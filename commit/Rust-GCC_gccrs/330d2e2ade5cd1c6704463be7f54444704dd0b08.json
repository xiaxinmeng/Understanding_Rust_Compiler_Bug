{"sha": "330d2e2ade5cd1c6704463be7f54444704dd0b08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMwZDJlMmFkZTVjZDFjNjcwNDQ2M2JlN2Y1NDQ0NDcwNGRkMGIwOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-07-10T14:13:01Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-07-10T14:13:01Z"}, "message": "gcov-io.h: Update documentation.\n\n\t* gcov-io.h: Update documentation.\n\t(GCOV_UNSIGNED2STRING): New.\n\t(GCOV_TAG_FUNCTION_LENGTH, GCOV_TAG_BLOCKS_LENGTH,\n\tGCOV_TAG_ARCS_LENGTH, GCOV_TAG_COUNTER_LENGTH,\n\tGCOV_TAG_SUMMARY_LENGTH): Adjust.\n\t(GCOV_TAG_BLOCKS_NUM, GCOV_TAG_ARCS_NUM,\n\tGCOV_TAG_COUNTER_NUM): New.\n\t(GCOV_BLOCK_SIZE): Number of words.\n\t(gcov_var): Adjust buffer type.\n\t* gcov-io.c (gcov_write_bytes, gcov_read_bytes): Rename to ...\n\t(gcov_write_words, gcov_read_words): ... here. Take a 4-byte word\n\tcount, not byte count.\n\t(gcov_open): Adjust overread init.\n\t(gcov_allocate, gcov_write_unsigned, gcov_write_counter,\n\tgcov_write_string, gcov_write_tag, gcov_write_length,\n\tgcov_write_tag_length): Adjust.\n\t(gcov_read_unsigned, gcov_read_counter, gcov_read_string): Adjust.\n\t(gcov_sync, gcov_seek): Adjust.\n\t* gcov-dump.c (print_usage): Show gcc version only.\n\t(dump_file): Use GCOV_UNSIGNED2STRING.\n\t(tag_blocks, tag_arcs, tag_counters): Use GCOV_TAG_*_NUM macros.\n\t* gcov.c (print_version): Show gcc version only.\n\t(read_graph_file): Use GCOV_UNSIGNED2STRING. Use\n\tGCOV_TAG_*_NUM macros.\n\t(read_count_file): Use GCOV_UNSIGNED2STRING. Use\n\tGCOV_TAG_COUNTER_LENGTH.\n\t* coverage.c (read_counts_file): Use GCOV_UNSIGNED2STRING.\n\tUse GCOV_TAG_COUNTER_NUM.\n\t* libgcov.c (gcov_version): Use GCOV_UNSIGNED2STRING.\n\t(__gcov_merge_single, __gcov_merge_delta): Use GCOV_CHECK.\n\nFrom-SVN: r69188", "tree": {"sha": "370e3a67dfb6cf6b6c2c94b4725e0c59b2c58223", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/370e3a67dfb6cf6b6c2c94b4725e0c59b2c58223"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/330d2e2ade5cd1c6704463be7f54444704dd0b08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/330d2e2ade5cd1c6704463be7f54444704dd0b08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/330d2e2ade5cd1c6704463be7f54444704dd0b08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/330d2e2ade5cd1c6704463be7f54444704dd0b08/comments", "author": null, "committer": null, "parents": [{"sha": "11791dbccca83858345c2dbb36b751c218fd4213", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11791dbccca83858345c2dbb36b751c218fd4213", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11791dbccca83858345c2dbb36b751c218fd4213"}], "stats": {"total": 279, "additions": 161, "deletions": 118}, "files": [{"sha": "359cf6d79e2acab6ba026de35a4d5aabe50110f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=330d2e2ade5cd1c6704463be7f54444704dd0b08", "patch": "@@ -1,3 +1,36 @@\n+2003-07-10  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcov-io.h: Update documentation.\n+\t(GCOV_UNSIGNED2STRING): New.\n+\t(GCOV_TAG_FUNCTION_LENGTH, GCOV_TAG_BLOCKS_LENGTH,\n+\tGCOV_TAG_ARCS_LENGTH, GCOV_TAG_COUNTER_LENGTH,\n+\tGCOV_TAG_SUMMARY_LENGTH): Adjust.\n+\t(GCOV_TAG_BLOCKS_NUM, GCOV_TAG_ARCS_NUM,\n+\tGCOV_TAG_COUNTER_NUM): New.\n+\t(GCOV_BLOCK_SIZE): Number of words.\n+\t(gcov_var): Adjust buffer type.\n+\t* gcov-io.c (gcov_write_bytes, gcov_read_bytes): Rename to ...\n+\t(gcov_write_words, gcov_read_words): ... here. Take a 4-byte word\n+\tcount, not byte count.\n+\t(gcov_open): Adjust overread init.\n+\t(gcov_allocate, gcov_write_unsigned, gcov_write_counter,\n+\tgcov_write_string, gcov_write_tag, gcov_write_length,\n+\tgcov_write_tag_length): Adjust.\n+\t(gcov_read_unsigned, gcov_read_counter, gcov_read_string): Adjust.\n+\t(gcov_sync, gcov_seek): Adjust.\n+\t* gcov-dump.c (print_usage): Show gcc version only.\n+\t(dump_file): Use GCOV_UNSIGNED2STRING.\n+\t(tag_blocks, tag_arcs, tag_counters): Use GCOV_TAG_*_NUM macros.\n+\t* gcov.c (print_version): Show gcc version only.\n+\t(read_graph_file): Use GCOV_UNSIGNED2STRING. Use\n+\tGCOV_TAG_*_NUM macros.\n+\t(read_count_file): Use GCOV_UNSIGNED2STRING. Use\n+\tGCOV_TAG_COUNTER_LENGTH.\n+\t* coverage.c (read_counts_file): Use GCOV_UNSIGNED2STRING.\n+\tUse GCOV_TAG_COUNTER_NUM.\n+\t* libgcov.c (gcov_version): Use GCOV_UNSIGNED2STRING.\n+\t(__gcov_merge_single, __gcov_merge_delta): Use GCOV_CHECK.\n+\n 2003-07-10  Andreas Schwab  <schwab@suse.de>\n \n \t* gcov-dump.c (dump_file): Fix missing address operator."}, {"sha": "252331776c4a116fff81d949d323ec29d71a683a", "filename": "gcc/coverage.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=330d2e2ade5cd1c6704463be7f54444704dd0b08", "patch": "@@ -167,10 +167,13 @@ read_counts_file (void)\n     }\n   else if ((tag = gcov_read_unsigned ()) != GCOV_VERSION)\n     {\n-      gcov_unsigned_t required = GCOV_VERSION;\n+      char v[4], e[4];\n+\n+      GCOV_UNSIGNED2STRING (v, tag);\n+      GCOV_UNSIGNED2STRING (e, GCOV_VERSION);\n \n       warning (\"`%s' is version `%.4s', expected version `%.4s'\",\n- \t       da_file_name, (const char *)&tag, (const char *)&required);\n+ \t       da_file_name, v, e);\n       gcov_close ();\n       return;\n     }\n@@ -229,7 +232,7 @@ read_counts_file (void)\n       else if (GCOV_TAG_IS_COUNTER (tag) && fn_ident)\n \t{\n \t  counts_entry_t **slot, *entry, elt;\n-\t  unsigned n_counts = length / 8;\n+\t  unsigned n_counts = GCOV_TAG_COUNTER_NUM (length);\n \t  unsigned ix;\n \n \t  elt.ident = fn_ident;"}, {"sha": "e0115622ab77e210f976dfc6026794f6b3b92cc4", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=330d2e2ade5cd1c6704463be7f54444704dd0b08", "patch": "@@ -117,16 +117,11 @@ print_usage (void)\n static void\n print_version (void)\n {\n-  char v[4];\n-  unsigned version = GCOV_VERSION;\n-  unsigned ix;\n-\n-  for (ix = 4; ix--; version >>= 8)\n-    v[ix] = version;\n-  printf (\"gcov %.4s (GCC %s)\\n\", v, version_string);\n-  printf (\"Copyright (C) 2002 Free Software Foundation, Inc.\\n\");\n-  printf (\"This is free software; see the source for copying conditions.  There is NO\\n\\\n-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\");\n+  printf (\"gcov-dump (GCC) %s\\n\", version_string);\n+  printf (\"Copyright (C) 2003 Free Software Foundation, Inc.\\n\");\n+  printf (\"This is free software; see the source for copying conditions.\\n\"\n+  \t  \"There is NO warranty; not even for MERCHANTABILITY or \\n\"\n+\t  \"FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\");\n }\n \n static void\n@@ -158,6 +153,7 @@ dump_file (const char *filename)\n     unsigned version;\n     const char *type = NULL;\n     int endianness = 0;\n+    char m[4], v[4];\n     \n     if ((endianness = gcov_magic (magic, GCOV_DATA_MAGIC)))\n       type = \"data\";\n@@ -170,16 +166,17 @@ dump_file (const char *filename)\n \treturn;\n       }\n     version = gcov_read_unsigned ();\n+    GCOV_UNSIGNED2STRING (v, version);\n+    GCOV_UNSIGNED2STRING (m, magic);\n     \n     printf (\"%s:%s:magic `%.4s':version `%.4s'%s\\n\", filename, type,\n- \t    (const char *)&magic, (const char *)&version,\n-\t    endianness < 0 ? \" (swapped endianness)\" : \"\");\n+ \t    m, v, endianness < 0 ? \" (swapped endianness)\" : \"\");\n     if (version != GCOV_VERSION)\n       {\n-\tunsigned expected = GCOV_VERSION;\n+\tchar e[4];\n \t\n-\tprintf (\"%s:warning:current version is `%.4s'\\n\", filename,\n-\t\t(const char *)&expected);\n+\tGCOV_UNSIGNED2STRING (e, GCOV_VERSION);\n+\tprintf (\"%s:warning:current version is `%.4s'\\n\", filename, e);\n       }\n   }\n \n@@ -287,7 +284,7 @@ static void\n tag_blocks (const char *filename ATTRIBUTE_UNUSED,\n \t    unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n {\n-  unsigned n_blocks = length / 4;\n+  unsigned n_blocks = GCOV_TAG_BLOCKS_NUM (length);\n \n   printf (\" %u blocks\", n_blocks);\n \n@@ -312,7 +309,7 @@ static void\n tag_arcs (const char *filename ATTRIBUTE_UNUSED,\n \t  unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n {\n-  unsigned n_arcs = (length - 4) / 8;\n+  unsigned n_arcs = GCOV_TAG_ARCS_NUM (length);\n \n   printf (\" %u arcs\", n_arcs);\n   if (flag_dump_contents)\n@@ -386,7 +383,7 @@ tag_counters (const char *filename ATTRIBUTE_UNUSED,\n \t      unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n {\n   static const char *const counter_names[] = GCOV_COUNTER_NAMES;\n-  unsigned n_counts = length / 8;\n+  unsigned n_counts = GCOV_TAG_COUNTER_NUM (length);\n \n   printf (\" %s %u counts\",\n \t  counter_names[GCOV_COUNTER_FOR_TAG (tag)], n_counts);"}, {"sha": "820b1f61701e64c8d3036c81b3e3e22450191c48", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=330d2e2ade5cd1c6704463be7f54444704dd0b08", "patch": "@@ -26,9 +26,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #if !IN_GCOV\n static void gcov_write_block (unsigned);\n-static gcov_unsigned_t *gcov_write_bytes (unsigned);\n+static gcov_unsigned_t *gcov_write_words (unsigned);\n #endif\n-static const gcov_unsigned_t *gcov_read_bytes (unsigned);\n+static const gcov_unsigned_t *gcov_read_words (unsigned);\n #if !IN_LIBGCOV\n static void gcov_allocate (unsigned);\n #endif\n@@ -77,7 +77,7 @@ gcov_open (const char *name, int mode)\n     abort ();\n   gcov_var.start = 0;\n   gcov_var.offset = gcov_var.length = 0;\n-  gcov_var.overread = -4u;\n+  gcov_var.overread = -1u;\n   gcov_var.error = 0;\n #if !IN_LIBGCOV\n   gcov_var.endian = 0;\n@@ -164,7 +164,7 @@ gcov_allocate (unsigned length)\n   new_size *= 2;\n   \n   gcov_var.alloc = new_size;\n-  gcov_var.buffer = xrealloc (gcov_var.buffer, new_size);\n+  gcov_var.buffer = xrealloc (gcov_var.buffer, new_size << 2);\n }\n #endif\n \n@@ -174,7 +174,7 @@ gcov_allocate (unsigned length)\n static void\n gcov_write_block (unsigned size)\n {\n-  if (fwrite (gcov_var.buffer, size, 1, gcov_var.file) != 1)\n+  if (fwrite (gcov_var.buffer, size << 2, 1, gcov_var.file) != 1)\n     gcov_var.error = 1;\n   gcov_var.start += size;\n   gcov_var.offset -= size;\n@@ -184,28 +184,27 @@ gcov_write_block (unsigned size)\n    pointer to those bytes, or NULL on failure.  */\n \n static gcov_unsigned_t *\n-gcov_write_bytes (unsigned bytes)\n+gcov_write_words (unsigned words)\n {\n   gcov_unsigned_t *result;\n \n   GCOV_CHECK_WRITING ();\n-  GCOV_CHECK (!(bytes & 3));\n #if IN_LIBGCOV\n   if (gcov_var.offset >= GCOV_BLOCK_SIZE)\n     {\n       gcov_write_block (GCOV_BLOCK_SIZE);\n       if (gcov_var.offset)\n \t{\n-\t  GCOV_CHECK (gcov_var.offset == 4);\n+\t  GCOV_CHECK (gcov_var.offset == 1);\n \t  memcpy (gcov_var.buffer, gcov_var.buffer + GCOV_BLOCK_SIZE, 4);\n \t}\n     }\n #else\n-  if (gcov_var.offset + bytes > gcov_var.alloc)\n-    gcov_allocate (gcov_var.offset + bytes);\n+  if (gcov_var.offset + words > gcov_var.alloc)\n+    gcov_allocate (gcov_var.offset + words);\n #endif\n-  result = (gcov_unsigned_t *)&gcov_var.buffer[gcov_var.offset];\n-  gcov_var.offset += bytes;\n+  result = &gcov_var.buffer[gcov_var.offset];\n+  gcov_var.offset += words;\n   \n   return result;\n }\n@@ -216,7 +215,7 @@ gcov_write_bytes (unsigned bytes)\n GCOV_LINKAGE void\n gcov_write_unsigned (gcov_unsigned_t value)\n {\n-  gcov_unsigned_t *buffer = gcov_write_bytes (4);\n+  gcov_unsigned_t *buffer = gcov_write_words (1);\n \n   buffer[0] = value;\n }\n@@ -228,7 +227,7 @@ gcov_write_unsigned (gcov_unsigned_t value)\n GCOV_LINKAGE void\n gcov_write_counter (gcov_type value)\n {\n-  gcov_unsigned_t *buffer = gcov_write_bytes (8);\n+  gcov_unsigned_t *buffer = gcov_write_words (2);\n \n   buffer[0] = (gcov_unsigned_t) value;\n   if (sizeof (value) > sizeof (gcov_unsigned_t))\n@@ -258,7 +257,7 @@ gcov_write_string (const char *string)\n       alloc = (length + 4) >> 2;\n     }\n   \n-  buffer = gcov_write_bytes (4 + alloc * 4);\n+  buffer = gcov_write_words (1 + alloc);\n \n   buffer[0] = alloc;\n   buffer[alloc] = 0;\n@@ -274,7 +273,7 @@ GCOV_LINKAGE gcov_position_t\n gcov_write_tag (gcov_unsigned_t tag)\n {\n   gcov_position_t result = gcov_var.start + gcov_var.offset;\n-  gcov_unsigned_t *buffer = gcov_write_bytes (8);\n+  gcov_unsigned_t *buffer = gcov_write_words (2);\n \n   buffer[0] = tag;\n   buffer[1] = 0;\n@@ -295,10 +294,10 @@ gcov_write_length (gcov_position_t position)\n   gcov_unsigned_t *buffer;\n \n   GCOV_CHECK_WRITING ();\n-  GCOV_CHECK (position + 8 <= gcov_var.start + gcov_var.offset);\n+  GCOV_CHECK (position + 2 <= gcov_var.start + gcov_var.offset);\n   GCOV_CHECK (position >= gcov_var.start);\n   offset = position - gcov_var.start;\n-  length = gcov_var.offset - offset - 8;\n+  length = gcov_var.offset - offset - 2;\n   buffer = (gcov_unsigned_t *) &gcov_var.buffer[offset];\n   buffer[1] = length;\n   if (gcov_var.offset >= GCOV_BLOCK_SIZE)\n@@ -312,7 +311,7 @@ gcov_write_length (gcov_position_t position)\n GCOV_LINKAGE void\n gcov_write_tag_length (gcov_unsigned_t tag, gcov_unsigned_t length)\n {\n-  gcov_unsigned_t *buffer = gcov_write_bytes (8);\n+  gcov_unsigned_t *buffer = gcov_write_words (2);\n \n   buffer[0] = tag;\n   buffer[1] = length;\n@@ -346,20 +345,19 @@ gcov_write_summary (gcov_unsigned_t tag, const struct gcov_summary *summary)\n    NULL on failure (read past EOF).  */\n \n static const gcov_unsigned_t *\n-gcov_read_bytes (unsigned bytes)\n+gcov_read_words (unsigned words)\n {\n   const gcov_unsigned_t *result;\n   unsigned excess = gcov_var.length - gcov_var.offset;\n   \n   GCOV_CHECK_READING ();\n-  GCOV_CHECK (!(bytes & 3));\n-  if (excess < bytes)\n+  if (excess < words)\n     {\n       gcov_var.start += gcov_var.offset;\n #if IN_LIBGCOV\n       if (excess)\n \t{\n-\t  GCOV_CHECK (excess == 4);\n+\t  GCOV_CHECK (excess == 1);\n \t  memcpy (gcov_var.buffer, gcov_var.buffer + gcov_var.offset, 4);\n \t}\n #else\n@@ -368,25 +366,25 @@ gcov_read_bytes (unsigned bytes)\n       gcov_var.offset = 0;\n       gcov_var.length = excess;\n #if IN_LIBGCOV\n-      GCOV_CHECK (!gcov_var.length || gcov_var.length == 4);\n+      GCOV_CHECK (!gcov_var.length || gcov_var.length == 1);\n       excess = GCOV_BLOCK_SIZE;\n #else\n-      if (gcov_var.length + bytes > gcov_var.alloc)\n-\tgcov_allocate (gcov_var.length + bytes);\n+      if (gcov_var.length + words > gcov_var.alloc)\n+\tgcov_allocate (gcov_var.length + words);\n       excess = gcov_var.alloc - gcov_var.length;\n #endif\n       excess = fread (gcov_var.buffer + gcov_var.length,\n-\t\t      1, excess, gcov_var.file);\n+\t\t      1, excess << 2, gcov_var.file) >> 2;\n       gcov_var.length += excess;\n-      if (gcov_var.length < bytes)\n+      if (gcov_var.length < words)\n \t{\n-\t  gcov_var.overread += bytes - gcov_var.length;\n+\t  gcov_var.overread += words - gcov_var.length;\n \t  gcov_var.length = 0;\n \t  return 0;\n \t}\n     }\n-  result = (gcov_unsigned_t *)&gcov_var.buffer[gcov_var.offset];\n-  gcov_var.offset += bytes;\n+  result = &gcov_var.buffer[gcov_var.offset];\n+  gcov_var.offset += words;\n   return result;\n }\n \n@@ -397,7 +395,7 @@ GCOV_LINKAGE gcov_unsigned_t\n gcov_read_unsigned (void)\n {\n   gcov_unsigned_t value;\n-  const gcov_unsigned_t *buffer = gcov_read_bytes (4);\n+  const gcov_unsigned_t *buffer = gcov_read_words (1);\n \n   if (!buffer)\n     return 0;\n@@ -412,7 +410,7 @@ GCOV_LINKAGE gcov_type\n gcov_read_counter (void)\n {\n   gcov_type value;\n-  const gcov_unsigned_t *buffer = gcov_read_bytes (8);\n+  const gcov_unsigned_t *buffer = gcov_read_words (2);\n \n   if (!buffer)\n     return 0;\n@@ -440,7 +438,7 @@ gcov_read_string (void)\n   if (!length)\n     return 0;\n \n-  return (const char *) gcov_read_bytes (length);\n+  return (const char *) gcov_read_words (length);\n }\n #endif\n \n@@ -475,8 +473,8 @@ gcov_sync (gcov_position_t base, gcov_unsigned_t length)\n   else\n     {\n       gcov_var.offset = gcov_var.length = 0;\n-      fseek (gcov_var.file, base, SEEK_SET);\n-      gcov_var.start = ftell (gcov_var.file);\n+      fseek (gcov_var.file, base << 2, SEEK_SET);\n+      gcov_var.start = ftell (gcov_var.file) >> 2;\n     }\n }\n #endif\n@@ -491,8 +489,8 @@ gcov_seek (gcov_position_t base)\n   GCOV_CHECK_WRITING ();\n   if (gcov_var.offset)\n     gcov_write_block (gcov_var.offset);\n-  fseek (gcov_var.file, base, base ? SEEK_SET : SEEK_END);\n-  gcov_var.start = ftell (gcov_var.file);\n+  fseek (gcov_var.file, base << 2, base ? SEEK_SET : SEEK_END);\n+  gcov_var.start = ftell (gcov_var.file) >> 2;\n }\n #endif\n "}, {"sha": "018b020ec378f0feff96e6861b6f45f4047d8c22", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=330d2e2ade5cd1c6704463be7f54444704dd0b08", "patch": "@@ -41,8 +41,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Numbers are recorded in the 32 bit unsigned binary form of the\n    endianness of the machine generating the file. 64 bit numbers are\n    stored as two 32 bit numbers, the low part first.  Strings are\n-   stored as length rounded up to 4 followed by the string and then 1\n-   to 4 NUL bytes.  Zero length and NULL strings are simply stored as\n+   padded with 1 to 4 NUL bytes, to bring the length up to a multiple\n+   of 4. The number of 4 bytes is stored, followed by the padded\n+   string. Zero length and NULL strings are simply stored as\n    a length of zero (they have no trailing NUL or padding).\n \n    \tint32:  byte3 byte2 byte1 byte0 | byte0 byte1 byte2 byte3\n@@ -89,16 +90,17 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Records are not nested, but there is a record hierarchy.  Tag\n    numbers reflect this hierarchy.  Tags are unique across note and\n    data files.  Some record types have a varying amount of data.  The\n-   LENGTH is usually used to determine how much data.  The tag value\n-   is split into 4 8-bit fields, one for each of four possible levels.\n-   The most significant is allocated first.  Unused levels are zero.\n-   Active levels are odd-valued, so that the LSB of the level is one.\n-   A sub-level incorporates the values of its superlevels.  This\n-   formatting allows you to determine the tag hierarchy, without\n-   understanding the tags themselves, and is similar to the standard\n-   section numbering used in technical documents.  Level values\n-   [1..3f] are used for common tags, values [41..9f] for the notes\n-   file and [a1..ff] for the data file.\n+   LENGTH is the number of 4bytes that follow and is usually used to\n+   determine how much data.  The tag value is split into 4 8-bit\n+   fields, one for each of four possible levels.  The most significant\n+   is allocated first.  Unused levels are zero.  Active levels are\n+   odd-valued, so that the LSB of the level is one.  A sub-level\n+   incorporates the values of its superlevels.  This formatting allows\n+   you to determine the tag hierarchy, without understanding the tags\n+   themselves, and is similar to the standard section numbering used\n+   in technical documents.  Level values [1..3f] are used for common\n+   tags, values [41..9f] for the notes file and [a1..ff] for the data\n+   file.\n \n    The basic block graph file contains the following records\n    \tnote: unit function-graph*\n@@ -252,23 +254,33 @@ typedef HOST_WIDEST_INT gcov_type;\n */\n #include \"gcov-iov.h\"\n \n+/* Convert a magic or version number to a 4 character string.  */\n+#define GCOV_UNSIGNED2STRING(ARRAY,VALUE)\t\\\n+  ((ARRAY)[0] = (char)((VALUE) >> 24),\t\t\\\n+   (ARRAY)[1] = (char)((VALUE) >> 16),\t\t\\\n+   (ARRAY)[2] = (char)((VALUE) >> 8),\t\t\\\n+   (ARRAY)[3] = (char)((VALUE) >> 0))\n+\n /* The record tags.  Values [1..3f] are for tags which may be in either\n    file.  Values [41..9f] for those in the note file and [a1..ff] for\n    the data file.  */\n \n #define GCOV_TAG_FUNCTION\t ((gcov_unsigned_t)0x01000000)\n-#define GCOV_TAG_FUNCTION_LENGTH (2 * 4)\n+#define GCOV_TAG_FUNCTION_LENGTH (2)\n #define GCOV_TAG_BLOCKS\t\t ((gcov_unsigned_t)0x01410000)\n-#define GCOV_TAG_BLOCKS_LENGTH(NUM) ((NUM) * 4)\n+#define GCOV_TAG_BLOCKS_LENGTH(NUM) (NUM)\n+#define GCOV_TAG_BLOCKS_NUM(LENGTH) (LENGTH)\n #define GCOV_TAG_ARCS\t\t ((gcov_unsigned_t)0x01430000)\n-#define GCOV_TAG_ARCS_LENGTH(NUM)  (1 * 4 + (NUM) * (2 * 4))\n+#define GCOV_TAG_ARCS_LENGTH(NUM)  (1 + (NUM) * 2)\n+#define GCOV_TAG_ARCS_NUM(LENGTH)  (((LENGTH) - 1) / 2)\n #define GCOV_TAG_LINES\t\t ((gcov_unsigned_t)0x01450000)\n #define GCOV_TAG_COUNTER_BASE \t ((gcov_unsigned_t)0x01a10000)\n-#define GCOV_TAG_COUNTER_LENGTH(NUM) ((NUM) * 8)\n+#define GCOV_TAG_COUNTER_LENGTH(NUM) ((NUM) * 2)\n+#define GCOV_TAG_COUNTER_NUM(LENGTH) ((LENGTH) / 2)\n #define GCOV_TAG_OBJECT_SUMMARY  ((gcov_unsigned_t)0xa1000000)\n #define GCOV_TAG_PROGRAM_SUMMARY ((gcov_unsigned_t)0xa3000000)\n #define GCOV_TAG_SUMMARY_LENGTH  \\\n-\t(1 * 4 + GCOV_COUNTERS_SUMMABLE * (2 * 4 + 3 * 8))\n+\t(1 + GCOV_COUNTERS_SUMMABLE * (2 + 3 * 2))\n \n /* Counters that are collected.  */\n #define GCOV_COUNTER_ARCS \t0  /* Arc transitions.  */\n@@ -407,30 +419,30 @@ extern void __gcov_merge_delta (gcov_type *, unsigned);\n \n #if IN_LIBGCOV >= 0\n \n-/* Optimum size read from or written to disk.  */\n-#define GCOV_BLOCK_SIZE (1 << 12)\n+/* Optimum number of gcov_unsigned_t's read from or written to disk.  */\n+#define GCOV_BLOCK_SIZE (1 << 10)\n \n GCOV_LINKAGE struct gcov_var\n {\n   FILE *file;\n   gcov_position_t start;\t/* Position of first byte of block */\n   unsigned offset;\t\t/* Read/write position within the block.  */\n   unsigned length;\t\t/* Read limit in the block.  */\n-  unsigned overread;\t\t/* Number of bytes overread.  */\n+  unsigned overread;\t\t/* Number of words overread.  */\n   int error;\t\t\t/* < 0 overflow, > 0 disk error.  */\n   int mode;\t                /* < 0 writing, > 0 reading */\n #if IN_LIBGCOV\n   /* Holds one block plus 4 bytes, thus all coverage reads & writes\n      fit within this buffer and we always can transfer GCOV_BLOCK_SIZE\n      to and from the disk. libgcov never backtracks and only writes 4\n      or 8 byte objects.  */\n-  char buffer[GCOV_BLOCK_SIZE + 4] __attribute__ ((aligned (4)));\n+  gcov_unsigned_t buffer[GCOV_BLOCK_SIZE + 1];\n #else\n   int endian;\t\t\t/* Swap endianness.  */\n   /* Holds a variable length block, as the compiler can write\n      strings and needs to backtrack.  */\n   size_t alloc;\n-  char *buffer;\n+  gcov_unsigned_t *buffer;\n #endif\n } gcov_var;\n "}, {"sha": "cc15f65fa54c2ebaae7c74df61a80fc9cc515326", "filename": "gcc/gcov.c", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=330d2e2ade5cd1c6704463be7f54444704dd0b08", "patch": "@@ -417,14 +417,12 @@ print_usage (int error_p)\n static void\n print_version (void)\n {\n-  unsigned version = GCOV_VERSION;\n-\n-  fnotice (stdout, \"gcov %.4s (GCC %s)\\n\",\n-\t   (const char *)&version, version_string);\n-  fnotice (stdout, \"Copyright (C) 2002 Free Software Foundation, Inc.\\n\");\n+  fnotice (stdout, \"gcov (GCC) %s\\n\", version_string);\n+  fnotice (stdout, \"Copyright (C) 2003 Free Software Foundation, Inc.\\n\");\n   fnotice (stdout,\n-\t   \"This is free software; see the source for copying conditions.  There is NO\\n\\\n-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\");\n+\t   \"This is free software; see the source for copying conditions.\\n\"\n+  \t   \"There is NO warranty; not even for MERCHANTABILITY or \\n\"\n+\t   \"FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\");\n   exit (SUCCESS_EXIT_CODE);\n }\n \n@@ -723,13 +721,10 @@ read_graph_file (void)\n   if (version != GCOV_VERSION)\n     {\n       char v[4], e[4];\n-      unsigned required = GCOV_VERSION;\n \n-      for (ix = 4; ix--; required >>= 8, version >>= 8)\n-\t{\n-\t  v[ix] = version;\n-\t  e[ix] = required;\n-\t}\n+      GCOV_UNSIGNED2STRING (v, version);\n+      GCOV_UNSIGNED2STRING (e, GCOV_VERSION);\n+\n       fnotice (stderr, \"%s:version `%.4s', prefer `%.4s'\\n\",\n \t       bbg_file_name, v, e);\n     }\n@@ -786,7 +781,7 @@ read_graph_file (void)\n \t\t     bbg_file_name, fn->name);\n \t  else\n \t    {\n-\t      unsigned ix, num_blocks = length / 4;\n+\t      unsigned ix, num_blocks = GCOV_TAG_BLOCKS_NUM (length);\n \t      fn->num_blocks = num_blocks;\n \n \t      fn->blocks\n@@ -798,7 +793,7 @@ read_graph_file (void)\n       else if (fn && tag == GCOV_TAG_ARCS)\n \t{\n \t  unsigned src = gcov_read_unsigned ();\n-\t  unsigned num_dests = (length - 4) / 8;\n+\t  unsigned num_dests = GCOV_TAG_ARCS_NUM (length);\n \n \t  if (src >= fn->num_blocks || fn->blocks[src].succ)\n \t    goto corrupt;\n@@ -857,7 +852,7 @@ read_graph_file (void)\n \t{\n \t  unsigned blockno = gcov_read_unsigned ();\n \t  unsigned *line_nos\n-\t    = (unsigned *)xcalloc ((length - 4) / 4, sizeof (unsigned));\n+\t    = (unsigned *)xcalloc (length - 1, sizeof (unsigned));\n \n \t  if (blockno >= fn->num_blocks || fn->blocks[blockno].u.line.encoding)\n \t    goto corrupt;\n@@ -991,10 +986,13 @@ read_count_file (void)\n   version = gcov_read_unsigned ();\n   if (version != GCOV_VERSION)\n     {\n-      unsigned desired = GCOV_VERSION;\n+      char v[4], e[4];\n+\n+      GCOV_UNSIGNED2STRING (v, version);\n+      GCOV_UNSIGNED2STRING (e, GCOV_VERSION);\n       \n       fnotice (stderr, \"%s:version `%.4s', prefer version `%.4s'\\n\",\n-\t       da_file_name, (const char *)&version, (const char *)&desired);\n+\t       da_file_name, v, e);\n     }\n   tag = gcov_read_unsigned ();\n   if (tag != bbg_stamp)\n@@ -1045,7 +1043,7 @@ read_count_file (void)\n \t}\n       else if (tag == GCOV_TAG_FOR_COUNTER (GCOV_COUNTER_ARCS) && fn)\n \t{\n-\t  if (length != 8 * fn->num_counts)\n+\t  if (length != GCOV_TAG_COUNTER_LENGTH (fn->num_counts))\n \t    goto mismatch;\n \n \t  if (!fn->counts)"}, {"sha": "140ab05bf1c68242cadcef7c07e6f759d0d733a0", "filename": "gcc/libgcov.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/330d2e2ade5cd1c6704463be7f54444704dd0b08/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=330d2e2ade5cd1c6704463be7f54444704dd0b08", "patch": "@@ -94,13 +94,16 @@ static gcov_unsigned_t gcov_crc32;\n static int\n gcov_version (struct gcov_info *ptr, gcov_unsigned_t version)\n {\n-  gcov_unsigned_t expected = GCOV_VERSION;\n-\n   if (version != GCOV_VERSION)\n     {\n+      char v[4], e[4];\n+\n+      GCOV_UNSIGNED2STRING (v, version);\n+      GCOV_UNSIGNED2STRING (e, GCOV_VERSION);\n+      \n       fprintf (stderr,\n \t       \"profiling:%s:Version mismatch - expected %.4s got %.4s\\n\",\n-\t       ptr->filename, (const char *)&expected, (const char *)&version);\n+\t       ptr->filename, e, v);\n       return 0;\n     }\n   return 1;\n@@ -478,10 +481,12 @@ __gcov_merge_add (gcov_type *counters, unsigned n_counters)\n #endif /* L_gcov_merge_add */\n \n #ifdef L_gcov_merge_single\n-/* The profile merging function for choosing the most common value.  It is given\n-   an array COUNTERS of N_COUNTERS old counters and it reads the same number\n-   of counters from the gcov file.  The counters are split into 3-tuples\n-   where the members of the tuple have meanings:\n+/* The profile merging function for choosing the most common value.\n+   It is given an array COUNTERS of N_COUNTERS old counters and it\n+   reads the same number of counters from the gcov file.  The counters\n+   are split into 3-tuples where the members of the tuple have\n+   meanings:\n+   \n    -- the stored candidate on the most common value of the measured entity\n    -- counter\n    -- total number of evaluations of the value  */\n@@ -491,9 +496,7 @@ __gcov_merge_single (gcov_type *counters, unsigned n_counters)\n   unsigned i, n_measures;\n   gcov_type value, counter, all;\n \n-  if (n_counters % 3)\n-    abort ();\n-\n+  GCOV_CHECK (!(n_counters % 3));\n   n_measures = n_counters / 3;\n   for (i = 0; i < n_measures; i++, counters += 3)\n     {\n@@ -516,11 +519,12 @@ __gcov_merge_single (gcov_type *counters, unsigned n_counters)\n #endif /* L_gcov_merge_single */\n \n #ifdef L_gcov_merge_delta\n-/* The profile merging function for choosing the most common difference between\n-   two consecutive evaluations of the value.  It is given an array COUNTERS of\n-   N_COUNTERS old counters and it reads the same number of counters from the\n-   gcov file.  The counters are split into 4-tuples where the members of the\n-   tuple have meanings:\n+/* The profile merging function for choosing the most common\n+   difference between two consecutive evaluations of the value.  It is\n+   given an array COUNTERS of N_COUNTERS old counters and it reads the\n+   same number of counters from the gcov file.  The counters are split\n+   into 4-tuples where the members of the tuple have meanings:\n+   \n    -- the last value of the measured entity\n    -- the stored candidate on the most common difference\n    -- counter\n@@ -531,9 +535,7 @@ __gcov_merge_delta (gcov_type *counters, unsigned n_counters)\n   unsigned i, n_measures;\n   gcov_type last, value, counter, all;\n \n-  if (n_counters % 4)\n-    abort ();\n-\n+  GCOV_CHECK (!(n_counters % 4));\n   n_measures = n_counters / 4;\n   for (i = 0; i < n_measures; i++, counters += 4)\n     {"}]}