{"sha": "35b1a6faebd652c6d95cc709ddf8af02ff0feced", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzViMWE2ZmFlYmQ2NTJjNmQ5NWNjNzA5ZGRmOGFmMDJmZjBmZWNlZA==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-19T19:43:59Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-19T19:43:59Z"}, "message": "c-aux-info.c: Convert to ISO C99.\n\n\n\t* c-aux-info.c: Convert to ISO C99.\n\t* c-pragma.c: Likewise.\n\t* c-common.c: Likewise.\n\t* c-common.h: Likewise.\n\t* c-convert.c: Likewise.\n\t* c-cppbuiltin.c: Likewise.\n\t* c-dump.c: Likewise.\n\t* c-decl.c: Likewise\n\t* c-format.c: Likewise.\n\t* c-incpath.c: Likewise.\n\t* c-incpath.h: Likewise.\n\nFrom-SVN: r68218", "tree": {"sha": "fd1cc81909b4c6acb6b6330a8a8b58659c5e5ba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd1cc81909b4c6acb6b6330a8a8b58659c5e5ba3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35b1a6faebd652c6d95cc709ddf8af02ff0feced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b1a6faebd652c6d95cc709ddf8af02ff0feced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35b1a6faebd652c6d95cc709ddf8af02ff0feced", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b1a6faebd652c6d95cc709ddf8af02ff0feced/comments", "author": null, "committer": null, "parents": [{"sha": "6dab8d4cdf065d4045132d01e9c2556bdcab4195", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dab8d4cdf065d4045132d01e9c2556bdcab4195", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dab8d4cdf065d4045132d01e9c2556bdcab4195"}], "stats": {"total": 1967, "additions": 752, "deletions": 1215}, "files": [{"sha": "b89b26f9f08ea64473e32381bf58ed83f6a9745a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35b1a6faebd652c6d95cc709ddf8af02ff0feced", "patch": "@@ -1,3 +1,17 @@\n+2003-06-19  Andreas Jaeger  <aj@suse.de>\n+\n+\t* c-aux-info.c: Convert to ISO C99.\n+\t* c-pragma.c: Likewise.\n+\t* c-common.c: Likewise.\n+\t* c-common.h: Likewise.\n+\t* c-convert.c: Likewise.\n+\t* c-cppbuiltin.c: Likewise.\n+\t* c-dump.c: Likewise.\n+\t* c-decl.c: Likewise\n+\t* c-format.c: Likewise.\n+\t* c-incpath.c: Likewise.\n+\t* c-incpath.h: Likewise.\n+\n 2003-06-19  Roger Sayle  <roger@eyesopen.com>\n \n \t* builtins.c (expand_errno_check): Assume that flag_errno_math\n@@ -11,7 +25,7 @@\n \tthe args after the main switch, and don't modify the orginal exp.\n \n 2003-06-19  Aldy Hernandez  <aldyh@redhat.com>\n- \n+\n         * expr.c (const_vector_from_tree): Initialize remaining elements\n         to 0.\n \n@@ -143,7 +157,7 @@\n         Support configuring with --with-cpu=iwmmxt.\n \t* doc/invoke.texi: Document new value for -mcpu= ARM switch.\n         * config/arm/aof.h (REGISTER_NAMES): Add iwmmxt register\n-\tnames.  Fix formatting.        \n+\tnames.  Fix formatting.\n         * config/arm/aout.h (REGISTER_NAMES): Add iwmmxt register\n \tnames.\n         * config/arm/arm-protos.h (arm_emit_vector_const): New\n@@ -314,7 +328,7 @@\n \n 2003-06-17  Ranjit Mathew  <rmathew@hotmail.com>\n             Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n-\t\n+\n \t* doc/sourcebuild.texi (libgcj Tests): Simplify instructions on how\n \tto run Java runtime tests separately.\n "}, {"sha": "b0a9ef040b703676365df8585ead6b865b05d05c", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=35b1a6faebd652c6d95cc709ddf8af02ff0feced", "patch": "@@ -2,7 +2,7 @@\n    on information stored in GCC's tree structure.  This code implements the\n    -aux-info option.\n    Copyright (C) 1989, 1991, 1994, 1995, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2003 Free Software Foundation, Inc.\n    Contributed by Ron Guilmette (rfg@segfault.us.com).\n \n This file is part of GCC.\n@@ -41,12 +41,12 @@ typedef enum formals_style_enum formals_style;\n \n static const char *data_type;\n \n-static char *affix_data_type\t\tPARAMS ((const char *)) ATTRIBUTE_MALLOC;\n-static const char *gen_formal_list_for_type PARAMS ((tree, formals_style));\n-static int   deserves_ellipsis\t\tPARAMS ((tree));\n-static const char *gen_formal_list_for_func_def PARAMS ((tree, formals_style));\n-static const char *gen_type\t\tPARAMS ((const char *, tree, formals_style));\n-static const char *gen_decl\t\tPARAMS ((tree, int, formals_style));\n+static char *affix_data_type (const char *) ATTRIBUTE_MALLOC;\n+static const char *gen_formal_list_for_type (tree, formals_style);\n+static int   deserves_ellipsis (tree);\n+static const char *gen_formal_list_for_func_def (tree, formals_style);\n+static const char *gen_type (const char *, tree, formals_style);\n+static const char *gen_decl (tree, int, formals_style);\n \f\n /* Given a string representing an entire type or an entire declaration\n    which only lacks the actual \"data-type\" specifier (at its left end),\n@@ -63,8 +63,7 @@ static const char *gen_decl\t\tPARAMS ((tree, int, formals_style));\n    that look as expected.  */\n \n static char *\n-affix_data_type (param)\n-     const char *param;\n+affix_data_type (const char *param)\n {\n   char *const type_or_decl = ASTRDUP (param);\n   char *p = type_or_decl;\n@@ -110,9 +109,7 @@ affix_data_type (param)\n    of empty parens here.  */\n \n static const char *\n-gen_formal_list_for_type (fntype, style)\n-     tree fntype;\n-     formals_style style;\n+gen_formal_list_for_type (tree fntype, formals_style style)\n {\n   const char *formal_list = \"\";\n   tree formal_type;\n@@ -194,8 +191,7 @@ gen_formal_list_for_type (fntype, style)\n    if the \"function type\" parameter list should end with an ellipsis.  */\n \n static int\n-deserves_ellipsis (fntype)\n-     tree fntype;\n+deserves_ellipsis (tree fntype)\n {\n   tree formal_type;\n \n@@ -230,9 +226,7 @@ deserves_ellipsis (fntype)\n    function formal parameter list.  */\n \n static const char *\n-gen_formal_list_for_func_def (fndecl, style)\n-     tree fndecl;\n-     formals_style style;\n+gen_formal_list_for_func_def (tree fndecl, formals_style style)\n {\n   const char *formal_list = \"\";\n   tree formal_decl;\n@@ -305,10 +299,7 @@ gen_formal_list_for_func_def (fndecl, style)\n    string onto the returned \"seed\".  */\n \n static const char *\n-gen_type (ret_val, t, style)\n-     const char *ret_val;\n-     tree t;\n-     formals_style style;\n+gen_type (const char *ret_val, tree t, formals_style style)\n {\n   tree chain_p;\n \n@@ -434,13 +425,13 @@ gen_type (ret_val, t, style)\n         case TYPE_DECL:\n           data_type = IDENTIFIER_POINTER (DECL_NAME (t));\n           break;\n- \n+\n         case INTEGER_TYPE:\n           data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));\n           /* Normally, `unsigned' is part of the deal.  Not so if it comes\n-    \t     with a type qualifier.  */\n+\t     with a type qualifier.  */\n           if (TREE_UNSIGNED (t) && TYPE_QUALS (t))\n-    \t    data_type = concat (\"unsigned \", data_type, NULL);\n+\t    data_type = concat (\"unsigned \", data_type, NULL);\n \t  break;\n \n         case REAL_TYPE:\n@@ -479,10 +470,7 @@ gen_type (ret_val, t, style)\n    an attached list of DECL nodes for function formal arguments is present.  */\n \n static const char *\n-gen_decl (decl, is_func_definition, style)\n-     tree decl;\n-     int is_func_definition;\n-     formals_style style;\n+gen_decl (tree decl, int is_func_definition, formals_style style)\n {\n   const char *ret_val;\n \n@@ -560,11 +548,8 @@ extern FILE *aux_info_file;\n    function definition (even the implicit ones).  */\n \n void\n-gen_aux_info_record (fndecl, is_definition, is_implicit, is_prototyped)\n-     tree fndecl;\n-     int is_definition;\n-     int is_implicit;\n-     int is_prototyped;\n+gen_aux_info_record (tree fndecl, int is_definition, int is_implicit,\n+\t\t     int is_prototyped)\n {\n   if (flag_gen_aux_info)\n     {"}, {"sha": "5bb3b44a3ffed84e99cac57636dd4414ca50ee86", "filename": "gcc/c-common.c", "status": "modified", "additions": 313, "deletions": 549, "changes": 862, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=35b1a6faebd652c6d95cc709ddf8af02ff0feced", "patch": "@@ -180,7 +180,7 @@ enum c_language_kind c_language;\n \ttree c99_function_name_decl_node;\n \n   Stack of nested function name VAR_DECLs.\n-  \n+\n \ttree saved_function_name_decls;\n \n */\n@@ -328,9 +328,9 @@ int warn_char_subscripts;\n \n int warn_conversion;\n \n-/* Warn about #pragma directives that are not recognized.  */      \n+/* Warn about #pragma directives that are not recognized.  */\n \n-int warn_unknown_pragmas; /* Tri state variable.  */  \n+int warn_unknown_pragmas; /* Tri state variable.  */\n \n /* Warn about format/argument anomalies in calls to formatted I/O functions\n    (*printf, *scanf, strftime, strfmon, etc.).  */\n@@ -432,8 +432,8 @@ int warn_div_by_zero = 1;\n int warn_implicit_int;\n \n /* Warn about NULL being passed to argument slots marked as requiring\n-   non-NULL.  */ \n-      \n+   non-NULL.  */\n+\n int warn_nonnull;\n \n \n@@ -476,7 +476,7 @@ int warn_selector;\n \n int warn_undeclared_selector;\n \n-/* Warn if methods required by a protocol are not implemented in the \n+/* Warn if methods required by a protocol are not implemented in the\n    class adopting it.  When turned off, methods inherited to that\n    class are also considered implemented.  */\n \n@@ -595,7 +595,7 @@ int flag_enforce_eh_specs = 1;\n /*  The version of the C++ ABI in use.  The following values are\n     allowed:\n \n-    0: The version of the ABI believed most conformant with the \n+    0: The version of the ABI believed most conformant with the\n        C++ ABI specification.  This ABI may change as bugs are\n        discovered and fixed.  Therefore, 0 will not necessarily\n        indicate the same ABI in different versions of G++.\n@@ -613,7 +613,7 @@ int flag_abi_version = 1;\n int warn_abi = 0;\n \n /* Nonzero means warn about invalid uses of offsetof. */\n- \n+\n int warn_invalid_offsetof = 1;\n \n /* Nonzero means warn about implicit declarations.  */\n@@ -683,11 +683,11 @@ int max_tinst_depth = 500;\n    type names and storage classes.  It is indexed by a RID_... value.  */\n tree *ridpointers;\n \n-tree (*make_fname_decl)                PARAMS ((tree, int));\n+tree (*make_fname_decl) (tree, int);\n \n /* If non-NULL, the address of a language-specific function that takes\n    any action required right before expand_function_end is called.  */\n-void (*lang_expand_function_end)       PARAMS ((void));\n+void (*lang_expand_function_end) (void);\n \n /* Nonzero means the expression being parsed will never be evaluated.\n    This is a count, since unevaluated expressions can nest.  */\n@@ -714,7 +714,7 @@ const struct fname_var_t fname_vars[] =\n   {NULL, 0, 0},\n };\n \n-static int constant_fits_type_p\t\tPARAMS ((tree, tree));\n+static int constant_fits_type_p (tree, tree);\n \n /* Keep a stack of if statements.  We record the number of compound\n    statements seen up to the if keyword, as well as the line number\n@@ -737,78 +737,55 @@ static int if_stack_space = 0;\n /* Stack pointer.  */\n static int if_stack_pointer = 0;\n \n-static tree handle_packed_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_nocommon_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_common_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_noreturn_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_noinline_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_always_inline_attribute PARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t    bool *));\n-static tree handle_used_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_unused_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_const_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_transparent_union_attribute PARAMS ((tree *, tree, tree,\n-\t\t\t\t\t\t\tint, bool *));\n-static tree handle_constructor_attribute PARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t  bool *));\n-static tree handle_destructor_attribute PARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_mode_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_section_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_aligned_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_weak_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_alias_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_visibility_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_tls_model_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_no_instrument_function_attribute PARAMS ((tree *, tree,\n-\t\t\t\t\t\t\t     tree, int,\n-\t\t\t\t\t\t\t     bool *));\n-static tree handle_malloc_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_no_limit_stack_attribute PARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t     bool *));\n-static tree handle_pure_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_deprecated_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_vector_size_attribute PARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t  bool *));\n-static tree handle_nonnull_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_nothrow_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree handle_cleanup_attribute\tPARAMS ((tree *, tree, tree, int,\n-\t\t\t\t\t\t bool *));\n-static tree vector_size_helper PARAMS ((tree, tree));\n-\n-static void check_function_nonnull\tPARAMS ((tree, tree));\n-static void check_nonnull_arg\t\tPARAMS ((void *, tree,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n-static bool nonnull_check_p\t\tPARAMS ((tree, unsigned HOST_WIDE_INT));\n-static bool get_nonnull_operand\t\tPARAMS ((tree,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT *));\n+static tree handle_packed_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_nocommon_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_common_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_noreturn_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_noinline_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_always_inline_attribute (tree *, tree, tree, int,\n+\t\t\t\t\t    bool *);\n+static tree handle_used_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_unused_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_const_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_transparent_union_attribute (tree *, tree, tree,\n+\t\t\t\t\t\tint, bool *);\n+static tree handle_constructor_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_destructor_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_mode_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_section_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_aligned_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_weak_attribute (tree *, tree, tree, int, bool *) ;\n+static tree handle_alias_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_visibility_attribute (tree *, tree, tree, int,\n+\t\t\t\t\t bool *);\n+static tree handle_tls_model_attribute (tree *, tree, tree, int,\n+\t\t\t\t\tbool *);\n+static tree handle_no_instrument_function_attribute (tree *, tree,\n+\t\t\t\t\t\t     tree, int, bool *);\n+static tree handle_malloc_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_no_limit_stack_attribute (tree *, tree, tree, int,\n+\t\t\t\t\t     bool *);\n+static tree handle_pure_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_deprecated_attribute (tree *, tree, tree, int,\n+\t\t\t\t\t bool *);\n+static tree handle_vector_size_attribute (tree *, tree, tree, int,\n+\t\t\t\t\t  bool *);\n+static tree handle_nonnull_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_nothrow_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_cleanup_attribute (tree *, tree, tree, int, bool *);\n+static tree vector_size_helper (tree, tree);\n+\n+static void check_function_nonnull (tree, tree);\n+static void check_nonnull_arg (void *, tree, unsigned HOST_WIDE_INT);\n+static bool nonnull_check_p (tree, unsigned HOST_WIDE_INT);\n+static bool get_nonnull_operand (tree, unsigned HOST_WIDE_INT *);\n \n /* Table of machine-independent attributes common to all C-like languages.  */\n const struct attribute_spec c_common_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n   { \"packed\",                 0, 0, false, false, false,\n-      \t\t\t      handle_packed_attribute },\n+\t\t\t      handle_packed_attribute },\n   { \"nocommon\",               0, 0, true,  false, false,\n \t\t\t      handle_nocommon_attribute },\n   { \"common\",                 0, 0, true,  false, false,\n@@ -898,10 +875,7 @@ const struct attribute_spec c_common_format_attribute_table[] =\n    condition to keep line number information accurate.  */\n \n void\n-c_expand_start_cond (cond, compstmt_count, if_stmt)\n-     tree cond;\n-     int compstmt_count;\n-     tree if_stmt;\n+c_expand_start_cond (tree cond, int compstmt_count, tree if_stmt)\n {\n   /* Make sure there is enough space on the stack.  */\n   if (if_stack_space == 0)\n@@ -929,7 +903,7 @@ c_expand_start_cond (cond, compstmt_count, if_stmt)\n /* Called after the then-clause for an if-statement is processed.  */\n \n void\n-c_finish_then ()\n+c_finish_then (void)\n {\n   tree if_stmt = if_stack[if_stack_pointer - 1].if_stmt;\n   RECHAIN_STMTS (if_stmt, THEN_CLAUSE (if_stmt));\n@@ -939,7 +913,7 @@ c_finish_then ()\n    if statement had an ambiguous else clause.  */\n \n void\n-c_expand_end_cond ()\n+c_expand_end_cond (void)\n {\n   if_stack_pointer--;\n   if (if_stack[if_stack_pointer].needs_warning)\n@@ -952,7 +926,7 @@ c_expand_end_cond ()\n    of an if-then-else.  */\n \n void\n-c_expand_start_else ()\n+c_expand_start_else (void)\n {\n   /* An ambiguous else warning must be generated for the enclosing if\n      statement, unless we see an else branch for that one, too.  */\n@@ -972,7 +946,7 @@ c_expand_start_else ()\n /* Called after the else-clause for an if-statement is processed.  */\n \n void\n-c_finish_else ()\n+c_finish_else (void)\n {\n   tree if_stmt = if_stack[if_stack_pointer - 1].if_stmt;\n   RECHAIN_STMTS (if_stmt, ELSE_CLAUSE (if_stmt));\n@@ -987,7 +961,7 @@ c_finish_else ()\n    beyond what is strictly necessary for correctness.  */\n \n tree\n-c_begin_if_stmt ()\n+c_begin_if_stmt (void)\n {\n   tree r;\n   r = build_stmt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n@@ -1003,29 +977,27 @@ c_begin_if_stmt ()\n    beyond what is strictly necessary for correctness.  */\n \n tree\n-c_begin_while_stmt ()\n+c_begin_while_stmt (void)\n {\n   tree r;\n   r = build_stmt (WHILE_STMT, NULL_TREE, NULL_TREE);\n   return r;\n }\n \n void\n-c_finish_while_stmt_cond (cond, while_stmt)\n-     tree while_stmt;\n-     tree cond;\n+c_finish_while_stmt_cond (tree cond, tree while_stmt)\n {\n   WHILE_COND (while_stmt) = cond;\n }\n \n /* Push current bindings for the function name VAR_DECLS.  */\n \n void\n-start_fname_decls ()\n+start_fname_decls (void)\n {\n   unsigned ix;\n   tree saved = NULL_TREE;\n-  \n+\n   for (ix = 0; fname_vars[ix].decl; ix++)\n     {\n       tree decl = *fname_vars[ix].decl;\n@@ -1051,15 +1023,15 @@ start_fname_decls ()\n    involved. Pop the previous bindings.  */\n \n void\n-finish_fname_decls ()\n+finish_fname_decls (void)\n {\n   unsigned ix;\n   tree body = NULL_TREE;\n   tree stack = saved_function_name_decls;\n \n   for (; stack && TREE_VALUE (stack); stack = TREE_CHAIN (stack))\n     body = chainon (TREE_VALUE (stack), body);\n-  \n+\n   if (body)\n     {\n       /* They were called into existence, so add to statement tree.  Add\n@@ -1075,10 +1047,10 @@ finish_fname_decls ()\n       body = chainon (body, *p);\n       *p = body;\n     }\n-  \n+\n   for (ix = 0; fname_vars[ix].decl; ix++)\n     *fname_vars[ix].decl = NULL_TREE;\n-  \n+\n   if (stack)\n     {\n       /* We had saved values, restore them.  */\n@@ -1088,7 +1060,7 @@ finish_fname_decls ()\n \t{\n \t  tree decl = TREE_PURPOSE (saved);\n \t  unsigned ix = TREE_INT_CST_LOW (TREE_VALUE (saved));\n-\t  \n+\n \t  *fname_vars[ix].decl = decl;\n \t}\n       stack = TREE_CHAIN (stack);\n@@ -1100,11 +1072,10 @@ finish_fname_decls ()\n    by PRETTY_P.  */\n \n const char *\n-fname_as_string (pretty_p)\n-     int pretty_p;\n+fname_as_string (int pretty_p)\n {\n   const char *name = NULL;\n-  \n+\n   if (pretty_p)\n     name = (current_function_decl\n \t    ? (*lang_hooks.decl_printable_name) (current_function_decl, 2)\n@@ -1120,11 +1091,10 @@ fname_as_string (pretty_p)\n    required by the supplied RID value.  */\n \n const char *\n-fname_string (rid)\n-     unsigned rid;\n+fname_string (unsigned int rid)\n {\n   unsigned ix;\n-  \n+\n   for (ix = 0; fname_vars[ix].decl; ix++)\n     if (fname_vars[ix].rid == rid)\n       break;\n@@ -1139,9 +1109,7 @@ fname_string (rid)\n    this language independent code.  */\n \n tree\n-fname_decl (rid, id)\n-     unsigned rid;\n-     tree id;\n+fname_decl (unsigned int rid, tree id)\n {\n   unsigned ix;\n   tree decl = NULL_TREE;\n@@ -1161,7 +1129,7 @@ fname_decl (rid, id)\n \t it from appearing in the RTL.  */\n       int saved_lineno = input_line;\n       input_line = 0;\n-      \n+\n       decl = (*make_fname_decl) (id, fname_vars[ix].pretty);\n       if (last_tree != saved_last_tree)\n \t{\n@@ -1187,8 +1155,7 @@ fname_decl (rid, id)\n /* Given a STRING_CST, give it a suitable array-of-chars data type.  */\n \n tree\n-fix_string_type (value)\n-      tree value;\n+fix_string_type (tree value)\n {\n   const int wchar_bytes = TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT;\n   const int wide_flag = TREE_TYPE (value) == wchar_array_type_node;\n@@ -1231,8 +1198,7 @@ fix_string_type (value)\n    STRING_CST.  */\n \n tree\n-combine_strings (strings)\n-     varray_type strings;\n+combine_strings (varray_type strings)\n {\n   const int wchar_bytes = TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT;\n   const int nstrings = VARRAY_ACTIVE_SIZE (strings);\n@@ -1258,7 +1224,7 @@ combine_strings (strings)\n \t{\n \t  length += (TREE_STRING_LENGTH (t) - 1);\n \t  if (C_ARTIFICIAL_STRING_P (t) && !in_system_header)\n-\t    warning (\"concatenation of string literals with __FUNCTION__ is deprecated\"); \n+\t    warning (\"concatenation of string literals with __FUNCTION__ is deprecated\");\n \t}\n     }\n \n@@ -1333,12 +1299,13 @@ combine_strings (strings)\n   return value;\n }\n \f\n-static int is_valid_printf_arglist PARAMS ((tree));\n-static rtx c_expand_builtin PARAMS ((tree, rtx, enum machine_mode, enum expand_modifier));\n-static rtx c_expand_builtin_printf PARAMS ((tree, rtx, enum machine_mode,\n-\t\t\t\t\t    enum expand_modifier, int, int));\n-static rtx c_expand_builtin_fprintf PARAMS ((tree, rtx, enum machine_mode,\n-\t\t\t\t\t     enum expand_modifier, int, int));\n+static int is_valid_printf_arglist (tree);\n+static rtx c_expand_builtin (tree, rtx, enum machine_mode,\n+\t\t\t     enum expand_modifier);\n+static rtx c_expand_builtin_printf (tree, rtx, enum machine_mode,\n+\t\t\t\t    enum expand_modifier, int, int);\n+static rtx c_expand_builtin_fprintf (tree, rtx, enum machine_mode,\n+\t\t\t\t     enum expand_modifier, int, int);\n \f\n /* Print a warning if a constant expression had overflow in folding.\n    Invoke this function on every expression that the language\n@@ -1347,8 +1314,7 @@ static rtx c_expand_builtin_fprintf PARAMS ((tree, rtx, enum machine_mode,\n    constant expression to overflow.  */\n \n void\n-constant_expression_warning (value)\n-     tree value;\n+constant_expression_warning (tree value)\n {\n   if ((TREE_CODE (value) == INTEGER_CST || TREE_CODE (value) == REAL_CST\n        || TREE_CODE (value) == VECTOR_CST\n@@ -1365,8 +1331,7 @@ constant_expression_warning (value)\n    however, do not invoke this function on operands of explicit casts.  */\n \n void\n-overflow_warning (value)\n-     tree value;\n+overflow_warning (tree value)\n {\n   if ((TREE_CODE (value) == INTEGER_CST\n        || (TREE_CODE (value) == COMPLEX_CST\n@@ -1400,8 +1365,7 @@ overflow_warning (value)\n    converted to an unsigned type.  */\n \n void\n-unsigned_conversion_warning (result, operand)\n-     tree result, operand;\n+unsigned_conversion_warning (tree result, tree operand)\n {\n   tree type = TREE_TYPE (result);\n \n@@ -1423,23 +1387,21 @@ unsigned_conversion_warning (result, operand)\n    for type TYPE (an INTEGER_TYPE).  */\n \n static int\n-constant_fits_type_p (c, type)\n-     tree c, type;\n+constant_fits_type_p (tree c, tree type)\n {\n   if (TREE_CODE (c) == INTEGER_CST)\n     return int_fits_type_p (c, type);\n \n   c = convert (type, c);\n   return !TREE_OVERFLOW (c);\n-}     \n+}\n \n /* Convert EXPR to TYPE, warning about conversion problems with constants.\n    Invoke this function on every expression that is converted implicitly,\n    i.e. because of language rules and not because of an explicit cast.  */\n \n tree\n-convert_and_check (type, expr)\n-     tree type, expr;\n+convert_and_check (tree type, tree expr)\n {\n   tree t = convert (type, expr);\n   if (TREE_CODE (t) == INTEGER_CST)\n@@ -1502,21 +1464,18 @@ static struct tlist *warned_ids;\n    cache the results.  */\n static struct tlist_cache *save_expr_cache;\n \n-static void add_tlist PARAMS ((struct tlist **, struct tlist *, tree, int));\n-static void merge_tlist PARAMS ((struct tlist **, struct tlist *, int));\n-static void verify_tree PARAMS ((tree, struct tlist **, struct tlist **, tree));\n-static int warning_candidate_p PARAMS ((tree));\n-static void warn_for_collisions PARAMS ((struct tlist *));\n-static void warn_for_collisions_1 PARAMS ((tree, tree, struct tlist *, int));\n-static struct tlist *new_tlist PARAMS ((struct tlist *, tree, tree));\n-static void verify_sequence_points PARAMS ((tree));\n+static void add_tlist (struct tlist **, struct tlist *, tree, int);\n+static void merge_tlist (struct tlist **, struct tlist *, int);\n+static void verify_tree (tree, struct tlist **, struct tlist **, tree);\n+static int warning_candidate_p (tree);\n+static void warn_for_collisions (struct tlist *);\n+static void warn_for_collisions_1 (tree, tree, struct tlist *, int);\n+static struct tlist *new_tlist (struct tlist *, tree, tree);\n+static void verify_sequence_points (tree);\n \n /* Create a new struct tlist and fill in its fields.  */\n static struct tlist *\n-new_tlist (next, t, writer)\n-     struct tlist *next;\n-     tree t;\n-     tree writer;\n+new_tlist (struct tlist *next, tree t, tree writer)\n {\n   struct tlist *l;\n   l = (struct tlist *) obstack_alloc (&tlist_obstack, sizeof *l);\n@@ -1530,11 +1489,7 @@ new_tlist (next, t, writer)\n    is nonnull, we ignore any node we find which has a writer equal to it.  */\n \n static void\n-add_tlist (to, add, exclude_writer, copy)\n-     struct tlist **to;\n-     struct tlist *add;\n-     tree exclude_writer;\n-     int copy;\n+add_tlist (struct tlist **to, struct tlist *add, tree exclude_writer, int copy)\n {\n   while (add)\n     {\n@@ -1554,10 +1509,7 @@ add_tlist (to, add, exclude_writer, copy)\n    write.  */\n \n static void\n-merge_tlist (to, add, copy)\n-     struct tlist **to;\n-     struct tlist *add;\n-     int copy;\n+merge_tlist (struct tlist **to, struct tlist *add, int copy)\n {\n   struct tlist **end = to;\n \n@@ -1592,10 +1544,8 @@ merge_tlist (to, add, copy)\n    is nonzero.  */\n \n static void\n-warn_for_collisions_1 (written, writer, list, only_writes)\n-     tree written, writer;\n-     struct tlist *list;\n-     int only_writes;\n+warn_for_collisions_1 (tree written, tree writer, struct tlist *list,\n+\t\t       int only_writes)\n {\n   struct tlist *tmp;\n \n@@ -1622,11 +1572,10 @@ warn_for_collisions_1 (written, writer, list, only_writes)\n    can cause conflicts due to missing sequence points.  */\n \n static void\n-warn_for_collisions (list)\n-     struct tlist *list;\n+warn_for_collisions (struct tlist *list)\n {\n   struct tlist *tmp;\n-  \n+\n   for (tmp = list; tmp; tmp = tmp->next)\n     {\n       if (tmp->writer)\n@@ -1637,8 +1586,7 @@ warn_for_collisions (list)\n /* Return nonzero if X is a tree that can be verified by the sequence point\n    warnings.  */\n static int\n-warning_candidate_p (x)\n-     tree x;\n+warning_candidate_p (tree x)\n {\n   return TREE_CODE (x) == VAR_DECL || TREE_CODE (x) == PARM_DECL;\n }\n@@ -1669,10 +1617,8 @@ warning_candidate_p (x)\n    way, so that no more than one access to B is recorded.  */\n \n static void\n-verify_tree (x, pbefore_sp, pno_sp, writer)\n-     tree x;\n-     struct tlist **pbefore_sp, **pno_sp;\n-     tree writer;\n+verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n+\t     tree writer)\n {\n   struct tlist *tmp_before, *tmp_nosp, *tmp_list2, *tmp_list3;\n   enum tree_code code;\n@@ -1867,8 +1813,7 @@ verify_tree (x, pbefore_sp, pno_sp, writer)\n    points.  */\n \n static void\n-verify_sequence_points (expr)\n-     tree expr;\n+verify_sequence_points (tree expr)\n {\n   struct tlist *before_sp = 0, *after_sp = 0;\n \n@@ -1886,8 +1831,7 @@ verify_sequence_points (expr)\n }\n \n tree\n-c_expand_expr_stmt (expr)\n-     tree expr;\n+c_expand_expr_stmt (tree expr)\n {\n   /* Do default conversion if safe and possibly important,\n      in case within ({...}).  */\n@@ -1904,15 +1848,14 @@ c_expand_expr_stmt (expr)\n       && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)\n     error (\"expression statement has incomplete type\");\n \n-  last_expr_type = TREE_TYPE (expr); \n+  last_expr_type = TREE_TYPE (expr);\n   return add_stmt (build_stmt (EXPR_STMT, expr));\n }\n \f\n /* Validate the expression after `case' and apply default promotions.  */\n \n tree\n-check_case_value (value)\n-     tree value;\n+check_case_value (tree value)\n {\n   if (value == NULL_TREE)\n     return value;\n@@ -1951,9 +1894,7 @@ check_case_value (value)\n    that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */\n \n tree\n-c_common_type_for_size (bits, unsignedp)\n-     unsigned bits;\n-     int unsignedp;\n+c_common_type_for_size (unsigned int bits, int unsignedp)\n {\n   if (bits == TYPE_PRECISION (integer_type_node))\n     return unsignedp ? unsigned_type_node : integer_type_node;\n@@ -1995,9 +1936,7 @@ c_common_type_for_size (bits, unsignedp)\n    then UNSIGNEDP selects between signed and unsigned types.  */\n \n tree\n-c_common_type_for_mode (mode, unsignedp)\n-     enum machine_mode mode;\n-     int unsignedp;\n+c_common_type_for_mode (enum machine_mode mode, int unsignedp)\n {\n   if (mode == TYPE_MODE (integer_type_node))\n     return unsignedp ? unsigned_type_node : integer_type_node;\n@@ -2087,8 +2026,7 @@ c_common_type_for_mode (mode, unsignedp)\n \n /* Return an unsigned type the same as TYPE in other respects.  */\n tree\n-c_common_unsigned_type (type)\n-     tree type;\n+c_common_unsigned_type (tree type)\n {\n   tree type1 = TYPE_MAIN_VARIANT (type);\n   if (type1 == signed_char_type_node || type1 == char_type_node)\n@@ -2122,8 +2060,7 @@ c_common_unsigned_type (type)\n /* Return a signed type the same as TYPE in other respects.  */\n \n tree\n-c_common_signed_type (type)\n-     tree type;\n+c_common_signed_type (tree type)\n {\n   tree type1 = TYPE_MAIN_VARIANT (type);\n   if (type1 == unsigned_char_type_node || type1 == char_type_node)\n@@ -2158,9 +2095,7 @@ c_common_signed_type (type)\n    signed according to UNSIGNEDP.  */\n \n tree\n-c_common_signed_or_unsigned_type (unsignedp, type)\n-     int unsignedp;\n-     tree type;\n+c_common_signed_or_unsigned_type (int unsignedp, tree type)\n {\n   if (! INTEGRAL_TYPE_P (type)\n       || TREE_UNSIGNED (type) == unsignedp)\n@@ -2201,9 +2136,7 @@ c_common_signed_or_unsigned_type (unsignedp, type)\n    signed or unsigned type, UNSIGNEDP says which.  */\n \n unsigned int\n-min_precision (value, unsignedp)\n-     tree value;\n-     int unsignedp;\n+min_precision (tree value, int unsignedp)\n {\n   int log;\n \n@@ -2231,8 +2164,7 @@ min_precision (value, unsignedp)\n    c_common_truthvalue_conversion).  */\n \n void\n-binary_op_error (code)\n-     enum tree_code code;\n+binary_op_error (enum tree_code code)\n {\n   const char *opname;\n \n@@ -2308,10 +2240,8 @@ binary_op_error (code)\n    that value.  */\n \n tree\n-shorten_compare (op0_ptr, op1_ptr, restype_ptr, rescode_ptr)\n-     tree *op0_ptr, *op1_ptr;\n-     tree *restype_ptr;\n-     enum tree_code *rescode_ptr;\n+shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n+\t\t enum tree_code *rescode_ptr)\n {\n   tree type;\n   tree op0 = *op0_ptr;\n@@ -2636,9 +2566,7 @@ shorten_compare (op0_ptr, op1_ptr, restype_ptr, rescode_ptr)\n    of pointer PTROP and integer INTOP.  */\n \n tree\n-pointer_int_sum (resultcode, ptrop, intop)\n-     enum tree_code resultcode;\n-     tree ptrop, intop;\n+pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n {\n   tree size_exp;\n \n@@ -2712,7 +2640,7 @@ pointer_int_sum (resultcode, ptrop, intop)\n \n   if (TYPE_PRECISION (TREE_TYPE (intop)) != TYPE_PRECISION (sizetype)\n       || TREE_UNSIGNED (TREE_TYPE (intop)) != TREE_UNSIGNED (sizetype))\n-    intop = convert (c_common_type_for_size (TYPE_PRECISION (sizetype), \n+    intop = convert (c_common_type_for_size (TYPE_PRECISION (sizetype),\n \t\t\t\t\t     TREE_UNSIGNED (sizetype)), intop);\n \n   /* Replace the integer argument with a suitable product by the object size.\n@@ -2745,8 +2673,7 @@ pointer_int_sum (resultcode, ptrop, intop)\n    The resulting type should always be `boolean_type_node'.  */\n \n tree\n-c_common_truthvalue_conversion (expr)\n-     tree expr;\n+c_common_truthvalue_conversion (tree expr)\n {\n   if (TREE_CODE (expr) == ERROR_MARK)\n     return expr;\n@@ -2907,17 +2834,15 @@ c_common_truthvalue_conversion (expr)\n   return build_binary_op (NE_EXPR, expr, integer_zero_node, 1);\n }\n \f\n-static tree builtin_function_2 PARAMS ((const char *, const char *, tree, tree,\n-\t\t\t\t\tint, enum built_in_class, int, int,\n-\t\t\t\t\ttree));\n+static tree builtin_function_2 (const char *, const char *, tree, tree,\n+\t\t\t\tint, enum built_in_class, int, int,\n+\t\t\t\ttree);\n \n /* Make a variant type in the proper way for C/C++, propagating qualifiers\n    down to the element type of an array.  */\n \n tree\n-c_build_qualified_type (type, type_quals)\n-     tree type;\n-     int type_quals;\n+c_build_qualified_type (tree type, int type_quals)\n {\n   /* A restrict-qualified pointer type must be a pointer to object or\n      incomplete type.  Note that the use of POINTER_TYPE_P also allows\n@@ -2944,12 +2869,10 @@ c_build_qualified_type (type, type_quals)\n /* Apply the TYPE_QUALS to the new DECL.  */\n \n void\n-c_apply_type_quals_to_decl (type_quals, decl)\n-     int type_quals;\n-     tree decl;\n+c_apply_type_quals_to_decl (int type_quals, tree decl)\n {\n   if ((type_quals & TYPE_QUAL_CONST)\n-      || (TREE_TYPE (decl) \n+      || (TREE_TYPE (decl)\n \t  && TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE))\n     TREE_READONLY (decl) = 1;\n   if (type_quals & TYPE_QUAL_VOLATILE)\n@@ -2975,11 +2898,10 @@ c_apply_type_quals_to_decl (type_quals, decl)\n    or a type.  Return -1 if we don't do anything special.  */\n \n HOST_WIDE_INT\n-c_common_get_alias_set (t)\n-     tree t;\n+c_common_get_alias_set (tree t)\n {\n   tree u;\n-  \n+\n   /* Permit type-punning when accessing a union, provided the access\n      is directly through the union.  For example, this code does not\n      permit taking the address of a union member and then storing\n@@ -3059,18 +2981,15 @@ c_common_get_alias_set (t)\n    flag controls whether we should diagnose possibly ill-formed\n    constructs or not.  */\n tree\n-c_sizeof_or_alignof_type (type, op, complain)\n-     tree type;\n-     enum tree_code op;\n-     int complain;\n+c_sizeof_or_alignof_type (tree type, enum tree_code op, int complain)\n {\n   const char *op_name;\n   tree value = NULL;\n   enum tree_code type_code = TREE_CODE (type);\n-  \n+\n   my_friendly_assert (op == SIZEOF_EXPR || op == ALIGNOF_EXPR, 20020720);\n   op_name = op == SIZEOF_EXPR ? \"sizeof\" : \"__alignof__\";\n-  \n+\n   if (type_code == FUNCTION_TYPE)\n     {\n       if (op == SIZEOF_EXPR)\n@@ -3084,7 +3003,7 @@ c_sizeof_or_alignof_type (type, op, complain)\n     }\n   else if (type_code == VOID_TYPE || type_code == ERROR_MARK)\n     {\n-      if (type_code == VOID_TYPE \n+      if (type_code == VOID_TYPE\n \t  && complain && (pedantic || warn_pointer_arith))\n \tpedwarn (\"invalid application of `%s' to a void type\", op_name);\n       value = size_one_node;\n@@ -3112,7 +3031,7 @@ c_sizeof_or_alignof_type (type, op, complain)\n      `size_t', which is just a typedef for an ordinary integer type.  */\n   value = fold (build1 (NOP_EXPR, size_type_node, value));\n   my_friendly_assert (!TYPE_IS_SIZETYPE (TREE_TYPE (value)), 20001021);\n-  \n+\n   return value;\n }\n \n@@ -3122,14 +3041,13 @@ c_sizeof_or_alignof_type (type, op, complain)\n    \"aligned\" __attribute__ specification).  */\n \n tree\n-c_alignof_expr (expr)\n-     tree expr;\n+c_alignof_expr (tree expr)\n {\n   tree t;\n \n   if (TREE_CODE (expr) == VAR_DECL)\n     t = size_int (DECL_ALIGN (expr) / BITS_PER_UNIT);\n- \n+\n   else if (TREE_CODE (expr) == COMPONENT_REF\n \t   && DECL_C_BIT_FIELD (TREE_OPERAND (expr, 1)))\n     {\n@@ -3139,13 +3057,13 @@ c_alignof_expr (expr)\n   else if (TREE_CODE (expr) == COMPONENT_REF\n \t   && TREE_CODE (TREE_OPERAND (expr, 1)) == FIELD_DECL)\n     t = size_int (DECL_ALIGN (TREE_OPERAND (expr, 1)) / BITS_PER_UNIT);\n- \n+\n   else if (TREE_CODE (expr) == INDIRECT_REF)\n     {\n       tree t = TREE_OPERAND (expr, 0);\n       tree best = t;\n       int bestalign = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (t)));\n- \n+\n       while (TREE_CODE (t) == NOP_EXPR\n \t     && TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == POINTER_TYPE)\n \t{\n@@ -3186,15 +3104,15 @@ static GTY(()) tree built_in_attributes[(int) ATTR_LAST];\n \n static bool c_attrs_initialized = false;\n \n-static void c_init_attributes PARAMS ((void));\n+static void c_init_attributes (void);\n \n /* Build tree nodes and builtin functions common to both C and C++ language\n    frontends.  */\n \n void\n-c_common_nodes_and_builtins ()\n+c_common_nodes_and_builtins (void)\n {\n-  enum builtin_type \n+  enum builtin_type\n   {\n #define DEF_PRIMITIVE_TYPE(NAME, VALUE) NAME,\n #define DEF_FUNCTION_TYPE_0(NAME, RETURN) NAME,\n@@ -3469,7 +3387,7 @@ c_common_nodes_and_builtins ()\n       va_list_arg_type_node = va_list_type_node;\n       va_list_ref_type_node = build_reference_type (va_list_type_node);\n     }\n- \n+\n #define DEF_PRIMITIVE_TYPE(ENUM, VALUE) \\\n   builtin_types[(int) ENUM] = VALUE;\n #define DEF_FUNCTION_TYPE_0(ENUM, RETURN)\t\t\\\n@@ -3484,7 +3402,7 @@ c_common_nodes_and_builtins ()\n \t\t\t\t      void_list_node));\n #define DEF_FUNCTION_TYPE_2(ENUM, RETURN, ARG1, ARG2)\t\\\n   builtin_types[(int) ENUM]\t\t\t\t\\\n-    = build_function_type \t\t\t\t\\\n+    = build_function_type\t\t\t\t\\\n       (builtin_types[(int) RETURN],\t\t\t\\\n        tree_cons (NULL_TREE,\t\t\t\t\\\n \t\t  builtin_types[(int) ARG1],\t\t\\\n@@ -3510,9 +3428,9 @@ c_common_nodes_and_builtins ()\n \t\t  builtin_types[(int) ARG1],\t\t\t\t\\\n \t\t  tree_cons (NULL_TREE,\t\t\t\t\t\\\n \t\t\t     builtin_types[(int) ARG2],\t\t\t\\\n-\t\t\t     tree_cons \t\t\t\t\t\\\n+\t\t\t     tree_cons\t\t\t\t\t\\\n \t\t\t     (NULL_TREE,\t\t\t\t\\\n-\t\t\t      builtin_types[(int) ARG3],\t \t\\\n+\t\t\t      builtin_types[(int) ARG3],\t\t\\\n \t\t\t      tree_cons (NULL_TREE,\t\t\t\\\n \t\t\t\t\t builtin_types[(int) ARG4],\t\\\n \t\t\t\t\t void_list_node)))));\n@@ -3521,14 +3439,14 @@ c_common_nodes_and_builtins ()\n     = build_function_type (builtin_types[(int) RETURN], NULL_TREE);\n #define DEF_FUNCTION_TYPE_VAR_1(ENUM, RETURN, ARG1)\t\t\t \\\n    builtin_types[(int) ENUM]\t\t\t\t\t\t \\\n-    = build_function_type (builtin_types[(int) RETURN], \t\t \\\n+    = build_function_type (builtin_types[(int) RETURN],\t\t \\\n \t\t\t   tree_cons (NULL_TREE,\t\t\t \\\n \t\t\t\t      builtin_types[(int) ARG1],\t \\\n \t\t\t\t      NULL_TREE));\n \n #define DEF_FUNCTION_TYPE_VAR_2(ENUM, RETURN, ARG1, ARG2)\t\\\n    builtin_types[(int) ENUM]\t\t\t\t\t\\\n-    = build_function_type \t\t\t\t\t\\\n+    = build_function_type\t\t\t\t\t\\\n       (builtin_types[(int) RETURN],\t\t\t\t\\\n        tree_cons (NULL_TREE,\t\t\t\t\t\\\n \t\t  builtin_types[(int) ARG1],\t\t\t\\\n@@ -3538,7 +3456,7 @@ c_common_nodes_and_builtins ()\n \n #define DEF_FUNCTION_TYPE_VAR_3(ENUM, RETURN, ARG1, ARG2, ARG3)\t\t\\\n    builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n-    = build_function_type \t\t\t\t\t\t\\\n+    = build_function_type\t\t\t\t\t\t\\\n       (builtin_types[(int) RETURN],\t\t\t\t\t\\\n        tree_cons (NULL_TREE,\t\t\t\t\t\t\\\n \t\t  builtin_types[(int) ARG1],\t\t\t\t\\\n@@ -3596,7 +3514,7 @@ c_common_nodes_and_builtins ()\n       built_in_decls[(int) ENUM] = decl;\t\t\t\t\\\n       if (IMPLICIT)\t\t\t\t\t\t\t\\\n         implicit_built_in_decls[(int) ENUM] = decl;\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\n+    }\n #include \"builtins.def\"\n #undef DEF_BUILTIN\n \n@@ -3606,8 +3524,7 @@ c_common_nodes_and_builtins ()\n }\n \n tree\n-build_va_arg (expr, type)\n-     tree expr, type;\n+build_va_arg (tree expr, tree type)\n {\n   return build1 (VA_ARG_EXPR, type, expr);\n }\n@@ -3622,14 +3539,13 @@ typedef struct disabled_builtin\n } disabled_builtin;\n static disabled_builtin *disabled_builtins = NULL;\n \n-static bool builtin_function_disabled_p PARAMS ((const char *));\n+static bool builtin_function_disabled_p (const char *);\n \n /* Disable a built-in function specified by -fno-builtin-NAME.  If NAME\n    begins with \"__builtin_\", give an error.  */\n \n void\n-disable_builtin_function (name)\n-     const char *name;\n+disable_builtin_function (const char *name)\n {\n   if (strncmp (name, \"__builtin_\", strlen (\"__builtin_\")) == 0)\n     error (\"cannot disable built-in function `%s'\", name);\n@@ -3647,8 +3563,7 @@ disable_builtin_function (name)\n    otherwise.  */\n \n static bool\n-builtin_function_disabled_p (name)\n-     const char *name;\n+builtin_function_disabled_p (const char *name)\n {\n   disabled_builtin *p;\n   for (p = disabled_builtins; p != NULL; p = p->next)\n@@ -3676,17 +3591,10 @@ builtin_function_disabled_p (name)\n    or if NONANSI_P and flag_no_nonansi_builtin.  */\n \n static tree\n-builtin_function_2 (builtin_name, name, builtin_type, type, function_code,\n-\t\t    class, library_name_p, nonansi_p, attrs)\n-     const char *builtin_name;\n-     const char *name;\n-     tree builtin_type;\n-     tree type;\n-     int function_code;\n-     enum built_in_class class;\n-     int library_name_p;\n-     int nonansi_p;\n-     tree attrs;\n+builtin_function_2 (const char *builtin_name, const char *name,\n+\t\t    tree builtin_type, tree type, int function_code,\n+\t\t    enum built_in_class class, int library_name_p,\n+\t\t    int nonansi_p, tree attrs)\n {\n   tree bdecl = NULL_TREE;\n   tree decl = NULL_TREE;\n@@ -3706,8 +3614,7 @@ builtin_function_2 (builtin_name, name, builtin_type, type, function_code,\n    integral promotions defined in ISO C99 6.3.1.1/2.  */\n \n bool\n-c_promoting_integer_type_p (t)\n-     tree t;\n+c_promoting_integer_type_p (tree t)\n {\n   switch (TREE_CODE (t))\n     {\n@@ -3737,8 +3644,7 @@ c_promoting_integer_type_p (t)\n    and none of their types is affected by default promotions.  */\n \n int\n-self_promoting_args_p (parms)\n-     tree parms;\n+self_promoting_args_p (tree parms)\n {\n   tree t;\n   for (t = parms; t; t = TREE_CHAIN (t))\n@@ -3764,17 +3670,15 @@ self_promoting_args_p (parms)\n    element type is found.  */\n \n tree\n-strip_array_types (type)\n-     tree type;\n+strip_array_types (tree type)\n {\n   while (TREE_CODE (type) == ARRAY_TYPE)\n     type = TREE_TYPE (type);\n \n   return type;\n }\n \n-static tree expand_unordered_cmp PARAMS ((tree, tree, enum tree_code,\n-\t\t\t\t\t  enum tree_code));\n+static tree expand_unordered_cmp (tree, tree, enum tree_code, enum tree_code);\n \n /* Expand a call to an unordered comparison function such as\n    __builtin_isgreater().  FUNCTION is the function's declaration and\n@@ -3786,9 +3690,9 @@ static tree expand_unordered_cmp PARAMS ((tree, tree, enum tree_code,\n    rest.  */\n \n static tree\n-expand_unordered_cmp (function, params, unordered_code, ordered_code)\n-     tree function, params;\n-     enum tree_code unordered_code, ordered_code;\n+expand_unordered_cmp (tree function, tree params,\n+\t\t      enum tree_code unordered_code,\n+\t\t      enum tree_code ordered_code)\n {\n   tree arg0, arg1, type;\n   enum tree_code code0, code1;\n@@ -3857,8 +3761,7 @@ expand_unordered_cmp (function, params, unordered_code, ordered_code)\n    where the similar functionality exists in the other front ends.  */\n \n tree\n-expand_tree_builtin (function, params, coerced_params)\n-     tree function, params, coerced_params;\n+expand_tree_builtin (tree function, tree params, tree coerced_params)\n {\n   if (DECL_BUILT_IN_CLASS (function) != BUILT_IN_NORMAL)\n     return NULL_TREE;\n@@ -3932,11 +3835,8 @@ expand_tree_builtin (function, params, coerced_params)\n    We don't need a without_duplicates variant of this one because the\n    statement tree is a tree, not a graph.  */\n \n-tree \n-walk_stmt_tree (tp, func, data)\n-     tree *tp;\n-     walk_tree_fn func;\n-     void *data;\n+tree\n+walk_stmt_tree (tree *tp, walk_tree_fn func, void *data)\n {\n   enum tree_code code;\n   int walk_subtrees;\n@@ -4001,9 +3901,7 @@ walk_stmt_tree (tp, func, data)\n    K2, and 0 if K1 and K2 are equal.  */\n \n int\n-case_compare (k1, k2)\n-     splay_tree_key k1;\n-     splay_tree_key k2;\n+case_compare (splay_tree_key k1, splay_tree_key k2)\n {\n   /* Consider a NULL key (such as arises with a `default' label) to be\n      smaller than anything else.  */\n@@ -4025,11 +3923,8 @@ case_compare (k1, k2)\n    ERROR_MARK_NODE if no CASE_LABEL is created.  */\n \n tree\n-c_add_case_label (cases, cond, low_value, high_value)\n-     splay_tree cases;\n-     tree cond;\n-     tree low_value;\n-     tree high_value;\n+c_add_case_label (splay_tree cases, tree cond, tree low_value,\n+\t\t  tree high_value)\n {\n   tree type;\n   tree label;\n@@ -4051,8 +3946,8 @@ c_add_case_label (cases, cond, low_value, high_value)\n       return error_mark_node;\n     }\n \n-  if ((low_value && TREE_TYPE (low_value) \n-       && POINTER_TYPE_P (TREE_TYPE (low_value))) \n+  if ((low_value && TREE_TYPE (low_value)\n+       && POINTER_TYPE_P (TREE_TYPE (low_value)))\n       || (high_value && TREE_TYPE (high_value)\n \t  && POINTER_TYPE_P (TREE_TYPE (high_value))))\n     error (\"pointers are not permitted as case values\");\n@@ -4091,8 +3986,8 @@ c_add_case_label (cases, cond, low_value, high_value)\n      the HIGH_VALUE to simplify later processing.  */\n   if (tree_int_cst_equal (low_value, high_value))\n     high_value = NULL_TREE;\n-  if (low_value && high_value \n-      && !tree_int_cst_lt (low_value, high_value)) \n+  if (low_value && high_value\n+      && !tree_int_cst_lt (low_value, high_value))\n     warning (\"empty range specified\");\n \n   /* Look up the LOW_VALUE in the table of case labels we already\n@@ -4130,7 +4025,7 @@ c_add_case_label (cases, cond, low_value, high_value)\n \t range is bigger than the low end of the current range, so we\n \t are only interested if the current range is a real range, and\n \t not an ordinary case label.  */\n-      else if (high_bound \n+      else if (high_bound\n \t       && high_value\n \t       && (tree_int_cst_compare ((tree) high_bound->key,\n \t\t\t\t\t high_value)\n@@ -4145,7 +4040,7 @@ c_add_case_label (cases, cond, low_value, high_value)\n       if (high_value)\n \t{\n \t  error (\"duplicate (or overlapping) case value\");\n-\t  error_with_decl (duplicate, \n+\t  error_with_decl (duplicate,\n \t\t\t   \"this is the first entry overlapping that value\");\n \t}\n       else if (low_value)\n@@ -4165,7 +4060,7 @@ c_add_case_label (cases, cond, low_value, high_value)\n   /* Add a CASE_LABEL to the statement-tree.  */\n   case_label = add_stmt (build_case_label (low_value, high_value, label));\n   /* Register this case label in the splay tree.  */\n-  splay_tree_insert (cases, \n+  splay_tree_insert (cases,\n \t\t     (splay_tree_key) low_value,\n \t\t     (splay_tree_value) case_label);\n \n@@ -4175,9 +4070,8 @@ c_add_case_label (cases, cond, low_value, high_value)\n /* Finish an expression taking the address of LABEL (an\n    IDENTIFIER_NODE).  Returns an expression for the address.  */\n \n-tree \n-finish_label_address_expr (label)\n-     tree label;\n+tree\n+finish_label_address_expr (tree label)\n {\n   tree result;\n \n@@ -4211,11 +4105,8 @@ finish_label_address_expr (label)\n /* Hook used by expand_expr to expand language-specific tree codes.  */\n \n rtx\n-c_expand_expr (exp, target, tmode, modifier)\n-     tree exp;\n-     rtx target;\n-     enum machine_mode tmode;\n-     int modifier;  /* Actually enum_modifier.  */\n+c_expand_expr (tree exp, rtx target, enum machine_mode tmode, int modifier)\n+     /* Actually enum_modifier.  */\n {\n   switch (TREE_CODE (exp))\n     {\n@@ -4293,7 +4184,7 @@ c_expand_expr (exp, target, tmode, modifier)\n \treturn result;\n       }\n       break;\n-      \n+\n     case CALL_EXPR:\n       {\n \tif (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n@@ -4328,14 +4219,12 @@ c_expand_expr (exp, target, tmode, modifier)\n /* Hook used by safe_from_p to handle language-specific tree codes.  */\n \n int\n-c_safe_from_p (target, exp)\n-     rtx target;\n-     tree exp;\n+c_safe_from_p (rtx target, tree exp)\n {\n   /* We can see statements here when processing the body of a\n      statement-expression.  For a declaration statement declaring a\n      variable, look at the variable's initializer.  */\n-  if (TREE_CODE (exp) == DECL_STMT) \n+  if (TREE_CODE (exp) == DECL_STMT)\n     {\n       tree decl = DECL_STMT_DECL (exp);\n \n@@ -4356,8 +4245,7 @@ c_safe_from_p (target, exp)\n /* Hook used by unsafe_for_reeval to handle language-specific tree codes.  */\n \n int\n-c_common_unsafe_for_reeval (exp)\n-     tree exp;\n+c_common_unsafe_for_reeval (tree exp)\n {\n   /* Statement expressions may not be reevaluated, likewise compound\n      literals.  */\n@@ -4372,8 +4260,7 @@ c_common_unsafe_for_reeval (exp)\n /* Hook used by staticp to handle language-specific tree codes.  */\n \n int\n-c_staticp (exp)\n-     tree exp;\n+c_staticp (tree exp)\n {\n   if (TREE_CODE (exp) == COMPOUND_LITERAL_EXPR\n       && TREE_STATIC (COMPOUND_LITERAL_EXPR_DECL (exp)))\n@@ -4385,11 +4272,8 @@ c_staticp (exp)\n    (!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), \"__builtin_\", 10))\n \n static rtx\n-c_expand_builtin (exp, target, tmode, modifier)\n-     tree exp;\n-     rtx target;\n-     enum machine_mode tmode;\n-     enum expand_modifier modifier;\n+c_expand_builtin (tree exp, rtx target, enum machine_mode tmode,\n+\t\t  enum expand_modifier modifier)\n {\n   tree type = TREE_TYPE (exp);\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n@@ -4449,8 +4333,7 @@ c_expand_builtin (exp, target, tmode, modifier)\n    at the format specifier, with the remaining arguments immediately\n    following it.  */\n static int\n-is_valid_printf_arglist (arglist)\n-     tree arglist;\n+is_valid_printf_arglist (tree arglist)\n {\n   /* Save this value so we can restore it later.  */\n   const int SAVE_pedantic = pedantic;\n@@ -4483,13 +4366,9 @@ is_valid_printf_arglist (arglist)\n /* If the arguments passed to printf are suitable for optimizations,\n    we attempt to transform the call.  */\n static rtx\n-c_expand_builtin_printf (arglist, target, tmode, modifier, ignore, unlocked)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode tmode;\n-     enum expand_modifier modifier;\n-     int ignore;\n-     int unlocked;\n+c_expand_builtin_printf (tree arglist, rtx target, enum machine_mode tmode,\n+\t\t\t enum expand_modifier modifier, int ignore,\n+\t\t\t int unlocked)\n {\n   tree fn_putchar = unlocked ?\n     implicit_built_in_decls[BUILT_IN_PUTCHAR_UNLOCKED] : implicit_built_in_decls[BUILT_IN_PUTCHAR];\n@@ -4506,11 +4385,11 @@ c_expand_builtin_printf (arglist, target, tmode, modifier, ignore, unlocked)\n   if (arglist == 0\n       || (TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE))\n     return 0;\n-  \n+\n   /* Check the specifier vs. the parameters.  */\n   if (!is_valid_printf_arglist (arglist))\n     return 0;\n-  \n+\n   format_arg = TREE_VALUE (arglist);\n   stripped_string = format_arg;\n   STRIP_NOPS (stripped_string);\n@@ -4520,7 +4399,7 @@ c_expand_builtin_printf (arglist, target, tmode, modifier, ignore, unlocked)\n   /* If the format specifier isn't a STRING_CST, punt.  */\n   if (TREE_CODE (stripped_string) != STRING_CST)\n     return 0;\n-  \n+\n   /* OK!  We can attempt optimization.  */\n \n   /* If the format specifier was \"%s\\n\", call __builtin_puts(arg2).  */\n@@ -4540,7 +4419,7 @@ c_expand_builtin_printf (arglist, target, tmode, modifier, ignore, unlocked)\n       /* We can't handle anything else with % args or %% ... yet.  */\n       if (strchr (TREE_STRING_POINTER (stripped_string), '%'))\n \treturn 0;\n-      \n+\n       /* If the resulting constant string has a length of 1, call\n          putchar.  Note, TREE_STRING_LENGTH includes the terminating\n          NULL in its count.  */\n@@ -4551,7 +4430,7 @@ c_expand_builtin_printf (arglist, target, tmode, modifier, ignore, unlocked)\n              function.  */\n \t  arglist = build_int_2 (TREE_STRING_POINTER (stripped_string)[0], 0);\n \t  arglist = build_tree_list (NULL_TREE, arglist);\n-\t  \n+\n \t  fn = fn_putchar;\n         }\n       /* If the resulting constant was \"string\\n\", call\n@@ -4568,7 +4447,7 @@ c_expand_builtin_printf (arglist, target, tmode, modifier, ignore, unlocked)\n \t  char *newstr = (char *) alloca (newlen);\n \t  memcpy (newstr, TREE_STRING_POINTER (stripped_string), newlen - 1);\n \t  newstr[newlen - 1] = 0;\n-\t  \n+\n \t  arglist = fix_string_type (build_string (newlen, newstr));\n \t  arglist = build_tree_list (NULL_TREE, arglist);\n \t  fn = fn_puts;\n@@ -4578,7 +4457,7 @@ c_expand_builtin_printf (arglist, target, tmode, modifier, ignore, unlocked)\n            need stdout and don't have a way to get it ... yet.  */\n \treturn 0;\n     }\n-  \n+\n   return expand_expr (build_function_call (fn, arglist),\n \t\t      (ignore ? const0_rtx : target),\n \t\t      tmode, modifier);\n@@ -4587,13 +4466,9 @@ c_expand_builtin_printf (arglist, target, tmode, modifier, ignore, unlocked)\n /* If the arguments passed to fprintf are suitable for optimizations,\n    we attempt to transform the call.  */\n static rtx\n-c_expand_builtin_fprintf (arglist, target, tmode, modifier, ignore, unlocked)\n-     tree arglist;\n-     rtx target;\n-     enum machine_mode tmode;\n-     enum expand_modifier modifier;\n-     int ignore;\n-     int unlocked;\n+c_expand_builtin_fprintf (tree arglist, rtx target, enum machine_mode tmode,\n+\t\t\t  enum expand_modifier modifier, int ignore,\n+\t\t\t  int unlocked)\n {\n   tree fn_fputc = unlocked ?\n     implicit_built_in_decls[BUILT_IN_FPUTC_UNLOCKED] : implicit_built_in_decls[BUILT_IN_FPUTC];\n@@ -4613,11 +4488,11 @@ c_expand_builtin_fprintf (arglist, target, tmode, modifier, ignore, unlocked)\n       || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) !=\n \t  POINTER_TYPE))\n     return 0;\n-  \n+\n   /* Check the specifier vs. the parameters.  */\n   if (!is_valid_printf_arglist (TREE_CHAIN (arglist)))\n     return 0;\n-  \n+\n   format_arg = TREE_VALUE (TREE_CHAIN (arglist));\n   stripped_string = format_arg;\n   STRIP_NOPS (stripped_string);\n@@ -4627,7 +4502,7 @@ c_expand_builtin_fprintf (arglist, target, tmode, modifier, ignore, unlocked)\n   /* If the format specifier isn't a STRING_CST, punt.  */\n   if (TREE_CODE (stripped_string) != STRING_CST)\n     return 0;\n-  \n+\n   /* OK!  We can attempt optimization.  */\n \n   /* If the format specifier was \"%s\", call __builtin_fputs(arg3, arg1).  */\n@@ -4653,15 +4528,15 @@ c_expand_builtin_fprintf (arglist, target, tmode, modifier, ignore, unlocked)\n       /* We can't handle anything else with % args or %% ... yet.  */\n       if (strchr (TREE_STRING_POINTER (stripped_string), '%'))\n \treturn 0;\n-      \n+\n       /* When \"string\" doesn't contain %, replace all cases of\n          fprintf(stream,string) with fputs(string,stream).  The fputs\n          builtin will take take of special cases like length==1.  */\n       arglist = tree_cons (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)),\n \t\t\t   build_tree_list (NULL_TREE, TREE_VALUE (arglist)));\n       fn = fn_fputs;\n     }\n-  \n+\n   return expand_expr (build_function_call (fn, arglist),\n \t\t      (ignore ? const0_rtx : target),\n \t\t      tmode, modifier);\n@@ -4672,9 +4547,7 @@ c_expand_builtin_fprintf (arglist, target, tmode, modifier, ignore, unlocked)\n    or decrement (as indicated by CODE) of ARG.  The front end must check for\n    invalid cases (e.g., decrement in C++).  */\n tree\n-boolean_increment (code, arg)\n-     enum tree_code code;\n-     tree arg;\n+boolean_increment (enum tree_code code, tree arg)\n {\n   tree val;\n   tree true_res = (c_language == clk_cplusplus\n@@ -4711,7 +4584,7 @@ boolean_increment (code, arg)\n /* Built-in macros for stddef.h, that require macros defined in this\n    file.  */\n void\n-c_stddef_cpp_builtins()\n+c_stddef_cpp_builtins(void)\n {\n   builtin_define_with_value (\"__SIZE_TYPE__\", SIZE_TYPE, 0);\n   builtin_define_with_value (\"__PTRDIFF_TYPE__\", PTRDIFF_TYPE, 0);\n@@ -4720,7 +4593,7 @@ c_stddef_cpp_builtins()\n }\n \n static void\n-c_init_attributes ()\n+c_init_attributes (void)\n {\n   /* Fill in the built_in_attributes array.  */\n #define DEF_ATTR_NULL_TREE(ENUM)\t\t\\\n@@ -4747,8 +4620,7 @@ c_init_attributes ()\n /* Depending on the name of DECL, apply default attributes to it.  */\n \n void\n-c_common_insert_default_attributes (decl)\n-     tree decl;\n+c_common_insert_default_attributes (tree decl)\n {\n   tree name = DECL_NAME (decl);\n \n@@ -4774,10 +4646,7 @@ c_common_insert_default_attributes (decl)\n /* Output a -Wshadow warning MSGCODE about NAME, and give the location\n    of the previous declaration DECL.  */\n void\n-shadow_warning (msgcode, name, decl)\n-     enum sw_kind msgcode;\n-     const char *name;\n-     tree decl;\n+shadow_warning (enum sw_kind msgcode, const char *name, tree decl)\n {\n   static const char *const msgs[] = {\n     /* SW_PARAM  */ N_(\"declaration of \\\"%s\\\" shadows a parameter\"),\n@@ -4795,12 +4664,8 @@ shadow_warning (msgcode, name, decl)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_packed_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags;\n-     bool *no_add_attrs;\n+handle_packed_attribute (tree *node, tree name, tree args  ATTRIBUTE_UNUSED,\n+\t\t\t int flags, _Bool *no_add_attrs)\n {\n   tree *type = NULL;\n   if (DECL_P (*node))\n@@ -4834,12 +4699,9 @@ handle_packed_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_nocommon_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_nocommon_attribute (tree *node, tree name,\n+\t\t\t   tree args ATTRIBUTE_UNUSED,\n+\t\t\t   int flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) == VAR_DECL)\n     DECL_COMMON (*node) = 0;\n@@ -4856,12 +4718,8 @@ handle_nocommon_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_common_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_common_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n+\t\t\t int flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) == VAR_DECL)\n     DECL_COMMON (*node) = 1;\n@@ -4878,12 +4736,8 @@ handle_common_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_noreturn_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_noreturn_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n+\t\t\t   int flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   tree type = TREE_TYPE (*node);\n \n@@ -4909,12 +4763,9 @@ handle_noreturn_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_noinline_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_noinline_attribute (tree *node, tree name,\n+\t\t\t   tree args ATTRIBUTE_UNUSED,\n+\t\t\t   int flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) == FUNCTION_DECL)\n     DECL_UNINLINABLE (*node) = 1;\n@@ -4931,12 +4782,10 @@ handle_noinline_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_always_inline_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_always_inline_attribute (tree *node, tree name,\n+\t\t\t\ttree args ATTRIBUTE_UNUSED,\n+\t\t\t\tint flags ATTRIBUTE_UNUSED,\n+\t\t\t\t_Bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) == FUNCTION_DECL)\n     {\n@@ -4956,12 +4805,8 @@ handle_always_inline_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_used_attribute (pnode, name, args, flags, no_add_attrs)\n-     tree *pnode;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_used_attribute (tree *pnode, tree name, tree args ATTRIBUTE_UNUSED,\n+\t\t       int flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   tree node = *pnode;\n \n@@ -4982,12 +4827,8 @@ handle_used_attribute (pnode, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_unused_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags;\n-     bool *no_add_attrs;\n+handle_unused_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n+\t\t\t int flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   if (DECL_P (*node))\n     {\n@@ -5019,12 +4860,8 @@ handle_unused_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_const_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_const_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n+\t\t\tint flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   tree type = TREE_TYPE (*node);\n \n@@ -5050,12 +4887,9 @@ handle_const_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_transparent_union_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags;\n-     bool *no_add_attrs;\n+handle_transparent_union_attribute (tree *node, tree name,\n+\t\t\t\t    tree args ATTRIBUTE_UNUSED, int flags,\n+\t\t\t\t    _Bool *no_add_attrs)\n {\n   tree decl = NULL_TREE;\n   tree *type = NULL;\n@@ -5097,12 +4931,10 @@ handle_transparent_union_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_constructor_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_constructor_attribute (tree *node, tree name,\n+\t\t\t      tree args ATTRIBUTE_UNUSED,\n+\t\t\t      int flags ATTRIBUTE_UNUSED,\n+\t\t\t      _Bool *no_add_attrs)\n {\n   tree decl = *node;\n   tree type = TREE_TYPE (decl);\n@@ -5127,12 +4959,10 @@ handle_constructor_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_destructor_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_destructor_attribute (tree *node, tree name,\n+\t\t\t     tree args ATTRIBUTE_UNUSED,\n+\t\t\t     int flags ATTRIBUTE_UNUSED,\n+\t\t\t     _Bool *no_add_attrs)\n {\n   tree decl = *node;\n   tree type = TREE_TYPE (decl);\n@@ -5157,12 +4987,8 @@ handle_destructor_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_mode_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_mode_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n+\t\t       int flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   tree type = *node;\n \n@@ -5246,12 +5072,8 @@ handle_mode_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_section_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_section_attribute (tree *node, tree name ATTRIBUTE_UNUSED, tree args,\n+\t\t\t  int flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   tree decl = *node;\n \n@@ -5304,12 +5126,8 @@ handle_section_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_aligned_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args;\n-     int flags;\n-     bool *no_add_attrs;\n+handle_aligned_attribute (tree *node, tree name ATTRIBUTE_UNUSED, tree args,\n+\t\t\t  int flags, _Bool *no_add_attrs)\n {\n   tree decl = NULL_TREE;\n   tree *type = NULL;\n@@ -5388,12 +5206,10 @@ handle_aligned_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_weak_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs ATTRIBUTE_UNUSED;\n+handle_weak_attribute (tree *node, tree name ATTRIBUTE_UNUSED,\n+\t\t       tree args ATTRIBUTE_UNUSED,\n+\t\t       int flags ATTRIBUTE_UNUSED,\n+\t\t       _Bool *no_add_attrs ATTRIBUTE_UNUSED)\n {\n   declare_weak (*node);\n \n@@ -5404,12 +5220,8 @@ handle_weak_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_alias_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_alias_attribute (tree *node, tree name, tree args,\n+\t\t\tint flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   tree decl = *node;\n \n@@ -5453,12 +5265,9 @@ handle_alias_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_visibility_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_visibility_attribute (tree *node, tree name, tree args,\n+\t\t\t     int flags ATTRIBUTE_UNUSED,\n+\t\t\t     _Bool *no_add_attrs)\n {\n   tree decl = *node;\n \n@@ -5496,12 +5305,8 @@ handle_visibility_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_tls_model_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_tls_model_attribute (tree *node, tree name, tree args,\n+\t\t\t    int flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   tree decl = *node;\n \n@@ -5539,12 +5344,10 @@ handle_tls_model_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_no_instrument_function_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_no_instrument_function_attribute (tree *node, tree name,\n+\t\t\t\t\t tree args ATTRIBUTE_UNUSED,\n+\t\t\t\t\t int flags ATTRIBUTE_UNUSED,\n+\t\t\t\t\t _Bool *no_add_attrs)\n {\n   tree decl = *node;\n \n@@ -5572,12 +5375,8 @@ handle_no_instrument_function_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_malloc_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_malloc_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n+\t\t\t int flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) == FUNCTION_DECL)\n     DECL_IS_MALLOC (*node) = 1;\n@@ -5595,12 +5394,10 @@ handle_malloc_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_no_limit_stack_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_no_limit_stack_attribute (tree *node, tree name,\n+\t\t\t\t tree args ATTRIBUTE_UNUSED,\n+\t\t\t\t int flags ATTRIBUTE_UNUSED,\n+\t\t\t\t _Bool *no_add_attrs)\n {\n   tree decl = *node;\n \n@@ -5628,12 +5425,8 @@ handle_no_limit_stack_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_pure_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_pure_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n+\t\t       int flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) == FUNCTION_DECL)\n     DECL_IS_PURE (*node) = 1;\n@@ -5649,24 +5442,21 @@ handle_pure_attribute (node, name, args, flags, no_add_attrs)\n \n /* Handle a \"deprecated\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n-   \n+\n static tree\n-handle_deprecated_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags;\n-     bool *no_add_attrs;\n+handle_deprecated_attribute (tree *node, tree name,\n+\t\t\t     tree args ATTRIBUTE_UNUSED, int flags,\n+\t\t\t     _Bool *no_add_attrs)\n {\n   tree type = NULL_TREE;\n   int warn = 0;\n   const char *what = NULL;\n-  \n+\n   if (DECL_P (*node))\n     {\n       tree decl = *node;\n       type = TREE_TYPE (decl);\n-      \n+\n       if (TREE_CODE (decl) == TYPE_DECL\n \t  || TREE_CODE (decl) == PARM_DECL\n \t  || TREE_CODE (decl) == VAR_DECL\n@@ -5685,7 +5475,7 @@ handle_deprecated_attribute (node, name, args, flags, no_add_attrs)\n     }\n   else\n     warn = 1;\n-  \n+\n   if (warn)\n     {\n       *no_add_attrs = true;\n@@ -5701,7 +5491,7 @@ handle_deprecated_attribute (node, name, args, flags, no_add_attrs)\n \twarning (\"`%s' attribute ignored for `%s'\",\n \t\t  IDENTIFIER_POINTER (name), what);\n       else\n-\twarning (\"`%s' attribute ignored\", \n+\twarning (\"`%s' attribute ignored\",\n \t\t      IDENTIFIER_POINTER (name));\n     }\n \n@@ -5719,12 +5509,9 @@ static GTY(()) tree vector_type_node_list = 0;\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_vector_size_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_vector_size_attribute (tree *node, tree name, tree args,\n+\t\t\t      int flags ATTRIBUTE_UNUSED,\n+\t\t\t      _Bool *no_add_attrs)\n {\n   unsigned HOST_WIDE_INT vecsize, nunits;\n   enum machine_mode mode, orig_mode, new_mode;\n@@ -5870,8 +5657,7 @@ handle_vector_size_attribute (node, name, args, flags, no_add_attrs)\n    new type which we will point to.  */\n \n static tree\n-vector_size_helper (type, bottom)\n-     tree type, bottom;\n+vector_size_helper (tree type, tree bottom)\n {\n   tree inner, outer;\n \n@@ -5892,7 +5678,7 @@ vector_size_helper (type, bottom)\n     }\n   else\n     return bottom;\n-  \n+\n   TREE_READONLY (outer) = TREE_READONLY (type);\n   TREE_THIS_VOLATILE (outer) = TREE_THIS_VOLATILE (type);\n \n@@ -5901,12 +5687,9 @@ vector_size_helper (type, bottom)\n \n /* Handle the \"nonnull\" attribute.  */\n static tree\n-handle_nonnull_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_nonnull_attribute (tree *node, tree name ATTRIBUTE_UNUSED,\n+\t\t\t  tree args, int flags ATTRIBUTE_UNUSED,\n+\t\t\t  _Bool *no_add_attrs)\n {\n   tree type = *node;\n   unsigned HOST_WIDE_INT attr_arg_num;\n@@ -5975,9 +5758,7 @@ handle_nonnull_attribute (node, name, args, flags, no_add_attrs)\n    that are marked as requiring a non-null pointer argument.  */\n \n static void\n-check_function_nonnull (attrs, params)\n-     tree attrs;\n-     tree params;\n+check_function_nonnull (tree attrs, tree params)\n {\n   tree a, args, param;\n   int param_num;\n@@ -5996,11 +5777,11 @@ check_function_nonnull (attrs, params)\n                param_num++, param = TREE_CHAIN (param))\n             {\n               if (! param)\n-        \tbreak;\n+\tbreak;\n               if (! args || nonnull_check_p (args, param_num))\n-        \tcheck_function_arguments_recurse (check_nonnull_arg, NULL,\n-        \t\t\t\t\t  TREE_VALUE (param),\n-        \t\t\t\t\t  param_num);\n+\tcheck_function_arguments_recurse (check_nonnull_arg, NULL,\n+\t\t\t\t\t  TREE_VALUE (param),\n+\t\t\t\t\t  param_num);\n             }\n \t}\n     }\n@@ -6011,9 +5792,7 @@ check_function_nonnull (attrs, params)\n    checked.  */\n \n static bool\n-nonnull_check_p (args, param_num)\n-     tree args;\n-     unsigned HOST_WIDE_INT param_num;\n+nonnull_check_p (tree args, unsigned HOST_WIDE_INT param_num)\n {\n   unsigned HOST_WIDE_INT arg_num;\n \n@@ -6033,10 +5812,8 @@ nonnull_check_p (args, param_num)\n    via check_function_arguments_recurse.  */\n \n static void\n-check_nonnull_arg (ctx, param, param_num)\n-     void *ctx ATTRIBUTE_UNUSED;\n-     tree param;\n-     unsigned HOST_WIDE_INT param_num;\n+check_nonnull_arg (void *ctx ATTRIBUTE_UNUSED, tree param,\n+\t\t   unsigned HOST_WIDE_INT param_num)\n {\n   /* Just skip checking the argument if it's not a pointer.  This can\n      happen if the \"nonnull\" attribute was given without an operand\n@@ -6054,9 +5831,7 @@ check_nonnull_arg (ctx, param, param_num)\n    from the attribute argument list.  */\n \n static bool\n-get_nonnull_operand (arg_num_expr, valp)\n-     tree arg_num_expr;\n-     unsigned HOST_WIDE_INT *valp;\n+get_nonnull_operand (tree arg_num_expr, unsigned HOST_WIDE_INT *valp)\n {\n   /* Strip any conversions from the arg number and verify they\n      are constants.  */\n@@ -6077,12 +5852,8 @@ get_nonnull_operand (arg_num_expr, valp)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_nothrow_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_nothrow_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n+\t\t\t  int flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) == FUNCTION_DECL)\n     TREE_NOTHROW (*node) = 1;\n@@ -6100,12 +5871,8 @@ handle_nothrow_attribute (node, name, args, flags, no_add_attrs)\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_cleanup_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+handle_cleanup_attribute (tree *node, tree name, tree args,\n+\t\t\t  int flags ATTRIBUTE_UNUSED, _Bool *no_add_attrs)\n {\n   tree decl = *node;\n   tree cleanup_id, cleanup_decl;\n@@ -6139,17 +5906,15 @@ handle_cleanup_attribute (node, name, args, flags, no_add_attrs)\n       return NULL_TREE;\n     }\n \n-  /* That the function has proper type is checked with the \n+  /* That the function has proper type is checked with the\n      eventual call to build_function_call.  */\n \n   return NULL_TREE;\n }\n \f\n /* Check for valid arguments being passed to a function.  */\n void\n-check_function_arguments (attrs, params)\n-     tree attrs;\n-     tree params;\n+check_function_arguments (tree attrs, tree params)\n {\n   /* Check for null being passed in a pointer argument that must be\n      non-null.  We also need to do this if format checking is enabled.  */\n@@ -6167,11 +5932,10 @@ check_function_arguments (attrs, params)\n    be checked.  PARAM_NUM is the number of the argument.  CALLBACK is invoked\n    once the argument is resolved.  CTX is context for the callback.  */\n void\n-check_function_arguments_recurse (callback, ctx, param, param_num)\n-     void (*callback) PARAMS ((void *, tree, unsigned HOST_WIDE_INT));\n-     void *ctx;\n-     tree param;\n-     unsigned HOST_WIDE_INT param_num;\n+check_function_arguments_recurse (void (*callback)\n+\t\t\t\t  (void *, tree, unsigned HOST_WIDE_INT),\n+\t\t\t\t  void *ctx, tree param,\n+\t\t\t\t  unsigned HOST_WIDE_INT param_num)\n {\n   if (TREE_CODE (param) == NOP_EXPR)\n     {"}, {"sha": "8ec8ddc0b15a2e292431edc506a594f2ddee603a", "filename": "gcc/c-common.h", "status": "modified", "additions": 153, "deletions": 175, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=35b1a6faebd652c6d95cc709ddf8af02ff0feced", "patch": "@@ -305,38 +305,35 @@ struct c_language_function GTY(()) {\n \n /* Language-specific hooks.  */\n \n-extern void (*lang_expand_stmt)                 PARAMS ((tree));\n-extern void (*lang_expand_decl_stmt)            PARAMS ((tree));\n-extern void (*lang_expand_function_end)         PARAMS ((void));\n-extern tree gettags\t\t\t\tPARAMS ((void));\n+extern void (*lang_expand_stmt) (tree);\n+extern void (*lang_expand_decl_stmt) (tree);\n+extern void (*lang_expand_function_end) (void);\n+extern tree gettags (void);\n \n /* Callback that determines if it's ok for a function to have no\n    noreturn attribute.  */\n-extern int (*lang_missing_noreturn_ok_p)\tPARAMS ((tree));\n-\n-extern int yyparse\t\t\t\tPARAMS ((void));\n-extern void free_parser_stacks\t\t\tPARAMS ((void));\n-\n-extern stmt_tree current_stmt_tree              PARAMS ((void));\n-extern tree *current_scope_stmt_stack           PARAMS ((void));\n-extern void begin_stmt_tree                     PARAMS ((tree *));\n-extern tree add_stmt\t\t\t\tPARAMS ((tree));\n-extern void add_decl_stmt                       PARAMS ((tree));\n-extern tree add_scope_stmt                      PARAMS ((int, int));\n-extern void finish_stmt_tree                    PARAMS ((tree *));\n-\n-extern tree walk_stmt_tree\t\t\tPARAMS ((tree *,\n-\t\t\t\t\t\t\t walk_tree_fn,\n-\t\t\t\t\t\t\t void *));\n-extern void prep_stmt                           PARAMS ((tree));\n-extern void expand_stmt                         PARAMS ((tree));\n-extern tree c_begin_if_stmt\t\t\tPARAMS ((void));\n-extern tree c_begin_while_stmt\t\t\tPARAMS ((void));\n-extern void c_finish_while_stmt_cond\t\tPARAMS ((tree, tree));\n+extern int (*lang_missing_noreturn_ok_p) (tree);\n+\n+extern int yyparse (void);\n+extern void free_parser_stacks (void);\n+\n+extern stmt_tree current_stmt_tree (void);\n+extern tree *current_scope_stmt_stack (void);\n+extern void begin_stmt_tree (tree *);\n+extern tree add_stmt (tree);\n+extern void add_decl_stmt (tree);\n+extern tree add_scope_stmt (int, int);\n+extern void finish_stmt_tree (tree *);\n+\n+extern tree walk_stmt_tree (tree *, walk_tree_fn, void *);\n+extern void prep_stmt (tree);\n+extern void expand_stmt (tree);\n+extern tree c_begin_if_stmt (void);\n+extern tree c_begin_while_stmt (void);\n+extern void c_finish_while_stmt_cond (tree, tree);\n \n enum sw_kind { SW_PARAM = 0, SW_LOCAL, SW_GLOBAL };\n-extern void shadow_warning\t\t\tPARAMS ((enum sw_kind,\n-\t\t\t\t\t\t\t const char *, tree));\n+extern void shadow_warning (enum sw_kind, const char *, tree);\n \n /* Extra information associated with a DECL.  Other C dialects extend\n    this structure in various ways.  The C front-end only uses this\n@@ -876,98 +873,94 @@ extern const struct attribute_spec c_common_format_attribute_table[];\n    TYPE_DEP indicates whether it depends on type of the function or not\n    (i.e. __PRETTY_FUNCTION__).  */\n \n-extern tree (*make_fname_decl)                  PARAMS ((tree, int));\n-\n-extern tree identifier_global_value\t\tPARAMS ((tree));\n-extern void record_builtin_type\t\t\tPARAMS ((enum rid,\n-\t\t\t\t\t\t\t const char *, tree));\n-extern tree build_void_list_node\t\tPARAMS ((void));\n-extern void start_fname_decls\t\t\tPARAMS ((void));\n-extern void finish_fname_decls\t\t\tPARAMS ((void));\n-extern const char *fname_as_string\t\tPARAMS ((int));\n-extern tree fname_decl\t\t\t\tPARAMS ((unsigned, tree));\n-extern const char *fname_string\t\t\tPARAMS ((unsigned));\n-\n-extern void check_function_arguments\t\tPARAMS ((tree, tree));\n-extern void check_function_arguments_recurse\tPARAMS ((void (*) (void *,\n-\t\t\t\t\t\t\t\t   tree,\n-\t\t\t\t\t\t\t\t   unsigned HOST_WIDE_INT),\n-\t\t\t\t\t\t\t void *, tree,\n-\t\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n-extern void check_function_format\t\tPARAMS ((int *, tree, tree));\n-extern void set_Wformat\t\t\t\tPARAMS ((int));\n-extern tree handle_format_attribute\t\tPARAMS ((tree *, tree, tree,\n-\t\t\t\t\t\t\t int, bool *));\n-extern tree handle_format_arg_attribute\t\tPARAMS ((tree *, tree, tree,\n-\t\t\t\t\t\t\t int, bool *));\n-extern void c_common_insert_default_attributes\tPARAMS ((tree));\n+extern tree (*make_fname_decl) (tree, int);\n+\n+extern tree identifier_global_value (tree);\n+extern void record_builtin_type (enum rid, const char *, tree);\n+extern tree build_void_list_node (void);\n+extern void start_fname_decls (void);\n+extern void finish_fname_decls (void);\n+extern const char *fname_as_string (int);\n+extern tree fname_decl (unsigned, tree);\n+extern const char *fname_string (unsigned);\n+\n+extern void check_function_arguments (tree, tree);\n+extern void check_function_arguments_recurse (void (*)\n+\t\t\t\t\t      (void *, tree,\n+\t\t\t\t\t       unsigned HOST_WIDE_INT),\n+\t\t\t\t\t      void *, tree,\n+\t\t\t\t\t      unsigned HOST_WIDE_INT);\n+extern void check_function_format (int *, tree, tree);\n+extern void set_Wformat (int);\n+extern tree handle_format_attribute (tree *, tree, tree, int, bool *);\n+extern tree handle_format_arg_attribute (tree *, tree, tree, int, bool *);\n+extern void c_common_insert_default_attributes (tree);\n extern int c_common_handle_option (size_t code, const char *arg, int value);\n-extern tree c_common_type_for_mode\t\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t\t int));\n-extern tree c_common_type_for_size\t\tPARAMS ((unsigned int, int));\n-extern tree c_common_unsigned_type\t\tPARAMS ((tree));\n-extern tree c_common_signed_type\t\tPARAMS ((tree));\n-extern tree c_common_signed_or_unsigned_type\tPARAMS ((int, tree));\n-extern tree c_common_truthvalue_conversion\tPARAMS ((tree));\n-extern void c_apply_type_quals_to_decl\t\tPARAMS ((int, tree));\n-extern tree c_sizeof_or_alignof_type\tPARAMS ((tree, enum tree_code, int));\n-extern tree c_alignof_expr\t\t\tPARAMS ((tree));\n+extern tree c_common_type_for_mode (enum machine_mode, int);\n+extern tree c_common_type_for_size (unsigned int, int);\n+extern tree c_common_unsigned_type (tree);\n+extern tree c_common_signed_type (tree);\n+extern tree c_common_signed_or_unsigned_type (int, tree);\n+extern tree c_common_truthvalue_conversion (tree);\n+extern void c_apply_type_quals_to_decl (int, tree);\n+extern tree c_sizeof_or_alignof_type (tree, enum tree_code, int);\n+extern tree c_alignof_expr (tree);\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n-extern void binary_op_error\t\t\tPARAMS ((enum tree_code));\n+extern void binary_op_error (enum tree_code);\n #define my_friendly_assert(EXP, N) (void) \\\n  (((EXP) == 0) ? (fancy_abort (__FILE__, __LINE__, __FUNCTION__), 0) : 0)\n \n-extern tree c_expand_expr_stmt\t\t\tPARAMS ((tree));\n-extern void c_expand_start_cond\t\t\tPARAMS ((tree, int, tree));\n-extern void c_finish_then                       PARAMS ((void));\n-extern void c_expand_start_else\t\t\tPARAMS ((void));\n-extern void c_finish_else\t\t\tPARAMS ((void));\n-extern void c_expand_end_cond\t\t\tPARAMS ((void));\n+extern tree c_expand_expr_stmt (tree);\n+extern void c_expand_start_cond (tree, int, tree);\n+extern void c_finish_then (void);\n+extern void c_expand_start_else (void);\n+extern void c_finish_else (void);\n+extern void c_expand_end_cond (void);\n /* Validate the expression after `case' and apply default promotions.  */\n-extern tree check_case_value\t\t\tPARAMS ((tree));\n-extern tree fix_string_type\t\t\tPARAMS ((tree));\n+extern tree check_case_value (tree);\n+extern tree fix_string_type (tree);\n struct varray_head_tag;\n-extern tree combine_strings\t\tPARAMS ((struct varray_head_tag *));\n-extern void constant_expression_warning\t\tPARAMS ((tree));\n-extern tree convert_and_check\t\t\tPARAMS ((tree, tree));\n-extern void overflow_warning\t\t\tPARAMS ((tree));\n-extern void unsigned_conversion_warning\t\tPARAMS ((tree, tree));\n+extern tree combine_strings (struct varray_head_tag *);\n+extern void constant_expression_warning (tree);\n+extern tree convert_and_check (tree, tree);\n+extern void overflow_warning (tree);\n+extern void unsigned_conversion_warning (tree, tree);\n \n /* Read the rest of the current #-directive line.  */\n-extern char *get_directive_line\t\t\tPARAMS ((void));\n+extern char *get_directive_line (void);\n #define GET_DIRECTIVE_LINE() get_directive_line ()\n #define c_sizeof(T)  c_sizeof_or_alignof_type (T, SIZEOF_EXPR, 1)\n #define c_alignof(T) c_sizeof_or_alignof_type (T, ALIGNOF_EXPR, 1)\n \n /* Subroutine of build_binary_op, used for comparison operations.\n    See if the operands have both been converted from subword integer types\n    and, if so, perhaps change them both back to their original type.  */\n-extern tree shorten_compare\t\t\tPARAMS ((tree *, tree *, tree *, enum tree_code *));\n+extern tree shorten_compare (tree *, tree *, tree *, enum tree_code *);\n \n-extern tree pointer_int_sum\t\t\tPARAMS ((enum tree_code, tree, tree));\n-extern unsigned int min_precision\t\tPARAMS ((tree, int));\n+extern tree pointer_int_sum (enum tree_code, tree, tree);\n+extern unsigned int min_precision (tree, int);\n \n /* Add qualifiers to a type, in the fashion for C.  */\n-extern tree c_build_qualified_type              PARAMS ((tree, int));\n+extern tree c_build_qualified_type (tree, int);\n \n /* Build tree nodes and builtin functions common to both C and C++ language\n    frontends.  */\n-extern void c_common_nodes_and_builtins\t\tPARAMS ((void));\n+extern void c_common_nodes_and_builtins (void);\n \n-extern void disable_builtin_function\t\tPARAMS ((const char *));\n+extern void disable_builtin_function (const char *);\n \n-extern tree build_va_arg\t\t\tPARAMS ((tree, tree));\n+extern tree build_va_arg (tree, tree);\n \n-extern int c_common_init_options\t\tPARAMS ((enum c_language_kind));\n-extern bool c_common_post_options\t\tPARAMS ((const char **));\n-extern bool c_common_init\t\t\tPARAMS ((void));\n-extern void c_common_finish\t\t\tPARAMS ((void));\n-extern void c_common_parse_file\t\t\tPARAMS ((int));\n-extern HOST_WIDE_INT c_common_get_alias_set\tPARAMS ((tree));\n-extern bool c_promoting_integer_type_p\t\tPARAMS ((tree));\n-extern int self_promoting_args_p\t\tPARAMS ((tree));\n-extern tree strip_array_types                   PARAMS ((tree));\n+extern int c_common_init_options (enum c_language_kind);\n+extern bool c_common_post_options (const char **);\n+extern bool c_common_init (void);\n+extern void c_common_finish (void);\n+extern void c_common_parse_file (int);\n+extern HOST_WIDE_INT c_common_get_alias_set (tree);\n+extern bool c_promoting_integer_type_p (tree);\n+extern int self_promoting_args_p (tree);\n+extern tree strip_array_types (tree);\n \n /* These macros provide convenient access to the various _STMT nodes.  */\n \n@@ -1172,28 +1165,26 @@ extern bool statement_code_p[MAX_TREE_CODES];\n       statement_code_p[STMT_CODES[i]] = true;\t\t\t\\\n   } while (0)\n \n-extern void genrtl_do_pushlevel                 PARAMS ((void));\n-extern void genrtl_goto_stmt                    PARAMS ((tree));\n-extern void genrtl_expr_stmt                    PARAMS ((tree));\n-extern void genrtl_expr_stmt_value              PARAMS ((tree, int, int));\n-extern void genrtl_decl_stmt                    PARAMS ((tree));\n-extern void genrtl_if_stmt                      PARAMS ((tree));\n-extern void genrtl_while_stmt                   PARAMS ((tree));\n-extern void genrtl_do_stmt                      PARAMS ((tree));\n-extern void genrtl_return_stmt                  PARAMS ((tree));\n-extern void genrtl_for_stmt                     PARAMS ((tree));\n-extern void genrtl_break_stmt                   PARAMS ((void));\n-extern void genrtl_continue_stmt                PARAMS ((void));\n-extern void genrtl_scope_stmt                   PARAMS ((tree));\n-extern void genrtl_switch_stmt                  PARAMS ((tree));\n-extern void genrtl_case_label                   PARAMS ((tree));\n-extern void genrtl_compound_stmt                PARAMS ((tree));\n-extern void genrtl_asm_stmt                     PARAMS ((tree, tree,\n-\t\t\t\t\t\t\t tree, tree,\n-\t\t\t\t\t\t\t tree, int));\n-extern void genrtl_cleanup_stmt                 PARAMS ((tree));\n-extern int stmts_are_full_exprs_p               PARAMS ((void));\n-extern int anon_aggr_type_p                     PARAMS ((tree));\n+extern void genrtl_do_pushlevel (void);\n+extern void genrtl_goto_stmt (tree);\n+extern void genrtl_expr_stmt (tree);\n+extern void genrtl_expr_stmt_value (tree, int, int);\n+extern void genrtl_decl_stmt (tree);\n+extern void genrtl_if_stmt (tree);\n+extern void genrtl_while_stmt (tree);\n+extern void genrtl_do_stmt (tree);\n+extern void genrtl_return_stmt (tree);\n+extern void genrtl_for_stmt (tree);\n+extern void genrtl_break_stmt (void);\n+extern void genrtl_continue_stmt (void);\n+extern void genrtl_scope_stmt (tree);\n+extern void genrtl_switch_stmt (tree);\n+extern void genrtl_case_label (tree);\n+extern void genrtl_compound_stmt (tree);\n+extern void genrtl_asm_stmt (tree, tree, tree, tree, tree, int);\n+extern void genrtl_cleanup_stmt (tree);\n+extern int stmts_are_full_exprs_p (void);\n+extern int anon_aggr_type_p (tree);\n \n /* For a VAR_DECL that is an anonymous union, these are the various\n    sub-variables that make up the anonymous union.  */\n@@ -1211,80 +1202,72 @@ extern int anon_aggr_type_p                     PARAMS ((tree));\n    an explicit asm specification.  */\n #define DECL_C_HARD_REGISTER(DECL)  DECL_LANG_FLAG_4 (VAR_DECL_CHECK (DECL))\n \n-extern void emit_local_var                      PARAMS ((tree));\n-extern void make_rtl_for_local_static           PARAMS ((tree));\n-extern tree expand_cond                         PARAMS ((tree));\n-extern tree c_expand_return\t\t\tPARAMS ((tree));\n-extern tree do_case\t\t\t\tPARAMS ((tree, tree));\n-extern tree build_stmt                          PARAMS ((enum tree_code, ...));\n-extern tree build_case_label                    PARAMS ((tree, tree, tree));\n-extern tree build_continue_stmt                 PARAMS ((void));\n-extern tree build_break_stmt                    PARAMS ((void));\n-extern tree build_return_stmt                   PARAMS ((tree));\n+extern void emit_local_var (tree);\n+extern void make_rtl_for_local_static (tree);\n+extern tree expand_cond (tree);\n+extern tree c_expand_return (tree);\n+extern tree do_case (tree, tree);\n+extern tree build_stmt (enum tree_code, ...);\n+extern tree build_case_label (tree, tree, tree);\n+extern tree build_continue_stmt (void);\n+extern tree build_break_stmt (void);\n+extern tree build_return_stmt (tree);\n \n #define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n \n /* Used by the C++ frontend to mark the block around the member\n    initializers and cleanups.  */\n #define COMPOUND_STMT_BODY_BLOCK(NODE)\tTREE_LANG_FLAG_3 (NODE)\n \n-extern void c_expand_asm_operands\t\tPARAMS ((tree, tree, tree, tree, int, const char *, int));\n+extern void c_expand_asm_operands (tree, tree, tree, tree, int, const char *, int);\n \n /* These functions must be defined by each front-end which implements\n    a variant of the C language.  They are used in c-common.c.  */\n \n-extern tree build_unary_op                      PARAMS ((enum tree_code,\n-\t\t\t\t\t\t\t tree, int));\n-extern tree build_binary_op                     PARAMS ((enum tree_code,\n-\t\t\t\t\t\t\t tree, tree, int));\n-extern int lvalue_p\t\t\t\tPARAMS ((tree));\n-extern tree default_conversion                  PARAMS ((tree));\n+extern tree build_unary_op (enum tree_code, tree, int);\n+extern tree build_binary_op (enum tree_code, tree, tree, int);\n+extern int lvalue_p (tree);\n+extern tree default_conversion (tree);\n \n /* Given two integer or real types, return the type for their sum.\n    Given two compatible ANSI C types, returns the merged type.  */\n \n-extern tree common_type                         PARAMS ((tree, tree));\n+extern tree common_type (tree, tree);\n \n-extern tree expand_tree_builtin                 PARAMS ((tree, tree, tree));\n+extern tree expand_tree_builtin (tree, tree, tree);\n \n-extern tree decl_constant_value\t\tPARAMS ((tree));\n+extern tree decl_constant_value (tree);\n \n /* Handle increment and decrement of boolean types.  */\n-extern tree boolean_increment\t\t\tPARAMS ((enum tree_code,\n-\t\t\t\t\t\t\t tree));\n+extern tree boolean_increment (enum tree_code, tree);\n \n /* Hook currently used only by the C++ front end to reset internal state\n    after entering or leaving a header file.  */\n-extern void extract_interface_info\t\tPARAMS ((void));\n+extern void extract_interface_info (void);\n \n-extern int case_compare                         PARAMS ((splay_tree_key,\n-\t\t\t\t\t\t\t splay_tree_key));\n+extern int case_compare (splay_tree_key, splay_tree_key);\n \n-extern tree c_add_case_label                    PARAMS ((splay_tree,\n-\t\t\t\t\t\t\t tree, tree,\n-\t\t\t\t\t\t\t tree));\n+extern tree c_add_case_label (splay_tree, tree, tree, tree);\n \n-extern tree build_function_call\t\t\tPARAMS ((tree, tree));\n+extern tree build_function_call (tree, tree);\n \n-extern tree finish_label_address_expr\t\tPARAMS ((tree));\n+extern tree finish_label_address_expr (tree);\n \n /* Same function prototype, but the C and C++ front ends have\n    different implementations.  Used in c-common.c.  */\n-extern tree lookup_label\t\t\tPARAMS ((tree));\n+extern tree lookup_label (tree);\n \n-extern rtx c_expand_expr\t\t\tPARAMS ((tree, rtx,\n-\t\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t\t int));\n+extern rtx c_expand_expr (tree, rtx, enum machine_mode, int);\n \n-extern int c_safe_from_p                        PARAMS ((rtx, tree));\n+extern int c_safe_from_p (rtx, tree);\n \n-extern int c_staticp                            PARAMS ((tree));\n+extern int c_staticp (tree);\n \n-extern int c_common_unsafe_for_reeval\t\tPARAMS ((tree));\n+extern int c_common_unsafe_for_reeval (tree);\n \n-extern void init_c_lex\t\t\t\tPARAMS ((void));\n+extern void init_c_lex (void);\n \n-extern void c_cpp_builtins\t\t\tPARAMS ((cpp_reader *));\n+extern void c_cpp_builtins (cpp_reader *);\n \n /* Positive if an implicit `extern \"C\"' scope has just been entered;\n    negative if such a scope has just been exited.  */\n@@ -1299,28 +1282,23 @@ struct c_fileinfo\n   short interface_unknown;\n };\n \n-struct c_fileinfo *get_fileinfo\t\t\tPARAMS ((const char *));\n-extern void dump_time_statistics\t\tPARAMS ((void));\n-\n-extern bool c_dump_tree\t\t\t\tPARAMS ((void *, tree));\n-\n-extern void pch_init\t\t\t\tPARAMS ((void));\n-extern int c_common_valid_pch\t\t\tPARAMS ((cpp_reader *pfile,\n-\t\t\t\t\t\t\t const char *name,\n-\t\t\t\t\t\t\t int fd));\n-extern void c_common_read_pch\t\t\tPARAMS ((cpp_reader *pfile,\n-\t\t\t\t\t\t\t const char *name,\n-\t\t\t\t\t\t\t int fd,\n-\t\t\t\t\t\t\t const char *orig));\n-extern void c_common_write_pch\t\t\tPARAMS ((void));\n-extern void builtin_define_with_value\t\tPARAMS ((const char *,\n-\t\t\t\t\t\t\t const char *, int));\n-extern void c_stddef_cpp_builtins\t\tPARAMS ((void));\n-extern void fe_file_change\t\tPARAMS ((const struct line_map *));\n+struct c_fileinfo *get_fileinfo (const char *);\n+extern void dump_time_statistics (void);\n+\n+extern bool c_dump_tree (void *, tree);\n+\n+extern void pch_init (void);\n+extern int c_common_valid_pch (cpp_reader *pfile, const char *name, int fd);\n+extern void c_common_read_pch (cpp_reader *pfile, const char *name, int fd,\n+\t\t\t       const char *orig);\n+extern void c_common_write_pch (void);\n+extern void builtin_define_with_value (const char *, const char *, int);\n+extern void c_stddef_cpp_builtins (void);\n+extern void fe_file_change (const struct line_map *);\n \n /* In c-ppoutput.c  */\n-extern void init_pp_output\t\t\tPARAMS ((FILE *));\n-extern void preprocess_file\t\t\tPARAMS ((cpp_reader *));\n-extern void pp_file_change\t\tPARAMS ((const struct line_map *));\n+extern void init_pp_output (FILE *);\n+extern void preprocess_file (cpp_reader *);\n+extern void pp_file_change (const struct line_map *);\n \n #endif /* ! GCC_C_COMMON_H */"}, {"sha": "ce095acc29a5543616cb869126be0572374bb51a", "filename": "gcc/c-convert.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=35b1a6faebd652c6d95cc709ddf8af02ff0feced", "patch": "@@ -1,5 +1,6 @@\n /* Language-level data type conversion for GNU C.\n-   Copyright (C) 1987, 1988, 1991, 1998, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991, 1998, 2002, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -62,8 +63,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    not permitted by the language being compiled.  */\n \n tree\n-convert (type, expr)\n-     tree type, expr;\n+convert (tree type, tree expr)\n {\n   tree e = expr;\n   enum tree_code code = TREE_CODE (type);"}, {"sha": "1dfc5d0c167a37327d2aeae67fab9b1cbd9093bb", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 30, "deletions": 52, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=35b1a6faebd652c6d95cc709ddf8af02ff0feced", "patch": "@@ -45,35 +45,29 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #endif\n \n /* Non-static as some targets don't use it.  */\n-void builtin_define_std PARAMS ((const char *)) ATTRIBUTE_UNUSED;\n-static void builtin_define_with_value_n PARAMS ((const char *, const char *,\n-\t\t\t\t\t\t size_t));\n-static void builtin_define_with_int_value PARAMS ((const char *,\n-\t\t\t\t\t\t   HOST_WIDE_INT));\n-static void builtin_define_with_hex_fp_value PARAMS ((const char *, tree,\n-\t\t\t\t\t\t      int, const char *,\n-\t\t\t\t\t\t      const char *));\n-static void builtin_define_type_max PARAMS ((const char *, tree, int));\n-static void builtin_define_type_precision PARAMS ((const char *, tree));\n-static void builtin_define_float_constants PARAMS ((const char *,\n-\t\t\t\t\t\t    const char *, tree));\n-static void define__GNUC__\t\tPARAMS ((void));\n+void builtin_define_std (const char *) ATTRIBUTE_UNUSED;\n+static void builtin_define_with_value_n (const char *, const char *,\n+\t\t\t\t\t size_t);\n+static void builtin_define_with_int_value (const char *, HOST_WIDE_INT);\n+static void builtin_define_with_hex_fp_value (const char *, tree,\n+\t\t\t\t\t      int, const char *,\n+\t\t\t\t\t      const char *);\n+static void builtin_define_type_max (const char *, tree, int);\n+static void builtin_define_type_precision (const char *, tree);\n+static void builtin_define_float_constants (const char *, const char *,\n+\t\t\t\t\t    tree);\n+static void define__GNUC__ (void);\n \n /* Define NAME with value TYPE precision.  */\n static void\n-builtin_define_type_precision (name, type)\n-     const char *name;\n-     tree type;\n+builtin_define_type_precision (const char *name, tree type)\n {\n   builtin_define_with_int_value (name, TYPE_PRECISION (type));\n }\n \n /* Define the float.h constants for TYPE using NAME_PREFIX and FP_SUFFIX.  */\n static void\n-builtin_define_float_constants (name_prefix, fp_suffix, type)\n-     const char *name_prefix;\n-     const char *fp_suffix;\n-     tree type;\n+builtin_define_float_constants (const char *name_prefix, const char *fp_suffix, tree type)\n {\n   /* Used to convert radix-based values to base 10 values in several cases.\n \n@@ -107,7 +101,7 @@ builtin_define_float_constants (name_prefix, fp_suffix, type)\n      p radix b digits and back again without change to the q decimal digits,\n \n \tp log10 b\t\t\tif b is a power of 10\n- \tfloor((p - 1) log10 b)\t\totherwise\n+\tfloor((p - 1) log10 b)\t\totherwise\n   */\n   dig = (fmt->p - 1) * log10_b;\n   sprintf (name, \"__%s_DIG__\", name_prefix);\n@@ -166,7 +160,7 @@ builtin_define_float_constants (name_prefix, fp_suffix, type)\n \n   /* The number of decimal digits, n, such that any floating-point number\n      can be rounded to n decimal digits and back again without change to\n-     the value. \n+     the value.\n \n \tp * log10(b)\t\t\tif b is a power of 10\n \tceil(1 + p * log10(b))\t\totherwise\n@@ -233,7 +227,7 @@ builtin_define_float_constants (name_prefix, fp_suffix, type)\n \n   /* For C++ std::numeric_limits<T>::has_infinity.  */\n   sprintf (name, \"__%s_HAS_INFINITY__\", name_prefix);\n-  builtin_define_with_int_value (name, \n+  builtin_define_with_int_value (name,\n \t\t\t\t MODE_HAS_INFINITIES (TYPE_MODE (type)));\n   /* For C++ std::numeric_limits<T>::has_quiet_NaN.  We do not have a\n      predicate to distinguish a target that has both quiet and\n@@ -246,7 +240,7 @@ builtin_define_float_constants (name_prefix, fp_suffix, type)\n \n /* Define __GNUC__, __GNUC_MINOR__ and __GNUC_PATCHLEVEL__.  */\n static void\n-define__GNUC__ ()\n+define__GNUC__ (void)\n {\n   /* The format of the version string, enforced below, is\n      ([^0-9]*-)?[0-9]+[.][0-9]+([.][0-9]+)?([- ].*)?  */\n@@ -289,8 +283,7 @@ define__GNUC__ ()\n \n /* Hook that registers front end and target-specific built-ins.  */\n void\n-c_cpp_builtins (pfile)\n-     cpp_reader *pfile;\n+c_cpp_builtins (cpp_reader *pfile)\n {\n   /* -undef turns off target-specific built-ins.  */\n   if (flag_undef)\n@@ -357,7 +350,7 @@ c_cpp_builtins (pfile)\n       cpp_define (pfile, \"_LP64\");\n       cpp_define (pfile, \"__LP64__\");\n     }\n-  \n+\n   /* Other target-independent built-ins determined by command-line\n      options.  */\n   if (optimize_size)\n@@ -410,8 +403,7 @@ c_cpp_builtins (pfile)\n    \"unix\".  Passing \"_mips\" defines \"__mips\", \"__mips__\" and possibly\n    \"_mips\".  */\n void\n-builtin_define_std (macro)\n-     const char *macro;\n+builtin_define_std (const char *macro)\n {\n   size_t len = strlen (macro);\n   char *buff = alloca (len + 5);\n@@ -450,10 +442,7 @@ builtin_define_std (macro)\n    parameter says whether or not to turn the value into a string\n    constant.  */\n void\n-builtin_define_with_value (macro, expansion, is_str)\n-     const char *macro;\n-     const char *expansion;\n-     int is_str;\n+builtin_define_with_value (const char *macro, const char *expansion, int is_str)\n {\n   char *buf;\n   size_t mlen = strlen (macro);\n@@ -475,14 +464,11 @@ builtin_define_with_value (macro, expansion, is_str)\n /* Pass an object-like macro and a value to define it to.  The third\n    parameter is the length of the expansion.  */\n static void\n-builtin_define_with_value_n (macro, expansion, elen)\n-     const char *macro;\n-     const char *expansion;\n-     size_t elen;\n+builtin_define_with_value_n (const char *macro, const char *expansion, size_t elen)\n {\n   char *buf;\n   size_t mlen = strlen (macro);\n-  \n+\n   /* Space for an = and a NUL.  */\n   buf = alloca (mlen + elen + 2);\n   memcpy (buf, macro, mlen);\n@@ -495,9 +481,7 @@ builtin_define_with_value_n (macro, expansion, elen)\n \n /* Pass an object-like macro and an integer value to define it to.  */\n static void\n-builtin_define_with_int_value (macro, value)\n-     const char *macro;\n-     HOST_WIDE_INT value;\n+builtin_define_with_int_value (const char *macro, HOST_WIDE_INT value)\n {\n   char *buf;\n   size_t mlen = strlen (macro);\n@@ -514,12 +498,9 @@ builtin_define_with_int_value (macro, value)\n \n /* Pass an object-like macro a hexadecimal floating-point value.  */\n static void\n-builtin_define_with_hex_fp_value (macro, type, digits, hex_str, fp_suffix)\n-     const char *macro;\n-     tree type ATTRIBUTE_UNUSED;\n-     int digits;\n-     const char *hex_str;\n-     const char *fp_suffix;\n+builtin_define_with_hex_fp_value (const char *macro,\n+\t\t\t\t  tree type ATTRIBUTE_UNUSED, int digits,\n+\t\t\t\t  const char *hex_str, const char *fp_suffix)\n {\n   REAL_VALUE_TYPE real;\n   char dec_str[64], buf[256];\n@@ -530,7 +511,7 @@ builtin_define_with_hex_fp_value (macro, type, digits, hex_str, fp_suffix)\n      pedwarn from the preprocessor, which has no context, so we can't\n      suppress the warning with __extension__.\n \n-     So instead what we do is construct the number in hex (because \n+     So instead what we do is construct the number in hex (because\n      it's easy to get the exact correct value), parse it as a real,\n      then print it back out as decimal.  */\n \n@@ -546,10 +527,7 @@ builtin_define_with_hex_fp_value (macro, type, digits, hex_str, fp_suffix)\n    unsigned types, since wchar_t might be unsigned.  */\n \n static void\n-builtin_define_type_max (macro, type, is_long)\n-     const char *macro;\n-     tree type;\n-     int is_long;\n+builtin_define_type_max (const char *macro, tree type, int is_long)\n {\n   static const char *const values[]\n     = { \"127\", \"255\","}, {"sha": "a33510cd7ac1541032d0d6cea3f2ceaa40ce029e", "filename": "gcc/c-decl.c", "status": "modified", "additions": 133, "deletions": 236, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=35b1a6faebd652c6d95cc709ddf8af02ff0feced", "patch": "@@ -263,32 +263,31 @@ tree static_ctors, static_dtors;\n \n /* Forward declarations.  */\n \n-static struct binding_level *make_binding_level\t\tPARAMS ((void));\n-static void pop_binding_level\t\tPARAMS ((struct binding_level **));\n-static int duplicate_decls\t\tPARAMS ((tree, tree, int));\n-static int redeclaration_error_message\tPARAMS ((tree, tree));\n-static void implicit_decl_warning       PARAMS ((tree));\n-static void storedecls\t\t\tPARAMS ((tree));\n-static void storetags\t\t\tPARAMS ((tree));\n-static tree lookup_tag\t\t\tPARAMS ((enum tree_code, tree, int));\n-static tree lookup_name_current_level\tPARAMS ((tree));\n-static tree grokdeclarator\t\tPARAMS ((tree, tree, enum decl_context,\n-\t\t\t\t\t\t int));\n-static tree grokparms\t\t\tPARAMS ((tree, int));\n-static void layout_array_type\t\tPARAMS ((tree));\n-static tree c_make_fname_decl           PARAMS ((tree, int));\n-static void c_expand_body_1             PARAMS ((tree, int));\n-static tree any_external_decl\t\tPARAMS ((tree));\n-static void record_external_decl\tPARAMS ((tree));\n-static void warn_if_shadowing\t\tPARAMS ((tree, tree));\n-static void clone_underlying_type\tPARAMS ((tree));\n-static bool flexible_array_type_p\tPARAMS ((tree));\n+static struct binding_level *make_binding_level (void);\n+static void pop_binding_level (struct binding_level **);\n+static int duplicate_decls (tree, tree, int);\n+static int redeclaration_error_message (tree, tree);\n+static void implicit_decl_warning (tree);\n+static void storedecls (tree);\n+static void storetags (tree);\n+static tree lookup_tag (enum tree_code, tree, int);\n+static tree lookup_name_current_level (tree);\n+static tree grokdeclarator (tree, tree, enum decl_context, int);\n+static tree grokparms (tree, int);\n+static void layout_array_type (tree);\n+static tree c_make_fname_decl (tree, int);\n+static void c_expand_body_1 (tree, int);\n+static tree any_external_decl (tree);\n+static void record_external_decl (tree);\n+static void warn_if_shadowing (tree, tree);\n+static void clone_underlying_type (tree);\n+static bool flexible_array_type_p (tree);\n \f\n /* States indicating how grokdeclarator() should handle declspecs marked\n    with __attribute__((deprecated)).  An object declared as\n    __attribute__((deprecated)) suppresses warnings of uses of other\n    deprecated items.  */\n-   \n+\n enum deprecated_states {\n   DEPRECATED_NORMAL,\n   DEPRECATED_SUPPRESS\n@@ -297,10 +296,7 @@ enum deprecated_states {\n static enum deprecated_states deprecated_state = DEPRECATED_NORMAL;\n \n void\n-c_print_identifier (file, node, indent)\n-     FILE *file;\n-     tree node;\n-     int indent;\n+c_print_identifier (FILE *file, tree node, int indent)\n {\n   print_node (file, \"symbol\", IDENTIFIER_SYMBOL_VALUE (node), indent + 4);\n   print_node (file, \"tag\", IDENTIFIER_TAG_VALUE (node), indent + 4);\n@@ -319,8 +315,7 @@ c_print_identifier (file, node, indent)\n    for a top-level tentative array defn that wasn't complete before.  */\n \n void\n-c_finish_incomplete_decl (decl)\n-     tree decl;\n+c_finish_incomplete_decl (tree decl)\n {\n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n@@ -342,7 +337,7 @@ c_finish_incomplete_decl (decl)\n /* Reuse or create a struct for this binding level.  */\n \n static struct binding_level *\n-make_binding_level ()\n+make_binding_level (void)\n {\n   struct binding_level *result;\n   if (free_binding_level)\n@@ -361,12 +356,11 @@ make_binding_level ()\n /* Remove a binding level from a list and add it to the level chain.  */\n \n static void\n-pop_binding_level (lp)\n-     struct binding_level **lp;\n+pop_binding_level (struct binding_level **lp)\n {\n   struct binding_level *l = *lp;\n   *lp = l->level_chain;\n-  \n+\n   memset (l, 0, sizeof (struct binding_level));\n   l->level_chain = free_binding_level;\n   free_binding_level = l;\n@@ -375,21 +369,21 @@ pop_binding_level (lp)\n /* Nonzero if we are currently in the global binding level.  */\n \n int\n-global_bindings_p ()\n+global_bindings_p (void)\n {\n   return current_binding_level == global_binding_level;\n }\n \n void\n-keep_next_level ()\n+keep_next_level (void)\n {\n   keep_next_level_flag = 1;\n }\n \n /* Nonzero if the current level needs to have a BLOCK made.  */\n \n int\n-kept_level_p ()\n+kept_level_p (void)\n {\n   return ((current_binding_level->keep_if_subblocks\n \t   && current_binding_level->blocks != 0)\n@@ -404,25 +398,23 @@ kept_level_p ()\n    DEFINITION_FLAG, so we ignore it.  */\n \n void\n-declare_parm_level (definition_flag)\n-     int definition_flag ATTRIBUTE_UNUSED;\n+declare_parm_level (int definition_flag ATTRIBUTE_UNUSED)\n {\n   current_binding_level->parm_flag = 1;\n }\n \n /* Nonzero if currently making parm declarations.  */\n \n int\n-in_parm_level_p ()\n+in_parm_level_p (void)\n {\n   return current_binding_level->parm_flag;\n }\n \n /* Enter a new binding level.  */\n \n void\n-pushlevel (dummy)\n-     int dummy ATTRIBUTE_UNUSED;\n+pushlevel (int dummy ATTRIBUTE_UNUSED)\n {\n   /* If this is the top level of a function, make sure that\n      NAMED_LABELS is 0.  */\n@@ -475,10 +467,7 @@ pushlevel (dummy)\n    them into the BLOCK.  */\n \n tree\n-poplevel (keep, reverse, functionbody)\n-     int keep;\n-     int reverse;\n-     int functionbody;\n+poplevel (int keep, int reverse, int functionbody)\n {\n   tree link;\n   tree block;\n@@ -659,8 +648,7 @@ poplevel (keep, reverse, functionbody)\n    to handle the BLOCK node inside the BIND_EXPR.  */\n \n void\n-insert_block (block)\n-     tree block;\n+insert_block (tree block)\n {\n   TREE_USED (block) = 1;\n   current_binding_level->blocks\n@@ -672,13 +660,12 @@ insert_block (block)\n    this hook, but it is not useful in function-at-a-time mode.  */\n \n void\n-set_block (block)\n-     tree block ATTRIBUTE_UNUSED;\n+set_block (tree block ATTRIBUTE_UNUSED)\n {\n }\n \f\n void\n-push_label_level ()\n+push_label_level (void)\n {\n   struct binding_level *newlevel;\n \n@@ -696,7 +683,7 @@ push_label_level ()\n }\n \n void\n-pop_label_level ()\n+pop_label_level (void)\n {\n   struct binding_level *level = label_level_chain;\n   tree link, prev;\n@@ -755,8 +742,7 @@ pop_label_level ()\n    In that case, the TYPE_SIZE will be zero.  */\n \n void\n-pushtag (name, type)\n-     tree name, type;\n+pushtag (tree name, tree type)\n {\n   struct binding_level *b = current_binding_level;\n \n@@ -801,9 +787,7 @@ pushtag (name, type)\n    and OLDDECL is in an outer binding level and should thus not be changed.  */\n \n static int\n-duplicate_decls (newdecl, olddecl, different_binding_level)\n-     tree newdecl, olddecl;\n-     int different_binding_level;\n+duplicate_decls (tree newdecl, tree olddecl, int different_binding_level)\n {\n   int types_match = comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl));\n   int new_is_definition = (TREE_CODE (newdecl) == FUNCTION_DECL\n@@ -1547,8 +1531,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n    currently in scope.  */\n \n static tree\n-any_external_decl (id)\n-     tree id;\n+any_external_decl (tree id)\n {\n   tree decl = IDENTIFIER_SYMBOL_VALUE (id);\n   tree t;\n@@ -1568,8 +1551,7 @@ any_external_decl (id)\n /* Record an external decl DECL.  This only does something if a\n    shadowing decl already exists.  */\n static void\n-record_external_decl (decl)\n-     tree decl;\n+record_external_decl (tree decl)\n {\n   tree name = DECL_NAME (decl);\n   if (!IDENTIFIER_SYMBOL_VALUE (name))\n@@ -1582,8 +1564,7 @@ record_external_decl (decl)\n    OLD is the old IDENTIFIER_SYMBOL_VALUE of the DECL_NAME of X,\n    which might be a NULL_TREE.  */\n static void\n-warn_if_shadowing (x, old)\n-     tree x, old;\n+warn_if_shadowing (tree x, tree old)\n {\n   const char *name;\n \n@@ -1660,8 +1641,7 @@ warn_if_shadowing (x, old)\n     on a standard type by checking the current value of lineno.  */\n \n static void\n-clone_underlying_type (x)\n-     tree x;\n+clone_underlying_type (tree x)\n {\n   if (DECL_SOURCE_LINE (x) == 0)\n     {\n@@ -1689,8 +1669,7 @@ clone_underlying_type (x)\n    to agree with what X says.  */\n \n tree\n-pushdecl (x)\n-     tree x;\n+pushdecl (tree x)\n {\n   tree name = DECL_NAME (x);\n   struct binding_level *scope = current_binding_level;\n@@ -1744,7 +1723,7 @@ pushdecl (x)\n \t  else\n \t    record_external_decl (x);\n \t}\n-\t  \n+\n       if (TREE_CODE (x) == TYPE_DECL)\n \tclone_underlying_type (x);\n \n@@ -1797,8 +1776,7 @@ pushdecl (x)\n    and is limited to its needs.  It will hork if there is _any_\n    visible binding for X (not just a global one).  */\n tree\n-pushdecl_top_level (x)\n-     tree x;\n+pushdecl_top_level (tree x)\n {\n   tree name, old;\n \n@@ -1834,9 +1812,7 @@ pushdecl_top_level (x)\n    called; if there is any preexisting decl for this identifier, it is\n    an ICE.  */\n tree\n-pushdecl_function_level (x, name)\n-     tree x;\n-     tree name;\n+pushdecl_function_level (tree x, tree name)\n {\n   struct binding_level *scope;\n \n@@ -1869,8 +1845,7 @@ pushdecl_function_level (x, name)\n    function of type int ().  */\n \n tree\n-implicitly_declare (functionid)\n-     tree functionid;\n+implicitly_declare (tree functionid)\n {\n   tree decl = any_external_decl (functionid);\n \n@@ -1922,8 +1897,7 @@ implicitly_declare (functionid)\n }\n \n static void\n-implicit_decl_warning (id)\n-     tree id;\n+implicit_decl_warning (tree id)\n {\n   const char *name = IDENTIFIER_POINTER (id);\n   if (mesg_implicit_function_declaration == 2)\n@@ -1939,8 +1913,7 @@ implicit_decl_warning (id)\n    and 3 if it is a conflicting declaration.  */\n \n static int\n-redeclaration_error_message (newdecl, olddecl)\n-     tree newdecl, olddecl;\n+redeclaration_error_message (tree newdecl, tree olddecl)\n {\n   if (TREE_CODE (newdecl) == TYPE_DECL)\n     {\n@@ -2001,8 +1974,7 @@ redeclaration_error_message (newdecl, olddecl)\n    This function is called for both label definitions and label references.  */\n \n tree\n-lookup_label (id)\n-     tree id;\n+lookup_label (tree id)\n {\n   tree decl = IDENTIFIER_LABEL_VALUE (id);\n \n@@ -2050,8 +2022,7 @@ lookup_label (id)\n    requires calling declare_nonlocal_label right away.  */\n \n tree\n-shadow_label (name)\n-     tree name;\n+shadow_label (tree name)\n {\n   tree decl = IDENTIFIER_LABEL_VALUE (name);\n \n@@ -2124,15 +2095,15 @@ define_label (const char* filename, int line, tree name)\n    store the result back using `storedecls' or you will lose.  */\n \n tree\n-getdecls ()\n+getdecls (void)\n {\n   return current_binding_level->names;\n }\n \n /* Return the list of type-tags (for structs, etc) of the current level.  */\n \n tree\n-gettags ()\n+gettags (void)\n {\n   return current_binding_level->tags;\n }\n@@ -2142,17 +2113,15 @@ gettags ()\n    after they are modified in the light of any missing parameters.  */\n \n static void\n-storedecls (decls)\n-     tree decls;\n+storedecls (tree decls)\n {\n   current_binding_level->names = decls;\n }\n \n /* Similarly, store the list of tags of the current level.  */\n \n static void\n-storetags (tags)\n-     tree tags;\n+storetags (tree tags)\n {\n   current_binding_level->tags = tags;\n }\n@@ -2165,10 +2134,7 @@ storetags (tags)\n    If the wrong kind of type is found, an error is reported.  */\n \n static tree\n-lookup_tag (code, name, thislevel_only)\n-     enum tree_code code;\n-     tree name;\n-     int thislevel_only;\n+lookup_tag (enum tree_code code, tree name, int thislevel_only)\n {\n   tree tag = IDENTIFIER_TAG_VALUE (name);\n   int thislevel = 0;\n@@ -2210,7 +2176,7 @@ lookup_tag (code, name, thislevel_only)\n    when used in the `struct foo;' construct for shadowing.  */\n \n void\n-pending_xref_error ()\n+pending_xref_error (void)\n {\n   if (pending_invalid_xref != 0)\n     error (\"%H`%s' defined as wrong kind of tag\",\n@@ -2226,8 +2192,7 @@ pending_xref_error ()\n    or return 0 if it is undefined.  */\n \n tree\n-lookup_name (name)\n-     tree name;\n+lookup_name (tree name)\n {\n   tree decl = IDENTIFIER_SYMBOL_VALUE (name);\n   if (decl == 0 || decl == error_mark_node)\n@@ -2240,8 +2205,7 @@ lookup_name (name)\n /* Similar to `lookup_name' but look only at the current binding level.  */\n \n static tree\n-lookup_name_current_level (name)\n-     tree name;\n+lookup_name_current_level (tree name)\n {\n   tree decl = IDENTIFIER_SYMBOL_VALUE (name);\n \n@@ -2264,7 +2228,7 @@ lookup_name_current_level (name)\n    Make definitions for built-in primitive functions.  */\n \n void\n-c_init_decl_processing ()\n+c_init_decl_processing (void)\n {\n   tree endlink;\n   tree ptr_ftype_void, ptr_ftype_ptr;\n@@ -2330,9 +2294,7 @@ c_init_decl_processing ()\n    are string merging candidates, which is wrong for C99's __func__.  FIXME.  */\n \n static tree\n-c_make_fname_decl (id, type_dep)\n-     tree id;\n-     int type_dep;\n+c_make_fname_decl (tree id, int type_dep)\n {\n   const char *name = fname_as_string (type_dep);\n   tree decl, type, init;\n@@ -2343,11 +2305,11 @@ c_make_fname_decl (id, type_dep)\n \t   build_index_type (size_int (length)));\n \n   decl = build_decl (VAR_DECL, id, type);\n-  \n+\n   TREE_STATIC (decl) = 1;\n   TREE_READONLY (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n-  \n+\n   init = build_string (length + 1, name);\n   TREE_TYPE (init) = type;\n   DECL_INITIAL (decl) = init;\n@@ -2372,13 +2334,9 @@ c_make_fname_decl (id, type_dep)\n    ATTRS is nonzero, use that for the function's attribute list.  */\n \n tree\n-builtin_function (name, type, function_code, class, library_name, attrs)\n-     const char *name;\n-     tree type;\n-     int function_code;\n-     enum built_in_class class;\n-     const char *library_name;\n-     tree attrs;\n+builtin_function (const char *name, tree type, int function_code,\n+\t\t  enum built_in_class class, const char *library_name,\n+\t\t  tree attrs)\n {\n   tree decl = build_decl (FUNCTION_DECL, get_identifier (name), type);\n   DECL_EXTERNAL (decl) = 1;\n@@ -2408,8 +2366,7 @@ builtin_function (name, type, function_code, class, library_name, attrs)\n    attributes.  */\n \n void\n-c_insert_default_attributes (decl)\n-     tree decl;\n+c_insert_default_attributes (tree decl)\n {\n   if (!TREE_PUBLIC (decl))\n     return;\n@@ -2425,16 +2382,15 @@ c_insert_default_attributes (decl)\n    Otherwise, it is an error.  */\n \n void\n-shadow_tag (declspecs)\n-     tree declspecs;\n+shadow_tag (tree declspecs)\n {\n   shadow_tag_warned (declspecs, 0);\n }\n \n void\n-shadow_tag_warned (declspecs, warned)\n-     tree declspecs;\n-     int warned;\n+shadow_tag_warned (tree declspecs, int warned)\n+\n+\n      /* 1 => we have done a pedwarn.  2 => we have done a warning, but\n \tno pedwarn.  */\n {\n@@ -2515,11 +2471,7 @@ shadow_tag_warned (declspecs, warned)\n    which has TREE_STATIC set if \"static\" is used.  */\n \n tree\n-build_array_declarator (expr, quals, static_p, vla_unspec_p)\n-     tree expr;\n-     tree quals;\n-     int static_p;\n-     int vla_unspec_p;\n+build_array_declarator (tree expr, tree quals, int static_p, int vla_unspec_p)\n {\n   tree decl;\n   decl = build_nt (ARRAY_REF, NULL_TREE, expr);\n@@ -2545,10 +2497,7 @@ build_array_declarator (expr, quals, static_p, vla_unspec_p)\n    C99 grammar.  */\n \n tree\n-set_array_declarator_type (decl, type, abstract_p)\n-     tree decl;\n-     tree type;\n-     int abstract_p;\n+set_array_declarator_type (tree decl, tree type, int abstract_p)\n {\n   TREE_OPERAND (decl, 0) = type;\n   if (abstract_p && (TREE_TYPE (decl) != NULL_TREE || TREE_STATIC (decl)))\n@@ -2559,8 +2508,7 @@ set_array_declarator_type (decl, type, abstract_p)\n /* Decode a \"typename\", such as \"int **\", returning a ..._TYPE node.  */\n \n tree\n-groktypename (typename)\n-     tree typename;\n+groktypename (tree typename)\n {\n   tree specs, attrs;\n \n@@ -2580,8 +2528,7 @@ groktypename (typename)\n /* Return a PARM_DECL node for a given pair of specs and declarator.  */\n \n tree\n-groktypename_in_parm_context (typename)\n-     tree typename;\n+groktypename_in_parm_context (tree typename)\n {\n   if (TREE_CODE (typename) != TREE_LIST)\n     return typename;\n@@ -2606,22 +2553,19 @@ groktypename_in_parm_context (typename)\n    grokfield and not through here.  */\n \n tree\n-start_decl (declarator, declspecs, initialized, attributes)\n-     tree declarator, declspecs;\n-     int initialized;\n-     tree attributes;\n+start_decl (tree declarator, tree declspecs, int initialized, tree attributes)\n {\n   tree decl;\n   tree tem;\n-  \n+\n   /* An object declared as __attribute__((deprecated)) suppresses\n      warnings of uses of other deprecated items.  */\n   if (lookup_attribute (\"deprecated\", attributes))\n     deprecated_state = DEPRECATED_SUPPRESS;\n \n   decl = grokdeclarator (declarator, declspecs,\n \t\t\t NORMAL, initialized);\n-  \n+\n   deprecated_state = DEPRECATED_NORMAL;\n \n   if (warn_main > 0 && TREE_CODE (decl) != FUNCTION_DECL\n@@ -2773,9 +2717,7 @@ start_decl (declarator, declspecs, initialized, attributes)\n    it must be determined now, from the initial value, or it is an error.  */\n \n void\n-finish_decl (decl, init, asmspec_tree)\n-     tree decl, init;\n-     tree asmspec_tree;\n+finish_decl (tree decl, tree init, tree asmspec_tree)\n {\n   tree type = TREE_TYPE (decl);\n   int was_incomplete = (DECL_SIZE (decl) == 0);\n@@ -2790,7 +2732,7 @@ finish_decl (decl, init, asmspec_tree)\n   /* If `start_decl' didn't like having an initialization, ignore it now.  */\n   if (init != 0 && DECL_INITIAL (decl) == 0)\n     init = 0;\n-  \n+\n   /* Don't crash if parm is initialized.  */\n   if (TREE_CODE (decl) == PARM_DECL)\n     init = 0;\n@@ -2953,7 +2895,7 @@ finish_decl (decl, init, asmspec_tree)\n \t\t ordinary, non-register local variable.  Historically,\n \t\t GCC has accepted -- but ignored -- the ASMSPEC in\n \t\t this case.  */\n-\t      if (TREE_CODE (decl) == VAR_DECL \n+\t      if (TREE_CODE (decl) == VAR_DECL\n \t\t  && !DECL_REGISTER (decl)\n \t\t  && !TREE_STATIC (decl))\n \t\twarning_with_decl (decl,\n@@ -3038,8 +2980,7 @@ finish_decl (decl, init, asmspec_tree)\n    record the given order of parms in `parm_order'.  */\n \n void\n-push_parm_decl (parm)\n-     tree parm;\n+push_parm_decl (tree parm)\n {\n   tree decl;\n   int old_immediate_size_expand = immediate_size_expand;\n@@ -3077,7 +3018,7 @@ push_parm_decl (parm)\n    and also at semicolon terminating forward decls.  */\n \n void\n-clear_parm_order ()\n+clear_parm_order (void)\n {\n   current_binding_level->parm_order = NULL_TREE;\n }\n@@ -3090,9 +3031,7 @@ static GTY(()) int compound_literal_number;\n    literal.  */\n \n tree\n-build_compound_literal (type, init)\n-     tree type;\n-     tree init;\n+build_compound_literal (tree type, tree init)\n {\n   /* We do not use start_decl here because we have a type, not a declarator;\n      and do not use finish_decl because the decl should be stored inside\n@@ -3132,7 +3071,7 @@ build_compound_literal (type, init)\n \t a unique suffix to be added to the name.  */\n       char *name;\n \n-      ASM_FORMAT_PRIVATE_NAME (name, \"__compound_literal\", \n+      ASM_FORMAT_PRIVATE_NAME (name, \"__compound_literal\",\n \t\t\t       compound_literal_number);\n       compound_literal_number++;\n       DECL_NAME (decl) = get_identifier (name);\n@@ -3151,10 +3090,7 @@ build_compound_literal (type, init)\n    2 if there was no information (in which case assume 1 if DO_DEFAULT).  */\n \n int\n-complete_array_type (type, initial_value, do_default)\n-     tree type;\n-     tree initial_value;\n-     int do_default;\n+complete_array_type (tree type, tree initial_value, int do_default)\n {\n   tree maxindex = NULL_TREE;\n   int value = 0;\n@@ -3220,8 +3156,7 @@ complete_array_type (type, initial_value, do_default)\n    or a union containing such a structure (possibly recursively).  */\n \n static bool\n-flexible_array_type_p (type)\n-     tree type;\n+flexible_array_type_p (tree type)\n {\n   tree x;\n   switch (TREE_CODE (type))\n@@ -3280,11 +3215,8 @@ flexible_array_type_p (type)\n    and `extern' are interpreted.  */\n \n static tree\n-grokdeclarator (declarator, declspecs, decl_context, initialized)\n-     tree declspecs;\n-     tree declarator;\n-     enum decl_context decl_context;\n-     int initialized;\n+grokdeclarator (tree declarator, tree declspecs,\n+\t\tenum decl_context decl_context, int initialized)\n {\n   int specbits = 0;\n   tree spec;\n@@ -4301,7 +4233,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  }\n \telse if (type_quals)\n \t  type = c_build_qualified_type (type, type_quals);\n-\t  \n+\n \ttype_as_written = type;\n \n \tdecl = build_decl (PARM_DECL, declarator, type);\n@@ -4464,7 +4396,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t    tree global_decl;\n \n \t    global_decl = identifier_global_value (declarator);\n-\t    if (global_decl \n+\t    if (global_decl\n \t\t&& TREE_CODE (global_decl) == VAR_DECL\n \t\t&& !TREE_PUBLIC (global_decl))\n \t      error (\"variable previously declared `static' redeclared \"\n@@ -4548,9 +4480,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n    when FUNCDEF_FLAG is zero.  */\n \n static tree\n-grokparms (parms_info, funcdef_flag)\n-     tree parms_info;\n-     int funcdef_flag;\n+grokparms (tree parms_info, int funcdef_flag)\n {\n   tree first_parm = TREE_CHAIN (parms_info);\n \n@@ -4645,8 +4575,7 @@ grokparms (parms_info, funcdef_flag)\n    Zero means the parmlist ended with an ellipsis so don't append `void'.  */\n \n tree\n-get_parm_info (void_at_end)\n-     int void_at_end;\n+get_parm_info (int void_at_end)\n {\n   tree decl, t;\n   tree types = 0;\n@@ -4746,7 +4675,7 @@ get_parm_info (void_at_end)\n    defined within.  Do so because these types cannot ever become complete.  */\n \n void\n-parmlist_tags_warning ()\n+parmlist_tags_warning (void)\n {\n   tree elt;\n   static int already;\n@@ -4792,9 +4721,7 @@ parmlist_tags_warning ()\n    Define the tag as a forward-reference if it is not defined.  */\n \n tree\n-xref_tag (code, name)\n-     enum tree_code code;\n-     tree name;\n+xref_tag (enum tree_code code, tree name)\n {\n   /* If a cross reference is requested, look up the type\n      already defined for this tag and return it.  */\n@@ -4843,9 +4770,7 @@ xref_tag (code, name)\n    CODE says which kind of tag NAME ought to be.  */\n \n tree\n-start_struct (code, name)\n-     enum tree_code code;\n-     tree name;\n+start_struct (enum tree_code code, tree name)\n {\n   /* If there is already a tag defined at this binding level\n      (as a forward reference), just return it.  */\n@@ -4862,7 +4787,7 @@ start_struct (code, name)\n \t    error (\"redefinition of `union %s'\", IDENTIFIER_POINTER (name));\n           else\n \t    error (\"redefinition of `struct %s'\", IDENTIFIER_POINTER (name));\n-\t}  \n+\t}\n     }\n   else\n     {\n@@ -4871,7 +4796,7 @@ start_struct (code, name)\n       ref = make_node (code);\n       pushtag (name, ref);\n     }\n-  \n+\n   C_TYPE_BEING_DEFINED (ref) = 1;\n   TYPE_PACKED (ref) = flag_pack_struct;\n   return ref;\n@@ -4886,10 +4811,8 @@ start_struct (code, name)\n    are ultimately passed to `build_struct' to make the RECORD_TYPE node.  */\n \n tree\n-grokfield (filename, line, declarator, declspecs, width)\n-     const char *filename ATTRIBUTE_UNUSED;\n-     int line ATTRIBUTE_UNUSED;\n-     tree declarator, declspecs, width;\n+grokfield (const char *filename ATTRIBUTE_UNUSED, int line ATTRIBUTE_UNUSED,\n+\t   tree declarator, tree declspecs, tree width)\n {\n   tree value;\n \n@@ -5009,10 +4932,7 @@ detect_field_duplicates (tree fieldlist)\n    ATTRIBUTES are attributes to be applied to the structure.  */\n \n tree\n-finish_struct (t, fieldlist, attributes)\n-     tree t;\n-     tree fieldlist;\n-     tree attributes;\n+finish_struct (tree t, tree fieldlist, tree attributes)\n {\n   tree x;\n   int toplevel = global_binding_level == current_binding_level;\n@@ -5289,8 +5209,7 @@ finish_struct (t, fieldlist, attributes)\n /* Lay out the type T, and its element type, and so on.  */\n \n static void\n-layout_array_type (t)\n-     tree t;\n+layout_array_type (tree t)\n {\n   if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n     layout_array_type (TREE_TYPE (t));\n@@ -5304,8 +5223,7 @@ layout_array_type (t)\n    may be used to declare the individual values as they are read.  */\n \n tree\n-start_enum (name)\n-     tree name;\n+start_enum (tree name)\n {\n   tree enumtype = 0;\n \n@@ -5350,10 +5268,7 @@ start_enum (name)\n    Returns ENUMTYPE.  */\n \n tree\n-finish_enum (enumtype, values, attributes)\n-     tree enumtype;\n-     tree values;\n-     tree attributes;\n+finish_enum (tree enumtype, tree values, tree attributes)\n {\n   tree pair, tem;\n   tree minnode = 0, maxnode = 0, enum_value_type;\n@@ -5478,8 +5393,7 @@ finish_enum (enumtype, values, attributes)\n    Assignment of sequential values by default is handled here.  */\n \n tree\n-build_enumerator (name, value)\n-     tree name, value;\n+build_enumerator (tree name, tree value)\n {\n   tree decl, type;\n \n@@ -5554,8 +5468,7 @@ build_enumerator (name, value)\n    yyparse to report a parse error.  */\n \n int\n-start_function (declspecs, declarator, attributes)\n-     tree declarator, declspecs, attributes;\n+start_function (tree declspecs, tree declarator, tree attributes)\n {\n   tree decl1, old_decl;\n   tree restype;\n@@ -5768,7 +5681,7 @@ start_function (declspecs, declarator, attributes)\n   immediate_size_expand = old_immediate_size_expand;\n \n   start_fname_decls ();\n-  \n+\n   return 1;\n }\n \f\n@@ -5780,7 +5693,7 @@ start_function (declspecs, declarator, attributes)\n    to specify at least the number of arguments.  */\n \n void\n-store_parm_decls ()\n+store_parm_decls (void)\n {\n   tree fndecl = current_function_decl;\n   tree parm;\n@@ -6175,7 +6088,7 @@ store_parm_decls ()\n     {\n       tree t;\n \n-      DECL_LANG_SPECIFIC (fndecl)->pending_sizes \n+      DECL_LANG_SPECIFIC (fndecl)->pending_sizes\n \t= nreverse (get_pending_sizes ());\n       for (t = DECL_LANG_SPECIFIC (fndecl)->pending_sizes;\n \t   t;\n@@ -6206,9 +6119,7 @@ store_parm_decls ()\n    CAN_DEFER_P is nonzero if the function may be deferred.  */\n \n void\n-finish_function (nested, can_defer_p)\n-     int nested;\n-     int can_defer_p;\n+finish_function (int nested, int can_defer_p)\n {\n   tree fndecl = current_function_decl;\n \n@@ -6260,7 +6171,7 @@ finish_function (nested, can_defer_p)\n #endif\n \t}\n     }\n-  \n+\n   finish_fname_decls ();\n \n   /* Tie off the statement tree for this function.  */\n@@ -6336,7 +6247,7 @@ finish_function (nested, can_defer_p)\n \t      current_function_decl = NULL;\n \t      return;\n \t    }\n-\t  \n+\n \t  /* Then, inline any functions called in it.  */\n \t  optimize_inline_calls (fndecl);\n \t  timevar_pop (TV_INTEGRATION);\n@@ -6361,8 +6272,7 @@ finish_function (nested, can_defer_p)\n /* Generate the RTL for a deferred function FNDECL.  */\n \n void\n-c_expand_deferred_function (fndecl)\n-     tree fndecl;\n+c_expand_deferred_function (tree fndecl)\n {\n   /* DECL_INLINE or DECL_RESULT might got cleared after the inline\n      function was deferred, e.g. in duplicate_decls.  */\n@@ -6384,7 +6294,7 @@ c_expand_deferred_function (fndecl)\n    nested FUNCTION_DECL.  */\n \n static tree\n-set_save_expr_context (tree *tp, \n+set_save_expr_context (tree *tp,\n \t\t       int *walk_subtrees,\n \t\t       void *data)\n {\n@@ -6404,9 +6314,7 @@ set_save_expr_context (tree *tp,\n    generation of RTL.  */\n \n static void\n-c_expand_body_1 (fndecl, nested_p)\n-     tree fndecl;\n-     int nested_p;\n+c_expand_body_1 (tree fndecl, int nested_p)\n {\n   timevar_push (TV_EXPAND);\n \n@@ -6445,7 +6353,7 @@ c_expand_body_1 (fndecl, nested_p)\n       && variably_modified_type_p (TREE_TYPE (fndecl)))\n     walk_tree (&TREE_TYPE (fndecl), set_save_expr_context, fndecl,\n \t       NULL);\n-\t     \n+\n   /* If this function is `main', emit a call to `__main'\n      to run global initializers, etc.  */\n   if (DECL_NAME (fndecl)\n@@ -6556,16 +6464,15 @@ c_expand_body_1 (fndecl, nested_p)\n /* Like c_expand_body_1 but only for unnested functions.  */\n \n void\n-c_expand_body (fndecl)\n-     tree fndecl;\n+c_expand_body (tree fndecl)\n {\n   c_expand_body_1 (fndecl, 0);\n }\n \f\n /* Check the declarations given in a for-loop for satisfying the C99\n    constraints.  */\n void\n-check_for_loop_decls ()\n+check_for_loop_decls (void)\n {\n   tree t;\n \n@@ -6596,7 +6503,7 @@ check_for_loop_decls ()\n       if (TREE_PURPOSE (t) != 0)\n         {\n           enum tree_code code = TREE_CODE (TREE_VALUE (t));\n-\t  \n+\n           if (code == RECORD_TYPE)\n             error (\"`struct %s' declared in `for' loop initial declaration\",\n                    IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n@@ -6641,8 +6548,7 @@ struct language_function GTY(())\n    used during compilation of a C function.  */\n \n void\n-c_push_function_context (f)\n-     struct function *f;\n+c_push_function_context (struct function *f)\n {\n   struct language_function *p;\n   p = ((struct language_function *)\n@@ -6664,8 +6570,7 @@ c_push_function_context (f)\n /* Restore the variables used during compilation of a C function.  */\n \n void\n-c_pop_function_context (f)\n-     struct function *f;\n+c_pop_function_context (struct function *f)\n {\n   struct language_function *p = f->language;\n   tree link;\n@@ -6703,8 +6608,7 @@ c_pop_function_context (f)\n /* Copy the DECL_LANG_SPECIFIC data associated with DECL.  */\n \n void\n-c_dup_lang_specific_decl (decl)\n-     tree decl;\n+c_dup_lang_specific_decl (tree decl)\n {\n   struct lang_decl *ld;\n \n@@ -6727,7 +6631,7 @@ c_dup_lang_specific_decl (decl)\n    at the end of the statement.  */\n \n int\n-stmts_are_full_exprs_p ()\n+stmts_are_full_exprs_p (void)\n {\n   return 0;\n }\n@@ -6737,15 +6641,15 @@ stmts_are_full_exprs_p ()\n    returned.  */\n \n stmt_tree\n-current_stmt_tree ()\n+current_stmt_tree (void)\n {\n   return &c_stmt_tree;\n }\n \n /* Returns the stack of SCOPE_STMTs for the current function.  */\n \n tree *\n-current_scope_stmt_stack ()\n+current_scope_stmt_stack (void)\n {\n   return &c_scope_stmt_stack;\n }\n@@ -6754,24 +6658,23 @@ current_scope_stmt_stack ()\n    C.  */\n \n int\n-anon_aggr_type_p (node)\n-     tree node ATTRIBUTE_UNUSED;\n+anon_aggr_type_p (tree node ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n \n /* Dummy function in place of callback used by C++.  */\n \n void\n-extract_interface_info ()\n+extract_interface_info (void)\n {\n }\n \n /* Return a new COMPOUND_STMT, after adding it to the current\n    statement tree.  */\n \n tree\n-c_begin_compound_stmt ()\n+c_begin_compound_stmt (void)\n {\n   tree stmt;\n \n@@ -6785,8 +6688,7 @@ c_begin_compound_stmt ()\n    common code.  */\n \n void\n-c_expand_decl_stmt (t)\n-     tree t;\n+c_expand_decl_stmt (tree t)\n {\n   tree decl = DECL_STMT_DECL (t);\n \n@@ -6800,8 +6702,7 @@ c_expand_decl_stmt (t)\n /* Return the global value of T as a symbol.  */\n \n tree\n-identifier_global_value\t(t)\n-     tree t;\n+identifier_global_value\t(tree t)\n {\n   tree decl = IDENTIFIER_SYMBOL_VALUE (t);\n   if (decl == 0 || DECL_CONTEXT (decl) == 0)\n@@ -6820,10 +6721,7 @@ identifier_global_value\t(t)\n    otherwise the name is found in ridpointers from RID_INDEX.  */\n \n void\n-record_builtin_type (rid_index, name, type)\n-     enum rid rid_index;\n-     const char *name;\n-     tree type;\n+record_builtin_type (enum rid rid_index, const char *name, tree type)\n {\n   tree id;\n   if (name == 0)\n@@ -6835,7 +6733,7 @@ record_builtin_type (rid_index, name, type)\n \n /* Build the void_list_node (void_type_node having been created).  */\n tree\n-build_void_list_node ()\n+build_void_list_node (void)\n {\n   tree t = build_tree_list (NULL_TREE, void_type_node);\n   return t;\n@@ -6851,8 +6749,7 @@ build_void_list_node ()\n    if attributes are present) and whose type is the modifier list.  */\n \n tree\n-make_pointer_declarator (type_quals_attrs, target)\n-     tree type_quals_attrs, target;\n+make_pointer_declarator (tree type_quals_attrs, tree target)\n {\n   tree quals, attrs;\n   tree itarget = target;"}, {"sha": "5403bf88601fe0a2d223f7ff497f9ec228155a1e", "filename": "gcc/c-dump.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-dump.c?ref=35b1a6faebd652c6d95cc709ddf8af02ff0feced", "patch": "@@ -30,29 +30,23 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Dump information common to statements from STMT.  */\n \n void\n-dump_stmt (di, t)\n-     dump_info_p di;\n-     tree t;\n+dump_stmt (dump_info_p di, tree t)\n {\n   dump_int (di, \"line\", STMT_LINENO (t));\n }\n \n /* Dump the next statement after STMT.  */\n \n void\n-dump_next_stmt (di, t)\n-     dump_info_p di;\n-     tree t;\n+dump_next_stmt (dump_info_p di, tree t)\n {\n   dump_child (\"next\", TREE_CHAIN (t));\n }\n \n /* Dump any C-specific tree codes and attributes of common codes.  */\n \n bool\n-c_dump_tree (dump_info, t)\n-     void *dump_info;\n-     tree t;\n+c_dump_tree (void *dump_info, tree t)\n {\n   enum tree_code code;\n   dump_info_p di = (dump_info_p) dump_info;"}, {"sha": "d0138ee58fb07a0f443173a68ec3193749e23e15", "filename": "gcc/c-format.c", "status": "modified", "additions": 38, "deletions": 81, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=35b1a6faebd652c6d95cc709ddf8af02ff0feced", "patch": "@@ -34,8 +34,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Set format warning options according to a -Wformat=n option.  */\n \n void\n-set_Wformat (setting)\n-     int setting;\n+set_Wformat (int setting)\n {\n   warn_format = setting;\n   warn_format_y2k = setting;\n@@ -67,9 +66,8 @@ typedef struct function_format_info\n   unsigned HOST_WIDE_INT first_arg_num;\t/* number of first arg (zero for varargs) */\n } function_format_info;\n \n-static bool decode_format_attr\t\tPARAMS ((tree,\n-\t\t\t\t\t\t function_format_info *, int));\n-static enum format_type decode_format_type\tPARAMS ((const char *));\n+static bool decode_format_attr (tree, function_format_info *, int);\n+static enum format_type decode_format_type (const char *);\n \n static bool check_format_string (tree argument,\n \t\t\t\t unsigned HOST_WIDE_INT format_num,\n@@ -81,12 +79,8 @@ static bool get_constant (tree expr, unsigned HOST_WIDE_INT *value,\n /* Handle a \"format_arg\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n tree\n-handle_format_arg_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args;\n-     int flags;\n-     bool *no_add_attrs;\n+handle_format_arg_attribute (tree *node, tree name ATTRIBUTE_UNUSED,\n+\t\t\t     tree args, int flags, _Bool *no_add_attrs)\n {\n   tree type = *node;\n   tree format_num_expr = TREE_VALUE (args);\n@@ -180,10 +174,7 @@ get_constant(tree expr, unsigned HOST_WIDE_INT *value, int validated_p)\n    successfully decoded, false otherwise.  */\n \n static bool\n-decode_format_attr (args, info, validated_p)\n-     tree args;\n-     function_format_info *info;\n-     int validated_p;\n+decode_format_attr (tree args, function_format_info *info, int validated_p)\n {\n   tree format_type_id = TREE_VALUE (args);\n   tree format_num_expr = TREE_VALUE (TREE_CHAIN (args));\n@@ -893,32 +884,30 @@ typedef struct\n   int *status;\n } format_check_context;\n \n-static void check_format_info\tPARAMS ((int *, function_format_info *, tree));\n-static void check_format_arg\tPARAMS ((void *, tree, unsigned HOST_WIDE_INT));\n-static void check_format_info_main PARAMS ((int *, format_check_results *,\n-\t\t\t\t\t    function_format_info *,\n-\t\t\t\t\t    const char *, int, tree,\n-\t\t\t\t\t    unsigned HOST_WIDE_INT));\n-static void status_warning PARAMS ((int *, const char *, ...))\n+static void check_format_info (int *, function_format_info *, tree);\n+static void check_format_arg (void *, tree, unsigned HOST_WIDE_INT);\n+static void check_format_info_main (int *, format_check_results *,\n+\t\t\t\t    function_format_info *,\n+\t\t\t\t    const char *, int, tree,\n+\t\t\t\t    unsigned HOST_WIDE_INT);\n+static void status_warning (int *, const char *, ...)\n      ATTRIBUTE_PRINTF_2;\n \n-static void init_dollar_format_checking\t\tPARAMS ((int, tree));\n-static int maybe_read_dollar_number\t\tPARAMS ((int *, const char **, int,\n-\t\t\t\t\t\t\t tree, tree *,\n-\t\t\t\t\t\t\t const format_kind_info *));\n-static void finish_dollar_format_checking\tPARAMS ((int *, format_check_results *, int));\n+static void init_dollar_format_checking (int, tree);\n+static int maybe_read_dollar_number (int *, const char **, int,\n+\t\t\t\t     tree, tree *, const format_kind_info *);\n+static void finish_dollar_format_checking (int *, format_check_results *, int);\n \n-static const format_flag_spec *get_flag_spec\tPARAMS ((const format_flag_spec *,\n-\t\t\t\t\t\t\t int, const char *));\n+static const format_flag_spec *get_flag_spec (const format_flag_spec *,\n+\t\t\t\t\t      int, const char *);\n \n-static void check_format_types\tPARAMS ((int *, format_wanted_type *));\n+static void check_format_types (int *, format_wanted_type *);\n \n /* Decode a format type from a string, returning the type, or\n    format_type_error if not valid, in which case the caller should print an\n    error message.  */\n static enum format_type\n-decode_format_type (s)\n-     const char *s;\n+decode_format_type (const char *s)\n {\n   int i;\n   int slen;\n@@ -945,10 +934,7 @@ decode_format_type (s)\n    attribute themselves.  */\n \n void\n-check_function_format (status, attrs, params)\n-     int *status;\n-     tree attrs;\n-     tree params;\n+check_function_format (int *status, tree attrs, tree params)\n {\n   tree a;\n \n@@ -1041,9 +1027,7 @@ static int dollar_format_warned;\n    function; PARAMS is the list of arguments starting at this argument.  */\n \n static void\n-init_dollar_format_checking (first_arg_num, params)\n-     int first_arg_num;\n-     tree params;\n+init_dollar_format_checking (int first_arg_num, tree params)\n {\n   tree oparams = params;\n \n@@ -1098,14 +1082,9 @@ init_dollar_format_checking (first_arg_num, params)\n    a $ format is found, *FORMAT is updated to point just after it.  */\n \n static int\n-maybe_read_dollar_number (status, format, dollar_needed, params, param_ptr,\n-\t\t\t  fki)\n-     int *status;\n-     const char **format;\n-     int dollar_needed;\n-     tree params;\n-     tree *param_ptr;\n-     const format_kind_info *fki;\n+maybe_read_dollar_number (int *status, const char **format,\n+\t\t\t  int dollar_needed, tree params, tree *param_ptr,\n+\t\t\t  const format_kind_info *fki)\n {\n   int argnum;\n   int overflow_flag;\n@@ -1210,10 +1189,7 @@ maybe_read_dollar_number (status, format, dollar_needed, params, param_ptr,\n    pointers.  */\n \n static void\n-finish_dollar_format_checking (status, res, pointer_gap_ok)\n-     int *status;\n-     format_check_results *res;\n-     int pointer_gap_ok;\n+finish_dollar_format_checking (int *status, format_check_results *res, int pointer_gap_ok)\n {\n   int i;\n   bool found_pointer_gap = false;\n@@ -1248,10 +1224,7 @@ finish_dollar_format_checking (status, res, pointer_gap_ok)\n    of these is found, it is returned, otherwise NULL is returned.  */\n \n static const format_flag_spec *\n-get_flag_spec (spec, flag, predicates)\n-     const format_flag_spec *spec;\n-     int flag;\n-     const char *predicates;\n+get_flag_spec (const format_flag_spec *spec, int flag, const char *predicates)\n {\n   int i;\n   for (i = 0; spec[i].flag_char != 0; i++)\n@@ -1279,10 +1252,7 @@ get_flag_spec (spec, flag, predicates)\n    PARAMS is the list of argument values.  */\n \n static void\n-check_format_info (status, info, params)\n-     int *status;\n-     function_format_info *info;\n-     tree params;\n+check_format_info (int *status, function_format_info *info, tree params)\n {\n   format_check_context format_ctx;\n   unsigned HOST_WIDE_INT arg_num;\n@@ -1380,10 +1350,8 @@ check_format_info (status, info, params)\n    format_check_context.  */\n \n static void\n-check_format_arg (ctx, format_tree, arg_num)\n-     void *ctx;\n-     tree format_tree;\n-     unsigned HOST_WIDE_INT arg_num;\n+check_format_arg (void *ctx, tree format_tree,\n+\t\t  unsigned HOST_WIDE_INT arg_num)\n {\n   format_check_context *format_ctx = ctx;\n   format_check_results *res = format_ctx->res;\n@@ -1539,15 +1507,10 @@ check_format_arg (ctx, format_tree, arg_num)\n    argument in the list of arguments.  */\n \n static void\n-check_format_info_main (status, res, info, format_chars, format_length,\n-\t\t\tparams, arg_num)\n-     int *status;\n-     format_check_results *res;\n-     function_format_info *info;\n-     const char *format_chars;\n-     int format_length;\n-     tree params;\n-     unsigned HOST_WIDE_INT arg_num;\n+check_format_info_main (int *status, format_check_results *res,\n+\t\t\tfunction_format_info *info, const char *format_chars,\n+\t\t\tint format_length, tree params,\n+\t\t\tunsigned HOST_WIDE_INT arg_num)\n {\n   const char *orig_format_chars = format_chars;\n   tree first_fillin_param = params;\n@@ -2170,9 +2133,7 @@ check_format_info_main (status, res, info, format_chars, format_length,\n /* Check the argument types from a single format conversion (possibly\n    including width and precision arguments).  */\n static void\n-check_format_types (status, types)\n-     int *status;\n-     format_wanted_type *types;\n+check_format_types (int *status, format_wanted_type *types)\n {\n   for (; types != 0; types = types->next)\n     {\n@@ -2433,12 +2394,8 @@ init_dynamic_asm_fprintf_info (void)\n /* Handle a \"format\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n tree\n-handle_format_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args;\n-     int flags;\n-     bool *no_add_attrs;\n+handle_format_attribute (tree *node, tree name ATTRIBUTE_UNUSED, tree args,\n+\t\t\t int flags, _Bool *no_add_attrs)\n {\n   tree type = *node;\n   function_format_info info;"}, {"sha": "377653021a5c2bf1481b9e529b6ac621ef885aae", "filename": "gcc/c-incpath.c", "status": "modified", "additions": 19, "deletions": 35, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-incpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-incpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.c?ref=35b1a6faebd652c6d95cc709ddf8af02ff0feced", "patch": "@@ -43,13 +43,13 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n # define INO_T_COPY(DEST, SRC) (DEST) = (SRC)\n #endif\n \n-static void add_env_var_paths PARAMS ((const char *, int));\n-static void add_standard_paths PARAMS ((const char *, const char *, int));\n-static void free_path PARAMS ((struct cpp_path *, int));\n-static void merge_include_chains PARAMS ((cpp_reader *, int));\n-static struct cpp_path *\n-  remove_duplicates PARAMS ((cpp_reader *, struct cpp_path *,\n-\t\t\t     struct cpp_path *, struct cpp_path *, int));\n+static void add_env_var_paths (const char *, int);\n+static void add_standard_paths (const char *, const char *, int);\n+static void free_path (struct cpp_path *, int);\n+static void merge_include_chains (cpp_reader *, int);\n+static struct cpp_path *remove_duplicates (cpp_reader *, struct cpp_path *,\n+\t\t\t\t\t   struct cpp_path *,\n+\t\t\t\t\t   struct cpp_path *, int);\n \n /* Include chains heads and tails.  */\n static struct cpp_path *heads[4];\n@@ -59,9 +59,7 @@ enum { REASON_QUIET = 0, REASON_NOENT, REASON_DUP, REASON_DUP_SYS };\n \n /* Free an element of the include chain, possibly giving a reason.  */\n static void\n-free_path (path, reason)\n-     struct cpp_path *path;\n-     int reason;\n+free_path (struct cpp_path *path, int reason)\n {\n   switch (reason)\n     {\n@@ -90,9 +88,7 @@ free_path (path, reason)\n /* Read ENV_VAR for a PATH_SEPARATOR-separated list of file names; and\n    append all the names to the search path CHAIN.  */\n static void\n-add_env_var_paths (env_var, chain)\n-     const char *env_var;\n-     int chain;\n+add_env_var_paths (const char *env_var, int chain)\n {\n   char *p, *q, *path;\n \n@@ -122,9 +118,7 @@ add_env_var_paths (env_var, chain)\n \n /* Append the standard include chain defined in cppdefault.c.  */\n static void\n-add_standard_paths (sysroot, iprefix, cxx_stdinc)\n-     const char *sysroot, *iprefix;\n-     int cxx_stdinc;\n+add_standard_paths (const char *sysroot, const char *iprefix, int cxx_stdinc)\n {\n   const struct default_include *p;\n   size_t len;\n@@ -176,12 +170,9 @@ add_standard_paths (sysroot, iprefix, cxx_stdinc)\n    removed.  Return the head of the resulting chain.  Any of HEAD,\n    JOIN and SYSTEM can be NULL.  */\n static struct cpp_path *\n-remove_duplicates (pfile, head, system, join, verbose)\n-     cpp_reader *pfile;\n-     struct cpp_path *head;\n-     struct cpp_path *system;\n-     struct cpp_path *join;\n-     int verbose;\n+remove_duplicates (cpp_reader *pfile, struct cpp_path *head,\n+\t\t   struct cpp_path *system, struct cpp_path *join,\n+\t\t   int verbose)\n {\n   struct cpp_path **pcur, *tmp, *cur;\n   struct stat st;\n@@ -255,9 +246,7 @@ remove_duplicates (pfile, head, system, join, verbose)\n    to treat -Ibar -Ifoo -I- -Ifoo -Iquux as if written -Ibar -I- -Ifoo\n    -Iquux.  */\n static void\n-merge_include_chains (pfile, verbose)\n-     cpp_reader *pfile;\n-     int verbose;\n+merge_include_chains (cpp_reader *pfile, int verbose)\n {\n   /* Join the SYSTEM and AFTER chains.  Remove duplicates in the\n      resulting SYSTEM chain.  */\n@@ -300,7 +289,7 @@ merge_include_chains (pfile, verbose)\n    (Note that -I. -I- is not the same as the default setup; -I. uses\n    the compiler's working dir.)  */\n void\n-split_quote_chain ()\n+split_quote_chain (void)\n {\n   heads[QUOTE] = heads[BRACKET];\n   tails[QUOTE] = tails[BRACKET];\n@@ -313,10 +302,7 @@ split_quote_chain ()\n /* Add PATH to the include chain CHAIN. PATH must be malloc-ed and\n    NUL-terminated.  */\n void\n-add_path (path, chain, cxx_aware)\n-     char *path;\n-     int chain;\n-     int cxx_aware;\n+add_path (char *path, int chain, int cxx_aware)\n {\n   struct cpp_path *p;\n \n@@ -338,11 +324,9 @@ add_path (path, chain, cxx_aware)\n /* Exported function to handle include chain merging, duplicate\n    removal, and registration with cpplib.  */\n void\n-register_include_chains (pfile, sysroot, iprefix,\n-\t\t\t stdinc, cxx_stdinc, verbose)\n-     cpp_reader *pfile;\n-     const char *sysroot, *iprefix;\n-     int stdinc, cxx_stdinc, verbose;\n+register_include_chains (cpp_reader *pfile, const char *sysroot,\n+\t\t\t const char *iprefix, int stdinc, int cxx_stdinc,\n+\t\t\t int verbose)\n {\n   static const char *const lang_env_vars[] =\n     { \"C_INCLUDE_PATH\", \"CPLUS_INCLUDE_PATH\","}, {"sha": "31ed657da2a5bcb5f600fc6da466c3cf1631c3fa", "filename": "gcc/c-incpath.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-incpath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-incpath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.h?ref=35b1a6faebd652c6d95cc709ddf8af02ff0feced", "patch": "@@ -15,9 +15,9 @@ You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n-extern void split_quote_chain\tPARAMS ((void));\n-extern void add_path\t\tPARAMS ((char *, int, int));\n-extern void register_include_chains PARAMS ((cpp_reader *, const char *,\n-\t\t\t\t\t     const char *, int, int, int));\n+extern void split_quote_chain (void);\n+extern void add_path (char *, int, int);\n+extern void register_include_chains (cpp_reader *, const char *,\n+\t\t\t\t     const char *, int, int, int);\n \n enum { QUOTE = 0, BRACKET, SYSTEM, AFTER };"}, {"sha": "71b34096b77c33a56171f705be25c4ae6aad9438", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b1a6faebd652c6d95cc709ddf8af02ff0feced/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=35b1a6faebd652c6d95cc709ddf8af02ff0feced", "patch": "@@ -49,7 +49,7 @@ typedef struct align_stack GTY(())\n static GTY(()) struct align_stack * alignment_stack;\n \n #ifdef HANDLE_PRAGMA_PACK\n-static void handle_pragma_pack PARAMS ((cpp_reader *));\n+static void handle_pragma_pack (cpp_reader *);\n \n #ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n /* If we have a \"global\" #pragma pack(<n>) in effect when the first\n@@ -61,14 +61,12 @@ static int default_alignment;\n #define SET_GLOBAL_ALIGNMENT(ALIGN) \\\n   (default_alignment = maximum_field_alignment = (ALIGN))\n \n-static void push_alignment PARAMS ((int, tree));\n-static void pop_alignment  PARAMS ((tree));\n+static void push_alignment (int, tree);\n+static void pop_alignment (tree);\n \n /* Push an alignment value onto the stack.  */\n static void\n-push_alignment (alignment, id)\n-     int alignment;\n-     tree id;\n+push_alignment (int alignment, tree id)\n {\n   if (alignment_stack == NULL\n       || alignment_stack->alignment != alignment\n@@ -99,8 +97,7 @@ push_alignment (alignment, id)\n \n /* Undo a push of an alignment onto the stack.  */\n static void\n-pop_alignment (id)\n-     tree id;\n+pop_alignment (tree id)\n {\n   align_stack * entry;\n       \n@@ -157,8 +154,7 @@ pop_alignment (id)\n    #pragma pack (pop)\n    #pragma pack (pop, ID) */\n static void\n-handle_pragma_pack (dummy)\n-     cpp_reader *dummy ATTRIBUTE_UNUSED;\n+handle_pragma_pack (cpp_reader *dummy ATTRIBUTE_UNUSED)\n {\n   tree x, id = 0;\n   int align = -1;\n@@ -261,12 +257,11 @@ handle_pragma_pack (dummy)\n static GTY(()) tree pending_weaks;\n \n #ifdef HANDLE_PRAGMA_WEAK\n-static void apply_pragma_weak PARAMS ((tree, tree));\n-static void handle_pragma_weak PARAMS ((cpp_reader *));\n+static void apply_pragma_weak (tree, tree);\n+static void handle_pragma_weak (cpp_reader *);\n \n static void\n-apply_pragma_weak (decl, value)\n-     tree decl, value;\n+apply_pragma_weak (tree decl, tree value)\n {\n   if (value)\n     {\n@@ -285,8 +280,7 @@ apply_pragma_weak (decl, value)\n }\n \n void\n-maybe_apply_pragma_weak (decl)\n-     tree decl;\n+maybe_apply_pragma_weak (tree decl)\n {\n   tree *p, t, id;\n \n@@ -311,8 +305,7 @@ maybe_apply_pragma_weak (decl)\n \n /* #pragma weak name [= value] */\n static void\n-handle_pragma_weak (dummy)\n-     cpp_reader *dummy ATTRIBUTE_UNUSED;\n+handle_pragma_weak (cpp_reader *dummy ATTRIBUTE_UNUSED)\n {\n   tree name, value, x, decl;\n   enum cpp_ttype t;\n@@ -343,21 +336,19 @@ handle_pragma_weak (dummy)\n }\n #else\n void\n-maybe_apply_pragma_weak (decl)\n-     tree decl ATTRIBUTE_UNUSED;\n+maybe_apply_pragma_weak (tree decl ATTRIBUTE_UNUSED)\n {\n }\n #endif /* HANDLE_PRAGMA_WEAK */\n \n static GTY(()) tree pending_redefine_extname;\n \n #ifdef HANDLE_PRAGMA_REDEFINE_EXTNAME\n-static void handle_pragma_redefine_extname PARAMS ((cpp_reader *));\n+static void handle_pragma_redefine_extname (cpp_reader *);\n \n /* #pragma redefined_extname oldname newname */\n static void\n-handle_pragma_redefine_extname (dummy)\n-     cpp_reader *dummy ATTRIBUTE_UNUSED;\n+handle_pragma_redefine_extname (cpp_reader *dummy ATTRIBUTE_UNUSED)\n {\n   tree oldname, newname, decl, x;\n   enum cpp_ttype t;\n@@ -390,8 +381,7 @@ handle_pragma_redefine_extname (dummy)\n #endif\n \n void\n-add_to_renaming_pragma_list (oldname, newname)\n-\ttree oldname, newname;\n+add_to_renaming_pragma_list (tree oldname, tree newname)\n {\n   pending_redefine_extname\n     = tree_cons (oldname, newname, pending_redefine_extname);\n@@ -400,12 +390,11 @@ add_to_renaming_pragma_list (oldname, newname)\n static GTY(()) tree pragma_extern_prefix;\n \n #ifdef HANDLE_PRAGMA_EXTERN_PREFIX\n-static void handle_pragma_extern_prefix PARAMS ((cpp_reader *));\n+static void handle_pragma_extern_prefix (cpp_reader *);\n \n /* #pragma extern_prefix \"prefix\" */\n static void\n-handle_pragma_extern_prefix (dummy)\n-     cpp_reader *dummy ATTRIBUTE_UNUSED;\n+handle_pragma_extern_prefix (cpp_reader *dummy ATTRIBUTE_UNUSED)\n {\n   tree prefix, x;\n   enum cpp_ttype t;\n@@ -428,8 +417,7 @@ handle_pragma_extern_prefix (dummy)\n    pragmas that rename variables.  */\n \n tree\n-maybe_apply_renaming_pragma (decl, asmname)\n-     tree decl, asmname;\n+maybe_apply_renaming_pragma (tree decl, tree asmname)\n {\n   tree oldname;\n \n@@ -486,17 +474,15 @@ maybe_apply_renaming_pragma (decl, asmname)\n /* Front-end wrapper for pragma registration to avoid dragging\n    cpplib.h in almost everywhere.  */\n void\n-c_register_pragma (space, name, handler)\n-     const char *space;\n-     const char *name;\n-     void (*handler) PARAMS ((struct cpp_reader *));\n+c_register_pragma (const char *space, const char *name,\n+\t\t   void (*handler) (struct cpp_reader *))\n {\n   cpp_register_pragma (parse_in, space, name, handler);\n }\n \n /* Set up front-end pragmas.  */\n void\n-init_pragma ()\n+init_pragma (void)\n {\n #ifdef HANDLE_PRAGMA_PACK\n   c_register_pragma (0, \"pack\", handle_pragma_pack);"}]}