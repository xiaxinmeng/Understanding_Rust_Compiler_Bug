{"sha": "cf00a885103d939b2175adc8918908a3b6f211d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YwMGE4ODUxMDNkOTM5YjIxNzVhZGM4OTE4OTA4YTNiNmYyMTFkMg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-07-08T02:33:00Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-07-08T02:33:00Z"}, "message": "cppexp.c: Update all code for new lexer interface.\n\n\t* cppexp.c: Update all code for new lexer interface.\n\t(op_t, operator codes, struct token, tokentab2, op_to_str): Remove.\n\t(struct suffix, vsuf_1, vsuf_2, vsuf_3, op_to_prio): New.\n\t* cpplex.c (token_names): Trim leading CPP_ from names; make\n\tthe strings unsigned.\n\t(_cpp_spell_operator): New.\n\t(is_macro_disabled): Disable all macros if rescanning\n\tpreprocessed text.\n\t(_cpp_get_directive_token): Remove.\n\n\t* cppinit.c: Don't set no_macro_expand.\n\t* cpplib.c (read_line_number, do_line): Check only for EOF,\n\tnot VSPACE.\n\t* cpphash.h: Update prototypes.\n\t* cpplib.h (CPP_VSPACE): Remove.\n\t(struct cpp_reader): Remove no_macro_expand.\n\ntestsuite:\n\t* gcc.dg/cpp/19951227-1.c, gcc.dg/cpp/assert2.c,\n\tgcc.dg/cpp/if-1.c, gcc.dg/cpp/if-4.c: Tweak error regexps.\n\nFrom-SVN: r34920", "tree": {"sha": "063609848f321cdd31d0d1155b156f5af32e889c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/063609848f321cdd31d0d1155b156f5af32e889c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf00a885103d939b2175adc8918908a3b6f211d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf00a885103d939b2175adc8918908a3b6f211d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf00a885103d939b2175adc8918908a3b6f211d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf00a885103d939b2175adc8918908a3b6f211d2/comments", "author": null, "committer": null, "parents": [{"sha": "563dd08adfa12573fdecf9669fdf685fef5fd360", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/563dd08adfa12573fdecf9669fdf685fef5fd360", "html_url": "https://github.com/Rust-GCC/gccrs/commit/563dd08adfa12573fdecf9669fdf685fef5fd360"}], "stats": {"total": 899, "additions": 398, "deletions": 501}, "files": [{"sha": "e8b67e049a97eeef5be111874b7a4d36c8e4ab1c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf00a885103d939b2175adc8918908a3b6f211d2", "patch": "@@ -1,3 +1,22 @@\n+2000-07-07  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppexp.c: Update all code for new lexer interface.\n+\t(op_t, operator codes, struct token, tokentab2, op_to_str): Remove.\n+\t(struct suffix, vsuf_1, vsuf_2, vsuf_3, op_to_prio): New.\n+\t* cpplex.c (token_names): Trim leading CPP_ from names; make\n+\tthe strings unsigned.\n+\t(_cpp_spell_operator): New.\n+\t(is_macro_disabled): Disable all macros if rescanning\n+\tpreprocessed text.\n+\t(_cpp_get_directive_token): Remove.\n+\n+\t* cppinit.c: Don't set no_macro_expand.\n+\t* cpplib.c (read_line_number, do_line): Check only for EOF,\n+\tnot VSPACE.\n+\t* cpphash.h: Update prototypes.\n+\t* cpplib.h (CPP_VSPACE): Remove.\n+\t(struct cpp_reader): Remove no_macro_expand.\n+\n 2000-07-08  Neil Booth  <NeilB@earthling.net>\n \n \t* cpphash.c (is__va_args__): New function."}, {"sha": "8a86c8bfe5b31f50f280743f31e2ba582215a169", "filename": "gcc/cppexp.c", "status": "modified", "additions": 327, "deletions": 446, "changes": 773, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=cf00a885103d939b2175adc8918908a3b6f211d2", "patch": "@@ -68,49 +68,34 @@ Boston, MA 02111-1307, USA.  */\n    number with SUM's sign, where A, B, and SUM are all C integers.  */\n #define possible_sum_sign(a, b, sum) ((((a) ^ (b)) | ~ ((a) ^ (sum))) < 0)\n \n-typedef int op_t;\n-\n static void integer_overflow PARAMS ((cpp_reader *));\n static HOST_WIDEST_INT left_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT,\n \t\t\t\t\t   unsigned int,\n \t\t\t\t\t   unsigned HOST_WIDEST_INT));\n static HOST_WIDEST_INT right_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT,\n \t\t\t\t\t    unsigned int,\n \t\t\t\t\t    unsigned HOST_WIDEST_INT));\n-static struct operation parse_number PARAMS ((cpp_reader *, U_CHAR *,\n-\t\t\t\t\t      U_CHAR *));\n-static struct operation parse_charconst PARAMS ((cpp_reader *, U_CHAR *,\n-\t\t\t\t\t\t U_CHAR *));\n-static struct operation parse_defined PARAMS ((cpp_reader *));\n-static struct operation parse_assertion PARAMS ((cpp_reader *));\n-static HOST_WIDEST_INT parse_escape PARAMS ((cpp_reader *, U_CHAR **,\n-\t\t\t\t\t     HOST_WIDEST_INT));\n-static struct operation lex PARAMS ((cpp_reader *, int));\n-static const char * op_to_str PARAMS ((op_t, char *));\n-\n-#define ERROR 299\n-#define OROR 300\n-#define ANDAND 301\n-#define EQUAL 302\n-#define NOTEQUAL 303\n-#define LEQ 304\n-#define GEQ 305\n-#define LSH 306\n-#define RSH 307\n-#define NAME 308\n-#define INT 309\n-#define CHAR 310\n-#define FINISHED 311\n-\n-struct operation\n+static struct op parse_number PARAMS ((cpp_reader *, const cpp_token *));\n+static struct op parse_charconst PARAMS ((cpp_reader *, const cpp_token *));\n+static struct op parse_defined PARAMS ((cpp_reader *));\n+static struct op parse_assertion PARAMS ((cpp_reader *));\n+static HOST_WIDEST_INT parse_escape PARAMS ((cpp_reader *, const U_CHAR **,\n+\t\t\t\t\t     const U_CHAR *, HOST_WIDEST_INT));\n+static struct op lex PARAMS ((cpp_reader *, int));\n+\n+struct op\n {\n-  op_t op;\n+  enum cpp_ttype op;\n   U_CHAR prio;         /* Priority of op.  */\n   U_CHAR flags;\n   U_CHAR unsignedp;    /* True if value should be treated as unsigned.  */\n   HOST_WIDEST_INT value; /* The value logically \"right\" of op.  */\n };\n \n+/* There is no \"error\" token, but we can't get comments in #if, so we can\n+   abuse that token type.  */\n+#define CPP_ERROR CPP_COMMENT\n+\n /* With -O2, gcc appears to produce nice code, moving the error\n    message load and subsequent jump completely out of the main path.  */\n #define CPP_ICE(msgid) \\\n@@ -122,21 +107,45 @@ struct operation\n \n /* Parse and convert an integer for #if.  Accepts decimal, hex, or octal\n    with or without size suffixes.  */\n+struct suffix\n+{\n+  unsigned char s[4];\n+  unsigned char u;\n+  unsigned char l;\n+};\n+\n+const struct suffix vsuf_1[] = {\n+  { \"u\", 1, 0 }, { \"U\", 1, 0 },\n+  { \"l\", 0, 1 }, { \"L\", 0, 1 }\n+};\n+\n+const struct suffix vsuf_2[] = {\n+  { \"ul\", 1, 1 }, { \"UL\", 1, 1 }, { \"uL\", 1, 1 }, { \"Ul\", 1, 1 },\n+  { \"lu\", 1, 1 }, { \"LU\", 1, 1 }, { \"Lu\", 1, 1 }, { \"lU\", 1, 1 },\n+  { \"ll\", 0, 2 }, { \"LL\", 0, 2 }\n+};\n \n-static struct operation\n-parse_number (pfile, start, end)\n+const struct suffix vsuf_3[] = {\n+  { \"ull\", 1, 2 }, { \"ULL\", 1, 2 }, { \"uLL\", 1, 2 }, { \"Ull\", 1, 2 },\n+  { \"llu\", 1, 2 }, { \"LLU\", 1, 2 }, { \"LLu\", 1, 2 }, { \"llU\", 1, 2 }\n+};\n+#define Nsuff(tab) (sizeof tab / sizeof (struct suffix))\n+\n+static struct op\n+parse_number (pfile, tok)\n      cpp_reader *pfile;\n-     U_CHAR *start;\n-     U_CHAR *end;\n+     const cpp_token *tok;\n {\n-  struct operation op;\n-  U_CHAR *p = start;\n-  int c;\n+  struct op op;\n+  const U_CHAR *start = tok->val.name.text;\n+  const U_CHAR *end = start + tok->val.name.len;\n+  const U_CHAR *p = start;\n+  int c, i, nsuff;\n   unsigned HOST_WIDEST_INT n = 0, nd, MAX_over_base;\n   int base = 10;\n   int overflow = 0;\n   int digit, largest_digit = 0;\n-  int spec_long = 0;\n+  const struct suffix *sufftab;\n \n   op.unsignedp = 0;\n \n@@ -158,75 +167,63 @@ parse_number (pfile, start, end)\n   MAX_over_base = (((unsigned HOST_WIDEST_INT) -1)\n \t\t   / ((unsigned HOST_WIDEST_INT) base));\n \n-  while (p < end)\n+  for(; p < end; p++)\n     {\n-      c = *p++;\n+      c = *p;\n \n       if (c >= '0' && c <= '9')\n \tdigit = c - '0';\n-      /* FIXME: assumes ASCII */\n+      /* We believe that in all live character sets, a-f are\n+\t consecutive, and so are A-F.  */\n       else if (base == 16 && c >= 'a' && c <= 'f')\n \tdigit = c - 'a' + 10;\n       else if (base == 16 && c >= 'A' && c <= 'F')\n \tdigit = c - 'A' + 10;\n-      else if (c == '.')\n-\t{\n-\t  /* It's a float since it contains a point.  */\n-\t  cpp_error (pfile,\n-\t     \"floating point numbers are not allowed in #if expressions\");\n-\t  goto error;\n-\t}\n       else\n-\t{\n-\t  /* `l' means long, and `u' means unsigned.  */\n-\t  for (;;)\n-\t    {\n-\t      if (c == 'l' || c == 'L')\n-\t\t  spec_long++;\n-\t      else if (c == 'u' || c == 'U')\n-\t\t  op.unsignedp++;\n-\t      else\n-\t\t{\n-\t\t  /* Decrement p here so that the error for an invalid\n-\t\t     number will be generated below in the case where\n-\t\t     this is the last character in the buffer.  */\n-\t\t  p--;\n-\t\t  break;\n-\t\t}\n-\t      if (p == end)\n-\t\tbreak;\n-\t      c = *p++;\n-\t    }\n-\t  /* Don't look for any more digits after the suffixes.  */\n-\t  break;\n-\t}\n-      \n+\tbreak;\n+\n       if (largest_digit < digit)\n \tlargest_digit = digit;\n       nd = n * base + digit;\n       overflow |= MAX_over_base < n || nd < n;\n       n = nd;\n     }\n \n-  if (p != end)\n-    {\n-      cpp_error (pfile, \"invalid number in #if expression\");\n-      goto error;\n-    }\n-  else if (spec_long > (CPP_OPTION (pfile, c89) ? 1 : 2))\n+  if (p < end)\n     {\n-      cpp_error (pfile, \"too many 'l' suffixes in integer constant\");\n-      goto error;\n-    }\n-  else if (op.unsignedp > 1)\n-    {\n-      cpp_error (pfile, \"too many 'u' suffixes in integer constant\");\n-      goto error;\n+      /* Check for a floating point constant.  Note that float constants\n+\t with an exponent or suffix but no decimal point are technically\n+\t illegal (C99 6.4.4.2) but accepted elsewhere.  */\n+      if ((c == '.' || c == 'F' || c == 'f')\n+\t  || (base == 10 && (c == 'E' || c == 'e')\n+\t      && p+1 < end && (p[1] == '+' || p[1] == '-'))\n+\t  || (base == 16 && (c == 'P' || c == 'p')\n+\t      && p+1 < end && (p[1] == '+' || p[1] == '-')))\n+\tSYNTAX_ERROR (\"floating point numbers are not valid in #if\");\n+  \n+      /* Determine the suffix. l means long, and u means unsigned.\n+\t See the suffix tables, above.  */\n+      switch (end - p)\n+\t{\n+\tcase 1: sufftab = vsuf_1; nsuff = Nsuff(vsuf_1); break;\n+\tcase 2: sufftab = vsuf_2; nsuff = Nsuff(vsuf_2); break;\n+\tcase 3: sufftab = vsuf_3; nsuff = Nsuff(vsuf_3); break;\n+\tdefault: goto invalid_suffix;\n+\t}\n+\n+      for (i = 0; i < nsuff; i++)\n+\tif (memcmp (p, sufftab[i].s, end - p) == 0)\n+\t  break;\n+      if (i == nsuff)\n+\tgoto invalid_suffix;\n+      op.unsignedp = sufftab[i].u;\n+\n+      if (CPP_OPTION (pfile, c89) && sufftab[i].l == 2)\n+\tSYNTAX_ERROR (\"too many 'l' suffixes in integer constant\");\n     }\n   \n   if (base <= largest_digit)\n-    cpp_pedwarn (pfile,\n-\t\t \"integer constant contains digits beyond the radix\");\n+    cpp_pedwarn (pfile, \"integer constant contains digits beyond the radix\");\n \n   if (overflow)\n     cpp_pedwarn (pfile, \"integer constant out of range\");\n@@ -235,55 +232,52 @@ parse_number (pfile, start, end)\n   else if ((HOST_WIDEST_INT) n < 0 && ! op.unsignedp)\n     {\n       if (base == 10)\n-\tcpp_warning (pfile,\n-\t\t     \"integer constant is so large that it is unsigned\");\n+\tcpp_warning (pfile, \"integer constant is so large that it is unsigned\");\n       op.unsignedp = 1;\n     }\n \n   op.value = n;\n-  op.op = INT;\n+  op.op = CPP_INT;\n   return op;\n \n- error:\n-  op.op = ERROR;\n+ invalid_suffix:\n+  cpp_error (pfile, \"invalid suffix '%.*s' on integer constant\",\n+\t     (int) (end - p), p);\n+ syntax_error:\n+  op.op = CPP_ERROR;\n   return op;\n }\n \n /* Parse and convert a character constant for #if.  Understands backslash\n    escapes (\\n, \\031) and multibyte characters (if so configured).  */\n-static struct operation\n-parse_charconst (pfile, start, end)\n+static struct op\n+parse_charconst (pfile, tok)\n      cpp_reader *pfile;\n-     U_CHAR *start;\n-     U_CHAR *end;\n+     const cpp_token *tok;\n {\n-  struct operation op;\n+  struct op op;\n   HOST_WIDEST_INT result = 0;\n   int num_chars = 0;\n   int num_bits;\n   unsigned int width = MAX_CHAR_TYPE_SIZE, mask = MAX_CHAR_TYPE_MASK;\n   int max_chars;\n-  U_CHAR *ptr = start;\n+  const U_CHAR *ptr = tok->val.name.text;\n+  const U_CHAR *end = ptr + tok->val.name.len;\n \n   int c = -1;\n \n-  if (*ptr == 'L')\n-    {\n-      ++ptr;\n-      width = MAX_WCHAR_TYPE_SIZE, mask = MAX_WCHAR_TYPE_MASK;\n-    }\n+  if (tok->type == CPP_WCHAR)\n+    width = MAX_WCHAR_TYPE_SIZE, mask = MAX_WCHAR_TYPE_MASK;\n   max_chars = MAX_LONG_TYPE_SIZE / width;\n \n-  ++ptr;  /* skip initial quote */\n-\n   while (ptr < end)\n     {\n       c = *ptr++;\n       if (c == '\\'')\n-\tbreak;\n+\tCPP_ICE (\"unescaped ' in character constant\");\n       else if (c == '\\\\')\n \t{\n-\t  c = parse_escape (pfile, &ptr, mask);\n+\t  c = parse_escape (pfile, &ptr, end, mask);\n \t  if (width < HOST_BITS_PER_INT\n \t      && (unsigned int) c >= (unsigned int)(1 << width))\n \t    cpp_pedwarn (pfile,\n@@ -301,22 +295,9 @@ parse_charconst (pfile, start, end)\n     }\n \n   if (num_chars == 0)\n-    {\n-      cpp_error (pfile, \"empty character constant\");\n-      goto error;\n-    }\n-  else if (c != '\\'')\n-    {\n-      /* cpp_get_token has already emitted an error if !traditional. */\n-      if (! CPP_TRADITIONAL (pfile))\n-\tcpp_error (pfile, \"malformatted character constant\");\n-      goto error;\n-    }\n+    SYNTAX_ERROR (\"empty character constant\");\n   else if (num_chars > max_chars)\n-    {\n-      cpp_error (pfile, \"character constant too long\");\n-      goto error;\n-    }\n+    SYNTAX_ERROR (\"character constant too long\");\n   else if (num_chars != 1 && ! CPP_TRADITIONAL (pfile))\n     cpp_warning (pfile, \"multi-character character constant\");\n \n@@ -334,75 +315,61 @@ parse_charconst (pfile, start, end)\n \n   /* This is always a signed type.  */\n   op.unsignedp = 0;\n-  op.op = CHAR;\n+  op.op = CPP_INT;\n   return op;\n \n- error:\n-  op.op = ERROR;\n+ syntax_error:\n+  op.op = CPP_ERROR;\n   return op;\n }\n \n-static struct operation\n+static struct op\n parse_defined (pfile)\n      cpp_reader *pfile;\n {\n-  int paren = 0, len;\n-  U_CHAR *tok;\n-  enum cpp_ttype token;\n-  struct operation op;\n-  long old_written = CPP_WRITTEN (pfile);\n+  int paren;\n+  const cpp_token *tok;\n+  struct op op;\n \n-  op.unsignedp = 0;\n-  op.op = INT;\n-\n-  pfile->no_macro_expand++;\n-  token = _cpp_get_directive_token (pfile);\n-  if (token == CPP_OPEN_PAREN)\n+  paren = 0;\n+  tok = _cpp_get_raw_token (pfile);\n+  if (tok->type == CPP_OPEN_PAREN)\n     {\n-      paren++;\n-      CPP_SET_WRITTEN (pfile, old_written);\n-      token = _cpp_get_directive_token (pfile);\n+      paren = 1;\n+      tok = _cpp_get_raw_token (pfile);\n     }\n \n-  if (token != CPP_NAME)\n-    goto oops;\n+  if (tok->type != CPP_NAME)\n+    SYNTAX_ERROR (\"\\\"defined\\\" without an identifier\");\n \n-  tok = pfile->token_buffer + old_written;\n-  len = CPP_PWRITTEN (pfile) - tok;\n-  op.value = cpp_defined (pfile, tok, len);\n+  if (paren && _cpp_get_raw_token (pfile)->type != CPP_CLOSE_PAREN)\n+    SYNTAX_ERROR (\"missing close paren after \\\"defined\\\"\");\n \n-  if (paren)\n-    {\n-      if (_cpp_get_directive_token (pfile) != CPP_CLOSE_PAREN)\n-\tgoto oops;\n-    }\n-  CPP_SET_WRITTEN (pfile, old_written);\n-  pfile->no_macro_expand--;\n+  op.unsignedp = 0;\n+  op.op = CPP_INT;\n+  op.value = cpp_defined (pfile, tok->val.name.text, tok->val.name.len);\n   return op;\n \n- oops:\n-  CPP_SET_WRITTEN (pfile, old_written);\n-  pfile->no_macro_expand--;\n-  cpp_error (pfile, \"'defined' without an identifier\");\n-\n-  op.op = ERROR;\n+ syntax_error:\n+  op.op = CPP_ERROR;\n   return op;\n }\n \n-static struct operation\n+static struct op\n parse_assertion (pfile)\n      cpp_reader *pfile;\n {\n-  struct operation op;\n+  struct op op;\n   struct answer *answer;\n   cpp_hashnode *hp;\n \n-  op.op = ERROR;\n+  op.op = CPP_ERROR;\n   hp = _cpp_parse_assertion (pfile, &answer);\n   if (hp)\n     {\n       /* If we get here, the syntax is valid.  */\n-      op.op = INT;\n+      op.op = CPP_INT;\n+      op.unsignedp = 0;\n       op.value = (hp->type == T_ASSERTION &&\n \t\t  (answer == 0 || *_cpp_find_answer (hp, &answer->list) != 0));\n \n@@ -412,229 +379,155 @@ parse_assertion (pfile)\n   return op;\n }\n \n-struct token\n-{\n-  const char *operator;\n-  op_t token;\n-};\n-\n-static const struct token tokentab2[] =\n-{\n-  {\"&&\", ANDAND},\n-  {\"||\", OROR},\n-  {\"<<\", LSH},\n-  {\">>\", RSH},\n-  {\"==\", EQUAL},\n-  {\"!=\", NOTEQUAL},\n-  {\"<=\", LEQ},\n-  {\">=\", GEQ},\n-  {NULL, ERROR}\n-};\n-\n /* Read one token.  */\n \n-static struct operation\n+static struct op\n lex (pfile, skip_evaluation)\n      cpp_reader *pfile;\n      int skip_evaluation;\n {\n-  const struct token *toktab;\n-  enum cpp_ttype token;\n-  struct operation op;\n-  U_CHAR *tok_start, *tok_end;\n-  long old_written = CPP_WRITTEN (pfile);\n+  struct op op;\n+  const cpp_token *tok;\n \n  retry:\n-  token = _cpp_get_directive_token (pfile);\n-  tok_start = pfile->token_buffer + old_written;\n-  tok_end = CPP_PWRITTEN (pfile);\n-  CPP_SET_WRITTEN (pfile, old_written);\n+  tok = cpp_get_token (pfile);\n \n-  switch (token)\n+  switch (tok->type)\n     {\n     case CPP_PLACEMARKER:\n-      CPP_SET_WRITTEN (pfile, old_written);\n+      /* XXX These shouldn't be visible outside cpplex.c.  */\n       goto retry;\n \n-    case CPP_EOF: /* Should not happen ...  */\n-    case CPP_VSPACE:\n-      op.op = 0;\n-      return op;\n+    case CPP_INT:\n     case CPP_NUMBER:\n-      return parse_number (pfile, tok_start, tok_end);\n+      return parse_number (pfile, tok);\n+    case CPP_CHAR:\n+    case CPP_WCHAR:\n+      return parse_charconst (pfile, tok);\n+\n     case CPP_STRING:\n     case CPP_WSTRING:\n-      cpp_error (pfile,\n-\t\t \"string constants are not allowed in #if expressions\");\n-      op.op = ERROR;\n-      return op;\n+      SYNTAX_ERROR (\"string constants are not valid in #if\");\n \n-    case CPP_CHAR:\n-    case CPP_WCHAR:\n-      return parse_charconst (pfile, tok_start, tok_end);\n+    case CPP_FLOAT:\n+      SYNTAX_ERROR (\"floating point numbers are not valid in #if\");\n+\n+    case CPP_OTHER:\n+      if (ISGRAPH (tok->val.aux))\n+\tSYNTAX_ERROR2 (\"invalid character '%c' in #if\", tok->val.aux);\n+      else\n+\tSYNTAX_ERROR2 (\"invalid character '\\\\%03o' in #if\", tok->val.aux);\n \n     case CPP_NAME:\n-      /* FIXME:  could this not overflow the tok_start buffer? */\n-      if (!ustrncmp (tok_start, U\"defined\", 7))\n+      if (!cpp_idcmp (tok->val.name.text, tok->val.name.len, \"defined\"))\n \treturn parse_defined (pfile);\n \n-      op.op = INT;\n+      op.op = CPP_INT;\n       op.unsignedp = 0;\n       op.value = 0;\n \n       if (CPP_OPTION (pfile, warn_undef) && !skip_evaluation)\n-\tcpp_warning (pfile, \"'%.*s' is not defined\",\n-\t\t     (int) (tok_end - tok_start), tok_start);\n+\tcpp_warning (pfile, \"\\\"%.*s\\\" is not defined\",\n+\t\t     (int) tok->val.name.len, tok->val.name.text);\n       return op;\n \n     case CPP_HASH:\n       return parse_assertion (pfile);\n \n-    case CPP_AND_AND:\top.op = ANDAND; return op;\n-    case CPP_OR_OR:\top.op = OROR;\treturn op;\n-    case CPP_LSHIFT:\top.op = LSH;\treturn op;\n-    case CPP_RSHIFT:\top.op = RSH;\treturn op;\n-    case CPP_EQ_EQ:\top.op = EQUAL;\treturn op;\n-    case CPP_NOT_EQ:\top.op = NOTEQUAL; return op;\n-    case CPP_LESS_EQ:\top.op = LEQ;\treturn op;\n-    case CPP_GREATER_EQ:op.op = GEQ;\treturn op;\n-\n     default:\n-      /* See if it is a special token of length 2.  */\n-      if (tok_start + 2 == tok_end)\n-        {\n-\t  for (toktab = tokentab2; toktab->operator != NULL; toktab++)\n-\t    if (tok_start[0] == toktab->operator[0]\n-\t\t&& tok_start[1] == toktab->operator[1])\n-\t\tbreak;\n-\t  if (toktab->token == ERROR)\n-\t    cpp_error (pfile, \"'%.*s' is not allowed in #if expressions\",\n-\t\t       (int) (tok_end - tok_start), tok_start);\n-\t  op.op = toktab->token; \n+      if ((tok->type > CPP_EQ && tok->type < CPP_PLUS_EQ)\n+\t  || tok->type == CPP_EOF)\n+\t{\n+\t  op.op = tok->type;\n \t  return op;\n \t}\n-      op.op = *tok_start;\n-      return op;\n-  }\n-}\n \n-/* Convert an operator ID to a string.  BUFF is a buffer at least 5\n-   characters long which might be used to store the string.  */\n-/* XXX FIXME: Remove BUFF when new lexer is implemented.  */\n-static const char *\n-op_to_str (op, buff)\n-     op_t op;\n-     char *buff;\n-{\n-  const struct token *toktab;\n-\n-  /* See if it is a special token of length 2.  */\n-  for (toktab = tokentab2; toktab->operator != NULL; toktab++)\n-    if (op == toktab->token)\n-      return toktab->operator;\n+      SYNTAX_ERROR2(\"'%s' is not valid in #if expressions\",\n+\t\t    _cpp_spell_operator (tok->type));\n+  }\n \n-  if (ISGRAPH (op))\n-    sprintf (buff, \"%c\", (int) op);\n-  else\n-    sprintf (buff, \"\\\\%03o\", (int) op);\n-  return buff;\n+ syntax_error:\n+  op.op = CPP_ERROR;\n+  return op;\n }\n \n /* Parse a C escape sequence.  STRING_PTR points to a variable\n    containing a pointer to the string to parse.  That pointer\n    is updated past the characters we use.  The value of the\n    escape sequence is returned.\n \n-   A negative value means the sequence \\ newline was seen,\n-   which is supposed to be equivalent to nothing at all.\n-\n-   If \\ is followed by a null character, we return a negative\n-   value and leave the string pointer pointing at the null character.\n-\n    If \\ is followed by 000, we return 0 and leave the string pointer\n    after the zeros.  A value of 0 does not mean end of string.  */\n \n static HOST_WIDEST_INT\n-parse_escape (pfile, string_ptr, result_mask)\n+parse_escape (pfile, string_ptr, limit, result_mask)\n      cpp_reader *pfile;\n-     U_CHAR **string_ptr;\n+     const U_CHAR **string_ptr;\n+     const U_CHAR *limit;\n      HOST_WIDEST_INT result_mask;\n {\n-  register int c = *(*string_ptr)++;\n+  const U_CHAR *ptr = *string_ptr;\n+  /* We know we have at least one following character.  */\n+  int c = *ptr++;\n   switch (c)\n     {\n-    case 'a':\n-      return TARGET_BELL;\n-    case 'b':\n-      return TARGET_BS;\n-    case 'e':\n-    case 'E':\n+    case 'a': c = TARGET_BELL;\t  break;\n+    case 'b': c = TARGET_BS;\t  break;\n+    case 'f': c = TARGET_FF;\t  break;\n+    case 'n': c = TARGET_NEWLINE; break;\n+    case 'r': c = TARGET_CR;\t  break;\n+    case 't': c = TARGET_TAB;\t  break;\n+    case 'v': c = TARGET_VT;\t  break;\n+\n+    case 'e': case 'E':\n       if (CPP_PEDANTIC (pfile))\n \tcpp_pedwarn (pfile, \"non-ISO-standard escape sequence, '\\\\%c'\", c);\n-      return TARGET_ESC;\n-    case 'f':\n-      return TARGET_FF;\n-    case 'n':\n-      return TARGET_NEWLINE;\n-    case 'r':\n-      return TARGET_CR;\n-    case 't':\n-      return TARGET_TAB;\n-    case 'v':\n-      return TARGET_VT;\n-    case '\\n':\n-      return -2;\n-    case 0:\n-      (*string_ptr)--;\n-      return 0;\n+      c = TARGET_ESC;\n+      break;\n       \n-    case '0':\n-    case '1':\n-    case '2':\n-    case '3':\n-    case '4':\n-    case '5':\n-    case '6':\n-    case '7':\n+    case '0': case '1': case '2': case '3':\n+    case '4': case '5': case '6': case '7':\n       {\n-\tregister HOST_WIDEST_INT i = c - '0';\n-\tregister int count = 0;\n+\tunsigned int i = c - '0';\n+\tint count = 0;\n \twhile (++count < 3)\n \t  {\n-\t    c = *(*string_ptr)++;\n-\t    if (c >= '0' && c <= '7')\n-\t      i = (i << 3) + c - '0';\n-\t    else\n-\t      {\n-\t\t(*string_ptr)--;\n-\t\tbreak;\n-\t      }\n+\t    if (ptr >= limit)\n+\t      break;\n+\t    \n+\t    c = *ptr;\n+\t    if (c < '0' || c > '7')\n+\t      break;\n+\t    ptr++;\n+\t    i = (i << 3) + c - '0';\n \t  }\n \tif (i != (i & result_mask))\n \t  {\n \t    i &= result_mask;\n \t    cpp_pedwarn (pfile, \"octal escape sequence out of range\");\n \t  }\n-\treturn i;\n+\tc = i;\n+\tbreak;\n       }\n+\n     case 'x':\n       {\n-\tregister unsigned HOST_WIDEST_INT i = 0, overflow = 0;\n-\tregister int digits_found = 0, digit;\n+\tunsigned int i = 0, overflow = 0;\n+\tint digits_found = 0, digit;\n \tfor (;;)\n \t  {\n-\t    c = *(*string_ptr)++;\n+\t    if (ptr >= limit)\n+\t      break;\n+\t    c = *ptr;\n \t    if (c >= '0' && c <= '9')\n \t      digit = c - '0';\n \t    else if (c >= 'a' && c <= 'f')\n \t      digit = c - 'a' + 10;\n \t    else if (c >= 'A' && c <= 'F')\n \t      digit = c - 'A' + 10;\n \t    else\n-\t      {\n-\t\t(*string_ptr)--;\n-\t\tbreak;\n-\t      }\n+\t      break;\n+\t    ptr++;\n \t    overflow |= i ^ (i << 4 >> 4);\n \t    i = (i << 4) + digit;\n \t    digits_found = 1;\n@@ -646,11 +539,12 @@ parse_escape (pfile, string_ptr, result_mask)\n \t    i &= result_mask;\n \t    cpp_pedwarn (pfile, \"hex escape sequence out of range\");\n \t  }\n-\treturn i;\n+\tc = i;\n+\tbreak;\n       }\n-    default:\n-      return c;\n     }\n+  *string_ptr = ptr;\n+  return c;\n }\n \n static void\n@@ -762,6 +656,40 @@ be handled with operator-specific code.  */\n #define MUL_PRIO           (15 << PRIO_SHIFT)\n #define UNARY_PRIO        ((16 << PRIO_SHIFT) | RIGHT_ASSOC | NO_L_OPERAND)\n \n+/* Operator to priority map.  Must be in the same order as the first\n+   N entries of enum cpp_ttype.  */\n+static const short\n+op_to_prio[] =\n+{\n+  /* EQ */\t\t0,\t\t/* dummy entry - can't happen */\n+  /* NOT */\t\tUNARY_PRIO,\n+  /* GREATER */\t\tLESS_PRIO,\n+  /* LESS */\t\tLESS_PRIO,\n+  /* PLUS */\t\tUNARY_PRIO,\t/* note these two can be unary */\n+  /* MINUS */\t\tUNARY_PRIO,\t/* or binary */\n+  /* MULT */\t\tMUL_PRIO,\n+  /* DIV */\t\tMUL_PRIO,\n+  /* MOD */\t\tMUL_PRIO,\n+  /* AND */\t\tAND_PRIO,\n+  /* OR */\t\tOR_PRIO,\n+  /* XOR */\t\tXOR_PRIO,\n+  /* RSHIFT */\t\tSHIFT_PRIO,\n+  /* LSHIFT */\t\tSHIFT_PRIO,\n+\n+  /* COMPL */\t\tUNARY_PRIO,\n+  /* AND_AND */\t\tANDAND_PRIO,\n+  /* OR_OR */\t\tOROR_PRIO,\n+  /* QUERY */\t\tCOND_PRIO,\n+  /* COLON */\t\tCOLON_PRIO,\n+  /* COMMA */\t\tCOMMA_PRIO,\n+  /* OPEN_PAREN */\tOPEN_PAREN_PRIO,\n+  /* CLOSE_PAREN */\tCLOSE_PAREN_PRIO,\n+  /* EQ_EQ */\t\tEQUAL_PRIO,\n+  /* NOT_EQ */\t\tEQUAL_PRIO,\n+  /* GREATER_EQ */\tLESS_PRIO,\n+  /* LESS_EQ */\t\tLESS_PRIO\n+};\n+\n #define COMPARE(OP) \\\n   top->unsignedp = 0; \\\n   top->value = (unsigned1 | unsigned2) \\\n@@ -770,9 +698,25 @@ be handled with operator-specific code.  */\n #define EQUALITY(OP) \\\n   top->value = v1 OP v2; \\\n   top->unsignedp = 0;\n-#define LOGICAL(OP) \\\n+#define BITWISE(OP) \\\n   top->value = v1 OP v2; \\\n   top->unsignedp = unsigned1 | unsigned2;\n+#define UNARY(OP) \\\n+  top->value = OP v2; \\\n+  top->unsignedp = unsigned2; \\\n+  top->flags |= HAVE_VALUE;\n+#define LOGICAL(OP, NEG) \\\n+  top->value = v1 OP v2; \\\n+  top->unsignedp = 0; \\\n+  if (NEG v1) skip_evaluation--;\n+#define SHIFT(PSH, MSH) \\\n+  if (skip_evaluation)  \\\n+    break;\t\t\\\n+  top->unsignedp = unsigned1; \\\n+  if (v2 < 0 && ! unsigned2)  \\\n+    top->value = MSH (pfile, v1, unsigned1, -v2); \\\n+  else \\\n+    top->value = PSH (pfile, v1, unsigned1, v2);\n \n /* Parse and evaluate a C expression, reading from PFILE.\n    Returns the truth value of the expression.  */\n@@ -792,21 +736,19 @@ _cpp_parse_expr (pfile)\n      In that case the 'flags' field has the HAVE_VALUE flag set.  */\n \n #define INIT_STACK_SIZE 20\n-  struct operation init_stack[INIT_STACK_SIZE];\n-  struct operation *stack = init_stack;\n-  struct operation *limit = stack + INIT_STACK_SIZE;\n-  register struct operation *top = stack + 1;\n-  long old_written = CPP_WRITTEN (pfile);\n+  struct op init_stack[INIT_STACK_SIZE];\n+  struct op *stack = init_stack;\n+  struct op *limit = stack + INIT_STACK_SIZE;\n+  register struct op *top = stack + 1;\n   int skip_evaluation = 0;\n   int result;\n-  char buff[5];\n \n   /* Save parser state and set it to something sane.  */\n   int save_skipping = pfile->skipping;\n   pfile->skipping = 0;\n \n   /* We've finished when we try to reduce this.  */\n-  top->op = FINISHED;\n+  top->op = CPP_EOF;\n   /* Nifty way to catch missing '('.  */\n   top->prio = EXTRACT_PRIO(CLOSE_PAREN_PRIO);\n   /* Avoid missing right operand checks.  */\n@@ -816,7 +758,7 @@ _cpp_parse_expr (pfile)\n     {\n       unsigned int prio;\n       unsigned int flags;\n-      struct operation op;\n+      struct op op;\n \n       /* Read a token */\n       op = lex (pfile, skip_evaluation);\n@@ -826,17 +768,10 @@ _cpp_parse_expr (pfile)\n \t try to reduce the expression on the stack.  */\n       switch (op.op)\n \t{\n-\tcase NAME:\n-\t  CPP_ICE (\"lex returns a NAME\");\n-\tcase ERROR:\n+\tcase CPP_ERROR:\n \t  goto syntax_error;\n-\tdefault:\n-\t  SYNTAX_ERROR2 (\"invalid character '%s' in #if\",\n-\t\t\t op_to_str (op.op, buff));\n-\n \tpush_immediate:\n-\tcase INT:\n-\tcase CHAR:\n+\tcase CPP_INT:\n \t  /* Push a value onto the stack.  */\n \t  if (top->flags & HAVE_VALUE)\n \t    SYNTAX_ERROR (\"missing binary operator\");\n@@ -845,40 +780,17 @@ _cpp_parse_expr (pfile)\n \t  top->flags |= HAVE_VALUE;\n \t  continue;\n \n-\tcase '+':\n-\tcase '-':    prio = PLUS_PRIO;  if (top->flags & HAVE_VALUE) break;\n+\tcase CPP_EOF:\tprio = FORCE_REDUCE_PRIO;\tbreak;\n+\tcase CPP_PLUS:\n+\tcase CPP_MINUS: prio = PLUS_PRIO;  if (top->flags & HAVE_VALUE) break;\n           /* else unary; fall through */\n-\tcase '!':\n-\tcase '~':    prio = UNARY_PRIO;  break;\n-\n-\tcase '*':\n-\tcase '/':\n-\tcase '%':    prio = MUL_PRIO;  break;\n-\tcase '<':\n-\tcase '>':\n-\tcase LEQ:\n-\tcase GEQ:    prio = LESS_PRIO;  break;\n-\tcase NOTEQUAL:\n-\tcase EQUAL:  prio = EQUAL_PRIO;  break;\n-\tcase LSH:\n-\tcase RSH:    prio = SHIFT_PRIO;  break;\n-\tcase '&':    prio = AND_PRIO;  break;\n-\tcase '^':    prio = XOR_PRIO;  break;\n-\tcase '|':    prio = OR_PRIO;  break;\n-\tcase ANDAND: prio = ANDAND_PRIO;  break;\n-\tcase OROR:   prio = OROR_PRIO;  break;\n-\tcase ',':    prio = COMMA_PRIO;  break;\n-\tcase '(':    prio = OPEN_PAREN_PRIO; break;\n-\tcase ')':    prio = CLOSE_PAREN_PRIO;  break;\n-        case ':':    prio = COLON_PRIO;  break;\n-        case '?':    prio = COND_PRIO;  break;\n-\tcase 0:      prio = FORCE_REDUCE_PRIO;  break;\n+\tdefault:\tprio = op_to_prio[op.op];\tbreak;\n \t}\n \n       /* Separate the operator's code into priority and flags.  */\n       flags = EXTRACT_FLAGS(prio);\n       prio = EXTRACT_PRIO(prio);\n-      if (op.op == '(')\n+      if (prio == EXTRACT_PRIO(OPEN_PAREN_PRIO))\n \tgoto skip_reduction;\n \n       /* Check for reductions.  Then push the operator.  */\n@@ -891,11 +803,11 @@ _cpp_parse_expr (pfile)\n \t     right operand.  Check this before trying to reduce.  */\n \t  if ((top->flags & (HAVE_VALUE | NO_R_OPERAND)) == 0)\n \t    {\n-\t      if (top->op == '(')\n+\t      if (top->op == CPP_OPEN_PAREN)\n \t\tSYNTAX_ERROR (\"void expression between '(' and ')'\");\n \t      else\n \t\tSYNTAX_ERROR2 (\"operator '%s' has no right operand\",\n-\t\t\t       op_to_str (top->op, buff));\n+\t\t\t       _cpp_spell_operator (top->op));\n \t    }\n \n \t  unsigned2 = top->unsignedp, v2 = top->value;\n@@ -905,12 +817,31 @@ _cpp_parse_expr (pfile)\n \t  /* Now set top->value = (top[1].op)(v1, v2); */\n \t  switch (top[1].op)\n \t    {\n-\t    case '+':\n+\t    default:\n+\t      cpp_ice (pfile, \"impossible operator type %s\",\n+\t\t       _cpp_spell_operator (op.op));\n+\t      goto syntax_error;\n+\n+\t    case CPP_NOT:\t UNARY(!);\tbreak;\n+\t    case CPP_COMPL:\t UNARY(~);\tbreak;\n+\t    case CPP_LESS:  \t COMPARE(<);\tbreak;\n+\t    case CPP_GREATER:\t COMPARE(>);\tbreak;\n+\t    case CPP_LESS_EQ:\t COMPARE(<=);\tbreak;\n+\t    case CPP_GREATER_EQ: COMPARE(>=);\tbreak;\n+\t    case CPP_EQ_EQ:\t EQUALITY(==);\tbreak;\n+\t    case CPP_NOT_EQ:\t EQUALITY(!=);\tbreak;\n+\t    case CPP_AND:\t BITWISE(&);\tbreak;\n+\t    case CPP_XOR:\t BITWISE(^);\tbreak;\n+\t    case CPP_OR:\t BITWISE(|);\tbreak;\n+\t    case CPP_AND_AND:\t LOGICAL(&&,!); break;\n+\t    case CPP_OR_OR:\t LOGICAL(||,);\tbreak;\n+\t    case CPP_LSHIFT:\t SHIFT(left_shift, right_shift); break;\n+\t    case CPP_RSHIFT:\t SHIFT(right_shift, left_shift); break;\n+\n+\t    case CPP_PLUS:\n \t      if (!(top->flags & HAVE_VALUE))\n-\t\t{ /* Unary '+' */\n-\t\t  top->value = v2;\n-\t\t  top->unsignedp = unsigned2;\n-\t\t  top->flags |= HAVE_VALUE;\n+\t\t{\n+\t\t  UNARY(+);\n \t\t}\n \t      else\n \t\t{\n@@ -921,15 +852,12 @@ _cpp_parse_expr (pfile)\n \t\t    integer_overflow (pfile);\n \t\t}\n \t      break;\n-\t    case '-':\n+\t    case CPP_MINUS:\n \t      if (!(top->flags & HAVE_VALUE))\n-\t\t{ /* Unary '-' */\n-\t\t  top->value = - v2;\n-\t\t  if (!skip_evaluation && (top->value & v2) < 0\n-\t\t      && !unsigned2)\n+\t\t{\n+\t\t  UNARY(-);\n+\t\t  if (!skip_evaluation && (top->value & v2) < 0 && !unsigned2)\n \t\t    integer_overflow (pfile);\n-\t\t  top->unsignedp = unsigned2;\n-\t\t  top->flags |= HAVE_VALUE;\n \t\t}\n \t      else\n \t\t{ /* Binary '-' */\n@@ -940,7 +868,7 @@ _cpp_parse_expr (pfile)\n \t\t    integer_overflow (pfile);\n \t\t}\n \t      break;\n-\t    case '*':\n+\t    case CPP_MULT:\n \t      top->unsignedp = unsigned1 | unsigned2;\n \t      if (top->unsignedp)\n \t\ttop->value = (unsigned HOST_WIDEST_INT) v1 * v2;\n@@ -952,14 +880,14 @@ _cpp_parse_expr (pfile)\n \t\t    integer_overflow (pfile);\n \t\t}\n \t      break;\n-\t    case '/':\n-\t    case '%':\n+\t    case CPP_DIV:\n+\t    case CPP_MOD:\n \t      if (skip_evaluation)\n \t\tbreak;\n \t      if (v2 == 0)\n \t\tSYNTAX_ERROR (\"division by zero in #if\");\n \t      top->unsignedp = unsigned1 | unsigned2;\n-\t      if (top[1].op == '/')\n+\t      if (top[1].op == CPP_DIV)\n \t\t{\n \t\t  if (top->unsignedp)\n \t\t    top->value = (unsigned HOST_WIDEST_INT) v1 / v2;\n@@ -978,79 +906,32 @@ _cpp_parse_expr (pfile)\n \t\t    top->value = v1 % v2;\n \t\t}\n \t      break;\n-\t    case '!':\n-\t      top->value = ! v2;\n-\t      top->unsignedp = 0;\n-\t      top->flags |= HAVE_VALUE;\n-\t      break;\n-\t    case '~':\n-\t      top->value = ~ v2;\n-\t      top->unsignedp = unsigned2;\n-\t      top->flags |= HAVE_VALUE;\n-\t      break;\n-\t    case '<':  COMPARE(<);  break;\n-\t    case '>':  COMPARE(>);  break;\n-\t    case LEQ:  COMPARE(<=);  break;\n-\t    case GEQ:  COMPARE(>=);  break;\n-\t    case EQUAL:    EQUALITY(==);  break;\n-\t    case NOTEQUAL: EQUALITY(!=);  break;\n-\t    case LSH:\n-\t      if (skip_evaluation)\n-\t\tbreak;\n-\t      top->unsignedp = unsigned1;\n-\t      if (v2 < 0 && ! unsigned2)\n-\t\ttop->value = right_shift (pfile, v1, unsigned1, -v2);\n-\t      else\n-\t\ttop->value = left_shift (pfile, v1, unsigned1, v2);\n-\t      break;\n-\t    case RSH:\n-\t      if (skip_evaluation)\n-\t\tbreak;\n-\t      top->unsignedp = unsigned1;\n-\t      if (v2 < 0 && ! unsigned2)\n-\t\ttop->value = left_shift (pfile, v1, unsigned1, -v2);\n-\t      else\n-\t\ttop->value = right_shift (pfile, v1, unsigned1, v2);\n-\t      break;\n-\t    case '&':  LOGICAL(&); break;\n-\t    case '^':  LOGICAL(^);  break;\n-\t    case '|':  LOGICAL(|);  break;\n-\t    case ANDAND:\n-\t      top->value = v1 && v2;  top->unsignedp = 0;\n-\t      if (!v1) skip_evaluation--;\n-\t      break;\n-\t    case OROR:\n-\t      top->value = v1 || v2;  top->unsignedp = 0;\n-\t      if (v1) skip_evaluation--;\n-\t      break;\n-\t    case ',':\n+\n+\t    case CPP_COMMA:\n \t      if (CPP_PEDANTIC (pfile))\n \t\tcpp_pedwarn (pfile, \"comma operator in operand of #if\");\n \t      top->value = v2;\n \t      top->unsignedp = unsigned2;\n \t      break;\n-\t    case '?':\n+\t    case CPP_QUERY:\n \t      SYNTAX_ERROR (\"syntax error '?' without following ':'\");\n-\t    case ':':\n-\t      if (top[0].op != '?')\n+\t    case CPP_COLON:\n+\t      if (top[0].op != CPP_QUERY)\n \t\tSYNTAX_ERROR (\"syntax error ':' without preceding '?'\");\n \t      top--;\n \t      if (top->value) skip_evaluation--;\n \t      top->value = top->value ? v1 : v2;\n \t      top->unsignedp = unsigned1 | unsigned2;\n \t      break;\n-\t    case '(':\n-\t      if (op.op != ')')\n+\t    case CPP_OPEN_PAREN:\n+\t      if (op.op != CPP_CLOSE_PAREN)\n \t\tSYNTAX_ERROR (\"missing ')' in expression\");\n \t      op.value = v2;\n \t      op.unsignedp = unsigned2;\n \t      goto push_immediate;\n-\t    default:\n-\t      SYNTAX_ERROR2 (\"unimplemented operator '%s'\",\n-\t\t\t     op_to_str (top[1].op, buff));\n-\t    case FINISHED:\n+\t    case CPP_EOF:\n \t      /* Reducing this dummy operator indicates we've finished.  */\n-\t      if (op.op == ')')\n+\t      if (op.op == CPP_CLOSE_PAREN)\n \t\tSYNTAX_ERROR (\"missing '(' in expression\");\n \t      goto done;\n \t    }\n@@ -1060,14 +941,16 @@ _cpp_parse_expr (pfile)\n       if (flags & SHORT_CIRCUIT)\n \tswitch (op.op)\n \t  {\n-\t  case OROR:    if (top->value) skip_evaluation++; break;\n-\t  case ANDAND:\n-\t  case '?':     if (!top->value) skip_evaluation++; break;\n-\t  case ':':\n+\t  case CPP_OR_OR:    if (top->value) skip_evaluation++; break;\n+\t  case CPP_AND_AND:\n+\t  case CPP_QUERY:    if (!top->value) skip_evaluation++; break;\n+\t  case CPP_COLON:\n \t    if (top[-1].value) /* Was '?' condition true?  */\n \t      skip_evaluation++;\n \t    else\n \t      skip_evaluation--;\n+\t  default:\n+\t    break;\n \t  }\n \n     skip_reduction:\n@@ -1076,32 +959,32 @@ _cpp_parse_expr (pfile)\n \t{\n \t  if (top->flags & HAVE_VALUE)\n \t    SYNTAX_ERROR2 (\"missing binary operator before '%s'\",\n-\t\t\t   op_to_str (op.op, buff));\n+\t\t\t   _cpp_spell_operator (op.op));\n \t}\n       else\n \t{\n \t  if (!(top->flags & HAVE_VALUE))\n \t    SYNTAX_ERROR2 (\"operator '%s' has no left operand\",\n-\t\t\t   op_to_str (op.op, buff));\n+\t\t\t   _cpp_spell_operator (op.op));\n \t}\n \n       /* Check for and handle stack overflow.  */\n       top++;\n       if (top == limit)\n \t{\n-\t  struct operation *new_stack;\n+\t  struct op *new_stack;\n \t  int old_size = (char *) limit - (char *) stack;\n \t  int new_size = 2 * old_size;\n \t  if (stack != init_stack)\n-\t    new_stack = (struct operation *) xrealloc (stack, new_size);\n+\t    new_stack = (struct op *) xrealloc (stack, new_size);\n \t  else\n \t    {\n-\t      new_stack = (struct operation *) xmalloc (new_size);\n+\t      new_stack = (struct op *) xmalloc (new_size);\n \t      memcpy (new_stack, stack, old_size);\n \t    }\n \t  stack = new_stack;\n-\t  top = (struct operation *) ((char *) new_stack + old_size);\n-\t  limit = (struct operation *) ((char *) new_stack + new_size);\n+\t  top = (struct op *) ((char *) new_stack + old_size);\n+\t  limit = (struct op *) ((char *) new_stack + new_size);\n \t}\n       \n       top->flags = flags;\n@@ -1112,19 +995,17 @@ _cpp_parse_expr (pfile)\n  done:\n   result = (top[1].value != 0);\n   if (top != stack)\n-    CPP_ICE (\"unbalanced stack in #if expression\");\n+    CPP_ICE (\"unbalanced stack in #if\");\n   else if (!(top[1].flags & HAVE_VALUE))\n     {\n       SYNTAX_ERROR (\"#if with no expression\");\n     syntax_error:\n-      _cpp_skip_rest_of_line (pfile);\n       result = 0;  /* Return 0 on syntax error.  */\n     }\n \n   /* Free dynamic stack if we allocated one.  */\n   if (stack != init_stack)\n     free (stack);\n-  CPP_SET_WRITTEN (pfile, old_written);\n   pfile->skipping = save_skipping;\n   return result;\n }"}, {"sha": "41c2686a69c68f8e9f849d975156fc72a2bd9ad9", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=cf00a885103d939b2175adc8918908a3b6f211d2", "patch": "@@ -213,8 +213,6 @@ extern void _cpp_skip_rest_of_line\tPARAMS ((cpp_reader *));\n extern void _cpp_free_temp_tokens\tPARAMS ((cpp_reader *));\n extern void _cpp_init_input_buffer\tPARAMS ((cpp_reader *));\n extern void _cpp_grow_token_buffer\tPARAMS ((cpp_reader *, long));\n-extern enum cpp_ttype _cpp_get_directive_token\n-\t\t\t\t\tPARAMS ((cpp_reader *));\n extern void _cpp_init_toklist\t\tPARAMS ((cpp_toklist *, int));\n extern void _cpp_clear_toklist\t\tPARAMS ((cpp_toklist *));\n extern void _cpp_free_toklist\t\tPARAMS ((const cpp_toklist *));\n@@ -238,6 +236,7 @@ extern unsigned int _cpp_get_line\tPARAMS ((cpp_reader *,\n extern const cpp_token *_cpp_get_raw_token PARAMS ((cpp_reader *));\n extern void _cpp_push_token PARAMS ((cpp_reader *, const cpp_token*));\n extern const cpp_token *_cpp_glue_header_name PARAMS ((cpp_reader *));\n+extern const U_CHAR *_cpp_spell_operator PARAMS ((enum cpp_ttype));\n \n /* In cpplib.c */\n extern const struct directive *_cpp_check_directive"}, {"sha": "9ce95caec5291476ecb61ae20b6e3fcd81314fc2", "filename": "gcc/cppinit.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=cf00a885103d939b2175adc8918908a3b6f211d2", "patch": "@@ -776,11 +776,6 @@ cpp_start_read (pfile, print, fname)\n   if (user_label_prefix == NULL)\n     user_label_prefix = USER_LABEL_PREFIX;\n \n-  /* Don't bother trying to do macro expansion if we've already done\n-     preprocessing.  */\n-  if (CPP_OPTION (pfile, preprocessed))\n-    pfile->no_macro_expand++;\n-\n   /* Figure out if we need to save function macro parameter spellings.\n      We don't use CPP_PEDANTIC() here because that depends on whether\n      or not the current file is a system header, and there is no"}, {"sha": "23d65401e67c3bb1e2f3d4538ce71c2ead1ebf38", "filename": "gcc/cpplex.c", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=cf00a885103d939b2175adc8918908a3b6f211d2", "patch": "@@ -167,13 +167,13 @@ token_spellings [N_TTYPES + 1] = {TTYPE_TABLE {0, 0} };\n #undef N\n \n /* For debugging: the internal names of the tokens.  */\n-#define T(e, s) STRINGX(e),\n-#define I(e, s) STRINGX(e),\n-#define S(e, s) STRINGX(e),\n-#define C(e, s) STRINGX(e),\n-#define N(e, s) STRINGX(e),\n+#define T(e, s) U STRINGX(e) + 4,\n+#define I(e, s) U STRINGX(e) + 4,\n+#define S(e, s) U STRINGX(e) + 4,\n+#define C(e, s) U STRINGX(e) + 4,\n+#define N(e, s) U STRINGX(e) + 4,\n \n-const char * const token_names[N_TTYPES] = { TTYPE_TABLE };\n+const U_CHAR *const token_names[N_TTYPES] = { TTYPE_TABLE };\n \n #undef T\n #undef I\n@@ -1872,10 +1872,9 @@ output_token (pfile, token, prev)\n }\n \n /* Write the spelling of a token TOKEN to BUFFER.  The buffer must\n-   already contain the enough space to hold the token's spelling.  If\n-   WHITESPACE is true, and the token was preceded by whitespace,\n-   output a single space before the token proper.  Returns a pointer\n-   to the character after the last character written.  */\n+   already contain the enough space to hold the token's spelling.\n+   Returns a pointer to the character after the last character\n+   written.  */\n \n static unsigned char *\n spell_token (pfile, token, buffer)\n@@ -1933,6 +1932,19 @@ spell_token (pfile, token, buffer)\n   return buffer;\n }\n \n+/* Return the spelling of a token known to be an operator.\n+   Does not distinguish digraphs from their counterparts.  */\n+const unsigned char *\n+_cpp_spell_operator (type)\n+     enum cpp_ttype type;\n+{\n+  if (token_spellings[type].type == SPELL_OPERATOR)\n+    return token_spellings[type].spelling;\n+  else\n+    return token_names[type];\n+}\n+\n+\n /* Macro expansion algorithm.  TODO.  */\n \n static const cpp_token placemarker_token = {0, 0, CPP_PLACEMARKER, 0 UNION_INIT_ZERO};\n@@ -2022,6 +2034,10 @@ is_macro_disabled (pfile, expansion, token)\n {\n   cpp_context *context = CURRENT_CONTEXT (pfile);\n \n+  /* Don't expand anything if this file has already been preprocessed.  */\n+  if (CPP_OPTION (pfile, preprocessed))\n+    return 1;\n+\n   /* Arguments on either side of ## are inserted in place without\n      macro expansion (6.10.3.3.2).  Conceptually, any macro expansion\n      occurs during a later rescan pass.  The effect is that we expand\n@@ -3275,26 +3291,6 @@ _cpp_dump_list (pfile, list, token, flush)\n     cpp_output_tokens (pfile, pfile->printer, pfile->token_list.line);\n }\n \n-/* Stub function during conversion, mainly for cppexp.c's benefit.  */\n-enum cpp_ttype\n-_cpp_get_directive_token (pfile)\n-     cpp_reader *pfile;\n-{\n-  const cpp_token *tok;\n-\n-  if (pfile->no_macro_expand)\n-    tok = _cpp_get_raw_token (pfile);\n-  else\n-    tok = cpp_get_token (pfile);\n-\n-  if (tok->type == CPP_EOF)\n-    return CPP_VSPACE;  /* backward compat; and don't try to spell EOF */\n-\n-  CPP_RESERVE (pfile, TOKEN_LEN (tok));\n-  pfile->limit = spell_token (pfile, tok, pfile->limit);\n-  return tok->type;\n-}\n-\n /* Allocate pfile->input_buffer, and initialize trigraph_map[]\n    if it hasn't happened already.  */\n "}, {"sha": "9e93e4dbf9423294ccd528eb347b8cfba3fcde13", "filename": "gcc/cpplib.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=cf00a885103d939b2175adc8918908a3b6f211d2", "patch": "@@ -476,7 +476,7 @@ read_line_number (pfile, num)\n     }\n   else\n     {\n-      if (type != CPP_VSPACE && type != CPP_EOF)\n+      if (type != CPP_EOF)\n \tcpp_error (pfile, \"invalid format #line\");\n       return 0;\n     }\n@@ -545,7 +545,7 @@ do_line (pfile)\n   str = tok->val.name.text;\n   len = tok->val.name.len;\n \n-  if (type == CPP_VSPACE || type == CPP_EOF)\n+  if (type == CPP_EOF)\n     goto done;\n   else if (type != CPP_STRING)\n     {"}, {"sha": "5f49f91ae80fba2cff5a319672946a1bd0294046", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=cf00a885103d939b2175adc8918908a3b6f211d2", "patch": "@@ -123,10 +123,7 @@ typedef struct cpp_hashnode cpp_hashnode;\n   I(CPP_COMMENT,\t0)\t/* Only if output comments.  */ \\\n   N(CPP_MACRO_ARG,      0)\t/* Macro argument.  */          \\\n   N(CPP_EOF,\t\t0)\t/* End of file.  */\t\t\\\n-  I(CPP_HEADER_NAME,\t0)\t/* <stdio.h> in #include */\t\\\n-\\\n-  /* Obsolete - will be removed when no code uses them still.  */\t\\\n-  T(CPP_VSPACE,\t\t\"\\n\")\t/* End of line.  */\n+  I(CPP_HEADER_NAME,\t0)\t/* <stdio.h> in #include */\n \n #define T(e, s) e,\n #define I(e, s) e,\n@@ -542,9 +539,6 @@ struct cpp_reader\n      containing files that matches the current status.  */\n   unsigned char input_stack_listing_current;\n \n-  /* If non-zero, macros are not expanded.  */\n-  unsigned char no_macro_expand;\n-\n   /* We're printed a warning recommending against using #import.  */\n   unsigned char import_warning;\n \n@@ -555,7 +549,8 @@ struct cpp_reader\n   /* True if we are skipping a failed conditional group.  */\n   unsigned char skipping;\n \n-  /* Do we need to save paramter spellings.  */\n+  /* True if we need to save parameter spellings - only if -pedantic,\n+     or we might need to write out definitions.  */\n   unsigned char save_parameter_spellings;\n \n   /* If we're in lex_line.  */"}, {"sha": "ddc8a99c746534770dc0047225ac9e3664333991", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cf00a885103d939b2175adc8918908a3b6f211d2", "patch": "@@ -1,3 +1,8 @@\n+2000-07-07  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* gcc.dg/cpp/19951227-1.c, gcc.dg/cpp/assert2.c,\n+\tgcc.dg/cpp/if-1.c, gcc.dg/cpp/if-4.c: Tweak error regexps.\n+\n 2000-07-08  Neil Booth  <NeilB@earthling.net>\n \n \t* gcc.dg/cpp/macsyntx.c: New tests."}, {"sha": "da2f6d8513b148afdd02cdd717670e85bfa0573d", "filename": "gcc/testsuite/gcc.dg/cpp/19951227-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19951227-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19951227-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19951227-1.c?ref=cf00a885103d939b2175adc8918908a3b6f211d2", "patch": "@@ -1,3 +1,3 @@\n /* { dg-do preprocess } */\n-#if 0xe-1\t/* { dg-error \"invalid number\" } */\n+#if 0xe-1\t/* { dg-error \"invalid suffix\" } */\n #endif"}, {"sha": "bdbf85d2998024b8b2a3e029815adb812bc1aa37", "filename": "gcc/testsuite/gcc.dg/cpp/assert2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert2.c?ref=cf00a885103d939b2175adc8918908a3b6f211d2", "patch": "@@ -20,5 +20,5 @@\n #error\t\t/* { dg-bogus \"error\" \"test w/o answer\" } */\n #endif\n \n-#if #abc[def]\t/* { dg-error \"invalid char\" \"test with malformed answer\" } */\n+#if #abc[def]\t/* { dg-error \"is not valid\" \"test with malformed answer\" } */\n #endif"}, {"sha": "863fa904753ef63ad6365710116262140feb39a3", "filename": "gcc/testsuite/gcc.dg/cpp/if-1.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-1.c?ref=cf00a885103d939b2175adc8918908a3b6f211d2", "patch": "@@ -9,22 +9,29 @@\n #error 077 != 63 /* { dg-bogus \"#error\" \"normal conversion\" } */\n #endif\n \n-#if 12wrt /* { dg-error \"nvalid number|missing white\" \"invalid number\" } */\n+#if 12wrt /* { dg-error \"invalid suffix\" \"invalid number\" } */\n #endif\n \n-#if 0abc /* { dg-error \"nvalid number|missing white\" \"invalid number\" } */\n+#if 0abc /* { dg-error \"invalid suffix\" \"invalid number\" } */\n #endif\n \n-#if 42abc /* { dg-error \"nvalid number|missing white\" \"invalid number\" } */\n+#if 42abc /* { dg-error \"invalid suffix\" \"invalid number\" } */\n+#endif\n+\n+#if 0xabc != 2748\n+#error 0xabc\t/* { dg-bogus \"#error\" \"normal conversion\" } */\n #endif\n \n #if 1.2 /* { dg-error \"loating point numbers\" \"floating point in #if\" } */\n #endif\n \n-#if 4uu /* { dg-error \"too many 'u'\" \"too many suffixes\" } */\n+#if 4uu /* { dg-error \"invalid suffix\" \"too many suffixes\" } */\n+#endif\n+\n+#if 124123231lll /* { dg-error \"invalid suffix\" \"too many suffixes\" } */\n #endif\n \n-#if 124123231lll /* { dg-error \"too many 'l'\" \"too many suffixes\" } */\n+#if 1234lul\t/* { dg-error \"invalid suffix\" \"u between ls\" } */\n #endif\n \n #if 099 /* { dg-error \"digits beyond the radix\" \"decimal in octal constant\" } */"}, {"sha": "a39c11d412d0cf34cd8f7a9ec17062ec52bc39e7", "filename": "gcc/testsuite/gcc.dg/cpp/if-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf00a885103d939b2175adc8918908a3b6f211d2/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fif-4.c?ref=cf00a885103d939b2175adc8918908a3b6f211d2", "patch": "@@ -2,7 +2,7 @@\n    NUL terminated, so we would print garbage after it.  */\n /* { dg-do compile } */\n \n-#if 1 += 2   /* { dg-error \"'\\\\+=' is not allowed\" \"+= in if\" } */\n+#if 1 += 2   /* { dg-error \"'\\\\+=' is not valid\" \"+= in if\" } */\n syntax_error\n #endif\n int foo;"}]}