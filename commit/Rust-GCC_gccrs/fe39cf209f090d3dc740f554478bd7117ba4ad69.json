{"sha": "fe39cf209f090d3dc740f554478bd7117ba4ad69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUzOWNmMjA5ZjA5MGQzZGM3NDBmNTU0NDc4YmQ3MTE3YmE0YWQ2OQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2007-12-19T16:24:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-19T16:24:44Z"}, "message": "sem_ch4.adb (Analyze_Concatenation_Rest): New procedure.\n\n2007-12-19  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Concatenation_Rest): New procedure.\n\t(Analyze_Concatenation): Use iteration instead of recursion in order\n\tto avoid running out of stack space for deeply nested concatenations.\n\nFrom-SVN: r131080", "tree": {"sha": "ec04055489cb646bd845dcf2d12c39be32041888", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec04055489cb646bd845dcf2d12c39be32041888"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe39cf209f090d3dc740f554478bd7117ba4ad69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe39cf209f090d3dc740f554478bd7117ba4ad69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe39cf209f090d3dc740f554478bd7117ba4ad69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe39cf209f090d3dc740f554478bd7117ba4ad69/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f29b857f303d388e8697e64414a27e6cafe9cce2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29b857f303d388e8697e64414a27e6cafe9cce2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f29b857f303d388e8697e64414a27e6cafe9cce2"}], "stats": {"total": 75, "additions": 65, "deletions": 10}, "files": [{"sha": "ebfdccf86ad97c7613f99c3a2cc100c2e3ace429", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 65, "deletions": 10, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe39cf209f090d3dc740f554478bd7117ba4ad69/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe39cf209f090d3dc740f554478bd7117ba4ad69/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=fe39cf209f090d3dc740f554478bd7117ba4ad69", "patch": "@@ -63,6 +63,10 @@ package body Sem_Ch4 is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Analyze_Concatenation_Rest (N : Node_Id);\n+   --  Does the \"rest\" of the work of Analyze_Concatenation, after the left\n+   --  operand has been analyzed. See Analyze_Concatenation for details.\n+\n    procedure Analyze_Expression (N : Node_Id);\n    --  For expressions that are not names, this is just a call to analyze.\n    --  If the expression is a name, it may be a call to a parameterless\n@@ -1031,23 +1035,74 @@ package body Sem_Ch4 is\n    -- Analyze_Concatenation --\n    ---------------------------\n \n+   procedure Analyze_Concatenation (N : Node_Id) is\n+\n+      --  We wish to avoid deep recursion, because concatenations are often\n+      --  deeply nested, as in A&B&...&Z. Therefore, we walk down the left\n+      --  operands nonrecursively until we find something that is not a\n+      --  concatenation (A in this case), or has already been analyzed. We\n+      --  analyze that, and then walk back up the tree following Parent\n+      --  pointers, calling Analyze_Concatenation_Rest to do the rest of the\n+      --  work at each level. The Parent pointers allow us to avoid recursion,\n+      --  and thus avoid running out of memory.\n+\n+      NN : Node_Id := N;\n+      L  : Node_Id;\n+\n+   begin\n+      Candidate_Type := Empty;\n+\n+      --  The following code is equivalent to:\n+\n+      --    Set_Etype (N, Any_Type);\n+      --    Analyze_Expression (Left_Opnd (N));\n+      --    Analyze_Concatenation_Rest (N);\n+\n+      --  where the Analyze_Expression call recurses back here if the left\n+      --  operand is a concatenation.\n+\n+      --  Walk down left operands\n+\n+      loop\n+         Set_Etype (NN, Any_Type);\n+         L := Left_Opnd (NN);\n+         exit when Nkind (L) /= N_Op_Concat or else Analyzed (L);\n+         NN := L;\n+      end loop;\n+\n+      --  Now (given the above example) NN is A&B and L is A\n+\n+      --  First analyze L ...\n+\n+      Analyze_Expression (L);\n+\n+      --  ... then walk NN back up until we reach N (where we started), calling\n+      --  Analyze_Concatenation_Rest along the way.\n+\n+      loop\n+         Analyze_Concatenation_Rest (NN);\n+         exit when NN = N;\n+         NN := Parent (NN);\n+      end loop;\n+   end Analyze_Concatenation;\n+\n+   --------------------------------\n+   -- Analyze_Concatenation_Rest --\n+   --------------------------------\n+\n    --  If the only one-dimensional array type in scope is String,\n    --  this is the resulting type of the operation. Otherwise there\n    --  will be a concatenation operation defined for each user-defined\n    --  one-dimensional array.\n \n-   procedure Analyze_Concatenation (N : Node_Id) is\n+   procedure Analyze_Concatenation_Rest (N : Node_Id) is\n       L     : constant Node_Id := Left_Opnd (N);\n       R     : constant Node_Id := Right_Opnd (N);\n       Op_Id : Entity_Id        := Entity (N);\n       LT    : Entity_Id;\n       RT    : Entity_Id;\n \n    begin\n-      Set_Etype (N, Any_Type);\n-      Candidate_Type := Empty;\n-\n-      Analyze_Expression (L);\n       Analyze_Expression (R);\n \n       --  If the entity is present, the node appears in an instance, and\n@@ -1126,7 +1181,7 @@ package body Sem_Ch4 is\n       end if;\n \n       Operator_Check (N);\n-   end Analyze_Concatenation;\n+   end Analyze_Concatenation_Rest;\n \n    ------------------------------------\n    -- Analyze_Conditional_Expression --\n@@ -1525,10 +1580,10 @@ package body Sem_Ch4 is\n       -------------------------------\n \n       procedure Process_Indexed_Component is\n-         Exp          : Node_Id;\n-         Array_Type   : Entity_Id;\n-         Index        : Node_Id;\n-         Pent         : Entity_Id := Empty;\n+         Exp        : Node_Id;\n+         Array_Type : Entity_Id;\n+         Index      : Node_Id;\n+         Pent       : Entity_Id := Empty;\n \n       begin\n          Exp := First (Exprs);"}]}