{"sha": "e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFmZDA0MDg4NGFiN2FjMzZjYTU1NTVhYjU4MjJiY2I1ZTUxZThkOA==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-01-21T22:38:54Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-01-22T17:30:15Z"}, "message": "PR c++/92907 - noexcept does not consider \"const\" in member functions.\n\nHere the problem is that if the noexcept specifier is used in the context\nof a const member function, const is not considered for the member variables,\nleading to a bogus error.  g's const makes its 'this' const, so the first\noverload of f should be selected.\n\nIn cp_parser_noexcept_specification_opt we inject 'this', but always\nunqualified:\n25737           if (current_class_type)\n25738             inject_this_parameter (current_class_type, TYPE_UNQUALIFIED);\nso we need to pass the function's qualifiers down here.  In\ncp_parser_direct_declarator it's easy: use the just parsed cv_quals, in\ncp_parser_late_noexcept_specifier look at the 'this' parameter to figure it\nout.\n\n2020-01-22  Marek Polacek  <polacek@redhat.com>\n\n\tPR c++/92907 - noexcept does not consider \"const\" in member functions.\n\t* parser.c (cp_parser_lambda_declarator_opt): Pass the proper\n\tqualifiers to cp_parser_exception_specification_opt.\n\t(cp_parser_direct_declarator): Pass the function qualifiers to\n\tcp_parser_exception_specification_opt.\n\t(cp_parser_class_specifier_1): Pass the function declaration to\n\tcp_parser_late_noexcept_specifier.\n\t(cp_parser_late_noexcept_specifier): Add a tree parameter.  Use it to\n\tpass the qualifiers of the function to\n\tcp_parser_noexcept_specification_opt.\n\t(cp_parser_noexcept_specification_opt): New cp_cv_quals parameter.\n\tUse it in inject_this_parameter.\n\t(cp_parser_exception_specification_opt): New cp_cv_quals parameter.\n\tUse it.\n\t(cp_parser_transaction): Pass TYPE_UNQUALIFIED to\n\tcp_parser_noexcept_specification_opt.\n\t(cp_parser_transaction_expression): Likewise.\n\n\t* g++.dg/cpp0x/noexcept56.C: New test.", "tree": {"sha": "2f923a8d3232ebc3530b978b25a2374fb1e37a92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f923a8d3232ebc3530b978b25a2374fb1e37a92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15ed55eabb0cf8a2974b8025a9f46c9e58960811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15ed55eabb0cf8a2974b8025a9f46c9e58960811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15ed55eabb0cf8a2974b8025a9f46c9e58960811"}], "stats": {"total": 90, "additions": 70, "deletions": 20}, "files": [{"sha": "47d4f2d496cb860a23f6aa3b341ef9e2fac2d6e6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8", "patch": "@@ -1,3 +1,8 @@\n+2020-01-22  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/92907 - noexcept does not consider \"const\" in member functions.\n+\t* g++.dg/cpp0x/noexcept56.C: New test.\n+\n 2020-01-22  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/93324 - ICE with -Wall on constexpr if."}, {"sha": "dc07dc55d9c52e678cc49fc11c29179eb793242d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8", "patch": "@@ -246,7 +246,7 @@ static void cp_lexer_stop_debugging\n static cp_token_cache *cp_token_cache_new\n   (cp_token *, cp_token *);\n static tree cp_parser_late_noexcept_specifier\n-  (cp_parser *, tree);\n+  (cp_parser *, tree, tree);\n static void noexcept_override_late_checks\n   (tree, tree);\n \n@@ -2388,11 +2388,11 @@ static tree cp_parser_exception_declaration\n static tree cp_parser_throw_expression\n   (cp_parser *);\n static tree cp_parser_exception_specification_opt\n-  (cp_parser *, cp_parser_flags);\n+  (cp_parser *, cp_parser_flags, cp_cv_quals);\n static tree cp_parser_type_id_list\n   (cp_parser *);\n static tree cp_parser_noexcept_specification_opt\n-  (cp_parser *, cp_parser_flags, bool, bool *, bool);\n+  (cp_parser *, cp_parser_flags, bool, bool *, bool, cp_cv_quals);\n \n /* GNU Extensions */\n \n@@ -10908,6 +10908,8 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n   tree trailing_requires_clause = NULL_TREE;\n   cp_decl_specifier_seq lambda_specs;\n   clear_decl_specs (&lambda_specs);\n+  /* A lambda op() is const unless explicitly 'mutable'.  */\n+  cp_cv_quals quals = TYPE_QUAL_CONST;\n \n   /* The template-parameter-list is optional, but must begin with\n      an opening angle if present.  */\n@@ -10999,6 +11001,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n       if (lambda_specs.storage_class == sc_mutable)\n \t{\n \t  LAMBDA_EXPR_MUTABLE_P (lambda_expr) = 1;\n+\t  quals = TYPE_UNQUALIFIED;\n \t  if (lambda_specs.conflicting_specifiers_p)\n \t    error_at (lambda_specs.locations[ds_storage_class],\n \t\t      \"duplicate %<mutable%>\");\n@@ -11008,7 +11011,8 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \n       /* Parse optional exception specification.  */\n       exception_spec\n-\t= cp_parser_exception_specification_opt (parser, CP_PARSER_FLAGS_NONE);\n+\t= cp_parser_exception_specification_opt (parser, CP_PARSER_FLAGS_NONE,\n+\t\t\t\t\t\t quals);\n \n       std_attrs = cp_parser_std_attribute_spec_seq (parser);\n \n@@ -11041,7 +11045,6 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n     cp_decl_specifier_seq return_type_specs;\n     cp_declarator* declarator;\n     tree fco;\n-    int quals;\n     void *p;\n \n     clear_decl_specs (&return_type_specs);\n@@ -11066,8 +11069,6 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n     declarator = make_id_declarator (NULL_TREE, call_op_identifier, sfk_none,\n \t\t\t\t     LAMBDA_EXPR_LOCATION (lambda_expr));\n \n-    quals = (LAMBDA_EXPR_MUTABLE_P (lambda_expr)\n-\t     ? TYPE_UNQUALIFIED : TYPE_QUAL_CONST);\n     declarator = make_call_declarator (declarator, param_list, quals,\n \t\t\t\t       VIRT_SPEC_UNSPECIFIED,\n                                        REF_QUAL_NONE,\n@@ -21127,7 +21128,9 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t  tree tx_qual = cp_parser_tx_qualifier_opt (parser);\n \t\t  /* And the exception-specification.  */\n \t\t  exception_specification\n-\t\t    = cp_parser_exception_specification_opt (parser, flags);\n+\t\t    = cp_parser_exception_specification_opt (parser,\n+\t\t\t\t\t\t\t     flags,\n+\t\t\t\t\t\t\t     cv_quals);\n \n \t\t  attrs = cp_parser_std_attribute_spec_seq (parser);\n \n@@ -23985,7 +23988,7 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n \t    parser->local_variables_forbidden_p |= THIS_FORBIDDEN;\n \n \t  /* Now we can parse the noexcept-specifier.  */\n-\t  spec = cp_parser_late_noexcept_specifier (parser, spec);\n+\t  spec = cp_parser_late_noexcept_specifier (parser, spec, decl);\n \n \t  if (spec != error_mark_node)\n \t    TREE_TYPE (decl) = build_exception_variant (TREE_TYPE (decl), spec);\n@@ -25612,10 +25615,12 @@ cp_parser_save_noexcept (cp_parser *parser)\n \n /* Used for late processing of noexcept-specifiers of member-functions.\n    DEFAULT_ARG is the unparsed operand of a noexcept-specifier which\n-   we saved for later; parse it now.  */\n+   we saved for later; parse it now.  DECL is the declaration of the\n+   member function.  */\n \n static tree\n-cp_parser_late_noexcept_specifier (cp_parser *parser, tree default_arg)\n+cp_parser_late_noexcept_specifier (cp_parser *parser, tree default_arg,\n+\t\t\t\t   tree decl)\n {\n   /* Make sure we've gotten something that hasn't been parsed yet.  */\n   gcc_assert (TREE_CODE (default_arg) == DEFERRED_PARSE);\n@@ -25627,13 +25632,16 @@ cp_parser_late_noexcept_specifier (cp_parser *parser, tree default_arg)\n   cp_token_cache *tokens = DEFPARSE_TOKENS (default_arg);\n   cp_parser_push_lexer_for_tokens (parser, tokens);\n \n+  /* We need to know if this member function was declared `const'.  Look\n+     at the this parameter to figure that out.  */\n+  cp_cv_quals quals = type_memfn_quals (TREE_TYPE (decl));\n   /* Parse the cached noexcept-specifier.  */\n   tree parsed_arg\n     = cp_parser_noexcept_specification_opt (parser,\n \t\t\t\t\t    CP_PARSER_FLAGS_NONE,\n \t\t\t\t\t    /*require_constexpr=*/true,\n \t\t\t\t\t    /*consumed_expr=*/NULL,\n-\t\t\t\t\t    /*return_cond=*/false);\n+\t\t\t\t\t    /*return_cond=*/false, quals);\n \n   /* Revert to the main lexer.  */\n   cp_parser_pop_lexer (parser);\n@@ -25683,14 +25691,16 @@ noexcept_override_late_checks (tree type, tree fndecl)\n    there are no parentheses.  CONSUMED_EXPR will be set accordingly.\n    Otherwise, returns a noexcept specification unless RETURN_COND is true,\n    in which case a boolean condition is returned instead.  The parser flags\n-   FLAGS is used to control parsing.  */\n+   FLAGS is used to control parsing.  QUALS are qualifiers indicating whether\n+   the (member) function is `const'.  */\n \n static tree\n cp_parser_noexcept_specification_opt (cp_parser* parser,\n \t\t\t\t      cp_parser_flags flags,\n \t\t\t\t      bool require_constexpr,\n \t\t\t\t      bool* consumed_expr,\n-\t\t\t\t      bool return_cond)\n+\t\t\t\t      bool return_cond,\n+\t\t\t\t      cp_cv_quals quals)\n {\n   cp_token *token;\n   const char *saved_message;\n@@ -25736,7 +25746,7 @@ cp_parser_noexcept_specification_opt (cp_parser* parser,\n \t  tree save_ccr = current_class_ref;\n \n \t  if (current_class_type)\n-\t    inject_this_parameter (current_class_type, TYPE_UNQUALIFIED);\n+\t    inject_this_parameter (current_class_type, quals);\n \n \t  if (require_constexpr)\n \t    {\n@@ -25796,10 +25806,13 @@ cp_parser_noexcept_specification_opt (cp_parser* parser,\n \n    Returns a TREE_LIST representing the exception-specification.  The\n    TREE_VALUE of each node is a type.  The parser flags FLAGS is used to\n-   control parsing.  */\n+   control parsing.  QUALS are qualifiers indicating whether the (member)\n+   function is `const'.  */\n \n static tree\n-cp_parser_exception_specification_opt (cp_parser* parser, cp_parser_flags flags)\n+cp_parser_exception_specification_opt (cp_parser* parser,\n+\t\t\t\t       cp_parser_flags flags,\n+\t\t\t\t       cp_cv_quals quals)\n {\n   cp_token *token;\n   tree type_id_list;\n@@ -25813,7 +25826,7 @@ cp_parser_exception_specification_opt (cp_parser* parser, cp_parser_flags flags)\n     = cp_parser_noexcept_specification_opt (parser, flags,\n \t\t\t\t\t    /*require_constexpr=*/true,\n \t\t\t\t\t    /*consumed_expr=*/NULL,\n-\t\t\t\t\t    /*return_cond=*/false);\n+\t\t\t\t\t    /*return_cond=*/false, quals);\n   if (type_id_list != NULL_TREE)\n     return type_id_list;\n \n@@ -42965,7 +42978,8 @@ cp_parser_transaction (cp_parser *parser, cp_token *token)\n \t\t\t\t\t\t CP_PARSER_FLAGS_NONE,\n \t\t\t\t\t\t /*require_constexpr=*/true,\n \t\t\t\t\t\t /*consumed_expr=*/NULL,\n-\t\t\t\t\t\t /*return_cond=*/true);\n+\t\t\t\t\t\t /*return_cond=*/true,\n+\t\t\t\t\t\t TYPE_UNQUALIFIED);\n \n   /* Keep track if we're in the lexical scope of an outer transaction.  */\n   new_in = this_in | (old_in & TM_STMT_ATTR_OUTER);\n@@ -43029,7 +43043,8 @@ cp_parser_transaction_expression (cp_parser *parser, enum rid keyword)\n \t\t\t\t\t       CP_PARSER_FLAGS_NONE,\n \t\t\t\t\t       /*require_constexpr=*/false,\n \t\t\t\t\t       &noex_expr,\n-\t\t\t\t\t       /*return_cond=*/true);\n+\t\t\t\t\t       /*return_cond=*/true,\n+\t\t\t\t\t       TYPE_UNQUALIFIED);\n \n   if (!noex || !noex_expr\n       || cp_lexer_peek_token (parser->lexer)->type == CPP_OPEN_PAREN)"}, {"sha": "6c5fe273c6423e9ee21d80cdf6a7a2f636f7cb4b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8", "patch": "@@ -1,3 +1,23 @@\n+2020-01-22  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/92907 - noexcept does not consider \"const\" in member functions.\n+\t* parser.c (cp_parser_lambda_declarator_opt): Pass the proper\n+\tqualifiers to cp_parser_exception_specification_opt.\n+\t(cp_parser_direct_declarator): Pass the function qualifiers to\n+\tcp_parser_exception_specification_opt.\n+\t(cp_parser_class_specifier_1): Pass the function declaration to\n+\tcp_parser_late_noexcept_specifier.\n+\t(cp_parser_late_noexcept_specifier): Add a tree parameter.  Use it to\n+\tpass the qualifiers of the function to\n+\tcp_parser_noexcept_specification_opt.\n+\t(cp_parser_noexcept_specification_opt): New cp_cv_quals parameter.\n+\tUse it in inject_this_parameter.\n+\t(cp_parser_exception_specification_opt): New cp_cv_quals parameter.\n+\tUse it.\n+\t(cp_parser_transaction): Pass TYPE_UNQUALIFIED to\n+\tcp_parser_noexcept_specification_opt.\n+\t(cp_parser_transaction_expression): Likewise.\n+\n 2020-01-22  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/93324 - ICE with -Wall on constexpr if."}, {"sha": "8eea6b91f7e8e4529b772f8598980d7579110c6a", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept56.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept56.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept56.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept56.C?ref=e1fd040884ab7ac36ca5555ab5822bcb5e51e8d8", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/92907 - noexcept does not consider \"const\" in member functions.\n+// { dg-do compile { target c++11 } }\n+\n+void f(const int&);\n+void f(int&) = delete;\n+\n+struct A {\n+  int i;\n+  void g() const noexcept(noexcept(f(i)));\n+};"}]}