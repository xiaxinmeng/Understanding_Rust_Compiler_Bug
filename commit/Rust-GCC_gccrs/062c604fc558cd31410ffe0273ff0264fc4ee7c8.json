{"sha": "062c604fc558cd31410ffe0273ff0264fc4ee7c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYyYzYwNGZjNTU4Y2QzMTQxMGZmZTAyNzNmZjAyNjRmYzRlZTdjOA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-06-25T14:27:47Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-06-25T14:27:47Z"}, "message": "ipa-prop.h (struct ipa_param_descriptor): Removed the modified flag.\n\n2010-06-25  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (struct ipa_param_descriptor): Removed the modified flag.\n\t(struct ipa_node_params): Removed the modification_analysis_done flag.\n\t(ipa_is_param_modified): Removed.\n\t(ipa_analyze_node): Declare.\n\t(ipa_compute_jump_functions): Remove declaration.\n\t(ipa_count_arguments): Likewise.\n\t(ipa_detect_param_modifications): Likewise.\n\t(ipa_analyze_params_uses): Likewise.\n\t* ipa-prop.c (struct param_analysis_info): New type.\n\t(visit_store_addr_for_mod_analysis): Removed.\n\t(visit_load_for_mod_analysis): Renamed to visit_ref_for_mod_analysis,\n\tmoved down in the file.\n\t(ipa_detect_param_modifications): Merged into ipa_analyze_params_uses.\n\t(ipa_count_arguments): Made static.\n\t(mark_modified): New function.\n\t(is_parm_modified_before_call): New function.\n\t(compute_pass_through_member_ptrs): New parameter parms_info, call\n\tis_parm_modified_before_call instead of ipa_is_param_modified.\n\t(ipa_compute_jump_functions_for_edge): New parameter parms_info, pass\n\tit to compute_pass_through_member_ptrs.\n\t(ipa_compute_jump_functions): New parameter parms_info, pass it to\n\tipa_compute_jump_functions_for_edge.  Call ipa_initialize_node_params\n\ton the callee if it is analyzed.  Made static.\n\t(ipa_analyze_indirect_call_uses): New parameter parms_info, call\n\tis_parm_modified_before_call instead of ipa_is_param_modified.\n\t(ipa_analyze_call_uses): New parameter parms_info, pass it to\n\tipa_analyze_indirect_call_uses.\n\t(ipa_analyze_stmt_uses): New parameter parms_info, pass it to\n\tipa_analyze_call_uses.\n\t(ipa_analyze_params_uses): New parameter parms_info, pass it to\n\tipa_analyze_stmt_uses.  Also perform the used analysis.  Made static.\n\t(ipa_analyze_node): New function.\n\t(ipa_print_node_params): Do not dump the modified flag.\n\t(ipa_write_node_info): Assert uses_analysis_done rather than streaming\n\tit.  Do not stream the modified parameter flag.\n\t(ipa_read_node_info): Set uses_analysis_done to 1 instead of streaming\n\tit.  Do not stream the modified parameter flag.\n\t* ipa-cp.c (ipcp_analyze_node): Removed.\n\t(ipcp_init_stage): Iterate only once over the nodes, analyze each one\n\twith only a call to ipa_analyze_node.\n\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): Analyze the\n\tnode with only a call to ipa_analyze_node.\n\t\n\t* testsuite/g++.dg/ipa/iinline-3.C: New test.\n\t* testsuite/gcc.dg/ipa/modif-1.c: Removed.\n\nFrom-SVN: r161384", "tree": {"sha": "a60ec3339f5eb1694260afebbffe15e123fcb971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a60ec3339f5eb1694260afebbffe15e123fcb971"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/062c604fc558cd31410ffe0273ff0264fc4ee7c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/062c604fc558cd31410ffe0273ff0264fc4ee7c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/062c604fc558cd31410ffe0273ff0264fc4ee7c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/062c604fc558cd31410ffe0273ff0264fc4ee7c8/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "212580ffb8305e6da025fd873f1732879b835de1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/212580ffb8305e6da025fd873f1732879b835de1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/212580ffb8305e6da025fd873f1732879b835de1"}], "stats": {"total": 515, "additions": 292, "deletions": 223}, "files": [{"sha": "f64b96910052f5aca1c659d998cbaf373aa945cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=062c604fc558cd31410ffe0273ff0264fc4ee7c8", "patch": "@@ -1,3 +1,48 @@\n+2010-06-25  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (struct ipa_param_descriptor): Removed the modified flag.\n+\t(struct ipa_node_params): Removed the modification_analysis_done flag.\n+\t(ipa_is_param_modified): Removed.\n+\t(ipa_analyze_node): Declare.\n+\t(ipa_compute_jump_functions): Remove declaration.\n+\t(ipa_count_arguments): Likewise.\n+\t(ipa_detect_param_modifications): Likewise.\n+\t(ipa_analyze_params_uses): Likewise.\n+\t* ipa-prop.c (struct param_analysis_info): New type.\n+\t(visit_store_addr_for_mod_analysis): Removed.\n+\t(visit_load_for_mod_analysis): Renamed to visit_ref_for_mod_analysis,\n+\tmoved down in the file.\n+\t(ipa_detect_param_modifications): Merged into ipa_analyze_params_uses.\n+\t(ipa_count_arguments): Made static.\n+\t(mark_modified): New function.\n+\t(is_parm_modified_before_call): New function.\n+\t(compute_pass_through_member_ptrs): New parameter parms_info, call\n+\tis_parm_modified_before_call instead of ipa_is_param_modified.\n+\t(ipa_compute_jump_functions_for_edge): New parameter parms_info, pass\n+\tit to compute_pass_through_member_ptrs.\n+\t(ipa_compute_jump_functions): New parameter parms_info, pass it to\n+\tipa_compute_jump_functions_for_edge.  Call ipa_initialize_node_params\n+\ton the callee if it is analyzed.  Made static.\n+\t(ipa_analyze_indirect_call_uses): New parameter parms_info, call\n+\tis_parm_modified_before_call instead of ipa_is_param_modified.\n+\t(ipa_analyze_call_uses): New parameter parms_info, pass it to\n+\tipa_analyze_indirect_call_uses.\n+\t(ipa_analyze_stmt_uses): New parameter parms_info, pass it to\n+\tipa_analyze_call_uses.\n+\t(ipa_analyze_params_uses): New parameter parms_info, pass it to\n+\tipa_analyze_stmt_uses.  Also perform the used analysis.  Made static.\n+\t(ipa_analyze_node): New function.\n+\t(ipa_print_node_params): Do not dump the modified flag.\n+\t(ipa_write_node_info): Assert uses_analysis_done rather than streaming\n+\tit.  Do not stream the modified parameter flag.\n+\t(ipa_read_node_info): Set uses_analysis_done to 1 instead of streaming\n+\tit.  Do not stream the modified parameter flag.\n+\t* ipa-cp.c (ipcp_analyze_node): Removed.\n+\t(ipcp_init_stage): Iterate only once over the nodes, analyze each one\n+\twith only a call to ipa_analyze_node.\n+\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): Analyze the\n+\tnode with only a call to ipa_analyze_node.\n+\t\n 2010-06-25  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* doc/invoke.texi (-Wsuggest-attribute): Add item for noreturn."}, {"sha": "78dccf85b04c954928d142064c39aa70d770e7a3", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=062c604fc558cd31410ffe0273ff0264fc4ee7c8", "patch": "@@ -177,18 +177,6 @@ ipcp_init_cloned_node (struct cgraph_node *orig_node,\n   IPA_NODE_REF (new_node)->ipcp_orig_node = orig_node;\n }\n \n-/* Perform intraprocedrual analysis needed for ipcp.  */\n-static void\n-ipcp_analyze_node (struct cgraph_node *node)\n-{\n-  /* Unreachable nodes should have been eliminated before ipcp.  */\n-  gcc_assert (node->needed || node->reachable);\n-\n-  node->local.versionable = tree_versionable_function_p (node->decl);\n-  ipa_initialize_node_params (node);\n-  ipa_detect_param_modifications (node);\n-}\n-\n /* Return scale for NODE.  */\n static inline gcov_type\n ipcp_get_node_scale (struct cgraph_node *node)\n@@ -611,23 +599,21 @@ ipcp_compute_node_scale (struct cgraph_node *node)\n /* Initialization and computation of IPCP data structures.  This is the initial\n    intraprocedural analysis of functions, which gathers information to be\n    propagated later on.  */\n+\n static void\n ipcp_init_stage (void)\n {\n   struct cgraph_node *node;\n \n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed)\n-      ipcp_analyze_node (node);\n-  for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      if (!node->analyzed)\n-\tcontinue;\n+      {\n+\t/* Unreachable nodes should have been eliminated before ipcp.  */\n+\tgcc_assert (node->needed || node->reachable);\n \n-      ipa_analyze_params_uses (node);\n-      /* building jump functions  */\n-      ipa_compute_jump_functions (node);\n-    }\n+\tnode->local.versionable = tree_versionable_function_p (node->decl);\n+\tipa_analyze_node (node);\n+      }\n }\n \n /* Return true if there are some formal parameters whose value is IPA_TOP (in"}, {"sha": "266d481950fb7790c3b115f889f82fe3f9431d71", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=062c604fc558cd31410ffe0273ff0264fc4ee7c8", "patch": "@@ -2011,12 +2011,8 @@ struct gimple_opt_pass pass_inline_parameters =\n static void\n inline_indirect_intraprocedural_analysis (struct cgraph_node *node)\n {\n-  ipa_initialize_node_params (node);\n-  ipa_detect_param_modifications (node);\n-  ipa_analyze_params_uses (node);\n-  ipa_compute_jump_functions (node);\n-\n-  if (dump_file)\n+  ipa_analyze_node (node);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       ipa_print_node_params (dump_file, node);\n       ipa_print_node_jump_functions (dump_file, node);"}, {"sha": "3fd284bff7ad5265e5ec67e966d4e0fdb8a154e0", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 168, "deletions": 135, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=062c604fc558cd31410ffe0273ff0264fc4ee7c8", "patch": "@@ -39,6 +39,16 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n #include \"lto-streamer.h\"\n \n+\n+/* Intermediate information about a parameter that is only useful during the\n+   run of ipa_analyze_node and is not kept afterwards.  */\n+\n+struct param_analysis_info\n+{\n+  bool modified;\n+  bitmap visited_statements;\n+};\n+\n /* Vector where the parameter infos are actually stored. */\n VEC (ipa_node_params_t, heap) *ipa_node_params_vector;\n /* Vector where the parameter infos are actually stored. */\n@@ -196,101 +206,10 @@ ipa_initialize_node_params (struct cgraph_node *node)\n     }\n }\n \n-/* Callback of walk_stmt_load_store_addr_ops for the visit_store and visit_addr\n-   parameters.  If OP is a parameter declaration, mark it as modified in the\n-   info structure passed in DATA.  */\n-\n-static bool\n-visit_store_addr_for_mod_analysis (gimple stmt ATTRIBUTE_UNUSED,\n-\t\t\t\t   tree op, void *data)\n-{\n-  struct ipa_node_params *info = (struct ipa_node_params *) data;\n-\n-  op = get_base_address (op);\n-  if (op\n-      && TREE_CODE (op) == PARM_DECL)\n-    {\n-      int index = ipa_get_param_decl_index (info, op);\n-      gcc_assert (index >= 0);\n-      info->params[index].modified = true;\n-      info->params[index].used = true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Callback of walk_stmt_load_store_addr_ops for the visit_load.\n-   If OP is a parameter declaration, mark it as used in the info structure\n-   passed in DATA.  */\n-\n-static bool\n-visit_load_for_mod_analysis (gimple stmt ATTRIBUTE_UNUSED,\n-\t\t\t     tree op, void *data)\n-{\n-  struct ipa_node_params *info = (struct ipa_node_params *) data;\n-\n-  op = get_base_address (op);\n-  if (op\n-      && TREE_CODE (op) == PARM_DECL)\n-    {\n-      int index = ipa_get_param_decl_index (info, op);\n-      gcc_assert (index >= 0);\n-      info->params[index].used = true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Compute which formal parameters of function associated with NODE are locally\n-   modified or their address is taken.  Note that this does not apply on\n-   parameters with SSA names but those can and should be analyzed\n-   differently.  */\n-\n-void\n-ipa_detect_param_modifications (struct cgraph_node *node)\n-{\n-  tree decl = node->decl;\n-  basic_block bb;\n-  struct function *func;\n-  gimple_stmt_iterator gsi;\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n-  int i;\n-\n-  if (ipa_get_param_count (info) == 0 || info->modification_analysis_done)\n-    return;\n-\n-  for (i = 0; i < ipa_get_param_count (info); i++)\n-    {\n-      tree parm = ipa_get_param (info, i);\n-      /* For SSA regs see if parameter is used.  For non-SSA we compute\n-\t the flag during modification analysis.  */\n-      if (is_gimple_reg (parm)\n-\t  && gimple_default_def (DECL_STRUCT_FUNCTION (node->decl), parm))\n-\tinfo->params[i].used = true;\n-    }\n-\n-  func = DECL_STRUCT_FUNCTION (decl);\n-  FOR_EACH_BB_FN (bb, func)\n-    {\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\twalk_stmt_load_store_addr_ops (gsi_stmt (gsi), info,\n-\t\t\t\t       visit_load_for_mod_analysis,\n-\t\t\t\t       visit_store_addr_for_mod_analysis,\n-\t\t\t\t       visit_store_addr_for_mod_analysis);\n-      for (gsi = gsi_start (phi_nodes (bb)); !gsi_end_p (gsi); gsi_next (&gsi))\n-\twalk_stmt_load_store_addr_ops (gsi_stmt (gsi), info,\n-\t\t\t\t       visit_load_for_mod_analysis,\n-\t\t\t\t       visit_store_addr_for_mod_analysis,\n-\t\t\t\t       visit_store_addr_for_mod_analysis);\n-    }\n-\n-  info->modification_analysis_done = 1;\n-}\n-\n /* Count number of arguments callsite CS has and store it in\n    ipa_edge_args structure corresponding to this callsite.  */\n \n-void\n+static void\n ipa_count_arguments (struct cgraph_edge *cs)\n {\n   gimple stmt;\n@@ -707,14 +626,53 @@ type_like_member_ptr_p (tree type, tree *method_ptr, tree *delta)\n   return true;\n }\n \n+/* Callback of walk_aliased_vdefs.  Flags that it has been invoked to the\n+   boolean variable pointed to by DATA.  */\n+\n+static bool\n+mark_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n+\t\t     void *data)\n+{\n+  bool *b = (bool *) data;\n+  *b = true;\n+  return true;\n+}\n+\n+/* Return true if the formal parameter PARM might have been modified in this\n+   function before reaching the statement CALL.  PARM_INFO is a pointer to a\n+   structure containing intermediate information about PARM.  */\n+\n+static bool\n+is_parm_modified_before_call (struct param_analysis_info *parm_info,\n+\t\t\t      gimple call, tree parm)\n+{\n+  bool modified = false;\n+  ao_ref refd;\n+\n+  if (parm_info->modified)\n+    return true;\n+\n+  ao_ref_init (&refd, parm);\n+  walk_aliased_vdefs (&refd, gimple_vuse (call), mark_modified,\n+\t\t      &modified, &parm_info->visited_statements);\n+  if (modified)\n+    {\n+      parm_info->modified = true;\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Go through arguments of the CALL and for every one that looks like a member\n    pointer, check whether it can be safely declared pass-through and if so,\n    mark that to the corresponding item of jump FUNCTIONS.  Return true iff\n    there are non-pass-through member pointers within the arguments.  INFO\n-   describes formal parameters of the caller.  */\n+   describes formal parameters of the caller.  PARMS_INFO is a pointer to a\n+   vector containing intermediate information about each formal parameter.  */\n \n static bool\n compute_pass_through_member_ptrs (struct ipa_node_params *info,\n+\t\t\t\t  struct param_analysis_info *parms_info,\n \t\t\t\t  struct ipa_jump_func *functions,\n \t\t\t\t  gimple call)\n {\n@@ -733,7 +691,7 @@ compute_pass_through_member_ptrs (struct ipa_node_params *info,\n \t      int index = ipa_get_param_decl_index (info, arg);\n \n \t      gcc_assert (index >=0);\n-\t      if (!ipa_is_param_modified (info, index))\n+\t      if (!is_parm_modified_before_call (&parms_info[index], call, arg))\n \t\t{\n \t\t  functions[num].type = IPA_JF_PASS_THROUGH;\n \t\t  functions[num].value.pass_through.formal_id = index;\n@@ -886,7 +844,8 @@ compute_cst_member_ptr_arguments (struct ipa_jump_func *functions,\n    to this callsite.  */\n \n static void\n-ipa_compute_jump_functions_for_edge (struct cgraph_edge *cs)\n+ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_info,\n+\t\t\t\t     struct cgraph_edge *cs)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (cs->caller);\n   struct ipa_edge_args *arguments = IPA_EDGE_REF (cs);\n@@ -905,7 +864,8 @@ ipa_compute_jump_functions_for_edge (struct cgraph_edge *cs)\n \n   /* Let's check whether there are any potential member pointers and if so,\n      whether we can determine their functions as pass_through.  */\n-  if (!compute_pass_through_member_ptrs (info, arguments->jump_functions, call))\n+  if (!compute_pass_through_member_ptrs (info, parms_info,\n+\t\t\t\t\t arguments->jump_functions, call))\n     return;\n \n   /* Finally, let's check whether we actually pass a new constant member\n@@ -916,8 +876,9 @@ ipa_compute_jump_functions_for_edge (struct cgraph_edge *cs)\n /* Compute jump functions for all edges - both direct and indirect - outgoing\n    from NODE.  Also count the actual arguments in the process.  */\n \n-void\n-ipa_compute_jump_functions (struct cgraph_node *node)\n+static void\n+ipa_compute_jump_functions (struct cgraph_node *node,\n+\t\t\t    struct param_analysis_info *parms_info)\n {\n   struct cgraph_edge *cs;\n \n@@ -928,16 +889,20 @@ ipa_compute_jump_functions (struct cgraph_node *node)\n       if (!cs->callee->analyzed && !flag_lto && !flag_whopr)\n \tcontinue;\n       ipa_count_arguments (cs);\n+      /* If the descriptor of the callee is not initialized yet, we have to do\n+\t it now. */\n+      if (cs->callee->analyzed)\n+\tipa_initialize_node_params (cs->callee);\n       if (ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n \t  != ipa_get_param_count (IPA_NODE_REF (cs->callee)))\n \tipa_set_called_with_variable_arg (IPA_NODE_REF (cs->callee));\n-      ipa_compute_jump_functions_for_edge (cs);\n+      ipa_compute_jump_functions_for_edge (parms_info, cs);\n     }\n \n   for (cs = node->indirect_calls; cs; cs = cs->next_callee)\n     {\n       ipa_count_arguments (cs);\n-      ipa_compute_jump_functions_for_edge (cs);\n+      ipa_compute_jump_functions_for_edge (parms_info, cs);\n     }\n }\n \n@@ -1021,13 +986,15 @@ ipa_note_param_call (struct cgraph_node *node, int param_index, gimple stmt,\n }\n \n /* Analyze the CALL and examine uses of formal parameters of the caller NODE\n-   (described by INFO).  Currently it checks whether the call calls a pointer\n-   that is a formal parameter and if so, the parameter is marked with the\n-   called flag and an indirect call graph edge describing the call is created.\n-   This is very simple for ordinary pointers represented in SSA but not-so-nice\n-   when it comes to member pointers.  The ugly part of this function does\n-   nothing more than trying to match the pattern of such a call.  An example of\n-   such a pattern is the gimple dump below, the call is on the last line:\n+   (described by INFO).  PARMS_INFO is a pointer to a vector containing\n+   intermediate information about each formal parameter.  Currently it checks\n+   whether the call calls a pointer that is a formal parameter and if so, the\n+   parameter is marked with the called flag and an indirect call graph edge\n+   describing the call is created.  This is very simple for ordinary pointers\n+   represented in SSA but not-so-nice when it comes to member pointers.  The\n+   ugly part of this function does nothing more than trying to match the\n+   pattern of such a call.  An example of such a pattern is the gimple dump\n+   below, the call is on the last line:\n \n      <bb 2>:\n        f$__delta_5 = f.__delta;\n@@ -1073,6 +1040,7 @@ ipa_note_param_call (struct cgraph_node *node, int param_index, gimple stmt,\n static void\n ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n \t\t\t\tstruct ipa_node_params *info,\n+\t\t\t\tstruct param_analysis_info *parms_info,\n \t\t\t\tgimple call, tree target)\n {\n   gimple def;\n@@ -1184,7 +1152,8 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n     return;\n \n   index = ipa_get_param_decl_index (info, rec);\n-  if (index >= 0 && !ipa_is_param_modified (info, index))\n+  if (index >= 0 && !is_parm_modified_before_call (&parms_info[index],\n+\t\t\t\t\t\t   call, rec))\n     ipa_note_param_call (node, index, call, false);\n \n   return;\n@@ -1227,62 +1196,139 @@ ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n }\n \n /* Analyze a call statement CALL whether and how it utilizes formal parameters\n-   of the caller (described by INFO). */\n+   of the caller (described by INFO).  PARMS_INFO is a pointer to a vector\n+   containing intermediate information about each formal parameter.  */\n \n static void\n ipa_analyze_call_uses (struct cgraph_node *node,\n-\t\t       struct ipa_node_params *info, gimple call)\n+\t\t       struct ipa_node_params *info,\n+\t\t       struct param_analysis_info *parms_info, gimple call)\n {\n   tree target = gimple_call_fn (call);\n \n   if (TREE_CODE (target) == SSA_NAME)\n-    ipa_analyze_indirect_call_uses (node, info, call, target);\n+    ipa_analyze_indirect_call_uses (node, info, parms_info, call, target);\n   else if (TREE_CODE (target) == OBJ_TYPE_REF)\n     ipa_analyze_virtual_call_uses (node, info, call, target);\n }\n \n \n /* Analyze the call statement STMT with respect to formal parameters (described\n    in INFO) of caller given by NODE.  Currently it only checks whether formal\n-   parameters are called.  */\n+   parameters are called.  PARMS_INFO is a pointer to a vector containing\n+   intermediate information about each formal parameter.  */\n \n static void\n ipa_analyze_stmt_uses (struct cgraph_node *node, struct ipa_node_params *info,\n-\t\t       gimple stmt)\n+\t\t       struct param_analysis_info *parms_info, gimple stmt)\n {\n   if (is_gimple_call (stmt))\n-    ipa_analyze_call_uses (node, info, stmt);\n+    ipa_analyze_call_uses (node, info, parms_info, stmt);\n+}\n+\n+/* Callback of walk_stmt_load_store_addr_ops for the visit_load.\n+   If OP is a parameter declaration, mark it as used in the info structure\n+   passed in DATA.  */\n+\n+static bool\n+visit_ref_for_mod_analysis (gimple stmt ATTRIBUTE_UNUSED,\n+\t\t\t     tree op, void *data)\n+{\n+  struct ipa_node_params *info = (struct ipa_node_params *) data;\n+\n+  op = get_base_address (op);\n+  if (op\n+      && TREE_CODE (op) == PARM_DECL)\n+    {\n+      int index = ipa_get_param_decl_index (info, op);\n+      gcc_assert (index >= 0);\n+      info->params[index].used = true;\n+    }\n+\n+  return false;\n }\n \n /* Scan the function body of NODE and inspect the uses of formal parameters.\n    Store the findings in various structures of the associated ipa_node_params\n-   structure, such as parameter flags, notes etc.  */\n+   structure, such as parameter flags, notes etc.  PARMS_INFO is a pointer to a\n+   vector containing intermediate information about each formal parameter.   */\n \n-void\n-ipa_analyze_params_uses (struct cgraph_node *node)\n+static void\n+ipa_analyze_params_uses (struct cgraph_node *node,\n+\t\t\t struct param_analysis_info *parms_info)\n {\n   tree decl = node->decl;\n   basic_block bb;\n   struct function *func;\n   gimple_stmt_iterator gsi;\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n+  int i;\n \n   if (ipa_get_param_count (info) == 0 || info->uses_analysis_done)\n     return;\n \n+  for (i = 0; i < ipa_get_param_count (info); i++)\n+    {\n+      tree parm = ipa_get_param (info, i);\n+      /* For SSA regs see if parameter is used.  For non-SSA we compute\n+\t the flag during modification analysis.  */\n+      if (is_gimple_reg (parm)\n+\t  && gimple_default_def (DECL_STRUCT_FUNCTION (node->decl), parm))\n+\tinfo->params[i].used = true;\n+    }\n+\n   func = DECL_STRUCT_FUNCTION (decl);\n   FOR_EACH_BB_FN (bb, func)\n     {\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n-\t  ipa_analyze_stmt_uses (node, info, stmt);\n+\n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n+\n+\t  ipa_analyze_stmt_uses (node, info, parms_info, stmt);\n+\t  walk_stmt_load_store_addr_ops (stmt, info,\n+\t\t\t\t\t visit_ref_for_mod_analysis,\n+\t\t\t\t\t visit_ref_for_mod_analysis,\n+\t\t\t\t\t visit_ref_for_mod_analysis);\n \t}\n+      for (gsi = gsi_start (phi_nodes (bb)); !gsi_end_p (gsi); gsi_next (&gsi))\n+\twalk_stmt_load_store_addr_ops (gsi_stmt (gsi), info,\n+\t\t\t\t       visit_ref_for_mod_analysis,\n+\t\t\t\t       visit_ref_for_mod_analysis,\n+\t\t\t\t       visit_ref_for_mod_analysis);\n     }\n \n   info->uses_analysis_done = 1;\n }\n \n+/* Initialize the array describing properties of of formal parameters of NODE,\n+   analyze their uses and and compute jump functions associated witu actual\n+   arguments of calls from within NODE.  */\n+\n+void\n+ipa_analyze_node (struct cgraph_node *node)\n+{\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  struct param_analysis_info *parms_info;\n+  int i, param_count;\n+\n+  ipa_initialize_node_params (node);\n+\n+  param_count = ipa_get_param_count (info);\n+  parms_info = XALLOCAVEC (struct param_analysis_info, param_count);\n+  memset (parms_info, 0, sizeof (struct param_analysis_info) * param_count);\n+\n+  ipa_analyze_params_uses (node, parms_info);\n+  ipa_compute_jump_functions (node, parms_info);\n+\n+  for (i = 0; i < param_count; i++)\n+    if (parms_info[i].visited_statements)\n+      BITMAP_FREE (parms_info[i].visited_statements);\n+}\n+\n+\n /* Update the jump function DST when the call graph edge correspondng to SRC is\n    is being inlined, knowing that DST is of type ancestor and src of known\n    type.  */\n@@ -1854,8 +1900,6 @@ ipa_print_node_params (FILE * f, struct cgraph_node *node)\n                  (DECL_NAME (temp)\n                   ? (*lang_hooks.decl_printable_name) (temp, 2)\n                   : \"(unnamed)\"));\n-      if (ipa_is_param_modified (info, i))\n-\tfprintf (f, \" modified\");\n       if (ipa_is_param_used (info, i))\n \tfprintf (f, \" used\");\n       fprintf (f, \"\\n\");\n@@ -2464,16 +2508,12 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n \n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, info->called_with_var_arguments, 1);\n-  bp_pack_value (&bp, info->uses_analysis_done, 1);\n-  gcc_assert (info->modification_analysis_done\n+  gcc_assert (info->uses_analysis_done\n \t      || ipa_get_param_count (info) == 0);\n   gcc_assert (!info->node_enqueued);\n   gcc_assert (!info->ipcp_orig_node);\n   for (j = 0; j < ipa_get_param_count (info); j++)\n-    {\n-      bp_pack_value (&bp, info->params[j].modified, 1);\n-      bp_pack_value (&bp, info->params[j].used, 1);\n-    }\n+    bp_pack_value (&bp, info->params[j].used, 1);\n   lto_output_bitpack (&bp);\n   for (e = node->callees; e; e = e->next_callee)\n     {\n@@ -2503,18 +2543,11 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n \n   bp = lto_input_bitpack (ib);\n   info->called_with_var_arguments = bp_unpack_value (&bp, 1);\n-  info->uses_analysis_done = bp_unpack_value (&bp, 1);\n   if (ipa_get_param_count (info) != 0)\n-    {\n-      info->modification_analysis_done = true;\n-      info->uses_analysis_done = true;\n-    }\n+    info->uses_analysis_done = true;\n   info->node_enqueued = false;\n   for (k = 0; k < ipa_get_param_count (info); k++)\n-    {\n-      info->params[k].modified = bp_unpack_value (&bp, 1);\n-      info->params[k].used = bp_unpack_value (&bp, 1);\n-    }\n+    info->params[k].used = bp_unpack_value (&bp, 1);\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);"}, {"sha": "c73367a49455b9eb4d777af3714c0734de4bade0", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=062c604fc558cd31410ffe0273ff0264fc4ee7c8", "patch": "@@ -161,8 +161,6 @@ struct ipa_param_descriptor\n   struct ipcp_lattice ipcp_lattice;\n   /* PARAM_DECL of this parameter.  */\n   tree decl;\n-  /* Whether the value parameter has been modified within the function.  */\n-  unsigned modified : 1;\n   /* The parameter is used.  */\n   unsigned used : 1;\n };\n@@ -179,8 +177,6 @@ struct ipa_node_params\n   /* Whether this function is called with variable number of actual\n      arguments.  */\n   unsigned called_with_var_arguments : 1;\n-  /* Whether the modification analysis has already been performed. */\n-  unsigned modification_analysis_done : 1;\n   /* Whether the param uses analysis has already been performed.  */\n   unsigned uses_analysis_done : 1;\n   /* Whether the function is enqueued in an ipa_func_list.  */\n@@ -228,17 +224,6 @@ ipa_get_param (struct ipa_node_params *info, int i)\n   return info->params[i].decl;\n }\n \n-/* Return the modification flag corresponding to the Ith formal parameter of\n-   the function associated with INFO.  Note that there is no setter method as\n-   the goal is to set all flags when building the array in\n-   ipa_detect_param_modifications.  */\n-\n-static inline bool\n-ipa_is_param_modified (struct ipa_node_params *info, int i)\n-{\n-  return info->params[i].modified;\n-}\n-\n /* Return the used flag corresponding to the Ith formal parameter of\n    the function associated with INFO.  */\n \n@@ -412,14 +397,10 @@ ipa_push_func_to_list (struct ipa_func_list **wl, struct cgraph_node *node)\n     ipa_push_func_to_list_1 (wl, node, info);\n }\n \n-/* Callsite related calculations.  */\n-void ipa_compute_jump_functions (struct cgraph_node *);\n-void ipa_count_arguments (struct cgraph_edge *);\n+void ipa_analyze_node (struct cgraph_node *);\n \n /* Function formal parameters related computations.  */\n void ipa_initialize_node_params (struct cgraph_node *node);\n-void ipa_detect_param_modifications (struct cgraph_node *);\n-void ipa_analyze_params_uses (struct cgraph_node *);\n bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \t\t\t\t\tVEC (cgraph_edge_p, heap) **new_edges);\n "}, {"sha": "d0e19bc2801c8ff11df50e319c956af40774f089", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=062c604fc558cd31410ffe0273ff0264fc4ee7c8", "patch": "@@ -1,3 +1,8 @@\n+2010-06-25  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* g++.dg/ipa/iinline-3.C: New test.\n+\t* gcc.dg/ipa/modif-1.c: Removed.\n+\n 2010-06-25  Jan Hubicka  <jh@suse.cz>\n \n \t* testsuite/gcc.dg/tree-ssa/ipa-split-1.c"}, {"sha": "3daee9a868161a5ed81d4a841bafb51fc77f5d9d", "filename": "gcc/testsuite/g++.dg/ipa/iinline-3.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fiinline-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062c604fc558cd31410ffe0273ff0264fc4ee7c8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fiinline-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fiinline-3.C?ref=062c604fc558cd31410ffe0273ff0264fc4ee7c8", "patch": "@@ -0,0 +1,64 @@\n+/* Verify that we do not indirect-inline using member pointer\n+   parameters which have been modified.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-early-inlining\"  } */\n+/* { dg-add-options bind_pic_locally } */\n+\n+extern \"C\" void abort (void);\n+\n+class String\n+{\n+private:\n+  const char *data;\n+\n+public:\n+  String (const char *d) : data(d)\n+  {}\n+\n+  int funcOne (int stuff) const;\n+  int funcTwo (int stuff) const;\n+};\n+\n+\n+int String::funcOne (int stuff) const\n+{\n+  return stuff + 1;\n+}\n+\n+int String::funcTwo (int stuff) const\n+{\n+  return stuff + 100;\n+}\n+\n+int (String::* gmp)(int stuff) const = &String::funcTwo;\n+\n+int docalling_1 (int (String::* f)(int stuff) const)\n+{\n+  String S (\"muhehehe\");\n+\n+  return (S.*f)(4);\n+}\n+\n+int docalling (int a, int (String::* f)(int stuff) const)\n+{\n+  if (a < 200)\n+    f = gmp;\n+\n+  return docalling_1 (f);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input (void)\n+{\n+  return 1;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  int i = 0;\n+  while (i < 10)\n+    i += docalling (get_input (), &String::funcOne);\n+\n+  if (i != 104)\n+    abort();\n+  return 0;\n+}"}, {"sha": "db6915a9d9e9e1b48e7059c08f04bcfc47e46e20", "filename": "gcc/testsuite/gcc.dg/ipa/modif-1.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/212580ffb8305e6da025fd873f1732879b835de1/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodif-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/212580ffb8305e6da025fd873f1732879b835de1/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodif-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fmodif-1.c?ref=212580ffb8305e6da025fd873f1732879b835de1", "patch": "@@ -1,41 +0,0 @@\n-/* Verify that modification analysis detects modfications.  */\n-/* { dg-do compile } */\n-/* { dg-options \"-O3 -c -fdump-ipa-inline-details -fno-early-inlining\"  } */\n-\n-struct whatever\n-{\n-  int first;\n-  unsigned second;\n-};\n-\n-void func1 (struct whatever w);\n-void func2 (struct whatever *pw);\n-void func3 (int i);\n-void func4 (int *pi);\n-\n-void the_test (struct whatever u, struct whatever v,\n-\t       struct whatever w, struct whatever x,\n-\t       int i, int k, int l)\n-{\n-  struct whatever *pw = &w;\n-  int *pk = &k;\n-\n-  v.first = 9;\n-\n-  func1 (u);\n-  func1 (v);\n-  func2 (pw);\n-  func2 (&x);\n-  func3 (i);\n-  func4 (pk);\n-  func4 (&l);\n-}\n-\n-/* { dg-final { scan-ipa-dump-not \"param 0\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { scan-ipa-dump \"param 1\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { scan-ipa-dump \"param 2\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { scan-ipa-dump \"param 3\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { scan-ipa-dump-not \"param 4\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { scan-ipa-dump \"param 5\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { scan-ipa-dump \"param 6\\[^\\\\n\\]*modified\" \"inline\" } } */\n-/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}]}