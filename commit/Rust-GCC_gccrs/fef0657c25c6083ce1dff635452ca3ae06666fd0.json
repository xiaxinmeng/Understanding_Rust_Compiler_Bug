{"sha": "fef0657c25c6083ce1dff635452ca3ae06666fd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVmMDY1N2MyNWM2MDgzY2UxZGZmNjM1NDUyY2EzYWUwNjY2NmZkMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-04-13T04:29:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-04-13T04:29:40Z"}, "message": "Makefile.in (OBJS-common): Add tree-ssa-uncprop.o.\n\n\n\t* Makefile.in (OBJS-common): Add tree-ssa-uncprop.o.\n\t(tree-ssa-uncprop.o): Add dependencies.\n\t* tree-cfg.c (remove_useless_stmts_bb, remove_useless_stmts): Remove.\n\t* tree-flow.h (remove_useless_stmts): Remove prototype.\n\t* tree-outof-ssa.c (rewrite_out_of_ssa): Remove call to\n\tremove_useless_stmts.\n\t* timevar.def (TV_TREE_SSA_UNCPROP): New timevar.\n\t* tree-optimize.c (init_tree_optimization_passes): Add uncprop pass.\n\t* tree-pass.h (pass_uncprop): Declare.\n\t* tree-ssa-uncprop.c: New file.\n\nFrom-SVN: r98066", "tree": {"sha": "6045fae43be21a314688da828dfd1010938a5ab4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6045fae43be21a314688da828dfd1010938a5ab4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fef0657c25c6083ce1dff635452ca3ae06666fd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef0657c25c6083ce1dff635452ca3ae06666fd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fef0657c25c6083ce1dff635452ca3ae06666fd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef0657c25c6083ce1dff635452ca3ae06666fd0/comments", "author": null, "committer": null, "parents": [{"sha": "6dab073ba797a0afd4e6692931f3a33bff814aff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dab073ba797a0afd4e6692931f3a33bff814aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dab073ba797a0afd4e6692931f3a33bff814aff"}], "stats": {"total": 763, "additions": 636, "deletions": 127}, "files": [{"sha": "86e3f9703bc419aaf0c80121ef652a30a0d90147", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fef0657c25c6083ce1dff635452ca3ae06666fd0", "patch": "@@ -1,3 +1,16 @@\n+2005-04-12  Jeff Law  <law@redhat.com>\n+\n+\t* Makefile.in (OBJS-common): Add tree-ssa-uncprop.o.\n+\t(tree-ssa-uncprop.o): Add dependencies.\n+\t* tree-cfg.c (remove_useless_stmts_bb, remove_useless_stmts): Remove.\n+\t* tree-flow.h (remove_useless_stmts): Remove prototype.\n+\t* tree-outof-ssa.c (rewrite_out_of_ssa): Remove call to\n+\tremove_useless_stmts.\n+\t* timevar.def (TV_TREE_SSA_UNCPROP): New timevar.\n+\t* tree-optimize.c (init_tree_optimization_passes): Add uncprop pass.\n+\t* tree-pass.h (pass_uncprop): Declare.\n+\t* tree-ssa-uncprop.c: New file.\n+\n 2005-04-12  James E. Wilson  <wilson@specifixinc.com>\n \n \tPR target/20670"}, {"sha": "b720a37cc249d377576cb2da821f65bccd0fff1c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fef0657c25c6083ce1dff635452ca3ae06666fd0", "patch": "@@ -924,7 +924,7 @@ OBJS-common = \\\n  tree-chrec.o tree-scalar-evolution.o tree-data-ref.o\t\t\t   \\\n  tree-cfg.o tree-dfa.o tree-eh.o tree-ssa.o tree-optimize.o tree-gimple.o  \\\n  gimplify.o tree-pretty-print.o tree-into-ssa.o          \\\n- tree-outof-ssa.o tree-ssa-ccp.o tree-vn.o             \\\n+ tree-outof-ssa.o tree-ssa-ccp.o tree-vn.o tree-ssa-uncprop.o\t\t   \\\n  tree-ssa-dce.o  tree-ssa-copy.o tree-nrv.o tree-ssa-copyrename.o  \\\n  tree-ssa-pre.o tree-ssa-live.o tree-ssa-operands.o tree-ssa-alias.o       \\\n  tree-ssa-phiopt.o tree-ssa-forwprop.o tree-nested.o tree-ssa-dse.o\t   \\\n@@ -1666,6 +1666,11 @@ tree-ssa-dom.o : tree-ssa-dom.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    $(BASIC_BLOCK_H) domwalk.h real.h tree-pass.h $(FLAGS_H) langhooks.h \\\n    tree-ssa-propagate.h cfgloop.h\n+tree-ssa-uncprop.o : tree-ssa-uncprop.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h diagnostic.h \\\n+   errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   $(BASIC_BLOCK_H) domwalk.h real.h tree-pass.h $(FLAGS_H) langhooks.h \\\n+   tree-ssa-propagate.h cfgloop.h\n tree-ssa-threadupdate.o : tree-ssa-threadupdate.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n    diagnostic.h errors.h function.h $(TM_H) coretypes.h $(TREE_DUMP_H) \\"}, {"sha": "a90afea394096297c9b91b535d58f585d10bf001", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=fef0657c25c6083ce1dff635452ca3ae06666fd0", "patch": "@@ -103,6 +103,7 @@ DEFTIMEVAR (TV_TREE_LOOP_IVOPTS\t     , \"tree iv optimization\")\n DEFTIMEVAR (TV_TREE_LOOP_INIT\t     , \"tree loop init\")\n DEFTIMEVAR (TV_TREE_LOOP_FINI\t     , \"tree loop fini\")\n DEFTIMEVAR (TV_TREE_CH\t\t     , \"tree copy headers\")\n+DEFTIMEVAR (TV_TREE_SSA_UNCPROP\t     , \"tree SSA uncprop\")\n DEFTIMEVAR (TV_TREE_SSA_TO_NORMAL    , \"tree SSA to normal\")\n DEFTIMEVAR (TV_TREE_NRV\t\t     , \"tree NRV optimization\")\n DEFTIMEVAR (TV_TREE_COPY_RENAME\t     , \"tree rename SSA copies\")"}, {"sha": "a80285b131f8fa863379599cec0e267f337f2c71", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=fef0657c25c6083ce1dff635452ca3ae06666fd0", "patch": "@@ -1896,127 +1896,6 @@ struct tree_opt_pass pass_remove_useless_stmts =\n   0\t\t\t\t\t/* letter */\n };\n \n-\n-/* Remove obviously useless statements in basic block BB.  */\n-\n-static void\n-cfg_remove_useless_stmts_bb (basic_block bb)\n-{\n-  block_stmt_iterator bsi;\n-  tree stmt = NULL_TREE;\n-  tree cond, var = NULL_TREE, val = NULL_TREE;\n-  struct var_ann_d *ann;\n-\n-  /* Check whether we come here from a condition, and if so, get the\n-     condition.  */\n-  if (!single_pred_p (bb)\n-      || !(single_pred_edge (bb)->flags\n-\t   & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n-    return;\n-\n-  cond = COND_EXPR_COND (last_stmt (single_pred (bb)));\n-\n-  if (TREE_CODE (cond) == VAR_DECL || TREE_CODE (cond) == PARM_DECL)\n-    {\n-      var = cond;\n-      val = (single_pred_edge (bb)->flags & EDGE_FALSE_VALUE\n-\t     ? boolean_false_node : boolean_true_node);\n-    }\n-  else if (TREE_CODE (cond) == TRUTH_NOT_EXPR\n-\t   && (TREE_CODE (TREE_OPERAND (cond, 0)) == VAR_DECL\n-\t       || TREE_CODE (TREE_OPERAND (cond, 0)) == PARM_DECL))\n-    {\n-      var = TREE_OPERAND (cond, 0);\n-      val = (single_pred_edge (bb)->flags & EDGE_FALSE_VALUE\n-\t     ? boolean_true_node : boolean_false_node);\n-    }\n-  else\n-    {\n-      if (single_pred_edge (bb)->flags & EDGE_FALSE_VALUE)\n-\tcond = invert_truthvalue (cond);\n-      if (TREE_CODE (cond) == EQ_EXPR\n-\t  && (TREE_CODE (TREE_OPERAND (cond, 0)) == VAR_DECL\n-\t      || TREE_CODE (TREE_OPERAND (cond, 0)) == PARM_DECL)\n-\t  && (TREE_CODE (TREE_OPERAND (cond, 1)) == VAR_DECL\n-\t      || TREE_CODE (TREE_OPERAND (cond, 1)) == PARM_DECL\n-\t      || TREE_CONSTANT (TREE_OPERAND (cond, 1))))\n-\t{\n-\t  var = TREE_OPERAND (cond, 0);\n-\t  val = TREE_OPERAND (cond, 1);\n-\t}\n-      else\n-\treturn;\n-    }\n-\n-  /* Only work for normal local variables.  */\n-  ann = var_ann (var);\n-  if (!ann\n-      || ann->may_aliases\n-      || TREE_ADDRESSABLE (var))\n-    return;\n-\n-  if (! TREE_CONSTANT (val))\n-    {\n-      ann = var_ann (val);\n-      if (!ann\n-\t  || ann->may_aliases\n-\t  || TREE_ADDRESSABLE (val))\n-\treturn;\n-    }\n-\n-  /* Ignore floating point variables, since comparison behaves weird for\n-     them.  */\n-  if (FLOAT_TYPE_P (TREE_TYPE (var)))\n-    return;\n-\n-  for (bsi = bsi_start (bb); !bsi_end_p (bsi);)\n-    {\n-      stmt = bsi_stmt (bsi);\n-\n-      /* If the THEN/ELSE clause merely assigns a value to a variable/parameter\n-\t which is already known to contain that value, then remove the useless\n-\t THEN/ELSE clause.  */\n-      if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t  && TREE_OPERAND (stmt, 0) == var\n-\t  && operand_equal_p (val, TREE_OPERAND (stmt, 1), 0))\n-\t{\n-\t  bsi_remove (&bsi);\n-\t  continue;\n-\t}\n-\n-      /* Invalidate the var if we encounter something that could modify it.\n-\t Likewise for the value it was previously set to.  Note that we only\n-\t consider values that are either a VAR_DECL or PARM_DECL so we\n-\t can test for conflict very simply.  */\n-      if (TREE_CODE (stmt) == ASM_EXPR\n-\t  || (TREE_CODE (stmt) == MODIFY_EXPR\n-\t      && (TREE_OPERAND (stmt, 0) == var\n-\t\t  || TREE_OPERAND (stmt, 0) == val)))\n-\treturn;\n-  \n-      bsi_next (&bsi);\n-    }\n-}\n-\n-\n-/* A CFG-aware version of remove_useless_stmts.  */\n-\n-void\n-cfg_remove_useless_stmts (void)\n-{\n-  basic_block bb;\n-\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      cfg_remove_useless_stmts_bb (bb);\n-    }\n-}\n-\n-\n /* Remove PHI nodes associated with basic block BB and all edges out of BB.  */\n \n static void"}, {"sha": "8cdadd11947616ad04f4ff28e3fc1dc12e763f0c", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=fef0657c25c6083ce1dff635452ca3ae06666fd0", "patch": "@@ -522,7 +522,6 @@ extern tree last_stmt (basic_block);\n extern tree *last_stmt_ptr (basic_block);\n extern tree last_and_only_stmt (basic_block);\n extern edge find_taken_edge (basic_block, tree);\n-extern void cfg_remove_useless_stmts (void);\n extern basic_block label_to_block_fn (struct function *, tree);\n #define label_to_block(t) (label_to_block_fn (cfun, t))\n extern void bsi_insert_on_edge (edge, tree);"}, {"sha": "4d172c292d646ad206209926351c7b722e7132ca", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=fef0657c25c6083ce1dff635452ca3ae06666fd0", "patch": "@@ -407,6 +407,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_phiopt);\n   NEXT_PASS (pass_tail_calls);\n   NEXT_PASS (pass_rename_ssa_copies);\n+  NEXT_PASS (pass_uncprop);\n   NEXT_PASS (pass_del_ssa);\n   NEXT_PASS (pass_nrv);\n   NEXT_PASS (pass_remove_useless_vars);"}, {"sha": "4663abbdeac08e89d4da571848869482bec5250b", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=fef0657c25c6083ce1dff635452ca3ae06666fd0", "patch": "@@ -2508,10 +2508,6 @@ rewrite_out_of_ssa (void)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_tree_cfg (dump_file, dump_flags & ~TDF_DETAILS);\n \n-  /* Do some cleanups which reduce the amount of data the\n-     tree->rtl expanders deal with.  */\n-  cfg_remove_useless_stmts ();\n-\n   /* Flush out flow graph and SSA data.  */\n   delete_var_map (map);\n "}, {"sha": "ac1ab92088783cf9a82543fb5074a0760b1fbcd9", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=fef0657c25c6083ce1dff635452ca3ae06666fd0", "patch": "@@ -212,5 +212,6 @@ extern struct tree_opt_pass pass_store_ccp;\n extern struct tree_opt_pass pass_store_copy_prop;\n extern struct tree_opt_pass pass_vrp;\n extern struct tree_opt_pass pass_create_structure_vars;\n+extern struct tree_opt_pass pass_uncprop;\n \n #endif /* GCC_TREE_PASS_H */"}, {"sha": "4400ee7800379d5745d65b4ff5f8d20332dab62d", "filename": "gcc/tree-ssa-uncprop.c", "status": "added", "additions": 614, "deletions": 0, "changes": 614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef0657c25c6083ce1dff635452ca3ae06666fd0/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=fef0657c25c6083ce1dff635452ca3ae06666fd0", "patch": "@@ -0,0 +1,614 @@\n+/* Routines for discovering and unpropagating edge equivalences.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"ggc.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"errors.h\"\n+#include \"expr.h\"\n+#include \"function.h\"\n+#include \"diagnostic.h\"\n+#include \"timevar.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-flow.h\"\n+#include \"domwalk.h\"\n+#include \"real.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"langhooks.h\"\n+\n+/* The basic structure describing an equivalency created by traversing\n+   an edge.  Traversing the edge effectively means that we can assume\n+   that we've seen an assignment LHS = RHS.  */\n+struct edge_equivalency\n+{\n+  tree rhs;\n+  tree lhs;\n+};\n+\n+/* This routine finds and records edge equivalences for every edge\n+   in the CFG.\n+\n+   When complete, each edge that creates an equivalency will have an\n+   EDGE_EQUIVALENCY structure hanging off the edge's AUX field. \n+   The caller is responsible for freeing the AUX fields.  */\n+\n+static void\n+associate_equivalences_with_edges (void)\n+{\n+  basic_block bb;\n+\n+  /* Walk over each block.  If the block ends with a control statement,\n+     then it might create a useful equivalence.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator bsi = bsi_last (bb);\n+      tree stmt;\n+\n+      /* If the block does not end with a COND_EXPR or SWITCH_EXPR\n+\t then there is nothing to do.  */\n+      if (bsi_end_p (bsi))\n+\tcontinue;\n+\n+      stmt = bsi_stmt (bsi);\n+\n+      if (!stmt)\n+\tcontinue;\n+\n+      /* A COND_EXPR may create an equivalency in a variety of different\n+\t ways.  */\n+      if (TREE_CODE (stmt) == COND_EXPR)\n+\t{\n+\t  tree cond = COND_EXPR_COND (stmt);\n+\t  edge true_edge;\n+\t  edge false_edge;\n+\t  struct edge_equivalency *equivalency;\n+\n+\t  extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n+\n+\t  /* If the conditional is a single variable 'X', record 'X = 1'\n+\t     for the true edge and 'X = 0' on the false edge.  */\n+\t  if (TREE_CODE (cond) == SSA_NAME)\n+\t    {\n+\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t      equivalency->rhs = constant_boolean_node (1, TREE_TYPE (cond));\n+\t      equivalency->lhs = cond;\n+\t      true_edge->aux = equivalency;\n+\n+\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t      equivalency->rhs = constant_boolean_node (0, TREE_TYPE (cond));\n+\t      equivalency->lhs = cond;\n+\t      false_edge->aux = equivalency;\n+\t    }\n+\t  /* Equality tests may create one or two equivalences.  */\n+\t  else if (TREE_CODE (cond) == EQ_EXPR || TREE_CODE (cond) == NE_EXPR)\n+\t    {\n+\t      tree op0 = TREE_OPERAND (cond, 0);\n+\t      tree op1 = TREE_OPERAND (cond, 1);\n+\n+\t      /* Special case comparing booleans against a constant as we\n+\t\t know the value of OP0 on both arms of the branch.  i.e., we\n+\t\t can record an equivalence for OP0 rather than COND.  */\n+\t      if (TREE_CODE (op0) == SSA_NAME\n+\t\t  && TREE_CODE (TREE_TYPE (op0)) == BOOLEAN_TYPE\n+\t\t  && is_gimple_min_invariant (op1))\n+\t\t{\n+\t\t  if (TREE_CODE (cond) == EQ_EXPR)\n+\t\t    {\n+\t\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t\t      equivalency->lhs = op0;\n+\t\t      equivalency->rhs = (integer_zerop (op1)\n+\t\t\t\t\t  ? boolean_false_node\n+\t\t\t\t\t  : boolean_true_node);\n+\t\t      true_edge->aux = equivalency;\n+\n+\t\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t\t      equivalency->lhs = op0;\n+\t\t      equivalency->rhs = (integer_zerop (op1)\n+\t\t\t\t\t  ? boolean_true_node\n+\t\t\t\t\t  : boolean_false_node);\n+\t\t      false_edge->aux = equivalency;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t\t      equivalency->lhs = op0;\n+\t\t      equivalency->rhs = (integer_zerop (op1)\n+\t\t\t\t\t  ? boolean_true_node\n+\t\t\t\t\t  : boolean_false_node);\n+\t\t      true_edge->aux = equivalency;\n+\n+\t\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t\t      equivalency->lhs = op0;\n+\t\t      equivalency->rhs = (integer_zerop (op1)\n+\t\t\t\t\t  ? boolean_false_node\n+\t\t\t\t\t  : boolean_true_node);\n+\t\t      false_edge->aux = equivalency;\n+\t\t    }\n+\t\t}\n+\n+\t      if (TREE_CODE (op0) == SSA_NAME\n+\t\t  && (is_gimple_min_invariant (op1)\n+\t\t      || TREE_CODE (op1) == SSA_NAME))\n+\t\t{\n+\t\t  /* For IEEE, -0.0 == 0.0, so we don't necessarily know\n+\t\t     the sign of a variable compared against zero.  If\n+\t\t     we're honoring signed zeros, then we cannot record\n+\t\t     this value unless we know that the value is nonzero.  */\n+\t\t  if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (op0)))\n+\t\t      && (TREE_CODE (op1) != REAL_CST\n+\t\t\t  || REAL_VALUES_EQUAL (dconst0, TREE_REAL_CST (op1))))\n+\t\t    continue;\n+\n+\t\t  equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t\t  equivalency->lhs = op0;\n+\t\t  equivalency->rhs = op1;\n+\t\t  if (TREE_CODE (cond) == EQ_EXPR)\n+\t\t    true_edge->aux = equivalency;\n+\t\t  else \n+\t\t    false_edge->aux = equivalency;\n+\n+\t\t}\n+\t    }\n+\n+\t  /* ??? TRUTH_NOT_EXPR can create an equivalence too.  */\n+\t}\n+\n+      /* For a SWITCH_EXPR, a case label which represents a single\n+\t value and which is the only case label which reaches the\n+\t target block creates an equivalence.  */\n+      if (TREE_CODE (stmt) == SWITCH_EXPR)\n+\t{\n+\t  tree cond = SWITCH_COND (stmt);\n+\n+\t  if (TREE_CODE (cond) == SSA_NAME)\n+\t    {\n+\t      tree labels = SWITCH_LABELS (stmt);\n+\t      int i, n_labels = TREE_VEC_LENGTH (labels);\n+\t      tree *info = xcalloc (n_basic_blocks, sizeof (tree));\n+\n+\t      /* Walk over the case label vector.  Record blocks\n+\t\t which are reached by a single case label which represents\n+\t\t a single value.  */\n+\t      for (i = 0; i < n_labels; i++)\n+\t\t{\n+\t\t  tree label = TREE_VEC_ELT (labels, i);\n+\t\t  basic_block bb = label_to_block (CASE_LABEL (label));\n+\n+\n+\t\t  if (CASE_HIGH (label)\n+\t\t      || !CASE_LOW (label)\n+\t\t      || info[bb->index])\n+\t\t    info[bb->index] = error_mark_node;\n+\t\t  else\n+\t\t    info[bb->index] = label;\n+\t\t}\n+\n+\t      /* Now walk over the blocks to determine which ones were\n+\t\t marked as being reached by a useful case label.  */\n+\t      for (i = 0; i < n_basic_blocks; i++)\n+\t\t{\n+\t\t  tree node = info[i];\n+\n+\t\t  if (node != NULL\n+\t\t      && node != error_mark_node)\n+\t\t    {\n+\t\t      tree x = fold_convert (TREE_TYPE (cond), CASE_LOW (node));\n+\t\t      struct edge_equivalency *equivalency;\n+\n+\t\t      /* Record an equivalency on the edge from BB to basic\n+\t\t\t block I.  */\n+\t\t      equivalency = xmalloc (sizeof (struct edge_equivalency));\n+\t\t      equivalency->rhs = x;\n+\t\t      equivalency->lhs = cond;\n+\t\t      find_edge (bb, BASIC_BLOCK (i))->aux = equivalency;\n+\t\t    }\n+\t\t}\n+\t      free (info);\n+\t    }\n+\t}\n+\n+    }\n+}\n+\n+\n+/* Translating out of SSA sometimes requires inserting copies and\n+   constant initializations on edges to eliminate PHI nodes.\n+\n+   In some cases those copies and constant initializations are\n+   redundant because the target already has the value on the\n+   RHS of the assignment.\n+\n+   We previously tried to catch these cases after translating\n+   out of SSA form.  However, that code often missed cases.  Worse\n+   yet, the cases it missed were also often missed by the RTL\n+   optimizers.  Thus the resulting code had redundant instructions.\n+\n+   This pass attempts to detect these situations before translating\n+   out of SSA form.\n+\n+   The key concept that this pass is built upon is that these\n+   redundant copies and constant initializations often occur\n+   due to constant/copy propagating equivalences resulting from\n+   COND_EXPRs and SWITCH_EXPRs.\n+\n+   We want to do those propagations as they can sometimes allow\n+   the SSA optimziers to do a better job.  However, in the cases\n+   where such propagations do not result in further optimization,\n+   we would like to \"undo\" the propagation to avoid the redundant\n+   copies and constant initializations.\n+\n+   This pass works by first associating equivalences with edges in\n+   the CFG.  For example, the edge leading from a SWITCH_EXPR to\n+   its associated CASE_LABEL will have an equivalency between\n+   SWITCH_COND and the value in the case label.\n+\n+   Once we have found the edge equivalences, we proceed to walk\n+   the CFG in dominator order.  As we traverse edges we record\n+   equivalences associated with those edges we traverse.\n+\n+   When we encounter a PHI node, we walk its arguments to see if we\n+   have an equivalence for the PHI argument.  If so, then we replace\n+   the argument.\n+\n+   Equivalences are looked up based on their value (think of it as\n+   the RHS of an assignment).   A value may be an SSA_NAME or an\n+   invariant.  We may have several SSA_NAMEs with the same value,\n+   so with each value we have a list of SSA_NAMEs that have the\n+   same value.  */\n+\n+/* As we enter each block we record the value for any edge equivalency\n+   leading to this block.  If no such edge equivalency exists, then we\n+   record NULL.  These equivalences are live until we leave the dominator\n+   subtree rooted at the block where we record the equivalency.  */\n+static varray_type equiv_stack;\n+\n+/* Global hash table implementing a mapping from invariant values\n+   to a list of SSA_NAMEs which have the same value.  We might be\n+   able to reuse tree-vn for this code.  */\n+static htab_t equiv;\n+\n+/* Main structure for recording equivalences into our hash table.  */\n+struct equiv_hash_elt\n+{\n+  /* The value/key of this entry.  */\n+  tree value;\n+\n+  /* List of SSA_NAMEs which have the same value/key.  */\n+  varray_type equivalences;\n+};\n+\n+static void uncprop_initialize_block (struct dom_walk_data *, basic_block);\n+static void uncprop_finalize_block (struct dom_walk_data *, basic_block);\n+static void uncprop_into_successor_phis (struct dom_walk_data *, basic_block);\n+\n+/* Hashing and equality routines for the hash table.  */\n+\n+static hashval_t\n+equiv_hash (const void *p)\n+{\n+  tree value = ((struct equiv_hash_elt *)p)->value;\n+  return iterative_hash_expr (value, 0);\n+}\n+\n+static int\n+equiv_eq (const void *p1, const void *p2)\n+{\n+  tree value1 = ((struct equiv_hash_elt *)p1)->value;\n+  tree value2 = ((struct equiv_hash_elt *)p2)->value;\n+\n+  return operand_equal_p (value1, value2, 0);\n+}\n+\n+/* Remove the most recently recorded equivalency for VALUE.  */\n+\n+static void\n+remove_equivalence (tree value)\n+{\n+  struct equiv_hash_elt equiv_hash_elt, *equiv_hash_elt_p;\n+  void **slot;\n+\n+  equiv_hash_elt.value = value;\n+  equiv_hash_elt.equivalences = NULL;\n+\n+  slot = htab_find_slot (equiv, &equiv_hash_elt, NO_INSERT);\n+\n+  equiv_hash_elt_p = (struct equiv_hash_elt *) *slot;\n+  VARRAY_POP (equiv_hash_elt_p->equivalences);\n+}\n+\n+/* Record EQUIVALENCE = VALUE into our hash table.  */\n+\n+static void\n+record_equiv (tree value, tree equivalence)\n+{\n+  struct equiv_hash_elt *equiv_hash_elt;\n+  void **slot;\n+\n+  equiv_hash_elt = xmalloc (sizeof (struct equiv_hash_elt));\n+  equiv_hash_elt->value = value;\n+  equiv_hash_elt->equivalences = NULL;\n+\n+  slot = htab_find_slot (equiv, equiv_hash_elt, INSERT);\n+\n+  if (*slot == NULL)\n+    *slot = (void *) equiv_hash_elt;\n+  else\n+     free (equiv_hash_elt);\n+\n+  equiv_hash_elt = (struct equiv_hash_elt *) *slot;\n+  \n+  if (!equiv_hash_elt->equivalences)\n+    VARRAY_TREE_INIT (equiv_hash_elt->equivalences, 10, \"value equivs\");\n+  VARRAY_PUSH_TREE (equiv_hash_elt->equivalences, equivalence);\n+}\n+\n+/* Main driver for un-cprop.  */\n+\n+static void\n+tree_ssa_uncprop (void)\n+{\n+  struct dom_walk_data walk_data;\n+  basic_block bb;\n+\n+  associate_equivalences_with_edges ();\n+\n+  /* Create our global data structures.  */\n+  equiv = htab_create (1024, equiv_hash, equiv_eq, free);\n+  VARRAY_TREE_INIT (equiv_stack, 2, \"Block equiv stack\");\n+\n+  /* We're going to do a dominator walk, so ensure that we have\n+     dominance information.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* Setup callbacks for the generic dominator tree walker.  */\n+  walk_data.walk_stmts_backward = false;\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.initialize_block_local_data = NULL;\n+  walk_data.before_dom_children_before_stmts = uncprop_initialize_block;\n+  walk_data.before_dom_children_walk_stmts = NULL;\n+  walk_data.before_dom_children_after_stmts = uncprop_into_successor_phis;\n+  walk_data.after_dom_children_before_stmts = NULL;\n+  walk_data.after_dom_children_walk_stmts = NULL;\n+  walk_data.after_dom_children_after_stmts = uncprop_finalize_block;\n+  walk_data.global_data = NULL;\n+  walk_data.block_local_data_size = 0;\n+  walk_data.interesting_blocks = NULL;\n+\n+  /* Now initialize the dominator walker.  */\n+  init_walk_dominator_tree (&walk_data);\n+\n+  /* Recursively walk the dominator tree undoing unprofitable\n+     constant/copy propagations.  */\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+\n+  /* Finalize and clean up.  */\n+  fini_walk_dominator_tree (&walk_data);\n+\n+  /* EQUIV_STACK should already be empty at this point, so we just need\n+     to empty elements out of the hash table and cleanup the AUX field\n+     on the edges.  */\n+  htab_delete (equiv);\n+  FOR_EACH_BB (bb)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  if (e->aux)\n+\t    {\n+\t      free (e->aux);\n+\t      e->aux = NULL;\n+\t    }\n+\t}\n+    }\n+\n+}\n+\n+\n+/* We have finished processing the dominator children of BB, perform\n+   any finalization actions in preparation for leaving this node in\n+   the dominator tree.  */\n+\n+static void\n+uncprop_finalize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\tbasic_block bb ATTRIBUTE_UNUSED)\n+{\n+  tree value = VARRAY_TOP_TREE (equiv_stack);\n+\n+  /* Pop the topmost value off the equiv stack.  */\n+  VARRAY_POP (equiv_stack);\n+\n+  /* If that value was non-null, then pop the topmost equivalency off\n+     its equivalency stack.  */\n+  if (value != NULL)\n+    remove_equivalence (value);\n+}\n+\n+/* Unpropagate values from PHI nodes in successor blocks of BB.  */\n+\n+static void\n+uncprop_into_successor_phis (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\t     basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  /* For each successor edge, first temporarily record any equivalence\n+     on that edge.  Then unpropagate values in any PHI nodes at the\n+     destination of the edge.  Then remove the temporary equivalence.  */\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      tree phi = phi_nodes (e->dest);\n+\n+      /* If there are no PHI nodes in this destination, then there is\n+\t no sense in recording any equivalences.  */\n+      if (!phi)\n+\tcontinue;\n+\n+      /* Record any equivalency associated with E.  */\n+      if (e->aux)\n+\t{\n+\t  struct edge_equivalency *equiv = e->aux;\n+\t  record_equiv (equiv->rhs, equiv->lhs);\n+\t}\n+\n+      /* Walk over the PHI nodes, unpropagating values.  */\n+      for ( ; phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  /* Sigh.  We'll have more efficient access to this one day.  */\n+\t  tree arg = PHI_ARG_DEF (phi, e->dest_idx);\n+\t  struct equiv_hash_elt equiv_hash_elt;\n+\t  void **slot;\n+\n+\t  /* If the argument is not an invariant, or refers to the same\n+\t     underlying variable as the PHI result, then there's no\n+\t     point in un-propagating the argument.  */\n+\t  if (!is_gimple_min_invariant (arg)\n+\t      && SSA_NAME_VAR (arg) != SSA_NAME_VAR (PHI_RESULT (phi)))\n+\t    continue;\n+\n+\t  /* Lookup this argument's value in the hash table.  */\n+\t  equiv_hash_elt.value = arg;\n+\t  equiv_hash_elt.equivalences = NULL;\n+\t  slot = htab_find_slot (equiv, &equiv_hash_elt, NO_INSERT);\n+\n+\t  if (slot)\n+\t    {\n+\t      struct equiv_hash_elt *elt = *slot;\n+\t      int j;\n+\n+\t      /* Walk every equivalence with the same value.  If we find\n+\t\t one with the same underlying variable as the PHI result,\n+\t\t then replace the value in the argument with its equivalent\n+\t\t SSA_NAME.  Use the most recent equivlance as hopefully\n+\t\t that results in shortest lifetimes.  */\n+\t      for (j = VARRAY_ACTIVE_SIZE (elt->equivalences) - 1; j >= 0; j--)\n+\t\t{\n+\t\t  tree equiv = VARRAY_TREE (elt->equivalences, j);\n+\n+\t\t  if (SSA_NAME_VAR (equiv) == SSA_NAME_VAR (PHI_RESULT (phi)))\n+\t\t    {\n+\t\t      SET_PHI_ARG_DEF (phi, e->dest_idx, equiv);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* If we had an equivalence associated with this edge, remove it.  */\n+      if (e->aux)\n+\t{\n+\t  struct edge_equivalency *equiv = e->aux;\n+\t  remove_equivalence (equiv->rhs);\n+\t}\n+    }\n+}\n+\n+/* Ignoring loop backedges, if BB has precisely one incoming edge then\n+   return that edge.  Otherwise return NULL.  */\n+static edge\n+single_incoming_edge_ignoring_loop_edges (basic_block bb)\n+{\n+  edge retval = NULL;\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      /* A loop back edge can be identified by the destination of\n+\t the edge dominating the source of the edge.  */\n+      if (dominated_by_p (CDI_DOMINATORS, e->src, e->dest))\n+\tcontinue;\n+\n+      /* If we have already seen a non-loop edge, then we must have\n+\t multiple incoming non-loop edges and thus we return NULL.  */\n+      if (retval)\n+\treturn NULL;\n+\n+      /* This is the first non-loop incoming edge we have found.  Record\n+\t it.  */\n+      retval = e;\n+    }\n+\n+  return retval;\n+}\n+\n+static void\n+uncprop_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\t  basic_block bb)\n+{\n+  basic_block parent;\n+  edge e;\n+  bool recorded = false;\n+\n+  /* If this block is dominated by a single incoming edge and that edge\n+     has an equivalency, then record the equivalency and push the\n+     VALUE onto EQUIV_STACK.  Else push a NULL entry on EQUIV_STACK.  */\n+  parent = get_immediate_dominator (CDI_DOMINATORS, bb);\n+  if (parent)\n+    {\n+      e = single_incoming_edge_ignoring_loop_edges (bb);\n+\n+      if (e && e->src == parent && e->aux)\n+\t{\n+\t  struct edge_equivalency *equiv = e->aux;\n+\n+\t  record_equiv (equiv->rhs, equiv->lhs);\n+\t  VARRAY_PUSH_TREE (equiv_stack, equiv->rhs);\n+\t  recorded = true;\n+\t}\n+    }\n+\n+  if (!recorded)\n+    VARRAY_PUSH_TREE (equiv_stack, NULL_TREE);\n+}\n+\n+static bool\n+gate_uncprop (void)\n+{\n+  return flag_tree_dom != 0;\n+}\n+\n+struct tree_opt_pass pass_uncprop = \n+{\n+  \"uncprop\",\t\t\t\t/* name */\n+  gate_uncprop,\t\t\t\t/* gate */\n+  tree_ssa_uncprop,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_SSA_UNCPROP,\t\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_verify_ssa,\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}]}