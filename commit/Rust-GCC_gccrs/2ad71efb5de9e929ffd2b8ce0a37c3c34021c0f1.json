{"sha": "2ad71efb5de9e929ffd2b8ce0a37c3c34021c0f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFkNzFlZmI1ZGU5ZTkyOWZmZDJiOGNlMGEzN2MzYzM0MDIxYzBmMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-28T07:42:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-28T07:42:58Z"}, "message": "tree-optimization/101207 - fix BB reduc permute elide with life stmts\n\nThis fixes breakage of live lane extracts from permuted loads we elide\nfrom BB reduction vectorization by handling the un-permuting the same\nas in the regular eliding code - apply the reverse permute to\nboth the scalar stmts and the load permutation.\n\n2021-06-28  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101207\n\t* tree-vect-slp.c (vect_optimize_slp): Do BB reduction\n\tpermute eliding for load permutations properly.\n\n\t* gcc.dg/vect/bb-slp-pr101207.c: New testcase.", "tree": {"sha": "8d9bd3176cffb59d65c31dd6daf968aa91b24706", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d9bd3176cffb59d65c31dd6daf968aa91b24706"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ad71efb5de9e929ffd2b8ce0a37c3c34021c0f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ad71efb5de9e929ffd2b8ce0a37c3c34021c0f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ad71efb5de9e929ffd2b8ce0a37c3c34021c0f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ad71efb5de9e929ffd2b8ce0a37c3c34021c0f1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ad9d88a3d7170b3d864693c9eb512f89a5096ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ad9d88a3d7170b3d864693c9eb512f89a5096ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ad9d88a3d7170b3d864693c9eb512f89a5096ff"}], "stats": {"total": 113, "additions": 71, "deletions": 42}, "files": [{"sha": "1f51d66a5fe81f9ad2fcbfc019197e77d449b8a4", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr101207.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ad71efb5de9e929ffd2b8ce0a37c3c34021c0f1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr101207.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ad71efb5de9e929ffd2b8ce0a37c3c34021c0f1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr101207.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr101207.c?ref=2ad71efb5de9e929ffd2b8ce0a37c3c34021c0f1", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-ffast-math\" } */\n+\n+#include \"tree-vect.h\"\n+\n+double a[2];\n+double x, y;\n+\n+void __attribute__((noipa)) foo ()\n+{\n+  x = a[1] - a[0];\n+  y = a[0] + a[1];\n+}\n+\n+int main()\n+{\n+  check_vect ();\n+\n+  a[0] = 0.;\n+  a[1] = 1.;\n+  foo ();\n+  if (x != 1. || y != 1.)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "5401dbe4d5e614fcfaa734c8666bc8f3f2c72f92", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ad71efb5de9e929ffd2b8ce0a37c3c34021c0f1/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ad71efb5de9e929ffd2b8ce0a37c3c34021c0f1/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=2ad71efb5de9e929ffd2b8ce0a37c3c34021c0f1", "patch": "@@ -3921,6 +3921,52 @@ vect_optimize_slp (vec_info *vinfo)\n \t}\n     }\n \n+  /* Elide any permutations at BB reduction roots.  */\n+  if (is_a <bb_vec_info> (vinfo))\n+    {\n+      for (slp_instance instance : vinfo->slp_instances)\n+\t{\n+\t  if (SLP_INSTANCE_KIND (instance) != slp_inst_kind_bb_reduc)\n+\t    continue;\n+\t  slp_tree old = SLP_INSTANCE_TREE (instance);\n+\t  if (SLP_TREE_CODE (old) == VEC_PERM_EXPR\n+\t      && SLP_TREE_CHILDREN (old).length () == 1)\n+\t    {\n+\t      slp_tree child = SLP_TREE_CHILDREN (old)[0];\n+\t      if (SLP_TREE_DEF_TYPE (child) == vect_external_def)\n+\t\t{\n+\t\t  /* Preserve the special VEC_PERM we use to shield existing\n+\t\t     vector defs from the rest.  But make it a no-op.  */\n+\t\t  unsigned i = 0;\n+\t\t  for (std::pair<unsigned, unsigned> &p\n+\t\t       : SLP_TREE_LANE_PERMUTATION (old))\n+\t\t    p.second = i++;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  SLP_INSTANCE_TREE (instance) = child;\n+\t\t  SLP_TREE_REF_COUNT (child)++;\n+\t\t  vect_free_slp_tree (old);\n+\t\t}\n+\t    }\n+\t  else if (SLP_TREE_LOAD_PERMUTATION (old).exists ()\n+\t\t   && SLP_TREE_REF_COUNT (old) == 1\n+\t\t   && vertices[old->vertex].materialize)\n+\t    {\n+\t      /* ???  For loads the situation is more complex since\n+\t\t we can't modify the permute in place in case the\n+\t\t node is used multiple times.  In fact for loads this\n+\t\t should be somehow handled in the propagation engine.  */\n+\t      /* Apply the reverse permutation to our stmts.  */\n+\t      int perm = vertices[old->vertex].get_perm_in ();\n+\t      vect_slp_permute (perms[perm],\n+\t\t\t\tSLP_TREE_SCALAR_STMTS (old), true);\n+\t      vect_slp_permute (perms[perm],\n+\t\t\t\tSLP_TREE_LOAD_PERMUTATION (old), true);\n+\t    }\n+\t}\n+    }\n+\n   /* Free the perms vector used for propagation.  */\n   while (!perms.is_empty ())\n     perms.pop ().release ();\n@@ -3987,48 +4033,6 @@ vect_optimize_slp (vec_info *vinfo)\n \t    }\n \t}\n     }\n-\n-  /* And any permutations of BB reductions.  */\n-  if (is_a <bb_vec_info> (vinfo))\n-    {\n-      for (slp_instance instance : vinfo->slp_instances)\n-\t{\n-\t  if (SLP_INSTANCE_KIND (instance) != slp_inst_kind_bb_reduc)\n-\t    continue;\n-\t  slp_tree old = SLP_INSTANCE_TREE (instance);\n-\t  if (SLP_TREE_CODE (old) == VEC_PERM_EXPR\n-\t      && SLP_TREE_CHILDREN (old).length () == 1)\n-\t    {\n-\t      slp_tree child = SLP_TREE_CHILDREN (old)[0];\n-\t      if (SLP_TREE_DEF_TYPE (child) == vect_external_def)\n-\t\t{\n-\t\t  /* Preserve the special VEC_PERM we use to shield existing\n-\t\t     vector defs from the rest.  But make it a no-op.  */\n-\t\t  unsigned i = 0;\n-\t\t  for (std::pair<unsigned, unsigned> &p\n-\t\t       : SLP_TREE_LANE_PERMUTATION (old))\n-\t\t    p.second = i++;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  SLP_INSTANCE_TREE (instance) = child;\n-\t\t  SLP_TREE_REF_COUNT (child)++;\n-\t\t  vect_free_slp_tree (old);\n-\t\t}\n-\t    }\n-\t  else if (SLP_TREE_LOAD_PERMUTATION (old).exists ()\n-\t\t   && SLP_TREE_REF_COUNT (old) == 1)\n-\t    {\n-\t      /* ???  For loads the situation is more complex since\n-\t\t we can't modify the permute in place in case the\n-\t\t node is used multiple times.  In fact for loads this\n-\t\t should be somehow handled in the propagation engine.  */\n-\t      auto fn = [] (const void *a, const void *b)\n-\t\t\t      { return *(const int *)a - *(const int *)b; };\n-\t      SLP_TREE_LOAD_PERMUTATION (old).qsort (fn);\n-\t    }\n-\t}\n-    }\n }\n \n /* Gather loads reachable from the individual SLP graph entries.  */"}]}