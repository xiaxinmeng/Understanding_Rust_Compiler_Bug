{"sha": "6bf68a93f60cf873c4a0713bb11480d838fb5af0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJmNjhhOTNmNjBjZjg3M2M0YTA3MTNiYjExNDgwZDgzOGZiNWFmMA==", "commit": {"author": {"name": "Laurent GUERBY", "email": "laurent@guerby.net", "date": "2009-06-26T17:06:52Z"}, "committer": {"name": "Laurent Guerby", "email": "guerby@gcc.gnu.org", "date": "2009-06-26T17:06:52Z"}, "message": "tb-gcc.c (trace_callback): Use char* instead of void*.\n\n2009-06-26  Laurent GUERBY  <laurent@guerby.net>\n\n\t* tb-gcc.c (trace_callback): Use char* instead of void*.\n\t* gcc-interface/misc.c (enumerate_modes): Make loop compatible\n\twith C++.\n\t* gcc-interface/trans.c (parm_attr): Rename to parm_attr_d. \n\tChange all uses.\n\t* gcc-interface/utils.c (new, class, template): Rename to be\n\tcompatible with C++. Change all uses.\n\t* gcc-interface/decl.c (new): Likewise.\n\nFrom-SVN: r148975", "tree": {"sha": "20d7a88e927511698c3d4b43e91c0b3cffcf82ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20d7a88e927511698c3d4b43e91c0b3cffcf82ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bf68a93f60cf873c4a0713bb11480d838fb5af0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bf68a93f60cf873c4a0713bb11480d838fb5af0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bf68a93f60cf873c4a0713bb11480d838fb5af0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bf68a93f60cf873c4a0713bb11480d838fb5af0/comments", "author": {"login": "guerby", "id": 6659329, "node_id": "MDQ6VXNlcjY2NTkzMjk=", "avatar_url": "https://avatars.githubusercontent.com/u/6659329?v=4", "gravatar_id": "", "url": "https://api.github.com/users/guerby", "html_url": "https://github.com/guerby", "followers_url": "https://api.github.com/users/guerby/followers", "following_url": "https://api.github.com/users/guerby/following{/other_user}", "gists_url": "https://api.github.com/users/guerby/gists{/gist_id}", "starred_url": "https://api.github.com/users/guerby/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/guerby/subscriptions", "organizations_url": "https://api.github.com/users/guerby/orgs", "repos_url": "https://api.github.com/users/guerby/repos", "events_url": "https://api.github.com/users/guerby/events{/privacy}", "received_events_url": "https://api.github.com/users/guerby/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bae4cf874ea098e56b8dc9ab755eb1669b749aeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bae4cf874ea098e56b8dc9ab755eb1669b749aeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bae4cf874ea098e56b8dc9ab755eb1669b749aeb"}], "stats": {"total": 248, "additions": 130, "deletions": 118}, "files": [{"sha": "f4b7074b4e35d0fa5c4979031f8e5cf00f2b3113", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf68a93f60cf873c4a0713bb11480d838fb5af0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf68a93f60cf873c4a0713bb11480d838fb5af0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6bf68a93f60cf873c4a0713bb11480d838fb5af0", "patch": "@@ -1,3 +1,14 @@\n+2009-06-26  Laurent GUERBY  <laurent@guerby.net>\n+\n+\t* tb-gcc.c (trace_callback): Use char* instead of void*.\n+\t* gcc-interface/misc.c (enumerate_modes): Make loop compatible\n+\twith C++.\n+\t* gcc-interface/trans.c (parm_attr): Rename to parm_attr_d. \n+\tChange all uses.\n+\t* gcc-interface/utils.c (new, class, template): Rename to be\n+\tcompatible with C++. Change all uses.\n+\t* gcc-interface/decl.c (new): Likewise.\n+\t\n 2009-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (cannot_be_superflat_p): New predicate."}, {"sha": "a5c6845ad5edc73ea903ef4396f7839de320dabc", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf68a93f60cf873c4a0713bb11480d838fb5af0/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf68a93f60cf873c4a0713bb11480d838fb5af0/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=6bf68a93f60cf873c4a0713bb11480d838fb5af0", "patch": "@@ -7840,7 +7840,7 @@ compatible_signatures_p (tree ftype1, tree ftype2)\n tree\n substitute_in_type (tree t, tree f, tree r)\n {\n-  tree new;\n+  tree new_tree;\n \n   gcc_assert (CONTAINS_PLACEHOLDER_P (r));\n \n@@ -7861,15 +7861,15 @@ substitute_in_type (tree t, tree f, tree r)\n \t  if (low == TYPE_GCC_MIN_VALUE (t) && high == TYPE_GCC_MAX_VALUE (t))\n \t    return t;\n \n-\t  new = copy_type (t);\n-\t  TYPE_GCC_MIN_VALUE (new) = low;\n-\t  TYPE_GCC_MAX_VALUE (new) = high;\n+\t  new_tree = copy_type (t);\n+\t  TYPE_GCC_MIN_VALUE (new_tree) = low;\n+\t  TYPE_GCC_MAX_VALUE (new_tree) = high;\n \n \t  if (TREE_CODE (t) == INTEGER_TYPE && TYPE_INDEX_TYPE (t))\n \t    SET_TYPE_INDEX_TYPE\n-\t      (new, substitute_in_type (TYPE_INDEX_TYPE (t), f, r));\n+\t      (new_tree, substitute_in_type (TYPE_INDEX_TYPE (t), f, r));\n \n-\t  return new;\n+\t  return new_tree;\n \t}\n \n       /* Then the subtypes.  */\n@@ -7882,21 +7882,21 @@ substitute_in_type (tree t, tree f, tree r)\n \t  if (low == TYPE_RM_MIN_VALUE (t) && high == TYPE_RM_MAX_VALUE (t))\n \t    return t;\n \n-\t  new = copy_type (t);\n-\t  SET_TYPE_RM_MIN_VALUE (new, low);\n-\t  SET_TYPE_RM_MAX_VALUE (new, high);\n+\t  new_tree = copy_type (t);\n+\t  SET_TYPE_RM_MIN_VALUE (new_tree, low);\n+\t  SET_TYPE_RM_MAX_VALUE (new_tree, high);\n \n-\t  return new;\n+\t  return new_tree;\n \t}\n \n       return t;\n \n     case COMPLEX_TYPE:\n-      new = substitute_in_type (TREE_TYPE (t), f, r);\n-      if (new == TREE_TYPE (t))\n+      new_tree = substitute_in_type (TREE_TYPE (t), f, r);\n+      if (new_tree == TREE_TYPE (t))\n \treturn t;\n \n-      return build_complex_type (new);\n+      return build_complex_type (new_tree);\n \n     case OFFSET_TYPE:\n     case METHOD_TYPE:\n@@ -7913,16 +7913,16 @@ substitute_in_type (tree t, tree f, tree r)\n \tif (component == TREE_TYPE (t) && domain == TYPE_DOMAIN (t))\n \t  return t;\n \n-\tnew = build_array_type (component, domain);\n-\tTYPE_ALIGN (new) = TYPE_ALIGN (t);\n-\tTYPE_USER_ALIGN (new) = TYPE_USER_ALIGN (t);\n-\tSET_TYPE_MODE (new, TYPE_MODE (t));\n-\tTYPE_SIZE (new) = SUBSTITUTE_IN_EXPR (TYPE_SIZE (t), f, r);\n-\tTYPE_SIZE_UNIT (new) = SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (t), f, r);\n-\tTYPE_NONALIASED_COMPONENT (new) = TYPE_NONALIASED_COMPONENT (t);\n-\tTYPE_MULTI_ARRAY_P (new) = TYPE_MULTI_ARRAY_P (t);\n-\tTYPE_CONVENTION_FORTRAN_P (new) = TYPE_CONVENTION_FORTRAN_P (t);\n-\treturn new;\n+\tnew_tree = build_array_type (component, domain);\n+\tTYPE_ALIGN (new_tree) = TYPE_ALIGN (t);\n+\tTYPE_USER_ALIGN (new_tree) = TYPE_USER_ALIGN (t);\n+\tSET_TYPE_MODE (new_tree, TYPE_MODE (t));\n+\tTYPE_SIZE (new_tree) = SUBSTITUTE_IN_EXPR (TYPE_SIZE (t), f, r);\n+\tTYPE_SIZE_UNIT (new_tree) = SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (t), f, r);\n+\tTYPE_NONALIASED_COMPONENT (new_tree) = TYPE_NONALIASED_COMPONENT (t);\n+\tTYPE_MULTI_ARRAY_P (new_tree) = TYPE_MULTI_ARRAY_P (t);\n+\tTYPE_CONVENTION_FORTRAN_P (new_tree) = TYPE_CONVENTION_FORTRAN_P (t);\n+\treturn new_tree;\n       }\n \n     case RECORD_TYPE:\n@@ -7935,8 +7935,8 @@ substitute_in_type (tree t, tree f, tree r)\n \t/* Start out with no fields, make new fields, and chain them\n \t   in.  If we haven't actually changed the type of any field,\n \t   discard everything we've done and return the old type.  */\n-\tnew = copy_type (t);\n-\tTYPE_FIELDS (new) = NULL_TREE;\n+\tnew_tree = copy_type (t);\n+\tTYPE_FIELDS (new_tree) = NULL_TREE;\n \n \tfor (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n \t  {\n@@ -7967,23 +7967,23 @@ substitute_in_type (tree t, tree f, tree r)\n \t\t  }\n \t      }\n \n-\t    DECL_CONTEXT (new_field) = new;\n+\t    DECL_CONTEXT (new_field) = new_tree;\n \t    SET_DECL_ORIGINAL_FIELD (new_field,\n \t\t\t\t     (DECL_ORIGINAL_FIELD (field)\n \t\t\t\t      ? DECL_ORIGINAL_FIELD (field) : field));\n \n-\t    TREE_CHAIN (new_field) = TYPE_FIELDS (new);\n-\t    TYPE_FIELDS (new) = new_field;\n+\t    TREE_CHAIN (new_field) = TYPE_FIELDS (new_tree);\n+\t    TYPE_FIELDS (new_tree) = new_field;\n \t  }\n \n \tif (!changed_field)\n \t  return t;\n \n-\tTYPE_FIELDS (new) = nreverse (TYPE_FIELDS (new));\n-\tTYPE_SIZE (new) = SUBSTITUTE_IN_EXPR (TYPE_SIZE (t), f, r);\n-\tTYPE_SIZE_UNIT (new) = SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (t), f, r);\n-\tSET_TYPE_ADA_SIZE (new, SUBSTITUTE_IN_EXPR (TYPE_ADA_SIZE (t), f, r));\n-\treturn new;\n+\tTYPE_FIELDS (new_tree) = nreverse (TYPE_FIELDS (new_tree));\n+\tTYPE_SIZE (new_tree) = SUBSTITUTE_IN_EXPR (TYPE_SIZE (t), f, r);\n+\tTYPE_SIZE_UNIT (new_tree) = SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (t), f, r);\n+\tSET_TYPE_ADA_SIZE (new_tree, SUBSTITUTE_IN_EXPR (TYPE_ADA_SIZE (t), f, r));\n+\treturn new_tree;\n       }\n \n     default:"}, {"sha": "fb306206fc1c654a63f7fe891911673e7a4d5f94", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf68a93f60cf873c4a0713bb11480d838fb5af0/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf68a93f60cf873c4a0713bb11480d838fb5af0/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=6bf68a93f60cf873c4a0713bb11480d838fb5af0", "patch": "@@ -729,10 +729,11 @@ must_pass_by_ref (tree gnu_type)\n void\n enumerate_modes (void (*f) (int, int, int, int, int, int, unsigned int))\n {\n-  enum machine_mode i;\n+  int iloop;\n \n-  for (i = 0; i < NUM_MACHINE_MODES; i++)\n+  for (iloop = 0; iloop < NUM_MACHINE_MODES; iloop++)\n     {\n+      enum machine_mode i = (enum machine_mode) iloop;\n       enum machine_mode j;\n       bool float_p = 0;\n       bool complex_p = 0;"}, {"sha": "24163b89ec11cfb07e721b2b2d8c45be65114366", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf68a93f60cf873c4a0713bb11480d838fb5af0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf68a93f60cf873c4a0713bb11480d838fb5af0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=6bf68a93f60cf873c4a0713bb11480d838fb5af0", "patch": "@@ -100,15 +100,15 @@ bool type_annotate_only;\n /* When not optimizing, we cache the 'First, 'Last and 'Length attributes\n    of unconstrained array IN parameters to avoid emitting a great deal of\n    redundant instructions to recompute them each time.  */\n-struct GTY (()) parm_attr {\n+struct GTY (()) parm_attr_d {\n   int id; /* GTY doesn't like Entity_Id.  */\n   int dim;\n   tree first;\n   tree last;\n   tree length;\n };\n \n-typedef struct parm_attr *parm_attr;\n+typedef struct parm_attr_d *parm_attr;\n \n DEF_VEC_P(parm_attr);\n DEF_VEC_ALLOC_P(parm_attr,gc);\n@@ -1464,7 +1464,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \tint Dimension = (Present (Expressions (gnat_node))\n \t\t\t ? UI_To_Int (Intval (First (Expressions (gnat_node))))\n \t\t\t : 1), i;\n-\tstruct parm_attr *pa = NULL;\n+\tstruct parm_attr_d *pa = NULL;\n \tEntity_Id gnat_param = Empty;\n \n \t/* Make sure any implicit dereference gets done.  */\n@@ -1508,7 +1508,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n \t    if (!pa)\n \t      {\n-\t\tpa = GGC_CNEW (struct parm_attr);\n+\t\tpa = GGC_CNEW (struct parm_attr_d);\n \t\tpa->id = gnat_param;\n \t\tpa->dim = Dimension;\n \t\tVEC_safe_push (parm_attr, gc, f_parm_attr_cache, pa);\n@@ -2268,7 +2268,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   cache = DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language->parm_attr_cache;\n   if (cache)\n     {\n-      struct parm_attr *pa;\n+      struct parm_attr_d *pa;\n       int i;\n \n       start_stmt_group ();"}, {"sha": "7734fddde5eb78145b986fd8f391dced95862601", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf68a93f60cf873c4a0713bb11480d838fb5af0/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf68a93f60cf873c4a0713bb11480d838fb5af0/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=6bf68a93f60cf873c4a0713bb11480d838fb5af0", "patch": "@@ -1017,33 +1017,33 @@ merge_sizes (tree last_size, tree first_bit, tree size, bool special,\n \t     bool has_rep)\n {\n   tree type = TREE_TYPE (last_size);\n-  tree new;\n+  tree new_tree;\n \n   if (!special || TREE_CODE (size) != COND_EXPR)\n     {\n-      new = size_binop (PLUS_EXPR, first_bit, size);\n+      new_tree = size_binop (PLUS_EXPR, first_bit, size);\n       if (has_rep)\n-\tnew = size_binop (MAX_EXPR, last_size, new);\n+\tnew_tree = size_binop (MAX_EXPR, last_size, new_tree);\n     }\n \n   else\n-    new = fold_build3 (COND_EXPR, type, TREE_OPERAND (size, 0),\n-\t\t       integer_zerop (TREE_OPERAND (size, 1))\n-\t\t       ? last_size : merge_sizes (last_size, first_bit,\n-\t\t\t\t\t\t  TREE_OPERAND (size, 1),\n-\t\t\t\t\t\t  1, has_rep),\n-\t\t       integer_zerop (TREE_OPERAND (size, 2))\n-\t\t       ? last_size : merge_sizes (last_size, first_bit,\n-\t\t\t\t\t\t  TREE_OPERAND (size, 2),\n-\t\t\t\t\t\t  1, has_rep));\n+    new_tree = fold_build3 (COND_EXPR, type, TREE_OPERAND (size, 0),\n+\t\t            integer_zerop (TREE_OPERAND (size, 1))\n+\t\t            ? last_size : merge_sizes (last_size, first_bit,\n+\t\t     \t\t\t\t  TREE_OPERAND (size, 1),\n+\t\t     \t\t\t\t  1, has_rep),\n+\t\t            integer_zerop (TREE_OPERAND (size, 2))\n+\t\t            ? last_size : merge_sizes (last_size, first_bit,\n+\t\t     \t\t\t\t  TREE_OPERAND (size, 2),\n+\t\t     \t\t\t\t  1, has_rep));\n \n   /* We don't need any NON_VALUE_EXPRs and they can confuse us (especially\n      when fed through substitute_in_expr) into thinking that a constant\n      size is not constant.  */\n-  while (TREE_CODE (new) == NON_LVALUE_EXPR)\n-    new = TREE_OPERAND (new, 0);\n+  while (TREE_CODE (new_tree) == NON_LVALUE_EXPR)\n+    new_tree = TREE_OPERAND (new_tree, 0);\n \n-  return new;\n+  return new_tree;\n }\n \n /* Utility function of above to see if OP0 and OP1, both of SIZETYPE, are\n@@ -1163,18 +1163,18 @@ create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n tree\n copy_type (tree type)\n {\n-  tree new = copy_node (type);\n+  tree new_tree = copy_node (type);\n \n   /* copy_node clears this field instead of copying it, because it is\n      aliased with TREE_CHAIN.  */\n-  TYPE_STUB_DECL (new) = TYPE_STUB_DECL (type);\n+  TYPE_STUB_DECL (new_tree) = TYPE_STUB_DECL (type);\n \n-  TYPE_POINTER_TO (new) = 0;\n-  TYPE_REFERENCE_TO (new) = 0;\n-  TYPE_MAIN_VARIANT (new) = new;\n-  TYPE_NEXT_VARIANT (new) = 0;\n+  TYPE_POINTER_TO (new_tree) = 0;\n+  TYPE_REFERENCE_TO (new_tree) = 0;\n+  TYPE_MAIN_VARIANT (new_tree) = new_tree;\n+  TYPE_NEXT_VARIANT (new_tree) = 0;\n \n-  return new;\n+  return new_tree;\n }\n \f\n /* Return a subtype of sizetype with range MIN to MAX and whose\n@@ -2515,7 +2515,7 @@ build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n   tree record_type = make_node (RECORD_TYPE);\n   tree pointer32_type;\n   tree field_list = 0;\n-  int class;\n+  int class_i;\n   int dtype = 0;\n   tree inner_type;\n   int ndim;\n@@ -2627,22 +2627,22 @@ build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n     {\n     case By_Descriptor_A:\n     case By_Short_Descriptor_A:\n-      class = 4;\n+      class_i = 4;\n       break;\n     case By_Descriptor_NCA:\n     case By_Short_Descriptor_NCA:\n-      class = 10;\n+      class_i = 10;\n       break;\n     case By_Descriptor_SB:\n     case By_Short_Descriptor_SB:\n-      class = 15;\n+      class_i = 15;\n       break;\n     case By_Descriptor:\n     case By_Short_Descriptor:\n     case By_Descriptor_S:\n     case By_Short_Descriptor_S:\n     default:\n-      class = 1;\n+      class_i = 1;\n       break;\n     }\n \n@@ -2664,7 +2664,7 @@ build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n   field_list = chainon (field_list,\n \t\t\tmake_descriptor_field (\"CLASS\",\n \t\t\t\t\t       gnat_type_for_size (8, 1),\n-\t\t\t\t\t       record_type, size_int (class)));\n+\t\t\t\t\t       record_type, size_int (class_i)));\n \n   /* Of course this will crash at run-time if the address space is not\n      within the low 32 bits, but there is nothing else we can do.  */\n@@ -2830,7 +2830,7 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n   tree record64_type = make_node (RECORD_TYPE);\n   tree pointer64_type;\n   tree field_list64 = 0;\n-  int class;\n+  int class_i;\n   int dtype = 0;\n   tree inner_type;\n   int ndim;\n@@ -2941,18 +2941,18 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n   switch (mech)\n     {\n     case By_Descriptor_A:\n-      class = 4;\n+      class_i = 4;\n       break;\n     case By_Descriptor_NCA:\n-      class = 10;\n+      class_i = 10;\n       break;\n     case By_Descriptor_SB:\n-      class = 15;\n+      class_i = 15;\n       break;\n     case By_Descriptor:\n     case By_Descriptor_S:\n     default:\n-      class = 1;\n+      class_i = 1;\n       break;\n     }\n \n@@ -2971,7 +2971,7 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n   field_list64 = chainon (field_list64,\n \t\t\tmake_descriptor_field (\"CLASS\",\n \t\t\t\t\t       gnat_type_for_size (8, 1),\n-\t\t\t\t\t       record64_type, size_int (class)));\n+\t\t\t\t\t       record64_type, size_int (class_i)));\n \n   field_list64 = chainon (field_list64,\n \t\t\tmake_descriptor_field (\"MBMO\",\n@@ -3154,9 +3154,9 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n   tree desc_type = TREE_TYPE (TREE_TYPE (gnu_expr));\n   tree desc = build1 (INDIRECT_REF, desc_type, gnu_expr);\n   /* The CLASS field is the 3rd field in the descriptor.  */\n-  tree class = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (desc_type)));\n+  tree class_tree = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (desc_type)));\n   /* The POINTER field is the 6th field in the descriptor.  */\n-  tree pointer64 = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (class)));\n+  tree pointer64 = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (class_tree)));\n \n   /* Retrieve the value of the POINTER field.  */\n   tree gnu_expr64\n@@ -3172,9 +3172,9 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n       tree template_type = TREE_TYPE (p_bounds_type);\n       tree min_field = TYPE_FIELDS (template_type);\n       tree max_field = TREE_CHAIN (TYPE_FIELDS (template_type));\n-      tree template, template_addr, aflags, dimct, t, u;\n+      tree template_tree, template_addr, aflags, dimct, t, u;\n       /* See the head comment of build_vms_descriptor.  */\n-      int iclass = TREE_INT_CST_LOW (DECL_INITIAL (class));\n+      int iclass = TREE_INT_CST_LOW (DECL_INITIAL (class_tree));\n       tree lfield, ufield;\n \n       /* Convert POINTER to the type of the P_ARRAY field.  */\n@@ -3185,23 +3185,23 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \tcase 1:  /* Class S  */\n \tcase 15: /* Class SB */\n \t  /* Build {1, LENGTH} template; LENGTH64 is the 5th field.  */\n-\t  t = TREE_CHAIN (TREE_CHAIN (class));\n+\t  t = TREE_CHAIN (TREE_CHAIN (class_tree));\n \t  t = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  t = tree_cons (min_field,\n \t\t\t convert (TREE_TYPE (min_field), integer_one_node),\n \t\t\t tree_cons (max_field,\n \t\t\t\t    convert (TREE_TYPE (max_field), t),\n \t\t\t\t    NULL_TREE));\n-\t  template = gnat_build_constructor (template_type, t);\n-\t  template_addr = build_unary_op (ADDR_EXPR, NULL_TREE, template);\n+\t  template_tree = gnat_build_constructor (template_type, t);\n+\t  template_addr = build_unary_op (ADDR_EXPR, NULL_TREE, template_tree);\n \n \t  /* For class S, we are done.  */\n \t  if (iclass == 1)\n \t    break;\n \n \t  /* Test that we really have a SB descriptor, like DEC Ada.  */\n-\t  t = build3 (COMPONENT_REF, TREE_TYPE (class), desc, class, NULL);\n-\t  u = convert (TREE_TYPE (class), DECL_INITIAL (class));\n+\t  t = build3 (COMPONENT_REF, TREE_TYPE (class_tree), desc, class_tree, NULL);\n+\t  u = convert (TREE_TYPE (class_tree), DECL_INITIAL (class_tree));\n \t  u = build_binary_op (EQ_EXPR, integer_type_node, t, u);\n \t  /* If so, there is already a template in the descriptor and\n \t     it is located right after the POINTER field.  The fields are\n@@ -3219,12 +3219,12 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  t = tree_cons (TYPE_FIELDS (template_type), lfield,\n \t\t\t tree_cons (TREE_CHAIN (TYPE_FIELDS (template_type)),\n                                     ufield, NULL_TREE));\n-\t  template = gnat_build_constructor (template_type, t);\n+\t  template_tree = gnat_build_constructor (template_type, t);\n \n \t  /* Otherwise use the {1, LENGTH} template we build above.  */\n \t  template_addr = build3 (COND_EXPR, p_bounds_type, u,\n \t\t\t\t  build_unary_op (ADDR_EXPR, p_bounds_type,\n-\t\t\t\t \t\t template),\n+\t\t\t\t \t\t template_tree),\n \t\t\t\t  template_addr);\n \t  break;\n \n@@ -3266,12 +3266,12 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  t = tree_cons (TYPE_FIELDS (template_type), lfield,\n \t\t\t tree_cons (TREE_CHAIN (TYPE_FIELDS (template_type)),\n                                     ufield, NULL_TREE));\n-\t  template = gnat_build_constructor (template_type, t);\n-\t  template = build3 (COND_EXPR, p_bounds_type, u,\n+\t  template_tree = gnat_build_constructor (template_type, t);\n+\t  template_tree = build3 (COND_EXPR, p_bounds_type, u,\n \t\t\t    build_call_raise (CE_Length_Check_Failed, Empty,\n \t\t\t\t\t      N_Raise_Constraint_Error),\n-\t\t\t    template);\n-\t  template_addr = build_unary_op (ADDR_EXPR, p_bounds_type, template);\n+\t\t\t    template_tree);\n+\t  template_addr = build_unary_op (ADDR_EXPR, p_bounds_type, template_tree);\n \t  break;\n \n \tcase 10: /* Class NCA */\n@@ -3302,9 +3302,9 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n   tree desc_type = TREE_TYPE (TREE_TYPE (gnu_expr));\n   tree desc = build1 (INDIRECT_REF, desc_type, gnu_expr);\n   /* The CLASS field is the 3rd field in the descriptor.  */\n-  tree class = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (desc_type)));\n+  tree class_tree = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (desc_type)));\n   /* The POINTER field is the 4th field in the descriptor.  */\n-  tree pointer = TREE_CHAIN (class);\n+  tree pointer = TREE_CHAIN (class_tree);\n \n   /* Retrieve the value of the POINTER field.  */\n   tree gnu_expr32\n@@ -3320,9 +3320,9 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n       tree template_type = TREE_TYPE (p_bounds_type);\n       tree min_field = TYPE_FIELDS (template_type);\n       tree max_field = TREE_CHAIN (TYPE_FIELDS (template_type));\n-      tree template, template_addr, aflags, dimct, t, u;\n+      tree template_tree, template_addr, aflags, dimct, t, u;\n       /* See the head comment of build_vms_descriptor.  */\n-      int iclass = TREE_INT_CST_LOW (DECL_INITIAL (class));\n+      int iclass = TREE_INT_CST_LOW (DECL_INITIAL (class_tree));\n \n       /* Convert POINTER to the type of the P_ARRAY field.  */\n       gnu_expr32 = convert (p_array_type, gnu_expr32);\n@@ -3339,25 +3339,25 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t\t\t tree_cons (max_field,\n \t\t\t\t    convert (TREE_TYPE (max_field), t),\n \t\t\t\t    NULL_TREE));\n-\t  template = gnat_build_constructor (template_type, t);\n-\t  template_addr = build_unary_op (ADDR_EXPR, NULL_TREE, template);\n+\t  template_tree = gnat_build_constructor (template_type, t);\n+\t  template_addr = build_unary_op (ADDR_EXPR, NULL_TREE, template_tree);\n \n \t  /* For class S, we are done.  */\n \t  if (iclass == 1)\n \t    break;\n \n \t  /* Test that we really have a SB descriptor, like DEC Ada.  */\n-\t  t = build3 (COMPONENT_REF, TREE_TYPE (class), desc, class, NULL);\n-\t  u = convert (TREE_TYPE (class), DECL_INITIAL (class));\n+\t  t = build3 (COMPONENT_REF, TREE_TYPE (class_tree), desc, class_tree, NULL);\n+\t  u = convert (TREE_TYPE (class_tree), DECL_INITIAL (class_tree));\n \t  u = build_binary_op (EQ_EXPR, integer_type_node, t, u);\n \t  /* If so, there is already a template in the descriptor and\n \t     it is located right after the POINTER field.  */\n \t  t = TREE_CHAIN (pointer);\n-\t  template = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n+\t  template_tree = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  /* Otherwise use the {1, LENGTH} template we build above.  */\n \t  template_addr = build3 (COND_EXPR, p_bounds_type, u,\n \t\t\t\t  build_unary_op (ADDR_EXPR, p_bounds_type,\n-\t\t\t\t \t\t template),\n+\t\t\t\t \t\t template_tree),\n \t\t\t\t  template_addr);\n \t  break;\n \n@@ -3384,12 +3384,12 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  /* There is already a template in the descriptor and it is\n \t     located at the start of block 3 (12th field).  */\n \t  t = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (t))));\n-\t  template = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-\t  template = build3 (COND_EXPR, p_bounds_type, u,\n+\t  template_tree = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n+\t  template_tree = build3 (COND_EXPR, p_bounds_type, u,\n \t\t\t    build_call_raise (CE_Length_Check_Failed, Empty,\n \t\t\t\t\t      N_Raise_Constraint_Error),\n-\t\t\t    template);\n-\t  template_addr = build_unary_op (ADDR_EXPR, p_bounds_type, template);\n+\t\t\t    template_tree);\n+\t  template_addr = build_unary_op (ADDR_EXPR, p_bounds_type, template_tree);\n \t  break;\n \n \tcase 10: /* Class NCA */\n@@ -3720,7 +3720,7 @@ convert_to_fat_pointer (tree type, tree expr)\n   tree template_type = TREE_TYPE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (type))));\n   tree p_array_type = TREE_TYPE (TYPE_FIELDS (type));\n   tree etype = TREE_TYPE (expr);\n-  tree template;\n+  tree template_tree;\n \n   /* If EXPR is null, make a fat pointer that contains null pointers to the\n      template and array.  */\n@@ -3746,15 +3746,15 @@ convert_to_fat_pointer (tree type, tree expr)\n       else\n \texpr = build1 (INDIRECT_REF, TREE_TYPE (etype), expr);\n \n-      template = build_component_ref (expr, NULL_TREE, fields, false);\n+      template_tree = build_component_ref (expr, NULL_TREE, fields, false);\n       expr = build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t     build_component_ref (expr, NULL_TREE,\n \t\t\t\t\t\t  TREE_CHAIN (fields), false));\n     }\n \n   /* Otherwise, build the constructor for the template.  */\n   else\n-    template = build_template (template_type, TREE_TYPE (etype), expr);\n+    template_tree = build_template (template_type, TREE_TYPE (etype), expr);\n \n   /* The final result is a constructor for the fat pointer.\n \n@@ -3774,7 +3774,7 @@ convert_to_fat_pointer (tree type, tree expr)\n        tree_cons (TYPE_FIELDS (type),\n \t\t  convert (p_array_type, expr),\n \t\t  tree_cons (TREE_CHAIN (TYPE_FIELDS (type)),\n-\t\t\t     build_unary_op (ADDR_EXPR, NULL_TREE, template),\n+\t\t\t     build_unary_op (ADDR_EXPR, NULL_TREE, template_tree),\n \t\t\t     NULL_TREE)));\n }\n \f\n@@ -4304,20 +4304,20 @@ tree\n maybe_unconstrained_array (tree exp)\n {\n   enum tree_code code = TREE_CODE (exp);\n-  tree new;\n+  tree new_tree;\n \n   switch (TREE_CODE (TREE_TYPE (exp)))\n     {\n     case UNCONSTRAINED_ARRAY_TYPE:\n       if (code == UNCONSTRAINED_ARRAY_REF)\n \t{\n-\t  new\n+\t  new_tree\n \t    = build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t      build_component_ref (TREE_OPERAND (exp, 0),\n \t\t\t\t\t\t   get_identifier (\"P_ARRAY\"),\n \t\t\t\t\t\t   NULL_TREE, false));\n-\t  TREE_READONLY (new) = TREE_STATIC (new) = TREE_READONLY (exp);\n-\t  return new;\n+\t  TREE_READONLY (new_tree) = TREE_STATIC (new_tree) = TREE_READONLY (exp);\n+\t  return new_tree;\n \t}\n \n       else if (code == NULL_EXPR)\n@@ -4331,12 +4331,12 @@ maybe_unconstrained_array (tree exp)\n \t it contains a template.  */\n       if (TYPE_IS_PADDING_P (TREE_TYPE (exp)))\n \t{\n-\t  new = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (exp))), exp);\n-\t  if (TREE_CODE (TREE_TYPE (new)) == RECORD_TYPE\n-\t      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (new)))\n+\t  new_tree = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (exp))), exp);\n+\t  if (TREE_CODE (TREE_TYPE (new_tree)) == RECORD_TYPE\n+\t      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (new_tree)))\n \t    return\n-\t      build_component_ref (new, NULL_TREE,\n-\t\t\t\t   TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (new))),\n+\t      build_component_ref (new_tree, NULL_TREE,\n+\t\t\t\t   TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (new_tree))),\n \t\t\t\t   0);\n \t}\n       else if (TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (exp)))"}, {"sha": "f4d5b121e40fff5daed2db0592d8625bea33d94d", "filename": "gcc/ada/tb-gcc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bf68a93f60cf873c4a0713bb11480d838fb5af0/gcc%2Fada%2Ftb-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bf68a93f60cf873c4a0713bb11480d838fb5af0/gcc%2Fada%2Ftb-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftb-gcc.c?ref=6bf68a93f60cf873c4a0713bb11480d838fb5af0", "patch": "@@ -64,13 +64,13 @@ typedef struct {\n static _Unwind_Reason_Code\n trace_callback (struct _Unwind_Context * uw_context, uw_data_t * uw_data)\n {\n-  void * pc;\n+  char * pc;\n \n #if defined (__ia64__) && defined (__hpux__)\n   /* Work around problem with _Unwind_GetIP on ia64 HP-UX. */\n   uwx_get_reg ((struct uwx_env *) uw_context, UWX_REG_IP, (uint64_t *) &pc);\n #else\n-  pc = (void *) _Unwind_GetIP (uw_context);\n+  pc = (char *) _Unwind_GetIP (uw_context);\n #endif\n \n   if (uw_data->n_frames_skipped < uw_data->n_frames_to_skip)"}]}