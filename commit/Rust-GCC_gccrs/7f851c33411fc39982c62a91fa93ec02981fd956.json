{"sha": "7f851c33411fc39982c62a91fa93ec02981fd956", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y4NTFjMzM0MTFmYzM5OTgyYzYyYTkxZmE5M2VjMDI5ODFmZDk1Ng==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-12T10:29:21Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-12T12:10:10Z"}, "message": "libstdc++: Fix __numeric_traits_integer<__int20> [PR 97798]\n\nThe expression used to calculate the maximum value for an integer type\nassumes that the number of bits in the value representation is always\nsizeof(T) * CHAR_BIT. This is not true for the __int20 type on msp430,\nwhich has only 20 bits in the value representation but 32 bits in the\nobject representation. This causes an integer overflow in a constant\nexpression, which is ill-formed.\n\nThis problem was already solved by DJ for std::numeric_limits<__int20>\nby generalizing the helper macros to use a specified number of bits\ninstead of assuming sizeof(T) * CHAR_BIT. Then the INT_N_n types can\nspecify the number of bits using the __GLIBCXX_BITSIZE_INT_N_n macros\nthat the compiler defines.\n\nI'm using a slightly different approach here. I've replaced the helper\nmacros entirely, and just expanded the calculations in the initializers\nfor the static data members. By reordering the data members we can reuse\n__is_signed and __digits in the other initializers. This removes the\nrepetition of expanding __glibcxx_signed(T) and __glibcxx_digits(T)\nmultiple times in each initializer.\n\nThe __is_integer_nonstrict trait now defines a new constant, __width,\nwhich is sizeof(T) * CHAR_BIT by default (defined as an enumerator so\nthat no storage is needed for a static data member). By specializing\n__is_integer_nonstrict for the INT_N types that have padding bits, we\ncan provide the correct width via the __GLIBCXX_BITSIZE_INT_N_n macros.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/97798\n\t* include/ext/numeric_traits.h (__glibcxx_signed)\n\t(__glibcxx_digits, __glibcxx_min, __glibcxx_max): Remove\n\tmacros.\n\t(__is_integer_nonstrict::__width): Define new constant.\n\t(__numeric_traits_integer): Define constants in terms of each\n\tother and __is_integer_nonstrict::__width, rather than the\n\tremoved macros.\n\t(_GLIBCXX_INT_N_TRAITS): Macro to define explicit\n\tspecializations for non-standard integer types.", "tree": {"sha": "270d1245f57c1acb3d6f5ce6c77b4d129939c04f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/270d1245f57c1acb3d6f5ce6c77b4d129939c04f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f851c33411fc39982c62a91fa93ec02981fd956", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f851c33411fc39982c62a91fa93ec02981fd956", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f851c33411fc39982c62a91fa93ec02981fd956", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f851c33411fc39982c62a91fa93ec02981fd956/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c3beb1a8137460bc485f9fbe3be8b21ee7f91a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c3beb1a8137460bc485f9fbe3be8b21ee7f91a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c3beb1a8137460bc485f9fbe3be8b21ee7f91a2"}], "stats": {"total": 104, "additions": 68, "deletions": 36}, "files": [{"sha": "c29f9f21d1aaa981059bd3615971152c52f5bc11", "filename": "libstdc++-v3/include/ext/numeric_traits.h", "status": "modified", "additions": 68, "deletions": 36, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f851c33411fc39982c62a91fa93ec02981fd956/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f851c33411fc39982c62a91fa93ec02981fd956/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric_traits.h?ref=7f851c33411fc39982c62a91fa93ec02981fd956", "patch": "@@ -39,31 +39,23 @@ namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Compile time constants for builtin types.\n-  // In C++98 std::numeric_limits member functions cannot be used for this.\n-#define __glibcxx_signed(_Tp) ((_Tp)(-1) < 0)\n-#define __glibcxx_digits(_Tp) \\\n-  (sizeof(_Tp) * __CHAR_BIT__ - __glibcxx_signed(_Tp))\n-\n-#define __glibcxx_min(_Tp) \\\n-  (__glibcxx_signed(_Tp) ? -__glibcxx_max(_Tp) - 1 : (_Tp)0)\n-\n-#define __glibcxx_max(_Tp) \\\n-  (__glibcxx_signed(_Tp) ? \\\n-   (((((_Tp)1 << (__glibcxx_digits(_Tp) - 1)) - 1) << 1) + 1) : ~(_Tp)0)\n-\n+  // In C++98 std::numeric_limits member functions are not constant expressions\n+  // (that changed in C++11 with the addition of 'constexpr').\n+  // Even for C++11, this header is smaller than <limits> and can be used\n+  // when only is_signed, digits, min, or max values are needed for integers,\n+  // or is_signed, digits10, max_digits10, or max_exponent10 for floats.\n+\n+  // Unlike __is_integer (and std::is_integral) this trait is true for\n+  // non-standard built-in integer types such as __int128 and __int20.\n   template<typename _Tp>\n     struct __is_integer_nonstrict\n     : public std::__is_integer<_Tp>\n-    { };\n-\n-#if defined __STRICT_ANSI__ && defined __SIZEOF_INT128__\n-  // __is_integer<__int128> is false, but we still want to allow it here.\n-  template<> struct __is_integer_nonstrict<__int128>\n-  { enum { __value = 1 }; typedef std::__true_type __type; };\n+    {\n+      using std::__is_integer<_Tp>::__value;\n \n-  template<> struct __is_integer_nonstrict<unsigned __int128>\n-  { enum { __value = 1 }; typedef std::__true_type __type; };\n-#endif\n+      // The number of bits in the value representation.\n+      enum { __width = __value ? sizeof(_Tp) * __CHAR_BIT__ : 0 };\n+    };\n \n   template<typename _Value>\n     struct __numeric_traits_integer\n@@ -73,14 +65,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    \"invalid specialization\");\n #endif\n \n-      // Only integers for initialization of member constant.\n-      static const _Value __min = __glibcxx_min(_Value);\n-      static const _Value __max = __glibcxx_max(_Value);\n-\n-      // NB: these two also available in std::numeric_limits as compile\n-      // time constants, but <limits> is big and we avoid including it.\n-      static const bool __is_signed = __glibcxx_signed(_Value);\n-      static const int __digits = __glibcxx_digits(_Value);      \n+      // NB: these two are also available in std::numeric_limits as compile\n+      // time constants, but <limits> is big and we can avoid including it.\n+      static const bool __is_signed = (_Value)(-1) < 0;\n+      static const int __digits\n+\t= __is_integer_nonstrict<_Value>::__width - __is_signed;\n+\n+      // The initializers must be constants so that __max and __min are too.\n+      static const _Value __max = __is_signed\n+\t? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)\n+\t: ~(_Value)0;\n+      static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;\n     };\n \n   template<typename _Value>\n@@ -95,16 +90,52 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Value>\n     const int __numeric_traits_integer<_Value>::__digits;\n \n+  // Enable __numeric_traits_integer for types where the __is_integer_nonstrict\n+  // primary template doesn't give the right answer.\n+#define _GLIBCXX_INT_N_TRAITS(T, WIDTH)\t\t\t\\\n+  template<> struct __is_integer_nonstrict<T>\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    enum { __value = 1 };\t\t\t\t\\\n+    typedef std::__true_type __type;\t\t\t\\\n+    enum { __width = WIDTH };\t\t\t\t\\\n+  };\t\t\t\t\t\t\t\\\n+  template<> struct __is_integer_nonstrict<unsigned T>\t\\\n+  {\t\t\t\t\t\t\t\\\n+    enum { __value = 1 };\t\t\t\t\\\n+    typedef std::__true_type __type;\t\t\t\\\n+    enum { __width = WIDTH };\t\t\t\t\\\n+  };\n+\n+  // We need to specify the width for some __intNN types because they\n+  // have padding bits, e.g. the object representation of __int20 has 32 bits,\n+  // but its width (number of bits in the value representation) is only 20.\n+#if defined __GLIBCXX_TYPE_INT_N_0 && __GLIBCXX_BITSIZE_INT_N_0 % __CHAR_BIT__\n+  _GLIBCXX_INT_N_TRAITS(__GLIBCXX_TYPE_INT_N_0, __GLIBCXX_BITSIZE_INT_N_0)\n+#endif\n+#if defined __GLIBCXX_TYPE_INT_N_1 && __GLIBCXX_BITSIZE_INT_N_1 % __CHAR_BIT__\n+  _GLIBCXX_INT_N_TRAITS(__GLIBCXX_TYPE_INT_N_1, __GLIBCXX_BITSIZE_INT_N_1)\n+#endif\n+#if defined __GLIBCXX_TYPE_INT_N_2 && __GLIBCXX_BITSIZE_INT_N_2 % __CHAR_BIT__\n+  _GLIBCXX_INT_N_TRAITS(__GLIBCXX_TYPE_INT_N_2, __GLIBCXX_BITSIZE_INT_N_2)\n+#endif\n+#if defined __GLIBCXX_TYPE_INT_N_3 && __GLIBCXX_BITSIZE_INT_N_3 % __CHAR_BIT__\n+  _GLIBCXX_INT_N_TRAITS(__GLIBCXX_TYPE_INT_N_3, __GLIBCXX_BITSIZE_INT_N_3)\n+#endif\n+\n+#if defined __STRICT_ANSI__ && defined __SIZEOF_INT128__\n+  // In strict modes __is_integer<__int128> is false,\n+  // but we still want to define __numeric_traits_integer<__int128>.\n+  _GLIBCXX_INT_N_TRAITS(__int128, 128)\n+#endif\n+\n+#undef _GLIBCXX_INT_N_TRAITS\n+\n #if __cplusplus >= 201103L\n+  /// Convenience alias for __numeric_traits<integer-type>.\n   template<typename _Tp>\n     using __int_traits = __numeric_traits_integer<_Tp>;\n #endif\n \n-#undef __glibcxx_signed\n-#undef __glibcxx_digits\n-#undef __glibcxx_min\n-#undef __glibcxx_max\n-\n #define __glibcxx_floating(_Tp, _Fval, _Dval, _LDval) \\\n   (std::__are_same<_Tp, float>::__value ? _Fval \\\n    : std::__are_same<_Tp, double>::__value ? _Dval : _LDval)\n@@ -120,10 +151,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   __glibcxx_floating(_Tp, __FLT_MAX_10_EXP__, __DBL_MAX_10_EXP__, \\\n \t\t     __LDBL_MAX_10_EXP__)\n \n+  // N.B. this only supports float, double and long double (no __float128 etc.)\n   template<typename _Value>\n     struct __numeric_traits_floating\n     {\n-      // Only floating point types. See N1822. \n+      // Only floating point types. See N1822.\n       static const int __max_digits10 = __glibcxx_max_digits10(_Value);\n \n       // See above comment...\n@@ -159,4 +191,4 @@ _GLIBCXX_END_NAMESPACE_VERSION\n #undef __glibcxx_digits10\n #undef __glibcxx_max_exponent10\n \n-#endif \n+#endif"}]}