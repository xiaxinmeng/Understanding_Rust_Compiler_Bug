{"sha": "b6219f420890d1f8e4eb4bc586499c75f4612f38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYyMTlmNDIwODkwZDFmOGU0ZWI0YmM1ODY0OTljNzVmNDYxMmYzOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2008-01-25T19:45:11Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2008-01-25T19:45:11Z"}, "message": "re PR c++/31780 (ICE with incompatible types for ?: with \"complex type\" conversion)\n\n        PR c++/31780\n        * call.c (standard_conversion): Allow conversion from integer/real\n        to complex.\n        (compare_ics): Such a conversion is worse than a normal arithmetic\n        conversion.\n\nCo-Authored-By: Mark Mitchell <mark@codesourcery.com>\n\nFrom-SVN: r131832", "tree": {"sha": "d63ed006c4a66749f6e6342f438d45f7bd2ec881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d63ed006c4a66749f6e6342f438d45f7bd2ec881"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6219f420890d1f8e4eb4bc586499c75f4612f38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6219f420890d1f8e4eb4bc586499c75f4612f38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6219f420890d1f8e4eb4bc586499c75f4612f38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6219f420890d1f8e4eb4bc586499c75f4612f38/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7fa4b30a1674de01bf12aef706415e876aa08e4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fa4b30a1674de01bf12aef706415e876aa08e4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fa4b30a1674de01bf12aef706415e876aa08e4f"}], "stats": {"total": 64, "additions": 58, "deletions": 6}, "files": [{"sha": "9383ccd95e662c1c395bd2b884851bcda5bca788", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6219f420890d1f8e4eb4bc586499c75f4612f38/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6219f420890d1f8e4eb4bc586499c75f4612f38/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b6219f420890d1f8e4eb4bc586499c75f4612f38", "patch": "@@ -1,3 +1,12 @@\n+2008-01-25  Jason Merrill  <jason@redhat.com>\n+\t    Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/31780\n+\t* call.c (standard_conversion): Allow conversion from integer/real\n+\tto complex.\n+\t(compare_ics): Such a conversion is worse than a normal arithmetic\n+\tconversion.\n+\t\n 2008-01-25  Richard Guenther  <rguenther@suse.de>\n \n \tPR c++/33887"}, {"sha": "3cd80b40daccc2b275811f545df154e902aedee1", "filename": "gcc/cp/call.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6219f420890d1f8e4eb4bc586499c75f4612f38/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6219f420890d1f8e4eb4bc586499c75f4612f38/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b6219f420890d1f8e4eb4bc586499c75f4612f38", "patch": "@@ -846,8 +846,8 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n     }\n   /* We don't check for ENUMERAL_TYPE here because there are no standard\n      conversions to enum type.  */\n-  else if (tcode == INTEGER_TYPE || tcode == BOOLEAN_TYPE\n-\t   || tcode == REAL_TYPE)\n+  /* As an extension, allow conversion to complex type.  */\n+  else if (ARITHMETIC_TYPE_P (to))\n     {\n       if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE))\n \treturn NULL;\n@@ -5937,17 +5937,17 @@ compare_ics (conversion *ics1, conversion *ics2)\n       from_type2 = t2->type;\n     }\n \n+  /* One sequence can only be a subsequence of the other if they start with\n+     the same type.  They can start with different types when comparing the\n+     second standard conversion sequence in two user-defined conversion\n+     sequences.  */\n   if (same_type_p (from_type1, from_type2))\n     {\n       if (is_subseq (ics1, ics2))\n \treturn 1;\n       if (is_subseq (ics2, ics1))\n \treturn -1;\n     }\n-  /* Otherwise, one sequence cannot be a subsequence of the other; they\n-     don't start with the same type.  This can happen when comparing the\n-     second standard conversion sequence in two user-defined conversion\n-     sequences.  */\n \n   /* [over.ics.rank]\n \n@@ -5977,6 +5977,21 @@ compare_ics (conversion *ics1, conversion *ics2)\n   to_type1 = ics1->type;\n   to_type2 = ics2->type;\n \n+  /* A conversion from scalar arithmetic type to complex is worse than a\n+     conversion between scalar arithmetic types.  */\n+  if (same_type_p (from_type1, from_type2)\n+      && ARITHMETIC_TYPE_P (from_type1)\n+      && ARITHMETIC_TYPE_P (to_type1)\n+      && ARITHMETIC_TYPE_P (to_type2)\n+      && ((TREE_CODE (to_type1) == COMPLEX_TYPE)\n+\t  != (TREE_CODE (to_type2) == COMPLEX_TYPE)))\n+    {\n+      if (TREE_CODE (to_type1) == COMPLEX_TYPE)\n+\treturn -1;\n+      else\n+\treturn 1;\n+    }\n+\n   if (TYPE_PTR_P (from_type1)\n       && TYPE_PTR_P (from_type2)\n       && TYPE_PTR_P (to_type1)"}, {"sha": "062c2d44bed7c356784184ffaeb812524615bf6a", "filename": "gcc/testsuite/g++.dg/ext/complex3.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6219f420890d1f8e4eb4bc586499c75f4612f38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplex3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6219f420890d1f8e4eb4bc586499c75f4612f38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplex3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcomplex3.C?ref=b6219f420890d1f8e4eb4bc586499c75f4612f38", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/31780\n+// { dg-do run }\n+// { dg-options \"\" }\n+\n+// Test that we can implicitly convert to _Complex, but that it's worse\n+// than a scalar arithmetic conversion.\n+\n+extern \"C\" void exit (int);\n+\n+int r = 0;\n+\n+void f (_Complex int) { ++r; }\n+void f (double) { }\n+\n+void g (_Complex int) { }\n+\n+int main()\n+{\n+  f (1);\n+  g (1);\n+\n+  return r;\n+}\n+\n+void bar()\n+{\n+  r ? 0i : 0;\n+}"}]}