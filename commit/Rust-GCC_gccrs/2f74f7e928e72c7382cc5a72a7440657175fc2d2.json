{"sha": "2f74f7e928e72c7382cc5a72a7440657175fc2d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY3NGY3ZTkyOGU3MmM3MzgyY2M1YTcyYTc0NDA2NTcxNzVmYzJkMg==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2000-10-20T15:59:07Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2000-10-20T15:59:07Z"}, "message": "c-common.c (check_format_info_recurse): Extract string constant initializers from non-volatile constant arrays and...\n\n\t* c-common.c (check_format_info_recurse): Extract string constant\n\tinitializers from non-volatile constant arrays and check them as\n\tformats.\n\t* c-typeck.c (decl_constant_value): Don't check pedantic or check\n\tfor DECL_MODE (decl) != BLKmode.\n\t(decl_constant_value_for_broken_optimization): New function which\n\tincludes these checks.\n\t(default_conversion, convert_for_assignment, digest_init): Use\n\tdecl_constant_value_for_broken_optimization instead of\n\tdecl_constant_value.\n\ntestsuite:\n\t* gcc.dg/format-array-1.c: New test.\n\nFrom-SVN: r36965", "tree": {"sha": "ff7e2b47546c45c64b35f3cf895f47da04cf520d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff7e2b47546c45c64b35f3cf895f47da04cf520d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f74f7e928e72c7382cc5a72a7440657175fc2d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f74f7e928e72c7382cc5a72a7440657175fc2d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f74f7e928e72c7382cc5a72a7440657175fc2d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f74f7e928e72c7382cc5a72a7440657175fc2d2/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "971774bbc15f4c0e411a921bace1fda1471433fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/971774bbc15f4c0e411a921bace1fda1471433fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/971774bbc15f4c0e411a921bace1fda1471433fc"}], "stats": {"total": 112, "additions": 106, "deletions": 6}, "files": [{"sha": "5a71796a0b52712aa899e151f671eedcc9efb0e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f74f7e928e72c7382cc5a72a7440657175fc2d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f74f7e928e72c7382cc5a72a7440657175fc2d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f74f7e928e72c7382cc5a72a7440657175fc2d2", "patch": "@@ -1,3 +1,16 @@\n+2000-10-20  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.c (check_format_info_recurse): Extract string constant\n+\tinitializers from non-volatile constant arrays and check them as\n+\tformats.\n+\t* c-typeck.c (decl_constant_value): Don't check pedantic or check\n+\tfor DECL_MODE (decl) != BLKmode.\n+\t(decl_constant_value_for_broken_optimization): New function which\n+\tincludes these checks.\n+\t(default_conversion, convert_for_assignment, digest_init): Use\n+\tdecl_constant_value_for_broken_optimization instead of\n+\tdecl_constant_value.\n+\n 2000-10-20  Mark Mitchell  <mark@codesourcery.com>\n \n \t* tree.h (DECL_ALIGN_UNIT): New macro."}, {"sha": "e9ce259901acdaa65e4b6f1be1f07f234ea6914c", "filename": "gcc/c-common.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f74f7e928e72c7382cc5a72a7440657175fc2d2/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f74f7e928e72c7382cc5a72a7440657175fc2d2/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=2f74f7e928e72c7382cc5a72a7440657175fc2d2", "patch": "@@ -2344,6 +2344,8 @@ check_format_info_recurse (status, res, info, format_tree, params, arg_num)\n {\n   int format_length;\n   const char *format_chars;\n+  tree array_size = 0;\n+  tree array_init;\n \n   if (TREE_CODE (format_tree) == NOP_EXPR)\n     {\n@@ -2436,6 +2438,17 @@ check_format_info_recurse (status, res, info, format_tree, params, arg_num)\n       return;\n     }\n   format_tree = TREE_OPERAND (format_tree, 0);\n+  if (TREE_CODE (format_tree) == VAR_DECL\n+      && TREE_CODE (TREE_TYPE (format_tree)) == ARRAY_TYPE\n+      && (array_init = decl_constant_value (format_tree)) != format_tree\n+      && TREE_CODE (array_init) == STRING_CST)\n+    {\n+      /* Extract the string constant initializer.  Note that this may include\n+\t a trailing NUL character that is not in the array (e.g.\n+\t const char a[3] = \"foo\";).  */\n+      array_size = DECL_SIZE_UNIT (format_tree);\n+      format_tree = array_init;\n+    }\n   if (TREE_CODE (format_tree) != STRING_CST)\n     {\n       res->number_non_literal++;\n@@ -2448,6 +2461,20 @@ check_format_info_recurse (status, res, info, format_tree, params, arg_num)\n     }\n   format_chars = TREE_STRING_POINTER (format_tree);\n   format_length = TREE_STRING_LENGTH (format_tree);\n+  if (array_size != 0)\n+    {\n+      /* Variable length arrays can't be initialized.  */\n+      if (TREE_CODE (array_size) != INTEGER_CST)\n+\tabort ();\n+      if (host_integerp (array_size, 0))\n+\t{\n+\t  HOST_WIDE_INT array_size_value = TREE_INT_CST_LOW (array_size);\n+\t  if (array_size_value > 0\n+\t      && array_size_value == (int) array_size_value\n+\t      && format_length > array_size_value)\n+\t    format_length = array_size_value;\n+\t}\n+    }\n   if (format_length < 1)\n     {\n       res->number_unterminated++;"}, {"sha": "e055e988beb063f8fd3f2320272876f597c9b63e", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f74f7e928e72c7382cc5a72a7440657175fc2d2/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f74f7e928e72c7382cc5a72a7440657175fc2d2/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=2f74f7e928e72c7382cc5a72a7440657175fc2d2", "patch": "@@ -54,6 +54,7 @@ static tree qualify_type\t\tPARAMS ((tree, tree));\n static int comp_target_types\t\tPARAMS ((tree, tree));\n static int function_types_compatible_p\tPARAMS ((tree, tree));\n static int type_lists_compatible_p\tPARAMS ((tree, tree));\n+static tree decl_constant_value_for_broken_optimization PARAMS ((tree));\n static tree lookup_field\t\tPARAMS ((tree, tree, tree *));\n static tree convert_arguments\t\tPARAMS ((tree, tree, tree, tree));\n static tree pointer_int_sum\t\tPARAMS ((enum tree_code, tree, tree));\n@@ -844,7 +845,6 @@ decl_constant_value (decl)\n   if (/* Don't change a variable array bound or initial value to a constant\n \t in a place where a variable is invalid.  */\n       current_function_decl != 0\n-      && ! pedantic\n       && ! TREE_THIS_VOLATILE (decl)\n       && TREE_READONLY (decl)\n       && DECL_INITIAL (decl) != 0\n@@ -854,12 +854,29 @@ decl_constant_value (decl)\n \t or a variable, then re-evaluating it could give different results.  */\n       && TREE_CONSTANT (DECL_INITIAL (decl))\n       /* Check for cases where this is sub-optimal, even though valid.  */\n-      && TREE_CODE (DECL_INITIAL (decl)) != CONSTRUCTOR\n-      && DECL_MODE (decl) != BLKmode)\n+      && TREE_CODE (DECL_INITIAL (decl)) != CONSTRUCTOR)\n     return DECL_INITIAL (decl);\n   return decl;\n }\n \n+/* Return either DECL or its known constant value (if it has one), but\n+   return DECL if pedantic or DECL has mode BLKmode.  This is for\n+   bug-compatibility with the old behavior of decl_constant_value\n+   (before GCC 3.0); every use of this function is a bug and it should\n+   be removed before GCC 3.1.  It is not appropriate to use pedantic\n+   in a way that affects optimization, and BLKmode is probably not the\n+   right test for avoiding misoptimizations either.  */\n+\n+static tree\n+decl_constant_value_for_broken_optimization (decl)\n+     tree decl;\n+{\n+  if (pedantic || DECL_MODE (decl) == BLKmode)\n+    return decl;\n+  else\n+    return decl_constant_value (decl);\n+}\n+\n /* Perform default promotions for C data used in expressions.\n    Arrays and functions are converted to pointers;\n    enumeral types or short or char, to int.\n@@ -881,7 +898,7 @@ default_conversion (exp)\n      address of the array produces consistent results.  */\n   else if (optimize && TREE_CODE (exp) == VAR_DECL && code != ARRAY_TYPE)\n     {\n-      exp = decl_constant_value (exp);\n+      exp = decl_constant_value_for_broken_optimization (exp);\n       type = TREE_TYPE (exp);\n     }\n \n@@ -4019,7 +4036,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n       || TREE_CODE (TREE_TYPE (rhs)) == FUNCTION_TYPE)\n     rhs = default_conversion (rhs);\n   else if (optimize && TREE_CODE (rhs) == VAR_DECL)\n-    rhs = decl_constant_value (rhs);\n+    rhs = decl_constant_value_for_broken_optimization (rhs);\n \n   rhstype = TREE_TYPE (rhs);\n   coder = TREE_CODE (rhstype);\n@@ -4695,7 +4712,7 @@ digest_init (type, init, require_constant, constructor_constant)\n \t}\n \n       if (optimize && TREE_CODE (inside_init) == VAR_DECL)\n-\tinside_init = decl_constant_value (inside_init);\n+\tinside_init = decl_constant_value_for_broken_optimization (inside_init);\n \n       /* Compound expressions can only occur here if -pedantic or\n \t -pedantic-errors is specified.  In the later case, we always want"}, {"sha": "ebaa50f34db2e89587f5fd5508f3b2a9f7d1e178", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f74f7e928e72c7382cc5a72a7440657175fc2d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f74f7e928e72c7382cc5a72a7440657175fc2d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f74f7e928e72c7382cc5a72a7440657175fc2d2", "patch": "@@ -1,3 +1,7 @@\n+2000-10-20  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcc.dg/format-array-1.c: New test.\n+\n 2000-10-18  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcc.dg/c90-printf-1.c, gcc.dg/c90-scanf-1.c: Add tests for"}, {"sha": "8d632a7f914a9405115953029f7c1d2bbd23b639", "filename": "gcc/testsuite/gcc.dg/format-array-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f74f7e928e72c7382cc5a72a7440657175fc2d2/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-array-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f74f7e928e72c7382cc5a72a7440657175fc2d2/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-array-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-array-1.c?ref=2f74f7e928e72c7382cc5a72a7440657175fc2d2", "patch": "@@ -0,0 +1,39 @@\n+/* Test for format checking of constant arrays.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -Wformat=2\" } */\n+\n+extern int printf (const char *, ...);\n+\n+const char a1[] = \"foo\";\n+const char a2[] = \"foo%d\";\n+const char b[3] = \"foo\";\n+static const char c1[] = \"foo\";\n+static const char c2[] = \"foo%d\";\n+char d[] = \"foo\";\n+volatile const char e[] = \"foo\";\n+\n+void\n+foo (int i, long l)\n+{\n+  const char p1[] = \"bar\";\n+  const char p2[] = \"bar%d\";\n+  static const char q1[] = \"bar\";\n+  static const char q2[] = \"bar%d\";\n+  printf (a1);\n+  printf (a2, i);\n+  printf (a2, l); /* { dg-warning \"format\" \"wrong type with array\" } */\n+  printf (b); /* { dg-warning \"unterminated\" \"unterminated array\" } */\n+  printf (c1);\n+  printf (c2, i);\n+  printf (c2, l); /* { dg-warning \"format\" \"wrong type with array\" } */\n+  printf (p1);\n+  printf (p2, i);\n+  printf (p2, l); /* { dg-warning \"format\" \"wrong type with array\" } */\n+  printf (q1);\n+  printf (q2, i);\n+  printf (q2, l); /* { dg-warning \"format\" \"wrong type with array\" } */\n+  /* Volatile or non-constant arrays must not be checked.  */\n+  printf (d); /* { dg-warning \"not a string literal\" \"non-const\" } */\n+  printf ((const char *)e); /* { dg-warning \"not a string literal\" \"volatile\" } */\n+}"}]}