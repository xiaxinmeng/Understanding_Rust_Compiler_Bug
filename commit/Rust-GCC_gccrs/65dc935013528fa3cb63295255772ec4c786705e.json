{"sha": "65dc935013528fa3cb63295255772ec4c786705e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVkYzkzNTAxMzUyOGZhM2NiNjMyOTUyNTU3NzJlYzRjNzg2NzA1ZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-03-13T17:06:42Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-03-13T17:06:42Z"}, "message": "expmed.c (expand_mult): Use synthetic multiplication sequences for more classes of DImode...\n\n\n\t* expmed.c (expand_mult): Use synthetic multiplication sequences for\n\tmore classes of DImode multiplication by constant.  Allow both\n\tmultiplication by small negative constants (by performing a\n\tmultiplication by a positive constant and negating the result) and\n\tmultiplications by large powers of two, by using a left shift.\n\nFrom-SVN: r96377", "tree": {"sha": "e4f79f782ea00652a790b8ec5f90102f92e7c5d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4f79f782ea00652a790b8ec5f90102f92e7c5d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65dc935013528fa3cb63295255772ec4c786705e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65dc935013528fa3cb63295255772ec4c786705e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65dc935013528fa3cb63295255772ec4c786705e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65dc935013528fa3cb63295255772ec4c786705e/comments", "author": null, "committer": null, "parents": [{"sha": "92c54d2c4e98cddf1b357014473870a00738882d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92c54d2c4e98cddf1b357014473870a00738882d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92c54d2c4e98cddf1b357014473870a00738882d"}], "stats": {"total": 133, "additions": 90, "deletions": 43}, "files": [{"sha": "f3a66255d94f82abbc086ffbeb04547bbd743367", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65dc935013528fa3cb63295255772ec4c786705e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65dc935013528fa3cb63295255772ec4c786705e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65dc935013528fa3cb63295255772ec4c786705e", "patch": "@@ -1,3 +1,11 @@\n+2005-03-13  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* expmed.c (expand_mult): Use synthetic multiplication sequences for\n+\tmore classes of DImode multiplication by constant.  Allow both\n+\tmultiplication by small negative constants (by performing a \n+\tmultiplication by a positive constant and negating the result) and\n+\tmultiplications by large powers of two, by using a left shift.\n+\n 2005-03-13  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-into-ssa.c (find_idf): Speed up by putting the indexes"}, {"sha": "093791e148a20214d602821596950b5729e7da9b", "filename": "gcc/expmed.c", "status": "modified", "additions": 82, "deletions": 43, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65dc935013528fa3cb63295255772ec4c786705e/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65dc935013528fa3cb63295255772ec4c786705e/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=65dc935013528fa3cb63295255772ec4c786705e", "patch": "@@ -3011,57 +3011,96 @@ rtx\n expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t     int unsignedp)\n {\n-  rtx const_op1 = op1;\n   enum mult_variant variant;\n   struct algorithm algorithm;\n+  int max_cost;\n \n-  /* synth_mult does an `unsigned int' multiply.  As long as the mode is\n-     less than or equal in size to `unsigned int' this doesn't matter.\n-     If the mode is larger than `unsigned int', then synth_mult works only\n-     if the constant value exactly fits in an `unsigned int' without any\n-     truncation.  This means that multiplying by negative values does\n-     not work; results are off by 2^32 on a 32 bit machine.  */\n-\n-  /* If we are multiplying in DImode, it may still be a win\n-     to try to work with shifts and adds.  */\n-  if (GET_CODE (op1) == CONST_DOUBLE\n-      && GET_MODE_CLASS (GET_MODE (op1)) == MODE_INT\n-      && HOST_BITS_PER_INT >= BITS_PER_WORD\n-      && CONST_DOUBLE_HIGH (op1) == 0)\n-    const_op1 = GEN_INT (CONST_DOUBLE_LOW (op1));\n-  else if (HOST_BITS_PER_INT < GET_MODE_BITSIZE (mode)\n-\t   && GET_CODE (op1) == CONST_INT\n-\t   && INTVAL (op1) < 0)\n-    const_op1 = 0;\n-\n-  /* We used to test optimize here, on the grounds that it's better to\n-     produce a smaller program when -O is not used.\n-     But this causes such a terrible slowdown sometimes\n-     that it seems better to use synth_mult always.  */\n-\n-  if (const_op1 && GET_CODE (const_op1) == CONST_INT\n+  /* Handling const0_rtx here allows us to use zero as a rogue value for\n+     coeff below.  */\n+  if (op1 == const0_rtx)\n+    return const0_rtx;\n+  if (op1 == const1_rtx)\n+    return op0;\n+  if (op1 == constm1_rtx)\n+    return expand_unop (mode,\n+\t\t\tGET_MODE_CLASS (mode) == MODE_INT\n+\t\t\t&& !unsignedp && flag_trapv\n+\t\t\t? negv_optab : neg_optab,\n+\t\t\top0, target, 0);\n+\n+  /* These are the operations that are potentially turned into a sequence\n+     of shifts and additions.  */\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n       && (unsignedp || !flag_trapv))\n     {\n-      HOST_WIDE_INT coeff = INTVAL (const_op1);\n-      int mult_cost;\n+      HOST_WIDE_INT coeff = 0;\n \n-      /* Special case powers of two.  */\n-      if (EXACT_POWER_OF_2_OR_ZERO_P (coeff))\n+      /* synth_mult does an `unsigned int' multiply.  As long as the mode is\n+\t less than or equal in size to `unsigned int' this doesn't matter.\n+\t If the mode is larger than `unsigned int', then synth_mult works\n+\t only if the constant value exactly fits in an `unsigned int' without\n+\t any truncation.  This means that multiplying by negative values does\n+\t not work; results are off by 2^32 on a 32 bit machine.  */\n+\n+      if (GET_CODE (op1) == CONST_INT)\n \t{\n-\t  if (coeff == 0)\n-\t    return const0_rtx;\n-\t  if (coeff == 1)\n-\t    return op0;\n-\t  return expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t       build_int_cst (NULL_TREE, floor_log2 (coeff)),\n-\t\t\t       target, unsignedp);\n+\t  /* Attempt to handle multiplication of DImode values by negative\n+\t     coefficients, by performing the multiplication by a positive\n+\t     multiplier and then inverting the result.  */\n+\t  if (INTVAL (op1) < 0\n+\t      && GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT)\n+\t    {\n+\t      /* Its safe to use -INTVAL (op1) even for INT_MIN, as the\n+\t\t result is interpreted as an unsigned coefficient.  */\n+\t      max_cost = rtx_cost (gen_rtx_MULT (mode, op0, op1), SET)\n+\t\t\t - neg_cost[mode];\n+\t      if (max_cost > 0\n+\t\t  && choose_mult_variant (mode, -INTVAL (op1), &algorithm,\n+\t\t\t\t\t  &variant, max_cost))\n+\t\t{\n+\t\t  rtx temp = expand_mult_const (mode, op0, -INTVAL (op1),\n+\t\t\t\t\t\tNULL_RTX, &algorithm,\n+\t\t\t\t\t\tvariant);\n+\t\t  return expand_unop (mode, neg_optab, temp, target, 0);\n+\t\t}\n+\t    }\n+\t  else coeff = INTVAL (op1);\n+\t}\n+      else if (GET_CODE (op1) == CONST_DOUBLE)\n+\t{\n+\t  /* If we are multiplying in DImode, it may still be a win\n+\t     to try to work with shifts and adds.  */\n+\t  if (CONST_DOUBLE_HIGH (op1) == 0)\n+\t    coeff = CONST_DOUBLE_LOW (op1);\n+\t  else if (CONST_DOUBLE_LOW (op1) == 0\n+\t\t   && EXACT_POWER_OF_2_OR_ZERO_P (CONST_DOUBLE_HIGH (op1)))\n+\t    {\n+\t      int shift = floor_log2 (CONST_DOUBLE_HIGH (op1))\n+\t\t\t  + HOST_BITS_PER_WIDE_INT;\n+\t      return expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t\t   build_int_cst (NULL_TREE, shift),\n+\t\t\t\t   target, unsignedp);\n+\t    }\n+\t}\n+        \n+      /* We used to test optimize here, on the grounds that it's better to\n+\t produce a smaller program when -O is not used.  But this causes\n+\t such a terrible slowdown sometimes that it seems better to always\n+\t use synth_mult.  */\n+      if (coeff != 0)\n+\t{\n+\t  /* Special case powers of two.  */\n+\t  if (EXACT_POWER_OF_2_OR_ZERO_P (coeff))\n+\t    return expand_shift (LSHIFT_EXPR, mode, op0,\n+\t\t\t\t build_int_cst (NULL_TREE, floor_log2 (coeff)),\n+\t\t\t\t target, unsignedp);\n+\n+\t  max_cost = rtx_cost (gen_rtx_MULT (mode, op0, op1), SET);\n+\t  if (choose_mult_variant (mode, coeff, &algorithm, &variant,\n+\t\t\t\t   max_cost))\n+\t    return expand_mult_const (mode, op0, coeff, target,\n+\t\t\t\t      &algorithm, variant);\n \t}\n-\n-      mult_cost = rtx_cost (gen_rtx_MULT (mode, op0, op1), SET);\n-      if (choose_mult_variant (mode, coeff, &algorithm, &variant,\n-\t\t\t       mult_cost))\n-\treturn expand_mult_const (mode, op0, coeff, target,\n-\t\t\t\t  &algorithm, variant);\n     }\n \n   if (GET_CODE (op0) == CONST_DOUBLE)"}]}