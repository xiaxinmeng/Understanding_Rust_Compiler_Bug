{"sha": "c572e5ba687d4e4c7c380e47750ead7c84a8ef39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU3MmU1YmE2ODdkNGU0YzdjMzgwZTQ3NzUwZWFkN2M4NGE4ZWYzOQ==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-04-21T05:40:51Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-04-21T05:40:51Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r808", "tree": {"sha": "1e418d77f48b5851e28606eae9aadd75114b51ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e418d77f48b5851e28606eae9aadd75114b51ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c572e5ba687d4e4c7c380e47750ead7c84a8ef39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c572e5ba687d4e4c7c380e47750ead7c84a8ef39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c572e5ba687d4e4c7c380e47750ead7c84a8ef39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c572e5ba687d4e4c7c380e47750ead7c84a8ef39/comments", "author": null, "committer": null, "parents": [{"sha": "5944b57e254405218515bf28f3b1a06aa711083e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5944b57e254405218515bf28f3b1a06aa711083e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5944b57e254405218515bf28f3b1a06aa711083e"}], "stats": {"total": 838, "additions": 676, "deletions": 162}, "files": [{"sha": "30858eaf8995906adff4f2eb74796fa8c1ce24ee", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 117, "deletions": 7, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c572e5ba687d4e4c7c380e47750ead7c84a8ef39/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c572e5ba687d4e4c7c380e47750ead7c84a8ef39/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c572e5ba687d4e4c7c380e47750ead7c84a8ef39", "patch": "@@ -45,6 +45,7 @@ extern char *strcat ();\n \n char *singlemove_string ();\n char *output_move_const_single ();\n+char *output_fp_cc0_set ();\n \n static char *hi_reg_name[] = HI_REGISTER_NAMES;\n static char *qi_reg_name[] = QI_REGISTER_NAMES;\n@@ -65,6 +66,12 @@ enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n   /* arg pointer */\n   INDEX_REGS\n };\n+\n+/* Test and compare insns in i386.md store the information needed to\n+   generate branch and scc insns here.  */\n+\n+struct rtx_def *i386_compare_op0, *i386_compare_op1;\n+struct rtx_def *(*i386_compare_gen)(), *(*i386_compare_gen_eq)();\n \f\n /* Output an insn whose source is a 386 integer register.  SRC is the\n    rtx for the register, and TEMPLATE is the op-code template.  SRC may\n@@ -1353,6 +1360,8 @@ notice_update_cc (exp)\n \t  CC_STATUS_INIT;\n \t  if (! stack_regs_mentioned_p (SET_SRC (XVECEXP (exp, 0, 0))))\n \t    cc_status.value1 = SET_SRC (XVECEXP (exp, 0, 0));\n+\n+\t  cc_status.flags |= CC_IN_80387;\n \t  return;\n \t}\n       CC_STATUS_INIT;\n@@ -1679,14 +1688,17 @@ output_fix_trunc (insn, operands)\n \f\n /* Output code for INSN to compare OPERANDS.  The two operands might\n    not have the same mode: one might be within a FLOAT or FLOAT_EXTEND\n-   expression. */\n+   expression.  If the compare is in mode CCFPEQmode, use an opcode that\n+   will not fault if a qNaN is present. */\n \n char *\n output_float_compare (insn, operands)\n      rtx insn;\n      rtx *operands;\n {\n   int stack_top_dies;\n+  rtx body = XVECEXP (PATTERN (insn), 0, 0);\n+  int unordered_compare = GET_MODE (SET_SRC (body)) == CCFPEQmode;\n \n   if (! STACK_TOP_P (operands[0]))\n     abort ();\n@@ -1702,15 +1714,21 @@ output_float_compare (insn, operands)\n \t is also a stack register that dies, then this must be a\n \t `fcompp' float compare */\n \n-      output_asm_insn (\"fcompp\", operands);\n+      if (unordered_compare)\n+\toutput_asm_insn (\"fucompp\", operands);\n+      else\n+\toutput_asm_insn (\"fcompp\", operands);\n     }\n   else\n     {\n       static char buf[100];\n \n-      /* Decide if this is the integer or float compare opcode. */\n+      /* Decide if this is the integer or float compare opcode, or the\n+\t unordered float compare. */\n \n-      if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_FLOAT)\n+      if (unordered_compare)\n+\tstrcpy (buf, \"fucom\");\n+      else if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_FLOAT)\n \tstrcpy (buf, \"fcom\");\n       else\n \tstrcpy (buf, \"ficom\");\n@@ -1728,10 +1746,102 @@ output_float_compare (insn, operands)\n \n   /* Now retrieve the condition code. */\n \n-  output_asm_insn (AS1 (fnsts%W2,%2), operands);\n+  return output_fp_cc0_set (insn);\n+}\n+\f\n+/* Output opcodes to transfer the results of FP compare or test INSN\n+   from the FPU to the CPU flags.  If TARGET_IEEE_FP, ensure that if the\n+   result of the compare or test is unordered, no comparison operator\n+   succeeds except NE.  Return an output template, if any.  */\n+\n+char *\n+output_fp_cc0_set (insn)\n+     rtx insn;\n+{\n+  rtx xops[3];\n+  rtx unordered_label;\n+  rtx next;\n+  enum rtx_code code;\n+\n+  xops[0] = gen_rtx (REG, HImode, 0);\n+  output_asm_insn (AS1 (fnsts%W0,%0), xops);\n+\n+  if (! TARGET_IEEE_FP)\n+    return \"sahf\";\n \n-  cc_status.flags |= CC_IN_80387;\n-  return \"sahf\";\n+  next = next_cc0_user (insn);\n+\n+  if (GET_CODE (next) == JUMP_INSN\n+      && GET_CODE (PATTERN (next)) == SET\n+      && SET_DEST (PATTERN (next)) == pc_rtx\n+      && GET_CODE (SET_SRC (PATTERN (next))) == IF_THEN_ELSE)\n+    {\n+      code = GET_CODE (XEXP (SET_SRC (PATTERN (next)), 0));\n+    }\n+  else if (GET_CODE (PATTERN (next)) == SET)\n+    {\n+      code = GET_CODE (SET_SRC (PATTERN (next)));\n+    }\n+  else\n+    abort ();\n+\n+  xops[0] = gen_rtx (REG, QImode, 0);\n+\n+  switch (code)\n+    {\n+    case GT:\n+      xops[1] = gen_rtx (CONST_INT, VOIDmode, 0x45);\n+      output_asm_insn (AS2 (and%B0,%1,%h0), xops);\n+      /* je label */\n+      break;\n+\n+    case LT:\n+      xops[1] = gen_rtx (CONST_INT, VOIDmode, 0x45);\n+      xops[2] = gen_rtx (CONST_INT, VOIDmode, 0x01);\n+      output_asm_insn (AS2 (and%B0,%1,%h0), xops);\n+      output_asm_insn (AS2 (cmp%B0,%2,%h0), xops);\n+      /* je label */\n+      break;\n+\n+    case GE:\n+      xops[1] = gen_rtx (CONST_INT, VOIDmode, 0x05);\n+      output_asm_insn (AS2 (and%B0,%1,%h0), xops);\n+      /* je label */\n+      break;\n+\n+    case LE:\n+      xops[1] = gen_rtx (CONST_INT, VOIDmode, 0x45);\n+      xops[2] = gen_rtx (CONST_INT, VOIDmode, 0x40);\n+      output_asm_insn (AS2 (and%B0,%1,%h0), xops);\n+      output_asm_insn (AS1 (dec%B0,%h0), xops);\n+      output_asm_insn (AS2 (cmp%B0,%2,%h0), xops);\n+      /* jb label */\n+      break;\n+\n+    case EQ:\n+      xops[1] = gen_rtx (CONST_INT, VOIDmode, 0x45);\n+      xops[2] = gen_rtx (CONST_INT, VOIDmode, 0x40);\n+      output_asm_insn (AS2 (and%B0,%1,%h0), xops);\n+      output_asm_insn (AS2 (cmp%B0,%2,%h0), xops);\n+      /* je label */\n+      break;\n+\n+    case NE:\n+      xops[1] = gen_rtx (CONST_INT, VOIDmode, 0x44);\n+      xops[2] = gen_rtx (CONST_INT, VOIDmode, 0x40);\n+      output_asm_insn (AS2 (and%B0,%1,%h0), xops);\n+      output_asm_insn (AS2 (xor%B0,%2,%h0), xops);\n+      /* jne label */\n+      break;\n+\n+    case GTU:\n+    case LTU:\n+    case GEU:\n+    case LEU:\n+    default:\n+      abort ();\n+    }\n+  RET;\n }\n \f\n #ifdef HANDLE_PRAGMA"}, {"sha": "e2a5cc9c44c4be20796a087c37877eee901766af", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c572e5ba687d4e4c7c380e47750ead7c84a8ef39/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c572e5ba687d4e4c7c380e47750ead7c84a8ef39/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c572e5ba687d4e4c7c380e47750ead7c84a8ef39", "patch": "@@ -61,6 +61,11 @@ extern int target_flags;\n    Meaningful only on svr3.  */\n #define TARGET_SVR3_SHLIB (target_flags & 040)\n \n+/* Use IEEE floating point comparisons.  These handle correctly the cases\n+   where the result of a comparison is unordered.  Normally SIGFPE is\n+   generated in such cases, in which case this isn't needed.  */\n+#define TARGET_IEEE_FP (target_flags & 0100)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -79,6 +84,8 @@ extern int target_flags;\n     { \"noregparm\", -020},\t\t\t\\\n     { \"svr3-shlib\", 040},\t\t\t\\\n     { \"nosvr3-shlib\", -040},\t\t\t\\\n+    { \"ieee-fp\", 0100},\t\t\t\t\\\n+    { \"noieee-fp\", -0100},\t\t\t\\\n     { \"\", TARGET_DEFAULT}}\n \f\n /* target machine storage layout */\n@@ -1146,6 +1153,33 @@ while (0)\n    : REG_P (RTX) ? 1\t\t\t\t\t\t\\\n    : 2)\n \f\n+/* Add any extra modes needed to represent the condition code.\n+\n+   For the i386, we need separate modes when floating-point equality\n+   comparisons are being done.  */\n+\n+#define EXTRA_CC_MODES CCFPEQmode\n+\n+/* Define the names for the modes specified above.  */\n+#define EXTRA_CC_NAMES \"CCFPEQ\"\n+\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.\n+\n+   For floating-point equality comparisons, CCFPEQmode should be used.\n+   VOIDmode should be used in all other cases.  */\n+\n+#define SELECT_CC_MODE(OP,X) \\\n+  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\\\n+   && ((OP) == EQ || (OP) == NE) ? CCFPEQmode : CCmode)\n+\n+/* Define the information needed to generate branch and scc insns.  This is\n+   stored from the compare operation.  Note that we can't use \"rtx\" here\n+   since it hasn't been defined!  */\n+\n+extern struct rtx_def *i386_compare_op0, *i386_compare_op1;\n+extern struct rtx_def *(*i386_compare_gen)(), *(*i386_compare_gen_eq)();\n+\n /* Tell final.c how to eliminate redundant test instructions.  */\n \n /* Here we define machine-dependent flags and fields in cc_status"}, {"sha": "319a9342c070eac690521dadddeede11c2c90fc9", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 506, "deletions": 136, "changes": 642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c572e5ba687d4e4c7c380e47750ead7c84a8ef39/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c572e5ba687d4e4c7c380e47750ead7c84a8ef39/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=c572e5ba687d4e4c7c380e47750ead7c84a8ef39", "patch": "@@ -62,7 +62,11 @@\n ;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n ;; be folded while optimizing anyway.\n \n-(define_insn \"tstsi\"\n+;; All test insns have expanders that save the operands away without\n+;; actually generating RTL.  The bCOND or sCOND (emitted immediately\n+;; after the tstM or cmp) will actually emit the tstM or cmpM.\n+\n+(define_insn \"tstsi_cc\"\n   [(set (cc0)\n \t(match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n   \"\"\n@@ -75,7 +79,18 @@\n   return AS2 (cmp%L0,%1,%0);\n }\")\n \n-(define_insn \"tsthi\"\n+(define_expand \"tstsi\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"nonimmediate_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  i386_compare_gen = gen_tstsi_cc;\n+  i386_compare_op0 = operands[0];\n+  DONE;\n+}\")\n+\n+(define_insn \"tsthi_cc\"\n   [(set (cc0)\n \t(match_operand:HI 0 \"nonimmediate_operand\" \"rm\"))]\n   \"\"\n@@ -88,7 +103,18 @@\n   return AS2 (cmp%W0,%1,%0);\n }\")\n \n-(define_insn \"tstqi\"\n+(define_expand \"tsthi\"\n+  [(set (cc0)\n+\t(match_operand:HI 0 \"nonimmediate_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  i386_compare_gen = gen_tsthi_cc;\n+  i386_compare_op0 = operands[0];\n+  DONE;\n+}\")\n+\n+(define_insn \"tstqi_cc\"\n   [(set (cc0)\n \t(match_operand:QI 0 \"nonimmediate_operand\" \"qm\"))]\n   \"\"\n@@ -101,54 +127,90 @@\n   return AS2 (cmp%B0,%1,%0);\n }\")\n \n-(define_insn \"tstsf\"\n+(define_expand \"tstqi\"\n+  [(set (cc0)\n+\t(match_operand:QI 0 \"nonimmediate_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  i386_compare_gen = gen_tstqi_cc;\n+  i386_compare_op0 = operands[0];\n+  DONE;\n+}\")\n+\n+(define_insn \"tstsf_cc\"\n   [(set (cc0)\n \t(match_operand:SF 0 \"register_operand\" \"f\"))\n    (clobber (match_scratch:HI 1 \"=a\"))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 && ! TARGET_IEEE_FP\"\n   \"*\n {\n   if (! STACK_TOP_P (operands[0]))\n     abort ();\n \n   output_asm_insn (\\\"ftst\\\", operands);\n-  cc_status.flags |= CC_IN_80387;\n \n   if (find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n     output_asm_insn (AS1 (fstp,%y0), operands);\n \n-  output_asm_insn (AS1 (fnsts%W1,%1), operands);\n+  return (char *) output_fp_cc0_set (insn);\n+}\")\n+\n+;; Don't generate tstsf if generating IEEE code, since the `ftst' opcode\n+;; isn't IEEE compliant.\n \n-  return \\\"sahf\\\";\n+(define_expand \"tstsf\"\n+  [(parallel [(set (cc0)\n+\t\t   (match_operand:SF 0 \"register_operand\" \"\"))\n+\t      (clobber (match_scratch:HI 1 \"\"))])]\n+  \"TARGET_80387 && ! TARGET_IEEE_FP\"\n+  \"\n+{\n+  i386_compare_gen = gen_tstsf_cc;\n+  i386_compare_op0 = operands[0];\n+  DONE;\n }\")\n \n-(define_insn \"tstdf\"\n+(define_insn \"tstdf_cc\"\n   [(set (cc0)\n \t(match_operand:DF 0 \"register_operand\" \"f\"))\n    (clobber (match_scratch:HI 1 \"=a\"))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 && ! TARGET_IEEE_FP\"\n   \"*\n {\n   if (! STACK_TOP_P (operands[0]))\n     abort ();\n \n   output_asm_insn (\\\"ftst\\\", operands);\n-  cc_status.flags |= CC_IN_80387;\n \n   if (find_regno_note (insn, REG_DEAD, FIRST_STACK_REG))\n     output_asm_insn (AS1 (fstp,%y0), operands);\n \n-  output_asm_insn (AS1 (fnsts%W1,%1), operands);\n+  return (char *) output_fp_cc0_set (insn);\n+}\")\n \n-  return \\\"sahf\\\";\n+;; Don't generate tstdf if generating IEEE code, since the `ftst' opcode\n+;; isn't IEEE compliant.\n+\n+(define_expand \"tstdf\"\n+  [(parallel [(set (cc0)\n+\t\t   (match_operand:DF 0 \"register_operand\" \"\"))\n+\t      (clobber (match_scratch:HI 1 \"\"))])]\n+  \"TARGET_80387 && ! TARGET_IEEE_FP\"\n+  \"\n+{\n+  i386_compare_gen = gen_tstdf_cc;\n+  i386_compare_op0 = operands[0];\n+  DONE;\n }\")\n \f\n-;;- compare instructions\n+;;- compare instructions.  See comments above tstM patterns about\n+;;  expansion of these insns.\n \n-(define_insn \"cmpsi\"\n+(define_insn \"cmpsi_cc\"\n   [(set (cc0)\n-\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"mr,ri\")\n-\t\t (match_operand:SI 1 \"general_operand\" \"ri,mr\")))]\n+\t(compare:CC (match_operand:SI 0 \"nonimmediate_operand\" \"mr,ri\")\n+\t\t    (match_operand:SI 1 \"general_operand\" \"ri,mr\")))]\n   \"\"\n   \"*\n {\n@@ -160,10 +222,23 @@\n   return AS2 (cmp%L0,%1,%0);\n }\")\n \n-(define_insn \"cmphi\"\n+(define_expand \"cmpsi\"\n   [(set (cc0)\n-\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"mr,ri\")\n-\t\t (match_operand:HI 1 \"general_operand\" \"ri,mr\")))]\n+\t(compare:CC (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:SI 1 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  i386_compare_gen = gen_cmpsi_cc;\n+  i386_compare_op0 = operands[0];\n+  i386_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_insn \"cmphi_cc\"\n+  [(set (cc0)\n+\t(compare:CC (match_operand:HI 0 \"nonimmediate_operand\" \"mr,ri\")\n+\t\t    (match_operand:HI 1 \"general_operand\" \"ri,mr\")))]\n   \"\"\n   \"*\n {\n@@ -175,10 +250,23 @@\n   return AS2 (cmp%W0,%1,%0);\n }\")\n \n-(define_insn \"cmpqi\"\n+(define_expand \"cmphi\"\n   [(set (cc0)\n-\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"qn,mq\")\n-\t\t (match_operand:QI 1 \"general_operand\" \"qm,nq\")))]\n+\t(compare:CC (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:HI 1 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  i386_compare_gen = gen_cmphi_cc;\n+  i386_compare_op0 = operands[0];\n+  i386_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_insn \"cmpqi_cc\"\n+  [(set (cc0)\n+\t(compare:CC (match_operand:QI 0 \"nonimmediate_operand\" \"qn,mq\")\n+\t\t    (match_operand:QI 1 \"general_operand\" \"qm,nq\")))]\n   \"\"\n   \"*\n {\n@@ -190,69 +278,142 @@\n   return AS2 (cmp%B0,%1,%0);\n }\")\n \n+(define_expand \"cmpqi\"\n+  [(set (cc0)\n+\t(compare:CC (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:QI 1 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  i386_compare_gen = gen_cmpqi_cc;\n+  i386_compare_op0 = operands[0];\n+  i386_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n ;; These implement float point compares.  For each of DFmode and\n ;; SFmode, there is the normal insn, and an insn where the second operand\n ;; is converted to the desired mode.\n \n-(define_expand \"cmpdf\"\n-  [(parallel [(set (cc0)\n-\t\t   (compare (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-\t\t\t    (match_operand:DF 1 \"nonimmediate_operand\" \"\")))\n-\t      (clobber (match_scratch:HI 2 \"\"))])]\n+(define_insn \"cmpdf_cc\"\n+  [(set (cc0)\n+\t(compare:CC (match_operand:DF 0 \"register_operand\" \"f\")\n+\t\t    (match_operand:DF 1 \"nonimmediate_operand\" \"fm\")))\n+   (clobber (match_scratch:HI 2 \"=a\"))]\n   \"TARGET_80387\"\n-  \"\")\n+  \"* return (char *) output_float_compare (insn, operands);\")\n \n-(define_expand \"cmpsf\"\n-  [(parallel [(set (cc0)\n-\t\t   (compare (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n-\t\t\t    (match_operand:SF 1 \"nonimmediate_operand\" \"\")))\n-\t      (clobber (match_scratch:HI 2 \"\"))])]\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare:CC (match_operand:DF 0 \"register_operand\" \"f,f\")\n+\t\t    (float:DF\n+\t\t     (match_operand:SI 1 \"nonimmediate_operand\" \"m,!*r\"))))\n+   (clobber (match_scratch:HI 2 \"=a,a\"))]\n   \"TARGET_80387\"\n-  \"\")\n+  \"* return (char *) output_float_compare (insn, operands);\")\n \n-;; The `ble' and `blt' patterns can reverse a compare, so we must allow\n-;; an immediate operand as operand 0 in the recognizers below.\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(compare:CC (match_operand:DF 0 \"register_operand\" \"f,f\")\n+\t\t    (float_extend:DF\n+\t\t     (match_operand:SF 1 \"nonimmediate_operand\" \"fm,!*r\"))))\n+   (clobber (match_scratch:HI 2 \"=a,a\"))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_float_compare (insn, operands);\")\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(compare (match_operand:DF 0 \"general_operand\" \"f\")\n-\t\t (match_operand:DF 1 \"general_operand\" \"fm\")))\n+\t(compare:CCFPEQ (match_operand:DF 0 \"register_operand\" \"f\")\n+\t\t\t(match_operand:DF 1 \"register_operand\" \"f\")))\n    (clobber (match_scratch:HI 2 \"=a\"))]\n   \"TARGET_80387\"\n   \"* return (char *) output_float_compare (insn, operands);\")\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(compare (match_operand:DF 0 \"general_operand\" \"f,f\")\n-\t\t (float:DF (match_operand:SI 1 \"general_operand\" \"m,!*r\"))))\n-   (clobber (match_scratch:HI 2 \"=a,a\"))]\n+\t(compare:CCFPEQ (match_operand:DF 0 \"register_operand\" \"f\")\n+\t\t\t(float_extend:DF\n+\t\t\t (match_operand:SF 1 \"register_operand\" \"f\"))))\n+   (clobber (match_scratch:HI 2 \"=a\"))]\n+  \"TARGET_80387\"\n+  \"* return (char *) output_float_compare (insn, operands);\")\n+\n+(define_insn \"cmpsf_cc\"\n+  [(set (cc0)\n+\t(compare:CC (match_operand:SF 0 \"register_operand\" \"f\")\n+\t\t    (match_operand:SF 1 \"nonimmediate_operand\" \"fm\")))\n+   (clobber (match_scratch:HI 2 \"=a\"))]\n   \"TARGET_80387\"\n   \"* return (char *) output_float_compare (insn, operands);\")\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(compare (match_operand:DF 0 \"general_operand\" \"f,f\")\n-\t\t (float_extend:DF\n-\t\t  (match_operand:SF 1 \"general_operand\" \"fm,!*r\"))))\n+\t(compare:CC (match_operand:SF 0 \"register_operand\" \"f,f\")\n+\t\t    (float:SF\n+\t\t     (match_operand:SI 1 \"nonimmediate_operand\" \"m,!*r\"))))\n    (clobber (match_scratch:HI 2 \"=a,a\"))]\n   \"TARGET_80387\"\n   \"* return (char *) output_float_compare (insn, operands);\")\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(compare (match_operand:SF 0 \"general_operand\" \"f\")\n-\t\t (match_operand:SF 1 \"general_operand\" \"fm\")))\n+\t(compare:CCFPEQ (match_operand:SF 0 \"register_operand\" \"f\")\n+\t\t\t(match_operand:SF 1 \"register_operand\" \"f\")))\n    (clobber (match_scratch:HI 2 \"=a\"))]\n   \"TARGET_80387\"\n   \"* return (char *) output_float_compare (insn, operands);\")\n \n-(define_insn \"\"\n+(define_expand \"cmpdf\"\n   [(set (cc0)\n-\t(compare (match_operand:SF 0 \"general_operand\" \"f,f\")\n-\t\t (float:SF (match_operand:SI 1 \"general_operand\" \"m,!*r\"))))\n-   (clobber (match_scratch:HI 2 \"=a,a\"))]\n+\t(compare:CC (match_operand:DF 0 \"register_operand\" \"\")\n+\t\t    (match_operand:DF 1 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_80387\"\n-  \"* return (char *) output_float_compare (insn, operands);\")\n+  \"\n+{\n+  i386_compare_gen = gen_cmpdf_cc;\n+  i386_compare_gen_eq = gen_cmpdf_ccfpeq;\n+  i386_compare_op0 = operands[0];\n+  i386_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpsf\"\n+  [(set (cc0)\n+\t(compare:CC (match_operand:SF 0 \"register_operand\" \"\")\n+\t\t    (match_operand:SF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"\n+{\n+  i386_compare_gen = gen_cmpsf_cc;\n+  i386_compare_gen_eq = gen_cmpsf_ccfpeq;\n+  i386_compare_op0 = operands[0];\n+  i386_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpdf_ccfpeq\"\n+  [(parallel [(set (cc0)\n+\t\t   (compare:CCFPEQ (match_operand:DF 0 \"register_operand\" \"\")\n+\t\t\t\t   (match_operand:DF 1 \"register_operand\" \"\")))\n+\t      (clobber (match_scratch:HI 2 \"\"))])]\n+  \"TARGET_80387\"\n+  \"\n+{\n+  if (! register_operand (operands[1], DFmode))\n+    operands[1] = copy_to_mode_reg (DFmode, operands[1]);\n+}\")\n+\n+(define_expand \"cmpsf_ccfpeq\"\n+  [(parallel [(set (cc0)\n+\t\t   (compare:CCFPEQ (match_operand:SF 0 \"register_operand\" \"\")\n+\t\t\t\t   (match_operand:SF 1 \"register_operand\" \"\")))\n+\t      (clobber (match_scratch:HI 2 \"\"))])]\n+  \"TARGET_80387\"\n+  \"\n+{\n+  if (! register_operand (operands[1], SFmode))\n+    operands[1] = copy_to_mode_reg (SFmode, operands[1]);\n+}\")\n \f\n ;; logical compare\n \n@@ -1454,7 +1615,7 @@\n   return AS3 (imul%L0,%2,%1,%0);\n }\")\n \n-(define_insn \"mulqihi3_1\"\n+(define_insn \"\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=a\")\n \t(mult:SI (zero_extend:HI\n \t\t  (match_operand:QI 1 \"nonimmediate_operand\" \"%0\"))\n@@ -2645,7 +2806,24 @@\n \f\n ;; Store-flag instructions.\n \n-(define_insn \"seq\"\n+;; For all sCOND expanders, also expand the compare or test insn that\n+;; generates cc0.  Generate an equality comparison if `seq' or `sne'.\n+\n+(define_expand \"seq\"\n+  [(match_dup 1)\n+   (set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(eq:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  if (TARGET_IEEE_FP\n+      && GET_MODE_CLASS (GET_MODE (i386_compare_op0)) == MODE_FLOAT)\n+    operands[1] = (*i386_compare_gen_eq)(i386_compare_op0, i386_compare_op1);\n+  else\n+    operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\n+}\")\n+\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(eq:QI (cc0) (const_int 0)))]\n   \"\"\n@@ -2655,10 +2833,23 @@\n     return AS1 (setnb,%0);\n   else\n     return AS1 (sete,%0);\n-}\n-\")\n+}\")\n \n-(define_insn \"sne\"\n+(define_expand \"sne\"\n+  [(match_dup 1)\n+   (set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(ne:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  if (TARGET_IEEE_FP\n+      && GET_MODE_CLASS (GET_MODE (i386_compare_op0)) == MODE_FLOAT)\n+    operands[1] = (*i386_compare_gen_eq)(i386_compare_op0, i386_compare_op1);\n+  else\n+    operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\n+}\")\n+\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(ne:QI (cc0) (const_int 0)))]\n   \"\"\n@@ -2671,47 +2862,120 @@\n }\n \")\n \n-(define_insn \"sgt\"\n+(define_expand \"sgt\"\n+  [(match_dup 1)\n+   (set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(gt:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n+\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(gt:QI (cc0) (const_int 0)))]\n   \"\"\n-  \"* OUTPUT_JUMP (\\\"setg %0\\\", \\\"seta %0\\\", 0); \")\n+  \"*\n+{\n+  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n+    return AS1 (sete,%0);\n+\n+  OUTPUT_JUMP (\\\"setg %0\\\", \\\"seta %0\\\", 0);\n+}\")\n \n-(define_insn \"sgtu\"\n+(define_expand \"sgtu\"\n+  [(match_dup 1)\n+   (set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(gtu:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n+\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(gtu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"* return \\\"seta %0\\\"; \")\n \n-(define_insn \"slt\"\n+(define_expand \"slt\"\n+  [(match_dup 1)\n+   (set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(lt:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n+\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(lt:QI (cc0) (const_int 0)))]\n   \"\"\n-  \"* OUTPUT_JUMP (\\\"setl %0\\\", \\\"setb %0\\\", \\\"sets %0\\\"); \")\n+  \"*\n+{\n+  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n+    return AS1 (sete,%0);\n \n-(define_insn \"sltu\"\n+  OUTPUT_JUMP (\\\"setl %0\\\", \\\"setb %0\\\", \\\"sets %0\\\");\n+}\")\n+\n+(define_expand \"sltu\"\n+  [(match_dup 1)\n+   (set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(ltu:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n+\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(ltu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"* return \\\"setb %0\\\"; \")\n \n-(define_insn \"sge\"\n+(define_expand \"sge\"\n+  [(match_dup 1)\n+   (set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(ge:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n+\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(ge:QI (cc0) (const_int 0)))]\n   \"\"\n-  \"* OUTPUT_JUMP (\\\"setge %0\\\", \\\"setae %0\\\", \\\"setns %0\\\"); \")\n+  \"*\n+{\n+  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n+    return AS1 (sete,%0);\n \n-(define_insn \"sgeu\"\n+  OUTPUT_JUMP (\\\"setge %0\\\", \\\"setae %0\\\", \\\"setns %0\\\");\n+}\")\n+\n+(define_expand \"sgeu\"\n+  [(match_dup 1)\n+   (set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(geu:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n+\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(geu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"* return \\\"setae %0\\\"; \")\n \n-(define_insn \"sle\"\n+(define_expand \"sle\"\n+  [(match_dup 1)\n+   (set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(le:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n+\n+(define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n \t(le:QI (cc0) (const_int 0)))]\n   \"\"\n-  \"* OUTPUT_JUMP (\\\"setle %0\\\", \\\"setbe %0\\\", 0); \")\n+  \"*\n+{\n+  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n+    return AS1 (setb,%0);\n+\n+  OUTPUT_JUMP (\\\"setle %0\\\", \\\"setbe %0\\\", 0);\n+}\")\n \n (define_insn \"sleu\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=qm\")\n@@ -2722,7 +2986,27 @@\n ;; Basic conditional jump instructions.\n ;; We ignore the overflow flag for signed branch instructions.\n \n-(define_insn \"beq\"\n+;; For all bCOND expanders, also expand the compare or test insn that\n+;; generates cc0.  Generate an equality comparison if `beq' or `bne'.\n+\n+(define_expand \"beq\"\n+  [(match_dup 1)\n+   (set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (TARGET_IEEE_FP\n+      && GET_MODE_CLASS (GET_MODE (i386_compare_op0)) == MODE_FLOAT)\n+    operands[1] = (*i386_compare_gen_eq)(i386_compare_op0, i386_compare_op1);\n+  else\n+    operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\n+}\")\n+\n+(define_insn \"\"\n   [(set (pc)\n \t(if_then_else (eq (cc0)\n \t\t\t  (const_int 0))\n@@ -2737,7 +3021,24 @@\n     return \\\"je %l0\\\";\n }\")\n \n-(define_insn \"bne\"\n+(define_expand \"bne\"\n+  [(match_dup 1)\n+   (set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (TARGET_IEEE_FP\n+      && GET_MODE_CLASS (GET_MODE (i386_compare_op0)) == MODE_FLOAT)\n+    operands[1] = (*i386_compare_gen_eq)(i386_compare_op0, i386_compare_op1);\n+  else\n+    operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\n+}\")\n+\n+(define_insn \"\"\n   [(set (pc)\n \t(if_then_else (ne (cc0)\n \t\t\t  (const_int 0))\n@@ -2752,16 +3053,42 @@\n     return \\\"jne %l0\\\";\n }\")\n \n-(define_insn \"bgt\"\n+(define_expand \"bgt\"\n+  [(match_dup 1)\n+   (set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n+\n+(define_insn \"\"\n   [(set (pc)\n \t(if_then_else (gt (cc0)\n \t\t\t  (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"*OUTPUT_JUMP (\\\"jg %l0\\\", \\\"ja %l0\\\", 0)\")\n+  \"*\n+{\n+  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n+    return AS1 (je,%l0);\n+\n+  OUTPUT_JUMP (\\\"jg %l0\\\", \\\"ja %l0\\\", 0);\n+}\")\n+\n+(define_expand \"bgtu\"\n+  [(match_dup 1)\n+   (set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"bgtu\"\n+(define_insn \"\"\n   [(set (pc)\n \t(if_then_else (gtu (cc0)\n \t\t\t   (const_int 0))\n@@ -2770,35 +3097,15 @@\n   \"\"\n   \"ja %l0\")\n \n-;; There is no jump insn to check for `<' on IEEE floats.\n-;; Page 17-80 in the 80387 manual says jb, but that's wrong;\n-;; jb checks for `not >='.  So swap the operands and do `>'.\n (define_expand \"blt\"\n-  [(set (pc)\n+  [(match_dup 1)\n+   (set (pc)\n \t(if_then_else (lt (cc0)\n \t\t\t  (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  rtx prev = get_last_insn_anywhere ();\n-  rtx body = PATTERN (prev);\n-  rtx comp;\n-  if (GET_CODE (body) == SET)\n-    comp = SET_SRC (body);\n-  else\n-    comp = SET_SRC (XVECEXP (body, 0, 0));\n-\n-  if (GET_CODE (comp) == COMPARE\n-      ? GET_MODE_CLASS (GET_MODE (XEXP (comp, 0))) == MODE_FLOAT\n-      : GET_MODE_CLASS (GET_MODE (comp)) == MODE_FLOAT)\n-    {\n-      reverse_comparison (prev);\n-      emit_insn (gen_bgt (operands[0]));\n-      DONE;\n-    }\n-}\")\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2807,9 +3114,25 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"*OUTPUT_JUMP (\\\"jl %l0\\\", \\\"jb %l0\\\", \\\"js %l0\\\")\")\n+  \"*\n+{\n+  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n+    return AS1 (je,%l0);\n+\n+  OUTPUT_JUMP (\\\"jl %l0\\\", \\\"jb %l0\\\", \\\"js %l0\\\");\n+}\")\n \n-(define_insn \"bltu\"\n+(define_expand \"bltu\"\n+  [(match_dup 1)\n+   (set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n+\n+(define_insn \"\"\n   [(set (pc)\n \t(if_then_else (ltu (cc0)\n \t\t\t   (const_int 0))\n@@ -2818,16 +3141,42 @@\n   \"\"\n   \"jb %l0\")\n \n-(define_insn \"bge\"\n+(define_expand \"bge\"\n+  [(match_dup 1)\n+   (set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n+\n+(define_insn \"\"\n   [(set (pc)\n \t(if_then_else (ge (cc0)\n \t\t\t  (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"*OUTPUT_JUMP (\\\"jge %l0\\\", \\\"jae %l0\\\", \\\"jns %l0\\\")\")\n+  \"*\n+{\n+  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n+    return AS1 (je,%l0);\n+\n+  OUTPUT_JUMP (\\\"jge %l0\\\", \\\"jae %l0\\\", \\\"jns %l0\\\");\n+}\")\n+\n+(define_expand \"bgeu\"\n+  [(match_dup 1)\n+   (set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"bgeu\"\n+(define_insn \"\"\n   [(set (pc)\n \t(if_then_else (geu (cc0)\n \t\t\t   (const_int 0))\n@@ -2836,33 +3185,15 @@\n   \"\"\n   \"jae %l0\")\n \n-;; See comment on `blt', above.\n (define_expand \"ble\"\n-  [(set (pc)\n+  [(match_dup 1)\n+   (set (pc)\n \t(if_then_else (le (cc0)\n \t\t\t  (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  rtx prev = get_last_insn_anywhere ();\n-  rtx body = PATTERN (prev);\n-  rtx comp;\n-  if (GET_CODE (body) == SET)\n-    comp = SET_SRC (body);\n-  else\n-    comp = SET_SRC (XVECEXP (body, 0, 0));\n-\n-  if (GET_CODE (comp) == COMPARE\n-      ? GET_MODE_CLASS (GET_MODE (XEXP (comp, 0))) == MODE_FLOAT\n-      : GET_MODE_CLASS (GET_MODE (comp)) == MODE_FLOAT)\n-    {\n-      reverse_comparison (prev);\n-      emit_insn (gen_bge (operands[0]));\n-      DONE;\n-    }\n-}\")\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2871,9 +3202,25 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"*OUTPUT_JUMP (\\\"jle %l0\\\", \\\"jbe %l0\\\", 0) \")\n+  \"*\n+{\n+  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n+    return AS1 (jb,%l0);\n+\n+  OUTPUT_JUMP (\\\"jle %l0\\\", \\\"jbe %l0\\\", 0);\n+}\")\n+\n+(define_expand \"bleu\"\n+  [(match_dup 1)\n+   (set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"bleu\"\n+(define_insn \"\"\n   [(set (pc)\n \t(if_then_else (leu (cc0)\n \t\t\t   (const_int 0))\n@@ -2921,7 +3268,13 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"*OUTPUT_JUMP (\\\"jle %l0\\\", \\\"jbe %l0\\\", 0) \")\n+  \"*\n+{\n+  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n+    return AS1 (jne,%l0);\n+\n+  OUTPUT_JUMP (\\\"jle %l0\\\", \\\"jbe %l0\\\", 0);\n+}\")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2939,8 +3292,13 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"*OUTPUT_JUMP (\\\"jge %l0\\\", \\\"jae %l0\\\", \\\"jns %l0\\\")\n-\")\n+  \"*\n+{\n+  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n+    return AS1 (jne,%l0);\n+\n+  OUTPUT_JUMP (\\\"jge %l0\\\", \\\"jae %l0\\\", \\\"jns %l0\\\");\n+}\")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2958,7 +3316,13 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"*OUTPUT_JUMP (\\\"jl %l0\\\", \\\"jb %l0\\\", \\\"js %l0\\\")\")\n+  \"*\n+{\n+  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n+    return AS1 (jne,%l0);\n+\n+  OUTPUT_JUMP (\\\"jl %l0\\\", \\\"jb %l0\\\", \\\"js %l0\\\");\n+}\")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2976,7 +3340,13 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"*OUTPUT_JUMP (\\\"jg %l0\\\", \\\"ja %l0\\\", 0)\")\n+  \"*\n+{\n+  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387))\n+    return AS1 (jae,%l0);\n+\n+  OUTPUT_JUMP (\\\"jg %l0\\\", \\\"ja %l0\\\", 0);\n+}\")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -3015,8 +3385,8 @@\n \t(minus:SI (match_operand:SI 0 \"general_operand\" \"\")\n \t\t  (match_operand:SI 1 \"general_operand\" \"\")))\n    (set (cc0)\n-\t(compare (match_dup 5)\n-\t\t (match_operand:SI 2 \"general_operand\" \"\")))\n+\t(compare:CC (match_dup 5)\n+\t\t    (match_operand:SI 2 \"general_operand\" \"\")))\n    (set (pc)\n \t(if_then_else (gtu (cc0)\n \t\t\t   (const_int 0))\n@@ -3358,7 +3728,7 @@\n \n (define_expand \"cmpstrsi\"\n   [(parallel [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t\t   (compare\n+\t\t   (compare:CC\n \t\t    (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\"))\n \t\t    (mem:BLK (match_operand:BLK 2 \"general_operand\" \"\"))))\n \t      (use (match_operand:SI 3 \"general_operand\" \"\"))\n@@ -3383,8 +3753,8 @@\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=&q\")\n-\t(compare (mem:BLK (match_operand:SI 1 \"general_operand\" \"S\"))\n-\t\t (mem:BLK (match_operand:SI 2 \"general_operand\" \"D\"))))\n+\t(compare:CC (mem:BLK (match_operand:SI 1 \"general_operand\" \"S\"))\n+\t\t    (mem:BLK (match_operand:SI 2 \"general_operand\" \"D\"))))\n    (use (match_operand:SI 3 \"general_operand\" \"c\"))\n    (use (match_operand:SI 4 \"immediate_operand\" \"i\"))\n    (clobber (match_dup 1))\n@@ -3415,8 +3785,8 @@\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(compare (mem:BLK (match_operand:SI 0 \"general_operand\" \"S\"))\n-\t\t (mem:BLK (match_operand:SI 1 \"general_operand\" \"D\"))))\n+\t(compare:CC (mem:BLK (match_operand:SI 0 \"general_operand\" \"S\"))\n+\t\t    (mem:BLK (match_operand:SI 1 \"general_operand\" \"D\"))))\n    (use (match_operand:SI 2 \"general_operand\" \"c\"))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n    (clobber (match_dup 0))"}, {"sha": "ad8089bec12ced1b14a798ef7254841b245feb39", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c572e5ba687d4e4c7c380e47750ead7c84a8ef39/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c572e5ba687d4e4c7c380e47750ead7c84a8ef39/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=c572e5ba687d4e4c7c380e47750ead7c84a8ef39", "patch": "@@ -1516,6 +1516,23 @@ prev_label (insn)\n }\n \f\n #ifdef HAVE_cc0\n+/* INSN uses CC0 and is being moved into a delay slot.  Set up REG_CC_SETTER\n+   and REG_CC_USER notes so we can find it.  */\n+\n+void\n+link_cc0_insns (insn)\n+     rtx insn;\n+{\n+  rtx user = next_nonnote_insn (insn);\n+\n+  if (GET_CODE (user) == INSN && GET_CODE (PATTERN (user)) == SEQUENCE)\n+    user = XVECEXP (PATTERN (user), 0, 0);\n+\n+  REG_NOTES (user) = gen_rtx (INSN_LIST, REG_CC_SETTER, insn,\n+\t\t\t      REG_NOTES (user));\n+  REG_NOTES (insn) = gen_rtx (INSN_LIST, REG_CC_USER, user, REG_NOTES (insn));\n+}\n+\n /* Return the next insn that uses CC0 after INSN, which is assumed to\n    set it.  This is the inverse of prev_cc0_setter (i.e., prev_cc0_setter\n    applied to the result of this function should yield INSN)."}, {"sha": "af7af39acb9e4bceb44fcfa91c034eabb39d6c25", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c572e5ba687d4e4c7c380e47750ead7c84a8ef39/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c572e5ba687d4e4c7c380e47750ead7c84a8ef39/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=c572e5ba687d4e4c7c380e47750ead7c84a8ef39", "patch": "@@ -1825,6 +1825,8 @@ compare_for_stack_reg (insn, regstack, pat)\n \t     the case handled above.  In all other cases, emit a separate\n \t     pop and remove the death note from here. */\n \n+\t  link_cc0_insns (insn);\n+\n \t  remove_regno_note (insn, REG_DEAD, REGNO (XEXP (src2_note, 0)));\n \n \t  emit_pop_insn (insn, regstack, XEXP (src2_note, 0),"}, {"sha": "ebd208e1863819f9c7a22e7569c56f0be17c07df", "filename": "gcc/reorg.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c572e5ba687d4e4c7c380e47750ead7c84a8ef39/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c572e5ba687d4e4c7c380e47750ead7c84a8ef39/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=c572e5ba687d4e4c7c380e47750ead7c84a8ef39", "patch": "@@ -779,25 +779,6 @@ add_to_delay_list (insn, delay_list)\n \n   return delay_list;\n }   \n-\n-#ifdef HAVE_cc0\n-/* INSN uses CC0 and is being moved into a delay slot.  Set up REG_CC_SETTER\n-   and REG_CC_USER notes so we can find it.  */\n-\n-static void\n-link_cc0_insns (insn)\n-     rtx insn;\n-{\n-  rtx user = next_nonnote_insn (insn);\n-\n-  if (GET_CODE (user) == INSN && GET_CODE (PATTERN (user)) == SEQUENCE)\n-    user = XVECEXP (PATTERN (user), 0, 0);\n-\n-  REG_NOTES (user) = gen_rtx (INSN_LIST, REG_CC_SETTER, insn,\n-\t\t\t      REG_NOTES (user));\n-  REG_NOTES (insn) = gen_rtx (INSN_LIST, REG_CC_USER, user, REG_NOTES (insn));\n-}\n-#endif\n \f\n /* Delete INSN from the the delay slot of the insn that it is in.  This may\n    produce an insn without anything in its delay slots.  */"}]}