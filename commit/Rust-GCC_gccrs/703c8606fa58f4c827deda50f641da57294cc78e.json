{"sha": "703c8606fa58f4c827deda50f641da57294cc78e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAzYzg2MDZmYTU4ZjRjODI3ZGVkYTUwZjY0MWRhNTcyOTRjYzc4ZQ==", "commit": {"author": {"name": "Lawrence Crowl", "email": "crowl@google.com", "date": "2012-10-09T21:21:36Z"}, "committer": {"name": "Lawrence Crowl", "email": "crowl@gcc.gnu.org", "date": "2012-10-09T21:21:36Z"}, "message": "Change more non-GTY hash tables to use the new type-safe template hash table.\n\nConstify member function parameters that can be const.\nCorrect a couple of expressions in formerly uninstantiated templates.\n\nThe new code is 0.362% faster in bootstrap, with a 99.5% confidence of\nbeing faster.\n\nTested on x86-64.\n\n\nIndex: gcc/java/ChangeLog\n\n2012-10-01  Lawrence Crowl  <crowl@google.com>\n\n\t* Make-lang.in (JAVA_OBJS): Add dependence on hash-table.o.\n\t(JCFDUMP_OBJS): Add dependence on hash-table.o.\n\t(jcf-io.o): Add dependence on hash-table.h.\n\t* jcf-io.c (memoized_class_lookups): Change to use type-safe hash table.\n\nIndex: gcc/c/ChangeLog\n\n2012-10-09  Lawrence Crowl  <crowl@google.com>\n\n\t* Make-lang.in (c-decl.o): Add dependence on hash-table.h.\n\t* c-decl.c (detect_field_duplicates_hash): Change to new type-safe\n\thash table.\n\nIndex: gcc/objc/ChangeLog\n\n2012-10-01  Lawrence Crowl  <crowl@google.com>\n\n\t* Make-lang.in (OBJC_OBJS): Add dependence on hash-table.o.\n\t(objc-act.o): Add dependence on hash-table.h.\n\t* objc-act.c (objc_detect_field_duplicates): Change to new type-safe\n\thash table.\n\nIndex: gcc/ChangeLog\n\n2012-10-09  Lawrence Crowl  <crowl@google.com>\n\n\t* Makefile.in (fold-const.o): Add depencence on hash-table.h.\n\t(dse.o): Likewise.\n\t(cfg.o): Likewise.\n\t* fold-const.c (fold_checksum_tree): Change to new type-safe hash table.\n\t* (print_fold_checksum): Likewise.\n\t* cfg.c (var bb_original): Likewise.\n\t* (var bb_copy): Likewise.\n\t* (var loop_copy): Likewise.\n\t* hash-table.h (template hash_table): Constify parameters for find...\n\tand remove_elt... member functions.\n        (hash_table::empty) Correct size expression.\n        (hash_table::clear_slot) Correct deleted entry assignment.\n\t* dse.c (var rtx_group_table): Change to new type-safe hash table.\n\nIndex: gcc/cp/ChangeLog\n\n2012-10-09  Lawrence Crowl  <crowl@google.com>\n\n\t* Make-lang.in (class.o): Add dependence on hash-table.h.\n\t(tree.o): Likewise.\n\t(semantics.o): Likewise.\n\t* class.c (fixed_type_or_null): Change to new type-safe hash table.\n\t* tree.c (verify_stmt_tree): Likewise.\n\t(verify_stmt_tree_r): Likewise.\n\t* semantics.c (struct nrv_data): Likewise.\n\nFrom-SVN: r192273", "tree": {"sha": "6b83efb5a5d730e31c6760ce9e20be32071b13a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b83efb5a5d730e31c6760ce9e20be32071b13a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/703c8606fa58f4c827deda50f641da57294cc78e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703c8606fa58f4c827deda50f641da57294cc78e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/703c8606fa58f4c827deda50f641da57294cc78e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703c8606fa58f4c827deda50f641da57294cc78e/comments", "author": null, "committer": null, "parents": [{"sha": "aa4723d7f56dd0c690c514b50c917c827a3d56dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4723d7f56dd0c690c514b50c917c827a3d56dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa4723d7f56dd0c690c514b50c917c827a3d56dd"}], "stats": {"total": 435, "additions": 252, "deletions": 183}, "files": [{"sha": "bb1345e7fe2b5c3b7b15e24123812df1c738569a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -1,3 +1,19 @@\n+2012-10-09  Lawrence Crowl  <crowl@google.com>\n+\n+\t* Makefile.in (fold-const.o): Add depencence on hash-table.h.\n+\t(dse.o): Likewise.\n+\t(cfg.o): Likewise.\n+\t* fold-const.c (fold_checksum_tree): Change to new type-safe hash table.\n+\t* (print_fold_checksum): Likewise.\n+\t* cfg.c (var bb_original): Likewise.\n+\t* (var bb_copy): Likewise.\n+\t* (var loop_copy): Likewise.\n+\t* hash-table.h (template hash_table): Constify parameters for find...\n+\tand remove_elt... member functions.\n+        (hash_table::empty) Correct size expression.\n+        (hash_table::clear_slot) Correct deleted entry assignment.\n+\t* dse.c (var rtx_group_table): Change to new type-safe hash table.\n+\n 2012-10-09  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* basic-block. (profile_record): New struct, moved from passes.c."}, {"sha": "9376e00d992df7dcc32e49e72ed7ac7857a9fa93", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -2617,8 +2617,8 @@ tree-diagnostic.o : tree-diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfi\n    $(TREE_H) $(DIAGNOSTIC_H) tree-diagnostic.h langhooks.h $(LANGHOOKS_DEF_H) \\\n    $(VEC_H) $(TREE_PRETTY_PRINT_H)\n fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TREE_H) $(FLAGS_H) $(DIAGNOSTIC_CORE_H) $(HASHTAB_H) $(EXPR_H) $(RTL_H) \\\n-   $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H) intl.h $(TARGET_H) \\\n+   $(TREE_H) $(FLAGS_H) $(DIAGNOSTIC_CORE_H) $(HASH_TABLE_H) $(EXPR_H) \\\n+   $(RTL_H) $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H) intl.h $(TARGET_H) \\\n    $(GIMPLE_H) realmpfr.h $(TREE_FLOW_H)\n diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    version.h $(DEMANGLE_H) $(INPUT_H) intl.h $(BACKTRACE_H) $(DIAGNOSTIC_H) \\\n@@ -2930,7 +2930,7 @@ dse.o : dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(TM_P_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(RECOG_H) $(EXPR_H) $(DF_H) cselib.h $(DBGCNT_H) \\\n    $(TREE_PASS_H) alloc-pool.h $(ALIAS_H) $(OPTABS_H) $(TARGET_H) \\\n-   $(BITMAP_H) $(PARAMS_H) $(TREE_FLOW_H)\n+   $(BITMAP_H) $(PARAMS_H) $(TREE_FLOW_H) $(HASH_TABLE_H)\n fwprop.o : fwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(DIAGNOSTIC_CORE_H) insn-config.h $(RECOG_H) $(FLAGS_H) $(OBSTACK_H) $(BASIC_BLOCK_H) \\\n    $(DF_H) alloc-pool.h $(TREE_PASS_H) $(TARGET_H) \\\n@@ -3059,7 +3059,7 @@ auto-inc-dec.o : auto-inc-dec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(REGS_H) $(FLAGS_H) $(FUNCTION_H) $(EXCEPT_H) $(DIAGNOSTIC_CORE_H) $(RECOG_H) \\\n    $(EXPR_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H) $(TARGET_H)\n cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(DIAGNOSTIC_CORE_H) \\\n-   $(GGC_H) $(OBSTACK_H) alloc-pool.h $(HASHTAB_H) $(CFGLOOP_H) $(TREE_H) \\\n+   $(GGC_H) $(OBSTACK_H) alloc-pool.h $(HASH_TABLE_H) $(CFGLOOP_H) $(TREE_H) \\\n    $(BASIC_BLOCK_H)\n cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TIMEVAR_H) toplev.h $(DIAGNOSTIC_CORE_H) $(CFGLOOP_H)"}, {"sha": "dfe76e63fdaa5a524e71f163a69de0114c5aea74", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -1,3 +1,9 @@\n+2012-10-09  Lawrence Crowl  <crowl@google.com>\n+\n+\t* Make-lang.in (c-decl.o): Add dependence on hash-table.h.\n+\t* c-decl.c (detect_field_duplicates_hash): Change to new type-safe\n+\thash table.\n+\n 2012-10-09  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/54194"}, {"sha": "0340d0d9a6cb65eb4e7e315da6e84519d42d30f1", "filename": "gcc/c/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FMake-lang.in?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -162,7 +162,7 @@ c/c-decl.o : c/c-decl.c c/c-lang.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \t$(TREE_H) $(C_TREE_H) $(GGC_H) $(TARGET_H) $(FLAGS_H) $(FUNCTION_H) \\\n \toutput.h debug.h toplev.h intl.h $(TM_P_H) $(TREE_INLINE_H) \\\n \t$(TIMEVAR_H) $(OPTS_H) $(C_PRAGMA_H) gt-c-c-decl.h $(CGRAPH_H) \\\n-\t$(HASHTAB_H) $(LANGHOOKS_DEF_H) \\\n+\t$(HASH_TABLE_H) $(LANGHOOKS_DEF_H) \\\n \tdumpfile.h $(C_COMMON_H) $(CPPLIB_H) $(DIAGNOSTIC_CORE_H) \\\n \t$(INPUT_H) langhooks.h pointer-set.h tree-iterator.h \\\n \t$(PLUGIN_H) c-family/c-ada-spec.h c-family/c-objc.h"}, {"sha": "80867caa18387410545176931c638dcc32e47122", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -53,7 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"dumpfile.h\"\n #include \"cgraph.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"langhooks-def.h\"\n #include \"pointer-set.h\"\n #include \"plugin.h\"\n@@ -6895,15 +6895,16 @@ is_duplicate_field (tree x, tree y)\n    to HTAB, giving errors for any duplicates.  */\n \n static void\n-detect_field_duplicates_hash (tree fieldlist, htab_t htab)\n+detect_field_duplicates_hash (tree fieldlist,\n+\t\t\t      hash_table <pointer_hash <tree_node> > htab)\n {\n   tree x, y;\n-  void **slot;\n+  tree_node **slot;\n \n   for (x = fieldlist; x ; x = DECL_CHAIN (x))\n     if ((y = DECL_NAME (x)) != 0)\n       {\n-\tslot = htab_find_slot (htab, y, INSERT);\n+\tslot = htab.find_slot (y, INSERT);\n \tif (*slot)\n \t  {\n \t    error (\"duplicate member %q+D\", x);\n@@ -6923,7 +6924,7 @@ detect_field_duplicates_hash (tree fieldlist, htab_t htab)\n \t    && TREE_CODE (TYPE_NAME (TREE_TYPE (x))) == TYPE_DECL)\n \t  {\n \t    tree xn = DECL_NAME (TYPE_NAME (TREE_TYPE (x)));\n-\t    slot = htab_find_slot (htab, xn, INSERT);\n+\t    slot = htab.find_slot (xn, INSERT);\n \t    if (*slot)\n \t      error (\"duplicate member %q+D\", TYPE_NAME (TREE_TYPE (x)));\n \t    *slot = xn;\n@@ -6995,10 +6996,11 @@ detect_field_duplicates (tree fieldlist)\n     }\n   else\n     {\n-      htab_t htab = htab_create (37, htab_hash_pointer, htab_eq_pointer, NULL);\n+      hash_table <pointer_hash <tree_node> > htab;\n+      htab.create (37);\n \n       detect_field_duplicates_hash (fieldlist, htab);\n-      htab_delete (htab);\n+      htab.dispose ();\n     }\n }\n "}, {"sha": "f0b91e09492021b596beb82fbec58da3203be903", "filename": "gcc/cfg.c", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -53,7 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"obstack.h\"\n #include \"ggc.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"alloc-pool.h\"\n #include \"tree.h\"\n #include \"basic-block.h\"\n@@ -976,14 +976,7 @@ scale_bbs_frequencies_gcov_type (basic_block *bbs, int nbbs, gcov_type num,\n       }\n }\n \n-/* Data structures used to maintain mapping between basic blocks and\n-   copies.  */\n-static htab_t bb_original;\n-static htab_t bb_copy;\n-\n-/* And between loops and copies.  */\n-static htab_t loop_copy;\n-static alloc_pool original_copy_bb_pool;\n+/* Helper types for hash tables.  */\n \n struct htab_bb_copy_original_entry\n {\n@@ -993,25 +986,35 @@ struct htab_bb_copy_original_entry\n   int index2;\n };\n \n-static hashval_t\n-bb_copy_original_hash (const void *p)\n+struct bb_copy_hasher : typed_noop_remove <htab_bb_copy_original_entry>\n {\n-  const struct htab_bb_copy_original_entry *data\n-    = ((const struct htab_bb_copy_original_entry *)p);\n+  typedef htab_bb_copy_original_entry T;\n+  static inline hashval_t hash (const T *);\n+  static inline bool equal (const T *existing, const T * candidate);\n+};\n \n+inline hashval_t\n+bb_copy_hasher::hash (const T *data)\n+{\n   return data->index1;\n }\n-static int\n-bb_copy_original_eq (const void *p, const void *q)\n-{\n-  const struct htab_bb_copy_original_entry *data\n-    = ((const struct htab_bb_copy_original_entry *)p);\n-  const struct htab_bb_copy_original_entry *data2\n-    = ((const struct htab_bb_copy_original_entry *)q);\n \n+inline bool\n+bb_copy_hasher::equal (const T *data, const T *data2)\n+{\n   return data->index1 == data2->index1;\n }\n \n+/* Data structures used to maintain mapping between basic blocks and\n+   copies.  */\n+static hash_table <bb_copy_hasher> bb_original;\n+static hash_table <bb_copy_hasher> bb_copy;\n+\n+/* And between loops and copies.  */\n+static hash_table <bb_copy_hasher> loop_copy;\n+static alloc_pool original_copy_bb_pool;\n+\n+\n /* Initialize the data structures to maintain mapping between blocks\n    and its copies.  */\n void\n@@ -1021,10 +1024,9 @@ initialize_original_copy_tables (void)\n   original_copy_bb_pool\n     = create_alloc_pool (\"original_copy\",\n \t\t\t sizeof (struct htab_bb_copy_original_entry), 10);\n-  bb_original = htab_create (10, bb_copy_original_hash,\n-\t\t\t     bb_copy_original_eq, NULL);\n-  bb_copy = htab_create (10, bb_copy_original_hash, bb_copy_original_eq, NULL);\n-  loop_copy = htab_create (10, bb_copy_original_hash, bb_copy_original_eq, NULL);\n+  bb_original.create (10);\n+  bb_copy.create (10);\n+  loop_copy.create (10);\n }\n \n /* Free the data structures to maintain mapping between blocks and\n@@ -1033,42 +1035,40 @@ void\n free_original_copy_tables (void)\n {\n   gcc_assert (original_copy_bb_pool);\n-  htab_delete (bb_copy);\n-  htab_delete (bb_original);\n-  htab_delete (loop_copy);\n+  bb_copy.dispose ();\n+  bb_original.dispose ();\n+  loop_copy.dispose ();\n   free_alloc_pool (original_copy_bb_pool);\n-  bb_copy = NULL;\n-  bb_original = NULL;\n-  loop_copy = NULL;\n   original_copy_bb_pool = NULL;\n }\n \n /* Removes the value associated with OBJ from table TAB.  */\n \n static void\n-copy_original_table_clear (htab_t tab, unsigned obj)\n+copy_original_table_clear (hash_table <bb_copy_hasher> tab, unsigned obj)\n {\n-  void **slot;\n+  htab_bb_copy_original_entry **slot;\n   struct htab_bb_copy_original_entry key, *elt;\n \n   if (!original_copy_bb_pool)\n     return;\n \n   key.index1 = obj;\n-  slot = htab_find_slot (tab, &key, NO_INSERT);\n+  slot = tab.find_slot (&key, NO_INSERT);\n   if (!slot)\n     return;\n \n-  elt = (struct htab_bb_copy_original_entry *) *slot;\n-  htab_clear_slot (tab, slot);\n+  elt = *slot;\n+  tab.clear_slot (slot);\n   pool_free (original_copy_bb_pool, elt);\n }\n \n /* Sets the value associated with OBJ in table TAB to VAL.\n    Do nothing when data structures are not initialized.  */\n \n static void\n-copy_original_table_set (htab_t tab, unsigned obj, unsigned val)\n+copy_original_table_set (hash_table <bb_copy_hasher> tab,\n+\t\t\t unsigned obj, unsigned val)\n {\n   struct htab_bb_copy_original_entry **slot;\n   struct htab_bb_copy_original_entry key;\n@@ -1077,8 +1077,7 @@ copy_original_table_set (htab_t tab, unsigned obj, unsigned val)\n     return;\n \n   key.index1 = obj;\n-  slot = (struct htab_bb_copy_original_entry **)\n-\t\thtab_find_slot (tab, &key, INSERT);\n+  slot = tab.find_slot (&key, INSERT);\n   if (!*slot)\n     {\n       *slot = (struct htab_bb_copy_original_entry *)\n@@ -1106,7 +1105,7 @@ get_bb_original (basic_block bb)\n   gcc_assert (original_copy_bb_pool);\n \n   key.index1 = bb->index;\n-  entry = (struct htab_bb_copy_original_entry *) htab_find (bb_original, &key);\n+  entry = bb_original.find (&key);\n   if (entry)\n     return BASIC_BLOCK (entry->index2);\n   else\n@@ -1131,7 +1130,7 @@ get_bb_copy (basic_block bb)\n   gcc_assert (original_copy_bb_pool);\n \n   key.index1 = bb->index;\n-  entry = (struct htab_bb_copy_original_entry *) htab_find (bb_copy, &key);\n+  entry = bb_copy.find (&key);\n   if (entry)\n     return BASIC_BLOCK (entry->index2);\n   else\n@@ -1161,7 +1160,7 @@ get_loop_copy (struct loop *loop)\n   gcc_assert (original_copy_bb_pool);\n \n   key.index1 = loop->num;\n-  entry = (struct htab_bb_copy_original_entry *) htab_find (loop_copy, &key);\n+  entry = loop_copy.find (&key);\n   if (entry)\n     return get_loop (entry->index2);\n   else"}, {"sha": "5d091838d928244ce246c878cb8b9a7d0b66abbd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -1,3 +1,13 @@\n+2012-10-09  Lawrence Crowl  <crowl@google.com>\n+\n+\t* Make-lang.in (class.o): Add dependence on hash-table.h.\n+\t(tree.o): Likewise.\n+\t(semantics.o): Likewise.\n+\t* class.c (fixed_type_or_null): Change to new type-safe hash table.\n+\t* tree.c (verify_stmt_tree): Likewise.\n+\t(verify_stmt_tree_r): Likewise.\n+\t* semantics.c (struct nrv_data): Likewise.\n+\n 2012-10-09  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/54194"}, {"sha": "812f3cb5c7ea702991767ced0f4dd8e5e7b62eef", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -293,7 +293,7 @@ cp/typeck.o: cp/typeck.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) \\\n   c-family/c-objc.h\n cp/class.o: cp/class.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) toplev.h \\\n   $(TARGET_H) convert.h $(CGRAPH_H) dumpfile.h gt-cp-class.h \\\n-  $(SPLAY_TREE_H) pointer-set.h\n+  $(SPLAY_TREE_H) pointer-set.h $(HASH_TABLE_H)\n cp/call.o: cp/call.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) toplev.h \\\n   $(DIAGNOSTIC_CORE_H) intl.h gt-cp-call.h convert.h $(TARGET_H) langhooks.h \\\n   $(TIMEVAR_H) c-family/c-objc.h\n@@ -309,7 +309,7 @@ cp/search.o: cp/search.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) toplev.h \\\n   intl.h\n cp/tree.o: cp/tree.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) \\\n   $(TREE_INLINE_H) $(REAL_H) gt-cp-tree.h \\\n-  $(TARGET_H) debug.h $(CGRAPH_H) $(SPLAY_TREE_H) $(GIMPLE_H)\n+  $(TARGET_H) debug.h $(CGRAPH_H) $(SPLAY_TREE_H) $(GIMPLE_H) $(HASH_TABLE_H)\n cp/ptree.o: cp/ptree.c $(CXX_TREE_H) $(TM_H)\n cp/rtti.o: cp/rtti.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) convert.h \\\n   $(TARGET_H) $(C_PRAGMA_H) gt-cp-rtti.h intl.h\n@@ -327,7 +327,7 @@ cp/repo.o: cp/repo.c $(CXX_TREE_H) $(TM_H) toplev.h $(DIAGNOSTIC_CORE_H) \\\n cp/semantics.o: cp/semantics.c $(CXX_TREE_H) $(TM_H) toplev.h \\\n   $(FLAGS_H) $(RTL_H) $(TIMEVAR_H) \\\n   $(TREE_INLINE_H) $(CGRAPH_H) $(TARGET_H) $(C_COMMON_H) $(GIMPLE_H) \\\n-  bitmap.h gt-cp-semantics.h c-family/c-objc.h\n+  bitmap.h gt-cp-semantics.h c-family/c-objc.h $(HASH_TABLE_H)\n cp/dump.o: cp/dump.c $(CXX_TREE_H) $(TM_H) $(TREE_DUMP_H)\n cp/optimize.o: cp/optimize.c $(CXX_TREE_H) $(TM_H) \\\n   input.h $(PARAMS_H) debug.h $(TREE_INLINE_H) $(GIMPLE_H) \\"}, {"sha": "0e77b81c85b266ff61111b0d9dfcc347a08c6ee8", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"splay-tree.h\"\n #include \"pointer-set.h\"\n+#include \"hash-table.h\"\n \n /* The number of nested classes being processed.  If we are not in the\n    scope of any class, this is zero.  */\n@@ -6465,12 +6466,9 @@ fixed_type_or_null (tree instance, int *nonnull, int *cdtorp)\n       else if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n \t{\n \t  /* We only need one hash table because it is always left empty.  */\n-\t  static htab_t ht;\n-\t  if (!ht)\n-\t    ht = htab_create (37, \n-\t\t\t      htab_hash_pointer,\n-\t\t\t      htab_eq_pointer,\n-\t\t\t      /*htab_del=*/NULL);\n+\t  static hash_table <pointer_hash <tree_node> > ht;\n+\t  if (!ht.is_created ())\n+\t    ht.create (37); \n \n \t  /* Reference variables should be references to objects.  */\n \t  if (nonnull)\n@@ -6482,15 +6480,15 @@ fixed_type_or_null (tree instance, int *nonnull, int *cdtorp)\n \t  if (TREE_CODE (instance) == VAR_DECL\n \t      && DECL_INITIAL (instance)\n \t      && !type_dependent_expression_p_push (DECL_INITIAL (instance))\n-\t      && !htab_find (ht, instance))\n+\t      && !ht.find (instance))\n \t    {\n \t      tree type;\n-\t      void **slot;\n+\t      tree_node **slot;\n \n-\t      slot = htab_find_slot (ht, instance, INSERT);\n+\t      slot = ht.find_slot (instance, INSERT);\n \t      *slot = instance;\n \t      type = RECUR (DECL_INITIAL (instance));\n-\t      htab_remove_elt (ht, instance);\n+\t      ht.remove_elt (instance);\n \n \t      return type;\n \t    }"}, {"sha": "4beed0073fbbc9a1e918f224f505b1bcdb658bdb", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"gimple.h\"\n #include \"bitmap.h\"\n+#include \"hash-table.h\"\n \n /* There routines provide a modular interface to perform many parsing\n    operations.  They may therefore be used during actual parsing, or\n@@ -3837,7 +3838,7 @@ struct nrv_data\n {\n   tree var;\n   tree result;\n-  htab_t visited;\n+  hash_table <pointer_hash <tree_node> > visited;\n };\n \n /* Helper function for walk_tree, used by finalize_nrv below.  */\n@@ -3846,7 +3847,7 @@ static tree\n finalize_nrv_r (tree* tp, int* walk_subtrees, void* data)\n {\n   struct nrv_data *dp = (struct nrv_data *)data;\n-  void **slot;\n+  tree_node **slot;\n \n   /* No need to walk into types.  There wouldn't be any need to walk into\n      non-statements, except that we have to consider STMT_EXPRs.  */\n@@ -3885,7 +3886,7 @@ finalize_nrv_r (tree* tp, int* walk_subtrees, void* data)\n   /* Avoid walking into the same tree more than once.  Unfortunately, we\n      can't just use walk_tree_without duplicates because it would only call\n      us for the first occurrence of dp->var in the function body.  */\n-  slot = htab_find_slot (dp->visited, *tp, INSERT);\n+  slot = dp->visited.find_slot (*tp, INSERT);\n   if (*slot)\n     *walk_subtrees = 0;\n   else\n@@ -3917,9 +3918,9 @@ finalize_nrv (tree *tp, tree var, tree result)\n \n   data.var = var;\n   data.result = result;\n-  data.visited = htab_create (37, htab_hash_pointer, htab_eq_pointer, NULL);\n+  data.visited.create (37);\n   cp_walk_tree (tp, finalize_nrv_r, &data, 0);\n-  htab_delete (data.visited);\n+  data.visited.dispose ();\n }\n \f\n /* Create CP_OMP_CLAUSE_INFO for clause C.  Returns true if it is invalid.  */"}, {"sha": "a41337c211692e024cbfd8688214197d3c4e1a1e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"splay-tree.h\"\n #include \"gimple.h\" /* gimple_has_body_p */\n+#include \"hash-table.h\"\n \n static tree bot_manip (tree *, int *, void *);\n static tree bot_replace (tree *, int *, void *);\n@@ -1918,17 +1919,18 @@ static tree\n verify_stmt_tree_r (tree* tp, int * /*walk_subtrees*/, void* data)\n {\n   tree t = *tp;\n-  htab_t *statements = (htab_t *) data;\n-  void **slot;\n+  hash_table <pointer_hash <tree_node> > *statements\n+      = static_cast <hash_table <pointer_hash <tree_node> > *> (data);\n+  tree_node **slot;\n \n   if (!STATEMENT_CODE_P (TREE_CODE (t)))\n     return NULL_TREE;\n \n   /* If this statement is already present in the hash table, then\n      there is a circularity in the statement tree.  */\n-  gcc_assert (!htab_find (*statements, t));\n+  gcc_assert (!statements->find (t));\n \n-  slot = htab_find_slot (*statements, t, INSERT);\n+  slot = statements->find_slot (t, INSERT);\n   *slot = t;\n \n   return NULL_TREE;\n@@ -1941,10 +1943,10 @@ verify_stmt_tree_r (tree* tp, int * /*walk_subtrees*/, void* data)\n void\n verify_stmt_tree (tree t)\n {\n-  htab_t statements;\n-  statements = htab_create (37, htab_hash_pointer, htab_eq_pointer, NULL);\n+  hash_table <pointer_hash <tree_node> > statements;\n+  statements.create (37);\n   cp_walk_tree (&t, verify_stmt_tree_r, &statements, NULL);\n-  htab_delete (statements);\n+  statements.dispose ();\n }\n \n /* Check if the type T depends on a type with no linkage and if so, return"}, {"sha": "eff4a3909c899e4a5cc4474a63beaaa37bbd60c2", "filename": "gcc/dse.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -26,7 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n@@ -547,9 +547,6 @@ typedef struct group_info *group_info_t;\n typedef const struct group_info *const_group_info_t;\n static alloc_pool rtx_group_info_pool;\n \n-/* Tables of group_info structures, hashed by base value.  */\n-static htab_t rtx_group_table;\n-\n /* Index into the rtx_group_vec.  */\n static int rtx_group_next_id;\n \n@@ -655,23 +652,29 @@ clear_alias_set_lookup (alias_set_type alias_set)\n /* Hashtable callbacks for maintaining the \"bases\" field of\n    store_group_info, given that the addresses are function invariants.  */\n \n-static int\n-invariant_group_base_eq (const void *p1, const void *p2)\n+struct invariant_group_base_hasher : typed_noop_remove <group_info>\n+{\n+  typedef group_info T;\n+  static inline hashval_t hash (const T *);\n+  static inline bool equal (const T *, const T *);\n+};\n+\n+inline bool\n+invariant_group_base_hasher::equal (const T *gi1, const T *gi2)\n {\n-  const_group_info_t gi1 = (const_group_info_t) p1;\n-  const_group_info_t gi2 = (const_group_info_t) p2;\n   return rtx_equal_p (gi1->rtx_base, gi2->rtx_base);\n }\n \n-\n-static hashval_t\n-invariant_group_base_hash (const void *p)\n+inline hashval_t\n+invariant_group_base_hasher::hash (const T *gi)\n {\n-  const_group_info_t gi = (const_group_info_t) p;\n   int do_not_record;\n   return hash_rtx (gi->rtx_base, Pmode, &do_not_record, NULL, false);\n }\n \n+/* Tables of group_info structures, hashed by base value.  */\n+static hash_table <invariant_group_base_hasher> rtx_group_table;\n+\n \n /* Get the GROUP for BASE.  Add a new group if it is not there.  */\n \n@@ -680,14 +683,14 @@ get_group_info (rtx base)\n {\n   struct group_info tmp_gi;\n   group_info_t gi;\n-  void **slot;\n+  group_info **slot;\n \n   if (base)\n     {\n       /* Find the store_base_info structure for BASE, creating a new one\n \t if necessary.  */\n       tmp_gi.rtx_base = base;\n-      slot = htab_find_slot (rtx_group_table, &tmp_gi, INSERT);\n+      slot = rtx_group_table.find_slot (&tmp_gi, INSERT);\n       gi = (group_info_t) *slot;\n     }\n   else\n@@ -777,8 +780,7 @@ dse_step0 (void)\n     = create_alloc_pool (\"deferred_change_pool\",\n \t\t\t sizeof (struct deferred_change), 10);\n \n-  rtx_group_table = htab_create (11, invariant_group_base_hash,\n-\t\t\t\t invariant_group_base_eq, NULL);\n+  rtx_group_table.create (11);\n \n   bb_table = XNEWVEC (bb_info_t, last_basic_block);\n   rtx_group_next_id = 0;\n@@ -2872,7 +2874,7 @@ dse_step1 (void)\n \n   BITMAP_FREE (regs_live);\n   cselib_finish ();\n-  htab_empty (rtx_group_table);\n+  rtx_group_table.empty ();\n }\n \n \f\n@@ -3812,7 +3814,7 @@ dse_step7 (void)\n \n   end_alias_analysis ();\n   free (bb_table);\n-  htab_delete (rtx_group_table);\n+  rtx_group_table.dispose ();\n   VEC_free (group_info_t, heap, rtx_group_vec);\n   BITMAP_FREE (all_blocks);\n   BITMAP_FREE (scratch);"}, {"sha": "99655a1df9c5e63694cd57188c0a3a04783a3dd5", "filename": "gcc/fold-const.c", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -56,7 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"intl.h\"\n #include \"ggc.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"langhooks.h\"\n #include \"md5.h\"\n #include \"gimple.h\"\n@@ -14320,7 +14320,8 @@ fold (tree expr)\n #ifdef ENABLE_FOLD_CHECKING\n #undef fold\n \n-static void fold_checksum_tree (const_tree, struct md5_ctx *, htab_t);\n+static void fold_checksum_tree (const_tree, struct md5_ctx *,\n+\t\t\t\thash_table <pointer_hash <tree_node> >);\n static void fold_check_failed (const_tree, const_tree);\n void print_fold_checksum (const_tree);\n \n@@ -14334,20 +14335,20 @@ fold (tree expr)\n   tree ret;\n   struct md5_ctx ctx;\n   unsigned char checksum_before[16], checksum_after[16];\n-  htab_t ht;\n+  hash_table <pointer_hash <tree_node> > ht;\n \n-  ht = htab_create (32, htab_hash_pointer, htab_eq_pointer, NULL);\n+  ht.create (32);\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (expr, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_before);\n-  htab_empty (ht);\n+  ht.empty ();\n \n   ret = fold_1 (expr);\n \n   md5_init_ctx (&ctx);\n   fold_checksum_tree (expr, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_after);\n-  htab_delete (ht);\n+  ht.dispose ();\n \n   if (memcmp (checksum_before, checksum_after, 16))\n     fold_check_failed (expr, ret);\n@@ -14360,13 +14361,13 @@ print_fold_checksum (const_tree expr)\n {\n   struct md5_ctx ctx;\n   unsigned char checksum[16], cnt;\n-  htab_t ht;\n+  hash_table <pointer_hash <tree_node> > ht;\n \n-  ht = htab_create (32, htab_hash_pointer, htab_eq_pointer, NULL);\n+  ht.create (32);\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (expr, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum);\n-  htab_delete (ht);\n+  ht.dispose ();\n   for (cnt = 0; cnt < 16; ++cnt)\n     fprintf (stderr, \"%02x\", checksum[cnt]);\n   putc ('\\n', stderr);\n@@ -14379,17 +14380,18 @@ fold_check_failed (const_tree expr ATTRIBUTE_UNUSED, const_tree ret ATTRIBUTE_UN\n }\n \n static void\n-fold_checksum_tree (const_tree expr, struct md5_ctx *ctx, htab_t ht)\n+fold_checksum_tree (const_tree expr, struct md5_ctx *ctx,\n+\t\t    hash_table <pointer_hash <tree_node> > ht)\n {\n-  void **slot;\n+  tree_node **slot;\n   enum tree_code code;\n   union tree_node buf;\n   int i, len;\n \n  recursive_label:\n   if (expr == NULL)\n     return;\n-  slot = (void **) htab_find_slot (ht, expr, INSERT);\n+  slot = ht.find_slot (expr, INSERT);\n   if (*slot != NULL)\n     return;\n   *slot = CONST_CAST_TREE (expr);\n@@ -14538,12 +14540,13 @@ debug_fold_checksum (const_tree t)\n   int i;\n   unsigned char checksum[16];\n   struct md5_ctx ctx;\n-  htab_t ht = htab_create (32, htab_hash_pointer, htab_eq_pointer, NULL);\n+  hash_table <pointer_hash <tree_node> > ht;\n+  ht.create (32);\n \n   md5_init_ctx (&ctx);\n   fold_checksum_tree (t, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum);\n-  htab_empty (ht);\n+  ht.empty ();\n \n   for (i = 0; i < 16; i++)\n     fprintf (stderr, \"%d \", checksum[i]);\n@@ -14566,13 +14569,13 @@ fold_build1_stat_loc (location_t loc,\n #ifdef ENABLE_FOLD_CHECKING\n   unsigned char checksum_before[16], checksum_after[16];\n   struct md5_ctx ctx;\n-  htab_t ht;\n+  hash_table <pointer_hash <tree_node> > ht;\n \n-  ht = htab_create (32, htab_hash_pointer, htab_eq_pointer, NULL);\n+  ht.create (32);\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op0, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_before);\n-  htab_empty (ht);\n+  ht.empty ();\n #endif\n \n   tem = fold_unary_loc (loc, code, type, op0);\n@@ -14583,7 +14586,7 @@ fold_build1_stat_loc (location_t loc,\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op0, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_after);\n-  htab_delete (ht);\n+  ht.dispose ();\n \n   if (memcmp (checksum_before, checksum_after, 16))\n     fold_check_failed (op0, tem);\n@@ -14609,18 +14612,18 @@ fold_build2_stat_loc (location_t loc,\n \t\tchecksum_after_op0[16],\n \t\tchecksum_after_op1[16];\n   struct md5_ctx ctx;\n-  htab_t ht;\n+  hash_table <pointer_hash <tree_node> > ht;\n \n-  ht = htab_create (32, htab_hash_pointer, htab_eq_pointer, NULL);\n+  ht.create (32);\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op0, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_before_op0);\n-  htab_empty (ht);\n+  ht.empty ();\n \n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op1, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_before_op1);\n-  htab_empty (ht);\n+  ht.empty ();\n #endif\n \n   tem = fold_binary_loc (loc, code, type, op0, op1);\n@@ -14631,15 +14634,15 @@ fold_build2_stat_loc (location_t loc,\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op0, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_after_op0);\n-  htab_empty (ht);\n+  ht.empty ();\n \n   if (memcmp (checksum_before_op0, checksum_after_op0, 16))\n     fold_check_failed (op0, tem);\n \n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op1, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_after_op1);\n-  htab_delete (ht);\n+  ht.dispose ();\n \n   if (memcmp (checksum_before_op1, checksum_after_op1, 16))\n     fold_check_failed (op1, tem);\n@@ -14665,23 +14668,23 @@ fold_build3_stat_loc (location_t loc, enum tree_code code, tree type,\n \t\tchecksum_after_op1[16],\n \t\tchecksum_after_op2[16];\n   struct md5_ctx ctx;\n-  htab_t ht;\n+  hash_table <pointer_hash <tree_node> > ht;\n \n-  ht = htab_create (32, htab_hash_pointer, htab_eq_pointer, NULL);\n+  ht.create (32);\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op0, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_before_op0);\n-  htab_empty (ht);\n+  ht.empty ();\n \n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op1, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_before_op1);\n-  htab_empty (ht);\n+  ht.empty ();\n \n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op2, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_before_op2);\n-  htab_empty (ht);\n+  ht.empty ();\n #endif\n \n   gcc_assert (TREE_CODE_CLASS (code) != tcc_vl_exp);\n@@ -14693,23 +14696,23 @@ fold_build3_stat_loc (location_t loc, enum tree_code code, tree type,\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op0, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_after_op0);\n-  htab_empty (ht);\n+  ht.empty ();\n \n   if (memcmp (checksum_before_op0, checksum_after_op0, 16))\n     fold_check_failed (op0, tem);\n \n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op1, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_after_op1);\n-  htab_empty (ht);\n+  ht.empty ();\n \n   if (memcmp (checksum_before_op1, checksum_after_op1, 16))\n     fold_check_failed (op1, tem);\n \n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op2, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_after_op2);\n-  htab_delete (ht);\n+  ht.dispose ();\n \n   if (memcmp (checksum_before_op2, checksum_after_op2, 16))\n     fold_check_failed (op2, tem);\n@@ -14733,20 +14736,20 @@ fold_build_call_array_loc (location_t loc, tree type, tree fn,\n \t\tchecksum_after_fn[16],\n \t\tchecksum_after_arglist[16];\n   struct md5_ctx ctx;\n-  htab_t ht;\n+  hash_table <pointer_hash <tree_node> > ht;\n   int i;\n \n-  ht = htab_create (32, htab_hash_pointer, htab_eq_pointer, NULL);\n+  ht.create (32);\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (fn, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_before_fn);\n-  htab_empty (ht);\n+  ht.empty ();\n \n   md5_init_ctx (&ctx);\n   for (i = 0; i < nargs; i++)\n     fold_checksum_tree (argarray[i], &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_before_arglist);\n-  htab_empty (ht);\n+  ht.empty ();\n #endif\n \n   tem = fold_builtin_call_array (loc, type, fn, nargs, argarray);\n@@ -14755,7 +14758,7 @@ fold_build_call_array_loc (location_t loc, tree type, tree fn,\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (fn, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_after_fn);\n-  htab_empty (ht);\n+  ht.empty ();\n \n   if (memcmp (checksum_before_fn, checksum_after_fn, 16))\n     fold_check_failed (fn, tem);\n@@ -14764,7 +14767,7 @@ fold_build_call_array_loc (location_t loc, tree type, tree fn,\n   for (i = 0; i < nargs; i++)\n     fold_checksum_tree (argarray[i], &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_after_arglist);\n-  htab_delete (ht);\n+  ht.dispose ();\n \n   if (memcmp (checksum_before_arglist, checksum_after_arglist, 16))\n     fold_check_failed (NULL_TREE, tem);"}, {"sha": "3aa66a797cf12bb92b27e8a7585a94b27d90eab1", "filename": "gcc/hash-table.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -223,15 +223,15 @@ class hash_table\n   void create (size_t initial_slots);\n   bool is_created ();\n   void dispose ();\n-  T *find (T *comparable);\n-  T *find_with_hash (T *comparable, hashval_t hash);\n-  T **find_slot (T *comparable, enum insert_option insert);\n-  T **find_slot_with_hash (T *comparable, hashval_t hash,\n+  T *find (const T *comparable);\n+  T *find_with_hash (const T *comparable, hashval_t hash);\n+  T **find_slot (const T *comparable, enum insert_option insert);\n+  T **find_slot_with_hash (const T *comparable, hashval_t hash,\n \t\t\t\t   enum insert_option insert);\n   void empty ();\n   void clear_slot (T **slot);\n-  void remove_elt (T *comparable);\n-  void remove_elt_with_hash (T *comparable, hashval_t hash);\n+  void remove_elt (const T *comparable);\n+  void remove_elt_with_hash (const T *comparable, hashval_t hash);\n   size_t size();\n   size_t elements();\n   double collisions();\n@@ -273,7 +273,7 @@ hash_table <Descr, Allocator>::is_created ()\n template <typename Descr,\n \t  template <typename Type> class Allocator>\n inline typename Descr::T *\n-hash_table <Descr, Allocator>::find (T *comparable)\n+hash_table <Descr, Allocator>::find (const T *comparable)\n {\n   return find_with_hash (comparable, Descr::hash (comparable));\n }\n@@ -285,7 +285,7 @@ template <typename Descr,\n \t  template <typename Type> class Allocator>\n inline typename Descr::T **\n hash_table <Descr, Allocator>\n-::find_slot (T *comparable, enum insert_option insert)\n+::find_slot (const T *comparable, enum insert_option insert)\n {\n   return find_slot_with_hash (comparable, Descr::hash (comparable), insert);\n }\n@@ -297,7 +297,7 @@ template <typename Descr,\n \t  template <typename Type> class Allocator>\n inline void\n hash_table <Descr, Allocator>\n-::remove_elt (T *comparable)\n+::remove_elt (const T *comparable)\n {\n   remove_elt_with_hash (comparable, Descr::hash (comparable));\n }\n@@ -495,7 +495,7 @@ template <typename Descr,\n \t  template <typename Type> class Allocator>\n typename Descr::T *\n hash_table <Descr, Allocator>\n-::find_with_hash (T *comparable, hashval_t hash)\n+::find_with_hash (const T *comparable, hashval_t hash)\n {\n   hashval_t index, hash2;\n   size_t size;\n@@ -538,7 +538,7 @@ template <typename Descr,\n \t  template <typename Type> class Allocator>\n typename Descr::T **\n hash_table <Descr, Allocator>\n-::find_slot_with_hash (T *comparable, hashval_t hash,\n+::find_slot_with_hash (const T *comparable, hashval_t hash,\n \t\t       enum insert_option insert)\n {\n   T **first_deleted_slot;\n@@ -609,7 +609,7 @@ template <typename Descr,\n void\n hash_table <Descr, Allocator>::empty ()\n {\n-  size_t size = htab_size (htab);\n+  size_t size = htab->size;\n   T **entries = htab->entries;\n   int i;\n \n@@ -651,7 +651,7 @@ ::clear_slot (T **slot)\n \n   Descr::remove (*slot);\n \n-  *slot = HTAB_DELETED_ENTRY;\n+  *slot = static_cast <T *> (HTAB_DELETED_ENTRY);\n   htab->n_deleted++;\n }\n \n@@ -664,7 +664,7 @@ template <typename Descr,\n \t  template <typename Type> class Allocator>\n void\n hash_table <Descr, Allocator>\n-::remove_elt_with_hash (T *comparable, hashval_t hash)\n+::remove_elt_with_hash (const T *comparable, hashval_t hash)\n {\n   T **slot;\n "}, {"sha": "190d48c13adf4fb665fca92b2d3045d5792ae5c7", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -1,3 +1,10 @@\n+2012-10-01  Lawrence Crowl  <crowl@google.com>\n+\n+\t* Make-lang.in (JAVA_OBJS): Add dependence on hash-table.o.\n+\t(JCFDUMP_OBJS): Add dependence on hash-table.o.\n+\t(jcf-io.o): Add dependence on hash-table.h.\n+\t* jcf-io.c (memoized_class_lookups): Change to use type-safe hash table.\n+\n 2012-09-24  Lawrence Crowl  <crowl@google.com>\n \n \t* decl.c (java_init_decl_processing): Change to new double_int API."}, {"sha": "390782d1af89df66eabb786e7aeb49dec1c10da8", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -83,10 +83,10 @@ JAVA_OBJS = java/class.o java/decl.o java/expr.o \\\n   java/zextract.o java/jcf-io.o java/win32-host.o java/jcf-parse.o java/mangle.o \\\n   java/mangle_name.o java/builtins.o java/resource.o \\\n   java/jcf-depend.o \\\n-  java/jcf-path.o java/boehm.o java/java-gimplify.o\n+  java/jcf-path.o java/boehm.o java/java-gimplify.o hash-table.o\n \n JCFDUMP_OBJS = java/jcf-dump.o java/jcf-io.o java/jcf-depend.o java/jcf-path.o \\\n-\t\tjava/win32-host.o java/zextract.o ggc-none.o\n+\t\tjava/win32-host.o java/zextract.o ggc-none.o hash-table.o\n \n JVGENMAIN_OBJS = java/jvgenmain.o java/mangle_name.o\n \n@@ -326,7 +326,7 @@ java/java-gimplify.o: java/java-gimplify.c $(CONFIG_H) $(SYSTEM_H) \\\n # jcf-io.o needs $(ZLIBINC) added to cflags.\n CFLAGS-java/jcf-io.o += $(ZLIBINC)\n java/jcf-io.o: java/jcf-io.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-  $(JAVA_TREE_H) java/zipfile.h\n+  $(JAVA_TREE_H) java/zipfile.h $(HASH_TABLE_H)\n \n # jcf-path.o needs a -D.\n CFLAGS-java/jcf-path.o += \\"}, {"sha": "97a3c0fbc681d1642c97af2dc693c8de318361a1", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -31,7 +31,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"jcf.h\"\n #include \"tree.h\"\n #include \"java-tree.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include <dirent.h>\n \n #include \"zlib.h\"\n@@ -271,20 +271,34 @@ find_classfile (char *filename, JCF *jcf, const char *dep_name)\n   return open_class (filename, jcf, fd, dep_name);\n }\n \n-/* Returns 1 if the CLASSNAME (really a char *) matches the name\n-   stored in TABLE_ENTRY (also a char *).  */\n \n-static int\n-memoized_class_lookup_eq (const void *table_entry, const void *classname)\n+/* Hash table helper.  */\n+\n+struct charstar_hash : typed_noop_remove <char>\n+{\n+  typedef const char T;\n+  static inline hashval_t hash (const T *candidate);\n+  static inline bool equal (const T *existing, const T *candidate);\n+};\n+\n+inline hashval_t\n+charstar_hash::hash (const T *candidate)\n {\n-  return strcmp ((const char *)classname, (const char *)table_entry) == 0;\n+  return htab_hash_string (candidate);\n }\n \n+inline bool\n+charstar_hash::equal (const T *existing, const T *candidate)\n+{\n+  return strcmp (existing, candidate) == 0;\n+}\n+\n+\n /* A hash table keeping track of class names that were not found\n    during class lookup.  (There is no need to cache the values\n    associated with names that were found; they are saved in\n    IDENTIFIER_CLASS_VALUE.)  */\n-static htab_t memoized_class_lookups;\n+static hash_table <charstar_hash> memoized_class_lookups;\n \n /* Returns a freshly malloc'd string with the fully qualified pathname\n    of the .class file for the class CLASSNAME.  CLASSNAME must be\n@@ -306,16 +320,13 @@ find_class (const char *classname, int classname_length, JCF *jcf)\n   hashval_t hash;\n \n   /* Create the hash table, if it does not already exist.  */\n-  if (!memoized_class_lookups)\n-    memoized_class_lookups = htab_create (37, \n-\t\t\t\t\t  htab_hash_string, \n-\t\t\t\t\t  memoized_class_lookup_eq,\n-\t\t\t\t\t  NULL);\n+  if (!memoized_class_lookups.is_created ())\n+    memoized_class_lookups.create (37);\n \n   /* Loop for this class in the hashtable.  If it is present, we've\n      already looked for this class and failed to find it.  */\n-  hash = htab_hash_string (classname);\n-  if (htab_find_with_hash (memoized_class_lookups, classname, hash))\n+  hash = charstar_hash::hash (classname);\n+  if (memoized_class_lookups.find_with_hash (classname, hash))\n     return NULL;\n \n   /* Allocate and zero out the buffer, since we don't explicitly put a\n@@ -390,8 +401,8 @@ find_class (const char *classname, int classname_length, JCF *jcf)\n \n   /* Remember that this class could not be found so that we do not\n      have to look again.  */\n-  *htab_find_slot_with_hash (memoized_class_lookups, classname, hash, INSERT)\n-    = (void *) CONST_CAST (char *, classname);\n+  *memoized_class_lookups.find_slot_with_hash (classname, hash, INSERT)\n+    = classname;\n \n   return NULL;\n  found:"}, {"sha": "575d4733925d100ffc7ba9ef9bc605f09b09fdad", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -1,3 +1,10 @@\n+2012-10-01  Lawrence Crowl  <crowl@google.com>\n+\n+\t* Make-lang.in (OBJC_OBJS): Add dependence on hash-table.o.\n+\t(objc-act.o): Add dependence on hash-table.h.\n+\t* objc-act.c (objc_detect_field_duplicates): Change to new type-safe\n+\thash table.\n+\n 2012-06-29  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* Make-ang.in: Adjust for move of C front-end files."}, {"sha": "bdc35e559c298e47f8d706708ea6e02889094581", "filename": "gcc/objc/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fobjc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fobjc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMake-lang.in?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -50,7 +50,7 @@ START_HDRS = $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n objc-warn = $(STRICT_WARN)\n \n # Language-specific object files for Objective C.\n-OBJC_OBJS = objc/objc-lang.o objc/objc-act.o \\\n+OBJC_OBJS = objc/objc-lang.o objc/objc-act.o hash-table.o \\\n    objc/objc-runtime-shared-support.o \\\n    objc/objc-gnu-runtime-abi-01.o \\\n    objc/objc-next-runtime-abi-01.o \\\n@@ -127,7 +127,7 @@ objc/objc-act.o : objc/objc-act.c \\\n    $(START_HDRS) \\\n    $(GGC_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) input.h \\\n    toplev.h $(FUNCTION_H) debug.h $(LANGHOOKS_DEF_H) \\\n-   $(HASHTAB_H) $(GIMPLE_H) \\\n+   $(HASH_TABLE_H) $(GIMPLE_H) \\\n    $(C_PRAGMA_H) $(C_TARGET_H) \\\n    objc/objc-encoding.h \\\n    objc/objc-map.h \\"}, {"sha": "cf0cc845369e55287ebc99debb894db8e052e683", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703c8606fa58f4c827deda50f641da57294cc78e/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=703c8606fa58f4c827deda50f641da57294cc78e", "patch": "@@ -51,7 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"cgraph.h\"\n #include \"tree-iterator.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"langhooks-def.h\"\n /* Different initialization, code gen and meta data generation for each\n    runtime.  */\n@@ -3824,18 +3824,23 @@ objc_get_class_ivars (tree class_name)\n    allows us to store keys in the hashtable, without values (it looks\n    more like a set).  So, we store the DECLs, but define equality as\n    DECLs having the same name, and hash as the hash of the name.  */\n-static hashval_t\n-hash_instance_variable (const PTR p)\n+\n+struct decl_name_hash : typed_noop_remove <tree_node>\n+{\n+  typedef tree_node T;\n+  static inline hashval_t hash (const T *);\n+  static inline bool equal (const T *, const T *);\n+};\n+\n+inline hashval_t\n+decl_name_hash::hash (const T *q)\n {\n-  const_tree q = (const_tree)p;\n   return (hashval_t) ((intptr_t)(DECL_NAME (q)) >> 3);\n }\n \n-static int\n-eq_instance_variable (const PTR p1, const PTR p2)\n+inline bool\n+decl_name_hash::equal (const T *a, const T *b)\n {\n-  const_tree a = (const_tree)p1;\n-  const_tree b = (const_tree)p2;\n   return DECL_NAME (a) == DECL_NAME (b);\n }\n \n@@ -3916,8 +3921,8 @@ objc_detect_field_duplicates (bool check_superclasses_only)\n \t  {\n \t    /* First, build the hashtable by putting all the instance\n \t       variables of superclasses in it.  */\n-\t    htab_t htab = htab_create (37, hash_instance_variable,\n-\t\t\t\t       eq_instance_variable, NULL);\n+\t    hash_table <decl_name_hash> htab;\n+\t    htab.create (37);\n \t    tree interface;\n \t    for (interface = lookup_interface (CLASS_SUPER_NAME\n \t\t\t\t\t       (objc_interface_context));\n@@ -3930,7 +3935,7 @@ objc_detect_field_duplicates (bool check_superclasses_only)\n \t\t  {\n \t\t    if (DECL_NAME (ivar) != NULL_TREE)\n \t\t      {\n-\t\t\tvoid **slot = htab_find_slot (htab, ivar, INSERT);\n+\t\t\ttree_node **slot = htab.find_slot (ivar, INSERT);\n \t\t\t/* Do not check for duplicate instance\n \t\t\t   variables in superclasses.  Errors have\n \t\t\t   already been generated.  */\n@@ -3950,7 +3955,7 @@ objc_detect_field_duplicates (bool check_superclasses_only)\n \t\t  {\n \t\t    if (DECL_NAME (ivar) != NULL_TREE)\n \t\t      {\n-\t\t\ttree duplicate_ivar = (tree)(htab_find (htab, ivar));\n+\t\t\ttree duplicate_ivar = htab.find (ivar);\n \t\t\tif (duplicate_ivar != HTAB_EMPTY_ENTRY)\n \t\t\t  {\n \t\t\t    error_at (DECL_SOURCE_LOCATION (ivar),\n@@ -3977,7 +3982,7 @@ objc_detect_field_duplicates (bool check_superclasses_only)\n \t\t  {\n \t\t    if (DECL_NAME (ivar) != NULL_TREE)\n \t\t      {\n-\t\t\tvoid **slot = htab_find_slot (htab, ivar, INSERT);\n+\t\t\ttree_node **slot = htab.find_slot (ivar, INSERT);\n \t\t\tif (*slot)\n \t\t\t  {\n \t\t\t    tree duplicate_ivar = (tree)(*slot);\n@@ -3994,7 +3999,7 @@ objc_detect_field_duplicates (bool check_superclasses_only)\n \t\t      }\n \t\t  }\n \t      }\n-\t    htab_delete (htab);\n+\t    htab.dispose ();\n \t    return true;\n \t  }\n       }"}]}