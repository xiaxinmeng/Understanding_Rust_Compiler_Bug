{"sha": "87e2a8fd39ac34b507dcadad62008ea3b5b6a735", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdlMmE4ZmQzOWFjMzRiNTA3ZGNhZGFkNjIwMDhlYTNiNWI2YTczNQ==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@google.com", "date": "2012-07-10T20:26:38Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2012-07-10T20:26:38Z"}, "message": "Implement -freuse-stack= option\n\nFrom-SVN: r189413", "tree": {"sha": "3ddd4b4957cfc5c0cac4bfd53cfe390f92e77c18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ddd4b4957cfc5c0cac4bfd53cfe390f92e77c18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87e2a8fd39ac34b507dcadad62008ea3b5b6a735", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e2a8fd39ac34b507dcadad62008ea3b5b6a735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87e2a8fd39ac34b507dcadad62008ea3b5b6a735", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e2a8fd39ac34b507dcadad62008ea3b5b6a735/comments", "author": {"login": "vns-mn", "id": 57157229, "node_id": "MDQ6VXNlcjU3MTU3MjI5", "avatar_url": "https://avatars.githubusercontent.com/u/57157229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vns-mn", "html_url": "https://github.com/vns-mn", "followers_url": "https://api.github.com/users/vns-mn/followers", "following_url": "https://api.github.com/users/vns-mn/following{/other_user}", "gists_url": "https://api.github.com/users/vns-mn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vns-mn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vns-mn/subscriptions", "organizations_url": "https://api.github.com/users/vns-mn/orgs", "repos_url": "https://api.github.com/users/vns-mn/repos", "events_url": "https://api.github.com/users/vns-mn/events{/privacy}", "received_events_url": "https://api.github.com/users/vns-mn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2f01137541c6214e5b4bca9fd0257a234bf20bf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f01137541c6214e5b4bca9fd0257a234bf20bf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f01137541c6214e5b4bca9fd0257a234bf20bf3"}], "stats": {"total": 118, "additions": 116, "deletions": 2}, "files": [{"sha": "f49066cbc05a488b88e50df230d860a17b9094f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e2a8fd39ac34b507dcadad62008ea3b5b6a735/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e2a8fd39ac34b507dcadad62008ea3b5b6a735/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87e2a8fd39ac34b507dcadad62008ea3b5b6a735", "patch": "@@ -1,3 +1,12 @@\n+2012-07-10  Xinliang David Li  <davidxl@google.com>\n+\n+\t* doc/invoke.texi: New option documented.\n+\t* flag-types.h: New enum type.\n+\t* gimplify.c (gimplify_bind_expr): Control\n+\tclobber generation with new option.\n+\t(gimplify_target_expr): Ditto.\n+\tcommon.opt: New option.\n+\n 2012-07-10  Julian Brown  <julian@codesourcery.com>\n \n \t* config/arm/arm.md (movsi): Don't split symbol refs here."}, {"sha": "4761d51e8d84ed624d8304f6a40168efa9db4cad", "filename": "gcc/common.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e2a8fd39ac34b507dcadad62008ea3b5b6a735/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e2a8fd39ac34b507dcadad62008ea3b5b6a735/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=87e2a8fd39ac34b507dcadad62008ea3b5b6a735", "patch": "@@ -1247,6 +1247,22 @@ fif-conversion2\n Common Report Var(flag_if_conversion2) Optimization\n Perform conversion of conditional jumps to conditional execution\n \n+fstack-reuse=\n+Common Joined RejectNegative Enum(stack_reuse_level) Var(flag_stack_reuse) Init(SR_ALL)\n+-fstack-reuse=[all|named_vars|none] Set stack reuse level for local variables.\n+\n+Enum\n+Name(stack_reuse_level) Type(enum stack_reuse_level) UnknownError(unknown Stack Reuse Level %qs)\n+\n+EnumValue\n+Enum(stack_reuse_level) String(all) Value(SR_ALL)\n+\n+EnumValue\n+Enum(stack_reuse_level) String(named_vars) Value(SR_NAMED_VARS)\n+\n+EnumValue\n+Enum(stack_reuse_level) String(none) Value(SR_NONE)\n+\n ftree-loop-if-convert\n Common Report Var(flag_tree_loop_if_convert) Init(-1) Optimization\n Convert conditional jumps in innermost loops to branchless equivalents"}, {"sha": "ca313bea9f198606a8ed4b62c9a7e7ce02304c24", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e2a8fd39ac34b507dcadad62008ea3b5b6a735/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e2a8fd39ac34b507dcadad62008ea3b5b6a735/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=87e2a8fd39ac34b507dcadad62008ea3b5b6a735", "patch": "@@ -990,6 +990,7 @@ See S/390 and zSeries Options.\n -fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym} @gol\n -fno-stack-limit -fsplit-stack @gol\n -fleading-underscore  -ftls-model=@var{model} @gol\n+-fstack-reuse=@var{reuse_level} @gol\n -ftrapv  -fwrapv  -fbounds-check @gol\n -fvisibility -fstrict-volatile-bitfields -fsync-libcalls}\n @end table\n@@ -19307,6 +19308,84 @@ indices used to access arrays are within the declared range.  This is\n currently only supported by the Java and Fortran front ends, where\n this option defaults to true and false respectively.\n \n+@item -fstack-reuse=@var{reuse-level}\n+@opindex fstack_reuse\n+This option controls stack space reuse for user declared local/auto variables\n+and compiler generated temporaries.  @var{reuse_level} can be @samp{all},\n+@samp{named_vars}, or @samp{none}. @samp{all} enables stack reuse for all\n+local variables and temporaries, @samp{named_vars} enables the reuse only for\n+user defined local variables with names, and @samp{none} disables stack reuse\n+completely. The default value is @samp{all}. The option is needed when the\n+program extends the lifetime of a scoped local variable or a compiler generated\n+temporary beyond the end point defined by the language.  When a lifetime of\n+a variable ends, and if the variable lives in memory, the optimizing compiler\n+has the freedom to reuse its stack space with other temporaries or scoped\n+local variables whose live range does not overlap with it. Legacy code extending\n+local lifetime will likely to break with the stack reuse optimization.\n+\n+For example,\n+\n+@smallexample\n+   int *p;\n+   @{\n+     int local1;\n+\n+     p = &local1;\n+     local1 = 10;\n+     ....\n+   @}\n+   @{\n+      int local2;\n+      local2 = 20;\n+      ...\n+   @}\n+\n+   if (*p == 10)  // out of scope use of local1\n+     @{\n+\n+     @}\n+@end smallexample\n+\n+Another example:\n+@smallexample\n+\n+   struct A\n+   @{\n+       A(int k) : i(k), j(k) @{ @}\n+       int i;\n+       int j;\n+   @};\n+\n+   A *ap;\n+\n+   void foo(const A& ar)\n+   @{\n+      ap = &ar;\n+   @}\n+\n+   void bar()\n+   @{\n+      foo(A(10)); // temp object's lifetime ends when foo returns\n+\n+      @{\n+        A a(20);\n+        ....\n+      @}\n+      ap->i+= 10;  // ap references out of scope temp whose space\n+                   // is reused with a. What is the value of ap->i?\n+   @}\n+\n+@end smallexample\n+\n+The lifetime of a compiler generated temporary is well defined by the C++\n+standard. When a lifetime of a temporary ends, and if the temporary lives\n+in memory, the optimizing compiler has the freedom to reuse its stack\n+space with other temporaries or scoped local variables whose live range\n+does not overlap with it. However some of the legacy code relies on\n+the behavior of older compilers in which temporaries' stack space is\n+not reused, the aggressive stack reuse can lead to runtime errors. This\n+option is used to control the temporary stack reuse optimization.\n+\n @item -ftrapv\n @opindex ftrapv\n This option generates traps for signed overflow on addition, subtraction,"}, {"sha": "b503c9f4f198672ab5e06e761f3b8c49c82412a9", "filename": "gcc/flag-types.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e2a8fd39ac34b507dcadad62008ea3b5b6a735/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e2a8fd39ac34b507dcadad62008ea3b5b6a735/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=87e2a8fd39ac34b507dcadad62008ea3b5b6a735", "patch": "@@ -106,6 +106,14 @@ enum symbol_visibility\n };\n #endif\n \n+/* The stack reuse level.  */\n+enum stack_reuse_level\n+{\n+  SR_NONE,\n+  SR_NAMED_VARS,\n+  SR_ALL\n+};\n+\n /* The algorithm used for the integrated register allocator (IRA).  */\n enum ira_algorithm\n {"}, {"sha": "bd3642c8c41f37483053427ac4a80e1a0a92e622", "filename": "gcc/gimplify.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e2a8fd39ac34b507dcadad62008ea3b5b6a735/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e2a8fd39ac34b507dcadad62008ea3b5b6a735/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=87e2a8fd39ac34b507dcadad62008ea3b5b6a735", "patch": "@@ -1247,7 +1247,8 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n \t  && !DECL_HAS_VALUE_EXPR_P (t)\n \t  /* Only care for variables that have to be in memory.  Others\n \t     will be rewritten into SSA names, hence moved to the top-level.  */\n-\t  && !is_gimple_reg (t))\n+\t  && !is_gimple_reg (t)\n+\t  && flag_stack_reuse != SR_NONE)\n \t{\n \t  tree clobber = build_constructor (TREE_TYPE (t), NULL);\n \t  TREE_THIS_VOLATILE (clobber) = 1;\n@@ -5634,7 +5635,8 @@ gimplify_target_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       /* Add a clobber for the temporary going out of scope, like\n \t gimplify_bind_expr.  */\n       if (gimplify_ctxp->in_cleanup_point_expr\n-\t  && needs_to_live_in_memory (temp))\n+\t  && needs_to_live_in_memory (temp)\n+\t  && flag_stack_reuse == SR_ALL)\n \t{\n \t  tree clobber = build_constructor (TREE_TYPE (temp), NULL);\n \t  TREE_THIS_VOLATILE (clobber) = true;"}]}