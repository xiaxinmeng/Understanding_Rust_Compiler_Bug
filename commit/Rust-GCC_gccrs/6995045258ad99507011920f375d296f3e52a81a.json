{"sha": "6995045258ad99507011920f375d296f3e52a81a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk5NTA0NTI1OGFkOTk1MDcwMTE5MjBmMzc1ZDI5NmYzZTUyYTgxYQ==", "commit": {"author": {"name": "Adrian Straetling", "email": "straetling@de.ibm.com", "date": "2005-07-13T19:34:56Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-07-13T19:34:56Z"}, "message": "s390.c: (s390_cc_modes_compatible): Move before \"s390_emit_compare\".\n\n2005-07-13  Adrian Strae\ufffdtling  <straetling@de.ibm.com>\n\n\t* config/s390/s390.c: (s390_cc_modes_compatible): Move before\n\t\"s390_emit_compare\".  Add handling of CCZ1mode.\n\t(s390_canonicalize_comparison): Simplify cascaded EQ, NE.\n\t(390_emit_compare): Use \"s390_cc_modes_compatible\" for mode\n\tchecking.\n\t(s390_branch_condition_mask): Add CCZ1mode handling.\n\t* config/s390/s390.md: (\"seq\", \"*seq\"): New pattern.\n\t(\"sync_compare_and_swap_cc<mode>\", \"*sync_compare_and_swap_cc<mode>\"):\n\tUse CCZ1mode instead of CCZmode.\n\t* config/s390/s390-modes.def: Add CCZ1mode.  Comment new mode.\n\nFrom-SVN: r101990", "tree": {"sha": "34b5e35869049cf8464a42978560a0a26ccd08b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34b5e35869049cf8464a42978560a0a26ccd08b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6995045258ad99507011920f375d296f3e52a81a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6995045258ad99507011920f375d296f3e52a81a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6995045258ad99507011920f375d296f3e52a81a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6995045258ad99507011920f375d296f3e52a81a/comments", "author": null, "committer": null, "parents": [{"sha": "ccbdc0d46e8d2ed948a5b3daa174632ad55847a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccbdc0d46e8d2ed948a5b3daa174632ad55847a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccbdc0d46e8d2ed948a5b3daa174632ad55847a5"}], "stats": {"total": 150, "additions": 110, "deletions": 40}, "files": [{"sha": "2d2b1a0eed48b1e81588bfe33b019f10ee165508", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6995045258ad99507011920f375d296f3e52a81a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6995045258ad99507011920f375d296f3e52a81a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6995045258ad99507011920f375d296f3e52a81a", "patch": "@@ -1,3 +1,16 @@\n+2005-07-13  Adrian Strae\ufffdtling  <straetling@de.ibm.com>\n+\n+\t* config/s390/s390.c: (s390_cc_modes_compatible): Move before\n+\t\"s390_emit_compare\".  Add handling of CCZ1mode.\n+\t(s390_canonicalize_comparison): Simplify cascaded EQ, NE.\n+\t(390_emit_compare): Use \"s390_cc_modes_compatible\" for mode\n+\tchecking.\n+\t(s390_branch_condition_mask): Add CCZ1mode handling.\n+\t* config/s390/s390.md: (\"seq\", \"*seq\"): New pattern.\n+\t(\"sync_compare_and_swap_cc<mode>\", \"*sync_compare_and_swap_cc<mode>\"):\n+\tUse CCZ1mode instead of CCZmode.\n+\t* config/s390/s390-modes.def: Add CCZ1mode.  Comment new mode.\n+\n 2006-07-13  Adrian Strae\ufffdtling  <straetling@de.ibm.com>\n \n \t* config/s390/s390.md: (\"cmpstrsi\", \"*cmpstr<mode>\"): New"}, {"sha": "afcfb1b69e647f508172914106a39e551e6c9fc2", "filename": "gcc/config/s390/s390-modes.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6995045258ad99507011920f375d296f3e52a81a/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6995045258ad99507011920f375d296f3e52a81a/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-modes.def?ref=6995045258ad99507011920f375d296f3e52a81a", "patch": "@@ -35,6 +35,7 @@ Condition Codes\n Check for zero\n \n CCZ:  EQ          NE           NE          NE\n+CCZ1: EQ          NE                                  (CS)\n \n Unsigned compares\n \n@@ -146,10 +147,17 @@ CCL3 mode. Together with the CCU mode this mode is used for jumpless\n implementations of several if-constructs - see s390_expand_addcc for more\n details.\n \n+CCZ1\n+\n+The compare and swap instructions sets the condition code to 0/1 if the\n+operands were equal/unequal. The CCZ1 mode ensures the result can be\n+effectively placed into a register.\n+\n */   \n \n \n CC_MODE (CCZ);\n+CC_MODE (CCZ1);\n CC_MODE (CCA);\n CC_MODE (CCAP);\n CC_MODE (CCAN);"}, {"sha": "e10afafabdf41ea0294004a98223909c627416a2", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 57, "deletions": 36, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6995045258ad99507011920f375d296f3e52a81a/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6995045258ad99507011920f375d296f3e52a81a/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6995045258ad99507011920f375d296f3e52a81a", "patch": "@@ -272,6 +272,41 @@ s390_set_has_landing_pad_p (bool value)\n   cfun->machine->has_landing_pad_p = value;\n }\n \n+/* If two condition code modes are compatible, return a condition code\n+   mode which is compatible with both.  Otherwise, return\n+   VOIDmode.  */\n+\n+static enum machine_mode\n+s390_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n+{\n+  if (m1 == m2)\n+    return m1;\n+\n+  switch (m1)\n+    {\n+    case CCZmode:\n+      if (m2 == CCUmode || m2 == CCTmode || m2 == CCZ1mode\n+\t  || m2 == CCSmode || m2 == CCSRmode || m2 == CCURmode)\n+        return m2;\n+      return VOIDmode;\n+\n+    case CCSmode:\n+    case CCUmode:\n+    case CCTmode:\n+    case CCSRmode:\n+    case CCURmode:\n+    case CCZ1mode:\n+      if (m2 == CCZmode)\n+\treturn m1;\n+      \n+      return VOIDmode;\n+\n+    default:\n+      return VOIDmode;\n+    }\n+  return VOIDmode;\n+}\n+\n /* Return true if SET either doesn't set the CC register, or else\n    the source and destination have matching CC modes and that\n    CC mode is at least as constrained as REQ_MODE.  */\n@@ -612,6 +647,23 @@ s390_canonicalize_comparison (enum rtx_code *code, rtx *op0, rtx *op1)\n \t  *code = new_code;\n \t}\n     }\n+\n+  /* Simplify cascaded EQ, NE with const0_rtx.  */\n+  if ((*code == NE || *code == EQ)\n+      && (GET_CODE (*op0) == EQ || GET_CODE (*op0) == NE)\n+      && GET_MODE (*op0) == SImode\n+      && GET_MODE (XEXP (*op0, 0)) == CCZ1mode\n+      && REG_P (XEXP (*op0, 0))\n+      && XEXP (*op0, 1) == const0_rtx\n+      && *op1 == const0_rtx)\n+    {\n+      if ((*code == EQ && GET_CODE (*op0) == NE)\n+          || (*code == NE && GET_CODE (*op0) == EQ))\n+\t*code = EQ;\n+      else\n+\t*code = NE;\n+      *op0 = XEXP (*op0, 0);\n+    }\n }\n \n /* Emit a compare instruction suitable to implement the comparison\n@@ -625,8 +677,10 @@ s390_emit_compare (enum rtx_code code, rtx op0, rtx op1)\n   rtx ret = NULL_RTX;\n \n   /* Do not output a redundant compare instruction if a compare_and_swap\n-     pattern already computed the result and the machine modes match.  */\n-  if (s390_compare_emitted && GET_MODE (s390_compare_emitted) == mode)\n+     pattern already computed the result and the machine modes are compatible.  */\n+  if (s390_compare_emitted \n+      && (s390_cc_modes_compatible (GET_MODE (s390_compare_emitted), mode)\n+\t  == GET_MODE (s390_compare_emitted)))\n     ret = gen_rtx_fmt_ee (code, VOIDmode, s390_compare_emitted, const0_rtx); \n   else\n     {\n@@ -673,6 +727,7 @@ s390_branch_condition_mask (rtx code)\n   switch (GET_MODE (XEXP (code, 0)))\n     {\n     case CCZmode:\n+    case CCZ1mode:\n       switch (GET_CODE (code))\n         {\n         case EQ:\treturn CC0;\n@@ -7910,40 +7965,6 @@ s390_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n   return true;\n }\n \n-/* If two condition code modes are compatible, return a condition code\n-   mode which is compatible with both.  Otherwise, return\n-   VOIDmode.  */\n-\n-static enum machine_mode\n-s390_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n-{\n-  if (m1 == m2)\n-    return m1;\n-\n-  switch (m1)\n-    {\n-    case CCZmode:\n-      if (m2 == CCUmode || m2 == CCTmode\n-\t  || m2 == CCSmode || m2 == CCSRmode || m2 == CCURmode)\n-        return m2;\n-      return VOIDmode;\n-\n-    case CCSmode:\n-    case CCUmode:\n-    case CCTmode:\n-    case CCSRmode:\n-    case CCURmode:\n-      if (m2 == CCZmode)\n-\treturn m1;\n-      \n-      return VOIDmode;\n-\n-    default:\n-      return VOIDmode;\n-    }\n-  return VOIDmode;\n-}\n-\n /* This function is used by the call expanders of the machine description.\n    It emits the call insn itself together with the necessary operations\n    to adjust the target address and returns the emitted insn."}, {"sha": "453191457d69b61b0100a30fa639c11ab7973f06", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6995045258ad99507011920f375d296f3e52a81a/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6995045258ad99507011920f375d296f3e52a81a/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=6995045258ad99507011920f375d296f3e52a81a", "patch": "@@ -3973,6 +3973,34 @@\n   \"if (!s390_expand_addcc (<CODE>, s390_compare_op0, s390_compare_op1,\n \t\t\t   operands[0], const0_rtx, const1_rtx)) FAIL; DONE;\")\n \n+(define_expand \"seq\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+          (match_dup 1))\n+     (clobber (reg:CC CC_REGNUM))])\n+   (parallel\n+    [(set (match_dup 0) (xor:SI (match_dup 0) (const_int 1)))\n+     (clobber (reg:CC CC_REGNUM))])]\n+  \"\"\n+{ \n+  if (!s390_compare_emitted || GET_MODE (s390_compare_emitted) != CCZ1mode)\n+    FAIL;\n+  operands[1] = s390_emit_compare (NE, s390_compare_op0, s390_compare_op1);\n+  PUT_MODE (operands[1], SImode);\n+})\n+\n+(define_insn_and_split \"*sne\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ne:SI (match_operand:CCZ1 1 \"register_operand\" \"0\") \n+\t       (const_int 0)))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+    [(set (match_dup 0) (ashiftrt:SI (match_dup 0) (const_int 28)))\n+     (clobber (reg:CC CC_REGNUM))])])\n+\n \n ;;\n ;;- Multiply instructions.\n@@ -6797,10 +6825,10 @@\n \t     (match_operand:GPR 3 \"register_operand\" \"\")]\n \t    UNSPECV_CAS))\n      (set (match_dup 4)\n-\t  (compare:CCZ (match_dup 1) (match_dup 2)))])]\n+\t  (compare:CCZ1 (match_dup 1) (match_dup 2)))])]\n   \"\"\n {\n-  operands[4] = gen_rtx_REG (CCZmode, CC_REGNUM);\n+  operands[4] = gen_rtx_REG (CCZ1mode, CC_REGNUM);\n   s390_compare_op0 = operands[1];\n   s390_compare_op1 = operands[2];\n   s390_compare_emitted = operands[4];\n@@ -6815,8 +6843,8 @@\n \t   (match_operand:GPR 2 \"register_operand\" \"0\")\n \t   (match_operand:GPR 3 \"register_operand\" \"r\")]\n \t  UNSPECV_CAS))\n-   (set (reg:CCZ CC_REGNUM)\n-\t(compare:CCZ (match_dup 1) (match_dup 2)))]\n+   (set (reg:CCZ1 CC_REGNUM)\n+\t(compare:CCZ1 (match_dup 1) (match_dup 2)))]\n   \"\" \n   \"cs<g>\\t%0,%3,%S1\"\n   [(set_attr \"op_type\" \"RS<E>\")"}]}