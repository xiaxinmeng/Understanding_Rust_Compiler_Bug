{"sha": "b8ff1d5bbb496e1afc8580f129706e18ddad09ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhmZjFkNWJiYjQ5NmUxYWZjODU4MGYxMjk3MDZlMThkZGFkMDllYQ==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@il.ibm.com", "date": "2007-06-05T10:48:33Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2007-06-05T10:48:33Z"}, "message": "matrix-reorg.c (transform_access_sites): Fix computation.\n\n2007-06-05  Razya Ladelsky  <razya@il.ibm.com>\n\n        * matrix-reorg.c (transform_access_sites): Fix computation.\n        (transform_allocation_sites): Same.\n        * testsuite/gcc.dg/matrix/matrix-6.c: Remove conversion.\n\nFrom-SVN: r125331", "tree": {"sha": "9187506bf0371b9dc9b15f8f5c7415edca8032a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9187506bf0371b9dc9b15f8f5c7415edca8032a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8ff1d5bbb496e1afc8580f129706e18ddad09ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ff1d5bbb496e1afc8580f129706e18ddad09ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ff1d5bbb496e1afc8580f129706e18ddad09ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ff1d5bbb496e1afc8580f129706e18ddad09ea/comments", "author": null, "committer": null, "parents": [{"sha": "cc55c4b0747681df3256493e2d10fd482ec451f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc55c4b0747681df3256493e2d10fd482ec451f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc55c4b0747681df3256493e2d10fd482ec451f8"}], "stats": {"total": 77, "additions": 49, "deletions": 28}, "files": [{"sha": "8862f516222a774f9ccdfdf640376092099895ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ff1d5bbb496e1afc8580f129706e18ddad09ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ff1d5bbb496e1afc8580f129706e18ddad09ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8ff1d5bbb496e1afc8580f129706e18ddad09ea", "patch": "@@ -1,3 +1,9 @@\n+2007-06-05  Razya Ladelsky  <razya@il.ibm.com>\n+\n+        * matrix-reorg.c (transform_access_sites): Fix computation.\n+        (transform_allocation_sites): Same.\n+        * testsuite/gcc.dg/matrix/matrix-6.c: Remove conversion.\n+\n 2007-06-05  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (override_options): Use"}, {"sha": "e5bd46134765e5b2ad53727df003dd61cf3b584f", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ff1d5bbb496e1afc8580f129706e18ddad09ea/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ff1d5bbb496e1afc8580f129706e18ddad09ea/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=b8ff1d5bbb496e1afc8580f129706e18ddad09ea", "patch": "@@ -1654,6 +1654,42 @@ record_all_accesses_in_func (void)\n   sbitmap_free (visited_stmts_1);\n }\n \n+/* Used when we want to convert the expression: RESULT =  something * ORIG to RESULT = something * NEW. If ORIG and NEW are power of 2, shift operations can be done, else division and multiplication.  */\n+static tree\n+compute_offset (HOST_WIDE_INT orig, HOST_WIDE_INT new, tree result)\n+{\n+\n+  int x, y;\n+  tree result1, ratio, log, orig_tree, new_tree;\n+\n+  x = exact_log2 (orig);\n+  y = exact_log2 (new);\n+\n+  if (x != -1 && y != -1)\n+    {\n+      if (x == y)\n+        return result;\n+      else if (x > y)\n+        {\n+          log = build_int_cst (TREE_TYPE (result), x - y);\n+          result1 =\n+            fold_build2 (LSHIFT_EXPR, TREE_TYPE (result), result, log);\n+          return result1;\n+        }\n+      log = build_int_cst (TREE_TYPE (result), y - x);\n+      result1 = fold_build2 (RSHIFT_EXPR, TREE_TYPE (result), result, log);\n+\n+      return result1;\n+    }\n+  orig_tree = build_int_cst (TREE_TYPE (result), orig);\n+  new_tree = build_int_cst (TREE_TYPE (result), new);\n+  ratio = fold_build2 (TRUNC_DIV_EXPR, TREE_TYPE (result), result, orig_tree);\n+  result1 = fold_build2 (MULT_EXPR, TREE_TYPE (result), ratio, new_tree);\n+\n+  return result1;\n+}\n+\n+\n /* We know that we are allowed to perform matrix flattening (according to the\n    escape analysis), so we traverse the use-def chains of the SSA vars\n    defined by the global variables pointing to the matrices of our interest.\n@@ -1783,8 +1819,6 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t\ttmp1 = offset;\n \t      else\n \t\t{\n-\t\t  int x, y;\n-\t\t  tree ratio;\n \t\t  tree new_offset;\n \t\t  tree d_type_size, d_type_size_k;\n \n@@ -1793,29 +1827,11 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t\t\t\t   mi->dimension_type_size[min_escape_l]);\n \t\t  d_type_size_k =\n \t\t    build_int_cst (type, mi->dimension_type_size[k + 1]);\n-\t\t  x = exact_log2 (mi->dimension_type_size[min_escape_l]);\n-\t\t  y = exact_log2 (mi->dimension_type_size[k + 1]);\n \n-\t\t  if (x != -1 && y != -1)\n-\t\t    {\n-\t\t      if (x - y == 0)\n-\t\t\tnew_offset = offset;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  tree log = build_int_cst (type, x - y);\n-\t\t\t  new_offset =\n-\t\t\t    fold_build2 (LSHIFT_EXPR, TREE_TYPE (offset),\n-\t\t\t\t\t offset, log);\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      ratio =\n-\t\t\tfold_build2 (TRUNC_DIV_EXPR, type, d_type_size,\n-\t\t\t\t     d_type_size_k);\n-\t\t      new_offset =\n-\t\t\tfold_build2 (MULT_EXPR, type, offset, ratio);\n-\t\t    }\n+\t\t  new_offset =\n+\t\t    compute_offset (mi->dimension_type_size[min_escape_l],\n+\t\t\t\t    mi->dimension_type_size[k + 1], offset);\n+\n \t\t  total_elements = new_offset;\n \t\t  if (new_offset != offset)\n \t\t    {\n@@ -1916,7 +1932,6 @@ sort_dim_hot_level (gcov_type * a, int *dim_map, int n)\n     }\n }\n \n-\n /* Replace multiple mallocs (one for each dimension) to one malloc\n    with the size of DIM1*DIM2*...*DIMN*size_of_element\n    Make sure that we hold the size in the malloc site inside a\n@@ -2065,14 +2080,14 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \tadd_new_static_var (TREE_TYPE\n \t\t\t    (mi->dimension_size_orig[mi->dim_map[i]]));\n       type = TREE_TYPE (mi->dimension_size_orig[mi->dim_map[i]]);\n-      d_type_size =\n-\tbuild_int_cst (type, mi->dimension_type_size[mi->dim_map[i] + 1]);\n \n       /* DIM_SIZE = MALLOC_SIZE_PARAM / TYPE_SIZE.  */\n       /* Find which dim ID becomes dim I.  */\n       for (id = 0; id < mi->min_indirect_level_escape; id++)\n \tif (mi->dim_map[id] == i)\n \t  break;\n+       d_type_size =\n+        build_int_cst (type, mi->dimension_type_size[id + 1]);\n       if (!prev_dim_size)\n \tprev_dim_size = build_int_cst (type, element_size);\n       if (!check_transpose_p && i == mi->min_indirect_level_escape - 1)"}, {"sha": "536afb5377a92ce8c4129972a3b47f6e7b83607b", "filename": "gcc/testsuite/gcc.dg/matrix/matrix-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ff1d5bbb496e1afc8580f129706e18ddad09ea/gcc%2Ftestsuite%2Fgcc.dg%2Fmatrix%2Fmatrix-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ff1d5bbb496e1afc8580f129706e18ddad09ea/gcc%2Ftestsuite%2Fgcc.dg%2Fmatrix%2Fmatrix-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmatrix%2Fmatrix-6.c?ref=b8ff1d5bbb496e1afc8580f129706e18ddad09ea", "patch": "@@ -89,7 +89,7 @@ mem_init (void)\n \t    }\n \t}\n     }\n-  *vel[1] = (int *)d;\n+  *vel[1] = &d;\n }\n \n /*--------------------------------------------------------------------------*/"}]}