{"sha": "4a942af61c16f38f7fe51ed72a7ac23f73f62f2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE5NDJhZjYxYzE2ZjM4ZjdmZTUxZWQ3MmE3YWMyM2Y3M2Y2MmYyYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-14T08:29:56Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-14T08:29:56Z"}, "message": "[AArch64] Rework SVE FP comparisons\n\nThis patch rewrites the SVE FP comparisons so that they always use\nunspecs and so that they have an additional operand to indicate\nwhether the predicate is known to be a PTRUE.  It's part of a series\nthat rewrites the SVE FP patterns so that they can cope with non-PTRUE\npredicates.\n\n2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/iterators.md (UNSPEC_COND_FCMUO): New unspec.\n\t(cmp_op): Handle it.\n\t(SVE_COND_FP_CMP): Rename to...\n\t(SVE_COND_FP_CMP_I0): ...this.\n\t(SVE_FP_CMP): Remove.\n\t* config/aarch64/aarch64-sve.md\n\t(*fcm<SVE_FP_CMP:cmp_op><SVE_F:mode>): Replace with...\n\t(*fcm<SVE_COND_FP_CMP_I0:cmp_op><SVE_F:mode>): ...this new pattern,\n\tusing unspecs to represent the comparison.\n\t(*fcmuo<SVE_F:mode>): Use UNSPEC_COND_FCMUO.\n\t(*fcm<cmp_op><mode>_and_combine, *fcmuo<mode>_and_combine): Update\n\taccordingly.\n\t* config/aarch64/aarch64.c (aarch64_emit_sve_ptrue_op): Delete.\n\t(aarch64_unspec_cond_code): Move after integer code.  Handle\n\tUNORDERED.\n\t(aarch64_emit_sve_predicated_cond): Replace with...\n\t(aarch64_emit_sve_fp_cond): ...this new function.\n\t(aarch64_emit_sve_or_conds): Replace with...\n\t(aarch64_emit_sve_or_fp_conds): ...this new function.\n\t(aarch64_emit_sve_inverted_cond): Replace with...\n\t(aarch64_emit_sve_invert_fp_cond): ...this new function.\n\t(aarch64_expand_sve_vec_cmp_float): Update accordingly.\n\nFrom-SVN: r274421", "tree": {"sha": "ef3bb111be06dd71ad44d724b89426fc697dfb6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef3bb111be06dd71ad44d724b89426fc697dfb6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a942af61c16f38f7fe51ed72a7ac23f73f62f2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a942af61c16f38f7fe51ed72a7ac23f73f62f2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a942af61c16f38f7fe51ed72a7ac23f73f62f2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a942af61c16f38f7fe51ed72a7ac23f73f62f2a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a70965b114281553fa46cac9b8abab543f36793f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70965b114281553fa46cac9b8abab543f36793f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a70965b114281553fa46cac9b8abab543f36793f"}], "stats": {"total": 263, "additions": 118, "deletions": 145}, "files": [{"sha": "693d6f872a5a0179f04a82f8b46d8c0e46e4df82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a942af61c16f38f7fe51ed72a7ac23f73f62f2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a942af61c16f38f7fe51ed72a7ac23f73f62f2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a942af61c16f38f7fe51ed72a7ac23f73f62f2a", "patch": "@@ -1,3 +1,28 @@\n+2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/iterators.md (UNSPEC_COND_FCMUO): New unspec.\n+\t(cmp_op): Handle it.\n+\t(SVE_COND_FP_CMP): Rename to...\n+\t(SVE_COND_FP_CMP_I0): ...this.\n+\t(SVE_FP_CMP): Remove.\n+\t* config/aarch64/aarch64-sve.md\n+\t(*fcm<SVE_FP_CMP:cmp_op><SVE_F:mode>): Replace with...\n+\t(*fcm<SVE_COND_FP_CMP_I0:cmp_op><SVE_F:mode>): ...this new pattern,\n+\tusing unspecs to represent the comparison.\n+\t(*fcmuo<SVE_F:mode>): Use UNSPEC_COND_FCMUO.\n+\t(*fcm<cmp_op><mode>_and_combine, *fcmuo<mode>_and_combine): Update\n+\taccordingly.\n+\t* config/aarch64/aarch64.c (aarch64_emit_sve_ptrue_op): Delete.\n+\t(aarch64_unspec_cond_code): Move after integer code.  Handle\n+\tUNORDERED.\n+\t(aarch64_emit_sve_predicated_cond): Replace with...\n+\t(aarch64_emit_sve_fp_cond): ...this new function.\n+\t(aarch64_emit_sve_or_conds): Replace with...\n+\t(aarch64_emit_sve_or_fp_conds): ...this new function.\n+\t(aarch64_emit_sve_inverted_cond): Replace with...\n+\t(aarch64_emit_sve_invert_fp_cond): ...this new function.\n+\t(aarch64_expand_sve_vec_cmp_float): Update accordingly.\n+\n 2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/iterators.md (SVE_HSD): New mode iterator."}, {"sha": "7cbd690932e6dcf74c8c3c995c489e41bfd497f4", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 28, "deletions": 68, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a942af61c16f38f7fe51ed72a7ac23f73f62f2a/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a942af61c16f38f7fe51ed72a7ac23f73f62f2a/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=4a942af61c16f38f7fe51ed72a7ac23f73f62f2a", "patch": "@@ -3136,15 +3136,15 @@\n   }\n )\n \n-;; Floating-point comparisons predicated with a PTRUE.\n+;; Predicated floating-point comparisons.\n (define_insn \"*fcm<cmp_op><mode>\"\n   [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n \t(unspec:<VPRED>\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n-\t   (SVE_FP_CMP:<VPRED>\n-\t     (match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n-\t     (match_operand:SVE_F 3 \"aarch64_simd_reg_or_zero\" \"Dz, w\"))]\n-\t  UNSPEC_MERGE_PTRUE))]\n+\t   (match_operand:SI 4 \"aarch64_sve_ptrue_flag\")\n+\t   (match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n+\t   (match_operand:SVE_F 3 \"aarch64_simd_reg_or_zero\" \"Dz, w\")]\n+\t  SVE_COND_FP_CMP_I0))]\n   \"TARGET_SVE\"\n   \"@\n    fcm<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, #0.0\n@@ -3156,10 +3156,10 @@\n   [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa\")\n \t(unspec:<VPRED>\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (unordered:<VPRED>\n-\t     (match_operand:SVE_F 2 \"register_operand\" \"w\")\n-\t     (match_operand:SVE_F 3 \"register_operand\" \"w\"))]\n-\t  UNSPEC_MERGE_PTRUE))]\n+\t   (match_operand:SI 4 \"aarch64_sve_ptrue_flag\")\n+\t   (match_operand:SVE_F 2 \"register_operand\" \"w\")\n+\t   (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n+\t  UNSPEC_COND_FCMUO))]\n   \"TARGET_SVE\"\n   \"fcmuo\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n )\n@@ -3177,20 +3177,21 @@\n \t(and:<VPRED>\n \t  (unspec:<VPRED>\n \t    [(match_operand:<VPRED> 1)\n-\t     (SVE_FP_CMP\n-\t       (match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n-\t       (match_operand:SVE_F 3 \"aarch64_simd_reg_or_zero\" \"Dz, w\"))]\n-\t    UNSPEC_MERGE_PTRUE)\n+\t     (const_int SVE_KNOWN_PTRUE)\n+\t     (match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n+\t     (match_operand:SVE_F 3 \"aarch64_simd_reg_or_zero\" \"Dz, w\")]\n+\t    SVE_COND_FP_CMP_I0)\n \t  (match_operand:<VPRED> 4 \"register_operand\" \"Upl, Upl\")))]\n   \"TARGET_SVE\"\n   \"#\"\n   \"&& 1\"\n   [(set (match_dup 0)\n-\t(and:<VPRED>\n-\t  (SVE_FP_CMP:<VPRED>\n-\t    (match_dup 2)\n-\t    (match_dup 3))\n-\t  (match_dup 4)))]\n+\t(unspec:<VPRED>\n+\t  [(match_dup 4)\n+\t   (const_int SVE_MAYBE_NOT_PTRUE)\n+\t   (match_dup 2)\n+\t   (match_dup 3)]\n+\t  SVE_COND_FP_CMP_I0))]\n )\n \n ;; Same for unordered comparisons.\n@@ -3199,62 +3200,21 @@\n \t(and:<VPRED>\n \t  (unspec:<VPRED>\n \t    [(match_operand:<VPRED> 1)\n-\t     (unordered\n-\t       (match_operand:SVE_F 2 \"register_operand\" \"w\")\n-\t       (match_operand:SVE_F 3 \"register_operand\" \"w\"))]\n-\t    UNSPEC_MERGE_PTRUE)\n+\t     (const_int SVE_KNOWN_PTRUE)\n+\t     (match_operand:SVE_F 2 \"register_operand\" \"w\")\n+\t     (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n+\t    UNSPEC_COND_FCMUO)\n \t  (match_operand:<VPRED> 4 \"register_operand\" \"Upl\")))]\n   \"TARGET_SVE\"\n   \"#\"\n   \"&& 1\"\n   [(set (match_dup 0)\n-\t(and:<VPRED>\n-\t  (unordered:<VPRED>\n-\t    (match_dup 2)\n-\t    (match_dup 3))\n-\t  (match_dup 4)))]\n-)\n-\n-;; Unpredicated floating-point comparisons, with the results ANDed with\n-;; another predicate.  This is a valid fold for the same reasons as above.\n-(define_insn \"*fcm<cmp_op><mode>_and\"\n-  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n-\t(and:<VPRED>\n-\t  (SVE_FP_CMP:<VPRED>\n-\t    (match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n-\t    (match_operand:SVE_F 3 \"aarch64_simd_reg_or_zero\" \"Dz, w\"))\n-\t  (match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")))]\n-  \"TARGET_SVE\"\n-  \"@\n-   fcm<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, #0.0\n-   fcm<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n-)\n-\n-;; Same for unordered comparisons.\n-(define_insn \"*fcmuo<mode>_and\"\n-  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa\")\n-\t(and:<VPRED>\n-\t  (unordered:<VPRED>\n-\t    (match_operand:SVE_F 2 \"register_operand\" \"w\")\n-\t    (match_operand:SVE_F 3 \"register_operand\" \"w\"))\n-\t  (match_operand:<VPRED> 1 \"register_operand\" \"Upl\")))]\n-  \"TARGET_SVE\"\n-  \"fcmuo\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n-)\n-\n-;; Predicated floating-point comparisons.  We don't need a version\n-;; of this for unordered comparisons.\n-(define_insn \"*pred_fcm<cmp_op><mode>\"\n-  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n \t(unspec:<VPRED>\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n-\t   (match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n-\t   (match_operand:SVE_F 3 \"aarch64_simd_reg_or_zero\" \"Dz, w\")]\n-\t  SVE_COND_FP_CMP))]\n-  \"TARGET_SVE\"\n-  \"@\n-   fcm<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, #0.0\n-   fcm<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n+\t  [(match_dup 4)\n+\t   (const_int SVE_MAYBE_NOT_PTRUE)\n+\t   (match_dup 2)\n+\t   (match_dup 3)]\n+\t  UNSPEC_COND_FCMUO))]\n )\n \n ;; -------------------------------------------------------------------------"}, {"sha": "99b84cdb7084a5130695ec303e66d49e4a5aefe8", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 55, "deletions": 67, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a942af61c16f38f7fe51ed72a7ac23f73f62f2a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a942af61c16f38f7fe51ed72a7ac23f73f62f2a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=4a942af61c16f38f7fe51ed72a7ac23f73f62f2a", "patch": "@@ -17700,28 +17700,35 @@ aarch64_sve_cmp_operand_p (rtx_code op_code, rtx x)\n \n      (set TARGET OP)\n \n-   given that PTRUE is an all-true predicate of the appropriate mode.  */\n+   given that PTRUE is an all-true predicate of the appropriate mode\n+   and that the instruction clobbers the condition codes.  */\n \n static void\n-aarch64_emit_sve_ptrue_op (rtx target, rtx ptrue, rtx op)\n+aarch64_emit_sve_ptrue_op_cc (rtx target, rtx ptrue, rtx op)\n {\n   rtx unspec = gen_rtx_UNSPEC (GET_MODE (target),\n \t\t\t       gen_rtvec (2, ptrue, op),\n \t\t\t       UNSPEC_MERGE_PTRUE);\n-  rtx_insn *insn = emit_set_insn (target, unspec);\n+  rtx_insn *insn = emit_insn (gen_set_clobber_cc_nzc (target, unspec));\n   set_unique_reg_note (insn, REG_EQUAL, copy_rtx (op));\n }\n \n-/* Likewise, but also clobber the condition codes.  */\n+/* Expand an SVE integer comparison using the SVE equivalent of:\n \n-static void\n-aarch64_emit_sve_ptrue_op_cc (rtx target, rtx ptrue, rtx op)\n+     (set TARGET (CODE OP0 OP1)).  */\n+\n+void\n+aarch64_expand_sve_vec_cmp_int (rtx target, rtx_code code, rtx op0, rtx op1)\n {\n-  rtx unspec = gen_rtx_UNSPEC (GET_MODE (target),\n-\t\t\t       gen_rtvec (2, ptrue, op),\n-\t\t\t       UNSPEC_MERGE_PTRUE);\n-  rtx_insn *insn = emit_insn (gen_set_clobber_cc_nzc (target, unspec));\n-  set_unique_reg_note (insn, REG_EQUAL, copy_rtx (op));\n+  machine_mode pred_mode = GET_MODE (target);\n+  machine_mode data_mode = GET_MODE (op0);\n+\n+  if (!aarch64_sve_cmp_operand_p (code, op1))\n+    op1 = force_reg (data_mode, op1);\n+\n+  rtx ptrue = aarch64_ptrue_reg (pred_mode);\n+  rtx cond = gen_rtx_fmt_ee (code, pred_mode, op0, op1);\n+  aarch64_emit_sve_ptrue_op_cc (target, ptrue, cond);\n }\n \n /* Return the UNSPEC_COND_* code for comparison CODE.  */\n@@ -17743,85 +17750,67 @@ aarch64_unspec_cond_code (rtx_code code)\n       return UNSPEC_COND_FCMLE;\n     case GE:\n       return UNSPEC_COND_FCMGE;\n+    case UNORDERED:\n+      return UNSPEC_COND_FCMUO;\n     default:\n       gcc_unreachable ();\n     }\n }\n \n /* Emit:\n \n-      (set TARGET (unspec [PRED OP0 OP1] UNSPEC_COND_<X>))\n+      (set TARGET (unspec [PRED KNOWN_PTRUE_P OP0 OP1] UNSPEC_COND_<X>))\n \n-   where <X> is the operation associated with comparison CODE.  This form\n-   of instruction is used when (and (CODE OP0 OP1) PRED) would have different\n-   semantics, such as when PRED might not be all-true and when comparing\n-   inactive lanes could have side effects.  */\n+   where <X> is the operation associated with comparison CODE.\n+   KNOWN_PTRUE_P is true if PRED is known to be a PTRUE.  */\n \n static void\n-aarch64_emit_sve_predicated_cond (rtx target, rtx_code code,\n-\t\t\t\t  rtx pred, rtx op0, rtx op1)\n+aarch64_emit_sve_fp_cond (rtx target, rtx_code code, rtx pred,\n+\t\t\t  bool known_ptrue_p, rtx op0, rtx op1)\n {\n+  rtx flag = gen_int_mode (known_ptrue_p, SImode);\n   rtx unspec = gen_rtx_UNSPEC (GET_MODE (pred),\n-\t\t\t       gen_rtvec (3, pred, op0, op1),\n+\t\t\t       gen_rtvec (4, pred, flag, op0, op1),\n \t\t\t       aarch64_unspec_cond_code (code));\n   emit_set_insn (target, unspec);\n }\n \n-/* Expand an SVE integer comparison using the SVE equivalent of:\n-\n-     (set TARGET (CODE OP0 OP1)).  */\n-\n-void\n-aarch64_expand_sve_vec_cmp_int (rtx target, rtx_code code, rtx op0, rtx op1)\n-{\n-  machine_mode pred_mode = GET_MODE (target);\n-  machine_mode data_mode = GET_MODE (op0);\n-\n-  if (!aarch64_sve_cmp_operand_p (code, op1))\n-    op1 = force_reg (data_mode, op1);\n-\n-  rtx ptrue = aarch64_ptrue_reg (pred_mode);\n-  rtx cond = gen_rtx_fmt_ee (code, pred_mode, op0, op1);\n-  aarch64_emit_sve_ptrue_op_cc (target, ptrue, cond);\n-}\n-\n /* Emit the SVE equivalent of:\n \n-      (set TMP1 (CODE1 OP0 OP1))\n-      (set TMP2 (CODE2 OP0 OP1))\n+      (set TMP1 (unspec [PRED KNOWN_PTRUE_P OP0 OP1] UNSPEC_COND_<X1>))\n+      (set TMP2 (unspec [PRED KNOWN_PTRUE_P OP0 OP1] UNSPEC_COND_<X2>))\n       (set TARGET (ior:PRED_MODE TMP1 TMP2))\n \n-   PTRUE is an all-true predicate with the same mode as TARGET.  */\n+   where <Xi> is the operation associated with comparison CODEi.\n+   KNOWN_PTRUE_P is true if PRED is known to be a PTRUE.  */\n \n static void\n-aarch64_emit_sve_or_conds (rtx target, rtx_code code1, rtx_code code2,\n-\t\t\t   rtx ptrue, rtx op0, rtx op1)\n+aarch64_emit_sve_or_fp_conds (rtx target, rtx_code code1, rtx_code code2,\n+\t\t\t      rtx pred, bool known_ptrue_p, rtx op0, rtx op1)\n {\n-  machine_mode pred_mode = GET_MODE (ptrue);\n+  machine_mode pred_mode = GET_MODE (pred);\n   rtx tmp1 = gen_reg_rtx (pred_mode);\n-  aarch64_emit_sve_ptrue_op (tmp1, ptrue,\n-\t\t\t     gen_rtx_fmt_ee (code1, pred_mode, op0, op1));\n+  aarch64_emit_sve_fp_cond (tmp1, code1, pred, known_ptrue_p, op0, op1);\n   rtx tmp2 = gen_reg_rtx (pred_mode);\n-  aarch64_emit_sve_ptrue_op (tmp2, ptrue,\n-\t\t\t     gen_rtx_fmt_ee (code2, pred_mode, op0, op1));\n+  aarch64_emit_sve_fp_cond (tmp2, code2, pred, known_ptrue_p, op0, op1);\n   aarch64_emit_binop (target, ior_optab, tmp1, tmp2);\n }\n \n /* Emit the SVE equivalent of:\n \n-      (set TMP (CODE OP0 OP1))\n+      (set TMP (unspec [PRED KNOWN_PTRUE_P OP0 OP1] UNSPEC_COND_<X>))\n       (set TARGET (not TMP))\n \n-   PTRUE is an all-true predicate with the same mode as TARGET.  */\n+   where <X> is the operation associated with comparison CODE.\n+   KNOWN_PTRUE_P is true if PRED is known to be a PTRUE.  */\n \n static void\n-aarch64_emit_sve_inverted_cond (rtx target, rtx ptrue, rtx_code code,\n-\t\t\t\trtx op0, rtx op1)\n+aarch64_emit_sve_invert_fp_cond (rtx target, rtx_code code, rtx pred,\n+\t\t\t\t bool known_ptrue_p, rtx op0, rtx op1)\n {\n-  machine_mode pred_mode = GET_MODE (ptrue);\n+  machine_mode pred_mode = GET_MODE (pred);\n   rtx tmp = gen_reg_rtx (pred_mode);\n-  aarch64_emit_sve_ptrue_op (tmp, ptrue,\n-\t\t\t     gen_rtx_fmt_ee (code, pred_mode, op0, op1));\n+  aarch64_emit_sve_fp_cond (tmp, code, pred, known_ptrue_p, op0, op1);\n   aarch64_emit_unop (target, one_cmpl_optab, tmp);\n }\n \n@@ -17854,22 +17843,22 @@ aarch64_expand_sve_vec_cmp_float (rtx target, rtx_code code,\n     case NE:\n       {\n \t/* There is native support for the comparison.  */\n-\trtx cond = gen_rtx_fmt_ee (code, pred_mode, op0, op1);\n-\taarch64_emit_sve_ptrue_op (target, ptrue, cond);\n+\taarch64_emit_sve_fp_cond (target, code, ptrue, true, op0, op1);\n \treturn false;\n       }\n \n     case LTGT:\n       /* This is a trapping operation (LT or GT).  */\n-      aarch64_emit_sve_or_conds (target, LT, GT, ptrue, op0, op1);\n+      aarch64_emit_sve_or_fp_conds (target, LT, GT, ptrue, true, op0, op1);\n       return false;\n \n     case UNEQ:\n       if (!flag_trapping_math)\n \t{\n \t  /* This would trap for signaling NaNs.  */\n \t  op1 = force_reg (data_mode, op1);\n-\t  aarch64_emit_sve_or_conds (target, UNORDERED, EQ, ptrue, op0, op1);\n+\t  aarch64_emit_sve_or_fp_conds (target, UNORDERED, EQ,\n+\t\t\t\t\tptrue, true, op0, op1);\n \t  return false;\n \t}\n       /* fall through */\n@@ -17882,7 +17871,8 @@ aarch64_expand_sve_vec_cmp_float (rtx target, rtx_code code,\n \t  /* Work out which elements are ordered.  */\n \t  rtx ordered = gen_reg_rtx (pred_mode);\n \t  op1 = force_reg (data_mode, op1);\n-\t  aarch64_emit_sve_inverted_cond (ordered, ptrue, UNORDERED, op0, op1);\n+\t  aarch64_emit_sve_invert_fp_cond (ordered, UNORDERED,\n+\t\t\t\t\t   ptrue, true, op0, op1);\n \n \t  /* Test the opposite condition for the ordered elements,\n \t     then invert the result.  */\n@@ -17892,13 +17882,12 @@ aarch64_expand_sve_vec_cmp_float (rtx target, rtx_code code,\n \t    code = reverse_condition_maybe_unordered (code);\n \t  if (can_invert_p)\n \t    {\n-\t      aarch64_emit_sve_predicated_cond (target, code,\n-\t\t\t\t\t\tordered, op0, op1);\n+\t      aarch64_emit_sve_fp_cond (target, code,\n+\t\t\t\t\tordered, false, op0, op1);\n \t      return true;\n \t    }\n-\t  rtx tmp = gen_reg_rtx (pred_mode);\n-\t  aarch64_emit_sve_predicated_cond (tmp, code, ordered, op0, op1);\n-\t  aarch64_emit_unop (target, one_cmpl_optab, tmp);\n+\t  aarch64_emit_sve_invert_fp_cond (target, code,\n+\t\t\t\t\t   ordered, false, op0, op1);\n \t  return false;\n \t}\n       break;\n@@ -17916,11 +17905,10 @@ aarch64_expand_sve_vec_cmp_float (rtx target, rtx_code code,\n   code = reverse_condition_maybe_unordered (code);\n   if (can_invert_p)\n     {\n-      rtx cond = gen_rtx_fmt_ee (code, pred_mode, op0, op1);\n-      aarch64_emit_sve_ptrue_op (target, ptrue, cond);\n+      aarch64_emit_sve_fp_cond (target, code, ptrue, true, op0, op1);\n       return true;\n     }\n-  aarch64_emit_sve_inverted_cond (target, ptrue, code, op0, op1);\n+  aarch64_emit_sve_invert_fp_cond (target, code, ptrue, true, op0, op1);\n   return false;\n }\n "}, {"sha": "6bf3638ed1aabecb4aaad7fd0b43d93d61ef88ee", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a942af61c16f38f7fe51ed72a7ac23f73f62f2a/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a942af61c16f38f7fe51ed72a7ac23f73f62f2a/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=4a942af61c16f38f7fe51ed72a7ac23f73f62f2a", "patch": "@@ -479,6 +479,7 @@\n     UNSPEC_COND_FCMLE\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FCMLT\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FCMNE\t; Used in aarch64-sve.md.\n+    UNSPEC_COND_FCMUO\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FDIV\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FMAXNM\t; Used in aarch64-sve.md.\n     UNSPEC_COND_FMINNM\t; Used in aarch64-sve.md.\n@@ -1273,9 +1274,6 @@\n ;; SVE integer comparisons.\n (define_code_iterator SVE_INT_CMP [lt le eq ne ge gt ltu leu geu gtu])\n \n-;; SVE floating-point comparisons.\n-(define_code_iterator SVE_FP_CMP [lt le eq ne ge gt])\n-\n ;; -------------------------------------------------------------------\n ;; Code Attributes\n ;; -------------------------------------------------------------------\n@@ -1663,12 +1661,13 @@\n \t\t\t\t\t  UNSPEC_COND_FNMLA\n \t\t\t\t\t  UNSPEC_COND_FNMLS])\n \n-(define_int_iterator SVE_COND_FP_CMP [UNSPEC_COND_FCMEQ\n-\t\t\t\t      UNSPEC_COND_FCMGE\n-\t\t\t\t      UNSPEC_COND_FCMGT\n-\t\t\t\t      UNSPEC_COND_FCMLE\n-\t\t\t\t      UNSPEC_COND_FCMLT\n-\t\t\t\t      UNSPEC_COND_FCMNE])\n+;; SVE FP comparisons that accept #0.0.\n+(define_int_iterator SVE_COND_FP_CMP_I0 [UNSPEC_COND_FCMEQ\n+\t\t\t\t\t UNSPEC_COND_FCMGE\n+\t\t\t\t\t UNSPEC_COND_FCMGT\n+\t\t\t\t\t UNSPEC_COND_FCMLE\n+\t\t\t\t\t UNSPEC_COND_FCMLT\n+\t\t\t\t\t UNSPEC_COND_FCMNE])\n \n (define_int_iterator FCADD [UNSPEC_FCADD90\n \t\t\t    UNSPEC_FCADD270])\n@@ -1955,7 +1954,8 @@\n \t\t\t (UNSPEC_COND_FCMGT \"gt\")\n \t\t\t (UNSPEC_COND_FCMLE \"le\")\n \t\t\t (UNSPEC_COND_FCMLT \"lt\")\n-\t\t\t (UNSPEC_COND_FCMNE \"ne\")])\n+\t\t\t (UNSPEC_COND_FCMNE \"ne\")\n+\t\t\t (UNSPEC_COND_FCMUO \"uo\")])\n \n (define_int_attr sve_int_op [(UNSPEC_ANDV \"andv\")\n \t\t\t     (UNSPEC_IORV \"orv\")"}]}