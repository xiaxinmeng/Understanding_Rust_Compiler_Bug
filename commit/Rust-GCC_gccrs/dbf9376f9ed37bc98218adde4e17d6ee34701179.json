{"sha": "dbf9376f9ed37bc98218adde4e17d6ee34701179", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJmOTM3NmY5ZWQzN2JjOTgyMThhZGRlNGUxN2Q2ZWUzNDcwMTE3OQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-10-18T23:22:01Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-10-18T23:22:01Z"}, "message": "compiler: list indirect imports separately in export data\n    \n    Previously when export data referred to a type that was not defined in\n    a directly imported package, we would write the package name as\n    additional information in the type's export data.  That approach\n    required all type information to be read in order.  This patch changes\n    the compiler to find all references to indirectly imported packages,\n    and write them out as an indirectimport line in the import data.  This\n    will permit us to read exported type data out of order.\n    \n    The type traversal used to find indirect imports is a little more\n    complicated than necessary in preparation for later patches in this\n    series.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/143020\n\nFrom-SVN: r265296", "tree": {"sha": "ae9ca18100b4d161827eb0d62c561c73d7e8625b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae9ca18100b4d161827eb0d62c561c73d7e8625b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbf9376f9ed37bc98218adde4e17d6ee34701179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbf9376f9ed37bc98218adde4e17d6ee34701179", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbf9376f9ed37bc98218adde4e17d6ee34701179", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbf9376f9ed37bc98218adde4e17d6ee34701179/comments", "author": null, "committer": null, "parents": [{"sha": "442d4185084653cec6922fc87f9a8c1b96e4b87d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442d4185084653cec6922fc87f9a8c1b96e4b87d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/442d4185084653cec6922fc87f9a8c1b96e4b87d"}], "stats": {"total": 286, "additions": 263, "deletions": 23}, "files": [{"sha": "28b39847bfa072130bd764dc27575a95c16f9e95", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=dbf9376f9ed37bc98218adde4e17d6ee34701179", "patch": "@@ -1,4 +1,4 @@\n-84531ef21230307773daa438a50bf095edcdbf93\n+9c985ce6f76dd65b8eb0e4b03c09ad0100712e04\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "da3d67f115215f3ee5eb9473ba645e4fe58519b3", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 211, "deletions": 16, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=dbf9376f9ed37bc98218adde4e17d6ee34701179", "patch": "@@ -143,6 +143,10 @@ Export::export_globals(const std::string& package_name,\n \n   std::sort(exports.begin(), exports.end(), Sort_bindings());\n \n+  // Find all packages not explicitly imported but mentioned by types.\n+  Unordered_set(const Package*) type_imports;\n+  this->prepare_types(&exports, &type_imports);\n+\n   // Although the export data is readable, at least this version is,\n   // it is conceptually a binary format.  Start with a four byte\n   // version number.\n@@ -169,7 +173,7 @@ Export::export_globals(const std::string& package_name,\n \n   this->write_packages(packages);\n \n-  this->write_imports(imports);\n+  this->write_imports(imports, type_imports);\n \n   this->write_imported_init_fns(package_name, import_init_fn,\n \t\t\t\timported_init_fns);\n@@ -199,6 +203,179 @@ Export::export_globals(const std::string& package_name,\n   this->stream_->write_checksum(s);\n }\n \n+// Traversal class to find referenced types.\n+\n+class Find_types_to_prepare : public Traverse\n+{\n+ public:\n+  Find_types_to_prepare(Unordered_set(const Package*)* imports)\n+    : Traverse(traverse_types),\n+      imports_(imports)\n+  { }\n+\n+  int\n+  type(Type* type);\n+\n+  // Traverse the components of a function type.\n+  void\n+  traverse_function(Function_type*);\n+\n+  // Traverse the methods of a named type, and register its package.\n+  void\n+  traverse_named_type(Named_type*);\n+\n+ private:\n+  // List of packages we are building.\n+  Unordered_set(const Package*)* imports_;\n+};\n+\n+// Traverse a type.\n+\n+int\n+Find_types_to_prepare::type(Type* type)\n+{\n+  // Skip forwarders.\n+  if (type->forward_declaration_type() != NULL)\n+    return TRAVERSE_CONTINUE;\n+\n+  // At this stage of compilation traversing interface types traverses\n+  // the final list of methods, but we export the locally defined\n+  // methods.  If there is an embedded interface type we need to make\n+  // sure to export that.  Check classification, rather than calling\n+  // the interface_type method, because we want to handle named types\n+  // below.\n+  if (type->classification() == Type::TYPE_INTERFACE)\n+    {\n+      Interface_type* it = type->interface_type();\n+      const Typed_identifier_list* methods = it->local_methods();\n+      if (methods != NULL)\n+\t{\n+\t  for (Typed_identifier_list::const_iterator p = methods->begin();\n+\t       p != methods->end();\n+\t       ++p)\n+\t    {\n+\t      if (p->name().empty())\n+\t\tType::traverse(p->type(), this);\n+\t      else\n+\t\tthis->traverse_function(p->type()->function_type());\n+\t    }\n+\t}\n+      return TRAVERSE_SKIP_COMPONENTS;\n+    }\n+\n+  Named_type* nt = type->named_type();\n+  if (nt != NULL)\n+    this->traverse_named_type(nt);\n+\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Traverse the types in a function type.  We don't need the function\n+// type tself, just the receiver, parameter, and result types.\n+\n+void\n+Find_types_to_prepare::traverse_function(Function_type* type)\n+{\n+  go_assert(type != NULL);\n+  if (this->remember_type(type))\n+    return;\n+  const Typed_identifier* receiver = type->receiver();\n+  if (receiver != NULL)\n+    Type::traverse(receiver->type(), this);\n+  const Typed_identifier_list* parameters = type->parameters();\n+  if (parameters != NULL)\n+    parameters->traverse(this);\n+  const Typed_identifier_list* results = type->results();\n+  if (results != NULL)\n+    results->traverse(this);\n+}\n+\n+// Traverse the methods of a named type, and record its package.\n+\n+void\n+Find_types_to_prepare::traverse_named_type(Named_type* nt)\n+{\n+  const Package* package = nt->named_object()->package();\n+  if (package != NULL)\n+    this->imports_->insert(package);\n+\n+  // We have to traverse the methods of named types, because we are\n+  // going to export them.  This is not done by ordinary type\n+  // traversal.\n+  const Bindings* methods = nt->local_methods();\n+  if (methods != NULL)\n+    {\n+      for (Bindings::const_definitions_iterator pm =\n+\t     methods->begin_definitions();\n+\t   pm != methods->end_definitions();\n+\t   ++pm)\n+\tthis->traverse_function((*pm)->func_value()->type());\n+\n+      for (Bindings::const_declarations_iterator pm =\n+\t     methods->begin_declarations();\n+\t   pm != methods->end_declarations();\n+\t   ++pm)\n+\t{\n+\t  Named_object* mno = pm->second;\n+\t  if (mno->is_function_declaration())\n+\t    this->traverse_function(mno->func_declaration_value()->type());\n+\t}\n+    }\n+}\n+\n+// Collect all the pacakges we see in types, so that if we refer to\n+// any types from indirectly importe packages we can tell the importer\n+// about the package.\n+\n+void\n+Export::prepare_types(const std::vector<Named_object*>* exports,\n+\t\t      Unordered_set(const Package*)* imports)\n+{\n+  // Use a single index of the traversal class because traversal\n+  // classes keep track of which types they've already seen.  That\n+  // lets us avoid type reference loops.\n+  Find_types_to_prepare find(imports);\n+\n+  // Traverse all the exported objects.\n+  for (std::vector<Named_object*>::const_iterator p = exports->begin();\n+       p != exports->end();\n+       ++p)\n+    {\n+      Named_object* no = *p;\n+      switch (no->classification())\n+\t{\n+\tcase Named_object::NAMED_OBJECT_CONST:\n+\t  {\n+\t    Type* t = no->const_value()->type();\n+\t    if (t != NULL && !t->is_abstract())\n+\t      Type::traverse(t, &find);\n+\t  }\n+\t  break;\n+\n+\tcase Named_object::NAMED_OBJECT_TYPE:\n+\t  Type::traverse(no->type_value(), &find);\n+\t  break;\n+\n+\tcase Named_object::NAMED_OBJECT_VAR:\n+\t  Type::traverse(no->var_value()->type(), &find);\n+\t  break;\n+\n+\tcase Named_object::NAMED_OBJECT_FUNC:\n+\t  find.traverse_function(no->func_value()->type());\n+\t  break;\n+\n+\tcase Named_object::NAMED_OBJECT_FUNC_DECLARATION:\n+\t  find.traverse_function(no->func_declaration_value()->type());\n+\t  break;\n+\n+\tdefault:\n+\t  // We shouldn't see anything else.  If we do we'll give an\n+\t  // error later when we try to actually export it.\n+\t  break;\n+\t}\n+    }\n+}\n+\n // Sort packages.\n \n static bool\n@@ -253,14 +430,19 @@ import_compare(const std::pair<std::string, Package*>& a,\n // Write out the imported packages.\n \n void\n-Export::write_imports(const std::map<std::string, Package*>& imports)\n+Export::write_imports(const std::map<std::string, Package*>& imports,\n+\t\t      const Unordered_set(const Package*)& type_imports)\n {\n   // Sort the imports for more consistent output.\n+  Unordered_set(const Package*) seen;\n   std::vector<std::pair<std::string, Package*> > sorted_imports;\n   for (std::map<std::string, Package*>::const_iterator p = imports.begin();\n        p != imports.end();\n        ++p)\n-    sorted_imports.push_back(std::make_pair(p->first, p->second));\n+    {\n+      sorted_imports.push_back(std::make_pair(p->first, p->second));\n+      seen.insert(p->second);\n+    }\n \n   std::sort(sorted_imports.begin(), sorted_imports.end(), import_compare);\n \n@@ -279,6 +461,32 @@ Export::write_imports(const std::map<std::string, Package*>& imports)\n \n       this->packages_.insert(p->second);\n     }\n+\n+  // Write out a separate list of indirectly imported packages.\n+  std::vector<const Package*> indirect_imports;\n+  for (Unordered_set(const Package*)::const_iterator p =\n+\t type_imports.begin();\n+       p != type_imports.end();\n+       ++p)\n+    {\n+      if (seen.find(*p) == seen.end())\n+\tindirect_imports.push_back(*p);\n+    }\n+\n+  std::sort(indirect_imports.begin(), indirect_imports.end(),\n+\t    packages_compare);\n+\n+  for (std::vector<const Package*>::const_iterator p =\n+\t indirect_imports.begin();\n+       p != indirect_imports.end();\n+       ++p)\n+    {\n+      this->write_c_string(\"indirectimport \");\n+      this->write_string((*p)->package_name());\n+      this->write_c_string(\" \");\n+      this->write_string((*p)->pkgpath());\n+      this->write_c_string(\"\\n\");\n+    }\n }\n \n void\n@@ -602,19 +810,6 @@ Export::write_type(const Type* type)\n       s += \"\\\" \";\n       this->write_string(s);\n \n-      // It is possible that this type was imported indirectly, and is\n-      // not in a package in the import list.  If we have not\n-      // mentioned this package before, write out the package name\n-      // here so that any package importing this one will know it.\n-      if (package != NULL\n-\t  && this->packages_.find(package) == this->packages_.end())\n-\t{\n-\t  this->write_c_string(\"\\\"\");\n-\t  this->write_string(package->package_name());\n-\t  this->packages_.insert(package);\n-\t  this->write_c_string(\"\\\" \");\n-\t}\n-\n       // We must add a named type to the table now, since the\n       // definition of the type may refer to the named type via a\n       // pointer."}, {"sha": "55942818eec931994815b174dd41d3eab4628efb", "filename": "gcc/go/gofrontend/export.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2Fexport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2Fexport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.h?ref=dbf9376f9ed37bc98218adde4e17d6ee34701179", "patch": "@@ -12,6 +12,7 @@\n class Go_sha1_helper;\n class Gogo;\n class Import_init;\n+class Named_object;\n class Bindings;\n class Type;\n class Package;\n@@ -194,6 +195,11 @@ class Export : public String_dump\n   Export(const Export&);\n   Export& operator=(const Export&);\n \n+  // Prepare types for exporting.\n+  void\n+  prepare_types(const std::vector<Named_object*>* exports,\n+\t\tUnordered_set(const Package*)* imports);\n+\n   // Write out all known packages.\n   void\n   write_packages(const std::map<std::string, Package*>& packages);\n@@ -210,7 +216,8 @@ class Export : public String_dump\n \n   // Write out the imported packages.\n   void\n-  write_imports(const std::map<std::string, Package*>& imports);\n+  write_imports(const std::map<std::string, Package*>& imports,\n+\t\tconst Unordered_set(const Package*)& type_imports);\n \n   // Write out the imported initialization functions and init graph.\n   void"}, {"sha": "8d17df708fc189a54017d9078b971c186ab4b24d", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=dbf9376f9ed37bc98218adde4e17d6ee34701179", "patch": "@@ -397,6 +397,9 @@ Import::import(Gogo* gogo, const std::string& local_name,\n       while (stream->match_c_string(\"import\"))\n \tthis->read_one_import();\n \n+      while (stream->match_c_string(\"indirectimport\"))\n+\tthis->read_one_indirect_import();\n+\n       if (stream->match_c_string(\"init\"))\n \tthis->read_import_init_fns(gogo);\n \n@@ -458,7 +461,7 @@ Import::read_one_package()\n   p->set_package_name(package_name, this->location());\n }\n \n-// Read an import line.  We don't actually care about these.\n+// Read an import line.\n \n void\n Import::read_one_import()\n@@ -480,6 +483,22 @@ Import::read_one_import()\n   p->set_package_name(package_name, this->location());\n }\n \n+// Read an indirectimport line.\n+\n+void\n+Import::read_one_indirect_import()\n+{\n+  this->require_c_string(\"indirectimport \");\n+  std::string package_name = this->read_identifier();\n+  this->require_c_string(\" \");\n+  std::string pkgpath = this->read_identifier();\n+  this->require_c_string(\"\\n\");\n+\n+  Package* p = this->gogo_->register_package(pkgpath, \"\",\n+\t\t\t\t\t     Linemap::unknown_location());\n+  p->set_package_name(package_name, this->location());\n+}\n+\n // Read the list of import control functions and/or init graph.\n \n void"}, {"sha": "dbdcc8fb4896c8e6e9e357b220c4c8ec42236ad9", "filename": "gcc/go/gofrontend/import.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.h?ref=dbf9376f9ed37bc98218adde4e17d6ee34701179", "patch": "@@ -241,6 +241,10 @@ class Import\n   void\n   read_one_import();\n \n+  // Read an indirectimport line.\n+  void\n+  read_one_indirect_import();\n+\n   // Read the import control functions and init graph.\n   void\n   read_import_init_fns(Gogo*);"}, {"sha": "e766c77ab0afb89e0a58aef7c848bc6ca5ab7499", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=dbf9376f9ed37bc98218adde4e17d6ee34701179", "patch": "@@ -12113,7 +12113,7 @@ Typed_identifier_list::sort_by_name()\n // Traverse types.\n \n int\n-Typed_identifier_list::traverse(Traverse* traverse)\n+Typed_identifier_list::traverse(Traverse* traverse) const\n {\n   for (Typed_identifier_list::const_iterator p = this->begin();\n        p != this->end();"}, {"sha": "18cc2575bf544719978934a300add520f350063f", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf9376f9ed37bc98218adde4e17d6ee34701179/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=dbf9376f9ed37bc98218adde4e17d6ee34701179", "patch": "@@ -1499,7 +1499,7 @@ class Typed_identifier_list\n \n   // Traverse types.\n   int\n-  traverse(Traverse*);\n+  traverse(Traverse*) const;\n \n   // Return the first and last elements.\n   Typed_identifier&\n@@ -3056,8 +3056,15 @@ class Interface_type : public Type\n     return this->all_methods_ == NULL;\n   }\n \n-  // Return the list of methods.  This will return NULL for an empty\n-  // interface.\n+  // Return the list of locally defined methos.  This will return NULL\n+  // for an empty interface.  Embedded interfaces will appear in this\n+  // list as an entry with no name.\n+  const Typed_identifier_list*\n+  local_methods() const\n+  { return this->parse_methods_; }\n+\n+  // Return the list of all methods.  This will return NULL for an\n+  // empty interface.\n   const Typed_identifier_list*\n   methods() const;\n "}, {"sha": "cd4e1d9288e041ef78ad40d28cf11d336245caa1", "filename": "libgo/go/go/internal/gccgoimporter/parser.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbf9376f9ed37bc98218adde4e17d6ee34701179/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbf9376f9ed37bc98218adde4e17d6ee34701179/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go?ref=dbf9376f9ed37bc98218adde4e17d6ee34701179", "patch": "@@ -832,6 +832,7 @@ func (p *parser) parseInitDataDirective() {\n //             \"pkgpath\" unquotedString \";\" |\n //             \"prefix\" unquotedString \";\" |\n //             \"import\" unquotedString unquotedString string \";\" |\n+//             \"indirectimport\" unquotedString unquotedstring \";\" |\n //             \"func\" Func \";\" |\n //             \"type\" Type \";\" |\n //             \"var\" Var \";\" |\n@@ -875,6 +876,13 @@ func (p *parser) parseDirective() {\n \t\tp.parseString()\n \t\tp.expectEOL()\n \n+\tcase \"indirectimport\":\n+\t\tp.next()\n+\t\tpkgname := p.parseUnquotedString()\n+\t\tpkgpath := p.parseUnquotedString()\n+\t\tp.getPkg(pkgpath, pkgname)\n+\t\tp.expectEOL()\n+\n \tcase \"func\":\n \t\tp.next()\n \t\tfun := p.parseFunc(p.pkg)"}]}