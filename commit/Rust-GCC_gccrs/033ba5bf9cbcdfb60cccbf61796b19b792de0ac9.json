{"sha": "033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMzYmE1YmY5Y2JjZGZiNjBjY2NiZjYxNzk2YjE5Yjc5MmRlMGFjOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-11-10T19:45:17Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-11-10T19:45:17Z"}, "message": "fe.h (Serious_Errors_Detected): New macro.\n\n\t* fe.h (Serious_Errors_Detected): New macro.\n\t* gcc-interface/gigi.h (build_atomic_load): Declare.\n\t(build_atomic_store): Likewise.\n\t* gcc-interface/trans.c (atomic_sync_required_p): New predicate.\n\t(call_to_gnu): Add ATOMIC_SYNC parameter.  Use local variable.\n\tBuild an atomic load for an In or In Out parameter if needed.\n\tBuild an atomic store for the assignment of an Out parameter if needed.\n\tBuild an atomic store to the target if ATOMIC_SYNC is true.\n\t(present_in_lhs_or_actual_p): New predicate.\n\t(gnat_to_gnu) <N_Identifier>: Build an atomic load if needed.\n\t<N_Explicit_Dereference>: Likewise.\n\t<N_Indexed_Component>: Likewise.\n\t<N_Selected_Component>: Likewise.\n\t<N_Assignment_Statement>: Adjust call to call_to_gnu.\n\tBuild an atomic store to the LHS if needed.\n\t<N_Function_Call>:  Adjust call to call_to_gnu.\n\t* gcc-interface/utils2.c: Include toplev.h.\n\t(resolve_atomic_size): New static function.\n\t(build_atomic_load): New function.\n\t(build_atomic_store): Likewise.\n\t* gcc-interface/Make-lang.in (ada/utils2.o): Add toplev.h.\n\nFrom-SVN: r181267", "tree": {"sha": "5894e158f9de464a9516a560a37795fd3caeab43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5894e158f9de464a9516a560a37795fd3caeab43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/comments", "author": null, "committer": null, "parents": [{"sha": "8b01bdb087c5112274565d75c9db2250440ee044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b01bdb087c5112274565d75c9db2250440ee044", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b01bdb087c5112274565d75c9db2250440ee044"}], "stats": {"total": 696, "additions": 671, "deletions": 25}, "files": [{"sha": "83b31547640f15dffec11109858ec9fcb63a0273", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -1,3 +1,27 @@\n+2011-11-10  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* fe.h (Serious_Errors_Detected): New macro.\n+\t* gcc-interface/gigi.h (build_atomic_load): Declare.\n+\t(build_atomic_store): Likewise.\n+\t* gcc-interface/trans.c (atomic_sync_required_p): New predicate.\n+\t(call_to_gnu): Add ATOMIC_SYNC parameter.  Use local variable.\n+\tBuild an atomic load for an In or In Out parameter if needed.\n+\tBuild an atomic store for the assignment of an Out parameter if needed.\n+\tBuild an atomic store to the target if ATOMIC_SYNC is true.\n+\t(present_in_lhs_or_actual_p): New predicate.\n+\t(gnat_to_gnu) <N_Identifier>: Build an atomic load if needed.\n+\t<N_Explicit_Dereference>: Likewise.\n+\t<N_Indexed_Component>: Likewise.\n+\t<N_Selected_Component>: Likewise.\n+\t<N_Assignment_Statement>: Adjust call to call_to_gnu.\n+\tBuild an atomic store to the LHS if needed.\n+\t<N_Function_Call>:  Adjust call to call_to_gnu.\n+\t* gcc-interface/utils2.c: Include toplev.h.\n+\t(resolve_atomic_size): New static function.\n+\t(build_atomic_load): New function.\n+\t(build_atomic_store): Likewise.\n+\t* gcc-interface/Make-lang.in (ada/utils2.o): Add toplev.h.\n+\n 2011-11-07  Olivier Hainque  <hainque@adacore.com>\n \n \t* sigtramp-ppcvxw.c: Add general comments."}, {"sha": "fe6b22dc751ea49a40f88af371238de94939173e", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -92,13 +92,15 @@ extern void Set_Identifier_Casing (Char *, const Char *);\n \n /* err_vars: */\n \n-#define Error_Msg_Node_2     err_vars__error_msg_node_2\n-#define Error_Msg_Uint_1     err_vars__error_msg_uint_1\n-#define Error_Msg_Uint_2     err_vars__error_msg_uint_2\n-\n-extern Entity_Id             Error_Msg_Node_2;\n-extern Uint                  Error_Msg_Uint_1;\n-extern Uint                  Error_Msg_Uint_2;\n+#define Error_Msg_Node_2        err_vars__error_msg_node_2\n+#define Error_Msg_Uint_1        err_vars__error_msg_uint_1\n+#define Error_Msg_Uint_2        err_vars__error_msg_uint_2\n+#define Serious_Errors_Detected err_vars__serious_errors_detected\n+\n+extern Entity_Id Error_Msg_Node_2;\n+extern Uint      Error_Msg_Uint_1;\n+extern Uint      Error_Msg_Uint_2;\n+extern Nat       Serious_Errors_Detected;\n \n /* exp_ch11:  */\n "}, {"sha": "3ff28a6e7b1889a6d2ce2941c57ff8a34878fcc9", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -1297,7 +1297,7 @@ ada/utils.o : ada/gcc-interface/utils.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) -I.. $(ALL_CPPFLAGS) $< -o $@\n \n ada/utils2.o : ada/gcc-interface/utils2.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(TM_H) $(TREE_H) $(FLAGS_H) output.h $(TREE_INLINE_H) \\\n+   $(TM_H) $(TREE_H) $(FLAGS_H) toplev.h output.h $(TREE_INLINE_H) \\\n    ada/gcc-interface/ada.h ada/types.h ada/atree.h ada/elists.h ada/namet.h \\\n    ada/nlists.h ada/snames.h ada/stringt.h ada/uintp.h ada/fe.h ada/sinfo.h \\\n    ada/einfo.h $(ADA_TREE_H) ada/gcc-interface/gigi.h"}, {"sha": "e22c44476db9654a8860b39a47203c4df276a66a", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -804,6 +804,12 @@ extern unsigned int known_alignment (tree exp);\n    of 2.  */\n extern bool value_factor_p (tree value, HOST_WIDE_INT factor);\n \n+/* Build an atomic load for the underlying atomic object in SRC.  */\n+extern tree build_atomic_load (tree src);\n+\n+/* Build an atomic store from SRC to the underlying atomic object in DEST.  */\n+extern tree build_atomic_store (tree dest, tree src);\n+\n /* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n    desired for the result.  Usually the operation is to be performed\n    in that type.  For MODIFY_EXPR and ARRAY_REF, RESULT_TYPE may be 0"}, {"sha": "8a74e6ccb45b79ad875de1b1d284afa77e4f5830", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 137, "deletions": 17, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -3300,6 +3300,60 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   mark_out_of_scope (Defining_Unit_Name (Specification (gnat_node)));\n }\n \f\n+/* Return true if GNAT_NODE requires atomic synchronization.  */\n+\n+static bool\n+atomic_sync_required_p (Node_Id gnat_node)\n+{\n+  const Node_Id gnat_parent = Parent (gnat_node);\n+  Node_Kind kind;\n+  unsigned char attr_id;\n+\n+  /* First, scan the node to find the Atomic_Sync_Required flag.  */\n+  kind = Nkind (gnat_node);\n+  if (kind == N_Type_Conversion || kind == N_Unchecked_Type_Conversion)\n+    {\n+      gnat_node = Expression (gnat_node);\n+      kind = Nkind (gnat_node);\n+    }\n+\n+  switch (kind)\n+    {\n+    case N_Expanded_Name:\n+    case N_Explicit_Dereference:\n+    case N_Identifier:\n+    case N_Indexed_Component:\n+    case N_Selected_Component:\n+      if (!Atomic_Sync_Required (gnat_node))\n+\treturn false;\n+      break;\n+\n+    default:\n+      return false;\n+    }\n+\n+  /* Then, scan the parent to find out cases where the flag is irrelevant.  */\n+  kind = Nkind (gnat_parent);\n+  switch (kind)\n+    {\n+    case N_Attribute_Reference:\n+      attr_id = Get_Attribute_Id (Attribute_Name (gnat_parent));\n+      /* Do not mess up machine code insertions.  */\n+      if (attr_id == Attr_Asm_Input || attr_id == Attr_Asm_Output)\n+\treturn false;\n+      break;\n+\n+    case N_Object_Renaming_Declaration:\n+      /* Do not generate a function call as a renamed object.  */\n+      return false;\n+\n+    default:\n+      break;\n+    }\n+\n+  return true;\n+}\n+\f\n /* Create a temporary variable with PREFIX and TYPE, and return it.  */\n \n static tree\n@@ -3334,10 +3388,13 @@ create_init_temporary (const char *prefix, tree gnu_init, tree *gnu_init_stmt,\n    or an N_Procedure_Call_Statement, to a GCC tree, which is returned.\n    GNU_RESULT_TYPE_P is a pointer to where we should place the result type.\n    If GNU_TARGET is non-null, this must be a function call on the RHS of a\n-   N_Assignment_Statement and the result is to be placed into that object.  */\n+   N_Assignment_Statement and the result is to be placed into that object.\n+   If, in addition, ATOMIC_SYNC is true, then the assignment to GNU_TARGET\n+   requires atomic synchronization.  */\n \n static tree\n-call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n+call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n+\t     bool atomic_sync)\n {\n   const bool function_call = (Nkind (gnat_node) == N_Function_Call);\n   const bool returning_value = (function_call && !gnu_target);\n@@ -3433,6 +3490,11 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       tree gnu_formal_type = gnat_to_gnu_type (Etype (gnat_formal));\n       const bool is_true_formal_parm\n \t= gnu_formal && TREE_CODE (gnu_formal) == PARM_DECL;\n+      const bool is_by_ref_formal_parm\n+ \t= is_true_formal_parm\n+ \t  && (DECL_BY_REF_P (gnu_formal)\n+\t      || DECL_BY_COMPONENT_PTR_P (gnu_formal)\n+\t      || DECL_BY_DESCRIPTOR_P (gnu_formal));\n       /* In the Out or In Out case, we must suppress conversions that yield\n \t an lvalue but can nevertheless cause the creation of a temporary,\n \t because we need the real object in this case, either to pass its\n@@ -3462,10 +3524,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       /* If we are passing a non-addressable parameter by reference, pass the\n \t address of a copy.  In the Out or In Out case, set up to copy back\n \t out after the call.  */\n-      if (is_true_formal_parm\n-\t  && (DECL_BY_REF_P (gnu_formal)\n-\t      || DECL_BY_COMPONENT_PTR_P (gnu_formal)\n-\t      || DECL_BY_DESCRIPTOR_P (gnu_formal))\n+      if (is_by_ref_formal_parm\n \t  && (gnu_name_type = gnat_to_gnu_type (Etype (gnat_name)))\n \t  && !addressable_p (gnu_name, gnu_name_type))\n \t{\n@@ -3569,6 +3628,14 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       /* Start from the real object and build the actual.  */\n       gnu_actual = gnu_name;\n \n+      /* If this is an atomic access of an In or In Out parameter for which\n+\t synchronization is required, build the atomic load.  */\n+      if (is_true_formal_parm\n+\t  && !is_by_ref_formal_parm\n+\t  && Ekind (gnat_formal) != E_Out_Parameter\n+\t  && atomic_sync_required_p (gnat_actual))\n+\tgnu_actual = build_atomic_load (gnu_actual);\n+\n       /* If this was a procedure call, we may not have removed any padding.\n \t So do it here for the part we will use as an input, if any.  */\n       if (Ekind (gnat_formal) != E_Out_Parameter\n@@ -3865,8 +3932,11 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t  gnu_result = convert (TREE_TYPE (gnu_actual), gnu_result);\n \t      }\n \n-\t    gnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t\t\t  gnu_actual, gnu_result);\n+\t    if (atomic_sync_required_p (gnat_actual))\n+\t      gnu_result = build_atomic_store (gnu_actual, gnu_result);\n+\t    else\n+\t      gnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t\t\t    gnu_actual, gnu_result);\n \t    set_expr_location_from_node (gnu_result, gnat_node);\n \t    append_to_statement_list (gnu_result, &gnu_stmt_list);\n \t    gnu_cico_list = TREE_CHAIN (gnu_cico_list);\n@@ -3919,8 +3989,11 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  else\n \t    op_code = MODIFY_EXPR;\n \n-\t  gnu_call\n-\t    = build_binary_op (op_code, NULL_TREE, gnu_target, gnu_call);\n+\t  if (atomic_sync)\n+\t    gnu_call = build_atomic_store (gnu_target, gnu_call);\n+\t  else\n+\t    gnu_call\n+\t      = build_binary_op (op_code, NULL_TREE, gnu_target, gnu_call);\n \t  set_expr_location_from_node (gnu_call, gnat_parent);\n \t  append_to_statement_list (gnu_call, &gnu_stmt_list);\n \t}\n@@ -4494,6 +4567,26 @@ lhs_or_actual_p (Node_Id gnat_node)\n   return false;\n }\n \n+/* Return true if either GNAT_NODE or a view of GNAT_NODE is on the LHS\n+   of an assignment or an actual parameter of a call.  */\n+\n+static bool\n+present_in_lhs_or_actual_p (Node_Id gnat_node)\n+{\n+  Node_Kind kind;\n+\n+  if (lhs_or_actual_p (gnat_node))\n+    return true;\n+\n+  kind = Nkind (Parent (gnat_node));\n+\n+  if ((kind == N_Type_Conversion || kind == N_Unchecked_Type_Conversion)\n+      && lhs_or_actual_p (Parent (gnat_node)))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Return true if GNAT_NODE, an unchecked type conversion, is a no-op as far\n    as gigi is concerned.  This is used to avoid conversions on the LHS.  */\n \n@@ -4613,6 +4706,12 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Operator_Symbol:\n     case N_Defining_Identifier:\n       gnu_result = Identifier_to_gnu (gnat_node, &gnu_result_type);\n+\n+      /* If this is an atomic access on the RHS for which synchronization is\n+\t required, build the atomic load.  */\n+      if (atomic_sync_required_p (gnat_node)\n+\t  && !present_in_lhs_or_actual_p (gnat_node))\n+\tgnu_result = build_atomic_load (gnu_result);\n       break;\n \n     case N_Integer_Literal:\n@@ -4897,6 +4996,12 @@ gnat_to_gnu (Node_Id gnat_node)\n       gnu_result = gnat_to_gnu (Prefix (gnat_node));\n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n       gnu_result = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n+\n+      /* If this is an atomic access on the RHS for which synchronization is\n+\t required, build the atomic load.  */\n+      if (atomic_sync_required_p (gnat_node)\n+\t  && !present_in_lhs_or_actual_p (gnat_node))\n+\tgnu_result = build_atomic_load (gnu_result);\n       break;\n \n     case N_Indexed_Component:\n@@ -4963,9 +5068,15 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_result = build_binary_op (ARRAY_REF, NULL_TREE,\n \t\t\t\t\t  gnu_result, gnu_expr);\n \t  }\n-      }\n \n-      gnu_result_type = get_unpadded_type (Etype (gnat_node));\n+\tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n+\n+\t/* If this is an atomic access on the RHS for which synchronization is\n+\t   required, build the atomic load.  */\n+\tif (atomic_sync_required_p (gnat_node)\n+\t    && !present_in_lhs_or_actual_p (gnat_node))\n+\t  gnu_result = build_atomic_load (gnu_result);\n+      }\n       break;\n \n     case N_Slice:\n@@ -5110,8 +5221,13 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t\t(Parent (gnat_node)));\n \t  }\n \n-\tgcc_assert (gnu_result);\n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n+\n+\t/* If this is an atomic access on the RHS for which synchronization is\n+\t   required, build the atomic load.  */\n+\tif (atomic_sync_required_p (gnat_node)\n+\t    && !present_in_lhs_or_actual_p (gnat_node))\n+\t  gnu_result = build_atomic_load (gnu_result);\n       }\n       break;\n \n@@ -5618,7 +5734,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t       N_Raise_Storage_Error);\n       else if (Nkind (Expression (gnat_node)) == N_Function_Call)\n \tgnu_result\n-\t  = call_to_gnu (Expression (gnat_node), &gnu_result_type, gnu_lhs);\n+\t  = call_to_gnu (Expression (gnat_node), &gnu_result_type, gnu_lhs,\n+\t\t\t atomic_sync_required_p (Name (gnat_node)));\n       else\n \t{\n \t  gnu_rhs\n@@ -5629,8 +5746,11 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_rhs = emit_range_check (gnu_rhs, Etype (Name (gnat_node)),\n \t\t\t\t\tgnat_node);\n \n-\t  gnu_result\n-\t    = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_lhs, gnu_rhs);\n+\t  if (atomic_sync_required_p (Name (gnat_node)))\n+\t    gnu_result = build_atomic_store (gnu_lhs, gnu_rhs);\n+\t  else\n+\t    gnu_result\n+\t      = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_lhs, gnu_rhs);\n \n \t  /* If the type being assigned is an array type and the two sides are\n \t     not completely disjoint, play safe and use memmove.  But don't do\n@@ -5880,7 +6000,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Function_Call:\n     case N_Procedure_Call_Statement:\n-      gnu_result = call_to_gnu (gnat_node, &gnu_result_type, NULL_TREE);\n+      gnu_result = call_to_gnu (gnat_node, &gnu_result_type, NULL_TREE, false);\n       break;\n \n     /************************/"}, {"sha": "c303e2f20a3fed227928b916f69db972f16ec174", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -29,6 +29,7 @@\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n+#include \"toplev.h\"\n #include \"ggc.h\"\n #include \"output.h\"\n #include \"tree-inline.h\"\n@@ -590,6 +591,112 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n   return convert (type, result);\n }\n \f\n+/* This page contains routines that implement the Ada semantics with regard\n+   to atomic objects.  They are fully piggybacked on the middle-end support\n+   for atomic loads and stores.\n+\n+   *** Memory barriers and volatile objects ***\n+\n+   We implement the weakened form of the C.6(16) clause that was introduced\n+   in Ada 2012 (AI05-117).  Earlier forms of this clause wouldn't have been\n+   implementable without significant performance hits on modern platforms.\n+\n+   We also take advantage of the requirements imposed on shared variables by\n+   9.10 (conditions for sequential actions) to have non-erroneous execution\n+   and consider that C.6(16) and C.6(17) only prescribe an uniform order of\n+   volatile updates with regard to sequential actions, i.e. with regard to\n+   reads or updates of atomic objects.\n+\n+   As such, an update of an atomic object by a task requires that all earlier\n+   accesses to volatile objects have completed.  Similarly, later accesses to\n+   volatile objects cannot be reordered before the update of the atomic object.\n+   So, memory barriers both before and after the atomic update are needed.\n+\n+   For a read of an atomic object, to avoid seeing writes of volatile objects\n+   by a task earlier than by the other tasks, a memory barrier is needed before\n+   the atomic read.  Finally, to avoid reordering later reads or updates of\n+   volatile objects to before the atomic read, a barrier is needed after the\n+   atomic read.\n+\n+   So, memory barriers are needed before and after atomic reads and updates.\n+   And, in order to simplify the implementation, we use full memory barriers\n+   in all cases, i.e. we enforce sequential consistency for atomic accesses.  */\n+\n+/* Return the size of TYPE, which must be a positive power of 2.  */\n+\n+static unsigned int\n+resolve_atomic_size (tree type)\n+{\n+  unsigned HOST_WIDE_INT size = tree_low_cst (TYPE_SIZE_UNIT (type), 1);\n+\n+  if (size == 1 || size == 2 || size == 4 || size == 8 || size == 16)\n+    return size;\n+\n+  /* We shouldn't reach here without having already detected that the size\n+     isn't compatible with an atomic access.  */\n+  gcc_assert (Serious_Errors_Detected);\n+\n+  return 0;\n+}\n+\n+/* Build an atomic load for the underlying atomic object in SRC.  */\n+\n+tree\n+build_atomic_load (tree src)\n+{\n+  tree ptr_type\n+    = build_pointer_type\n+      (build_qualified_type (void_type_node, TYPE_QUAL_VOLATILE));\n+  tree mem_model = build_int_cst (integer_type_node, MEMMODEL_SEQ_CST);\n+  tree orig_src = src;\n+  tree type = TREE_TYPE (src);\n+  tree t, val;\n+  unsigned int size;\n+  int fncode;\n+\n+  src = remove_conversions (src, false);\n+  size = resolve_atomic_size (TREE_TYPE (src));\n+  if (size == 0)\n+    return orig_src;\n+\n+  fncode = (int) BUILT_IN_ATOMIC_LOAD_N + exact_log2 (size) + 1;\n+  t = builtin_decl_implicit ((enum built_in_function) fncode);\n+\n+  src = build_unary_op (ADDR_EXPR, ptr_type, src);\n+  val = build_call_expr (t, 2, src, mem_model);\n+\n+  return unchecked_convert (type, val, true);\n+}\n+\n+/* Build an atomic store from SRC to the underlying atomic object in DEST.  */\n+\n+tree\n+build_atomic_store (tree dest, tree src)\n+{\n+  tree ptr_type\n+    = build_pointer_type\n+      (build_qualified_type (void_type_node, TYPE_QUAL_VOLATILE));\n+  tree mem_model = build_int_cst (integer_type_node, MEMMODEL_SEQ_CST);\n+  tree orig_dest = dest;\n+  tree t, int_type;\n+  unsigned int size;\n+  int fncode;\n+\n+  dest = remove_conversions (dest, false);\n+  size = resolve_atomic_size (TREE_TYPE (dest));\n+  if (size == 0)\n+    return build_binary_op (MODIFY_EXPR, NULL_TREE, orig_dest, src);\n+\n+  fncode = (int) BUILT_IN_ATOMIC_STORE_N + exact_log2 (size) + 1;\n+  t = builtin_decl_implicit ((enum built_in_function) fncode);\n+  int_type = gnat_type_for_size (BITS_PER_UNIT * size, 1);\n+\n+  dest = build_unary_op (ADDR_EXPR, ptr_type, dest);\n+  src = unchecked_convert (int_type, src, true);\n+\n+  return build_call_expr (t, 3, dest, src, mem_model);\n+}\n+\f\n /* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n    desired for the result.  Usually the operation is to be performed\n    in that type.  For INIT_EXPR and MODIFY_EXPR, RESULT_TYPE must be"}, {"sha": "e9887972d239d1c61359e6d7f254efc5be0c4ab3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -1,3 +1,15 @@\n+2011-11-10  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/atomic6_1.adb: New test.\n+\t* gnat.dg/atomic6_2.adb: Likewise.\n+\t* gnat.dg/atomic6_3.adb: Likewise.\n+\t* gnat.dg/atomic6_4.adb: Likewise.\n+\t* gnat.dg/atomic6_5.adb: Likewise.\n+\t* gnat.dg/atomic6_6.adb: Likewise.\n+\t* gnat.dg/atomic6_7.adb: Likewise.\n+\t* gnat.dg/atomic6_8.adb: Likewise.\n+\t* gnat.dg/atomic6_pkg.ads: New helper.\n+\n 2011-11-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/51077"}, {"sha": "714ceb6d2322a032d0f5d4d3a602c9be0d264c13", "filename": "gcc/testsuite/gnat.dg/atomic6_1.adb", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_1.adb?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -0,0 +1,39 @@\n+-- { dg-do compile }\n+-- { dg-options \"-fdump-tree-gimple\" }\n+\n+with Atomic6_Pkg; use Atomic6_Pkg;\n+\n+procedure Atomic6_1 is\n+  Temp : Integer;\n+begin\n+\n+  Counter1 := Counter2;\n+\n+  Timer1 := Timer2;\n+\n+  Counter1 := Int(Timer1);\n+  Timer1 := Integer(Counter1);\n+\n+  Temp := Integer(Counter1);\n+  Counter1 := Int(Temp);\n+\n+  Temp := Timer1;\n+  Timer1 := Temp;\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter1\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer1\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "4ecef9b18baf8e76c382e35ad52db91387a8b27d", "filename": "gcc/testsuite/gnat.dg/atomic6_2.adb", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_2.adb?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -0,0 +1,45 @@\n+-- { dg-do compile }\n+-- { dg-options \"-fdump-tree-gimple\" }\n+\n+with Atomic6_Pkg; use Atomic6_Pkg;\n+\n+procedure Atomic6_2 is\n+  Temp : Integer;\n+begin\n+\n+  Counter1 := Counter1 + Counter2;\n+\n+  Timer1 := Timer1 + Timer2;\n+\n+  Counter1 := Counter1 + Int(Timer1);\n+  Timer1 := Timer1 + Integer(Counter1);\n+\n+  Temp := Integer(Counter1) + Timer1;\n+  Counter1 := Int(Timer1) + Int(Temp);\n+  Timer1 := Integer(Counter1) + Temp;\n+\n+  if Counter1 /= Counter2 then\n+    raise Program_Error;\n+  end if;\n+\n+  if Timer1 /= Timer2 then\n+    raise Program_Error;\n+  end if;\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter1\" 6 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer1\" 6 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "86b6d814202e80eb88df4311c6bc3edc96ae3f22", "filename": "gcc/testsuite/gnat.dg/atomic6_3.adb", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_3.adb?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -0,0 +1,58 @@\n+-- { dg-do compile }\n+-- { dg-options \"-fdump-tree-gimple\" }\n+\n+with Atomic6_Pkg; use Atomic6_Pkg;\n+\n+procedure Atomic6_3 is\n+\n+  function F (I : Integer) return Integer is\n+  begin\n+    return I;\n+  end;\n+\n+  function F2 return Integer is\n+  begin\n+    return Integer(Counter1);\n+  end;\n+\n+  function F3 return Integer is\n+  begin\n+    return Timer1;\n+  end;\n+\n+  Temp : Integer;\n+begin\n+\n+  Counter1 := Int(F(Integer(Counter2)));\n+\n+  Timer1 := F(Timer2);\n+\n+  Counter1 := Int(F(Timer1));\n+  Timer1 := F(Integer(Counter1));\n+\n+  Temp := F(Integer(Counter1));\n+  Counter1 := Int(F(Temp));\n+\n+  Temp := F(Timer1);\n+  Timer1 := F(Temp);\n+\n+  Temp := F2;\n+  Temp := F3;\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "cf960fb69cc4d6b927f106cf84078fa449a8368d", "filename": "gcc/testsuite/gnat.dg/atomic6_4.adb", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_4.adb?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -0,0 +1,45 @@\n+-- { dg-do compile }\n+-- { dg-options \"-fdump-tree-gimple\" }\n+\n+with Atomic6_Pkg; use Atomic6_Pkg;\n+\n+procedure Atomic6_4 is\n+\n+  procedure P (I1 : out Integer; I2 : in Integer) is\n+  begin\n+    I1 := I2;\n+  end;\n+\n+  Temp : Integer;\n+begin\n+\n+  P (Integer(Counter1), Integer(Counter2));\n+\n+  P (Timer1, Timer2);\n+\n+  P (Integer(Counter1), Timer1);\n+  P (Timer1, Integer(Counter1));\n+\n+  P (Temp, Integer(Counter1));\n+  P (Integer(Counter1), Temp);\n+\n+  P (Temp, Timer1);\n+  P (Timer1, Temp);\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter1\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer1\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "5490f3a90c0529370d79f02f3b1b808819052e55", "filename": "gcc/testsuite/gnat.dg/atomic6_5.adb", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_5.adb?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -0,0 +1,38 @@\n+-- { dg-do compile }\n+-- { dg-options \"-fdump-tree-gimple\" }\n+\n+with Atomic6_Pkg; use Atomic6_Pkg;\n+\n+procedure Atomic6_5 is\n+  type Arr is array (Integer range 1 .. 4) of Boolean;\n+  A : Arr;\n+  B : Boolean;\n+begin\n+\n+  A (Integer(Counter1)) := True;\n+  B := A (Timer1);\n+\n+  declare\n+    pragma Suppress (Index_Check);\n+  begin\n+    A (Integer(Counter1)) := True;\n+    B := A (Timer1);\n+  end;\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter1\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer1\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter1\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer1\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "2c217f68f9a278eabd844108c8dbe3a73d52e94e", "filename": "gcc/testsuite/gnat.dg/atomic6_6.adb", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_6.adb?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -0,0 +1,39 @@\n+-- { dg-do compile }\n+-- { dg-options \"-fdump-tree-gimple\" }\n+\n+with Atomic6_Pkg; use Atomic6_Pkg;\n+\n+procedure Atomic6_6 is\n+  Temp : Integer;\n+begin\n+\n+  Counter(1) := Counter(2);\n+\n+  Timer(1) := Timer(2);\n+\n+  Counter(1) := Int(Timer(1));\n+  Timer(1) := Integer(Counter(1));\n+\n+  Temp := Integer(Counter(1));\n+  Counter(1) := Int(Temp);\n+\n+  Temp := Timer(1);\n+  Timer(1) := Temp;\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter\\\\\\[1\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter\\\\\\[2\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer\\\\\\[1\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer\\\\\\[2\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter\\\\\\[1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter\\\\\\[2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer\\\\\\[1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer\\\\\\[2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "8b48bf5165ddb31426be5533cf1d64d3d19f1029", "filename": "gcc/testsuite/gnat.dg/atomic6_7.adb", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_7.adb?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -0,0 +1,40 @@\n+-- { dg-do compile }\n+-- { dg-options \"-fdump-tree-gimple\" }\n+\n+with Atomic6_Pkg; use Atomic6_Pkg;\n+\n+procedure Atomic6_7 is\n+  My_Atomic  : R;\n+  Temp : Integer;\n+begin\n+\n+  My_Atomic.Counter1 := Counter2;\n+\n+  My_Atomic.Timer1 := Timer2;\n+\n+  My_Atomic.Counter1 := Int(My_Atomic.Timer1);\n+  My_Atomic.Timer1 := Integer(My_Atomic.Counter1);\n+\n+  Temp := Integer(My_Atomic.Counter1);\n+  My_Atomic.Counter1 := Int(Temp);\n+\n+  Temp := My_Atomic.Timer1;\n+  My_Atomic.Timer1 := Temp;\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&my_atomic.counter1\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&my_atomic.timer1\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&my_atomic.counter1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&my_atomic.timer1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*ptr\" 0 \"gimple\"} }\n+\n+-- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "7d39396866a4236a7496291b40417f22a5bab208", "filename": "gcc/testsuite/gnat.dg/atomic6_8.adb", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_8.adb?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -0,0 +1,37 @@\n+-- { dg-do compile }\n+-- { dg-options \"-fdump-tree-gimple\" }\n+\n+with Atomic6_Pkg; use Atomic6_Pkg;\n+\n+procedure Atomic6_8 is\n+  Ptr : Int_Ptr := new Int;\n+  Temp : Integer;\n+begin\n+\n+  Ptr.all := Counter1;\n+\n+  Counter1 := Ptr.all;\n+\n+  Ptr.all := Int(Timer1);\n+  Timer1 := Integer(Ptr.all);\n+\n+  Temp := Integer(Ptr.all);\n+  Ptr.all := Int(Temp);\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter1\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer1\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*ptr\" 3 \"gimple\"} }\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter1\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__counter2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer1\" 1 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&atomic6_pkg__timer2\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*ptr\" 3 \"gimple\"} }\n+\n+-- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "aad24357ebc85e57c905d2f0f9bf91909f0a106d", "filename": "gcc/testsuite/gnat.dg/atomic6_pkg.ads", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/033ba5bf9cbcdfb60cccbf61796b19b792de0ac9/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fatomic6_pkg.ads?ref=033ba5bf9cbcdfb60cccbf61796b19b792de0ac9", "patch": "@@ -0,0 +1,34 @@\n+package Atomic6_Pkg is\n+\n+  type Int is new Integer;\n+  pragma Atomic (Int);\n+\n+  Counter1 : Int;\n+  Counter2 : Int;\n+\n+  Timer1 : Integer;\n+  pragma Atomic (Timer1);\n+\n+  Timer2 : Integer;\n+  pragma Atomic (Timer2);\n+\n+  type Arr1 is array (1..8) of Int;\n+  Counter : Arr1;\n+\n+  type Arr2 is array (1..8) of Integer;\n+  pragma Atomic_Components (Arr2);\n+  Timer : Arr2;\n+\n+  type R is record\n+    Counter1 : Int;\n+    Timer1 : Integer;\n+    pragma Atomic (Timer1);\n+    Counter2 : Int;\n+    Timer2 : Integer;\n+    pragma Atomic (Timer2);\n+    Dummy : Integer;\n+  end record;\n+\n+  type Int_Ptr is access all Int;\n+\n+end Atomic6_Pkg;"}]}