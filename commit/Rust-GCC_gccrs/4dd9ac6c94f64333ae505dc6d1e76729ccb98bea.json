{"sha": "4dd9ac6c94f64333ae505dc6d1e76729ccb98bea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRkOWFjNmM5NGY2NDMzM2FlNTA1ZGM2ZDFlNzY3MjljY2I5OGJlYQ==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim.kuvyrkov@gmail.com", "date": "2014-10-24T08:22:12Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2014-10-24T08:22:12Z"}, "message": "Account for prologue spills in reg_pressure scheduling\n\n\t* haifa-sched.c (sched_class_regs_num, call_used_regs_num): New static\n\tarrays.  Use sched_class_regs_num instead of ira_class_hard_regs_num.\n\t(print_curr_reg_pressure, setup_insn_reg_pressure_info,)\n\t(model_update_pressure, model_spill_cost): Use sched_class_regs_num.\n\t(model_start_schedule): Update.\n\t(sched_pressure_start_bb): New static function.  Calculate\n\tsched_class_regs_num.\n\t(schedule_block): Use it.\n\t(alloc_global_sched_pressure_data): Calculate call_used_regs_num.\n\nFrom-SVN: r216620", "tree": {"sha": "cf083b72295dba3eccd3df751f1c531a3ae754ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf083b72295dba3eccd3df751f1c531a3ae754ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dd9ac6c94f64333ae505dc6d1e76729ccb98bea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dd9ac6c94f64333ae505dc6d1e76729ccb98bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dd9ac6c94f64333ae505dc6d1e76729ccb98bea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dd9ac6c94f64333ae505dc6d1e76729ccb98bea/comments", "author": {"login": "maxim-kuvyrkov", "id": 12545699, "node_id": "MDQ6VXNlcjEyNTQ1Njk5", "avatar_url": "https://avatars.githubusercontent.com/u/12545699?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maxim-kuvyrkov", "html_url": "https://github.com/maxim-kuvyrkov", "followers_url": "https://api.github.com/users/maxim-kuvyrkov/followers", "following_url": "https://api.github.com/users/maxim-kuvyrkov/following{/other_user}", "gists_url": "https://api.github.com/users/maxim-kuvyrkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/maxim-kuvyrkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maxim-kuvyrkov/subscriptions", "organizations_url": "https://api.github.com/users/maxim-kuvyrkov/orgs", "repos_url": "https://api.github.com/users/maxim-kuvyrkov/repos", "events_url": "https://api.github.com/users/maxim-kuvyrkov/events{/privacy}", "received_events_url": "https://api.github.com/users/maxim-kuvyrkov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef1ea28c3ce49265644432679fddf777b0176df6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef1ea28c3ce49265644432679fddf777b0176df6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef1ea28c3ce49265644432679fddf777b0176df6"}], "stats": {"total": 103, "additions": 90, "deletions": 13}, "files": [{"sha": "084fa812a45c4ade22507af1686b4fc4de7bbbf7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dd9ac6c94f64333ae505dc6d1e76729ccb98bea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dd9ac6c94f64333ae505dc6d1e76729ccb98bea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4dd9ac6c94f64333ae505dc6d1e76729ccb98bea", "patch": "@@ -1,3 +1,15 @@\n+2014-10-24  Maxim Kuvyrkov  <maxim.kuvyrkov@gmail.com>\n+\n+\t* haifa-sched.c (sched_class_regs_num, call_used_regs_num): New static\n+\tarrays.  Use sched_class_regs_num instead of ira_class_hard_regs_num.\n+\t(print_curr_reg_pressure, setup_insn_reg_pressure_info,)\n+\t(model_update_pressure, model_spill_cost): Use sched_class_regs_num.\n+\t(model_start_schedule): Update.\n+\t(sched_pressure_start_bb): New static function.  Calculate\n+\tsched_class_regs_num.\n+\t(schedule_block): Use it.\n+\t(alloc_global_sched_pressure_data): Calculate call_used_regs_num.\n+\n 2014-10-24  Richard Biener  <rguenther@suse.de>\n \n \t* Makefile.in (BUILD_CPPLIB): When in stage2+ use the"}, {"sha": "6cc34b20ab2a34d579a07f97f51e7820faf2539d", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 78, "deletions": 13, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dd9ac6c94f64333ae505dc6d1e76729ccb98bea/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dd9ac6c94f64333ae505dc6d1e76729ccb98bea/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=4dd9ac6c94f64333ae505dc6d1e76729ccb98bea", "patch": "@@ -933,6 +933,13 @@ static bitmap saved_reg_live;\n /* Registers mentioned in the current region.  */\n static bitmap region_ref_regs;\n \n+/* Effective number of available registers of a given class (see comment\n+   in sched_pressure_start_bb).  */\n+static int sched_class_regs_num[N_REG_CLASSES];\n+/* Number of call_used_regs.  This is a helper for calculating of\n+   sched_class_regs_num.  */\n+static int call_used_regs_num[N_REG_CLASSES];\n+\n /* Initiate register pressure relative info for scheduling the current\n    region.  Currently it is only clearing register mentioned in the\n    current region.  */\n@@ -1116,7 +1123,7 @@ print_curr_reg_pressure (void)\n       gcc_assert (curr_reg_pressure[cl] >= 0);\n       fprintf (sched_dump, \"  %s:%d(%d)\", reg_class_names[cl],\n \t       curr_reg_pressure[cl],\n-\t       curr_reg_pressure[cl] - ira_class_hard_regs_num[cl]);\n+\t       curr_reg_pressure[cl] - sched_class_regs_num[cl]);\n     }\n   fprintf (sched_dump, \"\\n\");\n }\n@@ -1731,9 +1738,9 @@ setup_insn_reg_pressure_info (rtx_insn *insn)\n       cl = ira_pressure_classes[i];\n       gcc_assert (curr_reg_pressure[cl] >= 0);\n       change = (int) pressure_info[i].set_increase - death[cl];\n-      before = MAX (0, max_reg_pressure[i] - ira_class_hard_regs_num[cl]);\n+      before = MAX (0, max_reg_pressure[i] - sched_class_regs_num[cl]);\n       after = MAX (0, max_reg_pressure[i] + change\n-\t\t   - ira_class_hard_regs_num[cl]);\n+\t\t   - sched_class_regs_num[cl]);\n       hard_regno = ira_class_hard_regs[cl][0];\n       gcc_assert (hard_regno >= 0);\n       mode = reg_raw_mode[hard_regno];\n@@ -2070,7 +2077,7 @@ model_update_pressure (struct model_pressure_group *group,\n \n       /* Check whether the maximum pressure in the overall schedule\n \t has increased.  (This means that the MODEL_MAX_PRESSURE of\n-\t every point <= POINT will need to increae too; see below.)  */\n+\t every point <= POINT will need to increase too; see below.)  */\n       if (group->limits[pci].pressure < ref_pressure)\n \tgroup->limits[pci].pressure = ref_pressure;\n \n@@ -2347,7 +2354,7 @@ must_restore_pattern_p (rtx_insn *next, dep_t dep)\n /* Return the cost of increasing the pressure in class CL from FROM to TO.\n \n    Here we use the very simplistic cost model that every register above\n-   ira_class_hard_regs_num[CL] has a spill cost of 1.  We could use other\n+   sched_class_regs_num[CL] has a spill cost of 1.  We could use other\n    measures instead, such as one based on MEMORY_MOVE_COST.  However:\n \n       (1) In order for an instruction to be scheduled, the higher cost\n@@ -2371,7 +2378,7 @@ must_restore_pattern_p (rtx_insn *next, dep_t dep)\n static int\n model_spill_cost (int cl, int from, int to)\n {\n-  from = MAX (from, ira_class_hard_regs_num[cl]);\n+  from = MAX (from, sched_class_regs_num[cl]);\n   return MAX (to, from) - from;\n }\n \n@@ -2477,7 +2484,7 @@ model_set_excess_costs (rtx_insn **insns, int count)\n   bool print_p;\n \n   /* Record the baseECC value for each instruction in the model schedule,\n-     except that negative costs are converted to zero ones now rather thatn\n+     except that negative costs are converted to zero ones now rather than\n      later.  Do not assign a cost to debug instructions, since they must\n      not change code-generation decisions.  Experiments suggest we also\n      get better results by not assigning a cost to instructions from\n@@ -3727,15 +3734,13 @@ model_dump_pressure_summary (void)\n    scheduling region.  */\n \n static void\n-model_start_schedule (void)\n+model_start_schedule (basic_block bb)\n {\n-  basic_block bb;\n-\n   model_next_priority = 1;\n   model_schedule.create (sched_max_luid);\n   model_insns = XCNEWVEC (struct model_insn_info, sched_max_luid);\n \n-  bb = BLOCK_FOR_INSN (NEXT_INSN (current_sched_info->prev_head));\n+  gcc_assert (bb == BLOCK_FOR_INSN (NEXT_INSN (current_sched_info->prev_head)));\n   initiate_reg_pressure_info (df_get_live_in (bb));\n \n   model_analyze_insns ();\n@@ -3773,6 +3778,53 @@ model_end_schedule (void)\n   model_finalize_pressure_group (&model_before_pressure);\n   model_schedule.release ();\n }\n+\n+/* Prepare reg pressure scheduling for basic block BB.  */\n+static void\n+sched_pressure_start_bb (basic_block bb)\n+{\n+  /* Set the number of available registers for each class taking into account\n+     relative probability of current basic block versus function prologue and\n+     epilogue.\n+     * If the basic block executes much more often than the prologue/epilogue\n+     (e.g., inside a hot loop), then cost of spill in the prologue is close to\n+     nil, so the effective number of available registers is\n+     (ira_class_hard_regs_num[cl] - 0).\n+     * If the basic block executes as often as the prologue/epilogue,\n+     then spill in the block is as costly as in the prologue, so the effective\n+     number of available registers is\n+     (ira_class_hard_regs_num[cl] - call_used_regs_num[cl]).\n+     Note that all-else-equal, we prefer to spill in the prologue, since that\n+     allows \"extra\" registers for other basic blocks of the function.\n+     * If the basic block is on the cold path of the function and executes\n+     rarely, then we should always prefer to spill in the block, rather than\n+     in the prologue/epilogue.  The effective number of available register is\n+     (ira_class_hard_regs_num[cl] - call_used_regs_num[cl]).  */\n+  {\n+    int i;\n+    int entry_freq = ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency;\n+    int bb_freq = bb->frequency;\n+\n+    if (bb_freq == 0)\n+      {\n+\tif (entry_freq == 0)\n+\t  entry_freq = bb_freq = 1;\n+      }\n+    if (bb_freq < entry_freq)\n+      bb_freq = entry_freq;\n+\n+    for (i = 0; i < ira_pressure_classes_num; ++i)\n+      {\n+\tenum reg_class cl = ira_pressure_classes[i];\n+\tsched_class_regs_num[cl] = ira_class_hard_regs_num[cl];\n+\tsched_class_regs_num[cl]\n+\t  -= (call_used_regs_num[cl] * entry_freq) / bb_freq;\n+      }\n+  }\n+\n+  if (sched_pressure == SCHED_PRESSURE_MODEL)\n+    model_start_schedule (bb);\n+}\n \f\n /* A structure that holds local state for the loop in schedule_block.  */\n struct sched_block_state\n@@ -6053,8 +6105,8 @@ schedule_block (basic_block *target_bb, state_t init_state)\n      in try_ready () (which is called through init_ready_list ()).  */\n   (*current_sched_info->init_ready_list) ();\n \n-  if (sched_pressure == SCHED_PRESSURE_MODEL)\n-    model_start_schedule ();\n+  if (sched_pressure)\n+    sched_pressure_start_bb (*target_bb);\n \n   /* The algorithm is O(n^2) in the number of ready insns at any given\n      time in the worst case.  Before reload we are more likely to have\n@@ -6701,6 +6753,19 @@ alloc_global_sched_pressure_data (void)\n \t  saved_reg_live = BITMAP_ALLOC (NULL);\n \t  region_ref_regs = BITMAP_ALLOC (NULL);\n \t}\n+\n+      /* Calculate number of CALL_USED_REGS in register classes that\n+\t we calculate register pressure for.  */\n+      for (int c = 0; c < ira_pressure_classes_num; ++c)\n+\t{\n+\t  enum reg_class cl = ira_pressure_classes[c];\n+\n+\t  call_used_regs_num[cl] = 0;\n+\n+\t  for (int i = 0; i < ira_class_hard_regs_num[cl]; ++i)\n+\t    if (call_used_regs[ira_class_hard_regs[cl][i]])\n+\t      ++call_used_regs_num[cl];\n+\t}\n     }\n }\n "}]}