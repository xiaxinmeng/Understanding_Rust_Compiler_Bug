{"sha": "949087624366a022cbe51f395eb41748cb0921fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ5MDg3NjI0MzY2YTAyMmNiZTUxZjM5NWViNDE3NDhjYjA5MjFmZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-06-23T22:00:44Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-06-23T22:00:44Z"}, "message": "tree-optimize.c (init_tree_optimization_passes): Move copy prop pass to run just before VRP.\n\n        * tree-optimize.c (init_tree_optimization_passes): Move\n        copy prop pass to run just before VRP.\n        * tree-vrp.c (remove_range_assertions): Remove copies created\n        by ASSERT_EXPR removal.\n\n        * gcc.dg/tree-ssa/vrp16.c: New test.\n\nFrom-SVN: r101277", "tree": {"sha": "e04fe30725945b297720279d7f55cee8f6677e1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e04fe30725945b297720279d7f55cee8f6677e1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/949087624366a022cbe51f395eb41748cb0921fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/949087624366a022cbe51f395eb41748cb0921fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/949087624366a022cbe51f395eb41748cb0921fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/949087624366a022cbe51f395eb41748cb0921fe/comments", "author": null, "committer": null, "parents": [{"sha": "32aa3bffc3be895994b3fa8a35c4c7d66e5fc8c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32aa3bffc3be895994b3fa8a35c4c7d66e5fc8c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32aa3bffc3be895994b3fa8a35c4c7d66e5fc8c6"}], "stats": {"total": 69, "additions": 65, "deletions": 4}, "files": [{"sha": "c34a161f49b36a3fa07ba9c9583ac58992352ee9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/949087624366a022cbe51f395eb41748cb0921fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/949087624366a022cbe51f395eb41748cb0921fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=949087624366a022cbe51f395eb41748cb0921fe", "patch": "@@ -1,3 +1,10 @@\n+2005-06-23  Jeff Law  <law@redhat.com>\n+\n+\t* tree-optimize.c (init_tree_optimization_passes): Move\n+\tcopy prop pass to run just before VRP.\n+\t* tree-vrp.c (remove_range_assertions): Remove copies created\n+\tby ASSERT_EXPR removal.\n+\n 2005-06-23  Kazu Hirata  <kazu@codesourcery.com>\n \n \tPR tree-optimization/22117"}, {"sha": "bece831b8ecfb9911c1b512dc2dbd8d511666aa7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/949087624366a022cbe51f395eb41748cb0921fe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/949087624366a022cbe51f395eb41748cb0921fe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=949087624366a022cbe51f395eb41748cb0921fe", "patch": "@@ -1,3 +1,7 @@\n+2005-06-23  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/vrp16.c: New test.\n+\n 2005-06-23  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* lib/target-supports.exp: Add"}, {"sha": "e8fd4bd230d66d0d22143015f2b1278ffd545b5a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp16.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/949087624366a022cbe51f395eb41748cb0921fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/949087624366a022cbe51f395eb41748cb0921fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp16.c?ref=949087624366a022cbe51f395eb41748cb0921fe", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp-details\" } */\n+\n+\n+extern void abort (void) __attribute__ ((__noreturn__));\n+struct rtx_def;\n+typedef struct rtx_def *rtx;\n+struct rtx_def\n+{\n+  int code;\n+};\n+int\n+nonlocal_mentioned_p (rtx x)\n+{\n+  if (x->code == 6 || x->code == 7)\n+    if (x->code == 7)\n+      if (x->code != 7)\n+\tabort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate .*to 0\" 1 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */\n+"}, {"sha": "adeee3c1496cbb91ab3098821151bd9738690976", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/949087624366a022cbe51f395eb41748cb0921fe/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/949087624366a022cbe51f395eb41748cb0921fe/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=949087624366a022cbe51f395eb41748cb0921fe", "patch": "@@ -407,8 +407,8 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_fre);\n   NEXT_PASS (pass_dce);\n   NEXT_PASS (pass_forwprop);\n-  NEXT_PASS (pass_vrp);\n   NEXT_PASS (pass_copy_prop);\n+  NEXT_PASS (pass_vrp);\n   NEXT_PASS (pass_dce);\n   NEXT_PASS (pass_merge_phi);\n   NEXT_PASS (pass_dominator);"}, {"sha": "5ad94b2ea52e649e7657947a64c332a944b71054", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/949087624366a022cbe51f395eb41748cb0921fe/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/949087624366a022cbe51f395eb41748cb0921fe/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=949087624366a022cbe51f395eb41748cb0921fe", "patch": "@@ -2641,7 +2641,10 @@ insert_range_assertions (void)\n }\n \n \n-/* Convert range assertion expressions into the implied copies.\n+/* Convert range assertion expressions into the implied copies and\n+   copy propagate away the copies.  Doing the trivial copy propagation\n+   here avoids the need to run the full copy propagation pass after\n+   VRP. \n    \n    FIXME, this will eventually lead to copy propagation removing the\n    names that had useful range information attached to them.  For\n@@ -2655,16 +2658,24 @@ insert_range_assertions (void)\n    things like jump threading.\n    \n    The problem with keeping ASSERT_EXPRs around is that passes after\n-   VRP need to handle them appropriately.  */\n+   VRP need to handle them appropriately. \n+\n+   Another approach would be to make the range information a first\n+   class property of the SSA_NAME so that it can be queried from\n+   any pass.  This is made somewhat more complex by the need for\n+   multiple ranges to be associated with one SSA_NAME.  */\n \n static void\n remove_range_assertions (void)\n {\n   basic_block bb;\n   block_stmt_iterator si;\n \n+  /* Note that the BSI iterator bump happens at the bottom of the\n+     loop and no bump is necessary if we're removing the statement\n+     referenced by the current BSI.  */\n   FOR_EACH_BB (bb)\n-    for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+    for (si = bsi_start (bb); !bsi_end_p (si);)\n       {\n \ttree stmt = bsi_stmt (si);\n \n@@ -2673,10 +2684,26 @@ remove_range_assertions (void)\n \t  {\n \t    tree rhs = TREE_OPERAND (stmt, 1);\n \t    tree cond = fold (ASSERT_EXPR_COND (rhs));\n+\t    use_operand_p use_p;\n+\t    imm_use_iterator iter;\n+\n \t    gcc_assert (cond != boolean_false_node);\n \t    TREE_OPERAND (stmt, 1) = ASSERT_EXPR_VAR (rhs);\n \t    update_stmt (stmt);\n+\n+\t    /* The statement is now a copy.  Propagate the RHS into\n+\t       every use of the LHS.  */\n+\t    FOR_EACH_IMM_USE_SAFE (use_p, iter, TREE_OPERAND (stmt, 0))\n+\t      {\n+\t\tSET_USE (use_p, ASSERT_EXPR_VAR (rhs));\n+\t\tupdate_stmt (USE_STMT (use_p));\n+\t      }\n+\n+\t    /* And finally, remove the copy, it is not needed.  */\n+\t    bsi_remove (&si);\n \t  }\n+\telse\n+\t  bsi_next (&si);\n       }\n }\n "}]}