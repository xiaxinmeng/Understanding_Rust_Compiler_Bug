{"sha": "0cd6c85a310f2e2a597a0ee4ef03173806d766f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNkNmM4NWEzMTBmMmUyYTU5N2EwZWU0ZWYwMzE3MzgwNmQ3NjZmNQ==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2005-08-27T02:08:29Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2005-08-27T02:08:29Z"}, "message": "genrecog.c (enum decision_type): Add DT_num_insns.\n\n2005-08-27  Paul Brook  <paul@codesourcery.com>\n\n\t* genrecog.c (enum decision_type): Add DT_num_insns.\n\t(struct decision_test): Add u.num_insns.\n\t(add_to_sequence): Add DT_num_insns test.\n\t(maybe_both_true_2, nodes_identical_1): Handle DT_num_insns.\n\t(write_cond, debug_decision_2): Ditto.\n\t(change_state): Assume peep2_next_insn never fails.\n\tRemove \"afterward\" argument.\n\t(write afterward, write_tree): Update to match.\n\t* recog.c (peep2_current_count): New variable.\n\t(peep2_next_insn): Check it.\n\t(peephole2_optimize): Set peep2_current_count.\n\t* recog.h (peep2_current_count): Declare.\n\nFrom-SVN: r103553", "tree": {"sha": "3a2df6c503cb4c254dadef63be62a4db37318490", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a2df6c503cb4c254dadef63be62a4db37318490"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cd6c85a310f2e2a597a0ee4ef03173806d766f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cd6c85a310f2e2a597a0ee4ef03173806d766f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cd6c85a310f2e2a597a0ee4ef03173806d766f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cd6c85a310f2e2a597a0ee4ef03173806d766f5/comments", "author": null, "committer": null, "parents": [{"sha": "e0af6cb7203510afbdabbe4aee515d616e8a0bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0af6cb7203510afbdabbe4aee515d616e8a0bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0af6cb7203510afbdabbe4aee515d616e8a0bda"}], "stats": {"total": 93, "additions": 66, "deletions": 27}, "files": [{"sha": "911b188df4ba0dbf0b53f986f5cfbb8955364025", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd6c85a310f2e2a597a0ee4ef03173806d766f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd6c85a310f2e2a597a0ee4ef03173806d766f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0cd6c85a310f2e2a597a0ee4ef03173806d766f5", "patch": "@@ -1,3 +1,18 @@\n+2005-08-27  Paul Brook  <paul@codesourcery.com>\n+\n+\t* genrecog.c (enum decision_type): Add DT_num_insns.\n+\t(struct decision_test): Add u.num_insns.\n+\t(add_to_sequence): Add DT_num_insns test.\n+\t(maybe_both_true_2, nodes_identical_1): Handle DT_num_insns.\n+\t(write_cond, debug_decision_2): Ditto.\n+\t(change_state): Assume peep2_next_insn never fails.\n+\tRemove \"afterward\" argument.\n+\t(write afterward, write_tree): Update to match.\n+\t* recog.c (peep2_current_count): New variable.\n+\t(peep2_next_insn): Check it.\n+\t(peephole2_optimize): Set peep2_current_count.\n+\t* recog.h (peep2_current_count): Declare.\n+\n 2005-08-26  Josh Conner  <jconner@apple.com>\n \n \tPR middle-end/23584"}, {"sha": "82248482de0654a60be036ce223c5e76b2c1d3bf", "filename": "gcc/genrecog.c", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd6c85a310f2e2a597a0ee4ef03173806d766f5/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd6c85a310f2e2a597a0ee4ef03173806d766f5/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=0cd6c85a310f2e2a597a0ee4ef03173806d766f5", "patch": "@@ -87,6 +87,7 @@ struct decision_test\n   /* These types are roughly in the order in which we'd like to test them.  */\n   enum decision_type\n     {\n+      DT_num_insns,\n       DT_mode, DT_code, DT_veclen,\n       DT_elt_zero_int, DT_elt_one_int, DT_elt_zero_wide, DT_elt_zero_wide_safe,\n       DT_const_int,\n@@ -96,6 +97,7 @@ struct decision_test\n \n   union\n   {\n+    int num_insns;\t\t/* Number if insn in a define_peephole2.  */\n     enum machine_mode mode;\t/* Machine mode of node.  */\n     RTX_CODE code;\t\t/* Code to test.  */\n \n@@ -439,7 +441,7 @@ static void find_afterward\n   (struct decision_head *, struct decision *);\n \n static void change_state\n-  (const char *, const char *, struct decision *, const char *);\n+  (const char *, const char *, const char *);\n static void print_code\n   (enum rtx_code);\n static void write_afterward\n@@ -923,8 +925,22 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n       /* Toplevel peephole pattern.  */\n       if (insn_type == PEEPHOLE2 && top)\n \t{\n-\t  /* We don't need the node we just created -- unlink it.  */\n-\t  last->first = last->last = NULL;\n+\t  int num_insns;\n+\n+\t  /* Check we have sufficient insns.  This avoids complications\n+\t     because we then know peep2_next_insn never fails.  */\n+\t  num_insns = XVECLEN (pattern, 0);\n+\t  if (num_insns > 1)\n+\t    {\n+\t      test = new_decision_test (DT_num_insns, &place);\n+\t      test->u.num_insns = num_insns;\n+\t      last = &sub->success;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We don't need the node we just created -- unlink it.  */\n+\t      last->first = last->last = NULL;\n+\t    }\n \n \t  for (i = 0; i < (size_t) XVECLEN (pattern, 0); i++)\n \t    {\n@@ -1174,6 +1190,12 @@ maybe_both_true_2 (struct decision_test *d1, struct decision_test *d2)\n     {\n       switch (d1->type)\n \t{\n+\tcase DT_num_insns:\n+\t  if (d1->u.num_insns == d2->u.num_insns)\n+\t    return 1;\n+\t  else\n+\t    return -1;\n+\n \tcase DT_mode:\n \t  return d1->u.mode == d2->u.mode;\n \n@@ -1372,6 +1394,9 @@ nodes_identical_1 (struct decision_test *d1, struct decision_test *d2)\n {\n   switch (d1->type)\n     {\n+    case DT_num_insns:\n+      return d1->u.num_insns == d2->u.num_insns;\n+\n     case DT_mode:\n       return d1->u.mode == d2->u.mode;\n \n@@ -1767,8 +1792,7 @@ find_afterward (struct decision_head *head, struct decision *real_afterward)\n    match multiple insns and we try to step past the end of the stream.  */\n \n static void\n-change_state (const char *oldpos, const char *newpos,\n-\t      struct decision *afterward, const char *indent)\n+change_state (const char *oldpos, const char *newpos, const char *indent)\n {\n   int odepth = strlen (oldpos);\n   int ndepth = strlen (newpos);\n@@ -1793,22 +1817,8 @@ change_state (const char *oldpos, const char *newpos,\n       /* It's a different insn from the first one.  */\n       if (ISUPPER (newpos[depth]))\n \t{\n-\t  /* We can only fail if we're moving down the tree.  */\n-\t  if (old_has_insn >= 0 && oldpos[old_has_insn] >= newpos[depth])\n-\t    {\n-\t      printf (\"%stem = peep2_next_insn (%d);\\n\",\n-\t\t      indent, newpos[depth] - 'A');\n-\t    }\n-\t  else\n-\t    {\n-\t      printf (\"%stem = peep2_next_insn (%d);\\n\",\n-\t\t      indent, newpos[depth] - 'A');\n-\t      printf (\"%sif (tem == NULL_RTX)\\n\", indent);\n-\t      if (afterward)\n-\t\tprintf (\"%s  goto L%d;\\n\", indent, afterward->number);\n-\t      else\n-\t\tprintf (\"%s  goto ret0;\\n\", indent);\n-\t    }\n+\t  printf (\"%stem = peep2_next_insn (%d);\\n\",\n+\t\t  indent, newpos[depth] - 'A');\n \t  printf (\"%sx%d = PATTERN (tem);\\n\", indent, depth + 1);\n \t}\n       else if (ISLOWER (newpos[depth]))\n@@ -1842,7 +1852,7 @@ write_afterward (struct decision *start, struct decision *afterward,\n     printf(\"%sgoto ret0;\\n\", indent);\n   else\n     {\n-      change_state (start->position, afterward->position, NULL, indent);\n+      change_state (start->position, afterward->position, indent);\n       printf (\"%sgoto L%d;\\n\", indent, afterward->number);\n     }\n }\n@@ -2067,6 +2077,10 @@ write_cond (struct decision_test *p, int depth,\n {\n   switch (p->type)\n     {\n+    case DT_num_insns:\n+      printf (\"peep2_current_count >= %d\", p->u.num_insns);\n+      break;\n+\n     case DT_mode:\n       printf (\"GET_MODE (x%d) == %smode\", depth, GET_MODE_NAME (p->u.mode));\n       break;\n@@ -2363,7 +2377,7 @@ write_tree (struct decision_head *head, const char *prevpos,\n \t  else\n \t    printf (\"  if (tem >= 0)\\n    return tem;\\n\");\n \n-\t  change_state (p->position, p->afterward->position, NULL, \"  \");\n+\t  change_state (p->position, p->afterward->position, \"  \");\n \t  printf (\"  goto L%d;\\n\", p->afterward->number);\n \t}\n       else\n@@ -2376,7 +2390,7 @@ write_tree (struct decision_head *head, const char *prevpos,\n     {\n       int depth = strlen (p->position);\n \n-      change_state (prevpos, p->position, head->last->afterward, \"  \");\n+      change_state (prevpos, p->position, \"  \");\n       write_tree_1 (head, depth, type);\n \n       for (p = head->first; p; p = p->next)\n@@ -2830,6 +2844,9 @@ debug_decision_2 (struct decision_test *test)\n {\n   switch (test->type)\n     {\n+    case DT_num_insns:\n+      fprintf (stderr, \"num_insns=%d\", test->u.num_insns);\n+      break;\n     case DT_mode:\n       fprintf (stderr, \"mode=%s\", GET_MODE_NAME (test->u.mode));\n       break;"}, {"sha": "1b8394c47b43fb67c175119b5df20ce3600292f7", "filename": "gcc/recog.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd6c85a310f2e2a597a0ee4ef03173806d766f5/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd6c85a310f2e2a597a0ee4ef03173806d766f5/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0cd6c85a310f2e2a597a0ee4ef03173806d766f5", "patch": "@@ -2853,6 +2853,8 @@ struct peep2_insn_data\n \n static struct peep2_insn_data peep2_insn_data[MAX_INSNS_PER_PEEP2 + 1];\n static int peep2_current;\n+/* The number of instructions available to match a peep2.  */\n+int peep2_current_count;\n \n /* A non-insn marker indicating the last insn of the block.\n    The live_before regset for this element is correct, indicating\n@@ -2866,14 +2868,12 @@ static int peep2_current;\n rtx\n peep2_next_insn (int n)\n {\n-  gcc_assert (n < MAX_INSNS_PER_PEEP2 + 1);\n+  gcc_assert (n <= peep2_current_count);\n \n   n += peep2_current;\n   if (n >= MAX_INSNS_PER_PEEP2 + 1)\n     n -= MAX_INSNS_PER_PEEP2 + 1;\n \n-  if (peep2_insn_data[n].insn == PEEP2_EOB)\n-    return NULL_RTX;\n   return peep2_insn_data[n].insn;\n }\n \n@@ -3062,6 +3062,7 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n       /* Indicate that all slots except the last holds invalid data.  */\n       for (i = 0; i < MAX_INSNS_PER_PEEP2; ++i)\n \tpeep2_insn_data[i].insn = NULL_RTX;\n+      peep2_current_count = 0;\n \n       /* Indicate that the last slot contains live_after data.  */\n       peep2_insn_data[MAX_INSNS_PER_PEEP2].insn = PEEP2_EOB;\n@@ -3090,6 +3091,8 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \t      /* Record this insn.  */\n \t      if (--peep2_current < 0)\n \t\tpeep2_current = MAX_INSNS_PER_PEEP2;\n+\t      if (peep2_current_count < MAX_INSNS_PER_PEEP2)\n+\t\tpeep2_current_count++;\n \t      peep2_insn_data[peep2_current].insn = insn;\n \t      propagate_one_insn (pbi, insn);\n \t      COPY_REG_SET (peep2_insn_data[peep2_current].live_before, live);\n@@ -3234,6 +3237,7 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \t\t  for (i = 0; i < MAX_INSNS_PER_PEEP2 + 1; ++i)\n \t\t    peep2_insn_data[i].insn = NULL_RTX;\n \t\t  peep2_insn_data[peep2_current].insn = PEEP2_EOB;\n+\t\t  peep2_current_count = 0;\n #else\n \t\t  /* Back up lifetime information past the end of the\n \t\t     newly created sequence.  */\n@@ -3249,6 +3253,8 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \t\t\t{\n \t\t\t  if (--i < 0)\n \t\t\t    i = MAX_INSNS_PER_PEEP2;\n+\t\t\t  if (peep2_current_count < MAX_INSNS_PER_PEEP2)\n+\t\t\t    peep2_current_count++;\n \t\t\t  peep2_insn_data[i].insn = x;\n \t\t\t  propagate_one_insn (pbi, x);\n \t\t\t  COPY_REG_SET (peep2_insn_data[i].live_before, live);"}, {"sha": "0ed7c9e4741dea9b961039cceb25c5675749dc5c", "filename": "gcc/recog.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cd6c85a310f2e2a597a0ee4ef03173806d766f5/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cd6c85a310f2e2a597a0ee4ef03173806d766f5/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=0cd6c85a310f2e2a597a0ee4ef03173806d766f5", "patch": "@@ -265,3 +265,4 @@ struct insn_data\n };\n \n extern const struct insn_data insn_data[];\n+extern int peep2_current_count;"}]}