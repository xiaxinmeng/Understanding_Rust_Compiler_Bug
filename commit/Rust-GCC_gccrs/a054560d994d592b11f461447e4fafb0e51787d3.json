{"sha": "a054560d994d592b11f461447e4fafb0e51787d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA1NDU2MGQ5OTRkNTkyYjExZjQ2MTQ0N2U0ZmFmYjBlNTE3ODdkMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-11-13T14:43:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-11-13T14:43:38Z"}, "message": "PR68264: Use unordered comparisons for tree-call-cdce.c\n\nAs reported in PR 68264, tree-call-cdce.c should be using unordered\ncomparisons for the range checks, in order to avoid raising FE_INVALID\nfor quiet NaNs.\n\nTested on x86_64-linux-gnu and aarch64-linux-gnu.  The test failed on\naarch64-linux-gnu before the patch, but it didn't on x86_64-linux-gnu\nbecause it used unordered comparisons for the previous ordered tree codes.\n\ngcc/\n\tPR tree-optimization/68264\n\t* tree-call-cdce.c (gen_one_condition): Update commentary.\n\t(gen_conditions_for_pow_int_base): Invert the sense of the tests\n\tpassed to gen_one_condition.\n\t(gen_conditions_for_domain): Likewise.  Use unordered comparisons.\n\t(shrink_wrap_one_built_in_call): Invert the sense of the tests,\n\tusing EDGE_FALSE_VALUE for edges to the call block and\n\tEDGE_TRUE_VALUE for the others.\n\ngcc/testsuite/\n\tPR tree-optimization/68264\n\t* gcc.dg/torture/pr68264.c: New test.\n\nFrom-SVN: r230323", "tree": {"sha": "2f6517c44a62abaf9ed1d762d3e5050d360fda33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f6517c44a62abaf9ed1d762d3e5050d360fda33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a054560d994d592b11f461447e4fafb0e51787d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a054560d994d592b11f461447e4fafb0e51787d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a054560d994d592b11f461447e4fafb0e51787d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a054560d994d592b11f461447e4fafb0e51787d3/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec8b536ffd7056c0f82c309da713352e6e4deed5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8b536ffd7056c0f82c309da713352e6e4deed5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec8b536ffd7056c0f82c309da713352e6e4deed5"}], "stats": {"total": 163, "additions": 141, "deletions": 22}, "files": [{"sha": "3c2d9364bca5e2b4541d076727af509e00bb8bdc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a054560d994d592b11f461447e4fafb0e51787d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a054560d994d592b11f461447e4fafb0e51787d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a054560d994d592b11f461447e4fafb0e51787d3", "patch": "@@ -1,3 +1,14 @@\n+2015-11-13  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/68264\n+\t* tree-call-cdce.c (gen_one_condition): Update commentary.\n+\t(gen_conditions_for_pow_int_base): Invert the sense of the tests\n+\tpassed to gen_one_condition.\n+\t(gen_conditions_for_domain): Likewise.  Use unordered comparisons.\n+\t(shrink_wrap_one_built_in_call): Invert the sense of the tests,\n+\tusing EDGE_FALSE_VALUE for edges to the call block and\n+\tEDGE_TRUE_VALUE for the others.\n+\n 2015-11-13  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* gimplify.c (oacc_default_clause): Use inform for enclosing scope."}, {"sha": "a29b65181a860f5fc2c7ace4c8a44247b777b0af", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a054560d994d592b11f461447e4fafb0e51787d3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a054560d994d592b11f461447e4fafb0e51787d3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a054560d994d592b11f461447e4fafb0e51787d3", "patch": "@@ -1,3 +1,8 @@\n+2015-11-13  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/68264\n+\t* gcc.dg/torture/pr68264.c: New test.\n+\n 2015-11-13  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/68320"}, {"sha": "9630474252564a4f562995a3ec34f08f8096b1ad", "filename": "gcc/testsuite/gcc.dg/torture/pr68264.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a054560d994d592b11f461447e4fafb0e51787d3/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68264.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a054560d994d592b11f461447e4fafb0e51787d3/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68264.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr68264.c?ref=a054560d994d592b11f461447e4fafb0e51787d3", "patch": "@@ -0,0 +1,104 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target fenv_exceptions } */\n+\n+#include <fenv.h>\n+#include <math.h>\n+#include <errno.h>\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define LARGE_NEG_MAYBE_ERANGE 0x01\n+#define LARGE_NEG_ERANGE       0x02\n+#define LARGE_POS_ERANGE       0x04\n+#define LARGE_NEG_EDOM         0x08\n+#define LARGE_POS_EDOM         0x10\n+\n+#define LARGE_ERANGE (LARGE_NEG_ERANGE | LARGE_POS_ERANGE)\n+#define LARGE_EDOM (LARGE_NEG_EDOM | LARGE_POS_EDOM)\n+#define POWER_ERANGE (LARGE_NEG_MAYBE_ERANGE | LARGE_POS_ERANGE)\n+\n+#define TEST(CALL, FLAGS) (CALL, tester (FLAGS))\n+\n+volatile double d;\n+volatile int i;\n+\n+static void (*tester) (int);\n+\n+void\n+check_quiet_nan (int flags __attribute__ ((unused)))\n+{\n+  if (fetestexcept (FE_ALL_EXCEPT))\n+    abort ();\n+  if (errno)\n+    abort ();\n+}\n+\n+void\n+check_large_neg (int flags)\n+{\n+  if (flags & LARGE_NEG_MAYBE_ERANGE)\n+    return;\n+  int expected_errno = (flags & LARGE_NEG_ERANGE ? ERANGE\n+\t\t\t: flags & LARGE_NEG_EDOM ? EDOM\n+\t\t\t: 0);\n+  if (expected_errno != errno)\n+    abort ();\n+  errno = 0;\n+}\n+\n+void\n+check_large_pos (int flags)\n+{\n+  int expected_errno = (flags & LARGE_POS_ERANGE ? ERANGE\n+\t\t\t: flags & LARGE_POS_EDOM ? EDOM\n+\t\t\t: 0);\n+  if (expected_errno != errno)\n+    abort ();\n+  errno = 0;\n+}\n+\n+void\n+test (void)\n+{\n+  TEST (acos (d), LARGE_EDOM);\n+  TEST (asin (d), LARGE_EDOM);\n+  TEST (acosh (d), LARGE_NEG_EDOM);\n+  TEST (atanh (d), LARGE_EDOM);\n+  TEST (cosh (d), LARGE_ERANGE);\n+  TEST (sinh (d), LARGE_ERANGE);\n+  TEST (log (d), LARGE_NEG_EDOM);\n+  TEST (log2 (d), LARGE_NEG_EDOM);\n+  TEST (log10 (d), LARGE_NEG_EDOM);\n+  /* Disabled due to glibc PR 6792, fixed in Apr 2015.  */\n+  if (0)\n+    TEST (log1p (d), LARGE_NEG_EDOM);\n+  TEST (exp (d), POWER_ERANGE);\n+  TEST (exp2 (d), POWER_ERANGE);\n+  TEST (expm1 (d), POWER_ERANGE);\n+  TEST (sqrt (d), LARGE_NEG_EDOM);\n+  TEST (pow (100.0, d), POWER_ERANGE);\n+  TEST (pow (i, d), POWER_ERANGE);\n+}\n+\n+int\n+main (void)\n+{\n+  errno = 0;\n+  i = 100;\n+  d = __builtin_nan (\"\");\n+  tester = check_quiet_nan;\n+  feclearexcept (FE_ALL_EXCEPT);\n+  test ();\n+\n+  d = -1.0e80;\n+  tester = check_large_neg;\n+  errno = 0;\n+  test ();\n+\n+  d = 1.0e80;\n+  tester = check_large_pos;\n+  errno = 0;\n+  test ();\n+\n+  return 0;\n+}"}, {"sha": "fbcc70baed536aabcaaedbe166ed96b0f516bc67", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a054560d994d592b11f461447e4fafb0e51787d3/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a054560d994d592b11f461447e4fafb0e51787d3/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=a054560d994d592b11f461447e4fafb0e51787d3", "patch": "@@ -51,10 +51,11 @@ along with GCC; see the file COPYING3.  If not see\n              built_in_call (args)\n \n     An actual simple example is :\n-         log (x);   // Mostly dead call\n+\t log (x);   // Mostly dead call\n      ==>\n-         if (x <= 0)\n-             log (x);\n+\t if (__builtin_islessequal (x, 0))\n+\t     log (x);\n+\n      With this change, call to log (x) is effectively eliminated, as\n      in majority of the cases, log won't be called with x out of\n      range.  The branch is totally predictable, so the branch cost\n@@ -306,15 +307,13 @@ is_call_dce_candidate (gcall *call)\n }\n \n \f\n-/* A helper function to generate gimple statements for\n-   one bound comparison.  ARG is the call argument to\n-   be compared with the bound, LBUB is the bound value\n-   in integer, TCODE is the tree_code of the comparison,\n-   TEMP_NAME1/TEMP_NAME2 are names of the temporaries,\n-   CONDS is a vector holding the produced GIMPLE statements,\n-   and NCONDS points to the variable holding the number\n-   of logical comparisons.  CONDS is either empty or\n-   a list ended with a null tree.  */\n+/* A helper function to generate gimple statements for one bound\n+   comparison, so that the built-in function is called whenever\n+   TCODE <ARG, LBUB> is *false*.  TEMP_NAME1/TEMP_NAME2 are names\n+   of the temporaries, CONDS is a vector holding the produced GIMPLE\n+   statements, and NCONDS points to the variable holding the number of\n+   logical comparisons.  CONDS is either empty or a list ended with a\n+   null tree.  */\n \n static void\n gen_one_condition (tree arg, int lbub,\n@@ -371,7 +370,7 @@ gen_conditions_for_domain (tree arg, inp_domain domain,\n   if (domain.has_lb)\n     gen_one_condition (arg, domain.lb,\n                        (domain.is_lb_inclusive\n-                        ? LT_EXPR : LE_EXPR),\n+                        ? UNGE_EXPR : UNGT_EXPR),\n                        \"DCE_COND_LB\", \"DCE_COND_LB_TEST\",\n                        conds, nconds);\n \n@@ -383,7 +382,7 @@ gen_conditions_for_domain (tree arg, inp_domain domain,\n \n       gen_one_condition (arg, domain.ub,\n                          (domain.is_ub_inclusive\n-                          ? GT_EXPR : GE_EXPR),\n+                          ? UNLE_EXPR : UNLT_EXPR),\n                          \"DCE_COND_UB\", \"DCE_COND_UB_TEST\",\n                          conds, nconds);\n     }\n@@ -395,7 +394,7 @@ gen_conditions_for_domain (tree arg, inp_domain domain,\n    See candidate selection in check_pow.  Since the\n    candidates' base values have a limited range,\n    the guarded code generated for y are simple:\n-   if (y > max_y)\n+   if (__builtin_isgreater (y, max_y))\n      pow (const, y);\n    Note max_y can be computed separately for each\n    const base, but in this implementation, we\n@@ -480,11 +479,11 @@ gen_conditions_for_pow_int_base (tree base, tree expn,\n   /* For pow ((double)x, y), generate the following conditions:\n      cond 1:\n      temp1 = x;\n-     if (temp1 <= 0)\n+     if (__builtin_islessequal (temp1, 0))\n \n      cond 2:\n      temp2 = y;\n-     if (temp2 > max_exp_real_cst)  */\n+     if (__builtin_isgreater (temp2, max_exp_real_cst))  */\n \n   /* Generate condition in reverse order -- first\n      the condition for the exp argument.  */\n@@ -508,7 +507,7 @@ gen_conditions_for_pow_int_base (tree base, tree expn,\n   stmt1 = gimple_build_assign (temp, base_val0);\n   tempn = make_ssa_name (temp, stmt1);\n   gimple_assign_set_lhs (stmt1, tempn);\n-  stmt2 = gimple_build_cond (LE_EXPR, tempn, cst0, NULL_TREE, NULL_TREE);\n+  stmt2 = gimple_build_cond (GT_EXPR, tempn, cst0, NULL_TREE, NULL_TREE);\n \n   conds.quick_push (stmt1);\n   conds.quick_push (stmt2);\n@@ -797,11 +796,11 @@ shrink_wrap_one_built_in_call (gcall *bi_call)\n \n   bi_call_in_edge0 = split_block (bi_call_bb, cond_expr);\n   bi_call_in_edge0->flags &= ~EDGE_FALLTHRU;\n-  bi_call_in_edge0->flags |= EDGE_TRUE_VALUE;\n+  bi_call_in_edge0->flags |= EDGE_FALSE_VALUE;\n   guard_bb = bi_call_bb;\n   bi_call_bb = bi_call_in_edge0->dest;\n   join_tgt_in_edge_fall_thru = make_edge (guard_bb, join_tgt_bb,\n-                                          EDGE_FALSE_VALUE);\n+                                          EDGE_TRUE_VALUE);\n \n   bi_call_in_edge0->probability = REG_BR_PROB_BASE * ERR_PROB;\n   bi_call_in_edge0->count =\n@@ -834,9 +833,9 @@ shrink_wrap_one_built_in_call (gcall *bi_call)\n       gcc_assert (cond_expr && gimple_code (cond_expr) == GIMPLE_COND);\n       guard_bb_in_edge = split_block (guard_bb, cond_expr);\n       guard_bb_in_edge->flags &= ~EDGE_FALLTHRU;\n-      guard_bb_in_edge->flags |= EDGE_FALSE_VALUE;\n+      guard_bb_in_edge->flags |= EDGE_TRUE_VALUE;\n \n-      bi_call_in_edge = make_edge (guard_bb, bi_call_bb, EDGE_TRUE_VALUE);\n+      bi_call_in_edge = make_edge (guard_bb, bi_call_bb, EDGE_FALSE_VALUE);\n \n       bi_call_in_edge->probability = REG_BR_PROB_BASE * ERR_PROB;\n       bi_call_in_edge->count ="}]}