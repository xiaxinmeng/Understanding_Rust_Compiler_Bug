{"sha": "00f45f309076825e5bae672ffc2229fbe6ef8d88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBmNDVmMzA5MDc2ODI1ZTViYWU2NzJmZmMyMjI5ZmJlNmVmOGQ4OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-13T10:42:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-13T10:42:37Z"}, "message": "[multiple changes]\n\n2017-01-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.ads, sem_util.adb (Choice_List): Move function here\n\tfrom sem_aggr.adb, for use elsewhere.\n\t* sem_ch3.adb (Analyze_Object_Declaration): Use Choice_List.\n\t* sem_aggr.adb (Resolve_Array_Aggregate): Remove\n\tIterated_Component_Present.\n\t* exp_aggr.adb: Use Choice_List throughout, to handle\n\tIterated_Component_Associations.\n\t(Gen_Loop): Generate proper loop for an\n\tIterated_Component_Association: loop variable has the identifier\n\tof the original association. Generate a loop even for a single\n\tcomponent choice, in order to make loop parameter visible in\n\texpression.\n\t(Flatten): An Iterated_Component_Association is not static.\n\n2017-01-13  Yannick Moy  <moy@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Op_Expon): Ensure that the value of\n\tfloat exponentiation for statically known small negative values\n\tis the reciprocal of the exponentiation for the opposite value\n\tof the exponent.\n\t* s-exnllf.adb (Exn_Float, Exn_Long_Float, Exn_Long_Long_Float):\n\tEnsure that the value of float exponentiation for negative values\n\tis the reciprocal of the exponentiation for the opposite value\n\tof the exponent.\n\t* inline.adb (Expand_Inlined_Call): Fix the count\n\tfor the number of generated gotos.\n\nFrom-SVN: r244414", "tree": {"sha": "ff983b37d2975254808502a007da8cc9fd9fb3e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff983b37d2975254808502a007da8cc9fd9fb3e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00f45f309076825e5bae672ffc2229fbe6ef8d88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f45f309076825e5bae672ffc2229fbe6ef8d88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00f45f309076825e5bae672ffc2229fbe6ef8d88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f45f309076825e5bae672ffc2229fbe6ef8d88/comments", "author": null, "committer": null, "parents": [{"sha": "eaed322611b9c09a746f84e6280cdd400aaf9d60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaed322611b9c09a746f84e6280cdd400aaf9d60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaed322611b9c09a746f84e6280cdd400aaf9d60"}], "stats": {"total": 261, "additions": 163, "deletions": 98}, "files": [{"sha": "ecd4459455d0f1666803bd9ac80d08bda8a3245d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=00f45f309076825e5bae672ffc2229fbe6ef8d88", "patch": "@@ -1,3 +1,32 @@\n+2017-01-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.ads, sem_util.adb (Choice_List): Move function here\n+\tfrom sem_aggr.adb, for use elsewhere.\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Use Choice_List.\n+\t* sem_aggr.adb (Resolve_Array_Aggregate): Remove\n+\tIterated_Component_Present.\n+\t* exp_aggr.adb: Use Choice_List throughout, to handle\n+\tIterated_Component_Associations.\n+\t(Gen_Loop): Generate proper loop for an\n+\tIterated_Component_Association: loop variable has the identifier\n+\tof the original association. Generate a loop even for a single\n+\tcomponent choice, in order to make loop parameter visible in\n+\texpression.\n+\t(Flatten): An Iterated_Component_Association is not static.\n+\n+2017-01-13  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Op_Expon): Ensure that the value of\n+\tfloat exponentiation for statically known small negative values\n+\tis the reciprocal of the exponentiation for the opposite value\n+\tof the exponent.\n+\t* s-exnllf.adb (Exn_Float, Exn_Long_Float, Exn_Long_Long_Float):\n+\tEnsure that the value of float exponentiation for negative values\n+\tis the reciprocal of the exponentiation for the opposite value\n+\tof the exponent.\n+\t* inline.adb (Expand_Inlined_Call): Fix the count\n+\tfor the number of generated gotos.\n+\n 2017-01-13  Yannick Moy  <moy@adacore.com>\n \n \t* inline.adb: Code cleanup."}, {"sha": "889c359dc4696587e70c866edc4d96aad70cc62d", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=00f45f309076825e5bae672ffc2229fbe6ef8d88", "patch": "@@ -492,7 +492,8 @@ package body Exp_Aggr is\n                then\n                   if Present (Component_Associations (N)) then\n                      Indx :=\n-                       First (Choices (First (Component_Associations (N))));\n+                       First\n+                         (Choice_List (First (Component_Associations (N))));\n \n                      if Is_Entity_Name (Indx)\n                        and then not Is_Type (Entity (Indx))\n@@ -853,6 +854,9 @@ package body Exp_Aggr is\n       --  Otherwise we call Build_Code recursively. As an optimization if the\n       --  loop covers 3 or fewer scalar elements we generate a sequence of\n       --  assignments.\n+      --  If the component association that generates the loop comes from an\n+      --  Iterated_Component_Association, the loop parameter has the name of\n+      --  the corresponding parameter in the original construct.\n \n       function Gen_While (L, H : Node_Id; Expr : Node_Id) return List_Id;\n       --  Nodes L and H must be side-effect-free expressions. If the input\n@@ -1644,6 +1648,9 @@ package body Exp_Aggr is\n       --------------\n \n       function Gen_Loop (L, H : Node_Id; Expr : Node_Id) return List_Id is\n+         Is_Iterated_Component : constant Boolean :=\n+           Nkind (Parent (Expr)) = N_Iterated_Component_Association;\n+\n          L_J : Node_Id;\n \n          L_L : Node_Id;\n@@ -1700,9 +1707,10 @@ package body Exp_Aggr is\n \n             return S;\n \n-         --  If loop bounds are the same then generate an assignment\n+         --  If loop bounds are the same then generate an assignment, unless\n+         --  the parent construct is an Iterated_Component_Association.\n \n-         elsif Equal (L, H) then\n+         elsif Equal (L, H) and then not Is_Iterated_Component then\n             return Gen_Assign (New_Copy_Tree (L), Expr);\n \n          --  If H - L <= 2 then generate a sequence of assignments when we are\n@@ -1714,6 +1722,7 @@ package body Exp_Aggr is\n            and then Local_Compile_Time_Known_Value (L)\n            and then Local_Compile_Time_Known_Value (H)\n            and then Local_Expr_Value (H) - Local_Expr_Value (L) <= 2\n+           and then not Is_Iterated_Component\n          then\n             Append_List_To (S, Gen_Assign (New_Copy_Tree (L), Expr));\n             Append_List_To (S, Gen_Assign (Add (1, To => L), Expr));\n@@ -1727,7 +1736,13 @@ package body Exp_Aggr is\n \n          --  Otherwise construct the loop, starting with the loop index L_J\n \n-         L_J := Make_Temporary (Loc, 'J', L);\n+         if Is_Iterated_Component then\n+            L_J := Make_Defining_Identifier (Loc,\n+                    Chars => (Chars (Defining_Identifier (Parent (Expr)))));\n+\n+         else\n+            L_J := Make_Temporary (Loc, 'J', L);\n+         end if;\n \n          --  Construct \"L .. H\" in Index_Base. We use a qualified expression\n          --  for the bound to convert to the index base, but we don't need\n@@ -1739,7 +1754,7 @@ package body Exp_Aggr is\n             L_L :=\n               Make_Qualified_Expression (Loc,\n                 Subtype_Mark => Index_Base_Name,\n-                Expression   => L);\n+                Expression   => New_Copy_Tree (L));\n          end if;\n \n          if Etype (H) = Index_Base then\n@@ -1748,7 +1763,7 @@ package body Exp_Aggr is\n             L_H :=\n               Make_Qualified_Expression (Loc,\n                 Subtype_Mark => Index_Base_Name,\n-                Expression   => H);\n+                Expression   => New_Copy_Tree (H));\n          end if;\n \n          L_Range :=\n@@ -2027,7 +2042,7 @@ package body Exp_Aggr is\n \n          Assoc := First (Component_Associations (N));\n          while Present (Assoc) loop\n-            Choice := First (Choices (Assoc));\n+            Choice := First (Choice_List (Assoc));\n             while Present (Choice) loop\n                if Nkind (Choice) = N_Others_Choice then\n                   Set_Loop_Actions (Assoc, New_List);\n@@ -4255,6 +4270,8 @@ package body Exp_Aggr is\n       --  Check whether all components of the aggregate are compile-time known\n       --  values, and can be passed as is to the back-end without further\n       --  expansion.\n+      --  An Iterated_component_Association is treated as non-static, but there\n+      --  are posibilities for optimization here.\n \n       function Flatten\n         (N   : Node_Id;\n@@ -4318,6 +4335,7 @@ package body Exp_Aggr is\n                elsif Nkind (Expression (Expr)) /= N_Aggregate\n                  or else not Compile_Time_Known_Aggregate (Expression (Expr))\n                  or else Expansion_Delayed (Expression (Expr))\n+                 or else Nkind (Expr) = N_Iterated_Component_Association\n                then\n                   Static_Components := False;\n                   exit;\n@@ -4377,9 +4395,12 @@ package body Exp_Aggr is\n \n                   if Box_Present (Assoc) then\n                      return False;\n+\n+                  elsif Nkind (Assoc) = N_Iterated_Component_Association then\n+                     return False;\n                   end if;\n \n-                  Choice := First (Choices (Assoc));\n+                  Choice := First (Choice_List (Assoc));\n \n                   while Present (Choice) loop\n                      if Nkind (Choice) = N_Others_Choice then\n@@ -4460,7 +4481,7 @@ package body Exp_Aggr is\n             end if;\n \n             Component_Loop : while Present (Elmt) loop\n-               Choice := First (Choices (Elmt));\n+               Choice := First (Choice_List (Elmt));\n                Choice_Loop : while Present (Choice) loop\n \n                   --  If we have an others choice, fill in the missing elements\n@@ -5228,7 +5249,7 @@ package body Exp_Aggr is\n          if Present (Component_Associations (Sub_Aggr)) then\n             Assoc := Last (Component_Associations (Sub_Aggr));\n \n-            if Nkind (First (Choices (Assoc))) = N_Others_Choice then\n+            if Nkind (First (Choice_List (Assoc))) = N_Others_Choice then\n                Others_Present (Dim) := True;\n             end if;\n          end if;\n@@ -5513,7 +5534,7 @@ package body Exp_Aggr is\n          elsif Present (Component_Associations (Sub_Aggr)) then\n             Assoc := Last (Component_Associations (Sub_Aggr));\n \n-            if Nkind (First (Choices (Assoc))) /= N_Others_Choice then\n+            if Nkind (First (Choice_List (Assoc))) /= N_Others_Choice then\n                Need_To_Check := False;\n \n             else\n@@ -5525,7 +5546,7 @@ package body Exp_Aggr is\n                Nb_Choices := -1;\n                Assoc := First (Component_Associations (Sub_Aggr));\n                while Present (Assoc) loop\n-                  Choice := First (Choices (Assoc));\n+                  Choice := First (Choice_List (Assoc));\n                   while Present (Choice) loop\n                      Nb_Choices := Nb_Choices + 1;\n                      Next (Choice);\n@@ -5570,7 +5591,7 @@ package body Exp_Aggr is\n             begin\n                Assoc := First (Component_Associations (Sub_Aggr));\n                while Present (Assoc) loop\n-                  Choice := First (Choices (Assoc));\n+                  Choice := First (Choice_List (Assoc));\n                   while Present (Choice) loop\n                      if Nkind (Choice) = N_Others_Choice then\n                         exit;\n@@ -6348,7 +6369,7 @@ package body Exp_Aggr is\n                MX : constant         := 80;\n \n             begin\n-               if Nkind (First (Choices (CA))) = N_Others_Choice\n+               if Nkind (First (Choice_List (CA))) = N_Others_Choice\n                  and then Nkind (Expression (CA)) = N_Character_Literal\n                  and then No (Expressions (N))\n                then\n@@ -7348,7 +7369,7 @@ package body Exp_Aggr is\n \n       Assoc := First (Component_Associations (N));\n       while Present (Assoc) loop\n-         Choice := First (Choices (Assoc));\n+         Choice := First (Choice_List (Assoc));\n          while Present (Choice) loop\n             if Nkind (Choice) /= N_Others_Choice then\n                Nb_Choices := Nb_Choices + 1;\n@@ -8091,7 +8112,7 @@ package body Exp_Aggr is\n             elsif Present (Next (Expr)) then\n                return False;\n \n-            elsif Present (Next (First (Choices (Expr)))) then\n+            elsif Present (Next (First (Choice_List (Expr)))) then\n                return False;\n \n             else"}, {"sha": "bdd720953094341886515d2b7f0f86a6de17b881", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=00f45f309076825e5bae672ffc2229fbe6ef8d88", "patch": "@@ -7691,7 +7691,11 @@ package body Exp_Ch4 is\n          --  the case of 0.0 ** (negative) even if Machine_Overflows = False.\n          --  See ACVC test C4A012B, and it is not worth generating the test.\n \n-         if Expv >= 0 and then Expv <= 4 then\n+         --  For small negative exponents, we return the reciprocal of\n+         --  the folding of the exponentiation for the opposite (positive)\n+         --  exponent, as required by Ada RM 4.5.6(11/3).\n+\n+         if abs Expv <= 4 then\n \n             --  X ** 0 = 1 (or 1.0)\n \n@@ -7742,8 +7746,7 @@ package body Exp_Ch4 is\n             --  in\n             --    En * En\n \n-            else\n-               pragma Assert (Expv = 4);\n+            elsif Expv = 4 then\n                Temp := Make_Temporary (Loc, 'E', Base);\n \n                Xnode :=\n@@ -7766,6 +7769,26 @@ package body Exp_Ch4 is\n                        Make_Op_Multiply (Loc,\n                          Left_Opnd  => New_Occurrence_Of (Temp, Loc),\n                          Right_Opnd => New_Occurrence_Of (Temp, Loc))));\n+\n+            --  X ** N = 1.0 / X ** (-N)\n+            --  N in -4 .. -1\n+\n+            else\n+               pragma Assert\n+                 (Expv = -1 or Expv = -2 or Expv = -3 or Expv = -4);\n+               Xnode :=\n+                 Make_Op_Divide (Loc,\n+                   Left_Opnd  =>\n+                     Make_Float_Literal (Loc,\n+                       Radix       => Uint_1,\n+                       Significand => Uint_1,\n+                       Exponent    => Uint_0),\n+                   Right_Opnd =>\n+                     Make_Op_Expon (Loc,\n+                       Left_Opnd  => Duplicate_Subexpr (Base),\n+                       Right_Opnd =>\n+                         Make_Integer_Literal (Loc,\n+                           Intval => -Expv)));\n             end if;\n \n             Rewrite (N, Xnode);"}, {"sha": "f07cc4a665059bfdea2df3a647a81b916305eb5f", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=00f45f309076825e5bae672ffc2229fbe6ef8d88", "patch": "@@ -2458,6 +2458,7 @@ package body Inline is\n \n          elsif Nkind (N) = N_Simple_Return_Statement then\n             if No (Expression (N)) then\n+               Num_Ret := Num_Ret + 1;\n                Make_Exit_Label;\n                Rewrite (N,\n                  Make_Goto_Statement (Loc, Name => New_Copy (Lab_Id)));\n@@ -3396,8 +3397,9 @@ package body Inline is\n \n       elsif Present (Exit_Lab) then\n \n-         --  If the body was a single expression, the single return statement\n-         --  and the corresponding label are useless.\n+         --  If there is a single return statement at the end of the\n+         --  subprogram, the corresponding goto statement and the\n+         --  corresponding label are useless.\n \n          if Num_Ret = 1\n            and then"}, {"sha": "be16b07128450b56cb91d8e6308a8603175758f3", "filename": "gcc/ada/s-exnllf.adb", "status": "modified", "additions": 40, "deletions": 49, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fs-exnllf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fs-exnllf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-exnllf.adb?ref=00f45f309076825e5bae672ffc2229fbe6ef8d88", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,12 +34,28 @@\n --  a compile time known exponent in this range. The use of Float'Machine and\n --  Long_Float'Machine is to avoid unwanted extra precision in the results.\n \n+--  Note that for a negative exponent in Left ** Right, we compute the result\n+--  as:\n+\n+--     1.0 / (Left ** (-Right))\n+\n+--  Note that the case of Left being zero is not special, it will simply result\n+--  in a division by zero at the end, yielding a correctly signed infinity, or\n+--  possibly generating an overflow.\n+\n+--  Note on overflow: This coding assumes that the target generates infinities\n+--  with standard IEEE semantics. If this is not the case, then the code\n+--  for negative exponent may raise Constraint_Error. This follows the\n+--  implementation permission given in RM 4.5.6(12).\n+\n package body System.Exn_LLF is\n \n+   subtype Negative is Integer range Integer'First .. -1;\n+\n    function Exp\n      (Left  : Long_Long_Float;\n-      Right : Integer) return Long_Long_Float;\n-   --  Common routine used if Right not in 0 .. 4\n+      Right : Natural) return Long_Long_Float;\n+   --  Common routine used if Right is greater or equal to 5\n \n    ---------------\n    -- Exn_Float --\n@@ -63,6 +79,8 @@ package body System.Exn_LLF is\n          when 4 =>\n             Temp := Float'Machine (Left * Left);\n             return Float'Machine (Temp * Temp);\n+         when Negative =>\n+            return Float'Machine (1.0 / Exn_Float (Left, -Right));\n          when others =>\n             return\n               Float'Machine\n@@ -92,6 +110,8 @@ package body System.Exn_LLF is\n          when 4 =>\n             Temp := Long_Float'Machine (Left * Left);\n             return Long_Float'Machine (Temp * Temp);\n+         when Negative =>\n+            return Long_Float'Machine (1.0 / Exn_Long_Float (Left, -Right));\n          when others =>\n             return\n               Long_Float'Machine\n@@ -121,6 +141,8 @@ package body System.Exn_LLF is\n          when 4 =>\n             Temp := Left * Left;\n             return Temp * Temp;\n+         when Negative =>\n+            return 1.0 / Exn_Long_Long_Float (Left, -Right);\n          when others =>\n             return Exp (Left, Right);\n       end case;\n@@ -132,60 +154,29 @@ package body System.Exn_LLF is\n \n    function Exp\n      (Left  : Long_Long_Float;\n-      Right : Integer) return Long_Long_Float\n+      Right : Natural) return Long_Long_Float\n    is\n       Result : Long_Long_Float := 1.0;\n       Factor : Long_Long_Float := Left;\n-      Exp    : Integer := Right;\n+      Exp    : Natural := Right;\n \n    begin\n       --  We use the standard logarithmic approach, Exp gets shifted right\n       --  testing successive low order bits and Factor is the value of the\n       --  base raised to the next power of 2. If the low order bit or Exp is\n-      --  set, multiply the result by this factor. For negative exponents,\n-      --  invert result upon return.\n-\n-      if Exp >= 0 then\n-         loop\n-            if Exp rem 2 /= 0 then\n-               Result := Result * Factor;\n-            end if;\n-\n-            Exp := Exp / 2;\n-            exit when Exp = 0;\n-            Factor := Factor * Factor;\n-         end loop;\n-\n-         return Result;\n-\n-      --  Here we have a negative exponent, and we compute the result as:\n-\n-      --     1.0 / (Left ** (-Right))\n-\n-      --  Note that the case of Left being zero is not special, it will\n-      --  simply result in a division by zero at the end, yielding a\n-      --  correctly signed infinity, or possibly generating an overflow.\n-\n-      --  Note on overflow: The coding of this routine assumes that the\n-      --  target generates infinities with standard IEEE semantics. If this\n-      --  is not the case, then the code below may raise Constraint_Error.\n-      --  This follows the implementation permission given in RM 4.5.6(12).\n-\n-      else\n-         begin\n-            loop\n-               if Exp rem 2 /= 0 then\n-                  Result := Result * Factor;\n-               end if;\n-\n-               Exp := Exp / 2;\n-               exit when Exp = 0;\n-               Factor := Factor * Factor;\n-            end loop;\n-\n-            return 1.0 / Result;\n-         end;\n-      end if;\n+      --  set, multiply the result by this factor.\n+\n+      loop\n+         if Exp rem 2 /= 0 then\n+            Result := Result * Factor;\n+         end if;\n+\n+         Exp := Exp / 2;\n+         exit when Exp = 0;\n+         Factor := Factor * Factor;\n+      end loop;\n+\n+      return Result;\n    end Exp;\n \n end System.Exn_LLF;"}, {"sha": "f34ae63f2f55dd4617e10ba9f9797b49593fd195", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=00f45f309076825e5bae672ffc2229fbe6ef8d88", "patch": "@@ -809,8 +809,8 @@ package body Sem_Aggr is\n    begin\n       return No (Expressions (Aggr))\n         and then\n-          Nkind (First (Choices (First (Component_Associations (Aggr))))) =\n-                                                              N_Others_Choice;\n+          Nkind (First (Choice_List (First (Component_Associations (Aggr)))))\n+             = N_Others_Choice;\n    end Is_Others_Aggregate;\n \n    ----------------------------\n@@ -1207,10 +1207,6 @@ package body Sem_Aggr is\n       function Dynamic_Or_Null_Range (L, H : Node_Id) return Boolean;\n       --  Returns True if range L .. H is dynamic or null\n \n-      function Choice_List (N : Node_Id) return List_Id;\n-      --  Utility to retrieve the choices of a Component_Association or the\n-      --  Discrete_Choices of an Iterated_Component_Association.\n-\n       procedure Get (Value : out Uint; From : Node_Id; OK : out Boolean);\n       --  Given expression node From, this routine sets OK to False if it\n       --  cannot statically evaluate From. Otherwise it stores this static\n@@ -1473,19 +1469,6 @@ package body Sem_Aggr is\n            or else Val_L > Val_H;\n       end Dynamic_Or_Null_Range;\n \n-      -----------------\n-      -- Choice_List --\n-      -----------------\n-\n-      function Choice_List (N : Node_Id) return List_Id is\n-      begin\n-         if Nkind (N) = N_Iterated_Component_Association then\n-            return Discrete_Choices (N);\n-         else\n-            return Choices (N);\n-         end if;\n-      end Choice_List;\n-\n       ---------\n       -- Get --\n       ---------\n@@ -1708,7 +1691,7 @@ package body Sem_Aggr is\n       Expr    : Node_Id;\n       Discard : Node_Id;\n \n-      Iterated_Component_Present : Boolean := False;\n+      --  Iterated_Component_Present : Boolean := False;\n \n       Aggr_Low  : Node_Id := Empty;\n       Aggr_High : Node_Id := Empty;\n@@ -1749,7 +1732,7 @@ package body Sem_Aggr is\n          while Present (Assoc) loop\n             if Nkind (Assoc) = N_Iterated_Component_Association then\n                Resolve_Iterated_Component_Association (Assoc, Index_Typ);\n-               Iterated_Component_Present := True;\n+               --  Iterated_Component_Present := True;\n                goto Next_Assoc;\n             end if;\n \n@@ -2726,10 +2709,6 @@ package body Sem_Aggr is\n \n       Analyze_Dimension_Array_Aggregate (N, Component_Typ);\n \n-      if Iterated_Component_Present then\n-         Error_Msg_N (\"iterated association not implemented yet\", N);\n-      end if;\n-\n       return Success;\n    end Resolve_Array_Aggregate;\n "}, {"sha": "0a6a30efeb19fdeae3ad4a659aab25accf5c1d17", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=00f45f309076825e5bae672ffc2229fbe6ef8d88", "patch": "@@ -4149,9 +4149,10 @@ package body Sem_Ch3 is\n \n          elsif Nkind (E) = N_Aggregate\n            and then Present (Component_Associations (E))\n-           and then Present (Choices (First (Component_Associations (E))))\n-           and then Nkind (First\n-            (Choices (First (Component_Associations (E))))) = N_Others_Choice\n+           and then Present (Choice_List (First (Component_Associations (E))))\n+           and then\n+             Nkind (First (Choice_List (First (Component_Associations (E)))))\n+               = N_Others_Choice\n          then\n             null;\n "}, {"sha": "3e5269f20f9b132acefee2ad0ccbccc9dbea0e19", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=00f45f309076825e5bae672ffc2229fbe6ef8d88", "patch": "@@ -3853,6 +3853,19 @@ package body Sem_Util is\n       end if;\n    end Check_Unused_Body_States;\n \n+   -----------------\n+   -- Choice_List --\n+   -----------------\n+\n+   function Choice_List (N : Node_Id) return List_Id is\n+   begin\n+      if Nkind (N) = N_Iterated_Component_Association then\n+         return Discrete_Choices (N);\n+      else\n+         return Choices (N);\n+      end if;\n+   end Choice_List;\n+\n    -------------------------\n    -- Collect_Body_States --\n    -------------------------"}, {"sha": "b5d1e4aec0b1245e9f273446ce037b30eee82e02", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f45f309076825e5bae672ffc2229fbe6ef8d88/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=00f45f309076825e5bae672ffc2229fbe6ef8d88", "patch": "@@ -337,6 +337,12 @@ package Sem_Util is\n    --  and the context is external to the protected operation, to warn against\n    --  a possible unlocked access to data.\n \n+   function Choice_List (N : Node_Id) return List_Id;\n+   --  Utility to retrieve the choices of a Component_Association or the\n+   --  Discrete_Choices of an Iterated_Component_Association. For various\n+   --  reasons these nodes have a different structure even though they play\n+   --  similar roles in array aggregates.\n+\n    function Collect_Body_States (Body_Id : Entity_Id) return Elist_Id;\n    --  Gather the entities of all abstract states and objects declared in the\n    --  body state space of package body Body_Id."}]}