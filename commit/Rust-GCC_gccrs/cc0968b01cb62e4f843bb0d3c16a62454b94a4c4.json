{"sha": "cc0968b01cb62e4f843bb0d3c16a62454b94a4c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MwOTY4YjAxY2I2MmU0Zjg0M2JiMGQzYzE2YTYyNDU0Yjk0YTRjNA==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2006-08-10T12:07:22Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2006-08-10T12:07:22Z"}, "message": "re PR tree-optimization/26197 (ICE in is_old_name with vectorizer)\n\n        PR tree-optimization/26197\n        * tree-ssa-alias.c (new_type_alias): Takes additional argument. Calls\n        get_ref_base_and_extent and overlap_subvar to add only relevant\n        subvars as may-aliases.\n        (add_may_alias_for_new_tag): New function, factored out of\n        new_type_alias.\n        * tree-vect-transform.c (vect_create_data_ref_ptr): Call new_type_alias\n        with additional argument.\n        * tree-flow.h (new_type_alias): Takes additional argument.\n\nFrom-SVN: r116060", "tree": {"sha": "48285f9f7c641d9cc4879127dc49ff7ea3d12d07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48285f9f7c641d9cc4879127dc49ff7ea3d12d07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/comments", "author": null, "committer": null, "parents": [{"sha": "22a8ed6556f9d57d93f43b60da5198136890f9c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a8ed6556f9d57d93f43b60da5198136890f9c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22a8ed6556f9d57d93f43b60da5198136890f9c7"}], "stats": {"total": 178, "additions": 137, "deletions": 41}, "files": [{"sha": "ddd2e67edce0b73898c50a31664490b3c534f8d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc0968b01cb62e4f843bb0d3c16a62454b94a4c4", "patch": "@@ -1,3 +1,15 @@\n+2006-08-10  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\tPR tree-optimization/26197\n+\t* tree-ssa-alias.c (new_type_alias): Takes additional argument. Calls\n+\tget_ref_base_and_extent and overlap_subvar to add only relevant\n+\tsubvars as may-aliases.\n+\t(add_may_alias_for_new_tag): New function, factored out of\n+\tnew_type_alias.\n+\t* tree-vect-transform.c (vect_create_data_ref_ptr): Call new_type_alias\n+\twith additional argument.\n+\t* tree-flow.h (new_type_alias): Takes additional argument.\n+\n 2006-08-09  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* gcov.c (no_data_file): New flag."}, {"sha": "55c187cad32af35bf4988e379e234f1bd76aec1f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cc0968b01cb62e4f843bb0d3c16a62454b94a4c4", "patch": "@@ -1,3 +1,9 @@\n+2006-08-10  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\tPR tree-optimization/26197\n+\t* g++.dg/vect/param-max-aliased-pr26197.cc: New test.\n+\t* g++.dg/vect/vect.exp: Compile the new testxs with --param max-aliased-vops=0.\n+\n 2006-08-09  Lee Millward  <lee.millward@codesourcery.com>\n \n        PR c++/28637"}, {"sha": "198cd6b53ac10b825fd081fa9b65c994a2412e10", "filename": "gcc/testsuite/g++.dg/vect/param-max-aliased-pr26197.cc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fparam-max-aliased-pr26197.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fparam-max-aliased-pr26197.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fparam-max-aliased-pr26197.cc?ref=cc0968b01cb62e4f843bb0d3c16a62454b94a4c4", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+\n+void g(const void*);\n+struct B\n+{\n+  int* x[2];\n+  int *p;\n+  B()\n+  {\n+     for (int** p=x; p<x+4; ++p)\n+      *p = 0;\n+  }\n+  ~B()\n+   {\n+      g(p);\n+   }\n+};\n+void bar()\n+{\n+  const B &b = B();\n+  g(&b);\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ce51c8a4f256b6b332d28fe68ddbcc788c67146a", "filename": "gcc/testsuite/g++.dg/vect/vect.exp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvect.exp?ref=cc0968b01cb62e4f843bb0d3c16a62454b94a4c4", "patch": "@@ -89,6 +89,16 @@ dg-init\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.{c,cc,S} ]] \\\n         \"\" $DEFAULT_VECTCFLAGS\n \n+#### Tests with special options\n+global SAVED_DEFAULT_VECTCFLAGS\n+set SAVED_DEFAULT_VECTCFLAGS $DEFAULT_VECTCFLAGS\n+    \n+# --param max-aliased-vops=0\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"--param max-aliased-vops=0\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/param-max-aliased*.\\[cS\\]]]  \\\n+        \"\" $DEFAULT_VECTCFLAGS \n+\n # Clean up.\n set dg-do-what-default ${save-dg-do-what-default} \n "}, {"sha": "46966663fe5f0f22ef024fd1290f0837c729b290", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=cc0968b01cb62e4f843bb0d3c16a62454b94a4c4", "patch": "@@ -667,7 +667,7 @@ extern void debug_points_to_info_for (tree);\n extern bool may_be_aliased (tree);\n extern bool is_aliased_with (tree, tree);\n extern struct ptr_info_def *get_ptr_info (tree);\n-extern void new_type_alias (tree, tree);\n+extern void new_type_alias (tree, tree, tree);\n extern void count_uses_and_derefs (tree, tree, unsigned *, unsigned *, bool *);\n static inline subvar_t get_subvars_for_var (tree);\n static inline tree get_subvar_at (tree, unsigned HOST_WIDE_INT);"}, {"sha": "6bfa4bb6063d0d07f5ba916e4719422acefc5c82", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 83, "deletions": 39, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=cc0968b01cb62e4f843bb0d3c16a62454b94a4c4", "patch": "@@ -2691,79 +2691,123 @@ is_aliased_with (tree tag, tree sym)\n   return false;\n }\n \n+/* The following is based on code in add_stmt_operand to ensure that the\n+   same defs/uses/vdefs/vuses will be found after replacing a reference\n+   to var (or ARRAY_REF to var) with an INDIRECT_REF to ptr whose value\n+   is the address of var.  Return a memtag for the ptr, after adding the \n+   proper may_aliases to it (which are the aliases of var, if it has any,\n+   or var itself).  */\n+\n+static tree\n+add_may_alias_for_new_tag (tree tag, tree var)\n+{\n+  var_ann_t v_ann = var_ann (var);\n+  VEC(tree, gc) *aliases = v_ann->may_aliases;\n+\n+  /* Case 1: |aliases| == 1  */\n+  if ((aliases != NULL)\n+      && (VEC_length (tree, aliases) == 1))\n+    {\n+      tree ali = VEC_index (tree, aliases, 0);\n+\n+      if (TREE_CODE (ali) == SYMBOL_MEMORY_TAG)\n+        return ali;\n+    }\n+\n+  /* Case 2: |aliases| == 0  */\n+  if (aliases == NULL)\n+    add_may_alias (tag, var);\n+  else\n+    {\n+      /* Case 3: |aliases| > 1  */\n+      unsigned i;\n+      tree al;\n+\n+      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n+        add_may_alias (tag, al);\n+    }\n+\n+  return tag;\n+}\n \n /* Create a new symbol tag for PTR.  Construct the may-alias list of this type\n-   tag so that it has the aliasing of VAR. \n+   tag so that it has the aliasing of VAR, or of the relevant subvars of VAR\n+   according to the location accessed by EXPR.\n \n    Note, the set of aliases represented by the new symbol tag are not marked\n    for renaming.  */\n \n void\n-new_type_alias (tree ptr, tree var)\n+new_type_alias (tree ptr, tree var, tree expr)\n {\n   var_ann_t p_ann = var_ann (ptr);\n   tree tag_type = TREE_TYPE (TREE_TYPE (ptr));\n-  var_ann_t v_ann = var_ann (var);\n   tree tag;\n   subvar_t svars;\n+  tree ali = NULL_TREE;\n+  HOST_WIDE_INT offset, size, maxsize;\n+  tree ref;\n \n   gcc_assert (p_ann->symbol_mem_tag == NULL_TREE);\n   gcc_assert (!MTAG_P (var));\n \n+  ref = get_ref_base_and_extent (expr, &offset, &size, &maxsize);\n+  gcc_assert (ref);\n+\n+  tag = create_memory_tag (tag_type, true);\n+  p_ann->symbol_mem_tag = tag;\n+\n   /* Add VAR to the may-alias set of PTR's new symbol tag.  If VAR has\n      subvars, add the subvars to the tag instead of the actual var.  */\n   if (var_can_have_subvars (var)\n       && (svars = get_subvars_for_var (var)))\n     {\n       subvar_t sv;\n-\n-      tag = create_memory_tag (tag_type, true);\n-      p_ann->symbol_mem_tag = tag;\n+      VEC (tree, heap) *overlaps = NULL;\n+      unsigned int len;\n \n       for (sv = svars; sv; sv = sv->next)\n-        add_may_alias (tag, sv->var);\n-    }\n-  else\n-    {\n-      /* The following is based on code in add_stmt_operand to ensure that the\n-\t same defs/uses/vdefs/vuses will be found after replacing a reference\n-\t to var (or ARRAY_REF to var) with an INDIRECT_REF to ptr whose value\n-\t is the address of var.  */\n-      VEC(tree, gc) *aliases = v_ann->may_aliases;\n-\n-      if ((aliases != NULL)\n-\t  && (VEC_length (tree, aliases) == 1))\n \t{\n-\t  tree ali = VEC_index (tree, aliases, 0);\n+          bool exact;\n \n-\t  if (TREE_CODE (ali) == SYMBOL_MEMORY_TAG)\n+          if (overlap_subvar (offset, maxsize, sv->var, &exact))\n+            VEC_safe_push (tree, heap, overlaps, sv->var);\n+        }\n+      len = VEC_length (tree, overlaps);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+        fprintf (dump_file, \"\\nnumber of overlapping subvars = %u\\n\", len);\n+      gcc_assert (len);\n+\n+      if (len == 1)\n+        ali = add_may_alias_for_new_tag (tag, VEC_index (tree, overlaps, 0));\n+      else if (len > 1)\n+        {\n+\t  unsigned int k;\n+\t  tree sv_var;\n+\n+\t  for (k = 0; VEC_iterate (tree, overlaps, k, sv_var); k++)\n \t    {\n-\t      p_ann->symbol_mem_tag = ali;\n-\t      return;\n-\t    }\n-\t}\n-\n-      tag = create_memory_tag (tag_type, true);\n-      p_ann->symbol_mem_tag = tag;\n-\n-      if (aliases == NULL)\n-\tadd_may_alias (tag, var);\n-      else\n-\t{\n-\t  unsigned i;\n-\t  tree al;\n+\t      ali = add_may_alias_for_new_tag (tag, sv_var);\n \n-\t  for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n-\t    add_may_alias (tag, al);\n+\t      if (ali != tag)\n+\t\t{\n+\t\t  /* Can happen only if 'Case 1' of add_may_alias_for_new_tag\n+\t\t     took place.  Since more than one svar was found, we add \n+\t\t     'ali' as one of the may_aliases of the new tag.  */ \n+\t\t  add_may_alias (tag, ali);\n+\t\t  ali = tag;\n+\t\t}\n+\t    }\n \t}\n-    }    \n+    }\n+  else\n+    ali = add_may_alias_for_new_tag (tag, var);\n \n+  p_ann->symbol_mem_tag = ali;\n   TREE_READONLY (tag) = TREE_READONLY (var);\n   MTAG_GLOBAL (tag) = is_global_var (var);\n }\n \n-\n-\n /* This represents the used range of a variable.  */\n \n typedef struct used_part"}, {"sha": "5f1b2069cebf1d8647abd84da5c00f6dfb6fbae9", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0968b01cb62e4f843bb0d3c16a62454b94a4c4/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=cc0968b01cb62e4f843bb0d3c16a62454b94a4c4", "patch": "@@ -303,7 +303,7 @@ vect_create_data_ref_ptr (tree stmt,\n   /* If tag is a variable (and NOT_A_TAG) than a new symbol memory\n      tag must be created with tag added to its may alias list.  */\n   if (!MTAG_P (tag))\n-    new_type_alias (vect_ptr, tag);\n+    new_type_alias (vect_ptr, tag, DR_REF (dr));\n   else\n     var_ann (vect_ptr)->symbol_mem_tag = tag;\n "}]}