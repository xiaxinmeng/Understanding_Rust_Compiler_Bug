{"sha": "20460eb94863954cf7ebdc7bf2193038ac0b781a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA0NjBlYjk0ODYzOTU0Y2Y3ZWJkYzdiZjIxOTMwMzhhYzBiNzgxYQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2009-06-29T21:02:17Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-06-29T21:02:17Z"}, "message": "re PR fortran/40580 (Add -fcheck=pointer with runtime check for using an unallocated argument)\n\n2009-06-29  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/40580\n        * trans-expr.c  (gfc_conv_procedure_call): Add -fcheck=pointer\n        * check.\n        * libgfortran.h: Add GFC_RTCHECK_POINTER.\n        * invoke.texi (-fcheck): Document new pointer option.\n        * options.c (gfc_handle_runtime_check_option): Handle pointer\n        * option.\n\n        * gfortran.texi (C Binding): Improve wording.\n        * iso-c-binding.def: Remove obsolete comment.\n\n\n2009-06-29  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/40580\n        * pointer_check_1.f90: New test.\n        * pointer_check_2.f90: New test.\n        * pointer_check_3.f90: New test.\n        * pointer_check_4.f90: New test.\n        * pointer_check_5.f90: New test.\n\nFrom-SVN: r149063", "tree": {"sha": "f4b9667f6f491ec9edcb2471c4bf08b3e532f635", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4b9667f6f491ec9edcb2471c4bf08b3e532f635"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20460eb94863954cf7ebdc7bf2193038ac0b781a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20460eb94863954cf7ebdc7bf2193038ac0b781a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20460eb94863954cf7ebdc7bf2193038ac0b781a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20460eb94863954cf7ebdc7bf2193038ac0b781a/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a61a36ab30b7711b5d5cf002d52e6e9514499739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61a36ab30b7711b5d5cf002d52e6e9514499739", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a61a36ab30b7711b5d5cf002d52e6e9514499739"}], "stats": {"total": 531, "additions": 521, "deletions": 10}, "files": [{"sha": "27d47cfed8eca7dbfa131f510a9ce85ad5f09364", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=20460eb94863954cf7ebdc7bf2193038ac0b781a", "patch": "@@ -1,3 +1,14 @@\n+2009-06-29  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/40580\n+\t* trans-expr.c  (gfc_conv_procedure_call): Add -fcheck=pointer check.\n+\t* libgfortran.h: Add GFC_RTCHECK_POINTER.\n+\t* invoke.texi (-fcheck): Document new pointer option.\n+\t* options.c (gfc_handle_runtime_check_option): Handle pointer option.\n+\n+\t* gfortran.texi (C Binding): Improve wording.\n+\t* iso-c-binding.def: Remove obsolete comment.\n+\n 2009-06-29  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/40551"}, {"sha": "f9e49325b8e41a8bb8d5e2cec63bad39af503632", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=20460eb94863954cf7ebdc7bf2193038ac0b781a", "patch": "@@ -1965,10 +1965,10 @@ a macro. Use the @code{IERRNO} intrinsic (GNU extension) instead.\n Subroutines and functions have to have the @code{BIND(C)} attribute to\n be compatible with C. The dummy argument declaration is relatively\n straightforward. However, one needs to be careful because C uses\n-call-by-value by default while GNU Fortran uses call-by-reference.\n-Furthermore, strings and pointers are handled differently. Note that\n-only explicit size and assumed-size arrays are supported but not\n-assumed-shape or allocatable arrays.\n+call-by-value by default while Fortran behaves usually similar to\n+call-by-reference. Furthermore, strings and pointers are handled\n+differently. Note that only explicit size and assumed-size arrays are\n+supported but not assumed-shape or allocatable arrays.\n \n To pass a variable by value, use the @code{VALUE} attribute.\n Thus the following C prototype\n@@ -2277,7 +2277,7 @@ initialization using @code{_gfortran_set_args}.\n Default: enabled.\n @item @var{option}[6] @tab Enables run-time checking. Possible values\n are (bitwise or-ed): GFC_RTCHECK_BOUNDS (1), GFC_RTCHECK_ARRAY_TEMPS (2),\n-GFC_RTCHECK_RECURSION (4), GFC_RTCHECK_DO (16).\n+GFC_RTCHECK_RECURSION (4), GFC_RTCHECK_DO (16), GFC_RTCHECK_POINTER (32).\n Default: disabled.\n @item @var{option}[7] @tab If non zero, range checking is enabled.\n Default: enabled. See -frange-check (@pxref{Code Gen Options})."}, {"sha": "5d0448f3cbe8fca5d438dff40024859f09b99e2c", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=20460eb94863954cf7ebdc7bf2193038ac0b781a", "patch": "@@ -166,7 +166,7 @@ and warnings}.\n @gccoptlist{-fno-automatic  -ff2c  -fno-underscoring @gol\n -fwhole-file -fsecond-underscore @gol\n -fbounds-check -fcheck-array-temporaries  -fmax-array-constructor =@var{n} @gol\n--fcheck=@var{<all|array-temps|bounds|do|recursion>}\n+-fcheck=@var{<all|array-temps|bounds|do|pointer|recursion>}\n -fmax-stack-var-size=@var{n} @gol\n -fpack-derived  -frepack-arrays  -fshort-enums  -fexternal-blas @gol\n -fblas-matmul-limit=@var{n} -frecursive -finit-local-zero @gol\n@@ -1203,6 +1203,7 @@ by use of the @option{-ff2c} option.\n @opindex @code{fcheck}\n @cindex array, bounds checking\n @cindex bounds checking\n+@cindex pointer checking\n @cindex range checking\n @cindex subscript checking\n @cindex checking subscripts\n@@ -1241,6 +1242,9 @@ checking substring references.\n Enable generation of run-time checks for invalid modification of loop\n iteration variables.\n \n+@item @samp{pointer}\n+Enable generation of run-time checks for pointers and allocatables.\n+\n @item @samp{recursion}\n Enable generation of run-time checks for recursively called subroutines and\n functions which are not marked as recursive. See also @option{-frecursive}."}, {"sha": "a529368765c4a850eead78a37e8ffafae628d81c", "filename": "gcc/fortran/iso-c-binding.def", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2Fiso-c-binding.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2Fiso-c-binding.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fiso-c-binding.def?ref=20460eb94863954cf7ebdc7bf2193038ac0b781a", "patch": "@@ -160,8 +160,6 @@ PROCEDURE (ISOCBINDING_F_POINTER, \"c_f_pointer\")\n PROCEDURE (ISOCBINDING_ASSOCIATED, \"c_associated\")\n PROCEDURE (ISOCBINDING_LOC, \"c_loc\")\n PROCEDURE (ISOCBINDING_FUNLOC, \"c_funloc\")\n-\n-/* Insert c_f_procpointer, though unsupported for now.  */\n PROCEDURE (ISOCBINDING_F_PROCPOINTER, \"c_f_procpointer\")\n \n #undef NAMED_INTCST"}, {"sha": "a18fdce2e8814883e94d59c53ebc532884eac980", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=20460eb94863954cf7ebdc7bf2193038ac0b781a", "patch": "@@ -47,8 +47,10 @@ along with GCC; see the file COPYING3.  If not see\n #define GFC_RTCHECK_ARRAY_TEMPS (1<<1)\n #define GFC_RTCHECK_RECURSION   (1<<2)\n #define GFC_RTCHECK_DO          (1<<3)\n+#define GFC_RTCHECK_POINTER     (1<<4)\n #define GFC_RTCHECK_ALL        (GFC_RTCHECK_BOUNDS | GFC_RTCHECK_ARRAY_TEMPS \\\n-\t\t\t\t| GFC_RTCHECK_RECURSION | GFC_RTCHECK_DO)\n+\t\t\t\t| GFC_RTCHECK_RECURSION | GFC_RTCHECK_DO \\\n+\t\t\t\t| GFC_RTCHECK_POINTER)\n \n \n /* Possible values for the CONVERT I/O specifier.  */"}, {"sha": "ff0a80983dae0d4a25e5f58d8c96a2d82b1e6e31", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=20460eb94863954cf7ebdc7bf2193038ac0b781a", "patch": "@@ -471,10 +471,11 @@ gfc_handle_runtime_check_option (const char *arg)\n {\n   int result, pos = 0, n;\n   static const char * const optname[] = { \"all\", \"bounds\", \"array-temps\",\n-\t\t\t\t\t  \"recursion\", \"do\", NULL };\n+\t\t\t\t\t  \"recursion\", \"do\", \"pointer\", NULL };\n   static const int optmask[] = { GFC_RTCHECK_ALL, GFC_RTCHECK_BOUNDS,\n \t\t\t\t GFC_RTCHECK_ARRAY_TEMPS,\n \t\t\t\t GFC_RTCHECK_RECURSION, GFC_RTCHECK_DO,\n+\t\t\t\t GFC_RTCHECK_POINTER,\n \t\t\t\t 0 };\n  \n   while (*arg)"}, {"sha": "19ac1390f82a462cb96d972369a3e50da883aaef", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=20460eb94863954cf7ebdc7bf2193038ac0b781a", "patch": "@@ -2772,6 +2772,48 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  gfc_add_expr_to_block (&se->post, tmp);\n         }\n \n+      /* Add argument checking of passing an unallocated/NULL actual to\n+         a nonallocatable/nonpointer dummy.  */\n+\n+      if (gfc_option.rtcheck & GFC_RTCHECK_POINTER)\n+        {\n+\t  gfc_symbol *sym;\n+\t  char *msg;\n+\t  tree cond;\n+\n+\t  if (e->expr_type == EXPR_VARIABLE)\n+\t    sym = e->symtree->n.sym;\n+\t  else if (e->expr_type == EXPR_FUNCTION)\n+\t    sym = e->symtree->n.sym->result;\n+\t  else\n+\t    goto end_pointer_check;\n+\n+\t  if (sym->attr.allocatable\n+\t      && (fsym == NULL || !fsym->attr.allocatable))\n+\t    asprintf (&msg, \"Allocatable actual argument '%s' is not \"\n+\t\t      \"allocated\", sym->name);\n+\t  else if (sym->attr.pointer\n+\t      && (fsym == NULL || !fsym->attr.pointer))\n+\t    asprintf (&msg, \"Pointer actual argument '%s' is not \"\n+\t\t      \"associated\", sym->name);\n+          else if (sym->attr.proc_pointer\n+\t      && (fsym == NULL || !fsym->attr.proc_pointer))\n+\t    asprintf (&msg, \"Proc-pointer actual argument '%s' is not \"\n+\t\t      \"associated\", sym->name);\n+\t  else\n+\t    goto end_pointer_check;\n+\n+\t  cond  = fold_build2 (EQ_EXPR, boolean_type_node, parmse.expr,\n+\t\t\t       fold_convert (TREE_TYPE (parmse.expr),\n+\t\t\t\t\t     null_pointer_node));\n+ \n+\t  gfc_trans_runtime_check (true, false, cond, &se->pre, &e->where,\n+\t\t\t\t   msg);\n+\t  gfc_free (msg);\n+        }\n+      end_pointer_check:\n+\n+\n       /* Character strings are passed as two parameters, a length and a\n          pointer - except for Bind(c) which only passes the pointer.  */\n       if (parmse.string_length != NULL_TREE && !sym->attr.is_bind_c)"}, {"sha": "3adb59d22a31c53b3e0471e25c76aa2f8941f3dc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=20460eb94863954cf7ebdc7bf2193038ac0b781a", "patch": "@@ -1,3 +1,12 @@\n+2009-06-29  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/40580\n+\t* pointer_check_1.f90: New test.\n+\t* pointer_check_2.f90: New test.\n+\t* pointer_check_3.f90: New test.\n+\t* pointer_check_4.f90: New test.\n+\t* pointer_check_5.f90: New test.\n+\n 2009-06-29  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/40551"}, {"sha": "6d43bf3029f2b3c33d3fa3dc006de5c42e9751f0", "filename": "gcc/testsuite/gfortran.dg/pointer_check_1.f90", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_1.f90?ref=20460eb94863954cf7ebdc7bf2193038ac0b781a", "patch": "@@ -0,0 +1,86 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=pointer\" }\n+! { dg-shouldfail \"Unassociated/unallocated actual argument\" }\n+!\n+! { dg-output \".*At line 53 .*Allocatable actual argument 'alloc2' is not allocated\" }\n+!\n+! PR fortran/40580\n+!\n+! Run-time check of passing deallocated/nonassociated actuals\n+! to nonallocatable/nonpointer dummies.\n+!\n+! Check for variable actuals\n+!\n+\n+subroutine test1(a)\n+  integer :: a\n+  a = 4444\n+end subroutine test1\n+\n+subroutine test2(a)\n+  integer :: a(2)\n+  a = 4444\n+end subroutine test2\n+\n+subroutine ppTest(f)\n+  implicit none\n+  external f\n+  call f()\n+end subroutine ppTest\n+\n+Program RunTimeCheck\n+  implicit none\n+  external :: test1, test2, ppTest\n+  integer, pointer :: ptr1, ptr2(:)\n+  integer, allocatable :: alloc2(:)\n+  procedure(), pointer :: pptr\n+\n+  allocate(ptr1,ptr2(2),alloc2(2))\n+  pptr => sub\n+  ! OK\n+  call test1(ptr1)\n+  call test3(ptr1)\n+\n+  call test2(ptr2)\n+  call test2(alloc2)\n+  call test4(ptr2)\n+  call test4(alloc2)\n+  call ppTest(pptr)\n+  call ppTest2(pptr)\n+\n+  ! Invalid 1:\n+  deallocate(alloc2)\n+  call test2(alloc2)\n+!  call test4(alloc2)\n+\n+  ! Invalid 2:\n+   deallocate(ptr1,ptr2)\n+   nullify(ptr1,ptr2)\n+!   call test1(ptr1)\n+!   call test3(ptr1)\n+!   call test2(ptr2)\n+!   call test4(ptr2)\n+\n+  ! Invalid 3:\n+  nullify(pptr)\n+!  call ppTest(pptr)\n+  call ppTest2(pptr)\n+\n+contains\n+  subroutine test3(b)\n+    integer :: b\n+    b = 333\n+  end subroutine test3\n+  subroutine test4(b)\n+    integer :: b(2)\n+    b = 333\n+  end subroutine test4\n+  subroutine sub()\n+    print *, 'Hello World'\n+  end subroutine sub\n+  subroutine ppTest2(f)\n+    implicit none\n+    procedure(sub) :: f\n+    call f()\n+  end subroutine ppTest2\n+end Program RunTimeCheck"}, {"sha": "2359b4ae8d2bcd552d8af5dd994b831b54b28d0a", "filename": "gcc/testsuite/gfortran.dg/pointer_check_2.f90", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_2.f90?ref=20460eb94863954cf7ebdc7bf2193038ac0b781a", "patch": "@@ -0,0 +1,86 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=pointer\" }\n+! { dg-shouldfail \"Unassociated/unallocated actual argument\" }\n+!\n+! { dg-output \".*At line 60.*Pointer actual argument 'ptr1' is not associated\" }\n+!\n+! PR fortran/40580\n+!\n+! Run-time check of passing deallocated/nonassociated actuals\n+! to nonallocatable/nonpointer dummies.\n+!\n+! Check for variable actuals\n+!\n+\n+subroutine test1(a)\n+  integer :: a\n+  a = 4444\n+end subroutine test1\n+\n+subroutine test2(a)\n+  integer :: a(2)\n+  a = 4444\n+end subroutine test2\n+\n+subroutine ppTest(f)\n+  implicit none\n+  external f\n+  call f()\n+end subroutine ppTest\n+\n+Program RunTimeCheck\n+  implicit none\n+  external :: test1, test2, ppTest\n+  integer, pointer :: ptr1, ptr2(:)\n+  integer, allocatable :: alloc2(:)\n+  procedure(), pointer :: pptr\n+\n+  allocate(ptr1,ptr2(2),alloc2(2))\n+  pptr => sub\n+  ! OK\n+  call test1(ptr1)\n+  call test3(ptr1)\n+\n+  call test2(ptr2)\n+  call test2(alloc2)\n+  call test4(ptr2)\n+  call test4(alloc2)\n+  call ppTest(pptr)\n+  call ppTest2(pptr)\n+\n+  ! Invalid 1:\n+  deallocate(alloc2)\n+!  call test2(alloc2)\n+!  call test4(alloc2)\n+\n+  ! Invalid 2:\n+   deallocate(ptr1,ptr2)\n+   nullify(ptr1,ptr2)\n+!   call test1(ptr1)\n+   call test3(ptr1)\n+!   call test2(ptr2)\n+!   call test4(ptr2)\n+\n+  ! Invalid 3:\n+  nullify(pptr)\n+!  call ppTest(pptr)\n+  call ppTest2(pptr)\n+\n+contains\n+  subroutine test3(b)\n+    integer :: b\n+    b = 333\n+  end subroutine test3\n+  subroutine test4(b)\n+    integer :: b(2)\n+    b = 333\n+  end subroutine test4\n+  subroutine sub()\n+    print *, 'Hello World'\n+  end subroutine sub\n+  subroutine ppTest2(f)\n+    implicit none\n+    procedure(sub) :: f\n+    call f()\n+  end subroutine ppTest2\n+end Program RunTimeCheck"}, {"sha": "23596e44e4b985787cbd3bef70c4a026357e113c", "filename": "gcc/testsuite/gfortran.dg/pointer_check_3.f90", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_3.f90?ref=20460eb94863954cf7ebdc7bf2193038ac0b781a", "patch": "@@ -0,0 +1,86 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=pointer\" }\n+! { dg-shouldfail \"Unassociated/unallocated actual argument\" }\n+!\n+! { dg-output \".*At line 61.*Pointer actual argument 'ptr2' is not associated\" }\n+!\n+! PR fortran/40580\n+!\n+! Run-time check of passing deallocated/nonassociated actuals\n+! to nonallocatable/nonpointer dummies.\n+!\n+! Check for variable actuals\n+!\n+\n+subroutine test1(a)\n+  integer :: a\n+  a = 4444\n+end subroutine test1\n+\n+subroutine test2(a)\n+  integer :: a(2)\n+  a = 4444\n+end subroutine test2\n+\n+subroutine ppTest(f)\n+  implicit none\n+  external f\n+  call f()\n+end subroutine ppTest\n+\n+Program RunTimeCheck\n+  implicit none\n+  external :: test1, test2, ppTest\n+  integer, pointer :: ptr1, ptr2(:)\n+  integer, allocatable :: alloc2(:)\n+  procedure(), pointer :: pptr\n+\n+  allocate(ptr1,ptr2(2),alloc2(2))\n+  pptr => sub\n+  ! OK\n+  call test1(ptr1)\n+  call test3(ptr1)\n+\n+  call test2(ptr2)\n+  call test2(alloc2)\n+  call test4(ptr2)\n+  call test4(alloc2)\n+  call ppTest(pptr)\n+  call ppTest2(pptr)\n+\n+  ! Invalid 1:\n+  deallocate(alloc2)\n+!  call test2(alloc2)\n+!  call test4(alloc2)\n+\n+  ! Invalid 2:\n+   deallocate(ptr1,ptr2)\n+   nullify(ptr1,ptr2)\n+!   call test1(ptr1)\n+!   call test3(ptr1)\n+   call test2(ptr2)\n+!   call test4(ptr2)\n+\n+  ! Invalid 3:\n+  nullify(pptr)\n+!  call ppTest(pptr)\n+  call ppTest2(pptr)\n+\n+contains\n+  subroutine test3(b)\n+    integer :: b\n+    b = 333\n+  end subroutine test3\n+  subroutine test4(b)\n+    integer :: b(2)\n+    b = 333\n+  end subroutine test4\n+  subroutine sub()\n+    print *, 'Hello World'\n+  end subroutine sub\n+  subroutine ppTest2(f)\n+    implicit none\n+    procedure(sub) :: f\n+    call f()\n+  end subroutine ppTest2\n+end Program RunTimeCheck"}, {"sha": "97eb6fad51e6cb2da906bd3002097d504868b3c4", "filename": "gcc/testsuite/gfortran.dg/pointer_check_4.f90", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_4.f90?ref=20460eb94863954cf7ebdc7bf2193038ac0b781a", "patch": "@@ -0,0 +1,86 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=pointer\" }\n+! { dg-shouldfail \"Unassociated/unallocated actual argument\" }\n+!\n+! { dg-output \".*At line 66.*Proc-pointer actual argument 'pptr' is not associated\" }\n+!\n+! PR fortran/40580\n+!\n+! Run-time check of passing deallocated/nonassociated actuals\n+! to nonallocatable/nonpointer dummies.\n+!\n+! Check for variable actuals\n+!\n+\n+subroutine test1(a)\n+  integer :: a\n+  a = 4444\n+end subroutine test1\n+\n+subroutine test2(a)\n+  integer :: a(2)\n+  a = 4444\n+end subroutine test2\n+\n+subroutine ppTest(f)\n+  implicit none\n+  external f\n+  call f()\n+end subroutine ppTest\n+\n+Program RunTimeCheck\n+  implicit none\n+  external :: test1, test2, ppTest\n+  integer, pointer :: ptr1, ptr2(:)\n+  integer, allocatable :: alloc2(:)\n+  procedure(), pointer :: pptr\n+\n+  allocate(ptr1,ptr2(2),alloc2(2))\n+  pptr => sub\n+  ! OK\n+  call test1(ptr1)\n+  call test3(ptr1)\n+\n+  call test2(ptr2)\n+  call test2(alloc2)\n+  call test4(ptr2)\n+  call test4(alloc2)\n+  call ppTest(pptr)\n+  call ppTest2(pptr)\n+\n+  ! Invalid 1:\n+  deallocate(alloc2)\n+!  call test2(alloc2)\n+!  call test4(alloc2)\n+\n+  ! Invalid 2:\n+   deallocate(ptr1,ptr2)\n+   nullify(ptr1,ptr2)\n+!   call test1(ptr1)\n+!   call test3(ptr1)\n+!   call test2(ptr2)\n+!   call test4(ptr2)\n+\n+  ! Invalid 3:\n+  nullify(pptr)\n+  call ppTest(pptr)\n+!  call ppTest2(pptr)\n+\n+contains\n+  subroutine test3(b)\n+    integer :: b\n+    b = 333\n+  end subroutine test3\n+  subroutine test4(b)\n+    integer :: b(2)\n+    b = 333\n+  end subroutine test4\n+  subroutine sub()\n+    print *, 'Hello World'\n+  end subroutine sub\n+  subroutine ppTest2(f)\n+    implicit none\n+    procedure(sub) :: f\n+    call f()\n+  end subroutine ppTest2\n+end Program RunTimeCheck"}, {"sha": "440d9a879ac6d0e22e69138af8eae89a9ba2aedd", "filename": "gcc/testsuite/gfortran.dg/pointer_check_5.f90", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20460eb94863954cf7ebdc7bf2193038ac0b781a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_check_5.f90?ref=20460eb94863954cf7ebdc7bf2193038ac0b781a", "patch": "@@ -0,0 +1,100 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=pointer\" }\n+! { dg-shouldfail \"Unassociated/unallocated actual argument\" }\n+! \n+! { dg-output \".*At line 46 .*Pointer actual argument 'getptr' is not associated\" }\n+!\n+! PR fortran/40580\n+!\n+! Run-time check of passing deallocated/nonassociated actuals\n+! to nonallocatable/nonpointer dummies.\n+!\n+! Check for function actuals\n+!\n+\n+subroutine test1(a)\n+  integer :: a\n+  print *, a\n+end subroutine test1\n+\n+subroutine test2(a)\n+  integer :: a(2)\n+  print *, a\n+end subroutine test2\n+\n+subroutine ppTest(f)\n+  implicit none\n+  external f\n+  call f()\n+end subroutine ppTest\n+\n+Program RunTimeCheck\n+  implicit none\n+  external :: test1, test2, ppTest\n+  procedure(), pointer :: pptr\n+\n+  ! OK\n+  call test1(getPtr(.true.))\n+  call test2(getPtrArray(.true.))\n+  call test2(getAlloc(.true.))\n+\n+  ! OK but fails due to PR 40593\n+!  call ppTest(getProcPtr(.true.))\n+!  call ppTest2(getProcPtr(.true.))\n+\n+  ! Invalid:\n+  call test1(getPtr(.false.))\n+!  call test2(getAlloc(.false.)) - fails because the check is inserted after\n+!                                  _gfortran_internal_pack, which fails with out of memory\n+!  call ppTest(getProcPtr(.false.)) - fails due to PR 40593\n+!  call ppTest2(getProcPtr(.false.)) - fails due to PR 40593\n+\n+contains\n+  function getPtr(alloc)\n+    integer, pointer :: getPtr\n+    logical, intent(in) :: alloc\n+    if (alloc) then\n+      allocate (getPtr)\n+      getPtr = 1\n+    else\n+      nullify (getPtr)\n+    end if\n+  end function getPtr\n+  function getPtrArray(alloc)\n+    integer, pointer :: getPtrArray(:)\n+    logical, intent(in) :: alloc\n+    if (alloc) then\n+      allocate (getPtrArray(2))\n+      getPtrArray = 1\n+    else\n+      nullify (getPtrArray)\n+    end if\n+  end function getPtrArray\n+  function getAlloc(alloc)\n+    integer, allocatable :: getAlloc(:)\n+    logical, intent(in) :: alloc\n+    if (alloc) then\n+      allocate (getAlloc(2))\n+      getAlloc = 2\n+    else if (allocated(getAlloc)) then\n+      deallocate(getAlloc)\n+    end if\n+  end function getAlloc\n+  subroutine sub()\n+    print *, 'Hello World'\n+  end subroutine sub\n+  function getProcPtr(alloc)\n+    procedure(sub), pointer :: getProcPtr\n+    logical, intent(in) :: alloc\n+    if (alloc) then\n+      getProcPtr => sub\n+    else\n+      nullify (getProcPtr)\n+    end if\n+  end function getProcPtr\n+  subroutine ppTest2(f)\n+    implicit none\n+    procedure(sub) :: f\n+    call f()\n+  end subroutine ppTest2\n+end Program RunTimeCheck"}]}