{"sha": "8eff378c612e592a3cc9e161e382c57e105be6f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVmZjM3OGM2MTJlNTkyYTNjYzllMTYxZTM4MmM1N2UxMDViZTZmNQ==", "commit": {"author": {"name": "Jim Blandy", "email": "jimb@codesourcery.com", "date": "2006-04-12T06:29:21Z"}, "committer": {"name": "Jim Blandy", "email": "jimb@gcc.gnu.org", "date": "2006-04-12T06:29:21Z"}, "message": "pex-common.c (pex_input_file, [...]): New functions.\n\nsrc/libiberty/ChangeLog:\n2006-03-29  Jim Blandy  <jimb@codesourcery.com>\n\n\t* pex-common.c (pex_input_file, pex_input_pipe): New functions.\n\t(pex_init_common): Initialize obj->input_file.\n\t(pex_run): Close any file opened by pex_input_file.\n\t* pexecute.txh (pex_input_file, pex_input_pipe): New docs.\n\t* pex-common.h (struct pex_obj): New field input_file.\n\t(struct pex_funcs): New function ptr fdopenw.\n\t* pex-unix.c (pex_unix_fdopenw): New function.\n\t(funcs): List it as our fdopenw function.\n\t* pex-win32.c (pex_win32_fdopenw): New function.\n\t(funcs): List it as our fdopenw function.\n\t* pex-djgpp.c (funcs): Leave fdopenw null.\n\t* pex-msdos (funcs): Same.\n\t* functions.texi: Regenerated.\n\nsrc/include/ChangeLog:\n2006-04-10  Jim Blandy  <jimb@codesourcery.com>\n\n\t* libiberty.h (pex_input_file, pex_input_pipe): New declarations.\n\nFrom-SVN: r112883", "tree": {"sha": "b7274305f47ba26e60fed695161a3513d463cd52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7274305f47ba26e60fed695161a3513d463cd52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8eff378c612e592a3cc9e161e382c57e105be6f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eff378c612e592a3cc9e161e382c57e105be6f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eff378c612e592a3cc9e161e382c57e105be6f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eff378c612e592a3cc9e161e382c57e105be6f5/comments", "author": null, "committer": null, "parents": [{"sha": "5ea49f9c39ed79fe33bb8c33518a3792b991104f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ea49f9c39ed79fe33bb8c33518a3792b991104f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ea49f9c39ed79fe33bb8c33518a3792b991104f"}], "stats": {"total": 331, "additions": 322, "deletions": 9}, "files": [{"sha": "d062490ac33539073c38d7e7b32a370a1048a642", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eff378c612e592a3cc9e161e382c57e105be6f5/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eff378c612e592a3cc9e161e382c57e105be6f5/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=8eff378c612e592a3cc9e161e382c57e105be6f5", "patch": "@@ -1,3 +1,7 @@\n+2006-04-11  Jim Blandy  <jimb@codesourcery.com>\n+\n+\t* libiberty.h (pex_input_file, pex_input_pipe): New declarations.\n+\n 2006-01-18  DJ Delorie  <dj@redhat.com>\n \n \t* md5.h: Include ansidecl.h"}, {"sha": "6bd318e0fe5d94f79ecbe3c3dbe54892748fc23d", "filename": "include/libiberty.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eff378c612e592a3cc9e161e382c57e105be6f5/include%2Flibiberty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eff378c612e592a3cc9e161e382c57e105be6f5/include%2Flibiberty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Flibiberty.h?ref=8eff378c612e592a3cc9e161e382c57e105be6f5", "patch": "@@ -448,6 +448,47 @@ extern const char *pex_run (struct pex_obj *obj, int flags,\n \t\t\t    const char *outname, const char *errname,\n \t\t\t    int *err);\n \n+/* Return a `FILE' pointer FP for the standard input of the first\n+   program in the pipeline; FP is opened for writing.  You must have\n+   passed `PEX_USE_PIPES' to the `pex_init' call that returned OBJ.\n+   You must close FP yourself with `fclose' to indicate that the\n+   pipeline's input is complete.\n+\n+   The file descriptor underlying FP is marked not to be inherited by\n+   child processes.\n+\n+   This call is not supported on systems which do not support pipes;\n+   it returns with an error.  (We could implement it by writing a\n+   temporary file, but then you would need to write all your data and\n+   close FP before your first call to `pex_run' -- and that wouldn't\n+   work on systems that do support pipes: the pipe would fill up, and\n+   you would block.  So there isn't any easy way to conceal the\n+   differences between the two types of systems.)\n+\n+   If you call both `pex_write_input' and `pex_read_output', be\n+   careful to avoid deadlock.  If the output pipe fills up, so that\n+   each program in the pipeline is waiting for the next to read more\n+   data, and you fill the input pipe by writing more data to FP, then\n+   there is no way to make progress: the only process that could read\n+   data from the output pipe is you, but you are blocked on the input\n+   pipe.  */\n+\n+extern FILE *pex_write_input (struct pex_obj *obj, int binary);\n+\n+/* Return a stream for a temporary file to pass to the first program\n+   in the pipeline as input.  The file name is chosen as for pex_run.\n+   pex_run closes the file automatically; don't close it yourself.  */\n+\n+extern FILE *pex_input_file (struct pex_obj *obj, int flags,\n+                             const char *in_name);\n+\n+/* Return a stream for a pipe connected to the standard input of the\n+   first program in the pipeline.  You must have passed\n+   `PEX_USE_PIPES' to `pex_init'.  Close the returned stream\n+   yourself.  */\n+\n+extern FILE *pex_input_pipe (struct pex_obj *obj, int binary);\n+\n /* Read the standard output of the last program to be executed.\n    pex_run can not be called after this.  BINARY should be non-zero if\n    the file should be opened in binary mode; this is ignored on Unix."}, {"sha": "fb328da633ccf74492003fc942928067caaadd67", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=8eff378c612e592a3cc9e161e382c57e105be6f5", "patch": "@@ -1,3 +1,19 @@\n+2006-03-29  Jim Blandy  <jimb@codesourcery.com>\n+\n+ \t* pex-common.c (pex_input_file, pex_input_pipe): New functions.\n+\t(pex_init_common): Initialize obj->input_file.\n+\t(pex_run): Close any file opened by pex_input_file.\n+ \t* pexecute.txh (pex_input_file, pex_input_pipe): New docs.\n+ \t* pex-common.h (struct pex_obj): New field input_file.\n+\t(struct pex_funcs): New function ptr fdopenw.\n+ \t* pex-unix.c (pex_unix_fdopenw): New function.\n+ \t(funcs): List it as our fdopenw function.\n+ \t* pex-win32.c (pex_win32_fdopenw): New function.\n+ \t(funcs): List it as our fdopenw function.\n+ \t* pex-djgpp.c (funcs): Leave fdopenw null.\n+ \t* pex-msdos (funcs): Same.\n+ \t* functions.texi: Regenerated.\n+\n 2006-04-10  Jim Blandy  <jimb@codesourcery.com>\n \n \t* pex-common.c (temp_file): New function, containing guts of"}, {"sha": "fa92d702d79e559b2a273fd0cbdb9add4828da23", "filename": "libiberty/functions.texi", "status": "modified", "additions": 72, "deletions": 9, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Ffunctions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Ffunctions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffunctions.texi?ref=8eff378c612e592a3cc9e161e382c57e105be6f5", "patch": "@@ -668,14 +668,14 @@ reading and writing.\n \n @end deftypefn\n \n-@c pexecute.txh:169\n+@c pexecute.txh:231\n @deftypefn Extension void pex_free (struct pex_obj @var{obj})\n \n Clean up and free all data associated with @var{obj}.\n \n @end deftypefn\n \n-@c pexecute.txh:144\n+@c pexecute.txh:206\n @deftypefn Extension int pex_get_status (struct pex_obj *@var{obj}, int @var{count}, int *@var{vector})\n \n Returns the exit status of all programs run using @var{obj}.\n@@ -685,7 +685,7 @@ to @code{pex_run}.  Returns 0 on error, 1 on success.\n \n @end deftypefn\n \n-@c pexecute.txh:153\n+@c pexecute.txh:215\n @deftypefn Extension int pex_get_times (struct pex_obj *@var{obj}, int @var{count}, struct pex_time *@var{vector})\n \n Returns the process execution times of all programs run using\n@@ -702,7 +702,7 @@ process times, all the fields will be set to @code{0}.\n \n @end deftypefn\n \n-@c pexecute.txh:1\n+@c pexecute.txh:2\n @deftypefn Extension {struct pex_obj *} pex_init (int @var{flags}, const char *@var{pname}, const char *@var{tempbase})\n \n Prepare to execute one or more programs, with standard output of each\n@@ -734,7 +734,70 @@ temporary files; it may be @code{NULL} to use a randomly chosen name.\n \n @end deftypefn\n \n-@c pexecute.txh:175\n+@c pexecute.txh:133\n+@deftypefn Extension {FILE *} pex_input_file (struct pex_obj *@var{obj}, int @var{flags}, const char *@var{in_name})\n+\n+Return a stream for a temporary file to pass to the first program in\n+the pipeline as input.\n+\n+The name of the input file is chosen according to the same rules\n+@code{pex_run} uses to choose output file names, based on\n+@var{in_name}, @var{obj} and the @code{PEX_SUFFIX} bit in @var{flags}.\n+\n+Don't call @code{fclose} on the returned stream; the first call to\n+@code{pex_run} closes it automatically.\n+\n+If @var{flags} includes @code{PEX_BINARY_OUTPUT}, open the stream in\n+binary mode; otherwise, open it in the default mode.  Including\n+@code{PEX_BINARY_OUTPUT} in @var{flags} has no effect on Unix.\n+@end deftypefn\n+\n+@c pexecute.txh:150\n+@deftypefn Extension {FILE *} pex_input_pipe (struct pex_obj *@var{obj}, int @var{binary})\n+\n+Return a stream @var{fp} for a pipe connected to the standard input of\n+the first program in the pipeline; @var{fp} is opened for writing.\n+You must have passed @code{PEX_USE_PIPES} to the @code{pex_init} call\n+that returned @var{obj}.\n+\n+You must close @var{fp} using @code{fclose} yourself when you have\n+finished writing data to the pipeline.\n+\n+The file descriptor underlying @var{fp} is marked not to be inherited\n+by child processes.\n+\n+On systems that do not support pipes, this function returns\n+@code{NULL}, and sets @code{errno} to @code{EINVAL}.  If you would\n+like to write code that is portable to all systems the @code{pex}\n+functions support, consider using @code{pex_input_file} instead.\n+\n+There are two opportunities for deadlock using\n+@code{pex_input_pipe}:\n+\n+@itemize @bullet\n+@item\n+Most systems' pipes can buffer only a fixed amount of data; a process\n+that writes to a full pipe blocks.  Thus, if you write to @file{fp}\n+before starting the first process, you run the risk of blocking when\n+there is no child process yet to read the data and allow you to\n+continue.  @code{pex_input_pipe} makes no promises about the\n+size of the pipe's buffer, so if you need to write any data at all\n+before starting the first process in the pipeline, consider using\n+@code{pex_input_file} instead.\n+\n+@item\n+Using @code{pex_input_pipe} and @code{pex_read_output} together\n+may also cause deadlock.  If the output pipe fills up, so that each\n+program in the pipeline is waiting for the next to read more data, and\n+you fill the input pipe by writing more data to @var{fp}, then there\n+is no way to make progress: the only process that could read data from\n+the output pipe is you, but you are blocked on the input pipe.\n+\n+@end itemize\n+\n+@end deftypefn\n+\n+@c pexecute.txh:237\n @deftypefn Extension {const char *} pex_one (int @var{flags}, const char *@var{executable}, char * const *@var{argv}, const char *@var{pname}, const char *@var{outname}, const char *@var{errname}, int *@var{status}, int *@var{err})\n \n An interface to permit the easy execution of a\n@@ -747,7 +810,7 @@ be set to the exit status of the program.\n \n @end deftypefn\n \n-@c pexecute.txh:132\n+@c pexecute.txh:194\n @deftypefn Extension {FILE *} pex_read_output (struct pex_obj *@var{obj}, int @var{binary})\n \n Returns a @code{FILE} pointer which may be used to read the standard\n@@ -760,7 +823,7 @@ it will be closed by @code{pex_free}.\n \n @end deftypefn\n \n-@c pexecute.txh:32\n+@c pexecute.txh:33\n @deftypefn Extension {const char *} pex_run (struct pex_obj *@var{obj}, int @var{flags}, const char *@var{executable}, char * const *@var{argv}, const char *@var{outname}, const char *@var{errname}, int *@var{err})\n \n Execute one program in a pipeline.  On success this returns\n@@ -861,7 +924,7 @@ value, or to 0 if there is no relevant @code{errno}.\n \n @end deftypefn\n \n-@c pexecute.txh:187\n+@c pexecute.txh:249\n @deftypefn Extension int pexecute (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int flags)\n \n This is the old interface to execute one or more programs.  It is\n@@ -889,7 +952,7 @@ name is unset/removed.\n \n @end deftypefn\n \n-@c pexecute.txh:195\n+@c pexecute.txh:257\n @deftypefn Extension int pwait (int @var{pid}, int *@var{status}, int @var{flags})\n \n Another part of the old execution interface."}, {"sha": "ebe8c437590ed36816832377d17c394b0a3291be", "filename": "libiberty/pex-common.c", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpex-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpex-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-common.c?ref=8eff378c612e592a3cc9e161e382c57e105be6f5", "patch": "@@ -67,6 +67,7 @@ pex_init_common (int flags, const char *pname, const char *tempbase,\n   obj->status = NULL;\n   obj->time = NULL;\n   obj->number_waited = 0;\n+  obj->input_file = NULL;\n   obj->read_output = NULL;\n   obj->remove_count = 0;\n   obj->remove = NULL;\n@@ -161,6 +162,17 @@ pex_run (struct pex_obj *obj, int flags, const char *executable,\n   outname = (char *) orig_outname;\n   outname_allocated = 0;\n \n+  /* If the user called pex_input_file, close the file now.  */\n+  if (obj->input_file)\n+    {\n+      if (fclose (obj->input_file) == EOF)\n+        {\n+          errmsg = \"closing pipeline input file\";\n+          goto error_exit;\n+        }\n+      obj->input_file = NULL;\n+    }\n+\n   /* Set IN.  */\n \n   if (obj->next_input_name != NULL)\n@@ -307,6 +319,87 @@ pex_run (struct pex_obj *obj, int flags, const char *executable,\n   return errmsg;\n }\n \n+/* Return a FILE pointer for a temporary file to fill with input for\n+   the pipeline.  */\n+FILE *\n+pex_input_file (struct pex_obj *obj, int flags, const char *in_name)\n+{\n+  char *name = (char *) in_name;\n+  FILE *f;\n+\n+  /* This must be called before the first pipeline stage is run, and\n+     there must not have been any other input selected.  */\n+  if (obj->count != 0\n+      || (obj->next_input >= 0 && obj->next_input != STDIN_FILE_NO)\n+      || obj->next_input_name)\n+    {\n+      errno = EINVAL;\n+      return NULL;\n+    }\n+\n+  name = temp_file (obj, flags, name);\n+  if (! name)\n+    return NULL;\n+\n+  f = fopen (name, (flags & PEX_BINARY_OUTPUT) ? \"wb\" : \"w\");\n+  if (! f)\n+    {\n+      free (name);\n+      return NULL;\n+    }\n+\n+  obj->input_file = f;\n+  obj->next_input_name = name;\n+  obj->next_input_name_allocated = (name != in_name);\n+\n+  return f;\n+}\n+\n+/* Return a stream for a pipe connected to the standard input of the\n+   first stage of the pipeline.  */\n+FILE *\n+pex_input_pipe (struct pex_obj *obj, int binary)\n+{\n+  int p[2];\n+  FILE *f;\n+\n+  /* You must call pex_input_pipe before the first pex_run or pex_one.  */\n+  if (obj->count > 0)\n+    goto usage_error;\n+\n+  /* You must be using pipes.  Implementations that don't support\n+     pipes clear this flag before calling pex_init_common.  */\n+  if (! (obj->flags & PEX_USE_PIPES))\n+    goto usage_error;\n+\n+  /* If we have somehow already selected other input, that's a\n+     mistake.  */\n+  if ((obj->next_input >= 0 && obj->next_input != STDIN_FILE_NO)\n+      || obj->next_input_name)\n+    goto usage_error;\n+\n+  if (obj->funcs->pipe (obj, p, binary != 0) < 0)\n+    return NULL;\n+\n+  f = obj->funcs->fdopenw (obj, p[WRITE_PORT], binary != 0);\n+  if (! f)\n+    {\n+      int saved_errno = errno;\n+      obj->funcs->close (obj, p[READ_PORT]);\n+      obj->funcs->close (obj, p[WRITE_PORT]);\n+      errno = saved_errno;\n+      return NULL;\n+    }\n+\n+  obj->next_input = p[READ_PORT];\n+\n+  return f;\n+\n+ usage_error:\n+  errno = EINVAL;\n+  return NULL;\n+}\n+\n /* Return a FILE pointer for the output of the last program\n    executed.  */\n "}, {"sha": "8ded138148c7aa11c72a6d33714ae7300780996f", "filename": "libiberty/pex-common.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpex-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpex-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-common.h?ref=8eff378c612e592a3cc9e161e382c57e105be6f5", "patch": "@@ -69,6 +69,8 @@ struct pex_obj\n   struct pex_time *time;\n   /* Number of children we have already waited for.  */\n   int number_waited;\n+  /* FILE created by pex_input_file.  */\n+  FILE *input_file;\n   /* FILE created by pex_read_output.  */\n   FILE *read_output;\n   /* Number of temporary files to remove.  */\n@@ -121,6 +123,11 @@ struct pex_funcs\n      PEX_USE_PIPES is set).  If BINARY is non-zero, open in binary\n      mode.  Return pointer on success, NULL on error.  */\n   FILE * (*fdopenr) (struct pex_obj *, int /* fd */, int /* binary */);\n+  /* Get a FILE pointer to write to the file descriptor FD (only\n+     called if PEX_USE_PIPES is set).  If BINARY is non-zero, open in\n+     binary mode.  Arrange for FD not to be inherited by the child\n+     processes.  Return pointer on success, NULL on error.  */\n+  FILE * (*fdopenw) (struct pex_obj *, int /* fd */, int /* binary */);\n   /* Free any system dependent data associated with OBJ.  May be\n      NULL if there is nothing to do.  */\n   void (*cleanup) (struct pex_obj *);"}, {"sha": "17fbf2cc7e4406205068bbdb68da71dd0e065c47", "filename": "libiberty/pex-djgpp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpex-djgpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpex-djgpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-djgpp.c?ref=8eff378c612e592a3cc9e161e382c57e105be6f5", "patch": "@@ -62,6 +62,7 @@ const struct pex_funcs funcs =\n   pex_djgpp_wait,\n   NULL, /* pipe */\n   NULL, /* fdopenr */\n+  NULL, /* fdopenw */\n   NULL  /* cleanup */\n };\n "}, {"sha": "db22337aa2afcd82fe20c3af5cbbbc76120bdbb6", "filename": "libiberty/pex-msdos.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpex-msdos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpex-msdos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-msdos.c?ref=8eff378c612e592a3cc9e161e382c57e105be6f5", "patch": "@@ -73,6 +73,7 @@ const struct pex_funcs funcs =\n   pex_msdos_wait,\n   NULL, /* pipe */\n   NULL, /* fdopenr */\n+  NULL, /* fdopenw */\n   pex_msdos_cleanup\n };\n "}, {"sha": "c92a429797128c4ba36aff5676649eeded39da47", "filename": "libiberty/pex-unix.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpex-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpex-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-unix.c?ref=8eff378c612e592a3cc9e161e382c57e105be6f5", "patch": "@@ -277,6 +277,7 @@ static int pex_unix_wait (struct pex_obj *, long, int *, struct pex_time *,\n \t\t\t  int, const char **, int *);\n static int pex_unix_pipe (struct pex_obj *, int *, int);\n static FILE *pex_unix_fdopenr (struct pex_obj *, int, int);\n+static FILE *pex_unix_fdopenw (struct pex_obj *, int, int);\n static void pex_unix_cleanup (struct pex_obj *);\n \n /* The list of functions we pass to the common routines.  */\n@@ -290,6 +291,7 @@ const struct pex_funcs funcs =\n   pex_unix_wait,\n   pex_unix_pipe,\n   pex_unix_fdopenr,\n+  pex_unix_fdopenw,\n   pex_unix_cleanup\n };\n \n@@ -495,6 +497,15 @@ pex_unix_fdopenr (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,\n   return fdopen (fd, \"r\");\n }\n \n+static FILE *\n+pex_unix_fdopenw (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,\n+\t\t  int binary ATTRIBUTE_UNUSED)\n+{\n+  if (fcntl (fd, F_SETFD, FD_CLOEXEC) < 0)\n+    return NULL;\n+  return fdopen (fd, \"w\");\n+}\n+\n static void\n pex_unix_cleanup (struct pex_obj *obj ATTRIBUTE_UNUSED)\n {"}, {"sha": "046f393c6d9f7a9aad19b73e89b3860d6931557f", "filename": "libiberty/pex-win32.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpex-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpex-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-win32.c?ref=8eff378c612e592a3cc9e161e382c57e105be6f5", "patch": "@@ -83,6 +83,7 @@ static int pex_win32_wait (struct pex_obj *, long, int *,\n \t\t\t   struct pex_time *, int, const char **, int *);\n static int pex_win32_pipe (struct pex_obj *, int *, int);\n static FILE *pex_win32_fdopenr (struct pex_obj *, int, int);\n+static FILE *pex_win32_fdopenw (struct pex_obj *, int, int);\n \n /* The list of functions we pass to the common routines.  */\n \n@@ -95,6 +96,7 @@ const struct pex_funcs funcs =\n   pex_win32_wait,\n   pex_win32_pipe,\n   pex_win32_fdopenr,\n+  pex_win32_fdopenw,\n   NULL /* cleanup */\n };\n \n@@ -766,6 +768,18 @@ pex_win32_fdopenr (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,\n   return fdopen (fd, binary ? \"rb\" : \"r\");\n }\n \n+static FILE *\n+pex_win32_fdopenw (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,\n+\t\t   int binary)\n+{\n+  HANDLE h = (HANDLE) _get_osfhandle (fd);\n+  if (h == INVALID_HANDLE_VALUE)\n+    return NULL;\n+  if (! SetHandleInformation (h, HANDLE_FLAG_INHERIT, 0))\n+    return NULL;\n+  return fdopen (fd, binary ? \"wb\" : \"w\");\n+}\n+\n #ifdef MAIN\n #include <stdio.h>\n "}, {"sha": "7d45576eecea9f9fc7797e63538293d8376d0383", "filename": "libiberty/pexecute.txh", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpexecute.txh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eff378c612e592a3cc9e161e382c57e105be6f5/libiberty%2Fpexecute.txh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpexecute.txh?ref=8eff378c612e592a3cc9e161e382c57e105be6f5", "patch": "@@ -1,3 +1,4 @@\n+@c -*- mode: texinfo -*-\n @deftypefn Extension {struct pex_obj *} pex_init (int @var{flags}, const char *@var{pname}, const char *@var{tempbase})\n \n Prepare to execute one or more programs, with standard output of each\n@@ -129,6 +130,67 @@ value, or to 0 if there is no relevant @code{errno}.\n \n @end deftypefn\n \n+@deftypefn Extension {FILE *} pex_input_file (struct pex_obj *@var{obj}, int @var{flags}, const char *@var{in_name})\n+\n+Return a stream for a temporary file to pass to the first program in\n+the pipeline as input.\n+\n+The name of the input file is chosen according to the same rules\n+@code{pex_run} uses to choose output file names, based on\n+@var{in_name}, @var{obj} and the @code{PEX_SUFFIX} bit in @var{flags}.\n+\n+Don't call @code{fclose} on the returned stream; the first call to\n+@code{pex_run} closes it automatically.\n+\n+If @var{flags} includes @code{PEX_BINARY_OUTPUT}, open the stream in\n+binary mode; otherwise, open it in the default mode.  Including\n+@code{PEX_BINARY_OUTPUT} in @var{flags} has no effect on Unix.\n+@end deftypefn\n+\n+@deftypefn Extension {FILE *} pex_input_pipe (struct pex_obj *@var{obj}, int @var{binary})\n+\n+Return a stream @var{fp} for a pipe connected to the standard input of\n+the first program in the pipeline; @var{fp} is opened for writing.\n+You must have passed @code{PEX_USE_PIPES} to the @code{pex_init} call\n+that returned @var{obj}.\n+\n+You must close @var{fp} using @code{fclose} yourself when you have\n+finished writing data to the pipeline.\n+\n+The file descriptor underlying @var{fp} is marked not to be inherited\n+by child processes.\n+\n+On systems that do not support pipes, this function returns\n+@code{NULL}, and sets @code{errno} to @code{EINVAL}.  If you would\n+like to write code that is portable to all systems the @code{pex}\n+functions support, consider using @code{pex_input_file} instead.\n+\n+There are two opportunities for deadlock using\n+@code{pex_input_pipe}:\n+\n+@itemize @bullet\n+@item\n+Most systems' pipes can buffer only a fixed amount of data; a process\n+that writes to a full pipe blocks.  Thus, if you write to @file{fp}\n+before starting the first process, you run the risk of blocking when\n+there is no child process yet to read the data and allow you to\n+continue.  @code{pex_input_pipe} makes no promises about the\n+size of the pipe's buffer, so if you need to write any data at all\n+before starting the first process in the pipeline, consider using\n+@code{pex_input_file} instead.\n+\n+@item\n+Using @code{pex_input_pipe} and @code{pex_read_output} together\n+may also cause deadlock.  If the output pipe fills up, so that each\n+program in the pipeline is waiting for the next to read more data, and\n+you fill the input pipe by writing more data to @var{fp}, then there\n+is no way to make progress: the only process that could read data from\n+the output pipe is you, but you are blocked on the input pipe.\n+\n+@end itemize\n+\n+@end deftypefn\n+\n @deftypefn Extension {FILE *} pex_read_output (struct pex_obj *@var{obj}, int @var{binary})\n \n Returns a @code{FILE} pointer which may be used to read the standard"}]}