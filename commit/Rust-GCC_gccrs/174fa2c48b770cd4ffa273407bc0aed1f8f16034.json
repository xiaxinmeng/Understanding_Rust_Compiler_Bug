{"sha": "174fa2c48b770cd4ffa273407bc0aed1f8f16034", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc0ZmEyYzQ4Yjc3MGNkNGZmYTI3MzQwN2JjMGFlZDFmOGYxNjAzNA==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2001-01-13T14:43:27Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2001-01-13T14:43:27Z"}, "message": "reload1.c: Add prototype for replace_pseudos_in_call_usage.\n\n\t* reload1.c: Add prototype for replace_pseudos_in_call_usage.\n\n\t* regmove.c: Add prototype for replace_in_call_usage.\n\nFrom-SVN: r38985", "tree": {"sha": "e83bcb8b96de921cb58ad71532608fc2d3c3f2e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e83bcb8b96de921cb58ad71532608fc2d3c3f2e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/174fa2c48b770cd4ffa273407bc0aed1f8f16034", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174fa2c48b770cd4ffa273407bc0aed1f8f16034", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174fa2c48b770cd4ffa273407bc0aed1f8f16034", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174fa2c48b770cd4ffa273407bc0aed1f8f16034/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8121d2c3841bac793b1f1c1c3d028fae303de516", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8121d2c3841bac793b1f1c1c3d028fae303de516", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8121d2c3841bac793b1f1c1c3d028fae303de516"}], "stats": {"total": 50, "additions": 30, "deletions": 20}, "files": [{"sha": "79a84b9c87a3d7a74656a7974f43228ed5b78c53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174fa2c48b770cd4ffa273407bc0aed1f8f16034/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174fa2c48b770cd4ffa273407bc0aed1f8f16034/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=174fa2c48b770cd4ffa273407bc0aed1f8f16034", "patch": "@@ -1,3 +1,9 @@\n+2001-01-13  Andreas Jaeger  <aj@suse.de>\n+\n+\t* reload1.c: Add prototype for replace_pseudos_in_call_usage.\n+\n+\t* regmove.c: Add prototype for replace_in_call_usage.\n+\n 2001-01-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n         * cpplib.h (cpp_pool, mi_state, mi_ind, struct cpp_macro,\n@@ -87,7 +93,7 @@ Sat Jan 13 09:53:32 MET 2001  Jan Hubicka  <jh@suse.cz>\n         CPP_OPTION.\n         * scan-decls.c (scan_decls): Use return value of\n         cpp_pop_buffer rather than CPP_BUFFER.\n-\t\n+\n 2001-01-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n         * cppinit.c (cpp_handle_option): help_only is now part of the"}, {"sha": "e3b6cf9970ee9f050e782803bba0b546038eda33", "filename": "gcc/regmove.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174fa2c48b770cd4ffa273407bc0aed1f8f16034/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174fa2c48b770cd4ffa273407bc0aed1f8f16034/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=174fa2c48b770cd4ffa273407bc0aed1f8f16034", "patch": "@@ -62,6 +62,7 @@ static void flags_set_1 PARAMS ((rtx, rtx, void *));\n \n static int try_auto_increment PARAMS ((rtx, rtx, rtx, rtx, HOST_WIDE_INT, int));\n static int find_matches PARAMS ((rtx, struct match *));\n+static void replace_in_call_usage PARAMS ((rtx *, int, rtx, rtx));\n static int fixup_match_1 PARAMS ((rtx, rtx, rtx, rtx, rtx, int, int, int, FILE *))\n ;\n static int reg_is_remote_constant_p PARAMS ((rtx, rtx, rtx));\n@@ -138,7 +139,7 @@ try_auto_increment (insn, inc_insn, inc_insn_set, reg, increment, pre)\n \t    {\n \t      if (inc_insn_set)\n \t\tvalidate_change\n-\t\t  (inc_insn, \n+\t\t  (inc_insn,\n \t\t   &SET_SRC (inc_insn_set),\n \t\t   XEXP (SET_SRC (inc_insn_set), 0), 1);\n \t      validate_change (insn, &XEXP (use, 0),\n@@ -176,7 +177,7 @@ discover_flags_reg ()\n   tmp = gen_rtx_REG (word_mode, 10000);\n   tmp = gen_add3_insn (tmp, tmp, GEN_INT (2));\n \n-  /* If we get something that isn't a simple set, or a \n+  /* If we get something that isn't a simple set, or a\n      [(set ..) (clobber ..)], this whole function will go wrong.  */\n   if (GET_CODE (tmp) == SET)\n     return NULL_RTX;\n@@ -209,7 +210,7 @@ discover_flags_reg ()\n /* It is a tedious task identifying when the flags register is live and\n    when it is safe to optimize.  Since we process the instruction stream\n    multiple times, locate and record these live zones by marking the\n-   mode of the instructions -- \n+   mode of the instructions --\n \n    QImode is used on the instruction at which the flags becomes live.\n \n@@ -237,7 +238,7 @@ mark_flags_life_zones (flags)\n   else if (flags != cc0_rtx)\n     flags = pc_rtx;\n #endif\n-    \n+\n   /* Simple cases first: if no flags, clear all modes.  If confusing,\n      mark the entire function as being in a flags shadow.  */\n   if (flags == NULL_RTX || flags == pc_rtx)\n@@ -398,7 +399,7 @@ static int perhaps_ends_bb_p (insn)\n \n    Search forward to see if SRC dies before either it or DEST is modified,\n    but don't scan past the end of a basic block.  If so, we can replace SRC\n-   with DEST and let SRC die in INSN. \n+   with DEST and let SRC die in INSN.\n \n    This will reduce the number of registers live in that range and may enable\n    DEST to be tied to SRC, thus often saving one register in addition to a\n@@ -1202,7 +1203,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t      dst_class = reg_preferred_class (REGNO (dst));\n \t      if (! regclass_compatible_p (src_class, dst_class))\n \t\tcontinue;\n-\t  \n+\n \t      if (fixup_match_1 (insn, set, src, src_subreg, dst, pass,\n \t\t\t\t op_no, match_no,\n \t\t\t\t regmove_dump_file))\n@@ -1588,18 +1589,18 @@ replace_in_call_usage (loc, dst_reg, src, insn)\n \n   if (! x)\n     return;\n-  \n+\n   code = GET_CODE (x);\n   if (code == REG)\n     {\n       if (REGNO (x) != dst_reg)\n \treturn;\n-\t\n+\n       validate_change (insn, loc, src, 1);\n \n       return;\n     }\n-  \n+\n   /* Process each of our operands recursively.  */\n   fmt = GET_RTX_FORMAT (code);\n   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n@@ -1685,7 +1686,7 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n       if (GET_CODE (p) == CALL_INSN)\n \treplace_in_call_usage (& CALL_INSN_FUNCTION_USAGE (p),\n \t\t\t       REGNO (dst), src, p);\n-\t  \n+\n       /* ??? We can't scan past the end of a basic block without updating\n \t the register lifetime info (REG_DEAD/basic_block_live_at_start).  */\n       if (perhaps_ends_bb_p (p))\n@@ -2055,7 +2056,7 @@ stable_and_no_regs_but_for_p (x, src, dst)\n     }\n }\n \f\n-/* Track stack adjustments and stack memory references.  Attempt to \n+/* Track stack adjustments and stack memory references.  Attempt to\n    reduce the number of stack adjustments by back-propogating across\n    the memory references.\n \n@@ -2094,7 +2095,7 @@ static struct csa_memlist *record_one_stack_memref\n static int try_apply_stack_adjustment\n   PARAMS ((rtx, struct csa_memlist *, HOST_WIDE_INT, HOST_WIDE_INT));\n static void combine_stack_adjustments_for_block PARAMS ((basic_block));\n-static int record_stack_memrefs \tPARAMS ((rtx *, void *));\n+static int record_stack_memrefs\tPARAMS ((rtx *, void *));\n \n \n /* Main entry point for stack adjustment combination.  */\n@@ -2301,7 +2302,7 @@ record_stack_memrefs (xp, data)\n \n /* Subroutine of combine_stack_adjustments, called for each basic block.  */\n \n-static void \n+static void\n combine_stack_adjustments_for_block (bb)\n      basic_block bb;\n {\n@@ -2423,7 +2424,7 @@ combine_stack_adjustments_for_block (bb)\n \t}\n       memlist = data.memlist;\n \n-      /* Otherwise, we were not able to process the instruction. \n+      /* Otherwise, we were not able to process the instruction.\n \t Do not continue collecting data across such a one.  */\n       if (last_sp_set\n \t  && (GET_CODE (insn) == CALL_INSN"}, {"sha": "a9da6dd5a7f93f50d510849f9a8c8f94272ebac1", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174fa2c48b770cd4ffa273407bc0aed1f8f16034/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174fa2c48b770cd4ffa273407bc0aed1f8f16034/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=174fa2c48b770cd4ffa273407bc0aed1f8f16034", "patch": "@@ -370,6 +370,9 @@ static int (*offsets_at)[NUM_ELIMINABLE_REGS];\n \n static int num_labels;\n \f\n+static void replace_pseudos_in_call_usage\tPARAMS((rtx *,\n+\t\t\t\t\t\t\tenum machine_mode,\n+\t\t\t\t\t\t\trtx));\n static void maybe_fix_stack_asms\tPARAMS ((void));\n static void copy_reloads\t\tPARAMS ((struct insn_chain *));\n static void calculate_needs_all_insns\tPARAMS ((int));\n@@ -381,7 +384,7 @@ static void delete_caller_save_insns\tPARAMS ((void));\n static void spill_failure\t\tPARAMS ((rtx, enum reg_class));\n static void count_spilled_pseudo\tPARAMS ((int, int, int));\n static void delete_dead_insn\t\tPARAMS ((rtx));\n-static void alter_reg  \t\t\tPARAMS ((int, int));\n+static void alter_reg\t\t\tPARAMS ((int, int));\n static void set_label_offsets\t\tPARAMS ((rtx, rtx, int));\n static void check_eliminable_occurrences\tPARAMS ((rtx));\n static void elimination_effects\t\tPARAMS ((rtx, enum machine_mode));\n@@ -594,7 +597,7 @@ replace_pseudos_in_call_usage (loc, mem_mode, usage)\n \n   if (! x)\n     return;\n-  \n+\n   code = GET_CODE (x);\n   if (code == REG)\n     {\n@@ -623,7 +626,7 @@ replace_pseudos_in_call_usage (loc, mem_mode, usage)\n       replace_pseudos_in_call_usage (& XEXP (x, 0), GET_MODE (x), usage);\n       return;\n     }\n-  \n+\n   /* Process each of our operands recursively.  */\n   fmt = GET_RTX_FORMAT (code);\n   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n@@ -5649,7 +5652,7 @@ choose_reload_regs (chain)\n \t\t RELOAD_FOR_OUTPUT_ADDRESS reload.  */\n \n \t      if (equiv != 0)\n-  \t\t{\n+\t\t{\n \t\t  if (regno_clobbered_p (regno, insn, rld[r].mode, 0))\n \t\t    switch (rld[r].when_needed)\n \t\t      {\n@@ -9187,7 +9190,7 @@ move2add_note_store (dst, set, data)\n \t  reg_offset[regno] = dst;\n \t}\n       return;\n-    } \n+    }\n   if (GET_CODE (dst) != REG)\n     return;\n "}]}