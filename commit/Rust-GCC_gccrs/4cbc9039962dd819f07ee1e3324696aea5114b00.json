{"sha": "4cbc9039962dd819f07ee1e3324696aea5114b00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNiYzkwMzk5NjJkZDgxOWYwN2VlMWUzMzI0Njk2YWVhNTExNGIwMA==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2013-01-29T21:40:51Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2013-01-29T21:40:51Z"}, "message": "re PR fortran/54107 ([F03] Memory hog with abstract interface)\n\n2013-01-29  Janus Weil  <janus@gcc.gnu.org>\n\t    Mikael Morin <mikael@gcc.gnu.org>\n\n\tPR fortran/54107\n\t* gfortran.h (gfc_component): Delete members 'formal' and 'formal_ns'.\n\t(gfc_copy_formal_args,gfc_copy_formal_args_ppc,gfc_expr_replace_symbols,\n\tgfc_expr_replace_comp): Delete.\n\t(gfc_sym_get_dummy_args): New prototype.\n\t* dependency.c (gfc_check_fncall_dependency): Use\n\t'gfc_sym_get_dummy_args'.\n\t* expr.c (gfc_is_constant_expr): Ditto.\n\t(replace_symbol,gfc_expr_replace_symbols,replace_comp,\n\tgfc_expr_replace_comp): Deleted.\n\t* frontend-passes.c (doloop_code,do_function): Use\n\t'gfc_sym_get_dummy_args'.\n\t* interface.c (gfc_check_operator_interface,gfc_compare_interfaces,\n\tgfc_procedure_use,gfc_ppc_use,gfc_arglist_matches_symbol,\n\tgfc_check_typebound_override): Ditto.\n\t* module.c (MOD_VERSION): Bump module version.\n\t(mio_component): Do not read/write 'formal' and 'formal_ns'.\n\t* resolve.c (resolve_procedure_interface,resolve_fl_derived0): Do not\n\tcopy formal args, but just keep a pointer to the interface.\n\t(resolve_function,resolve_call,resolve_typebound_generic_call,\n\tresolve_ppc_call,resolve_expr_ppc,generate_component_assignments,\n\tresolve_fl_procedure,gfc_resolve_finalizers,check_generic_tbp_ambiguity,\n\tresolve_typebound_procedure,check_uop_procedure): Use\n\t'gfc_sym_get_dummy_args'.\n\t* symbol.c (free_components): Do not free 'formal' and 'formal_ns'.\n\t(gfc_copy_formal_args,gfc_copy_formal_args_ppc): Deleted.\n\t(gfc_sym_get_dummy_args): New function.\n\t* trans-array.c (get_array_charlen,gfc_walk_elemental_function_args):\n\tUse 'gfc_sym_get_dummy_args'.\n\t* trans-decl.c (build_function_decl,create_function_arglist,\n\tbuild_entry_thunks,init_intent_out_dt,gfc_trans_deferred_vars,\n\tadd_argument_checking): Ditto.\n\t* trans-expr.c (gfc_map_fcn_formal_to_actual,gfc_conv_procedure_call,\n\tgfc_conv_statement_function): Ditto.\n\t* trans-stmt.c (gfc_conv_elemental_dependencies): Ditto.\n\t* trans-types.c (create_fn_spec,gfc_get_function_type): Ditto.\n\n\n2013-01-29  Janus Weil  <janus@gcc.gnu.org>\n\t    Mikael Morin <mikael@gcc.gnu.org>\n\n\tPR fortran/54107\n\t* gfortran.dg/proc_ptr_comp_36.f90: New.\n\nCo-Authored-By: Mikael Morin <mikael@gcc.gnu.org>\n\nFrom-SVN: r195562", "tree": {"sha": "8a5b65f0f6e388374cf3665d4df237dbe7704a75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a5b65f0f6e388374cf3665d4df237dbe7704a75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cbc9039962dd819f07ee1e3324696aea5114b00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cbc9039962dd819f07ee1e3324696aea5114b00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cbc9039962dd819f07ee1e3324696aea5114b00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cbc9039962dd819f07ee1e3324696aea5114b00/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6f2922e91928b5191a5c5f1b3a6b320712b5ce3"}], "stats": {"total": 503, "additions": 187, "deletions": 316}, "files": [{"sha": "6a42ba45c32d5285c4fad513fc2a4021f59e8a02", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -1,3 +1,43 @@\n+2013-01-29  Janus Weil  <janus@gcc.gnu.org>\n+\t    Mikael Morin <mikael@gcc.gnu.org>\n+\n+\tPR fortran/54107\n+\t* gfortran.h (gfc_component): Delete members 'formal' and 'formal_ns'.\n+\t(gfc_copy_formal_args,gfc_copy_formal_args_ppc,gfc_expr_replace_symbols,\n+\tgfc_expr_replace_comp): Delete.\n+\t(gfc_sym_get_dummy_args): New prototype.\n+\t* dependency.c (gfc_check_fncall_dependency): Use\n+\t'gfc_sym_get_dummy_args'.\n+\t* expr.c (gfc_is_constant_expr): Ditto.\n+\t(replace_symbol,gfc_expr_replace_symbols,replace_comp,\n+\tgfc_expr_replace_comp): Deleted.\n+\t* frontend-passes.c (doloop_code,do_function): Use\n+\t'gfc_sym_get_dummy_args'.\n+\t* interface.c (gfc_check_operator_interface,gfc_compare_interfaces,\n+\tgfc_procedure_use,gfc_ppc_use,gfc_arglist_matches_symbol,\n+\tgfc_check_typebound_override): Ditto.\n+\t* module.c (MOD_VERSION): Bump module version.\n+\t(mio_component): Do not read/write 'formal' and 'formal_ns'.\n+\t* resolve.c (resolve_procedure_interface,resolve_fl_derived0): Do not\n+\tcopy formal args, but just keep a pointer to the interface.\n+\t(resolve_function,resolve_call,resolve_typebound_generic_call,\n+\tresolve_ppc_call,resolve_expr_ppc,generate_component_assignments,\n+\tresolve_fl_procedure,gfc_resolve_finalizers,check_generic_tbp_ambiguity,\n+\tresolve_typebound_procedure,check_uop_procedure): Use\n+\t'gfc_sym_get_dummy_args'.\n+\t* symbol.c (free_components): Do not free 'formal' and 'formal_ns'.\n+\t(gfc_copy_formal_args,gfc_copy_formal_args_ppc): Deleted.\n+\t(gfc_sym_get_dummy_args): New function.\n+\t* trans-array.c (get_array_charlen,gfc_walk_elemental_function_args):\n+\tUse 'gfc_sym_get_dummy_args'.\n+\t* trans-decl.c (build_function_decl,create_function_arglist,\n+\tbuild_entry_thunks,init_intent_out_dt,gfc_trans_deferred_vars,\n+\tadd_argument_checking): Ditto.\n+\t* trans-expr.c (gfc_map_fcn_formal_to_actual,gfc_conv_procedure_call,\n+\tgfc_conv_statement_function): Ditto.\n+\t* trans-stmt.c (gfc_conv_elemental_dependencies): Ditto.\n+\t* trans-types.c (create_fn_spec,gfc_get_function_type): Ditto.\n+\n 2013-01-28  Tobias Burnus  <burnus@net-b.de>\n \t    Mikael Morin  <mikael@gcc.gnu.org>\n "}, {"sha": "e58bd227bdecaced330704134405894dfcbb1fab", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -822,7 +822,7 @@ gfc_check_fncall_dependency (gfc_expr *other, sym_intent intent,\n   gfc_formal_arglist *formal;\n   gfc_expr *expr;\n \n-  formal = fnsym ? fnsym->formal : NULL;\n+  formal = fnsym ? gfc_sym_get_dummy_args (fnsym) : NULL;\n   for (; actual; actual = actual->next, formal = formal ? formal->next : NULL)\n     {\n       expr = actual->expr;"}, {"sha": "3843c2e3c5a82f11ecbfa84a14adf9c4f9ff096f", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 1, "deletions": 67, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -934,7 +934,7 @@ gfc_is_constant_expr (gfc_expr *e)\n \t  && sym->attr.proc != PROC_INTERNAL\n \t  && sym->attr.proc != PROC_ST_FUNCTION\n \t  && sym->attr.proc != PROC_UNKNOWN\n-\t  && sym->formal == NULL)\n+\t  && gfc_sym_get_dummy_args (sym) == NULL)\n \treturn 1;\n \n       if (e->value.function.isym\n@@ -4301,72 +4301,6 @@ gfc_expr_check_typed (gfc_expr* e, gfc_namespace* ns, bool strict)\n }\n \n \n-/* Walk an expression tree and replace all dummy symbols by the corresponding\n-   symbol in the formal_ns of \"sym\". Needed for copying interfaces in PROCEDURE\n-   statements. The boolean return value is required by gfc_traverse_expr.  */\n-\n-static bool\n-replace_symbol (gfc_expr *expr, gfc_symbol *sym, int *i ATTRIBUTE_UNUSED)\n-{\n-  if ((expr->expr_type == EXPR_VARIABLE\n-       || (expr->expr_type == EXPR_FUNCTION\n-\t   && !gfc_is_intrinsic (expr->symtree->n.sym, 0, expr->where)))\n-      && expr->symtree->n.sym->ns == sym->ts.interface->formal_ns\n-      && expr->symtree->n.sym->attr.dummy)\n-    {\n-      gfc_symtree *root = sym->formal_ns ? sym->formal_ns->sym_root\n-\t\t\t\t\t : gfc_current_ns->sym_root;\n-      gfc_symtree *stree = gfc_find_symtree (root, expr->symtree->n.sym->name);\n-      gcc_assert (stree);\n-      stree->n.sym->attr = expr->symtree->n.sym->attr;\n-      expr->symtree = stree;\n-    }\n-  return false;\n-}\n-\n-void\n-gfc_expr_replace_symbols (gfc_expr *expr, gfc_symbol *dest)\n-{\n-  gfc_traverse_expr (expr, dest, &replace_symbol, 0);\n-}\n-\n-\n-/* The following is analogous to 'replace_symbol', and needed for copying\n-   interfaces for procedure pointer components. The argument 'sym' must formally\n-   be a gfc_symbol, so that the function can be passed to gfc_traverse_expr.\n-   However, it gets actually passed a gfc_component (i.e. the procedure pointer\n-   component in whose formal_ns the arguments have to be).  */\n-\n-static bool\n-replace_comp (gfc_expr *expr, gfc_symbol *sym, int *i ATTRIBUTE_UNUSED)\n-{\n-  gfc_component *comp;\n-  comp = (gfc_component *)sym;\n-  if ((expr->expr_type == EXPR_VARIABLE\n-       || (expr->expr_type == EXPR_FUNCTION\n-\t   && !gfc_is_intrinsic (expr->symtree->n.sym, 0, expr->where)))\n-      && expr->symtree->n.sym->ns == comp->ts.interface->formal_ns)\n-    {\n-      gfc_symtree *stree;\n-      gfc_namespace *ns = comp->formal_ns;\n-      /* Don't use gfc_get_symtree as we prefer to fail badly if we don't find\n-\t the symtree rather than create a new one (and probably fail later).  */\n-      stree = gfc_find_symtree (ns ? ns->sym_root : gfc_current_ns->sym_root,\n-\t\t      \t\texpr->symtree->n.sym->name);\n-      gcc_assert (stree);\n-      stree->n.sym->attr = expr->symtree->n.sym->attr;\n-      expr->symtree = stree;\n-    }\n-  return false;\n-}\n-\n-void\n-gfc_expr_replace_comp (gfc_expr *expr, gfc_component *dest)\n-{\n-  gfc_traverse_expr (expr, (gfc_symbol *)dest, &replace_comp, 0);\n-}\n-\n-\n bool\n gfc_ref_this_image (gfc_ref *ref)\n {"}, {"sha": "ead32f87882f3e61784f93b8a121d69b66592b3e", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -1447,7 +1447,7 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n       if (co->resolved_sym == NULL)\n \tbreak;\n \n-      f = co->resolved_sym->formal;\n+      f = gfc_sym_get_dummy_args (co->resolved_sym);\n \n       /* Withot a formal arglist, there is only unknown INTENT,\n \t which we don't check for.  */\n@@ -1516,7 +1516,7 @@ do_function (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n   if (expr->value.function.isym)\n     return 0;\n \n-  f = expr->symtree->n.sym->formal;\n+  f = gfc_sym_get_dummy_args (expr->symtree->n.sym);\n \n   /* Without a formal arglist, there is only unknown INTENT,\n      which we don't check for.  */"}, {"sha": "16751b43d29fdd606d6db69a08ee3dbcfd4ad928", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -974,8 +974,6 @@ typedef struct gfc_component\n   struct gfc_component *next;\n \n   /* Needed for procedure pointer components.  */\n-  struct gfc_formal_arglist *formal;\n-  struct gfc_namespace *formal_ns;\n   struct gfc_typebound_proc *tb;\n }\n gfc_component;\n@@ -2659,9 +2657,7 @@ gfc_symbol* gfc_get_ultimate_derived_super_type (gfc_symbol*);\n bool gfc_type_is_extension_of (gfc_symbol *, gfc_symbol *);\n bool gfc_type_compatible (gfc_typespec *, gfc_typespec *);\n \n-void gfc_copy_formal_args (gfc_symbol *, gfc_symbol *, ifsrc);\n void gfc_copy_formal_args_intr (gfc_symbol *, gfc_intrinsic_sym *);\n-void gfc_copy_formal_args_ppc (gfc_component *, gfc_symbol *, ifsrc);\n \n void gfc_free_finalizer (gfc_finalizer *el); /* Needed in resolve.c, too  */\n \n@@ -2670,6 +2666,7 @@ gfc_namespace* gfc_find_proc_namespace (gfc_namespace*);\n \n bool gfc_is_associate_pointer (gfc_symbol*);\n gfc_symbol * gfc_find_dt_in_generic (gfc_symbol *);\n+gfc_formal_arglist *gfc_sym_get_dummy_args (gfc_symbol *);\n \n /* intrinsic.c -- true if working in an init-expr, false otherwise.  */\n extern bool gfc_init_expr_flag;\n@@ -2784,8 +2781,6 @@ bool gfc_traverse_expr (gfc_expr *, gfc_symbol *,\n \t\t\tint);\n void gfc_expr_set_symbols_referenced (gfc_expr *);\n gfc_try gfc_expr_check_typed (gfc_expr*, gfc_namespace*, bool);\n-void gfc_expr_replace_symbols (gfc_expr *, gfc_symbol *);\n-void gfc_expr_replace_comp (gfc_expr *, gfc_component *);\n \n gfc_component * gfc_get_proc_ptr_comp (gfc_expr *);\n bool gfc_is_proc_ptr_comp (gfc_expr *);"}, {"sha": "fff8c39ad93108a53d294aaf96b63f3ccdbf10b1", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -616,7 +616,7 @@ gfc_check_operator_interface (gfc_symbol *sym, gfc_intrinsic_op op,\n   r1 = r2 = -1;\n   k1 = k2 = -1;\n \n-  for (formal = sym->formal; formal; formal = formal->next)\n+  for (formal = gfc_sym_get_dummy_args (sym); formal; formal = formal->next)\n     {\n       gfc_symbol *fsym = formal->sym;\n       if (fsym == NULL)\n@@ -662,6 +662,8 @@ gfc_check_operator_interface (gfc_symbol *sym, gfc_intrinsic_op op,\n      INTRINSIC_ASSIGN which should map to a subroutine.  */\n   if (op == INTRINSIC_ASSIGN)\n     {\n+      gfc_formal_arglist *dummy_args;\n+\n       if (!sym->attr.subroutine)\n \t{\n \t  gfc_error (\"Assignment operator interface at %L must be \"\n@@ -674,12 +676,13 @@ gfc_check_operator_interface (gfc_symbol *sym, gfc_intrinsic_op op,\n \t - First argument is a scalar and second an array,\n \t - Types and kinds do not conform, or\n \t - First argument is of derived type.  */\n-      if (sym->formal->sym->ts.type != BT_DERIVED\n-\t  && sym->formal->sym->ts.type != BT_CLASS\n+      dummy_args = gfc_sym_get_dummy_args (sym);\n+      if (dummy_args->sym->ts.type != BT_DERIVED\n+\t  && dummy_args->sym->ts.type != BT_CLASS\n \t  && (r2 == 0 || r1 == r2)\n-\t  && (sym->formal->sym->ts.type == sym->formal->next->sym->ts.type\n-\t      || (gfc_numeric_ts (&sym->formal->sym->ts)\n-\t\t  && gfc_numeric_ts (&sym->formal->next->sym->ts))))\n+\t  && (dummy_args->sym->ts.type == dummy_args->next->sym->ts.type\n+\t      || (gfc_numeric_ts (&dummy_args->sym->ts)\n+\t\t  && gfc_numeric_ts (&dummy_args->next->sym->ts))))\n \t{\n \t  gfc_error (\"Assignment operator interface at %L must not redefine \"\n \t\t     \"an INTRINSIC type assignment\", &sym->declared_at);\n@@ -1377,8 +1380,8 @@ gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n       || s2->attr.if_source == IFSRC_UNKNOWN)\n     return 1;\n \n-  f1 = s1->formal;\n-  f2 = s2->formal;\n+  f1 = gfc_sym_get_dummy_args (s1);\n+  f2 = gfc_sym_get_dummy_args (s2);\n \n   if (f1 == NULL && f2 == NULL)\n     return 1;\t\t\t/* Special case: No arguments.  */\n@@ -3107,6 +3110,8 @@ check_intents (gfc_formal_arglist *f, gfc_actual_arglist *a)\n gfc_try\n gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n {\n+  gfc_formal_arglist *dummy_args;\n+\n   /* Warn about calls with an implicit interface.  Special case\n      for calling a ISO_C_BINDING becase c_loc and c_funloc\n      are pseudo-unknown.  Additionally, warn about procedures not\n@@ -3202,14 +3207,16 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n       return SUCCESS;\n     }\n \n-  if (!compare_actual_formal (ap, sym->formal, 0, sym->attr.elemental, where))\n+  dummy_args = gfc_sym_get_dummy_args (sym);\n+\n+  if (!compare_actual_formal (ap, dummy_args, 0, sym->attr.elemental, where))\n     return FAILURE;\n \n-  if (check_intents (sym->formal, *ap) == FAILURE)\n+  if (check_intents (dummy_args, *ap) == FAILURE)\n     return FAILURE;\n \n   if (gfc_option.warn_aliasing)\n-    check_some_aliasing (sym->formal, *ap);\n+    check_some_aliasing (dummy_args, *ap);\n \n   return SUCCESS;\n }\n@@ -3222,7 +3229,6 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n void\n gfc_ppc_use (gfc_component *comp, gfc_actual_arglist **ap, locus *where)\n {\n-\n   /* Warn about calls with an implicit interface.  Special case\n      for calling a ISO_C_BINDING becase c_loc and c_funloc\n      are pseudo-unknown.  */\n@@ -3250,12 +3256,13 @@ gfc_ppc_use (gfc_component *comp, gfc_actual_arglist **ap, locus *where)\n       return;\n     }\n \n-  if (!compare_actual_formal (ap, comp->formal, 0, comp->attr.elemental, where))\n+  if (!compare_actual_formal (ap, comp->ts.interface->formal, 0,\n+\t\t\t      comp->attr.elemental, where))\n     return;\n \n-  check_intents (comp->formal, *ap);\n+  check_intents (comp->ts.interface->formal, *ap);\n   if (gfc_option.warn_aliasing)\n-    check_some_aliasing (comp->formal, *ap);\n+    check_some_aliasing (comp->ts.interface->formal, *ap);\n }\n \n \n@@ -3266,16 +3273,19 @@ gfc_ppc_use (gfc_component *comp, gfc_actual_arglist **ap, locus *where)\n bool\n gfc_arglist_matches_symbol (gfc_actual_arglist** args, gfc_symbol* sym)\n {\n+  gfc_formal_arglist *dummy_args;\n   bool r;\n \n   gcc_assert (sym->attr.flavor == FL_PROCEDURE);\n \n+  dummy_args = gfc_sym_get_dummy_args (sym);\n+\n   r = !sym->attr.elemental;\n-  if (compare_actual_formal (args, sym->formal, r, !r, NULL))\n+  if (compare_actual_formal (args, dummy_args, r, !r, NULL))\n     {\n-      check_intents (sym->formal, *args);\n+      check_intents (dummy_args, *args);\n       if (gfc_option.warn_aliasing)\n-\tcheck_some_aliasing (sym->formal, *args);\n+\tcheck_some_aliasing (dummy_args, *args);\n       return true;\n     }\n \n@@ -4080,8 +4090,9 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n   if (!old->n.tb->nopass && !old->n.tb->pass_arg)\n     old_pass_arg = 1;\n   argpos = 1;\n-  for (proc_formal = proc_target->formal, old_formal = old_target->formal;\n-       proc_formal && old_formal;\n+  proc_formal = gfc_sym_get_dummy_args (proc_target);\n+  old_formal = gfc_sym_get_dummy_args (old_target);\n+  for ( ; proc_formal && old_formal;\n        proc_formal = proc_formal->next, old_formal = old_formal->next)\n     {\n       if (proc->n.tb->pass_arg"}, {"sha": "1b38555842484391cd7fa26f7829bdbc2f4a4978", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -80,7 +80,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Don't put any single quote (') in MOD_VERSION, \n    if yout want it to be recognized.  */\n-#define MOD_VERSION \"9\"\n+#define MOD_VERSION \"10\"\n \n \n /* Structure that describes a position within a module file.  */\n@@ -2573,7 +2573,6 @@ mio_component (gfc_component *c, int vtype)\n {\n   pointer_info *p;\n   int n;\n-  gfc_formal_arglist *formal;\n \n   mio_lparen ();\n \n@@ -2606,32 +2605,7 @@ mio_component (gfc_component *c, int vtype)\n     mio_expr (&c->initializer);\n \n   if (c->attr.proc_pointer)\n-    {\n-      if (iomode == IO_OUTPUT)\n-\t{\n-\t  formal = c->formal;\n-\t  while (formal && !formal->sym)\n-\t    formal = formal->next;\n-\n-\t  if (formal)\n-\t    mio_namespace_ref (&formal->sym->ns);\n-\t  else\n-\t    mio_namespace_ref (&c->formal_ns);\n-\t}\n-      else\n-\t{\n-\t  mio_namespace_ref (&c->formal_ns);\n-\t  /* TODO: if (c->formal_ns)\n-\t    {\n-\t      c->formal_ns->proc_name = c;\n-\t      c->refs++;\n-\t    }*/\n-\t}\n-\n-      mio_formal_arglist (&c->formal);\n-\n-      mio_typebound_proc (&c->tb);\n-    }\n+    mio_typebound_proc (&c->tb);\n \n   mio_rparen ();\n }"}, {"sha": "d6bae43cf849be1d7cec7e7a384090da4de8e1cd", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 39, "deletions": 49, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -223,7 +223,6 @@ resolve_procedure_interface (gfc_symbol *sym)\n       sym->ts.interface = ifc;\n       sym->attr.function = ifc->attr.function;\n       sym->attr.subroutine = ifc->attr.subroutine;\n-      gfc_copy_formal_args (sym, ifc, IFSRC_DECL);\n \n       sym->attr.allocatable = ifc->attr.allocatable;\n       sym->attr.pointer = ifc->attr.pointer;\n@@ -238,20 +237,10 @@ resolve_procedure_interface (gfc_symbol *sym)\n       sym->attr.class_ok = ifc->attr.class_ok;\n       /* Copy array spec.  */\n       sym->as = gfc_copy_array_spec (ifc->as);\n-      if (sym->as)\n-\t{\n-\t  int i;\n-\t  for (i = 0; i < sym->as->rank; i++)\n-\t    {\n-\t      gfc_expr_replace_symbols (sym->as->lower[i], sym);\n-\t      gfc_expr_replace_symbols (sym->as->upper[i], sym);\n-\t    }\n-\t}\n       /* Copy char length.  */\n       if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)\n \t{\n \t  sym->ts.u.cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);\n-\t  gfc_expr_replace_symbols (sym->ts.u.cl->length, sym);\n \t  if (sym->ts.u.cl->length && !sym->ts.u.cl->resolved\n \t      && gfc_resolve_expr (sym->ts.u.cl->length) == FAILURE)\n \t    return FAILURE;\n@@ -3141,7 +3130,8 @@ resolve_function (gfc_expr *expr)\n \n   if (expr->value.function.isym && expr->value.function.isym->inquiry)\n     inquiry_argument = true;\n-  no_formal_args = sym && is_external_proc (sym) && sym->formal == NULL;\n+  no_formal_args = sym && is_external_proc (sym)\n+  \t\t       && gfc_sym_get_dummy_args (sym) == NULL;\n \n   if (resolve_actual_arglist (expr->value.function.actual,\n \t\t\t      p, no_formal_args) == FAILURE)\n@@ -3826,7 +3816,8 @@ resolve_call (gfc_code *c)\n   if (csym)\n     ptype = csym->attr.proc;\n \n-  no_formal_args = csym && is_external_proc (csym) && csym->formal == NULL;\n+  no_formal_args = csym && is_external_proc (csym)\n+\t\t\t&& gfc_sym_get_dummy_args (csym) == NULL;\n   if (resolve_actual_arglist (c->ext.actual, ptype,\n \t\t\t      no_formal_args) == FAILURE)\n     return FAILURE;\n@@ -6018,7 +6009,8 @@ resolve_typebound_generic_call (gfc_expr* e, const char **name)\n \t\t\t\t\t  g->specific->pass_arg);\n \t    }\n \t  resolve_actual_arglist (args, target->attr.proc,\n-\t\t\t\t  is_external_proc (target) && !target->formal);\n+\t\t\t\t  is_external_proc (target)\n+\t\t\t\t  && gfc_sym_get_dummy_args (target) == NULL);\n \n \t  /* Check if this arglist matches the formal.  */\n \t  matches = gfc_arglist_matches_symbol (&args, target);\n@@ -6438,7 +6430,7 @@ resolve_ppc_call (gfc_code* c)\n   c->ext.actual = c->expr1->value.compcall.actual;\n \n   if (resolve_actual_arglist (c->ext.actual, comp->attr.proc,\n-\t\t\t      comp->formal == NULL) == FAILURE)\n+\t\t\t      !(comp->ts.interface && comp->ts.interface->formal)) == FAILURE)\n     return FAILURE;\n \n   gfc_ppc_use (comp, &c->expr1->value.compcall.actual, &c->expr1->where);\n@@ -6472,7 +6464,7 @@ resolve_expr_ppc (gfc_expr* e)\n     return FAILURE;\n \n   if (resolve_actual_arglist (e->value.function.actual, comp->attr.proc,\n-\t\t\t      comp->formal == NULL) == FAILURE)\n+\t\t\t      !(comp->ts.interface && comp->ts.interface->formal)) == FAILURE)\n     return FAILURE;\n \n   if (update_ppc_arglist (e) == FAILURE)\n@@ -9963,6 +9955,7 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n \n       if (this_code->op == EXEC_ASSIGN_CALL)\n \t{\n+\t  gfc_formal_arglist *dummy_args;\n \t  gfc_symbol *rsym;\n \t  /* Check that there is a typebound defined assignment.  If not,\n \t     then this must be a module defined assignment.  We cannot\n@@ -9981,8 +9974,9 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n \t  /* If the first argument of the subroutine has intent INOUT\n \t     a temporary must be generated and used instead.  */\n \t  rsym = this_code->resolved_sym;\n-\t  if (rsym->formal\n-\t      && rsym->formal->sym->attr.intent == INTENT_INOUT)\n+\t  dummy_args = gfc_sym_get_dummy_args (rsym);\n+\t  if (dummy_args\n+\t      && dummy_args->sym->attr.intent == INTENT_INOUT)\n \t    {\n \t      gfc_code *temp_code;\n \t      inout = true;\n@@ -11414,7 +11408,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n     {\n       gfc_interface *iface;\n \n-      for (arg = sym->formal; arg; arg = arg->next)\n+      for (arg = gfc_sym_get_dummy_args (sym); arg; arg = arg->next)\n \t{\n \t  if (arg->sym\n \t      && arg->sym->ts.type == BT_DERIVED\n@@ -11436,7 +11430,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t PRIVATE to the containing module.  */\n       for (iface = sym->generic; iface; iface = iface->next)\n \t{\n-\t  for (arg = iface->sym->formal; arg; arg = arg->next)\n+\t  for (arg = gfc_sym_get_dummy_args (iface->sym); arg; arg = arg->next)\n \t    {\n \t      if (arg->sym\n \t\t  && arg->sym->ts.type == BT_DERIVED\n@@ -11460,7 +11454,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t PRIVATE to the containing module.  */\n       for (iface = sym->generic; iface; iface = iface->next)\n \t{\n-\t  for (arg = iface->sym->formal; arg; arg = arg->next)\n+\t  for (arg = gfc_sym_get_dummy_args (iface->sym); arg; arg = arg->next)\n \t    {\n \t      if (arg->sym\n \t\t  && arg->sym->ts.type == BT_DERIVED\n@@ -11580,7 +11574,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n           sym->ts.is_c_interop = 1;\n         }\n \n-      curr_arg = sym->formal;\n+      curr_arg = gfc_sym_get_dummy_args (sym);\n       while (curr_arg != NULL)\n         {\n           /* Skip implicitly typed dummy args here.  */\n@@ -11667,6 +11661,7 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n   prev_link = &derived->f2k_derived->finalizers;\n   for (list = derived->f2k_derived->finalizers; list; list = *prev_link)\n     {\n+      gfc_formal_arglist *dummy_args;\n       gfc_symbol* arg;\n       gfc_finalizer* i;\n       int my_rank;\n@@ -11687,13 +11682,14 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n \t}\n \n       /* We should have exactly one argument.  */\n-      if (!list->proc_sym->formal || list->proc_sym->formal->next)\n+      dummy_args = gfc_sym_get_dummy_args (list->proc_sym);\n+      if (!dummy_args || dummy_args->next)\n \t{\n \t  gfc_error (\"FINAL procedure at %L must have exactly one argument\",\n \t\t     &list->where);\n \t  goto error;\n \t}\n-      arg = list->proc_sym->formal->sym;\n+      arg = dummy_args->sym;\n \n       /* This argument must be of our type.  */\n       if (arg->ts.type != BT_DERIVED || arg->ts.u.derived != derived)\n@@ -11745,11 +11741,14 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n       my_rank = (arg->as ? arg->as->rank : 0);\n       for (i = list->next; i; i = i->next)\n \t{\n+\t  gfc_formal_arglist *dummy_args;\n+\n \t  /* Argument list might be empty; that is an error signalled earlier,\n \t     but we nevertheless continued resolving.  */\n-\t  if (i->proc_sym->formal)\n+\t  dummy_args = gfc_sym_get_dummy_args (i->proc_sym);\n+\t  if (dummy_args)\n \t    {\n-\t      gfc_symbol* i_arg = i->proc_sym->formal->sym;\n+\t      gfc_symbol* i_arg = dummy_args->sym;\n \t      const int i_rank = (i_arg->as ? i_arg->as->rank : 0);\n \t      if (i_rank == my_rank)\n \t\t{\n@@ -11835,13 +11834,13 @@ check_generic_tbp_ambiguity (gfc_tbp_generic* t1, gfc_tbp_generic* t2,\n   else if (t1->specific->pass_arg)\n     pass1 = t1->specific->pass_arg;\n   else\n-    pass1 = t1->specific->u.specific->n.sym->formal->sym->name;\n+    pass1 = gfc_sym_get_dummy_args (t1->specific->u.specific->n.sym)->sym->name;\n   if (t2->specific->nopass)\n     pass2 = NULL;\n   else if (t2->specific->pass_arg)\n     pass2 = t2->specific->pass_arg;\n   else\n-    pass2 = t2->specific->u.specific->n.sym->formal->sym->name;\n+    pass2 = gfc_sym_get_dummy_args (t2->specific->u.specific->n.sym)->sym->name;\n   if (gfc_compare_interfaces (sym1, sym2, sym2->name, !t1->is_operator, 0,\n \t\t\t      NULL, 0, pass1, pass2))\n     {\n@@ -12205,16 +12204,19 @@ resolve_typebound_procedure (gfc_symtree* stree)\n      from a .mod file.  */\n   if (!stree->n.tb->nopass && stree->n.tb->pass_arg_num == 0)\n     {\n+      gfc_formal_arglist *dummy_args;\n+\n+      dummy_args = gfc_sym_get_dummy_args (proc);\n       if (stree->n.tb->pass_arg)\n \t{\n-\t  gfc_formal_arglist* i;\n+\t  gfc_formal_arglist *i;\n \n \t  /* If an explicit passing argument name is given, walk the arg-list\n \t     and look for it.  */\n \n \t  me_arg = NULL;\n \t  stree->n.tb->pass_arg_num = 1;\n-\t  for (i = proc->formal; i; i = i->next)\n+\t  for (i = dummy_args; i; i = i->next)\n \t    {\n \t      if (!strcmp (i->sym->name, stree->n.tb->pass_arg))\n \t\t{\n@@ -12238,13 +12240,13 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \t  /* Otherwise, take the first one; there should in fact be at least\n \t     one.  */\n \t  stree->n.tb->pass_arg_num = 1;\n-\t  if (!proc->formal)\n+\t  if (!dummy_args)\n \t    {\n \t      gfc_error (\"Procedure '%s' with PASS at %L must have at\"\n \t\t\t \" least one argument\", proc->name, &where);\n \t      goto error;\n \t    }\n-\t  me_arg = proc->formal->sym;\n+\t  me_arg = dummy_args->sym;\n \t}\n \n       /* Now check that the argument-type matches and the passed-object\n@@ -12623,30 +12625,18 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t      c->ts.interface = ifc;\n \t      c->attr.function = ifc->attr.function;\n \t      c->attr.subroutine = ifc->attr.subroutine;\n-\t      gfc_copy_formal_args_ppc (c, ifc, IFSRC_DECL);\n \n \t      c->attr.pure = ifc->attr.pure;\n \t      c->attr.elemental = ifc->attr.elemental;\n \t      c->attr.recursive = ifc->attr.recursive;\n \t      c->attr.always_explicit = ifc->attr.always_explicit;\n \t      c->attr.ext_attr |= ifc->attr.ext_attr;\n-\t      /* Replace symbols in array spec.  */\n-\t      if (c->as)\n-\t\t{\n-\t\t  int i;\n-\t\t  for (i = 0; i < c->as->rank; i++)\n-\t\t    {\n-\t\t      gfc_expr_replace_comp (c->as->lower[i], c);\n-\t\t      gfc_expr_replace_comp (c->as->upper[i], c);\n-\t\t    }\n-\t\t}\n \t      /* Copy char length.  */\n \t      if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)\n \t\t{\n \t\t  gfc_charlen *cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);\n-\t\t  gfc_expr_replace_comp (cl->length, c);\n \t\t  if (cl->length && !cl->resolved\n-\t\t\t&& gfc_resolve_expr (cl->length) == FAILURE)\n+\t\t      && gfc_resolve_expr (cl->length) == FAILURE)\n \t\t    return FAILURE;\n \t\t  c->ts.u.cl = cl;\n \t\t}\n@@ -12674,7 +12664,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \n \t      me_arg = NULL;\n \t      c->tb->pass_arg_num = 1;\n-\t      for (i = c->formal; i; i = i->next)\n+\t      for (i = c->ts.interface->formal; i; i = i->next)\n \t\t{\n \t\t  if (!strcmp (i->sym->name, c->tb->pass_arg))\n \t\t    {\n@@ -12698,15 +12688,15 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t      /* Otherwise, take the first one; there should in fact be at least\n \t\tone.  */\n \t      c->tb->pass_arg_num = 1;\n-\t      if (!c->formal)\n+\t      if (!c->ts.interface->formal)\n \t\t{\n \t\t  gfc_error (\"Procedure pointer component '%s' with PASS at %L \"\n \t\t\t     \"must have at least one argument\",\n \t\t\t     c->name, &c->loc);\n \t\t  c->tb->error = 1;\n \t\t  return FAILURE;\n \t\t}\n-\t      me_arg = c->formal->sym;\n+\t      me_arg = c->ts.interface->formal->sym;\n \t    }\n \n \t  /* Now check that the argument-type matches.  */\n@@ -14793,7 +14783,7 @@ check_uop_procedure (gfc_symbol *sym, locus where)\n       return FAILURE;\n     }\n \n-  formal = sym->formal;\n+  formal = gfc_sym_get_dummy_args (sym);\n   if (!formal || !formal->sym)\n     {\n       gfc_error (\"User operator procedure '%s' at %L must have at least \""}, {"sha": "acfebc558312c7c1ce2e3dd73ffc60556406bd56", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 17, "deletions": 120, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -2077,9 +2077,6 @@ free_components (gfc_component *p)\n       gfc_free_array_spec (p->as);\n       gfc_free_expr (p->initializer);\n \n-      gfc_free_formal_arglist (p->formal);\n-      gfc_free_namespace (p->formal_ns);\n-\n       free (p);\n     }\n }\n@@ -4128,64 +4125,6 @@ add_proc_interface (gfc_symbol *sym, ifsrc source, gfc_formal_arglist *formal)\n    declaration statement (see match_proc_decl()) to create the formal\n    args based on the args of a given named interface.  */\n \n-void\n-gfc_copy_formal_args (gfc_symbol *dest, gfc_symbol *src, ifsrc if_src)\n-{\n-  gfc_formal_arglist *head = NULL;\n-  gfc_formal_arglist *tail = NULL;\n-  gfc_formal_arglist *formal_arg = NULL;\n-  gfc_formal_arglist *curr_arg = NULL;\n-  gfc_formal_arglist *formal_prev = NULL;\n-  /* Save current namespace so we can change it for formal args.  */\n-  gfc_namespace *parent_ns = gfc_current_ns;\n-\n-  /* Create a new namespace, which will be the formal ns (namespace\n-     of the formal args).  */\n-  gfc_current_ns = gfc_get_namespace (parent_ns, 0);\n-  gfc_current_ns->proc_name = dest;\n-  dest->formal_ns = gfc_current_ns;\n-\n-  for (curr_arg = src->formal; curr_arg; curr_arg = curr_arg->next)\n-    {\n-      formal_arg = gfc_get_formal_arglist ();\n-      gfc_get_symbol (curr_arg->sym->name, gfc_current_ns, &(formal_arg->sym));\n-\n-      /* May need to copy more info for the symbol.  */\n-      formal_arg->sym->attr = curr_arg->sym->attr;\n-      formal_arg->sym->ts = curr_arg->sym->ts;\n-      formal_arg->sym->as = gfc_copy_array_spec (curr_arg->sym->as);\n-      gfc_copy_formal_args (formal_arg->sym, curr_arg->sym,\n-\t\t\t    curr_arg->sym->attr.if_source);\n-\n-      /* If this isn't the first arg, set up the next ptr.  For the\n-        last arg built, the formal_arg->next will never get set to\n-        anything other than NULL.  */\n-      if (formal_prev != NULL)\n-\tformal_prev->next = formal_arg;\n-      else\n-\tformal_arg->next = NULL;\n-\n-      formal_prev = formal_arg;\n-\n-      /* Add arg to list of formal args.  */\n-      add_formal_arg (&head, &tail, formal_arg, formal_arg->sym);\n-\n-      /* Validate changes.  */\n-      gfc_commit_symbol (formal_arg->sym);\n-    }\n-\n-  /* Add the interface to the symbol.  */\n-  add_proc_interface (dest, if_src, head);\n-\n-  /* Store the formal namespace information.  */\n-  if (dest->formal != NULL)\n-    /* The current ns should be that for the dest proc.  */\n-    dest->formal_ns = gfc_current_ns;\n-  /* Restore the current namespace to what it was on entry.  */\n-  gfc_current_ns = parent_ns;\n-}\n-\n-\n void\n gfc_copy_formal_args_intr (gfc_symbol *dest, gfc_intrinsic_sym *src)\n {\n@@ -4247,65 +4186,6 @@ gfc_copy_formal_args_intr (gfc_symbol *dest, gfc_intrinsic_sym *src)\n }\n \n \n-void\n-gfc_copy_formal_args_ppc (gfc_component *dest, gfc_symbol *src, ifsrc if_src)\n-{\n-  gfc_formal_arglist *head = NULL;\n-  gfc_formal_arglist *tail = NULL;\n-  gfc_formal_arglist *formal_arg = NULL;\n-  gfc_formal_arglist *curr_arg = NULL;\n-  gfc_formal_arglist *formal_prev = NULL;\n-  /* Save current namespace so we can change it for formal args.  */\n-  gfc_namespace *parent_ns = gfc_current_ns;\n-\n-  /* Create a new namespace, which will be the formal ns (namespace\n-     of the formal args).  */\n-  gfc_current_ns = gfc_get_namespace (parent_ns, 0);\n-  /* TODO: gfc_current_ns->proc_name = dest;*/\n-\n-  for (curr_arg = src->formal; curr_arg; curr_arg = curr_arg->next)\n-    {\n-      formal_arg = gfc_get_formal_arglist ();\n-      gfc_get_symbol (curr_arg->sym->name, gfc_current_ns, &(formal_arg->sym));\n-\n-      /* May need to copy more info for the symbol.  */\n-      formal_arg->sym->attr = curr_arg->sym->attr;\n-      formal_arg->sym->ts = curr_arg->sym->ts;\n-      formal_arg->sym->as = gfc_copy_array_spec (curr_arg->sym->as);\n-      gfc_copy_formal_args (formal_arg->sym, curr_arg->sym,\n-\t\t\t    curr_arg->sym->attr.if_source);\n-\n-      /* If this isn't the first arg, set up the next ptr.  For the\n-        last arg built, the formal_arg->next will never get set to\n-        anything other than NULL.  */\n-      if (formal_prev != NULL)\n-\tformal_prev->next = formal_arg;\n-      else\n-\tformal_arg->next = NULL;\n-\n-      formal_prev = formal_arg;\n-\n-      /* Add arg to list of formal args.  */\n-      add_formal_arg (&head, &tail, formal_arg, formal_arg->sym);\n-\n-      /* Validate changes.  */\n-      gfc_commit_symbol (formal_arg->sym);\n-    }\n-\n-  /* Add the interface to the symbol.  */\n-  gfc_free_formal_arglist (dest->formal);\n-  dest->formal = head;\n-  dest->attr.if_source = if_src;\n-\n-  /* Store the formal namespace information.  */\n-  if (dest->formal != NULL)\n-    /* The current ns should be that for the dest proc.  */\n-    dest->formal_ns = gfc_current_ns;\n-  /* Restore the current namespace to what it was on entry.  */\n-  gfc_current_ns = parent_ns;\n-}\n-\n-\n /* Builds the parameter list for the iso_c_binding procedure\n    c_f_pointer or c_f_procpointer.  The old_sym typically refers to a\n    generic version of either the c_f_pointer or c_f_procpointer\n@@ -4983,3 +4863,20 @@ gfc_find_dt_in_generic (gfc_symbol *sym)\n         break;\n   return intr ? intr->sym : NULL;\n }\n+\n+\n+/* Get the dummy arguments from a procedure symbol. If it has been declared\n+   via a PROCEDURE statement with a named interface, ts.interface will be set\n+   and the arguments need to be taken from there.  */\n+\n+gfc_formal_arglist *\n+gfc_sym_get_dummy_args (gfc_symbol *sym)\n+{\n+  gfc_formal_arglist *dummies;\n+\n+  dummies = sym->formal;\n+  if (dummies == NULL && sym->ts.interface != NULL)\n+    dummies = sym->ts.interface->formal;\n+\n+  return dummies;\n+}"}, {"sha": "3e658c0dd338c864409e6199902c142a5a8a9494", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -6282,7 +6282,7 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)\n       /* Map expressions involving the dummy arguments onto the actual\n \t argument expressions.  */\n       gfc_init_interface_mapping (&mapping);\n-      formal = expr->symtree->n.sym->formal;\n+      formal = gfc_sym_get_dummy_args (expr->symtree->n.sym);\n       arg = expr->value.function.actual;\n \n       /* Set se = NULL in the calls to the interface mapping, to suppress any\n@@ -8626,7 +8626,7 @@ gfc_walk_elemental_function_args (gfc_ss * ss, gfc_actual_arglist *arg,\n   tail = NULL;\n \n   if (proc_ifc)\n-    dummy_arg = proc_ifc->formal;\n+    dummy_arg = gfc_sym_get_dummy_args (proc_ifc);\n   else\n     dummy_arg = NULL;\n "}, {"sha": "1d0919dd4c1fdcc32e3785f8d53c9f8e5e5a24f9", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -1906,7 +1906,7 @@ build_function_decl (gfc_symbol * sym, bool global)\n     {\n       /* Look for alternate return placeholders.  */\n       int has_alternate_returns = 0;\n-      for (f = sym->formal; f; f = f->next)\n+      for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)\n \t{\n \t  if (f->sym == NULL)\n \t    {\n@@ -2074,11 +2074,11 @@ create_function_arglist (gfc_symbol * sym)\n     }\n \n   hidden_typelist = typelist;\n-  for (f = sym->formal; f; f = f->next)\n+  for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)\n     if (f->sym != NULL)\t/* Ignore alternate returns.  */\n       hidden_typelist = TREE_CHAIN (hidden_typelist);\n \n-  for (f = sym->formal; f; f = f->next)\n+  for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)\n     {\n       char name[GFC_MAX_SYMBOL_LEN + 2];\n \n@@ -2344,15 +2344,16 @@ build_entry_thunks (gfc_namespace * ns, bool global)\n \t    }\n \t}\n \n-      for (formal = ns->proc_name->formal; formal; formal = formal->next)\n+      for (formal = gfc_sym_get_dummy_args (ns->proc_name); formal;\n+\t   formal = formal->next)\n \t{\n \t  /* Ignore alternate returns.  */\n \t  if (formal->sym == NULL)\n \t    continue;\n \n \t  /* We don't have a clever way of identifying arguments, so resort to\n \t     a brute-force search.  */\n-\t  for (thunk_formal = thunk_sym->formal;\n+\t  for (thunk_formal = gfc_sym_get_dummy_args (thunk_sym);\n \t       thunk_formal;\n \t       thunk_formal = thunk_formal->next)\n \t    {\n@@ -2459,7 +2460,8 @@ build_entry_thunks (gfc_namespace * ns, bool global)\n       /* We share the symbols in the formal argument list with other entry\n \t points and the master function.  Clear them so that they are\n \t recreated for each function.  */\n-      for (formal = thunk_sym->formal; formal; formal = formal->next)\n+      for (formal = gfc_sym_get_dummy_args (thunk_sym); formal;\n+\t   formal = formal->next)\n \tif (formal->sym != NULL)  /* Ignore alternate returns.  */\n \t  {\n \t    formal->sym->backend_decl = NULL_TREE;\n@@ -3458,7 +3460,7 @@ init_intent_out_dt (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n   tree present;\n \n   gfc_init_block (&init);\n-  for (f = proc_sym->formal; f; f = f->next)\n+  for (f = gfc_sym_get_dummy_args (proc_sym); f; f = f->next)\n     if (f->sym && f->sym->attr.intent == INTENT_OUT\n \t&& !f->sym->attr.pointer\n \t&& f->sym->ts.type == BT_DERIVED)\n@@ -3911,7 +3913,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \n   gfc_init_block (&tmpblock);\n \n-  for (f = proc_sym->formal; f; f = f->next)\n+  for (f = gfc_sym_get_dummy_args (proc_sym); f; f = f->next)\n     {\n       if (f->sym && f->sym->tlink == NULL && f->sym->ts.type == BT_CHARACTER)\n \t{\n@@ -4804,7 +4806,7 @@ add_argument_checking (stmtblock_t *block, gfc_symbol *sym)\n {\n   gfc_formal_arglist *formal;\n \n-  for (formal = sym->formal; formal; formal = formal->next)\n+  for (formal = gfc_sym_get_dummy_args (sym); formal; formal = formal->next)\n     if (formal->sym && formal->sym->ts.type == BT_CHARACTER\n \t&& !formal->sym->ts.deferred)\n       {"}, {"sha": "2c3ff1fc3cd608021b65b6d94ec59609c0fac90b", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -3266,7 +3266,7 @@ gfc_map_fcn_formal_to_actual (gfc_expr *expr, gfc_expr *map_expr,\n   gfc_actual_arglist *actual;\n \n   actual = expr->value.function.actual;\n-  f = map_expr->symtree->n.sym->formal;\n+  f = gfc_sym_get_dummy_args (map_expr->symtree->n.sym);\n \n   for (; f && actual; f = f->next, actual = actual->next)\n     {\n@@ -3996,7 +3996,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   gfc_init_interface_mapping (&mapping);\n   if (!comp)\n     {\n-      formal = sym->formal;\n+      formal = gfc_sym_get_dummy_args (sym);\n       need_interface_mapping = sym->attr.dimension ||\n \t\t\t       (sym->ts.type == BT_CHARACTER\n \t\t\t\t&& sym->ts.u.cl->length\n@@ -4005,7 +4005,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n     }\n   else\n     {\n-      formal = comp->formal;\n+      formal = comp->ts.interface ? comp->ts.interface->formal : NULL;\n       need_interface_mapping = comp->attr.dimension ||\n \t\t\t       (comp->ts.type == BT_CHARACTER\n \t\t\t\t&& comp->ts.u.cl->length\n@@ -4858,7 +4858,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    cl.backend_decl = (*stringargs)[0];\n \t  else\n \t    {\n-\t      formal = sym->ns->proc_name->formal;\n+\t      formal = gfc_sym_get_dummy_args (sym->ns->proc_name);\n \t      for (; formal; formal = formal->next)\n \t\tif (strcmp (formal->sym->name, sym->name) == 0)\n \t\t  cl.backend_decl = formal->sym->ts.u.cl->backend_decl;\n@@ -5440,12 +5440,13 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n   gfc_init_se (&rse, NULL);\n \n   n = 0;\n-  for (fargs = sym->formal; fargs; fargs = fargs->next)\n+  for (fargs = gfc_sym_get_dummy_args (sym); fargs; fargs = fargs->next)\n     n++;\n   saved_vars = XCNEWVEC (gfc_saved_var, n);\n   temp_vars = XCNEWVEC (tree, n);\n \n-  for (fargs = sym->formal, n = 0; fargs; fargs = fargs->next, n++)\n+  for (fargs = gfc_sym_get_dummy_args (sym), n = 0; fargs;\n+       fargs = fargs->next, n++)\n     {\n       /* Each dummy shall be specified, explicitly or implicitly, to be\n          scalar.  */\n@@ -5499,7 +5500,8 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n     }\n \n   /* Use the temporary variables in place of the real ones.  */\n-  for (fargs = sym->formal, n = 0; fargs; fargs = fargs->next, n++)\n+  for (fargs = gfc_sym_get_dummy_args (sym), n = 0; fargs;\n+       fargs = fargs->next, n++)\n     gfc_shadow_sym (fargs->sym, temp_vars[n], &saved_vars[n]);\n \n   gfc_conv_expr (se, sym->value);\n@@ -5525,7 +5527,8 @@ gfc_conv_statement_function (gfc_se * se, gfc_expr * expr)\n     }\n \n   /* Restore the original variables.  */\n-  for (fargs = sym->formal, n = 0; fargs; fargs = fargs->next, n++)\n+  for (fargs = gfc_sym_get_dummy_args (sym), n = 0; fargs;\n+       fargs = fargs->next, n++)\n     gfc_restore_sym (fargs->sym, &saved_vars[n]);\n   free (temp_vars);\n   free (saved_vars);"}, {"sha": "430b10e37609f7153d51333de4c0b12658e948aa", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -236,7 +236,7 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \n   ss = loopse->ss;\n   arg0 = arg;\n-  formal = sym->formal;\n+  formal = gfc_sym_get_dummy_args (sym);\n \n   /* Loop over all the arguments testing for dependencies.  */\n   for (; arg != NULL; arg = arg->next, formal = formal ? formal->next : NULL)"}, {"sha": "21aa75c12d35166ab18edbed937811d015225ca1", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -2679,7 +2679,7 @@ create_fn_spec (gfc_symbol *sym, tree fntype)\n \tspec[spec_len++] = 'R';\n     }\n \n-  for (f = sym->formal; f; f = f->next)\n+  for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)\n     if (spec_len < sizeof (spec))\n       {\n \tif (!f->sym || f->sym->attr.pointer || f->sym->attr.target\n@@ -2763,7 +2763,7 @@ gfc_get_function_type (gfc_symbol * sym)\n     }\n \n   /* Build the argument types for the function.  */\n-  for (f = sym->formal; f; f = f->next)\n+  for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)\n     {\n       arg = f->sym;\n       if (arg)\n@@ -2806,7 +2806,7 @@ gfc_get_function_type (gfc_symbol * sym)\n     }\n \n   /* Add hidden string length parameters.  */\n-  for (f = sym->formal; f; f = f->next)\n+  for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)\n     {\n       arg = f->sym;\n       if (arg && arg->ts.type == BT_CHARACTER && !sym->attr.is_bind_c)"}, {"sha": "761d601603468be08d1823e4d2492e90a6ddaa82", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -1,3 +1,9 @@\n+2013-01-29  Janus Weil  <janus@gcc.gnu.org>\n+\t    Mikael Morin <mikael@gcc.gnu.org>\n+\n+\tPR fortran/54107\n+\t* gfortran.dg/proc_ptr_comp_36.f90: New.\n+\n 2013-01-29  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/55270"}, {"sha": "63140bb454bc1b07be2af2c86ed6dfc88965d7a4", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_36.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_36.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc9039962dd819f07ee1e3324696aea5114b00/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_36.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_36.f90?ref=4cbc9039962dd819f07ee1e3324696aea5114b00", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+!\n+! PR 54107: [4.8 Regression] Memory hog with abstract interface\n+!\n+! Contributed by Arjen Markus <arjen.markus895@gmail.com>\n+\n+  implicit none \n+  type computation_method \n+    character(len=40)                           :: name \n+    procedure(compute_routine), pointer, nopass :: compute \n+  end type \n+  abstract interface \n+    subroutine compute_routine( param_value, zfunc, probability ) \n+      real, dimension(:), intent(in) :: param_value \n+      procedure(compute_routine)     :: zfunc \n+      real, intent(in)               :: probability \n+    end subroutine \n+  end interface \n+end"}]}