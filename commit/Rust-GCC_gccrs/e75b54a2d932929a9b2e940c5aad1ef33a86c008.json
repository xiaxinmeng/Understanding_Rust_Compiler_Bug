{"sha": "e75b54a2d932929a9b2e940c5aad1ef33a86c008", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc1YjU0YTJkOTMyOTI5YTliMmU5NDBjNWFhZDFlZjMzYTg2YzAwOA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2012-03-22T17:54:55Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2012-03-22T17:54:55Z"}, "message": "* lex.c (search_line_fast): Provide Neon-optimized version for ARM.\n\nFrom-SVN: r185702", "tree": {"sha": "fb178b3c53b755463feef6cd03fe3c9044a0caae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb178b3c53b755463feef6cd03fe3c9044a0caae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e75b54a2d932929a9b2e940c5aad1ef33a86c008", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e75b54a2d932929a9b2e940c5aad1ef33a86c008", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e75b54a2d932929a9b2e940c5aad1ef33a86c008", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e75b54a2d932929a9b2e940c5aad1ef33a86c008/comments", "author": null, "committer": null, "parents": [{"sha": "b31a2c5a3a32245bb7035fc20a5421b0ee059a4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b31a2c5a3a32245bb7035fc20a5421b0ee059a4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b31a2c5a3a32245bb7035fc20a5421b0ee059a4f"}], "stats": {"total": 67, "additions": 67, "deletions": 0}, "files": [{"sha": "133620b3b702587a311cf3f1d768ae089914fd28", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e75b54a2d932929a9b2e940c5aad1ef33a86c008/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e75b54a2d932929a9b2e940c5aad1ef33a86c008/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=e75b54a2d932929a9b2e940c5aad1ef33a86c008", "patch": "@@ -1,3 +1,7 @@\n+2012-03-22  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* lex.c (search_line_fast): Provide Neon-optimized version for ARM.\n+\n 2012-03-14  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* lex.c: Remove Solaris 8 reference."}, {"sha": "9d23002d84be19b2a19ff83a246cbbde5c0880af", "filename": "libcpp/lex.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e75b54a2d932929a9b2e940c5aad1ef33a86c008/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e75b54a2d932929a9b2e940c5aad1ef33a86c008/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=e75b54a2d932929a9b2e940c5aad1ef33a86c008", "patch": "@@ -629,6 +629,69 @@ search_line_fast (const uchar *s, const uchar *end ATTRIBUTE_UNUSED)\n   }\n }\n \n+#elif defined (__ARM_NEON__)\n+#include \"arm_neon.h\"\n+\n+static const uchar *\n+search_line_fast (const uchar *s, const uchar *end ATTRIBUTE_UNUSED)\n+{\n+  const uint8x16_t repl_nl = vdupq_n_u8 ('\\n');\n+  const uint8x16_t repl_cr = vdupq_n_u8 ('\\r');\n+  const uint8x16_t repl_bs = vdupq_n_u8 ('\\\\');\n+  const uint8x16_t repl_qm = vdupq_n_u8 ('?');\n+  const uint8x16_t xmask = (uint8x16_t) vdupq_n_u64 (0x8040201008040201ULL);\n+\n+  unsigned int misalign, found, mask;\n+  const uint8_t *p;\n+  uint8x16_t data;\n+\n+  /* Align the source pointer.  */\n+  misalign = (uintptr_t)s & 15;\n+  p = (const uint8_t *)((uintptr_t)s & -16);\n+  data = vld1q_u8 (p);\n+\n+  /* Create a mask for the bytes that are valid within the first\n+     16-byte block.  The Idea here is that the AND with the mask\n+     within the loop is \"free\", since we need some AND or TEST\n+     insn in order to set the flags for the branch anyway.  */\n+  mask = (-1u << misalign) & 0xffff;\n+\n+  /* Main loop, processing 16 bytes at a time.  */\n+  goto start;\n+\n+  do\n+    {\n+      uint8x8_t l;\n+      uint16x4_t m;\n+      uint32x2_t n;\n+      uint8x16_t t, u, v, w;\n+\n+      p += 16;\n+      data = vld1q_u8 (p);\n+      mask = 0xffff;\n+\n+    start:\n+      t = vceqq_u8 (data, repl_nl);\n+      u = vceqq_u8 (data, repl_cr);\n+      v = vorrq_u8 (t, vceqq_u8 (data, repl_bs));\n+      w = vorrq_u8 (u, vceqq_u8 (data, repl_qm));\n+      t = vandq_u8 (vorrq_u8 (v, w), xmask);\n+      l = vpadd_u8 (vget_low_u8 (t), vget_high_u8 (t));\n+      m = vpaddl_u8 (l);\n+      n = vpaddl_u16 (m);\n+      \n+      found = vget_lane_u32 ((uint32x2_t) vorr_u64 ((uint64x1_t) n, \n+\t      vshr_n_u64 ((uint64x1_t) n, 24)), 0);\n+      found &= mask;\n+    }\n+  while (!found);\n+\n+  /* FOUND contains 1 in bits for which we matched a relevant\n+     character.  Conversion to the byte index is trivial.  */\n+  found = __builtin_ctz (found);\n+  return (const uchar *)p + found;\n+}\n+\n #else\n \n /* We only have one accellerated alternative.  Use a direct call so that"}]}