{"sha": "7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgxMmM3OGMzNDFmYjRjNjU1OWNmODE1OGIxNWM0OGM3YTFkNmZkZQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2009-04-05T20:13:56Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2009-04-05T20:13:56Z"}, "message": "[multiple changes]\n\n2009-04-05  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/38654\n\t* io/read.c (read_f): Reworked to speed up floating point parsing.\n\t(convert_real): Use pointer-casting instead of memcpy and temporaries.\n\n2009-04-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n        PR libfortran/37754\n\t* io/io.h (format_hash_entry): New structure for hash table.\n\t(format_hash_table): The hash table itself.\n\t(free_format_data): Revise function prototype.\n\t(free_format_hash_table, init_format_hash,\n\tfree_format_hash): New function prototypes.\n\t* io/unit.c (close_unit_1): Use free_format_hash_table.\n\t* io/transfer.c (st_read_done, st_write_done): Free format data if\n\tinternal unit.\n\t* io/format.c (free_format_hash_table): New function that frees any\n\tmemory allocated previously for cached format data.\n\t(reset_node): New static helper function to reset the format counters\n\tfor a format node.\n\t(reset_fnode_counters): New static function recursively calls reset_node\n\tto traverse the\tfnode tree.\n\t(format_hash): New simple hash function based on XOR, probabalistic,\n\ttosses collisions.\n\t(save_parsed_format): New static function to save the parsed format\n\tdata to use again.\n\t(find_parsed_format): New static function searches the hash table\n\tlooking for a match.\n\t(free_format_data): Revised to accept pointer to format data rather than\n\tthe dtp pointer so that the function can be used in more places.\n\t(format_lex): Editorial.\n\t(parse_format_list): Set flag used to determine of format data hashing\n\tis to be used.  Internal units are not persistent enough for this.\n\t(revert): Move to ne location in file.\n\t(parse_format): Use new functions to look for previously parsed\n\tformat strings and use them rather than re-parse.  If not found, saves\n\tthe parsed format data for later use.\n\t\n2009-04-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n        PR libfortran/37754\n\t* io/transfer.c (formatted_transfer_scalar): Remove this function by\n\tfactoring it into two new functions, one for read and one for write,\n\teliminating all the conditionals for read or write mode.\n\t(formatted transfer_scalar_read): New function.\n\t(formatted transfer_scalar_write): New function.\n\t(formatted_transfer): Use new functions.\n\n2009-04-05  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        PR libfortran/25561 libfortran/37754\n\t* io/io.h (struct stream): Define new stream interface function\n\tpointers, and inline functions for accessing it.\n\t(struct fbuf): Use int instead of size_t, remove flushed element.\n\t(mem_alloc_w): New prototype.\n\t(mem_alloc_r): New prototype.\n\t(stream_at_bof): Remove prototype.\n\t(stream_at_eof): Remove prototype.\n\t(file_position): Remove prototype.\n\t(flush): Remove prototype.\n\t(stream_offset): Remove prototype.\n\t(unit_truncate): New prototype.\n\t(read_block_form): Change to return pointer, int* argument.\n\t(hit_eof): New prototype.\n\t(fbuf_init): Change prototype.\n\t(fbuf_reset): Change prototype.\n\t(fbuf_alloc): Change prototype.\n\t(fbuf_flush): Change prototype.\n\t(fbuf_seek): Change prototype.\n\t(fbuf_read): New prototype.\n\t(fbuf_getc_refill): New prototype.\n\t(fbuf_getc): New inline function.\n        * io/fbuf.c (fbuf_init): Use int, get rid of flushed.\n\t(fbuf_debug): New function.\n\t(fbuf_reset): Flush, and return position offset.\n\t(fbuf_alloc): Simplify, don't flush, just realloc.\n\t(fbuf_flush): Make usable for read mode, salvage remaining bytes.\n\t(fbuf_seek): New whence argument.\n\t(fbuf_read): New function.\n\t(fbuf_getc_refill): New function.\n\t* io/file_pos.c (formatted_backspace): Use new stream interface.\n\t(unformatted_backspace): Likewise.\n\t(st_backspace): Make sure format buffer is reset, use new stream\n\tinterface, use unit_truncate.\n\t(st_endfile): Likewise.\n\t(st_rewind): Likewise.\n\t* io/intrinsics.c: Use new stream interface.\n\t* io/list_read.c (push_char): Don't use u.p.scratch, use realloc\n\tto resize.\n\t(free_saved): Don't check u.p.scratch.\n\t(next_char): Use new stream interface, use fbuf_getc() for external files.\n\t(finish_list_read): flush format buffer.\n\t(nml_query): Update to use modified interface:s\n\t* io/open.c (test_endfile): Use new stream interface.\n\t(edit_modes): Likewise.\n\t(new_unit): Likewise, set bytes_left to 1 for stream files.\n\t* io/read.c (read_l): Use new read_block_form interface.\n\t(read_utf8): Likewise.\n\t(read_utf8_char1): Likewise.\n\t(read_default_char1): Likewise.\n\t(read_utf8_char4): Likewise.\n\t(read_default_char4): Likewise.\n\t(read_a): Likewise.\n\t(read_a_char4): Likewise.\n\t(read_decimal): Likewise.\n\t(read_radix): Likewise.\n\t(read_f): Likewise.\n\t* io/transfer.c (read_sf): Use fbuf_read and mem_alloc_r, remove\n\tusage of u.p.line_buffer.\n\t(read_block_form): Update interface to return pointer, use\n\tfbuf_read for direct access.\n\t(read_block_direct): Update to new stream interface.\n\t(write_block): Use mem_alloc_w for internal I/O.\n\t(write_buf): Update to new stream interface.\n\t(formatted_transfer_scalar): Don't use u.p.line_buffer, use\n\tfbuf_seek for external files.\n\t(us_read): Update to new stream interface.\n\t(us_write): Likewise.\n\t(data_transfer_init): Always check if we switch modes and flush.\n\t(skip_record): Use new stream interface, fix comparison.\n\t(next_record_r): Check for and reset u.p.at_eof, use new stream\n\tinterface, use fbuf_getc for spacing.\n\t(write_us_marker): Update to new stream interface, don't inline.\n\t(next_record_w_unf): Likewise.\n\t(sset): New function.\n\t(next_record_w): Use new stream interface, use fbuf for printing\n\tnewline.\n\t(next_record): Use new stream interface.\n\t(finalize_transfer): Remove sfree call, use new stream interface.\n\t(st_iolength_done): Don't use u.p.scratch.\n\t(st_read): Don't check for end of file.\n\t(st_read_done): Don't use u.p.scratch, use unit_truncate.\n\t(hit_eof): New function.\n\t* io/unit.c (init_units): Always init fbuf for formatted units.\n\t(update_position): Use new stream interface.\n\t(unit_truncate): New function.\n\t(finish_last_advance_record): Use fbuf to print newline.\n\t* io/unix.c: Remove unused SSIZE_MAX macro.\n\t(BUFFER_SIZE): Make static const variable rather than macro.\n\t(struct unix_stream): Remove dirty_offset, len, method,\n\tsmall_buffer. Order elements by decreasing size.\n\t(struct int_stream): Remove.\n\t(move_pos_offset): Remove usage of dirty_offset.\n\t(reset_stream): Remove.\n\t(do_read): Rename to raw_read, update to match new stream\n\tinterface.\n\t(do_write): Rename to raw_write, update to new stream interface.\n\t(raw_seek): New function.\n\t(raw_tell): New function.\n\t(raw_truncate): New function.\n\t(raw_close): New function.\n\t(raw_flush): New function.\n\t(raw_init): New function.\n\t(fd_alloc): Remove.\n\t(fd_alloc_r_at): Remove.\n\t(fd_alloc_w_at): Remove.\n\t(fd_sfree): Remove.\n\t(fd_seek): Remove.\n\t(fd_truncate): Remove.\n\t(fd_sset): Remove.\n\t(fd_read): Remove.\n\t(fd_write): Remove.\n\t(fd_close): Remove.\n\t(fd_open): Remove.\n\t(fd_flush): Rename to buf_flush, update to new stream interface\n\tand unix_stream.\n\t(buf_read): New function.\n\t(buf_write): New function.\n\t(buf_seek): New function.\n\t(buf_tell): New function.\n\t(buf_truncate): New function.\n\t(buf_close): New function.\n\t(buf_init): New function.\n\t(mem_alloc_r_at): Rename to mem_alloc_r, change prototype.\n\t(mem_alloc_w_at): Rename to mem_alloc_w, change prototype.\n\t(mem_read): Change to match new stream interface.\n\t(mem_write): Likewise.\n\t(mem_seek): Likewise.\n\t(mem_tell): Likewise.\n\t(mem_truncate): Likewise.\n\t(mem_close): Likewise.\n\t(mem_flush): New function.\n\t(mem_sfree): Remove.\n\t(empty_internal_buffer): Cast to correct type.\n\t(open_internal): Use correct type, init function pointers.\n\t(fd_to_stream): Test whether to open file as buffered or raw.\n\t(output_stream): Remove mode set.\n\t(error_stream): Likewise.\n\t(flush_all_units_1): Use new stream interface.\n\t(flush_all_units): Likewise.\n\t(stream_at_bof): Remove.\n\t(stream_at_eof): Remove.\n\t(file_position): Remove.\n\t(file_length): Update logic to use stream interface.\n\t(flush): Remove.\n\t(stream_offset): Remove.\n\t* io/write.c (write_utf8_char4): Use int instead of size_t.\n\t(write_x): Extra safety check.\n\t(namelist_write_newline): Use new stream interface.\n\nFrom-SVN: r145571", "tree": {"sha": "9713a11310a5202d06a5ad2750bf0992f9c0e3f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9713a11310a5202d06a5ad2750bf0992f9c0e3f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/comments", "author": null, "committer": null, "parents": [{"sha": "941c3614de1559c71cd1dc4f15d888d2bcccbd63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/941c3614de1559c71cd1dc4f15d888d2bcccbd63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/941c3614de1559c71cd1dc4f15d888d2bcccbd63"}], "stats": {"total": 3895, "additions": 2143, "deletions": 1752}, "files": [{"sha": "761110f4e3c50b401edea59e3aba961548d3a62e", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "patch": "@@ -1,3 +1,204 @@\n+2009-04-05  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/38654\n+\t* io/read.c (read_f): Reworked to speed up floating point parsing.\n+\t(convert_real): Use pointer-casting instead of memcpy and temporaries.\n+\n+2009-04-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+        PR libfortran/37754\n+\t* io/io.h (format_hash_entry): New structure for hash table.\n+\t(format_hash_table): The hash table itself.\n+\t(free_format_data): Revise function prototype.\n+\t(free_format_hash_table, init_format_hash,\n+\tfree_format_hash): New function prototypes.\n+\t* io/unit.c (close_unit_1): Use free_format_hash_table.\n+\t* io/transfer.c (st_read_done, st_write_done): Free format data if\n+\tinternal unit.\n+\t* io/format.c (free_format_hash_table): New function that frees any\n+\tmemory allocated previously for cached format data.\n+\t(reset_node): New static helper function to reset the format counters\n+\tfor a format node.\n+\t(reset_fnode_counters): New static function recursively calls reset_node\n+\tto traverse the\tfnode tree.\n+\t(format_hash): New simple hash function based on XOR, probabalistic,\n+\ttosses collisions.\n+\t(save_parsed_format): New static function to save the parsed format\n+\tdata to use again.\n+\t(find_parsed_format): New static function searches the hash table\n+\tlooking for a match.\n+\t(free_format_data): Revised to accept pointer to format data rather than\n+\tthe dtp pointer so that the function can be used in more places.\n+\t(format_lex): Editorial.\n+\t(parse_format_list): Set flag used to determine of format data hashing\n+\tis to be used.  Internal units are not persistent enough for this.\n+\t(revert): Move to ne location in file.\n+\t(parse_format): Use new functions to look for previously parsed\n+\tformat strings and use them rather than re-parse.  If not found, saves\n+\tthe parsed format data for later use.\n+\t\n+2009-04-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+        PR libfortran/37754\n+\t* io/transfer.c (formatted_transfer_scalar): Remove this function by\n+\tfactoring it into two new functions, one for read and one for write,\n+\teliminating all the conditionals for read or write mode.\n+\t(formatted transfer_scalar_read): New function.\n+\t(formatted transfer_scalar_write): New function.\n+\t(formatted_transfer): Use new functions.\n+\n+2009-04-05  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        PR libfortran/25561 libfortran/37754\n+\t* io/io.h (struct stream): Define new stream interface function\n+\tpointers, and inline functions for accessing it.\n+\t(struct fbuf): Use int instead of size_t, remove flushed element.\n+\t(mem_alloc_w): New prototype.\n+\t(mem_alloc_r): New prototype.\n+\t(stream_at_bof): Remove prototype.\n+\t(stream_at_eof): Remove prototype.\n+\t(file_position): Remove prototype.\n+\t(flush): Remove prototype.\n+\t(stream_offset): Remove prototype.\n+\t(unit_truncate): New prototype.\n+\t(read_block_form): Change to return pointer, int* argument.\n+\t(hit_eof): New prototype.\n+\t(fbuf_init): Change prototype.\n+\t(fbuf_reset): Change prototype.\n+\t(fbuf_alloc): Change prototype.\n+\t(fbuf_flush): Change prototype.\n+\t(fbuf_seek): Change prototype.\n+\t(fbuf_read): New prototype.\n+\t(fbuf_getc_refill): New prototype.\n+\t(fbuf_getc): New inline function.\n+        * io/fbuf.c (fbuf_init): Use int, get rid of flushed.\n+\t(fbuf_debug): New function.\n+\t(fbuf_reset): Flush, and return position offset.\n+\t(fbuf_alloc): Simplify, don't flush, just realloc.\n+\t(fbuf_flush): Make usable for read mode, salvage remaining bytes.\n+\t(fbuf_seek): New whence argument.\n+\t(fbuf_read): New function.\n+\t(fbuf_getc_refill): New function.\n+\t* io/file_pos.c (formatted_backspace): Use new stream interface.\n+\t(unformatted_backspace): Likewise.\n+\t(st_backspace): Make sure format buffer is reset, use new stream\n+\tinterface, use unit_truncate.\n+\t(st_endfile): Likewise.\n+\t(st_rewind): Likewise.\n+\t* io/intrinsics.c: Use new stream interface.\n+\t* io/list_read.c (push_char): Don't use u.p.scratch, use realloc\n+\tto resize.\n+\t(free_saved): Don't check u.p.scratch.\n+\t(next_char): Use new stream interface, use fbuf_getc() for external files.\n+\t(finish_list_read): flush format buffer.\n+\t(nml_query): Update to use modified interface:s\n+\t* io/open.c (test_endfile): Use new stream interface.\n+\t(edit_modes): Likewise.\n+\t(new_unit): Likewise, set bytes_left to 1 for stream files.\n+\t* io/read.c (read_l): Use new read_block_form interface.\n+\t(read_utf8): Likewise.\n+\t(read_utf8_char1): Likewise.\n+\t(read_default_char1): Likewise.\n+\t(read_utf8_char4): Likewise.\n+\t(read_default_char4): Likewise.\n+\t(read_a): Likewise.\n+\t(read_a_char4): Likewise.\n+\t(read_decimal): Likewise.\n+\t(read_radix): Likewise.\n+\t(read_f): Likewise.\n+\t* io/transfer.c (read_sf): Use fbuf_read and mem_alloc_r, remove\n+\tusage of u.p.line_buffer.\n+\t(read_block_form): Update interface to return pointer, use\n+\tfbuf_read for direct access.\n+\t(read_block_direct): Update to new stream interface.\n+\t(write_block): Use mem_alloc_w for internal I/O.\n+\t(write_buf): Update to new stream interface.\n+\t(formatted_transfer_scalar): Don't use u.p.line_buffer, use\n+\tfbuf_seek for external files.\n+\t(us_read): Update to new stream interface.\n+\t(us_write): Likewise.\n+\t(data_transfer_init): Always check if we switch modes and flush.\n+\t(skip_record): Use new stream interface, fix comparison.\n+\t(next_record_r): Check for and reset u.p.at_eof, use new stream\n+\tinterface, use fbuf_getc for spacing.\n+\t(write_us_marker): Update to new stream interface, don't inline.\n+\t(next_record_w_unf): Likewise.\n+\t(sset): New function.\n+\t(next_record_w): Use new stream interface, use fbuf for printing\n+\tnewline.\n+\t(next_record): Use new stream interface.\n+\t(finalize_transfer): Remove sfree call, use new stream interface.\n+\t(st_iolength_done): Don't use u.p.scratch.\n+\t(st_read): Don't check for end of file.\n+\t(st_read_done): Don't use u.p.scratch, use unit_truncate.\n+\t(hit_eof): New function.\n+\t* io/unit.c (init_units): Always init fbuf for formatted units.\n+\t(update_position): Use new stream interface.\n+\t(unit_truncate): New function.\n+\t(finish_last_advance_record): Use fbuf to print newline.\n+\t* io/unix.c: Remove unused SSIZE_MAX macro.\n+\t(BUFFER_SIZE): Make static const variable rather than macro.\n+\t(struct unix_stream): Remove dirty_offset, len, method,\n+\tsmall_buffer. Order elements by decreasing size.\n+\t(struct int_stream): Remove.\n+\t(move_pos_offset): Remove usage of dirty_offset.\n+\t(reset_stream): Remove.\n+\t(do_read): Rename to raw_read, update to match new stream\n+\tinterface.\n+\t(do_write): Rename to raw_write, update to new stream interface.\n+\t(raw_seek): New function.\n+\t(raw_tell): New function.\n+\t(raw_truncate): New function.\n+\t(raw_close): New function.\n+\t(raw_flush): New function.\n+\t(raw_init): New function.\n+\t(fd_alloc): Remove.\n+\t(fd_alloc_r_at): Remove.\n+\t(fd_alloc_w_at): Remove.\n+\t(fd_sfree): Remove.\n+\t(fd_seek): Remove.\n+\t(fd_truncate): Remove.\n+\t(fd_sset): Remove.\n+\t(fd_read): Remove.\n+\t(fd_write): Remove.\n+\t(fd_close): Remove.\n+\t(fd_open): Remove.\n+\t(fd_flush): Rename to buf_flush, update to new stream interface\n+\tand unix_stream.\n+\t(buf_read): New function.\n+\t(buf_write): New function.\n+\t(buf_seek): New function.\n+\t(buf_tell): New function.\n+\t(buf_truncate): New function.\n+\t(buf_close): New function.\n+\t(buf_init): New function.\n+\t(mem_alloc_r_at): Rename to mem_alloc_r, change prototype.\n+\t(mem_alloc_w_at): Rename to mem_alloc_w, change prototype.\n+\t(mem_read): Change to match new stream interface.\n+\t(mem_write): Likewise.\n+\t(mem_seek): Likewise.\n+\t(mem_tell): Likewise.\n+\t(mem_truncate): Likewise.\n+\t(mem_close): Likewise.\n+\t(mem_flush): New function.\n+\t(mem_sfree): Remove.\n+\t(empty_internal_buffer): Cast to correct type.\n+\t(open_internal): Use correct type, init function pointers.\n+\t(fd_to_stream): Test whether to open file as buffered or raw.\n+\t(output_stream): Remove mode set.\n+\t(error_stream): Likewise.\n+\t(flush_all_units_1): Use new stream interface.\n+\t(flush_all_units): Likewise.\n+\t(stream_at_bof): Remove.\n+\t(stream_at_eof): Remove.\n+\t(file_position): Remove.\n+\t(file_length): Update logic to use stream interface.\n+\t(flush): Remove.\n+\t(stream_offset): Remove.\n+\t* io/write.c (write_utf8_char4): Use int instead of size_t.\n+\t(write_x): Extra safety check.\n+\t(namelist_write_newline): Use new stream interface.\n+\n 2009-03-29  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR fortran/33595"}, {"sha": "a496365f928fcb7ab84f7082b31cfb4b71a31298", "filename": "libgfortran/io/fbuf.c", "status": "modified", "additions": 183, "deletions": 74, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Ffbuf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Ffbuf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffbuf.c?ref=7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "patch": "@@ -33,23 +33,19 @@ Boston, MA 02110-1301, USA.  */\n #include <stdlib.h>\n \n \n+//#define FBUF_DEBUG\n+\n+\n void\n-fbuf_init (gfc_unit * u, size_t len)\n+fbuf_init (gfc_unit * u, int len)\n {\n   if (len == 0)\n     len = 512;\t\t\t/* Default size.  */\n \n   u->fbuf = get_mem (sizeof (fbuf));\n   u->fbuf->buf = get_mem (len);\n   u->fbuf->len = len;\n-  u->fbuf->act = u->fbuf->flushed = u->fbuf->pos = 0;\n-}\n-\n-\n-void\n-fbuf_reset (gfc_unit * u)\n-{\n-  u->fbuf->act = u->fbuf->flushed = u->fbuf->pos = 0;\n+  u->fbuf->act = u->fbuf->pos = 0;\n }\n \n \n@@ -61,58 +57,79 @@ fbuf_destroy (gfc_unit * u)\n   if (u->fbuf->buf)\n     free_mem (u->fbuf->buf);\n   free_mem (u->fbuf);\n+  u->fbuf = NULL;\n+}\n+\n+\n+static void\n+#ifdef FBUF_DEBUG\n+fbuf_debug (gfc_unit * u, const char * format, ...)\n+{\n+  va_list args;\n+  va_start(args, format);\n+  vfprintf(stderr, format, args);\n+  va_end(args);\n+  fprintf (stderr, \"fbuf_debug pos: %d, act: %d, buf: ''\", \n+           u->fbuf->pos, u->fbuf->act);\n+  for (int ii = 0; ii < u->fbuf->act; ii++)\n+    {\n+      putc (u->fbuf->buf[ii], stderr);\n+    }\n+  fprintf (stderr, \"''\\n\");\n+}\n+#else\n+fbuf_debug (gfc_unit * u __attribute__ ((unused)),\n+            const char * format __attribute__ ((unused)),\n+            ...) {}\n+#endif\n+\n+  \n+\n+/* You should probably call this before doing a physical seek on the\n+   underlying device.  Returns how much the physical position was\n+   modified.  */\n+\n+int\n+fbuf_reset (gfc_unit * u)\n+{\n+  int seekval = 0;\n+\n+  if (!u->fbuf)\n+    return 0;\n+\n+  fbuf_debug (u, \"fbuf_reset: \");\n+  fbuf_flush (u, u->mode);\n+  /* If we read past the current position, seek the underlying device\n+     back.  */\n+  if (u->mode == READING && u->fbuf->act > u->fbuf->pos)\n+    {\n+      seekval = - (u->fbuf->act - u->fbuf->pos);\n+      fbuf_debug (u, \"fbuf_reset seekval %d, \", seekval);\n+    }\n+  u->fbuf->act = u->fbuf->pos = 0;\n+  return seekval;\n }\n \n \n /* Return a pointer to the current position in the buffer, and increase\n    the pointer by len. Makes sure that the buffer is big enough, \n-   reallocating if necessary. If the buffer is not big enough, there are\n-   three cases to consider:\n-   1. If we haven't flushed anything, realloc\n-   2. If we have flushed enough that by discarding the flushed bytes\n-      the request fits into the buffer, do that.\n-   3. Else allocate a new buffer, memcpy unflushed active bytes from old\n-      buffer. */\n+   reallocating if necessary.  */\n \n char *\n-fbuf_alloc (gfc_unit * u, size_t len)\n+fbuf_alloc (gfc_unit * u, int len)\n {\n-  size_t newlen;\n+  int newlen;\n   char *dest;\n+  fbuf_debug (u, \"fbuf_alloc len %d, \", len);\n   if (u->fbuf->pos + len > u->fbuf->len)\n     {\n-      if (u->fbuf->flushed == 0)\n-\t{\n-\t  /* Round up to nearest multiple of the current buffer length.  */\n-\t  newlen = ((u->fbuf->pos + len) / u->fbuf->len + 1) * u->fbuf->len;\n-\t  dest = realloc (u->fbuf->buf, newlen);\n-\t  if (dest == NULL)\n-\t    return NULL;\n-\t  u->fbuf->buf = dest;\n-\t  u->fbuf->len = newlen;\n-\t}\n-      else if (u->fbuf->act - u->fbuf->flushed + len < u->fbuf->len)\n-\t{\n-\t  memmove (u->fbuf->buf, u->fbuf->buf + u->fbuf->flushed,\n-\t\t   u->fbuf->act - u->fbuf->flushed);\n-\t  u->fbuf->act -= u->fbuf->flushed;\n-\t  u->fbuf->pos -= u->fbuf->flushed;\n-\t  u->fbuf->flushed = 0;\n-\t}\n-      else\n-\t{\n-\t  /* Most general case, flushed != 0, request doesn't fit.  */\n-\t  newlen = ((u->fbuf->pos - u->fbuf->flushed + len)\n-\t\t    / u->fbuf->len + 1) * u->fbuf->len;\n-\t  dest = get_mem (newlen);\n-\t  memcpy (dest, u->fbuf->buf + u->fbuf->flushed,\n-\t\t  u->fbuf->act - u->fbuf->flushed);\n-\t  u->fbuf->act -= u->fbuf->flushed;\n-\t  u->fbuf->pos -= u->fbuf->flushed;\n-\t  u->fbuf->flushed = 0;\n-\t  u->fbuf->buf = dest;\n-\t  u->fbuf->len = newlen;\n-\t}\n+      /* Round up to nearest multiple of the current buffer length.  */\n+      newlen = ((u->fbuf->pos + len) / u->fbuf->len + 1) * u->fbuf->len;\n+      dest = realloc (u->fbuf->buf, newlen);\n+      if (dest == NULL)\n+\treturn NULL;\n+      u->fbuf->buf = dest;\n+      u->fbuf->len = newlen;\n     }\n \n   dest = u->fbuf->buf + u->fbuf->pos;\n@@ -123,42 +140,134 @@ fbuf_alloc (gfc_unit * u, size_t len)\n }\n \n \n-\n+/* mode argument is WRITING for write mode and READING for read\n+   mode. Return value is 0 for success, -1 on failure.  */\n \n int\n-fbuf_flush (gfc_unit * u, int record_done)\n+fbuf_flush (gfc_unit * u, unit_mode mode)\n {\n-  int status;\n-  size_t nbytes;\n+  int nwritten;\n \n   if (!u->fbuf)\n     return 0;\n-  if (u->fbuf->act - u->fbuf->flushed != 0)\n+\n+  fbuf_debug (u, \"fbuf_flush with mode %d: \", mode);\n+\n+  if (mode == WRITING)\n     {\n-      if (record_done)\n-        nbytes = u->fbuf->act - u->fbuf->flushed;\n-      else\t\n-        nbytes = u->fbuf->pos - u->fbuf->flushed;\t\n-      status = swrite (u->s, u->fbuf->buf + u->fbuf->flushed, &nbytes);\n-      u->fbuf->flushed += nbytes;\n+      if (u->fbuf->pos > 0)\n+\t{\n+\t  nwritten = swrite (u->s, u->fbuf->buf, u->fbuf->pos);\n+\t  if (nwritten < 0)\n+\t    return -1;\n+\t}\n     }\n-  else\n-    status = 0;\n-  if (record_done)\n-    fbuf_reset (u);\n-  return status;\n+  /* Salvage remaining bytes for both reading and writing. This\n+     happens with the combination of advance='no' and T edit\n+     descriptors leaving the final position somewhere not at the end\n+     of the record. For reading, this also happens if we sread() past\n+     the record boundary.  */ \n+  if (u->fbuf->act > u->fbuf->pos && u->fbuf->pos > 0)\n+    memmove (u->fbuf->buf, u->fbuf->buf + u->fbuf->pos, \n+             u->fbuf->act - u->fbuf->pos);\n+\n+  u->fbuf->act -= u->fbuf->pos;\n+  u->fbuf->pos = 0;\n+\n+  return 0;\n }\n \n \n int\n-fbuf_seek (gfc_unit * u, gfc_offset off)\n+fbuf_seek (gfc_unit * u, int off, int whence)\n {\n-  gfc_offset pos = u->fbuf->pos + off;\n-  /* Moving to the left past the flushed marked would imply moving past\n-     the left tab limit, which is never allowed. So return error if\n-     that is attempted.  */\n-  if (pos < (gfc_offset) u->fbuf->flushed)\n+  if (!u->fbuf)\n     return -1;\n-  u->fbuf->pos = pos;\n-  return 0;\n+\n+  switch (whence)\n+    {\n+    case SEEK_SET:\n+      break;\n+    case SEEK_CUR:\n+      off += u->fbuf->pos;\n+      break;\n+    case SEEK_END:\n+      off += u->fbuf->act;\n+      break;\n+    default:\n+      return -1;\n+    }\n+\n+  fbuf_debug (u, \"fbuf_seek, off %d \", off);\n+  /* The start of the buffer is always equal to the left tab\n+     limit. Moving to the left past the buffer is illegal in C and\n+     would also imply moving past the left tab limit, which is never\n+     allowed in Fortran. Similarly, seeking past the end of the buffer\n+     is not possible, in that case the user must make sure to allocate\n+     space with fbuf_alloc().  So return error if that is\n+     attempted.  */\n+  if (off < 0 || off > u->fbuf->act)\n+    return -1;\n+  u->fbuf->pos = off;\n+  return off;\n+}\n+\n+\n+/* Fill the buffer with bytes for reading.  Returns a pointer to start\n+   reading from. If we hit EOF, returns a short read count. If any\n+   other error occurs, return NULL.  After reading, the caller is\n+   expected to call fbuf_seek to update the position with the number\n+   of bytes actually processed. */\n+\n+char *\n+fbuf_read (gfc_unit * u, int * len)\n+{\n+  char *ptr;\n+  int oldact, oldpos;\n+  int readlen = 0;\n+\n+  fbuf_debug (u, \"fbuf_read, len %d: \", *len);\n+  oldact = u->fbuf->act;\n+  oldpos = u->fbuf->pos;\n+  ptr = fbuf_alloc (u, *len);\n+  u->fbuf->pos = oldpos;\n+  if (oldpos + *len > oldact)\n+    {\n+      fbuf_debug (u, \"reading %d bytes starting at %d \", \n+                  oldpos + *len - oldact, oldact);\n+      readlen = sread (u->s, u->fbuf->buf + oldact, oldpos + *len - oldact);\n+      if (readlen < 0)\n+\treturn NULL;\n+      *len = oldact - oldpos + readlen;\n+    }\n+  u->fbuf->act = oldact + readlen;\n+  fbuf_debug (u, \"fbuf_read done: \");\n+  return ptr;\n+}\n+\n+\n+/* When the fbuf_getc() inline function runs out of buffer space, it\n+   calls this function to fill the buffer with bytes for\n+   reading. Never call this function directly.  */\n+\n+int\n+fbuf_getc_refill (gfc_unit * u)\n+{\n+  int nread;\n+  char *p;\n+\n+  fbuf_debug (u, \"fbuf_getc_refill \");\n+\n+  /* Read 80 bytes (average line length?).  This is a compromise\n+     between not needing to call the read() syscall all the time and\n+     not having to memmove unnecessary stuff when switching to the\n+     next record.  */\n+  nread = 80;\n+\n+  p = fbuf_read (u, &nread);\n+\n+  if (p && nread > 0)\n+    return (unsigned char) u->fbuf->buf[u->fbuf->pos++];\n+  else\n+    return EOF;\n }"}, {"sha": "ecee101b6792827d292c63b4207f109fec13625f", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "patch": "@@ -46,17 +46,17 @@ formatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n {\n   gfc_offset base;\n   char p[READ_CHUNK];\n-  size_t n;\n+  ssize_t n;\n \n-  base = file_position (u->s) - 1;\n+  base = stell (u->s) - 1;\n \n   do\n     {\n       n = (base < READ_CHUNK) ? base : READ_CHUNK;\n       base -= n;\n-      if (sseek (u->s, base) == FAILURE)\n+      if (sseek (u->s, base, SEEK_SET) < 0)\n         goto io_error;\n-      if (sread (u->s, p, &n) != 0)\n+      if (sread (u->s, p, n) != n)\n \tgoto io_error;\n \n       /* We have moved backwards from the current position, it should\n@@ -81,7 +81,7 @@ formatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n \n   /* base is the new pointer.  Seek to it exactly.  */\n  done:\n-  if (sseek (u->s, base) == FAILURE)\n+  if (sseek (u->s, base, SEEK_SET) < 0)\n     goto io_error;\n   u->last_record--;\n   u->endfile = NO_ENDFILE;\n@@ -100,10 +100,10 @@ formatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n static void\n unformatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n {\n-  gfc_offset m, new;\n+  gfc_offset m, slen;\n   GFC_INTEGER_4 m4;\n   GFC_INTEGER_8 m8;\n-  size_t length;\n+  ssize_t length;\n   int continued;\n   char p[sizeof (GFC_INTEGER_8)];\n \n@@ -114,9 +114,10 @@ unformatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n \n   do\n     {\n-      if (sseek (u->s, file_position (u->s) - length) == FAILURE)\n+      slen = - (gfc_offset) length;\n+      if (sseek (u->s, slen, SEEK_CUR) < 0)\n         goto io_error;\n-      if (sread (u->s, p, &length) != 0)\n+      if (sread (u->s, p, length) != length)\n         goto io_error;\n \n       /* Only GFC_CONVERT_NATIVE and GFC_CONVERT_SWAP are valid here.  */\n@@ -164,10 +165,7 @@ unformatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n       if (continued)\n \tm = -m;\n \n-      if ((new = file_position (u->s) - m - 2*length) < 0)\n-\tnew = 0;\n-\n-      if (sseek (u->s, new) == FAILURE)\n+      if (sseek (u->s, -m -2 * length, SEEK_CUR) < 0)\n \tgoto io_error;\n     } while (continued);\n \n@@ -206,27 +204,33 @@ st_backspace (st_parameter_filepos *fpp)\n       goto done;\n     }\n \n-    if (u->flags.access == ACCESS_STREAM && u->flags.form == FORM_UNFORMATTED)\n-      {\n-\tgenerate_error (&fpp->common, LIBERROR_OPTION_CONFLICT,\n-\t\t\t\"Cannot BACKSPACE an unformatted stream file\");\n-\tgoto done;\n-      }\n+  if (u->flags.access == ACCESS_STREAM && u->flags.form == FORM_UNFORMATTED)\n+    {\n+      generate_error (&fpp->common, LIBERROR_OPTION_CONFLICT,\n+                      \"Cannot BACKSPACE an unformatted stream file\");\n+      goto done;\n+    }\n+\n+  /* Make sure format buffer is flushed and reset.  */\n+  if (u->flags.form == FORM_FORMATTED)\n+    {\n+      int pos = fbuf_reset (u);\n+      if (pos != 0)\n+        sseek (u->s, pos, SEEK_CUR);\n+    }\n \n-  /* Make sure format buffer is flushed.  */\n-  fbuf_flush (u, 1);\n   \n   /* Check for special cases involving the ENDFILE record first.  */\n \n   if (u->endfile == AFTER_ENDFILE)\n     {\n       u->endfile = AT_ENDFILE;\n       u->flags.position = POSITION_APPEND;\n-      flush (u->s);\n+      sflush (u->s);\n     }\n   else\n     {\n-      if (file_position (u->s) == 0)\n+      if (stell (u->s) == 0)\n \t{\n \t  u->flags.position = POSITION_REWIND;\n \t  goto done;\t\t/* Common special case */\n@@ -243,8 +247,7 @@ st_backspace (st_parameter_filepos *fpp)\n \n \t  u->previous_nonadvancing_write = 0;\n \n-\t  flush (u->s);\n-\t  struncate (u->s);\n+\t  unit_truncate (u, stell (u->s), &fpp->common);\n \t  u->mode = READING;\n         }\n \n@@ -253,7 +256,7 @@ st_backspace (st_parameter_filepos *fpp)\n       else\n \tunformatted_backspace (fpp, u);\n \n-      update_position (u);\n+      u->flags.position = POSITION_UNSPECIFIED;\n       u->endfile = NO_ENDFILE;\n       u->current_record = 0;\n       u->bytes_left = 0;\n@@ -305,10 +308,10 @@ st_endfile (st_parameter_filepos *fpp)\n \t  next_record (&dtp, 1);\n \t}\n \n-      flush (u->s);\n-      struncate (u->s);\n+      unit_truncate (u, stell (u->s), &fpp->common);\n       u->endfile = AFTER_ENDFILE;\n-      update_position (u);\n+      if (0 == stell (u->s))\n+        u->flags.position = POSITION_REWIND;\n     done:\n       unlock_unit (u);\n     }\n@@ -347,14 +350,25 @@ st_rewind (st_parameter_filepos *fpp)\n \t       written record is the last record in the file, so truncate the\n \t       file now.  Reset to read mode so two consecutive rewind\n \t       statements do not delete the file contents.  */\n-\t  flush (u->s);\n-\t  if (u->mode == WRITING && u->flags.access != ACCESS_STREAM)\n-\t    struncate (u->s);\n+\t  if (u->mode == WRITING)\n+\t    {\n+\t      /* unit_truncate takes care of flushing.  */\n+\t      unit_truncate (u, stell (u->s), &fpp->common);\n+\t      /* .. but we still need to reset since we're going to seek.  */\n+\t      fbuf_reset (u);\n+\t    }\n+          else\n+            {\n+              /* Make sure buffers are reset.  */\n+              if (u->flags.form == FORM_FORMATTED)\n+                fbuf_reset (u);\n+              sflush (u->s);\n+            }              \n \n \t  u->mode = READING;\n \t  u->last_record = 0;\n \n-\t  if (file_position (u->s) != 0 && sseek (u->s, 0) == FAILURE)\n+\t  if (sseek (u->s, 0, SEEK_SET) < 0)\n \t    generate_error (&fpp->common, LIBERROR_OS, NULL);\n \n \t  /* Handle special files like /dev/null differently.  */\n@@ -366,7 +380,7 @@ st_rewind (st_parameter_filepos *fpp)\n \t  else\n \t    {\n \t      /* Set this for compatibilty with g77 for /dev/null.  */\n-\t      if (file_length (u->s) == 0  && file_position (u->s) == 0)\n+\t      if (file_length (u->s) == 0  && stell (u->s) == 0)\n \t\tu->endfile = AT_ENDFILE;\n \t      /* Future refinements on special files can go here.  */\n \t    }\n@@ -397,7 +411,11 @@ st_flush (st_parameter_filepos *fpp)\n   u = find_unit (fpp->common.unit);\n   if (u != NULL)\n     {\n-      flush (u->s);\n+      /* Make sure format buffer is flushed.  */\n+      if (u->flags.form == FORM_FORMATTED)\n+        fbuf_flush (u, u->mode);\n+\n+      sflush (u->s);\n       unlock_unit (u);\n     }\n   else"}, {"sha": "4e654aec6b50f46116dd3f1c93f2fb37f6d1d26f", "filename": "libgfortran/io/format.c", "status": "modified", "additions": 191, "deletions": 42, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.c?ref=7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"io.h\"\n #include <ctype.h>\n #include <string.h>\n+#include <stdbool.h>\n \n #define FARRAY_SIZE 64\n \n@@ -63,7 +64,7 @@ format_data;\n static const fnode colon_node = { FMT_COLON, 0, NULL, NULL, {{ 0, 0, 0 }}, 0,\n \t\t\t\t  NULL };\n \n-/* Error messages */\n+/* Error messages. */\n \n static const char posint_required[] = \"Positive width required in format\",\n   period_required[] = \"Period required in format\",\n@@ -75,6 +76,129 @@ static const char posint_required[] = \"Positive width required in format\",\n   reversion_error[] = \"Exhausted data descriptors in format\",\n   zero_width[] = \"Zero width in format descriptor\";\n \n+/* The following routines support caching format data from parsed format strings\n+   into a hash table.  This avoids repeatedly parsing duplicate format strings\n+   or format strings in I/O statements that are repeated in loops.  */\n+\n+\n+/* Traverse the table and free all data.  */\n+\n+void\n+free_format_hash_table (gfc_unit *u)\n+{\n+  size_t i;\n+\n+  /* free_format_data handles any NULL pointers.  */\n+  for (i = 0; i < FORMAT_HASH_SIZE; i++)\n+    {\n+      if (u->format_hash_table[i].hashed_fmt != NULL)\n+\tfree_format_data (u->format_hash_table[i].hashed_fmt);\n+      u->format_hash_table[i].hashed_fmt = NULL;\n+    }\n+}\n+\n+/* Traverse the format_data structure and reset the fnode counters.  */\n+\n+static void\n+reset_node (fnode *fn)\n+{\n+  fnode *f;\n+\n+  fn->count = 0;\n+  fn->current = NULL;\n+  \n+  if (fn->format != FMT_LPAREN)\n+    return;\n+\n+  for (f = fn->u.child; f; f = f->next)\n+    {\n+      if (f->format == FMT_RPAREN)\n+\tbreak;\n+      reset_node (f);\n+    }\n+}\n+\n+static void\n+reset_fnode_counters (st_parameter_dt *dtp)\n+{\n+  fnode *f;\n+  format_data *fmt;\n+\n+  fmt = dtp->u.p.fmt;\n+\n+  /* Clear this pointer at the head so things start at the right place.  */\n+  fmt->array.array[0].current = NULL;\n+\n+  for (f = fmt->last->array[0].u.child; f; f = f->next)\n+    reset_node (f);\n+}\n+\n+\n+/* A simple hashing function to generate an index into the hash table.  */\n+\n+static inline\n+uint32_t format_hash (st_parameter_dt *dtp)\n+{\n+  char *key;\n+  size_t key_len;\n+  uint32_t hash = 0;\n+  size_t i;\n+\n+  /* Hash the format string. Super simple, but what the heck!  */\n+  key = dtp->format;\n+  key_len = dtp->format_len;\n+  for (i = 0; i < key_len; i++)\n+    hash ^= key[i];\n+  hash &= (FORMAT_HASH_SIZE - 1);\n+  return hash;\n+}\n+\n+\n+static void\n+save_parsed_format (st_parameter_dt *dtp)\n+{\n+  uint32_t hash;\n+  gfc_unit *u;\n+\n+  hash = format_hash (dtp);\n+  u = dtp->u.p.current_unit;\n+\n+  /* Index into the hash table.  We are simply replacing whatever is there\n+     relying on probability.  */\n+  if (u->format_hash_table[hash].hashed_fmt != NULL)\n+    free_format_data (u->format_hash_table[hash].hashed_fmt);\n+  u->format_hash_table[hash].hashed_fmt = NULL;\n+\n+  u->format_hash_table[hash].key = dtp->format;\n+  u->format_hash_table[hash].key_len = dtp->format_len;\n+  u->format_hash_table[hash].hashed_fmt = dtp->u.p.fmt;\n+}\n+\n+\n+static format_data *\n+find_parsed_format (st_parameter_dt *dtp)\n+{\n+  uint32_t hash;\n+  gfc_unit *u;\n+\n+  hash = format_hash (dtp);\n+  u = dtp->u.p.current_unit;\n+\n+  if (u->format_hash_table[hash].key != NULL)\n+    {\n+      /* See if it matches.  */\n+      if (u->format_hash_table[hash].key_len == dtp->format_len)\n+\t{\n+\t  /* So far so good.  */\n+\t  if (strncmp (u->format_hash_table[hash].key,\n+\t      dtp->format, dtp->format_len) == 0)\n+\t    return u->format_hash_table[hash].hashed_fmt;\n+\t}\n+    }\n+  return NULL;\n+}\n+\n+\n /* next_char()-- Return the next character in the format string.\n  * Returns -1 when the string is done.  If the literal flag is set,\n  * spaces are significant, otherwise they are not. */\n@@ -90,7 +214,8 @@ next_char (format_data *fmt, int literal)\n \treturn -1;\n \n       fmt->format_string_len--;\n-      fmt->error_element = c = toupper (*fmt->format_string++);\n+      c = toupper (*fmt->format_string++);\n+      fmt->error_element = c;\n     }\n   while ((c == ' ' || c == '\\t') && !literal);\n \n@@ -141,10 +266,10 @@ get_fnode (format_data *fmt, fnode **head, fnode **tail, format_token t)\n /* free_format_data()-- Free all allocated format data.  */\n \n void\n-free_format_data (st_parameter_dt *dtp)\n+free_format_data (format_data *fmt)\n {\n   fnode_array *fa, *fa_next;\n-  format_data *fmt = dtp->u.p.fmt;\n+\n \n   if (fmt == NULL)\n     return;\n@@ -156,7 +281,7 @@ free_format_data (st_parameter_dt *dtp)\n     }\n \n   free_mem (fmt);\n-  dtp->u.p.fmt = NULL;\n+  fmt = NULL;\n }\n \n \n@@ -184,6 +309,14 @@ format_lex (format_data *fmt)\n \n   switch (c)\n     {\n+    case '(':\n+      token = FMT_LPAREN;\n+      break;\n+\n+    case ')':\n+      token = FMT_RPAREN;\n+      break;\n+\n     case '-':\n       negative_flag = 1;\n       /* Fall Through */\n@@ -276,14 +409,6 @@ format_lex (format_data *fmt)\n \n       break;\n \n-    case '(':\n-      token = FMT_LPAREN;\n-      break;\n-\n-    case ')':\n-      token = FMT_RPAREN;\n-      break;\n-\n     case 'X':\n       token = FMT_X;\n       break;\n@@ -455,8 +580,10 @@ parse_format_list (st_parameter_dt *dtp)\n   format_token t, u, t2;\n   int repeat;\n   format_data *fmt = dtp->u.p.fmt;\n+  bool save_format;\n \n   head = tail = NULL;\n+  save_format = !is_internal_unit (dtp);\n \n   /* Get the next format item */\n  format_item:\n@@ -567,6 +694,7 @@ parse_format_list (st_parameter_dt *dtp)\n     case FMT_DP:\n       notify_std (&dtp->common, GFC_STD_F2003, \"Fortran 2003: DC or DP \"\n \t\t  \"descriptor not allowed\");\n+      save_format = true;\n     /* Fall through.  */\n     case FMT_S:\n     case FMT_SS:\n@@ -592,6 +720,7 @@ parse_format_list (st_parameter_dt *dtp)\n       get_fnode (fmt, &head, &tail, FMT_DOLLAR);\n       tail->repeat = 1;\n       notify_std (&dtp->common, GFC_STD_GNU, \"Extension: $ descriptor\");\n+      save_format = false;\n       goto between_desc;\n \n \n@@ -689,6 +818,7 @@ parse_format_list (st_parameter_dt *dtp)\n \t      fmt->saved_token = t;\n \t      fmt->value = 1;\t/* Default width */\n \t      notify_std (&dtp->common, GFC_STD_GNU, posint_required);\n+\t      save_format = false;\n \t    }\n \t}\n \n@@ -999,13 +1129,55 @@ format_error (st_parameter_dt *dtp, const fnode *f, const char *message)\n }\n \n \n+/* revert()-- Do reversion of the format.  Control reverts to the left\n+ * parenthesis that matches the rightmost right parenthesis.  From our\n+ * tree structure, we are looking for the rightmost parenthesis node\n+ * at the second level, the first level always being a single\n+ * parenthesis node.  If this node doesn't exit, we use the top\n+ * level. */\n+\n+static void\n+revert (st_parameter_dt *dtp)\n+{\n+  fnode *f, *r;\n+  format_data *fmt = dtp->u.p.fmt;\n+\n+  dtp->u.p.reversion_flag = 1;\n+\n+  r = NULL;\n+\n+  for (f = fmt->array.array[0].u.child; f; f = f->next)\n+    if (f->format == FMT_LPAREN)\n+      r = f;\n+\n+  /* If r is NULL because no node was found, the whole tree will be used */\n+\n+  fmt->array.array[0].current = r;\n+  fmt->array.array[0].count = 0;\n+}\n+\n /* parse_format()-- Parse a format string.  */\n \n void\n parse_format (st_parameter_dt *dtp)\n {\n   format_data *fmt;\n \n+  /* Lookup format string to see if it has already been parsed.  */\n+\n+  dtp->u.p.fmt = find_parsed_format (dtp);\n+\n+  if (dtp->u.p.fmt != NULL)\n+    {\n+      dtp->u.p.fmt->reversion_ok = 0;\n+      dtp->u.p.fmt->saved_token = FMT_NONE;\n+      dtp->u.p.fmt->saved_format = NULL;\n+      reset_fnode_counters (dtp);\n+      return;\n+    }\n+\n+  /* Not found so proceed as follows.  */\n+\n   dtp->u.p.fmt = fmt = get_mem (sizeof (format_data));\n   fmt->format_string = dtp->format;\n   fmt->format_string_len = dtp->format_len;\n@@ -1037,35 +1209,12 @@ parse_format (st_parameter_dt *dtp)\n     fmt->error = \"Missing initial left parenthesis in format\";\n \n   if (fmt->error)\n-    format_error (dtp, NULL, fmt->error);\n-}\n-\n-\n-/* revert()-- Do reversion of the format.  Control reverts to the left\n- * parenthesis that matches the rightmost right parenthesis.  From our\n- * tree structure, we are looking for the rightmost parenthesis node\n- * at the second level, the first level always being a single\n- * parenthesis node.  If this node doesn't exit, we use the top\n- * level. */\n-\n-static void\n-revert (st_parameter_dt *dtp)\n-{\n-  fnode *f, *r;\n-  format_data *fmt = dtp->u.p.fmt;\n-\n-  dtp->u.p.reversion_flag = 1;\n-\n-  r = NULL;\n-\n-  for (f = fmt->array.array[0].u.child; f; f = f->next)\n-    if (f->format == FMT_LPAREN)\n-      r = f;\n-\n-  /* If r is NULL because no node was found, the whole tree will be used */\n-\n-  fmt->array.array[0].current = r;\n-  fmt->array.array[0].count = 0;\n+    {\n+      format_error (dtp, NULL, fmt->error);\n+      free_format_hash_table (dtp->u.p.current_unit);\n+      return;\n+    }\n+  save_parsed_format (dtp);\n }\n \n "}, {"sha": "5e8283b2096a8719925588d7333fd0a906e33d92", "filename": "libgfortran/io/intrinsics.c", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Fintrinsics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Fintrinsics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fintrinsics.c?ref=7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "patch": "@@ -54,13 +54,13 @@ PREFIX(fgetc) (const int * unit, char * c, gfc_charlen_type c_len)\n \n   s = 1;\n   memset (c, ' ', c_len);\n-  ret = sread (u->s, c, &s);\n+  ret = sread (u->s, c, s);\n   unlock_unit (u);\n \n-  if (ret != 0)\n+  if (ret < 0)\n     return ret;\n \n-  if (s != 1)\n+  if (ret != 1)\n     return -1;\n   else\n     return 0;\n@@ -119,17 +119,17 @@ int\n PREFIX(fputc) (const int * unit, char * c,\n \t       gfc_charlen_type c_len __attribute__((unused)))\n {\n-  size_t s;\n-  int ret;\n+  ssize_t s;\n   gfc_unit * u = find_unit (*unit);\n \n   if (u == NULL)\n     return -1;\n \n-  s = 1;\n-  ret = swrite (u->s, c, &s);\n+  s = swrite (u->s, c, 1);\n   unlock_unit (u);\n-  return ret;\n+  if (s < 0)\n+    return -1;\n+  return 0;\n }\n \n \n@@ -196,7 +196,7 @@ flush_i4 (GFC_INTEGER_4 *unit)\n       us = find_unit (*unit);\n       if (us != NULL)\n \t{\n-\t  flush (us->s);\n+\t  sflush (us->s);\n \t  unlock_unit (us);\n \t}\n     }\n@@ -219,7 +219,7 @@ flush_i8 (GFC_INTEGER_8 *unit)\n       us = find_unit (*unit);\n       if (us != NULL)\n \t{\n-\t  flush (us->s);\n+\t  sflush (us->s);\n \t  unlock_unit (us);\n \t}\n     }\n@@ -234,22 +234,17 @@ void\n fseek_sub (int * unit, GFC_IO_INT * offset, int * whence, int * status)\n {\n   gfc_unit * u = find_unit (*unit);\n-  try result = FAILURE;\n+  ssize_t result = -1;\n \n   if (u != NULL && is_seekable(u->s))\n     {\n-      if (*whence == 0)\n-        result = sseek(u->s, *offset);                       /* SEEK_SET */\n-      else if (*whence == 1)\n-        result = sseek(u->s, file_position(u->s) + *offset); /* SEEK_CUR */\n-      else if (*whence == 2)\n-        result = sseek(u->s, file_length(u->s) + *offset);   /* SEEK_END */\n+      result = sseek(u->s, *offset, *whence);\n \n       unlock_unit (u);\n     }\n \n   if (status)\n-    *status = (result == FAILURE ? -1 : 0);\n+    *status = (result < 0 ? -1 : 0);\n }\n \n \n@@ -266,7 +261,7 @@ PREFIX(ftell) (int * unit)\n   size_t ret;\n   if (u == NULL)\n     return ((size_t) -1);\n-  ret = (size_t) stream_offset (u->s);\n+  ret = (size_t) stell (u->s);\n   unlock_unit (u);\n   return ret;\n }\n@@ -282,7 +277,7 @@ PREFIX(ftell) (int * unit)\n       *offset = -1; \\\n     else \\\n       { \\\n-\t*offset = stream_offset (u->s); \\\n+\t*offset = stell (u->s); \\\n \tunlock_unit (u); \\\n       } \\\n   }"}, {"sha": "0be480e07386e49ae3c61632d0d162f0ddd21515", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 106, "deletions": 47, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "patch": "@@ -49,34 +49,59 @@ struct st_parameter_dt;\n \n typedef struct stream\n {\n-  char *(*alloc_w_at) (struct stream *, int *);\n-  try (*sfree) (struct stream *);\n-  try (*close) (struct stream *);\n-  try (*seek) (struct stream *, gfc_offset);\n-  try (*trunc) (struct stream *);\n-  int (*read) (struct stream *, void *, size_t *);\n-  int (*write) (struct stream *, const void *, size_t *);\n-  try (*set) (struct stream *, int, size_t);\n+  ssize_t (*read) (struct stream *, void *, ssize_t);\n+  ssize_t (*write) (struct stream *, const void *, ssize_t);\n+  off_t (*seek) (struct stream *, off_t, int);\n+  off_t (*tell) (struct stream *);\n+  int (*truncate) (struct stream *, off_t);\n+  int (*flush) (struct stream *);\n+  int (*close) (struct stream *);\n }\n stream;\n \n-typedef enum\n-{ SYNC_BUFFERED, SYNC_UNBUFFERED, ASYNC }\n-io_mode;\n+/* Inline functions for doing file I/O given a stream.  */\n+static inline ssize_t\n+sread (stream * s, void * buf, ssize_t nbyte)\n+{\n+  return s->read (s, buf, nbyte);\n+}\n \n-/* Macros for doing file I/O given a stream.  */\n+static inline ssize_t\n+swrite (stream * s, const void * buf, ssize_t nbyte)\n+{\n+  return s->write (s, buf, nbyte);\n+}\n \n-#define sfree(s) ((s)->sfree)(s)\n-#define sclose(s) ((s)->close)(s)\n+static inline off_t\n+sseek (stream * s, off_t offset, int whence)\n+{\n+  return s->seek (s, offset, whence);\n+}\n \n-#define salloc_w(s, len) ((s)->alloc_w_at)(s, len)\n+static inline off_t\n+stell (stream * s)\n+{\n+  return s->tell (s);\n+}\n \n-#define sseek(s, pos) ((s)->seek)(s, pos)\n-#define struncate(s) ((s)->trunc)(s)\n-#define sread(s, buf, nbytes) ((s)->read)(s, buf, nbytes)\n-#define swrite(s, buf, nbytes) ((s)->write)(s, buf, nbytes)\n+static inline int\n+struncate (stream * s, off_t length)\n+{\n+  return s->truncate (s, length);\n+}\n+\n+static inline int\n+sflush (stream * s)\n+{\n+  return s->flush (s);\n+}\n+\n+static inline int\n+sclose (stream * s)\n+{\n+  return s->close (s);\n+}\n \n-#define sset(s, c, n) ((s)->set)(s, c, n)\n \n /* Macros for testing what kinds of I/O we are doing.  */\n \n@@ -106,6 +131,18 @@ typedef struct array_loop_spec\n }\n array_loop_spec;\n \n+/* A stucture to build a hash table for format data.  */\n+\n+#define FORMAT_HASH_SIZE 16 \n+\n+typedef struct format_hash_entry\n+{\n+  char *key;\n+  gfc_charlen_type key_len;\n+  struct format_data *hashed_fmt;\n+}\n+format_hash_entry;\n+\n /* Representation of a namelist object in libgfortran\n \n    Namelist Records\n@@ -127,7 +164,6 @@ array_loop_spec;\n \n typedef struct namelist_type\n {\n-\n   /* Object type, stored as GFC_DTYPE_xxxx.  */\n   bt type;\n \n@@ -538,10 +574,9 @@ unit_flags;\n typedef struct fbuf\n {\n   char *buf;\t\t\t/* Start of buffer.  */\n-  size_t len;\t\t\t/* Length of buffer.  */\n-  size_t act;\t\t\t/* Active bytes in buffer.  */\n-  size_t flushed;\t\t/* Flushed bytes from beginning of buffer.  */\n-  size_t pos;\t\t\t/* Current position in buffer.  */\n+  int len;\t\t\t/* Length of buffer.  */\n+  int act;\t\t\t/* Active bytes in buffer.  */\n+  int pos;\t\t\t/* Current position in buffer.  */\n }\n fbuf;\n \n@@ -599,6 +634,9 @@ typedef struct gfc_unit\n \n   int file_len;\n   char *file;\n+\n+  /* The format hash table.  */\n+  struct format_hash_entry format_hash_table[FORMAT_HASH_SIZE];\n   \n   /* Formatting buffer.  */\n   struct fbuf *fbuf;\n@@ -683,6 +721,12 @@ internal_proto(open_external);\n extern stream *open_internal (char *, int, gfc_offset);\n internal_proto(open_internal);\n \n+extern char * mem_alloc_w (stream *, int *);\n+internal_proto(mem_alloc_w);\n+\n+extern char * mem_alloc_r (stream *, int *);\n+internal_proto(mem_alloc_w);\n+\n extern stream *input_stream (void);\n internal_proto(input_stream);\n \n@@ -698,12 +742,6 @@ internal_proto(compare_file_filename);\n extern gfc_unit *find_file (const char *file, gfc_charlen_type file_len);\n internal_proto(find_file);\n \n-extern int stream_at_bof (stream *);\n-internal_proto(stream_at_bof);\n-\n-extern int stream_at_eof (stream *);\n-internal_proto(stream_at_eof);\n-\n extern int delete_file (gfc_unit *);\n internal_proto(delete_file);\n \n@@ -734,9 +772,6 @@ internal_proto(inquire_readwrite);\n extern gfc_offset file_length (stream *);\n internal_proto(file_length);\n \n-extern gfc_offset file_position (stream *);\n-internal_proto(file_position);\n-\n extern int is_seekable (stream *);\n internal_proto(is_seekable);\n \n@@ -752,18 +787,12 @@ internal_proto(flush_if_preconnected);\n extern void empty_internal_buffer(stream *);\n internal_proto(empty_internal_buffer);\n \n-extern try flush (stream *);\n-internal_proto(flush);\n-\n extern int stream_isatty (stream *);\n internal_proto(stream_isatty);\n \n extern char * stream_ttyname (stream *);\n internal_proto(stream_ttyname);\n \n-extern gfc_offset stream_offset (stream *s);\n-internal_proto(stream_offset);\n-\n extern int unpack_filename (char *, const char *, int);\n internal_proto(unpack_filename);\n \n@@ -807,6 +836,9 @@ internal_proto(update_position);\n extern void finish_last_advance_record (gfc_unit *u);\n internal_proto (finish_last_advance_record);\n \n+extern int unit_truncate (gfc_unit *, gfc_offset, st_parameter_common *);\n+internal_proto (unit_truncate);\n+\n /* open.c */\n \n extern gfc_unit *new_unit (st_parameter_open *, gfc_unit *, unit_flags *);\n@@ -826,17 +858,26 @@ internal_proto(unget_format);\n extern void format_error (st_parameter_dt *, const fnode *, const char *);\n internal_proto(format_error);\n \n-extern void free_format_data (st_parameter_dt *);\n+extern void free_format_data (struct format_data *);\n internal_proto(free_format_data);\n \n+extern void free_format_hash_table (gfc_unit *);\n+internal_proto(free_format_hash_table);\n+\n+extern void init_format_hash (st_parameter_dt *);\n+internal_proto(init_format_hash);\n+\n+extern void free_format_hash (st_parameter_dt *);\n+internal_proto(free_format_hash);\n+\n /* transfer.c */\n \n #define SCRATCH_SIZE 300\n \n extern const char *type_name (bt);\n internal_proto(type_name);\n \n-extern try read_block_form (st_parameter_dt *, void *, size_t *);\n+extern void * read_block_form (st_parameter_dt *, int *);\n internal_proto(read_block_form);\n \n extern char *read_sf (st_parameter_dt *, int *, int);\n@@ -862,6 +903,9 @@ internal_proto (reverse_memcpy);\n extern void st_wait (st_parameter_wait *);\n export_proto(st_wait);\n \n+extern void hit_eof (st_parameter_dt *);\n+internal_proto(hit_eof);\n+\n /* read.c */\n \n extern void set_integer (void *, GFC_INTEGER_LARGEST, int);\n@@ -968,24 +1012,39 @@ extern size_t size_from_complex_kind (int);\n internal_proto(size_from_complex_kind);\n \n /* fbuf.c */\n-extern void fbuf_init (gfc_unit *, size_t);\n+extern void fbuf_init (gfc_unit *, int);\n internal_proto(fbuf_init);\n \n extern void fbuf_destroy (gfc_unit *);\n internal_proto(fbuf_destroy);\n \n-extern void fbuf_reset (gfc_unit *);\n+extern int fbuf_reset (gfc_unit *);\n internal_proto(fbuf_reset);\n \n-extern char * fbuf_alloc (gfc_unit *, size_t);\n+extern char * fbuf_alloc (gfc_unit *, int);\n internal_proto(fbuf_alloc);\n \n-extern int fbuf_flush (gfc_unit *, int);\n+extern int fbuf_flush (gfc_unit *, unit_mode);\n internal_proto(fbuf_flush);\n \n-extern int fbuf_seek (gfc_unit *, gfc_offset);\n+extern int fbuf_seek (gfc_unit *, int, int);\n internal_proto(fbuf_seek);\n \n+extern char * fbuf_read (gfc_unit *, int *);\n+internal_proto(fbuf_read);\n+\n+/* Never call this function, only use fbuf_getc().  */\n+extern int fbuf_getc_refill (gfc_unit *);\n+internal_proto(fbuf_getc_refill);\n+\n+static inline int\n+fbuf_getc (gfc_unit * u)\n+{\n+  if (u->fbuf->pos < u->fbuf->act)\n+    return (unsigned char) u->fbuf->buf[u->fbuf->pos++];\n+  return fbuf_getc_refill (u);\n+}\n+\n /* lock.c */\n extern void free_ionml (st_parameter_dt *);\n internal_proto(free_ionml);"}, {"sha": "1637957245ee5c0a579ae66efb4f7880008a7b00", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "patch": "@@ -33,6 +33,7 @@ Boston, MA 02110-1301, USA.  */\n \n #include \"io.h\"\n #include <string.h>\n+#include <stdlib.h>\n #include <ctype.h>\n \n \n@@ -79,9 +80,8 @@ push_char (st_parameter_dt *dtp, char c)\n \n   if (dtp->u.p.saved_string == NULL)\n     {\n-      if (dtp->u.p.scratch == NULL)\n-\tdtp->u.p.scratch = get_mem (SCRATCH_SIZE);\n-      dtp->u.p.saved_string = dtp->u.p.scratch;\n+      dtp->u.p.saved_string = get_mem (SCRATCH_SIZE);\n+      // memset below should be commented out.\n       memset (dtp->u.p.saved_string, 0, SCRATCH_SIZE);\n       dtp->u.p.saved_length = SCRATCH_SIZE;\n       dtp->u.p.saved_used = 0;\n@@ -90,15 +90,15 @@ push_char (st_parameter_dt *dtp, char c)\n   if (dtp->u.p.saved_used >= dtp->u.p.saved_length)\n     {\n       dtp->u.p.saved_length = 2 * dtp->u.p.saved_length;\n-      new = get_mem (2 * dtp->u.p.saved_length);\n-\n-      memset (new, 0, 2 * dtp->u.p.saved_length);\n-\n-      memcpy (new, dtp->u.p.saved_string, dtp->u.p.saved_used);\n-      if (dtp->u.p.saved_string != dtp->u.p.scratch)\n-\tfree_mem (dtp->u.p.saved_string);\n-\n+      new = realloc (dtp->u.p.saved_string, dtp->u.p.saved_length);\n+      if (new == NULL)\n+\tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n       dtp->u.p.saved_string = new;\n+      \n+      // Also this should not be necessary.\n+      memset (new + dtp->u.p.saved_used, 0, \n+\t      dtp->u.p.saved_length - dtp->u.p.saved_used);\n+\n     }\n \n   dtp->u.p.saved_string[dtp->u.p.saved_used++] = c;\n@@ -113,8 +113,7 @@ free_saved (st_parameter_dt *dtp)\n   if (dtp->u.p.saved_string == NULL)\n     return;\n \n-  if (dtp->u.p.saved_string != dtp->u.p.scratch)\n-    free_mem (dtp->u.p.saved_string);\n+  free_mem (dtp->u.p.saved_string);\n \n   dtp->u.p.saved_string = NULL;\n   dtp->u.p.saved_used = 0;\n@@ -140,9 +139,10 @@ free_line (st_parameter_dt *dtp)\n static char\n next_char (st_parameter_dt *dtp)\n {\n-  size_t length;\n+  ssize_t length;\n   gfc_offset record;\n   char c;\n+  int cc;\n \n   if (dtp->u.p.last_char != '\\0')\n     {\n@@ -194,7 +194,7 @@ next_char (st_parameter_dt *dtp)\n \t    }\n \n \t  record *= dtp->u.p.current_unit->recl;\n-\t  if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n+\t  if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)\n \t    longjmp (*dtp->u.p.eof_jump, 1);\n \n \t  dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n@@ -204,19 +204,15 @@ next_char (st_parameter_dt *dtp)\n \n   /* Get the next character and handle end-of-record conditions.  */\n \n-  length = 1;\n-\n-  if (sread (dtp->u.p.current_unit->s, &c, &length) != 0)\n-    {\n-\tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n-\treturn '\\0';\n-    }\n-  \n-  if (is_stream_io (dtp) && length == 1)\n-    dtp->u.p.current_unit->strm_pos++;\n-\n   if (is_internal_unit (dtp))\n     {\n+      length = sread (dtp->u.p.current_unit->s, &c, 1);\n+      if (length < 0)\n+\t{\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n+\t  return '\\0';\n+\t}\n+  \n       if (is_array_io (dtp))\n \t{\n \t  /* Check whether we hit EOF.  */ \n@@ -240,13 +236,20 @@ next_char (st_parameter_dt *dtp)\n     }\n   else\n     {\n-      if (length == 0)\n+      cc = fbuf_getc (dtp->u.p.current_unit);\n+\n+      if (cc == EOF)\n \t{\n \t  if (dtp->u.p.current_unit->endfile == AT_ENDFILE)\n \t    longjmp (*dtp->u.p.eof_jump, 1);\n \t  dtp->u.p.current_unit->endfile = AT_ENDFILE;\n \t  c = '\\n';\n \t}\n+      else\n+\tc = (char) cc;\n+      if (is_stream_io (dtp) && cc != EOF)\n+\tdtp->u.p.current_unit->strm_pos++;\n+\n     }\n done:\n   dtp->u.p.at_eol = (c == '\\n' || c == '\\r');\n@@ -1698,7 +1701,7 @@ list_formatted_read_scalar (st_parameter_dt *dtp, volatile bt type, void *p,\n       dtp->u.p.input_complete = 0;\n       dtp->u.p.repeat_count = 1;\n       dtp->u.p.at_eol = 0;\n-\n+      \n       c = eat_spaces (dtp);\n       if (is_separator (c))\n \t{\n@@ -1726,6 +1729,9 @@ list_formatted_read_scalar (st_parameter_dt *dtp, volatile bt type, void *p,\n \t    return;\n \t  goto set_value;\n \t}\n+\t\n+      if (dtp->u.p.input_complete)\n+\tgoto cleanup;\n \n       if (dtp->u.p.input_complete)\n \tgoto cleanup;\n@@ -1853,6 +1859,8 @@ finish_list_read (st_parameter_dt *dtp)\n \n   free_saved (dtp);\n \n+  fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n+\n   if (dtp->u.p.at_eol)\n     {\n       dtp->u.p.at_eol = 0;\n@@ -2261,8 +2269,8 @@ nml_query (st_parameter_dt *dtp, char c)\n \n       /* Flush the stream to force immediate output.  */\n \n-      fbuf_flush (dtp->u.p.current_unit, 1);\n-      flush (dtp->u.p.current_unit->s);\n+      fbuf_flush (dtp->u.p.current_unit, WRITING);\n+      sflush (dtp->u.p.current_unit->s);\n       unlock_unit (dtp->u.p.current_unit);\n     }\n \n@@ -2903,7 +2911,7 @@ namelist_read (st_parameter_dt *dtp)\n \t  st_printf (\"%s\\n\", nml_err_msg);\n \t  if (u != NULL)\n \t    {\n-\t      flush (u->s);\n+\t      sflush (u->s);\n \t      unlock_unit (u);\n \t    }\n         }"}, {"sha": "7caa1c9ffdc0a8184d84be9175bbe59e261f46b6", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "patch": "@@ -155,7 +155,7 @@ static const st_option async_opt[] =\n static void\n test_endfile (gfc_unit * u)\n {\n-  if (u->endfile == NO_ENDFILE && file_length (u->s) == file_position (u->s))\n+  if (u->endfile == NO_ENDFILE && file_length (u->s) == stell (u->s))\n     u->endfile = AT_ENDFILE;\n }\n \n@@ -271,7 +271,7 @@ edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n       break;\n \n     case POSITION_REWIND:\n-      if (sseek (u->s, 0) == FAILURE)\n+      if (sseek (u->s, 0, SEEK_SET) != 0)\n \tgoto seek_error;\n \n       u->current_record = 0;\n@@ -281,7 +281,7 @@ edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n       break;\n \n     case POSITION_APPEND:\n-      if (sseek (u->s, file_length (u->s)) == FAILURE)\n+      if (sseek (u->s, 0, SEEK_END) < 0)\n \tgoto seek_error;\n \n       if (flags->access != ACCESS_STREAM)\n@@ -557,7 +557,7 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n \n   if (flags->position == POSITION_APPEND)\n     {\n-      if (sseek (u->s, file_length (u->s)) == FAILURE)\n+      if (sseek (u->s, 0, SEEK_END) < 0)\n \tgenerate_error (&opp->common, LIBERROR_OS, NULL);\n       u->endfile = AT_ENDFILE;\n     }\n@@ -611,7 +611,8 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n     {\n       u->maxrec = max_offset;\n       u->recl = 1;\n-      u->strm_pos = file_position (u->s) + 1;\n+      u->bytes_left = 1;\n+      u->strm_pos = stell (u->s) + 1;\n     }\n \n   memmove (u->file, opp->file, opp->file_len);\n@@ -627,7 +628,7 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n   if (flags->status == STATUS_SCRATCH && opp->file != NULL)\n     free_mem (opp->file);\n     \n-  if (flags->form == FORM_FORMATTED && (flags->action != ACTION_READ))\n+  if (flags->form == FORM_FORMATTED)\n     {\n       if ((opp->common.flags & IOPARM_OPEN_HAS_RECL_IN))\n         fbuf_init (u, u->recl);"}, {"sha": "b651665944f93b91b695ef8febcd030681798205", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 221, "deletions": 269, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "patch": "@@ -33,6 +33,7 @@ Boston, MA 02110-1301, USA.  */\n #include <errno.h>\n #include <ctype.h>\n #include <stdlib.h>\n+#include <assert.h>\n \n typedef unsigned char uchar;\n \n@@ -141,38 +142,30 @@ convert_real (st_parameter_dt *dtp, void *dest, const char *buffer, int length)\n   switch (length)\n     {\n     case 4:\n-      {\n-\tGFC_REAL_4 tmp =\n+      *((GFC_REAL_4*) dest) =\n #if defined(HAVE_STRTOF)\n-\t  strtof (buffer, NULL);\n+\tstrtof (buffer, NULL);\n #else\n-\t  (GFC_REAL_4) strtod (buffer, NULL);\n+\t(GFC_REAL_4) strtod (buffer, NULL);\n #endif\n-\tmemcpy (dest, (void *) &tmp, length);\n-      }\n       break;\n+\n     case 8:\n-      {\n-\tGFC_REAL_8 tmp = strtod (buffer, NULL);\n-\tmemcpy (dest, (void *) &tmp, length);\n-      }\n+      *((GFC_REAL_8*) dest) = strtod (buffer, NULL);\n       break;\n+\n #if defined(HAVE_GFC_REAL_10) && defined (HAVE_STRTOLD)\n     case 10:\n-      {\n-\tGFC_REAL_10 tmp = strtold (buffer, NULL);\n-\tmemcpy (dest, (void *) &tmp, length);\n-      }\n+      *((GFC_REAL_10*) dest) = strtold (buffer, NULL);\n       break;\n #endif\n+\n #if defined(HAVE_GFC_REAL_16) && defined (HAVE_STRTOLD)\n     case 16:\n-      {\n-\tGFC_REAL_16 tmp = strtold (buffer, NULL);\n-\tmemcpy (dest, (void *) &tmp, length);\n-      }\n+      *((GFC_REAL_16*) dest) = strtold (buffer, NULL);\n       break;\n #endif\n+\n     default:\n       internal_error (&dtp->common, \"Unsupported real kind during IO\");\n     }\n@@ -195,13 +188,13 @@ void\n read_l (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n {\n   char *p;\n-  size_t w;\n+  int w;\n \n   w = f->u.w;\n \n-  p = gfc_alloca (w);\n+  p = read_block_form (dtp, &w);\n \n-  if (read_block_form (dtp, p, &w) == FAILURE)\n+  if (p == NULL)\n     return;\n \n   while (*p == ' ')\n@@ -238,28 +231,26 @@ read_l (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n }\n \n \n-static inline gfc_char4_t\n-read_utf8 (st_parameter_dt *dtp, size_t *nbytes) \n+static gfc_char4_t\n+read_utf8 (st_parameter_dt *dtp, int *nbytes) \n {\n   static const uchar masks[6] = { 0x7F, 0x1F, 0x0F, 0x07, 0x02, 0x01 };\n   static const uchar patns[6] = { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n-  static uchar buffer[6];\n-  size_t i, nb, nread;\n+  int i, nb, nread;\n   gfc_char4_t c;\n-  int status;\n   char *s;\n \n   *nbytes = 1;\n-  s = (char *) &buffer[0];\n-  status = read_block_form (dtp, s, nbytes);\n-  if (status == FAILURE)\n+\n+  s = read_block_form (dtp, nbytes);\n+  if (s == NULL)\n     return 0;\n \n   /* If this is a short read, just return.  */\n   if (*nbytes == 0)\n     return 0;\n \n-  c = buffer[0];\n+  c = (uchar) s[0];\n   if (c < 0x80)\n     return c;\n \n@@ -274,9 +265,8 @@ read_utf8 (st_parameter_dt *dtp, size_t *nbytes)\n   c = (c & masks[nb-1]);\n   nread = nb - 1;\n \n-  s = (char *) &buffer[1];\n-  status = read_block_form (dtp, s, &nread);\n-  if (status == FAILURE)\n+  s = read_block_form (dtp, &nread);\n+  if (s == NULL)\n     return 0;\n   /* Decode the bytes read.  */\n   for (i = 1; i < nb; i++)\n@@ -309,14 +299,14 @@ read_utf8 (st_parameter_dt *dtp, size_t *nbytes)\n \n \n static void\n-read_utf8_char1 (st_parameter_dt *dtp, char *p, int len, size_t width)\n+read_utf8_char1 (st_parameter_dt *dtp, char *p, int len, int width)\n {\n   gfc_char4_t c;\n   char *dest;\n-  size_t nbytes;\n+  int nbytes;\n   int i, j;\n \n-  len = ((int) width < len) ? len : (int) width;\n+  len = (width < len) ? len : width;\n \n   dest = (char *) p;\n \n@@ -339,21 +329,19 @@ read_utf8_char1 (st_parameter_dt *dtp, char *p, int len, size_t width)\n }\n \n static void\n-read_default_char1 (st_parameter_dt *dtp, char *p, int len, size_t width)\n+read_default_char1 (st_parameter_dt *dtp, char *p, int len, int width)\n {\n   char *s;\n-  int m, n, status;\n+  int m, n;\n \n-  s = gfc_alloca (width);\n-\n-  status = read_block_form (dtp, s, &width);\n+  s = read_block_form (dtp, &width);\n   \n-  if (status == FAILURE)\n+  if (s == NULL)\n     return;\n-  if (width > (size_t) len)\n+  if (width > len)\n      s += (width - len);\n \n-  m = ((int) width > len) ? len : (int) width;\n+  m = (width > len) ? len : width;\n   memcpy (p, s, m);\n \n   n = len - width;\n@@ -363,13 +351,13 @@ read_default_char1 (st_parameter_dt *dtp, char *p, int len, size_t width)\n \n \n static void\n-read_utf8_char4 (st_parameter_dt *dtp, void *p, int len, size_t width)\n+read_utf8_char4 (st_parameter_dt *dtp, void *p, int len, int width)\n {\n   gfc_char4_t *dest;\n-  size_t nbytes;\n+  int nbytes;\n   int i, j;\n \n-  len = ((int) width < len) ? len : (int) width;\n+  len = (width < len) ? len : width;\n \n   dest = (gfc_char4_t *) p;\n \n@@ -391,19 +379,17 @@ read_utf8_char4 (st_parameter_dt *dtp, void *p, int len, size_t width)\n \n \n static void\n-read_default_char4 (st_parameter_dt *dtp, char *p, int len, size_t width)\n+read_default_char4 (st_parameter_dt *dtp, char *p, int len, int width)\n {\n   char *s;\n   gfc_char4_t *dest;\n-  int m, n, status;\n-\n-  s = gfc_alloca (width);\n+  int m, n;\n \n-  status = read_block_form (dtp, s, &width);\n+  s = read_block_form (dtp, &width);\n   \n-  if (status == FAILURE)\n+  if (s == NULL)\n     return;\n-  if (width > (size_t) len)\n+  if (width > len)\n      s += (width - len);\n \n   m = ((int) width > len) ? len : (int) width;\n@@ -425,7 +411,7 @@ void\n read_a (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n {\n   int wi;\n-  size_t w;\n+  int w;\n \n   wi = f->u.w;\n   if (wi == -1) /* '(A)' edit descriptor  */\n@@ -451,13 +437,11 @@ read_a (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n void\n read_a_char4 (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n {\n-  int wi;\n-  size_t w;\n+  int w;\n \n-  wi = f->u.w;\n-  if (wi == -1) /* '(A)' edit descriptor  */\n-    wi = length;\n-  w = wi;\n+  w = f->u.w;\n+  if (w == -1) /* '(A)' edit descriptor  */\n+    w = length;\n \n   /* Read in w characters, treating comma as not a separator.  */\n   dtp->u.p.sf_read_comma = 0;\n@@ -532,18 +516,15 @@ read_decimal (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n   GFC_UINTEGER_LARGEST value, maxv, maxv_10;\n   GFC_INTEGER_LARGEST v;\n   int w, negative; \n-  size_t wu;\n   char c, *p;\n \n-  wu = f->u.w;\n+  w = f->u.w;\n \n-  p = gfc_alloca (wu);\n+  p = read_block_form (dtp, &w);\n \n-  if (read_block_form (dtp, p, &wu) == FAILURE)\n+  if (p == NULL)\n     return;\n \n-  w = wu;\n-\n   p = eat_leading_spaces (&w, p);\n   if (w == 0)\n     {\n@@ -636,17 +617,14 @@ read_radix (st_parameter_dt *dtp, const fnode *f, char *dest, int length,\n   GFC_INTEGER_LARGEST v;\n   int w, negative;\n   char c, *p;\n-  size_t wu;\n \n-  wu = f->u.w;\n+  w = f->u.w;\n \n-  p = gfc_alloca (wu);\n+  p = read_block_form (dtp, &w);\n \n-  if (read_block_form (dtp, p, &wu) == FAILURE)\n+  if (p == NULL)\n     return;\n \n-  w = wu;\n-\n   p = eat_leading_spaces (&w, p);\n   if (w == 0)\n     {\n@@ -783,75 +761,83 @@ read_radix (st_parameter_dt *dtp, const fnode *f, char *dest, int length,\n void\n read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n {\n-  size_t wu;\n   int w, seen_dp, exponent;\n-  int exponent_sign, val_sign;\n-  int ndigits;\n-  int edigits;\n-  int i;\n-  char *p, *buffer;\n-  char *digits;\n-  char scratch[SCRATCH_SIZE];\n-\n-  val_sign = 1;\n-  seen_dp = 0;\n-  wu = f->u.w;\n+  int exponent_sign;\n+  const char *p;\n+  char *buffer;\n+  char *out;\n+  int seen_int_digit; /* Seen a digit before the decimal point?  */\n+  int seen_dec_digit; /* Seen a digit after the decimal point?  */\n \n-  p = gfc_alloca (wu);\n+  seen_dp = 0;\n+  seen_int_digit = 0;\n+  seen_dec_digit = 0;\n+  exponent_sign = 1;\n+  exponent = 0;\n+  w = f->u.w;\n \n-  if (read_block_form (dtp, p, &wu) == FAILURE)\n+  /* Read in the next block.  */\n+  p = read_block_form (dtp, &w);\n+  if (p == NULL)\n     return;\n-\n-  w = wu;\n-\n-  p = eat_leading_spaces (&w, p);\n+  p = eat_leading_spaces (&w, (char*) p);\n   if (w == 0)\n     goto zero;\n \n-  /* Optional sign */\n+  /* In this buffer we're going to re-format the number cleanly to be parsed\n+     by convert_real in the end; this assures we're using strtod from the\n+     C library for parsing and thus probably get the best accuracy possible.\n+     This process may add a '+0.0' in front of the number as well as change the\n+     exponent because of an implicit decimal point or the like.  Thus allocating\n+     strlen (\"+0.0e-1000\") == 10 characters plus one for NUL more than the\n+     original buffer had should be enough.  */\n+  buffer = gfc_alloca (w + 11);\n+  out = buffer;\n \n+  /* Optional sign */\n   if (*p == '-' || *p == '+')\n     {\n       if (*p == '-')\n-        val_sign = -1;\n-      p++;\n-      w--;\n+\t*(out++) = '-';\n+      ++p;\n+      --w;\n     }\n \n-  exponent_sign = 1;\n-  p = eat_leading_spaces (&w, p);\n+  p = eat_leading_spaces (&w, (char*) p);\n   if (w == 0)\n     goto zero;\n \n-  /* A digit, a '.' or a exponent character ('e', 'E', 'd' or 'D')\n-     is required at this point */\n-\n-  if (!isdigit (*p) && *p != '.' && *p != ',' && *p != 'd' && *p != 'D'\n-      && *p != 'e' && *p != 'E')\n-    goto bad_float;\n-\n-  /* Remember the position of the first digit.  */\n-  digits = p;\n-  ndigits = 0;\n-\n-  /* Scan through the string to find the exponent.  */\n+  /* Process the mantissa string.  */\n   while (w > 0)\n     {\n       switch (*p)\n \t{\n \tcase ',':\n-\t  if (dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA\n-               && *p == ',')\n-\t    *p = '.';\n-\t  else\n+\t  if (dtp->u.p.current_unit->decimal_status != DECIMAL_COMMA)\n \t    goto bad_float;\n-\t  /* Fall through */\n+\t  /* Fall through.  */\n \tcase '.':\n \t  if (seen_dp)\n \t    goto bad_float;\n+\t  if (!seen_int_digit)\n+\t    *(out++) = '0';\n+\t  *(out++) = '.';\n \t  seen_dp = 1;\n-\t  /* Fall through */\n+\t  break;\n \n+\tcase ' ':\n+\t  if (dtp->u.p.blank_status == BLANK_ZERO)\n+\t    {\n+\t      *(out++) = '0';\n+\t      goto found_digit;\n+\t    }\n+\t  else if (dtp->u.p.blank_status == BLANK_NULL)\n+\t    break;\n+\t  else\n+\t    /* TODO: Should we check instead that there are only trailing\n+\t       blanks here, as is done below for exponents?  */\n+\t    goto done;\n+\t  /* Fall through.  */\n \tcase '0':\n \tcase '1':\n \tcase '2':\n@@ -862,207 +848,173 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n \tcase '7':\n \tcase '8':\n \tcase '9':\n-\tcase ' ':\n-\t  ndigits++;\n-\t  p++;\n-\t  w--;\n+\t  *(out++) = *p;\n+found_digit:\n+\t  if (!seen_dp)\n+\t    seen_int_digit = 1;\n+\t  else\n+\t    seen_dec_digit = 1;\n \t  break;\n \n \tcase '-':\n-\t  exponent_sign = -1;\n-\t  /* Fall through */\n-\n \tcase '+':\n-\t  p++;\n-\t  w--;\n-\t  goto exp2;\n+\t  goto exponent;\n \n-\tcase 'd':\n \tcase 'e':\n-\tcase 'D':\n \tcase 'E':\n-\t  p++;\n-\t  w--;\n-\t  goto exp1;\n+\tcase 'd':\n+\tcase 'D':\n+\t  ++p;\n+\t  --w;\n+\t  goto exponent;\n \n \tdefault:\n \t  goto bad_float;\n \t}\n-    }\n \n-  /* No exponent has been seen, so we use the current scale factor */\n-  exponent = -dtp->u.p.scale_factor;\n-  goto done;\n-\n- bad_float:\n-  generate_error (&dtp->common, LIBERROR_READ_VALUE,\n-\t\t  \"Bad value during floating point read\");\n-  next_record (dtp, 1);\n-  return;\n-\n-  /* The value read is zero */\n- zero:\n-  switch (length)\n-    {\n-      case 4:\n-\t*((GFC_REAL_4 *) dest) = 0;\n-\tbreak;\n-\n-      case 8:\n-\t*((GFC_REAL_8 *) dest) = 0;\n-\tbreak;\n-\n-#ifdef HAVE_GFC_REAL_10\n-      case 10:\n-\t*((GFC_REAL_10 *) dest) = 0;\n-\tbreak;\n-#endif\n-\n-#ifdef HAVE_GFC_REAL_16\n-      case 16:\n-\t*((GFC_REAL_16 *) dest) = 0;\n-\tbreak;\n-#endif\n-\n-      default:\n-\tinternal_error (&dtp->common, \"Unsupported real kind during IO\");\n+      ++p;\n+      --w;\n     }\n-  return;\n+  \n+  /* No exponent has been seen, so we use the current scale factor.  */\n+  exponent = - dtp->u.p.scale_factor;\n+  goto done;\n \n-  /* At this point the start of an exponent has been found */\n- exp1:\n-  while (w > 0 && *p == ' ')\n+  /* At this point the start of an exponent has been found.  */\n+exponent:\n+  p = eat_leading_spaces (&w, (char*) p);\n+  if (*p == '-' || *p == '+')\n     {\n-      w--;\n-      p++;\n+      if (*p == '-')\n+\texponent_sign = -1;\n+      ++p;\n+      --w;\n     }\n \n-  switch (*p)\n-    {\n-    case '-':\n-      exponent_sign = -1;\n-      /* Fall through */\n-\n-    case '+':\n-      p++;\n-      w--;\n-      break;\n-    }\n+  /* At this point a digit string is required.  We calculate the value\n+     of the exponent in order to take account of the scale factor and\n+     the d parameter before explict conversion takes place.  */\n \n   if (w == 0)\n     goto bad_float;\n \n-  /* At this point a digit string is required.  We calculate the value\n-     of the exponent in order to take account of the scale factor and\n-     the d parameter before explict conversion takes place. */\n- exp2:\n-  /* Normal processing of exponent */\n-  exponent = 0;\n   if (dtp->u.p.blank_status == BLANK_UNSPECIFIED)\n     {\n       while (w > 0 && isdigit (*p))\n-        {\n-          exponent = 10 * exponent + *p - '0';\n-          p++;\n-          w--;\n-        }\n-        \n-      /* Only allow trailing blanks */\n-\n+\t{\n+\t  exponent *= 10;\n+\t  exponent += *p - '0';\n+\t  ++p;\n+\t  --w;\n+\t}\n+\t\n+      /* Only allow trailing blanks.  */\n       while (w > 0)\n-        {\n-          if (*p != ' ')\n+\t{\n+\t  if (*p != ' ')\n \t    goto bad_float;\n-          p++;\n-          w--;\n-        }\n+\t  ++p;\n+\t  --w;\n+\t}\n     }    \n-  else  /* BZ or BN status is enabled */\n+  else  /* BZ or BN status is enabled.  */\n     {\n       while (w > 0)\n-        {\n-          if (*p == ' ')\n-            {\n-\t      if (dtp->u.p.blank_status == BLANK_ZERO) *p = '0';\n-\t      if (dtp->u.p.blank_status == BLANK_NULL)\n-                {\n-                  p++;\n-                  w--;\n-                  continue;\n-                }\n-            }\n-          else if (!isdigit (*p))\n-            goto bad_float;\n-\n-          exponent = 10 * exponent + *p - '0';\n-          p++;\n-          w--;\n-        }\n+\t{\n+\t  if (*p == ' ')\n+\t    {\n+\t      if (dtp->u.p.blank_status == BLANK_ZERO)\n+\t\texponent *= 10;\n+\t      else\n+\t\tassert (dtp->u.p.blank_status == BLANK_NULL);\n+\t    }\n+\t  else if (!isdigit (*p))\n+\t    goto bad_float;\n+\t  else\n+\t    {\n+\t      exponent *= 10;\n+\t      exponent += *p - '0';\n+\t    }\n+\n+\t  ++p;\n+\t  --w;\n+\t}\n     }\n \n-  exponent = exponent * exponent_sign;\n+  exponent *= exponent_sign;\n \n- done:\n+done:\n   /* Use the precision specified in the format if no decimal point has been\n      seen.  */\n   if (!seen_dp)\n     exponent -= f->u.real.d;\n \n-  if (exponent > 0)\n-    {\n-      edigits = 2;\n-      i = exponent;\n-    }\n-  else\n-    {\n-      edigits = 3;\n-      i = -exponent;\n-    }\n+  /* Output a trailing '0' after decimal point if not yet found.  */\n+  if (seen_dp && !seen_dec_digit)\n+    *(out++) = '0';\n \n-  while (i >= 10)\n+  /* Print out the exponent to finish the reformatted number.  Maximum 4\n+     digits for the exponent.  */\n+  if (exponent != 0)\n     {\n-      i /= 10;\n-      edigits++;\n-    }\n+      int dig;\n \n-  i = ndigits + edigits + 1;\n-  if (val_sign < 0)\n-    i++;\n+      *(out++) = 'e';\n+      if (exponent < 0)\n+\t{\n+\t  *(out++) = '-';\n+\t  exponent = - exponent;\n+\t}\n \n-  if (i < SCRATCH_SIZE) \n-    buffer = scratch;\n-  else\n-    buffer = get_mem (i);\n-\n-  /* Reformat the string into a temporary buffer.  As we're using atof it's\n-     easiest to just leave the decimal point in place.  */\n-  p = buffer;\n-  if (val_sign < 0)\n-    *(p++) = '-';\n-  for (; ndigits > 0; ndigits--)\n-    {\n-      if (*digits == ' ')\n-        {\n-\t  if (dtp->u.p.blank_status == BLANK_ZERO) *digits = '0';\n-\t  if (dtp->u.p.blank_status == BLANK_NULL)\n-            {\n-              digits++;\n-              continue;\n-            } \n-        }\n-      *p = *digits;\n-      p++;\n-      digits++;\n+      assert (exponent < 10000);\n+      for (dig = 3; dig >= 0; --dig)\n+\t{\n+\t  out[dig] = (char) ('0' + exponent % 10);\n+\t  exponent /= 10;\n+\t}\n+      out += 4;\n     }\n-  *(p++) = 'e';\n-  sprintf (p, \"%d\", exponent);\n+  *(out++) = '\\0';\n \n   /* Do the actual conversion.  */\n   convert_real (dtp, dest, buffer, length);\n \n-  if (buffer != scratch)\n-     free_mem (buffer);\n+  return;\n \n+  /* The value read is zero.  */\n+zero:\n+  switch (length)\n+    {\n+      case 4:\n+\t*((GFC_REAL_4 *) dest) = 0.0;\n+\tbreak;\n+\n+      case 8:\n+\t*((GFC_REAL_8 *) dest) = 0.0;\n+\tbreak;\n+\n+#ifdef HAVE_GFC_REAL_10\n+      case 10:\n+\t*((GFC_REAL_10 *) dest) = 0.0;\n+\tbreak;\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+      case 16:\n+\t*((GFC_REAL_16 *) dest) = 0.0;\n+\tbreak;\n+#endif\n+\n+      default:\n+\tinternal_error (&dtp->common, \"Unsupported real kind during IO\");\n+    }\n+  return;\n+\n+bad_float:\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE,\n+\t\t  \"Bad value during floating point read\");\n+  next_record (dtp, 1);\n+  return;\n }\n \n "}, {"sha": "7a06c5d12326ab866b5e3912aa96daccb62cc969", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 733, "deletions": 514, "changes": 1247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02110-1301, USA.  */\n #include <string.h>\n #include <assert.h>\n #include <stdlib.h>\n+#include <errno.h>\n \n \n /* Calling conventions:  Data transfer statements are unlike other\n@@ -183,60 +184,58 @@ current_mode (st_parameter_dt *dtp)\n    heap.  Hopefully this won't happen very often.  */\n \n char *\n-read_sf (st_parameter_dt *dtp, int *length, int no_error)\n+read_sf (st_parameter_dt *dtp, int * length, int no_error)\n {\n+  static char *empty_string[0];\n   char *base, *p, q;\n-  int n, crlf;\n-  gfc_offset pos;\n-  size_t readlen;\n+  int n, lorig, memread, seen_comma;\n \n-  if (*length > SCRATCH_SIZE)\n-    dtp->u.p.line_buffer = get_mem (*length);\n-  p = base = dtp->u.p.line_buffer;\n+  /* If we hit EOF previously with the no_error flag set (i.e. X, T,\n+     TR edit descriptors), and we now try to read again, this time\n+     without setting no_error.  */\n+  if (!no_error && dtp->u.p.at_eof)\n+    {\n+      *length = 0;\n+      hit_eof (dtp);\n+      return NULL;\n+    }\n \n   /* If we have seen an eor previously, return a length of 0.  The\n      caller is responsible for correctly padding the input field.  */\n   if (dtp->u.p.sf_seen_eor)\n     {\n       *length = 0;\n-      return base;\n+      /* Just return something that isn't a NULL pointer, otherwise the\n+         caller thinks an error occured.  */\n+      return (char*) empty_string;\n     }\n \n   if (is_internal_unit (dtp))\n     {\n-      readlen = *length;\n-      if (unlikely (sread (dtp->u.p.current_unit->s, p, &readlen) != 0\n-\t\t    || readlen < (size_t) *length))\n+      memread = *length;\n+      base = mem_alloc_r (dtp->u.p.current_unit->s, length);\n+      if (unlikely (memread > *length))\n \t{\n-\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n+          hit_eof (dtp);\n \t  return NULL;\n \t}\n-\t\n+      n = *length;\n       goto done;\n     }\n \n-  readlen = 1;\n-  n = 0;\n+  n = seen_comma = 0;\n \n-  do\n-    {\n-      if (unlikely (sread (dtp->u.p.current_unit->s, &q, &readlen) != 0))\n-        {\n-\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n-\t  return NULL;\n-\t}\n+  /* Read data into format buffer and scan through it.  */\n+  lorig = *length;\n+  base = p = fbuf_read (dtp->u.p.current_unit, length);\n+  if (base == NULL)\n+    return NULL;\n \n-      /* If we have a line without a terminating \\n, drop through to\n-\t EOR below.  */\n-      if (readlen < 1 && n == 0)\n-\t{\n-\t  if (likely (no_error))\n-\t    break;\n-\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n-\t  return NULL;\n-\t}\n+  while (n < *length)\n+    {\n+      q = *p;\n \n-      if (readlen < 1 || q == '\\n' || q == '\\r')\n+      if (q == '\\n' || q == '\\r')\n \t{\n \t  /* Unexpected end of line.  */\n \n@@ -245,23 +244,14 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n \t  if (dtp->u.p.advance_status == ADVANCE_NO || dtp->u.p.seen_dollar)\n \t    dtp->u.p.eor_condition = 1;\n \n-\t  crlf = 0;\n \t  /* If we encounter a CR, it might be a CRLF.  */\n \t  if (q == '\\r') /* Probably a CRLF */\n \t    {\n-\t      readlen = 1;\n-\t      pos = stream_offset (dtp->u.p.current_unit->s);\n-\t      if (unlikely (sread (dtp->u.p.current_unit->s, &q, &readlen)\n-\t\t\t    != 0))\n-\t        {\n-\t\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n-\t\t  return NULL;\n-\t\t}\n-\t      if (q != '\\n' && readlen == 1) /* Not a CRLF after all.  */\n-\t\tsseek (dtp->u.p.current_unit->s, pos);\n-\t      else\n-\t\tcrlf = 1;\n+\t      if (n < *length && *(p + 1) == '\\n')\n+\t\tdtp->u.p.sf_seen_eor = 2;\n \t    }\n+          else\n+            dtp->u.p.sf_seen_eor = 1;\n \n \t  /* Without padding, terminate the I/O statement without assigning\n \t     the value.  With padding, the value still needs to be assigned,\n@@ -275,7 +265,6 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n \t    }\n \n \t  *length = n;\n-\t  dtp->u.p.sf_seen_eor = (crlf ? 2 : 1);\n \t  break;\n \t}\n       /*  Short circuit the read if a comma is found during numeric input.\n@@ -284,23 +273,39 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n       if (q == ',')\n \tif (dtp->u.p.sf_read_comma == 1)\n \t  {\n+            seen_comma = 1;\n \t    notify_std (&dtp->common, GFC_STD_GNU,\n \t\t\t\"Comma in formatted numeric read.\");\n \t    *length = n;\n \t    break;\n \t  }\n \n       n++;\n-      *p++ = q;\n-      dtp->u.p.sf_seen_eor = 0;\n+      p++;\n+    } \n+\n+  fbuf_seek (dtp->u.p.current_unit, n + dtp->u.p.sf_seen_eor + seen_comma, \n+             SEEK_CUR);\n+\n+  /* A short read implies we hit EOF, unless we hit EOR, a comma, or\n+     some other stuff. Set the relevant flags.  */\n+  if (lorig > *length && !dtp->u.p.sf_seen_eor && !seen_comma)\n+    {\n+      if (no_error)\n+        dtp->u.p.at_eof = 1;\n+      else\n+        {\n+          hit_eof (dtp);\n+          return NULL;\n+        }\n     }\n-  while (n < *length);\n \n  done:\n-  dtp->u.p.current_unit->bytes_left -= *length;\n+\n+  dtp->u.p.current_unit->bytes_left -= n;\n \n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-    dtp->u.p.size_used += (GFC_IO_INT) *length;\n+    dtp->u.p.size_used += (GFC_IO_INT) n;\n \n   return base;\n }\n@@ -316,12 +321,11 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n    opened with PAD=YES.  The caller must assume tailing spaces for\n    short reads.  */\n \n-try\n-read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n+void *\n+read_block_form (st_parameter_dt *dtp, int * nbytes)\n {\n   char *source;\n-  size_t nread;\n-  int nb;\n+  int norig;\n \n   if (!is_stream_io (dtp))\n     {\n@@ -338,15 +342,14 @@ read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t\t{\n \t\t  /* Not enough data left.  */\n \t\t  generate_error (&dtp->common, LIBERROR_EOR, NULL);\n-\t\t  return FAILURE;\n+\t\t  return NULL;\n \t\t}\n \t    }\n \n \t  if (unlikely (dtp->u.p.current_unit->bytes_left == 0))\n \t    {\n-\t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\t      generate_error (&dtp->common, LIBERROR_END, NULL);\n-\t      return FAILURE;\n+              hit_eof (dtp);\n+\t      return NULL;\n \t    }\n \n \t  *nbytes = dtp->u.p.current_unit->bytes_left;\n@@ -357,42 +360,36 @@ read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n       (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL ||\n        dtp->u.p.current_unit->flags.access == ACCESS_STREAM))\n     {\n-      nb = *nbytes;\n-      source = read_sf (dtp, &nb, 0);\n-      *nbytes = nb;\n+      source = read_sf (dtp, nbytes, 0);\n       dtp->u.p.current_unit->strm_pos +=\n \t(gfc_offset) (*nbytes + dtp->u.p.sf_seen_eor);\n-      if (source == NULL)\n-\treturn FAILURE;\n-      memcpy (buf, source, *nbytes);\n-      return SUCCESS;\n+      return source;\n     }\n+\n+  /* If we reach here, we can assume it's direct access.  */\n+\n   dtp->u.p.current_unit->bytes_left -= (gfc_offset) *nbytes;\n \n-  nread = *nbytes;\n-  if (unlikely (sread (dtp->u.p.current_unit->s, buf, &nread) != 0))\n-    {\n-      generate_error (&dtp->common, LIBERROR_OS, NULL);\n-      return FAILURE;\n-    }\n+  norig = *nbytes;\n+  source = fbuf_read (dtp->u.p.current_unit, nbytes);\n+  fbuf_seek (dtp->u.p.current_unit, *nbytes, SEEK_CUR);\n \n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-    dtp->u.p.size_used += (GFC_IO_INT) nread;\n+    dtp->u.p.size_used += (GFC_IO_INT) *nbytes;\n \n-  if (nread != *nbytes)\n-    {\t\t\t\t/* Short read, this shouldn't happen.  */\n-      if (likely (dtp->u.p.current_unit->pad_status == PAD_YES))\n-\t*nbytes = nread;\n-      else\n+  if (norig != *nbytes)\n+    {\t\t\t\t\n+      /* Short read, this shouldn't happen.  */\n+      if (!dtp->u.p.current_unit->pad_status == PAD_YES)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_EOR, NULL);\n \t  source = NULL;\n \t}\n     }\n \n-  dtp->u.p.current_unit->strm_pos += (gfc_offset) nread;\n+  dtp->u.p.current_unit->strm_pos += (gfc_offset) *nbytes;\n \n-  return SUCCESS;\n+  return source;\n }\n \n \n@@ -402,18 +399,18 @@ read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n static void\n read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n {\n-  size_t to_read_record;\n-  size_t have_read_record;\n-  size_t to_read_subrecord;\n-  size_t have_read_subrecord;\n+  ssize_t to_read_record;\n+  ssize_t have_read_record;\n+  ssize_t to_read_subrecord;\n+  ssize_t have_read_subrecord;\n   int short_record;\n \n   if (is_stream_io (dtp))\n     {\n       to_read_record = *nbytes;\n-      have_read_record = to_read_record;\n-      if (unlikely (sread (dtp->u.p.current_unit->s, buf, &have_read_record)\n-\t\t    != 0))\n+      have_read_record = sread (dtp->u.p.current_unit->s, buf, \n+\t\t\t\tto_read_record);\n+      if (unlikely (have_read_record < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return;\n@@ -425,7 +422,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t{\n \t  /* Short read,  e.g. if we hit EOF.  For stream files,\n \t   we have to set the end-of-file condition.  */\n-\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n+          hit_eof (dtp);\n \t  return;\n \t}\n       return;\n@@ -448,14 +445,14 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n       dtp->u.p.current_unit->bytes_left -= to_read_record;\n \n-      if (unlikely (sread (dtp->u.p.current_unit->s, buf, &to_read_record)\n-\t\t    != 0))\n+      to_read_record = sread (dtp->u.p.current_unit->s, buf, to_read_record);\n+      if (unlikely (to_read_record < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return;\n \t}\n \n-      if (to_read_record != *nbytes)  \n+      if (to_read_record != (ssize_t) *nbytes)  \n \t{\n \t  /* Short read, e.g. if we hit EOF.  Apparently, we read\n \t   more than was written to the last record.  */\n@@ -475,18 +472,12 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n      until the request has been fulfilled or the record has run out\n      of continuation subrecords.  */\n \n-  if (unlikely (dtp->u.p.current_unit->endfile == AT_ENDFILE))\n-    {\n-      generate_error (&dtp->common, LIBERROR_END, NULL);\n-      return;\n-    }\n-\n   /* Check whether we exceed the total record length.  */\n \n   if (dtp->u.p.current_unit->flags.has_recl\n       && (*nbytes > (size_t) dtp->u.p.current_unit->bytes_left))\n     {\n-      to_read_record = (size_t) dtp->u.p.current_unit->bytes_left;\n+      to_read_record = (ssize_t) dtp->u.p.current_unit->bytes_left;\n       short_record = 1;\n     }\n   else\n@@ -501,7 +492,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n       if (dtp->u.p.current_unit->bytes_left_subrecord\n \t  < (gfc_offset) to_read_record)\n \t{\n-\t  to_read_subrecord = (size_t) dtp->u.p.current_unit->bytes_left_subrecord;\n+\t  to_read_subrecord = (ssize_t) dtp->u.p.current_unit->bytes_left_subrecord;\n \t  to_read_record -= to_read_subrecord;\n \t}\n       else\n@@ -512,9 +503,9 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n       dtp->u.p.current_unit->bytes_left_subrecord -= to_read_subrecord;\n \n-      have_read_subrecord = to_read_subrecord;\n-      if (unlikely (sread (dtp->u.p.current_unit->s, buf + have_read_record,\n-\t\t\t   &have_read_subrecord) != 0))\n+      have_read_subrecord = sread (dtp->u.p.current_unit->s, \n+\t\t\t\t   buf + have_read_record, to_read_subrecord);\n+      if (unlikely (have_read_subrecord) < 0)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return;\n@@ -603,7 +594,7 @@ write_block (st_parameter_dt *dtp, int length)\n \n   if (is_internal_unit (dtp))\n     {\n-    dest = salloc_w (dtp->u.p.current_unit->s, &length);\n+    dest = mem_alloc_w (dtp->u.p.current_unit->s, &length);\n \n     if (dest == NULL)\n       {\n@@ -641,20 +632,22 @@ static try\n write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n {\n \n-  size_t have_written, to_write_subrecord;\n+  ssize_t have_written;\n+  ssize_t to_write_subrecord;\n   int short_record;\n \n   /* Stream I/O.  */\n \n   if (is_stream_io (dtp))\n     {\n-      if (unlikely (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0))\n+      have_written = swrite (dtp->u.p.current_unit->s, buf, nbytes);\n+      if (unlikely (have_written < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return FAILURE;\n \t}\n \n-      dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes; \n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) have_written; \n \n       return SUCCESS;\n     }\n@@ -672,14 +665,15 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n       if (buf == NULL && nbytes == 0)\n \treturn SUCCESS;\n \n-      if (unlikely (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0))\n+      have_written = swrite (dtp->u.p.current_unit->s, buf, nbytes); \n+      if (unlikely (have_written < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return FAILURE;\n \t}\n \n-      dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes;\n-      dtp->u.p.current_unit->bytes_left -= (gfc_offset) nbytes;\n+      dtp->u.p.current_unit->strm_pos += (gfc_offset) have_written;\n+      dtp->u.p.current_unit->bytes_left -= (gfc_offset) have_written;\n \n       return SUCCESS;\n     }\n@@ -709,8 +703,9 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n       dtp->u.p.current_unit->bytes_left_subrecord -=\n \t(gfc_offset) to_write_subrecord;\n \n-      if (unlikely (swrite (dtp->u.p.current_unit->s, buf + have_written,\n-\t\t\t    &to_write_subrecord) != 0))\n+      to_write_subrecord = swrite (dtp->u.p.current_unit->s, \n+\t\t\t\t   buf + have_written, to_write_subrecord);\n+      if (unlikely (to_write_subrecord < 0))\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return FAILURE;\n@@ -920,19 +915,18 @@ require_type (st_parameter_dt *dtp, bt expected, bt actual, const fnode *f)\n }\n \n \n-/* This subroutine is the main loop for a formatted data transfer\n+/* This function is in the main loop for a formatted data transfer\n    statement.  It would be natural to implement this as a coroutine\n    with the user program, but C makes that awkward.  We loop,\n    processing format elements.  When we actually have to transfer\n    data instead of just setting flags, we return control to the user\n-   program which calls a subroutine that supplies the address and type\n+   program which calls a function that supplies the address and type\n    of the next element, then comes back here to process it.  */\n \n static void\n-formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n-\t\t\t   size_t size)\n+formatted_transfer_scalar_read (st_parameter_dt *dtp, bt type, void *p, int kind,\n+\t\t\t\tsize_t size)\n {\n-  char scratch[SCRATCH_SIZE];\n   int pos, bytes_used;\n   const fnode *f;\n   format_token t;\n@@ -959,7 +953,347 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n   dtp->u.p.sf_read_comma =\n     dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA ? 0 : 1;\n \n-  dtp->u.p.line_buffer = scratch;\n+  for (;;)\n+    {\n+      /* If reversion has occurred and there is another real data item,\n+\t then we have to move to the next record.  */\n+      if (dtp->u.p.reversion_flag && n > 0)\n+\t{\n+\t  dtp->u.p.reversion_flag = 0;\n+\t  next_record (dtp, 0);\n+\t}\n+\n+      consume_data_flag = 1;\n+      if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n+\tbreak;\n+\n+      f = next_format (dtp);\n+      if (f == NULL)\n+\t{\n+\t  /* No data descriptors left.  */\n+\t  if (unlikely (n > 0))\n+\t    generate_error (&dtp->common, LIBERROR_FORMAT,\n+\t\t\"Insufficient data descriptors in format after reversion\");\n+\t  return;\n+\t}\n+\n+      t = f->format;\n+\n+      bytes_used = (int)(dtp->u.p.current_unit->recl\n+\t\t   - dtp->u.p.current_unit->bytes_left);\n+\n+      if (is_stream_io(dtp))\n+\tbytes_used = 0;\n+\n+      switch (t)\n+\t{\n+\tcase FMT_I:\n+\t  if (n == 0)\n+\t    goto need_read_data;\n+\t  if (require_type (dtp, BT_INTEGER, type, f))\n+\t    return;\n+\t  read_decimal (dtp, f, p, kind);\n+\t  break;\n+\n+\tcase FMT_B:\n+\t  if (n == 0)\n+\t    goto need_read_data;\n+\t  if (compile_options.allow_std < GFC_STD_GNU\n+              && require_type (dtp, BT_INTEGER, type, f))\n+\t    return;\n+\t  read_radix (dtp, f, p, kind, 2);\n+\t  break;\n+\n+\tcase FMT_O:\n+\t  if (n == 0)\n+\t    goto need_read_data; \n+\t  if (compile_options.allow_std < GFC_STD_GNU\n+              && require_type (dtp, BT_INTEGER, type, f))\n+\t    return;\n+\t  read_radix (dtp, f, p, kind, 8);\n+\t  break;\n+\n+\tcase FMT_Z:\n+\t  if (n == 0)\n+\t    goto need_read_data;\n+\t  if (compile_options.allow_std < GFC_STD_GNU\n+              && require_type (dtp, BT_INTEGER, type, f))\n+\t    return;\n+\t  read_radix (dtp, f, p, kind, 16);\n+\t  break;\n+\n+\tcase FMT_A:\n+\t  if (n == 0)\n+\t    goto need_read_data;\n+\n+\t  /* It is possible to have FMT_A with something not BT_CHARACTER such\n+\t     as when writing out hollerith strings, so check both type\n+\t     and kind before calling wide character routines.  */\n+\t  if (type == BT_CHARACTER && kind == 4)\n+\t    read_a_char4 (dtp, f, p, size);\n+\t  else\n+\t    read_a (dtp, f, p, size);\n+\t  break;\n+\n+\tcase FMT_L:\n+\t  if (n == 0)\n+\t    goto need_read_data;\n+\t  read_l (dtp, f, p, kind);\n+\t  break;\n+\n+\tcase FMT_D:\n+\t  if (n == 0)\n+\t    goto need_read_data;\n+\t  if (require_type (dtp, BT_REAL, type, f))\n+\t    return;\n+\t  read_f (dtp, f, p, kind);\n+\t  break;\n+\n+\tcase FMT_E:\n+\t  if (n == 0)\n+\t    goto need_read_data;\n+\t  if (require_type (dtp, BT_REAL, type, f))\n+\t    return;\n+\t  read_f (dtp, f, p, kind);\n+\t  break;\n+\n+\tcase FMT_EN:\n+\t  if (n == 0)\n+\t    goto need_read_data;\n+\t  if (require_type (dtp, BT_REAL, type, f))\n+\t    return;\n+\t  read_f (dtp, f, p, kind);\n+\t  break;\n+\n+\tcase FMT_ES:\n+\t  if (n == 0)\n+\t    goto need_read_data;\n+\t  if (require_type (dtp, BT_REAL, type, f))\n+\t    return;\n+\t  read_f (dtp, f, p, kind);\n+\t  break;\n+\n+\tcase FMT_F:\n+\t  if (n == 0)\n+\t    goto need_read_data;\n+\t  if (require_type (dtp, BT_REAL, type, f))\n+\t    return;\n+\t  read_f (dtp, f, p, kind);\n+\t  break;\n+\n+\tcase FMT_G:\n+\t  if (n == 0)\n+\t    goto need_read_data;\n+\t  switch (type)\n+\t    {\n+\t      case BT_INTEGER:\n+\t\tread_decimal (dtp, f, p, kind);\n+\t\tbreak;\n+\t      case BT_LOGICAL:\n+\t\tread_l (dtp, f, p, kind);\n+\t\tbreak;\n+\t      case BT_CHARACTER:\n+\t\tif (kind == 4)\n+\t\t  read_a_char4 (dtp, f, p, size);\n+\t\telse\n+\t\t  read_a (dtp, f, p, size);\n+\t\tbreak;\n+\t      case BT_REAL:\n+\t\tread_f (dtp, f, p, kind);\n+\t\tbreak;\n+\t      default:\n+\t\tinternal_error (&dtp->common, \"formatted_transfer(): Bad type\");\n+\t    }\n+\t  break;\n+\n+\tcase FMT_STRING:\n+\t  consume_data_flag = 0;\n+\t  format_error (dtp, f, \"Constant string in input format\");\n+\t  return;\n+\n+\t/* Format codes that don't transfer data.  */\n+\tcase FMT_X:\n+\tcase FMT_TR:\n+\t  consume_data_flag = 0;\n+\t  dtp->u.p.skips += f->u.n;\n+\t  pos = bytes_used + dtp->u.p.skips - 1;\n+\t  dtp->u.p.pending_spaces = pos - dtp->u.p.max_pos + 1;\n+\t  read_x (dtp, f->u.n);\n+\t  break;\n+\n+\tcase FMT_TL:\n+\tcase FMT_T:\n+\t  consume_data_flag = 0;\n+\n+\t  if (f->format == FMT_TL)\n+\t    {\n+\t      /* Handle the special case when no bytes have been used yet.\n+\t         Cannot go below zero. */\n+\t      if (bytes_used == 0)\n+\t\t{\n+\t\t  dtp->u.p.pending_spaces -= f->u.n;\n+\t\t  dtp->u.p.skips -= f->u.n;\n+\t\t  dtp->u.p.skips = dtp->u.p.skips < 0 ? 0 : dtp->u.p.skips;\n+\t\t}\n+\n+\t      pos = bytes_used - f->u.n;\n+\t    }\n+\t  else /* FMT_T */\n+\t    pos = f->u.n - 1;\n+\n+\t  /* Standard 10.6.1.1: excessive left tabbing is reset to the\n+\t     left tab limit.  We do not check if the position has gone\n+\t     beyond the end of record because a subsequent tab could\n+\t     bring us back again.  */\n+\t  pos = pos < 0 ? 0 : pos;\n+\n+\t  dtp->u.p.skips = dtp->u.p.skips + pos - bytes_used;\n+\t  dtp->u.p.pending_spaces = dtp->u.p.pending_spaces\n+\t\t\t\t    + pos - dtp->u.p.max_pos;\n+\t  dtp->u.p.pending_spaces = dtp->u.p.pending_spaces < 0\n+\t\t\t\t    ? 0 : dtp->u.p.pending_spaces;\n+\t  if (dtp->u.p.skips == 0)\n+\t    break;\n+\n+\t  /* Adjust everything for end-of-record condition */\n+\t  if (dtp->u.p.sf_seen_eor && !is_internal_unit (dtp))\n+\t    {\n+              dtp->u.p.current_unit->bytes_left -= dtp->u.p.sf_seen_eor;\n+              dtp->u.p.skips -= dtp->u.p.sf_seen_eor;\n+\t      bytes_used = pos;\n+\t      dtp->u.p.sf_seen_eor = 0;\n+\t    }\n+\t  if (dtp->u.p.skips < 0)\n+\t    {\n+              if (is_internal_unit (dtp))  \n+                move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);\n+              else\n+                fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips, SEEK_CUR);\n+\t      dtp->u.p.current_unit->bytes_left -= (gfc_offset) dtp->u.p.skips;\n+\t      dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n+\t    }\n+\t  else\n+\t    read_x (dtp, dtp->u.p.skips);\n+\t  break;\n+\n+\tcase FMT_S:\n+\t  consume_data_flag = 0;\n+\t  dtp->u.p.sign_status = SIGN_S;\n+\t  break;\n+\n+\tcase FMT_SS:\n+\t  consume_data_flag = 0;\n+\t  dtp->u.p.sign_status = SIGN_SS;\n+\t  break;\n+\n+\tcase FMT_SP:\n+\t  consume_data_flag = 0;\n+\t  dtp->u.p.sign_status = SIGN_SP;\n+\t  break;\n+\n+\tcase FMT_BN:\n+\t  consume_data_flag = 0 ;\n+\t  dtp->u.p.blank_status = BLANK_NULL;\n+\t  break;\n+\n+\tcase FMT_BZ:\n+\t  consume_data_flag = 0;\n+\t  dtp->u.p.blank_status = BLANK_ZERO;\n+\t  break;\n+\n+\tcase FMT_DC:\n+\t  consume_data_flag = 0;\n+\t  dtp->u.p.current_unit->decimal_status = DECIMAL_COMMA;\n+\t  break;\n+\n+\tcase FMT_DP:\n+\t  consume_data_flag = 0;\n+\t  dtp->u.p.current_unit->decimal_status = DECIMAL_POINT;\n+\t  break;\n+\n+\tcase FMT_P:\n+\t  consume_data_flag = 0;\n+\t  dtp->u.p.scale_factor = f->u.k;\n+\t  break;\n+\n+\tcase FMT_DOLLAR:\n+\t  consume_data_flag = 0;\n+\t  dtp->u.p.seen_dollar = 1;\n+\t  break;\n+\n+\tcase FMT_SLASH:\n+\t  consume_data_flag = 0;\n+\t  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n+\t  next_record (dtp, 0);\n+\t  break;\n+\n+\tcase FMT_COLON:\n+\t  /* A colon descriptor causes us to exit this loop (in\n+\t     particular preventing another / descriptor from being\n+\t     processed) unless there is another data item to be\n+\t     transferred.  */\n+\t  consume_data_flag = 0;\n+\t  if (n == 0)\n+\t    return;\n+\t  break;\n+\n+\tdefault:\n+\t  internal_error (&dtp->common, \"Bad format node\");\n+\t}\n+\n+      /* Adjust the item count and data pointer.  */\n+\n+      if ((consume_data_flag > 0) && (n > 0))\n+\t{\n+\t  n--;\n+\t  p = ((char *) p) + size;\n+\t}\n+\n+      dtp->u.p.skips = 0;\n+\n+      pos = (int)(dtp->u.p.current_unit->recl - dtp->u.p.current_unit->bytes_left);\n+      dtp->u.p.max_pos = (dtp->u.p.max_pos > pos) ? dtp->u.p.max_pos : pos;\n+    }\n+\n+  return;\n+\n+  /* Come here when we need a data descriptor but don't have one.  We\n+     push the current format node back onto the input, then return and\n+     let the user program call us back with the data.  */\n+ need_read_data:\n+  unget_format (dtp, f);\n+}\n+\n+\n+static void\n+formatted_transfer_scalar_write (st_parameter_dt *dtp, bt type, void *p, int kind,\n+\t\t\t\t size_t size)\n+{\n+  int pos, bytes_used;\n+  const fnode *f;\n+  format_token t;\n+  int n;\n+  int consume_data_flag;\n+\n+  /* Change a complex data item into a pair of reals.  */\n+\n+  n = (p == NULL) ? 0 : ((type != BT_COMPLEX) ? 1 : 2);\n+  if (type == BT_COMPLEX)\n+    {\n+      type = BT_REAL;\n+      size /= 2;\n+    }\n+\n+  /* If there's an EOR condition, we simulate finalizing the transfer\n+     by doing nothing.  */\n+  if (dtp->u.p.eor_condition)\n+    return;\n+\n+  /* Set this flag so that commas in reads cause the read to complete before\n+     the entire field has been read.  The next read field will start right after\n+     the comma in the stream.  (Set to 0 for character reads).  */\n+  dtp->u.p.sf_read_comma =\n+    dtp->u.p.current_unit->decimal_status == DECIMAL_COMMA ? 0 : 1;\n \n   for (;;)\n     {\n@@ -1010,7 +1344,7 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n               if (is_internal_unit (dtp))  \n \t        move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);\n               else\n-                fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips);\n+                fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips, SEEK_CUR);\n \t      dtp->u.p.current_unit->bytes_left -= (gfc_offset) dtp->u.p.skips;\n \t    }\n \t  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n@@ -1029,57 +1363,34 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t    goto need_data;\n \t  if (require_type (dtp, BT_INTEGER, type, f))\n \t    return;\n-\n-\t  if (dtp->u.p.mode == READING)\n-\t    read_decimal (dtp, f, p, kind);\n-\t  else\n-\t    write_i (dtp, f, p, kind);\n-\n+\t  write_i (dtp, f, p, kind);\n \t  break;\n \n \tcase FMT_B:\n \t  if (n == 0)\n \t    goto need_data;\n-\n \t  if (compile_options.allow_std < GFC_STD_GNU\n               && require_type (dtp, BT_INTEGER, type, f))\n \t    return;\n-\n-\t  if (dtp->u.p.mode == READING)\n-\t    read_radix (dtp, f, p, kind, 2);\n-\t  else\n-\t    write_b (dtp, f, p, kind);\n-\n+\t  write_b (dtp, f, p, kind);\n \t  break;\n \n \tcase FMT_O:\n \t  if (n == 0)\n \t    goto need_data; \n-\n \t  if (compile_options.allow_std < GFC_STD_GNU\n               && require_type (dtp, BT_INTEGER, type, f))\n \t    return;\n-\n-\t  if (dtp->u.p.mode == READING)\n-\t    read_radix (dtp, f, p, kind, 8);\n-\t  else\n-\t    write_o (dtp, f, p, kind);\n-\n+\t  write_o (dtp, f, p, kind);\n \t  break;\n \n \tcase FMT_Z:\n \t  if (n == 0)\n \t    goto need_data;\n-\n \t  if (compile_options.allow_std < GFC_STD_GNU\n               && require_type (dtp, BT_INTEGER, type, f))\n \t    return;\n-\n-\t  if (dtp->u.p.mode == READING)\n-\t    read_radix (dtp, f, p, kind, 16);\n-\t  else\n-\t    write_z (dtp, f, p, kind);\n-\n+\t  write_z (dtp, f, p, kind);\n \t  break;\n \n \tcase FMT_A:\n@@ -1089,124 +1400,63 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t  /* It is possible to have FMT_A with something not BT_CHARACTER such\n \t     as when writing out hollerith strings, so check both type\n \t     and kind before calling wide character routines.  */\n-\t  if (dtp->u.p.mode == READING)\n-\t    {\n-\t      if (type == BT_CHARACTER && kind == 4)\n-\t\tread_a_char4 (dtp, f, p, size);\n-\t      else\n-\t\tread_a (dtp, f, p, size);\n-\t    }\n+\t  if (type == BT_CHARACTER && kind == 4)\n+\t    write_a_char4 (dtp, f, p, size);\n \t  else\n-\t    {\n-\t      if (type == BT_CHARACTER && kind == 4)\n-\t\twrite_a_char4 (dtp, f, p, size);\n-\t      else\n-\t\twrite_a (dtp, f, p, size);\n-\t    }\n+\t    write_a (dtp, f, p, size);\n \t  break;\n \n \tcase FMT_L:\n \t  if (n == 0)\n \t    goto need_data;\n-\n-\t  if (dtp->u.p.mode == READING)\n-\t    read_l (dtp, f, p, kind);\n-\t  else\n-\t    write_l (dtp, f, p, kind);\n-\n+\t  write_l (dtp, f, p, kind);\n \t  break;\n \n \tcase FMT_D:\n \t  if (n == 0)\n \t    goto need_data;\n \t  if (require_type (dtp, BT_REAL, type, f))\n \t    return;\n-\n-\t  if (dtp->u.p.mode == READING)\n-\t    read_f (dtp, f, p, kind);\n-\t  else\n-\t    write_d (dtp, f, p, kind);\n-\n+\t  write_d (dtp, f, p, kind);\n \t  break;\n \n \tcase FMT_E:\n \t  if (n == 0)\n \t    goto need_data;\n \t  if (require_type (dtp, BT_REAL, type, f))\n \t    return;\n-\n-\t  if (dtp->u.p.mode == READING)\n-\t    read_f (dtp, f, p, kind);\n-\t  else\n-\t    write_e (dtp, f, p, kind);\n+\t  write_e (dtp, f, p, kind);\n \t  break;\n \n \tcase FMT_EN:\n \t  if (n == 0)\n \t    goto need_data;\n \t  if (require_type (dtp, BT_REAL, type, f))\n \t    return;\n-\n-\t  if (dtp->u.p.mode == READING)\n-\t    read_f (dtp, f, p, kind);\n-\t  else\n-\t    write_en (dtp, f, p, kind);\n-\n+\t  write_en (dtp, f, p, kind);\n \t  break;\n \n \tcase FMT_ES:\n \t  if (n == 0)\n \t    goto need_data;\n \t  if (require_type (dtp, BT_REAL, type, f))\n \t    return;\n-\n-\t  if (dtp->u.p.mode == READING)\n-\t    read_f (dtp, f, p, kind);\n-\t  else\n-\t    write_es (dtp, f, p, kind);\n-\n+\t  write_es (dtp, f, p, kind);\n \t  break;\n \n \tcase FMT_F:\n \t  if (n == 0)\n \t    goto need_data;\n \t  if (require_type (dtp, BT_REAL, type, f))\n \t    return;\n-\n-\t  if (dtp->u.p.mode == READING)\n-\t    read_f (dtp, f, p, kind);\n-\t  else\n-\t    write_f (dtp, f, p, kind);\n-\n+\t  write_f (dtp, f, p, kind);\n \t  break;\n \n \tcase FMT_G:\n \t  if (n == 0)\n \t    goto need_data;\n-\t  if (dtp->u.p.mode == READING)\n-\t    switch (type)\n-\t      {\n-\t      case BT_INTEGER:\n-\t\tread_decimal (dtp, f, p, kind);\n-\t\tbreak;\n-\t      case BT_LOGICAL:\n-\t\tread_l (dtp, f, p, kind);\n-\t\tbreak;\n-\t      case BT_CHARACTER:\n-\t\tif (kind == 4)\n-\t\t  read_a_char4 (dtp, f, p, size);\n-\t\telse\n-\t\t  read_a (dtp, f, p, size);\n-\t\tbreak;\n-\t      case BT_REAL:\n-\t\tread_f (dtp, f, p, kind);\n-\t\tbreak;\n-\t      default:\n-\t\tgoto bad_type;\n-\t      }\n-\t  else\n-\t    switch (type)\n-\t      {\n+\t  switch (type)\n+\t    {\n \t      case BT_INTEGER:\n \t\twrite_i (dtp, f, p, kind);\n \t\tbreak;\n@@ -1221,25 +1471,18 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t\tbreak;\n \t      case BT_REAL:\n \t\tif (f->u.real.w == 0)\n-\t\t  write_real_g0 (dtp, p, kind, f->u.real.d);\n+                  write_real_g0 (dtp, p, kind, f->u.real.d);\n \t\telse\n \t\t  write_d (dtp, f, p, kind);\n \t\tbreak;\n \t      default:\n-\t      bad_type:\n \t\tinternal_error (&dtp->common,\n \t\t\t\t\"formatted_transfer(): Bad type\");\n-\t      }\n-\n+\t    }\n \t  break;\n \n \tcase FMT_STRING:\n \t  consume_data_flag = 0;\n-\t  if (dtp->u.p.mode == READING)\n-\t    {\n-\t      format_error (dtp, f, \"Constant string in input format\");\n-\t      return;\n-\t    }\n \t  write_constant_string (dtp, f);\n \t  break;\n \n@@ -1251,21 +1494,15 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t  dtp->u.p.skips += f->u.n;\n \t  pos = bytes_used + dtp->u.p.skips - 1;\n \t  dtp->u.p.pending_spaces = pos - dtp->u.p.max_pos + 1;\n-\n \t  /* Writes occur just before the switch on f->format, above, so\n \t     that trailing blanks are suppressed, unless we are doing a\n \t     non-advancing write in which case we want to output the blanks\n \t     now.  */\n-\t  if (dtp->u.p.mode == WRITING\n-\t      && dtp->u.p.advance_status == ADVANCE_NO)\n+\t  if (dtp->u.p.advance_status == ADVANCE_NO)\n \t    {\n \t      write_x (dtp, dtp->u.p.skips, dtp->u.p.pending_spaces);\n \t      dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n \t    }\n-\n-\t  if (dtp->u.p.mode == READING)\n-\t    read_x (dtp, f->u.n);\n-\n \t  break;\n \n \tcase FMT_TL:\n@@ -1287,12 +1524,7 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t      pos = bytes_used - f->u.n;\n \t    }\n \t  else /* FMT_T */\n-\t    {\n-\t      if (dtp->u.p.mode == READING)\n-\t\tpos = f->u.n - 1;\n-\t      else\n-\t\tpos = f->u.n - dtp->u.p.pending_spaces - 1;\n-\t    }\n+\t    pos = f->u.n - dtp->u.p.pending_spaces - 1;\n \n \t  /* Standard 10.6.1.1: excessive left tabbing is reset to the\n \t     left tab limit.  We do not check if the position has gone\n@@ -1305,43 +1537,6 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t\t\t\t    + pos - dtp->u.p.max_pos;\n \t  dtp->u.p.pending_spaces = dtp->u.p.pending_spaces < 0\n \t\t\t\t    ? 0 : dtp->u.p.pending_spaces;\n-\n-\t  if (dtp->u.p.skips == 0)\n-\t    break;\n-\n-\t  /* Writes occur just before the switch on f->format, above, so that\n-\t     trailing blanks are suppressed.  */\n-\t  if (dtp->u.p.mode == READING)\n-\t    {\n-\t      /* Adjust everything for end-of-record condition */\n-\t      if (dtp->u.p.sf_seen_eor && !is_internal_unit (dtp))\n-\t\t{\n-\t\t  if (dtp->u.p.sf_seen_eor == 2)\n-\t\t    {\n-\t\t      /* The EOR was a CRLF (two bytes wide).  */\n-\t\t      dtp->u.p.current_unit->bytes_left -= 2;\n-\t\t      dtp->u.p.skips -= 2;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* The EOR marker was only one byte wide.  */\n-\t\t      dtp->u.p.current_unit->bytes_left--;\n-\t\t      dtp->u.p.skips--;\n-\t\t    }\n-\t\t  bytes_used = pos;\n-\t\t  dtp->u.p.sf_seen_eor = 0;\n-\t\t}\n-\t      if (dtp->u.p.skips < 0)\n-\t\t{\n-\t\t  move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);\n-\t\t  dtp->u.p.current_unit->bytes_left\n-\t\t    -= (gfc_offset) dtp->u.p.skips;\n-\t\t  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n-\t\t}\n-\t      else\n-\t\tread_x (dtp, dtp->u.p.skips);\n-\t    }\n-\n \t  break;\n \n \tcase FMT_S:\n@@ -1409,30 +1604,16 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t  internal_error (&dtp->common, \"Bad format node\");\n \t}\n \n-      /* Free a buffer that we had to allocate during a sequential\n-\t formatted read of a block that was larger than the static\n-\t buffer.  */\n-\n-      if (dtp->u.p.line_buffer != scratch)\n-\t{\n-\t  free_mem (dtp->u.p.line_buffer);\n-\t  dtp->u.p.line_buffer = scratch;\n-\t}\n-\n       /* Adjust the item count and data pointer.  */\n \n       if ((consume_data_flag > 0) && (n > 0))\n-      {\n-\tn--;\n-\tp = ((char *) p) + size;\n-      }\n-\n-      if (dtp->u.p.mode == READING)\n-\tdtp->u.p.skips = 0;\n+\t{\n+\t  n--;\n+\t  p = ((char *) p) + size;\n+\t}\n \n       pos = (int)(dtp->u.p.current_unit->recl - dtp->u.p.current_unit->bytes_left);\n       dtp->u.p.max_pos = (dtp->u.p.max_pos > pos) ? dtp->u.p.max_pos : pos;\n-\n     }\n \n   return;\n@@ -1444,6 +1625,7 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n   unget_format (dtp, f);\n }\n \n+\n static void\n formatted_transfer (st_parameter_dt *dtp, bt type, void *p, int kind,\n \t\t    size_t size, size_t nelems)\n@@ -1454,16 +1636,27 @@ formatted_transfer (st_parameter_dt *dtp, bt type, void *p, int kind,\n   tmp = (char *) p;\n   size_t stride = type == BT_CHARACTER ?\n \t\t  size * GFC_SIZE_OF_CHAR_KIND(kind) : size;\n-  /* Big loop over all the elements.  */\n-  for (elem = 0; elem < nelems; elem++)\n+  if (dtp->u.p.mode == READING)\n+    {\n+      /* Big loop over all the elements.  */\n+      for (elem = 0; elem < nelems; elem++)\n+\t{\n+\t  dtp->u.p.item_count++;\n+\t  formatted_transfer_scalar_read (dtp, type, tmp + stride*elem, kind, size);\n+\t}\n+    }\n+  else\n     {\n-      dtp->u.p.item_count++;\n-      formatted_transfer_scalar (dtp, type, tmp + stride*elem, kind, size);\n+      /* Big loop over all the elements.  */\n+      for (elem = 0; elem < nelems; elem++)\n+\t{\n+\t  dtp->u.p.item_count++;\n+\t  formatted_transfer_scalar_write (dtp, type, tmp + stride*elem, kind, size);\n+\t}\n     }\n }\n \n \n-\n /* Data transfer entry points.  The type of the data entity is\n    implicit in the subroutine call.  This prevents us from having to\n    share a common enum with the compiler.  */\n@@ -1657,34 +1850,28 @@ transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n static void\n us_read (st_parameter_dt *dtp, int continued)\n {\n-  size_t n, nr;\n+  ssize_t n, nr;\n   GFC_INTEGER_4 i4;\n   GFC_INTEGER_8 i8;\n   gfc_offset i;\n \n-  if (dtp->u.p.current_unit->endfile == AT_ENDFILE)\n-    return;\n-\n   if (compile_options.record_marker == 0)\n     n = sizeof (GFC_INTEGER_4);\n   else\n     n = compile_options.record_marker;\n \n-  nr = n;\n-\n-  if (unlikely (sread (dtp->u.p.current_unit->s, &i, &n) != 0))\n+  nr = sread (dtp->u.p.current_unit->s, &i, n);\n+  if (unlikely (nr < 0))\n     {\n       generate_error (&dtp->common, LIBERROR_BAD_US, NULL);\n       return;\n     }\n-\n-  if (n == 0)\n+  else if (nr == 0)\n     {\n-      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+      hit_eof (dtp);\n       return;  /* end of file */\n     }\n-\n-  if (unlikely (n != nr))\n+  else if (unlikely (n != nr))\n     {\n       generate_error (&dtp->common, LIBERROR_BAD_US, NULL);\n       return;\n@@ -1750,7 +1937,7 @@ us_read (st_parameter_dt *dtp, int continued)\n static void\n us_write (st_parameter_dt *dtp, int continued)\n {\n-  size_t nbytes;\n+  ssize_t nbytes;\n   gfc_offset dummy;\n \n   dummy = 0;\n@@ -1760,7 +1947,7 @@ us_write (st_parameter_dt *dtp, int continued)\n   else\n     nbytes = compile_options.record_marker ;\n \n-  if (swrite (dtp->u.p.current_unit->s, &dummy, &nbytes) != 0)\n+  if (swrite (dtp->u.p.current_unit->s, &dummy, nbytes) != nbytes)\n     generate_error (&dtp->common, LIBERROR_OS, NULL);\n \n   /* For sequential unformatted, if RECL= was not specified in the OPEN\n@@ -1962,7 +2149,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n       return;\n     }\n \n-  /* Check the record number.  */\n+  /* Check the record or position number.  */\n \n   if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT\n       && (cf & IOPARM_DT_HAS_REC) == 0)\n@@ -2111,65 +2298,71 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   \n   if (dtp->u.p.current_unit->pad_status == PAD_UNSPECIFIED)\n \tdtp->u.p.current_unit->pad_status = dtp->u.p.current_unit->flags.pad;\n-  \n+\n+  /* Check to see if we might be reading what we wrote before  */\n+\n+  if (dtp->u.p.mode != dtp->u.p.current_unit->mode\n+      && !is_internal_unit (dtp))\n+    {\n+      int pos = fbuf_reset (dtp->u.p.current_unit);\n+      if (pos != 0)\n+        sseek (dtp->u.p.current_unit->s, pos, SEEK_CUR);\n+      sflush(dtp->u.p.current_unit->s);\n+    }\n+\n   /* Check the POS= specifier: that it is in range and that it is used with a\n      unit that has been connected for STREAM access. F2003 9.5.1.10.  */\n   \n   if (((cf & IOPARM_DT_HAS_POS) != 0))\n     {\n       if (is_stream_io (dtp))\n-\t{\n-\n-\t  if (dtp->pos <= 0)\n-\t    {\n-\t      generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n-\t\t\t      \"POS=specifier must be positive\");\n-\t      return;\n-\t    }\n-\n-\t  if (dtp->pos >= dtp->u.p.current_unit->maxrec)\n-\t    {\n-\t      generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n-\t\t\t      \"POS=specifier too large\");\n-\t      return;\n-\t    }\n-\n-\t  dtp->rec = dtp->pos;\n-\n-\t  if (dtp->u.p.mode == READING)\n-\t    {\n-\t      /* Required for compatibility between 4.3 and 4.4 runtime. Check\n-\t      to see if we might be reading what we wrote before  */\n-\t      if (dtp->u.p.current_unit->mode == WRITING)\n-\t\t{\n-\t\t  fbuf_flush (dtp->u.p.current_unit, 1);      \n-\t\t  flush(dtp->u.p.current_unit->s);\n-\t\t}\n-\n-\t      if (dtp->pos < file_length (dtp->u.p.current_unit->s))\n-\t\tdtp->u.p.current_unit->endfile = NO_ENDFILE;\n-\t    }\n-\n-\t  if (dtp->pos != dtp->u.p.current_unit->strm_pos)\n-\t    {\n-\t      fbuf_flush (dtp->u.p.current_unit, 1);\n-\t      flush (dtp->u.p.current_unit->s);\n-\t      if (sseek (dtp->u.p.current_unit->s, dtp->pos - 1) == FAILURE)\n-\t\t{\n-\t\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t\t  return;\n-\t\t}\n-\t      dtp->u.p.current_unit->strm_pos = dtp->pos;\n-\t    }\n-\t}\n+        {\n+          \n+          if (dtp->pos <= 0)\n+            {\n+              generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+                              \"POS=specifier must be positive\");\n+              return;\n+            }\n+          \n+          if (dtp->pos >= dtp->u.p.current_unit->maxrec)\n+            {\n+              generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+                              \"POS=specifier too large\");\n+              return;\n+            }\n+          \n+          dtp->rec = dtp->pos;\n+          \n+          if (dtp->u.p.mode == READING)\n+            {\n+              /* Reset the endfile flag; if we hit EOF during reading\n+                 we'll set the flag and generate an error at that point\n+                 rather than worrying about it here.  */\n+              dtp->u.p.current_unit->endfile = NO_ENDFILE;\n+            }\n+         \n+          if (dtp->pos != dtp->u.p.current_unit->strm_pos)\n+            {\n+              fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n+              sflush (dtp->u.p.current_unit->s);\n+              if (sseek (dtp->u.p.current_unit->s, dtp->pos - 1, SEEK_SET) < 0)\n+                {\n+                  generate_error (&dtp->common, LIBERROR_OS, NULL);\n+                  return;\n+                }\n+              dtp->u.p.current_unit->strm_pos = dtp->pos;\n+            }\n+        }\n       else\n-\t{\n-\t  generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n-\t\t\t  \"POS=specifier not allowed, \"\n-\t\t\t  \"Try OPEN with ACCESS='stream'\");\n-\t  return;\n-\t}\n+        {\n+          generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+                          \"POS=specifier not allowed, \"\n+                          \"Try OPEN with ACCESS='stream'\");\n+          return;\n+        }\n     }\n+  \n \n   /* Sanity checks on the record number.  */\n   if ((cf & IOPARM_DT_HAS_REC) != 0)\n@@ -2188,15 +2381,10 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t  return;\n \t}\n \n-      /* Check to see if we might be reading what we wrote before  */\n+      /* Make sure format buffer is reset.  */\n+      if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED)\n+        fbuf_reset (dtp->u.p.current_unit);\n \n-      if (dtp->u.p.mode == READING\n-\t  && dtp->u.p.current_unit->mode == WRITING\n-\t  && !is_internal_unit (dtp))\n-\t{\n-\t  fbuf_flush (dtp->u.p.current_unit, 1);      \n-\t  flush(dtp->u.p.current_unit->s);\n-\t}\n \n       /* Check whether the record exists to be read.  Only\n \t a partial record needs to exist.  */\n@@ -2211,37 +2399,28 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \n       /* Position the file.  */\n       if (sseek (dtp->u.p.current_unit->s, (gfc_offset) (dtp->rec - 1)\n-\t\t * dtp->u.p.current_unit->recl) == FAILURE)\n-\t{\n-\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t  return;\n-\t}\n+                 * dtp->u.p.current_unit->recl, SEEK_SET) < 0)\n+        {\n+          generate_error (&dtp->common, LIBERROR_OS, NULL);\n+          return;\n+        }\n \n       /* TODO: This is required to maintain compatibility between\n-\t 4.3 and 4.4 runtime. Remove when ABI changes from 4.3 */\n+         4.3 and 4.4 runtime. Remove when ABI changes from 4.3 */\n \n       if (is_stream_io (dtp))\n-\tdtp->u.p.current_unit->strm_pos = dtp->rec;\n-      \n+        dtp->u.p.current_unit->strm_pos = dtp->rec;\n+\n       /* TODO: Un-comment this code when ABI changes from 4.3.\n       if (dtp->u.p.current_unit->flags.access == ACCESS_STREAM)\n-\t{\n-\t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n-\t\t      \"Record number not allowed for stream access \"\n-\t\t      \"data transfer\");\n-\t  return;\n-\t}  */\n-\n+       {\n+         generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n+                     \"Record number not allowed for stream access \"\n+                     \"data transfer\");\n+         return;\n+       }  */\n     }\n \n-  /* Overwriting an existing sequential file ?\n-     it is always safe to truncate the file on the first write */\n-  if (dtp->u.p.mode == WRITING\n-      && dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL\n-      && dtp->u.p.current_unit->last_record == 0 \n-      && !is_preconnected(dtp->u.p.current_unit->s))\n-\tstruncate(dtp->u.p.current_unit->s);\n-\n   /* Bugware for badly written mixed C-Fortran I/O.  */\n   flush_if_preconnected(dtp->u.p.current_unit->s);\n \n@@ -2394,8 +2573,8 @@ next_array_record (st_parameter_dt *dtp, array_loop_spec *ls, int *finished)\n static void\n skip_record (st_parameter_dt *dtp, size_t bytes)\n {\n-  gfc_offset new;\n   size_t rlength;\n+  ssize_t readb;\n   static const size_t MAX_READ = 4096;\n   char p[MAX_READ];\n \n@@ -2405,29 +2584,28 @@ skip_record (st_parameter_dt *dtp, size_t bytes)\n \n   if (is_seekable (dtp->u.p.current_unit->s))\n     {\n-      new = file_position (dtp->u.p.current_unit->s)\n-\t+ dtp->u.p.current_unit->bytes_left_subrecord;\n-\n       /* Direct access files do not generate END conditions,\n \t only I/O errors.  */\n-      if (sseek (dtp->u.p.current_unit->s, new) == FAILURE)\n+      if (sseek (dtp->u.p.current_unit->s, \n+\t\t dtp->u.p.current_unit->bytes_left_subrecord, SEEK_CUR) < 0)\n \tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n     }\n   else\n     {\t\t\t/* Seek by reading data.  */\n       while (dtp->u.p.current_unit->bytes_left_subrecord > 0)\n \t{\n \t  rlength = \n-\t    (MAX_READ > (size_t) dtp->u.p.current_unit->bytes_left_subrecord) ?\n+\t    (MAX_READ < (size_t) dtp->u.p.current_unit->bytes_left_subrecord) ?\n \t    MAX_READ : (size_t) dtp->u.p.current_unit->bytes_left_subrecord;\n \n-\t  if (sread (dtp->u.p.current_unit->s, p, &rlength) != 0)\n+\t  readb = sread (dtp->u.p.current_unit->s, p, rlength);\n+\t  if (readb < 0)\n \t    {\n \t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t      return;\n \t    }\n \n-\t  dtp->u.p.current_unit->bytes_left_subrecord -= rlength;\n+\t  dtp->u.p.current_unit->bytes_left_subrecord -= readb;\n \t}\n     }\n \n@@ -2475,8 +2653,8 @@ next_record_r (st_parameter_dt *dtp)\n {\n   gfc_offset record;\n   int bytes_left;\n-  size_t length;\n   char p;\n+  int cc;\n \n   switch (current_mode (dtp))\n     {\n@@ -2496,11 +2674,12 @@ next_record_r (st_parameter_dt *dtp)\n \n     case FORMATTED_STREAM:\n     case FORMATTED_SEQUENTIAL:\n-      length = 1;\n-      /* sf_read has already terminated input because of an '\\n'  */\n-      if (dtp->u.p.sf_seen_eor)\n+      /* read_sf has already terminated input because of an '\\n', or\n+         we have hit EOF.  */\n+      if (dtp->u.p.sf_seen_eor || dtp->u.p.at_eof)\n \t{\n \t  dtp->u.p.sf_seen_eor = 0;\n+          dtp->u.p.at_eof = 0;\n \t  break;\n \t}\n \n@@ -2515,7 +2694,7 @@ next_record_r (st_parameter_dt *dtp)\n \n \t      /* Now seek to this record.  */\n \t      record = record * dtp->u.p.current_unit->recl;\n-\t      if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n+\t      if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)\n \t\t{\n \t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t  break;\n@@ -2527,10 +2706,9 @@ next_record_r (st_parameter_dt *dtp)\n \t      bytes_left = (int) dtp->u.p.current_unit->bytes_left;\n \t      bytes_left = min_off (bytes_left, \n \t\t      file_length (dtp->u.p.current_unit->s)\n-\t\t      - file_position (dtp->u.p.current_unit->s));\n+\t\t      - stell (dtp->u.p.current_unit->s));\n \t      if (sseek (dtp->u.p.current_unit->s, \n-\t\t\t  file_position (dtp->u.p.current_unit->s) \n-\t\t\t  + bytes_left) == FAILURE)\n+\t\t\t bytes_left, SEEK_CUR) < 0)\n \t        {\n \t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t  break;\n@@ -2540,42 +2718,37 @@ next_record_r (st_parameter_dt *dtp)\n \t    } \n \t  break;\n \t}\n-      else do\n+      else \n \t{\n-\t  if (sread (dtp->u.p.current_unit->s, &p, &length) != 0) \n+\t  do\n \t    {\n-\t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t      break;\n-\t    }\n-\n-\t  if (length == 0)\n-\t    {\n-\t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\t      break;\n+              errno = 0;\n+              cc = fbuf_getc (dtp->u.p.current_unit);\n+\t      if (cc == EOF) \n+\t\t{\n+                  if (errno != 0)\n+                    generate_error (&dtp->common, LIBERROR_OS, NULL);\n+                  else\n+                    hit_eof (dtp);\n+\t\t  break;\n+                }\n+\t      \n+\t      if (is_stream_io (dtp))\n+\t\tdtp->u.p.current_unit->strm_pos++;\n+              \n+              p = (char) cc;\n \t    }\n-\n-\t  if (is_stream_io (dtp))\n-\t    dtp->u.p.current_unit->strm_pos++;\n+\t  while (p != '\\n');\n \t}\n-      while (p != '\\n');\n-\n       break;\n     }\n-\n-  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL\n-      && !dtp->u.p.namelist_mode\n-      && dtp->u.p.current_unit->endfile == NO_ENDFILE\n-      && (file_length (dtp->u.p.current_unit->s) ==\n-\t file_position (dtp->u.p.current_unit->s)))\n-    dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\n }\n \n \n /* Small utility function to write a record marker, taking care of\n    byte swapping and of choosing the correct size.  */\n \n-inline static int\n+static int\n write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n {\n   size_t len;\n@@ -2595,12 +2768,12 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n \t{\n \tcase sizeof (GFC_INTEGER_4):\n \t  buf4 = buf;\n-\t  return swrite (dtp->u.p.current_unit->s, &buf4, &len);\n+\t  return swrite (dtp->u.p.current_unit->s, &buf4, len);\n \t  break;\n \n \tcase sizeof (GFC_INTEGER_8):\n \t  buf8 = buf;\n-\t  return swrite (dtp->u.p.current_unit->s, &buf8, &len);\n+\t  return swrite (dtp->u.p.current_unit->s, &buf8, len);\n \t  break;\n \n \tdefault:\n@@ -2615,13 +2788,13 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n \tcase sizeof (GFC_INTEGER_4):\n \t  buf4 = buf;\n \t  reverse_memcpy (p, &buf4, sizeof (GFC_INTEGER_4));\n-\t  return swrite (dtp->u.p.current_unit->s, p, &len);\n+\t  return swrite (dtp->u.p.current_unit->s, p, len);\n \t  break;\n \n \tcase sizeof (GFC_INTEGER_8):\n \t  buf8 = buf;\n \t  reverse_memcpy (p, &buf8, sizeof (GFC_INTEGER_8));\n-\t  return swrite (dtp->u.p.current_unit->s, p, &len);\n+\t  return swrite (dtp->u.p.current_unit->s, p, len);\n \t  break;\n \n \tdefault:\n@@ -2644,7 +2817,7 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n   /* Bytes written.  */\n   m = dtp->u.p.current_unit->recl_subrecord\n     - dtp->u.p.current_unit->bytes_left_subrecord;\n-  c = file_position (dtp->u.p.current_unit->s);\n+  c = stell (dtp->u.p.current_unit->s);\n \n   /* Write the length tail.  If we finish a record containing\n      subrecords, we write out the negative length.  */\n@@ -2654,7 +2827,7 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n   else\n     m_write = m;\n \n-  if (unlikely (write_us_marker (dtp, m_write) != 0))\n+  if (unlikely (write_us_marker (dtp, m_write) < 0))\n     goto io_error;\n \n   if (compile_options.record_marker == 0)\n@@ -2665,22 +2838,22 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n   /* Seek to the head and overwrite the bogus length with the real\n      length.  */\n \n-  if (unlikely (sseek (dtp->u.p.current_unit->s, c - m - record_marker)\n-\t\t== FAILURE))\n+  if (unlikely (sseek (dtp->u.p.current_unit->s, c - m - record_marker, \n+\t\t       SEEK_SET) < 0))\n     goto io_error;\n \n   if (next_subrecord)\n     m_write = -m;\n   else\n     m_write = m;\n \n-  if (unlikely (write_us_marker (dtp, m_write) != 0))\n+  if (unlikely (write_us_marker (dtp, m_write) < 0))\n     goto io_error;\n \n   /* Seek past the end of the current record.  */\n \n-  if (unlikely (sseek (dtp->u.p.current_unit->s, c + record_marker)\n-\t\t== FAILURE))\n+  if (unlikely (sseek (dtp->u.p.current_unit->s, c + record_marker, \n+\t\t       SEEK_SET) < 0))\n     goto io_error;\n \n   return;\n@@ -2691,6 +2864,35 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n \n }\n \n+\n+/* Utility function like memset() but operating on streams. Return\n+   value is same as for POSIX write().  */\n+\n+static ssize_t\n+sset (stream * s, int c, ssize_t nbyte)\n+{\n+  static const int WRITE_CHUNK = 256;\n+  char p[WRITE_CHUNK];\n+  ssize_t bytes_left, trans;\n+\n+  if (nbyte < WRITE_CHUNK)\n+    memset (p, c, nbyte);\n+  else\n+    memset (p, c, WRITE_CHUNK);\n+\n+  bytes_left = nbyte;\n+  while (bytes_left > 0)\n+    {\n+      trans = (bytes_left < WRITE_CHUNK) ? bytes_left : WRITE_CHUNK;\n+      trans = swrite (s, p, trans);\n+      if (trans < 0)\n+\treturn trans;\n+      bytes_left -= trans;\n+    }\n+\t       \n+  return nbyte - bytes_left;\n+}\n+\n /* Position to the next record in write mode.  */\n \n static void\n@@ -2699,9 +2901,6 @@ next_record_w (st_parameter_dt *dtp, int done)\n   gfc_offset m, record, max_pos;\n   int length;\n \n-  /* Flush and reset the format buffer.  */\n-  fbuf_flush (dtp->u.p.current_unit, 1);\n-  \n   /* Zero counters for X- and T-editing.  */\n   max_pos = dtp->u.p.max_pos;\n   dtp->u.p.max_pos = dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n@@ -2716,8 +2915,11 @@ next_record_w (st_parameter_dt *dtp, int done)\n       if (dtp->u.p.current_unit->bytes_left == 0)\n \tbreak;\n \n+      fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);\n+      fbuf_flush (dtp->u.p.current_unit, WRITING);\n       if (sset (dtp->u.p.current_unit->s, ' ', \n-\t\tdtp->u.p.current_unit->bytes_left) == FAILURE)\n+\t\tdtp->u.p.current_unit->bytes_left) \n+\t  != dtp->u.p.current_unit->bytes_left)\n \tgoto io_error;\n \n       break;\n@@ -2726,7 +2928,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n       if (dtp->u.p.current_unit->bytes_left > 0)\n \t{\n \t  length = (int) dtp->u.p.current_unit->bytes_left;\n-\t  if (sset (dtp->u.p.current_unit->s, 0, length) == FAILURE)\n+\t  if (sset (dtp->u.p.current_unit->s, 0, length) != length)\n \t    goto io_error;\n \t}\n       break;\n@@ -2757,16 +2959,15 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t{\n \t\t  length = (int) (max_pos - m);\n \t\t  if (sseek (dtp->u.p.current_unit->s, \n-\t\t\t      file_position (dtp->u.p.current_unit->s) \n-\t\t\t      + length) == FAILURE)\n+\t\t\t     length, SEEK_CUR) < 0)\n \t\t    {\n \t\t      generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t      return;\n \t\t    }\n \t\t  length = (int) (dtp->u.p.current_unit->recl - max_pos);\n \t\t}\n \n-\t      if (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)\n+\t      if (sset (dtp->u.p.current_unit->s, ' ', length) != length)\n \t\t{\n \t\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t\t  return;\n@@ -2782,7 +2983,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t      /* Now seek to this record */\n \t      record = record * dtp->u.p.current_unit->recl;\n \n-\t      if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n+\t      if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)\n \t\t{\n \t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t  return;\n@@ -2805,8 +3006,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t    {\n \t\t      length = (int) (max_pos - m);\n \t\t      if (sseek (dtp->u.p.current_unit->s, \n-\t\t\t\t  file_position (dtp->u.p.current_unit->s)\n-\t\t\t\t  + length) == FAILURE)\n+\t\t\t\t length, SEEK_CUR) < 0)\n \t\t        {\n \t\t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t\t  return;\n@@ -2817,7 +3017,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t    length = (int) dtp->u.p.current_unit->bytes_left;\n \t\t}\n \n-\t      if (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)\n+\t      if (sset (dtp->u.p.current_unit->s, ' ', length) != length)\n \t\t{\n \t\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t\t  return;\n@@ -2826,23 +3026,27 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t}\n       else\n \t{\n-\t  size_t len;\n-\t  const char crlf[] = \"\\r\\n\";\n-\n #ifdef HAVE_CRLF\n-\t  len = 2;\n+\t  const int len = 2;\n #else\n-\t  len = 1;\n+\t  const int len = 1;\n #endif\n-\t  if (swrite (dtp->u.p.current_unit->s, &crlf[2-len], &len) != 0)\n-\t    goto io_error;\n-\t  \n+          fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);\n+          char * p = fbuf_alloc (dtp->u.p.current_unit, len);\n+          if (!p)\n+            goto io_error;\n+#ifdef HAVE_CRLF\n+          *(p++) = '\\r';\n+#endif\n+          *p = '\\n';\n \t  if (is_stream_io (dtp))\n \t    {\n \t      dtp->u.p.current_unit->strm_pos += len;\n \t      if (dtp->u.p.current_unit->strm_pos\n \t\t  < file_length (dtp->u.p.current_unit->s))\n-\t\tstruncate (dtp->u.p.current_unit->s);\n+\t\tunit_truncate (dtp->u.p.current_unit,\n+                               dtp->u.p.current_unit->strm_pos - 1,\n+                               &dtp->common);\n \t    }\n \t}\n \n@@ -2880,7 +3084,7 @@ next_record (st_parameter_dt *dtp, int done)\n       dtp->u.p.current_unit->current_record = 0;\n       if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n \t{\n-\t  fp = file_position (dtp->u.p.current_unit->s);\n+\t  fp = stell (dtp->u.p.current_unit->s);\n \t  /* Calculate next record, rounding up partial records.  */\n \t  dtp->u.p.current_unit->last_record =\n \t    (fp + dtp->u.p.current_unit->recl - 1) /\n@@ -2892,6 +3096,8 @@ next_record (st_parameter_dt *dtp, int done)\n \n   if (!done)\n     pre_position (dtp);\n+\n+  fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n }\n \n \n@@ -2940,7 +3146,6 @@ finalize_transfer (st_parameter_dt *dtp)\n   if ((cf & IOPARM_DT_LIST_FORMAT) != 0 && dtp->u.p.mode == READING)\n     {\n       finish_list_read (dtp);\n-      sfree (dtp->u.p.current_unit->s);\n       return;\n     }\n \n@@ -2955,10 +3160,9 @@ finalize_transfer (st_parameter_dt *dtp)\n \tnext_record (dtp, 1);\n \n       if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED\n-\t  && file_position (dtp->u.p.current_unit->s) >= dtp->rec)\n+\t  && stell (dtp->u.p.current_unit->s) >= dtp->rec)\n \t{\n-\t  flush (dtp->u.p.current_unit->s);\n-\t  sfree (dtp->u.p.current_unit->s);\n+\t  sflush (dtp->u.p.current_unit->s);\n \t}\n       return;\n     }\n@@ -2967,9 +3171,8 @@ finalize_transfer (st_parameter_dt *dtp)\n \n   if (!is_internal_unit (dtp) && dtp->u.p.seen_dollar)\n     {\n+      fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n       dtp->u.p.seen_dollar = 0;\n-      fbuf_flush (dtp->u.p.current_unit, 1);\n-      sfree (dtp->u.p.current_unit->s);\n       return;\n     }\n \n@@ -2981,15 +3184,17 @@ finalize_transfer (st_parameter_dt *dtp)\n \t- dtp->u.p.current_unit->bytes_left);\n       dtp->u.p.current_unit->saved_pos =\n \tdtp->u.p.max_pos > 0 ? dtp->u.p.max_pos - bytes_written : 0;\n-      fbuf_flush (dtp->u.p.current_unit, 0);\n-      flush (dtp->u.p.current_unit->s);\n+      fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n+      sflush (dtp->u.p.current_unit->s);\n       return;\n     }\n+  else if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED \n+           && dtp->u.p.mode == WRITING && !is_internal_unit (dtp))\n+      fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);    \n \n   dtp->u.p.current_unit->saved_pos = 0;\n \n   next_record (dtp, 1);\n-  sfree (dtp->u.p.current_unit->s);\n }\n \n /* Transfer function for IOLENGTH. It doesn't actually do any\n@@ -3046,8 +3251,6 @@ void\n st_iolength_done (st_parameter_dt *dtp __attribute__((unused)))\n {\n   free_ionml (dtp);\n-  if (dtp->u.p.scratch != NULL)\n-    free_mem (dtp->u.p.scratch);\n   library_end ();\n }\n \n@@ -3063,29 +3266,6 @@ st_read (st_parameter_dt *dtp)\n   library_start (&dtp->common);\n \n   data_transfer_init (dtp, 1);\n-\n-  /* Handle complications dealing with the endfile record.  */\n-\n-  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n-    switch (dtp->u.p.current_unit->endfile)\n-      {\n-      case NO_ENDFILE:\n-\tbreak;\n-\n-      case AT_ENDFILE:\n-\tif (!is_internal_unit (dtp))\n-\t  {\n-\t    generate_error (&dtp->common, LIBERROR_END, NULL);\n-\t    dtp->u.p.current_unit->endfile = AFTER_ENDFILE;\n-\t    dtp->u.p.current_unit->current_record = 0;\n-\t  }\n-\tbreak;\n-\n-      case AFTER_ENDFILE:\n-\tgenerate_error (&dtp->common, LIBERROR_ENDFILE, NULL);\n-\tdtp->u.p.current_unit->current_record = 0;\n-\tbreak;\n-      }\n }\n \n extern void st_read_done (st_parameter_dt *);\n@@ -3095,10 +3275,9 @@ void\n st_read_done (st_parameter_dt *dtp)\n {\n   finalize_transfer (dtp);\n-  free_format_data (dtp);\n+  if (is_internal_unit (dtp))\n+    free_format_data (dtp->u.p.fmt);\n   free_ionml (dtp);\n-  if (dtp->u.p.scratch != NULL)\n-    free_mem (dtp->u.p.scratch);\n   if (dtp->u.p.current_unit != NULL)\n     unlock_unit (dtp->u.p.current_unit);\n \n@@ -3141,19 +3320,16 @@ st_write_done (st_parameter_dt *dtp)\n       case NO_ENDFILE:\n \t/* Get rid of whatever is after this record.  */\n         if (!is_internal_unit (dtp))\n-\t  {\n-\t    flush (dtp->u.p.current_unit->s);\n-\t    if (struncate (dtp->u.p.current_unit->s) == FAILURE)\n-\t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t  }\n+          unit_truncate (dtp->u.p.current_unit, \n+                         stell (dtp->u.p.current_unit->s),\n+                         &dtp->common);\n \tdtp->u.p.current_unit->endfile = AT_ENDFILE;\n \tbreak;\n       }\n \n-  free_format_data (dtp);\n+  if (is_internal_unit (dtp))\n+    free_format_data (dtp->u.p.fmt);\n   free_ionml (dtp);\n-  if (dtp->u.p.scratch != NULL)\n-    free_mem (dtp->u.p.scratch);\n   if (dtp->u.p.current_unit != NULL)\n     unlock_unit (dtp->u.p.current_unit);\n   \n@@ -3267,3 +3443,46 @@ void reverse_memcpy (void *dest, const void *src, size_t n)\n   for (i=0; i<n; i++)\n       *(d++) = *(s--);\n }\n+\n+\n+/* Once upon a time, a poor innocent Fortran program was reading a\n+   file, when suddenly it hit the end-of-file (EOF).  Unfortunately\n+   the OS doesn't tell whether we're at the EOF or whether we already\n+   went past it.  Luckily our hero, libgfortran, keeps track of this.\n+   Call this function when you detect an EOF condition.  See Section\n+   9.10.2 in F2003.  */\n+\n+void\n+hit_eof (st_parameter_dt * dtp)\n+{\n+  dtp->u.p.current_unit->flags.position = POSITION_APPEND;\n+\n+  if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n+    switch (dtp->u.p.current_unit->endfile)\n+      {\n+      case NO_ENDFILE:\n+      case AT_ENDFILE:\n+        generate_error (&dtp->common, LIBERROR_END, NULL);\n+\tif (!is_internal_unit (dtp))\n+\t  {\n+\t    dtp->u.p.current_unit->endfile = AFTER_ENDFILE;\n+\t    dtp->u.p.current_unit->current_record = 0;\n+\t  }\n+        else\n+          dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+\tbreak;\n+        \n+      case AFTER_ENDFILE:\n+\tgenerate_error (&dtp->common, LIBERROR_ENDFILE, NULL);\n+\tdtp->u.p.current_unit->current_record = 0;\n+\tbreak;\n+      }\n+  else\n+    {\n+      /* Non-sequential files don't have an ENDFILE record, so we\n+         can't be at AFTER_ENDFILE.  */\n+      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n+      generate_error (&dtp->common, LIBERROR_END, NULL);\n+      dtp->u.p.current_unit->current_record = 0;\n+    }\n+}"}, {"sha": "4c460166152dbb55b8fa1bbfb5d24ea973df2a66", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 64, "deletions": 12, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "patch": "@@ -540,6 +540,8 @@ init_units (void)\n       u->file_len = strlen (stdin_name);\n       u->file = get_mem (u->file_len);\n       memmove (u->file, stdin_name, u->file_len);\n+\n+      fbuf_init (u, 0);\n     \n       __gthread_mutex_unlock (&u->lock);\n     }\n@@ -640,7 +642,8 @@ close_unit_1 (gfc_unit *u, int locked)\n     free_mem (u->file);\n   u->file = NULL;\n   u->file_len = 0;\n-  \n+\n+  free_format_hash_table (u);  \n   fbuf_destroy (u);\n \n   if (!locked)\n@@ -697,15 +700,62 @@ close_units (void)\n void\n update_position (gfc_unit *u)\n {\n-  if (file_position (u->s) == 0)\n+  if (stell (u->s) == 0)\n     u->flags.position = POSITION_REWIND;\n-  else if (file_length (u->s) == file_position (u->s))\n+  else if (file_length (u->s) == stell (u->s))\n     u->flags.position = POSITION_APPEND;\n   else\n     u->flags.position = POSITION_ASIS;\n }\n \n \n+/* High level interface to truncate a file safely, i.e. flush format\n+   buffers, check that it's a regular file, and generate error if that\n+   occurs.  Just like POSIX ftruncate, returns 0 on success, -1 on\n+   failure.  */\n+\n+int\n+unit_truncate (gfc_unit * u, gfc_offset pos, st_parameter_common * common)\n+{\n+  int ret;\n+\n+  /* Make sure format buffer is flushed.  */\n+  if (u->flags.form == FORM_FORMATTED)\n+    {\n+      if (u->mode == READING)\n+\tpos += fbuf_reset (u);\n+      else\n+\tfbuf_flush (u, u->mode);\n+    }\n+  \n+  /* Don't try to truncate a special file, just pretend that it\n+     succeeds.  */\n+  if (is_special (u->s) || !is_seekable (u->s))\n+    {\n+      sflush (u->s);\n+      return 0;\n+    }\n+\n+  /* struncate() should flush the stream buffer if necessary, so don't\n+     bother calling sflush() here.  */\n+  ret = struncate (u->s, pos);\n+\n+  if (ret != 0)\n+    {\n+      generate_error (common, LIBERROR_OS, NULL);\n+      u->endfile = NO_ENDFILE;\n+      u->flags.position = POSITION_ASIS;\n+    }\n+  else\n+    {\n+      u->endfile = AT_ENDFILE;\n+      u->flags.position = POSITION_APPEND;\n+    }\n+\n+  return ret;\n+}\n+\n+\n /* filename_from_unit()-- If the unit_number exists, return a pointer to the\n    name of the associated file, otherwise return the empty string.  The caller\n    must free memory allocated for the filename string.  */\n@@ -746,23 +796,25 @@ finish_last_advance_record (gfc_unit *u)\n {\n   \n   if (u->saved_pos > 0)\n-    fbuf_seek (u, u->saved_pos);\n-    \n-  fbuf_flush (u, 1);\n+    fbuf_seek (u, u->saved_pos, SEEK_CUR);\n \n   if (!(u->unit_number == options.stdout_unit\n \t|| u->unit_number == options.stderr_unit))\n     {\n-      size_t len;\n-\n-      const char crlf[] = \"\\r\\n\";\n #ifdef HAVE_CRLF\n-      len = 2;\n+      const int len = 2;\n #else\n-      len = 1;\n+      const int len = 1;\n #endif\n-      if (swrite (u->s, &crlf[2-len], &len) != 0)\n+      char *p = fbuf_alloc (u, len);\n+      if (!p)\n \tos_error (\"Completing record after ADVANCE_NO failed\");\n+#ifdef HAVE_CRLF\n+      *(p++) = '\\r';\n+#endif\n+      *p = '\\n';\n     }\n+\n+  fbuf_flush (u, u->mode);\n }\n "}, {"sha": "5cac8ea4a5c88a30b5f3a61a22916672dcacf50c", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 327, "deletions": 698, "changes": 1025, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "patch": "@@ -94,10 +94,6 @@ id_from_fd (const int fd)\n \n #endif\n \n-#ifndef SSIZE_MAX\n-#define SSIZE_MAX SHRT_MAX\n-#endif\n-\n #ifndef PATH_MAX\n #define PATH_MAX 1024\n #endif\n@@ -129,102 +125,32 @@ id_from_fd (const int fd)\n #endif\n \n \n-/* Unix stream I/O module */\n+/* Unix and internal stream I/O module */\n \n-#define BUFFER_SIZE 8192\n+static const int BUFFER_SIZE = 8192;\n \n typedef struct\n {\n   stream st;\n \n-  int fd;\n   gfc_offset buffer_offset;\t/* File offset of the start of the buffer */\n   gfc_offset physical_offset;\t/* Current physical file offset */\n   gfc_offset logical_offset;\t/* Current logical file offset */\n-  gfc_offset dirty_offset;\t/* Start of modified bytes in buffer */\n   gfc_offset file_length;\t/* Length of the file, -1 if not seekable. */\n \n-  int len;\t\t\t/* Physical length of the current buffer */\n+  char *buffer;                 /* Pointer to the buffer.  */\n+  int fd;                       /* The POSIX file descriptor.  */\n+\n   int active;\t\t\t/* Length of valid bytes in the buffer */\n \n   int prot;\n-  int ndirty;\t\t\t/* Dirty bytes starting at dirty_offset */\n+  int ndirty;\t\t\t/* Dirty bytes starting at buffer_offset */\n \n   int special_file;\t\t/* =1 if the fd refers to a special file */\n-\n-  io_mode method;\t\t/* Method of stream I/O being used */\n-\n-  char *buffer;\n-  char small_buffer[BUFFER_SIZE];\n }\n unix_stream;\n \n \n-/* Stream structure for internal files. Fields must be kept in sync\n-   with unix_stream above, except for the buffer. For internal files\n-   we point the buffer pointer directly at the destination memory.  */\n-\n-typedef struct\n-{\n-  stream st;\n-\n-  int fd;\n-  gfc_offset buffer_offset;\t/* File offset of the start of the buffer */\n-  gfc_offset physical_offset;\t/* Current physical file offset */\n-  gfc_offset logical_offset;\t/* Current logical file offset */\n-  gfc_offset dirty_offset;\t/* Start of modified bytes in buffer */\n-  gfc_offset file_length;\t/* Length of the file, -1 if not seekable. */\n-\n-  int len;\t\t\t/* Physical length of the current buffer */\n-  int active;\t\t\t/* Length of valid bytes in the buffer */\n-\n-  int prot;\n-  int ndirty;\t\t\t/* Dirty bytes starting at dirty_offset */\n-\n-  int special_file;\t\t/* =1 if the fd refers to a special file */\n-\n-  io_mode method;\t\t/* Method of stream I/O being used */\n-\n-  char *buffer;\n-}\n-int_stream;\n-\n-/* This implementation of stream I/O is based on the paper:\n- *\n- *  \"Exploiting the advantages of mapped files for stream I/O\",\n- *  O. Krieger, M. Stumm and R. Umrau, \"Proceedings of the 1992 Winter\n- *  USENIX conference\", p. 27-42.\n- *\n- * It differs in a number of ways from the version described in the\n- * paper.  First of all, threads are not an issue during I/O and we\n- * also don't have to worry about having multiple regions, since\n- * fortran's I/O model only allows you to be one place at a time.\n- *\n- * On the other hand, we have to be able to writing at the end of a\n- * stream, read from the start of a stream or read and write blocks of\n- * bytes from an arbitrary position.  After opening a file, a pointer\n- * to a stream structure is returned, which is used to handle file\n- * accesses until the file is closed.\n- *\n- * salloc_at_r(stream, len, where)-- Given a stream pointer, return a\n- * pointer to a block of memory that mirror the file at position\n- * 'where' that is 'len' bytes long.  The len integer is updated to\n- * reflect how many bytes were actually read.  The only reason for a\n- * short read is end of file.  The file pointer is updated.  The\n- * pointer is valid until the next call to salloc_*.\n- *\n- * salloc_at_w(stream, len, where)-- Given the stream pointer, returns\n- * a pointer to a block of memory that is updated to reflect the state\n- * of the file.  The length of the buffer is always equal to that\n- * requested.  The buffer must be completely set by the caller.  When\n- * data has been written, the sfree() function must be called to\n- * indicate that the caller is done writing data to the buffer.  This\n- * may or may not cause a physical write.\n- *\n- * Short forms of these are salloc_r() and salloc_w() which drop the\n- * 'where' parameter and use the current file pointer. */\n-\n-\n /*move_pos_offset()--  Move the record pointer right or left\n  *relative to current position */\n \n@@ -236,15 +162,12 @@ move_pos_offset (stream* st, int pos_off)\n     {\n       str->logical_offset += pos_off;\n \n-      if (str->dirty_offset + str->ndirty > str->logical_offset)\n+      if (str->ndirty > str->logical_offset)\n \t{\n \t  if (str->ndirty + pos_off > 0)\n \t    str->ndirty += pos_off;\n \t  else\n-\t    {\n-\t      str->dirty_offset +=  pos_off + pos_off;\n-\t      str->ndirty = 0;\n-\t    }\n+            str->ndirty = 0;\n \t}\n \n     return pos_off;\n@@ -327,580 +250,330 @@ flush_if_preconnected (stream * s)\n }\n \n \n-/* Reset a stream after reading/writing. Assumes that the buffers have\n-   been flushed.  */\n+/* get_oserror()-- Get the most recent operating system error.  For\n+ * unix, this is errno. */\n \n-inline static void\n-reset_stream (unix_stream * s, size_t bytes_rw)\n+const char *\n+get_oserror (void)\n {\n-  s->physical_offset += bytes_rw;\n-  s->logical_offset = s->physical_offset;\n-  if (s->file_length != -1 && s->physical_offset > s->file_length)\n-    s->file_length = s->physical_offset;\n+  return strerror (errno);\n }\n \n \n-/* Read bytes into a buffer, allowing for short reads.  If the nbytes\n- * argument is less on return than on entry, it is because we've hit\n- * the end of file. */\n+/********************************************************************\n+Raw I/O functions (read, write, seek, tell, truncate, close).\n+\n+These functions wrap the basic POSIX I/O syscalls. Any deviation in\n+semantics is a bug, except the following: write restarts in case\n+of being interrupted by a signal, and as the first argument the\n+functions take the unix_stream struct rather than an integer file\n+descriptor. Also, for POSIX read() and write() a nbyte argument larger\n+than SSIZE_MAX is undefined; here the type of nbyte is ssize_t rather\n+than size_t as for POSIX read/write.\n+*********************************************************************/\n \n static int\n-do_read (unix_stream * s, void * buf, size_t * nbytes)\n+raw_flush (unix_stream * s  __attribute__ ((unused)))\n {\n-  ssize_t trans;\n-  size_t bytes_left;\n-  char *buf_st;\n-  int status;\n-\n-  status = 0;\n-  bytes_left = *nbytes;\n-  buf_st = (char *) buf;\n-\n-  /* We must read in a loop since some systems don't restart system\n-     calls in case of a signal.  */\n-  while (bytes_left > 0)\n-    {\n-      /* Requests between SSIZE_MAX and SIZE_MAX are undefined by SUSv3,\n-\t so we must read in chunks smaller than SSIZE_MAX.  */\n-      trans = (bytes_left < SSIZE_MAX) ? bytes_left : SSIZE_MAX;\n-      trans = read (s->fd, buf_st, trans);\n-      if (trans < 0)\n-\t{\n-\t  if (errno == EINTR)\n-\t    continue;\n-\t  else\n-\t    {\n-\t      status = errno;\n-\t      break;\n-\t    }\n-\t}\n-      else if (trans == 0) /* We hit EOF.  */\n-\tbreak;\n-      buf_st += trans;\n-      bytes_left -= trans;\n-    }\n-\n-  *nbytes -= bytes_left;\n-  return status;\n+  return 0;\n }\n \n+static ssize_t\n+raw_read (unix_stream * s, void * buf, ssize_t nbyte)\n+{\n+  /* For read we can't do I/O in a loop like raw_write does, because\n+     that will break applications that wait for interactive I/O.  */\n+  return read (s->fd, buf, nbyte);\n+}\n \n-/* Write a buffer to a stream, allowing for short writes.  */\n-\n-static int\n-do_write (unix_stream * s, const void * buf, size_t * nbytes)\n+static ssize_t\n+raw_write (unix_stream * s, const void * buf, ssize_t nbyte)\n {\n-  ssize_t trans;\n-  size_t bytes_left;\n+  ssize_t trans, bytes_left;\n   char *buf_st;\n-  int status;\n \n-  status = 0;\n-  bytes_left = *nbytes;\n+  bytes_left = nbyte;\n   buf_st = (char *) buf;\n \n   /* We must write in a loop since some systems don't restart system\n      calls in case of a signal.  */\n   while (bytes_left > 0)\n     {\n-      /* Requests between SSIZE_MAX and SIZE_MAX are undefined by SUSv3,\n-\t so we must write in chunks smaller than SSIZE_MAX.  */\n-      trans = (bytes_left < SSIZE_MAX) ? bytes_left : SSIZE_MAX;\n-      trans = write (s->fd, buf_st, trans);\n+      trans = write (s->fd, buf_st, bytes_left);\n       if (trans < 0)\n \t{\n \t  if (errno == EINTR)\n \t    continue;\n \t  else\n-\t    {\n-\t      status = errno;\n-\t      break;\n-\t    }\n+\t    return trans;\n \t}\n       buf_st += trans;\n       bytes_left -= trans;\n     }\n \n-  *nbytes -= bytes_left;\n-  return status;\n+  return nbyte - bytes_left;\n }\n \n+static off_t\n+raw_seek (unix_stream * s, off_t offset, int whence)\n+{\n+  return lseek (s->fd, offset, whence);\n+}\n \n-/* get_oserror()-- Get the most recent operating system error.  For\n- * unix, this is errno. */\n+static off_t\n+raw_tell (unix_stream * s)\n+{\n+  return lseek (s->fd, 0, SEEK_CUR);\n+}\n \n-const char *\n-get_oserror (void)\n+static int\n+raw_truncate (unix_stream * s, off_t length)\n {\n-  return strerror (errno);\n+#ifdef HAVE_FTRUNCATE\n+  return ftruncate (s->fd, length);\n+#elif defined HAVE_CHSIZE\n+  return chsize (s->fd, length);\n+#else\n+  runtime_error (\"required ftruncate or chsize support not present\");\n+  return -1;\n+#endif\n }\n \n+static int\n+raw_close (unix_stream * s)\n+{\n+  int retval;\n+  \n+  retval = close (s->fd);\n+  free_mem (s);\n+  return retval;\n+}\n \n-/*********************************************************************\n-    File descriptor stream functions\n-*********************************************************************/\n+static int\n+raw_init (unix_stream * s)\n+{\n+  s->st.read = (void *) raw_read;\n+  s->st.write = (void *) raw_write;\n+  s->st.seek = (void *) raw_seek;\n+  s->st.tell = (void *) raw_tell;\n+  s->st.truncate = (void *) raw_truncate;\n+  s->st.close = (void *) raw_close;\n+  s->st.flush = (void *) raw_flush;\n \n+  s->buffer = NULL;\n+  return 0;\n+}\n \n-/* fd_flush()-- Write bytes that need to be written */\n \n-static try\n-fd_flush (unix_stream * s)\n+/*********************************************************************\n+Buffered I/O functions. These functions have the same semantics as the\n+raw I/O functions above, except that they are buffered in order to\n+improve performance. The buffer must be flushed when switching from\n+reading to writing and vice versa.\n+*********************************************************************/\n+\n+static int\n+buf_flush (unix_stream * s)\n {\n-  size_t writelen;\n+  int writelen;\n+\n+  /* Flushing in read mode means discarding read bytes.  */\n+  s->active = 0;\n \n   if (s->ndirty == 0)\n-    return SUCCESS;\n+    return 0;\n   \n-  if (s->file_length != -1 && s->physical_offset != s->dirty_offset &&\n-      lseek (s->fd, s->dirty_offset, SEEK_SET) < 0)\n-    return FAILURE;\n+  if (s->file_length != -1 && s->physical_offset != s->buffer_offset\n+      && lseek (s->fd, s->buffer_offset, SEEK_SET) < 0)\n+    return -1;\n \n-  writelen = s->ndirty;\n-  if (do_write (s, s->buffer + (s->dirty_offset - s->buffer_offset),\n-\t\t&writelen) != 0)\n-    return FAILURE;\n+  writelen = raw_write (s, s->buffer, s->ndirty);\n \n-  s->physical_offset = s->dirty_offset + writelen;\n+  s->physical_offset = s->buffer_offset + writelen;\n \n-  /* don't increment file_length if the file is non-seekable */\n+  /* Don't increment file_length if the file is non-seekable.  */\n   if (s->file_length != -1 && s->physical_offset > s->file_length)\n-      s->file_length = s->physical_offset; \n+      s->file_length = s->physical_offset;\n \n   s->ndirty -= writelen;\n   if (s->ndirty != 0)\n-    return FAILURE;\n+    return -1;\n \n-  return SUCCESS;\n+  return 0;\n }\n \n-\n-/* fd_alloc()-- Arrange a buffer such that the salloc() request can be\n- * satisfied.  This subroutine gets the buffer ready for whatever is\n- * to come next. */\n-\n-static void\n-fd_alloc (unix_stream * s, gfc_offset where,\n-\t  int *len __attribute__ ((unused)))\n+static ssize_t\n+buf_read (unix_stream * s, void * buf, ssize_t nbyte)\n {\n-  char *new_buffer;\n-  int n, read_len;\n+  if (s->active == 0)\n+    s->buffer_offset = s->logical_offset;\n \n-  if (*len <= BUFFER_SIZE)\n-    {\n-      new_buffer = s->small_buffer;\n-      read_len = BUFFER_SIZE;\n-    }\n+  /* Is the data we want in the buffer?  */\n+  if (s->logical_offset + nbyte <= s->buffer_offset + s->active\n+      && s->buffer_offset <= s->logical_offset)\n+    memcpy (buf, s->buffer + (s->logical_offset - s->buffer_offset), nbyte);\n   else\n     {\n-      new_buffer = get_mem (*len);\n-      read_len = *len;\n-    }\n-\n-  /* Salvage bytes currently within the buffer.  This is important for\n-   * devices that cannot seek. */\n-\n-  if (s->buffer != NULL && s->buffer_offset <= where &&\n-      where <= s->buffer_offset + s->active)\n-    {\n-\n-      n = s->active - (where - s->buffer_offset);\n-      memmove (new_buffer, s->buffer + (where - s->buffer_offset), n);\n-\n-      s->active = n;\n-    }\n-  else\n-    {\t\t\t\t/* new buffer starts off empty */\n-      s->active = 0;\n+      /* First copy the active bytes if applicable, then read the rest\n+         either directly or filling the buffer.  */\n+      char *p;\n+      int nread = 0;\n+      ssize_t to_read, did_read;\n+      gfc_offset new_logical;\n+      \n+      p = (char *) buf;\n+      if (s->logical_offset >= s->buffer_offset \n+          && s->buffer_offset + s->active >= s->logical_offset)\n+        {\n+          nread = s->active - (s->logical_offset - s->buffer_offset);\n+          memcpy (buf, s->buffer + (s->logical_offset - s->buffer_offset), \n+                  nread);\n+          p += nread;\n+        }\n+      /* At this point we consider all bytes in the buffer discarded.  */\n+      to_read = nbyte - nread;\n+      new_logical = s->logical_offset + nread;\n+      if (s->file_length != -1 && s->physical_offset != new_logical\n+          && lseek (s->fd, new_logical, SEEK_SET) < 0)\n+        return -1;\n+      s->buffer_offset = s->physical_offset = new_logical;\n+      if (to_read <= BUFFER_SIZE/2)\n+        {\n+          did_read = raw_read (s, s->buffer, BUFFER_SIZE);\n+          s->physical_offset += did_read;\n+          s->active = did_read;\n+          did_read = (did_read > to_read) ? to_read : did_read;\n+          memcpy (p, s->buffer, did_read);\n+        }\n+      else\n+        {\n+          did_read = raw_read (s, p, to_read);\n+          s->physical_offset += did_read;\n+          s->active = 0;\n+        }\n+      nbyte = did_read + nread;\n     }\n-\n-  s->buffer_offset = where;\n-\n-  /* free the old buffer if necessary */\n-\n-  if (s->buffer != NULL && s->buffer != s->small_buffer)\n-    free_mem (s->buffer);\n-\n-  s->buffer = new_buffer;\n-  s->len = read_len;\n+  s->logical_offset += nbyte;\n+  return nbyte;\n }\n \n-\n-/* fd_alloc_r_at()-- Allocate a stream buffer for reading.  Either\n- * we've already buffered the data or we need to load it.  Returns\n- * NULL on I/O error. */\n-\n-static char *\n-fd_alloc_r_at (unix_stream * s, int *len)\n+static ssize_t\n+buf_write (unix_stream * s, const void * buf, ssize_t nbyte)\n {\n-  gfc_offset m;\n-  gfc_offset where = s->logical_offset;\n-\n-  if (s->buffer != NULL && s->buffer_offset <= where &&\n-      where + *len <= s->buffer_offset + s->active)\n-    {\n-\n-      /* Return a position within the current buffer */\n-\n-      s->logical_offset = where + *len;\n-      return s->buffer + where - s->buffer_offset;\n-    }\n-\n-  fd_alloc (s, where, len);\n-\n-  m = where + s->active;\n-\n-  if (s->physical_offset != m && lseek (s->fd, m, SEEK_SET) < 0)\n-    return NULL;\n-\n-  /* do_read() hangs on read from terminals for *BSD-systems.  Only\n-     use read() in that case.  */\n-\n-  if (s->special_file)\n+  if (s->ndirty == 0)\n+    s->buffer_offset = s->logical_offset;\n+\n+  /* Does the data fit into the buffer?  As a special case, if the\n+     buffer is empty and the request is bigger than BUFFER_SIZE/2,\n+     write directly. This avoids the case where the buffer would have\n+     to be flushed at every write.  */\n+  if (!(s->ndirty == 0 && nbyte > BUFFER_SIZE/2)\n+      && s->logical_offset + nbyte <= s->buffer_offset + BUFFER_SIZE\n+      && s->buffer_offset <= s->logical_offset\n+      && s->buffer_offset + s->ndirty >= s->logical_offset)\n     {\n-      ssize_t n;\n-\n-      n = read (s->fd, s->buffer + s->active, s->len - s->active);\n-      if (n < 0)\n-\treturn NULL;\n-\n-      s->physical_offset = m + n;\n-      s->active += n;\n+      memcpy (s->buffer + (s->logical_offset - s->buffer_offset), buf, nbyte);\n+      int nd = (s->logical_offset - s->buffer_offset) + nbyte;\n+      if (nd > s->ndirty)\n+        s->ndirty = nd;\n     }\n   else\n     {\n-      size_t n;\n-\n-      n = s->len - s->active;\n-      if (do_read (s, s->buffer + s->active, &n) != 0)\n-\treturn NULL;\n-\n-      s->physical_offset = m + n;\n-      s->active += n;\n-    }\n-\n-  if (s->active < *len)\n-    *len = s->active;\t\t/* Bytes actually available */\n-\n-  s->logical_offset = where + *len;\n-\n-  return s->buffer;\n-}\n-\n-\n-/* fd_alloc_w_at()-- Allocate a stream buffer for writing.  Either\n- * we've already buffered the data or we need to load it. */\n-\n-static char *\n-fd_alloc_w_at (unix_stream * s, int *len)\n-{\n-  gfc_offset n;\n-  gfc_offset where = s->logical_offset;\n-\n-  if (s->buffer == NULL || s->buffer_offset > where ||\n-      where + *len > s->buffer_offset + s->len)\n-    {\n-\n-      if (fd_flush (s) == FAILURE)\n-\treturn NULL;\n-      fd_alloc (s, where, len);\n-    }\n-\n-  /* Return a position within the current buffer */\n-  if (s->ndirty == 0 \n-      || where > s->dirty_offset + s->ndirty    \n-      || s->dirty_offset > where + *len)\n-    {  /* Discontiguous blocks, start with a clean buffer.  */  \n-\t/* Flush the buffer.  */  \n-      if (s->ndirty != 0)    \n-\tfd_flush (s);  \n-      s->dirty_offset = where;  \n-      s->ndirty = *len;\n-    }\n-  else\n-    {  \n-      gfc_offset start;  /* Merge with the existing data.  */  \n-      if (where < s->dirty_offset)    \n-\tstart = where;  \n-      else    \n-\tstart = s->dirty_offset;  \n-      if (where + *len > s->dirty_offset + s->ndirty)    \n-\ts->ndirty = where + *len - start;  \n-      else    \n-\ts->ndirty = s->dirty_offset + s->ndirty - start;  \n-      s->dirty_offset = start;\n+      /* Flush, and either fill the buffer with the new data, or if\n+         the request is bigger than the buffer size, write directly\n+         bypassing the buffer.  */\n+      buf_flush (s);\n+      if (nbyte <= BUFFER_SIZE/2)\n+        {\n+          memcpy (s->buffer, buf, nbyte);\n+          s->buffer_offset = s->logical_offset;\n+          s->ndirty += nbyte;\n+        }\n+      else\n+        {\n+          if (s->file_length != -1 && s->physical_offset != s->logical_offset\n+              && lseek (s->fd, s->logical_offset, SEEK_SET) < 0)\n+            return -1;\n+          nbyte = raw_write (s, buf, nbyte);\n+          s->physical_offset += nbyte;\n+        }\n     }\n-\n-  s->logical_offset = where + *len;\n-\n+  s->logical_offset += nbyte;\n   /* Don't increment file_length if the file is non-seekable.  */\n-\n   if (s->file_length != -1 && s->logical_offset > s->file_length)\n-     s->file_length = s->logical_offset;\n-\n-  n = s->logical_offset - s->buffer_offset;\n-  if (n > s->active)\n-    s->active = n;\n-\n-  return s->buffer + where - s->buffer_offset;\n+    s->file_length = s->logical_offset;\n+  return nbyte;\n }\n \n-\n-static try\n-fd_sfree (unix_stream * s)\n-{\n-  if (s->ndirty != 0 &&\n-      (s->buffer != s->small_buffer || options.all_unbuffered ||\n-       s->method == SYNC_UNBUFFERED))\n-    return fd_flush (s);\n-\n-  return SUCCESS;\n-}\n-\n-\n-static try\n-fd_seek (unix_stream * s, gfc_offset offset)\n-{\n-\n-  if (s->file_length == -1)\n-    return SUCCESS;\n-\n-  if (s->physical_offset == offset) /* Are we lucky and avoid syscall?  */\n-    {\n-      s->logical_offset = offset;\n-      return SUCCESS;\n-    }\n-\n-  if (lseek (s->fd, offset, SEEK_SET) >= 0)\n-    {\n-      s->physical_offset = s->logical_offset = offset;\n-      s->active = 0;\n-      return SUCCESS;\n-    }\n-\n-  return FAILURE;\n-}\n-\n-\n-/* truncate_file()-- Given a unit, truncate the file at the current\n- * position.  Sets the physical location to the new end of the file.\n- * Returns nonzero on error. */\n-\n-static try\n-fd_truncate (unix_stream * s)\n+static off_t\n+buf_seek (unix_stream * s, off_t offset, int whence)\n {\n-  /* Non-seekable files, like terminals and fifo's fail the lseek so just\n-     return success, there is nothing to truncate.  If its not a pipe there\n-     is a real problem.  */\n-  if (lseek (s->fd, s->logical_offset, SEEK_SET) == -1)\n+  switch (whence)\n     {\n-      if (errno == ESPIPE)\n-\treturn SUCCESS;\n-      else\n-\treturn FAILURE;\n+    case SEEK_SET:\n+      break;\n+    case SEEK_CUR:\n+      offset += s->logical_offset;\n+      break;\n+    case SEEK_END:\n+      offset += s->file_length;\n+      break;\n+    default:\n+      return -1;\n     }\n-\n-  /* Using ftruncate on a seekable special file (like /dev/null)\n-     is undefined, so we treat it as if the ftruncate succeeded.  */\n-  if (!s->special_file\n-      && (\n-#ifdef HAVE_FTRUNCATE\n-\t  ftruncate (s->fd, s->logical_offset) != 0\n-#elif defined HAVE_CHSIZE\n-\t  chsize (s->fd, s->logical_offset) != 0\n-#else\n-\t  /* If we have neither, always fail and exit, noisily.  */\n-\t  runtime_error (\"required ftruncate or chsize support not present\"), 1\n-#endif\n-\t  ))\n+  if (offset < 0)\n     {\n-      /* The truncation failed and we need to handle this gracefully.\n-\t The file length remains the same, but the file-descriptor\n-\t offset needs adjustment per the successful lseek above.\n-\t (Similarly, the contents of the buffer isn't valid anymore.)\n-\t A ftruncate call does not affect the physical (file-descriptor)\n-\t offset, according to the ftruncate manual, so neither should a\n-\t failed call.  */\n-      s->physical_offset = s->logical_offset;\n-      s->active = 0;\n-      return FAILURE;\n+      errno = EINVAL;\n+      return -1;\n     }\n-\n-  s->physical_offset = s->file_length = s->logical_offset;\n-  s->active = 0;\n-  return SUCCESS;\n+  s->logical_offset = offset;\n+  return offset;\n }\n \n-\n-/* Similar to memset(), but operating on a stream instead of a string.\n-   Takes care of not using too much memory.  */\n-\n-static try\n-fd_sset (unix_stream * s, int c, size_t n)\n+static off_t\n+buf_tell (unix_stream * s)\n {\n-  size_t bytes_left;\n-  int trans;\n-  void *p;\n-\n-  bytes_left = n;\n-\n-  while (bytes_left > 0)\n-    {\n-      /* memset() in chunks of BUFFER_SIZE.  */\n-      trans = (bytes_left < BUFFER_SIZE) ? bytes_left : BUFFER_SIZE;\n-\n-      p = fd_alloc_w_at (s, &trans);\n-      if (p)\n-\t  memset (p, c, trans);\n-      else\n-\treturn FAILURE;\n-\n-      bytes_left -= trans;\n-    }\n-\n-  return SUCCESS;\n+  return s->logical_offset;\n }\n \n-\n-/* Stream read function. Avoids using a buffer for big reads. The\n-   interface is like POSIX read(), but the nbytes argument is a\n-   pointer; on return it contains the number of bytes written. The\n-   function return value is the status indicator (0 for success).  */\n-\n static int\n-fd_read (unix_stream * s, void * buf, size_t * nbytes)\n+buf_truncate (unix_stream * s, off_t length)\n {\n-  void *p;\n-  int tmp, status;\n-\n-  if (*nbytes < BUFFER_SIZE && s->method == SYNC_BUFFERED)\n-    {\n-      tmp = *nbytes;\n-      p = fd_alloc_r_at (s, &tmp);\n-      if (p)\n-\t{\n-\t  *nbytes = tmp;\n-\t  memcpy (buf, p, *nbytes);\n-\t  return 0;\n-\t}\n-      else\n-\t{\n-\t  *nbytes = 0;\n-\t  return errno;\n-\t}\n-    }\n-\n-  /* If the request is bigger than BUFFER_SIZE we flush the buffers\n-     and read directly.  */\n-  if (fd_flush (s) == FAILURE)\n-    {\n-      *nbytes = 0;\n-      return errno;\n-    }\n-\n-  if (is_seekable ((stream *) s) && fd_seek (s, s->logical_offset) == FAILURE)\n-    {\n-      *nbytes = 0;\n-      return errno;\n-    }\n+  int r;\n \n-  status = do_read (s, buf, nbytes);\n-  reset_stream (s, *nbytes);\n-  return status;\n+  if (buf_flush (s) != 0)\n+    return -1;\n+  r = raw_truncate (s, length);\n+  if (r == 0)\n+    s->file_length = length;\n+  return r;\n }\n \n-\n-/* Stream write function. Avoids using a buffer for big writes. The\n-   interface is like POSIX write(), but the nbytes argument is a\n-   pointer; on return it contains the number of bytes written. The\n-   function return value is the status indicator (0 for success).  */\n-\n static int\n-fd_write (unix_stream * s, const void * buf, size_t * nbytes)\n-{\n-  void *p;\n-  int tmp, status;\n-\n-  if (*nbytes < BUFFER_SIZE && s->method == SYNC_BUFFERED)\n-    {\n-      tmp = *nbytes;\n-      p = fd_alloc_w_at (s, &tmp);\n-      if (p)\n-\t{\n-\t  *nbytes = tmp;\n-\t  memcpy (p, buf, *nbytes);\n-\t  return 0;\n-\t}\n-      else\n-\t{\n-\t  *nbytes = 0;\n-\t  return errno;\n-\t}\n-    }\n-\n-  /* If the request is bigger than BUFFER_SIZE we flush the buffers\n-     and write directly.  */\n-  if (fd_flush (s) == FAILURE)\n-    {\n-      *nbytes = 0;\n-      return errno;\n-    }\n-\n-  if (is_seekable ((stream *) s) && fd_seek (s, s->logical_offset) == FAILURE)\n-    {\n-      *nbytes = 0;\n-      return errno;\n-    }\n-\n-  status =  do_write (s, buf, nbytes);\n-  reset_stream (s, *nbytes);\n-  return status;\n-}\n-\n-\n-static try\n-fd_close (unix_stream * s)\n+buf_close (unix_stream * s)\n {\n-  if (fd_flush (s) == FAILURE)\n-    return FAILURE;\n-\n-  if (s->buffer != NULL && s->buffer != s->small_buffer)\n-    free_mem (s->buffer);\n-\n-  if (s->fd != STDOUT_FILENO && s->fd != STDERR_FILENO && s->fd != STDIN_FILENO)\n-    {\n-      if (close (s->fd) < 0)\n-\treturn FAILURE;\n-    }\n-\n-  free_mem (s);\n-\n-  return SUCCESS;\n+  if (buf_flush (s) != 0)\n+    return -1;\n+  free_mem (s->buffer);\n+  return raw_close (s);\n }\n \n-\n-static void\n-fd_open (unix_stream * s)\n+static int\n+buf_init (unix_stream * s)\n {\n-  if (isatty (s->fd))\n-    s->method = SYNC_UNBUFFERED;\n-  else\n-    s->method = SYNC_BUFFERED;\n-\n-  s->st.alloc_w_at = (void *) fd_alloc_w_at;\n-  s->st.sfree = (void *) fd_sfree;\n-  s->st.close = (void *) fd_close;\n-  s->st.seek = (void *) fd_seek;\n-  s->st.trunc = (void *) fd_truncate;\n-  s->st.read = (void *) fd_read;\n-  s->st.write = (void *) fd_write;\n-  s->st.set = (void *) fd_sset;\n+  s->st.read = (void *) buf_read;\n+  s->st.write = (void *) buf_write;\n+  s->st.seek = (void *) buf_seek;\n+  s->st.tell = (void *) buf_tell;\n+  s->st.truncate = (void *) buf_truncate;\n+  s->st.close = (void *) buf_close;\n+  s->st.flush = (void *) buf_flush;\n \n-  s->buffer = NULL;\n+  s->buffer = get_mem (BUFFER_SIZE);\n+  return 0;\n }\n \n \n-\n-\n /*********************************************************************\n   memory stream functions - These are used for internal files\n \n@@ -912,33 +585,33 @@ fd_open (unix_stream * s)\n *********************************************************************/\n \n \n-static char *\n-mem_alloc_r_at (int_stream * s, int *len)\n+char *\n+mem_alloc_r (stream * strm, int * len)\n {\n+  unix_stream * s = (unix_stream *) strm;\n   gfc_offset n;\n   gfc_offset where = s->logical_offset;\n \n   if (where < s->buffer_offset || where > s->buffer_offset + s->active)\n     return NULL;\n \n-  s->logical_offset = where + *len;\n-\n   n = s->buffer_offset + s->active - where;\n   if (*len > n)\n     *len = n;\n \n+  s->logical_offset = where + *len;\n+\n   return s->buffer + (where - s->buffer_offset);\n }\n \n \n-static char *\n-mem_alloc_w_at (int_stream * s, int *len)\n+char *\n+mem_alloc_w (stream * strm, int * len)\n {\n+  unix_stream * s = (unix_stream *) strm;\n   gfc_offset m;\n   gfc_offset where = s->logical_offset;\n \n-  assert (*len >= 0);  /* Negative values not allowed. */\n-  \n   m = where + *len;\n \n   if (where < s->buffer_offset)\n@@ -955,110 +628,111 @@ mem_alloc_w_at (int_stream * s, int *len)\n \n /* Stream read function for internal units.  */\n \n-static int\n-mem_read (int_stream * s, void * buf, size_t * nbytes)\n+static ssize_t\n+mem_read (stream * s, void * buf, ssize_t nbytes)\n {\n   void *p;\n-  int tmp;\n+  int nb = nbytes;\n \n-  tmp = *nbytes;\n-  p = mem_alloc_r_at (s, &tmp);\n+  p = mem_alloc_r (s, &nb);\n   if (p)\n     {\n-      *nbytes = tmp;\n-      memcpy (buf, p, *nbytes);\n-      return 0;\n+      memcpy (buf, p, nb);\n+      return (ssize_t) nb;\n     }\n   else\n-    {\n-      *nbytes = 0;\n-      return 0;\n-    }\n+    return 0;\n }\n \n \n /* Stream write function for internal units. This is not actually used\n    at the moment, as all internal IO is formatted and the formatted IO\n    routines use mem_alloc_w_at.  */\n \n-static int\n-mem_write (int_stream * s, const void * buf, size_t * nbytes)\n+static ssize_t\n+mem_write (stream * s, const void * buf, ssize_t nbytes)\n {\n   void *p;\n-  int tmp;\n+  int nb = nbytes;\n \n-  tmp = *nbytes;\n-  p = mem_alloc_w_at (s, &tmp);\n+  p = mem_alloc_w (s, &nb);\n   if (p)\n     {\n-      *nbytes = tmp;\n-      memcpy (p, buf, *nbytes);\n-      return 0;\n+      memcpy (p, buf, nb);\n+      return (ssize_t) nb;\n     }\n   else\n-    {\n-      *nbytes = 0;\n-      return 0;\n-    }\n+    return 0;\n }\n \n \n-static int\n-mem_seek (int_stream * s, gfc_offset offset)\n+static off_t\n+mem_seek (stream * strm, off_t offset, int whence)\n {\n+  unix_stream * s = (unix_stream *) strm;\n+  switch (whence)\n+    {\n+    case SEEK_SET:\n+      break;\n+    case SEEK_CUR:\n+      offset += s->logical_offset;\n+      break;\n+    case SEEK_END:\n+      offset += s->file_length;\n+      break;\n+    default:\n+      return -1;\n+    }\n+\n+  /* Note that for internal array I/O it's actually possible to have a\n+     negative offset, so don't check for that.  */\n   if (offset > s->file_length)\n     {\n-      errno = ESPIPE;\n-      return FAILURE;\n+      errno = EINVAL;\n+      return -1;\n     }\n \n   s->logical_offset = offset;\n-  return SUCCESS;\n+\n+  /* Returning < 0 is the error indicator for sseek(), so return 0 if\n+     offset is negative.  Thus if the return value is 0, the caller\n+     has to use stell() to get the real value of logical_offset.  */\n+  if (offset >= 0)\n+    return offset;\n+  return 0;\n }\n \n \n-static try\n-mem_set (int_stream * s, int c, size_t n)\n+static off_t\n+mem_tell (stream * s)\n {\n-  void *p;\n-  int len;\n-\n-  len = n;\n-  \n-  p = mem_alloc_w_at (s, &len);\n-  if (p)\n-    {\n-      memset (p, c, len);\n-      return SUCCESS;\n-    }\n-  else\n-    return FAILURE;\n+  return ((unix_stream *)s)->logical_offset;\n }\n \n \n static int\n-mem_truncate (int_stream * s __attribute__ ((unused)))\n+mem_truncate (unix_stream * s __attribute__ ((unused)), \n+\t      off_t length __attribute__ ((unused)))\n {\n-  return SUCCESS;\n+  return 0;\n }\n \n \n-static try\n-mem_close (int_stream * s)\n+static int\n+mem_flush (unix_stream * s __attribute__ ((unused)))\n {\n-  if (s != NULL)\n-    free_mem (s);\n-\n-  return SUCCESS;\n+  return 0;\n }\n \n \n-static try\n-mem_sfree (int_stream * s __attribute__ ((unused)))\n+static int\n+mem_close (unix_stream * s)\n {\n-  return SUCCESS;\n-}\n+  if (s != NULL)\n+    free_mem (s);\n \n+  return 0;\n+}\n \n \n /*********************************************************************\n@@ -1071,7 +745,7 @@ mem_sfree (int_stream * s __attribute__ ((unused)))\n void\n empty_internal_buffer(stream *strm)\n {\n-  int_stream * s = (int_stream *) strm;\n+  unix_stream * s = (unix_stream *) strm;\n   memset(s->buffer, ' ', s->file_length);\n }\n \n@@ -1080,25 +754,24 @@ empty_internal_buffer(stream *strm)\n stream *\n open_internal (char *base, int length, gfc_offset offset)\n {\n-  int_stream *s;\n+  unix_stream *s;\n \n-  s = get_mem (sizeof (int_stream));\n-  memset (s, '\\0', sizeof (int_stream));\n+  s = get_mem (sizeof (unix_stream));\n+  memset (s, '\\0', sizeof (unix_stream));\n \n   s->buffer = base;\n   s->buffer_offset = offset;\n \n   s->logical_offset = 0;\n   s->active = s->file_length = length;\n \n-  s->st.alloc_w_at = (void *) mem_alloc_w_at;\n-  s->st.sfree = (void *) mem_sfree;\n   s->st.close = (void *) mem_close;\n   s->st.seek = (void *) mem_seek;\n-  s->st.trunc = (void *) mem_truncate;\n+  s->st.tell = (void *) mem_tell;\n+  s->st.truncate = (void *) mem_truncate;\n   s->st.read = (void *) mem_read;\n   s->st.write = (void *) mem_write;\n-  s->st.set = (void *) mem_set;\n+  s->st.flush = (void *) mem_flush;\n \n   return (stream *) s;\n }\n@@ -1133,7 +806,14 @@ fd_to_stream (int fd, int prot)\n \n   s->special_file = !S_ISREG (statbuf.st_mode);\n \n-  fd_open (s);\n+  if (isatty (s->fd) || options.all_unbuffered\n+      ||(options.unbuffered_preconnected && \n+         (s->fd == STDIN_FILENO \n+          || s->fd == STDOUT_FILENO \n+          || s->fd == STDERR_FILENO)))\n+    raw_init (s);\n+  else\n+    buf_init (s);\n \n   return (stream *) s;\n }\n@@ -1417,8 +1097,6 @@ output_stream (void)\n #endif\n \n   s = fd_to_stream (STDOUT_FILENO, PROT_WRITE);\n-  if (options.unbuffered_preconnected)\n-    ((unix_stream *) s)->method = SYNC_UNBUFFERED;\n   return s;\n }\n \n@@ -1436,8 +1114,6 @@ error_stream (void)\n #endif\n \n   s = fd_to_stream (STDERR_FILENO, PROT_WRITE);\n-  if (options.unbuffered_preconnected)\n-    ((unix_stream *) s)->method = SYNC_UNBUFFERED;\n   return s;\n }\n \n@@ -1668,7 +1344,7 @@ flush_all_units_1 (gfc_unit *u, int min_unit)\n \t  if (__gthread_mutex_trylock (&u->lock))\n \t    return u;\n \t  if (u->s)\n-\t    flush (u->s);\n+\t    sflush (u->s);\n \t  __gthread_mutex_unlock (&u->lock);\n \t}\n       u = u->right;\n@@ -1698,7 +1374,7 @@ flush_all_units (void)\n \n       if (u->closed == 0)\n \t{\n-\t  flush (u->s);\n+\t  sflush (u->s);\n \t  __gthread_mutex_lock (&unit_lock);\n \t  __gthread_mutex_unlock (&u->lock);\n \t  (void) predec_waiting_locked (u);\n@@ -1715,40 +1391,6 @@ flush_all_units (void)\n }\n \n \n-/* stream_at_bof()-- Returns nonzero if the stream is at the beginning\n- * of the file. */\n-\n-int\n-stream_at_bof (stream * s)\n-{\n-  unix_stream *us;\n-\n-  if (!is_seekable (s))\n-    return 0;\n-\n-  us = (unix_stream *) s;\n-\n-  return us->logical_offset == 0;\n-}\n-\n-\n-/* stream_at_eof()-- Returns nonzero if the stream is at the end\n- * of the file. */\n-\n-int\n-stream_at_eof (stream * s)\n-{\n-  unix_stream *us;\n-\n-  if (!is_seekable (s))\n-    return 0;\n-\n-  us = (unix_stream *) s;\n-\n-  return us->logical_offset == us->dirty_offset;\n-}\n-\n-\n /* delete_file()-- Given a unit structure, delete the file associated\n  * with the unit.  Returns nonzero if something went wrong. */\n \n@@ -1954,16 +1596,15 @@ inquire_readwrite (const char *string, int len)\n gfc_offset\n file_length (stream * s)\n {\n-  return ((unix_stream *) s)->file_length;\n-}\n-\n-\n-/* file_position()-- Return the current position of the file */\n-\n-gfc_offset\n-file_position (stream *s)\n-{\n-  return ((unix_stream *) s)->logical_offset;\n+  off_t curr, end;\n+  if (!is_seekable (s))\n+    return -1;\n+  curr = stell (s);\n+  if (curr == -1)\n+    return curr;\n+  end = sseek (s, 0, SEEK_END);\n+  sseek (s, curr, SEEK_SET);\n+  return end;\n }\n \n \n@@ -1988,12 +1629,6 @@ is_special (stream *s)\n }\n \n \n-try\n-flush (stream *s)\n-{\n-  return fd_flush( (unix_stream *) s);\n-}\n-\n int\n stream_isatty (stream *s)\n {\n@@ -2010,12 +1645,6 @@ stream_ttyname (stream *s __attribute__ ((unused)))\n #endif\n }\n \n-gfc_offset\n-stream_offset (stream *s)\n-{\n-  return (((unix_stream *) s)->logical_offset);\n-}\n-\n \n /* How files are stored:  This is an operating-system specific issue,\n    and therefore belongs here.  There are three cases to consider."}, {"sha": "0b439dd7bd2e3ed8e0fb7c4fa26910e0735621ba", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7812c78c341fb4c6559cf8158b15c48c7a1d6fde/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=7812c78c341fb4c6559cf8158b15c48c7a1d6fde", "patch": "@@ -113,7 +113,7 @@ write_utf8_char4 (st_parameter_dt *dtp, gfc_char4_t *source,\n   gfc_char4_t c;\n   static const uchar masks[6] =  { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n   static const uchar limits[6] = { 0x80, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE };\n-  size_t nbytes;\n+  int nbytes;\n   uchar buf[6], d, *q; \n \n   /* Take care of preceding blanks.  */\n@@ -784,8 +784,7 @@ write_x (st_parameter_dt *dtp, int len, int nspaces)\n   p = write_block (dtp, len);\n   if (p == NULL)\n     return;\n-\n-  if (nspaces > 0)\n+  if (nspaces > 0 && len - nspaces >= 0)\n     memset (&p[len - nspaces], ' ', nspaces);\n }\n \n@@ -1173,7 +1172,7 @@ namelist_write_newline (st_parameter_dt *dtp)\n \t  /* Now seek to this record */\n \t  record = record * dtp->u.p.current_unit->recl;\n \n-\t  if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n+\t  if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)\n \t    {\n \t      generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t      return;"}]}