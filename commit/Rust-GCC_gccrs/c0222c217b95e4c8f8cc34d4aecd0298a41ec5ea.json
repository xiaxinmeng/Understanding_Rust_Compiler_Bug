{"sha": "c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAyMjJjMjE3Yjk1ZTRjOGY4Y2MzNGQ0YWVjZDAyOThhNDFlYzVlYQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-09-12T03:45:22Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-09-12T03:45:22Z"}, "message": "More multi-register structure return recognition fixes and:\n\n\t* config/sparc/sparc.md (movdf_const_intreg_sp64): Disable.\n\nFrom-SVN: r22396", "tree": {"sha": "126a9b30c0a9ea97ed7ecfeae273a0a869ec597e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/126a9b30c0a9ea97ed7ecfeae273a0a869ec597e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea/comments", "author": null, "committer": null, "parents": [{"sha": "86465af7347851ef4d3473eabb4c7088b5443e6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86465af7347851ef4d3473eabb4c7088b5443e6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86465af7347851ef4d3473eabb4c7088b5443e6d"}], "stats": {"total": 151, "additions": 129, "deletions": 22}, "files": [{"sha": "98f60c72918f588ca18b4d04bd50d673abf6b811", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea", "patch": "@@ -6,6 +6,16 @@ Fri Sep 11 23:55:54 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n \t(count_reg_sets_1): Likewise.\n \t(count_reg_references):\tLikewise.\n \t* rtlanal.c (note_stores): Likewise.\n+\t(reg_overlap_mentioned_p): Likewise.\n+\t* haifa-sched.c (check_live_1): Likewise.\n+\t(update_live_1): Likewise.\n+\t(sched_analyze_1): Likewise.\n+\t(sched_note_set): Likewise.\n+\t(birthing_insn_p): Likewise.\n+\t(attach_deaths): Likewise.\n+\n+\t* config/sparc/sparc.md (movdf_const_intreg_sp64): Disable.\n+\n \n Fri Sep 11 22:57:55 1998  Eric Dumazet  <dumazet@cosmosbay.com>\n "}, {"sha": "8129fa3dcfdb81ee82c2287c04a48127ab15ca6c", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea", "patch": "@@ -2949,10 +2949,15 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n+;; ?? This and split disabled on sparc64... When I change the destination\n+;; ?? reg to be DImode to emit the constant formation code, the instruction\n+;; ?? scheduler does not want to believe that it is the same as the DFmode\n+;; ?? subreg we started with...  See the SFmode version of this above to\n+;; ?? see how it can be handled.\n (define_insn \"*movdf_const_intreg_sp64\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=e,e,r\")\n         (match_operand:DF 1 \"\"                 \"m,o,F\"))]\n-  \"TARGET_FPU && TARGET_ARCH64\n+  \"0 && TARGET_FPU && TARGET_ARCH64\n    && GET_CODE (operands[1]) == CONST_DOUBLE\n    && GET_CODE (operands[0]) == REG\"\n   \"*\n@@ -2968,7 +2973,8 @@\n (define_split\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n         (match_operand:DF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_FPU\n+  \"! TARGET_ARCH64\n+   && TARGET_FPU\n    && GET_CODE (operands[1]) == CONST_DOUBLE\n    && (GET_CODE (operands[0]) == REG\n        && REGNO (operands[0]) < 32)\n@@ -2985,22 +2991,39 @@\n     operands[0] = alter_subreg (operands[0]);\n   operands[0] = gen_rtx_raw_REG (DImode, REGNO (operands[0]));\n \n-  emit_insn (gen_movsi (gen_highpart (SImode, operands[0]),\n-\t\t\tGEN_INT (l[0])));\n-\n-  /* Slick... but this trick loses if this subreg constant part\n-     can be done in one insn.  */\n-  if (l[1] == l[0]\n-      && !(SPARC_SETHI_P (l[0])\n-\t   || SPARC_SIMM13_P (l[0])))\n+  if (TARGET_ARCH64)\n     {\n-      emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n-\t\t\t    gen_highpart (SImode, operands[0])));\n+#if HOST_BITS_PER_WIDE_INT == 64\n+      HOST_WIDE_INT val;\n+\n+      val = ((HOST_WIDE_INT)l[1] |\n+             ((HOST_WIDE_INT)l[0] << 32));\n+      emit_insn (gen_movdi (operands[0], GEN_INT (val)));\n+#else\n+      emit_insn (gen_movdi (operands[0],\n+                            gen_rtx_CONST_DOUBLE (VOIDmode, const0_rtx,\n+                                                  l[1], l[0])));\n+#endif\n     }\n   else\n     {\n-      emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n-\t\t\t    GEN_INT (l[1])));\n+      emit_insn (gen_movsi (gen_highpart (SImode, operands[0]),\n+\t\t\t    GEN_INT (l[0])));\n+\n+      /* Slick... but this trick loses if this subreg constant part\n+         can be done in one insn.  */\n+      if (l[1] == l[0]\n+          && !(SPARC_SETHI_P (l[0])\n+\t       || SPARC_SIMM13_P (l[0])))\n+        {\n+          emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n+\t\t\t        gen_highpart (SImode, operands[0])));\n+        }\n+      else\n+        {\n+          emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n+\t\t\t        GEN_INT (l[1])));\n+        }\n     }\n   DONE;\n }\")"}, {"sha": "459987c279d0e164f019543e563a6fd4f68a3be4", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 70, "deletions": 8, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea", "patch": "@@ -2117,6 +2117,16 @@ check_live_1 (src, x)\n \t || GET_CODE (reg) == STRICT_LOW_PART)\n     reg = XEXP (reg, 0);\n \n+  if (GET_CODE (reg) == PARALLEL\n+      && GET_MODE (reg) == BLKmode)\n+    {\n+      register int i;\n+      for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n+\tif (check_live_1 (src, XVECEXP (reg, 0, i)))\n+\t  return 1;\n+      return 0;\n+    }\n+\n   if (GET_CODE (reg) != REG)\n     return 1;\n \n@@ -2185,6 +2195,15 @@ update_live_1 (src, x)\n \t || GET_CODE (reg) == STRICT_LOW_PART)\n     reg = XEXP (reg, 0);\n \n+  if (GET_CODE (reg) == PARALLEL\n+      && GET_MODE (reg) == BLKmode)\n+    {\n+      register int i;\n+      for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n+\tupdate_live_1 (src, XVECEXP (reg, 0, i));\n+      return;\n+    }\n+\n   if (GET_CODE (reg) != REG)\n     return;\n \n@@ -3288,6 +3307,17 @@ sched_analyze_1 (x, insn)\n   if (dest == 0)\n     return;\n \n+  if (GET_CODE (dest) == PARALLEL\n+      && GET_MODE (dest) == BLKmode)\n+    {\n+      register int i;\n+      for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n+\tsched_analyze_1 (XVECEXP (dest, 0, i), insn);\n+      if (GET_CODE (x) == SET)\n+\tsched_analyze_2 (SET_SRC (x), insn);\n+      return;\n+    }\n+\n   while (GET_CODE (dest) == STRICT_LOW_PART || GET_CODE (dest) == SUBREG\n       || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SIGN_EXTRACT)\n     {\n@@ -3982,6 +4012,15 @@ sched_note_set (x, death)\n   if (reg == 0)\n     return;\n \n+  if (GET_CODE (reg) == PARALLEL\n+      && GET_MODE (reg) == BLKmode)\n+    {\n+      register int i;\n+      for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n+\tsched_note_set (XVECEXP (reg, 0, i), death);\n+      return;\n+    }\n+\n   while (GET_CODE (reg) == SUBREG || GET_CODE (reg) == STRICT_LOW_PART\n \t || GET_CODE (reg) == SIGN_EXTRACT || GET_CODE (reg) == ZERO_EXTRACT)\n     {\n@@ -4215,18 +4254,31 @@ birthing_insn_p (pat)\n     return 0;\n \n   if (GET_CODE (pat) == SET\n-      && GET_CODE (SET_DEST (pat)) == REG)\n+      && (GET_CODE (SET_DEST (pat)) == REG\n+\t  || (GET_CODE (SET_DEST (pat)) == PARALLEL\n+\t      && GET_MODE (SET_DEST (pat)) == BLKmode)))\n     {\n       rtx dest = SET_DEST (pat);\n-      int i = REGNO (dest);\n+      int i;\n \n       /* It would be more accurate to use refers_to_regno_p or\n-         reg_mentioned_p to determine when the dest is not live before this\n-         insn.  */\n-\n-      if (REGNO_REG_SET_P (bb_live_regs, i))\n-\treturn (REG_N_SETS (i) == 1);\n-\n+\t reg_mentioned_p to determine when the dest is not live before this\n+\t insn.  */\n+      if (GET_CODE (dest) == REG)\n+\t{\n+\t  i = REGNO (dest);\n+\t  if (REGNO_REG_SET_P (bb_live_regs, i))\n+\t    return (REG_N_SETS (i) == 1);\n+\t}\n+      else\n+\t{\n+\t  for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n+\t    {\n+\t      int regno = REGNO (SET_DEST (XVECEXP (dest, 0, i)));\n+\t      if (REGNO_REG_SET_P (bb_live_regs, regno))\n+\t\treturn (REG_N_SETS (regno) == 1);\n+\t    }\n+\t}\n       return 0;\n     }\n   if (GET_CODE (pat) == PARALLEL)\n@@ -4638,6 +4690,16 @@ attach_deaths (x, insn, set_p)\n       attach_deaths (XEXP (x, 2), insn, 0);\n       return;\n \n+    case PARALLEL:\n+      if (set_p\n+\t  && GET_MODE (x) == BLKmode)\n+\t{\n+\t  for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\t    attach_deaths (SET_DEST (XVECEXP (x, 0, i)), insn, 1);\n+\t  return;\n+\t}\n+\n+      /* fallthrough */\n     default:\n       /* Other cases: walk the insn.  */\n       fmt = GET_RTX_FORMAT (code);"}, {"sha": "6e5fa77fd3e0abfdae340cdda522eaa78d104d66", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=c0222c217b95e4c8f8cc34d4aecd0298a41ec5ea", "patch": "@@ -851,6 +851,18 @@ reg_overlap_mentioned_p (x, in)\n   else if (GET_CODE (x) == SCRATCH || GET_CODE (x) == PC\n \t   || GET_CODE (x) == CC0)\n     return reg_mentioned_p (x, in);\n+  else if (GET_CODE (x) == PARALLEL\n+\t   && GET_MODE (x) == BLKmode)\n+    {\n+      register int i;\n+\n+      /* If any register in here refers to it\n+\t we return true.  */\n+      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\tif (reg_overlap_mentioned_p (SET_DEST (XVECEXP (x, 0, i)), in))\n+\t  return 1;\n+      return 0;\n+    }\n   else\n     abort ();\n "}]}