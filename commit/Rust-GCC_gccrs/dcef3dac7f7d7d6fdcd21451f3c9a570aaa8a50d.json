{"sha": "dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNlZjNkYWM3ZjdkN2Q2ZmRjZDIxNDUxZjNjOWE1NzBhYWE4YTUwZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2008-07-06T13:33:05Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2008-07-06T13:33:05Z"}, "message": "jcf-io.c: Don't include fnmatch.h.\n\n\t* jcf-io.c: Don't include fnmatch.h.  Don't use JCF_USE_SCANDIR.\n\t(compare_path): Remove.\n\t(java_or_class_file): Likewise.\n\t(memoized_dirlist_entry): Likewise.\n\t(memoized_dirlist_hash): Likewise.\n\t(memoized_dirlist_lookup_eq): Likewise.\n\t(memoized_dirlists): Likewise.\n\t(caching_stat): Likewise.\n\t(find_class): Use stat.\n\t* jcf.h (JCF_USE_SCANDIR): Remove.\n\nFrom-SVN: r137523", "tree": {"sha": "7ddb197a2bf5bf748c7d71a7c592b6858b568551", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ddb197a2bf5bf748c7d71a7c592b6858b568551"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d/comments", "author": null, "committer": null, "parents": [{"sha": "a0ed509928bf2ab7544da098a6f41eb457c5c3ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ed509928bf2ab7544da098a6f41eb457c5c3ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0ed509928bf2ab7544da098a6f41eb457c5c3ad"}], "stats": {"total": 167, "additions": 15, "deletions": 152}, "files": [{"sha": "a8ae772a66e1033bea6ca6c1d32fb2d9740a153d", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d", "patch": "@@ -1,3 +1,16 @@\n+2008-07-05  Tom Tromey  <tromey@redhat.com>\n+\n+\t* jcf-io.c: Don't include fnmatch.h.  Don't use JCF_USE_SCANDIR.\n+\t(compare_path): Remove.\n+\t(java_or_class_file): Likewise.\n+\t(memoized_dirlist_entry): Likewise.\n+\t(memoized_dirlist_hash): Likewise.\n+\t(memoized_dirlist_lookup_eq): Likewise.\n+\t(memoized_dirlists): Likewise.\n+\t(caching_stat): Likewise.\n+\t(find_class): Use stat.\n+\t* jcf.h (JCF_USE_SCANDIR): Remove.\n+\n 2008-06-30  Joshua Sumali  <jsumali@redhat.com>\n \n \t* Make-lang.in (JAVA_MANFILES): Add doc/aot-compile.1 and"}, {"sha": "b968214e50904866a035462cd19eb8d0913e26e0", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 1, "deletions": 143, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d", "patch": "@@ -34,10 +34,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"toplev.h\"\n #include \"java-tree.h\"\n #include \"hashtab.h\"\n-#if JCF_USE_SCANDIR\n #include <dirent.h>\n-#include <fnmatch.h>\n-#endif\n \n #include \"zlib.h\"\n \n@@ -283,145 +280,6 @@ find_classfile (char *filename, JCF *jcf, const char *dep_name)\n   return open_class (filename, jcf, fd, dep_name);\n }\n \n-#if JCF_USE_SCANDIR\n-\n-/* A comparison function (as for qsort) that compares KEY (a char *\n-   giving the basename of a file) with the name stored in ENTRY (a\n-   dirent **).  */\n-\n-static int\n-compare_path (const void *key, const void *entry)\n-{\n-  return strcmp ((const char *) key, \n-\t\t (*((const struct dirent *const*) entry))->d_name);\n-}\n-\n-/* Returns nonzero if ENTRY names a .java or .class file.  */\n-\n-static int\n-java_or_class_file (const struct dirent *entry)\n-{\n-  const char *base = lbasename (entry->d_name);\n-  return (fnmatch (\"*.java\", base, 0) == 0 || \n-\t  fnmatch (\"*.class\", base, 0) == 0);\n-}\n-\n-/* Information about the files present in a particular directory.  */\n-typedef struct memoized_dirlist_entry \n-{\n-  /* The name of the directory.  */\n-  const char *dir;\n-  /* The number of .java and .class files present, or -1 if we could\n-     not, for some reason, obtain the list.  */\n-  int num_files;\n-  /* The .java and .class files in the directory, in alphabetical\n-     order.  */\n-  struct dirent **files;\n-} memoized_dirlist_entry;\n-\n-/* A hash function for a memoized_dirlist_entry.  */\n-static hashval_t\n-memoized_dirlist_hash (const void *entry)\n-{\n-  const memoized_dirlist_entry *mde = (const memoized_dirlist_entry *) entry;\n-  return htab_hash_string (mde->dir);\n-}\n-\n-/* Returns true if ENTRY (a memoized_dirlist_entry *) corresponds to\n-   the directory given by KEY (a char *) giving the directory \n-   name.  */\n-\n-static int\n-memoized_dirlist_lookup_eq (const void *entry, const void *key)\n-{\n-  return strcmp ((const char *) key,\n-\t\t ((const memoized_dirlist_entry *) entry)->dir) == 0;\n-}\n-\n-/* A hash table mapping directory names to the lists of .java and\n-   .class files in that directory.  */\n-\n-static htab_t memoized_dirlists;\n-\n-#endif\n-\n-/* Like stat, but avoids actually making the stat system call if we\n-   know that it cannot succeed.  FILENAME and BUF are as for stat.  */\n-\n-static int\n-caching_stat (char *filename, struct stat *buf)\n-{\n-#if JCF_USE_SCANDIR\n-  char *sep;\n-  char origsep = 0;\n-  char *base;\n-  memoized_dirlist_entry *dent;\n-  void **slot;\n-  struct memoized_dirlist_entry temp;\n-  \n-  /* If the hashtable has not already been created, create it now.  */\n-  if (!memoized_dirlists)\n-    memoized_dirlists = htab_create (37,\n-\t\t\t\t     memoized_dirlist_hash,\n-\t\t\t\t     memoized_dirlist_lookup_eq,\n-\t\t\t\t     NULL);\n-\n-  /* Get the name of the directory.  */\n-  sep = strrchr (filename, DIR_SEPARATOR);\n-#ifdef DIR_SEPARATOR_2\n-  if (! sep)\n-    sep = strrchr (filename, DIR_SEPARATOR_2);\n-#endif\n-  if (sep)\n-    {\n-      origsep = *sep;\n-      *sep = '\\0';\n-      base = sep + 1;\n-    }\n-  else\n-    base = filename;\n-\n-  /* Obtain the entry for this directory from the hash table.  This\n-     approach is ok since we know that the hash function only looks at\n-     the directory name.  */\n-  temp.dir = filename;\n-  temp.num_files = 0;\n-  temp.files = NULL;\n-  slot = htab_find_slot (memoized_dirlists, &temp, INSERT);\n-  if (!*slot)\n-    {\n-      /* We have not already scanned this directory; scan it now.  */\n-      dent = XNEW (memoized_dirlist_entry);\n-      dent->dir = xstrdup (filename);\n-      /* Unfortunately, scandir is not fully standardized.  In\n-\t particular, the type of the function pointer passed as the\n-\t third argument sometimes takes a \"const struct dirent *\"\n-\t parameter, and sometimes just a \"struct dirent *\".  We cast\n-\t to (void *) and use __extension__ so that either way it is\n-\t quietly accepted.  FIXME: scandir is not in POSIX.  */\n-      dent->num_files = __extension__ scandir (filename, &dent->files, \n-\t\t\t\t\t       (void *) java_or_class_file, \n-\t\t\t\t\t       alphasort);\n-      *slot = dent;\n-    }\n-  else\n-    dent = *((memoized_dirlist_entry **) slot);\n-\n-  /* Put the separator back.  */\n-  if (sep)\n-    *sep = origsep;\n-\n-  /* If the file is not in the list, there is no need to stat it; it\n-     does not exist.  */\n-  if (dent->num_files != -1\n-      && !bsearch (base, dent->files, dent->num_files,\n-\t\t   sizeof (struct dirent *), compare_path))\n-    return -1;\n-#endif\n-  \n-  return stat (filename, buf);\n-}\n-\n /* Returns 1 if the CLASSNAME (really a char *) matches the name\n    stored in TABLE_ENTRY (also a char *).  */\n \n@@ -521,7 +379,7 @@ find_class (const char *classname, int classname_length, JCF *jcf)\n \t      else\n \t\tcontinue;\n \t    }\n-\t  klass = caching_stat(buffer, &class_buf);\n+\t  klass = stat (buffer, &class_buf);\n \t}\n     }\n "}, {"sha": "40bbd725d45b36df4613b79349b3798a8791c8ed", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=dcef3dac7f7d7d6fdcd21451f3c9a570aaa8a50d", "patch": "@@ -1,6 +1,6 @@\n /* Utility macros to read Java(TM) .class files and byte codes.\n    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-   2006, 2007 Free Software Foundation, Inc.\n+   2006, 2007, 2008 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -45,14 +45,6 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #define JCF_word JCF_u4\n #endif\n \n-/* If we have both \"scandir\" and \"alphasort\", we can cache directory\n-   listings to reduce the time taken to search the classpath.  */\n-#if defined(HAVE_SCANDIR) && defined(HAVE_ALPHASORT)\n-#define JCF_USE_SCANDIR 1\n-#else\n-#define JCF_USE_SCANDIR 0\n-#endif \n-\n /* On case-insensitive file systems, we need to ensure that a request\n    to open a .java or .class file is honored only if the file to be\n    opened is of the exact case we are asking for. In other words, we"}]}