{"sha": "abd5730b2df531b752b1447e05f1c947f5ecdeb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJkNTczMGIyZGY1MzFiNzUyYjE0NDdlMDVmMWM5NDdmNWVjZGViMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-11-21T06:33:56Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-11-21T06:33:56Z"}, "message": "PR c++/9050, DR 147, DR 318\n\n\tPR c++/9050, DR 147, DR 318\n\t* parser.c (cp_parser_lookup_name): If the name matches the explicit\n\tclass scope, we're naming the constructor.\n\t(cp_parser_constructor_declarator_p): Just use cp_parser_unqualified_id\n\tif we have a nested-name-specifier.\n\t(cp_parser_direct_declarator): Handle getting an overload set as a\n\tconstructor declarator.\n\t(cp_parser_unqualified_id): Avoid looking up the constructor when\n\tnaming the destructor.\n\t(cp_parser_diagnose_invalid_type_name): Give good\n\tdiagnostic for improper use of constructor as template.\n\t* typeck.c (finish_class_member_access_expr): Give good diagnostic\n\tabout calling constructor.\n\n\t* error.c (dump_aggr_type): Don't print A::A for injected-class-name.\n\nFrom-SVN: r154403", "tree": {"sha": "7f4536668ed93e9f54f2a097d69e1d19bbdfd521", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f4536668ed93e9f54f2a097d69e1d19bbdfd521"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abd5730b2df531b752b1447e05f1c947f5ecdeb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd5730b2df531b752b1447e05f1c947f5ecdeb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abd5730b2df531b752b1447e05f1c947f5ecdeb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd5730b2df531b752b1447e05f1c947f5ecdeb2/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42a06e46ab05b7cf751579a50ee302a8ab6b9cae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42a06e46ab05b7cf751579a50ee302a8ab6b9cae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42a06e46ab05b7cf751579a50ee302a8ab6b9cae"}], "stats": {"total": 188, "additions": 141, "deletions": 47}, "files": [{"sha": "b9f1cbebbfbd23110879c30c755c646f73e4cff1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=abd5730b2df531b752b1447e05f1c947f5ecdeb2", "patch": "@@ -1,3 +1,21 @@\n+2009-11-20  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/9050, DR 147, DR 318\n+\t* parser.c (cp_parser_lookup_name): If the name matches the explicit\n+\tclass scope, we're naming the constructor.\n+\t(cp_parser_constructor_declarator_p): Just use cp_parser_unqualified_id\n+\tif we have a nested-name-specifier.\n+\t(cp_parser_direct_declarator): Handle getting an overload set as a\n+\tconstructor declarator.\n+\t(cp_parser_unqualified_id): Avoid looking up the constructor when\n+\tnaming the destructor.\n+\t(cp_parser_diagnose_invalid_type_name): Give good\n+\tdiagnostic for improper use of constructor as template.\n+\t* typeck.c (finish_class_member_access_expr): Give good diagnostic\n+\tabout calling constructor.\n+\n+\t* error.c (dump_aggr_type): Don't print A::A for injected-class-name.\n+\n 2009-11-20  Simon Martin  <simartin@users.sourceforge.net>\n \n \tPR c++/38646"}, {"sha": "e0e5ae52ceb73f90b739655b92a4add6acd3141e", "filename": "gcc/cp/error.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=abd5730b2df531b752b1447e05f1c947f5ecdeb2", "patch": "@@ -568,10 +568,11 @@ dump_aggr_type (tree t, int flags)\n     {\n       typdef = !DECL_ARTIFICIAL (name);\n \n-      if (typdef\n-\t  && ((flags & TFF_CHASE_TYPEDEF)\n-\t      || (!flag_pretty_templates && DECL_LANG_SPECIFIC (name)\n-\t\t  && DECL_TEMPLATE_INFO (name))))\n+      if ((typdef\n+\t   && ((flags & TFF_CHASE_TYPEDEF)\n+\t       || (!flag_pretty_templates && DECL_LANG_SPECIFIC (name)\n+\t\t   && DECL_TEMPLATE_INFO (name))))\n+\t  || DECL_SELF_REFERENCE_P (name))\n \t{\n \t  t = TYPE_MAIN_VARIANT (t);\n \t  name = TYPE_NAME (t);"}, {"sha": "c7560a872b4eb5717b648e49517bb6be580a3b75", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 83, "deletions": 36, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=abd5730b2df531b752b1447e05f1c947f5ecdeb2", "patch": "@@ -2400,6 +2400,12 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser,\n       if (TREE_CODE (parser->scope) == NAMESPACE_DECL)\n \terror_at (location, \"%qE in namespace %qE does not name a type\",\n \t\t  id, parser->scope);\n+      else if (CLASS_TYPE_P (parser->scope)\n+\t       && constructor_name_p (id, parser->scope)\n+\t       && cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n+\t/* A<T>::A<T>() */\n+\terror_at (location, \"invalid use of constructor %<%T::%E%> as \"\n+\t\t  \"template\", parser->scope, id);\n       else if (TYPE_P (parser->scope)\n \t       && dependent_scope_p (parser->scope))\n \terror_at (location, \"need %<typename%> before %<%T::%E%> because \"\n@@ -3890,15 +3896,19 @@ cp_parser_unqualified_id (cp_parser* parser,\n \tif (scope\n \t    && token->type == CPP_NAME\n \t    && (cp_lexer_peek_nth_token (parser->lexer, 2)->type\n-\t\t== CPP_OPEN_PAREN)\n+\t\t!= CPP_LESS)\n \t    && constructor_name_p (token->u.value, scope))\n \t  {\n \t    cp_lexer_consume_token (parser->lexer);\n \t    return build_nt (BIT_NOT_EXPR, scope);\n \t  }\n \n \t/* If there was an explicit qualification (S::~T), first look\n-\t   in the scope given by the qualification (i.e., S).  */\n+\t   in the scope given by the qualification (i.e., S).\n+\n+\t   Note: in the calls to cp_parser_class_name below we pretend that\n+\t   the lookup had an explicit 'class' tag so that lookup finds the\n+\t   injected-class-name rather than the constructor.  */\n \tdone = false;\n \ttype_decl = NULL_TREE;\n \tif (scope)\n@@ -3907,7 +3917,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t    type_decl = cp_parser_class_name (parser,\n \t\t\t\t\t      /*typename_keyword_p=*/false,\n \t\t\t\t\t      /*template_keyword_p=*/false,\n-\t\t\t\t\t      none_type,\n+\t\t\t\t\t      class_type,\n \t\t\t\t\t      /*check_dependency=*/false,\n \t\t\t\t\t      /*class_head_p=*/false,\n \t\t\t\t\t      declarator_p);\n@@ -3925,7 +3935,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t      = cp_parser_class_name (parser,\n \t\t\t\t      /*typename_keyword_p=*/false,\n \t\t\t\t      /*template_keyword_p=*/false,\n-\t\t\t\t      none_type,\n+\t\t\t\t      class_type,\n \t\t\t\t      /*check_dependency=*/false,\n \t\t\t\t      /*class_head_p=*/false,\n \t\t\t\t      declarator_p);\n@@ -3943,7 +3953,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t      = cp_parser_class_name (parser,\n \t\t\t\t      /*typename_keyword_p=*/false,\n \t\t\t\t      /*template_keyword_p=*/false,\n-\t\t\t\t      none_type,\n+\t\t\t\t      class_type,\n \t\t\t\t      /*check_dependency=*/false,\n \t\t\t\t      /*class_head_p=*/false,\n \t\t\t\t      declarator_p);\n@@ -3962,7 +3972,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t      = cp_parser_class_name (parser,\n \t\t\t\t      /*typename_keyword_p=*/false,\n \t\t\t\t      /*template_keyword_p=*/false,\n-\t\t\t\t      none_type,\n+\t\t\t\t      class_type,\n \t\t\t\t      /*check_dependency=*/false,\n \t\t\t\t      /*class_head_p=*/false,\n \t\t\t\t      declarator_p);\n@@ -14275,6 +14285,10 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\tunqualified_name = constructor_name (class_type);\n \t\t\tsfk = sfk_constructor;\n \t\t      }\n+\t\t    else if (is_overloaded_fn (unqualified_name)\n+\t\t\t     && DECL_CONSTRUCTOR_P (get_first_fn\n+\t\t\t\t\t\t    (unqualified_name)))\n+\t\t      sfk = sfk_constructor;\n \n \t\t    if (ctor_dtor_or_conv_p && sfk != sfk_none)\n \t\t      *ctor_dtor_or_conv_p = -1;\n@@ -17969,6 +17983,26 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t     lookup_member, we must enter the scope here.  */\n \t  if (dependent_p)\n \t    pushed_scope = push_scope (parser->scope);\n+\n+\t  /* 3.4.3.1: In a lookup in which the constructor is an acceptable\n+\t     lookup result and the nested-name-specifier nominates a class C:\n+\t       * if the name specified after the nested-name-specifier, when\n+\t       looked up in C, is the injected-class-name of C (Clause 9), or\n+\t       * if the name specified after the nested-name-specifier is the\n+\t       same as the identifier or the simple-template-id's template-\n+\t       name in the last component of the nested-name-specifier,\n+\t     the name is instead considered to name the constructor of\n+\t     class C. [ Note: for example, the constructor is not an\n+\t     acceptable lookup result in an elaborated-type-specifier so\n+\t     the constructor would not be used in place of the\n+\t     injected-class-name. --end note ] Such a constructor name\n+\t     shall be used only in the declarator-id of a declaration that\n+\t     names a constructor or in a using-declaration.  */\n+\t  if (tag_type == none_type\n+\t      && CLASS_TYPE_P (parser->scope)\n+\t      && constructor_name_p (name, parser->scope))\n+\t    name = ctor_identifier;\n+\n \t  /* If the PARSER->SCOPE is a template specialization, it\n \t     may be instantiated during name lookup.  In that case,\n \t     errors may be issued.  Even if we rollback the current\n@@ -18320,8 +18354,7 @@ static bool\n cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n {\n   bool constructor_p;\n-  tree type_decl = NULL_TREE;\n-  bool nested_name_p;\n+  tree nested_name_specifier;\n   cp_token *next_token;\n \n   /* The common case is that this is not a constructor declarator, so\n@@ -18347,34 +18380,48 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n   cp_parser_global_scope_opt (parser,\n \t\t\t      /*current_scope_valid_p=*/false);\n   /* Look for the nested-name-specifier.  */\n-  nested_name_p\n+  nested_name_specifier\n     = (cp_parser_nested_name_specifier_opt (parser,\n \t\t\t\t\t    /*typename_keyword_p=*/false,\n \t\t\t\t\t    /*check_dependency_p=*/false,\n \t\t\t\t\t    /*type_p=*/false,\n-\t\t\t\t\t    /*is_declaration=*/false)\n-       != NULL_TREE);\n+\t\t\t\t\t    /*is_declaration=*/false));\n   /* Outside of a class-specifier, there must be a\n      nested-name-specifier.  */\n-  if (!nested_name_p &&\n+  if (!nested_name_specifier &&\n       (!at_class_scope_p () || !TYPE_BEING_DEFINED (current_class_type)\n        || friend_p))\n     constructor_p = false;\n+  else if (nested_name_specifier == error_mark_node)\n+    constructor_p = false;\n+\n+  /* If we have a class scope, this is easy; DR 147 says that S::S always\n+     names the constructor, and no other qualified name could.  */\n+  if (constructor_p && nested_name_specifier\n+      && TYPE_P (nested_name_specifier))\n+    {\n+      tree id = cp_parser_unqualified_id (parser,\n+\t\t\t\t\t  /*template_keyword_p=*/false,\n+\t\t\t\t\t  /*check_dependency_p=*/false,\n+\t\t\t\t\t  /*declarator_p=*/true,\n+\t\t\t\t\t  /*optional_p=*/false);\n+      if (is_overloaded_fn (id))\n+\tid = DECL_NAME (get_first_fn (id));\n+      if (!constructor_name_p (id, nested_name_specifier))\n+\tconstructor_p = false;\n+    }\n   /* If we still think that this might be a constructor-declarator,\n      look for a class-name.  */\n-  if (constructor_p)\n+  else if (constructor_p)\n     {\n       /* If we have:\n \n-\t   template <typename T> struct S { S(); };\n-\t   template <typename T> S<T>::S ();\n-\n-\t we must recognize that the nested `S' names a class.\n-\t Similarly, for:\n+\t   template <typename T> struct S {\n+\t     S();\n+\t   };\n \n-\t   template <typename T> S<T>::S<T> ();\n-\n-\t we must recognize that the nested `S' names a template.  */\n+\t we must recognize that the nested `S' names a class.  */\n+      tree type_decl;\n       type_decl = cp_parser_class_name (parser,\n \t\t\t\t\t/*typename_keyword_p=*/false,\n \t\t\t\t\t/*template_keyword_p=*/false,\n@@ -18384,22 +18431,23 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t\t\t\t\t/*is_declaration=*/false);\n       /* If there was no class-name, then this is not a constructor.  */\n       constructor_p = !cp_parser_error_occurred (parser);\n-    }\n \n-  /* If we're still considering a constructor, we have to see a `(',\n-     to begin the parameter-declaration-clause, followed by either a\n-     `)', an `...', or a decl-specifier.  We need to check for a\n-     type-specifier to avoid being fooled into thinking that:\n+      /* If we're still considering a constructor, we have to see a `(',\n+\t to begin the parameter-declaration-clause, followed by either a\n+\t `)', an `...', or a decl-specifier.  We need to check for a\n+\t type-specifier to avoid being fooled into thinking that:\n \n-       S::S (f) (int);\n+\t   S (f) (int);\n \n-     is a constructor.  (It is actually a function named `f' that\n-     takes one parameter (of type `int') and returns a value of type\n-     `S::S'.  */\n-  if (constructor_p\n-      && cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n-    {\n-      if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN)\n+\t is a constructor.  (It is actually a function named `f' that\n+\t takes one parameter (of type `int') and returns a value of type\n+\t `S'.  */\n+      if (constructor_p\n+\t  && !cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+\tconstructor_p = false;\n+\n+      if (constructor_p\n+\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN)\n \t  && cp_lexer_next_token_is_not (parser->lexer, CPP_ELLIPSIS)\n \t  /* A parameter declaration begins with a decl-specifier,\n \t     which is either the \"attribute\" keyword, a storage class\n@@ -18454,8 +18502,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \t  constructor_p = !cp_parser_error_occurred (parser);\n \t}\n     }\n-  else\n-    constructor_p = false;\n+\n   /* We did not really want to consume any tokens.  */\n   cp_parser_abort_tentative_parse (parser);\n "}, {"sha": "307825f65160126da0b91aac657fe453682a9121", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=abd5730b2df531b752b1447e05f1c947f5ecdeb2", "patch": "@@ -2429,6 +2429,14 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n \t  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE\n \t\t      || TREE_CODE (name) == BIT_NOT_EXPR);\n \n+\t  if (constructor_name_p (name, scope))\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror (\"cannot call constructor %<%T::%D%> directly\",\n+\t\t       scope, name);\n+\t      return error_mark_node;\n+\t    }\n+\n \t  /* Find the base of OBJECT_TYPE corresponding to SCOPE.  */\n \t  access_path = lookup_base (object_type, scope, ba_check, NULL);\n \t  if (access_path == error_mark_node)"}, {"sha": "0c067501f1a4aaf7542a19f7e7a2c59d92d2d985", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=abd5730b2df531b752b1447e05f1c947f5ecdeb2", "patch": "@@ -1,3 +1,12 @@\n+2009-11-20  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/9050, DR 147, DR 318\n+\t* g++.dg/template/ctor9.C: New.\n+\t* g++.dg/tc1/dr147.C: Remove xfails.\n+\t* g++.dg/lookup/name-clash4.C: Adjust.\n+\t* g++.old-deja/g++.jason/temporary5.C: Adjust.\n+\t* g++.old-deja/g++.pt/ctor2.C: Adjust.\n+\n 2009-11-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/42078"}, {"sha": "d6c6d97bbc1330ef3081700bc2740e00768844f8", "filename": "gcc/testsuite/g++.dg/lookup/name-clash4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fname-clash4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fname-clash4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fname-clash4.C?ref=abd5730b2df531b752b1447e05f1c947f5ecdeb2", "patch": "@@ -9,4 +9,4 @@ struct A\n     template<int> struct A {};\t// { dg-error \"same name\" }\n };\n \n-A::A<0> a;\t\t\t// { dg-error \"not a template\" }\n+A::A<0> a;\t// { dg-error \"not a template|invalid use of constructor\" }"}, {"sha": "9c90d982f5f6ba81636066cfc861750a5d265a33", "filename": "gcc/testsuite/g++.dg/tc1/dr147.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftc1%2Fdr147.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftc1%2Fdr147.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftc1%2Fdr147.C?ref=abd5730b2df531b752b1447e05f1c947f5ecdeb2", "patch": "@@ -11,7 +11,7 @@ A::A() { }\n B::B() { }\n \n B::A ba;\n-A::A a; // { dg-error \"\" \"the injected-class-name can never be found through qualified lookup\" { xfail *-*-* } }\n+A::A a; // { dg-error \"\" \"the injected-class-name can never be found through qualified lookup\" }\n \n }\n \n@@ -26,6 +26,6 @@ template <class T> struct A {\n   template <class T2> A(T2);\n   static A x;\n };\n-template<> A<int>::A<int>(A<int>::x);  // { dg-error \"\" \"this is an invalid declaration of the constructor\" { xfail *-*-* } }\n+template<> A<int>::A<int>(A<int>::x);  // { dg-error \"\" \"this is an invalid declaration of the constructor\" }\n \n }"}, {"sha": "819ca1c940107208ace4ab8e8739d79ee9374ad0", "filename": "gcc/testsuite/g++.dg/template/ctor9.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fctor9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fctor9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fctor9.C?ref=abd5730b2df531b752b1447e05f1c947f5ecdeb2", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/9050, DR 147, 318\n+\n+struct Y\n+{\n+  template <typename T> Y (T);\n+  template <typename T> void foo (T);\n+};\n+\n+template <>      Y::Y<int>   (int)  { }"}, {"sha": "eef2e200539c91211ebed784d0007ad12c715c90", "filename": "gcc/testsuite/g++.old-deja/g++.jason/temporary5.C", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftemporary5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftemporary5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftemporary5.C?ref=abd5730b2df531b752b1447e05f1c947f5ecdeb2", "patch": "@@ -1,6 +1,6 @@\n-// { dg-do run  }\n // PRMS Id: 6604\n-// Bug: Scoped constructor call is not properly recognized as a functional cast\n+// Old bug: Scoped constructor call is not properly recognized as a functional cast\n+// But after DR 147 A::A() is a constructor call, not a functional cast.\n \n int c;\n \n@@ -12,6 +12,8 @@ struct A {\n \n int main ()\n {\n-  A::A();\n+  A a;\n+  a.A::A();\t\t\t// { dg-error \"\" }\n+  A::A();\t\t\t// { dg-error \"\" }\n   return c;\n }"}, {"sha": "802c2a4a446e65647249d65630c83bb15a6331eb", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ctor2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fctor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd5730b2df531b752b1447e05f1c947f5ecdeb2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fctor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fctor2.C?ref=abd5730b2df531b752b1447e05f1c947f5ecdeb2", "patch": "@@ -10,4 +10,4 @@ struct A {\n template <class T>\n A<T>::A<T>()   // { dg-error \"invalid use of constructor|qualified name\" }\n {\n-}\n+} // { dg-error \"end of input\" }"}]}