{"sha": "8194dcdd37de477dcb0be39d912a7eb1d465a2c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE5NGRjZGQzN2RlNDc3ZGNiMGJlMzlkOTEyYTdlYjFkNDY1YTJjNA==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2016-12-06T23:18:17Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-12-06T23:18:17Z"}, "message": "re PR tree-optimization/67955 (tree-dse does not use pointer info)\n\n\tPR tree-optimization/67955\n\t* tree-ssa-alias.c (same_addr_size_stores_p): New function.\n\t(stmt_kills_ref_p): Use it.\n\n\tPR tree-optimization/67955\n\t* gcc.dg/tree-ssa/dse-points-to.c: New test.\n\nFrom-SVN: r243325", "tree": {"sha": "cdfd7ffd14ae7f74519400f89ffe5243b71aeb31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdfd7ffd14ae7f74519400f89ffe5243b71aeb31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8194dcdd37de477dcb0be39d912a7eb1d465a2c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8194dcdd37de477dcb0be39d912a7eb1d465a2c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8194dcdd37de477dcb0be39d912a7eb1d465a2c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8194dcdd37de477dcb0be39d912a7eb1d465a2c4/comments", "author": null, "committer": null, "parents": [{"sha": "6b8805cfce8847a0d944150845cb908b6ee0ba57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8805cfce8847a0d944150845cb908b6ee0ba57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b8805cfce8847a0d944150845cb908b6ee0ba57"}], "stats": {"total": 103, "additions": 103, "deletions": 0}, "files": [{"sha": "797b7113a8a734725cce6cdd48ef7826f402fa54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8194dcdd37de477dcb0be39d912a7eb1d465a2c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8194dcdd37de477dcb0be39d912a7eb1d465a2c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8194dcdd37de477dcb0be39d912a7eb1d465a2c4", "patch": "@@ -1,3 +1,9 @@\n+2016-12-06  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/67955\n+\t* tree-ssa-alias.c (same_addr_size_stores_p): New function.\n+\t(stmt_kills_ref_p): Use it.\n+\n 2016-12-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR middle-end/78700"}, {"sha": "6090a9649170f7ed443b1c38e19ef931a9150f1d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8194dcdd37de477dcb0be39d912a7eb1d465a2c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8194dcdd37de477dcb0be39d912a7eb1d465a2c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8194dcdd37de477dcb0be39d912a7eb1d465a2c4", "patch": "@@ -1,3 +1,8 @@\n+2016-12-06  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/67955\n+\t* gcc.dg/tree-ssa/dse-points-to.c: New test.\n+\n 2016-12-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/78658"}, {"sha": "8003556474d0288f592f0d32b55bf92d7937cd9a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/dse-points-to.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8194dcdd37de477dcb0be39d912a7eb1d465a2c4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdse-points-to.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8194dcdd37de477dcb0be39d912a7eb1d465a2c4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdse-points-to.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdse-points-to.c?ref=8194dcdd37de477dcb0be39d912a7eb1d465a2c4", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-ccp -fno-tree-forwprop -fno-tree-fre -fno-tree-vrp\" } */\n+/* { dg-additional-options \"-fdump-tree-dse1-details\" } */\n+\n+int\n+f ()\n+{\n+  int a;\n+  int *p = &a;\n+  *p = 1;\n+  a = 2;\n+  return a;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Deleted dead store.*p_1\" 1 \"dse1\"} } */"}, {"sha": "37b581daf6bdc7ab08556c39ce3db0c1c76fc11f", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8194dcdd37de477dcb0be39d912a7eb1d465a2c4/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8194dcdd37de477dcb0be39d912a7eb1d465a2c4/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=8194dcdd37de477dcb0be39d912a7eb1d465a2c4", "patch": "@@ -2316,6 +2316,78 @@ stmt_may_clobber_ref_p (gimple *stmt, tree ref)\n   return stmt_may_clobber_ref_p_1 (stmt, &r);\n }\n \n+/* Return true if store1 and store2 described by corresponding tuples\n+   <BASE, OFFSET, SIZE, MAX_SIZE> have the same size and store to the same\n+   address.  */\n+\n+static bool\n+same_addr_size_stores_p (tree base1, HOST_WIDE_INT offset1, HOST_WIDE_INT size1,\n+\t\t\t HOST_WIDE_INT max_size1,\n+\t\t\t tree base2, HOST_WIDE_INT offset2, HOST_WIDE_INT size2,\n+\t\t\t HOST_WIDE_INT max_size2)\n+{\n+  /* For now, just handle VAR_DECL.  */\n+  bool base1_obj_p = VAR_P (base1);\n+  bool base2_obj_p = VAR_P (base2);\n+\n+  /* We need one object.  */\n+  if (base1_obj_p == base2_obj_p)\n+    return false;\n+  tree obj = base1_obj_p ? base1 : base2;\n+\n+  /* And we need one MEM_REF.  */\n+  bool base1_memref_p = TREE_CODE (base1) == MEM_REF;\n+  bool base2_memref_p = TREE_CODE (base2) == MEM_REF;\n+  if (base1_memref_p == base2_memref_p)\n+    return false;\n+  tree memref = base1_memref_p ? base1 : base2;\n+\n+  /* Sizes need to be valid.  */\n+  if (max_size1 == -1 || max_size2 == -1\n+      || size1 == -1 || size2 == -1)\n+    return false;\n+\n+  /* Max_size needs to match size.  */\n+  if (max_size1 != size1\n+      || max_size2 != size2)\n+    return false;\n+\n+  /* Sizes need to match.  */\n+  if (size1 != size2)\n+    return false;\n+\n+  /* Offsets need to be 0.  */\n+  if (offset1 != 0\n+      || offset2 != 0)\n+    return false;\n+\n+  /* Check that memref is a store to pointer with singleton points-to info.  */\n+  if (!tree_int_cst_equal (TREE_OPERAND (memref, 1), integer_zero_node))\n+    return false;\n+  tree ptr = TREE_OPERAND (memref, 0);\n+  if (TREE_CODE (ptr) != SSA_NAME)\n+    return false;\n+  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n+  unsigned int pt_uid;\n+  if (pi == NULL\n+      || !pt_solution_singleton_or_null_p (&pi->pt, &pt_uid))\n+    return false;\n+\n+  /* Check that ptr points relative to obj.  */\n+  unsigned int obj_uid = (DECL_PT_UID_SET_P (obj)\n+\t\t\t  ? DECL_PT_UID (obj)\n+\t\t\t  : DECL_UID (obj));\n+  if (obj_uid != pt_uid)\n+    return false;\n+\n+  /* Check that the object size is the same as the store size.  That ensures us\n+     that ptr points to the start of obj.  */\n+  if (!tree_fits_shwi_p (DECL_SIZE (obj)))\n+    return false;\n+  HOST_WIDE_INT obj_size = tree_to_shwi (DECL_SIZE (obj));\n+  return obj_size == size1;\n+}\n+\n /* If STMT kills the memory reference REF return true, otherwise\n    return false.  */\n \n@@ -2393,6 +2465,11 @@ stmt_kills_ref_p (gimple *stmt, ao_ref *ref)\n \t so base == ref->base does not always hold.  */\n       if (base != ref->base)\n \t{\n+\t  /* Try using points-to info.  */\n+\t  if (same_addr_size_stores_p (base, offset, size, max_size, ref->base,\n+\t\t\t\t       ref->offset, ref->size, ref->max_size))\n+\t    return true;\n+\n \t  /* If both base and ref->base are MEM_REFs, only compare the\n \t     first operand, and if the second operand isn't equal constant,\n \t     try to add the offsets into offset and ref_offset.  */"}]}