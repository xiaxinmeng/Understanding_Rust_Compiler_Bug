{"sha": "9fa25ead5321c9f0a35445d08f83d9116902da94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZhMjVlYWQ1MzIxYzlmMGEzNTQ0NWQwOGY4M2Q5MTE2OTAyZGE5NA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-11-17T15:10:28Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-11-17T15:10:28Z"}, "message": "re PR ada/27936 (gnatbind fails to link)\n\n\tPR ada/27936\n\t* trans.c (add_decl_expr): Do not dynamically elaborate padded objects\n\tif the initializer takes into account the padding.\n\nFrom-SVN: r118939", "tree": {"sha": "954d33db5601434573843d37d6d8b505330d2f83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/954d33db5601434573843d37d6d8b505330d2f83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fa25ead5321c9f0a35445d08f83d9116902da94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fa25ead5321c9f0a35445d08f83d9116902da94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fa25ead5321c9f0a35445d08f83d9116902da94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fa25ead5321c9f0a35445d08f83d9116902da94/comments", "author": null, "committer": null, "parents": [{"sha": "598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/598ec7bdbe0e6e2f7c58961fd0f61e0898a3083e"}], "stats": {"total": 66, "additions": 30, "deletions": 36}, "files": [{"sha": "cd6447b37ef9b36de7c5af193545b320c7992b8c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fa25ead5321c9f0a35445d08f83d9116902da94/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fa25ead5321c9f0a35445d08f83d9116902da94/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9fa25ead5321c9f0a35445d08f83d9116902da94", "patch": "@@ -1,3 +1,9 @@\n+2006-11-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR ada/27936\n+\t* trans.c (add_decl_expr): Do not dynamically elaborate padded objects\n+\tif the initializer takes into account the padding.\n+\n 2006-11-11  Richard Guenther  <rguenther@suse.de>\n \n \t* trans.c (maybe_stabilize_reference): Remove handling of"}, {"sha": "8adff5e0a418c18a01df8fbc664ce8acea5c540c", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fa25ead5321c9f0a35445d08f83d9116902da94/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fa25ead5321c9f0a35445d08f83d9116902da94/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=9fa25ead5321c9f0a35445d08f83d9116902da94", "patch": "@@ -4518,15 +4518,16 @@ add_stmt_with_node (tree gnu_stmt, Node_Id gnat_node)\n void\n add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n {\n-  tree gnu_stmt;\n+  tree type = TREE_TYPE (gnu_decl);\n+  tree gnu_stmt, gnu_init, gnu_lhs;\n \n   /* If this is a variable that Gigi is to ignore, we may have been given\n      an ERROR_MARK.  So test for it.  We also might have been given a\n      reference for a renaming.  So only do something for a decl.  Also\n      ignore a TYPE_DECL for an UNCONSTRAINED_ARRAY_TYPE.  */\n   if (!DECL_P (gnu_decl)\n       || (TREE_CODE (gnu_decl) == TYPE_DECL\n-\t  && TREE_CODE (TREE_TYPE (gnu_decl)) == UNCONSTRAINED_ARRAY_TYPE))\n+\t  && TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE))\n     return;\n \n   gnu_stmt = build1 (DECL_EXPR, void_type_node, gnu_decl);\n@@ -4551,45 +4552,32 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n   else\n     add_stmt_with_node (gnu_stmt, gnat_entity);\n \n-  /* If this is a DECL_EXPR for a variable with DECL_INITIAL set,\n-     there are two cases we need to handle here.  */\n-  if (TREE_CODE (gnu_decl) == VAR_DECL && DECL_INITIAL (gnu_decl))\n+  /* If this is a variable and an initializer is attached to it, it must be\n+     valid for the context.  Similar to init_const in create_var_decl_1.  */ \n+  if (TREE_CODE (gnu_decl) == VAR_DECL\n+      && (gnu_init = DECL_INITIAL (gnu_decl)) != NULL_TREE\n+      && (TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (TREE_TYPE (gnu_init))\n+\t  || (TREE_STATIC (gnu_decl)\n+\t      && !initializer_constant_valid_p (gnu_init,\n+\t\t\t\t\t\tTREE_TYPE (gnu_init)))))\n     {\n-      tree gnu_init = DECL_INITIAL (gnu_decl);\n-      tree gnu_lhs = NULL_TREE;\n-\n-      /* If this is a DECL_EXPR for a variable with DECL_INITIAL set\n-\t and decl has a padded type, convert it to the unpadded type so the\n-\t assignment is done properly.  */\n-      if (TREE_CODE (TREE_TYPE (gnu_decl)) == RECORD_TYPE\n-\t  && TYPE_IS_PADDING_P (TREE_TYPE (gnu_decl)))\n-\tgnu_lhs\n-\t  = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_decl))), gnu_decl);\n-\n-      /* Otherwise, if this is going into memory and the initializer isn't\n-\t valid for the assembler and loader.  Gimplification could do this,\n-\t but would be run too late if -fno-unit-at-a-time.  */\n-      else if (TREE_STATIC (gnu_decl)\n-\t       && !initializer_constant_valid_p (gnu_init,\n-\t\t\t\t\t\t TREE_TYPE (gnu_decl)))\n+      /* If GNU_DECL has a padded type, convert it to the unpadded\n+\t type so the assignment is done properly.  */\n+      if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n+\tgnu_lhs = convert (TREE_TYPE (TYPE_FIELDS (type)), gnu_decl);\n+      else\n \tgnu_lhs = gnu_decl;\n \n-      if (gnu_lhs)\n-\t{\n-\t  tree gnu_assign_stmt\n-\t    = build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t       gnu_lhs, DECL_INITIAL (gnu_decl));\n+      gnu_stmt = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_lhs, gnu_init);\n \n-\t  DECL_INITIAL (gnu_decl) = NULL_TREE;\n-\t  if (TREE_READONLY (gnu_decl))\n-\t    {\n-\t      TREE_READONLY (gnu_decl) = 0;\n-\t      DECL_READONLY_ONCE_ELAB (gnu_decl) = 1;\n-\t    }\n-\t  annotate_with_locus (gnu_assign_stmt,\n-\t\t\t       DECL_SOURCE_LOCATION (gnu_decl));\n-\t  add_stmt (gnu_assign_stmt);\n+      DECL_INITIAL (gnu_decl) = NULL_TREE;\n+      if (TREE_READONLY (gnu_decl))\n+\t{\n+\t  TREE_READONLY (gnu_decl) = 0;\n+\t  DECL_READONLY_ONCE_ELAB (gnu_decl) = 1;\n \t}\n+\n+      add_stmt_with_node (gnu_stmt, gnat_entity);\n     }\n }\n "}]}