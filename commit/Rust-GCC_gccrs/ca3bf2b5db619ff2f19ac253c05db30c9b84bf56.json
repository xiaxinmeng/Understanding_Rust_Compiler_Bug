{"sha": "ca3bf2b5db619ff2f19ac253c05db30c9b84bf56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EzYmYyYjVkYjYxOWZmMmYxOWFjMjUzYzA1ZGIzMGM5Yjg0YmY1Ng==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1998-10-23T14:00:08Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1998-10-23T14:00:08Z"}, "message": "Fix m32r build failure, (SUBREG (MEM)) problem from Joern's reload patches.\n\n\t* m32r/m32r.c (gen_split_move_double): Call alter_subreg.  Delete\n\tsubreg support.\n\nFrom-SVN: r23256", "tree": {"sha": "40d3edf44a9a53b12249769fc1539abebd49ef64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40d3edf44a9a53b12249769fc1539abebd49ef64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca3bf2b5db619ff2f19ac253c05db30c9b84bf56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3bf2b5db619ff2f19ac253c05db30c9b84bf56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca3bf2b5db619ff2f19ac253c05db30c9b84bf56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3bf2b5db619ff2f19ac253c05db30c9b84bf56/comments", "author": null, "committer": null, "parents": [{"sha": "e1ba7da73f740ffe54029e33b71f649cb299959d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ba7da73f740ffe54029e33b71f649cb299959d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1ba7da73f740ffe54029e33b71f649cb299959d"}], "stats": {"total": 30, "additions": 23, "deletions": 7}, "files": [{"sha": "eba3f1440994cf63e333e40080aca8ea64e4a4b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bf2b5db619ff2f19ac253c05db30c9b84bf56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bf2b5db619ff2f19ac253c05db30c9b84bf56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca3bf2b5db619ff2f19ac253c05db30c9b84bf56", "patch": "@@ -1,3 +1,8 @@\n+Fri Oct 23 13:55:48 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* m32r/m32r.c (gen_split_move_double): Call alter_subreg.  Delete\n+\tsubreg support.\n+\n Fri Oct 23 16:19:24 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* mips.h (EXTRA_SPECS): Add missing initializers."}, {"sha": "3474ad608d32457389c3baa9f52bf2c06f94a946", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bf2b5db619ff2f19ac253c05db30c9b84bf56/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bf2b5db619ff2f19ac253c05db30c9b84bf56/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=ca3bf2b5db619ff2f19ac253c05db30c9b84bf56", "patch": "@@ -1123,16 +1123,29 @@ gen_split_move_double (operands)\n   rtx src  = operands[1];\n   rtx val;\n \n+  /* We might have (SUBREG (MEM)) here, so just get rid of the\n+     subregs to make this code simpler.  It is safe to call\n+     alter_subreg any time after reload.  */\n+  if (GET_CODE (dest) == SUBREG)\n+    dest = alter_subreg (dest);\n+  if (GET_CODE (src) == SUBREG)\n+    src = alter_subreg (src);\n+\n   start_sequence ();\n-  if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG)\n+  if (GET_CODE (dest) == REG)\n     {\n+      int dregno = REGNO (dest);\n+\n       /* reg = reg */\n-      if (GET_CODE (src) == REG || GET_CODE (src) == SUBREG)\n+      if (GET_CODE (src) == REG)\n \t{\n+\t  int sregno = REGNO (src);\n+\n+\t  int reverse = (dregno == sregno + 1);\n+\n \t  /* We normally copy the low-numbered register first.  However, if\n \t     the first register operand 0 is the same as the second register of\n \t     operand 1, we must copy in the opposite order.  */\n-\t  int reverse = (REGNO (operands[0]) == REGNO (operands[1]) + 1);\n \t  emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t  operand_subword (dest, reverse, TRUE, mode),\n \t\t\t\t  operand_subword (src,  reverse, TRUE, mode)));\n@@ -1162,8 +1175,7 @@ gen_split_move_double (operands)\n \t  /* If the high-address word is used in the address, we must load it\n \t     last.  Otherwise, load it first.  */\n \t  rtx addr = XEXP (src, 0);\n-\t  int reverse = (refers_to_regno_p (REGNO (dest), REGNO (dest)+1,\n-\t\t\t\t\t    addr, 0) != 0);\n+\t  int reverse = (refers_to_regno_p (dregno, dregno+1, addr, 0) != 0);\n \n \t  /* We used to optimize loads from single registers as\n \n@@ -1205,8 +1217,7 @@ gen_split_move_double (operands)\n \tst r1,r3; st r2,+r3; addi r3,-4\n \n      which saves 2 bytes and doesn't force longword alignment.  */\n-  else if (GET_CODE (dest) == MEM\n-\t   && (GET_CODE (src) == REG || GET_CODE (src) == SUBREG))\n+  else if (GET_CODE (dest) == MEM && GET_CODE (src) == REG)\n     {\n       rtx addr = XEXP (dest, 0);\n "}]}