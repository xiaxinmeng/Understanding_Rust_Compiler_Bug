{"sha": "70883f7262c96220e2586ea15024ec545bb3acd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA4ODNmNzI2MmM5NjIyMGUyNTg2ZWExNTAyNGVjNTQ1YmIzYWNkNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-06-28T12:01:30Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-28T12:01:30Z"}, "message": "tree-nested.c (create_tmp_var_for): Allow ARRAY_TYPE.\n\n\t* tree-nested.c (create_tmp_var_for): Allow ARRAY_TYPE.\n\t(convert_nonlocal_reference, convert_local_reference): Properly\n\tconvert nest of handled component references.\n\nFrom-SVN: r83781", "tree": {"sha": "b0ba130dd7c31980e7df064ed1c3f8e0c6893853", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0ba130dd7c31980e7df064ed1c3f8e0c6893853"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70883f7262c96220e2586ea15024ec545bb3acd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70883f7262c96220e2586ea15024ec545bb3acd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70883f7262c96220e2586ea15024ec545bb3acd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70883f7262c96220e2586ea15024ec545bb3acd7/comments", "author": null, "committer": null, "parents": [{"sha": "d7fa922736d73a90e18ca6d71bd0eb9fc73f1cbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7fa922736d73a90e18ca6d71bd0eb9fc73f1cbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7fa922736d73a90e18ca6d71bd0eb9fc73f1cbf"}], "stats": {"total": 121, "additions": 70, "deletions": 51}, "files": [{"sha": "f011e27b8dd1c6082f0cc60d55582e0859ed5224", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70883f7262c96220e2586ea15024ec545bb3acd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70883f7262c96220e2586ea15024ec545bb3acd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70883f7262c96220e2586ea15024ec545bb3acd7", "patch": "@@ -1,3 +1,9 @@\n+2004-06-28  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* tree-nested.c (create_tmp_var_for): Allow ARRAY_TYPE.\n+\t(convert_nonlocal_reference, convert_local_reference): Properly\n+\tconvert nest of handled component references.\n+\n 2004-06-28  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* vec.h, vec.c: New, type safe vector API."}, {"sha": "668861c15b963d7d2479ca4f826f3c21254cda30", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 64, "deletions": 51, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70883f7262c96220e2586ea15024ec545bb3acd7/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70883f7262c96220e2586ea15024ec545bb3acd7/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=70883f7262c96220e2586ea15024ec545bb3acd7", "patch": "@@ -133,13 +133,12 @@ create_tmp_var_for (struct nesting_info *info, tree type, const char *prefix)\n   tree tmp_var;\n \n #if defined ENABLE_CHECKING\n-  /* If the type is an array or a type which must be created by the\n+  /* If the type is of variable size or a type which must be created by the\n      frontend, something is wrong.  Note that we explicitly allow\n      incomplete types here, since we create them ourselves here.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE || TREE_ADDRESSABLE (type))\n-    abort ();\n-  if (TYPE_SIZE_UNIT (type)\n-      && TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST)\n+  if (TREE_ADDRESSABLE (type)\n+      || (TYPE_SIZE_UNIT (type)\n+\t  && TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST))\n     abort ();\n #endif\n \n@@ -797,34 +796,41 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      wi->val_only = false;\n-      walk_tree (&TREE_OPERAND (t, 0), convert_nonlocal_reference, wi, NULL);\n-      wi->val_only = true;\n-      break;\n-\n     case COMPONENT_REF:\n-      wi->val_only = false;\n-      walk_tree (&TREE_OPERAND (t, 0), convert_nonlocal_reference, wi, NULL);\n-      wi->val_only = true;\n-      walk_tree (&TREE_OPERAND (t, 2), convert_nonlocal_reference, wi, NULL);\n-      break;\n-\n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n-      wi->val_only = false;\n-      walk_tree (&TREE_OPERAND (t, 0), convert_nonlocal_reference, wi, NULL);\n-      wi->val_only = true;\n-      walk_tree (&TREE_OPERAND (t, 1), convert_nonlocal_reference, wi, NULL);\n-      walk_tree (&TREE_OPERAND (t, 2), convert_nonlocal_reference, wi, NULL);\n-      walk_tree (&TREE_OPERAND (t, 3), convert_nonlocal_reference, wi, NULL);\n-      break;\n-\n     case BIT_FIELD_REF:\n-      wi->val_only = false;\n-      walk_tree (&TREE_OPERAND (t, 0), convert_nonlocal_reference, wi, NULL);\n+      /* Go down this entire nest and just look at the final prefix and\n+\t anything that describes the references.  Otherwise, we lose track\n+\t of whether a NOP_EXPR or VIEW_CONVERT_EXPR needs a simple value.  */\n       wi->val_only = true;\n-      walk_tree (&TREE_OPERAND (t, 1), convert_nonlocal_reference, wi, NULL);\n-      walk_tree (&TREE_OPERAND (t, 2), convert_nonlocal_reference, wi, NULL);\n+      for (; handled_component_p (t)\n+\t   || TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR;\n+\t   tp = &TREE_OPERAND (t, 0), t = *tp)\n+\t{\n+\t  if (TREE_CODE (t) == COMPONENT_REF)\n+\t    walk_tree (&TREE_OPERAND (t, 2), convert_nonlocal_reference, wi,\n+\t\t       NULL);\n+\t  else if (TREE_CODE (t) == ARRAY_REF\n+\t\t   || TREE_CODE (t) == ARRAY_RANGE_REF)\n+\t    {\n+\t      walk_tree (&TREE_OPERAND (t, 1), convert_nonlocal_reference, wi,\n+\t\t\t NULL);\n+\t      walk_tree (&TREE_OPERAND (t, 2), convert_nonlocal_reference, wi,\n+\t\t\t NULL);\n+\t      walk_tree (&TREE_OPERAND (t, 3), convert_nonlocal_reference, wi,\n+\t\t\t NULL);\n+\t    }\n+\t  else if (TREE_CODE (t) == BIT_FIELD_REF)\n+\t    {\n+\t      walk_tree (&TREE_OPERAND (t, 1), convert_nonlocal_reference, wi,\n+\t\t\t NULL);\n+\t      walk_tree (&TREE_OPERAND (t, 2), convert_nonlocal_reference, wi,\n+\t\t\t NULL);\n+\t    }\n+\t}\n+      wi->val_only = false;\n+      walk_tree (tp, convert_nonlocal_reference, wi, NULL);\n       break;\n \n     default:\n@@ -938,34 +944,41 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      wi->val_only = false;\n-      walk_tree (&TREE_OPERAND (t, 0), convert_local_reference, wi, NULL);\n-      wi->val_only = true;\n-      break;\n-\n     case COMPONENT_REF:\n-      wi->val_only = false;\n-      walk_tree (&TREE_OPERAND (t, 0), convert_local_reference, wi, NULL);\n-      wi->val_only = true;\n-      walk_tree (&TREE_OPERAND (t, 2), convert_local_reference, wi, NULL);\n-      break;\n-\n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n-      wi->val_only = false;\n-      walk_tree (&TREE_OPERAND (t, 0), convert_local_reference, wi, NULL);\n-      wi->val_only = true;\n-      walk_tree (&TREE_OPERAND (t, 1), convert_local_reference, wi, NULL);\n-      walk_tree (&TREE_OPERAND (t, 2), convert_local_reference, wi, NULL);\n-      walk_tree (&TREE_OPERAND (t, 3), convert_local_reference, wi, NULL);\n-      break;\n-\n     case BIT_FIELD_REF:\n-      wi->val_only = false;\n-      walk_tree (&TREE_OPERAND (t, 0), convert_local_reference, wi, NULL);\n+      /* Go down this entire nest and just look at the final prefix and\n+\t anything that describes the references.  Otherwise, we lose track\n+\t of whether a NOP_EXPR or VIEW_CONVERT_EXPR needs a simple value.  */\n       wi->val_only = true;\n-      walk_tree (&TREE_OPERAND (t, 1), convert_local_reference, wi, NULL);\n-      walk_tree (&TREE_OPERAND (t, 2), convert_local_reference, wi, NULL);\n+      for (; handled_component_p (t)\n+\t   || TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR;\n+\t   tp = &TREE_OPERAND (t, 0), t = *tp)\n+\t{\n+\t  if (TREE_CODE (t) == COMPONENT_REF)\n+\t    walk_tree (&TREE_OPERAND (t, 2), convert_local_reference, wi,\n+\t\t       NULL);\n+\t  else if (TREE_CODE (t) == ARRAY_REF\n+\t\t   || TREE_CODE (t) == ARRAY_RANGE_REF)\n+\t    {\n+\t      walk_tree (&TREE_OPERAND (t, 1), convert_local_reference, wi,\n+\t\t\t NULL);\n+\t      walk_tree (&TREE_OPERAND (t, 2), convert_local_reference, wi,\n+\t\t\t NULL);\n+\t      walk_tree (&TREE_OPERAND (t, 3), convert_local_reference, wi,\n+\t\t\t NULL);\n+\t    }\n+\t  else if (TREE_CODE (t) == BIT_FIELD_REF)\n+\t    {\n+\t      walk_tree (&TREE_OPERAND (t, 1), convert_local_reference, wi,\n+\t\t\t NULL);\n+\t      walk_tree (&TREE_OPERAND (t, 2), convert_local_reference, wi,\n+\t\t\t NULL);\n+\t    }\n+\t}\n+      wi->val_only = false;\n+      walk_tree (tp, convert_local_reference, wi, NULL);\n       break;\n \n     default:"}]}