{"sha": "1facd6278b85e2866b487b72c1f5f671c5ae9e4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZhY2Q2Mjc4Yjg1ZTI4NjZiNDg3YjcyYzFmNWY2NzFjNWFlOWU0YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2019-05-31T14:16:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-05-31T14:16:27Z"}, "message": "tree-ssa-alias.c (type_has_components_p): New function.\n\n\n\t* tree-ssa-alias.c (type_has_components_p): New function.\n\t(aliasing_component_refs_p): Use it.\n\nFrom-SVN: r271813", "tree": {"sha": "497c78a95c21f907ff88c9deac8dba1033b38f42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/497c78a95c21f907ff88c9deac8dba1033b38f42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1facd6278b85e2866b487b72c1f5f671c5ae9e4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1facd6278b85e2866b487b72c1f5f671c5ae9e4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1facd6278b85e2866b487b72c1f5f671c5ae9e4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1facd6278b85e2866b487b72c1f5f671c5ae9e4a/comments", "author": null, "committer": null, "parents": [{"sha": "ff0b7e883d9f09785c92ab41fa32fa093b60b346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff0b7e883d9f09785c92ab41fa32fa093b60b346", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff0b7e883d9f09785c92ab41fa32fa093b60b346"}], "stats": {"total": 17, "additions": 17, "deletions": 0}, "files": [{"sha": "b04b38b5b9fad988d7122090730901f5e85e2921", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1facd6278b85e2866b487b72c1f5f671c5ae9e4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1facd6278b85e2866b487b72c1f5f671c5ae9e4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1facd6278b85e2866b487b72c1f5f671c5ae9e4a", "patch": "@@ -1,3 +1,8 @@\n+2019-05-31  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-ssa-alias.c (type_has_components_p): New function.\n+\t(aliasing_component_refs_p): Use it.\n+\n 2019-05-31  Martin Liska  <mliska@suse.cz>\n \n \t* gdbhooks.py: Add const_tree to TreePrinter."}, {"sha": "429288b6ca523a7ed09267e651e3a35d8d53479f", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1facd6278b85e2866b487b72c1f5f671c5ae9e4a/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1facd6278b85e2866b487b72c1f5f671c5ae9e4a/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=1facd6278b85e2866b487b72c1f5f671c5ae9e4a", "patch": "@@ -822,6 +822,16 @@ same_type_for_tbaa (tree type1, tree type2)\n   return 0;\n }\n \n+/* Return true if TYPE is a composite type (i.e. we may apply one of handled\n+   components on it).  */\n+\n+static bool\n+type_has_components_p (tree type)\n+{\n+  return AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type)\n+\t || TREE_CODE (type) == COMPLEX_TYPE;\n+}\n+\n /* Determine if the two component references REF1 and REF2 which are\n    based on access types TYPE1 and TYPE2 and of which at least one is based\n    on an indirect reference may alias.  REF2 is the only one that can\n@@ -965,6 +975,7 @@ aliasing_component_refs_p (tree ref1,\n      if there is no B2 in the tail of path1 and no B1 on the\n      tail of path2.  */\n   if (compare_type_sizes (TREE_TYPE (ref2), type1) >= 0\n+      && type_has_components_p (TREE_TYPE (ref2))\n       && (base1_alias_set == ref2_alias_set\n           || alias_set_subset_of (base1_alias_set, ref2_alias_set)))\n     {\n@@ -974,6 +985,7 @@ aliasing_component_refs_p (tree ref1,\n   /* If this is ptr vs. decl then we know there is no ptr ... decl path.  */\n   if (!ref2_is_decl\n       && compare_type_sizes (TREE_TYPE (ref1), type2) >= 0\n+      && type_has_components_p (TREE_TYPE (ref1))\n       && (base2_alias_set == ref1_alias_set\n \t  || alias_set_subset_of (base2_alias_set, ref1_alias_set)))\n     {"}]}