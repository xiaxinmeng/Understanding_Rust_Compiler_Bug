{"sha": "c7fc73ee459045edabb99816658f14f32d23bf92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdmYzczZWU0NTkwNDVlZGFiYjk5ODE2NjU4ZjE0ZjMyZDIzYmY5Mg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-03-25T13:51:08Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-03-25T18:21:19Z"}, "message": "libstdc++: Allow seeding random engines in testsuite\n\nThe testsuite utilities that use random numbers use a\ndefault-constructed mersenne_twister_engine, meaning the values are\nreproducable. This adds support for seeding them, controlledby an\nenvironment variable. Defining GLIBCXX_SEED_TEST_RNG=val in the\nenvironment will cause the engines to be seeded with atoi(val) if that\nis non-zero, or with a value read from std::random_device otherwise.\n\nRunning with different seeds revealed some bugs in the tests, where a\nrandomly selected iterator was past-the-end (which can't be erased), or\nwhere the randomly populated container was empty, and then we tried to\nremove elements from it unconditionally.\n\nlibstdc++-v3/ChangeLog:\n\n\t* testsuite/util/exception/safety.h (setup_base::generate):\n\tSupport seeding random engine.\n\t(erase_point, erase_range): Adjust range of random numbers to\n\tensure dereferenceable iterators are used where required.\n\t(generation_prohibited::run): Do not try to erase from empty\n\tcontainers.\n\t* testsuite/util/testsuite_containergen.h (test_containers):\n\tSupport seeding random engine.", "tree": {"sha": "6c0c963982b3afa80752298c38556ebdd6913773", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c0c963982b3afa80752298c38556ebdd6913773"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7fc73ee459045edabb99816658f14f32d23bf92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7fc73ee459045edabb99816658f14f32d23bf92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7fc73ee459045edabb99816658f14f32d23bf92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7fc73ee459045edabb99816658f14f32d23bf92/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aac12084fc07319d5c8232c51dafa4e297bd5415", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac12084fc07319d5c8232c51dafa4e297bd5415", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aac12084fc07319d5c8232c51dafa4e297bd5415"}], "stats": {"total": 103, "additions": 73, "deletions": 30}, "files": [{"sha": "2e5d8acae00765c54bcd6d9da94f25450e6410ac", "filename": "libstdc++-v3/testsuite/util/exception/safety.h", "status": "modified", "additions": 59, "deletions": 30, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7fc73ee459045edabb99816658f14f32d23bf92/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7fc73ee459045edabb99816658f14f32d23bf92/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h?ref=c7fc73ee459045edabb99816658f14f32d23bf92", "patch": "@@ -22,6 +22,8 @@\n \n #include <testsuite_container_traits.h>\n #include <ext/throw_allocator.h>\n+#include <cstdlib> // getenv, atoi\n+#include <cstdio>  // printf, fflush\n \n // Container requirement testing.\n namespace __gnu_test\n@@ -33,27 +35,34 @@ namespace __gnu_test\n     typedef std::uniform_int_distribution<size_type> \tdistribution_type;\n     typedef std::mt19937 \t\t\t\tengine_type;\n \n+    static engine_type\n+    get_engine()\n+    {\n+      engine_type engine;\n+      if (const char* v = std::getenv(\"GLIBCXX_SEED_TEST_RNG\"))\n+\t{\n+\t  // A single seed value is much smaller than the mt19937 state size,\n+\t  // but we're not trying to be cryptographically secure here.\n+\t  int s = std::atoi(v);\n+\t  if (s == 0)\n+\t    s = (int)std::random_device{}();\n+\t  std::printf(\"Using random seed %d\\n\", s);\n+\t  std::fflush(stdout);\n+\t  engine.seed((unsigned)s);\n+\t}\n+      return engine;\n+    }\n+\n     // Return randomly generated integer on range [0, __max_size].\n     static size_type\n     generate(size_type __max_size)\n     {\n-      // Make the generator static...\n-      const engine_type engine;\n-      const distribution_type distribution;\n-      static auto generator = std::bind(distribution, engine,\n-\t\t\t\t\tstd::placeholders::_1);\n-\n-      // ... but set the range for this particular invocation here.\n-      const typename distribution_type::param_type p(0, __max_size);\n-      size_type random = generator(p);\n-      if (random < distribution.min() || random > distribution.max())\n-\tstd::__throw_out_of_range_fmt(__N(\"setup_base::generate\\n\"\n-\t\t\t\t\t  \"random number generated is: %zu \"\n-\t\t\t\t\t  \"out of range [%zu, %zu]\\n\"),\n-\t\t\t\t      (size_t)random,\n-\t\t\t\t      (size_t)distribution.min(),\n-\t\t\t\t      (size_t)distribution.max());\n-      return random;\n+      using param_type = typename distribution_type::param_type;\n+\n+      // Make the engine and distribution static...\n+      static engine_type engine = get_engine();\n+      static distribution_type distribution;\n+      return distribution(engine, param_type{0, __max_size});\n     }\n \n     // Given an instantiating type, return a unique value.\n@@ -309,10 +318,13 @@ namespace __gnu_test\n \t      // computed with begin() and end().\n \t      const size_type sz = std::distance(__container.begin(),\n \t\t\t\t\t\t __container.end());\n+\t      // Container::erase(pos) requires dereferenceable pos.\n+\t      if (sz == 0)\n+\t\tthrow std::logic_error(\"erase_point: empty container\");\n \n \t      // NB: Lowest common denominator: use forward iterator operations.\n \t      auto i = __container.begin();\n-\t      std::advance(i, generate(sz));\n+\t      std::advance(i, generate(sz - 1));\n \n \t      // Makes it easier to think of this as __container.erase(i)\n \t      (__container.*_F_erase_point)(i);\n@@ -337,12 +349,15 @@ namespace __gnu_test\n \t      // computed with begin() and end().\n \t      const size_type sz = std::distance(__container.begin(),\n \t\t\t\t\t\t __container.end());\n+\t      // forward_list::erase_after(pos) requires dereferenceable pos.\n+\t      if (sz == 0)\n+\t\tthrow std::logic_error(\"erase_point: empty container\");\n \n \t      // NB: Lowest common denominator: use forward iterator operations.\n \t      auto i = __container.before_begin();\n-\t      std::advance(i, generate(sz));\n+\t      std::advance(i, generate(sz - 1));\n \n-\t      // Makes it easier to think of this as __container.erase(i)\n+\t      // Makes it easier to think of this as __container.erase_after(i)\n \t      (__container.*_F_erase_point)(i);\n \t    }\n \t  catch(const __gnu_cxx::forced_error&)\n@@ -405,14 +420,19 @@ namespace __gnu_test\n \t    {\n \t      const size_type sz = std::distance(__container.begin(),\n \t\t\t\t\t\t __container.end());\n-\t      size_type s1 = generate(sz);\n-\t      size_type s2 = generate(sz);\n+\t      // forward_list::erase_after(pos, last) requires a pos != last\n+\t      if (sz == 0)\n+\t\treturn; // Caller doesn't check for this, not a logic error.\n+\n+\t      size_type s1 = generate(sz - 1);\n+\t      size_type s2 = generate(sz - 1);\n \t      auto i1 = __container.before_begin();\n \t      auto i2 = __container.before_begin();\n \t      std::advance(i1, std::min(s1, s2));\n-\t      std::advance(i2, std::max(s1, s2));\n+\t      std::advance(i2, std::max(s1, s2) + 1);\n \n-\t      // Makes it easier to think of this as __container.erase(i1, i2).\n+\t      // Makes it easier to think of this as\n+\t      // __container.erase_after(i1, i2).\n \t      (__container.*_F_erase_range)(i1, i2);\n \t    }\n \t  catch(const __gnu_cxx::forced_error&)\n@@ -1454,16 +1474,25 @@ namespace __gnu_test\n \t  // constructor or assignment operator of value_type throws.\n \t  if (!traits<container_type>::has_throwing_erase::value)\n \t    {\n-\t      typename base_type::erase_point erasep;\n-\t      erasep(container);\n+\t      if (!container.empty())\n+\t\t{\n+\t\t  typename base_type::erase_point erasep;\n+\t\t  erasep(container);\n+\t\t}\n \t      typename base_type::erase_range eraser;\n \t      eraser(container);\n \t    }\n \n-\t  typename base_type::pop_front popf;\n-\t  popf(container);\n-\t  typename base_type::pop_back popb;\n-\t  popb(container);\n+\t  if (!container.empty())\n+\t    {\n+\t      typename base_type::pop_front popf;\n+\t      popf(container);\n+\t    }\n+\t  if (!container.empty())\n+\t    {\n+\t      typename base_type::pop_back popb;\n+\t      popb(container);\n+\t    }\n \n \t  typename base_type::iterator_ops iops;\n \t  iops(container);"}, {"sha": "c468c7f44152f080045125e5ad02fa50923b18d4", "filename": "libstdc++-v3/testsuite/util/testsuite_containergen.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7fc73ee459045edabb99816658f14f32d23bf92/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_containergen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7fc73ee459045edabb99816658f14f32d23bf92/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_containergen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_containergen.h?ref=c7fc73ee459045edabb99816658f14f32d23bf92", "patch": "@@ -20,6 +20,8 @@\n \n #include <testsuite_container_traits.h>\n #include <random>\n+#include <cstdlib> // getenv, atoi\n+#include <cstdio>  // printf, fflush\n \n namespace __gnu_test\n {\n@@ -63,6 +65,18 @@ namespace __gnu_test\n     {\n       std::mt19937_64 random_gen;\n \n+      if (const char* v = std::getenv(\"GLIBCXX_SEED_TEST_RNG\"))\n+\t{\n+\t  // A single seed value is much smaller than the mt19937 state size,\n+\t  // but we're not trying to be cryptographically secure here.\n+\t  int s = std::atoi(v);\n+\t  if (s == 0)\n+\t    s = (int)std::random_device{}();\n+\t  std::printf(\"Using random seed %d\\n\", s);\n+\t  std::fflush(stdout);\n+\t  random_gen.seed((unsigned)s);\n+\t}\n+\n #ifdef SIMULATOR_TEST\n       int loops = 10;\n #else"}]}