{"sha": "412dc29d628f7b523790a34042a3c55e77ed1f9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEyZGMyOWQ2MjhmN2I1MjM3OTBhMzQwNDJhM2M1NWU3N2VkMWY5Zg==", "commit": {"author": {"name": "Basile Starynkevitch", "email": "basile@starynkevitch.net", "date": "2010-11-23T15:13:12Z"}, "committer": {"name": "Basile Starynkevitch", "email": "bstarynk@gcc.gnu.org", "date": "2010-11-23T15:13:12Z"}, "message": "gengtype.c (enum typekind, [...]): Move to gengtype.h.\n\n2010-11-23  Basile Starynkevitch  <basile@starynkevitch.net>\n\t    Jeremie Salvucci  <jeremie.salvucci@free.fr>\n\n\t* gengtype.c (enum typekind, struct options)\n\t(struct nested_ptr_data, struct pair, NUM_PARAM)\n\t(enum gc_used_num, struct type, UNION_P, UNION_OR_STRUCT_P):\n\tMove to gengtype.h.\n\t(string_type, scalar_nonchar, scalar_nonchar, scalar_char):\n\tRemove static, add zero state_number.\n\t(typedefs, structures, param_structs, variables): Remove static.\n\t(create_option): Remove.\n\t(create_string_option, create_type_option, create_nested_option):\n\tNew functions.\n\t(create_nested_ptr_option): Use create_nested_option.\n\t(note_variable, adjust_field_rtx_def, adjust_field_type): Call the\n\tnew create*option functions.\n\t(process_gc_options): Adjust for discriminated option.\n\t(output_mangled_typename): Handle TYPE_NONE.\n\t(walk_type): Test option kinds.\n\t(write_types_process_field): Handle TYPE_NONE and TYPE_ARRAY.\n\t(write_func_for_structure, write_type, write_local, write_root)\n\t(write_roots, note_def_vec, dump_options): Adjust for\n\tdiscriminated option.\n\n\t* gengtype.h\n\t(typedefs, structures, param_structs, variables, enum typekind):\n\tMove from gengtype.c\n\t(enum option_kind): New discriminating enumeration.\n\t(struct options): Becomes discriminated.\n\t(struct nested_ptr_data): Nove from gengtype.c\n\t(create_string_option, create_type_option, create_nested_option)\n\t(create_nested_ptr_option): New functions\n\t(struct pair, enum_gc_used_enum, NUM_PARAM, struct type, UNION_P)\n\t(UNION_OR_STRUCT_P): Move from gengtype.c\n\n\t* gengtype-parse.c (str_optvalue_opt, type_optvalue, option): Make\n\tdiscriminated options.\n\n\nCo-Authored-By: Jeremie Salvucci <jeremie.salvucci@free.fr>\n\nFrom-SVN: r167080", "tree": {"sha": "dd3d960ba0ae8b82eeaf2d114c9eb9550fb1cb58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd3d960ba0ae8b82eeaf2d114c9eb9550fb1cb58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/412dc29d628f7b523790a34042a3c55e77ed1f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/412dc29d628f7b523790a34042a3c55e77ed1f9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/412dc29d628f7b523790a34042a3c55e77ed1f9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/412dc29d628f7b523790a34042a3c55e77ed1f9f/comments", "author": {"login": "bstarynk", "id": 90412, "node_id": "MDQ6VXNlcjkwNDEy", "avatar_url": "https://avatars.githubusercontent.com/u/90412?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstarynk", "html_url": "https://github.com/bstarynk", "followers_url": "https://api.github.com/users/bstarynk/followers", "following_url": "https://api.github.com/users/bstarynk/following{/other_user}", "gists_url": "https://api.github.com/users/bstarynk/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstarynk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstarynk/subscriptions", "organizations_url": "https://api.github.com/users/bstarynk/orgs", "repos_url": "https://api.github.com/users/bstarynk/repos", "events_url": "https://api.github.com/users/bstarynk/events{/privacy}", "received_events_url": "https://api.github.com/users/bstarynk/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6e223f7e4eac7ddfad78a6411ff6e37b3beb91e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e223f7e4eac7ddfad78a6411ff6e37b3beb91e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e223f7e4eac7ddfad78a6411ff6e37b3beb91e6"}], "stats": {"total": 651, "additions": 430, "deletions": 221}, "files": [{"sha": "09053c37400299611b093bfd38b89578b199d9a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412dc29d628f7b523790a34042a3c55e77ed1f9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412dc29d628f7b523790a34042a3c55e77ed1f9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=412dc29d628f7b523790a34042a3c55e77ed1f9f", "patch": "@@ -1,3 +1,41 @@\n+2010-11-23  Basile Starynkevitch  <basile@starynkevitch.net>\n+\t    Jeremie Salvucci  <jeremie.salvucci@free.fr>\n+\n+\t* gengtype.c (enum typekind, struct options)\n+\t(struct nested_ptr_data, struct pair, NUM_PARAM)\n+\t(enum gc_used_num, struct type, UNION_P, UNION_OR_STRUCT_P):\n+\tMove to gengtype.h.\n+\t(string_type, scalar_nonchar, scalar_nonchar, scalar_char):\n+\tRemove static, add zero state_number.\n+\t(typedefs, structures, param_structs, variables): Remove static.\n+\t(create_option): Remove.\n+\t(create_string_option, create_type_option, create_nested_option):\n+\tNew functions.\n+\t(create_nested_ptr_option): Use create_nested_option.\n+\t(note_variable, adjust_field_rtx_def, adjust_field_type): Call the\n+\tnew create*option functions.\n+\t(process_gc_options): Adjust for discriminated option.\n+\t(output_mangled_typename): Handle TYPE_NONE.\n+\t(walk_type): Test option kinds.\n+\t(write_types_process_field): Handle TYPE_NONE and TYPE_ARRAY.\n+\t(write_func_for_structure, write_type, write_local, write_root)\n+\t(write_roots, note_def_vec, dump_options): Adjust for\n+\tdiscriminated option.\n+\n+\t* gengtype.h\n+\t(typedefs, structures, param_structs, variables, enum typekind):\n+\tMove from gengtype.c\n+\t(enum option_kind): New discriminating enumeration.\n+\t(struct options): Becomes discriminated.\n+\t(struct nested_ptr_data): Nove from gengtype.c\n+\t(create_string_option, create_type_option, create_nested_option)\n+\t(create_nested_ptr_option): New functions\n+\t(struct pair, enum_gc_used_enum, NUM_PARAM, struct type, UNION_P)\n+\t(UNION_OR_STRUCT_P): Move from gengtype.c\n+\n+\t* gengtype-parse.c (str_optvalue_opt, type_optvalue, option): Make\n+\tdiscriminated options.\n+\n 2010-11-23  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.c (vn_reference_lookup_3): Avoid doing work"}, {"sha": "8f0b0c532334183912b6e64388263c0ce6ed704a", "filename": "gcc/gengtype-parse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412dc29d628f7b523790a34042a3c55e77ed1f9f/gcc%2Fgengtype-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412dc29d628f7b523790a34042a3c55e77ed1f9f/gcc%2Fgengtype-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-parse.c?ref=412dc29d628f7b523790a34042a3c55e77ed1f9f", "patch": "@@ -372,7 +372,7 @@ str_optvalue_opt (options_p prev)\n       value = string_seq ();\n       require (')');\n     }\n-  return create_option (prev, name, value);\n+  return create_string_option (prev, name, value);\n }\n \n /* absdecl: type '*'*\n@@ -410,7 +410,7 @@ type_optvalue (options_p prev, const char *name)\n   require ('(');\n   ty = absdecl ();\n   require (')');\n-  return create_option (prev, name, ty);\n+  return create_type_option (prev, name, ty);\n }\n \n /* Nested pointer data: '(' type '*'* ',' string_seq ',' string_seq ')' */\n@@ -459,7 +459,7 @@ option (options_p prev)\n     default:\n       parse_error (\"expected an option keyword, have %s\", print_cur_token ());\n       advance ();\n-      return create_option (prev, \"\", \"\");\n+      return create_string_option (prev, \"\", \"\");\n     }\n }\n "}, {"sha": "8d13d0eb1d177bf93b01efa6bb3cc87280439cd9", "filename": "gcc/gengtype.c", "status": "modified", "additions": 177, "deletions": 213, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412dc29d628f7b523790a34042a3c55e77ed1f9f/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412dc29d628f7b523790a34042a3c55e77ed1f9f/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=412dc29d628f7b523790a34042a3c55e77ed1f9f", "patch": "@@ -31,106 +31,6 @@\n \n /* Data types, macros, etc. used only in this file.  */\n \n-/* Kinds of types we can understand.  */\n-enum typekind\n-{\n-  TYPE_SCALAR,\n-  TYPE_STRING,\n-  TYPE_STRUCT,\n-  TYPE_UNION,\n-  TYPE_POINTER,\n-  TYPE_ARRAY,\n-  TYPE_LANG_STRUCT,\n-  TYPE_PARAM_STRUCT\n-};\n-\n-\n-/* A way to pass data through to the output end.  */\n-struct options\n-{\n-  struct options *next;\n-  const char *name;\n-  const char *info;\n-};\n-\n-/* Option data for the 'nested_ptr' option.  */\n-struct nested_ptr_data\n-{\n-  type_p type;\n-  const char *convert_to;\n-  const char *convert_from;\n-};\n-\n-/* A name and a type.  */\n-struct pair\n-{\n-  pair_p next;\n-  const char *name;\n-  type_p type;\n-  struct fileloc line;\n-  options_p opt;\n-};\n-\n-#define NUM_PARAM 10\n-\n-/* A description of a type.  */\n-enum gc_used_enum\n-{\n-  GC_UNUSED = 0,\n-  GC_USED,\n-  /* Used for structures whose definitions we haven't seen so far when\n-     we encounter a pointer to it that is annotated with ``maybe_undef''.\n-     If after reading in everything we don't have source file\n-     information for it, we assume that it never has been defined. */\n-  GC_MAYBE_POINTED_TO,\n-  GC_POINTED_TO\n-};\n-\n-struct type\n-{\n-  enum typekind kind;\n-  type_p next;\n-  type_p pointer_to;\n-  enum gc_used_enum gc_used;\n-  union\n-  {\n-    type_p p;\n-    struct\n-    {\n-      const char *tag;\n-      struct fileloc line;\n-      pair_p fields;\n-      options_p opt;\n-      lang_bitmap bitmap;\n-      type_p lang_struct;\n-    } s;\n-    bool scalar_is_char;\n-    struct\n-    {\n-      type_p p;\n-      const char *len;\n-    } a;\n-    struct\n-    {\n-      type_p stru;\n-      type_p param[NUM_PARAM];\n-      struct fileloc line;\n-    } param_struct;\n-  } u;\n-};\n-\n-#define UNION_P(x)\t\t\t\t\t\\\n- ((x)->kind == TYPE_UNION || \t\t\t\t\\\n-  ((x)->kind == TYPE_LANG_STRUCT \t\t\t\\\n-   && (x)->u.s.lang_struct->kind == TYPE_UNION))\n-#define UNION_OR_STRUCT_P(x)\t\t\t\\\n- ((x)->kind == TYPE_UNION \t\t\t\\\n-  || (x)->kind == TYPE_STRUCT \t\t\t\\\n-  || (x)->kind == TYPE_LANG_STRUCT)\n-\n-\n-\n-\n \n /* The list of output files.  */\n outf_p output_files;\n@@ -554,27 +454,27 @@ read_input_list (const char *listname)\n \n /* The one and only TYPE_STRING.  */\n \n-static struct type string_type = {\n-  TYPE_STRING, 0, 0, GC_USED, {0}\n+struct type string_type = {\n+  TYPE_STRING, 0, 0, 0, GC_USED, {0}\n };\n \n /* The two and only TYPE_SCALARs.  Their u.scalar_is_char flags are\n-   set to appropriate values at the beginning of main.  */\n+   set early in main.  */\n \n-static struct type scalar_nonchar = {\n-  TYPE_SCALAR, 0, 0, GC_USED, {0}\n+struct type scalar_nonchar = {\n+  TYPE_SCALAR, 0, 0, 0, GC_USED, {0}\n };\n \n-static struct type scalar_char = {\n-  TYPE_SCALAR, 0, 0, GC_USED, {0}\n+struct type scalar_char = {\n+  TYPE_SCALAR, 0, 0, 0, GC_USED, {0}\n };\n \n /* Lists of various things.  */\n \n-static pair_p typedefs;\n-static type_p structures;\n-static type_p param_structs;\n-static pair_p variables;\n+pair_p typedefs;\n+type_p structures;\n+type_p param_structs;\n+pair_p variables;\n \n static type_p find_param_structure (type_p t, type_p param[NUM_PARAM]);\n static type_p adjust_field_tree_exp (type_p t, options_p opt);\n@@ -800,16 +700,44 @@ create_array (type_p t, const char *len)\n   return v;\n }\n \n-/* Return an options structure with name NAME and info INFO.  NEXT is the\n-   next option in the chain.  */\n+/* Return a string options structure with name NAME and info INFO.\n+   NEXT is the next option in the chain.  */\n+options_p\n+create_string_option (options_p next, const char *name, const char *info)\n+{\n+  options_p o = XNEW (struct options);\n+  o->kind = OPTION_STRING;\n+  o->next = next;\n+  o->name = name;\n+  o->info.string = info;\n+  return o;\n+}\n \n+/* Create a type options structure with name NAME and info INFO.  NEXT\n+   is the next option in the chain.  */\n options_p\n-create_option (options_p next, const char *name, const void *info)\n+create_type_option (options_p next, const char* name, type_p info)\n {\n   options_p o = XNEW (struct options);\n   o->next = next;\n   o->name = name;\n-  o->info = (const char *) info;\n+  o->kind = OPTION_TYPE;\n+  o->info.type = info;\n+  return o;\n+}\n+\n+/* Create a nested pointer options structure with name NAME and info\n+   INFO.  NEXT is the next option in the chain.  */\n+options_p\n+create_nested_option (options_p next, const char* name,\n+                      struct nested_ptr_data* info)\n+{\n+  options_p o;\n+  o = XNEW (struct options);\n+  o->next = next;\n+  o->name = name;\n+  o->kind = OPTION_NESTED;\n+  o->info.nested = info;\n   return o;\n }\n \n@@ -823,12 +751,11 @@ create_nested_ptr_option (options_p next, type_p t,\n   d->type = adjust_field_type (t, 0);\n   d->convert_to = to;\n   d->convert_from = from;\n-  return create_option (next, \"nested_ptr\", d);\n+  return create_nested_option (next, \"nested_ptr\", d);\n }\n \n /* Add a variable named S of type T with options O defined at POS,\n    to `variables'.  */\n-\n void\n note_variable (const char *s, type_p t, options_p o, struct fileloc *pos)\n {\n@@ -890,15 +817,19 @@ create_optional_field_ (pair_p next, type_p type, const char *name,\n      The field has a tag of \"1\".  This allows us to make the presence\n      of a field of type TYPE depend on some boolean \"desc\" being true.  */\n   union_fields = create_field (NULL, type, \"\");\n-  union_fields->opt = create_option (union_fields->opt, \"dot\", \"\");\n-  union_fields->opt = create_option (union_fields->opt, \"tag\", \"1\");\n-  union_type = new_structure (xasprintf (\"%s_%d\", \"fake_union\", id++), 1,\n-\t\t\t      &lexer_line, union_fields, NULL);\n+  union_fields->opt = \n+    create_string_option (union_fields->opt, \"dot\", \"\");\n+  union_fields->opt = \n+    create_string_option (union_fields->opt, \"tag\", \"1\");\n+  union_type = \n+    new_structure (xasprintf (\"%s_%d\", \"fake_union\", id++), 1,\n+                   &lexer_line, union_fields, NULL);\n \n   /* Create the field and give it the new fake union type.  Add a \"desc\"\n      tag that specifies the condition under which the field is valid.  */\n   return create_field_all (next, union_type, name,\n-\t\t\t   create_option (0, \"desc\", cond), this_file, line);\n+\t\t\t   create_string_option (0, \"desc\", cond), \n+\t\t\t   this_file, line);\n }\n \n #define create_optional_field(next,type,name,cond)\t\\\n@@ -1031,14 +962,16 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n       return &string_type;\n     }\n \n-  nodot = create_option (NULL, \"dot\", \"\");\n+  nodot = create_string_option (NULL, \"dot\", \"\");\n \n   rtx_tp = create_pointer (find_structure (\"rtx_def\", 0));\n   rtvec_tp = create_pointer (find_structure (\"rtvec_def\", 0));\n   tree_tp = create_pointer (find_structure (\"tree_node\", 1));\n   mem_attrs_tp = create_pointer (find_structure (\"mem_attrs\", 0));\n-  reg_attrs_tp = create_pointer (find_structure (\"reg_attrs\", 0));\n-  basic_block_tp = create_pointer (find_structure (\"basic_block_def\", 0));\n+  reg_attrs_tp = \n+    create_pointer (find_structure (\"reg_attrs\", 0));\n+  basic_block_tp = \n+    create_pointer (find_structure (\"basic_block_def\", 0));\n   constant_tp =\n     create_pointer (find_structure (\"constant_descriptor_rtx\", 0));\n   scalar_tp = &scalar_nonchar;\t/* rtunion int */\n@@ -1072,23 +1005,22 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t/* NOTE_INSN_MAX is used as the default field for line\n \t   number notes.  */\n \tif (c == NOTE_INSN_MAX)\n-\t  note_flds->opt = create_option (nodot, \"default\", \"\");\n+\t  note_flds->opt = \n+\t    create_string_option (nodot, \"default\", \"\");\n \telse\n-\t  note_flds->opt = create_option (nodot, \"tag\", note_insn_name[c]);\n+\t  note_flds->opt = \n+\t    create_string_option (nodot, \"tag\", note_insn_name[c]);\n       }\n     note_union_tp = new_structure (\"rtx_def_note_subunion\", 1,\n \t\t\t\t   &lexer_line, note_flds, NULL);\n   }\n   /* Create a type to represent the various forms of SYMBOL_REF_DATA.  */\n   {\n     pair_p sym_flds;\n-\n     sym_flds = create_field (NULL, tree_tp, \"rt_tree\");\n-    sym_flds->opt = create_option (nodot, \"default\", \"\");\n-\n+    sym_flds->opt = create_string_option (nodot, \"default\", \"\");\n     sym_flds = create_field (sym_flds, constant_tp, \"rt_constant\");\n-    sym_flds->opt = create_option (nodot, \"tag\", \"1\");\n-\n+    sym_flds->opt = create_string_option (nodot, \"tag\", \"1\");\n     symbol_union_tp = new_structure (\"rtx_def_symbol_subunion\", 1,\n \t\t\t\t     &lexer_line, sym_flds, NULL);\n   }\n@@ -1152,9 +1084,10 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t\tt = scalar_tp, subname = \"rt_int\";\n \t      else\n \t\t{\n-\t\t  error_at_line (&lexer_line,\n-\t\t\t\t \"rtx type `%s' has `0' in position %lu, can't handle\",\n-\t\t\t\t rtx_name[i], (unsigned long) aindex);\n+\t\t  error_at_line \n+\t\t    (&lexer_line,\n+\t\t     \"rtx type `%s' has `0' in position %lu, can't handle\",\n+\t\t     rtx_name[i], (unsigned long) aindex);\n \t\t  t = &string_type;\n \t\t  subname = \"rt_int\";\n \t\t}\n@@ -1190,10 +1123,11 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t      break;\n \n \t    default:\n-\t      error_at_line (&lexer_line,\n-\t\t\t     \"rtx type `%s' has `%c' in position %lu, can't handle\",\n-\t\t\t     rtx_name[i], rtx_format[i][aindex],\n-\t\t\t     (unsigned long) aindex);\n+\t      error_at_line\n+\t\t(&lexer_line,\n+\t\t \"rtx type `%s' has `%c' in position %lu, can't handle\",\n+\t\t rtx_name[i], rtx_format[i][aindex],\n+\t\t (unsigned long) aindex);\n \t      t = &string_type;\n \t      subname = \"rt_int\";\n \t      break;\n@@ -1205,16 +1139,19 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t\t\t\t\t       subname));\n \t  subfields->opt = nodot;\n \t  if (t == note_union_tp)\n-\t    subfields->opt = create_option (subfields->opt, \"desc\",\n-\t\t\t\t\t    \"NOTE_KIND (&%0)\");\n+\t    subfields->opt =\n+\t      create_string_option (subfields->opt, \"desc\",\n+\t\t\t\t    \"NOTE_KIND (&%0)\");\n \t  if (t == symbol_union_tp)\n-\t    subfields->opt = create_option (subfields->opt, \"desc\",\n-\t\t\t\t\t    \"CONSTANT_POOL_ADDRESS_P (&%0)\");\n+\t    subfields->opt = \n+\t      create_string_option (subfields->opt, \"desc\",\n+\t\t\t\t    \"CONSTANT_POOL_ADDRESS_P (&%0)\");\n \t}\n \n       if (i == SYMBOL_REF)\n \t{\n-\t  /* Add the \"block_sym\" field if SYMBOL_REF_HAS_BLOCK_INFO_P holds.  */\n+\t  /* Add the \"block_sym\" field if SYMBOL_REF_HAS_BLOCK_INFO_P\n+\t     holds.  */\n \t  type_p field_tp = find_structure (\"block_symbol\", 0);\n \t  subfields\n \t    = create_optional_field (subfields, field_tp, \"block_sym\",\n@@ -1227,11 +1164,9 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n       ftag = xstrdup (rtx_name[i]);\n       for (nmindex = 0; nmindex < strlen (ftag); nmindex++)\n \tftag[nmindex] = TOUPPER (ftag[nmindex]);\n-\n       flds = create_field (flds, substruct, \"\");\n-      flds->opt = create_option (nodot, \"tag\", ftag);\n+      flds->opt = create_string_option (nodot, \"tag\", ftag);\n     }\n-\n   return new_structure (\"rtx_def_subunion\", 1, &lexer_line, flds, nodot);\n }\n \n@@ -1254,12 +1189,12 @@ adjust_field_tree_exp (type_p t, options_p opt ATTRIBUTE_UNUSED)\n       return &string_type;\n     }\n \n-  nodot = create_option (NULL, \"dot\", \"\");\n+  nodot = create_string_option (NULL, \"dot\", \"\");\n \n   flds = create_field (NULL, t, \"\");\n-  flds->opt = create_option (nodot, \"length\",\n-\t\t\t     \"TREE_OPERAND_LENGTH ((tree) &%0)\");\n-  flds->opt = create_option (flds->opt, \"default\", \"\");\n+  flds->opt = create_string_option (nodot, \"length\",\n+\t\t\t\t    \"TREE_OPERAND_LENGTH ((tree) &%0)\");\n+  flds->opt = create_string_option (flds->opt, \"default\", \"\");\n \n   return new_structure (\"tree_exp_subunion\", 1, &lexer_line, flds, nodot);\n }\n@@ -1289,10 +1224,11 @@ adjust_field_type (type_p t, options_p opt)\n   for (; opt; opt = opt->next)\n     if (strcmp (opt->name, \"length\") == 0)\n       length_p = 1;\n-    else if (strcmp (opt->name, \"param_is\") == 0\n-\t     || (strncmp (opt->name, \"param\", 5) == 0\n-\t\t && ISDIGIT (opt->name[5])\n-\t\t && strcmp (opt->name + 6, \"_is\") == 0))\n+    else if ((strcmp (opt->name, \"param_is\") == 0\n+\t      || (strncmp (opt->name, \"param\", 5) == 0\n+\t\t  && ISDIGIT (opt->name[5])\n+\t\t  && strcmp (opt->name + 6, \"_is\") == 0))\n+\t     && opt->kind == OPTION_TYPE)\n       {\n \tint num = ISDIGIT (opt->name[5]) ? opt->name[5] - '0' : 0;\n \n@@ -1309,14 +1245,14 @@ adjust_field_type (type_p t, options_p opt)\n \tif (params[num] != NULL)\n \t  error_at_line (&lexer_line, \"duplicate `%s' option\", opt->name);\n \tif (!ISDIGIT (opt->name[5]))\n-\t  params[num] =\n-\t    create_pointer (CONST_CAST2 (type_p, const char *, opt->info));\n+\t  params[num] = create_pointer (opt->info.type);\n \telse\n-\t  params[num] = CONST_CAST2 (type_p, const char *, opt->info);\n+\t  params[num] = opt->info.type;\n       }\n-    else if (strcmp (opt->name, \"special\") == 0)\n+    else if (strcmp (opt->name, \"special\") == 0\n+\t     && opt->kind == OPTION_STRING)\n       {\n-\tconst char *special_name = opt->info;\n+\tconst char *special_name = opt->info.string;\n \tif (strcmp (special_name, \"tree_exp\") == 0)\n \t  t = adjust_field_tree_exp (t, opt);\n \telse if (strcmp (special_name, \"rtx_def\") == 0)\n@@ -1359,8 +1295,9 @@ process_gc_options (options_p opt, enum gc_used_enum level, int *maybe_undef,\n {\n   options_p o;\n   for (o = opt; o; o = o->next)\n-    if (strcmp (o->name, \"ptr_alias\") == 0 && level == GC_POINTED_TO)\n-      set_gc_used_type (CONST_CAST2 (type_p, const char *, o->info),\n+    if (strcmp (o->name, \"ptr_alias\") == 0 && level == GC_POINTED_TO\n+\t&& o->kind == OPTION_TYPE)\n+      set_gc_used_type (o->info.type,\n \t\t\tGC_POINTED_TO, NULL);\n     else if (strcmp (o->name, \"maybe_undef\") == 0)\n       *maybe_undef = 1;\n@@ -1370,12 +1307,13 @@ process_gc_options (options_p opt, enum gc_used_enum level, int *maybe_undef,\n       *length = 1;\n     else if (strcmp (o->name, \"skip\") == 0)\n       *skip = 1;\n-    else if (strcmp (o->name, \"nested_ptr\") == 0)\n-      *nested_ptr = ((const struct nested_ptr_data *) o->info)->type;\n+    else if (strcmp (o->name, \"nested_ptr\") == 0\n+\t     && o->kind == OPTION_NESTED)\n+      *nested_ptr = ((const struct nested_ptr_data *) o->info.nested)->type;\n }\n \n-/* Set the gc_used field of T to LEVEL, and handle the types it references.  */\n \n+/* Set the gc_used field of T to LEVEL, and handle the types it references.  */\n static void\n set_gc_used_type (type_p t, enum gc_used_enum level, type_p param[NUM_PARAM])\n {\n@@ -2318,6 +2256,9 @@ output_mangled_typename (outf_p of, const_type_p t)\n   else\n     switch (t->kind)\n       {\n+      case TYPE_NONE:\n+\tgcc_unreachable ();\n+\tbreak;\n       case TYPE_POINTER:\n \toprintf (of, \"P\");\n \toutput_mangled_typename (of, t->u.p);\n@@ -2413,21 +2354,22 @@ walk_type (type_p t, struct walk_type_data *d)\n \n   d->needs_cast_p = false;\n   for (oo = d->opt; oo; oo = oo->next)\n-    if (strcmp (oo->name, \"length\") == 0)\n-      length = oo->info;\n+    if (strcmp (oo->name, \"length\") == 0 && oo->kind == OPTION_STRING)\n+      length = oo->info.string;\n     else if (strcmp (oo->name, \"maybe_undef\") == 0)\n       maybe_undef_p = 1;\n     else if (strncmp (oo->name, \"use_param\", 9) == 0\n \t     && (oo->name[9] == '\\0' || ISDIGIT (oo->name[9])))\n       use_param_num = oo->name[9] == '\\0' ? 0 : oo->name[9] - '0';\n     else if (strcmp (oo->name, \"use_params\") == 0)\n       use_params_p = 1;\n-    else if (strcmp (oo->name, \"desc\") == 0)\n-      desc = oo->info;\n+    else if (strcmp (oo->name, \"desc\") == 0 && oo->kind == OPTION_STRING)\n+      desc = oo->info.string;\n     else if (strcmp (oo->name, \"mark_hook\") == 0)\n       ;\n-    else if (strcmp (oo->name, \"nested_ptr\") == 0)\n-      nested_ptr_d = (const struct nested_ptr_data *) oo->info;\n+    else if (strcmp (oo->name, \"nested_ptr\") == 0 \n+\t     && oo->kind == OPTION_NESTED)\n+      nested_ptr_d = (const struct nested_ptr_data *) oo->info.nested;\n     else if (strcmp (oo->name, \"dot\") == 0)\n       ;\n     else if (strcmp (oo->name, \"tag\") == 0)\n@@ -2675,8 +2617,9 @@ walk_type (type_p t, struct walk_type_data *d)\n \n \t/* Some things may also be defined in the structure's options.  */\n \tfor (o = t->u.s.opt; o; o = o->next)\n-\t  if (!desc && strcmp (o->name, \"desc\") == 0)\n-\t    desc = o->info;\n+\t  if (!desc && strcmp (o->name, \"desc\") == 0\n+\t      && o->kind == OPTION_STRING)\n+\t    desc = o->info.string;\n \n \td->prev_val[2] = oldval;\n \td->prev_val[1] = oldprevval2;\n@@ -2707,16 +2650,19 @@ walk_type (type_p t, struct walk_type_data *d)\n \n \t    d->reorder_fn = NULL;\n \t    for (oo = f->opt; oo; oo = oo->next)\n-\t      if (strcmp (oo->name, \"dot\") == 0)\n-\t\tdot = oo->info;\n-\t      else if (strcmp (oo->name, \"tag\") == 0)\n-\t\ttagid = oo->info;\n+\t      if (strcmp (oo->name, \"dot\") == 0\n+\t\t  && oo->kind == OPTION_STRING)\n+\t\tdot = oo->info.string;\n+\t      else if (strcmp (oo->name, \"tag\") == 0\n+\t\t       && oo->kind == OPTION_STRING)\n+\t\ttagid = oo->info.string;\n \t      else if (strcmp (oo->name, \"skip\") == 0)\n \t\tskip_p = 1;\n \t      else if (strcmp (oo->name, \"default\") == 0)\n \t\tdefault_p = 1;\n-\t      else if (strcmp (oo->name, \"reorder\") == 0)\n-\t\td->reorder_fn = oo->info;\n+\t      else if (strcmp (oo->name, \"reorder\") == 0\n+\t\t  && oo->kind == OPTION_STRING)\n+\t\td->reorder_fn = oo->info.string;\n \t      else if (strncmp (oo->name, \"use_param\", 9) == 0\n \t\t       && (oo->name[9] == '\\0' || ISDIGIT (oo->name[9])))\n \t\tuse_param_p = 1;\n@@ -2830,6 +2776,8 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n \n   switch (f->kind)\n     {\n+    case TYPE_NONE:\n+      gcc_unreachable ();\n     case TYPE_POINTER:\n       oprintf (d->of, \"%*s%s (%s%s\", d->indent, \"\",\n \t       wtd->subfield_marker_routine, cast, d->val);\n@@ -2882,7 +2830,7 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n     case TYPE_SCALAR:\n       break;\n \n-    default:\n+    case TYPE_ARRAY:\n       gcc_unreachable ();\n     }\n }\n@@ -2950,17 +2898,19 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \n   memset (&d, 0, sizeof (d));\n   d.of = get_output_file_for_structure (s, param);\n-\n   for (opt = s->u.s.opt; opt; opt = opt->next)\n-    if (strcmp (opt->name, \"chain_next\") == 0)\n-      chain_next = opt->info;\n-    else if (strcmp (opt->name, \"chain_prev\") == 0)\n-      chain_prev = opt->info;\n-    else if (strcmp (opt->name, \"chain_circular\") == 0)\n-      chain_circular = opt->info;\n-    else if (strcmp (opt->name, \"mark_hook\") == 0)\n-      mark_hook_name = opt->info;\n-\n+    if (strcmp (opt->name, \"chain_next\") == 0\n+\t&& opt->kind == OPTION_STRING)\n+      chain_next = opt->info.string;\n+    else if (strcmp (opt->name, \"chain_prev\") == 0\n+\t     && opt->kind == OPTION_STRING)\n+      chain_prev = opt->info.string;\n+    else if (strcmp (opt->name, \"chain_circular\") == 0\n+\t     && opt->kind == OPTION_STRING)\n+      chain_circular = opt->info.string;\n+    else if (strcmp (opt->name, \"mark_hook\") == 0\n+\t     && opt->kind == OPTION_STRING)\n+      mark_hook_name = opt->info.string;\n   if (chain_prev != NULL && chain_next == NULL)\n     error_at_line (&s->u.s.line, \"chain_prev without chain_next\");\n   if (chain_circular != NULL && chain_next != NULL)\n@@ -3127,9 +3077,10 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \toprintf (output_header, \"  } while (0)\\n\");\n \n \tfor (opt = s->u.s.opt; opt; opt = opt->next)\n-\t  if (strcmp (opt->name, \"ptr_alias\") == 0)\n+\t  if (strcmp (opt->name, \"ptr_alias\") == 0\n+\t      && opt->kind == OPTION_TYPE)\n \t    {\n-\t      const_type_p const t = (const_type_p) opt->info;\n+\t      const_type_p const t = (const_type_p) opt->info.type;\n \t      if (t->kind == TYPE_STRUCT\n \t\t  || t->kind == TYPE_UNION || t->kind == TYPE_LANG_STRUCT)\n \t\toprintf (output_header,\n@@ -3352,11 +3303,11 @@ write_local (outf_p output_header, type_p structures, type_p param_structs)\n \n \tif (s->u.s.line.file == NULL)\n \t  continue;\n-\n-\tfor (opt = s->u.s.opt; opt; opt = opt->next)\n-\t  if (strcmp (opt->name, \"ptr_alias\") == 0)\n+ \tfor (opt = s->u.s.opt; opt; opt = opt->next)\n+\t  if (strcmp (opt->name, \"ptr_alias\") == 0\n+\t      && opt->kind == OPTION_TYPE)\n \t    {\n-\t      const_type_p const t = (const_type_p) opt->info;\n+\t      const_type_p const t = (const_type_p) opt->info.type;\n \t      if (t->kind == TYPE_STRUCT\n \t\t  || t->kind == TYPE_UNION || t->kind == TYPE_LANG_STRUCT)\n \t\t{\n@@ -3679,8 +3630,9 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \t    for (o = fld->opt; o; o = o->next)\n \t      if (strcmp (o->name, \"skip\") == 0)\n \t\tskip_p = 1;\n-\t      else if (strcmp (o->name, \"desc\") == 0)\n-\t\tdesc = o->info;\n+\t      else if (strcmp (o->name, \"desc\") == 0\n+\t\t       && o->kind == OPTION_STRING)\n+\t\tdesc = o->info.string;\n \t      else if (strcmp (o->name, \"param_is\") == 0)\n \t\t;\n \t      else\n@@ -3699,10 +3651,10 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \t\t  {\n \t\t    const char *tag = NULL;\n \t\t    options_p oo;\n-\n-\t\t    for (oo = ufld->opt; oo; oo = oo->next)\n-\t\t      if (strcmp (oo->name, \"tag\") == 0)\n-\t\t\ttag = oo->info;\n+ \t\t    for (oo = ufld->opt; oo; oo = oo->next)\n+\t\t      if (strcmp (oo->name, \"tag\") == 0\n+\t\t\t  && oo->kind == OPTION_STRING)\n+\t\t\ttag = oo->info.string;\n \t\t    if (tag == NULL || strcmp (tag, desc) != 0)\n \t\t      continue;\n \t\t    if (validf != NULL)\n@@ -3873,10 +3825,10 @@ write_roots (pair_p variables, bool emit_pch)\n       const char *length = NULL;\n       int deletable_p = 0;\n       options_p o;\n-\n       for (o = v->opt; o; o = o->next)\n-\tif (strcmp (o->name, \"length\") == 0)\n-\t  length = o->info;\n+\tif (strcmp (o->name, \"length\") == 0\n+\t    && o->kind == OPTION_STRING)\n+\t  length = o->info.string;\n \telse if (strcmp (o->name, \"deletable\") == 0)\n \t  deletable_p = 1;\n \telse if (strcmp (o->name, \"param_is\") == 0)\n@@ -4003,12 +3955,11 @@ write_roots (pair_p variables, bool emit_pch)\n       for (o = v->opt; o; o = o->next)\n \tif (strcmp (o->name, \"length\") == 0)\n \t  length_p = 1;\n-\telse if (strcmp (o->name, \"if_marked\") == 0)\n-\t  if_marked = o->info;\n-\n-      if (if_marked == NULL)\n+\telse if (strcmp (o->name, \"if_marked\") == 0\n+\t\t       && o->kind == OPTION_STRING)\n+\t  if_marked = o->info.string;\n+       if (if_marked == NULL)\n \tcontinue;\n-\n       if (v->type->kind != TYPE_POINTER\n \t  || v->type->u.p->kind != TYPE_PARAM_STRUCT\n \t  || v->type->u.p->u.param_struct.stru != find_structure (\"htab\", 0))\n@@ -4143,9 +4094,8 @@ note_def_vec (const char *type_name, bool is_scalar, struct fileloc *pos)\n   else\n     {\n       t = resolve_typedef (type_name, pos);\n-      o = create_option (0, \"length\", \"%h.num\");\n+      o = create_string_option (0, \"length\", \"%h.num\");\n     }\n-\n   /* We assemble the field list in reverse order.  */\n   fields = create_field_at (0, create_array (t, \"1\"), \"vec\", o, pos);\n   fields = create_field_at (fields, len_ty, \"alloc\", 0, pos);\n@@ -4463,7 +4413,21 @@ dump_options (int indent, options_p opt)\n   o = opt;\n   while (o)\n     {\n-      printf (\"%s:%s \", o->name, o->info);\n+      switch (o->kind)\n+\t{\n+\tcase OPTION_STRING:\n+\t  printf (\"%s:string %s \", o->name, o->info.string);\n+\t  break;\n+\tcase OPTION_TYPE:\n+\t  printf (\"%s:type \", o->name);\n+\t  dump_type (indent+1, o->info.type);\n+\t  break;\n+\tcase OPTION_NESTED:\n+\t  printf (\"%s:nested \", o->name);\n+\t  break;\n+\tcase OPTION_NONE:\n+\t  gcc_unreachable ();\n+\t}\n       o = o->next;\n     }\n   printf (\"\\n\");"}, {"sha": "2046e40d6e976d798022259903729ff6483f3bd9", "filename": "gcc/gengtype.h", "status": "modified", "additions": 212, "deletions": 5, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/412dc29d628f7b523790a34042a3c55e77ed1f9f/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/412dc29d628f7b523790a34042a3c55e77ed1f9f/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=412dc29d628f7b523790a34042a3c55e77ed1f9f", "patch": "@@ -116,6 +116,218 @@ typedef struct options *options_p;\n extern int lexer_toplevel_done;\n extern struct fileloc lexer_line;\n \n+/* Various things, organized as linked lists, needed both in\n+   gengtype.c & in gengtype-state.c files.  */\n+extern pair_p typedefs;\n+extern type_p structures;\n+extern type_p param_structs;\n+extern pair_p variables;\n+\n+\n+\n+/* Discrimating kind of types we can understand.  */\n+\n+enum typekind {\n+  TYPE_NONE=0,          /* Never used, so zeroed memory is invalid.  */\n+  TYPE_SCALAR,          /* Scalar types like char.  */\n+  TYPE_STRING,          /* The string type.  */\n+  TYPE_STRUCT,          /* Type for GTY-ed structs.  */\n+  TYPE_UNION,           /* Type for GTY-ed discriminated unions.  */\n+  TYPE_POINTER,         /* Pointer type to GTY-ed type.  */\n+  TYPE_ARRAY,           /* Array of GTY-ed types.  */\n+  TYPE_LANG_STRUCT,     /* GCC front-end language specific structs.\n+                           Various languages may have homonymous but\n+                           different structs.  */\n+  TYPE_PARAM_STRUCT     /* Type for parametrized structs, e.g. hash_t\n+                           hash-tables, ...  See (param_is, use_param,\n+                           param1_is, param2_is,... use_param1,\n+                           use_param_2,... use_params) GTY\n+                           options.  */\n+};\n+\n+/* Discriminating kind for options.  */\n+enum option_kind {\n+  OPTION_NONE=0,        /* Never used, so zeroed memory is invalid.  */\n+  OPTION_STRING,        /* A string-valued option.  Most options are\n+                           strings.  */\n+  OPTION_TYPE,          /* A type-valued option.  */\n+  OPTION_NESTED         /* Option data for 'nested_ptr'.  */\n+};\n+\n+\n+/* A way to pass data through to the output end.  */\n+struct options {\n+  struct options *next;         /* next option of the same pair.  */\n+  const char *name;             /* GTY option name.  */\n+  enum option_kind kind;        /* discriminating option kind.  */\n+  union {\n+    const char* string;                    /* When OPTION_STRING.  */\n+    type_p type;                           /* When OPTION_TYPE.  */\n+    struct nested_ptr_data* nested;        /* when OPTION_NESTED.  */\n+  } info;\n+};\n+\n+\n+/* Option data for the 'nested_ptr' option.  */\n+struct nested_ptr_data {\n+  type_p type;\n+  const char *convert_to;\n+  const char *convert_from;\n+};\n+\n+/* Some functions to create various options structures with name NAME\n+   and info INFO.  NEXT is the next option in the chain.  */\n+\n+/* Create a string option.  */\n+options_p create_string_option (options_p next, const char* name,\n+                                const char* info);\n+\n+/* Create a type option.  */\n+options_p create_type_option (options_p next, const char* name,\n+                              type_p info);\n+\n+/* Create a nested option.  */\n+options_p create_nested_option (options_p next, const char* name,\n+\t\t\t\tstruct nested_ptr_data* info);\n+\n+/* Create a nested pointer option.  */\n+options_p create_nested_ptr_option (options_p, type_p t,\n+\t\t\t \t     const char *from, const char *to);\n+\n+/* A name and a type.  */\n+struct pair {\n+  pair_p next;                  /* The next pair in the linked list.  */\n+  const char *name;             /* The defined name.  */\n+  type_p type;                  /* Its GTY-ed type.  */\n+  struct fileloc line;          /* The file location.  */\n+  options_p opt;                /* GTY options, as a linked list.  */\n+};\n+\n+/* Usage information for GTY-ed types.  Gengtype has to care only of\n+   used GTY-ed types.  Types are initially unused, and their usage is\n+   computed by set_gc_used_type and set_gc_used functions.  */\n+\n+enum gc_used_enum {\n+\n+  /* We need that zeroed types are initially unused.  */\n+  GC_UNUSED=0,\n+\n+  /* The GTY-ed type is used, e.g by a GTY-ed variable or a field\n+     inside a GTY-ed used type.  */\n+  GC_USED,\n+\n+  /* For GTY-ed structures whose definitions we haven't seen so far\n+     when we encounter a pointer to it that is annotated with\n+     ``maybe_undef''.  If after reading in everything we don't have\n+     source file information for it, we assume that it never has been\n+     defined.  */\n+  GC_MAYBE_POINTED_TO,\n+\n+  /* For known GTY-ed structures which are pointed to by GTY-ed\n+     variables or fields.  */\n+  GC_POINTED_TO\n+};\n+\n+/* We can have at most ten type parameters in parameterized structures.  */\n+#define NUM_PARAM 10\n+\n+/* Our type structure describes all types handled by gengtype.  */\n+struct type {\n+  /* Discriminating kind, cannot be TYPE_NONE.  */\n+  enum typekind kind;\n+\n+  /* For top-level structs or unions, the 'next' field links the\n+     global list 'structures' or 'param_structs'; for lang_structs,\n+     their homonymous structs are linked using this 'next' field.  The\n+     homonymous list starts at the s.lang_struct field of the\n+     lang_struct.  See the new_structure function for details.  This is\n+     tricky!  */\n+  type_p next;\n+\n+  /* State number used when writing & reading the persistent state.  A\n+     type with a positive number has already been written.  For ease\n+     of debugging, newly allocated types have a unique negative\n+     number.  */\n+  int state_number;\n+\n+  /* Each GTY-ed type which is pointed to by some GTY-ed type knows\n+     the GTY pointer type pointing to it.  See create_pointer\n+     function.  */\n+  type_p pointer_to;\n+\n+  /* Type usage information, computed by set_gc_used_type and\n+     set_gc_used functions.  */\n+  enum gc_used_enum gc_used;\n+\n+  /* The following union is discriminated by the 'kind' field above.  */\n+  union {\n+    /* TYPE__NONE is impossible.  */\n+\n+    /* when TYPE_POINTER:  */\n+    type_p p;\n+\n+    /* when TYPE_STRUCT or TYPE_UNION or TYPE_LANG_STRUCT, we have an\n+       aggregate type containing fields: */\n+    struct {\n+      const char *tag;          /* the aggragate tag, if any.  */\n+      struct fileloc line;      /* the source location.  */\n+      pair_p fields;            /* the linked list of fields.  */\n+      options_p opt;            /* the GTY options if any.  */\n+      lang_bitmap bitmap;       /* the set of front-end languages\n+                                   using that GTY-ed aggregate.  */\n+      /* For TYPE_LANG_STRUCT, the lang_struct field gives the first\n+         element of a linked list of homonymous struct or union types.\n+         Within this list, each homonymous type has as its lang_struct\n+         field the original TYPE_LANG_STRUCT type.  This is a dirty\n+         trick, see the new_structure function for details.  */\n+      type_p lang_struct;\n+    } s;\n+\n+    /* when TYPE_SCALAR: */\n+    bool scalar_is_char;\n+\n+    /* when TYPE_ARRAY: */\n+    struct {\n+      type_p p;                 /* The array component type.  */\n+      const char *len;          /* The string if any giving its length.  */\n+    } a;\n+\n+    /* When TYPE_PARAM_STRUCT for (param_is, use_param, param1_is,\n+       param2_is, ... use_param1, use_param_2, ... use_params) GTY\n+       options.  */\n+    struct {\n+      type_p stru;              /* The generic GTY-ed type.  */\n+      type_p param[NUM_PARAM];  /* The actual parameter types.  */\n+      struct fileloc line;      /* The source location.  */\n+    } param_struct;\n+\n+  } u;\n+};\n+\n+/* The one and only TYPE_STRING.  */\n+extern struct type string_type;\n+\n+/* The two and only TYPE_SCALARs.  Their u.scalar_is_char flags are\n+   set early in main.  */\n+extern struct type scalar_nonchar;\n+extern struct type scalar_char;\n+\n+/* Test if a type is a union, either a plain one or a language\n+   specific one.  */\n+#define UNION_P(x)                                      \\\n+    ((x)->kind == TYPE_UNION ||                         \\\n+     ((x)->kind == TYPE_LANG_STRUCT                     \\\n+      && (x)->u.s.lang_struct->kind == TYPE_UNION))\n+\n+/* Test if a type is a union or a structure, perhaps a language\n+   specific one.  */\n+#define UNION_OR_STRUCT_P(x)\t\t\t\\\n+    ((x)->kind == TYPE_UNION \t\t\t\\\n+     || (x)->kind == TYPE_STRUCT\t\t\\\n+     || (x)->kind == TYPE_LANG_STRUCT)\n+\n+\n+\n /* Structure representing an output file.  */\n struct outf\n {\n@@ -180,11 +392,6 @@ extern type_p find_structure (const char *s, int isunion);\n extern type_p create_scalar_type (const char *name);\n extern type_p create_pointer (type_p t);\n extern type_p create_array (type_p t, const char *len);\n-extern options_p create_option (options_p, const char *name,\n-\t\t\t\tconst void *info);\n-extern options_p create_nested_ptr_option (options_p, type_p t,\n-\t\t\t\t\t   const char *from,\n-\t\t\t\t\t   const char *to);\n extern pair_p create_field_at (pair_p next, type_p type,\n \t\t\t       const char *name, options_p opt,\n \t\t\t       struct fileloc *pos);"}]}