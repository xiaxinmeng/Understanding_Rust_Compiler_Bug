{"sha": "97286431624c245b32ae05c33e9af2876eda55ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcyODY0MzE2MjRjMjQ1YjMyYWUwNWMzM2U5YWYyODc2ZWRhNTVlZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-12-16T18:44:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-12-16T18:44:51Z"}, "message": "internal-fn.c: Include stringpool.h and tree-ssanames.h.\n\n\t* internal-fn.c: Include stringpool.h and tree-ssanames.h.\n\t(ubsan_expand_si_overflow_addsub_check): In the generic expansion,\n\ttry to improve generated code if one of the arguments is constant\n\tor get_range_info says that one of the argument is always\n\tnegative or always non-negative.\n\t* tree-vrp.c (simplify_internal_call_using_ranges): New function.\n\t(simplify_stmt_using_ranges): Call it.\n\nFrom-SVN: r206025", "tree": {"sha": "41dc923f102f79eeb2f9561e2cba92cf1201e9c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41dc923f102f79eeb2f9561e2cba92cf1201e9c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97286431624c245b32ae05c33e9af2876eda55ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97286431624c245b32ae05c33e9af2876eda55ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97286431624c245b32ae05c33e9af2876eda55ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97286431624c245b32ae05c33e9af2876eda55ee/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "91c5ee5b4ac9c85b6cbf596dc7917910b0d7b1b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c5ee5b4ac9c85b6cbf596dc7917910b0d7b1b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91c5ee5b4ac9c85b6cbf596dc7917910b0d7b1b3"}], "stats": {"total": 150, "additions": 140, "deletions": 10}, "files": [{"sha": "25f85d2cea49845acddef6b1179c7e5bb403f4e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97286431624c245b32ae05c33e9af2876eda55ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97286431624c245b32ae05c33e9af2876eda55ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97286431624c245b32ae05c33e9af2876eda55ee", "patch": "@@ -1,3 +1,13 @@\n+2013-12-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* internal-fn.c: Include stringpool.h and tree-ssanames.h.\n+\t(ubsan_expand_si_overflow_addsub_check): In the generic expansion,\n+\ttry to improve generated code if one of the arguments is constant\n+\tor get_range_info says that one of the argument is always\n+\tnegative or always non-negative.\n+\t* tree-vrp.c (simplify_internal_call_using_ranges): New function.\n+\t(simplify_stmt_using_ranges): Call it.\n+\n 2013-12-16  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/59466"}, {"sha": "a0dbad139a07ca247df99932e2416ce33f6cef6f", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 65, "deletions": 10, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97286431624c245b32ae05c33e9af2876eda55ee/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97286431624c245b32ae05c33e9af2876eda55ee/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=97286431624c245b32ae05c33e9af2876eda55ee", "patch": "@@ -34,6 +34,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ubsan.h\"\n #include \"target.h\"\n #include \"predict.h\"\n+#include \"stringpool.h\"\n+#include \"tree-ssanames.h\"\n \n /* The names of each internal function, indexed by function number.  */\n const char *const internal_fn_name_array[] = {\n@@ -211,28 +213,81 @@ ubsan_expand_si_overflow_addsub_check (tree_code code, gimple stmt)\n   if (icode == CODE_FOR_nothing)\n     {\n       rtx sub_check = gen_label_rtx ();\n+      int pos_neg = 3;\n \n       /* Compute the operation.  On RTL level, the addition is always\n \t unsigned.  */\n       res = expand_binop (mode, code == PLUS_EXPR ? add_optab : sub_optab,\n \t\t\t  op0, op1, NULL_RTX, false, OPTAB_LIB_WIDEN);\n \n+      /* If we can prove one of the arguments is always non-negative\n+\t or always negative, we can do just one comparison and\n+\t conditional jump instead of 2 at runtime, 3 present in the\n+\t emitted code.  If one of the arguments is CONST_INT, all we\n+\t need is to make sure it is op1, then the first\n+\t emit_cmp_and_jump_insns will be just folded.  Otherwise try\n+\t to use range info if available.  */\n+      if (CONST_INT_P (op0))\n+\t{\n+\t  rtx tem = op0;\n+\t  op0 = op1;\n+\t  op1 = tem;\n+\t}\n+      else if (CONST_INT_P (op1))\n+\t;\n+      else if (TREE_CODE (arg0) == SSA_NAME)\n+\t{\n+\t  double_int arg0_min, arg0_max;\n+\t  if (get_range_info (arg0, &arg0_min, &arg0_max) == VR_RANGE)\n+\t    {\n+\t      if (!arg0_min.is_negative ())\n+\t\tpos_neg = 1;\n+\t      else if (arg0_max.is_negative ())\n+\t\tpos_neg = 2;\n+\t    }\n+\t  if (pos_neg != 3)\n+\t    {\n+\t      rtx tem = op0;\n+\t      op0 = op1;\n+\t      op1 = tem;\n+\t    }\n+\t}\n+      if (pos_neg == 3 && !CONST_INT_P (op1) && TREE_CODE (arg1) == SSA_NAME)\n+\t{\n+\t  double_int arg1_min, arg1_max;\n+\t  if (get_range_info (arg1, &arg1_min, &arg1_max) == VR_RANGE)\n+\t    {\n+\t      if (!arg1_min.is_negative ())\n+\t\tpos_neg = 1;\n+\t      else if (arg1_max.is_negative ())\n+\t\tpos_neg = 2;\n+\t    }\n+\t}\n+\n       /* If the op1 is negative, we have to use a different check.  */\n-      emit_cmp_and_jump_insns (op1, const0_rtx, LT, NULL_RTX, mode,\n-\t\t\t       false, sub_check, PROB_EVEN);\n+      if (pos_neg == 3)\n+\temit_cmp_and_jump_insns (op1, const0_rtx, LT, NULL_RTX, mode,\n+\t\t\t\t false, sub_check, PROB_EVEN);\n \n       /* Compare the result of the operation with one of the operands.  */\n-      emit_cmp_and_jump_insns (res, op0, code == PLUS_EXPR ? GE : LE,\n-\t\t\t       NULL_RTX, mode, false, done_label,\n-\t\t\t       PROB_VERY_LIKELY);\n+      if (pos_neg & 1)\n+\temit_cmp_and_jump_insns (res, op0, code == PLUS_EXPR ? GE : LE,\n+\t\t\t\t NULL_RTX, mode, false, done_label,\n+\t\t\t\t PROB_VERY_LIKELY);\n+\n       /* If we get here, we have to print the error.  */\n-      emit_jump (do_error);\n+      if (pos_neg == 3)\n+\t{\n+\t  emit_jump (do_error);\n+\n+\t  emit_label (sub_check);\n+\t}\n \n-      emit_label (sub_check);\n       /* We have k = a + b for b < 0 here.  k <= a must hold.  */\n-      emit_cmp_and_jump_insns (res, op0, code == PLUS_EXPR ? LE : GE,\n-\t\t\t       NULL_RTX, mode, false, done_label,\n-\t\t\t       PROB_VERY_LIKELY);\n+      if (pos_neg & 2)\n+\temit_cmp_and_jump_insns (res, op0, code == PLUS_EXPR ? LE : GE,\n+\t\t\t\t NULL_RTX, mode, false, done_label,\n+\t\t\t\t PROB_VERY_LIKELY);\n     }\n \n   emit_label (do_error);"}, {"sha": "4de7c4d9199b22c4367ecb9aeb50579dc722fae4", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97286431624c245b32ae05c33e9af2876eda55ee/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97286431624c245b32ae05c33e9af2876eda55ee/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=97286431624c245b32ae05c33e9af2876eda55ee", "patch": "@@ -9299,6 +9299,68 @@ simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n   return true;\n }\n \n+/* Simplify an internal fn call using ranges if possible.  */\n+\n+static bool\n+simplify_internal_call_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n+{\n+  enum tree_code subcode;\n+  switch (gimple_call_internal_fn (stmt))\n+    {\n+    case IFN_UBSAN_CHECK_ADD:\n+      subcode = PLUS_EXPR;\n+      break;\n+    case IFN_UBSAN_CHECK_SUB:\n+      subcode = MINUS_EXPR;\n+      break;\n+    case IFN_UBSAN_CHECK_MUL:\n+      subcode = MULT_EXPR;\n+      break;\n+    default:\n+      return false;\n+    }\n+\n+  value_range_t vr0 = VR_INITIALIZER;\n+  value_range_t vr1 = VR_INITIALIZER;\n+  tree op0 = gimple_call_arg (stmt, 0);\n+  tree op1 = gimple_call_arg (stmt, 1);\n+\n+  if (TREE_CODE (op0) == SSA_NAME)\n+    vr0 = *get_value_range (op0);\n+  else if (TREE_CODE (op0) == INTEGER_CST)\n+    set_value_range_to_value (&vr0, op0, NULL);\n+  else\n+    return false;\n+\n+  if (TREE_CODE (op1) == SSA_NAME)\n+    vr1 = *get_value_range (op1);\n+  else if (TREE_CODE (op1) == INTEGER_CST)\n+    set_value_range_to_value (&vr1, op1, NULL);\n+  else\n+    return false;\n+\n+  if (!range_int_cst_p (&vr0) || !range_int_cst_p (&vr1))\n+    return false;\n+\n+  tree r1 = int_const_binop (subcode, vr0.min, vr1.min);\n+  tree r2 = int_const_binop (subcode, vr0.max, vr1.max);\n+  if (r1 == NULL_TREE || TREE_OVERFLOW (r1)\n+      || r2 == NULL_TREE || TREE_OVERFLOW (r2))\n+    return false;\n+  if (subcode == MULT_EXPR)\n+    {\n+      tree r3 = int_const_binop (subcode, vr0.min, vr1.max);\n+      tree r4 = int_const_binop (subcode, vr0.max, vr1.min);\n+      if (r3 == NULL_TREE || TREE_OVERFLOW (r3)\n+\t  || r4 == NULL_TREE || TREE_OVERFLOW (r4))\n+\treturn false;\n+    }\n+  gimple g = gimple_build_assign_with_ops (subcode, gimple_call_lhs (stmt),\n+\t\t\t\t\t   op0, op1);\n+  gsi_replace (gsi, g, false);\n+  return true;\n+}\n+\n /* Simplify STMT using ranges if possible.  */\n \n static bool\n@@ -9367,6 +9429,9 @@ simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n     return simplify_cond_using_ranges (stmt);\n   else if (gimple_code (stmt) == GIMPLE_SWITCH)\n     return simplify_switch_using_ranges (stmt);\n+  else if (is_gimple_call (stmt)\n+\t   && gimple_call_internal_p (stmt))\n+    return simplify_internal_call_using_ranges (gsi, stmt);\n \n   return false;\n }"}]}