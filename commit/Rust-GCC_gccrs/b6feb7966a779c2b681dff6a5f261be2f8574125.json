{"sha": "b6feb7966a779c2b681dff6a5f261be2f8574125", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZmZWI3OTY2YTc3OWMyYjY4MWRmZjZhNWYyNjFiZTJmODU3NDEyNQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2010-04-30T14:58:54Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2010-04-30T14:58:54Z"}, "message": "sdbout.c: Include vec.h, do not include varray.h.\n\n\t* sdbout.c: Include vec.h, do not include varray.h.\n\t(deferred_global_decls, sdbout_global_decl,\n\tsdbout_finish, sdbout_init): Use VEC instead of VARRAY.\n\t* toplev.c: Do not include varray.h.\n\t(dump_memory_report): Do not dump VARRAY statistics.\n\t* gengtype.c (open_base_file): Ignore varray.h.\n\t* Makefile.in: Update for abovementioned changes.\n\tRemove all traces of varray.c and varray.h.\n\t* varray.c: Remove file.\n\t* varray.h: Remove file.\n\nFrom-SVN: r158939", "tree": {"sha": "1fcd11c88845a3c74b2d60744c3b29ea233813f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fcd11c88845a3c74b2d60744c3b29ea233813f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6feb7966a779c2b681dff6a5f261be2f8574125", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6feb7966a779c2b681dff6a5f261be2f8574125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6feb7966a779c2b681dff6a5f261be2f8574125", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6feb7966a779c2b681dff6a5f261be2f8574125/comments", "author": null, "committer": null, "parents": [{"sha": "05575e078047eec2ec0730ffd9f2f99f344c3f35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05575e078047eec2ec0730ffd9f2f99f344c3f35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05575e078047eec2ec0730ffd9f2f99f344c3f35"}], "stats": {"total": 642, "additions": 32, "deletions": 610}, "files": [{"sha": "adf9734e4e0e340281c28055891803b3839ec2d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6feb7966a779c2b681dff6a5f261be2f8574125/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6feb7966a779c2b681dff6a5f261be2f8574125/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6feb7966a779c2b681dff6a5f261be2f8574125", "patch": "@@ -1,3 +1,16 @@\n+2010-04-30  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* sdbout.c: Include vec.h, do not include varray.h.\n+\t(deferred_global_decls, sdbout_global_decl,\n+\tsdbout_finish, sdbout_init): Use VEC instead of VARRAY.\n+\t* toplev.c: Do not include varray.h.\n+\t(dump_memory_report): Do not dump VARRAY statistics.\n+\t* gengtype.c (open_base_file): Ignore varray.h.\n+\t* Makefile.in: Update for abovementioned changes.\n+\tRemove all traces of varray.c and varray.h.\n+\t* varray.c: Remove file.\n+\t* varray.h: Remove file.\n+\n 2010-04-30  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-cgraph.c (lto_output_varpool_node): Always output constant pool"}, {"sha": "48f2c618ea598d91cbee605243abb3b1b4ffb62f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6feb7966a779c2b681dff6a5f261be2f8574125/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6feb7966a779c2b681dff6a5f261be2f8574125/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b6feb7966a779c2b681dff6a5f261be2f8574125", "patch": "@@ -876,7 +876,7 @@ TREE_H = tree.h all-tree.def tree.def c-common.def $(lang_tree_files) \\\n           $(MACHMODE_H) tree-check.h $(BUILTINS_DEF) \\\n           $(INPUT_H) statistics.h vec.h treestruct.def $(HASHTAB_H) \\\n           double-int.h alias.h $(SYMTAB_H) options.h\n-BASIC_BLOCK_H = basic-block.h $(BITMAP_H) sbitmap.h varray.h $(PARTITION_H) \\\n+BASIC_BLOCK_H = basic-block.h $(BITMAP_H) sbitmap.h $(PARTITION_H) \\\n           hard-reg-set.h $(PREDICT_H) vec.h $(FUNCTION_H) \\\n           cfghooks.h $(OBSTACK_H)\n GIMPLE_H = gimple.h gimple.def gsstruct.def pointer-set.h vec.h \\\n@@ -892,7 +892,7 @@ FLAGS_H = flags.h coretypes.h options.h\n FUNCTION_H = function.h $(TREE_H) $(HASHTAB_H) vecprim.h\n EXPR_H = expr.h insn-config.h $(FUNCTION_H) $(RTL_H) $(FLAGS_H) $(TREE_H) $(MACHMODE_H) $(EMIT_RTL_H)\n OPTABS_H = optabs.h insn-codes.h\n-REGS_H = regs.h varray.h $(MACHMODE_H) $(OBSTACK_H) $(BASIC_BLOCK_H) $(FUNCTION_H)\n+REGS_H = regs.h $(MACHMODE_H) $(OBSTACK_H) $(BASIC_BLOCK_H) $(FUNCTION_H)\n RESOURCE_H = resource.h hard-reg-set.h\n SCHED_INT_H = sched-int.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) $(DF_H) vecprim.h\n SEL_SCHED_IR_H = sel-sched-ir.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) \\\n@@ -911,7 +911,7 @@ DDG_H = ddg.h sbitmap.h $(DF_H)\n GCC_H = gcc.h version.h\n GGC_H = ggc.h gtype-desc.h statistics.h\n TIMEVAR_H = timevar.h timevar.def\n-INSN_ATTR_H = insn-attr.h $(INSN_ADDR_H) $(srcdir)/varray.h\n+INSN_ATTR_H = insn-attr.h $(INSN_ADDR_H)\n INSN_ADDR_H = $(srcdir)/insn-addr.h vecprim.h\n C_COMMON_H = c-common.h $(SPLAY_TREE_H) $(CPPLIB_H) $(GGC_H)\n C_PRAGMA_H = c-pragma.h $(CPPLIB_H)\n@@ -944,7 +944,6 @@ C_PRETTY_PRINT_H = c-pretty-print.h $(PRETTY_PRINT_H) $(C_COMMON_H) $(TREE_H)\n SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h $(PARAMS_H)\n LAMBDA_H = lambda.h $(TREE_H) vec.h $(GGC_H)\n TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H) omega.h graphds.h $(SCEV_H)\n-VARRAY_H = varray.h $(MACHMODE_H) $(SYSTEM_H) coretypes.h $(TM_H)\n TREE_INLINE_H = tree-inline.h $(GIMPLE_H)\n REAL_H = real.h $(MACHMODE_H)\n IRA_INT_H = ira.h ira-int.h $(CFGLOOP_H) alloc-pool.h\n@@ -1403,7 +1402,6 @@ OBJS-common = \\\n \tvalue-prof.o \\\n \tvar-tracking.o \\\n \tvarasm.o \\\n-\tvarray.o \\\n \tvec.o \\\n \tversion.o \\\n \tvmsdbgout.o \\\n@@ -2180,7 +2178,7 @@ endif\n \t-DBUGURL=$(BUGURL_s) -c $(srcdir)/version.c $(OUTPUT_OPTION)\n \n gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-\t$(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) $(OBSTACK_H) $(BITMAP_H) \\\n+\t$(HASHTAB_H) $(SPLAY_TREE_H) $(OBSTACK_H) $(BITMAP_H) \\\n \t$(INPUT_H) $(TREE_H) $(RTL_H) $(FUNCTION_H) insn-config.h $(EXPR_H) \\\n \thard-reg-set.h $(BASIC_BLOCK_H) cselib.h $(INSN_ADDR_H) $(OPTABS_H) \\\n \tlibfuncs.h debug.h $(GGC_H) $(CGRAPH_H) $(TREE_FLOW_H) reload.h \\\n@@ -2285,7 +2283,7 @@ stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n tree-ssa-structalias.o: tree-ssa-structalias.c \\\n    $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(GGC_H) $(OBSTACK_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(RTL_H) $(TM_P_H) hard-reg-set.h $(BASIC_BLOCK_H) output.h \\\n-   $(DIAGNOSTIC_H) $(TOPLEV_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) varray.h \\\n+   $(DIAGNOSTIC_H) $(TOPLEV_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) \\\n    $(GIMPLE_H) $(HASHTAB_H) $(FUNCTION_H) $(CGRAPH_H) \\\n    $(TREE_PASS_H) $(TIMEVAR_H) alloc-pool.h $(SPLAY_TREE_H) $(PARAMS_H) \\\n    gt-tree-ssa-structalias.h $(CGRAPH_H) $(ALIAS_H) pointer-set.h\n@@ -2560,7 +2558,7 @@ tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) \\\n    $(TM_H) coretypes.h\n omega.o : omega.c omega.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(GGC_H) $(TREE_H) $(DIAGNOSTIC_H) varray.h $(TREE_PASS_H) $(PARAMS_H)\n+   $(GGC_H) $(TREE_H) $(DIAGNOSTIC_H) $(TREE_PASS_H) $(PARAMS_H)\n tree-chrec.o: tree-chrec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GGC_H) $(TREE_H) $(REAL_H) $(SCEV_H) $(TREE_PASS_H) $(PARAMS_H) \\\n    $(DIAGNOSTIC_H) $(CFGLOOP_H) $(TREE_FLOW_H) $(FLAGS_H)\n@@ -2710,7 +2708,7 @@ diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n opts.o : opts.c opts.h options.h $(TOPLEV_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_H) $(TM_H) langhooks.h $(GGC_H) $(EXPR_H) $(RTL_H) \\\n    output.h $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h $(TARGET_H) \\\n-   $(FLAGS_H) $(PARAMS_H) $(TREE_PASS_H) $(DBGCNT_H) debug.h varray.h \\\n+   $(FLAGS_H) $(PARAMS_H) $(TREE_PASS_H) $(DBGCNT_H) debug.h \\\n    $(PLUGIN_H) $(EXCEPT_H)\n opts-common.o : opts-common.c opts.h $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h intl.h\n@@ -2736,7 +2734,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) $(CFGLOOP_H) hosthooks.h \\\n    $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h $(GGC_H) $(INTEGRATE_H) \\\n    opts.h params.def tree-mudflap.h $(REAL_H) $(TREE_PASS_H) $(GIMPLE_H) \\\n-   tree-ssa-alias.h $(PLUGIN_H) $(VARRAY_H)\n+   tree-ssa-alias.h $(PLUGIN_H)\n \t$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \\\n \t  -DTARGET_NAME=\\\"$(target_noncanonical)\\\" \\\n \t  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)\n@@ -2763,7 +2761,7 @@ host-default.o : host-default.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \n rtl-error.o: rtl-error.c $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(INSN_ATTR_H) insn-config.h $(INPUT_H) $(TOPLEV_H) intl.h $(DIAGNOSTIC_H) \\\n-   $(CONFIG_H) varray.h\n+   $(CONFIG_H)\n \n rtl.o : rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n   $(GGC_H) $(BCONFIG_H) insn-notes.def reg-notes.def $(TOPLEV_H) $(REAL_H)\n@@ -2840,7 +2838,7 @@ debug.o : debug.c debug.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\n sdbout.o : sdbout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) debug.h \\\n    $(TREE_H) $(GGC_H) $(RTL_H) $(REGS_H) $(FLAGS_H) insn-config.h \\\n    output.h $(TOPLEV_H) $(TM_P_H) gsyms.h langhooks.h $(TARGET_H) sdbout.h \\\n-   gt-sdbout.h reload.h $(VARRAY_H)\n+   gt-sdbout.h reload.h\n dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) version.h $(RTL_H) $(DWARF2_H) debug.h $(FLAGS_H) insn-config.h \\\n    output.h $(DIAGNOSTIC_H) $(REAL_H) hard-reg-set.h $(REGS_H) $(EXPR_H) \\\n@@ -3147,8 +3145,6 @@ reginfo.o : reginfo.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TARGET_H) $(TREE_PASS_H) $(DF_H) ira.h\n bitmap.o : bitmap.c $(CONFIG_H) $(SYSTEM_H)  coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(GGC_H) gt-bitmap.h $(BITMAP_H) $(OBSTACK_H) $(HASHTAB_H)\n-varray.o : varray.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n-   $(HASHTAB_H) $(BCONFIG_H) $(VARRAY_H) $(TOPLEV_H)\n vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h vec.h $(GGC_H) \\\n    $(TOPLEV_H) $(HASHTAB_H)\n reload.o : reload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n@@ -3583,7 +3579,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) $(srcdir)/bitmap.h \\\n   $(srcdir)/alias.h $(srcdir)/coverage.c $(srcdir)/rtl.h \\\n   $(srcdir)/vecprim.h \\\n-  $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/varray.h $(srcdir)/libfuncs.h $(SYMTAB_H) \\\n+  $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/libfuncs.h $(SYMTAB_H) \\\n   $(srcdir)/real.h $(srcdir)/function.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \\\n   $(srcdir)/fixed-value.h \\\n   $(srcdir)/ipa-reference.h $(srcdir)/output.h $(srcdir)/cfgloop.h \\"}, {"sha": "66b4105fb7e062edeb59ef7059edd68ab6b89bc9", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6feb7966a779c2b681dff6a5f261be2f8574125/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6feb7966a779c2b681dff6a5f261be2f8574125/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=b6feb7966a779c2b681dff6a5f261be2f8574125", "patch": "@@ -1564,7 +1564,7 @@ open_base_files (void)\n   {\n     /* The order of files here matters very much.  */\n     static const char *const ifiles [] = {\n-      \"config.h\", \"system.h\", \"coretypes.h\", \"tm.h\", \"varray.h\",\n+      \"config.h\", \"system.h\", \"coretypes.h\", \"tm.h\",\n       \"hashtab.h\", \"splay-tree.h\",  \"obstack.h\", \"bitmap.h\", \"input.h\",\n       \"tree.h\", \"rtl.h\", \"function.h\", \"insn-config.h\", \"expr.h\",\n       \"hard-reg-set.h\", \"basic-block.h\", \"cselib.h\", \"insn-addr.h\","}, {"sha": "87a00b4a61e1a102e279e4578b3dd9c383576acb", "filename": "gcc/sdbout.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6feb7966a779c2b681dff6a5f261be2f8574125/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6feb7966a779c2b681dff6a5f261be2f8574125/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=b6feb7966a779c2b681dff6a5f261be2f8574125", "patch": "@@ -48,7 +48,7 @@ AT&T C compiler.  From the example below I would conclude the following:\n #include \"debug.h\"\n #include \"tree.h\"\n #include \"ggc.h\"\n-#include \"varray.h\"\n+#include \"vec.h\"\n \n static GTY(()) tree anonymous_types;\n \n@@ -58,7 +58,7 @@ static GTY(()) int unnamed_struct_number;\n \n /* Declarations whose debug info was deferred till end of compilation.  */\n \n-static GTY(()) varray_type deferred_global_decls;\n+static GTY(()) VEC(tree,gc) *deferred_global_decls;\n \n /* The C front end may call sdbout_symbol before sdbout_init runs.\n    We save all such decls in this list and output them when we get\n@@ -1464,7 +1464,7 @@ sdbout_global_decl (tree decl)\n       if (!DECL_INITIAL (decl) || !TREE_PUBLIC (decl))\n \tsdbout_symbol (decl, 0);\n       else\n-\tVARRAY_PUSH_TREE (deferred_global_decls, decl);\n+\tVEC_safe_push (tree, gc, deferred_global_decls, decl);\n \n       /* Output COFF information for non-global file-scope initialized\n \t variables.  */\n@@ -1480,9 +1480,10 @@ static void\n sdbout_finish (const char *main_filename ATTRIBUTE_UNUSED)\n {\n   size_t i;\n+  tree decl;\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (deferred_global_decls); i++)\n-    sdbout_symbol (VARRAY_TREE (deferred_global_decls, i), 0);\n+  for (i = 0; VEC_iterate (tree, deferred_global_decls, i, decl); i++)\n+    sdbout_symbol (decl, 0);\n }\n \n /* Describe the beginning of an internal block within a function.\n@@ -1689,7 +1690,7 @@ sdbout_init (const char *input_file_name ATTRIBUTE_UNUSED)\n   current_file->name = input_file_name;\n #endif\n \n-  VARRAY_TREE_INIT (deferred_global_decls, 12, \"deferred_global_decls\");\n+  deferred_global_decls = VEC_alloc (tree, gc, 12);\n \n   /* Emit debug information which was queued by sdbout_symbol before\n      we got here.  */"}, {"sha": "b62380b4f40823d116b9d3a268dee0e008993482", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6feb7966a779c2b681dff6a5f261be2f8574125/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6feb7966a779c2b681dff6a5f261be2f8574125/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b6feb7966a779c2b681dff6a5f261be2f8574125", "patch": "@@ -86,7 +86,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"tree-ssa-alias.h\"\n #include \"plugin.h\"\n-#include \"varray.h\"\n \n #if defined (DWARF2_UNWIND_INFO) || defined (DWARF2_DEBUGGING_INFO)\n #include \"dwarf2out.h\"\n@@ -2348,7 +2347,6 @@ dump_memory_report (bool final)\n   dump_tree_statistics ();\n   dump_gimple_statistics ();\n   dump_rtx_statistics ();\n-  dump_varray_statistics ();\n   dump_alloc_pool_statistics ();\n   dump_bitmap_statistics ();\n   dump_vec_loc_statistics ();"}, {"sha": "91e5b5d588a0deb0ce32b12ccee9a9aaded85c24", "filename": "gcc/varray.c", "status": "removed", "additions": 0, "deletions": 263, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05575e078047eec2ec0730ffd9f2f99f344c3f35/gcc%2Fvarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05575e078047eec2ec0730ffd9f2f99f344c3f35/gcc%2Fvarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.c?ref=05575e078047eec2ec0730ffd9f2f99f344c3f35", "patch": "@@ -1,263 +0,0 @@\n-/* Virtual array support.\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2007, 2008\n-   Free Software Foundation, Inc.\n-   Contributed by Cygnus Solutions.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"toplev.h\"\n-#include \"varray.h\"\n-#include \"ggc.h\"\n-#include \"hashtab.h\"\n-\n-#define VARRAY_HDR_SIZE (sizeof (struct varray_head_tag) - sizeof (varray_data))\n-\n-#ifdef GATHER_STATISTICS\n-\n-/* Store information about each particular varray.  */\n-struct varray_descriptor\n-{\n-  const char *name;\n-  int allocated;\n-  int created;\n-  int resized;\n-  int copied;\n-};\n-\n-/* Hashtable mapping varray names to descriptors.  */\n-static htab_t varray_hash;\n-\n-/* Hashtable helpers.  */\n-static hashval_t\n-hash_descriptor (const void *p)\n-{\n-  const struct varray_descriptor *d = (const struct varray_descriptor *) p;\n-  return htab_hash_pointer (d->name);\n-}\n-static int\n-eq_descriptor (const void *p1, const void *p2)\n-{\n-  const struct varray_descriptor *d = (const struct varray_descriptor *) p1;\n-  return d->name == p2;\n-}\n-\n-/* For given name, return descriptor, create new if needed.  */\n-static struct varray_descriptor *\n-varray_descriptor (const char *name)\n-{\n-  struct varray_descriptor **slot;\n-\n-  if (!varray_hash)\n-    varray_hash = htab_create (10, hash_descriptor, eq_descriptor, NULL);\n-\n-  slot = (struct varray_descriptor **)\n-    htab_find_slot_with_hash (varray_hash, name,\n-\t\t    \t      htab_hash_pointer (name),\n-\t\t\t      INSERT);\n-  if (*slot)\n-    return *slot;\n-  *slot = XCNEW (struct varray_descriptor);\n-  (*slot)->name = name;\n-  return *slot;\n-}\n-#endif\n-\n-/* Do not add any more non-GC items here.  Please either remove or GC\n-   those items that are not GCed.  */\n-\n-static const struct {\n-  unsigned char size;\n-  bool uses_ggc;\n-} element[NUM_VARRAY_DATA] = {\n-  { sizeof (char), 1 },\n-  { sizeof (unsigned char), 1 },\n-  { sizeof (short), 1 },\n-  { sizeof (unsigned short), 1 },\n-  { sizeof (int), 1 },\n-  { sizeof (unsigned int), 1 },\n-  { sizeof (long), 1 },\n-  { sizeof (unsigned long), 1 },\n-  { sizeof (HOST_WIDE_INT), 1 },\n-  { sizeof (unsigned HOST_WIDE_INT), 1 },\n-  { sizeof (void *), 1 },\n-  { sizeof (void *), 0 },\n-  { sizeof (char *), 1 },\n-  { sizeof (struct rtx_def *), 1 },\n-  { sizeof (struct rtvec_def *), 1 },\n-  { sizeof (union tree_node *), 1 },\n-  { sizeof (struct bitmap_head_def *), 1 },\n-  { sizeof (struct reg_info_def *), 0 },\n-  { sizeof (struct basic_block_def *), 1 },\n-  { sizeof (struct elt_list *), 1 },\n-  { sizeof (struct edge_def *), 1 },\n-  { sizeof (tree *), 1 },\n-};\n-\n-/* Allocate a virtual array with NUM_ELEMENT elements, each of which is\n-   ELEMENT_SIZE bytes long, named NAME.  Array elements are zeroed.  */\n-varray_type\n-varray_init (size_t num_elements, enum varray_data_enum element_kind,\n-\t     const char *name)\n-{\n-  size_t data_size = num_elements * element[element_kind].size;\n-  varray_type ptr;\n-#ifdef GATHER_STATISTICS\n-  struct varray_descriptor *desc = varray_descriptor (name);\n-\n-  desc->created++;\n-  desc->allocated += data_size + VARRAY_HDR_SIZE;\n-#endif\n-  if (element[element_kind].uses_ggc)\n-    ptr = GGC_CNEWVAR (struct varray_head_tag, VARRAY_HDR_SIZE + data_size);\n-  else\n-    ptr = XCNEWVAR (struct varray_head_tag, VARRAY_HDR_SIZE + data_size);\n-\n-  ptr->num_elements = num_elements;\n-  ptr->elements_used = 0;\n-  ptr->type = element_kind;\n-  ptr->name = name;\n-  return ptr;\n-}\n-\n-/* Grow/shrink the virtual array VA to N elements.  Zero any new elements\n-   allocated.  */\n-varray_type\n-varray_grow (varray_type va, size_t n)\n-{\n-  size_t old_elements = va->num_elements;\n-  if (n != old_elements)\n-    {\n-      size_t elem_size = element[va->type].size;\n-      size_t old_data_size = old_elements * elem_size;\n-      size_t data_size = n * elem_size;\n-#ifdef GATHER_STATISTICS\n-      struct varray_descriptor *desc = varray_descriptor (va->name);\n-      varray_type oldva = va;\n-\n-      if (data_size > old_data_size)\n-        desc->allocated += data_size - old_data_size;\n-      desc->resized ++;\n-#endif\n-\n-\n-      if (element[va->type].uses_ggc)\n-\tva = GGC_RESIZEVAR (struct varray_head_tag, va,\n-\t\t\t    VARRAY_HDR_SIZE + data_size);\n-      else\n-\tva = XRESIZEVAR (struct varray_head_tag, va,\n-\t\t\t VARRAY_HDR_SIZE + data_size);\n-      va->num_elements = n;\n-      if (n > old_elements)\n-\tmemset (&va->data.vdt_c[old_data_size], 0, data_size - old_data_size);\n-#ifdef GATHER_STATISTICS\n-      if (oldva != va)\n-        desc->copied++;\n-#endif\n-    }\n-\n-  return va;\n-}\n-\n-/* Reset a varray to its original state.  */\n-void\n-varray_clear (varray_type va)\n-{\n-  size_t data_size = element[va->type].size * va->num_elements;\n-\n-  memset (va->data.vdt_c, 0, data_size);\n-  va->elements_used = 0;\n-}\n-\n-/* Check the bounds of a varray access.  */\n-\n-#if defined ENABLE_CHECKING && (GCC_VERSION >= 2007)\n-\n-void\n-varray_check_failed (varray_type va, size_t n, const char *file, int line,\n-\t\t     const char *function)\n-{\n-  internal_error (\"virtual array %s[%lu]: element %lu out of bounds \"\n-\t\t  \"in %s, at %s:%d\",\n-\t\t  va->name, (unsigned long) va->num_elements, (unsigned long) n,\n-\t\t  function, trim_filename (file), line);\n-}\n-\n-void\n-varray_underflow (varray_type va, const char *file, int line,\n-\t\t  const char *function)\n-{\n-  internal_error (\"underflowed virtual array %s in %s, at %s:%d\",\n-\t\t  va->name, function, trim_filename (file), line);\n-}\n-\n-#endif\n-\n-\n-/* Output per-varray statistics.  */\n-#ifdef GATHER_STATISTICS\n-\n-/* Used to accumulate statistics about varray sizes.  */\n-struct output_info\n-{\n-  int count;\n-  int size;\n-};\n-\n-/* Called via htab_traverse.  Output varray descriptor pointed out by SLOT\n-   and update statistics.  */\n-static int\n-print_statistics (void **slot, void *b)\n-{\n-  struct varray_descriptor *d = (struct varray_descriptor *) *slot;\n-  struct output_info *i = (struct output_info *) b;\n-\n-  if (d->allocated)\n-    {\n-      fprintf (stderr, \"%-21s %6d %10d %7d %7d\\n\", d->name,\n-\t       d->created, d->allocated, d->resized, d->copied);\n-      i->size += d->allocated;\n-      i->count += d->created;\n-    }\n-  return 1;\n-}\n-#endif\n-\n-/* Output per-varray memory usage statistics.  */\n-void\n-dump_varray_statistics (void)\n-{\n-#ifdef GATHER_STATISTICS\n-  struct output_info info;\n-\n-  if (varray_hash)\n-    {\n-      fprintf (stderr, \"\\nVARRAY Kind            Count      Bytes  Resized copied\\n\");\n-      fprintf (stderr, \"-------------------------------------------------------\\n\");\n-      info.count = 0;\n-      info.size = 0;\n-      htab_traverse (varray_hash, print_statistics, &info);\n-      fprintf (stderr, \"-------------------------------------------------------\\n\");\n-      fprintf (stderr, \"%-20s %7d %10d\\n\",\n-\t       \"Total\", info.count, info.size);\n-      fprintf (stderr, \"-------------------------------------------------------\\n\");\n-   }\n-#endif\n-}"}, {"sha": "fbccde34d261cc669dbb6620d55da9babed4f09c", "filename": "gcc/varray.h", "status": "removed", "additions": 0, "deletions": 323, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05575e078047eec2ec0730ffd9f2f99f344c3f35/gcc%2Fvarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05575e078047eec2ec0730ffd9f2f99f344c3f35/gcc%2Fvarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.h?ref=05575e078047eec2ec0730ffd9f2f99f344c3f35", "patch": "@@ -1,323 +0,0 @@\n-/* Virtual array support.\n-   Copyright (C) 1998, 1999, 2000, 2002, 2003, 2004, 2007\n-   Free Software Foundation, Inc.\n-   Contributed by Cygnus Solutions.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_VARRAY_H\n-#define GCC_VARRAY_H\n-\n-#ifndef HOST_WIDE_INT\n-#include \"machmode.h\"\n-#endif\n-\n-#ifndef GCC_SYSTEM_H\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#endif\n-\n-/* Enum indicating what the varray contains.\n-   If this is changed, `element' in varray.c needs to be updated.  */\n-\n-enum varray_data_enum {\n-  VARRAY_DATA_C,\n-  VARRAY_DATA_UC,\n-  VARRAY_DATA_S,\n-  VARRAY_DATA_US,\n-  VARRAY_DATA_I,\n-  VARRAY_DATA_U,\n-  VARRAY_DATA_L,\n-  VARRAY_DATA_UL,\n-  VARRAY_DATA_HINT,\n-  VARRAY_DATA_UHINT,\n-  VARRAY_DATA_GENERIC,\n-  VARRAY_DATA_GENERIC_NOGC,\n-  VARRAY_DATA_CPTR,\n-  VARRAY_DATA_RTX,\n-  VARRAY_DATA_RTVEC,\n-  VARRAY_DATA_TREE,\n-  VARRAY_DATA_BITMAP,\n-  VARRAY_DATA_REG,\n-  VARRAY_DATA_BB,\n-  VARRAY_DATA_TE,\n-  VARRAY_DATA_EDGE,\n-  VARRAY_DATA_TREE_PTR,\n-  NUM_VARRAY_DATA\n-};\n-\n-/* Union of various array types that are used.  */\n-typedef union GTY (()) varray_data_tag {\n-  char\t\t\t  GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_C\")))\t\tvdt_c[1];\n-  unsigned char\t\t  GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_UC\")))\tvdt_uc[1];\n-  short\t\t\t  GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_S\")))\t\tvdt_s[1];\n-  unsigned short\t  GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_US\")))\tvdt_us[1];\n-  int\t\t\t  GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_I\")))\t\tvdt_i[1];\n-  unsigned int\t\t  GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_U\")))\t\tvdt_u[1];\n-  long\t\t\t  GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_L\")))\t\tvdt_l[1];\n-  unsigned long\t\t  GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_UL\")))\tvdt_ul[1];\n-  HOST_WIDE_INT\t\t  GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_HINT\")))\tvdt_hint[1];\n-  unsigned HOST_WIDE_INT  GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_UHINT\")))\tvdt_uhint[1];\n-  PTR\t\t\t  GTY ((length (\"%0.num_elements\"), use_param,\n-\t\t\t\ttag (\"VARRAY_DATA_GENERIC\")))\tvdt_generic[1];\n-  PTR\t\t\t  GTY ((length (\"%0.num_elements\"), skip (\"\"),\n-\t\t\t\ttag (\"VARRAY_DATA_GENERIC_NOGC\")))\tvdt_generic_nogc[1];\n-  char\t\t\t *GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_CPTR\")))\tvdt_cptr[1];\n-  rtx\t\t\t  GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_RTX\")))\tvdt_rtx[1];\n-  rtvec\t\t\t  GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_RTVEC\")))\tvdt_rtvec[1];\n-  tree\t\t\t  GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_TREE\")))\tvdt_tree[1];\n-  struct bitmap_head_def *GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_BITMAP\")))\tvdt_bitmap[1];\n-  struct reg_info_def\t *GTY ((length (\"%0.num_elements\"), skip,\n-\t\t\t\ttag (\"VARRAY_DATA_REG\")))\tvdt_reg[1];\n-  struct basic_block_def *GTY ((length (\"%0.num_elements\"), skip,\n-\t\t\t\ttag (\"VARRAY_DATA_BB\")))\tvdt_bb[1];\n-  struct elt_list\t *GTY ((length (\"%0.num_elements\"),\n-\t\t\t\ttag (\"VARRAY_DATA_TE\")))\tvdt_te[1];\n-  struct edge_def        *GTY ((length (\"%0.num_elements\"),\n-\t                        tag (\"VARRAY_DATA_EDGE\")))\tvdt_e[1];\n-  tree                   *GTY ((length (\"%0.num_elements\"), skip (\"\"),\n-\t                        tag (\"VARRAY_DATA_TREE_PTR\")))\tvdt_tp[1];\n-} varray_data;\n-\n-/* Virtual array of pointers header.  */\n-struct GTY(()) varray_head_tag {\n-  size_t\tnum_elements;\t/* Maximum element number allocated.  */\n-  size_t        elements_used;  /* The number of elements used, if\n-\t\t\t\t   using VARRAY_PUSH/VARRAY_POP.  */\n-  enum varray_data_enum type;\t/* The kind of elements in the varray.  */\n-  const char   *name;\t\t/* name of the varray for reporting errors */\n-  varray_data\tGTY ((desc (\"%0.type\"))) data;\t/* The data elements follow,\n-\t\t\t\t\t\t   must be last.  */\n-};\n-typedef struct varray_head_tag *varray_type;\n-\n-/* Allocate a virtual array with NUM elements, each of which is SIZE bytes\n-   long, named NAME.  Array elements are zeroed.  */\n-extern varray_type varray_init (size_t, enum varray_data_enum, const char *);\n-\n-#define VARRAY_CHAR_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_C, name)\n-\n-#define VARRAY_UCHAR_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_UC, name)\n-\n-#define VARRAY_SHORT_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_S, name)\n-\n-#define VARRAY_USHORT_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_US, name)\n-\n-#define VARRAY_INT_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_I, name)\n-\n-#define VARRAY_UINT_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_U, name)\n-\n-#define VARRAY_LONG_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_L, name)\n-\n-#define VARRAY_ULONG_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_UL, name)\n-\n-#define VARRAY_WIDE_INT_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_HINT, name)\n-\n-#define VARRAY_UWIDE_INT_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_UHINT, name)\n-\n-#define VARRAY_GENERIC_PTR_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_GENERIC, name)\n-\n-#define VARRAY_GENERIC_PTR_NOGC_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_GENERIC_NOGC, name)\n-\n-#define VARRAY_CHAR_PTR_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_CPTR, name)\n-\n-#define VARRAY_RTX_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_RTX, name)\n-\n-#define VARRAY_RTVEC_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_RTVEC, name)\n-\n-#define VARRAY_TREE_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_TREE, name)\n-\n-#define VARRAY_BITMAP_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_BITMAP, name)\n-\n-#define VARRAY_REG_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_REG, name)\n-\n-#define VARRAY_BB_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_BB, name)\n-\n-#define VARRAY_ELT_LIST_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_TE, name)\n-\n-#define VARRAY_EDGE_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_EDGE, name)\n-\n-#define VARRAY_TREE_PTR_INIT(va, num, name) \\\n-  va = varray_init (num, VARRAY_DATA_TREE_PTR, name)\n-\n-/* Free up memory allocated by the virtual array, but do not free any of the\n-   elements involved.  */\n-#define VARRAY_FREE(vp) \\\n-  do { if (vp) { free (vp); vp = (varray_type) 0; } } while (0)\n-\n-/* Grow/shrink the virtual array VA to N elements.  */\n-extern varray_type varray_grow (varray_type, size_t);\n-\n-#define VARRAY_GROW(VA, N) ((VA) = varray_grow (VA, N))\n-\n-#define VARRAY_SIZE(VA)\t((VA)->num_elements)\n-\n-#define VARRAY_ACTIVE_SIZE(VA)\t((VA)->elements_used)\n-#define VARRAY_POP_ALL(VA)\t((VA)->elements_used = 0)\n-\n-#define VARRAY_CLEAR(VA) varray_clear(VA)\n-\n-extern void varray_clear (varray_type);\n-extern void dump_varray_statistics (void);\n-\n-/* Check for VARRAY_xxx macros being in bound.  */\n-#if defined ENABLE_CHECKING && (GCC_VERSION >= 2007)\n-extern void varray_check_failed (varray_type, size_t, const char *, int,\n-\t\t\t\t const char *) ATTRIBUTE_NORETURN;\n-extern void varray_underflow (varray_type, const char *, int, const char *)\n-     ATTRIBUTE_NORETURN;\n-#define VARRAY_CHECK(VA, N, T) __extension__\t\t\t\\\n-(*({ varray_type const _va = (VA);\t\t\t\t\\\n-     const size_t _n = (N);\t\t\t\t\t\\\n-     if (_n >= _va->num_elements)\t\t\t\t\\\n-       varray_check_failed (_va, _n, __FILE__, __LINE__, __FUNCTION__);\t\\\n-     &_va->data.T[_n]; }))\n-\n-#define VARRAY_POP(VA) do {\t\t\t\t\t\\\n-  varray_type const _va = (VA);\t\t\t\t\t\\\n-  if (_va->elements_used == 0)\t\t\t\t\t\\\n-    varray_underflow (_va, __FILE__, __LINE__, __FUNCTION__);\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    _va->elements_used--;\t\t\t\t\t\\\n-} while (0)\n-\n-#else\n-#define VARRAY_CHECK(VA, N, T) ((VA)->data.T[N])\n-/* Pop the top element of VA.  */\n-#define VARRAY_POP(VA) do { ((VA)->elements_used--); } while (0)\n-#endif\n-\n-/* Push X onto VA.  T is the name of the field in varray_data\n-   corresponding to the type of X.  */\n-#define VARRAY_PUSH(VA, T, X)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if ((VA)->elements_used >= (VA)->num_elements)\t\\\n-        VARRAY_GROW ((VA), 2 * (VA)->num_elements);\t\\\n-      (VA)->data.T[(VA)->elements_used++] = (X);\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define VARRAY_CHAR(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_c)\n-#define VARRAY_UCHAR(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_uc)\n-#define VARRAY_SHORT(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_s)\n-#define VARRAY_USHORT(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_us)\n-#define VARRAY_INT(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_i)\n-#define VARRAY_UINT(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_u)\n-#define VARRAY_LONG(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_l)\n-#define VARRAY_ULONG(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_ul)\n-#define VARRAY_WIDE_INT(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_hint)\n-#define VARRAY_UWIDE_INT(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_uhint)\n-#define VARRAY_GENERIC_PTR(VA,N)\tVARRAY_CHECK (VA, N, vdt_generic)\n-#define VARRAY_GENERIC_PTR_NOGC(VA,N)\tVARRAY_CHECK (VA, N, vdt_generic_nogc)\n-#define VARRAY_CHAR_PTR(VA,N)\t\tVARRAY_CHECK (VA, N, vdt_cptr)\n-#define VARRAY_RTX(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_rtx)\n-#define VARRAY_RTVEC(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_rtvec)\n-#define VARRAY_TREE(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_tree)\n-#define VARRAY_BITMAP(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_bitmap)\n-#define VARRAY_REG(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_reg)\n-#define VARRAY_BB(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_bb)\n-#define VARRAY_ELT_LIST(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_te)\n-#define VARRAY_EDGE(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_e)\n-#define VARRAY_TREE_PTR(VA, N)\t\tVARRAY_CHECK (VA, N, vdt_tp)\n-\n-/* Push a new element on the end of VA, extending it if necessary.  */\n-#define VARRAY_PUSH_CHAR(VA, X)\t\tVARRAY_PUSH (VA, vdt_c, X)\n-#define VARRAY_PUSH_UCHAR(VA, X)\tVARRAY_PUSH (VA, vdt_uc, X)\n-#define VARRAY_PUSH_SHORT(VA, X)\tVARRAY_PUSH (VA, vdt_s, X)\n-#define VARRAY_PUSH_USHORT(VA, X)\tVARRAY_PUSH (VA, vdt_us, X)\n-#define VARRAY_PUSH_INT(VA, X)\t\tVARRAY_PUSH (VA, vdt_i, X)\n-#define VARRAY_PUSH_UINT(VA, X)\t\tVARRAY_PUSH (VA, vdt_u, X)\n-#define VARRAY_PUSH_LONG(VA, X)\t\tVARRAY_PUSH (VA, vdt_l, X)\n-#define VARRAY_PUSH_ULONG(VA, X)\tVARRAY_PUSH (VA, vdt_ul, X)\n-#define VARRAY_PUSH_WIDE_INT(VA, X)\tVARRAY_PUSH (VA, vdt_hint, X)\n-#define VARRAY_PUSH_UWIDE_INT(VA, X)\tVARRAY_PUSH (VA, vdt_uhint, X)\n-#define VARRAY_PUSH_GENERIC_PTR(VA, X)\tVARRAY_PUSH (VA, vdt_generic, X)\n-#define VARRAY_PUSH_GENERIC_PTR_NOGC(VA, X)\tVARRAY_PUSH (VA, vdt_generic_nogc, X)\n-#define VARRAY_PUSH_CHAR_PTR(VA, X)\tVARRAY_PUSH (VA, vdt_cptr, X)\n-#define VARRAY_PUSH_RTX(VA, X)\t\tVARRAY_PUSH (VA, vdt_rtx, X)\n-#define VARRAY_PUSH_RTVEC(VA, X)\tVARRAY_PUSH (VA, vdt_rtvec, X)\n-#define VARRAY_PUSH_TREE(VA, X)\t\tVARRAY_PUSH (VA, vdt_tree, X)\n-#define VARRAY_PUSH_BITMAP(VA, X)\tVARRAY_PUSH (VA, vdt_bitmap, X)\n-#define VARRAY_PUSH_REG(VA, X)\t\tVARRAY_PUSH (VA, vdt_reg, X)\n-#define VARRAY_PUSH_BB(VA, X)\t\tVARRAY_PUSH (VA, vdt_bb, X)\n-#define VARRAY_PUSH_EDGE(VA, X)\t\tVARRAY_PUSH (VA, vdt_e, X)\n-#define VARRAY_PUSH_TREE_PTR(VA, X)\tVARRAY_PUSH (VA, vdt_tp, X)\n-\n-/* Return the last element of VA.  */\n-#define VARRAY_TOP(VA, T) VARRAY_CHECK(VA, (VA)->elements_used - 1, T)\n-\n-#define VARRAY_TOP_CHAR(VA)\t\tVARRAY_TOP (VA, vdt_c)\n-#define VARRAY_TOP_UCHAR(VA)\t        VARRAY_TOP (VA, vdt_uc)\n-#define VARRAY_TOP_SHORT(VA)\t        VARRAY_TOP (VA, vdt_s)\n-#define VARRAY_TOP_USHORT(VA)\t        VARRAY_TOP (VA, vdt_us)\n-#define VARRAY_TOP_INT(VA)\t\tVARRAY_TOP (VA, vdt_i)\n-#define VARRAY_TOP_UINT(VA)\t\tVARRAY_TOP (VA, vdt_u)\n-#define VARRAY_TOP_LONG(VA)\t\tVARRAY_TOP (VA, vdt_l)\n-#define VARRAY_TOP_ULONG(VA)\t        VARRAY_TOP (VA, vdt_ul)\n-#define VARRAY_TOP_WIDE_INT(VA)\t        VARRAY_TOP (VA, vdt_hint)\n-#define VARRAY_TOP_UWIDE_INT(VA)\tVARRAY_TOP (VA, vdt_uhint)\n-#define VARRAY_TOP_GENERIC_PTR(VA)\tVARRAY_TOP (VA, vdt_generic)\n-#define VARRAY_TOP_GENERIC_PTR_NOGC(VA)\tVARRAY_TOP (VA, vdt_generic_nogc)\n-#define VARRAY_TOP_CHAR_PTR(VA)\t\tVARRAY_TOP (VA, vdt_cptr)\n-#define VARRAY_TOP_RTX(VA)\t\tVARRAY_TOP (VA, vdt_rtx)\n-#define VARRAY_TOP_RTVEC(VA)\t        VARRAY_TOP (VA, vdt_rtvec)\n-#define VARRAY_TOP_TREE(VA)\t\tVARRAY_TOP (VA, vdt_tree)\n-#define VARRAY_TOP_BITMAP(VA)\t        VARRAY_TOP (VA, vdt_bitmap)\n-#define VARRAY_TOP_REG(VA)\t\tVARRAY_TOP (VA, vdt_reg)\n-#define VARRAY_TOP_BB(VA)\t\tVARRAY_TOP (VA, vdt_bb)\n-#define VARRAY_TOP_EDGE(VA)\t\tVARRAY_TOP (VA, vdt_e)\n-#define VARRAY_TOP_TREE_PTR(VA)\t\tVARRAY_TOP (VA, vdt_tp)\n-\n-#endif /* ! GCC_VARRAY_H */"}]}