{"sha": "acf41a74a832b7225d9e2b60e7294a7c750e9b97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNmNDFhNzRhODMyYjcyMjVkOWUyYjYwZTcyOTRhN2M3NTBlOWI5Nw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2012-04-12T12:53:17Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2012-04-12T12:53:17Z"}, "message": "dbgcnt.def (ira_move): New counter.\n\n\t* dbgcnt.def (ira_move): New counter.\n\t* ira-int.h (ira_create_new_reg): Declare function.\n\t(first_moveable_pseudo, last_moveable_pseudo): Declare variables.\n\t* ira-emit.c (ira_create_new_reg): Renamed from craete_new_reg and\n\tno longer static.  All callers changed.\n\t* ira.c: Include \"dbgcnt.h\".\n\t(rtx_moveable_p, insn_dominated_by_p, find_moveable_pseudos,\n\tmove_unallocated_pseudos): New static functions.\n\t(first_moveable_pseudo, last_moveable_pseudo): New global variables.\n\t(pseudo_replaced_reg, pseudo_move_insn): New static variables.\n\t(ira): Call find_moveable_pseudos and move_unallocated_pseudos.\n\t* ira-costs.c (find_costs_and_classes): Assign a memory cost of zero\n\tto the pseudos generated in find_moveable_pseudos.\n\t* Makefile.in (ira.o): Add $(DBGCNT_H).\n\nFrom-SVN: r186378", "tree": {"sha": "0875d59a520e21ddc21464bbfcc6747bc4161359", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0875d59a520e21ddc21464bbfcc6747bc4161359"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acf41a74a832b7225d9e2b60e7294a7c750e9b97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acf41a74a832b7225d9e2b60e7294a7c750e9b97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acf41a74a832b7225d9e2b60e7294a7c750e9b97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acf41a74a832b7225d9e2b60e7294a7c750e9b97/comments", "author": null, "committer": null, "parents": [{"sha": "b9b09214978dd0f5000225f722ca18559c2564c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9b09214978dd0f5000225f722ca18559c2564c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9b09214978dd0f5000225f722ca18559c2564c7"}], "stats": {"total": 558, "additions": 550, "deletions": 8}, "files": [{"sha": "a1dad36b367407a62cb42f46c47cf670567c292e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=acf41a74a832b7225d9e2b60e7294a7c750e9b97", "patch": "@@ -1,3 +1,20 @@\n+2012-04-12  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* dbgcnt.def (ira_move): New counter.\n+\t* ira-int.h (ira_create_new_reg): Declare function.\n+\t(first_moveable_pseudo, last_moveable_pseudo): Declare variables.\n+\t* ira-emit.c (ira_create_new_reg): Renamed from craete_new_reg and\n+\tno longer static.  All callers changed.\n+\t* ira.c: Include \"dbgcnt.h\".\n+\t(rtx_moveable_p, insn_dominated_by_p, find_moveable_pseudos,\n+\tmove_unallocated_pseudos): New static functions.\n+\t(first_moveable_pseudo, last_moveable_pseudo): New global variables.\n+\t(pseudo_replaced_reg, pseudo_move_insn): New static variables.\n+\t(ira): Call find_moveable_pseudos and move_unallocated_pseudos.\n+\t* ira-costs.c (find_costs_and_classes): Assign a memory cost of zero\n+\tto the pseudos generated in find_moveable_pseudos.\n+\t* Makefile.in (ira.o): Add $(DBGCNT_H).\n+\n 2012-04-12  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/52943"}, {"sha": "408182a648ad6728b93184886a7788fcf595d2f9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=acf41a74a832b7225d9e2b60e7294a7c750e9b97", "patch": "@@ -3292,7 +3292,7 @@ ira-lives.o: ira-lives.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(DF_H) sparseset.h $(IRA_INT_H)\n ira.o: ira.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(REGS_H) $(RTL_H) $(TM_P_H) $(TARGET_H) $(FLAGS_H) $(OBSTACK_H) \\\n-   $(BITMAP_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n+   $(BITMAP_H) hard-reg-set.h $(BASIC_BLOCK_H) $(DBGCNT_H) \\\n    $(EXPR_H) $(RECOG_H) $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) output.h \\\n    $(EXCEPT_H) reload.h toplev.h $(DIAGNOSTIC_CORE_H) $(INTEGRATE_H) $(DF_H) $(GGC_H) $(IRA_INT_H)\n regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\"}, {"sha": "439f3e18a02cd34f91db6b9f5488088597a60554", "filename": "gcc/dbgcnt.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2Fdbgcnt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2Fdbgcnt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.def?ref=acf41a74a832b7225d9e2b60e7294a7c750e9b97", "patch": "@@ -184,3 +184,4 @@ DEBUG_COUNTER (sms_sched_loop)\n DEBUG_COUNTER (store_motion)\n DEBUG_COUNTER (split_for_sched2)\n DEBUG_COUNTER (tail_call)\n+DEBUG_COUNTER (ira_move)"}, {"sha": "1199763aeb377c36dcd34123894b1b6e6b4b4718", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=acf41a74a832b7225d9e2b60e7294a7c750e9b97", "patch": "@@ -1650,6 +1650,8 @@ find_costs_and_classes (FILE *dump_file)\n \t\t\tCOSTS (total_allocno_costs, parent_a_num)->mem_cost\n \t\t\t  += add_cost;\n \n+\t\t      if (i >= first_moveable_pseudo && i < last_moveable_pseudo)\n+\t\t\tCOSTS (total_allocno_costs, parent_a_num)->mem_cost = 0;\n \t\t    }\n \t\t  a_costs = COSTS (costs, a_num)->cost;\n \t\t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n@@ -1667,7 +1669,9 @@ find_costs_and_classes (FILE *dump_file)\n \t\t    i_mem_cost += add_cost;\n \t\t}\n \t    }\n-\t  if (equiv_savings < 0)\n+\t  if (i >= first_moveable_pseudo && i < last_moveable_pseudo)\n+\t    i_mem_cost = 0;\n+\t  else if (equiv_savings < 0)\n \t    i_mem_cost = -equiv_savings;\n \t  else if (equiv_savings > 0)\n \t    {"}, {"sha": "4523a8d41d9798bf035e3fcc102eb42cae6f1d88", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=acf41a74a832b7225d9e2b60e7294a7c750e9b97", "patch": "@@ -330,8 +330,8 @@ add_to_edge_list (edge e, move_t move, bool head_p)\n \n /* Create and return new pseudo-register with the same attributes as\n    ORIGINAL_REG.  */\n-static rtx\n-create_new_reg (rtx original_reg)\n+rtx\n+ira_create_new_reg (rtx original_reg)\n {\n   rtx new_reg;\n \n@@ -625,7 +625,7 @@ change_loop (ira_loop_tree_node_t node)\n \t\tfprintf (ira_dump_file, \"  %i vs parent %i:\",\n \t\t\t ALLOCNO_HARD_REGNO (allocno),\n \t\t\t ALLOCNO_HARD_REGNO (parent_allocno));\n-\t      set_allocno_reg (allocno, create_new_reg (original_reg));\n+\t      set_allocno_reg (allocno, ira_create_new_reg (original_reg));\n \t    }\n \t}\n     }\n@@ -646,7 +646,7 @@ change_loop (ira_loop_tree_node_t node)\n       if (! used_p)\n \tcontinue;\n       bitmap_set_bit (renamed_regno_bitmap, regno);\n-      set_allocno_reg (allocno, create_new_reg (allocno_emit_reg (allocno)));\n+      set_allocno_reg (allocno, ira_create_new_reg (allocno_emit_reg (allocno)));\n     }\n }\n \n@@ -852,7 +852,7 @@ modify_move_list (move_t list)\n \t\tALLOCNO_ASSIGNED_P (new_allocno) = true;\n \t\tALLOCNO_HARD_REGNO (new_allocno) = -1;\n \t\tALLOCNO_EMIT_DATA (new_allocno)->reg\n-\t\t  = create_new_reg (allocno_emit_reg (set_move->to));\n+\t\t  = ira_create_new_reg (allocno_emit_reg (set_move->to));\n \n \t\t/* Make it possibly conflicting with all earlier\n \t\t   created allocnos.  Cases where temporary allocnos"}, {"sha": "24976d0418cceefc3054190ca6a99bf2ac16e176", "filename": "gcc/ira-int.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=acf41a74a832b7225d9e2b60e7294a7c750e9b97", "patch": "@@ -1416,3 +1416,6 @@ ira_allocate_and_set_or_copy_costs (int **vec, enum reg_class aclass,\n \treg_costs[i] = val;\n     }\n }\n+\n+extern rtx ira_create_new_reg (rtx);\n+extern int first_moveable_pseudo, last_moveable_pseudo;"}, {"sha": "3b598e65064e744e4a9ffb4cbee0206278dcc257", "filename": "gcc/ira.c", "status": "modified", "additions": 518, "deletions": 1, "changes": 519, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acf41a74a832b7225d9e2b60e7294a7c750e9b97/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=acf41a74a832b7225d9e2b60e7294a7c750e9b97", "patch": "@@ -384,7 +384,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"ira-int.h\"\n #include \"dce.h\"\n-\n+#include \"dbgcnt.h\"\n \n struct target_ira default_target_ira;\n struct target_ira_int default_target_ira_int;\n@@ -3512,7 +3512,521 @@ build_insn_chain (void)\n   if (dump_file)\n     print_insn_chains (dump_file);\n }\n+ \f\n+/* Examine the rtx found in *LOC, which is read or written to as determined\n+   by TYPE.  Return false if we find a reason why an insn containing this\n+   rtx should not be moved (such as accesses to non-constant memory), true\n+   otherwise.  */\n+static bool\n+rtx_moveable_p (rtx *loc, enum op_type type)\n+{\n+  const char *fmt;\n+  rtx x = *loc;\n+  enum rtx_code code = GET_CODE (x);\n+  int i, j;\n+\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case CONST:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST_FIXED:\n+    case CONST_VECTOR:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return true;\n+\n+    case PC:\n+      return type == OP_IN;\n+\n+    case CC0:\n+      return false;\n+\n+    case REG:\n+      if (x == frame_pointer_rtx)\n+\treturn true;\n+      if (HARD_REGISTER_P (x))\n+\treturn false;\n+      \n+      return true;\n+\n+    case MEM:\n+      if (type == OP_IN && MEM_READONLY_P (x))\n+\treturn rtx_moveable_p (&XEXP (x, 0), OP_IN);\n+      return false;\n+\n+    case SET:\n+      return (rtx_moveable_p (&SET_SRC (x), OP_IN)\n+\t      && rtx_moveable_p (&SET_DEST (x), OP_OUT));\n+\n+    case STRICT_LOW_PART:\n+      return rtx_moveable_p (&XEXP (x, 0), OP_OUT);\n+\n+    case ZERO_EXTRACT:\n+    case SIGN_EXTRACT:\n+      return (rtx_moveable_p (&XEXP (x, 0), type)\n+\t      && rtx_moveable_p (&XEXP (x, 1), OP_IN)\n+\t      && rtx_moveable_p (&XEXP (x, 2), OP_IN));\n+\n+    case CLOBBER:\n+      return rtx_moveable_p (&SET_DEST (x), OP_OUT);\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (!rtx_moveable_p (&XEXP (x, i), type))\n+\t    return false;\n+\t}\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  {\n+\t    if (!rtx_moveable_p (&XVECEXP (x, i, j), type))\n+\t      return false;\n+\t  }\n+    }\n+  return true;\n+}\n+\n+/* A wrapper around dominated_by_p, which uses the information in UID_LUID\n+   to give dominance relationships between two insns I1 and I2.  */\n+static bool\n+insn_dominated_by_p (rtx i1, rtx i2, int *uid_luid)\n+{\n+  basic_block bb1 = BLOCK_FOR_INSN (i1);\n+  basic_block bb2 = BLOCK_FOR_INSN (i2);\n+\n+  if (bb1 == bb2)\n+    return uid_luid[INSN_UID (i2)] < uid_luid[INSN_UID (i1)];\n+  return dominated_by_p (CDI_DOMINATORS, bb1, bb2);\n+}\n+\n+/* Record the range of register numbers added by find_moveable_pseudos.  */\n+int first_moveable_pseudo, last_moveable_pseudo;\n+\n+/* These two vectors hold data for every register added by\n+   find_movable_pseudos, with index 0 holding data for the\n+   first_moveable_pseudo.  */\n+/* The original home register.  */\n+static VEC (rtx, heap) *pseudo_replaced_reg;\n+/* The move instruction we added to move the value to its original home\n+   register.  */\n+static VEC (rtx, heap) *pseudo_move_insn;\n+\n+/* Look for instances where we have an instruction that is known to increase\n+   register pressure, and whose result is not used immediately.  If it is\n+   possible to move the instruction downwards to just before its first use,\n+   split its lifetime into two ranges.  We create a new pseudo to compute the\n+   value, and emit a move instruction just before the first use.  If, after\n+   register allocation, the new pseudo remains unallocated, the function\n+   move_unallocated_pseudos then deletes the move instruction and places\n+   the computation just before the first use.\n+\n+   Such a move is safe and profitable if all the input registers remain live\n+   and unchanged between the original computation and its first use.  In such\n+   a situation, the computation is known to increase register pressure, and\n+   moving it is known to at least not worsen it.\n+\n+   We restrict moves to only those cases where a register remains unallocated,\n+   in order to avoid interfering too much with the instruction schedule.  As\n+   an exception, we may move insns which only modify their input register\n+   (typically induction variables), as this increases the freedom for our\n+   intended transformation, and does not limit the second instruction\n+   scheduler pass.  */\n+   \n+static void\n+find_moveable_pseudos (void)\n+{\n+  unsigned i;\n+  int max_regs = max_reg_num ();\n+  int max_uid = get_max_uid ();\n+  basic_block bb;\n+  int *uid_luid = XNEWVEC (int, max_uid);\n+  rtx *closest_uses = XNEWVEC (rtx, max_regs);\n+  /* A set of registers which are live but not modified throughout a block.  */\n+  bitmap_head *bb_transp_live = XNEWVEC (bitmap_head, last_basic_block);\n+  /* A set of registers which only exist in a given basic block.  */\n+  bitmap_head *bb_local = XNEWVEC (bitmap_head, last_basic_block);\n+  /* A set of registers which are set once, in an instruction that can be\n+     moved freely downwards, but are otherwise transparent to a block.  */\n+  bitmap_head *bb_moveable_reg_sets = XNEWVEC (bitmap_head, last_basic_block);\n+  bitmap_head live, used, set, interesting, unusable_as_input;\n+  bitmap_iterator bi;\n+  bitmap_initialize (&interesting, 0);\n+\n+  first_moveable_pseudo = max_regs;\n+  VEC_free (rtx, heap, pseudo_move_insn);\n+  VEC_free (rtx, heap, pseudo_replaced_reg);\n+  VEC_safe_grow (rtx, heap, pseudo_move_insn, max_regs);\n+  VEC_safe_grow (rtx, heap, pseudo_replaced_reg, max_regs);\n+\n+  df_analyze ();\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  i = 0;\n+  bitmap_initialize (&live, 0);\n+  bitmap_initialize (&used, 0);\n+  bitmap_initialize (&set, 0);\n+  bitmap_initialize (&unusable_as_input, 0);\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx insn;\n+      bitmap transp = bb_transp_live + bb->index;\n+      bitmap moveable = bb_moveable_reg_sets + bb->index;\n+      bitmap local = bb_local + bb->index;\n+\n+      bitmap_initialize (local, 0);\n+      bitmap_initialize (transp, 0);\n+      bitmap_initialize (moveable, 0);\n+      bitmap_copy (&live, df_get_live_out (bb));\n+      bitmap_and_into (&live, df_get_live_in (bb));\n+      bitmap_copy (transp, &live);\n+      bitmap_clear (moveable);\n+      bitmap_clear (&live);\n+      bitmap_clear (&used);\n+      bitmap_clear (&set);\n+      FOR_BB_INSNS (bb, insn)\n+\tif (NONDEBUG_INSN_P (insn))\n+\t  {\n+\t    df_ref *u_rec, *d_rec;\n+\n+\t    uid_luid[INSN_UID (insn)] = i++;\n+\t    \n+\t    u_rec = DF_INSN_USES (insn);\n+\t    d_rec = DF_INSN_DEFS (insn);\n+\t    if (d_rec[0] != NULL && d_rec[1] == NULL\n+\t\t&& u_rec[0] != NULL && u_rec[1] == NULL\n+\t\t&& DF_REF_REGNO (*u_rec) == DF_REF_REGNO (*d_rec)\n+\t\t&& !bitmap_bit_p (&set, DF_REF_REGNO (*u_rec))\n+\t\t&& rtx_moveable_p (&PATTERN (insn), OP_IN))\n+\t      {\n+\t\tunsigned regno = DF_REF_REGNO (*u_rec);\n+\t\tbitmap_set_bit (moveable, regno);\n+\t\tbitmap_set_bit (&set, regno);\n+\t\tbitmap_set_bit (&used, regno);\n+\t\tbitmap_clear_bit (transp, regno);\n+\t\tcontinue;\n+\t      }\n+\t    while (*u_rec)\n+\t      {\n+\t\tunsigned regno = DF_REF_REGNO (*u_rec);\n+\t\tbitmap_set_bit (&used, regno);\n+\t\tif (bitmap_clear_bit (moveable, regno))\n+\t\t  bitmap_clear_bit (transp, regno);\n+\t\tu_rec++;\n+\t      }\n+\n+\t    while (*d_rec)\n+\t      {\n+\t\tunsigned regno = DF_REF_REGNO (*d_rec);\n+\t\tbitmap_set_bit (&set, regno);\n+\t\tbitmap_clear_bit (transp, regno);\n+\t\tbitmap_clear_bit (moveable, regno);\n+\t\td_rec++;\n+\t      }\n+\t  }\n+    }\n+\n+  bitmap_clear (&live);\n+  bitmap_clear (&used);\n+  bitmap_clear (&set);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      bitmap local = bb_local + bb->index;\n+      rtx insn;\n+\n+      FOR_BB_INSNS (bb, insn)\n+\tif (NONDEBUG_INSN_P (insn))\n+\t  {\n+\t    rtx def_insn, closest_use, note;\n+\t    df_ref *def_rec, def, use;\n+\t    unsigned regno;\n+\t    bool all_dominated, all_local;\n+\t    enum machine_mode mode;\n+\n+\t    def_rec = DF_INSN_DEFS (insn);\n+\t    /* There must be exactly one def in this insn.  */\n+\t    def = *def_rec;\n+\t    if (!def || def_rec[1] || !single_set (insn))\n+\t      continue;\n+\t    /* This must be the only definition of the reg.  We also limit\n+\t       which modes we deal with so that we can assume we can generate\n+\t       move instructions.  */\n+\t    regno = DF_REF_REGNO (def);\n+\t    mode = GET_MODE (DF_REF_REG (def));\n+\t    if (DF_REG_DEF_COUNT (regno) != 1\n+\t\t|| !DF_REF_INSN_INFO (def)\n+\t\t|| HARD_REGISTER_NUM_P (regno)\n+\t\t|| (!INTEGRAL_MODE_P (mode) && !FLOAT_MODE_P (mode)))\n+\t      continue;\n+\t    def_insn = DF_REF_INSN (def);\n+\n+\t    for (note = REG_NOTES (def_insn); note; note = XEXP (note, 1))\n+\t      if (REG_NOTE_KIND (note) == REG_EQUIV && MEM_P (XEXP (note, 0)))\n+\t\tbreak;\n+\t\t\n+\t    if (note)\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"Ignoring reg %d, has equiv memory\\n\",\n+\t\t\t   regno);\n+\t\tbitmap_set_bit (&unusable_as_input, regno);\n+\t\tcontinue;\n+\t      }\n+\n+\t    use = DF_REG_USE_CHAIN (regno);\n+\t    all_dominated = true;\n+\t    all_local = true;\n+\t    closest_use = NULL_RTX;\n+\t    for (; use; use = DF_REF_NEXT_REG (use))\n+\t      {\n+\t\trtx insn;\n+\t\tif (!DF_REF_INSN_INFO (use))\n+\t\t  {\n+\t\t    all_dominated = false;\n+\t\t    all_local = false;\n+\t\t    break;\n+\t\t  }\n+\t\tinsn = DF_REF_INSN (use);\n+\t\tif (DEBUG_INSN_P (insn))\n+\t\t  continue;\n+\t\tif (BLOCK_FOR_INSN (insn) != BLOCK_FOR_INSN (def_insn))\n+\t\t  all_local = false;\n+\t\tif (!insn_dominated_by_p (insn, def_insn, uid_luid))\n+\t\t  all_dominated = false;\n+\t\tif (closest_use != insn && closest_use != const0_rtx)\n+\t\t  {\n+\t\t    if (closest_use == NULL_RTX)\n+\t\t      closest_use = insn;\n+\t\t    else if (insn_dominated_by_p (closest_use, insn, uid_luid))\n+\t\t      closest_use = insn;\n+\t\t    else if (!insn_dominated_by_p (insn, closest_use, uid_luid))\n+\t\t      closest_use = const0_rtx;\n+\t\t  }\n+\t      }\n+\t    if (!all_dominated)\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"Reg %d not all uses dominated by set\\n\",\n+\t\t\t   regno);\n+\t\tcontinue;\n+\t      }\n+\t    if (all_local)\n+\t      bitmap_set_bit (local, regno);\n+\t    if (closest_use == const0_rtx || closest_use == NULL\n+\t\t|| next_nonnote_nondebug_insn (def_insn) == closest_use)\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"Reg %d uninteresting%s\\n\", regno,\n+\t\t\t   closest_use == const0_rtx || closest_use == NULL\n+\t\t\t   ? \" (no unique first use)\" : \"\");\n+\t\tcontinue;\n+\t      }\n+#ifdef HAVE_cc0\n+\t    if (reg_referenced_p (cc0_rtx, PATTERN (closest_use)))\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"Reg %d: closest user uses cc0\\n\",\n+\t\t\t   regno);\n+\t\tcontinue;\n+\t      }\n+#endif\n+\t    bitmap_set_bit (&interesting, regno);\n+\t    closest_uses[regno] = closest_use;\n+\n+\t    if (dump_file && (all_local || all_dominated))\n+\t      {\n+\t\tfprintf (dump_file, \"Reg %u:\", regno);\n+\t\tif (all_local)\n+\t\t  fprintf (dump_file, \" local to bb %d\", bb->index);\n+\t\tif (all_dominated)\n+\t\t  fprintf (dump_file, \" def dominates all uses\");\n+\t\tif (closest_use != const0_rtx)\n+\t\t  fprintf (dump_file, \" has unique first use\");\n+\t\tfputs (\"\\n\", dump_file);\n+\t      }\n+\t  }\n+    }\n+\n+  EXECUTE_IF_SET_IN_BITMAP (&interesting, 0, i, bi)\n+    {\n+      df_ref def = DF_REG_DEF_CHAIN (i);\n+      rtx def_insn = DF_REF_INSN (def);\n+      basic_block def_block = BLOCK_FOR_INSN (def_insn);\n+      bitmap def_bb_local = bb_local + def_block->index;\n+      bitmap def_bb_moveable = bb_moveable_reg_sets + def_block->index;\n+      bitmap def_bb_transp = bb_transp_live + def_block->index;\n+      bool local_to_bb_p = bitmap_bit_p (def_bb_local, i);\n+      rtx use_insn = closest_uses[i];\n+      df_ref *def_insn_use_rec = DF_INSN_USES (def_insn);\n+      bool all_ok = true;\n+      bool all_transp = true;\n+\n+      if (!REG_P (DF_REF_REG (def)))\n+\tcontinue;\n+\n+      if (!local_to_bb_p)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Reg %u not local to one basic block\\n\",\n+\t\t     i);\n+\t  continue;\n+\t}\n+      if (reg_equiv_init (i) != NULL_RTX)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Ignoring reg %u with equiv init insn\\n\",\n+\t\t     i);\n+\t  continue;\n+\t}\n+      if (!rtx_moveable_p (&PATTERN (def_insn), OP_IN))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Found def insn %d for %d to be not moveable\\n\",\n+\t\t     INSN_UID (def_insn), i);\n+\t  continue;\n+\t}\n+      if (dump_file)\n+\tfprintf (dump_file, \"Examining insn %d, def for %d\\n\",\n+\t\t INSN_UID (def_insn), i);\n+      while (*def_insn_use_rec != NULL)\n+\t{\n+\t  df_ref use = *def_insn_use_rec;\n+\t  unsigned regno = DF_REF_REGNO (use);\n+\t  if (bitmap_bit_p (&unusable_as_input, regno))\n+\t    {\n+\t      all_ok = false;\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"  found unusable input reg %u.\\n\", regno);\n+\t      break;\n+\t    }\n+\t  if (!bitmap_bit_p (def_bb_transp, regno))\n+\t    {\n+\t      if (bitmap_bit_p (def_bb_moveable, regno)\n+\t\t  && !control_flow_insn_p (use_insn)\n+#ifdef HAVE_cc0\n+\t\t  && !sets_cc0_p (use_insn)\n+#endif\n+\t\t  )\n+\t\t{\n+\t\t  if (modified_between_p (DF_REF_REG (use), def_insn, use_insn))\n+\t\t    {\n+\t\t      rtx x = NEXT_INSN (def_insn);\n+\t\t      while (!modified_in_p (DF_REF_REG (use), x))\n+\t\t\t{\n+\t\t\t  gcc_assert (x != use_insn);\n+\t\t\t  x = NEXT_INSN (x);\n+\t\t\t}\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"  input reg %u modified but insn %d moveable\\n\",\n+\t\t\t\t regno, INSN_UID (x));\n+\t\t      emit_insn_after (PATTERN (x), use_insn);\n+\t\t      set_insn_deleted (x);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"  input reg %u modified between def and use\\n\",\n+\t\t\t\t regno);\n+\t\t      all_transp = false;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tall_transp = false;\n+\t    }\n+\n+\t  def_insn_use_rec++;\n+\t}\n+      if (!all_ok)\n+\tcontinue;\n+      if (!dbg_cnt (ira_move))\n+\tbreak;\n+      if (dump_file)\n+\tfprintf (dump_file, \"  all ok%s\\n\", all_transp ? \" and transp\" : \"\");\n+\n+      if (all_transp)\n+\t{\n+\t  rtx def_reg = DF_REF_REG (def);\n+\t  rtx newreg = ira_create_new_reg (def_reg);\n+\t  if (validate_change (def_insn, DF_REF_LOC (def), newreg, 0))\n+\t    {\n+\t      unsigned nregno = REGNO (newreg);\n+\t      rtx move = emit_insn_before (gen_move_insn (def_reg, newreg),\n+\t\t\t\t\t   use_insn);\n+\t      nregno -= max_regs;\n+\t      VEC_replace (rtx, pseudo_move_insn, nregno, move);\n+\t      VEC_replace (rtx, pseudo_replaced_reg, nregno, def_reg);\n+\t    }\n+\t}\n+    }\n+  \n+  FOR_EACH_BB (bb)\n+    {\n+      bitmap_clear (bb_local + bb->index);\n+      bitmap_clear (bb_transp_live + bb->index);\n+      bitmap_clear (bb_moveable_reg_sets + bb->index);\n+    }\n+  bitmap_clear (&interesting);\n+  bitmap_clear (&unusable_as_input);\n+  free (uid_luid);\n+  free (closest_uses);\n+  free (bb_local);\n+  free (bb_transp_live);\n+  free (bb_moveable_reg_sets);\n+\n+  last_moveable_pseudo = max_reg_num ();\n+\n+  fix_reg_equiv_init();\n+  regstat_free_n_sets_and_refs ();\n+  regstat_free_ri ();\n+  regstat_init_n_sets_and_refs ();\n+  regstat_compute_ri ();\n+  free_dominance_info (CDI_DOMINATORS);\n+}\n \n+/* Perform the second half of the transformation started in\n+   find_moveable_pseudos.  We look for instances where the newly introduced\n+   pseudo remains unallocated, and remove it by moving the definition to\n+   just before its use, replacing the move instruction generated by\n+   find_moveable_pseudos.  */\n+static void\n+move_unallocated_pseudos (void)\n+{\n+  int i;\n+  for (i = first_moveable_pseudo; i < last_moveable_pseudo; i++)\n+    if (reg_renumber[i] < 0)\n+      {\n+\tdf_ref def = DF_REG_DEF_CHAIN (i);\n+\tint idx = i - first_moveable_pseudo;\n+\trtx other_reg = VEC_index (rtx, pseudo_replaced_reg, idx);\n+\trtx def_insn = DF_REF_INSN (def);\n+\trtx move_insn = VEC_index (rtx, pseudo_move_insn, idx);\n+\trtx set;\n+\trtx newinsn = emit_insn_after (PATTERN (def_insn), move_insn);\n+\tint success;\n+\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"moving def of %d (insn %d now) \",\n+\t\t   REGNO (other_reg), INSN_UID (def_insn));\n+\n+\tset = single_set (newinsn);\n+\tsuccess = validate_change (newinsn, &SET_DEST (set), other_reg, 0);\n+\tgcc_assert (success);\n+\tif (dump_file)\n+\t  fprintf (dump_file, \" %d) rather than keep unallocated replacement %d\\n\",\n+\t\t   INSN_UID (newinsn), i);\n+\tdelete_insn (move_insn);\n+\tdelete_insn (def_insn);\n+\tSET_REG_N_REFS (i, 0);\n+      }\n+}\n \f\n \n /* All natural loops.  */\n@@ -3606,6 +4120,8 @@ ira (FILE *f)\n \t}\n     }\n \n+  find_moveable_pseudos ();\n+\n   max_regno_before_ira = allocated_reg_info_size = max_reg_num ();\n   ira_setup_eliminable_regset ();\n \n@@ -3716,6 +4232,7 @@ ira (FILE *f)\n \t      max_regno * sizeof (struct ira_spilled_reg_stack_slot));\n     }\n   allocate_initial_values (reg_equivs);\n+  move_unallocated_pseudos ();\n }\n \n static void"}]}