{"sha": "f015be23f57e10375b7495132aa6f05d6fa3c065", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAxNWJlMjNmNTdlMTAzNzViNzQ5NTEzMmFhNmYwNWQ2ZmEzYzA2NQ==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2002-02-01T18:58:39Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2002-02-01T18:58:39Z"}, "message": "cfganal.c (keep_with_call_p): New function.\n\n\t* cfganal.c (keep_with_call_p): New function.\n\t(flow_call_edges_add): Prevent splitting a block between a call and\n\ta single-set instruction that should be kept in the same block.\n\nFrom-SVN: r49401", "tree": {"sha": "3c2f67d4025cf2d16e9dfa9b70ec9ee829804b88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c2f67d4025cf2d16e9dfa9b70ec9ee829804b88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f015be23f57e10375b7495132aa6f05d6fa3c065", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f015be23f57e10375b7495132aa6f05d6fa3c065", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f015be23f57e10375b7495132aa6f05d6fa3c065", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f015be23f57e10375b7495132aa6f05d6fa3c065/comments", "author": null, "committer": null, "parents": [{"sha": "63708ffc63b8fbeda7425126067d8adffa0f5ae9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63708ffc63b8fbeda7425126067d8adffa0f5ae9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63708ffc63b8fbeda7425126067d8adffa0f5ae9"}], "stats": {"total": 76, "additions": 62, "deletions": 14}, "files": [{"sha": "673c6802eacd0bc3770d62d454eeaf2c44c45b72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f015be23f57e10375b7495132aa6f05d6fa3c065/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f015be23f57e10375b7495132aa6f05d6fa3c065/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f015be23f57e10375b7495132aa6f05d6fa3c065", "patch": "@@ -1,3 +1,9 @@\n+2002-02-01  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* cfganal.c (keep_with_call_p): New function.\n+\t(flow_call_edges_add): Prevent splitting a block between a call and\n+\ta single-set instruction that should be kept in the same block.\n+\n 2002-02-01  Craig Rodrigues  <rodrigc@gcc.gnu.org>\n \n \t* doc/install.texi (avr): Update outdated URL."}, {"sha": "a57b25a1ffd9f3c78d520c6c389a17d49978acfd", "filename": "gcc/cfganal.c", "status": "modified", "additions": 56, "deletions": 14, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f015be23f57e10375b7495132aa6f05d6fa3c065/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f015be23f57e10375b7495132aa6f05d6fa3c065/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=f015be23f57e10375b7495132aa6f05d6fa3c065", "patch": "@@ -53,6 +53,7 @@ static void flow_dfs_compute_reverse_finish\n   PARAMS ((depth_first_search_ds));\n static void remove_fake_successors\tPARAMS ((basic_block));\n static bool need_fake_edge_p\t\tPARAMS ((rtx));\n+static bool keep_with_call_p\t\tPARAMS ((rtx));\n \f\n /* Return true if the block has no effect and only forwards control flow to\n    its single destination.  */\n@@ -209,6 +210,29 @@ need_fake_edge_p (insn)\n \t  || GET_CODE (PATTERN (insn)) == ASM_INPUT);\n }\n \n+/* Return true if INSN should be kept in the same block as a preceding call.\n+   This is done for a single-set whose destination is a fixed register or\n+   whose source is the function return value.  This is a helper function for\n+   flow_call_edges_add.  */\n+\n+static bool\n+keep_with_call_p (insn)\n+     rtx insn;\n+{\n+  rtx set;\n+\n+  if (INSN_P (insn) && (set = single_set (insn)) != NULL)\n+    {\n+      if (GET_CODE (SET_DEST (set)) == REG\n+\t  && fixed_regs[REGNO (SET_DEST (set))])\n+\treturn true;\n+      if (GET_CODE (SET_SRC (set)) == REG\n+\t  && REG_FUNCTION_VALUE_P (SET_SRC (set)))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Add fake edges to the function exit for any non constant and non noreturn\n    calls, volatile inline assembly in the bitmap of blocks specified by\n    BLOCKS or to the whole CFG if BLOCKS is zero.  Return the number of blocks\n@@ -259,17 +283,27 @@ flow_call_edges_add (blocks)\n      spanning tree in the case that the call doesn't return.\n \n      Handle this by adding a dummy instruction in a new last basic block.  */\n-  if (check_last_block\n-      && need_fake_edge_p (BASIC_BLOCK (n_basic_blocks - 1)->end))\n+  if (check_last_block)\n     {\n-       edge e;\n+      basic_block bb = BASIC_BLOCK (n_basic_blocks - 1);\n+      rtx insn = bb->end;\n \n-       for (e = BASIC_BLOCK (n_basic_blocks - 1)->succ; e; e = e->succ_next)\n-\t if (e->dest == EXIT_BLOCK_PTR)\n-\t    break;\n+      /* Back up past insns that must be kept in the same block as a call.  */\n+      while (insn != bb->head\n+\t     && keep_with_call_p (insn))\n+\tinsn = PREV_INSN (insn);\n+\n+      if (need_fake_edge_p (insn))\n+\t{\n+\t  edge e;\n \n-       insert_insn_on_edge (gen_rtx_USE (VOIDmode, const0_rtx), e);\n-       commit_edge_insertions ();\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    if (e->dest == EXIT_BLOCK_PTR)\n+\t      break;\n+\n+\t  insert_insn_on_edge (gen_rtx_USE (VOIDmode, const0_rtx), e);\n+\t  commit_edge_insertions ();\n+\t}\n     }\n \n   /* Now add fake edges to the function exit for any non constant\n@@ -288,22 +322,30 @@ flow_call_edges_add (blocks)\n \t  if (need_fake_edge_p (insn))\n \t    {\n \t      edge e;\n+\t      rtx split_at_insn = insn;\n+\n+\t      /* Don't split the block between a call and an insn that should\n+\t         remain in the same block as the call.  */\n+\t      if (GET_CODE (insn) == CALL_INSN)\n+\t\twhile (split_at_insn != bb->end\n+\t\t       && keep_with_call_p (NEXT_INSN (split_at_insn)))\n+\t\t  split_at_insn = NEXT_INSN (split_at_insn);\n \n-\t      /* The above condition should be enough to verify that there is\n-\t\t no edge to the exit block in CFG already.  Calling make_edge\n-\t\t in such case would make us to mark that edge as fake and\n-\t\t remove it later.  */\n+\t      /* The handling above of the final block before the epilogue\n+\t         should be enough to verify that there is no edge to the exit\n+\t\t block in CFG already.  Calling make_edge in such case would\n+\t\t cause us to mark that edge as fake and remove it later.  */\n \n #ifdef ENABLE_CHECKING\n-\t      if (insn == bb->end)\n+\t      if (split_at_insn == bb->end)\n \t\tfor (e = bb->succ; e; e = e->succ_next)\n \t\t  if (e->dest == EXIT_BLOCK_PTR)\n \t\t    abort ();\n #endif\n \n \t      /* Note that the following may create a new basic block\n \t\t and renumber the existing basic blocks.  */\n-\t      e = split_block (bb, insn);\n+\t      e = split_block (bb, split_at_insn);\n \t      if (e)\n \t\tblocks_split++;\n "}]}