{"sha": "859b6600162e068949a502cf17b0735a92273995", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU5YjY2MDAxNjJlMDY4OTQ5YTUwMmNmMTdiMDczNWE5MjI3Mzk5NQ==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2010-07-14T19:19:57Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2010-07-14T19:19:57Z"}, "message": "trans-array.c (gfc_conv_section_upper_bound): Remove\n\n2010-07-14  Mikael Morin  <mikael@gcc.gnu.org>\n\n\t* trans-array.c (gfc_conv_section_upper_bound): Remove\n\t(gfc_conv_section_startstride): Don't set the upper bound in the \n\tvector subscript case. \n\t(gfc_conv_loop_setup): Don't use gfc_conv_section_upper_bound\n\nFrom-SVN: r162191", "tree": {"sha": "8d17d7a9d8e0b2bfd2aed7853125891e7f2e4bb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d17d7a9d8e0b2bfd2aed7853125891e7f2e4bb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/859b6600162e068949a502cf17b0735a92273995", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/859b6600162e068949a502cf17b0735a92273995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/859b6600162e068949a502cf17b0735a92273995", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/859b6600162e068949a502cf17b0735a92273995/comments", "author": null, "committer": null, "parents": [{"sha": "588c71dabfe3f91b16da60e335d33a59719dfedf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/588c71dabfe3f91b16da60e335d33a59719dfedf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/588c71dabfe3f91b16da60e335d33a59719dfedf"}], "stats": {"total": 65, "additions": 12, "deletions": 53}, "files": [{"sha": "d6b150a2d2587b33be7579b589f8c51afb5b96b8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/859b6600162e068949a502cf17b0735a92273995/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/859b6600162e068949a502cf17b0735a92273995/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=859b6600162e068949a502cf17b0735a92273995", "patch": "@@ -1,3 +1,10 @@\n+2010-07-14  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-array.c (gfc_conv_section_upper_bound): Remove\n+\t(gfc_conv_section_startstride): Don't set the upper bound in the \n+\tvector subscript case. \n+\t(gfc_conv_loop_setup): Don't use gfc_conv_section_upper_bound\n+\n 2010-07-14  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/44925"}, {"sha": "b6a95483ea64832296a0fccc3864f25e474f314d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 5, "deletions": 53, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/859b6600162e068949a502cf17b0735a92273995/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/859b6600162e068949a502cf17b0735a92273995/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=859b6600162e068949a502cf17b0735a92273995", "patch": "@@ -2964,50 +2964,6 @@ gfc_trans_scalarized_loop_boundary (gfc_loopinfo * loop, stmtblock_t * body)\n }\n \n \n-/* Calculate the upper bound of an array section.  */\n-\n-static tree\n-gfc_conv_section_upper_bound (gfc_ss * ss, int n, stmtblock_t * pblock)\n-{\n-  int dim;\n-  gfc_expr *end;\n-  tree desc;\n-  tree bound;\n-  gfc_se se;\n-  gfc_ss_info *info;\n-\n-  gcc_assert (ss->type == GFC_SS_SECTION);\n-\n-  info = &ss->data.info;\n-  dim = info->dim[n];\n-\n-  if (info->ref->u.ar.dimen_type[dim] == DIMEN_VECTOR)\n-    /* We'll calculate the upper bound once we have access to the\n-       vector's descriptor.  */\n-    return NULL;\n-\n-  gcc_assert (info->ref->u.ar.dimen_type[dim] == DIMEN_RANGE);\n-  desc = info->descriptor;\n-  end = info->ref->u.ar.end[dim];\n-\n-  if (end)\n-    {\n-      /* The upper bound was specified.  */\n-      gfc_init_se (&se, NULL);\n-      gfc_conv_expr_type (&se, end, gfc_array_index_type);\n-      gfc_add_block_to_block (pblock, &se.pre);\n-      bound = se.expr;\n-    }\n-  else\n-    {\n-      /* No upper bound was specified, so use the bound of the array.  */\n-      bound = gfc_conv_array_ubound (desc, dim);\n-    }\n-\n-  return bound;\n-}\n-\n-\n /* Calculate the lower bound of an array section.  */\n \n static void\n@@ -3030,8 +2986,8 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int n)\n     {\n       /* We use a zero-based index to access the vector.  */\n       info->start[n] = gfc_index_zero_node;\n-      info->end[n] = gfc_index_zero_node;\n       info->stride[n] = gfc_index_one_node;\n+      info->end[n] = NULL;\n       return;\n     }\n \n@@ -3688,17 +3644,13 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t    case GFC_SS_SECTION:\n \t      /* Use the end expression if it exists and is not constant,\n \t\t so that it is only evaluated once.  */\n-\t      if (info->end[n] && !INTEGER_CST_P (info->end[n]))\n-\t\tloop->to[n] = info->end[n];\n-\t      else\n-\t\tloop->to[n] = gfc_conv_section_upper_bound (loopspec[n], n,\n-\t\t\t\t\t\t\t    &loop->pre);\n+\t      loop->to[n] = info->end[n];\n \t      break;\n \n-            case GFC_SS_FUNCTION:\n+\t    case GFC_SS_FUNCTION:\n \t      /* The loop bound will be set when we generate the call.  */\n-              gcc_assert (loop->to[n] == NULL_TREE);\n-              break;\n+\t      gcc_assert (loop->to[n] == NULL_TREE);\n+\t      break;\n \n \t    default:\n \t      gcc_unreachable ();"}]}