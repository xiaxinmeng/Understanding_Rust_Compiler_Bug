{"sha": "faaeebd64671ebe0aabf203527bb7bf57476f4f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFhZWViZDY0NjcxZWJlMGFhYmYyMDM1MjdiYjdiZjU3NDc2ZjRmMw==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2019-02-05T16:32:06Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2019-02-05T16:32:06Z"}, "message": "re PR target/89112 (Incorrect code generated by rs6000 memcmp expansion)\n\n2019-02-05  Aaron Sawdey  <acsawdey@linux.ibm.com>\n\n\tPR target/89112\n\t* config/rs6000/rs6000-string.c (do_ifelse, expand_cmp_vec_sequence,\n\texpand_compare_loop, expand_block_compare_gpr,\n\texpand_strncmp_align_check, expand_strncmp_gpr_sequence): Insert\n\tREG_BR_PROB notes in inline expansion of memcmp/strncmp. Add\n\t#include \"profile-count.h\" and \"predict.h\" for types and functions\n\tneeded to work with REG_BR_PROB notes.\n\nFrom-SVN: r268547", "tree": {"sha": "21306deb7bf07da94f715b9901f4ae061b87d83c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21306deb7bf07da94f715b9901f4ae061b87d83c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/faaeebd64671ebe0aabf203527bb7bf57476f4f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faaeebd64671ebe0aabf203527bb7bf57476f4f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faaeebd64671ebe0aabf203527bb7bf57476f4f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faaeebd64671ebe0aabf203527bb7bf57476f4f3/comments", "author": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "60f34f084ad075b1495487c9e6fd2455b1e00551", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60f34f084ad075b1495487c9e6fd2455b1e00551", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60f34f084ad075b1495487c9e6fd2455b1e00551"}], "stats": {"total": 77, "additions": 52, "deletions": 25}, "files": [{"sha": "b3c2e7c46d365a608309553ac6d0cf65729f1b22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faaeebd64671ebe0aabf203527bb7bf57476f4f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faaeebd64671ebe0aabf203527bb7bf57476f4f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=faaeebd64671ebe0aabf203527bb7bf57476f4f3", "patch": "@@ -1,3 +1,13 @@\n+2019-02-05  Aaron Sawdey  <acsawdey@linux.ibm.com>\n+\n+\tPR target/89112\n+\t* config/rs6000/rs6000-string.c (do_ifelse, expand_cmp_vec_sequence,\n+\texpand_compare_loop, expand_block_compare_gpr,\n+\texpand_strncmp_align_check, expand_strncmp_gpr_sequence): Insert\n+\tREG_BR_PROB notes in inline expansion of memcmp/strncmp. Add\n+\t#include \"profile-count.h\" and \"predict.h\" for types and functions\n+\tneeded to work with REG_BR_PROB notes.\n+\n 2019-02-05  Aaron Sawdey  <acsawdey@linux.ibm.com>\n \n \tPR target/89112"}, {"sha": "7101dc77e081570b654fb8730dc625243d637359", "filename": "gcc/config/rs6000/rs6000-string.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faaeebd64671ebe0aabf203527bb7bf57476f4f3/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faaeebd64671ebe0aabf203527bb7bf57476f4f3/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-string.c?ref=faaeebd64671ebe0aabf203527bb7bf57476f4f3", "patch": "@@ -35,6 +35,8 @@\n #include \"expr.h\"\n #include \"output.h\"\n #include \"target.h\"\n+#include \"profile-count.h\"\n+#include \"predict.h\"\n \n /* Expand a block clear operation, and return 1 if successful.  Return 0\n    if we should let the compiler generate normal code.\n@@ -369,6 +371,7 @@ do_load_for_compare_from_addr (machine_mode mode, rtx dest, rtx addr,\n    B is the second thing to be compared.\n    CR is the condition code reg input, or NULL_RTX.\n    TRUE_LABEL is the label to branch to if the condition is true.\n+   P is the estimated branch probability for the branch.\n \n    The return value is the CR used for the comparison.\n    If CR is null_rtx, then a new register of CMPMODE is generated.\n@@ -377,7 +380,7 @@ do_load_for_compare_from_addr (machine_mode mode, rtx dest, rtx addr,\n \n static void\n do_ifelse (machine_mode cmpmode, rtx_code comparison,\n-\t   rtx a, rtx b, rtx cr, rtx true_label)\n+\t   rtx a, rtx b, rtx cr, rtx true_label, profile_probability br_prob)\n {\n   gcc_assert ((a == NULL_RTX && b == NULL_RTX && cr != NULL_RTX)\n \t      || (a != NULL_RTX && b != NULL_RTX));\n@@ -395,7 +398,8 @@ do_ifelse (machine_mode cmpmode, rtx_code comparison,\n   rtx cmp_rtx = gen_rtx_fmt_ee (comparison, VOIDmode, cr, const0_rtx);\n \n   rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx, label_ref, pc_rtx);\n-  rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+  rtx_insn *j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+  add_reg_br_prob_note (j, br_prob);\n   JUMP_LABEL (j) = true_label;\n   LABEL_NUSES (true_label) += 1;\n }\n@@ -781,7 +785,8 @@ expand_cmp_vec_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n       rtx lab_ref = gen_rtx_LABEL_REF (VOIDmode, dst_label);\n       rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx,\n \t\t\t\t\t lab_ref, pc_rtx);\n-      rtx j2 = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+      rtx_insn *j2 = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+      add_reg_br_prob_note (j2, profile_probability::likely ());\n       JUMP_LABEL (j2) = dst_label;\n       LABEL_NUSES (dst_label) += 1;\n \n@@ -1036,7 +1041,7 @@ expand_compare_loop (rtx operands[])\n \n   /* Difference found is stored here before jump to diff_label.  */\n   rtx diff = gen_reg_rtx (word_mode);\n-  rtx j;\n+  rtx_insn *j;\n \n   /* Example of generated code for 35 bytes aligned 1 byte.\n \n@@ -1120,11 +1125,11 @@ expand_compare_loop (rtx operands[])\n       /* Check for > max_bytes bytes.  We want to bail out as quickly as\n \t possible if we have to go over to memcmp.  */\n       do_ifelse (CCmode, GT, bytes_rtx, GEN_INT (max_bytes),\n-\t\t NULL_RTX, library_call_label);\n+\t\t NULL_RTX, library_call_label, profile_probability::even ());\n \n       /* Check for < loop_bytes bytes.  */\n       do_ifelse (CCmode, LT, bytes_rtx, GEN_INT (loop_bytes),\n-\t\t NULL_RTX, cleanup_label);\n+\t\t NULL_RTX, cleanup_label, profile_probability::even ());\n \n       /* Loop compare bytes and iterations if bytes>max_bytes.  */\n       rtx mb_reg = gen_reg_rtx (word_mode);\n@@ -1165,7 +1170,7 @@ expand_compare_loop (rtx operands[])\n \t{\n \t  rtx lab_after = gen_label_rtx ();\n \t  do_ifelse (CCmode, LE, bytes_rtx, GEN_INT (max_bytes),\n-\t\t     NULL_RTX, lab_after);\n+\t\t     NULL_RTX, lab_after, profile_probability::even ());\n \t  emit_move_insn (loop_cmp, mb_reg);\n \t  emit_move_insn (iter, mi_reg);\n \t  emit_label (lab_after);\n@@ -1236,7 +1241,7 @@ expand_compare_loop (rtx operands[])\n \t}\n \n       do_ifelse (GET_MODE (dcond), NE, NULL_RTX, NULL_RTX,\n-\t\t dcond, diff_label);\n+\t\t dcond, diff_label, profile_probability::unlikely ());\n \n       if (TARGET_P9_MISC)\n \t{\n@@ -1260,6 +1265,7 @@ expand_compare_loop (rtx operands[])\n       else\n \tj = emit_jump_insn (gen_bdnztf_si (loop_top_label, ctr, ctr,\n \t\t\t\t\t   eqrtx, dcond));\n+      add_reg_br_prob_note (j, profile_probability::likely ());\n       JUMP_LABEL (j) = loop_top_label;\n       LABEL_NUSES (loop_top_label) += 1;\n     }\n@@ -1272,9 +1278,11 @@ expand_compare_loop (rtx operands[])\n      code.  If we exit here with a nonzero diff, it is\n      because the second word differed.  */\n   if (TARGET_P9_MISC)\n-    do_ifelse (CCUNSmode, NE, NULL_RTX, NULL_RTX, dcond, diff_label);\n+    do_ifelse (CCUNSmode, NE, NULL_RTX, NULL_RTX, dcond,\n+\t       diff_label, profile_probability::unlikely ());\n   else\n-    do_ifelse (CCmode, NE, diff, const0_rtx, NULL_RTX, diff_label);\n+    do_ifelse (CCmode, NE, diff, const0_rtx, NULL_RTX,\n+\t       diff_label, profile_probability::unlikely ());\n \n   if (library_call_label != NULL && bytes_is_const && bytes > max_bytes)\n     {\n@@ -1317,7 +1325,7 @@ expand_compare_loop (rtx operands[])\n \t     loop with a branch to cleanup_label.  */\n \t  emit_move_insn (target, const0_rtx);\n \t  do_ifelse (CCmode, EQ, cmp_rem, const0_rtx,\n-\t\t     NULL_RTX, final_label);\n+\t\t     NULL_RTX, final_label, profile_probability::unlikely ());\n \t}\n \n       rtx final_cleanup = gen_label_rtx ();\n@@ -1327,9 +1335,12 @@ expand_compare_loop (rtx operands[])\n \t{\n \t  /* If remainder length < word length, branch to final\n \t     cleanup compare.  */\n+\t  \n \t  if (!bytes_is_const)\n-\t    do_ifelse (CCmode, LT, cmp_rem, GEN_INT (load_mode_size),\n-\t\t       NULL_RTX, final_cleanup);\n+\t    {\n+\t      do_ifelse (CCmode, LT, cmp_rem, GEN_INT (load_mode_size),\n+\t\t\t NULL_RTX, final_cleanup, profile_probability::even ());\n+\t    }\n \n \t  /* load and compare 8B */\n \t  do_load_for_compare_from_addr (load_mode, d1_1,\n@@ -1354,7 +1365,7 @@ expand_compare_loop (rtx operands[])\n \t    }\n \n \t  do_ifelse (GET_MODE (dcond), NE, NULL_RTX, NULL_RTX,\n-\t\t     dcond, diff_label);\n+\t\t     dcond, diff_label, profile_probability::even ());\n \n \t  do_add3 (src1_addr, src1_addr, GEN_INT (load_mode_size));\n \t  do_add3 (src2_addr, src2_addr, GEN_INT (load_mode_size));\n@@ -1365,9 +1376,8 @@ expand_compare_loop (rtx operands[])\n \t  else\n \t    /* See if remaining length is now zero.  We previously set\n \t       target to 0 so we can just jump to the end.  */\n-\t    do_ifelse (CCmode, EQ, cmp_rem, const0_rtx,\n-\t\t       NULL_RTX, final_label);\n-\n+\t    do_ifelse (CCmode, EQ, cmp_rem, const0_rtx, NULL_RTX,\n+\t\t       final_label, profile_probability::unlikely ());\n \t}\n \n       /* Cases:\n@@ -1450,7 +1460,7 @@ expand_compare_loop (rtx operands[])\n \t     than one loop iteration, in which case go do the overlap\n \t     load compare path.  */\n \t  do_ifelse (CCmode, GT, bytes_rtx, GEN_INT (loop_bytes),\n-\t\t     NULL_RTX, nonconst_overlap);\n+\t\t     NULL_RTX, nonconst_overlap, profile_probability::even ());\n \n \t  rtx rem4k = gen_reg_rtx (word_mode);\n \t  rtx dist1 = gen_reg_rtx (word_mode);\n@@ -1460,12 +1470,14 @@ expand_compare_loop (rtx operands[])\n \t    emit_insn (gen_andsi3 (dist1, src1_addr, GEN_INT (0xfff)));\n \t  else\n \t    emit_insn (gen_anddi3 (dist1, src1_addr, GEN_INT (0xfff)));\n-\t  do_ifelse (CCmode, LE, dist1, rem4k, NULL_RTX, handle4k_label);\n+\t  do_ifelse (CCmode, LE, dist1, rem4k, NULL_RTX,\n+\t\t     handle4k_label, profile_probability::very_unlikely ());\n \t  if (word_mode == SImode)\n \t    emit_insn (gen_andsi3 (dist2, src2_addr, GEN_INT (0xfff)));\n \t  else\n \t    emit_insn (gen_anddi3 (dist2, src2_addr, GEN_INT (0xfff)));\n-\t  do_ifelse (CCmode, LE, dist2, rem4k, NULL_RTX, handle4k_label);\n+\t  do_ifelse (CCmode, LE, dist2, rem4k, NULL_RTX,\n+\t\t     handle4k_label, profile_probability::very_unlikely ());\n \n \t  /* We don't have a 4k boundary to deal with, so do\n \t     a load/shift/compare and jump to diff.  */\n@@ -1817,7 +1829,8 @@ expand_block_compare_gpr(unsigned HOST_WIDE_INT bytes, unsigned int base_align,\n \t      rtx ne_rtx = gen_rtx_NE (VOIDmode, cr, const0_rtx);\n \t      rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, ne_rtx,\n \t\t\t\t\t\t fin_ref, pc_rtx);\n-\t      rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+\t      rtx_insn *j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+\t      add_reg_br_prob_note (j, profile_probability::unlikely ());\n \t      JUMP_LABEL (j) = final_label;\n \t      LABEL_NUSES (final_label) += 1;\n \t    }\n@@ -2095,7 +2108,8 @@ expand_strncmp_align_check (rtx strncmp_label, rtx src_addr, HOST_WIDE_INT bytes\n \n   rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx,\n \t\t\t\t     lab_ref, pc_rtx);\n-  rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+  rtx_insn *j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+  add_reg_br_prob_note (j, profile_probability::unlikely ());\n   JUMP_LABEL (j) = strncmp_label;\n   LABEL_NUSES (strncmp_label) += 1;\n }\n@@ -2265,7 +2279,8 @@ expand_strncmp_gpr_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n \n \t      rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx,\n \t\t\t\t\t\t lab_ref, pc_rtx);\n-\t      rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+\t      rtx_insn *j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+\t      add_reg_br_prob_note (j, profile_probability::unlikely ());\n \t      JUMP_LABEL (j) = final_move_label;\n \t      LABEL_NUSES (final_move_label) += 1;\n \n@@ -2282,7 +2297,8 @@ expand_strncmp_gpr_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n \n \t      rtx ifelse0 = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp0eq_rtx,\n \t\t\t\t\t\t lab_ref, pc_rtx);\n-\t      rtx j0 = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse0));\n+\t      rtx_insn *j0 = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse0));\n+\t      add_reg_br_prob_note (j0, profile_probability::unlikely ());\n \t      JUMP_LABEL (j0) = final_move_label;\n \t      LABEL_NUSES (final_move_label) += 1;\n \t    }\n@@ -2325,7 +2341,8 @@ expand_strncmp_gpr_sequence (unsigned HOST_WIDE_INT bytes_to_compare,\n \n \t  rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx,\n \t\t\t\t\t     lab_ref, pc_rtx);\n-\t  rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+\t  rtx_insn *j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+\t  add_reg_br_prob_note (j, profile_probability::unlikely ());\n \t  JUMP_LABEL (j) = dst_label;\n \t  LABEL_NUSES (dst_label) += 1;\n \t}"}]}