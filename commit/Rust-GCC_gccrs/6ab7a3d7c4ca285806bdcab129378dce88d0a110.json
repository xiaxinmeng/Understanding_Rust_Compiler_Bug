{"sha": "6ab7a3d7c4ca285806bdcab129378dce88d0a110", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFiN2EzZDdjNGNhMjg1ODA2YmRjYWIxMjkzNzhkY2U4OGQwYTExMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-11-12T16:41:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-11-12T16:41:51Z"}, "message": "gimple-ssa-isolate-paths.c (check_loadstore): New function.\n\n\t* gimple-ssa-isolate-paths.c (check_loadstore): New function.\n\t(insert_trap_and_remove_trailing_statements): New argument OP which\n\tis the NULL pointer.  Emit the trap after the load/store through\n\tthe NULL pointer.  Simplify the RHS of a store through a NULL pointer\n\twhen trivial to do so.\n\t(isolate_path): Corresponding changes.\n\t(gimple_ssa_isolate_erroneous_path): Likewise.\n\n\t* gcc.dg/tree-ssa/isolate-1.c: Update expected output.\n\t* gcc.dg/tree-ssa/isolate-5.c: New test.\n\nFrom-SVN: r204708", "tree": {"sha": "312c513cff532b2a7e8690bb06a23517aa6f588e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/312c513cff532b2a7e8690bb06a23517aa6f588e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ab7a3d7c4ca285806bdcab129378dce88d0a110", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab7a3d7c4ca285806bdcab129378dce88d0a110", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ab7a3d7c4ca285806bdcab129378dce88d0a110", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab7a3d7c4ca285806bdcab129378dce88d0a110/comments", "author": null, "committer": null, "parents": [{"sha": "eb4b92c13be5ec67ca43b701da932835bdd1e4b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb4b92c13be5ec67ca43b701da932835bdd1e4b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb4b92c13be5ec67ca43b701da932835bdd1e4b7"}], "stats": {"total": 157, "additions": 142, "deletions": 15}, "files": [{"sha": "a9254472c8eb162840b1b4995c338ea29e0ebb46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab7a3d7c4ca285806bdcab129378dce88d0a110/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab7a3d7c4ca285806bdcab129378dce88d0a110/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ab7a3d7c4ca285806bdcab129378dce88d0a110", "patch": "@@ -1,3 +1,13 @@\n+2013-11-12  Jeff Law  <law@redhat.com>\n+\n+\t* gimple-ssa-isolate-paths.c (check_loadstore): New function.\n+\t(insert_trap_and_remove_trailing_statements): New argument OP which\n+\tis the NULL pointer.  Emit the trap after the load/store through\n+\tthe NULL pointer.  Simplify the RHS of a store through a NULL pointer\n+\twhen trivial to do so.\n+\t(isolate_path): Corresponding changes.\n+\t(gimple_ssa_isolate_erroneous_path): Likewise.\n+\n 2013-11-12  Teresa Johnson  <tejohnson@google.com>\n \t    Jan Hubicka  <jh@suse.cz>\n "}, {"sha": "48ab6049e4e896cc7534ad435d032a5e90686e7c", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 61, "deletions": 11, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab7a3d7c4ca285806bdcab129378dce88d0a110/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab7a3d7c4ca285806bdcab129378dce88d0a110/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=6ab7a3d7c4ca285806bdcab129378dce88d0a110", "patch": "@@ -39,17 +39,65 @@ along with GCC; see the file COPYING3.  If not see\n \n static bool cfg_altered;\n \n-/* Insert a trap before SI and remove SI and all statements after SI.  */\n+/* Callback for walk_stmt_load_store_ops.\n+ \n+   Return TRUE if OP will dereference the tree stored in DATA, FALSE\n+   otherwise.\n+\n+   This routine only makes a superficial check for a dereference.  Thus,\n+   it must only be used if it is safe to return a false negative.  */\n+static bool\n+check_loadstore (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+{\n+  if ((TREE_CODE (op) == MEM_REF || TREE_CODE (op) == TARGET_MEM_REF)\n+      && operand_equal_p (TREE_OPERAND (op, 0), (tree)data, 0))\n+    return true;\n+  return false;\n+}\n+\n+/* Insert a trap after SI and remove SI and all statements after the trap.  */\n \n static void\n-insert_trap_and_remove_trailing_statements (gimple_stmt_iterator *si_p)\n+insert_trap_and_remove_trailing_statements (gimple_stmt_iterator *si_p, tree op)\n {\n-  gimple_seq seq = NULL;\n-  gimple stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n-  gimple_seq_add_stmt (&seq, stmt);\n-  gsi_insert_before (si_p, seq, GSI_SAME_STMT);\n+  /* We want the NULL pointer dereference to actually occur so that\n+     code that wishes to catch the signal can do so.\n \n-  /* Now delete all remaining statements in this block.  */\n+     If the dereference is a load, then there's nothing to do as the\n+     LHS will be a throw-away SSA_NAME and the LHS is the NULL dereference.\n+\n+     If the dereference is a store and we can easily transform the RHS,\n+     then simplify the RHS to enable more DCE.  */\n+  gimple stmt = gsi_stmt (*si_p);\n+  if (walk_stmt_load_store_ops (stmt, (void *)op, NULL, check_loadstore)\n+      && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_lhs (stmt))))\n+    {\n+      /* We just need to turn the RHS into zero converted to the proper\n+         type.  */\n+      tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n+      gimple_assign_set_rhs_code (stmt, INTEGER_CST);\n+      gimple_assign_set_rhs1 (stmt, fold_convert (type, integer_zero_node));\n+      update_stmt (stmt);\n+    }\n+\n+  gimple new_stmt\n+    = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n+  gimple_seq seq = NULL;\n+  gimple_seq_add_stmt (&seq, new_stmt);\n+\n+  /* If we had a NULL pointer dereference, then we want to insert the\n+     __builtin_trap after the statement, for the other cases we want\n+     to insert before the statement.  */\n+  if (walk_stmt_load_store_ops (stmt, (void *)op,\n+\t\t\t        check_loadstore,\n+\t\t\t\tcheck_loadstore))\n+    gsi_insert_after (si_p, seq, GSI_NEW_STMT);\n+  else\n+    gsi_insert_before (si_p, seq, GSI_NEW_STMT);\n+\n+  /* The iterator points to the __builtin_trap.  Advance the iterator\n+     and delete everything else in the block.  */\n+  gsi_next (si_p);\n   for (; !gsi_end_p (*si_p);)\n     {\n       stmt = gsi_stmt (*si_p);\n@@ -73,7 +121,8 @@ insert_trap_and_remove_trailing_statements (gimple_stmt_iterator *si_p)\n    Return BB'.  */\n \n basic_block\n-isolate_path (basic_block bb, basic_block duplicate, edge e, gimple stmt)\n+isolate_path (basic_block bb, basic_block duplicate,\n+\t      edge e, gimple stmt, tree op)\n {\n   gimple_stmt_iterator si, si2;\n   edge_iterator ei;\n@@ -133,7 +182,7 @@ isolate_path (basic_block bb, basic_block duplicate, edge e, gimple stmt)\n      SI2 points to the duplicate of STMT in DUPLICATE.  Insert a trap\n      before SI2 and remove SI2 and all trailing statements.  */\n   if (!gsi_end_p (si2))\n-    insert_trap_and_remove_trailing_statements (&si2);\n+    insert_trap_and_remove_trailing_statements (&si2, op);\n \n   return duplicate;\n }\n@@ -224,7 +273,7 @@ gimple_ssa_isolate_erroneous_paths (void)\n \t\t  if (infer_nonnull_range (use_stmt, lhs))\n \t\t    {\n \t\t      duplicate = isolate_path (bb, duplicate,\n-\t\t\t\t\t\te, use_stmt);\n+\t\t\t\t\t\te, use_stmt, lhs);\n \n \t\t      /* When we remove an incoming edge, we need to\n \t\t\t reprocess the Ith element.  */\n@@ -247,7 +296,8 @@ gimple_ssa_isolate_erroneous_paths (void)\n \t     where a non-NULL value is required.  */\n \t  if (infer_nonnull_range (stmt, null_pointer_node))\n \t    {\n-\t      insert_trap_and_remove_trailing_statements (&si);\n+\t      insert_trap_and_remove_trailing_statements (&si,\n+\t\t\t\t\t\t\t  null_pointer_node);\n \n \t      /* And finally, remove all outgoing edges from BB.  */\n \t      edge e;"}, {"sha": "82d0e7a14d46c3c6290bbcd1dfec15496a50541e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab7a3d7c4ca285806bdcab129378dce88d0a110/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab7a3d7c4ca285806bdcab129378dce88d0a110/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6ab7a3d7c4ca285806bdcab129378dce88d0a110", "patch": "@@ -1,3 +1,8 @@\n+2013-11-12  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/isolate-1.c: Update expected output.\n+\t* gcc.dg/tree-ssa/isolate-5.c: New test.\n+\n 2013-11-12  Martin Jambor  <mjambor@suse.cz>\n \n \tPR rtl-optimization/10474\n@@ -389,7 +394,7 @@\n \tPR fortran/58989\n \t* gfortran.dg/reshape_6.f90: New test.\n \n-2013-10-05  Jeff Law  <law@redhat.com>\n+2013-11-05  Jeff Law  <law@redhat.com>\n \n \t* gcc.dg/pr38984.c: Add -fno-isolate-erroneous-paths.\n \t* gcc.dg/tree-ssa/isolate-1.c: New test."}, {"sha": "33745baf2f81261a25d458927e10342b80de909a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/isolate-1.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab7a3d7c4ca285806bdcab129378dce88d0a110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab7a3d7c4ca285806bdcab129378dce88d0a110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-1.c?ref=6ab7a3d7c4ca285806bdcab129378dce88d0a110", "patch": "@@ -43,12 +43,14 @@ d_type (struct d_info *di)\n    return ret;\n }\n \n-/* We're testing two aspects of isolation here.  First that isolation\n+/* We're testing three aspects of isolation here.  First that isolation\n    occurs, second that if we have two null dereferences in a block that\n    that we delete everything from the first dereferece to the end of the\n-   block, regardless of which comes first in the immediate use iterator.  */\n+   block, regardless of which comes first in the immediate use iterator\n+   and finally that we set the RHS of the store to zero.  */\n /* { dg-final { scan-tree-dump-times \"__builtin_trap\" 1 \"isolate-paths\"} } */\n-/* { dg-final { scan-tree-dump-times \"->type\" 1 \"isolate-paths\"} } */\n+/* { dg-final { scan-tree-dump-times \"->type = 42\" 1 \"isolate-paths\"} } */\n+/* { dg-final { scan-tree-dump-times \"->type = 0\" 1 \"isolate-paths\"} } */\n /* { dg-final { scan-tree-dump-times \"->zzz\" 1 \"isolate-paths\"} } */\n /* { dg-final { cleanup-tree-dump \"isolate-paths\" } } */\n "}, {"sha": "a70871eba00c16cbe88099ad248a0b3c7f0e201d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/isolate-5.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab7a3d7c4ca285806bdcab129378dce88d0a110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab7a3d7c4ca285806bdcab129378dce88d0a110/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-5.c?ref=6ab7a3d7c4ca285806bdcab129378dce88d0a110", "patch": "@@ -0,0 +1,60 @@\n+\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-isolate-paths\" } */\n+\n+\n+struct demangle_component\n+{\n+\n+  int type;\n+  int zzz;\n+\n+};\n+\n+\n+struct d_info\n+{\n+  struct demangle_component *comps;\n+  int next_comp;\n+  int num_comps;\n+};\n+\n+\n+static struct demangle_component *\n+d_make_empty (struct d_info *di)\n+{\n+  struct demangle_component *p;\n+\n+  if (di->next_comp >= di->num_comps)\n+    return ((void *)0);\n+  p = &di->comps[di->next_comp];\n+  return p;\n+}\n+\n+\n+\n+struct demangle_component *\n+d_type (struct d_info *di)\n+{\n+   struct demangle_component *ret;\n+   ret = d_make_empty (di);\n+   foo (ret->type);\n+   bar (ret->zzz);\n+   return ret;\n+}\n+\n+/* We're testing two aspects of isolation here.  First that isolation\n+   occurs, second that if we have two null dereferences in a block that\n+   that we delete everything from the first dereferece to the end of the\n+   block, regardless of which comes first in the immediate use iterator.\n+\n+   We leave the 0->type in the IL, so expect to see ->type twice.  */\n+/* { dg-final { scan-tree-dump-times \"__builtin_trap\" 1 \"isolate-paths\"} } */\n+/* { dg-final { scan-tree-dump-times \"->type\" 2 \"isolate-paths\"} } */\n+/* { dg-final { scan-tree-dump-times \"->zzz\" 1 \"isolate-paths\"} } */\n+/* { dg-final { cleanup-tree-dump \"isolate-paths\" } } */\n+\n+\n+\n+\n+"}]}