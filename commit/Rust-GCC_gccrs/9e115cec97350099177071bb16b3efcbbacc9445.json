{"sha": "9e115cec97350099177071bb16b3efcbbacc9445", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUxMTVjZWM5NzM1MDA5OTE3NzA3MWJiMTZiM2VmY2JiYWNjOTQ0NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-11-08T20:17:42Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-11-08T20:17:42Z"}, "message": "Correct conversion/overflow behavior.\n\n\t* cvt.c (ignore_overflows): Move here from typeck.c.\n\t(ocp_convert): Use it.\n\t(cp_fold_convert): Use it.  Don't call rvalue.\n\t* typeck.c (build_static_cast_1): Don't use it.  Do call rvalue.\n\t* error.c (location_of): Handle expressions, too.\n\t* class.c (check_bitfield_decl): Set input_location around call to\n\tcxx_constant_value.\n\t* semantics.c (cxx_eval_outermost_constant_expr): Don't\n\tprint the expression if it already had TREE_OVERFLOW set.\n\t(reduced_constant_expression_p): Check TREE_OVERFLOW_P for C++98, too.\n\t(verify_constant): Allow overflow with a permerror if we're\n\tenforcing.\n\t(cxx_eval_outermost_constant_expr): Use verify_constant.\n\t(adjust_temp_type): Use cp_fold_convert.\n\t* decl.c (build_enumerator): Don't call constant_expression_warning.\n\t* decl2.c (grokbitfield): Likewise.\n\nFrom-SVN: r166453", "tree": {"sha": "29e021e2fec06d40962f55e47d182c721d950eae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29e021e2fec06d40962f55e47d182c721d950eae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e115cec97350099177071bb16b3efcbbacc9445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e115cec97350099177071bb16b3efcbbacc9445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e115cec97350099177071bb16b3efcbbacc9445", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e115cec97350099177071bb16b3efcbbacc9445/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1b2c3293fbe12f7fa3254af12e9d0ca98d89c5aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b2c3293fbe12f7fa3254af12e9d0ca98d89c5aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b2c3293fbe12f7fa3254af12e9d0ca98d89c5aa"}], "stats": {"total": 207, "additions": 132, "deletions": 75}, "files": [{"sha": "4f08ec3961751a9e1f09b0e048e3fe88ca46ff74", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -1,3 +1,23 @@\n+2010-11-08  Jason Merrill  <jason@redhat.com>\n+\n+\tCorrect conversion/overflow behavior.\n+\t* cvt.c (ignore_overflows): Move here from typeck.c.\n+\t(ocp_convert): Use it.\n+\t(cp_fold_convert): Use it.  Don't call rvalue.\n+\t* typeck.c (build_static_cast_1): Don't use it.  Do call rvalue.\n+\t* error.c (location_of): Handle expressions, too.\n+\t* class.c (check_bitfield_decl): Set input_location around call to\n+\tcxx_constant_value.\n+\t* semantics.c (cxx_eval_outermost_constant_expr): Don't\n+\tprint the expression if it already had TREE_OVERFLOW set.\n+\t(reduced_constant_expression_p): Check TREE_OVERFLOW_P for C++98, too.\n+\t(verify_constant): Allow overflow with a permerror if we're\n+\tenforcing.\n+\t(cxx_eval_outermost_constant_expr): Use verify_constant.\n+\t(adjust_temp_type): Use cp_fold_convert.\n+\t* decl.c (build_enumerator): Don't call constant_expression_warning.\n+\t* decl2.c (grokbitfield): Likewise.\n+\n 2010-11-06  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/46348"}, {"sha": "03951cfa4ea3ecd504ac6366b904d8c901baf3ec", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -2797,11 +2797,14 @@ check_bitfield_decl (tree field)\n     }\n   else\n     {\n+      location_t loc = input_location;\n       /* Avoid the non_lvalue wrapper added by fold for PLUS_EXPRs.  */\n       STRIP_NOPS (w);\n \n       /* detect invalid field size.  */\n+      input_location = DECL_SOURCE_LOCATION (field);\n       w = cxx_constant_value (w);\n+      input_location = loc;\n \n       if (TREE_CODE (w) != INTEGER_CST)\n \t{"}, {"sha": "2f7823f76d930b85a4087441a5348f19ae8937b6", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -543,12 +543,35 @@ force_rvalue (tree expr)\n }\n \n \f\n-/* Fold away simple conversions, but make sure the result is an rvalue.  */\n+/* If EXPR and ORIG are INTEGER_CSTs, return a version of EXPR that has\n+   TREE_OVERFLOW set only if it is set in ORIG.  Otherwise, return EXPR\n+   unchanged.  */\n+\n+static tree\n+ignore_overflows (tree expr, tree orig)\n+{\n+  if (TREE_CODE (expr) == INTEGER_CST\n+      && TREE_CODE (orig) == INTEGER_CST\n+      && TREE_OVERFLOW (expr) != TREE_OVERFLOW (orig))\n+    {\n+      gcc_assert (!TREE_OVERFLOW (orig));\n+      /* Ensure constant sharing.  */\n+      expr = build_int_cst_wide (TREE_TYPE (expr),\n+\t\t\t\t TREE_INT_CST_LOW (expr),\n+\t\t\t\t TREE_INT_CST_HIGH (expr));\n+    }\n+  return expr;\n+}\n+\n+/* Fold away simple conversions, but make sure TREE_OVERFLOW is set\n+   properly.  */\n \n tree\n cp_fold_convert (tree type, tree expr)\n {\n-  return rvalue (fold_convert (type, expr));\n+  tree conv = fold_convert (type, expr);\n+  conv = ignore_overflows (conv, expr);\n+  return conv;\n }\n \n /* C++ conversions, preference to static cast conversions.  */\n@@ -661,6 +684,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n   if (INTEGRAL_CODE_P (code))\n     {\n       tree intype = TREE_TYPE (e);\n+      tree converted;\n \n       if (TREE_CODE (type) == ENUMERAL_TYPE)\n \t{\n@@ -705,7 +729,10 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       if (code == BOOLEAN_TYPE)\n \treturn cp_truthvalue_conversion (e);\n \n-      return fold_if_not_in_template (convert_to_integer (type, e));\n+      converted = fold_if_not_in_template (convert_to_integer (type, e));\n+\n+      /* Ignore any integer overflow caused by the conversion.  */\n+      return ignore_overflows (converted, e);\n     }\n   if (NULLPTR_TYPE_P (type) && e && null_ptr_cst_p (e))\n     return nullptr_node;"}, {"sha": "c37284083687d88555d286b0e0ccfb4946e7eaa0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -11823,7 +11823,6 @@ build_enumerator (tree name, tree value, tree enumtype, location_t loc)\n \t  if (TREE_CODE (value) == INTEGER_CST)\n \t    {\n \t      value = perform_integral_promotions (value);\n-\t      constant_expression_warning (value);\n \t    }\n \t  else\n \t    {"}, {"sha": "e00549eca3b81887eb6d9d449a46a09e272d3689", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -1054,7 +1054,6 @@ grokbitfield (const cp_declarator *declarator,\n       if (!INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (TREE_TYPE (width)))\n \terror (\"width of bit-field %qD has non-integral type %qT\", value,\n \t       TREE_TYPE (width));\n-      constant_expression_warning (width);\n       DECL_INITIAL (value) = width;\n       SET_DECL_C_BIT_FIELD (value);\n     }"}, {"sha": "1560fc6047be211ac420b35d9d52660c5c0a3a73", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -2469,7 +2469,9 @@ location_of (tree t)\n   else if (TREE_CODE (t) == OVERLOAD)\n     t = OVL_FUNCTION (t);\n \n-  return DECL_SOURCE_LOCATION (t);\n+  if (DECL_P (t))\n+    return DECL_SOURCE_LOCATION (t);\n+  return EXPR_LOC_OR_HERE (t);\n }\n \n /* Now the interfaces from error et al to dump_type et al. Each takes an"}, {"sha": "494247e71b5fa6df6b7c8122f2726fad1e38c47b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -5789,7 +5789,7 @@ adjust_temp_type (tree type, tree temp)\n   if (TREE_CODE (temp) == CONSTRUCTOR)\n     return build_constructor (type, CONSTRUCTOR_ELTS (temp));\n   gcc_assert (SCALAR_TYPE_P (type));\n-  return fold_convert (type, temp);\n+  return cp_fold_convert (type, temp);\n }\n \n /* Subroutine of cxx_eval_call_expression.\n@@ -6003,13 +6003,13 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n   return result;\n }\n \n+/* FIXME speed this up, it's taking 16% of compile time on sieve testcase.  */\n+\n bool\n reduced_constant_expression_p (tree t)\n {\n-  /* FIXME speed this up, it's taking 16% of compile time on sieve testcase.  */\n-  if (cxx_dialect >= cxx0x && TREE_OVERFLOW_P (t))\n-    /* In C++0x, integer overflow makes this not a constant expression.\n-       FIXME arithmetic overflow is different from conversion truncation */\n+  if (TREE_OVERFLOW_P (t))\n+    /* Integer overflow makes this not a constant expression.  */\n     return false;\n   /* FIXME are we calling this too much?  */\n   return initializer_constant_valid_p (t, TREE_TYPE (t)) != NULL_TREE;\n@@ -6030,7 +6030,20 @@ verify_constant (tree t, bool allow_non_constant, bool *non_constant_p)\n   if (!*non_constant_p && !reduced_constant_expression_p (t))\n     {\n       if (!allow_non_constant)\n-\terror (\"%qE is not a constant expression\", t);\n+\t{\n+\t  /* If T was already folded to a _CST with TREE_OVERFLOW set,\n+\t     printing the folded constant isn't helpful.  */\n+\t  if (TREE_OVERFLOW_P (t))\n+\t    {\n+\t      permerror (input_location, \"overflow in constant expression\");\n+\t      /* If we're being permissive (and are in an enforcing\n+\t\t context), consider this constant.  */\n+\t      if (flag_permissive)\n+\t\treturn false;\n+\t    }\n+\t  else\n+\t    error (\"%q+E is not a constant expression\", t);\n+\t}\n       *non_constant_p = true;\n     }\n   return *non_constant_p;\n@@ -6895,12 +6908,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant)\n   tree r = cxx_eval_constant_expression (NULL, t, allow_non_constant,\n \t\t\t\t\t false, &non_constant_p);\n \n-  if (!non_constant_p && !reduced_constant_expression_p (r))\n-    {\n-      if (!allow_non_constant)\n-\terror (\"%qE is not a constant expression\", t);\n-      non_constant_p = true;\n-    }\n+  verify_constant (r, allow_non_constant, &non_constant_p);\n \n   if (non_constant_p && !allow_non_constant)\n     return error_mark_node;"}, {"sha": "cad881797182eedb9ee9efa94e2c8c756d8a6f36", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 42, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -5717,33 +5717,6 @@ convert_ptrmem (tree type, tree expr, bool allow_inverse_p,\n \t\t\t     allow_inverse_p, c_cast_p, complain);\n }\n \n-/* If EXPR is an INTEGER_CST and ORIG is an arithmetic constant, return\n-   a version of EXPR that has TREE_OVERFLOW set if it is set in ORIG.\n-   Otherwise, return EXPR unchanged.  */\n-\n-static tree\n-ignore_overflows (tree expr, tree orig)\n-{\n-  if (TREE_CODE (expr) == INTEGER_CST\n-      && CONSTANT_CLASS_P (orig)\n-      && TREE_CODE (orig) != STRING_CST\n-      && TREE_OVERFLOW (expr) != TREE_OVERFLOW (orig))\n-    {\n-      if (!TREE_OVERFLOW (orig))\n-\t/* Ensure constant sharing.  */\n-\texpr = build_int_cst_wide (TREE_TYPE (expr),\n-\t\t\t\t   TREE_INT_CST_LOW (expr),\n-\t\t\t\t   TREE_INT_CST_HIGH (expr));\n-      else\n-\t{\n-\t  /* Avoid clobbering a shared constant.  */\n-\t  expr = copy_node (expr);\n-\t  TREE_OVERFLOW (expr) = TREE_OVERFLOW (orig);\n-\t}\n-    }\n-  return expr;\n-}\n-\n /* Perform a static_cast from EXPR to TYPE.  When C_CAST_P is true,\n    this static_cast is being attempted as one of the possible casts\n    allowed by a C-style cast.  (In that case, accessibility of base\n@@ -5757,7 +5730,6 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n {\n   tree intype;\n   tree result;\n-  tree orig;\n \n   /* Assume the cast is valid.  */\n   *valid_p = true;\n@@ -5814,8 +5786,14 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n       expr = build_base_path (MINUS_EXPR, build_address (expr),\n \t\t\t      base, /*nonnull=*/false);\n       /* Convert the pointer to a reference -- but then remember that\n-\t there are no expressions with reference type in C++.  */\n-      return convert_from_reference (cp_fold_convert (type, expr));\n+\t there are no expressions with reference type in C++.\n+\n+         We call rvalue so that there's an actual tree code\n+         (NON_LVALUE_EXPR) for the static_cast; otherwise, if the operand\n+         is a variable with the same type, the conversion would get folded\n+         away, leaving just the variable and causing lvalue_kind to give\n+         the wrong answer.  */\n+      return convert_from_reference (rvalue (cp_fold_convert (type, expr)));\n     }\n \n   /* \"An lvalue of type cv1 T1 can be cast to type rvalue reference to\n@@ -5830,8 +5808,6 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n       return convert_from_reference (expr);\n     }\n \n-  orig = expr;\n-\n   /* Resolve overloaded address here rather than once in\n      implicit_conversion and again in the inverse code below.  */\n   if (TYPE_PTRMEMFUNC_P (type) && type_unknown_p (expr))\n@@ -5852,9 +5828,6 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n     {\n       result = convert_from_reference (result);\n \n-      /* Ignore any integer overflow caused by the cast.  */\n-      result = ignore_overflows (result, orig);\n-\n       /* [expr.static.cast]\n \n \t If T is a reference type, the result is an lvalue; otherwise,\n@@ -5894,13 +5867,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n        || SCALAR_FLOAT_TYPE_P (type))\n       && (INTEGRAL_OR_ENUMERATION_TYPE_P (intype)\n \t  || SCALAR_FLOAT_TYPE_P (intype)))\n-    {\n-      expr = ocp_convert (type, expr, CONV_C_CAST, LOOKUP_NORMAL);\n-\n-      /* Ignore any integer overflow caused by the cast.  */\n-      expr = ignore_overflows (expr, orig);\n-      return expr;\n-    }\n+    return ocp_convert (type, expr, CONV_C_CAST, LOOKUP_NORMAL);\n \n   if (TYPE_PTR_P (type) && TYPE_PTR_P (intype)\n       && CLASS_TYPE_P (TREE_TYPE (type))"}, {"sha": "7d2688e35476fa345bb7cd896821fc3c1c7c9f7a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -1,3 +1,11 @@\n+2010-11-08  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/expr/overflow1.C: New.\n+\t* g++.dg/warn/overflow-warn-1.C: Add expected diagnostics.\n+\t* g++.dg/warn/overflow-warn-3.C: Remove unnecessary line number.\n+\t* g++.dg/warn/overflow-warn-4.C: Add expected diagnostics.\n+\t* g++.dg/warn/overflow-warn-5.C: Don't expect wrong warning.\n+\n 2010-11-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc.dg/pr35442.c: Adapt warning."}, {"sha": "b67b4e42eddcf8ec90de8c5639f839834a6d0d37", "filename": "gcc/testsuite/g++.dg/expr/overflow1.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Foverflow1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Foverflow1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Foverflow1.C?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -0,0 +1,8 @@\n+#include <limits.h>\n+\n+enum E {\n+  A = (unsigned char)-1,\t/* OK */\n+  B = (signed char)UCHAR_MAX,\t/* implementation-defined */\n+  C = INT_MAX+1,     /* undefined (C)/ill-formed (C++) { dg-message \"\" } */\n+  D = UINT_MAX+1     /* OK */\n+};"}, {"sha": "22c512a4f8f779d4ecb357d9523c28ff9b3756b9", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-1.C", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -1,7 +1,7 @@\n /* Test for diagnostics for constant overflow.  */\n /* Origin: Joseph Myers <joseph@codesourcery.com> */\n /* { dg-do compile } */\n-/* { dg-options \"\" } */\n+/* { dg-options \"-fpermissive\" } */\n \n #include <limits.h>\n \n@@ -19,8 +19,10 @@ enum e {\n   E4 = 0 * (1 / 0), /* { dg-warning \"division by zero\" } */\n   /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n   E5 = INT_MAX + 1, /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n   /* Again, overflow in evaluated subexpression.  */\n   E6 = 0 * (INT_MAX + 1), /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n   /* A cast does not constitute overflow in conversion.  */\n   E7 = (char) INT_MAX\n };\n@@ -29,6 +31,7 @@ struct s {\n   int a;\n   int : 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n   int : 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" } */\n+  /* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n };\n \n void\n@@ -49,10 +52,10 @@ void *n = 0;\n    constants.  The third has the overflow in an unevaluated\n    subexpression, so is a null pointer constant.  */\n void *p = 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 51 } */\n+/* { dg-warning \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 54 } */\n void *q = 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 53 } */\n-void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 55 } */\n+/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 56 } */\n+void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } } */\n \n void\n g (int i)\n@@ -62,6 +65,7 @@ g (int i)\n     case 0 * (1/0): /* { dg-warning \"division by zero\" } */\n       ;\n     case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"integer overflow in expression\" } */\n+      /* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 67 } */\n       ;\n     }\n }"}, {"sha": "d88c87a53981bdd8f335a78a087d2e40ed14d817", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -57,7 +57,7 @@ void *p = 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" }\n \n void *q = 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n /* { dg-warning \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 58 } */\n-void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 60 } */\n+void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } } */\n \n void\n g (int i)"}, {"sha": "374d29428a802241e65d7b17f79427e9a650e150", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-4.C", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -11,7 +11,7 @@ enum e {\n   E1 = UINT_MAX + 1,\n   /* Overflow in an unevaluated part of an expression is OK (example\n      in the standard).  */\n-  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n+  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } } */\n   E3 = 1 / 0, /* { dg-warning \"division by zero\" } */\n   /* { dg-error \"enumerator value for 'E3' is not an integer constant|not a constant expression\" \"enum error\" { target *-*-* } 15 } */\n   /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n@@ -20,9 +20,11 @@ enum e {\n   /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n   E5 = INT_MAX + 1, /* { dg-warning \"integer overflow in expression\" } */\n   /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n+  /* { dg-error \"enumerator value for 'E5' is not an integer constant\" \"enum error\" { target *-*-* } 21 } */\n   /* Again, overflow in evaluated subexpression.  */\n   E6 = 0 * (INT_MAX + 1), /* { dg-warning \"integer overflow in expression\" } */\n-  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 25 } */\n+  /* { dg-error \"enumerator value for 'E6' is not an integer constant\" \"enum error\" { target *-*-* } 25 } */\n   /* A cast does not constitute overflow in conversion.  */\n   E7 = (char) INT_MAX\n };\n@@ -31,7 +33,8 @@ struct s {\n   int a;\n   int : 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n   int : 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" } */\n-  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n+  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 35 } */\n+  /* { dg-error \"bit-field .* width not an integer constant\" \"\" { target *-*-* } 35 } */\n };\n \n void\n@@ -53,11 +56,11 @@ void *n = 0;\n    constants.  The third has the overflow in an unevaluated\n    subexpression, so is a null pointer constant.  */\n void *p = 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 55 } */\n+/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 58 } */\n \n void *q = 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 58 } */\n-void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 60 } */\n+/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 61 } */\n+void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } } */\n \n void\n g (int i)\n@@ -67,7 +70,7 @@ g (int i)\n     case 0 * (1/0): /* { dg-warning \"division by zero\" } */\n       ;\n     case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"integer overflow in expression\" } */\n-      /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 69 } */\n+      /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 72 } */\n       ;\n     }\n }"}, {"sha": "bdfec4a6be19c1cc559d54457b18b4f52fd101ff", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-5.C", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-5.C?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -1,7 +1,11 @@\n /* PR c/27273 */\n /* { dg-do compile } */\n-/* { dg-options \"-Woverflow\" } */\n+\n+// This used to warn about \"overflow in implicit constant conversion\",\n+// which was wrong; 512 is never converted to unsigned char.  Rather, an\n+// appropriate warning would be that the & expression always evaluates to 0\n+// because of the limited range of unsigned char.\n \n unsigned char rx_async(unsigned char p) {\n-    return p & 512; /* { dg-warning \"overflow in implicit constant conversion\" } */\n+    return p & 512; /* { dg-warning \"\" \"\" { xfail *-*-* } } */\n }"}, {"sha": "d49f970a157e4d26d1a3b79f2c09e52dd6f54a92", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -1,3 +1,8 @@\n+2010-11-08  Jason Merrill  <jason@redhat.com>\n+\n+\t* testsuite/20_util/ratio/cons/cons_overflow_neg.cc: Adjust\n+\texpected error.\n+\n 2010-11-08  Benjamin Kosnik  <bkoz@redhat.com>\n \n         * include/std/complex (operator==, !=): Mark constexpr."}, {"sha": "e7f448deca19434a8e1b0077c399efafb015de6a", "filename": "libstdc++-v3/testsuite/20_util/ratio/cons/cons_overflow_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e115cec97350099177071bb16b3efcbbacc9445/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Fcons%2Fcons_overflow_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e115cec97350099177071bb16b3efcbbacc9445/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Fcons%2Fcons_overflow_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Fcons%2Fcons_overflow_neg.cc?ref=9e115cec97350099177071bb16b3efcbbacc9445", "patch": "@@ -52,6 +52,6 @@ test04()\n // { dg-error \"denominator cannot be zero\" \"\" { target *-*-* } 153 }\n // { dg-error \"out of range\" \"\" { target *-*-* } 154 }\n // { dg-error \"non-constant expression\" \"\" { target *-*-* } 59 }\n-// { dg-error \"is not a constant expression\" \"\" { target *-*-* } 59 }\n+// { dg-error \"overflow in constant expression\" \"\" { target *-*-* } 59 }\n // { dg-error \"not a member\" \"\" { target *-*-* } 162 }\n // { dg-error \"not a valid template argument\" \"\" { target *-*-* } 164 }"}]}