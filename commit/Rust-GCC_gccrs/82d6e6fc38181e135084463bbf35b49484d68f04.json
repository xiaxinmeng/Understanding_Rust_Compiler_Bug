{"sha": "82d6e6fc38181e135084463bbf35b49484d68f04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJkNmU2ZmMzODE4MWUxMzUwODQ0NjNiYmYzNWI0OTQ4NGQ2OGYwNA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-08-06T15:57:09Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-08-06T15:57:09Z"}, "message": "builtins.c (expand_builtin_profile_func): Avoid C++ keywords.\n\n\t* builtins.c (expand_builtin_profile_func): Avoid C++ keywords.\n\t* calls.c (avoid_likely_spilled_reg): Likewise.\n\t* cfgexpand.c (gimple_assign_rhs_to_tree): Likewise.\n\t* cgraph.c (cgraph_clone_edge, cgraph_clone_node): Likewise.\n\t* config/i386/i386.c (ix86_expand_special_args_builtin,\n\tix86_secondary_reload): Likewise.\n\t* except.c (struct eh_region, gen_eh_region_catch,\n\tremove_unreachable_regions, duplicate_eh_regions,\n\tassign_filter_values, build_post_landing_pads,\n\tsjlj_find_directly_reachable_regions, remove_eh_handler,\n\treachable_next_level, foreach_reachable_handler,\n\tcan_throw_internal_1, can_throw_external_1,\n\tcollect_one_action_chain): Likewise.\n\t* expr.c (expand_expr_real_1, vector_mode_valid_p): Likewise.\n\t* fold-const.c (twoval_comparison_p, eval_subst): Likewise.\n\t* function.c (update_temp_slot_address, instantiate_new_reg,\n\tinstantiate_virtual_regs_in_rtx,\n\tinstantiate_virtual_regs_in_insn): Likewise.\n\t* gimple.c (extract_ops_from_tree, gimple_seq_copy): Likewise.\n\t* gimplify.c (gimplify_call_expr, gimplify_init_constructor,\n\tgimplify_cleanup_point_expr): Likewise.\n\t* ipa-cp.c (ipcp_lattice_changed): Likewise.\n\t* passes.c (next_pass_1): Likewise.\n\t* print-tree.c (print_node_brief, print_node): Likewise.\n\t* profile.c (branch_prob): Likewise.\n\t* tree-dump.c (dump_register): Likewise.\n\t* tree-eh.c (replace_goto_queue_cond_clause, lower_catch):\n\tLikewise.\n\t* tree-inline.c (remap_ssa_name, remap_type_1, remap_blocks,\n\tcopy_statement_list, remap_gimple_op_r, copy_tree_body_r,\n\tcopy_edges_for_bb, copy_cfg_body, copy_tree_r,\n\tcopy_arguments_for_versioning, copy_static_chain): Likewise.\n\t* tree-into-ssa.c (names_replaced_by, add_to_repl_tbl,\n\tadd_new_name_mapping, register_new_name_mapping): Likewise.\n\t* tree-mudflap.c (mf_xform_derefs): Likewise.\n\t* tree-predcom.c (struct chain, dump_chain, replace_ref_with,\n\tget_init_expr, combine_chains): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t* tree-ssa-structalias.c (create_variable_info_for): Likewise.\n\t* tree-vrp.c (simplify_cond_using_ranges): Likewise.\n\t* tree.c (substitute_in_expr, iterative_hash_expr): Likewise.\n\t* value-prof.c (gimple_duplicate_stmt_histograms): Likewise.\n\nFrom-SVN: r138809", "tree": {"sha": "bdfccfe6a5eaa20f5e70f9bb36ae6a07f0e85aa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdfccfe6a5eaa20f5e70f9bb36ae6a07f0e85aa5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82d6e6fc38181e135084463bbf35b49484d68f04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82d6e6fc38181e135084463bbf35b49484d68f04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82d6e6fc38181e135084463bbf35b49484d68f04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82d6e6fc38181e135084463bbf35b49484d68f04/comments", "author": null, "committer": null, "parents": [{"sha": "01973e26724e32e61b3d6d580e2f3479646a5d35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01973e26724e32e61b3d6d580e2f3479646a5d35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01973e26724e32e61b3d6d580e2f3479646a5d35"}], "stats": {"total": 922, "additions": 485, "deletions": 437}, "files": [{"sha": "37c57db11b368ba041c756b64ccfde4d3b5d097c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -1,3 +1,48 @@\n+2008-08-06  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (expand_builtin_profile_func): Avoid C++ keywords.\n+\t* calls.c (avoid_likely_spilled_reg): Likewise.\n+\t* cfgexpand.c (gimple_assign_rhs_to_tree): Likewise.\n+\t* cgraph.c (cgraph_clone_edge, cgraph_clone_node): Likewise.\n+\t* config/i386/i386.c (ix86_expand_special_args_builtin,\n+\tix86_secondary_reload): Likewise.\n+\t* except.c (struct eh_region, gen_eh_region_catch,\n+\tremove_unreachable_regions, duplicate_eh_regions,\n+\tassign_filter_values, build_post_landing_pads,\n+\tsjlj_find_directly_reachable_regions, remove_eh_handler,\n+\treachable_next_level, foreach_reachable_handler,\n+\tcan_throw_internal_1, can_throw_external_1,\n+\tcollect_one_action_chain): Likewise.\n+\t* expr.c (expand_expr_real_1, vector_mode_valid_p): Likewise.\n+\t* fold-const.c (twoval_comparison_p, eval_subst): Likewise.\n+\t* function.c (update_temp_slot_address, instantiate_new_reg,\n+\tinstantiate_virtual_regs_in_rtx,\n+\tinstantiate_virtual_regs_in_insn): Likewise.\n+\t* gimple.c (extract_ops_from_tree, gimple_seq_copy): Likewise.\n+\t* gimplify.c (gimplify_call_expr, gimplify_init_constructor,\n+\tgimplify_cleanup_point_expr): Likewise.\n+\t* ipa-cp.c (ipcp_lattice_changed): Likewise.\n+\t* passes.c (next_pass_1): Likewise.\n+\t* print-tree.c (print_node_brief, print_node): Likewise.\n+\t* profile.c (branch_prob): Likewise.\n+\t* tree-dump.c (dump_register): Likewise.\n+\t* tree-eh.c (replace_goto_queue_cond_clause, lower_catch):\n+\tLikewise.\n+\t* tree-inline.c (remap_ssa_name, remap_type_1, remap_blocks,\n+\tcopy_statement_list, remap_gimple_op_r, copy_tree_body_r,\n+\tcopy_edges_for_bb, copy_cfg_body, copy_tree_r,\n+\tcopy_arguments_for_versioning, copy_static_chain): Likewise.\n+\t* tree-into-ssa.c (names_replaced_by, add_to_repl_tbl,\n+\tadd_new_name_mapping, register_new_name_mapping): Likewise.\n+\t* tree-mudflap.c (mf_xform_derefs): Likewise.\n+\t* tree-predcom.c (struct chain, dump_chain, replace_ref_with,\n+\tget_init_expr, combine_chains): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t* tree-ssa-structalias.c (create_variable_info_for): Likewise.\n+\t* tree-vrp.c (simplify_cond_using_ranges): Likewise.\n+\t* tree.c (substitute_in_expr, iterative_hash_expr): Likewise.\n+\t* value-prof.c (gimple_duplicate_stmt_histograms): Likewise.\n+\n 2008-08-06  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR middle-end/37010"}, {"sha": "088c916a9c1ef866a24e4ca5b012d8033df083a4", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -5576,18 +5576,18 @@ expand_builtin_sprintf (tree exp, rtx target, enum machine_mode mode)\n static rtx\n expand_builtin_profile_func (bool exitp)\n {\n-  rtx this, which;\n+  rtx this_rtx, which;\n \n-  this = DECL_RTL (current_function_decl);\n-  gcc_assert (MEM_P (this));\n-  this = XEXP (this, 0);\n+  this_rtx = DECL_RTL (current_function_decl);\n+  gcc_assert (MEM_P (this_rtx));\n+  this_rtx = XEXP (this_rtx, 0);\n \n   if (exitp)\n     which = profile_function_exit_libfunc;\n   else\n     which = profile_function_entry_libfunc;\n \n-  emit_library_call (which, LCT_NORMAL, VOIDmode, 2, this, Pmode,\n+  emit_library_call (which, LCT_NORMAL, VOIDmode, 2, this_rtx, Pmode,\n \t\t     expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n \t\t\t\t\t\t 0),\n \t\t     Pmode);"}, {"sha": "27aaaee6eff59da6f42044d5023a4cd556b38d89", "filename": "gcc/calls.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -1877,7 +1877,7 @@ shift_return_value (enum machine_mode mode, bool left_p, rtx value)\n static rtx\n avoid_likely_spilled_reg (rtx x)\n {\n-  rtx new;\n+  rtx new_rtx;\n \n   if (REG_P (x)\n       && HARD_REGISTER_P (x)\n@@ -1888,10 +1888,10 @@ avoid_likely_spilled_reg (rtx x)\n \t and the whole point of this function is to avoid\n \t using the hard register directly in such a situation.  */\n       generating_concat_p = 0;\n-      new = gen_reg_rtx (GET_MODE (x));\n+      new_rtx = gen_reg_rtx (GET_MODE (x));\n       generating_concat_p = 1;\n-      emit_move_insn (new, x);\n-      return new;\n+      emit_move_insn (new_rtx, x);\n+      return new_rtx;\n     }\n   return x;\n }"}, {"sha": "296d74858b466571744f3140e0a0c25f22e6b03b", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -50,20 +50,20 @@ tree\n gimple_assign_rhs_to_tree (gimple stmt)\n {\n   tree t;\n-  enum gimple_rhs_class class;\n+  enum gimple_rhs_class grhs_class;\n     \n-  class = get_gimple_rhs_class (gimple_expr_code (stmt));\n+  grhs_class = get_gimple_rhs_class (gimple_expr_code (stmt));\n \n-  if (class == GIMPLE_BINARY_RHS)\n+  if (grhs_class == GIMPLE_BINARY_RHS)\n     t = build2 (gimple_assign_rhs_code (stmt),\n \t\tTREE_TYPE (gimple_assign_lhs (stmt)),\n \t\tgimple_assign_rhs1 (stmt),\n \t\tgimple_assign_rhs2 (stmt));\n-  else if (class == GIMPLE_UNARY_RHS)\n+  else if (grhs_class == GIMPLE_UNARY_RHS)\n     t = build1 (gimple_assign_rhs_code (stmt),\n \t\tTREE_TYPE (gimple_assign_lhs (stmt)),\n \t\tgimple_assign_rhs1 (stmt));\n-  else if (class == GIMPLE_SINGLE_RHS)\n+  else if (grhs_class == GIMPLE_SINGLE_RHS)\n     t = gimple_assign_rhs1 (stmt);\n   else\n     gcc_unreachable ();"}, {"sha": "37ad9f1606f2c6e3132dca12d631d7c8588b0086", "filename": "gcc/cgraph.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -1159,25 +1159,25 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \t\t   gimple call_stmt, gcov_type count_scale, int freq_scale,\n \t\t   int loop_nest, bool update_original)\n {\n-  struct cgraph_edge *new;\n+  struct cgraph_edge *new_edge;\n   gcov_type count = e->count * count_scale / REG_BR_PROB_BASE;\n   gcov_type freq = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n \n   if (freq > CGRAPH_FREQ_MAX)\n     freq = CGRAPH_FREQ_MAX;\n-  new = cgraph_create_edge (n, e->callee, call_stmt, count, freq,\n+  new_edge = cgraph_create_edge (n, e->callee, call_stmt, count, freq,\n \t\t\t    e->loop_nest + loop_nest);\n \n-  new->inline_failed = e->inline_failed;\n-  new->indirect_call = e->indirect_call;\n+  new_edge->inline_failed = e->inline_failed;\n+  new_edge->indirect_call = e->indirect_call;\n   if (update_original)\n     {\n-      e->count -= new->count;\n+      e->count -= new_edge->count;\n       if (e->count < 0)\n \te->count = 0;\n     }\n-  cgraph_call_edge_duplication_hooks (e, new);\n-  return new;\n+  cgraph_call_edge_duplication_hooks (e, new_edge);\n+  return new_edge;\n }\n \n /* Create node representing clone of N executed COUNT times.  Decrease\n@@ -1190,25 +1190,25 @@ struct cgraph_node *\n cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n \t\t   int loop_nest, bool update_original)\n {\n-  struct cgraph_node *new = cgraph_create_node ();\n+  struct cgraph_node *new_node = cgraph_create_node ();\n   struct cgraph_edge *e;\n   gcov_type count_scale;\n \n-  new->decl = n->decl;\n-  new->origin = n->origin;\n-  if (new->origin)\n+  new_node->decl = n->decl;\n+  new_node->origin = n->origin;\n+  if (new_node->origin)\n     {\n-      new->next_nested = new->origin->nested;\n-      new->origin->nested = new;\n+      new_node->next_nested = new_node->origin->nested;\n+      new_node->origin->nested = new_node;\n     }\n-  new->analyzed = n->analyzed;\n-  new->local = n->local;\n-  new->global = n->global;\n-  new->rtl = n->rtl;\n-  new->master_clone = n->master_clone;\n-  new->count = count;\n+  new_node->analyzed = n->analyzed;\n+  new_node->local = n->local;\n+  new_node->global = n->global;\n+  new_node->rtl = n->rtl;\n+  new_node->master_clone = n->master_clone;\n+  new_node->count = count;\n   if (n->count)\n-    count_scale = new->count * REG_BR_PROB_BASE / n->count;\n+    count_scale = new_node->count * REG_BR_PROB_BASE / n->count;\n   else\n     count_scale = 0;\n   if (update_original)\n@@ -1219,17 +1219,17 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n     }\n \n   for (e = n->callees;e; e=e->next_callee)\n-    cgraph_clone_edge (e, new, e->call_stmt, count_scale, freq, loop_nest,\n+    cgraph_clone_edge (e, new_node, e->call_stmt, count_scale, freq, loop_nest,\n \t\t       update_original);\n \n-  new->next_clone = n->next_clone;\n-  new->prev_clone = n;\n-  n->next_clone = new;\n-  if (new->next_clone)\n-    new->next_clone->prev_clone = new;\n+  new_node->next_clone = n->next_clone;\n+  new_node->prev_clone = n;\n+  n->next_clone = new_node;\n+  if (new_node->next_clone)\n+    new_node->next_clone->prev_clone = new_node;\n \n-  cgraph_call_node_duplication_hooks (n, new);\n-  return new;\n+  cgraph_call_node_duplication_hooks (n, new_node);\n+  return new_node;\n }\n \n /* Return true if N is an master_clone, (see cgraph_master_clone).  */"}, {"sha": "37f00faff092589eed1914e7030b62ced30268be", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -22434,7 +22434,7 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n   bool last_arg_constant = false;\n   const struct insn_data *insn_p = &insn_data[icode];\n   enum machine_mode tmode = insn_p->operand[0].mode;\n-  enum { load, store } class;\n+  enum { load, store } klass;\n \n   switch ((enum ix86_special_builtin_type) d->flag)\n     {\n@@ -22446,7 +22446,7 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n     case V4SF_FTYPE_PCFLOAT:\n     case V2DF_FTYPE_PCDOUBLE:\n       nargs = 1;\n-      class = load;\n+      klass = load;\n       memory = 0;\n       break;\n     case VOID_FTYPE_PV2SF_V4SF:\n@@ -22457,14 +22457,14 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n     case VOID_FTYPE_PDI_DI:\n     case VOID_FTYPE_PINT_INT:\n       nargs = 1;\n-      class = store;\n+      klass = store;\n       /* Reserve memory operand for target.  */\n       memory = ARRAY_SIZE (args);\n       break;\n     case V4SF_FTYPE_V4SF_PCV2SF:\n     case V2DF_FTYPE_V2DF_PCDOUBLE:\n       nargs = 2;\n-      class = load;\n+      klass = load;\n       memory = 1;\n       break;\n     default:\n@@ -22473,7 +22473,7 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n \n   gcc_assert (nargs <= ARRAY_SIZE (args));\n \n-  if (class == store)\n+  if (klass == store)\n     {\n       arg = CALL_EXPR_ARG (exp, 0);\n       op = expand_normal (arg);\n@@ -22550,7 +22550,7 @@ ix86_expand_special_args_builtin (const struct builtin_description *d,\n   if (! pat)\n     return 0;\n   emit_insn (pat);\n-  return class == store ? 0 : target;\n+  return klass == store ? 0 : target;\n }\n \n /* Return the integer constant in ARG.  Constrain it to be in the range\n@@ -23417,16 +23417,16 @@ ix86_preferred_output_reload_class (rtx x, enum reg_class regclass)\n }\n \n static enum reg_class\n-ix86_secondary_reload (bool in_p, rtx x, enum reg_class class,\n+ix86_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n \t\t       enum machine_mode mode,\n \t\t       secondary_reload_info *sri ATTRIBUTE_UNUSED)\n {\n   /* QImode spills from non-QI registers require\n      intermediate register on 32bit targets.  */\n   if (!in_p && mode == QImode && !TARGET_64BIT\n-      && (class == GENERAL_REGS\n-\t  || class == LEGACY_REGS\n-\t  || class == INDEX_REGS))\n+      && (rclass == GENERAL_REGS\n+\t  || rclass == LEGACY_REGS\n+\t  || rclass == INDEX_REGS))\n     {\n       int regno;\n "}, {"sha": "77a3049ba5e889d79a48bb4a31a82eba65cbdca1", "filename": "gcc/except.c", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -148,9 +148,9 @@ struct eh_region GTY(())\n     /* A list of catch blocks, a surrounding try block,\n        and the label for continuing after a catch.  */\n     struct eh_region_u_try {\n-      struct eh_region *catch;\n+      struct eh_region *eh_catch;\n       struct eh_region *last_catch;\n-    } GTY ((tag (\"ERT_TRY\"))) try;\n+    } GTY ((tag (\"ERT_TRY\"))) eh_try;\n \n     /* The list through the catch handlers, the list of type objects\n        matched, and the list of associated filters.  */\n@@ -159,7 +159,7 @@ struct eh_region GTY(())\n       struct eh_region *prev_catch;\n       tree type_list;\n       tree filter_list;\n-    } GTY ((tag (\"ERT_CATCH\"))) catch;\n+    } GTY ((tag (\"ERT_CATCH\"))) eh_catch;\n \n     /* A tree_list of allowed types.  */\n     struct eh_region_u_allowed {\n@@ -171,7 +171,7 @@ struct eh_region GTY(())\n        for a throw.  */\n     struct eh_region_u_throw {\n       tree type;\n-    } GTY ((tag (\"ERT_THROW\"))) throw;\n+    } GTY ((tag (\"ERT_THROW\"))) eh_throw;\n \n     /* Retain the cleanup expression even after expansion so that\n        we can match up fixup regions.  */\n@@ -479,14 +479,14 @@ gen_eh_region_catch (struct eh_region *t, tree type_or_list)\n     }\n \n   c = gen_eh_region (ERT_CATCH, t->outer);\n-  c->u.catch.type_list = type_list;\n-  l = t->u.try.last_catch;\n-  c->u.catch.prev_catch = l;\n+  c->u.eh_catch.type_list = type_list;\n+  l = t->u.eh_try.last_catch;\n+  c->u.eh_catch.prev_catch = l;\n   if (l)\n-    l->u.catch.next_catch = c;\n+    l->u.eh_catch.next_catch = c;\n   else\n-    t->u.try.catch = c;\n-  t->u.try.last_catch = c;\n+    t->u.eh_try.eh_catch = c;\n+  t->u.eh_try.last_catch = c;\n \n   return c;\n }\n@@ -683,7 +683,7 @@ remove_unreachable_regions (rtx insns)\n \t\t/* TRY regions are reachable if any of its CATCH regions\n \t\t   are reachable.  */\n \t\tstruct eh_region *c;\n-\t\tfor (c = r->u.try.catch; c ; c = c->u.catch.next_catch)\n+\t\tfor (c = r->u.eh_try.eh_catch; c ; c = c->u.eh_catch.next_catch)\n \t\t  if (reachable[c->region_number])\n \t\t    {\n \t\t      kill_it = false;\n@@ -988,17 +988,17 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n       switch (cur->type)\n \t{\n \tcase ERT_TRY:\n-\t  if (cur->u.try.catch)\n-\t    REMAP (cur->u.try.catch);\n-\t  if (cur->u.try.last_catch)\n-\t    REMAP (cur->u.try.last_catch);\n+\t  if (cur->u.eh_try.eh_catch)\n+\t    REMAP (cur->u.eh_try.eh_catch);\n+\t  if (cur->u.eh_try.last_catch)\n+\t    REMAP (cur->u.eh_try.last_catch);\n \t  break;\n \n \tcase ERT_CATCH:\n-\t  if (cur->u.catch.next_catch)\n-\t    REMAP (cur->u.catch.next_catch);\n-\t  if (cur->u.catch.prev_catch)\n-\t    REMAP (cur->u.catch.prev_catch);\n+\t  if (cur->u.eh_catch.next_catch)\n+\t    REMAP (cur->u.eh_catch.next_catch);\n+\t  if (cur->u.eh_catch.prev_catch)\n+\t    REMAP (cur->u.eh_catch.prev_catch);\n \t  break;\n \n \tcase ERT_CLEANUP:\n@@ -1290,21 +1290,21 @@ assign_filter_values (void)\n \tcase ERT_CATCH:\n \t  /* Whatever type_list is (NULL or true list), we build a list\n \t     of filters for the region.  */\n-\t  r->u.catch.filter_list = NULL_TREE;\n+\t  r->u.eh_catch.filter_list = NULL_TREE;\n \n-\t  if (r->u.catch.type_list != NULL)\n+\t  if (r->u.eh_catch.type_list != NULL)\n \t    {\n \t      /* Get a filter value for each of the types caught and store\n \t\t them in the region's dedicated list.  */\n-\t      tree tp_node = r->u.catch.type_list;\n+\t      tree tp_node = r->u.eh_catch.type_list;\n \n \t      for (;tp_node; tp_node = TREE_CHAIN (tp_node))\n \t\t{\n \t\t  int flt = add_ttypes_entry (ttypes, TREE_VALUE (tp_node));\n \t\t  tree flt_node = build_int_cst (NULL_TREE, flt);\n \n-\t\t  r->u.catch.filter_list\n-\t\t    = tree_cons (NULL_TREE, flt_node, r->u.catch.filter_list);\n+\t\t  r->u.eh_catch.filter_list\n+\t\t    = tree_cons (NULL_TREE, flt_node, r->u.eh_catch.filter_list);\n \t\t}\n \t    }\n \t  else\n@@ -1314,8 +1314,8 @@ assign_filter_values (void)\n \t      int flt = add_ttypes_entry (ttypes, NULL);\n \t      tree flt_node = build_int_cst (NULL_TREE, flt);\n \n-\t      r->u.catch.filter_list\n-\t\t= tree_cons (NULL_TREE, flt_node, r->u.catch.filter_list);\n+\t      r->u.eh_catch.filter_list\n+\t\t= tree_cons (NULL_TREE, flt_node, r->u.eh_catch.filter_list);\n \t    }\n \n \t  break;\n@@ -1400,17 +1400,17 @@ build_post_landing_pads (void)\n \t     Rapid prototyping sez a sequence of ifs.  */\n \t  {\n \t    struct eh_region *c;\n-\t    for (c = region->u.try.catch; c ; c = c->u.catch.next_catch)\n+\t    for (c = region->u.eh_try.eh_catch; c ; c = c->u.eh_catch.next_catch)\n \t      {\n-\t\tif (c->u.catch.type_list == NULL)\n+\t\tif (c->u.eh_catch.type_list == NULL)\n \t\t  emit_jump (c->label);\n \t\telse\n \t\t  {\n \t\t    /* Need for one cmp/jump per type caught. Each type\n \t\t       list entry has a matching entry in the filter list\n \t\t       (see assign_filter_values).  */\n-\t\t    tree tp_node = c->u.catch.type_list;\n-\t\t    tree flt_node = c->u.catch.filter_list;\n+\t\t    tree tp_node = c->u.eh_catch.type_list;\n+\t\t    tree flt_node = c->u.eh_catch.filter_list;\n \n \t\t    for (; tp_node; )\n \t\t      {\n@@ -1437,7 +1437,7 @@ build_post_landing_pads (void)\n \t  seq = get_insns ();\n \t  end_sequence ();\n \n-\t  emit_to_new_bb_before (seq, region->u.try.catch->label);\n+\t  emit_to_new_bb_before (seq, region->u.eh_try.eh_catch->label);\n \n \t  break;\n \n@@ -1651,7 +1651,7 @@ sjlj_find_directly_reachable_regions (struct sjlj_lp_info *lp_info)\n       type_thrown = NULL_TREE;\n       if (region->type == ERT_THROW)\n \t{\n-\t  type_thrown = region->u.throw.type;\n+\t  type_thrown = region->u.eh_throw.type;\n \t  region = region->outer;\n \t}\n \n@@ -2204,28 +2204,28 @@ remove_eh_handler (struct eh_region *region)\n \n   if (region->type == ERT_CATCH)\n     {\n-      struct eh_region *try, *next, *prev;\n+      struct eh_region *eh_try, *next, *prev;\n \n-      for (try = region->next_peer;\n-\t   try->type == ERT_CATCH;\n-\t   try = try->next_peer)\n+      for (eh_try = region->next_peer;\n+\t   eh_try->type == ERT_CATCH;\n+\t   eh_try = eh_try->next_peer)\n \tcontinue;\n-      gcc_assert (try->type == ERT_TRY);\n+      gcc_assert (eh_try->type == ERT_TRY);\n \n-      next = region->u.catch.next_catch;\n-      prev = region->u.catch.prev_catch;\n+      next = region->u.eh_catch.next_catch;\n+      prev = region->u.eh_catch.prev_catch;\n \n       if (next)\n-\tnext->u.catch.prev_catch = prev;\n+\tnext->u.eh_catch.prev_catch = prev;\n       else\n-\ttry->u.try.last_catch = prev;\n+\teh_try->u.eh_try.last_catch = prev;\n       if (prev)\n-\tprev->u.catch.next_catch = next;\n+\tprev->u.eh_catch.next_catch = next;\n       else\n \t{\n-\t  try->u.try.catch = next;\n+\t  eh_try->u.eh_try.eh_catch = next;\n \t  if (! next)\n-\t    remove_eh_handler (try);\n+\t    remove_eh_handler (eh_try);\n \t}\n     }\n }\n@@ -2388,10 +2388,10 @@ reachable_next_level (struct eh_region *region, tree type_thrown,\n \tstruct eh_region *c;\n \tenum reachable_code ret = RNL_NOT_CAUGHT;\n \n-\tfor (c = region->u.try.catch; c ; c = c->u.catch.next_catch)\n+\tfor (c = region->u.eh_try.eh_catch; c ; c = c->u.eh_catch.next_catch)\n \t  {\n \t    /* A catch-all handler ends the search.  */\n-\t    if (c->u.catch.type_list == NULL)\n+\t    if (c->u.eh_catch.type_list == NULL)\n \t      {\n \t\tadd_reachable_handler (info, region, c);\n \t\treturn RNL_CAUGHT;\n@@ -2400,7 +2400,7 @@ reachable_next_level (struct eh_region *region, tree type_thrown,\n \t    if (type_thrown)\n \t      {\n \t\t/* If we have at least one type match, end the search.  */\n-\t\ttree tp_node = c->u.catch.type_list;\n+\t\ttree tp_node = c->u.eh_catch.type_list;\n \n \t\tfor (; tp_node; tp_node = TREE_CHAIN (tp_node))\n \t\t  {\n@@ -2438,7 +2438,7 @@ reachable_next_level (struct eh_region *region, tree type_thrown,\n \t      ret = RNL_MAYBE_CAUGHT;\n \t    else\n \t      {\n-\t\ttree tp_node = c->u.catch.type_list;\n+\t\ttree tp_node = c->u.eh_catch.type_list;\n \t\tbool maybe_reachable = false;\n \n \t\t/* Compute the potential reachability of this handler and\n@@ -2562,7 +2562,7 @@ foreach_reachable_handler (int region_number, bool is_resx,\n     }\n   else if (region->type == ERT_THROW)\n     {\n-      type_thrown = region->u.throw.type;\n+      type_thrown = region->u.eh_throw.type;\n       region = region->outer;\n     }\n \n@@ -2645,7 +2645,7 @@ can_throw_internal_1 (int region_number, bool is_resx)\n     region = region->outer;\n   else if (region->type == ERT_THROW)\n     {\n-      type_thrown = region->u.throw.type;\n+      type_thrown = region->u.eh_throw.type;\n       region = region->outer;\n     }\n \n@@ -2705,7 +2705,7 @@ can_throw_external_1 (int region_number, bool is_resx)\n     region = region->outer;\n   else if (region->type == ERT_THROW)\n     {\n-      type_thrown = region->u.throw.type;\n+      type_thrown = region->u.eh_throw.type;\n       region = region->outer;\n     }\n \n@@ -3109,14 +3109,14 @@ collect_one_action_chain (htab_t ar_hash, struct eh_region *region)\n \t search outer regions.  Use a magic -3 value to record\n \t that we haven't done the outer search.  */\n       next = -3;\n-      for (c = region->u.try.last_catch; c ; c = c->u.catch.prev_catch)\n+      for (c = region->u.eh_try.last_catch; c ; c = c->u.eh_catch.prev_catch)\n \t{\n-\t  if (c->u.catch.type_list == NULL)\n+\t  if (c->u.eh_catch.type_list == NULL)\n \t    {\n \t      /* Retrieve the filter from the head of the filter list\n \t\t where we have stored it (see assign_filter_values).  */\n \t      int filter\n-\t\t= TREE_INT_CST_LOW (TREE_VALUE (c->u.catch.filter_list));\n+\t\t= TREE_INT_CST_LOW (TREE_VALUE (c->u.eh_catch.filter_list));\n \n \t      next = add_action_record (ar_hash, filter, 0);\n \t    }\n@@ -3141,7 +3141,7 @@ collect_one_action_chain (htab_t ar_hash, struct eh_region *region)\n \t\t    next = add_action_record (ar_hash, 0, 0);\n \t\t}\n \n-\t      flt_node = c->u.catch.filter_list;\n+\t      flt_node = c->u.eh_catch.filter_list;\n \t      for (; flt_node; flt_node = TREE_CHAIN (flt_node))\n \t\t{\n \t\t  int filter = TREE_INT_CST_LOW (TREE_VALUE (flt_node));"}, {"sha": "109ddebe5dc228bd04b5cf59b51a99288ff85d9e", "filename": "gcc/expr.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -7944,20 +7944,20 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    if (mode == BLKmode)\n \t      {\n \t\tHOST_WIDE_INT size = GET_MODE_BITSIZE (ext_mode);\n-\t\trtx new;\n+\t\trtx new_rtx;\n \n \t\t/* If the reference doesn't use the alias set of its type,\n \t\t   we cannot create the temporary using that type.  */\n \t\tif (component_uses_parent_alias_set (exp))\n \t\t  {\n-\t\t    new = assign_stack_local (ext_mode, size, 0);\n-\t\t    set_mem_alias_set (new, get_alias_set (exp));\n+\t\t    new_rtx = assign_stack_local (ext_mode, size, 0);\n+\t\t    set_mem_alias_set (new_rtx, get_alias_set (exp));\n \t\t  }\n \t\telse\n-\t\t  new = assign_stack_temp_for_type (ext_mode, size, 0, type);\n+\t\t  new_rtx = assign_stack_temp_for_type (ext_mode, size, 0, type);\n \n-\t\temit_move_insn (new, op0);\n-\t\top0 = copy_rtx (new);\n+\t\temit_move_insn (new_rtx, op0);\n+\t\top0 = copy_rtx (new_rtx);\n \t\tPUT_MODE (op0, BLKmode);\n \t\tset_mem_attributes (op0, exp, 1);\n \t      }\n@@ -8198,9 +8198,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      HOST_WIDE_INT temp_size\n \t\t= MAX (int_size_in_bytes (inner_type),\n \t\t       (HOST_WIDE_INT) GET_MODE_SIZE (TYPE_MODE (type)));\n-\t      rtx new = assign_stack_temp_for_type (TYPE_MODE (type),\n-\t\t\t\t\t\t    temp_size, 0, type);\n-\t      rtx new_with_op0_mode = adjust_address (new, GET_MODE (op0), 0);\n+\t      rtx new_rtx = assign_stack_temp_for_type (TYPE_MODE (type),\n+\t\t\t\t\t\t\ttemp_size, 0, type);\n+\t      rtx new_with_op0_mode = adjust_address (new_rtx, GET_MODE (op0), 0);\n \n \t      gcc_assert (!TREE_ADDRESSABLE (exp));\n \n@@ -8212,7 +8212,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      else\n \t\temit_move_insn (new_with_op0_mode, op0);\n \n-\t      op0 = new;\n+\t      op0 = new_rtx;\n \t    }\n \n \t  op0 = adjust_address (op0, TYPE_MODE (type), 0);\n@@ -9997,16 +9997,16 @@ try_tablejump (tree index_type, tree index_expr, tree minval, tree range,\n int\n vector_mode_valid_p (enum machine_mode mode)\n {\n-  enum mode_class class = GET_MODE_CLASS (mode);\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n   enum machine_mode innermode;\n \n   /* Doh!  What's going on?  */\n-  if (class != MODE_VECTOR_INT\n-      && class != MODE_VECTOR_FLOAT\n-      && class != MODE_VECTOR_FRACT\n-      && class != MODE_VECTOR_UFRACT\n-      && class != MODE_VECTOR_ACCUM\n-      && class != MODE_VECTOR_UACCUM)\n+  if (mclass != MODE_VECTOR_INT\n+      && mclass != MODE_VECTOR_FLOAT\n+      && mclass != MODE_VECTOR_FRACT\n+      && mclass != MODE_VECTOR_UFRACT\n+      && mclass != MODE_VECTOR_ACCUM\n+      && mclass != MODE_VECTOR_UACCUM)\n     return 0;\n \n   /* Hardware support.  Woo hoo!  */"}, {"sha": "cb693d60c115e3bda782b14f055e47f6d0edd527", "filename": "gcc/fold-const.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -3391,29 +3391,29 @@ static int\n twoval_comparison_p (tree arg, tree *cval1, tree *cval2, int *save_p)\n {\n   enum tree_code code = TREE_CODE (arg);\n-  enum tree_code_class class = TREE_CODE_CLASS (code);\n+  enum tree_code_class tclass = TREE_CODE_CLASS (code);\n \n   /* We can handle some of the tcc_expression cases here.  */\n-  if (class == tcc_expression && code == TRUTH_NOT_EXPR)\n-    class = tcc_unary;\n-  else if (class == tcc_expression\n+  if (tclass == tcc_expression && code == TRUTH_NOT_EXPR)\n+    tclass = tcc_unary;\n+  else if (tclass == tcc_expression\n \t   && (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR\n \t       || code == COMPOUND_EXPR))\n-    class = tcc_binary;\n+    tclass = tcc_binary;\n \n-  else if (class == tcc_expression && code == SAVE_EXPR\n+  else if (tclass == tcc_expression && code == SAVE_EXPR\n \t   && ! TREE_SIDE_EFFECTS (TREE_OPERAND (arg, 0)))\n     {\n       /* If we've already found a CVAL1 or CVAL2, this expression is\n \t two complex to handle.  */\n       if (*cval1 || *cval2)\n \treturn 0;\n \n-      class = tcc_unary;\n+      tclass = tcc_unary;\n       *save_p = 1;\n     }\n \n-  switch (class)\n+  switch (tclass)\n     {\n     case tcc_unary:\n       return twoval_comparison_p (TREE_OPERAND (arg, 0), cval1, cval2, save_p);\n@@ -3484,16 +3484,16 @@ eval_subst (tree arg, tree old0, tree new0, tree old1, tree new1)\n {\n   tree type = TREE_TYPE (arg);\n   enum tree_code code = TREE_CODE (arg);\n-  enum tree_code_class class = TREE_CODE_CLASS (code);\n+  enum tree_code_class tclass = TREE_CODE_CLASS (code);\n \n   /* We can handle some of the tcc_expression cases here.  */\n-  if (class == tcc_expression && code == TRUTH_NOT_EXPR)\n-    class = tcc_unary;\n-  else if (class == tcc_expression\n+  if (tclass == tcc_expression && code == TRUTH_NOT_EXPR)\n+    tclass = tcc_unary;\n+  else if (tclass == tcc_expression\n \t   && (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR))\n-    class = tcc_binary;\n+    tclass = tcc_binary;\n \n-  switch (class)\n+  switch (tclass)\n     {\n     case tcc_unary:\n       return fold_build1 (code, type,"}, {"sha": "b3f5cbffa45cc8db3f149cdbd33ce0712d13f53b", "filename": "gcc/function.c", "status": "modified", "additions": 66, "deletions": 65, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -932,59 +932,60 @@ find_temp_slot_from_address (rtx x)\n   return 0;\n }\n \n-/* Indicate that NEW is an alternate way of referring to the temp slot\n-   that previously was known by OLD.  */\n+/* Indicate that NEW_RTX is an alternate way of referring to the temp\n+   slot that previously was known by OLD_RTX.  */\n \n void\n-update_temp_slot_address (rtx old, rtx new)\n+update_temp_slot_address (rtx old_rtx, rtx new_rtx)\n {\n   struct temp_slot *p;\n \n-  if (rtx_equal_p (old, new))\n+  if (rtx_equal_p (old_rtx, new_rtx))\n     return;\n \n-  p = find_temp_slot_from_address (old);\n+  p = find_temp_slot_from_address (old_rtx);\n \n-  /* If we didn't find one, see if both OLD is a PLUS.  If so, and NEW\n-     is a register, see if one operand of the PLUS is a temporary\n-     location.  If so, NEW points into it.  Otherwise, if both OLD and\n-     NEW are a PLUS and if there is a register in common between them.\n-     If so, try a recursive call on those values.  */\n+  /* If we didn't find one, see if both OLD_RTX is a PLUS.  If so, and\n+     NEW_RTX is a register, see if one operand of the PLUS is a\n+     temporary location.  If so, NEW_RTX points into it.  Otherwise,\n+     if both OLD_RTX and NEW_RTX are a PLUS and if there is a register\n+     in common between them.  If so, try a recursive call on those\n+     values.  */\n   if (p == 0)\n     {\n-      if (GET_CODE (old) != PLUS)\n+      if (GET_CODE (old_rtx) != PLUS)\n \treturn;\n \n-      if (REG_P (new))\n+      if (REG_P (new_rtx))\n \t{\n-\t  update_temp_slot_address (XEXP (old, 0), new);\n-\t  update_temp_slot_address (XEXP (old, 1), new);\n+\t  update_temp_slot_address (XEXP (old_rtx, 0), new_rtx);\n+\t  update_temp_slot_address (XEXP (old_rtx, 1), new_rtx);\n \t  return;\n \t}\n-      else if (GET_CODE (new) != PLUS)\n+      else if (GET_CODE (new_rtx) != PLUS)\n \treturn;\n \n-      if (rtx_equal_p (XEXP (old, 0), XEXP (new, 0)))\n-\tupdate_temp_slot_address (XEXP (old, 1), XEXP (new, 1));\n-      else if (rtx_equal_p (XEXP (old, 1), XEXP (new, 0)))\n-\tupdate_temp_slot_address (XEXP (old, 0), XEXP (new, 1));\n-      else if (rtx_equal_p (XEXP (old, 0), XEXP (new, 1)))\n-\tupdate_temp_slot_address (XEXP (old, 1), XEXP (new, 0));\n-      else if (rtx_equal_p (XEXP (old, 1), XEXP (new, 1)))\n-\tupdate_temp_slot_address (XEXP (old, 0), XEXP (new, 0));\n+      if (rtx_equal_p (XEXP (old_rtx, 0), XEXP (new_rtx, 0)))\n+\tupdate_temp_slot_address (XEXP (old_rtx, 1), XEXP (new_rtx, 1));\n+      else if (rtx_equal_p (XEXP (old_rtx, 1), XEXP (new_rtx, 0)))\n+\tupdate_temp_slot_address (XEXP (old_rtx, 0), XEXP (new_rtx, 1));\n+      else if (rtx_equal_p (XEXP (old_rtx, 0), XEXP (new_rtx, 1)))\n+\tupdate_temp_slot_address (XEXP (old_rtx, 1), XEXP (new_rtx, 0));\n+      else if (rtx_equal_p (XEXP (old_rtx, 1), XEXP (new_rtx, 1)))\n+\tupdate_temp_slot_address (XEXP (old_rtx, 0), XEXP (new_rtx, 0));\n \n       return;\n     }\n \n   /* Otherwise add an alias for the temp's address.  */\n   else if (p->address == 0)\n-    p->address = new;\n+    p->address = new_rtx;\n   else\n     {\n       if (GET_CODE (p->address) != EXPR_LIST)\n \tp->address = gen_rtx_EXPR_LIST (VOIDmode, p->address, NULL_RTX);\n \n-      p->address = gen_rtx_EXPR_LIST (VOIDmode, new, p->address);\n+      p->address = gen_rtx_EXPR_LIST (VOIDmode, new_rtx, p->address);\n     }\n }\n \n@@ -1210,7 +1211,7 @@ static int cfa_offset;\n static rtx\n instantiate_new_reg (rtx x, HOST_WIDE_INT *poffset)\n {\n-  rtx new;\n+  rtx new_rtx;\n   HOST_WIDE_INT offset;\n \n   if (x == virtual_incoming_args_rtx)\n@@ -1219,32 +1220,32 @@ instantiate_new_reg (rtx x, HOST_WIDE_INT *poffset)\n         {\n \t  /* Replace virtual_incoming_args_rtx with internal arg\n \t     pointer if DRAP is used to realign stack.  */\n-          new = crtl->args.internal_arg_pointer;\n+          new_rtx = crtl->args.internal_arg_pointer;\n           offset = 0;\n         }\n       else\n-        new = arg_pointer_rtx, offset = in_arg_offset;\n+        new_rtx = arg_pointer_rtx, offset = in_arg_offset;\n     }\n   else if (x == virtual_stack_vars_rtx)\n-    new = frame_pointer_rtx, offset = var_offset;\n+    new_rtx = frame_pointer_rtx, offset = var_offset;\n   else if (x == virtual_stack_dynamic_rtx)\n-    new = stack_pointer_rtx, offset = dynamic_offset;\n+    new_rtx = stack_pointer_rtx, offset = dynamic_offset;\n   else if (x == virtual_outgoing_args_rtx)\n-    new = stack_pointer_rtx, offset = out_arg_offset;\n+    new_rtx = stack_pointer_rtx, offset = out_arg_offset;\n   else if (x == virtual_cfa_rtx)\n     {\n #ifdef FRAME_POINTER_CFA_OFFSET\n-      new = frame_pointer_rtx;\n+      new_rtx = frame_pointer_rtx;\n #else\n-      new = arg_pointer_rtx;\n+      new_rtx = arg_pointer_rtx;\n #endif\n       offset = cfa_offset;\n     }\n   else\n     return NULL_RTX;\n \n   *poffset = offset;\n-  return new;\n+  return new_rtx;\n }\n \n /* A subroutine of instantiate_virtual_regs, called via for_each_rtx.\n@@ -1258,7 +1259,7 @@ instantiate_virtual_regs_in_rtx (rtx *loc, void *data)\n {\n   HOST_WIDE_INT offset;\n   bool *changed = (bool *) data;\n-  rtx x, new;\n+  rtx x, new_rtx;\n \n   x = *loc;\n   if (x == 0)\n@@ -1267,21 +1268,21 @@ instantiate_virtual_regs_in_rtx (rtx *loc, void *data)\n   switch (GET_CODE (x))\n     {\n     case REG:\n-      new = instantiate_new_reg (x, &offset);\n-      if (new)\n+      new_rtx = instantiate_new_reg (x, &offset);\n+      if (new_rtx)\n \t{\n-\t  *loc = plus_constant (new, offset);\n+\t  *loc = plus_constant (new_rtx, offset);\n \t  if (changed)\n \t    *changed = true;\n \t}\n       return -1;\n \n     case PLUS:\n-      new = instantiate_new_reg (XEXP (x, 0), &offset);\n-      if (new)\n+      new_rtx = instantiate_new_reg (XEXP (x, 0), &offset);\n+      if (new_rtx)\n \t{\n-\t  new = plus_constant (new, offset);\n-\t  *loc = simplify_gen_binary (PLUS, GET_MODE (x), new, XEXP (x, 1));\n+\t  new_rtx = plus_constant (new_rtx, offset);\n+\t  *loc = simplify_gen_binary (PLUS, GET_MODE (x), new_rtx, XEXP (x, 1));\n \t  if (changed)\n \t    *changed = true;\n \t  return -1;\n@@ -1327,7 +1328,7 @@ instantiate_virtual_regs_in_insn (rtx insn)\n   HOST_WIDE_INT offset;\n   int insn_code, i;\n   bool any_change = false;\n-  rtx set, new, x, seq;\n+  rtx set, new_rtx, x, seq;\n \n   /* There are some special cases to be handled first.  */\n   set = single_set (insn);\n@@ -1337,17 +1338,17 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t to mean that the underlying register gets assigned the inverse\n \t transformation.  This is used, for example, in the handling of\n \t non-local gotos.  */\n-      new = instantiate_new_reg (SET_DEST (set), &offset);\n-      if (new)\n+      new_rtx = instantiate_new_reg (SET_DEST (set), &offset);\n+      if (new_rtx)\n \t{\n \t  start_sequence ();\n \n \t  for_each_rtx (&SET_SRC (set), instantiate_virtual_regs_in_rtx, NULL);\n-\t  x = simplify_gen_binary (PLUS, GET_MODE (new), SET_SRC (set),\n+\t  x = simplify_gen_binary (PLUS, GET_MODE (new_rtx), SET_SRC (set),\n \t\t\t\t   GEN_INT (-offset));\n-\t  x = force_operand (x, new);\n-\t  if (x != new)\n-\t    emit_move_insn (new, x);\n+\t  x = force_operand (x, new_rtx);\n+\t  if (x != new_rtx)\n+\t    emit_move_insn (new_rtx, x);\n \n \t  seq = get_insns ();\n \t  end_sequence ();\n@@ -1361,15 +1362,15 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t new add insn.  The difference between this and falling through\n \t to the generic case is avoiding a new pseudo and eliminating a\n \t move insn in the initial rtl stream.  */\n-      new = instantiate_new_reg (SET_SRC (set), &offset);\n-      if (new && offset != 0\n+      new_rtx = instantiate_new_reg (SET_SRC (set), &offset);\n+      if (new_rtx && offset != 0\n \t  && REG_P (SET_DEST (set))\n \t  && REGNO (SET_DEST (set)) > LAST_VIRTUAL_REGISTER)\n \t{\n \t  start_sequence ();\n \n \t  x = expand_simple_binop (GET_MODE (SET_DEST (set)), PLUS,\n-\t\t\t\t   new, GEN_INT (offset), SET_DEST (set),\n+\t\t\t\t   new_rtx, GEN_INT (offset), SET_DEST (set),\n \t\t\t\t   1, OPTAB_LIB_WIDEN);\n \t  if (x != SET_DEST (set))\n \t    emit_move_insn (SET_DEST (set), x);\n@@ -1392,7 +1393,7 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t  && recog_data.operand_loc[1] == &XEXP (SET_SRC (set), 0)\n \t  && recog_data.operand_loc[2] == &XEXP (SET_SRC (set), 1)\n \t  && GET_CODE (recog_data.operand[2]) == CONST_INT\n-\t  && (new = instantiate_new_reg (recog_data.operand[1], &offset)))\n+\t  && (new_rtx = instantiate_new_reg (recog_data.operand[1], &offset)))\n \t{\n \t  offset += INTVAL (recog_data.operand[2]);\n \n@@ -1402,7 +1403,7 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t      && REGNO (SET_DEST (set)) > LAST_VIRTUAL_REGISTER)\n \t    {\n \t      start_sequence ();\n-\t      emit_move_insn (SET_DEST (set), new);\n+\t      emit_move_insn (SET_DEST (set), new_rtx);\n \t      seq = get_insns ();\n \t      end_sequence ();\n \n@@ -1416,10 +1417,10 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t  /* Using validate_change and apply_change_group here leaves\n \t     recog_data in an invalid state.  Since we know exactly what\n \t     we want to check, do those two by hand.  */\n-\t  if (safe_insn_predicate (insn_code, 1, new)\n+\t  if (safe_insn_predicate (insn_code, 1, new_rtx)\n \t      && safe_insn_predicate (insn_code, 2, x))\n \t    {\n-\t      *recog_data.operand_loc[1] = recog_data.operand[1] = new;\n+\t      *recog_data.operand_loc[1] = recog_data.operand[1] = new_rtx;\n \t      *recog_data.operand_loc[2] = recog_data.operand[2] = x;\n \t      any_change = true;\n \n@@ -1474,11 +1475,11 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t  break;\n \n \tcase REG:\n-\t  new = instantiate_new_reg (x, &offset);\n-\t  if (new == NULL)\n+\t  new_rtx = instantiate_new_reg (x, &offset);\n+\t  if (new_rtx == NULL)\n \t    continue;\n \t  if (offset == 0)\n-\t    x = new;\n+\t    x = new_rtx;\n \t  else\n \t    {\n \t      start_sequence ();\n@@ -1489,7 +1490,7 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t      /* ??? Recognize address_operand and/or \"p\" constraints\n \t\t to see if (plus new offset) is a valid before we put\n \t\t this through expand_simple_binop.  */\n-\t      x = expand_simple_binop (GET_MODE (x), PLUS, new,\n+\t      x = expand_simple_binop (GET_MODE (x), PLUS, new_rtx,\n \t\t\t\t       GEN_INT (offset), NULL_RTX,\n \t\t\t\t       1, OPTAB_LIB_WIDEN);\n \t      seq = get_insns ();\n@@ -1499,21 +1500,21 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t  break;\n \n \tcase SUBREG:\n-\t  new = instantiate_new_reg (SUBREG_REG (x), &offset);\n-\t  if (new == NULL)\n+\t  new_rtx = instantiate_new_reg (SUBREG_REG (x), &offset);\n+\t  if (new_rtx == NULL)\n \t    continue;\n \t  if (offset != 0)\n \t    {\n \t      start_sequence ();\n-\t      new = expand_simple_binop (GET_MODE (new), PLUS, new,\n+\t      new_rtx = expand_simple_binop (GET_MODE (new_rtx), PLUS, new_rtx,\n \t\t\t\t\t GEN_INT (offset), NULL_RTX,\n \t\t\t\t\t 1, OPTAB_LIB_WIDEN);\n \t      seq = get_insns ();\n \t      end_sequence ();\n \t      emit_insn_before (seq, insn);\n \t    }\n-\t  x = simplify_gen_subreg (recog_data.operand_mode[i], new,\n-\t\t\t\t   GET_MODE (new), SUBREG_BYTE (x));\n+\t  x = simplify_gen_subreg (recog_data.operand_mode[i], new_rtx,\n+\t\t\t\t   GET_MODE (new_rtx), SUBREG_BYTE (x));\n \t  break;\n \n \tdefault:"}, {"sha": "2d097c733e7b559e7cf6a7c9234d261e7aa74907", "filename": "gcc/gimple.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -370,22 +370,22 @@ void\n extract_ops_from_tree (tree expr, enum tree_code *subcode_p, tree *op1_p,\n \t\t       tree *op2_p)\n {\n-  enum gimple_rhs_class class;\n+  enum gimple_rhs_class grhs_class;\n \n   *subcode_p = TREE_CODE (expr);\n-  class = get_gimple_rhs_class (*subcode_p);\n+  grhs_class = get_gimple_rhs_class (*subcode_p);\n \n-  if (class == GIMPLE_BINARY_RHS)\n+  if (grhs_class == GIMPLE_BINARY_RHS)\n     {\n       *op1_p = TREE_OPERAND (expr, 0);\n       *op2_p = TREE_OPERAND (expr, 1);\n     }\n-  else if (class == GIMPLE_UNARY_RHS)\n+  else if (grhs_class == GIMPLE_UNARY_RHS)\n     {\n       *op1_p = TREE_OPERAND (expr, 0);\n       *op2_p = NULL_TREE;\n     }\n-  else if (class == GIMPLE_SINGLE_RHS)\n+  else if (grhs_class == GIMPLE_SINGLE_RHS)\n     {\n       *op1_p = expr;\n       *op2_p = NULL_TREE;\n@@ -1276,16 +1276,16 @@ gimple_seq\n gimple_seq_copy (gimple_seq src)\n {\n   gimple_stmt_iterator gsi;\n-  gimple_seq new = gimple_seq_alloc ();\n+  gimple_seq new_seq = gimple_seq_alloc ();\n   gimple stmt;\n \n   for (gsi = gsi_start (src); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       stmt = gimple_copy (gsi_stmt (gsi));\n-      gimple_seq_add_stmt (&new, stmt);\n+      gimple_seq_add_stmt (&new_seq, stmt);\n     }\n \n-  return new;\n+  return new_seq;\n }\n \n "}, {"sha": "f22111d4cd7fff803d5f0bebbc6aa89615e844e0", "filename": "gcc/gimplify.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -2294,14 +2294,14 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n   fndecl = get_callee_fndecl (*expr_p);\n   if (fndecl && DECL_BUILT_IN (fndecl))\n     {\n-      tree new = fold_call_expr (*expr_p, !want_value);\n+      tree new_tree = fold_call_expr (*expr_p, !want_value);\n \n-      if (new && new != *expr_p)\n+      if (new_tree && new_tree != *expr_p)\n \t{\n \t  /* There was a transformation of this call which computes the\n \t     same value, but in a more efficient way.  Return and try\n \t     again.  */\n-\t  *expr_p = new;\n+\t  *expr_p = new_tree;\n \t  return GS_OK;\n \t}\n \n@@ -2452,14 +2452,14 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n   /* Try this again in case gimplification exposed something.  */\n   if (ret != GS_ERROR)\n     {\n-      tree new = fold_call_expr (*expr_p, !want_value);\n+      tree new_tree = fold_call_expr (*expr_p, !want_value);\n \n-      if (new && new != *expr_p)\n+      if (new_tree && new_tree != *expr_p)\n \t{\n \t  /* There was a transformation of this call which computes the\n \t     same value, but in a more efficient way.  Return and try\n \t     again.  */\n-\t  *expr_p = new;\n+\t  *expr_p = new_tree;\n \t  return GS_OK;\n \t}\n     }\n@@ -3636,25 +3636,25 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \t    if (size > 0 && !can_move_by_pieces (size, align))\n \t      {\n-\t\ttree new;\n+\t\ttree new_tree;\n \n \t\tif (notify_temp_creation)\n \t\t  return GS_ERROR;\n \n-\t\tnew = create_tmp_var_raw (type, \"C\");\n+\t\tnew_tree = create_tmp_var_raw (type, \"C\");\n \n-\t\tgimple_add_tmp_var (new);\n-\t\tTREE_STATIC (new) = 1;\n-\t\tTREE_READONLY (new) = 1;\n-\t\tDECL_INITIAL (new) = ctor;\n-\t\tif (align > DECL_ALIGN (new))\n+\t\tgimple_add_tmp_var (new_tree);\n+\t\tTREE_STATIC (new_tree) = 1;\n+\t\tTREE_READONLY (new_tree) = 1;\n+\t\tDECL_INITIAL (new_tree) = ctor;\n+\t\tif (align > DECL_ALIGN (new_tree))\n \t\t  {\n-\t\t    DECL_ALIGN (new) = align;\n-\t\t    DECL_USER_ALIGN (new) = 1;\n+\t\t    DECL_ALIGN (new_tree) = align;\n+\t\t    DECL_USER_ALIGN (new_tree) = 1;\n \t\t  }\n-\t        walk_tree (&DECL_INITIAL (new), force_labels_r, NULL, NULL);\n+\t        walk_tree (&DECL_INITIAL (new_tree), force_labels_r, NULL, NULL);\n \n-\t\tTREE_OPERAND (*expr_p, 1) = new;\n+\t\tTREE_OPERAND (*expr_p, 1) = new_tree;\n \n \t\t/* This is no longer an assignment of a CONSTRUCTOR, but\n \t\t   we still may have processing to do on the LHS.  So\n@@ -4844,7 +4844,7 @@ gimplify_cleanup_point_expr (tree *expr_p, gimple_seq *pre_p)\n \t    }\n \t  else\n \t    {\n-\t      gimple try;\n+\t      gimple gtry;\n \t      gimple_seq seq;\n \t      enum gimple_try_flags kind;\n \n@@ -4854,10 +4854,10 @@ gimplify_cleanup_point_expr (tree *expr_p, gimple_seq *pre_p)\n \t\tkind = GIMPLE_TRY_FINALLY;\n \t      seq = gsi_split_seq_after (iter);\n \n-\t      try = gimple_build_try (seq, gimple_wce_cleanup (wce), kind);\n+\t      gtry = gimple_build_try (seq, gimple_wce_cleanup (wce), kind);\n               /* Do not use gsi_replace here, as it may scan operands.\n                  We want to do a simple structural modification only.  */\n-              *gsi_stmt_ptr (&iter) = try;\n+              *gsi_stmt_ptr (&iter) = gtry;\n \t      iter = gsi_start (seq);\n \t    }\n \t}"}, {"sha": "8ad6ddb3fec185ad3291e3336af8a97fb181de8c", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -281,15 +281,17 @@ ipcp_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n     lat->type = IPA_BOTTOM;\n }\n \n-/* True when OLD and NEW values are not the same.  */\n+/* True when OLD_LAT and NEW_LAT values are not the same.  */\n+\n static bool\n-ipcp_lattice_changed (struct ipcp_lattice *old, struct ipcp_lattice *new)\n+ipcp_lattice_changed (struct ipcp_lattice *old_lat,\n+\t\t      struct ipcp_lattice *new_lat)\n {\n-  if (old->type == new->type)\n+  if (old_lat->type == new_lat->type)\n     {\n-      if (!ipcp_lat_is_const (old))\n+      if (!ipcp_lat_is_const (old_lat))\n \treturn false;\n-      if (ipcp_lats_are_equal (old, new))\n+      if (ipcp_lats_are_equal (old_lat, new_lat))\n \treturn false;\n     }\n   return true;"}, {"sha": "64470ba2b0bc1548c7215ffdfa7c34a4b49cad77", "filename": "gcc/passes.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -447,13 +447,13 @@ next_pass_1 (struct opt_pass **list, struct opt_pass *pass)\n      pass is already in the list.  */\n   if (pass->static_pass_number)\n     {\n-      struct opt_pass *new;\n+      struct opt_pass *new_pass;\n \n-      new = XNEW (struct opt_pass);\n-      memcpy (new, pass, sizeof (*new));\n-      new->next = NULL;\n+      new_pass = XNEW (struct opt_pass);\n+      memcpy (new_pass, pass, sizeof (*new_pass));\n+      new_pass->next = NULL;\n \n-      new->todo_flags_start &= ~TODO_mark_first_instance;\n+      new_pass->todo_flags_start &= ~TODO_mark_first_instance;\n \n       /* Indicate to register_dump_files that this pass has duplicates,\n          and so it should rename the dump file.  The first instance will\n@@ -462,10 +462,10 @@ next_pass_1 (struct opt_pass **list, struct opt_pass *pass)\n       if (pass->name)\n         {\n           pass->static_pass_number -= 1;\n-          new->static_pass_number = -pass->static_pass_number;\n+          new_pass->static_pass_number = -pass->static_pass_number;\n \t}\n       \n-      *list = new;\n+      *list = new_pass;\n     }\n   else\n     {"}, {"sha": "16ba3929fabd548d15e8be27c174ccac597e3665", "filename": "gcc/print-tree.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -74,12 +74,12 @@ dump_addr (FILE *file, const char *prefix, const void *addr)\n void\n print_node_brief (FILE *file, const char *prefix, const_tree node, int indent)\n {\n-  enum tree_code_class class;\n+  enum tree_code_class tclass;\n \n   if (node == 0)\n     return;\n \n-  class = TREE_CODE_CLASS (TREE_CODE (node));\n+  tclass = TREE_CODE_CLASS (TREE_CODE (node));\n \n   /* Always print the slot this node is in, and its code, address and\n      name if any.  */\n@@ -88,7 +88,7 @@ print_node_brief (FILE *file, const char *prefix, const_tree node, int indent)\n   fprintf (file, \"%s <%s\", prefix, tree_code_name[(int) TREE_CODE (node)]);\n   dump_addr (file, \" \", node);\n \n-  if (class == tcc_declaration)\n+  if (tclass == tcc_declaration)\n     {\n       if (DECL_NAME (node))\n \tfprintf (file, \" %s\", IDENTIFIER_POINTER (DECL_NAME (node)));\n@@ -99,7 +99,7 @@ print_node_brief (FILE *file, const char *prefix, const_tree node, int indent)\n \tfprintf (file, \" %c.%u\", TREE_CODE (node) == CONST_DECL ? 'C' : 'D',\n \t\t DECL_UID (node));\n     }\n-  else if (class == tcc_type)\n+  else if (tclass == tcc_type)\n     {\n       if (TYPE_NAME (node))\n \t{\n@@ -188,7 +188,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n   int hash;\n   struct bucket *b;\n   enum machine_mode mode;\n-  enum tree_code_class class;\n+  enum tree_code_class tclass;\n   int len;\n   int i;\n   expanded_location xloc;\n@@ -198,7 +198,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n     return;\n   \n   code = TREE_CODE (node);\n-  class = TREE_CODE_CLASS (code);\n+  tclass = TREE_CODE_CLASS (code);\n \n   /* Don't get too deep in nesting.  If the user wants to see deeper,\n      it is easy to use the address of a lowest-level node\n@@ -210,7 +210,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       return;\n     }\n \n-  if (indent > 8 && (class == tcc_type || class == tcc_declaration))\n+  if (indent > 8 && (tclass == tcc_type || tclass == tcc_declaration))\n     {\n       print_node_brief (file, prefix, node, indent);\n       return;\n@@ -251,7 +251,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n   dump_addr (file, \" \", node);\n \n   /* Print the name, if any.  */\n-  if (class == tcc_declaration)\n+  if (tclass == tcc_declaration)\n     {\n       if (DECL_NAME (node))\n \tfprintf (file, \" %s\", IDENTIFIER_POINTER (DECL_NAME (node)));\n@@ -262,7 +262,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \tfprintf (file, \" %c.%u\", TREE_CODE (node) == CONST_DECL ? 'C' : 'D',\n \t\t DECL_UID (node));\n     }\n-  else if (class == tcc_type)\n+  else if (tclass == tcc_type)\n     {\n       if (TYPE_NAME (node))\n \t{"}, {"sha": "7489579ca274f47f5f73d6b6c70658deb7470557", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -821,8 +821,8 @@ branch_prob (void)\n \t\t  || (LOCATION_LINE (e->goto_locus)\n \t\t      != LOCATION_LINE (gimple_location  (last)))))\n \t    {\n-\t      basic_block new = split_edge (e);\n-\t      single_succ_edge (new)->goto_locus = e->goto_locus;\n+\t      basic_block new_bb = split_edge (e);\n+\t      single_succ_edge (new_bb)->goto_locus = e->goto_locus;\n \t    }\n \t  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n \t       && e->dest != EXIT_BLOCK_PTR)"}, {"sha": "ffac189f4498d627bc80b7c4d5413d770096f30e", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -832,9 +832,9 @@ dump_register (const char *suffix, const char *swtch, const char *glob,\n   static int next_dump = FIRST_AUTO_NUMBERED_DUMP;\n   int num = next_dump++;\n \n-  size_t this = extra_dump_files_in_use++;\n+  size_t count = extra_dump_files_in_use++;\n \n-  if (this >= extra_dump_files_alloced)\n+  if (count >= extra_dump_files_alloced)\n     {\n       if (extra_dump_files_alloced == 0)\n \textra_dump_files_alloced = 32;\n@@ -845,14 +845,14 @@ dump_register (const char *suffix, const char *swtch, const char *glob,\n \t\t\t\t     extra_dump_files_alloced);\n     }\n \n-  memset (&extra_dump_files[this], 0, sizeof (struct dump_file_info));\n-  extra_dump_files[this].suffix = suffix;\n-  extra_dump_files[this].swtch = swtch;\n-  extra_dump_files[this].glob = glob;\n-  extra_dump_files[this].flags = flags;\n-  extra_dump_files[this].num = num;\n+  memset (&extra_dump_files[count], 0, sizeof (struct dump_file_info));\n+  extra_dump_files[count].suffix = suffix;\n+  extra_dump_files[count].swtch = swtch;\n+  extra_dump_files[count].glob = glob;\n+  extra_dump_files[count].flags = flags;\n+  extra_dump_files[count].num = num;\n \n-  return this + TDI_end;\n+  return count + TDI_end;\n }\n \n "}, {"sha": "a8885e36d1ab8008c63bea1646ba775d2687449b", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -480,18 +480,18 @@ replace_goto_queue_cond_clause (tree *tp, struct leh_tf_state *tf,\n \t\t\t\tgimple_stmt_iterator *gsi)\n {\n   tree label;\n-  gimple_seq new;\n+  gimple_seq new_seq;\n   treemple temp;\n \n   temp.tp = tp;\n-  new = find_goto_replacement (tf, temp);\n-  if (!new)\n+  new_seq = find_goto_replacement (tf, temp);\n+  if (!new_seq)\n     return;\n \n-  if (gimple_seq_singleton_p (new)\n-      && gimple_code (gimple_seq_first_stmt (new)) == GIMPLE_GOTO)\n+  if (gimple_seq_singleton_p (new_seq)\n+      && gimple_code (gimple_seq_first_stmt (new_seq)) == GIMPLE_GOTO)\n     {\n-      *tp = gimple_goto_dest (gimple_seq_first_stmt (new));\n+      *tp = gimple_goto_dest (gimple_seq_first_stmt (new_seq));\n       return;\n     }\n \n@@ -500,7 +500,7 @@ replace_goto_queue_cond_clause (tree *tp, struct leh_tf_state *tf,\n   *tp = label;\n \n   gsi_insert_after (gsi, gimple_build_label (label), GSI_CONTINUE_LINKING);\n-  gsi_insert_seq_after (gsi, gimple_seq_copy (new), GSI_CONTINUE_LINKING);\n+  gsi_insert_seq_after (gsi, gimple_seq_copy (new_seq), GSI_CONTINUE_LINKING);\n }\n \n /* The real work of replace_goto_queue.  Returns with TSI updated to\n@@ -1665,32 +1665,32 @@ lower_catch (struct leh_state *state, gimple tp)\n     {\n       struct eh_region *catch_region;\n       tree eh_label;\n-      gimple x, catch;\n+      gimple x, gcatch;\n \n-      catch = gsi_stmt (gsi);\n+      gcatch = gsi_stmt (gsi);\n       catch_region = gen_eh_region_catch (try_region,\n-                                          gimple_catch_types (catch));\n+                                          gimple_catch_types (gcatch));\n \n       this_state.cur_region = catch_region;\n       this_state.prev_try = state->prev_try;\n-      lower_eh_constructs_1 (&this_state, gimple_catch_handler (catch));\n+      lower_eh_constructs_1 (&this_state, gimple_catch_handler (gcatch));\n \n       eh_label = create_artificial_label ();\n       set_eh_region_tree_label (catch_region, eh_label);\n \n       x = gimple_build_label (eh_label);\n       gsi_insert_before (&gsi, x, GSI_SAME_STMT);\n \n-      if (gimple_seq_may_fallthru (gimple_catch_handler (catch)))\n+      if (gimple_seq_may_fallthru (gimple_catch_handler (gcatch)))\n \t{\n \t  if (!out_label)\n \t    out_label = create_artificial_label ();\n \n \t  x = gimple_build_goto (out_label);\n-\t  gimple_seq_add_stmt (gimple_catch_handler_ptr (catch), x);\n+\t  gimple_seq_add_stmt (gimple_catch_handler_ptr (gcatch), x);\n \t}\n \n-      gsi_insert_seq_before (&gsi, gimple_catch_handler (catch),\n+      gsi_insert_seq_before (&gsi, gimple_catch_handler (gcatch),\n \t\t\t     GSI_SAME_STMT);\n       gsi_remove (&gsi, false);\n     }"}, {"sha": "4eeabb141b9e6c2be18e8bee844fdbd61cd83e96", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 95, "deletions": 95, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -154,7 +154,7 @@ insert_decl_map (copy_body_data *id, tree key, tree value)\n static tree\n remap_ssa_name (tree name, copy_body_data *id)\n {\n-  tree new;\n+  tree new_tree;\n   tree *n;\n \n   gcc_assert (TREE_CODE (name) == SSA_NAME);\n@@ -165,23 +165,23 @@ remap_ssa_name (tree name, copy_body_data *id)\n \n   /* Do not set DEF_STMT yet as statement is not copied yet. We do that\n      in copy_bb.  */\n-  new = remap_decl (SSA_NAME_VAR (name), id);\n+  new_tree = remap_decl (SSA_NAME_VAR (name), id);\n \n   /* We might've substituted constant or another SSA_NAME for\n      the variable. \n \n      Replace the SSA name representing RESULT_DECL by variable during\n      inlining:  this saves us from need to introduce PHI node in a case\n      return value is just partly initialized.  */\n-  if ((TREE_CODE (new) == VAR_DECL || TREE_CODE (new) == PARM_DECL)\n+  if ((TREE_CODE (new_tree) == VAR_DECL || TREE_CODE (new_tree) == PARM_DECL)\n       && (TREE_CODE (SSA_NAME_VAR (name)) != RESULT_DECL\n \t  || !id->transform_return_to_modify))\n     {\n-      new = make_ssa_name (new, NULL);\n-      insert_decl_map (id, name, new);\n-      SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new)\n+      new_tree = make_ssa_name (new_tree, NULL);\n+      insert_decl_map (id, name, new_tree);\n+      SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_tree)\n \t= SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name);\n-      TREE_TYPE (new) = TREE_TYPE (SSA_NAME_VAR (new));\n+      TREE_TYPE (new_tree) = TREE_TYPE (SSA_NAME_VAR (new_tree));\n       if (gimple_nop_p (SSA_NAME_DEF_STMT (name)))\n \t{\n \t  /* By inlining function having uninitialized variable, we might\n@@ -202,24 +202,24 @@ remap_ssa_name (tree name, copy_body_data *id)\n \t      gimple_stmt_iterator gsi = gsi_last_bb (id->entry_bb);\n \t      gimple init_stmt;\n \t      \n-\t      init_stmt = gimple_build_assign (new,\n-\t\t                               fold_convert (TREE_TYPE (new),\n+\t      init_stmt = gimple_build_assign (new_tree,\n+\t\t                               fold_convert (TREE_TYPE (new_tree),\n \t\t\t\t\t       \t\t    integer_zero_node));\n \t      gsi_insert_after (&gsi, init_stmt, GSI_NEW_STMT);\n-\t      SSA_NAME_IS_DEFAULT_DEF (new) = 0;\n+\t      SSA_NAME_IS_DEFAULT_DEF (new_tree) = 0;\n \t    }\n \t  else\n \t    {\n-\t      SSA_NAME_DEF_STMT (new) = gimple_build_nop ();\n+\t      SSA_NAME_DEF_STMT (new_tree) = gimple_build_nop ();\n \t      if (gimple_default_def (id->src_cfun, SSA_NAME_VAR (name))\n \t\t  == name)\n-\t        set_default_def (SSA_NAME_VAR (new), new);\n+\t        set_default_def (SSA_NAME_VAR (new_tree), new_tree);\n \t    }\n \t}\n     }\n   else\n-    insert_decl_map (id, name, new);\n-  return new;\n+    insert_decl_map (id, name, new_tree);\n+  return new_tree;\n }\n \n /* Remap DECL during the copying of the BLOCK tree for the function.  */\n@@ -295,79 +295,79 @@ remap_decl (tree decl, copy_body_data *id)\n static tree\n remap_type_1 (tree type, copy_body_data *id)\n {\n-  tree new, t;\n+  tree new_tree, t;\n \n   /* We do need a copy.  build and register it now.  If this is a pointer or\n      reference type, remap the designated type and make a new pointer or\n      reference type.  */\n   if (TREE_CODE (type) == POINTER_TYPE)\n     {\n-      new = build_pointer_type_for_mode (remap_type (TREE_TYPE (type), id),\n+      new_tree = build_pointer_type_for_mode (remap_type (TREE_TYPE (type), id),\n \t\t\t\t\t TYPE_MODE (type),\n \t\t\t\t\t TYPE_REF_CAN_ALIAS_ALL (type));\n-      insert_decl_map (id, type, new);\n-      return new;\n+      insert_decl_map (id, type, new_tree);\n+      return new_tree;\n     }\n   else if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n-      new = build_reference_type_for_mode (remap_type (TREE_TYPE (type), id),\n+      new_tree = build_reference_type_for_mode (remap_type (TREE_TYPE (type), id),\n \t\t\t\t\t    TYPE_MODE (type),\n \t\t\t\t\t    TYPE_REF_CAN_ALIAS_ALL (type));\n-      insert_decl_map (id, type, new);\n-      return new;\n+      insert_decl_map (id, type, new_tree);\n+      return new_tree;\n     }\n   else\n-    new = copy_node (type);\n+    new_tree = copy_node (type);\n \n-  insert_decl_map (id, type, new);\n+  insert_decl_map (id, type, new_tree);\n \n   /* This is a new type, not a copy of an old type.  Need to reassociate\n      variants.  We can handle everything except the main variant lazily.  */\n   t = TYPE_MAIN_VARIANT (type);\n   if (type != t)\n     {\n       t = remap_type (t, id);\n-      TYPE_MAIN_VARIANT (new) = t;\n-      TYPE_NEXT_VARIANT (new) = TYPE_NEXT_VARIANT (t);\n-      TYPE_NEXT_VARIANT (t) = new;\n+      TYPE_MAIN_VARIANT (new_tree) = t;\n+      TYPE_NEXT_VARIANT (new_tree) = TYPE_NEXT_VARIANT (t);\n+      TYPE_NEXT_VARIANT (t) = new_tree;\n     }\n   else\n     {\n-      TYPE_MAIN_VARIANT (new) = new;\n-      TYPE_NEXT_VARIANT (new) = NULL;\n+      TYPE_MAIN_VARIANT (new_tree) = new_tree;\n+      TYPE_NEXT_VARIANT (new_tree) = NULL;\n     }\n \n   if (TYPE_STUB_DECL (type))\n-    TYPE_STUB_DECL (new) = remap_decl (TYPE_STUB_DECL (type), id);\n+    TYPE_STUB_DECL (new_tree) = remap_decl (TYPE_STUB_DECL (type), id);\n \n   /* Lazily create pointer and reference types.  */\n-  TYPE_POINTER_TO (new) = NULL;\n-  TYPE_REFERENCE_TO (new) = NULL;\n+  TYPE_POINTER_TO (new_tree) = NULL;\n+  TYPE_REFERENCE_TO (new_tree) = NULL;\n \n-  switch (TREE_CODE (new))\n+  switch (TREE_CODE (new_tree))\n     {\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n     case FIXED_POINT_TYPE:\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n-      t = TYPE_MIN_VALUE (new);\n+      t = TYPE_MIN_VALUE (new_tree);\n       if (t && TREE_CODE (t) != INTEGER_CST)\n-        walk_tree (&TYPE_MIN_VALUE (new), copy_tree_body_r, id, NULL);\n+        walk_tree (&TYPE_MIN_VALUE (new_tree), copy_tree_body_r, id, NULL);\n \n-      t = TYPE_MAX_VALUE (new);\n+      t = TYPE_MAX_VALUE (new_tree);\n       if (t && TREE_CODE (t) != INTEGER_CST)\n-        walk_tree (&TYPE_MAX_VALUE (new), copy_tree_body_r, id, NULL);\n-      return new;\n+        walk_tree (&TYPE_MAX_VALUE (new_tree), copy_tree_body_r, id, NULL);\n+      return new_tree;\n \n     case FUNCTION_TYPE:\n-      TREE_TYPE (new) = remap_type (TREE_TYPE (new), id);\n-      walk_tree (&TYPE_ARG_TYPES (new), copy_tree_body_r, id, NULL);\n-      return new;\n+      TREE_TYPE (new_tree) = remap_type (TREE_TYPE (new_tree), id);\n+      walk_tree (&TYPE_ARG_TYPES (new_tree), copy_tree_body_r, id, NULL);\n+      return new_tree;\n \n     case ARRAY_TYPE:\n-      TREE_TYPE (new) = remap_type (TREE_TYPE (new), id);\n-      TYPE_DOMAIN (new) = remap_type (TYPE_DOMAIN (new), id);\n+      TREE_TYPE (new_tree) = remap_type (TREE_TYPE (new_tree), id);\n+      TYPE_DOMAIN (new_tree) = remap_type (TYPE_DOMAIN (new_tree), id);\n       break;\n \n     case RECORD_TYPE:\n@@ -376,14 +376,14 @@ remap_type_1 (tree type, copy_body_data *id)\n       {\n \ttree f, nf = NULL;\n \n-\tfor (f = TYPE_FIELDS (new); f ; f = TREE_CHAIN (f))\n+\tfor (f = TYPE_FIELDS (new_tree); f ; f = TREE_CHAIN (f))\n \t  {\n \t    t = remap_decl (f, id);\n-\t    DECL_CONTEXT (t) = new;\n+\t    DECL_CONTEXT (t) = new_tree;\n \t    TREE_CHAIN (t) = nf;\n \t    nf = t;\n \t  }\n-\tTYPE_FIELDS (new) = nreverse (nf);\n+\tTYPE_FIELDS (new_tree) = nreverse (nf);\n       }\n       break;\n \n@@ -393,10 +393,10 @@ remap_type_1 (tree type, copy_body_data *id)\n       gcc_unreachable ();\n     }\n \n-  walk_tree (&TYPE_SIZE (new), copy_tree_body_r, id, NULL);\n-  walk_tree (&TYPE_SIZE_UNIT (new), copy_tree_body_r, id, NULL);\n+  walk_tree (&TYPE_SIZE (new_tree), copy_tree_body_r, id, NULL);\n+  walk_tree (&TYPE_SIZE_UNIT (new_tree), copy_tree_body_r, id, NULL);\n \n-  return new;\n+  return new_tree;\n }\n \n tree\n@@ -504,28 +504,28 @@ static tree\n remap_blocks (tree block, copy_body_data *id)\n {\n   tree t;\n-  tree new = block;\n+  tree new_tree = block;\n \n   if (!block)\n     return NULL;\n \n-  remap_block (&new, id);\n-  gcc_assert (new != block);\n+  remap_block (&new_tree, id);\n+  gcc_assert (new_tree != block);\n   for (t = BLOCK_SUBBLOCKS (block); t ; t = BLOCK_CHAIN (t))\n-    add_lexical_block (new, remap_blocks (t, id));\n-  return new;\n+    add_lexical_block (new_tree, remap_blocks (t, id));\n+  return new_tree;\n }\n \n static void\n copy_statement_list (tree *tp)\n {\n   tree_stmt_iterator oi, ni;\n-  tree new;\n+  tree new_tree;\n \n-  new = alloc_stmt_list ();\n-  ni = tsi_start (new);\n+  new_tree = alloc_stmt_list ();\n+  ni = tsi_start (new_tree);\n   oi = tsi_start (*tp);\n-  *tp = new;\n+  *tp = new_tree;\n \n   for (; !tsi_end_p (oi); tsi_next (&oi))\n     tsi_link_after (&ni, tsi_stmt (oi), TSI_NEW_STMT);\n@@ -679,7 +679,7 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n \t  n = (tree *) pointer_map_contains (id->decl_map, decl);\n \t  if (n)\n \t    {\n-\t      tree type, new, old;\n+\t      tree type, new_tree, old;\n \n \t      /* If we happen to get an ADDR_EXPR in n->value, strip\n \t\t it manually here as we'll eventually get ADDR_EXPRs\n@@ -689,23 +689,23 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n \t\t fold_indirect_ref does other useful transformations,\n \t\t try that first, though.  */\n \t      type = TREE_TYPE (TREE_TYPE (*n));\n-\t      new = unshare_expr (*n);\n+\t      new_tree = unshare_expr (*n);\n \t      old = *tp;\n-\t      *tp = gimple_fold_indirect_ref (new);\n+\t      *tp = gimple_fold_indirect_ref (new_tree);\n \t      if (!*tp)\n \t        {\n-\t\t  if (TREE_CODE (new) == ADDR_EXPR)\n+\t\t  if (TREE_CODE (new_tree) == ADDR_EXPR)\n \t\t    {\n-\t\t      *tp = fold_indirect_ref_1 (type, new);\n+\t\t      *tp = fold_indirect_ref_1 (type, new_tree);\n \t\t      /* ???  We should either assert here or build\n \t\t\t a VIEW_CONVERT_EXPR instead of blindly leaking\n \t\t\t incompatible types to our IL.  */\n \t\t      if (! *tp)\n-\t\t\t*tp = TREE_OPERAND (new, 0);\n+\t\t\t*tp = TREE_OPERAND (new_tree, 0);\n \t\t    }\n \t          else\n \t\t    {\n-\t              *tp = build1 (INDIRECT_REF, type, new);\n+\t              *tp = build1 (INDIRECT_REF, type, new_tree);\n \t\t      TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n \t\t    }\n \t\t}\n@@ -908,7 +908,7 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  n = (tree *) pointer_map_contains (id->decl_map, decl);\n \t  if (n)\n \t    {\n-\t      tree new;\n+\t      tree new_tree;\n \t      tree old;\n \t      /* If we happen to get an ADDR_EXPR in n->value, strip\n \t         it manually here as we'll eventually get ADDR_EXPRs\n@@ -917,23 +917,23 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t\t but we absolutely rely on that.  As fold_indirect_ref\n \t         does other useful transformations, try that first, though.  */\n \t      tree type = TREE_TYPE (TREE_TYPE (*n));\n-\t      new = unshare_expr (*n);\n+\t      new_tree = unshare_expr (*n);\n \t      old = *tp;\n-\t      *tp = gimple_fold_indirect_ref (new);\n+\t      *tp = gimple_fold_indirect_ref (new_tree);\n \t      if (! *tp)\n \t        {\n-\t\t  if (TREE_CODE (new) == ADDR_EXPR)\n+\t\t  if (TREE_CODE (new_tree) == ADDR_EXPR)\n \t\t    {\n-\t\t      *tp = fold_indirect_ref_1 (type, new);\n+\t\t      *tp = fold_indirect_ref_1 (type, new_tree);\n \t\t      /* ???  We should either assert here or build\n \t\t\t a VIEW_CONVERT_EXPR instead of blindly leaking\n \t\t\t incompatible types to our IL.  */\n \t\t      if (! *tp)\n-\t\t\t*tp = TREE_OPERAND (new, 0);\n+\t\t\t*tp = TREE_OPERAND (new_tree, 0);\n \t\t    }\n \t          else\n \t\t    {\n-\t              *tp = build1 (INDIRECT_REF, type, new);\n+\t              *tp = build1 (INDIRECT_REF, type, new_tree);\n \t\t      TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n \t\t      TREE_SIDE_EFFECTS (*tp) = TREE_SIDE_EFFECTS (old);\n \t\t    }\n@@ -1547,17 +1547,17 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb)\n   FOR_EACH_EDGE (old_edge, ei, bb->succs)\n     if (!(old_edge->flags & EDGE_EH))\n       {\n-\tedge new;\n+\tedge new_edge;\n \n \tflags = old_edge->flags;\n \n \t/* Return edges do get a FALLTHRU flag when the get inlined.  */\n \tif (old_edge->dest->index == EXIT_BLOCK && !old_edge->flags\n \t    && old_edge->dest->aux != EXIT_BLOCK_PTR)\n \t  flags |= EDGE_FALLTHRU;\n-\tnew = make_edge (new_bb, (basic_block) old_edge->dest->aux, flags);\n-\tnew->count = old_edge->count * count_scale / REG_BR_PROB_BASE;\n-\tnew->probability = old_edge->probability;\n+\tnew_edge = make_edge (new_bb, (basic_block) old_edge->dest->aux, flags);\n+\tnew_edge->count = old_edge->count * count_scale / REG_BR_PROB_BASE;\n+\tnew_edge->probability = old_edge->probability;\n       }\n \n   if (bb->index == ENTRY_BLOCK || bb->index == EXIT_BLOCK)\n@@ -1795,9 +1795,9 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency,\n   /* Use aux pointers to map the original blocks to copy.  */\n   FOR_EACH_BB_FN (bb, cfun_to_copy)\n     {\n-      basic_block new = copy_bb (id, bb, frequency_scale, count_scale);\n-      bb->aux = new;\n-      new->aux = bb;\n+      basic_block new_bb = copy_bb (id, bb, frequency_scale, count_scale);\n+      bb->aux = new_bb;\n+      new_bb->aux = bb;\n     }\n \n   last = last_basic_block;\n@@ -3554,18 +3554,18 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n     {\n       /* Because the chain gets clobbered when we make a copy, we save it\n \t here.  */\n-      tree chain = NULL_TREE, new;\n+      tree chain = NULL_TREE, new_tree;\n \n       chain = TREE_CHAIN (*tp);\n \n       /* Copy the node.  */\n-      new = copy_node (*tp);\n+      new_tree = copy_node (*tp);\n \n       /* Propagate mudflap marked-ness.  */\n       if (flag_mudflap && mf_marked_p (*tp))\n-        mf_mark (new);\n+        mf_mark (new_tree);\n \n-      *tp = new;\n+      *tp = new_tree;\n \n       /* Now, restore the chain, if appropriate.  That will cause\n \t walk_tree to walk into the chain as well.  */\n@@ -3583,17 +3583,17 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n     {\n       /* CONSTRUCTOR nodes need special handling because\n          we need to duplicate the vector of elements.  */\n-      tree new;\n+      tree new_tree;\n \n-      new = copy_node (*tp);\n+      new_tree = copy_node (*tp);\n \n       /* Propagate mudflap marked-ness.  */\n       if (flag_mudflap && mf_marked_p (*tp))\n-        mf_mark (new);\n+        mf_mark (new_tree);\n \n-      CONSTRUCTOR_ELTS (new) = VEC_copy (constructor_elt, gc,\n+      CONSTRUCTOR_ELTS (new_tree) = VEC_copy (constructor_elt, gc,\n \t\t\t\t\t CONSTRUCTOR_ELTS (*tp));\n-      *tp = new;\n+      *tp = new_tree;\n     }\n   else if (TREE_CODE_CLASS (code) == tcc_type)\n     *walk_subtrees = 0;\n@@ -4093,10 +4093,10 @@ copy_arguments_for_versioning (tree orig_parm, copy_body_data * id)\n   arg_copy = &orig_parm;\n   for (parg = arg_copy; *parg; parg = &TREE_CHAIN (*parg))\n     {\n-      tree new = remap_decl (*parg, id);\n-      lang_hooks.dup_lang_specific_decl (new);\n-      TREE_CHAIN (new) = TREE_CHAIN (*parg);\n-      *parg = new;\n+      tree new_tree = remap_decl (*parg, id);\n+      lang_hooks.dup_lang_specific_decl (new_tree);\n+      TREE_CHAIN (new_tree) = TREE_CHAIN (*parg);\n+      *parg = new_tree;\n     }\n   return orig_parm;\n }\n@@ -4110,10 +4110,10 @@ copy_static_chain (tree static_chain, copy_body_data * id)\n   chain_copy = &static_chain;\n   for (pvar = chain_copy; *pvar; pvar = &TREE_CHAIN (*pvar))\n     {\n-      tree new = remap_decl (*pvar, id);\n-      lang_hooks.dup_lang_specific_decl (new);\n-      TREE_CHAIN (new) = TREE_CHAIN (*pvar);\n-      *pvar = new;\n+      tree new_tree = remap_decl (*pvar, id);\n+      lang_hooks.dup_lang_specific_decl (new_tree);\n+      TREE_CHAIN (new_tree) = TREE_CHAIN (*pvar);\n+      *pvar = new_tree;\n     }\n   return static_chain;\n }"}, {"sha": "f0c5590506060e63caf722378096844afcabf0d9", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -638,15 +638,15 @@ repl_map_free (void *p)\n }\n \n \n-/* Return the names replaced by NEW (i.e., REPL_TBL[NEW].SET).  */\n+/* Return the names replaced by NEW_TREE (i.e., REPL_TBL[NEW_TREE].SET).  */\n \n static inline bitmap\n-names_replaced_by (tree new)\n+names_replaced_by (tree new_tree)\n {\n   struct repl_map_d m;\n   void **slot;\n \n-  m.name = new;\n+  m.name = new_tree;\n   slot = htab_find_slot (repl_tbl, (void *) &m, NO_INSERT);\n \n   /* If N was not registered in the replacement table, return NULL.  */\n@@ -657,20 +657,20 @@ names_replaced_by (tree new)\n }\n \n \n-/* Add OLD to REPL_TBL[NEW].SET.  */\n+/* Add OLD to REPL_TBL[NEW_TREE].SET.  */\n \n static inline void\n-add_to_repl_tbl (tree new, tree old)\n+add_to_repl_tbl (tree new_tree, tree old)\n {\n   struct repl_map_d m, *mp;\n   void **slot;\n \n-  m.name = new;\n+  m.name = new_tree;\n   slot = htab_find_slot (repl_tbl, (void *) &m, INSERT);\n   if (*slot == NULL)\n     {\n       mp = XNEW (struct repl_map_d);\n-      mp->name = new;\n+      mp->name = new_tree;\n       mp->set = BITMAP_ALLOC (NULL);\n       *slot = (void *) mp;\n     }\n@@ -681,23 +681,23 @@ add_to_repl_tbl (tree new, tree old)\n }\n \n \n-/* Add a new mapping NEW -> OLD REPL_TBL.  Every entry N_i in REPL_TBL\n+/* Add a new mapping NEW_TREE -> OLD REPL_TBL.  Every entry N_i in REPL_TBL\n    represents the set of names O_1 ... O_j replaced by N_i.  This is\n    used by update_ssa and its helpers to introduce new SSA names in an\n    already formed SSA web.  */\n \n static void\n-add_new_name_mapping (tree new, tree old)\n+add_new_name_mapping (tree new_tree, tree old)\n {\n   timevar_push (TV_TREE_SSA_INCREMENTAL);\n \n-  /* OLD and NEW must be different SSA names for the same symbol.  */\n-  gcc_assert (new != old && SSA_NAME_VAR (new) == SSA_NAME_VAR (old));\n+  /* OLD and NEW_TREE must be different SSA names for the same symbol.  */\n+  gcc_assert (new_tree != old && SSA_NAME_VAR (new_tree) == SSA_NAME_VAR (old));\n \n   /* If this mapping is for virtual names, we will need to update\n      virtual operands.  If this is a mapping for .MEM, then we gather\n      the symbols associated with each name.  */\n-  if (!is_gimple_reg (new))\n+  if (!is_gimple_reg (new_tree))\n     {\n       tree sym;\n \n@@ -712,7 +712,7 @@ add_new_name_mapping (tree new, tree old)\n \t will make more sense to rename the symbols from scratch.\n \t Otherwise, the insertion of PHI nodes for each of the old\n \t names in these mappings will be very slow.  */\n-      sym = SSA_NAME_VAR (new);\n+      sym = SSA_NAME_VAR (new_tree);\n       bitmap_set_bit (update_ssa_stats.virtual_symbols, DECL_UID (sym));\n     }\n \n@@ -726,16 +726,16 @@ add_new_name_mapping (tree new, tree old)\n     }\n \n   /* Update the REPL_TBL table.  */\n-  add_to_repl_tbl (new, old);\n+  add_to_repl_tbl (new_tree, old);\n \n   /* If OLD had already been registered as a new name, then all the\n-     names that OLD replaces should also be replaced by NEW.  */\n+     names that OLD replaces should also be replaced by NEW_TREE.  */\n   if (is_new_name (old))\n-    bitmap_ior_into (names_replaced_by (new), names_replaced_by (old));\n+    bitmap_ior_into (names_replaced_by (new_tree), names_replaced_by (old));\n \n-  /* Register NEW and OLD in NEW_SSA_NAMES and OLD_SSA_NAMES,\n+  /* Register NEW_TREE and OLD in NEW_SSA_NAMES and OLD_SSA_NAMES,\n      respectively.  */\n-  SET_BIT (new_ssa_names, SSA_NAME_VERSION (new));\n+  SET_BIT (new_ssa_names, SSA_NAME_VERSION (new_tree));\n   SET_BIT (old_ssa_names, SSA_NAME_VERSION (old));\n \n   /* Update mapping counter to use in the virtual mapping heuristic.  */\n@@ -2757,12 +2757,12 @@ create_new_def_for (tree old_name, gimple stmt, def_operand_p def)\n    update_ssa.  */\n \n void\n-register_new_name_mapping (tree new ATTRIBUTE_UNUSED, tree old ATTRIBUTE_UNUSED)\n+register_new_name_mapping (tree new_Tree ATTRIBUTE_UNUSED, tree old ATTRIBUTE_UNUSED)\n {\n   if (need_to_initialize_update_ssa_p)\n     init_update_ssa ();\n \n-  add_new_name_mapping (new, old);\n+  add_new_name_mapping (new_Tree, old);\n }\n \n "}, {"sha": "3f77b2cb1f69a2276b03554a4e3b1b74c02a7102", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -897,7 +897,7 @@ mf_xform_derefs (void)\n   basic_block bb, next;\n   gimple_stmt_iterator i;\n   int saved_last_basic_block = last_basic_block;\n-  enum gimple_rhs_class class;\n+  enum gimple_rhs_class grhs_class;\n \n   bb = ENTRY_BLOCK_PTR ->next_bb;\n   do\n@@ -915,8 +915,8 @@ mf_xform_derefs (void)\n \t\t  \t\t gimple_location (s), integer_one_node);\n \t      mf_xform_derefs_1 (&i, gimple_assign_rhs1_ptr (s),\n \t\t  \t\t gimple_location (s), integer_zero_node);\n-\t      class = get_gimple_rhs_class (gimple_assign_rhs_code (s));\n-\t      if (class == GIMPLE_BINARY_RHS)\n+\t      grhs_class = get_gimple_rhs_class (gimple_assign_rhs_code (s));\n+\t      if (grhs_class == GIMPLE_BINARY_RHS)\n \t\tmf_xform_derefs_1 (&i, gimple_assign_rhs2_ptr (s),\n \t\t\t\t   gimple_location (s), integer_zero_node);\n               break;"}, {"sha": "e26149fd1b40ae0b9b6852f20dea25df31efb14b", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -267,7 +267,7 @@ typedef struct chain\n \n   /* For combination chains, the operator and the two chains that are\n      combined, and the type of the result.  */\n-  enum tree_code operator;\n+  enum tree_code op;\n   tree rslt_type;\n   struct chain *ch1, *ch2;\n \n@@ -409,7 +409,7 @@ dump_chain (FILE *file, chain_p chain)\n   if (chain->type == CT_COMBINATION)\n     {\n       fprintf (file, \"  equal to %p %s %p in type \",\n-\t       (void *) chain->ch1, op_symbol_code (chain->operator),\n+\t       (void *) chain->ch1, op_symbol_code (chain->op),\n \t       (void *) chain->ch2);\n       print_generic_expr (file, chain->rslt_type, TDF_SLIM);\n       fprintf (file, \"\\n\");\n@@ -1224,12 +1224,12 @@ determine_roots (struct loop *loop,\n }\n \n /* Replace the reference in statement STMT with temporary variable\n-   NEW.  If SET is true, NEW is instead initialized to the value of\n+   NEW_TREE.  If SET is true, NEW_TREE is instead initialized to the value of\n    the reference in the statement.  IN_LHS is true if the reference\n    is in the lhs of STMT, false if it is in rhs.  */\n \n static void\n-replace_ref_with (gimple stmt, tree new, bool set, bool in_lhs)\n+replace_ref_with (gimple stmt, tree new_tree, bool set, bool in_lhs)\n {\n   tree val;\n   gimple new_stmt;\n@@ -1245,7 +1245,7 @@ replace_ref_with (gimple stmt, tree new, bool set, bool in_lhs)\n       remove_phi_node (&psi, false);\n \n       /* Turn the phi node into GIMPLE_ASSIGN.  */\n-      new_stmt = gimple_build_assign (val, new);\n+      new_stmt = gimple_build_assign (val, new_tree);\n       gsi_insert_before (&bsi, new_stmt, GSI_NEW_STMT);\n       return;\n     }\n@@ -1256,11 +1256,11 @@ replace_ref_with (gimple stmt, tree new, bool set, bool in_lhs)\n \n   bsi = gsi_for_stmt (stmt);\n \n-  /* If we do not need to initialize NEW, just replace the use of OLD.  */\n+  /* If we do not need to initialize NEW_TREE, just replace the use of OLD.  */\n   if (!set)\n     {\n       gcc_assert (!in_lhs);\n-      gimple_assign_set_rhs_from_tree (&bsi, new);\n+      gimple_assign_set_rhs_from_tree (&bsi, new_tree);\n       stmt = gsi_stmt (bsi);\n       update_stmt (stmt);\n       return;\n@@ -1306,7 +1306,7 @@ replace_ref_with (gimple stmt, tree new, bool set, bool in_lhs)\n       val = gimple_assign_lhs (stmt);\n     }\n \n-  new_stmt = gimple_build_assign (new, unshare_expr (val));\n+  new_stmt = gimple_build_assign (new_tree, unshare_expr (val));\n   gsi_insert_after (&bsi, new_stmt, GSI_NEW_STMT);\n }\n \n@@ -1406,7 +1406,7 @@ get_init_expr (chain_p chain, unsigned index)\n       tree e1 = get_init_expr (chain->ch1, index);\n       tree e2 = get_init_expr (chain->ch2, index);\n \n-      return fold_build2 (chain->operator, chain->rslt_type, e1, e2);\n+      return fold_build2 (chain->op, chain->rslt_type, e1, e2);\n     }\n   else\n     return VEC_index (tree, chain->inits, index);\n@@ -2347,7 +2347,7 @@ combine_chains (chain_p ch1, chain_p ch2)\n \n   new_chain = XCNEW (struct chain);\n   new_chain->type = CT_COMBINATION;\n-  new_chain->operator = op;\n+  new_chain->op = op;\n   new_chain->ch1 = ch1;\n   new_chain->ch2 = ch2;\n   new_chain->rslt_type = rslt_type;"}, {"sha": "5708eedf3b2fdf25e05624a88dc197dffb4b5926", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -519,7 +519,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case BOOLEAN_TYPE:\n       {\n \tunsigned int quals = TYPE_QUALS (node);\n-\tenum tree_code_class class;\n+\tenum tree_code_class tclass;\n \n \tif (quals & TYPE_QUAL_CONST)\n \t  pp_string (buffer, \"const \");\n@@ -528,16 +528,16 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \telse if (quals & TYPE_QUAL_RESTRICT)\n \t  pp_string (buffer, \"restrict \");\n \n-\tclass = TREE_CODE_CLASS (TREE_CODE (node));\n+\ttclass = TREE_CODE_CLASS (TREE_CODE (node));\n \n-\tif (class == tcc_declaration)\n+\tif (tclass == tcc_declaration)\n \t  {\n \t    if (DECL_NAME (node))\n \t      dump_decl_name (buffer, node, flags);\n \t    else\n               pp_string (buffer, \"<unnamed type decl>\");\n \t  }\n-\telse if (class == tcc_type)\n+\telse if (tclass == tcc_type)\n \t  {\n \t    if (TYPE_NAME (node))\n \t      {"}, {"sha": "4198498800b6ecbc0cc5aac87f864159c40aff44", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -4346,16 +4346,16 @@ create_variable_info_for (tree decl, const char *name)\n {\n   unsigned int index = VEC_length (varinfo_t, varmap);\n   varinfo_t vi;\n-  tree decltype = TREE_TYPE (decl);\n-  tree declsize = DECL_P (decl) ? DECL_SIZE (decl) : TYPE_SIZE (decltype);\n+  tree decl_type = TREE_TYPE (decl);\n+  tree declsize = DECL_P (decl) ? DECL_SIZE (decl) : TYPE_SIZE (decl_type);\n   bool is_global = DECL_P (decl) ? is_global_var (decl) : false;\n   VEC (fieldoff_s,heap) *fieldstack = NULL;\n \n   if (TREE_CODE (decl) == FUNCTION_DECL && in_ipa_mode)\n     return create_function_info_for (decl, name);\n \n   if (var_can_have_subvars (decl) && use_field_sensitive)\n-    push_fields_onto_fieldstack (decltype, &fieldstack, 0);\n+    push_fields_onto_fieldstack (decl_type, &fieldstack, 0);\n \n   /* If the variable doesn't have subvars, we may end up needing to\n      sort the field list and create fake variables for all the"}, {"sha": "af4060c6a1e9b7a651a9237770f821b4c74e1ff9", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -6383,9 +6383,9 @@ simplify_cond_using_ranges (gimple stmt)\n \t able to simplify this conditional. */\n       if (vr->type == VR_RANGE)\n \t{\n-\t  tree new = test_for_singularity (cond_code, op0, op1, vr);\n+\t  tree new_tree = test_for_singularity (cond_code, op0, op1, vr);\n \n-\t  if (new)\n+\t  if (new_tree)\n \t    {\n \t      if (dump_file)\n \t\t{\n@@ -6396,7 +6396,7 @@ simplify_cond_using_ranges (gimple stmt)\n \n \t      gimple_cond_set_code (stmt, EQ_EXPR);\n \t      gimple_cond_set_lhs (stmt, op0);\n-\t      gimple_cond_set_rhs (stmt, new);\n+\t      gimple_cond_set_rhs (stmt, new_tree);\n \n \t      update_stmt (stmt);\n \n@@ -6413,9 +6413,9 @@ simplify_cond_using_ranges (gimple stmt)\n \t     with integral types here, so no need to worry about\n \t     issues with inverting FP comparisons.  */\n \t  cond_code = invert_tree_comparison (cond_code, false);\n-\t  new = test_for_singularity (cond_code, op0, op1, vr);\n+\t  new_tree = test_for_singularity (cond_code, op0, op1, vr);\n \n-\t  if (new)\n+\t  if (new_tree)\n \t    {\n \t      if (dump_file)\n \t\t{\n@@ -6426,7 +6426,7 @@ simplify_cond_using_ranges (gimple stmt)\n \n \t      gimple_cond_set_code (stmt, NE_EXPR);\n \t      gimple_cond_set_lhs (stmt, op0);\n-\t      gimple_cond_set_rhs (stmt, new);\n+\t      gimple_cond_set_rhs (stmt, new_tree);\n \n \t      update_stmt (stmt);\n "}, {"sha": "e01ba76d1e61e6944648d929aa71f4a54746b5e5", "filename": "gcc/tree.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -2594,7 +2594,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n {\n   enum tree_code code = TREE_CODE (exp);\n   tree op0, op1, op2, op3;\n-  tree new, inner;\n+  tree new_tree, inner;\n \n   /* We handle TREE_LIST and COMPONENT_REF separately.  */\n   if (code == TREE_LIST)\n@@ -2626,7 +2626,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n      if (op0 == TREE_OPERAND (exp, 0))\n        return exp;\n \n-     new = fold_build3 (COMPONENT_REF, TREE_TYPE (exp),\n+     new_tree = fold_build3 (COMPONENT_REF, TREE_TYPE (exp),\n \t\t\top0, TREE_OPERAND (exp, 1), NULL_TREE);\n    }\n   else\n@@ -2652,7 +2652,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t    if (op0 == TREE_OPERAND (exp, 0))\n \t      return exp;\n \n-\t    new = fold_build1 (code, TREE_TYPE (exp), op0);\n+\t    new_tree = fold_build1 (code, TREE_TYPE (exp), op0);\n \t    break;\n \n \t  case 2:\n@@ -2662,7 +2662,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n \t      return exp;\n \n-\t    new = fold_build2 (code, TREE_TYPE (exp), op0, op1);\n+\t    new_tree = fold_build2 (code, TREE_TYPE (exp), op0, op1);\n \t    break;\n \n \t  case 3:\n@@ -2674,7 +2674,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t\t&& op2 == TREE_OPERAND (exp, 2))\n \t      return exp;\n \n-\t    new = fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);\n+\t    new_tree = fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);\n \t    break;\n \n \t  case 4:\n@@ -2688,7 +2688,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t\t&& op3 == TREE_OPERAND (exp, 3))\n \t      return exp;\n \n-\t    new = fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));\n+\t    new_tree = fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));\n \t    break;\n \n \t  default:\n@@ -2714,7 +2714,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t    }\n \n \t  if (copy)\n-\t    new = fold (copy);\n+\t    new_tree = fold (copy);\n \t  else\n \t    return exp;\n \t}\n@@ -2724,8 +2724,8 @@ substitute_in_expr (tree exp, tree f, tree r)\n \tgcc_unreachable ();\n       }\n \n-  TREE_READONLY (new) = TREE_READONLY (exp);\n-  return new;\n+  TREE_READONLY (new_tree) = TREE_READONLY (exp);\n+  return new_tree;\n }\n \n /* Similar, but look for a PLACEHOLDER_EXPR in EXP and find a replacement\n@@ -5253,7 +5253,7 @@ iterative_hash_expr (const_tree t, hashval_t val)\n {\n   int i;\n   enum tree_code code;\n-  char class;\n+  char tclass;\n \n   if (t == NULL_TREE)\n     return iterative_hash_pointer (t, val);\n@@ -5322,16 +5322,16 @@ iterative_hash_expr (const_tree t, hashval_t val)\n \t}\n       /* else FALL THROUGH */\n     default:\n-      class = TREE_CODE_CLASS (code);\n+      tclass = TREE_CODE_CLASS (code);\n \n-      if (class == tcc_declaration)\n+      if (tclass == tcc_declaration)\n \t{\n \t  /* DECL's have a unique ID */\n \t  val = iterative_hash_host_wide_int (DECL_UID (t), val);\n \t}\n       else\n \t{\n-\t  gcc_assert (IS_EXPR_CODE_CLASS (class));\n+\t  gcc_assert (IS_EXPR_CODE_CLASS (tclass));\n \t  \n \t  val = iterative_hash_object (code, val);\n "}, {"sha": "da35008ca8e29f2c92f53218aebd48ce0218a43f", "filename": "gcc/value-prof.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d6e6fc38181e135084463bbf35b49484d68f04/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=82d6e6fc38181e135084463bbf35b49484d68f04", "patch": "@@ -333,12 +333,12 @@ gimple_duplicate_stmt_histograms (struct function *fun, gimple stmt,\n   histogram_value val;\n   for (val = gimple_histogram_value (ofun, ostmt); val != NULL; val = val->hvalue.next)\n     {\n-      histogram_value new = gimple_alloc_histogram_value (fun, val->type, NULL, NULL);\n-      memcpy (new, val, sizeof (*val));\n-      new->hvalue.stmt = stmt;\n-      new->hvalue.counters = XNEWVAR (gcov_type, sizeof (*new->hvalue.counters) * new->n_counters);\n-      memcpy (new->hvalue.counters, val->hvalue.counters, sizeof (*new->hvalue.counters) * new->n_counters);\n-      gimple_add_histogram_value (fun, stmt, new);\n+      histogram_value new_val = gimple_alloc_histogram_value (fun, val->type, NULL, NULL);\n+      memcpy (new_val, val, sizeof (*val));\n+      new_val->hvalue.stmt = stmt;\n+      new_val->hvalue.counters = XNEWVAR (gcov_type, sizeof (*new_val->hvalue.counters) * new_val->n_counters);\n+      memcpy (new_val->hvalue.counters, val->hvalue.counters, sizeof (*new_val->hvalue.counters) * new_val->n_counters);\n+      gimple_add_histogram_value (fun, stmt, new_val);\n     }\n }\n "}]}