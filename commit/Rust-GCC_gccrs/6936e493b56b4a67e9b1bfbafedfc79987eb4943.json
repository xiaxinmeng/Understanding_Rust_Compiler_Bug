{"sha": "6936e493b56b4a67e9b1bfbafedfc79987eb4943", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkzNmU0OTNiNTZiNGE2N2U5YjFiZmJhZmVkZmM3OTk4N2ViNDk0Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-10-11T16:36:03Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-10-11T16:36:03Z"}, "message": "cp-tree.h (get_dynamic_cast_base_type): Rename to ...\n\n\t* cp-tree.h (get_dynamic_cast_base_type): Rename to ...\n\t(dcast_base_hint): ... here.\n\t* rtti.c (build_dynamic_cast_1): Use dcast_base_hint.\n\t* search.c (struct dcast_data_s): New.\n\t(dynamic_cast_base_recurse): Remove. Replace with ...\n\t(dfs_dcast_hint_pre, dfs_dcast_base_post): ... these. New.\n\t(get_dynamic_cast_base_type): Rename to ...\n\t(dcast_base_hint): ... here.  Use dfs_walk_once_accessible.\n\t(accessible_r): Remove.\n\t(dfs_accessible_post): New, broken out of accessible_r.\n\t(accessible_p): Use dfs_walk_once_accessible.\n\t(dfs_walk_once_accessible_r): New. From accessible_r.\n\t(dfs_walk_once_accessible): New. From acessible_p.\n\nFrom-SVN: r88884", "tree": {"sha": "da0a95caf66e02585539ef9a5081dce3a080f1d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da0a95caf66e02585539ef9a5081dce3a080f1d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6936e493b56b4a67e9b1bfbafedfc79987eb4943", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6936e493b56b4a67e9b1bfbafedfc79987eb4943", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6936e493b56b4a67e9b1bfbafedfc79987eb4943", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6936e493b56b4a67e9b1bfbafedfc79987eb4943/comments", "author": null, "committer": null, "parents": [{"sha": "eb172681f75b5ff4196bf4e670826a7f442eb90c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb172681f75b5ff4196bf4e670826a7f442eb90c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb172681f75b5ff4196bf4e670826a7f442eb90c"}], "stats": {"total": 283, "additions": 183, "deletions": 100}, "files": [{"sha": "f12c2775f2114435332f8c00d4d025b61cfe9120", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6936e493b56b4a67e9b1bfbafedfc79987eb4943/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6936e493b56b4a67e9b1bfbafedfc79987eb4943/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6936e493b56b4a67e9b1bfbafedfc79987eb4943", "patch": "@@ -1,5 +1,19 @@\n 2004-10-11  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* cp-tree.h (get_dynamic_cast_base_type): Rename to ...\n+\t(dcast_base_hint): ... here.\n+\t* rtti.c (build_dynamic_cast_1): Use dcast_base_hint.\n+\t* search.c (struct dcast_data_s): New.\n+\t(dynamic_cast_base_recurse): Remove. Replace with ...\n+\t(dfs_dcast_hint_pre, dfs_dcast_base_post): ... these. New.\n+\t(get_dynamic_cast_base_type): Rename to ...\n+\t(dcast_base_hint): ... here.  Use dfs_walk_once_accessible.\n+\t(accessible_r): Remove.\n+\t(dfs_accessible_post): New, broken out of accessible_r.\n+\t(accessible_p): Use dfs_walk_once_accessible.\n+\t(dfs_walk_once_accessible_r): New. From accessible_r.\n+\t(dfs_walk_once_accessible): New. From acessible_p.\n+\n \t* cp-tree.h (SAME_BINFO_TYPE_P): New.\n \t* class.c (build_base_path): Use SAME_BINFO_TYPE_P to compare\n \tbinfo types."}, {"sha": "85d0aa6a79131f228e3177a1d28ece0219d84b2d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6936e493b56b4a67e9b1bfbafedfc79987eb4943/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6936e493b56b4a67e9b1bfbafedfc79987eb4943/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6936e493b56b4a67e9b1bfbafedfc79987eb4943", "patch": "@@ -3998,7 +3998,7 @@ extern bool emit_tinfo_decl (tree);\n /* in search.c */\n extern bool accessible_base_p (tree, tree);\n extern tree lookup_base (tree, tree, base_access, base_kind *);\n-extern tree get_dynamic_cast_base_type          (tree, tree);\n+extern tree dcast_base_hint                     (tree, tree);\n extern int accessible_p                         (tree, tree);\n extern tree lookup_field_1                      (tree, tree, bool);\n extern tree lookup_field\t\t\t(tree, tree, int, bool);"}, {"sha": "a0711466ac9847eb2463493e4d4f137d523dc2d8", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6936e493b56b4a67e9b1bfbafedfc79987eb4943/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6936e493b56b4a67e9b1bfbafedfc79987eb4943/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=6936e493b56b4a67e9b1bfbafedfc79987eb4943", "patch": "@@ -602,7 +602,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t  td3 = build_unary_op (ADDR_EXPR, td3, 0);\n \n           /* Determine how T and V are related.  */\n-          boff = get_dynamic_cast_base_type (static_type, target_type);\n+          boff = dcast_base_hint (static_type, target_type);\n           \n \t  /* Since expr is used twice below, save it.  */\n \t  expr = save_expr (expr);"}, {"sha": "5b642a35c60ad2edae164a88890fb8754bdb1b67", "filename": "gcc/cp/search.c", "status": "modified", "additions": 167, "deletions": 98, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6936e493b56b4a67e9b1bfbafedfc79987eb4943/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6936e493b56b4a67e9b1bfbafedfc79987eb4943/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=6936e493b56b4a67e9b1bfbafedfc79987eb4943", "patch": "@@ -37,8 +37,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"stack.h\"\n \n static int is_subobject_of_p (tree, tree);\n+static tree dfs_dcast_hint_pre (tree, void *);\n+static tree dfs_dcast_hint_post (tree, void *);\n static base_kind lookup_base_r (tree, tree, base_access, bool, tree *);\n-static int dynamic_cast_base_recurse (tree, tree, bool, tree *);\n static tree dfs_debug_mark (tree, void *);\n static tree dfs_walk_once_r (tree, tree (*pre_fn) (tree, void *),\n \t\t\t     tree (*post_fn) (tree, void *), void *data);\n@@ -49,7 +50,15 @@ static int lookup_conversions_r (tree, int, int,\n \t\t\t\t tree, tree, tree, tree, tree *, tree *);\n static int look_for_overrides_r (tree, tree);\n static tree lookup_field_r (tree, void *);\n-static tree accessible_r (tree, bool);\n+static tree dfs_accessible_post (tree, void *);\n+static tree dfs_walk_once_accessible_r (tree, bool, bool,\n+\t\t\t\t\ttree (*pre_fn) (tree, void *),\n+\t\t\t\t\ttree (*post_fn) (tree, void *),\n+\t\t\t\t\tvoid *data);\n+static tree dfs_walk_once_accessible (tree, bool,\n+\t\t\t\t      tree (*pre_fn) (tree, void *),\n+\t\t\t\t      tree (*post_fn) (tree, void *),\n+\t\t\t\t      void *data);\n static tree dfs_access_in_type (tree, void *);\n static access_kind access_in_type (tree, tree);\n static int protected_accessible_p (tree, tree, tree);\n@@ -268,49 +277,58 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n   return binfo;\n }\n \n-/* Worker function for get_dynamic_cast_base_type.  */\n+/* Data for dcast_base_hint walker.  */\n \n-static int\n-dynamic_cast_base_recurse (tree subtype, tree binfo, bool is_via_virtual,\n-\t\t\t   tree *offset_ptr)\n+struct dcast_data_s\n {\n-  VEC (tree) *accesses;\n-  tree base_binfo;\n-  int i;\n-  int worst = -2;\n+  tree subtype;   /* The base type we're looking for.  */\n+  int virt_depth; /* Number of virtual bases encountered from most\n+\t\t     derived.  */\n+  tree offset;    /* Best hint offset discovered so far.  */\n+  bool repeated_base;  /* Whether there are repeated bases in the\n+\t\t\t  heirarchy.  */\n+};\n+\n+/* Worker for dcast_base_hint.  Search for the base type being cast\n+   from.  */\n+\n+static tree\n+dfs_dcast_hint_pre (tree binfo, void *data_)\n+{\n+  struct dcast_data_s *data = data_;\n+\n+  if (BINFO_VIRTUAL_P (binfo))\n+    data->virt_depth++;\n   \n-  if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), subtype))\n+  if (SAME_BINFO_TYPE_P (BINFO_TYPE (binfo), data->subtype))\n     {\n-      if (is_via_virtual)\n-        return -1;\n+      if (data->virt_depth)\n+\t{\n+\t  data->offset = ssize_int (-1);\n+\t  return data->offset;\n+\t}\n+      if (data->offset)\n+\tdata->offset = ssize_int (-3);\n       else\n-        {\n-          *offset_ptr = BINFO_OFFSET (binfo);\n-          return 0;\n-        }\n+\tdata->offset = BINFO_OFFSET (binfo);\n+\n+      return data->repeated_base ? dfs_skip_bases : data->offset;\n     }\n-  \n-  accesses = BINFO_BASE_ACCESSES (binfo);\n-  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-    {\n-      tree base_access = VEC_index (tree, accesses, i);\n-      int rval;\n-      \n-      if (base_access != access_public_node)\n-        continue;\n-      rval = dynamic_cast_base_recurse\n-             (subtype, base_binfo,\n-              is_via_virtual || BINFO_VIRTUAL_P (base_binfo), offset_ptr);\n-      if (worst == -2)\n-        worst = rval;\n-      else if (rval >= 0)\n-        worst = worst >= 0 ? -3 : worst;\n-      else if (rval == -1)\n-        worst = -1;\n-      else if (rval == -3 && worst != -1)\n-        worst = -3;\n-    }\n-  return worst;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Worker for dcast_base_hint.  Track the virtual depth.  */\n+\n+static tree\n+dfs_dcast_hint_post (tree binfo, void *data_)\n+{\n+  struct dcast_data_s *data = data_;\n+\n+  if (BINFO_VIRTUAL_P (binfo))\n+    data->virt_depth--;\n+\n+  return NULL_TREE;\n }\n \n /* The dynamic cast runtime needs a hint about how the static SUBTYPE type\n@@ -325,16 +343,18 @@ dynamic_cast_base_recurse (tree subtype, tree binfo, bool is_via_virtual,\n    BOFF == -3, SUBTYPE occurs as multiple public non-virtual bases.  */\n \n tree\n-get_dynamic_cast_base_type (tree subtype, tree target)\n+dcast_base_hint (tree subtype, tree target)\n {\n-  tree offset = NULL_TREE;\n-  int boff = dynamic_cast_base_recurse (subtype, TYPE_BINFO (target),\n-                                        false, &offset);\n+  struct dcast_data_s data;\n+\n+  data.subtype = subtype;\n+  data.virt_depth = 0;\n+  data.offset = NULL_TREE;\n+  data.repeated_base = CLASSTYPE_REPEATED_BASE_P (target);\n   \n-  if (!boff)\n-    return offset;\n-  offset = ssize_int (boff);\n-  return offset;\n+  dfs_walk_once_accessible (TYPE_BINFO (target), /*friends=*/false,\n+\t\t\t    dfs_dcast_hint_pre, dfs_dcast_hint_post, &data);\n+  return data.offset ? data.offset : ssize_int (-2);\n }\n \n /* Search for a member with name NAME in a multiple inheritance\n@@ -806,41 +826,16 @@ friend_accessible_p (tree scope, tree decl, tree binfo)\n   return 0;\n }\n \n+/* Called via dfs_walk_once_accessible from accessible_p */\n+\n static tree\n-accessible_r (tree binfo, bool once)\n+dfs_accessible_post (tree binfo, void *data ATTRIBUTE_UNUSED)\n {\n-  tree rval = NULL_TREE;\n-  unsigned ix;\n-  tree base_binfo;\n-  \n-  /* Find the next child binfo to walk.  */\n-  for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n-    {\n-      bool mark = once && BINFO_VIRTUAL_P (base_binfo);\n-\n-      if (mark && BINFO_MARKED (base_binfo))\n-\tcontinue;\n-  \n-      /* If the base is inherited via private or protected\n-     \t inheritance, then we can't see it, unless we are a friend of\n-     \t the current binfo.  */\n-      if (BINFO_BASE_ACCESS (binfo, ix) != access_public_node\n-\t  && !is_friend (BINFO_TYPE (binfo), current_scope ()))\n-\tcontinue;\n-\n-      if (mark)\n-\tBINFO_MARKED (base_binfo) = 1;\n-\n-      rval = accessible_r (base_binfo, once);\n-      if (rval)\n-\treturn rval;\n-    }\n-  \n   if (BINFO_ACCESS (binfo) != ak_none\n       && is_friend (BINFO_TYPE (binfo), current_scope ()))\n-    rval = binfo;\n+    return binfo;\n   \n-  return rval;\n+  return NULL_TREE;\n }\n \n /* DECL is a declaration from a base class of TYPE, which was the\n@@ -929,27 +924,8 @@ accessible_p (tree type, tree decl)\n     {\n       /* Walk the hierarchy again, looking for a base class that allows\n \t access.  */\n-      t = accessible_r\n-\t(binfo, CLASSTYPE_DIAMOND_SHAPED_P (BINFO_TYPE (binfo)));\n-\n-      if (!CLASSTYPE_DIAMOND_SHAPED_P (BINFO_TYPE (binfo)))\n-\t;/* We are not diamond shaped, and therefore cannot\n-\t    encounter the same binfo twice.  */\n-      else if (!BINFO_INHERITANCE_CHAIN (binfo))\n-\t{\n-\t  /* We are at the top of the hierarchy, and can use the\n-             CLASSTYPE_VBASECLASSES list for unmarking the virtual\n-             bases.  */\n-\t  VEC (tree) *vbases;\n-\t  unsigned ix;\n-\t  tree base_binfo;\n-\t  \n-\t  for (vbases = CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo)), ix = 0;\n-\t       VEC_iterate (tree, vbases, ix, base_binfo); ix++)\n-\t    BINFO_MARKED (base_binfo) = 0;\n-\t}\n-      else\n-\tdfs_unmark_r (binfo);\n+      t = dfs_walk_once_accessible (binfo, /*friends=*/true,\n+\t\t\t\t    NULL, dfs_accessible_post, NULL);\n       \n       return t != NULL_TREE;\n     }\n@@ -1670,6 +1646,99 @@ dfs_walk_once (tree binfo, tree (*pre_fn) (tree, void *),\n   return rval;\n }\n \n+/* Worker function for dfs_walk_once_accessible.  Behaves like\n+   dfs_walk_once_r, except (a) FRIENDS_P is true if special\n+   access given by the current context should be considered, (b) ONCE\n+   indicates whether bases should be marked during traversal.  */\n+\n+static tree\n+dfs_walk_once_accessible_r (tree binfo, bool friends_p, bool once,\n+\t\t\t    tree (*pre_fn) (tree, void *),\n+\t\t\t    tree (*post_fn) (tree, void *), void *data)\n+{\n+  tree rval = NULL_TREE;\n+  unsigned ix;\n+  tree base_binfo;\n+\n+  /* Call the pre-order walking function.  */\n+  if (pre_fn)\n+    {\n+      rval = pre_fn (binfo, data);\n+      if (rval)\n+\t{\n+\t  if (rval == dfs_skip_bases)\n+\t    goto skip_bases;\n+\t  \n+\t  return rval;\n+\t}\n+    }\n+\n+  /* Find the next child binfo to walk.  */\n+  for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n+    {\n+      bool mark = once && BINFO_VIRTUAL_P (base_binfo);\n+\n+      if (mark && BINFO_MARKED (base_binfo))\n+\tcontinue;\n+  \n+      /* If the base is inherited via private or protected\n+     \t inheritance, then we can't see it, unless we are a friend of\n+     \t the current binfo.  */\n+      if (BINFO_BASE_ACCESS (binfo, ix) != access_public_node\n+\t  && !(friends_p && is_friend (BINFO_TYPE (binfo), current_scope ())))\n+\tcontinue;\n+\n+      if (mark)\n+\tBINFO_MARKED (base_binfo) = 1;\n+\n+      rval = dfs_walk_once_accessible_r (base_binfo, friends_p, once,\n+\t\t\t\t\t pre_fn, post_fn, data);\n+      if (rval)\n+\treturn rval;\n+    }\n+  \n+ skip_bases:\n+  /* Call the post-order walking function.  */\n+  if (post_fn)\n+    return post_fn (binfo, data);\n+  \n+  return NULL_TREE;\n+}\n+\n+/* Like dfs_walk_once except that only accessible bases are walked.\n+   FRIENDS_P indicates whether friendship of the local context\n+   should be considered when determining accessibility.  */\n+\n+static tree\n+dfs_walk_once_accessible (tree binfo, bool friends_p,\n+\t\t\t    tree (*pre_fn) (tree, void *),\n+\t\t\t    tree (*post_fn) (tree, void *), void *data)\n+{\n+  bool diamond_shaped = CLASSTYPE_DIAMOND_SHAPED_P (BINFO_TYPE (binfo));\n+  tree rval = dfs_walk_once_accessible_r (binfo, friends_p, diamond_shaped,\n+\t\t\t\t\t  pre_fn, post_fn, data);\n+  \n+  if (diamond_shaped)\n+    {\n+      if (!BINFO_INHERITANCE_CHAIN (binfo))\n+\t{\n+\t  /* We are at the top of the hierachy, and can use the\n+             CLASSTYPE_VBASECLASSES list for unmarking the virtual\n+             bases.  */\n+\t  VEC (tree) *vbases;\n+\t  unsigned ix;\n+\t  tree base_binfo;\n+\t  \n+\t  for (vbases = CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo)), ix = 0;\n+\t       VEC_iterate (tree, vbases, ix, base_binfo); ix++)\n+\t    BINFO_MARKED (base_binfo) = 0;\n+\t}\n+      else\n+\tdfs_unmark_r (binfo);\n+    }\n+  return rval;\n+}\n+\n /* Check that virtual overrider OVERRIDER is acceptable for base function\n    BASEFN. Issue diagnostic, and return zero, if unacceptable.  */\n "}]}