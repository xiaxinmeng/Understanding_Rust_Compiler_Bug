{"sha": "6bb36601f1c5a8f758f29523d514f9e27ee711f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJiMzY2MDFmMWM1YThmNzU4ZjI5NTIzZDUxNGY5ZTI3ZWU3MTFmOA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-11-11T04:33:43Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-11-11T04:33:43Z"}, "message": "* PA PIC support.\n\n\t* pa.c (secondary_reload_class): Refine.  Readonly data needs a\n\tsecondary reload only during PIC generation.  Loading a floating\n\tpoint register with a constant requires a register from R1_REGS\n\tduring -fPIC code generation.\n\t(read_only_operand): Constant pool entries are no longer read only\n\tduring PIC code generation.\n\t(hppa_legitimize_address): If flag_pic is nonzero, then\n\timmediately call legitimize_pic_address.\n\t(emit_move_sequence): Call legitimize_pic_address to handle\n\tconstant data.  Handle secondary reloads for PIC.  Use\n\tpic_label_operand rather than open coding the test.  Handle\n\tloading a LABEL_REF when generating PIC.\n\t(legitimzie_pic_address): Handle constant data addressing for PIC\n\there.   Fix loading of symbolic addresses for -fPIC generation.\n\t(pic_label_operand): Renamed from pic_operand.  Handle any read\n\tonly operand (such as constant data).  Reject function addresses,\n\tAccept SYMBOL_REF with the read-only bit set.  Generalize to\n\thandle (const (plus (reg) (int))).\n\t(finalize_pic): Delete unused function.\n\t(check_pic): Delete function.\n\t(pic_pc_rtx): Delete variable definition.\n\t(current_function_uses_pic_offset_table): Delete extern decl.\n\t(force_reg, validize_mem): Likewise.\n        (output_global_address): Don't tack on \"-$global$\" when generating\n        PIC code.\n\t(finalize_pic): Don't emit code for initialization of\n\thppa_save_pic_table_rtx here.  Don't claim we USE\n\tpic_offset_table_rtx at function end.\n\t* pa.h (SELECT_RTX_SECTION): Define.  During PIC generation\n\teverything (in the constant pool) goes into the data space.\n\t(PRINT_OPERAND_ADDRESS): Handle CONST_INTs during PIC\n\tgeneration.  Handle LO_SUM address during -fPIC generation.\n\t(LEGITIMATE_CONSTANT_P): Reject function labels when generating\n\tPIC code.\n\t(GO_IF_LEGITIMATE_ADDRESS): Only accept pic_reg + SYMBOL_REF for\n\t-fpic.\n\t(EXTRA_SECTION_FUNCTIONS): For -fpic, use the TEXT section for\n\tconstants to avoid GAS lossage.\n\t(OVERRIDE_OPTIONS): Delete.\n\t(PIC_OFFSET_TABLE_REG_CALL_CLOBBERED): Define.\n\t(FINALIZE_PIC): Delete definition.\n\t(INIT_EXPANDERS): Define.  Clear hppa_save_pic_table_rtx here.\n\t* pa.md: Use !flag_pic rather than calling check_pic.\n\t(HImode high and lo_sum): Only accept const_int_operands.\n\t(pic_load_label): Force output to be in %r1.\n\t(pic_highpart): New pattern.  Output must go into %r1.  More\n\tlinker trickery.\n\t(symbolic high and lo_sum): Disallow during PIC\tgeneration if\n\tsource is a symbolic operand.  Handle CONST_INT LO_SUM during PIC\n\tgeneration.  Simplify.\n\t(define_split for symbolic_operand load): Do not accept a symbolic\n\toperand that is a pic_label_operand.\n\t(pic_load_label): Name this pattern.  Mask least significant bits\n\tand optimize when a simple label is within reach of an ldo.\n\t(call, call_value): Emit new-style USE information for\n\tpic_offset_table_rtx.  Emit code for initialization of\n\thppa_save_pic_table_rtx and wrap it into push_topmost_sequence()\n\tand pop_topmost_sequence() calls.\n\nFrom-SVN: r8419", "tree": {"sha": "4d67fb8a4a81191e22da8cca8a7163d77653ba82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d67fb8a4a81191e22da8cca8a7163d77653ba82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bb36601f1c5a8f758f29523d514f9e27ee711f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bb36601f1c5a8f758f29523d514f9e27ee711f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bb36601f1c5a8f758f29523d514f9e27ee711f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bb36601f1c5a8f758f29523d514f9e27ee711f8/comments", "author": null, "committer": null, "parents": [{"sha": "858e1c67f7b5f471fb8d74624f7074610f43fdc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/858e1c67f7b5f471fb8d74624f7074610f43fdc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/858e1c67f7b5f471fb8d74624f7074610f43fdc6"}], "stats": {"total": 328, "additions": 195, "deletions": 133}, "files": [{"sha": "2ec55bab63937bcec27fad81c32ca667749e2007", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 65, "deletions": 66, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bb36601f1c5a8f758f29523d514f9e27ee711f8/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bb36601f1c5a8f758f29523d514f9e27ee711f8/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=6bb36601f1c5a8f758f29523d514f9e27ee711f8", "patch": "@@ -219,11 +219,29 @@ reg_or_cint_move_operand (op, mode)\n }\n \n int\n-pic_operand (op, mode)\n+pic_label_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  return flag_pic && GET_CODE (op) == LABEL_REF;\n+  if (!flag_pic)\n+    return 0;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case LABEL_REF:\n+      return 1;\n+    case SYMBOL_REF:\n+      return (read_only_operand (op) && !FUNCTION_NAME_P (XSTR (op, 0)));\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return (((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t\t&& read_only_operand (XEXP (op, 0))\n+\t\t&& !FUNCTION_NAME_P (XSTR (XEXP (op, 0), 0)))\n+\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+    default:\n+      return 0;\n+    }\n }\n \n int\n@@ -235,32 +253,6 @@ fp_reg_operand (op, mode)\n }\n \n \f\n-extern int current_function_uses_pic_offset_table;\n-extern rtx force_reg (), validize_mem ();\n-\n-/* The rtx for the global offset table which is a special form\n-   that *is* a position independent symbolic constant.  */\n-rtx pic_pc_rtx;\n-\n-/* Ensure that we are not using patterns that are not OK with PIC.  */\n-\n-int\n-check_pic (i)\n-     int i;\n-{\n-  extern rtx recog_operand[];\n-  switch (flag_pic)\n-    {\n-    case 1:\n-      if (GET_CODE (recog_operand[i]) == SYMBOL_REF\n-\t  || (GET_CODE (recog_operand[i]) == CONST\n-\t      && ! rtx_equal_p (pic_pc_rtx, recog_operand[i])))\n-\tabort ();\n-    case 2:\n-    default:\n-      return 1;\n-    }\n-}\n \n /* Return truth value of whether OP can be used as an operand in a\n    three operand arithmetic insn that accepts registers of mode MODE\n@@ -480,22 +472,26 @@ legitimize_pic_address (orig, mode, reg)\n {\n   rtx pic_ref = orig;\n \n+  /* Lables and read-only data need special handling.  */\n+  if (pic_label_operand (orig))\n+    {\n+      emit_insn (gen_pic_load_label (reg, orig));\n+      current_function_uses_pic_offset_table = 1;\n+      return reg;\n+    }\n   if (GET_CODE (orig) == SYMBOL_REF)\n     {\n       if (reg == 0)\n \tabort ();\n \n       if (flag_pic == 2)\n \t{\n-\t  emit_insn (gen_rtx (SET, VOIDmode, reg,\n-\t\t\t      gen_rtx (HIGH, Pmode, orig)));\n-\t  emit_insn (gen_rtx (SET, VOIDmode, reg,\n-\t\t\t      gen_rtx (LO_SUM, Pmode, reg, orig)));\n-\t  orig = reg;\n+\t  emit_insn (gen_pic_highpart (reg, pic_offset_table_rtx, orig));\n+\t  pic_ref = (gen_rtx (MEM, Pmode, gen_rtx (LO_SUM, Pmode, reg, orig)));\n \t}\n-      pic_ref = gen_rtx (MEM, Pmode,\n-\t\t\t gen_rtx (PLUS, Pmode,\n-\t\t\t\t  pic_offset_table_rtx, orig));\n+      else\n+\tpic_ref = gen_rtx (MEM, Pmode,\n+\t\t\t   gen_rtx (PLUS, Pmode, pic_offset_table_rtx, orig));\n       current_function_uses_pic_offset_table = 1;\n       RTX_UNCHANGING_P (pic_ref) = 1;\n       emit_move_insn (reg, pic_ref);\n@@ -531,24 +527,6 @@ legitimize_pic_address (orig, mode, reg)\n   return pic_ref;\n }\n \n-/* Emit special PIC prologues and epilogues.  */\n-\n-void\n-finalize_pic ()\n-{\n-  if (hppa_save_pic_table_rtx)\n-    {\n-      emit_insn_after (gen_rtx (SET, VOIDmode,\n-\t\t\t\thppa_save_pic_table_rtx,\n-\t\t\t\tgen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM)),\n-\t\t       get_insns ());\n-      /* Need to emit this whether or not we obey regdecls,\n-\t since setjmp/longjmp can cause life info to screw up.  */\n-      hppa_save_pic_table_rtx = 0;\n-    }\n-  emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n-}\n-\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n    This macro is used in only one place: `memory_address' in explow.c.\n@@ -607,6 +585,9 @@ hppa_legitimize_address (x, oldx, mode)\n {\n   rtx orig = x;\n \n+  if (flag_pic)\n+    return legitimize_pic_address (x, mode, gen_reg_rtx (Pmode));\n+\n   /* Strip off CONST. */\n   if (GET_CODE (x) == CONST)\n     x = XEXP (x, 0);\n@@ -727,9 +708,6 @@ hppa_legitimize_address (x, oldx, mode)\n \t}\n     }\n \n-  if (flag_pic)\n-    return legitimize_pic_address (x, mode, gen_reg_rtx (Pmode));\n-\n   return orig;\n }\n \n@@ -895,16 +873,16 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t      rtx temp;\n \n \t      if (reload_in_progress || reload_completed)\n-\t\ttemp = operand0;\n+\t\ttemp = scratch_reg ? scratch_reg : operand0;\n \t      else\n \t\ttemp = gen_reg_rtx (Pmode);\n \n \t      operands[1] = legitimize_pic_address (operand1, mode, temp);\n-              emit_insn (gen_rtx (SET, VOIDmode, operand0, operands[1]));\n+\t      emit_insn (gen_rtx (SET, VOIDmode, operand0, operands[1]));\n \t    }\n-\t  /* On the HPPA, references to data space are supposed to */\n-\t  /* use dp, register 27, but showing it in the RTL inhibits various\n-\t     cse and loop optimizations.  */\n+\t  /* On the HPPA, references to data space are supposed to use dp,\n+\t     register 27, but showing it in the RTL inhibits various cse\n+\t     and loop optimizations.  */\n \t  else\n \t    {\n \t      rtx temp, set, const_part = NULL;\n@@ -982,8 +960,16 @@ read_only_operand (operand)\n {\n   if (GET_CODE (operand) == CONST)\n     operand = XEXP (XEXP (operand, 0), 0);\n-  if (GET_CODE (operand) == SYMBOL_REF)\n-    return SYMBOL_REF_FLAG (operand) || CONSTANT_POOL_ADDRESS_P (operand);\n+  if (flag_pic)\n+    {\n+      if (GET_CODE (operand) == SYMBOL_REF)\n+\treturn SYMBOL_REF_FLAG (operand) && !CONSTANT_POOL_ADDRESS_P (operand);\n+    }\n+  else\n+    {\n+      if (GET_CODE (operand) == SYMBOL_REF)\n+\treturn SYMBOL_REF_FLAG (operand) || CONSTANT_POOL_ADDRESS_P (operand);\n+    }\n   return 1;\n }\n \n@@ -2950,7 +2936,7 @@ output_global_address (file, x)\n \n   if (GET_CODE (x) == SYMBOL_REF && read_only_operand (x))\n     assemble_name (file, XSTR (x, 0));\n-  else if (GET_CODE (x) == SYMBOL_REF)\n+  else if (GET_CODE (x) == SYMBOL_REF && !flag_pic)\n     {\n       assemble_name (file, XSTR (x, 0));\n       fprintf (file, \"-$global$\");\n@@ -2994,7 +2980,7 @@ output_global_address (file, x)\n \tsep = \"-\";\n       else abort ();\n \n-      if (!read_only_operand (base))\n+      if (!read_only_operand (base) && !flag_pic)\n \tfprintf (file, \"-$global$\");\n       fprintf (file, \"%s\", sep);\n       if (offset) fprintf (file,\"%d\", offset);\n@@ -3261,6 +3247,14 @@ secondary_reload_class (class, mode, in)\n {\n   int regno = true_regnum (in);\n \n+  /* Trying to load a constant into a FP register during PIC code\n+     generation will require %r1 as a scratch register.  */\n+  if (flag_pic == 2\n+      && GET_MODE_CLASS (mode) == MODE_INT\n+      && FP_REG_CLASS_P (class)\n+      && (GET_CODE (in) == CONST_INT || GET_CODE (in) == CONST_DOUBLE))\n+    return R1_REGS;\n+\n   if (((regno >= FIRST_PSEUDO_REGISTER || regno == -1)\n        && GET_MODE_CLASS (mode) == MODE_INT\n        && FP_REG_CLASS_P (class))\n@@ -3270,6 +3264,11 @@ secondary_reload_class (class, mode, in)\n   if (GET_CODE (in) == HIGH)\n     in = XEXP (in, 0);\n \n+  if (!flag_pic\n+      && symbolic_operand (in, VOIDmode)\n+      && read_only_operand (in))\n+    return NO_REGS;\n+\n   if (class != R1_REGS && symbolic_operand (in, VOIDmode))\n     return R1_REGS;\n "}, {"sha": "cf880aff622ad0d930cd63305aaf9fcf0319264d", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bb36601f1c5a8f758f29523d514f9e27ee711f8/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bb36601f1c5a8f758f29523d514f9e27ee711f8/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=6bb36601f1c5a8f758f29523d514f9e27ee711f8", "patch": "@@ -182,21 +182,6 @@ extern int target_flags;\n #define WCHAR_TYPE \"unsigned int\"\n #define WCHAR_TYPE_SIZE 32\n \n-/* Sometimes certain combinations of command options do not make sense\n-   on a particular target machine.  You can define a macro\n-   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n-   defined, is executed once just after all the command options have\n-   been parsed.\n-\n-   On the PA, it is used to explicitly warn the user that -fpic and -fPIC\n-   do not work.  */\n-\n-#define OVERRIDE_OPTIONS \\\n-{\t\t\t\t\t\t\t\t\\\n-  if (flag_pic != 0)\t\t\t\t\t\t\\\n-    warning (\"-fpic and -fPIC are not supported on the PA.\");\t\\\n-}\n-\n /* Show we can debug even without a frame pointer.  */\n #define CAN_DEBUG_WITHOUT_FP\n \n@@ -495,8 +480,12 @@ extern int target_flags;\n    data references.  */\n \n #define PIC_OFFSET_TABLE_REGNUM 19\n+#define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED 1\n \n-#define FINALIZE_PIC finalize_pic ()\n+/* Initialize hppa_save_pic_table_rtx before RTL generation for\n+   each function.  We used to do this in FINALIZE_PIC, but FINALIZE_PIC\n+   isn't always called for static inline functions.  */\n+#define INIT_EXPANDERS hppa_save_pic_table_rtx = 0;\n \n /* SOM ABI says that objects larger than 64 bits are returned in memory.  */\n #define RETURN_IN_MEMORY(TYPE)\t\\\n@@ -1185,8 +1174,9 @@ extern union tree_node *current_function_decl;\n    floating-point, except for floating-point zero.  */\n \n #define LEGITIMATE_CONSTANT_P(X)  \t\t\\\n-  (GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT\t\\\n-    || (X) == CONST0_RTX (GET_MODE (X)))\n+  ((GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT\t\\\n+    || (X) == CONST0_RTX (GET_MODE (X)))\t\\\n+   && !(flag_pic && function_label_operand (X, VOIDmode)))\n \n /* Subroutine for EXTRA_CONSTRAINT.\n \n@@ -1307,9 +1297,7 @@ extern union tree_node *current_function_decl;\n \t      && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\\\n \t    goto ADDR;\t\t\t\t\t\\\n \t  else if (flag_pic == 1\t\t\t\\\n-\t\t   && GET_CODE (XEXP (X, 1)) != REG\t\\\n-\t\t   && GET_CODE (XEXP (X, 1)) != LO_SUM\t\\\n-\t\t   && GET_CODE (XEXP (X, 1)) != MEM)\t\\\n+\t\t   && GET_CODE (XEXP (X, 1)) == SYMBOL_REF)\\\n \t    goto ADDR;\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\\\n       else if (REG_P (XEXP (X, 0))\t\t\t\\\n@@ -1427,6 +1415,17 @@ while (0)\n \t\t\t     1 + (SYMBOL_NAME)[1] == '@'\\\n \t\t\t     : (SYMBOL_NAME)[0] == '@'))\n \n+/* Arghh.  This is used for stuff in the constant pool; this may include\n+   function addresses on the PA, which during PIC code generation must\n+   reside in the data space.  Unfortuantely, there's no way to determine\n+   if a particular label in the constant pool refers to a function address.\n+   So just force everything into the data space during PIC generation.  */\n+#define SELECT_RTX_SECTION(RTX,MODE)\t\\\n+  if (flag_pic)\t\t\t\t\\\n+    data_section ();\t\t\t\\\n+  else\t\t\t\t\t\\\n+    readonly_data_section ();\n+\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n #define CASE_VECTOR_MODE DImode\n@@ -1682,6 +1681,10 @@ do { fprintf (FILE, \"\\t.SPACE $PRIVATE$\\n\\\n \n #define EXTRA_SECTIONS in_bss, in_readonly_data\n \n+/* FIXME: GAS doesn't grok expressions involving two symbols in different\n+   segments (aka subspaces).  Two avoid creating such expressions, we place\n+   readonly data into the $CODE$ subspace when generating PIC code.  If\n+   GAS ever handles such expressions, this hack can disappear.  */\n #define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n bss_section ()\t\t\t\t\t\t\t\t\\\n@@ -1697,7 +1700,10 @@ readonly_data ()\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (in_section != in_readonly_data)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", READONLY_DATA_ASM_OP);\t\t\\\n+      if (flag_pic)\t\t\t\t\t\t\t\\\n+\tfprintf (asm_out_file, \"%s\\n\", TEXT_SECTION_ASM_OP);\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tfprintf (asm_out_file, \"%s\\n\", READONLY_DATA_ASM_OP);\t\t\\\n       in_section = in_readonly_data;\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n@@ -1980,7 +1986,12 @@ readonly_data ()\t\t\t\t\t\t\t\\\n       fprintf (FILE, \"%d(0,%s)\", offset, reg_names [REGNO (base)]);\t\\\n       break;\t\t\t\t\t\t\t\t\\\n     case LO_SUM:\t\t\t\t\t\t\t\\\n-      fputs (\"R'\", FILE);\t\t\t\t\t\t\\\n+      if (flag_pic == 0 || !symbolic_operand (XEXP (addr, 1)))\t\t\\\n+\tfputs (\"R'\", FILE);\t\t\t\t\t\t\\\n+      else if (flag_pic == 1)\t\t\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+      else if (flag_pic == 2)\t\t\t\t\t\t\\\n+\tfputs (\"RT'\", FILE);\t\t\t\t\t\t\\\n       output_global_address (FILE, XEXP (addr, 1));\t\t\t\\\n       fputs (\"(\", FILE);\t\t\t\t\t\t\\\n       output_operand (XEXP (addr, 0), 0);\t\t\t\t\\"}, {"sha": "3bb5b073193468e13926b1319d2971c29c36b3f4", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 96, "deletions": 44, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bb36601f1c5a8f758f29523d514f9e27ee711f8/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bb36601f1c5a8f758f29523d514f9e27ee711f8/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=6bb36601f1c5a8f758f29523d514f9e27ee711f8", "patch": "@@ -1124,10 +1124,11 @@\n    (set_attr \"length\" \"4\")])\n \n ;; For pic\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"pic_operand\" \"i\"))\n-   (clobber (match_scratch:SI 2 \"=a\"))]\n+;; Note since this pattern can be created at reload time (via movsi), all\n+;; the same rules for movsi apply here.  (no new pseudos, no temporaries).\n+(define_insn \"pic_load_label\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(match_operand:SI 1 \"pic_label_operand\" \"\"))]\n   \"\"\n   \"*\n {\n@@ -1138,14 +1139,43 @@\n   xoperands[0] = operands[0];\n   xoperands[1] = operands[1];\n   xoperands[2] = label_rtx;\n-  output_asm_insn (\\\"bl .+8,%0\\;addil L'%1-%2,%0\\\", xoperands);\n-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (label_rtx));\n-  output_asm_insn (\\\"ldo R'%1-%2(1),%0\\\", xoperands);\n+  output_asm_insn (\\\"bl .+8,%0\\\", xoperands);\n+  output_asm_insn (\\\"depi 0,31,2,%0\\\", xoperands);\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t     CODE_LABEL_NUMBER (label_rtx));\n+\n+  /* If we're trying to load the address of a label that happens to be\n+     close, then we can use a shorter sequence.  */\n+  if (GET_CODE (operands[1]) == LABEL_REF\n+      && insn_addresses\n+      && abs (insn_addresses[INSN_UID (XEXP (operands[1], 0))]\n+\t        - insn_current_address) < 8100)\n+    {\n+      /* Prefixing with R% here is wrong, it extracts just 11 bits and is\n+\t always non-negative.  */\n+      output_asm_insn (\\\"ldo %1-%2(%0),%0\\\", xoperands);\n+    }\n+  else\n+    {\n+      output_asm_insn (\\\"addil L%%%1-%2,%0\\\", xoperands);\n+      output_asm_insn (\\\"ldo R%%%1-%2(%0),%0\\\", xoperands);\n+    }\n   return \\\"\\\";\n-  }\n-\"\n+}\"\n   [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"12\")])\n+   (set_attr \"length\" \"16\")])\t\t; 12 or 16\n+\n+(define_insn \"pic_highpart\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus (match_operand:SI 1 \"register_operand\" \"r\")\n+\t      (high:SI (match_operand 2 \"\" \"\"))))]\n+  \"symbolic_operand (operands[2], Pmode)\n+   && ! function_label_operand (operands[2])\n+   && ! read_only_operand (operands[2])\n+   && flag_pic == 2\"\n+  \"addil LT'%G2,%1\"\n+  [(set_attr \"type\" \"binary\")\n+   (set_attr \"length\" \"4\")])\n \n ;; Always use addil rather than ldil;add sequences.  This allows the\n ;; HP linker to eliminate the dp relocation if the symbolic operand\n@@ -1155,9 +1185,9 @@\n \t(high:SI (match_operand 1 \"\" \"\")))]\n   \"symbolic_operand (operands[1], Pmode)\n    && ! function_label_operand (operands[1])\n-   && ! read_only_operand (operands[1])\"\n-  \"@\n-   addil L'%G1,%%r27\"\n+   && ! read_only_operand (operands[1])\n+   && ! flag_pic\"\n+  \"addil L'%G1,%%r27\"\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"4\")])\n \n@@ -1199,7 +1229,8 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(high:SI (match_operand 1 \"\" \"\")))]\n-  \"check_pic (1) && !is_function_label_plus_const (operands[1])\"\n+  \"(!flag_pic || !symbolic_operand (operands[1]), Pmode)\n+    && !is_function_label_plus_const (operands[1])\"\n   \"ldil L'%G1,%0\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"4\")])\n@@ -1233,7 +1264,15 @@\n \t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"!is_function_label_plus_const (operands[2])\"\n-  \"ldo R'%G2(%1),%0\"\n+  \"*\n+{\n+  if (flag_pic == 2 && symbolic_operand (operands[2], Pmode))\n+    return \\\"ldw RT'%G2(%1),%0\\\";\n+  else if (flag_pic == 1 && symbolic_operand (operands[2], Pmode))\n+    abort ();\n+  else\n+    return \\\"ldo R'%G2(%1),%0\\\";\n+}\"\n   [(set_attr \"length\" \"4\")])\n \n ;; Now that a symbolic_address plus a constant is broken up early\n@@ -1245,7 +1284,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(match_operand:SI 1 \"symbolic_operand\" \"\"))\n    (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n-  \"\"\n+  \"! (flag_pic && pic_label_operand (operands[1], SImode))\"\n   [(set (match_dup 2) (high:SI (match_dup 1)))\n    (set (match_dup 0) (lo_sum:SI (match_dup 2) (match_dup 1)))]\n   \"\")\n@@ -1337,16 +1376,16 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(high:HI (match_operand 1 \"\" \"\")))]\n-  \"check_pic (1)\"\n+\t(high:HI (match_operand 1 \"const_int_operand\" \"\")))]\n+  \"\"\n   \"ldil L'%G1,%0\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(lo_sum:HI (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t   (match_operand 2 \"immediate_operand\" \"i\")))]\n+\t\t   (match_operand 2 \"const_int_operand\" \"i\")))]\n   \"\"\n   \"ldo R'%G2(%1),%0\"\n   [(set_attr \"length\" \"4\")])\n@@ -1651,7 +1690,7 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(high:DI (match_operand 1 \"\" \"\")))]\n-  \"check_pic (1)\"\n+  \"\"\n   \"*\n {\n   rtx op0 = operands[0];\n@@ -3102,10 +3141,7 @@\n   \"\n {\n   rtx op;\n-\n-  if (flag_pic)\n-    emit_insn (gen_rtx (USE, VOIDmode,\n-\t\t\tgen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM)));\n+  rtx call_insn;\n \n   if (TARGET_LONG_CALLS)\n     op = force_reg (SImode, XEXP (operands[0], 0));\n@@ -3118,17 +3154,27 @@\n      to change the named call into an indirect call in some cases (using\n      two patterns keeps CSE from performing this optimization).  */\n   if (GET_CODE (op) == SYMBOL_REF)\n-    emit_call_insn (gen_call_internal_symref (op, operands[1]));\n+    call_insn = emit_call_insn (gen_call_internal_symref (op, operands[1]));\n   else\n-    emit_call_insn (gen_call_internal_reg (force_reg (SImode, op),\n-\t\t\t\t\t   operands[1]));\n+    call_insn = emit_call_insn (gen_call_internal_reg (force_reg (SImode, op),\n+\t\t\t\t\t\t       operands[1]));\n \n   if (flag_pic)\n     {\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n+\n       if (!hppa_save_pic_table_rtx)\n-\thppa_save_pic_table_rtx = gen_reg_rtx (Pmode);\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  gen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM),\n+\t{\n+\t  hppa_save_pic_table_rtx = gen_reg_rtx (Pmode);\n+\t  push_topmost_sequence ();\n+\t  emit_insn_after (gen_rtx (SET, VOIDmode,\n+\t\t\t\t    hppa_save_pic_table_rtx,\n+\t\t\t\t    pic_offset_table_rtx),\n+\t\t\t   get_insns ());\n+\t  pop_topmost_sequence ();\n+\t}\n+\n+      emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n \t\t\t  hppa_save_pic_table_rtx));\n     }\n   DONE;\n@@ -3173,15 +3219,11 @@\n \t\t   (call (match_operand:SI 1 \"\" \"\")\n \t\t\t (match_operand 2 \"\" \"\")))\n \t      (clobber (reg:SI 2))])]\n-  ;;- Don't use operand 1 for most machines.\n   \"\"\n   \"\n {\n   rtx op;\n-\n-  if (flag_pic)\n-    emit_insn (gen_rtx (USE, VOIDmode,\n-\t\t\tgen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM)));\n+  rtx call_insn;\n \n   if (TARGET_LONG_CALLS)\n     op = force_reg (SImode, XEXP (operands[1], 0));\n@@ -3194,19 +3236,30 @@\n      to change the named call into an indirect call in some cases (using\n      two patterns keeps CSE from performing this optimization).  */\n   if (GET_CODE (op) == SYMBOL_REF)\n-    emit_call_insn (gen_call_value_internal_symref (operands[0], op,\n-\t\t\t\t\t\t    operands[2]));\n+    call_insn = emit_call_insn (gen_call_value_internal_symref (operands[0],\n+\t\t\t\t\t\t\t\top,\n+\t\t\t\t\t\t\t\toperands[2]));\n   else\n-    emit_call_insn (gen_call_value_internal_reg (operands[0],\n-\t\t\t\t\t\t force_reg (SImode, op),\n-\t\t\t\t\t\t operands[2]));\n+    call_insn = emit_call_insn (gen_call_value_internal_reg (operands[0],\n+\t\t\t\t\t\t\t     force_reg (SImode, op),\n+\t\t\t\t\t\t\t     operands[2]));\n \n   if (flag_pic)\n     {\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n+\n       if (!hppa_save_pic_table_rtx)\n-\thppa_save_pic_table_rtx = gen_reg_rtx (Pmode);\n-      emit_insn (gen_rtx (SET, VOIDmode,\n-\t\t\t  gen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM),\n+\t{\n+\t  hppa_save_pic_table_rtx = gen_reg_rtx (Pmode);\n+\t  push_topmost_sequence ();\n+\t  emit_insn_after (gen_rtx (SET, VOIDmode,\n+\t\t\t\t    hppa_save_pic_table_rtx,\n+\t\t\t\t    pic_offset_table_rtx),\n+\t\t\t   get_insns ());\n+\t  pop_topmost_sequence ();\n+\t}\n+\n+      emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n \t\t\t  hppa_save_pic_table_rtx));\n     }\n   DONE;\n@@ -3234,7 +3287,6 @@\n \t      (match_operand 2 \"\" \"i\")))\n    (clobber (reg:SI 2))\n    (use (const_int 1))]\n-  ;;- Don't use operand 1 for most machines.\n   \"\"\n   \"*\n {"}]}