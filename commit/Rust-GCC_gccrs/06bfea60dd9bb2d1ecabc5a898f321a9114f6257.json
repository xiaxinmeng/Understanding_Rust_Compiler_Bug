{"sha": "06bfea60dd9bb2d1ecabc5a898f321a9114f6257", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZiZmVhNjBkZDliYjJkMWVjYWJjNWE4OThmMzIxYTkxMTRmNjI1Nw==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-11T10:52:16Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-11T11:53:33Z"}, "message": "Refactor and extract CanonicalPath into a common header\n\nCanonicalPath class and the node types are a common type which when split\nfrom the hir-mapping class decouples the headers and cleans things up.", "tree": {"sha": "912eb298372f247fdc8cd9dd387659f91db0a59c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/912eb298372f247fdc8cd9dd387659f91db0a59c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06bfea60dd9bb2d1ecabc5a898f321a9114f6257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06bfea60dd9bb2d1ecabc5a898f321a9114f6257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06bfea60dd9bb2d1ecabc5a898f321a9114f6257", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06bfea60dd9bb2d1ecabc5a898f321a9114f6257/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1b59b12509ccbafc9169888b1417e0f459a54ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1b59b12509ccbafc9169888b1417e0f459a54ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1b59b12509ccbafc9169888b1417e0f459a54ba"}], "stats": {"total": 314, "additions": 187, "deletions": 127}, "files": [{"sha": "b4e394b8037abaeedfb657648991d1fa408c6f91", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 1, "deletions": 106, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bfea60dd9bb2d1ecabc5a898f321a9114f6257/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bfea60dd9bb2d1ecabc5a898f321a9114f6257/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=06bfea60dd9bb2d1ecabc5a898f321a9114f6257", "patch": "@@ -20,118 +20,13 @@\n #define RUST_NAME_RESOLVER_H\n \n #include \"rust-system.h\"\n+#include \"rust-canonical-path.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-hir-type-check.h\"\n \n namespace Rust {\n namespace Resolver {\n \n-// https://doc.rust-lang.org/reference/paths.html#canonical-paths\n-//\n-// struct X - path X\n-// impl X { fn test - path X::test }\n-//\n-// struct X<T> - path X\n-//\n-// impl X<T>   { fn test - path X::test}\n-// impl X<i32> { fn test - path X<i32>::test }\n-// impl X<f32> { fn test - path X<f32>::test }\n-//\n-// pub trait Trait { // ::a::Trait\n-//   fn f(&self); // ::a::Trait::f\n-// }\n-//\n-// impl Trait for Struct {\n-//    fn f(&self) {} // <::a::Struct as ::a::Trait>::f\n-// }\n-class CanonicalPath\n-{\n-public:\n-  CanonicalPath (const CanonicalPath &other) : segs (other.segs) {}\n-\n-  CanonicalPath &operator= (const CanonicalPath &other)\n-  {\n-    segs = other.segs;\n-    return *this;\n-  }\n-\n-  static CanonicalPath new_seg (NodeId id, const std::string &path)\n-  {\n-    rust_assert (!path.empty ());\n-    return CanonicalPath ({std::pair<NodeId, std::string> (id, path)});\n-  }\n-\n-  std::string get () const\n-  {\n-    std::string buf;\n-    for (size_t i = 0; i < segs.size (); i++)\n-      {\n-\tbool have_more = (i + 1) < segs.size ();\n-\tconst std::string &seg = segs.at (i).second;\n-\tbuf += seg + (have_more ? \"::\" : \"\");\n-      }\n-    return buf;\n-  }\n-\n-  static CanonicalPath get_big_self (NodeId id)\n-  {\n-    return CanonicalPath::new_seg (id, \"Self\");\n-  }\n-\n-  static CanonicalPath create_empty () { return CanonicalPath ({}); }\n-\n-  bool is_empty () const { return segs.size () == 0; }\n-\n-  CanonicalPath append (const CanonicalPath &other) const\n-  {\n-    rust_assert (!other.is_empty ());\n-    if (is_empty ())\n-      return CanonicalPath (other.segs);\n-\n-    std::vector<std::pair<NodeId, std::string>> copy (segs);\n-    for (auto &s : other.segs)\n-      copy.push_back (s);\n-\n-    return CanonicalPath (copy);\n-  }\n-\n-  // if we have the path A::B::C this will give a callback for each segment\n-  // example:\n-  //   A\n-  //   A::B\n-  //   A::B::C\n-  void iterate (std::function<bool (const CanonicalPath &)> cb) const\n-  {\n-    std::vector<std::pair<NodeId, std::string>> buf;\n-    for (auto &seg : segs)\n-      {\n-\tbuf.push_back (seg);\n-\tif (!cb (CanonicalPath (buf)))\n-\t  return;\n-      }\n-  }\n-\n-  NodeId get_id () const\n-  {\n-    rust_assert (!segs.empty ());\n-    return segs.back ().first;\n-  }\n-\n-  bool operator== (const CanonicalPath &b) const\n-  {\n-    return get ().compare (b.get ()) == 0;\n-  }\n-\n-  bool operator< (const CanonicalPath &b) const { return get () < b.get (); }\n-\n-private:\n-  explicit CanonicalPath (std::vector<std::pair<NodeId, std::string>> path)\n-    : segs (path)\n-  {}\n-\n-  std::vector<std::pair<NodeId, std::string>> segs;\n-};\n-\n class Rib\n {\n public:"}, {"sha": "a2d6773980cfb87f4236cf58a976192293f810ab", "filename": "gcc/rust/util/rust-canonical-path.h", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bfea60dd9bb2d1ecabc5a898f321a9114f6257/gcc%2Frust%2Futil%2Frust-canonical-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bfea60dd9bb2d1ecabc5a898f321a9114f6257/gcc%2Frust%2Futil%2Frust-canonical-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-canonical-path.h?ref=06bfea60dd9bb2d1ecabc5a898f321a9114f6257", "patch": "@@ -0,0 +1,137 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_CANONICAL_PATH\n+#define RUST_CANONICAL_PATH\n+\n+#include \"rust-system.h\"\n+#include \"rust-mapping-common.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// https://doc.rust-lang.org/reference/paths.html#canonical-paths\n+//\n+// struct X - path X\n+// impl X { fn test - path X::test }\n+//\n+// struct X<T> - path X\n+//\n+// impl X<T>   { fn test - path X::test}\n+// impl X<i32> { fn test - path X<i32>::test }\n+// impl X<f32> { fn test - path X<f32>::test }\n+//\n+// pub trait Trait { // ::a::Trait\n+//   fn f(&self); // ::a::Trait::f\n+// }\n+//\n+// impl Trait for Struct {\n+//    fn f(&self) {} // <::a::Struct as ::a::Trait>::f\n+// }\n+class CanonicalPath\n+{\n+public:\n+  CanonicalPath (const CanonicalPath &other) : segs (other.segs) {}\n+\n+  CanonicalPath &operator= (const CanonicalPath &other)\n+  {\n+    segs = other.segs;\n+    return *this;\n+  }\n+\n+  static CanonicalPath new_seg (NodeId id, const std::string &path)\n+  {\n+    rust_assert (!path.empty ());\n+    return CanonicalPath ({std::pair<NodeId, std::string> (id, path)});\n+  }\n+\n+  std::string get () const\n+  {\n+    std::string buf;\n+    for (size_t i = 0; i < segs.size (); i++)\n+      {\n+\tbool have_more = (i + 1) < segs.size ();\n+\tconst std::string &seg = segs.at (i).second;\n+\tbuf += seg + (have_more ? \"::\" : \"\");\n+      }\n+    return buf;\n+  }\n+\n+  static CanonicalPath get_big_self (NodeId id)\n+  {\n+    return CanonicalPath::new_seg (id, \"Self\");\n+  }\n+\n+  static CanonicalPath create_empty () { return CanonicalPath ({}); }\n+\n+  bool is_empty () const { return segs.size () == 0; }\n+\n+  CanonicalPath append (const CanonicalPath &other) const\n+  {\n+    rust_assert (!other.is_empty ());\n+    if (is_empty ())\n+      return CanonicalPath (other.segs);\n+\n+    std::vector<std::pair<NodeId, std::string>> copy (segs);\n+    for (auto &s : other.segs)\n+      copy.push_back (s);\n+\n+    return CanonicalPath (copy);\n+  }\n+\n+  // if we have the path A::B::C this will give a callback for each segment\n+  // example:\n+  //   A\n+  //   A::B\n+  //   A::B::C\n+  void iterate (std::function<bool (const CanonicalPath &)> cb) const\n+  {\n+    std::vector<std::pair<NodeId, std::string>> buf;\n+    for (auto &seg : segs)\n+      {\n+\tbuf.push_back (seg);\n+\tif (!cb (CanonicalPath (buf)))\n+\t  return;\n+      }\n+  }\n+\n+  NodeId get_id () const\n+  {\n+    rust_assert (!segs.empty ());\n+    return segs.back ().first;\n+  }\n+\n+  bool operator== (const CanonicalPath &b) const\n+  {\n+    return get ().compare (b.get ()) == 0;\n+  }\n+\n+  bool operator< (const CanonicalPath &b) const { return get () < b.get (); }\n+\n+private:\n+  explicit CanonicalPath (std::vector<std::pair<NodeId, std::string>> path)\n+    : segs (path)\n+  {}\n+\n+  std::vector<std::pair<NodeId, std::string>> segs;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_CANONICAL_PATH"}, {"sha": "6fbb4d7e08638fb9268b307729c2d1e0e7381edc", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bfea60dd9bb2d1ecabc5a898f321a9114f6257/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bfea60dd9bb2d1ecabc5a898f321a9114f6257/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=06bfea60dd9bb2d1ecabc5a898f321a9114f6257", "patch": "@@ -21,32 +21,12 @@\n \n #include \"rust-system.h\"\n #include \"rust-location.h\"\n+#include \"rust-mapping-common.h\"\n \n #include \"rust-ast-full-decls.h\"\n #include \"rust-hir-full-decls.h\"\n \n namespace Rust {\n-\n-// refers to a Crate\n-typedef uint32_t CrateNum;\n-// refers to any node in the AST in current Crate\n-typedef uint32_t NodeId;\n-// refers to any node in the HIR for the current crate\n-typedef uint32_t HirId;\n-// refers to any top-level decl in HIR\n-typedef uint32_t LocalDefId;\n-// refers to <Crate><DefId>\n-typedef uint64_t DefId;\n-\n-#define DEF_ID_CRATE_MASK 0xFFFFFFFF00000000\n-#define DEF_ID_LOCAL_DEF_MASK 0x00000000FFFFFFFF\n-\n-#define UNKNOWN_CREATENUM ((uint32_t) (0))\n-#define UNKNOWN_NODEID ((uint32_t) (0))\n-#define UNKNOWN_HIRID ((uint32_t) (0))\n-#define UNKNOWN_LOCAL_DEFID ((uint32_t) (0))\n-#define UNKNOWN_DEFID ((uint64_t) (0))\n-\n namespace Analysis {\n \n class NodeMapping"}, {"sha": "45af11b253528d000179cdf3f799f0302a50f896", "filename": "gcc/rust/util/rust-mapping-common.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bfea60dd9bb2d1ecabc5a898f321a9114f6257/gcc%2Frust%2Futil%2Frust-mapping-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bfea60dd9bb2d1ecabc5a898f321a9114f6257/gcc%2Frust%2Futil%2Frust-mapping-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-mapping-common.h?ref=06bfea60dd9bb2d1ecabc5a898f321a9114f6257", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_MAPPING_COMMON\n+#define RUST_MAPPING_COMMON\n+\n+#include \"rust-system.h\"\n+\n+namespace Rust {\n+\n+// refers to a Crate\n+typedef uint32_t CrateNum;\n+// refers to any node in the AST in current Crate\n+typedef uint32_t NodeId;\n+// refers to any node in the HIR for the current crate\n+typedef uint32_t HirId;\n+// refers to any top-level decl in HIR\n+typedef uint32_t LocalDefId;\n+// refers to <Crate><DefId>\n+typedef uint64_t DefId;\n+\n+#define DEF_ID_CRATE_MASK 0xFFFFFFFF00000000\n+#define DEF_ID_LOCAL_DEF_MASK 0x00000000FFFFFFFF\n+\n+#define UNKNOWN_CREATENUM ((uint32_t) (0))\n+#define UNKNOWN_NODEID ((uint32_t) (0))\n+#define UNKNOWN_HIRID ((uint32_t) (0))\n+#define UNKNOWN_LOCAL_DEFID ((uint32_t) (0))\n+#define UNKNOWN_DEFID ((uint64_t) (0))\n+\n+} // namespace Rust\n+\n+#endif // RUST_MAPPING_COMMON"}]}