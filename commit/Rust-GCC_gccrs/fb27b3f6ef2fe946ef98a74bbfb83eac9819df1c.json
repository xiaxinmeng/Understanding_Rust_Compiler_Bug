{"sha": "fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIyN2IzZjZlZjJmZTk0NmVmOThhNzRiYmZiODNlYWM5ODE5ZGYxYw==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2007-09-11T00:25:18Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2007-09-11T00:25:18Z"}, "message": "dfp-bit.c (dfp_unary_func): Delete.\n\n\t* config/dfp-bit.c (dfp_unary_func): Delete.\n\t(dfp_unary_op): Delete.\n\t(dfp_binary_op): Use decFloat functions instead of decNumber\n\tfunctions for binary operations.\n\t(d32_binary_op): Convert 32-bit operands to 64 bits for evaluation.\n\t(dnn_binary_op): Call dfp_binary_op with decFloat rather than\n\tDFP_C_TYPE.\n\t(dfp_compare_op): Use decFloat functions insteadof decNumber\n\tfunctions for comparisons.\n\t(d32_compare_op): Convert 32-bit operands to 64 bits for evaluation.\n\t(dnn_binary_op): Call dfp_compare_op with decFloat rather than\n\tDFP_C_TYPE.\n\t(DFP_ADD, DFP_SUB, DFP_MULTIPLE, DFP_DIVIDE): Use macros for\n\tcall to dxx_binary_op and decFloat function.\n\t(DFP_EQ, DFP_NE, DFP_LT, DFP_GT, DFP_LE, DFP_GE): Use macros for\n\tcalls to dxx_binary_op and decFloat function.\n\t* config/dfp-bit.h: Include decFloat header files.\n\t(decFloat, DFP_BINARY_OP, DFP_COMPARE_OP, DEC_FLOAT_ADD,\n\tDEC_FLOAT_SUBTRACT, DEC_FLOAT_MULTIPLY, DEC_FLOAT_DIVIDE,\n\tDEC_FLOAT_COMPARE, DEC_FLOAT_IS_ZERO, DEC_FLOAT_IS_NAN,\n\tDEC_FLOAT_IS_SIGNED: Define for each of 3 operand widths.\n\nFrom-SVN: r128358", "tree": {"sha": "cdd1d11749442787aa9127594fdf8d20fdef40b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdd1d11749442787aa9127594fdf8d20fdef40b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c/comments", "author": null, "committer": null, "parents": [{"sha": "4a14361781d73eec1e76ac6102536e9854c9d9e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a14361781d73eec1e76ac6102536e9854c9d9e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a14361781d73eec1e76ac6102536e9854c9d9e9"}], "stats": {"total": 224, "additions": 157, "deletions": 67}, "files": [{"sha": "275023a773bbe3b909828c4dd82fadb7b7fbc604", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c", "patch": "@@ -1,3 +1,27 @@\n+2007-09-10  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* config/dfp-bit.c (dfp_unary_func): Delete.\n+\t(dfp_unary_op): Delete.\n+\t(dfp_binary_op): Use decFloat functions instead of decNumber\n+\tfunctions for binary operations.\n+\t(d32_binary_op): Convert 32-bit operands to 64 bits for evaluation.\n+\t(dnn_binary_op): Call dfp_binary_op with decFloat rather than\n+\tDFP_C_TYPE.\n+\t(dfp_compare_op): Use decFloat functions insteadof decNumber\n+\tfunctions for comparisons.\n+\t(d32_compare_op): Convert 32-bit operands to 64 bits for evaluation.\n+\t(dnn_binary_op): Call dfp_compare_op with decFloat rather than\n+\tDFP_C_TYPE.\n+\t(DFP_ADD, DFP_SUB, DFP_MULTIPLE, DFP_DIVIDE): Use macros for\n+\tcall to dxx_binary_op and decFloat function.\n+\t(DFP_EQ, DFP_NE, DFP_LT, DFP_GT, DFP_LE, DFP_GE): Use macros for\n+\tcalls to dxx_binary_op and decFloat function.\n+\t* config/dfp-bit.h: Include decFloat header files.\n+\t(decFloat, DFP_BINARY_OP, DFP_COMPARE_OP, DEC_FLOAT_ADD,\n+\tDEC_FLOAT_SUBTRACT, DEC_FLOAT_MULTIPLY, DEC_FLOAT_DIVIDE,\n+\tDEC_FLOAT_COMPARE, DEC_FLOAT_IS_ZERO, DEC_FLOAT_IS_NAN,\n+\tDEC_FLOAT_IS_SIGNED: Define for each of 3 operand widths.\n+\n 2007-09-10  Harsha Jagasia <harsha.jagasia@amd.com>\n             Jan Sjodin <jan.sjodin@amd.com>\n \t"}, {"sha": "6a1bc30a21a2acb1af8de578d332cadb0a37ef00", "filename": "gcc/config/dfp-bit.c", "status": "modified", "additions": 90, "deletions": 67, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c/gcc%2Fconfig%2Fdfp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c/gcc%2Fconfig%2Fdfp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdfp-bit.c?ref=fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c", "patch": "@@ -63,33 +63,25 @@ void __host_to_ieee_128 (_Decimal128 in, decimal128 *out);\n void __ieee_to_host_128 (decimal128 in, _Decimal128 *out);\n #endif\n \n-/* A pointer to a unary decNumber operation.  */\n-typedef decNumber* (*dfp_unary_func)\n-     (decNumber *, decNumber *, decContext *);\n-\n-/* A pointer to a binary decNumber operation.  */\n-typedef decNumber* (*dfp_binary_func)\n-     (decNumber *, const decNumber *, const decNumber *, decContext *);\n+/* A pointer to a binary decFloat operation.  */\n+typedef decFloat* (*dfp_binary_func)\n+     (decFloat *, const decFloat *, const decFloat *, decContext *);\n \f\n-/* Unary operations.  */\n+/* Binary operations.  */\n \n-static inline DFP_C_TYPE\n-dfp_unary_op (dfp_unary_func op, DFP_C_TYPE arg)\n+/* Use a decFloat (decDouble or decQuad) function to perform a DFP\n+   binary operation.  */\n+static inline decFloat\n+dfp_binary_op (dfp_binary_func op, decFloat arg_a, decFloat arg_b)\n {\n-  DFP_C_TYPE result;\n+  decFloat result;\n   decContext context;\n-  decNumber arg1, res;\n-  IEEE_TYPE a, encoded_result;\n-\n-  HOST_TO_IEEE (arg, &a);\n \n   decContextDefault (&context, CONTEXT_INIT);\n   DFP_INIT_ROUNDMODE (context.round);\n \n-  TO_INTERNAL (&a, &arg1);\n-\n   /* Perform the operation.  */\n-  op (&res, &arg1, &context);\n+  op (&result, &arg_a, &arg_b, &context);\n \n   if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n     {\n@@ -104,85 +96,116 @@ dfp_unary_op (dfp_unary_func op, DFP_C_TYPE arg)\n         DFP_HANDLE_EXCEPTIONS (ieee_flags);\n     }\n \n-  TO_ENCODED (&encoded_result, &res, &context);\n-  IEEE_TO_HOST (encoded_result, &result);\n   return result;\n }\n \n-/* Binary operations.  */\n-\n-static inline DFP_C_TYPE\n-dfp_binary_op (dfp_binary_func op, DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+#if WIDTH == 32\n+/* The decNumber package doesn't provide arithmetic for decSingle (32 bits);\n+   convert to decDouble, use the operation for that, and convert back.  */\n+static inline _Decimal32\n+d32_binary_op (dfp_binary_func op, _Decimal32 arg_a, _Decimal32 arg_b)\n {\n-  DFP_C_TYPE result;\n+  union { _Decimal32 c; decSingle f; } a32, b32, res32;\n+  decDouble a, b, res;\n   decContext context;\n-  decNumber arg1, arg2, res;\n-  IEEE_TYPE a, b, encoded_result;\n \n-  HOST_TO_IEEE (arg_a, &a);\n-  HOST_TO_IEEE (arg_b, &b);\n+  /* Widen the operands and perform the operation.  */\n+  a32.c = arg_a;\n+  b32.c = arg_b;\n+  decSingleToWider (&a32.f, &a);\n+  decSingleToWider (&b32.f, &b);\n+  res = dfp_binary_op (op, a, b);\n \n+  /* Narrow the result, which might result in an underflow or overflow.  */\n   decContextDefault (&context, CONTEXT_INIT);\n   DFP_INIT_ROUNDMODE (context.round);\n-\n-  TO_INTERNAL (&a, &arg1);\n-  TO_INTERNAL (&b, &arg2);\n-\n-  /* Perform the operation.  */\n-  op (&res, &arg1, &arg2, &context);\n-\n+  decSingleFromWider (&res32.f, &res, &context);\n   if (DFP_EXCEPTIONS_ENABLED && context.status != 0)\n     {\n       /* decNumber exception flags we care about here.  */\n       int ieee_flags;\n-      int dec_flags = DEC_IEEE_854_Division_by_zero | DEC_IEEE_854_Inexact\n-\t\t      | DEC_IEEE_854_Invalid_operation | DEC_IEEE_854_Overflow\n+      int dec_flags = DEC_IEEE_854_Inexact | DEC_IEEE_854_Overflow\n \t\t      | DEC_IEEE_854_Underflow;\n       dec_flags &= context.status;\n       ieee_flags = DFP_IEEE_FLAGS (dec_flags);\n       if (ieee_flags != 0)\n         DFP_HANDLE_EXCEPTIONS (ieee_flags);\n     }\n \n-  TO_ENCODED (&encoded_result, &res, &context);\n-  IEEE_TO_HOST (encoded_result, &result);\n-  return result;\n+  return res32.c;\n+}\n+#else\n+/* decFloat operations are supported for decDouble (64 bits) and\n+   decQuad (128 bits).  The bit patterns for the types are the same.  */\n+static inline DFP_C_TYPE\n+dnn_binary_op (dfp_binary_func op, DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  union { DFP_C_TYPE c; decFloat f; } a, b, result;\n+\n+  a.c = arg_a;\n+  b.c = arg_b;\n+  result.f = dfp_binary_op (op, a.f, b.f);\n+  return result.c;\n }\n+#endif\n \n /* Comparison operations.  */\n \n-static inline int\n-dfp_compare_op (dfp_binary_func op, DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+/* Use a decFloat (decDouble or decQuad) function to perform a DFP\n+   comparison.  */\n+static inline CMPtype\n+dfp_compare_op (dfp_binary_func op, decFloat arg_a, decFloat arg_b)\n {\n-  IEEE_TYPE a, b;\n   decContext context;\n-  decNumber arg1, arg2, res;\n+  decFloat res;\n   int result;\n \n-  HOST_TO_IEEE (arg_a, &a);\n-  HOST_TO_IEEE (arg_b, &b);\n-\n   decContextDefault (&context, CONTEXT_INIT);\n   DFP_INIT_ROUNDMODE (context.round);\n \n-  TO_INTERNAL (&a, &arg1);\n-  TO_INTERNAL (&b, &arg2);\n-\n   /* Perform the comparison.  */\n-  op (&res, &arg1, &arg2, &context);\n+  op (&res, &arg_a, &arg_b, &context);\n \n-  if (decNumberIsNegative (&res))\n+  if (DEC_FLOAT_IS_SIGNED (&res))\n     result = -1;\n-  else if (decNumberIsZero (&res))\n+  else if (DEC_FLOAT_IS_ZERO (&res))\n     result = 0;\n-  else if (decNumberIsNaN (&res))\n+  else if (DEC_FLOAT_IS_NAN (&res))\n     result = -2;\n   else\n     result = 1;\n \n-  return result;\n+  return (CMPtype) result;\n+}\n+\n+#if WIDTH == 32\n+/* The decNumber package doesn't provide comparisons for decSingle (32 bits);\n+   convert to decDouble, use the operation for that, and convert back.  */\n+static inline CMPtype\n+d32_compare_op (dfp_binary_func op, _Decimal32 arg_a, _Decimal32 arg_b)\n+{\n+  union { _Decimal32 c; decSingle f; } a32, b32;\n+  decDouble a, b;\n+\n+  a32.c = arg_a;\n+  b32.c = arg_b;\n+  decSingleToWider (&a32.f, &a);\n+  decSingleToWider (&b32.f, &b);\n+  return dfp_compare_op (op, a, b);  \n }\n+#else\n+/* decFloat comparisons are supported for decDouble (64 bits) and\n+   decQuad (128 bits).  The bit patterns for the types are the same.  */\n+static inline CMPtype\n+dnn_compare_op (dfp_binary_func op, DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  union { DFP_C_TYPE c; decFloat f; } a, b;\n \n+  a.c = arg_a;\n+  b.c = arg_b;\n+  return dfp_compare_op (op, a.f, b.f);  \n+}\n+#endif\n \f\n #if defined(L_conv_sd)\n void\n@@ -230,38 +253,38 @@ __ieee_to_host_128 (decimal128 in, _Decimal128 *out)\n DFP_C_TYPE\n DFP_ADD (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n {\n-  return dfp_binary_op (decNumberAdd, arg_a, arg_b);\n+  return DFP_BINARY_OP (DEC_FLOAT_ADD, arg_a, arg_b);\n }\n \n DFP_C_TYPE\n DFP_SUB (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n {\n-  return dfp_binary_op (decNumberSubtract, arg_a, arg_b);\n+  return DFP_BINARY_OP (DEC_FLOAT_SUBTRACT, arg_a, arg_b);\n }\n #endif /* L_addsub */\n \n #if defined(L_mul_sd) || defined(L_mul_dd) || defined(L_mul_td)\n DFP_C_TYPE\n DFP_MULTIPLY (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n {\n-  return dfp_binary_op (decNumberMultiply, arg_a, arg_b);\n+  return DFP_BINARY_OP (DEC_FLOAT_MULTIPLY, arg_a, arg_b);\n }\n #endif /* L_mul */\n \n #if defined(L_div_sd) || defined(L_div_dd) || defined(L_div_td)\n DFP_C_TYPE\n DFP_DIVIDE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n {\n-  return dfp_binary_op (decNumberDivide, arg_a, arg_b);\n+  return DFP_BINARY_OP (DEC_FLOAT_DIVIDE, arg_a, arg_b);\n }\n #endif /* L_div */\n \n #if defined (L_eq_sd) || defined (L_eq_dd) || defined (L_eq_td)\n CMPtype\n DFP_EQ (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n {\n-  int stat;\n-  stat = dfp_compare_op (decNumberCompare, arg_a, arg_b);\n+  CMPtype stat;\n+  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n   /* For EQ return zero for true, nonzero for false.  */\n   return stat != 0;\n }\n@@ -272,7 +295,7 @@ CMPtype\n DFP_NE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n {\n   int stat;\n-  stat = dfp_compare_op (decNumberCompare, arg_a, arg_b);\n+  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n   /* For NE return zero for true, nonzero for false.  */\n   if (__builtin_expect (stat == -2, 0))  /* An operand is NaN.  */\n     return 1;\n@@ -285,7 +308,7 @@ CMPtype\n DFP_LT (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n {\n   int stat;\n-  stat = dfp_compare_op (decNumberCompare, arg_a, arg_b);\n+  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n   /* For LT return -1 (<0) for true, 1 for false.  */\n   return (stat == -1) ? -1 : 1;\n }\n@@ -296,7 +319,7 @@ CMPtype\n DFP_GT (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n {\n   int stat;\n-  stat = dfp_compare_op (decNumberCompare, arg_a, arg_b);\n+  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n   /* For GT return 1 (>0) for true, -1 for false.  */\n   return (stat == 1) ? 1 : -1;\n }\n@@ -307,7 +330,7 @@ CMPtype\n DFP_LE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n {\n   int stat;\n-  stat = dfp_compare_op (decNumberCompare, arg_a, arg_b);\n+  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n   /* For LE return 0 (<= 0) for true, 1 for false.  */\n   if (__builtin_expect (stat == -2, 0))  /* An operand is NaN.  */\n     return 1;\n@@ -320,7 +343,7 @@ CMPtype\n DFP_GE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n {\n   int stat;\n-  stat = dfp_compare_op (decNumberCompare, arg_a, arg_b);\n+  stat = DFP_COMPARE_OP (DEC_FLOAT_COMPARE, arg_a, arg_b);\n   /* For GE return 1 (>=0) for true, -1 for false.  */\n   if (__builtin_expect (stat == -2, 0))  /* An operand is NaN.  */\n     return -1;"}, {"sha": "7c4738760ed7d4add14cd3e26c4c1b4ae96904a9", "filename": "gcc/config/dfp-bit.h", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c/gcc%2Fconfig%2Fdfp-bit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c/gcc%2Fconfig%2Fdfp-bit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdfp-bit.h?ref=fb27b3f6ef2fe946ef98a74bbfb83eac9819df1c", "patch": "@@ -277,12 +277,15 @@ extern float strtof (const char *, char **);\n \n #if WIDTH == 128 || WIDTH_TO == 128\n #include \"decimal128.h\"\n+#include \"decQuad.h\"\n #endif\n #if WIDTH == 64 || WIDTH_TO == 64\n #include \"decimal64.h\"\n+#include \"decDouble.h\"\n #endif\n #if WIDTH == 32 || WIDTH_TO == 32\n #include \"decimal32.h\"\n+#include \"decSingle.h\"\n #endif\n #include \"decNumber.h\"\n \n@@ -332,6 +335,46 @@ extern float strtof (const char *, char **);\n #define DFP_UNORD\tDPD_BID_NAME(__dpd_unordtd2,__bid_unordtd2)\n #endif\n \n+/* Names of decNumber functions for DPD arithmetic.  */\n+\n+#if WIDTH == 32\n+#define decFloat\t\tdecDouble\n+#define DFP_BINARY_OP\t\td32_binary_op\n+#define DFP_COMPARE_OP\t\td32_compare_op\n+#define DEC_FLOAT_ADD\t\tdecDoubleAdd\n+#define DEC_FLOAT_SUBTRACT\tdecDoubleSubtract\n+#define DEC_FLOAT_MULTIPLY\tdecDoubleMultiply\n+#define DEC_FLOAT_DIVIDE\tdecDoubleDivide\n+#define DEC_FLOAT_COMPARE\tdecDoubleCompare\n+#define DEC_FLOAT_IS_ZERO\tdecDoubleIsZero\n+#define DEC_FLOAT_IS_NAN\tdecDoubleIsNaN\n+#define DEC_FLOAT_IS_SIGNED\tdecDoubleIsSigned\n+#elif WIDTH == 64\n+#define DFP_BINARY_OP\t\tdnn_binary_op\n+#define DFP_COMPARE_OP\t\tdnn_compare_op\n+#define decFloat\t\tdecDouble\n+#define DEC_FLOAT_ADD\t\tdecDoubleAdd\n+#define DEC_FLOAT_SUBTRACT\tdecDoubleSubtract\n+#define DEC_FLOAT_MULTIPLY\tdecDoubleMultiply\n+#define DEC_FLOAT_DIVIDE\tdecDoubleDivide\n+#define DEC_FLOAT_COMPARE\tdecDoubleCompare\n+#define DEC_FLOAT_IS_ZERO\tdecDoubleIsZero\n+#define DEC_FLOAT_IS_NAN\tdecDoubleIsNaN\n+#define DEC_FLOAT_IS_SIGNED\tdecDoubleIsSigned\n+#elif WIDTH == 128\n+#define DFP_BINARY_OP\t\tdnn_binary_op\n+#define DFP_COMPARE_OP\t\tdnn_compare_op\n+#define decFloat\t\tdecQuad\n+#define DEC_FLOAT_ADD\t\tdecQuadAdd\n+#define DEC_FLOAT_SUBTRACT\tdecQuadSubtract\n+#define DEC_FLOAT_MULTIPLY\tdecQuadMultiply\n+#define DEC_FLOAT_DIVIDE\tdecQuadDivide\n+#define DEC_FLOAT_COMPARE\tdecQuadCompare\n+#define DEC_FLOAT_IS_ZERO\tdecQuadIsZero\n+#define DEC_FLOAT_IS_NAN\tdecQuadIsNaN\n+#define DEC_FLOAT_IS_SIGNED\tdecQuadIsSigned\n+#endif\n+\n /* Names of functions to convert between different decimal float types.  */\n \n #if WIDTH == 32"}]}