{"sha": "7f4a8ee03d404c560dcb75ba684fd57ffbc77e85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y0YThlZTAzZDQwNGM1NjBkY2I3NWJhNjg0ZmQ1N2ZmYmM3N2U4NQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-10-30T12:01:03Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-10-30T12:01:03Z"}, "message": "Come up with an abstraction.\n\n2019-10-30  Martin Liska  <mliska@suse.cz>\n\n\t* fold-const.c (operand_equal_p): Move to ...\n\t(operand_compare::operand_equal_p): ... here.\n\t(operand_compare::verify_hash_value): New.\n\t(add_expr): Move to ...\n\t(operand_compare::hash_operand): ... here.\n\t* fold-const.h (operand_equal_p): Move to the class.\n\t(class operand_compare): New.\n\t* tree.c (add_expr): Remove.\n\nFrom-SVN: r277614", "tree": {"sha": "b47bc170e7685789924985d88c12fcf373024b96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b47bc170e7685789924985d88c12fcf373024b96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42ceec0607f3235904c68d3ede1aaddb70eb06aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42ceec0607f3235904c68d3ede1aaddb70eb06aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42ceec0607f3235904c68d3ede1aaddb70eb06aa"}], "stats": {"total": 678, "additions": 376, "deletions": 302}, "files": [{"sha": "487cc9606ea36cfc8da6eda6b3eac7bac11b0da9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f4a8ee03d404c560dcb75ba684fd57ffbc77e85", "patch": "@@ -1,3 +1,14 @@\n+2019-10-30  Martin Liska  <mliska@suse.cz>\n+\n+\t* fold-const.c (operand_equal_p): Move to ...\n+\t(operand_compare::operand_equal_p): ... here.\n+\t(operand_compare::verify_hash_value): New.\n+\t(add_expr): Move to ...\n+\t(operand_compare::hash_operand): ... here.\n+\t* fold-const.h (operand_equal_p): Move to the class.\n+\t(class operand_compare): New.\n+\t* tree.c (add_expr): Remove.\n+\n 2019-10-30  Martin Liska  <mliska@suse.cz>\n \n \t* fold-const.c (operand_equal_p): Support OBJ_TYPE_REF."}, {"sha": "fce503692fd8c5c5f06f470bab0b71ef9a468672", "filename": "gcc/fold-const.c", "status": "modified", "additions": 341, "deletions": 22, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7f4a8ee03d404c560dcb75ba684fd57ffbc77e85", "patch": "@@ -2942,29 +2942,12 @@ combine_comparisons (location_t loc,\n    even if var is volatile.  */\n \n bool\n-operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n+operand_compare::operand_equal_p (const_tree arg0, const_tree arg1,\n+\t\t\t\t  unsigned int flags)\n {\n-  /* When checking, verify at the outermost operand_equal_p call that\n-     if operand_equal_p returns non-zero then ARG0 and ARG1 has the same\n-     hash value.  */\n-  if (flag_checking && !(flags & OEP_NO_HASH_CHECK))\n-    {\n-      if (operand_equal_p (arg0, arg1, flags | OEP_NO_HASH_CHECK))\n-\t{\n-\t  if (arg0 != arg1)\n-\t    {\n-\t      inchash::hash hstate0 (0), hstate1 (0);\n-\t      inchash::add_expr (arg0, hstate0, flags | OEP_HASH_CHECK);\n-\t      inchash::add_expr (arg1, hstate1, flags | OEP_HASH_CHECK);\n-\t      hashval_t h0 = hstate0.end ();\n-\t      hashval_t h1 = hstate1.end ();\n-\t      gcc_assert (h0 == h1);\n-\t    }\n-\t  return true;\n-\t}\n-      else\n-\treturn false;\n-    }\n+  bool r;\n+  if (verify_hash_value (arg0, arg1, flags, &r))\n+    return r;\n \n   STRIP_ANY_LOCATION_WRAPPER (arg0);\n   STRIP_ANY_LOCATION_WRAPPER (arg1);\n@@ -3581,6 +3564,342 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \n #undef OP_SAME\n #undef OP_SAME_WITH_NULL\n+}\n+\n+/* Generate a hash value for an expression.  This can be used iteratively\n+   by passing a previous result as the HSTATE argument.  */\n+\n+void\n+operand_compare::hash_operand (const_tree t, inchash::hash &hstate,\n+\t\t\t       unsigned int flags)\n+{\n+  int i;\n+  enum tree_code code;\n+  enum tree_code_class tclass;\n+\n+  if (t == NULL_TREE || t == error_mark_node)\n+    {\n+      hstate.merge_hash (0);\n+      return;\n+    }\n+\n+  STRIP_ANY_LOCATION_WRAPPER (t);\n+\n+  if (!(flags & OEP_ADDRESS_OF))\n+    STRIP_NOPS (t);\n+\n+  code = TREE_CODE (t);\n+\n+  switch (code)\n+    {\n+    /* Alas, constants aren't shared, so we can't rely on pointer\n+       identity.  */\n+    case VOID_CST:\n+      hstate.merge_hash (0);\n+      return;\n+    case INTEGER_CST:\n+      gcc_checking_assert (!(flags & OEP_ADDRESS_OF));\n+      for (i = 0; i < TREE_INT_CST_EXT_NUNITS (t); i++)\n+\thstate.add_hwi (TREE_INT_CST_ELT (t, i));\n+      return;\n+    case REAL_CST:\n+      {\n+\tunsigned int val2;\n+\tif (!HONOR_SIGNED_ZEROS (t) && real_zerop (t))\n+\t  val2 = rvc_zero;\n+\telse\n+\t  val2 = real_hash (TREE_REAL_CST_PTR (t));\n+\thstate.merge_hash (val2);\n+\treturn;\n+      }\n+    case FIXED_CST:\n+      {\n+\tunsigned int val2 = fixed_hash (TREE_FIXED_CST_PTR (t));\n+\thstate.merge_hash (val2);\n+\treturn;\n+      }\n+    case STRING_CST:\n+      hstate.add ((const void *) TREE_STRING_POINTER (t),\n+\t\t  TREE_STRING_LENGTH (t));\n+      return;\n+    case COMPLEX_CST:\n+      hash_operand (TREE_REALPART (t), hstate, flags);\n+      hash_operand (TREE_IMAGPART (t), hstate, flags);\n+      return;\n+    case VECTOR_CST:\n+      {\n+\thstate.add_int (VECTOR_CST_NPATTERNS (t));\n+\thstate.add_int (VECTOR_CST_NELTS_PER_PATTERN (t));\n+\tunsigned int count = vector_cst_encoded_nelts (t);\n+\tfor (unsigned int i = 0; i < count; ++i)\n+\t  hash_operand (VECTOR_CST_ENCODED_ELT (t, i), hstate, flags);\n+\treturn;\n+      }\n+    case SSA_NAME:\n+      /* We can just compare by pointer.  */\n+      hstate.add_hwi (SSA_NAME_VERSION (t));\n+      return;\n+    case PLACEHOLDER_EXPR:\n+      /* The node itself doesn't matter.  */\n+      return;\n+    case BLOCK:\n+    case OMP_CLAUSE:\n+      /* Ignore.  */\n+      return;\n+    case TREE_LIST:\n+      /* A list of expressions, for a CALL_EXPR or as the elements of a\n+\t VECTOR_CST.  */\n+      for (; t; t = TREE_CHAIN (t))\n+\thash_operand (TREE_VALUE (t), hstate, flags);\n+      return;\n+    case CONSTRUCTOR:\n+      {\n+\tunsigned HOST_WIDE_INT idx;\n+\ttree field, value;\n+\tflags &= ~OEP_ADDRESS_OF;\n+\tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (t), idx, field, value)\n+\t  {\n+\t    hash_operand (field, hstate, flags);\n+\t    hash_operand (value, hstate, flags);\n+\t  }\n+\treturn;\n+      }\n+    case STATEMENT_LIST:\n+      {\n+\ttree_stmt_iterator i;\n+\tfor (i = tsi_start (CONST_CAST_TREE (t));\n+\t     !tsi_end_p (i); tsi_next (&i))\n+\t  hash_operand (tsi_stmt (i), hstate, flags);\n+\treturn;\n+      }\n+    case TREE_VEC:\n+      for (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n+\thash_operand (TREE_VEC_ELT (t, i), hstate, flags);\n+      return;\n+    case IDENTIFIER_NODE:\n+      hstate.add_object (IDENTIFIER_HASH_VALUE (t));\n+      return;\n+    case FIELD_DECL:\n+      inchash::add_expr (DECL_FIELD_OFFSET (t), hstate, flags);\n+      inchash::add_expr (DECL_FIELD_BIT_OFFSET (t), hstate, flags);\n+      return;\n+    case FUNCTION_DECL:\n+      /* When referring to a built-in FUNCTION_DECL, use the __builtin__ form.\n+\t Otherwise nodes that compare equal according to operand_equal_p might\n+\t get different hash codes.  However, don't do this for machine specific\n+\t or front end builtins, since the function code is overloaded in those\n+\t cases.  */\n+      if (DECL_BUILT_IN_CLASS (t) == BUILT_IN_NORMAL\n+\t  && builtin_decl_explicit_p (DECL_FUNCTION_CODE (t)))\n+\t{\n+\t  t = builtin_decl_explicit (DECL_FUNCTION_CODE (t));\n+\t  code = TREE_CODE (t);\n+\t}\n+      /* FALL THROUGH */\n+    default:\n+      if (POLY_INT_CST_P (t))\n+\t{\n+\t  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+\t    hstate.add_wide_int (wi::to_wide (POLY_INT_CST_COEFF (t, i)));\n+\t  return;\n+\t}\n+      tclass = TREE_CODE_CLASS (code);\n+\n+      if (tclass == tcc_declaration)\n+\t{\n+\t  /* DECL's have a unique ID */\n+\t  hstate.add_hwi (DECL_UID (t));\n+\t}\n+      else if (tclass == tcc_comparison && !commutative_tree_code (code))\n+\t{\n+\t  /* For comparisons that can be swapped, use the lower\n+\t     tree code.  */\n+\t  enum tree_code ccode = swap_tree_comparison (code);\n+\t  if (code < ccode)\n+\t    ccode = code;\n+\t  hstate.add_object (ccode);\n+\t  hash_operand (TREE_OPERAND (t, ccode != code), hstate, flags);\n+\t  hash_operand (TREE_OPERAND (t, ccode == code), hstate, flags);\n+\t}\n+      else if (CONVERT_EXPR_CODE_P (code))\n+\t{\n+\t  /* NOP_EXPR and CONVERT_EXPR are considered equal by\n+\t     operand_equal_p.  */\n+\t  enum tree_code ccode = NOP_EXPR;\n+\t  hstate.add_object (ccode);\n+\n+\t  /* Don't hash the type, that can lead to having nodes which\n+\t     compare equal according to operand_equal_p, but which\n+\t     have different hash codes.  Make sure to include signedness\n+\t     in the hash computation.  */\n+\t  hstate.add_int (TYPE_UNSIGNED (TREE_TYPE (t)));\n+\t  hash_operand (TREE_OPERAND (t, 0), hstate, flags);\n+\t}\n+      /* For OEP_ADDRESS_OF, hash MEM_EXPR[&decl, 0] the same as decl.  */\n+      else if (code == MEM_REF\n+\t       && (flags & OEP_ADDRESS_OF) != 0\n+\t       && TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR\n+\t       && DECL_P (TREE_OPERAND (TREE_OPERAND (t, 0), 0))\n+\t       && integer_zerop (TREE_OPERAND (t, 1)))\n+\thash_operand (TREE_OPERAND (TREE_OPERAND (t, 0), 0),\n+\t\t      hstate, flags);\n+      /* Don't ICE on FE specific trees, or their arguments etc.\n+\t during operand_equal_p hash verification.  */\n+      else if (!IS_EXPR_CODE_CLASS (tclass))\n+\tgcc_assert (flags & OEP_HASH_CHECK);\n+      else\n+\t{\n+\t  unsigned int sflags = flags;\n+\n+\t  hstate.add_object (code);\n+\n+\t  switch (code)\n+\t    {\n+\t    case ADDR_EXPR:\n+\t      gcc_checking_assert (!(flags & OEP_ADDRESS_OF));\n+\t      flags |= OEP_ADDRESS_OF;\n+\t      sflags = flags;\n+\t      break;\n+\n+\t    case INDIRECT_REF:\n+\t    case MEM_REF:\n+\t    case TARGET_MEM_REF:\n+\t      flags &= ~OEP_ADDRESS_OF;\n+\t      sflags = flags;\n+\t      break;\n+\n+\t    case ARRAY_REF:\n+\t    case ARRAY_RANGE_REF:\n+\t    case COMPONENT_REF:\n+\t    case BIT_FIELD_REF:\n+\t      sflags &= ~OEP_ADDRESS_OF;\n+\t      break;\n+\n+\t    case COND_EXPR:\n+\t      flags &= ~OEP_ADDRESS_OF;\n+\t      break;\n+\n+\t    case WIDEN_MULT_PLUS_EXPR:\n+\t    case WIDEN_MULT_MINUS_EXPR:\n+\t      {\n+\t\t/* The multiplication operands are commutative.  */\n+\t\tinchash::hash one, two;\n+\t\thash_operand (TREE_OPERAND (t, 0), one, flags);\n+\t\thash_operand (TREE_OPERAND (t, 1), two, flags);\n+\t\thstate.add_commutative (one, two);\n+\t\thash_operand (TREE_OPERAND (t, 2), two, flags);\n+\t\treturn;\n+\t      }\n+\n+\t    case CALL_EXPR:\n+\t      if (CALL_EXPR_FN (t) == NULL_TREE)\n+\t\thstate.add_int (CALL_EXPR_IFN (t));\n+\t      break;\n+\n+\t    case TARGET_EXPR:\n+\t      /* For TARGET_EXPR, just hash on the TARGET_EXPR_SLOT.\n+\t\t Usually different TARGET_EXPRs just should use\n+\t\t different temporaries in their slots.  */\n+\t      hash_operand (TARGET_EXPR_SLOT (t), hstate, flags);\n+\t      return;\n+\n+\t    /* Virtual table call.  */\n+\t    case OBJ_TYPE_REF:\n+\t      inchash::add_expr (OBJ_TYPE_REF_EXPR (t), hstate, flags);\n+\t      inchash::add_expr (OBJ_TYPE_REF_TOKEN (t), hstate, flags);\n+\t      inchash::add_expr (OBJ_TYPE_REF_OBJECT (t), hstate, flags);\n+\t      return;\n+\t    default:\n+\t      break;\n+\t    }\n+\n+\t  /* Don't hash the type, that can lead to having nodes which\n+\t     compare equal according to operand_equal_p, but which\n+\t     have different hash codes.  */\n+\t  if (code == NON_LVALUE_EXPR)\n+\t    {\n+\t      /* Make sure to include signness in the hash computation.  */\n+\t      hstate.add_int (TYPE_UNSIGNED (TREE_TYPE (t)));\n+\t      hash_operand (TREE_OPERAND (t, 0), hstate, flags);\n+\t    }\n+\n+\t  else if (commutative_tree_code (code))\n+\t    {\n+\t      /* It's a commutative expression.  We want to hash it the same\n+\t\t however it appears.  We do this by first hashing both operands\n+\t\t and then rehashing based on the order of their independent\n+\t\t hashes.  */\n+\t      inchash::hash one, two;\n+\t      hash_operand (TREE_OPERAND (t, 0), one, flags);\n+\t      hash_operand (TREE_OPERAND (t, 1), two, flags);\n+\t      hstate.add_commutative (one, two);\n+\t    }\n+\t  else\n+\t    for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n+\t      hash_operand (TREE_OPERAND (t, i), hstate,\n+\t\t\t    i == 0 ? flags : sflags);\n+\t}\n+      return;\n+    }\n+}\n+\n+bool\n+operand_compare::verify_hash_value (const_tree arg0, const_tree arg1,\n+\t\t\t\t    unsigned int flags, bool *ret)\n+{\n+  /* When checking, verify at the outermost operand_equal_p call that\n+     if operand_equal_p returns non-zero then ARG0 and ARG1 has the same\n+     hash value.  */\n+  if (flag_checking && !(flags & OEP_NO_HASH_CHECK))\n+    {\n+      if (operand_equal_p (arg0, arg1, flags | OEP_NO_HASH_CHECK))\n+\t{\n+\t  if (arg0 != arg1)\n+\t    {\n+\t      inchash::hash hstate0 (0), hstate1 (0);\n+\t      hash_operand (arg0, hstate0, flags | OEP_HASH_CHECK);\n+\t      hash_operand (arg1, hstate1, flags | OEP_HASH_CHECK);\n+\t      hashval_t h0 = hstate0.end ();\n+\t      hashval_t h1 = hstate1.end ();\n+\t      gcc_assert (h0 == h1);\n+\t    }\n+\t  *ret = true;\n+\t}\n+      else\n+\t*ret = false;\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+\n+static operand_compare default_compare_instance;\n+\n+/* Conveinece wrapper around operand_compare class because usually we do\n+   not need to play with the valueizer.  */\n+\n+bool\n+operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n+{\n+  return default_compare_instance.operand_equal_p (arg0, arg1, flags);\n+}\n+\n+namespace inchash\n+{\n+\n+/* Generate a hash value for an expression.  This can be used iteratively\n+   by passing a previous result as the HSTATE argument.\n+\n+   This function is intended to produce the same hash for expressions which\n+   would compare equal using operand_equal_p.  */\n+void\n+add_expr (const_tree t, inchash::hash &hstate, unsigned int flags)\n+{\n+  default_compare_instance.hash_operand (t, hstate, flags);\n+}\n+\n }\n \f\n /* Similar to operand_equal_p, but see if ARG0 might be a variant of ARG1"}, {"sha": "c9c5cbdae360d97e48e811a9c9878e47d582ce17", "filename": "gcc/fold-const.h", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=7f4a8ee03d404c560dcb75ba684fd57ffbc77e85", "patch": "@@ -84,7 +84,7 @@ extern bool fold_deferring_overflow_warnings_p (void);\n extern void fold_overflow_warning (const char*, enum warn_strict_overflow_code);\n extern enum tree_code fold_div_compare (enum tree_code, tree, tree,\n \t\t\t\t\ttree *, tree *, bool *);\n-extern bool operand_equal_p (const_tree, const_tree, unsigned int);\n+extern bool operand_equal_p (const_tree, const_tree, unsigned int flags = 0);\n extern int multiple_of_p (tree, const_tree, const_tree);\n #define omit_one_operand(T1,T2,T3)\\\n    omit_one_operand_loc (UNKNOWN_LOCATION, T1, T2, T3)\n@@ -212,4 +212,27 @@ extern tree fold_build_pointer_plus_hwi_loc (location_t loc, tree ptr, HOST_WIDE\n \n #define fold_build_pointer_plus_hwi(p,o) \\\n \tfold_build_pointer_plus_hwi_loc (UNKNOWN_LOCATION, p, o)\n+\n+\n+/* Class used to compare gimple operands.  */\n+\n+class operand_compare\n+{\n+public:\n+  /* Return true if two operands are equal.  The flags fields can be used\n+     to specify OEP flags described above.  */\n+  virtual bool operand_equal_p (const_tree, const_tree, unsigned int flags);\n+\n+  /* Generate a hash value for an expression.  This can be used iteratively\n+     by passing a previous result as the HSTATE argument.  */\n+  virtual void hash_operand (const_tree, inchash::hash &, unsigned flags);\n+\n+protected:\n+  /* Verify that when arguments (ARG0 and ARG1) are equal, then they have\n+     an equal hash value.  When the function knowns comparison return,\n+     true is returned.  Then RET is set to corresponding comparsion result.  */\n+  bool verify_hash_value (const_tree arg0, const_tree arg1, unsigned int flags,\n+\t\t\t  bool *ret);\n+};\n+\n #endif // GCC_FOLD_CONST_H"}, {"sha": "ad477d3feb24192cfb6c990fbc84bad74c3d5c19", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 279, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7f4a8ee03d404c560dcb75ba684fd57ffbc77e85", "patch": "@@ -7790,285 +7790,6 @@ operation_no_trapping_overflow (tree type, enum tree_code code)\n     }\n }\n \n-namespace inchash\n-{\n-\n-/* Generate a hash value for an expression.  This can be used iteratively\n-   by passing a previous result as the HSTATE argument.\n-\n-   This function is intended to produce the same hash for expressions which\n-   would compare equal using operand_equal_p.  */\n-void\n-add_expr (const_tree t, inchash::hash &hstate, unsigned int flags)\n-{\n-  int i;\n-  enum tree_code code;\n-  enum tree_code_class tclass;\n-\n-  if (t == NULL_TREE || t == error_mark_node)\n-    {\n-      hstate.merge_hash (0);\n-      return;\n-    }\n-\n-  STRIP_ANY_LOCATION_WRAPPER (t);\n-\n-  if (!(flags & OEP_ADDRESS_OF))\n-    STRIP_NOPS (t);\n-\n-  code = TREE_CODE (t);\n-\n-  switch (code)\n-    {\n-    /* Alas, constants aren't shared, so we can't rely on pointer\n-       identity.  */\n-    case VOID_CST:\n-      hstate.merge_hash (0);\n-      return;\n-    case INTEGER_CST:\n-      gcc_checking_assert (!(flags & OEP_ADDRESS_OF));\n-      for (i = 0; i < TREE_INT_CST_EXT_NUNITS (t); i++)\n-\thstate.add_hwi (TREE_INT_CST_ELT (t, i));\n-      return;\n-    case REAL_CST:\n-      {\n-\tunsigned int val2;\n-\tif (!HONOR_SIGNED_ZEROS (t) && real_zerop (t))\n-\t  val2 = rvc_zero;\n-\telse\n-\t  val2 = real_hash (TREE_REAL_CST_PTR (t));\n-\thstate.merge_hash (val2);\n-\treturn;\n-      }\n-    case FIXED_CST:\n-      {\n-\tunsigned int val2 = fixed_hash (TREE_FIXED_CST_PTR (t));\n-\thstate.merge_hash (val2);\n-\treturn;\n-      }\n-    case STRING_CST:\n-      hstate.add ((const void *) TREE_STRING_POINTER (t),\n-\t\t  TREE_STRING_LENGTH (t));\n-      return;\n-    case COMPLEX_CST:\n-      inchash::add_expr (TREE_REALPART (t), hstate, flags);\n-      inchash::add_expr (TREE_IMAGPART (t), hstate, flags);\n-      return;\n-    case VECTOR_CST:\n-      {\n-\thstate.add_int (VECTOR_CST_NPATTERNS (t));\n-\thstate.add_int (VECTOR_CST_NELTS_PER_PATTERN (t));\n-\tunsigned int count = vector_cst_encoded_nelts (t);\n-\tfor (unsigned int i = 0; i < count; ++i)\n-\t  inchash::add_expr (VECTOR_CST_ENCODED_ELT (t, i), hstate, flags);\n-\treturn;\n-      }\n-    case SSA_NAME:\n-      /* We can just compare by pointer.  */\n-      hstate.add_hwi (SSA_NAME_VERSION (t));\n-      return;\n-    case PLACEHOLDER_EXPR:\n-      /* The node itself doesn't matter.  */\n-      return;\n-    case BLOCK:\n-    case OMP_CLAUSE:\n-      /* Ignore.  */\n-      return;\n-    case TREE_LIST:\n-      /* A list of expressions, for a CALL_EXPR or as the elements of a\n-\t VECTOR_CST.  */\n-      for (; t; t = TREE_CHAIN (t))\n-\tinchash::add_expr (TREE_VALUE (t), hstate, flags);\n-      return;\n-    case CONSTRUCTOR:\n-      {\n-\tunsigned HOST_WIDE_INT idx;\n-\ttree field, value;\n-\tflags &= ~OEP_ADDRESS_OF;\n-\tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (t), idx, field, value)\n-\t  {\n-\t    inchash::add_expr (field, hstate, flags);\n-\t    inchash::add_expr (value, hstate, flags);\n-\t  }\n-\treturn;\n-      }\n-    case STATEMENT_LIST:\n-      {\n-\ttree_stmt_iterator i;\n-\tfor (i = tsi_start (CONST_CAST_TREE (t));\n-\t     !tsi_end_p (i); tsi_next (&i))\n-\t  inchash::add_expr (tsi_stmt (i), hstate, flags);\n-\treturn;\n-      }\n-    case TREE_VEC:\n-      for (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n-\tinchash::add_expr (TREE_VEC_ELT (t, i), hstate, flags);\n-      return;\n-    case IDENTIFIER_NODE:\n-      hstate.add_object (IDENTIFIER_HASH_VALUE (t));\n-      return;\n-    case FUNCTION_DECL:\n-      /* When referring to a built-in FUNCTION_DECL, use the __builtin__ form.\n-\t Otherwise nodes that compare equal according to operand_equal_p might\n-\t get different hash codes.  However, don't do this for machine specific\n-\t or front end builtins, since the function code is overloaded in those\n-\t cases.  */\n-      if (DECL_BUILT_IN_CLASS (t) == BUILT_IN_NORMAL\n-\t  && builtin_decl_explicit_p (DECL_FUNCTION_CODE (t)))\n-\t{\n-\t  t = builtin_decl_explicit (DECL_FUNCTION_CODE (t));\n-\t  code = TREE_CODE (t);\n-\t}\n-      /* FALL THROUGH */\n-    default:\n-      if (POLY_INT_CST_P (t))\n-\t{\n-\t  for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n-\t    hstate.add_wide_int (wi::to_wide (POLY_INT_CST_COEFF (t, i)));\n-\t  return;\n-\t}\n-      tclass = TREE_CODE_CLASS (code);\n-\n-      if (tclass == tcc_declaration)\n-\t{\n-\t  /* DECL's have a unique ID */\n-\t  hstate.add_hwi (DECL_UID (t));\n-\t}\n-      else if (tclass == tcc_comparison && !commutative_tree_code (code))\n-\t{\n-\t  /* For comparisons that can be swapped, use the lower\n-\t     tree code.  */\n-\t  enum tree_code ccode = swap_tree_comparison (code);\n-\t  if (code < ccode)\n-\t    ccode = code;\n-\t  hstate.add_object (ccode);\n-\t  inchash::add_expr (TREE_OPERAND (t, ccode != code), hstate, flags);\n-\t  inchash::add_expr (TREE_OPERAND (t, ccode == code), hstate, flags);\n-\t}\n-      else if (CONVERT_EXPR_CODE_P (code))\n-\t{\n-\t  /* NOP_EXPR and CONVERT_EXPR are considered equal by\n-\t     operand_equal_p.  */\n-\t  enum tree_code ccode = NOP_EXPR;\n-\t  hstate.add_object (ccode);\n-\n-\t  /* Don't hash the type, that can lead to having nodes which\n-\t     compare equal according to operand_equal_p, but which\n-\t     have different hash codes.  Make sure to include signedness\n-\t     in the hash computation.  */\n-\t  hstate.add_int (TYPE_UNSIGNED (TREE_TYPE (t)));\n-\t  inchash::add_expr (TREE_OPERAND (t, 0), hstate, flags);\n-\t}\n-      /* For OEP_ADDRESS_OF, hash MEM_EXPR[&decl, 0] the same as decl.  */\n-      else if (code == MEM_REF\n-\t       && (flags & OEP_ADDRESS_OF) != 0\n-\t       && TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR\n-\t       && DECL_P (TREE_OPERAND (TREE_OPERAND (t, 0), 0))\n-\t       && integer_zerop (TREE_OPERAND (t, 1)))\n-\tinchash::add_expr (TREE_OPERAND (TREE_OPERAND (t, 0), 0),\n-\t\t\t   hstate, flags);\n-      /* Don't ICE on FE specific trees, or their arguments etc.\n-\t during operand_equal_p hash verification.  */\n-      else if (!IS_EXPR_CODE_CLASS (tclass))\n-\tgcc_assert (flags & OEP_HASH_CHECK);\n-      else\n-\t{\n-\t  unsigned int sflags = flags;\n-\n-\t  hstate.add_object (code);\n-\n-\t  switch (code)\n-\t    {\n-\t    case ADDR_EXPR:\n-\t      gcc_checking_assert (!(flags & OEP_ADDRESS_OF));\n-\t      flags |= OEP_ADDRESS_OF;\n-\t      sflags = flags;\n-\t      break;\n-\n-\t    case INDIRECT_REF:\n-\t    case MEM_REF:\n-\t    case TARGET_MEM_REF:\n-\t      flags &= ~OEP_ADDRESS_OF;\n-\t      sflags = flags;\n-\t      break;\n-\n-\t    case ARRAY_REF:\n-\t    case ARRAY_RANGE_REF:\n-\t    case COMPONENT_REF:\n-\t    case BIT_FIELD_REF:\n-\t      sflags &= ~OEP_ADDRESS_OF;\n-\t      break;\n-\n-\t    case COND_EXPR:\n-\t      flags &= ~OEP_ADDRESS_OF;\n-\t      break;\n-\n-\t    case WIDEN_MULT_PLUS_EXPR:\n-\t    case WIDEN_MULT_MINUS_EXPR:\n-\t      {\n-\t\t/* The multiplication operands are commutative.  */\n-\t\tinchash::hash one, two;\n-\t\tinchash::add_expr (TREE_OPERAND (t, 0), one, flags);\n-\t\tinchash::add_expr (TREE_OPERAND (t, 1), two, flags);\n-\t\thstate.add_commutative (one, two);\n-\t\tinchash::add_expr (TREE_OPERAND (t, 2), two, flags);\n-\t\treturn;\n-\t      }\n-\n-\t    case CALL_EXPR:\n-\t      if (CALL_EXPR_FN (t) == NULL_TREE)\n-\t\thstate.add_int (CALL_EXPR_IFN (t));\n-\t      break;\n-\n-\t    case TARGET_EXPR:\n-\t      /* For TARGET_EXPR, just hash on the TARGET_EXPR_SLOT.\n-\t\t Usually different TARGET_EXPRs just should use\n-\t\t different temporaries in their slots.  */\n-\t      inchash::add_expr (TARGET_EXPR_SLOT (t), hstate, flags);\n-\t      return;\n-\n-\t    /* Virtual table call.  */\n-\t    case OBJ_TYPE_REF:\n-\t      inchash::add_expr (OBJ_TYPE_REF_EXPR (t), hstate, flags);\n-\t      inchash::add_expr (OBJ_TYPE_REF_TOKEN (t), hstate, flags);\n-\t      inchash::add_expr (OBJ_TYPE_REF_OBJECT (t), hstate, flags);\n-\t      return;\n-\t    default:\n-\t      break;\n-\t    }\n-\n-\t  /* Don't hash the type, that can lead to having nodes which\n-\t     compare equal according to operand_equal_p, but which\n-\t     have different hash codes.  */\n-\t  if (code == NON_LVALUE_EXPR)\n-\t    {\n-\t      /* Make sure to include signness in the hash computation.  */\n-\t      hstate.add_int (TYPE_UNSIGNED (TREE_TYPE (t)));\n-\t      inchash::add_expr (TREE_OPERAND (t, 0), hstate, flags);\n-\t    }\n-\n-\t  else if (commutative_tree_code (code))\n-\t    {\n-\t      /* It's a commutative expression.  We want to hash it the same\n-\t\t however it appears.  We do this by first hashing both operands\n-\t\t and then rehashing based on the order of their independent\n-\t\t hashes.  */\n-\t      inchash::hash one, two;\n-\t      inchash::add_expr (TREE_OPERAND (t, 0), one, flags);\n-\t      inchash::add_expr (TREE_OPERAND (t, 1), two, flags);\n-\t      hstate.add_commutative (one, two);\n-\t    }\n-\t  else\n-\t    for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n-\t      inchash::add_expr (TREE_OPERAND (t, i), hstate,\n-\t\t\t\t i == 0 ? flags : sflags);\n-\t}\n-      return;\n-    }\n-}\n-\n-}\n-\n /* Constructors for pointer, array and function types.\n    (RECORD_TYPE, UNION_TYPE and ENUMERAL_TYPE nodes are\n    constructed by language-dependent code, not here.)  */"}]}