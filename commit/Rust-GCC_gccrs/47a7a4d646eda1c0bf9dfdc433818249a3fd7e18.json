{"sha": "47a7a4d646eda1c0bf9dfdc433818249a3fd7e18", "node_id": "C_kwDOANBUbNoAKDQ3YTdhNGQ2NDZlZGExYzBiZjlkZmRjNDMzODE4MjQ5YTNmZDdlMTg", "commit": {"author": {"name": "Mahmoud Mohamed", "email": "mahadelr19@gmail.com", "date": "2023-03-15T23:54:11Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-03-17T16:37:37Z"}, "message": "resolve: Add name resolution for AltPattern\n\nThe main changes in this commit can be logically split into two parts:\n\n1) Pushing new pattern binding contexts in alt patterns. At the start\nof each AltPattern we push an 'Or' context which represents the relation\nbetween the bindings of different alts.\n\nBefore we resolve each alt arm we need to push a 'Product' context to represent\nthe relation between the bindings of this specific alt arm and each other.\nThis 'Product' context is removed after the alt arm visit and the its bindings\nare pushed into the 'Or' context.\n\nEventually, the 'Or' context is removed as well after it fulfills its duty.\nIts bindings are then pushed into the previous context similarly and so on.\n\n2) Checking for consistent bindings between the alt arms which is handled\nby check_bindings_consistency. The info necessary for this check is held\nby binding_info_map inside PatternDeclaration class. The binding_info_map\nonly holds bindings for one alt arm at a time. After every alt arm visit,\nthese bindings info are pushed into a vec (that contains all alt arms info\nand will eventually be passed to check_bindings_consistency) and emptied out\nfor the next alt arm visit. At the end, all the info from all the alt arms\nare pushed again into binding_info in addition to the initial bindings that\nwere there before the alt arms visits, this way the binding_info will contain\nall the binding_info present in the AltPattern (as it should).\n\nIn addition to that, some refactors were made (e.g. add_new_binding function)\nand some errors emitted, no biggie.\n\ngcc/rust/ChangeLog:\n\n\t* resolve/rust-ast-resolve-pattern.cc (PatternDeclaration::go):\n\tPrint out consistency errors.\n\t(PatternDeclaration::visit): Implement visit for AltPattern.\n\t(PatternDeclaration::add_new_binding): New helper function for\n\tadding a binding to identifier.\n\t* resolve/rust-ast-resolve-pattern.h (struct BindingInfo):\n\tNew struct to facilitate checking for inconsistencies between bindings.\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/torture/alt_patterns1.rs: New test.\n\nSigned-off-by: Mahmoud Mohamed <mahadelr19@gmail.com>", "tree": {"sha": "023e9e0c754160617dfb9e61273ec6e5dbf20dc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/023e9e0c754160617dfb9e61273ec6e5dbf20dc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47a7a4d646eda1c0bf9dfdc433818249a3fd7e18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a7a4d646eda1c0bf9dfdc433818249a3fd7e18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a7a4d646eda1c0bf9dfdc433818249a3fd7e18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a7a4d646eda1c0bf9dfdc433818249a3fd7e18/comments", "author": {"login": "goar5670", "id": 40712841, "node_id": "MDQ6VXNlcjQwNzEyODQx", "avatar_url": "https://avatars.githubusercontent.com/u/40712841?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goar5670", "html_url": "https://github.com/goar5670", "followers_url": "https://api.github.com/users/goar5670/followers", "following_url": "https://api.github.com/users/goar5670/following{/other_user}", "gists_url": "https://api.github.com/users/goar5670/gists{/gist_id}", "starred_url": "https://api.github.com/users/goar5670/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goar5670/subscriptions", "organizations_url": "https://api.github.com/users/goar5670/orgs", "repos_url": "https://api.github.com/users/goar5670/repos", "events_url": "https://api.github.com/users/goar5670/events{/privacy}", "received_events_url": "https://api.github.com/users/goar5670/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "428bd076370600c0054dae8f386ed7c230cb7add", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/428bd076370600c0054dae8f386ed7c230cb7add", "html_url": "https://github.com/Rust-GCC/gccrs/commit/428bd076370600c0054dae8f386ed7c230cb7add"}], "stats": {"total": 318, "additions": 272, "deletions": 46}, "files": [{"sha": "7eab1f0fc44bf27a13848412554a95299e58f161", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.cc", "status": "modified", "additions": 187, "deletions": 43, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a7a4d646eda1c0bf9dfdc433818249a3fd7e18/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a7a4d646eda1c0bf9dfdc433818249a3fd7e18/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc?ref=47a7a4d646eda1c0bf9dfdc433818249a3fd7e18", "patch": "@@ -28,59 +28,45 @@ PatternDeclaration::go (AST::Pattern *pattern, Rib::ItemType type)\n {\n   std::vector<PatternBinding> bindings\n     = {PatternBinding (PatternBoundCtx::Product, std::set<Identifier> ())};\n-  PatternDeclaration resolver (bindings, type);\n-  pattern->accept_vis (resolver);\n-};\n+  PatternDeclaration::go (pattern, type, bindings);\n+}\n \n void\n PatternDeclaration::go (AST::Pattern *pattern, Rib::ItemType type,\n \t\t\tstd::vector<PatternBinding> &bindings)\n {\n   PatternDeclaration resolver (bindings, type);\n   pattern->accept_vis (resolver);\n-}\n-\n-void\n-PatternDeclaration::visit (AST::IdentifierPattern &pattern)\n-{\n-  bool has_binding_ctx = bindings.size () > 0;\n-  rust_assert (has_binding_ctx);\n \n-  auto &binding_idents = bindings.back ().idents;\n+  for (auto &map_entry : resolver.missing_bindings)\n+    {\n+      auto ident = map_entry.first; // key\n+      auto info = map_entry.second; // value\n \n-  bool current_ctx_is_product\n-    = bindings.back ().ctx == PatternBoundCtx::Product;\n-  bool identifier_is_product_bound\n-    = current_ctx_is_product\n-      && binding_idents.find (pattern.get_ident ()) != binding_idents.end ();\n+      rust_error_at (info.get_locus (), ErrorCode (\"E0408\"),\n+\t\t     \"variable '%s' is not bound in all patterns\",\n+\t\t     ident.c_str ());\n+    }\n \n-  if (identifier_is_product_bound)\n+  for (auto &map_entry : resolver.inconsistent_bindings)\n     {\n-      if (type == Rib::ItemType::Param)\n-\t{\n-\t  rust_error_at (pattern.get_locus (), ErrorCode (\"E0415\"),\n-\t\t\t \"identifier '%s' is bound more than once in the \"\n-\t\t\t \"same parameter list\",\n-\t\t\t pattern.get_ident ().c_str ());\n-\t}\n-      else\n-\t{\n-\t  rust_error_at (\n-\t    pattern.get_locus (), ErrorCode (\"E0416\"),\n-\t    \"identifier '%s' is bound more than once in the same pattern\",\n-\t    pattern.get_ident ().c_str ());\n-\t}\n+      auto ident = map_entry.first; // key\n+      auto info = map_entry.second; // value\n \n-      return;\n+      rust_error_at (\n+\tinfo.get_locus (), ErrorCode (\"E0409\"),\n+\t\"variable '%s' is bound inconsistently across pattern alternatives\",\n+\tident.c_str ());\n     }\n+}\n \n-  // if we have a duplicate id this then allows for shadowing correctly\n-  // as new refs to this decl will match back here so it is ok to overwrite\n-  resolver->get_name_scope ().insert (\n-    CanonicalPath::new_seg (pattern.get_node_id (), pattern.get_ident ()),\n-    pattern.get_node_id (), pattern.get_locus (), type);\n-\n-  binding_idents.insert (pattern.get_ident ());\n+void\n+PatternDeclaration::visit (AST::IdentifierPattern &pattern)\n+{\n+  Mutability mut = pattern.get_is_mut () ? Mutability::Mut : Mutability::Imm;\n+  add_new_binding (pattern.get_ident (), pattern.get_node_id (),\n+\t\t   BindingTypeInfo (mut, pattern.get_is_ref (),\n+\t\t\t\t    pattern.get_locus ()));\n }\n \n void\n@@ -154,10 +140,12 @@ PatternDeclaration::visit (AST::StructPattern &pattern)\n \t    AST::StructPatternFieldIdent &ident\n \t      = static_cast<AST::StructPatternFieldIdent &> (*field.get ());\n \n-\t    resolver->get_name_scope ().insert (\n-\t      CanonicalPath::new_seg (ident.get_node_id (),\n-\t\t\t\t      ident.get_identifier ()),\n-\t      ident.get_node_id (), ident.get_locus ());\n+\t    Mutability mut\n+\t      = ident.is_mut () ? Mutability::Mut : Mutability::Imm;\n+\n+\t    add_new_binding (ident.get_identifier (), ident.get_node_id (),\n+\t\t\t     BindingTypeInfo (mut, ident.is_ref (),\n+\t\t\t\t\t      ident.get_locus ()));\n \t  }\n \t  break;\n \t}\n@@ -197,6 +185,162 @@ PatternDeclaration::visit (AST::TuplePattern &pattern)\n     }\n }\n \n+void\n+PatternDeclaration::visit (AST::AltPattern &pattern)\n+{\n+  // push a new set of 'Or' bindings to the stack. Accounts for the\n+  // alternatives. e.g. in `p_0 | p_1`, bindings to the same identifier between\n+  // p_0 and p_1 shouldn't cause an error.\n+  bindings_with_ctx.push_back (\n+    PatternBinding (PatternBoundCtx::Or, std::set<Identifier> ()));\n+\n+  // This is a hack to avoid creating a separate visitor class for the\n+  // consistency checks. We empty out the binding_info_map before each iteration\n+  // to separate between the alts' binding_maps. And right after the alt\n+  // visit...\n+  auto tmp_binding_map = binding_info_map;\n+  binding_info_map.clear ();\n+\n+  std::vector<BindingMap> alts_binding_maps;\n+\n+  for (auto &alt : pattern.get_alts ())\n+    {\n+      // before this visit, the binding_info_map is guaranteed to be empty\n+      rust_assert (binding_info_map.empty ());\n+\n+      // push a new `Product` context to correctly reject multiple bindings\n+      // within this single alt.\n+      bindings_with_ctx.push_back (\n+\tPatternBinding (PatternBoundCtx::Product, std::set<Identifier> ()));\n+\n+      alt->accept_vis (*this);\n+\n+      // ...the binding_info_map is (potentially) populated. We copy it to the\n+      // vector, and empty it out to be ready for the next iteration. And after\n+      // all the iterations are finished...\n+      alts_binding_maps.push_back (binding_info_map);\n+      binding_info_map.clear ();\n+\n+      // Remove the last (i.e. `Product`) context and add the bindings from the\n+      // visited alt to the one before last (i.e. `Or`). Now (after checking\n+      // with the alt internally), the bindings from this alt will reside in the\n+      // `Or` context.\n+      auto last_bound_idents = bindings_with_ctx.back ().idents;\n+      bindings_with_ctx.pop_back ();\n+\n+      for (auto &ident : last_bound_idents)\n+\t{\n+\t  bindings_with_ctx.back ().idents.insert (ident);\n+\t}\n+    }\n+\n+  // Now we can finally check for consistency.\n+  check_bindings_consistency (alts_binding_maps);\n+\n+  // Now we remove the `Or` context we pushed earlier.\n+  // e.g. in `(a, (p_0 | p_1), c)`: after finishing up inside the alt pattern,\n+  // we return to the tuple (`Product`) context and push the new bindings.\n+  auto idents = bindings_with_ctx.back ().idents;\n+  bindings_with_ctx.pop_back ();\n+  for (auto &ident : idents)\n+    bindings_with_ctx.back ().idents.insert (ident);\n+\n+  // ...we repopulate the binding_info_map correctly (the initial bindings\n+  // stored in the tmp_binding_map + all the bindings from all the alts)\n+  binding_info_map = tmp_binding_map;\n+  for (auto &alt_map : alts_binding_maps)\n+    for (auto &map_entry : alt_map)\n+      binding_info_map.insert (map_entry);\n+}\n+\n+void\n+PatternDeclaration::add_new_binding (Identifier ident, NodeId node_id,\n+\t\t\t\t     BindingTypeInfo info)\n+{\n+  bool has_binding_ctx = bindings_with_ctx.size () > 0;\n+  rust_assert (has_binding_ctx);\n+\n+  bool identifier_or_bound = false, identifier_product_bound = false;\n+\n+  for (auto binding : bindings_with_ctx)\n+    {\n+      bool identifier_bound_here\n+\t= (binding.idents.find (ident) != binding.idents.end ());\n+      if (identifier_bound_here)\n+\t{\n+\t  identifier_product_bound |= binding.ctx == PatternBoundCtx::Product;\n+\t  identifier_or_bound |= binding.ctx == PatternBoundCtx::Or;\n+\t}\n+    }\n+\n+  if (identifier_product_bound)\n+    {\n+      if (type == Rib::ItemType::Param)\n+\t{\n+\t  rust_error_at (info.get_locus (), ErrorCode (\"E0415\"),\n+\t\t\t \"identifier '%s' is bound more than once in the \"\n+\t\t\t \"same parameter list\",\n+\t\t\t ident.c_str ());\n+\t}\n+      else\n+\t{\n+\t  rust_error_at (\n+\t    info.get_locus (), ErrorCode (\"E0416\"),\n+\t    \"identifier '%s' is bound more than once in the same pattern\",\n+\t    ident.c_str ());\n+\t}\n+\n+      return;\n+    }\n+\n+  if (!identifier_or_bound)\n+    {\n+      bindings_with_ctx.back ().idents.insert (ident);\n+      resolver->get_name_scope ().insert (CanonicalPath::new_seg (node_id,\n+\t\t\t\t\t\t\t\t  ident),\n+\t\t\t\t\t  node_id, info.get_locus (), type);\n+    }\n+\n+  binding_info_map.insert ({ident, info});\n+}\n+\n+// Verifies that all the alts in an AltPattern have the same set of bindings\n+// with the same mutability and reference states.\n+void\n+PatternDeclaration::check_bindings_consistency (\n+  std::vector<BindingMap> &binding_maps)\n+{\n+  for (size_t i = 0; i < binding_maps.size (); i++)\n+    {\n+      auto &outer_bindings_map = binding_maps[i];\n+\n+      for (size_t j = 0; j < binding_maps.size (); j++)\n+\t{\n+\t  // skip comparing the current outer map with itself.\n+\t  if (j == i)\n+\t    continue;\n+\n+\t  auto &inner_bindings_map = binding_maps[j];\n+\n+\t  // iterate over the inner map entries and check if they exist in outer\n+\t  // map\n+\t  for (auto map_entry : inner_bindings_map)\n+\t    {\n+\t      auto ident = map_entry.first;\t  // key\n+\t      auto inner_info = map_entry.second; // value\n+\t      bool ident_is_outer_bound = outer_bindings_map.count (ident);\n+\n+\t      if (!ident_is_outer_bound && !missing_bindings.count (ident))\n+\t\tmissing_bindings.insert ({ident, inner_info});\n+\n+\t      else if (outer_bindings_map[ident] != inner_info\n+\t\t       && !inconsistent_bindings.count (ident))\n+\t\tinconsistent_bindings.insert ({ident, inner_info});\n+\t    }\n+\t}\n+    }\n+}\n+\n static void\n resolve_range_pattern_bound (AST::RangePatternBound *bound)\n {"}, {"sha": "5723c35e88615758facbcf2856433e7cc7f0d281", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 70, "deletions": 3, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a7a4d646eda1c0bf9dfdc433818249a3fd7e18/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a7a4d646eda1c0bf9dfdc433818249a3fd7e18/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=47a7a4d646eda1c0bf9dfdc433818249a3fd7e18", "patch": "@@ -45,6 +45,51 @@ struct PatternBinding\n   {}\n };\n \n+// Info that gets stored in the map. Helps us detect if two bindings to the same\n+// identifier have different mutability or ref states.\n+class BindingTypeInfo\n+{\n+  Mutability mut;\n+  bool is_ref;\n+  Location locus;\n+\n+public:\n+  BindingTypeInfo (Mutability mut, bool is_ref, Location locus)\n+    : mut (mut), is_ref (is_ref), locus (locus)\n+  {}\n+\n+  BindingTypeInfo (BindingTypeInfo const &other)\n+    : mut (other.mut), is_ref (other.is_ref), locus (other.get_locus ())\n+  {}\n+\n+  BindingTypeInfo (){};\n+\n+  Location get_locus () const { return locus; }\n+  Mutability get_mut () const { return mut; }\n+  bool get_is_ref () const { return is_ref; }\n+\n+  BindingTypeInfo operator= (BindingTypeInfo const &other)\n+  {\n+    mut = other.mut;\n+    is_ref = other.is_ref;\n+    locus = other.get_locus ();\n+\n+    return *this;\n+  }\n+\n+  bool operator== (BindingTypeInfo const &other)\n+  {\n+    return mut == other.mut && is_ref == other.is_ref;\n+  }\n+\n+  bool operator!= (BindingTypeInfo const &other)\n+  {\n+    return !BindingTypeInfo::operator== (other);\n+  }\n+};\n+\n+typedef std::map<Identifier, BindingTypeInfo> BindingMap;\n+\n class ResolvePattern : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;\n@@ -87,13 +132,35 @@ class PatternDeclaration : public ResolverBase\n   void visit (AST::TupleStructPattern &pattern) override;\n   void visit (AST::TuplePattern &pattern) override;\n   void visit (AST::RangePattern &pattern) override;\n+  void visit (AST::AltPattern &pattern) override;\n+\n+  void add_new_binding (Identifier ident, NodeId node_id, BindingTypeInfo info);\n+  void check_bindings_consistency (std::vector<BindingMap> &binding_maps);\n \n private:\n-  PatternDeclaration (std::vector<PatternBinding> &bindings, Rib::ItemType type)\n-    : ResolverBase (), bindings (bindings), type (type)\n+  PatternDeclaration (std::vector<PatternBinding> &bindings_with_ctx,\n+\t\t      Rib::ItemType type)\n+    : ResolverBase (), bindings_with_ctx (bindings_with_ctx), type (type)\n   {}\n \n-  std::vector<PatternBinding> &bindings;\n+  // To avoid having a separate visitor for consistency checks, we store\n+  // bindings in two forms:\n+\n+  // 1) Bindings as a vector of context-related sets.\n+  // Used for checking multiple bindings to the same identifier (i.e. E0415,\n+  // E0416).\n+  std::vector<PatternBinding> &bindings_with_ctx;\n+\n+  // 2) Bindings as a map between identifiers and binding info.\n+  // Used for checking consistency between alt patterns (i.e. E0408, E0409).\n+  BindingMap binding_info_map;\n+\n+  // we need to insert the missing and inconsistent bindings (found in\n+  // check_bindings_consistency) into maps to avoid duplication of error\n+  // messages.\n+  BindingMap inconsistent_bindings;\n+  BindingMap missing_bindings;\n+\n   Rib::ItemType type;\n };\n "}, {"sha": "5647015cda66c07c81ab07efe3f478582bcca60d", "filename": "gcc/testsuite/rust/compile/torture/alt_patterns1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a7a4d646eda1c0bf9dfdc433818249a3fd7e18/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Falt_patterns1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a7a4d646eda1c0bf9dfdc433818249a3fd7e18/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Falt_patterns1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Falt_patterns1.rs?ref=47a7a4d646eda1c0bf9dfdc433818249a3fd7e18", "patch": "@@ -0,0 +1,15 @@\n+enum E {\n+  A(i32),\n+  B(i32, i32),\n+}\n+\n+fn foo((E::A(a) | E::B(mut a, _)): E) {}\n+// { dg-error \"variable .a. is bound inconsistently across pattern alternatives .E0409.\" \"\" { target *-*-* } .-1 }\n+\n+fn bar((E::A(a) | E::B(mut b, a)): E) {}\n+// { dg-error \"variable .b. is not bound in all patterns .E0408.\" \"\" { target *-*-* } .-1 }\n+\n+fn baz_correct((a, (E::A(c) | (E::A(c) | E::B(_, c)) | E::B(c, _)), b): (i32, E, u8)) {}\n+\n+fn baz_wrong((a, (E::A(c) | (E::A(c) | E::B(_, c)) | E::B(c, z)), b): (i32, E, u8)) {}\n+// { dg-error \"variable .z. is not bound in all patterns .E0408.\" \"\" { target *-*-* } .-1 }\n\\ No newline at end of file"}]}