{"sha": "399e70e80d48330ed539b43f648741203d9a4f31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk5ZTcwZTgwZDQ4MzMwZWQ1MzliNDNmNjQ4NzQxMjAzZDlhNGYzMQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-06-16T08:33:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-06-16T08:33:07Z"}, "message": "a-textio.adb (Set_Col): Fix two errors noticed recently...\n\n2005-06-14  Robert Dewar  <dewar@adacore.com>\n\n\t* a-textio.adb (Set_Col): Fix two errors noticed recently, having to\n\tdo with treatment of Set_Col when positioned at end of line character.\n\nFrom-SVN: r101025", "tree": {"sha": "e851743b4a1567322ce1b55e6cb7961155e19956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e851743b4a1567322ce1b55e6cb7961155e19956"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/399e70e80d48330ed539b43f648741203d9a4f31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/399e70e80d48330ed539b43f648741203d9a4f31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/399e70e80d48330ed539b43f648741203d9a4f31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/399e70e80d48330ed539b43f648741203d9a4f31/comments", "author": null, "committer": null, "parents": [{"sha": "758c442c139f7dfa96cbb94bfcfa0cab337c62be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/758c442c139f7dfa96cbb94bfcfa0cab337c62be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/758c442c139f7dfa96cbb94bfcfa0cab337c62be"}], "stats": {"total": 47, "additions": 43, "deletions": 4}, "files": [{"sha": "306ab592e8c635d9229b176f23e512a4dec57021", "filename": "gcc/ada/a-textio.adb", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399e70e80d48330ed539b43f648741203d9a4f31/gcc%2Fada%2Fa-textio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399e70e80d48330ed539b43f648741203d9a4f31/gcc%2Fada%2Fa-textio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-textio.adb?ref=399e70e80d48330ed539b43f648741203d9a4f31", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                         GNAT RUNTIME COMPONENTS                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n --                          A D A . T E X T _ I O                           --\n --                                                                          --\n@@ -1340,43 +1340,82 @@ package body Ada.Text_IO is\n \n       FIO.Check_File_Open (AP (File));\n \n-      if To = File.Col then\n-         return;\n-      end if;\n+      --  Output case\n \n       if Mode (File) >= Out_File then\n+\n+         --  Error if we attempt to set Col to a value greater than the\n+         --  maximum permissible line length.\n+\n          if File.Line_Length /= 0 and then To > File.Line_Length then\n             raise Layout_Error;\n          end if;\n \n+         --  If we are behind current position, then go to start of new line\n+\n          if To < File.Col then\n             New_Line (File);\n          end if;\n \n+         --  Loop to output blanks till we are at the required column\n+\n          while File.Col < To loop\n             Put (File, ' ');\n          end loop;\n \n+      --  Input case\n+\n       else\n+         --  If we are logically before a LM, but physically after it, the\n+         --  file position still reflects the position before the LM, so eat\n+         --  it now and adjust the file position appropriately.\n+\n+         if File.Before_LM then\n+            File.Before_LM := False;\n+            File.Before_LM_PM := False;\n+            File.Line := File.Line + 1;\n+            File.Col := 1;\n+         end if;\n+\n+         --  Loop reading characters till we get one at the required Col value\n+\n          loop\n+            --  Read next character. The reason we have to read ahead is to\n+            --  skip formatting characters, the effect of Set_Col is to set\n+            --  us to a real character with the right Col value, and format\n+            --  characters don't count.\n+\n             ch := Getc (File);\n \n+            --  Error if we hit an end of file\n+\n             if ch = EOF then\n                raise End_Error;\n \n+            --  If line mark, eat it and adjust file position\n+\n             elsif ch = LM then\n                File.Line := File.Line + 1;\n                File.Col := 1;\n \n+            --  If recognized page mark, eat it, and adjust file position\n+\n             elsif ch = PM and then File.Is_Regular_File then\n                File.Page := File.Page + 1;\n                File.Line := 1;\n                File.Col := 1;\n \n+            --  Otherwise this is the character we are looking for, so put it\n+            --  back in the input stream (we have not adjusted the file\n+            --  position yet, so everything is set right after this ungetc).\n+\n             elsif To = File.Col then\n                Ungetc (ch, File);\n                return;\n \n+            --  Keep skipping characters if we are not there yet, updating the\n+            --  file position past the skipped character.\n+\n             else\n                File.Col := File.Col + 1;\n             end if;"}]}