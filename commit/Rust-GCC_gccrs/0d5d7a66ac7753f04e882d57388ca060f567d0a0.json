{"sha": "0d5d7a66ac7753f04e882d57388ca060f567d0a0", "node_id": "C_kwDOANBUbNoAKDBkNWQ3YTY2YWM3NzUzZjA0ZTg4MmQ1NzM4OGNhMDYwZjU2N2QwYTA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2023-02-10T10:17:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-10T10:17:07Z"}, "message": "Merge #1810 #1823 #1824 #1837 #1839\n\n1810: fixed indentation in AST pretty printed expanded dump of trait. r=CohenArthur a=00AR\n\nfixes #1785 \r\n\r\nSigned-off-by: Abdul Rafey <abdulrafeyq@gmail.com>\r\n---\r\n\r\nIn Dump::visit (TraitImpl), the for loop adds indentation before calling visit () on every iteration. I think when Dump::visit (Method) is executed it adds extra indentation on top of it.\r\n\n\n1823: parser: Improve parsing of complex generic arguments r=CohenArthur a=CohenArthur\n\nThe parser was missing code for handling complex type arguments such as type paths or nested generics.\r\n\r\ngcc/rust/ChangeLog:\r\n\r\n\t* parse/rust-parse-impl.h (Parser::parse_generic_arg): Handle type paths and nested generics properly.\r\n\r\ngcc/testsuite/ChangeLog:\r\n\r\n\t* rust/compile/parse_complex_generic_application.rs: New test.\r\n\t* rust/compile/parse_complex_generic_application2.rs: New test.\n\n1824: parser: Fix parsing of closure param list r=CohenArthur a=CohenArthur\n\ngcc/rust/ChangeLog:\r\n\r\n\t* parse/rust-parse-impl.h (Parser::parse_closure_expr): Advance tokens properly when parsing closure param list.\r\n\r\ngcc/testsuite/ChangeLog:\r\n\r\n\t* rust/compile/closure_move_expr.rs: New test.\r\n\r\n\n\n1837: typecheck: Refactor rust-hir-trait-reference.h r=CohenArthur a=P-E-P\n\nMove function body to their own cc file instead of keeping them in the header file.\r\n\r\ngcc/rust/ChangeLog:\r\n\r\n\t* Make-lang.in: Add `rust-hir-trait-reference.o`.\r\n\t* typecheck/rust-hir-trait-reference.h: Remove multiple function body.\r\n\t* typecheck/rust-hir-trait-reference.cc: Add multiple function body.\r\n\t\r\nFixes #1835\n\n1839: cli: Update safety warning message r=CohenArthur a=P-E-P\n\nThe compiler's warning message about the safety flag did not match cargo-gccrs environment variable name anymore.\r\n\r\ngcc/rust/ChangeLog:\r\n\r\n\t* rust-session-manager.cc (Session::compile_crate): Update the environment variable name.\r\n\r\nSigned-off-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>\r\n\r\nFixes #1829 \n\nCo-authored-by: Abdul Rafey <abdulrafeyq@gmail.com>\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\nCo-authored-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>", "tree": {"sha": "89ed53c37b1c90b33583a4f069bc55fe0cab0c2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89ed53c37b1c90b33583a4f069bc55fe0cab0c2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d5d7a66ac7753f04e882d57388ca060f567d0a0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj5hmkCRBK7hj4Ov3rIwAArxYIAAx+wK3jTK+Li0A3C1I8yxHi\nhp/GmQ14Dm8iUKeF2zNeblZExgsJbFh2Bf332RbvP5kIr9A43fYG0RqnFd+2Kk4o\nKRYqHKTretsUaJCWNrEFXHhC36M5axMXEvyna6mkHSU3kg/XDkg9sriWcw3LHNo/\nZGA5pKw0NSORRFtW0Mv6Y7OV6JDWacyc/xRLcHI/JjQ+dODpm5kW+/u1w4tU3KGC\nR6a+CgJ4tQdPkRX+WSp9sZlYuGgzZj/w0LviFR2QmrDqbiC6W3zHj18Q+uafHqQo\nvCCx3R6CnvXS6LjXZyi06zqTo+S+0OaMiz1Gjn4xtHkZKz6MxqKBArXMkd3IFNE=\n=Zwb7\n-----END PGP SIGNATURE-----\n", "payload": "tree 89ed53c37b1c90b33583a4f069bc55fe0cab0c2c\nparent bceb118bc2f542382591803d9727b8c199a44ddd\nparent c02a518fab792e5a8656cc7dfb0b88bb0de8a00f\nparent d60022770403ee3799644fb3832cbdd0d721e0f7\nparent 38bad2bf21ef0649b3e89bcccfe7e8f7c366de68\nparent 7179562ff2854bdd128a2a4ddcd5da5ac59c4512\nparent 9762350b8cac09e8f6671c42edc5cc4398b33753\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1676024227 +0000\ncommitter GitHub <noreply@github.com> 1676024227 +0000\n\nMerge #1810 #1823 #1824 #1837 #1839\n\n1810: fixed indentation in AST pretty printed expanded dump of trait. r=CohenArthur a=00AR\n\nfixes #1785 \r\n\r\nSigned-off-by: Abdul Rafey <abdulrafeyq@gmail.com>\r\n---\r\n\r\nIn Dump::visit (TraitImpl), the for loop adds indentation before calling visit () on every iteration. I think when Dump::visit (Method) is executed it adds extra indentation on top of it.\r\n\n\n1823: parser: Improve parsing of complex generic arguments r=CohenArthur a=CohenArthur\n\nThe parser was missing code for handling complex type arguments such as type paths or nested generics.\r\n\r\ngcc/rust/ChangeLog:\r\n\r\n\t* parse/rust-parse-impl.h (Parser::parse_generic_arg): Handle type paths and nested generics properly.\r\n\r\ngcc/testsuite/ChangeLog:\r\n\r\n\t* rust/compile/parse_complex_generic_application.rs: New test.\r\n\t* rust/compile/parse_complex_generic_application2.rs: New test.\n\n1824: parser: Fix parsing of closure param list r=CohenArthur a=CohenArthur\n\ngcc/rust/ChangeLog:\r\n\r\n\t* parse/rust-parse-impl.h (Parser::parse_closure_expr): Advance tokens properly when parsing closure param list.\r\n\r\ngcc/testsuite/ChangeLog:\r\n\r\n\t* rust/compile/closure_move_expr.rs: New test.\r\n\r\n\n\n1837: typecheck: Refactor rust-hir-trait-reference.h r=CohenArthur a=P-E-P\n\nMove function body to their own cc file instead of keeping them in the header file.\r\n\r\ngcc/rust/ChangeLog:\r\n\r\n\t* Make-lang.in: Add `rust-hir-trait-reference.o`.\r\n\t* typecheck/rust-hir-trait-reference.h: Remove multiple function body.\r\n\t* typecheck/rust-hir-trait-reference.cc: Add multiple function body.\r\n\t\r\nFixes #1835\n\n1839: cli: Update safety warning message r=CohenArthur a=P-E-P\n\nThe compiler's warning message about the safety flag did not match cargo-gccrs environment variable name anymore.\r\n\r\ngcc/rust/ChangeLog:\r\n\r\n\t* rust-session-manager.cc (Session::compile_crate): Update the environment variable name.\r\n\r\nSigned-off-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>\r\n\r\nFixes #1829 \n\nCo-authored-by: Abdul Rafey <abdulrafeyq@gmail.com>\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\nCo-authored-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d5d7a66ac7753f04e882d57388ca060f567d0a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d5d7a66ac7753f04e882d57388ca060f567d0a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d5d7a66ac7753f04e882d57388ca060f567d0a0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bceb118bc2f542382591803d9727b8c199a44ddd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bceb118bc2f542382591803d9727b8c199a44ddd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bceb118bc2f542382591803d9727b8c199a44ddd"}, {"sha": "c02a518fab792e5a8656cc7dfb0b88bb0de8a00f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c02a518fab792e5a8656cc7dfb0b88bb0de8a00f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c02a518fab792e5a8656cc7dfb0b88bb0de8a00f"}, {"sha": "d60022770403ee3799644fb3832cbdd0d721e0f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60022770403ee3799644fb3832cbdd0d721e0f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d60022770403ee3799644fb3832cbdd0d721e0f7"}, {"sha": "38bad2bf21ef0649b3e89bcccfe7e8f7c366de68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38bad2bf21ef0649b3e89bcccfe7e8f7c366de68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38bad2bf21ef0649b3e89bcccfe7e8f7c366de68"}, {"sha": "7179562ff2854bdd128a2a4ddcd5da5ac59c4512", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7179562ff2854bdd128a2a4ddcd5da5ac59c4512", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7179562ff2854bdd128a2a4ddcd5da5ac59c4512"}, {"sha": "9762350b8cac09e8f6671c42edc5cc4398b33753", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9762350b8cac09e8f6671c42edc5cc4398b33753", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9762350b8cac09e8f6671c42edc5cc4398b33753"}], "stats": {"total": 858, "additions": 553, "deletions": 305}, "files": [{"sha": "d625f4f13b5485d37e123bd75bff93e01f4abf50", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=0d5d7a66ac7753f04e882d57388ca060f567d0a0", "patch": "@@ -121,6 +121,7 @@ GRS_OBJS = \\\n     rust/rust-tyty-bounds.o \\\n     rust/rust-hir-type-check-util.o \\\n     rust/rust-hir-trait-resolve.o \\\n+    rust/rust-hir-trait-reference.o \\\n     rust/rust-hir-type-check-item.o \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-hir-type-check-struct.o \\"}, {"sha": "7a2fdc5b9b643cdc9a9e8f29c8c68de4aabd2bd5", "filename": "gcc/rust/ast/rust-ast-dump.cc", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Frust%2Fast%2Frust-ast-dump.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Frust%2Fast%2Frust-ast-dump.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-dump.cc?ref=0d5d7a66ac7753f04e882d57388ca060f567d0a0", "patch": "@@ -1072,8 +1072,6 @@ Dump::visit (TypeBoundWhereClauseItem &item)\n void\n Dump::visit (Method &method)\n {\n-  // FIXME: Do we really need to dump the indentation here?\n-  stream << indentation;\n   visit (method.get_visibility ());\n   stream << \"fn \" << method.get_method_name () << '(';\n \n@@ -1326,7 +1324,7 @@ void\n Dump::visit (TraitItemFunc &item)\n {\n   auto func = item.get_trait_function_decl ();\n-  stream << indentation << \"fn \" << func.get_identifier () << '(';\n+  stream << \"fn \" << func.get_identifier () << '(';\n \n   visit_items_joined_by_separator (func.get_function_params ());\n \n@@ -1340,9 +1338,6 @@ Dump::visit (TraitItemMethod &item)\n {\n   auto method = item.get_trait_method_decl ();\n \n-  // FIXME: Do we really need to dump the indentation here?\n-  stream << indentation;\n-\n   // FIXME: Can we have visibility here?\n   // emit_visibility (method.get_visibility ());\n   stream << \"fn \" << method.get_identifier () << '(';"}, {"sha": "0bac0f56f07be74fb9e0e5153023b39f456820e3", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=0d5d7a66ac7753f04e882d57388ca060f567d0a0", "patch": "@@ -6309,7 +6309,9 @@ Parser<ManagedTokenSource>::parse_generic_arg ()\n \t// could either have a valid type or a macro (FIXME: anything else?). So\n \t// we need one bit of lookahead to differentiate if this is really\n \tauto next_tok = lexer.peek_token (1);\n-\tif (next_tok->get_id () == EXCLAM)\n+\tif (next_tok->get_id () == LEFT_ANGLE\n+\t    || next_tok->get_id () == SCOPE_RESOLUTION\n+\t    || next_tok->get_id () == EXCLAM)\n \t  {\n \t    auto type = parse_type ();\n \t    if (type)\n@@ -7590,6 +7592,7 @@ Parser<ManagedTokenSource>::parse_closure_expr (AST::AttrVec outer_attrs)\n     case PIPE:\n       // actually may have parameters\n       lexer.skip_token ();\n+      t = lexer.peek_token ();\n \n       while (t->get_id () != PIPE)\n \t{\n@@ -7606,6 +7609,7 @@ Parser<ManagedTokenSource>::parse_closure_expr (AST::AttrVec outer_attrs)\n \n \t  if (lexer.peek_token ()->get_id () != COMMA)\n \t    {\n+\t      lexer.skip_token ();\n \t      // not an error but means param list is done\n \t      break;\n \t    }"}, {"sha": "6966ccc3de36139b0cd756c8ea2f81a2919a0d30", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=0d5d7a66ac7753f04e882d57388ca060f567d0a0", "patch": "@@ -447,7 +447,7 @@ Session::compile_crate (const char *filename)\n       \"defining the following environment variable (any value will \"\n       \"do)\\n\\nGCCRS_INCOMPLETE_AND_EXPERIMENTAL_COMPILER_DO_NOT_USE\\n\\nFor \"\n       \"cargo-gccrs, this means passing\\n\\n\"\n-      \"GCCRS_EXTRA_FLAGS=\\\"-frust-incomplete-and-experimental-compiler-do-not-\"\n+      \"GCCRS_EXTRA_ARGS=\\\"-frust-incomplete-and-experimental-compiler-do-not-\"\n       \"use\\\"\\n\\nas an environment variable.\");\n \n   RAIIFile file_wrap (filename);"}, {"sha": "651c55abc82172acf28e95794ee7182556500ef0", "filename": "gcc/rust/typecheck/rust-hir-trait-reference.cc", "status": "added", "additions": 463, "deletions": 0, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.cc?ref=0d5d7a66ac7753f04e882d57388ca060f567d0a0", "patch": "@@ -0,0 +1,463 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-trait-reference.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+std::string\n+TraitItemReference::as_string () const\n+{\n+  return \"(\" + trait_item_type_as_string (type) + \" \" + identifier + \" \" + \")\";\n+}\n+\n+bool\n+TraitItemReference::is_error () const\n+{\n+  return type == ERROR;\n+}\n+\n+bool\n+TraitItemReference::is_optional () const\n+{\n+  return optional_flag;\n+};\n+\n+std::string\n+TraitItemReference::get_identifier () const\n+{\n+  return identifier;\n+}\n+\n+TraitItemReference::TraitItemType\n+TraitItemReference::get_trait_item_type () const\n+{\n+  return type;\n+}\n+\n+HIR::TraitItem *\n+TraitItemReference::get_hir_trait_item () const\n+{\n+  return hir_trait_item;\n+}\n+\n+Location\n+TraitItemReference::get_locus () const\n+{\n+  return locus;\n+}\n+\n+const Analysis::NodeMapping\n+TraitItemReference::get_mappings () const\n+{\n+  return hir_trait_item->get_mappings ();\n+}\n+\n+TyTy::BaseType *\n+TraitItemReference::get_tyty () const\n+{\n+  rust_assert (hir_trait_item != nullptr);\n+\n+  switch (type)\n+    {\n+    case CONST:\n+      return get_type_from_constant (\n+\tstatic_cast</*const*/ HIR::TraitItemConst &> (*hir_trait_item));\n+      break;\n+\n+    case TYPE:\n+      return get_type_from_typealias (\n+\tstatic_cast</*const*/ HIR::TraitItemType &> (*hir_trait_item));\n+\n+    case FN:\n+      return get_type_from_fn (\n+\tstatic_cast</*const*/ HIR::TraitItemFunc &> (*hir_trait_item));\n+      break;\n+\n+    default:\n+      return get_error ();\n+    }\n+\n+  gcc_unreachable ();\n+  return get_error ();\n+}\n+\n+TyTy::ErrorType *\n+TraitItemReference::get_error () const\n+{\n+  return new TyTy::ErrorType (get_mappings ().get_hirid ());\n+}\n+\n+TraitReference::TraitReference (\n+  const HIR::Trait *hir_trait_ref, std::vector<TraitItemReference> item_refs,\n+  std::vector<const TraitReference *> super_traits,\n+  std::vector<TyTy::SubstitutionParamMapping> substs)\n+  : hir_trait_ref (hir_trait_ref), item_refs (item_refs),\n+    super_traits (super_traits)\n+{\n+  trait_substs.clear ();\n+  trait_substs.reserve (substs.size ());\n+  for (const auto &p : substs)\n+    trait_substs.push_back (p.clone ());\n+}\n+\n+TraitReference::TraitReference (TraitReference const &other)\n+  : hir_trait_ref (other.hir_trait_ref), item_refs (other.item_refs),\n+    super_traits (other.super_traits)\n+{\n+  trait_substs.clear ();\n+  trait_substs.reserve (other.trait_substs.size ());\n+  for (const auto &p : other.trait_substs)\n+    trait_substs.push_back (p.clone ());\n+}\n+\n+TraitReference &\n+TraitReference::operator= (TraitReference const &other)\n+{\n+  hir_trait_ref = other.hir_trait_ref;\n+  item_refs = other.item_refs;\n+  super_traits = other.super_traits;\n+\n+  trait_substs.clear ();\n+  trait_substs.reserve (other.trait_substs.size ());\n+  for (const auto &p : other.trait_substs)\n+    trait_substs.push_back (p.clone ());\n+\n+  return *this;\n+}\n+\n+bool\n+TraitReference::is_error () const\n+{\n+  return hir_trait_ref == nullptr;\n+}\n+\n+Location\n+TraitReference::get_locus () const\n+{\n+  return hir_trait_ref->get_locus ();\n+}\n+\n+std::string\n+TraitReference::get_name () const\n+{\n+  rust_assert (!is_error ());\n+  return hir_trait_ref->get_name ();\n+}\n+\n+std::string\n+TraitReference::as_string () const\n+{\n+  if (is_error ())\n+    return \"<trait-ref-error-node>\";\n+\n+  std::string item_buf;\n+  for (auto &item : item_refs)\n+    {\n+      item_buf += item.as_string () + \", \";\n+    }\n+  return \"HIR Trait: \" + get_name () + \"->\"\n+\t + hir_trait_ref->get_mappings ().as_string () + \" [\" + item_buf + \"]\";\n+}\n+\n+const HIR::Trait *\n+TraitReference::get_hir_trait_ref () const\n+{\n+  return hir_trait_ref;\n+}\n+\n+const Analysis::NodeMapping &\n+TraitReference::get_mappings () const\n+{\n+  return hir_trait_ref->get_mappings ();\n+}\n+\n+DefId\n+TraitReference::get_defid () const\n+{\n+  return get_mappings ().get_defid ();\n+}\n+\n+bool\n+TraitReference::lookup_hir_trait_item (const HIR::TraitItem &item,\n+\t\t\t\t       TraitItemReference **ref)\n+{\n+  return lookup_trait_item (item.trait_identifier (), ref);\n+}\n+\n+bool\n+TraitReference::lookup_trait_item (const std::string &ident,\n+\t\t\t\t   TraitItemReference **ref)\n+{\n+  for (auto &item : item_refs)\n+    {\n+      if (ident.compare (item.get_identifier ()) == 0)\n+\t{\n+\t  *ref = &item;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+bool\n+TraitReference::lookup_trait_item_by_type (\n+  const std::string &ident, TraitItemReference::TraitItemType type,\n+  TraitItemReference **ref)\n+{\n+  for (auto &item : item_refs)\n+    {\n+      if (item.get_trait_item_type () != type)\n+\tcontinue;\n+\n+      if (ident.compare (item.get_identifier ()) == 0)\n+\t{\n+\t  *ref = &item;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+bool\n+TraitReference::lookup_trait_item_by_type (\n+  const std::string &ident, TraitItemReference::TraitItemType type,\n+  const TraitItemReference **ref) const\n+{\n+  for (auto &item : item_refs)\n+    {\n+      if (item.get_trait_item_type () != type)\n+\tcontinue;\n+\n+      if (ident.compare (item.get_identifier ()) == 0)\n+\t{\n+\t  *ref = &item;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+bool\n+TraitReference::lookup_hir_trait_item (const HIR::TraitItem &item,\n+\t\t\t\t       const TraitItemReference **ref) const\n+{\n+  return lookup_trait_item (item.trait_identifier (), ref);\n+}\n+\n+bool\n+TraitReference::lookup_trait_item (const std::string &ident,\n+\t\t\t\t   const TraitItemReference **ref) const\n+{\n+  for (auto &item : item_refs)\n+    {\n+      if (ident.compare (item.get_identifier ()) == 0)\n+\t{\n+\t  *ref = &item;\n+\t  return true;\n+\t}\n+    }\n+\n+  // lookup super traits\n+  for (const auto &super_trait : super_traits)\n+    {\n+      bool found = super_trait->lookup_trait_item (ident, ref);\n+      if (found)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+const TraitItemReference *\n+TraitReference::lookup_trait_item (const std::string &ident,\n+\t\t\t\t   TraitItemReference::TraitItemType type) const\n+{\n+  for (auto &item : item_refs)\n+    {\n+      if (item.get_trait_item_type () != type)\n+\tcontinue;\n+\n+      if (ident.compare (item.get_identifier ()) == 0)\n+\treturn &item;\n+    }\n+\n+  // lookup super traits\n+  for (const auto &super_trait : super_traits)\n+    {\n+      const TraitItemReference *res\n+\t= super_trait->lookup_trait_item (ident, type);\n+      if (!res->is_error ())\n+\treturn res;\n+    }\n+\n+  return &TraitItemReference::error_node ();\n+}\n+\n+size_t\n+TraitReference::size () const\n+{\n+  return item_refs.size ();\n+}\n+\n+const std::vector<TraitItemReference> &\n+TraitReference::get_trait_items () const\n+{\n+  return item_refs;\n+}\n+\n+void\n+TraitReference::get_trait_items_and_supers (\n+  std::vector<const TraitItemReference *> &result) const\n+{\n+  for (const auto &item : item_refs)\n+    result.push_back (&item);\n+\n+  for (const auto &super_trait : super_traits)\n+    super_trait->get_trait_items_and_supers (result);\n+}\n+\n+void\n+TraitReference::on_resolved ()\n+{\n+  for (auto &item : item_refs)\n+    {\n+      item.on_resolved ();\n+    }\n+}\n+\n+void\n+TraitReference::clear_associated_types ()\n+{\n+  for (auto &item : item_refs)\n+    {\n+      bool is_assoc_type = item.get_trait_item_type ()\n+\t\t\t   == TraitItemReference::TraitItemType::TYPE;\n+      if (is_assoc_type)\n+\titem.associated_type_reset ();\n+    }\n+}\n+\n+bool\n+TraitReference::is_equal (const TraitReference &other) const\n+{\n+  DefId this_id = get_mappings ().get_defid ();\n+  DefId other_id = other.get_mappings ().get_defid ();\n+  return this_id == other_id;\n+}\n+\n+const std::vector<const TraitReference *>\n+TraitReference::get_super_traits () const\n+{\n+  return super_traits;\n+}\n+\n+bool\n+TraitReference::is_object_safe (bool emit_error, Location locus) const\n+{\n+  // https: // doc.rust-lang.org/reference/items/traits.html#object-safety\n+  std::vector<const TraitReference *> non_object_super_traits;\n+  for (auto &item : super_traits)\n+    {\n+      if (!item->is_object_safe (false, Location ()))\n+\tnon_object_super_traits.push_back (item);\n+    }\n+\n+  std::vector<const Resolver::TraitItemReference *> non_object_safe_items;\n+  for (auto &item : get_trait_items ())\n+    {\n+      if (!item.is_object_safe ())\n+\tnon_object_safe_items.push_back (&item);\n+    }\n+\n+  bool is_safe\n+    = non_object_super_traits.empty () && non_object_safe_items.empty ();\n+  if (emit_error && !is_safe)\n+    {\n+      RichLocation r (locus);\n+      for (auto &item : non_object_super_traits)\n+\tr.add_range (item->get_locus ());\n+      for (auto &item : non_object_safe_items)\n+\tr.add_range (item->get_locus ());\n+\n+      rust_error_at (r, \"trait bound is not object safe\");\n+    }\n+\n+  return is_safe;\n+}\n+\n+bool\n+TraitReference::trait_has_generics () const\n+{\n+  return !trait_substs.empty ();\n+}\n+\n+std::vector<TyTy::SubstitutionParamMapping>\n+TraitReference::get_trait_substs () const\n+{\n+  return trait_substs;\n+}\n+\n+bool\n+TraitReference::satisfies_bound (const TraitReference &reference) const\n+{\n+  if (is_equal (reference))\n+    return true;\n+\n+  for (const auto &super_trait : super_traits)\n+    {\n+      if (super_trait->satisfies_bound (reference))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+AssociatedImplTrait::AssociatedImplTrait (TraitReference *trait,\n+\t\t\t\t\t  HIR::ImplBlock *impl,\n+\t\t\t\t\t  TyTy::BaseType *self,\n+\t\t\t\t\t  Resolver::TypeCheckContext *context)\n+  : trait (trait), impl (impl), self (self), context (context)\n+{}\n+\n+TraitReference *\n+AssociatedImplTrait::get_trait ()\n+{\n+  return trait;\n+}\n+\n+HIR::ImplBlock *\n+AssociatedImplTrait::get_impl_block ()\n+{\n+  return impl;\n+}\n+\n+TyTy::BaseType *\n+AssociatedImplTrait::get_self ()\n+{\n+  return self;\n+}\n+const TyTy::BaseType *\n+AssociatedImplTrait::get_self () const\n+{\n+  return self;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "40a1fd7970cd01b432a86010f862a8607cdb0563", "filename": "gcc/rust/typecheck/rust-hir-trait-reference.h", "status": "modified", "additions": 46, "deletions": 297, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h?ref=0d5d7a66ac7753f04e882d57388ca060f567d0a0", "patch": "@@ -20,8 +20,8 @@\n #define RUST_HIR_TRAIT_REF_H\n \n #include \"rust-hir-full.h\"\n-#include \"rust-tyty-visitor.h\"\n #include \"rust-hir-type-check-util.h\"\n+#include \"rust-tyty-visitor.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -61,13 +61,9 @@ class TraitItemReference\n     return error;\n   }\n \n-  bool is_error () const { return type == ERROR; }\n+  bool is_error () const;\n \n-  std::string as_string () const\n-  {\n-    return \"(\" + trait_item_type_as_string (type) + \" \" + identifier + \" \"\n-\t   + \")\";\n-  }\n+  std::string as_string () const;\n \n   static std::string trait_item_type_as_string (TraitItemType ty)\n   {\n@@ -85,53 +81,24 @@ class TraitItemReference\n     return \"ERROR\";\n   }\n \n-  bool is_optional () const { return optional_flag; }\n-\n-  std::string get_identifier () const { return identifier; }\n-\n-  TraitItemType get_trait_item_type () const { return type; }\n-\n-  HIR::TraitItem *get_hir_trait_item () const { return hir_trait_item; }\n+  bool is_optional () const;\n \n-  Location get_locus () const { return locus; }\n+  std::string get_identifier () const;\n \n-  const Analysis::NodeMapping get_mappings () const\n-  {\n-    return hir_trait_item->get_mappings ();\n-  }\n+  TraitItemType get_trait_item_type () const;\n \n-  TyTy::BaseType *get_tyty () const\n-  {\n-    rust_assert (hir_trait_item != nullptr);\n+  HIR::TraitItem *get_hir_trait_item () const;\n \n-    switch (type)\n-      {\n-      case CONST:\n-\treturn get_type_from_constant (\n-\t  static_cast</*const*/ HIR::TraitItemConst &> (*hir_trait_item));\n-\tbreak;\n+  Location get_locus () const;\n \n-      case TYPE:\n-\treturn get_type_from_typealias (\n-\t  static_cast</*const*/ HIR::TraitItemType &> (*hir_trait_item));\n+  const Analysis::NodeMapping get_mappings () const;\n \n-      case FN:\n-\treturn get_type_from_fn (\n-\t  static_cast</*const*/ HIR::TraitItemFunc &> (*hir_trait_item));\n-\tbreak;\n-\n-      default:\n-\treturn get_error ();\n-      }\n-\n-    gcc_unreachable ();\n-    return get_error ();\n-  }\n+  TyTy::BaseType *get_tyty () const;\n \n   Analysis::NodeMapping get_parent_trait_mappings () const;\n \n-  // this is called when the trait is completed resolution and gives the items a\n-  // chance to run their specific type resolution passes. If we call their\n+  // this is called when the trait is completed resolution and gives the items\n+  // a chance to run their specific type resolution passes. If we call their\n   // resolution on construction it can lead to a case where the trait being\n   // resolved recursively trying to resolve the trait itself infinitely since\n   // the trait will not be stored in its own map yet\n@@ -144,10 +111,7 @@ class TraitItemReference\n   bool is_object_safe () const;\n \n private:\n-  TyTy::ErrorType *get_error () const\n-  {\n-    return new TyTy::ErrorType (get_mappings ().get_hirid ());\n-  }\n+  TyTy::ErrorType *get_error () const;\n \n   TyTy::BaseType *get_type_from_typealias (/*const*/\n \t\t\t\t\t   HIR::TraitItemType &type) const;\n@@ -182,39 +146,11 @@ class TraitReference\n   TraitReference (const HIR::Trait *hir_trait_ref,\n \t\t  std::vector<TraitItemReference> item_refs,\n \t\t  std::vector<const TraitReference *> super_traits,\n-\t\t  std::vector<TyTy::SubstitutionParamMapping> substs)\n-    : hir_trait_ref (hir_trait_ref), item_refs (item_refs),\n-      super_traits (super_traits)\n-  {\n-    trait_substs.clear ();\n-    trait_substs.reserve (substs.size ());\n-    for (const auto &p : substs)\n-      trait_substs.push_back (p.clone ());\n-  }\n-\n-  TraitReference (TraitReference const &other)\n-    : hir_trait_ref (other.hir_trait_ref), item_refs (other.item_refs),\n-      super_traits (other.super_traits)\n-  {\n-    trait_substs.clear ();\n-    trait_substs.reserve (other.trait_substs.size ());\n-    for (const auto &p : other.trait_substs)\n-      trait_substs.push_back (p.clone ());\n-  }\n-\n-  TraitReference &operator= (TraitReference const &other)\n-  {\n-    hir_trait_ref = other.hir_trait_ref;\n-    item_refs = other.item_refs;\n-    super_traits = other.super_traits;\n+\t\t  std::vector<TyTy::SubstitutionParamMapping> substs);\n \n-    trait_substs.clear ();\n-    trait_substs.reserve (other.trait_substs.size ());\n-    for (const auto &p : other.trait_substs)\n-      trait_substs.push_back (p.clone ());\n+  TraitReference (TraitReference const &other);\n \n-    return *this;\n-  }\n+  TraitReference &operator= (TraitReference const &other);\n \n   TraitReference (TraitReference &&other) = default;\n   TraitReference &operator= (TraitReference &&other) = default;\n@@ -224,256 +160,71 @@ class TraitReference\n     return TraitReference (nullptr, {}, {}, {});\n   }\n \n-  bool is_error () const { return hir_trait_ref == nullptr; }\n+  bool is_error () const;\n \n   static TraitReference &error_node ()\n   {\n     static TraitReference trait_error_node = TraitReference::error ();\n     return trait_error_node;\n   }\n \n-  Location get_locus () const { return hir_trait_ref->get_locus (); }\n+  Location get_locus () const;\n \n-  std::string get_name () const\n-  {\n-    rust_assert (!is_error ());\n-    return hir_trait_ref->get_name ();\n-  }\n+  std::string get_name () const;\n \n-  std::string as_string () const\n-  {\n-    if (is_error ())\n-      return \"<trait-ref-error-node>\";\n-\n-    std::string item_buf;\n-    for (auto &item : item_refs)\n-      {\n-\titem_buf += item.as_string () + \", \";\n-      }\n-    return \"HIR Trait: \" + get_name () + \"->\"\n-\t   + hir_trait_ref->get_mappings ().as_string () + \" [\" + item_buf\n-\t   + \"]\";\n-  }\n+  std::string as_string () const;\n \n-  const HIR::Trait *get_hir_trait_ref () const { return hir_trait_ref; }\n+  const HIR::Trait *get_hir_trait_ref () const;\n \n-  const Analysis::NodeMapping &get_mappings () const\n-  {\n-    return hir_trait_ref->get_mappings ();\n-  }\n+  const Analysis::NodeMapping &get_mappings () const;\n \n-  DefId get_defid () const { return get_mappings ().get_defid (); }\n+  DefId get_defid () const;\n \n   bool lookup_hir_trait_item (const HIR::TraitItem &item,\n-\t\t\t      TraitItemReference **ref)\n-  {\n-    return lookup_trait_item (item.trait_identifier (), ref);\n-  }\n+\t\t\t      TraitItemReference **ref);\n \n-  bool lookup_trait_item (const std::string &ident, TraitItemReference **ref)\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\tif (ident.compare (item.get_identifier ()) == 0)\n-\t  {\n-\t    *ref = &item;\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n+  bool lookup_trait_item (const std::string &ident, TraitItemReference **ref);\n \n   bool lookup_trait_item_by_type (const std::string &ident,\n \t\t\t\t  TraitItemReference::TraitItemType type,\n-\t\t\t\t  TraitItemReference **ref)\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\tif (item.get_trait_item_type () != type)\n-\t  continue;\n-\n-\tif (ident.compare (item.get_identifier ()) == 0)\n-\t  {\n-\t    *ref = &item;\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n+\t\t\t\t  TraitItemReference **ref);\n \n   bool lookup_trait_item_by_type (const std::string &ident,\n \t\t\t\t  TraitItemReference::TraitItemType type,\n-\t\t\t\t  const TraitItemReference **ref) const\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\tif (item.get_trait_item_type () != type)\n-\t  continue;\n-\n-\tif (ident.compare (item.get_identifier ()) == 0)\n-\t  {\n-\t    *ref = &item;\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n+\t\t\t\t  const TraitItemReference **ref) const;\n \n   bool lookup_hir_trait_item (const HIR::TraitItem &item,\n-\t\t\t      const TraitItemReference **ref) const\n-  {\n-    return lookup_trait_item (item.trait_identifier (), ref);\n-  }\n+\t\t\t      const TraitItemReference **ref) const;\n \n   bool lookup_trait_item (const std::string &ident,\n-\t\t\t  const TraitItemReference **ref) const\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\tif (ident.compare (item.get_identifier ()) == 0)\n-\t  {\n-\t    *ref = &item;\n-\t    return true;\n-\t  }\n-      }\n-\n-    // lookup super traits\n-    for (const auto &super_trait : super_traits)\n-      {\n-\tbool found = super_trait->lookup_trait_item (ident, ref);\n-\tif (found)\n-\t  return true;\n-      }\n-\n-    return false;\n-  }\n+\t\t\t  const TraitItemReference **ref) const;\n \n   const TraitItemReference *\n   lookup_trait_item (const std::string &ident,\n-\t\t     TraitItemReference::TraitItemType type) const\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\tif (item.get_trait_item_type () != type)\n-\t  continue;\n+\t\t     TraitItemReference::TraitItemType type) const;\n \n-\tif (ident.compare (item.get_identifier ()) == 0)\n-\t  return &item;\n-      }\n+  size_t size () const;\n \n-    // lookup super traits\n-    for (const auto &super_trait : super_traits)\n-      {\n-\tconst TraitItemReference *res\n-\t  = super_trait->lookup_trait_item (ident, type);\n-\tif (!res->is_error ())\n-\t  return res;\n-      }\n-\n-    return &TraitItemReference::error_node ();\n-  }\n-\n-  size_t size () const { return item_refs.size (); }\n-\n-  const std::vector<TraitItemReference> &get_trait_items () const\n-  {\n-    return item_refs;\n-  }\n+  const std::vector<TraitItemReference> &get_trait_items () const;\n \n   void get_trait_items_and_supers (\n-    std::vector<const TraitItemReference *> &result) const\n-  {\n-    for (const auto &item : item_refs)\n-      result.push_back (&item);\n-\n-    for (const auto &super_trait : super_traits)\n-      super_trait->get_trait_items_and_supers (result);\n-  }\n-\n-  void on_resolved ()\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\titem.on_resolved ();\n-      }\n-  }\n-\n-  void clear_associated_types ()\n-  {\n-    for (auto &item : item_refs)\n-      {\n-\tbool is_assoc_type = item.get_trait_item_type ()\n-\t\t\t     == TraitItemReference::TraitItemType::TYPE;\n-\tif (is_assoc_type)\n-\t  item.associated_type_reset ();\n-      }\n-  }\n-\n-  bool is_equal (const TraitReference &other) const\n-  {\n-    DefId this_id = get_mappings ().get_defid ();\n-    DefId other_id = other.get_mappings ().get_defid ();\n-    return this_id == other_id;\n-  }\n-\n-  const std::vector<const TraitReference *> get_super_traits () const\n-  {\n-    return super_traits;\n-  }\n-\n-  bool is_object_safe (bool emit_error, Location locus) const\n-  {\n-    // https: // doc.rust-lang.org/reference/items/traits.html#object-safety\n-    std::vector<const TraitReference *> non_object_super_traits;\n-    for (auto &item : super_traits)\n-      {\n-\tif (!item->is_object_safe (false, Location ()))\n-\t  non_object_super_traits.push_back (item);\n-      }\n+    std::vector<const TraitItemReference *> &result) const;\n \n-    std::vector<const Resolver::TraitItemReference *> non_object_safe_items;\n-    for (auto &item : get_trait_items ())\n-      {\n-\tif (!item.is_object_safe ())\n-\t  non_object_safe_items.push_back (&item);\n-      }\n+  void on_resolved ();\n \n-    bool is_safe\n-      = non_object_super_traits.empty () && non_object_safe_items.empty ();\n-    if (emit_error && !is_safe)\n-      {\n-\tRichLocation r (locus);\n-\tfor (auto &item : non_object_super_traits)\n-\t  r.add_range (item->get_locus ());\n-\tfor (auto &item : non_object_safe_items)\n-\t  r.add_range (item->get_locus ());\n+  void clear_associated_types ();\n \n-\trust_error_at (r, \"trait bound is not object safe\");\n-      }\n+  bool is_equal (const TraitReference &other) const;\n \n-    return is_safe;\n-  }\n+  const std::vector<const TraitReference *> get_super_traits () const;\n \n-  bool trait_has_generics () const { return !trait_substs.empty (); }\n+  bool is_object_safe (bool emit_error, Location locus) const;\n \n-  std::vector<TyTy::SubstitutionParamMapping> get_trait_substs () const\n-  {\n-    return trait_substs;\n-  }\n-\n-  bool satisfies_bound (const TraitReference &reference) const\n-  {\n-    if (is_equal (reference))\n-      return true;\n+  bool trait_has_generics () const;\n \n-    for (const auto &super_trait : super_traits)\n-      {\n-\tif (super_trait->satisfies_bound (reference))\n-\t  return true;\n-      }\n+  std::vector<TyTy::SubstitutionParamMapping> get_trait_substs () const;\n \n-    return false;\n-  }\n+  bool satisfies_bound (const TraitReference &reference) const;\n \n private:\n   const HIR::Trait *hir_trait_ref;\n@@ -487,16 +238,14 @@ class AssociatedImplTrait\n public:\n   AssociatedImplTrait (TraitReference *trait, HIR::ImplBlock *impl,\n \t\t       TyTy::BaseType *self,\n-\t\t       Resolver::TypeCheckContext *context)\n-    : trait (trait), impl (impl), self (self), context (context)\n-  {}\n+\t\t       Resolver::TypeCheckContext *context);\n \n-  TraitReference *get_trait () { return trait; }\n+  TraitReference *get_trait ();\n \n-  HIR::ImplBlock *get_impl_block () { return impl; }\n+  HIR::ImplBlock *get_impl_block ();\n \n-  TyTy::BaseType *get_self () { return self; }\n-  const TyTy::BaseType *get_self () const { return self; }\n+  TyTy::BaseType *get_self ();\n+  const TyTy::BaseType *get_self () const;\n \n   TyTy::BaseType *\n   setup_associated_types (const TyTy::BaseType *self,"}, {"sha": "780c316e0af28f7ff3c1a3355a7a98e0fa104ca8", "filename": "gcc/testsuite/rust/compile/closure_move_expr.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fclosure_move_expr.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fclosure_move_expr.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fclosure_move_expr.rs?ref=0d5d7a66ac7753f04e882d57388ca060f567d0a0", "patch": "@@ -0,0 +1,9 @@\n+// { dg-additional-options \"-fsyntax-only\" }\n+\n+fn foo() {\n+    move |l: u32, r: u32| l + r\n+}\n+\n+fn foo2() {\n+    |l: u32, r: u32| l + r\n+}"}, {"sha": "d5c7bf488b7d33371fc8bbe0f12f295a16af1a2d", "filename": "gcc/testsuite/rust/compile/parse_complex_generic_application.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fparse_complex_generic_application.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fparse_complex_generic_application.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fparse_complex_generic_application.rs?ref=0d5d7a66ac7753f04e882d57388ca060f567d0a0", "patch": "@@ -0,0 +1,17 @@\n+pub enum Either<T, E> {\n+    Left(T),\n+    Right(E),\n+}\n+\n+pub mod err {\n+    pub struct Error;\n+    pub struct ErrorWrap<T>(T);\n+}\n+\n+pub fn foo_err() -> Either<(), err::Error> {\n+    Either::Left(())\n+}\n+\n+pub fn foo_err_wrap() -> Either<(), err::ErrorWrap<u8>> {\n+    Either::Left(())\n+}"}, {"sha": "0361931c50c0b0b40234c5becf63fe78b6fb2814", "filename": "gcc/testsuite/rust/compile/parse_complex_generic_application2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fparse_complex_generic_application2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d5d7a66ac7753f04e882d57388ca060f567d0a0/gcc%2Ftestsuite%2Frust%2Fcompile%2Fparse_complex_generic_application2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fparse_complex_generic_application2.rs?ref=0d5d7a66ac7753f04e882d57388ca060f567d0a0", "patch": "@@ -0,0 +1,10 @@\n+pub enum Either<L, R> {\n+    Left(L),\n+    Right(R),\n+}\n+\n+pub struct Wrap<T>(T);\n+\n+pub fn foo_wrap() -> Either<(), Wrap<u8>> {\n+    Either::Left(())\n+}"}]}