{"sha": "03ef2c3bc55f8cd65c82a69c5209e03f240e2397", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNlZjJjM2JjNTVmOGNkNjVjODJhNjljNTIwOWUwM2YyNDBlMjM5Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-01T14:46:05Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-01T14:46:05Z"}, "message": "(R_KR): New macro.\n\n(FIRST_PSEUDO_REGISTER, FIXED_REGISTERS, CALL_USED_REGISTERS): Adjust for\nmore registers present.\n(REG_ALLOC_ORDER, REG_CLASS_CONTENTS, REGISTER_NAMES): Likewise.\n(HARD_REGNO_NREGS, HARD_REGNO_MODE_OK, REGNO_REG_CLASS): Likewise.\n(CONDITIONAL_REGISTER_USAGE): Swap names rather than replacing them.\n\n(TARGET_LARGE_MEMORY): New flag; change value for all others.\n(ENCODE_SECTION_INFO): New macro.\n(TARGET_SWITCHES): Add \"normal\" and change values.\n\nFrom-SVN: r5542", "tree": {"sha": "d8179bf6759a4ecfe9488a67cd9eb73bfeaddf67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8179bf6759a4ecfe9488a67cd9eb73bfeaddf67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03ef2c3bc55f8cd65c82a69c5209e03f240e2397", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03ef2c3bc55f8cd65c82a69c5209e03f240e2397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03ef2c3bc55f8cd65c82a69c5209e03f240e2397", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03ef2c3bc55f8cd65c82a69c5209e03f240e2397/comments", "author": null, "committer": null, "parents": [{"sha": "964119deb75540897c552b09c00d9a02e3f54f6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/964119deb75540897c552b09c00d9a02e3f54f6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/964119deb75540897c552b09c00d9a02e3f54f6b"}], "stats": {"total": 135, "additions": 84, "deletions": 51}, "files": [{"sha": "3a2d58e1d3339cff9125e33b5ae6f8966d90c5c9", "filename": "gcc/config/a29k/a29k.h", "status": "modified", "additions": 84, "deletions": 51, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ef2c3bc55f8cd65c82a69c5209e03f240e2397/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ef2c3bc55f8cd65c82a69c5209e03f240e2397/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=03ef2c3bc55f8cd65c82a69c5209e03f240e2397", "patch": "@@ -54,49 +54,55 @@ extern int target_flags;\n \n #define TARGET_SMALL_MEMORY\t(target_flags & 4)\n \n+/* This means that we must always used on indirect call, even when\n+   calling a function in the same file, since the file might be > 256KB.  */\n+\n+#define TARGET_LARGE_MEMORY\t(target_flags & 8)\n+\n /* This means that we are compiling for a 29050.  */\n \n-#define TARGET_29050\t\t(target_flags & 8)\n+#define TARGET_29050\t\t(target_flags & 16)\n \n /* This means that we are compiling for the kernel which means that we use\n    gr64-gr95 instead of gr96-126.  */\n \n-#define TARGET_KERNEL_REGISTERS\t(target_flags & 16)\n+#define TARGET_KERNEL_REGISTERS\t(target_flags & 32)\n \n /* This means that a call to \"__msp_check\" should be inserted after each stack\n    adjustment to check for stack overflow.  */\n \n-#define TARGET_STACK_CHECK\t(target_flags & 32)\n+#define TARGET_STACK_CHECK\t(target_flags & 64)\n \n /* This handles 29k processors which cannot handle the separation\n    of a mtsrim insns and a storem insn (most 29000 chips to date, but\n    not the 29050.  */\n \n-#define TARGET_NO_STOREM_BUG\t(target_flags & 64)\n+#define TARGET_NO_STOREM_BUG\t(target_flags & 128)\n \n /* This forces the compiler not to use incoming argument registers except\n    for copying out arguments.  It helps detect problems when a function is\n    called with fewer arguments than it is declared with.  */\n \n-#define TARGET_NO_REUSE_ARGS\t(target_flags & 128)\n+#define TARGET_NO_REUSE_ARGS\t(target_flags & 256)\n \n #define TARGET_SWITCHES\t\t\t\\\n   { {\"dw\", 1},\t\t\t\t\\\n     {\"ndw\", -1},\t\t\t\\\n     {\"bw\", 2},\t\t\t\t\\\n     {\"nbw\", - (1|2)},\t\t\t\\\n     {\"small\", 4},\t\t\t\\\n-    {\"large\", -4},\t\t\t\\\n-    {\"29050\", 8+64},\t\t\t\\\n-    {\"29000\", -8},\t\t\t\\\n-    {\"kernel-registers\", 16},\t\t\\\n-    {\"user-registers\", -16},\t\t\\\n-    {\"stack-check\", 32},\t\t\\\n-    {\"no-stack-check\", - 32},\t\t\\\n-    {\"storem-bug\", -64},\t\t\\\n-    {\"no-storem-bug\", 64},\t\t\\\n-    {\"reuse-arg-regs\", -128},\t\t\\\n-    {\"no-reuse-arg-regs\", 128},\t\t\\\n+    {\"normal\", - (4|8)},\t\t\\\n+    {\"large\", 8},\t\t\t\\\n+    {\"29050\", 16+128},\t\t\t\\\n+    {\"29000\", -16},\t\t\t\\\n+    {\"kernel-registers\", 32},\t\t\\\n+    {\"user-registers\", -32},\t\t\\\n+    {\"stack-check\", 64},\t\t\\\n+    {\"no-stack-check\", - 74},\t\t\\\n+    {\"storem-bug\", -128},\t\t\\\n+    {\"no-storem-bug\", 128},\t\t\\\n+    {\"reuse-arg-regs\", -256},\t\t\\\n+    {\"no-reuse-arg-regs\", 256},\t\t\\\n     {\"\", TARGET_DEFAULT}}\n \n #define TARGET_DEFAULT 3\n@@ -237,10 +243,14 @@ extern int target_flags;\n    Registers 200-203 are the four floating-point accumulator register in\n    the 29050.\n \n+   Registers 204-235 are the 32 global registers for kernel mode when\n+   -mkernel-registers is not specified, and the 32 global user registers\n+   when it is.\n+\n    When -mkernel-registers is specified, we still use the same register\n    map but change the names so 0-31 print as gr64-gr95.  */\n \n-#define FIRST_PSEUDO_REGISTER 204\n+#define FIRST_PSEUDO_REGISTER 236\n \n /* Because of the large number of registers on the 29k, we define macros\n    to refer to each group of registers and then define the number for some\n@@ -250,6 +260,7 @@ extern int target_flags;\n #define R_LR(N)\t\t((N) + 32)\t/* lr0 is register number 32 */\n #define R_FP\t\t176\t\t/* frame pointer is register 176 */\n #define R_AR(N)\t\t((N) + 160)\t/* first incoming arg reg is 160 */\n+#define R_KR(N)\t\t((N) + 204)\t/* kernel registers (gr64 to gr95) */\n \n /* Define the numbers of the special registers.  */\n #define R_BP\t177\n@@ -309,7 +320,9 @@ extern int target_flags;\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n   1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\t\t  \\\n-  0, 0, 0, 0 }\n+  0, 0, 0, 0,\t\t\t\t\t  \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -331,7 +344,9 @@ extern int target_flags;\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\t\t  \\\n-  1, 1, 1, 1 }\n+  1, 1, 1, 1,\t\t\t\t\t  \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n \n /* List the order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.\n@@ -382,15 +397,21 @@ extern int target_flags;\n    R_FP, R_BP, R_FC, R_CR, R_Q,\t\t\t\t\t\t\\\n    R_VAB, R_OPS, R_CPS, R_CFG, R_CHA, R_CHD, R_CHC, R_RBP, R_TMC,\t\\\n    R_TMR, R_PC0, R_PC1, R_PC2, R_MMU, R_LRU, R_FPE, R_INT, R_FPS,\t\\\n-   R_EXO }\n+   R_EXO,\t\t\t\t\t\t\t\t\\\n+   R_KR (0), R_KR (1), R_KR (2), R_KR (3), R_KR (4), R_KR (5), \t\t\\\n+   R_KR (6), R_KR (7), R_KR (8), R_KR (9), R_KR (10), R_KR (11),\t\\\n+   R_KR (12), R_KR (13), R_KR (14), R_KR (15), R_KR (16), R_KR (17),\t\\\n+   R_KR (18), R_KR (19), R_KR (20), R_KR (21), R_KR (22), R_KR (23),\t\\\n+   R_KR (24), R_KR (25), R_KR (26), R_KR (27), R_KR (28), R_KR (29),\t\\\n+   R_KR (30), R_KR (31) }\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((REGNO) >= R_ACC (0) ? 1\t\t\\\n+  ((REGNO) >= R_ACC (0) && (REGNO) <= R_ACC (3)? 1\t\t\\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n@@ -407,15 +428,15 @@ extern int target_flags;\n    (I'd like to use the \"?:\" syntax to make this more readable, but Sun's\n    compiler doesn't seem to accept it.)  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE)  \t\t\t\t\\\n-  (((REGNO) >= R_ACC (0)\t\t\t\t\t\t\\\n+(((REGNO) >= R_ACC (0) && (REGNO) <= R_ACC (3)\t\t\t\t\\\n     && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n \t|| GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT))\t\t\\\n    || ((REGNO) >= R_BP && (REGNO) <= R_CR\t\t\t\t\\\n        && GET_MODE_CLASS (MODE) == MODE_PARTIAL_INT)\t\t\t\\\n    || ((REGNO) >= R_Q && (REGNO) < R_ACC (0)\t\t\t\t\\\n        && GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t\\\n        && GET_MODE_CLASS (MODE) != MODE_COMPLEX_FLOAT)\t\t\t\\\n-   || ((REGNO) < R_BP\t\t\t\t\t\t\t\\\n+   || (((REGNO) < R_BP || (REGNO) >= R_KR (0))\t\t\t\t \\\n        && ((((REGNO) & 1) == 0)\t\t\t\t\t\t\\\n \t   || GET_MODE_UNIT_SIZE (MODE) <= UNITS_PER_WORD)))\n \n@@ -511,18 +532,18 @@ enum reg_class { NO_REGS, LR0_REGS, GENERAL_REGS, BP_REGS, FC_REGS, CR_REGS,\n    of length N_REG_CLASSES.  */\n \n #define REG_CLASS_CONTENTS\t\\\n-  { {0, 0, 0, 0, 0, 0, 0}, \t\\\n-    {0, 1, 0, 0, 0, 0, 0},\t\\\n-    {~0, ~0, ~0, ~0, ~0, ~ 0xfffe0000, 0},  \\\n-    {0, 0, 0, 0, 0, 0x20000, 0}, \t\\\n-    {0, 0, 0, 0, 0, 0x40000, 0}, \t\\\n-    {0, 0, 0, 0, 0, 0x80000, 0}, \t\\\n-    {0, 0, 0, 0, 0, 0x100000, 0}, \t\\\n-    {0, 0, 0, 0, 0, 0xfffe0000, 0xff},\t\\\n-    {0, 0, 0, 0, 0, 0, 0x100},\t\t\\\n-    {0, 0, 0, 0, 0, 0, 0xf00},\t\t\\\n-    {~0, ~0, ~0, ~0, ~0, ~ 0xfffe0000, 0xf00}, \\\n-    {~0, ~0, ~0, ~0, ~0, ~0, ~0} }\n+  { {0, 0, 0, 0, 0, 0, 0, 0}, \t\t\t\t   \\\n+    {0, 1, 0, 0, 0, 0, 0, 0},\t\t\t\t   \\\n+    {~0, ~0, ~0, ~0, ~0, ~ 0xfffe0000, ~ 0xfff, 0xfffff},  \\\n+    {0, 0, 0, 0, 0, 0x20000, 0, 0}, \t\t\t   \\\n+    {0, 0, 0, 0, 0, 0x40000, 0, 0}, \t\t\t   \\\n+    {0, 0, 0, 0, 0, 0x80000, 0, 0}, \t\t\t   \\\n+    {0, 0, 0, 0, 0, 0x100000, 0, 0}, \t\t\t   \\\n+    {0, 0, 0, 0, 0, 0xfffe0000, 0xff, 0},\t\t   \\\n+    {0, 0, 0, 0, 0, 0, 0x100, 0},\t\t\t   \\\n+    {0, 0, 0, 0, 0, 0, 0xf00, 0},\t\t\t   \\\n+    {~0, ~0, ~0, ~0, ~0, ~ 0xfffe0000, ~ 0xff, ~0}, \t   \\\n+    {~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0} }\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n@@ -536,6 +557,7 @@ enum reg_class { NO_REGS, LR0_REGS, GENERAL_REGS, BP_REGS, FC_REGS, CR_REGS,\n    : (REGNO) == R_Q ? Q_REGS\t\t\\\n    : (REGNO) > R_BP && (REGNO) <= R_EXO ? SPECIAL_REGS\t\\\n    : (REGNO) == R_ACC (0) ? ACCUM0_REGS\t\\\n+   : (REGNO) >= R_KR (0) ? GENERAL_REGS \\\n    : (REGNO) > R_ACC (0) ? ACCUM_REGS\t\\\n    : (REGNO) == R_LR (0) ? LR0_REGS\t\\\n    : GENERAL_REGS)\n@@ -563,21 +585,18 @@ enum reg_class { NO_REGS, LR0_REGS, GENERAL_REGS, BP_REGS, FC_REGS, CR_REGS,\n \n    On the 29k, we use this to change the register names for kernel mapping.  */\n \n-#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    static char *kernel_names[] = {\"gr64\", \"gr65\", \"gr66\", \"gr67\",\t\\\n-\t\t\t\t   \"gr68\", \"gr69\", \"gr70\", \"gr71\",\t\\\n-\t\t\t\t   \"gr72\", \"gr73\", \"gr74\", \"gr75\",\t\\\n-\t\t\t\t   \"gr76\", \"gr77\", \"gr78\", \"gr79\",\t\\\n-\t\t\t\t   \"gr80\", \"gr81\", \"gr82\", \"gr83\",\t\\\n-\t\t\t\t   \"gr84\", \"gr85\", \"gr86\", \"gr87\",\t\\\n-\t\t\t\t   \"gr88\", \"gr89\", \"gr90\", \"gr91\",\t\\\n-\t\t\t\t   \"gr92\", \"gr93\", \"gr94\", \"gr95\"};\t\\\n-    int i;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_KERNEL_REGISTERS)\t\t\t\t\t\\\n-      for (i = 0; i < 32; i++)\t\t\t\t\t\t\\\n-\treg_names[i] = kernel_names[i];\t\t\t\t\t\\\n+#define CONDITIONAL_REGISTER_USAGE\t\t\\\n+  {\t\t\t\t\t\t\\\n+    char *p;\t\t\t\t\t\\\n+    int i;\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+    if (TARGET_KERNEL_REGISTERS)\t\t\\\n+      for (i = 0; i < 32; i++)\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  p = reg_names[i];\t\t\t\\\n+\t  reg_names[i] = reg_names[R_KR (i)];\t\\\n+\t  reg_names[R_KR (i)] = p;\t\t\\\n+\t}\t\t\t\t\t\\\n   }\n \n /* The letters I, J, K, L, M, N, O, and P in a register constraint string\n@@ -1359,6 +1378,16 @@ literal_section ()\t\t\t\t\t\t\\\n \n #define READONLY_DATA_SECTION\tliteral_section\n \n+/* If we are referencing a function that is static or is known to be\n+   in this file, make the SYMBOL_REF special.  We can use this to indicate\n+   that we can branch to this function without emitting a no-op after the\n+   call.  */\n+\n+#define ENCODE_SECTION_INFO(DECL)  \\\n+  if (TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\\\n+      && (TREE_ASM_WRITTEN (DECL) || ! TREE_PUBLIC (DECL))) \\\n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\n+\n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n@@ -1387,7 +1416,11 @@ literal_section ()\t\t\t\t\t\t\\\n   \"bp\", \"fc\", \"cr\", \"q\",\t\t\t\t\t\t \\\n   \"vab\", \"ops\", \"cps\", \"cfg\", \"cha\", \"chd\", \"chc\", \"rbp\", \"tmc\", \"tmr\",\t \\\n   \"pc0\", \"pc1\", \"pc2\", \"mmu\", \"lru\", \"fpe\", \"int\", \"fps\", \"exo\",\t \\\n-  \"0\", \"1\", \"2\", \"3\" }\n+  \"0\", \"1\", \"2\", \"3\",\t\t\t\t\t\t\t \\\n+  \"gr64\", \"gr65\", \"gr66\", \"gr67\", \"gr68\", \"gr69\", \"gr70\", \"gr71\",\t \\\n+  \"gr72\", \"gr73\", \"gr74\", \"gr75\", \"gr76\", \"gr77\", \"gr78\", \"gr79\",\t \\\n+  \"gr80\", \"gr81\", \"gr82\", \"gr83\", \"gr84\", \"gr85\", \"gr86\", \"gr87\",\t \\\n+  \"gr88\", \"gr89\", \"gr90\", \"gr91\", \"gr92\", \"gr93\", \"gr94\", \"gr95\" }\n \n /* How to renumber registers for dbx and gdb.  */\n "}]}