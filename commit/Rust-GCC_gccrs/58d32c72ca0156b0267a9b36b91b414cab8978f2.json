{"sha": "58d32c72ca0156b0267a9b36b91b414cab8978f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThkMzJjNzJjYTAxNTZiMDI2N2E5YjM2YjkxYjQxNGNhYjg5NzhmMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-04T16:22:17Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-12T12:50:57Z"}, "message": "[Ada] Use GNAT encodings only when -fgnat-encodings=all is specified\n\ngcc/ada/\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <discrete_type>: Add a\n\tparallel type only when -fgnat-encodings=all is specified.\n\t<E_Array_Type>: Use the PAT name and special suffixes only when\n\t-fgnat-encodings=all is specified.\n\t<E_Array_Subtype>: Build a special type for debugging purposes only\n\twhen -fgnat-encodings=all is specified.  Add a parallel type or use\n\tthe PAT name only when -fgnat-encodings=all is specified.\n\t<E_Record_Type>: Generate debug info for the inner record types only\n\twhen -fgnat-encodings=all is specified.\n\t<E_Record_Subtype>: Use a debug type for an artificial subtype only\n\texcept when -fgnat-encodings=all is specified.\n\t(elaborate_expression_1): Reset need_for_debug when possible only\n\texcept when -fgnat-encodings=all is specified.\n\t(components_to_record): Use XV encodings for variable size only\n\twhen -fgnat-encodings=all is specified.\n\t(associate_original_type_to_packed_array): Add a parallel type only\n\twhen -fgnat-encodings=all is specified.\n\t* gcc-interface/misc.c (gnat_get_array_descr_info): Do not return\n\tfull information only when -fgnat-encodings=all is specified.\n\t* gcc-interface/utils.c (make_packable_type): Add a parallel type\n\tonly when -fgnat-encodings=all is specified.\n\t(maybe_pad_type): Make the inner type a debug type only except when\n\t-fgnat-encodings=all is specified.  Create an XVS type for variable\n\tsize only when -fgnat-encodings=all is specified.\n\t(rest_of_record_type_compilation): Add a parallel type only when\n\t-fgnat-encodings=all is specified.", "tree": {"sha": "51b15e14a84852a7baed1d67dc6fe7fad1844a89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51b15e14a84852a7baed1d67dc6fe7fad1844a89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58d32c72ca0156b0267a9b36b91b414cab8978f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58d32c72ca0156b0267a9b36b91b414cab8978f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58d32c72ca0156b0267a9b36b91b414cab8978f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58d32c72ca0156b0267a9b36b91b414cab8978f2/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ccd5d7192603e0ed6d0020658291b7c96f5651b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccd5d7192603e0ed6d0020658291b7c96f5651b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ccd5d7192603e0ed6d0020658291b7c96f5651b"}], "stats": {"total": 68, "additions": 33, "deletions": 35}, "files": [{"sha": "4b6479b2a04f6b8ba4d57aaa4f9898a01be1e8e6", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d32c72ca0156b0267a9b36b91b414cab8978f2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d32c72ca0156b0267a9b36b91b414cab8978f2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=58d32c72ca0156b0267a9b36b91b414cab8978f2", "patch": "@@ -1998,10 +1998,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t     so we use an intermediate step for standard DWARF.  */\n \t  if (debug_info_p)\n \t    {\n-\t      if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n-\t\tSET_TYPE_DEBUG_TYPE (gnu_type, gnu_field_type);\n-\t      else if (DECL_PARALLEL_TYPE (t))\n+\t      if (gnat_encodings == DWARF_GNAT_ENCODINGS_ALL)\n \t\tadd_parallel_type (gnu_type, DECL_PARALLEL_TYPE (t));\n+\t      else\n+\t\tSET_TYPE_DEBUG_TYPE (gnu_type, gnu_field_type);\n \t    }\n \t}\n \n@@ -2210,11 +2210,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t   implementation type.  But, in any case, mark it as artificial so\n \t   the debugger can skip it.  */\n \tconst Entity_Id gnat_name\n-\t  = Present (PAT) && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n+\t  = Present (PAT) && gnat_encodings == DWARF_GNAT_ENCODINGS_ALL\n \t    ? PAT\n \t    : gnat_entity;\n \ttree xup_name\n-\t  = gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n+\t  = gnat_encodings == DWARF_GNAT_ENCODINGS_ALL\n \t    ? create_concat_name (gnat_name, \"XUP\")\n \t    : gnu_entity_name;\n \tcreate_type_decl (xup_name, gnu_fat_type, true, debug_info_p,\n@@ -2420,11 +2420,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t   template at a negative offset, but this was somewhat of a kludge; we\n \t   now shift thin pointer values explicitly but only those which have a\n \t   TYPE_UNCONSTRAINED_ARRAY attached to the designated RECORD_TYPE.\n-\t   Note that GDB can handle standard DWARF information for them, so we\n-\t   don't have to name them as a GNAT encoding, except if specifically\n-\t   asked to.  */\n+\t   If the GNAT encodings are used, give it a name.  */\n \ttree xut_name\n-\t  = (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t  = (gnat_encodings == DWARF_GNAT_ENCODINGS_ALL)\n \t    ? create_concat_name (gnat_name, \"XUT\")\n \t    : gnu_entity_name;\n \tobj = build_unc_object_type (gnu_template_type, tem, xut_name,\n@@ -2673,7 +2671,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t       && TREE_CODE (TREE_TYPE (gnu_index_type))\n \t\t\t  != INTEGER_TYPE)\n \t\t   || TYPE_BIASED_REPRESENTATION_P (gnu_index_type))\n-\t\t  && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t\t  && gnat_encodings == DWARF_GNAT_ENCODINGS_ALL)\n \t\tneed_index_type_struct = true;\n \t    }\n \n@@ -2850,7 +2848,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t    gnu_entity_name = gnu_name;\n \t\t}\n \n-\t      else if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t      else if (gnat_encodings == DWARF_GNAT_ENCODINGS_ALL)\n \t\t{\n \t\t  tree gnu_base_decl\n \t\t    = gnat_to_gnu_entity (Etype (gnat_entity), NULL_TREE,\n@@ -2897,7 +2895,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t      save_gnu_tree (gnat_entity, NULL_TREE, false);\n \n \t      /* Set the ___XP suffix for GNAT encodings.  */\n-\t      if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t      if (gnat_encodings == DWARF_GNAT_ENCODINGS_ALL)\n \t\tgnu_entity_name = DECL_NAME (TYPE_NAME (gnu_type));\n \n \t      tree gnu_inner = gnu_type;\n@@ -3372,14 +3370,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t      = build_subst_list (gnat_entity, gnat_parent_type, definition);\n \n \t    /* Set the layout of the type to match that of the parent type,\n-\t       doing required substitutions.  If we are in minimal GNAT\n-\t       encodings mode, we don't need debug info for the inner record\n+\t       doing required substitutions.  Note that, if we do not use the\n+\t       GNAT encodings, we don't need debug info for the inner record\n \t       types, as they will be part of the embedding variant record's\n \t       debug info.  */\n \t    copy_and_substitute_in_layout\n \t      (gnat_entity, gnat_parent_type, gnu_type, gnu_parent_type,\n \t       gnu_subst_list,\n-\t       debug_info_p && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL);\n+\t       debug_info_p && gnat_encodings == DWARF_GNAT_ENCODINGS_ALL);\n \t  }\n \telse\n \t  {\n@@ -3518,11 +3516,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t      annotate_rep (gnat_entity, gnu_type);\n \n \t      /* If debugging information is being written for the type and if\n-\t\t we are asked to output such encodings, write a record that\n+\t\t we are asked to output GNAT encodings, write a record that\n \t\t shows what we are a subtype of and also make a variable that\n \t\t indicates our size, if still variable.  */\n \t      if (debug_info_p\n-\t\t  && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t\t  && gnat_encodings == DWARF_GNAT_ENCODINGS_ALL)\n \t\t{\n \t\t  tree gnu_subtype_marker = make_node (RECORD_TYPE);\n \t\t  tree gnu_unpad_base_name\n@@ -3553,11 +3551,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t\t\t true, true, NULL, gnat_entity, false);\n \t\t}\n \n-\t      /* Or else, if the subtype is artificial and encodings are not\n-\t\t used, use the base record type as the debug type.  */\n+\t      /* Or else, if the subtype is artificial and GNAT encodings are\n+\t\t not used, use the base record type as the debug type.  */\n \t      else if (debug_info_p\n \t\t       && artificial_p\n-\t\t       && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t\t       && gnat_encodings != DWARF_GNAT_ENCODINGS_ALL)\n \t\tSET_TYPE_DEBUG_TYPE (gnu_type, gnu_unpad_base_type);\n \t    }\n \n@@ -6892,7 +6890,7 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n      we must be careful because we do not generate debug info for external\n      variables so DECL_IGNORED_P is not stable across units.  */\n   if (need_for_debug\n-      && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL\n+      && gnat_encodings != DWARF_GNAT_ENCODINGS_ALL\n       && (TREE_CONSTANT (gnu_expr)\n \t  || (!expr_public_p\n \t      && DECL_P (gnu_expr)\n@@ -7777,7 +7775,7 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n \t\t      tree *p_gnu_rep_list)\n {\n   const bool needs_xv_encodings\n-    = debug_info && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL;\n+    = debug_info && gnat_encodings == DWARF_GNAT_ENCODINGS_ALL;\n   bool all_rep_and_size = all_rep && TYPE_SIZE (gnu_record_type);\n   bool variants_have_rep = all_rep;\n   bool layout_with_rep = false;\n@@ -10241,7 +10239,12 @@ associate_original_type_to_packed_array (tree gnu_type, Entity_Id gnat_entity)\n \n   gcc_assert (TYPE_IMPL_PACKED_ARRAY_P (gnu_type));\n \n-  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+  if (gnat_encodings == DWARF_GNAT_ENCODINGS_ALL)\n+    {\n+      add_parallel_type (gnu_type, gnu_original_array_type);\n+      return NULL_TREE;\n+    }\n+  else\n     {\n       SET_TYPE_ORIGINAL_PACKED_ARRAY (gnu_type, gnu_original_array_type);\n \n@@ -10250,11 +10253,6 @@ associate_original_type_to_packed_array (tree gnu_type, Entity_Id gnat_entity)\n \toriginal_name = DECL_NAME (original_name);\n       return original_name;\n     }\n-  else\n-    {\n-      add_parallel_type (gnu_type, gnu_original_array_type);\n-      return NULL_TREE;\n-    }\n }\n \n /* Given a type T, a FIELD_DECL F, and a replacement value R, return an"}, {"sha": "186367ac6d187b6d71fd54e85e752b98e33ca43c", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d32c72ca0156b0267a9b36b91b414cab8978f2/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d32c72ca0156b0267a9b36b91b414cab8978f2/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=58d32c72ca0156b0267a9b36b91b414cab8978f2", "patch": "@@ -806,7 +806,7 @@ gnat_get_array_descr_info (const_tree const_type,\n   /* As well as array types embedded in a record type with their bounds.  */\n   else if (TREE_CODE (type) == RECORD_TYPE\n \t   && TYPE_CONTAINS_TEMPLATE_P (type)\n-\t   && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t   && gnat_encodings != DWARF_GNAT_ENCODINGS_ALL)\n     {\n       /* This will be our base object address.  Note that we assume that\n \t pointers to this will actually point to the array field (thin\n@@ -901,7 +901,7 @@ gnat_get_array_descr_info (const_tree const_type,\n \t  if (TYPE_CONTEXT (first_dimen)\n \t      && TREE_CODE (TYPE_CONTEXT (first_dimen)) != RECORD_TYPE\n \t      && CONTAINS_PLACEHOLDER_P (TYPE_MIN_VALUE (index_type))\n-\t      && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t      && gnat_encodings == DWARF_GNAT_ENCODINGS_ALL)\n \t    {\n \t      info->dimen[i].lower_bound = NULL_TREE;\n \t      info->dimen[i].upper_bound = NULL_TREE;\n@@ -943,7 +943,7 @@ gnat_get_array_descr_info (const_tree const_type,\n   info->associated = NULL_TREE;\n   info->data_location = NULL_TREE;\n \n-  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+  if (gnat_encodings != DWARF_GNAT_ENCODINGS_ALL)\n     {\n       /* When arrays contain dynamically-sized elements, we usually wrap them\n \t in padding types, or we create constrained types for them.  Then, if"}, {"sha": "846d20a8be7595f5490ad58840bf57f7e0e470c7", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d32c72ca0156b0267a9b36b91b414cab8978f2/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d32c72ca0156b0267a9b36b91b414cab8978f2/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=58d32c72ca0156b0267a9b36b91b414cab8978f2", "patch": "@@ -1277,7 +1277,7 @@ make_packable_type (tree type, bool in_record, unsigned int max_align)\n \n   finish_record_type (new_type, nreverse (new_field_list), 2, false);\n   relate_alias_sets (new_type, type, ALIAS_SET_COPY);\n-  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+  if (gnat_encodings != DWARF_GNAT_ENCODINGS_ALL)\n     SET_TYPE_DEBUG_TYPE (new_type, TYPE_DEBUG_TYPE (type));\n   else if (TYPE_STUB_DECL (type))\n     SET_DECL_PARALLEL_TYPE (TYPE_STUB_DECL (new_type),\n@@ -1610,7 +1610,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n     }\n \n   /* Make the inner type the debug type of the padded type.  */\n-  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+  if (gnat_encodings != DWARF_GNAT_ENCODINGS_ALL)\n     SET_TYPE_DEBUG_TYPE (record, maybe_debug_type (type));\n \n   /* Unless debugging information isn't being written for the input type,\n@@ -1645,7 +1645,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n       /* There is no need to show what we are a subtype of when outputting as\n \t few encodings as possible: regular debugging infomation makes this\n \t redundant.  */\n-      if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+      if (gnat_encodings == DWARF_GNAT_ENCODINGS_ALL)\n \t{\n \t  tree marker = make_node (RECORD_TYPE);\n \t  tree orig_name = TYPE_IDENTIFIER (type);\n@@ -2274,7 +2274,7 @@ rest_of_record_type_compilation (tree record_type)\n \n   /* If this record type is of variable size, make a parallel record type that\n      will tell the debugger how the former is laid out (see exp_dbug.ads).  */\n-  if (var_size && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+  if (var_size && gnat_encodings == DWARF_GNAT_ENCODINGS_ALL)\n     {\n       tree new_record_type\n \t= make_node (TREE_CODE (record_type) == QUAL_UNION_TYPE"}]}