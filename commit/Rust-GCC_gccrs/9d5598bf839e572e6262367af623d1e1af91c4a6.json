{"sha": "9d5598bf839e572e6262367af623d1e1af91c4a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ1NTk4YmY4MzllNTcyZTYyNjIzNjdhZjYyM2QxZTFhZjkxYzRhNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-23T09:50:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-23T09:50:31Z"}, "message": "[multiple changes]\n\n2013-04-23  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Significant\n\trewrite to make sure Is_Ignore is properly captured when aspect\n\tis declared.\n\t* sem_ch6.adb: Minor reformatting.\n\t* sem_prag.adb (Analyze_Pragma): Do not test policy at time of\n\tpragma for the case of a pragma coming from an aspect (already\n\ttested when we analyzed the aspect).\n\n2013-04-23  Vincent Celier  <celier@adacore.com>\n\n\t* prj-conf.adb (Parse_Project_And_Apply_Config): New\n\tBoolean parameter Implicit_Project, defaulted to False. Call\n\tPrj.Part.Parse with Implicit_Project.\n\t* prj-conf.ads (Parse_Project_And_Apply_Config): New Boolean\n\tparameter Implicit_Project, defaulted to False.\n\t* prj-part.adb (Parse_Single_Project): New Boolean parameter\n\tImplicit_Project, defaulted to False. When Implicit_Project is\n\tTrue, change the Directory of the project node to the Current_Dir.\n\t* prj-part.ads (Parse): New Boolean parameter, defaulted to False\n\n2013-04-23  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_util.adb: Minor reformatting.\n\nFrom-SVN: r198184", "tree": {"sha": "736488b1564594a20c6544bb39015355c43363c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/736488b1564594a20c6544bb39015355c43363c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d5598bf839e572e6262367af623d1e1af91c4a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d5598bf839e572e6262367af623d1e1af91c4a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d5598bf839e572e6262367af623d1e1af91c4a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d5598bf839e572e6262367af623d1e1af91c4a6/comments", "author": null, "committer": null, "parents": [{"sha": "72267417bd5d1072812339dee3bf426b686f81b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72267417bd5d1072812339dee3bf426b686f81b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72267417bd5d1072812339dee3bf426b686f81b6"}], "stats": {"total": 531, "additions": 325, "deletions": 206}, "files": [{"sha": "b81550c73383b5d8469d28cab99c8694233d1a98", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9d5598bf839e572e6262367af623d1e1af91c4a6", "patch": "@@ -1,3 +1,29 @@\n+2013-04-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Significant\n+\trewrite to make sure Is_Ignore is properly captured when aspect\n+\tis declared.\n+\t* sem_ch6.adb: Minor reformatting.\n+\t* sem_prag.adb (Analyze_Pragma): Do not test policy at time of\n+\tpragma for the case of a pragma coming from an aspect (already\n+\ttested when we analyzed the aspect).\n+\n+2013-04-23  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-conf.adb (Parse_Project_And_Apply_Config): New\n+\tBoolean parameter Implicit_Project, defaulted to False. Call\n+\tPrj.Part.Parse with Implicit_Project.\n+\t* prj-conf.ads (Parse_Project_And_Apply_Config): New Boolean\n+\tparameter Implicit_Project, defaulted to False.\n+\t* prj-part.adb (Parse_Single_Project): New Boolean parameter\n+\tImplicit_Project, defaulted to False. When Implicit_Project is\n+\tTrue, change the Directory of the project node to the Current_Dir.\n+\t* prj-part.ads (Parse): New Boolean parameter, defaulted to False\n+\n+2013-04-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_util.adb: Minor reformatting.\n+\n 2013-04-23  Robert Dewar  <dewar@adacore.com>\n \n \t* xoscons.adb: Minor reformatting."}, {"sha": "03442ac322e9d8e505bf8915cde88f19551ea988", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=9d5598bf839e572e6262367af623d1e1af91c4a6", "patch": "@@ -2586,9 +2586,11 @@ package body Exp_Util is\n    begin\n       Start_String;\n       Internal_Full_Qualified_Name (E);\n+\n       if Append_NUL then\n          Store_String_Char (Get_Char_Code (ASCII.NUL));\n       end if;\n+\n       return End_String;\n    end Fully_Qualified_Name_String;\n "}, {"sha": "48241efbdd0b511ce2be712302d97adb508b2d8c", "filename": "gcc/ada/prj-conf.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fprj-conf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fprj-conf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.adb?ref=9d5598bf839e572e6262367af623d1e1af91c4a6", "patch": "@@ -1558,7 +1558,8 @@ package body Prj.Conf is\n       Config_File_Path           : out String_Access;\n       Target_Name                : String := \"\";\n       Normalized_Hostname        : String;\n-      On_Load_Config             : Config_File_Hook := null)\n+      On_Load_Config             : Config_File_Hook := null;\n+      Implicit_Project           : Boolean := False)\n    is\n    begin\n       pragma Assert (Prj.Env.Is_Initialized (Env.Project_Path));\n@@ -1578,7 +1579,8 @@ package body Prj.Conf is\n          Packages_To_Check => Packages_To_Check,\n          Current_Directory => Current_Directory,\n          Is_Config_File    => False,\n-         Env               => Env);\n+         Env               => Env,\n+         Implicit_Project  => Implicit_Project);\n \n       if User_Project_Node = Empty_Node then\n          User_Project_Node := Empty_Node;"}, {"sha": "172356f48ec1ddfbe455f5bb233c079c9180e6ac", "filename": "gcc/ada/prj-conf.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fprj-conf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fprj-conf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.ads?ref=9d5598bf839e572e6262367af623d1e1af91c4a6", "patch": "@@ -55,7 +55,8 @@ package Prj.Conf is\n       Config_File_Path           : out String_Access;\n       Target_Name                : String := \"\";\n       Normalized_Hostname        : String;\n-      On_Load_Config             : Config_File_Hook := null);\n+      On_Load_Config             : Config_File_Hook := null;\n+      Implicit_Project           : Boolean := False);\n    --  Find the main configuration project and parse the project tree rooted at\n    --  this configuration project.\n    --\n@@ -85,6 +86,11 @@ package Prj.Conf is\n    --  Any error in generating or parsing the config file is reported via the\n    --  Invalid_Config exception, with an appropriate message. Any error while\n    --  parsing the project file results in No_Project.\n+   --\n+   --  If Implicit_Project is True, the main project file being parsed is\n+   --  deemed to be in the current working directory, even if it is not the\n+   --  case.\n+   --  Why is this ever useful???\n \n    procedure Process_Project_And_Apply_Config\n      (Main_Project               : out Prj.Project_Id;"}, {"sha": "7f617a0e6dc881a402c1bcd3f6974378c4163718", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=9d5598bf839e572e6262367af623d1e1af91c4a6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -191,7 +191,8 @@ package body Prj.Part is\n       Depth             : Natural;\n       Current_Dir       : String;\n       Is_Config_File    : Boolean;\n-      Env               : in out Environment);\n+      Env               : in out Environment;\n+      Implicit_Project  : Boolean := False);\n    --  Parse a project file. This is a recursive procedure: it calls itself for\n    --  imported and extended projects. When From_Extended is not None, if the\n    --  project has already been parsed and is an extended project A, return the\n@@ -201,6 +202,10 @@ package body Prj.Part is\n    --\n    --  Is_Config_File should be set to True if the project represents a config\n    --  file (.cgpr) since some specific checks apply.\n+   --\n+   --  If Implicit_Project is True, change the Directory of the project node\n+   --  to be the Current_Dir. Recursive calls to Parse_Single_Project are\n+   --  always done with the default False value for Implicit_Project.\n \n    procedure Pre_Parse_Context_Clause\n      (In_Tree        : Project_Node_Tree_Ref;\n@@ -530,7 +535,8 @@ package body Prj.Part is\n       Current_Directory : String := \"\";\n       Is_Config_File    : Boolean;\n       Env               : in out Prj.Tree.Environment;\n-      Target_Name       : String := \"\")\n+      Target_Name       : String := \"\";\n+      Implicit_Project  : Boolean := False)\n    is\n       Dummy : Boolean;\n       pragma Warnings (Off, Dummy);\n@@ -598,7 +604,8 @@ package body Prj.Part is\n             Depth             => 0,\n             Current_Dir       => Current_Directory,\n             Is_Config_File    => Is_Config_File,\n-            Env               => Env);\n+            Env               => Env,\n+            Implicit_Project  => Implicit_Project);\n \n       exception\n          when Types.Unrecoverable_Error =>\n@@ -1230,7 +1237,8 @@ package body Prj.Part is\n       Depth             : Natural;\n       Current_Dir       : String;\n       Is_Config_File    : Boolean;\n-      Env               : in out Environment)\n+      Env               : in out Environment;\n+      Implicit_Project  : Boolean := False)\n    is\n       Path_Name : constant String := Get_Name_String (Path_Name_Id);\n \n@@ -1394,7 +1402,10 @@ package body Prj.Part is\n       Tree.Reset_State;\n       Scan (In_Tree);\n \n-      if not Is_Config_File and then Name_From_Path = No_Name then\n+      if not Is_Config_File\n+        and then Name_From_Path = No_Name\n+        and then not Implicit_Project\n+      then\n \n          --  The project file name is not correct (no or bad extension, or not\n          --  following Ada identifier's syntax).\n@@ -1977,6 +1988,13 @@ package body Prj.Part is\n       Tree.Restore_And_Free (Project_Comment_State);\n \n       Debug_Decrease_Indent;\n+\n+      if Project /= Empty_Node and then Implicit_Project then\n+         Name_Len := 0;\n+         Add_Str_To_Name_Buffer (Current_Dir);\n+         Add_Char_To_Name_Buffer (Dir_Sep);\n+         In_Tree.Project_Nodes.Table (Project).Directory := Name_Find;\n+      end if;\n    end Parse_Single_Project;\n \n    -----------------------"}, {"sha": "438ec9dda945a868af519c7c85c256eefbc2b89b", "filename": "gcc/ada/prj-part.ads", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fprj-part.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fprj-part.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.ads?ref=9d5598bf839e572e6262367af623d1e1af91c4a6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,7 +47,8 @@ package Prj.Part is\n       Current_Directory : String := \"\";\n       Is_Config_File    : Boolean;\n       Env               : in out Prj.Tree.Environment;\n-      Target_Name       : String := \"\");\n+      Target_Name       : String := \"\";\n+      Implicit_Project  : Boolean := False);\n    --  Parse project file and all its imported project files and create a tree.\n    --  Return the node for the project (or Empty_Node if parsing failed). If\n    --  Always_Errout_Finalize is True, Errout.Finalize is called in all cases,\n@@ -66,5 +67,10 @@ package Prj.Part is\n    --  Target_Name will be used to initialize the default project path, unless\n    --  In_Tree.Project_Path has already been initialized (which is the\n    --  recommended use).\n+   --\n+   --  If Implicit_Project is True, the main project file being parsed is\n+   --  deemed to be in the current working directory, even if it is not the\n+   --  case.\n+   --  Why is this ever useful???\n \n end Prj.Part;"}, {"sha": "24970f1aadf0cbe1ca7100a5bd2feeb14ea2ade8", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 209, "deletions": 157, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=9d5598bf839e572e6262367af623d1e1af91c4a6", "patch": "@@ -961,7 +961,7 @@ package body Sem_Ch13 is\n \n       Aspect := First (L);\n       Aspect_Loop : while Present (Aspect) loop\n-         declare\n+         Analyze_One_Aspect : declare\n             Expr : constant Node_Id    := Expression (Aspect);\n             Id   : constant Node_Id    := Identifier (Aspect);\n             Loc  : constant Source_Ptr := Sloc (Aspect);\n@@ -977,12 +977,22 @@ package body Sem_Ch13 is\n             --  is set below when Expr is present.\n \n             procedure Analyze_Aspect_External_Or_Link_Name;\n-            --  This routine performs the analysis of the External_Name or\n-            --  Link_Name aspects.\n+            --  Perform analysis of the External_Name or Link_Name aspects\n \n             procedure Analyze_Aspect_Implicit_Dereference;\n-            --  This routine performs the analysis of the Implicit_Dereference\n-            --  aspects.\n+            --  Perform  analysis of the Implicit_Dereference aspects\n+\n+            procedure Make_Aitem_Pragma\n+              (Pragma_Argument_Associations : List_Id;\n+               Pragma_Name                  : Name_Id);\n+            --  This is a wrapper for Make_Pragma used for converting aspects\n+            --  to pragmas. It takes care of Sloc (set from Loc) and building\n+            --  the pragma identifier from the given name. In addition the\n+            --  flags Class_Present and Split_PPC are set from the aspect\n+            --  node, as well as Is_Ignored. This routine also sets the\n+            --  From_Aspect_Specification in the resulting pragma node to\n+            --  True, and sets Corresponding_Aspect to point to the aspect.\n+            --  The resulting pragma is assigned to Aitem.\n \n             ------------------------------------------\n             -- Analyze_Aspect_External_Or_Link_Name --\n@@ -1051,6 +1061,42 @@ package body Sem_Ch13 is\n                end if;\n             end Analyze_Aspect_Implicit_Dereference;\n \n+            -----------------------\n+            -- Make_Aitem_Pragma --\n+            -----------------------\n+\n+            procedure Make_Aitem_Pragma\n+              (Pragma_Argument_Associations : List_Id;\n+               Pragma_Name                  : Name_Id)\n+            is\n+            begin\n+               --  We should never get here if aspect was disabled\n+\n+               pragma Assert (not Is_Disabled (Aspect));\n+\n+               --  Build the pragma\n+\n+               Aitem :=\n+                 Make_Pragma (Loc,\n+                   Pragma_Argument_Associations =>\n+                     Pragma_Argument_Associations,\n+                   Pragma_Identifier =>\n+                     Make_Identifier (Sloc (Id), Pragma_Name),\n+                     Class_Present     => Class_Present (Aspect),\n+                     Split_PPC         => Split_PPC (Aspect));\n+\n+               --  Set additional semantic fields\n+\n+               if Is_Ignored (Aspect) then\n+                  Set_Is_Ignored (Aitem);\n+               end if;\n+\n+               Set_Corresponding_Aspect (Aitem, Aspect);\n+               Set_From_Aspect_Specification (Aitem, True);\n+            end Make_Aitem_Pragma;\n+\n+         --  Start of processing for Analyze_One_Aspect\n+\n          begin\n             --  Skip aspect if already analyzed (not clear if this is needed)\n \n@@ -1059,7 +1105,8 @@ package body Sem_Ch13 is\n             end if;\n \n             --  Skip looking at aspect if it is totally disabled. Just mark\n-            --  it as such for later reference in the tree.\n+            --  it as such for later reference in the tree. This also sets\n+            --  the Is_Ignored flag appropriately.\n \n             Check_Applicable_Policy (Aspect);\n \n@@ -1218,53 +1265,51 @@ package body Sem_Ch13 is\n                --  referring to the entity, and the second argument is the\n                --  aspect definition expression.\n \n+               --  Suppress/Unsuppress\n+\n                when Aspect_Suppress   |\n                     Aspect_Unsuppress =>\n \n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Argument_Associations => New_List (\n-                        Make_Pragma_Argument_Association (Loc,\n-                          Expression => New_Occurrence_Of (E, Loc)),\n-\n-                        Make_Pragma_Argument_Association (Sloc (Expr),\n-                          Expression => Relocate_Node (Expr))),\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => New_Occurrence_Of (E, Loc)),\n+                       Make_Pragma_Argument_Association (Sloc (Expr),\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Chars (Id));\n \n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Chars (Id)));\n+               --  Synchronization\n \n-               --  The aspect corresponds to pragma Implemented. Construct the\n-               --  pragma.\n+               --  Corresponds to pragma Implemented, construct the pragma\n \n                when Aspect_Synchronization =>\n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Argument_Associations => New_List (\n-                        Make_Pragma_Argument_Association (Loc,\n-                          Expression => New_Occurrence_Of (E, Loc)),\n-\n-                        Make_Pragma_Argument_Association (Sloc (Expr),\n-                          Expression => Relocate_Node (Expr))),\n \n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Implemented));\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => New_Occurrence_Of (E, Loc)),\n+                       Make_Pragma_Argument_Association (Sloc (Expr),\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Implemented);\n \n                   --  No delay is required since the only values are: By_Entry\n                   --  | By_Protected_Procedure | By_Any | Optional which don't\n                   --  get analyzed anyway.\n \n                   Delay_Required := False;\n \n+               --  Attach Handler\n+\n                when Aspect_Attach_Handler =>\n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Attach_Handler),\n-                          Pragma_Argument_Associations => New_List (\n-                            Make_Pragma_Argument_Association (Sloc (Ent),\n-                              Expression => Ent),\n-                            Make_Pragma_Argument_Association (Sloc (Expr),\n-                              Expression => Relocate_Node (Expr))));\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Sloc (Ent),\n+                         Expression => Ent),\n+                       Make_Pragma_Argument_Association (Sloc (Expr),\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Attach_Handler);\n+\n+               --  Dynamic_Predicate, Predicate, Static_Predicate\n \n                when Aspect_Dynamic_Predicate |\n                     Aspect_Predicate         |\n@@ -1274,16 +1319,13 @@ package body Sem_Ch13 is\n                   --  flags recording whether it is static/dynamic). We also\n                   --  set flags recording this in the type itself.\n \n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Argument_Associations => New_List (\n-                         Make_Pragma_Argument_Association (Sloc (Ent),\n-                           Expression => Ent),\n-                         Make_Pragma_Argument_Association (Sloc (Expr),\n-                           Expression => Relocate_Node (Expr))),\n-                      Class_Present                => Class_Present (Aspect),\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Predicate));\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Sloc (Ent),\n+                         Expression => Ent),\n+                       Make_Pragma_Argument_Association (Sloc (Expr),\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Predicate);\n \n                   --  Mark type has predicates, and remember what kind of\n                   --  aspect lead to this predicate (we need this to access\n@@ -1301,9 +1343,7 @@ package body Sem_Ch13 is\n                   --  has a freeze node, because that is the one that will be\n                   --  visible at freeze time.\n \n-                  if Is_Private_Type (E)\n-                    and then Present (Full_View (E))\n-                  then\n+                  if Is_Private_Type (E) and then Present (Full_View (E)) then\n                      Set_Has_Predicates (Full_View (E));\n \n                      if A_Id = Aspect_Dynamic_Predicate then\n@@ -1321,6 +1361,8 @@ package body Sem_Ch13 is\n                --  referring to the entity, and the first argument is the\n                --  aspect definition expression.\n \n+               --  Convention\n+\n                when Aspect_Convention  =>\n \n                   --  The aspect may be part of the specification of an import\n@@ -1387,30 +1429,28 @@ package body Sem_Ch13 is\n                         Append_To (Arg_List, E_Assoc);\n                      end if;\n \n-                     Aitem :=\n-                       Make_Pragma (Loc,\n-                         Pragma_Argument_Associations => Arg_List,\n-                         Pragma_Identifier            =>\n-                            Make_Identifier (Loc, P_Name));\n+                     Make_Aitem_Pragma\n+                       (Pragma_Argument_Associations => Arg_List,\n+                        Pragma_Name                  => P_Name);\n                   end;\n \n-               --  The following three aspects can be specified for a\n-               --  subprogram body, in which case we generate pragmas for them\n-               --  and insert them ahead of local declarations, rather than\n-               --  after the body.\n+               --  CPU, Interrupt_Priority, Priority\n+\n+               --  These three aspects can be specified for a subprogram body,\n+               --  in which case we generate pragmas for them and insert them\n+               --  ahead of local declarations, rather than after the body.\n \n                when Aspect_CPU                |\n                     Aspect_Interrupt_Priority |\n                     Aspect_Priority           =>\n \n                   if Nkind (N) = N_Subprogram_Body then\n-                     Aitem :=\n-                       Make_Pragma (Loc,\n-                         Pragma_Argument_Associations => New_List (\n-                           Make_Pragma_Argument_Association (Sloc (Expr),\n-                             Expression => Relocate_Node (Expr))),\n-                         Pragma_Identifier            =>\n-                           Make_Identifier (Sloc (Id), Chars (Id)));\n+                     Make_Aitem_Pragma\n+                       (Pragma_Argument_Associations => New_List (\n+                          Make_Pragma_Argument_Association (Sloc (Expr),\n+                            Expression => Relocate_Node (Expr))),\n+                        Pragma_Name                  => Chars (Id));\n+\n                   else\n                      Aitem :=\n                        Make_Attribute_Definition_Clause (Loc,\n@@ -1419,17 +1459,17 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr));\n                   end if;\n \n+               --  Warnings\n+\n                when Aspect_Warnings =>\n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Argument_Associations => New_List (\n-                        Make_Pragma_Argument_Association (Sloc (Expr),\n-                          Expression => Relocate_Node (Expr)),\n-                        Make_Pragma_Argument_Association (Loc,\n-                          Expression => New_Occurrence_Of (E, Loc))),\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Chars (Id)),\n-                      Class_Present                => Class_Present (Aspect));\n+\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Sloc (Expr),\n+                         Expression => Relocate_Node (Expr)),\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => New_Occurrence_Of (E, Loc))),\n+                     Pragma_Name                  => Chars (Id));\n \n                   --  We don't have to play the delay game here, since the only\n                   --  values are ON/OFF which don't get analyzed anyway.\n@@ -1443,23 +1483,22 @@ package body Sem_Ch13 is\n                --  entity, a second argument that is the expression and a third\n                --  argument that is an appropriate message.\n \n+               --  Invariant, Type_Invariant\n+\n                when Aspect_Invariant      |\n                     Aspect_Type_Invariant =>\n \n                   --  Analysis of the pragma will verify placement legality:\n                   --  an invariant must apply to a private type, or appear in\n                   --  the private part of a spec and apply to a completion.\n \n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Argument_Associations => New_List (\n-                        Make_Pragma_Argument_Association (Sloc (Ent),\n-                          Expression => Ent),\n-                        Make_Pragma_Argument_Association (Sloc (Expr),\n-                          Expression => Relocate_Node (Expr))),\n-                      Class_Present                => Class_Present (Aspect),\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Invariant));\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Sloc (Ent),\n+                         Expression => Ent),\n+                       Make_Pragma_Argument_Association (Sloc (Expr),\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Invariant);\n \n                   --  Add message unless exception messages are suppressed\n \n@@ -1482,50 +1521,49 @@ package body Sem_Ch13 is\n                --  Case 2d : Aspects that correspond to a pragma with one\n                --  argument.\n \n-               when Aspect_Abstract_State =>\n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Abstract_State),\n-                      Pragma_Argument_Associations => New_List (\n-                        Make_Pragma_Argument_Association (Loc,\n-                          Expression => Relocate_Node (Expr))));\n+               --  Abstract_State\n \n+               when Aspect_Abstract_State =>\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Abstract_State);\n                   Delay_Required := False;\n \n+               --  Depends\n+\n                --  Aspect Depends must be delayed because it mentions names\n                --  of inputs and output that are classified by aspect Global.\n \n                when Aspect_Depends =>\n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Depends),\n-                      Pragma_Argument_Associations => New_List (\n-                        Make_Pragma_Argument_Association (Loc,\n-                          Expression => Relocate_Node (Expr))));\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Depends);\n+\n+               --  Global\n \n                --  Aspect Global must be delayed because it can mention names\n                --  and benefit from the forward visibility rules applicable to\n                --  aspects of subprograms.\n \n                when Aspect_Global =>\n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Global),\n-                      Pragma_Argument_Associations => New_List (\n-                        Make_Pragma_Argument_Association (Loc,\n-                          Expression => Relocate_Node (Expr))));\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Global);\n+\n+               --  Relative_Deadline\n \n                when Aspect_Relative_Deadline =>\n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Argument_Associations => New_List (\n-                        Make_Pragma_Argument_Association (Loc,\n-                          Expression => Relocate_Node (Expr))),\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Relative_Deadline));\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                      Pragma_Name                 => Name_Relative_Deadline);\n \n                   --  If the aspect applies to a task, the corresponding pragma\n                   --  must appear within its declarations, not after.\n@@ -1562,13 +1600,17 @@ package body Sem_Ch13 is\n                --  Case 3a: The aspects listed below don't correspond to\n                --  pragmas/attributes but do require delayed analysis.\n \n+               --  Default_Value, Default_Component_Value\n+\n                when Aspect_Default_Value           |\n                     Aspect_Default_Component_Value =>\n                   Aitem := Empty;\n \n                --  Case 3b: The aspects listed below don't correspond to\n                --  pragmas/attributes and don't need delayed analysis.\n \n+               --  Implicit_Dereference\n+\n                --  For Implicit_Dereference, External_Name and Link_Name, only\n                --  the legality checks are done during the analysis, thus no\n                --  delay is required.\n@@ -1577,15 +1619,21 @@ package body Sem_Ch13 is\n                   Analyze_Aspect_Implicit_Dereference;\n                   goto Continue;\n \n+               --  External_Name, Link_Name\n+\n                when Aspect_External_Name |\n                     Aspect_Link_Name     =>\n                   Analyze_Aspect_External_Or_Link_Name;\n                   goto Continue;\n \n+               --  Dimension\n+\n                when Aspect_Dimension =>\n                   Analyze_Aspect_Dimension (N, Id, Expr);\n                   goto Continue;\n \n+               --  Dimension_System\n+\n                when Aspect_Dimension_System =>\n                   Analyze_Aspect_Dimension_System (N, Id, Expr);\n                   goto Continue;\n@@ -1595,6 +1643,8 @@ package body Sem_Ch13 is\n                --  Pre/Post/Test_Case/Contract_Cases whose corresponding\n                --  pragmas take care of the delay.\n \n+               --  Pre/Post\n+\n                --  Aspects Pre/Post generate Precondition/Postcondition pragmas\n                --  with a first argument that is the expression, and a second\n                --  argument that is an informative message if the test fails.\n@@ -1648,16 +1698,12 @@ package body Sem_Ch13 is\n \n                   --  Build the precondition/postcondition pragma\n \n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Pname),\n-                      Class_Present                => Class_Present (Aspect),\n-                      Split_PPC                    => Split_PPC (Aspect),\n-                      Pragma_Argument_Associations => New_List (\n-                        Make_Pragma_Argument_Association (Eloc,\n-                          Chars      => Name_Check,\n-                          Expression => Relocate_Node (Expr))));\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Eloc,\n+                         Chars      => Name_Check,\n+                         Expression => Relocate_Node (Expr))),\n+                       Pragma_Name                => Pname);\n \n                   --  Add message unless exception messages are suppressed\n \n@@ -1726,6 +1772,8 @@ package body Sem_Ch13 is\n                   goto Continue;\n                end;\n \n+               --  Test_Case\n+\n                when Aspect_Test_Case => Test_Case : declare\n                   Args      : List_Id;\n                   Comp_Expr : Node_Id;\n@@ -1786,15 +1834,15 @@ package body Sem_Ch13 is\n \n                   --  Build the test-case pragma\n \n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Nam),\n-                      Pragma_Argument_Associations => Args);\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => Args,\n+                     Pragma_Name                  => Nam);\n \n                   Delay_Required := False;\n                end Test_Case;\n \n+               --  Contract_Cases\n+\n                when Aspect_Contract_Cases => Contract_Cases : declare\n                   Case_Guard  : Node_Id;\n                   Extra       : Node_Id;\n@@ -1860,13 +1908,11 @@ package body Sem_Ch13 is\n \n                   --  Transform the aspect into a pragma\n \n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Loc, Nam),\n-                      Pragma_Argument_Associations => New_List (\n-                        Make_Pragma_Argument_Association (Loc,\n-                          Expression => Relocate_Node (Expr))));\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Nam);\n \n                   Delay_Required := False;\n                end Contract_Cases;\n@@ -1875,8 +1921,10 @@ package body Sem_Ch13 is\n                --  boolean argument.\n \n                --  In the general case, the corresponding pragma cannot be\n-               --  generated yet because the evaluation of the boolean needs to\n-               --  be delayed til the freeze point.\n+               --  generated yet because the evaluation of the boolean needs\n+               --  to be delayed till the freeze point.\n+\n+               --  Boolwn_Aspects\n \n                when Boolean_Aspects      |\n                     Library_Unit_Aspects =>\n@@ -1954,13 +2002,11 @@ package body Sem_Ch13 is\n                   --  simply insert the pragma, no delay is required.\n \n                   if No (Expr) then\n-                     Aitem :=\n-                       Make_Pragma (Loc,\n-                         Pragma_Argument_Associations => New_List (\n-                           Make_Pragma_Argument_Association (Sloc (Ent),\n-                             Expression => Ent)),\n-                         Pragma_Identifier            =>\n-                           Make_Identifier (Sloc (Id), Chars (Id)));\n+                     Make_Aitem_Pragma\n+                       (Pragma_Argument_Associations => New_List (\n+                          Make_Pragma_Argument_Association (Sloc (Ent),\n+                            Expression => Ent)),\n+                        Pragma_Name                  => Chars (Id));\n \n                      Delay_Required := False;\n \n@@ -1979,8 +2025,16 @@ package body Sem_Ch13 is\n             if Present (Aitem) then\n                Set_From_Aspect_Specification (Aitem, True);\n \n+               --  For a pragma, keep pointer to aspect\n+\n                if Nkind (Aitem) = N_Pragma then\n                   Set_Corresponding_Aspect (Aitem, Aspect);\n+\n+                  --  Also set Is_Ignored flag. No need to set Is_Disabled.\n+                  --  We checked that right away, and would not get here.\n+\n+                  Set_Is_Ignored (Aitem, Is_Ignored (Aspect));\n+                  pragma Assert (not Is_Disabled (Aspect));\n                end if;\n             end if;\n \n@@ -2000,9 +2054,9 @@ package body Sem_Ch13 is\n                goto Continue;\n \n             --  In the context of a compilation unit, we directly put the\n-            --  pragma in the Pragmas_After list of the\n-            --  N_Compilation_Unit_Aux node (no delay is required here)\n-            --  except for aspects on a subprogram body (see below).\n+            --  pragma in the Pragmas_After list of the N_Compilation_Unit_Aux\n+            --  node (no delay is required here) except for aspects on a\n+            --  subprogram body (see below).\n \n             elsif Nkind (Parent (N)) = N_Compilation_Unit\n               and then (Present (Aitem) or else Is_Boolean_Aspect (Aspect))\n@@ -2018,13 +2072,11 @@ package body Sem_Ch13 is\n \n                   if Is_Boolean_Aspect (Aspect) and then No (Aitem) then\n                      if Is_True (Static_Boolean (Expr)) then\n-                        Aitem :=\n-                          Make_Pragma (Loc,\n-                            Pragma_Argument_Associations => New_List (\n-                              Make_Pragma_Argument_Association (Sloc (Ent),\n-                                Expression => Ent)),\n-                            Pragma_Identifier            =>\n-                              Make_Identifier (Sloc (Id), Chars (Id)));\n+                        Make_Aitem_Pragma\n+                          (Pragma_Argument_Associations => New_List (\n+                             Make_Pragma_Argument_Association (Sloc (Ent),\n+                               Expression => Ent)),\n+                           Pragma_Name                  => Chars (Id));\n \n                         Set_From_Aspect_Specification (Aitem, True);\n                         Set_Corresponding_Aspect (Aitem, Aspect);\n@@ -2097,7 +2149,7 @@ package body Sem_Ch13 is\n                Insert_After (Ins_Node, Aitem);\n                Ins_Node := Aitem;\n             end if;\n-         end;\n+         end Analyze_One_Aspect;\n \n       <<Continue>>\n          Next (Aspect);"}, {"sha": "43f94e11b0e21536520980c3b7c0d5988fea2c5d", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=9d5598bf839e572e6262367af623d1e1af91c4a6", "patch": "@@ -12082,16 +12082,12 @@ package body Sem_Ch6 is\n \n                      declare\n                         New_Expr : constant Node_Id :=\n-                                     Get_Pragma_Arg\n-                                       (Next\n-                                         (First\n-                                           (Pragma_Argument_Associations\n-                                             (Inherited_Precond))));\n+                          Get_Pragma_Arg\n+                            (Next (First (Pragma_Argument_Associations\n+                                            (Inherited_Precond))));\n                         Old_Expr : constant Node_Id :=\n-                                     Get_Pragma_Arg\n-                                       (Next\n-                                         (First\n-                                           (Pragma_Argument_Associations\n+                          Get_Pragma_Arg\n+                            (Next (First (Pragma_Argument_Associations\n                                              (Precond))));\n \n                      begin\n@@ -12404,8 +12400,7 @@ package body Sem_Ch6 is\n \n          declare\n             Post_Proc : constant Entity_Id :=\n-                          Make_Defining_Identifier (Loc,\n-                            Chars => Name_uPostconditions);\n+              Make_Defining_Identifier (Loc, Chars => Name_uPostconditions);\n             --  The entity for the _Postconditions procedure\n \n          begin"}, {"sha": "bacb34066157b8361fea7ffd328abfdbba9a580a", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5598bf839e572e6262367af623d1e1af91c4a6/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=9d5598bf839e572e6262367af623d1e1af91c4a6", "patch": "@@ -2138,12 +2138,7 @@ package body Sem_Prag is\n          --  For a pragma PPC in the extended main source unit, record enabled\n          --  status in SCO.\n \n-         --  This may seem redundant with the call to Check_Kind test that\n-         --  occurs later on when the pragma is rewritten into a pragma Check\n-         --  but is actually required in the case of a postcondition within a\n-         --  generic.\n-\n-         if Check_Kind (Pname) = Name_Check and then not Split_PPC (N) then\n+         if not Is_Ignored (N) and then not Split_PPC (N) then\n             Set_SCO_Pragma_Enabled (Loc);\n          end if;\n \n@@ -6775,14 +6770,20 @@ package body Sem_Prag is\n          Pname := Chars (Identifier (Corresponding_Aspect (N)));\n       end if;\n \n-      Check_Applicable_Policy (N);\n+      --  Check applicable policy. We skip this for a pragma that came from\n+      --  an aspect, since we already dealt with the Disable case, and we set\n+      --  the Is_Ignored flag at the time the aspect was analyzed.\n \n-      --  If pragma is disabled, rewrite as Null statement and skip analysis\n+      if not From_Aspect_Specification (N) then\n+         Check_Applicable_Policy (N);\n \n-      if Is_Disabled (N) then\n-         Rewrite (N, Make_Null_Statement (Loc));\n-         Analyze (N);\n-         raise Pragma_Exit;\n+         --  If pragma is disabled, rewrite as NULL and skip analysis\n+\n+         if Is_Disabled (N) then\n+            Rewrite (N, Make_Null_Statement (Loc));\n+            Analyze (N);\n+            raise Pragma_Exit;\n+         end if;\n       end if;\n \n       --  Preset arguments\n@@ -8109,26 +8110,37 @@ package body Sem_Prag is\n \n             --  Set Check_On to indicate check status\n \n-            case Check_Kind (Cname) is\n-               when Name_Ignore =>\n-                  Check_On := False;\n+            --  If this comes from an aspect, we have already taken care of\n+            --  the policy active when the aspect was analyzed, and Is_Ignore\n+            --  is set appriately already.\n \n-               when Name_Check =>\n-                  Check_On := True;\n+            if From_Aspect_Specification (N) then\n+               Check_On := not Is_Ignored (N);\n \n-               --  For disable, rewrite pragma as null statement and skip\n-               --  rest of the analysis of the pragma.\n+            --  Otherwise check the status right now\n \n-               when Name_Disable =>\n-                  Rewrite (N, Make_Null_Statement (Loc));\n-                  Analyze (N);\n-                  raise Pragma_Exit;\n+            else\n+               case Check_Kind (Cname) is\n+                  when Name_Ignore =>\n+                     Check_On := False;\n \n-               --  No other possibilities\n+                  when Name_Check =>\n+                     Check_On := True;\n \n-               when others =>\n-                  raise Program_Error;\n-            end case;\n+                  --  For disable, rewrite pragma as null statement and skip\n+                  --  rest of the analysis of the pragma.\n+\n+                  when Name_Disable =>\n+                     Rewrite (N, Make_Null_Statement (Loc));\n+                     Analyze (N);\n+                     raise Pragma_Exit;\n+\n+                     --  No other possibilities\n+\n+                  when others =>\n+                     raise Program_Error;\n+               end case;\n+            end if;\n \n             --  If check kind was not Disable, then continue pragma analysis\n "}]}