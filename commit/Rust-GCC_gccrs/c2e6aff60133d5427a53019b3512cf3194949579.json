{"sha": "c2e6aff60133d5427a53019b3512cf3194949579", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJlNmFmZjYwMTMzZDU0MjdhNTMwMTliMzUxMmNmMzE5NDk0OTU3OQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-25T18:14:35Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-25T18:14:35Z"}, "message": "(store_expr): If TARGET is volatile mem ref, return it.\n\nFrom-SVN: r4730", "tree": {"sha": "c8ef97312aba4815b2ea8696c3e6be399ac9e3cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8ef97312aba4815b2ea8696c3e6be399ac9e3cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2e6aff60133d5427a53019b3512cf3194949579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2e6aff60133d5427a53019b3512cf3194949579", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2e6aff60133d5427a53019b3512cf3194949579", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2e6aff60133d5427a53019b3512cf3194949579/comments", "author": null, "committer": null, "parents": [{"sha": "c7daad388b54749c33fcbc32076d09281381a68e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7daad388b54749c33fcbc32076d09281381a68e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7daad388b54749c33fcbc32076d09281381a68e"}], "stats": {"total": 15, "additions": 11, "deletions": 4}, "files": [{"sha": "144eb637f2e8db05e69c99b3e30100a5a4aa08c7", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e6aff60133d5427a53019b3512cf3194949579/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e6aff60133d5427a53019b3512cf3194949579/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c2e6aff60133d5427a53019b3512cf3194949579", "patch": "@@ -2312,12 +2312,14 @@ store_expr (exp, target, suggest_reg)\n       OK_DEFER_POP;\n       return target;\n     }\n-  else if (suggest_reg && GET_CODE (target) == MEM\n+  else if (suggest_reg && GET_CODE (target) == MEM && ! MEM_VOLATILE_P (target)\n \t   && GET_MODE (target) != BLKmode)\n     /* If target is in memory and caller wants value in a register instead,\n        arrange that.  Pass TARGET as target for expand_expr so that,\n        if EXP is another assignment, SUGGEST_REG will be nonzero for it.\n-       We know expand_expr will not use the target in that case.  */\n+       We know expand_expr will not use the target in that case.\n+       Don't do this if TARGET is volatile because we are supposed\n+       to write it and then read it.  */\n     {\n       temp = expand_expr (exp, cse_not_expected ? NULL_RTX : target,\n \t\t\t  GET_MODE (target), 0);\n@@ -2332,6 +2334,9 @@ store_expr (exp, target, suggest_reg)\n        So copy the value through a temporary and use that temp\n        as the result.  */\n     {\n+      /* ??? There may be a bug here in the case of a target\n+\t that is volatile, but I' too sleepy today to write anything\n+\t to handle it.  */\n       if (GET_MODE (target) != BLKmode && GET_MODE (target) != VOIDmode)\n \t{\n \t  /* Expand EXP into a new pseudo.  */\n@@ -2357,10 +2362,12 @@ store_expr (exp, target, suggest_reg)\n     {\n       temp = expand_expr (exp, target, GET_MODE (target), 0);\n       /* DO return TARGET if it's a specified hardware register.\n-\t expand_return relies on this.  */\n+\t expand_return relies on this.\n+\t DO return TARGET if it's a volatile mem ref; ANSI requires this.  */\n       if (!(target && GET_CODE (target) == REG\n \t    && REGNO (target) < FIRST_PSEUDO_REGISTER)\n-\t  && CONSTANT_P (temp))\n+\t  && CONSTANT_P (temp)\n+\t  && !(GET_CODE (target) == MEM && MEM_VOLATILE_P (target)))\n \tdont_return_target = 1;\n     }\n "}]}