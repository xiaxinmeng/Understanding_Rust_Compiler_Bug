{"sha": "d22c85969b4555d97d16a2f6704bf57b7d712cd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDIyYzg1OTY5YjQ1NTVkOTdkMTZhMmY2NzA0YmY1N2I3ZDcxMmNkMw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-10-11T20:19:33Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-10-11T20:19:33Z"}, "message": "89th Cygnus<->FSF quick merge\n\nFrom-SVN: r12953", "tree": {"sha": "831fede3889f6c6924b3d0336991173527a83689", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/831fede3889f6c6924b3d0336991173527a83689"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d22c85969b4555d97d16a2f6704bf57b7d712cd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d22c85969b4555d97d16a2f6704bf57b7d712cd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d22c85969b4555d97d16a2f6704bf57b7d712cd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d22c85969b4555d97d16a2f6704bf57b7d712cd3/comments", "author": null, "committer": null, "parents": [{"sha": "3d4683cb70b1f1f075e7d2c1f865de215f25679d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d4683cb70b1f1f075e7d2c1f865de215f25679d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d4683cb70b1f1f075e7d2c1f865de215f25679d"}], "stats": {"total": 552, "additions": 167, "deletions": 385}, "files": [{"sha": "5aca192b9b923a00c09d0c6b22b93f06c1e82dfc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 19, "deletions": 86, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d22c85969b4555d97d16a2f6704bf57b7d712cd3", "patch": "@@ -562,7 +562,7 @@ struct binding_level\n \n     /* List of VAR_DECLS saved from a previous for statement.\n        These would be dead in ANSI-conforming code, but might\n-       be referenced in traditional code.  */\n+       be referenced in ARM-era code.  */\n     tree dead_vars_from_for;\n \n     /* 1 for the level that holds the parameters of a function.\n@@ -591,7 +591,7 @@ struct binding_level\n     unsigned namespace_p : 1;\n \n     /* True if this level is that of a for-statement where we need to\n-       worry about ambiguous (traditional or ANSI) scope rules.  */\n+       worry about ambiguous (ARM or ANSI) scope rules.  */\n     unsigned is_for_scope : 1;\n \n     /* Two bits left for this word.  */\n@@ -2067,16 +2067,6 @@ pushtag (name, type, globalize)\n \t\t  newdecl = 1;\n \t\t  d = build_decl (TYPE_DECL, name, type);\n \t\t  SET_DECL_ARTIFICIAL (d);\n-#ifdef DWARF_DEBUGGING_INFO\n-\t\t  if (write_symbols == DWARF_DEBUG)\n-\t\t    {\n-\t\t      /* Mark the TYPE_DECL node we created just above as an\n-\t\t\t gratuitous one.  We need to do this so that dwarfout.c\n-\t\t\t will understand that it is not supposed to output a\n-\t\t\t TAG_typedef DIE  for it.  */\n-\t\t      DECL_IGNORED_P (d) = 1;\n-\t\t    }\n-#endif /* DWARF_DEBUGGING_INFO */\n \t\t  set_identifier_type_value_with_scope (name, type, b);\n \t\t}\n \t      else\n@@ -2103,17 +2093,6 @@ pushtag (name, type, globalize)\n \t      newdecl = 1;\n \t      d = build_decl (TYPE_DECL, name, type);\n \t      SET_DECL_ARTIFICIAL (d);\n-#ifdef DWARF_DEBUGGING_INFO\n-\t      if (write_symbols == DWARF_DEBUG)\n-\t\t{\n-\t\t  /* Mark the TYPE_DECL node we created just above as an\n-\t\t     gratuitous one.  We need to do this so that dwarfout.c\n-\t\t     will understand that it is not supposed to output a\n-\t\t     TAG_typedef DIE  for it.  */\n-\t\t  DECL_IGNORED_P (d) = 1;\n-\t\t}\n-#endif /* DWARF_DEBUGGING_INFO */\n-\n \t      TYPE_MAIN_DECL (type) = d;\n \t      DECL_CONTEXT (d) = context;\n \t      if (! globalize && processing_template_decl && IS_AGGR_TYPE (type))\n@@ -2334,9 +2313,6 @@ decls_match (newdecl, olddecl)\n    Note that this does not apply to the C++ case of declaring\n    a variable `extern const' and then later `const'.\n \n-   Don't complain if -traditional, since traditional compilers\n-   don't complain.\n-\n    Don't complain about built-in functions, since they are beyond\n    the user's control.  */\n \n@@ -2351,8 +2327,7 @@ warn_extern_redeclared_static (newdecl, olddecl)\n   static char *implicit_extern_static_warning\n     = \"`%D' was declared implicitly `extern' and later `static'\";\n \n-  if (flag_traditional\n-      || TREE_CODE (newdecl) == TYPE_DECL)\n+  if (TREE_CODE (newdecl) == TYPE_DECL)\n     return;\n \n   name = DECL_ASSEMBLER_NAME (newdecl);\n@@ -2413,14 +2388,9 @@ duplicate_decls (newdecl, olddecl)\n \t  && TREE_CODE (TREE_TYPE (olddecl)) == ERROR_MARK))\n     types_match = 1;\n \n-  if (flag_traditional && TREE_CODE (newdecl) == FUNCTION_DECL\n-      && IDENTIFIER_IMPLICIT_DECL (DECL_ASSEMBLER_NAME (newdecl)) == olddecl)\n-    /* If -traditional, avoid error for redeclaring fcn\n-       after implicit decl.  */\n-    ;\n-  else if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t   && DECL_ARTIFICIAL (olddecl)\n-\t   && (DECL_BUILT_IN (olddecl) || DECL_BUILT_IN_NONANSI (olddecl)))\n+  if (TREE_CODE (olddecl) == FUNCTION_DECL\n+      && DECL_ARTIFICIAL (olddecl)\n+      && (DECL_BUILT_IN (olddecl) || DECL_BUILT_IN_NONANSI (olddecl)))\n     {\n       /* If you declare a built-in or predefined function name as static,\n \t the old definition is overridden, but optionally warn this was a\n@@ -2917,13 +2887,17 @@ duplicate_decls (newdecl, olddecl)\n \n \t  obstack_free (&permanent_obstack, newdecl);\n \t}\n-      else if (LANG_DECL_PERMANENT (ol))\n+      else if (LANG_DECL_PERMANENT (ol) && ol != nl)\n \t{\n \t  if (DECL_MAIN_VARIANT (olddecl) == olddecl)\n \t    {\n \t      /* Save these lang_decls that would otherwise be lost.  */\n \t      extern tree free_lang_decl_chain;\n \t      tree free_lang_decl = (tree) ol;\n+\n+\t      if (DECL_LANG_SPECIFIC (olddecl) == ol)\n+\t\tabort ();\n+\n \t      TREE_CHAIN (free_lang_decl) = free_lang_decl_chain;\n \t      free_lang_decl_chain = free_lang_decl;\n \t    }\n@@ -3160,12 +3134,6 @@ pushdecl (x)\n \t    }\n \t}\n \n-      /* In PCC-compatibility mode, extern decls of vars with no current decl\n-\t take effect at top level no matter where they are.  */\n-      if (flag_traditional && DECL_EXTERNAL (x)\n-\t  && lookup_name (name, 0) == NULL_TREE)\n-\tb = global_binding_level;\n-\n       /* This name is new in its binding level.\n \t Install the new declaration and return it.  */\n       if (b == global_binding_level)\n@@ -3625,7 +3593,7 @@ implicitly_declare (functionid)\n   /* Save the decl permanently so we can warn if definition follows.\n      In ANSI C, warn_implicit is usually false, so the saves little space.\n      But in C++, it's usually true, hence the extra code.  */\n-  if (temp && (flag_traditional || !warn_implicit || toplevel_bindings_p ()))\n+  if (temp && (! warn_implicit || toplevel_bindings_p ()))\n     end_temporary_allocation ();\n \n   /* We used to reuse an old implicit decl here,\n@@ -3637,8 +3605,7 @@ implicitly_declare (functionid)\n   TREE_PUBLIC (decl) = 1;\n \n   /* ANSI standard says implicit declarations are in the innermost block.\n-     So we record the decl in the standard fashion.\n-     If flag_traditional is set, pushdecl does it top-level.  */\n+     So we record the decl in the standard fashion.  */\n   pushdecl (decl);\n   rest_of_decl_compilation (decl, NULL_PTR, 0, 0);\n \n@@ -4695,8 +4662,6 @@ init_decl_processing ()\n   tree decl;\n   register tree endlink, int_endlink, double_endlink;\n   tree fields[20];\n-  /* Either char* or void*.  */\n-  tree traditional_ptr_type_node;\n   /* Data type of memcpy.  */\n   tree memcpy_ftype, strlen_ftype;\n   int wchar_type_size;\n@@ -4819,13 +4784,10 @@ init_decl_processing ()\n   record_builtin_type (RID_MAX, \"unsigned short\", short_unsigned_type_node);\n \n   /* `unsigned long' is the standard type for sizeof.\n-     Traditionally, use a signed type.\n      Note that stddef.h uses `unsigned long',\n      and this must agree, even of long and int are the same size.  */\n   sizetype\n     = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (SIZE_TYPE)));\n-  if (flag_traditional && TREE_UNSIGNED (sizetype))\n-    sizetype = signed_type (sizetype);\n \n   ptrdiff_type_node\n     = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (PTRDIFF_TYPE)));\n@@ -5017,11 +4979,8 @@ init_decl_processing ()\n \t\t\t   tree_cons (NULL_TREE, const_string_type_node,\n \t\t\t\t      endlink));\n \n-  traditional_ptr_type_node\n-    = (flag_traditional ? string_type_node : ptr_type_node);\n-\n   memcpy_ftype\t/* memcpy prototype */\n-    = build_function_type (traditional_ptr_type_node,\n+    = build_function_type (ptr_type_node,\n \t\t\t   tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t\t      tree_cons (NULL_TREE, const_ptr_type_node,\n \t\t\t\t\t\t tree_cons (NULL_TREE,\n@@ -6546,8 +6505,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       /* ??? FIXME: What about nested classes?  */\n       int toplev = toplevel_bindings_p () || pseudo_global_level_p ();\n       int was_temp\n-\t= ((flag_traditional\n-\t    || (TREE_STATIC (decl) && TYPE_NEEDS_DESTRUCTOR (type)))\n+\t= (TREE_STATIC (decl) && TYPE_NEEDS_DESTRUCTOR (type)\n \t   && allocation_temporary_p ());\n \n       if (was_temp)\n@@ -6709,7 +6667,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t      /* Check to see if the same name is already bound at\n \t\t the outer level, either because it was directly declared,\n \t\t or because a dead for-decl got preserved.  In either case,\n-\t\t the code would not have been valid under the traditional\n+\t\t the code would not have been valid under the ARM\n \t\t scope rules, so clear is_for_scope for the\n \t\t current_binding_level.\n \n@@ -7507,9 +7465,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   else if (decl_context == BITFIELD)\n     bitfield = 1, decl_context = FIELD;\n \n-  if (flag_traditional && allocation_temporary_p ())\n-    end_temporary_allocation ();\n-\n   /* Look inside a declarator for the name being declared\n      and get it as a string, for an error message.  */\n   {\n@@ -8059,8 +8014,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   /* Decide whether an integer type is signed or not.\n      Optionally treat bitfields as signed by default.  */\n   if (RIDBIT_SETP (RID_UNSIGNED, specbits)\n-      /* Traditionally, all bitfields are unsigned.  */\n-      || (bitfield && flag_traditional)\n       || (bitfield && ! flag_signed_bitfields\n \t  && (explicit_int || explicit_char\n \t      /* A typedef for plain `int' without `signed'\n@@ -8659,16 +8612,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t\t    name);\n \t      }\n \n-\t    /* Traditionally, declaring return type float means double.  */\n-\n-\t    if (flag_traditional\n-\t\t&& TYPE_MAIN_VARIANT (type) == float_type_node)\n-\t      {\n-\t\ttype = build_type_variant (double_type_node,\n-\t\t\t\t\t   TYPE_READONLY (type),\n-\t\t\t\t\t   TYPE_VOLATILE (type));\n-\t      }\n-\n \t    /* Construct the function type and go to the next\n \t       inner layer of declarator.  */\n \n@@ -8700,10 +8643,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  }\n \t      }\n \n-\t    /* ANSI seems to say that `const int foo ();'\n+\t    /* ANSI says that `const int foo ();'\n \t       does not make the function foo const.  */\n-\t    type = build_function_type (type,\n-\t\t\t\t\tflag_traditional ? 0 : arg_types);\n+\t    type = build_function_type (type, arg_types);\n \t  }\n \t  break;\n \n@@ -12030,10 +11972,6 @@ finish_function (lineno, call_poplevel, nested)\n   /* Must mark the RESULT_DECL as being in this function.  */\n   DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;\n \n-  /* Obey `register' declarations if `setjmp' is called in this fn.  */\n-  if (flag_traditional && current_function_calls_setjmp)\n-    setjmp_protect (DECL_INITIAL (fndecl));\n-\n   /* Set the BLOCK_SUPERCONTEXT of the outermost function scope to point\n      to the FUNCTION_DECL node itself.  */\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n@@ -12108,12 +12046,7 @@ finish_function (lineno, call_poplevel, nested)\n       DECL_INITIAL (fndecl) = error_mark_node;\n       /* And we need the arguments for template instantiation.  */\n       if (! processing_template_decl)\n-\t{\n-\t  if (! DECL_CONSTRUCTOR_P (fndecl)\n-\t      || !(TYPE_USES_VIRTUAL_BASECLASSES\n-\t\t   (TYPE_METHOD_BASETYPE (fntype))))\n-\t    DECL_ARGUMENTS (fndecl) = NULL_TREE;\n-\t}\n+\tDECL_ARGUMENTS (fndecl) = NULL_TREE;\n     }\n \n   if (DECL_STATIC_CONSTRUCTOR (fndecl))"}, {"sha": "0775bb2bba09df99de81e65ab5e38d9223d283f3", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d22c85969b4555d97d16a2f6704bf57b7d712cd3", "patch": "@@ -42,6 +42,7 @@ extern tree cleanups_this_call;\n static void grok_function_init PROTO((tree, tree));\n void import_export_decl ();\n extern int current_class_depth;\n+extern int symout_time;\n \n /* A list of virtual function tables we must make sure to write out.  */\n tree pending_vtables;\n@@ -104,7 +105,8 @@ int flag_no_builtin;\n \n int flag_no_nonansi_builtin;\n \n-/* Nonzero means do some things the same way PCC does.  */\n+/* Nonzero means do some things the same way PCC does.  Only provided so\n+   the compiler will link.  */\n \n int flag_traditional;\n \n@@ -184,20 +186,11 @@ int warn_cast_qual;\n \n int warn_template_debugging;\n \n-/* Warn about traditional constructs whose meanings changed in ANSI C.  */\n-\n-int warn_traditional;\n-\n /* Nonzero means warn about sizeof(function) or addition/subtraction\n    of function pointers.  */\n \n int warn_pointer_arith = 1;\n \n-/* Nonzero means warn for non-prototype function decls\n-   or non-prototyped defs without previous prototype.  */\n-\n-int warn_strict_prototypes;\n-\n /* Nonzero means warn for any function def without prototype decl.  */\n \n int warn_missing_prototypes;\n@@ -439,7 +432,7 @@ lang_decode_option (p)\n      char *p;\n {\n   if (!strcmp (p, \"-ftraditional\") || !strcmp (p, \"-traditional\"))\n-    flag_traditional = 1, dollars_in_ident = 1, flag_writable_strings = 1,\n+    dollars_in_ident = 1, flag_writable_strings = 1,\n     flag_this_is_variable = 1, flag_new_for_scope = 0;\n   /* The +e options are for cfront compatibility.  They come in as\n      `-+eN', to kludge around gcc.c's argument handling.  */\n@@ -536,14 +529,10 @@ lang_decode_option (p)\n \twarn_write_strings = setting;\n       else if (!strcmp (p, \"cast-qual\"))\n \twarn_cast_qual = setting;\n-      else if (!strcmp (p, \"traditional\"))\n-\twarn_traditional = setting;\n       else if (!strcmp (p, \"char-subscripts\"))\n \twarn_char_subscripts = setting;\n       else if (!strcmp (p, \"pointer-arith\"))\n \twarn_pointer_arith = setting;\n-      else if (!strcmp (p, \"strict-prototypes\"))\n-\twarn_strict_prototypes = setting;\n       else if (!strcmp (p, \"missing-prototypes\"))\n \twarn_missing_prototypes = setting;\n       else if (!strcmp (p, \"redundant-decls\"))\n@@ -1149,8 +1138,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n     {\n     case 2:\n       maxindex = build_binary_op (MINUS_EXPR, size, integer_one_node, 1);\n-      if (! flag_traditional)\n-\tpedwarn (\"anachronistic use of array size in vector delete\");\n+      pedwarn (\"anachronistic use of array size in vector delete\");\n       /* Fall through.  */\n     case 1:\n       break;\n@@ -2777,6 +2765,13 @@ finish_file ()\n     {\n       tree decl = TREE_VALUE (vars);\n \n+#ifdef DWARF_DEBUGGING_INFO\n+\t/* Output DWARF information for file-scope tentative data object\n+\t   declarations.  */\n+\n+\tif (write_symbols == DWARF_DEBUG)\n+\t  TIMEVAR (symout_time, dwarfout_file_scope_decl (decl, 1));\n+#endif\n       if (DECL_TEMPLATE_INSTANTIATION (decl)\n \t  && ! DECL_IN_AGGR_P (decl))\n \t{"}, {"sha": "6cb2a97abe46d15369d133695340c798c5f6971d", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=d22c85969b4555d97d16a2f6704bf57b7d712cd3", "patch": "@@ -67,7 +67,6 @@ not_eq, EQCOMPARE, NORID,\n operator, OPERATOR, NORID,\n or, OROR, NORID,\n or_eq, ASSIGN, NORID,\n-overload, OVERLOAD, NORID,\n private, VISSPEC, RID_PRIVATE,\n protected, VISSPEC, RID_PROTECTED,\n public, VISSPEC, RID_PUBLIC,"}, {"sha": "d3f6be7330d8fd1f903e621eee5e1b94cf6f34fc", "filename": "gcc/cp/hash.h", "status": "modified", "additions": 97, "deletions": 115, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=d22c85969b4555d97d16a2f6704bf57b7d712cd3", "patch": "@@ -3,12 +3,12 @@\n /* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n struct resword { char *name; short token; enum rid rid;};\n \n-#define TOTAL_KEYWORDS 98\n+#define TOTAL_KEYWORDS 97\n #define MIN_WORD_LENGTH 2\n #define MAX_WORD_LENGTH 16\n #define MIN_HASH_VALUE 4\n-#define MAX_HASH_VALUE 258\n-/* maximum key range = 255, duplicates = 0 */\n+#define MAX_HASH_VALUE 202\n+/* maximum key range = 199, duplicates = 0 */\n \n #ifdef __GNUC__\n inline\n@@ -18,21 +18,21 @@ hash (str, len)\n      register char *str;\n      register int unsigned len;\n {\n-  static unsigned short asso_values[] =\n+  static unsigned char asso_values[] =\n     {\n-     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n-     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n-     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n-     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n-     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n-     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n-     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n-     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n-     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n-     259, 259, 259, 259, 259,   0, 259,  27,  17,  20,\n-      40,   0,  64,   6,  10,  89, 259,   2, 110,  44,\n-      13, 107,  40,  10,  18,  55,   1,   3,   5,  17,\n-       2,   4, 259, 259, 259, 259, 259, 259,\n+     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n+     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n+     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n+     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n+     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n+     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n+     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n+     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n+     203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n+     203, 203, 203, 203, 203,   0, 203,  29,  22,  32,\n+      35,   0,  73,   8,  19,  48, 203,   0,   7,  15,\n+      11,  66,   9,  11,  19,  58,   1,   7,  83,  21,\n+      89,   5, 203, 203, 203, 203, 203, 203,\n     };\n   register int hval = len;\n \n@@ -67,150 +67,132 @@ is_reserved_word (str, len)\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"else\",  ELSE, NORID,},\n       {\"true\",  CXX_TRUE, NORID,},\n-      {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, \n       {\"try\",  TRY, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"not\",  '!', NORID,},\n-      {\"xor_eq\",  ASSIGN, NORID,},\n+      {\"\",}, \n       {\"extern\",  SCSPEC, RID_EXTERN,},\n+      {\"\",}, \n+      {\"template\",  TEMPLATE, RID_TEMPLATE,},\n+      {\"__null\",  CONSTANT, RID_NULL},\n       {\"\",}, {\"\",}, {\"\",}, \n-      {\"xor\",  '^', NORID,},\n-      {\"case\",  CASE, NORID,},\n+      {\"typename\",  TYPENAME_KEYWORD, NORID,},\n       {\"\",}, {\"\",}, \n-      {\"using\",  USING, NORID,},\n-      {\"__extension__\",  EXTENSION, NORID},\n+      {\"long\",  TYPESPEC, RID_LONG,},\n       {\"not_eq\",  EQCOMPARE, NORID,},\n-      {\"\",}, {\"\",}, \n-      {\"continue\",  CONTINUE, NORID,},\n-      {\"new\",  NEW, NORID,},\n+      {\"__alignof__\",  ALIGNOF, NORID},\n       {\"__inline\",  SCSPEC, RID_INLINE},\n-      {\"\",}, \n+      {\"using\",  USING, NORID,},\n       {\"__inline__\",  SCSPEC, RID_INLINE},\n+      {\"while\",  WHILE, NORID,},\n+      {\"enum\",  ENUM, NORID,},\n+      {\"new\",  NEW, NORID,},\n+      {\"case\",  CASE, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, \n-      {\"return\",  RETURN, NORID,},\n-      {\"\",}, {\"\",}, \n-      {\"and_eq\",  ASSIGN, NORID,},\n-      {\"\",}, {\"\",}, \n+      {\"bool\",  TYPESPEC, RID_BOOL,},\n       {\"delete\",  DELETE, NORID,},\n       {\"typeid\",  TYPEID, NORID,},\n-      {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n-      {\"namespace\",  NAMESPACE, NORID,},\n-      {\"template\",  TEMPLATE, RID_TEMPLATE,},\n-      {\"break\",  BREAK, NORID,},\n-      {\"private\",  VISSPEC, RID_PRIVATE,},\n-      {\"typename\",  TYPENAME_KEYWORD, NORID,},\n-      {\"\",}, \n-      {\"catch\",  CATCH, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"char\",  TYPESPEC, RID_CHAR,},\n-      {\"\",}, \n-      {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n-      {\"double\",  TYPESPEC, RID_DOUBLE,},\n-      {\"\",}, \n-      {\"struct\",  AGGR, RID_RECORD,},\n-      {\"reinterpret_cast\",  REINTERPRET_CAST, NORID,},\n-      {\"\",}, \n-      {\"static_cast\",  STATIC_CAST, NORID,},\n-      {\"\",}, \n-      {\"and\",  ANDAND, NORID,},\n-      {\"typeof\",  TYPEOF, NORID,},\n-      {\"switch\",  SWITCH, NORID,},\n+      {\"return\",  RETURN, NORID,},\n       {\"\",}, \n+      {\"__label__\",  LABEL, NORID},\n+      {\"and_eq\",  ASSIGN, NORID,},\n       {\"asm\",  ASM_KEYWORD, NORID,},\n-      {\"\",}, \n-      {\"default\",  DEFAULT, NORID,},\n+      {\"continue\",  CONTINUE, NORID,},\n+      {\"namespace\",  NAMESPACE, NORID,},\n       {\"\",}, \n       {\"mutable\",  SCSPEC, RID_MUTABLE,},\n-      {\"short\",  TYPESPEC, RID_SHORT,},\n-      {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n-      {\"const\",  CV_QUALIFIER, RID_CONST,},\n-      {\"static\",  SCSPEC, RID_STATIC,},\n-      {\"\",}, {\"\",}, \n-      {\"for\",  FOR, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"void\",  TYPESPEC, RID_VOID,},\n-      {\"bitand\",  '&', NORID,},\n-      {\"protected\",  VISSPEC, RID_PROTECTED,},\n-      {\"enum\",  ENUM, NORID,},\n       {\"int\",  TYPESPEC, RID_INT,},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"float\",  TYPESPEC, RID_FLOAT,},\n+      {\"compl\",  '~', NORID,},\n+      {\"public\",  VISSPEC, RID_PUBLIC,},\n+      {\"protected\",  VISSPEC, RID_PROTECTED,},\n+      {\"break\",  BREAK, NORID,},\n       {\"\",}, \n       {\"__signed__\",  TYPESPEC, RID_SIGNED},\n-      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n-      {\"__attribute\",  ATTRIBUTE, NORID},\n       {\"\",}, \n+      {\"__attribute\",  ATTRIBUTE, NORID},\n+      {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n       {\"__attribute__\",  ATTRIBUTE, NORID},\n-      {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n-      {\"\",}, \n-      {\"const_cast\",  CONST_CAST, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"friend\",  SCSPEC, RID_FRIEND,},\n+      {\"double\",  TYPESPEC, RID_DOUBLE,},\n+      {\"explicit\",  SCSPEC, RID_EXPLICIT,},\n+      {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n+      {\"reinterpret_cast\",  REINTERPRET_CAST, NORID,},\n+      {\"and\",  ANDAND, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, \n-      {\"signed\",  TYPESPEC, RID_SIGNED,},\n-      {\"this\",  THIS, NORID,},\n+      {\"static_cast\",  STATIC_CAST, NORID,},\n+      {\"struct\",  AGGR, RID_RECORD,},\n+      {\"default\",  DEFAULT, NORID,},\n+      {\"char\",  TYPESPEC, RID_CHAR,},\n       {\"__const\",  CV_QUALIFIER, RID_CONST},\n       {\"__const__\",  CV_QUALIFIER, RID_CONST},\n       {\"__volatile\",  CV_QUALIFIER, RID_VOLATILE},\n-      {\"__null\",  CONSTANT, RID_NULL},\n+      {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n       {\"__volatile__\",  CV_QUALIFIER, RID_VOLATILE},\n+      {\"typeof\",  TYPEOF, NORID,},\n       {\"__typeof__\",  TYPEOF, NORID},\n       {\"or_eq\",  ASSIGN, NORID,},\n+      {\"short\",  TYPESPEC, RID_SHORT,},\n+      {\"switch\",  SWITCH, NORID,},\n+      {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n       {\"\",}, \n-      {\"false\",  CXX_FALSE, NORID,},\n-      {\"sizeof\",  SIZEOF, NORID,},\n-      {\"long\",  TYPESPEC, RID_LONG,},\n       {\"or\",  OROR, NORID,},\n+      {\"catch\",  CATCH, NORID,},\n       {\"union\",  AGGR, RID_UNION,},\n       {\"__signature__\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"__signed\",  TYPESPEC, RID_SIGNED},\n+      {\"bitand\",  '&', NORID,},\n       {\"throw\",  THROW, NORID,},\n-      {\"\",}, \n-      {\"while\",  WHILE, NORID,},\n       {\"register\",  SCSPEC, RID_REGISTER,},\n-      {\"__alignof__\",  ALIGNOF, NORID},\n-      {\"class\",  AGGR, RID_CLASS,},\n-      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n-      {\"__signed\",  TYPESPEC, RID_SIGNED},\n-      {\"\",}, {\"\",}, \n+      {\"for\",  FOR, NORID,},\n+      {\"const\",  CV_QUALIFIER, RID_CONST,},\n+      {\"static\",  SCSPEC, RID_STATIC,},\n       {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"__label__\",  LABEL, NORID},\n-      {\"bitor\",  '|', NORID,},\n+      {\"private\",  VISSPEC, RID_PRIVATE,},\n+      {\"__alignof\",  ALIGNOF, NORID},\n       {\"\",}, \n+      {\"inline\",  SCSPEC, RID_INLINE,},\n       {\"do\",  DO, NORID,},\n-      {\"volatile\",  CV_QUALIFIER, RID_VOLATILE,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"if\",  IF, NORID,},\n+      {\"\",}, \n+      {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n+      {\"xor_eq\",  ASSIGN, NORID,},\n+      {\"\",}, \n+      {\"float\",  TYPESPEC, RID_FLOAT,},\n+      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n+      {\"signed\",  TYPESPEC, RID_SIGNED,},\n+      {\"xor\",  '^', NORID,},\n+      {\"bitor\",  '|', NORID,},\n+      {\"__extension__\",  EXTENSION, NORID},\n+      {\"friend\",  SCSPEC, RID_FRIEND,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"__sigof__\",  SIGOF, NORID\t\t/* Extension */,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"this\",  THIS, NORID,},\n+      {\"\",}, \n+      {\"if\",  IF, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, \n-      {\"compl\",  '~', NORID,},\n-      {\"public\",  VISSPEC, RID_PUBLIC,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"__typeof\",  TYPEOF, NORID},\n-      {\"inline\",  SCSPEC, RID_INLINE,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"volatile\",  CV_QUALIFIER, RID_VOLATILE,},\n       {\"\",}, {\"\",}, \n-      {\"__alignof\",  ALIGNOF, NORID},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"overload\",  OVERLOAD, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"explicit\",  SCSPEC, RID_EXPLICIT,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"__sigof__\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"\",}, {\"\",}, \n+      {\"const_cast\",  CONST_CAST, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"false\",  CXX_FALSE, NORID,},\n+      {\"sizeof\",  SIZEOF, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"goto\",  GOTO, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n-      {\"\",}, \n-      {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"bool\",  TYPESPEC, RID_BOOL,},\n-      {\"\",}, {\"\",}, {\"\",}, \n+      {\"__typeof\",  TYPEOF, NORID},\n+      {\"class\",  AGGR, RID_CLASS,},\n+      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n+      {\"\",}, {\"\",}, \n+      {\"void\",  TYPESPEC, RID_VOID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"auto\",  SCSPEC, RID_AUTO,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"\",}, {\"\",}, {\"\",}, \n       {\"operator\",  OPERATOR, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)"}, {"sha": "4888981f47b1b653d0369ec34a5c8d967c224243", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 43, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=d22c85969b4555d97d16a2f6704bf57b7d712cd3", "patch": "@@ -821,8 +821,6 @@ init_lex ()\n       UNSET_RESERVED_WORD (\"xor\");\n       UNSET_RESERVED_WORD (\"xor_eq\");\n     }\n-  if (! flag_traditional)\n-    UNSET_RESERVED_WORD (\"overload\");\n \n   token_count = init_parse ();\n   interface_unknown = 1;\n@@ -2339,12 +2337,6 @@ readescape (ignore_ptr)\n   switch (c)\n     {\n     case 'x':\n-      if (warn_traditional)\n-\twarning (\"the meaning of `\\\\x' varies with -traditional\");\n-\n-      if (flag_traditional)\n-\treturn c;\n-\n       code = 0;\n       count = 0;\n       nonnull = 0;\n@@ -2419,11 +2411,6 @@ readescape (ignore_ptr)\n       return TARGET_BS;\n \n     case 'a':\n-      if (warn_traditional)\n-\twarning (\"the meaning of `\\\\a' varies with -traditional\");\n-\n-      if (flag_traditional)\n-\treturn c;\n       return TARGET_BELL;\n \n     case 'v':\n@@ -3527,7 +3514,6 @@ real_yylex ()\n \t    TREE_TYPE (yylval.ttype) = long_long_unsigned_type_node;\n \n \t    if (!spec_long && !spec_unsigned\n-\t\t&& !(flag_traditional && base != 10)\n \t\t&& int_fits_type_p (yylval.ttype, integer_type_node))\n \t      {\n \t\ttype = integer_type_node;\n@@ -3546,12 +3532,7 @@ real_yylex ()\n \t    else if (! spec_long_long\n \t\t     && int_fits_type_p (yylval.ttype,\n \t\t\t\t\t long_unsigned_type_node))\n-\t      {\n-\t\tif (flag_traditional && !spec_unsigned)\n-\t\t  type = long_integer_type_node;\n-\t\telse\n-\t\t  type = long_unsigned_type_node;\n-\t      }\n+\t      type = long_unsigned_type_node;\n \n \t    else if (! spec_unsigned\n \t\t     /* Verify value does not overflow into sign bit.  */\n@@ -3562,12 +3543,7 @@ real_yylex ()\n \n \t    else if (int_fits_type_p (yylval.ttype,\n \t\t\t\t      long_long_unsigned_type_node))\n-\t      {\n-\t\tif (flag_traditional && !spec_unsigned)\n-\t\t  type = long_long_integer_type_node;\n-\t\telse\n-\t\t  type = long_long_unsigned_type_node;\n-\t      }\n+\t      type = long_long_unsigned_type_node;\n \n \t    else\n \t      {\n@@ -3667,7 +3643,7 @@ real_yylex ()\n \t    num_chars = max_chars;\n \t    error (\"character constant too long\");\n \t  }\n-\telse if (num_chars != 1 && ! flag_traditional)\n+\telse if (num_chars != 1)\n \t  warning (\"multi-character character constant\");\n \n \t/* If char type is signed, sign-extend the constant.  */\n@@ -4094,22 +4070,7 @@ build_lang_decl (code, name, type)\n \t  == TREE_PERMANENT  (t), 234);\n   DECL_MAIN_VARIANT (t) = t;\n   if (current_lang_name == lang_name_cplusplus)\n-    {\n-      DECL_LANGUAGE (t) = lang_cplusplus;\n-#if 0\n-#ifndef NO_AUTO_OVERLOAD\n-      if (code == FUNCTION_DECL && name != 0\n-\t  && ! (IDENTIFIER_LENGTH (name) == 4\n-\t\t&& IDENTIFIER_POINTER (name)[0] == 'm'\n-\t\t&& strcmp (IDENTIFIER_POINTER (name), \"main\") == 0)\n-\t  && ! (IDENTIFIER_LENGTH (name) > 10\n-\t\t&& IDENTIFIER_POINTER (name)[0] == '_'\n-\t\t&& IDENTIFIER_POINTER (name)[1] == '_'\n-\t\t&& strncmp (IDENTIFIER_POINTER (name)+2, \"builtin_\", 8) == 0))\n-\tTREE_OVERLOADED (name) = 1;\n-#endif\n-#endif\n-    }\n+    DECL_LANGUAGE (t) = lang_cplusplus;\n   else if (current_lang_name == lang_name_c)\n     DECL_LANGUAGE (t) = lang_c;\n   else my_friendly_abort (64);"}, {"sha": "f032c9b2c22d211ff179703af3ac5657488b3322", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 57, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=d22c85969b4555d97d16a2f6704bf57b7d712cd3", "patch": "@@ -62,10 +62,6 @@ static char *scratch_firstobj;\n # define OB_FINISH() (obstack_1grow (&scratch_obstack, '\\0'))\n # define OB_LAST() (obstack_next_free (&scratch_obstack)[-1])\n \n-#ifdef NO_AUTO_OVERLOAD\n-int is_overloaded ();\n-#endif\n-\n void\n init_method ()\n {\n@@ -1108,56 +1104,6 @@ get_id_2 (name, name2)\n   OB_FINISH ();\n   return get_identifier (obstack_base (&scratch_obstack));\n }\n-\n-/* Top-level interface to explicit overload requests. Allow NAME\n-   to be overloaded. Error if NAME is already declared for the current\n-   scope. Warning if function is redundantly overloaded.  */\n-\n-void\n-declare_overloaded (name)\n-     tree name;\n-{\n-#ifdef NO_AUTO_OVERLOAD\n-  if (is_overloaded (name))\n-    warning (\"function `%s' already declared overloaded\",\n-\t     IDENTIFIER_POINTER (name));\n-  else if (IDENTIFIER_GLOBAL_VALUE (name))\n-    error (\"overloading function `%s' that is already defined\",\n-\t   IDENTIFIER_POINTER (name));\n-  else\n-    {\n-      TREE_OVERLOADED (name) = 1;\n-      IDENTIFIER_GLOBAL_VALUE (name) = build_tree_list (name, NULL_TREE);\n-      TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (name)) = unknown_type_node;\n-    }\n-#else\n-  if (current_lang_name == lang_name_cplusplus)\n-    {\n-      if (0)\n-\twarning (\"functions are implicitly overloaded in C++\");\n-    }\n-  else if (current_lang_name == lang_name_c)\n-    error (\"overloading function `%s' cannot be done in C language context\");\n-  else\n-    my_friendly_abort (76);\n-#endif\n-}\n-\n-#ifdef NO_AUTO_OVERLOAD\n-/* Check to see if NAME is overloaded. For first approximation,\n-   check to see if its TREE_OVERLOADED is set.  This is used on\n-   IDENTIFIER nodes.  */\n-\n-int\n-is_overloaded (name)\n-     tree name;\n-{\n-  /* @@ */\n-  return (TREE_OVERLOADED (name)\n-\t  && (! IDENTIFIER_CLASS_VALUE (name) || current_class_type == 0)\n-\t  && ! IDENTIFIER_LOCAL_VALUE (name));\n-}\n-#endif\n \f\n /* Given a tree_code CODE, and some arguments (at least one),\n    attempt to use an overloaded operator on the arguments.\n@@ -1428,9 +1374,8 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \n \t\t  /* There's probably a LOT of code in the world that\n \t\t     relies upon this old behavior.  */\n-\t\t  if (! flag_traditional)\n-\t\t    pedwarn (\"no `operator%s (int)' declared for postfix `%s', using prefix operator instead\",\n-\t\t\t     op, op);\n+\t\t  pedwarn (\"no `operator%s (int)' declared for postfix `%s', using prefix operator instead\",\n+\t\t\t   op, op);\n \t\t  xarg2 = NULL_TREE;\n \t\t  binary_is_unary = 1;\n \t\t}"}, {"sha": "d29d4a88822b176a48ca7c913384534f77a4776f", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=d22c85969b4555d97d16a2f6704bf57b7d712cd3", "patch": "@@ -144,7 +144,7 @@ empty_parms ()\n /* the reserved words... C++ extensions */\n %token <ttype> AGGR\n %token <ttype> VISSPEC\n-%token DELETE NEW OVERLOAD THIS OPERATOR CXX_TRUE CXX_FALSE\n+%token DELETE NEW THIS OPERATOR CXX_TRUE CXX_FALSE\n %token NAMESPACE TYPENAME_KEYWORD USING\n %token LEFT_RIGHT TEMPLATE\n %token TYPEID DYNAMIC_CAST STATIC_CAST REINTERPRET_CAST CONST_CAST\n@@ -359,7 +359,6 @@ extdef:\n \t\t{ if (pending_inlines) do_pending_inlines (); }\n \t| template_def\n \t\t{ if (pending_inlines) do_pending_inlines (); }\n-\t| overloaddef\n \t| asm_keyword '(' string ')' ';'\n \t\t{ if (TREE_CHAIN ($3)) $3 = combine_strings ($3);\n \t\t  assemble_asm ($3); }\n@@ -469,18 +468,6 @@ template_parm:\n \t\t{ $$ = build_tree_list ($3, $1.t); }\n \t;\n \n-overloaddef:\n-\t  OVERLOAD ov_identifiers ';'\n-\t\t{ warning (\"use of `overload' is an anachronism\"); }\n-\t;\n-\n-ov_identifiers:\n-\t  IDENTIFIER\n-\t\t{ declare_overloaded ($1); }\n-\t| ov_identifiers ',' IDENTIFIER\n-\t\t{ declare_overloaded ($3); }\n-\t;\n-\n template_def:\n \t  template_header\n \t  extdef\n@@ -764,13 +751,13 @@ member_init_list:\n member_init:\n \t  '(' nonnull_exprlist ')'\n \t\t{\n-\t\t  if (current_class_name && !flag_traditional)\n+\t\t  if (current_class_name)\n \t\t    pedwarn (\"anachronistic old style base class initializer\");\n \t\t  expand_member_init (current_class_ref, NULL_TREE, $2);\n \t\t}\n \t| LEFT_RIGHT\n \t\t{\n-\t\t  if (current_class_name && !flag_traditional)\n+\t\t  if (current_class_name)\n \t\t    pedwarn (\"anachronistic old style base class initializer\");\n \t\t  expand_member_init (current_class_ref, NULL_TREE, void_type_node);\n \t\t}"}, {"sha": "99943e22f0be9a925f497a699b2a33e6a45f839f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d22c85969b4555d97d16a2f6704bf57b7d712cd3", "patch": "@@ -1434,7 +1434,11 @@ tsubst (t, args, nargs, in_decl)\n \n \tif (type == TREE_TYPE (t)\n \t    && (! member || ctx == DECL_CLASS_CONTEXT (t)))\n-\t  return t;\n+\t  {\n+\t    t = copy_node (t);\n+\t    copy_lang_decl (t);\n+\t    return t;\n+\t  }\n \n \t/* Do we already have this instantiation?  */\n \tif (DECL_TEMPLATE_INFO (t) != NULL_TREE)"}, {"sha": "dfcc28f2b3ea8f10a3336ccb506d03645e23b7c9", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 24, "deletions": 43, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=d22c85969b4555d97d16a2f6704bf57b7d712cd3", "patch": "@@ -1573,9 +1573,6 @@ default_conversion (exp)\n       if (t != type)\n \treturn convert (t, exp);\n     }\n-  if (flag_traditional\n-      && TYPE_MAIN_VARIANT (type) == float_type_node)\n-    return convert (double_type_node, exp);\n \n   return exp;\n }\n@@ -3474,18 +3471,12 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;\n-\t  if (pedantic)\n-\t    pedwarn (\"ANSI C++ forbids comparison between pointer and integer\");\n-\t  else if (! flag_traditional)\n-\t    warning (\"comparison between pointer and integer\");\n+\t  pedwarn (\"ANSI C++ forbids comparison between pointer and integer\");\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n-\t  if (pedantic)\n-\t    pedwarn (\"ANSI C++ forbids comparison between pointer and integer\");\n-\t  else if (! flag_traditional)\n-\t    warning (\"comparison between pointer and integer\");\n+\t  pedwarn (\"ANSI C++ forbids comparison between pointer and integer\");\n \t}\n       break;\n     }\n@@ -4493,7 +4484,6 @@ unary_complex_lvalue (code, arg)\n \t is really the representation of a pointer to it.\n \t Here give the representation its true type.  */\n       tree t;\n-      tree offset;\n \n       my_friendly_assert (TREE_CODE (arg) != SCOPE_REF, 313);\n \n@@ -4508,6 +4498,9 @@ unary_complex_lvalue (code, arg)\n \treturn build_unary_op (ADDR_EXPR, t, 0);\n       else\n \t{\n+\t  tree type;\n+\t  tree offset = integer_zero_node;\n+\n \t  if (TREE_OPERAND (arg, 0)\n \t      && (TREE_CODE (TREE_OPERAND (arg, 0)) != NOP_EXPR\n \t\t  || TREE_OPERAND (TREE_OPERAND (arg, 0), 0) != error_mark_node))\n@@ -4519,10 +4512,23 @@ unary_complex_lvalue (code, arg)\n \t\treturn error_mark_node;\n \t      }\n \n-\t  /* Add in the offset to the right subobject.  */\n-\t  offset = get_delta_difference (DECL_FIELD_CONTEXT (t), \n-\t\t\t\t\t TREE_TYPE (TREE_OPERAND (arg, 0)),\n-\t\t\t\t\t 0);\n+\t  type = TREE_TYPE (TREE_OPERAND (arg, 0));\n+\n+\t  if (TREE_CODE (TREE_TYPE (arg)) == OFFSET_TYPE)\n+\t    {\n+\t      /* Add in the offset to the intermediate subobject, if any.  */\n+\t      offset = get_delta_difference (TYPE_OFFSET_BASETYPE (TREE_TYPE (arg)),\n+\t\t\t\t\t     type,\n+\t\t\t\t\t     0);\n+\t      type = TYPE_OFFSET_BASETYPE (TREE_TYPE (arg));\n+\t    }\n+\n+\t  /* Now in the offset to the final subobject.  */\n+\t  offset = size_binop (PLUS_EXPR,\n+\t\t\t       offset,\n+\t\t\t       get_delta_difference (DECL_FIELD_CONTEXT (t), \n+\t\t\t\t\t\t     type,\n+\t\t\t\t\t\t     0));\n \n \t  /* Add in the offset to the field.  */\n \t  offset = size_binop (PLUS_EXPR, offset,\n@@ -6063,13 +6069,13 @@ get_delta_difference (from, to, force)\n       if (!force)\n \t{\n \t  error_not_base_type (from, to);\n-\t  error (\"   in pointer to member function conversion\");\n+\t  error (\"   in pointer to member conversion\");\n \t  return delta;\n \t}\n       binfo = get_binfo (to, from, 1);\n       if (binfo == error_mark_node)\n \t{\n-\t  error (\"   in pointer to member function conversion\");\n+\t  error (\"   in pointer to member conversion\");\n \t  return delta;\n \t}\n       if (binfo == 0)\n@@ -6546,31 +6552,6 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t}\n \t    }\n \t}\n-      else if (TREE_CODE (ttr) == OFFSET_TYPE\n-\t       && TREE_CODE (ttl) != OFFSET_TYPE)\n-\t{\n-\t  /* Normally, pointers to different type codes (other\n-\t     than void) are not compatible, but we perform\n-\t     some type instantiation if that resolves the\n-\t     ambiguity of (X Y::*) and (X *).  */\n-\n-\t  if (current_class_ptr)\n-\t    {\n-\t      if (TREE_CODE (rhs) == INTEGER_CST)\n-\t\t{\n-\t\t  rhs = build (PLUS_EXPR, build_pointer_type (TREE_TYPE (ttr)),\n-\t\t\t       current_class_ptr, rhs);\n-\t\t  return convert_for_assignment (type, rhs,\n-\t\t\t\t\t\t errtype, fndecl, parmnum);\n-\t\t}\n-\t    }\n-\t  if (TREE_CODE (ttl) == METHOD_TYPE)\n-\t    error (\"%s between pointer-to-method and pointer-to-member types\",\n-\t\t   errtype);\n-\t  else\n-\t    error (\"%s between pointer and pointer-to-member types\", errtype);\n-\t  return error_mark_node;\n-\t}\n       else\n \t{\n \t  int add_quals = 0, const_parity = 0, volatile_parity = 0;"}, {"sha": "9395cc85ba6f01412ded45709b605dbfb9d6b5b1", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d22c85969b4555d97d16a2f6704bf57b7d712cd3/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=d22c85969b4555d97d16a2f6704bf57b7d712cd3", "patch": "@@ -879,12 +879,7 @@ digest_init (type, init, tail)\n \t  *tail = old_tail_contents;\n \t  return process_init_constructor (type, 0, tail);\n \t}\n-      else if (flag_traditional)\n-\t/* Traditionally one can say `char x[100] = 0;'.  */\n-\treturn process_init_constructor (type,\n-\t\t\t\t\t build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\t\t\t\t\t   tree_cons (NULL_TREE, init, NULL_TREE)),\n-\t\t\t\t\t (tree*)0);\n+\n       if (code != ARRAY_TYPE)\n \treturn convert_for_initialization (NULL_TREE, type, init, LOOKUP_NORMAL,\n \t\t\t\t\t   \"initialization\", NULL_TREE, 0);"}]}