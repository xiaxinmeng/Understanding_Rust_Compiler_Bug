{"sha": "b9747e59d60160903cd366f342ddb5cb960b9944", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk3NDdlNTlkNjAxNjA5MDNjZDM2NmYzNDJkZGI1Y2I5NjBiOTk0NA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-03-19T18:19:53Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-03-19T18:19:53Z"}, "message": "PR c++/8316, c++/9315, c++/10136\n\n        PR c++/8316, c++/9315, c++/10136\n        * call.c (print_z_candidate): Split out from...\n        (print_z_candidiates): ...here.\n        (joust): Use it.\n\nFrom-SVN: r64590", "tree": {"sha": "7950655295f16a8c523a857a20f9b0d20ec6753c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7950655295f16a8c523a857a20f9b0d20ec6753c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9747e59d60160903cd366f342ddb5cb960b9944", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9747e59d60160903cd366f342ddb5cb960b9944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9747e59d60160903cd366f342ddb5cb960b9944", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9747e59d60160903cd366f342ddb5cb960b9944/comments", "author": null, "committer": null, "parents": [{"sha": "9eb0ef7a07219dd4e4bfd6f8c3cd216e0a250367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb0ef7a07219dd4e4bfd6f8c3cd216e0a250367", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eb0ef7a07219dd4e4bfd6f8c3cd216e0a250367"}], "stats": {"total": 67, "additions": 44, "deletions": 23}, "files": [{"sha": "de07dfe5122f3ecbdfc115e63d2f7cbca412574a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9747e59d60160903cd366f342ddb5cb960b9944/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9747e59d60160903cd366f342ddb5cb960b9944/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b9747e59d60160903cd366f342ddb5cb960b9944", "patch": "@@ -1,5 +1,13 @@\n+2003-03-19  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/8316, c++/9315, c++/10136\n+\t* call.c (print_z_candidate): Split out from...\n+\t(print_z_candidiates): ...here.\n+\t(joust): Use it.\n+\n 2003-03-17  Roger Sayle  <roger@eyesopen.com>\n \n+\tPR c++/10031\n \t* decl.c (duplicate_decls): Use the new type when prototyping\n \tanticipated decls, even when the types match.  This defines the\n \texception list for the built-in function."}, {"sha": "71192343e42a49a5939aa3e861e7f7d93b362c3b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9747e59d60160903cd366f342ddb5cb960b9944/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9747e59d60160903cd366f342ddb5cb960b9944/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b9747e59d60160903cd366f342ddb5cb960b9944", "patch": "@@ -2435,6 +2435,36 @@ equal_functions (tree fn1, tree fn2)\n   return fn1 == fn2;\n }\n \n+/* Print information about one overload candidate CANDIDATE.  STR is the\n+   text to print before the candidate itself and ERRFN is the routine\n+   (i.e. error, warning or pedwarn) used to do the printing.  */\n+\n+static void\n+print_z_candidate (const char *str, struct z_candidate *candidate,\n+\t\t   void (*errfn)(const char *, ...))\n+{\n+  if (TREE_CODE (candidate->fn) == IDENTIFIER_NODE)\n+    {\n+      if (TREE_VEC_LENGTH (candidate->convs) == 3)\n+\terrfn (\"%s %D(%T, %T, %T) <built-in>\", str, candidate->fn,\n+\t       TREE_TYPE (TREE_VEC_ELT (candidate->convs, 0)),\n+\t       TREE_TYPE (TREE_VEC_ELT (candidate->convs, 1)),\n+\t       TREE_TYPE (TREE_VEC_ELT (candidate->convs, 2)));\n+      else if (TREE_VEC_LENGTH (candidate->convs) == 2)\n+\terrfn (\"%s %D(%T, %T) <built-in>\", str, candidate->fn,\n+\t       TREE_TYPE (TREE_VEC_ELT (candidate->convs, 0)),\n+\t       TREE_TYPE (TREE_VEC_ELT (candidate->convs, 1)));\n+      else\n+\terrfn (\"%s %D(%T) <built-in>\", str, candidate->fn,\n+\t       TREE_TYPE (TREE_VEC_ELT (candidate->convs, 0)));\n+    }\n+  else if (TYPE_P (candidate->fn))\n+    errfn (\"%s %T <conversion>\", str, candidate->fn);\n+  else\n+    errfn (\"%H%s %+#D%s\", &DECL_SOURCE_LOCATION (candidate->fn), str,\n+\t   candidate->fn, candidate->viable == -1 ? \" <near match>\" : \"\");\n+}\n+\n static void\n print_z_candidates (struct z_candidate *candidates)\n {\n@@ -2467,26 +2497,7 @@ print_z_candidates (struct z_candidate *candidates)\n   str = \"candidates are:\";\n   for (; candidates; candidates = candidates->next)\n     {\n-      if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n-\t{\n-\t  if (TREE_VEC_LENGTH (candidates->convs) == 3)\n-\t    error (\"%s %D(%T, %T, %T) <built-in>\", str, candidates->fn,\n-\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n-\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)),\n-\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 2)));\n-\t  else if (TREE_VEC_LENGTH (candidates->convs) == 2)\n-\t    error (\"%s %D(%T, %T) <built-in>\", str, candidates->fn,\n-\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n-\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)));\n-\t  else\n-\t    error (\"%s %D(%T) <built-in>\", str, candidates->fn,\n-\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)));\n-\t}\n-      else if (TYPE_P (candidates->fn))\n-\terror (\"%s %T <conversion>\", str, candidates->fn);\n-      else\n-\tcp_error_at (\"%s %+#D%s\", str, candidates->fn,\n-\t\t     candidates->viable == -1 ? \" <near match>\" : \"\");\n+      print_z_candidate (str, candidates, error);\n       str = \"               \"; \n     }\n }\n@@ -5861,9 +5872,11 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n         {\n \t  if (warn)\n \t    {\n-\t      pedwarn (\"choosing `%D' over `%D'\", w->fn, l->fn);\n-\t      pedwarn (\n-\"  because worst conversion for the former is better than worst conversion for the latter\");\n+\t      print_z_candidate (\"ISO C++ says that \", w, pedwarn);\n+\t      print_z_candidate (\"              and \", l, pedwarn);\n+\t      pedwarn (\"are ambiguous even though the worst conversion \\\n+for the former is better than the worst conversion for the latter\",\n+\t\t       w->fn, l->fn);\n \t    }\n \t  else\n \t    add_warning (w, l);"}]}