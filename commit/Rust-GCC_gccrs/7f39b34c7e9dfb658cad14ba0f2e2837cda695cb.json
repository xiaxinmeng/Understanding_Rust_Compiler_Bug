{"sha": "7f39b34c7e9dfb658cad14ba0f2e2837cda695cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YzOWIzNGM3ZTlkZmI2NThjYWQxNGJhMGYyZTI4MzdjZGE2OTVjYg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-09-11T05:02:58Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-09-11T05:02:58Z"}, "message": "re PR fortran/28890 (ICE on write)\n\n2006-09-11  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/28890\n\ttrans-expr.c (gfc_conv_function_call): Obtain the string length\n\tof a dummy character(*) function from the symbol if it is not\n\talready translated.  For a call to a character(*) function, use\n\tthe passed, hidden string length argument, which is available\n\tfrom the backend_decl of the formal argument.\n\tresolve.c (resolve_function): It is an error if a function call\n\tto a character(*) function is other than a dummy procedure or\n\tan intrinsic.\n\n2006-09-11  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR libfortran/28890\n\tgfortran.dg/assumed_charlen_function_5.f90: New test.\n\nFrom-SVN: r116839", "tree": {"sha": "35baec3c4421884fed9311bf88cfb8e1f452b755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35baec3c4421884fed9311bf88cfb8e1f452b755"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb/comments", "author": null, "committer": null, "parents": [{"sha": "bc70af526c6b2243c68242d0aa6a48da9da4003d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc70af526c6b2243c68242d0aa6a48da9da4003d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc70af526c6b2243c68242d0aa6a48da9da4003d"}], "stats": {"total": 89, "additions": 83, "deletions": 6}, "files": [{"sha": "b89e0c715fd2e6c333ae583d93614bf73e2439f2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7f39b34c7e9dfb658cad14ba0f2e2837cda695cb", "patch": "@@ -1,3 +1,15 @@\n+2006-09-11  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/28890\n+\ttrans-expr.c (gfc_conv_function_call): Obtain the string length\n+\tof a dummy character(*) function from the symbol if it is not\n+\talready translated.  For a call to a character(*) function, use\n+\tthe passed, hidden string length argument, which is available\n+\tfrom the backend_decl of the formal argument.\n+\tresolve.c (resolve_function): It is an error if a function call\n+\tto a character(*) function is other than a dummy procedure or\n+\tan intrinsic.\n+\n 2006-09-10  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/28959"}, {"sha": "c9475cceab882895c5f9325834f19563c9106dca", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=7f39b34c7e9dfb658cad14ba0f2e2837cda695cb", "patch": "@@ -1413,6 +1413,7 @@ resolve_function (gfc_expr * expr)\n \t&& sym->ts.cl\n \t&& sym->ts.cl->length == NULL\n \t&& !sym->attr.dummy\n+\t&& expr->value.function.esym == NULL\n \t&& !sym->attr.contained)\n     {\n       /* Internal procedures are taken care of in resolve_contained_fntype.  */"}, {"sha": "dc5ac27b786440b3d0ca0848bee1b2cc078032a8", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=7f39b34c7e9dfb658cad14ba0f2e2837cda695cb", "patch": "@@ -2030,6 +2030,16 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  gfc_add_expr_to_block (&se->pre, tmp);\n \t}\n \n+      if (fsym && fsym->ts.type == BT_CHARACTER\n+\t     && parmse.string_length == NULL_TREE\n+\t     && e->ts.type == BT_PROCEDURE\n+\t     && e->symtree->n.sym->ts.type == BT_CHARACTER\n+\t     && e->symtree->n.sym->ts.cl->length != NULL)\n+\t{\n+\t  gfc_conv_const_charlen (e->symtree->n.sym->ts.cl);\n+\t  parmse.string_length = e->symtree->n.sym->ts.cl->backend_decl;\n+\t}\n+\n       /* Character strings are passed as two parameters, a length and a\n          pointer.  */\n       if (parmse.string_length != NULL_TREE)\n@@ -2046,12 +2056,22 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t{\n \t  /* Assumed character length results are not allowed by 5.1.1.5 of the\n \t     standard and are trapped in resolve.c; except in the case of SPREAD\n-\t     (and other intrinsics?).  In this case, we take the character length\n-\t     of the first argument for the result.  */\n-\t  cl.backend_decl = TREE_VALUE (stringargs);\n-\t}\n-      else\n-\t{\n+\t     (and other intrinsics?) and dummy functions.  In the case of SPREAD,\n+\t     we take the character length of the first argument for the result.\n+\t     For dummies, we have to look through the formal argument list for\n+\t     this function and use the character length found there.*/\n+\t  if (!sym->attr.dummy)\n+\t    cl.backend_decl = TREE_VALUE (stringargs);\n+\t  else\n+\t    {\n+\t      formal = sym->ns->proc_name->formal;\n+\t      for (; formal; formal = formal->next)\n+\t\tif (strcmp (formal->sym->name, sym->name) == 0)\n+\t\t  cl.backend_decl = formal->sym->ts.cl->backend_decl;\n+\t    }\n+        }\n+        else\n+        {\n \t  /* Calculate the length of the returned string.  */\n \t  gfc_init_se (&parmse, NULL);\n \t  if (need_interface_mapping)"}, {"sha": "d0f76e0b764907bb1087d7da9471caa0c517d98b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7f39b34c7e9dfb658cad14ba0f2e2837cda695cb", "patch": "@@ -1,3 +1,8 @@\n+2006-09-11  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR libfortran/28890\n+\tgfortran.dg/assumed_charlen_function_5.f90: New test.\n+\n 2006-09-10  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/28991"}, {"sha": "f8efc0ad8b583055e8535489665d39b660e6993b", "filename": "gcc/testsuite/gfortran.dg/assumed_charlen_function_5.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f39b34c7e9dfb658cad14ba0f2e2837cda695cb/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_5.f90?ref=7f39b34c7e9dfb658cad14ba0f2e2837cda695cb", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+! Tests the patch for PR28890, in which a reference to a legal reference\n+! to an assumed character length function, passed as a dummy, would\n+! cause an ICE.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+character(*) function charrext (n)  ! { dg-warning \"is obsolescent in fortran 95\" }\n+  character(26) :: alpha =\"abcdefghijklmnopqrstuvwxyz\"\n+  charrext = alpha (1:n)\n+end function charrext\n+\n+  character(26), external :: charrext\n+  interface\n+    integer(4) function test(charr, i)\n+     character(*), external :: charr\n+     integer :: i\n+    end function test\n+  end interface\n+\n+  do j = 1 , 26\n+    m = test (charrext, j)\n+    m = ctest (charrext, 27 - j)\n+  end do\n+contains\n+  integer(4) function ctest(charr, i)  ! { dg-warning \"is obsolescent in fortran 95\" }\n+    character(*) :: charr\n+    integer :: i\n+    print *, charr(i)\n+    ctest = 1\n+  end function ctest\n+end\n+\n+integer(4) function test(charr, i)  ! { dg-warning \"is obsolescent in fortran 95\" }\n+  character(*) :: charr\n+  integer :: i\n+  print *, charr(i)\n+  test = 1\n+end function test\n\\ No newline at end of file"}]}