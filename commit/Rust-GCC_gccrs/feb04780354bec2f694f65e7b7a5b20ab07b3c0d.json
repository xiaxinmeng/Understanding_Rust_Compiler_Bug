{"sha": "feb04780354bec2f694f65e7b7a5b20ab07b3c0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmViMDQ3ODAzNTRiZWMyZjY5NGY2NWU3YjdhNWIyMGFiMDdiM2MwZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-02-13T01:55:37Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-02-13T01:55:37Z"}, "message": "re PR middle-end/25724 (Emits call to __cmpdi2 for long long comparison in switches)\n\n\n\tPR middle-end/25724\n\t* dojump.c (do_jump): Call do_compare_rtx_and_jump.\n\t(do_jump_parts_zero_rtx): New function renamed from\n\tdo_jump_parts_equality_rtx.  Made static.  Add a mode argument.\n\t(do_jump_parts_equality_rtx): New function split out from\n\tdo_jump_parts_equality.  Old implementation renamed as above.\n\tCall do_jump_parts_zero_rtx if either operand is zero.\n\t(do_jump_parts_equality): Call do_jump_parts_equality_rtx to\n\tdo all of the heavy lifting.\n\t(do_compare_rtx_and_jump): Handle multi-word comparisons by\n\tcalling either do_jump_by_parts_greater_rtx or\n\tdo_jump_by_parts_equality_rtx.\n\t* expr.h (do_jump_by_parts_equality_rtx): Remove prototype.\n\t* expmed.c (do_cmp_and_jump): Now multi-word optimization has\n\tmoved to do_compare_rtx_and_jump, call it directly.\n\t* stmt.c (do_jump_if_equal): Remove static prototype.  Add a\n\tmode argument.  Call do_compare_rtx_and_jump.\n\t(emit_case_nodes): Update calls to do_jump_if_equal.\n\nFrom-SVN: r110906", "tree": {"sha": "3d8ced1bf10347b4692e3a1210b4de3fd48c5e58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d8ced1bf10347b4692e3a1210b4de3fd48c5e58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/feb04780354bec2f694f65e7b7a5b20ab07b3c0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb04780354bec2f694f65e7b7a5b20ab07b3c0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feb04780354bec2f694f65e7b7a5b20ab07b3c0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb04780354bec2f694f65e7b7a5b20ab07b3c0d/comments", "author": null, "committer": null, "parents": [{"sha": "c0c84a897e862589a0bde45ce884c2d0fb7dda7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0c84a897e862589a0bde45ce884c2d0fb7dda7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0c84a897e862589a0bde45ce884c2d0fb7dda7b"}], "stats": {"total": 307, "additions": 161, "deletions": 146}, "files": [{"sha": "18ea30d7b340406554c158da5ff1bbacb8b3d0fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb04780354bec2f694f65e7b7a5b20ab07b3c0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb04780354bec2f694f65e7b7a5b20ab07b3c0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=feb04780354bec2f694f65e7b7a5b20ab07b3c0d", "patch": "@@ -1,3 +1,24 @@\n+2006-02-12  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR middle-end/25724\n+\t* dojump.c (do_jump): Call do_compare_rtx_and_jump.\n+\t(do_jump_parts_zero_rtx): New function renamed from\n+\tdo_jump_parts_equality_rtx.  Made static.  Add a mode argument.\n+\t(do_jump_parts_equality_rtx): New function split out from\n+\tdo_jump_parts_equality.  Old implementation renamed as above.\n+\tCall do_jump_parts_zero_rtx if either operand is zero.\n+\t(do_jump_parts_equality): Call do_jump_parts_equality_rtx to\n+\tdo all of the heavy lifting.\n+\t(do_compare_rtx_and_jump): Handle multi-word comparisons by\n+\tcalling either do_jump_by_parts_greater_rtx or\n+\tdo_jump_by_parts_equality_rtx.\n+\t* expr.h (do_jump_by_parts_equality_rtx): Remove prototype.\n+\t* expmed.c (do_cmp_and_jump): Now multi-word optimization has\n+\tmoved to do_compare_rtx_and_jump, call it directly.\n+\t* stmt.c (do_jump_if_equal): Remove static prototype.  Add a\n+\tmode argument.  Call do_compare_rtx_and_jump.\n+\t(emit_case_nodes): Update calls to do_jump_if_equal.\n+\n 2006-02-12  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR rtl-optimization/26225"}, {"sha": "86dc6f4a6c4ec9c7207d9ac34bceb90f4cbbe989", "filename": "gcc/dojump.c", "status": "modified", "additions": 121, "deletions": 67, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb04780354bec2f694f65e7b7a5b20ab07b3c0d/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb04780354bec2f694f65e7b7a5b20ab07b3c0d/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=feb04780354bec2f694f65e7b7a5b20ab07b3c0d", "patch": "@@ -1,6 +1,6 @@\n /* Convert tree expression to rtl instructions, for GNU compiler.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -586,38 +586,20 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n     normal:\n       temp = expand_normal (exp);\n       do_pending_stack_adjust ();\n-\n-      if (GET_CODE (temp) == CONST_INT\n-          || (GET_CODE (temp) == CONST_DOUBLE && GET_MODE (temp) == VOIDmode)\n-          || GET_CODE (temp) == LABEL_REF)\n-        {\n-          rtx target = temp == const0_rtx ? if_false_label : if_true_label;\n-          if (target)\n-            emit_jump (target);\n-        }\n-      else if (GET_MODE_CLASS (GET_MODE (temp)) == MODE_INT\n-               && ! can_compare_p (NE, GET_MODE (temp), ccp_jump))\n-        /* Note swapping the labels gives us not-equal.  */\n-        do_jump_by_parts_equality_rtx (temp, if_true_label, if_false_label);\n-      else\n+      /* The RTL optimizers prefer comparisons against pseudos.  */\n+      if (GET_CODE (temp) == SUBREG)\n \t{\n-\t  gcc_assert (GET_MODE (temp) != VOIDmode);\n-\t  \n-\t  /* The RTL optimizers prefer comparisons against pseudos.  */\n-\t  if (GET_CODE (temp) == SUBREG)\n-\t    {\n-\t      /* Compare promoted variables in their promoted mode.  */\n-\t      if (SUBREG_PROMOTED_VAR_P (temp)\n-\t\t  && REG_P (XEXP (temp, 0)))\n-\t\ttemp = XEXP (temp, 0);\n-\t      else\n-\t\ttemp = copy_to_reg (temp);\n-\t    }\n-\t  do_compare_rtx_and_jump (temp, CONST0_RTX (GET_MODE (temp)),\n-\t\t\t\t   NE, TYPE_UNSIGNED (TREE_TYPE (exp)),\n-\t\t\t\t   GET_MODE (temp), NULL_RTX,\n-\t\t\t\t   if_false_label, if_true_label);\n+\t  /* Compare promoted variables in their promoted mode.  */\n+\t  if (SUBREG_PROMOTED_VAR_P (temp)\n+\t      && REG_P (XEXP (temp, 0)))\n+\t    temp = XEXP (temp, 0);\n+\t  else\n+\t    temp = copy_to_reg (temp);\n \t}\n+      do_compare_rtx_and_jump (temp, CONST0_RTX (GET_MODE (temp)),\n+\t\t\t       NE, TYPE_UNSIGNED (TREE_TYPE (exp)),\n+\t\t\t       GET_MODE (temp), NULL_RTX,\n+\t\t\t       if_false_label, if_true_label);\n     }\n \n   if (drop_through_label)\n@@ -695,43 +677,17 @@ do_jump_by_parts_greater_rtx (enum machine_mode mode, int unsignedp, rtx op0,\n   if (drop_through_label)\n     emit_label (drop_through_label);\n }\n-\n-/* Given an EQ_EXPR expression EXP for values too wide to be compared\n-   with one insn, test the comparison and jump to the appropriate label.  */\n-\n-static void\n-do_jump_by_parts_equality (tree exp, rtx if_false_label, rtx if_true_label)\n-{\n-  rtx op0 = expand_normal (TREE_OPERAND (exp, 0));\n-  rtx op1 = expand_normal (TREE_OPERAND (exp, 1));\n-  enum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-  int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);\n-  int i;\n-  rtx drop_through_label = 0;\n-\n-  if (! if_false_label)\n-    drop_through_label = if_false_label = gen_label_rtx ();\n-\n-  for (i = 0; i < nwords; i++)\n-    do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),\n-                             operand_subword_force (op1, i, mode),\n-                             EQ, TYPE_UNSIGNED (TREE_TYPE (exp)),\n-                             word_mode, NULL_RTX, if_false_label, NULL_RTX);\n-\n-  if (if_true_label)\n-    emit_jump (if_true_label);\n-  if (drop_through_label)\n-    emit_label (drop_through_label);\n-}\n \f\n-/* Jump according to whether OP0 is 0.\n-   We assume that OP0 has an integer mode that is too wide\n-   for the available compare insns.  */\n+/* Jump according to whether OP0 is 0.  We assume that OP0 has an integer\n+   mode, MODE, that is too wide for the available compare insns.  Either\n+   Either (but not both) of IF_TRUE_LABEL and IF_FALSE_LABEL may be NULL_RTX\n+   to indicate drop through.  */\n \n-void\n-do_jump_by_parts_equality_rtx (rtx op0, rtx if_false_label, rtx if_true_label)\n+static void\n+do_jump_by_parts_zero_rtx (enum machine_mode mode, rtx op0,\n+\t\t\t   rtx if_false_label, rtx if_true_label)\n {\n-  int nwords = GET_MODE_SIZE (GET_MODE (op0)) / UNITS_PER_WORD;\n+  int nwords = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n   rtx part;\n   int i;\n   rtx drop_through_label = 0;\n@@ -771,6 +727,58 @@ do_jump_by_parts_equality_rtx (rtx op0, rtx if_false_label, rtx if_true_label)\n   if (drop_through_label)\n     emit_label (drop_through_label);\n }\n+\n+/* Test for the equality of two RTX expressions OP0 and OP1 in mode MODE,\n+   where MODE is an integer mode too wide to be compared with one insn.\n+   Either (but not both) of IF_TRUE_LABEL and IF_FALSE_LABEL may be NULL_RTX\n+   to indicate drop through.  */\n+\n+static void\n+do_jump_by_parts_equality_rtx (enum machine_mode mode, rtx op0, rtx op1,\n+\t\t\t       rtx if_false_label, rtx if_true_label)\n+{\n+  int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);\n+  rtx drop_through_label = 0;\n+  int i;\n+\n+  if (op1 == const0_rtx)\n+    {\n+      do_jump_by_parts_zero_rtx (mode, op0, if_false_label, if_true_label);\n+      return;\n+    }\n+  else if (op0 == const0_rtx)\n+    {\n+      do_jump_by_parts_zero_rtx (mode, op1, if_false_label, if_true_label);\n+      return;\n+    }\n+\n+  if (! if_false_label)\n+    drop_through_label = if_false_label = gen_label_rtx ();\n+\n+  for (i = 0; i < nwords; i++)\n+    do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),\n+                             operand_subword_force (op1, i, mode),\n+                             EQ, 0, word_mode, NULL_RTX,\n+\t\t\t     if_false_label, NULL_RTX);\n+\n+  if (if_true_label)\n+    emit_jump (if_true_label);\n+  if (drop_through_label)\n+    emit_label (drop_through_label);\n+}\n+\n+/* Given an EQ_EXPR expression EXP for values too wide to be compared\n+   with one insn, test the comparison and jump to the appropriate label.  */\n+\n+static void\n+do_jump_by_parts_equality (tree exp, rtx if_false_label, rtx if_true_label)\n+{\n+  rtx op0 = expand_normal (TREE_OPERAND (exp, 0));\n+  rtx op1 = expand_normal (TREE_OPERAND (exp, 1));\n+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+  do_jump_by_parts_equality_rtx (mode, op0, op1, if_false_label,\n+\t\t\t\t if_true_label);\n+}\n \f\n /* Generate code for a comparison of OP0 and OP1 with rtx code CODE.\n    MODE is the machine mode of the comparison, not of the result.\n@@ -886,14 +894,60 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n       unsignedp = (code == GTU || code == LTU || code == GEU || code == LEU);\n     }\n \n+\n   if (! if_true_label)\n     {\n       dummy_true_label = 1;\n       if_true_label = gen_label_rtx ();\n     }\n \n-  emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp,\n-                           if_true_label);\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      && ! can_compare_p (code, mode, ccp_jump))\n+    {\n+      switch (code)\n+\t{\n+\tcase LTU:\n+\t  do_jump_by_parts_greater_rtx (mode, 1, op1, op0,\n+\t\t\t\t\tif_false_label, if_true_label);\n+\t  break;\n+\n+\tcase LEU:\n+\t  do_jump_by_parts_greater_rtx (mode, 1, op0, op1,\n+\t\t\t\t\tif_true_label, if_false_label);\n+\t  break;\n+\n+\tcase LT:\n+\t  do_jump_by_parts_greater_rtx (mode, 0, op1, op0,\n+\t\t\t\t\tif_false_label, if_true_label);\n+\t  break;\n+\n+\tcase GT:\n+\t  do_jump_by_parts_greater_rtx (mode, 0, op0, op1,\n+\t\t\t\t\tif_false_label, if_true_label);\n+\t  break;\n+\n+\tcase GE:\n+\t  do_jump_by_parts_greater_rtx (mode, 0, op1, op0,\n+\t\t\t\t\tif_true_label, if_false_label);\n+\t  break;\n+\n+\tcase EQ:\n+\t  do_jump_by_parts_equality_rtx (mode, op0, op1, if_false_label,\n+\t\t\t\t\t if_true_label);\n+\t  break;\n+\n+\tcase NE:\n+\t  do_jump_by_parts_equality_rtx (mode, op0, op1, if_true_label,\n+\t\t\t\t\t if_false_label);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp,\n+\t\t\t     if_true_label);\n \n   if (if_false_label)\n     emit_jump (if_false_label);"}, {"sha": "7d77587e6e61c6b535e0406d2938be6e04df609d", "filename": "gcc/expmed.c", "status": "modified", "additions": 7, "deletions": 58, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb04780354bec2f694f65e7b7a5b20ab07b3c0d/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb04780354bec2f694f65e7b7a5b20ab07b3c0d/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=feb04780354bec2f694f65e7b7a5b20ab07b3c0d", "patch": "@@ -1,7 +1,8 @@\n /* Medium-level subroutines: convert bit-field store and extract\n    and shifts, multiplies and divides to rtl instructions.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -5564,66 +5565,14 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n }\n \f\n /* Perform possibly multi-word comparison and conditional jump to LABEL\n-   if ARG1 OP ARG2 true where ARG1 and ARG2 are of mode MODE\n-\n-   The algorithm is based on the code in expr.c:do_jump.\n-\n-   Note that this does not perform a general comparison.  Only\n-   variants generated within expmed.c are correctly handled, others\n-   could be handled if needed.  */\n+   if ARG1 OP ARG2 true where ARG1 and ARG2 are of mode MODE.  This is\n+   now a thin wrapper around do_compare_rtx_and_jump.  */\n \n static void\n do_cmp_and_jump (rtx arg1, rtx arg2, enum rtx_code op, enum machine_mode mode,\n \t\t rtx label)\n {\n-  /* If this mode is an integer too wide to compare properly,\n-     compare word by word.  Rely on cse to optimize constant cases.  */\n-\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n-      && ! can_compare_p (op, mode, ccp_jump))\n-    {\n-      rtx label2 = gen_label_rtx ();\n-\n-      switch (op)\n-\t{\n-\tcase LTU:\n-\t  do_jump_by_parts_greater_rtx (mode, 1, arg2, arg1, label2, label);\n-\t  break;\n-\n-\tcase LEU:\n-\t  do_jump_by_parts_greater_rtx (mode, 1, arg1, arg2, label, label2);\n-\t  break;\n-\n-\tcase LT:\n-\t  do_jump_by_parts_greater_rtx (mode, 0, arg2, arg1, label2, label);\n-\t  break;\n-\n-\tcase GT:\n-\t  do_jump_by_parts_greater_rtx (mode, 0, arg1, arg2, label2, label);\n-\t  break;\n-\n-\tcase GE:\n-\t  do_jump_by_parts_greater_rtx (mode, 0, arg2, arg1, label, label2);\n-\t  break;\n-\n-\t  /* do_jump_by_parts_equality_rtx compares with zero.  Luckily\n-\t     that's the only equality operations we do */\n-\tcase EQ:\n-\t  gcc_assert (arg2 == const0_rtx && mode == GET_MODE(arg1));\n-\t  do_jump_by_parts_equality_rtx (arg1, label2, label);\n-\t  break;\n-\n-\tcase NE:\n-\t  gcc_assert (arg2 == const0_rtx && mode == GET_MODE(arg1));\n-\t  do_jump_by_parts_equality_rtx (arg1, label, label2);\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      emit_label (label2);\n-    }\n-  else\n-    emit_cmp_and_jump_insns (arg1, arg2, op, NULL_RTX, mode, 0, label);\n+  int unsignedp = (op == LTU || op == LEU || op == GTU || op == GEU);\n+  do_compare_rtx_and_jump (arg1, arg2, op, unsignedp, mode,\n+\t\t\t   NULL_RTX, NULL_RTX, label);\n }"}, {"sha": "f1cf081b195d1e34d2d10008c26d0f361179f3e4", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb04780354bec2f694f65e7b7a5b20ab07b3c0d/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb04780354bec2f694f65e7b7a5b20ab07b3c0d/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=feb04780354bec2f694f65e7b7a5b20ab07b3c0d", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for code generation pass of GNU compiler.\n    Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -743,7 +743,6 @@ extern void init_all_optabs (void);\n /* Call this to initialize an optab function entry.  */\n extern rtx init_one_libfunc (const char *);\n \n-extern void do_jump_by_parts_equality_rtx (rtx, rtx, rtx);\n extern void do_jump_by_parts_greater_rtx (enum machine_mode, int, rtx, rtx,\n \t\t\t\t\t  rtx, rtx);\n "}, {"sha": "be192169e004358c331a4708e02e40d177a5972d", "filename": "gcc/stmt.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb04780354bec2f694f65e7b7a5b20ab07b3c0d/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb04780354bec2f694f65e7b7a5b20ab07b3c0d/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=feb04780354bec2f694f65e7b7a5b20ab07b3c0d", "patch": "@@ -1,6 +1,6 @@\n /* Expands front end tree to back end RTL for GCC\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -112,7 +112,6 @@ static bool check_unique_operand_names (tree, tree);\n static char *resolve_operand_name_1 (char *, tree, tree);\n static void expand_null_return_1 (void);\n static void expand_value_return (rtx);\n-static void do_jump_if_equal (rtx, rtx, rtx, int);\n static int estimate_case_costs (case_node_ptr);\n static bool lshift_cheap_p (void);\n static int case_bit_test_cmp (const void *, const void *);\n@@ -2588,21 +2587,14 @@ expand_case (tree exp)\n   free_temp_slots ();\n }\n \n-/* Generate code to jump to LABEL if OP1 and OP2 are equal.  */\n+/* Generate code to jump to LABEL if OP0 and OP1 are equal in mode MODE.  */\n \n static void\n-do_jump_if_equal (rtx op1, rtx op2, rtx label, int unsignedp)\n+do_jump_if_equal (enum machine_mode mode, rtx op0, rtx op1, rtx label,\n+\t\t  int unsignedp)\n {\n-  if (GET_CODE (op1) == CONST_INT && GET_CODE (op2) == CONST_INT)\n-    {\n-      if (op1 == op2)\n-\temit_jump (label);\n-    }\n-  else\n-    emit_cmp_and_jump_insns (op1, op2, EQ, NULL_RTX,\n-\t\t\t     (GET_MODE (op1) == VOIDmode\n-\t\t\t     ? GET_MODE (op2) : GET_MODE (op1)),\n-\t\t\t     unsignedp, label);\n+  do_compare_rtx_and_jump (op0, op1, EQ, unsignedp, mode,\n+\t\t\t   NULL_RTX, NULL_RTX, label);\n }\n \f\n /* Not all case values are encountered equally.  This function\n@@ -2954,7 +2946,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n       /* Node is single valued.  First see if the index expression matches\n \t this node and then check our children, if any.  */\n \n-      do_jump_if_equal (index,\n+      do_jump_if_equal (mode, index,\n \t\t\tconvert_modes (mode, imode,\n \t\t\t\t       expand_normal (node->low),\n \t\t\t\t       unsignedp),\n@@ -3007,7 +2999,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \n \t      /* See if the value matches what the right hand side\n \t\t wants.  */\n-\t      do_jump_if_equal (index,\n+\t      do_jump_if_equal (mode, index,\n \t\t\t\tconvert_modes (mode, imode,\n \t\t\t\t\t       expand_normal (node->right->low),\n \t\t\t\t\t       unsignedp),\n@@ -3016,7 +3008,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \n \t      /* See if the value matches what the left hand side\n \t\t wants.  */\n-\t      do_jump_if_equal (index,\n+\t      do_jump_if_equal (mode, index,\n \t\t\t\tconvert_modes (mode, imode,\n \t\t\t\t\t       expand_normal (node->left->low),\n \t\t\t\t\t       unsignedp),\n@@ -3082,7 +3074,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t    /* We cannot process node->right normally\n \t       since we haven't ruled out the numbers less than\n \t       this node's value.  So handle node->right explicitly.  */\n-\t    do_jump_if_equal (index,\n+\t    do_jump_if_equal (mode, index,\n \t\t\t      convert_modes\n \t\t\t      (mode, imode,\n \t\t\t       expand_normal (node->right->low),\n@@ -3113,7 +3105,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t    /* We cannot process node->left normally\n \t       since we haven't ruled out the numbers less than\n \t       this node's value.  So handle node->left explicitly.  */\n-\t    do_jump_if_equal (index,\n+\t    do_jump_if_equal (mode, index,\n \t\t\t      convert_modes\n \t\t\t      (mode, imode,\n \t\t\t       expand_normal (node->left->low),"}]}