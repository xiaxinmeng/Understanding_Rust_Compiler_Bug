{"sha": "a8399af846a1f9c71f1275f3de74ff3f8a86532a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgzOTlhZjg0NmExZjljNzFmMTI3NWYzZGU3NGZmM2Y4YTg2NTMyYQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-02-17T11:07:32Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-02-17T11:07:32Z"}, "message": "re PR fortran/84115 (Failure in associate construct with concatenated character target)\n\n2018-02-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/84115\n\t* resolve.c (resolve_assoc_var): If a non-constant target expr.\n\thas no string length expression, make the associate variable\n\tinto a deferred length, allocatable symbol.\n\t* trans-decl.c (gfc_is_reallocatable_lhs): Add and use a ptr to\n\tthe symbol.\n\t* trans-stmt.c (trans_associate_var): Null and free scalar\n\tassociate names that are allocatable. After assignment, remove\n\tthe allocatable attribute to prevent reallocation.\n\n2018-02-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/84115\n\t* gfortran.dg/associate_35.f90: Remove error, add stop n's and\n\tchange to run.\n\nFrom-SVN: r257781", "tree": {"sha": "0261cf814bb464b35228e498b8b896484764ed07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0261cf814bb464b35228e498b8b896484764ed07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8399af846a1f9c71f1275f3de74ff3f8a86532a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8399af846a1f9c71f1275f3de74ff3f8a86532a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8399af846a1f9c71f1275f3de74ff3f8a86532a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8399af846a1f9c71f1275f3de74ff3f8a86532a/comments", "author": null, "committer": null, "parents": [{"sha": "9f533a82db92db8c0772a0d75e6a76c98ad1bcc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f533a82db92db8c0772a0d75e6a76c98ad1bcc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f533a82db92db8c0772a0d75e6a76c98ad1bcc9"}], "stats": {"total": 100, "additions": 84, "deletions": 16}, "files": [{"sha": "af345eafd5cb59b339504aa6a6a1e0eba3e14040", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a8399af846a1f9c71f1275f3de74ff3f8a86532a", "patch": "@@ -1,3 +1,15 @@\n+2018-02-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/84115\n+\t* resolve.c (resolve_assoc_var): If a non-constant target expr.\n+\thas no string length expression, make the associate variable\n+\tinto a deferred length, allocatable symbol.\n+\t* trans-decl.c (gfc_is_reallocatable_lhs): Add and use a ptr to\n+\tthe symbol.\n+\t* trans-stmt.c (trans_associate_var): Null and free scalar\n+\tassociate names that are allocatable. After assignment, remove\n+\tthe allocatable attribute to prevent reallocation.\n+\n 2018-02-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/84418"}, {"sha": "9e6a8fe0d8019a92906605ab9ed5341345ddc52a", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=a8399af846a1f9c71f1275f3de74ff3f8a86532a", "patch": "@@ -2082,7 +2082,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n     {\n       bool permissible;\n \n-      /* These target expressions can ge resolved at any time.  */\n+      /* These target expressions can be resolved at any time.  */\n       permissible = tgt_expr && tgt_expr->symtree && tgt_expr->symtree->n.sym\n \t\t    && (tgt_expr->symtree->n.sym->attr.use_assoc\n \t\t\t|| tgt_expr->symtree->n.sym->attr.host_assoc"}, {"sha": "e1d2aa27ad18e85f78b21c063db7161296c22638", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=a8399af846a1f9c71f1275f3de74ff3f8a86532a", "patch": "@@ -8635,7 +8635,20 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n   if (sym->ts.type == BT_CHARACTER && !sym->attr.select_type_temporary)\n     {\n       if (!sym->ts.u.cl)\n-\tsym->ts.u.cl = target->ts.u.cl;\n+\t{\n+\t  if (target->expr_type != EXPR_CONSTANT\n+\t      && !target->ts.u.cl->length)\n+\t    {\n+\t      sym->ts.u.cl = gfc_get_charlen();\n+\t      sym->ts.deferred = 1;\n+\n+\t      /* This is reset in trans-stmt.c after the assignment\n+\t\t of the target expression to the associate name.  */\n+\t      sym->attr.allocatable = 1;\n+\t    }\n+\t  else\n+\t    sym->ts.u.cl = target->ts.u.cl;\n+\t}\n \n       if (!sym->ts.u.cl->length && !sym->ts.deferred)\n \t{"}, {"sha": "79d4d171bddb3552195fb9fbbef3e2806a867e8d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=a8399af846a1f9c71f1275f3de74ff3f8a86532a", "patch": "@@ -9470,29 +9470,32 @@ bool\n gfc_is_reallocatable_lhs (gfc_expr *expr)\n {\n   gfc_ref * ref;\n+  gfc_symbol *sym;\n \n   if (!expr->ref)\n     return false;\n \n+  sym = expr->symtree->n.sym;\n+\n   /* An allocatable class variable with no reference.  */\n-  if (expr->symtree->n.sym->ts.type == BT_CLASS\n-      && CLASS_DATA (expr->symtree->n.sym)->attr.allocatable\n+  if (sym->ts.type == BT_CLASS\n+      && CLASS_DATA (sym)->attr.allocatable\n       && expr->ref && expr->ref->type == REF_COMPONENT\n       && strcmp (expr->ref->u.c.component->name, \"_data\") == 0\n       && expr->ref->next == NULL)\n     return true;\n \n   /* An allocatable variable.  */\n-  if (expr->symtree->n.sym->attr.allocatable\n+  if (sym->attr.allocatable\n \t&& expr->ref\n \t&& expr->ref->type == REF_ARRAY\n \t&& expr->ref->u.ar.type == AR_FULL)\n     return true;\n \n   /* All that can be left are allocatable components.  */\n-  if ((expr->symtree->n.sym->ts.type != BT_DERIVED\n-       && expr->symtree->n.sym->ts.type != BT_CLASS)\n-\t|| !expr->symtree->n.sym->ts.u.derived->attr.alloc_comp)\n+  if ((sym->ts.type != BT_DERIVED\n+       && sym->ts.type != BT_CLASS)\n+\t|| !sym->ts.u.derived->attr.alloc_comp)\n     return false;\n \n   /* Find a component ref followed by an array reference.  */"}, {"sha": "04e06efbe38b17f8b7c17500e6cf27d4a0ee455a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a8399af846a1f9c71f1275f3de74ff3f8a86532a", "patch": "@@ -657,7 +657,7 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \t      }\n \n \t  /* Array references with vector subscripts and non-variable expressions\n-\t     need be coverted to a one-based descriptor.  */\n+\t     need be converted to a one-based descriptor.  */\n \t  if (ref || e->expr_type != EXPR_VARIABLE)\n \t    {\n \t      for (dim = 0; dim < e->rank; ++dim)"}, {"sha": "71e22d80e98224bd6e9215fa2d654f71d376424e", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=a8399af846a1f9c71f1275f3de74ff3f8a86532a", "patch": "@@ -1926,9 +1926,26 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n     {\n       gfc_expr *lhs;\n       tree res;\n+      gfc_se se;\n+\n+      gfc_init_se (&se, NULL);\n+\n+      /* resolve.c converts some associate names to allocatable so that\n+\t allocation can take place automatically in gfc_trans_assignment.\n+\t The frontend prevents them from being either allocated,\n+\t deallocated or reallocated.  */\n+      if (sym->attr.allocatable)\n+\t{\n+\t  tmp = sym->backend_decl;\n+\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n+\t    tmp = gfc_conv_descriptor_data_get (tmp);\n+\t  gfc_add_modify (&se.pre, tmp, fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t\t\t    null_pointer_node));\n+\t}\n \n       lhs = gfc_lval_expr_from_sym (sym);\n       res = gfc_trans_assignment (lhs, e, false, true);\n+      gfc_add_expr_to_block (&se.pre, res);\n \n       tmp = sym->backend_decl;\n       if (e->expr_type == EXPR_FUNCTION\n@@ -1948,8 +1965,25 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t  tmp = gfc_deallocate_pdt_comp (CLASS_DATA (sym)->ts.u.derived,\n \t\t\t\t\t tmp, 0);\n \t}\n+      else if (sym->attr.allocatable)\n+\t{\n+\t  tmp = sym->backend_decl;\n+\n+\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n+\t    tmp = gfc_conv_descriptor_data_get (tmp);\n+\n+\t  /* A simple call to free suffices here.  */\n+\t  tmp = gfc_call_free (tmp);\n+\n+\t  /* Make sure that reallocation on assignment cannot occur.  */\n+\t  sym->attr.allocatable = 0;\n+\t}\n+      else\n+\ttmp = NULL_TREE;\n \n+      res = gfc_finish_block (&se.pre);\n       gfc_add_init_cleanup (block, res, tmp);\n+      gfc_free_expr (lhs);\n     }\n \n   /* Set the stringlength, when needed.  */"}, {"sha": "4bc2d3e7f768606b3e0f7663101f2e5731d67c22", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a8399af846a1f9c71f1275f3de74ff3f8a86532a", "patch": "@@ -1,3 +1,9 @@\n+2018-02-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/84115\n+\t* gfortran.dg/associate_35.f90: Remove error, add STOP n and\n+\tchange to dg-run.\n+\n 2018-02-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR ada/84277\n@@ -492,7 +498,7 @@\n \n \tPR sanitizer/83987\n \t* g++.dg/ubsan/pr83987-2.C: New test.\n-\t\n+\n 2018-02-09  Sebastian Perta  <sebastian.perta@renesas.com>\n \n \t* gcc.target/rx/movsicc.c: New test."}, {"sha": "67329785bc4315fe086f05a4e2163f4fa912687f", "filename": "gcc/testsuite/gfortran.dg/associate_35.f90", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_35.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8399af846a1f9c71f1275f3de74ff3f8a86532a/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_35.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_35.f90?ref=a8399af846a1f9c71f1275f3de74ff3f8a86532a", "patch": "@@ -1,6 +1,6 @@\n-! { dg-do compile }\n+! { dg-do run }\n !\n-! Test the fix for PR84115 comment #1 (except for s1(x)!).\n+! Test the fix for PR84115 comment #1.\n !\n ! Contributed by G Steinmetz  <gscfq@t-online.de>\n !\n@@ -14,22 +14,22 @@\n contains\n   subroutine s1(x)\n     character(:), allocatable :: x\n-    associate (y => x//x)   ! { dg-error \"type character and non-constant length\" }\n-      print *, y\n+    associate (y => x//x)\n+      if (y .ne. x//x) stop 1\n     end associate\n   end\n \n   subroutine s2(x)\n     character(:), allocatable :: x\n     associate (y => [x])\n-      print *, y\n+      if (any(y .ne. [x])) stop 2\n     end associate\n   end\n \n   subroutine s3(x)\n     character(:), allocatable :: x\n     associate (y => [x,x])\n-      print *, y\n+      if (any(y .ne. [x,x])) stop 3\n     end associate\n   end\n end"}]}