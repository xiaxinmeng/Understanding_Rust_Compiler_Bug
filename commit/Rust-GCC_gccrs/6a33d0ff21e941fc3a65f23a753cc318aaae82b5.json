{"sha": "6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmEzM2QwZmYyMWU5NDFmYzNhNjVmMjNhNzUzY2MzMThhYWFlODJiNQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-11-21T20:01:58Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-11-21T20:01:58Z"}, "message": "PR tree-optimization/82945 - add warning for passing non-strings to functions that expect string arguments\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/82945\n\t* builtins.c (expand_builtin_strlen): Call maybe_warn_nonstring_arg.\n\t* calls.h (maybe_warn_nonstring_arg): Declare new function.\n\t* calls.c (get_attr_nonstring_decl, maybe_warn_nonstring_arg): New\n\tfunctions.\n\t(initialize_argument_information): Call maybe_warn_nonstring_arg.\n\t* calls.h (get_attr_nonstring_decl): Declare new function.\n\t* doc/extend.texi (attribute nonstring): Update.\n\t* gimple-fold.c (gimple_fold_builtin_strncpy): Call\n\tget_attr_nonstring_decl and handle it.\n\t* tree-ssa-strlen.c (maybe_diag_stxncpy_trunc): Same.  Improve\n\tdetection of nul-termination.\n\t(strlen_to_stridx): Change to a pointer.\n\t(handle_builtin_strlen, handle_builtin_stxncpy): Adjust.\n\t(pass_strlen::execute): Same.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/82945\n\t* c-c++-common/Wstringop-truncation-2.c: New test.\n\t* c-c++-common/Wstringop-truncation.c: Adjust.\n\t* c-c++-common/attr-nonstring-2.c: Adjust.\n\t* c-c++-common/attr-nonstring-3.c: New test.\n\nFrom-SVN: r255031", "tree": {"sha": "b3eedddc82aa715ade9b6b34cd5163e5fd23b551", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3eedddc82aa715ade9b6b34cd5163e5fd23b551"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ab2c4ec8dcbe5d0b93d0250abd42ff9fb791e0b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab2c4ec8dcbe5d0b93d0250abd42ff9fb791e0b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab2c4ec8dcbe5d0b93d0250abd42ff9fb791e0b6"}], "stats": {"total": 1098, "additions": 972, "deletions": 126}, "files": [{"sha": "2a4e92fb75176afe270b02663fb14ee16bfb80c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "patch": "@@ -1,3 +1,21 @@\n+2017-11-21  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/82945\n+\t* builtins.c (expand_builtin_strlen): Call maybe_warn_nonstring_arg.\n+\t* calls.h (maybe_warn_nonstring_arg): Declare new function.\n+\t* calls.c (get_attr_nonstring_decl, maybe_warn_nonstring_arg): New\n+\tfunctions.\n+\t(initialize_argument_information): Call maybe_warn_nonstring_arg.\n+\t* calls.h (get_attr_nonstring_decl): Declare new function.\n+\t* doc/extend.texi (attribute nonstring): Update.\n+\t* gimple-fold.c (gimple_fold_builtin_strncpy): Call\n+\tget_attr_nonstring_decl and handle it.\n+\t* tree-ssa-strlen.c (maybe_diag_stxncpy_trunc): Same.  Improve\n+\tdetection of nul-termination.\n+\t(strlen_to_stridx): Change to a pointer.\n+\t(handle_builtin_strlen, handle_builtin_stxncpy): Adjust.\n+\t(pass_strlen::execute): Same.\n+\n 2017-11-21  Sergey Shalnov  <Sergey.Shalnov@intel.com>\n \n \t* config/i386/i386-opts.h (enum prefer_vector_width): Added new enum"}, {"sha": "b97445920170c1bc9b7220442b68d00dc49dde7f", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "patch": "@@ -2885,6 +2885,11 @@ expand_builtin_strlen (tree exp, rtx target,\n       if (!maybe_expand_insn (icode, 4, ops))\n \treturn NULL_RTX;\n \n+      /* Check to see if the argument was declared attribute nonstring\n+\t and if so, issue a warning since at this point it's not known\n+\t to be nul-terminated.  */\n+      maybe_warn_nonstring_arg (TREE_OPERAND (CALL_EXPR_FN (exp), 0), exp);\n+\n       /* Now that we are assured of success, expand the source.  */\n       start_sequence ();\n       pat = expand_expr (src, src_reg, Pmode, EXPAND_NORMAL);"}, {"sha": "cae543c481f70a8666574952905b4d7fad35034c", "filename": "gcc/calls.c", "status": "modified", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "patch": "@@ -1494,6 +1494,210 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n     }\n }\n \n+/* If EXPR refers to a character array or pointer declared attribute\n+   nonstring return a decl for that array or pointer and set *REF to\n+   the referenced enclosing object or pointer.  Otherwise returns\n+   null.  */\n+\n+tree\n+get_attr_nonstring_decl (tree expr, tree *ref)\n+{\n+  tree decl = expr;\n+  if (TREE_CODE (decl) == SSA_NAME)\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (decl);\n+\n+      if (is_gimple_assign (def))\n+\t{\n+\t  tree_code code = gimple_assign_rhs_code (def);\n+\t  if (code == ADDR_EXPR\n+\t      || code == COMPONENT_REF\n+\t      || code == VAR_DECL)\n+\t    decl = gimple_assign_rhs1 (def);\n+\t}\n+      else if (tree var = SSA_NAME_VAR (decl))\n+\tdecl = var;\n+    }\n+\n+  if (TREE_CODE (decl) == ADDR_EXPR)\n+    decl = TREE_OPERAND (decl, 0);\n+\n+  if (ref)\n+    *ref = decl;\n+\n+  if (TREE_CODE (decl) == COMPONENT_REF)\n+    decl = TREE_OPERAND (decl, 1);\n+\n+  if (DECL_P (decl)\n+      && lookup_attribute (\"nonstring\", DECL_ATTRIBUTES (decl)))\n+    return decl;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Check the size argument to the strncmp built-in to see if it's within\n+   the bounds of the arguments and if not, issue a warning.  */\n+\n+static void\n+warn_nonstring_bound (tree fndecl, tree call)\n+{\n+  bool with_bounds = CALL_WITH_BOUNDS_P (call);\n+\n+  tree cnt = CALL_EXPR_ARG (call, with_bounds ? 4 : 2);\n+\n+  tree cntrange[2];\n+  if (!get_size_range (cnt, cntrange))\n+    return;\n+\n+  location_t callloc = EXPR_LOCATION (call);\n+\n+  for (unsigned i = 0; i != 2; ++i)\n+    {\n+      tree str = CALL_EXPR_ARG (call, i + 2 * with_bounds);\n+\n+      tree sref;\n+      tree decl = get_attr_nonstring_decl (str, &sref);\n+      if (!decl)\n+\tcontinue;\n+\n+      tree type = TREE_TYPE (decl);\n+      if (TREE_CODE (type) != ARRAY_TYPE)\n+\tcontinue;\n+\n+      tree dom = TYPE_DOMAIN (type);\n+      if (!dom)\n+\tcontinue;\n+\n+      tree bound = TYPE_MAX_VALUE (dom);\n+      if (!bound)\n+\tcontinue;\n+\n+      bool warned = false;\n+      if (tree_int_cst_le (bound, cntrange[0]))\n+\twarned = warning_at (callloc, OPT_Wstringop_truncation,\n+\t\t\t     \"%qD argument %i declared attribute %<nonstring%> \"\n+\t\t\t     \"is smaller than the specified bound %E\",\n+\t\t\t     fndecl, i, cntrange[0]);\n+      if (warned)\n+\t{\n+\t  location_t loc = DECL_SOURCE_LOCATION (decl);\n+\t  if (loc != UNKNOWN_LOCATION)\n+\t    inform (loc, \"argument %qD declared here\", decl);\n+\t}\n+    }\n+}\n+\n+/* Warn about passing a non-string array/pointer to a function that\n+   expects a nul-terminated string argument.  */\n+\n+void\n+maybe_warn_nonstring_arg (tree fndecl, tree exp)\n+{\n+  if (!fndecl || DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_NORMAL)\n+    return;\n+\n+  bool with_bounds = CALL_WITH_BOUNDS_P (exp);\n+\n+  /* The bound argument to a bounded string function like strncpy.  */\n+  tree bound = NULL_TREE;\n+\n+  /* It's safe to call \"bounded\" string functions with a non-string\n+     argument since the functions provide an explicit bound for this\n+     purpose.  */\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+    case BUILT_IN_STPNCPY:\n+    case BUILT_IN_STPNCPY_CHK:\n+    case BUILT_IN_STRNCMP:\n+    case BUILT_IN_STRNCASECMP:\n+    case BUILT_IN_STRNCPY:\n+    case BUILT_IN_STRNCPY_CHK:\n+      bound = CALL_EXPR_ARG (exp, with_bounds ? 4 : 2);\n+      break;\n+\n+    case BUILT_IN_STRNDUP:\n+      bound = CALL_EXPR_ARG (exp, with_bounds ? 2 : 1);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Determine the range of the bound argument (if specified).  */\n+  tree bndrng[2] = { NULL_TREE, NULL_TREE };\n+  if (bound)\n+    get_size_range (bound, bndrng);\n+\n+  /* Iterate over the built-in function's formal arguments and check\n+     each const char* against the actual argument.  If the actual\n+     argument is declared attribute non-string issue a warning unless\n+     the argument's maximum length is bounded.  */\n+  function_args_iterator it;\n+  function_args_iter_init (&it, TREE_TYPE (fndecl));\n+\n+  for (unsigned argno = 0; ; ++argno, function_args_iter_next (&it))\n+    {\n+      tree argtype = function_args_iter_cond (&it);\n+      if (!argtype)\n+\tbreak;\n+\n+      if (TREE_CODE (argtype) != POINTER_TYPE)\n+\tcontinue;\n+\n+      argtype = TREE_TYPE (argtype);\n+\n+      if (TREE_CODE (argtype) != INTEGER_TYPE\n+\t  || !TYPE_READONLY (argtype))\n+\tcontinue;\n+\n+      argtype = TYPE_MAIN_VARIANT (argtype);\n+      if (argtype != char_type_node)\n+\tcontinue;\n+\n+      tree callarg = CALL_EXPR_ARG (exp, argno);\n+      if (TREE_CODE (callarg) == ADDR_EXPR)\n+\tcallarg = TREE_OPERAND (callarg, 0);\n+\n+      /* See if the destination is declared with attribute \"nonstring\".  */\n+      tree decl = get_attr_nonstring_decl (callarg);\n+      if (!decl)\n+\tcontinue;\n+\n+      tree type = TREE_TYPE (decl);\n+\n+      offset_int wibnd = 0;\n+      if (bndrng[0])\n+\twibnd = wi::to_offset (bndrng[0]);\n+\n+      offset_int asize = wibnd;\n+\n+      if (TREE_CODE (type) == ARRAY_TYPE)\n+\tif (tree arrbnd = TYPE_DOMAIN (type))\n+\t  {\n+\t    if ((arrbnd = TYPE_MAX_VALUE (arrbnd)))\n+\t      asize = wi::to_offset (arrbnd) + 1;\n+\t  }\n+\n+      location_t loc = EXPR_LOCATION (exp);\n+\n+      bool warned = false;\n+\n+      if (wi::ltu_p (asize, wibnd))\n+\twarned = warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t     \"%qD argument %i declared attribute %<nonstring%> \"\n+\t\t\t     \"is smaller than the specified bound %E\",\n+\t\t\t     fndecl, argno + 1, bndrng[0]);\n+      else if (!bound)\n+\twarned = warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t     \"%qD argument %i declared attribute %<nonstring%>\",\n+\t\t\t     fndecl, argno + 1);\n+\n+      if (warned)\n+\tinform (DECL_SOURCE_LOCATION (decl),\n+\t\t\"argument %qD declared here\", decl);\n+    }\n+}\n+\n /* Issue an error if CALL_EXPR was flagged as requiring\n    tall-call optimization.  */\n \n@@ -1943,6 +2147,10 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t alloc_size.  */\n       maybe_warn_alloc_args_overflow (fndecl, exp, alloc_args, alloc_idx);\n     }\n+\n+  /* Detect passing non-string arguments to functions expecting\n+     nul-terminated strings.  */\n+  maybe_warn_nonstring_arg (fndecl, exp);\n }\n \n /* Update ARGS_SIZE to contain the total size for the argument block."}, {"sha": "9b7fa9a2f9c3f2461455980ced04ec9b0e3663b1", "filename": "gcc/calls.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "patch": "@@ -39,5 +39,7 @@ extern bool reference_callee_copied (CUMULATIVE_ARGS *, machine_mode,\n \t\t\t\t     tree, bool);\n extern void maybe_warn_alloc_args_overflow (tree, tree, tree[2], int[2]);\n extern bool get_size_range (tree, tree[2]);\n+extern tree get_attr_nonstring_decl (tree, tree * = NULL);\n+extern void maybe_warn_nonstring_arg (tree, tree);\n \n #endif // GCC_CALLS_H"}, {"sha": "65fc8602860c66270e501dead8481a2912462821", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "patch": "@@ -6008,22 +6008,33 @@ types (@pxref{Common Function Attributes},\n The @code{nonstring} variable attribute specifies that an object or member\n declaration with type array of @code{char} or pointer to @code{char} is\n intended to store character arrays that do not necessarily contain\n-a terminating @code{NUL} character.  This is useful to avoid warnings\n-when such an array or pointer is used as an argument to a bounded string\n-manipulation function such as @code{strncpy}.  For example, without the\n-attribute, GCC will issue a warning for the call below because it may\n-truncate the copy without appending the terminating NUL character.  Using\n-the attribute makes it possible to suppress the warning.\n+a terminating @code{NUL} character.  This is useful in detecting uses\n+of such arrays or pointers with functions that expect NUL-terminated\n+strings, and to avoid warnings when such an array or pointer is used\n+as an argument to a bounded string manipulation function such as\n+@code{strncpy}.  For example, without the attribute, GCC will issue\n+a warning for the @code{strncpy} call below because it may truncate\n+the copy without appending the terminating @code{NUL} character.  Using\n+the attribute makes it possible to suppress the warning.  However, when\n+the array is declared with the attribute the call to @code{strlen} is\n+diagnosed because when the array doesn't contain a @code{NUL}-terminated\n+string the call is undefined.  To copy, compare, of search non-string\n+character arrays use the @code{memcpy}, @code{memcmp}, @code{memchr},\n+and other functions that operate on arrays of bytes.  In addition,\n+calling @code{strnlen} and @code{strndup} with such arrays is safe\n+provided a suitable bound is specified, and not diagnosed.\n \n @smallexample\n struct Data\n @{\n   char name [32] __attribute__ ((nonstring));\n @};\n-void f (struct Data *pd, const char *s)\n+\n+int f (struct Data *pd, const char *s)\n @{\n   strncpy (pd->name, s, sizeof pd->name);\n   @dots{}\n+  return strlen (pd->name);   // unsafe, gets a warning\n @}\n @end smallexample\n "}, {"sha": "ea8f92eab7bb7e23812f0a6959fdcf6d4b950fc1", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 49, "deletions": 59, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "patch": "@@ -62,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"asan.h\"\n #include \"diagnostic-core.h\"\n #include \"intl.h\"\n+#include \"calls.h\"\n \n /* Return true when DECL can be referenced from current unit.\n    FROM_DECL (if non-null) specify constructor of variable DECL was taken from.\n@@ -1558,25 +1559,31 @@ gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi,\n {\n   gimple *stmt = gsi_stmt (*gsi);\n   location_t loc = gimple_location (stmt);\n+  bool nonstring = get_attr_nonstring_decl (dest) != NULL_TREE;\n \n   /* If the LEN parameter is zero, return DEST.  */\n   if (integer_zerop (len))\n     {\n-      tree fndecl = gimple_call_fndecl (stmt);\n-      gcall *call = as_a <gcall *> (stmt);\n-\n-      /* Warn about the lack of nul termination: the result is not\n-\t a (nul-terminated) string.  */\n-      tree slen = get_maxval_strlen (src, 0);\n-      if (slen && !integer_zerop (slen))\n-\twarning_at (loc, OPT_Wstringop_truncation,\n-\t\t    \"%G%qD destination unchanged after copying no bytes \"\n-\t\t    \"from a string of length %E\",\n-\t\t    call, fndecl, slen);\n-      else\n-\twarning_at (loc, OPT_Wstringop_truncation,\n-\t\t    \"%G%qD destination unchanged after copying no bytes\",\n-\t\t    call, fndecl);\n+      /* Avoid warning if the destination refers to a an array/pointer\n+\t decorate with attribute nonstring.  */\n+      if (!nonstring)\n+\t{\n+\t  tree fndecl = gimple_call_fndecl (stmt);\n+\t  gcall *call = as_a <gcall *> (stmt);\n+\n+\t  /* Warn about the lack of nul termination: the result is not\n+\t     a (nul-terminated) string.  */\n+\t  tree slen = get_maxval_strlen (src, 0);\n+\t  if (slen && !integer_zerop (slen))\n+\t    warning_at (loc, OPT_Wstringop_truncation,\n+\t\t\t\"%G%qD destination unchanged after copying no bytes \"\n+\t\t\t\"from a string of length %E\",\n+\t\t\tcall, fndecl, slen);\n+\t  else\n+\t    warning_at (loc, OPT_Wstringop_truncation,\n+\t\t\t\"%G%qD destination unchanged after copying no bytes\",\n+\t\t\tcall, fndecl);\n+\t}\n \n       replace_call_with_value (gsi, dest);\n       return true;\n@@ -1601,53 +1608,36 @@ gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi,\n   if (tree_int_cst_lt (ssize, len))\n     return false;\n \n-  if (tree_int_cst_lt (len, slen))\n-    {\n-      tree fndecl = gimple_call_fndecl (stmt);\n-      gcall *call = as_a <gcall *> (stmt);\n-\n-      warning_at (loc, OPT_Wstringop_truncation,\n-\t\t  (tree_int_cst_equal (size_one_node, len)\n-\t\t   ? G_(\"%G%qD output truncated copying %E byte \"\n-\t\t\t\"from a string of length %E\")\n-\t\t   : G_(\"%G%qD output truncated copying %E bytes \"\n-\t\t      \"from a string of length %E\")),\n-\t\t  call, fndecl, len, slen);\n-    }\n-  else if (tree_int_cst_equal (len, slen))\n+  if (!nonstring)\n     {\n-      tree decl = dest;\n-      if (TREE_CODE (decl) == SSA_NAME)\n+      if (tree_int_cst_lt (len, slen))\n \t{\n-\t  gimple *def_stmt = SSA_NAME_DEF_STMT (decl);\n-\t  if (is_gimple_assign (def_stmt))\n-\t    {\n-\t      tree_code code = gimple_assign_rhs_code (def_stmt);\n-\t      if (code == ADDR_EXPR || code == VAR_DECL)\n-\t\tdecl = gimple_assign_rhs1 (def_stmt);\n-\t    }\n+\t  tree fndecl = gimple_call_fndecl (stmt);\n+\t  gcall *call = as_a <gcall *> (stmt);\n+\n+\t  warning_at (loc, OPT_Wstringop_truncation,\n+\t\t      (tree_int_cst_equal (size_one_node, len)\n+\t\t       ? G_(\"%G%qD output truncated copying %E byte \"\n+\t\t\t    \"from a string of length %E\")\n+\t\t       : G_(\"%G%qD output truncated copying %E bytes \"\n+\t\t\t    \"from a string of length %E\")),\n+\t\t      call, fndecl, len, slen);\n+\t}\n+      else if (tree_int_cst_equal (len, slen))\n+\t{\n+\t  tree fndecl = gimple_call_fndecl (stmt);\n+\t  gcall *call = as_a <gcall *> (stmt);\n+\n+\t  warning_at (loc, OPT_Wstringop_truncation,\n+\t\t      (tree_int_cst_equal (size_one_node, len)\n+\t\t       ? G_(\"%G%qD output truncated before terminating nul \"\n+\t\t\t    \"copying %E byte from a string of the same \"\n+\t\t\t    \"length\")\n+\t\t       : G_(\"%G%qD output truncated before terminating nul \"\n+\t\t\t    \"copying %E bytes from a string of the same \"\n+\t\t\t    \"length\")),\n+\t\t      call, fndecl, len);\n \t}\n-\n-      if (TREE_CODE (decl) == ADDR_EXPR)\n-\tdecl = TREE_OPERAND (decl, 0);\n-\n-      if (TREE_CODE (decl) == COMPONENT_REF)\n-\tdecl = TREE_OPERAND (decl, 1);\n-\n-      tree fndecl = gimple_call_fndecl (stmt);\n-      gcall *call = as_a <gcall *> (stmt);\n-\n-      if (!DECL_P (decl)\n-\t  || !lookup_attribute (\"nonstring\", DECL_ATTRIBUTES (decl)))\n-\twarning_at (loc, OPT_Wstringop_truncation,\n-\t\t    (tree_int_cst_equal (size_one_node, len)\n-\t\t     ? G_(\"%G%qD output truncated before terminating nul \"\n-\t\t\t  \"copying %E byte from a string of the same \"\n-\t\t\t  \"length\")\n-\t\t     : G_(\"%G%qD output truncated before terminating nul \"\n-\t\t\t  \"copying %E bytes from a string of the same \"\n-\t\t\t  \"length\")),\n-\t\t    call, fndecl, len);\n     }\n \n   /* OK transform into builtin memcpy.  */"}, {"sha": "0d86a8685345eaa99e57df8baa4326cc0d7b7ca1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "patch": "@@ -1,3 +1,11 @@\n+2017-11-21  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/82945\n+\t* c-c++-common/Wstringop-truncation-2.c: New test.\n+\t* c-c++-common/Wstringop-truncation.c: Adjust.\n+\t* c-c++-common/attr-nonstring-2.c: Adjust.\n+\t* c-c++-common/attr-nonstring-3.c: New test.\n+\n 2017-11-21  Sergey Shalnov  <Sergey.Shalnov@intel.com>\n \n \t* g++.dg/ext/pr57362.C (__attribute__): Test"}, {"sha": "7b3c182b0fa2971d7b22fa482eb97d291516bb52", "filename": "gcc/testsuite/c-c++-common/Wstringop-truncation-2.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation-2.c?ref=6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "patch": "@@ -0,0 +1,105 @@\n+/* Verify that \n+   { dg-do compile }\n+   { dg-options \"-O2 -Wstringop-truncation -Wno-stringop-overflow -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define stpncpy(d, s, n) __builtin_stpncpy ((d), (s), (n))\n+#define strncpy(d, s, n) __builtin_stpncpy ((d), (s), (n))\n+\n+void sink (void*);\n+\n+struct A {\n+  char arr[3] __attribute__ ((nonstring));\n+  char str[3];\n+};\n+\n+struct B { struct A a[3]; int i; };\n+struct C { struct B b[3]; int i; };\n+\n+void stpncpy_arr_1 (struct C *pc, const char *s)\n+{\n+  stpncpy (pc->b[0].a[0].arr, s, sizeof pc->b[0].a[0].arr);\n+  sink (pc->b[0].a[0].arr);\n+\n+  stpncpy (pc->b[0].a[1].arr, s, sizeof pc->b[0].a[1].arr);\n+  sink (pc->b[0].a[1].arr);\n+\n+  stpncpy (pc->b[0].a[2].arr, s, sizeof pc->b[0].a[2].arr);\n+  sink (pc->b[0].a[2].arr);\n+\n+  stpncpy (pc->b[1].a[0].arr, s, sizeof pc->b[1].a[0].arr);\n+  sink (pc->b[1].a[0].arr);\n+\n+  stpncpy (pc->b[1].a[1].arr, s, sizeof pc->b[1].a[1].arr);\n+  sink (pc->b[1].a[1].arr);\n+\n+  stpncpy (pc->b[1].a[2].arr, s, sizeof pc->b[1].a[2].arr);\n+  sink (pc->b[1].a[2].arr);\n+\n+  stpncpy (pc->b[2].a[0].arr, s, sizeof pc->b[2].a[0].arr);\n+  sink (pc->b[2].a[0].arr);\n+\n+  stpncpy (pc->b[2].a[1].arr, s, sizeof pc->b[2].a[1].arr);\n+  sink (pc->b[2].a[1].arr);\n+\n+  stpncpy (pc->b[2].a[2].arr, s, sizeof pc->b[2].a[2].arr);\n+  sink (pc->b[2].a[2].arr);\n+}\n+\n+void stpncpy_str_nowarn_1 (struct C *pc, const char *s)\n+{\n+  stpncpy (pc->b[0].a[0].str, s, sizeof pc->b[0].a[0].str)[-1] = 0;   /* { dg-bogus \"\\\\\\[-Wstringop-truncation\" } */\n+}\n+\n+void stpncpy_str_nowarn_2 (struct C *pc, const char *s)\n+{\n+  *stpncpy (pc->b[0].a[0].str, s, sizeof pc->b[0].a[0].str - 1) = 0;   /* { dg-bogus \"\\\\\\[-Wstringop-truncation\" } */\n+}\n+\n+void stpncpy_str_nowarn_3 (struct C *pc, const char *s)\n+{\n+  char *d = stpncpy (pc->b[0].a[0].str, s, sizeof pc->b[0].a[0].str);   /* { dg-bogus \"\\\\\\[-Wstringop-truncation\" } */\n+\n+  d[-1] = 0;\n+}\n+\n+void stpncpy_str_nowarn_4 (struct C *pc, const char *s)\n+{\n+  char *d = stpncpy (pc->b[0].a[0].str, s, sizeof pc->b[0].a[0].str - 1);   /* { dg-bogus \"\\\\\\[-Wstringop-truncation\" } */\n+\n+  *d = 0;\n+}\n+\n+void strncpy_arr_1 (struct C *pc, const char *s)\n+{\n+  strncpy (pc->b[0].a[0].arr, s, sizeof pc->b[0].a[0].arr);\n+  sink (pc->b[0].a[0].arr);\n+\n+  strncpy (pc->b[0].a[1].arr, s, sizeof pc->b[0].a[1].arr);\n+  sink (pc->b[0].a[1].arr);\n+\n+  strncpy (pc->b[0].a[2].arr, s, sizeof pc->b[0].a[2].arr);\n+  sink (pc->b[0].a[2].arr);\n+}\n+\n+void strncpy_str_nowarn_1 (struct C *pc, const char *s)\n+{\n+  strncpy (pc->b[0].a[0].str, s, sizeof pc->b[0].a[0].str);   /* { dg-bogus \"\\\\\\[-Wstringop-truncation\" } */\n+\n+  pc->b[0].a[0].str[sizeof pc->b[0].a[0].str - 1] = 0;\n+}\n+\n+void strncpy_str_warn_1 (struct C *pc, const char *s)\n+{\n+  strncpy (pc->b[0].a[0].str, s, sizeof pc->b[0].a[0].str);   /* { dg-warning \"specified bound 3 equals destination size\" } */\n+\n+  pc->b[1].a[0].str[sizeof pc->b[0].a[0].str - 1] = 0;\n+}\n+\n+void strncpy_str_warn_2 (struct C *pc, const char *s)\n+{\n+  strncpy (pc->b[0].a[0].str, s, sizeof pc->b[0].a[0].str);   /* { dg-warning \"specified bound 3 equals destination size\" } */\n+\n+  pc->b[0].a[1].str[sizeof pc->b[0].a[0].str - 1] = 0;\n+}"}, {"sha": "dc8c618976e13cd3de8cc0a070077080d046e578", "filename": "gcc/testsuite/c-c++-common/Wstringop-truncation.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c?ref=6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "patch": "@@ -193,35 +193,35 @@ void test_strncpy_ptr (char *d, const char* s, const char *t, int i)\n   CPY (d, CHOOSE (\"123\", \"12\"), 1); /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated copying 1 byte from a string of length 2\" } */\n \n   {\n-    signed char n = strlen (s);   /* { dg-message \"length computed here\" } */\n+    signed char n = strlen (s);     /* { dg-message \"length computed here\" } */\n     CPY (d, s, n);                  /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying as many bytes from a string as its length\" } */\n   }\n \n   {\n-    short n = strlen (s);         /* { dg-message \"length computed here\" } */\n+    short n = strlen (s);           /* { dg-message \"length computed here\" } */\n     CPY (d, s, n);                  /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying as many bytes from a string as its length\" } */\n   }\n \n   {\n-    int n = strlen (s);           /* { dg-message \"length computed here\" } */\n+    int n = strlen (s);             /* { dg-message \"length computed here\" } */\n     CPY (d, s, n);                  /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying as many bytes from a string as its length\" } */\n   }\n \n   {\n-    unsigned n = strlen (s);      /* { dg-message \"length computed here\" } */\n+    unsigned n = strlen (s);        /* { dg-message \"length computed here\" } */\n     CPY (d, s, n);                  /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying as many bytes from a string as its length\" } */\n   }\n \n   {\n     size_t n;\n-    n = strlen (s);               /* { dg-message \"length computed here\" } */\n+    n = strlen (s);                 /* { dg-message \"length computed here\" } */\n     CPY (d, s, n);                  /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying as many bytes from a string as its length\" } */\n   }\n \n   {\n     size_t n;\n     char *dp2 = d + 1;\n-    n = strlen (s);               /* { dg-message \"length computed here\" } */\n+    n = strlen (s);                 /* { dg-message \"length computed here\" } */\n     CPY (dp2, s, n);                /* { dg-warning \".strncpy\\[^\\n\\r\\]* output truncated before terminating nul copying as many bytes from a string as its length\" } */\n   }\n \n@@ -312,9 +312,11 @@ void test_strncpy_array (Dest *pd, int i, const char* s)\n   /* Exercise destination with attribute \"nonstring\".  */\n   CPY (pd->c3ns, \"\", 3);\n   CPY (pd->c3ns, \"\", 1);\n-  /* Truncation is still diagnosed -- using strncpy in this case is\n-     pointless and should be replaced with memcpy.  */\n-  CPY (pd->c3ns, \"12\", 1);          /* { dg-warning \"output truncated copying 1 byte from a string of length 2\" } */\n+  /* It could be argued that truncation in the literal case should be\n+     diagnosed even for non-strings.  Using strncpy in this case is\n+     pointless and should be replaced with memcpy.  But it would likely\n+     be viewed as a false positive.  */\n+  CPY (pd->c3ns, \"12\", 1);\n   CPY (pd->c3ns, \"12\", 2);\n   CPY (pd->c3ns, \"12\", 3);\n   CPY (pd->c3ns, \"123\", 3);"}, {"sha": "67fce0375d8d4f645b08dd161bfbf1d3abc4553c", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-2.c?ref=6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "patch": "@@ -89,7 +89,7 @@ void test_pointer (const char *s, unsigned n)\n   strncpy (pns_1, \"a\", 1);\n   strncpy (pns_2, \"ab\", 2);\n   strncpy (pns_3, \"abc\", 3);\n-  strncpy (pns_3, s7, 3);         /* { dg-warning \"output truncated copying 3 bytes from a string of length 7\" } */\n+  strncpy (pns_3, s7, 3);\n \n   strncpy (pns_1, s, 1);\n   strncpy (pns_2, s, 1);\n@@ -105,6 +105,7 @@ void test_member_array (struct MemArrays *p, const char *s, unsigned n)\n {\n   const char s7[] = \"1234567\";\n \n+  strncpy (p->ma3, \"\", 0);\n   strncpy (p->ma3, \"a\", 1);\n   strncpy (p->ma4, \"ab\", 2);\n   strncpy (p->ma5, \"abc\", 3);"}, {"sha": "1645ed3ae6d510c2e63b5712befe5be180acd0a8", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-3.c", "status": "added", "additions": 474, "deletions": 0, "changes": 474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c?ref=6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "patch": "@@ -0,0 +1,474 @@\n+/* Test to exercise warnings when an array declared with attribute \"nonstring\"\n+   is passed to a function that expects a nul-terminated string as an argument.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wattributes -Wstringop-overflow -ftrack-macro-expansion=0\" }  */\n+\n+typedef __SIZE_TYPE__       size_t;\n+typedef __builtin_va_list   va_list;\n+\n+#if __cplusplus\n+extern \"C\" {\n+#endif\n+\n+void* memchr (const void*, int, size_t);\n+int memcmp (const void*, const void*, size_t);\n+void* memcpy (void*, const void*, size_t);\n+void* memmove (void*, const void*, size_t);\n+\n+int printf (const char*, ...);\n+int puts (const char*);\n+int puts_unlocked (const char*);\n+int sprintf (char*, const char*, ...);\n+int snprintf (char*, size_t, const char*, ...);\n+int vsprintf (char*, const char*, va_list);\n+int vsnprintf (char*, size_t, const char*, va_list);\n+\n+int strcmp (const char*, const char*);\n+int strncmp (const char*, const char*, size_t);\n+\n+char* stpcpy (char*, const char*);\n+char* stpncpy (char*, const char*, size_t);\n+\n+char* strcat (char*, const char*);\n+char* strncat (char*, const char*, size_t);\n+\n+char* strcpy (char*, const char*);\n+char* strncpy (char*, const char*, size_t);\n+\n+char* strchr (const char*, int);\n+char* strdup (const char*);\n+size_t strlen (const char*);\n+size_t strnlen (const char*, size_t);\n+char* strndup (const char*, size_t);\n+\n+#if __cplusplus\n+}   /* extern \"C\" */\n+#endif\n+\n+#define NONSTRING __attribute__ ((nonstring))\n+\n+char str[4];\n+char arr[4] NONSTRING;\n+\n+char *ptr;\n+char *parr NONSTRING;\n+\n+struct MemArrays\n+{\n+  char str[4];\n+  char arr[4] NONSTRING;\n+  char *parr NONSTRING;\n+};\n+\n+void sink (int, ...);\n+\n+\n+#define T(call)  sink (0, (call))\n+\n+void test_printf (struct MemArrays *p)\n+{\n+  T (printf (str));\n+  T (printf (arr));             /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+  T (printf (ptr));\n+  T (printf (parr));            /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+  T (printf (p->str));\n+  T (printf (p->arr));          /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+}\n+\n+\n+void test_puts (struct MemArrays *p)\n+{\n+  T (puts (str));\n+  T (puts (arr));               /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+  T (puts (ptr));\n+  T (puts (parr));              /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+  T (puts (p->str));\n+  T (puts (p->arr));            /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+}\n+\n+\n+void test_snprintf (char *d, size_t n, struct MemArrays *p)\n+{\n+  T (snprintf (d, n, str));\n+  T (snprintf (d, n, arr));       /* { dg-warning \"argument 3 declared attribute .nonstring.\" } */\n+\n+  T (snprintf (d, n, ptr));\n+  T (snprintf (d, n, parr));      /* { dg-warning \"argument 3 declared attribute .nonstring.\" } */\n+\n+  T (snprintf (d, n, p->str));\n+  T (snprintf (d, n, p->arr));    /* { dg-warning \"argument 3 declared attribute .nonstring.\" } */\n+}\n+\n+\n+void test_sprintf (char *d, struct MemArrays *p)\n+{\n+  T (sprintf (d, str));\n+  T (sprintf (d, arr));           /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+\n+  T (sprintf (d, ptr));\n+  T (sprintf (d, parr));          /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+\n+  T (sprintf (d, p->str));\n+  T (sprintf (d, p->arr));        /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+}\n+\n+\n+void test_vsnprintf (char *d, size_t n, struct MemArrays *p, va_list va)\n+{\n+  T (vsnprintf (d, n, str, va));\n+  T (vsnprintf (d, n, arr, va));  /* { dg-warning \"argument 3 declared attribute .nonstring.\" } */\n+\n+  T (vsnprintf (d, n, ptr, va));\n+  T (vsnprintf (d, n, parr, va)); /* { dg-warning \"argument 3 declared attribute .nonstring.\" } */\n+\n+  T (vsnprintf (d, n, p->str, va));\n+  T (vsnprintf (d, n, p->arr, va)); /* { dg-warning \"argument 3 declared attribute .nonstring.\" } */\n+}\n+\n+\n+void test_vsprintf (char *d, struct MemArrays *p, va_list va)\n+{\n+  T (vsprintf (d, str, va));\n+  T (vsprintf (d, arr, va));      /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+\n+  T (vsprintf (d, ptr, va));\n+  T (vsprintf (d, parr, va));     /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+\n+  T (vsprintf (d, p->str, va));\n+  T (vsprintf (d, p->arr, va));   /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+}\n+\n+\n+void test_strcmp (struct MemArrays *p)\n+{\n+  T (strcmp (str, str));\n+  T (strcmp (str, arr));          /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (strcmp (arr, str));          /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+  T (strcmp (str, ptr));\n+  T (strcmp (str, parr));         /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (strcmp (parr, str));         /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+  T (strcmp (p->str, p->arr));    /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (strcmp (p->arr, p->str));    /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+  T (strcmp (p->parr, p->str));   /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+}\n+\n+\n+void test_strncmp_warn (struct MemArrays *p)\n+{\n+  enum { N = sizeof arr };\n+  T (strncmp (str, arr, N));\n+  T (strncmp (arr, str, N));\n+\n+  T (strncmp (str, arr, N + 1));   /* { dg-warning \"argument 2 declared attribute .nonstring. is smaller than the specified bound 5\" } */\n+  T (strncmp (arr, str, N + 1));   /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 5\" } */\n+\n+  T (strncmp (str, parr, N + 1));\n+  T (strncmp (parr, str, N + 1));\n+\n+  T (strncmp (p->str, p->arr, N));\n+  T (strncmp (p->arr, p->str, N));\n+  T (strncmp (p->parr, p->str, N));\n+\n+  T (strncmp (p->str, p->arr, N));\n+  T (strncmp (p->arr, p->str, N));\n+  T (strncmp (p->parr, p->str, N));\n+}\n+\n+\n+void test_strncmp_nowarn (struct MemArrays *p, size_t n)\n+{\n+  T (strncmp (str, str, n));\n+  T (strncmp (str, arr, n));\n+  T (strncmp (arr, str, n));\n+\n+  T (strncmp (str, ptr, n));\n+  T (strncmp (str, parr, n));\n+  T (strncmp (parr, str, n));\n+\n+  T (strncmp (p->str, p->arr, n));\n+  T (strncmp (p->arr, p->str, n));\n+  T (strncmp (p->parr, p->str, n));\n+}\n+\n+\n+void test_stpcpy (struct MemArrays *p)\n+{\n+  T (stpcpy (str, str));\n+  T (stpcpy (str, arr));          /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (stpcpy (arr, str));\n+\n+  T (stpcpy (str, ptr));\n+  T (stpcpy (str, parr));         /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (stpcpy (parr, str));\n+\n+  T (stpcpy (p->str, p->arr));    /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (stpcpy (p->arr, p->str));\n+  T (stpcpy (p->parr, p->str));\n+}\n+\n+\n+void test_stpncpy_nowarn (struct MemArrays *p, unsigned n)\n+{\n+  T (stpncpy (str, str, n));\n+  T (stpncpy (str, arr, n));\n+  T (stpncpy (arr, str, n));\n+\n+  T (stpncpy (str, ptr, n));\n+  T (stpncpy (str, parr, n));\n+  T (stpncpy (parr, str, n));\n+\n+  T (stpncpy (p->str, p->arr, n));\n+  T (stpncpy (p->arr, p->str, n));\n+  T (stpncpy (p->parr, p->str, n));\n+}\n+\n+\n+void test_stpncpy_warn (struct MemArrays *p, unsigned n)\n+{\n+  enum { N = sizeof arr };\n+\n+  T (stpncpy (str, str, N));\n+  T (stpncpy (str, arr, N));\n+  T (stpncpy (arr, str, N));\n+\n+  T (stpncpy (str, ptr, N));\n+  T (stpncpy (str, parr, N));\n+  T (stpncpy (parr, str, N));\n+\n+  T (stpncpy (p->str, p->arr, N));\n+  T (stpncpy (p->arr, p->str, N));\n+  T (stpncpy (p->parr, p->str, N));\n+\n+  T (stpncpy (ptr, str, N + 1));\n+  T (stpncpy (ptr, arr, N + 1));          /* { dg-warning \"argument 2 declared attribute .nonstring. is smaller than the specified bound 5\" } */\n+  T (stpncpy (arr, str, N + 1));          /* { dg-warning \"writing 5 bytes into a region of size 4 overflows \" } */\n+\n+  T (stpncpy (ptr, ptr, N + 1));\n+  T (stpncpy (ptr, parr, N + 1));\n+  T (stpncpy (parr, str, N + 1));\n+\n+  T (stpncpy (ptr, p->arr, N + 1));       /* { dg-warning \"argument 2 declared attribute .nonstring. is smaller\" } */\n+  T (stpncpy (p->arr, p->str, N + 1));    /* { dg-warning \"writing 5 bytes into a region of size 4 overflows\" } */\n+  T (stpncpy (p->parr, p->str, N + 1));\n+}\n+\n+\n+void test_strcat (struct MemArrays *p)\n+{\n+  T (strcat (str, str));\n+  T (strcat (str, arr));          /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (strcat (arr, str));\n+\n+  T (strcat (str, ptr));\n+  T (strcat (str, parr));         /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (strcat (parr, str));\n+\n+  T (strcat (p->str, p->arr));    /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (strcat (p->arr, p->str));\n+  T (strcat (p->parr, p->str));\n+}\n+\n+\n+void test_strncat (struct MemArrays *p, unsigned n)\n+{\n+  T (strncat (str, str, n));\n+  T (strncat (str, arr, n));      /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (strncat (arr, str, n));\n+\n+  T (strncat (str, ptr, n));\n+  T (strncat (str, parr, n));     /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (strncat (parr, str, n));\n+\n+  T (strncat (p->str, p->arr, n));   /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (strncat (p->arr, p->str, n));\n+  T (strncat (p->parr, p->str, n));\n+}\n+\n+\n+void test_strcpy (struct MemArrays *p)\n+{\n+  T (strcpy (str, str));\n+  T (strcpy (str, arr));          /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (strcpy (arr, str));\n+\n+  T (strcpy (str, ptr));\n+  T (strcpy (str, parr));         /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (strcpy (parr, str));\n+\n+  T (strcpy (p->str, p->arr));    /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  T (strcpy (p->arr, p->str));\n+  T (strcpy (p->parr, p->str));\n+}\n+\n+\n+void test_strncpy (struct MemArrays *p, unsigned n)\n+{\n+  T (strncpy (str, str, n));\n+  T (strncpy (str, arr, n));\n+  T (strncpy (arr, str, n));\n+\n+  T (strncpy (str, ptr, n));\n+  T (strncpy (str, parr, n));\n+  T (strncpy (parr, str, n));\n+\n+  T (strncpy (p->str, p->arr, n));\n+  T (strncpy (p->arr, p->str, n));\n+  T (strncpy (p->parr, p->str, n));\n+}\n+\n+\n+void test_strchr (struct MemArrays *p, int c)\n+{\n+  T (strchr (str, c));\n+  T (strchr (arr, c));          /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+  T (strchr (ptr, c));\n+  T (strchr (parr, c));         /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+  T (strchr (p->str, c));\n+  T (strchr (p->arr, c));       /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+}\n+\n+\n+void test_strdup (struct MemArrays *p)\n+{\n+  T (strdup (str));\n+  T (strdup (arr));             /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+  T (strdup (ptr));\n+  T (strdup (parr));            /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+  T (strdup (p->str));\n+  T (strdup (p->arr));          /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+}\n+\n+\n+void test_stnrdup_nowarn (struct MemArrays *p, size_t n)\n+{\n+  T (strndup (str, n));\n+  T (strndup (arr, n));\n+\n+  T (strndup (ptr, n));\n+  T (strndup (parr, n));\n+\n+  T (strndup (p->str, n));\n+  T (strndup (p->arr, n));\n+}\n+\n+\n+void test_stnrdup_warn (struct MemArrays *p)\n+{\n+  enum { N = sizeof arr };\n+\n+  T (strndup (str, N));\n+  T (strndup (arr, N));\n+\n+  T (strndup (ptr, N));\n+  T (strndup (parr, N));\n+\n+  T (strndup (p->str, N));\n+  T (strndup (p->arr, N));\n+\n+\n+  T (strndup (arr, N + 1));     /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 5\" } */\n+  T (strndup (parr, N + 1));\n+  T (strndup (p->arr, N + 1));  /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 5\" } */\n+  T (strndup (p->parr, N + 1));\n+}\n+\n+\n+void test_strlen (struct MemArrays *p, char *s NONSTRING, size_t n)\n+{\n+  T (strlen (str));\n+  T (strlen (arr));             /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+  T (strlen (ptr));\n+  T (strlen (parr));            /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+  T (strlen (p->str));\n+  T (strlen (p->arr));          /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+  T (strlen (s));               /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+  {\n+    strcpy (s, \"123\");\n+    T (strlen (s));\n+  }\n+\n+  {\n+    char a[] __attribute__ ((nonstring)) = { 1, 2, 3 };\n+\n+    T (strlen (a));             /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+  }\n+\n+  {\n+    char a[] __attribute__ ((nonstring)) = { 1, 2, 3, 4 };\n+\n+    strcpy (a, \"12\");\n+    T (strlen (a));\n+  }\n+\n+  {\n+    char *p __attribute__ ((nonstring));\n+    p = (char *)__builtin_malloc (n);\n+    __builtin_memset (p, '*', n);\n+\n+    T (strlen (p));             /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+\n+    strcpy (p, \"12345\");\n+    T (strlen (p));\n+  }\n+}\n+\n+\n+void test_strnlen (struct MemArrays *p, size_t n)\n+{\n+  T (strnlen (str, n));\n+  T (strnlen (arr, n));\n+\n+  T (strnlen (ptr, n));\n+  T (strnlen (parr, n));\n+\n+  T (strnlen (p->str, n));\n+  T (strnlen (p->arr, n));\n+}\n+\n+\n+/* Verify no warnings are issued for raw mempory functions.  */\n+\n+void test_mem_functions (struct MemArrays *p, int c, size_t n)\n+{\n+  T (memchr (arr, c, n));\n+  T (memchr (parr, c, n));\n+  T (memchr (p->arr, c, n));\n+  T (memchr (p->parr, c, n));\n+\n+  T (memcmp (str, arr, n));\n+  T (memcmp (arr, str, n));\n+  T (memcmp (str, parr, n));\n+  T (memcmp (parr, str, n));\n+  T (memcmp (p->str, p->arr, n));\n+  T (memcmp (p->arr, p->str, n));\n+  T (memcmp (p->parr, p->str, n));\n+\n+  T (memcpy (str, arr, n));\n+  T (memcpy (arr, str, n));\n+  T (memcpy (str, parr, n));\n+  T (memcpy (parr, str, n));\n+  T (memcpy (p->str, p->arr, n));\n+  T (memcpy (p->arr, p->str, n));\n+  T (memcpy (p->parr, p->str, n));\n+\n+  T (memmove (str, arr, n));\n+  T (memmove (arr, str, n));\n+  T (memmove (str, parr, n));\n+  T (memmove (parr, str, n));\n+  T (memmove (p->str, p->arr, n));\n+  T (memmove (p->arr, p->str, n));\n+  T (memmove (p->parr, p->str, n));\n+}"}, {"sha": "48b92417b57411d5f91e1ed751005d927ece4ea5", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 72, "deletions": 50, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a33d0ff21e941fc3a65f23a753cc318aaae82b5/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=6a33d0ff21e941fc3a65f23a753cc318aaae82b5", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"intl.h\"\n #include \"attribs.h\"\n+#include \"calls.h\"\n \n /* A vector indexed by SSA_NAME_VERSION.  0 means unknown, positive value\n    is an index into strinfo vector, negative value stands for\n@@ -152,8 +153,11 @@ struct decl_stridxlist_map\n    mappings.  */\n static hash_map<tree_decl_hash, stridxlist> *decl_to_stridxlist_htab;\n \n+/* Hash table mapping strlen calls to stridx instances describing\n+   the calls' arguments.  Non-null only when warn_stringop_truncation\n+   is non-zero.  */\n typedef std::pair<int, location_t> stridx_strlenloc;\n-static hash_map<tree, stridx_strlenloc> strlen_to_stridx;\n+static hash_map<tree, stridx_strlenloc> *strlen_to_stridx;\n \n /* Obstack for struct stridxlist and struct decl_stridxlist_map.  */\n static struct obstack stridx_obstack;\n@@ -1207,8 +1211,11 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t      gcc_assert (si->full_string_p);\n \t    }\n \n-\t  location_t loc = gimple_location (stmt);\n-\t  strlen_to_stridx.put (lhs, stridx_strlenloc (idx, loc));\n+\t  if (strlen_to_stridx)\n+\t    {\n+\t      location_t loc = gimple_location (stmt);\n+\t      strlen_to_stridx->put (lhs, stridx_strlenloc (idx, loc));\n+\t    }\n \t  return;\n \t}\n     }\n@@ -1253,8 +1260,11 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n       set_strinfo (idx, si);\n       find_equal_ptrs (src, idx);\n \n-      location_t loc = gimple_location (stmt);\n-      strlen_to_stridx.put (lhs, stridx_strlenloc (idx, loc));\n+      if (strlen_to_stridx)\n+\t{\n+\t  location_t loc = gimple_location (stmt);\n+\t  strlen_to_stridx->put (lhs, stridx_strlenloc (idx, loc));\n+\t}\n     }\n }\n \n@@ -1691,9 +1701,6 @@ is_strlen_related_p (tree src, tree len)\n static bool\n maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n {\n-  if (!warn_stringop_truncation)\n-    return false;\n-\n   gimple *stmt = gsi_stmt (gsi);\n \n   wide_int cntrange[2];\n@@ -1733,35 +1740,15 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n     return false;\n \n   tree dst = gimple_call_arg (stmt, 0);\n-\n-  /* See if the destination is declared with attribute \"nonstring\"\n-     and if so, avoid the truncation warning.  */\n-  if (TREE_CODE (dst) == SSA_NAME)\n-    {\n-      if (SSA_NAME_IS_DEFAULT_DEF (dst))\n-\tdst = SSA_NAME_VAR (dst);\n-      else\n-\t{\n-\t  gimple *def = SSA_NAME_DEF_STMT (dst);\n-\n-\t  if (is_gimple_assign (def)\n-\t      && gimple_assign_rhs_code (def) == ADDR_EXPR)\n-\t    dst = gimple_assign_rhs1 (def);\n-\t}\n-    }\n-\n   tree dstdecl = dst;\n   if (TREE_CODE (dstdecl) == ADDR_EXPR)\n     dstdecl = TREE_OPERAND (dstdecl, 0);\n \n-  {\n-    tree d = dstdecl;\n-    if (TREE_CODE (d) == COMPONENT_REF)\n-      d = TREE_OPERAND (d, 1);\n-\n-    if (DECL_P (d) && lookup_attribute (\"nonstring\", DECL_ATTRIBUTES (d)))\n-      return false;\n-  }\n+  /* If the destination refers to a an array/pointer declared nonstring\n+     return early.  */\n+  tree ref = NULL_TREE;\n+  if (get_attr_nonstring_decl (dstdecl, &ref))\n+    return false;\n \n   /* Look for dst[i] = '\\0'; after the stxncpy() call and if found\n      avoid the truncation warning.  */\n@@ -1770,12 +1757,32 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n \n   if (!gsi_end_p (gsi) && is_gimple_assign (next_stmt))\n     {\n-      HOST_WIDE_INT off;\n-      dstdecl = get_addr_base_and_unit_offset (dstdecl, &off);\n-\n       tree lhs = gimple_assign_lhs (next_stmt);\n-      tree lhsbase = get_addr_base_and_unit_offset (lhs, &off);\n-      if (lhsbase && operand_equal_p (dstdecl, lhsbase, 0))\n+      tree_code code = TREE_CODE (lhs);\n+      if (code == ARRAY_REF || code == MEM_REF)\n+\tlhs = TREE_OPERAND (lhs, 0);\n+\n+      tree func = gimple_call_fndecl (stmt);\n+      if (DECL_FUNCTION_CODE (func) == BUILT_IN_STPNCPY)\n+\t{\n+\t  tree ret = gimple_call_lhs (stmt);\n+\t  if (ret && operand_equal_p (ret, lhs, 0))\n+\t    return false;\n+\t}\n+\n+      /* Determine the base address and offset of the reference,\n+\t ignoring the innermost array index.  */\n+      if (TREE_CODE (ref) == ARRAY_REF)\n+\tref = TREE_OPERAND (ref, 0);\n+\n+      HOST_WIDE_INT dstoff;\n+      tree dstbase = get_addr_base_and_unit_offset (ref, &dstoff);\n+\n+      HOST_WIDE_INT lhsoff;\n+      tree lhsbase = get_addr_base_and_unit_offset (lhs, &lhsoff);\n+      if (lhsbase\n+\t  && dstoff == lhsoff\n+\t  && operand_equal_p (dstbase, lhsbase, 0))\n \treturn false;\n     }\n \n@@ -1909,6 +1916,9 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n static void\n handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *gsi)\n {\n+  if (!strlen_to_stridx)\n+    return;\n+\n   gimple *stmt = gsi_stmt (*gsi);\n \n   bool with_bounds = gimple_call_with_bounds_p (stmt);\n@@ -1919,7 +1929,7 @@ handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *gsi)\n   /* If the length argument was computed from strlen(S) for some string\n      S retrieve the strinfo index for the string (PSS->FIRST) alonng with\n      the location of the strlen() call (PSS->SECOND).  */\n-  stridx_strlenloc *pss = strlen_to_stridx.get (len);\n+  stridx_strlenloc *pss = strlen_to_stridx->get (len);\n   if (!pss || pss->first <= 0)\n     {\n       if (maybe_diag_stxncpy_trunc (*gsi, src, len))\n@@ -1953,13 +1963,13 @@ handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *gsi)\n      whether its value is known.  Otherwise, issue the more generic\n      -Wstringop-overflow which triggers for LEN arguments that in\n      any meaningful way depend on strlen(SRC).  */\n-  if (warn_stringop_truncation\n-      && sisrc == silen\n-      && is_strlen_related_p (src, len))\n-    warned = warning_at (callloc, OPT_Wstringop_truncation,\n-\t\t\t \"%qD output truncated before terminating nul \"\n-\t\t\t \"copying as many bytes from a string as its length\",\n-\t\t\t func);\n+  if (sisrc == silen\n+      && is_strlen_related_p (src, len)\n+      && warning_at (callloc, OPT_Wstringop_truncation,\n+\t\t     \"%qD output truncated before terminating nul \"\n+\t\t     \"copying as many bytes from a string as its length\",\n+\t\t     func))\n+    warned = true;\n   else if (silen && is_strlen_related_p (src, silen->ptr))\n     warned = warning_at (callloc, OPT_Wstringop_overflow_,\n \t\t\t \"%qD specified bound depends on the length \"\n@@ -2966,9 +2976,12 @@ strlen_optimize_stmt (gimple_stmt_iterator *gsi)\n \t  fold_strstr_to_strncmp (gimple_assign_rhs1 (stmt),\n \t\t\t\t  gimple_assign_rhs2 (stmt), stmt);\n \n-\ttree rhs1 = gimple_assign_rhs1 (stmt);\n-\tif (stridx_strlenloc *ps = strlen_to_stridx.get (rhs1))\n-\t  strlen_to_stridx.put (lhs, stridx_strlenloc (*ps));\n+\tif (strlen_to_stridx)\n+\t  {\n+\t    tree rhs1 = gimple_assign_rhs1 (stmt);\n+\t    if (stridx_strlenloc *ps = strlen_to_stridx->get (rhs1))\n+\t      strlen_to_stridx->put (lhs, stridx_strlenloc (*ps));\n+\t  }\n       }\n     else if (TREE_CODE (lhs) != SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n \t{\n@@ -3199,6 +3212,10 @@ class pass_strlen : public gimple_opt_pass\n unsigned int\n pass_strlen::execute (function *fun)\n {\n+  gcc_assert (!strlen_to_stridx);\n+  if (warn_stringop_overflow || warn_stringop_truncation)\n+    strlen_to_stridx = new hash_map<tree, stridx_strlenloc> ();\n+\n   ssa_ver_to_stridx.safe_grow_cleared (num_ssa_names);\n   max_stridx = 1;\n \n@@ -3220,7 +3237,12 @@ pass_strlen::execute (function *fun)\n   laststmt.len = NULL_TREE;\n   laststmt.stridx = 0;\n \n-  strlen_to_stridx.empty ();\n+  if (strlen_to_stridx)\n+    {\n+      strlen_to_stridx->empty ();\n+      delete strlen_to_stridx;\n+      strlen_to_stridx = NULL;\n+    }\n \n   return 0;\n }"}]}