{"sha": "9d5f3b7a694ceb774330d45894b38e34bb90f86a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ1ZjNiN2E2OTRjZWI3NzQzMzBkNDU4OTRiMzhlMzRiYjkwZjg2YQ==", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2020-12-07T15:45:23Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-04-28T09:38:08Z"}, "message": "[Ada] Use spans instead of locations for compiler diagnostics\n\ngcc/ada/\n\n\t* errout.adb: (Error_Msg_Internal): Use span instead of\n\tlocation.\n\t(Error_Msg, Error_Msg_NEL): Add versions with span parameter.\n\t(Error_Msg_F, Error_Msg_FE, Error_Msg_N, Error_Msg_NE,\n\tError_Msg_NW): Retrieve span from node.\n\t(First_Node): Use the new First_And_Last_Nodes.\n\t(First_And_Last_Nodes): Expand on previous First_Node. Apply to\n\tother nodes than expressions.\n\t(First_Sloc): Protect against inconsistent locations.\n\t(Last_Node): New function based on First_And_Last_Nodes.\n\t(Last_Sloc): New function similar to First_Sloc.\n\t(Output_Messages): Update output when -gnatdF is used. Use\n\tcharacter ~ for making the span visible, similar to what is done\n\tin GCC and Clang.\n\t* errout.ads (Error_Msg, Error_Msg_NEL): Add versions with span\n\tparameter.\n\t(First_And_Last_Nodes, Last_Node, Last_Sloc): New subprograms.\n\t* erroutc.adb: Adapt to Sptr field being a span.\n\t* erroutc.ads (Error_Msg_Object): Change field Sptr from\n\tlocation to span.\n\t* errutil.adb: Adapt to Sptr field being a span.\n\t* freeze.adb: Use Errout reporting procedures for nodes to get\n\tspans.\n\t* par-ch3.adb: Likewise.\n\t* par-prag.adb: Likewise.\n\t* par-util.adb: Likewise.\n\t* sem_case.adb: Likewise.\n\t* sem_ch13.adb: Likewise.\n\t* sem_ch3.adb: Likewise.\n\t* sem_prag.adb: Likewise.\n\t* types.ads: (Source_Span): New type for spans.\n\t(To_Span): Basic constructors for spans.", "tree": {"sha": "f9755e604cf4629f136eec728632b29475f8d069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9755e604cf4629f136eec728632b29475f8d069"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d5f3b7a694ceb774330d45894b38e34bb90f86a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d5f3b7a694ceb774330d45894b38e34bb90f86a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d5f3b7a694ceb774330d45894b38e34bb90f86a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d5f3b7a694ceb774330d45894b38e34bb90f86a/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae77b299e9717e3a76ac6b7be65145a50aa31ed2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae77b299e9717e3a76ac6b7be65145a50aa31ed2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae77b299e9717e3a76ac6b7be65145a50aa31ed2"}], "stats": {"total": 635, "additions": 479, "deletions": 156}, "files": [{"sha": "97fd9d4e56800c75009fa89199660f410bdf1d86", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 380, "deletions": 86, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -98,8 +98,8 @@ package body Errout is\n \n    procedure Error_Msg_Internal\n      (Msg      : String;\n-      Sptr     : Source_Ptr;\n-      Optr     : Source_Ptr;\n+      Span     : Source_Span;\n+      Opan     : Source_Span;\n       Msg_Cont : Boolean;\n       Node     : Node_Id);\n    --  This is the low level routine used to post messages after dealing with\n@@ -218,7 +218,7 @@ package body Errout is\n       Err_Id    : Error_Msg_Id := Error_Id;\n \n    begin\n-      Set_Msg_Text (New_Msg, Errors.Table (Error_Id).Sptr);\n+      Set_Msg_Text (New_Msg, Errors.Table (Error_Id).Sptr.Ptr);\n       Errors.Table (Error_Id).Text := new String'(Msg_Buffer (1 .. Msglen));\n \n       --  If in immediate error message mode, output modified error message now\n@@ -300,14 +300,19 @@ package body Errout is\n    ---------------\n \n    --  Error_Msg posts a flag at the given location, except that if the\n-   --  Flag_Location points within a generic template and corresponds to an\n-   --  instantiation of this generic template, then the actual message will be\n-   --  posted on the generic instantiation, along with additional messages\n-   --  referencing the generic declaration.\n+   --  Flag_Location/Flag_Span points within a generic template and corresponds\n+   --  to an instantiation of this generic template, then the actual message\n+   --  will be posted on the generic instantiation, along with additional\n+   --  messages referencing the generic declaration.\n \n    procedure Error_Msg (Msg : String; Flag_Location : Source_Ptr) is\n    begin\n-      Error_Msg (Msg, Flag_Location, Current_Node);\n+      Error_Msg (Msg, To_Span (Flag_Location), Current_Node);\n+   end Error_Msg;\n+\n+   procedure Error_Msg (Msg : String; Flag_Span : Source_Span) is\n+   begin\n+      Error_Msg (Msg, Flag_Span, Current_Node);\n    end Error_Msg;\n \n    procedure Error_Msg\n@@ -318,7 +323,7 @@ package body Errout is\n       Save_Is_Compile_Time_Msg : constant Boolean := Is_Compile_Time_Msg;\n    begin\n       Is_Compile_Time_Msg := Is_Compile_Time_Pragma;\n-      Error_Msg (Msg, Flag_Location, Current_Node);\n+      Error_Msg (Msg, To_Span (Flag_Location), Current_Node);\n       Is_Compile_Time_Msg := Save_Is_Compile_Time_Msg;\n    end Error_Msg;\n \n@@ -327,6 +332,17 @@ package body Errout is\n       Flag_Location : Source_Ptr;\n       N             : Node_Id)\n    is\n+   begin\n+      Error_Msg (Msg, To_Span (Flag_Location), N);\n+   end Error_Msg;\n+\n+   procedure Error_Msg\n+     (Msg       : String;\n+      Flag_Span : Source_Span;\n+      N         : Node_Id)\n+   is\n+      Flag_Location : constant Source_Ptr := Flag_Span.Ptr;\n+\n       Sindex : Source_File_Index;\n       --  Source index for flag location\n \n@@ -429,7 +445,7 @@ package body Errout is\n       --  Error_Msg_Internal to place the message in the requested location.\n \n       if Instantiation (Sindex) = No_Location then\n-         Error_Msg_Internal (Msg, Flag_Location, Flag_Location, False, N);\n+         Error_Msg_Internal (Msg, Flag_Span, Flag_Span, False, N);\n          return;\n       end if;\n \n@@ -525,32 +541,32 @@ package body Errout is\n                   if Is_Info_Msg then\n                      Error_Msg_Internal\n                        (Msg      => \"info: in inlined body #\",\n-                        Sptr     => Actual_Error_Loc,\n-                        Optr     => Flag_Location,\n+                        Span     => To_Span (Actual_Error_Loc),\n+                        Opan     => Flag_Span,\n                         Msg_Cont => Msg_Cont_Status,\n                         Node     => N);\n \n                   elsif Is_Warning_Msg then\n                      Error_Msg_Internal\n                        (Msg      => Warn_Insertion & \"in inlined body #\",\n-                        Sptr     => Actual_Error_Loc,\n-                        Optr     => Flag_Location,\n+                        Span     => To_Span (Actual_Error_Loc),\n+                        Opan     => Flag_Span,\n                         Msg_Cont => Msg_Cont_Status,\n                         Node     => N);\n \n                   elsif Is_Style_Msg then\n                      Error_Msg_Internal\n                        (Msg      => \"style: in inlined body #\",\n-                        Sptr     => Actual_Error_Loc,\n-                        Optr     => Flag_Location,\n+                        Span     => To_Span (Actual_Error_Loc),\n+                        Opan     => Flag_Span,\n                         Msg_Cont => Msg_Cont_Status,\n                         Node     => N);\n \n                   else\n                      Error_Msg_Internal\n                        (Msg      => \"error in inlined body #\",\n-                        Sptr     => Actual_Error_Loc,\n-                        Optr     => Flag_Location,\n+                        Span     => To_Span (Actual_Error_Loc),\n+                        Opan     => Flag_Span,\n                         Msg_Cont => Msg_Cont_Status,\n                         Node     => N);\n                   end if;\n@@ -561,32 +577,32 @@ package body Errout is\n                   if Is_Info_Msg then\n                      Error_Msg_Internal\n                        (Msg      => \"info: in instantiation #\",\n-                        Sptr     => Actual_Error_Loc,\n-                        Optr     => Flag_Location,\n+                        Span     => To_Span (Actual_Error_Loc),\n+                        Opan     => Flag_Span,\n                         Msg_Cont => Msg_Cont_Status,\n                         Node     => N);\n \n                   elsif Is_Warning_Msg then\n                      Error_Msg_Internal\n                        (Msg      => Warn_Insertion & \"in instantiation #\",\n-                        Sptr     => Actual_Error_Loc,\n-                        Optr     => Flag_Location,\n+                        Span     => To_Span (Actual_Error_Loc),\n+                        Opan     => Flag_Span,\n                         Msg_Cont => Msg_Cont_Status,\n                         Node     => N);\n \n                   elsif Is_Style_Msg then\n                      Error_Msg_Internal\n                        (Msg      => \"style: in instantiation #\",\n-                        Sptr     => Actual_Error_Loc,\n-                        Optr     => Flag_Location,\n+                        Span     => To_Span (Actual_Error_Loc),\n+                        Opan     => Flag_Span,\n                         Msg_Cont => Msg_Cont_Status,\n                         Node     => N);\n \n                   else\n                      Error_Msg_Internal\n                        (Msg      => \"instantiation error #\",\n-                        Sptr     => Actual_Error_Loc,\n-                        Optr     => Flag_Location,\n+                        Span     => To_Span (Actual_Error_Loc),\n+                        Opan     => Flag_Span,\n                         Msg_Cont => Msg_Cont_Status,\n                         Node     => N);\n                   end if;\n@@ -605,8 +621,8 @@ package body Errout is\n \n          Error_Msg_Internal\n            (Msg      => Msg,\n-            Sptr     => Actual_Error_Loc,\n-            Optr     => Flag_Location,\n+            Span     => To_Span (Actual_Error_Loc),\n+            Opan     => Flag_Span,\n             Msg_Cont => Msg_Cont_Status,\n             Node     => N);\n       end;\n@@ -834,8 +850,13 @@ package body Errout is\n    -----------------\n \n    procedure Error_Msg_F (Msg : String; N : Node_Id) is\n+      Fst, Lst : Node_Id;\n    begin\n-      Error_Msg_NEL (Msg, N, N, Sloc (First_Node (N)));\n+      First_And_Last_Nodes (N, Fst, Lst);\n+      Error_Msg_NEL (Msg, N, N,\n+                     To_Span (Ptr   => Sloc (Fst),\n+                              First => First_Sloc (Fst),\n+                              Last  => Last_Sloc (Lst)));\n    end Error_Msg_F;\n \n    ------------------\n@@ -847,8 +868,13 @@ package body Errout is\n       N   : Node_Id;\n       E   : Node_Or_Entity_Id)\n    is\n+      Fst, Lst : Node_Id;\n    begin\n-      Error_Msg_NEL (Msg, N, E, Sloc (First_Node (N)));\n+      First_And_Last_Nodes (N, Fst, Lst);\n+      Error_Msg_NEL (Msg, N, E,\n+                     To_Span (Ptr   => Sloc (Fst),\n+                              First => First_Sloc (Fst),\n+                              Last  => Last_Sloc (Lst)));\n    end Error_Msg_FE;\n \n    ------------------------\n@@ -857,11 +883,14 @@ package body Errout is\n \n    procedure Error_Msg_Internal\n      (Msg      : String;\n-      Sptr     : Source_Ptr;\n-      Optr     : Source_Ptr;\n+      Span     : Source_Span;\n+      Opan     : Source_Span;\n       Msg_Cont : Boolean;\n       Node     : Node_Id)\n    is\n+      Sptr     : constant Source_Ptr := Span.Ptr;\n+      Optr     : constant Source_Ptr := Opan.Ptr;\n+\n       Next_Msg : Error_Msg_Id;\n       --  Pointer to next message at insertion point\n \n@@ -1136,7 +1165,7 @@ package body Errout is\n         ((Text                => new String'(Msg_Buffer (1 .. Msglen)),\n           Next                => No_Error_Msg,\n           Prev                => No_Error_Msg,\n-          Sptr                => Sptr,\n+          Sptr                => Span,\n           Optr                => Optr,\n           Insertion_Sloc      => (if Has_Insertion_Line then Error_Msg_Sloc\n                                   else No_Location),\n@@ -1196,9 +1225,9 @@ package body Errout is\n          if Last_Error_Msg /= No_Error_Msg\n            and then Errors.Table (Cur_Msg).Sfile =\n                     Errors.Table (Last_Error_Msg).Sfile\n-           and then (Sptr > Errors.Table (Last_Error_Msg).Sptr\n+           and then (Sptr > Errors.Table (Last_Error_Msg).Sptr.Ptr\n                        or else\n-                          (Sptr = Errors.Table (Last_Error_Msg).Sptr\n+                          (Sptr = Errors.Table (Last_Error_Msg).Sptr.Ptr\n                              and then\n                                Optr > Errors.Table (Last_Error_Msg).Optr))\n          then\n@@ -1216,8 +1245,8 @@ package body Errout is\n \n                if Errors.Table (Cur_Msg).Sfile = Errors.Table (Next_Msg).Sfile\n                then\n-                  exit when Sptr < Errors.Table (Next_Msg).Sptr\n-                    or else (Sptr = Errors.Table (Next_Msg).Sptr\n+                  exit when Sptr < Errors.Table (Next_Msg).Sptr.Ptr\n+                    or else (Sptr = Errors.Table (Next_Msg).Sptr.Ptr\n                               and then Optr < Errors.Table (Next_Msg).Optr);\n                end if;\n \n@@ -1364,8 +1393,13 @@ package body Errout is\n    -----------------\n \n    procedure Error_Msg_N (Msg : String; N : Node_Or_Entity_Id) is\n+      Fst, Lst : Node_Id;\n    begin\n-      Error_Msg_NEL (Msg, N, N, Sloc (N));\n+      First_And_Last_Nodes (N, Fst, Lst);\n+      Error_Msg_NEL (Msg, N, N,\n+                     To_Span (Ptr   => Sloc (N),\n+                              First => First_Sloc (Fst),\n+                              Last  => Last_Sloc (Lst)));\n    end Error_Msg_N;\n \n    ------------------\n@@ -1377,8 +1411,13 @@ package body Errout is\n       N   : Node_Or_Entity_Id;\n       E   : Node_Or_Entity_Id)\n    is\n+      Fst, Lst : Node_Id;\n    begin\n-      Error_Msg_NEL (Msg, N, E, Sloc (N));\n+      First_And_Last_Nodes (N, Fst, Lst);\n+      Error_Msg_NEL (Msg, N, E,\n+                     To_Span (Ptr   => Sloc (N),\n+                              First => First_Sloc (Fst),\n+                              Last  => Last_Sloc (Lst)));\n    end Error_Msg_NE;\n \n    -------------------\n@@ -1391,6 +1430,16 @@ package body Errout is\n       E             : Node_Or_Entity_Id;\n       Flag_Location : Source_Ptr)\n    is\n+   begin\n+      Error_Msg_NEL (Msg, N, E, To_Span (Flag_Location));\n+   end Error_Msg_NEL;\n+\n+   procedure Error_Msg_NEL\n+     (Msg       : String;\n+      N         : Node_Or_Entity_Id;\n+      E         : Node_Or_Entity_Id;\n+      Flag_Span : Source_Span)\n+   is\n    begin\n       if Special_Msg_Delete (Msg, N, E) then\n          return;\n@@ -1443,7 +1492,7 @@ package body Errout is\n       then\n          Debug_Output (N);\n          Error_Msg_Node_1 := E;\n-         Error_Msg (Msg, Flag_Location, N);\n+         Error_Msg (Msg, Flag_Span, N);\n \n       else\n          Last_Killed := True;\n@@ -1463,12 +1512,17 @@ package body Errout is\n       Msg   : String;\n       N     : Node_Or_Entity_Id)\n    is\n+      Fst, Lst : Node_Id;\n    begin\n       if Eflag\n         and then In_Extended_Main_Source_Unit (N)\n         and then Comes_From_Source (N)\n       then\n-         Error_Msg_NEL (Msg, N, N, Sloc (N));\n+         First_And_Last_Nodes (N, Fst, Lst);\n+         Error_Msg_NEL (Msg, N, N,\n+                        To_Span (Ptr   => Sloc (N),\n+                                 First => First_Sloc (Fst),\n+                                 Last  => Last_Sloc (Lst)));\n       end if;\n    end Error_Msg_NW;\n \n@@ -1563,7 +1617,7 @@ package body Errout is\n \n          F := Nxt;\n          while F /= No_Error_Msg\n-           and then Errors.Table (F).Sptr = Errors.Table (Cur).Sptr\n+           and then Errors.Table (F).Sptr.Ptr = Errors.Table (Cur).Sptr.Ptr\n          loop\n             Check_Duplicate_Message (Cur, F);\n             F := Errors.Table (F).Next;\n@@ -1583,8 +1637,8 @@ package body Errout is\n          begin\n             if (CE.Warn and not CE.Deleted)\n               and then\n-                   (Warning_Specifically_Suppressed (CE.Sptr, CE.Text, Tag) /=\n-                                                                   No_String\n+                   (Warning_Specifically_Suppressed (CE.Sptr.Ptr, CE.Text, Tag)\n+                                                                /= No_String\n                       or else\n                     Warning_Specifically_Suppressed (CE.Optr, CE.Text, Tag) /=\n                                                                    No_String)\n@@ -1630,23 +1684,40 @@ package body Errout is\n    ----------------\n \n    function First_Node (C : Node_Id) return Node_Id is\n+      Fst, Lst : Node_Id;\n+   begin\n+      First_And_Last_Nodes (C, Fst, Lst);\n+      return Fst;\n+   end First_Node;\n+\n+   --------------------------\n+   -- First_And_Last_Nodes --\n+   --------------------------\n+\n+   procedure First_And_Last_Nodes\n+     (C                     : Node_Id;\n+      First_Node, Last_Node : out Node_Id)\n+   is\n       Orig     : constant Node_Id           := Original_Node (C);\n       Loc      : constant Source_Ptr        := Sloc (Orig);\n       Sfile    : constant Source_File_Index := Get_Source_File_Index (Loc);\n       Earliest : Node_Id;\n+      Latest   : Node_Id;\n       Eloc     : Source_Ptr;\n+      Lloc     : Source_Ptr;\n \n-      function Test_Earlier (N : Node_Id) return Traverse_Result;\n+      function Test_First_And_Last (N : Node_Id) return Traverse_Result;\n       --  Function applied to every node in the construct\n \n-      procedure Search_Tree_First is new Traverse_Proc (Test_Earlier);\n+      procedure Search_Tree_First_And_Last is new\n+        Traverse_Proc (Test_First_And_Last);\n       --  Create traversal procedure\n \n-      ------------------\n-      -- Test_Earlier --\n-      ------------------\n+      -------------------------\n+      -- Test_First_And_Last --\n+      -------------------------\n \n-      function Test_Earlier (N : Node_Id) return Traverse_Result is\n+      function Test_First_And_Last (N : Node_Id) return Traverse_Result is\n          Norig : constant Node_Id    := Original_Node (N);\n          Loc   : constant Source_Ptr := Sloc (Norig);\n \n@@ -1670,22 +1741,61 @@ package body Errout is\n             Eloc     := Loc;\n          end if;\n \n+         --  Check for later\n+\n+         if Loc > Lloc\n+\n+           --  Ignore nodes with no useful location information\n+\n+           and then Loc /= Standard_Location\n+           and then Loc /= No_Location\n+\n+           --  Ignore nodes from a different file. This ensures against cases\n+           --  of strange foreign code somehow being present. We don't want\n+           --  wild placement of messages if that happens.\n+\n+           and then Get_Source_File_Index (Loc) = Sfile\n+         then\n+            Latest := Norig;\n+            Lloc     := Loc;\n+         end if;\n+\n          return OK_Orig;\n-      end Test_Earlier;\n+      end Test_First_And_Last;\n \n-   --  Start of processing for First_Node\n+   --  Start of processing for First_And_Last_Nodes\n \n    begin\n-      if Nkind (Orig) in N_Subexpr then\n+      if Nkind (Orig) in N_Subexpr\n+                       | N_Declaration\n+                       | N_Access_To_Subprogram_Definition\n+                       | N_Generic_Instantiation\n+                       | N_Subprogram_Declaration\n+                       | N_Use_Package_Clause\n+                       | N_Array_Type_Definition\n+                       | N_Renaming_Declaration\n+                       | N_Generic_Renaming_Declaration\n+                       | N_Assignment_Statement\n+                       | N_Raise_Statement\n+                       | N_Simple_Return_Statement\n+                       | N_Exit_Statement\n+                       | N_Pragma\n+                       | N_Use_Type_Clause\n+                       | N_With_Clause\n+      then\n          Earliest := Orig;\n          Eloc := Loc;\n-         Search_Tree_First (Orig);\n-         return Earliest;\n+         Latest := Orig;\n+         Lloc := Loc;\n+         Search_Tree_First_And_Last (Orig);\n+         First_Node := Earliest;\n+         Last_Node := Latest;\n \n       else\n-         return Orig;\n+         First_Node := Orig;\n+         Last_Node := Orig;\n       end if;\n-   end First_Node;\n+   end First_And_Last_Nodes;\n \n    ----------------\n    -- First_Sloc --\n@@ -1694,13 +1804,22 @@ package body Errout is\n    function First_Sloc (N : Node_Id) return Source_Ptr is\n       SI : constant Source_File_Index := Source_Index (Get_Source_Unit (N));\n       SF : constant Source_Ptr        := Source_First (SI);\n+      SL : constant Source_Ptr        := Source_Last (SI);\n       F  : Node_Id;\n       S  : Source_Ptr;\n \n    begin\n       F := First_Node (N);\n       S := Sloc (F);\n \n+      --  ??? Protect against inconsistency in locations, by returning S\n+      --  immediately if not in the expected range, rather than failing with\n+      --  a Constraint_Error when accessing Source_Text(SI)(S)\n+\n+      if S not in SF .. SL then\n+         return S;\n+      end if;\n+\n       --  The following circuit is a bit subtle. When we have parenthesized\n       --  expressions, then the Sloc will not record the location of the paren,\n       --  but we would like to post the flag on the paren. So what we do is to\n@@ -1786,6 +1905,92 @@ package body Errout is\n       --  True if S starts with Size_For\n    end Is_Size_Too_Small_Message;\n \n+   ---------------\n+   -- Last_Node --\n+   ---------------\n+\n+   function Last_Node (C : Node_Id) return Node_Id is\n+      Fst, Lst : Node_Id;\n+   begin\n+      First_And_Last_Nodes (C, Fst, Lst);\n+      return Lst;\n+   end Last_Node;\n+\n+   ---------------\n+   -- Last_Sloc --\n+   ---------------\n+\n+   function Last_Sloc (N : Node_Id) return Source_Ptr is\n+      SI : constant Source_File_Index := Source_Index (Get_Source_Unit (N));\n+      SF : constant Source_Ptr        := Source_First (SI);\n+      SL : constant Source_Ptr        := Source_Last (SI);\n+      F  : Node_Id;\n+      S  : Source_Ptr;\n+\n+   begin\n+      F := Last_Node (N);\n+      S := Sloc (F);\n+\n+      --  ??? Protect against inconsistency in locations, by returning S\n+      --  immediately if not in the expected range, rather than failing with\n+      --  a Constraint_Error when accessing Source_Text(SI)(S)\n+\n+      if S not in SF .. SL then\n+         return S;\n+      end if;\n+\n+      --  Skip past an identifier\n+\n+      while S in SF .. SL - 1\n+        and then Source_Text (SI) (S + 1)\n+          in\n+        '0' .. '9' | 'a' .. 'z' | 'A' .. 'Z' | '.' | '_'\n+      loop\n+         S := S + 1;\n+      end loop;\n+\n+      --  The following circuit attempts at crawling up the tree from the\n+      --  Last_Node, adjusting the Sloc value for any parentheses we know\n+      --  are present, similarly to what is done in First_Sloc.\n+\n+      Node_Loop : loop\n+         Paren_Loop : for J in 1 .. Paren_Count (F) loop\n+\n+            --  We don't look more than 12 characters after the current\n+            --  location\n+\n+            Search_Loop : for K in 1 .. 12 loop\n+               exit Node_Loop when S = SL;\n+\n+               if Source_Text (SI) (S + 1) = ')' then\n+                  S := S + 1;\n+                  exit Search_Loop;\n+\n+               elsif Source_Text (SI) (S + 1) <= ' ' then\n+                  S := S + 1;\n+\n+               else\n+                  exit Search_Loop;\n+               end if;\n+            end loop Search_Loop;\n+         end loop Paren_Loop;\n+\n+         exit Node_Loop when F = N;\n+         F := Parent (F);\n+         exit Node_Loop when Nkind (F) not in N_Subexpr;\n+      end loop Node_Loop;\n+\n+      --  Remove any trailing space\n+\n+      while S in SF + 1 .. SL\n+        and then Source_Text (SI) (S) = ' '\n+      loop\n+         S := S - 1;\n+      end loop;\n+\n+      return S;\n+   end Last_Sloc;\n+\n    -----------------\n    -- No_Warnings --\n    -----------------\n@@ -1858,13 +2063,30 @@ package body Errout is\n       procedure Write_Max_Errors;\n       --  Write message if max errors reached\n \n-      procedure Write_Source_Code_Line (Loc : Source_Ptr);\n-      --  Write the source code line corresponding to Loc, as follows:\n+      procedure Write_Source_Code_Lines (Span : Source_Span);\n+      --  Write the source code line corresponding to Span, as follows when\n+      --  Span in on one line:\n+      --\n+      --  line |  actual code line here with Span somewhere\n+      --       |                        ~~~~~^~~~\n+      --\n+      --  where the caret on the line points to location Span.Ptr, and the\n+      --  range Span.First..Span.Last is underlined.\n+      --\n+      --  or when the span is over multiple lines:\n+      --\n+      --  line |  beginning of the Span on this line\n+      --   ... |     ...\n+      --  line>|  actual code line here with Span.Ptr somewhere\n+      --   ... |     ...\n+      --  line |  end of the Span on this line\n+      --\n+      --  or when the span is a simple location, as follows:\n       --\n-      --  line |  actual code line here with Loc somewhere\n+      --  line |  actual code line here with Span somewhere\n       --       |                             ^ here\n       --\n-      --  where the carret on the last line points to location Loc.\n+      --  where the caret on the line points to location Span.Ptr\n \n       -------------------------\n       -- Write_Error_Summary --\n@@ -2056,17 +2278,25 @@ package body Errout is\n          end if;\n       end Write_Max_Errors;\n \n-      ----------------------------\n-      -- Write_Source_Code_Line --\n-      ----------------------------\n+      -----------------------------\n+      -- Write_Source_Code_Lines --\n+      -----------------------------\n \n-      procedure Write_Source_Code_Line (Loc : Source_Ptr) is\n+      procedure Write_Source_Code_Lines (Span : Source_Span) is\n \n          function Image (X : Positive; Width : Positive) return String;\n          --  Output number X over Width characters, with whitespace padding.\n          --  Only output the low-order Width digits of X, if X is larger than\n          --  Width digits.\n \n+         procedure Write_Line_Marker\n+           (Num   : Pos;\n+            Mark  : Boolean;\n+            Width : Positive);\n+         --  Output the line number Num over Width characters, with possibly\n+         --  a Mark to denote the line with the main location when reporting\n+         --  a span over multiple lines.\n+\n          -----------\n          -- Image --\n          -----------\n@@ -2087,26 +2317,76 @@ package body Errout is\n             return Str;\n          end Image;\n \n+         -----------------------\n+         -- Write_Line_Marker --\n+         -----------------------\n+\n+         procedure Write_Line_Marker\n+           (Num   : Pos;\n+            Mark  : Boolean;\n+            Width : Positive)\n+         is\n+         begin\n+            Write_Str (Image (Positive (Num), Width => Width));\n+            Write_Str ((if Mark then \">\" else \" \") & \"|\");\n+         end Write_Line_Marker;\n+\n          --  Local variables\n \n-         Line    : constant Pos     := Pos (Get_Physical_Line_Number (Loc));\n-         Col     : constant Natural := Natural (Get_Column_Number (Loc));\n-         Width   : constant         := 5;\n+         Loc     : constant Source_Ptr := Span.Ptr;\n+         Line    : constant Pos        := Pos (Get_Physical_Line_Number (Loc));\n \n-         Buf     : Source_Buffer_Ptr;\n-         Cur_Loc : Source_Ptr := Loc;\n+         Col     : constant Natural    := Natural (Get_Column_Number (Loc));\n \n-      --  Start of processing for Write_Source_Code_Line\n+         Fst      : constant Source_Ptr := Span.First;\n+         Line_Fst : constant Pos        :=\n+           Pos (Get_Physical_Line_Number (Fst));\n+         Col_Fst  : constant Natural    :=\n+           Natural (Get_Column_Number (Fst));\n+         Lst      : constant Source_Ptr := Span.Last;\n+         Line_Lst : constant Pos        :=\n+           Pos (Get_Physical_Line_Number (Lst));\n+         Col_Lst  : constant Natural    :=\n+           Natural (Get_Column_Number (Lst));\n+\n+         Width    : constant := 5;\n+         Buf      : Source_Buffer_Ptr;\n+         Cur_Loc  : Source_Ptr := Fst;\n+         Cur_Line : Pos := Line_Fst;\n+\n+      --  Start of processing for Write_Source_Code_Lines\n \n       begin\n          if Loc >= First_Source_Ptr then\n             Buf := Source_Text (Get_Source_File_Index (Loc));\n \n-            --  First line with the actual source code line\n+            --  First line of the span with actual source code\n \n-            Write_Str (Image (Positive (Line), Width => Width));\n-            Write_Str (\" |\");\n-            Write_Str (String (Buf (Loc - Source_Ptr (Col) + 1  .. Loc - 1)));\n+            Write_Line_Marker\n+              (Cur_Line,\n+               Line_Fst /= Line_Lst and then Cur_Line = Line,\n+               Width);\n+            Write_Str\n+              (String (Buf (Fst - Source_Ptr (Col_Fst) + 1  .. Fst - 1)));\n+\n+            --  Output all the lines in the span\n+\n+            while Cur_Loc <= Buf'Last\n+              and then Cur_Loc < Lst\n+            loop\n+               Write_Char (Buf (Cur_Loc));\n+               Cur_Loc := Cur_Loc + 1;\n+\n+               if Buf (Cur_Loc - 1) = ASCII.LF then\n+                  Cur_Line := Cur_Line + 1;\n+                  Write_Line_Marker\n+                    (Cur_Line,\n+                     Line_Fst /= Line_Lst and then Cur_Line = Line,\n+                     Width);\n+               end if;\n+            end loop;\n+\n+            --  Output the rest of the last line of the span\n \n             while Cur_Loc <= Buf'Last\n               and then Buf (Cur_Loc) /= ASCII.LF\n@@ -2117,15 +2397,28 @@ package body Errout is\n \n             Write_Eol;\n \n-            --  Second line with carret sign pointing to location Loc\n+            --  If the span is on one line, output a second line with caret\n+            --  sign pointing to location Loc\n \n-            Write_Str (String'(1 .. Width => ' '));\n-            Write_Str (\" |\");\n-            Write_Str (String'(1 .. Col - 1 => ' '));\n-            Write_Str (\"^ here\");\n-            Write_Eol;\n+            if Line_Fst = Line_Lst then\n+               Write_Str (String'(1 .. Width => ' '));\n+               Write_Str (\" |\");\n+               Write_Str (String'(1 .. Col_Fst - 1 => ' '));\n+               Write_Str (String'(Col_Fst .. Col - 1 => '~'));\n+               Write_Str (\"^\");\n+               Write_Str (String'(Col + 1 .. Col_Lst => '~'));\n+\n+               --  If the span is really just a location, add the word \"here\"\n+               --  to clarify this is the location for the message.\n+\n+               if Col_Fst = Col_Lst then\n+                  Write_Str (\" here\");\n+               end if;\n+\n+               Write_Eol;\n+            end if;\n          end if;\n-      end Write_Source_Code_Line;\n+      end Write_Source_Code_Lines;\n \n       --  Local variables\n \n@@ -2217,12 +2510,12 @@ package body Errout is\n                           Errors.Table (E).Insertion_Sloc;\n                      begin\n                         if Loc /= No_Location then\n-                           Write_Source_Code_Line (Loc);\n+                           Write_Source_Code_Lines (To_Span (Loc));\n                         end if;\n                      end;\n \n                   else\n-                     Write_Source_Code_Line (Errors.Table (E).Sptr);\n+                     Write_Source_Code_Lines (Errors.Table (E).Sptr);\n                   end if;\n                end if;\n             end if;\n@@ -2355,11 +2648,12 @@ package body Errout is\n          --  subunits for a body).\n \n          while E /= No_Error_Msg\n-           and then (not In_Extended_Main_Source_Unit (Errors.Table (E).Sptr)\n+           and then (not In_Extended_Main_Source_Unit\n+                           (Errors.Table (E).Sptr.Ptr)\n                        or else\n                         (Debug_Flag_Dot_M\n                           and then Get_Source_Unit\n-                                     (Errors.Table (E).Sptr) /= Main_Unit))\n+                                     (Errors.Table (E).Sptr.Ptr) /= Main_Unit))\n          loop\n             if Errors.Table (E).Deleted then\n                E := Errors.Table (E).Next;"}, {"sha": "f9a8379c8f0f77b5ac4f466ea1c3c3d496c413c1", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -702,11 +702,16 @@ package Errout is\n \n    procedure Error_Msg\n      (Msg : String; Flag_Location : Source_Ptr);\n+   procedure Error_Msg\n+     (Msg : String; Flag_Span : Source_Span);\n    procedure Error_Msg\n      (Msg : String; Flag_Location : Source_Ptr; N : Node_Id);\n+   procedure Error_Msg\n+     (Msg : String; Flag_Span : Source_Span; N : Node_Id);\n    --  Output a message at specified location. Can be called from the parser\n    --  or the semantic analyzer. If N is set, points to the relevant node for\n-   --  this message.\n+   --  this message. The version with a span is preferred whenever possible,\n+   --  in other cases the version with a location can still be used.\n \n    procedure Error_Msg\n      (Msg                    : String;\n@@ -782,8 +787,13 @@ package Errout is\n       N             : Node_Or_Entity_Id;\n       E             : Node_Or_Entity_Id;\n       Flag_Location : Source_Ptr);\n+   procedure Error_Msg_NEL\n+     (Msg       : String;\n+      N         : Node_Or_Entity_Id;\n+      E         : Node_Or_Entity_Id;\n+      Flag_Span : Source_Span);\n    --  Exactly the same as Error_Msg_NE, except that the flag is placed at\n-   --  the specified Flag_Location instead of at Sloc (N).\n+   --  the specified Flag_Location/Flag_Span instead of at Sloc (N).\n \n    procedure Error_Msg_NW\n      (Eflag : Boolean;\n@@ -801,12 +811,17 @@ package Errout is\n    --  the given text. This text may contain insertion characters in the\n    --  usual manner, and need not be the same length as the original text.\n \n+   procedure First_And_Last_Nodes\n+     (C                     : Node_Id;\n+      First_Node, Last_Node : out Node_Id);\n+   --  Given a construct C, finds the first and last node in the construct,\n+   --  i.e. the ones with the lowest and highest Sloc value. This is useful in\n+   --  placing error msgs. Note that this procedure uses Original_Node to look\n+   --  at the original source tree, since that's what we want for placing an\n+   --  error message flag in the right place.\n+\n    function First_Node (C : Node_Id) return Node_Id;\n-   --  Given a construct C, finds the first node in the construct, i.e. the one\n-   --  with the lowest Sloc value. This is useful in placing error msgs. Note\n-   --  that this procedure uses Original_Node to look at the original source\n-   --  tree, since that's what we want for placing an error message flag in\n-   --  the right place.\n+   --  Return the first output of First_And_Last_Nodes\n \n    function First_Sloc (N : Node_Id) return Source_Ptr;\n    --  Given the node for an expression, return a source pointer value that\n@@ -817,6 +832,15 @@ package Errout is\n    function Get_Ignore_Errors return Boolean;\n    --  Return True if all error calls are ignored.\n \n+   function Last_Node (C : Node_Id) return Node_Id;\n+   --  Return the last output of First_And_Last_Nodes\n+\n+   function Last_Sloc (N : Node_Id) return Source_Ptr;\n+   --  Given the node for an expression, return a source pointer value that\n+   --  points to the end of the last token in the expression. In the case\n+   --  where the expression is parenthesized, an attempt is made to include\n+   --  the parentheses (i.e. to return the location of the final paren).\n+\n    procedure Purge_Messages (From : Source_Ptr; To : Source_Ptr)\n      renames Erroutc.Purge_Messages;\n    --  All error messages whose location is in the range From .. To (not"}, {"sha": "d7ca221db2283124e5201c8c2139689090060969", "filename": "gcc/ada/erroutc.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ferroutc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ferroutc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.adb?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -321,7 +321,7 @@ package body Erroutc is\n \n       Write_Str\n         (\"  Sptr     = \");\n-      Write_Location (E.Sptr);\n+      Write_Location (E.Sptr.Ptr);  --  ??? Do not write the full span for now\n       Write_Eol;\n \n       Write_Str\n@@ -350,7 +350,7 @@ package body Erroutc is\n \n    function Get_Location (E : Error_Msg_Id) return Source_Ptr is\n    begin\n-      return Errors.Table (E).Sptr;\n+      return Errors.Table (E).Sptr.Ptr;\n    end Get_Location;\n \n    ----------------\n@@ -477,7 +477,7 @@ package body Erroutc is\n         and then Errors.Table (T).Line = Errors.Table (E).Line\n         and then Errors.Table (T).Sfile = Errors.Table (E).Sfile\n       loop\n-         if Errors.Table (T).Sptr > Errors.Table (E).Sptr then\n+         if Errors.Table (T).Sptr.Ptr > Errors.Table (E).Sptr.Ptr then\n             Mult_Flags := True;\n          end if;\n \n@@ -490,7 +490,7 @@ package body Erroutc is\n \n       if not Debug_Flag_2 then\n          Write_Str (\"        \");\n-         P := Line_Start (Errors.Table (E).Sptr);\n+         P := Line_Start (Errors.Table (E).Sptr.Ptr);\n          Flag_Num := 1;\n \n          --  Loop through error messages for this line to place flags\n@@ -507,7 +507,7 @@ package body Erroutc is\n             begin\n                --  Loop to output blanks till current flag position\n \n-               while P < Errors.Table (T).Sptr loop\n+               while P < Errors.Table (T).Sptr.Ptr loop\n \n                   --  Horizontal tab case, just echo the tab\n \n@@ -536,7 +536,7 @@ package body Erroutc is\n                --  Output flag (unless already output, this happens if more\n                --  than one error message occurs at the same flag position).\n \n-               if P = Errors.Table (T).Sptr then\n+               if P = Errors.Table (T).Sptr.Ptr then\n                   if (Flag_Num = 1 and then not Mult_Flags)\n                     or else Flag_Num > 9\n                   then\n@@ -955,8 +955,8 @@ package body Erroutc is\n       function To_Be_Purged (E : Error_Msg_Id) return Boolean is\n       begin\n          if E /= No_Error_Msg\n-           and then Errors.Table (E).Sptr > From\n-           and then Errors.Table (E).Sptr < To\n+           and then Errors.Table (E).Sptr.Ptr > From\n+           and then Errors.Table (E).Sptr.Ptr < To\n          then\n             if Errors.Table (E).Warn or else Errors.Table (E).Style then\n                Warnings_Detected := Warnings_Detected - 1;"}, {"sha": "eb434661387d4ccd695087512d64c78146920e49", "filename": "gcc/ada/erroutc.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ferroutc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ferroutc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.ads?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -197,7 +197,7 @@ package Erroutc is\n       --  refers to a template, always references the original template\n       --  not an instantiation copy.\n \n-      Sptr : Source_Ptr;\n+      Sptr : Source_Span;\n       --  Flag pointer. In the case of an error that refers to a template,\n       --  always references the original template, not an instantiation copy.\n       --  This value is the actual place in the source that the error message"}, {"sha": "0a9f6ad6e63da0093436706b1239bf36e1d97cb2", "filename": "gcc/ada/errutil.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ferrutil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ferrutil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrutil.adb?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -207,7 +207,7 @@ package body Errutil is\n             Next                => No_Error_Msg,\n             Prev                => No_Error_Msg,\n             Sfile               => Get_Source_File_Index (Sptr),\n-            Sptr                => Sptr,\n+            Sptr                => To_Span (Sptr),\n             Optr                => Optr,\n             Insertion_Sloc      => No_Location,\n             Line                => Get_Physical_Line_Number (Sptr),\n@@ -234,7 +234,7 @@ package body Errutil is\n            Errors.Table (Cur_Msg).Sfile < Errors.Table (Next_Msg).Sfile;\n \n          if Errors.Table (Cur_Msg).Sfile = Errors.Table (Next_Msg).Sfile then\n-            exit when Sptr < Errors.Table (Next_Msg).Sptr;\n+            exit when Sptr < Errors.Table (Next_Msg).Sptr.Ptr;\n          end if;\n \n          Prev_Msg := Next_Msg;"}, {"sha": "cbdecaa7552f9ebc7cabe31d64a7156caeb85715", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -3644,8 +3644,8 @@ package body Freeze is\n                  and then not Freezing_Library_Level_Tagged_Type\n                then\n                   Error_Msg_Node_1 := F_Type;\n-                  Error_Msg\n-                    (\"type & must be fully defined before this point\", Loc);\n+                  Error_Msg_N\n+                    (\"type & must be fully defined before this point\", N);\n                end if;\n             end if;\n "}, {"sha": "41aad79d8405d9be1ad1694ad0433f254cbea051", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -1379,9 +1379,9 @@ package body Ch3 is\n       procedure No_List is\n       begin\n          if Num_Idents > 1 then\n-            Error_Msg\n+            Error_Msg_N\n               (\"identifier list not allowed for RENAMES\",\n-               Sloc (Idents (2)));\n+               Idents (2));\n          end if;\n \n          List_OK := False;"}, {"sha": "d05f267ab0cb9083f218ea5ef702f80d2459ddae", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -158,7 +158,7 @@ function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id is\n    procedure Check_Arg_Count (Required : Int) is\n    begin\n       if Arg_Count /= Required then\n-         Error_Msg (\"wrong number of arguments for pragma%\", Pragma_Sloc);\n+         Error_Msg_N (\"wrong number of arguments for pragma%\", Pragma_Node);\n          raise Error_Resync;\n       end if;\n    end Check_Arg_Count;\n@@ -177,7 +177,7 @@ function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id is\n          Error_Msg_Name_2 := Name_On;\n          Error_Msg_Name_3 := Name_Off;\n \n-         Error_Msg (\"argument for pragma% must be% or%\", Sloc (Argx));\n+         Error_Msg_N (\"argument for pragma% must be% or%\", Argx);\n          raise Error_Resync;\n       end if;\n    end Check_Arg_Is_On_Or_Off;\n@@ -189,9 +189,9 @@ function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id is\n    procedure Check_Arg_Is_String_Literal (Arg : Node_Id) is\n    begin\n       if Nkind (Expression (Arg)) /= N_String_Literal then\n-         Error_Msg\n+         Error_Msg_N\n            (\"argument for pragma% must be string literal\",\n-             Sloc (Expression (Arg)));\n+            Expression (Arg));\n          raise Error_Resync;\n       end if;\n    end Check_Arg_Is_String_Literal;\n@@ -466,7 +466,7 @@ begin\n          A := Expression (Arg1);\n \n          if Nkind (A) /= N_Identifier then\n-            Error_Msg (\"incorrect argument for pragma %\", Sloc (A));\n+            Error_Msg_N (\"incorrect argument for pragma %\", A);\n          else\n             Set_Name_Table_Boolean3 (Chars (A), True);\n          end if;\n@@ -718,19 +718,19 @@ begin\n          begin\n             if Prag_Id = Pragma_Source_File_Name then\n                if Project_File_In_Use = In_Use then\n-                  Error_Msg\n+                  Error_Msg_N\n                     (\"pragma Source_File_Name cannot be used \" &\n-                     \"with a project file\", Pragma_Sloc);\n+                     \"with a project file\", Pragma_Node);\n \n                else\n                   Project_File_In_Use := Not_In_Use;\n                end if;\n \n             else\n                if Project_File_In_Use = Not_In_Use then\n-                  Error_Msg\n+                  Error_Msg_N\n                     (\"pragma Source_File_Name_Project should only be used \" &\n-                     \"with a project file\", Pragma_Sloc);\n+                     \"with a project file\", Pragma_Node);\n                else\n                   Project_File_In_Use := In_Use;\n                end if;\n@@ -773,9 +773,9 @@ begin\n                     or else Intval (Expr) > 999\n                     or else Intval (Expr) <= 0\n                   then\n-                     Error_Msg\n+                     Error_Msg_N\n                        (\"pragma% index must be integer literal\" &\n-                        \" in range 1 .. 999\", Sloc (Expr));\n+                        \" in range 1 .. 999\", Expr);\n                      raise Error_Resync;\n                   else\n                      Index := UI_To_Int (Intval (Expr));\n@@ -908,18 +908,18 @@ begin\n            and then Num_SRef_Pragmas (Current_Source_File) = 0\n            and then Operating_Mode /= Check_Syntax\n          then\n-            Error_Msg -- CODEFIX\n-              (\"first % pragma must be first line of file\", Pragma_Sloc);\n+            Error_Msg_N -- CODEFIX\n+              (\"first % pragma must be first line of file\", Pragma_Node);\n             raise Error_Resync;\n          end if;\n \n          Check_No_Identifier (Arg1);\n \n          if Arg_Count = 1 then\n             if Num_SRef_Pragmas (Current_Source_File) = 0 then\n-               Error_Msg\n+               Error_Msg_N\n                  (\"file name required for first % pragma in file\",\n-                  Pragma_Sloc);\n+                  Pragma_Node);\n                raise Error_Resync;\n             else\n                Fname := No_File;\n@@ -934,17 +934,17 @@ begin\n \n             if Num_SRef_Pragmas (Current_Source_File) > 0 then\n                if Fname /= Full_Ref_Name (Current_Source_File) then\n-                  Error_Msg\n-                    (\"file name must be same in all % pragmas\", Pragma_Sloc);\n+                  Error_Msg_N\n+                    (\"file name must be same in all % pragmas\", Pragma_Node);\n                   raise Error_Resync;\n                end if;\n             end if;\n          end if;\n \n          if Nkind (Expression (Arg1)) /= N_Integer_Literal then\n-            Error_Msg\n+            Error_Msg_N\n               (\"argument for pragma% must be integer literal\",\n-                Sloc (Expression (Arg1)));\n+               Expression (Arg1));\n             raise Error_Resync;\n \n          --  OK, this source reference pragma is effective, however, we\n@@ -1059,7 +1059,7 @@ begin\n             end if;\n \n             if not OK then\n-               Error_Msg (\"incorrect argument for pragma%\", Sloc (A));\n+               Error_Msg_N (\"incorrect argument for pragma%\", A);\n                raise Error_Resync;\n             end if;\n          end if;"}, {"sha": "0571c0feba0c242170a8940c4ae1ae84f91b1442", "filename": "gcc/ada/par-util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fpar-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fpar-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-util.adb?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -254,7 +254,7 @@ package body Util is\n       then\n          return Mark;\n       else\n-         Error_Msg (\"subtype mark expected\", Sloc (Mark));\n+         Error_Msg_N (\"subtype mark expected\", Mark);\n          return Error;\n       end if;\n    end Check_Subtype_Mark;"}, {"sha": "7f35cfc3c5e2d03818dde62e7459025347c2f8b1", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -677,8 +677,6 @@ package body Sem_Case is\n       --------------------\n \n       procedure Missing_Choice (Value1 : Uint; Value2 : Uint) is\n-         Msg_Sloc : constant Source_Ptr := Sloc (Case_Node);\n-\n       begin\n          --  AI05-0188 : within an instance the non-others choices do not have\n          --  to belong to the actual subtype.\n@@ -704,10 +702,10 @@ package body Sem_Case is\n          if Value1 = Value2 then\n             if Is_Integer_Type (Bounds_Type) then\n                Error_Msg_Uint_1 := Value1;\n-               Error_Msg (\"missing case value: ^!\", Msg_Sloc);\n+               Error_Msg_N (\"missing case value: ^!\", Case_Node);\n             else\n                Error_Msg_Name_1 := Choice_Image (Value1, Bounds_Type);\n-               Error_Msg (\"missing case value: %!\", Msg_Sloc);\n+               Error_Msg_N (\"missing case value: %!\", Case_Node);\n             end if;\n \n          --  More than one choice value, so print range of values\n@@ -716,11 +714,11 @@ package body Sem_Case is\n             if Is_Integer_Type (Bounds_Type) then\n                Error_Msg_Uint_1 := Value1;\n                Error_Msg_Uint_2 := Value2;\n-               Error_Msg (\"missing case values: ^ .. ^!\", Msg_Sloc);\n+               Error_Msg_N (\"missing case values: ^ .. ^!\", Case_Node);\n             else\n                Error_Msg_Name_1 := Choice_Image (Value1, Bounds_Type);\n                Error_Msg_Name_2 := Choice_Image (Value2, Bounds_Type);\n-               Error_Msg (\"missing case values: % .. %!\", Msg_Sloc);\n+               Error_Msg_N (\"missing case values: % .. %!\", Case_Node);\n             end if;\n          end if;\n       end Missing_Choice;"}, {"sha": "07dec4c4d983a1b8fd5bc02bc20620a677bf1e0d", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -4147,8 +4147,8 @@ package body Sem_Ch13 is\n                         --  Must not be parenthesized\n \n                         if Paren_Count (Expr) /= 0 then\n-                           Error_Msg -- CODEFIX\n-                             (\"redundant parentheses\", First_Sloc (Expr));\n+                           Error_Msg_F -- CODEFIX\n+                             (\"redundant parentheses\", Expr);\n                         end if;\n \n                         --  List of arguments is list of aggregate expressions\n@@ -4442,8 +4442,8 @@ package body Sem_Ch13 is\n                   --  parentheses).\n \n                   if Paren_Count (Expr) /= 0 then\n-                     Error_Msg -- CODEFIX\n-                       (\"redundant parentheses\", First_Sloc (Expr));\n+                     Error_Msg_F -- CODEFIX\n+                       (\"redundant parentheses\", Expr);\n                      goto Continue;\n                   end if;\n \n@@ -4860,11 +4860,11 @@ package body Sem_Ch13 is\n                      Error_Msg_Name_1 := Aspect_Names (A_Id);\n                      Error_Msg_Sloc := Sloc (Inherited_Aspect);\n \n-                     Error_Msg\n+                     Error_Msg_N\n                        (\"overriding aspect specification for \"\n                           & \"nonoverridable aspect % does not confirm \"\n                           & \"aspect specification inherited from #\",\n-                        Sloc (Aspect));\n+                        Aspect);\n                   end if;\n                end;\n             end if;\n@@ -7909,9 +7909,8 @@ package body Sem_Ch13 is\n       --  Check that the expression is a proper aggregate (no parentheses)\n \n       elsif Paren_Count (Aggr) /= 0 then\n-         Error_Msg\n-           (\"extra parentheses surrounding aggregate not allowed\",\n-            First_Sloc (Aggr));\n+         Error_Msg_F\n+           (\"extra parentheses surrounding aggregate not allowed\", Aggr);\n          return;\n \n       --  All tests passed, so set rep clause in place"}, {"sha": "478439781871d4638e0d271208fc58f995807ce2", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -1575,9 +1575,8 @@ package body Sem_Ch3 is\n \n    begin\n       if not RTE_Available (RE_Interface_Tag) then\n-         Error_Msg\n-           (\"(Ada 2005) interface types not supported by this run-time!\",\n-            Sloc (N));\n+         Error_Msg_N\n+           (\"(Ada 2005) interface types not supported by this run-time!\", N);\n          return;\n       end if;\n "}, {"sha": "1b1e01b4da058160ba9e6383ca6974d2042ddf34", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -566,8 +566,8 @@ package body Sem_Prag is\n          --  Check that the expression is a proper aggregate (no parentheses)\n \n          if Paren_Count (CCases) /= 0 then\n-            Error_Msg -- CODEFIX\n-              (\"redundant parentheses\", First_Sloc (CCases));\n+            Error_Msg_F -- CODEFIX\n+              (\"redundant parentheses\", CCases);\n          end if;\n \n          --  Ensure that the formal parameters are visible when analyzing all\n@@ -15041,9 +15041,8 @@ package body Sem_Prag is\n             else\n                --  All other cases: diagnose error\n \n-               Error_Msg\n-                 (\"argument of pragma \"\"Debug\"\" is not procedure call\",\n-                  Sloc (Call));\n+               Error_Msg_N\n+                 (\"argument of pragma \"\"Debug\"\" is not procedure call\", Call);\n                return;\n             end if;\n \n@@ -25632,9 +25631,9 @@ package body Sem_Prag is\n                               Set_Specific_Warning_On (Loc, Message, Err);\n \n                               if Err then\n-                                 Error_Msg\n+                                 Error_Msg_N\n                                    (\"??pragma Warnings On with no matching \"\n-                                    & \"Warnings Off\", Loc);\n+                                    & \"Warnings Off\", N);\n                               end if;\n                            end if;\n                         end;\n@@ -29206,8 +29205,8 @@ package body Sem_Prag is\n          --  Check that the expression is a proper aggregate (no parentheses)\n \n          if Paren_Count (Variants) /= 0 then\n-            Error_Msg -- CODEFIX\n-              (\"redundant parentheses\", First_Sloc (Variants));\n+            Error_Msg_F -- CODEFIX\n+              (\"redundant parentheses\", Variants);\n          end if;\n \n          --  Ensure that the formal parameters are visible when analyzing all"}, {"sha": "408d6615bdf998c53daff0e8f02e57e047236cb6", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5f3b7a694ceb774330d45894b38e34bb90f86a/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=9d5f3b7a694ceb774330d45894b38e34bb90f86a", "patch": "@@ -218,6 +218,16 @@ package Types is\n    --  which source it refers to. Note that negative numbers are allowed to\n    --  accommodate the following special values.\n \n+   type Source_Span is record\n+      Ptr, First, Last : Source_Ptr;\n+   end record;\n+   --  Type used to represent a source span, consisting in a main location Ptr,\n+   --  with a First and Last location, such that Ptr in First .. Last\n+\n+   function To_Span (Loc : Source_Ptr) return Source_Span is ((others => Loc));\n+   function To_Span (Ptr, First, Last : Source_Ptr) return Source_Span is\n+     ((Ptr, First, Last));\n+\n    No_Location : constant Source_Ptr := -1;\n    --  Value used to indicate no source position set in a node. A test for a\n    --  Source_Ptr value being > No_Location is the approved way to test for a"}]}