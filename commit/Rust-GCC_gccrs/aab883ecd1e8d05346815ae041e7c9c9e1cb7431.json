{"sha": "aab883ecd1e8d05346815ae041e7c9c9e1cb7431", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFiODgzZWNkMWU4ZDA1MzQ2ODE1YWUwNDFlN2M5YzllMWNiNzQzMQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-04-06T09:26:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:26:20Z"}, "message": "sem_ch4.adb (Try_Primitive_Operation): The call is legal if the prefix type is a discriminated subtype of the type of...\n\n2007-04-06  Ed Schonberg  <schonberg@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch4.adb (Try_Primitive_Operation): The call is legal if the\n\tprefix type is a discriminated subtype of the type of the formal.\n\t(Analyze_Allocator): Collect all coextensions regardless of the context.\n\tWhether they can be allocated statically is determined in exp_ch4.\n\t(Analyze_Selected_Component): If the prefix is a limited view and the\n\tnon-limited view is available, use the non-limited one.\n\t(Operator_Check): For \"X'Access = Y'Access\" (which is ambiguous, and\n\ttherefore illegal), suggest a qualified expression rather than a type\n\tconversion, because a type conversion would be illegal in this context.\n\t(Anayze_Allocator): Trace recursively all nested allocators so that all\n\tcoextensions are on the corresponding list for the root. Do no mark\n\tcoextensions if the root allocator is within a declaration for a stack-\n\tallocated object, because the access discriminants will be allocated on\n\tthe stack as well.\n\t(Analyze_Call): Remove restriction on calls to limited functions for the\n\tcases of generic actuals for formal objects, defaults for formal objects\n\tand defaults for record components.\n\t(Analyze_Allocator): Before analysis, chain coextensions on the proper\n\telement list. Their expansion is delayed until the enclosing allocator\n\tis processed and its finalization list constructed.\n\t(Try_Primitive_Operation): If the prefix is a concurrent type, looks\n\tfor an operation with the given name among the primitive operations of\n\tthe corresponding record type.\n\t(Analyze_Selected_Component): If the prefix is a task type that\n\timplements an interface, and there is no entry with the given name,\n\tcheck whether there is another primitive operation (e.g. a function)\n\twith that name.\n\t(Try_Object_Operation, Analyze_One_Call, Try_Indexed_Call): Handle\n\tproperly the indexing of a function call written in prefix form, where\n\tthe function returns an array type, and all parameters of the function\n\texcept the first have defaults.\n\t(Analyze_Equality_Op): If this is a call to an implicit inequality, keep\n\tthe original operands, rather than relocating them, for efficiency and\n\tto work properly when an operand is overloaded.\n\t(Analyze_Allocator,Operator_Check,Remove_Abstract_Operations): Split\n\tIs_Abstract flag into Is_Abstract_Subprogram and Is_Abstract_Type.\n\t(Analyze_Selected_Component): If the prefix is a private extension, only\n\tscan the visible components, not those of the full view.\n\t(Try_Primitive_Operation): If the operation is a procedure, collect all\n\tpossible interpretations, as for a function, because in the presence of\n\tclasswide parameters several primitive operations of the type can match\n\tthe given arguments.\n\nFrom-SVN: r123594", "tree": {"sha": "e9bd15814fc83fc88fc867340d4292acea3c954e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9bd15814fc83fc88fc867340d4292acea3c954e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aab883ecd1e8d05346815ae041e7c9c9e1cb7431", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aab883ecd1e8d05346815ae041e7c9c9e1cb7431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aab883ecd1e8d05346815ae041e7c9c9e1cb7431", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aab883ecd1e8d05346815ae041e7c9c9e1cb7431/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da931119f4caeba05e524717a2ee3492aecb5bb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da931119f4caeba05e524717a2ee3492aecb5bb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da931119f4caeba05e524717a2ee3492aecb5bb0"}], "stats": {"total": 252, "additions": 184, "deletions": 68}, "files": [{"sha": "14f7c101b9969b26a4053e13ce8c6c1b5b2f092b", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 184, "deletions": 68, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab883ecd1e8d05346815ae041e7c9c9e1cb7431/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab883ecd1e8d05346815ae041e7c9c9e1cb7431/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=aab883ecd1e8d05346815ae041e7c9c9e1cb7431", "patch": "@@ -234,25 +234,28 @@ package body Sem_Ch4 is\n    --  operation is not a candidate interpretation.\n \n    function Try_Indexed_Call\n-     (N   : Node_Id;\n-      Nam : Entity_Id;\n-      Typ : Entity_Id) return Boolean;\n-   --  If a function has defaults for all its actuals, a call to it may\n-   --  in fact be an indexing on the result of the call. Try_Indexed_Call\n-   --  attempts the interpretation as an indexing, prior to analysis as\n-   --  a call. If both are possible,  the node is overloaded with both\n-   --  interpretations (same symbol but two different types).\n+     (N          : Node_Id;\n+      Nam        : Entity_Id;\n+      Typ        : Entity_Id;\n+      Skip_First : Boolean) return Boolean;\n+   --  If a function has defaults for all its actuals, a call to it may in fact\n+   --  be an indexing on the result of the call. Try_Indexed_Call attempts the\n+   --  interpretation as an indexing, prior to analysis as a call. If both are\n+   --  possible, the node is overloaded with both interpretations (same symbol\n+   --  but two different types). If the call is written in prefix form, the\n+   --  prefix becomes the first parameter in the call, and only the remaining\n+   --  actuals must be checked for the presence of defaults.\n \n    function Try_Indirect_Call\n      (N   : Node_Id;\n       Nam : Entity_Id;\n       Typ : Entity_Id) return Boolean;\n-   --  Similarly, a function F that needs no actuals can return an access\n-   --  to a subprogram, and the call F (X)  interpreted as F.all (X). In\n-   --  this case the call may be overloaded with both interpretations.\n+   --  Similarly, a function F that needs no actuals can return an access to a\n+   --  subprogram, and the call F (X) interpreted as F.all (X). In this case\n+   --  the call may be overloaded with both interpretations.\n \n    function Try_Object_Operation (N : Node_Id) return Boolean;\n-   --  Ada 2005 (AI-252): Give support to the object operation notation\n+   --  Ada 2005 (AI-252): Support the object.operation notation\n \n    ------------------------\n    -- Ambiguous_Operands --\n@@ -343,10 +346,48 @@ package body Sem_Ch4 is\n       Acc_Type : Entity_Id;\n       Type_Id  : Entity_Id;\n \n+      function Mark_Allocator (Nod : Node_Id) return Traverse_Result;\n+      --  Ada 2005 AI-162: Traverse the expression for an allocator, to locate\n+      --  inner allocators that may specify access discriminants. Such access\n+      --  discriminants are coextensions of the enclosing objects. They should\n+      --  be allocated from the same storage pool as the enclosing object, and\n+      --  deallocated at the same time as the enclosing object. They are\n+      --  linked to the enclosing allocator to simplify this sharing.\n+      --  On the other hand, access discriminants for stack-allocated objects\n+      --  are themselves allocated statically, and do not carry the flag.\n+\n+      --------------------\n+      -- Mark_Allocator --\n+      --------------------\n+\n+      function Mark_Allocator (Nod : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (Nod) = N_Allocator\n+           and then Nkind (Parent (Nod)) = N_Index_Or_Discriminant_Constraint\n+         then\n+            Set_Is_Coextension (Nod);\n+\n+            if No (Coextensions (N)) then\n+               Set_Coextensions (N, New_Elmt_List);\n+            end if;\n+\n+            Append_Elmt (Nod, Coextensions (N));\n+         end if;\n+\n+         return OK;\n+      end Mark_Allocator;\n+\n+      procedure Mark_Coextensions is new Traverse_Proc (Mark_Allocator);\n+\n+   --  Start of processing for Analyze_Allocator\n+\n    begin\n       Check_Restriction (No_Allocators, N);\n+      Set_Coextensions (N, No_Elist);\n+      Mark_Coextensions (E);\n \n       if Nkind (E) = N_Qualified_Expression then\n+\n          Acc_Type := Create_Itype (E_Allocator_Type, N);\n          Set_Etype (Acc_Type, Acc_Type);\n          Init_Size_Align (Acc_Type);\n@@ -383,7 +424,7 @@ package body Sem_Ch4 is\n \n          Set_Etype  (E, Type_Id);\n \n-      --  Case where no qualified expression is present\n+      --  Case where allocator has a subtype indication\n \n       else\n          declare\n@@ -507,7 +548,7 @@ package body Sem_Ch4 is\n          end;\n       end if;\n \n-      if Is_Abstract (Type_Id) then\n+      if Is_Abstract_Type (Type_Id) then\n          Error_Msg_N (\"cannot allocate abstract object\", E);\n       end if;\n \n@@ -904,8 +945,8 @@ package body Sem_Ch4 is\n          elsif not Is_Overloaded (N)\n            and then Is_Entity_Name (Nam)\n          then\n-            --  Resolution yields a single interpretation. Verify that\n-            --  is has the proper capitalization.\n+            --  Resolution yields a single interpretation. Verify that the\n+            --  reference has capitalization consistent with the declaration.\n \n             Set_Entity_With_Style_Check (Nam, Entity (Nam));\n             Generate_Reference (Entity (Nam), Nam);\n@@ -918,21 +959,17 @@ package body Sem_Ch4 is\n          End_Interp_List;\n       end if;\n \n-      --  Check for not-yet-implemented cases of AI-318.\n-      --  We only need to check for inherently limited types,\n-      --  because other limited types will be returned by copy,\n-      --  which works just fine.\n+      --  Check for not-yet-implemented cases of AI-318. We only need to check\n+      --  for inherently limited types, because other limited types will be\n+      --  returned by copy, which works just fine.\n \n       if Ada_Version >= Ada_05\n         and then not Debug_Flag_Dot_L\n         and then Is_Inherently_Limited_Type (Etype (N))\n         and then (Nkind (Parent (N)) = N_Selected_Component\n-                  or else Nkind (Parent (N)) = N_Indexed_Component\n-                  or else Nkind (Parent (N)) = N_Slice\n-                  or else Nkind (Parent (N)) = N_Attribute_Reference\n-                  or else Nkind (Parent (N)) = N_Component_Declaration\n-                  or else Nkind (Parent (N)) = N_Formal_Object_Declaration\n-                  or else Nkind (Parent (N)) = N_Generic_Association)\n+                   or else Nkind (Parent (N)) = N_Indexed_Component\n+                   or else Nkind (Parent (N)) = N_Slice\n+                   or else Nkind (Parent (N)) = N_Attribute_Reference)\n       then\n          Error_Msg_N (\"(Ada 2005) limited function call in this context\" &\n                       \" is not yet implemented\", N);\n@@ -1183,8 +1220,8 @@ package body Sem_Ch4 is\n               Make_Op_Not (Loc,\n                 Right_Opnd =>\n                   Make_Op_Eq (Loc,\n-                    Left_Opnd =>  Relocate_Node (Left_Opnd (N)),\n-                    Right_Opnd => Relocate_Node (Right_Opnd (N)))));\n+                    Left_Opnd  => Left_Opnd (N),\n+                    Right_Opnd => Right_Opnd (N))));\n \n             Set_Entity (Right_Opnd (N), Op_Id);\n             Analyze (N);\n@@ -1678,7 +1715,7 @@ package body Sem_Ch4 is\n       then\n          U_N := Entity (P);\n \n-         if Ekind (U_N) in Type_Kind then\n+         if Is_Type (U_N) then\n \n             --  Reformat node as a type conversion\n \n@@ -1947,6 +1984,18 @@ package body Sem_Ch4 is\n    is\n       Actuals    : constant List_Id   := Parameter_Associations (N);\n       Prev_T     : constant Entity_Id := Etype (N);\n+      Must_Skip  : constant Boolean := Skip_First\n+                     or else Nkind (Original_Node (N)) = N_Selected_Component\n+                     or else\n+                       (Nkind (Original_Node (N)) = N_Indexed_Component\n+                          and then Nkind (Prefix (Original_Node (N)))\n+                            = N_Selected_Component);\n+      --  The first formal must be omitted from the match when trying to find\n+      --  a primitive operation that is a possible interpretation, and also\n+      --  after the call has been rewritten, because the corresponding actual\n+      --  is already known to be compatible, and because this may be an\n+      --  indexing of a call with default parameters.\n+\n       Formal     : Entity_Id;\n       Actual     : Node_Id;\n       Is_Indexed : Boolean := False;\n@@ -2000,18 +2049,26 @@ package body Sem_Ch4 is\n       --  If the subprogram has no formals, or if all the formals have\n       --  defaults, and the return type is an array type, the node may\n       --  denote an indexing of the result of a parameterless call.\n+      --  In Ada 2005, the subprogram may have one non-defaulted formal,\n+      --  and the call may have been written in prefix notation, so that\n+      --  the rebuilt parameter list has more than one actual.\n \n-      if Needs_No_Actuals (Nam)\n-        and then Present (Actuals)\n+      if Present (Actuals)\n+        and then\n+          (Needs_No_Actuals (Nam)\n+            or else\n+              (Needs_One_Actual (Nam)\n+                 and then Present (Next_Actual (First (Actuals)))))\n       then\n          if Is_Array_Type (Subp_Type) then\n-            Is_Indexed := Try_Indexed_Call (N, Nam, Subp_Type);\n+            Is_Indexed := Try_Indexed_Call (N, Nam, Subp_Type, Must_Skip);\n \n          elsif Is_Access_Type (Subp_Type)\n            and then Is_Array_Type (Designated_Type (Subp_Type))\n          then\n             Is_Indexed :=\n-              Try_Indexed_Call (N, Nam, Designated_Type (Subp_Type));\n+              Try_Indexed_Call\n+                (N, Nam, Designated_Type (Subp_Type), Must_Skip);\n \n          --  The prefix can also be a parameterless function that returns an\n          --  access to subprogram. in which case this is an indirect call.\n@@ -2131,7 +2188,7 @@ package body Sem_Ch4 is\n          --  skip first actual, which may be rewritten later as an\n          --  explicit dereference.\n \n-         if Skip_First then\n+         if Must_Skip then\n             Next_Actual (Actual);\n             Next_Formal (Formal);\n          end if;\n@@ -2618,16 +2675,33 @@ package body Sem_Ch4 is\n \n          Prefix_Type := Designated_Type (Prefix_Type);\n \n-         --  (Ada 2005): if the prefix is the limited view of a type, and\n-         --  the context already includes the full view, use the full view\n-         --  in what follows, either to retrieve a component of to find\n-         --  a primitive operation.\n+      end if;\n \n-         if Is_Incomplete_Type (Prefix_Type)\n-           and then From_With_Type (Prefix_Type)\n-           and then Present (Non_Limited_View (Prefix_Type))\n-         then\n-            Prefix_Type := Non_Limited_View (Prefix_Type);\n+      --  (Ada 2005): if the prefix is the limited view of a type, and\n+      --  the context already includes the full view, use the full view\n+      --  in what follows, either to retrieve a component of to find\n+      --  a primitive operation. If the prefix is an explicit dereference,\n+      --  set the type of the prefix to reflect this transformation.\n+\n+      if Is_Incomplete_Type (Prefix_Type)\n+        and then From_With_Type (Prefix_Type)\n+        and then Present (Non_Limited_View (Prefix_Type))\n+      then\n+         Prefix_Type := Non_Limited_View (Prefix_Type);\n+\n+         if Nkind (N) = N_Explicit_Dereference then\n+            Set_Etype (Prefix (N), Prefix_Type);\n+         end if;\n+\n+      elsif Ekind (Prefix_Type) = E_Class_Wide_Type\n+        and then From_With_Type (Prefix_Type)\n+        and then Present (Non_Limited_View (Etype (Prefix_Type)))\n+      then\n+         Prefix_Type :=\n+           Class_Wide_Type (Non_Limited_View (Etype (Prefix_Type)));\n+\n+         if Nkind (N) = N_Explicit_Dereference then\n+            Set_Etype (Prefix (N), Prefix_Type);\n          end if;\n       end if;\n \n@@ -2804,6 +2878,13 @@ package body Sem_Ch4 is\n                return;\n             end if;\n \n+            --  If the prefix is a private extension, check only the visible\n+            --  components of the partial view.\n+\n+            if Ekind (Prefix_Type) = E_Record_Type_With_Private then\n+               exit when Comp = Last_Entity (Prefix_Type);\n+            end if;\n+\n             Next_Entity (Comp);\n          end loop;\n \n@@ -2822,7 +2903,6 @@ package body Sem_Ch4 is\n          end if;\n \n       elsif Is_Private_Type (Prefix_Type) then\n-\n          --  Allow access only to discriminants of the type. If the type has\n          --  no full view, gigi uses the parent type for the components, so we\n          --  do the same here.\n@@ -2848,6 +2928,15 @@ package body Sem_Ch4 is\n                      Set_Original_Discriminant (Sel, Comp);\n                   end if;\n \n+               --  Before declararing an error, check whether this is tagged\n+               --  private type and a call to a primitive operation.\n+\n+               elsif Ada_Version >= Ada_05\n+                 and then Is_Tagged_Type (Prefix_Type)\n+                 and then Try_Object_Operation (N)\n+               then\n+                  return;\n+\n                else\n                   Error_Msg_NE\n                     (\"invisible selector for }\",\n@@ -2915,6 +3004,18 @@ package body Sem_Ch4 is\n                    Comp = First_Private_Entity (Base_Type (Prefix_Type));\n          end loop;\n \n+         --  If there is no visible entry with the given name, and the task\n+         --  implements an interface, check whether there is some other\n+         --  primitive operation with that name.\n+\n+         if Etype (N) = Any_Type\n+           and then Ada_Version >= Ada_05\n+           and then Is_Tagged_Type (Prefix_Type)\n+           and then Try_Object_Operation (N)\n+         then\n+            return;\n+         end if;\n+\n          Set_Is_Overloaded (N, Is_Overloaded (Sel));\n \n       else\n@@ -4528,7 +4629,7 @@ package body Sem_Ch4 is\n                Error_Msg_N\n                  (\"two access attributes cannot be compared directly\", N);\n                Error_Msg_N\n-                 (\"\\they must be converted to an explicit type for comparison\",\n+                 (\"\\use qualified expression for one of the operands\",\n                    N);\n                return;\n \n@@ -4589,7 +4690,7 @@ package body Sem_Ch4 is\n                         then\n                            if not Is_Immediately_Visible (Op_Id)\n                              and then not In_Use (Scope (Op_Id))\n-                             and then not Is_Abstract (Op_Id)\n+                             and then not Is_Abstract_Subprogram (Op_Id)\n                              and then not Is_Hidden (Op_Id)\n                              and then Ekind (Scope (Op_Id)) = E_Package\n                              and then\n@@ -4712,8 +4813,8 @@ package body Sem_Ch4 is\n          Get_First_Interp (N, I, It);\n \n          while Present (It.Nam) loop\n-            if not Is_Type (It.Nam)\n-              and then Is_Abstract (It.Nam)\n+            if Is_Overloadable (It.Nam)\n+              and then Is_Abstract_Subprogram (It.Nam)\n               and then not Is_Dispatching_Operation (It.Nam)\n             then\n                Abstract_Op := It.Nam;\n@@ -4932,16 +5033,25 @@ package body Sem_Ch4 is\n    ----------------------\n \n    function Try_Indexed_Call\n-     (N   : Node_Id;\n-      Nam : Entity_Id;\n-      Typ : Entity_Id) return Boolean\n+     (N          : Node_Id;\n+      Nam        : Entity_Id;\n+      Typ        : Entity_Id;\n+      Skip_First : Boolean) return Boolean\n    is\n       Actuals : constant List_Id   := Parameter_Associations (N);\n       Actual : Node_Id;\n       Index  : Entity_Id;\n \n    begin\n       Actual := First (Actuals);\n+\n+      --  If the call was originally written in prefix form, skip the first\n+      --  actual, which is obviously not defaulted.\n+\n+      if Skip_First then\n+         Next (Actual);\n+      end if;\n+\n       Index := First_Index (Typ);\n       while Present (Actual) and then Present (Index) loop\n \n@@ -5085,6 +5195,10 @@ package body Sem_Ch4 is\n             Rewrite (First_Actual, Obj);\n          end if;\n \n+         if Is_Overloaded (Call_Node) then\n+            Save_Interps (Call_Node, Node_To_Replace);\n+         end if;\n+\n          Rewrite (Node_To_Replace, Call_Node);\n          Analyze (Node_To_Replace);\n       end Complete_Object_Operation;\n@@ -5290,9 +5404,10 @@ package body Sem_Ch4 is\n             Typ : constant Entity_Id := Etype (First_Formal (Op));\n \n          begin\n-            --  Simple case\n+            --  Simple case. Object may be a subtype of the tagged type.\n \n-            return Base_Type (Obj_Type) = Typ\n+            return Obj_Type = Typ\n+              or else  Base_Type (Obj_Type) = Typ\n \n             --  Prefix can be dereferenced\n \n@@ -5314,8 +5429,17 @@ package body Sem_Ch4 is\n          --  Look for subprograms in the list of primitive operations\n          --  The name must be identical, and the kind of call indicates the\n          --  expected kind of operation (function or procedure).\n+         --  If the type is a (tagged) synchronized type, the primitive ops\n+         --  are attached to the corresponding record type.\n+\n+         if Is_Concurrent_Type (Obj_Type) then\n+            Elmt :=\n+              First_Elmt\n+               (Primitive_Operations (Corresponding_Record_Type (Obj_Type)));\n+         else\n+            Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n+         end if;\n \n-         Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n          while Present (Elmt) loop\n             Prim_Op := Node (Elmt);\n \n@@ -5355,24 +5479,16 @@ package body Sem_Ch4 is\n                      Success    => Success,\n                      Skip_First => True);\n \n-                  if Success then\n+                  if Success\n+                    or else Needs_One_Actual (Prim_Op)\n+                  then\n                      Op_Exists := True;\n-\n-                     --  If the operation is a procedure call, there can only\n-                     --  be one candidate and we found it. If it is a function\n-                     --  we must collect all interpretations, because there\n-                     --  may be several primitive operations that differ only\n-                     --  in the return type.\n-\n-                     if Nkind (Call_Node) = N_Procedure_Call_Statement then\n-                        exit;\n-                     end if;\n                   end if;\n \n-               elsif Ekind (Prim_Op) = E_Function then\n+               else\n \n-                  --  Collect remaining function interpretations, to be\n-                  --  resolved from context.\n+                  --  More than one interpretation, collect for subsequent\n+                  --  disambiguation.\n \n                   Add_One_Interp (Prim_Op_Ref, Prim_Op, Etype (Prim_Op));\n                end if;"}]}