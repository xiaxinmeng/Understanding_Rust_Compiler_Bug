{"sha": "c11c10d87b229fc9bfa4a1e0a5a342e3344f737d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzExYzEwZDg3YjIyOWZjOWJmYTRhMWUwYTVhMzQyZTMzNDRmNzM3ZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-11-21T23:32:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-21T23:32:03Z"}, "message": "expr.c (expand_expr, [...]): Refine slightly and also support TREE_ADDRESSABLE.\n\n\t* expr.c (expand_expr, case VIEW_CONVERT_EXPR): Refine slightly\n\tand also support TREE_ADDRESSABLE.\n\t* tree.def (VIEW_CONVERT_EXPR): Document TREE_ADDRESSABLE.\n\nFrom-SVN: r47249", "tree": {"sha": "c9328a6f72e26ab58f5c08b5f144508cc16878e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9328a6f72e26ab58f5c08b5f144508cc16878e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c11c10d87b229fc9bfa4a1e0a5a342e3344f737d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11c10d87b229fc9bfa4a1e0a5a342e3344f737d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c11c10d87b229fc9bfa4a1e0a5a342e3344f737d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11c10d87b229fc9bfa4a1e0a5a342e3344f737d/comments", "author": null, "committer": null, "parents": [{"sha": "2e7d5318fc0902a682ef1a2b1e43df40f7f3de29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e7d5318fc0902a682ef1a2b1e43df40f7f3de29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e7d5318fc0902a682ef1a2b1e43df40f7f3de29"}], "stats": {"total": 60, "additions": 35, "deletions": 25}, "files": [{"sha": "9b9595fb09aa7964ec145634f662890684a32f93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11c10d87b229fc9bfa4a1e0a5a342e3344f737d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11c10d87b229fc9bfa4a1e0a5a342e3344f737d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c11c10d87b229fc9bfa4a1e0a5a342e3344f737d", "patch": "@@ -1,3 +1,9 @@\n+Wed Nov 21 17:37:16 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (expand_expr, case VIEW_CONVERT_EXPR): Refine slightly\n+\tand also support TREE_ADDRESSABLE.\n+\t* tree.def (VIEW_CONVERT_EXPR): Document TREE_ADDRESSABLE.\n+\n 2001-11-21  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000.md (cmptf_internal1): Replace %$ with $."}, {"sha": "9ea2345ffa24e0b15952a056ecb717f150f571cc", "filename": "gcc/expr.c", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11c10d87b229fc9bfa4a1e0a5a342e3344f737d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11c10d87b229fc9bfa4a1e0a5a342e3344f737d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c11c10d87b229fc9bfa4a1e0a5a342e3344f737d", "patch": "@@ -7542,47 +7542,43 @@ expand_expr (exp, target, tmode, modifier)\n \n       /* If the input and output modes are both the same, we are done.\n \t Otherwise, if neither mode is BLKmode and both are within a word, we\n-\t can use gen_lowpart.  If neither is true, store the operand into\n-\t memory and convert the MEM to the new mode.  */\n+\t can use gen_lowpart.  If neither is true, make sure the operand is\n+\t in memory and convert the MEM to the new mode.  */\n       if (TYPE_MODE (type) == GET_MODE (op0))\n \t;\n       else if (TYPE_MODE (type) != BLKmode && GET_MODE (op0) != BLKmode\n \t       && GET_MODE_SIZE (TYPE_MODE (type)) <= UNITS_PER_WORD\n \t       && GET_MODE_SIZE (GET_MODE (op0)) <= UNITS_PER_WORD)\n \top0 = gen_lowpart (TYPE_MODE (type), op0);\n-      else\n+      else if (GET_CODE (op0) != MEM)\n \t{\n+\t  /* If the operand is not a MEM, force it into memory.  Since we\n+\t     are going to be be changing the mode of the MEM, don't call\n+\t     force_const_mem for constants because we don't allow pool\n+\t     constants to change mode.  */\n \t  tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n-\t  enum machine_mode non_blkmode\n-\t    = GET_MODE (op0) == BLKmode ? TYPE_MODE (type) : GET_MODE (op0);\n \n-\t  if (CONSTANT_P (op0))\n-\t    op0 = validize_mem (force_const_mem (TYPE_MODE (inner_type), op0));\n-\t  else\n-\t    {\n-\t      if (target == 0 || GET_MODE (target) != TYPE_MODE (inner_type))\n-\t\ttarget\n-\t\t  = assign_stack_temp_for_type (TYPE_MODE (inner_type),\n-\t\t\t\t\t\tGET_MODE_SIZE (non_blkmode),\n-\t\t\t\t\t\t0, inner_type);\n+\t  if (TREE_ADDRESSABLE (exp))\n+\t    abort ();\n \n-\t      if (GET_MODE (target) == BLKmode)\n-\t\temit_block_move (target, op0,\n-\t\t\t\t expr_size (TREE_OPERAND (exp, 0)));\n-\t      else\n-\t\temit_move_insn (target, op0);\n+\t  if (target == 0 || GET_MODE (target) != TYPE_MODE (inner_type))\n+\t    target\n+\t      = assign_stack_temp_for_type\n+\t\t(TYPE_MODE (inner_type),\n+\t\t GET_MODE_SIZE (TYPE_MODE (inner_type)), 0, inner_type);\n \n-\t      op0 = target;\n-\t    }\n+\t  emit_move_insn (target, op0);\n+\t  op0 = target;\n \t}\n \n+      /* At this point, OP0 is in the correct mode.  If the output type is such\n+\t that the operand is known to be aligned, indicate that it is.\n+\t Otherwise, we need only be concerned about alignment for non-BLKmode\n+\t results.  */\n       if (GET_CODE (op0) == MEM)\n \t{\n \t  op0 = copy_rtx (op0);\n \n-\t  /* If the output type is such that the operand is known to be\n-\t     aligned, indicate that it is.  Otherwise, we need only be\n-\t     concerned about alignment for non-BLKmode results.  */\n \t  if (TYPE_ALIGN_OK (type))\n \t    set_mem_align (op0, MAX (MEM_ALIGN (op0), TYPE_ALIGN (type)));\n \t  else if (TYPE_MODE (type) != BLKmode && STRICT_ALIGNMENT\n@@ -7595,6 +7591,9 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t\t\t    temp_size, 0, type);\n \t      rtx new_with_op0_mode = copy_rtx (new);\n \n+\t      if (TREE_ADDRESSABLE (exp))\n+\t\tabort ();\n+\n \t      PUT_MODE (new_with_op0_mode, GET_MODE (op0));\n \t      if (GET_MODE (op0) == BLKmode)\n \t\temit_block_move (new_with_op0_mode, op0,"}, {"sha": "39ea31c033bc1f9913dc51ee8c72df6bafb68961", "filename": "gcc/tree.def", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11c10d87b229fc9bfa4a1e0a5a342e3344f737d/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11c10d87b229fc9bfa4a1e0a5a342e3344f737d/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=c11c10d87b229fc9bfa4a1e0a5a342e3344f737d", "patch": "@@ -695,7 +695,12 @@ DEFTREECODE (NON_LVALUE_EXPR, \"non_lvalue_expr\", '1', 1)\n    This corresponds to an \"Unchecked Conversion\" in Ada and roughly to\n    the idiom *(type2 *)&X in C.  The only operand is the value to be\n    viewed as being of another type.  It is undefined if the type of the\n-   input and of the expression have different sizes.  */\n+   input and of the expression have different sizes.\n+\n+   This code may also be used within the LHS of a MODIFY_EXPR, in which\n+   case no actual data motion may occur.  TREE_ADDRESSABLE will be set in\n+   this case and GCC must abort if it could not do the operation without\n+   generating insns.  */\n DEFTREECODE (VIEW_CONVERT_EXPR, \"view_convert_expr\", '1', 1)\n \n /* Represents something we computed once and will use multiple times."}]}