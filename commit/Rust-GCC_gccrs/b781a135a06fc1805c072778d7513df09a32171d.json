{"sha": "b781a135a06fc1805c072778d7513df09a32171d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc4MWExMzVhMDZmYzE4MDVjMDcyNzc4ZDc1MTNkZjA5YTMyMTcxZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T18:01:24Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T18:01:24Z"}, "message": "Add support for in-order addition reduction using SVE FADDA\n\nThis patch adds support for in-order floating-point addition reductions,\nwhich are suitable even in strict IEEE mode.\n\nPreviously vect_is_simple_reduction would reject any cases that forbid\nreassociation.  The idea is instead to tentatively accept them as\n\"FOLD_LEFT_REDUCTIONs\" and only fail later if there is no support\nfor them.  Although this patch only handles the particular case of plus\nand minus on floating-point types, there's no reason in principle why\nwe couldn't handle other cases.\n\nThe reductions use a new fold_left_plus_optab if available, otherwise\nthey fall back to elementwise additions or subtractions.\n\nThe vect_force_simple_reduction change makes it easier for parloops\nto read the type of reduction.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* optabs.def (fold_left_plus_optab): New optab.\n\t* doc/md.texi (fold_left_plus_@var{m}): Document.\n\t* internal-fn.def (IFN_FOLD_LEFT_PLUS): New internal function.\n\t* internal-fn.c (fold_left_direct): Define.\n\t(expand_fold_left_optab_fn): Likewise.\n\t(direct_fold_left_optab_supported_p): Likewise.\n\t* fold-const-call.c (fold_const_fold_left): New function.\n\t(fold_const_call): Use it to fold CFN_FOLD_LEFT_PLUS.\n\t* tree-parloops.c (valid_reduction_p): New function.\n\t(gather_scalar_reductions): Use it.\n\t* tree-vectorizer.h (FOLD_LEFT_REDUCTION): New vect_reduction_type.\n\t(vect_finish_replace_stmt): Declare.\n\t* tree-vect-loop.c (fold_left_reduction_fn): New function.\n\t(needs_fold_left_reduction_p): New function, split out from...\n\t(vect_is_simple_reduction): ...here.  Accept reductions that\n\tforbid reassociation, but give them type FOLD_LEFT_REDUCTION.\n\t(vect_force_simple_reduction): Also store the reduction type in\n\tthe assignment's STMT_VINFO_REDUC_TYPE.\n\t(vect_model_reduction_cost): Handle FOLD_LEFT_REDUCTION.\n\t(merge_with_identity): New function.\n\t(vect_expand_fold_left): Likewise.\n\t(vectorize_fold_left_reduction): Likewise.\n\t(vectorizable_reduction): Handle FOLD_LEFT_REDUCTION.  Leave the\n\tscalar phi in place for it.  Check for target support and reject\n\tcases that would reassociate the operation.  Defer the transform\n\tphase to vectorize_fold_left_reduction.\n\t* config/aarch64/aarch64.md (UNSPEC_FADDA): New unspec.\n\t* config/aarch64/aarch64-sve.md (fold_left_plus_<mode>): New expander.\n\t(*fold_left_plus_<mode>, *pred_fold_left_plus_<mode>): New insns.\n\ngcc/testsuite/\n\t* gcc.dg/vect/no-fast-math-vect16.c: Expect the test to pass and\n\tcheck for a message about using in-order reductions.\n\t* gcc.dg/vect/pr79920.c: Expect both loops to be vectorized and\n\tcheck for a message about using in-order reductions.\n\t* gcc.dg/vect/trapv-vect-reduc-4.c: Expect all three loops to be\n\tvectorized and check for a message about using in-order reductions.\n\tExpect targets with variable-length vectors to fall back to the\n\tfixed-length mininum.\n\t* gcc.dg/vect/vect-reduc-6.c: Expect the loop to be vectorized and\n\tcheck for a message about using in-order reductions.\n\t* gcc.dg/vect/vect-reduc-in-order-1.c: New test.\n\t* gcc.dg/vect/vect-reduc-in-order-2.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-in-order-3.c: Likewise.\n\t* gcc.dg/vect/vect-reduc-in-order-4.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_strict_1.c: New test.\n\t* gcc.target/aarch64/sve/reduc_strict_1_run.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_strict_2.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_strict_2_run.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_strict_3.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_13.c: Add floating-point types.\n\t* gfortran.dg/vect/vect-8.f90: Expect 22 loops to be vectorized if\n\tvect_fold_left_plus.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256639", "tree": {"sha": "43af641081da5b462f6d95a1d23ab6b0f16dd13a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43af641081da5b462f6d95a1d23ab6b0f16dd13a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b781a135a06fc1805c072778d7513df09a32171d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b781a135a06fc1805c072778d7513df09a32171d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b781a135a06fc1805c072778d7513df09a32171d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b781a135a06fc1805c072778d7513df09a32171d/comments", "author": null, "committer": null, "parents": [{"sha": "b89fa419ca39b13b5ed0f7a23722b394b3af399e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b89fa419ca39b13b5ed0f7a23722b394b3af399e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b89fa419ca39b13b5ed0f7a23722b394b3af399e"}], "stats": {"total": 1039, "additions": 960, "deletions": 79}, "files": [{"sha": "a5daf352ca1b84138bae0a05d3ebf4a9874b5248", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -1,3 +1,37 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* optabs.def (fold_left_plus_optab): New optab.\n+\t* doc/md.texi (fold_left_plus_@var{m}): Document.\n+\t* internal-fn.def (IFN_FOLD_LEFT_PLUS): New internal function.\n+\t* internal-fn.c (fold_left_direct): Define.\n+\t(expand_fold_left_optab_fn): Likewise.\n+\t(direct_fold_left_optab_supported_p): Likewise.\n+\t* fold-const-call.c (fold_const_fold_left): New function.\n+\t(fold_const_call): Use it to fold CFN_FOLD_LEFT_PLUS.\n+\t* tree-parloops.c (valid_reduction_p): New function.\n+\t(gather_scalar_reductions): Use it.\n+\t* tree-vectorizer.h (FOLD_LEFT_REDUCTION): New vect_reduction_type.\n+\t(vect_finish_replace_stmt): Declare.\n+\t* tree-vect-loop.c (fold_left_reduction_fn): New function.\n+\t(needs_fold_left_reduction_p): New function, split out from...\n+\t(vect_is_simple_reduction): ...here.  Accept reductions that\n+\tforbid reassociation, but give them type FOLD_LEFT_REDUCTION.\n+\t(vect_force_simple_reduction): Also store the reduction type in\n+\tthe assignment's STMT_VINFO_REDUC_TYPE.\n+\t(vect_model_reduction_cost): Handle FOLD_LEFT_REDUCTION.\n+\t(merge_with_identity): New function.\n+\t(vect_expand_fold_left): Likewise.\n+\t(vectorize_fold_left_reduction): Likewise.\n+\t(vectorizable_reduction): Handle FOLD_LEFT_REDUCTION.  Leave the\n+\tscalar phi in place for it.  Check for target support and reject\n+\tcases that would reassociate the operation.  Defer the transform\n+\tphase to vectorize_fold_left_reduction.\n+\t* config/aarch64/aarch64.md (UNSPEC_FADDA): New unspec.\n+\t* config/aarch64/aarch64-sve.md (fold_left_plus_<mode>): New expander.\n+\t(*fold_left_plus_<mode>, *pred_fold_left_plus_<mode>): New insns.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-if-conv.c (predicate_mem_writes): Remove redundant"}, {"sha": "08956b9ce4ba4ddd2d7b6873b11e6ce14d59a57e", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -1550,6 +1550,45 @@\n   \"<bit_reduc_op>\\t%<Vetype>0, %1, %2.<Vetype>\"\n )\n \n+;; Unpredicated in-order FP reductions.\n+(define_expand \"fold_left_plus_<mode>\"\n+  [(set (match_operand:<VEL> 0 \"register_operand\")\n+\t(unspec:<VEL> [(match_dup 3)\n+\t\t       (match_operand:<VEL> 1 \"register_operand\")\n+\t\t       (match_operand:SVE_F 2 \"register_operand\")]\n+\t\t      UNSPEC_FADDA))]\n+  \"TARGET_SVE\"\n+  {\n+    operands[3] = force_reg (<VPRED>mode, CONSTM1_RTX (<VPRED>mode));\n+  }\n+)\n+\n+;; In-order FP reductions predicated with PTRUE.\n+(define_insn \"*fold_left_plus_<mode>\"\n+  [(set (match_operand:<VEL> 0 \"register_operand\" \"=w\")\n+\t(unspec:<VEL> [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n+\t\t       (match_operand:<VEL> 2 \"register_operand\" \"0\")\n+\t\t       (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n+\t\t      UNSPEC_FADDA))]\n+  \"TARGET_SVE\"\n+  \"fadda\\t%<Vetype>0, %1, %<Vetype>0, %3.<Vetype>\"\n+)\n+\n+;; Predicated form of the above in-order reduction.\n+(define_insn \"*pred_fold_left_plus_<mode>\"\n+  [(set (match_operand:<VEL> 0 \"register_operand\" \"=w\")\n+\t(unspec:<VEL>\n+\t  [(match_operand:<VEL> 1 \"register_operand\" \"0\")\n+\t   (unspec:SVE_F\n+\t     [(match_operand:<VPRED> 2 \"register_operand\" \"Upl\")\n+\t      (match_operand:SVE_F 3 \"register_operand\" \"w\")\n+\t      (match_operand:SVE_F 4 \"aarch64_simd_imm_zero\")]\n+\t     UNSPEC_SEL)]\n+\t  UNSPEC_FADDA))]\n+  \"TARGET_SVE\"\n+  \"fadda\\t%<Vetype>0, %2, %<Vetype>0, %3.<Vetype>\"\n+)\n+\n ;; Unpredicated floating-point addition.\n (define_expand \"add<mode>3\"\n   [(set (match_operand:SVE_F 0 \"register_operand\")"}, {"sha": "4a73ccc7c3f60af01d180ae2461dd6cb11333432", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -165,6 +165,7 @@\n     UNSPEC_STN\n     UNSPEC_INSR\n     UNSPEC_CLASTB\n+    UNSPEC_FADDA\n ])\n \n (define_c_enum \"unspecv\" ["}, {"sha": "4527b44d1af1b026d06125a4079c5196c33ecf33", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -5236,6 +5236,14 @@ has mode @var{m} and operands 0 and 1 have the mode appropriate for\n one element of @var{m}.  Operand 2 has the usual mask mode for vectors\n of mode @var{m}; see @code{TARGET_VECTORIZE_GET_MASK_MODE}.\n \n+@cindex @code{fold_left_plus_@var{m}} instruction pattern\n+@item @code{fold_left_plus_@var{m}}\n+Take scalar operand 1 and successively add each element from vector\n+operand 2.  Store the result in scalar operand 0.  The vector has\n+mode @var{m} and the scalars have the mode appropriate for one\n+element of @var{m}.  The operation is strictly in-order: there is\n+no reassociation.\n+\n @cindex @code{sdot_prod@var{m}} instruction pattern\n @item @samp{sdot_prod@var{m}}\n @cindex @code{udot_prod@var{m}} instruction pattern"}, {"sha": "fcf4a14ebaa75ca3a8fb4e4df83a724a79769140", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -1195,6 +1195,28 @@ fold_const_call (combined_fn fn, tree type, tree arg)\n     }\n }\n \n+/* Fold a call to IFN_FOLD_LEFT_<CODE> (ARG0, ARG1), returning a value\n+   of type TYPE.  */\n+\n+static tree\n+fold_const_fold_left (tree type, tree arg0, tree arg1, tree_code code)\n+{\n+  if (TREE_CODE (arg1) != VECTOR_CST)\n+    return NULL_TREE;\n+\n+  unsigned HOST_WIDE_INT nelts;\n+  if (!VECTOR_CST_NELTS (arg1).is_constant (&nelts))\n+    return NULL_TREE;\n+\n+  for (unsigned HOST_WIDE_INT i = 0; i < nelts; i++)\n+    {\n+      arg0 = const_binop (code, type, arg0, VECTOR_CST_ELT (arg1, i));\n+      if (arg0 == NULL_TREE || !CONSTANT_CLASS_P (arg0))\n+\treturn NULL_TREE;\n+    }\n+  return arg0;\n+}\n+\n /* Try to evaluate:\n \n       *RESULT = FN (*ARG0, *ARG1)\n@@ -1500,6 +1522,9 @@ fold_const_call (combined_fn fn, tree type, tree arg0, tree arg1)\n \t}\n       return NULL_TREE;\n \n+    case CFN_FOLD_LEFT_PLUS:\n+      return fold_const_fold_left (type, arg0, arg1, PLUS_EXPR);\n+\n     default:\n       return fold_const_call_1 (fn, type, arg0, arg1);\n     }"}, {"sha": "42cdf1345e560b297cf1b83e3fcc5b88e2109c84", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -92,6 +92,7 @@ init_internal_fns ()\n #define cond_binary_direct { 1, 1, true }\n #define while_direct { 0, 2, false }\n #define fold_extract_direct { 2, 2, false }\n+#define fold_left_direct { 1, 1, false }\n \n const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1] = {\n #define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) not_direct,\n@@ -2897,6 +2898,9 @@ expand_while_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n #define expand_fold_extract_optab_fn(FN, STMT, OPTAB) \\\n   expand_direct_optab_fn (FN, STMT, OPTAB, 3)\n \n+#define expand_fold_left_optab_fn(FN, STMT, OPTAB) \\\n+  expand_direct_optab_fn (FN, STMT, OPTAB, 2)\n+\n /* RETURN_TYPE and ARGS are a return type and argument list that are\n    in principle compatible with FN (which satisfies direct_internal_fn_p).\n    Return the types that should be used to determine whether the\n@@ -2980,6 +2984,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_mask_store_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_while_optab_supported_p convert_optab_supported_p\n #define direct_fold_extract_optab_supported_p direct_optab_supported_p\n+#define direct_fold_left_optab_supported_p direct_optab_supported_p\n \n /* Return the optab used by internal function FN.  */\n "}, {"sha": "36bcf885bf78d000420cc9e3319a3a2d2e684f18", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -58,6 +58,8 @@ along with GCC; see the file COPYING3.  If not see\n \n    - cond_binary: a conditional binary optab, such as add<mode>cc\n \n+   - fold_left: for scalar = FN (scalar, vector), keyed off the vector mode\n+\n    DEF_INTERNAL_SIGNED_OPTAB_FN defines an internal function that\n    maps to one of two optabs, depending on the signedness of an input.\n    SIGNED_OPTAB and UNSIGNED_OPTAB are the optabs for signed and\n@@ -162,6 +164,8 @@ DEF_INTERNAL_OPTAB_FN (EXTRACT_LAST, ECF_CONST | ECF_NOTHROW,\n DEF_INTERNAL_OPTAB_FN (FOLD_EXTRACT_LAST, ECF_CONST | ECF_NOTHROW,\n \t\t       fold_extract_last, fold_extract)\n \n+DEF_INTERNAL_OPTAB_FN (FOLD_LEFT_PLUS, ECF_CONST | ECF_NOTHROW,\n+\t\t       fold_left_plus, fold_left)\n \n /* Unary math functions.  */\n DEF_INTERNAL_FLT_FN (ACOS, ECF_CONST, acos, unary)"}, {"sha": "7fab96f2d6659bf7681741cd72c21da33ed4cdf8", "filename": "gcc/optabs.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -306,6 +306,7 @@ OPTAB_D (reduc_umin_scal_optab, \"reduc_umin_scal_$a\")\n OPTAB_D (reduc_and_scal_optab,  \"reduc_and_scal_$a\")\n OPTAB_D (reduc_ior_scal_optab,  \"reduc_ior_scal_$a\")\n OPTAB_D (reduc_xor_scal_optab,  \"reduc_xor_scal_$a\")\n+OPTAB_D (fold_left_plus_optab, \"fold_left_plus_$a\")\n \n OPTAB_D (extract_last_optab, \"extract_last_$a\")\n OPTAB_D (fold_extract_last_optab, \"fold_extract_last_$a\")"}, {"sha": "8c8987639e65df9a3b1b3ebe6823758208b737a2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -1,3 +1,30 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.dg/vect/no-fast-math-vect16.c: Expect the test to pass and\n+\tcheck for a message about using in-order reductions.\n+\t* gcc.dg/vect/pr79920.c: Expect both loops to be vectorized and\n+\tcheck for a message about using in-order reductions.\n+\t* gcc.dg/vect/trapv-vect-reduc-4.c: Expect all three loops to be\n+\tvectorized and check for a message about using in-order reductions.\n+\tExpect targets with variable-length vectors to fall back to the\n+\tfixed-length mininum.\n+\t* gcc.dg/vect/vect-reduc-6.c: Expect the loop to be vectorized and\n+\tcheck for a message about using in-order reductions.\n+\t* gcc.dg/vect/vect-reduc-in-order-1.c: New test.\n+\t* gcc.dg/vect/vect-reduc-in-order-2.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-in-order-3.c: Likewise.\n+\t* gcc.dg/vect/vect-reduc-in-order-4.c: Likewise.\n+\t* gcc.target/aarch64/sve/reduc_strict_1.c: New test.\n+\t* gcc.target/aarch64/sve/reduc_strict_1_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/reduc_strict_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/reduc_strict_2_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/reduc_strict_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_13.c: Add floating-point types.\n+\t* gfortran.dg/vect/vect-8.f90: Expect 22 loops to be vectorized if\n+\tvect_fold_left_plus.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.target/aarch64/sve/spill_1.c: Also test that no predicates"}, {"sha": "2445d605534cc096d6f9a0c560ef961aa29db433", "filename": "gcc/testsuite/gcc.dg/vect/no-fast-math-vect16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-fast-math-vect16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-fast-math-vect16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-fast-math-vect16.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -33,5 +33,5 @@ int main (void)\n   return main1 ();\n }\n \n-/* Requires fast-math.  */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times {using an in-order \\(fold-left\\) reduction} 1 \"vect\" } } */"}, {"sha": "9ba0fb3e4f52703739f5e485cf1d576b37e92f54", "filename": "gcc/testsuite/gcc.dg/vect/pr79920.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr79920.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr79920.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr79920.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-additional-options \"-O3\" } */\n+/* { dg-additional-options \"-O3 -fno-fast-math\" } */\n \n #include \"tree-vect.h\"\n \n@@ -41,4 +41,5 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_double && { vect_perm && vect_hw_misalign } } } } } */\n+/* { dg-final { scan-tree-dump-times {using an in-order \\(fold-left\\) reduction} 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target { vect_double && { vect_perm && vect_hw_misalign } } } } } */"}, {"sha": "8a57eb69a91c3f48dce4385ae6e4058d2369383e", "filename": "gcc/testsuite/gcc.dg/vect/trapv-vect-reduc-4.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftrapv-vect-reduc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftrapv-vect-reduc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftrapv-vect-reduc-4.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -46,5 +46,8 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Detected reduction\\\\.\" 2 \"vect\"  } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target { ! vect_no_int_min_max } } } } */\n+/* We can't handle the first loop with variable-length vectors and so\n+   fall back to the fixed-length mininum instead.  */\n+/* { dg-final { scan-tree-dump-times \"Detected reduction\\\\.\" 3 \"vect\" { xfail vect_variable_length } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { target { ! vect_no_int_min_max } } } } */\n+/* { dg-final { scan-tree-dump-times {using an in-order \\(fold-left\\) reduction} 1 \"vect\" } } */"}, {"sha": "f80d5ba8114d69f99c9b87a6a465aba245b3a3f7", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-6.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-6.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -1,4 +1,5 @@\n /* { dg-require-effective-target vect_float } */\n+/* { dg-additional-options \"-fno-fast-math\" } */\n \n #include <stdarg.h>\n #include \"tree-vect.h\"\n@@ -48,6 +49,5 @@ int main (void)\n   return 0;\n }\n \n-/* need -ffast-math to vectorizer these loops.  */\n-/* ARM NEON passes -ffast-math to these tests, so expect this to fail.  */\n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" { xfail arm_neon_ok } } } */\n+/* { dg-final { scan-tree-dump-times {using an in-order \\(fold-left\\) reduction} 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "cc73d524d5441ef97033e98f1b0b6718f7198d9c", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-in-order-1.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-in-order-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-in-order-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-in-order-1.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run { xfail { { i?86-*-* x86_64-*-* } && ia32 } } } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-add-options ieee } */\n+/* { dg-additional-options \"-fno-fast-math\" } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N (VECTOR_BITS * 17)\n+\n+double __attribute__ ((noinline, noclone))\n+reduc_plus_double (double *a, double *b)\n+{\n+  double r = 0, q = 3;\n+  for (int i = 0; i < N; i++)\n+    {\n+      r += a[i];\n+      q -= b[i];\n+    }\n+  return r * q;\n+}\n+\n+int __attribute__ ((optimize (1)))\n+main ()\n+{\n+  double a[N];\n+  double b[N];\n+  double r = 0, q = 3;\n+  for (int i = 0; i < N; i++)\n+    {\n+      a[i] = (i * 0.1) * (i & 1 ? 1 : -1);\n+      b[i] = (i * 0.3) * (i & 1 ? 1 : -1);\n+      r += a[i];\n+      q -= b[i];\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  double res = reduc_plus_double (a, b);\n+  if (res != r * q)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times {using an in-order \\(fold-left\\) reduction} 2 \"vect\" } } */"}, {"sha": "dea6cdd00480894a7faf655cd8f59ee46c7919bb", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-in-order-2.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-in-order-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-in-order-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-in-order-2.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run { xfail { { i?86-*-* x86_64-*-* } && ia32 } } } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-add-options ieee } */\n+/* { dg-additional-options \"-fno-fast-math\" } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N (VECTOR_BITS * 17)\n+\n+double __attribute__ ((noinline, noclone))\n+reduc_plus_double (double *restrict a, int n)\n+{\n+  double res = 0.0;\n+  for (int i = 0; i < n; i++)\n+    for (int j = 0; j < N; j++)\n+      res += a[i];\n+  return res;\n+}\n+\n+int __attribute__ ((optimize (1)))\n+main ()\n+{\n+  int n = 19;\n+  double a[N];\n+  double r = 0;\n+  for (int i = 0; i < N; i++)\n+    {\n+      a[i] = (i * 0.1) * (i & 1 ? 1 : -1);\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  for (int i = 0; i < n; i++)\n+    for (int j = 0; j < N; j++)\n+      {\n+\tr += a[i];\n+\tasm volatile (\"\" ::: \"memory\");\n+      }\n+  double res = reduc_plus_double (a, n);\n+  if (res != r)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {in-order double reduction not supported} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times {using an in-order \\(fold-left\\) reduction} 1 \"vect\" } } */"}, {"sha": "037213ee31c689618fba08fa6c508261dacf2f0f", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-in-order-3.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-in-order-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-in-order-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-in-order-3.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run { xfail { { i?86-*-* x86_64-*-* } && ia32 } } } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-add-options ieee } */\n+/* { dg-additional-options \"-fno-fast-math\" } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N (VECTOR_BITS * 17)\n+\n+double __attribute__ ((noinline, noclone))\n+reduc_plus_double (double *a)\n+{\n+  double r = 0;\n+  for (int i = 0; i < N; i += 4)\n+    {\n+      r += a[i] * 2.0;\n+      r += a[i + 1] * 3.0;\n+      r += a[i + 2] * 4.0;\n+      r += a[i + 3] * 5.0;\n+    }\n+  return r;\n+}\n+\n+int __attribute__ ((optimize (1)))\n+main ()\n+{\n+  double a[N];\n+  double r = 0;\n+  for (int i = 0; i < N; i++)\n+    {\n+      a[i] = (i * 0.1) * (i & 1 ? 1 : -1);\n+      r += a[i] * (i % 4 + 2);\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  double res = reduc_plus_double (a);\n+  if (res != r)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times {using an in-order \\(fold-left\\) reduction} 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times {vectorizing stmts using SLP} 1 \"vect\" } } */"}, {"sha": "46d0f3a04648d3493521e81da83e8e63051d82de", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-in-order-4.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-in-order-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-in-order-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-in-order-4.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run { xfail { { i?86-*-* x86_64-*-* } && ia32 } } } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-add-options ieee } */\n+/* { dg-additional-options \"-fno-fast-math\" } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N (VECTOR_BITS * 17)\n+\n+double __attribute__ ((noinline, noclone))\n+reduc_plus_double (double *a)\n+{\n+  double r1 = 0;\n+  double r2 = 0;\n+  double r3 = 0;\n+  double r4 = 0;\n+  for (int i = 0; i < N; i += 4)\n+    {\n+      r1 += a[i];\n+      r2 += a[i + 1];\n+      r3 += a[i + 2];\n+      r4 += a[i + 3];\n+    }\n+  return r1 * r2 * r3 * r4;\n+}\n+\n+int __attribute__ ((optimize (1)))\n+main ()\n+{\n+  double a[N];\n+  double r[4] = {};\n+  for (int i = 0; i < N; i++)\n+    {\n+      a[i] = (i * 0.1) * (i & 1 ? 1 : -1);\n+      r[i % 4] += a[i];\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  double res = reduc_plus_double (a);\n+  if (res != r[0] * r[1] * r[2] * r[3])\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {in-order unchained SLP reductions not supported} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vectorizing stmts using SLP} \"vect\" } } */"}, {"sha": "4c75807c85e13633c81a6146283634c9066cdb16", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_strict_1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_1.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define NUM_ELEMS(TYPE) ((int)(5 * (256 / sizeof (TYPE)) + 3))\n+\n+#define DEF_REDUC_PLUS(TYPE)\t\t\t\\\n+  TYPE __attribute__ ((noinline, noclone))\t\\\n+  reduc_plus_##TYPE (TYPE *a, TYPE *b)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TYPE r = 0, q = 3;\t\t\t\t\\\n+    for (int i = 0; i < NUM_ELEMS (TYPE); i++)\t\\\n+      {\t\t\t\t\t\t\\\n+\tr += a[i];\t\t\t\t\\\n+\tq -= b[i];\t\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+    return r * q;\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T) \\\n+  T (_Float16) \\\n+  T (float) \\\n+  T (double)\n+\n+TEST_ALL (DEF_REDUC_PLUS)\n+\n+/* { dg-final { scan-assembler-times {\\tfadda\\th[0-9]+, p[0-7], h[0-9]+, z[0-9]+\\.h} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfadda\\ts[0-9]+, p[0-7], s[0-9]+, z[0-9]+\\.s} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfadda\\td[0-9]+, p[0-7], d[0-9]+, z[0-9]+\\.d} 2 } } */"}, {"sha": "40e0cf0a6dd5c4358fc09ff6972a214c2adee9fc", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_strict_1_run.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_1_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_1_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_1_run.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run { target { aarch64_sve_hw } } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"reduc_strict_1.c\"\n+\n+#define TEST_REDUC_PLUS(TYPE)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TYPE a[NUM_ELEMS (TYPE)];\t\t\t\\\n+    TYPE b[NUM_ELEMS (TYPE)];\t\t\t\\\n+    TYPE r = 0, q = 3;\t\t\t\t\\\n+    for (int i = 0; i < NUM_ELEMS (TYPE); i++)\t\\\n+      {\t\t\t\t\t\t\\\n+\ta[i] = (i * 0.1) * (i & 1 ? 1 : -1);\t\\\n+\tb[i] = (i * 0.3) * (i & 1 ? 1 : -1);\t\\\n+\tr += a[i];\t\t\t\t\\\n+\tq -= b[i];\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\\\n+      }\t\t\t\t\t\t\\\n+    TYPE res = reduc_plus_##TYPE (a, b);\t\\\n+    if (res != r * q)\t\t\t\t\\\n+      __builtin_abort ();\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main ()\n+{\n+  TEST_ALL (TEST_REDUC_PLUS);\n+  return 0;\n+}"}, {"sha": "d32efc29db1c196d50e9a81fcd3c267da599f7a3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_strict_2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_2.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define NUM_ELEMS(TYPE) ((int) (5 * (256 / sizeof (TYPE)) + 3))\n+\n+#define DEF_REDUC_PLUS(TYPE)\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\\\n+reduc_plus_##TYPE (TYPE (*restrict a)[NUM_ELEMS (TYPE)],\t\\\n+\t\t   TYPE *restrict r, int n)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; i++)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      r[i] = 0;\t\t\t\t\t\t\t\\\n+      for (int j = 0; j < NUM_ELEMS (TYPE); j++)\t\t\\\n+        r[i] += a[i][j];\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define TEST_ALL(T) \\\n+  T (_Float16) \\\n+  T (float) \\\n+  T (double)\n+\n+TEST_ALL (DEF_REDUC_PLUS)\n+\n+/* { dg-final { scan-assembler-times {\\tfadda\\th[0-9]+, p[0-7], h[0-9]+, z[0-9]+\\.h} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadda\\ts[0-9]+, p[0-7], s[0-9]+, z[0-9]+\\.s} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadda\\td[0-9]+, p[0-7], d[0-9]+, z[0-9]+\\.d} 1 } } */"}, {"sha": "e59f640dfd361b3697501a9e6bfec6af437a9531", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_strict_2_run.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_2_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_2_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_2_run.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run { target { aarch64_sve_hw } } } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-inline\" } */\n+\n+#include \"reduc_strict_2.c\"\n+\n+#define NROWS 5\n+\n+#define TEST_REDUC_PLUS(TYPE)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE a[NROWS][NUM_ELEMS (TYPE)];\t\t\t\t\\\n+    TYPE r[NROWS];\t\t\t\t\t\t\\\n+    TYPE expected[NROWS] = {};\t\t\t\t\t\\\n+    for (int i = 0; i < NROWS; ++i)\t\t\t\t\\\n+      for (int j = 0; j < NUM_ELEMS (TYPE); ++j)\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  a[i][j] = (i * 0.1 + j * 0.6) * (j & 1 ? 1 : -1);\t\\\n+\t  expected[i] += a[i][j];\t\t\t\t\\\n+\t  asm volatile (\"\" ::: \"memory\");\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    reduc_plus_##TYPE (a, r, NROWS);\t\t\t\t\\\n+    for (int i = 0; i < NROWS; ++i)\t\t\t\t\\\n+      if (r[i] != expected[i])\t\t\t\t\t\\\n+\t__builtin_abort ();\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main ()\n+{\n+  TEST_ALL (TEST_REDUC_PLUS);\n+  return 0;\n+}"}, {"sha": "a28145febce65b443f3b84d12e61139b1aa23ac7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_strict_3.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_strict_3.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -0,0 +1,131 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-inline -msve-vector-bits=256 -fdump-tree-vect-details\" } */\n+\n+double mat[100][4];\n+double mat2[100][8];\n+double mat3[100][12];\n+double mat4[100][3];\n+\n+double\n+slp_reduc_plus (int n)\n+{\n+  double tmp = 0.0;\n+  for (int i = 0; i < n; i++)\n+    {\n+      tmp = tmp + mat[i][0];\n+      tmp = tmp + mat[i][1];\n+      tmp = tmp + mat[i][2];\n+      tmp = tmp + mat[i][3];\n+    }\n+  return tmp;\n+}\n+\n+double\n+slp_reduc_plus2 (int n)\n+{\n+  double tmp = 0.0;\n+  for (int i = 0; i < n; i++)\n+    {\n+      tmp = tmp + mat2[i][0];\n+      tmp = tmp + mat2[i][1];\n+      tmp = tmp + mat2[i][2];\n+      tmp = tmp + mat2[i][3];\n+      tmp = tmp + mat2[i][4];\n+      tmp = tmp + mat2[i][5];\n+      tmp = tmp + mat2[i][6];\n+      tmp = tmp + mat2[i][7];\n+    }\n+  return tmp;\n+}\n+\n+double\n+slp_reduc_plus3 (int n)\n+{\n+  double tmp = 0.0;\n+  for (int i = 0; i < n; i++)\n+    {\n+      tmp = tmp + mat3[i][0];\n+      tmp = tmp + mat3[i][1];\n+      tmp = tmp + mat3[i][2];\n+      tmp = tmp + mat3[i][3];\n+      tmp = tmp + mat3[i][4];\n+      tmp = tmp + mat3[i][5];\n+      tmp = tmp + mat3[i][6];\n+      tmp = tmp + mat3[i][7];\n+      tmp = tmp + mat3[i][8];\n+      tmp = tmp + mat3[i][9];\n+      tmp = tmp + mat3[i][10];\n+      tmp = tmp + mat3[i][11];\n+    }\n+  return tmp;\n+}\n+\n+void\n+slp_non_chained_reduc (int n, double * restrict out)\n+{\n+  for (int i = 0; i < 3; i++)\n+    out[i] = 0;\n+\n+  for (int i = 0; i < n; i++)\n+    {\n+      out[0] = out[0] + mat4[i][0];\n+      out[1] = out[1] + mat4[i][1];\n+      out[2] = out[2] + mat4[i][2];\n+    }\n+}\n+\n+/* Strict FP reductions shouldn't be used for the outer loops, only the\n+   inner loops.  */\n+\n+float\n+double_reduc1 (float (*restrict i)[16])\n+{\n+  float l = 0;\n+\n+  for (int a = 0; a < 8; a++)\n+    for (int b = 0; b < 8; b++)\n+      l += i[b][a];\n+  return l;\n+}\n+\n+float\n+double_reduc2 (float *restrict i)\n+{\n+  float l = 0;\n+\n+  for (int a = 0; a < 8; a++)\n+    for (int b = 0; b < 16; b++)\n+      {\n+        l += i[b * 4];\n+        l += i[b * 4 + 1];\n+        l += i[b * 4 + 2];\n+        l += i[b * 4 + 3];\n+      }\n+  return l;\n+}\n+\n+float\n+double_reduc3 (float *restrict i, float *restrict j)\n+{\n+  float k = 0, l = 0;\n+\n+  for (int a = 0; a < 8; a++)\n+    for (int b = 0; b < 8; b++)\n+      {\n+        k += i[b];\n+        l += j[b];\n+      }\n+  return l * k;\n+}\n+\n+/* We can't yet handle double_reduc1.  */\n+/* { dg-final { scan-assembler-times {\\tfadda\\ts[0-9]+, p[0-7], s[0-9]+, z[0-9]+\\.s} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tfadda\\td[0-9]+, p[0-7], d[0-9]+, z[0-9]+\\.d} 9 } } */\n+/* 1 reduction each for double_reduc{1,2} and 2 for double_reduc3.  Each one\n+   is reported three times, once for SVE, once for 128-bit AdvSIMD and once\n+   for 64-bit AdvSIMD.  */\n+/* { dg-final { scan-tree-dump-times \"Detected double reduction\" 12 \"vect\" } } */\n+/* double_reduc2 has 2 reductions and slp_non_chained_reduc has 3.\n+   double_reduc1 is reported 3 times (SVE, 128-bit AdvSIMD, 64-bit AdvSIMD)\n+   before failing.  */\n+/* { dg-final { scan-tree-dump-times \"Detected reduction\" 12 \"vect\" } } */"}, {"sha": "0b2a7ad57e37175b47ef82a00550dd0470e9af78", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_13.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_13.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+/* The cost model thinks that the double loop isn't a win for SVE-128.  */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable -fno-vect-cost-model\" } */\n \n #include <stdint.h>\n \n@@ -24,29 +25,36 @@ vec_slp_##TYPE (TYPE *restrict a, int n)\t\t\t\\\n   T (int32_t)\t\t\t\t\t\\\n   T (uint32_t)\t\t\t\t\t\\\n   T (int64_t)\t\t\t\t\t\\\n-  T (uint64_t)\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (_Float16)\t\t\t\t\t\\\n+  T (float)\t\t\t\t\t\\\n+  T (double)\n \n TEST_ALL (VEC_PERM)\n \n /* ??? We don't treat the int8_t and int16_t loops as reductions.  */\n /* ??? We don't treat the uint loops as SLP.  */\n /* The loop should be fully-masked.  */\n /* { dg-final { scan-assembler-times {\\tld1b\\t} 2 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tld1h\\t} 2 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tld1w\\t} 2 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tld1w\\t} 1 } } */\n-/* { dg-final { scan-assembler-times {\\tld1d\\t} 2 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tld1d\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 3 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 3 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 3 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 2 } } */\n /* { dg-final { scan-assembler-not {\\tldr} { xfail *-*-* } } } */\n \n /* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b} 4 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 4 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 4 } } */\n-/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 6 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d} 6 } } */\n \n /* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.b\\n} 2 { xfail *-*-* } } } */\n /* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.h\\n} 2 { xfail *-*-* } } } */\n /* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.s\\n} 2 } } */\n /* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.d\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfadda\\th[0-9]+, p[0-7], h[0-9]+, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadda\\ts[0-9]+, p[0-7], s[0-9]+, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadda\\td[0-9]+, p[0-7], d[0-9]+, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-not {\\tfadd\\n} } } */\n \n /* { dg-final { scan-assembler-not {\\tuqdec} } } */"}, {"sha": "0ac5f1c390b365bdb04e49b8e94b10bcb15f0eea", "filename": "gcc/testsuite/gfortran.dg/vect/vect-8.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-8.f90?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -704,5 +704,5 @@ SUBROUTINE kernel(tk)\n RETURN\n END SUBROUTINE kernel\n \n-! { dg-final { scan-tree-dump-times \"vectorized 21 loops\" 1 \"vect\" { target { vect_intdouble_cvt } } } }\n+! { dg-final { scan-tree-dump-times \"vectorized 22 loops\" 1 \"vect\" { target vect_intdouble_cvt } } }\n ! { dg-final { scan-tree-dump-times \"vectorized 17 loops\" 1 \"vect\" { target { ! vect_intdouble_cvt } } } }"}, {"sha": "e44ad5e6861f31795d9a66ba1604109cea205279", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -2531,6 +2531,19 @@ set_reduc_phi_uids (reduction_info **slot, void *data ATTRIBUTE_UNUSED)\n   return 1;\n }\n \n+/* Return true if the type of reduction performed by STMT is suitable\n+   for this pass.  */\n+\n+static bool\n+valid_reduction_p (gimple *stmt)\n+{\n+  /* Parallelization would reassociate the operation, which isn't\n+     allowed for in-order reductions.  */\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  vect_reduction_type reduc_type = STMT_VINFO_REDUC_TYPE (stmt_info);\n+  return reduc_type != FOLD_LEFT_REDUCTION;\n+}\n+\n /* Detect all reductions in the LOOP, insert them into REDUCTION_LIST.  */\n \n static void\n@@ -2564,7 +2577,7 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list\n       gimple *reduc_stmt\n \t= vect_force_simple_reduction (simple_loop_info, phi,\n \t\t\t\t       &double_reduc, true);\n-      if (!reduc_stmt)\n+      if (!reduc_stmt || !valid_reduction_p (reduc_stmt))\n \tcontinue;\n \n       if (double_reduc)\n@@ -2610,7 +2623,8 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list\n \t\t= vect_force_simple_reduction (simple_loop_info, inner_phi,\n \t\t\t\t\t       &double_reduc, true);\n \t      gcc_assert (!double_reduc);\n-\t      if (inner_reduc_stmt == NULL)\n+\t      if (inner_reduc_stmt == NULL\n+\t\t  || !valid_reduction_p (inner_reduc_stmt))\n \t\tcontinue;\n \n \t      build_new_reduction (reduction_list, double_reduc_stmts[i], phi);"}, {"sha": "7fc2215b12aa8d014e5ab5fbe9b8f3f2bc02d402", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 338, "deletions": 56, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -2576,6 +2576,22 @@ vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo)\n     }\n }\n \n+/* Return true if there is an in-order reduction function for CODE, storing\n+   it in *REDUC_FN if so.  */\n+\n+static bool\n+fold_left_reduction_fn (tree_code code, internal_fn *reduc_fn)\n+{\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+      *reduc_fn = IFN_FOLD_LEFT_PLUS;\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n \n /* Function reduction_fn_for_scalar_code\n \n@@ -2882,6 +2898,42 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n   return true;\n }\n \n+/* Return true if we need an in-order reduction for operation CODE\n+   on type TYPE.  NEED_WRAPPING_INTEGRAL_OVERFLOW is true if integer\n+   overflow must wrap.  */\n+\n+static bool\n+needs_fold_left_reduction_p (tree type, tree_code code,\n+\t\t\t     bool need_wrapping_integral_overflow)\n+{\n+  /* CHECKME: check for !flag_finite_math_only too?  */\n+  if (SCALAR_FLOAT_TYPE_P (type))\n+    switch (code)\n+      {\n+      case MIN_EXPR:\n+      case MAX_EXPR:\n+\treturn false;\n+\n+      default:\n+\treturn !flag_associative_math;\n+      }\n+\n+  if (INTEGRAL_TYPE_P (type))\n+    {\n+      if (!operation_no_trapping_overflow (type, code))\n+\treturn true;\n+      if (need_wrapping_integral_overflow\n+\t  && !TYPE_OVERFLOW_WRAPS (type)\n+\t  && operation_can_overflow (code))\n+\treturn true;\n+      return false;\n+    }\n+\n+  if (SAT_FIXED_POINT_TYPE_P (type))\n+    return true;\n+\n+  return false;\n+}\n \n /* Return true if the reduction PHI in LOOP with latch arg LOOP_ARG and\n    reduction operation CODE has a handled computation expression.  */\n@@ -3308,58 +3360,18 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n       return NULL;\n     }\n \n-  /* Check that it's ok to change the order of the computation.\n+  /* Check whether it's ok to change the order of the computation.\n      Generally, when vectorizing a reduction we change the order of the\n      computation.  This may change the behavior of the program in some\n      cases, so we need to check that this is ok.  One exception is when\n      vectorizing an outer-loop: the inner-loop is executed sequentially,\n      and therefore vectorizing reductions in the inner-loop during\n      outer-loop vectorization is safe.  */\n-\n-  if (*v_reduc_type != COND_REDUCTION\n-      && check_reduction)\n-    {\n-      /* CHECKME: check for !flag_finite_math_only too?  */\n-      if (SCALAR_FLOAT_TYPE_P (type) && !flag_associative_math)\n-\t{\n-\t  /* Changing the order of operations changes the semantics.  */\n-\t  if (dump_enabled_p ())\n-\t    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t\"reduction: unsafe fp math optimization: \");\n-\t  return NULL;\n-\t}\n-      else if (INTEGRAL_TYPE_P (type))\n-\t{\n-\t  if (!operation_no_trapping_overflow (type, code))\n-\t    {\n-\t      /* Changing the order of operations changes the semantics.  */\n-\t      if (dump_enabled_p ())\n-\t\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t\t\"reduction: unsafe int math optimization\"\n-\t\t\t\t\" (overflow traps): \");\n-\t      return NULL;\n-\t    }\n-\t  if (need_wrapping_integral_overflow\n-\t      && !TYPE_OVERFLOW_WRAPS (type)\n-\t      && operation_can_overflow (code))\n-\t    {\n-\t      /* Changing the order of operations changes the semantics.  */\n-\t      if (dump_enabled_p ())\n-\t\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t\t\"reduction: unsafe int math optimization\"\n-\t\t\t\t\" (overflow doesn't wrap): \");\n-\t      return NULL;\n-\t    }\n-\t}\n-      else if (SAT_FIXED_POINT_TYPE_P (type))\n-\t{\n-\t  /* Changing the order of operations changes the semantics.  */\n-\t  if (dump_enabled_p ())\n-\t  report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t  \"reduction: unsafe fixed-point math optimization: \");\n-\t  return NULL;\n-\t}\n-    }\n+  if (check_reduction\n+      && *v_reduc_type == TREE_CODE_REDUCTION\n+      && needs_fold_left_reduction_p (type, code,\n+\t\t\t\t      need_wrapping_integral_overflow))\n+    *v_reduc_type = FOLD_LEFT_REDUCTION;\n \n   /* Reduction is safe. We're dealing with one of the following:\n      1) integer arithmetic and no trapv\n@@ -3525,6 +3537,7 @@ vect_force_simple_reduction (loop_vec_info loop_info, gimple *phi,\n       STMT_VINFO_REDUC_TYPE (reduc_def_info) = v_reduc_type;\n       STMT_VINFO_REDUC_DEF (reduc_def_info) = def;\n       reduc_def_info = vinfo_for_stmt (def);\n+      STMT_VINFO_REDUC_TYPE (reduc_def_info) = v_reduc_type;\n       STMT_VINFO_REDUC_DEF (reduc_def_info) = phi;\n     }\n   return def;\n@@ -4076,14 +4089,27 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \n   code = gimple_assign_rhs_code (orig_stmt);\n \n-  if (reduction_type == EXTRACT_LAST_REDUCTION)\n+  if (reduction_type == EXTRACT_LAST_REDUCTION\n+      || reduction_type == FOLD_LEFT_REDUCTION)\n     {\n       /* No extra instructions needed in the prologue.  */\n       prologue_cost = 0;\n \n-      /* Count NCOPIES FOLD_EXTRACT_LAST operations.  */\n-      inside_cost = add_stmt_cost (target_cost_data, ncopies, vec_to_scalar,\n-\t\t\t\t   stmt_info, 0, vect_body);\n+      if (reduction_type == EXTRACT_LAST_REDUCTION || reduc_fn != IFN_LAST)\n+\t/* Count one reduction-like operation per vector.  */\n+\tinside_cost = add_stmt_cost (target_cost_data, ncopies, vec_to_scalar,\n+\t\t\t\t     stmt_info, 0, vect_body);\n+      else\n+\t{\n+\t  /* Use NELEMENTS extracts and NELEMENTS scalar ops.  */\n+\t  unsigned int nelements = ncopies * vect_nunits_for_cost (vectype);\n+\t  inside_cost = add_stmt_cost (target_cost_data,  nelements,\n+\t\t\t\t       vec_to_scalar, stmt_info, 0,\n+\t\t\t\t       vect_body);\n+\t  inside_cost += add_stmt_cost (target_cost_data,  nelements,\n+\t\t\t\t\tscalar_stmt, stmt_info, 0,\n+\t\t\t\t\tvect_body);\n+\t}\n     }\n   else\n     {\n@@ -4149,7 +4175,8 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \t\t\t\t\t  scalar_stmt, stmt_info, 0,\n \t\t\t\t\t  vect_epilogue);\n \t}\n-      else if (reduction_type == EXTRACT_LAST_REDUCTION)\n+      else if (reduction_type == EXTRACT_LAST_REDUCTION\n+\t       || reduction_type == FOLD_LEFT_REDUCTION)\n \t/* No extra instructions need in the epilogue.  */\n \t;\n       else\n@@ -6025,6 +6052,197 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n     }\n }\n \n+/* Return a vector of type VECTYPE that is equal to the vector select\n+   operation \"MASK ? VEC : IDENTITY\".  Insert the select statements\n+   before GSI.  */\n+\n+static tree\n+merge_with_identity (gimple_stmt_iterator *gsi, tree mask, tree vectype,\n+\t\t     tree vec, tree identity)\n+{\n+  tree cond = make_temp_ssa_name (vectype, NULL, \"cond\");\n+  gimple *new_stmt = gimple_build_assign (cond, VEC_COND_EXPR,\n+\t\t\t\t\t  mask, vec, identity);\n+  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+  return cond;\n+}\n+\n+/* Successively apply CODE to each element of VECTOR_RHS, in left-to-right\n+   order, starting with LHS.  Insert the extraction statements before GSI and\n+   associate the new scalar SSA names with variable SCALAR_DEST.\n+   Return the SSA name for the result.  */\n+\n+static tree\n+vect_expand_fold_left (gimple_stmt_iterator *gsi, tree scalar_dest,\n+\t\t       tree_code code, tree lhs, tree vector_rhs)\n+{\n+  tree vectype = TREE_TYPE (vector_rhs);\n+  tree scalar_type = TREE_TYPE (vectype);\n+  tree bitsize = TYPE_SIZE (scalar_type);\n+  unsigned HOST_WIDE_INT vec_size_in_bits = tree_to_uhwi (TYPE_SIZE (vectype));\n+  unsigned HOST_WIDE_INT element_bitsize = tree_to_uhwi (bitsize);\n+\n+  for (unsigned HOST_WIDE_INT bit_offset = 0;\n+       bit_offset < vec_size_in_bits;\n+       bit_offset += element_bitsize)\n+    {\n+      tree bitpos = bitsize_int (bit_offset);\n+      tree rhs = build3 (BIT_FIELD_REF, scalar_type, vector_rhs,\n+\t\t\t bitsize, bitpos);\n+\n+      gassign *stmt = gimple_build_assign (scalar_dest, rhs);\n+      rhs = make_ssa_name (scalar_dest, stmt);\n+      gimple_assign_set_lhs (stmt, rhs);\n+      gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+\n+      stmt = gimple_build_assign (scalar_dest, code, lhs, rhs);\n+      tree new_name = make_ssa_name (scalar_dest, stmt);\n+      gimple_assign_set_lhs (stmt, new_name);\n+      gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+      lhs = new_name;\n+    }\n+  return lhs;\n+}\n+\n+/* Perform an in-order reduction (FOLD_LEFT_REDUCTION).  STMT is the\n+   statement that sets the live-out value.  REDUC_DEF_STMT is the phi\n+   statement.  CODE is the operation performed by STMT and OPS are\n+   its scalar operands.  REDUC_INDEX is the index of the operand in\n+   OPS that is set by REDUC_DEF_STMT.  REDUC_FN is the function that\n+   implements in-order reduction, or IFN_LAST if we should open-code it.\n+   VECTYPE_IN is the type of the vector input.  MASKS specifies the masks\n+   that should be used to control the operation in a fully-masked loop.  */\n+\n+static bool\n+vectorize_fold_left_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n+\t\t\t       gimple **vec_stmt, slp_tree slp_node,\n+\t\t\t       gimple *reduc_def_stmt,\n+\t\t\t       tree_code code, internal_fn reduc_fn,\n+\t\t\t       tree ops[3], tree vectype_in,\n+\t\t\t       int reduc_index, vec_loop_masks *masks)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n+  gimple *new_stmt = NULL;\n+\n+  int ncopies;\n+  if (slp_node)\n+    ncopies = 1;\n+  else\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype_in);\n+\n+  gcc_assert (!nested_in_vect_loop_p (loop, stmt));\n+  gcc_assert (ncopies == 1);\n+  gcc_assert (TREE_CODE_LENGTH (code) == binary_op);\n+  gcc_assert (reduc_index == (code == MINUS_EXPR ? 0 : 1));\n+  gcc_assert (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t      == FOLD_LEFT_REDUCTION);\n+\n+  if (slp_node)\n+    gcc_assert (known_eq (TYPE_VECTOR_SUBPARTS (vectype_out),\n+\t\t\t  TYPE_VECTOR_SUBPARTS (vectype_in)));\n+\n+  tree op0 = ops[1 - reduc_index];\n+\n+  int group_size = 1;\n+  gimple *scalar_dest_def;\n+  auto_vec<tree> vec_oprnds0;\n+  if (slp_node)\n+    {\n+      vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL, slp_node);\n+      group_size = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n+      scalar_dest_def = SLP_TREE_SCALAR_STMTS (slp_node)[group_size - 1];\n+    }\n+  else\n+    {\n+      tree loop_vec_def0 = vect_get_vec_def_for_operand (op0, stmt);\n+      vec_oprnds0.create (1);\n+      vec_oprnds0.quick_push (loop_vec_def0);\n+      scalar_dest_def = stmt;\n+    }\n+\n+  tree scalar_dest = gimple_assign_lhs (scalar_dest_def);\n+  tree scalar_type = TREE_TYPE (scalar_dest);\n+  tree reduc_var = gimple_phi_result (reduc_def_stmt);\n+\n+  int vec_num = vec_oprnds0.length ();\n+  gcc_assert (vec_num == 1 || slp_node);\n+  tree vec_elem_type = TREE_TYPE (vectype_out);\n+  gcc_checking_assert (useless_type_conversion_p (scalar_type, vec_elem_type));\n+\n+  tree vector_identity = NULL_TREE;\n+  if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+    vector_identity = build_zero_cst (vectype_out);\n+\n+  tree scalar_dest_var = vect_create_destination_var (scalar_dest, NULL);\n+  int i;\n+  tree def0;\n+  FOR_EACH_VEC_ELT (vec_oprnds0, i, def0)\n+    {\n+      tree mask = NULL_TREE;\n+      if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+\tmask = vect_get_loop_mask (gsi, masks, vec_num, vectype_in, i);\n+\n+      /* Handle MINUS by adding the negative.  */\n+      if (reduc_fn != IFN_LAST && code == MINUS_EXPR)\n+\t{\n+\t  tree negated = make_ssa_name (vectype_out);\n+\t  new_stmt = gimple_build_assign (negated, NEGATE_EXPR, def0);\n+\t  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+\t  def0 = negated;\n+\t}\n+\n+      if (mask)\n+\tdef0 = merge_with_identity (gsi, mask, vectype_out, def0,\n+\t\t\t\t    vector_identity);\n+\n+      /* On the first iteration the input is simply the scalar phi\n+\t result, and for subsequent iterations it is the output of\n+\t the preceding operation.  */\n+      if (reduc_fn != IFN_LAST)\n+\t{\n+\t  new_stmt = gimple_build_call_internal (reduc_fn, 2, reduc_var, def0);\n+\t  /* For chained SLP reductions the output of the previous reduction\n+\t     operation serves as the input of the next. For the final statement\n+\t     the output cannot be a temporary - we reuse the original\n+\t     scalar destination of the last statement.  */\n+\t  if (i != vec_num - 1)\n+\t    {\n+\t      gimple_set_lhs (new_stmt, scalar_dest_var);\n+\t      reduc_var = make_ssa_name (scalar_dest_var, new_stmt);\n+\t      gimple_set_lhs (new_stmt, reduc_var);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  reduc_var = vect_expand_fold_left (gsi, scalar_dest_var, code,\n+\t\t\t\t\t     reduc_var, def0);\n+\t  new_stmt = SSA_NAME_DEF_STMT (reduc_var);\n+\t  /* Remove the statement, so that we can use the same code paths\n+\t     as for statements that we've just created.  */\n+\t  gimple_stmt_iterator tmp_gsi = gsi_for_stmt (new_stmt);\n+\t  gsi_remove (&tmp_gsi, false);\n+\t}\n+\n+      if (i == vec_num - 1)\n+\t{\n+\t  gimple_set_lhs (new_stmt, scalar_dest);\n+\t  vect_finish_replace_stmt (scalar_dest_def, new_stmt);\n+\t}\n+      else\n+\tvect_finish_stmt_generation (scalar_dest_def, new_stmt, gsi);\n+\n+      if (slp_node)\n+\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+    }\n+\n+  if (!slp_node)\n+    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\n+  return true;\n+}\n \n /* Function is_nonwrapping_integer_induction.\n \n@@ -6203,6 +6421,12 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  return true;\n \t}\n \n+      if (STMT_VINFO_REDUC_TYPE (stmt_info) == FOLD_LEFT_REDUCTION)\n+\t/* Leave the scalar phi in place.  Note that checking\n+\t   STMT_VINFO_VEC_REDUCTION_TYPE (as below) only works\n+\t   for reductions involving a single statement.  */\n+\treturn true;\n+\n       gimple *reduc_stmt = STMT_VINFO_REDUC_DEF (stmt_info);\n       if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (reduc_stmt)))\n \treduc_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (reduc_stmt));\n@@ -6434,6 +6658,14 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n      directy used in stmt.  */\n   if (reduc_index == -1)\n     {\n+      if (STMT_VINFO_REDUC_TYPE (stmt_info) == FOLD_LEFT_REDUCTION)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"in-order reduction chain without SLP.\\n\");\n+\t  return false;\n+\t}\n+\n       if (orig_stmt)\n \treduc_def_stmt = STMT_VINFO_REDUC_DEF (orig_stmt_info);\n       else\n@@ -6687,7 +6919,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   vect_reduction_type reduction_type\n     = STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info);\n-  if (orig_stmt && reduction_type == TREE_CODE_REDUCTION)\n+  if (orig_stmt\n+      && (reduction_type == TREE_CODE_REDUCTION\n+\t  || reduction_type == FOLD_LEFT_REDUCTION))\n     {\n       /* This is a reduction pattern: get the vectype from the type of the\n          reduction variable, and get the tree-code from orig_stmt.  */\n@@ -6734,10 +6968,13 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   reduc_fn = IFN_LAST;\n \n   if (reduction_type == TREE_CODE_REDUCTION\n+      || reduction_type == FOLD_LEFT_REDUCTION\n       || reduction_type == INTEGER_INDUC_COND_REDUCTION\n       || reduction_type == CONST_COND_REDUCTION)\n     {\n-      if (reduction_fn_for_scalar_code (orig_code, &reduc_fn))\n+      if (reduction_type == FOLD_LEFT_REDUCTION\n+\t  ? fold_left_reduction_fn (orig_code, &reduc_fn)\n+\t  : reduction_fn_for_scalar_code (orig_code, &reduc_fn))\n \t{\n \t  if (reduc_fn != IFN_LAST\n \t      && !direct_internal_fn_supported_p (reduc_fn, vectype_out,\n@@ -6803,6 +7040,41 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       = neutral_op_for_slp_reduction (slp_node_instance->reduc_phis, code,\n \t\t\t\t      GROUP_FIRST_ELEMENT (stmt_info) != NULL);\n \n+  if (double_reduc && reduction_type == FOLD_LEFT_REDUCTION)\n+    {\n+      /* We can't support in-order reductions of code such as this:\n+\n+\t   for (int i = 0; i < n1; ++i)\n+\t     for (int j = 0; j < n2; ++j)\n+\t       l += a[j];\n+\n+\t since GCC effectively transforms the loop when vectorizing:\n+\n+\t   for (int i = 0; i < n1 / VF; ++i)\n+\t     for (int j = 0; j < n2; ++j)\n+\t       for (int k = 0; k < VF; ++k)\n+\t\t l += a[j];\n+\n+\t which is a reassociation of the original operation.  */\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"in-order double reduction not supported.\\n\");\n+\n+      return false;\n+    }\n+\n+  if (reduction_type == FOLD_LEFT_REDUCTION\n+      && slp_node\n+      && !GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+    {\n+      /* We cannot use in-order reductions in this case because there is\n+\t an implicit reassociation of the operations involved.  */\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"in-order unchained SLP reductions not supported.\\n\");\n+      return false;\n+    }\n+\n   /* For double reductions, and for SLP reductions with a neutral value,\n      we construct a variable-length initial vector by loading a vector\n      full of the neutral value and then shift-and-inserting the start\n@@ -6976,9 +7248,10 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \tvect_model_reduction_cost (stmt_info, reduc_fn, ncopies);\n       if (loop_vinfo && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n \t{\n-\t  if (cond_fn == IFN_LAST\n-\t      || !direct_internal_fn_supported_p (cond_fn, vectype_in,\n-\t\t\t\t\t\t  OPTIMIZE_FOR_SPEED))\n+\t  if (reduction_type != FOLD_LEFT_REDUCTION\n+\t      && (cond_fn == IFN_LAST\n+\t\t  || !direct_internal_fn_supported_p (cond_fn, vectype_in,\n+\t\t\t\t\t\t      OPTIMIZE_FOR_SPEED)))\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6998,6 +7271,10 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    vect_record_loop_mask (loop_vinfo, masks, ncopies * vec_num,\n \t\t\t\t   vectype_in);\n \t}\n+      if (dump_enabled_p ()\n+\t  && reduction_type == FOLD_LEFT_REDUCTION)\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"using an in-order (fold-left) reduction.\\n\");\n       STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n       return true;\n     }\n@@ -7013,6 +7290,11 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   bool masked_loop_p = LOOP_VINFO_FULLY_MASKED_P (loop_vinfo);\n \n+  if (reduction_type == FOLD_LEFT_REDUCTION)\n+    return vectorize_fold_left_reduction\n+      (stmt, gsi, vec_stmt, slp_node, reduc_def_stmt, code,\n+       reduc_fn, ops, vectype_in, reduc_index, masks);\n+\n   if (reduction_type == EXTRACT_LAST_REDUCTION)\n     {\n       gcc_assert (!slp_node);"}, {"sha": "003d4accedb6b7e0bcdb0349fba29a75c654f2c2", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b781a135a06fc1805c072778d7513df09a32171d/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b781a135a06fc1805c072778d7513df09a32171d", "patch": "@@ -74,7 +74,15 @@ enum vect_reduction_type {\n \n        for (int i = 0; i < VF; ++i)\n          res = cond[i] ? val[i] : res;  */\n-  EXTRACT_LAST_REDUCTION\n+  EXTRACT_LAST_REDUCTION,\n+\n+  /* Use a folding reduction within the loop to implement:\n+\n+       for (int i = 0; i < VF; ++i)\n+\t res = res OP val[i];\n+\n+     (with no reassocation).  */\n+  FOLD_LEFT_REDUCTION\n };\n \n #define VECTORIZABLE_CYCLE_DEF(D) (((D) == vect_reduction_def)           \\\n@@ -1390,6 +1398,7 @@ extern void vect_model_load_cost (stmt_vec_info, int, vect_memory_access_type,\n extern unsigned record_stmt_cost (stmt_vector_for_cost *, int,\n \t\t\t\t  enum vect_cost_for_stmt, stmt_vec_info,\n \t\t\t\t  int, enum vect_cost_model_location);\n+extern void vect_finish_replace_stmt (gimple *, gimple *);\n extern void vect_finish_stmt_generation (gimple *, gimple *,\n                                          gimple_stmt_iterator *);\n extern bool vect_mark_stmts_to_be_vectorized (loop_vec_info);"}]}