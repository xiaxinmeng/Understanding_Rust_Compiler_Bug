{"sha": "18caa34eb299b8ea583088ce4bbf32cdc37676ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThjYWEzNGViMjk5YjhlYTU4MzA4OGNlNGJiZjMyY2RjMzc2NzZmZg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-05-09T11:44:03Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-05-09T11:44:03Z"}, "message": "tree-if-conv.c (tree-ssa-loop.h): Include header file.\n\n\t* tree-if-conv.c (tree-ssa-loop.h): Include header file.\n\t(tree-ssa-loop-niter.h): Ditto.\n\t(idx_within_array_bound, ref_within_array_bound): New functions.\n\t(ifcvt_memrefs_wont_trap): Check if array ref is within bound.\n\tFactor out check on writable base object to ...\n\t(base_object_writable): ... here.\n\n\tgcc/testsuite/\n\t* gcc.dg/tree-ssa/ifc-9.c: New test.\n\t* gcc.dg/tree-ssa/ifc-10.c: New test.\n\t* gcc.dg/tree-ssa/ifc-11.c: New test.\n\t* gcc.dg/tree-ssa/ifc-12.c: New test.\n\t* gcc.dg/vect/pr61194.c: Remove XFAIL.\n\t* gcc.dg/vect/vect-23.c: Remove XFAIL.\n\t* gcc.dg/vect/vect-mask-store-move-1.c: Revise test check.\n\nFrom-SVN: r236026", "tree": {"sha": "0bc305c854d198927d3503e42a9cc89202fc8b3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bc305c854d198927d3503e42a9cc89202fc8b3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18caa34eb299b8ea583088ce4bbf32cdc37676ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18caa34eb299b8ea583088ce4bbf32cdc37676ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18caa34eb299b8ea583088ce4bbf32cdc37676ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18caa34eb299b8ea583088ce4bbf32cdc37676ff/comments", "author": null, "committer": null, "parents": [{"sha": "fb334765e2ab959fcf3630e3c4a31ba1cc01a0f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb334765e2ab959fcf3630e3c4a31ba1cc01a0f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb334765e2ab959fcf3630e3c4a31ba1cc01a0f2"}], "stats": {"total": 237, "additions": 223, "deletions": 14}, "files": [{"sha": "ad4f9f7bcffa5b78a998f43c8ab3279df4e7d71f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18caa34eb299b8ea583088ce4bbf32cdc37676ff", "patch": "@@ -1,3 +1,12 @@\n+2016-05-09  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-if-conv.c (tree-ssa-loop.h): Include header file.\n+\t(tree-ssa-loop-niter.h): Ditto.\n+\t(idx_within_array_bound, ref_within_array_bound): New functions.\n+\t(ifcvt_memrefs_wont_trap): Check if array ref is within bound.\n+\tFactor out check on writable base object to ...\n+\t(base_object_writable): ... here.\n+\n 2016-05-09  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm.md (probe_stack): Add modes to set source"}, {"sha": "bcb75c42cddd346dc14b403bafd6286c7c1da934", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=18caa34eb299b8ea583088ce4bbf32cdc37676ff", "patch": "@@ -1,3 +1,13 @@\n+2016-05-09  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/ifc-9.c: New test.\n+\t* gcc.dg/tree-ssa/ifc-10.c: New test.\n+\t* gcc.dg/tree-ssa/ifc-11.c: New test.\n+\t* gcc.dg/tree-ssa/ifc-12.c: New test.\n+\t* gcc.dg/vect/pr61194.c: Remove XFAIL.\n+\t* gcc.dg/vect/vect-23.c: Remove XFAIL.\n+\t* gcc.dg/vect/vect-mask-store-move-1.c: Revise test check.\n+\n 2016-05-09  Richard Biener  <rguenther@suse.de>\n \n \tPR fortran/70937"}, {"sha": "70b742238926db8f9bf3da060c99a69b37d8212d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-10.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-10.c?ref=18caa34eb299b8ea583088ce4bbf32cdc37676ff", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fdump-tree-ifcvt-stats\" } */\n+/* { dg-require-visibility \"\" } */\n+\n+int b[256] = {0}, y;\n+void bar (int *);\n+int foo (int x, int n)\n+{\n+  int i;\n+  int a[128];\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      a[i] = i;\n+      if (x > i)\n+\tb[i] = y;\n+    }\n+  bar (a);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Applying if-conversion\" 1 \"ifcvt\" } } */"}, {"sha": "bacf428ec03dcd65f9ba9927945714f06b794f59", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-11.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-11.c?ref=18caa34eb299b8ea583088ce4bbf32cdc37676ff", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fdump-tree-ifcvt-stats\" } */\n+/* { dg-require-visibility \"\" } */\n+\n+int a[1024] = {0.0};\n+int b[1024] = {0.0};\n+int c[1024] = {0.0};\n+int foo (float *x)\n+{\n+  int i = 0;\n+\n+  for (i = 0; i < 1024; i++)\n+    {\n+      c[i] = (x[i] > 0.0) ? a[i] : b[i];\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Applying if-conversion\" 1 \"ifcvt\" } } */"}, {"sha": "89d42b4d6fd0add66e53d35742aee8778a266cca", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-12.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-12.c?ref=18caa34eb299b8ea583088ce4bbf32cdc37676ff", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fdump-tree-ifcvt-stats\" } */\n+/* { dg-require-visibility \"\" } */\n+\n+struct st\n+{\n+  int a[1024];\n+  int b[1024];\n+};\n+\n+struct st s = {0};\n+int foo (int x)\n+{\n+  int i;\n+  struct st *p = &s;\n+\n+  for (i = 0; i < 1024; i++)\n+    {\n+      if (x > i)\n+\tp->a[i] = p->b[i];\n+    }\n+\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump-times \"Applying if-conversion\" 1 \"ifcvt\" } } */"}, {"sha": "24c19c064f40b93da895de9c9d799d9694e37f54", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-9.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-9.c?ref=18caa34eb299b8ea583088ce4bbf32cdc37676ff", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fdump-tree-ifcvt-stats\" } */\n+/* { dg-require-visibility \"\" } */\n+\n+extern int b[256], y;\n+void bar (int *, int);\n+int foo (int x, int n)\n+{\n+  int i;\n+  int a[128];\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      a[i] = i;\n+      if (x > i)\n+\ty = b[i];\n+    }\n+  bar (a, y);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Applying if-conversion\" 1 \"ifcvt\" } } */"}, {"sha": "f7c71b91b4889597c571618e26cda5bada742f57", "filename": "gcc/testsuite/gcc.dg/vect/pr61194.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr61194.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr61194.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr61194.c?ref=18caa34eb299b8ea583088ce4bbf32cdc37676ff", "patch": "@@ -38,4 +38,4 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "e463f1b5cc9daf681183e2df7ece8f7c8dc2559c", "filename": "gcc/testsuite/gcc.dg/vect/vect-23.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-23.c?ref=18caa34eb299b8ea583088ce4bbf32cdc37676ff", "patch": "@@ -123,5 +123,5 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */"}, {"sha": "f928dbf4c21675f886edc35a1062fbc366dfa2b9", "filename": "gcc/testsuite/gcc.dg/vect/vect-mask-store-move-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mask-store-move-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mask-store-move-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-mask-store-move-1.c?ref=18caa34eb299b8ea583088ce4bbf32cdc37676ff", "patch": "@@ -15,4 +15,4 @@ void foo (int n)\n       }\n }\n \n-/* { dg-final { scan-tree-dump-times \"Move stmt to created bb\" 6 \"vect\" { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"Move stmt to created bb\" 4 \"vect\" { target { i?86-*-* x86_64-*-* } } } } */"}, {"sha": "c38e21b32ce85c19eb3d255bed3e6726f2567c48", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 112, "deletions": 11, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18caa34eb299b8ea583088ce4bbf32cdc37676ff/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=18caa34eb299b8ea583088ce4bbf32cdc37676ff", "patch": "@@ -106,6 +106,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-data-ref.h\"\n #include \"tree-scalar-evolution.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"tree-ssa-loop-niter.h\"\n #include \"tree-ssa-loop-ivopts.h\"\n #include \"tree-ssa-address.h\"\n #include \"dbgcnt.h\"\n@@ -718,6 +720,105 @@ hash_memrefs_baserefs_and_store_DRs_read_written_info (data_reference_p a)\n     }\n }\n \n+/* Return TRUE if can prove the index IDX of an array reference REF is\n+   within array bound.  Return false otherwise.  */\n+\n+static bool\n+idx_within_array_bound (tree ref, tree *idx, void *dta)\n+{\n+  bool overflow;\n+  widest_int niter, valid_niter, delta, wi_step;\n+  tree ev, init, step;\n+  tree low, high;\n+  struct loop *loop = (struct loop*) dta;\n+\n+  /* Only support within-bound access for array references.  */\n+  if (TREE_CODE (ref) != ARRAY_REF)\n+    return false;\n+\n+  /* For arrays at the end of the structure, we are not guaranteed that they\n+     do not really extend over their declared size.  However, for arrays of\n+     size greater than one, this is unlikely to be intended.  */\n+  if (array_at_struct_end_p (ref))\n+    return false;\n+\n+  ev = analyze_scalar_evolution (loop, *idx);\n+  ev = instantiate_parameters (loop, ev);\n+  init = initial_condition (ev);\n+  step = evolution_part_in_loop_num (ev, loop->num);\n+\n+  if (!init || TREE_CODE (init) != INTEGER_CST\n+      || (step && TREE_CODE (step) != INTEGER_CST))\n+    return false;\n+\n+  low = array_ref_low_bound (ref);\n+  high = array_ref_up_bound (ref);\n+\n+  /* The case of nonconstant bounds could be handled, but it would be\n+     complicated.  */\n+  if (TREE_CODE (low) != INTEGER_CST\n+      || !high || TREE_CODE (high) != INTEGER_CST)\n+    return false;\n+\n+  /* Check if the intial idx is within bound.  */\n+  if (wi::to_widest (init) < wi::to_widest (low)\n+      || wi::to_widest (init) > wi::to_widest (high))\n+    return false;\n+\n+  /* The idx is always within bound.  */\n+  if (!step || integer_zerop (step))\n+    return true;\n+\n+  if (!max_loop_iterations (loop, &niter))\n+    return false;\n+\n+  if (wi::to_widest (step) < 0)\n+    {\n+      delta = wi::to_widest (init) - wi::to_widest (low);\n+      wi_step = -wi::to_widest (step);\n+    }\n+  else\n+    {\n+      delta = wi::to_widest (high) - wi::to_widest (init);\n+      wi_step = wi::to_widest (step);\n+    }\n+\n+  valid_niter = wi::div_floor (delta, wi_step, SIGNED, &overflow);\n+  /* The iteration space of idx is within array bound.  */\n+  if (!overflow && niter <= valid_niter)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return TRUE if ref is a within bound array reference.  */\n+\n+static bool\n+ref_within_array_bound (gimple *stmt, tree ref)\n+{\n+  struct loop *loop = loop_containing_stmt (stmt);\n+\n+  gcc_assert (loop != NULL);\n+  return for_each_index (&ref, idx_within_array_bound, loop);\n+}\n+\n+\n+/* Given a memory reference expression T, return TRUE if base object\n+   it refers to is writable.  The base object of a memory reference\n+   is the main object being referenced, which is returned by function\n+   get_base_address.  */\n+\n+static bool\n+base_object_writable (tree ref)\n+{\n+  tree base_tree = get_base_address (ref);\n+\n+  return (base_tree\n+\t  && DECL_P (base_tree)\n+\t  && decl_binds_to_current_def_p (base_tree)\n+\t  && !TREE_READONLY (base_tree));\n+}\n+\n /* Return true when the memory references of STMT won't trap in the\n    if-converted code.  There are two things that we have to check for:\n \n@@ -765,8 +866,13 @@ ifcvt_memrefs_wont_trap (gimple *stmt, vec<data_reference_p> drs)\n   if (DR_W_UNCONDITIONALLY (*master_dr))\n     return true;\n \n-  /* If a is unconditionally accessed then ... */\n-  if (DR_RW_UNCONDITIONALLY (*master_dr))\n+  /* If a is unconditionally accessed then ...\n+\n+     Even a is conditional access, we can treat it as an unconditional\n+     one if it's an array reference and all its index are within array\n+     bound.  */\n+  if (DR_RW_UNCONDITIONALLY (*master_dr)\n+      || ref_within_array_bound (stmt, DR_REF (a)))\n     {\n       /* an unconditional read won't trap.  */\n       if (DR_IS_READ (a))\n@@ -777,16 +883,11 @@ ifcvt_memrefs_wont_trap (gimple *stmt, vec<data_reference_p> drs)\n       if (base_master_dr\n \t  && DR_BASE_W_UNCONDITIONALLY (*base_master_dr))\n \treturn PARAM_VALUE (PARAM_ALLOW_STORE_DATA_RACES);\n-      else\n-\t{\n-\t  /* or the base is know to be not readonly.  */\n-\t  tree base_tree = get_base_address (DR_REF (a));\n-\t  if (DECL_P (base_tree)\n-\t      && decl_binds_to_current_def_p (base_tree)\n-\t      && ! TREE_READONLY (base_tree))\n-\t    return PARAM_VALUE (PARAM_ALLOW_STORE_DATA_RACES);\n-\t}\n+      /* or the base is known to be not readonly.  */\n+      else if (base_object_writable (DR_REF (a)))\n+\treturn PARAM_VALUE (PARAM_ALLOW_STORE_DATA_RACES);\n     }\n+\n   return false;\n }\n "}]}