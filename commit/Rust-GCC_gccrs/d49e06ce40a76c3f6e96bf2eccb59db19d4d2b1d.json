{"sha": "d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ5ZTA2Y2U0MGE3NmMzZjZlOTZiZjJlY2NiNTlkYjE5ZDRkMmIxZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-12-04T16:14:24Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-12-04T16:14:24Z"}, "message": "re PR tree-optimization/78496 (Missed opportunities for jump threading)\n\n\tPR tree-optimizatin/78496\n\t* gimple-ssa-evrp-analyze.h\n\t(evrp_range_analyzer::get_vr_values): Simplify.\n\t* gimple-ssa-evrp-analyze.c: Corresponding changes.\n\t* tree-ssa-dom.c: Include alloc-pool.h, tree-vrp.h, vr-values.h\n\tand gimple-ssa-evrp-analyze.h.\n\t(dom_opt_dom_walker class): Add evrp_range_analyzer member.\n\t(simplify_stmt_for_jump_threading): Copy a blob of code from\n\ttree-vrp.c to use ranges to simplify statements.\n\t(dom_opt_dom_walker::before_dom_children): Call\n\tevrp_range_analyzer::{enter,record_ranges_from_stmt} methods.\n\t(dom_opt_dom_walker::after_dom_children): Similarly for\n\tevrp_range_analyzer::leave.\n\t(dom_opt_dom_walker::optimize_stmt): Use EVRP ranges to optimize\n\tconditionals.\n\n\tPR tree-optimization/78496\n\t* gcc.dg/builtin-unreachable-6.c: Disable DOM.\n\t* gcc.dg/builtin-unreachable-6a.c: New test.\n\t* gcc.dg/tree-ssa/20030922-1.c: No longer XFAIL.\n\t* gcc.dg/ssa-dom-branch-1.c: Tweak expected output.\n\nFrom-SVN: r255387", "tree": {"sha": "1744737fd0c09e38928cb3ca91a814e849bbac4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1744737fd0c09e38928cb3ca91a814e849bbac4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/comments", "author": null, "committer": null, "parents": [{"sha": "d48f6f3f2d1f8b62b538939f82740f463a193b8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d48f6f3f2d1f8b62b538939f82740f463a193b8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d48f6f3f2d1f8b62b538939f82740f463a193b8b"}], "stats": {"total": 189, "additions": 172, "deletions": 17}, "files": [{"sha": "97c64c70560341164f060c849f68ca3af1458da7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d", "patch": "@@ -1,5 +1,21 @@\n 2017-12-04  Jeff Law  <law@redhat.com>\n \n+\tPR tree-optimizatin/78496\n+\t* gimple-ssa-evrp-analyze.h\n+\t(evrp_range_analyzer::get_vr_values): Simplify.\n+\t* gimple-ssa-evrp-analyze.c: Corresponding changes.\n+\t* tree-ssa-dom.c: Include alloc-pool.h, tree-vrp.h, vr-values.h\n+\tand gimple-ssa-evrp-analyze.h.\n+\t(dom_opt_dom_walker class): Add evrp_range_analyzer member.\n+\t(simplify_stmt_for_jump_threading): Copy a blob of code from\n+\ttree-vrp.c to use ranges to simplify statements.\n+\t(dom_opt_dom_walker::before_dom_children): Call\n+\tevrp_range_analyzer::{enter,record_ranges_from_stmt} methods.\n+\t(dom_opt_dom_walker::after_dom_children): Similarly for\n+\tevrp_range_analyzer::leave.\n+\t(dom_opt_dom_walker::optimize_stmt): Use EVRP ranges to optimize\n+\tconditionals.\n+\n \t* gimple-ssa-evrp-analyze.c\n \t(evrp_range_analyzer::extract_range_from_stmt):  Always use\n \tvr_values::update_value_range so preexisting range info is"}, {"sha": "4783e6f772eb1f879b11a508ad665241b6bd726b", "filename": "gcc/gimple-ssa-evrp-analyze.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Fgimple-ssa-evrp-analyze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Fgimple-ssa-evrp-analyze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.h?ref=d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d", "patch": "@@ -51,13 +51,7 @@ class evrp_range_analyzer\n      true, then we are transferring ownership.  Else we keep ownership.\n \n      This should be converted to a unique_ptr.  */\n-  class vr_values *get_vr_values (bool transfer)\n-    {\n-      class vr_values *x = vr_values;\n-      if (transfer)\n-\tvr_values = NULL;\n-      return x;\n-    }\n+  class vr_values *get_vr_values (void) { return vr_values; }\n \n  private:\n   DISABLE_COPY_AND_ASSIGN (evrp_range_analyzer);"}, {"sha": "609ce38f2182d38e7fea1135eb3f347b1876378c", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d", "patch": "@@ -68,7 +68,7 @@ class evrp_dom_walker : public dom_walker\n public:\n   evrp_dom_walker ()\n     : dom_walker (CDI_DOMINATORS),\n-      evrp_folder (evrp_range_analyzer.get_vr_values (false))\n+      evrp_folder (evrp_range_analyzer.get_vr_values ())\n     {\n       need_eh_cleanup = BITMAP_ALLOC (NULL);\n     }"}, {"sha": "16eee3d024da9975e256917d5768b7d065fb3cd3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d", "patch": "@@ -1,3 +1,11 @@\n+2017-12-04  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/78496\n+\t* gcc.dg/builtin-unreachable-6.c: Disable DOM.\n+\t* gcc.dg/builtin-unreachable-6a.c: New test.\n+\t* gcc.dg/tree-ssa/20030922-1.c: No longer XFAIL.\n+\t* gcc.dg/ssa-dom-branch-1.c: Tweak expected output.\n+\n 2017-12-04  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/83255"}, {"sha": "1915dd13f42f13f6415447a882d9cc5840fe0a1e", "filename": "gcc/testsuite/gcc.dg/builtin-unreachable-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-unreachable-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-unreachable-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-unreachable-6.c?ref=d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-fab1\" } */\n+/* { dg-options \"-O2 -fdump-tree-fab1 -fno-tree-dominator-opts\" } */\n \n void\n foo (int b, int c)"}, {"sha": "f527f2edc3b2ac56f92c3a3b2b8593dc3086a050", "filename": "gcc/testsuite/gcc.dg/builtin-unreachable-6a.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-unreachable-6a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-unreachable-6a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-unreachable-6a.c?ref=d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fab1\" } */\n+\n+#include \"builtin-unreachable-6.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"lab:\" 1 \"fab1\" } } */\n+/* { dg-final { scan-tree-dump-not \"__builtin_unreachable\" \"fab1\" } } */"}, {"sha": "16c79da9521cec88426d1e48958c53a219307ce1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030922-2.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030922-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030922-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030922-2.c?ref=d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d", "patch": "@@ -20,6 +20,4 @@ rgn_rank (rtx insn1, rtx insn2)\n }\n \n /* There should be two IF conditionals.  */\n-/* We no longer record the conditional equivalence by design, thus we\n-   are unable to simplify the 3rd conditional at compile time.  */\n-/* { dg-final { scan-tree-dump-times \"if \" 2 \"dom2\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"if \" 2 \"dom2\" } } */"}, {"sha": "fae5bdef8186eb152ca8249b0f1a9d434e176d78", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-branch-1.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-branch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-branch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-branch-1.c?ref=d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d", "patch": "@@ -19,9 +19,10 @@ try_combine (rtx i1, rtx newpat)\n   else if (i1 && foo ());\n }\n \n-/* There should be two tests against i1.  One from the hash table\n-   dumps, one in the code itself.  */\n-/* { dg-final { scan-tree-dump-times \"if .i1_\" 2 \"dom2\"} } */\n+/* There should be four tests against i1.  One from the hash table\n+   dumps, one from the EVRP analyzer one from EVRP evaluation and one\n+   in the code itself.  */\n+/* { dg-final { scan-tree-dump-times \"if .i1_\" 4 \"dom2\"} } */\n \n /* There should be no actual jump threads realized by DOM.  The\n    legitimize jump threads are handled in VRP and those discovered"}, {"sha": "59a7d87898e185587acf9cf98148161367eca6fc", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 133, "deletions": 2, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=d49e06ce40a76c3f6e96bf2eccb59db19d4d2b1d", "patch": "@@ -46,6 +46,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"tree-cfgcleanup.h\"\n #include \"dbgcnt.h\"\n+#include \"alloc-pool.h\"\n+#include \"tree-vrp.h\"\n+#include \"vr-values.h\"\n+#include \"gimple-ssa-evrp-analyze.h\"\n \n /* This file implements optimizations on the dominator tree.  */\n \n@@ -584,6 +588,9 @@ class dom_opt_dom_walker : public dom_walker\n   class const_and_copies *m_const_and_copies;\n   class avail_exprs_stack *m_avail_exprs_stack;\n \n+  /* VRP data.  */\n+  class evrp_range_analyzer evrp_range_analyzer;\n+\n   /* Dummy condition to avoid creating lots of throw away statements.  */\n   gcond *m_dummy_cond;\n \n@@ -835,6 +842,9 @@ make_pass_dominator (gcc::context *ctxt)\n   return new pass_dominator (ctxt);\n }\n \n+/* A hack until we remove threading from tree-vrp.c and bring the\n+   simplification routine into the dom_opt_dom_walker class.  */\n+static class vr_values *x_vr_values;\n \n /* A trivial wrapper so that we can present the generic jump\n    threading code with a simple API for simplifying statements.  */\n@@ -844,7 +854,95 @@ simplify_stmt_for_jump_threading (gimple *stmt,\n \t\t\t\t  class avail_exprs_stack *avail_exprs_stack,\n \t\t\t\t  basic_block bb ATTRIBUTE_UNUSED)\n {\n-  return avail_exprs_stack->lookup_avail_expr (stmt, false, true);\n+  /* First query our hash table to see if the the expression is available\n+     there.  A non-NULL return value will be either a constant or another\n+     SSA_NAME.  */\n+  tree cached_lhs =  avail_exprs_stack->lookup_avail_expr (stmt, false, true);\n+  if (cached_lhs)\n+    return cached_lhs;\n+\n+  /* If the hash table query failed, query VRP information.  This is\n+     essentially the same as tree-vrp's simplification routine.  The\n+     copy in tree-vrp is scheduled for removal in gcc-9.  */\n+  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n+    {\n+      cached_lhs\n+\t= x_vr_values->vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n+\t\t\t\t\t\t gimple_cond_lhs (cond_stmt),\n+\t\t\t\t\t\t gimple_cond_rhs (cond_stmt),\n+\t\t\t\t\t\t within_stmt);\n+      return cached_lhs;\n+    }\n+\n+  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))\n+    {\n+      tree op = gimple_switch_index (switch_stmt);\n+      if (TREE_CODE (op) != SSA_NAME)\n+\treturn NULL_TREE;\n+\n+      value_range *vr = x_vr_values->get_value_range (op);\n+      if ((vr->type != VR_RANGE && vr->type != VR_ANTI_RANGE)\n+\t  || symbolic_range_p (vr))\n+\treturn NULL_TREE;\n+\n+      if (vr->type == VR_RANGE)\n+\t{\n+\t  size_t i, j;\n+\n+\t  find_case_label_range (switch_stmt, vr->min, vr->max, &i, &j);\n+\n+\t  if (i == j)\n+\t    {\n+\t      tree label = gimple_switch_label (switch_stmt, i);\n+\n+\t      if (CASE_HIGH (label) != NULL_TREE\n+\t\t  ? (tree_int_cst_compare (CASE_LOW (label), vr->min) <= 0\n+\t\t     && tree_int_cst_compare (CASE_HIGH (label), vr->max) >= 0)\n+\t\t  : (tree_int_cst_equal (CASE_LOW (label), vr->min)\n+\t\t     && tree_int_cst_equal (vr->min, vr->max)))\n+\t\treturn label;\n+\n+\t      if (i > j)\n+\t\treturn gimple_switch_label (switch_stmt, 0);\n+\t    }\n+\t}\n+\n+      if (vr->type == VR_ANTI_RANGE)\n+          {\n+            unsigned n = gimple_switch_num_labels (switch_stmt);\n+            tree min_label = gimple_switch_label (switch_stmt, 1);\n+            tree max_label = gimple_switch_label (switch_stmt, n - 1);\n+\n+            /* The default label will be taken only if the anti-range of the\n+               operand is entirely outside the bounds of all the (non-default)\n+               case labels.  */\n+            if (tree_int_cst_compare (vr->min, CASE_LOW (min_label)) <= 0\n+                && (CASE_HIGH (max_label) != NULL_TREE\n+                    ? tree_int_cst_compare (vr->max, CASE_HIGH (max_label)) >= 0\n+                    : tree_int_cst_compare (vr->max, CASE_LOW (max_label)) >= 0))\n+            return gimple_switch_label (switch_stmt, 0);\n+          }\n+\treturn NULL_TREE;\n+    }\n+\n+  if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))\n+    {\n+      tree lhs = gimple_assign_lhs (assign_stmt);\n+      if (TREE_CODE (lhs) == SSA_NAME\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t  && stmt_interesting_for_vrp (stmt))\n+\t{\n+\t  edge dummy_e;\n+\t  tree dummy_tree;\n+\t  value_range new_vr = VR_INITIALIZER;\n+\t  x_vr_values->extract_range_from_stmt (stmt, &dummy_e,\n+\t\t\t\t\t      &dummy_tree, &new_vr);\n+\t  if (range_int_cst_singleton_p (&new_vr))\n+\t    return new_vr.min;\n+\t}\n+    }\n+  return NULL;\n }\n \n /* Valueize hook for gimple_fold_stmt_to_constant_1.  */\n@@ -1310,6 +1408,8 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n\\nOptimizing block #%d\\n\\n\", bb->index);\n \n+  evrp_range_analyzer.enter (bb);\n+\n   /* Push a marker on the stacks of local information so that we know how\n      far to unwind when we finalize this block.  */\n   m_avail_exprs_stack->push_marker ();\n@@ -1332,7 +1432,10 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n \n   edge taken_edge = NULL;\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    taken_edge = this->optimize_stmt (bb, gsi);\n+    {\n+      evrp_range_analyzer.record_ranges_from_stmt (gsi_stmt (gsi));\n+      taken_edge = this->optimize_stmt (bb, gsi);\n+    }\n \n   /* Now prepare to process dominated blocks.  */\n   record_edge_info (bb);\n@@ -1350,13 +1453,16 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n void\n dom_opt_dom_walker::after_dom_children (basic_block bb)\n {\n+  x_vr_values = evrp_range_analyzer.get_vr_values ();\n   thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,\n \t\t\t m_avail_exprs_stack,\n \t\t\t simplify_stmt_for_jump_threading);\n+  x_vr_values = NULL;\n \n   /* These remove expressions local to BB from the tables.  */\n   m_avail_exprs_stack->pop_to_marker ();\n   m_const_and_copies->pop_to_marker ();\n+  evrp_range_analyzer.leave (bb);\n }\n \n /* Search for redundant computations in STMT.  If any are found, then\n@@ -1902,6 +2008,31 @@ dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n \t\t\t\t\t\t integer_zero_node));\n \t      gimple_set_modified (stmt, true);\n \t    }\n+\t  else if (TREE_CODE (lhs) == SSA_NAME)\n+\t    {\n+\t      /* Exploiting EVRP data is not yet fully integrated into DOM\n+\t\t but we need to do something for this case to avoid regressing\n+\t\t udr4.f90 and new1.C which have unexecutable blocks with\n+\t\t undefined behavior that get diagnosed if they're left in the\n+\t\t IL because we've attached range information to new\n+\t\t SSA_NAMES.  */\n+\t      edge taken_edge = NULL;\n+\t      evrp_range_analyzer.vrp_visit_cond_stmt (as_a <gcond *> (stmt),\n+\t\t\t\t\t\t       &taken_edge);\n+\t      if (taken_edge)\n+\t\t{\n+\t\t  if (taken_edge->flags & EDGE_TRUE_VALUE)\n+\t\t    gimple_cond_make_true (as_a <gcond *> (stmt));\n+\t\t  else if (taken_edge->flags & EDGE_FALSE_VALUE)\n+\t\t    gimple_cond_make_false (as_a <gcond *> (stmt));\n+\t\t  else\n+\t\t    gcc_unreachable ();\n+\t\t  gimple_set_modified (stmt, true);\n+\t\t  update_stmt (stmt);\n+\t\t  cfg_altered = true;\n+\t\t  return taken_edge;\n+\t\t}\n+\t    }\n \t}\n \n       update_stmt_if_modified (stmt);"}]}