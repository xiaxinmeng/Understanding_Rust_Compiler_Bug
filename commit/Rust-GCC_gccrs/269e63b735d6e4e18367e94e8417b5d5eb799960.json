{"sha": "269e63b735d6e4e18367e94e8417b5d5eb799960", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY5ZTYzYjczNWQ2ZTRlMTgzNjdlOTRlODQxN2I1ZDVlYjc5OTk2MA==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz70@googlemail.com", "date": "2015-11-13T22:24:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-11-13T22:24:45Z"}, "message": "Add non-folding variants for convert_to_*.\n\n2015-11-13  Kai Tietz  <ktietz70@googlemail.com>\n\t    Marek Polacek  <polacek@redhat.com>\n\t    Jason Merrill  <jason@redhat.com>\n\ngcc/\n\t* convert.c (maybe_fold_build1_loc): New.\n\t(maybe_fold_build2_loc): New.\n\t(convert_to_pointer_1): Split out from convert_to_pointer.\n\t(convert_to_pointer_nofold): New.\n\t(convert_to_real_1): Split out from convert_to_real.\n\t(convert_to_real_nofold): New.\n\t(convert_to_integer_1): Split out from convert_to_integer.\n\t(convert_to_integer_nofold): New.\n\t(convert_to_complex_1): Split out from convert_to_complex.\n\t(convert_to_complex_nofold): New.\n\t* convert.h: Declare new functions.\n\t* tree-complex.c (create_one_component_var): Break up line to\n\tavoid sequence point issues.\ngcc/c-family/\n\t* c-lex.c (interpret_float): Use fold_convert.\n\nCo-Authored-By: Jason Merrill <jason@redhat.com>\nCo-Authored-By: Marek Polacek <polacek@redhat.com>\n\nFrom-SVN: r230359", "tree": {"sha": "2ab66075ba691c6242d45ab66643cf2f0358a6a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ab66075ba691c6242d45ab66643cf2f0358a6a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/269e63b735d6e4e18367e94e8417b5d5eb799960", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/269e63b735d6e4e18367e94e8417b5d5eb799960", "html_url": "https://github.com/Rust-GCC/gccrs/commit/269e63b735d6e4e18367e94e8417b5d5eb799960", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/269e63b735d6e4e18367e94e8417b5d5eb799960/comments", "author": {"login": "kai1970", "id": 11942286, "node_id": "MDQ6VXNlcjExOTQyMjg2", "avatar_url": "https://avatars.githubusercontent.com/u/11942286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kai1970", "html_url": "https://github.com/kai1970", "followers_url": "https://api.github.com/users/kai1970/followers", "following_url": "https://api.github.com/users/kai1970/following{/other_user}", "gists_url": "https://api.github.com/users/kai1970/gists{/gist_id}", "starred_url": "https://api.github.com/users/kai1970/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kai1970/subscriptions", "organizations_url": "https://api.github.com/users/kai1970/orgs", "repos_url": "https://api.github.com/users/kai1970/repos", "events_url": "https://api.github.com/users/kai1970/events{/privacy}", "received_events_url": "https://api.github.com/users/kai1970/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9514e74fcd529835a8963f91e12e1ee853149095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9514e74fcd529835a8963f91e12e1ee853149095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9514e74fcd529835a8963f91e12e1ee853149095"}], "stats": {"total": 300, "additions": 221, "deletions": 79}, "files": [{"sha": "dde26959f14696d27661c49872cff990cc0df7be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269e63b735d6e4e18367e94e8417b5d5eb799960/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269e63b735d6e4e18367e94e8417b5d5eb799960/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=269e63b735d6e4e18367e94e8417b5d5eb799960", "patch": "@@ -1,3 +1,21 @@\n+2015-11-13  Kai Tietz  <ktietz70@googlemail.com>\n+\t    Marek Polacek  <polacek@redhat.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\t* convert.c (maybe_fold_build1_loc): New.\n+\t(maybe_fold_build2_loc): New.\n+\t(convert_to_pointer_1): Split out from convert_to_pointer.\n+\t(convert_to_pointer_nofold): New.\n+\t(convert_to_real_1): Split out from convert_to_real.\n+\t(convert_to_real_nofold): New.\n+\t(convert_to_integer_1): Split out from convert_to_integer.\n+\t(convert_to_integer_nofold): New.\n+\t(convert_to_complex_1): Split out from convert_to_complex.\n+\t(convert_to_complex_nofold): New.\n+\t* convert.h: Declare new functions.\n+\t* tree-complex.c (create_one_component_var): Break up line to\n+\tavoid sequence point issues.\n+\n 2015-11-13  Jason Merrill  <jason@redhat.com>\n \n \t* fold-const.c (fold_convert_const): Fold changing cv-quals on"}, {"sha": "7262cfd1dc360c3b9601f7ddede24edc5f63f27c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269e63b735d6e4e18367e94e8417b5d5eb799960/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269e63b735d6e4e18367e94e8417b5d5eb799960/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=269e63b735d6e4e18367e94e8417b5d5eb799960", "patch": "@@ -1,3 +1,7 @@\n+2015-11-13  Kai Tietz  <ktietz70@googlemail.com>\n+\n+\t* c-lex.c (interpret_float): Use fold_convert.\n+\n 2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-common.c (c_fully_fold_internal): Capture existing souce_range,"}, {"sha": "9c86ba729edccbb3ae31223dd1f6aae720c43d39", "filename": "gcc/c-family/c-lex.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269e63b735d6e4e18367e94e8417b5d5eb799960/gcc%2Fc-family%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269e63b735d6e4e18367e94e8417b5d5eb799960/gcc%2Fc-family%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.c?ref=269e63b735d6e4e18367e94e8417b5d5eb799960", "patch": "@@ -926,8 +926,9 @@ interpret_float (const cpp_token *token, unsigned int flags,\n   value = build_real (const_type, real);\n   if (flags & CPP_N_IMAGINARY)\n     {\n-      value = build_complex (NULL_TREE, convert (const_type,\n-\t\t\t\t\t\t integer_zero_node), value);\n+      value = build_complex (NULL_TREE,\n+\t\t\t     fold_convert (const_type,\n+\t\t\t\t\t   integer_zero_node), value);\n       if (type != const_type)\n \t{\n \t  const_type = TREE_TYPE (value);"}, {"sha": "e27a6feeda5ecfce80dc74f2fab0fefe326a42dc", "filename": "gcc/convert.c", "status": "modified", "additions": 190, "deletions": 75, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269e63b735d6e4e18367e94e8417b5d5eb799960/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269e63b735d6e4e18367e94e8417b5d5eb799960/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=269e63b735d6e4e18367e94e8417b5d5eb799960", "patch": "@@ -34,12 +34,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"ubsan.h\"\n \n+#define maybe_fold_build1_loc(FOLD_P, LOC, CODE, TYPE, EXPR) \\\n+  ((FOLD_P) ? fold_build1_loc (LOC, CODE, TYPE, EXPR)\t     \\\n+   : build1_loc (LOC, CODE, TYPE, EXPR))\n+#define maybe_fold_build2_loc(FOLD_P, LOC, CODE, TYPE, EXPR1, EXPR2) \\\n+  ((FOLD_P) ? fold_build2_loc (LOC, CODE, TYPE, EXPR1, EXPR2)\t     \\\n+   : build2_loc (LOC, CODE, TYPE, EXPR1, EXPR2))\n+\n /* Convert EXPR to some pointer or reference type TYPE.\n    EXPR must be pointer, reference, integer, enumeral, or literal zero;\n-   in other cases error is called.  */\n+   in other cases error is called.  If FOLD_P is true, try to fold the\n+   expression.  */\n \n-tree\n-convert_to_pointer (tree type, tree expr)\n+static tree\n+convert_to_pointer_1 (tree type, tree expr, bool fold_p)\n {\n   location_t loc = EXPR_LOCATION (expr);\n   if (TREE_TYPE (expr) == type)\n@@ -56,9 +64,10 @@ convert_to_pointer (tree type, tree expr)\n \taddr_space_t from_as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (expr)));\n \n \tif (to_as == from_as)\n-\t  return fold_build1_loc (loc, NOP_EXPR, type, expr);\n+\t  return maybe_fold_build1_loc (fold_p, loc, NOP_EXPR, type, expr);\n \telse\n-\t  return fold_build1_loc (loc, ADDR_SPACE_CONVERT_EXPR, type, expr);\n+\t  return maybe_fold_build1_loc (fold_p, loc, ADDR_SPACE_CONVERT_EXPR,\n+\t\t\t\t\ttype, expr);\n       }\n \n     case INTEGER_TYPE:\n@@ -72,35 +81,54 @@ convert_to_pointer (tree type, tree expr)\n \tunsigned int pprec = TYPE_PRECISION (type);\n \tunsigned int eprec = TYPE_PRECISION (TREE_TYPE (expr));\n \n- \tif (eprec != pprec)\n-\t  expr = fold_build1_loc (loc, NOP_EXPR,\n-\t\t\t      lang_hooks.types.type_for_size (pprec, 0),\n-\t\t\t      expr);\n+\tif (eprec != pprec)\n+\t  expr\n+\t    = maybe_fold_build1_loc (fold_p, loc, NOP_EXPR,\n+\t\t\t\t     lang_hooks.types.type_for_size (pprec, 0),\n+\t\t\t\t     expr);\n       }\n-\n-      return fold_build1_loc (loc, CONVERT_EXPR, type, expr);\n+      return maybe_fold_build1_loc (fold_p, loc, CONVERT_EXPR, type, expr);\n \n     default:\n       error (\"cannot convert to a pointer type\");\n-      return convert_to_pointer (type, integer_zero_node);\n+      return convert_to_pointer_1 (type, integer_zero_node, fold_p);\n     }\n }\n \n+/* A wrapper around convert_to_pointer_1 that always folds the\n+   expression.  */\n+\n+tree\n+convert_to_pointer (tree type, tree expr)\n+{\n+  return convert_to_pointer_1 (type, expr, true);\n+}\n+\n+/* A wrapper around convert_to_pointer_1 that only folds the\n+   expression if it is CONSTANT_CLASS_P.  */\n+\n+tree\n+convert_to_pointer_nofold (tree type, tree expr)\n+{\n+  return convert_to_pointer_1 (type, expr, CONSTANT_CLASS_P (expr));\n+}\n \n /* Convert EXPR to some floating-point type TYPE.\n \n    EXPR must be float, fixed-point, integer, or enumeral;\n-   in other cases error is called.  */\n+   in other cases error is called.  If FOLD_P is true, try to fold\n+   the expression.  */\n \n-tree\n-convert_to_real (tree type, tree expr)\n+static tree\n+convert_to_real_1 (tree type, tree expr, bool fold_p)\n {\n   enum built_in_function fcode = builtin_mathfn_code (expr);\n   tree itype = TREE_TYPE (expr);\n+  location_t loc = EXPR_LOCATION (expr);\n \n   if (TREE_CODE (expr) == COMPOUND_EXPR)\n     {\n-      tree t = convert_to_real (type, TREE_OPERAND (expr, 1));\n+      tree t = convert_to_real_1 (type, TREE_OPERAND (expr, 1), fold_p);\n       if (t == TREE_OPERAND (expr, 1))\n \treturn expr;\n       return build2_loc (EXPR_LOCATION (expr), COMPOUND_EXPR, TREE_TYPE (t),\n@@ -208,14 +236,13 @@ convert_to_real (tree type, tree expr)\n \t\t      || TYPE_MODE (newtype) == TYPE_MODE (float_type_node)))\n \t\t{\n \t\t  tree fn = mathfn_built_in (newtype, fcode);\n-\n \t\t  if (fn)\n-\t\t  {\n-\t\t    tree arg = fold (convert_to_real (newtype, arg0));\n-\t\t    expr = build_call_expr (fn, 1, arg);\n-\t\t    if (newtype == type)\n-\t\t      return expr;\n-\t\t  }\n+\t\t    {\n+\t\t      tree arg = convert_to_real_1 (newtype, arg0, fold_p);\n+\t\t      expr = build_call_expr (fn, 1, arg);\n+\t\t      if (newtype == type)\n+\t\t\treturn expr;\n+\t\t    }\n \t\t}\n \t    }\n \tdefault:\n@@ -234,9 +261,11 @@ convert_to_real (tree type, tree expr)\n \t  if (!flag_rounding_math\n \t      && FLOAT_TYPE_P (itype)\n \t      && TYPE_PRECISION (type) < TYPE_PRECISION (itype))\n-\t    return build1 (TREE_CODE (expr), type,\n-\t\t\t   fold (convert_to_real (type,\n-\t\t\t\t\t\t  TREE_OPERAND (expr, 0))));\n+\t    {\n+\t      tree arg = convert_to_real_1 (type, TREE_OPERAND (expr, 0),\n+\t\t\t\t\t    fold_p);\n+\t      return build1 (TREE_CODE (expr), type, arg);\n+\t    }\n \t  break;\n \t/* Convert (outertype)((innertype0)a+(innertype1)b)\n \t   into ((newtype)a+(newtype)b) where newtype\n@@ -272,8 +301,10 @@ convert_to_real (tree type, tree expr)\n \t\t      || newtype == dfloat128_type_node)\n \t\t    {\n \t\t      expr = build2 (TREE_CODE (expr), newtype,\n-\t\t\t\t     fold (convert_to_real (newtype, arg0)),\n-\t\t\t\t     fold (convert_to_real (newtype, arg1)));\n+\t\t\t\t     convert_to_real_1 (newtype, arg0,\n+\t\t\t\t\t\t\tfold_p),\n+\t\t\t\t     convert_to_real_1 (newtype, arg1,\n+\t\t\t\t\t\t\tfold_p));\n \t\t      if (newtype == type)\n \t\t\treturn expr;\n \t\t      break;\n@@ -312,8 +343,10 @@ convert_to_real (tree type, tree expr)\n \t\t\t      && !excess_precision_type (newtype))))\n \t\t    {\n \t\t      expr = build2 (TREE_CODE (expr), newtype,\n-\t\t\t\t     fold (convert_to_real (newtype, arg0)),\n-\t\t\t\t     fold (convert_to_real (newtype, arg1)));\n+\t\t\t\t     convert_to_real_1 (newtype, arg0,\n+\t\t\t\t\t\t\tfold_p),\n+\t\t\t\t     convert_to_real_1 (newtype, arg1,\n+\t\t\t\t\t\t\tfold_p));\n \t\t      if (newtype == type)\n \t\t\treturn expr;\n \t\t    }\n@@ -344,30 +377,51 @@ convert_to_real (tree type, tree expr)\n \n     case COMPLEX_TYPE:\n       return convert (type,\n-\t\t      fold_build1 (REALPART_EXPR,\n-\t\t\t\t   TREE_TYPE (TREE_TYPE (expr)), expr));\n+\t\t      maybe_fold_build1_loc (fold_p, loc, REALPART_EXPR,\n+\t\t\t\t\t     TREE_TYPE (TREE_TYPE (expr)),\n+\t\t\t\t\t     expr));\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       error (\"pointer value used where a floating point value was expected\");\n-      return convert_to_real (type, integer_zero_node);\n+      return convert_to_real_1 (type, integer_zero_node, fold_p);\n \n     default:\n       error (\"aggregate value used where a float was expected\");\n-      return convert_to_real (type, integer_zero_node);\n+      return convert_to_real_1 (type, integer_zero_node, fold_p);\n     }\n }\n \n+/* A wrapper around convert_to_real_1 that always folds the\n+   expression.  */\n+\n+tree\n+convert_to_real (tree type, tree expr)\n+{\n+  return convert_to_real_1 (type, expr, true);\n+}\n+\n+/* A wrapper around convert_to_real_1 that only folds the\n+   expression if it is CONSTANT_CLASS_P.  */\n+\n+tree\n+convert_to_real_nofold (tree type, tree expr)\n+{\n+  return convert_to_real_1 (type, expr, CONSTANT_CLASS_P (expr));\n+}\n+\n /* Convert EXPR to some integer (or enum) type TYPE.\n \n    EXPR must be pointer, integer, discrete (enum, char, or bool), float,\n    fixed-point or vector; in other cases error is called.\n \n+   If DOFOLD is TRUE, we try to simplify newly-created patterns by folding.\n+\n    The result of this is always supposed to be a newly created tree node\n    not in use in any existing structure.  */\n \n-tree\n-convert_to_integer (tree type, tree expr)\n+static tree\n+convert_to_integer_1 (tree type, tree expr, bool dofold)\n {\n   enum tree_code ex_form = TREE_CODE (expr);\n   tree intype = TREE_TYPE (expr);\n@@ -385,7 +439,7 @@ convert_to_integer (tree type, tree expr)\n \n   if (ex_form == COMPOUND_EXPR)\n     {\n-      tree t = convert_to_integer (type, TREE_OPERAND (expr, 1));\n+      tree t = convert_to_integer_1 (type, TREE_OPERAND (expr, 1), dofold);\n       if (t == TREE_OPERAND (expr, 1))\n \treturn expr;\n       return build2_loc (EXPR_LOCATION (expr), COMPOUND_EXPR, TREE_TYPE (t),\n@@ -479,7 +533,7 @@ convert_to_integer (tree type, tree expr)\n \t  break;\n \n \tCASE_FLT_FN (BUILT_IN_TRUNC):\n-\t  return convert_to_integer (type, CALL_EXPR_ARG (s_expr, 0));\n+\t  return convert_to_integer_1 (type, CALL_EXPR_ARG (s_expr, 0), dofold);\n \n \tdefault:\n \t  break;\n@@ -488,7 +542,7 @@ convert_to_integer (tree type, tree expr)\n       if (fn)\n         {\n \t  tree newexpr = build_call_expr (fn, 1, CALL_EXPR_ARG (s_expr, 0));\n-\t  return convert_to_integer (type, newexpr);\n+\t  return convert_to_integer_1 (type, newexpr, dofold);\n \t}\n     }\n \n@@ -519,7 +573,7 @@ convert_to_integer (tree type, tree expr)\n       if (fn)\n         {\n \t  tree newexpr = build_call_expr (fn, 1, CALL_EXPR_ARG (s_expr, 0));\n-\t  return convert_to_integer (type, newexpr);\n+\t  return convert_to_integer_1 (type, newexpr, dofold);\n \t}\n     }\n \n@@ -534,6 +588,8 @@ convert_to_integer (tree type, tree expr)\n \t there widen/truncate to the required type.  Some targets support the\n \t coexistence of multiple valid pointer sizes, so fetch the one we need\n \t from the type.  */\n+      if (!dofold)\n+\treturn build1 (CONVERT_EXPR, type, expr);\n       expr = fold_build1 (CONVERT_EXPR,\n \t\t\t  lang_hooks.types.type_for_size\n \t\t\t    (TYPE_PRECISION (intype), 0),\n@@ -578,7 +634,7 @@ convert_to_integer (tree type, tree expr)\n \t  else\n \t    code = NOP_EXPR;\n \n-\t  return fold_build1 (code, type, expr);\n+\t  return maybe_fold_build1_loc (dofold, loc, code, type, expr);\n \t}\n \n       /* If TYPE is an enumeral type or a type with a precision less\n@@ -784,10 +840,12 @@ convert_to_integer (tree type, tree expr)\n \t\t\tif (TYPE_UNSIGNED (typex))\n \t\t\t  typex = signed_type_for (typex);\n \t\t      }\n-\t\t    return convert (type,\n-\t\t\t\t    fold_build2 (ex_form, typex,\n-\t\t\t\t\t\t convert (typex, arg0),\n-\t\t\t\t\t\t convert (typex, arg1)));\n+\t\t    /* We should do away with all this once we have a proper\n+\t\t       type promotion/demotion pass, see PR45397.  */\n+\t\t    expr = maybe_fold_build2_loc (dofold, loc, ex_form, typex,\n+\t\t\t\t\t\t  convert (typex, arg0),\n+\t\t\t\t\t\t  convert (typex, arg1));\n+\t\t    return convert (type, expr);\n \t\t  }\n \t      }\n \t  }\n@@ -798,6 +856,9 @@ convert_to_integer (tree type, tree expr)\n \t  /* This is not correct for ABS_EXPR,\n \t     since we must test the sign before truncation.  */\n \t  {\n+\t    if (!dofold)\n+\t      break;\n+\n \t    /* Do the arithmetic in type TYPEX,\n \t       then convert result to TYPE.  */\n \t    tree typex = type;\n@@ -833,13 +894,15 @@ convert_to_integer (tree type, tree expr)\n \t     the conditional and never loses.  A COND_EXPR may have a throw\n \t     as one operand, which then has void type.  Just leave void\n \t     operands as they are.  */\n-\t  return fold_build3 (COND_EXPR, type, TREE_OPERAND (expr, 0),\n-\t\t\t      VOID_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 1)))\n-\t\t\t      ? TREE_OPERAND (expr, 1)\n-\t\t\t      : convert (type, TREE_OPERAND (expr, 1)),\n-\t\t\t      VOID_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 2)))\n-\t\t\t      ? TREE_OPERAND (expr, 2)\n-\t\t\t      : convert (type, TREE_OPERAND (expr, 2)));\n+\t  if (dofold)\n+\t    return\n+\t      fold_build3 (COND_EXPR, type, TREE_OPERAND (expr, 0),\n+\t\t\t   VOID_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 1)))\n+\t\t\t   ? TREE_OPERAND (expr, 1)\n+\t\t\t   : convert (type, TREE_OPERAND (expr, 1)),\n+\t\t\t   VOID_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 2)))\n+\t\t\t   ? TREE_OPERAND (expr, 2)\n+\t\t\t   : convert (type, TREE_OPERAND (expr, 2)));\n \n \tdefault:\n \t  break;\n@@ -860,7 +923,8 @@ convert_to_integer (tree type, tree expr)\n \t  expr = build1 (FIX_TRUNC_EXPR, type, expr);\n \t  if (check == NULL)\n \t    return expr;\n-\t  return fold_build2 (COMPOUND_EXPR, TREE_TYPE (expr), check, expr);\n+\t  return maybe_fold_build2_loc (dofold, loc, COMPOUND_EXPR,\n+\t\t\t\t\tTREE_TYPE (expr), check, expr);\n \t}\n       else\n \treturn build1 (FIX_TRUNC_EXPR, type, expr);\n@@ -869,9 +933,9 @@ convert_to_integer (tree type, tree expr)\n       return build1 (FIXED_CONVERT_EXPR, type, expr);\n \n     case COMPLEX_TYPE:\n-      return convert (type,\n-\t\t      fold_build1 (REALPART_EXPR,\n-\t\t\t\t   TREE_TYPE (TREE_TYPE (expr)), expr));\n+      expr = maybe_fold_build1_loc (dofold, loc, REALPART_EXPR,\n+\t\t\t\t    TREE_TYPE (TREE_TYPE (expr)), expr);\n+      return convert (type, expr);\n \n     case VECTOR_TYPE:\n       if (!tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (TREE_TYPE (expr))))\n@@ -889,11 +953,42 @@ convert_to_integer (tree type, tree expr)\n     }\n }\n \n-/* Convert EXPR to the complex type TYPE in the usual ways.  */\n+/* Convert EXPR to some integer (or enum) type TYPE.\n+\n+   EXPR must be pointer, integer, discrete (enum, char, or bool), float,\n+   fixed-point or vector; in other cases error is called.\n+\n+   The result of this is always supposed to be a newly created tree node\n+   not in use in any existing structure.  */\n \n tree\n-convert_to_complex (tree type, tree expr)\n+convert_to_integer (tree type, tree expr)\n+{\n+  return convert_to_integer_1 (type, expr, true);\n+}\n+\n+/* Convert EXPR to some integer (or enum) type TYPE.\n+\n+   EXPR must be pointer, integer, discrete (enum, char, or bool), float,\n+   fixed-point or vector; in other cases error is called.\n+\n+   The result of this is always supposed to be a newly created tree node\n+   not in use in any existing structure.  The tree node isn't folded,\n+   beside EXPR is of constant class.  */\n+\n+tree\n+convert_to_integer_nofold (tree type, tree expr)\n {\n+  return convert_to_integer_1 (type, expr, CONSTANT_CLASS_P (expr));\n+}\n+\n+/* Convert EXPR to the complex type TYPE in the usual ways.  If FOLD_P is\n+   true, try to fold the expression.  */\n+\n+static tree\n+convert_to_complex_1 (tree type, tree expr, bool fold_p)\n+{\n+  location_t loc = EXPR_LOCATION (expr);\n   tree subtype = TREE_TYPE (type);\n \n   switch (TREE_CODE (TREE_TYPE (expr)))\n@@ -914,43 +1009,63 @@ convert_to_complex (tree type, tree expr)\n \t  return expr;\n \telse if (TREE_CODE (expr) == COMPOUND_EXPR)\n \t  {\n-\t    tree t = convert_to_complex (type, TREE_OPERAND (expr, 1));\n+\t    tree t = convert_to_complex_1 (type, TREE_OPERAND (expr, 1),\n+\t\t\t\t\t   fold_p);\n \t    if (t == TREE_OPERAND (expr, 1))\n \t      return expr;\n \t    return build2_loc (EXPR_LOCATION (expr), COMPOUND_EXPR,\n \t\t\t       TREE_TYPE (t), TREE_OPERAND (expr, 0), t);\n-\t  }    \n+\t  }\n \telse if (TREE_CODE (expr) == COMPLEX_EXPR)\n-\t  return fold_build2 (COMPLEX_EXPR, type,\n-\t\t\t      convert (subtype, TREE_OPERAND (expr, 0)),\n-\t\t\t      convert (subtype, TREE_OPERAND (expr, 1)));\n+\t  return maybe_fold_build2_loc (fold_p, loc, COMPLEX_EXPR, type,\n+\t\t\t\t\tconvert (subtype,\n+\t\t\t\t\t\t TREE_OPERAND (expr, 0)),\n+\t\t\t\t\tconvert (subtype,\n+\t\t\t\t\t\t TREE_OPERAND (expr, 1)));\n \telse\n \t  {\n \t    expr = save_expr (expr);\n-\t    return\n-\t      fold_build2 (COMPLEX_EXPR, type,\n-\t\t\t   convert (subtype,\n-\t\t\t\t    fold_build1 (REALPART_EXPR,\n-\t\t\t\t\t\t TREE_TYPE (TREE_TYPE (expr)),\n-\t\t\t\t\t\t expr)),\n-\t\t\t   convert (subtype,\n-\t\t\t\t    fold_build1 (IMAGPART_EXPR,\n-\t\t\t\t\t\t TREE_TYPE (TREE_TYPE (expr)),\n-\t\t\t\t\t\t expr)));\n+\t    tree realp = maybe_fold_build1_loc (fold_p, loc, REALPART_EXPR,\n+\t\t\t\t\t\tTREE_TYPE (TREE_TYPE (expr)),\n+\t\t\t\t\t\texpr);\n+\t    tree imagp = maybe_fold_build1_loc (fold_p, loc, IMAGPART_EXPR,\n+\t\t\t\t\t\tTREE_TYPE (TREE_TYPE (expr)),\n+\t\t\t\t\t\texpr);\n+\t    return maybe_fold_build2_loc (fold_p, loc, COMPLEX_EXPR, type,\n+\t\t\t\t\t  convert (subtype, realp),\n+\t\t\t\t\t  convert (subtype, imagp));\n \t  }\n       }\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       error (\"pointer value used where a complex was expected\");\n-      return convert_to_complex (type, integer_zero_node);\n+      return convert_to_complex_1 (type, integer_zero_node, fold_p);\n \n     default:\n       error (\"aggregate value used where a complex was expected\");\n-      return convert_to_complex (type, integer_zero_node);\n+      return convert_to_complex_1 (type, integer_zero_node, fold_p);\n     }\n }\n \n+/* A wrapper around convert_to_complex_1 that always folds the\n+   expression.  */\n+\n+tree\n+convert_to_complex (tree type, tree expr)\n+{\n+  return convert_to_complex_1 (type, expr, true);\n+}\n+\n+/* A wrapper around convert_to_complex_1 that only folds the\n+   expression if it is CONSTANT_CLASS_P.  */\n+\n+tree\n+convert_to_complex_nofold (tree type, tree expr)\n+{\n+  return convert_to_complex_1 (type, expr, CONSTANT_CLASS_P (expr));\n+}\n+\n /* Convert EXPR to the vector type TYPE in the usual ways.  */\n \n tree"}, {"sha": "7cc31684a7a558b2af4ef1f55287d470b63b974a", "filename": "gcc/convert.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269e63b735d6e4e18367e94e8417b5d5eb799960/gcc%2Fconvert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269e63b735d6e4e18367e94e8417b5d5eb799960/gcc%2Fconvert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.h?ref=269e63b735d6e4e18367e94e8417b5d5eb799960", "patch": "@@ -21,10 +21,14 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_CONVERT_H\n \n extern tree convert_to_integer (tree, tree);\n+extern tree convert_to_integer_nofold (tree, tree);\n extern tree convert_to_pointer (tree, tree);\n+extern tree convert_to_pointer_nofold (tree, tree);\n extern tree convert_to_real (tree, tree);\n+extern tree convert_to_real_nofold (tree, tree);\n extern tree convert_to_fixed (tree, tree);\n extern tree convert_to_complex (tree, tree);\n+extern tree convert_to_complex_nofold (tree, tree);\n extern tree convert_to_vector (tree, tree);\n \n #endif /* GCC_CONVERT_H */"}, {"sha": "0204cfefb0e0897943712117191c6dcd50bc5ff7", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/269e63b735d6e4e18367e94e8417b5d5eb799960/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/269e63b735d6e4e18367e94e8417b5d5eb799960/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=269e63b735d6e4e18367e94e8417b5d5eb799960", "patch": "@@ -432,8 +432,8 @@ create_one_component_var (tree type, tree orig, const char *prefix,\n   if (DECL_NAME (orig) && !DECL_IGNORED_P (orig))\n     {\n       const char *name = IDENTIFIER_POINTER (DECL_NAME (orig));\n-\n-      DECL_NAME (r) = get_identifier (ACONCAT ((name, suffix, NULL)));\n+      name = ACONCAT ((name, suffix, NULL));\n+      DECL_NAME (r) = get_identifier (name);\n \n       SET_DECL_DEBUG_EXPR (r, build1 (code, type, orig));\n       DECL_HAS_DEBUG_EXPR_P (r) = 1;"}]}