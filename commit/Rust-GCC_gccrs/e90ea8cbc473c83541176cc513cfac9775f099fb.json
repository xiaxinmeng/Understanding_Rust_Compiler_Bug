{"sha": "e90ea8cbc473c83541176cc513cfac9775f099fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkwZWE4Y2JjNDczYzgzNTQxMTc2Y2M1MTNjZmFjOTc3NWYwOTlmYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-11-04T09:12:12Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-11-04T09:12:12Z"}, "message": "bitmap.h (bitmap_iterator): Remove word_bit and bit fields.\n\n\t* bitmap.h (bitmap_iterator): Remove word_bit and bit\n\tfields. Rename others.\n\t(bmp_iter_common_next_1, bmp_iter_single_next_1,\n\tbmp_iter_single_init, bmp_iter_end_p, bmp_iter_single_next,\n\tbmp_iter_and_not_next_1, bmp_iter_and_not_init,\n\tbmp_iter_and_not_next, bmp_iter_and_next_1, bmp_iter_and_init,\n\tbmp_iter_and_next): Remove.\n\t(bmp_iter_set_init, bmp_iter_and_init, bmp_iter_and_compl_init,\n\tbmp_iter_next, bmp_iter_set, bmp_iter_and, bmp_iter_and_compl):\n\tNew.\n\t(EXECUTE_IF_SET_IN_BITMAP, EXECUTE_IF_AND_IN_BITMAP,\n\tEXECUTE_IF_AND_COMPL_IN_BITMAP): Adjust.\n\nFrom-SVN: r90055", "tree": {"sha": "baa9f15d3be7a5a2ed37b5df9c7469b4f622a578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baa9f15d3be7a5a2ed37b5df9c7469b4f622a578"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e90ea8cbc473c83541176cc513cfac9775f099fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90ea8cbc473c83541176cc513cfac9775f099fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e90ea8cbc473c83541176cc513cfac9775f099fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90ea8cbc473c83541176cc513cfac9775f099fb/comments", "author": null, "committer": null, "parents": [{"sha": "67299d9127c08dcc633ea6433dc1a3234256eaf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67299d9127c08dcc633ea6433dc1a3234256eaf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67299d9127c08dcc633ea6433dc1a3234256eaf0"}], "stats": {"total": 651, "additions": 315, "deletions": 336}, "files": [{"sha": "9c60546dfe7aa9192d06b1a4eb5c35b7a8ef730a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90ea8cbc473c83541176cc513cfac9775f099fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90ea8cbc473c83541176cc513cfac9775f099fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e90ea8cbc473c83541176cc513cfac9775f099fb", "patch": "@@ -1,5 +1,18 @@\n 2004-11-04  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* bitmap.h (bitmap_iterator): Remove word_bit and bit\n+\tfields. Rename others.\n+\t(bmp_iter_common_next_1, bmp_iter_single_next_1,\n+\tbmp_iter_single_init, bmp_iter_end_p, bmp_iter_single_next,\n+\tbmp_iter_and_not_next_1, bmp_iter_and_not_init,\n+\tbmp_iter_and_not_next, bmp_iter_and_next_1, bmp_iter_and_init,\n+\tbmp_iter_and_next): Remove.\n+\t(bmp_iter_set_init, bmp_iter_and_init, bmp_iter_and_compl_init,\n+\tbmp_iter_next, bmp_iter_set, bmp_iter_and, bmp_iter_and_compl):\n+\tNew.\n+\t(EXECUTE_IF_SET_IN_BITMAP, EXECUTE_IF_AND_IN_BITMAP,\n+\tEXECUTE_IF_AND_COMPL_IN_BITMAP): Adjust.\n+\n \t* bitmap.h (bitmap_a_or_b, bitmap_a_and_b): Remove.\n \t* df.c (dataflow_set_a_op_b): Use bitmap_and, bitmap_ior,\n \tbitmap_and_into, bitmap_ior_into as appropriate."}, {"sha": "f46dcf4c2ba8da46411cff30dd94689f1730bcce", "filename": "gcc/bitmap.h", "status": "modified", "additions": 302, "deletions": 336, "changes": 638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90ea8cbc473c83541176cc513cfac9775f099fb/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90ea8cbc473c83541176cc513cfac9775f099fb/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=e90ea8cbc473c83541176cc513cfac9775f099fb", "patch": "@@ -184,421 +184,387 @@ do {\t\t\t\t\t\t\\\n \n typedef struct\n {\n-  /* Actual elements in the bitmaps.  */\n-  bitmap_element *ptr1, *ptr2;\n-\n-  /* Position of an actual word in the elements.  */\n-  unsigned word;\n-\n-  /* Position of a bit corresponding to the start of word.  */\n-  unsigned word_bit;\n-\n-  /* Position of the actual bit.  */\n-  unsigned bit;\n-\n+  /* Pointer to the current bitmap element.  */\n+  bitmap_element *elt1;\n+  \n+  /* Pointer to 2nd bitmap element when two are involved.  */\n+  bitmap_element *elt2;\n+\n+  /* Word within the current element.  */\n+  unsigned word_no;\n+  \n   /* Contents of the actually processed word.  When finding next bit\n      it is shifted right, so that the actual bit is always the least\n      significant bit of ACTUAL.  */\n-  BITMAP_WORD actual;\n+  BITMAP_WORD bits;\n } bitmap_iterator;\n \n-/* Moves the iterator BI to the first set bit on or after the current\n-   position in bitmap and returns the bit if available.  The bit is\n-   found in ACTUAL field only.  */\n+/* Initialize a single bitmap iterator.  START_BIT is the first bit to\n+   iterate from.  */\n \n-static inline unsigned\n-bmp_iter_common_next_1 (bitmap_iterator *bi)\n+static inline void\n+bmp_iter_set_init (bitmap_iterator *bi, bitmap map,\n+\t\t   unsigned start_bit, unsigned *bit_no)\n {\n-  while (!(bi->actual & 1))\n+  bi->elt1 = map->first;\n+  bi->elt2 = NULL;\n+\n+  /* Advance elt1 until it is not before the block containing start_bit.  */\n+  while (1)\n     {\n-      bi->actual >>= 1;\n-      bi->bit++;\n+      if (!bi->elt1)\n+\t{\n+\t  bi->elt1 = &bitmap_zero_bits;\n+\t  break;\n+\t}\n+      \n+      if (bi->elt1->indx >= start_bit / BITMAP_ELEMENT_ALL_BITS)\n+\tbreak;\n+      bi->elt1 = bi->elt1->next;\n     }\n \n-  return bi->bit;\n+  /* We might have gone past the start bit, so reinitialize it.  */\n+  if (bi->elt1->indx != start_bit / BITMAP_ELEMENT_ALL_BITS)\n+    start_bit = bi->elt1->indx * BITMAP_ELEMENT_ALL_BITS;\n+  \n+  /* Initialize for what is now start_bit.  */\n+  bi->word_no = start_bit / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\n+  bi->bits = bi->elt1->bits[bi->word_no];\n+  bi->bits >>= start_bit % BITMAP_WORD_BITS;\n+\n+  /* If this word is zero, we must make sure we're not pointing at the\n+     first bit, otherwise our incrementing to the next word boundary\n+     will fail.  It won't matter if this increment moves us into the\n+     next word.  */\n+  start_bit += !bi->bits;\n+  \n+  *bit_no = start_bit;\n }\n \n-/* Moves the iterator BI to the first set bit on or after the current\n-   position in bitmap and returns the bit if available.  */\n+/* Initialize an iterator to iterate over the intersection of two\n+   bitmaps.  START_BIT is the bit to commence from.  */\n \n-static inline unsigned\n-bmp_iter_single_next_1 (bitmap_iterator *bi)\n+static inline void\n+bmp_iter_and_init (bitmap_iterator *bi, bitmap map1, bitmap map2,\n+\t\t   unsigned start_bit, unsigned *bit_no)\n {\n-  if (bi->actual)\n-    return bmp_iter_common_next_1 (bi);\n-\n-  bi->word++;\n-  bi->word_bit += BITMAP_WORD_BITS;\n+  bi->elt1 = map1->first;\n+  bi->elt2 = map2->first;\n \n+  /* Advance elt1 until it is not before the block containing\n+     start_bit.  */\n   while (1)\n     {\n-      for (;\n-\t   bi->word < BITMAP_ELEMENT_WORDS;\n-\t   bi->word++, bi->word_bit += BITMAP_WORD_BITS)\n+      if (!bi->elt1)\n \t{\n-\t  bi->actual = bi->ptr1->bits[bi->word];\n-\t  if (bi->actual)\n-\t    {\n-\t      bi->bit = bi->word_bit;\n-\t      return bmp_iter_common_next_1 (bi);\n-\t    }\n+\t  bi->elt2 = NULL;\n+\t  break;\n \t}\n-\n-      bi->ptr1 = bi->ptr1->next;\n-      if (!bi->ptr1)\n-\treturn 0;\n-\n-      bi->word = 0;\n-      bi->word_bit = bi->ptr1->indx * BITMAP_ELEMENT_ALL_BITS;\n+      \n+      if (bi->elt1->indx >= start_bit / BITMAP_ELEMENT_ALL_BITS)\n+\tbreak;\n+      bi->elt1 = bi->elt1->next;\n     }\n-}\n-\n-/* Initializes a bitmap iterator BI for looping over bits of bitmap\n-   BMP, starting with bit MIN.  Returns the first bit of BMP greater\n-   or equal to MIN if there is any.  */\n-\n-static inline unsigned\n-bmp_iter_single_init (bitmap_iterator *bi, bitmap bmp, unsigned min)\n-{\n-  unsigned indx = min / BITMAP_ELEMENT_ALL_BITS;\n-\n-  for (bi->ptr1 = bmp->first;\n-       bi->ptr1 && bi->ptr1->indx < indx;\n-       bi->ptr1 = bi->ptr1->next)\n-    continue;\n-\n-  if (!bi->ptr1)\n+  \n+  /* Advance elt2 until it is not before elt1.  */\n+  while (1)\n     {\n-      /* To avoid warnings.  */\n-      bi->word = 0;\n-      bi->bit = 0;\n-      bi->word_bit = 0;\n-      bi->actual = 0;\n-      bi->ptr2 = NULL;\n-      return 0;\n+      if (!bi->elt2)\n+\t{\n+\t  bi->elt1 = bi->elt2 = &bitmap_zero_bits;\n+\t  break;\n+\t}\n+      \n+      if (bi->elt2->indx >= bi->elt1->indx)\n+\tbreak;\n+      bi->elt2 = bi->elt2->next;\n     }\n \n-  if (bi->ptr1->indx == indx)\n+  /* If we're at the same index, then we have some intersecting bits.   */\n+  if (bi->elt1->indx == bi->elt2->indx)\n     {\n-      unsigned bit_in_elt = min - BITMAP_ELEMENT_ALL_BITS * indx;\n-      unsigned word_in_elt = bit_in_elt / BITMAP_WORD_BITS;\n-      unsigned bit_in_word = bit_in_elt % BITMAP_WORD_BITS;\n-\n-      bi->word = word_in_elt;\n-      bi->word_bit = min - bit_in_word;\n-      bi->bit = min;\n-      bi->actual = bi->ptr1->bits[word_in_elt] >> bit_in_word;\n+      /* We might have advanced beyond the start_bit, so reinitialize\n+     \t for that.  */\n+      if (bi->elt1->indx != start_bit / BITMAP_ELEMENT_ALL_BITS)\n+\tstart_bit = bi->elt1->indx * BITMAP_ELEMENT_ALL_BITS;\n+      \n+      bi->word_no = start_bit / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\n+      bi->bits = bi->elt1->bits[bi->word_no] & bi->elt2->bits[bi->word_no];\n+      bi->bits >>= start_bit % BITMAP_WORD_BITS;\n     }\n   else\n     {\n-      bi->word = 0;\n-      bi->bit = bi->ptr1->indx * BITMAP_ELEMENT_ALL_BITS;\n-      bi->word_bit = bi->bit;\n-      bi->actual = bi->ptr1->bits[0];\n+      /* Otherwise we must immediately advance elt1, so initialize for\n+\t that.  */\n+      bi->word_no = BITMAP_ELEMENT_WORDS - 1;\n+      bi->bits = 0;\n     }\n-\n-  return bmp_iter_single_next_1 (bi);\n+  \n+  /* If this word is zero, we must make sure we're not pointing at the\n+     first bit, otherwise our incrementing to the next word boundary\n+     will fail.  It won't matter if this increment moves us into the\n+     next word.  */\n+  start_bit += !bi->bits;\n+  \n+  *bit_no = start_bit;\n }\n \n-/* Returns true if all elements of the bitmap referred to by iterator BI\n-   were processed.  */\n+/* Initialize an iterator to iterate over the bits in MAP1 & ~MAP2.\n+   */\n \n-static inline bool\n-bmp_iter_end_p (const bitmap_iterator *bi)\n+static inline void\n+bmp_iter_and_compl_init (bitmap_iterator *bi, bitmap map1, bitmap map2,\n+\t\t\t unsigned start_bit, unsigned *bit_no)\n {\n-  return bi->ptr1 == NULL;\n-}\n-\n-/* Moves the iterator BI to the next bit of bitmap and returns the bit\n-   if available.  */\n-\n-static inline unsigned\n-bmp_iter_single_next (bitmap_iterator *bi)\n-{\n-  bi->bit++;\n-  bi->actual >>= 1;\n-  return bmp_iter_single_next_1 (bi);\n-}\n-\n-/* Loop over all bits in BITMAP, starting with MIN and setting BITNUM to\n-   the bit number.  ITER is a bitmap iterator.  */\n-\n-#define EXECUTE_IF_SET_IN_BITMAP(BITMAP, MIN, BITNUM, ITER)\t\t\\\n-  for ((BITNUM) = bmp_iter_single_init (&(ITER), (BITMAP), (MIN));\t\\\n-       !bmp_iter_end_p (&(ITER));\t\t\t\t\t\\\n-       (BITNUM) = bmp_iter_single_next (&(ITER)))\n-\n-/* Moves the iterator BI to the first set bit on or after the current\n-   position in difference of bitmaps and returns the bit if available.  */\n-\n-static inline unsigned\n-bmp_iter_and_not_next_1 (bitmap_iterator *bi)\n-{\n-  if (bi->actual)\n-    return bmp_iter_common_next_1 (bi);\n-\n-  bi->word++;\n-  bi->word_bit += BITMAP_WORD_BITS;\n+  bi->elt1 = map1->first;\n+  bi->elt2 = map2->first;\n \n+  /* Advance elt1 until it is not before the block containing start_bit.  */\n   while (1)\n     {\n-      bitmap_element *snd;\n-\n-      if (bi->ptr2 && bi->ptr2->indx == bi->ptr1->indx)\n-\tsnd = bi->ptr2;\n-      else\n-\tsnd = &bitmap_zero_bits;\n-\n-      for (;\n-\t   bi->word < BITMAP_ELEMENT_WORDS;\n-\t   bi->word++, bi->word_bit += BITMAP_WORD_BITS)\n+      if (!bi->elt1)\n \t{\n-\t  bi->actual = (bi->ptr1->bits[bi->word]\n-\t\t\t& ~snd->bits[bi->word]);\n-\t  if (bi->actual)\n-\t    {\n-\t      bi->bit = bi->word_bit;\n-\t      return bmp_iter_common_next_1 (bi);\n-\t    }\n+\t  bi->elt1 = &bitmap_zero_bits;\n+\t  break;\n \t}\n-\n-      bi->ptr1 = bi->ptr1->next;\n-      if (!bi->ptr1)\n-\treturn 0;\n-\n-      while (bi->ptr2\n-\t     && bi->ptr2->indx < bi->ptr1->indx)\n-\tbi->ptr2 = bi->ptr2->next;\n-\n-      bi->word = 0;\n-      bi->word_bit = bi->ptr1->indx * BITMAP_ELEMENT_ALL_BITS;\n+      \n+      if (bi->elt1->indx >= start_bit / BITMAP_ELEMENT_ALL_BITS)\n+\tbreak;\n+      bi->elt1 = bi->elt1->next;\n     }\n+\n+  /* Advance elt2 until it is not before elt1.  */\n+  while (bi->elt2 && bi->elt2->indx < bi->elt1->indx)\n+    bi->elt2 = bi->elt2->next;\n+\n+  /* We might have advanced beyond the start_bit, so reinitialize for\n+     that.  */\n+  if (bi->elt1->indx != start_bit / BITMAP_ELEMENT_ALL_BITS)\n+    start_bit = bi->elt1->indx * BITMAP_ELEMENT_ALL_BITS;\n+  \n+  bi->word_no = start_bit / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\n+  bi->bits = bi->elt1->bits[bi->word_no];\n+  if (bi->elt2 && bi->elt1->indx == bi->elt2->indx)\n+    bi->bits &= ~bi->elt2->bits[bi->word_no];\n+  bi->bits >>= start_bit % BITMAP_WORD_BITS;\n+  \n+  /* If this word is zero, we must make sure we're not pointing at the\n+     first bit, otherwise our incrementing to the next word boundary\n+     will fail.  It won't matter if this increment moves us into the\n+     next word.  */\n+  start_bit += !bi->bits;\n+  \n+  *bit_no = start_bit;\n }\n \n-/* Initializes a bitmap iterator BI for looping over bits of bitmap\n-   BMP1 &~ BMP2, starting with bit MIN.  Returns the first bit of\n-   BMP1 &~ BMP2 greater or equal to MIN if there is any.  */\n+/* Advance to the next bit in BI.  We don't advance to the next\n+   non-zero bit yet.  */\n \n-static inline unsigned\n-bmp_iter_and_not_init (bitmap_iterator *bi, bitmap bmp1, bitmap bmp2,\n-\t\t       unsigned min)\n+static inline void\n+bmp_iter_next (bitmap_iterator *bi, unsigned *bit_no)\n {\n-  unsigned indx = min / BITMAP_ELEMENT_ALL_BITS;\n+  bi->bits >>= 1;\n+  *bit_no += 1;\n+}\n \n-  for (bi->ptr1 = bmp1->first;\n-       bi->ptr1 && bi->ptr1->indx < indx;\n-       bi->ptr1 = bi->ptr1->next)\n-    continue;\n+/* Advance to the next non-zero bit of a single bitmap, we will have\n+   already advanced past the just iterated bit.  Return true if there\n+   is a bit to iterate.  */\n \n-  if (!bi->ptr1)\n+static inline bool\n+bmp_iter_set (bitmap_iterator *bi, unsigned *bit_no)\n+{\n+  /* If our current word is non-zero, it contains the bit we want.  */\n+  if (bi->bits)\n     {\n-      /* To avoid warnings.  */\n-      bi->word = 0;\n-      bi->bit = 0;\n-      bi->word_bit = 0;\n-      bi->actual = 0;\n-      bi->ptr2 = NULL;\n-      return 0;\n+    next_bit:\n+      while (!(bi->bits & 1))\n+\t{\n+\t  bi->bits >>= 1;\n+\t  *bit_no += 1;\n+\t}\n+      return true;\n     }\n \n-  for (bi->ptr2 = bmp2->first;\n-       bi->ptr2 && bi->ptr2->indx < bi->ptr1->indx;\n-       bi->ptr2 = bi->ptr2->next)\n-    continue;\n+  /* Round up to the word boundary.  We might have just iterated past\n+     the end of the last word, hence the -1.  It is not possible for\n+     bit_no to point at the beginning of the now last word.  */\n+  *bit_no = ((*bit_no + BITMAP_WORD_BITS - 1)\n+\t     / BITMAP_WORD_BITS * BITMAP_WORD_BITS);\n+  bi->word_no++;\n \n-  if (bi->ptr1->indx == indx)\n-    {\n-      unsigned bit_in_elt = min - BITMAP_ELEMENT_ALL_BITS * indx;\n-      unsigned word_in_elt = bit_in_elt / BITMAP_WORD_BITS;\n-      unsigned bit_in_word = bit_in_elt % BITMAP_WORD_BITS;\n-\n-      bi->word = word_in_elt;\n-      bi->word_bit = min - bit_in_word;\n-      bi->bit = min;\n-\n-      if (bi->ptr2 && bi->ptr2->indx == indx)\n-\tbi->actual = (bi->ptr1->bits[word_in_elt]\n-\t\t      & ~bi->ptr2->bits[word_in_elt]) >> bit_in_word;\n-      else\n-       bi->actual = bi->ptr1->bits[word_in_elt] >> bit_in_word;\n-    }\n-  else\n+  while (1)\n     {\n-      bi->word = 0;\n-      bi->bit = bi->ptr1->indx * BITMAP_ELEMENT_ALL_BITS;\n-      bi->word_bit = bi->bit;\n-\n-      if (bi->ptr2 && bi->ptr2->indx == bi->ptr1->indx)\n-\tbi->actual = (bi->ptr1->bits[0] & ~bi->ptr2->bits[0]);\n-      else\n-\tbi->actual = bi->ptr1->bits[0];\n+      /* Find the next non-zero word in this elt.  */\n+      while (bi->word_no != BITMAP_ELEMENT_WORDS)\n+\t{\n+\t  bi->bits = bi->elt1->bits[bi->word_no];\n+\t  if (bi->bits)\n+\t    goto next_bit;\n+\t  *bit_no += BITMAP_WORD_BITS;\n+\t  bi->word_no++;\n+\t}\n+  \n+      /* Advance to the next element.  */\n+      bi->elt1 = bi->elt1->next;\n+      if (!bi->elt1)\n+\treturn false;\n+      *bit_no = bi->elt1->indx * BITMAP_ELEMENT_ALL_BITS;\n+      bi->word_no = 0;\n     }\n-\n-  return bmp_iter_and_not_next_1 (bi);\n-}\n-\n-/* Moves the iterator BI to the next bit of difference of bitmaps and returns\n-   the bit if available.  */\n-\n-static inline unsigned\n-bmp_iter_and_not_next (bitmap_iterator *bi)\n-{\n-  bi->bit++;\n-  bi->actual >>= 1;\n-  return bmp_iter_and_not_next_1 (bi);\n }\n \n-/* Loop over all bits in BMP1 and BMP2, starting with MIN, setting\n-   BITNUM to the bit number for all bits that are set in the first bitmap\n-   and not set in the second.  ITER is a bitmap iterator.  */\n+/* Advance to the next non-zero bit of an intersecting pair of\n+   bitmaps.  We will have alreadt advanced past the just iterated bit.\n+   Return true if there is a bit to iterate.  */\n \n-#define EXECUTE_IF_AND_COMPL_IN_BITMAP(BMP1, BMP2, MIN, BITNUM, ITER)\t\\\n-  for ((BITNUM) = bmp_iter_and_not_init (&(ITER), (BMP1), (BMP2), (MIN)); \\\n-       !bmp_iter_end_p (&(ITER));\t\t\t\t\t\t\\\n-       (BITNUM) = bmp_iter_and_not_next (&(ITER)))\n-\n-/* Moves the iterator BI to the first set bit on or after the current\n-   position in intersection of bitmaps and returns the bit if available.  */\n-\n-static inline unsigned\n-bmp_iter_and_next_1 (bitmap_iterator *bi)\n+static inline bool\n+bmp_iter_and (bitmap_iterator *bi, unsigned *bit_no)\n {\n-  if (bi->actual)\n-    return bmp_iter_common_next_1 (bi);\n-\n-  bi->word++;\n-  bi->word_bit += BITMAP_WORD_BITS;\n+  /* If our current word is non-zero, it contains the bit we want.  */\n+  if (bi->bits)\n+    {\n+    next_bit:\n+      while (!(bi->bits & 1))\n+\t{\n+\t  bi->bits >>= 1;\n+\t  *bit_no += 1;\n+\t}\n+      return true;\n+    }\n \n+  /* Round up to the word boundary.  We might have just iterated past\n+     the end of the last word, hence the -1.  It is not possible for\n+     bit_no to point at the beginning of the now last word.  */\n+  *bit_no = ((*bit_no + BITMAP_WORD_BITS - 1)\n+\t     / BITMAP_WORD_BITS * BITMAP_WORD_BITS);\n+  bi->word_no++;\n+  \n   while (1)\n     {\n-      for (;\n-\t   bi->word < BITMAP_ELEMENT_WORDS;\n-\t   bi->word++, bi->word_bit += BITMAP_WORD_BITS)\n+      /* Find the next non-zero word in this elt.  */\n+      while (bi->word_no != BITMAP_ELEMENT_WORDS)\n \t{\n-\t  bi->actual = (bi->ptr1->bits[bi->word]\n-\t\t\t& bi->ptr2->bits[bi->word]);\n-\t  if (bi->actual)\n-\t    {\n-\t      bi->bit = bi->word_bit;\n-\t      return bmp_iter_common_next_1 (bi);\n-\t    }\n+\t  bi->bits = bi->elt1->bits[bi->word_no] & bi->elt2->bits[bi->word_no];\n+\t  if (bi->bits)\n+\t    goto next_bit;\n+\t  *bit_no += BITMAP_WORD_BITS;\n+\t  bi->word_no++;\n \t}\n-\n+  \n+      /* Advance to the next identical element.  */\n       do\n \t{\n-\t  bi->ptr1 = bi->ptr1->next;\n-\t  if (!bi->ptr1)\n-\t    return 0;\n-\n-\t  while (bi->ptr2->indx < bi->ptr1->indx)\n+\t  /* Advance elt1 while it is less than elt2.  We always want\n+\t     to advance one elt.  */\n+\t  do\n \t    {\n-\t      bi->ptr2 = bi->ptr2->next;\n-\t      if (!bi->ptr2)\n-\t\t{\n-\t\t  bi->ptr1 = NULL;\n-\t\t  return 0;\n-\t\t}\n+\t      bi->elt1 = bi->elt1->next;\n+\t      if (!bi->elt1)\n+\t\treturn false;\n+\t    }\n+\t  while (bi->elt1->indx < bi->elt2->indx);\n+\t\n+\t  /* Advance elt2 to be no less than elt1.  This might not\n+\t     advance.  */\n+\t  while (bi->elt2->indx < bi->elt1->indx)\n+\t    {\n+\t      bi->elt2 = bi->elt2->next;\n+\t      if (!bi->elt2)\n+\t\treturn false;\n \t    }\n \t}\n-      while (bi->ptr1->indx != bi->ptr2->indx);\n-\n-      bi->word = 0;\n-      bi->word_bit = bi->ptr1->indx * BITMAP_ELEMENT_ALL_BITS;\n+      while (bi->elt1->indx != bi->elt2->indx);\n+  \n+      *bit_no = bi->elt1->indx * BITMAP_ELEMENT_ALL_BITS;\n+      bi->word_no = 0;\n     }\n }\n \n-/* Initializes a bitmap iterator BI for looping over bits of bitmap\n-   BMP1 & BMP2, starting with bit MIN.  Returns the first bit of\n-   BMP1 & BMP2 greater or equal to MIN if there is any.  */\n+/* Advance to the next non-zero bit in the intersection of\n+   complemented bitmaps.  We will have already advanced past the just\n+   iterated bit.  */\n \n-static inline unsigned\n-bmp_iter_and_init (bitmap_iterator *bi, bitmap bmp1, bitmap bmp2,\n-\t\t       unsigned min)\n+static inline bool\n+bmp_iter_and_compl (bitmap_iterator *bi, unsigned *bit_no)\n {\n-  unsigned indx = min / BITMAP_ELEMENT_ALL_BITS;\n-\n-  for (bi->ptr1 = bmp1->first;\n-       bi->ptr1 && bi->ptr1->indx < indx;\n-       bi->ptr1 = bi->ptr1->next)\n-    continue;\n-\n-  if (!bi->ptr1)\n-    goto empty;\n-\n-  bi->ptr2 = bmp2->first;\n-  if (!bi->ptr2)\n-    goto empty;\n-\n-  while (1)\n+  /* If our current word is non-zero, it contains the bit we want.  */\n+  if (bi->bits)\n     {\n-      while (bi->ptr2->indx < bi->ptr1->indx)\n+    next_bit:\n+      while (!(bi->bits & 1))\n \t{\n-\t  bi->ptr2 = bi->ptr2->next;\n-\t  if (!bi->ptr2)\n-\t    goto empty;\n+\t  bi->bits >>= 1;\n+\t  *bit_no += 1;\n \t}\n-\n-      if (bi->ptr1->indx == bi->ptr2->indx)\n-\tbreak;\n-\n-      bi->ptr1 = bi->ptr1->next;\n-      if (!bi->ptr1)\n-\tgoto empty;\n+      return true;\n     }\n \n-  if (bi->ptr1->indx == indx)\n-    {\n-      unsigned bit_in_elt = min - BITMAP_ELEMENT_ALL_BITS * indx;\n-      unsigned word_in_elt = bit_in_elt / BITMAP_WORD_BITS;\n-      unsigned bit_in_word = bit_in_elt % BITMAP_WORD_BITS;\n-\n-      bi->word = word_in_elt;\n-      bi->word_bit = min - bit_in_word;\n-      bi->bit = min;\n+  /* Round up to the word boundary.  We might have just iterated past\n+     the end of the last word, hence the -1.  It is not possible for\n+     bit_no to point at the beginning of the now last word.  */\n+  *bit_no = ((*bit_no + BITMAP_WORD_BITS - 1)\n+\t     / BITMAP_WORD_BITS * BITMAP_WORD_BITS);\n+  bi->word_no++;\n \n-      bi->actual = (bi->ptr1->bits[word_in_elt]\n-\t\t    & bi->ptr2->bits[word_in_elt]) >> bit_in_word;\n-    }\n-  else\n+  while (1)\n     {\n-      bi->word = 0;\n-      bi->bit = bi->ptr1->indx * BITMAP_ELEMENT_ALL_BITS;\n-      bi->word_bit = bi->bit;\n-\n-      bi->actual = (bi->ptr1->bits[0] & bi->ptr2->bits[0]);\n+      /* Find the next non-zero word in this elt.  */\n+      while (bi->word_no != BITMAP_ELEMENT_WORDS)\n+\t{\n+\t  bi->bits = bi->elt1->bits[bi->word_no];\n+\t  if (bi->elt2 && bi->elt2->indx == bi->elt1->indx)\n+\t    bi->bits &= ~bi->elt2->bits[bi->word_no];\n+\t  if (bi->bits)\n+\t    goto next_bit;\n+\t  *bit_no += BITMAP_WORD_BITS;\n+\t  bi->word_no++;\n+\t}\n+  \n+      /* Advance to the next element of elt1.  */\n+      bi->elt1 = bi->elt1->next;\n+      if (!bi->elt1)\n+\treturn false;\n+\n+      /* Advance elt2 until it is no less than elt1.  */\n+      while (bi->elt2 && bi->elt2->indx < bi->elt1->indx)\n+\tbi->elt2 = bi->elt2->next;\n+      \n+      *bit_no = bi->elt1->indx * BITMAP_ELEMENT_ALL_BITS;\n+      bi->word_no = 0;\n     }\n-\n-  return bmp_iter_and_next_1 (bi);\n-\n-empty:\n-  /* To avoid warnings.  */\n-  bi->word = 0;\n-  bi->bit = 0;\n-  bi->word_bit = 0;\n-  bi->actual = 0;\n-  bi->ptr1 = NULL;\n-  bi->ptr2 = NULL;\n-  return 0;\n-}\n-\n-/* Moves the iterator BI to the next bit of intersection of bitmaps and returns\n-   the bit if available.  */\n-\n-static inline unsigned\n-bmp_iter_and_next (bitmap_iterator *bi)\n-{\n-  bi->bit++;\n-  bi->actual >>= 1;\n-  return bmp_iter_and_next_1 (bi);\n }\n \n-/* Loop over all bits in BMP1 and BMP2, starting with MIN, setting\n-   BITNUM to the bit number for all bits that are set in both bitmaps.\n-   ITER is a bitmap iterator.  */\n+/* Loop over all bits set in BITMAP, starting with MIN and setting\n+   BITNUM to the bit number.  ITER is a bitmap iterator.  BITNUM\n+   should be treated as a read-only variable as it contains loop\n+   state.  */\n \n-#define EXECUTE_IF_AND_IN_BITMAP(BMP1, BMP2, MIN, BITNUM, ITER)\t\t\\\n-  for ((BITNUM) = bmp_iter_and_init (&(ITER), (BMP1), (BMP2), (MIN));\t\\\n-       !bmp_iter_end_p (&(ITER));\t\t\t\t\t\t\\\n-       (BITNUM) = bmp_iter_and_next (&(ITER)))\n+#define EXECUTE_IF_SET_IN_BITMAP(BITMAP, MIN, BITNUM, ITER)\t\t\\\n+  for (bmp_iter_set_init (&(ITER), (BITMAP), (MIN), &(BITNUM));\t\t\\\n+       bmp_iter_set (&(ITER), &(BITNUM));\t\t\t\t\\\n+       bmp_iter_next (&(ITER), &(BITNUM)))\n+\n+/* Loop over all the bits set in BITMAP1 & BITMAP2, starting with MIN\n+   and setting BITNUM to the bit number.  ITER is a bitmap iterator.\n+   BITNUM should be treated as a read-only variable as it contains\n+   loop state.  */\n+\n+#define EXECUTE_IF_AND_IN_BITMAP(BITMAP1, BITMAP2, MIN, BITNUM, ITER)\t\\\n+  for (bmp_iter_and_init (&(ITER), (BITMAP1), (BITMAP2), (MIN), \t\\\n+\t\t\t  &(BITNUM));\t\t\t\t\t\\\n+       bmp_iter_and (&(ITER), &(BITNUM));\t\t\t\t\\\n+       bmp_iter_next (&(ITER), &(BITNUM)))\n+\n+/* Loop over all the bits set in BITMAP1 & ~BITMAP2, starting with MIN\n+   and setting BITNUM to the bit number.  ITER is a bitmap iterator.\n+   BITNUM should be treated as a read-only variable as it contains\n+   loop state.  */\n+\n+#define EXECUTE_IF_AND_COMPL_IN_BITMAP(BITMAP1, BITMAP2, MIN, BITNUM, ITER) \\\n+  for (bmp_iter_and_compl_init (&(ITER), (BITMAP1), (BITMAP2), (MIN),\t\\\n+\t\t\t\t&(BITNUM)); \t\t\t\t\\\n+       bmp_iter_and_compl (&(ITER), &(BITNUM));\t\t\t\t\\\n+       bmp_iter_next (&(ITER), &(BITNUM)))\n \n #endif /* GCC_BITMAP_H */"}]}