{"sha": "c505fc0613bc714188de804f9699ff7810418f7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUwNWZjMDYxM2JjNzE0MTg4ZGU4MDRmOTY5OWZmNzgxMDQxOGY3YQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-05-14T15:48:11Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-05-14T15:48:11Z"}, "message": "re PR rtl-optimization/22563 (performance regression for gcc newer than 2.95)\n\n\n\tPR rtl-optimization/22563\n\t* expmed.c (store_fixed_bit_field): When using AND and IOR to store\n\ta fixed width bitfield, always force the intermediates into psuedos.\n\nFrom-SVN: r113762", "tree": {"sha": "b1225cf5a03bab747be06a9edf60ab079fbc4eed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1225cf5a03bab747be06a9edf60ab079fbc4eed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c505fc0613bc714188de804f9699ff7810418f7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c505fc0613bc714188de804f9699ff7810418f7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c505fc0613bc714188de804f9699ff7810418f7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c505fc0613bc714188de804f9699ff7810418f7a/comments", "author": null, "committer": null, "parents": [{"sha": "f9a4b91e4ba0e555780e391f3430d8a0c2c1e963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9a4b91e4ba0e555780e391f3430d8a0c2c1e963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9a4b91e4ba0e555780e391f3430d8a0c2c1e963"}], "stats": {"total": 33, "additions": 19, "deletions": 14}, "files": [{"sha": "1c6df66f205ea2d0734d9e080d04d33f2629a629", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c505fc0613bc714188de804f9699ff7810418f7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c505fc0613bc714188de804f9699ff7810418f7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c505fc0613bc714188de804f9699ff7810418f7a", "patch": "@@ -1,3 +1,9 @@\n+2006-05-14  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR rtl-optimization/22563\n+\t* expmed.c (store_fixed_bit_field): When using AND and IOR to store\n+\ta fixed width bitfield, always force the intermediates into psuedos.\n+\n 2006-05-14  Bernhard Fischer  <aldot@gcc.gnu.org>\n \n \tPR 27501"}, {"sha": "56c0d24bd66fee2bef217c9ee512b447659ef9ad", "filename": "gcc/expmed.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c505fc0613bc714188de804f9699ff7810418f7a/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c505fc0613bc714188de804f9699ff7810418f7a/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c505fc0613bc714188de804f9699ff7810418f7a", "patch": "@@ -793,7 +793,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n {\n   enum machine_mode mode;\n   unsigned int total_bits = BITS_PER_WORD;\n-  rtx subtarget, temp;\n+  rtx temp;\n   int all_zero = 0;\n   int all_one = 0;\n \n@@ -919,29 +919,28 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n \n   /* Now clear the chosen bits in OP0,\n      except that if VALUE is -1 we need not bother.  */\n+  /* We keep the intermediates in registers to allow CSE to combine\n+     consecutive bitfield assignments.  */\n \n-  subtarget = op0;\n+  temp = force_reg (mode, op0);\n \n   if (! all_one)\n     {\n-      /* Don't try and keep the intermediate in memory, if we need to\n-\t perform both a bit-wise AND and a bit-wise IOR (except when\n-\t we're optimizing for size).  */\n-      if (MEM_P (subtarget) && !all_zero && !optimize_size)\n-\tsubtarget = force_reg (mode, subtarget);\n-      temp = expand_binop (mode, and_optab, subtarget,\n+      temp = expand_binop (mode, and_optab, temp,\n \t\t\t   mask_rtx (mode, bitpos, bitsize, 1),\n-\t\t\t   subtarget, 1, OPTAB_LIB_WIDEN);\n-      subtarget = temp;\n+\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+      temp = force_reg (mode, temp);\n     }\n-  else\n-    temp = op0;\n \n   /* Now logical-or VALUE into OP0, unless it is zero.  */\n \n   if (! all_zero)\n-    temp = expand_binop (mode, ior_optab, temp, value,\n-\t\t\t subtarget, 1, OPTAB_LIB_WIDEN);\n+    {\n+      temp = expand_binop (mode, ior_optab, temp, value,\n+\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+      temp = force_reg (mode, temp);\n+    }\n+\n   if (op0 != temp)\n     emit_move_insn (op0, temp);\n }"}]}