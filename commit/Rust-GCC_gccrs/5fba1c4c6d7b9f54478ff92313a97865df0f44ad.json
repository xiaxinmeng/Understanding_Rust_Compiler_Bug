{"sha": "5fba1c4c6d7b9f54478ff92313a97865df0f44ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZiYTFjNGM2ZDdiOWY1NDQ3OGZmOTIzMTNhOTc4NjVkZjBmNDRhZA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2008-05-18T17:00:00Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2008-05-18T17:00:00Z"}, "message": "revert: i386.c (ix86_secondary_reload): New static function.\n\nRevert:\n2008-05-18  Uros Bizjak  <ubizjak@gmail.com>\n\n        * config/i386/i386.c (ix86_secondary_reload): New static function.\n        (TARGET_SECONDARY_RELOAD): New define.\n        * config/i386/i386.h (SECONDARY_OUTPUT_RELOAD_CLASS): Remove.\n        * config/i386/i386.md (reload_outqi): Remove.\n\nFrom-SVN: r135505", "tree": {"sha": "381fdb0f09133de58e431567d90a264bbf091c17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/381fdb0f09133de58e431567d90a264bbf091c17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fba1c4c6d7b9f54478ff92313a97865df0f44ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fba1c4c6d7b9f54478ff92313a97865df0f44ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fba1c4c6d7b9f54478ff92313a97865df0f44ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fba1c4c6d7b9f54478ff92313a97865df0f44ad/comments", "author": null, "committer": null, "parents": [{"sha": "a86907b25ec3125480871e316dcc62c6bcb481ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a86907b25ec3125480871e316dcc62c6bcb481ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a86907b25ec3125480871e316dcc62c6bcb481ca"}], "stats": {"total": 66, "additions": 28, "deletions": 38}, "files": [{"sha": "17a2632b75cf30ab86688cb18b131ca992bc0f9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fba1c4c6d7b9f54478ff92313a97865df0f44ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fba1c4c6d7b9f54478ff92313a97865df0f44ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fba1c4c6d7b9f54478ff92313a97865df0f44ad", "patch": "@@ -3,13 +3,6 @@\n \t* tree-cfg.c (verify_gimple_expr): Allow conversions from\n \tpointers to sizetype and vice versa.\n \n-2008-05-18  Uros Bizjak  <ubizjak@gmail.com>\n-\n-\t* config/i386/i386.c (ix86_secondary_reload): New static function.\n-\t(TARGET_SECONDARY_RELOAD): New define.\n-\t* config/i386/i386.h (SECONDARY_OUTPUT_RELOAD_CLASS): Remove.\n-\t* config/i386/i386.md (reload_outqi): Remove.\n-\n 2008-05-18 Xinliang David Li   <davidxl@google.com>\n \n \t* gcc/tree-ssa-dce.c: Coding style fix."}, {"sha": "af1e6c60b55ea8c058fb6f125d7c6ed7e919cc2b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fba1c4c6d7b9f54478ff92313a97865df0f44ad/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fba1c4c6d7b9f54478ff92313a97865df0f44ad/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5fba1c4c6d7b9f54478ff92313a97865df0f44ad", "patch": "@@ -22023,34 +22023,6 @@ ix86_preferred_output_reload_class (rtx x, enum reg_class regclass)\n   return regclass;\n }\n \n-static enum reg_class\n-ix86_secondary_reload (bool in_p, rtx x, enum reg_class class,\n-\t\t       enum machine_mode mode,\n-\t\t       secondary_reload_info *sri ATTRIBUTE_UNUSED)\n-{\n-  /* QImode spills from non-QI registers require\n-     intermediate register on 32bit targets.  */\n-  if (!in_p && mode == QImode && class == NON_Q_REGS\n-      && !TARGET_64BIT)\n-    {\n-      int regno;\n-\n-      if (REG_P (x))\n-\tregno = REGNO (x);\n-      else\n-\tregno = -1;\n-\n-      if (regno >= FIRST_PSEUDO_REGISTER || GET_CODE (x) == SUBREG)\n-\tregno = true_regnum (x);\n-\n-      /* Return Q_REGS if the operand is in memory.  */\n-      if (regno == -1)\n-\treturn Q_REGS;\n-    }\n-\n-  return NO_REGS;\n-}\n-\n /* If we are copying between general and FP registers, we need a memory\n    location. The same is true for SSE and MMX registers.\n \n@@ -25906,9 +25878,6 @@ x86_builtin_vectorization_cost (bool runtime_test)\n #undef TARGET_FUNCTION_VALUE\n #define TARGET_FUNCTION_VALUE ix86_function_value\n \n-#undef TARGET_SECONDARY_RELOAD\n-#define TARGET_SECONDARY_RELOAD ix86_secondary_reload\n-\n #undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST x86_builtin_vectorization_cost\n "}, {"sha": "8516e53b41db5b692a8cfa92d380c730f9c641f0", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fba1c4c6d7b9f54478ff92313a97865df0f44ad/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fba1c4c6d7b9f54478ff92313a97865df0f44ad/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=5fba1c4c6d7b9f54478ff92313a97865df0f44ad", "patch": "@@ -1524,6 +1524,15 @@ enum reg_class\n    ? mode_for_size (32, GET_MODE_CLASS (MODE), 0)\t\t\\\n    : MODE)\n \n+/* QImode spills from non-QI registers need a scratch.  This does not\n+   happen often -- the only example so far requires an uninitialized\n+   pseudo.  */\n+\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, OUT)\t\t\t\\\n+  (((CLASS) == GENERAL_REGS || (CLASS) == LEGACY_REGS\t\t\t\\\n+    || (CLASS) == INDEX_REGS) && !TARGET_64BIT && (MODE) == QImode\t\\\n+   ? Q_REGS : NO_REGS)\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n /* On the 80386, this is the size of MODE in words,"}, {"sha": "145c373ff7522846fa08942407061211ce5747dd", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fba1c4c6d7b9f54478ff92313a97865df0f44ad/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fba1c4c6d7b9f54478ff92313a97865df0f44ad/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=5fba1c4c6d7b9f54478ff92313a97865df0f44ad", "patch": "@@ -1810,6 +1810,25 @@\n \t   ]\n \t   (const_string \"QI\")))])\n \n+(define_expand \"reload_outqi\"\n+  [(parallel [(match_operand:QI 0 \"\" \"=m\")\n+              (match_operand:QI 1 \"register_operand\" \"r\")\n+              (match_operand:QI 2 \"register_operand\" \"=&q\")])]\n+  \"\"\n+{\n+  rtx op0, op1, op2;\n+  op0 = operands[0]; op1 = operands[1]; op2 = operands[2];\n+\n+  gcc_assert (!reg_overlap_mentioned_p (op2, op0));\n+  if (! q_regs_operand (op1, QImode))\n+    {\n+      emit_insn (gen_movqi (op2, op1));\n+      op1 = op2;\n+    }\n+  emit_insn (gen_movqi (op0, op1));\n+  DONE;\n+})\n+\n (define_insn \"*swapqi_1\"\n   [(set (match_operand:QI 0 \"register_operand\" \"+r\")\n \t(match_operand:QI 1 \"register_operand\" \"+r\"))"}]}