{"sha": "441d04c6db6e5b13c0d9eadf7decc1e49304174a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQxZDA0YzZkYjZlNWIxM2MwZDllYWRmN2RlY2MxZTQ5MzA0MTc0YQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-14T22:57:31Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-14T22:57:31Z"}, "message": "h8300-protos.h: New file.\n\n        * h8300-protos.h: New file.\n\n        * h8300.c: Include tm_p.h.  Add static prototypes.  Fix compile\n        time warnings.\n\n        * h8300.h: Move prototypes to h8300-protos.h.  Fix compile time\n        warnings.\n\n        * h8300.md: Likewise.\n\nFrom-SVN: r31426", "tree": {"sha": "d21e98a1f3dae1d6df9a637e4dc488b46bd38a31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d21e98a1f3dae1d6df9a637e4dc488b46bd38a31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/441d04c6db6e5b13c0d9eadf7decc1e49304174a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/441d04c6db6e5b13c0d9eadf7decc1e49304174a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/441d04c6db6e5b13c0d9eadf7decc1e49304174a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/441d04c6db6e5b13c0d9eadf7decc1e49304174a/comments", "author": null, "committer": null, "parents": [{"sha": "05b13f5974e02a52465591b4b336bc1573d23058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05b13f5974e02a52465591b4b336bc1573d23058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05b13f5974e02a52465591b4b336bc1573d23058"}], "stats": {"total": 264, "additions": 178, "deletions": 86}, "files": [{"sha": "3c9310619570945a3ce4561b9a25357c00d0dd2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/441d04c6db6e5b13c0d9eadf7decc1e49304174a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/441d04c6db6e5b13c0d9eadf7decc1e49304174a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=441d04c6db6e5b13c0d9eadf7decc1e49304174a", "patch": "@@ -1,3 +1,15 @@\n+2000-01-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* h8300-protos.h: New file.\n+\n+\t* h8300.c: Include tm_p.h.  Add static prototypes.  Fix compile\n+\ttime warnings.\n+\t\n+\t* h8300.h: Move prototypes to h8300-protos.h.  Fix compile time\n+\twarnings.\n+\t\n+\t* h8300.md: Likewise.\n+\n 2000-01-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* varasm.c (asm_output_bss): Mark parameters with ATTRIBUTE_UNUSED."}, {"sha": "0f4bf78e5d85128fc28c3e9dd7be5592f8c33a8a", "filename": "gcc/config/h8300/h8300-protos.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/441d04c6db6e5b13c0d9eadf7decc1e49304174a/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/441d04c6db6e5b13c0d9eadf7decc1e49304174a/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=441d04c6db6e5b13c0d9eadf7decc1e49304174a", "patch": "@@ -0,0 +1,75 @@\n+/* Definitions of target machine for GNU compiler. \n+   Hitachi H8/300 version generating coff \n+   Copyright (C) 2000 Free SoftwareFoundation, Inc.\n+   Contributed by Steve Chamberlain (sac@cygnus.com),\n+   Jim Wilson (wilson@cygnus.com), and Doug Evans (dje@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Declarations for functions used in insn-output.c.  */\n+#ifdef RTX_CODE\n+extern const char *emit_a_shift PARAMS ((rtx, rtx *));\n+extern const char *output_adds_subs PARAMS ((rtx *));\n+extern const char * output_simode_bld PARAMS ((int, int, rtx[]));\n+extern void print_operand_address PARAMS ((FILE *, rtx));\n+extern const char *byte_reg PARAMS ((rtx, int));\n+extern int const_costs PARAMS ((rtx, enum rtx_code));\n+extern void print_operand PARAMS ((FILE *, rtx, int));\n+extern void final_prescan_insn PARAMS ((rtx, rtx *, int));\n+extern int do_movsi PARAMS ((rtx[]));\n+extern void notice_update_cc PARAMS ((rtx, rtx));\n+extern int expand_a_shift PARAMS ((enum machine_mode, int, rtx[]));\n+extern int fix_bit_operand PARAMS ((rtx *, int, enum rtx_code));\n+extern int h8300_adjust_insn_length PARAMS ((rtx, int));\n+\n+extern int general_operand_src PARAMS ((rtx, enum machine_mode));\n+extern int general_operand_dst PARAMS ((rtx, enum machine_mode));\n+extern int o_operand PARAMS ((rtx, enum machine_mode));\n+extern int p_operand PARAMS ((rtx, enum machine_mode));\n+extern int call_insn_operand PARAMS ((rtx, enum machine_mode));\n+extern int adds_subs_operand PARAMS ((rtx, enum machine_mode));\n+extern int one_insn_adds_subs_operand PARAMS ((rtx, enum machine_mode));\n+extern int small_call_insn_operand PARAMS ((rtx, enum machine_mode));\n+extern int jump_address_operand PARAMS ((rtx, enum machine_mode));\n+extern int bit_operand PARAMS ((rtx, enum machine_mode));\n+extern int bit_memory_operand PARAMS ((rtx, enum machine_mode));\n+extern int eq_operator PARAMS ((rtx, enum machine_mode));\n+extern int bit_operator PARAMS ((rtx, enum machine_mode));\n+extern int nshift_operator PARAMS ((rtx, enum machine_mode));\n+#endif /* RTX_CODE */\n+\n+#ifdef TREE_CODE\n+extern struct rtx_def *function_arg PARAMS ((CUMULATIVE_ARGS *,\n+\t\t\t\t\t     enum machine_mode, tree, int));\n+extern int h8300_valid_machine_decl_attribute PARAMS ((tree, tree, tree,\n+\t\t\t\t\t\t       tree));\n+extern int h8300_funcvec_function_p PARAMS ((tree));\n+extern int h8300_eightbit_data_p PARAMS ((tree));\n+extern int h8300_tiny_data_p PARAMS ((tree));\n+extern void h8300_encode_label PARAMS ((tree));\n+#endif /* TREE_CODE */\n+\n+extern int handle_pragma PARAMS ((int (*)(void), void (*)(int), const char *));\n+extern void h8300_init_once PARAMS ((void));\n+extern void function_prologue PARAMS ((FILE *, int));\n+extern void function_epilogue PARAMS ((FILE *, int));\n+extern void asm_file_start PARAMS ((FILE *));\n+extern void asm_file_end PARAMS ((FILE *));\n+extern int ok_for_bclr PARAMS ((int));\n+extern int small_power_of_two PARAMS ((int));\n+extern int initial_offset PARAMS ((int, int));"}, {"sha": "132a69492113fa5211774efef8614e50922c31db", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 73, "deletions": 62, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/441d04c6db6e5b13c0d9eadf7decc1e49304174a/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/441d04c6db6e5b13c0d9eadf7decc1e49304174a/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=441d04c6db6e5b13c0d9eadf7decc1e49304174a", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Hitachi H8/300.\n-   Copyright (C) 1992, 93, 94, 95, 96, 97, 1998, 1999 Free Software\n+   Copyright (C) 1992, 93-99, 2000 Free Software\n    Foundation, Inc. \n    Contributed by Steve Chamberlain (sac@cygnus.com),\n    Jim Wilson (wilson@cygnus.com), and Doug Evans (dje@cygnus.com).\n@@ -38,13 +38,15 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"function.h\"\n #include \"obstack.h\"\n+#include \"toplev.h\"\n+#include \"tm_p.h\"\n \n /* Forward declarations.  */\n-void print_operand_address ();\n-\n static int h8300_interrupt_function_p PROTO ((tree));\n static int h8300_monitor_function_p PROTO ((tree));\n static int h8300_os_task_function_p PROTO ((tree));\n+static void dosize PROTO ((FILE *, const char *, unsigned int));\n+static const char *cond_string PROTO ((enum rtx_code));\n \n /* CPU_TYPE, says what cpu we're compiling for.  */\n int cpu_type;\n@@ -64,29 +66,26 @@ int monitor;\n /* True if a #pragma saveall has been seen for the current function.  */\n int pragma_saveall;\n \n-static char *names_big[] =\n+static const char *const names_big[] =\n {\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\"};\n \n-static char *names_extended[] =\n+static const char *const names_extended[] =\n {\"er0\", \"er1\", \"er2\", \"er3\", \"er4\", \"er5\", \"er6\", \"er7\"};\n \n-static char *names_upper_extended[] =\n+static const char *const names_upper_extended[] =\n {\"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\", \"e6\", \"e7\"};\n \n /* Points to one of the above.  */\n /* ??? The above could be put in an array indexed by CPU_TYPE.  */\n-char **h8_reg_names;\n+const char * const *h8_reg_names;\n \n /* Various operations needed by the following, indexed by CPU_TYPE.  */\n \n-static char *h8_push_ops[2] =\n-{\"push\", \"push.l\"};\n-static char *h8_pop_ops[2] =\n-{\"pop\", \"pop.l\"};\n-static char *h8_mov_ops[2] =\n-{\"mov.w\", \"mov.l\"};\n+static const char *const h8_push_ops[2] = {\"push\", \"push.l\"};\n+static const char *const h8_pop_ops[2] = {\"pop\", \"pop.l\"};\n+static const char *const h8_mov_ops[2] = {\"mov.w\", \"mov.l\"};\n \n-char *h8_push_op, *h8_pop_op, *h8_mov_op;\n+const char *h8_push_op, *h8_pop_op, *h8_mov_op;\n \n /* Initialize various cpu specific globals at start up.  */\n \n@@ -109,12 +108,12 @@ h8300_init_once ()\n   h8_mov_op = h8_mov_ops[cpu_type];\n }\n \n-char *\n+const char *\n byte_reg (x, b)\n      rtx x;\n      int b;\n {\n-  static char *names_small[] =\n+  static const char *const names_small[] =\n   {\"r0l\", \"r0h\", \"r1l\", \"r1h\", \"r2l\", \"r2h\", \"r3l\", \"r3h\",\n    \"r4l\", \"r4h\", \"r5l\", \"r5h\", \"r6l\", \"r6h\", \"r7l\", \"r7h\"};\n \n@@ -146,7 +145,7 @@ byte_reg (x, b)\n static void\n dosize (file, op, size)\n      FILE *file;\n-     char *op;\n+     const char *op;\n      unsigned int size;\n {\n   /* On the h8300h and h8300s, for sizes <= 8 bytes it is as good or\n@@ -238,7 +237,6 @@ function_prologue (file, size)\n      FILE *file;\n      int size;\n {\n-  register int mask = 0;\n   int fsize = (size + STACK_BOUNDARY / 8 - 1) & -STACK_BOUNDARY / 8;\n   int idx;\n \n@@ -382,8 +380,6 @@ function_epilogue (file, size)\n      FILE *file;\n      int size;\n {\n-  register int regno;\n-  register int mask = 0;\n   int fsize = (size + STACK_BOUNDARY / 8 - 1) & -STACK_BOUNDARY / 8;\n   int idx;\n   rtx insn = get_last_insn ();\n@@ -514,6 +510,7 @@ function_epilogue (file, size)\n \n /* Output assembly code for the start of the file.  */\n \n+void\n asm_file_start (file)\n      FILE *file;\n {\n@@ -612,7 +609,7 @@ general_operand_dst (op, mode)\n int\n o_operand (operand, mode)\n      rtx operand;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return (GET_CODE (operand) == CONST_INT\n \t  && CONST_OK_FOR_O (INTVAL (operand)));\n@@ -623,7 +620,7 @@ o_operand (operand, mode)\n int\n p_operand (operand, mode)\n      rtx operand;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return (GET_CODE (operand) == CONST_INT\n \t  && CONST_OK_FOR_P (INTVAL (operand)));\n@@ -634,7 +631,7 @@ p_operand (operand, mode)\n int\n call_insn_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) == MEM)\n     {\n@@ -650,7 +647,7 @@ call_insn_operand (op, mode)\n int\n adds_subs_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n@@ -676,7 +673,7 @@ adds_subs_operand (op, mode)\n int\n one_insn_adds_subs_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   int val = INTVAL (op);\n \n@@ -688,7 +685,7 @@ one_insn_adds_subs_operand (op, mode)\n   return 0;\n }\n \n-char *\n+const char *\n output_adds_subs (operands)\n      rtx *operands;\n {\n@@ -760,7 +757,7 @@ output_adds_subs (operands)\n int\n small_call_insn_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) == MEM)\n     {\n@@ -840,7 +837,7 @@ bit_operand (op, mode)\n int\n bit_memory_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return (GET_CODE (op) == MEM\n \t  && EXTRA_CONSTRAINT (op, 'U'));\n@@ -851,7 +848,7 @@ bit_memory_operand (op, mode)\n int\n eq_operator (x, mode)\n      rtx x;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return (GET_CODE (x) == EQ || GET_CODE (x) == NE);\n }\n@@ -868,9 +865,9 @@ eq_operator (x, mode)\n \n int\n handle_pragma (p_getc, p_ungetc, pname)\n-     int (*  p_getc) PROTO ((void));\n-     void (* p_ungetc) PROTO ((int));\n-     char * pname;\n+     int (* ATTRIBUTE_UNUSED p_getc) PROTO ((void));\n+     void (* ATTRIBUTE_UNUSED p_ungetc) PROTO ((int));\n+     const char *pname;\n {\n   int retval = 0;\n \n@@ -886,7 +883,7 @@ handle_pragma (p_getc, p_ungetc, pname)\n    the rtx to represent where it is passed.  CUM represents the state after\n    the last argument.  NAMED is not used.  */\n \n-static char *hand_list[] =\n+static const char *const hand_list[] =\n {\n   \"__main\",\n   \"__cmpsi2\",\n@@ -917,7 +914,7 @@ function_arg (cum, mode, type, named)\n      int named;\n {\n   rtx result = 0;\n-  char *fname;\n+  const char *fname;\n   int regpass = 0;\n \n   /* Never pass unnamed arguments in registers.  */\n@@ -932,7 +929,7 @@ function_arg (cum, mode, type, named)\n \n   if (cum->libcall)\n     {\n-      char **p;\n+      const char * const *p;\n \n       fname = XSTR (cum->libcall, 0);\n \n@@ -1064,7 +1061,7 @@ const_costs (r, c)\n \n /* Return assembly language string which identifies a comparison type.  */\n \n-static char *\n+static const char *\n cond_string (code)\n      enum rtx_code code;\n {\n@@ -1105,7 +1102,7 @@ print_operand (file, x, code)\n      int code;\n {\n   /* This is used for communication between the 'P' and 'U' codes.  */\n-  static char *last_p;\n+  static const char *last_p;\n \n   /* This is used for communication between codes V,W,Z and Y.  */\n   static int bitint;\n@@ -1243,6 +1240,8 @@ print_operand (file, x, code)\n \tcase AND:\n \t  fprintf (file, \"band\");\n \t  break;\n+\tdefault:\n+\t  break;\n \t}\n       break;\n     case 'c':\n@@ -1257,6 +1256,8 @@ print_operand (file, x, code)\n \tcase AND:\n \t  fprintf (file, \"biand\");\n \t  break;\n+\tdefault:\n+\t  break;\n \t}\n       break;\n     case 'd':\n@@ -1294,7 +1295,7 @@ print_operand (file, x, code)\n \t    REAL_VALUE_TYPE rv;\n \t    REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n \t    REAL_VALUE_TO_TARGET_SINGLE (rv, val);\n-\t    fprintf (file, \"#%d\", ((val >> 16) & 0xffff));\n+\t    fprintf (file, \"#%ld\", ((val >> 16) & 0xffff));\n \t    break;\n \t  }\n \tdefault:\n@@ -1324,7 +1325,7 @@ print_operand (file, x, code)\n \t    REAL_VALUE_TYPE rv;\n \t    REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n \t    REAL_VALUE_TO_TARGET_SINGLE (rv, val);\n-\t    fprintf (file, \"#%d\", (val & 0xffff));\n+\t    fprintf (file, \"#%ld\", (val & 0xffff));\n \t    break;\n \t  }\n \tdefault:\n@@ -1449,9 +1450,11 @@ print_operand (file, x, code)\n \t    REAL_VALUE_TYPE rv;\n \t    REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n \t    REAL_VALUE_TO_TARGET_SINGLE (rv, val);\n-\t    fprintf (file, \"#%d\", val);\n+\t    fprintf (file, \"#%ld\", val);\n \t    break;\n \t  }\n+\tdefault:\n+\t  break;\n \t}\n     }\n }\n@@ -1527,8 +1530,8 @@ print_operand_address (file, addr)\n \n void\n final_prescan_insn (insn, operand, num_operands)\n-     rtx insn, *operand;\n-     int num_operands;\n+     rtx insn, *operand ATTRIBUTE_UNUSED;\n+     int num_operands ATTRIBUTE_UNUSED;\n {\n   /* This holds the last insn address.  */\n   static int last_insn_address = 0;\n@@ -1576,6 +1579,7 @@ do_movsi (operands)\n \n int\n initial_offset (from, to)\n+     int from, to;\n {\n   int offset = 0;\n \n@@ -1603,7 +1607,7 @@ initial_offset (from, to)\n \n /* Update the condition code from the insn.  */\n \n-int\n+void\n notice_update_cc (body, insn)\n      rtx body;\n      rtx insn;\n@@ -1657,7 +1661,7 @@ notice_update_cc (body, insn)\n int\n bit_operator (x, mode)\n      rtx x;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -1838,7 +1842,7 @@ bit_operator (x, mode)\n int\n nshift_operator (x, mode)\n      rtx x;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   switch (GET_CODE (x))\n     {\n@@ -1918,7 +1922,7 @@ enum shift_mode\n \n struct shift_insn\n {\n-  char *assembler;\n+  const char *assembler;\n   int cc_valid;\n };\n \n@@ -2068,6 +2072,11 @@ static const char *const rotate_two[3][3] =\n     }\n };\n \n+static enum shift_alg get_shift_alg PARAMS ((enum attr_cpu, enum shift_type,\n+\t\t\t\t\t     enum machine_mode, int,\n+\t\t\t\t\t     const char **, const char **,\n+\t\t\t\t\t     int *));\n+\n /* Given CPU, MODE, SHIFT_TYPE, and shift count COUNT, determine the best\n    algorithm for doing the shift.  The assembler code is stored in ASSEMBLER.\n    We don't achieve maximum efficiency in all cases, but the hooks are here\n@@ -2332,7 +2341,7 @@ get_shift_alg (cpu, shift_type, mode, count, assembler_p,\n \t      return SHIFT_SPECIAL;\n \t    }\n \t}\n-      else if (!TARGET_H8300 && (count == 13 || count == 14)\n+      else if ((!TARGET_H8300 && (count == 13 || count == 14))\n \t       || count == 15)\n \t{\n \t  if (count == 15 && shift_type == SHIFT_ASHIFTRT)\n@@ -2586,16 +2595,15 @@ get_shift_alg (cpu, shift_type, mode, count, assembler_p,\n \n /* Emit the assembler code for doing shifts.  */\n \n-char *\n+const char *\n emit_a_shift (insn, operands)\n-     rtx insn;\n+     rtx insn ATTRIBUTE_UNUSED;\n      rtx *operands;\n {\n   static int loopend_lab;\n-  char *assembler;\n-  char *assembler2;\n+  const char *assembler;\n+  const char *assembler2;\n   int cc_valid;\n-  rtx inside = PATTERN (insn);\n   rtx shift = operands[3];\n   enum machine_mode mode = GET_MODE (shift);\n   enum rtx_code code = GET_CODE (shift);\n@@ -2690,8 +2698,8 @@ emit_a_shift (insn, operands)\n \t  {\n \t    int m = GET_MODE_BITSIZE (mode) - n;\n \t    int mask = (shift_type == SHIFT_ASHIFT\n-\t\t\t? ((1 << GET_MODE_BITSIZE (mode) - n) - 1) << n\n-\t\t\t: (1 << GET_MODE_BITSIZE (mode) - n) - 1);\n+\t\t\t? ((1 << (GET_MODE_BITSIZE (mode) - n)) - 1) << n\n+\t\t\t: (1 << (GET_MODE_BITSIZE (mode) - n)) - 1);\n \t    char insn_buf[200];\n \t    /* Not all possibilities of rotate are supported.  They shouldn't\n \t       be generated, but let's watch for 'em.  */\n@@ -2718,17 +2726,18 @@ emit_a_shift (insn, operands)\n \t\tswitch (mode)\n \t\t  {\n \t\t  case QImode:\n-\t\t    sprintf (insn_buf, \"and #%d,%%X0\",\n-\t\t\t     mask, n);\n+\t\t    sprintf (insn_buf, \"and #%d,%%X0\", mask);\n \t\t    cc_status.value1 = operands[0];\n \t\t    cc_status.flags |= CC_NO_CARRY;\n \t\t    break;\n \t\t  case HImode:\n \t\t    sprintf (insn_buf, \"and #%d,%%s0\\n\\tand #%d,%%t0\",\n-\t\t\t     mask & 255, mask >> 8, n);\n+\t\t\t     mask & 255, mask >> 8);\n \t\t    break;\n \t\t  case SImode:\n \t\t    abort ();\n+\t\t  default:\n+\t\t    break;\n \t\t  }\n \t      }\n \t    else\n@@ -2788,7 +2797,7 @@ emit_a_shift (insn, operands)\n int\n fix_bit_operand (operands, what, type)\n      rtx *operands;\n-     char what;\n+     int what;\n      enum rtx_code type;\n {\n   /* The bit_operand predicate accepts any memory during RTL generation, but\n@@ -2952,7 +2961,7 @@ h8300_tiny_data_p (decl)\n int\n h8300_valid_machine_decl_attribute (decl, attributes, attr, args)\n      tree decl;\n-     tree attributes;\n+     tree attributes ATTRIBUTE_UNUSED;\n      tree attr;\n      tree args;\n {\n@@ -2994,10 +3003,11 @@ h8300_valid_machine_decl_attribute (decl, attributes, attr, args)\n \n extern struct obstack *saveable_obstack;\n \n+void\n h8300_encode_label (decl)\n      tree decl;\n {\n-  char *str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n+  const char *str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n   int len = strlen (str);\n   char *newstr;\n \n@@ -3008,7 +3018,7 @@ h8300_encode_label (decl)\n   XSTR (XEXP (DECL_RTL (decl), 0), 0) = newstr;\n }\n \n-char *\n+const char *\n output_simode_bld (bild, log2, operands)\n      int bild;\n      int log2;\n@@ -3040,9 +3050,10 @@ output_simode_bld (bild, log2, operands)\n \n    We use this to get the lengths of various memory references correct.  */\n \n+int\n h8300_adjust_insn_length (insn, length)\n      rtx insn;\n-     int length;\n+     int length ATTRIBUTE_UNUSED;\n {\n   rtx pat;\n "}, {"sha": "359279724459df7142b42c91fcee6ae70816b0bd", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/441d04c6db6e5b13c0d9eadf7decc1e49304174a/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/441d04c6db6e5b13c0d9eadf7decc1e49304174a/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=441d04c6db6e5b13c0d9eadf7decc1e49304174a", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler. \n    Hitachi H8/300 version generating coff \n-   Copyright (C) 1992, 93-98, 1999 Free SoftwareFoundation, Inc.\n+   Copyright (C) 1992, 93-99, 2000 Free SoftwareFoundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com),\n    Jim Wilson (wilson@cygnus.com), and Doug Evans (dje@cygnus.com).\n \n@@ -30,8 +30,8 @@ extern int cpu_type;\n \n /* Various globals defined in h8300.c.  */\n \n-extern char *h8_push_op,*h8_pop_op,*h8_mov_op;\n-extern char **h8_reg_names;\n+extern const char *h8_push_op,*h8_pop_op,*h8_mov_op;\n+extern const char * const *h8_reg_names;\n \n /* Names to predefine in the preprocessor for this target machine.  */\n \n@@ -367,10 +367,10 @@ enum reg_class {\n    of length N_REG_CLASSES.  */\n \n #define REG_CLASS_CONTENTS  \t\t\t\\\n-{      0,\t\t/* No regs      */\t\\\n-   0x2ff,\t\t/* GENERAL_REGS */    \t\\\n-   0x100,\t\t/* MAC_REGS */    \t\\\n-   0x3ff,\t\t/* ALL_REGS \t*/\t\\\n+{      {0},\t\t/* No regs      */\t\\\n+   {0x2ff},\t\t/* GENERAL_REGS */    \t\\\n+   {0x100},\t\t/* MAC_REGS */    \t\\\n+   {0x3ff},\t\t/* ALL_REGS \t*/\t\\\n }\n \n /* The same information, inverted:\n@@ -631,7 +631,6 @@ struct cum_arg { int nbytes; struct rtx_def * libcall; };\n    case the first 3 arguments are passed in registers.\n    See function `function_arg'.  */\n \n-struct rtx_def *function_arg();\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (&CUM, MODE, TYPE, NAMED)\n \n@@ -826,11 +825,11 @@ struct rtx_def *function_arg();\n        && REG_OK_FOR_BASE_P (XEXP (OP, 0)))  \\\n    || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == SYMBOL_REF \\\n        && (TARGET_H8300S || SYMBOL_REF_FLAG (XEXP (OP, 0)))) \\\n-   || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == CONST \\\n-       && GET_CODE (XEXP (XEXP (OP, 0), 0)) == PLUS \\\n-       && GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 0)) == SYMBOL_REF \\\n-       && GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 1)) == CONST_INT) \\\n-       && (TARGET_H8300S || SYMBOL_REF_FLAG (XEXP (XEXP (OP, 0), 0))))\n+   || ((GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == CONST \\\n+        && GET_CODE (XEXP (XEXP (OP, 0), 0)) == PLUS \\\n+        && GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 0)) == SYMBOL_REF \\\n+        && GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 1)) == CONST_INT) \\\n+        && (TARGET_H8300S || SYMBOL_REF_FLAG (XEXP (XEXP (OP, 0), 0)))))\n  \n #define EXTRA_CONSTRAINT(OP, C) \\\n  ((C) == 'U' ? OK_FOR_U (OP) : 0)\n@@ -958,7 +957,6 @@ struct rtx_def *function_arg();\n /* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n    is a valid machine specific attribute for DECL.\n    The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n-extern int h8300_valid_machine_decl_attribute ();\n #define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n h8300_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n \n@@ -1019,7 +1017,7 @@ h8300_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n \f\n /* Control the assembler format that we output.  */\n \n-#define ASM_IDENTIFY_GCC /* nothing */\n+#define ASM_IDENTIFY_GCC(FILE) /* nothing */\n \n /* Output at beginning/end of assembler file.  */\n \n@@ -1384,7 +1382,6 @@ do { char dstr[30];\t\t\t\t\t\\\n    it should be pointing at the last character after the end of the pragma\n    (newline or end-of-file).  */\n #define HANDLE_PRAGMA(GETC, UNGETC, NAME) handle_pragma (GETC, UNGETC, NAME)\n-extern int handle_pragma ();\n \n #define FINAL_PRESCAN_INSN(insn, operand, nop) final_prescan_insn (insn, operand,nop)\n \n@@ -1418,9 +1415,3 @@ extern int handle_pragma ();\n \n #define MOVE_RATIO 3\n \n-/* Declarations for functions used in insn-output.c.  */\n-char *emit_a_shift ();\n-int h8300_funcvec_function_p ();\n-char *output_adds_subs ();\n-char * output_simode_bld ();\n-"}, {"sha": "a3015c659d6f977fb11ea5f2e9224beed7eef120", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/441d04c6db6e5b13c0d9eadf7decc1e49304174a/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/441d04c6db6e5b13c0d9eadf7decc1e49304174a/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=441d04c6db6e5b13c0d9eadf7decc1e49304174a", "patch": "@@ -1,5 +1,5 @@\n ;; GCC machine description for Hitachi H8/300\n-;; Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n+;; Copyright (C) 1992, 93-99, 2000 Free Software Foundation, Inc.\n \n ;;   Contributed by Steve Chamberlain (sac@cygnus.com),\n ;;   Jim Wilson (wilson@cygnus.com), and Doug Evans (dje@cygnus.com).\n@@ -335,6 +335,8 @@\n       return \\\"mov.w\t%f1,%T0\\;mov.w\t%e1,%T0\\\";\n     case 5:\n       return \\\"mov.w\t%T1,%e0\\;mov.w\t%T1,%f0\\\";\n+    default:\n+      abort();\n     }\n }\"\n   [(set_attr \"length\" \"4,4,8,8,4,4\")\n@@ -393,7 +395,8 @@\n       return \\\"mov.w\t%f1,%T0\\;mov.w\t%e1,%T0\\\";\n     case 5:\n       return \\\"mov.w\t%T1,%e0\\;mov.w\t%T1,%f0\\\";\n-\n+    default:\n+      abort();\n     }\n }\"\n   [(set_attr \"length\" \"4,4,8,8,4,4\")"}]}