{"sha": "a7285117b4d52ba2ee8adc9f2c123ee08c48937c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcyODUxMTdiNGQ1MmJhMmVlOGFkYzlmMmMxMjNlZTA4YzQ4OTM3Yw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2006-05-04T17:35:05Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2006-05-04T17:35:05Z"}, "message": "re PR libgcj/26861 (VirtualMachineError in interperter.)\n\n\tPR libgcj/26861:\n\t* interpret.cc (run) <insn_getfield>: Removed 0xffff check.\n\t<insn_putfield>: Likewise.\n\t(NULLCHECK): Define unconditionally.\n\t* link.cc (ensure_class_linked): Removed dead code.\n\nFrom-SVN: r113531", "tree": {"sha": "0f72903bf321b4c5bf8b857d5a52da113dcd0e60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f72903bf321b4c5bf8b857d5a52da113dcd0e60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7285117b4d52ba2ee8adc9f2c123ee08c48937c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7285117b4d52ba2ee8adc9f2c123ee08c48937c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7285117b4d52ba2ee8adc9f2c123ee08c48937c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7285117b4d52ba2ee8adc9f2c123ee08c48937c/comments", "author": null, "committer": null, "parents": [{"sha": "b149e89e77531944d9575190084dee9816391bc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b149e89e77531944d9575190084dee9816391bc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b149e89e77531944d9575190084dee9816391bc2"}], "stats": {"total": 42, "additions": 19, "deletions": 23}, "files": [{"sha": "161adfca458db5d6642de64613992a6892b5dc30", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7285117b4d52ba2ee8adc9f2c123ee08c48937c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7285117b4d52ba2ee8adc9f2c123ee08c48937c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a7285117b4d52ba2ee8adc9f2c123ee08c48937c", "patch": "@@ -1,3 +1,11 @@\n+2006-05-04  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/26861:\n+\t* interpret.cc (run) <insn_getfield>: Removed 0xffff check.\n+\t<insn_putfield>: Likewise.\n+\t(NULLCHECK): Define unconditionally.\n+\t* link.cc (ensure_class_linked): Removed dead code.\n+\n 2006-05-04  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/Class.h (JV_STATE_LOADING): Added comment."}, {"sha": "79121585bad2a9ca7ebaa49b7c369eb16e49938b", "filename": "libjava/interpret.cc", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7285117b4d52ba2ee8adc9f2c123ee08c48937c/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7285117b4d52ba2ee8adc9f2c123ee08c48937c/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=a7285117b4d52ba2ee8adc9f2c123ee08c48937c", "patch": "@@ -25,7 +25,6 @@ details.  */\n #include <java/lang/StringBuffer.h>\n #include <java/lang/Class.h>\n #include <java/lang/reflect/Modifier.h>\n-#include <java/lang/VirtualMachineError.h>\n #include <java/lang/InternalError.h>\n #include <java/lang/NullPointerException.h>\n #include <java/lang/ArithmeticException.h>\n@@ -222,12 +221,20 @@ static jint get4(unsigned char* loc) {\n \n #define SAVE_PC() frame_desc.pc = pc\n \n+// We used to define this conditionally, depending on HANDLE_SEGV.\n+// However, that runs into a problem if a chunk in low memory is\n+// mapped and we try to look at a field near the end of a large\n+// object.  See PR 26858 for details.  It is, most likely, relatively\n+// inexpensive to simply do this check always.\n+#define NULLCHECK(X) \\\n+  do { SAVE_PC(); if ((X)==NULL) throw_null_pointer_exception (); } while (0)\n+\n+// Note that we can still conditionally define NULLARRAYCHECK, since\n+// we know that all uses of an array will first reference the length\n+// field, which is first -- and thus will trigger a SEGV.\n #ifdef HANDLE_SEGV\n-#define NULLCHECK(X) SAVE_PC()\n #define NULLARRAYCHECK(X) SAVE_PC()\n #else\n-#define NULLCHECK(X) \\\n-  do { SAVE_PC(); if ((X)==NULL) throw_null_pointer_exception (); } while (0)\n #define NULLARRAYCHECK(X) \\\n   do { SAVE_PC(); if ((X)==NULL) { throw_null_pointer_exception (); } } while (0)\n #endif\n@@ -2542,8 +2549,6 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \n \tjclass type = field->type;\n \tjint field_offset = field->u.boffset;\n-\tif (field_offset > 0xffff)\n-\t  throw new java::lang::VirtualMachineError;\n \n \tjobject obj   = POPA();\n \tNULLCHECK(obj);\n@@ -2746,8 +2751,6 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n \t    (JvNewStringLatin1 (\"field is static\"));\n \n \tjint field_offset = field->u.boffset;\n-\tif (field_offset > 0xffff)\n-\t  throw new java::lang::VirtualMachineError;\n \n \tvoid *newinsn = NULL;\n \tif (type->isPrimitive ())"}, {"sha": "6c2815168953dfe8a28935e8fae4bed5674a9629", "filename": "libjava/link.cc", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7285117b4d52ba2ee8adc9f2c123ee08c48937c/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7285117b4d52ba2ee8adc9f2c123ee08c48937c/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=a7285117b4d52ba2ee8adc9f2c123ee08c48937c", "patch": "@@ -1629,21 +1629,6 @@ _Jv_Linker::ensure_class_linked (jclass klass)\n \t    }\n \t}\n \n-#if 0  // Should be redundant now\n-      // If superclass looks like a constant pool entry,\n-      // resolve it now.\n-      if ((uaddr) klass->superclass < (uaddr) pool->size)\n-\tklass->superclass = pool->data[(uaddr) klass->superclass].clazz;\n-\n-      // Likewise for interfaces.\n-      for (int i = 0; i < klass->interface_count; i++)\n-\t{\n-\t  if ((uaddr) klass->interfaces[i] < (uaddr) pool->size)\n-\t    klass->interfaces[i]\n-\t      = pool->data[(uaddr) klass->interfaces[i]].clazz;\n-\t}\n-#endif\n-\n       // Resolve the remaining constant pool entries.\n       for (int index = 1; index < pool->size; ++index)\n \t{"}]}