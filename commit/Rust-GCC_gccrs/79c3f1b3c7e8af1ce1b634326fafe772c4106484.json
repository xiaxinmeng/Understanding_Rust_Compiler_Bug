{"sha": "79c3f1b3c7e8af1ce1b634326fafe772c4106484", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzljM2YxYjNjN2U4YWYxY2UxYjYzNDMyNmZhZmU3NzJjNDEwNjQ4NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:42:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:42:32Z"}, "message": "poly_int: expand_assignment\n\nThis patch makes the CONCAT handing in expand_assignment cope with\npolynomial mode sizes.  The mode of the CONCAT must be complex,\nso we can base the tests on the sizes of the real and imaginary\ncomponents.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* expr.c (expand_assignment): Cope with polynomial mode sizes\n\twhen assigning to a CONCAT.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256199", "tree": {"sha": "099d90cf665f2b0f26804d0777367f1ab0feabec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/099d90cf665f2b0f26804d0777367f1ab0feabec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79c3f1b3c7e8af1ce1b634326fafe772c4106484", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c3f1b3c7e8af1ce1b634326fafe772c4106484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79c3f1b3c7e8af1ce1b634326fafe772c4106484", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c3f1b3c7e8af1ce1b634326fafe772c4106484/comments", "author": null, "committer": null, "parents": [{"sha": "bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb94ec7613a4fd30c278b236eb8783d985a1b6ee"}], "stats": {"total": 26, "additions": 18, "deletions": 8}, "files": [{"sha": "eeb0b6b70a4ed90571ecd36ed70a65c9b635850c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c3f1b3c7e8af1ce1b634326fafe772c4106484/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c3f1b3c7e8af1ce1b634326fafe772c4106484/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79c3f1b3c7e8af1ce1b634326fafe772c4106484", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* expr.c (expand_assignment): Cope with polynomial mode sizes\n+\twhen assigning to a CONCAT.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "8317d297fac1aabf27ffc838b56572d235b1820a", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c3f1b3c7e8af1ce1b634326fafe772c4106484/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c3f1b3c7e8af1ce1b634326fafe772c4106484/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=79c3f1b3c7e8af1ce1b634326fafe772c4106484", "patch": "@@ -5131,25 +5131,28 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       /* Handle expand_expr of a complex value returning a CONCAT.  */\n       else if (GET_CODE (to_rtx) == CONCAT)\n \t{\n-\t  unsigned short mode_bitsize = GET_MODE_BITSIZE (GET_MODE (to_rtx));\n+\t  machine_mode to_mode = GET_MODE (to_rtx);\n+\t  gcc_checking_assert (COMPLEX_MODE_P (to_mode));\n+\t  poly_int64 mode_bitsize = GET_MODE_BITSIZE (to_mode);\n+\t  unsigned short inner_bitsize = GET_MODE_UNIT_BITSIZE (to_mode);\n \t  if (TYPE_MODE (TREE_TYPE (from)) == GET_MODE (to_rtx)\n \t      && COMPLEX_MODE_P (GET_MODE (to_rtx))\n \t      && known_eq (bitpos, 0)\n \t      && known_eq (bitsize, mode_bitsize))\n \t    result = store_expr (from, to_rtx, false, nontemporal, reversep);\n-\t  else if (known_eq (bitsize, mode_bitsize / 2)\n+\t  else if (known_eq (bitsize, inner_bitsize)\n \t\t   && (known_eq (bitpos, 0)\n-\t\t       || known_eq (bitpos, mode_bitsize / 2)))\n+\t\t       || known_eq (bitpos, inner_bitsize)))\n \t    result = store_expr (from, XEXP (to_rtx, maybe_ne (bitpos, 0)),\n \t\t\t\t false, nontemporal, reversep);\n-\t  else if (known_le (bitpos + bitsize, mode_bitsize / 2))\n+\t  else if (known_le (bitpos + bitsize, inner_bitsize))\n \t    result = store_field (XEXP (to_rtx, 0), bitsize, bitpos,\n \t\t\t\t  bitregion_start, bitregion_end,\n \t\t\t\t  mode1, from, get_alias_set (to),\n \t\t\t\t  nontemporal, reversep);\n-\t  else if (known_ge (bitpos, mode_bitsize / 2))\n+\t  else if (known_ge (bitpos, inner_bitsize))\n \t    result = store_field (XEXP (to_rtx, 1), bitsize,\n-\t\t\t\t  bitpos - mode_bitsize / 2,\n+\t\t\t\t  bitpos - inner_bitsize,\n \t\t\t\t  bitregion_start, bitregion_end,\n \t\t\t\t  mode1, from, get_alias_set (to),\n \t\t\t\t  nontemporal, reversep);\n@@ -5158,7 +5161,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t      result = expand_normal (from);\n \t      if (GET_CODE (result) == CONCAT)\n \t\t{\n-\t\t  machine_mode to_mode = GET_MODE_INNER (GET_MODE (to_rtx));\n+\t\t  to_mode = GET_MODE_INNER (to_mode);\n \t\t  machine_mode from_mode = GET_MODE_INNER (GET_MODE (result));\n \t\t  rtx from_real\n \t\t    = simplify_gen_subreg (to_mode, XEXP (result, 0),\n@@ -5174,7 +5177,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t      else\n \t\t{\n \t\t  rtx from_rtx\n-\t\t    = simplify_gen_subreg (GET_MODE (to_rtx), result,\n+\t\t    = simplify_gen_subreg (to_mode, result,\n \t\t\t\t\t   TYPE_MODE (TREE_TYPE (from)), 0);\n \t\t  if (from_rtx)\n \t\t    {"}]}