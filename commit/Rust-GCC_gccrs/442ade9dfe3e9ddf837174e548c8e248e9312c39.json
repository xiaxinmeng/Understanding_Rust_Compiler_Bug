{"sha": "442ade9dfe3e9ddf837174e548c8e248e9312c39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQyYWRlOWRmZTNlOWRkZjgzNzE3NGU1NDhjOGUyNDhlOTMxMmMzOQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-08-14T08:40:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:40:45Z"}, "message": "sem_attr.ads, [...] (Analyze_Attribute, case Value): For enumeration type, mark all literals as referenced.\n\n2007-08-14  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.ads, sem_attr.adb (Analyze_Attribute, case Value): For\n\tenumeration type, mark all literals as referenced.\n\t(Eval_Attribute, case 'Image): If the argument is an enumeration\n\tliteral and names are available, constant-fold but mark nevertheless as\n\tnon-static.\n\tClean up function names.\n\t(Name_Modifies_Prefix): Rename to Name_Implies_Lvalue_Prefix. Clarify\n\tcomment.\n\t(Requires_Simple_Name_Prefix): Removed.\n\nFrom-SVN: r127425", "tree": {"sha": "778e85a418abd06355401c4f840c91da4be82e94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/778e85a418abd06355401c4f840c91da4be82e94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/442ade9dfe3e9ddf837174e548c8e248e9312c39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442ade9dfe3e9ddf837174e548c8e248e9312c39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/442ade9dfe3e9ddf837174e548c8e248e9312c39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442ade9dfe3e9ddf837174e548c8e248e9312c39/comments", "author": null, "committer": null, "parents": [{"sha": "852ab9d007807547a8a4ae456095e975dfe7a5c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852ab9d007807547a8a4ae456095e975dfe7a5c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/852ab9d007807547a8a4ae456095e975dfe7a5c6"}], "stats": {"total": 361, "additions": 183, "deletions": 178}, "files": [{"sha": "a669e26aeef602d36211aaa9086e90aa0ade2305", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 173, "deletions": 166, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442ade9dfe3e9ddf837174e548c8e248e9312c39/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442ade9dfe3e9ddf837174e548c8e248e9312c39/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=442ade9dfe3e9ddf837174e548c8e248e9312c39", "patch": "@@ -27,6 +27,7 @@\n with Ada.Characters.Latin_1; use Ada.Characters.Latin_1;\n \n with Atree;    use Atree;\n+with Casing;   use Casing;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n@@ -136,28 +137,19 @@ package body Sem_Attr is\n       Attribute_Wide_Wide_Width   => True,\n       others                      => False);\n \n-   --  The following array contains all attributes that cause a modification\n-   --  of their prefixes. In a certain sense, the prefix may be considered as\n-   --  an lvalue.\n+   --  The following array contains all attributes that imply a modification\n+   --  of their prefixes or result in an access value. Such prefixes can be\n+   --  considered as lvalues.\n \n-   Attribute_Name_Modifies_Prefix : constant Attribute_Class_Array :=\n+   Attribute_Name_Implies_Lvalue_Prefix : constant Attribute_Class_Array :=\n       Attribute_Class_Array'(\n-      Attribute_Access           |\n-      Attribute_Address          |\n-      Attribute_Input            |\n-      Attribute_Read             |\n-      Attribute_Unchecked_Access => True,\n-      others                     => False);\n-\n-   --  The following list contains all attributes that require simple names\n-   --  rather than values as their prefixes.\n-\n-   Attribute_Requires_Simple_Name_Prefix : constant Attribute_Class_Array :=\n-      Attribute_Class_Array'(\n-      Attribute_Asm_Input  |\n-      Attribute_Asm_Output |\n-      Attribute_Size       => True,\n-      others               => False);\n+      Attribute_Access              |\n+      Attribute_Address             |\n+      Attribute_Input               |\n+      Attribute_Read                |\n+      Attribute_Unchecked_Access    |\n+      Attribute_Unrestricted_Access => True,\n+      others                        => False);\n \n    -----------------------\n    -- Local_Subprograms --\n@@ -1638,86 +1630,6 @@ package body Sem_Attr is\n       procedure Standard_Attribute (Val : Int) is\n       begin\n          Check_Standard_Prefix;\n-\n-         --  First a special check (more like a kludge really). For GNAT5\n-         --  on Windows, the alignments in GCC are severely mixed up. In\n-         --  particular, we have a situation where the maximum alignment\n-         --  that GCC thinks is possible is greater than the guaranteed\n-         --  alignment at run-time. That causes many problems. As a partial\n-         --  cure for this situation, we force a value of 4 for the maximum\n-         --  alignment attribute on this target. This still does not solve\n-         --  all problems, but it helps.\n-\n-         --  A further (even more horrible) dimension to this kludge is now\n-         --  installed. There are two uses for Maximum_Alignment, one is to\n-         --  determine the maximum guaranteed alignment, that's the one we\n-         --  want the kludge to yield as 4. The other use is to maximally\n-         --  align objects, we can't use 4 here, since for example, long\n-         --  long integer has an alignment of 8, so we will get errors.\n-\n-         --  It is of course impossible to determine which use the programmer\n-         --  has in mind, but an approximation for now is to disconnect the\n-         --  kludge if the attribute appears in an alignment clause.\n-\n-         --  To be removed if GCC ever gets its act together here ???\n-\n-         Alignment_Kludge : declare\n-            P : Node_Id;\n-\n-            function On_X86 return Boolean;\n-            --  Determine if target is x86 (ia32), return True if so\n-\n-            ------------\n-            -- On_X86 --\n-            ------------\n-\n-            function On_X86 return Boolean is\n-               T : constant String := Sdefault.Target_Name.all;\n-\n-            begin\n-               --  There is no clean way to check this. That's not surprising,\n-               --  the front end should not be doing this kind of test ???. The\n-               --  way we do it is test for either \"86\" or \"pentium\" being in\n-               --  the string for the target name. However, we need to exclude\n-               --  x86_64 for this check.\n-\n-               for J in T'First .. T'Last - 1 loop\n-                  if (T (J .. J + 1) = \"86\"\n-                      and then\n-                        (J + 4 > T'Last\n-                           or else T (J + 2 .. J + 4) /= \"_64\"))\n-                    or else (J <= T'Last - 6\n-                               and then T (J .. J + 6) = \"pentium\")\n-                  then\n-                     return True;\n-                  end if;\n-               end loop;\n-\n-               return False;\n-            end On_X86;\n-\n-         --  Start of processing for Alignment_Kludge\n-\n-         begin\n-            if Aname = Name_Maximum_Alignment and then On_X86 then\n-               P := Parent (N);\n-\n-               while Nkind (P) in N_Subexpr loop\n-                  P := Parent (P);\n-               end loop;\n-\n-               if Nkind (P) /= N_Attribute_Definition_Clause\n-                 or else Chars (P) /= Name_Alignment\n-               then\n-                  Rewrite (N, Make_Integer_Literal (Loc, 4));\n-                  Analyze (N);\n-                  return;\n-               end if;\n-            end if;\n-         end Alignment_Kludge;\n-\n-         --  Normally we get the value from gcc ???\n-\n          Rewrite (N, Make_Integer_Literal (Loc, Val));\n          Analyze (N);\n       end Standard_Attribute;\n@@ -1791,15 +1703,17 @@ package body Sem_Attr is\n       end if;\n \n       --  Analyze prefix and exit if error in analysis. If the prefix is an\n-      --  incomplete type, use full view if available. A special case is\n-      --  that we never analyze the prefix of an Elab_Body or Elab_Spec\n-      --  or UET_Address attribute.\n+      --  incomplete type, use full view if available. Note that there are\n+      --  some attributes for which we do not analyze the prefix, since the\n+      --  prefix is not a normal name.\n \n       if Aname /= Name_Elab_Body\n            and then\n          Aname /= Name_Elab_Spec\n            and then\n          Aname /= Name_UET_Address\n+           and then\n+         Aname /= Name_Enabled\n       then\n          Analyze (P);\n          P_Type := Etype (P);\n@@ -1864,7 +1778,7 @@ package body Sem_Attr is\n          E1 := First (Exprs);\n          Analyze (E1);\n \n-         --  Check for missing or bad expression (result of previous error)\n+         --  Check for missing/bad expression (result of previous error)\n \n          if No (E1) or else Etype (E1) = Any_Type then\n             raise Bad_Attribute;\n@@ -1886,7 +1800,7 @@ package body Sem_Attr is\n       end if;\n \n       --  Ada 2005 (AI-345): Ensure that the compiler gives exactly the current\n-      --  output compiling in Ada 95 mode\n+      --  output compiling in Ada 95 mode for the case of ambiguous prefixes.\n \n       if Ada_Version < Ada_05\n         and then Is_Overloaded (P)\n@@ -2371,7 +2285,6 @@ package body Sem_Attr is\n       --  immediately and sets an appropriate type.\n \n       when Attribute_Bit_Position =>\n-\n          if Comes_From_Source (N) then\n             Check_Component;\n          end if;\n@@ -2564,7 +2477,7 @@ package body Sem_Attr is\n             if Warn_On_Obsolescent_Feature then\n                Error_Msg_N\n                  (\"constrained for private type is an \" &\n-                  \"obsolescent feature ('R'M 'J.4)?\", N);\n+                  \"obsolescent feature (RM J.4)?\", N);\n             end if;\n \n             --  If we are within an instance, the attribute must be legal\n@@ -2605,7 +2518,7 @@ package body Sem_Attr is\n             end if;\n \n             --  Must have discriminants or be an access type designating\n-            --  a type with discriminants. If it is a classwide type is\n+            --  a type with discriminants. If it is a classwide type is ???\n             --  has unknown discriminants.\n \n             if Has_Discriminants (P_Type)\n@@ -2872,6 +2785,29 @@ package body Sem_Attr is\n          Check_Floating_Point_Type_0;\n          Set_Etype (N, Universal_Integer);\n \n+      -------------\n+      -- Enabled --\n+      -------------\n+\n+      when Attribute_Enabled =>\n+         Check_Either_E0_Or_E1;\n+\n+         if Present (E1) then\n+            if not Is_Entity_Name (E1) or else No (Entity (E1)) then\n+               Error_Msg_N (\"entity name expected for Enabled attribute\", E1);\n+               E1 := Empty;\n+            end if;\n+         end if;\n+\n+         if Nkind (P) /= N_Identifier then\n+            Error_Msg_N (\"identifier expected (check name)\", P);\n+\n+         elsif Get_Check_Id (Chars (P)) = No_Check_Id then\n+            Error_Msg_N (\"& is not a recognized check name\", P);\n+         end if;\n+\n+         Set_Etype (N, Standard_Boolean);\n+\n       --------------\n       -- Enum_Rep --\n       --------------\n@@ -4223,8 +4159,23 @@ package body Sem_Attr is\n          Check_E1;\n          Check_Scalar_Type;\n \n+         --  Case of enumeration type\n+\n          if Is_Enumeration_Type (P_Type) then\n             Check_Restriction (No_Enumeration_Maps, N);\n+\n+            --  Mark all enumeration literals as referenced, since the use of\n+            --  the Value attribute can implicitly reference any of the\n+            --  literals of the enumeration base type.\n+\n+            declare\n+               Ent : Entity_Id := First_Literal (P_Base_Type);\n+            begin\n+               while Present (Ent) loop\n+                  Set_Referenced (Ent);\n+                  Next_Literal (Ent);\n+               end loop;\n+            end;\n          end if;\n \n          --  Set Etype before resolving expression because expansion of\n@@ -4507,7 +4458,6 @@ package body Sem_Attr is\n       begin\n          Result := 1;\n          Delta_Val := Delta_Value (P_Type);\n-\n          while Delta_Val < Ureal_Tenth loop\n             Delta_Val := Delta_Val * Ureal_10;\n             Result := Result + 1;\n@@ -4521,9 +4471,9 @@ package body Sem_Attr is\n       -----------------------\n \n       procedure Check_Expressions is\n-         E : Node_Id := E1;\n-\n+         E : Node_Id;\n       begin\n+         E := E1;\n          while Present (E) loop\n             Check_Non_Static_Context (E);\n             Next (E);\n@@ -4886,6 +4836,49 @@ package body Sem_Attr is\n          E2 := Empty;\n       end if;\n \n+      --  Special processing for Enabled attribute. This attribute has a very\n+      --  special prefix, and the easiest way to avoid lots of special checks\n+      --  to protect this special prefix from causing trouble is to deal with\n+      --  this attribute immediately and be done with it.\n+\n+      if Id = Attribute_Enabled then\n+\n+         --  Evaluate the Enabled attribute\n+\n+         --  We skip evaluation if the expander is not active. This is not just\n+         --  an optimization. It is of key importance that we not rewrite the\n+         --  attribute in a generic template, since we want to pick up the\n+         --  setting of the check in the instance, and testing expander active\n+         --  is as easy way of doing this as any.\n+\n+         if Expander_Active then\n+            declare\n+               C : constant Check_Id := Get_Check_Id (Chars (P));\n+               R : Boolean;\n+\n+            begin\n+               if No (E1) then\n+                  if C in Predefined_Check_Id then\n+                     R := Scope_Suppress (C);\n+                  else\n+                     R := Is_Check_Suppressed (Empty, C);\n+                  end if;\n+\n+               else\n+                  R := Is_Check_Suppressed (Entity (E1), C);\n+               end if;\n+\n+               if R then\n+                  Rewrite (N, New_Occurrence_Of (Standard_False, Loc));\n+               else\n+                  Rewrite (N, New_Occurrence_Of (Standard_True, Loc));\n+               end if;\n+            end;\n+         end if;\n+\n+         return;\n+      end if;\n+\n       --  Special processing for cases where the prefix is an object. For\n       --  this purpose, a string literal counts as an object (attributes\n       --  of string literals can only appear in generated code).\n@@ -5578,9 +5571,29 @@ package body Sem_Attr is\n \n       --  Image is a scalar attribute, but is never static, because it is\n       --  not a static function (having a non-scalar argument (RM 4.9(22))\n+      --  However, we can constant-fold the image of an enumeration literal\n+      --  if names are available.\n \n       when Attribute_Image =>\n-         null;\n+         if Is_Entity_Name (E1)\n+           and then Ekind (Entity (E1)) = E_Enumeration_Literal\n+           and then not Discard_Names (First_Subtype (Etype (E1)))\n+           and then not Global_Discard_Names\n+         then\n+            declare\n+               Lit : constant Entity_Id := Entity (E1);\n+               Str : String_Id;\n+            begin\n+               Start_String;\n+               Get_Unqualified_Decoded_Name_String (Chars (Lit));\n+               Set_Casing (All_Upper_Case);\n+               Store_String_Chars (Name_Buffer (1 .. Name_Len));\n+               Str := End_String;\n+               Rewrite (N, Make_String_Literal (Loc, Strval => Str));\n+               Analyze_And_Resolve (N, Standard_String);\n+               Set_Is_Static_Expression (N, False);\n+            end;\n+         end if;\n \n       ---------\n       -- Img --\n@@ -6644,12 +6657,10 @@ package body Sem_Attr is\n \n       when Attribute_Value_Size => Value_Size : declare\n          P_TypeA : constant Entity_Id := Underlying_Type (P_Type);\n-\n       begin\n          if RM_Size (P_TypeA) /= Uint_0 then\n             Fold_Uint (N, RM_Size (P_TypeA), True);\n          end if;\n-\n       end Value_Size;\n \n       -------------\n@@ -6947,6 +6958,7 @@ package body Sem_Attr is\n            Attribute_Elaborated               |\n            Attribute_Elab_Body                |\n            Attribute_Elab_Spec                |\n+           Attribute_Enabled                  |\n            Attribute_External_Tag             |\n            Attribute_First_Bit                |\n            Attribute_Input                    |\n@@ -7011,7 +7023,6 @@ package body Sem_Attr is\n       else\n          null;\n       end if;\n-\n    end Eval_Attribute;\n \n    ------------------------------\n@@ -7030,25 +7041,15 @@ package body Sem_Attr is\n           and then Associated_Node_For_Itype (Anon) = Parent (Typ);\n    end Is_Anonymous_Tagged_Base;\n \n-   --------------------------\n-   -- Name_Modifies_Prefix --\n-   --------------------------\n-\n-   function Name_Modifies_Prefix (Nam : Name_Id) return Boolean is\n-      pragma Assert (Is_Attribute_Name (Nam));\n-   begin\n-      return Attribute_Name_Modifies_Prefix (Get_Attribute_Id (Nam));\n-   end Name_Modifies_Prefix;\n-\n-   ---------------------------------\n-   -- Requires_Simple_Name_Prefix --\n-   ---------------------------------\n+   --------------------------------\n+   -- Name_Implies_Lvalue_Prefix --\n+   --------------------------------\n \n-   function Requires_Simple_Name_Prefix (Nam : Name_Id) return Boolean is\n+   function Name_Implies_Lvalue_Prefix (Nam : Name_Id) return Boolean is\n       pragma Assert (Is_Attribute_Name (Nam));\n    begin\n-      return Attribute_Requires_Simple_Name_Prefix (Get_Attribute_Id (Nam));\n-   end Requires_Simple_Name_Prefix;\n+      return Attribute_Name_Implies_Lvalue_Prefix (Get_Attribute_Id (Nam));\n+   end Name_Implies_Lvalue_Prefix;\n \n    -----------------------\n    -- Resolve_Attribute --\n@@ -7161,6 +7162,7 @@ package body Sem_Attr is\n             | Attribute_Unchecked_Access\n             | Attribute_Unrestricted_Access =>\n \n+         Access_Attribute : begin\n             if Is_Variable (P) then\n                Note_Possible_Modification (P);\n             end if;\n@@ -7187,7 +7189,7 @@ package body Sem_Attr is\n \n                --  If Prefix is a subprogram name, it is frozen by this\n                --  reference:\n-               --\n+\n                --    If it is a type, there is nothing to resolve.\n                --    If it is an object, complete its resolution.\n \n@@ -7357,12 +7359,12 @@ package body Sem_Attr is\n                            Error_Msg_NE\n                              (\"\\because \" &\n                               \"access type & is declared outside \" &\n-                              \"generic unit ('R'M 3.10.2(32))\", N, Btyp);\n+                              \"generic unit (RM 3.10.2(32))\", N, Btyp);\n                         else\n                            Error_Msg_NE\n                              (\"\\because ancestor of \" &\n                               \"access type & is declared outside \" &\n-                              \"generic unit ('R'M 3.10.2(32))\", N, Btyp);\n+                              \"generic unit (RM 3.10.2(32))\", N, Btyp);\n                         end if;\n \n                         Error_Msg_NE\n@@ -7460,9 +7462,9 @@ package body Sem_Attr is\n \n             if not (Ekind (Btyp) = E_Access_Subprogram_Type\n                      or else Ekind (Btyp) = E_Anonymous_Access_Subprogram_Type\n-                    or else (Is_Record_Type (Btyp)\n-                              and then\n-                                Present (Corresponding_Remote_Type (Btyp)))\n+                     or else (Is_Record_Type (Btyp)\n+                               and then\n+                                 Present (Corresponding_Remote_Type (Btyp)))\n                      or else Ekind (Btyp) = E_Access_Protected_Subprogram_Type\n                      or else Ekind (Btyp)\n                                = E_Anonymous_Access_Protected_Subprogram_Type\n@@ -7524,9 +7526,8 @@ package body Sem_Attr is\n                      P);\n                end if;\n \n-               --  Check the static matching rule of 3.10.2(27). The\n-               --  nominal subtype of the prefix must statically\n-               --  match the designated type.\n+               --  Check static matching rule of 3.10.2(27). Nominal subtype\n+               --  of the prefix must statically match the designated type.\n \n                Nom_Subt := Etype (P);\n \n@@ -7554,8 +7555,8 @@ package body Sem_Attr is\n                if Is_Tagged_Type (Designated_Type (Typ)) then\n \n                   --  If the attribute is in the context of an access\n-                  --  parameter, then the prefix is allowed to be of\n-                  --  the class-wide type (by AI-127).\n+                  --  parameter, then the prefix is allowed to be of the\n+                  --  class-wide type (by AI-127).\n \n                   if Ekind (Typ) = E_Anonymous_Access_Type then\n                      if not Covers (Designated_Type (Typ), Nom_Subt)\n@@ -7594,7 +7595,7 @@ package body Sem_Attr is\n                        (\"type of prefix: & is not covered\", P, Nom_Subt);\n                      Error_Msg_FE\n                        (\"\\by &, the expected designated type\" &\n-                           \" ('R'M 3.10.2 (27))\", P, Designated_Type (Typ));\n+                           \" (RM 3.10.2 (27))\", P, Designated_Type (Typ));\n                   end if;\n \n                   if Is_Class_Wide_Type (Designated_Type (Typ))\n@@ -7666,12 +7667,11 @@ package body Sem_Attr is\n                then\n                   Error_Msg_F (\"context requires a protected subprogram\", P);\n \n-               --  Check accessibility of protected object against that\n-               --  of the access type, but only on user code, because\n-               --  the expander creates access references for handlers.\n-               --  If the context is an anonymous_access_to_protected,\n-               --  there are no accessibility checks either.\n-               --  Omit check altogether for GNAT Unrestricted_Access.\n+               --  Check accessibility of protected object against that of the\n+               --  access type, but only on user code, because the expander\n+               --  creates access references for handlers. If the context is an\n+               --  anonymous_access_to_protected, there are no accessibility\n+               --  checks either. Omit check entirely for Unrestricted_Access.\n \n                elsif Object_Access_Level (P) > Type_Access_Level (Btyp)\n                  and then Comes_From_Source (N)\n@@ -7726,6 +7726,11 @@ package body Sem_Attr is\n                end if;\n             end if;\n \n+            if Is_Entity_Name (P) then\n+               Set_Address_Taken (Entity (P));\n+            end if;\n+         end Access_Attribute;\n+\n          -------------\n          -- Address --\n          -------------\n@@ -7734,6 +7739,7 @@ package body Sem_Attr is\n          --  is not permitted here, since there is no context to resolve it.\n \n          when Attribute_Address | Attribute_Code_Address =>\n+         Address_Attribute : begin\n \n             --  To be safe, assume that if the address of a variable is taken,\n             --  it may be modified via this address, so note modification.\n@@ -7756,7 +7762,7 @@ package body Sem_Attr is\n             end if;\n \n             if not Is_Entity_Name (P)\n-               or else not Is_Overloadable (Entity (P))\n+              or else not Is_Overloadable (Entity (P))\n             then\n                if not Is_Task_Type (Etype (P))\n                  or else Nkind (P) = N_Explicit_Dereference\n@@ -7776,6 +7782,11 @@ package body Sem_Attr is\n                  New_Occurrence_Of (Alias (Entity (P)), Sloc (P)));\n             end if;\n \n+            if Is_Entity_Name (P) then\n+               Set_Address_Taken (Entity (P));\n+            end if;\n+         end Address_Attribute;\n+\n          ---------------\n          -- AST_Entry --\n          ---------------\n@@ -7845,6 +7856,16 @@ package body Sem_Attr is\n          when Attribute_Elaborated =>\n             null;\n \n+         -------------\n+         -- Enabled --\n+         -------------\n+\n+         --  Prefix of Enabled attribute is a check name, which must be treated\n+         --  specially and not touched by Resolve.\n+\n+         when Attribute_Enabled =>\n+            null;\n+\n          --------------------\n          -- Mechanism_Code --\n          --------------------\n@@ -8112,23 +8133,9 @@ package body Sem_Attr is\n       end case;\n \n       --  Normally the Freezing is done by Resolve but sometimes the Prefix\n-      --  is not resolved, in which case the freezing must be done now. The\n-      --  exception to this general rule is the use of 'Address with\n-      --  subprograms (this is required by the backend to support the static\n-      --  allocation of the dispatch tables).\n-\n-      if Static_Dispatch_Tables\n-        and then Nkind (P) in N_Has_Entity\n-        and then not Is_Frozen (Entity (P))\n-        and then Attr_Id = Attribute_Address\n-        and then Is_Subprogram (Entity (P))\n-        and then Is_Dispatching_Operation (Entity (P))\n-      then\n-         Set_Has_Delayed_Freeze (Entity (P));\n+      --  is not resolved, in which case the freezing must be done now.\n \n-      else\n-         Freeze_Expression (P);\n-      end if;\n+      Freeze_Expression (P);\n \n       --  Finally perform static evaluation on the attribute reference\n "}, {"sha": "1ca903915d54509af62d297fa679715086ee18a5", "filename": "gcc/ada/sem_attr.ads", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442ade9dfe3e9ddf837174e548c8e248e9312c39/gcc%2Fada%2Fsem_attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442ade9dfe3e9ddf837174e548c8e248e9312c39/gcc%2Fada%2Fsem_attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.ads?ref=442ade9dfe3e9ddf837174e548c8e248e9312c39", "patch": "@@ -542,18 +542,16 @@ package Sem_Attr is\n    --  in appropriate contexts (i.e. in subtype marks, or as prefixes for\n    --  other attributes).\n \n-   function Name_Modifies_Prefix (Nam : Name_Id) return Boolean;\n-   --  Determine whether the name of an attribute reference modifies the\n-   --  contents of its prefix. \"Read\" is such an attribute.\n-\n-   function Requires_Simple_Name_Prefix (Nam : Name_Id) return Boolean;\n-   --  Determine whether the name of an attribute reference requires a simple\n-   --  name rather than a value as its prefix. Such prefixes do not need to be\n-   --  optimized. For instance in the following example:\n-   --     I : constant Integer := 5;\n-   --     S : constant Integer := I'Size;\n-   --  \"Size\" requires a simple name prefix since \"5'Size\" does not make\n-   --  sense.\n+   function Name_Implies_Lvalue_Prefix (Nam : Name_Id) return Boolean;\n+   --  Determine whether the name of an attribute reference categorizes its\n+   --  prefix as an lvalue. The following attributes fall under this bracket\n+   --  by directly or indirectly modifying their prefixes.\n+   --     Access\n+   --     Address\n+   --     Input\n+   --     Read\n+   --     Unchecked_Access\n+   --     Unrestricted_Access\n \n    procedure Resolve_Attribute (N : Node_Id; Typ : Entity_Id);\n    --  Performs type resolution of attribute. If the attribute yields a"}]}