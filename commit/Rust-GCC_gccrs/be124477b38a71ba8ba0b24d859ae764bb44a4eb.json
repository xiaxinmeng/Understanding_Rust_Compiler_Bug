{"sha": "be124477b38a71ba8ba0b24d859ae764bb44a4eb", "node_id": "C_kwDOANBUbNoAKGJlMTI0NDc3YjM4YTcxYmE4YmEwYjI0ZDg1OWFlNzY0YmI0NGE0ZWI", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-12-15T20:54:31Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-12-15T20:54:31Z"}, "message": "c++: local alias in typename in lambda [PR105518]\n\nWe substitute the qualifying scope of a TYPENAME_TYPE directly using\ntsubst_aggr_type (so that we can pass entering_scope=true) instead of\ngoing through tsubst, which means we don't properly reuse typedefs\nduring this substitution.  This ends up causing us to reject the below\ntestcase because we substitute the TYPENAME_TYPE alias::type as if it\nwere written without the A<t> alias, and thus we expect the non-capturing\nlambda to capture t.\n\nThis patch fixes this by making tsubst_aggr_type delegate typedefs\nto tsubst so that get consistently reused, and then adjusting the result\nappropriately if entering_scope is true.  In passing, this refactors\ntsubst_aggr_type into two functions, one that's intended to be called\ndirectly and a more minimal one that's intended to be called only from\nthe RECORD/UNION/ENUMERAL_TYPE cases of tsubst (and contains only the\nnecessary bits for that call site).\n\n\tPR c++/105518\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (tsubst_aggr_type): Handle typedefs by delegating to\n\ttsubst and adjusting the result if entering_scope.  Split out\n\tthe main part of the function into ...\n\t(tsubst_aggr_type_1) ... here.\n\t(tsubst): Use tsubst_aggr_type_1 instead of tsubst_aggr_type.\n\tHandle TYPE_PTRMEMFUNC_P RECORD_TYPEs here instead of in\n\ttsubst_aggr_type_1.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/lambda/lambda-alias1.C: New test.", "tree": {"sha": "75410ad2cd9d58aa08e91983acef4d5ba11f213c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75410ad2cd9d58aa08e91983acef4d5ba11f213c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be124477b38a71ba8ba0b24d859ae764bb44a4eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be124477b38a71ba8ba0b24d859ae764bb44a4eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be124477b38a71ba8ba0b24d859ae764bb44a4eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be124477b38a71ba8ba0b24d859ae764bb44a4eb/comments", "author": null, "committer": null, "parents": [{"sha": "38304846d18d6bb14b0fd6c627c5c6d43a814d01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38304846d18d6bb14b0fd6c627c5c6d43a814d01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38304846d18d6bb14b0fd6c627c5c6d43a814d01"}], "stats": {"total": 134, "additions": 92, "deletions": 42}, "files": [{"sha": "38e3a1672c1946b0d6e1211fd90c006201a0962a", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 69, "deletions": 42, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be124477b38a71ba8ba0b24d859ae764bb44a4eb/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be124477b38a71ba8ba0b24d859ae764bb44a4eb/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=be124477b38a71ba8ba0b24d859ae764bb44a4eb", "patch": "@@ -185,6 +185,7 @@ static tree tsubst_template_parms (tree, tree, tsubst_flags_t);\n static void tsubst_each_template_parm_constraints (tree, tree, tsubst_flags_t);\n tree most_specialized_partial_spec (tree, tsubst_flags_t);\n static tree tsubst_aggr_type (tree, tree, tsubst_flags_t, tree, int);\n+static tree tsubst_aggr_type_1 (tree, tree, tsubst_flags_t, tree, int);\n static tree tsubst_arg_types (tree, tree, tree, tsubst_flags_t, tree);\n static tree tsubst_function_type (tree, tree, tsubst_flags_t, tree);\n static bool check_specialization_scope (void);\n@@ -13828,57 +13829,80 @@ tsubst_aggr_type (tree t,\n   if (t == NULL_TREE)\n     return NULL_TREE;\n \n-  /* If T is an alias template specialization, we want to substitute that\n-     rather than strip it, especially if it's dependent_alias_template_spec_p.\n-     It should be OK not to handle entering_scope in this case, since\n-     DECL_CONTEXT will never be an alias template specialization.  We only get\n-     here with an alias when tsubst calls us for TYPENAME_TYPE.  */\n-  if (alias_template_specialization_p (t, nt_transparent))\n-    return tsubst (t, args, complain, in_decl);\n+  /* Handle typedefs via tsubst so that they get consistently reused.  */\n+  if (typedef_variant_p (t))\n+    {\n+      t = tsubst (t, args, complain, in_decl);\n+      if (t == error_mark_node)\n+\treturn error_mark_node;\n+\n+      /* The effect of entering_scope is that for a dependent specialization\n+\t A<T>, lookup_template_class prefers to return A's primary template\n+\t type instead of the implicit instantiation.  So when entering_scope,\n+\t we mirror this behavior by inspecting TYPE_CANONICAL appropriately,\n+\t taking advantage of the fact that lookup_template_class links the two\n+\t types by setting TYPE_CANONICAL of the latter to the former.  */\n+      if (entering_scope\n+\t  && CLASS_TYPE_P (t)\n+\t  && dependent_type_p (t)\n+\t  && TYPE_CANONICAL (t) == TREE_TYPE (TYPE_TI_TEMPLATE (t)))\n+\tt = TYPE_CANONICAL (t);\n+\n+      return t;\n+    }\n \n   switch (TREE_CODE (t))\n     {\n-    case RECORD_TYPE:\n-      if (TYPE_PTRMEMFUNC_P (t))\n-\treturn tsubst (TYPE_PTRMEMFUNC_FN_TYPE (t), args, complain, in_decl);\n+      case RECORD_TYPE:\n+      case ENUMERAL_TYPE:\n+      case UNION_TYPE:\n+\treturn tsubst_aggr_type_1 (t, args, complain, in_decl, entering_scope);\n \n-      /* Fall through.  */\n-    case ENUMERAL_TYPE:\n-    case UNION_TYPE:\n-      if (TYPE_TEMPLATE_INFO (t) && uses_template_parms (t))\n-\t{\n-\t  tree argvec;\n-\t  tree r;\n+      default:\n+\treturn tsubst (t, args, complain, in_decl);\n+    }\n+}\n \n-\t  /* Figure out what arguments are appropriate for the\n-\t     type we are trying to find.  For example, given:\n+/* The part of tsubst_aggr_type that's shared with the RECORD_, UNION_\n+   and ENUMERAL_TYPE cases of tsubst.  */\n+\n+static tree\n+tsubst_aggr_type_1 (tree t,\n+\t\t    tree args,\n+\t\t    tsubst_flags_t complain,\n+\t\t    tree in_decl,\n+\t\t    int entering_scope)\n+{\n+  if (TYPE_TEMPLATE_INFO (t) && uses_template_parms (t))\n+    {\n+      tree argvec;\n+      tree r;\n \n-\t       template <class T> struct S;\n-\t       template <class T, class U> void f(T, U) { S<U> su; }\n+      /* Figure out what arguments are appropriate for the\n+\t type we are trying to find.  For example, given:\n \n-\t     and supposing that we are instantiating f<int, double>,\n-\t     then our ARGS will be {int, double}, but, when looking up\n-\t     S we only want {double}.  */\n-\t  argvec = tsubst_template_args (TYPE_TI_ARGS (t), args,\n-\t\t\t\t\t complain, in_decl);\n-\t  if (argvec == error_mark_node)\n-\t    r = error_mark_node;\n-\t  else\n-\t    {\n-\t      r = lookup_template_class (t, argvec, in_decl, NULL_TREE,\n-\t\t\t\t\t entering_scope, complain);\n-\t      r = cp_build_qualified_type (r, cp_type_quals (t), complain);\n-\t    }\n+\t   template <class T> struct S;\n+\t   template <class T, class U> void f(T, U) { S<U> su; }\n \n-\t  return r;\n-\t}\n+\t and supposing that we are instantiating f<int, double>,\n+\t then our ARGS will be {int, double}, but, when looking up\n+\t S we only want {double}.  */\n+      argvec = tsubst_template_args (TYPE_TI_ARGS (t), args,\n+\t\t\t\t     complain, in_decl);\n+      if (argvec == error_mark_node)\n+\tr = error_mark_node;\n       else\n-\t/* This is not a template type, so there's nothing to do.  */\n-\treturn t;\n+\t{\n+\t  r = lookup_template_class (t, argvec, in_decl, NULL_TREE,\n+\t\t\t\t     entering_scope, complain);\n+\t  r = cp_build_qualified_type (r, cp_type_quals (t), complain);\n+\t}\n \n-    default:\n-      return tsubst (t, args, complain, in_decl);\n+      return r;\n     }\n+  else\n+    /* This is not a template type, so there's nothing to do.  */\n+    return t;\n }\n \n /* Map from a FUNCTION_DECL to a vec of default argument instantiations,\n@@ -15795,10 +15819,13 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   switch (code)\n     {\n     case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (t))\n+\treturn tsubst (TYPE_PTRMEMFUNC_FN_TYPE (t), args, complain, in_decl);\n+      /* Fall through.  */\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n-      return tsubst_aggr_type (t, args, complain, in_decl,\n-\t\t\t       /*entering_scope=*/0);\n+      return tsubst_aggr_type_1 (t, args, complain, in_decl,\n+\t\t\t\t /*entering_scope=*/0);\n \n     case ERROR_MARK:\n     case IDENTIFIER_NODE:"}, {"sha": "08c38e6f84c6e0fd9fcd8da6298c07fe180c468b", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-alias1.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be124477b38a71ba8ba0b24d859ae764bb44a4eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-alias1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be124477b38a71ba8ba0b24d859ae764bb44a4eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-alias1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-alias1.C?ref=be124477b38a71ba8ba0b24d859ae764bb44a4eb", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/105518\n+// { dg-do compile { target c++11 } }\n+\n+struct integral_constant {\n+  constexpr operator int() const { return 42; }\n+};\n+\n+template<int N>\n+struct A {\n+  using type = A;\n+  static constexpr int value = N;\n+};\n+\n+template<class T>\n+void f(T t) {\n+  using alias = A<t>;\n+  [](int) {\n+    typename alias::type a; // { dg-bogus \"'t' is not captured\" }\n+    return a.value;\n+  }(0);\n+}\n+\n+template void f(integral_constant);"}]}