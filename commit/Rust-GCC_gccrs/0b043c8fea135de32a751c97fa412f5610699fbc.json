{"sha": "0b043c8fea135de32a751c97fa412f5610699fbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIwNDNjOGZlYTEzNWRlMzJhNzUxYzk3ZmE0MTJmNTYxMDY5OWZiYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-06-11T12:49:58Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-16T09:18:15Z"}, "message": "[Ada] Wrong execution of Tan on large argument\n\ngcc/ada/\n\n\t* Makefile.rtl: replace a-numaux__x86.ads by\n\ta-numaux__libc-x86.ads and a-numaux__x86.adb by\n\ta-numaux__dummy.adb.\n\t* libgnat/a-numaux__x86.ads, libgnat/a-numaux__x86.adb: Removed.\n\t* libgnat/a-numaux__dummy.adb: New.", "tree": {"sha": "5fb57bbaa00c4599881a0655bc94ec245ec5c676", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fb57bbaa00c4599881a0655bc94ec245ec5c676"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b043c8fea135de32a751c97fa412f5610699fbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b043c8fea135de32a751c97fa412f5610699fbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b043c8fea135de32a751c97fa412f5610699fbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b043c8fea135de32a751c97fa412f5610699fbc/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "875a00faca1e15e72aca02c323c0459b50d96b89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/875a00faca1e15e72aca02c323c0459b50d96b89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/875a00faca1e15e72aca02c323c0459b50d96b89"}], "stats": {"total": 637, "additions": 8, "deletions": 629}, "files": [{"sha": "d7f2bdef59efa96a79d3e2599f6afdd6625d5223", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b043c8fea135de32a751c97fa412f5610699fbc/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b043c8fea135de32a751c97fa412f5610699fbc/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=0b043c8fea135de32a751c97fa412f5610699fbc", "patch": "@@ -834,13 +834,13 @@ ATOMICS_BUILTINS_TARGET_PAIRS = \\\n # Special version of units for x86 and x86-64 platforms.\n \n X86_TARGET_PAIRS = \\\n-  a-numaux.ads<libgnat/a-numaux__x86.ads \\\n-  a-numaux.adb<libgnat/a-numaux__x86.adb \\\n+  a-numaux.ads<libgnat/a-numaux__libc-x86.ads \\\n+  a-numaux.adb<libgnat/a-numaux__dummy.adb \\\n   s-atocou.adb<libgnat/s-atocou__x86.adb\n \n X86_64_TARGET_PAIRS = \\\n-  a-numaux.ads<libgnat/a-numaux__x86.ads \\\n-  a-numaux.adb<libgnat/a-numaux__x86.adb \\\n+  a-numaux.ads<libgnat/a-numaux__libc-x86.ads \\\n+  a-numaux.adb<libgnat/a-numaux__dummy.adb \\\n   s-atocou.adb<libgnat/s-atocou__builtin.adb\n \n # Implementation of symbolic traceback based on dwarf\n@@ -1648,8 +1648,8 @@ endif\n ifeq ($(strip $(filter-out x86_64 kfreebsd%,$(target_cpu) $(target_os))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<libgnarl/a-intnam__freebsd.ads \\\n-  a-numaux.adb<libgnat/a-numaux__x86.adb \\\n-  a-numaux.ads<libgnat/a-numaux__x86.ads \\\n+  a-numaux.ads<libgnat/a-numaux__libc-x86.ads \\\n+  a-numaux.adb<libgnat/a-numaux__dummy.adb \\\n   s-inmaop.adb<libgnarl/s-inmaop__posix.adb \\\n   s-intman.adb<libgnarl/s-intman__posix.adb \\\n   s-osinte.adb<libgnarl/s-osinte__posix.adb \\"}, {"sha": "f5d72ece8de5e746ec6ebc6940353be3fe7ede95", "filename": "gcc/ada/libgnat/a-numaux__dummy.adb", "status": "renamed", "additions": 2, "deletions": 46, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b043c8fea135de32a751c97fa412f5610699fbc/gcc%2Fada%2Flibgnat%2Fa-numaux__dummy.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b043c8fea135de32a751c97fa412f5610699fbc/gcc%2Fada%2Flibgnat%2Fa-numaux__dummy.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-numaux__dummy.adb?ref=0b043c8fea135de32a751c97fa412f5610699fbc", "patch": "@@ -4,8 +4,7 @@\n --                                                                          --\n --                     A D A . N U M E R I C S . A U X                      --\n --                                                                          --\n---                                 S p e c                                  --\n---                        (Machine Version for x86)                         --\n+--                                 B o d y                                  --\n --                                                                          --\n --          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n --                                                                          --\n@@ -30,47 +29,4 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This version is for the x86 using the 80-bit x86 long double format with\n---  inline asm statements.\n-\n-package Ada.Numerics.Aux is\n-   pragma Pure;\n-\n-   type Double is new Long_Long_Float;\n-\n-   function Sin (X : Double) return Double;\n-\n-   function Cos (X : Double) return Double;\n-\n-   function Tan (X : Double) return Double;\n-\n-   function Exp (X : Double) return Double;\n-\n-   function Sqrt (X : Double) return Double;\n-\n-   function Log (X : Double) return Double;\n-\n-   function Atan (X : Double) return Double;\n-\n-   function Acos (X : Double) return Double;\n-\n-   function Asin (X : Double) return Double;\n-\n-   function Sinh (X : Double) return Double;\n-\n-   function Cosh (X : Double) return Double;\n-\n-   function Tanh (X : Double) return Double;\n-\n-   function Pow (X, Y : Double) return Double;\n-\n-private\n-   pragma Inline (Atan);\n-   pragma Inline (Cos);\n-   pragma Inline (Tan);\n-   pragma Inline (Exp);\n-   pragma Inline (Log);\n-   pragma Inline (Sin);\n-   pragma Inline (Sqrt);\n-\n-end Ada.Numerics.Aux;\n+pragma No_Body;", "previous_filename": "gcc/ada/libgnat/a-numaux__x86.ads"}, {"sha": "af22be253e351417d0946bfae8f494e940f076a1", "filename": "gcc/ada/libgnat/a-numaux__x86.adb", "status": "removed", "additions": 0, "deletions": 577, "changes": 577, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/875a00faca1e15e72aca02c323c0459b50d96b89/gcc%2Fada%2Flibgnat%2Fa-numaux__x86.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/875a00faca1e15e72aca02c323c0459b50d96b89/gcc%2Fada%2Flibgnat%2Fa-numaux__x86.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-numaux__x86.adb?ref=875a00faca1e15e72aca02c323c0459b50d96b89", "patch": "@@ -1,577 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---                     A D A . N U M E R I C S . A U X                      --\n---                                                                          --\n---                                 B o d y                                  --\n---                        (Machine Version for x86)                         --\n---                                                                          --\n---          Copyright (C) 1998-2020, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with System.Machine_Code; use System.Machine_Code;\n-\n-package body Ada.Numerics.Aux is\n-\n-   NL : constant String := ASCII.LF & ASCII.HT;\n-\n-   -----------------------\n-   -- Local subprograms --\n-   -----------------------\n-\n-   function Is_Nan (X : Double) return Boolean;\n-   --  Return True iff X is a IEEE NaN value\n-\n-   function Logarithmic_Pow (X, Y : Double) return Double;\n-   --  Implementation of X**Y using Exp and Log functions (binary base)\n-   --  to calculate the exponentiation. This is used by Pow for values\n-   --  for values of Y in the open interval (-0.25, 0.25)\n-\n-   procedure Reduce (X : in out Double; Q : out Natural);\n-   --  Implement reduction of X by Pi/2. Q is the quadrant of the final\n-   --  result in the range 0..3. The absolute value of X is at most Pi/4.\n-   --  It is needed to avoid a loss of accuracy for sin near Pi and cos\n-   --  near Pi/2 due to the use of an insufficiently precise value of Pi\n-   --  in the range reduction.\n-\n-   pragma Inline (Is_Nan);\n-   pragma Inline (Reduce);\n-\n-   --------------------------------\n-   -- Basic Elementary Functions --\n-   --------------------------------\n-\n-   --  This section implements a few elementary functions that are used to\n-   --  build the more complex ones. This ordering enables better inlining.\n-\n-   ----------\n-   -- Atan --\n-   ----------\n-\n-   function Atan (X : Double) return Double is\n-      Result  : Double;\n-\n-   begin\n-      Asm (Template =>\n-           \"fld1\" & NL\n-         & \"fpatan\",\n-         Outputs  => Double'Asm_Output (\"=t\", Result),\n-         Inputs   => Double'Asm_Input  (\"0\", X));\n-\n-      --  The result value is NaN iff input was invalid\n-\n-      if not (Result = Result) then\n-         raise Argument_Error;\n-      end if;\n-\n-      return Result;\n-   end Atan;\n-\n-   ---------\n-   -- Exp --\n-   ---------\n-\n-   function Exp (X : Double) return Double is\n-      Result : Double;\n-   begin\n-      Asm (Template =>\n-         \"fldl2e               \" & NL\n-       & \"fmulp   %%st, %%st(1)\" & NL -- X * log2 (E)\n-       & \"fld     %%st(0)      \" & NL\n-       & \"frndint              \" & NL -- Integer (X * Log2 (E))\n-       & \"fsubr   %%st, %%st(1)\" & NL -- Fraction (X * Log2 (E))\n-       & \"fxch                 \" & NL\n-       & \"f2xm1                \" & NL -- 2**(...) - 1\n-       & \"fld1                 \" & NL\n-       & \"faddp   %%st, %%st(1)\" & NL -- 2**(Fraction (X * Log2 (E)))\n-       & \"fscale               \" & NL -- E ** X\n-       & \"fstp    %%st(1)      \",\n-         Outputs  => Double'Asm_Output (\"=t\", Result),\n-         Inputs   => Double'Asm_Input  (\"0\", X));\n-      return Result;\n-   end Exp;\n-\n-   ------------\n-   -- Is_Nan --\n-   ------------\n-\n-   function Is_Nan (X : Double) return Boolean is\n-   begin\n-      --  The IEEE NaN values are the only ones that do not equal themselves\n-\n-      return X /= X;\n-   end Is_Nan;\n-\n-   ---------\n-   -- Log --\n-   ---------\n-\n-   function Log (X : Double) return Double is\n-      Result : Double;\n-\n-   begin\n-      Asm (Template =>\n-         \"fldln2               \" & NL\n-       & \"fxch                 \" & NL\n-       & \"fyl2x                \" & NL,\n-         Outputs  => Double'Asm_Output (\"=t\", Result),\n-         Inputs   => Double'Asm_Input  (\"0\", X));\n-      return Result;\n-   end Log;\n-\n-   ------------\n-   -- Reduce --\n-   ------------\n-\n-   procedure Reduce (X : in out Double; Q : out Natural) is\n-      Half_Pi     : constant := Pi / 2.0;\n-      Two_Over_Pi : constant := 2.0 / Pi;\n-\n-      HM : constant := Integer'Min (Double'Machine_Mantissa / 2, Natural'Size);\n-      M  : constant Double := 0.5 + 2.0**(1 - HM); -- Splitting constant\n-      P1 : constant Double := Double'Leading_Part (Half_Pi, HM);\n-      P2 : constant Double := Double'Leading_Part (Half_Pi - P1, HM);\n-      P3 : constant Double := Double'Leading_Part (Half_Pi - P1 - P2, HM);\n-      P4 : constant Double := Double'Leading_Part (Half_Pi - P1 - P2 - P3, HM);\n-      P5 : constant Double := Double'Leading_Part (Half_Pi - P1 - P2 - P3\n-                                                                 - P4, HM);\n-      P6 : constant Double := Double'Model (Half_Pi - P1 - P2 - P3 - P4 - P5);\n-      K  : Double;\n-      R  : Integer;\n-\n-   begin\n-      --  For X < 2.0**HM, all products below are computed exactly.\n-      --  Due to cancellation effects all subtractions are exact as well.\n-      --  As no double extended floating-point number has more than 75\n-      --  zeros after the binary point, the result will be the correctly\n-      --  rounded result of X - K * (Pi / 2.0).\n-\n-      K := X * Two_Over_Pi;\n-      while abs K >= 2.0**HM loop\n-         K := K * M - (K * M - K);\n-         X :=\n-           (((((X - K * P1) - K * P2) - K * P3) - K * P4) - K * P5) - K * P6;\n-         K := X * Two_Over_Pi;\n-      end loop;\n-\n-      --  If K is not a number (because X was not finite) raise exception\n-\n-      if Is_Nan (K) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      --  Go through an integer temporary so as to use machine instructions\n-\n-      R := Integer (Double'Rounding (K));\n-      Q := R mod 4;\n-      K := Double (R);\n-      X := (((((X - K * P1) - K * P2) - K * P3) - K * P4) - K * P5) - K * P6;\n-   end Reduce;\n-\n-   ----------\n-   -- Sqrt --\n-   ----------\n-\n-   function Sqrt (X : Double) return Double is\n-      Result  : Double;\n-\n-   begin\n-      if X < 0.0 then\n-         raise Argument_Error;\n-      end if;\n-\n-      Asm (Template => \"fsqrt\",\n-           Outputs  => Double'Asm_Output (\"=t\", Result),\n-           Inputs   => Double'Asm_Input  (\"0\", X));\n-\n-      return Result;\n-   end Sqrt;\n-\n-   --------------------------------\n-   -- Other Elementary Functions --\n-   --------------------------------\n-\n-   --  These are built using the previously implemented basic functions\n-\n-   ----------\n-   -- Acos --\n-   ----------\n-\n-   function Acos (X : Double) return Double is\n-      Result  : Double;\n-\n-   begin\n-      Result := 2.0 * Atan (Sqrt ((1.0 - X) / (1.0 + X)));\n-\n-      --  The result value is NaN iff input was invalid\n-\n-      if Is_Nan (Result) then\n-         raise Argument_Error;\n-      end if;\n-\n-      return Result;\n-   end Acos;\n-\n-   ----------\n-   -- Asin --\n-   ----------\n-\n-   function Asin (X : Double) return Double is\n-      Result  : Double;\n-\n-   begin\n-      Result := Atan (X / Sqrt ((1.0 - X) * (1.0 + X)));\n-\n-      --  The result value is NaN iff input was invalid\n-\n-      if Is_Nan (Result) then\n-         raise Argument_Error;\n-      end if;\n-\n-      return Result;\n-   end Asin;\n-\n-   ---------\n-   -- Cos --\n-   ---------\n-\n-   function Cos (X : Double) return Double is\n-      Reduced_X : Double := abs X;\n-      Result    : Double;\n-      Quadrant  : Natural range 0 .. 3;\n-\n-   begin\n-      if Reduced_X > Pi / 4.0 then\n-         Reduce (Reduced_X, Quadrant);\n-\n-         case Quadrant is\n-            when 0 =>\n-               Asm (Template  => \"fcos\",\n-                  Outputs  => Double'Asm_Output (\"=t\", Result),\n-                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n-\n-            when 1 =>\n-               Asm (Template  => \"fsin\",\n-                  Outputs  => Double'Asm_Output (\"=t\", Result),\n-                  Inputs   => Double'Asm_Input  (\"0\", -Reduced_X));\n-\n-            when 2 =>\n-               Asm (Template  => \"fcos ; fchs\",\n-                  Outputs  => Double'Asm_Output (\"=t\", Result),\n-                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n-\n-            when 3 =>\n-               Asm (Template  => \"fsin\",\n-                  Outputs  => Double'Asm_Output (\"=t\", Result),\n-                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n-         end case;\n-\n-      else\n-         Asm (Template  => \"fcos\",\n-              Outputs  => Double'Asm_Output (\"=t\", Result),\n-              Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n-      end if;\n-\n-      return Result;\n-   end Cos;\n-\n-   ---------------------\n-   -- Logarithmic_Pow --\n-   ---------------------\n-\n-   function Logarithmic_Pow (X, Y : Double) return Double is\n-      Result  : Double;\n-   begin\n-      Asm (Template => \"\"             --  X                  : Y\n-       & \"fyl2x                \" & NL --  Y * Log2 (X)\n-       & \"fld     %%st(0)      \" & NL --  Y * Log2 (X)       : Y * Log2 (X)\n-       & \"frndint              \" & NL --  Int (...)          : Y * Log2 (X)\n-       & \"fsubr   %%st, %%st(1)\" & NL --  Int (...)          : Fract (...)\n-       & \"fxch                 \" & NL --  Fract (...)        : Int (...)\n-       & \"f2xm1                \" & NL --  2**Fract (...) - 1 : Int (...)\n-       & \"fld1                 \" & NL --  1 : 2**Fract (...) - 1 : Int (...)\n-       & \"faddp   %%st, %%st(1)\" & NL --  2**Fract (...)     : Int (...)\n-       & \"fscale               \",     --  2**(Fract (...) + Int (...))\n-         Outputs  => Double'Asm_Output (\"=t\", Result),\n-         Inputs   =>\n-           (Double'Asm_Input  (\"0\", X),\n-            Double'Asm_Input  (\"u\", Y)));\n-      return Result;\n-   end Logarithmic_Pow;\n-\n-   ---------\n-   -- Pow --\n-   ---------\n-\n-   function Pow (X, Y : Double) return Double is\n-      type Mantissa_Type is mod 2**Double'Machine_Mantissa;\n-      --  Modular type that can hold all bits of the mantissa of Double\n-\n-      --  For negative exponents, do divide at the end of the processing\n-\n-      Negative_Y : constant Boolean := Y < 0.0;\n-      Abs_Y      : constant Double := abs Y;\n-\n-      --  During this function the following invariant is kept:\n-      --  X ** (abs Y) = Base**(Exp_High + Exp_Mid + Exp_Low) * Factor\n-\n-      Base : Double := X;\n-\n-      Exp_High : Double := Double'Floor (Abs_Y);\n-      Exp_Mid  : Double;\n-      Exp_Low  : Double;\n-      Exp_Int  : Mantissa_Type;\n-\n-      Factor : Double := 1.0;\n-\n-   begin\n-      --  Select algorithm for calculating Pow (integer cases fall through)\n-\n-      if Exp_High >= 2.0**Double'Machine_Mantissa then\n-\n-         --  In case of Y that is IEEE infinity, just raise constraint error\n-\n-         if Exp_High > Double'Safe_Last then\n-            raise Constraint_Error;\n-         end if;\n-\n-         --  Large values of Y are even integers and will stay integer\n-         --  after division by two.\n-\n-         loop\n-            --  Exp_Mid and Exp_Low are zero, so\n-            --    X**(abs Y) = Base ** Exp_High = (Base**2) ** (Exp_High / 2)\n-\n-            Exp_High := Exp_High / 2.0;\n-            Base := Base * Base;\n-            exit when Exp_High < 2.0**Double'Machine_Mantissa;\n-         end loop;\n-\n-      elsif Exp_High /= Abs_Y then\n-         Exp_Low := Abs_Y - Exp_High;\n-         Factor := 1.0;\n-\n-         if Exp_Low /= 0.0 then\n-\n-            --  Exp_Low now is in interval (0.0, 1.0)\n-            --  Exp_Mid := Double'Floor (Exp_Low * 4.0) / 4.0;\n-\n-            Exp_Mid := 0.0;\n-            Exp_Low := Exp_Low - Exp_Mid;\n-\n-            if Exp_Low >= 0.5 then\n-               Factor := Sqrt (X);\n-               Exp_Low := Exp_Low - 0.5;  -- exact\n-\n-               if Exp_Low >= 0.25 then\n-                  Factor := Factor * Sqrt (Factor);\n-                  Exp_Low := Exp_Low - 0.25; --  exact\n-               end if;\n-\n-            elsif Exp_Low >= 0.25 then\n-               Factor := Sqrt (Sqrt (X));\n-               Exp_Low := Exp_Low - 0.25; --  exact\n-            end if;\n-\n-            --  Exp_Low now is in interval (0.0, 0.25)\n-\n-            --  This means it is safe to call Logarithmic_Pow\n-            --  for the remaining part.\n-\n-            Factor := Factor * Logarithmic_Pow (X, Exp_Low);\n-         end if;\n-\n-      elsif X = 0.0 then\n-         return 0.0;\n-      end if;\n-\n-      --  Exp_High is non-zero integer smaller than 2**Double'Machine_Mantissa\n-\n-      Exp_Int := Mantissa_Type (Exp_High);\n-\n-      --  Standard way for processing integer powers > 0\n-\n-      while Exp_Int > 1 loop\n-         if (Exp_Int and 1) = 1 then\n-\n-            --  Base**Y = Base**(Exp_Int - 1) * Exp_Int for Exp_Int > 0\n-\n-            Factor := Factor * Base;\n-         end if;\n-\n-         --  Exp_Int is even and Exp_Int > 0, so\n-         --    Base**Y = (Base**2)**(Exp_Int / 2)\n-\n-         Base := Base * Base;\n-         Exp_Int := Exp_Int / 2;\n-      end loop;\n-\n-      --  Exp_Int = 1 or Exp_Int = 0\n-\n-      if Exp_Int = 1 then\n-         Factor := Base * Factor;\n-      end if;\n-\n-      if Negative_Y then\n-         Factor := 1.0 / Factor;\n-      end if;\n-\n-      return Factor;\n-   end Pow;\n-\n-   ---------\n-   -- Sin --\n-   ---------\n-\n-   function Sin (X : Double) return Double is\n-      Reduced_X : Double := X;\n-      Result    : Double;\n-      Quadrant  : Natural range 0 .. 3;\n-\n-   begin\n-      if abs X > Pi / 4.0 then\n-         Reduce (Reduced_X, Quadrant);\n-\n-         case Quadrant is\n-            when 0 =>\n-               Asm (Template  => \"fsin\",\n-                  Outputs  => Double'Asm_Output (\"=t\", Result),\n-                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n-\n-            when 1 =>\n-               Asm (Template  => \"fcos\",\n-                  Outputs  => Double'Asm_Output (\"=t\", Result),\n-                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n-\n-            when 2 =>\n-               Asm (Template  => \"fsin\",\n-                  Outputs  => Double'Asm_Output (\"=t\", Result),\n-                  Inputs   => Double'Asm_Input  (\"0\", -Reduced_X));\n-\n-            when 3 =>\n-               Asm (Template  => \"fcos ; fchs\",\n-                  Outputs  => Double'Asm_Output (\"=t\", Result),\n-                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n-         end case;\n-\n-      else\n-         Asm (Template  => \"fsin\",\n-            Outputs  => Double'Asm_Output (\"=t\", Result),\n-            Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n-      end if;\n-\n-      return Result;\n-   end Sin;\n-\n-   ---------\n-   -- Tan --\n-   ---------\n-\n-   function Tan (X : Double) return Double is\n-      Reduced_X : Double := X;\n-      Result    : Double;\n-      Quadrant  : Natural range 0 .. 3;\n-\n-   begin\n-      if abs X > Pi / 4.0 then\n-         Reduce (Reduced_X, Quadrant);\n-\n-         if Quadrant mod 2 = 0 then\n-            Asm (Template  => \"fptan\" & NL\n-                            & \"ffree   %%st(0)\"  & NL\n-                            & \"fincstp\",\n-                  Outputs  => Double'Asm_Output (\"=t\", Result),\n-                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n-         else\n-            Asm (Template  => \"fsincos\" & NL\n-                            & \"fdivp   %%st, %%st(1)\" & NL\n-                            & \"fchs\",\n-                  Outputs  => Double'Asm_Output (\"=t\", Result),\n-                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n-         end if;\n-\n-      else\n-         Asm (Template  =>\n-               \"fptan                 \" & NL\n-             & \"ffree   %%st(0)      \" & NL\n-             & \"fincstp              \",\n-               Outputs  => Double'Asm_Output (\"=t\", Result),\n-               Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n-      end if;\n-\n-      return Result;\n-   end Tan;\n-\n-   ----------\n-   -- Sinh --\n-   ----------\n-\n-   function Sinh (X : Double) return Double is\n-   begin\n-      --  Mathematically Sinh (x) is defined to be (Exp (X) - Exp (-X)) / 2.0\n-\n-      if abs X < 25.0 then\n-         return (Exp (X) - Exp (-X)) / 2.0;\n-      else\n-         return Exp (X) / 2.0;\n-      end if;\n-   end Sinh;\n-\n-   ----------\n-   -- Cosh --\n-   ----------\n-\n-   function Cosh (X : Double) return Double is\n-   begin\n-      --  Mathematically Cosh (X) is defined to be (Exp (X) + Exp (-X)) / 2.0\n-\n-      if abs X < 22.0 then\n-         return (Exp (X) + Exp (-X)) / 2.0;\n-      else\n-         return Exp (X) / 2.0;\n-      end if;\n-   end Cosh;\n-\n-   ----------\n-   -- Tanh --\n-   ----------\n-\n-   function Tanh (X : Double) return Double is\n-   begin\n-      --  Return the Hyperbolic Tangent of x\n-\n-      --                                    x    -x\n-      --                                   e  - e        Sinh (X)\n-      --       Tanh (X) is defined to be -----------   = --------\n-      --                                    x    -x      Cosh (X)\n-      --                                   e  + e\n-\n-      if abs X > 23.0 then\n-         return Double'Copy_Sign (1.0, X);\n-      end if;\n-\n-      return 1.0 / (1.0 + Exp (-(2.0 * X))) - 1.0 / (1.0 + Exp (2.0 * X));\n-   end Tanh;\n-\n-end Ada.Numerics.Aux;"}]}