{"sha": "e8e029df92f4c7e313dfff56efb71614f99ba10e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThlMDI5ZGY5MmY0YzdlMzEzZGZmZjU2ZWZiNzE2MTRmOTliYTEwZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2012-04-12T22:26:24Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2012-04-12T22:26:24Z"}, "message": "re PR target/52828 (powerpc -m32 -Os writes register saves below stack)\n\n\tPR target/52828\n\t* config/rs6000/rs6000.c (rs6000_emit_stack_tie): Rewrite with\n\ttie regs on destination of sets.  Delete forward declaration.\n\t(rs6000_emit_stack_reset): Update rs6000_emit_stack_tie calls.\n\t(rs6000_emit_prologue): Likewise.\n\t(rs6000_emit_epilogue): Likewise.  Use in place of gen_frame_tie\n\tand gen_stack_tie.\n\t(is_mem_ref): Use tie_operand to recognise stack ties.\n\t* config/rs6000/predicates.md (tie_operand): New.\n\t* config/rs6000/rs6000.md (restore_stack_block): Generate new\n\tstack tie rtl.\n\t(restore_stack_nonlocal): Likewise.\n\t(stack_tie): Update.\n\t(frame_tie): Delete.\n\nFrom-SVN: r186397", "tree": {"sha": "6640c5144f749e378fc48a81bdb1a2b777ec9629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6640c5144f749e378fc48a81bdb1a2b777ec9629"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8e029df92f4c7e313dfff56efb71614f99ba10e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e029df92f4c7e313dfff56efb71614f99ba10e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8e029df92f4c7e313dfff56efb71614f99ba10e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e029df92f4c7e313dfff56efb71614f99ba10e/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ede5f2c24b169223b884bfbbd198edc61d057ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ede5f2c24b169223b884bfbbd198edc61d057ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ede5f2c24b169223b884bfbbd198edc61d057ce"}], "stats": {"total": 114, "additions": 73, "deletions": 41}, "files": [{"sha": "3c0bb61aa3ca181ad7d1d54d00e5ef727a571e18", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e029df92f4c7e313dfff56efb71614f99ba10e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e029df92f4c7e313dfff56efb71614f99ba10e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8e029df92f4c7e313dfff56efb71614f99ba10e", "patch": "@@ -1,3 +1,20 @@\n+2012-04-13  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/52828\n+\t* config/rs6000/rs6000.c (rs6000_emit_stack_tie): Rewrite with\n+\ttie regs on destination of sets.  Delete forward declaration.\n+\t(rs6000_emit_stack_reset): Update rs6000_emit_stack_tie calls.\n+\t(rs6000_emit_prologue): Likewise.\n+\t(rs6000_emit_epilogue): Likewise.  Use in place of gen_frame_tie\n+\tand gen_stack_tie.\n+\t(is_mem_ref): Use tie_operand to recognise stack ties.\n+\t* config/rs6000/predicates.md (tie_operand): New.\n+\t* config/rs6000/rs6000.md (restore_stack_block): Generate new\n+\tstack tie rtl.\n+\t(restore_stack_nonlocal): Likewise.\n+\t(stack_tie): Update.\n+\t(frame_tie): Delete.\n+\n 2012-04-12  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* tree-ssa-reassoc.c (attempt_builtin_powi_stats): Change %ld to"}, {"sha": "232773d5d142a64ed5512593da15c0422d484ffe", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e029df92f4c7e313dfff56efb71614f99ba10e/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e029df92f4c7e313dfff56efb71614f99ba10e/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=e8e029df92f4c7e313dfff56efb71614f99ba10e", "patch": "@@ -1451,3 +1451,13 @@\n \n   return 1;\n })\n+\n+;; Return 1 if OP is a stack tie operand.\n+(define_predicate \"tie_operand\"\n+  (match_code \"parallel\")\n+{\n+  return (GET_CODE (XVECEXP (op, 0, 0)) == SET\n+\t  && GET_CODE (XEXP (XVECEXP (op, 0, 0), 0)) == MEM\n+\t  && GET_MODE (XEXP (XVECEXP (op, 0, 0), 0)) == BLKmode\n+\t  && XEXP (XVECEXP (op, 0, 0), 1) == const0_rtx);\n+})"}, {"sha": "ceb6448742ce0a53c587869a21d15a704015430e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e029df92f4c7e313dfff56efb71614f99ba10e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e029df92f4c7e313dfff56efb71614f99ba10e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e8e029df92f4c7e313dfff56efb71614f99ba10e", "patch": "@@ -925,7 +925,6 @@ static const char *rs6000_invalid_within_doloop (const_rtx);\n static bool rs6000_legitimate_address_p (enum machine_mode, rtx, bool);\n static bool rs6000_debug_legitimate_address_p (enum machine_mode, rtx, bool);\n static rtx rs6000_generate_compare (rtx, enum machine_mode);\n-static void rs6000_emit_stack_tie (void);\n static bool spe_func_has_64bit_regs_p (void);\n static rtx gen_frame_mem_offset (enum machine_mode, rtx, int);\n static unsigned rs6000_hash_constant (rtx);\n@@ -18505,12 +18504,29 @@ rs6000_aix_asm_output_dwarf_table_ref (char * frame_table_label)\n    and the change to the stack pointer.  */\n \n static void\n-rs6000_emit_stack_tie (void)\n+rs6000_emit_stack_tie (rtx fp, bool hard_frame_needed)\n {\n-  rtx mem = gen_frame_mem (BLKmode,\n-\t\t\t   gen_rtx_REG (Pmode, STACK_POINTER_REGNUM));\n+  rtvec p;\n+  int i;\n+  rtx regs[3];\n+\n+  i = 0;\n+  regs[i++] = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n+  if (hard_frame_needed)\n+    regs[i++] = gen_rtx_REG (Pmode, HARD_FRAME_POINTER_REGNUM);\n+  if (!(REGNO (fp) == STACK_POINTER_REGNUM\n+\t|| (hard_frame_needed\n+\t    && REGNO (fp) == HARD_FRAME_POINTER_REGNUM)))\n+    regs[i++] = fp;\n \n-  emit_insn (gen_stack_tie (mem));\n+  p = rtvec_alloc (i);\n+  while (--i >= 0)\n+    {\n+      rtx mem = gen_frame_mem (BLKmode, regs[i]);\n+      RTVEC_ELT (p, i) = gen_rtx_SET (VOIDmode, mem, const0_rtx);\n+    }\n+\n+  emit_insn (gen_stack_tie (gen_rtx_PARALLEL (VOIDmode, p)));\n }\n \n /* Emit the correct code for allocating stack space, as insns.\n@@ -19130,7 +19146,7 @@ rs6000_emit_stack_reset (rs6000_stack_t *info,\n       || (TARGET_SPE_ABI\n \t  && info->spe_64bit_regs_used != 0\n \t  && info->first_gp_reg_save != 32))\n-    rs6000_emit_stack_tie ();\n+    rs6000_emit_stack_tie (frame_reg_rtx, frame_pointer_needed);\n   \n   if (frame_reg_rtx != sp_reg_rtx)\n     {\n@@ -19350,7 +19366,7 @@ rs6000_emit_prologue (void)\n \t}\n       rs6000_emit_allocate_stack (info->total_size, copy_reg);\n       if (frame_reg_rtx != sp_reg_rtx)\n-\trs6000_emit_stack_tie ();\n+\trs6000_emit_stack_tie (frame_reg_rtx, false);\n     }\n \n   /* Handle world saves specially here.  */\n@@ -19854,7 +19870,7 @@ rs6000_emit_prologue (void)\n \tsp_offset = info->total_size;\n       rs6000_emit_allocate_stack (info->total_size, copy_reg);\n       if (frame_reg_rtx != sp_reg_rtx)\n-\trs6000_emit_stack_tie ();\n+\trs6000_emit_stack_tie (frame_reg_rtx, false);\n     }\n \n   /* Set frame pointer, if needed.  */\n@@ -20425,13 +20441,7 @@ rs6000_emit_epilogue (int sibcall)\n       /* Prevent reordering memory accesses against stack pointer restore.  */\n       else if (cfun->calls_alloca\n \t       || offset_below_red_zone_p (-info->total_size))\n-\t{\n-\t  rtx mem1 = gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx);\n-\t  rtx mem2 = gen_rtx_MEM (BLKmode, sp_reg_rtx);\n-\t  MEM_NOTRAP_P (mem1) = 1;\n-\t  MEM_NOTRAP_P (mem2) = 1;\n-\t  emit_insn (gen_frame_tie (mem1, mem2));\n-\t}\n+\trs6000_emit_stack_tie (frame_reg_rtx, true);\n \n       insn = emit_insn (gen_add3_insn (frame_reg_rtx, hard_frame_pointer_rtx,\n \t\t\t\t       GEN_INT (info->total_size)));\n@@ -20444,11 +20454,7 @@ rs6000_emit_epilogue (int sibcall)\n       /* Prevent reordering memory accesses against stack pointer restore.  */\n       if (cfun->calls_alloca\n \t  || offset_below_red_zone_p (-info->total_size))\n-\t{\n-\t  rtx mem = gen_rtx_MEM (BLKmode, sp_reg_rtx);\n-\t  MEM_NOTRAP_P (mem) = 1;\n-\t  emit_insn (gen_stack_tie (mem));\n-\t}\n+\trs6000_emit_stack_tie (frame_reg_rtx, false);\n       insn = emit_insn (gen_add3_insn (sp_reg_rtx, sp_reg_rtx,\n \t\t\t\t       GEN_INT (info->total_size)));\n       sp_offset = 0;\n@@ -22835,8 +22841,7 @@ is_mem_ref (rtx pat)\n   bool ret = false;\n \n   /* stack_tie does not produce any real memory traffic.  */\n-  if (GET_CODE (pat) == UNSPEC\n-      && XINT (pat, 1) == UNSPEC_TIE)\n+  if (tie_operand (pat, VOIDmode))\n     return false;\n \n   if (GET_CODE (pat) == MEM)"}, {"sha": "3d271695b94dbdabf336f648993fc3f9c6aae20f", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8e029df92f4c7e313dfff56efb71614f99ba10e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8e029df92f4c7e313dfff56efb71614f99ba10e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=e8e029df92f4c7e313dfff56efb71614f99ba10e", "patch": "@@ -73,7 +73,6 @@\n (define_c_enum \"unspec\"\n   [UNSPEC_FRSP\t\t\t; frsp for POWER machines\n    UNSPEC_PROBE_STACK\t\t; probe stack memory reference\n-   UNSPEC_TIE\t\t\t; tie stack contents and stack pointer\n    UNSPEC_TOCPTR\t\t; address of a word pointing to the TOC\n    UNSPEC_TOC\t\t\t; address of the TOC (more-or-less)\n    UNSPEC_MOVSI_GOT\n@@ -11989,17 +11988,23 @@\n (define_expand \"restore_stack_block\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 4) (match_dup 2))\n-   (set (match_dup 5) (unspec:BLK [(match_dup 5)] UNSPEC_TIE))\n+   (match_dup 5)\n    (set (match_operand 0 \"register_operand\" \"\")\n \t(match_operand 1 \"register_operand\" \"\"))]\n   \"\"\n   \"\n {\n+  rtvec p;\n+\n   operands[1] = force_reg (Pmode, operands[1]);\n   operands[2] = gen_reg_rtx (Pmode);\n   operands[3] = gen_frame_mem (Pmode, operands[0]);\n   operands[4] = gen_frame_mem (Pmode, operands[1]);\n-  operands[5] = gen_frame_mem (BLKmode, operands[0]);\n+  p = rtvec_alloc (1);\n+  RTVEC_ELT (p, 0) = gen_rtx_SET (VOIDmode,\n+\t\t\t\t  gen_frame_mem (BLKmode, operands[0]),\n+\t\t\t\t  const0_rtx);\n+  operands[5] = gen_rtx_PARALLEL (VOIDmode, p);\n }\")\n \n (define_expand \"save_stack_nonlocal\"\n@@ -12022,20 +12027,25 @@\n   [(set (match_dup 2) (match_operand 1 \"memory_operand\" \"\"))\n    (set (match_dup 3) (match_dup 4))\n    (set (match_dup 5) (match_dup 2))\n-   (set (match_dup 6) (unspec:BLK [(match_dup 6)] UNSPEC_TIE))\n+   (match_dup 6)\n    (set (match_operand 0 \"register_operand\" \"\") (match_dup 3))]\n   \"\"\n   \"\n {\n   int units_per_word = (TARGET_32BIT) ? 4 : 8;\n+  rtvec p;\n \n   /* Restore the backchain from the first word, sp from the second.  */\n   operands[2] = gen_reg_rtx (Pmode);\n   operands[3] = gen_reg_rtx (Pmode);\n   operands[1] = adjust_address_nv (operands[1], Pmode, 0);\n   operands[4] = adjust_address_nv (operands[1], Pmode, units_per_word);\n   operands[5] = gen_frame_mem (Pmode, operands[3]);\n-  operands[6] = gen_frame_mem (BLKmode, operands[0]);\n+  p = rtvec_alloc (1);\n+  RTVEC_ELT (p, 0) = gen_rtx_SET (VOIDmode,\n+\t\t\t\t  gen_frame_mem (BLKmode, operands[0]),\n+\t\t\t\t  const0_rtx);\n+  operands[6] = gen_rtx_PARALLEL (VOIDmode, p);\n }\")\n \f\n ;; TOC register handling.\n@@ -15899,25 +15909,15 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4\")])\n \n-; These are to explain that changes to the stack pointer should\n-; not be moved over stores to stack memory.\n+; This is to explain that changes to the stack pointer should\n+; not be moved over loads from or stores to stack memory.\n (define_insn \"stack_tie\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"+m\")\n-        (unspec:BLK [(match_dup 0)] UNSPEC_TIE))]\n-  \"\"\n-  \"\"\n-  [(set_attr \"length\" \"0\")])\n-\n-; Like stack_tie, but depend on both fp and sp based memory.\n-(define_insn \"frame_tie\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"+m\")\n-\t(unspec:BLK [(match_dup 0)\n-\t\t     (match_operand:BLK 1 \"memory_operand\" \"m\")] UNSPEC_TIE))]\n+  [(match_parallel 0 \"tie_operand\"\n+\t\t   [(set (mem:BLK (reg 1)) (const_int 0))])]\n   \"\"\n   \"\"\n   [(set_attr \"length\" \"0\")])\n \n-\n (define_expand \"epilogue\"\n   [(use (const_int 0))]\n   \"\""}]}