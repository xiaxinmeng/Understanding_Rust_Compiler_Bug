{"sha": "46327bc509a091ca9def304efd65b37110160d24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYzMjdiYzUwOWEwOTFjYTlkZWYzMDRlZmQ2NWIzNzExMDE2MGQyNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-06-13T23:36:19Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-06-13T23:36:19Z"}, "message": "libgcc2.c (ia64_throw_helper): Use __builtin_return_address.\n\n        * libgcc2.c (ia64_throw_helper): Use __builtin_return_address.\n        (__throw): Don't pass the address of a label.\n\n        * config/ia64/ia64.c (ia64_compute_frame_size): Use\n        current_function_is_leaf.\n        (ia64_expand_prologue): Likewise.  Modify return_address_pointer_rtx\n        instead of reg_names[RETURN_ADDRESS_REGNUM].\n        (ia64_init_machine_status): Reset return_address_pointer_rtx.\n        * config/ia64/ia64.h (RETURN_ADDRESS_POINTER_REGNUM): Rename\n        from RETURN_ADDRESS_REGNUM.  Update all uses.\n        (RETURN_ADDR_RTX): Use return_address_pointer_rtx; return\n        zero instead of null on failure.\n        (ELIMINABLE_REGS): Add ra->b0 elimination.\n        (CAN_ELIMINATE): Update accordingly.\n        (INITIAL_ELIMINATION_OFFSET): Likewise.\n        (REGISTER_NAMES): Use an illegal assembler name for\n        RETURN_ADDRESS_POINTER_REGNUM.\n\nFrom-SVN: r34531", "tree": {"sha": "e3050ff52fc29f7a4264af25f0952023d18cc9ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3050ff52fc29f7a4264af25f0952023d18cc9ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46327bc509a091ca9def304efd65b37110160d24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46327bc509a091ca9def304efd65b37110160d24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46327bc509a091ca9def304efd65b37110160d24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46327bc509a091ca9def304efd65b37110160d24/comments", "author": null, "committer": null, "parents": [{"sha": "13da91fd236bc0d0b3cb773eed729cb35044848b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13da91fd236bc0d0b3cb773eed729cb35044848b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13da91fd236bc0d0b3cb773eed729cb35044848b"}], "stats": {"total": 90, "additions": 52, "deletions": 38}, "files": [{"sha": "54b253d0aeb17007a2b72675e20f562d34d9ea87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46327bc509a091ca9def304efd65b37110160d24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46327bc509a091ca9def304efd65b37110160d24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46327bc509a091ca9def304efd65b37110160d24", "patch": "@@ -1,3 +1,23 @@\n+2000-06-13  Richard Henderson  <rth@cygnus.com>\n+\n+\t* libgcc2.c (ia64_throw_helper): Use __builtin_return_address.\n+\t(__throw): Don't pass the address of a label.\n+\n+\t* config/ia64/ia64.c (ia64_compute_frame_size): Use\n+\tcurrent_function_is_leaf.\n+\t(ia64_expand_prologue): Likewise.  Modify return_address_pointer_rtx\n+\tinstead of reg_names[RETURN_ADDRESS_REGNUM].\n+\t(ia64_init_machine_status): Reset return_address_pointer_rtx.\n+\t* config/ia64/ia64.h (RETURN_ADDRESS_POINTER_REGNUM): Rename\n+\tfrom RETURN_ADDRESS_REGNUM.  Update all uses.\n+\t(RETURN_ADDR_RTX): Use return_address_pointer_rtx; return\n+\tzero instead of null on failure.\n+\t(ELIMINABLE_REGS): Add ra->b0 elimination.\n+\t(CAN_ELIMINATE): Update accordingly.\n+\t(INITIAL_ELIMINATION_OFFSET): Likewise.\n+\t(REGISTER_NAMES): Use an illegal assembler name for\n+\tRETURN_ADDRESS_POINTER_REGNUM.\n+\n 2000-06-13  Richard Henderson  <rth@cygnus.com>\n \n \t* config/ia64/ia64.h (enum reg_class): Remove FR_INT_REGS, FR_FP_REGS,"}, {"sha": "88aa7d23d2c2d0bddc1a26cd78796c2d5ad232fc", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46327bc509a091ca9def304efd65b37110160d24/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46327bc509a091ca9def304efd65b37110160d24/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=46327bc509a091ca9def304efd65b37110160d24", "patch": "@@ -607,10 +607,9 @@ ia64_compute_frame_size (size)\n   total_size = IA64_STACK_ALIGN (tmp);\n   extra_size = total_size - tmp + 16;\n \n-  /* If this is a leaf routine (BR_REG (0) is not live), and if there is no\n-     stack space needed for register saves, then don't allocate the 16 byte\n-     scratch area.  */\n-  if (total_size == 16 && ! regs_ever_live[BR_REG (0)])\n+  /* If this is a leaf routine, and if there is no stack space needed for\n+     register saves, then don't allocate the 16 byte scratch area.  */\n+  if (total_size == 16 && current_function_is_leaf)\n     {\n       total_size = 0;\n       extra_size = 0;\n@@ -812,18 +811,9 @@ ia64_expand_prologue ()\n   rtx insn, offset;\n   int i, locals, inputs, outputs, rotates;\n   int frame_size = ia64_compute_frame_size (get_frame_size ());\n-  int leaf_function;\n   int epilogue_p;\n   edge e;\n \n-  /* ??? This seems like a leaf_function_p bug.  It calls get_insns which\n-     returns the first insn of the current sequence, not the first insn\n-     of the function.  We work around this by pushing to the topmost\n-     sequence first.  */\n-  push_topmost_sequence ();\n-  leaf_function = leaf_function_p ();\n-  pop_topmost_sequence ();\n-\n   /* If there is no epilogue, then we don't need some prologue insns.  We\n      need to avoid emitting the dead prologue insns, because flow will complain\n      about them.  */\n@@ -941,7 +931,7 @@ ia64_expand_prologue ()\n      locals and outputs are both zero sized.  Since we have already allocated\n      two locals for rp and ar.pfs, we check for two locals.  */\n   /* Leaf functions can use output registers as call-clobbered temporaries.  */\n-  if (locals == 2 && outputs == 0 && leaf_function)\n+  if (locals == 2 && outputs == 0 && current_function_is_leaf)\n     {\n       /* If there is no alloc, but there are input registers used, then we\n \t need a .regstk directive.  */\n@@ -966,13 +956,11 @@ ia64_expand_prologue ()\n       /* Emit a save of BR_REG (0) if we call other functions.\n \t Do this even if this function doesn't return, as EH\n          depends on this to be able to unwind the stack.  */\n-      if (! leaf_function)\n+      if (! current_function_is_leaf)\n \t{\n \t  rtx ia64_rp_reg;\n \n \t  ia64_rp_regno = LOC_REG (locals - 2);\n-\t  reg_names[RETURN_ADDRESS_REGNUM] = reg_names[ia64_rp_regno];\n-\n \t  ia64_rp_reg = gen_rtx_REG (DImode, ia64_rp_regno);\n \t  insn = emit_move_insn (ia64_rp_reg, gen_rtx_REG (DImode,\n \t\t\t\t\t\t\t   BR_REG (0)));\n@@ -984,6 +972,10 @@ ia64_expand_prologue ()\n \t\t appear dead and will elicit a warning from flow.  */\n \t      emit_insn (gen_rtx_USE (VOIDmode, ia64_rp_reg));\n \t    }\n+\n+\t  /* Fix up the return address placeholder.  */\n+\t  if (regs_ever_live[RETURN_ADDRESS_POINTER_REGNUM])\n+\t    XINT (return_address_pointer_rtx, 0) = ia64_rp_regno;\n \t}\n       else\n \tia64_rp_regno = 0;\n@@ -2113,6 +2105,9 @@ ia64_init_machine_status (p)\n {\n   p->machine =\n     (struct machine_function *) xcalloc (1, sizeof (struct machine_function));\n+\n+  /* Reset from the previous function's potential modifications.  */\n+  XINT (return_address_pointer_rtx, 0) = RETURN_ADDRESS_POINTER_REGNUM;\n }\n \n static void"}, {"sha": "0dadc512f56e2af918a5528f7c433e0bf7fb0428", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46327bc509a091ca9def304efd65b37110160d24/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46327bc509a091ca9def304efd65b37110160d24/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=46327bc509a091ca9def304efd65b37110160d24", "patch": "@@ -551,7 +551,7 @@ while (0)\n #define GENERAL_REGNO_P(REGNO) \\\n   (GR_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n    || (REGNO) == FRAME_POINTER_REGNUM\t\t\t\t\t\\\n-   || (REGNO) == RETURN_ADDRESS_REGNUM)\n+   || (REGNO) == RETURN_ADDRESS_POINTER_REGNUM)\n \n #define GR_REG(REGNO) ((REGNO) + 0)\n #define FR_REG(REGNO) ((REGNO) + 128)\n@@ -788,7 +788,7 @@ while (0)\n   /* Special branch registers.  */\t\t\t\t\t   \\\n   R_BR (0),\t\t\t\t\t\t\t\t   \\\n   /* Frame pointer.  Return address.  */\t\t\t\t   \\\n-  FRAME_POINTER_REGNUM, RETURN_ADDRESS_REGNUM,\t\t\t\t   \\\n+  FRAME_POINTER_REGNUM, RETURN_ADDRESS_POINTER_REGNUM,\t\t\t   \\\n }\n \n \f\n@@ -1110,13 +1110,8 @@ enum reg_class\n    unwind info, so we don't try to support them.  We would also need to define\n    DYNAMIC_CHAIN_ADDRESS and SETUP_FRAME_ADDRESS (for the reg stack flush).  */\n \n-/* ??? This only works for non-leaf functions.  In a leaf function, the return\n-   address would be in b0 (rp).  */\n-\n-#define RETURN_ADDR_RTX(COUNT, FRAMEADDR) \\\n-  (((COUNT) == 0)\t\t\t\t\t\t\t\\\n-   ? gen_rtx_REG (Pmode, RETURN_ADDRESS_REGNUM)\t\t\t\t\\\n-   : (rtx) 0)\n+#define RETURN_ADDR_RTX(COUNT, FRAME) \\\n+  ((COUNT) == 0 ? return_address_pointer_rtx : const0_rtx)\n \n /* A C expression whose value is RTL representing the location of the incoming\n    return address at the beginning of any function, before the prologue.  This\n@@ -1177,10 +1172,12 @@ extern int ia64_local_regs;\n    in it.  */\n #define ARG_POINTER_REGNUM R_GR(0)\n \n-/* The register number for the return address register.  This is modified by\n-   ia64_expand_prologue to point to the real return address save register.  */\n+/* The register number for the return address register.  This is not actually\n+   a pointer as the name suggests, but that's a name that gen_rtx_REG \n+   already takes care to keep unique.  We modify return_address_pointer_rtx\n+   in ia64_expand_prologue to reference the final output regnum.  */\n \n-#define RETURN_ADDRESS_REGNUM 329\n+#define RETURN_ADDRESS_POINTER_REGNUM 329\n \n /* Register numbers used for passing a function's static chain pointer.  */\n \n@@ -1202,14 +1199,15 @@ extern int ia64_local_regs;\n {\t\t\t\t\t\t\t\t\t\\\n   {ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM},\t\t\t\t\\\n   {ARG_POINTER_REGNUM,\t FRAME_POINTER_REGNUM},\t\t\t\t\\\n-  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}\t\t\t\t\\\n+  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\t\\\n+  {RETURN_ADDRESS_POINTER_REGNUM, BR_REG (0)}\t\t\t\t\\\n }\n \n /* A C expression that returns non-zero if the compiler is allowed to try to\n-   replace register number FROM with register number TO.  There are no ia64\n-   specific restrictions.  */\n+   replace register number FROM with register number TO.  */\n \n-#define CAN_ELIMINATE(FROM, TO) 1\n+#define CAN_ELIMINATE(FROM, TO) \\\n+  (TO == BR_REG (0) ? current_function_is_leaf : 1)\n \n /* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It specifies the\n    initial difference between the specified pair of registers.  This macro must\n@@ -1238,6 +1236,8 @@ extern int ia64_local_regs;\n \t  abort ();\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+  else if ((TO) == BR_REG (0))\t\t\t\t\t\t\\\n+    (OFFSET) = 0;\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     abort ();\t\t\t\t\t\t\t\t\\\n }\n@@ -2324,7 +2324,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   /* Branch registers.  */\t\t\t\t\t\t\\\n   \"b0\", \"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\",\t\t\t\\\n   /* Frame pointer.  Return address.  */\t\t\t\t\\\n-  \"fp\", \"ra\"\t\t\t\t\t\t\t\t\\\n+  \"sfp\", \"retaddr\"\t\t\t\t\t\t\t\\\n }\n \n /* If defined, a C initializer for an array of structures containing a name and"}, {"sha": "06c6fdd06b85aa750374785fbde7e7cd3e918bd9", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46327bc509a091ca9def304efd65b37110160d24/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46327bc509a091ca9def304efd65b37110160d24/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=46327bc509a091ca9def304efd65b37110160d24", "patch": "@@ -4043,12 +4043,12 @@ __ia64_personality_v1 (void *pc, old_exception_table *table)\n }\n \n static void\n-ia64_throw_helper (throw_pc, throw_frame, caller, throw_bsp)\n-     void *throw_pc;\n+ia64_throw_helper (throw_frame, caller, throw_bsp)\n      ia64_frame_state *throw_frame;\n      ia64_frame_state *caller;\n      void *throw_bsp;\n {\n+  void *throw_pc = __builtin_return_address (0);\n   unwind_info_ptr *info;\n   void *pc, *handler = NULL;\n   void *pc_base;\n@@ -4146,15 +4146,14 @@ __throw ()\n     __terminate ();\n \n   __builtin_unwind_init ();\n-label_ia64:\n   /* We have to call another routine to actually process the frame \n      information, which will force all of __throw's local registers into\n      backing store.  */\n \n   /* Get the value of ar.bsp while we're here.  */\n \n   bsp = __builtin_ia64_bsp ();\n-  ia64_throw_helper (&&label_ia64, &my_frame, &originator, bsp);\n+  ia64_throw_helper (&my_frame, &originator, bsp);\n \n   /* Now we have to fudge the bsp by the amount in our (__throw)\n      frame marker, since the return is going to adjust it by that much. */"}]}