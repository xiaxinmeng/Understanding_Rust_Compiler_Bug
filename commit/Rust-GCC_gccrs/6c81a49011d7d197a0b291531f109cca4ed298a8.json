{"sha": "6c81a49011d7d197a0b291531f109cca4ed298a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM4MWE0OTAxMWQ3ZDE5N2EwYjI5MTUzMWYxMDljY2E0ZWQyOThhOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-05-11T17:16:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-05-11T17:16:28Z"}, "message": "i386.md (testsi to testqi spliters): New.\n\n\t* i386.md (testsi to testqi spliters): New.\n\n\t2002-01-14  Josef Zlomek  <zlomek@matfyz.cz>\n\n\tcfg.c (dump_edge_info): added dumping of EDGE_CAN_FALLTHRU.\n\n\tWed Jan  9 2002  Josef Zlomek  <zlomj9am@artax.karlin.mff.cuni.cz>\n\n\t* basic-block.h: New flag EDGE_CAN_FALLTHRU\n\t* cfganal.c (set_edge_can_fallthru_flag): New function; marks the edges\n\tthat can be made fallthru.\n\n\tMon Nov 12 16:25:53 CET 2001  Jan Hubicka  <jh@suse.cz>\n\n\t* cfglayout.c (cleanup_unconditional_jumps): New static function.\n\t(cfg_layout_initialize): Use it.\n\nCo-Authored-By: Pavel Nejedly <bim@atrey.karlin.mff.cuni.cz>\n\nFrom-SVN: r53383", "tree": {"sha": "fa9e11cf8b568b8afe5c8d0febfdf02da5bbb8e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa9e11cf8b568b8afe5c8d0febfdf02da5bbb8e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c81a49011d7d197a0b291531f109cca4ed298a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c81a49011d7d197a0b291531f109cca4ed298a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c81a49011d7d197a0b291531f109cca4ed298a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c81a49011d7d197a0b291531f109cca4ed298a8/comments", "author": null, "committer": null, "parents": [{"sha": "a5c76ee6e2c613ac4c3e309e562d51bea137c73a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c76ee6e2c613ac4c3e309e562d51bea137c73a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5c76ee6e2c613ac4c3e309e562d51bea137c73a"}], "stats": {"total": 291, "additions": 218, "deletions": 73}, "files": [{"sha": "df060b25f278e19e4b9b5bc1d9b64b358e0d9bf0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 68, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c81a49011d7d197a0b291531f109cca4ed298a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c81a49011d7d197a0b291531f109cca4ed298a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c81a49011d7d197a0b291531f109cca4ed298a8", "patch": "@@ -1,43 +1,21 @@\n-2002-05-11  Zack Weinberg  <zack@codesourcery.com>\n-\n-\t* config/rs6000/rs6000.c (rs6000_default_long_calls,\n-\trs6000_longcall_switch, rs6000_set_default_type_attributes): New.\n-\t(TARGET_SET_DEFAULT_TYPE_ATTRIBUTES): Set it.\n-\t(rs6000_override_options): Handle -m(no-)longcall.\n-\t(init_cumulative_args, output_mi_thunk): Check for both\n-\tlongcall and shortcall attributes on the function.\n-\t(rs6000_attribute_table): Add \"shortcall\".\n-\t(rs6000_handle_longcall_attribute): Update comment.\n-\t(altivec_expand_unop_builtin, altivec_expand_binop_builtin,\n-\taltivec_expand_ternop_builtin): Add default clauses to switches\n-\tto silence warnings.\n-\n-\t* config/rs6000/rs6000.h: Declare rs6000_longcall_switch and\n-\trs6000_default_long_calls.  Define REGISTER_TARGET_PRAGMAS.\n-\t(TARGET_OPTIONS): Add longcall and no-longcall.\n-\n-\t* config/rs6000/rs6000.md (call_nonlocal_sysv,\n-\tcall_value_nonlocal_sysv): Split by alternatives.  One pair\n-\taccepts only SYMBOL_REFs and rejects if CALL_LONG is set in\n-\tthe call cookie.  The other pair accepts only LR/CTR and has\n-\tno restriction.\n-\n-\t* config.gcc (rs6000-*-* | powerpc*-*-* trailer stanza):\n-\tSet c_target_objs, cxx_target_objs; add t-rs6000-c-rule to\n-\ttmake_file.\n-\t* config/rs6000/rs6000-c.c: New file.\n-\t* config/rs6000/t-rs6000-c-rule: New file.\n-\t* config/rs6000/rs6000-protos.c: Add multiple-include guard.\n-\tPrototype rs6000_pragma_longcall.\n-\n-\t* doc/extend.texi: Document shortcall attribute.\n-\t* doc/invoke.texi: Document -mlongcall, -mno-longcall.\n-\n-2002-05-12  Marek Michalkiewicz  <marekm@amelek.gda.pl>\n-\n-\t* config/avr/avr.c (avr_mcu_types): Update supported devices.\n-\t* config/avr/avr.h (CPP_SPEC, LINK_SPEC, CRT_BINUTILS_SPECS): Likewise.\n-\t* config/avr/t-avr (MULTILIB_MATCHES): Likewise.\n+Sat May 11 14:34:35 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (testsi to testqi spliters): New.\n+\n+\t2002-01-14  Josef Zlomek  <zlomek@matfyz.cz>\n+\n+\tcfg.c (dump_edge_info): added dumping of EDGE_CAN_FALLTHRU.\n+\n+\tWed Jan  9 2002  Josef Zlomek  <zlomj9am@artax.karlin.mff.cuni.cz>\n+\n+\t* basic-block.h: New flag EDGE_CAN_FALLTHRU\n+\t* cfganal.c (set_edge_can_fallthru_flag): New function; marks the edges\n+\tthat can be made fallthru.\n+\n+\tMon Nov 12 16:25:53 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cfglayout.c (cleanup_unconditional_jumps): New static function.\n+\t(cfg_layout_initialize): Use it.\n \n 2002-05-11  Kazu Hirata  <kazu@cs.umass.edu>\n \n@@ -240,38 +218,38 @@ Thu May  9 14:52:45 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \t* final.c (end_final): Use C trees to output data structures for profiling.\n \n \t* Makefile.in (LIBGCC_DEPS): Added missing dependency on gcov-io.h\n-\t(profile.o): New dependency profile.h\n-\t(final.o): New dependency profile.h\n-\t* profile.h: New file. New global structure profile_info.\n-\t* final.h (count_edges_instrumented_now): Declare.\n-\t(current_function_cfg_checksum): Declare.\n-\t(function_list): New structure.\n-\t(functions_head, functions_tail): New static variables.\n-\t(end_final): Emits more data, removed some -ax stuff.\n-\t(final): Stores function names and chcksums.\n-\t* gcov-io.h (__write_gcov_string): New function.\n-\t(__read_gcov_string): New function.\n-\t* gcov.c (read_profile): New function.\n-\t(create_program_flow_graph): Uses read_profile instead of reading\n+        (profile.o): New dependency profile.h\n+        (final.o): New dependency profile.h\n+        * profile.h: New file. New global structure profile_info.\n+        * final.h (count_edges_instrumented_now): Declare.\n+        (current_function_cfg_checksum): Declare.\n+        (function_list): New structure.\n+        (functions_head, functions_tail): New static variables.\n+        (end_final): Emits more data, removed some -ax stuff.\n+        (final): Stores function names and chcksums.\n+        * gcov-io.h (__write_gcov_string): New function.\n+        (__read_gcov_string): New function.\n+        * gcov.c (read_profile): New function.\n+        (create_program_flow_graph): Uses read_profile instead of reading\n \tda_file.\n-\t(read_files): Removed da_file checking, it's done by read_profile now.\n-\t* libgcc2.c (bb_function_info): New structure.\n-\t(bb): New field in structure, removed some -ax stuff.\n-\t(__bb_exit_func): Changed structure of da_file.\n-\t* profile.c (count_edges_instrumented_now): New global variable.\n-\t(current_function_cfg_checksum): New global variable.\n-\t(max_counter_in_program): New global variable.\n-\t(get_exec_counts): New function.\n-\t(compute_checksum): New function.\n-\t(instrument_edges): Sets count_edges_instrumented_now.\n-\t(compute_branch_probabilities): Uses get_exec_counts instead of\n+        (read_files): Removed da_file checking, it's done by read_profile now.\n+        * libgcc2.c (bb_function_info): New structure.\n+        (bb): New field in structure, removed some -ax stuff.\n+        (__bb_exit_func): Changed structure of da_file.\n+        * profile.c (count_edges_instrumented_now): New global variable.\n+        (current_function_cfg_checksum): New global variable.\n+        (max_counter_in_program): New global variable.\n+        (get_exec_counts): New function.\n+        (compute_checksum): New function.\n+        (instrument_edges): Sets count_edges_instrumented_now.\n+        (compute_branch_probabilities): Uses get_exec_counts instead of\n \treading da_file.\n-\t(branch_prob): Calls compute_checksum and writes extra data to bbg_file.\n-\t(init_branch_prob): Removed da_file checking, done in get_exec_counts\n+        (branch_prob): Calls compute_checksum and writes extra data to bbg_file.\n+        (init_branch_prob): Removed da_file checking, done in get_exec_counts\n \tnow.\n-\t(end_branch_prob): Removed da_file checking, done in get_exec_counts\n+        (end_branch_prob): Removed da_file checking, done in get_exec_counts\n \tnow.\n-\t* gcov.texi: Updated information about gcov file format.\n+        * gcov.texi: Updated information about gcov file format.\n \n 2002-05-09  Kazu Hirata  <kazu@cs.umass.edu>\n "}, {"sha": "05b4b7c9002758a3129ac361e2bf92dd105266b7", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c81a49011d7d197a0b291531f109cca4ed298a8/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c81a49011d7d197a0b291531f109cca4ed298a8/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=6c81a49011d7d197a0b291531f109cca4ed298a8", "patch": "@@ -141,6 +141,7 @@ typedef struct edge_def {\n #define EDGE_EH\t\t\t8\n #define EDGE_FAKE\t\t16\n #define EDGE_DFS_BACK\t\t32\n+#define EDGE_CAN_FALLTHRU\t64\n \n #define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n \n@@ -699,6 +700,7 @@ extern conflict_graph conflict_graph_compute\n                                         PARAMS ((regset,\n \t\t\t\t\t\t partition));\n extern bool mark_dfs_back_edges\t\tPARAMS ((void));\n+extern void set_edge_can_fallthru_flag\tPARAMS ((void));\n extern void update_br_prob_note\t\tPARAMS ((basic_block));\n extern void fixup_abnormal_edges\tPARAMS ((void));\n "}, {"sha": "47dfb238ea593ac18b5ff43857534b8c8e028917", "filename": "gcc/cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c81a49011d7d197a0b291531f109cca4ed298a8/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c81a49011d7d197a0b291531f109cca4ed298a8/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=6c81a49011d7d197a0b291531f109cca4ed298a8", "patch": "@@ -609,7 +609,7 @@ dump_edge_info (file, e, do_succ)\n   if (e->flags)\n     {\n       static const char * const bitnames[]\n-\t= {\"fallthru\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\"};\n+\t= {\"fallthru\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\", \"can_fallthru\"};\n       int comma = 0;\n       int i, flags = e->flags;\n "}, {"sha": "a64124cfb79e0cf16832e73ff1107238e8e64bc2", "filename": "gcc/cfganal.c", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c81a49011d7d197a0b291531f109cca4ed298a8/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c81a49011d7d197a0b291531f109cca4ed298a8/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=6c81a49011d7d197a0b291531f109cca4ed298a8", "patch": "@@ -189,6 +189,36 @@ mark_dfs_back_edges ()\n   return found;\n }\n \n+/* Set the flag EDGE_CAN_FALLTHRU for edges that can be fallthru.  */\n+\n+void\n+set_edge_can_fallthru_flag ()\n+{\n+  int i;\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      edge e;\n+\n+      /* The FALLTHRU edge is also CAN_FALLTHRU edge.  */\n+      for (e = bb->succ; e; e = e->succ_next)\n+\tif (e->flags & EDGE_FALLTHRU)\n+\t  e->flags |= EDGE_CAN_FALLTHRU;\n+\n+      /* If the BB ends with an invertable condjump all (2) edges are\n+\t CAN_FALLTHRU edges.  */\n+      if (!bb->succ || !bb->succ->succ_next || bb->succ->succ_next->succ_next)\n+\tcontinue;\n+      if (!any_condjump_p (bb->end))\n+\tcontinue;\n+      if (!invert_jump (bb->end, JUMP_LABEL (bb->end), 0))\n+\tcontinue;\n+      invert_jump (bb->end, JUMP_LABEL (bb->end), 0);\n+      bb->succ->flags |= EDGE_CAN_FALLTHRU;\n+      bb->succ->succ_next->flags |= EDGE_CAN_FALLTHRU;\n+    }\n+}\n+\n /* Return true if we need to add fake edge to exit.\n    Helper function for the flow_call_edges_add.  */\n \n@@ -326,9 +356,12 @@ flow_call_edges_add (blocks)\n \n \t      /* Note that the following may create a new basic block\n \t\t and renumber the existing basic blocks.  */\n-\t      e = split_block (bb, split_at_insn);\n-\t      if (e)\n-\t\tblocks_split++;\n+\t      if (split_at_insn != bb->end)\n+\t\t{\n+\t\t  e = split_block (bb, split_at_insn);\n+\t\t  if (e)\n+\t\t    blocks_split++;\n+\t\t}\n \n \t      make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n \t    }"}, {"sha": "2820f0d5d9697e1c16b509184f9290d677641b8f", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c81a49011d7d197a0b291531f109cca4ed298a8/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c81a49011d7d197a0b291531f109cca4ed298a8/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=6c81a49011d7d197a0b291531f109cca4ed298a8", "patch": "@@ -46,6 +46,7 @@ static void set_block_levels\t\tPARAMS ((tree, int));\n static void change_scope\t\tPARAMS ((rtx, tree, tree));\n \n void verify_insn_chain\t\t\tPARAMS ((void));\n+static void cleanup_unconditional_jumps\tPARAMS ((void));\n static void fixup_fallthru_exit_predecessor PARAMS ((void));\n static rtx unlink_insn_chain PARAMS ((rtx, rtx));\n static rtx duplicate_insn_chain PARAMS ((rtx, rtx));\n@@ -578,6 +579,76 @@ verify_insn_chain ()\n     abort ();\n }\n \f\n+/* Remove any unconditional jumps and forwarder block creating fallthru\n+   edges instead.  During BB reordering fallthru edges are not required\n+   to target next basic block in the linear CFG layout, so the unconditional\n+   jumps are not needed.  If LOOPS is not null, also update loop structure &\n+   dominators.  */\n+\n+static void\n+cleanup_unconditional_jumps ()\n+{\n+  int i;\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+\n+      if (!bb->succ)\n+\tcontinue;\n+      if (bb->succ->flags & EDGE_FALLTHRU)\n+\tcontinue;\n+      if (!bb->succ->succ_next)\n+\t{\n+\t  rtx insn;\n+\t  if (GET_CODE (bb->head) != CODE_LABEL && forwarder_block_p (bb) && i)\n+\t    {\n+\t      basic_block prev = BASIC_BLOCK (--i);\n+\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file, \"Removing forwarder BB %i\\n\",\n+\t\t\t bb->index);\n+\n+\t      redirect_edge_succ (bb->pred, bb->succ->dest);\n+\t      flow_delete_block (bb);\n+\t      bb = prev;\n+\t    }\n+\t  else if (simplejump_p (bb->end))\n+\t    {\n+\t      rtx jump = bb->end;\n+\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file, \"Removing jump %i in BB %i\\n\",\n+\t\t\t INSN_UID (jump), bb->index);\n+\t      delete_insn (jump);\n+\t      bb->succ->flags |= EDGE_FALLTHRU;\n+\t    }\n+\t  else\n+\t    continue;\n+\n+\t  /* Cleanup barriers and delete ADDR_VECs in a way as they are belonging\n+             to removed tablejump anyway.  */\n+\t  insn = NEXT_INSN (bb->end);\n+\t  while (insn\n+\t\t && (GET_CODE (insn) != NOTE\n+\t\t     || NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK))\n+\t    {\n+\t      rtx next = NEXT_INSN (insn);\n+\n+\t      if (GET_CODE (insn) == BARRIER)\n+\t\tdelete_barrier (insn);\n+\t      else if (GET_CODE (insn) == JUMP_INSN)\n+\t\tdelete_insn_chain (PREV_INSN (insn), insn);\n+\t      else if (GET_CODE (insn) == CODE_LABEL)\n+\t\t;\n+\t      else if (GET_CODE (insn) != NOTE)\n+\t\tabort ();\n+\n+\t      insn = next;\n+\t    }\n+\t}\n+    }\n+}\n+\f\n /* The block falling through to exit must be the last one in the\n    reordered chain.  Ensure that this condition is met.  */\n static void\n@@ -767,6 +838,14 @@ cfg_layout_redirect_edge (e, dest)\n     }\n   else\n     redirect_edge_and_branch (e, dest);\n+\n+  /* We don't want simplejumps in the insn stream during cfglayout.  */\n+  if (simplejump_p (src->end))\n+    {\n+      delete_insn (src->end);\n+      delete_barrier (NEXT_INSN (src->end));\n+      src->succ->flags |= EDGE_FALLTHRU;\n+    }\n   dest->index = old_index;\n }\n \n@@ -868,6 +947,8 @@ cfg_layout_initialize ()\n      around the code.  */\n   alloc_aux_for_blocks (sizeof (struct reorder_block_def));\n \n+  cleanup_unconditional_jumps ();\n+\n   scope_to_insns_initialize ();\n \n   record_effective_endpoints ();"}, {"sha": "54e1305e8ecbf79be7425659dfd84d4276f48114", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c81a49011d7d197a0b291531f109cca4ed298a8/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c81a49011d7d197a0b291531f109cca4ed298a8/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=6c81a49011d7d197a0b291531f109cca4ed298a8", "patch": "@@ -7640,6 +7640,56 @@\n   operands[3] = gen_rtx_AND (mode, operands[0], gen_int_mode (mask, mode));\n })\n \n+;; Convert HImode/SImode test instructions with immediate to QImode ones.\n+;; i386 does not allow to encode test with 8bit sign extended immediate, so\n+;; this is relatively important trick.\n+;; Do the converison only post-reload to avoid limiting of the register class\n+;; to QI regs.\n+(define_split\n+  [(set (reg 17)\n+\t(compare\n+\t  (and (match_operand 0 \"register_operand\" \"\")\n+\t       (match_operand 1 \"const_int_operand\" \"\"))\n+\t  (const_int 0)))]\n+   \"(!TARGET_PROMOTE_QImode || optimize_size)\n+    && reload_completed\n+    && QI_REG_P (operands[0])\n+    && ((ix86_match_ccmode (insn, CCZmode)\n+    \t && !(INTVAL (operands[1]) & ~(255 << 8)))\n+\t|| (ix86_match_ccmode (insn, CCNOmode)\n+\t    && !(INTVAL (operands[1]) & ~(127 << 8))))\n+    && GET_MODE (operands[0]) != QImode\"\n+  [(set (reg:CCNO 17)\n+\t(compare:CCNO\n+\t  (and:SI (zero_extract:SI (match_dup 0) (const_int 8) (const_int 8))\n+\t\t  (match_dup 1))\n+\t  (const_int 0)))]\n+  \"operands[0] = gen_lowpart (SImode, operands[0]);\n+   operands[1] = gen_int_mode (INTVAL (operands[1]) >> 8, QImode);\")\n+\n+(define_split\n+  [(set (reg 17)\n+\t(compare\n+\t  (and (match_operand 0 \"nonimmediate_operand\" \"\")\n+\t       (match_operand 1 \"const_int_operand\" \"\"))\n+\t  (const_int 0)))]\n+   \"(!TARGET_PROMOTE_QImode || optimize_size)\n+    && reload_completed\n+    && (!REG_P (operands[0]) || ANY_QI_REG_P (operands[0]))\n+    && ((ix86_match_ccmode (insn, CCZmode)\n+\t && !(INTVAL (operands[1]) & ~255))\n+\t|| (ix86_match_ccmode (insn, CCNOmode)\n+\t    && !(INTVAL (operands[1]) & ~127)))\n+    && GET_MODE (operands[0]) != QImode\"\n+  [(set (reg:CCNO 17)\n+\t(compare:CCNO\n+\t  (and:QI (match_dup 0)\n+\t\t  (match_dup 1))\n+\t  (const_int 0)))]\n+  \"operands[0] = gen_lowpart (QImode, operands[0]);\n+   operands[1] = gen_lowpart (QImode, operands[1]);\")\n+\n+\n ;; %%% This used to optimize known byte-wide and operations to memory,\n ;; and sometimes to QImode registers.  If this is considered useful,\n ;; it should be done with splitters.\n@@ -16494,7 +16544,8 @@\n \t\t (const_int 0)))]\n   \"ix86_match_ccmode (insn, CCNOmode)\n    && (true_regnum (operands[0]) != 0\n-       || CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'K'))\n+       || (GET_CODE (operands[1]) == CONST_INT\n+\t   && CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'K')))\n    && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))\"\n   [(parallel\n      [(set (reg:CCNO 17)"}]}