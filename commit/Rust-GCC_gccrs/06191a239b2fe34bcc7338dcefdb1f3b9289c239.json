{"sha": "06191a239b2fe34bcc7338dcefdb1f3b9289c239", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYxOTFhMjM5YjJmZTM0YmNjNzMzOGRjZWZkYjFmM2I5Mjg5YzIzOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-09-24T12:43:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-09-24T12:43:30Z"}, "message": "cgraph.c (cgraph_clone_edge): Make the scale gcov_type.\n\n\n\t* cgraph.c (cgraph_clone_edge): Make the scale gcov_type.\n\t(cgraph_clone_node): Likewise.\n\t* cgraph.h (cgraph_clone_edge): Update prototype.\n\t(cgraph_mark_inline_edge, cgraph_clone_inlined_nodes): Remove\n\tduplicated prototypes; add updating argument.\n\t* cgraphunit.c (verify_cgraph_node): Verify that counts are non-negative.\n\t* ipa-inline.c (cgraph_clone_inlined_nodes): Allow clonning without\n\tupdating profile.\n\t(cgraph_mark_inline_edge): Likewise.\n\t(cgraph_mark_inline): Update use of cgraph_mark_inline_edge.\n\t(cgraph_flatten_node): Likewise.\n\t(cgraph_decide_recursive_inlining): Likewise.\n\t(cgraph_decide_inlining_of_small_function): Likewise.\n\t* tree-optimize.c (tree_rest_of_compilation): Likewise.\n\nFrom-SVN: r104601", "tree": {"sha": "65dc8daa11fadff0c648fecf430944f0ddcca2f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65dc8daa11fadff0c648fecf430944f0ddcca2f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06191a239b2fe34bcc7338dcefdb1f3b9289c239", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06191a239b2fe34bcc7338dcefdb1f3b9289c239", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06191a239b2fe34bcc7338dcefdb1f3b9289c239", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06191a239b2fe34bcc7338dcefdb1f3b9289c239/comments", "author": null, "committer": null, "parents": [{"sha": "26b7ebf6bf2dac324aaba62bab4b07863abe2c37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26b7ebf6bf2dac324aaba62bab4b07863abe2c37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26b7ebf6bf2dac324aaba62bab4b07863abe2c37"}], "stats": {"total": 67, "additions": 47, "deletions": 20}, "files": [{"sha": "48bf6152168e652a4d785046fb1ccf2823cfd05c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06191a239b2fe34bcc7338dcefdb1f3b9289c239/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06191a239b2fe34bcc7338dcefdb1f3b9289c239/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06191a239b2fe34bcc7338dcefdb1f3b9289c239", "patch": "@@ -1,3 +1,20 @@\n+2005-09-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_clone_edge): Make the scale gcov_type.\n+\t(cgraph_clone_node): Likewise.\n+\t* cgraph.h (cgraph_clone_edge): Update prototype.\n+\t(cgraph_mark_inline_edge, cgraph_clone_inlined_nodes): Remove\n+\tduplicated prototypes; add updating argument.\n+\t* cgraphunit.c (verify_cgraph_node): Verify that counts are non-negative.\n+\t* ipa-inline.c (cgraph_clone_inlined_nodes): Allow clonning without\n+\tupdating profile.\n+\t(cgraph_mark_inline_edge): Likewise.\n+\t(cgraph_mark_inline): Update use of cgraph_mark_inline_edge.\n+\t(cgraph_flatten_node): Likewise.\n+\t(cgraph_decide_recursive_inlining): Likewise.\n+\t(cgraph_decide_inlining_of_small_function): Likewise.\n+\t* tree-optimize.c (tree_rest_of_compilation): Likewise.\n+\n 2005-09-23  David Edelsohn  <edelsohn@gnu.org>\n \t    Pete Steinmetz <steinmtz@us.ibm.com>\n "}, {"sha": "32fbe3097391878eb90dd88f9a0c5e3dff92914d", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06191a239b2fe34bcc7338dcefdb1f3b9289c239/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06191a239b2fe34bcc7338dcefdb1f3b9289c239/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=06191a239b2fe34bcc7338dcefdb1f3b9289c239", "patch": "@@ -884,7 +884,7 @@ cgraph_function_possibly_inlined_p (tree decl)\n /* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */\n struct cgraph_edge *\n cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n-\t\t   tree call_stmt, int count_scale, int loop_nest,\n+\t\t   tree call_stmt, gcov_type count_scale, int loop_nest,\n \t\t   bool update_original)\n {\n   struct cgraph_edge *new;\n@@ -911,7 +911,7 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int loop_nest,\n {\n   struct cgraph_node *new = cgraph_create_node ();\n   struct cgraph_edge *e;\n-  int count_scale;\n+  gcov_type count_scale;\n \n   new->decl = n->decl;\n   new->origin = n->origin;"}, {"sha": "42a74f549b47efe0bb3644936f409ce215769af4", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06191a239b2fe34bcc7338dcefdb1f3b9289c239/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06191a239b2fe34bcc7338dcefdb1f3b9289c239/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=06191a239b2fe34bcc7338dcefdb1f3b9289c239", "patch": "@@ -242,7 +242,7 @@ struct cgraph_rtl_info *cgraph_rtl_info (tree);\n const char * cgraph_node_name (struct cgraph_node *);\n struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n \t\t\t\t        struct cgraph_node *,\n-\t\t\t\t        tree, int, int, bool);\n+\t\t\t\t        tree, gcov_type, int, bool);\n struct cgraph_node * cgraph_clone_node (struct cgraph_node *, gcov_type,\n \t\t\t\t\tint, bool);\n \n@@ -276,8 +276,6 @@ bool cgraph_inline_p (struct cgraph_edge *, const char **reason);\n bool cgraph_preserve_function_body_p (tree);\n void verify_cgraph (void);\n void verify_cgraph_node (struct cgraph_node *);\n-void cgraph_mark_inline_edge (struct cgraph_edge *e);\n-void cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate);\n void cgraph_build_static_cdtor (char which, tree body, int priority);\n void cgraph_reset_static_var_maps (void);\n void init_cgraph (void);\n@@ -290,7 +288,7 @@ int cgraph_postorder (struct cgraph_node **);\n \n /* In ipa-inline.c  */\n bool cgraph_decide_inlining_incrementally (struct cgraph_node *, bool);\n-void cgraph_clone_inlined_nodes (struct cgraph_edge *, bool);\n-void cgraph_mark_inline_edge (struct cgraph_edge *);\n+void cgraph_clone_inlined_nodes (struct cgraph_edge *, bool, bool);\n+void cgraph_mark_inline_edge (struct cgraph_edge *, bool);\n bool cgraph_default_inline_p (struct cgraph_node *, const char **);\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "181ee4e6329aedf9796bc22909bce19c1d75499a", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06191a239b2fe34bcc7338dcefdb1f3b9289c239/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06191a239b2fe34bcc7338dcefdb1f3b9289c239/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=06191a239b2fe34bcc7338dcefdb1f3b9289c239", "patch": "@@ -663,8 +663,18 @@ verify_cgraph_node (struct cgraph_node *node)\n \t       cgraph_node_name (e->caller), cgraph_node_name (e->callee));\n \terror_found = true;\n       }\n+  if (node->count < 0)\n+    {\n+      error (\"Execution count is negative\");\n+      error_found = true;\n+    }\n   for (e = node->callers; e; e = e->next_caller)\n     {\n+      if (e->count < 0)\n+\t{\n+\t  error (\"caller edge count is negative\");\n+\t  error_found = true;\n+\t}\n       if (!e->inline_failed)\n \t{\n \t  if (node->global.inlined_to"}, {"sha": "d91ca669765023dc6bf64a99174721a22a9cf4e7", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06191a239b2fe34bcc7338dcefdb1f3b9289c239/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06191a239b2fe34bcc7338dcefdb1f3b9289c239/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=06191a239b2fe34bcc7338dcefdb1f3b9289c239", "patch": "@@ -113,7 +113,7 @@ cgraph_estimate_size_after_inlining (int times, struct cgraph_node *to,\n    clones or re-using node originally representing out-of-line function call.\n    */\n void\n-cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate)\n+cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate, bool update_original)\n {\n   struct cgraph_node *n;\n \n@@ -131,7 +131,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate)\n     }\n    else if (duplicate)\n     {\n-      n = cgraph_clone_node (e->callee, e->count, e->loop_nest, true);\n+      n = cgraph_clone_node (e->callee, e->count, e->loop_nest, update_original);\n       cgraph_redirect_edge_callee (e, n);\n     }\n \n@@ -143,13 +143,15 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate)\n   /* Recursively clone all bodies.  */\n   for (e = e->callee->callees; e; e = e->next_callee)\n     if (!e->inline_failed)\n-      cgraph_clone_inlined_nodes (e, duplicate);\n+      cgraph_clone_inlined_nodes (e, duplicate, update_original);\n }\n \n-/* Mark edge E as inlined and update callgraph accordingly.  */\n+/* Mark edge E as inlined and update callgraph accordingly. \n+   UPDATE_ORIGINAL specify whether profile of original function should be\n+   updated. */\n \n void\n-cgraph_mark_inline_edge (struct cgraph_edge *e)\n+cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original)\n {\n   int old_insns = 0, new_insns = 0;\n   struct cgraph_node *to = NULL, *what;\n@@ -161,7 +163,7 @@ cgraph_mark_inline_edge (struct cgraph_edge *e)\n     DECL_POSSIBLY_INLINED (e->callee->decl) = true;\n   e->callee->global.inlined = true;\n \n-  cgraph_clone_inlined_nodes (e, true);\n+  cgraph_clone_inlined_nodes (e, true, update_original);\n \n   what = e->callee;\n \n@@ -200,7 +202,7 @@ cgraph_mark_inline (struct cgraph_edge *edge)\n       next = e->next_caller;\n       if (e->caller == to && e->inline_failed)\n \t{\n-          cgraph_mark_inline_edge (e);\n+          cgraph_mark_inline_edge (e, true);\n \t  if (e == edge)\n \t    edge = next;\n \t  times++;\n@@ -520,7 +522,7 @@ cgraph_flatten_node (struct cgraph_node *node, htab_t cycles)\n \t{\n \t  if (dump_file)\n     \t    fprintf (dump_file, \" inlining %s\", cgraph_node_name (e->callee));\n-          cgraph_mark_inline_edge (e);\n+          cgraph_mark_inline_edge (e, true);\n \t  cgraph_flatten_node (e->callee, cycles);\n \t}\n       else if (dump_file)\n@@ -571,7 +573,7 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n   master_clone->needed = true;\n   for (e = master_clone->callees; e; e = e->next_callee)\n     if (!e->inline_failed)\n-      cgraph_clone_inlined_nodes (e, true);\n+      cgraph_clone_inlined_nodes (e, true, false);\n \n   /* Do the inlining and update list of recursive call during process.  */\n   while (!fibheap_empty (heap)\n@@ -623,7 +625,7 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n \t  fprintf (dump_file, \"\\n\");\n \t}\n       cgraph_redirect_edge_callee (curr, master_clone);\n-      cgraph_mark_inline_edge (curr);\n+      cgraph_mark_inline_edge (curr, false);\n       lookup_recursive_calls (node, curr->callee, heap);\n       n++;\n     }\n@@ -808,7 +810,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \t      continue;\n \t    }\n \t  callee = edge->callee;\n-\t  cgraph_mark_inline_edge (edge);\n+\t  cgraph_mark_inline_edge (edge, true);\n \t  update_callee_keys (heap, callee, updated_nodes);\n \t}\n       where = edge->caller;\n@@ -930,7 +932,7 @@ cgraph_decide_inlining (void)\n \t  if (cgraph_recursive_inlining_p (e->caller, e->callee,\n \t\t\t\t  \t   &e->inline_failed))\n \t    continue;\n-\t  cgraph_mark_inline_edge (e);\n+\t  cgraph_mark_inline_edge (e, true);\n \t  if (dump_file)\n \t    fprintf (dump_file, \n \t\t     \" Inlined into %s which now has %i insns.\\n\","}, {"sha": "0678889c7722cbf8a9bb6a6046b65fd78e48cf32", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06191a239b2fe34bcc7338dcefdb1f3b9289c239/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06191a239b2fe34bcc7338dcefdb1f3b9289c239/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=06191a239b2fe34bcc7338dcefdb1f3b9289c239", "patch": "@@ -375,7 +375,7 @@ tree_rest_of_compilation (tree fndecl)\n \t  saved_node = cgraph_clone_node (node, node->count, 1, false);\n \t  for (e = saved_node->callees; e; e = e->next_callee)\n \t    if (!e->inline_failed)\n-\t      cgraph_clone_inlined_nodes (e, true);\n+\t      cgraph_clone_inlined_nodes (e, true, false);\n \t}\n       cfun->saved_static_chain_decl = cfun->static_chain_decl;\n       save_body (fndecl, &cfun->saved_args, &cfun->saved_static_chain_decl);"}]}