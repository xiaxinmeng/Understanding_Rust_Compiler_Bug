{"sha": "8e4ce833ab3f109b5d344a84d0659a895aa8c603", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU0Y2U4MzNhYjNmMTA5YjVkMzQ0YTg0ZDA2NTlhODk1YWE4YzYwMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2001-03-23T12:04:11Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2001-03-23T12:04:11Z"}, "message": "decl.c (local_names): Define.\n\n\t* decl.c (local_names): Define.\n\t(push_local_name): New.\n\t(grok_reference_init): Return init if initializing static reference\n\tvariable with non-constant instead of emitting it.\n\tMove expand_static_init call to cp_finish_decl.\n\t(layout_var_decl): Call push_local_name.\n\t(maybe_commonize_var): Allow inlining functions even if they have\n\tstatic local variables, use comdat_linkage for them if flag_weak.\n\t(check_initializer): Call obscure_complex_init if\n\tgrok_reference_init returned non-zero.\n\t(save_function_data): Clear x_local_names.\n\t(pop_cp_function_context): Free x_local_names.\n\t(mark_inlined_fns): Remove.\n\t(mark_lang_function): Mark x_local_names.\n\t(lang_mark_tree): Don't mark DECL_ACCESS for DECL_DISCRIMINATOR_P.\n\tMark inlined_fns as tree, remove call to mark_inlined_fns.\n\t* class.c (alter_access): Ensure DECL_ACCESS is never set if\n\tDECL_DISCRIMINATOR_P.\n\t* cp-tree.h (cp_language_function): Add x_local_names.\n\t(lang_decl_flags): Add discriminator into u2.\n\t(lang_decl_inlined_fns): Remove.\n\t(lang_decl): inlined_fns is now a TREE_VEC.\n\t(DECL_DISCRIMINATOR_P, DECL_DISCRIMINATOR): Define.\n\t* optimize.c (inlinable_function_p): DECL_INLINED_FNS is now a\n\tTREE_VEC, not a custom structure.\n\t(optimize_function): Likewise.\n\t* mangle.c (discriminator_for_local_entity): Discriminate among\n\tVAR_DECL local entities.\n\t* search.c (dfs_access_in_type): If DECL_DISCRIMINATOR_P, DECL_ACCESS\n\tis not valid.\n\n\t* g++.old-deja/g++.other/mangle3.C: New test.\n\nFrom-SVN: r40779", "tree": {"sha": "1a8f5604777aadd2add12ef78e66d86095808cde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a8f5604777aadd2add12ef78e66d86095808cde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e4ce833ab3f109b5d344a84d0659a895aa8c603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e4ce833ab3f109b5d344a84d0659a895aa8c603", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e4ce833ab3f109b5d344a84d0659a895aa8c603", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e4ce833ab3f109b5d344a84d0659a895aa8c603/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d2cd1b16ae683dc7c2af5fcc0bbf288fdbba22d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d2cd1b16ae683dc7c2af5fcc0bbf288fdbba22d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d2cd1b16ae683dc7c2af5fcc0bbf288fdbba22d"}], "stats": {"total": 278, "additions": 197, "deletions": 81}, "files": [{"sha": "2881da6ab5ef0ee6bd948ce121ac36e6bdff8fc9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8e4ce833ab3f109b5d344a84d0659a895aa8c603", "patch": "@@ -1,3 +1,36 @@\n+2001-03-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* decl.c (local_names): Define.\n+\t(push_local_name): New.\n+\t(grok_reference_init): Return init if initializing static reference\n+\tvariable with non-constant instead of emitting it.\n+\tMove expand_static_init call to cp_finish_decl.\n+\t(layout_var_decl): Call push_local_name.\n+\t(maybe_commonize_var): Allow inlining functions even if they have\n+\tstatic local variables, use comdat_linkage for them if flag_weak.\n+\t(check_initializer): Call obscure_complex_init if\n+\tgrok_reference_init returned non-zero.\n+\t(save_function_data): Clear x_local_names.\n+\t(pop_cp_function_context): Free x_local_names.\n+\t(mark_inlined_fns): Remove.\n+\t(mark_lang_function): Mark x_local_names.\n+\t(lang_mark_tree): Don't mark DECL_ACCESS for DECL_DISCRIMINATOR_P.\n+\tMark inlined_fns as tree, remove call to mark_inlined_fns.\n+\t* class.c (alter_access): Ensure DECL_ACCESS is never set if\n+\tDECL_DISCRIMINATOR_P.\n+\t* cp-tree.h (cp_language_function): Add x_local_names.\n+\t(lang_decl_flags): Add discriminator into u2.\n+\t(lang_decl_inlined_fns): Remove.\n+\t(lang_decl): inlined_fns is now a TREE_VEC.\n+\t(DECL_DISCRIMINATOR_P, DECL_DISCRIMINATOR): Define.\n+\t* optimize.c (inlinable_function_p): DECL_INLINED_FNS is now a\n+\tTREE_VEC, not a custom structure.\n+\t(optimize_function): Likewise.\n+\t* mangle.c (discriminator_for_local_entity): Discriminate among\n+\tVAR_DECL local entities.\n+\t* search.c (dfs_access_in_type): If DECL_DISCRIMINATOR_P, DECL_ACCESS\n+\tis not valid.\n+\n 2001-03-22  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \tAdd support for Java interface method calls."}, {"sha": "b4838b17bcf36740dccc6859dd89ead5577cb459", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8e4ce833ab3f109b5d344a84d0659a895aa8c603", "patch": "@@ -1458,6 +1458,9 @@ alter_access (t, fdecl, access)\n   if (!DECL_LANG_SPECIFIC (fdecl))\n     retrofit_lang_decl (fdecl);\n \n+  if (DECL_DISCRIMINATOR_P (fdecl))\n+    abort ();\n+\n   elem = purpose_member (t, DECL_ACCESS (fdecl));\n   if (elem)\n     {"}, {"sha": "28f519dd29be1ca1c01fd5f9bc29e6863cc4a9b1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8e4ce833ab3f109b5d344a84d0659a895aa8c603", "patch": "@@ -887,6 +887,7 @@ struct cp_language_function\n   struct named_label_use_list *x_named_label_uses;\n   struct named_label_list *x_named_labels;\n   struct binding_level *bindings;\n+  varray_type x_local_names;\n \n   const char *cannot_inline;\n };\n@@ -1840,6 +1841,9 @@ struct lang_decl_flags\n     /* This is DECL_ACCESS.  */\n     tree access;\n \n+    /* For VAR_DECL in function, this is DECL_DISCRIMINATOR.  */\n+    int discriminator;\n+\n     /* In a namespace-scope FUNCTION_DECL, this is\n        GLOBAL_INIT_PRIORITY.  */\n     int init_priority;\n@@ -1852,12 +1856,6 @@ struct lang_decl_flags\n \n struct unparsed_text;\n \n-struct lang_decl_inlined_fns\n-{\n-  size_t num_fns;\n-  tree fns[1];\n-};\n-\n struct lang_decl\n {\n   struct lang_decl_flags decl_flags;\n@@ -1871,8 +1869,9 @@ struct lang_decl\n   /* In a FUNCTION_DECL, this is DECL_CLONED_FUNCTION.  */\n   tree cloned_function;\n \n-  /* In a FUNCTION_DECL, this is a list of trees inlined into its body.  */\n-  struct lang_decl_inlined_fns *inlined_fns;\n+  /* In a FUNCTION_DECL, these are function data which is to be kept\n+     as long as FUNCTION_DECL is kept.  */\n+  tree inlined_fns;\n \n   union\n   {\n@@ -1989,6 +1988,15 @@ struct lang_decl\n #define DECL_INLINED_FNS(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->inlined_fns)\n \n+/* Nonzero if NODE has DECL_DISCRIMINATOR and not DECL_ACCESS.  */\n+#define DECL_DISCRIMINATOR_P(NODE)\t\\\n+  (TREE_CODE (NODE) == VAR_DECL\t\t\\\n+   && DECL_FUNCTION_SCOPE_P (NODE))\n+\n+/* Discriminator for name mangling.  */\n+#define DECL_DISCRIMINATOR(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.u2.discriminator)\n+\n /* Non-zero if the VTT parm has been added to NODE.  */\n #define DECL_HAS_VTT_PARM_P(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->decl_flags.has_vtt_parm_p)"}, {"sha": "4794f659d3debbad8897b93744b2e24b0e146a98", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 80, "deletions": 51, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8e4ce833ab3f109b5d344a84d0659a895aa8c603", "patch": "@@ -75,8 +75,9 @@ static tree store_bindings PARAMS ((tree, tree));\n static tree lookup_tag_reverse PARAMS ((tree, tree));\n static tree obscure_complex_init PARAMS ((tree, tree));\n static tree lookup_name_real PARAMS ((tree, int, int, int));\n+static void push_local_name PARAMS ((tree));\n static void warn_extern_redeclared_static PARAMS ((tree, tree));\n-static void grok_reference_init PARAMS ((tree, tree, tree));\n+static tree grok_reference_init PARAMS ((tree, tree, tree));\n static tree grokfndecl PARAMS ((tree, tree, tree, tree, int,\n \t\t\t      enum overload_flags, tree,\n \t\t\t      tree, int, int, int, int, int, int, tree));\n@@ -130,7 +131,6 @@ static void mark_binding_level PARAMS ((void *));\n static void mark_named_label_lists PARAMS ((void *, void *));\n static void mark_cp_function_context PARAMS ((struct function *));\n static void mark_saved_scope PARAMS ((void *));\n-static void mark_inlined_fns PARAMS ((struct lang_decl_inlined_fns *));\n static void mark_lang_function PARAMS ((struct cp_language_function *));\n static void save_function_data PARAMS ((tree));\n static void check_function_type PARAMS ((tree, tree));\n@@ -248,6 +248,8 @@ struct named_label_use_list\n \n #define named_label_uses cp_function_chain->x_named_label_uses\n \n+#define local_names cp_function_chain->x_local_names\n+\n /* A list of objects which have constructors or destructors\n    which reside in the global scope.  The decl is stored in\n    the TREE_VALUE slot and the initializer is stored\n@@ -2750,6 +2752,41 @@ create_implicit_typedef (name, type)\n   return decl;\n }\n \n+/* Remember a local name for name-mangling purposes.  */\n+\n+static void\n+push_local_name (decl)\n+     tree decl;\n+{\n+  size_t i, nelts;\n+  tree t, name;\n+\n+  if (!local_names)\n+    VARRAY_TREE_INIT (local_names, 8, \"local_names\");\n+\n+  name = DECL_NAME (decl);\n+\n+  nelts = VARRAY_ACTIVE_SIZE (local_names);\n+  for (i = 0; i < nelts; i++)\n+    {\n+      t = VARRAY_TREE (local_names, i);\n+      if (DECL_NAME (t) == name)\n+\t{\n+\t  if (!DECL_LANG_SPECIFIC (decl))\n+\t    retrofit_lang_decl (decl);\n+\t  if (DECL_LANG_SPECIFIC (t))\n+\t    DECL_DISCRIMINATOR (decl) = DECL_DISCRIMINATOR (t) + 1;\n+\t  else\n+\t    DECL_DISCRIMINATOR (decl) = 1;\n+\n+\t  VARRAY_TREE (local_names, i) = decl;\n+\t  return;\n+\t}\n+    }\n+\n+  VARRAY_PUSH_TREE (local_names, decl);\n+}\n+\n /* Push a tag name NAME for struct/class/union/enum type TYPE.\n    Normally put it into the inner-most non-tag-transparent scope,\n    but if GLOBALIZE is true, put it in the inner-most non-class scope.\n@@ -7292,7 +7329,7 @@ start_decl_1 (decl)\n \n    Quotes on semantics can be found in ARM 8.4.3.  */\n \n-static void\n+static tree\n grok_reference_init (decl, type, init)\n      tree decl, type, init;\n {\n@@ -7304,16 +7341,16 @@ grok_reference_init (decl, type, init)\n \t   || DECL_IN_AGGR_P (decl) == 0)\n \t  && ! DECL_THIS_EXTERN (decl))\n \tcp_error (\"`%D' declared as reference but not initialized\", decl);\n-      return;\n+      return NULL_TREE;\n     }\n \n   if (init == error_mark_node)\n-    return;\n+    return NULL_TREE;\n \n   if (TREE_CODE (init) == CONSTRUCTOR)\n     {\n       cp_error (\"ISO C++ forbids use of initializer list to initialize reference `%D'\", decl);\n-      return;\n+      return NULL_TREE;\n     }\n \n   if (TREE_CODE (init) == TREE_LIST)\n@@ -7342,32 +7379,26 @@ grok_reference_init (decl, type, init)\n      decl);\n \n   if (tmp == error_mark_node)\n-    return;\n-  else if (tmp != NULL_TREE)\n-    {\n-      init = tmp;\n-      tmp = save_expr (tmp);\n-      if (building_stmt_tree ())\n-\t{\n-\t  /* Initialize the declaration.  */\n-\t  tmp = build (INIT_EXPR, TREE_TYPE (decl), decl, tmp);\n-\t  finish_expr_stmt (tmp);\n-\t}\n-      else\n-\tDECL_INITIAL (decl) = tmp;\n-    }\n-  else\n+    return NULL_TREE;\n+  else if (tmp == NULL_TREE)\n     {\n       cp_error (\"cannot initialize `%T' from `%T'\", type, TREE_TYPE (init));\n-      return;\n+      return NULL_TREE;\n     }\n \n-  if (TREE_STATIC (decl) && ! TREE_CONSTANT (DECL_INITIAL (decl)))\n+  if (TREE_STATIC (decl) && !TREE_CONSTANT (tmp))\n+    return tmp;\n+\n+  if (building_stmt_tree ())\n     {\n-      expand_static_init (decl, DECL_INITIAL (decl));\n-      DECL_INITIAL (decl) = NULL_TREE;\n+      /* Initialize the declaration.  */\n+      tmp = build (INIT_EXPR, TREE_TYPE (decl), decl, tmp);\n+      finish_expr_stmt (tmp);\n     }\n-  return;\n+  else\n+    DECL_INITIAL (decl) = tmp;\n+\n+  return NULL_TREE;\n }\n \n /* Fill in DECL_INITIAL with some magical value to prevent expand_decl from\n@@ -7493,6 +7524,12 @@ layout_var_decl (decl)\n       else\n \tcp_error (\"storage size of `%D' isn't constant\", decl);\n     }\n+\n+  if (TREE_STATIC (decl)\n+      && !DECL_ARTIFICIAL (decl)\n+      && current_function_decl\n+      && DECL_CONTEXT (decl) == current_function_decl)\n+    push_local_name (decl);\n }\n \n /* If a local static variable is declared in an inline function, or if\n@@ -7514,12 +7551,6 @@ maybe_commonize_var (decl)\n \t  || DECL_TEMPLATE_INSTANTIATION (current_function_decl))\n       && TREE_PUBLIC (current_function_decl))\n     {\n-      /* Rather than try to get this right with inlining, we suppress\n-\t inlining of such functions.  */\n-      current_function_cannot_inline\n-\t= \"function with static variable cannot be inline\";\n-      DECL_UNINLINABLE (current_function_decl) = 1;\n-\n       /* If flag_weak, we don't need to mess with this, as we can just\n \t make the function weak, and let it refer to its unique local\n \t copy.  This works because we don't allow the function to be\n@@ -7546,6 +7577,8 @@ maybe_commonize_var (decl)\n \t      cp_warning_at (\"  you can work around this by removing the initializer\", decl);\n \t    }\n \t}\n+      else\n+\tcomdat_linkage (decl);\n     }\n   else if (DECL_LANG_SPECIFIC (decl) && DECL_COMDAT (decl))\n     /* Set it up again; we might have set DECL_INITIAL since the last\n@@ -7632,8 +7665,9 @@ check_initializer (decl, init)\n     }\n   else if (!DECL_EXTERNAL (decl) && TREE_CODE (type) == REFERENCE_TYPE)\n     {\n-      grok_reference_init (decl, type, init);\n-      init = NULL_TREE;\n+      init = grok_reference_init (decl, type, init);\n+      if (init)\n+\tinit = obscure_complex_init (decl, init);\n     }\n   else if (init)\n     {\n@@ -13694,6 +13728,7 @@ save_function_data (decl)\n   f->base.x_stmt_tree.x_last_expr_type = NULL_TREE;\n   f->x_named_label_uses = NULL;\n   f->bindings = NULL;\n+  f->x_local_names = NULL;\n \n   /* When we get back here again, we will be expanding.  */\n   f->x_expanding_p = 1;\n@@ -14312,23 +14347,16 @@ pop_cp_function_context (f)\n      struct function *f;\n {\n   if (f->language)\n-    free (f->language);\n+    {\n+      struct cp_language_function *cp =\n+\t(struct cp_language_function *) f->language;\n+      if (cp->x_local_names)\n+\tVARRAY_FREE (cp->x_local_names);\n+      free (f->language);\n+    }\n   f->language = 0;\n }\n \n-/* Mark I for GC.  */\n-\n-static void\n-mark_inlined_fns (i)\n-     struct lang_decl_inlined_fns *i;\n-{\n-  int n;\n-\n-  for (n = i->num_fns - 1; n >= 0; n--)\n-    ggc_mark_tree (i->fns [n]);\n-  ggc_set_mark (i);\n-}\n-\n /* Mark P for GC.  */\n \n static void\n@@ -14345,6 +14373,7 @@ mark_lang_function (p)\n   ggc_mark_tree (p->x_current_class_ptr);\n   ggc_mark_tree (p->x_current_class_ref);\n   ggc_mark_tree (p->x_eh_spec_try_block);\n+  ggc_mark_tree_varray (p->x_local_names);\n \n   mark_named_label_lists (&p->x_named_labels, &p->x_named_label_uses);\n   mark_binding_level (&p->bindings);\n@@ -14402,7 +14431,8 @@ lang_mark_tree (t)\n \t  c_mark_lang_decl (&ld->decl_flags.base);\n \t  if (!DECL_GLOBAL_CTOR_P (t)\n \t      && !DECL_GLOBAL_DTOR_P (t)\n-\t      && !DECL_THUNK_P (t))\n+\t      && !DECL_THUNK_P (t)\n+\t      && !DECL_DISCRIMINATOR_P (t))\n \t    ggc_mark_tree (ld->decl_flags.u2.access);\n \t  else if (DECL_THUNK_P (t))\n \t    ggc_mark_tree (ld->decl_flags.u2.vcall_offset);\n@@ -14415,8 +14445,7 @@ lang_mark_tree (t)\n \t      ggc_mark_tree (ld->befriending_classes);\n \t      ggc_mark_tree (ld->context);\n \t      ggc_mark_tree (ld->cloned_function);\n-\t      if (ld->inlined_fns)\n-\t\tmark_inlined_fns (ld->inlined_fns);\n+\t      ggc_mark_tree (ld->inlined_fns);\n \t      if (TREE_CODE (t) == TYPE_DECL)\n \t\tggc_mark_tree (ld->u.sorted_fields);\n \t      else if (TREE_CODE (t) == FUNCTION_DECL"}, {"sha": "a908640088ef3c4f83b2da7a7a60d24d3a769da1", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=8e4ce833ab3f109b5d344a84d0659a895aa8c603", "patch": "@@ -1154,16 +1154,17 @@ discriminator_for_local_entity (entity)\n   /* Assume this is the only local entity with this name.  */\n   discriminator = 0;\n \n-  /* For now, we don't discriminate amongst local variables.  */\n-  if (TREE_CODE (entity) != TYPE_DECL)\n-    return 0;\n-\n-  /* Scan the list of local classes.  */\n-  entity = TREE_TYPE (entity);\n-  for (type = &VARRAY_TREE (local_classes, 0); *type != entity; ++type)\n-    if (TYPE_IDENTIFIER (*type) == TYPE_IDENTIFIER (entity)\n-\t&& TYPE_CONTEXT (*type) == TYPE_CONTEXT (entity))\n-      ++discriminator;\n+  if (DECL_DISCRIMINATOR_P (entity) && DECL_LANG_SPECIFIC (entity))\n+    discriminator = DECL_DISCRIMINATOR (entity);\n+  else if (TREE_CODE (entity) == TYPE_DECL)\n+    {\n+      /* Scan the list of local classes.  */\n+      entity = TREE_TYPE (entity);\n+      for (type = &VARRAY_TREE (local_classes, 0); *type != entity; ++type)\n+        if (TYPE_IDENTIFIER (*type) == TYPE_IDENTIFIER (entity)\n+            && TYPE_CONTEXT (*type) == TYPE_CONTEXT (entity))\n+\t  ++discriminator;\n+    }  \n \n   return discriminator;\n }"}, {"sha": "d350fdaaeedb1c2429071642f47002c99c16a703", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=8e4ce833ab3f109b5d344a84d0659a895aa8c603", "patch": "@@ -620,10 +620,11 @@ inlinable_function_p (fn, id)\n \n       if (inlinable && DECL_LANG_SPECIFIC (fn) && DECL_INLINED_FNS (fn))\n \t{\n-\t  struct lang_decl_inlined_fns *ifn = DECL_INLINED_FNS (fn);\n+\t  int j;\n+\t  tree inlined_fns = DECL_INLINED_FNS (fn);\n \n-\t  for (i = 0; i < ifn->num_fns; ++i)\n-\t    if (ifn->fns [i] == VARRAY_TREE (id->fns, 0))\n+\t  for (j = 0; j < TREE_VEC_LENGTH (inlined_fns); ++j)\n+\t    if (TREE_VEC_ELT (inlined_fns, j) == VARRAY_TREE (id->fns, 0))\n \t      return 0;\n \t}\n     }\n@@ -912,14 +913,10 @@ optimize_function (fn)\n       VARRAY_FREE (id.target_exprs);\n       if (DECL_LANG_SPECIFIC (fn))\n \t{\n-\t  struct lang_decl_inlined_fns *ifn;\n-\n-\t  ifn = ggc_alloc (sizeof (struct lang_decl_inlined_fns)\n-\t\t\t   + (VARRAY_ACTIVE_SIZE (id.inlined_fns) - 1)\n-\t\t\t     * sizeof (tree));\n-\t  ifn->num_fns = VARRAY_ACTIVE_SIZE (id.inlined_fns);\n-\t  memcpy (&ifn->fns[0], &VARRAY_TREE (id.inlined_fns, 0),\n-\t\t  ifn->num_fns * sizeof (tree));\n+\t  tree ifn = make_tree_vec (VARRAY_ACTIVE_SIZE (id.inlined_fns));\n+\n+\t  memcpy (&TREE_VEC_ELT (ifn, 0), &VARRAY_TREE (id.inlined_fns, 0),\n+\t\t  VARRAY_ACTIVE_SIZE (id.inlined_fns) * sizeof (tree));\n \t  DECL_INLINED_FNS (fn) = ifn;\n \t}\n       VARRAY_FREE (id.inlined_fns);"}, {"sha": "c52620f0cf3400261424754621a42926bdfc7d0e", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=8e4ce833ab3f109b5d344a84d0659a895aa8c603", "patch": "@@ -842,7 +842,7 @@ dfs_access_in_type (binfo, data)\n \t access to the DECL.  The CONST_DECL for an enumeration\n \t constant will not have DECL_LANG_SPECIFIC, and thus no\n \t DECL_ACCESS.  */\n-      if (DECL_LANG_SPECIFIC (decl))\n+      if (DECL_LANG_SPECIFIC (decl) && !DECL_DISCRIMINATOR_P (decl))\n \t{\n \t  tree decl_access = purpose_member (type, DECL_ACCESS (decl));\n \t  if (decl_access)"}, {"sha": "4e61c615d26a626460739b212a6a5a93a0a6ac2b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e4ce833ab3f109b5d344a84d0659a895aa8c603", "patch": "@@ -1,3 +1,7 @@\n+2001-03-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* g++.old-deja/g++.other/mangle3.C: New test.\n+\n 2001-03-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.old-deja/g++.other/anon8.C: New test."}, {"sha": "d77a4b548de8eaef657e4d5d8c882639e3bff8e5", "filename": "gcc/testsuite/g++.old-deja/g++.other/mangle3.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4ce833ab3f109b5d344a84d0659a895aa8c603/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle3.C?ref=8e4ce833ab3f109b5d344a84d0659a895aa8c603", "patch": "@@ -0,0 +1,41 @@\n+struct foo {\n+  static int bar ()\n+  {\n+    int i;\n+    static int baz = 1;\n+    {\n+      static int baz = 2;\n+      i = baz++;\n+    }\n+    {\n+      struct baz {\n+        static int m ()\n+        {\n+          static int n;\n+          return n += 10;\n+        }\n+      };\n+      baz a;\n+      i += a.m ();\n+    }\n+    {\n+      static int baz = 3;\n+      i += baz;\n+      baz += 30;\n+    }\n+    i += baz;\n+    baz += 60;\n+    return i;\n+  }\n+};\n+\n+int main ()\n+{\n+  foo x;\n+\n+  if (x.bar () != 16)\n+    return 1;\n+  if (x.bar() != 117)\n+    return 1;\n+  return 0;\n+}"}]}