{"sha": "06eab6a7fadd9a6502a7fe439140f8ac1091231e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZlYWI2YTdmYWRkOWE2NTAyYTdmZTQzOTE0MGY4YWMxMDkxMjMxZQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-03-26T07:38:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-03-26T07:38:28Z"}, "message": "exp_ch11.adb (Expand_At_End_Handler): Set From_At_End flag on raise stmt.\n\n2008-03-26  Robert Dewar  <dewar@adacore.com>\n\t    Arnaud Charlet  <charlet@adacore.com>\n\n\t* exp_ch11.adb (Expand_At_End_Handler): Set From_At_End flag on raise\n\tstmt.\n\t(No_Exception_Propagation_Active): New function.\n\t(Expand_Exception_Handlers): Use No_Exception_Propagation_Active.\n\tUpdate comments, and review all uses of No_Exception_Propagation, which\n\tare now correct and in sync with what gigi expects.\n\n\t* restrict.ads, restrict.adb (No_Exception_Propagation_Active): New\n\tfunction.\n\t(Expand_Exception_Handlers): Use No_Exception_Propagation_Active.\n\tUpdate comments, and review all uses of No_Exception_Propagation, which\n\tare now correct and in sync with what gigi expects.\n\nFrom-SVN: r133560", "tree": {"sha": "98cf57933dcfc760e203fc2231fbda94827b9349", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98cf57933dcfc760e203fc2231fbda94827b9349"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06eab6a7fadd9a6502a7fe439140f8ac1091231e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06eab6a7fadd9a6502a7fe439140f8ac1091231e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06eab6a7fadd9a6502a7fe439140f8ac1091231e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06eab6a7fadd9a6502a7fe439140f8ac1091231e/comments", "author": null, "committer": null, "parents": [{"sha": "e10dab7f8dc252e8fa7cb42a4f4452b0f493bdcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e10dab7f8dc252e8fa7cb42a4f4452b0f493bdcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e10dab7f8dc252e8fa7cb42a4f4452b0f493bdcc"}], "stats": {"total": 256, "additions": 143, "deletions": 113}, "files": [{"sha": "dbe3ebe73ad840266ce325ebc638df507f5baa7a", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 126, "deletions": 113, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06eab6a7fadd9a6502a7fe439140f8ac1091231e/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06eab6a7fadd9a6502a7fe439140f8ac1091231e/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=06eab6a7fadd9a6502a7fe439140f8ac1091231e", "patch": "@@ -143,12 +143,21 @@ package body Exp_Ch11 is\n         Make_Procedure_Call_Statement (Loc,\n           Name => New_Occurrence_Of (Clean, Loc)));\n \n-      --  Avoid generation of raise stmt if compiling with no exceptions\n-      --  propagation\n+      --  Generate reraise statement as last statement of AT-END handler,\n+      --  unless we are under control of No_Exception_Propagation, in which\n+      --  case no exception propagation is possible anyway, so we do not need\n+      --  a reraise (the AT END handler in this case is only for normal exits\n+      --  not for exceptional exits). Also, we flag the Reraise statement as\n+      --  being part of an AT END handler to prevent signalling this reraise\n+      --  as a violation of the restriction when it is not set.\n \n       if not Restriction_Active (No_Exception_Propagation) then\n-         Append_To (Stmnts,\n-           Make_Raise_Statement (Loc));\n+         declare\n+            Rstm : constant Node_Id := Make_Raise_Statement (Loc);\n+         begin\n+            Set_From_At_End (Rstm);\n+            Append_To (Stmnts, Rstm);\n+         end;\n       end if;\n \n       Set_Exception_Handlers (HSS, New_List (\n@@ -963,16 +972,17 @@ package body Exp_Ch11 is\n       Handler_Loop : while Present (Handler) loop\n          Next_Handler := Next_Non_Pragma (Handler);\n \n-         --  Remove source handler if gnat debug flag N is set\n+         --  Remove source handler if gnat debug flag .x is set\n \n          if Debug_Flag_Dot_X and then Comes_From_Source (Handler) then\n             Remove (Handler);\n \n          --  Remove handler if no exception propagation, generating a warning\n          --  if a source generated handler was not the target of a local raise.\n \n-         elsif Restriction_Active (No_Exception_Propagation) then\n-            if not Has_Local_Raise (Handler)\n+         else\n+            if Restriction_Active (No_Exception_Propagation)\n+              and then not Has_Local_Raise (Handler)\n               and then Comes_From_Source (Handler)\n               and then Warn_On_Non_Local_Exception\n             then\n@@ -982,118 +992,124 @@ package body Exp_Ch11 is\n                   Handler);\n             end if;\n \n-            Remove (Handler);\n-\n-         --  Exception handler is active and retained and must be processed\n-\n-         else\n-            --  If an exception occurrence is present, then we must declare it\n-            --  and initialize it from the value stored in the TSD\n-\n-            --     declare\n-            --        name : Exception_Occurrence;\n-            --     begin\n-            --        Save_Occurrence (name, Get_Current_Excep.all)\n-            --        ...\n-            --     end;\n-\n-            if Present (Choice_Parameter (Handler)) then\n-               declare\n-                  Cparm : constant Entity_Id  := Choice_Parameter (Handler);\n-                  Clc   : constant Source_Ptr := Sloc (Cparm);\n-                  Save  : Node_Id;\n-\n-               begin\n-                  Save :=\n-                    Make_Procedure_Call_Statement (Loc,\n-                      Name =>\n-                        New_Occurrence_Of (RTE (RE_Save_Occurrence), Loc),\n-                      Parameter_Associations => New_List (\n-                        New_Occurrence_Of (Cparm, Clc),\n-                        Make_Explicit_Dereference (Loc,\n-                          Make_Function_Call (Loc,\n-                            Name => Make_Explicit_Dereference (Loc,\n-                              New_Occurrence_Of\n-                                (RTE (RE_Get_Current_Excep), Loc))))));\n-\n-                  Mark_Rewrite_Insertion (Save);\n-                  Prepend (Save, Statements (Handler));\n-\n-                  Obj_Decl :=\n-                    Make_Object_Declaration\n-                      (Clc,\n-                       Defining_Identifier => Cparm,\n-                       Object_Definition   =>\n-                         New_Occurrence_Of\n-                           (RTE (RE_Exception_Occurrence), Clc));\n-                  Set_No_Initialization (Obj_Decl, True);\n-\n-                  Rewrite (Handler,\n-                    Make_Implicit_Exception_Handler (Loc,\n-                      Exception_Choices => Exception_Choices (Handler),\n-\n-                      Statements => New_List (\n-                        Make_Block_Statement (Loc,\n-                          Declarations => New_List (Obj_Decl),\n-                          Handled_Statement_Sequence =>\n-                            Make_Handled_Sequence_Of_Statements (Loc,\n-                              Statements => Statements (Handler))))));\n-\n-                  Analyze_List (Statements (Handler), Suppress => All_Checks);\n-               end;\n-            end if;\n-\n-            --  The processing at this point is rather different for the JVM\n-            --  case, so we completely separate the processing.\n+            if No_Exception_Propagation_Active then\n+               Remove (Handler);\n \n-            --  For the JVM case, we unconditionally call Update_Exception,\n-            --  passing a call to the intrinsic Current_Target_Exception (see\n-            --  JVM version of Ada.Exceptions in 4jexcept.adb for details).\n+            --  Exception handler is active and retained and must be processed\n \n-            if VM_Target /= No_VM then\n-               declare\n-                  Arg : constant Node_Id :=\n-                          Make_Function_Call (Loc,\n-                            Name =>\n-                              New_Occurrence_Of\n-                                (RTE (RE_Current_Target_Exception), Loc));\n-               begin\n-                  Prepend_Call_To_Handler\n-                    (RE_Update_Exception, New_List (Arg));\n-               end;\n+            else\n+               --  If an exception occurrence is present, then we must declare\n+               --  it and initialize it from the value stored in the TSD\n \n-               --  For the normal case, we have to worry about the state of\n-               --  abort deferral. Generally, we defer abort during runtime\n-               --  handling of exceptions. When control is passed to the\n-               --  handler, then in the normal case we undefer aborts. In any\n-               --  case this entire handling is relevant only if aborts are\n-               --  allowed!\n+               --     declare\n+               --        name : Exception_Occurrence;\n+               --     begin\n+               --        Save_Occurrence (name, Get_Current_Excep.all)\n+               --        ...\n+               --     end;\n \n-            elsif Abort_Allowed then\n+               if Present (Choice_Parameter (Handler)) then\n+                  declare\n+                     Cparm : constant Entity_Id  := Choice_Parameter (Handler);\n+                     Clc   : constant Source_Ptr := Sloc (Cparm);\n+                     Save  : Node_Id;\n \n-               --  There are some special cases in which we do not do the\n-               --  undefer. In particular a finalization (AT END) handler\n-               --  wants to operate with aborts still deferred.\n+                  begin\n+                     Save :=\n+                       Make_Procedure_Call_Statement (Loc,\n+                         Name =>\n+                           New_Occurrence_Of (RTE (RE_Save_Occurrence), Loc),\n+                         Parameter_Associations => New_List (\n+                           New_Occurrence_Of (Cparm, Clc),\n+                           Make_Explicit_Dereference (Loc,\n+                             Make_Function_Call (Loc,\n+                               Name => Make_Explicit_Dereference (Loc,\n+                                 New_Occurrence_Of\n+                                   (RTE (RE_Get_Current_Excep), Loc))))));\n+\n+                     Mark_Rewrite_Insertion (Save);\n+                     Prepend (Save, Statements (Handler));\n+\n+                     Obj_Decl :=\n+                       Make_Object_Declaration\n+                         (Clc,\n+                          Defining_Identifier => Cparm,\n+                          Object_Definition   =>\n+                            New_Occurrence_Of\n+                              (RTE (RE_Exception_Occurrence), Clc));\n+                     Set_No_Initialization (Obj_Decl, True);\n+\n+                     Rewrite (Handler,\n+                       Make_Implicit_Exception_Handler (Loc,\n+                         Exception_Choices => Exception_Choices (Handler),\n+\n+                         Statements => New_List (\n+                           Make_Block_Statement (Loc,\n+                             Declarations => New_List (Obj_Decl),\n+                             Handled_Statement_Sequence =>\n+                               Make_Handled_Sequence_Of_Statements (Loc,\n+                                 Statements => Statements (Handler))))));\n+\n+                     Analyze_List\n+                       (Statements (Handler), Suppress => All_Checks);\n+                  end;\n+               end if;\n \n-               --  We also suppress the call if this is the special handler\n-               --  for Abort_Signal, since if we are aborting, we want to keep\n-               --  aborts deferred (one abort is enough).\n+               --  The processing at this point is rather different for the JVM\n+               --  case, so we completely separate the processing.\n \n-               --  If abort really needs to be deferred the expander must add\n-               --  this call explicitly, see Expand_N_Asynchronous_Select.\n+               --  For the VM case, we unconditionally call Update_Exception,\n+               --  passing a call to the intrinsic Current_Target_Exception\n+               --  (see JVM/.NET versions of Ada.Exceptions for details).\n \n-               Others_Choice :=\n-                 Nkind (First (Exception_Choices (Handler))) = N_Others_Choice;\n+               if VM_Target /= No_VM then\n+                  declare\n+                     Arg : constant Node_Id :=\n+                             Make_Function_Call (Loc,\n+                               Name =>\n+                                 New_Occurrence_Of\n+                                   (RTE (RE_Current_Target_Exception), Loc));\n+                  begin\n+                     Prepend_Call_To_Handler\n+                       (RE_Update_Exception, New_List (Arg));\n+                  end;\n \n-               if (Others_Choice\n-                   or else Entity (First (Exception_Choices (Handler))) /=\n-                     Stand.Abort_Signal)\n-                 and then not\n-                   (Others_Choice\n-                    and then All_Others (First (Exception_Choices (Handler))))\n-                 and then Abort_Allowed\n-               then\n-                  Prepend_Call_To_Handler (RE_Abort_Undefer);\n+                  --  For the normal case, we have to worry about the state of\n+                  --  abort deferral. Generally, we defer abort during runtime\n+                  --  handling of exceptions. When control is passed to the\n+                  --  handler, then in the normal case we undefer aborts. In\n+                  --  any case this entire handling is relevant only if aborts\n+                  --  are allowed!\n+\n+               elsif Abort_Allowed then\n+\n+                  --  There are some special cases in which we do not do the\n+                  --  undefer. In particular a finalization (AT END) handler\n+                  --  wants to operate with aborts still deferred.\n+\n+                  --  We also suppress the call if this is the special handler\n+                  --  for Abort_Signal, since if we are aborting, we want to\n+                  --  keep aborts deferred (one abort is enough).\n+\n+                  --  If abort really needs to be deferred the expander must\n+                  --  add this call explicitly, see\n+                  --  Expand_N_Asynchronous_Select.\n+\n+                  Others_Choice :=\n+                    Nkind (First (Exception_Choices (Handler))) =\n+                                                         N_Others_Choice;\n+\n+                  if (Others_Choice\n+                       or else Entity (First (Exception_Choices (Handler))) /=\n+                                                         Stand.Abort_Signal)\n+                    and then not\n+                      (Others_Choice\n+                        and then\n+                          All_Others (First (Exception_Choices (Handler))))\n+                    and then Abort_Allowed\n+                  then\n+                     Prepend_Call_To_Handler (RE_Abort_Undefer);\n+                  end if;\n                end if;\n             end if;\n          end if;\n@@ -1248,7 +1264,6 @@ package body Exp_Ch11 is\n             Insert_List_After_And_Analyze (N, L);\n          end if;\n       end if;\n-\n    end Expand_N_Exception_Declaration;\n \n    ---------------------------------------------\n@@ -1334,8 +1349,6 @@ package body Exp_Ch11 is\n       H     : Node_Id;\n \n    begin\n-      --  Debug_Flag_Dot_G := True;\n-\n       --  Processing for locally handled exception (exclude reraise case)\n \n       if Present (Name (N)) and then Nkind (Name (N)) = N_Identifier then"}, {"sha": "068d601c2c6d959d0da5c43c8813fcf2cd5933ff", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06eab6a7fadd9a6502a7fe439140f8ac1091231e/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06eab6a7fadd9a6502a7fe439140f8ac1091231e/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=06eab6a7fadd9a6502a7fe439140f8ac1091231e", "patch": "@@ -26,6 +26,7 @@\n with Atree;    use Atree;\n with Casing;   use Casing;\n with Errout;   use Errout;\n+with Debug;    use Debug;\n with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n with Lib;      use Lib;\n@@ -430,6 +431,18 @@ package body Restrict is\n                   Restrictions.Set (No_Exception_Propagation));\n    end No_Exception_Handlers_Set;\n \n+   -------------------------------------\n+   -- No_Exception_Propagation_Active --\n+   -------------------------------------\n+\n+   function No_Exception_Propagation_Active return Boolean is\n+   begin\n+      return (No_Run_Time_Mode\n+               or else Configurable_Run_Time_Mode\n+               or else Debug_Flag_Dot_G)\n+        and then Restriction_Active (No_Exception_Propagation);\n+   end No_Exception_Propagation_Active;\n+\n    ----------------------------------\n    -- Process_Restriction_Synonyms --\n    ----------------------------------"}, {"sha": "0cd4dbf28bf184184e0f26a63d90728038961f58", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06eab6a7fadd9a6502a7fe439140f8ac1091231e/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06eab6a7fadd9a6502a7fe439140f8ac1091231e/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=06eab6a7fadd9a6502a7fe439140f8ac1091231e", "patch": "@@ -249,6 +249,10 @@ package Restrict is\n    --  set. In the latter case, the source may contain handlers but they either\n    --  get converted using the local goto transformation or deleted.\n \n+   function No_Exception_Propagation_Active return Boolean;\n+   --  Test to see if current restrictions settings specify that no\n+   --  exception propagation is activated.\n+\n    function Process_Restriction_Synonyms (N : Node_Id) return Name_Id;\n    --  Id is a node whose Chars field contains the name of a restriction.\n    --  If it is one of synonyms that we allow for historical purposes (for"}]}