{"sha": "b3ad445f853ab7ca0da6216ff1bebfd6f90425f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNhZDQ0NWY4NTNhYjdjYTBkYTYyMTZmZjFiZWJmZDZmOTA0MjVmNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-01T12:52:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-01T12:52:50Z"}, "message": "Add narrower_subreg_mode helper function\n\nThis patch adds a narrowing equivalent of wider_subreg_mode.  At present\nthere is only one user.\n\n2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* rtl.h (narrower_subreg_mode): New function.\n\t* ira-color.c (update_costs_from_allocno): Use it.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254304", "tree": {"sha": "577e5328d9d178838c8eb7f7463fb071697131b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/577e5328d9d178838c8eb7f7463fb071697131b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3ad445f853ab7ca0da6216ff1bebfd6f90425f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ad445f853ab7ca0da6216ff1bebfd6f90425f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3ad445f853ab7ca0da6216ff1bebfd6f90425f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ad445f853ab7ca0da6216ff1bebfd6f90425f5/comments", "author": null, "committer": null, "parents": [{"sha": "4b926feae10ecec6555dca641c03a8239a824eab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b926feae10ecec6555dca641c03a8239a824eab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b926feae10ecec6555dca641c03a8239a824eab"}], "stats": {"total": 34, "additions": 25, "deletions": 9}, "files": [{"sha": "bdd6b73ae4f31e2bd39151dc0707a09f31b1532c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ad445f853ab7ca0da6216ff1bebfd6f90425f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ad445f853ab7ca0da6216ff1bebfd6f90425f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3ad445f853ab7ca0da6216ff1bebfd6f90425f5", "patch": "@@ -1,3 +1,10 @@\n+2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtl.h (narrower_subreg_mode): New function.\n+\t* ira-color.c (update_costs_from_allocno): Use it.\n+\n 2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "0148058aeee732790d11d1352a2606af8a98f67d", "filename": "gcc/ira-color.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ad445f853ab7ca0da6216ff1bebfd6f90425f5/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ad445f853ab7ca0da6216ff1bebfd6f90425f5/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=b3ad445f853ab7ca0da6216ff1bebfd6f90425f5", "patch": "@@ -1367,15 +1367,14 @@ update_costs_from_allocno (ira_allocno_t allocno, int hard_regno,\n \t      || ALLOCNO_ASSIGNED_P (another_allocno))\n \t    continue;\n \n-\t  if (GET_MODE_SIZE (ALLOCNO_MODE (cp->second)) < GET_MODE_SIZE (mode))\n-\t    /* If we have different modes use the smallest one.  It is\n-\t       a sub-register move.  It is hard to predict what LRA\n-\t       will reload (the pseudo or its sub-register) but LRA\n-\t       will try to minimize the data movement.  Also for some\n-\t       register classes bigger modes might be invalid,\n-\t       e.g. DImode for AREG on x86.  For such cases the\n-\t       register move cost will be maximal. */\n-\t    mode = ALLOCNO_MODE (cp->second);\n+\t  /* If we have different modes use the smallest one.  It is\n+\t     a sub-register move.  It is hard to predict what LRA\n+\t     will reload (the pseudo or its sub-register) but LRA\n+\t     will try to minimize the data movement.  Also for some\n+\t     register classes bigger modes might be invalid,\n+\t     e.g. DImode for AREG on x86.  For such cases the\n+\t     register move cost will be maximal.  */\n+\t  mode = narrower_subreg_mode (mode, ALLOCNO_MODE (cp->second));\n \t  \n \t  cost = (cp->second == allocno\n \t\t  ? ira_register_move_cost[mode][rclass][aclass]"}, {"sha": "8de5a1cada5a9d65f4f8b11bb826d441ba7e6298", "filename": "gcc/rtl.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ad445f853ab7ca0da6216ff1bebfd6f90425f5/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ad445f853ab7ca0da6216ff1bebfd6f90425f5/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b3ad445f853ab7ca0da6216ff1bebfd6f90425f5", "patch": "@@ -2954,6 +2954,16 @@ subreg_lowpart_offset (machine_mode outermode, machine_mode innermode)\n \t\t\t\t     GET_MODE_SIZE (innermode));\n }\n \n+/* Given that a subreg has outer mode OUTERMODE and inner mode INNERMODE,\n+   return the smaller of the two modes if they are different sizes,\n+   otherwise return the outer mode.  */\n+\n+inline machine_mode\n+narrower_subreg_mode (machine_mode outermode, machine_mode innermode)\n+{\n+  return paradoxical_subreg_p (outermode, innermode) ? innermode : outermode;\n+}\n+\n /* Given that a subreg has outer mode OUTERMODE and inner mode INNERMODE,\n    return the mode that is big enough to hold both the outer and inner\n    values.  Prefer the outer mode in the event of a tie.  */"}]}