{"sha": "f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNiMDFjZDk4ODA2OWFiNjUzZmIzNDQ4OGM2ZjBlYTliZmIyYmFlNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-17T09:38:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-17T09:38:12Z"}, "message": "[multiple changes]\n\n2009-04-17  Ed Schonberg  <schonberg@adacore.com>\n\n\t* atree.ads, atree.adb: Move New_Copy_Tree.to sem_util.\n\n\t* nlists.ads, nlists.adb: Move New_Copy_List to sem_util.\n\t\n\t* lib-load.adb: Use Copy_Separate_Tree rather than New_Copy_Tree\n\n\t* sem_util.ads, sem_util.adb: New_Copy_Tree and New_Copy_List belong in\n\tsemantic units, because the handling of itypes in the copied tree\n\trequires semantic information that does not belong in atree.\n\n2009-04-17  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch6.adb: Minor reformatting\n\n\t* prj.adb: Minor reformatting\n\nFrom-SVN: r146230", "tree": {"sha": "69f024da5f301a5d19395994058f7c9fff2082b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69f024da5f301a5d19395994058f7c9fff2082b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/comments", "author": null, "committer": null, "parents": [{"sha": "cec29135594f16fbbeafdb0ce26a65613c4d0567", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cec29135594f16fbbeafdb0ce26a65613c4d0567", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cec29135594f16fbbeafdb0ce26a65613c4d0567"}], "stats": {"total": 1303, "additions": 1168, "deletions": 135}, "files": [{"sha": "15330166f6460921271cdb74a213c81a61265776", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "patch": "@@ -1,3 +1,35 @@\n+2009-04-17  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Access_Subprogram_Definition): Additional checks on\n+\tillegal uses of incomplete types in formal parts and return types.\n+\n+\t* sem_ch6.adb (Process_Formals): Taft-amendment types are legal in\n+\taccess to subprograms.\n+\n+\t* sem_ch7.adb (Uninstall_Declarations): diagnose attempts to use\n+\tTaft-amendment types as the return type of an access_to_function type.\n+\n+\t* freeze.adb (Freeze_Entity): Remove tests on formals of an incomplete\n+\ttype for access_to_subprograms. The check is performed on package exit.\n+\n+2009-04-17  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* atree.ads, atree.adb: Move New_Copy_Tree.to sem_util.\n+\n+\t* nlists.ads, nlists.adb: Move New_Copy_List to sem_util.\n+\t\n+\t* lib-load.adb: Use Copy_Separate_Tree rather than New_Copy_Tree\n+\n+\t* sem_util.ads, sem_util.adb: New_Copy_Tree and New_Copy_List belong in\n+\tsemantic units, because the handling of itypes in the copied tree\n+\trequires semantic information that does not belong in atree.\n+\n+2009-04-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-ch6.adb: Minor reformatting\n+\n+\t* prj.adb: Minor reformatting\n+\n 2009-04-17  Gary Dismukes  <dismukes@adacore.com>\n \n \t* par-ch6.adb (P_Subprogram): Overriding indicators should be allowed"}, {"sha": "3745b38493882b89cb86196f6d207accde7ffa04", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 8, "deletions": 94, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "patch": "@@ -105,8 +105,6 @@ package body Atree is\n    use Atree_Private_Part;\n    --  We are also allowed to see our private data structures!\n \n-   function E_To_N is new Unchecked_Conversion (Entity_Kind, Node_Kind);\n-   function N_To_E is new Unchecked_Conversion (Node_Kind, Entity_Kind);\n    --  Functions used to store Entity_Kind value in Nkind field\n \n    --  The following declarations are used to store flags 65-72 in the\n@@ -395,91 +393,6 @@ package body Atree is\n    function To_Flag_Word5_Ptr is new\n      Unchecked_Conversion (Union_Id_Ptr, Flag_Word5_Ptr);\n \n-   --  Default value used to initialize default nodes. Note that some of the\n-   --  fields get overwritten, and in particular, Nkind always gets reset.\n-\n-   Default_Node : Node_Record := (\n-      Is_Extension      => False,\n-      Pflag1            => False,\n-      Pflag2            => False,\n-      In_List           => False,\n-      Unused_1          => False,\n-      Rewrite_Ins       => False,\n-      Analyzed          => False,\n-      Comes_From_Source => False, -- modified by Set_Comes_From_Source_Default\n-      Error_Posted      => False,\n-      Flag4             => False,\n-\n-      Flag5             => False,\n-      Flag6             => False,\n-      Flag7             => False,\n-      Flag8             => False,\n-      Flag9             => False,\n-      Flag10            => False,\n-      Flag11            => False,\n-      Flag12            => False,\n-\n-      Flag13            => False,\n-      Flag14            => False,\n-      Flag15            => False,\n-      Flag16            => False,\n-      Flag17            => False,\n-      Flag18            => False,\n-\n-      Nkind             => N_Unused_At_Start,\n-\n-      Sloc              => No_Location,\n-      Link              => Empty_List_Or_Node,\n-      Field1            => Empty_List_Or_Node,\n-      Field2            => Empty_List_Or_Node,\n-      Field3            => Empty_List_Or_Node,\n-      Field4            => Empty_List_Or_Node,\n-      Field5            => Empty_List_Or_Node);\n-\n-   --  Default value used to initialize node extensions (i.e. the second\n-   --  and third and fourth components of an extended node). Note we are\n-   --  cheating a bit here when it comes to Node12, which really holds\n-   --  flags an (for the third component), the convention. But it works\n-   --  because Empty, False, Convention_Ada, all happen to be all zero bits.\n-\n-   Default_Node_Extension : constant Node_Record := (\n-      Is_Extension      => True,\n-      Pflag1            => False,\n-      Pflag2            => False,\n-      In_List           => False,\n-      Unused_1          => False,\n-      Rewrite_Ins       => False,\n-      Analyzed          => False,\n-      Comes_From_Source => False,\n-      Error_Posted      => False,\n-      Flag4             => False,\n-\n-      Flag5             => False,\n-      Flag6             => False,\n-      Flag7             => False,\n-      Flag8             => False,\n-      Flag9             => False,\n-      Flag10            => False,\n-      Flag11            => False,\n-      Flag12            => False,\n-\n-      Flag13            => False,\n-      Flag14            => False,\n-      Flag15            => False,\n-      Flag16            => False,\n-      Flag17            => False,\n-      Flag18            => False,\n-\n-      Nkind             => E_To_N (E_Void),\n-\n-      Field6            => Empty_List_Or_Node,\n-      Field7            => Empty_List_Or_Node,\n-      Field8            => Empty_List_Or_Node,\n-      Field9            => Empty_List_Or_Node,\n-      Field10           => Empty_List_Or_Node,\n-      Field11           => Empty_List_Or_Node,\n-      Field12           => Empty_List_Or_Node);\n-\n    --------------------------------------------------\n    -- Implementation of Tree Substitution Routines --\n    --------------------------------------------------\n@@ -1218,7 +1131,7 @@ package body Atree is\n \n    --  Start of processing for New_Copy_Tree function\n \n-   function New_Copy_Tree\n+   function New_Copy_Tree1\n      (Source    : Node_Id;\n       Map       : Elist_Id := No_Elist;\n       New_Sloc  : Source_Ptr := No_Location;\n@@ -1835,12 +1748,9 @@ package body Atree is\n          --  The new Itype has all the attributes of the old one, and\n          --  we just copy the contents of the entity. However, the back-end\n          --  needs different names for debugging purposes, so we create a\n-         --  new internal name by appending the letter 'c' (copy) to the\n-         --  name of the original.\n+         --  new internal name for it in all cases.\n \n-         Get_Name_String (Chars (Old_Itype));\n-         Add_Char_To_Name_Buffer ('c');\n-         Set_Chars (New_Itype, Name_Enter);\n+         --  Set_Chars (New_Itype, New_Internal_Name ('T'));\n \n          --  If our associated node is an entity that has already been copied,\n          --  then set the associated node of the copy to point to the right\n@@ -1952,6 +1862,10 @@ package body Atree is\n                             Old_Itype);\n             end if;\n          end if;\n+         Get_Name_String (Chars (Old_Itype));\n+         Add_Char_To_Name_Buffer ('c');\n+         Add_Nat_To_Name_Buffer (Int (Associated_Node_For_Itype (New_Itype)));\n+         Set_Chars (New_Itype, Name_Enter);\n       end Visit_Itype;\n \n       ----------------\n@@ -2085,7 +1999,7 @@ package body Atree is\n       --  Now we can copy the actual tree\n \n       return Copy_Node_With_Replacement (Source);\n-   end New_Copy_Tree;\n+   end New_Copy_Tree1;\n \n    ----------------\n    -- New_Entity --"}, {"sha": "8807638f86229104e6a76e7a76ccaa4873f06d04", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 90, "deletions": 1, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "patch": "@@ -430,7 +430,7 @@ package Atree is\n    --  Source to be Empty, in which case Relocate_Node simply returns\n    --  Empty as the result.\n \n-   function New_Copy_Tree\n+   function New_Copy_Tree1\n      (Source    : Node_Id;\n       Map       : Elist_Id   := No_Elist;\n       New_Sloc  : Source_Ptr := No_Location;\n@@ -3114,6 +3114,95 @@ package Atree is\n       for Node_Record'Size use 8*32;\n       for Node_Record'Alignment use 4;\n \n+      function E_To_N is new Unchecked_Conversion (Entity_Kind, Node_Kind);\n+      function N_To_E is new Unchecked_Conversion (Node_Kind, Entity_Kind);\n+\n+      --  Default value used to initialize default nodes. Note that some of the\n+      --  fields get overwritten, and in particular, Nkind always gets reset.\n+\n+      Default_Node : Node_Record := (\n+         Is_Extension      => False,\n+         Pflag1            => False,\n+         Pflag2            => False,\n+         In_List           => False,\n+         Unused_1          => False,\n+         Rewrite_Ins       => False,\n+         Analyzed          => False,\n+         Comes_From_Source => False,\n+         --  modified by Set_Comes_From_Source_Default\n+         Error_Posted      => False,\n+         Flag4             => False,\n+\n+         Flag5             => False,\n+         Flag6             => False,\n+         Flag7             => False,\n+         Flag8             => False,\n+         Flag9             => False,\n+         Flag10            => False,\n+         Flag11            => False,\n+         Flag12            => False,\n+\n+         Flag13            => False,\n+         Flag14            => False,\n+         Flag15            => False,\n+         Flag16            => False,\n+         Flag17            => False,\n+         Flag18            => False,\n+\n+         Nkind             => N_Unused_At_Start,\n+\n+         Sloc              => No_Location,\n+         Link              => Empty_List_Or_Node,\n+         Field1            => Empty_List_Or_Node,\n+         Field2            => Empty_List_Or_Node,\n+         Field3            => Empty_List_Or_Node,\n+         Field4            => Empty_List_Or_Node,\n+         Field5            => Empty_List_Or_Node);\n+\n+      --  Default value used to initialize node extensions (i.e. the second\n+      --  and third and fourth components of an extended node). Note we are\n+      --  cheating a bit here when it comes to Node12, which really holds\n+      --  flags an (for the third component), the convention. But it works\n+      --  because Empty, False, Convention_Ada, all happen to be all zero bits.\n+\n+      Default_Node_Extension : constant Node_Record := (\n+         Is_Extension      => True,\n+         Pflag1            => False,\n+         Pflag2            => False,\n+         In_List           => False,\n+         Unused_1          => False,\n+         Rewrite_Ins       => False,\n+         Analyzed          => False,\n+         Comes_From_Source => False,\n+         Error_Posted      => False,\n+         Flag4             => False,\n+\n+         Flag5             => False,\n+         Flag6             => False,\n+         Flag7             => False,\n+         Flag8             => False,\n+         Flag9             => False,\n+         Flag10            => False,\n+         Flag11            => False,\n+         Flag12            => False,\n+\n+         Flag13            => False,\n+         Flag14            => False,\n+         Flag15            => False,\n+         Flag16            => False,\n+         Flag17            => False,\n+         Flag18            => False,\n+\n+         Nkind             => E_To_N (E_Void),\n+\n+         Field6            => Empty_List_Or_Node,\n+         Field7            => Empty_List_Or_Node,\n+         Field8            => Empty_List_Or_Node,\n+         Field9            => Empty_List_Or_Node,\n+         Field10           => Empty_List_Or_Node,\n+         Field11           => Empty_List_Or_Node,\n+         Field12           => Empty_List_Or_Node);\n+\n       --  The following defines the extendable array used for the nodes table\n       --  Nodes with extensions use five consecutive entries in the array\n "}, {"sha": "857b609b0bc2d4f395c98e00396bbbe3d2f6d33c", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "patch": "@@ -169,14 +169,14 @@ package body Lib.Load is\n              Chars => Chars (Selector_Name (Name (With_Node))));\n          Du_Name :=\n            Make_Defining_Program_Unit_Name (No_Location,\n-             Name => New_Copy_Tree (Prefix (Name (With_Node))),\n+             Name => Copy_Separate_Tree (Prefix (Name (With_Node))),\n              Defining_Identifier => Cunit_Entity);\n \n          Set_Is_Child_Unit (Cunit_Entity);\n \n          End_Lab :=\n            Make_Designator (No_Location,\n-             Name => New_Copy_Tree (Prefix (Name (With_Node))),\n+             Name => Copy_Separate_Tree (Prefix (Name (With_Node))),\n              Identifier => New_Occurrence_Of (Cunit_Entity, No_Location));\n       end if;\n "}, {"sha": "09bd85a8439b3d6f1a3600a0e931e9095890a072", "filename": "gcc/ada/nlists.adb", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fnlists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fnlists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.adb?ref=f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "patch": "@@ -745,31 +745,6 @@ package body Nlists is\n       end if;\n    end New_Copy_List_Original;\n \n-   ------------------------\n-   -- New_Copy_List_Tree --\n-   ------------------------\n-\n-   function New_Copy_List_Tree (List : List_Id) return List_Id is\n-      NL : List_Id;\n-      E  : Node_Id;\n-\n-   begin\n-      if List = No_List then\n-         return No_List;\n-\n-      else\n-         NL := New_List;\n-         E := First (List);\n-\n-         while Present (E) loop\n-            Append (New_Copy_Tree (E), NL);\n-            E := Next (E);\n-         end loop;\n-\n-         return NL;\n-      end if;\n-   end New_Copy_List_Tree;\n-\n    --------------\n    -- New_List --\n    --------------"}, {"sha": "3753936df105d69e3a7c006504caf5d1ef34ec83", "filename": "gcc/ada/nlists.ads", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fnlists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fnlists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.ads?ref=f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "patch": "@@ -108,13 +108,6 @@ package Nlists is\n    function New_Copy_List_Original (List : List_Id) return List_Id;\n    --  Same as New_Copy_List but copies only nodes coming from source\n \n-   function New_Copy_List_Tree (List : List_Id) return List_Id;\n-   --  Similar to New_Copy_List, except that the copies are done using the\n-   --  Atree.New_Copy_Tree function, which means that a full recursive copy\n-   --  of the subtrees in the list is performed, setting proper parents. As\n-   --  for New_Copy_Tree, it is illegal to attempt to copy extended nodes\n-   --  (entities) either directly or indirectly using this function.\n-\n    function First (List : List_Id) return Node_Id;\n    pragma Inline (First);\n    --  Obtains the first element of the given node list or, if the node list"}, {"sha": "d91b2d9f15dceb2c035bf0d702dc1e25d729381e", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "patch": "@@ -221,13 +221,12 @@ package body Ch6 is\n          --  and bodies can occur.\n \n          if Pf_Flags /= Pf_Decl_Gins_Pbod_Rnam_Stub\n-           and then Pf_Flags /= Pf_Decl_Pbod\n+              and then\n+            Pf_Flags /= Pf_Decl_Pbod\n          then\n             Error_Msg_SC (\"overriding indicator not allowed here!\");\n \n-         elsif Token /= Tok_Function\n-           and then Token /= Tok_Procedure\n-         then\n+         elsif Token /= Tok_Function and then Token /= Tok_Procedure then\n             Error_Msg_SC (\"FUNCTION or PROCEDURE expected!\");\n          end if;\n       end if;"}, {"sha": "d8f368d39964a2cc93b5990b6172f1b37d90b2eb", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "patch": "@@ -715,8 +715,8 @@ package body Prj is\n    is\n    begin\n       if Object_File_Suffix = No_Name then\n-         return Extend_Name (Source_File_Name, Object_Suffix);\n-\n+         return Extend_Name\n+           (Source_File_Name, Object_Suffix);\n       else\n          return Extend_Name\n            (Source_File_Name, Get_Name_String (Object_File_Suffix));\n@@ -880,6 +880,7 @@ package body Prj is\n          loop\n             Free (Tree.Projects.Table (P));\n          end loop;\n+\n          Project_Table.Free (Tree.Projects);\n \n          --  Private part\n@@ -929,6 +930,7 @@ package body Prj is\n             Free (Tree.Projects.Table (P));\n          end loop;\n       end if;\n+\n       Project_Table.Init            (Tree.Projects);\n \n       --  Private part table"}, {"sha": "337d1ac0cf0f1ac1a0ff7efb2aaa6634a7ddd166", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 978, "deletions": 0, "changes": 978, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "patch": "@@ -59,8 +59,38 @@ with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n with Uname;    use Uname;\n \n+with GNAT.HTable; use GNAT.HTable;\n package body Sem_Util is\n \n+   ----------------------------------------\n+   -- Global_Variables for New_Copy_Tree --\n+   ----------------------------------------\n+\n+   --  These global variables are used by New_Copy_Tree. See description\n+   --  of the body of this subprogram for details. Global variables can be\n+   --  safely used by New_Copy_Tree, since there is no case of a recursive\n+   --  call from the processing inside New_Copy_Tree.\n+\n+   NCT_Hash_Threshhold : constant := 20;\n+   --  If there are more than this number of pairs of entries in the\n+   --  map, then Hash_Tables_Used will be set, and the hash tables will\n+   --  be initialized and used for the searches.\n+\n+   NCT_Hash_Tables_Used : Boolean := False;\n+   --  Set to True if hash tables are in use\n+\n+   NCT_Table_Entries : Nat;\n+   --  Count entries in table to see if threshhold is reached\n+\n+   NCT_Hash_Table_Setup : Boolean := False;\n+   --  Set to True if hash table contains data. We set this True if we\n+   --  setup the hash table with data, and leave it set permanently\n+   --  from then on, this is a signal that second and subsequent users\n+   --  of the hash table must clear the old entries before reuse.\n+\n+   subtype NCT_Header_Num is Int range 0 .. 511;\n+   --  Defines range of headers in hash tables (512 headers)\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -7431,6 +7461,954 @@ package body Sem_Util is\n       end if;\n    end Needs_One_Actual;\n \n+   ------------------------\n+   -- New_Copy_List_Tree --\n+   ------------------------\n+\n+   function New_Copy_List_Tree (List : List_Id) return List_Id is\n+      NL : List_Id;\n+      E  : Node_Id;\n+\n+   begin\n+      if List = No_List then\n+         return No_List;\n+\n+      else\n+         NL := New_List;\n+         E := First (List);\n+\n+         while Present (E) loop\n+            Append (New_Copy_Tree (E), NL);\n+            E := Next (E);\n+         end loop;\n+\n+         return NL;\n+      end if;\n+   end New_Copy_List_Tree;\n+\n+   -------------------\n+   -- New_Copy_Tree --\n+   -------------------\n+\n+   use Atree.Unchecked_Access;\n+   use Atree_Private_Part;\n+\n+   --  Our approach here requires a two pass traversal of the tree. The\n+   --  first pass visits all nodes that eventually will be copied looking\n+   --  for defining Itypes. If any defining Itypes are found, then they are\n+   --  copied, and an entry is added to the replacement map. In the second\n+   --  phase, the tree is copied, using the replacement map to replace any\n+   --  Itype references within the copied tree.\n+\n+   --  The following hash tables are used if the Map supplied has more\n+   --  than hash threshhold entries to speed up access to the map. If\n+   --  there are fewer entries, then the map is searched sequentially\n+   --  (because setting up a hash table for only a few entries takes\n+   --  more time than it saves.\n+\n+   function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num;\n+   --  Hash function used for hash operations\n+\n+   -------------------\n+   -- New_Copy_Hash --\n+   -------------------\n+\n+   function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num is\n+   begin\n+      return Nat (E) mod (NCT_Header_Num'Last + 1);\n+   end New_Copy_Hash;\n+\n+   ---------------\n+   -- NCT_Assoc --\n+   ---------------\n+\n+   --  The hash table NCT_Assoc associates old entities in the table\n+   --  with their corresponding new entities (i.e. the pairs of entries\n+   --  presented in the original Map argument are Key-Element pairs).\n+\n+   package NCT_Assoc is new Simple_HTable (\n+     Header_Num => NCT_Header_Num,\n+     Element    => Entity_Id,\n+     No_Element => Empty,\n+     Key        => Entity_Id,\n+     Hash       => New_Copy_Hash,\n+     Equal      => Types.\"=\");\n+\n+   ---------------------\n+   -- NCT_Itype_Assoc --\n+   ---------------------\n+\n+   --  The hash table NCT_Itype_Assoc contains entries only for those\n+   --  old nodes which have a non-empty Associated_Node_For_Itype set.\n+   --  The key is the associated node, and the element is the new node\n+   --  itself (NOT the associated node for the new node).\n+\n+   package NCT_Itype_Assoc is new Simple_HTable (\n+     Header_Num => NCT_Header_Num,\n+     Element    => Entity_Id,\n+     No_Element => Empty,\n+     Key        => Entity_Id,\n+     Hash       => New_Copy_Hash,\n+     Equal      => Types.\"=\");\n+\n+   --  Start of processing for New_Copy_Tree function\n+\n+   function New_Copy_Tree\n+     (Source    : Node_Id;\n+      Map       : Elist_Id := No_Elist;\n+      New_Sloc  : Source_Ptr := No_Location;\n+      New_Scope : Entity_Id := Empty) return Node_Id\n+   is\n+      Actual_Map : Elist_Id := Map;\n+      --  This is the actual map for the copy. It is initialized with the\n+      --  given elements, and then enlarged as required for Itypes that are\n+      --  copied during the first phase of the copy operation. The visit\n+      --  procedures add elements to this map as Itypes are encountered.\n+      --  The reason we cannot use Map directly, is that it may well be\n+      --  (and normally is) initialized to No_Elist, and if we have mapped\n+      --  entities, we have to reset it to point to a real Elist.\n+\n+      function Assoc (N : Node_Or_Entity_Id) return Node_Id;\n+      --  Called during second phase to map entities into their corresponding\n+      --  copies using Actual_Map. If the argument is not an entity, or is not\n+      --  in Actual_Map, then it is returned unchanged.\n+\n+      procedure Build_NCT_Hash_Tables;\n+      --  Builds hash tables (number of elements >= threshold value)\n+\n+      function Copy_Elist_With_Replacement\n+        (Old_Elist : Elist_Id) return Elist_Id;\n+      --  Called during second phase to copy element list doing replacements\n+\n+      procedure Copy_Itype_With_Replacement (New_Itype : Entity_Id);\n+      --  Called during the second phase to process a copied Itype. The actual\n+      --  copy happened during the first phase (so that we could make the entry\n+      --  in the mapping), but we still have to deal with the descendents of\n+      --  the copied Itype and copy them where necessary.\n+\n+      function Copy_List_With_Replacement (Old_List : List_Id) return List_Id;\n+      --  Called during second phase to copy list doing replacements\n+\n+      function Copy_Node_With_Replacement (Old_Node : Node_Id) return Node_Id;\n+      --  Called during second phase to copy node doing replacements\n+\n+      procedure Visit_Elist (E : Elist_Id);\n+      --  Called during first phase to visit all elements of an Elist\n+\n+      procedure Visit_Field (F : Union_Id; N : Node_Id);\n+      --  Visit a single field, recursing to call Visit_Node or Visit_List\n+      --  if the field is a syntactic descendent of the current node (i.e.\n+      --  its parent is Node N).\n+\n+      procedure Visit_Itype (Old_Itype : Entity_Id);\n+      --  Called during first phase to visit subsidiary fields of a defining\n+      --  Itype, and also create a copy and make an entry in the replacement\n+      --  map for the new copy.\n+\n+      procedure Visit_List (L : List_Id);\n+      --  Called during first phase to visit all elements of a List\n+\n+      procedure Visit_Node (N : Node_Or_Entity_Id);\n+      --  Called during first phase to visit a node and all its subtrees\n+\n+      -----------\n+      -- Assoc --\n+      -----------\n+\n+      function Assoc (N : Node_Or_Entity_Id) return Node_Id is\n+         E   : Elmt_Id;\n+         Ent : Entity_Id;\n+\n+      begin\n+         if not Has_Extension (N) or else No (Actual_Map) then\n+            return N;\n+\n+         elsif NCT_Hash_Tables_Used then\n+            Ent := NCT_Assoc.Get (Entity_Id (N));\n+\n+            if Present (Ent) then\n+               return Ent;\n+            else\n+               return N;\n+            end if;\n+\n+         --  No hash table used, do serial search\n+\n+         else\n+            E := First_Elmt (Actual_Map);\n+            while Present (E) loop\n+               if Node (E) = N then\n+                  return Node (Next_Elmt (E));\n+               else\n+                  E := Next_Elmt (Next_Elmt (E));\n+               end if;\n+            end loop;\n+         end if;\n+\n+         return N;\n+      end Assoc;\n+\n+      ---------------------------\n+      -- Build_NCT_Hash_Tables --\n+      ---------------------------\n+\n+      procedure Build_NCT_Hash_Tables is\n+         Elmt : Elmt_Id;\n+         Ent  : Entity_Id;\n+      begin\n+         if NCT_Hash_Table_Setup then\n+            NCT_Assoc.Reset;\n+            NCT_Itype_Assoc.Reset;\n+         end if;\n+\n+         Elmt := First_Elmt (Actual_Map);\n+         while Present (Elmt) loop\n+            Ent := Node (Elmt);\n+\n+            --  Get new entity, and associate old and new\n+\n+            Next_Elmt (Elmt);\n+            NCT_Assoc.Set (Ent, Node (Elmt));\n+\n+            if Is_Type (Ent) then\n+               declare\n+                  Anode : constant Entity_Id :=\n+                            Associated_Node_For_Itype (Ent);\n+\n+               begin\n+                  if Present (Anode) then\n+\n+                     --  Enter a link between the associated node of the\n+                     --  old Itype and the new Itype, for updating later\n+                     --  when node is copied.\n+\n+                     NCT_Itype_Assoc.Set (Anode, Node (Elmt));\n+                  end if;\n+               end;\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+\n+         NCT_Hash_Tables_Used := True;\n+         NCT_Hash_Table_Setup := True;\n+      end Build_NCT_Hash_Tables;\n+\n+      ---------------------------------\n+      -- Copy_Elist_With_Replacement --\n+      ---------------------------------\n+\n+      function Copy_Elist_With_Replacement\n+        (Old_Elist : Elist_Id) return Elist_Id\n+      is\n+         M         : Elmt_Id;\n+         New_Elist : Elist_Id;\n+\n+      begin\n+         if No (Old_Elist) then\n+            return No_Elist;\n+\n+         else\n+            New_Elist := New_Elmt_List;\n+\n+            M := First_Elmt (Old_Elist);\n+            while Present (M) loop\n+               Append_Elmt (Copy_Node_With_Replacement (Node (M)), New_Elist);\n+               Next_Elmt (M);\n+            end loop;\n+         end if;\n+\n+         return New_Elist;\n+      end Copy_Elist_With_Replacement;\n+\n+      ---------------------------------\n+      -- Copy_Itype_With_Replacement --\n+      ---------------------------------\n+\n+      --  This routine exactly parallels its phase one analog Visit_Itype,\n+\n+      procedure Copy_Itype_With_Replacement (New_Itype : Entity_Id) is\n+      begin\n+         --  Translate Next_Entity, Scope and Etype fields, in case they\n+         --  reference entities that have been mapped into copies.\n+\n+         Set_Next_Entity (New_Itype, Assoc (Next_Entity (New_Itype)));\n+         Set_Etype       (New_Itype, Assoc (Etype       (New_Itype)));\n+\n+         if Present (New_Scope) then\n+            Set_Scope    (New_Itype, New_Scope);\n+         else\n+            Set_Scope    (New_Itype, Assoc (Scope       (New_Itype)));\n+         end if;\n+\n+         --  Copy referenced fields\n+\n+         if Is_Discrete_Type (New_Itype) then\n+            Set_Scalar_Range (New_Itype,\n+              Copy_Node_With_Replacement (Scalar_Range (New_Itype)));\n+\n+         elsif Has_Discriminants (Base_Type (New_Itype)) then\n+            Set_Discriminant_Constraint (New_Itype,\n+              Copy_Elist_With_Replacement\n+                (Discriminant_Constraint (New_Itype)));\n+\n+         elsif Is_Array_Type (New_Itype) then\n+            if Present (First_Index (New_Itype)) then\n+               Set_First_Index (New_Itype,\n+                 First (Copy_List_With_Replacement\n+                         (List_Containing (First_Index (New_Itype)))));\n+            end if;\n+\n+            if Is_Packed (New_Itype) then\n+               Set_Packed_Array_Type (New_Itype,\n+                 Copy_Node_With_Replacement\n+                   (Packed_Array_Type (New_Itype)));\n+            end if;\n+         end if;\n+      end Copy_Itype_With_Replacement;\n+\n+      --------------------------------\n+      -- Copy_List_With_Replacement --\n+      --------------------------------\n+\n+      function Copy_List_With_Replacement\n+        (Old_List : List_Id) return List_Id\n+      is\n+         New_List : List_Id;\n+         E        : Node_Id;\n+\n+      begin\n+         if Old_List = No_List then\n+            return No_List;\n+\n+         else\n+            New_List := Empty_List;\n+\n+            E := First (Old_List);\n+            while Present (E) loop\n+               Append (Copy_Node_With_Replacement (E), New_List);\n+               Next (E);\n+            end loop;\n+\n+            return New_List;\n+         end if;\n+      end Copy_List_With_Replacement;\n+\n+      --------------------------------\n+      -- Copy_Node_With_Replacement --\n+      --------------------------------\n+\n+      function Copy_Node_With_Replacement\n+        (Old_Node : Node_Id) return Node_Id\n+      is\n+         New_Node : Node_Id;\n+\n+         procedure Adjust_Named_Associations\n+           (Old_Node : Node_Id;\n+            New_Node : Node_Id);\n+         --  If a call node has named associations, these are chained through\n+         --  the First_Named_Actual, Next_Named_Actual links. These must be\n+         --  propagated separately to the new parameter list, because these\n+         --  are not syntactic fields.\n+\n+         function Copy_Field_With_Replacement\n+           (Field : Union_Id) return Union_Id;\n+         --  Given Field, which is a field of Old_Node, return a copy of it\n+         --  if it is a syntactic field (i.e. its parent is Node), setting\n+         --  the parent of the copy to poit to New_Node. Otherwise returns\n+         --  the field (possibly mapped if it is an entity).\n+\n+         -------------------------------\n+         -- Adjust_Named_Associations --\n+         -------------------------------\n+\n+         procedure Adjust_Named_Associations\n+           (Old_Node : Node_Id;\n+            New_Node : Node_Id)\n+         is\n+            Old_E : Node_Id;\n+            New_E : Node_Id;\n+\n+            Old_Next : Node_Id;\n+            New_Next : Node_Id;\n+\n+         begin\n+            Old_E := First (Parameter_Associations (Old_Node));\n+            New_E := First (Parameter_Associations (New_Node));\n+            while Present (Old_E) loop\n+               if Nkind (Old_E) = N_Parameter_Association\n+                 and then Present (Next_Named_Actual (Old_E))\n+               then\n+                  if First_Named_Actual (Old_Node)\n+                    =  Explicit_Actual_Parameter (Old_E)\n+                  then\n+                     Set_First_Named_Actual\n+                       (New_Node, Explicit_Actual_Parameter (New_E));\n+                  end if;\n+\n+                  --  Now scan parameter list from the beginning,to locate\n+                  --  next named actual, which can be out of order.\n+\n+                  Old_Next := First (Parameter_Associations (Old_Node));\n+                  New_Next := First (Parameter_Associations (New_Node));\n+\n+                  while Nkind (Old_Next) /= N_Parameter_Association\n+                    or else  Explicit_Actual_Parameter (Old_Next)\n+                      /= Next_Named_Actual (Old_E)\n+                  loop\n+                     Next (Old_Next);\n+                     Next (New_Next);\n+                  end loop;\n+\n+                  Set_Next_Named_Actual\n+                    (New_E, Explicit_Actual_Parameter (New_Next));\n+               end if;\n+\n+               Next (Old_E);\n+               Next (New_E);\n+            end loop;\n+         end Adjust_Named_Associations;\n+\n+         ---------------------------------\n+         -- Copy_Field_With_Replacement --\n+         ---------------------------------\n+\n+         function Copy_Field_With_Replacement\n+           (Field : Union_Id) return Union_Id\n+         is\n+         begin\n+            if Field = Union_Id (Empty) then\n+               return Field;\n+\n+            elsif Field in Node_Range then\n+               declare\n+                  Old_N : constant Node_Id := Node_Id (Field);\n+                  New_N : Node_Id;\n+\n+               begin\n+                  --  If syntactic field, as indicated by the parent pointer\n+                  --  being set, then copy the referenced node recursively.\n+\n+                  if Parent (Old_N) = Old_Node then\n+                     New_N := Copy_Node_With_Replacement (Old_N);\n+\n+                     if New_N /= Old_N then\n+                        Set_Parent (New_N, New_Node);\n+                     end if;\n+\n+                  --  For semantic fields, update possible entity reference\n+                  --  from the replacement map.\n+\n+                  else\n+                     New_N := Assoc (Old_N);\n+                  end if;\n+\n+                  return Union_Id (New_N);\n+               end;\n+\n+            elsif Field in List_Range then\n+               declare\n+                  Old_L : constant List_Id := List_Id (Field);\n+                  New_L : List_Id;\n+\n+               begin\n+                  --  If syntactic field, as indicated by the parent pointer,\n+                  --  then recursively copy the entire referenced list.\n+\n+                  if Parent (Old_L) = Old_Node then\n+                     New_L := Copy_List_With_Replacement (Old_L);\n+                     Set_Parent (New_L, New_Node);\n+\n+                  --  For semantic list, just returned unchanged\n+\n+                  else\n+                     New_L := Old_L;\n+                  end if;\n+\n+                  return Union_Id (New_L);\n+               end;\n+\n+            --  Anything other than a list or a node is returned unchanged\n+\n+            else\n+               return Field;\n+            end if;\n+         end Copy_Field_With_Replacement;\n+\n+      --  Start of processing for Copy_Node_With_Replacement\n+\n+      begin\n+         if Old_Node <= Empty_Or_Error then\n+            return Old_Node;\n+\n+         elsif Has_Extension (Old_Node) then\n+            return Assoc (Old_Node);\n+\n+         else\n+            New_Node := New_Copy (Old_Node);\n+\n+            --  If the node we are copying is the associated node of a\n+            --  previously copied Itype, then adjust the associated node\n+            --  of the copy of that Itype accordingly.\n+\n+            if Present (Actual_Map) then\n+               declare\n+                  E   : Elmt_Id;\n+                  Ent : Entity_Id;\n+\n+               begin\n+                  --  Case of hash table used\n+\n+                  if NCT_Hash_Tables_Used then\n+                     Ent := NCT_Itype_Assoc.Get (Old_Node);\n+\n+                     if Present (Ent) then\n+                        Set_Associated_Node_For_Itype (Ent, New_Node);\n+                     end if;\n+\n+                  --  Case of no hash table used\n+\n+                  else\n+                     E := First_Elmt (Actual_Map);\n+                     while Present (E) loop\n+                        if Is_Itype (Node (E))\n+                          and then\n+                            Old_Node = Associated_Node_For_Itype (Node (E))\n+                        then\n+                           Set_Associated_Node_For_Itype\n+                             (Node (Next_Elmt (E)), New_Node);\n+                        end if;\n+\n+                        E := Next_Elmt (Next_Elmt (E));\n+                     end loop;\n+                  end if;\n+               end;\n+            end if;\n+\n+            --  Recursively copy descendents\n+\n+            Set_Field1\n+              (New_Node, Copy_Field_With_Replacement (Field1 (New_Node)));\n+            Set_Field2\n+              (New_Node, Copy_Field_With_Replacement (Field2 (New_Node)));\n+            Set_Field3\n+              (New_Node, Copy_Field_With_Replacement (Field3 (New_Node)));\n+            Set_Field4\n+              (New_Node, Copy_Field_With_Replacement (Field4 (New_Node)));\n+            Set_Field5\n+              (New_Node, Copy_Field_With_Replacement (Field5 (New_Node)));\n+\n+            --  Adjust Sloc of new node if necessary\n+\n+            if New_Sloc /= No_Location then\n+               Set_Sloc (New_Node, New_Sloc);\n+\n+               --  If we adjust the Sloc, then we are essentially making\n+               --  a completely new node, so the Comes_From_Source flag\n+               --  should be reset to the proper default value.\n+\n+               Nodes.Table (New_Node).Comes_From_Source :=\n+                 Default_Node.Comes_From_Source;\n+            end if;\n+\n+            --  If the node is call and has named associations,\n+            --  set the corresponding links in the copy.\n+\n+            if (Nkind (Old_Node) = N_Function_Call\n+                 or else Nkind (Old_Node) = N_Entry_Call_Statement\n+                 or else\n+                   Nkind (Old_Node) = N_Procedure_Call_Statement)\n+              and then Present (First_Named_Actual (Old_Node))\n+            then\n+               Adjust_Named_Associations (Old_Node, New_Node);\n+            end if;\n+\n+            --  Reset First_Real_Statement for Handled_Sequence_Of_Statements.\n+            --  The replacement mechanism applies to entities, and is not used\n+            --  here. Eventually we may need a more general graph-copying\n+            --  routine. For now, do a sequential search to find desired node.\n+\n+            if Nkind (Old_Node) = N_Handled_Sequence_Of_Statements\n+              and then Present (First_Real_Statement (Old_Node))\n+            then\n+               declare\n+                  Old_F  : constant Node_Id := First_Real_Statement (Old_Node);\n+                  N1, N2 : Node_Id;\n+\n+               begin\n+                  N1 := First (Statements (Old_Node));\n+                  N2 := First (Statements (New_Node));\n+\n+                  while N1 /= Old_F loop\n+                     Next (N1);\n+                     Next (N2);\n+                  end loop;\n+\n+                  Set_First_Real_Statement (New_Node, N2);\n+               end;\n+            end if;\n+         end if;\n+\n+         --  All done, return copied node\n+\n+         return New_Node;\n+      end Copy_Node_With_Replacement;\n+\n+      -----------------\n+      -- Visit_Elist --\n+      -----------------\n+\n+      procedure Visit_Elist (E : Elist_Id) is\n+         Elmt : Elmt_Id;\n+      begin\n+         if Present (E) then\n+            Elmt := First_Elmt (E);\n+\n+            while Elmt /= No_Elmt loop\n+               Visit_Node (Node (Elmt));\n+               Next_Elmt (Elmt);\n+            end loop;\n+         end if;\n+      end Visit_Elist;\n+\n+      -----------------\n+      -- Visit_Field --\n+      -----------------\n+\n+      procedure Visit_Field (F : Union_Id; N : Node_Id) is\n+      begin\n+         if F = Union_Id (Empty) then\n+            return;\n+\n+         elsif F in Node_Range then\n+\n+            --  Copy node if it is syntactic, i.e. its parent pointer is\n+            --  set to point to the field that referenced it (certain\n+            --  Itypes will also meet this criterion, which is fine, since\n+            --  these are clearly Itypes that do need to be copied, since\n+            --  we are copying their parent.)\n+\n+            if Parent (Node_Id (F)) = N then\n+               Visit_Node (Node_Id (F));\n+               return;\n+\n+            --  Another case, if we are pointing to an Itype, then we want\n+            --  to copy it if its associated node is somewhere in the tree\n+            --  being copied.\n+\n+            --  Note: the exclusion of self-referential copies is just an\n+            --  optimization, since the search of the already copied list\n+            --  would catch it, but it is a common case (Etype pointing\n+            --  to itself for an Itype that is a base type).\n+\n+            elsif Has_Extension (Node_Id (F))\n+              and then Is_Itype (Entity_Id (F))\n+              and then Node_Id (F) /= N\n+            then\n+               declare\n+                  P : Node_Id;\n+\n+               begin\n+                  P := Associated_Node_For_Itype (Node_Id (F));\n+                  while Present (P) loop\n+                     if P = Source then\n+                        Visit_Node (Node_Id (F));\n+                        return;\n+                     else\n+                        P := Parent (P);\n+                     end if;\n+                  end loop;\n+\n+                  --  An Itype whose parent is not being copied definitely\n+                  --  should NOT be copied, since it does not belong in any\n+                  --  sense to the copied subtree.\n+\n+                  return;\n+               end;\n+            end if;\n+\n+         elsif F in List_Range\n+           and then Parent (List_Id (F)) = N\n+         then\n+            Visit_List (List_Id (F));\n+            return;\n+         end if;\n+      end Visit_Field;\n+\n+      -----------------\n+      -- Visit_Itype --\n+      -----------------\n+\n+      procedure Visit_Itype (Old_Itype : Entity_Id) is\n+         New_Itype : Entity_Id;\n+         E         : Elmt_Id;\n+         Ent       : Entity_Id;\n+\n+      begin\n+         --  Itypes that describe the designated type of access to subprograms\n+         --  have the structure of subprogram declarations, with signatures,\n+         --  etc. Either we duplicate the signatures completely, or choose to\n+         --  share such itypes, which is fine because their elaboration will\n+         --  have no side effects.\n+\n+         if Ekind (Old_Itype) = E_Subprogram_Type then\n+            return;\n+         end if;\n+\n+         New_Itype := New_Copy (Old_Itype);\n+\n+         --  The new Itype has all the attributes of the old one, and\n+         --  we just copy the contents of the entity. However, the back-end\n+         --  needs different names for debugging purposes, so we create a\n+         --  new internal name for it in all cases.\n+\n+         Set_Chars (New_Itype, New_Internal_Name ('T'));\n+\n+         --  If our associated node is an entity that has already been copied,\n+         --  then set the associated node of the copy to point to the right\n+         --  copy. If we have copied an Itype that is itself the associated\n+         --  node of some previously copied Itype, then we set the right\n+         --  pointer in the other direction.\n+\n+         if Present (Actual_Map) then\n+\n+            --  Case of hash tables used\n+\n+            if NCT_Hash_Tables_Used then\n+\n+               Ent := NCT_Assoc.Get (Associated_Node_For_Itype (Old_Itype));\n+\n+               if Present (Ent) then\n+                  Set_Associated_Node_For_Itype (New_Itype, Ent);\n+               end if;\n+\n+               Ent := NCT_Itype_Assoc.Get (Old_Itype);\n+               if Present (Ent) then\n+                  Set_Associated_Node_For_Itype (Ent, New_Itype);\n+\n+               --  If the hash table has no association for this Itype and\n+               --  its associated node, enter one now.\n+\n+               else\n+                  NCT_Itype_Assoc.Set\n+                    (Associated_Node_For_Itype (Old_Itype), New_Itype);\n+               end if;\n+\n+            --  Case of hash tables not used\n+\n+            else\n+               E := First_Elmt (Actual_Map);\n+               while Present (E) loop\n+                  if Associated_Node_For_Itype (Old_Itype) = Node (E) then\n+                     Set_Associated_Node_For_Itype\n+                       (New_Itype, Node (Next_Elmt (E)));\n+                  end if;\n+\n+                  if Is_Type (Node (E))\n+                    and then\n+                      Old_Itype = Associated_Node_For_Itype (Node (E))\n+                  then\n+                     Set_Associated_Node_For_Itype\n+                       (Node (Next_Elmt (E)), New_Itype);\n+                  end if;\n+\n+                  E := Next_Elmt (Next_Elmt (E));\n+               end loop;\n+            end if;\n+         end if;\n+\n+         if Present (Freeze_Node (New_Itype)) then\n+            Set_Is_Frozen (New_Itype, False);\n+            Set_Freeze_Node (New_Itype, Empty);\n+         end if;\n+\n+         --  Add new association to map\n+\n+         if No (Actual_Map) then\n+            Actual_Map := New_Elmt_List;\n+         end if;\n+\n+         Append_Elmt (Old_Itype, Actual_Map);\n+         Append_Elmt (New_Itype, Actual_Map);\n+\n+         if NCT_Hash_Tables_Used then\n+            NCT_Assoc.Set (Old_Itype, New_Itype);\n+\n+         else\n+            NCT_Table_Entries := NCT_Table_Entries + 1;\n+\n+            if NCT_Table_Entries > NCT_Hash_Threshhold then\n+               Build_NCT_Hash_Tables;\n+            end if;\n+         end if;\n+\n+         --  If a record subtype is simply copied, the entity list will be\n+         --  shared. Thus cloned_Subtype must be set to indicate the sharing.\n+\n+         if Ekind (Old_Itype) = E_Record_Subtype\n+           or else Ekind (Old_Itype) = E_Class_Wide_Subtype\n+         then\n+            Set_Cloned_Subtype (New_Itype, Old_Itype);\n+         end if;\n+\n+         --  Visit descendents that eventually get copied\n+\n+         Visit_Field (Union_Id (Etype (Old_Itype)), Old_Itype);\n+\n+         if Is_Discrete_Type (Old_Itype) then\n+            Visit_Field (Union_Id (Scalar_Range (Old_Itype)), Old_Itype);\n+\n+         elsif Has_Discriminants (Base_Type (Old_Itype)) then\n+            --  ??? This should involve call to Visit_Field\n+            Visit_Elist (Discriminant_Constraint (Old_Itype));\n+\n+         elsif Is_Array_Type (Old_Itype) then\n+            if Present (First_Index (Old_Itype)) then\n+               Visit_Field (Union_Id (List_Containing\n+                                (First_Index (Old_Itype))),\n+                            Old_Itype);\n+            end if;\n+\n+            if Is_Packed (Old_Itype) then\n+               Visit_Field (Union_Id (Packed_Array_Type (Old_Itype)),\n+                            Old_Itype);\n+            end if;\n+         end if;\n+      end Visit_Itype;\n+\n+      ----------------\n+      -- Visit_List --\n+      ----------------\n+\n+      procedure Visit_List (L : List_Id) is\n+         N : Node_Id;\n+      begin\n+         if L /= No_List then\n+            N := First (L);\n+\n+            while Present (N) loop\n+               Visit_Node (N);\n+               Next (N);\n+            end loop;\n+         end if;\n+      end Visit_List;\n+\n+      ----------------\n+      -- Visit_Node --\n+      ----------------\n+\n+      procedure Visit_Node (N : Node_Or_Entity_Id) is\n+\n+      --  Start of processing for Visit_Node\n+\n+      begin\n+         --  Handle case of an Itype, which must be copied\n+\n+         if Has_Extension (N)\n+           and then Is_Itype (N)\n+         then\n+            --  Nothing to do if already in the list. This can happen with an\n+            --  Itype entity that appears more than once in the tree.\n+            --  Note that we do not want to visit descendents in this case.\n+\n+            --  Test for already in list when hash table is used\n+\n+            if NCT_Hash_Tables_Used then\n+               if Present (NCT_Assoc.Get (Entity_Id (N))) then\n+                  return;\n+               end if;\n+\n+            --  Test for already in list when hash table not used\n+\n+            else\n+               declare\n+                  E : Elmt_Id;\n+               begin\n+                  if Present (Actual_Map) then\n+                     E := First_Elmt (Actual_Map);\n+                     while Present (E) loop\n+                        if Node (E) = N then\n+                           return;\n+                        else\n+                           E := Next_Elmt (Next_Elmt (E));\n+                        end if;\n+                     end loop;\n+                  end if;\n+               end;\n+            end if;\n+\n+            Visit_Itype (N);\n+         end if;\n+\n+         --  Visit descendents\n+\n+         Visit_Field (Field1 (N), N);\n+         Visit_Field (Field2 (N), N);\n+         Visit_Field (Field3 (N), N);\n+         Visit_Field (Field4 (N), N);\n+         Visit_Field (Field5 (N), N);\n+      end Visit_Node;\n+\n+   --  Start of processing for New_Copy_Tree\n+\n+   begin\n+      Actual_Map := Map;\n+\n+      --  See if we should use hash table\n+\n+      if No (Actual_Map) then\n+         NCT_Hash_Tables_Used := False;\n+\n+      else\n+         declare\n+            Elmt : Elmt_Id;\n+\n+         begin\n+            NCT_Table_Entries := 0;\n+\n+            Elmt := First_Elmt (Actual_Map);\n+            while Present (Elmt) loop\n+               NCT_Table_Entries := NCT_Table_Entries + 1;\n+               Next_Elmt (Elmt);\n+               Next_Elmt (Elmt);\n+            end loop;\n+\n+            if NCT_Table_Entries > NCT_Hash_Threshhold then\n+               Build_NCT_Hash_Tables;\n+            else\n+               NCT_Hash_Tables_Used := False;\n+            end if;\n+         end;\n+      end if;\n+\n+      --  Hash table set up if required, now start phase one by visiting\n+      --  top node (we will recursively visit the descendents).\n+\n+      Visit_Node (Source);\n+\n+      --  Now the second phase of the copy can start. First we process\n+      --  all the mapped entities, copying their descendents.\n+\n+      if Present (Actual_Map) then\n+         declare\n+            Elmt      : Elmt_Id;\n+            New_Itype : Entity_Id;\n+         begin\n+            Elmt := First_Elmt (Actual_Map);\n+            while Present (Elmt) loop\n+               Next_Elmt (Elmt);\n+               New_Itype := Node (Elmt);\n+               Copy_Itype_With_Replacement (New_Itype);\n+               Next_Elmt (Elmt);\n+            end loop;\n+         end;\n+      end if;\n+\n+      --  Now we can copy the actual tree\n+\n+      return Copy_Node_With_Replacement (Source);\n+   end New_Copy_Tree;\n+\n    -------------------------\n    -- New_External_Entity --\n    -------------------------"}, {"sha": "4046b785892ef446fdd8dd87e1f4d1a9d4229c0c", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b01cd988069ab653fb34488c6f0ea9bfb2bae6/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f3b01cd988069ab653fb34488c6f0ea9bfb2bae6", "patch": "@@ -876,6 +876,57 @@ package Sem_Util is\n    --  formal. Used in Ada 2005 mode to solve the syntactic ambiguity that\n    --  results from an indexing of a function call written in prefix form.\n \n+   function New_Copy_List_Tree (List : List_Id) return List_Id;\n+   --  Copy recursively an analyzed list of nodes. Uses New_Copy_Tree defined\n+   --  below. As for New_Copy_Tree, it is illegal to attempt to copy extended\n+   --  nodes (entities) either directly or indirectly using this function.\n+\n+   function New_Copy_Tree\n+     (Source    : Node_Id;\n+      Map       : Elist_Id   := No_Elist;\n+      New_Sloc  : Source_Ptr := No_Location;\n+      New_Scope : Entity_Id  := Empty) return Node_Id;\n+   --  Given a node that is the root of a subtree, Copy_Tree copies the entire\n+   --  syntactic subtree, including recursively any descendents whose parent\n+   --  field references a copied node (descendents not linked to a copied node\n+   --  by the parent field are not copied, instead the copied tree references\n+   --  the same descendent as the original in this case, which is appropriate\n+   --  for non-syntactic fields such as Etype). The parent pointers in the\n+   --  copy are properly set. Copy_Tree (Empty/Error) returns Empty/Error.\n+   --  The one exception to the rule of not copying semantic fields is that\n+   --  any implicit types attached to the subtree are duplicated, so that\n+   --  the copy contains a distinct set of implicit type entities. Thus this\n+   --  function is used when it is necessary to duplicate an analyzed tree,\n+   --  declared in the same or some other compilation unit. This function is\n+   --  declared here rather than in atree because it uses semantic information\n+   --  in particular concerning the structure of itypes and the generation of\n+   --  public symbols.\n+\n+   --  The Map argument, if set to a non-empty Elist, specifies a set of\n+   --  mappings to be applied to entities in the tree. The map has the form:\n+   --\n+   --     old entity 1\n+   --     new entity to replace references to entity 1\n+   --     old entity 2\n+   --     new entity to replace references to entity 2\n+   --     ...\n+   --\n+   --  The call destroys the contents of Map in this case\n+   --\n+   --  The parameter New_Sloc, if set to a value other than No_Location, is\n+   --  used as the Sloc value for all nodes in the new copy. If New_Sloc is\n+   --  set to its default value No_Location, then the Sloc values of the\n+   --  nodes in the copy are simply copied from the corresponding original.\n+   --\n+   --  The Comes_From_Source indication is unchanged if New_Sloc is set to\n+   --  the default No_Location value, but is reset if New_Sloc is given, since\n+   --  in this case the result clearly is neither a source node or an exact\n+   --  copy of a source node.\n+   --\n+   --  The parameter New_Scope, if set to a value other than Empty, is the\n+   --  value to use as the Scope for any Itypes that are copied. The most\n+   --  typical value for this parameter, if given, is Current_Scope.\n+\n    function New_External_Entity\n      (Kind         : Entity_Kind;\n       Scope_Id     : Entity_Id;"}]}