{"sha": "92d28cbb59cc5a611af41342c5b224fbf779a44d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJkMjhjYmI1OWNjNWE2MTFhZjQxMzQyYzViMjI0ZmJmNzc5YTQ0ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-06-10T06:05:22Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-06-10T06:05:22Z"}, "message": "re PR fortran/60928 (gfortran issue with allocatable components and OpenMP)\n\n\tPR fortran/60928\n\t* omp-low.c (lower_rec_input_clauses) <case OMP_CLAUSE_LASTPRIVATE>:\n\tSet lastprivate_firstprivate even if omp_private_outer_ref\n\tlanghook returns true.\n\t<case OMP_CLAUSE_REDUCTION>: When calling omp_clause_default_ctor\n\tlanghook, call unshare_expr on new_var and call\n\tbuild_outer_var_ref to get the last argument.\ngcc/c-family/\n\t* c-pragma.c (omp_pragmas_simd): Move PRAGMA_OMP_TASK...\n\t(omp_pragmas): ... back here.\ngcc/fortran/\n\t* f95-lang.c (gfc_init_builtin_functions): Handle -fopenmp-simd\n\tlike -fopenmp.\n\t* openmp.c (resolve_omp_clauses): Remove allocatable components\n\tdiagnostics.  Add associate-name and intent(in) pointer\n\tdiagnostics for various clauses, diagnose procedure pointers in\n\treduction clause.\n\t* parse.c (match_word_omp_simd): New function.\n\t(matchs, matcho): New macros.\n\t(decode_omp_directive): Change match macros to either matchs\n\tor matcho.  Handle -fopenmp-simd.\n\t(next_free, next_fixed): Handle -fopenmp-simd like -fopenmp.\n\t* scanner.c (skip_free_comments, skip_fixed_comments, include_line):\n\tLikewise.\n\t* trans-array.c (get_full_array_size): Rename to...\n\t(gfc_full_array_size): ... this.  No longer static.\n\t(duplicate_allocatable): Adjust caller.  Add NO_MEMCPY argument\n\tand handle it.\n\t(gfc_duplicate_allocatable, gfc_copy_allocatable_data): Adjust\n\tduplicate_allocatable callers.\n\t(gfc_duplicate_allocatable_nocopy): New function.\n\t(structure_alloc_comps): Adjust g*_full_array_size and\n\tduplicate_allocatable caller.\n\t* trans-array.h (gfc_full_array_size,\n\tgfc_duplicate_allocatable_nocopy): New prototypes.\n\t* trans-common.c (create_common): Call gfc_finish_decl_attrs.\n\t* trans-decl.c (gfc_finish_decl_attrs): New function.\n\t(gfc_finish_var_decl, create_function_arglist,\n\tgfc_get_fake_result_decl): Call it.\n\t(gfc_allocate_lang_decl): If DECL_LANG_SPECIFIC is already allocated,\n\tdon't allocate it again.\n\t(gfc_get_symbol_decl): Set GFC_DECL_ASSOCIATE_VAR_P on\n\tassociate-names.\n\t* trans.h (gfc_finish_decl_attrs): New prototype.\n\t(struct lang_decl): Add scalar_allocatable and scalar_pointer\n\tbitfields.\n\t(GFC_DECL_SCALAR_ALLOCATABLE, GFC_DECL_SCALAR_POINTER,\n\tGFC_DECL_GET_SCALAR_ALLOCATABLE, GFC_DECL_GET_SCALAR_POINTER,\n\tGFC_DECL_ASSOCIATE_VAR_P): Define.\n\t(GFC_POINTER_TYPE_P): Remove.\n\t* trans-openmp.c (gfc_omp_privatize_by_reference): Don't check\n\tGFC_POINTER_TYPE_P, instead test GFC_DECL_GET_SCALAR_ALLOCATABLE,\n\tGFC_DECL_GET_SCALAR_POINTER or GFC_DECL_CRAY_POINTEE on decl.\n\t(gfc_omp_predetermined_sharing): Associate-names are predetermined.\n\t(enum walk_alloc_comps): New.\n\t(gfc_has_alloc_comps, gfc_omp_unshare_expr_r, gfc_omp_unshare_expr,\n\tgfc_walk_alloc_comps): New functions.\n\t(gfc_omp_private_outer_ref): Return true for scalar allocatables or\n\tdecls with allocatable components.\n\t(gfc_omp_clause_default_ctor, gfc_omp_clause_copy_ctor,\n\tgfc_omp_clause_assign_op, gfc_omp_clause_dtor): Fix up handling of\n\tallocatables, handle also OMP_CLAUSE_REDUCTION, handle scalar\n\tallocatables and decls with allocatable components.\n\t(gfc_trans_omp_array_reduction_or_udr): Don't handle allocatable\n\tarrays here.\n\t(gfc_trans_omp_reduction_list): Call\n\tgfc_trans_omp_array_reduction_or_udr even for allocatable scalars.\n\t(gfc_trans_omp_do_simd): If -fno-openmp, just expand it as OMP_SIMD.\n\t(gfc_trans_omp_parallel_do_simd): Likewise.\n\t* trans-types.c (gfc_sym_type): Don't set GFC_POINTER_TYPE_P.\n\t(gfc_get_derived_type): Call gfc_finish_decl_attrs.\ngcc/testsuite/\n\t* gfortran.dg/gomp/allocatable_components_1.f90: Remove dg-error\n\tdirectives.\n\t* gfortran.dg/gomp/associate1.f90: New test.\n\t* gfortran.dg/gomp/intentin1.f90: New test.\n\t* gfortran.dg/gomp/openmp-simd-1.f90: New test.\n\t* gfortran.dg/gomp/openmp-simd-2.f90: New test.\n\t* gfortran.dg/gomp/openmp-simd-3.f90: New test.\n\t* gfortran.dg/gomp/proc_ptr_2.f90: New test.\nlibgomp/\n\t* testsuite/libgomp.fortran/allocatable9.f90: New test.\n\t* testsuite/libgomp.fortran/allocatable10.f90: New test.\n\t* testsuite/libgomp.fortran/allocatable11.f90: New test.\n\t* testsuite/libgomp.fortran/allocatable12.f90: New test.\n\t* testsuite/libgomp.fortran/alloc-comp-1.f90: New test.\n\t* testsuite/libgomp.fortran/alloc-comp-2.f90: New test.\n\t* testsuite/libgomp.fortran/alloc-comp-3.f90: New test.\n\t* testsuite/libgomp.fortran/associate1.f90: New test.\n\t* testsuite/libgomp.fortran/associate2.f90: New test.\n\t* testsuite/libgomp.fortran/procptr1.f90: New test.\n\nFrom-SVN: r211397", "tree": {"sha": "d0ec7ff75f32129f09cb9bd294a6cdde28a88977", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0ec7ff75f32129f09cb9bd294a6cdde28a88977"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92d28cbb59cc5a611af41342c5b224fbf779a44d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d28cbb59cc5a611af41342c5b224fbf779a44d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92d28cbb59cc5a611af41342c5b224fbf779a44d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d28cbb59cc5a611af41342c5b224fbf779a44d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c9f2b7e90ab7580521fa91274551784f6d4815f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f2b7e90ab7580521fa91274551784f6d4815f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9f2b7e90ab7580521fa91274551784f6d4815f5"}], "stats": {"total": 3223, "additions": 2932, "deletions": 291}, "files": [{"sha": "e277f229b1304d44ac4293ab2f80f2bc546534fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -1,3 +1,13 @@\n+2014-06-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/60928\n+\t* omp-low.c (lower_rec_input_clauses) <case OMP_CLAUSE_LASTPRIVATE>:\n+\tSet lastprivate_firstprivate even if omp_private_outer_ref\n+\tlanghook returns true.\n+\t<case OMP_CLAUSE_REDUCTION>: When calling omp_clause_default_ctor\n+\tlanghook, call unshare_expr on new_var and call\n+\tbuild_outer_var_ref to get the last argument.\n+\n 2014-06-10  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/60988"}, {"sha": "b976f21988dfaab3a3dff01fb8d536a5f85d81f7", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -1,3 +1,9 @@\n+2014-06-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/60928\n+\t* c-pragma.c (omp_pragmas_simd): Move PRAGMA_OMP_TASK...\n+\t(omp_pragmas): ... back here.\n+\n 2014-06-05  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/49706"}, {"sha": "5e57de39b137e0d9e599d31a6a976f9a7cb8f99a", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -1185,6 +1185,7 @@ static const struct omp_pragma_def omp_pragmas[] = {\n   { \"section\", PRAGMA_OMP_SECTION },\n   { \"sections\", PRAGMA_OMP_SECTIONS },\n   { \"single\", PRAGMA_OMP_SINGLE },\n+  { \"task\", PRAGMA_OMP_TASK },\n   { \"taskgroup\", PRAGMA_OMP_TASKGROUP },\n   { \"taskwait\", PRAGMA_OMP_TASKWAIT },\n   { \"taskyield\", PRAGMA_OMP_TASKYIELD },\n@@ -1197,7 +1198,6 @@ static const struct omp_pragma_def omp_pragmas_simd[] = {\n   { \"parallel\", PRAGMA_OMP_PARALLEL },\n   { \"simd\", PRAGMA_OMP_SIMD },\n   { \"target\", PRAGMA_OMP_TARGET },\n-  { \"task\", PRAGMA_OMP_TASK },\n   { \"teams\", PRAGMA_OMP_TEAMS },\n };\n "}, {"sha": "f945dd1c2f6e0dc2835314f6e39a30f02468fe57", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -1,3 +1,67 @@\n+2014-06-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/60928\n+\t* f95-lang.c (gfc_init_builtin_functions): Handle -fopenmp-simd\n+\tlike -fopenmp.\n+\t* openmp.c (resolve_omp_clauses): Remove allocatable components\n+\tdiagnostics.  Add associate-name and intent(in) pointer\n+\tdiagnostics for various clauses, diagnose procedure pointers in\n+\treduction clause.\n+\t* parse.c (match_word_omp_simd): New function.\n+\t(matchs, matcho): New macros.\n+\t(decode_omp_directive): Change match macros to either matchs\n+\tor matcho.  Handle -fopenmp-simd.\n+\t(next_free, next_fixed): Handle -fopenmp-simd like -fopenmp.\n+\t* scanner.c (skip_free_comments, skip_fixed_comments, include_line):\n+\tLikewise.\n+\t* trans-array.c (get_full_array_size): Rename to...\n+\t(gfc_full_array_size): ... this.  No longer static.\n+\t(duplicate_allocatable): Adjust caller.  Add NO_MEMCPY argument\n+\tand handle it.\n+\t(gfc_duplicate_allocatable, gfc_copy_allocatable_data): Adjust\n+\tduplicate_allocatable callers.\n+\t(gfc_duplicate_allocatable_nocopy): New function.\n+\t(structure_alloc_comps): Adjust g*_full_array_size and\n+\tduplicate_allocatable caller.\n+\t* trans-array.h (gfc_full_array_size,\n+\tgfc_duplicate_allocatable_nocopy): New prototypes.\n+\t* trans-common.c (create_common): Call gfc_finish_decl_attrs.\n+\t* trans-decl.c (gfc_finish_decl_attrs): New function.\n+\t(gfc_finish_var_decl, create_function_arglist,\n+\tgfc_get_fake_result_decl): Call it.\n+\t(gfc_allocate_lang_decl): If DECL_LANG_SPECIFIC is already allocated,\n+\tdon't allocate it again.\n+\t(gfc_get_symbol_decl): Set GFC_DECL_ASSOCIATE_VAR_P on\n+\tassociate-names.\n+\t* trans.h (gfc_finish_decl_attrs): New prototype.\n+\t(struct lang_decl): Add scalar_allocatable and scalar_pointer\n+\tbitfields.\n+\t(GFC_DECL_SCALAR_ALLOCATABLE, GFC_DECL_SCALAR_POINTER,\n+\tGFC_DECL_GET_SCALAR_ALLOCATABLE, GFC_DECL_GET_SCALAR_POINTER,\n+\tGFC_DECL_ASSOCIATE_VAR_P): Define.\n+\t(GFC_POINTER_TYPE_P): Remove.\n+\t* trans-openmp.c (gfc_omp_privatize_by_reference): Don't check\n+\tGFC_POINTER_TYPE_P, instead test GFC_DECL_GET_SCALAR_ALLOCATABLE,\n+\tGFC_DECL_GET_SCALAR_POINTER or GFC_DECL_CRAY_POINTEE on decl.\n+\t(gfc_omp_predetermined_sharing): Associate-names are predetermined.\n+\t(enum walk_alloc_comps): New.\n+\t(gfc_has_alloc_comps, gfc_omp_unshare_expr_r, gfc_omp_unshare_expr,\n+\tgfc_walk_alloc_comps): New functions.\n+\t(gfc_omp_private_outer_ref): Return true for scalar allocatables or\n+\tdecls with allocatable components.\n+\t(gfc_omp_clause_default_ctor, gfc_omp_clause_copy_ctor,\n+\tgfc_omp_clause_assign_op, gfc_omp_clause_dtor): Fix up handling of\n+\tallocatables, handle also OMP_CLAUSE_REDUCTION, handle scalar\n+\tallocatables and decls with allocatable components.\n+\t(gfc_trans_omp_array_reduction_or_udr): Don't handle allocatable\n+\tarrays here.\n+\t(gfc_trans_omp_reduction_list): Call\n+\tgfc_trans_omp_array_reduction_or_udr even for allocatable scalars.\n+\t(gfc_trans_omp_do_simd): If -fno-openmp, just expand it as OMP_SIMD.\n+\t(gfc_trans_omp_parallel_do_simd): Likewise.\n+\t* trans-types.c (gfc_sym_type): Don't set GFC_POINTER_TYPE_P.\n+\t(gfc_get_derived_type): Call gfc_finish_decl_attrs.\n+\n 2014-06-09  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/61406"}, {"sha": "196214497679e3b4ffe0915b0384739c72ed07dd", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -1044,7 +1044,9 @@ gfc_init_builtin_functions (void)\n #include \"../sync-builtins.def\"\n #undef DEF_SYNC_BUILTIN\n \n-  if (gfc_option.gfc_flag_openmp || flag_tree_parallelize_loops)\n+  if (gfc_option.gfc_flag_openmp\n+      || gfc_option.gfc_flag_openmp_simd\n+      || flag_tree_parallelize_loops)\n     {\n #undef DEF_GOMP_BUILTIN\n #define DEF_GOMP_BUILTIN(code, name, type, attr) \\"}, {"sha": "a6e5f6c2cf88ae6f5ef2f796afa8b290c04ec931", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -1763,9 +1763,6 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\tif (!n->sym->attr.threadprivate)\n \t\t  gfc_error (\"Non-THREADPRIVATE object '%s' in COPYIN clause\"\n \t\t\t     \" at %L\", n->sym->name, where);\n-\t\tif (n->sym->ts.type == BT_DERIVED && n->sym->ts.u.derived->attr.alloc_comp)\n-\t\t  gfc_error (\"COPYIN clause object '%s' at %L has ALLOCATABLE components\",\n-\t\t\t     n->sym->name, where);\n \t      }\n \t    break;\n \t  case OMP_LIST_COPYPRIVATE:\n@@ -1774,9 +1771,9 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\tif (n->sym->as && n->sym->as->type == AS_ASSUMED_SIZE)\n \t\t  gfc_error (\"Assumed size array '%s' in COPYPRIVATE clause \"\n \t\t\t     \"at %L\", n->sym->name, where);\n-\t\tif (n->sym->ts.type == BT_DERIVED && n->sym->ts.u.derived->attr.alloc_comp)\n-\t\t  gfc_error (\"COPYPRIVATE clause object '%s' at %L has ALLOCATABLE components\",\n-\t\t\t     n->sym->name, where);\n+\t\tif (n->sym->attr.pointer && n->sym->attr.intent == INTENT_IN)\n+\t\t  gfc_error (\"INTENT(IN) POINTER '%s' in COPYPRIVATE clause \"\n+\t\t\t     \"at %L\", n->sym->name, where);\n \t      }\n \t    break;\n \t  case OMP_LIST_SHARED:\n@@ -1788,6 +1785,9 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\tif (n->sym->attr.cray_pointee)\n \t\t  gfc_error (\"Cray pointee '%s' in SHARED clause at %L\",\n \t\t\t    n->sym->name, where);\n+\t\tif (n->sym->attr.associate_var)\n+\t\t  gfc_error (\"ASSOCIATE name '%s' in SHARED clause at %L\",\n+\t\t\t     n->sym->name, where);\n \t      }\n \t    break;\n \t  case OMP_LIST_ALIGNED:\n@@ -1879,17 +1879,17 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\tif (n->sym->attr.cray_pointee)\n \t\t  gfc_error (\"Cray pointee '%s' in %s clause at %L\",\n \t\t\t    n->sym->name, name, where);\n+\t\tif (n->sym->attr.associate_var)\n+\t\t  gfc_error (\"ASSOCIATE name '%s' in %s clause at %L\",\n+\t\t\t     n->sym->name, name, where);\n \t\tif (list != OMP_LIST_PRIVATE)\n \t\t  {\n+\t\t    if (n->sym->attr.proc_pointer && list == OMP_LIST_REDUCTION)\n+\t\t      gfc_error (\"Procedure pointer '%s' in %s clause at %L\",\n+\t\t\t\t n->sym->name, name, where);\n \t\t    if (n->sym->attr.pointer && list == OMP_LIST_REDUCTION)\n \t\t      gfc_error (\"POINTER object '%s' in %s clause at %L\",\n \t\t\t\t n->sym->name, name, where);\n-\t\t    /* Variables in REDUCTION-clauses must be of intrinsic type (flagged below).  */\n-\t\t    if (list != OMP_LIST_REDUCTION\n-\t\t\t && n->sym->ts.type == BT_DERIVED\n-\t\t\t && n->sym->ts.u.derived->attr.alloc_comp)\n-\t\t      gfc_error (\"%s clause object '%s' has ALLOCATABLE components at %L\",\n-\t\t\t\t name, n->sym->name, where);\n \t\t    if (n->sym->attr.cray_pointer && list == OMP_LIST_REDUCTION)\n \t\t      gfc_error (\"Cray pointer '%s' in %s clause at %L\",\n \t\t\t\t n->sym->name, name, where);\n@@ -1901,6 +1901,19 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t  gfc_error (\"Variable '%s' in %s clause is used in \"\n \t\t\t     \"NAMELIST statement at %L\",\n \t\t\t     n->sym->name, name, where);\n+\t\tif (n->sym->attr.pointer && n->sym->attr.intent == INTENT_IN)\n+\t\t  switch (list)\n+\t\t    {\n+\t\t    case OMP_LIST_PRIVATE:\n+\t\t    case OMP_LIST_LASTPRIVATE:\n+\t\t    case OMP_LIST_LINEAR:\n+\t\t    /* case OMP_LIST_REDUCTION: */\n+\t\t      gfc_error (\"INTENT(IN) POINTER '%s' in %s clause at %L\",\n+\t\t\t\t n->sym->name, name, where);\n+\t\t      break;\n+\t\t    default:\n+\t\t      break;\n+\t\t    }\n \t\tswitch (list)\n \t\t  {\n \t\t  case OMP_LIST_REDUCTION:"}, {"sha": "bdee831ae4d0ebf609733ffb39d67c36eb1901b4", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 124, "deletions": 61, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -74,6 +74,34 @@ match_word (const char *str, match (*subr) (void), locus *old_locus)\n }\n \n \n+/* Like match_word, but if str is matched, set a flag that it\n+   was matched.  */\n+static match\n+match_word_omp_simd (const char *str, match (*subr) (void), locus *old_locus,\n+\t\t     bool *simd_matched)\n+{\n+  match m;\n+\n+  if (str != NULL)\n+    {\n+      m = gfc_match (str);\n+      if (m != MATCH_YES)\n+\treturn m;\n+      *simd_matched = true;\n+    }\n+\n+  m = (*subr) ();\n+\n+  if (m != MATCH_YES)\n+    {\n+      gfc_current_locus = *old_locus;\n+      reject_statement ();\n+    }\n+\n+  return m;\n+}\n+\n+\n /* Load symbols from all USE statements encountered in this scoping unit.  */\n \n static void\n@@ -103,7 +131,7 @@ use_modules (void)\n       if (match_word (keyword, subr, &old_locus) == MATCH_YES)\t\\\n \treturn st;\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n-\tundo_new_statement ();\t\t\t\t  \\\n+\tundo_new_statement ();\t\t\t\t  \t\\\n     } while (0);\n \n \n@@ -531,11 +559,34 @@ decode_statement (void)\n   return ST_NONE;\n }\n \n+/* Like match, but set a flag simd_matched if keyword matched.  */\n+#define matchs(keyword, subr, st)\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\\\n+      if (match_word_omp_simd (keyword, subr, &old_locus,\t\\\n+\t\t\t       &simd_matched) == MATCH_YES)\t\\\n+\treturn st;\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tundo_new_statement ();\t\t\t\t  \t\\\n+    } while (0);\n+\n+/* Like match, but don't match anything if not -fopenmp.  */\n+#define matcho(keyword, subr, st)\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\\\n+      if (!gfc_option.gfc_flag_openmp)\t\t\t\t\\\n+\t;\t\t\t\t\t\t\t\\\n+      else if (match_word (keyword, subr, &old_locus)\t\t\\\n+\t       == MATCH_YES)\t\t\t\t\t\\\n+\treturn st;\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tundo_new_statement ();\t\t\t\t  \t\\\n+    } while (0);\n+\n static gfc_statement\n decode_omp_directive (void)\n {\n   locus old_locus;\n   char c;\n+  bool simd_matched = false;\n \n   gfc_enforce_clean_symbol_state ();\n \n@@ -560,94 +611,102 @@ decode_omp_directive (void)\n \n   c = gfc_peek_ascii_char ();\n \n+  /* match is for directives that should be recognized only if\n+     -fopenmp, matchs for directives that should be recognized\n+     if either -fopenmp or -fopenmp-simd.  */\n   switch (c)\n     {\n     case 'a':\n-      match (\"atomic\", gfc_match_omp_atomic, ST_OMP_ATOMIC);\n+      matcho (\"atomic\", gfc_match_omp_atomic, ST_OMP_ATOMIC);\n       break;\n     case 'b':\n-      match (\"barrier\", gfc_match_omp_barrier, ST_OMP_BARRIER);\n+      matcho (\"barrier\", gfc_match_omp_barrier, ST_OMP_BARRIER);\n       break;\n     case 'c':\n-      match (\"cancellation% point\", gfc_match_omp_cancellation_point,\n-\t     ST_OMP_CANCELLATION_POINT);\n-      match (\"cancel\", gfc_match_omp_cancel, ST_OMP_CANCEL);\n-      match (\"critical\", gfc_match_omp_critical, ST_OMP_CRITICAL);\n+      matcho (\"cancellation% point\", gfc_match_omp_cancellation_point,\n+\t      ST_OMP_CANCELLATION_POINT);\n+      matcho (\"cancel\", gfc_match_omp_cancel, ST_OMP_CANCEL);\n+      matcho (\"critical\", gfc_match_omp_critical, ST_OMP_CRITICAL);\n       break;\n     case 'd':\n-      match (\"declare reduction\", gfc_match_omp_declare_reduction,\n-\t     ST_OMP_DECLARE_REDUCTION);\n-      match (\"declare simd\", gfc_match_omp_declare_simd,\n-\t     ST_OMP_DECLARE_SIMD);\n-      match (\"do simd\", gfc_match_omp_do_simd, ST_OMP_DO_SIMD);\n-      match (\"do\", gfc_match_omp_do, ST_OMP_DO);\n+      matchs (\"declare reduction\", gfc_match_omp_declare_reduction,\n+\t      ST_OMP_DECLARE_REDUCTION);\n+      matchs (\"declare simd\", gfc_match_omp_declare_simd,\n+\t      ST_OMP_DECLARE_SIMD);\n+      matchs (\"do simd\", gfc_match_omp_do_simd, ST_OMP_DO_SIMD);\n+      matcho (\"do\", gfc_match_omp_do, ST_OMP_DO);\n       break;\n     case 'e':\n-      match (\"end atomic\", gfc_match_omp_eos, ST_OMP_END_ATOMIC);\n-      match (\"end critical\", gfc_match_omp_critical, ST_OMP_END_CRITICAL);\n-      match (\"end do simd\", gfc_match_omp_end_nowait, ST_OMP_END_DO_SIMD);\n-      match (\"end do\", gfc_match_omp_end_nowait, ST_OMP_END_DO);\n-      match (\"end simd\", gfc_match_omp_eos, ST_OMP_END_SIMD);\n-      match (\"end master\", gfc_match_omp_eos, ST_OMP_END_MASTER);\n-      match (\"end ordered\", gfc_match_omp_eos, ST_OMP_END_ORDERED);\n-      match (\"end parallel do simd\", gfc_match_omp_eos,\n-\t     ST_OMP_END_PARALLEL_DO_SIMD);\n-      match (\"end parallel do\", gfc_match_omp_eos, ST_OMP_END_PARALLEL_DO);\n-      match (\"end parallel sections\", gfc_match_omp_eos,\n-\t     ST_OMP_END_PARALLEL_SECTIONS);\n-      match (\"end parallel workshare\", gfc_match_omp_eos,\n-\t     ST_OMP_END_PARALLEL_WORKSHARE);\n-      match (\"end parallel\", gfc_match_omp_eos, ST_OMP_END_PARALLEL);\n-      match (\"end sections\", gfc_match_omp_end_nowait, ST_OMP_END_SECTIONS);\n-      match (\"end single\", gfc_match_omp_end_single, ST_OMP_END_SINGLE);\n-      match (\"end taskgroup\", gfc_match_omp_eos, ST_OMP_END_TASKGROUP);\n-      match (\"end task\", gfc_match_omp_eos, ST_OMP_END_TASK);\n-      match (\"end workshare\", gfc_match_omp_end_nowait,\n-\t     ST_OMP_END_WORKSHARE);\n+      matcho (\"end atomic\", gfc_match_omp_eos, ST_OMP_END_ATOMIC);\n+      matcho (\"end critical\", gfc_match_omp_critical, ST_OMP_END_CRITICAL);\n+      matchs (\"end do simd\", gfc_match_omp_end_nowait, ST_OMP_END_DO_SIMD);\n+      matcho (\"end do\", gfc_match_omp_end_nowait, ST_OMP_END_DO);\n+      matchs (\"end simd\", gfc_match_omp_eos, ST_OMP_END_SIMD);\n+      matcho (\"end master\", gfc_match_omp_eos, ST_OMP_END_MASTER);\n+      matcho (\"end ordered\", gfc_match_omp_eos, ST_OMP_END_ORDERED);\n+      matchs (\"end parallel do simd\", gfc_match_omp_eos,\n+\t      ST_OMP_END_PARALLEL_DO_SIMD);\n+      matcho (\"end parallel do\", gfc_match_omp_eos, ST_OMP_END_PARALLEL_DO);\n+      matcho (\"end parallel sections\", gfc_match_omp_eos,\n+\t      ST_OMP_END_PARALLEL_SECTIONS);\n+      matcho (\"end parallel workshare\", gfc_match_omp_eos,\n+\t      ST_OMP_END_PARALLEL_WORKSHARE);\n+      matcho (\"end parallel\", gfc_match_omp_eos, ST_OMP_END_PARALLEL);\n+      matcho (\"end sections\", gfc_match_omp_end_nowait, ST_OMP_END_SECTIONS);\n+      matcho (\"end single\", gfc_match_omp_end_single, ST_OMP_END_SINGLE);\n+      matcho (\"end taskgroup\", gfc_match_omp_eos, ST_OMP_END_TASKGROUP);\n+      matcho (\"end task\", gfc_match_omp_eos, ST_OMP_END_TASK);\n+      matcho (\"end workshare\", gfc_match_omp_end_nowait,\n+\t      ST_OMP_END_WORKSHARE);\n       break;\n     case 'f':\n-      match (\"flush\", gfc_match_omp_flush, ST_OMP_FLUSH);\n+      matcho (\"flush\", gfc_match_omp_flush, ST_OMP_FLUSH);\n       break;\n     case 'm':\n-      match (\"master\", gfc_match_omp_master, ST_OMP_MASTER);\n+      matcho (\"master\", gfc_match_omp_master, ST_OMP_MASTER);\n       break;\n     case 'o':\n-      match (\"ordered\", gfc_match_omp_ordered, ST_OMP_ORDERED);\n+      matcho (\"ordered\", gfc_match_omp_ordered, ST_OMP_ORDERED);\n       break;\n     case 'p':\n-      match (\"parallel do simd\", gfc_match_omp_parallel_do_simd,\n-\t     ST_OMP_PARALLEL_DO_SIMD);\n-      match (\"parallel do\", gfc_match_omp_parallel_do, ST_OMP_PARALLEL_DO);\n-      match (\"parallel sections\", gfc_match_omp_parallel_sections,\n-\t     ST_OMP_PARALLEL_SECTIONS);\n-      match (\"parallel workshare\", gfc_match_omp_parallel_workshare,\n-\t     ST_OMP_PARALLEL_WORKSHARE);\n-      match (\"parallel\", gfc_match_omp_parallel, ST_OMP_PARALLEL);\n+      matchs (\"parallel do simd\", gfc_match_omp_parallel_do_simd,\n+\t      ST_OMP_PARALLEL_DO_SIMD);\n+      matcho (\"parallel do\", gfc_match_omp_parallel_do, ST_OMP_PARALLEL_DO);\n+      matcho (\"parallel sections\", gfc_match_omp_parallel_sections,\n+\t      ST_OMP_PARALLEL_SECTIONS);\n+      matcho (\"parallel workshare\", gfc_match_omp_parallel_workshare,\n+\t      ST_OMP_PARALLEL_WORKSHARE);\n+      matcho (\"parallel\", gfc_match_omp_parallel, ST_OMP_PARALLEL);\n       break;\n     case 's':\n-      match (\"sections\", gfc_match_omp_sections, ST_OMP_SECTIONS);\n-      match (\"section\", gfc_match_omp_eos, ST_OMP_SECTION);\n-      match (\"simd\", gfc_match_omp_simd, ST_OMP_SIMD);\n-      match (\"single\", gfc_match_omp_single, ST_OMP_SINGLE);\n+      matcho (\"sections\", gfc_match_omp_sections, ST_OMP_SECTIONS);\n+      matcho (\"section\", gfc_match_omp_eos, ST_OMP_SECTION);\n+      matchs (\"simd\", gfc_match_omp_simd, ST_OMP_SIMD);\n+      matcho (\"single\", gfc_match_omp_single, ST_OMP_SINGLE);\n       break;\n     case 't':\n-      match (\"taskgroup\", gfc_match_omp_taskgroup, ST_OMP_TASKGROUP);\n-      match (\"taskwait\", gfc_match_omp_taskwait, ST_OMP_TASKWAIT);\n-      match (\"taskyield\", gfc_match_omp_taskyield, ST_OMP_TASKYIELD);\n-      match (\"task\", gfc_match_omp_task, ST_OMP_TASK);\n-      match (\"threadprivate\", gfc_match_omp_threadprivate,\n-\t     ST_OMP_THREADPRIVATE);\n+      matcho (\"taskgroup\", gfc_match_omp_taskgroup, ST_OMP_TASKGROUP);\n+      matcho (\"taskwait\", gfc_match_omp_taskwait, ST_OMP_TASKWAIT);\n+      matcho (\"taskyield\", gfc_match_omp_taskyield, ST_OMP_TASKYIELD);\n+      matcho (\"task\", gfc_match_omp_task, ST_OMP_TASK);\n+      matcho (\"threadprivate\", gfc_match_omp_threadprivate,\n+\t      ST_OMP_THREADPRIVATE);\n       break;\n     case 'w':\n-      match (\"workshare\", gfc_match_omp_workshare, ST_OMP_WORKSHARE);\n+      matcho (\"workshare\", gfc_match_omp_workshare, ST_OMP_WORKSHARE);\n       break;\n     }\n \n   /* All else has failed, so give up.  See if any of the matchers has\n-     stored an error message of some sort.  */\n+     stored an error message of some sort.  Don't error out if\n+     not -fopenmp and simd_matched is false, i.e. if a directive other\n+     than one marked with match has been seen.  */\n \n-  if (gfc_error_check () == 0)\n-    gfc_error_now (\"Unclassifiable OpenMP directive at %C\");\n+  if (gfc_option.gfc_flag_openmp || simd_matched)\n+    {\n+      if (gfc_error_check () == 0)\n+\tgfc_error_now (\"Unclassifiable OpenMP directive at %C\");\n+    }\n \n   reject_statement ();\n \n@@ -770,7 +829,9 @@ next_free (void)\n \t  return decode_gcc_attribute ();\n \n \t}\n-      else if (c == '$' && gfc_option.gfc_flag_openmp)\n+      else if (c == '$'\n+\t       && (gfc_option.gfc_flag_openmp\n+\t\t   || gfc_option.gfc_flag_openmp_simd))\n \t{\n \t  int i;\n \n@@ -859,7 +920,9 @@ next_fixed (void)\n \n \t      return decode_gcc_attribute ();\n \t    }\n-\t  else if (c == '$' && gfc_option.gfc_flag_openmp)\n+\t  else if (c == '$'\n+\t\t   && (gfc_option.gfc_flag_openmp\n+\t\t       || gfc_option.gfc_flag_openmp_simd))\n \t    {\n \t      for (i = 0; i < 4; i++, c = gfc_next_char_literal (NONSTRING))\n \t\tgcc_assert ((char) gfc_wide_tolower (c) == \"$omp\"[i]);"}, {"sha": "8934924d876e075d81ab4f41bd20362123ce9f22", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -752,7 +752,8 @@ skip_free_comments (void)\n \t     2) handle OpenMP conditional compilation, where\n \t\t!$ should be treated as 2 spaces (for initial lines\n \t\tonly if followed by space).  */\n-\t  if (gfc_option.gfc_flag_openmp && at_bol)\n+\t  if ((gfc_option.gfc_flag_openmp\n+\t       || gfc_option.gfc_flag_openmp_simd) && at_bol)\n \t    {\n \t      locus old_loc = gfc_current_locus;\n \t      if (next_char () == '$')\n@@ -878,7 +879,7 @@ skip_fixed_comments (void)\n \t      && continue_line < gfc_linebuf_linenum (gfc_current_locus.lb))\n \t    continue_line = gfc_linebuf_linenum (gfc_current_locus.lb);\n \n-\t  if (gfc_option.gfc_flag_openmp)\n+\t  if (gfc_option.gfc_flag_openmp || gfc_option.gfc_flag_openmp_simd)\n \t    {\n \t      if (next_char () == '$')\n \t\t{\n@@ -1821,7 +1822,7 @@ include_line (gfc_char_t *line)\n \n   c = line;\n \n-  if (gfc_option.gfc_flag_openmp)\n+  if (gfc_option.gfc_flag_openmp || gfc_option.gfc_flag_openmp_simd)\n     {\n       if (gfc_current_form == FORM_FREE)\n \t{"}, {"sha": "5558217ab48b88bd1187c9154731e767fce2e6c0", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -7381,8 +7381,8 @@ gfc_trans_dealloc_allocated (tree descriptor, bool coarray, gfc_expr *expr)\n \n /* This helper function calculates the size in words of a full array.  */\n \n-static tree\n-get_full_array_size (stmtblock_t *block, tree decl, int rank)\n+tree\n+gfc_full_array_size (stmtblock_t *block, tree decl, int rank)\n {\n   tree idx;\n   tree nelems;\n@@ -7408,7 +7408,7 @@ get_full_array_size (stmtblock_t *block, tree decl, int rank)\n \n static tree\n duplicate_allocatable (tree dest, tree src, tree type, int rank,\n-\t\t       bool no_malloc, tree str_sz)\n+\t\t       bool no_malloc, bool no_memcpy, tree str_sz)\n {\n   tree tmp;\n   tree size;\n@@ -7442,9 +7442,13 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n \n-      tmp = builtin_decl_explicit (BUILT_IN_MEMCPY);\n-      tmp = build_call_expr_loc (input_location, tmp, 3, dest, src,\n-\t\t\t\t fold_convert (size_type_node, size));\n+      if (!no_memcpy)\n+\t{\n+\t  tmp = builtin_decl_explicit (BUILT_IN_MEMCPY);\n+\t  tmp = build_call_expr_loc (input_location, tmp, 3, dest, src,\n+\t\t\t\t     fold_convert (size_type_node, size));\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n     }\n   else\n     {\n@@ -7453,7 +7457,7 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n \n       gfc_init_block (&block);\n       if (rank)\n-\tnelems = get_full_array_size (&block, src, rank);\n+\tnelems = gfc_full_array_size (&block, src, rank);\n       else\n \tnelems = gfc_index_one_node;\n \n@@ -7473,14 +7477,17 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n \n       /* We know the temporary and the value will be the same length,\n \t so can use memcpy.  */\n-      tmp = builtin_decl_explicit (BUILT_IN_MEMCPY);\n-      tmp = build_call_expr_loc (input_location,\n-\t\t\ttmp, 3, gfc_conv_descriptor_data_get (dest),\n-\t\t\tgfc_conv_descriptor_data_get (src),\n-\t\t\tfold_convert (size_type_node, size));\n+      if (!no_memcpy)\n+\t{\n+\t  tmp = builtin_decl_explicit (BUILT_IN_MEMCPY);\n+\t  tmp = build_call_expr_loc (input_location, tmp, 3,\n+\t\t\t\t     gfc_conv_descriptor_data_get (dest),\n+\t\t\t\t     gfc_conv_descriptor_data_get (src),\n+\t\t\t\t     fold_convert (size_type_node, size));\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n     }\n \n-  gfc_add_expr_to_block (&block, tmp);\n   tmp = gfc_finish_block (&block);\n \n   /* Null the destination if the source is null; otherwise do\n@@ -7502,7 +7509,8 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n tree\n gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank)\n {\n-  return duplicate_allocatable (dest, src, type, rank, false, NULL_TREE);\n+  return duplicate_allocatable (dest, src, type, rank, false, false,\n+\t\t\t\tNULL_TREE);\n }\n \n \n@@ -7511,7 +7519,16 @@ gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank)\n tree\n gfc_copy_allocatable_data (tree dest, tree src, tree type, int rank)\n {\n-  return duplicate_allocatable (dest, src, type, rank, true, NULL_TREE);\n+  return duplicate_allocatable (dest, src, type, rank, true, false,\n+\t\t\t\tNULL_TREE);\n+}\n+\n+/* Allocate dest to the same size as src, but don't copy anything.  */\n+\n+tree\n+gfc_duplicate_allocatable_nocopy (tree dest, tree src, tree type, int rank)\n+{\n+  return duplicate_allocatable (dest, src, type, rank, false, true, NULL_TREE);\n }\n \n \n@@ -7571,7 +7588,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t  /* Use the descriptor for an allocatable array.  Since this\n \t     is a full array reference, we only need the descriptor\n \t     information from dimension = rank.  */\n-\t  tmp = get_full_array_size (&fnblock, decl, rank);\n+\t  tmp = gfc_full_array_size (&fnblock, decl, rank);\n \t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t\t gfc_array_index_type, tmp,\n \t\t\t\t gfc_index_one_node);\n@@ -7930,7 +7947,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t      size = size_of_string_in_bytes (c->ts.kind, len);\n \t      tmp = duplicate_allocatable (dcmp, comp, ctype, rank,\n-\t\t\t\t\t   false, size);\n+\t\t\t\t\t   false, false, size);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  else if (c->attr.allocatable && !c->attr.proc_pointer"}, {"sha": "e0bb82071fa4f7b996570d42d6c54de4c7ee416a", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -44,10 +44,14 @@ void gfc_trans_g77_array (gfc_symbol *, gfc_wrapped_block *);\n /* Generate code to deallocate an array, if it is allocated.  */\n tree gfc_trans_dealloc_allocated (tree, bool, gfc_expr *);\n \n+tree gfc_full_array_size (stmtblock_t *, tree, int);\n+\n tree gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank);\n \n tree gfc_copy_allocatable_data (tree dest, tree src, tree type, int rank);\n \n+tree gfc_duplicate_allocatable_nocopy (tree, tree, tree, int);\n+\n tree gfc_nullify_alloc_comp (gfc_symbol *, tree, int);\n \n tree gfc_deallocate_alloc_comp (gfc_symbol *, tree, int);"}, {"sha": "36aa8f3efd820987f7fdfaa4fa91ed4189db8624", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -705,6 +705,7 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n \tTREE_ADDRESSABLE (var_decl) = 1;\n       /* Fake variables are not visible from other translation units. */\n       TREE_PUBLIC (var_decl) = 0;\n+      gfc_finish_decl_attrs (var_decl, &s->sym->attr);\n \n       /* To preserve identifier names in COMMON, chain to procedure\n          scope unless at top level in a module definition.  */"}, {"sha": "863e596c639666db1b1d6279b8f04b291fcadc55", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -496,6 +496,29 @@ gfc_finish_decl (tree decl)\n }\n \n \n+/* Handle setting of GFC_DECL_SCALAR* on DECL.  */\n+\n+void\n+gfc_finish_decl_attrs (tree decl, symbol_attribute *attr)\n+{\n+  if (!attr->dimension && !attr->codimension)\n+    {\n+      /* Handle scalar allocatable variables.  */\n+      if (attr->allocatable)\n+\t{\n+\t  gfc_allocate_lang_decl (decl);\n+\t  GFC_DECL_SCALAR_ALLOCATABLE (decl) = 1;\n+\t}\n+      /* Handle scalar pointer variables.  */\n+      if (attr->pointer)\n+\t{\n+\t  gfc_allocate_lang_decl (decl);\n+\t  GFC_DECL_SCALAR_POINTER (decl) = 1;\n+\t}\n+    }\n+}\n+\n+\n /* Apply symbol attributes to a variable, and add it to the function scope.  */\n \n static void\n@@ -607,6 +630,8 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n   if (sym->attr.threadprivate\n       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n     DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n+\n+  gfc_finish_decl_attrs (decl, &sym->attr);\n }\n \n \n@@ -615,7 +640,8 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n void\n gfc_allocate_lang_decl (tree decl)\n {\n-  DECL_LANG_SPECIFIC (decl) = ggc_cleared_alloc<struct lang_decl> ();\n+  if (DECL_LANG_SPECIFIC (decl) == NULL)\n+    DECL_LANG_SPECIFIC (decl) = ggc_cleared_alloc<struct lang_decl> ();\n }\n \n /* Remember a symbol to generate initialization/cleanup code at function\n@@ -1517,6 +1543,9 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n       && !sym->attr.select_type_temporary)\n     DECL_BY_REFERENCE (decl) = 1;\n \n+  if (sym->attr.associate_var)\n+    GFC_DECL_ASSOCIATE_VAR_P (decl) = 1;\n+\n   if (sym->attr.vtab\n       || (sym->name[0] == '_' && strncmp (\"__def_init\", sym->name, 10) == 0))\n     TREE_READONLY (decl) = 1;\n@@ -2236,6 +2265,7 @@ create_function_arglist (gfc_symbol * sym)\n \tDECL_BY_REFERENCE (parm) = 1;\n \n       gfc_finish_decl (parm);\n+      gfc_finish_decl_attrs (parm, &f->sym->attr);\n \n       f->sym->backend_decl = parm;\n \n@@ -2690,6 +2720,7 @@ gfc_get_fake_result_decl (gfc_symbol * sym, int parent_flag)\n       TREE_ADDRESSABLE (decl) = 1;\n \n       layout_decl (decl, 0);\n+      gfc_finish_decl_attrs (decl, &sym->attr);\n \n       if (parent_flag)\n \tgfc_add_decl_to_parent_function (decl);"}, {"sha": "998d687761bf22ae73cfb2f9f1a0703d5b733e0a", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 671, "deletions": 183, "changes": 854, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -55,7 +55,9 @@ gfc_omp_privatize_by_reference (const_tree decl)\n       /* Array POINTER/ALLOCATABLE have aggregate types, all user variables\n \t that have POINTER_TYPE type and don't have GFC_POINTER_TYPE_P\n \t set are supposed to be privatized by reference.  */\n-      if (GFC_POINTER_TYPE_P (type))\n+      if (GFC_DECL_GET_SCALAR_POINTER (decl)\n+\t  || GFC_DECL_GET_SCALAR_ALLOCATABLE (decl)\n+\t  || GFC_DECL_CRAY_POINTEE (decl))\n \treturn false;\n \n       if (!DECL_ARTIFICIAL (decl)\n@@ -77,6 +79,19 @@ gfc_omp_privatize_by_reference (const_tree decl)\n enum omp_clause_default_kind\n gfc_omp_predetermined_sharing (tree decl)\n {\n+  /* Associate names preserve the association established during ASSOCIATE.\n+     As they are implemented either as pointers to the selector or array\n+     descriptor and shouldn't really change in the ASSOCIATE region,\n+     this decl can be either shared or firstprivate.  If it is a pointer,\n+     use firstprivate, as it is cheaper that way, otherwise make it shared.  */\n+  if (GFC_DECL_ASSOCIATE_VAR_P (decl))\n+    {\n+      if (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE)\n+\treturn OMP_CLAUSE_DEFAULT_FIRSTPRIVATE;\n+      else\n+\treturn OMP_CLAUSE_DEFAULT_SHARED;\n+    }\n+\n   if (DECL_ARTIFICIAL (decl)\n       && ! GFC_DECL_RESULT (decl)\n       && ! (DECL_LANG_SPECIFIC (decl)\n@@ -135,6 +150,41 @@ gfc_omp_report_decl (tree decl)\n   return decl;\n }\n \n+/* Return true if TYPE has any allocatable components.  */\n+\n+static bool\n+gfc_has_alloc_comps (tree type, tree decl)\n+{\n+  tree field, ftype;\n+\n+  if (POINTER_TYPE_P (type))\n+    {\n+      if (GFC_DECL_GET_SCALAR_ALLOCATABLE (decl))\n+\ttype = TREE_TYPE (type);\n+      else if (GFC_DECL_GET_SCALAR_POINTER (decl))\n+\treturn false;\n+    }\n+\n+  while (GFC_DESCRIPTOR_TYPE_P (type) || GFC_ARRAY_TYPE_P (type))\n+    type = gfc_get_element_type (type);\n+\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    return false;\n+\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    {\n+      ftype = TREE_TYPE (field);\n+      if (GFC_DECL_GET_SCALAR_ALLOCATABLE (field))\n+\treturn true;\n+      if (GFC_DESCRIPTOR_TYPE_P (ftype)\n+\t  && GFC_TYPE_ARRAY_AKIND (ftype) == GFC_ARRAY_ALLOCATABLE)\n+\treturn true;\n+      if (gfc_has_alloc_comps (ftype, field))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Return true if DECL in private clause needs\n    OMP_CLAUSE_PRIVATE_OUTER_REF on the private clause.  */\n bool\n@@ -146,68 +196,335 @@ gfc_omp_private_outer_ref (tree decl)\n       && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)\n     return true;\n \n+  if (GFC_DECL_GET_SCALAR_ALLOCATABLE (decl))\n+    return true;\n+\n+  if (gfc_omp_privatize_by_reference (decl))\n+    type = TREE_TYPE (type);\n+\n+  if (gfc_has_alloc_comps (type, decl))\n+    return true;\n+\n   return false;\n }\n \n+/* Callback for gfc_omp_unshare_expr.  */\n+\n+static tree\n+gfc_omp_unshare_expr_r (tree *tp, int *walk_subtrees, void *)\n+{\n+  tree t = *tp;\n+  enum tree_code code = TREE_CODE (t);\n+\n+  /* Stop at types, decls, constants like copy_tree_r.  */\n+  if (TREE_CODE_CLASS (code) == tcc_type\n+      || TREE_CODE_CLASS (code) == tcc_declaration\n+      || TREE_CODE_CLASS (code) == tcc_constant\n+      || code == BLOCK)\n+    *walk_subtrees = 0;\n+  else if (handled_component_p (t)\n+\t   || TREE_CODE (t) == MEM_REF)\n+    {\n+      *tp = unshare_expr (t);\n+      *walk_subtrees = 0;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Unshare in expr anything that the FE which normally doesn't\n+   care much about tree sharing (because during gimplification\n+   everything is unshared) could cause problems with tree sharing\n+   at omp-low.c time.  */\n+\n+static tree\n+gfc_omp_unshare_expr (tree expr)\n+{\n+  walk_tree (&expr, gfc_omp_unshare_expr_r, NULL, NULL);\n+  return expr;\n+}\n+\n+enum walk_alloc_comps\n+{\n+  WALK_ALLOC_COMPS_DTOR,\n+  WALK_ALLOC_COMPS_DEFAULT_CTOR,\n+  WALK_ALLOC_COMPS_COPY_CTOR\n+};\n+\n+/* Handle allocatable components in OpenMP clauses.  */\n+\n+static tree\n+gfc_walk_alloc_comps (tree decl, tree dest, tree var,\n+\t\t      enum walk_alloc_comps kind)\n+{\n+  stmtblock_t block, tmpblock;\n+  tree type = TREE_TYPE (decl), then_b, tem, field;\n+  gfc_init_block (&block);\n+\n+  if (GFC_ARRAY_TYPE_P (type) || GFC_DESCRIPTOR_TYPE_P (type))\n+    {\n+      if (GFC_DESCRIPTOR_TYPE_P (type))\n+\t{\n+\t  gfc_init_block (&tmpblock);\n+\t  tem = gfc_full_array_size (&tmpblock, decl,\n+\t\t\t\t     GFC_TYPE_ARRAY_RANK (type));\n+\t  then_b = gfc_finish_block (&tmpblock);\n+\t  gfc_add_expr_to_block (&block, gfc_omp_unshare_expr (then_b));\n+\t  tem = gfc_omp_unshare_expr (tem);\n+\t  tem = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type, tem,\n+\t\t\t\t gfc_index_one_node);\n+\t}\n+      else\n+\t{\n+\t  if (!TYPE_DOMAIN (type)\n+\t      || TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == NULL_TREE\n+\t      || TYPE_MIN_VALUE (TYPE_DOMAIN (type)) == error_mark_node\n+\t      || TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == error_mark_node)\n+\t    {\n+\t      tem = fold_build2 (EXACT_DIV_EXPR, sizetype,\n+\t\t\t\t TYPE_SIZE_UNIT (type),\n+\t\t\t\t TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+\t      tem = size_binop (MINUS_EXPR, tem, size_one_node);\n+\t    }\n+\t  else\n+\t    tem = array_type_nelts (type);\n+\t  tem = fold_convert (gfc_array_index_type, tem);\n+\t}\n+\n+      tree nelems = gfc_evaluate_now (tem, &block);\n+      tree index = gfc_create_var (gfc_array_index_type, \"S\");\n+\n+      gfc_init_block (&tmpblock);\n+      tem = gfc_conv_array_data (decl);\n+      tree declvar = build_fold_indirect_ref_loc (input_location, tem);\n+      tree declvref = gfc_build_array_ref (declvar, index, NULL);\n+      tree destvar, destvref = NULL_TREE;\n+      if (dest)\n+\t{\n+\t  tem = gfc_conv_array_data (dest);\n+\t  destvar = build_fold_indirect_ref_loc (input_location, tem);\n+\t  destvref = gfc_build_array_ref (destvar, index, NULL);\n+\t}\n+      gfc_add_expr_to_block (&tmpblock,\n+\t\t\t     gfc_walk_alloc_comps (declvref, destvref,\n+\t\t\t\t\t\t   var, kind));\n+\n+      gfc_loopinfo loop;\n+      gfc_init_loopinfo (&loop);\n+      loop.dimen = 1;\n+      loop.from[0] = gfc_index_zero_node;\n+      loop.loopvar[0] = index;\n+      loop.to[0] = nelems;\n+      gfc_trans_scalarizing_loops (&loop, &tmpblock);\n+      gfc_add_block_to_block (&block, &loop.pre);\n+      return gfc_finish_block (&block);\n+    }\n+  else if (GFC_DECL_GET_SCALAR_ALLOCATABLE (var))\n+    {\n+      decl = build_fold_indirect_ref_loc (input_location, decl);\n+      if (dest)\n+\tdest = build_fold_indirect_ref_loc (input_location, dest);\n+      type = TREE_TYPE (decl);\n+    }\n+\n+  gcc_assert (TREE_CODE (type) == RECORD_TYPE);\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    {\n+      tree ftype = TREE_TYPE (field);\n+      tree declf, destf = NULL_TREE;\n+      bool has_alloc_comps = gfc_has_alloc_comps (ftype, field);\n+      if ((!GFC_DESCRIPTOR_TYPE_P (ftype)\n+\t   || GFC_TYPE_ARRAY_AKIND (ftype) != GFC_ARRAY_ALLOCATABLE)\n+\t  && !GFC_DECL_GET_SCALAR_ALLOCATABLE (field)\n+\t  && !has_alloc_comps)\n+\tcontinue;\n+      declf = fold_build3_loc (input_location, COMPONENT_REF, ftype,\n+\t\t\t       decl, field, NULL_TREE);\n+      if (dest)\n+\tdestf = fold_build3_loc (input_location, COMPONENT_REF, ftype,\n+\t\t\t\t dest, field, NULL_TREE);\n+\n+      tem = NULL_TREE;\n+      switch (kind)\n+\t{\n+\tcase WALK_ALLOC_COMPS_DTOR:\n+\t  break;\n+\tcase WALK_ALLOC_COMPS_DEFAULT_CTOR:\n+\t  if (GFC_DESCRIPTOR_TYPE_P (ftype)\n+\t      && GFC_TYPE_ARRAY_AKIND (ftype) == GFC_ARRAY_ALLOCATABLE)\n+\t    {\n+\t      gfc_add_modify (&block, unshare_expr (destf),\n+\t\t\t      unshare_expr (declf));\n+\t      tem = gfc_duplicate_allocatable_nocopy\n+\t\t\t\t\t(destf, declf, ftype,\n+\t\t\t\t\t GFC_TYPE_ARRAY_RANK (ftype));\n+\t    }\n+\t  else if (GFC_DECL_GET_SCALAR_ALLOCATABLE (field))\n+\t    tem = gfc_duplicate_allocatable_nocopy (destf, declf, ftype, 0);\n+\t  break;\n+\tcase WALK_ALLOC_COMPS_COPY_CTOR:\n+\t  if (GFC_DESCRIPTOR_TYPE_P (ftype)\n+\t      && GFC_TYPE_ARRAY_AKIND (ftype) == GFC_ARRAY_ALLOCATABLE)\n+\t    tem = gfc_duplicate_allocatable (destf, declf, ftype,\n+\t\t\t\t\t     GFC_TYPE_ARRAY_RANK (ftype));\n+\t  else if (GFC_DECL_GET_SCALAR_ALLOCATABLE (field))\n+\t    tem = gfc_duplicate_allocatable (destf, declf, ftype, 0);\n+\t  break;\n+\t}\n+      if (tem)\n+\tgfc_add_expr_to_block (&block, gfc_omp_unshare_expr (tem));\n+      if (has_alloc_comps)\n+\t{\n+\t  gfc_init_block (&tmpblock);\n+\t  gfc_add_expr_to_block (&tmpblock,\n+\t\t\t\t gfc_walk_alloc_comps (declf, destf,\n+\t\t\t\t\t\t       field, kind));\n+\t  then_b = gfc_finish_block (&tmpblock);\n+\t  if (GFC_DESCRIPTOR_TYPE_P (ftype)\n+\t      && GFC_TYPE_ARRAY_AKIND (ftype) == GFC_ARRAY_ALLOCATABLE)\n+\t    tem = gfc_conv_descriptor_data_get (unshare_expr (declf));\n+\t  else if (GFC_DECL_GET_SCALAR_ALLOCATABLE (field))\n+\t    tem = unshare_expr (declf);\n+\t  else\n+\t    tem = NULL_TREE;\n+\t  if (tem)\n+\t    {\n+\t      tem = fold_convert (pvoid_type_node, tem);\n+\t      tem = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t     boolean_type_node, tem,\n+\t\t\t\t     null_pointer_node);\n+\t      then_b = build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t   tem, then_b,\n+\t\t\t\t   build_empty_stmt (input_location));\n+\t    }\n+\t  gfc_add_expr_to_block (&block, then_b);\n+\t}\n+      if (kind == WALK_ALLOC_COMPS_DTOR)\n+\t{\n+\t  if (GFC_DESCRIPTOR_TYPE_P (ftype)\n+\t      && GFC_TYPE_ARRAY_AKIND (ftype) == GFC_ARRAY_ALLOCATABLE)\n+\t    {\n+\t      tem = gfc_trans_dealloc_allocated (unshare_expr (declf),\n+\t\t\t\t\t\t false, NULL);\n+\t      gfc_add_expr_to_block (&block, gfc_omp_unshare_expr (tem));\n+\t    }\n+\t  else if (GFC_DECL_GET_SCALAR_ALLOCATABLE (field))\n+\t    {\n+\t      tem = gfc_call_free (unshare_expr (declf));\n+\t      gfc_add_expr_to_block (&block, gfc_omp_unshare_expr (tem));\n+\t    }\n+\t}\n+    }\n+\n+  return gfc_finish_block (&block);\n+}\n+\n /* Return code to initialize DECL with its default constructor, or\n    NULL if there's nothing to do.  */\n \n tree\n gfc_omp_clause_default_ctor (tree clause, tree decl, tree outer)\n {\n-  tree type = TREE_TYPE (decl), rank, size, esize, ptr, cond, then_b, else_b;\n+  tree type = TREE_TYPE (decl), size, ptr, cond, then_b, else_b;\n   stmtblock_t block, cond_block;\n \n-  if (! GFC_DESCRIPTOR_TYPE_P (type)\n-      || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n-    return NULL;\n+  gcc_assert (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_PRIVATE\n+\t      || OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_LASTPRIVATE\n+\t      || OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_LINEAR\n+\t      || OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_REDUCTION);\n \n-  if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_REDUCTION)\n-    return NULL;\n+  if ((! GFC_DESCRIPTOR_TYPE_P (type)\n+       || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n+      && !GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause)))\n+    {\n+      if (gfc_has_alloc_comps (type, OMP_CLAUSE_DECL (clause)))\n+\t{\n+\t  gcc_assert (outer);\n+\t  gfc_start_block (&block);\n+\t  tree tem = gfc_walk_alloc_comps (outer, decl,\n+\t\t\t\t\t   OMP_CLAUSE_DECL (clause),\n+\t\t\t\t\t   WALK_ALLOC_COMPS_DEFAULT_CTOR);\n+\t  gfc_add_expr_to_block (&block, tem);\n+\t  return gfc_finish_block (&block);\n+\t}\n+      return NULL_TREE;\n+    }\n \n-  gcc_assert (outer != NULL);\n-  gcc_assert (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_PRIVATE\n-\t      || OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_LASTPRIVATE);\n+  gcc_assert (outer != NULL_TREE);\n \n-  /* Allocatable arrays in PRIVATE clauses need to be set to\n+  /* Allocatable arrays and scalars in PRIVATE clauses need to be set to\n      \"not currently allocated\" allocation status if outer\n      array is \"not currently allocated\", otherwise should be allocated.  */\n   gfc_start_block (&block);\n \n   gfc_init_block (&cond_block);\n \n-  gfc_add_modify (&cond_block, decl, outer);\n-  rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n-  size = gfc_conv_descriptor_ubound_get (decl, rank);\n-  size = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n-\t\t\t  size, gfc_conv_descriptor_lbound_get (decl, rank));\n-  size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n-\t\t\t  size, gfc_index_one_node);\n-  if (GFC_TYPE_ARRAY_RANK (type) > 1)\n-    size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n-\t\t\t    size, gfc_conv_descriptor_stride_get (decl, rank));\n-  esize = fold_convert (gfc_array_index_type,\n-\t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n-  size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n-\t\t\t  size, esize);\n-  size = gfc_evaluate_now (fold_convert (size_type_node, size), &cond_block);\n-\n+  if (GFC_DESCRIPTOR_TYPE_P (type))\n+    {\n+      gfc_add_modify (&cond_block, decl, outer);\n+      tree rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n+      size = gfc_conv_descriptor_ubound_get (decl, rank);\n+      size = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t      size,\n+\t\t\t      gfc_conv_descriptor_lbound_get (decl, rank));\n+      size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      size, gfc_index_one_node);\n+      if (GFC_TYPE_ARRAY_RANK (type) > 1)\n+\tsize = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\tgfc_array_index_type, size,\n+\t\t\t\tgfc_conv_descriptor_stride_get (decl, rank));\n+      tree esize = fold_convert (gfc_array_index_type,\n+\t\t\t\t TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+      size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t      size, esize);\n+      size = unshare_expr (size);\n+      size = gfc_evaluate_now (fold_convert (size_type_node, size),\n+\t\t\t       &cond_block);\n+    }\n+  else\n+    size = fold_convert (size_type_node, TYPE_SIZE_UNIT (TREE_TYPE (type)));\n   ptr = gfc_create_var (pvoid_type_node, NULL);\n   gfc_allocate_using_malloc (&cond_block, ptr, size, NULL_TREE);\n-  gfc_conv_descriptor_data_set (&cond_block, decl, ptr);\n-\n+  if (GFC_DESCRIPTOR_TYPE_P (type))\n+    gfc_conv_descriptor_data_set (&cond_block, unshare_expr (decl), ptr);\n+  else\n+    gfc_add_modify (&cond_block, unshare_expr (decl),\n+\t\t    fold_convert (TREE_TYPE (decl), ptr));\n+  if (gfc_has_alloc_comps (type, OMP_CLAUSE_DECL (clause)))\n+    {\n+      tree tem = gfc_walk_alloc_comps (outer, decl,\n+\t\t\t\t       OMP_CLAUSE_DECL (clause),\n+\t\t\t\t       WALK_ALLOC_COMPS_DEFAULT_CTOR);\n+      gfc_add_expr_to_block (&cond_block, tem);\n+    }\n   then_b = gfc_finish_block (&cond_block);\n \n-  gfc_init_block (&cond_block);\n-  gfc_conv_descriptor_data_set (&cond_block, decl, null_pointer_node);\n-  else_b = gfc_finish_block (&cond_block);\n-\n-  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n-\t\t\t  fold_convert (pvoid_type_node,\n-\t\t\t\t\tgfc_conv_descriptor_data_get (outer)),\n-\t\t\t  null_pointer_node);\n-  gfc_add_expr_to_block (&block, build3_loc (input_location, COND_EXPR,\n-\t\t\t void_type_node, cond, then_b, else_b));\n+  /* Reduction clause requires allocated ALLOCATABLE.  */\n+  if (OMP_CLAUSE_CODE (clause) != OMP_CLAUSE_REDUCTION)\n+    {\n+      gfc_init_block (&cond_block);\n+      if (GFC_DESCRIPTOR_TYPE_P (type))\n+\tgfc_conv_descriptor_data_set (&cond_block, unshare_expr (decl),\n+\t\t\t\t      null_pointer_node);\n+      else\n+\tgfc_add_modify (&cond_block, unshare_expr (decl),\n+\t\t\tbuild_zero_cst (TREE_TYPE (decl)));\n+      else_b = gfc_finish_block (&cond_block);\n+\n+      tree tem = fold_convert (pvoid_type_node,\n+\t\t\t       GFC_DESCRIPTOR_TYPE_P (type)\n+\t\t\t       ? gfc_conv_descriptor_data_get (outer) : outer);\n+      tem = unshare_expr (tem);\n+      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t      tem, null_pointer_node);\n+      gfc_add_expr_to_block (&block,\n+\t\t\t     build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\t void_type_node, cond, then_b,\n+\t\t\t\t\t else_b));\n+    }\n+  else\n+    gfc_add_expr_to_block (&block, then_b);\n \n   return gfc_finish_block (&block);\n }\n@@ -217,15 +534,29 @@ gfc_omp_clause_default_ctor (tree clause, tree decl, tree outer)\n tree\n gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n {\n-  tree type = TREE_TYPE (dest), ptr, size, esize, rank, call;\n+  tree type = TREE_TYPE (dest), ptr, size, call;\n   tree cond, then_b, else_b;\n   stmtblock_t block, cond_block;\n \n-  if (! GFC_DESCRIPTOR_TYPE_P (type)\n-      || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n-    return build2_v (MODIFY_EXPR, dest, src);\n+  gcc_assert (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_FIRSTPRIVATE\n+\t      || OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_LINEAR);\n \n-  gcc_assert (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_FIRSTPRIVATE);\n+  if ((! GFC_DESCRIPTOR_TYPE_P (type)\n+       || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n+      && !GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause)))\n+    {\n+      if (gfc_has_alloc_comps (type, OMP_CLAUSE_DECL (clause)))\n+\t{\n+\t  gfc_start_block (&block);\n+\t  gfc_add_modify (&block, dest, src);\n+\t  tree tem = gfc_walk_alloc_comps (src, dest, OMP_CLAUSE_DECL (clause),\n+\t\t\t\t\t   WALK_ALLOC_COMPS_COPY_CTOR);\n+\t  gfc_add_expr_to_block (&block, tem);\n+\t  return gfc_finish_block (&block);\n+\t}\n+      else\n+\treturn build2_v (MODIFY_EXPR, dest, src);\n+    }\n \n   /* Allocatable arrays in FIRSTPRIVATE clauses need to be allocated\n      and copied from SRC.  */\n@@ -234,85 +565,257 @@ gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n   gfc_init_block (&cond_block);\n \n   gfc_add_modify (&cond_block, dest, src);\n-  rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n-  size = gfc_conv_descriptor_ubound_get (dest, rank);\n-  size = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n-\t\t\t  size, gfc_conv_descriptor_lbound_get (dest, rank));\n-  size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n-\t\t\t  size, gfc_index_one_node);\n-  if (GFC_TYPE_ARRAY_RANK (type) > 1)\n-    size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n-\t\t\t    size, gfc_conv_descriptor_stride_get (dest, rank));\n-  esize = fold_convert (gfc_array_index_type,\n-\t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n-  size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n-\t\t\t  size, esize);\n-  size = gfc_evaluate_now (fold_convert (size_type_node, size), &cond_block);\n-\n+  if (GFC_DESCRIPTOR_TYPE_P (type))\n+    {\n+      tree rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n+      size = gfc_conv_descriptor_ubound_get (dest, rank);\n+      size = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t      size,\n+\t\t\t      gfc_conv_descriptor_lbound_get (dest, rank));\n+      size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      size, gfc_index_one_node);\n+      if (GFC_TYPE_ARRAY_RANK (type) > 1)\n+\tsize = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\tgfc_array_index_type, size,\n+\t\t\t\tgfc_conv_descriptor_stride_get (dest, rank));\n+      tree esize = fold_convert (gfc_array_index_type,\n+\t\t\t\t TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+      size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t      size, esize);\n+      size = unshare_expr (size);\n+      size = gfc_evaluate_now (fold_convert (size_type_node, size),\n+\t\t\t       &cond_block);\n+    }\n+  else\n+    size = fold_convert (size_type_node, TYPE_SIZE_UNIT (TREE_TYPE (type)));\n   ptr = gfc_create_var (pvoid_type_node, NULL);\n   gfc_allocate_using_malloc (&cond_block, ptr, size, NULL_TREE);\n-  gfc_conv_descriptor_data_set (&cond_block, dest, ptr);\n+  if (GFC_DESCRIPTOR_TYPE_P (type))\n+    gfc_conv_descriptor_data_set (&cond_block, unshare_expr (dest), ptr);\n+  else\n+    gfc_add_modify (&cond_block, unshare_expr (dest),\n+\t\t    fold_convert (TREE_TYPE (dest), ptr));\n \n+  tree srcptr = GFC_DESCRIPTOR_TYPE_P (type)\n+\t\t? gfc_conv_descriptor_data_get (src) : src;\n+  srcptr = unshare_expr (srcptr);\n+  srcptr = fold_convert (pvoid_type_node, srcptr);\n   call = build_call_expr_loc (input_location,\n-\t\t\t  builtin_decl_explicit (BUILT_IN_MEMCPY),\n-\t\t\t  3, ptr,\n-\t\t\t  fold_convert (pvoid_type_node,\n-\t\t\t\t\tgfc_conv_descriptor_data_get (src)),\n-\t\t\t  size);\n+\t\t\t      builtin_decl_explicit (BUILT_IN_MEMCPY), 3, ptr,\n+\t\t\t      srcptr, size);\n   gfc_add_expr_to_block (&cond_block, fold_convert (void_type_node, call));\n+  if (gfc_has_alloc_comps (type, OMP_CLAUSE_DECL (clause)))\n+    {\n+      tree tem = gfc_walk_alloc_comps (src, dest,\n+\t\t\t\t       OMP_CLAUSE_DECL (clause),\n+\t\t\t\t       WALK_ALLOC_COMPS_COPY_CTOR);\n+      gfc_add_expr_to_block (&cond_block, tem);\n+    }\n   then_b = gfc_finish_block (&cond_block);\n \n   gfc_init_block (&cond_block);\n-  gfc_conv_descriptor_data_set (&cond_block, dest, null_pointer_node);\n+  if (GFC_DESCRIPTOR_TYPE_P (type))\n+    gfc_conv_descriptor_data_set (&cond_block, unshare_expr (dest),\n+\t\t\t\t  null_pointer_node);\n+  else\n+    gfc_add_modify (&cond_block, unshare_expr (dest),\n+\t\t    build_zero_cst (TREE_TYPE (dest)));\n   else_b = gfc_finish_block (&cond_block);\n \n   cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n-\t\t\t  fold_convert (pvoid_type_node,\n-\t\t\t\t\tgfc_conv_descriptor_data_get (src)),\n-\t\t\t  null_pointer_node);\n-  gfc_add_expr_to_block (&block, build3_loc (input_location, COND_EXPR,\n-\t\t\t void_type_node, cond, then_b, else_b));\n+\t\t\t  unshare_expr (srcptr), null_pointer_node);\n+  gfc_add_expr_to_block (&block,\n+\t\t\t build3_loc (input_location, COND_EXPR,\n+\t\t\t\t     void_type_node, cond, then_b, else_b));\n \n   return gfc_finish_block (&block);\n }\n \n-/* Similarly, except use an assignment operator instead.  */\n+/* Similarly, except use an intrinsic or pointer assignment operator\n+   instead.  */\n \n tree\n-gfc_omp_clause_assign_op (tree clause ATTRIBUTE_UNUSED, tree dest, tree src)\n+gfc_omp_clause_assign_op (tree clause, tree dest, tree src)\n {\n-  tree type = TREE_TYPE (dest), rank, size, esize, call;\n-  stmtblock_t block;\n+  tree type = TREE_TYPE (dest), ptr, size, call, nonalloc;\n+  tree cond, then_b, else_b;\n+  stmtblock_t block, cond_block, cond_block2, inner_block;\n \n-  if (! GFC_DESCRIPTOR_TYPE_P (type)\n-      || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n-    return build2_v (MODIFY_EXPR, dest, src);\n+  if ((! GFC_DESCRIPTOR_TYPE_P (type)\n+       || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n+      && !GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause)))\n+    {\n+      if (gfc_has_alloc_comps (type, OMP_CLAUSE_DECL (clause)))\n+\t{\n+\t  gfc_start_block (&block);\n+\t  /* First dealloc any allocatable components in DEST.  */\n+\t  tree tem = gfc_walk_alloc_comps (dest, NULL_TREE,\n+\t\t\t\t\t   OMP_CLAUSE_DECL (clause),\n+\t\t\t\t\t   WALK_ALLOC_COMPS_DTOR);\n+\t  gfc_add_expr_to_block (&block, tem);\n+\t  /* Then copy over toplevel data.  */\n+\t  gfc_add_modify (&block, dest, src);\n+\t  /* Finally allocate any allocatable components and copy.  */\n+\t  tem = gfc_walk_alloc_comps (src, dest, OMP_CLAUSE_DECL (clause),\n+\t\t\t\t\t   WALK_ALLOC_COMPS_COPY_CTOR);\n+\t  gfc_add_expr_to_block (&block, tem);\n+\t  return gfc_finish_block (&block);\n+\t}\n+      else\n+\treturn build2_v (MODIFY_EXPR, dest, src);\n+    }\n \n-  /* Handle copying allocatable arrays.  */\n   gfc_start_block (&block);\n \n-  rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n-  size = gfc_conv_descriptor_ubound_get (dest, rank);\n-  size = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n-\t\t\t  size, gfc_conv_descriptor_lbound_get (dest, rank));\n-  size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n-\t\t\t  size, gfc_index_one_node);\n-  if (GFC_TYPE_ARRAY_RANK (type) > 1)\n-    size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n-\t\t\t    size, gfc_conv_descriptor_stride_get (dest, rank));\n-  esize = fold_convert (gfc_array_index_type,\n-\t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n-  size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n-\t\t\t  size, esize);\n-  size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n+  if (gfc_has_alloc_comps (type, OMP_CLAUSE_DECL (clause)))\n+    {\n+      then_b = gfc_walk_alloc_comps (dest, NULL_TREE, OMP_CLAUSE_DECL (clause),\n+\t\t\t\t     WALK_ALLOC_COMPS_DTOR);\n+      tree tem = fold_convert (pvoid_type_node,\n+\t\t\t       GFC_DESCRIPTOR_TYPE_P (type)\n+\t\t\t       ? gfc_conv_descriptor_data_get (dest) : dest);\n+      tem = unshare_expr (tem);\n+      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t      tem, null_pointer_node);\n+      tem = build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\tthen_b, build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&block, tem);\n+    }\n+\n+  gfc_init_block (&cond_block);\n+\n+  if (GFC_DESCRIPTOR_TYPE_P (type))\n+    {\n+      tree rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n+      size = gfc_conv_descriptor_ubound_get (src, rank);\n+      size = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t      size,\n+\t\t\t      gfc_conv_descriptor_lbound_get (src, rank));\n+      size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      size, gfc_index_one_node);\n+      if (GFC_TYPE_ARRAY_RANK (type) > 1)\n+\tsize = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\tgfc_array_index_type, size,\n+\t\t\t\tgfc_conv_descriptor_stride_get (src, rank));\n+      tree esize = fold_convert (gfc_array_index_type,\n+\t\t\t\t TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+      size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t      size, esize);\n+      size = unshare_expr (size);\n+      size = gfc_evaluate_now (fold_convert (size_type_node, size),\n+\t\t\t       &cond_block);\n+    }\n+  else\n+    size = fold_convert (size_type_node, TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+  ptr = gfc_create_var (pvoid_type_node, NULL);\n+\n+  tree destptr = GFC_DESCRIPTOR_TYPE_P (type)\n+\t\t ? gfc_conv_descriptor_data_get (dest) : dest;\n+  destptr = unshare_expr (destptr);\n+  destptr = fold_convert (pvoid_type_node, destptr);\n+  gfc_add_modify (&cond_block, ptr, destptr);\n+\n+  nonalloc = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t      destptr, null_pointer_node);\n+  cond = nonalloc;\n+  if (GFC_DESCRIPTOR_TYPE_P (type))\n+    {\n+      int i;\n+      for (i = 0; i < GFC_TYPE_ARRAY_RANK (type); i++)\n+\t{\n+\t  tree rank = gfc_rank_cst[i];\n+\t  tree tem = gfc_conv_descriptor_ubound_get (src, rank);\n+\t  tem = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type, tem,\n+\t\t\t\t gfc_conv_descriptor_lbound_get (src, rank));\n+\t  tem = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, tem,\n+\t\t\t\t gfc_conv_descriptor_lbound_get (dest, rank));\n+\t  tem = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t tem, gfc_conv_descriptor_ubound_get (dest,\n+\t\t\t\t\t\t\t\t      rank));\n+\t  cond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t\t  boolean_type_node, cond, tem);\n+\t}\n+    }\n+\n+  gfc_init_block (&cond_block2);\n+\n+  if (GFC_DESCRIPTOR_TYPE_P (type))\n+    {\n+      gfc_init_block (&inner_block);\n+      gfc_allocate_using_malloc (&inner_block, ptr, size, NULL_TREE);\n+      then_b = gfc_finish_block (&inner_block);\n+\n+      gfc_init_block (&inner_block);\n+      gfc_add_modify (&inner_block, ptr,\n+\t\t      gfc_call_realloc (&inner_block, ptr, size));\n+      else_b = gfc_finish_block (&inner_block);\n+\n+      gfc_add_expr_to_block (&cond_block2,\n+\t\t\t     build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\t void_type_node,\n+\t\t\t\t\t unshare_expr (nonalloc),\n+\t\t\t\t\t then_b, else_b));\n+      gfc_add_modify (&cond_block2, dest, src);\n+      gfc_conv_descriptor_data_set (&cond_block2, unshare_expr (dest), ptr);\n+    }\n+  else\n+    {\n+      gfc_allocate_using_malloc (&cond_block2, ptr, size, NULL_TREE);\n+      gfc_add_modify (&cond_block2, unshare_expr (dest),\n+\t\t      fold_convert (type, ptr));\n+    }\n+  then_b = gfc_finish_block (&cond_block2);\n+  else_b = build_empty_stmt (input_location);\n+\n+  gfc_add_expr_to_block (&cond_block,\n+\t\t\t build3_loc (input_location, COND_EXPR,\n+\t\t\t\t     void_type_node, unshare_expr (cond),\n+\t\t\t\t     then_b, else_b));\n+\n+  tree srcptr = GFC_DESCRIPTOR_TYPE_P (type)\n+\t\t? gfc_conv_descriptor_data_get (src) : src;\n+  srcptr = unshare_expr (srcptr);\n+  srcptr = fold_convert (pvoid_type_node, srcptr);\n   call = build_call_expr_loc (input_location,\n-\t\t\t  builtin_decl_explicit (BUILT_IN_MEMCPY), 3,\n-\t\t\t  fold_convert (pvoid_type_node,\n-\t\t\t\t\tgfc_conv_descriptor_data_get (dest)),\n-\t\t\t  fold_convert (pvoid_type_node,\n-\t\t\t\t\tgfc_conv_descriptor_data_get (src)),\n-\t\t\t  size);\n-  gfc_add_expr_to_block (&block, fold_convert (void_type_node, call));\n+\t\t\t      builtin_decl_explicit (BUILT_IN_MEMCPY), 3, ptr,\n+\t\t\t      srcptr, size);\n+  gfc_add_expr_to_block (&cond_block, fold_convert (void_type_node, call));\n+  if (gfc_has_alloc_comps (type, OMP_CLAUSE_DECL (clause)))\n+    {\n+      tree tem = gfc_walk_alloc_comps (src, dest,\n+\t\t\t\t       OMP_CLAUSE_DECL (clause),\n+\t\t\t\t       WALK_ALLOC_COMPS_COPY_CTOR);\n+      gfc_add_expr_to_block (&cond_block, tem);\n+    }\n+  then_b = gfc_finish_block (&cond_block);\n+\n+  if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_COPYIN)\n+    {\n+      gfc_init_block (&cond_block);\n+      if (GFC_DESCRIPTOR_TYPE_P (type))\n+\tgfc_add_expr_to_block (&cond_block,\n+\t\t\t       gfc_trans_dealloc_allocated (unshare_expr (dest),\n+\t\t\t\t\t\t\t    false, NULL));\n+      else\n+\t{\n+\t  destptr = gfc_evaluate_now (destptr, &cond_block);\n+\t  gfc_add_expr_to_block (&cond_block, gfc_call_free (destptr));\n+\t  gfc_add_modify (&cond_block, unshare_expr (dest),\n+\t\t\t  build_zero_cst (TREE_TYPE (dest)));\n+\t}\n+      else_b = gfc_finish_block (&cond_block);\n+\n+      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t      unshare_expr (srcptr), null_pointer_node);\n+      gfc_add_expr_to_block (&block,\n+\t\t\t     build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\t void_type_node, cond,\n+\t\t\t\t\t then_b, else_b));\n+    }\n+  else\n+    gfc_add_expr_to_block (&block, then_b);\n \n   return gfc_finish_block (&block);\n }\n@@ -321,20 +824,52 @@ gfc_omp_clause_assign_op (tree clause ATTRIBUTE_UNUSED, tree dest, tree src)\n    to be done.  */\n \n tree\n-gfc_omp_clause_dtor (tree clause ATTRIBUTE_UNUSED, tree decl)\n+gfc_omp_clause_dtor (tree clause, tree decl)\n {\n-  tree type = TREE_TYPE (decl);\n+  tree type = TREE_TYPE (decl), tem;\n \n-  if (! GFC_DESCRIPTOR_TYPE_P (type)\n-      || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n-    return NULL;\n+  if ((! GFC_DESCRIPTOR_TYPE_P (type)\n+       || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n+      && !GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause)))\n+    {\n+      if (gfc_has_alloc_comps (type, OMP_CLAUSE_DECL (clause)))\n+\treturn gfc_walk_alloc_comps (decl, NULL_TREE,\n+\t\t\t\t     OMP_CLAUSE_DECL (clause),\n+\t\t\t\t     WALK_ALLOC_COMPS_DTOR);\n+      return NULL_TREE;\n+    }\n \n-  if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_REDUCTION)\n-    return NULL;\n+  if (GFC_DESCRIPTOR_TYPE_P (type))\n+    /* Allocatable arrays in FIRSTPRIVATE/LASTPRIVATE etc. clauses need\n+       to be deallocated if they were allocated.  */\n+    tem = gfc_trans_dealloc_allocated (decl, false, NULL);\n+  else\n+    tem = gfc_call_free (decl);\n+  tem = gfc_omp_unshare_expr (tem);\n \n-  /* Allocatable arrays in FIRSTPRIVATE/LASTPRIVATE etc. clauses need\n-     to be deallocated if they were allocated.  */\n-  return gfc_trans_dealloc_allocated (decl, false, NULL);\n+  if (gfc_has_alloc_comps (type, OMP_CLAUSE_DECL (clause)))\n+    {\n+      stmtblock_t block;\n+      tree then_b;\n+\n+      gfc_init_block (&block);\n+      gfc_add_expr_to_block (&block,\n+\t\t\t     gfc_walk_alloc_comps (decl, NULL_TREE,\n+\t\t\t\t\t\t   OMP_CLAUSE_DECL (clause),\n+\t\t\t\t\t\t   WALK_ALLOC_COMPS_DTOR));\n+      gfc_add_expr_to_block (&block, tem);\n+      then_b = gfc_finish_block (&block);\n+\n+      tem = fold_convert (pvoid_type_node,\n+\t\t\t  GFC_DESCRIPTOR_TYPE_P (type)\n+\t\t\t  ? gfc_conv_descriptor_data_get (decl) : decl);\n+      tem = unshare_expr (tem);\n+      tree cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t   tem, null_pointer_node);\n+      tem = build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\tthen_b, build_empty_stmt (input_location));\n+    }\n+  return tem;\n }\n \n \n@@ -881,47 +1416,7 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n \n   /* Create the init statement list.  */\n   pushlevel ();\n-  if (sym->attr.dimension\n-      && GFC_DESCRIPTOR_TYPE_P (type)\n-      && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)\n-    {\n-      /* If decl is an allocatable array, it needs to be allocated\n-\t with the same bounds as the outer var.  */\n-      tree rank, size, esize, ptr;\n-      stmtblock_t block;\n-\n-      gfc_start_block (&block);\n-\n-      gfc_add_modify (&block, decl, outer_sym.backend_decl);\n-      rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n-      size = gfc_conv_descriptor_ubound_get (decl, rank);\n-      size = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t      gfc_array_index_type, size,\n-\t\t\t      gfc_conv_descriptor_lbound_get (decl, rank));\n-      size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n-\t\t\t      size, gfc_index_one_node);\n-      if (GFC_TYPE_ARRAY_RANK (type) > 1)\n-\tsize = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\tgfc_array_index_type, size,\n-\t\t\t\tgfc_conv_descriptor_stride_get (decl, rank));\n-      esize = fold_convert (gfc_array_index_type,\n-\t\t\t    TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n-      size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n-\t\t\t      size, esize);\n-      size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n-\n-      ptr = gfc_create_var (pvoid_type_node, NULL);\n-      gfc_allocate_using_malloc (&block, ptr, size, NULL_TREE);\n-      gfc_conv_descriptor_data_set (&block, decl, ptr);\n-\n-      if (e2)\n-\tstmt = gfc_trans_assignment (e1, e2, false, false);\n-      else\n-\tstmt = gfc_trans_omp_udr_expr (n, true, e1, e3);\n-      gfc_add_expr_to_block (&block, stmt);\n-      stmt = gfc_finish_block (&block);\n-    }\n-  else if (e2)\n+  if (e2)\n     stmt = gfc_trans_assignment (e1, e2, false, false);\n   else if (sym->attr.dimension)\n     stmt = gfc_trans_omp_udr_expr (n, true, e1, e3);\n@@ -936,25 +1431,7 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n \n   /* Create the merge statement list.  */\n   pushlevel ();\n-  if (sym->attr.dimension\n-      && GFC_DESCRIPTOR_TYPE_P (type)\n-      && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)\n-    {\n-      /* If decl is an allocatable array, it needs to be deallocated\n-\t afterwards.  */\n-      stmtblock_t block;\n-\n-      gfc_start_block (&block);\n-      if (e4)\n-\tstmt = gfc_trans_assignment (e3, e4, false, true);\n-      else\n-\tstmt = gfc_trans_omp_udr_expr (n, false, e1, e3);\n-      gfc_add_expr_to_block (&block, stmt);\n-      gfc_add_expr_to_block (&block, gfc_trans_dealloc_allocated (decl, false,\n-\t\t\t\t\t\t\t\t  NULL));\n-      stmt = gfc_finish_block (&block);\n-    }\n-  else if (e4)\n+  if (e4)\n     stmt = gfc_trans_assignment (e3, e4, false, true);\n   else if (sym->attr.dimension)\n     stmt = gfc_trans_omp_udr_expr (n, false, e1, e3);\n@@ -1055,7 +1532,8 @@ gfc_trans_omp_reduction_list (gfc_omp_namelist *namelist, tree list,\n \t\tgcc_unreachable ();\n \t      }\n \t    if (namelist->sym->attr.dimension\n-\t\t|| namelist->rop == OMP_REDUCTION_USER)\n+\t\t|| namelist->rop == OMP_REDUCTION_USER\n+\t\t|| namelist->sym->attr.allocatable)\n \t      gfc_trans_omp_array_reduction_or_udr (node, namelist, where);\n \t    list = gfc_trans_add_clause (node, list);\n \t  }\n@@ -2274,19 +2752,25 @@ gfc_trans_omp_do_simd (gfc_code *code, gfc_omp_clauses *clausesa,\n       clausesa = clausesa_buf;\n       gfc_split_omp_clauses (code, clausesa);\n     }\n-  omp_do_clauses\n-    = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_DO], code->loc);\n+  if (gfc_option.gfc_flag_openmp)\n+    omp_do_clauses\n+      = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_DO], code->loc);\n   pblock = &block;\n   body = gfc_trans_omp_do (code, EXEC_OMP_SIMD, pblock,\n \t\t\t   &clausesa[GFC_OMP_SPLIT_SIMD], omp_clauses);\n   if (TREE_CODE (body) != BIND_EXPR)\n     body = build3_v (BIND_EXPR, NULL, body, poplevel (1, 0));\n   else\n     poplevel (0, 0);\n-  stmt = make_node (OMP_FOR);\n-  TREE_TYPE (stmt) = void_type_node;\n-  OMP_FOR_BODY (stmt) = body;\n-  OMP_FOR_CLAUSES (stmt) = omp_do_clauses;\n+  if (gfc_option.gfc_flag_openmp)\n+    {\n+      stmt = make_node (OMP_FOR);\n+      TREE_TYPE (stmt) = void_type_node;\n+      OMP_FOR_BODY (stmt) = body;\n+      OMP_FOR_CLAUSES (stmt) = omp_do_clauses;\n+    }\n+  else\n+    stmt = body;\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n }\n@@ -2332,18 +2816,22 @@ gfc_trans_omp_parallel_do_simd (gfc_code *code)\n   gfc_start_block (&block);\n \n   gfc_split_omp_clauses (code, clausesa);\n-  omp_clauses\n-    = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_PARALLEL],\n-\t\t\t     code->loc);\n+  if (gfc_option.gfc_flag_openmp)\n+    omp_clauses\n+      = gfc_trans_omp_clauses (&block, &clausesa[GFC_OMP_SPLIT_PARALLEL],\n+\t\t\t       code->loc);\n   pushlevel ();\n   stmt = gfc_trans_omp_do_simd (code, clausesa, omp_clauses);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n   else\n     poplevel (0, 0);\n-  stmt = build2_loc (input_location, OMP_PARALLEL, void_type_node, stmt,\n-\t\t     omp_clauses);\n-  OMP_PARALLEL_COMBINED (stmt) = 1;\n+  if (gfc_option.gfc_flag_openmp)\n+    {\n+      stmt = build2_loc (input_location, OMP_PARALLEL, void_type_node, stmt,\n+\t\t\t omp_clauses);\n+      OMP_PARALLEL_COMBINED (stmt) = 1;\n+    }\n   gfc_add_expr_to_block (&block, stmt);\n   return gfc_finish_block (&block);\n }"}, {"sha": "71a159b6b996583c44de728598fcffbc1ad5c820", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -2160,9 +2160,6 @@ gfc_sym_type (gfc_symbol * sym)\n \t\t\t\t\t\trestricted);\n \t      byref = 0;\n \t    }\n-\n-\t  if (sym->attr.cray_pointee)\n-\t    GFC_POINTER_TYPE_P (type) = 1;\n         }\n       else\n \t{\n@@ -2181,8 +2178,6 @@ gfc_sym_type (gfc_symbol * sym)\n       if (sym->attr.allocatable || sym->attr.pointer\n \t  || gfc_is_associate_pointer (sym))\n \ttype = gfc_build_pointer_type (sym, type);\n-      if (sym->attr.pointer || sym->attr.cray_pointee)\n-\tGFC_POINTER_TYPE_P (type) = 1;\n     }\n \n   /* We currently pass all parameters by reference.\n@@ -2552,6 +2547,8 @@ gfc_get_derived_type (gfc_symbol * derived)\n       else if (derived->declared_at.lb)\n \tgfc_set_decl_location (field, &derived->declared_at);\n \n+      gfc_finish_decl_attrs (field, &c->attr);\n+\n       DECL_PACKED (field) |= TYPE_PACKED (typenode);\n \n       gcc_assert (field);"}, {"sha": "7e8d08cda85f09ed984e07edfd53cd3cf395243c", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -547,6 +547,9 @@ void gfc_set_decl_assembler_name (tree, tree);\n /* Returns true if a variable of specified size should go on the stack.  */\n int gfc_can_put_var_on_stack (tree);\n \n+/* Set GFC_DECL_SCALAR_* on decl from sym if needed.  */\n+void gfc_finish_decl_attrs (tree, symbol_attribute *);\n+\n /* Allocate the lang-specific part of a decl node.  */\n void gfc_allocate_lang_decl (tree);\n \n@@ -822,6 +825,8 @@ struct GTY(()) lang_decl {\n   tree span;\n   /* For assumed-shape coarrays.  */\n   tree token, caf_offset;\n+  unsigned int scalar_allocatable : 1;\n+  unsigned int scalar_pointer : 1;\n };\n \n \n@@ -832,21 +837,28 @@ struct GTY(()) lang_decl {\n #define GFC_DECL_CAF_OFFSET(node) DECL_LANG_SPECIFIC(node)->caf_offset\n #define GFC_DECL_SAVED_DESCRIPTOR(node) \\\n   (DECL_LANG_SPECIFIC(node)->saved_descriptor)\n+#define GFC_DECL_SCALAR_ALLOCATABLE(node) \\\n+  (DECL_LANG_SPECIFIC (node)->scalar_allocatable)\n+#define GFC_DECL_SCALAR_POINTER(node) \\\n+  (DECL_LANG_SPECIFIC (node)->scalar_pointer)\n+#define GFC_DECL_GET_SCALAR_ALLOCATABLE(node) \\\n+  (DECL_LANG_SPECIFIC (node) ? GFC_DECL_SCALAR_ALLOCATABLE (node) : 0)\n+#define GFC_DECL_GET_SCALAR_POINTER(node) \\\n+  (DECL_LANG_SPECIFIC (node) ? GFC_DECL_SCALAR_POINTER (node) : 0)\n #define GFC_DECL_PACKED_ARRAY(node) DECL_LANG_FLAG_0(node)\n #define GFC_DECL_PARTIAL_PACKED_ARRAY(node) DECL_LANG_FLAG_1(node)\n #define GFC_DECL_ASSIGN(node) DECL_LANG_FLAG_2(node)\n #define GFC_DECL_COMMON_OR_EQUIV(node) DECL_LANG_FLAG_3(node)\n #define GFC_DECL_CRAY_POINTEE(node) DECL_LANG_FLAG_4(node)\n #define GFC_DECL_RESULT(node) DECL_LANG_FLAG_5(node)\n #define GFC_DECL_SUBREF_ARRAY_P(node) DECL_LANG_FLAG_6(node)\n+#define GFC_DECL_ASSOCIATE_VAR_P(node) DECL_LANG_FLAG_7(node)\n #define GFC_DECL_CLASS(node) DECL_LANG_FLAG_8(node)\n \n /* An array descriptor.  */\n #define GFC_DESCRIPTOR_TYPE_P(node) TYPE_LANG_FLAG_1(node)\n /* An array without a descriptor.  */\n #define GFC_ARRAY_TYPE_P(node) TYPE_LANG_FLAG_2(node)\n-/* Fortran POINTER type.  */\n-#define GFC_POINTER_TYPE_P(node) TYPE_LANG_FLAG_3(node)\n /* Fortran CLASS type.  */\n #define GFC_CLASS_TYPE_P(node) TYPE_LANG_FLAG_4(node)\n /* The GFC_TYPE_ARRAY_* members are present in both descriptor and"}, {"sha": "ddb049d3ea180915da4b4028e7b0e43dba533543", "filename": "gcc/omp-low.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -3110,6 +3110,13 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  if (pass != 0)\n \t\t    continue;\n \t\t}\n+\t      /* Even without corresponding firstprivate, if\n+\t\t decl is Fortran allocatable, it needs outer var\n+\t\t reference.  */\n+\t      else if (pass == 0\n+\t\t       && lang_hooks.decls.omp_private_outer_ref\n+\t\t\t\t\t\t\t(OMP_CLAUSE_DECL (c)))\n+\t\tlastprivate_firstprivate = true;\n \t      break;\n \t    case OMP_CLAUSE_ALIGNED:\n \t      if (pass == 0)\n@@ -3545,7 +3552,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  else if (is_reference (var) && is_simd)\n \t\t    handle_simd_reference (clause_loc, new_vard, ilist);\n \t\t  x = lang_hooks.decls.omp_clause_default_ctor\n-\t\t\t\t(c, new_var, unshare_expr (x));\n+\t\t\t\t(c, unshare_expr (new_var),\n+\t\t\t\t build_outer_var_ref (var, ctx));\n \t\t  if (x)\n \t\t    gimplify_and_add (x, ilist);\n \t\t  if (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c))"}, {"sha": "b8a164983fbba4f5c8651f196bd789cb7319a884", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -1,3 +1,15 @@\n+2014-06-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/60928\n+\t* gfortran.dg/gomp/allocatable_components_1.f90: Remove dg-error\n+\tdirectives.\n+\t* gfortran.dg/gomp/associate1.f90: New test.\n+\t* gfortran.dg/gomp/intentin1.f90: New test.\n+\t* gfortran.dg/gomp/openmp-simd-1.f90: New test.\n+\t* gfortran.dg/gomp/openmp-simd-2.f90: New test.\n+\t* gfortran.dg/gomp/openmp-simd-3.f90: New test.\n+\t* gfortran.dg/gomp/proc_ptr_2.f90: New test.\n+\n 2014-06-09  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/36446"}, {"sha": "bc06cc8662ccabbdd1964b65602f7e5a7c8e0d8c", "filename": "gcc/testsuite/gfortran.dg/gomp/allocatable_components_1.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocatable_components_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocatable_components_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocatable_components_1.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -14,23 +14,23 @@ SUBROUTINE test_copyin()\n     TYPE(t), SAVE :: a\n \n     !$omp threadprivate(a)\n-    !$omp parallel copyin(a)        ! { dg-error \"has ALLOCATABLE components\" }\n+    !$omp parallel copyin(a)\n       ! do something\n     !$omp end parallel\n   END SUBROUTINE\n \n   SUBROUTINE test_copyprivate()\n     TYPE(t) :: a\n \n-    !$omp single                    ! { dg-error \"has ALLOCATABLE components\" }\n+    !$omp single\n       ! do something\n     !$omp end single copyprivate (a)\n   END SUBROUTINE\n \n   SUBROUTINE test_firstprivate\n     TYPE(t) :: a\n \n-    !$omp parallel firstprivate(a)  ! { dg-error \"has ALLOCATABLE components\" }\n+    !$omp parallel firstprivate(a)\n       ! do something\n     !$omp end parallel\n   END SUBROUTINE\n@@ -39,7 +39,7 @@ SUBROUTINE test_lastprivate\n     TYPE(t) :: a\n     INTEGER :: i\n \n-    !$omp parallel do lastprivate(a)  ! { dg-error \"has ALLOCATABLE components\" }\n+    !$omp parallel do lastprivate(a)\n       DO i = 1, 1\n       END DO\n     !$omp end parallel do"}, {"sha": "abc5ae95a0d1c55de3fdd1c4b31af35f119cac4b", "filename": "gcc/testsuite/gfortran.dg/gomp/associate1.f90", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassociate1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassociate1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fassociate1.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,83 @@\n+! { dg-do compile }\n+\n+program associate1\n+  type dl\n+    integer :: i\n+  end type\n+  type dt\n+    integer :: i\n+    real :: a(3, 3)\n+    type(dl) :: c(3, 3)\n+  end type\n+  integer :: v, i, j\n+  real :: a(3, 3)\n+  type(dt) :: b(3)\n+  i = 1\n+  j = 2\n+  associate(k => v, l => a(i, j), m => a(i, :))\n+  associate(n => b(j)%c(:, :)%i, o => a, p => b)\n+!$omp parallel shared (l)\t! { dg-error \"ASSOCIATE name\" }\n+!$omp end parallel\n+!$omp parallel firstprivate (m)\t! { dg-error \"ASSOCIATE name\" }\n+!$omp end parallel\n+!$omp parallel reduction (+: k)\t! { dg-error \"ASSOCIATE name\" }\n+!$omp end parallel\n+!$omp parallel do firstprivate (k)\t! { dg-error \"ASSOCIATE name\" }\n+  do i = 1, 10\n+  end do\n+!$omp parallel do lastprivate (n)\t! { dg-error \"ASSOCIATE name\" }\n+  do i = 1, 10\n+  end do\n+!$omp parallel do private (o)\t! { dg-error \"ASSOCIATE name\" }\n+  do i = 1, 10\n+  end do\n+!$omp parallel do shared (p)\t! { dg-error \"ASSOCIATE name\" }\n+  do i = 1, 10\n+  end do\n+!$omp task private (k)\t\t! { dg-error \"ASSOCIATE name\" }\n+!$omp end task\n+!$omp task shared (l)\t\t! { dg-error \"ASSOCIATE name\" }\n+!$omp end task\n+!$omp task firstprivate (m)\t! { dg-error \"ASSOCIATE name\" }\n+!$omp end task\n+!$omp do private (l)\t\t! { dg-error \"ASSOCIATE name\" }\n+  do i = 1, 10\n+  end do\n+!$omp do reduction (*: k)\t! { dg-error \"ASSOCIATE name\" }\n+  do i = 1, 10\n+  end do\n+!$omp sections private(o)\t! { dg-error \"ASSOCIATE name\" }\n+!$omp section\n+!$omp section\n+!$omp end sections\n+!$omp parallel sections firstprivate(p)\t! { dg-error \"ASSOCIATE name\" }\n+!$omp section\n+!$omp section\n+!$omp endparallelsections\n+!$omp parallelsections lastprivate(m)\t! { dg-error \"ASSOCIATE name\" }\n+!$omp section\n+!$omp section\n+!$omp endparallelsections\n+!$omp sections reduction(+:k)\t! { dg-error \"ASSOCIATE name\" }\n+!$omp section\n+!$omp section\n+!$omp end sections\n+!$omp simd private (l)\t\t! { dg-error \"ASSOCIATE name\" }\n+  do i = 1, 10\n+  end do\n+  k = 1\n+!$omp simd lastprivate (m)\t! { dg-error \"ASSOCIATE name\" }\n+  do i = 1, 10\n+  end do\n+  k = 1\n+!$omp simd reduction (+: k)\t! { dg-error \"ASSOCIATE name\" }\n+  do i = 1, 10\n+  end do\n+  k = 1\n+!$omp simd linear (k : 2)\t! { dg-error \"ASSOCIATE name\" }\n+  do i = 1, 10\n+    k = k + 2\n+  end do\n+  end associate\n+  end associate\n+end program"}, {"sha": "f2a2e98fd7615d46a61a9d9861b0a7d7dda16a95", "filename": "gcc/testsuite/gfortran.dg/gomp/intentin1.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fintentin1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fintentin1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fintentin1.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+\n+subroutine foo (x)\n+  integer, pointer, intent (in) :: x\n+  integer :: i\n+!$omp parallel private (x)\t\t! { dg-error \"INTENT.IN. POINTER\" }\n+!$omp end parallel\n+!$omp parallel do lastprivate (x)\t! { dg-error \"INTENT.IN. POINTER\" }\n+  do i = 1, 10\n+  end do\n+!$omp simd linear (x)\t\t\t! { dg-error \"INTENT.IN. POINTER\" }\n+  do i = 1, 10\n+  end do\n+!$omp single\t\t\t\t! { dg-error \"INTENT.IN. POINTER\" }\n+!$omp end single copyprivate (x)\n+end"}, {"sha": "c9ce70c4f442ecc4f7d721462811609bde0c6efa", "filename": "gcc/testsuite/gfortran.dg/gomp/openmp-simd-1.f90", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fopenmp-simd-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fopenmp-simd-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fopenmp-simd-1.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,137 @@\n+! { dg-do compile }\n+! { dg-options \"-fno-openmp -fopenmp-simd -fdump-tree-original -O2\" }\n+\n+!$omp declare reduction (foo:integer:omp_out = omp_out + omp_in)\n+  interface\n+    integer function foo (x, y)\n+      integer, value :: x, y\n+!$omp declare simd (foo) linear (y : 2)\n+    end function foo\n+  end interface\n+  integer :: i, a(64), b, c\n+  integer, save :: d\n+!$omp threadprivate (d)\n+  d = 5\n+  a = 6\n+!$omp simd\n+  do i = 1, 64\n+    a(i) = foo (a(i), 2 * i)\n+  end do\n+  b = 0\n+  c = 0\n+!$omp simd reduction (+:b) reduction (foo:c)\n+  do i = 1, 64\n+    b = b + a(i)\n+    c = c + a(i) * 2\n+  end do\n+  print *, b\n+  b = 0\n+!$omp parallel\n+!$omp do simd schedule(static, 4) safelen (8) reduction (+:b)\n+  do i = 1, 64\n+    a(i) = a(i) + 1\n+    b = b + 1\n+  end do\n+!$omp end parallel\n+  print *, b\n+  b = 0\n+!$omp parallel do simd schedule(static, 4) safelen (8) &\n+!$omp num_threads (4) if (.true.) reduction (+:b)\n+  do i = 1, 64\n+    a(i) = a(i) + 1\n+    b = b + 1\n+  end do\n+  print *, b\n+  b = 0\n+!$omp parallel\n+!$omp do simd schedule(static, 4) safelen (8) reduction (+:b)\n+  do i = 1, 64\n+    a(i) = a(i) + 1\n+    b = b + 1\n+  end do\n+!$omp enddosimd\n+!$omp end parallel\n+  print *, b\n+  b = 0\n+!$omp parallel do simd schedule(static, 4) safelen (8) &\n+!$omp num_threads (4) if (.true.) reduction (+:b)\n+  do i = 1, 64\n+    a(i) = a(i) + 1\n+    b = b + 1\n+  end do\n+!$omp end parallel do simd\n+!$omp atomic seq_cst\n+  b = b + 1\n+!$omp end atomic\n+!$omp barrier\n+!$omp parallel private (i)\n+!$omp cancellation point parallel\n+!$omp critical (bar)\n+  b = b + 1\n+!$omp end critical (bar)\n+!$omp flush(b)\n+!$omp single\n+  b = b + 1\n+!$omp end single\n+!$omp do ordered\n+  do i = 1, 10\n+    !$omp atomic\n+    b = b + 1\n+    !$omp end atomic\n+    !$omp ordered\n+      print *, b\n+    !$omp end ordered\n+  end do\n+!$omp end do\n+!$omp master\n+  b = b + 1\n+!$omp end master\n+!$omp cancel parallel\n+!$omp end parallel\n+!$omp parallel do schedule(runtime) num_threads(8)\n+  do i = 1, 10\n+    print *, b\n+  end do\n+!$omp end parallel do\n+!$omp sections\n+!$omp section\n+  b = b + 1\n+!$omp section\n+  c = c + 1\n+!$omp end sections\n+  print *, b\n+!$omp parallel sections firstprivate (b) if (.true.)\n+!$omp section\n+  b = b + 1\n+!$omp section\n+  c = c + 1\n+!$omp endparallelsections\n+!$omp workshare\n+  b = 24\n+!$omp end workshare\n+!$omp parallel workshare num_threads (2)\n+  b = b + 1\n+  c = c + 1\n+!$omp end parallel workshare\n+  print *, b\n+!$omp parallel\n+!$omp single\n+!$omp taskgroup\n+!$omp task firstprivate (b)\n+  b = b + 1\n+!$omp taskyield\n+!$omp end task\n+!$omp task firstprivate (b)\n+  b = b + 1\n+!$omp end task\n+!$omp taskwait\n+!$omp end taskgroup\n+!$omp end single\n+!$omp end parallel\n+  print *, a, c\n+end\n+\n+! { dg-final { scan-tree-dump-times \"pragma omp simd\" 6 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp\" 6 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "4b2046a58cc7b27dfb3304bc5c70c4828fdff02d", "filename": "gcc/testsuite/gfortran.dg/gomp/openmp-simd-2.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fopenmp-simd-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fopenmp-simd-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fopenmp-simd-2.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp -fopenmp-simd -fdump-tree-original -O2\" }\n+\n+include 'openmp-simd-1.f90'\n+\n+! { dg-final { scan-tree-dump-times \"pragma omp simd\" 6 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp\" 39 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp for\" 6 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp parallel\" 9 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp taskgroup\" 1 \"original\" } }\n+! Includes the above taskgroup\n+! { dg-final { scan-tree-dump-times \"pragma omp task\" 3 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp critical\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp atomic\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp sections\" 2 \"original\" } }\n+! Includes the above sections\n+! { dg-final { scan-tree-dump-times \"pragma omp section\" 6 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp single\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp ordered\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp master\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP\" 5 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP_barrier\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP_cancellation_point\" 1 \"original\" } }\n+! Includes the above cancellation point\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP_cancel\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP_taskyield\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP_taskwait\" 1 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "2dece895f390b44d3a8f5efff6a07e07fa1d65b7", "filename": "gcc/testsuite/gfortran.dg/gomp/openmp-simd-3.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fopenmp-simd-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fopenmp-simd-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fopenmp-simd-3.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp -fno-openmp-simd -fdump-tree-original -O2\" }\n+\n+include 'openmp-simd-1.f90'\n+\n+! { dg-final { scan-tree-dump-times \"pragma omp simd\" 6 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp\" 39 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp for\" 6 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp parallel\" 9 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp taskgroup\" 1 \"original\" } }\n+! Includes the above taskgroup\n+! { dg-final { scan-tree-dump-times \"pragma omp task\" 3 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp critical\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp atomic\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp sections\" 2 \"original\" } }\n+! Includes the above sections\n+! { dg-final { scan-tree-dump-times \"pragma omp section\" 6 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp single\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp ordered\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp master\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP\" 5 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP_barrier\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP_cancellation_point\" 1 \"original\" } }\n+! Includes the above cancellation point\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP_cancel\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP_taskyield\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP_taskwait\" 1 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "d993429a76f88fa4cff6580ded1852f90766313e", "filename": "gcc/testsuite/gfortran.dg/gomp/proc_ptr_2.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fproc_ptr_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fproc_ptr_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fproc_ptr_2.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+  procedure(foo), pointer :: ptr\n+  integer :: i\n+  ptr => foo\n+!$omp do reduction (+ : ptr)\t! { dg-error \"Procedure pointer|not found\" }\n+  do i = 1, 10\n+  end do\n+!$omp simd linear (ptr)\t\t! { dg-error \"must be INTEGER\" }\n+  do i = 1, 10\n+  end do\n+contains\n+  subroutine foo\n+  end subroutine\n+end"}, {"sha": "8e6d37ae96169de60f339101f4b5c8f6d7831d6c", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -1,3 +1,17 @@\n+2014-06-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/60928\n+\t* testsuite/libgomp.fortran/allocatable9.f90: New test.\n+\t* testsuite/libgomp.fortran/allocatable10.f90: New test.\n+\t* testsuite/libgomp.fortran/allocatable11.f90: New test.\n+\t* testsuite/libgomp.fortran/allocatable12.f90: New test.\n+\t* testsuite/libgomp.fortran/alloc-comp-1.f90: New test.\n+\t* testsuite/libgomp.fortran/alloc-comp-2.f90: New test.\n+\t* testsuite/libgomp.fortran/alloc-comp-3.f90: New test.\n+\t* testsuite/libgomp.fortran/associate1.f90: New test.\n+\t* testsuite/libgomp.fortran/associate2.f90: New test.\n+\t* testsuite/libgomp.fortran/procptr1.f90: New test.\n+\n 2014-06-06  Jakub Jelinek  <jakub@redhat.com>\n \n \t* testsuite/libgomp.fortran/simd1.f90: New test."}, {"sha": "2a2a12ec8171485b4d3ac3dd8f2c6a8781530bac", "filename": "libgomp/testsuite/libgomp.fortran/alloc-comp-1.f90", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-comp-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-comp-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-comp-1.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,328 @@\n+! { dg-do run }\n+! Don't cycle by default through all options, just test -O0 and -O2,\n+! as this is quite large test.\n+! { dg-skip-if \"\" { ! run_expensive_tests } { \"*\" } { \"-O0\" \"-O2\" } }\n+\n+module m\n+  type dl\n+    integer :: a, b\n+    integer, allocatable :: c(:,:)\n+    integer :: d, e\n+    integer, allocatable :: f\n+  end type\n+  type dt\n+    integer :: g\n+    type (dl), allocatable :: h(:)\n+    integer :: i\n+    type (dl) :: j(2, 2)\n+    type (dl), allocatable :: k\n+  end type\n+contains\n+  subroutine ver_dl (obj, val, c, cl1, cu1, cl2, cu2, f)\n+    type (dl), intent (in) :: obj\n+    integer, intent (in) :: val, cl1, cu1, cl2, cu2\n+    logical, intent (in) :: c, f\n+    if ((c .neqv. allocated (obj%c)) .or. (f .neqv. allocated (obj%f))) call abort\n+    if (c) then\n+      if (lbound (obj%c, 1) /= cl1 .or. ubound (obj%c, 1) /= cu1) call abort\n+      if (lbound (obj%c, 2) /= cl2 .or. ubound (obj%c, 2) /= cu2) call abort\n+    end if\n+    if (val /= 0) then\n+      if (obj%a /= val .or. obj%b /= val) call abort\n+      if (obj%d /= val .or. obj%e /= val) call abort\n+      if (c) then\n+        if (any (obj%c /= val)) call abort\n+      end if\n+      if (f) then\n+        if (obj%f /= val) call abort\n+      end if\n+    end if\n+  end subroutine ver_dl\n+  subroutine ver_dt (obj, val, h, hl, hu, k, c, cl1, cu1, cl2, cu2, f)\n+    type (dt), intent (in) :: obj\n+    integer, intent (in) :: val, hl, hu, cl1, cu1, cl2, cu2\n+    logical, intent (in) :: h, k, c, f\n+    integer :: i, j\n+    if ((h .neqv. allocated (obj%h)) .or. (k .neqv. allocated (obj%k))) call abort\n+    if (h) then\n+      if (lbound (obj%h, 1) /= hl .or. ubound (obj%h, 1) /= hu) call abort\n+      do i = hl, hu\n+        call ver_dl (obj%h(i), val, c, cl1, cu1, cl2, cu2, f)\n+      end do\n+    end if\n+    do i = 1, 2\n+      do j = 1, 2\n+        call ver_dl (obj%j(i, j), val, c, cl1, cu1, cl2, cu2, f)\n+      end do\n+    end do\n+    if (k) call ver_dl (obj%k, val, c, cl1, cu1, cl2, cu2, f)\n+    if (val /= 0) then\n+      if (obj%g /= val .or. obj%i /= val) call abort\n+    end if\n+  end subroutine ver_dt\n+  subroutine alloc_dl (obj, val, c, cl1, cu1, cl2, cu2, f)\n+    type (dl), intent (inout) :: obj\n+    integer, intent (in) :: val, cl1, cu1, cl2, cu2\n+    logical, intent (in) :: c, f\n+    if (val /= 0) then\n+      obj%a = val\n+      obj%b = val\n+      obj%d = val\n+      obj%e = val\n+    end if\n+    if (allocated (obj%c)) deallocate (obj%c)\n+    if (c) then\n+      allocate (obj%c(cl1:cu1, cl2:cu2))\n+      if (val /= 0) obj%c = val\n+    end if\n+    if (f) then\n+      if (.not.allocated (obj%f)) allocate (obj%f)\n+      if (val /= 0) obj%f = val\n+    else\n+      if (allocated (obj%f)) deallocate (obj%f)\n+    end if\n+  end subroutine alloc_dl\n+  subroutine alloc_dt (obj, val, h, hl, hu, k, c, cl1, cu1, cl2, cu2, f)\n+    type (dt), intent (inout) :: obj\n+    integer, intent (in) :: val, hl, hu, cl1, cu1, cl2, cu2\n+    logical, intent (in) :: h, k, c, f\n+    integer :: i, j\n+    if (val /= 0) then\n+      obj%g = val\n+      obj%i = val\n+    end if\n+    if (allocated (obj%h)) deallocate (obj%h)\n+    if (h) then\n+      allocate (obj%h(hl:hu))\n+      do i = hl, hu\n+        call alloc_dl (obj%h(i), val, c, cl1, cu1, cl2, cu2, f)\n+      end do\n+    end if\n+    do i = 1, 2\n+      do j = 1, 2\n+        call alloc_dl (obj%j(i, j), val, c, cl1, cu1, cl2, cu2, f)\n+      end do\n+    end do\n+    if (k) then\n+      if (.not.allocated (obj%k)) allocate (obj%k)\n+      call alloc_dl (obj%k, val, c, cl1, cu1, cl2, cu2, f)\n+    else\n+      if (allocated (obj%k)) deallocate (obj%k)\n+    end if\n+  end subroutine alloc_dt\n+end module m\n+  use m\n+  type (dt) :: y\n+  call foo (y)\n+contains\n+  subroutine foo (y)\n+    use m\n+    type (dt) :: x, y, z(-3:-3,2:3)\n+    logical, parameter :: F = .false.\n+    logical, parameter :: T = .true.\n+    logical :: l\n+    call ver_dt (x, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (y, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+!$omp parallel private (x, y, z)\n+    call ver_dt (x, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (y, 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    call ver_dt (y, 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,3), 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+!$omp end parallel\n+    call ver_dt (x, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (y, 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+!$omp parallel private (x, y, z)\n+    call ver_dt (x, 0, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y, 0, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    deallocate (x%h, x%k)\n+    deallocate (y%h)\n+    allocate (y%k)\n+    call ver_dt (z(-3,2), 0, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 0, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    deallocate (z(-3,2)%h, z(-3,2)%k)\n+    deallocate (z(-3,3)%h)\n+    allocate (z(-3,3)%k)\n+!$omp end parallel\n+    call alloc_dt (x, 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (y, 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (z(-3,2), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (z(-3,3), 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+!$omp parallel firstprivate (x, y, z)\n+    call ver_dt (x, 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y, 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (y, 4, T, 3, 4, T, T, 1, 1, 2, 4, T)\n+    call ver_dt (y, 4, T, 3, 4, T, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,2), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (z(-3,3), 4, T, 3, 4, T, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,3), 4, T, 3, 4, T, T, 1, 1, 2, 4, T)\n+!$omp end parallel\n+    call ver_dt (x, 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (x, 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (y, 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (y, 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,2), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (z(-3,2), 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,3), 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (z(-3,3), 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+!$omp parallel firstprivate (x, y, z)\n+    call ver_dt (x, 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y, 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (y, 17, T, 1, 2, F, T, 2, 2, 3, 3, F)\n+    call ver_dt (y, 17, T, 1, 2, F, T, 2, 2, 3, 3, F)\n+    call ver_dt (z(-3,2), 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 17, T, 1, 2, F, T, 2, 2, 3, 3, F)\n+    call ver_dt (z(-3,3), 17, T, 1, 2, F, T, 2, 2, 3, 3, F)\n+!$omp end parallel\n+    call ver_dt (x, 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (y, 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (y, 18, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+    call ver_dt (z(-3,2), 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,3), 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 18, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+    l = F\n+!$omp parallel sections lastprivate (x, y, z) firstprivate (l)\n+!$omp section\n+    if (l) then\n+      call ver_dt (x, 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (y, 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+      call ver_dt (z(-3,2), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (z(-3,3), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    else\n+      call ver_dt (x, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+      call ver_dt (y, 0, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+      call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+      call ver_dt (z(-3,3), 0, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+    end if\n+    l = T\n+    call alloc_dt (x, 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+    call ver_dt (x, 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+    call alloc_dt (y, 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+    call ver_dt (y, 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+    call alloc_dt (z(-3,2), 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+    call ver_dt (z(-3,2), 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+    call alloc_dt (z(-3,3), 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+    call ver_dt (z(-3,3), 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+!$omp section\n+    if (l) then\n+      call ver_dt (x, 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+      call ver_dt (y, 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+      call ver_dt (z(-3,2), 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+      call ver_dt (z(-3,3), 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+    else\n+      call ver_dt (x, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+      call ver_dt (y, 0, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+      call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+      call ver_dt (z(-3,3), 0, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+    end if\n+    l = T\n+    call alloc_dt (x, 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call ver_dt (x, 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call alloc_dt (y, 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    call ver_dt (y, 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    call alloc_dt (z(-3,2), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call ver_dt (z(-3,2), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call alloc_dt (z(-3,3), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    call ver_dt (z(-3,3), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+!$omp section\n+!$omp end parallel sections\n+    call ver_dt (x, 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call ver_dt (y, 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    call ver_dt (z(-3,2), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call ver_dt (z(-3,3), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+!$omp parallel sections lastprivate (x, y, z) firstprivate (l)\n+!$omp section\n+    if (l) then\n+      call ver_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+      call ver_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+      call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+      call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    else\n+      call ver_dt (x, 0, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (y, 0, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+      call ver_dt (z(-3,2), 0, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (z(-3,3), 0, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    end if\n+    l = T\n+    call alloc_dt (x, 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call ver_dt (x, 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call alloc_dt (y, 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call ver_dt (y, 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call alloc_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call ver_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call alloc_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call ver_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+!$omp section\n+    if (l) then\n+      call ver_dt (x, 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+      call ver_dt (y, 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+      call ver_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+      call ver_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    else\n+      call ver_dt (x, 0, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (y, 0, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+      call ver_dt (z(-3,2), 0, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (z(-3,3), 0, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    end if\n+    l = T\n+    call alloc_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call alloc_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call alloc_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call alloc_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+!$omp section\n+!$omp end parallel sections\n+    call ver_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+!$omp parallel private (x, y, z)\n+    call ver_dt (x, 0, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (y, 0, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,2), 0, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,3), 0, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+!$omp single\n+    call alloc_dt (x, 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call alloc_dt (y, 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call alloc_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call alloc_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+!$omp end single copyprivate (x, y, z)\n+    call ver_dt (x, 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call ver_dt (y, 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call ver_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call ver_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+!$omp end parallel\n+    call ver_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+  end subroutine foo\n+end"}, {"sha": "490ed24cf4fa2fe26cdcae43cf5db75e9a1edd4b", "filename": "libgomp/testsuite/libgomp.fortran/alloc-comp-2.f90", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-comp-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-comp-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-comp-2.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,367 @@\n+! { dg-do run }\n+! Don't cycle by default through all options, just test -O0 and -O2,\n+! as this is quite large test.\n+! { dg-skip-if \"\" { ! run_expensive_tests } { \"*\" } { \"-O0\" \"-O2\" } }\n+\n+module m\n+  type dl\n+    integer :: a, b\n+    integer, allocatable :: c(:,:)\n+    integer :: d, e\n+    integer, allocatable :: f\n+  end type\n+  type dt\n+    integer :: g\n+    type (dl), allocatable :: h(:)\n+    integer :: i\n+    type (dl) :: j(2, 2)\n+    type (dl), allocatable :: k\n+  end type\n+contains\n+  subroutine ver_dl (obj, val, c, cl1, cu1, cl2, cu2, f)\n+    type (dl), intent (in) :: obj\n+    integer, intent (in) :: val, cl1, cu1, cl2, cu2\n+    logical, intent (in) :: c, f\n+    if ((c .neqv. allocated (obj%c)) .or. (f .neqv. allocated (obj%f))) call abort\n+    if (c) then\n+      if (lbound (obj%c, 1) /= cl1 .or. ubound (obj%c, 1) /= cu1) call abort\n+      if (lbound (obj%c, 2) /= cl2 .or. ubound (obj%c, 2) /= cu2) call abort\n+    end if\n+    if (val /= 0) then\n+      if (obj%a /= val .or. obj%b /= val) call abort\n+      if (obj%d /= val .or. obj%e /= val) call abort\n+      if (c) then\n+        if (any (obj%c /= val)) call abort\n+      end if\n+      if (f) then\n+        if (obj%f /= val) call abort\n+      end if\n+    end if\n+  end subroutine ver_dl\n+  subroutine ver_dt (obj, val, h, hl, hu, k, c, cl1, cu1, cl2, cu2, f)\n+    type (dt), intent (in) :: obj\n+    integer, intent (in) :: val, hl, hu, cl1, cu1, cl2, cu2\n+    logical, intent (in) :: h, k, c, f\n+    integer :: i, j\n+    if ((h .neqv. allocated (obj%h)) .or. (k .neqv. allocated (obj%k))) call abort\n+    if (h) then\n+      if (lbound (obj%h, 1) /= hl .or. ubound (obj%h, 1) /= hu) call abort\n+      do i = hl, hu\n+        call ver_dl (obj%h(i), val, c, cl1, cu1, cl2, cu2, f)\n+      end do\n+    end if\n+    do i = 1, 2\n+      do j = 1, 2\n+        call ver_dl (obj%j(i, j), val, c, cl1, cu1, cl2, cu2, f)\n+      end do\n+    end do\n+    if (k) call ver_dl (obj%k, val, c, cl1, cu1, cl2, cu2, f)\n+    if (val /= 0) then\n+      if (obj%g /= val .or. obj%i /= val) call abort\n+    end if\n+  end subroutine ver_dt\n+  subroutine alloc_dl (obj, val, c, cl1, cu1, cl2, cu2, f)\n+    type (dl), intent (inout) :: obj\n+    integer, intent (in) :: val, cl1, cu1, cl2, cu2\n+    logical, intent (in) :: c, f\n+    if (val /= 0) then\n+      obj%a = val\n+      obj%b = val\n+      obj%d = val\n+      obj%e = val\n+    end if\n+    if (allocated (obj%c)) deallocate (obj%c)\n+    if (c) then\n+      allocate (obj%c(cl1:cu1, cl2:cu2))\n+      if (val /= 0) obj%c = val\n+    end if\n+    if (f) then\n+      if (.not.allocated (obj%f)) allocate (obj%f)\n+      if (val /= 0) obj%f = val\n+    else\n+      if (allocated (obj%f)) deallocate (obj%f)\n+    end if\n+  end subroutine alloc_dl\n+  subroutine alloc_dt (obj, val, h, hl, hu, k, c, cl1, cu1, cl2, cu2, f)\n+    type (dt), intent (inout) :: obj\n+    integer, intent (in) :: val, hl, hu, cl1, cu1, cl2, cu2\n+    logical, intent (in) :: h, k, c, f\n+    integer :: i, j\n+    if (val /= 0) then\n+      obj%g = val\n+      obj%i = val\n+    end if\n+    if (allocated (obj%h)) deallocate (obj%h)\n+    if (h) then\n+      allocate (obj%h(hl:hu))\n+      do i = hl, hu\n+        call alloc_dl (obj%h(i), val, c, cl1, cu1, cl2, cu2, f)\n+      end do\n+    end if\n+    do i = 1, 2\n+      do j = 1, 2\n+        call alloc_dl (obj%j(i, j), val, c, cl1, cu1, cl2, cu2, f)\n+      end do\n+    end do\n+    if (k) then\n+      if (.not.allocated (obj%k)) allocate (obj%k)\n+      call alloc_dl (obj%k, val, c, cl1, cu1, cl2, cu2, f)\n+    else\n+      if (allocated (obj%k)) deallocate (obj%k)\n+    end if\n+  end subroutine alloc_dt\n+end module m\n+  use m\n+  type (dt), allocatable :: y\n+  call foo (y)\n+contains\n+  subroutine foo (y)\n+    use m\n+    type (dt), allocatable :: x, y, z(:,:)\n+    logical, parameter :: F = .false.\n+    logical, parameter :: T = .true.\n+    logical :: l\n+!$omp parallel private (x, y, z)\n+    if (allocated (x) .or. allocated (y) .or. allocated (z)) call abort\n+!$omp end parallel\n+!$omp parallel firstprivate (x, y, z)\n+    if (allocated (x) .or. allocated (y) .or. allocated (z)) call abort\n+!$omp end parallel\n+    l = F\n+!$omp parallel sections lastprivate (x, y, z) firstprivate (l)\n+!$omp section\n+    if (.not. l) then\n+      if (allocated (x) .or. allocated (y) .or. allocated (z)) call abort\n+    end if\n+!$omp section\n+    if (.not. l) then\n+      if (allocated (x) .or. allocated (y) .or. allocated (z)) call abort\n+    end if\n+    allocate (x, y, z(-3:-3,2:3))\n+    call alloc_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call alloc_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call alloc_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call alloc_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+!$omp section\n+!$omp end parallel sections\n+    if (.not.allocated (x) .or. .not.allocated (y)) call abort\n+    if (.not.allocated (z)) call abort\n+    if (lbound (z, 1) /= -3 .or. ubound (z, 1) /= -3) call abort\n+    if (lbound (z, 2) /= 2 .or. ubound (z, 2) /= 3) call abort\n+    call ver_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call alloc_dt (x, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (x, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (y, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (y, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+!$omp parallel private (x, y, z)\n+    call ver_dt (x, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (y, 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    call ver_dt (y, 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,3), 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+!$omp end parallel\n+    call ver_dt (x, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (y, 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+!$omp parallel private (x, y, z)\n+    call ver_dt (x, 0, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y, 0, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    deallocate (x%h, x%k)\n+    deallocate (y%h)\n+    allocate (y%k)\n+    call ver_dt (z(-3,2), 0, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 0, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    deallocate (z(-3,2)%h, z(-3,2)%k)\n+    deallocate (z(-3,3)%h)\n+    allocate (z(-3,3)%k)\n+!$omp end parallel\n+    call alloc_dt (x, 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (y, 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (z(-3,2), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (z(-3,3), 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+!$omp parallel firstprivate (x, y, z)\n+    call ver_dt (x, 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y, 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (y, 4, T, 3, 4, T, T, 1, 1, 2, 4, T)\n+    call ver_dt (y, 4, T, 3, 4, T, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,2), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (z(-3,3), 4, T, 3, 4, T, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,3), 4, T, 3, 4, T, T, 1, 1, 2, 4, T)\n+!$omp end parallel\n+    call ver_dt (x, 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (x, 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (y, 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (y, 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,2), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (z(-3,2), 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,3), 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (z(-3,3), 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+!$omp parallel firstprivate (x, y, z)\n+    call ver_dt (x, 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (x, 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y, 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (y, 17, T, 1, 2, F, T, 2, 2, 3, 3, F)\n+    call ver_dt (y, 17, T, 1, 2, F, T, 2, 2, 3, 3, F)\n+    call ver_dt (z(-3,2), 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 17, T, 1, 2, F, T, 2, 2, 3, 3, F)\n+    call ver_dt (z(-3,3), 17, T, 1, 2, F, T, 2, 2, 3, 3, F)\n+!$omp end parallel\n+    call ver_dt (x, 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (y, 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (y, 18, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+    call ver_dt (z(-3,2), 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,3), 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 18, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+    l = F\n+!$omp parallel sections lastprivate (x, y, z) firstprivate (l)\n+!$omp section\n+    if (l) then\n+      call ver_dt (x, 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (y, 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+      call ver_dt (z(-3,2), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (z(-3,3), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    else\n+      call ver_dt (x, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+      call ver_dt (y, 0, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+      call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+      call ver_dt (z(-3,3), 0, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+    end if\n+    l = T\n+    call alloc_dt (x, 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+    call ver_dt (x, 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+    call alloc_dt (y, 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+    call ver_dt (y, 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+    call alloc_dt (z(-3,2), 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+    call ver_dt (z(-3,2), 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+    call alloc_dt (z(-3,3), 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+    call ver_dt (z(-3,3), 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+!$omp section\n+    if (l) then\n+      call ver_dt (x, 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+      call ver_dt (y, 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+      call ver_dt (z(-3,2), 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+      call ver_dt (z(-3,3), 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+    else\n+      call ver_dt (x, 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+      call ver_dt (y, 0, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+      call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+      call ver_dt (z(-3,3), 0, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+    end if\n+    l = T\n+    call alloc_dt (x, 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call ver_dt (x, 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call alloc_dt (y, 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    call ver_dt (y, 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    call alloc_dt (z(-3,2), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call ver_dt (z(-3,2), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call alloc_dt (z(-3,3), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    call ver_dt (z(-3,3), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+!$omp section\n+!$omp end parallel sections\n+    call ver_dt (x, 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call ver_dt (y, 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    call ver_dt (z(-3,2), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call ver_dt (z(-3,3), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+!$omp parallel sections lastprivate (x, y, z) firstprivate (l)\n+!$omp section\n+    if (l) then\n+      call ver_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+      call ver_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+      call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+      call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    else\n+      call ver_dt (x, 0, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (y, 0, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+      call ver_dt (z(-3,2), 0, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (z(-3,3), 0, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    end if\n+    l = T\n+    call alloc_dt (x, 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call ver_dt (x, 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call alloc_dt (y, 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call ver_dt (y, 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call alloc_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call ver_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call alloc_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call ver_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+!$omp section\n+    if (l) then\n+      call ver_dt (x, 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+      call ver_dt (y, 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+      call ver_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+      call ver_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    else\n+      call ver_dt (x, 0, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (y, 0, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+      call ver_dt (z(-3,2), 0, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (z(-3,3), 0, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    end if\n+    l = T\n+    call alloc_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call alloc_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call alloc_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call alloc_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+!$omp section\n+!$omp end parallel sections\n+    call ver_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+!$omp parallel private (x, y, z)\n+    call ver_dt (x, 0, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (y, 0, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,2), 0, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,3), 0, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+!$omp single\n+    call alloc_dt (x, 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call alloc_dt (y, 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call alloc_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call alloc_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+!$omp end single copyprivate (x, y, z)\n+    call ver_dt (x, 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call ver_dt (y, 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call ver_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call ver_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+!$omp end parallel\n+    call ver_dt (x, 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (y, 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+  end subroutine foo\n+end"}, {"sha": "20f13144a62e285f27f4091b81d3e2e574dc3e42", "filename": "libgomp/testsuite/libgomp.fortran/alloc-comp-3.f90", "status": "added", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-comp-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-comp-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-comp-3.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,372 @@\n+! { dg-do run }\n+! Don't cycle by default through all options, just test -O0 and -O2,\n+! as this is quite large test.\n+! { dg-skip-if \"\" { ! run_expensive_tests } { \"*\" } { \"-O0\" \"-O2\" } }\n+\n+module m\n+  type dl\n+    integer :: a, b\n+    integer, allocatable :: c(:,:)\n+    integer :: d, e\n+    integer, allocatable :: f\n+  end type\n+  type dt\n+    integer :: g\n+    type (dl), allocatable :: h(:)\n+    integer :: i\n+    type (dl) :: j(2, 2)\n+    type (dl), allocatable :: k\n+  end type\n+contains\n+  subroutine ver_dl (obj, val, c, cl1, cu1, cl2, cu2, f)\n+    type (dl), intent (in) :: obj\n+    integer, intent (in) :: val, cl1, cu1, cl2, cu2\n+    logical, intent (in) :: c, f\n+    if ((c .neqv. allocated (obj%c)) .or. (f .neqv. allocated (obj%f))) call abort\n+    if (c) then\n+      if (lbound (obj%c, 1) /= cl1 .or. ubound (obj%c, 1) /= cu1) call abort\n+      if (lbound (obj%c, 2) /= cl2 .or. ubound (obj%c, 2) /= cu2) call abort\n+    end if\n+    if (val /= 0) then\n+      if (obj%a /= val .or. obj%b /= val) call abort\n+      if (obj%d /= val .or. obj%e /= val) call abort\n+      if (c) then\n+        if (any (obj%c /= val)) call abort\n+      end if\n+      if (f) then\n+        if (obj%f /= val) call abort\n+      end if\n+    end if\n+  end subroutine ver_dl\n+  subroutine ver_dt (obj, val, h, hl, hu, k, c, cl1, cu1, cl2, cu2, f)\n+    type (dt), intent (in) :: obj\n+    integer, intent (in) :: val, hl, hu, cl1, cu1, cl2, cu2\n+    logical, intent (in) :: h, k, c, f\n+    integer :: i, j\n+    if ((h .neqv. allocated (obj%h)) .or. (k .neqv. allocated (obj%k))) call abort\n+    if (h) then\n+      if (lbound (obj%h, 1) /= hl .or. ubound (obj%h, 1) /= hu) call abort\n+      do i = hl, hu\n+        call ver_dl (obj%h(i), val, c, cl1, cu1, cl2, cu2, f)\n+      end do\n+    end if\n+    do i = 1, 2\n+      do j = 1, 2\n+        call ver_dl (obj%j(i, j), val, c, cl1, cu1, cl2, cu2, f)\n+      end do\n+    end do\n+    if (k) call ver_dl (obj%k, val, c, cl1, cu1, cl2, cu2, f)\n+    if (val /= 0) then\n+      if (obj%g /= val .or. obj%i /= val) call abort\n+    end if\n+  end subroutine ver_dt\n+  subroutine alloc_dl (obj, val, c, cl1, cu1, cl2, cu2, f)\n+    type (dl), intent (inout) :: obj\n+    integer, intent (in) :: val, cl1, cu1, cl2, cu2\n+    logical, intent (in) :: c, f\n+    if (val /= 0) then\n+      obj%a = val\n+      obj%b = val\n+      obj%d = val\n+      obj%e = val\n+    end if\n+    if (allocated (obj%c)) deallocate (obj%c)\n+    if (c) then\n+      allocate (obj%c(cl1:cu1, cl2:cu2))\n+      if (val /= 0) obj%c = val\n+    end if\n+    if (f) then\n+      if (.not.allocated (obj%f)) allocate (obj%f)\n+      if (val /= 0) obj%f = val\n+    else\n+      if (allocated (obj%f)) deallocate (obj%f)\n+    end if\n+  end subroutine alloc_dl\n+  subroutine alloc_dt (obj, val, h, hl, hu, k, c, cl1, cu1, cl2, cu2, f)\n+    type (dt), intent (inout) :: obj\n+    integer, intent (in) :: val, hl, hu, cl1, cu1, cl2, cu2\n+    logical, intent (in) :: h, k, c, f\n+    integer :: i, j\n+    if (val /= 0) then\n+      obj%g = val\n+      obj%i = val\n+    end if\n+    if (allocated (obj%h)) deallocate (obj%h)\n+    if (h) then\n+      allocate (obj%h(hl:hu))\n+      do i = hl, hu\n+        call alloc_dl (obj%h(i), val, c, cl1, cu1, cl2, cu2, f)\n+      end do\n+    end if\n+    do i = 1, 2\n+      do j = 1, 2\n+        call alloc_dl (obj%j(i, j), val, c, cl1, cu1, cl2, cu2, f)\n+      end do\n+    end do\n+    if (k) then\n+      if (.not.allocated (obj%k)) allocate (obj%k)\n+      call alloc_dl (obj%k, val, c, cl1, cu1, cl2, cu2, f)\n+    else\n+      if (allocated (obj%k)) deallocate (obj%k)\n+    end if\n+  end subroutine alloc_dt\n+end module m\n+  use m\n+  type (dt), allocatable :: z(:,:)\n+  type (dt) :: y(2:3)\n+  call foo (y, z, 4)\n+contains\n+  subroutine foo (y, z, n)\n+    use m\n+    integer :: n\n+    type (dt) :: x(2:n), y(3:)\n+    type (dt), allocatable :: z(:,:)\n+    logical, parameter :: F = .false.\n+    logical, parameter :: T = .true.\n+    logical :: l\n+    if (lbound (x, 1) /= 2 .or. ubound (x, 1) /= 4) call abort\n+    if (lbound (y, 1) /= 3 .or. ubound (y, 1) /= 4) call abort\n+    call ver_dt (x(2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (x(n), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (y(3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (y(4), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+!$omp parallel private (z)\n+    if (allocated (z)) call abort\n+!$omp end parallel\n+!$omp parallel firstprivate (z)\n+    if (allocated (z)) call abort\n+!$omp end parallel\n+    l = F\n+!$omp parallel sections lastprivate (z) firstprivate (l)\n+!$omp section\n+    if (.not. l) then\n+      if (allocated (z)) call abort\n+    end if\n+!$omp section\n+    if (.not. l) then\n+      if (allocated (z)) call abort\n+    end if\n+    allocate (z(-3:-3,2:3))\n+    call alloc_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call alloc_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+!$omp section\n+!$omp end parallel sections\n+    if (.not.allocated (z)) call abort\n+    if (lbound (z, 1) /= -3 .or. ubound (z, 1) /= -3) call abort\n+    if (lbound (z, 2) /= 2 .or. ubound (z, 2) /= 3) call abort\n+    call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (x(n - 1), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (y(4), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+!$omp parallel private (x, y, z)\n+    call ver_dt (x(n - 1), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (x(n - 1), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (x(n - 1), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y(4), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (y(4), 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    call ver_dt (y(4), 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,3), 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+!$omp end parallel\n+    call ver_dt (x(n - 1), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (x(n - 1), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y(4), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (y(4), 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 14, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+!$omp parallel private (x, y, z)\n+    call ver_dt (x(n - 1), 0, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y(4), 0, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    deallocate (x(n - 1)%h, x(n - 1)%k)\n+    deallocate (y(4)%h)\n+    allocate (y(4)%k)\n+    call ver_dt (z(-3,2), 0, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 0, T, 3, 4, F, T, 1, 1, 2, 4, T)\n+    deallocate (z(-3,2)%h, z(-3,2)%k)\n+    deallocate (z(-3,3)%h)\n+    allocate (z(-3,3)%k)\n+!$omp end parallel\n+    call alloc_dt (x(n - 1), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (y(4), 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (z(-3,2), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (z(-3,3), 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+!$omp parallel firstprivate (x, y, z)\n+    if (lbound (x, 1) /= 2 .or. ubound (x, 1) /= 4) call abort\n+    if (lbound (y, 1) /= 3 .or. ubound (y, 1) /= 4) call abort\n+    call ver_dt (x(n - 1), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (x(n - 1), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (x(n - 1), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y(4), 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (y(4), 4, T, 3, 4, T, T, 1, 1, 2, 4, T)\n+    call ver_dt (y(4), 4, T, 3, 4, T, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,2), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (z(-3,3), 4, T, 3, 4, T, T, 1, 1, 2, 4, T)\n+    call ver_dt (z(-3,3), 4, T, 3, 4, T, T, 1, 1, 2, 4, T)\n+!$omp end parallel\n+    call ver_dt (x(n - 1), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (x(n - 1), 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (y(4), 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (y(4), 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,2), 5, T, 1, 2, F, T, 2, 3, -2, -2, F)\n+    call alloc_dt (z(-3,2), 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,3), 15, F, 0, 0, T, T, 2, 2, 2, 2, T)\n+    call alloc_dt (z(-3,3), 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+!$omp parallel firstprivate (x, y, z)\n+    call ver_dt (x(n - 1), 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (x(n - 1), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (x(n - 1), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (y(4), 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (y(4), 17, T, 1, 2, F, T, 2, 2, 3, 3, F)\n+    call ver_dt (y(4), 17, T, 1, 2, F, T, 2, 2, 3, 3, F)\n+    call ver_dt (z(-3,2), 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,2), 4, T, -3, -1, T, T, -1, -1, 2, 3, T)\n+    call ver_dt (z(-3,3), 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 17, T, 1, 2, F, T, 2, 2, 3, 3, F)\n+    call ver_dt (z(-3,3), 17, T, 1, 2, F, T, 2, 2, 3, 3, F)\n+!$omp end parallel\n+    call ver_dt (x(n - 1), 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (y(4), 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (y(4), 18, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+    call ver_dt (z(-3,2), 4, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (z(-3,3), 16, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call alloc_dt (z(-3,3), 18, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+    l = F\n+!$omp parallel sections lastprivate (x, y, z) firstprivate (l)\n+!$omp section\n+    if (l) then\n+      call ver_dt (x(n - 1), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (y(4), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+      call ver_dt (z(-3,2), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (z(-3,3), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    else\n+      call ver_dt (x(n - 1), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+      call ver_dt (y(4), 0, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+      call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+      call ver_dt (z(-3,3), 0, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+    end if\n+    l = T\n+    call alloc_dt (x(n - 1), 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+    call ver_dt (x(n - 1), 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+    call alloc_dt (y(4), 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+    call ver_dt (y(4), 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+    call alloc_dt (z(-3,2), 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+    call ver_dt (z(-3,2), 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+    call alloc_dt (z(-3,3), 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+    call ver_dt (z(-3,3), 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+!$omp section\n+    if (l) then\n+      call ver_dt (x(n - 1), 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+      call ver_dt (y(4), 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+      call ver_dt (z(-3,2), 7, T, 1, 1, T, T, 1, 2, 3, 3, T)\n+      call ver_dt (z(-3,3), 20, T, 0, 0, F, T, 2, 2, 3, 4, F)\n+    else\n+      call ver_dt (x(n - 1), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+      call ver_dt (y(4), 0, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+      call ver_dt (z(-3,2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+      call ver_dt (z(-3,3), 0, T, 0, 1, T, T, 0, 1, 0, 1, T)\n+    end if\n+    l = T\n+    call alloc_dt (x(n - 1), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call ver_dt (x(n - 1), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call alloc_dt (y(4), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    call ver_dt (y(4), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    call alloc_dt (z(-3,2), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call ver_dt (z(-3,2), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call alloc_dt (z(-3,3), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    call ver_dt (z(-3,3), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+!$omp section\n+!$omp end parallel sections\n+    call ver_dt (x(n - 1), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call ver_dt (y(4), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    call ver_dt (z(-3,2), 9, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+    call ver_dt (z(-3,3), 21, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+!$omp parallel sections lastprivate (x, y, z) firstprivate (l)\n+!$omp section\n+    if (l) then\n+      call ver_dt (x(n - 1), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+      call ver_dt (y(4), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+      call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+      call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    else\n+      call ver_dt (x(n - 1), 0, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (y(4), 0, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+      call ver_dt (z(-3,2), 0, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (z(-3,3), 0, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    end if\n+    l = T\n+    call alloc_dt (x(n - 1), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call ver_dt (x(n - 1), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call alloc_dt (y(4), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call ver_dt (y(4), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call alloc_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call ver_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call alloc_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call ver_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+!$omp section\n+    if (l) then\n+      call ver_dt (x(n - 1), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+      call ver_dt (y(4), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+      call ver_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+      call ver_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    else\n+      call ver_dt (x(n - 1), 0, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (y(4), 0, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+      call ver_dt (z(-3,2), 0, T, 1, 1, F, F, 0, 0, 0, 0, T)\n+      call ver_dt (z(-3,3), 0, F, 0, 0, T, T, 1, 2, 3, 4, T)\n+    end if\n+    l = T\n+    call alloc_dt (x(n - 1), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (x(n - 1), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call alloc_dt (y(4), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (y(4), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call alloc_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call alloc_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+!$omp section\n+!$omp end parallel sections\n+    call ver_dt (x(n - 1), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (y(4), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+!$omp parallel private (x, y, z)\n+    call ver_dt (x(n - 1), 0, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (y(4), 0, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,2), 0, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,3), 0, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+!$omp single\n+    call alloc_dt (x(n - 1), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call alloc_dt (y(4), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call alloc_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call alloc_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+!$omp end single copyprivate (x, y, z)\n+    call ver_dt (x(n - 1), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call ver_dt (y(4), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+    call ver_dt (z(-3,2), 3, F, 0, 0, T, T, 0, 1, 0, 1, F)\n+    call ver_dt (z(-3,3), 22, T, 5, 5, F, T, 2, 3, 2, 2, T)\n+!$omp end parallel\n+    call ver_dt (x(n - 1), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (y(4), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (z(-3,2), 5, F, 0, 0, T, T, -1, -1, -1, -1, T)\n+    call ver_dt (z(-3,3), 23, T, 0, 1, T, T, 2, 2, 2, 2, F)\n+    call ver_dt (x(2), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (x(n), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+    call ver_dt (y(3), 0, F, 0, 0, F, F, 0, 0, 0, 0, F)\n+  end subroutine foo\n+end"}, {"sha": "54eed617b458e4570f2df7eb7450514a5dbeb71f", "filename": "libgomp/testsuite/libgomp.fortran/allocatable10.f90", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable10.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,112 @@\n+! { dg-do run }\n+\n+  integer, allocatable :: a, b(:), c(:,:)\n+  integer :: i\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in) &\n+!$omp & initializer (omp_priv = 0)\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+  allocate (a, b(6:9), c(3, 8:9))\n+  a = 0\n+  b = 0\n+  c = 0\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 4) call abort\n+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+  if (.not.allocated (c) .or. size (c) /= 6) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+!$omp parallel do reduction (+:a, b, c)\n+  do i = 1, 10\n+    if (.not.allocated (a)) call abort\n+    if (.not.allocated (b) .or. size (b) /= 4) call abort\n+    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+    if (.not.allocated (c) .or. size (c) /= 6) call abort\n+    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+    a = a + i\n+    b = b + 2 * i\n+    c = c + 3 * i\n+  end do\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 4) call abort\n+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+  if (.not.allocated (c) .or. size (c) /= 6) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+  if (a /= 55 .or. any (b /= 110) .or. any (c /= 165)) call abort\n+  a = 0\n+  b = 0\n+  c = 0\n+!$omp parallel do reduction (foo : a, b, c)\n+  do i = 1, 10\n+    if (.not.allocated (a)) call abort\n+    if (.not.allocated (b) .or. size (b) /= 4) call abort\n+    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+    if (.not.allocated (c) .or. size (c) /= 6) call abort\n+    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+    a = a + i\n+    b = b + 2 * i\n+    c = c + 3 * i\n+  end do\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 4) call abort\n+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+  if (.not.allocated (c) .or. size (c) /= 6) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+  if (a /= 55 .or. any (b /= 110) .or. any (c /= 165)) call abort\n+  a = 0\n+  b = 0\n+  c = 0\n+!$omp simd reduction (+:a, b, c)\n+  do i = 1, 10\n+    if (.not.allocated (a)) call abort\n+    if (.not.allocated (b) .or. size (b) /= 4) call abort\n+    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+    if (.not.allocated (c) .or. size (c) /= 6) call abort\n+    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+    a = a + i\n+    b = b + 2 * i\n+    c = c + 3 * i\n+  end do\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 4) call abort\n+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+  if (.not.allocated (c) .or. size (c) /= 6) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+  if (a /= 55 .or. any (b /= 110) .or. any (c /= 165)) call abort\n+  a = 0\n+  b = 0\n+  c = 0\n+!$omp simd reduction (foo : a, b, c)\n+  do i = 1, 10\n+    if (.not.allocated (a)) call abort\n+    if (.not.allocated (b) .or. size (b) /= 4) call abort\n+    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+    if (.not.allocated (c) .or. size (c) /= 6) call abort\n+    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+    a = a + i\n+    b = b + 2 * i\n+    c = c + 3 * i\n+  end do\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 4) call abort\n+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+  if (.not.allocated (c) .or. size (c) /= 6) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+  if (a /= 55 .or. any (b /= 110) .or. any (c /= 165)) call abort\n+end"}, {"sha": "479f6041b7d8506075177692efc451c3421bb953", "filename": "libgomp/testsuite/libgomp.fortran/allocatable11.f90", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable11.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,72 @@\n+! { dg-do run }\n+! { dg-require-effective-target tls_runtime }\n+\n+  use omp_lib\n+  integer, allocatable, save :: a, b(:), c(:,:)\n+  integer :: p\n+!$omp threadprivate (a, b, c)\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+\n+  call omp_set_dynamic (.false.)\n+  call omp_set_num_threads (4)\n+\n+!$omp parallel num_threads (4)\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+!$omp end parallel\n+\n+  allocate (a, b(6:9), c(3, 8:9))\n+  a = 4\n+  b = 5\n+  c = 6\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 4) call abort\n+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+  if (.not.allocated (c) .or. size (c) /= 6) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+\n+!$omp parallel num_threads (4) copyin (a, b, c) private (p)\n+  p = omp_get_thread_num ()\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 4) call abort\n+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+  if (.not.allocated (c) .or. size (c) /= 6) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+  if (a /= 4 .or. any (b /= 5) .or. any (c /= 6)) call abort\n+  deallocate (a, b, c)\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+  allocate (a, b(p:9), c(3, p:7))\n+  a = p\n+  b = p\n+  c = p\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= (10 - p)) call abort\n+  if (lbound (b, 1) /= p .or. ubound (b, 1) /= 9) call abort\n+  if (.not.allocated (c) .or. size (c) /= (3 * (8 - p))) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= (8 - p)) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= p .or. ubound (c, 2) /= 7) call abort\n+  if (a /= p .or. any (b /= p) .or. any (c /= p)) call abort\n+!$omp end parallel\n+\n+!$omp parallel num_threads (4) copyin (a, b, c)\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 10) call abort\n+  if (lbound (b, 1) /= 0 .or. ubound (b, 1) /= 9) call abort\n+  if (.not.allocated (c) .or. size (c) /= 24) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 8) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 0 .or. ubound (c, 2) /= 7) call abort\n+  if (a /= 0 .or. any (b /= 0) .or. any (c /= 0)) call abort\n+!$omp end parallel\n+\n+  deallocate (a, b, c)\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+\n+!$omp parallel num_threads (4) copyin (a, b, c)\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+!$omp end parallel\n+end"}, {"sha": "533ab7cd85d9debfcc5e165d5a981d395847079e", "filename": "libgomp/testsuite/libgomp.fortran/allocatable12.f90", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable12.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,74 @@\n+! { dg-do run }\n+\n+  integer, allocatable :: a, b(:), c(:,:)\n+  logical :: l\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+\n+!$omp parallel private (a, b, c, l)\n+  l = .false.\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+\n+!$omp single\n+  allocate (a, b(6:9), c(3, 8:9))\n+  a = 4\n+  b = 5\n+  c = 6\n+!$omp end single copyprivate (a, b, c)\n+\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 4) call abort\n+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+  if (.not.allocated (c) .or. size (c) /= 6) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+  if (a /= 4 .or. any (b /= 5) .or. any (c /= 6)) call abort\n+\n+!$omp single\n+  deallocate (a, b, c)\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+  allocate (a, b(0:4), c(3, 2:7))\n+  a = 1\n+  b = 2\n+  c = 3\n+!$omp end single copyprivate (a, b, c)\n+\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 5) call abort\n+  if (lbound (b, 1) /= 0 .or. ubound (b, 1) /= 4) call abort\n+  if (.not.allocated (c) .or. size (c) /= 18) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 6) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 2 .or. ubound (c, 2) /= 7) call abort\n+  if (a /= 1 .or. any (b /= 2) .or. any (c /= 3)) call abort\n+\n+!$omp single\n+  l = .true.\n+  deallocate (a, b, c)\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+  allocate (a, b(2:6), c(3:5, 3:8))\n+  a = 7\n+  b = 8\n+  c = 9\n+!$omp end single copyprivate (a, b, c)\n+\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 5) call abort\n+  if (l) then\n+    if (lbound (b, 1) /= 2 .or. ubound (b, 1) /= 6) call abort\n+  else\n+    if (lbound (b, 1) /= 0 .or. ubound (b, 1) /= 4) call abort\n+  end if\n+  if (.not.allocated (c) .or. size (c) /= 18) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 6) call abort\n+  if (l) then\n+    if (lbound (c, 1) /= 3 .or. ubound (c, 1) /= 5) call abort\n+    if (lbound (c, 2) /= 3 .or. ubound (c, 2) /= 8) call abort\n+  else\n+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+    if (lbound (c, 2) /= 2 .or. ubound (c, 2) /= 7) call abort\n+  end if\n+  if (a /= 7 .or. any (b /= 8) .or. any (c /= 9)) call abort\n+\n+!$omp end parallel\n+end"}, {"sha": "80bf5d389f3d264774c559bc045e39818f20d80d", "filename": "libgomp/testsuite/libgomp.fortran/allocatable9.f90", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable9.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,156 @@\n+! { dg-do run }\n+\n+  integer, allocatable :: a, b(:), c(:,:)\n+  logical :: l\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+!$omp parallel private (a, b, c)\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+  allocate (a, b(-7:-1), c(2:3, 3:5))\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 7) call abort\n+  if (lbound (b, 1) /= -7 .or. ubound (b, 1) /= -1) call abort\n+  if (.not.allocated (c) .or. size (c) /= 6) call abort\n+  if (size (c, 1) /= 2 .or. size (c, 2) /= 3) call abort\n+  if (lbound (c, 1) /= 2 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 3 .or. ubound (c, 2) /= 5) call abort\n+  a = 4\n+  b = 3\n+  c = 2\n+!$omp end parallel\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+!$omp parallel firstprivate (a, b, c)\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+  allocate (a, b(-7:-1), c(2:3, 3:5))\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 7) call abort\n+  if (lbound (b, 1) /= -7 .or. ubound (b, 1) /= -1) call abort\n+  if (.not.allocated (c) .or. size (c) /= 6) call abort\n+  if (size (c, 1) /= 2 .or. size (c, 2) /= 3) call abort\n+  if (lbound (c, 1) /= 2 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 3 .or. ubound (c, 2) /= 5) call abort\n+  a = 4\n+  b = 3\n+  c = 2\n+!$omp end parallel\n+  if (allocated (a) .or. allocated (b) .or. allocated (c)) call abort\n+  allocate (a, b(6:9), c(3, 8:9))\n+  a = 2\n+  b = 4\n+  c = 5\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 4) call abort\n+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+  if (.not.allocated (c) .or. size (c) /= 6) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+!$omp parallel firstprivate (a, b, c)\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 4) call abort\n+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+  if (.not.allocated (c) .or. size (c) /= 6) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+  if (a /= 2 .or. any (b .ne. 4) .or. any (c .ne. 5)) call abort\n+  deallocate (a)\n+  if (allocated (a)) call abort\n+  allocate (a)\n+  a = 8\n+  b = (/ 1, 2, 3 /)\n+  c = reshape ((/ 1, 2, 3, 4, 5, 6, 7, 8 /), (/ 2, 4 /))\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 3) call abort\n+  if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 3) call abort\n+  if (.not.allocated (c) .or. size (c) /= 8) call abort\n+  if (size (c, 1) /= 2 .or. size (c, 2) /= 4) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 2) call abort\n+  if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 4) call abort\n+  if (a /= 8 .or. b(2) /= 2 .or. c(1, 2) /= 3) call abort\n+!$omp end parallel\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 4) call abort\n+  if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+  if (.not.allocated (c) .or. size (c) /= 6) call abort\n+  if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+  if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+  if (a /= 2 .or. any (b .ne. 4) .or. any (c .ne. 5)) call abort\n+  l = .false.\n+!$omp parallel sections lastprivate (a, b, c) firstprivate (l)\n+!$omp section\n+  if (.not.allocated (a)) call abort\n+  if (l) then\n+    if (.not.allocated (b) .or. size (b) /= 6) call abort\n+    if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 6) call abort\n+    if (.not.allocated (c) .or. size (c) /= 8) call abort\n+    if (size (c, 1) /= 4 .or. size (c, 2) /= 2) call abort\n+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 4) call abort\n+    if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 2) call abort\n+    if (a /= 12 .or. b(2) /= 8 .or. c(1, 2) /= 5) call abort\n+  else\n+    if (.not.allocated (b) .or. size (b) /= 4) call abort\n+    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+    if (.not.allocated (c) .or. size (c) /= 6) call abort\n+    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+  end if\n+  l = .true.\n+  deallocate (a)\n+  if (allocated (a)) call abort\n+  allocate (a)\n+  a = 8\n+  b = (/ 1, 2, 3 /)\n+  c = reshape ((/ 1, 2, 3, 4, 5, 6, 7, 8 /), (/ 2, 4 /))\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 3) call abort\n+  if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 3) call abort\n+  if (.not.allocated (c) .or. size (c) /= 8) call abort\n+  if (size (c, 1) /= 2 .or. size (c, 2) /= 4) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 2) call abort\n+  if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 4) call abort\n+  if (a /= 8 .or. b(2) /= 2 .or. c(1, 2) /= 3) call abort\n+!$omp section\n+  if (.not.allocated (a)) call abort\n+  if (l) then\n+    if (.not.allocated (b) .or. size (b) /= 3) call abort\n+    if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 3) call abort\n+    if (.not.allocated (c) .or. size (c) /= 8) call abort\n+    if (size (c, 1) /= 2 .or. size (c, 2) /= 4) call abort\n+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 2) call abort\n+    if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 4) call abort\n+    if (a /= 8 .or. b(2) /= 2 .or. c(1, 2) /= 3) call abort\n+  else\n+    if (.not.allocated (b) .or. size (b) /= 4) call abort\n+    if (lbound (b, 1) /= 6 .or. ubound (b, 1) /= 9) call abort\n+    if (.not.allocated (c) .or. size (c) /= 6) call abort\n+    if (size (c, 1) /= 3 .or. size (c, 2) /= 2) call abort\n+    if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 3) call abort\n+    if (lbound (c, 2) /= 8 .or. ubound (c, 2) /= 9) call abort\n+  end if\n+  l = .true.\n+  deallocate (a)\n+  if (allocated (a)) call abort\n+  allocate (a)\n+  a = 12\n+  b = (/ 9, 8, 7, 6, 5, 4 /)\n+  c = reshape ((/ 1, 2, 3, 4, 5, 6, 7, 8 /), (/ 4, 2 /))\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 6) call abort\n+  if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 6) call abort\n+  if (.not.allocated (c) .or. size (c) /= 8) call abort\n+  if (size (c, 1) /= 4 .or. size (c, 2) /= 2) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 4) call abort\n+  if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 2) call abort\n+  if (a /= 12 .or. b(2) /= 8 .or. c(1, 2) /= 5) call abort\n+!$omp end parallel sections\n+  if (.not.allocated (a)) call abort\n+  if (.not.allocated (b) .or. size (b) /= 6) call abort\n+  if (lbound (b, 1) /= 1 .or. ubound (b, 1) /= 6) call abort\n+  if (.not.allocated (c) .or. size (c) /= 8) call abort\n+  if (size (c, 1) /= 4 .or. size (c, 2) /= 2) call abort\n+  if (lbound (c, 1) /= 1 .or. ubound (c, 1) /= 4) call abort\n+  if (lbound (c, 2) /= 1 .or. ubound (c, 2) /= 2) call abort\n+  if (a /= 12 .or. b(2) /= 8 .or. c(1, 2) /= 5) call abort\n+end"}, {"sha": "e40995515d8e0c19ffea7bcaab5351dcc9d252c4", "filename": "libgomp/testsuite/libgomp.fortran/associate1.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fassociate1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fassociate1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fassociate1.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+\n+program associate1\n+  integer :: v, i, j\n+  real :: a(3, 3)\n+  v = 15\n+  a = 4.5\n+  a(2,1) = 3.5\n+  i = 2\n+  j = 1\n+  associate(u => v, b => a(i, j))\n+!$omp parallel private(v, a) default(none)\n+  v = -1\n+  a = 2.5\n+  if (v /= -1 .or. u /= 15) call abort\n+  if (a(2,1) /= 2.5 .or. b /= 3.5) call abort\n+  associate(u => v, b => a(2, 1))\n+  if (u /= -1 .or. b /= 2.5) call abort\n+  end associate\n+  if (u /= 15 .or. b /= 3.5) call abort\n+!$omp end parallel\n+  end associate\n+end program"}, {"sha": "dee8496e1d7d11a1331a021ef4db920990ad8865", "filename": "libgomp/testsuite/libgomp.fortran/associate2.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fassociate2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fassociate2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fassociate2.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do run }\n+\n+program associate2\n+  type dl\n+    integer :: i\n+  end type\n+  type dt\n+    integer :: i\n+    real :: a(3, 3)\n+    type(dl) :: c(3, 3)\n+  end type\n+  integer :: v(4), i, j, k, l\n+  type (dt) :: a(3, 3)\n+  v = 15\n+  forall (k = 1:3, l = 1:3) a(k, l)%a(:,:) = 4.5\n+  a(2,1)%a(1,2) = 3.5\n+  i = 2\n+  j = 1\n+  associate(u => v, b => a(i, j)%a)\n+!$omp parallel private(v, a) default(none)\n+  v = -1\n+  forall (k = 1:3, l = 1:3) a(k, l)%a(:,:) = 2.5\n+  if (v(3) /= -1 .or. u(3) /= 15) call abort\n+  if (a(2,1)%a(1,2) /= 2.5 .or. b(1,2) /= 3.5) call abort\n+  associate(u => v, b => a(2, 1)%a)\n+  if (u(3) /= -1 .or. b(1,2) /= 2.5) call abort\n+  end associate\n+  if (u(3) /= 15 .or. b(1,2) /= 3.5) call abort\n+!$omp end parallel\n+  end associate\n+  forall (k = 1:3, l = 1:3) a(k, l)%c(:,:)%i = 7\n+  a(1,2)%c(2,1)%i = 9\n+  i = 1\n+  j = 2\n+  associate(d => a(i, j)%c(2,:)%i)\n+!$omp parallel private(a) default(none)\n+  forall (k = 1:3, l = 1:3) a(k, l)%c(:,:)%i = 15\n+  if (a(1,2)%c(2,1)%i /= 15 .or. d(1) /= 9) call abort\n+  if (a(1,2)%c(2,2)%i /= 15 .or. d(2) /= 7) call abort\n+  associate(d => a(2,1)%c(2,:)%i)\n+  if (d(1) /= 15 .or. d(2) /= 15) call abort\n+  end associate\n+  if (d(1) /= 9 .or. d(2) /= 7) call abort\n+!$omp end parallel\n+  end associate\n+end program"}, {"sha": "4187739826facd55715a170b5ca5016b673a18d7", "filename": "libgomp/testsuite/libgomp.fortran/procptr1.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fprocptr1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d28cbb59cc5a611af41342c5b224fbf779a44d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fprocptr1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fprocptr1.f90?ref=92d28cbb59cc5a611af41342c5b224fbf779a44d", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+  interface\n+    integer function foo ()\n+    end function\n+    integer function bar ()\n+    end function\n+    integer function baz ()\n+    end function\n+  end interface\n+  procedure(foo), pointer :: ptr\n+  integer :: i\n+  ptr => foo\n+!$omp parallel shared (ptr)\n+  if (ptr () /= 1) call abort\n+!$omp end parallel\n+  ptr => bar\n+!$omp parallel firstprivate (ptr)\n+  if (ptr () /= 2) call abort\n+!$omp end parallel\n+!$omp parallel sections lastprivate (ptr)\n+!$omp section\n+  ptr => foo\n+  if (ptr () /= 1) call abort\n+!$omp section\n+  ptr => bar\n+  if (ptr () /= 2) call abort\n+!$omp section\n+  ptr => baz\n+  if (ptr () /= 3) call abort\n+!$omp end parallel sections\n+  if (ptr () /= 3) call abort\n+  if (.not.associated (ptr, baz)) call abort\n+end\n+integer function foo ()\n+  foo = 1\n+end function\n+integer function bar ()\n+  bar = 2\n+end function\n+integer function baz ()\n+  baz = 3\n+end function"}]}