{"sha": "958448a9441ee54e012c67cfc3cf88083f3d0e4a", "node_id": "C_kwDOANBUbNoAKDk1ODQ0OGE5NDQxZWU1NGUwMTJjNjdjZmMzY2Y4ODA4M2YzZDBlNGE", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-02-09T16:57:03Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-02-09T16:57:03Z"}, "message": "aarch64: Generalise adjacency check for load_pair_lanes\n\nThis patch generalises the load_pair_lanes<mode> guard so that\nit uses aarch64_check_consecutive_mems to check for consecutive\nmems.  It also allows the pattern to be used for STRICT_ALIGNMENT\ntargets if the alignment is high enough.\n\nThe main aim is to avoid an inline test, for the sake of a later patch\nthat needs to repeat it.  Reusing aarch64_check_consecutive_mems seemed\nsimpler than writing an entirely new function.\n\ngcc/\n\t* config/aarch64/aarch64-protos.h (aarch64_mergeable_load_pair_p):\n\tDeclare.\n\t* config/aarch64/aarch64-simd.md (load_pair_lanes<mode>): Use\n\taarch64_mergeable_load_pair_p instead of inline check.\n\t* config/aarch64/aarch64.cc (aarch64_expand_vector_init): Likewise.\n\t(aarch64_check_consecutive_mems): Allow the reversed parameter\n\tto be null.\n\t(aarch64_mergeable_load_pair_p): New function.", "tree": {"sha": "2c19072e5faf07112e08d9e0fd8145080812cc27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c19072e5faf07112e08d9e0fd8145080812cc27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/958448a9441ee54e012c67cfc3cf88083f3d0e4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/958448a9441ee54e012c67cfc3cf88083f3d0e4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/958448a9441ee54e012c67cfc3cf88083f3d0e4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/958448a9441ee54e012c67cfc3cf88083f3d0e4a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fabc5d9bceb0aec8db2147eb50ae375c711eea90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabc5d9bceb0aec8db2147eb50ae375c711eea90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fabc5d9bceb0aec8db2147eb50ae375c711eea90"}], "stats": {"total": 86, "additions": 62, "deletions": 24}, "files": [{"sha": "b75ed35635bcb74ae5ff1fff381002746939927a", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/958448a9441ee54e012c67cfc3cf88083f3d0e4a/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/958448a9441ee54e012c67cfc3cf88083f3d0e4a/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=958448a9441ee54e012c67cfc3cf88083f3d0e4a", "patch": "@@ -1000,6 +1000,7 @@ void aarch64_atomic_assign_expand_fenv (tree *, tree *, tree *);\n int aarch64_ccmp_mode_to_code (machine_mode mode);\n \n bool extract_base_offset_in_addr (rtx mem, rtx *base, rtx *offset);\n+bool aarch64_mergeable_load_pair_p (machine_mode, rtx, rtx);\n bool aarch64_operands_ok_for_ldpstp (rtx *, bool, machine_mode);\n bool aarch64_operands_adjust_ok_for_ldpstp (rtx *, bool, machine_mode);\n void aarch64_swap_ldrstr_operands (rtx *, bool);"}, {"sha": "c5bc2ea658bcdbd5d8e31cb9cd4c5dd274fa630a", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/958448a9441ee54e012c67cfc3cf88083f3d0e4a/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/958448a9441ee54e012c67cfc3cf88083f3d0e4a/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=958448a9441ee54e012c67cfc3cf88083f3d0e4a", "patch": "@@ -4353,11 +4353,8 @@\n \t(vec_concat:<VDBL>\n \t   (match_operand:VDC 1 \"memory_operand\" \"Utq\")\n \t   (match_operand:VDC 2 \"memory_operand\" \"m\")))]\n-  \"TARGET_SIMD && !STRICT_ALIGNMENT\n-   && rtx_equal_p (XEXP (operands[2], 0),\n-\t\t   plus_constant (Pmode,\n-\t\t\t\t  XEXP (operands[1], 0),\n-\t\t\t\t  GET_MODE_SIZE (<MODE>mode)))\"\n+  \"TARGET_SIMD\n+   && aarch64_mergeable_load_pair_p (<VDBL>mode, operands[1], operands[2])\"\n   \"ldr\\\\t%q0, %1\"\n   [(set_attr \"type\" \"neon_load1_1reg_q\")]\n )"}, {"sha": "c47543aebf31dbb1dbf7706d5b06380a63407e67", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/958448a9441ee54e012c67cfc3cf88083f3d0e4a/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/958448a9441ee54e012c67cfc3cf88083f3d0e4a/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=958448a9441ee54e012c67cfc3cf88083f3d0e4a", "patch": "@@ -21063,11 +21063,7 @@ aarch64_expand_vector_init (rtx target, rtx vals)\n \t\t for store_pair_lanes<mode>.  */\n \t      if (memory_operand (x0, inner_mode)\n \t\t  && memory_operand (x1, inner_mode)\n-\t\t  && !STRICT_ALIGNMENT\n-\t\t  && rtx_equal_p (XEXP (x1, 0),\n-\t\t\t\t  plus_constant (Pmode,\n-\t\t\t\t\t\t XEXP (x0, 0),\n-\t\t\t\t\t\t GET_MODE_SIZE (inner_mode))))\n+\t\t  && aarch64_mergeable_load_pair_p (mode, x0, x1))\n \t\t{\n \t\t  rtx t;\n \t\t  if (inner_mode == DFmode)\n@@ -24687,14 +24683,20 @@ aarch64_sched_adjust_priority (rtx_insn *insn, int priority)\n   return priority;\n }\n \n-/* Check if *MEM1 and *MEM2 are consecutive memory references and,\n+/* If REVERSED is null, return true if memory reference *MEM2 comes\n+   immediately after memory reference *MEM1.  Do not change the references\n+   in this case.\n+\n+   Otherwise, check if *MEM1 and *MEM2 are consecutive memory references and,\n    if they are, try to make them use constant offsets from the same base\n    register.  Return true on success.  When returning true, set *REVERSED\n    to true if *MEM1 comes after *MEM2, false if *MEM1 comes before *MEM2.  */\n static bool\n aarch64_check_consecutive_mems (rtx *mem1, rtx *mem2, bool *reversed)\n {\n-  *reversed = false;\n+  if (reversed)\n+    *reversed = false;\n+\n   if (GET_RTX_CLASS (GET_CODE (XEXP (*mem1, 0))) == RTX_AUTOINC\n       || GET_RTX_CLASS (GET_CODE (XEXP (*mem2, 0))) == RTX_AUTOINC)\n     return false;\n@@ -24723,7 +24725,7 @@ aarch64_check_consecutive_mems (rtx *mem1, rtx *mem2, bool *reversed)\n       if (known_eq (UINTVAL (offset1) + size1, UINTVAL (offset2)))\n \treturn true;\n \n-      if (known_eq (UINTVAL (offset2) + size2, UINTVAL (offset1)))\n+      if (known_eq (UINTVAL (offset2) + size2, UINTVAL (offset1)) && reversed)\n \t{\n \t  *reversed = true;\n \t  return true;\n@@ -24756,29 +24758,43 @@ aarch64_check_consecutive_mems (rtx *mem1, rtx *mem2, bool *reversed)\n \n       if (known_eq (expr_offset1 + size1, expr_offset2))\n \t;\n-      else if (known_eq (expr_offset2 + size2, expr_offset1))\n+      else if (known_eq (expr_offset2 + size2, expr_offset1) && reversed)\n \t*reversed = true;\n       else\n \treturn false;\n \n-      if (base2)\n+      if (reversed)\n \t{\n-\t  rtx addr1 = plus_constant (Pmode, XEXP (*mem2, 0),\n-\t\t\t\t     expr_offset1 - expr_offset2);\n-\t  *mem1 = replace_equiv_address_nv (*mem1, addr1);\n-\t}\n-      else\n-\t{\n-\t  rtx addr2 = plus_constant (Pmode, XEXP (*mem1, 0),\n-\t\t\t\t     expr_offset2 - expr_offset1);\n-\t  *mem2 = replace_equiv_address_nv (*mem2, addr2);\n+\t  if (base2)\n+\t    {\n+\t      rtx addr1 = plus_constant (Pmode, XEXP (*mem2, 0),\n+\t\t\t\t\t expr_offset1 - expr_offset2);\n+\t      *mem1 = replace_equiv_address_nv (*mem1, addr1);\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx addr2 = plus_constant (Pmode, XEXP (*mem1, 0),\n+\t\t\t\t\t expr_offset2 - expr_offset1);\n+\t      *mem2 = replace_equiv_address_nv (*mem2, addr2);\n+\t    }\n \t}\n       return true;\n     }\n \n   return false;\n }\n \n+/* Return true if MEM1 and MEM2 can be combined into a single access\n+   of mode MODE, with the combined access having the same address as MEM1.  */\n+\n+bool\n+aarch64_mergeable_load_pair_p (machine_mode mode, rtx mem1, rtx mem2)\n+{\n+  if (STRICT_ALIGNMENT && MEM_ALIGN (mem1) < GET_MODE_ALIGNMENT (mode))\n+    return false;\n+  return aarch64_check_consecutive_mems (&mem1, &mem2, nullptr);\n+}\n+\n /* Given OPERANDS of consecutive load/store, check if we can merge\n    them into ldp/stp.  LOAD is true if they are load instructions.\n    MODE is the mode of memory operands.  */"}, {"sha": "964501574987b901055c53b85f4f8dea4e260cc1", "filename": "gcc/testsuite/gcc.target/aarch64/vec-init-6.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/958448a9441ee54e012c67cfc3cf88083f3d0e4a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/958448a9441ee54e012c67cfc3cf88083f3d0e4a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-6.c?ref=958448a9441ee54e012c67cfc3cf88083f3d0e4a", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+#include <arm_neon.h>\n+\n+int64_t s64[2];\n+float64_t f64[2];\n+\n+int64x2_t test_s64() { return (int64x2_t) { s64[0], s64[1] }; }\n+float64x2_t test_f64() { return (float64x2_t) { f64[0], f64[1] }; }\n+\n+/* { dg-final { scan-assembler-not {\\tins\\t} } } */"}, {"sha": "795895286db96189d5728c2dc6dc305d7b5e732f", "filename": "gcc/testsuite/gcc.target/aarch64/vec-init-7.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/958448a9441ee54e012c67cfc3cf88083f3d0e4a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/958448a9441ee54e012c67cfc3cf88083f3d0e4a/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvec-init-7.c?ref=958448a9441ee54e012c67cfc3cf88083f3d0e4a", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mstrict-align\" } */\n+\n+#include <arm_neon.h>\n+\n+int64_t s64[2] __attribute__((aligned(16)));\n+float64_t f64[2] __attribute__((aligned(16)));\n+\n+int64x2_t test_s64() { return (int64x2_t) { s64[0], s64[1] }; }\n+float64x2_t test_f64() { return (float64x2_t) { f64[0], f64[1] }; }\n+\n+/* { dg-final { scan-assembler-not {\\tins\\t} } } */"}]}