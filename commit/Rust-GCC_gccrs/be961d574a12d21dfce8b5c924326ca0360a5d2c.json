{"sha": "be961d574a12d21dfce8b5c924326ca0360a5d2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU5NjFkNTc0YTEyZDIxZGZjZThiNWM5MjQzMjZjYTAzNjBhNWQyYw==", "commit": {"author": {"name": "Magnus Fromreide", "email": "magfr@lysator.liu.se", "date": "2000-04-24T17:31:57Z"}, "committer": {"name": "Martin v. L\u00f6wis", "email": "loewis@gcc.gnu.org", "date": "2000-04-24T17:31:57Z"}, "message": "sstream: New file.\n\n\t* sstream: New file.\n\t* Makefile.in (HEADERS): Add it.\n\nFrom-SVN: r33380", "tree": {"sha": "677c80215a0ebb771b83ecf2b53f823b7c15b2b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/677c80215a0ebb771b83ecf2b53f823b7c15b2b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be961d574a12d21dfce8b5c924326ca0360a5d2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be961d574a12d21dfce8b5c924326ca0360a5d2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be961d574a12d21dfce8b5c924326ca0360a5d2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be961d574a12d21dfce8b5c924326ca0360a5d2c/comments", "author": {"login": "magfr", "id": 38747965, "node_id": "MDQ6VXNlcjM4NzQ3OTY1", "avatar_url": "https://avatars.githubusercontent.com/u/38747965?v=4", "gravatar_id": "", "url": "https://api.github.com/users/magfr", "html_url": "https://github.com/magfr", "followers_url": "https://api.github.com/users/magfr/followers", "following_url": "https://api.github.com/users/magfr/following{/other_user}", "gists_url": "https://api.github.com/users/magfr/gists{/gist_id}", "starred_url": "https://api.github.com/users/magfr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/magfr/subscriptions", "organizations_url": "https://api.github.com/users/magfr/orgs", "repos_url": "https://api.github.com/users/magfr/repos", "events_url": "https://api.github.com/users/magfr/events{/privacy}", "received_events_url": "https://api.github.com/users/magfr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a2702aa12b7eb800ad0bc344f7c541c605358d84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2702aa12b7eb800ad0bc344f7c541c605358d84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2702aa12b7eb800ad0bc344f7c541c605358d84"}], "stats": {"total": 233, "additions": 232, "deletions": 1}, "files": [{"sha": "0ee8cfae86f0d34ee6f473a070bab65cff36876f", "filename": "libstdc++/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be961d574a12d21dfce8b5c924326ca0360a5d2c/libstdc%2B%2B%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be961d574a12d21dfce8b5c924326ca0360a5d2c/libstdc%2B%2B%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2FChangeLog?ref=be961d574a12d21dfce8b5c924326ca0360a5d2c", "patch": "@@ -1,3 +1,8 @@\n+2000-04-24  Magnus Fromreide  <magfr@lysator.liu.se>\n+\n+\t* sstream: New file.\n+\t* Makefile.in (HEADERS): Add it.\n+\n 2000-03-29  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* configure.in: -linux-gnu*, not -linux-gnu."}, {"sha": "28222cd7a4bef4a4abf146211e5f1cad6431cdf8", "filename": "libstdc++/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be961d574a12d21dfce8b5c924326ca0360a5d2c/libstdc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be961d574a12d21dfce8b5c924326ca0360a5d2c/libstdc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2FMakefile.in?ref=be961d574a12d21dfce8b5c924326ca0360a5d2c", "patch": "@@ -28,7 +28,8 @@ HEADERS= cassert cctype cerrno cfloat ciso646 climits clocale cmath complex \\\n \t cwchar cwctype string stdexcept \\\n \t algorithm deque functional hash_map hash_set iterator list map \\\n \t memory numeric pthread_alloc queue rope set slist stack utility \\\n-\t vector fstream iomanip iostream strstream iosfwd bitset valarray\n+\t vector fstream iomanip iostream strstream iosfwd bitset valarray \\\n+\t sstream\n \n ARLIB   = libstdc++.a.$(VERSION)\n ARLINK  = libstdc++.a"}, {"sha": "714be717e5071b8a7de2f36036ad1e1ceefbbc0b", "filename": "libstdc++/sstream", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be961d574a12d21dfce8b5c924326ca0360a5d2c/libstdc%2B%2B%2Fsstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be961d574a12d21dfce8b5c924326ca0360a5d2c/libstdc%2B%2B%2Fsstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fsstream?ref=be961d574a12d21dfce8b5c924326ca0360a5d2c", "patch": "@@ -0,0 +1,225 @@\n+/* This is part of libio/iostream, providing -*- C++ -*- input/output.\r\n+Copyright (C) 2000 Free Software Foundation\r\n+\r\n+This file is part of the GNU IO Library.  This library is free\r\n+software; you can redistribute it and/or modify it under the\r\n+terms of the GNU General Public License as published by the\r\n+Free Software Foundation; either version 2, or (at your option)\r\n+any later version.\r\n+\r\n+This library is distributed in the hope that it will be useful,\r\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n+GNU General Public License for more details.\r\n+\r\n+You should have received a copy of the GNU General Public License\r\n+along with this library; see the file COPYING.  If not, write to the Free\r\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\r\n+\r\n+As a special exception, if you link this library with files\r\n+compiled with a GNU compiler to produce an executable, this does not cause\r\n+the resulting executable to be covered by the GNU General Public License.\r\n+This exception does not however invalidate any other reasons why\r\n+the executable file might be covered by the GNU General Public License. */\r\n+\r\n+/* Written by Magnus Fromreide (magfr@lysator.liu.se). */\r\n+\r\n+#ifndef __SSTREAM__\r\n+#define __SSTREAM__\r\n+\r\n+#include <string>\r\n+#include <iostream.h>\r\n+#include <streambuf.h>\r\n+\r\n+namespace std\r\n+{\r\n+  class stringbuf : public streambuf\r\n+  {\r\n+  public:\r\n+    typedef char\tchar_type;\r\n+    typedef int\t\tint_type;\r\n+    typedef streampos\tpos_type;\r\n+    typedef streamoff\toff_type;\r\n+\r\n+    explicit stringbuf(int which=ios::in|ios::out) :\r\n+      streambuf(which), buf(), mode(static_cast<ios::open_mode>(which)),\r\n+      rpos(0), bufsize(1)\r\n+    { }\r\n+\t\r\n+    explicit stringbuf(const std::string &s, int which=ios::in|ios::out) :\r\n+      streambuf(which), buf(s), mode(static_cast<ios::open_mode>(which)),\r\n+      bufsize(1)\r\n+    {\r\n+      if(mode & ios::in)\r\n+\t{\r\n+\t  setg(&defbuf, &defbuf + bufsize, &defbuf + bufsize);\r\n+\t}\r\n+      if(mode & ios::out)\r\n+\t{\r\n+\t  setp(&defbuf, &defbuf + bufsize);\r\n+\t}\r\n+      rpos = (mode & ios::ate ? s.size() : 0);\r\n+    }\r\n+\t\r\n+    std::string str() const\r\n+    {\r\n+      const_cast<stringbuf*>(this)->sync();  // Sigh, really ugly hack\r\n+      return buf;\r\n+    };\r\n+\r\n+    void str(const std::string& s)\r\n+    {\r\n+      buf = s;\r\n+      if(mode & ios::in)\r\n+\t{\r\n+\t  gbump(egptr() - gptr());\r\n+\t}\r\n+      if(mode & ios::out)\r\n+\t{\r\n+\t  pbump(pbase() - pptr());\r\n+\t}\r\n+      rpos = (mode & ios::ate ? s.size() : 0);\r\n+    }\r\n+\r\n+  protected:\r\n+    inline virtual int sync();\r\n+    inline virtual int overflow(int = EOF);\r\n+    inline virtual int underflow();\r\n+  private:\r\n+    std::string\t\t\tbuf;\r\n+    ios::open_mode\t\tmode;\r\n+    std::string::size_type\trpos;\r\n+    streamsize\t\t\tbufsize;\r\n+    char\t\t\tdefbuf;\r\n+  };\r\n+\r\n+  class stringstreambase : virtual public ios {\r\n+  protected:\r\n+    stringbuf __my_sb;\r\n+  public:\r\n+    std::string str() const\r\n+    {\r\n+      return dynamic_cast<stringbuf*>(_strbuf)->str();\r\n+    }\r\n+    void str(const std::string& s)\r\n+    {\r\n+      clear();\r\n+      dynamic_cast<stringbuf*>(_strbuf)->str(s);\r\n+    }\r\n+\t\r\n+    stringbuf* rdbuf()\r\n+    {\r\n+      return &__my_sb;\r\n+    }\r\n+  protected:\r\n+    stringstreambase(int which) :\r\n+      __my_sb(which)\r\n+    {\r\n+      init (&__my_sb);\r\n+    }\r\n+\t\r\n+    stringstreambase(const std::string& s, int which) :\r\n+      __my_sb(s, which)\r\n+    {\r\n+      init (&__my_sb);\r\n+    }\r\n+  };\r\n+    \r\n+  class istringstream : public stringstreambase, public istream {\r\n+  public:\r\n+    istringstream(int which=ios::in) :\r\n+      stringstreambase(which)\r\n+    { }\r\n+\t\r\n+    istringstream(const std::string& s, int which=ios::in) :\r\n+      stringstreambase(s, which)\r\n+    { }\r\n+  };\r\n+    \r\n+  class ostringstream : public stringstreambase, public ostream {\r\n+  public:\r\n+    ostringstream(int which=ios::out) :\r\n+      stringstreambase(which)\r\n+    { }\r\n+\t\r\n+    ostringstream(const std::string& s, int which=ios::out) :\r\n+      stringstreambase(s, which)\r\n+    { }\r\n+  };\r\n+    \r\n+  class stringstream : public stringstreambase, public iostream {\r\n+  public:\r\n+    stringstream(int which=ios::in|ios::out) :\r\n+      stringstreambase(which)\r\n+    { }\r\n+    \r\n+    stringstream(const std::string &s, int which=ios::in|ios::out) :\r\n+      stringstreambase(s, which)\r\n+    { }\r\n+  };\r\n+}\r\n+\r\n+inline int std::stringbuf::sync()\r\n+{\r\n+  if((mode & ios::out) == 0)\r\n+    return EOF;\r\n+\r\n+  streamsize n = pptr() - pbase();\r\n+  if(n)\r\n+    {\r\n+      buf.replace(rpos, std::string::npos, pbase(), n);\r\n+      if(buf.size() - rpos != n)\r\n+\treturn EOF;\r\n+      rpos += n;\r\n+      pbump(-n);\r\n+      gbump(egptr() - gptr());\r\n+    }\r\n+  return 0;\r\n+}\r\n+\r\n+inline int std::stringbuf::overflow(int ch)\r\n+{\r\n+  if((mode & ios::out) == 0)\r\n+    return EOF;\r\n+\r\n+  streamsize n = pptr() - pbase();\r\n+\r\n+  if(n && sync())\r\n+    return EOF;\r\n+\r\n+  if(ch != EOF)\r\n+    {\r\n+      std::string::size_type oldSize = buf.size();\r\n+      \r\n+      buf.replace(rpos, std::string::npos, ch);\r\n+      if(buf.size() - oldSize != 1)\r\n+\treturn EOF;\r\n+      ++rpos;\r\n+    }\r\n+  return 0;\r\n+}\r\n+\r\n+inline int std::stringbuf::underflow()\r\n+{\r\n+  sync();\r\n+  if((mode & ios::in) == 0)\r\n+    {\r\n+      return EOF;\r\n+    }\r\n+  if(rpos >= buf.size())\r\n+    {\r\n+      return EOF;\r\n+    }\r\n+  \r\n+  std::string::size_type n = egptr() - eback();\r\n+  std::string::size_type s;\r\n+\r\n+  s = buf.copy(eback(), n, rpos);\r\n+  pbump(pbase() - pptr());\r\n+  gbump(eback() - gptr());\r\n+  int res = (0377 & buf[rpos]);\r\n+  rpos += s;\r\n+  return res;\r\n+}\r\n+\r\n+#endif /* not __STRSTREAM__ */\r"}]}