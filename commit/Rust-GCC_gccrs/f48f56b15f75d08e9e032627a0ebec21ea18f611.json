{"sha": "f48f56b15f75d08e9e032627a0ebec21ea18f611", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ4ZjU2YjE1Zjc1ZDA4ZTllMDMyNjI3YTBlYmVjMjFlYTE4ZjYxMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2002-01-10T19:20:10Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-01-10T19:20:10Z"}, "message": "* config/h8300/h8300.h: Fix formatting.\n\nFrom-SVN: r48747", "tree": {"sha": "b4d5c921dd3e410d7255824188282d7397bcb51e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4d5c921dd3e410d7255824188282d7397bcb51e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f48f56b15f75d08e9e032627a0ebec21ea18f611", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f48f56b15f75d08e9e032627a0ebec21ea18f611", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f48f56b15f75d08e9e032627a0ebec21ea18f611", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f48f56b15f75d08e9e032627a0ebec21ea18f611/comments", "author": null, "committer": null, "parents": [{"sha": "468c0b9b4c4eeb1b89adf156cf4346662bc92abe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/468c0b9b4c4eeb1b89adf156cf4346662bc92abe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/468c0b9b4c4eeb1b89adf156cf4346662bc92abe"}], "stats": {"total": 45, "additions": 25, "deletions": 20}, "files": [{"sha": "eaa7e45e76f7b0df82296cb45183facddca40d7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f48f56b15f75d08e9e032627a0ebec21ea18f611/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f48f56b15f75d08e9e032627a0ebec21ea18f611/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f48f56b15f75d08e9e032627a0ebec21ea18f611", "patch": "@@ -1,3 +1,7 @@\n+2002-01-10  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* config/h8300/h8300.h: Fix formatting.\n+\n 2001-01-10  Ira Ruben\t<ira@apple.com>\n \n \tAdd __attribute__ ((deprecated))."}, {"sha": "b96c9b6e622fc505181a86bb07c3f5de3307736f", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f48f56b15f75d08e9e032627a0ebec21ea18f611/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f48f56b15f75d08e9e032627a0ebec21ea18f611/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=f48f56b15f75d08e9e032627a0ebec21ea18f611", "patch": "@@ -319,9 +319,10 @@ extern int target_flags;\n            or HI.\n    H8/300H: Anything goes.  */\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n- (TARGET_H8300 ? (((REGNO)&1)==0) || (MODE==HImode) || (MODE==QImode) \\\n-   : REGNO == 8 ? MODE == SImode : 1)\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n+  (TARGET_H8300\t\t\t\t\t\t\t\t\\\n+   ? ((((REGNO) & 1) == 0) || ((MODE) == HImode) || ((MODE) == QImode))\t\\\n+   : (REGNO) == 8 ? (MODE) == SImode : 1)\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -476,7 +477,7 @@ enum reg_class {\n    In general this is just CLASS; but on some machines\n    in some cases it is preferable to use a more restrictive class.  */\n \n-#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n+#define PREFERRED_RELOAD_CLASS(X, CLASS)  (CLASS)\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n@@ -542,7 +543,7 @@ enum reg_class {\n \n    On the H8 the return does not pop anything.  */\n \n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, SIZE) 0\n \n /* Definitions for register eliminations.\n \n@@ -654,7 +655,7 @@ struct cum_arg\n \n    On the H8/300, the offset starts at 0.  */\n \n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT)\t\\\n  ((CUM).nbytes = 0, (CUM).libcall = LIBNAME)\n \n /* Update the data in CUM to advance over an argument\n@@ -928,15 +929,15 @@ struct cum_arg\n \n    For the H8/300, don't do anything.  */\n \n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)  {}\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.\n \n    On the H8/300, the predecrement and postincrement address depend thus\n    (the amount of decrement or increment being the length of the operand).  */\n \n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL) \\\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL) \\\n   if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC) goto LABEL;\n \f\n /* Specify the machine mode that this machine uses\n@@ -1009,7 +1010,7 @@ struct cum_arg\n    of a switch statement.  If the code is computed here,\n    return it with a return statement.  Otherwise, break from the switch.  */\n \n-#define DEFAULT_RTX_COSTS(RTX,CODE,OUTER_CODE) \\\n+#define DEFAULT_RTX_COSTS(RTX, CODE, OUTER_CODE) \\\n   return (const_costs (RTX, CODE));\n \n #define BRANCH_COST 0\n@@ -1021,7 +1022,7 @@ struct cum_arg\n    switch on CODE.  */\n /* ??? Shifts need to have a *much* higher cost than this.  */\n \n-#define RTX_COSTS(RTX,CODE,OUTER_CODE)\t\t\\\n+#define RTX_COSTS(RTX, CODE, OUTER_CODE)\t\\\n   case MOD:\t\t\t\t\t\\\n   case DIV:\t\t\t\t\t\\\n     return 60;\t\t\t\t\t\\\n@@ -1045,11 +1046,11 @@ struct cum_arg\n    after execution of an instruction whose pattern is EXP.\n    Do not alter them if the instruction would not alter the cc's.  */\n \n-#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP, INSN)\n+#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc (EXP, INSN)\n \n /* The add insns don't set overflow in a usable way.  */\n #define CC_OVERFLOW_UNUSABLE 01000\n-/* The mov,and,or,xor insns don't set carry.  That's ok though as the\n+/* The mov,and,or,xor insns don't set carry.  That's OK though as the\n    Z bit is all we need when doing unsigned comparisons on the result of\n    these insns (since they're always with 0).  However, conditions.h has\n    CC_NO_OVERFLOW defined for this purpose.  Rename it to something more\n@@ -1060,9 +1061,9 @@ struct cum_arg\n \n /* Output at beginning/end of assembler file.  */\n \n-#define ASM_FILE_START(FILE) asm_file_start(FILE)\n+#define ASM_FILE_START(FILE) asm_file_start (FILE)\n \n-#define ASM_FILE_END(FILE) asm_file_end(FILE)\n+#define ASM_FILE_END(FILE) asm_file_end (FILE)\n \n /* Output to assembler file text saying following lines\n    may contain character constants, extra white space, comments, etc.  */\n@@ -1155,7 +1156,7 @@ readonly_data ()\t\t\t\t\t\t\t\\\n \n /* Store the user-specified part of SYMBOL_NAME in VAR.\n    This is sort of inverse to ENCODE_SECTION_INFO.  */\n-#define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME)\t\t\\\n+#define STRIP_NAME_ENCODING(VAR, SYMBOL_NAME)\t\t\\\n   (VAR) = (SYMBOL_NAME) + ((SYMBOL_NAME)[0] == '*'\t\\\n \t\t\t   || (SYMBOL_NAME)[0] == '@'\t\\\n \t\t\t   || (SYMBOL_NAME)[0] == '&');\n@@ -1201,7 +1202,7 @@ readonly_data ()\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n   while (0)\n \n-#define ASM_OUTPUT_LABELREF(FILE,NAME)  \\\n+#define ASM_OUTPUT_LABELREF(FILE, NAME)  \\\n   asm_fprintf ((FILE), \"%U%s\", (NAME) + (TINY_DATA_NAME_P (NAME) ? 1 : 0))\n \n #define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\n@@ -1251,7 +1252,7 @@ readonly_data ()\t\t\t\t\t\t\t\\\n /* This is how to output an insn to pop a register from the stack.\n    It need not be very fast code.  */\n \n-#define ASM_OUTPUT_REG_POP(FILE,REGNO) \\\n+#define ASM_OUTPUT_REG_POP(FILE, REGNO) \\\n   fprintf (FILE, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[REGNO])\n \n /* This is how to output an element of a case-vector that is absolute.  */\n@@ -1268,7 +1269,7 @@ readonly_data ()\t\t\t\t\t\t\t\\\n    that says to advance the location counter\n    to a multiple of 2**LOG bytes.  */\n \n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\t\\\n+#define ASM_OUTPUT_ALIGN(FILE, LOG)\t\t\\\n   if ((LOG) != 0)\t\t\t\t\\\n     fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n \n@@ -1299,7 +1300,7 @@ readonly_data ()\t\t\t\t\t\t\t\\\n /* This says how to output an assembler line\n    to define a local common symbol.  */\n \n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE,ROUNDED)\t\\\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n ( fputs (\"\\t.lcomm \", (FILE)),\t\t\t\t\\\n   assemble_name ((FILE), (NAME)),\t\t\t\\\n   fprintf ((FILE), \",%d\\n\", (SIZE)))\n@@ -1318,7 +1319,7 @@ readonly_data ()\t\t\t\t\t\t\t\\\n #define PRINT_OPERAND_PUNCT_VALID_P(CODE) \\\n   ((CODE) == '#')\n \n-#define PRINT_OPERAND(FILE, X, CODE) print_operand(FILE,X,CODE)\n+#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n \n /* Print a memory operand whose address is X, on file FILE.\n    This uses a function in h8300.c.  */"}]}