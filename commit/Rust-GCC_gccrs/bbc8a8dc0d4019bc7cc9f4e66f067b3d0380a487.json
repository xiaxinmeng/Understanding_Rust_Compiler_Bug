{"sha": "bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJjOGE4ZGMwZDQwMTliYzdjYzlmNGU2NmYwNjdiM2QwMzgwYTQ4Nw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-05-24T16:09:26Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-05-24T16:09:26Z"}, "message": "passes.texi: Document predictive commoning.\n\n\t* doc/passes.texi: Document predictive commoning.\n\t* doc/invoke.texi (-fpredictive-commoning): Document.\n\t* opts.c (decode_options): Enable flag_predictive_commoning on -O3.\n\t* tree-ssa-loop-im.c (get_lsm_tmp_name): Export.  Allow\n\tadding indices to the generated name.\n\t(schedule_sm): Pass 0 to get_lsm_tmp_name.\n\t* tree-ssa-loop-niter.c (stmt_dominates_stmt_p): Export.\n\t* tree-pretty-print.c (op_symbol_1): Renamed to ...\n\t(op_symbol_code): ... and exported.\n\t(dump_omp_clause, op_symbol): Use op_symbol_code\n\tinstead of op_symbol_1.\n\t* tree-pass.h (pass_predcom): Declare.\n\t* timevar.def (TV_PREDCOM): New timevar.\n\t* tree-ssa-loop.c (run_tree_predictive_commoning,\n\tgate_tree_predictive_commoning, pass_predcom): New.\n\t* tree-data-ref.c (find_data_references_in_loop): Find the\n\treferences in dominance order.\n\t(canonicalize_base_object_address): Ensure that the result has\n\tpointer type.\n\t(dr_analyze_innermost): Export.\n\t(create_data_ref): Code to fail for references with invariant\n\taddress moved ...\n\t(find_data_references_in_stmt): ... here.\n\t* tree-data-ref.h (dr_analyze_innermost): Declare.\n\t* tree-affine.c: Include tree-gimple.h and hashtab.h.\n\t(aff_combination_find_elt, name_expansion_hash,\n\tname_expansion_eq, tree_to_aff_combination_expand,\n\tdouble_int_constant_multiple_p, aff_combination_constant_multiple_p):\n\tNew functions.\n\t* tree-affine.h (aff_combination_constant_multiple_p,\n\ttree_to_aff_combination_expand): Declare.\n\t* tree-predcom.c: New file.\n\t* common.opt (fpredictive-commoning): New option.\n\t* tree-flow.h (op_symbol_code, tree_predictive_commoning,\n\tstmt_dominates_stmt_p, get_lsm_tmp_name): Declare.\n\t* Makefile.in (tree-predcom.o): Add.\n\t(tree-affine.o): Add TREE_GIMPLE_H dependency.\n\t* passes.c (init_optimization_passes):  Add dceloop after\n\tcopy propagation in loop optimizer.  Add predictive commoning\n\tto loop optimizer passes.\n\n\t* gcc.dg/tree-ssa/predcom-1.c: New test.\n\t* gcc.dg/tree-ssa/predcom-2.c: New test.\n\t* gcc.dg/tree-ssa/predcom-3.c: New test.\n\t* gcc.dg/tree-ssa/predcom-4.c: New test.\n\t* gcc.dg/tree-ssa/predcom-5.c: New test.\n\t* gcc.dg/vect/dump-tree-dceloop-pr26359.c: Test dceloop2 dumps.\n\nFrom-SVN: r125030", "tree": {"sha": "efa71ea8cb7294c745a8a90f9749d81cacc971df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efa71ea8cb7294c745a8a90f9749d81cacc971df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/comments", "author": null, "committer": null, "parents": [{"sha": "956741d54f125ca2fd4253b0fa261c023182d330", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/956741d54f125ca2fd4253b0fa261c023182d330", "html_url": "https://github.com/Rust-GCC/gccrs/commit/956741d54f125ca2fd4253b0fa261c023182d330"}], "stats": {"total": 3157, "additions": 3125, "deletions": 32}, "files": [{"sha": "385c5eee96ebb3be4be340277ab4f48a60e59535", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -1,3 +1,46 @@\n+2007-05-24  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* doc/passes.texi: Document predictive commoning.\n+\t* doc/invoke.texi (-fpredictive-commoning): Document.\n+\t* opts.c (decode_options): Enable flag_predictive_commoning on -O3.\n+\t* tree-ssa-loop-im.c (get_lsm_tmp_name): Export.  Allow\n+\tadding indices to the generated name.\n+\t(schedule_sm): Pass 0 to get_lsm_tmp_name.\n+\t* tree-ssa-loop-niter.c (stmt_dominates_stmt_p): Export.\n+\t* tree-pretty-print.c (op_symbol_1): Renamed to ...\n+\t(op_symbol_code): ... and exported.\n+\t(dump_omp_clause, op_symbol): Use op_symbol_code\n+\tinstead of op_symbol_1.\n+\t* tree-pass.h (pass_predcom): Declare.\n+\t* timevar.def (TV_PREDCOM): New timevar.\n+\t* tree-ssa-loop.c (run_tree_predictive_commoning,\n+\tgate_tree_predictive_commoning, pass_predcom): New.\n+\t* tree-data-ref.c (find_data_references_in_loop): Find the\n+\treferences in dominance order.\n+\t(canonicalize_base_object_address): Ensure that the result has\n+\tpointer type.\n+\t(dr_analyze_innermost): Export.\n+\t(create_data_ref): Code to fail for references with invariant\n+\taddress moved ...\n+\t(find_data_references_in_stmt): ... here.\n+\t* tree-data-ref.h (dr_analyze_innermost): Declare.\n+\t* tree-affine.c: Include tree-gimple.h and hashtab.h.\n+\t(aff_combination_find_elt, name_expansion_hash,\n+\tname_expansion_eq, tree_to_aff_combination_expand,\n+\tdouble_int_constant_multiple_p, aff_combination_constant_multiple_p):\n+\tNew functions.\n+\t* tree-affine.h (aff_combination_constant_multiple_p,\n+\ttree_to_aff_combination_expand): Declare.\n+\t* tree-predcom.c: New file.\n+\t* common.opt (fpredictive-commoning): New option.\n+\t* tree-flow.h (op_symbol_code, tree_predictive_commoning,\n+\tstmt_dominates_stmt_p, get_lsm_tmp_name): Declare.\n+\t* Makefile.in (tree-predcom.o): Add.\n+\t(tree-affine.o): Add TREE_GIMPLE_H dependency.\n+\t* passes.c (init_optimization_passes):  Add dceloop after\n+\tcopy propagation in loop optimizer.  Add predictive commoning\n+\tto loop optimizer passes.\n+\n 2007-05-24  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* target-def.h (TARGET_MANGLE_DECL_ASSEMBLER_NAME): Correct"}, {"sha": "d5ed16b7b9b87e76820fa936149c8e04ec08ef50", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -1100,6 +1100,7 @@ OBJS-common = \\\n \ttree-optimize.o \\\n \ttree-outof-ssa.o \\\n \ttree-phinodes.o \\\n+\ttree-predcom.o \\\n \ttree-pretty-print.o \\\n \ttree-profile.o \\\n \ttree-scalar-evolution.o \\\n@@ -2083,14 +2084,18 @@ tree-ssa-loop-prefetch.o: tree-ssa-loop-prefetch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    tree-pass.h $(GGC_H) $(RECOG_H) insn-config.h $(HASHTAB_H) $(SCEV_H) \\\n    $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) hard-reg-set.h \\\n    tree-chrec.h toplev.h langhooks.h $(TREE_INLINE_H)\n+tree-predcom.o: tree-predcom.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_P_H) \\\n+   $(CFGLOOP_H) $(TREE_FLOW_H) $(GGC_H) $(TREE_DATA_REF_H) $(SCEV_H) \\\n+   $(PARAMS_H) $(DIAGNOSTIC_H) tree-pass.h $(TM_H) coretypes.h tree-affine.h \\\n+   tree-inline.h\n tree-ssa-loop-ivopts.o : tree-ssa-loop-ivopts.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(EXPR_H) \\\n    output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    tree-pass.h $(GGC_H) $(RECOG_H) insn-config.h $(HASHTAB_H) $(SCEV_H) \\\n    $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) hard-reg-set.h \\\n    tree-chrec.h $(VARRAY_H) tree-affine.h pointer-set.h $(TARGET_H)\n-tree-affine.o : tree-affine.c tree-affine.h $(CONFIG_H) \\\n-   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) \\\n+tree-affine.o : tree-affine.c tree-affine.h $(CONFIG_H) pointer-set.h \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(TREE_GIMPLE_H) \\\n    output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H)\n tree-ssa-loop-manip.o : tree-ssa-loop-manip.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \\"}, {"sha": "3710f346d40af7ce5841f8e0201d475c5e7584d1", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -719,6 +719,10 @@ fpie\n Common Report Var(flag_pie,1) VarExists\n Generate position-independent code for executables if possible (small mode)\n \n+fpredictive-commoning\n+Common Report Var(flag_predictive_commoning)\n+Run predictive commoning optimization.\n+\n fprefetch-loop-arrays\n Common Report Var(flag_prefetch_loop_arrays) Optimization\n Generate prefetch instructions, if available, for arrays in loops"}, {"sha": "023cf720fef6fcb0c39dbd81630ae084f94b53ed", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -334,7 +334,7 @@ Objective-C and Objective-C++ Dialects}.\n -ffinite-math-only  -fno-signed-zeros @gol\n -fno-toplevel-reorder -fno-trapping-math  -fno-zero-initialized-in-bss @gol\n -fomit-frame-pointer  -foptimize-register-move @gol\n--foptimize-sibling-calls  -fprefetch-loop-arrays @gol\n+-foptimize-sibling-calls  -fpredictive-commoning -fprefetch-loop-arrays @gol\n -fprofile-generate -fprofile-use @gol\n -fregmove  -frename-registers @gol\n -freorder-blocks  -freorder-blocks-and-partition -freorder-functions @gol\n@@ -5001,7 +5001,8 @@ invoking @option{-O2} on programs that use computed gotos.\n @opindex O3\n Optimize yet more.  @option{-O3} turns on all optimizations specified by\n @option{-O2} and also turns on the @option{-finline-functions},\n-@option{-funswitch-loops} and @option{-fgcse-after-reload} options.\n+@option{-funswitch-loops}, @option{-fpredictive-commoning} and\n+@option{-fgcse-after-reload} options.\n \n @item -O0\n @opindex O0\n@@ -5712,6 +5713,14 @@ This optimization is enabled by default.\n With this option, the compiler will create multiple copies of some\n local variables when unrolling a loop which can result in superior code.\n \n+@item -fpredictive-commoning\n+@opindex fpredictive-commoning\n+Perform predictive commoning optimization, i.e., reusing computations\n+(especially memory loads and stores) performed in previous\n+iterations of loops.\n+\n+This option is enabled at level @option{-O3}.\n+\n @item -fprefetch-loop-arrays\n @opindex fprefetch-loop-arrays\n If supported by the target machine, generate instructions to prefetch"}, {"sha": "b4eef6047b373384d6bf07ce7a93429b52db2b84", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -602,6 +602,17 @@ This pass completely unrolls loops with few iterations.  The pass\n is located in @file{tree-ssa-loop-ivcanon.c} and described by\n @code{pass_complete_unroll}.\n \n+@item Predictive commoning\n+\n+This pass makes the code reuse the computations from the previous\n+iterations of the loops, especially loads and stores to memory.\n+It does so by storing the values of these computations to a bank\n+of temporary variables that are rotated at the end of loop.  To avoid\n+the need for this rotation, the loop is then unrolled and the copies\n+of the loop body are rewritten to use the appropriate version of\n+the temporary variable.  This pass is located in @file{tree-predcom.c}\n+and described by @code{pass_predcom}.\n+\n @item Array prefetching\n \n This pass issues prefetch instructions for array references inside"}, {"sha": "78e746e0b7a234c2906ea817b0d0207a23cbb772", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -767,6 +767,7 @@ decode_options (unsigned int argc, const char **argv)\n \n   if (optimize >= 3)\n     {\n+      flag_predictive_commoning = 1;\n       flag_inline_functions = 1;\n       flag_unswitch_loops = 1;\n       flag_gcse_after_reload = 1;"}, {"sha": "8f7ab85bc865eee9bd35dd0e5c9aa6e98fe5ed04", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -590,7 +590,9 @@ init_optimization_passes (void)\n \t  struct tree_opt_pass **p = &pass_tree_loop.sub;\n \t  NEXT_PASS (pass_tree_loop_init);\n \t  NEXT_PASS (pass_copy_prop);\n+\t  NEXT_PASS (pass_dce_loop);\n \t  NEXT_PASS (pass_lim);\n+\t  NEXT_PASS (pass_predcom);\n \t  NEXT_PASS (pass_tree_unswitch);\n \t  NEXT_PASS (pass_scev_cprop);\n \t  NEXT_PASS (pass_empty_loop);"}, {"sha": "1b07721cab8ba9d2b11f5b64845167875b12afd9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -1,3 +1,12 @@\n+2007-05-24  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/predcom-1.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-2.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-3.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-4.c: New test.\n+\t* gcc.dg/tree-ssa/predcom-5.c: New test.\n+\t* gcc.dg/vect/dump-tree-dceloop-pr26359.c: Test dceloop2 dumps.\n+\n 2007-05-24  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR testsuite/32062"}, {"sha": "8e6e897199d8fe768751ef5e234d3a158c1eaedf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-1.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+void abort (void);\n+\n+unsigned fib[1000];\n+\n+void count_fib(void)\n+{\n+  int i;\n+\n+  fib[0] = 0;\n+  fib[1] = 1;\n+  for (i = 2; i < 1000; i++)\n+    fib[i] = (fib[i-1] + fib[i - 2]) & 0xffff;\n+}\n+\n+unsigned avg[1000];\n+\n+void count_averages(int n)\n+{\n+  int i;\n+\n+  for (i = 1; i < n; i++)\n+    avg[i] = ((fib[i - 1] + fib[i] + fib[i + 1]) / 3) & 0xffff;\n+}\n+\n+int main(void)\n+{\n+  count_fib ();\n+  count_averages (999);\n+\n+  if (fib[19] != 4181 || avg[19] != 4510)\n+    abort ();\n+\n+  if (fib[999] != 162 || avg[998] != 21953)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* Verify that both loops were transformed and unrolled.  */\n+/* { dg-final { scan-tree-dump-times \"Unrolling 2 times.\" 2 \"pcom\"} } */\n+\n+/* Also check that we undid the transformation previously made by PRE.  */\n+/* { dg-final { scan-tree-dump-times \"looparound ref\" 1 \"pcom\"} } */\n+\n+/* { dg-final { cleanup-tree-dump \"pcom\" } } */"}, {"sha": "b7088c5f83f441cbff34d9cd4259c116c946f2ac", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-2.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-2.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+void abort (void);\n+\n+int fib[1000];\n+\n+void count_fib(void)\n+{\n+  int i;\n+\n+  fib[0] = 0;\n+  fib[1] = 1;\n+  for (i = 2; i < 1000; i++)\n+    fib[i] = (fib[i-1] + fib[i - 2]) & 0xffff;\n+}\n+\n+int avg[1000];\n+\n+void count_averages(void)\n+{\n+  int i;\n+\n+  for (i = 1; i < 999; i++)\n+    avg[i] = ((fib[i - 1] + fib[i] + fib[i + 1]) / 3) & 0xffff;\n+}\n+\n+int main(void)\n+{\n+  count_fib ();\n+  count_averages ();\n+\n+  if (fib[19] != 4181 || avg[19] != 4510)\n+    abort ();\n+\n+  if (fib[999] != 162 || avg[998] != 21953)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* Verify that both loops were transformed and unrolled.  */\n+/* { dg-final { scan-tree-dump-times \"Unrolling 2 times.\" 2 \"pcom\"} } */\n+/* { dg-final { cleanup-tree-dump \"pcom\" } } */"}, {"sha": "d5002346ed22c3ad38b8819b5d8b6d0f73ff5cb0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-3.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+int a[1000], b[1000];\n+\n+void test(void)\n+{\n+  int i;\n+\n+  for (i = 1; i < 999; i++)\n+    b[i] = (a[i + 1] + a[i] + a[i - 1]) / 3;\n+}\n+\n+/* Verify that we used 3 temporary variables for the loop.  */\n+/* { dg-final { scan-tree-dump-times \"Unrolling 3 times.\" 1 \"pcom\"} } */\n+/* { dg-final { cleanup-tree-dump \"pcom\" } } */"}, {"sha": "6f06b7f8bf6e7095d8203b21dd7f048c5bae275a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-4.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-4.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+/* Test for predictive commoning of expressions, without reassociation.  */\n+\n+void abort (void);\n+\n+int a[1000], b[1000], c[1000];\n+\n+int main(void)\n+{\n+  int i;\n+\n+  for (i = 0; i < 1000; i++)\n+    a[i] = b[i] = i;\n+\n+  for (i = 1; i < 998; i++)\n+    c[i] = a[i + 2] * b[i + 1] - b[i - 1] * a[i];\n+\n+  for (i = 1; i < 998; i++)\n+    if (c[i] != 4 * i + 2)\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Combination\" 1 \"pcom\"} } */\n+/* { dg-final { scan-tree-dump-times \"Unrolling 3 times.\" 1 \"pcom\"} } */\n+/* { dg-final { cleanup-tree-dump \"pcom\" } } */"}, {"sha": "134fc3765dc8d2f07eedf8038b803a47be4dd37d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/predcom-5.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpredcom-5.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fpredictive-commoning -fdump-tree-pcom-details\" } */\n+\n+/* Test for predictive commoning of expressions, with reassociation.  */\n+\n+void abort (void);\n+\n+unsigned a[1000], b[1000], c[1000], d[1000];\n+\n+int main(void)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < 1000; i++)\n+    a[i] = b[i] = d[i] = i;\n+\n+  for (i = 1; i < 998; i++)\n+    c[i] = d[i + 1] * a[i + 2] * b[i + 1] - b[i - 1] * a[i] * d[i - 1];\n+\n+  for (i = 1; i < 998; i++)\n+    if (c[i] != (i+1)*(i+2)*(i+1) - (i - 1) * i * (i - 1))\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Combination\" 2 \"pcom\"} } */\n+/* { dg-final { scan-tree-dump-times \"Unrolling 3 times.\" 1 \"pcom\"} } */\n+/* { dg-final { cleanup-tree-dump \"pcom\" } } */"}, {"sha": "87fc36d167cae014bbdd3d299ed74dde386cfc45", "filename": "gcc/testsuite/gcc.dg/vect/dump-tree-dceloop-pr26359.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fdump-tree-dceloop-pr26359.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fdump-tree-dceloop-pr26359.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fdump-tree-dceloop-pr26359.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -11,6 +11,6 @@ foo () {\n   }\n }\n \n-/* { dg-final { scan-tree-dump-times \"Deleting : vect_\" 0 \"dceloop\" } } */\n-/* { dg-final { cleanup-tree-dump \"dceloop\" } } */\n+/* { dg-final { scan-tree-dump-times \"Deleting : vect_\" 0 \"dceloop2\" } } */\n+/* { dg-final { cleanup-tree-dump \"dceloop2\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "f9690fe080f676e35a12054da672d927d2216ebd", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -112,6 +112,7 @@ DEFTIMEVAR (TV_TREE_LINEAR_TRANSFORM , \"tree loop linear\")\n DEFTIMEVAR (TV_CHECK_DATA_DEPS       , \"tree check data dependences\")\n DEFTIMEVAR (TV_TREE_PREFETCH\t     , \"tree prefetching\")\n DEFTIMEVAR (TV_TREE_LOOP_IVOPTS\t     , \"tree iv optimization\")\n+DEFTIMEVAR (TV_PREDCOM\t\t     , \"predictive commoning\")\n DEFTIMEVAR (TV_TREE_LOOP_INIT\t     , \"tree loop init\")\n DEFTIMEVAR (TV_TREE_LOOP_FINI\t     , \"tree loop fini\")\n DEFTIMEVAR (TV_TREE_CH\t\t     , \"tree copy headers\")"}, {"sha": "87f379c8003bc407c271e789023cbbc6f81ec342", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -29,7 +29,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"output.h\"\n #include \"diagnostic.h\"\n #include \"tree-dump.h\"\n+#include \"pointer-set.h\"\n #include \"tree-affine.h\"\n+#include \"tree-gimple.h\"\n \n /* Extends CST as appropriate for the affine combinations COMB.  */\n \n@@ -493,3 +495,212 @@ aff_combination_mult (aff_tree *c1, aff_tree *c2, aff_tree *r)\n     aff_combination_add_product (c1, double_int_one, c2->rest, r);\n   aff_combination_add_product (c1, c2->offset, NULL, r);\n }\n+\n+/* Returns the element of COMB whose value is VAL, or NULL if no such\n+   element exists.  If IDX is not NULL, it is set to the index of VAL in\n+   COMB.  */\n+\t      \n+static struct aff_comb_elt *\n+aff_combination_find_elt (aff_tree *comb, tree val, unsigned *idx)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < comb->n; i++)\n+    if (operand_equal_p (comb->elts[i].val, val, 0))\n+      {\n+\tif (idx)\n+\t  *idx = i;\n+\n+\treturn &comb->elts[i];\n+      }\n+\n+  return NULL;\n+}\n+\n+/* Element of the cache that maps ssa name NAME to its expanded form\n+   as an affine expression EXPANSION.  */\n+\n+struct name_expansion\n+{\n+  aff_tree expansion;\n+\n+  /* True if the expansion for the name is just being generated.  */\n+  unsigned in_progress : 1;\n+};\n+\n+/* Similar to tree_to_aff_combination, but follows SSA name definitions\n+   and expands them recursively.  CACHE is used to cache the expansions\n+   of the ssa names, to avoid exponential time complexity for cases\n+   like\n+ \n+   a1 = a0 + a0;\n+   a2 = a1 + a1;\n+   a3 = a2 + a2;\n+   ...  */\n+\n+void\n+tree_to_aff_combination_expand (tree expr, tree type, aff_tree *comb,\n+\t\t\t\tstruct pointer_map_t **cache)\n+{\n+  unsigned i;\n+  aff_tree to_add, current, curre;\n+  tree e, def, rhs;\n+  double_int scale;\n+  void **slot;\n+  struct name_expansion *exp;\n+\n+  tree_to_aff_combination (expr, type, comb);\n+  aff_combination_zero (&to_add, type);\n+  for (i = 0; i < comb->n; i++)\n+    {\n+      e = comb->elts[i].val;\n+      if (TREE_CODE (e) != SSA_NAME)\n+\tcontinue;\n+      def = SSA_NAME_DEF_STMT (e);\n+      if (TREE_CODE (def) != GIMPLE_MODIFY_STMT\n+\t  || GIMPLE_STMT_OPERAND (def, 0) != e)\n+\tcontinue;\n+\n+      rhs = GIMPLE_STMT_OPERAND (def, 1);\n+      if (TREE_CODE (rhs) != SSA_NAME\n+\t  && !EXPR_P (rhs)\n+\t  && !is_gimple_min_invariant (rhs))\n+\tcontinue;\n+\n+      /* We do not know whether the reference retains its value at the\n+\t place where the expansion is used.  */\n+      if (REFERENCE_CLASS_P (rhs))\n+\tcontinue;\n+\n+      if (!*cache)\n+\t*cache = pointer_map_create ();\n+      slot = pointer_map_insert (*cache, e);\n+      exp = *slot;\n+\n+      if (!exp)\n+\t{\n+\t  exp = XNEW (struct name_expansion);\n+\t  exp->in_progress = 1;\n+\t  *slot = exp;\n+\t  tree_to_aff_combination_expand (rhs, type, &current, cache);\n+\t  exp->expansion = current;\n+\t  exp->in_progress = 0;\n+\t}\n+      else\n+\t{\n+\t  /* Since we follow the definitions in the SSA form, we should not\n+\t     enter a cycle unless we pass through a phi node.  */\n+\t  gcc_assert (!exp->in_progress);\n+\t  current = exp->expansion;\n+\t}\n+\n+      /* Accumulate the new terms to TO_ADD, so that we do not modify\n+\t COMB while traversing it; include the term -coef * E, to remove\n+         it from COMB.  */\n+      scale = comb->elts[i].coef;\n+      aff_combination_zero (&curre, type);\n+      aff_combination_add_elt (&curre, e, double_int_neg (scale));\n+      aff_combination_scale (&current, scale);\n+      aff_combination_add (&to_add, &current);\n+      aff_combination_add (&to_add, &curre);\n+    }\n+  aff_combination_add (comb, &to_add);\n+}\n+\n+/* Frees memory occupied by struct name_expansion in *VALUE.  Callback for\n+   pointer_map_traverse.  */\n+\n+static bool\n+free_name_expansion (void *key ATTRIBUTE_UNUSED, void **value,\n+\t\t     void *data ATTRIBUTE_UNUSED)\n+{\n+  struct name_expansion *exp = *value;\n+\n+  free (exp);\n+  return true;\n+}\n+\n+/* Frees memory allocated for the CACHE used by\n+   tree_to_aff_combination_expand.  */\n+\n+void\n+free_affine_expand_cache (struct pointer_map_t **cache)\n+{\n+  if (!*cache)\n+    return;\n+\n+  pointer_map_traverse (*cache, free_name_expansion, NULL);\n+  pointer_map_destroy (*cache);\n+  *cache = NULL;\n+}\n+\n+/* If VAL != CST * DIV for any constant CST, returns false.\n+   Otherwise, if VAL != 0 (and hence CST != 0), and *MULT_SET is true,\n+   additionally compares CST and MULT, and if they are different,\n+   returns false.  Finally, if neither of these two cases occcur,\n+   true is returned, and if CST != 0, CST is stored to MULT and\n+   MULT_SET is set to true.  */\n+\n+static bool\n+double_int_constant_multiple_p (double_int val, double_int div,\n+\t\t\t\tbool *mult_set, double_int *mult)\n+{\n+  double_int rem, cst;\n+\n+  if (double_int_zero_p (val))\n+    return true;\n+\n+  if (double_int_zero_p (div))\n+    return false;\n+\n+  cst = double_int_sdivmod (val, div, FLOOR_DIV_EXPR, &rem);\n+  if (!double_int_zero_p (rem))\n+    return false;\n+\n+  if (*mult_set && !double_int_equal_p (*mult, cst))\n+    return false;\n+\n+  *mult_set = true;\n+  *mult = cst;\n+  return true;\n+}\n+\n+/* Returns true if VAL = X * DIV for some constant X.  If this is the case,\n+   X is stored to MULT.  */\n+\n+bool\n+aff_combination_constant_multiple_p (aff_tree *val, aff_tree *div,\n+\t\t\t\t     double_int *mult)\n+{\n+  bool mult_set = false;\n+  unsigned i;\n+\n+  if (val->n == 0 && double_int_zero_p (val->offset))\n+    {\n+      *mult = double_int_zero;\n+      return true;\n+    }\n+  if (val->n != div->n)\n+    return false;\n+\n+  if (val->rest || div->rest)\n+    return false;\n+\n+  if (!double_int_constant_multiple_p (val->offset, div->offset,\n+\t\t\t\t       &mult_set, mult))\n+    return false;\n+\n+  for (i = 0; i < div->n; i++)\n+    {\n+      struct aff_comb_elt *elt\n+\t      = aff_combination_find_elt (val, div->elts[i].val, NULL);\n+      if (!elt)\n+\treturn false;\n+      if (!double_int_constant_multiple_p (elt->coef, div->elts[i].coef,\n+\t\t\t\t\t   &mult_set, mult))\n+\treturn false;\n+    }\n+\n+  gcc_assert (mult_set);\n+  return true;\n+}"}, {"sha": "42ae230cf0361b386ddd6406b6cdbfb87e94ef6f", "filename": "gcc/tree-affine.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-affine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-affine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.h?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -70,3 +70,7 @@ void aff_combination_convert (aff_tree *, tree);\n void tree_to_aff_combination (tree, tree, aff_tree *);\n tree aff_combination_to_tree (aff_tree *);\n void unshare_aff_combination (aff_tree *);\n+bool aff_combination_constant_multiple_p (aff_tree *, aff_tree *, double_int *);\n+void tree_to_aff_combination_expand (tree, tree, aff_tree *,\n+\t\t\t\t     struct pointer_map_t **);\n+void free_affine_expand_cache (struct pointer_map_t **);"}, {"sha": "ce0b3fe52f9e987c56e25c58adbc3594d430bd30", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -573,8 +573,15 @@ split_constant_offset (tree exp, tree *var, tree *off)\n static tree\n canonicalize_base_object_address (tree addr)\n {\n+  tree orig = addr;\n+\n   STRIP_NOPS (addr);\n \n+  /* The base address may be obtained by casting from integer, in that case\n+     keep the cast.  */\n+  if (!POINTER_TYPE_P (TREE_TYPE (addr)))\n+    return orig;\n+\n   if (TREE_CODE (addr) != ADDR_EXPR)\n     return addr;\n \n@@ -584,7 +591,7 @@ canonicalize_base_object_address (tree addr)\n /* Analyzes the behavior of the memory reference DR in the innermost loop that\n    contains it.  */\n \n-static void\n+void\n dr_analyze_innermost (struct data_reference *dr)\n {\n   tree stmt = DR_STMT (dr);\n@@ -804,16 +811,6 @@ create_data_ref (struct loop *nest, tree memref, tree stmt, bool is_read)\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  /* FIXME -- data dependence analysis does not work correctly for objects with\n-     invariant addresses.  Let us fail here until the problem is fixed.  */\n-  if (dr_address_invariant_p (dr))\n-    {\n-      free_data_ref (dr);\n-      dr = NULL;\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"\\tFAILED as dr address is invariant\\n\");\n-    }\n-\n   return dr;  \n }\n \n@@ -3965,13 +3962,20 @@ find_data_references_in_stmt (struct loop *nest, tree stmt,\n   for (i = 0; VEC_iterate (data_ref_loc, references, i, ref); i++)\n     {\n       dr = create_data_ref (nest, *ref->pos, stmt, ref->is_read);\n-      if (dr)\n-\tVEC_safe_push (data_reference_p, heap, *datarefs, dr);\n-      else\n+      gcc_assert (dr != NULL);\n+  \n+      /* FIXME -- data dependence analysis does not work correctly for objects with\n+\t invariant addresses.  Let us fail here until the problem is fixed.  */\n+      if (dr_address_invariant_p (dr))\n \t{\n+\t  free_data_ref (dr);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"\\tFAILED as dr address is invariant\\n\");\n \t  ret = false;\n \t  break;\n \t}\n+\n+      VEC_safe_push (data_reference_p, heap, *datarefs, dr);\n     }\n   VEC_free (data_ref_loc, heap, references);\n   return ret;\n@@ -3992,7 +3996,7 @@ find_data_references_in_loop (struct loop *loop,\n   unsigned int i;\n   block_stmt_iterator bsi;\n \n-  bbs = get_loop_body (loop);\n+  bbs = get_loop_body_in_dom_order (loop);\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {"}, {"sha": "b53c6f17bfd6b508e47cfb427517e794638de7ff", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -299,6 +299,7 @@ DEF_VEC_O (data_ref_loc);\n DEF_VEC_ALLOC_O (data_ref_loc, heap);\n \n bool get_references_in_stmt (tree, VEC (data_ref_loc, heap) **);\n+void dr_analyze_innermost (struct data_reference *);\n extern void compute_data_dependences_for_loop (struct loop *, bool,\n \t\t\t\t\t       VEC (data_reference_p, heap) **,\n \t\t\t\t\t       VEC (ddr_p, heap) **);"}, {"sha": "40e80494c59ac21b5bb92406ffc5bd007ac9a9cf", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -786,6 +786,7 @@ extern bool cleanup_tree_cfg_loop (void);\n \n /* In tree-pretty-print.c.  */\n extern void dump_generic_bb (FILE *, basic_block, int, int);\n+extern const char *op_symbol_code (enum tree_code);\n \n /* In tree-dfa.c  */\n extern var_ann_t create_var_ann (tree);\n@@ -972,6 +973,7 @@ unsigned int tree_unroll_loops_completely (bool);\n unsigned int tree_ssa_prefetch_arrays (void);\n unsigned int remove_empty_loops (void);\n void tree_ssa_iv_optimize (void);\n+void tree_predictive_commoning (void);\n \n bool number_of_iterations_exit (struct loop *, edge,\n \t\t\t\tstruct tree_niter_desc *niter, bool);\n@@ -1017,6 +1019,7 @@ void tree_transform_and_unroll_loop (struct loop *, unsigned,\n \t\t\t\t     edge, struct tree_niter_desc *,\n \t\t\t\t     transform_callback, void *);\n bool contains_abnormal_ssa_name_p (tree);\n+bool stmt_dominates_stmt_p (tree, tree);\n \n /* In tree-ssa-threadedge.c */\n extern bool potentially_threadable_block (basic_block);\n@@ -1034,6 +1037,7 @@ enum move_pos\n     MOVE_POSSIBLE\t\t/* Unlimited movement.  */\n   };\n extern enum move_pos movement_possibility (tree);\n+char *get_lsm_tmp_name (tree, unsigned);\n \n /* The reasons a variable may escape a function.  */\n enum escape_type "}, {"sha": "95a3cd3769f953903b21493afe26717172aa8ecb", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -250,6 +250,7 @@ extern struct tree_opt_pass pass_tree_loop;\n extern struct tree_opt_pass pass_tree_loop_init;\n extern struct tree_opt_pass pass_lim;\n extern struct tree_opt_pass pass_tree_unswitch;\n+extern struct tree_opt_pass pass_predcom;\n extern struct tree_opt_pass pass_iv_canon;\n extern struct tree_opt_pass pass_scev_cprop;\n extern struct tree_opt_pass pass_empty_loop;"}, {"sha": "87459695413c59d8b1016fa6e212d7f9f310a079", "filename": "gcc/tree-predcom.c", "status": "added", "additions": 2567, "deletions": 0, "changes": 2567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -0,0 +1,2567 @@\n+/* Predictive commoning.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   \n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* This file implements the predictive commoning optimization.  Predictive\n+   commoning can be viewed as CSE around a loop, and with some improvements,\n+   as generalized strength reduction-- i.e., reusing values computed in\n+   earlier iterations of a loop in the later ones.  So far, the pass only\n+   handles the most useful case, that is, reusing values of memory references.\n+   If you think this is all just a special case of PRE, you are sort of right;\n+   however, concentrating on loops is simpler, and makes it possible to\n+   incorporate data dependence analysis to detect the opportunities, perform\n+   loop unrolling to avoid copies together with renaming immediately,\n+   and if needed, we could also take register pressure into account.\n+\n+   Let us demonstrate what is done on an example:\n+   \n+   for (i = 0; i < 100; i++)\n+     {\n+       a[i+2] = a[i] + a[i+1];\n+       b[10] = b[10] + i;\n+       c[i] = c[99 - i];\n+       d[i] = d[i + 1];\n+     }\n+\n+   1) We find data references in the loop, and split them to mutually\n+      independent groups (i.e., we find components of a data dependence\n+      graph).  We ignore read-read dependences whose distance is not constant.\n+      (TODO -- we could also ignore antidependences).  In this example, we\n+      find the following groups:\n+\n+      a[i]{read}, a[i+1]{read}, a[i+2]{write}\n+      b[10]{read}, b[10]{write}\n+      c[99 - i]{read}, c[i]{write}\n+      d[i + 1]{read}, d[i]{write}\n+\n+   2) Inside each of the group, we verify several conditions:\n+      a) all the references must differ in indices only, and the indices\n+\t must all have the same step\n+      b) the references must dominate loop latch (and thus, they must be\n+\t ordered by dominance relation).\n+      c) the distance of the indices must be a small multiple of the step\n+      We are then able to compute the difference of the references (# of\n+      iterations before they point to the same place as the first of them).\n+      Also, in case there are writes in the loop, we split the groups into\n+      chains whose head is the write whose values are used by the reads in\n+      the same chain.  The chains are then processed independently,\n+      making the further transformations simpler.  Also, the shorter chains\n+      need the same number of registers, but may require lower unrolling\n+      factor in order to get rid of the copies on the loop latch.\n+      \n+      In our example, we get the following chains (the chain for c is invalid).\n+\n+      a[i]{read,+0}, a[i+1]{read,-1}, a[i+2]{write,-2}\n+      b[10]{read,+0}, b[10]{write,+0}\n+      d[i + 1]{read,+0}, d[i]{write,+1}\n+\n+   3) For each read, we determine the read or write whose value it reuses,\n+      together with the distance of this reuse.  I.e. we take the last\n+      reference before it with distance 0, or the last of the references\n+      with the smallest positive distance to the read.  Then, we remove\n+      the references that are not used in any of these chains, discard the\n+      empty groups, and propagate all the links so that they point to the\n+      single root reference of the chain (adjusting their distance \n+      appropriately).  Some extra care needs to be taken for references with\n+      step 0.  In our example (the numbers indicate the distance of the\n+      reuse),\n+\n+      a[i] --> (*) 2, a[i+1] --> (*) 1, a[i+2] (*)\n+      b[10] --> (*) 1, b[10] (*)\n+\n+   4) The chains are combined together if possible.  If the corresponding\n+      elements of two chains are always combined together with the same\n+      operator, we remember just the result of this combination, instead\n+      of remembering the values separately.  We may need to perform\n+      reassociation to enable combining, for example\n+\n+      e[i] + f[i+1] + e[i+1] + f[i]\n+\n+      can be reassociated as\n+\n+      (e[i] + f[i]) + (e[i+1] + f[i+1])\n+\n+      and we can combine the chains for e and f into one chain.\n+\n+   5) For each root reference (end of the chain) R, let N be maximum distance\n+      of a reference reusing its value.  Variables R0 upto RN are created,\n+      together with phi nodes that transfer values from R1 .. RN to\n+      R0 .. R(N-1).\n+      Initial values are loaded to R0..R(N-1) (in case not all references\n+      must necessarily be accessed and they may trap, we may fail here;\n+      TODO sometimes, the loads could be guarded by a check for the number\n+      of iterations).  Values loaded/stored in roots are also copied to\n+      RN.  Other reads are replaced with the appropriate variable Ri.\n+      Everything is put to SSA form.\n+\n+      As a small improvement, if R0 is dead after the root (i.e., all uses of\n+      the value with the maximum distance dominate the root), we can avoid\n+      creating RN and use R0 instead of it.\n+\n+      In our example, we get (only the parts concerning a and b are shown):\n+      for (i = 0; i < 100; i++)\n+\t{\n+\t  f = phi (a[0], s);\n+\t  s = phi (a[1], f);\n+\t  x = phi (b[10], x);\n+\n+\t  f = f + s;\n+\t  a[i+2] = f;\n+\t  x = x + i;\n+\t  b[10] = x;\n+\t}\n+\n+   6) Factor F for unrolling is determined as the smallest common multiple of\n+      (N + 1) for each root reference (N for references for that we avoided\n+      creating RN).  If F and the loop is small enough, loop is unrolled F\n+      times.  The stores to RN (R0) in the copies of the loop body are\n+      periodically replaced with R0, R1, ... (R1, R2, ...), so that they can\n+      be coalesced and the copies can be eliminated.\n+      \n+      TODO -- copy propagation and other optimizations may change the live\n+      ranges of the temporary registers and prevent them from being coalesced;\n+      this may increase the register pressure.\n+\n+      In our case, F = 2 and the (main loop of the) result is\n+\n+      for (i = 0; i < ...; i += 2)\n+        {\n+          f = phi (a[0], f);\n+          s = phi (a[1], s);\n+          x = phi (b[10], x);\n+\n+          f = f + s;\n+          a[i+2] = f;\n+          x = x + i;\n+          b[10] = x;\n+\n+          s = s + f;\n+          a[i+3] = s;\n+          x = x + i;\n+          b[10] = x;\n+       }\n+\n+   TODO -- stores killing other stores can be taken into account, e.g.,\n+   for (i = 0; i < n; i++)\n+     {\n+       a[i] = 1;\n+       a[i+2] = 2;\n+     }\n+\n+   can be replaced with\n+\n+   t0 = a[0];\n+   t1 = a[1];\n+   for (i = 0; i < n; i++)\n+     {\n+       a[i] = 1;\n+       t2 = 2;\n+       t0 = t1;\n+       t1 = t2;\n+     }\n+   a[n] = t0;\n+   a[n+1] = t1;\n+\n+   The interesting part is that this would generalize store motion; still, since\n+   sm is performed elsewhere, it does not seem that important.\n+\n+   Predictive commoning can be generalized for arbitrary computations (not\n+   just memory loads), and also nontrivial transfer functions (e.g., replacing\n+   i * i with ii_last + 2 * i + 1), to generalize strength reduction.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"tm_p.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-flow.h\"\n+#include \"ggc.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-chrec.h\"\n+#include \"params.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-affine.h\"\n+#include \"tree-inline.h\"\n+\n+/* The maximum number of iterations between the considered memory\n+   references.  */\n+\n+#define MAX_DISTANCE (target_avail_regs < 16 ? 4 : 8)\n+   \n+/* Data references.  */\n+\n+typedef struct dref\n+{\n+  /* The reference itself.  */\n+  struct data_reference *ref;\n+\n+  /* The statement in that the reference appears.  */\n+  tree stmt;\n+\n+  /* Distance of the reference from the root of the chain (in number of\n+     iterations of the loop).  */\n+  unsigned distance;\n+\n+  /* Number of iterations offset from the first reference in the component.  */\n+  double_int offset;\n+\n+  /* Number of the reference in a component, in dominance ordering.  */\n+  unsigned pos;\n+\n+  /* True if the memory reference is always accessed when the loop is\n+     entered.  */\n+  unsigned always_accessed : 1;\n+} *dref;\n+\n+DEF_VEC_P (dref);\n+DEF_VEC_ALLOC_P (dref, heap);\n+\n+/* Type of the chain of the references.  */\n+\n+enum chain_type\n+{\n+  /* The addresses of the references in the chain are constant.  */\n+  CT_INVARIANT,\n+\n+  /* There are only loads in the chain.  */\n+  CT_LOAD,\n+\n+  /* Root of the chain is store, the rest are loads.  */\n+  CT_STORE_LOAD,\n+\n+  /* A combination of two chains.  */\n+  CT_COMBINATION\n+};\n+\n+/* Chains of data references.  */\n+\n+typedef struct chain\n+{\n+  /* Type of the chain.  */\n+  enum chain_type type;\n+\n+  /* For combination chains, the operator and the two chains that are\n+     combined, and the type of the result.  */\n+  enum tree_code operator;\n+  tree rslt_type;\n+  struct chain *ch1, *ch2;\n+\n+  /* The references in the chain.  */\n+  VEC(dref,heap) *refs;\n+\n+  /* The maximum distance of the reference in the chain from the root.  */\n+  unsigned length;\n+\n+  /* The variables used to copy the value throughout iterations.  */\n+  VEC(tree,heap) *vars;\n+\n+  /* Initializers for the variables.  */\n+  VEC(tree,heap) *inits;\n+\n+  /* True if there is a use of a variable with the maximal distance\n+     that comes after the root in the loop.  */\n+  unsigned has_max_use_after : 1;\n+\n+  /* True if all the memory references in the chain are always accessed.  */\n+  unsigned all_always_accessed : 1;\n+\n+  /* True if this chain was combined together with some other chain.  */\n+  unsigned combined : 1;\n+} *chain_p;\n+\n+DEF_VEC_P (chain_p);\n+DEF_VEC_ALLOC_P (chain_p, heap);\n+\n+/* Describes the knowledge about the step of the memory references in\n+   the component.  */\n+\n+enum ref_step_type\n+{\n+  /* The step is zero.  */\n+  RS_INVARIANT,\n+\n+  /* The step is nonzero.  */\n+  RS_NONZERO,\n+\n+  /* The step may or may not be nonzero.  */\n+  RS_ANY\n+};\n+\n+/* Components of the data dependence graph.  */\n+\n+struct component\n+{\n+  /* The references in the component.  */\n+  VEC(dref,heap) *refs;\n+\n+  /* What we know about the step of the references in the component.  */\n+  enum ref_step_type comp_step;\n+\n+  /* Next component in the list.  */\n+  struct component *next;\n+};\n+\n+/* Bitmap of ssa names defined by looparound phi nodes covered by chains.  */\n+\n+static bitmap looparound_phis;\n+\n+/* Cache used by tree_to_aff_combination_expand.  */\n+\n+static struct pointer_map_t *name_expansions;\n+\n+/* Dumps data reference REF to FILE.  */\n+\n+extern void dump_dref (FILE *, dref);\n+void\n+dump_dref (FILE *file, dref ref)\n+{\n+  if (ref->ref)\n+    {\n+      fprintf (file, \"    \");\n+      print_generic_expr (file, DR_REF (ref->ref), TDF_SLIM);\n+      fprintf (file, \" (id %u%s)\\n\", ref->pos,\n+\t       DR_IS_READ (ref->ref) ? \"\" : \", write\");\n+\n+      fprintf (file, \"      offset \");\n+      dump_double_int (file, ref->offset, false);\n+      fprintf (file, \"\\n\");\n+\n+      fprintf (file, \"      distance %u\\n\", ref->distance);\n+    }\n+  else\n+    {\n+      if (TREE_CODE (ref->stmt) == PHI_NODE)\n+\tfprintf (file, \"    looparound ref\\n\");\n+      else\n+\tfprintf (file, \"    combination ref\\n\");\n+      fprintf (file, \"      in statement \");\n+      print_generic_expr (file, ref->stmt, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+      fprintf (file, \"      distance %u\\n\", ref->distance);\n+    }\n+\n+}\n+\n+/* Dumps CHAIN to FILE.  */\n+\n+extern void dump_chain (FILE *, chain_p);\n+void\n+dump_chain (FILE *file, chain_p chain)\n+{\n+  dref a;\n+  const char *chain_type;\n+  unsigned i;\n+  tree var;\n+\n+  switch (chain->type)\n+    {\n+    case CT_INVARIANT:\n+      chain_type = \"Load motion\";\n+      break;\n+\n+    case CT_LOAD:\n+      chain_type = \"Loads-only\";\n+      break;\n+\n+    case CT_STORE_LOAD:\n+      chain_type = \"Store-loads\";\n+      break;\n+\n+    case CT_COMBINATION:\n+      chain_type = \"Combination\";\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  fprintf (file, \"%s chain %p%s\\n\", chain_type, (void *) chain,\n+\t   chain->combined ? \" (combined)\" : \"\");\n+  if (chain->type != CT_INVARIANT)\n+    fprintf (file, \"  max distance %u%s\\n\", chain->length,\n+\t     chain->has_max_use_after ? \"\" : \", may reuse first\");\n+\n+  if (chain->type == CT_COMBINATION)\n+    {\n+      fprintf (file, \"  equal to %p %s %p in type \",\n+\t       (void *) chain->ch1, op_symbol_code (chain->operator),\n+\t       (void *) chain->ch2);\n+      print_generic_expr (file, chain->rslt_type, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n+\n+  if (chain->vars)\n+    {\n+      fprintf (file, \"  vars\");\n+      for (i = 0; VEC_iterate (tree, chain->vars, i, var); i++)\n+\t{\n+\t  fprintf (file, \" \");\n+\t  print_generic_expr (file, var, TDF_SLIM);\n+\t}\n+      fprintf (file, \"\\n\");\n+    }\n+\n+  if (chain->inits)\n+    {\n+      fprintf (file, \"  inits\");\n+      for (i = 0; VEC_iterate (tree, chain->inits, i, var); i++)\n+\t{\n+\t  fprintf (file, \" \");\n+\t  print_generic_expr (file, var, TDF_SLIM);\n+\t}\n+      fprintf (file, \"\\n\");\n+    }\n+\n+  fprintf (file, \"  references:\\n\");\n+  for (i = 0; VEC_iterate (dref, chain->refs, i, a); i++)\n+    dump_dref (file, a);\n+\n+  fprintf (file, \"\\n\");\n+}\n+\n+/* Dumps CHAINS to FILE.  */\n+\n+extern void dump_chains (FILE *, VEC (chain_p, heap) *);\n+void\n+dump_chains (FILE *file, VEC (chain_p, heap) *chains)\n+{\n+  chain_p chain;\n+  unsigned i;\n+\n+  for (i = 0; VEC_iterate (chain_p, chains, i, chain); i++)\n+    dump_chain (file, chain);\n+}\n+\n+/* Dumps COMP to FILE.  */\n+\n+extern void dump_component (FILE *, struct component *);\n+void\n+dump_component (FILE *file, struct component *comp)\n+{\n+  dref a;\n+  unsigned i;\n+\n+  fprintf (file, \"Component%s:\\n\",\n+\t   comp->comp_step == RS_INVARIANT ? \" (invariant)\" : \"\");\n+  for (i = 0; VEC_iterate (dref, comp->refs, i, a); i++)\n+    dump_dref (file, a);\n+  fprintf (file, \"\\n\");\n+}\n+\n+/* Dumps COMPS to FILE.  */\n+\n+extern void dump_components (FILE *, struct component *);\n+void\n+dump_components (FILE *file, struct component *comps)\n+{\n+  struct component *comp;\n+\n+  for (comp = comps; comp; comp = comp->next)\n+    dump_component (file, comp);\n+}\n+\n+/* Frees a chain CHAIN.  */\n+\n+static void\n+release_chain (chain_p chain)\n+{\n+  dref ref;\n+  unsigned i;\n+\n+  if (chain == NULL)\n+    return;\n+\n+  for (i = 0; VEC_iterate (dref, chain->refs, i, ref); i++)\n+    free (ref);\n+\n+  VEC_free (dref, heap, chain->refs);\n+  VEC_free (tree, heap, chain->vars);\n+  VEC_free (tree, heap, chain->inits);\n+\n+  free (chain);\n+}\n+\n+/* Frees CHAINS.  */\n+\n+static void\n+release_chains (VEC (chain_p, heap) *chains)\n+{\n+  unsigned i;\n+  chain_p chain;\n+\n+  for (i = 0; VEC_iterate (chain_p, chains, i, chain); i++)\n+    release_chain (chain);\n+  VEC_free (chain_p, heap, chains);\n+}\n+\n+/* Frees a component COMP.  */\n+\n+static void\n+release_component (struct component *comp)\n+{\n+  VEC_free (dref, heap, comp->refs);\n+  free (comp);\n+}\n+\n+/* Frees list of components COMPS.  */\n+\n+static void\n+release_components (struct component *comps)\n+{\n+  struct component *act, *next;\n+\n+  for (act = comps; act; act = next)\n+    {\n+      next = act->next;\n+      release_component (act);\n+    }\n+}\n+\n+/* Finds a root of tree given by FATHERS containing A, and performs path\n+   shortening.  */\n+\n+static unsigned\n+component_of (unsigned fathers[], unsigned a)\n+{\n+  unsigned root, n;\n+\n+  for (root = a; root != fathers[root]; root = fathers[root])\n+    continue;\n+\n+  for (; a != root; a = n)\n+    {\n+      n = fathers[a];\n+      fathers[a] = root;\n+    }\n+\n+  return root;\n+}\n+\n+/* Join operation for DFU.  FATHERS gives the tree, SIZES are sizes of the\n+   components, A and B are components to merge.  */\n+\n+static void\n+merge_comps (unsigned fathers[], unsigned sizes[], unsigned a, unsigned b)\n+{\n+  unsigned ca = component_of (fathers, a);\n+  unsigned cb = component_of (fathers, b);\n+\n+  if (ca == cb)\n+    return;\n+\n+  if (sizes[ca] < sizes[cb])\n+    {\n+      sizes[cb] += sizes[ca];\n+      fathers[ca] = cb;\n+    }\n+  else\n+    {\n+      sizes[ca] += sizes[cb];\n+      fathers[cb] = ca;\n+    }\n+}\n+\n+/* Returns true if A is a reference that is suitable for predictive commoning\n+   in the innermost loop that contains it.  REF_STEP is set according to the\n+   step of the reference A.  */\n+\n+static bool\n+suitable_reference_p (struct data_reference *a, enum ref_step_type *ref_step)\n+{\n+  tree ref = DR_REF (a), step = DR_STEP (a);\n+\n+  if (!step\n+      || !is_gimple_reg_type (TREE_TYPE (ref)))\n+    return false;\n+\n+  if (integer_zerop (step))\n+    *ref_step = RS_INVARIANT;\n+  else if (integer_nonzerop (step))\n+    *ref_step = RS_NONZERO;\n+  else\n+    *ref_step = RS_ANY;\n+\n+  return true;\n+}\n+\n+/* Stores DR_OFFSET (DR) + DR_INIT (DR) to OFFSET.  */\n+\n+static void\n+aff_combination_dr_offset (struct data_reference *dr, aff_tree *offset)\n+{\n+  aff_tree delta;\n+\n+  tree_to_aff_combination_expand (DR_OFFSET (dr), sizetype, offset,\n+\t\t\t\t  &name_expansions);\n+  aff_combination_const (&delta, sizetype, tree_to_double_int (DR_INIT (dr)));\n+  aff_combination_add (offset, &delta);\n+}\n+\n+/* Determines number of iterations of the innermost enclosing loop before B\n+   refers to exactly the same location as A and stores it to OFF.  If A and\n+   B do not have the same step, they never meet, or anything else fails,\n+   returns false, otherwise returns true.  Both A and B are assumed to\n+   satisfy suitable_reference_p.  */\n+\n+static bool\n+determine_offset (struct data_reference *a, struct data_reference *b,\n+\t\t  double_int *off)\n+{\n+  aff_tree diff, baseb, step;\n+\n+  /* Check whether the base address and the step of both references is the\n+     same.  */\n+  if (!operand_equal_p (DR_STEP (a), DR_STEP (b), 0)\n+      || !operand_equal_p (DR_BASE_ADDRESS (a), DR_BASE_ADDRESS (b), 0))\n+    return false;\n+\n+  if (integer_zerop (DR_STEP (a)))\n+    {\n+      /* If the references have loop invariant address, check that they access\n+\t exactly the same location.  */\n+      *off = double_int_zero;\n+      return (operand_equal_p (DR_OFFSET (a), DR_OFFSET (b), 0)\n+\t      && operand_equal_p (DR_INIT (a), DR_INIT (b), 0));\n+    }\n+\n+  /* Compare the offsets of the addresses, and check whether the difference\n+     is a multiple of step.  */\n+  aff_combination_dr_offset (a, &diff);\n+  aff_combination_dr_offset (b, &baseb);\n+  aff_combination_scale (&baseb, double_int_minus_one);\n+  aff_combination_add (&diff, &baseb);\n+\n+  tree_to_aff_combination_expand (DR_STEP (a), sizetype,\n+\t\t\t\t  &step, &name_expansions);\n+  return aff_combination_constant_multiple_p (&diff, &step, off);\n+}\n+\n+/* Returns the last basic block in LOOP for that we are sure that\n+   it is executed whenever the loop is entered.  */\n+\n+static basic_block\n+last_always_executed_block (struct loop *loop)\n+{\n+  unsigned i;\n+  VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n+  edge ex;\n+  basic_block last = loop->latch;\n+\n+  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n+    last = nearest_common_dominator (CDI_DOMINATORS, last, ex->src);\n+  VEC_free (edge, heap, exits);\n+\n+  return last;\n+}\n+\n+/* Splits dependence graph on DATAREFS described by DEPENDS to components.  */\n+\n+static struct component *\n+split_data_refs_to_components (struct loop *loop,\n+\t\t\t       VEC (data_reference_p, heap) *datarefs,\n+\t\t\t       VEC (ddr_p, heap) *depends)\n+{\n+  unsigned i, n = VEC_length (data_reference_p, datarefs);\n+  unsigned ca, ia, ib, bad;\n+  unsigned *comp_father = XNEWVEC (unsigned, n + 1);\n+  unsigned *comp_size = XNEWVEC (unsigned, n + 1);\n+  struct component **comps;\n+  struct data_reference *dr, *dra, *drb;\n+  struct data_dependence_relation *ddr;\n+  struct component *comp_list = NULL, *comp;\n+  dref dataref;\n+  basic_block last_always_executed = last_always_executed_block (loop);\n+ \n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+    {\n+      if (!DR_REF (dr))\n+\t{\n+\t  /* A fake reference for call or asm_expr that may clobber memory;\n+\t     just fail.  */\n+\t  goto end;\n+\t}\n+      dr->aux = i;\n+      comp_father[i] = i;\n+      comp_size[i] = 1;\n+    }\n+\n+  /* A component reserved for the \"bad\" data references.  */\n+  comp_father[n] = n;\n+  comp_size[n] = 1;\n+\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+    {\n+      enum ref_step_type dummy;\n+\n+      if (!suitable_reference_p (dr, &dummy))\n+\t{\n+\t  ia = dr->aux;\n+\t  merge_comps (comp_father, comp_size, n, ia);\n+\t}\n+    }\n+\n+  for (i = 0; VEC_iterate (ddr_p, depends, i, ddr); i++)\n+    {\n+      double_int dummy_off;\n+\n+      if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+\tcontinue;\n+\n+      dra = DDR_A (ddr);\n+      drb = DDR_B (ddr);\n+      ia = component_of (comp_father, dra->aux);\n+      ib = component_of (comp_father, drb->aux);\n+      if (ia == ib)\n+\tcontinue;\n+\n+      bad = component_of (comp_father, n);\n+\n+      /* If both A and B are reads, we may ignore unsuitable dependences.  */\n+      if (DR_IS_READ (dra) && DR_IS_READ (drb)\n+\t  && (ia == bad || ib == bad\n+\t      || !determine_offset (dra, drb, &dummy_off)))\n+\tcontinue;\n+\t  \n+      merge_comps (comp_father, comp_size, ia, ib);\n+    }\n+\n+  comps = XCNEWVEC (struct component *, n);\n+  bad = component_of (comp_father, n);\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+    {\n+      ia = dr->aux;\n+      ca = component_of (comp_father, ia);\n+      if (ca == bad)\n+\tcontinue;\n+\n+      comp = comps[ca];\n+      if (!comp)\n+\t{\n+\t  comp = XCNEW (struct component);\n+\t  comp->refs = VEC_alloc (dref, heap, comp_size[ca]);\n+\t  comps[ca] = comp;\n+\t}\n+\n+      dataref = XCNEW (struct dref);\n+      dataref->ref = dr;\n+      dataref->stmt = DR_STMT (dr);\n+      dataref->offset = double_int_zero;\n+      dataref->distance = 0;\n+\n+      dataref->always_accessed\n+\t      = dominated_by_p (CDI_DOMINATORS, last_always_executed,\n+\t\t\t\tbb_for_stmt (dataref->stmt));\n+      dataref->pos = VEC_length (dref, comp->refs);\n+      VEC_quick_push (dref, comp->refs, dataref);\n+    }\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      comp = comps[i];\n+      if (comp)\n+\t{\n+\t  comp->next = comp_list;\n+\t  comp_list = comp;\n+\t}\n+    }\n+  free (comps);\n+\n+end:\n+  free (comp_father);\n+  free (comp_size);\n+  return comp_list;\n+}\n+\n+/* Returns true if the component COMP satisfies the conditions\n+   described in 2) at the begining of this file.  LOOP is the current\n+   loop.  */\n+      \n+static bool\n+suitable_component_p (struct loop *loop, struct component *comp)\n+{\n+  unsigned i;\n+  dref a, first;\n+  basic_block ba, bp = loop->header;\n+  bool ok, has_write = false;\n+\n+  for (i = 0; VEC_iterate (dref, comp->refs, i, a); i++)\n+    {\n+      ba = bb_for_stmt (a->stmt);\n+\n+      if (!just_once_each_iteration_p (loop, ba))\n+\treturn false;\n+\n+      gcc_assert (dominated_by_p (CDI_DOMINATORS, ba, bp));\n+      bp = ba;\n+\n+      if (!DR_IS_READ (a->ref))\n+\thas_write = true;\n+    }\n+\n+  first = VEC_index (dref, comp->refs, 0);\n+  ok = suitable_reference_p (first->ref, &comp->comp_step);\n+  gcc_assert (ok);\n+  first->offset = double_int_zero;\n+\n+  for (i = 1; VEC_iterate (dref, comp->refs, i, a); i++)\n+    {\n+      if (!determine_offset (first->ref, a->ref, &a->offset))\n+\treturn false;\n+\n+#ifdef ENABLE_CHECKING\n+      {\n+\tenum ref_step_type a_step;\n+\tok = suitable_reference_p (a->ref, &a_step);\n+\tgcc_assert (ok && a_step == comp->comp_step);\n+      }\n+#endif\n+    }\n+\n+  /* If there is a write inside the component, we must know whether the\n+     step is nonzero or not -- we would not otherwise be able to recognize\n+     whether the value accessed by reads comes from the OFFSET-th iteration\n+     or the previous one.  */\n+  if (has_write && comp->comp_step == RS_ANY)\n+    return false;\n+\n+  return true;\n+}\n+      \n+/* Check the conditions on references inside each of components COMPS,\n+   and remove the unsuitable components from the list.  The new list\n+   of components is returned.  The conditions are described in 2) at\n+   the begining of this file.  LOOP is the current loop.  */\n+\n+static struct component *\n+filter_suitable_components (struct loop *loop, struct component *comps)\n+{\n+  struct component **comp, *act;\n+\n+  for (comp = &comps; *comp; )\n+    {\n+      act = *comp;\n+      if (suitable_component_p (loop, act))\n+\tcomp = &act->next;\n+      else\n+\t{\n+\t  *comp = act->next;\n+\t  release_component (act);\n+\t}\n+    }\n+\n+  return comps;\n+}\n+\n+/* Compares two drefs A and B by their offset and position.  Callback for\n+   qsort.  */\n+\n+static int\n+order_drefs (const void *a, const void *b)\n+{\n+  const dref *da = a;\n+  const dref *db = b;\n+  int offcmp = double_int_scmp ((*da)->offset, (*db)->offset);\n+\n+  if (offcmp != 0)\n+    return offcmp;\n+\n+  return (*da)->pos - (*db)->pos;\n+}\n+\n+/* Returns root of the CHAIN.  */\n+\n+static inline dref\n+get_chain_root (chain_p chain)\n+{\n+  return VEC_index (dref, chain->refs, 0);\n+}\n+\n+/* Adds REF to the chain CHAIN.  */\n+\n+static void\n+add_ref_to_chain (chain_p chain, dref ref)\n+{\n+  dref root = get_chain_root (chain);\n+  double_int dist;\n+\n+  gcc_assert (double_int_scmp (root->offset, ref->offset) <= 0);\n+  dist = double_int_add (ref->offset, double_int_neg (root->offset));\n+  if (double_int_ucmp (uhwi_to_double_int (MAX_DISTANCE), dist) <= 0)\n+    return;\n+  gcc_assert (double_int_fits_in_uhwi_p (dist));\n+\n+  VEC_safe_push (dref, heap, chain->refs, ref);\n+\n+  ref->distance = double_int_to_uhwi (dist);\n+\n+  if (ref->distance >= chain->length)\n+    {\n+      chain->length = ref->distance;\n+      chain->has_max_use_after = false;\n+    }\n+\n+  if (ref->distance == chain->length\n+      && ref->pos > root->pos)\n+    chain->has_max_use_after = true;\n+\n+  chain->all_always_accessed &= ref->always_accessed;\n+}\n+\n+/* Returns the chain for invariant component COMP.  */\n+\n+static chain_p\n+make_invariant_chain (struct component *comp)\n+{\n+  chain_p chain = XCNEW (struct chain);\n+  unsigned i;\n+  dref ref;\n+\n+  chain->type = CT_INVARIANT;\n+\n+  chain->all_always_accessed = true;\n+\n+  for (i = 0; VEC_iterate (dref, comp->refs, i, ref); i++)\n+    {\n+      VEC_safe_push (dref, heap, chain->refs, ref);\n+      chain->all_always_accessed &= ref->always_accessed;\n+    }\n+\n+  return chain;\n+}\n+\n+/* Make a new chain rooted at REF.  */\n+\n+static chain_p\n+make_rooted_chain (dref ref)\n+{\n+  chain_p chain = XCNEW (struct chain);\n+\n+  chain->type = DR_IS_READ (ref->ref) ? CT_LOAD : CT_STORE_LOAD;\n+\n+  VEC_safe_push (dref, heap, chain->refs, ref);\n+  chain->all_always_accessed = ref->always_accessed;\n+\n+  ref->distance = 0;\n+\n+  return chain;\n+}\n+\n+/* Returns true if CHAIN is not trivial.  */\n+\n+static bool\n+nontrivial_chain_p (chain_p chain)\n+{\n+  return chain != NULL && VEC_length (dref, chain->refs) > 1;\n+}\n+\n+/* Returns the ssa name that contains the value of REF, or NULL_TREE if there\n+   is no such name.  */\n+\n+static tree\n+name_for_ref (dref ref)\n+{\n+  tree name;\n+\n+  if (TREE_CODE (ref->stmt) == GIMPLE_MODIFY_STMT)\n+    {\n+      if (!ref->ref || DR_IS_READ (ref->ref))\n+\tname = GIMPLE_STMT_OPERAND (ref->stmt, 0);\n+      else\n+\tname = GIMPLE_STMT_OPERAND (ref->stmt, 1);\n+    }\n+  else\n+    name = PHI_RESULT (ref->stmt);\n+\n+  return (TREE_CODE (name) == SSA_NAME ? name : NULL_TREE);\n+}\n+\n+/* Returns true if REF is a valid initializer for ROOT with given DISTANCE (in\n+   iterations of the innermost enclosing loop).  */\n+\n+static bool\n+valid_initializer_p (struct data_reference *ref,\n+\t\t     unsigned distance, struct data_reference *root)\n+{\n+  aff_tree diff, base, step;\n+  double_int off;\n+\n+  if (!DR_BASE_ADDRESS (ref))\n+    return false;\n+\n+  /* Both REF and ROOT must be accessing the same object.  */\n+  if (!operand_equal_p (DR_BASE_ADDRESS (ref), DR_BASE_ADDRESS (root), 0))\n+    return false;\n+\n+  /* The initializer is defined outside of loop, hence its address must be\n+     invariant inside the loop.  */\n+  gcc_assert (integer_zerop (DR_STEP (ref)));\n+\n+  /* If the address of the reference is invariant, initializer must access\n+     exactly the same location.  */\n+  if (integer_zerop (DR_STEP (root)))\n+    return (operand_equal_p (DR_OFFSET (ref), DR_OFFSET (root), 0)\n+\t    && operand_equal_p (DR_INIT (ref), DR_INIT (root), 0));\n+\n+  /* Verify that this index of REF is equal to the root's index at\n+     -DISTANCE-th iteration.  */\n+  aff_combination_dr_offset (root, &diff);\n+  aff_combination_dr_offset (ref, &base);\n+  aff_combination_scale (&base, double_int_minus_one);\n+  aff_combination_add (&diff, &base);\n+\n+  tree_to_aff_combination_expand (DR_STEP (root), sizetype, &step,\n+\t\t\t\t  &name_expansions);\n+  if (!aff_combination_constant_multiple_p (&diff, &step, &off))\n+    return false;\n+\n+  if (!double_int_equal_p (off, uhwi_to_double_int (distance)))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Finds looparound phi node of LOOP that copies the value of REF, and if its\n+   initial value is correct (equal to initial value of REF shifted by one\n+   iteration), returns the phi node.  Otherwise, NULL_TREE is returned.  ROOT\n+   is the root of the current chain.  */\n+\n+static tree\n+find_looparound_phi (struct loop *loop, dref ref, dref root)\n+{\n+  tree name, phi, init, init_stmt, init_ref;\n+  edge latch = loop_latch_edge (loop);\n+  struct data_reference init_dr;\n+\n+  if (TREE_CODE (ref->stmt) == GIMPLE_MODIFY_STMT)\n+    {\n+      if (DR_IS_READ (ref->ref))\n+\tname = GIMPLE_STMT_OPERAND (ref->stmt, 0);\n+      else\n+\tname = GIMPLE_STMT_OPERAND (ref->stmt, 1);\n+    }\n+  else\n+    name = PHI_RESULT (ref->stmt);\n+  if (!name)\n+    return NULL_TREE;\n+\n+  for (phi = phi_nodes (loop->header); phi; phi = PHI_CHAIN (phi))\n+    if (PHI_ARG_DEF_FROM_EDGE (phi, latch) == name)\n+      break;\n+\n+  if (!phi)\n+    return NULL_TREE;\n+\n+  init = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (loop));\n+  if (TREE_CODE (init) != SSA_NAME)\n+    return NULL_TREE;\n+  init_stmt = SSA_NAME_DEF_STMT (init);\n+  if (TREE_CODE (init_stmt) != GIMPLE_MODIFY_STMT)\n+    return NULL_TREE;\n+  gcc_assert (GIMPLE_STMT_OPERAND (init_stmt, 0) == init);\n+\n+  init_ref = GIMPLE_STMT_OPERAND (init_stmt, 1);\n+  if (!REFERENCE_CLASS_P (init_ref)\n+      && !DECL_P (init_ref))\n+    return NULL_TREE;\n+\n+  /* Analyze the behavior of INIT_REF with respect to LOOP (innermost\n+     loop enclosing PHI).  */\n+  memset (&init_dr, 0, sizeof (struct data_reference));\n+  DR_REF (&init_dr) = init_ref;\n+  DR_STMT (&init_dr) = phi;\n+  dr_analyze_innermost (&init_dr);\n+\n+  if (!valid_initializer_p (&init_dr, ref->distance + 1, root->ref))\n+    return NULL_TREE;\n+\n+  return phi;\n+}\n+\n+/* Adds a reference for the looparound copy of REF in PHI to CHAIN.  */\n+\n+static void\n+insert_looparound_copy (chain_p chain, dref ref, tree phi)\n+{\n+  dref nw = XCNEW (struct dref), aref;\n+  unsigned i;\n+\n+  nw->stmt = phi;\n+  nw->distance = ref->distance + 1;\n+  nw->always_accessed = 1;\n+\n+  for (i = 0; VEC_iterate (dref, chain->refs, i, aref); i++)\n+    if (aref->distance >= nw->distance)\n+      break;\n+  VEC_safe_insert (dref, heap, chain->refs, i, nw);\n+\n+  if (nw->distance > chain->length)\n+    {\n+      chain->length = nw->distance;\n+      chain->has_max_use_after = false;\n+    }\n+}\n+\n+/* For references in CHAIN that are copied around the LOOP (created previously\n+   by PRE, or by user), add the results of such copies to the chain.  This\n+   enables us to remove the copies by unrolling, and may need less registers\n+   (also, it may allow us to combine chains together).  */\n+\n+static void\n+add_looparound_copies (struct loop *loop, chain_p chain)\n+{\n+  unsigned i;\n+  dref ref, root = get_chain_root (chain);\n+  tree phi;\n+\n+  for (i = 0; VEC_iterate (dref, chain->refs, i, ref); i++)\n+    {\n+      phi = find_looparound_phi (loop, ref, root);\n+      if (!phi)\n+\tcontinue;\n+\n+      bitmap_set_bit (looparound_phis, SSA_NAME_VERSION (PHI_RESULT (phi)));\n+      insert_looparound_copy (chain, ref, phi);\n+    }\n+}\n+\n+/* Find roots of the values and determine distances in the component COMP.\n+   The references are redistributed into CHAINS.  LOOP is the current\n+   loop.  */\n+\n+static void\n+determine_roots_comp (struct loop *loop,\n+\t\t      struct component *comp,\n+\t\t      VEC (chain_p, heap) **chains)\n+{\n+  unsigned i;\n+  dref a;\n+  chain_p chain = NULL;\n+\n+  /* Invariants are handled specially.  */\n+  if (comp->comp_step == RS_INVARIANT)\n+    {\n+      chain = make_invariant_chain (comp);\n+      VEC_safe_push (chain_p, heap, *chains, chain);\n+      return;\n+    }\n+\n+  qsort (VEC_address (dref, comp->refs), VEC_length (dref, comp->refs),\n+\t sizeof (dref), order_drefs);\n+\n+  for (i = 0; VEC_iterate (dref, comp->refs, i, a); i++)\n+    {\n+      if (!chain || !DR_IS_READ (a->ref))\n+\t{\n+\t  if (nontrivial_chain_p (chain))\n+\t    VEC_safe_push (chain_p, heap, *chains, chain);\n+\t  else\n+\t    release_chain (chain);\n+\t  chain = make_rooted_chain (a);\n+\t  continue;\n+\t}\n+\n+      add_ref_to_chain (chain, a);\n+    }\n+\n+  if (nontrivial_chain_p (chain))\n+    {\n+      add_looparound_copies (loop, chain);\n+      VEC_safe_push (chain_p, heap, *chains, chain);\n+    }\n+  else\n+    release_chain (chain);\n+}\n+\n+/* Find roots of the values and determine distances in components COMPS, and\n+   separates the references to CHAINS.  LOOP is the current loop.  */\n+\n+static void\n+determine_roots (struct loop *loop,\n+\t\t struct component *comps, VEC (chain_p, heap) **chains)\n+{\n+  struct component *comp;\n+\n+  for (comp = comps; comp; comp = comp->next)\n+    determine_roots_comp (loop, comp, chains);\n+}\n+\n+/* Replace the reference in statement STMT with temporary variable\n+   NEW.  If SET is true, NEW is instead initialized to the value of\n+   the reference in the statement.  IN_LHS is true if the reference\n+   is in the lhs of STMT, false if it is in rhs.  */\n+\n+static void\n+replace_ref_with (tree stmt, tree new, bool set, bool in_lhs)\n+{\n+  tree val, new_stmt;\n+  block_stmt_iterator bsi;\n+\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    {\n+      gcc_assert (!in_lhs && !set);\n+\n+      val = PHI_RESULT (stmt);\n+      bsi = bsi_after_labels (bb_for_stmt (stmt));\n+      remove_phi_node (stmt, NULL_TREE, false);\n+\n+      /* Turn the phi node into GIMPLE_MODIFY_STMT.  */\n+      new_stmt = build_gimple_modify_stmt_stat (val, new);\n+      SSA_NAME_DEF_STMT (val) = new_stmt;\n+      bsi_insert_before (&bsi, new_stmt, BSI_NEW_STMT);\n+      return;\n+    }\n+      \n+  /* Since the reference is of gimple_reg type, it should only\n+     appear as lhs or rhs of modify statement.  */\n+  gcc_assert (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT);\n+\n+  /* If we do not need to initialize NEW, just replace the use of OLD.  */\n+  if (!set)\n+    {\n+      gcc_assert (!in_lhs);\n+      GIMPLE_STMT_OPERAND (stmt, 1) = new;\n+      update_stmt (stmt);\n+      return;\n+    }\n+\n+  bsi = bsi_for_stmt (stmt);\n+  if (in_lhs)\n+    {\n+      val = GIMPLE_STMT_OPERAND (stmt, 1);\n+\n+      /* OLD = VAL\n+\n+\t is transformed to\n+\n+\t OLD = VAL\n+\t NEW = VAL\n+\n+\t (since the reference is of gimple_reg type, VAL is either gimple\n+\t invariant or ssa name).  */\n+    }\n+  else\n+    {\n+      val = GIMPLE_STMT_OPERAND (stmt, 0);\n+\n+      /* VAL = OLD\n+\n+\t is transformed to\n+\n+\t VAL = OLD\n+\t NEW = VAL  */\n+    }\n+\n+  new_stmt = build_gimple_modify_stmt_stat (new, unshare_expr (val));\n+  bsi_insert_after (&bsi, new_stmt, BSI_NEW_STMT);\n+  SSA_NAME_DEF_STMT (new) = new_stmt;\n+}\n+\n+/* Returns the reference to the address of REF in the ITER-th iteration of\n+   LOOP, or NULL if we fail to determine it (ITER may be negative).  We\n+   try to preserve the original shape of the reference (not rewrite it\n+   as an indirect ref to the address), to make tree_could_trap_p in\n+   prepare_initializers_chain return false more often.  */\n+\n+static tree\n+ref_at_iteration (struct loop *loop, tree ref, int iter)\n+{\n+  tree idx, *idx_p, type, val, op0 = NULL_TREE, ret;\n+  affine_iv iv;\n+  bool ok;\n+\n+  if (handled_component_p (ref))\n+    {\n+      op0 = ref_at_iteration (loop, TREE_OPERAND (ref, 0), iter);\n+      if (!op0)\n+\treturn NULL_TREE;\n+    }\n+  else if (!INDIRECT_REF_P (ref))\n+    return unshare_expr (ref);\n+\n+  if (TREE_CODE (ref) == INDIRECT_REF)\n+    {\n+      ret = build1 (INDIRECT_REF, TREE_TYPE (ref), NULL_TREE);\n+      idx = TREE_OPERAND (ref, 0);\n+      idx_p = &TREE_OPERAND (ret, 0);\n+    }\n+  else if (TREE_CODE (ref) == COMPONENT_REF)\n+    {\n+      /* Check that the offset is loop invariant.  */\n+      if (TREE_OPERAND (ref, 2)\n+\t  && !expr_invariant_in_loop_p (loop, TREE_OPERAND (ref, 2)))\n+\treturn NULL_TREE;\n+\n+      return build3 (COMPONENT_REF, TREE_TYPE (ref), op0,\n+\t\t     unshare_expr (TREE_OPERAND (ref, 1)),\n+\t\t     unshare_expr (TREE_OPERAND (ref, 2)));\n+    }\n+  else if (TREE_CODE (ref) == ARRAY_REF)\n+    {\n+      /* Check that the lower bound and the step are loop invariant.  */\n+      if (TREE_OPERAND (ref, 2)\n+\t  && !expr_invariant_in_loop_p (loop, TREE_OPERAND (ref, 2)))\n+\treturn NULL_TREE;\n+      if (TREE_OPERAND (ref, 3)\n+\t  && !expr_invariant_in_loop_p (loop, TREE_OPERAND (ref, 3)))\n+\treturn NULL_TREE;\n+\n+      ret = build4 (ARRAY_REF, TREE_TYPE (ref), op0, NULL_TREE,\n+\t\t    unshare_expr (TREE_OPERAND (ref, 2)),\n+\t\t    unshare_expr (TREE_OPERAND (ref, 3)));\n+      idx = TREE_OPERAND (ref, 1);\n+      idx_p = &TREE_OPERAND (ret, 1);\n+    }\n+  else\n+    return NULL_TREE;\n+\n+  ok = simple_iv (loop, first_stmt (loop->header), idx, &iv, true);\n+  if (!ok)\n+    return NULL_TREE;\n+  iv.base = expand_simple_operations (iv.base);\n+  if (integer_zerop (iv.step))\n+    *idx_p = unshare_expr (iv.base);\n+  else\n+    {\n+      type = TREE_TYPE (iv.base);\n+      val = fold_build2 (MULT_EXPR, type, iv.step,\n+\t\t\t build_int_cst_type (type, iter));\n+      val = fold_build2 (PLUS_EXPR, type, iv.base, val);\n+      *idx_p = unshare_expr (val);\n+    }\n+\n+  return ret;\n+}\n+\n+/* Get the initialization expression for the INDEX-th temporary variable\n+   of CHAIN.  */\n+\n+static tree\n+get_init_expr (chain_p chain, unsigned index)\n+{\n+  if (chain->type == CT_COMBINATION)\n+    {\n+      tree e1 = get_init_expr (chain->ch1, index);\n+      tree e2 = get_init_expr (chain->ch2, index);\n+\n+      return fold_build2 (chain->operator, chain->rslt_type, e1, e2);\n+    }\n+  else\n+    return VEC_index (tree, chain->inits, index);\n+}\n+\n+/* Marks all virtual operands of statement STMT for renaming.  */\n+\n+static void\n+mark_virtual_ops_for_renaming (tree stmt)\n+{\n+  ssa_op_iter iter;\n+  tree var;\n+\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    return;\n+\n+  update_stmt (stmt);\n+\n+  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_VIRTUALS)\n+    {\n+      if (TREE_CODE (var) == SSA_NAME)\n+\tvar = SSA_NAME_VAR (var);\n+      mark_sym_for_renaming (var);\n+    }\n+}\n+\n+/* Calls mark_virtual_ops_for_renaming for all members of LIST.  */\n+\n+static void\n+mark_virtual_ops_for_renaming_list (tree list)\n+{\n+  tree_stmt_iterator tsi;\n+\n+  for (tsi = tsi_start (list); !tsi_end_p (tsi); tsi_next (&tsi))\n+    mark_virtual_ops_for_renaming (tsi_stmt (tsi));\n+}\n+\n+/* Creates the variables for CHAIN, as well as phi nodes for them and\n+   initialization on entry to LOOP.  Uids of the newly created\n+   temporary variables are marked in TMP_VARS.  */\n+\n+static void\n+initialize_root_vars (struct loop *loop, chain_p chain, bitmap tmp_vars)\n+{\n+  unsigned i;\n+  unsigned n = chain->length;\n+  dref root = get_chain_root (chain);\n+  bool reuse_first = !chain->has_max_use_after;\n+  tree ref, init, var, next, stmts;\n+  tree phi;\n+  edge entry = loop_preheader_edge (loop), latch = loop_latch_edge (loop);\n+\n+  /* If N == 0, then all the references are within the single iteration.  And\n+     since this is an nonempty chain, reuse_first cannot be true.  */\n+  gcc_assert (n > 0 || !reuse_first);\n+\n+  chain->vars = VEC_alloc (tree, heap, n + 1);\n+\n+  if (chain->type == CT_COMBINATION)\n+    ref = GIMPLE_STMT_OPERAND (root->stmt, 0);\n+  else\n+    ref = DR_REF (root->ref);\n+\n+  for (i = 0; i < n + (reuse_first ? 0 : 1); i++)\n+    {\n+      var = create_tmp_var (TREE_TYPE (ref), get_lsm_tmp_name (ref, i));\n+      add_referenced_var (var);\n+      bitmap_set_bit (tmp_vars, DECL_UID (var));\n+      VEC_quick_push (tree, chain->vars, var);\n+    }\n+  if (reuse_first)\n+    VEC_quick_push (tree, chain->vars, VEC_index (tree, chain->vars, 0));\n+  \n+  for (i = 0; VEC_iterate (tree, chain->vars, i, var); i++)\n+    VEC_replace (tree, chain->vars, i, make_ssa_name (var, NULL_TREE));\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      var = VEC_index (tree, chain->vars, i);\n+      next = VEC_index (tree, chain->vars, i + 1);\n+      init = get_init_expr (chain, i);\n+\n+      init = force_gimple_operand (init, &stmts, true, NULL_TREE);\n+      if (stmts)\n+\t{\n+\t  mark_virtual_ops_for_renaming_list (stmts);\n+\t  bsi_insert_on_edge_immediate (entry, stmts);\n+\t}\n+\n+      phi = create_phi_node (var, loop->header);\n+      SSA_NAME_DEF_STMT (var) = phi;\n+      add_phi_arg (phi, init, entry);\n+      add_phi_arg (phi, next, latch);\n+    }\n+}\n+\n+/* Create the variables and initialization statement for root of chain\n+   CHAIN.  Uids of the newly created temporary variables are marked\n+   in TMP_VARS.  */\n+\n+static void\n+initialize_root (struct loop *loop, chain_p chain, bitmap tmp_vars)\n+{\n+  dref root = get_chain_root (chain);\n+  bool in_lhs = (chain->type == CT_STORE_LOAD\n+\t\t || chain->type == CT_COMBINATION);\n+\n+  initialize_root_vars (loop, chain, tmp_vars);\n+  replace_ref_with (root->stmt,\n+\t\t    VEC_index (tree, chain->vars, chain->length),\n+\t\t    true, in_lhs);\n+}\n+\n+/* Initializes a variable for load motion for ROOT and prepares phi nodes and\n+   initialization on entry to LOOP if necessary.  The ssa name for the variable\n+   is stored in VARS.  If WRITTEN is true, also a phi node to copy its value\n+   around the loop is created.  Uid of the newly created temporary variable\n+   is marked in TMP_VARS.  INITS is the list containing the (single)\n+   initializer.  */\n+\n+static void\n+initialize_root_vars_lm (struct loop *loop, dref root, bool written,\n+\t\t\t VEC(tree, heap) **vars, VEC(tree, heap) *inits,\n+\t\t\t bitmap tmp_vars)\n+{\n+  unsigned i;\n+  tree ref = DR_REF (root->ref), init, var, next, stmts;\n+  tree phi;\n+  edge entry = loop_preheader_edge (loop), latch = loop_latch_edge (loop);\n+\n+  /* Find the initializer for the variable, and check that it cannot\n+     trap.  */\n+  init = VEC_index (tree, inits, 0);\n+\n+  *vars = VEC_alloc (tree, heap, written ? 2 : 1);\n+  var = create_tmp_var (TREE_TYPE (ref), get_lsm_tmp_name (ref, 0));\n+  add_referenced_var (var);\n+  bitmap_set_bit (tmp_vars, DECL_UID (var));\n+  VEC_quick_push (tree, *vars, var);\n+  if (written)\n+    VEC_quick_push (tree, *vars, VEC_index (tree, *vars, 0));\n+  \n+  for (i = 0; VEC_iterate (tree, *vars, i, var); i++)\n+    VEC_replace (tree, *vars, i, make_ssa_name (var, NULL_TREE));\n+\n+  var = VEC_index (tree, *vars, 0);\n+      \n+  init = force_gimple_operand (init, &stmts, written, NULL_TREE);\n+  if (stmts)\n+    {\n+      mark_virtual_ops_for_renaming_list (stmts);\n+      bsi_insert_on_edge_immediate (entry, stmts);\n+    }\n+\n+  if (written)\n+    {\n+      next = VEC_index (tree, *vars, 1);\n+      phi = create_phi_node (var, loop->header);\n+      SSA_NAME_DEF_STMT (var) = phi;\n+      add_phi_arg (phi, init, entry);\n+      add_phi_arg (phi, next, latch);\n+    }\n+  else\n+    {\n+      init = build_gimple_modify_stmt_stat (var, init);\n+      SSA_NAME_DEF_STMT (var) = init;\n+      mark_virtual_ops_for_renaming (init);\n+      bsi_insert_on_edge_immediate (entry, init);\n+    }\n+}\n+\n+\n+/* Execute load motion for references in chain CHAIN.  Uids of the newly\n+   created temporary variables are marked in TMP_VARS.  */\n+\n+static void\n+execute_load_motion (struct loop *loop, chain_p chain, bitmap tmp_vars)\n+{\n+  VEC (tree, heap) *vars;\n+  dref a;\n+  unsigned n_writes = 0, ridx, i;\n+  tree var;\n+\n+  gcc_assert (chain->type == CT_INVARIANT);\n+  gcc_assert (!chain->combined);\n+  for (i = 0; VEC_iterate (dref, chain->refs, i, a); i++)\n+    if (!DR_IS_READ (a->ref))\n+      n_writes++;\n+  \n+  /* If there are no reads in the loop, there is nothing to do.  */\n+  if (n_writes == VEC_length (dref, chain->refs))\n+    return;\n+\n+  initialize_root_vars_lm (loop, get_chain_root (chain), n_writes > 0,\n+\t\t\t   &vars, chain->inits, tmp_vars);\n+\n+  ridx = 0;\n+  for (i = 0; VEC_iterate (dref, chain->refs, i, a); i++)\n+    {\n+      bool is_read = DR_IS_READ (a->ref);\n+      mark_virtual_ops_for_renaming (a->stmt);\n+\n+      if (!DR_IS_READ (a->ref))\n+\t{\n+\t  n_writes--;\n+\t  if (n_writes)\n+\t    {\n+\t      var = VEC_index (tree, vars, 0);\n+\t      var = make_ssa_name (SSA_NAME_VAR (var), NULL_TREE);\n+\t      VEC_replace (tree, vars, 0, var);\n+\t    }\n+\t  else\n+\t    ridx = 1;\n+\t}\n+\t  \n+      replace_ref_with (a->stmt, VEC_index (tree, vars, ridx),\n+\t\t\t!is_read, !is_read);\n+    }\n+\n+  VEC_free (tree, heap, vars);\n+}\n+\n+/* Returns the single statement in that NAME is used, excepting\n+   the looparound phi nodes contained in one of the chains.  If there is no\n+   such statement, or more statements, NULL_TREE is returned.  */\n+\n+static tree\n+single_nonlooparound_use (tree name)\n+{\n+  use_operand_p use;\n+  imm_use_iterator it;\n+  tree stmt, ret = NULL_TREE;\n+\n+  FOR_EACH_IMM_USE_FAST (use, it, name)\n+    {\n+      stmt = USE_STMT (use);\n+\n+      if (TREE_CODE (stmt) == PHI_NODE)\n+\t{\n+\t  /* Ignore uses in looparound phi nodes.  Uses in other phi nodes\n+\t     could not be processed anyway, so just fail for them.  */\n+\t  if (bitmap_bit_p (looparound_phis,\n+\t\t\t    SSA_NAME_VERSION (PHI_RESULT (stmt))))\n+\t    continue;\n+\n+\t  return NULL_TREE;\n+\t}\n+      else if (ret != NULL_TREE)\n+\treturn NULL_TREE;\n+      else\n+\tret = stmt;\n+    }\n+\n+  return ret;\n+}\n+\n+/* Remove statement STMT, as well as the chain of assignments in that it is\n+   used.  */\n+\n+static void\n+remove_stmt (tree stmt)\n+{\n+  tree next, name;\n+\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    {\n+      name = PHI_RESULT (stmt);\n+      next = single_nonlooparound_use (name);\n+      remove_phi_node (stmt, NULL_TREE, true);\n+\n+      if (!next\n+\t  || TREE_CODE (next) != GIMPLE_MODIFY_STMT\n+\t  || GIMPLE_STMT_OPERAND (next, 1) != name)\n+\treturn;\n+\n+      stmt = next;\n+    }\n+\n+  while (1)\n+    {\n+      block_stmt_iterator bsi;\n+    \n+      bsi = bsi_for_stmt (stmt);\n+\n+      name = GIMPLE_STMT_OPERAND (stmt, 0);\n+      gcc_assert (TREE_CODE (name) == SSA_NAME);\n+\n+      next = single_nonlooparound_use (name);\n+\n+      mark_virtual_ops_for_renaming (stmt);\n+      bsi_remove (&bsi, true);\n+\n+      if (!next\n+\t  || TREE_CODE (next) != GIMPLE_MODIFY_STMT\n+\t  || GIMPLE_STMT_OPERAND (next, 1) != name)\n+\treturn;\n+\n+      stmt = next;\n+    }\n+}\n+\n+/* Perform the predictive commoning optimization for a chain CHAIN.\n+   Uids of the newly created temporary variables are marked in TMP_VARS.*/\n+\n+static void\n+execute_pred_commoning_chain (struct loop *loop, chain_p chain,\n+\t\t\t     bitmap tmp_vars)\n+{\n+  unsigned i;\n+  dref a, root;\n+  tree var;\n+\n+  if (chain->combined)\n+    {\n+      /* For combined chains, just remove the statements that are used to\n+\t compute the values of the expression (except for the root one).  */\n+      for (i = 1; VEC_iterate (dref, chain->refs, i, a); i++)\n+\tremove_stmt (a->stmt);\n+    }\n+  else\n+    {\n+      /* For non-combined chains, set up the variables that hold its value,\n+\t and replace the uses of the original references by these\n+\t variables.  */\n+      root = get_chain_root (chain);\n+      mark_virtual_ops_for_renaming (root->stmt);\n+\n+      initialize_root (loop, chain, tmp_vars);\n+      for (i = 1; VEC_iterate (dref, chain->refs, i, a); i++)\n+\t{\n+\t  mark_virtual_ops_for_renaming (a->stmt);\n+\t  var = VEC_index (tree, chain->vars, chain->length - a->distance);\n+\t  replace_ref_with (a->stmt, var, false, false);\n+\t}\n+    }\n+}\n+\n+/* Determines the unroll factor necessary to remove as many temporary variable\n+   copies as possible.  CHAINS is the list of chains that will be\n+   optimized.  */\n+\n+static unsigned\n+determine_unroll_factor (VEC (chain_p, heap) *chains)\n+{\n+  chain_p chain;\n+  unsigned factor = 1, af, nfactor, i;\n+  unsigned max = PARAM_VALUE (PARAM_MAX_UNROLL_TIMES);\n+\n+  for (i = 0; VEC_iterate (chain_p, chains, i, chain); i++)\n+    {\n+      if (chain->type == CT_INVARIANT || chain->combined)\n+\tcontinue;\n+\n+      /* The best unroll factor for this chain is equal to the number of\n+\t temporary variables that we create for it.  */\n+      af = chain->length;\n+      if (chain->has_max_use_after)\n+\taf++;\n+\n+      nfactor = factor * af / gcd (factor, af);\n+      if (nfactor <= max)\n+\tfactor = nfactor;\n+    }\n+\n+  return factor;\n+}\n+\n+/* Perform the predictive commoning optimization for CHAINS.\n+   Uids of the newly created temporary variables are marked in TMP_VARS.  */\n+\n+static void\n+execute_pred_commoning (struct loop *loop, VEC (chain_p, heap) *chains,\n+\t\t\tbitmap tmp_vars)\n+{\n+  chain_p chain;\n+  unsigned i;\n+\n+  for (i = 0; VEC_iterate (chain_p, chains, i, chain); i++)\n+    {\n+      if (chain->type == CT_INVARIANT)\n+\texecute_load_motion (loop, chain, tmp_vars);\n+      else\n+\texecute_pred_commoning_chain (loop, chain, tmp_vars);\n+    }\n+  \n+  update_ssa (TODO_update_ssa_only_virtuals);\n+}\n+\n+/* For each reference in CHAINS, if its definining statement is\n+   ssa name, set it to phi node that defines it.  */\n+\n+static void\n+replace_phis_by_defined_names (VEC (chain_p, heap) *chains)\n+{\n+  chain_p chain;\n+  dref a;\n+  unsigned i, j;\n+\n+  for (i = 0; VEC_iterate (chain_p, chains, i, chain); i++)\n+    for (j = 0; VEC_iterate (dref, chain->refs, j, a); j++)\n+      {\n+\tgcc_assert (TREE_CODE (a->stmt) != SSA_NAME);\n+\tif (TREE_CODE (a->stmt) == PHI_NODE)\n+\t  a->stmt = PHI_RESULT (a->stmt);\n+      }\n+}\n+\n+/* For each reference in CHAINS, if its definining statement is\n+   phi node, set it to the ssa name that is defined by it.  */\n+\n+static void\n+replace_names_by_phis (VEC (chain_p, heap) *chains)\n+{\n+  chain_p chain;\n+  dref a;\n+  unsigned i, j;\n+\n+  for (i = 0; VEC_iterate (chain_p, chains, i, chain); i++)\n+    for (j = 0; VEC_iterate (dref, chain->refs, j, a); j++)\n+      if (TREE_CODE (a->stmt) == SSA_NAME)\n+\t{\n+\t  a->stmt = SSA_NAME_DEF_STMT (a->stmt);\n+\t  gcc_assert (TREE_CODE (a->stmt) == PHI_NODE);\n+\t}\n+}\n+\n+/* Wrapper over execute_pred_commoning, to pass it as a callback\n+   to tree_transform_and_unroll_loop.  */\n+\n+struct epcc_data\n+{\n+  VEC (chain_p, heap) *chains;\n+  bitmap tmp_vars;\n+};\n+\n+static void\n+execute_pred_commoning_cbck (struct loop *loop, void *data)\n+{\n+  struct epcc_data *dta = data;\n+\n+  /* Restore phi nodes that were replaced by ssa names before\n+     tree_transform_and_unroll_loop (see detailed description in\n+     tree_predictive_commoning_loop).  */\n+  replace_names_by_phis (dta->chains);\n+  execute_pred_commoning (loop, dta->chains, dta->tmp_vars);\n+}\n+\n+/* Returns true if we can and should unroll LOOP FACTOR times.  Number\n+   of iterations of the loop is returned in NITER.  */\n+\n+static bool\n+should_unroll_loop_p (struct loop *loop, unsigned factor,\n+\t\t      struct tree_niter_desc *niter)\n+{\n+  edge exit;\n+\n+  if (factor == 1)\n+    return false;\n+\n+  /* Check whether unrolling is possible.  We only want to unroll loops\n+     for that we are able to determine number of iterations.  We also\n+     want to split the extra iterations of the loop from its end,\n+     therefore we require that the loop has precisely one\n+     exit.  */\n+\n+  exit = single_dom_exit (loop);\n+  if (!exit)\n+    return false;\n+\n+  if (!number_of_iterations_exit (loop, exit, niter, false))\n+    return false;\n+\n+  /* And of course, we must be able to duplicate the loop.  */\n+  if (!can_duplicate_loop_p (loop))\n+    return false;\n+\n+  /* The final loop should be small enough.  */\n+  if (tree_num_loop_insns (loop, &eni_size_weights) * factor\n+      > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Base NAME and all the names in the chain of phi nodes that use it\n+   on variable VAR.  The phi nodes are recognized by being in the copies of\n+   the header of the LOOP.  */\n+\n+static void\n+base_names_in_chain_on (struct loop *loop, tree name, tree var)\n+{\n+  tree stmt, phi;\n+  imm_use_iterator iter;\n+  edge e;\n+\n+  SSA_NAME_VAR (name) = var;\n+\n+  while (1)\n+    {\n+      phi = NULL;\n+      FOR_EACH_IMM_USE_STMT (stmt, iter, name)\n+\t{\n+\t  if (TREE_CODE (stmt) == PHI_NODE\n+\t      && flow_bb_inside_loop_p (loop, bb_for_stmt (stmt)))\n+\t    {\n+\t      phi = stmt;\n+\t      BREAK_FROM_IMM_USE_STMT (iter);\n+\t    }\n+\t}\n+      if (!phi)\n+\treturn;\n+\n+      if (bb_for_stmt (phi) == loop->header)\n+\te = loop_latch_edge (loop);\n+      else\n+\te = single_pred_edge (bb_for_stmt (stmt));\n+\n+      name = PHI_RESULT (phi);\n+      SSA_NAME_VAR (name) = var;\n+    }\n+}\n+\n+/* Given an unrolled LOOP after predictive commoning, remove the\n+   register copies arising from phi nodes by changing the base\n+   variables of SSA names.  TMP_VARS is the set of the temporary variables\n+   for those we want to perform this.  */\n+\n+static void\n+eliminate_temp_copies (struct loop *loop, bitmap tmp_vars)\n+{\n+  edge e;\n+  tree phi, name, use, var, stmt;\n+\n+  e = loop_latch_edge (loop);\n+  for (phi = phi_nodes (loop->header); phi; phi = PHI_CHAIN (phi))\n+    {\n+      name = PHI_RESULT (phi);\n+      var = SSA_NAME_VAR (name);\n+      if (!bitmap_bit_p (tmp_vars, DECL_UID (var)))\n+\tcontinue;\n+      use = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+      gcc_assert (TREE_CODE (use) == SSA_NAME);\n+\n+      /* Base all the ssa names in the ud and du chain of NAME on VAR.  */\n+      stmt = SSA_NAME_DEF_STMT (use);\n+      while (TREE_CODE (stmt) == PHI_NODE)\n+\t{\n+\t  gcc_assert (single_pred_p (bb_for_stmt (stmt)));\n+\t  use = PHI_ARG_DEF (stmt, 0);\n+\t  stmt = SSA_NAME_DEF_STMT (use);\n+\t}\n+\n+      base_names_in_chain_on (loop, use, var);\n+    }\n+}\n+\n+/* Returns true if CHAIN is suitable to be combined.  */\n+\n+static bool\n+chain_can_be_combined_p (chain_p chain)\n+{\n+  return (!chain->combined\n+\t  && (chain->type == CT_LOAD || chain->type == CT_COMBINATION));\n+}\n+\n+/* Returns the modify statement that uses NAME.  Skips over assignment\n+   statements, NAME is replaced with the actual name used in the returned\n+   statement.  */\n+\n+static tree\n+find_use_stmt (tree *name)\n+{\n+  tree stmt, rhs, lhs;\n+\n+  /* Skip over assignments.  */\n+  while (1)\n+    {\n+      stmt = single_nonlooparound_use (*name);\n+      if (!stmt)\n+\treturn NULL_TREE;\n+\n+      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+\treturn NULL_TREE;\n+\n+      lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+      if (TREE_CODE (lhs) != SSA_NAME)\n+\treturn NULL_TREE;\n+\n+      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+      if (rhs != *name)\n+\tbreak;\n+\n+      *name = lhs;\n+    }\n+\n+  if (!EXPR_P (rhs)\n+      || REFERENCE_CLASS_P (rhs)\n+      || TREE_CODE_LENGTH (TREE_CODE (rhs)) != 2)\n+    return NULL_TREE;\n+\n+  return stmt;\n+}\n+\n+/* Returns true if we may perform reassociation for operation CODE in TYPE.  */\n+\n+static bool\n+may_reassociate_p (tree type, enum tree_code code)\n+{\n+  if (FLOAT_TYPE_P (type)\n+      && !flag_unsafe_math_optimizations)\n+    return false;\n+\n+  return (commutative_tree_code (code)\n+\t  && associative_tree_code (code));\n+}\n+\n+/* If the operation used in STMT is associative and commutative, go through the\n+   tree of the same operations and returns its root.  Distance to the root\n+   is stored in DISTANCE.  */\n+\n+static tree\n+find_associative_operation_root (tree stmt, unsigned *distance)\n+{\n+  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1), lhs, next;\n+  enum tree_code code = TREE_CODE (rhs);\n+  unsigned dist = 0;\n+\n+  if (!may_reassociate_p (TREE_TYPE (rhs), code))\n+    return NULL_TREE;\n+\n+  while (1)\n+    {\n+      lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+      gcc_assert (TREE_CODE (lhs) == SSA_NAME);\n+\n+      next = find_use_stmt (&lhs);\n+      if (!next)\n+\tbreak;\n+\n+      rhs = GIMPLE_STMT_OPERAND (next, 1);\n+      if (TREE_CODE (rhs) != code)\n+\tbreak;\n+\n+      stmt = next;\n+      dist++;\n+    }\n+\n+  if (distance)\n+    *distance = dist;\n+  return stmt;\n+}\n+\n+/* Returns the common statement in that NAME1 and NAME2 have a use.  If there\n+   is no such statement, returns NULL_TREE.  In case the operation used on\n+   NAME1 and NAME2 is associative and comutative, returns the root of the\n+   tree formed by this operation instead of the statement that uses NAME1 or\n+   NAME2.  */\n+\n+static tree\n+find_common_use_stmt (tree *name1, tree *name2)\n+{\n+  tree stmt1, stmt2;\n+\n+  stmt1 = find_use_stmt (name1);\n+  if (!stmt1)\n+    return NULL_TREE;\n+\n+  stmt2 = find_use_stmt (name2);\n+  if (!stmt2)\n+    return NULL_TREE;\n+\n+  if (stmt1 == stmt2)\n+    return stmt1;\n+\n+  stmt1 = find_associative_operation_root (stmt1, NULL);\n+  if (!stmt1)\n+    return NULL_TREE;\n+  stmt2 = find_associative_operation_root (stmt2, NULL);\n+  if (!stmt2)\n+    return NULL_TREE;\n+\n+  return (stmt1 == stmt2 ? stmt1 : NULL_TREE);\n+}\n+\n+/* Checks whether R1 and R2 are combined together using CODE, with the result\n+   in RSLT_TYPE, in order R1 CODE R2 if SWAP is false and in order R2 CODE R1\n+   if it is true.  If CODE is ERROR_MARK, set these values instead.  */\n+\n+static bool\n+combinable_refs_p (dref r1, dref r2,\n+\t\t   enum tree_code *code, bool *swap, tree *rslt_type)\n+{\n+  enum tree_code acode;\n+  bool aswap;\n+  tree atype;\n+  tree name1, name2, stmt, rhs;\n+\n+  name1 = name_for_ref (r1);\n+  name2 = name_for_ref (r2);\n+  gcc_assert (name1 != NULL_TREE && name2 != NULL_TREE);\n+\n+  stmt = find_common_use_stmt (&name1, &name2);\n+\n+  if (!stmt)\n+    return false;\n+\n+  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+  acode = TREE_CODE (rhs);\n+  aswap = (!commutative_tree_code (acode)\n+\t   && TREE_OPERAND (rhs, 0) != name1);\n+  atype = TREE_TYPE (rhs);\n+\n+  if (*code == ERROR_MARK)\n+    {\n+      *code = acode;\n+      *swap = aswap;\n+      *rslt_type = atype;\n+      return true;\n+    }\n+\n+  return (*code == acode\n+\t  && *swap == aswap\n+\t  && *rslt_type == atype);\n+}\n+\n+/* Remove OP from the operation on rhs of STMT, and replace STMT with\n+   an assignment of the remaining operand.  */\n+\n+static void\n+remove_name_from_operation (tree stmt, tree op)\n+{\n+  tree *rhs;\n+\n+  gcc_assert (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT);\n+\n+  rhs = &GIMPLE_STMT_OPERAND (stmt, 1);\n+  if (TREE_OPERAND (*rhs, 0) == op)\n+    *rhs = TREE_OPERAND (*rhs, 1);\n+  else if (TREE_OPERAND (*rhs, 1) == op)\n+    *rhs = TREE_OPERAND (*rhs, 0);\n+  else\n+    gcc_unreachable ();\n+  update_stmt (stmt);\n+}\n+\n+/* Reassociates the expression in that NAME1 and NAME2 are used so that they\n+   are combined in a single statement, and returns this statement.  */\n+\n+static tree\n+reassociate_to_the_same_stmt (tree name1, tree name2)\n+{\n+  tree stmt1, stmt2, root1, root2, r1, r2, s1, s2;\n+  tree new_stmt, tmp_stmt, new_name, tmp_name, var;\n+  unsigned dist1, dist2;\n+  enum tree_code code;\n+  tree type = TREE_TYPE (name1);\n+  block_stmt_iterator bsi;\n+\n+  stmt1 = find_use_stmt (&name1);\n+  stmt2 = find_use_stmt (&name2);\n+  root1 = find_associative_operation_root (stmt1, &dist1);\n+  root2 = find_associative_operation_root (stmt2, &dist2);\n+  code = TREE_CODE (GIMPLE_STMT_OPERAND (stmt1, 1));\n+\n+  gcc_assert (root1 && root2 && root1 == root2\n+\t      && code == TREE_CODE (GIMPLE_STMT_OPERAND (stmt2, 1)));\n+\n+  /* Find the root of the nearest expression in that both NAME1 and NAME2\n+     are used.  */\n+  r1 = name1;\n+  s1 = stmt1;\n+  r2 = name2;\n+  s2 = stmt2;\n+\n+  while (dist1 > dist2)\n+    {\n+      s1 = find_use_stmt (&r1);\n+      r1 = GIMPLE_STMT_OPERAND (s1, 0);\n+      dist1--;\n+    }\n+  while (dist2 > dist1)\n+    {\n+      s2 = find_use_stmt (&r2);\n+      r2 = GIMPLE_STMT_OPERAND (s2, 0);\n+      dist2--;\n+    }\n+\n+  while (s1 != s2)\n+    {\n+      s1 = find_use_stmt (&r1);\n+      r1 = GIMPLE_STMT_OPERAND (s1, 0);\n+      s2 = find_use_stmt (&r2);\n+      r2 = GIMPLE_STMT_OPERAND (s2, 0);\n+    }\n+\n+  /* Remove NAME1 and NAME2 from the statements in that they are used\n+     currently.  */\n+  remove_name_from_operation (stmt1, name1);\n+  remove_name_from_operation (stmt2, name2);\n+\n+  /* Insert the new statement combining NAME1 and NAME2 before S1, and\n+     combine it with the rhs of S1.  */\n+  var = create_tmp_var (type, \"predreastmp\");\n+  add_referenced_var (var);\n+  new_name = make_ssa_name (var, NULL_TREE);\n+  new_stmt = build_gimple_modify_stmt_stat (new_name,\n+\t\t\t    fold_build2 (code, type, name1, name2));\n+  SSA_NAME_DEF_STMT (new_name) = new_stmt;\n+\n+  var = create_tmp_var (type, \"predreastmp\");\n+  add_referenced_var (var);\n+  tmp_name = make_ssa_name (var, NULL_TREE);\n+  tmp_stmt = build_gimple_modify_stmt_stat (tmp_name,\n+\t\t\t\t\t    GIMPLE_STMT_OPERAND (s1, 1));\n+  SSA_NAME_DEF_STMT (tmp_name) = tmp_stmt;\n+\n+  GIMPLE_STMT_OPERAND (s1, 1) = fold_build2 (code, type, new_name, tmp_name);\n+  update_stmt (s1);\n+\n+  bsi = bsi_for_stmt (s1);\n+  bsi_insert_before (&bsi, new_stmt, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, tmp_stmt, BSI_SAME_STMT);\n+\n+  return new_stmt;\n+}\n+\n+/* Returns the statement that combines references R1 and R2.  In case R1\n+   and R2 are not used in the same statement, but they are used with an\n+   associative and commutative operation in the same expression, reassociate\n+   the expression so that they are used in the same statement.  */\n+\n+static tree\n+stmt_combining_refs (dref r1, dref r2)\n+{\n+  tree stmt1, stmt2;\n+  tree name1 = name_for_ref (r1);\n+  tree name2 = name_for_ref (r2);\n+\n+  stmt1 = find_use_stmt (&name1);\n+  stmt2 = find_use_stmt (&name2);\n+  if (stmt1 == stmt2)\n+    return stmt1;\n+\n+  return reassociate_to_the_same_stmt (name1, name2);\n+}\n+\n+/* Tries to combine chains CH1 and CH2 together.  If this succeeds, the\n+   description of the new chain is returned, otherwise we return NULL.  */\n+\n+static chain_p\n+combine_chains (chain_p ch1, chain_p ch2)\n+{\n+  dref r1, r2, nw;\n+  enum tree_code op = ERROR_MARK;\n+  bool swap = false;\n+  chain_p new_chain;\n+  unsigned i;\n+  tree root_stmt;\n+  tree rslt_type = NULL_TREE;\n+\n+  if (ch1 == ch2)\n+    return false;\n+  if (ch1->length != ch2->length)\n+    return NULL;\n+\n+  if (VEC_length (dref, ch1->refs) != VEC_length (dref, ch2->refs))\n+    return NULL;\n+\n+  for (i = 0; (VEC_iterate (dref, ch1->refs, i, r1)\n+\t       && VEC_iterate (dref, ch2->refs, i, r2)); i++)\n+    {\n+      if (r1->distance != r2->distance)\n+\treturn NULL;\n+\n+      if (!combinable_refs_p (r1, r2, &op, &swap, &rslt_type))\n+\treturn NULL;\n+    }\n+\n+  if (swap)\n+    {\n+      chain_p tmp = ch1;\n+      ch1 = ch2;\n+      ch2 = tmp;\n+    }\n+\n+  new_chain = XCNEW (struct chain);\n+  new_chain->type = CT_COMBINATION;\n+  new_chain->operator = op;\n+  new_chain->ch1 = ch1;\n+  new_chain->ch2 = ch2;\n+  new_chain->rslt_type = rslt_type;\n+  new_chain->length = ch1->length;\n+\n+  for (i = 0; (VEC_iterate (dref, ch1->refs, i, r1)\n+\t       && VEC_iterate (dref, ch2->refs, i, r2)); i++)\n+    {\n+      nw = XCNEW (struct dref);\n+      nw->stmt = stmt_combining_refs (r1, r2);\n+      nw->distance = r1->distance;\n+\n+      VEC_safe_push (dref, heap, new_chain->refs, nw);\n+    }\n+\n+  new_chain->has_max_use_after = false;\n+  root_stmt = get_chain_root (new_chain)->stmt;\n+  for (i = 1; VEC_iterate (dref, new_chain->refs, i, nw); i++)\n+    {\n+      if (nw->distance == new_chain->length\n+\t  && !stmt_dominates_stmt_p (nw->stmt, root_stmt))\n+\t{\n+\t  new_chain->has_max_use_after = true;\n+\t  break;\n+\t}\n+    }\n+\n+  ch1->combined = true;\n+  ch2->combined = true;\n+  return new_chain;\n+}\n+\n+/* Try to combine the CHAINS.  */\n+\n+static void\n+try_combine_chains (VEC (chain_p, heap) **chains)\n+{\n+  unsigned i, j;\n+  chain_p ch1, ch2, cch;\n+  VEC (chain_p, heap) *worklist = NULL;\n+\n+  for (i = 0; VEC_iterate (chain_p, *chains, i, ch1); i++)\n+    if (chain_can_be_combined_p (ch1))\n+      VEC_safe_push (chain_p, heap, worklist, ch1);\n+\n+  while (!VEC_empty (chain_p, worklist))\n+    {\n+      ch1 = VEC_pop (chain_p, worklist);\n+      if (!chain_can_be_combined_p (ch1))\n+\tcontinue;\n+\n+      for (j = 0; VEC_iterate (chain_p, *chains, j, ch2); j++)\n+\t{\n+\t  if (!chain_can_be_combined_p (ch2))\n+\t    continue;\n+\n+\t  cch = combine_chains (ch1, ch2);\n+\t  if (cch)\n+\t    {\n+\t      VEC_safe_push (chain_p, heap, worklist, cch);\n+\t      VEC_safe_push (chain_p, heap, *chains, cch);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Sets alias information based on data reference DR for REF,\n+   if necessary.  */\n+\n+static void\n+set_alias_info (tree ref, struct data_reference *dr)\n+{\n+  tree var;\n+  tree tag = DR_SYMBOL_TAG (dr);\n+\n+  gcc_assert (tag != NULL_TREE);\n+\n+  ref = get_base_address (ref);\n+  if (!ref || !INDIRECT_REF_P (ref))\n+    return;\n+\n+  var = SSA_NAME_VAR (TREE_OPERAND (ref, 0));\n+  if (var_ann (var)->symbol_mem_tag)\n+    return;\n+\n+  if (!MTAG_P (tag))\n+    new_type_alias (var, tag, ref);\n+  else\n+    var_ann (var)->symbol_mem_tag = tag;\n+\n+  var_ann (var)->subvars = DR_SUBVARS (dr);\n+}\n+\n+/* Prepare initializers for CHAIN in LOOP.  Returns false if this is\n+   impossible because one of these initializers may trap, true otherwise.  */\n+\n+static bool\n+prepare_initializers_chain (struct loop *loop, chain_p chain)\n+{\n+  unsigned i, n = (chain->type == CT_INVARIANT) ? 1 : chain->length;\n+  struct data_reference *dr = get_chain_root (chain)->ref;\n+  tree init, stmts;\n+  dref laref;\n+  edge entry = loop_preheader_edge (loop);\n+\n+  /* Find the initializers for the variables, and check that they cannot\n+     trap.  */\n+  chain->inits = VEC_alloc (tree, heap, n);\n+  for (i = 0; i < n; i++)\n+    VEC_quick_push (tree, chain->inits, NULL_TREE);\n+\n+  /* If we have replaced some looparound phi nodes, use their initializers\n+     instead of creating our own.  */\n+  for (i = 0; VEC_iterate (dref, chain->refs, i, laref); i++)\n+    {\n+      if (TREE_CODE (laref->stmt) != PHI_NODE)\n+\tcontinue;\n+\n+      gcc_assert (laref->distance > 0);\n+      VEC_replace (tree, chain->inits, n - laref->distance,\n+\t\t   PHI_ARG_DEF_FROM_EDGE (laref->stmt, entry));\n+    }\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      if (VEC_index (tree, chain->inits, i) != NULL_TREE)\n+\tcontinue;\n+\n+      init = ref_at_iteration (loop, DR_REF (dr), (int) i - n);\n+      if (!init)\n+\treturn false;\n+      \n+      if (!chain->all_always_accessed && tree_could_trap_p (init))\n+\treturn false;\n+\n+      init = force_gimple_operand (init, &stmts, false, NULL_TREE);\n+      if (stmts)\n+\t{\n+\t  mark_virtual_ops_for_renaming_list (stmts);\n+\t  bsi_insert_on_edge_immediate (entry, stmts);\n+\t}\n+      set_alias_info (init, dr);\n+\n+      VEC_replace (tree, chain->inits, i, init);\n+    }\n+\n+  return true;\n+}\n+\n+/* Prepare initializers for CHAINS in LOOP, and free chains that cannot\n+   be used because the initializers might trap.  */\n+\n+static void\n+prepare_initializers (struct loop *loop, VEC (chain_p, heap) *chains)\n+{\n+  chain_p chain;\n+  unsigned i;\n+\n+  for (i = 0; i < VEC_length (chain_p, chains); )\n+    {\n+      chain = VEC_index (chain_p, chains, i);\n+      if (prepare_initializers_chain (loop, chain))\n+\ti++;\n+      else\n+\t{\n+\t  release_chain (chain);\n+\t  VEC_unordered_remove (chain_p, chains, i);\n+\t}\n+    }\n+}\n+\n+/* Performs predictive commoning for LOOP.  Returns true if LOOP was\n+   unrolled.  */\n+\n+static bool\n+tree_predictive_commoning_loop (struct loop *loop)\n+{\n+  VEC (data_reference_p, heap) *datarefs;\n+  VEC (ddr_p, heap) *dependences;\n+  struct component *components;\n+  VEC (chain_p, heap) *chains = NULL;\n+  unsigned unroll_factor;\n+  struct tree_niter_desc desc;\n+  bool unroll = false;\n+  edge exit;\n+  bitmap tmp_vars;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Processing loop %d\\n\",  loop->num);\n+\n+  /* Find the data references and split them into components according to their\n+     dependence relations.  */\n+  datarefs = VEC_alloc (data_reference_p, heap, 10);\n+  dependences = VEC_alloc (ddr_p, heap, 10);\n+  compute_data_dependences_for_loop (loop, true, &datarefs, &dependences);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_data_dependence_relations (dump_file, dependences);\n+\n+  components = split_data_refs_to_components (loop, datarefs, dependences);\n+  free_dependence_relations (dependences);\n+  if (!components)\n+    {\n+      free_data_refs (datarefs);\n+      return false;\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Initial state:\\n\\n\");\n+      dump_components (dump_file, components);\n+    }\n+\n+  /* Find the suitable components and split them into chains.  */\n+  components = filter_suitable_components (loop, components);\n+\n+  tmp_vars = BITMAP_ALLOC (NULL);\n+  looparound_phis = BITMAP_ALLOC (NULL);\n+  determine_roots (loop, components, &chains);\n+  release_components (components);\n+\n+  if (!chains)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Predictive commoning failed: no suitable chains\\n\");\n+      goto end;\n+    }\n+  prepare_initializers (loop, chains);\n+\n+  /* Try to combine the chains that are always worked with together.  */\n+  try_combine_chains (&chains);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Before commoning:\\n\\n\");\n+      dump_chains (dump_file, chains);\n+    }\n+\n+  /* Determine the unroll factor, and if the loop should be unrolled, ensure\n+     that its number of iterations is divisible by the factor.  */\n+  unroll_factor = determine_unroll_factor (chains);\n+  scev_reset ();\n+  unroll = should_unroll_loop_p (loop, unroll_factor, &desc);\n+  exit = single_dom_exit (loop);\n+\n+  /* Execute the predictive commoning transformations, and possibly unroll the\n+     loop.  */\n+  if (unroll)\n+    {\n+      struct epcc_data dta;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Unrolling %u times.\\n\", unroll_factor);\n+\n+      dta.chains = chains;\n+      dta.tmp_vars = tmp_vars;\n+      \n+      update_ssa (TODO_update_ssa_only_virtuals);\n+\n+      /* Cfg manipulations performed in tree_transform_and_unroll_loop before\n+\t execute_pred_commoning_cbck is called may cause phi nodes to be\n+\t reallocated, which is a problem since CHAINS may point to these\n+\t statements.  To fix this, we store the ssa names defined by the\n+\t phi nodes here instead of the phi nodes themselves, and restore\n+\t the phi nodes in execute_pred_commoning_cbck.  A bit hacky.  */\n+      replace_phis_by_defined_names (chains);\n+\n+      tree_transform_and_unroll_loop (loop, unroll_factor, exit, &desc,\n+\t\t\t\t      execute_pred_commoning_cbck, &dta);\n+      eliminate_temp_copies (loop, tmp_vars);\n+    }\n+  else\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Executing predictive commoning without unrolling.\\n\");\n+      execute_pred_commoning (loop, chains, tmp_vars);\n+    }\n+\n+end: ;\n+  release_chains (chains);\n+  free_data_refs (datarefs);\n+  BITMAP_FREE (tmp_vars);\n+  BITMAP_FREE (looparound_phis);\n+\n+  free_affine_expand_cache (&name_expansions);\n+\n+  return unroll;\n+}\n+\n+/* Runs predictive commoning.  */\n+\n+void\n+tree_predictive_commoning (void)\n+{\n+  bool unrolled = false;\n+  struct loop *loop;\n+  loop_iterator li;\n+\n+  initialize_original_copy_tables ();\n+  FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n+    {\n+      unrolled |= tree_predictive_commoning_loop (loop);\n+    }\n+\n+  if (unrolled)\n+    {\n+      scev_reset ();\n+      cleanup_tree_cfg_loop ();\n+    }\n+  free_original_copy_tables ();\n+}"}, {"sha": "3678fab8b7e7b4f3759f8fa7e4e8b4c6be8b61c3", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -37,7 +37,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n /* Local functions, macros and variables.  */\n static int op_prio (tree);\n-static const char *op_symbol_1 (enum tree_code);\n static const char *op_symbol (tree);\n static void pretty_print_string (pretty_printer *, const char*);\n static void print_call_name (pretty_printer *, tree);\n@@ -296,7 +295,7 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n \n     case OMP_CLAUSE_REDUCTION:\n       pp_string (buffer, \"reduction(\");\n-      pp_string (buffer, op_symbol_1 (OMP_CLAUSE_REDUCTION_CODE (clause)));\n+      pp_string (buffer, op_symbol_code (OMP_CLAUSE_REDUCTION_CODE (clause)));\n       pp_character (buffer, ':');\n       dump_generic_node (buffer, OMP_CLAUSE_DECL (clause),\n \t  spc, flags, false);\n@@ -2390,10 +2389,10 @@ op_prio (tree op)\n }\n \n \n-/* Return the symbol associated with operator OP.  */\n+/* Return the symbol associated with operator CODE.  */\n \n-static const char *\n-op_symbol_1 (enum tree_code code)\n+const char *\n+op_symbol_code (enum tree_code code)\n {\n   switch (code)\n     {\n@@ -2557,10 +2556,12 @@ op_symbol_1 (enum tree_code code)\n     }\n }\n \n+/* Return the symbol associated with operator OP.  */\n+\n static const char *\n op_symbol (tree op)\n {\n-  return op_symbol_1 (TREE_CODE (op));\n+  return op_symbol_code (TREE_CODE (op));\n }\n \n /* Prints the name of a CALL_EXPR.  */"}, {"sha": "4bed167ec4ac34e7ab38902358b5392e49180a03", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -1116,14 +1116,23 @@ gen_lsm_tmp_name (tree ref)\n }\n \n /* Determines name for temporary variable that replaces REF.\n-   The name is accumulated into the lsm_tmp_name variable.  */\n+   The name is accumulated into the lsm_tmp_name variable.\n+   N is added to the name of the temporary.  */\n \n-static char *\n-get_lsm_tmp_name (tree ref)\n+char *\n+get_lsm_tmp_name (tree ref, unsigned n)\n {\n+  char ns[2];\n+\n   lsm_tmp_name_length = 0;\n   gen_lsm_tmp_name (ref);\n   lsm_tmp_name_add (\"_lsm\");\n+  if (n < 10)\n+    {\n+      ns[0] = '0' + n;\n+      ns[1] = 0;\n+      lsm_tmp_name_add (ns);\n+    }\n   return lsm_tmp_name;\n }\n \n@@ -1153,7 +1162,7 @@ schedule_sm (struct loop *loop, VEC (edge, heap) *exits, tree ref,\n     }\n \n   tmp_var = make_rename_temp (TREE_TYPE (ref),\n-\t\t\t      get_lsm_tmp_name (ref));\n+\t\t\t      get_lsm_tmp_name (ref, ~0));\n \n   fmt_data.loop = loop;\n   fmt_data.orig_loop = loop;"}, {"sha": "c3d3b7786354910398cc44f56535d775f390d858", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -2816,7 +2816,7 @@ estimate_numbers_of_iterations (void)\n \n /* Returns true if statement S1 dominates statement S2.  */\n \n-static bool\n+bool\n stmt_dominates_stmt_p (tree s1, tree s2)\n {\n   basic_block bb1 = bb_for_stmt (s1), bb2 = bb_for_stmt (s2);"}, {"sha": "895c9c251743bfd9c51ca37cb9d2192a52b66e85", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=bbc8a8dc0d4019bc7cc9f4e66f067b3d0380a487", "patch": "@@ -176,6 +176,42 @@ struct tree_opt_pass pass_tree_unswitch =\n   0\t\t\t\t\t/* letter */\n };\n \n+/* Predictive commoning.  */\n+\n+static unsigned\n+run_tree_predictive_commoning (void)\n+{\n+  if (!current_loops)\n+    return 0;\n+\n+  tree_predictive_commoning ();\n+  return 0;\n+}\n+\n+static bool\n+gate_tree_predictive_commoning (void)\n+{\n+  return flag_predictive_commoning != 0;\n+}\n+\n+struct tree_opt_pass pass_predcom = \n+{\n+  \"pcom\",\t\t\t\t/* name */\n+  gate_tree_predictive_commoning,\t/* gate */\n+  run_tree_predictive_commoning,\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_PREDCOM,\t\t\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_verify_loops\n+    | TODO_update_ssa_only_virtuals,\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n /* Loop autovectorization.  */\n \n static unsigned int"}]}