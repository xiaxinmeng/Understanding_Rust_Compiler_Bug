{"sha": "44fd4dc0b684e06c6c6d08b3994df23135bf2fbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRmZDRkYzBiNjg0ZTA2YzZjNmQwOGIzOTk0ZGYyMzEzNWJmMmZiYw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-03-10T17:02:07Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-03-10T17:02:07Z"}, "message": "analyzer: factor out new class feasibility_state\n\nAs preparatory work for a fix to PR analyzer/96374, this patch\nmoves the core state-update logic from the loop in\nexploded_path::feasible_p into a new class feasibility_state.\n\nNo functional change intended.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/96374\n\t* engine.cc (exploded_path::feasible_p): Move \"snodes_visited\" and\n\t\"model\" locals into a new class feasibility_state.  Move heart\n\tof per-edge processing into\n\tfeasibility_state::maybe_update_for_edge.\n\t(feasibility_state::feasibility_state): New.\n\t(feasibility_state::maybe_update_for_edge): New, based on loop\n\tbody in exploded_path::feasible_p.\n\t* exploded-graph.h (class feasibility_state): New.", "tree": {"sha": "a31d4c270aa49c9a9129e2411957719729269535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a31d4c270aa49c9a9129e2411957719729269535"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44fd4dc0b684e06c6c6d08b3994df23135bf2fbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fd4dc0b684e06c6c6d08b3994df23135bf2fbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44fd4dc0b684e06c6c6d08b3994df23135bf2fbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fd4dc0b684e06c6c6d08b3994df23135bf2fbc/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b78729186060cf96c0b4e0f3eacf155f4e90376", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b78729186060cf96c0b4e0f3eacf155f4e90376", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b78729186060cf96c0b4e0f3eacf155f4e90376"}], "stats": {"total": 273, "additions": 172, "deletions": 101}, "files": [{"sha": "fef482364c4ee1c591f3ca6929e704abf2277a8a", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 150, "deletions": 101, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fd4dc0b684e06c6c6d08b3994df23135bf2fbc/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fd4dc0b684e06c6c6d08b3994df23135bf2fbc/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=44fd4dc0b684e06c6c6d08b3994df23135bf2fbc", "patch": "@@ -3404,11 +3404,10 @@ exploded_path::feasible_p (logger *logger, feasibility_problem **out,\n {\n   LOG_SCOPE (logger);\n \n-  auto_sbitmap snodes_visited (eg->get_supergraph ().m_nodes.length ());\n-  bitmap_clear (snodes_visited);\n+  feasibility_state state (eng->get_model_manager (),\n+\t\t\t   eg->get_supergraph ());\n \n-  /* Traverse the path, updating this model.  */\n-  region_model model (eng->get_model_manager ());\n+  /* Traverse the path, updating this state.  */\n   for (unsigned edge_idx = 0; edge_idx < m_edges.length (); edge_idx++)\n     {\n       const exploded_edge *eedge = m_edges[edge_idx];\n@@ -3417,106 +3416,23 @@ exploded_path::feasible_p (logger *logger, feasibility_problem **out,\n \t\t     edge_idx,\n \t\t     eedge->m_src->m_index,\n \t\t     eedge->m_dest->m_index);\n-      const exploded_node &src_enode = *eedge->m_src;\n-      const program_point &src_point = src_enode.get_point ();\n-      if (logger)\n-\t{\n-\t  logger->start_log_line ();\n-\t  src_point.print (logger->get_printer (), format (false));\n-\t  logger->end_log_line ();\n-\t}\n-\n-      /* Update state for the stmts that were processed in each enode.  */\n-      for (unsigned stmt_idx = 0; stmt_idx < src_enode.m_num_processed_stmts;\n-\t   stmt_idx++)\n-\t{\n-\t  const gimple *stmt = src_enode.get_processed_stmt (stmt_idx);\n-\n-\t  /* Update cfun and input_location in case of ICE: make it easier to\n-\t     track down which source construct we're failing to handle.  */\n-\t  auto_cfun sentinel (src_point.get_function ());\n-\t  input_location = stmt->location;\n-\n-\t  if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n-\t    model.on_assignment (assign, NULL);\n-\t  else if (const greturn *return_ = dyn_cast <const greturn *> (stmt))\n-\t    model.on_return (return_, NULL);\n-\t}\n-\n-      const superedge *sedge = eedge->m_sedge;\n-      if (sedge)\n-\t{\n-\t  if (logger)\n-\t    logger->log (\"  sedge: SN:%i -> SN:%i %s\",\n-\t\t\t sedge->m_src->m_index,\n-\t\t\t sedge->m_dest->m_index,\n-\t\t\t sedge->get_description (false));\n-\n-\t  const gimple *last_stmt = src_point.get_supernode ()->get_last_stmt ();\n-\t  rejected_constraint *rc = NULL;\n-\t  if (!model.maybe_update_for_edge (*sedge, last_stmt, NULL, &rc))\n-\t    {\n-\t      if (logger)\n-\t\t{\n-\t\t  logger->log (\"rejecting due to region model\");\n-\t\t  model.dump_to_pp (logger->get_printer (), true, false);\n-\t\t}\n-\t      if (out)\n-\t\t*out = new feasibility_problem (edge_idx, *eedge,\n-\t\t\t\t\t\tlast_stmt, rc);\n-\t      else\n-\t\tdelete rc;\n-\t      return false;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Special-case the initial eedge from the origin node to the\n-\t     initial function by pushing a frame for it.  */\n-\t  if (edge_idx == 0)\n-\t    {\n-\t      gcc_assert (eedge->m_src->m_index == 0);\n-\t      gcc_assert (src_point.get_kind () == PK_ORIGIN);\n-\t      gcc_assert (eedge->m_dest->get_point ().get_kind ()\n-\t\t\t  == PK_BEFORE_SUPERNODE);\n-\t      function *fun = eedge->m_dest->get_function ();\n-\t      gcc_assert (fun);\n-\t      model.push_frame (fun, NULL, NULL);\n-\t      if (logger)\n-\t\tlogger->log (\"  pushing frame for %qD\", fun->decl);\n-\t    }\n-\t  else if (eedge->m_custom_info)\n-\t    {\n-\t      eedge->m_custom_info->update_model (&model, *eedge);\n-\t    }\n-\t}\n \n-      /* Handle phi nodes on an edge leaving a PK_BEFORE_SUPERNODE (to\n-\t a PK_BEFORE_STMT, or a PK_AFTER_SUPERNODE if no stmts).\n-\t This will typically not be associated with a superedge.  */\n-      if (src_point.get_from_edge ())\n+      rejected_constraint *rc = NULL;\n+      if (!state.maybe_update_for_edge (logger, eedge, &rc))\n \t{\n-\t  const cfg_superedge *last_cfg_superedge\n-\t    = src_point.get_from_edge ()->dyn_cast_cfg_superedge ();\n-\t  const exploded_node &dst_enode = *eedge->m_dest;\n-\t  const unsigned dst_snode_idx = dst_enode.get_supernode ()->m_index;\n-\t  if (last_cfg_superedge)\n+\t  gcc_assert (rc);\n+\t  if (out)\n \t    {\n-\t      if (logger)\n-\t\tlogger->log (\"  update for phis\");\n-\t      model.update_for_phis (src_enode.get_supernode (),\n-\t\t\t\t     last_cfg_superedge,\n-\t\t\t\t     NULL);\n-\t      /* If we've entering an snode that we've already visited on this\n-\t\t epath, then we need do fix things up for loops; see the\n-\t\t comment for store::loop_replay_fixup.\n-\t\t Perhaps we should probably also verify the callstring,\n-\t\t and track program_points,  but hopefully doing it by supernode\n-\t\t is good enough.  */\n-\t      if (bitmap_bit_p (snodes_visited, dst_snode_idx))\n-\t\tmodel.loop_replay_fixup (dst_enode.get_state ().m_region_model);\n+\t      const exploded_node &src_enode = *eedge->m_src;\n+\t      const program_point &src_point = src_enode.get_point ();\n+\t      const gimple *last_stmt\n+\t\t= src_point.get_supernode ()->get_last_stmt ();\n+\t      *out = new feasibility_problem (edge_idx, *eedge,\n+\t\t\t\t\t      last_stmt, rc);\n \t    }\n-\t  bitmap_set_bit (snodes_visited, dst_snode_idx);\n+\t  else\n+\t    delete rc;\n+\t  return false;\n \t}\n \n       if (logger)\n@@ -3526,7 +3442,7 @@ exploded_path::feasible_p (logger *logger, feasibility_problem **out,\n \t\t       eedge->m_src->m_index,\n \t\t       eedge->m_dest->m_index);\n \t  logger->start_log_line ();\n-\t  model.dump_to_pp (logger->get_printer (), true, false);\n+\t  state.get_model ().dump_to_pp (logger->get_printer (), true, false);\n \t  logger->end_log_line ();\n \t}\n     }\n@@ -3587,6 +3503,139 @@ feasibility_problem::dump_to_pp (pretty_printer *pp) const\n     }\n }\n \n+/* class feasibility_state.  */\n+\n+/* Ctor for feasibility_state, at the beginning of a path.  */\n+\n+feasibility_state::feasibility_state (region_model_manager *manager,\n+\t\t\t\t      const supergraph &sg)\n+: m_model (manager),\n+  m_snodes_visited (sg.m_nodes.length ())\n+{\n+  bitmap_clear (m_snodes_visited);\n+}\n+\n+/* Copy ctor for feasibility_state, for extending a path.  */\n+\n+feasibility_state::feasibility_state (const feasibility_state &other)\n+: m_model (other.m_model),\n+  m_snodes_visited (const_sbitmap (other.m_snodes_visited)->n_bits)\n+{\n+  bitmap_copy (m_snodes_visited, other.m_snodes_visited);\n+}\n+\n+/* The heart of feasibility-checking.\n+\n+   Attempt to update this state in-place based on traversing EEDGE\n+   in a path.\n+   Update the model for the stmts in the src enode.\n+   Attempt to add constraints for EEDGE.\n+\n+   If feasible, return true.\n+   Otherwise, return false and write to *OUT_RC.  */\n+\n+bool\n+feasibility_state::maybe_update_for_edge (logger *logger,\n+\t\t\t\t\t  const exploded_edge *eedge,\n+\t\t\t\t\t  rejected_constraint **out_rc)\n+{\n+  const exploded_node &src_enode = *eedge->m_src;\n+  const program_point &src_point = src_enode.get_point ();\n+  if (logger)\n+    {\n+      logger->start_log_line ();\n+      src_point.print (logger->get_printer (), format (false));\n+      logger->end_log_line ();\n+    }\n+\n+  /* Update state for the stmts that were processed in each enode.  */\n+  for (unsigned stmt_idx = 0; stmt_idx < src_enode.m_num_processed_stmts;\n+       stmt_idx++)\n+    {\n+      const gimple *stmt = src_enode.get_processed_stmt (stmt_idx);\n+\n+      /* Update cfun and input_location in case of ICE: make it easier to\n+\t track down which source construct we're failing to handle.  */\n+      auto_cfun sentinel (src_point.get_function ());\n+      input_location = stmt->location;\n+\n+      if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n+\tm_model.on_assignment (assign, NULL);\n+      else if (const greturn *return_ = dyn_cast <const greturn *> (stmt))\n+\tm_model.on_return (return_, NULL);\n+    }\n+\n+  const superedge *sedge = eedge->m_sedge;\n+  if (sedge)\n+    {\n+      if (logger)\n+\tlogger->log (\"  sedge: SN:%i -> SN:%i %s\",\n+\t\t     sedge->m_src->m_index,\n+\t\t     sedge->m_dest->m_index,\n+\t\t     sedge->get_description (false));\n+\n+      const gimple *last_stmt = src_point.get_supernode ()->get_last_stmt ();\n+      if (!m_model.maybe_update_for_edge (*sedge, last_stmt, NULL, out_rc))\n+\t{\n+\t  if (logger)\n+\t    {\n+\t      logger->log (\"rejecting due to region model\");\n+\t      m_model.dump_to_pp (logger->get_printer (), true, false);\n+\t    }\n+\t  return false;\n+\t}\n+    }\n+  else\n+    {\n+      /* Special-case the initial eedge from the origin node to the\n+\t initial function by pushing a frame for it.  */\n+      if (src_point.get_kind () == PK_ORIGIN)\n+\t{\n+\t  gcc_assert (eedge->m_src->m_index == 0);\n+\t  gcc_assert (eedge->m_dest->get_point ().get_kind ()\n+\t\t      == PK_BEFORE_SUPERNODE);\n+\t  function *fun = eedge->m_dest->get_function ();\n+\t  gcc_assert (fun);\n+\t  m_model.push_frame (fun, NULL, NULL);\n+\t  if (logger)\n+\t    logger->log (\"  pushing frame for %qD\", fun->decl);\n+\t}\n+      else if (eedge->m_custom_info)\n+\t{\n+\t  eedge->m_custom_info->update_model (&m_model, *eedge);\n+\t}\n+    }\n+\n+  /* Handle phi nodes on an edge leaving a PK_BEFORE_SUPERNODE (to\n+     a PK_BEFORE_STMT, or a PK_AFTER_SUPERNODE if no stmts).\n+     This will typically not be associated with a superedge.  */\n+  if (src_point.get_from_edge ())\n+    {\n+      const cfg_superedge *last_cfg_superedge\n+\t= src_point.get_from_edge ()->dyn_cast_cfg_superedge ();\n+      const exploded_node &dst_enode = *eedge->m_dest;\n+      const unsigned dst_snode_idx = dst_enode.get_supernode ()->m_index;\n+      if (last_cfg_superedge)\n+\t{\n+\t  if (logger)\n+\t    logger->log (\"  update for phis\");\n+\t  m_model.update_for_phis (src_enode.get_supernode (),\n+\t\t\t\t  last_cfg_superedge,\n+\t\t\t\t  NULL);\n+\t  /* If we've entering an snode that we've already visited on this\n+\t     epath, then we need do fix things up for loops; see the\n+\t     comment for store::loop_replay_fixup.\n+\t     Perhaps we should probably also verify the callstring,\n+\t     and track program_points,  but hopefully doing it by supernode\n+\t     is good enough.  */\n+\t  if (bitmap_bit_p (m_snodes_visited, dst_snode_idx))\n+\t    m_model.loop_replay_fixup (dst_enode.get_state ().m_region_model);\n+\t}\n+      bitmap_set_bit (m_snodes_visited, dst_snode_idx);\n+    }\n+  return true;\n+}\n+\n /* A family of cluster subclasses for use when generating .dot output for\n    exploded graphs (-fdump-analyzer-exploded-graph), for grouping the\n    enodes into hierarchical boxes."}, {"sha": "da1cebb1aef857c5538efc387b9b8b30d7840476", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44fd4dc0b684e06c6c6d08b3994df23135bf2fbc/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44fd4dc0b684e06c6c6d08b3994df23135bf2fbc/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=44fd4dc0b684e06c6c6d08b3994df23135bf2fbc", "patch": "@@ -906,6 +906,28 @@ class feasibility_problem\n   rejected_constraint *m_rc;\n };\n \n+/* A class for capturing the state of a node when checking a path\n+   through the exploded_graph for feasibility.  */\n+\n+class feasibility_state\n+{\n+public:\n+  feasibility_state (region_model_manager *manager,\n+\t\t     const supergraph &sg);\n+  feasibility_state (const feasibility_state &other);\n+\n+  bool maybe_update_for_edge (logger *logger,\n+\t\t\t      const exploded_edge *eedge,\n+\t\t\t      rejected_constraint **out_rc);\n+\n+  const region_model &get_model () const { return m_model; }\n+  const auto_sbitmap &get_snodes_visited () const { return m_snodes_visited; }\n+\n+private:\n+  region_model m_model;\n+  auto_sbitmap m_snodes_visited;\n+};\n+\n /* Finding the shortest exploded_path within an exploded_graph.  */\n \n typedef shortest_paths<eg_traits, exploded_path> shortest_exploded_paths;"}]}