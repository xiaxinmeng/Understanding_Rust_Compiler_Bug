{"sha": "47c95231c3eba90771d739d36e608cb206c118e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdjOTUyMzFjM2ViYTkwNzcxZDczOWQzNmU2MDhjYjIwNmMxMThlNg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-28T20:30:51Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-28T20:30:51Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r613", "tree": {"sha": "4273bd8a5dc402d85737c76741cea7dda98bd7bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4273bd8a5dc402d85737c76741cea7dda98bd7bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47c95231c3eba90771d739d36e608cb206c118e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47c95231c3eba90771d739d36e608cb206c118e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47c95231c3eba90771d739d36e608cb206c118e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47c95231c3eba90771d739d36e608cb206c118e6/comments", "author": null, "committer": null, "parents": [{"sha": "88fe15a1861bd630c70d7a7027d7b3523194d08a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88fe15a1861bd630c70d7a7027d7b3523194d08a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88fe15a1861bd630c70d7a7027d7b3523194d08a"}], "stats": {"total": 41, "additions": 22, "deletions": 19}, "files": [{"sha": "b9700853bf8b76911aaa79efaf8706109a7aac1c", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c95231c3eba90771d739d36e608cb206c118e6/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c95231c3eba90771d739d36e608cb206c118e6/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=47c95231c3eba90771d739d36e608cb206c118e6", "patch": "@@ -826,39 +826,46 @@ __transfer_from_trampoline ()\t\t\\\n        && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n        && CONSTANT_ADDRESS_P (XEXP (X, 1))))\n \n+/* Check for frame pointer or stack pointer.  */\n #define MEM_REG(X) \\\n-  ((GET_CODE (X) == REG && (REGNO (X) ^ 16) < 2)\t\t\t\\\n-   || (TARGET_SB && CONSTANT_ADDRESS_P (X)))\n+  (GET_CODE (X) == REG && (REGNO (X) ^ 16) < 2)\n \n+/* A memory ref whose address is the FP or SP, with optional integer offset,\n+   or (on certain machines) a constant address.  */\n #define INDIRECTABLE_2_ADDRESS_P(X)  \\\n   (GET_CODE (X) == MEM\t\t\t\t\t\t\t\\\n    && (((xfoo0 = XEXP (X, 0), MEM_REG (xfoo0))\t\t\t\t\\\n        || (GET_CODE (xfoo0) == PLUS\t\t\t\t\t\\\n-\t   && GET_CODE (XEXP (xfoo0, 0)) == REG\t\t\t\t\\\n \t   && MEM_REG (XEXP (xfoo0, 0))\t\t\t\t\t\\\n \t   && CONSTANT_ADDRESS_NO_LABEL_P (XEXP (xfoo0, 1))))\t\t\\\n        || (TARGET_SB && CONSTANT_ADDRESS_P (xfoo0))))\n \n-#define INDIRECTABLE_ADDRESS_P(X)  \\\n-  (INDIRECTABLE_1_ADDRESS_P(X)\t\t\t\t\t\t\\\n-   || INDIRECTABLE_2_ADDRESS_P (X)\t\t\t\t\t\\\n-   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-       && CONSTANT_ADDRESS_NO_LABEL_P (XEXP (X, 1))\t\t\t\\\n-       && INDIRECTABLE_2_ADDRESS_P (XEXP (X, 0))))\n-\n /* Go to ADDR if X is a valid address not using indexing.\n    (This much is the easy part.)  */\n #define GO_IF_NONINDEXED_ADDRESS(X, ADDR)  \\\n { register rtx xfoob = (X);\t\t\t\t\t\t\\\n-  if (GET_CODE (xfoob) == REG && REG_OK_FOR_BASE_P (xfoob)) goto ADDR;\t\\\n-  if (INDIRECTABLE_1_ADDRESS_P(X)) goto ADDR;\t\t\t\t\\\n+  if (INDIRECTABLE_1_ADDRESS_P (X)) goto ADDR;\t\t\t\t\\\n   if (INDIRECTABLE_2_ADDRESS_P (X)) goto ADDR;\t\t\t\t\\\n   if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n     if (CONSTANT_ADDRESS_NO_LABEL_P (XEXP (X, 1)))\t\t\t\\\n       if (INDIRECTABLE_2_ADDRESS_P (XEXP (X, 0)))\t\t\t\\\n \tgoto ADDR;\t\t\t\t\t\t\t\\\n }\n \n+/* Go to ADDR if X is a valid address not using indexing.\n+   (This much is the easy part.)  */\n+#define GO_IF_INDEXING(X, ADDR)  \\\n+{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n+  if (GET_CODE (xfoob) == PLUS && INDEX_TERM_P (XEXP (xfoob, 0)))\t\\\n+    GO_IF_INDEXABLE_ADDRESS (XEXP (xfoob, 1), ADDR);\t\t\t\\\n+  if (GET_CODE (xfoob) == PLUS && INDEX_TERM_P (XEXP (xfoob, 1)))\t\\\n+    GO_IF_INDEXABLE_ADDRESS (XEXP (xfoob, 0), ADDR); }\t\t\t\\\n+\n+#define GO_IF_INDEXABLE_ADDRESS(X, ADDR) \\\n+{ if (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X)) goto ADDR;\t\t\\\n+  if (INDIRECTABLE_2_ADDRESS_P (X)) goto ADDR;\t\t\t\t\\\n+}\n+\n /* 1 if PROD is either a reg times size of mode MODE\n    or just a reg, if MODE is just one byte. Actually, on the ns32k,\n    since the index mode is independent of the operand size,\n@@ -879,8 +886,9 @@ __transfer_from_trampoline ()\t\t\\\n   ((xfoo2 = (unsigned)(X)-1),\t\t\t\t\t\t\\\n    ((xfoo2 < 4 && xfoo2 != 2) || xfoo2 == 7))\n \n+/* Note that xfoo0, xfoo1, xfoo2 are used in some of the submacros above.  */\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n-{ register rtx xfooy, xfooz, xfoo0, xfoo1;\t\t\t\t\\\n+{ register rtx xfooy, xfoo0, xfoo1;\t\t\t\t\t\\\n   unsigned xfoo2;\t\t\t\t\t\t\t\\\n   xfooy = X;\t\t\t\t\t\t\t\t\\\n   GO_IF_NONINDEXED_ADDRESS (xfooy, ADDR);\t\t\t\t\\\n@@ -892,12 +900,7 @@ __transfer_from_trampoline ()\t\t\\\n       else if (CONSTANT_ADDRESS_NO_LABEL_P (XEXP (xfooy, 0))\t\t\\\n \t  && GET_CODE (XEXP (xfooy, 1)) == PLUS)\t\t\t\\\n \txfooy = XEXP (xfooy, 1);\t\t\t\t\t\\\n-      xfooz = XEXP (xfooy, 1);\t\t\t\t\t\t\\\n-      if (INDEX_TERM_P (xfooz, MODE))\t\t\t\t\t\\\n-\t{ rtx t = XEXP (xfooy, 0); GO_IF_NONINDEXED_ADDRESS (t, ADDR); }\\\n-      xfooz = XEXP (xfooy, 0);\t\t\t\t\t\t\\\n-      if (INDEX_TERM_P (xfooz, MODE))\t\t\t\t\t\\\n-\t{ rtx t = XEXP (xfooy, 1); GO_IF_NONINDEXED_ADDRESS (t, ADDR); }\\\n+      GO_IF_INDEXING (xfooy, ADDR);\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else if (INDEX_TERM_P (xfooy, MODE))\t\t\t\t\t\\\n     goto ADDR;\t\t\t\t\t\t\t\t\\"}]}