{"sha": "a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkyNjZiZmE0YTlkODQ5MWQ1Y2RiMWQxNjUzZTIzZWNkYzdjYmMxNw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-04-28T01:42:43Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-04-28T01:42:43Z"}, "message": "aclocal.m4: New file with new test libiberty_AC_FUNC_STRNCMP.\n\n\t* aclocal.m4: New file with new test libiberty_AC_FUNC_STRNCMP.\n\n\t* configure.in (AC_CHECK_HEADERS): Add sys/mman.h fcntl.h.\n\t(libiberty_AC_FUNC_STRNCMP): Invoke.\n\n\t* strncmp.c: New file.\n\nFrom-SVN: r33498", "tree": {"sha": "b17419ab155b4e9009d38da21cac2f8c357d799b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b17419ab155b4e9009d38da21cac2f8c357d799b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17/comments", "author": null, "committer": null, "parents": [{"sha": "b9550bfbc60717467e93c5337306ed7748b57983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9550bfbc60717467e93c5337306ed7748b57983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9550bfbc60717467e93c5337306ed7748b57983"}], "stats": {"total": 481, "additions": 479, "deletions": 2}, "files": [{"sha": "b71886dc58ca8d2c0d7d7471354d21f337a6f84f", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17", "patch": "@@ -1,3 +1,12 @@\n+2000-04-27  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* aclocal.m4: New file with new test libiberty_AC_FUNC_STRNCMP.\n+\n+\t* configure.in (AC_CHECK_HEADERS): Add sys/mman.h fcntl.h.\n+\t(libiberty_AC_FUNC_STRNCMP): Invoke.\n+\n+\t* strncmp.c: New file.\n+\n Thu Apr 27 16:58:43 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* hashtab.c (htab_expand): Add prototype."}, {"sha": "b6a38d6052273f6b4e578ae0bd4f012e1f470919", "filename": "libiberty/aclocal.m4", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17/libiberty%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17/libiberty%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Faclocal.m4?ref=a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17", "patch": "@@ -0,0 +1,71 @@\n+dnl See whether strncmp reads past the end of its string parameters.\n+dnl On some versions of SunOS4 at least, strncmp reads a word at a time\n+dnl but erroneously reads past the end of strings.  This can cause\n+dnl a SEGV in some cases.\n+AC_DEFUN(libiberty_AC_FUNC_STRNCMP,\n+[AC_REQUIRE([AC_FUNC_MMAP])\n+AC_CACHE_CHECK([for working strncmp], ac_cv_func_strncmp_works,\n+[AC_TRY_RUN([\n+/* Test by Jim Wilson and Kaveh Ghazi.\n+   Check whether strncmp reads past the end of its string parameters. */\n+#include <sys/types.h>\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SYS_MMAN_H\n+#include <sys/mman.h>\n+#endif\n+\n+#ifndef MAP_ANON\n+#ifdef MAP_ANONYMOUS\n+#define MAP_ANON MAP_ANONYMOUS\n+#else\n+#define MAP_ANON MAP_FILE\n+#endif\n+#endif\n+\n+#ifndef MAP_FILE\n+#define MAP_FILE 0\n+#endif\n+#ifndef O_RDONLY\n+#define O_RDONLY 0\n+#endif\n+\n+#define MAP_LEN 0x10000\n+\n+main ()\n+{\n+#if defined(HAVE_MMAP) || defined(HAVE_MMAP_ANYWHERE)\n+  char *p;\n+  int dev_zero;\n+\n+  dev_zero = open (\"/dev/zero\", O_RDONLY);\n+  if (dev_zero < 0)\n+    exit (1);\n+  \n+  p = (char *) mmap (0, MAP_LEN, PROT_READ|PROT_WRITE,\n+\t\t     MAP_ANON|MAP_PRIVATE, dev_zero, 0);\n+  if (p == (char *)-1)\n+    exit (2);\n+  else\n+    {\n+      char *string = \"__si_type_info\";\n+      char *q = (char *) p + MAP_LEN - strlen (string) - 2;\n+      char *r = (char *) p + 0xe;\n+\n+      strcpy (q, string);\n+      strcpy (r, string);\n+      strncmp (r, q, 14);\n+    }\n+#endif /* HAVE_MMAP || HAVE_MMAP_ANYWHERE */\n+  exit (0);\n+}\n+], ac_cv_func_strncmp_works=yes, ac_cv_func_strncmp_works=no,\n+  ac_cv_func_strncmp_works=no)\n+rm -f core core.* *.core])\n+if test $ac_cv_func_strncmp_works = no ; then\n+  LIBOBJS=\"$LIBOBJS strncmp.o\"\n+fi\n+])"}, {"sha": "bc0c7291a8c0a82e73385efe756cf1a7ac264db1", "filename": "libiberty/config.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17/libiberty%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17/libiberty%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfig.in?ref=a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17", "patch": "@@ -13,6 +13,9 @@\n /* Define if you have <alloca.h> and it should be used (not on Ultrix).  */\n #undef HAVE_ALLOCA_H\n \n+/* Define if you have a working `mmap' system call.  */\n+#undef HAVE_MMAP\n+\n /* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */\n #undef HAVE_SYS_WAIT_H\n \n@@ -196,6 +199,9 @@\n /* Define if you have the waitpid function.  */\n #undef HAVE_WAITPID\n \n+/* Define if you have the <fcntl.h> header file.  */\n+#undef HAVE_FCNTL_H\n+\n /* Define if you have the <stdlib.h> header file.  */\n #undef HAVE_STDLIB_H\n \n@@ -208,6 +214,9 @@\n /* Define if you have the <sys/file.h> header file.  */\n #undef HAVE_SYS_FILE_H\n \n+/* Define if you have the <sys/mman.h> header file.  */\n+#undef HAVE_SYS_MMAN_H\n+\n /* Define if you have the <sys/param.h> header file.  */\n #undef HAVE_SYS_PARAM_H\n "}, {"sha": "891c656ebc487db4dd548573d7c563292c14d532", "filename": "libiberty/configure", "status": "modified", "additions": 359, "deletions": 1, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17/libiberty%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17/libiberty%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure?ref=a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17", "patch": "@@ -1058,7 +1058,7 @@ else\n fi\n echo \"$ac_t\"\"$CPP\" 1>&6\n \n-for ac_hdr in sys/file.h sys/param.h stdlib.h string.h unistd.h strings.h sys/time.h sys/resource.h sys/stat.h\n+for ac_hdr in sys/file.h sys/param.h stdlib.h string.h unistd.h strings.h sys/time.h sys/resource.h sys/stat.h sys/mman.h fcntl.h\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n@@ -2550,6 +2550,364 @@ done\n \n fi\n \n+for ac_hdr in unistd.h\n+do\n+ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n+echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n+echo \"configure:2558: checking for $ac_hdr\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 2563 \"configure\"\n+#include \"confdefs.h\"\n+#include <$ac_hdr>\n+EOF\n+ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n+{ (eval echo configure:2568: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n+if test -z \"$ac_err\"; then\n+  rm -rf conftest*\n+  eval \"ac_cv_header_$ac_safe=yes\"\n+else\n+  echo \"$ac_err\" >&5\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_header_$ac_safe=no\"\n+fi\n+rm -f conftest*\n+fi\n+if eval \"test \\\"`echo '$ac_cv_header_'$ac_safe`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`\n+  cat >> confdefs.h <<EOF\n+#define $ac_tr_hdr 1\n+EOF\n+ \n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+done\n+\n+for ac_func in getpagesize\n+do\n+echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n+echo \"configure:2597: checking for $ac_func\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 2602 \"configure\"\n+#include \"confdefs.h\"\n+/* System header to define __stub macros and hopefully few prototypes,\n+    which can conflict with char $ac_func(); below.  */\n+#include <assert.h>\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+/* We use char because int might match the return type of a gcc2\n+    builtin and then its argument prototype would still apply.  */\n+char $ac_func();\n+\n+int main() {\n+\n+/* The GNU C library defines this for functions which it implements\n+    to always fail with ENOSYS.  Some functions are actually named\n+    something starting with __ and the normal name is an alias.  */\n+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)\n+choke me\n+#else\n+$ac_func();\n+#endif\n+\n+; return 0; }\n+EOF\n+if { (eval echo configure:2625: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  eval \"ac_cv_func_$ac_func=yes\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_func_$ac_func=no\"\n+fi\n+rm -f conftest*\n+fi\n+\n+if eval \"test \\\"`echo '$ac_cv_func_'$ac_func`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`\n+  cat >> confdefs.h <<EOF\n+#define $ac_tr_func 1\n+EOF\n+ \n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+done\n+\n+echo $ac_n \"checking for working mmap\"\"... $ac_c\" 1>&6\n+echo \"configure:2650: checking for working mmap\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_func_mmap_fixed_mapped'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  if test \"$cross_compiling\" = yes; then\n+  ac_cv_func_mmap_fixed_mapped=no\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 2658 \"configure\"\n+#include \"confdefs.h\"\n+\n+/* Thanks to Mike Haertel and Jim Avera for this test.\n+   Here is a matrix of mmap possibilities:\n+\tmmap private not fixed\n+\tmmap private fixed at somewhere currently unmapped\n+\tmmap private fixed at somewhere already mapped\n+\tmmap shared not fixed\n+\tmmap shared fixed at somewhere currently unmapped\n+\tmmap shared fixed at somewhere already mapped\n+   For private mappings, we should verify that changes cannot be read()\n+   back from the file, nor mmap's back from the file at a different\n+   address.  (There have been systems where private was not correctly\n+   implemented like the infamous i386 svr4.0, and systems where the\n+   VM page cache was not coherent with the filesystem buffer cache\n+   like early versions of FreeBSD and possibly contemporary NetBSD.)\n+   For shared mappings, we should conversely verify that changes get\n+   propogated back to all the places they're supposed to be.\n+\n+   Grep wants private fixed already mapped.\n+   The main things grep needs to know about mmap are:\n+   * does it exist and is it safe to write into the mmap'd area\n+   * how to use it (BSD variants)  */\n+#include <sys/types.h>\n+#include <fcntl.h>\n+#include <sys/mman.h>\n+\n+/* This mess was copied from the GNU getpagesize.h.  */\n+#ifndef HAVE_GETPAGESIZE\n+# ifdef HAVE_UNISTD_H\n+#  include <unistd.h>\n+# endif\n+\n+/* Assume that all systems that can run configure have sys/param.h.  */\n+# ifndef HAVE_SYS_PARAM_H\n+#  define HAVE_SYS_PARAM_H 1\n+# endif\n+\n+# ifdef _SC_PAGESIZE\n+#  define getpagesize() sysconf(_SC_PAGESIZE)\n+# else /* no _SC_PAGESIZE */\n+#  ifdef HAVE_SYS_PARAM_H\n+#   include <sys/param.h>\n+#   ifdef EXEC_PAGESIZE\n+#    define getpagesize() EXEC_PAGESIZE\n+#   else /* no EXEC_PAGESIZE */\n+#    ifdef NBPG\n+#     define getpagesize() NBPG * CLSIZE\n+#     ifndef CLSIZE\n+#      define CLSIZE 1\n+#     endif /* no CLSIZE */\n+#    else /* no NBPG */\n+#     ifdef NBPC\n+#      define getpagesize() NBPC\n+#     else /* no NBPC */\n+#      ifdef PAGESIZE\n+#       define getpagesize() PAGESIZE\n+#      endif /* PAGESIZE */\n+#     endif /* no NBPC */\n+#    endif /* no NBPG */\n+#   endif /* no EXEC_PAGESIZE */\n+#  else /* no HAVE_SYS_PARAM_H */\n+#   define getpagesize() 8192\t/* punt totally */\n+#  endif /* no HAVE_SYS_PARAM_H */\n+# endif /* no _SC_PAGESIZE */\n+\n+#endif /* no HAVE_GETPAGESIZE */\n+\n+#ifdef __cplusplus\n+extern \"C\" { void *malloc(unsigned); }\n+#else\n+char *malloc();\n+#endif\n+\n+int\n+main()\n+{\n+\tchar *data, *data2, *data3;\n+\tint i, pagesize;\n+\tint fd;\n+\n+\tpagesize = getpagesize();\n+\n+\t/*\n+\t * First, make a file with some known garbage in it.\n+\t */\n+\tdata = malloc(pagesize);\n+\tif (!data)\n+\t\texit(1);\n+\tfor (i = 0; i < pagesize; ++i)\n+\t\t*(data + i) = rand();\n+\tumask(0);\n+\tfd = creat(\"conftestmmap\", 0600);\n+\tif (fd < 0)\n+\t\texit(1);\n+\tif (write(fd, data, pagesize) != pagesize)\n+\t\texit(1);\n+\tclose(fd);\n+\n+\t/*\n+\t * Next, try to mmap the file at a fixed address which\n+\t * already has something else allocated at it.  If we can,\n+\t * also make sure that we see the same garbage.\n+\t */\n+\tfd = open(\"conftestmmap\", O_RDWR);\n+\tif (fd < 0)\n+\t\texit(1);\n+\tdata2 = malloc(2 * pagesize);\n+\tif (!data2)\n+\t\texit(1);\n+\tdata2 += (pagesize - ((int) data2 & (pagesize - 1))) & (pagesize - 1);\n+\tif (data2 != mmap(data2, pagesize, PROT_READ | PROT_WRITE,\n+\t    MAP_PRIVATE | MAP_FIXED, fd, 0L))\n+\t\texit(1);\n+\tfor (i = 0; i < pagesize; ++i)\n+\t\tif (*(data + i) != *(data2 + i))\n+\t\t\texit(1);\n+\n+\t/*\n+\t * Finally, make sure that changes to the mapped area\n+\t * do not percolate back to the file as seen by read().\n+\t * (This is a bug on some variants of i386 svr4.0.)\n+\t */\n+\tfor (i = 0; i < pagesize; ++i)\n+\t\t*(data2 + i) = *(data2 + i) + 1;\n+\tdata3 = malloc(pagesize);\n+\tif (!data3)\n+\t\texit(1);\n+\tif (read(fd, data3, pagesize) != pagesize)\n+\t\texit(1);\n+\tfor (i = 0; i < pagesize; ++i)\n+\t\tif (*(data + i) != *(data3 + i))\n+\t\t\texit(1);\n+\tclose(fd);\n+\tunlink(\"conftestmmap\");\n+\texit(0);\n+}\n+\n+EOF\n+if { (eval echo configure:2798: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+then\n+  ac_cv_func_mmap_fixed_mapped=yes\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -fr conftest*\n+  ac_cv_func_mmap_fixed_mapped=no\n+fi\n+rm -fr conftest*\n+fi\n+\n+fi\n+\n+echo \"$ac_t\"\"$ac_cv_func_mmap_fixed_mapped\" 1>&6\n+if test $ac_cv_func_mmap_fixed_mapped = yes; then\n+  cat >> confdefs.h <<\\EOF\n+#define HAVE_MMAP 1\n+EOF\n+\n+fi\n+\n+\n+echo $ac_n \"checking for working strncmp\"\"... $ac_c\" 1>&6\n+echo \"configure:2822: checking for working strncmp\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_func_strncmp_works'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  if test \"$cross_compiling\" = yes; then\n+  ac_cv_func_strncmp_works=no\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 2830 \"configure\"\n+#include \"confdefs.h\"\n+\n+/* Test by Jim Wilson and Kaveh Ghazi.\n+   Check whether strncmp reads past the end of its string parameters. */\n+#include <sys/types.h>\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SYS_MMAN_H\n+#include <sys/mman.h>\n+#endif\n+\n+#ifndef MAP_ANON\n+#ifdef MAP_ANONYMOUS\n+#define MAP_ANON MAP_ANONYMOUS\n+#else\n+#define MAP_ANON MAP_FILE\n+#endif\n+#endif\n+\n+#ifndef MAP_FILE\n+#define MAP_FILE 0\n+#endif\n+#ifndef O_RDONLY\n+#define O_RDONLY 0\n+#endif\n+\n+#define MAP_LEN 0x10000\n+\n+main ()\n+{\n+#if defined(HAVE_MMAP) || defined(HAVE_MMAP_ANYWHERE)\n+  char *p;\n+  int dev_zero;\n+\n+  dev_zero = open (\"/dev/zero\", O_RDONLY);\n+  if (dev_zero < 0)\n+    exit (1);\n+  \n+  p = (char *) mmap (0, MAP_LEN, PROT_READ|PROT_WRITE,\n+\t\t     MAP_ANON|MAP_PRIVATE, dev_zero, 0);\n+  if (p == (char *)-1)\n+    exit (2);\n+  else\n+    {\n+      char *string = \"__si_type_info\";\n+      char *q = (char *) p + MAP_LEN - strlen (string) - 2;\n+      char *r = (char *) p + 0xe;\n+\n+      strcpy (q, string);\n+      strcpy (r, string);\n+      strncmp (r, q, 14);\n+    }\n+#endif /* HAVE_MMAP || HAVE_MMAP_ANYWHERE */\n+  exit (0);\n+}\n+\n+EOF\n+if { (eval echo configure:2891: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+then\n+  ac_cv_func_strncmp_works=yes\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -fr conftest*\n+  ac_cv_func_strncmp_works=no\n+fi\n+rm -fr conftest*\n+fi\n+\n+rm -f core core.* *.core\n+fi\n+\n+echo \"$ac_t\"\"$ac_cv_func_strncmp_works\" 1>&6\n+if test $ac_cv_func_strncmp_works = no ; then\n+  LIBOBJS=\"$LIBOBJS strncmp.o\"\n+fi\n+\n+\n # Install a library built with a cross compiler in $(tooldir) rather\n # than $(libdir).\n if test -z \"${with_cross_host}\"; then"}, {"sha": "0814ae3296790182985d96c215840ce59628f99a", "filename": "libiberty/configure.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17/libiberty%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17/libiberty%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure.in?ref=a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17", "patch": "@@ -109,7 +109,7 @@ AC_SUBST_FILE(host_makefile_frag)\n # It's OK to check for header files.  Although the compiler may not be\n # able to link anything, it had better be able to at least compile\n # something.\n-AC_CHECK_HEADERS(sys/file.h sys/param.h stdlib.h string.h unistd.h strings.h sys/time.h sys/resource.h sys/stat.h)\n+AC_CHECK_HEADERS(sys/file.h sys/param.h stdlib.h string.h unistd.h strings.h sys/time.h sys/resource.h sys/stat.h sys/mman.h fcntl.h)\n AC_HEADER_SYS_WAIT\n \n # This is the list of functions which libiberty will provide if they\n@@ -352,6 +352,8 @@ EOF\n   AC_CHECK_FUNCS($checkfuncs)\n fi\n \n+libiberty_AC_FUNC_STRNCMP\n+\n # Install a library built with a cross compiler in $(tooldir) rather\n # than $(libdir).\n if test -z \"${with_cross_host}\"; then"}, {"sha": "b3b9de16b10c450f1869de56bd19385669215b76", "filename": "libiberty/strncmp.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17/libiberty%2Fstrncmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17/libiberty%2Fstrncmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrncmp.c?ref=a9266bfa4a9d8491d5cdb1d1653e23ecdc7cbc17", "patch": "@@ -0,0 +1,28 @@\n+/* strncmp -- compare two strings, stop after n bytes.\n+   This function is in the public domain.  */\n+\n+#include <ansidecl.h>\n+#ifdef __STDC__\n+#include <stddef.h>\n+#else\n+#define size_t unsigned long\n+#endif\n+\n+int\n+strncmp(s1, s2, n)\n+     const char *s1, *s2;\n+     register size_t n;\n+{\n+  register unsigned char u1, u2;\n+\n+  while (n-- > 0)\n+    {\n+      u1 = (unsigned char) *s1++;\n+      u2 = (unsigned char) *s2++;\n+      if (u1 != u2)\n+\treturn u1 - u2;\n+      if (u1 == '\\0')\n+\treturn 0;\n+    }\n+  return 0;\n+}"}]}