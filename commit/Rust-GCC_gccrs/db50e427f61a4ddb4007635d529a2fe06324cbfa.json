{"sha": "db50e427f61a4ddb4007635d529a2fe06324cbfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI1MGU0MjdmNjFhNGRkYjQwMDc2MzVkNTI5YTJmZTA2MzI0Y2JmYQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-10-29T04:44:10Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-10-29T04:44:10Z"}, "message": "Re-indent in preparation for diff.\n\nFrom-SVN: r37114", "tree": {"sha": "b1454b947f76c75a8d729f475f99c210f6f7589b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1454b947f76c75a8d729f475f99c210f6f7589b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db50e427f61a4ddb4007635d529a2fe06324cbfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db50e427f61a4ddb4007635d529a2fe06324cbfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db50e427f61a4ddb4007635d529a2fe06324cbfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db50e427f61a4ddb4007635d529a2fe06324cbfa/comments", "author": null, "committer": null, "parents": [{"sha": "7d3af72b0abf82c5371aa8edb4dd7071e385fd3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d3af72b0abf82c5371aa8edb4dd7071e385fd3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d3af72b0abf82c5371aa8edb4dd7071e385fd3f"}], "stats": {"total": 240, "additions": 120, "deletions": 120}, "files": [{"sha": "9a12de967137c09fc391484a3971cadc3d5aa985", "filename": "libjava/java/util/BitSet.java", "status": "modified", "additions": 120, "deletions": 120, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db50e427f61a4ddb4007635d529a2fe06324cbfa/libjava%2Fjava%2Futil%2FBitSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db50e427f61a4ddb4007635d529a2fe06324cbfa/libjava%2Fjava%2Futil%2FBitSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FBitSet.java?ref=db50e427f61a4ddb4007635d529a2fe06324cbfa", "patch": "@@ -4,9 +4,9 @@\n \n    This file is part of libgcj.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+   This software is copyrighted work licensed under the terms of the\n+   Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+   details.  */\n \n package java.util;\n import java.io.Serializable;\n@@ -23,154 +23,154 @@\n public final class BitSet implements Cloneable, Serializable\n {\n   public void and (BitSet bs)\n-    {\n-      int max = Math.min(bits.length, bs.bits.length);\n-      int i;\n-      for (i = 0; i < max; ++i)\n-\tbits[i] &= bs.bits[i];\n-      for ( ; i < bits.length; ++i)\n-\tbits[i] = 0;\n-    }\n+  {\n+    int max = Math.min (bits.length, bs.bits.length);\n+    int i;\n+    for (i = 0; i < max; ++i)\n+      bits[i] &= bs.bits[i];\n+    for (; i < bits.length; ++i)\n+      bits[i] = 0;\n+  }\n \n   public BitSet ()\n-    {\n-      this (64);\n-    }\n+  {\n+    this (64);\n+  }\n \n   public BitSet (int nbits)\n-    {\n-      if (nbits < 0)\n-\tthrow new NegativeArraySizeException ();\n-      int length = nbits / 64;\n-      if (nbits % 64 != 0)\n-\t++length;\n-      bits = new long[length];\n-    }\n+  {\n+    if (nbits < 0)\n+      throw new NegativeArraySizeException ();\n+    int length = nbits / 64;\n+    if (nbits % 64 != 0)\n+      ++length;\n+    bits = new long[length];\n+  }\n \n   public void clear (int pos)\n-    {\n-      if (pos < 0)\n-\tthrow new IndexOutOfBoundsException ();\n-      int bit = pos % 64;\n-      int offset = pos / 64;\n-      ensure (offset);\n-      bits[offset] &= ~ (1L << bit);\n-    }\n+  {\n+    if (pos < 0)\n+      throw new IndexOutOfBoundsException ();\n+    int bit = pos % 64;\n+    int offset = pos / 64;\n+    ensure (offset);\n+    bits[offset] &= ~(1L << bit);\n+  }\n \n   public Object clone ()\n-    {\n-      BitSet bs = new BitSet (bits.length * 64);\n-      System.arraycopy(bits, 0, bs.bits, 0, bits.length);\n-      return bs;\n-    }\n+  {\n+    BitSet bs = new BitSet (bits.length * 64);\n+    System.arraycopy (bits, 0, bs.bits, 0, bits.length);\n+    return bs;\n+  }\n \n   public boolean equals (Object obj)\n-    {\n-      if (! (obj instanceof BitSet))\n+  {\n+    if (!(obj instanceof BitSet))\n+      return false;\n+    BitSet bs = (BitSet) obj;\n+    int max = Math.min (bits.length, bs.bits.length);\n+    int i;\n+    for (i = 0; i < max; ++i)\n+      if (bits[i] != bs.bits[i])\n \treturn false;\n-      BitSet bs = (BitSet) obj;\n-      int max = Math.min(bits.length, bs.bits.length);\n-      int i;\n-      for (i = 0; i < max; ++i)\n-\tif (bits[i] != bs.bits[i])\n-\t  return false;\n-      // If one is larger, check to make sure all extra bits are 0.\n-      for (int j = i; j < bits.length; ++j)\n-\tif (bits[j] != 0)\n-\t  return false;\n-      for (int j = i; j < bs.bits.length; ++j)\n-\tif (bs.bits[j] != 0)\n-\t  return false;\n-      return true;\n-    }\n+    // If one is larger, check to make sure all extra bits are 0.\n+    for (int j = i; j < bits.length; ++j)\n+      if (bits[j] != 0)\n+\treturn false;\n+    for (int j = i; j < bs.bits.length; ++j)\n+      if (bs.bits[j] != 0)\n+\treturn false;\n+    return true;\n+  }\n \n   public boolean get (int pos)\n-    {\n-      if (pos < 0)\n-\tthrow new IndexOutOfBoundsException ();\n+  {\n+    if (pos < 0)\n+      throw new IndexOutOfBoundsException ();\n \n-      int bit = pos % 64;\n-      int offset = pos / 64;\n+    int bit = pos % 64;\n+    int offset = pos / 64;\n \n-      if (offset >= bits.length)\n-\treturn false;\n+    if (offset >= bits.length)\n+      return false;\n \n-      return (bits[offset] & (1L << bit)) == 0 ? false : true;\n-    }\n+    return (bits[offset] & (1L << bit)) == 0 ? false : true;\n+  }\n \n   public int hashCode ()\n-    {\n-      long h = 1234;\n-      for (int i = bits.length - 1; i >= 0; --i)\n-\th ^= bits[i] * (i + 1);\n-      return (int) ((h >> 32) ^ h);\n-    }\n+  {\n+    long h = 1234;\n+    for (int i = bits.length - 1; i >= 0; --i)\n+      h ^= bits[i] * (i + 1);\n+    return (int) ((h >> 32) ^ h);\n+  }\n \n   public void or (BitSet bs)\n-    {\n-      ensure (bs.bits.length - 1);\n-      int i;\n-      for (i = 0; i < bs.bits.length; ++i)\n-\tbits[i] |= bs.bits[i];\n-    }\n+  {\n+    ensure (bs.bits.length - 1);\n+    int i;\n+    for (i = 0; i < bs.bits.length; ++i)\n+      bits[i] |= bs.bits[i];\n+  }\n \n   public void set (int pos)\n-    {\n-      if (pos < 0)\n-\tthrow new IndexOutOfBoundsException ();\n-      int bit = pos % 64;\n-      int offset = pos / 64;\n-      ensure (offset);\n-      bits[offset] |= 1L << bit;\n-    }\n+  {\n+    if (pos < 0)\n+      throw new IndexOutOfBoundsException ();\n+    int bit = pos % 64;\n+    int offset = pos / 64;\n+    ensure (offset);\n+    bits[offset] |= 1L << bit;\n+  }\n \n   public int size ()\n-    {\n-      return bits.length * 64;\n-    }\n+  {\n+    return bits.length * 64;\n+  }\n \n   public String toString ()\n-    {\n-      StringBuffer result = new StringBuffer (\"{\");\n-      boolean first = true;\n-      for (int i = 0; i < bits.length; ++i)\n-\t{\n-\t  int bit = 1;\n-\t  long word = bits[i];\n-\t  for (int j = 0; j < 64; ++j)\n-\t    {\n-\t      if ((word & bit) != 0)\n-\t\t{\n-\t\t  if (! first)\n-\t\t    result.append(\", \");\n-\t\t  result.append(64 * i + j);\n-\t\t  first = false;\n-\t\t}\n-\t      bit <<= 1;\n-\t    }\n-\t}\n-\n-      return result.append(\"}\").toString();\n-    }\n+  {\n+    StringBuffer result = new StringBuffer (\"{\");\n+    boolean first = true;\n+    for (int i = 0; i < bits.length; ++i)\n+      {\n+\tint bit = 1;\n+\tlong word = bits[i];\n+\tfor (int j = 0; j < 64; ++j)\n+\t  {\n+\t    if ((word & bit) != 0)\n+\t      {\n+\t\tif (!first)\n+\t\t  result.append (\", \");\n+\t\tresult.append (64 * i + j);\n+\t\tfirst = false;\n+\t      }\n+\t    bit <<= 1;\n+\t  }\n+      }\n+\n+    return result.append (\"}\").toString ();\n+  }\n \n   public void xor (BitSet bs)\n-    {\n-      ensure (bs.bits.length - 1);\n-      int i;\n-      for (i = 0; i < bs.bits.length; ++i)\n-\tbits[i] ^= bs.bits[i];\n-    }\n+  {\n+    ensure (bs.bits.length - 1);\n+    int i;\n+    for (i = 0; i < bs.bits.length; ++i)\n+      bits[i] ^= bs.bits[i];\n+  }\n \n   // Make sure the vector is big enough.\n   private final void ensure (int lastElt)\n-    {\n-      if (lastElt + 1 > bits.length)\n-\t{\n-\t  long[] nd = new long[lastElt + 1];\n-\t  System.arraycopy(bits, 0, nd, 0, bits.length);\n-\t  bits = nd;\n-\t}\n-    }\n+  {\n+    if (lastElt + 1 > bits.length)\n+      {\n+\tlong[] nd = new long[lastElt + 1];\n+\tSystem.arraycopy (bits, 0, nd, 0, bits.length);\n+\tbits = nd;\n+      }\n+  }\n \n   // The actual bits.\n   private long[] bits;"}]}