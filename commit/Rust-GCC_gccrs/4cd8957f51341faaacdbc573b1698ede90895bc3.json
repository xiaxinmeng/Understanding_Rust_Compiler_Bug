{"sha": "4cd8957f51341faaacdbc573b1698ede90895bc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNkODk1N2Y1MTM0MWZhYWFjZGJjNTczYjE2OThlZGU5MDg5NWJjMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-03-28T19:50:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-03-28T19:50:28Z"}, "message": "re PR ipa/60243 (IPA is slow on large cgraph tree)\n\n\tPR ipa/60243\n\t* ipa-inline.c (want_inline_small_function_p): Short circuit large\n\tfunctions; reorganize to make cheap checks first.\n\t(inline_small_functions): Do not estimate growth when dumping;\n\tit is expensive.\n\t* ipa-inline.h (inline_summary): Add min_size.\n\t(growth_likely_positive): New function.\n\t* ipa-inline-analysis.c (dump_inline_summary): Add min_size.\n\t(set_cond_stmt_execution_predicate): Cleanup.\n\t(estimate_edge_size_and_time): Compute min_size.\n\t(estimate_calls_size_and_time): Likewise.\n\t(estimate_node_size_and_time): Likewise.\n\t(inline_update_overall_summary): Update min_size.\n\t(do_estimate_edge_time): Likewise.\n\t(do_estimate_edge_size): Update.\n\t(do_estimate_edge_hints): Update.\n\t(growth_likely_positive): New function.\n\nFrom-SVN: r208916", "tree": {"sha": "2fd5928dd4a0a5449b5d3be2dd387d5f444ae009", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fd5928dd4a0a5449b5d3be2dd387d5f444ae009"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cd8957f51341faaacdbc573b1698ede90895bc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd8957f51341faaacdbc573b1698ede90895bc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cd8957f51341faaacdbc573b1698ede90895bc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd8957f51341faaacdbc573b1698ede90895bc3/comments", "author": null, "committer": null, "parents": [{"sha": "ff76f4e2c026de44df33189825ae3f2b7d582f1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff76f4e2c026de44df33189825ae3f2b7d582f1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff76f4e2c026de44df33189825ae3f2b7d582f1a"}], "stats": {"total": 233, "additions": 164, "deletions": 69}, "files": [{"sha": "a4108ad12782de1bc52d7025d223a385563ae217", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd8957f51341faaacdbc573b1698ede90895bc3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd8957f51341faaacdbc573b1698ede90895bc3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4cd8957f51341faaacdbc573b1698ede90895bc3", "patch": "@@ -1,3 +1,23 @@\n+2014-03-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/60243\n+\t* ipa-inline.c (want_inline_small_function_p): Short circuit large\n+\tfunctions; reorganize to make cheap checks first.\n+\t(inline_small_functions): Do not estimate growth when dumping;\n+\tit is expensive.\n+\t* ipa-inline.h (inline_summary): Add min_size.\n+\t(growth_likely_positive): New function.\n+\t* ipa-inline-analysis.c (dump_inline_summary): Add min_size.\n+\t(set_cond_stmt_execution_predicate): Cleanup.\n+\t(estimate_edge_size_and_time): Compute min_size.\n+\t(estimate_calls_size_and_time): Likewise.\n+\t(estimate_node_size_and_time): Likewise.\n+\t(inline_update_overall_summary): Update min_size.\n+\t(do_estimate_edge_time): Likewise.\n+\t(do_estimate_edge_size): Update.\n+\t(do_estimate_edge_hints): Update.\n+\t(growth_likely_positive): New function.\n+\n 2014-03-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/60693"}, {"sha": "8e0f5dd898899e98de41c6a4b5a28545d5ef45b1", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 100, "deletions": 21, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd8957f51341faaacdbc573b1698ede90895bc3/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd8957f51341faaacdbc573b1698ede90895bc3/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=4cd8957f51341faaacdbc573b1698ede90895bc3", "patch": "@@ -1397,6 +1397,7 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n       fprintf (f, \"  global time:     %i\\n\", s->time);\n       fprintf (f, \"  self size:       %i\\n\", s->self_size);\n       fprintf (f, \"  global size:     %i\\n\", s->size);\n+      fprintf (f, \"  min size:       %i\\n\", s->min_size);\n       fprintf (f, \"  self stack:      %i\\n\",\n \t       (int) s->estimated_self_stack_size);\n       fprintf (f, \"  global stack:    %i\\n\", (int) s->estimated_stack_size);\n@@ -1746,8 +1747,7 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n \t  if (this_code != ERROR_MARK)\n \t    {\n \t      struct predicate p = add_condition (summary, index, &aggpos,\n-\t\t\t\t\t\t  e->flags & EDGE_TRUE_VALUE\n-\t\t\t\t\t\t  ? code : inverted_code,\n+\t\t\t\t\t\t  this_code,\n \t\t\t\t\t\t  gimple_cond_rhs (last));\n \t      e->aux = pool_alloc (edge_predicate_pool);\n \t      *(struct predicate *) e->aux = p;\n@@ -2991,10 +2991,15 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n   return isummary->inlinable;\n }\n \n-/* Increase SIZE and TIME for size and time needed to handle edge E.  */\n+/* Increase SIZE, MIN_SIZE (if non-NULL) and TIME for size and time needed to\n+   handle edge E with probability PROB.\n+   Set HINTS if edge may be devirtualized.\n+   KNOWN_VALS, KNOWN_AGGS and KNOWN_BINFOS describe context of the call\n+   site.  */\n \n static inline void\n-estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time,\n+estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n+\t\t\t     int *time,\n \t\t\t     int prob,\n \t\t\t     vec<tree> known_vals,\n \t\t\t     vec<tree> known_binfos,\n@@ -3004,12 +3009,16 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time,\n   struct inline_edge_summary *es = inline_edge_summary (e);\n   int call_size = es->call_stmt_size;\n   int call_time = es->call_stmt_time;\n+  int cur_size;\n   if (!e->callee\n       && estimate_edge_devirt_benefit (e, &call_size, &call_time,\n \t\t\t\t       known_vals, known_binfos, known_aggs)\n       && hints && cgraph_maybe_hot_edge_p (e))\n     *hints |= INLINE_HINT_indirect_call;\n-  *size += call_size * INLINE_SIZE_SCALE;\n+  cur_size = call_size * INLINE_SIZE_SCALE;\n+  *size += cur_size;\n+  if (min_size)\n+    *min_size += cur_size;\n   *time += apply_probability ((gcov_type) call_time, prob)\n     * e->frequency * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE);\n   if (*time > MAX_TIME * INLINE_TIME_SCALE)\n@@ -3018,12 +3027,14 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time,\n \n \n \n-/* Increase SIZE and TIME for size and time needed to handle all calls in NODE.\n-   POSSIBLE_TRUTHS, KNOWN_VALS and KNOWN_BINFOS describe context of the call\n-   site.  */\n+/* Increase SIZE, MIN_SIZE and TIME for size and time needed to handle all\n+   calls in NODE.\n+   POSSIBLE_TRUTHS, KNOWN_VALS, KNOWN_AGGS and KNOWN_BINFOS describe context of\n+   the call site.  */\n \n static void\n-estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n+estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n+\t\t\t      int *min_size, int *time,\n \t\t\t      inline_hints *hints,\n \t\t\t      clause_t possible_truths,\n \t\t\t      vec<tree> known_vals,\n@@ -3041,12 +3052,15 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n \t    {\n \t      /* Predicates of calls shall not use NOT_CHANGED codes,\n \t         sowe do not need to compute probabilities.  */\n-\t      estimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE,\n+\t      estimate_edge_size_and_time (e, size,\n+\t\t\t\t\t   es->predicate ? NULL : min_size,\n+\t\t\t\t\t   time, REG_BR_PROB_BASE,\n \t\t\t\t\t   known_vals, known_binfos,\n \t\t\t\t\t   known_aggs, hints);\n \t    }\n \t  else\n-\t    estimate_calls_size_and_time (e->callee, size, time, hints,\n+\t    estimate_calls_size_and_time (e->callee, size, min_size, time,\n+\t\t\t\t\t  hints,\n \t\t\t\t\t  possible_truths,\n \t\t\t\t\t  known_vals, known_binfos,\n \t\t\t\t\t  known_aggs);\n@@ -3057,24 +3071,31 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n       struct inline_edge_summary *es = inline_edge_summary (e);\n       if (!es->predicate\n \t  || evaluate_predicate (es->predicate, possible_truths))\n-\testimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE,\n+\testimate_edge_size_and_time (e, size,\n+\t\t\t\t     es->predicate ? NULL : min_size,\n+\t\t\t\t     time, REG_BR_PROB_BASE,\n \t\t\t\t     known_vals, known_binfos, known_aggs,\n \t\t\t\t     hints);\n     }\n }\n \n \n /* Estimate size and time needed to execute NODE assuming\n-   POSSIBLE_TRUTHS clause, and KNOWN_VALS and KNOWN_BINFOS information\n-   about NODE's arguments. */\n+   POSSIBLE_TRUTHS clause, and KNOWN_VALS, KNOWN_AGGS and KNOWN_BINFOS\n+   information about NODE's arguments.  If non-NULL use also probability\n+   information present in INLINE_PARAM_SUMMARY vector.\n+   Additionally detemine hints determined by the context.  Finally compute\n+   minimal size needed for the call that is independent on the call context and\n+   can be used for fast estimates.  Return the values in RET_SIZE,\n+   RET_MIN_SIZE, RET_TIME and RET_HINTS.  */\n \n static void\n estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     clause_t possible_truths,\n \t\t\t     vec<tree> known_vals,\n \t\t\t     vec<tree> known_binfos,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n-\t\t\t     int *ret_size, int *ret_time,\n+\t\t\t     int *ret_size, int *ret_min_size, int *ret_time,\n \t\t\t     inline_hints *ret_hints,\n \t\t\t     vec<inline_param_summary>\n \t\t\t     inline_param_summary)\n@@ -3083,6 +3104,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   size_time_entry *e;\n   int size = 0;\n   int time = 0;\n+  int min_size = 0;\n   inline_hints hints = 0;\n   int i;\n \n@@ -3128,6 +3150,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \tgcc_checking_assert (time >= 0);\n \n       }\n+  gcc_checking_assert (true_predicate_p (&(*info->entry)[0].predicate));\n+  min_size = (*info->entry)[0].size;\n   gcc_checking_assert (size >= 0);\n   gcc_checking_assert (time >= 0);\n \n@@ -3145,19 +3169,22 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   if (DECL_DECLARED_INLINE_P (node->decl))\n     hints |= INLINE_HINT_declared_inline;\n \n-  estimate_calls_size_and_time (node, &size, &time, &hints, possible_truths,\n+  estimate_calls_size_and_time (node, &size, &min_size, &time, &hints, possible_truths,\n \t\t\t\tknown_vals, known_binfos, known_aggs);\n   gcc_checking_assert (size >= 0);\n   gcc_checking_assert (time >= 0);\n   time = RDIV (time, INLINE_TIME_SCALE);\n   size = RDIV (size, INLINE_SIZE_SCALE);\n+  min_size = RDIV (min_size, INLINE_SIZE_SCALE);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n   size:%i time:%i\\n\", (int) size, (int) time);\n   if (ret_time)\n     *ret_time = time;\n   if (ret_size)\n     *ret_size = size;\n+  if (ret_min_size)\n+    *ret_min_size = min_size;\n   if (ret_hints)\n     *ret_hints = hints;\n   return;\n@@ -3182,7 +3209,7 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n   clause = evaluate_conditions_for_known_args (node, false, known_vals,\n \t\t\t\t\t       known_aggs);\n   estimate_node_size_and_time (node, clause, known_vals, known_binfos,\n-\t\t\t       known_aggs, ret_size, ret_time, hints, vNULL);\n+\t\t\t       known_aggs, ret_size, NULL, ret_time, hints, vNULL);\n }\n \n /* Translate all conditions from callee representation into caller\n@@ -3583,7 +3610,8 @@ inline_update_overall_summary (struct cgraph_node *node)\n       if (info->time > MAX_TIME * INLINE_TIME_SCALE)\n \tinfo->time = MAX_TIME * INLINE_TIME_SCALE;\n     }\n-  estimate_calls_size_and_time (node, &info->size, &info->time, NULL,\n+  estimate_calls_size_and_time (node, &info->size, &info->min_size,\n+\t\t\t\t&info->time, NULL,\n \t\t\t\t~(clause_t) (1 << predicate_false_condition),\n \t\t\t\tvNULL, vNULL, vNULL);\n   info->time = (info->time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n@@ -3628,6 +3656,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   vec<tree> known_binfos;\n   vec<ipa_agg_jump_function_p> known_aggs;\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n+  int min_size;\n \n   callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n \n@@ -3636,7 +3665,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n \t\t\t\t&clause, &known_vals, &known_binfos,\n \t\t\t\t&known_aggs);\n   estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n-\t\t\t       known_aggs, &size, &time, &hints, es->param);\n+\t\t\t       known_aggs, &size, &min_size, &time, &hints, es->param);\n   known_vals.release ();\n   known_binfos.release ();\n   known_aggs.release ();\n@@ -3646,6 +3675,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   /* When caching, update the cache entry.  */\n   if (edge_growth_cache.exists ())\n     {\n+      inline_summary (edge->callee)->min_size = min_size;\n       if ((int) edge_growth_cache.length () <= edge->uid)\n \tedge_growth_cache.safe_grow_cleared (cgraph_edge_max_uid);\n       edge_growth_cache[edge->uid].time = time + (time >= 0);\n@@ -3689,7 +3719,7 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n \t\t\t\t&clause, &known_vals, &known_binfos,\n \t\t\t\t&known_aggs);\n   estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n-\t\t\t       known_aggs, &size, NULL, NULL, vNULL);\n+\t\t\t       known_aggs, &size, NULL, NULL, NULL, vNULL);\n   known_vals.release ();\n   known_binfos.release ();\n   known_aggs.release ();\n@@ -3728,7 +3758,7 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n \t\t\t\t&clause, &known_vals, &known_binfos,\n \t\t\t\t&known_aggs);\n   estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n-\t\t\t       known_aggs, NULL, NULL, &hints, vNULL);\n+\t\t\t       known_aggs, NULL, NULL, NULL, &hints, vNULL);\n   known_vals.release ();\n   known_binfos.release ();\n   known_aggs.release ();\n@@ -3848,6 +3878,55 @@ do_estimate_growth (struct cgraph_node *node)\n }\n \n \n+/* Make cheap estimation if growth of NODE is likely positive knowing\n+   EDGE_GROWTH of one particular edge. \n+   We assume that most of other edges will have similar growth\n+   and skip computation if there are too many callers.  */\n+\n+bool\n+growth_likely_positive (struct cgraph_node *node, int edge_growth ATTRIBUTE_UNUSED)\n+{\n+  int max_callers;\n+  int ret;\n+  struct cgraph_edge *e;\n+  gcc_checking_assert (edge_growth > 0);\n+\n+  /* Unlike for functions called once, we play unsafe with\n+     COMDATs.  We can allow that since we know functions\n+     in consideration are small (and thus risk is small) and\n+     moreover grow estimates already accounts that COMDAT\n+     functions may or may not disappear when eliminated from\n+     current unit. With good probability making aggressive\n+     choice in all units is going to make overall program\n+     smaller.\n+\n+     Consequently we ask cgraph_can_remove_if_no_direct_calls_p\n+     instead of\n+     cgraph_will_be_removed_from_program_if_no_direct_calls  */\n+  if (DECL_EXTERNAL (node->decl)\n+      || !cgraph_can_remove_if_no_direct_calls_p (node))\n+    return true;\n+\n+  /* If there is cached value, just go ahead.  */\n+  if ((int)node_growth_cache.length () > node->uid\n+      && (ret = node_growth_cache[node->uid]))\n+    return ret > 0;\n+  if (!cgraph_will_be_removed_from_program_if_no_direct_calls (node)\n+      && (!DECL_COMDAT (node->decl)\n+\t  || !cgraph_can_remove_if_no_direct_calls_p (node)))\n+    return true;\n+  max_callers = inline_summary (node)->size * 4 / edge_growth + 2;\n+\n+  for (e = node->callers; e; e = e->next_caller)\n+    {\n+      max_callers--;\n+      if (!max_callers)\n+\treturn true;\n+    }\n+  return estimate_growth (node) > 0;\n+}\n+\n+\n /* This function performs intraprocedural analysis in NODE that is required to\n    inline indirect calls.  */\n "}, {"sha": "1e1e1183b8659e117d1a00b849e9cb24f8f3d2aa", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 41, "deletions": 48, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd8957f51341faaacdbc573b1698ede90895bc3/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd8957f51341faaacdbc573b1698ede90895bc3/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=4cd8957f51341faaacdbc573b1698ede90895bc3", "patch": "@@ -573,6 +573,24 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n       e->inline_failed = CIF_FUNCTION_NOT_INLINE_CANDIDATE;\n       want_inline = false;\n     }\n+  /* Do fast and conservative check if the function can be good\n+     inline cnadidate.  At themoment we allow inline hints to\n+     promote non-inline function to inline and we increase\n+     MAX_INLINE_INSNS_SINGLE 16fold for inline functions.  */\n+  else if (!DECL_DECLARED_INLINE_P (callee->decl)\n+\t   && inline_summary (callee)->min_size - inline_edge_summary (e)->call_stmt_size\n+\t      > MAX (MAX_INLINE_INSNS_SINGLE, MAX_INLINE_INSNS_AUTO))\n+    {\n+      e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n+      want_inline = false;\n+    }\n+  else if (DECL_DECLARED_INLINE_P (callee->decl)\n+\t   && inline_summary (callee)->min_size - inline_edge_summary (e)->call_stmt_size\n+\t      > 16 * MAX_INLINE_INSNS_SINGLE)\n+    {\n+      e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n+      want_inline = false;\n+    }\n   else\n     {\n       int growth = estimate_edge_growth (e);\n@@ -585,56 +603,26 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t hints suggests that inlining given function is very profitable.  */\n       else if (DECL_DECLARED_INLINE_P (callee->decl)\n \t       && growth >= MAX_INLINE_INSNS_SINGLE\n-\t       && !big_speedup\n-\t       && !(hints & (INLINE_HINT_indirect_call\n-\t\t\t     | INLINE_HINT_loop_iterations\n-\t\t\t     | INLINE_HINT_array_index\n-\t\t\t     | INLINE_HINT_loop_stride)))\n+\t       && ((!big_speedup\n+\t\t    && !(hints & (INLINE_HINT_indirect_call\n+\t\t\t\t  | INLINE_HINT_loop_iterations\n+\t\t\t\t  | INLINE_HINT_array_index\n+\t\t\t\t  | INLINE_HINT_loop_stride)))\n+\t\t   || growth >= MAX_INLINE_INSNS_SINGLE * 16))\n \t{\n           e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n \t  want_inline = false;\n \t}\n-      /* Before giving up based on fact that caller size will grow, allow\n-         functions that are called few times and eliminating the offline\n-\t copy will lead to overall code size reduction.\n-\t Not all of these will be handled by subsequent inlining of functions\n-\t called once: in particular weak functions are not handled or funcitons\n-\t that inline to multiple calls but a lot of bodies is optimized out.\n-\t Finally we want to inline earlier to allow inlining of callbacks.\n-\n-\t This is slightly wrong on aggressive side:  it is entirely possible\n-\t that function is called many times with a context where inlining\n-\t reduces code size and few times with a context where inlining increase\n-\t code size.  Resoluting growth estimate will be negative even if it\n-\t would make more sense to keep offline copy and do not inline into the\n-\t call sites that makes the code size grow.  \n-\n-\t When badness orders the calls in a way that code reducing calls come\n-\t first, this situation is not a problem at all: after inlining all\n-\t \"good\" calls, we will realize that keeping the function around is\n-\t better.  */\n-      else if (growth <= MAX_INLINE_INSNS_SINGLE\n-\t       /* Unlike for functions called once, we play unsafe with\n-\t\t  COMDATs.  We can allow that since we know functions\n-\t\t  in consideration are small (and thus risk is small) and\n-\t\t  moreover grow estimates already accounts that COMDAT\n-\t\t  functions may or may not disappear when eliminated from\n-\t\t  current unit. With good probability making aggressive\n-\t\t  choice in all units is going to make overall program\n-\t\t  smaller.\n-\n-\t\t  Consequently we ask cgraph_can_remove_if_no_direct_calls_p\n-\t\t  instead of\n-\t\t  cgraph_will_be_removed_from_program_if_no_direct_calls  */\n-\t        && !DECL_EXTERNAL (callee->decl)\n-\t\t&& cgraph_can_remove_if_no_direct_calls_p (callee)\n-\t\t&& estimate_growth (callee) <= 0)\n-\t;\n       else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t       && !flag_inline_functions)\n \t{\n-          e->inline_failed = CIF_NOT_DECLARED_INLINED;\n-\t  want_inline = false;\n+\t  /* growth_likely_positive is expensive, always test it last.  */\n+          if (growth >= MAX_INLINE_INSNS_SINGLE\n+\t      || growth_likely_positive (callee, growth))\n+\t    {\n+              e->inline_failed = CIF_NOT_DECLARED_INLINED;\n+\t      want_inline = false;\n+ \t    }\n \t}\n       /* Apply MAX_INLINE_INSNS_AUTO limit for functions not declared inline\n \t Upgrade it to MAX_INLINE_INSNS_SINGLE when hints suggests that\n@@ -649,11 +637,18 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t\t\t\t    MAX_INLINE_INSNS_SINGLE)\n \t\t\t     : MAX_INLINE_INSNS_AUTO))\n \t{\n-          e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n-\t  want_inline = false;\n+\t  /* growth_likely_positive is expensive, always test it last.  */\n+          if (growth >= MAX_INLINE_INSNS_SINGLE\n+\t      || growth_likely_positive (callee, growth))\n+\t    {\n+\t      e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n+\t      want_inline = false;\n+ \t    }\n \t}\n       /* If call is cold, do not inline when function body would grow. */\n-      else if (!cgraph_maybe_hot_edge_p (e))\n+      else if (!cgraph_maybe_hot_edge_p (e)\n+\t       && (growth >= MAX_INLINE_INSNS_SINGLE\n+\t\t   || growth_likely_positive (callee, growth)))\n \t{\n           e->inline_failed = CIF_UNLIKELY_CALL;\n \t  want_inline = false;\n@@ -1723,14 +1718,12 @@ inline_small_functions (void)\n \t\t   inline_summary (callee)->size);\n \t  fprintf (dump_file,\n \t\t   \" to be inlined into %s/%i in %s:%i\\n\"\n-\t\t   \" Estimated growth after inlined into all is %+i insns.\\n\"\n \t\t   \" Estimated badness is %i, frequency %.2f.\\n\",\n \t\t   edge->caller->name (), edge->caller->order,\n \t\t   flag_wpa ? \"unknown\"\n \t\t   : gimple_filename ((const_gimple) edge->call_stmt),\n \t\t   flag_wpa ? -1\n \t\t   : gimple_lineno ((const_gimple) edge->call_stmt),\n-\t\t   estimate_growth (callee),\n \t\t   badness,\n \t\t   edge->frequency / (double)CGRAPH_FREQ_BASE);\n \t  if (edge->count)"}, {"sha": "8ee075f93000116b4a8d46c097f41c8d2c69fd9b", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd8957f51341faaacdbc573b1698ede90895bc3/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd8957f51341faaacdbc573b1698ede90895bc3/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=4cd8957f51341faaacdbc573b1698ede90895bc3", "patch": "@@ -117,6 +117,8 @@ struct GTY(()) inline_summary\n   int self_size;\n   /* Time of the function body.  */\n   int self_time;\n+  /* Minimal size increase after inlining.  */\n+  int min_size;\n \n   /* False when there something makes inlining impossible (such as va_arg).  */\n   unsigned inlinable : 1;\n@@ -220,6 +222,7 @@ void estimate_ipcp_clone_size_and_time (struct cgraph_node *,\n \t\t\t\t\tvec<ipa_agg_jump_function_p>,\n \t\t\t\t\tint *, int *, inline_hints *);\n int do_estimate_growth (struct cgraph_node *);\n+bool growth_likely_positive (struct cgraph_node *, int);\n void inline_merge_summary (struct cgraph_edge *edge);\n void inline_update_overall_summary (struct cgraph_node *node);\n int do_estimate_edge_size (struct cgraph_edge *edge);"}]}