{"sha": "1d135d9873524cde4b6ad56a1fe1a83ca0023b48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQxMzVkOTg3MzUyNGNkZTRiNmFkNTZhMWZlMWE4M2NhMDAyM2I0OA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-06-05T17:37:58Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-06-05T17:37:58Z"}, "message": "rs6000.c (toplevel): Include attribs.h.\n\n[gcc]\n2017-06-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (toplevel): Include attribs.h.\n\t(CLONE_*): New constants to define the processors we can generate\n\tcode for with the target_clone attribute.\n\t(rs6000_clone_map): New array to identify which clone processors\n\tthe current program is running on.\n\t(TARGET_COMPARE_VERSION_PRIORITY): Define to enable the\n\ttarget_clone attribute.\n\t(TARGET_GENERATE_VERSION_DISPATCHER_BODY): Likewise.\n\t(TARGET_GET_FUNCTION_VERSIONS_DISPATCHER): Likewise.\n\t(TARGET_OPTION_FUNCTION_VERSIONS): Likewise.\n\t(cpu_expand_builtin): Add support for target_clone attribute.\n\t(rs6000_valid_attribute_p): Allow \"default\" attribute.\n\t(get_decl_name): New debug function to simplify printing the\n\tcurrent function name in debugging statements.\n\t(rs6000_clone_priority): New functions to support the target_clone\n\tattribute, and be able to generate code to switch between ISA 2.05\n\tthrough ISA 3.0 (power6 through power9).\n\t(rs6000_compare_version_priority): Likewise.\n\t(rs6000_get_function_versions_dispatcher): Likewise.\n\t(make_resolver_func): Likewise.\n\t(add_condition_to_bb): Likewise.\n\t(dispatch_function_versions): Likewise.\n\t(rs6000_generate_version_dispatcher_body): Likewise.\n\t(rs6000_can_inline_p): Call get_decl_name for debugging usage.\n\t(fusion_gpr_load_p): Fix a spacing issue.\n\t* doc/extend.texi (Common Function Attributes): Document that the\n\tPowerPC supports the target_clone attribute.\n\n[gcc/testsuite]\n2017-06-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/clone1.c: New test.\n\nFrom-SVN: r248883", "tree": {"sha": "ed5d6e10af61a994f1379aa66862ab710ce6452d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed5d6e10af61a994f1379aa66862ab710ce6452d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d135d9873524cde4b6ad56a1fe1a83ca0023b48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d135d9873524cde4b6ad56a1fe1a83ca0023b48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d135d9873524cde4b6ad56a1fe1a83ca0023b48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d135d9873524cde4b6ad56a1fe1a83ca0023b48/comments", "author": null, "committer": null, "parents": [{"sha": "94895bd98d8dc129f8a21d9a0272f5a86debcfe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94895bd98d8dc129f8a21d9a0272f5a86debcfe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94895bd98d8dc129f8a21d9a0272f5a86debcfe0"}], "stats": {"total": 579, "additions": 571, "deletions": 8}, "files": [{"sha": "cc8112d4e01cbc2d37234e839e6fee597313c99f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d135d9873524cde4b6ad56a1fe1a83ca0023b48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d135d9873524cde4b6ad56a1fe1a83ca0023b48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d135d9873524cde4b6ad56a1fe1a83ca0023b48", "patch": "@@ -1,3 +1,33 @@\n+2017-06-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (toplevel): Include attribs.h.\n+\t(CLONE_*): New constants to define the processors we can generate\n+\tcode for with the target_clone attribute.\n+\t(rs6000_clone_map): New array to identify which clone processors\n+\tthe current program is running on.\n+\t(TARGET_COMPARE_VERSION_PRIORITY): Define to enable the\n+\ttarget_clone attribute.\n+\t(TARGET_GENERATE_VERSION_DISPATCHER_BODY): Likewise.\n+\t(TARGET_GET_FUNCTION_VERSIONS_DISPATCHER): Likewise.\n+\t(TARGET_OPTION_FUNCTION_VERSIONS): Likewise.\n+\t(cpu_expand_builtin): Add support for target_clone attribute.\n+\t(rs6000_valid_attribute_p): Allow \"default\" attribute.\n+\t(get_decl_name): New debug function to simplify printing the\n+\tcurrent function name in debugging statements.\n+\t(rs6000_clone_priority): New functions to support the target_clone\n+\tattribute, and be able to generate code to switch between ISA 2.05\n+\tthrough ISA 3.0 (power6 through power9).\n+\t(rs6000_compare_version_priority): Likewise.\n+\t(rs6000_get_function_versions_dispatcher): Likewise.\n+\t(make_resolver_func): Likewise.\n+\t(add_condition_to_bb): Likewise.\n+\t(dispatch_function_versions): Likewise.\n+\t(rs6000_generate_version_dispatcher_body): Likewise.\n+\t(rs6000_can_inline_p): Call get_decl_name for debugging usage.\n+\t(fusion_gpr_load_p): Fix a spacing issue.\n+\t* doc/extend.texi (Common Function Attributes): Document that the\n+\tPowerPC supports the target_clone attribute.\n+\n 2017-06-05  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* config/arm/arm.h: explain F symbol found in description of ARM"}, {"sha": "e8051aa674a724a7c59b5636ef325a12fa48a510", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 502, "deletions": 7, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d135d9873524cde4b6ad56a1fe1a83ca0023b48/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d135d9873524cde4b6ad56a1fe1a83ca0023b48/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=1d135d9873524cde4b6ad56a1fe1a83ca0023b48", "patch": "@@ -42,6 +42,7 @@\n #include \"flags.h\"\n #include \"alias.h\"\n #include \"fold-const.h\"\n+#include \"attribs.h\"\n #include \"stor-layout.h\"\n #include \"calls.h\"\n #include \"print-tree.h\"\n@@ -386,6 +387,34 @@ static const struct\n   { \"ieee128\",\t\tPPC_FEATURE2_HAS_IEEE128,\t1 }\n };\n \n+/* On PowerPC, we have a limited number of target clones that we care about\n+   which means we can use an array to hold the options, rather than having more\n+   elaborate data structures to identify each possible variation.  Order the\n+   clones from the default to the highest ISA.  */\n+enum {\n+  CLONE_DEFAULT\t\t= 0,\t\t/* default clone.  */\n+  CLONE_ISA_2_05,\t\t\t/* ISA 2.05 (power6).  */\n+  CLONE_ISA_2_06,\t\t\t/* ISA 2.06 (power7).  */\n+  CLONE_ISA_2_07,\t\t\t/* ISA 2.07 (power8).  */\n+  CLONE_ISA_3_00,\t\t\t/* ISA 3.00 (power9).  */\n+  CLONE_MAX\n+};\n+\n+/* Map compiler ISA bits into HWCAP names.  */\n+struct clone_map {\n+  HOST_WIDE_INT isa_mask;\t/* rs6000_isa mask */\n+  const char *name;\t\t/* name to use in __builtin_cpu_supports.  */\n+};\n+\n+static const struct clone_map rs6000_clone_map[CLONE_MAX] = {\n+  { 0,\t\t\t\t\"\" },\t\t/* Default options.  */\n+  { OPTION_MASK_CMPB,\t\t\"arch_2_05\" },\t/* ISA 2.05 (power6).  */\n+  { OPTION_MASK_POPCNTD,\t\"arch_2_06\" },\t/* ISA 2.06 (power7).  */\n+  { OPTION_MASK_P8_VECTOR,\t\"arch_2_07\" },\t/* ISA 2.07 (power8).  */\n+  { OPTION_MASK_P9_VECTOR,\t\"arch_3_00\" },\t/* ISA 3.00 (power9).  */\n+};\n+\n+\n /* Newer LIBCs explicitly export this symbol to declare that they provide\n    the AT_PLATFORM and AT_HWCAP/AT_HWCAP2 values in the TCB.  We emit a\n    reference to this symbol whenever we expand a CPU builtin, so that\n@@ -1971,6 +2000,21 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 1\n+\n+#undef TARGET_COMPARE_VERSION_PRIORITY\n+#define TARGET_COMPARE_VERSION_PRIORITY rs6000_compare_version_priority\n+\n+#undef TARGET_GENERATE_VERSION_DISPATCHER_BODY\n+#define TARGET_GENERATE_VERSION_DISPATCHER_BODY\t\t\t\t\\\n+  rs6000_generate_version_dispatcher_body\n+\n+#undef TARGET_GET_FUNCTION_VERSIONS_DISPATCHER\n+#define TARGET_GET_FUNCTION_VERSIONS_DISPATCHER\t\t\t\t\\\n+  rs6000_get_function_versions_dispatcher\n+\n+#undef TARGET_OPTION_FUNCTION_VERSIONS\n+#define TARGET_OPTION_FUNCTION_VERSIONS common_function_versions\n+\n \f\n \n /* Processor table.  */\n@@ -15611,6 +15655,14 @@ cpu_expand_builtin (enum rs6000_builtins fcode, tree exp ATTRIBUTE_UNUSED,\n \n #ifdef TARGET_LIBC_PROVIDES_HWCAP_IN_TCB\n   tree arg = TREE_OPERAND (CALL_EXPR_ARG (exp, 0), 0);\n+  /* Target clones creates an ARRAY_REF instead of STRING_CST, convert it back\n+     to a STRING_CST.  */\n+  if (TREE_CODE (arg) == ARRAY_REF\n+      && TREE_CODE (TREE_OPERAND (arg, 0)) == STRING_CST\n+      && TREE_CODE (TREE_OPERAND (arg, 1)) == INTEGER_CST\n+      && compare_tree_int (TREE_OPERAND (arg, 1), 0) == 0)\n+    arg = TREE_OPERAND (arg, 0);\n+\n   if (TREE_CODE (arg) != STRING_CST)\n     {\n       error (\"builtin %s only accepts a string argument\",\n@@ -39766,6 +39818,14 @@ rs6000_valid_attribute_p (tree fndecl,\n       fprintf (stderr, \"--------------------\\n\");\n     }\n \n+  /* attribute((target(\"default\"))) does nothing, beyond\n+     affecting multi-versioning.  */\n+  if (TREE_VALUE (args)\n+      && TREE_CODE (TREE_VALUE (args)) == STRING_CST\n+      && TREE_CHAIN (args) == NULL_TREE\n+      && strcmp (TREE_STRING_POINTER (TREE_VALUE (args)), \"default\") == 0)\n+    return true;\n+\n   old_optimize = build_optimization_node (&global_options);\n   func_optimize = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);\n \n@@ -40197,6 +40257,446 @@ rs6000_disable_incompatible_switches (void)\n   return ignore_masks;\n }\n \n+\f\n+/* Helper function for printing the function name when debugging.  */\n+\n+static const char *\n+get_decl_name (tree fn)\n+{\n+  tree name;\n+\n+  if (!fn)\n+    return \"<null>\";\n+\n+  name = DECL_NAME (fn);\n+  if (!name)\n+    return \"<no-name>\";\n+\n+  return IDENTIFIER_POINTER (name);\n+}\n+\n+/* Return the clone id of the target we are compiling code for in a target\n+   clone.  The clone id is ordered from 0 (default) to CLONE_MAX-1 and gives\n+   the priority list for the target clones (ordered from lowest to\n+   highest).  */\n+\n+static int\n+rs6000_clone_priority (tree fndecl)\n+{\n+  tree fn_opts = DECL_FUNCTION_SPECIFIC_TARGET (fndecl);\n+  HOST_WIDE_INT isa_masks;\n+  int ret = CLONE_DEFAULT;\n+  tree attrs = lookup_attribute (\"target\", DECL_ATTRIBUTES (fndecl));\n+  const char *attrs_str = NULL;\n+\n+  attrs = TREE_VALUE (TREE_VALUE (attrs));\n+  attrs_str = TREE_STRING_POINTER (attrs);\n+\n+  /* Return priority zero for default function.  Return the ISA needed for the\n+     function if it is not the default.  */\n+  if (strcmp (attrs_str, \"default\") != 0)\n+    {\n+      if (fn_opts == NULL_TREE)\n+\tfn_opts = target_option_default_node;\n+\n+      if (!fn_opts || !TREE_TARGET_OPTION (fn_opts))\n+\tisa_masks = rs6000_isa_flags;\n+      else\n+\tisa_masks = TREE_TARGET_OPTION (fn_opts)->x_rs6000_isa_flags;\n+\n+      for (ret = CLONE_MAX - 1; ret != 0; ret--)\n+\tif ((rs6000_clone_map[ret].isa_mask & isa_masks) != 0)\n+\t  break;\n+    }\n+\n+  if (TARGET_DEBUG_TARGET)\n+    fprintf (stderr, \"rs6000_get_function_version_priority (%s) => %d\\n\",\n+\t     get_decl_name (fndecl), ret);\n+\n+  return ret;\n+}\n+\n+/* This compares the priority of target features in function DECL1 and DECL2.\n+   It returns positive value if DECL1 is higher priority, negative value if\n+   DECL2 is higher priority and 0 if they are the same.  Note, priorities are\n+   ordered from lowest (CLONE_DEFAULT) to highest (currently CLONE_ISA_3_0).  */\n+\n+static int\n+rs6000_compare_version_priority (tree decl1, tree decl2)\n+{\n+  int priority1 = rs6000_clone_priority (decl1);\n+  int priority2 = rs6000_clone_priority (decl2);\n+  int ret = priority1 - priority2;\n+\n+  if (TARGET_DEBUG_TARGET)\n+    fprintf (stderr, \"rs6000_compare_version_priority (%s, %s) => %d\\n\",\n+\t     get_decl_name (decl1), get_decl_name (decl2), ret);\n+\n+  return ret;\n+}\n+\n+/* Make a dispatcher declaration for the multi-versioned function DECL.\n+   Calls to DECL function will be replaced with calls to the dispatcher\n+   by the front-end.  Returns the decl of the dispatcher function.  */\n+\n+static tree\n+rs6000_get_function_versions_dispatcher (void *decl)\n+{\n+  tree fn = (tree) decl;\n+  struct cgraph_node *node = NULL;\n+  struct cgraph_node *default_node = NULL;\n+  struct cgraph_function_version_info *node_v = NULL;\n+  struct cgraph_function_version_info *first_v = NULL;\n+\n+  tree dispatch_decl = NULL;\n+\n+  struct cgraph_function_version_info *default_version_info = NULL;\n+  gcc_assert (fn != NULL && DECL_FUNCTION_VERSIONED (fn));\n+\n+  if (TARGET_DEBUG_TARGET)\n+    fprintf (stderr, \"rs6000_get_function_versions_dispatcher (%s)\\n\",\n+\t     get_decl_name (fn));\n+\n+  node = cgraph_node::get (fn);\n+  gcc_assert (node != NULL);\n+\n+  node_v = node->function_version ();\n+  gcc_assert (node_v != NULL);\n+\n+  if (node_v->dispatcher_resolver != NULL)\n+    return node_v->dispatcher_resolver;\n+\n+  /* Find the default version and make it the first node.  */\n+  first_v = node_v;\n+  /* Go to the beginning of the chain.  */\n+  while (first_v->prev != NULL)\n+    first_v = first_v->prev;\n+\n+  default_version_info = first_v;\n+  while (default_version_info != NULL)\n+    {\n+      const tree decl2 = default_version_info->this_node->decl;\n+      if (is_function_default_version (decl2))\n+        break;\n+      default_version_info = default_version_info->next;\n+    }\n+\n+  /* If there is no default node, just return NULL.  */\n+  if (default_version_info == NULL)\n+    return NULL;\n+\n+  /* Make default info the first node.  */\n+  if (first_v != default_version_info)\n+    {\n+      default_version_info->prev->next = default_version_info->next;\n+      if (default_version_info->next)\n+        default_version_info->next->prev = default_version_info->prev;\n+      first_v->prev = default_version_info;\n+      default_version_info->next = first_v;\n+      default_version_info->prev = NULL;\n+    }\n+\n+  default_node = default_version_info->this_node;\n+\n+  if (targetm.has_ifunc_p ())\n+    {\n+      struct cgraph_function_version_info *it_v = NULL;\n+      struct cgraph_node *dispatcher_node = NULL;\n+      struct cgraph_function_version_info *dispatcher_version_info = NULL;\n+\n+      /* Right now, the dispatching is done via ifunc.  */\n+      dispatch_decl = make_dispatcher_decl (default_node->decl);\n+\n+      dispatcher_node = cgraph_node::get_create (dispatch_decl);\n+      gcc_assert (dispatcher_node != NULL);\n+      dispatcher_node->dispatcher_function = 1;\n+      dispatcher_version_info\n+\t= dispatcher_node->insert_new_function_version ();\n+      dispatcher_version_info->next = default_version_info;\n+      dispatcher_node->definition = 1;\n+\n+      /* Set the dispatcher for all the versions.  */\n+      it_v = default_version_info;\n+      while (it_v != NULL)\n+\t{\n+\t  it_v->dispatcher_resolver = dispatch_decl;\n+\t  it_v = it_v->next;\n+\t}\n+    }\n+  else\n+    {\n+      error_at (DECL_SOURCE_LOCATION (default_node->decl),\n+\t\t\"multiversioning needs ifunc which is not supported \"\n+\t\t\"on this target\");\n+    }\n+\n+  return dispatch_decl;\n+}\n+\n+/* Make the resolver function decl to dispatch the versions of a multi-\n+   versioned function, DEFAULT_DECL.  Create an empty basic block in the\n+   resolver and store the pointer in EMPTY_BB.  Return the decl of the resolver\n+   function.  */\n+\n+static tree\n+make_resolver_func (const tree default_decl,\n+\t\t    const tree dispatch_decl,\n+\t\t    basic_block *empty_bb)\n+{\n+  /* IFUNC's have to be globally visible.  So, if the default_decl is\n+     not, then the name of the IFUNC should be made unique.  */\n+  bool is_uniq = (TREE_PUBLIC (default_decl) == 0);\n+\n+  /* Append the filename to the resolver function if the versions are\n+     not externally visible.  This is because the resolver function has\n+     to be externally visible for the loader to find it.  So, appending\n+     the filename will prevent conflicts with a resolver function from\n+     another module which is based on the same version name.  */\n+  char *resolver_name = make_unique_name (default_decl, \"resolver\", is_uniq);\n+\n+  /* The resolver function should return a (void *).  */\n+  tree type = build_function_type_list (ptr_type_node, NULL_TREE);\n+  tree decl = build_fn_decl (resolver_name, type);\n+  tree decl_name = get_identifier (resolver_name);\n+  SET_DECL_ASSEMBLER_NAME (decl, decl_name);\n+\n+  DECL_NAME (decl) = decl_name;\n+  TREE_USED (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_IGNORED_P (decl) = 0;\n+  /* IFUNC resolvers have to be externally visible.  */\n+  TREE_PUBLIC (decl) = 1;\n+  DECL_UNINLINABLE (decl) = 1;\n+\n+  /* Resolver is not external, body is generated.  */\n+  DECL_EXTERNAL (decl) = 0;\n+  DECL_EXTERNAL (dispatch_decl) = 0;\n+\n+  DECL_CONTEXT (decl) = NULL_TREE;\n+  DECL_INITIAL (decl) = make_node (BLOCK);\n+  DECL_STATIC_CONSTRUCTOR (decl) = 0;\n+\n+  if (DECL_COMDAT_GROUP (default_decl) || TREE_PUBLIC (default_decl))\n+    {\n+      /* In this case, each translation unit with a call to this\n+\t versioned function will put out a resolver.  Ensure it\n+\t is comdat to keep just one copy.  */\n+      DECL_COMDAT (decl) = 1;\n+      make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));\n+    }\n+\n+  /* Build result decl and add to function_decl.  */\n+  tree t = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE, ptr_type_node);\n+  DECL_ARTIFICIAL (t) = 1;\n+  DECL_IGNORED_P (t) = 1;\n+  DECL_RESULT (decl) = t;\n+\n+  gimplify_function_tree (decl);\n+  push_cfun (DECL_STRUCT_FUNCTION (decl));\n+  *empty_bb = init_lowered_empty_function (decl, false, 0);\n+\n+  cgraph_node::add_new_function (decl, true);\n+  symtab->call_cgraph_insertion_hooks (cgraph_node::get_create (decl));\n+\n+  pop_cfun ();\n+\n+  /* Mark dispatch_decl as \"ifunc\" with resolver as resolver_name.  */\n+  DECL_ATTRIBUTES (dispatch_decl)\n+    = make_attribute (\"ifunc\", resolver_name, DECL_ATTRIBUTES (dispatch_decl));\n+\n+  cgraph_node::create_same_body_alias (dispatch_decl, decl);\n+  XDELETEVEC (resolver_name);\n+  return decl;\n+}\n+\n+/* This adds a condition to the basic_block NEW_BB in function FUNCTION_DECL to\n+   return a pointer to VERSION_DECL if we are running on a machine that\n+   supports the index CLONE_ISA hardware architecture bits.  This function will\n+   be called during version dispatch to decide which function version to\n+   execute.  It returns the basic block at the end, to which more conditions\n+   can be added.  */\n+\n+static basic_block\n+add_condition_to_bb (tree function_decl, tree version_decl,\n+\t\t     int clone_isa, basic_block new_bb)\n+{\n+  push_cfun (DECL_STRUCT_FUNCTION (function_decl));\n+\n+  gcc_assert (new_bb != NULL);\n+  gimple_seq gseq = bb_seq (new_bb);\n+\n+\n+  tree convert_expr = build1 (CONVERT_EXPR, ptr_type_node,\n+\t\t\t      build_fold_addr_expr (version_decl));\n+  tree result_var = create_tmp_var (ptr_type_node);\n+  gimple *convert_stmt = gimple_build_assign (result_var, convert_expr);\n+  gimple *return_stmt = gimple_build_return (result_var);\n+\n+  if (clone_isa == CLONE_DEFAULT)\n+    {\n+      gimple_seq_add_stmt (&gseq, convert_stmt);\n+      gimple_seq_add_stmt (&gseq, return_stmt);\n+      set_bb_seq (new_bb, gseq);\n+      gimple_set_bb (convert_stmt, new_bb);\n+      gimple_set_bb (return_stmt, new_bb);\n+      pop_cfun ();\n+      return new_bb;\n+    }\n+\n+  tree bool_zero = build_int_cst (bool_int_type_node, 0);\n+  tree cond_var = create_tmp_var (bool_int_type_node);\n+  tree predicate_decl = rs6000_builtin_decls [(int) RS6000_BUILTIN_CPU_SUPPORTS];\n+  const char *arg_str = rs6000_clone_map[clone_isa].name;\n+  tree predicate_arg = build_string_literal (strlen (arg_str) + 1, arg_str);\n+  gimple *call_cond_stmt = gimple_build_call (predicate_decl, 1, predicate_arg);\n+  gimple_call_set_lhs (call_cond_stmt, cond_var);\n+\n+  gimple_set_block (call_cond_stmt, DECL_INITIAL (function_decl));\n+  gimple_set_bb (call_cond_stmt, new_bb);\n+  gimple_seq_add_stmt (&gseq, call_cond_stmt);\n+\n+  gimple *if_else_stmt = gimple_build_cond (NE_EXPR, cond_var, bool_zero,\n+\t\t\t\t\t    NULL_TREE, NULL_TREE);\n+  gimple_set_block (if_else_stmt, DECL_INITIAL (function_decl));\n+  gimple_set_bb (if_else_stmt, new_bb);\n+  gimple_seq_add_stmt (&gseq, if_else_stmt);\n+\n+  gimple_seq_add_stmt (&gseq, convert_stmt);\n+  gimple_seq_add_stmt (&gseq, return_stmt);\n+  set_bb_seq (new_bb, gseq);\n+\n+  basic_block bb1 = new_bb;\n+  edge e12 = split_block (bb1, if_else_stmt);\n+  basic_block bb2 = e12->dest;\n+  e12->flags &= ~EDGE_FALLTHRU;\n+  e12->flags |= EDGE_TRUE_VALUE;\n+\n+  edge e23 = split_block (bb2, return_stmt);\n+  gimple_set_bb (convert_stmt, bb2);\n+  gimple_set_bb (return_stmt, bb2);\n+\n+  basic_block bb3 = e23->dest;\n+  make_edge (bb1, bb3, EDGE_FALSE_VALUE);\n+\n+  remove_edge (e23);\n+  make_edge (bb2, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+\n+  pop_cfun ();\n+  return bb3;\n+}\n+\n+/* This function generates the dispatch function for multi-versioned functions.\n+   DISPATCH_DECL is the function which will contain the dispatch logic.\n+   FNDECLS are the function choices for dispatch, and is a tree chain.\n+   EMPTY_BB is the basic block pointer in DISPATCH_DECL in which the dispatch\n+   code is generated.  */\n+\n+static int\n+dispatch_function_versions (tree dispatch_decl,\n+\t\t\t    void *fndecls_p,\n+\t\t\t    basic_block *empty_bb)\n+{\n+  int ix;\n+  tree ele;\n+  vec<tree> *fndecls;\n+  tree clones[CLONE_MAX];\n+\n+  if (TARGET_DEBUG_TARGET)\n+    fputs (\"dispatch_function_versions, top\\n\", stderr);\n+\n+  gcc_assert (dispatch_decl != NULL\n+\t      && fndecls_p != NULL\n+\t      && empty_bb != NULL);\n+\n+  /* fndecls_p is actually a vector.  */\n+  fndecls = static_cast<vec<tree> *> (fndecls_p);\n+\n+  /* At least one more version other than the default.  */\n+  gcc_assert (fndecls->length () >= 2);\n+\n+  /* The first version in the vector is the default decl.  */\n+  memset ((void *) clones, '\\0', sizeof (clones));\n+  clones[CLONE_DEFAULT] = (*fndecls)[0];\n+\n+  /* On the PowerPC, we do not need to call __builtin_cpu_init, which is a NOP\n+     on the PowerPC (on the x86_64, it is not a NOP).  The builtin function\n+     __builtin_cpu_support ensures that the TOC fields are setup by requiring a\n+     recent glibc.  If we ever need to call __builtin_cpu_init, we would need\n+     to insert the code here to do the call.  */\n+\n+  for (ix = 1; fndecls->iterate (ix, &ele); ++ix)\n+    {\n+      int priority = rs6000_clone_priority (ele);\n+      if (!clones[priority])\n+\tclones[priority] = ele;\n+    }\n+\n+  for (ix = CLONE_MAX - 1; ix >= 0; ix--)\n+    if (clones[ix])\n+      {\n+\tif (TARGET_DEBUG_TARGET)\n+\t  fprintf (stderr, \"dispatch_function_versions, clone %d, %s\\n\",\n+\t\t   ix, get_decl_name (clones[ix]));\n+\n+\t*empty_bb = add_condition_to_bb (dispatch_decl, clones[ix], ix,\n+\t\t\t\t\t *empty_bb);\n+      }\n+\n+  return 0;\n+}\n+\n+/* Generate the dispatching code body to dispatch multi-versioned function\n+   DECL.  The target hook is called to process the \"target\" attributes and\n+   provide the code to dispatch the right function at run-time.  NODE points\n+   to the dispatcher decl whose body will be created.  */\n+\n+static tree\n+rs6000_generate_version_dispatcher_body (void *node_p)\n+{\n+  tree resolver;\n+  basic_block empty_bb;\n+  struct cgraph_node *node = (cgraph_node *) node_p;\n+  struct cgraph_function_version_info *ninfo = node->function_version ();\n+\n+  if (ninfo->dispatcher_resolver)\n+    return ninfo->dispatcher_resolver;\n+\n+  /* node is going to be an alias, so remove the finalized bit.  */\n+  node->definition = false;\n+\n+  /* The first version in the chain corresponds to the default version.  */\n+  ninfo->dispatcher_resolver = resolver\n+    = make_resolver_func (ninfo->next->this_node->decl, node->decl, &empty_bb);\n+\n+  if (TARGET_DEBUG_TARGET)\n+    fprintf (stderr, \"rs6000_get_function_versions_dispatcher, %s\\n\",\n+\t     get_decl_name (resolver));\n+\n+  push_cfun (DECL_STRUCT_FUNCTION (resolver));\n+  auto_vec<tree, 2> fn_ver_vec;\n+\n+  for (struct cgraph_function_version_info *vinfo = ninfo->next;\n+       vinfo;\n+       vinfo = vinfo->next)\n+    {\n+      struct cgraph_node *version = vinfo->this_node;\n+      /* Check for virtual functions here again, as by this time it should\n+\t have been determined if this function needs a vtable index or\n+\t not.  This happens for methods in derived classes that override\n+\t virtual methods in base classes but are not explicitly marked as\n+\t virtual.  */\n+      if (DECL_VINDEX (version->decl))\n+\tsorry (\"Virtual function multiversioning not supported\");\n+\n+      fn_ver_vec.safe_push (version->decl);\n+    }\n+\n+  dispatch_function_versions (resolver, &fn_ver_vec, &empty_bb);\n+  cgraph_edge::rebuild_edges ();\n+  pop_cfun ();\n+  return resolver;\n+}\n+\n \f\n /* Hook to determine if one function can safely inline another.  */\n \n@@ -40231,12 +40731,7 @@ rs6000_can_inline_p (tree caller, tree callee)\n \n   if (TARGET_DEBUG_TARGET)\n     fprintf (stderr, \"rs6000_can_inline_p:, caller %s, callee %s, %s inline\\n\",\n-\t     (DECL_NAME (caller)\n-\t      ? IDENTIFIER_POINTER (DECL_NAME (caller))\n-\t      : \"<unknown>\"),\n-\t     (DECL_NAME (callee)\n-\t      ? IDENTIFIER_POINTER (DECL_NAME (callee))\n-\t      : \"<unknown>\"),\n+\t     get_decl_name (caller), get_decl_name (callee),\n \t     (ret ? \"can\" : \"cannot\"));\n \n   return ret;\n@@ -40894,7 +41389,7 @@ bool\n fusion_gpr_load_p (rtx addis_reg,\t/* register set via addis.  */\n \t\t   rtx addis_value,\t/* addis value.  */\n \t\t   rtx target,\t\t/* target register that is loaded.  */\n-\t\t   rtx mem)\t\t/* bottom part of the memory addr. */\n+\t\t   rtx mem)\t\t/* bottom part of the memory addr.  */\n {\n   rtx addr;\n   rtx base_reg;"}, {"sha": "d147d5ac4a0f6d2eed115e6e22578bffdddd4d51", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d135d9873524cde4b6ad56a1fe1a83ca0023b48/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d135d9873524cde4b6ad56a1fe1a83ca0023b48/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=1d135d9873524cde4b6ad56a1fe1a83ca0023b48", "patch": "@@ -3257,7 +3257,15 @@ For instance, on an x86, you could compile a function with\n @code{target_clones(\"sse4.1,avx\")}.  GCC creates two function clones,\n one compiled with @option{-msse4.1} and another with @option{-mavx}.\n It also creates a resolver function (see the @code{ifunc} attribute\n-above) that dynamically selects a clone suitable for current architecture.\n+above) that dynamically selects a clone suitable for current\n+architecture.\n+\n+On a PowerPC, you can compile a function with\n+@code{target_clones(\"cpu=power9,default\")}.  GCC will create two\n+function clones, one compiled with @option{-mcpu=power9} and another\n+with the default options.  It also creates a resolver function (see\n+the @code{ifunc} attribute above) that dynamically selects a clone\n+suitable for current architecture.\n \n @item unused\n @cindex @code{unused} function attribute"}, {"sha": "c9fb8baa77bfcef4fe757aafc3d47bd4c1c7bb20", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d135d9873524cde4b6ad56a1fe1a83ca0023b48/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d135d9873524cde4b6ad56a1fe1a83ca0023b48/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1d135d9873524cde4b6ad56a1fe1a83ca0023b48", "patch": "@@ -1,3 +1,7 @@\n+2017-06-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/clone1.c: New test.\n+\n 2017-06-05  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/70601"}, {"sha": "5c69db8e217f90448b43fc99b9bfb6d4c7610698", "filename": "gcc/testsuite/gcc.target/powerpc/clone1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d135d9873524cde4b6ad56a1fe1a83ca0023b48/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fclone1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d135d9873524cde4b6ad56a1fe1a83ca0023b48/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fclone1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fclone1.c?ref=1d135d9873524cde4b6ad56a1fe1a83ca0023b48", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+\n+/* Power9 (aka, ISA 3.0) has a MODSD instruction to do modulus, while Power8\n+   (aka, ISA 2.07) has to do modulus with divide and multiply.  Make sure\n+   both clone functions are generated.\n+\n+   Restrict ourselves to Linux, since IFUNC might not be supported in other\n+   operating systems.  */\n+\n+__attribute__((target_clones(\"cpu=power9,default\")))\n+long mod_func (long a, long b)\n+{\n+  return a % b;\n+}\n+\n+long mod_func_or (long a, long b, long c)\n+{\n+  return mod_func (a, b) | c;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mdivd\\M}  1 } } */\n+/* { dg-final { scan-assembler-times {\\mmulld\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mmodsd\\M} 1 } } */"}]}