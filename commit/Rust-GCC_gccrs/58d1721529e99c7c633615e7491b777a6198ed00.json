{"sha": "58d1721529e99c7c633615e7491b777a6198ed00", "node_id": "C_kwDOANBUbNoAKDU4ZDE3MjE1MjllOTljN2M2MzM2MTVlNzQ5MWI3NzdhNjE5OGVkMDA", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-01T09:41:45Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-01T10:19:11Z"}, "message": "macroinvocation: Only allow *stmt* visitors when semicoloned", "tree": {"sha": "494dea8c86717a2efeacd4dc757de0bc5d48ff0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/494dea8c86717a2efeacd4dc757de0bc5d48ff0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58d1721529e99c7c633615e7491b777a6198ed00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58d1721529e99c7c633615e7491b777a6198ed00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58d1721529e99c7c633615e7491b777a6198ed00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58d1721529e99c7c633615e7491b777a6198ed00/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12d156566af84ec834abb7e18feac6e8f5884451", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12d156566af84ec834abb7e18feac6e8f5884451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12d156566af84ec834abb7e18feac6e8f5884451"}], "stats": {"total": 374, "additions": 181, "deletions": 193}, "files": [{"sha": "826d41af658d122e324b439aad54092c816d984c", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=58d1721529e99c7c633615e7491b777a6198ed00", "patch": "@@ -1275,19 +1275,6 @@ TypeAlias::as_string () const\n   return str;\n }\n \n-// FIXME: ARTHUR: Check if this is necessary for MacroInvocation\n-// std::string\n-// MacroInvocationSemi::as_string () const\n-// {\n-//   std::string str = \"MacroInvocationSemi: \";\n-//\n-//   str += append_attributes (outer_attrs, OUTER);\n-//\n-//   str += \"\\n\" + invoc_data.as_string ();\n-//\n-//   return str;\n-// }\n-\n std::string\n ExternBlock::as_string () const\n {"}, {"sha": "2b396248ec6ae3d953e6dc2866fa16358163a53e", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=58d1721529e99c7c633615e7491b777a6198ed00", "patch": "@@ -469,6 +469,8 @@ class MacroInvocation : public TypeNoBounds,\n   // Important for when we actually expand the macro\n   bool is_semi_coloned;\n \n+  NodeId node_id;\n+\n public:\n   std::string as_string () const override;\n \n@@ -477,7 +479,9 @@ class MacroInvocation : public TypeNoBounds,\n \t\t   bool is_semi_coloned = false)\n     : outer_attrs (std::move (outer_attrs)),\n       invoc_data (std::move (invoc_data)), locus (locus),\n-      fragment (ASTFragment::create_empty ()), is_semi_coloned (is_semi_coloned)\n+      fragment (ASTFragment::create_empty ()),\n+      is_semi_coloned (is_semi_coloned),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   Location get_locus () const override final { return locus; }\n@@ -504,6 +508,8 @@ class MacroInvocation : public TypeNoBounds,\n     return ExprWithoutBlock::get_node_id ();\n   }\n \n+  NodeId get_macro_node_id () const { return node_id; }\n+\n   MacroInvocData &get_invoc_data () { return invoc_data; }\n \n   ASTFragment &get_fragment () { return fragment; }\n@@ -562,12 +568,9 @@ class MacroInvocation : public TypeNoBounds,\n   }\n \n   ExprWithoutBlock *to_stmt () const override\n-  \n-   \n-   \n-   \n-  { \n-    auto new_impl  = clone_macro_invocation_impl();\n+\n+  {\n+    auto new_impl = clone_macro_invocation_impl ();\n     new_impl->is_semi_coloned = true;\n \n     return new_impl;"}, {"sha": "be3859fb51fca9087bfa5da82cfdf8c73381914e", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 62, "deletions": 84, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=58d1721529e99c7c633615e7491b777a6198ed00", "patch": "@@ -310,31 +310,33 @@ class AttrVisitor : public AST::ASTVisitor\n     // supposedly does not require - cfg does nothing\n   }\n \n-  // FIXME: ARTHUR: Check to see if necessary for MacroInvocation\n-  // void visit (AST::MacroInvocationSemi &macro_invoc) override\n-  // {\n-  //   // initial strip test based on outer attrs\n-  //   expander.expand_cfg_attrs (macro_invoc.get_outer_attrs ());\n-  //   if (expander.fails_cfg_with_expand (macro_invoc.get_outer_attrs ()))\n-  //     {\n-  // macro_invoc.mark_for_strip ();\n-  // return;\n-  //     }\n+  void visit (AST::MacroInvocation &macro_invoc) override\n+  {\n+    // initial strip test based on outer attrs\n+    expander.expand_cfg_attrs (macro_invoc.get_outer_attrs ());\n+    if (expander.fails_cfg_with_expand (macro_invoc.get_outer_attrs ()))\n+      {\n+\tmacro_invoc.mark_for_strip ();\n+\treturn;\n+      }\n \n-  //   // can't strip simple path\n+    // can't strip simple path\n \n-  //   // I don't think any macro token trees can be stripped in any way\n+    // I don't think any macro token trees can be stripped in any way\n \n-  //   // TODO: maybe have cfg! macro stripping behaviour here?\n+    // TODO: maybe have cfg! macro stripping behaviour here?\n \n-  //   expander.expand_invoc_semi (macro_invoc);\n+    if (macro_invoc.has_semicolon ())\n+      expander.expand_invoc_semi (macro_invoc);\n+    else\n+      expander.expand_invoc (macro_invoc);\n \n-  //   // we need to visit the expanded fragments since it may need cfg\n-  //   expansion\n-  //   // and it may be recursive\n-  //   for (auto &node : macro_invoc.get_fragment ().get_nodes ())\n-  //     node.accept_vis (*this);\n-  // }\n+    // we need to visit the expanded fragments since it may need cfg\n+    // expansion\n+    // and it may be recursive\n+    for (auto &node : macro_invoc.get_fragment ().get_nodes ())\n+      node.accept_vis (*this);\n+  }\n \n   void visit (AST::PathInExpression &path) override\n   {\n@@ -2536,28 +2538,6 @@ class AttrVisitor : public AST::ASTVisitor\n     expander.mappings->insert_macro_def (&rules_def);\n   }\n \n-  void visit (AST::MacroInvocation &macro_invoc) override\n-  {\n-    // FIXME\n-    // we probably need another recurision check here\n-\n-    // initial strip test based on outer attrs\n-    expander.expand_cfg_attrs (macro_invoc.get_outer_attrs ());\n-    if (expander.fails_cfg_with_expand (macro_invoc.get_outer_attrs ()))\n-      {\n-\tmacro_invoc.mark_for_strip ();\n-\treturn;\n-      }\n-\n-    // I don't think any macro token trees can be stripped in any way\n-    expander.expand_invoc (macro_invoc);\n-\n-    // we need to visit the expanded fragments since it may need cfg expansion\n-    // and it may be recursive\n-    for (auto &node : macro_invoc.get_fragment ().get_nodes ())\n-      node.accept_vis (*this);\n-  }\n-\n   void visit (AST::MetaItemPath &) override {}\n   void visit (AST::MetaItemSeq &) override {}\n   void visit (AST::MetaWord &) override {}\n@@ -3210,48 +3190,46 @@ MacroExpander::expand_invoc (AST::MacroInvocation &invoc)\n   invoc.set_fragment (std::move (fragment));\n }\n \n-// FIXME: ARTHUR: Check to see if necessary for MacroInvocation\n-// void\n-// MacroExpander::expand_invoc_semi (AST::MacroInvocationSemi &invoc)\n-// {\n-//   if (depth_exceeds_recursion_limit ())\n-//     {\n-//       rust_error_at (invoc.get_locus (), \"reached recursion limit\");\n-//       return;\n-//     }\n-//\n-//   AST::MacroInvocData &invoc_data = invoc.get_invoc_data ();\n-//\n-//   // lookup the rules for this macro\n-//   NodeId resolved_node = UNKNOWN_NODEID;\n-//   bool found = resolver->get_macro_scope ().lookup (\n-//     Resolver::CanonicalPath::new_seg (invoc.get_macro_node_id (),\n-// \t\t\t\t      invoc_data.get_path ().as_string ()),\n-//     &resolved_node);\n-//   if (!found)\n-//     {\n-//       rust_error_at (invoc.get_locus (), \"unknown macro\");\n-//       return;\n-//     }\n-//\n-//   // lookup the rules\n-//   AST::MacroRulesDefinition *rules_def = nullptr;\n-//   bool ok = mappings->lookup_macro_def (resolved_node, &rules_def);\n-//   rust_assert (ok);\n-//\n-//   auto fragment = AST::ASTFragment::create_empty ();\n-//\n-//   if (rules_def->is_builtin ())\n-//     fragment\n-//       = rules_def->get_builtin_transcriber () (invoc.get_locus (),\n-//       invoc_data);\n-//   else\n-//     fragment\n-//       = expand_decl_macro (invoc.get_locus (), invoc_data, *rules_def, true);\n-//\n-//   // lets attach this fragment to the invocation\n-//   invoc.set_fragment (std::move (fragment));\n-// }\n+void\n+MacroExpander::expand_invoc_semi (AST::MacroInvocation &invoc)\n+{\n+  if (depth_exceeds_recursion_limit ())\n+    {\n+      rust_error_at (invoc.get_locus (), \"reached recursion limit\");\n+      return;\n+    }\n+\n+  AST::MacroInvocData &invoc_data = invoc.get_invoc_data ();\n+\n+  // lookup the rules for this macro\n+  NodeId resolved_node = UNKNOWN_NODEID;\n+  bool found = resolver->get_macro_scope ().lookup (\n+    Resolver::CanonicalPath::new_seg (invoc.get_macro_node_id (),\n+\t\t\t\t      invoc_data.get_path ().as_string ()),\n+    &resolved_node);\n+  if (!found)\n+    {\n+      rust_error_at (invoc.get_locus (), \"unknown macro\");\n+      return;\n+    }\n+\n+  // lookup the rules\n+  AST::MacroRulesDefinition *rules_def = nullptr;\n+  bool ok = mappings->lookup_macro_def (resolved_node, &rules_def);\n+  rust_assert (ok);\n+\n+  auto fragment = AST::ASTFragment::create_empty ();\n+\n+  if (rules_def->is_builtin ())\n+    fragment\n+      = rules_def->get_builtin_transcriber () (invoc.get_locus (), invoc_data);\n+  else\n+    fragment\n+      = expand_decl_macro (invoc.get_locus (), invoc_data, *rules_def, true);\n+\n+  // lets attach this fragment to the invocation\n+  invoc.set_fragment (std::move (fragment));\n+}\n \n /* Determines whether any cfg predicate is false and hence item with attributes\n  * should be stripped. Note that attributes must be expanded before calling. */"}, {"sha": "da95408848b95678078cb71a3ba47aaffcb86c0b", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=58d1721529e99c7c633615e7491b777a6198ed00", "patch": "@@ -146,10 +146,11 @@ struct MacroExpander\n   // Expands all macros in the crate passed in.\n   void expand_crate ();\n \n-  /* Expands a macro invocation (not macro invocation semi) - possibly make both\n+  /* Expands a macro invocation - possibly make both\n    * have similar duck-typed interface and use templates?*/\n   // should this be public or private?\n   void expand_invoc (AST::MacroInvocation &invoc);\n+  void expand_invoc_semi (AST::MacroInvocation &invoc);\n \n   // Expands a single declarative macro.\n   AST::ASTFragment expand_decl_macro (Location locus,"}, {"sha": "3b901f600868e2ea813ff270dceb8e6680c3784d", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=58d1721529e99c7c633615e7491b777a6198ed00", "patch": "@@ -52,16 +52,18 @@ class ASTLowerImplItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n-  // void visit (AST::MacroInvocationSemi &invoc) override\n-  // {\n-  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n+  void visit (AST::MacroInvocation &invoc) override\n+  {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n \n-  //   // FIXME\n-  //   // this assertion might go away, maybe on failure's to expand a macro?\n-  //   rust_assert (!fragment.get_nodes ().empty ());\n-  //   fragment.get_nodes ().at (0).accept_vis (*this);\n-  // }\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n \n   void visit (AST::TypeAlias &alias) override\n   {\n@@ -319,16 +321,18 @@ class ASTLowerTraitItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n-  // void visit (AST::MacroInvocationSemi &invoc) override\n-  // {\n-  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n+  void visit (AST::MacroInvocation &invoc) override\n+  {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n \n-  //   // FIXME\n-  //   // this assertion might go away, maybe on failure's to expand a macro?\n-  //   rust_assert (!fragment.get_nodes ().empty ());\n-  //   fragment.get_nodes ().at (0).accept_vis (*this);\n-  // }\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n \n   void visit (AST::TraitItemFunc &func) override\n   {"}, {"sha": "660a30cb6190fca4f77c31594b7d2db9290b0078", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=58d1721529e99c7c633615e7491b777a6198ed00", "patch": "@@ -51,16 +51,18 @@ class ASTLoweringItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n-  // void visit (AST::MacroInvocationSemi &invoc) override\n-  // {\n-  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n-\n-  //   // FIXME\n-  //   // this assertion might go away, maybe on failure's to expand a macro?\n-  //   rust_assert (!fragment.get_nodes ().empty ());\n-  //   fragment.get_nodes ().at (0).accept_vis (*this);\n-  // }\n+  void visit (AST::MacroInvocation &invoc) override\n+  {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n \n   void visit (AST::Module &module) override\n   {"}, {"sha": "484c638c82ee9c3136b513852c0632a985232326", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=58d1721529e99c7c633615e7491b777a6198ed00", "patch": "@@ -45,16 +45,18 @@ class ASTLoweringStmt : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  // FIXME: ARTHUR: See if this implementation is necessary for MacroInvocation\n-  // void visit (AST::MacroInvocationSemi &invoc) override\n-  // {\n-  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n-\n-  //   // FIXME\n-  //   // this assertion might go away, maybe on failure's to expand a macro?\n-  //   rust_assert (!fragment.get_nodes ().empty ());\n-  //   fragment.get_nodes ().at (0).accept_vis (*this);\n-  // }\n+  void visit (AST::MacroInvocation &invoc) override\n+  {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+    // FIXME\n+    // this assertion might go away, maybe on failure's to expand a macro?\n+    rust_assert (!fragment.get_nodes ().empty ());\n+    fragment.get_nodes ().at (0).accept_vis (*this);\n+  }\n \n   void visit (AST::ExprStmtWithBlock &stmt) override\n   {"}, {"sha": "73933935e7504a8e9fd214afd330b1628f4552c2", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=58d1721529e99c7c633615e7491b777a6198ed00", "patch": "@@ -49,13 +49,15 @@ class ResolveToplevelImplItem : public ResolverBase\n     item->accept_vis (resolver);\n   }\n \n-  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n-  // void visit (AST::MacroInvocationSemi &invoc) override\n-  // {\n-  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n-  //   for (auto &node : fragment.get_nodes ())\n-  //     node.accept_vis (*this);\n-  // }\n+  void visit (AST::MacroInvocation &invoc) override\n+  {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n \n   void visit (AST::TypeAlias &type) override\n   {\n@@ -145,13 +147,15 @@ class ResolveTopLevelTraitItems : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n-  // void visit (AST::MacroInvocationSemi &invoc) override\n-  // {\n-  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n-  //   for (auto &node : fragment.get_nodes ())\n-  //     node.accept_vis (*this);\n-  // }\n+  void visit (AST::MacroInvocation &invoc) override\n+  {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n \n   void visit (AST::TraitItemFunc &function) override\n   {\n@@ -256,13 +260,15 @@ class ResolveToplevelExternItem : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n-  // void visit (AST::MacroInvocationSemi &invoc) override\n-  // {\n-  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n-  //   for (auto &node : fragment.get_nodes ())\n-  //     node.accept_vis (*this);\n-  // }\n+  void visit (AST::MacroInvocation &invoc) override\n+  {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n \n   void visit (AST::ExternalFunctionItem &function) override\n   {"}, {"sha": "2cb00065f0b1f296e17582533a696956194c62ad", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=58d1721529e99c7c633615e7491b777a6198ed00", "patch": "@@ -45,13 +45,15 @@ class ResolveTraitItems : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n-  // void visit (AST::MacroInvocationSemi &invoc) override\n-  // {\n-  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n-  //   for (auto &node : fragment.get_nodes ())\n-  //     node.accept_vis (*this);\n-  // }\n+  void visit (AST::MacroInvocation &invoc) override\n+  {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n \n   void visit (AST::TraitItemType &type) override\n   {\n@@ -235,13 +237,15 @@ class ResolveItem : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n-  // void visit (AST::MacroInvocationSemi &invoc) override\n-  // {\n-  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n-  //   for (auto &node : fragment.get_nodes ())\n-  //     node.accept_vis (*this);\n-  // }\n+  void visit (AST::MacroInvocation &invoc) override\n+  {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n \n   void visit (AST::TypeAlias &alias) override\n   {"}, {"sha": "785f3dea29229f243aff07b268c36ca64a174d6a", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=58d1721529e99c7c633615e7491b777a6198ed00", "patch": "@@ -44,14 +44,16 @@ class ResolveStmt : public ResolverBase\n     stmt->accept_vis (resolver);\n   };\n \n-  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n-  // void visit (AST::MacroInvocationSemi &invoc) override\n-  // {\n-  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n-\n-  //   for (auto &node : fragment.get_nodes ())\n-  //     node.accept_vis (*this);\n-  // }\n+  void visit (AST::MacroInvocation &invoc) override\n+  {\n+    if (!invoc.has_semicolon ())\n+      return;\n+\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n \n   void visit (AST::ExprStmtWithBlock &stmt) override\n   {"}, {"sha": "1f528fe9550929bde1245a04e3dab12a97f735a8", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58d1721529e99c7c633615e7491b777a6198ed00/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=58d1721529e99c7c633615e7491b777a6198ed00", "patch": "@@ -43,13 +43,12 @@ class ResolveTopLevel : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  // FIXME: ARTHUR: See if this is necessary for MacroInvocation\n-  // void visit (AST::MacroInvocationSemi &invoc) override\n-  // {\n-  //   AST::ASTFragment &fragment = invoc.get_fragment ();\n-  //   for (auto &node : fragment.get_nodes ())\n-  //     node.accept_vis (*this);\n-  // }\n+  void visit (AST::MacroInvocation &invoc) override\n+  {\n+    AST::ASTFragment &fragment = invoc.get_fragment ();\n+    for (auto &node : fragment.get_nodes ())\n+      node.accept_vis (*this);\n+  }\n \n   void visit (AST::Module &module) override\n   {"}]}