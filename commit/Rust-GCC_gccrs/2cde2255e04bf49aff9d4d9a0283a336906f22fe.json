{"sha": "2cde2255e04bf49aff9d4d9a0283a336906f22fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNkZTIyNTVlMDRiZjQ5YWZmOWQ0ZDlhMDI4M2EzMzY5MDZmMjJmZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-08-02T12:01:10Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-08-02T12:01:10Z"}, "message": "(expand_expr, case PLACEHOLDER_EXPR): Find innermost matching and\ndon't check contains_placeholder_p.\n\nFrom-SVN: r14605", "tree": {"sha": "9f5c9390485625e2058261714dca8ac762d401b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f5c9390485625e2058261714dca8ac762d401b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cde2255e04bf49aff9d4d9a0283a336906f22fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cde2255e04bf49aff9d4d9a0283a336906f22fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cde2255e04bf49aff9d4d9a0283a336906f22fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cde2255e04bf49aff9d4d9a0283a336906f22fe/comments", "author": null, "committer": null, "parents": [{"sha": "cc3c7c132926180feb7bec2abeaa63867040661a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc3c7c132926180feb7bec2abeaa63867040661a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc3c7c132926180feb7bec2abeaa63867040661a"}], "stats": {"total": 46, "additions": 19, "deletions": 27}, "files": [{"sha": "9f5ad573792c6ebc178fbbed3bccf8c4586d02d2", "filename": "gcc/expr.c", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cde2255e04bf49aff9d4d9a0283a336906f22fe/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cde2255e04bf49aff9d4d9a0283a336906f22fe/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2cde2255e04bf49aff9d4d9a0283a336906f22fe", "patch": "@@ -5023,36 +5023,28 @@ expand_expr (exp, target, tmode, modifier)\n \t  tree old_list = placeholder_list;\n \t  tree elt;\n \n-\t  /* See if the object is the type that we want and does not contain\n-\t     this PLACEHOLDER_EXPR itself.  Then see if the operand of any\n-\t     reference is the type we want.  */\n+\t  /* See if the object is the type that we want.  */\n \t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_PURPOSE (placeholder_list)))\n-\t       == need_type)\n-\t      && (! contains_this_placeholder_p\n-\t\t  (TREE_PURPOSE (placeholder_list), exp)))\n+\t       == need_type))\n \t    object = TREE_PURPOSE (placeholder_list);\n \n-\t  else\n-\t    /* Find the outermost reference that is of the type we want and\n-\t       that does not itself contain this PLACEHOLDER_EXPR.  */\n-\t    for (elt = TREE_PURPOSE (placeholder_list);\n-\t\t elt != 0\n-\t\t && (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e');\n-\t\t elt = ((TREE_CODE (elt) == COMPOUND_EXPR\n-\t\t\t || TREE_CODE (elt) == COND_EXPR)\n-\t\t\t? TREE_OPERAND (elt, 1) : TREE_OPERAND (elt, 0)))\n-\t      if (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n-\t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (elt, 0)))\n-\t\t      == need_type)\n-\t\t  && ! contains_this_placeholder_p (TREE_OPERAND (elt, 0),\n-\t\t\t\t\t\t    exp))\n-\t\t{\n-\t\t  object = TREE_OPERAND (elt, 0);\n-\t\t  break;\n-\t\t}\n+\t  /* Find the innermost reference that is of the type we want.  */\n+\t  for (elt = TREE_PURPOSE (placeholder_list);\n+\t       elt != 0\n+\t       && (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n+\t\t   || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n+\t\t   || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n+\t\t   || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e');\n+\t       elt = ((TREE_CODE (elt) == COMPOUND_EXPR\n+\t\t       || TREE_CODE (elt) == COND_EXPR)\n+\t\t      ? TREE_OPERAND (elt, 1) : TREE_OPERAND (elt, 0)))\n+\t    if (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n+\t\t&& (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (elt, 0)))\n+\t\t    == need_type))\n+\t      {\n+\t\tobject = TREE_OPERAND (elt, 0);\n+\t\tbreak;\n+\t      }\n \n \t  if (object != 0)\n \t    {"}]}