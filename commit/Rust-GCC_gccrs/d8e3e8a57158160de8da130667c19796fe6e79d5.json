{"sha": "d8e3e8a57158160de8da130667c19796fe6e79d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhlM2U4YTU3MTU4MTYwZGU4ZGExMzA2NjdjMTk3OTZmZTZlNzlkNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-12-03T04:21:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-12-03T04:21:50Z"}, "message": "ipa-pure-const.c (ignore_edge_for_pure_const): New function.\n\n\t* ipa-pure-const.c (ignore_edge_for_pure_const): New function.\n\t(propagate_pure_const): Use it; fix comments and optimize loops.\n\nFrom-SVN: r231219", "tree": {"sha": "14b99dc78c37ecb7da84bf142c792eb85acbb9cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14b99dc78c37ecb7da84bf142c792eb85acbb9cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8e3e8a57158160de8da130667c19796fe6e79d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8e3e8a57158160de8da130667c19796fe6e79d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8e3e8a57158160de8da130667c19796fe6e79d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8e3e8a57158160de8da130667c19796fe6e79d5/comments", "author": null, "committer": null, "parents": [{"sha": "9644e52a6b3ebdcfd1158532f82843d55ec6365d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9644e52a6b3ebdcfd1158532f82843d55ec6365d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9644e52a6b3ebdcfd1158532f82843d55ec6365d"}], "stats": {"total": 39, "additions": 28, "deletions": 11}, "files": [{"sha": "ae92402d7e2a16145a9faae1efaaa3dcdfa2b1dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e3e8a57158160de8da130667c19796fe6e79d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e3e8a57158160de8da130667c19796fe6e79d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8e3e8a57158160de8da130667c19796fe6e79d5", "patch": "@@ -1,3 +1,8 @@\n+2015-12-02  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-pure-const.c (ignore_edge_for_pure_const): New function.\n+\t(propagate_pure_const): Use it; fix comments and optimize loops.\n+\n 2015-12-02  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-pure-const.c (ignore_edge): Rename to ..."}, {"sha": "4cf09183f3a23b570bbee777b24f8c32afb54a1f", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e3e8a57158160de8da130667c19796fe6e79d5/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e3e8a57158160de8da130667c19796fe6e79d5/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=d8e3e8a57158160de8da130667c19796fe6e79d5", "patch": "@@ -1164,6 +1164,17 @@ cdtor_p (cgraph_node *n, void *)\n   return false;\n }\n \n+/* We only propagate across edges with non-interposable callee.  */\n+\n+static bool\n+ignore_edge_for_pure_const (struct cgraph_edge *e)\n+{\n+  enum availability avail;\n+  e->callee->function_or_virtual_thunk_symbol (&avail);\n+  return (avail <= AVAIL_INTERPOSABLE);\n+}\n+\n+\n /* Produce transitive closure over the callgraph and compute pure/const\n    attributes.  */\n \n@@ -1179,7 +1190,8 @@ propagate_pure_const (void)\n   struct ipa_dfs_info * w_info;\n   bool remove_p = false;\n \n-  order_pos = ipa_reduced_postorder (order, true, false, NULL);\n+  order_pos = ipa_reduced_postorder (order, true, false,\n+\t\t\t\t     ignore_edge_for_pure_const);\n   if (dump_file)\n     {\n       cgraph_node::dump_cgraph (dump_file);\n@@ -1226,7 +1238,7 @@ propagate_pure_const (void)\n \t  if (pure_const_state == IPA_NEITHER)\n \t    break;\n \n-\t  /* For overwritable nodes we can not assume anything.  */\n+\t  /* For interposable nodes we can not assume anything.  */\n \t  if (w->get_availability () == AVAIL_INTERPOSABLE)\n \t    {\n \t      worse_state (&pure_const_state, &looping,\n@@ -1235,7 +1247,7 @@ propagate_pure_const (void)\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n \t\t  fprintf (dump_file,\n-\t\t\t   \"    Overwritable. state %s looping %i\\n\",\n+\t\t\t   \"    Interposable. state %s looping %i\\n\",\n \t\t\t   pure_const_names[w_l->state_previously_known],\n \t\t\t   w_l->looping_previously_known);\n \t\t}\n@@ -1251,7 +1263,8 @@ propagate_pure_const (void)\n \t    looping = true;\n \n \t  /* Now walk the edges and merge in callee properties.  */\n-\t  for (e = w->callees; e; e = e->next_callee)\n+\t  for (e = w->callees; e && pure_const_state != IPA_NEITHER;\n+\t       e = e->next_callee)\n \t    {\n \t      enum availability avail;\n \t      struct cgraph_node *y = e->callee->\n@@ -1309,11 +1322,10 @@ propagate_pure_const (void)\n \t      if (pure_const_state == IPA_NEITHER)\n \t        break;\n \t    }\n-\t  if (pure_const_state == IPA_NEITHER)\n-\t    break;\n \n \t  /* Now process the indirect call.  */\n-          for (ie = w->indirect_calls; ie; ie = ie->next_callee)\n+          for (ie = w->indirect_calls;\n+\t       ie && pure_const_state != IPA_NEITHER; ie = ie->next_callee)\n \t    {\n \t      enum pure_const_state_e edge_state = IPA_CONST;\n \t      bool edge_looping = false;\n@@ -1332,11 +1344,10 @@ propagate_pure_const (void)\n \t      if (pure_const_state == IPA_NEITHER)\n \t        break;\n \t    }\n-\t  if (pure_const_state == IPA_NEITHER)\n-\t    break;\n \n \t  /* And finally all loads and stores.  */\n-\t  for (i = 0; w->iterate_reference (i, ref); i++)\n+\t  for (i = 0; w->iterate_reference (i, ref)\n+\t       && pure_const_state != IPA_NEITHER; i++)\n \t    {\n \t      enum pure_const_state_e ref_state = IPA_CONST;\n \t      bool ref_looping = false;\n@@ -1426,7 +1437,8 @@ propagate_pure_const (void)\n \t      && this_state > w_l->state_previously_known)\n \t    {\n               this_state = w_l->state_previously_known;\n-\t      this_looping |= w_l->looping_previously_known;\n+\t      if (this_state == IPA_NEITHER)\n+\t        this_looping = w_l->looping_previously_known;\n \t    }\n \t  if (!this_looping && self_recursive_p (w))\n \t    this_looping = true;"}]}