{"sha": "4581c6785660dd5d9fef416d15c9ad39051951d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU4MWM2Nzg1NjYwZGQ1ZDlmZWY0MTZkMTVjOWFkMzkwNTE5NTFkOQ==", "commit": {"author": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-13T16:23:35Z"}, "committer": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-13T16:23:35Z"}, "message": "* c-typeck.c: Remove #if 0 clauses.\n\nFrom-SVN: r67905", "tree": {"sha": "060b91d3d5b87cc85cfaa92e43a7eee723b2cb88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/060b91d3d5b87cc85cfaa92e43a7eee723b2cb88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4581c6785660dd5d9fef416d15c9ad39051951d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4581c6785660dd5d9fef416d15c9ad39051951d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4581c6785660dd5d9fef416d15c9ad39051951d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4581c6785660dd5d9fef416d15c9ad39051951d9/comments", "author": null, "committer": null, "parents": [{"sha": "9e7d1164368531bd7747f4f6f93d3c90b6018354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7d1164368531bd7747f4f6f93d3c90b6018354", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e7d1164368531bd7747f4f6f93d3c90b6018354"}], "stats": {"total": 130, "additions": 2, "deletions": 128}, "files": [{"sha": "8327e0f26ffae18f97673d475584ba889cf3d9d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4581c6785660dd5d9fef416d15c9ad39051951d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4581c6785660dd5d9fef416d15c9ad39051951d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4581c6785660dd5d9fef416d15c9ad39051951d9", "patch": "@@ -1,5 +1,7 @@\n 2003-06-13  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n+\t* c-typeck.c: Remove #if 0 clauses.\n+\n \tPR other/1494\n \t* config/alpha/openbsd.h, config/i386/openbsd.h,\n \tconfig/m68k/openbsd.h, config/sparc/openbsd.h: Remove"}, {"sha": "8d6ed0be9fddca702900bb0ae3b7f31ef28df5ef", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4581c6785660dd5d9fef416d15c9ad39051951d9/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4581c6785660dd5d9fef416d15c9ad39051951d9/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=4581c6785660dd5d9fef416d15c9ad39051951d9", "patch": "@@ -334,10 +334,6 @@ common_type (t1, t2)\n \t\t\t\t  TYPE_QUALS (pointed_to_2)));\n \treturn build_type_attribute_variant (t1, attributes);\n       }\n-#if 0\n-      t1 = build_pointer_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));\n-      return build_type_attribute_variant (t1, attributes);\n-#endif\n \n     case ARRAY_TYPE:\n       {\n@@ -1714,14 +1710,6 @@ convert_arguments (typelist, values, name, fundecl)\n \t\t\t       && TREE_CODE (TREE_OPERAND (val, 0)) == INTEGER_CST\n \t\t\t       && int_fits_type_p (TREE_OPERAND (val, 0), type))\n \t\t\t;\n-#if 0 /* We never get such tree structure here.  */\n-\t\t      else if (TREE_CODE (TREE_TYPE (val)) == ENUMERAL_TYPE\n-\t\t\t       && int_fits_type_p (TYPE_MIN_VALUE (TREE_TYPE (val)), type)\n-\t\t\t       && int_fits_type_p (TYPE_MAX_VALUE (TREE_TYPE (val)), type))\n-\t\t\t/* Change in signedness doesn't matter\n-\t\t\t   if an enum value is unaffected.  */\n-\t\t\t;\n-#endif\n \t\t      /* If the value is extended from a narrower\n \t\t\t unsigned type, it doesn't matter whether we\n \t\t\t pass it as signed or unsigned; the value\n@@ -3028,28 +3016,6 @@ build_unary_op (code, xarg, flag)\n       if (val != 0)\n \treturn val;\n \n-#if 0 /* Turned off because inconsistent;\n-\t float f; *&(int)f = 3.4 stores in int format\n-\t whereas (int)f = 3.4 stores in float format.  */\n-      /* Address of a cast is just a cast of the address\n-\t of the operand of the cast.  */\n-      switch (TREE_CODE (arg))\n-\t{\n-\tcase NOP_EXPR:\n-\tcase CONVERT_EXPR:\n-\tcase FLOAT_EXPR:\n-\tcase FIX_TRUNC_EXPR:\n-\tcase FIX_FLOOR_EXPR:\n-\tcase FIX_ROUND_EXPR:\n-\tcase FIX_CEIL_EXPR:\n-\t  if (pedantic)\n-\t    pedwarn (\"ISO C forbids the address of a cast expression\");\n-\t  return convert (build_pointer_type (TREE_TYPE (arg)),\n-\t\t\t  build_unary_op (ADDR_EXPR, TREE_OPERAND (arg, 0),\n-\t\t\t\t\t  0));\n-\t}\n-#endif\n-\n       /* Anything not already handled and not a true memory reference\n \t or a non-lvalue array is an error.  */\n       else if (typecode != FUNCTION_TYPE && !flag\n@@ -3115,35 +3081,6 @@ build_unary_op (code, xarg, flag)\n   return fold (build1 (code, argtype, arg));\n }\n \n-#if 0\n-/* If CONVERSIONS is a conversion expression or a nested sequence of such,\n-   convert ARG with the same conversions in the same order\n-   and return the result.  */\n-\n-static tree\n-convert_sequence (conversions, arg)\n-     tree conversions;\n-     tree arg;\n-{\n-  switch (TREE_CODE (conversions))\n-    {\n-    case NOP_EXPR:\n-    case CONVERT_EXPR:\n-    case FLOAT_EXPR:\n-    case FIX_TRUNC_EXPR:\n-    case FIX_FLOOR_EXPR:\n-    case FIX_ROUND_EXPR:\n-    case FIX_CEIL_EXPR:\n-      return convert (TREE_TYPE (conversions),\n-\t\t      convert_sequence (TREE_OPERAND (conversions, 0),\n-\t\t\t\t\targ));\n-\n-    default:\n-      return arg;\n-    }\n-}\n-#endif /* 0 */\n-\n /* Return nonzero if REF is an lvalue valid for this language.\n    Lvalues can be assigned, unless their type has TYPE_READONLY.\n    Lvalues can have their address taken, unless they have DECL_REGISTER.  */\n@@ -3367,11 +3304,6 @@ c_mark_addressable (exp)\n \t/* drops in */\n       case FUNCTION_DECL:\n \tTREE_ADDRESSABLE (x) = 1;\n-#if 0  /* poplevel deals with this now.  */\n-\tif (DECL_CONTEXT (x) == 0)\n-\t  TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (x)) = 1;\n-#endif\n-\n       default:\n \treturn true;\n     }\n@@ -3392,23 +3324,6 @@ build_conditional_expr (ifexp, op1, op2)\n \n   ifexp = c_common_truthvalue_conversion (default_conversion (ifexp));\n \n-#if 0 /* Produces wrong result if within sizeof.  */\n-  /* Don't promote the operands separately if they promote\n-     the same way.  Return the unpromoted type and let the combined\n-     value get promoted if necessary.  */\n-\n-  if (TREE_TYPE (op1) == TREE_TYPE (op2)\n-      && TREE_CODE (TREE_TYPE (op1)) != ARRAY_TYPE\n-      && TREE_CODE (TREE_TYPE (op1)) != ENUMERAL_TYPE\n-      && TREE_CODE (TREE_TYPE (op1)) != FUNCTION_TYPE)\n-    {\n-      if (TREE_CODE (ifexp) == INTEGER_CST)\n-\treturn pedantic_non_lvalue (integer_zerop (ifexp) ? op2 : op1);\n-\n-      return fold (build (COND_EXPR, TREE_TYPE (op1), ifexp, op1, op2));\n-    }\n-#endif\n-\n   /* Promote both alternatives.  */\n \n   if (TREE_CODE (TREE_TYPE (op1)) != VOID_TYPE)\n@@ -3580,14 +3495,6 @@ internal_build_compound_expr (list, first_p)\n \tTREE_VALUE (list)\n \t  = default_function_array_conversion (TREE_VALUE (list));\n \n-#if 0 /* If something inside inhibited lvalueness, we should not override.  */\n-      /* Consider (x, y+0), which is not an lvalue since y+0 is not.  */\n-\n-      /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n-      if (TREE_CODE (list) == NON_LVALUE_EXPR)\n-\tlist = TREE_OPERAND (list, 0);\n-#endif\n-\n       /* Don't let (0, 0) be null pointer constant.  */\n       if (!first_p && integer_zerop (TREE_VALUE (list)))\n \treturn non_lvalue (TREE_VALUE (list));\n@@ -3640,12 +3547,6 @@ build_c_cast (type, expr)\n   if (!flag_objc || !objc_is_id (type))\n     type = TYPE_MAIN_VARIANT (type);\n \n-#if 0\n-  /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n-  if (TREE_CODE (value) == NON_LVALUE_EXPR)\n-    value = TREE_OPERAND (value, 0);\n-#endif\n-\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       error (\"cast specifies array type\");\n@@ -4460,35 +4361,6 @@ store_init_value (decl, init)\n \n   /* Store the expression if valid; else report error.  */\n \n-#if 0\n-  /* Note that this is the only place we can detect the error\n-     in a case such as   struct foo bar = (struct foo) { x, y };\n-     where there is one initial value which is a constructor expression.  */\n-  if (value == error_mark_node)\n-    ;\n-  else if (TREE_STATIC (decl) && ! TREE_CONSTANT (value))\n-    {\n-      error (\"initializer for static variable is not constant\");\n-      value = error_mark_node;\n-    }\n-  else if (TREE_STATIC (decl)\n-\t   && initializer_constant_valid_p (value, TREE_TYPE (value)) == 0)\n-    {\n-      error (\"initializer for static variable uses complicated arithmetic\");\n-      value = error_mark_node;\n-    }\n-  else\n-    {\n-      if (pedantic && TREE_CODE (value) == CONSTRUCTOR)\n-\t{\n-\t  if (! TREE_CONSTANT (value))\n-\t    pedwarn (\"aggregate initializer is not constant\");\n-\t  else if (! TREE_STATIC (value))\n-\t    pedwarn (\"aggregate initializer uses complicated arithmetic\");\n-\t}\n-    }\n-#endif\n-\n   if (warn_traditional && !in_system_header\n       && AGGREGATE_TYPE_P (TREE_TYPE (decl)) && ! TREE_STATIC (decl))\n     warning (\"traditional C rejects automatic aggregate initialization\");"}]}