{"sha": "d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk0MmJjODBlNGU5OWYyNmRmMzliOGMwM2U4ZmIwM2U3YzdlOTFiYw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-01-08T23:00:46Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-01-08T23:00:46Z"}, "message": "PR libstdc++/87855 fix optional for types with non-trivial copy/move\n\nWhen the contained value is not trivially copy (or move) constructible\nthe union's copy (or move) constructor will be deleted, and so the\n_Optional_payload delegating constructors are invalid. G++ fails to\ndiagnose this because it incorrectly performs copy elision in the\ndelegating constructors. Clang does diagnose it (llvm.org/PR40245).\n\nThe solution is to avoid performing any copy (or move) when the\ncontained value's copy (or move) constructor isn't trivial. Instead the\ncontained value can be constructed by calling _M_construct. This is OK,\nbecause the relevant constructor doesn't need to be constexpr when the\ncontained value isn't trivially copy (or move) constructible.\n\nAdditionally, this patch removes a lot of code duplication in the\n_Optional_payload partial specializations and the _Optional_base partial\nspecialization, by hoisting it into common base classes.\n\nThe Python pretty printer for std::optional needs to be adjusted to\nsupport the new layout. Retain support for the old layout, and add a\ntest to verify that the support still works.\n\n\tPR libstdc++/87855\n\t* include/std/optional (_Optional_payload_base): New class template\n\tfor common code hoisted from _Optional_payload specializations. Use\n\ta template for the union, to allow a partial specialization for\n\ttypes with non-trivial destructors. Add constructors for in-place\n\tinitialization to the union.\n\t(_Optional_payload(bool, const _Optional_payload&)): Use _M_construct\n\tto perform non-trivial copy construction, instead of relying on\n\tnon-standard copy elision in a delegating constructor.\n\t(_Optional_payload(bool, _Optional_payload&&)): Likewise for\n\tnon-trivial move construction.\n\t(_Optional_payload): Derive from _Optional_payload_base and use it\n\tfor everything except the non-trivial assignment operators, which are\n\tdefined as needed.\n\t(_Optional_payload<false, C, M>): Derive from the specialization\n\t_Optional_payload<true, false, false> and add a destructor.\n\t(_Optional_base_impl::_M_destruct, _Optional_base_impl::_M_reset):\n\tForward to corresponding members of _Optional_payload.\n\t(_Optional_base_impl::_M_is_engaged, _Optional_base_impl::_M_get):\n\tHoist common members from _Optional_base.\n\t(_Optional_base): Make all members and base class public.\n\t(_Optional_base::_M_get, _Optional_base::_M_is_engaged): Move to\n\t_Optional_base_impl.\n\t* python/libstdcxx/v6/printers.py (StdExpOptionalPrinter): Add\n\tsupport for new std::optional layout.\n\t* testsuite/libstdc++-prettyprinters/compat.cc: New test.\n\nFrom-SVN: r267742", "tree": {"sha": "28a825d5a7060ea68ea6f9b6395a49431ac69e20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28a825d5a7060ea68ea6f9b6395a49431ac69e20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96e768c3fecf0f65af3f289293145d5740971e2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e768c3fecf0f65af3f289293145d5740971e2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96e768c3fecf0f65af3f289293145d5740971e2a"}], "stats": {"total": 881, "additions": 323, "deletions": 558}, "files": [{"sha": "bb8f8742e570c840b3e7717b8989cd5bdaec3a7d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc", "patch": "@@ -1,5 +1,32 @@\n 2019-01-08  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/87855\n+\t* include/std/optional (_Optional_payload_base): New class template\n+\tfor common code hoisted from _Optional_payload specializations. Use\n+\ta template for the union, to allow a partial specialization for\n+\ttypes with non-trivial destructors. Add constructors for in-place\n+\tinitialization to the union.\n+\t(_Optional_payload(bool, const _Optional_payload&)): Use _M_construct\n+\tto perform non-trivial copy construction, instead of relying on\n+\tnon-standard copy elision in a delegating constructor.\n+\t(_Optional_payload(bool, _Optional_payload&&)): Likewise for\n+\tnon-trivial move construction.\n+\t(_Optional_payload): Derive from _Optional_payload_base and use it\n+\tfor everything except the non-trivial assignment operators, which are\n+\tdefined as needed.\n+\t(_Optional_payload<false, C, M>): Derive from the specialization\n+\t_Optional_payload<true, false, false> and add a destructor.\n+\t(_Optional_base_impl::_M_destruct, _Optional_base_impl::_M_reset):\n+\tForward to corresponding members of _Optional_payload.\n+\t(_Optional_base_impl::_M_is_engaged, _Optional_base_impl::_M_get):\n+\tHoist common members from _Optional_base.\n+\t(_Optional_base): Make all members and base class public.\n+\t(_Optional_base::_M_get, _Optional_base::_M_is_engaged): Move to\n+\t_Optional_base_impl.\n+\t* python/libstdcxx/v6/printers.py (StdExpOptionalPrinter): Add\n+\tsupport for new std::optional layout.\n+\t* testsuite/libstdc++-prettyprinters/compat.cc: New test.\n+\n \tPR libstdc++/88066\n \t* include/bits/locale_conv.h: Use <> for includes not \"\".\n \t* include/ext/random: Likewise."}, {"sha": "b06e30fbd6721aab2cfd6f7bddb358f05232cda2", "filename": "libstdc++-v3/include/std/optional", "status": "modified", "additions": 203, "deletions": 551, "changes": 754, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional?ref=d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc", "patch": "@@ -98,107 +98,115 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   __throw_bad_optional_access()\n   { _GLIBCXX_THROW_OR_ABORT(bad_optional_access()); }\n \n-\n-  // Payload for optionals with non-trivial destructor.\n-  template <typename _Tp,\n-\t    bool /*_HasTrivialDestructor*/ =\n-\t      is_trivially_destructible_v<_Tp>,\n-\t    bool /*_HasTrivialCopy */ =\n-\t      is_trivially_copy_assignable_v<_Tp>\n-\t      && is_trivially_copy_constructible_v<_Tp>,\n-\t    bool /*_HasTrivialMove */ =\n-\t      is_trivially_move_assignable_v<_Tp>\n-\t      && is_trivially_move_constructible_v<_Tp>>\n-    struct _Optional_payload\n+  // This class template manages construction/destruction of\n+  // the contained value for a std::optional.\n+  template <typename _Tp>\n+    struct _Optional_payload_base\n     {\n-      constexpr _Optional_payload() noexcept : _M_empty() { }\n+      using _Stored_type = remove_const_t<_Tp>;\n+\n+      _Optional_payload_base() = default;\n+      ~_Optional_payload_base() = default;\n \n-      template <typename... _Args>\n+      template<typename... _Args>\n \tconstexpr\n-\t_Optional_payload(in_place_t, _Args&&... __args)\n-\t: _M_payload(std::forward<_Args>(__args)...), _M_engaged(true) { }\n+\t_Optional_payload_base(in_place_t __tag, _Args&&... __args)\n+\t: _M_payload(__tag, std::forward<_Args>(__args)...),\n+\t  _M_engaged(true)\n+\t{ }\n \n       template<typename _Up, typename... _Args>\n \tconstexpr\n-\t_Optional_payload(std::initializer_list<_Up> __il,\n-\t\t\t  _Args&&... __args)\n+\t_Optional_payload_base(std::initializer_list<_Up> __il,\n+\t\t\t       _Args&&... __args)\n \t: _M_payload(__il, std::forward<_Args>(__args)...),\n \t  _M_engaged(true)\n \t{ }\n \n+      // Constructor used by _Optional_base copy constructor when the\n+      // contained value is not trivially copy constructible.\n       constexpr\n-      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n-      : _Optional_payload(__other)\n-      { }\n-\n-      constexpr\n-      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n-      : _Optional_payload(std::move(__other))\n-      { }\n-\n-      constexpr\n-      _Optional_payload(const _Optional_payload& __other)\n+      _Optional_payload_base(bool __engaged,\n+\t\t\t     const _Optional_payload_base& __other)\n       {\n \tif (__other._M_engaged)\n-\t  this->_M_construct(__other._M_payload);\n+\t  this->_M_construct(__other._M_get());\n       }\n \n+      // Constructor used by _Optional_base move constructor when the\n+      // contained value is not trivially move constructible.\n       constexpr\n-      _Optional_payload(_Optional_payload&& __other)\n+      _Optional_payload_base(bool __engaged,\n+\t\t\t     _Optional_payload_base&& __other)\n       {\n \tif (__other._M_engaged)\n-\t  this->_M_construct(std::move(__other._M_payload));\n+\t  this->_M_construct(std::move(__other._M_get()));\n       }\n \n-      constexpr\n-      _Optional_payload&\n-      operator=(const _Optional_payload& __other)\n-      {\n-        if (this->_M_engaged && __other._M_engaged)\n-          this->_M_get() = __other._M_get();\n-        else\n-\t  {\n-\t    if (__other._M_engaged)\n-\t      this->_M_construct(__other._M_get());\n-\t    else\n-\t      this->_M_reset();\n-\t  }\n-\treturn *this;\n-      }\n+      // Copy constructor is only used to when the contained value is\n+      // trivially copy constructible.\n+      _Optional_payload_base(const _Optional_payload_base&) = default;\n \n-      constexpr\n-      _Optional_payload&\n-      operator=(_Optional_payload&& __other)\n-      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,\n-\t\t       is_nothrow_move_assignable<_Tp>>)\n-      {\n-\tif (this->_M_engaged && __other._M_engaged)\n-\t  this->_M_get() = std::move(__other._M_get());\n-\telse\n-\t  {\n-\t    if (__other._M_engaged)\n-\t      this->_M_construct(std::move(__other._M_get()));\n-\t    else\n-\t      this->_M_reset();\n-\t  }\n-\treturn *this;\n-      }\n+      // Move constructor is only used to when the contained value is\n+      // trivially copy constructible.\n+      _Optional_payload_base(_Optional_payload_base&&) = default;\n \n-      using _Stored_type = remove_const_t<_Tp>;\n+      _Optional_payload_base&\n+      operator=(const _Optional_payload_base&) = default;\n+\n+      _Optional_payload_base&\n+      operator=(_Optional_payload_base&&) = default;\n \n       struct _Empty_byte { };\n \n-      union {\n-          _Empty_byte _M_empty;\n-          _Stored_type _M_payload;\n-      };\n-      bool _M_engaged = false;\n+      template<typename _Up, bool = is_trivially_destructible_v<_Up>>\n+\tunion _Storage\n+\t{\n+\t  constexpr _Storage() noexcept : _M_empty() { }\n \n-      ~_Optional_payload()\n-      {\n-        if (_M_engaged)\n-          _M_payload.~_Stored_type();\n-      }\n+\t  template<typename... _Args>\n+\t    constexpr\n+\t    _Storage(in_place_t, _Args&&... __args)\n+\t    : _M_value(std::forward<_Args>(__args)...)\n+\t    { }\n+\n+\t  template<typename _Vp, typename... _Args>\n+\t    constexpr\n+\t    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)\n+\t    : _M_value(__il, std::forward<_Args>(__args)...)\n+\t    { }\n+\n+\t  _Empty_byte _M_empty;\n+          _Up _M_value;\n+\t};\n+\n+      template<typename _Up>\n+\tunion _Storage<_Up, false>\n+\t{\n+\t  constexpr _Storage() noexcept : _M_empty() { }\n+\n+\t  template<typename... _Args>\n+\t    constexpr\n+\t    _Storage(in_place_t, _Args&&... __args)\n+\t    : _M_value(std::forward<_Args>(__args)...)\n+\t    { }\n+\n+\t  template<typename _Vp, typename... _Args>\n+\t    constexpr\n+\t    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)\n+\t    : _M_value(__il, std::forward<_Args>(__args)...)\n+\t    { }\n+\n+\t  // User-provided destructor is needed when _Up has non-trivial dtor.\n+\t  ~_Storage() { }\n+\n+\t  _Empty_byte _M_empty;\n+          _Up _M_value;\n+\t};\n+\n+      _Storage<_Stored_type> _M_payload;\n+\n+      bool _M_engaged = false;\n \n       template<typename... _Args>\n         void\n@@ -210,147 +218,70 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n           this->_M_engaged = true;\n         }\n \n-      // The _M_get operations have _M_engaged as a precondition.\n+      constexpr void\n+      _M_destroy() noexcept\n+      {\n+\t_M_engaged = false;\n+\t_M_payload._M_value.~_Stored_type();\n+      }\n+\n+      // The _M_get() operations have _M_engaged as a precondition.\n+      // They exist to access the contained value with the appropriate\n+      // const-qualification, because _M_payload has had the const removed.\n+\n       constexpr _Tp&\n       _M_get() noexcept\n-      { return this->_M_payload; }\n+      { return this->_M_payload._M_value; }\n \n       constexpr const _Tp&\n       _M_get() const noexcept\n-      { return this->_M_payload; }\n+      { return this->_M_payload._M_value; }\n \n       // _M_reset is a 'safe' operation with no precondition.\n-      constexpr\n-      void\n+      constexpr void\n       _M_reset() noexcept\n       {\n \tif (this->_M_engaged)\n-\t  {\n-\t    this->_M_engaged = false;\n-\t    this->_M_payload.~_Stored_type();\n-\t  }\n+\t  _M_destroy();\n       }\n     };\n \n-  // Payload for potentially-constexpr optionals.\n+  // Class template that manages the payload for optionals.\n+  template <typename _Tp,\n+\t    bool /*_HasTrivialDestructor*/ =\n+\t      is_trivially_destructible_v<_Tp>,\n+\t    bool /*_HasTrivialCopy */ =\n+\t      is_trivially_copy_assignable_v<_Tp>\n+\t      && is_trivially_copy_constructible_v<_Tp>,\n+\t    bool /*_HasTrivialMove */ =\n+\t      is_trivially_move_assignable_v<_Tp>\n+\t      && is_trivially_move_constructible_v<_Tp>>\n+    struct _Optional_payload;\n+\n+  // Payload for potentially-constexpr optionals (trivial copy/move/destroy).\n   template <typename _Tp>\n     struct _Optional_payload<_Tp, true, true, true>\n+    : _Optional_payload_base<_Tp>\n     {\n-      constexpr _Optional_payload() noexcept\n-      : _M_empty(), _M_engaged(false) { }\n+      using _Optional_payload_base<_Tp>::_Optional_payload_base;\n \n-      template<typename... _Args>\n-\tconstexpr\n-\t_Optional_payload(in_place_t, _Args&&... __args)\n-\t: _M_payload(std::forward<_Args>(__args)...), _M_engaged(true)\n-\t{ }\n-\n-      template<typename _Up, typename... _Args>\n-\tconstexpr\n-\t_Optional_payload(std::initializer_list<_Up> __il,\n-\t\t\t  _Args&&... __args)\n-\t: _M_payload(__il, std::forward<_Args>(__args)...),\n-\t  _M_engaged(true)\n-\t{ }\n-\n-      template <class _Up> struct __ctor_tag {};\n-\n-      constexpr\n-      _Optional_payload(__ctor_tag<bool>, const _Tp& __other)\n-      : _M_payload(__other), _M_engaged(true)\n-      { }\n-\n-      constexpr _Optional_payload(__ctor_tag<void>) noexcept\n-      : _M_empty(), _M_engaged(false)\n-      { }\n-\n-      constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)\n-      : _M_payload(std::move(__other)), _M_engaged(true)\n-      { }\n-\n-      constexpr\n-      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n-      : _Optional_payload(__engaged ?\n-\t\t\t  _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t    __other._M_payload) :\n-\t\t\t  _Optional_payload(__ctor_tag<void>{}))\n-      { }\n-\n-      constexpr\n-      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n-      : _Optional_payload(__engaged\n-\t\t\t  ? _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t      std::move(__other._M_payload))\n-\t\t\t  : _Optional_payload(__ctor_tag<void>{}))\n-      { }\n-\n-      using _Stored_type = remove_const_t<_Tp>;\n-\n-      struct _Empty_byte { };\n-\n-      union {\n-\t  _Empty_byte _M_empty;\n-          _Stored_type _M_payload;\n-      };\n-      bool _M_engaged;\n+      _Optional_payload() = default;\n     };\n \n-  // Payload for optionals with non-trivial copy assignment.\n+  // Payload for optionals with non-trivial copy construction/assignment.\n   template <typename _Tp>\n     struct _Optional_payload<_Tp, true, false, true>\n+    : _Optional_payload_base<_Tp>\n     {\n-      constexpr _Optional_payload() noexcept\n-      : _M_empty(), _M_engaged(false) { }\n-\n-      template<typename... _Args>\n-\tconstexpr\n-\t_Optional_payload(in_place_t, _Args&&... __args)\n-\t: _M_payload(std::forward<_Args>(__args)...), _M_engaged(true)\n-\t{ }\n-\n-      template<typename _Up, typename... _Args>\n-\tconstexpr\n-\t_Optional_payload(std::initializer_list<_Up> __il,\n-\t\t\t  _Args&&... __args)\n-\t: _M_payload(__il, std::forward<_Args>(__args)...),\n-\t  _M_engaged(true)\n-\t{ }\n-\n-      template <class _Up> struct __ctor_tag {};\n-\n-      constexpr _Optional_payload(__ctor_tag<bool>, const _Tp& __other)\n-      : _M_payload(__other),\n-\t_M_engaged(true)\n-      { }\n-\n-      constexpr _Optional_payload(__ctor_tag<void>) noexcept\n-      : _M_empty(), _M_engaged(false)\n-      { }\n-\n-      constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)\n-      : _M_payload(std::move(__other)),\n-\t_M_engaged(true)\n-      { }\n-\n-      constexpr\n-      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n-      : _Optional_payload(__engaged ?\n-\t\t\t  _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t    __other._M_payload) :\n-\t\t\t  _Optional_payload(__ctor_tag<void>{}))\n-      { }\n-\n-      constexpr\n-      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n-      : _Optional_payload(__engaged\n-\t\t\t  ? _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t      std::move(__other._M_payload))\n-\t\t\t  : _Optional_payload(__ctor_tag<void>{}))\n-      { }\n+      using _Optional_payload_base<_Tp>::_Optional_payload_base;\n \n+      _Optional_payload() = default;\n+      ~_Optional_payload() = default;\n       _Optional_payload(const _Optional_payload&) = default;\n       _Optional_payload(_Optional_payload&&) = default;\n+      _Optional_payload& operator=(_Optional_payload&&) = default;\n \n+      // Non-trivial copy assignment.\n       constexpr\n       _Optional_payload&\n       operator=(const _Optional_payload& __other)\n@@ -366,113 +297,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n \treturn *this;\n       }\n-\n-      _Optional_payload&\n-      operator=(_Optional_payload&& __other) = default;\n-\n-      using _Stored_type = remove_const_t<_Tp>;\n-\n-      struct _Empty_byte { };\n-\n-      union {\n-          _Empty_byte _M_empty;\n-          _Stored_type _M_payload;\n-      };\n-      bool _M_engaged;\n-\n-      template<typename... _Args>\n-        void\n-        _M_construct(_Args&&... __args)\n-        noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)\n-        {\n-          ::new ((void *) std::__addressof(this->_M_payload))\n-            _Stored_type(std::forward<_Args>(__args)...);\n-          this->_M_engaged = true;\n-        }\n-\n-      // The _M_get operations have _M_engaged as a precondition.\n-      constexpr _Tp&\n-      _M_get() noexcept\n-      { return this->_M_payload; }\n-\n-      constexpr const _Tp&\n-      _M_get() const noexcept\n-      { return this->_M_payload; }\n-\n-      // _M_reset is a 'safe' operation with no precondition.\n-      constexpr\n-      void\n-      _M_reset() noexcept\n-      {\n-\tif (this->_M_engaged)\n-\t  {\n-\t    this->_M_engaged = false;\n-\t    this->_M_payload.~_Stored_type();\n-\t  }\n-      }\n     };\n \n-  // Payload for optionals with non-trivial move assignment.\n+  // Payload for optionals with non-trivial move construction/assignment.\n   template <typename _Tp>\n     struct _Optional_payload<_Tp, true, true, false>\n+    : _Optional_payload_base<_Tp>\n     {\n-      constexpr _Optional_payload() noexcept\n-      : _M_empty(), _M_engaged(false) { }\n-\n-      template<typename... _Args>\n-\tconstexpr\n-\t_Optional_payload(in_place_t, _Args&&... __args)\n-\t: _M_payload(std::forward<_Args>(__args)...),\n-\t  _M_engaged(true)\n-\t{ }\n-\n-      template<typename _Up, typename... _Args>\n-\tconstexpr\n-\t_Optional_payload(std::initializer_list<_Up> __il,\n-\t\t\t  _Args&&... __args)\n-\t: _M_payload(__il, std::forward<_Args>(__args)...),\n-\t  _M_engaged(true)\n-\t{ }\n-\n-      template <class _Up> struct __ctor_tag {};\n-\n-      constexpr\n-      _Optional_payload(__ctor_tag<bool>, const _Tp& __other)\n-      : _M_payload(__other),\n-\t_M_engaged(true)\n-      { }\n-\n-      constexpr _Optional_payload(__ctor_tag<void>) noexcept\n-      : _M_empty(), _M_engaged(false)\n-      { }\n-\n-      constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)\n-      : _M_payload(std::move(__other)),\n-\t_M_engaged(true)\n-      { }\n-\n-      constexpr\n-      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n-      : _Optional_payload(__engaged ?\n-\t\t\t  _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t    __other._M_payload) :\n-\t\t\t  _Optional_payload(__ctor_tag<void>{}))\n-      { }\n-\n-      constexpr\n-      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n-      : _Optional_payload(__engaged\n-\t\t\t  ? _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t      std::move(__other._M_payload))\n-\t\t\t  : _Optional_payload(__ctor_tag<void>{}))\n-      { }\n+      using _Optional_payload_base<_Tp>::_Optional_payload_base;\n \n+      _Optional_payload() = default;\n+      ~_Optional_payload() = default;\n       _Optional_payload(const _Optional_payload&) = default;\n       _Optional_payload(_Optional_payload&&) = default;\n+      _Optional_payload& operator=(const _Optional_payload&) = default;\n \n-      _Optional_payload&\n-      operator=(const _Optional_payload& __other) = default;\n-\n+      // Non-trivial move assignment.\n       constexpr\n       _Optional_payload&\n       operator=(_Optional_payload&& __other)\n@@ -490,106 +330,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n \treturn *this;\n       }\n-\n-      using _Stored_type = remove_const_t<_Tp>;\n-\n-      struct _Empty_byte { };\n-\n-      union {\n-          _Empty_byte _M_empty;\n-          _Stored_type _M_payload;\n-      };\n-      bool _M_engaged;\n-\n-      template<typename... _Args>\n-        void\n-        _M_construct(_Args&&... __args)\n-        noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)\n-        {\n-          ::new ((void *) std::__addressof(this->_M_payload))\n-            _Stored_type(std::forward<_Args>(__args)...);\n-          this->_M_engaged = true;\n-        }\n-\n-      // The _M_get operations have _M_engaged as a precondition.\n-      constexpr _Tp&\n-      _M_get() noexcept\n-      { return this->_M_payload; }\n-\n-      constexpr const _Tp&\n-      _M_get() const noexcept\n-      { return this->_M_payload; }\n-\n-      // _M_reset is a 'safe' operation with no precondition.\n-      constexpr\n-      void\n-      _M_reset() noexcept\n-      {\n-\tif (this->_M_engaged)\n-\t  {\n-\t    this->_M_engaged = false;\n-\t    this->_M_payload.~_Stored_type();\n-\t  }\n-      }\n     };\n \n   // Payload for optionals with non-trivial copy and move assignment.\n   template <typename _Tp>\n     struct _Optional_payload<_Tp, true, false, false>\n+    : _Optional_payload_base<_Tp>\n     {\n-      constexpr _Optional_payload() noexcept\n-      : _M_empty(), _M_engaged(false) {}\n-\n-      template<typename... _Args>\n-\tconstexpr\n-\t_Optional_payload(in_place_t, _Args&&... __args)\n-\t: _M_payload(std::forward<_Args>(__args)...),\n-\t  _M_engaged(true)\n-\t{ }\n-\n-      template<typename _Up, typename... _Args>\n-\tconstexpr\n-\t_Optional_payload(std::initializer_list<_Up> __il,\n-\t\t\t  _Args&&... __args)\n-\t: _M_payload(__il, std::forward<_Args>(__args)...),\n-\t  _M_engaged(true)\n-\t{ }\n-\n-      template <class _Up> struct __ctor_tag {};\n-\n-      constexpr _Optional_payload(__ctor_tag<bool>, const _Tp& __other)\n-      : _M_payload(__other),\n-\t    _M_engaged(true)\n-      { }\n-\n-      constexpr _Optional_payload(__ctor_tag<void>) noexcept\n-      : _M_empty(), _M_engaged(false)\n-      { }\n-\n-      constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)\n-      : _M_payload(std::move(__other)),\n-\t_M_engaged(true)\n-      { }\n-\n-      constexpr\n-      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n-      : _Optional_payload(__engaged ?\n-\t\t\t  _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t    __other._M_payload) :\n-\t\t\t  _Optional_payload(__ctor_tag<void>{}))\n-      { }\n-\n-      constexpr\n-      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n-      : _Optional_payload(__engaged\n-\t\t\t  ? _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t      std::move(__other._M_payload))\n-\t\t\t  : _Optional_payload(__ctor_tag<void>{}))\n-      { }\n+      using _Optional_payload_base<_Tp>::_Optional_payload_base;\n \n+      _Optional_payload() = default;\n+      ~_Optional_payload() = default;\n       _Optional_payload(const _Optional_payload&) = default;\n       _Optional_payload(_Optional_payload&&) = default;\n \n+      // Non-trivial copy\n       constexpr\n       _Optional_payload&\n       operator=(const _Optional_payload& __other)\n@@ -606,6 +361,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n+      // Non-trivial move assignment.\n       constexpr\n       _Optional_payload&\n       operator=(_Optional_payload&& __other)\n@@ -623,56 +379,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n \treturn *this;\n       }\n+    };\n \n-      using _Stored_type = remove_const_t<_Tp>;\n-\n-      struct _Empty_byte { };\n-\n-      union {\n-          _Empty_byte _M_empty;\n-          _Stored_type _M_payload;\n-      };\n-      bool _M_engaged;\n-\n-      template<typename... _Args>\n-        constexpr\n-        void\n-        _M_construct(_Args&&... __args)\n-        noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)\n-        {\n-          ::new ((void *) std::__addressof(this->_M_payload))\n-            _Stored_type(std::forward<_Args>(__args)...);\n-          this->_M_engaged = true;\n-        }\n-\n-      // The _M_get operations have _M_engaged as a precondition.\n-      constexpr _Tp&\n-      _M_get() noexcept\n-      { return this->_M_payload; }\n-\n-      constexpr const _Tp&\n-      _M_get() const noexcept\n-      { return this->_M_payload; }\n+  // Payload for optionals with non-trivial destructors.\n+  template <typename _Tp, bool _Copy, bool _Move>\n+    struct _Optional_payload<_Tp, false, _Copy, _Move>\n+    : _Optional_payload<_Tp, true, false, false>\n+    {\n+      // Base class implements all the constructors and assignment operators:\n+      using _Optional_payload<_Tp, true, false, false>::_Optional_payload;\n+      _Optional_payload() = default;\n+      _Optional_payload(const _Optional_payload&) = default;\n+      _Optional_payload(_Optional_payload&&) = default;\n+      _Optional_payload& operator=(const _Optional_payload&) = default;\n+      _Optional_payload& operator=(_Optional_payload&&) = default;\n \n-      // _M_reset is a 'safe' operation with no precondition.\n-      constexpr\n-      void\n-      _M_reset() noexcept\n-      {\n-\tif (this->_M_engaged)\n-\t  {\n-\t    this->_M_engaged = false;\n-\t    this->_M_payload.~_Stored_type();\n-\t  }\n-      }\n+      // Destructor needs to destroy the contained value:\n+      ~_Optional_payload() { this->_M_reset(); }\n     };\n \n+  // Common base class for _Optional_base<T> to avoid repeating these\n+  // member functions in each specialization.\n   template<typename _Tp, typename _Dp>\n     class _Optional_base_impl\n     {\n     protected:\n       using _Stored_type = remove_const_t<_Tp>;\n-      \n+\n       // The _M_construct operation has !_M_engaged as a precondition\n       // while _M_destruct has _M_engaged as a precondition.\n       template<typename... _Args>\n@@ -685,42 +418,59 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    _Stored_type(std::forward<_Args>(__args)...);\n \t  static_cast<_Dp*>(this)->_M_payload._M_engaged = true;\n \t}\n-      \n+\n       void\n       _M_destruct() noexcept\n-      {\n-\tstatic_cast<_Dp*>(this)->_M_payload._M_engaged = false;\n-\tstatic_cast<_Dp*>(this)->_M_payload._M_payload.~_Stored_type();\n-      }\n-      \n+      { static_cast<_Dp*>(this)->_M_payload._M_destroy(); }\n+\n       // _M_reset is a 'safe' operation with no precondition.\n-      constexpr\n-      void\n+      constexpr void\n       _M_reset() noexcept\n+      { static_cast<_Dp*>(this)->_M_payload._M_reset(); }\n+\n+      constexpr bool _M_is_engaged() const noexcept\n+      { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }\n+\n+      // The _M_get operations have _M_engaged as a precondition.\n+      constexpr _Tp&\n+      _M_get() noexcept\n       {\n-\tif (static_cast<_Dp*>(this)->_M_payload._M_engaged)\n-\t  static_cast<_Dp*>(this)->_M_destruct();\n+\t__glibcxx_assert(this->_M_is_engaged());\n+\treturn static_cast<_Dp*>(this)->_M_payload._M_get();\n       }\n-  };\n+\n+      constexpr const _Tp&\n+      _M_get() const noexcept\n+      {\n+\t__glibcxx_assert(this->_M_is_engaged());\n+\treturn static_cast<const _Dp*>(this)->_M_payload._M_get();\n+      }\n+    };\n \n   /**\n-    * @brief Class template that takes care of copy/move constructors\n-    of optional\n+    * @brief Class template that provides copy/move constructors of optional.\n     *\n     * Such a separate base class template is necessary in order to\n     * conditionally make copy/move constructors trivial.\n+    *\n+    * When the contained value is trivally copy/move constructible,\n+    * the copy/move constructors of _Optional_base will invoke the\n+    * trivial copy/move constructor of _Optional_payload. Otherwise,\n+    * they will invoke _Optional_payload(bool, const _Optional_payload&)\n+    * or _Optional_payload(bool, _Optional_payload&&) to initialize\n+    * the contained value, if copying/moving an engaged optional.\n+    *\n+    * Whether the other special members are trivial is determined by the\n+    * _Optional_payload<_Tp> specialization used for the _M_payload member.\n+    *\n     * @see optional, _Enable_special_members\n     */\n   template<typename _Tp,\n \t   bool = is_trivially_copy_constructible_v<_Tp>,\n \t   bool = is_trivially_move_constructible_v<_Tp>>\n-    class _Optional_base\n-    // protected inheritance because optional needs to reach that base too\n-      : protected _Optional_base_impl<_Tp, _Optional_base<_Tp>>\n+    struct _Optional_base\n+      : _Optional_base_impl<_Tp, _Optional_base<_Tp>>\n     {\n-      friend class _Optional_base_impl<_Tp, _Optional_base<_Tp>>;\n-\n-    public:\n       // Constructors for disengaged optionals.\n       constexpr _Optional_base() = default;\n \n@@ -758,37 +508,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Optional_base& operator=(const _Optional_base&) = default;\n       _Optional_base& operator=(_Optional_base&&) = default;\n \n-    protected:\n-\n-      constexpr bool _M_is_engaged() const noexcept\n-      { return this->_M_payload._M_engaged; }\n-\n-      // The _M_get operations have _M_engaged as a precondition.\n-      constexpr _Tp&\n-\t_M_get() noexcept\n-      {\n-\t__glibcxx_assert(this->_M_is_engaged());\n-\treturn this->_M_payload._M_payload;\n-      }\n-\n-      constexpr const _Tp&\n-\t_M_get() const noexcept\n-      {\n-\t__glibcxx_assert(this->_M_is_engaged());\n-\treturn this->_M_payload._M_payload;\n-      }\n-\n-    private:\n       _Optional_payload<_Tp> _M_payload;\n     };\n \n   template<typename _Tp>\n-    class _Optional_base<_Tp, false, true>\n-      : protected _Optional_base_impl<_Tp, _Optional_base<_Tp>>\n+    struct _Optional_base<_Tp, false, true>\n+      : _Optional_base_impl<_Tp, _Optional_base<_Tp>>\n     {\n-      friend class _Optional_base_impl<_Tp, _Optional_base<_Tp>>;\n-    public:\n-\n       // Constructors for disengaged optionals.\n       constexpr _Optional_base() = default;\n \n@@ -822,37 +548,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Optional_base& operator=(const _Optional_base&) = default;\n       _Optional_base& operator=(_Optional_base&&) = default;\n \n-    protected:\n-\n-      constexpr bool _M_is_engaged() const noexcept\n-      { return this->_M_payload._M_engaged; }\n-\n-      // The _M_get operations have _M_engaged as a precondition.\n-      constexpr _Tp&\n-\t_M_get() noexcept\n-      {\n-\t__glibcxx_assert(this->_M_is_engaged());\n-\treturn this->_M_payload._M_payload;\n-      }\n-\n-      constexpr const _Tp&\n-\t_M_get() const noexcept\n-      {\n-\t__glibcxx_assert(this->_M_is_engaged());\n-\treturn this->_M_payload._M_payload;\n-      }\n-\n-    private:\n       _Optional_payload<_Tp> _M_payload;\n     };\n \n   template<typename _Tp>\n-    class _Optional_base<_Tp, true, false>\n-      : protected _Optional_base_impl<_Tp, _Optional_base<_Tp>>\n+    struct _Optional_base<_Tp, true, false>\n+      : _Optional_base_impl<_Tp, _Optional_base<_Tp>>\n     {\n-      friend class _Optional_base_impl<_Tp, _Optional_base<_Tp>>;\n-    public:\n-\n       // Constructors for disengaged optionals.\n       constexpr _Optional_base() = default;\n \n@@ -887,37 +589,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Optional_base& operator=(const _Optional_base&) = default;\n       _Optional_base& operator=(_Optional_base&&) = default;\n \n-    protected:\n-\n-      constexpr bool _M_is_engaged() const noexcept\n-      { return this->_M_payload._M_engaged; }\n-\n-      // The _M_get operations have _M_engaged as a precondition.\n-      constexpr _Tp&\n-\t_M_get() noexcept\n-      {\n-\t__glibcxx_assert(this->_M_is_engaged());\n-\treturn this->_M_payload._M_payload;\n-      }\n-\n-      constexpr const _Tp&\n-\t_M_get() const noexcept\n-      {\n-\t__glibcxx_assert(this->_M_is_engaged());\n-\treturn this->_M_payload._M_payload;\n-      }\n-\n-    private:\n       _Optional_payload<_Tp> _M_payload;\n     };\n \n   template<typename _Tp>\n-    class _Optional_base<_Tp, true, true>\n-      : protected _Optional_base_impl<_Tp, _Optional_base<_Tp>>\n+    struct _Optional_base<_Tp, true, true>\n+      : _Optional_base_impl<_Tp, _Optional_base<_Tp>>\n     {\n-      friend class _Optional_base_impl<_Tp, _Optional_base<_Tp>>;\n-    public:\n-\n       // Constructors for disengaged optionals.\n       constexpr _Optional_base() = default;\n \n@@ -947,27 +625,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Optional_base& operator=(const _Optional_base&) = default;\n       _Optional_base& operator=(_Optional_base&&) = default;\n \n-    protected:\n-\n-      constexpr bool _M_is_engaged() const noexcept\n-      { return this->_M_payload._M_engaged; }\n-\n-      // The _M_get operations have _M_engaged as a precondition.\n-      constexpr _Tp&\n-\t_M_get() noexcept\n-      {\n-\t__glibcxx_assert(this->_M_is_engaged());\n-\treturn this->_M_payload._M_payload;\n-      }\n-\n-      constexpr const _Tp&\n-\t_M_get() const noexcept\n-      {\n-\t__glibcxx_assert(this->_M_is_engaged());\n-\treturn this->_M_payload._M_payload;\n-      }\n-\n-    private:\n       _Optional_payload<_Tp> _M_payload;\n     };\n \n@@ -1262,36 +919,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       value() const&\n       {\n \treturn this->_M_is_engaged()\n-\t  ?  this->_M_get()\n-\t  : (__throw_bad_optional_access(),\n-\t     this->_M_get());\n+\t  ? this->_M_get()\n+\t  : (__throw_bad_optional_access(), this->_M_get());\n       }\n \n       constexpr _Tp&\n       value()&\n       {\n \treturn this->_M_is_engaged()\n-\t  ?  this->_M_get()\n-\t  : (__throw_bad_optional_access(),\n-\t     this->_M_get());\n+\t  ? this->_M_get()\n+\t  : (__throw_bad_optional_access(), this->_M_get());\n       }\n \n       constexpr _Tp&&\n       value()&&\n       {\n \treturn this->_M_is_engaged()\n-\t  ?  std::move(this->_M_get())\n-\t  : (__throw_bad_optional_access(),\n-\t     std::move(this->_M_get()));\n+\t  ? std::move(this->_M_get())\n+\t  : (__throw_bad_optional_access(), std::move(this->_M_get()));\n       }\n \n       constexpr const _Tp&&\n       value() const&&\n       {\n \treturn this->_M_is_engaged()\n-\t  ?  std::move(this->_M_get())\n-\t  : (__throw_bad_optional_access(),\n-\t     std::move(this->_M_get()));\n+\t  ? std::move(this->_M_get())\n+\t  : (__throw_bad_optional_access(), std::move(this->_M_get()));\n       }\n \n       template<typename _Up>\n@@ -1302,8 +955,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  static_assert(is_convertible_v<_Up&&, _Tp>);\n \n \t  return this->_M_is_engaged()\n-\t    ? this->_M_get()\n-\t    : static_cast<_Tp>(std::forward<_Up>(__u));\n+\t    ? this->_M_get() : static_cast<_Tp>(std::forward<_Up>(__u));\n \t}\n \n       template<typename _Up>"}, {"sha": "967d03a43c7e9f210dd074ed0dcb95fa7c4c08f3", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc", "patch": "@@ -1093,13 +1093,23 @@ class StdExpOptionalPrinter(SingleObjContainerPrinter):\n \n     def __init__ (self, typename, val):\n         valtype = self._recognize (val.type.template_argument(0))\n-        self.typename = strip_versioned_namespace(typename)\n-        self.typename = re.sub('^std::(experimental::|)(fundamentals_v\\d::|)(.*)', r'std::\\1\\3<%s>' % valtype, self.typename, 1)\n-        if not self.typename.startswith('std::experimental'):\n-            val = val['_M_payload']\n-        self.val = val\n-        contained_value = val['_M_payload'] if self.val['_M_engaged'] else None\n-        visualizer = gdb.default_visualizer (val['_M_payload'])\n+        typename = strip_versioned_namespace(typename)\n+        self.typename = re.sub('^std::(experimental::|)(fundamentals_v\\d::|)(.*)', r'std::\\1\\3<%s>' % valtype, typename, 1)\n+        payload = val['_M_payload']\n+        if self.typename.startswith('std::experimental'):\n+            engaged = val['_M_engaged']\n+            contained_value = payload\n+        else:\n+            engaged = payload['_M_engaged']\n+            contained_value = payload['_M_payload']\n+            try:\n+                # Since GCC 9\n+                contained_value = contained_value['_M_value']\n+            except:\n+                pass\n+        visualizer = gdb.default_visualizer (contained_value)\n+        if not engaged:\n+            contained_value = None\n         super (StdExpOptionalPrinter, self).__init__ (contained_value, visualizer)\n \n     def to_string (self):"}, {"sha": "39271ddaf27023cbcc46808f09e999a345515899", "filename": "libstdc++-v3/testsuite/libstdc++-prettyprinters/compat.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fcompat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fcompat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fcompat.cc?ref=d942bc80e4e99f26df39b8c03e8fb03e7c7e91bc", "patch": "@@ -0,0 +1,76 @@\n+// { dg-options \"-g -O0\" }\n+// { dg-do run }\n+// { dg-skip-if \"\" { *-*-* } { \"-D_GLIBCXX_PROFILE\" } }\n+\n+// Copyright (C) 2014-2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Test that current printers still support old definitions of types.\n+\n+namespace std\n+{\n+  // Old representation of std::optional, before GCC 9\n+  template<typename T>\n+    struct _Optional_payload\n+    {\n+      _Optional_payload() : _M_empty(), _M_engaged(false) { }\n+      struct _Empty_byte { };\n+      union {\n+\t_Empty_byte _M_empty;\n+\tT _M_payload;\n+      };\n+      bool _M_engaged;\n+    };\n+\n+  template<typename T>\n+    struct _Optional_base\n+    {\n+      _Optional_payload<T> _M_payload;\n+    };\n+\n+  template<typename T>\n+    struct optional : _Optional_base<T>\n+    {\n+      optional() { }\n+\n+      optional(T t)\n+      {\n+\tthis->_M_payload._M_payload = t;\n+\tthis->_M_payload._M_engaged = true;\n+      }\n+    };\n+} // namespace std\n+\n+int\n+main()\n+{\n+  using std::optional;\n+\n+  optional<int> o;\n+// { dg-final { note-test o {std::optional<int> [no contained value]} } }\n+  optional<bool> ob{false};\n+// { dg-final { note-test ob {std::optional<bool> = {[contained value] = false}} } }\n+  optional<int> oi{5};\n+// { dg-final { note-test oi {std::optional<int> = {[contained value] = 5}} } }\n+  optional<void*> op{nullptr};\n+// { dg-final { note-test op {std::optional<void *> = {[contained value] = 0x0}} } }\n+\n+  __builtin_puts(\"\");\n+  return 0;\t\t\t// Mark SPOT\n+}\n+\n+// { dg-final { gdb-test SPOT } }"}]}