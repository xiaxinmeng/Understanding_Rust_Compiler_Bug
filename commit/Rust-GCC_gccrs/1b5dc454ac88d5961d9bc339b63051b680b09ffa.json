{"sha": "1b5dc454ac88d5961d9bc339b63051b680b09ffa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI1ZGM0NTRhYzg4ZDU5NjFkOWJjMzM5YjYzMDUxYjY4MGIwOWZmYQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2020-05-27T20:44:40Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-10T09:16:21Z"}, "message": "[Ada] Potentially unevaluated nested expressions\n\ngcc/ada/\n\n\t* sem_util.adb\n\t(Immediate_Context_Implies_Is_Potentially_Unevaluated): New\n\tsubprogram.\n\t(Is_Potentially_Unevaluated): Do not stop climbing the tree on\n\tthe first candidate subexpression; required to handle nested\n\texpressions.", "tree": {"sha": "1bcb9f1166f180295675eb684fd1218c7e1f2be3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bcb9f1166f180295675eb684fd1218c7e1f2be3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b5dc454ac88d5961d9bc339b63051b680b09ffa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b5dc454ac88d5961d9bc339b63051b680b09ffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b5dc454ac88d5961d9bc339b63051b680b09ffa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b5dc454ac88d5961d9bc339b63051b680b09ffa/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce59f39f78b0a517eaa61b6845c25c60bc19c455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce59f39f78b0a517eaa61b6845c25c60bc19c455", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce59f39f78b0a517eaa61b6845c25c60bc19c455"}], "stats": {"total": 211, "additions": 119, "deletions": 92}, "files": [{"sha": "643eb216294a8089fac586892659e51ab1af231f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 119, "deletions": 92, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b5dc454ac88d5961d9bc339b63051b680b09ffa/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b5dc454ac88d5961d9bc339b63051b680b09ffa/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=1b5dc454ac88d5961d9bc339b63051b680b09ffa", "patch": "@@ -17752,6 +17752,13 @@ package body Sem_Util is\n       --  return True if the others choice of the given array aggregate does\n       --  not cover any component (i.e. is null).\n \n+      function Immediate_Context_Implies_Is_Potentially_Unevaluated\n+        (Expr : Node_Id) return Boolean;\n+      --  Return True if the *immediate* context of this expression tells us\n+      --  that it is potentially unevaluated; return False if the *immediate*\n+      --  context doesn't provide an answer to this question and we need to\n+      --  keep looking.\n+\n       function Non_Static_Or_Null_Range (N : Node_Id) return Boolean;\n       --  Return True if the given range is nonstatic or null\n \n@@ -17789,6 +17796,99 @@ package body Sem_Util is\n             return False;\n       end Has_Null_Others_Choice;\n \n+      ----------------------------------------------------------\n+      -- Immediate_Context_Implies_Is_Potentially_Unevaluated --\n+      ----------------------------------------------------------\n+\n+      function Immediate_Context_Implies_Is_Potentially_Unevaluated\n+        (Expr : Node_Id) return Boolean\n+      is\n+         Par : constant Node_Id := Parent (Expr);\n+\n+      begin\n+         if Nkind (Par) = N_If_Expression then\n+            return Is_Elsif (Par) or else Expr /= First (Expressions (Par));\n+\n+         elsif Nkind (Par) = N_Case_Expression then\n+            return Expr /= Expression (Par);\n+\n+         elsif Nkind_In (Par, N_And_Then, N_Or_Else) then\n+            return Expr = Right_Opnd (Par);\n+\n+         elsif Nkind_In (Par, N_In, N_Not_In) then\n+\n+            --  If the membership includes several alternatives, only the first\n+            --  is definitely evaluated.\n+\n+            if Present (Alternatives (Par)) then\n+               return Expr /= First (Alternatives (Par));\n+\n+            --  If this is a range membership both bounds are evaluated\n+\n+            else\n+               return False;\n+            end if;\n+\n+         elsif Nkind (Par) = N_Quantified_Expression then\n+            return Expr = Condition (Par);\n+\n+         elsif Nkind (Par) = N_Aggregate\n+           and then Present (Etype (Par))\n+           and then Etype (Par) /= Any_Composite\n+           and then Is_Array_Type (Etype (Par))\n+           and then Nkind (Expr) = N_Component_Association\n+         then\n+            declare\n+               Choice           : Node_Id;\n+               In_Others_Choice : Boolean := False;\n+\n+            begin\n+               --  The expression of an array_component_association is\n+               --  potentially unevaluated if the associated choice is a\n+               --  subtype_indication or range that defines a nonstatic or\n+               --  null range.\n+\n+               Choice := First (Choices (Expr));\n+               while Present (Choice) loop\n+                  if Nkind (Choice) = N_Range\n+                    and then Non_Static_Or_Null_Range (Choice)\n+                  then\n+                     return True;\n+\n+                  elsif Nkind (Choice) = N_Identifier\n+                    and then Present (Scalar_Range (Etype (Choice)))\n+                    and then\n+                      Non_Static_Or_Null_Range (Scalar_Range (Etype (Choice)))\n+                  then\n+                     return True;\n+\n+                  elsif Nkind (Choice) = N_Others_Choice then\n+                     In_Others_Choice := True;\n+                  end if;\n+\n+                  Next (Choice);\n+               end loop;\n+\n+               --  It is also potentially unevaluated if the associated choice\n+               --  is an others choice and the applicable index constraint is\n+               --  nonstatic or null.\n+\n+               if In_Others_Choice then\n+                  if not Compile_Time_Known_Bounds (Etype (Par)) then\n+                     return True;\n+                  else\n+                     return Has_Null_Others_Choice (Par);\n+                  end if;\n+               end if;\n+            end;\n+\n+            return False;\n+\n+         else\n+            return False;\n+         end if;\n+      end Immediate_Context_Implies_Is_Potentially_Unevaluated;\n+\n       ------------------------------\n       -- Non_Static_Or_Null_Range --\n       ------------------------------\n@@ -17850,113 +17950,40 @@ package body Sem_Util is\n       --  conjunct in a postcondition) with a potentially unevaluated operand.\n \n       Par := Parent (Expr);\n-      while not Nkind_In (Par, N_And_Then,\n-                               N_Case_Expression,\n-                               N_If_Expression,\n-                               N_In,\n-                               N_Not_In,\n-                               N_Or_Else,\n-                               N_Quantified_Expression)\n-        and then not (Nkind (Par) = N_Aggregate\n-                        and then Etype (Par) /= Any_Composite\n-                        and then Is_Array_Type (Etype (Par)))\n+\n+      while Present (Par)\n+        and then Nkind (Par) /= N_Pragma_Argument_Association\n       loop\n-         Expr := Par;\n-         Par  := Parent (Par);\n+         if Comes_From_Source (Par)\n+           and then\n+             Immediate_Context_Implies_Is_Potentially_Unevaluated (Expr)\n+         then\n+            return True;\n+\n+         --  For component associations continue climbing; it may be part of\n+         --  an array aggregate.\n+\n+         elsif Nkind (Par) = N_Component_Association then\n+            null;\n \n          --  If the context is not an expression, or if is the result of\n          --  expansion of an enclosing construct (such as another attribute)\n          --  the predicate does not apply.\n \n-         if Nkind (Par) = N_Case_Expression_Alternative then\n+         elsif Nkind (Par) = N_Case_Expression_Alternative then\n             null;\n \n          elsif Nkind (Par) not in N_Subexpr\n            or else not Comes_From_Source (Par)\n          then\n             return False;\n          end if;\n-      end loop;\n-\n-      if Nkind (Par) = N_If_Expression then\n-         return Is_Elsif (Par) or else Expr /= First (Expressions (Par));\n-\n-      elsif Nkind (Par) = N_Case_Expression then\n-         return Expr /= Expression (Par);\n-\n-      elsif Nkind_In (Par, N_And_Then, N_Or_Else) then\n-         return Expr = Right_Opnd (Par);\n-\n-      elsif Nkind_In (Par, N_In, N_Not_In) then\n-\n-         --  If the membership includes several alternatives, only the first is\n-         --  definitely evaluated.\n-\n-         if Present (Alternatives (Par)) then\n-            return Expr /= First (Alternatives (Par));\n-\n-         --  If this is a range membership both bounds are evaluated\n-\n-         else\n-            return False;\n-         end if;\n-\n-      elsif Nkind (Par) = N_Quantified_Expression then\n-         return Expr = Condition (Par);\n-\n-      elsif Nkind (Par) = N_Aggregate\n-        and then Etype (Par) /= Any_Composite\n-        and then Is_Array_Type (Etype (Par))\n-        and then Nkind (Expr) = N_Component_Association\n-      then\n-         declare\n-            Choice           : Node_Id;\n-            In_Others_Choice : Boolean := False;\n-\n-         begin\n-            --  The expression of an array_component_association is potentially\n-            --  unevaluated if the associated choice is a subtype_indication or\n-            --  range that defines a nonstatic or null range.\n-\n-            Choice := First (Choices (Expr));\n-            while Present (Choice) loop\n-               if Nkind (Choice) = N_Range\n-                 and then Non_Static_Or_Null_Range (Choice)\n-               then\n-                  return True;\n-\n-               elsif Nkind (Choice) = N_Identifier\n-                 and then Present (Scalar_Range (Etype (Choice)))\n-                 and then\n-                   Non_Static_Or_Null_Range (Scalar_Range (Etype (Choice)))\n-               then\n-                  return True;\n-\n-               elsif Nkind (Choice) = N_Others_Choice then\n-                  In_Others_Choice := True;\n-               end if;\n-\n-               Next (Choice);\n-            end loop;\n-\n-            --  It is also potentially unevaluated if the associated choice\n-            --  is an others choice and the applicable index constraint is\n-            --  nonstatic or null.\n-\n-            if In_Others_Choice then\n-               if not Compile_Time_Known_Bounds (Etype (Par)) then\n-                  return True;\n-               else\n-                  return Has_Null_Others_Choice (Par);\n-               end if;\n-            end if;\n-         end;\n \n-         return False;\n+         Expr := Par;\n+         Par  := Parent (Par);\n+      end loop;\n \n-      else\n-         return False;\n-      end if;\n+      return False;\n    end Is_Potentially_Unevaluated;\n \n    -----------------------------------------"}]}