{"sha": "27916b83f5f371d27f728fcc003fe93b0e44b3cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc5MTZiODNmNWYzNzFkMjdmNzI4ZmNjMDAzZmU5M2IwZTQ0YjNjYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2005-01-06T19:10:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-06T19:10:56Z"}, "message": "re PR rtl-optimization/13299 (Unsafe treatment of extended givs)\n\n        PR rtl-opt/13299\n        * loop.c (get_monotonic_increment, biased_biv_fits_mode_p,\n        biv_fits_mode_p, extension_within_bounds_p): New functions.\n        (check_ext_dependent_givs): Use them.\n\nFrom-SVN: r93000", "tree": {"sha": "19e9dc3f1ffa12be4d4551159477f7db64176090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19e9dc3f1ffa12be4d4551159477f7db64176090"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27916b83f5f371d27f728fcc003fe93b0e44b3cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27916b83f5f371d27f728fcc003fe93b0e44b3cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27916b83f5f371d27f728fcc003fe93b0e44b3cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27916b83f5f371d27f728fcc003fe93b0e44b3cc/comments", "author": null, "committer": null, "parents": [{"sha": "4ab8006314c6e08c6e63e0743bf0a7e18c38792f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ab8006314c6e08c6e63e0743bf0a7e18c38792f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ab8006314c6e08c6e63e0743bf0a7e18c38792f"}], "stats": {"total": 390, "additions": 226, "deletions": 164}, "files": [{"sha": "05e754715e16f5ea9f39f34ebc3aa7218e19c49b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27916b83f5f371d27f728fcc003fe93b0e44b3cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27916b83f5f371d27f728fcc003fe93b0e44b3cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27916b83f5f371d27f728fcc003fe93b0e44b3cc", "patch": "@@ -1,3 +1,10 @@\n+2005-01-06  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\tPR rtl-opt/13299\n+\t* loop.c (get_monotonic_increment, biased_biv_fits_mode_p,\n+\tbiv_fits_mode_p, extension_within_bounds_p): New functions.\n+\t(check_ext_dependent_givs): Use them.\n+\n 2005-01-06  Roger Sayle  <roger@eyesopen.com>\n \n \t* cfgrtl.c (rtl_delete_block): A basic block may be followed by"}, {"sha": "77aec293a37a349fd5f9239b34dbd17b0d4fb830", "filename": "gcc/loop.c", "status": "modified", "additions": 184, "deletions": 164, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27916b83f5f371d27f728fcc003fe93b0e44b3cc/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27916b83f5f371d27f728fcc003fe93b0e44b3cc/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=27916b83f5f371d27f728fcc003fe93b0e44b3cc", "patch": "@@ -653,6 +653,14 @@ static void record_giv (const struct loop *, struct induction *, rtx, rtx,\n \t\t\trtx, rtx, rtx, rtx, int, enum g_types, int, int,\n \t\t\trtx *);\n static void update_giv_derive (const struct loop *, rtx);\n+static HOST_WIDE_INT get_monotonic_increment (struct iv_class *);\n+static bool biased_biv_fits_mode_p (const struct loop *, struct iv_class *,\n+\t\t\t\t    HOST_WIDE_INT, enum machine_mode,\n+\t\t\t\t    unsigned HOST_WIDE_INT);\n+static bool biv_fits_mode_p (const struct loop *, struct iv_class *,\n+\t\t\t     HOST_WIDE_INT, enum machine_mode, bool);\n+static bool extension_within_bounds_p (const struct loop *, struct iv_class *,\n+\t\t\t\t       HOST_WIDE_INT, rtx);\n static void check_ext_dependent_givs (const struct loop *, struct iv_class *);\n static int basic_induction_var (const struct loop *, rtx, enum machine_mode,\n \t\t\t\trtx, rtx, rtx *, rtx *, rtx **);\n@@ -8608,192 +8616,204 @@ combine_givs_p (struct induction *g1, struct induction *g2)\n   return NULL_RTX;\n }\n \f\n-/* Check each extension dependent giv in this class to see if its\n-   root biv is safe from wrapping in the interior mode, which would\n-   make the giv illegal.  */\n+/* See if BL is monotonic and has a constant per-iteration increment.\n+   Return the increment if so, otherwise return 0.  */\n \n-static void\n-check_ext_dependent_givs (const struct loop *loop, struct iv_class *bl)\n+static HOST_WIDE_INT\n+get_monotonic_increment (struct iv_class *bl)\n {\n-  struct loop_info *loop_info = LOOP_INFO (loop);\n-  int ze_ok = 0, se_ok = 0, info_ok = 0;\n-  enum machine_mode biv_mode = GET_MODE (bl->biv->src_reg);\n-  HOST_WIDE_INT start_val;\n-  unsigned HOST_WIDE_INT u_end_val = 0;\n-  unsigned HOST_WIDE_INT u_start_val = 0;\n-  rtx incr = pc_rtx;\n   struct induction *v;\n+  rtx incr;\n+\n+  /* Get the total increment and check that it is constant.  */\n+  incr = biv_total_increment (bl);\n+  if (incr == 0 || GET_CODE (incr) != CONST_INT)\n+    return 0;\n+\n+  for (v = bl->biv; v != 0; v = v->next_iv)\n+    {\n+      if (GET_CODE (v->add_val) != CONST_INT)\n+\treturn 0;\n+\n+      if (INTVAL (v->add_val) < 0 && INTVAL (incr) >= 0)\n+\treturn 0;\n+\n+      if (INTVAL (v->add_val) > 0 && INTVAL (incr) <= 0)\n+\treturn 0;\n+    }\n+  return INTVAL (incr);\n+}\n+\n+\n+/* Subroutine of biv_fits_mode_p.  Return true if biv BL, when biased by\n+   BIAS, will never exceed the unsigned range of MODE.  LOOP is the loop\n+   to which the biv belongs and INCR is its per-iteration increment.  */\n+\n+static bool\n+biased_biv_fits_mode_p (const struct loop *loop, struct iv_class *bl,\n+\t\t\tHOST_WIDE_INT incr, enum machine_mode mode,\n+\t\t\tunsigned HOST_WIDE_INT bias)\n+{\n+  unsigned HOST_WIDE_INT initial, maximum, span, delta;\n+\n+  /* We need to be able to manipulate MODE-size constants.  */\n+  if (HOST_BITS_PER_WIDE_INT < GET_MODE_BITSIZE (mode))\n+    return false;\n+\n+  /* The number of loop iterations must be constant.  */\n+  if (LOOP_INFO (loop)->n_iterations == 0)\n+    return false;\n+\n+  /* So must the biv's initial value.  */\n+  if (bl->initial_value == 0 || GET_CODE (bl->initial_value) != CONST_INT)\n+    return false;\n+\n+  initial = bias + INTVAL (bl->initial_value);\n+  maximum = GET_MODE_MASK (mode);\n \n-  /* Make sure the iteration data is available.  We must have\n-     constants in order to be certain of no overflow.  */\n-  if (loop_info->n_iterations > 0\n-      && bl->initial_value\n-      && GET_CODE (bl->initial_value) == CONST_INT\n-      && (incr = biv_total_increment (bl))\n-      && GET_CODE (incr) == CONST_INT\n-      /* Make sure the host can represent the arithmetic.  */\n-      && HOST_BITS_PER_WIDE_INT >= GET_MODE_BITSIZE (biv_mode))\n-    {\n-      unsigned HOST_WIDE_INT abs_incr, total_incr;\n-      HOST_WIDE_INT s_end_val;\n-      int neg_incr;\n-\n-      info_ok = 1;\n-      start_val = INTVAL (bl->initial_value);\n-      u_start_val = start_val;\n-\n-      neg_incr = 0, abs_incr = INTVAL (incr);\n-      if (INTVAL (incr) < 0)\n-\tneg_incr = 1, abs_incr = -abs_incr;\n-      total_incr = abs_incr * loop_info->n_iterations;\n-\n-      /* Check for host arithmetic overflow.  */\n-      if (total_incr / loop_info->n_iterations == abs_incr)\n+  /* Make sure that the initial value is within range.  */\n+  if (initial > maximum)\n+    return false;\n+\n+  /* Set up DELTA and SPAN such that the number of iterations * DELTA\n+     (calculated to arbitrary precision) must be <= SPAN.  */\n+  if (incr < 0)\n+    {\n+      delta = -incr;\n+      span = initial;\n+    }\n+  else\n+    {\n+      delta = incr;\n+      /* Handle the special case in which MAXIMUM is the largest\n+\t unsigned HOST_WIDE_INT and INITIAL is 0.  */\n+      if (maximum + 1 == initial)\n+\tspan = LOOP_INFO (loop)->n_iterations * delta;\n+      else\n+\tspan = maximum + 1 - initial;\n+    }\n+  return (span / LOOP_INFO (loop)->n_iterations >= delta);\n+}\n+\n+\n+/* Return true if biv BL will never exceed the bounds of MODE.  LOOP is\n+   the loop to which BL belongs and INCR is its per-iteration increment.\n+   UNSIGNEDP is true if the biv should be treated as unsigned.  */\n+\n+static bool\n+biv_fits_mode_p (const struct loop *loop, struct iv_class *bl,\n+\t\t HOST_WIDE_INT incr, enum machine_mode mode, bool unsignedp)\n+{\n+  struct loop_info *loop_info;\n+  unsigned HOST_WIDE_INT bias;\n+\n+  /* A biv's value will always be limited to its natural mode.\n+     Larger modes will observe the same wrap-around.  */\n+  if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (bl->biv->src_reg)))\n+    mode = GET_MODE (bl->biv->src_reg);\n+\n+  loop_info = LOOP_INFO (loop);\n+\n+  bias = (unsignedp ? 0 : (GET_MODE_MASK (mode) >> 1) + 1);\n+  if (biased_biv_fits_mode_p (loop, bl, incr, mode, bias))\n+    return true;\n+\n+  if (mode == GET_MODE (bl->biv->src_reg)\n+      && bl->biv->src_reg == loop_info->iteration_var\n+      && loop_info->comparison_value\n+      && loop_invariant_p (loop, loop_info->comparison_value))\n+    {\n+      /* If the increment is +1, and the exit test is a <, the BIV\n+         cannot overflow.  (For <=, we have the problematic case that\n+         the comparison value might be the maximum value of the range.)  */\n+      if (incr == 1)\n \t{\n-\t  unsigned HOST_WIDE_INT u_max;\n-\t  HOST_WIDE_INT s_max;\n-\n-\t  u_end_val = start_val + (neg_incr ? -total_incr : total_incr);\n-\t  s_end_val = u_end_val;\n-\t  u_max = GET_MODE_MASK (biv_mode);\n-\t  s_max = u_max >> 1;\n-\n-\t  /* Check zero extension of biv ok.  */\n-\t  if (start_val >= 0\n-\t      /* Check for host arithmetic overflow.  */\n-\t      && (neg_incr\n-\t\t  ? u_end_val < u_start_val\n-\t\t  : u_end_val > u_start_val)\n-\t      /* Check for target arithmetic overflow.  */\n-\t      && (neg_incr\n-\t\t  ? 1 /* taken care of with host overflow */\n-\t\t  : u_end_val <= u_max))\n-\t    {\n-\t      ze_ok = 1;\n-\t    }\n+\t  if (loop_info->comparison_code == LT)\n+\t    return true;\n+\t  if (loop_info->comparison_code == LTU && unsignedp)\n+\t    return true;\n+\t}\n \n-\t  /* Check sign extension of biv ok.  */\n-\t  /* ??? While it is true that overflow with signed and pointer\n-\t     arithmetic is undefined, I fear too many programmers don't\n-\t     keep this fact in mind -- myself included on occasion.\n-\t     So leave alone with the signed overflow optimizations.  */\n-\t  if (start_val >= -s_max - 1\n-\t      /* Check for host arithmetic overflow.  */\n-\t      && (neg_incr\n-\t\t  ? s_end_val < start_val\n-\t\t  : s_end_val > start_val)\n-\t      /* Check for target arithmetic overflow.  */\n-\t      && (neg_incr\n-\t\t  ? s_end_val >= -s_max - 1\n-\t\t  : s_end_val <= s_max))\n-\t    {\n-\t      se_ok = 1;\n-\t    }\n+      /* Likewise for increment -1 and exit test >.  */\n+      if (incr == -1)\n+\t{\n+\t  if (loop_info->comparison_code == GT)\n+\t    return true;\n+\t  if (loop_info->comparison_code == GTU && unsignedp)\n+\t    return true;\n \t}\n     }\n+  return false;\n+}\n+\n+\n+/* Given that X is an extension or truncation of BL, return true\n+   if it is unaffected by overflow.  LOOP is the loop to which\n+   BL belongs and INCR is its per-iteration increment.  */\n \n-  /* If we know the BIV is compared at run-time against an \n-     invariant value, and the increment is +/- 1, we may also \n-     be able to prove that the BIV cannot overflow.  */\n-  else if (bl->biv->src_reg == loop_info->iteration_var\n-           && loop_info->comparison_value\n-           && loop_invariant_p (loop, loop_info->comparison_value)\n-           && (incr = biv_total_increment (bl))\n-           && GET_CODE (incr) == CONST_INT)\n-    {\n-      /* If the increment is +1, and the exit test is a <,\n-         the BIV cannot overflow.  (For <=, we have the \n-         problematic case that the comparison value might\n-         be the maximum value of the range.)  */\n-       if (INTVAL (incr) == 1)\n-         {\n-           if (loop_info->comparison_code == LT)\n-             se_ok = ze_ok = 1;\n-           else if (loop_info->comparison_code == LTU)\n-             ze_ok = 1;\n-         }\n-\n-       /* Likewise for increment -1 and exit test >.  */\n-       if (INTVAL (incr) == -1)\n-         {\n-           if (loop_info->comparison_code == GT)\n-             se_ok = ze_ok = 1;\n-           else if (loop_info->comparison_code == GTU)\n-             ze_ok = 1;\n-         }\n+static bool\n+extension_within_bounds_p (const struct loop *loop, struct iv_class *bl,\n+\t\t\t   HOST_WIDE_INT incr, rtx x)\n+{\n+  enum machine_mode mode;\n+  bool signedp, unsignedp;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n+      mode = GET_MODE (XEXP (x, 0));\n+      signedp = (GET_CODE (x) == SIGN_EXTEND);\n+      unsignedp = (GET_CODE (x) == ZERO_EXTEND);\n+      break;\n+\n+    case TRUNCATE:\n+      /* We don't know whether this value is being used as signed\n+\t or unsigned, so check the conditions for both.  */\n+      mode = GET_MODE (x);\n+      signedp = unsignedp = true;\n+      break;\n+\n+    default:\n+      abort ();\n     }\n \n-  /* Invalidate givs that fail the tests.  */\n-  for (v = bl->giv; v; v = v->next_iv)\n-    if (v->ext_dependent)\n-      {\n-\tenum rtx_code code = GET_CODE (v->ext_dependent);\n-\tint ok = 0;\n+  return ((!signedp || biv_fits_mode_p (loop, bl, incr, mode, false))\n+\t  && (!unsignedp || biv_fits_mode_p (loop, bl, incr, mode, true)));\n+}\n \n-\tswitch (code)\n-\t  {\n-\t  case SIGN_EXTEND:\n-\t    ok = se_ok;\n-\t    break;\n-\t  case ZERO_EXTEND:\n-\t    ok = ze_ok;\n-\t    break;\n \n-\t  case TRUNCATE:\n-\t    /* We don't know whether this value is being used as either\n-\t       signed or unsigned, so to safely truncate we must satisfy\n-\t       both.  The initial check here verifies the BIV itself;\n-\t       once that is successful we may check its range wrt the\n-\t       derived GIV.  This works only if we were able to determine\n-\t       constant start and end values above.  */\n-\t    if (se_ok && ze_ok && info_ok)\n-\t      {\n-\t\tenum machine_mode outer_mode = GET_MODE (v->ext_dependent);\n-\t\tunsigned HOST_WIDE_INT max = GET_MODE_MASK (outer_mode) >> 1;\n-\n-\t\t/* We know from the above that both endpoints are nonnegative,\n-\t\t   and that there is no wrapping.  Verify that both endpoints\n-\t\t   are within the (signed) range of the outer mode.  */\n-\t\tif (u_start_val <= max && u_end_val <= max)\n-\t\t  ok = 1;\n-\t      }\n-\t    break;\n+/* Check each extension dependent giv in this class to see if its\n+   root biv is safe from wrapping in the interior mode, which would\n+   make the giv illegal.  */\n \n-\t  default:\n-\t    abort ();\n-\t  }\n+static void\n+check_ext_dependent_givs (const struct loop *loop, struct iv_class *bl)\n+{\n+  struct induction *v;\n+  HOST_WIDE_INT incr;\n+\n+  incr = get_monotonic_increment (bl);\n \n-\tif (ok)\n+  /* Invalidate givs that fail the tests.  */\n+  for (v = bl->giv; v; v = v->next_iv)\n+    if (v->ext_dependent)\n+      {\n+\tif (incr != 0\n+\t    && extension_within_bounds_p (loop, bl, incr, v->ext_dependent))\n \t  {\n \t    if (loop_dump_stream)\n-\t      {\n-\t\tfprintf (loop_dump_stream,\n-\t\t\t \"Verified ext dependent giv at %d of reg %d\\n\",\n-\t\t\t INSN_UID (v->insn), bl->regno);\n-\t      }\n+\t      fprintf (loop_dump_stream,\n+\t\t       \"Verified ext dependent giv at %d of reg %d\\n\",\n+\t\t       INSN_UID (v->insn), bl->regno);\n \t  }\n \telse\n \t  {\n \t    if (loop_dump_stream)\n-\t      {\n-\t\tconst char *why;\n-\n-\t\tif (info_ok)\n-\t\t  why = \"biv iteration values overflowed\";\n-\t\telse\n-\t\t  {\n-\t\t    if (incr == pc_rtx)\n-\t\t      incr = biv_total_increment (bl);\n-\t\t    if (incr == const1_rtx)\n-\t\t      why = \"biv iteration info incomplete; incr by 1\";\n-\t\t    else\n-\t\t      why = \"biv iteration info incomplete\";\n-\t\t  }\n+\t      fprintf (loop_dump_stream,\n+\t\t       \"Failed ext dependent giv at %d\\n\",\n+\t\t       INSN_UID (v->insn));\n \n-\t\tfprintf (loop_dump_stream,\n-\t\t\t \"Failed ext dependent giv at %d, %s\\n\",\n-\t\t\t INSN_UID (v->insn), why);\n-\t      }\n \t    v->ignore = 1;\n \t    bl->all_reduced = 0;\n \t  }"}, {"sha": "8b460c6dd68399d490037c985ba76d9dc74fca52", "filename": "gcc/testsuite/gcc.c-torture/execute/20030916-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27916b83f5f371d27f728fcc003fe93b0e44b3cc/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030916-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27916b83f5f371d27f728fcc003fe93b0e44b3cc/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030916-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20030916-1.c?ref=27916b83f5f371d27f728fcc003fe93b0e44b3cc", "patch": "@@ -0,0 +1,35 @@\n+/* \"i\" overflows in f().  Check that x[i] is not treated as a giv.  */\n+#include <limits.h>\n+\n+#if CHAR_BIT == 8\n+\n+void f (unsigned int *x)\n+{\n+  unsigned char i;\n+  int j;\n+\n+  i = 0x10;\n+  for (j = 0; j < 0x10; j++)\n+    {\n+      i += 0xe8;\n+      x[i] = 0;\n+      i -= 0xe7;\n+    }\n+}\n+\n+int main ()\n+{\n+  unsigned int x[256];\n+  int i;\n+\n+  for (i = 0; i < 256; i++)\n+    x[i] = 1;\n+  f (x);\n+  for (i = 0; i < 256; i++)\n+    if (x[i] != (i >= 0x08 && i < 0xf8))\n+      abort ();\n+  exit (0);\n+}\n+#else\n+int main () { exit (0); }\n+#endif"}]}