{"sha": "45656a992eb18bfefe2e6e20d3b425afe945af28", "node_id": "C_kwDOANBUbNoAKDQ1NjU2YTk5MmViMThiZmVmZTJlNmUyMGQzYjQyNWFmZTk0NWFmMjg", "commit": {"author": {"name": "Ronan Desplanques", "email": "desplanques@adacore.com", "date": "2022-10-24T09:50:06Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-11-08T08:35:02Z"}, "message": "ada: Adjust classwide contract expression preanalysis\n\nBefore this patch, a classwide contract expression was preanalyzed\nonly when its primitive operation's type was frozen. It caused name\nresolution to be off in the cases where the freezing took place\nafter the end of the declaration list the primitive operation was\ndeclared in.\n\nThis patch makes it so that if the compiler gets to the end of\nthe declaration list before the type is frozen, it preanalyzes the\nclasswide contract expression, so that the names are resolved in the\nright context.\n\ngcc/ada/\n\n\t* contracts.adb\n\t(Preanalyze_Class_Conditions): New procedure.\n\t(Preanalyze_Condition): Moved out from Merge_Class_Conditions in\n\torder to be spec-visible.\n\t* contracts.ads\n\t(Preanalyze_Class_Conditions): New procedure.\n\t* sem_prag.adb\n\t(Analyze_Pre_Post_Condition_In_Decl_Part): Call\n\tPreanalyze_Class_Conditions when necessary.", "tree": {"sha": "a72c8da1b7fce47af8249b860cd94deebff9711f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a72c8da1b7fce47af8249b860cd94deebff9711f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45656a992eb18bfefe2e6e20d3b425afe945af28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45656a992eb18bfefe2e6e20d3b425afe945af28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45656a992eb18bfefe2e6e20d3b425afe945af28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45656a992eb18bfefe2e6e20d3b425afe945af28/comments", "author": {"login": "ronan-d", "id": 14870758, "node_id": "MDQ6VXNlcjE0ODcwNzU4", "avatar_url": "https://avatars.githubusercontent.com/u/14870758?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ronan-d", "html_url": "https://github.com/ronan-d", "followers_url": "https://api.github.com/users/ronan-d/followers", "following_url": "https://api.github.com/users/ronan-d/following{/other_user}", "gists_url": "https://api.github.com/users/ronan-d/gists{/gist_id}", "starred_url": "https://api.github.com/users/ronan-d/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ronan-d/subscriptions", "organizations_url": "https://api.github.com/users/ronan-d/orgs", "repos_url": "https://api.github.com/users/ronan-d/repos", "events_url": "https://api.github.com/users/ronan-d/events{/privacy}", "received_events_url": "https://api.github.com/users/ronan-d/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48e2e5b4c2f56b9e3497d57d0974c66604e087a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e2e5b4c2f56b9e3497d57d0974c66604e087a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48e2e5b4c2f56b9e3497d57d0974c66604e087a6"}], "stats": {"total": 499, "additions": 267, "deletions": 232}, "files": [{"sha": "218fd66852fdb3baa6e37391d66722a2e69eaa1c", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 249, "deletions": 232, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45656a992eb18bfefe2e6e20d3b425afe945af28/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45656a992eb18bfefe2e6e20d3b425afe945af28/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=45656a992eb18bfefe2e6e20d3b425afe945af28", "patch": "@@ -107,6 +107,11 @@ package body Contracts is\n    --  well as Contract_Cases, Subprogram_Variant, invariants and predicates.\n    --  Body_Id denotes the entity of the subprogram body.\n \n+   procedure Preanalyze_Condition\n+     (Subp : Entity_Id;\n+      Expr : Node_Id);\n+   --  Preanalyze the class-wide condition Expr of Subp\n+\n    procedure Set_Class_Condition\n      (Kind : Condition_Kind;\n       Subp : Entity_Id;\n@@ -4548,242 +4553,10 @@ package body Contracts is\n \n    procedure Merge_Class_Conditions (Spec_Id : Entity_Id) is\n \n-      procedure Preanalyze_Condition\n-        (Subp : Entity_Id;\n-         Expr : Node_Id);\n-      --  Preanalyze the class-wide condition Expr of Subp\n-\n       procedure Process_Inherited_Conditions (Kind : Condition_Kind);\n       --  Collect all inherited class-wide conditions of Spec_Id and merge\n       --  them into one big condition.\n \n-      --------------------------\n-      -- Preanalyze_Condition --\n-      --------------------------\n-\n-      procedure Preanalyze_Condition\n-        (Subp : Entity_Id;\n-         Expr : Node_Id)\n-      is\n-         procedure Clear_Unset_References;\n-         --  Clear unset references on formals of Subp since preanalysis\n-         --  occurs in a place unrelated to the actual code.\n-\n-         procedure Remove_Controlling_Arguments;\n-         --  Traverse Expr and clear the Controlling_Argument of calls to\n-         --  nonabstract functions.\n-\n-         procedure Remove_Formals (Id : Entity_Id);\n-         --  Remove formals from homonym chains and make them not visible\n-\n-         procedure Restore_Original_Selected_Component;\n-         --  Traverse Expr searching for dispatching calls to functions whose\n-         --  original node was a selected component, and replace them with\n-         --  their original node.\n-\n-         ----------------------------\n-         -- Clear_Unset_References --\n-         ----------------------------\n-\n-         procedure Clear_Unset_References is\n-            F : Entity_Id := First_Formal (Subp);\n-\n-         begin\n-            while Present (F) loop\n-               Set_Unset_Reference (F, Empty);\n-               Next_Formal (F);\n-            end loop;\n-         end Clear_Unset_References;\n-\n-         ----------------------------------\n-         -- Remove_Controlling_Arguments --\n-         ----------------------------------\n-\n-         procedure Remove_Controlling_Arguments is\n-            function Remove_Ctrl_Arg (N : Node_Id) return Traverse_Result;\n-            --  Reset the Controlling_Argument of calls to nonabstract\n-            --  function calls.\n-\n-            ---------------------\n-            -- Remove_Ctrl_Arg --\n-            ---------------------\n-\n-            function Remove_Ctrl_Arg (N : Node_Id) return Traverse_Result is\n-            begin\n-               if Nkind (N) = N_Function_Call\n-                 and then Present (Controlling_Argument (N))\n-                 and then not Is_Abstract_Subprogram (Entity (Name (N)))\n-               then\n-                  Set_Controlling_Argument (N, Empty);\n-               end if;\n-\n-               return OK;\n-            end Remove_Ctrl_Arg;\n-\n-            procedure Remove_Ctrl_Args is new Traverse_Proc (Remove_Ctrl_Arg);\n-         begin\n-            Remove_Ctrl_Args (Expr);\n-         end Remove_Controlling_Arguments;\n-\n-         --------------------\n-         -- Remove_Formals --\n-         --------------------\n-\n-         procedure Remove_Formals (Id : Entity_Id) is\n-            F : Entity_Id := First_Formal (Id);\n-\n-         begin\n-            while Present (F) loop\n-               Set_Is_Immediately_Visible (F, False);\n-               Remove_Homonym (F);\n-               Next_Formal (F);\n-            end loop;\n-         end Remove_Formals;\n-\n-         -----------------------------------------\n-         -- Restore_Original_Selected_Component --\n-         -----------------------------------------\n-\n-         procedure Restore_Original_Selected_Component is\n-            Restored_Nodes_List : Elist_Id := No_Elist;\n-\n-            procedure Fix_Parents (N : Node_Id);\n-            --  Traverse the subtree of N fixing the Parent field of all the\n-            --  nodes.\n-\n-            function Restore_Node (N : Node_Id) return Traverse_Result;\n-            --  Process dispatching calls to functions whose original node was\n-            --  a selected component, and replace them with their original\n-            --  node. Restored nodes are stored in the Restored_Nodes_List\n-            --  to fix the parent fields of their subtrees in a separate\n-            --  tree traversal.\n-\n-            -----------------\n-            -- Fix_Parents --\n-            -----------------\n-\n-            procedure Fix_Parents (N : Node_Id) is\n-\n-               function Fix_Parent\n-                 (Parent_Node : Node_Id;\n-                  Node        : Node_Id) return Traverse_Result;\n-               --  Process a single node\n-\n-               ----------------\n-               -- Fix_Parent --\n-               ----------------\n-\n-               function Fix_Parent\n-                 (Parent_Node : Node_Id;\n-                  Node        : Node_Id) return Traverse_Result\n-               is\n-                  Par : constant Node_Id := Parent (Node);\n-\n-               begin\n-                  if Par /= Parent_Node then\n-                     pragma Assert (not Is_List_Member (Node));\n-                     Set_Parent (Node, Parent_Node);\n-                  end if;\n-\n-                  return OK;\n-               end Fix_Parent;\n-\n-               procedure Fix_Parents is\n-                  new Traverse_Proc_With_Parent (Fix_Parent);\n-\n-            begin\n-               Fix_Parents (N);\n-            end Fix_Parents;\n-\n-            ------------------\n-            -- Restore_Node --\n-            ------------------\n-\n-            function Restore_Node (N : Node_Id) return Traverse_Result is\n-            begin\n-               if Nkind (N) = N_Function_Call\n-                 and then Nkind (Original_Node (N)) = N_Selected_Component\n-                 and then Is_Dispatching_Operation (Entity (Name (N)))\n-               then\n-                  Rewrite (N, Original_Node (N));\n-                  Set_Original_Node (N, N);\n-\n-                  --  Save the restored node in the Restored_Nodes_List to fix\n-                  --  the parent fields of their subtrees in a separate tree\n-                  --  traversal.\n-\n-                  Append_New_Elmt (N, Restored_Nodes_List);\n-               end if;\n-\n-               return OK;\n-            end Restore_Node;\n-\n-            procedure Restore_Nodes is new Traverse_Proc (Restore_Node);\n-\n-         --  Start of processing for Restore_Original_Selected_Component\n-\n-         begin\n-            Restore_Nodes (Expr);\n-\n-            --  After restoring the original node we must fix the decoration\n-            --  of the Parent attribute to ensure tree consistency; required\n-            --  because when the class-wide condition is inherited, calls to\n-            --  New_Copy_Tree will perform copies of this subtree, and formal\n-            --  occurrences with wrong Parent field cannot be mapped to the\n-            --  new formals.\n-\n-            if Present (Restored_Nodes_List) then\n-               declare\n-                  Elmt : Elmt_Id := First_Elmt (Restored_Nodes_List);\n-\n-               begin\n-                  while Present (Elmt) loop\n-                     Fix_Parents (Node (Elmt));\n-                     Next_Elmt (Elmt);\n-                  end loop;\n-               end;\n-            end if;\n-         end Restore_Original_Selected_Component;\n-\n-      --  Start of processing for Preanalyze_Condition\n-\n-      begin\n-         pragma Assert (Present (Expr));\n-         pragma Assert (Inside_Class_Condition_Preanalysis = False);\n-\n-         Push_Scope (Subp);\n-         Install_Formals (Subp);\n-         Inside_Class_Condition_Preanalysis := True;\n-\n-         Preanalyze_Spec_Expression (Expr, Standard_Boolean);\n-\n-         Inside_Class_Condition_Preanalysis := False;\n-         Remove_Formals (Subp);\n-         Pop_Scope;\n-\n-         --  If this preanalyzed condition has occurrences of dispatching calls\n-         --  using the Object.Operation notation, during preanalysis such calls\n-         --  are rewritten as dispatching function calls; if at later stages\n-         --  this condition is inherited we must have restored the original\n-         --  selected-component node to ensure that the preanalysis of the\n-         --  inherited condition rewrites these dispatching calls in the\n-         --  correct context to avoid reporting spurious errors.\n-\n-         Restore_Original_Selected_Component;\n-\n-         --  Traverse Expr and clear the Controlling_Argument of calls to\n-         --  nonabstract functions. Required since the preanalyzed condition\n-         --  is not yet installed on its definite context and will be cloned\n-         --  and extended in derivations with additional conditions.\n-\n-         Remove_Controlling_Arguments;\n-\n-         --  Clear also attribute Unset_Reference; again because preanalysis\n-         --  occurs in a place unrelated to the actual code.\n-\n-         Clear_Unset_References;\n-      end Preanalyze_Condition;\n-\n       ----------------------------------\n       -- Process_Inherited_Conditions --\n       ----------------------------------\n@@ -5116,6 +4889,250 @@ package body Contracts is\n       end loop;\n    end Merge_Class_Conditions;\n \n+   ---------------------------------\n+   -- Preanalyze_Class_Conditions --\n+   ---------------------------------\n+\n+   procedure Preanalyze_Class_Conditions (Spec_Id : Entity_Id) is\n+      Cond : Node_Id;\n+\n+   begin\n+      for Kind in Condition_Kind loop\n+         Cond := Class_Condition (Kind, Spec_Id);\n+\n+         if Present (Cond) then\n+            Preanalyze_Condition (Spec_Id, Cond);\n+         end if;\n+      end loop;\n+   end Preanalyze_Class_Conditions;\n+\n+   --------------------------\n+   -- Preanalyze_Condition --\n+   --------------------------\n+\n+   procedure Preanalyze_Condition\n+     (Subp : Entity_Id;\n+      Expr : Node_Id)\n+   is\n+      procedure Clear_Unset_References;\n+      --  Clear unset references on formals of Subp since preanalysis\n+      --  occurs in a place unrelated to the actual code.\n+\n+      procedure Remove_Controlling_Arguments;\n+      --  Traverse Expr and clear the Controlling_Argument of calls to\n+      --  nonabstract functions.\n+\n+      procedure Remove_Formals (Id : Entity_Id);\n+      --  Remove formals from homonym chains and make them not visible\n+\n+      procedure Restore_Original_Selected_Component;\n+      --  Traverse Expr searching for dispatching calls to functions whose\n+      --  original node was a selected component, and replace them with\n+      --  their original node.\n+\n+      ----------------------------\n+      -- Clear_Unset_References --\n+      ----------------------------\n+\n+      procedure Clear_Unset_References is\n+         F : Entity_Id := First_Formal (Subp);\n+\n+      begin\n+         while Present (F) loop\n+            Set_Unset_Reference (F, Empty);\n+            Next_Formal (F);\n+         end loop;\n+      end Clear_Unset_References;\n+\n+      ----------------------------------\n+      -- Remove_Controlling_Arguments --\n+      ----------------------------------\n+\n+      procedure Remove_Controlling_Arguments is\n+         function Remove_Ctrl_Arg (N : Node_Id) return Traverse_Result;\n+         --  Reset the Controlling_Argument of calls to nonabstract\n+         --  function calls.\n+\n+         ---------------------\n+         -- Remove_Ctrl_Arg --\n+         ---------------------\n+\n+         function Remove_Ctrl_Arg (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Nkind (N) = N_Function_Call\n+              and then Present (Controlling_Argument (N))\n+              and then not Is_Abstract_Subprogram (Entity (Name (N)))\n+            then\n+               Set_Controlling_Argument (N, Empty);\n+            end if;\n+\n+            return OK;\n+         end Remove_Ctrl_Arg;\n+\n+         procedure Remove_Ctrl_Args is new Traverse_Proc (Remove_Ctrl_Arg);\n+      begin\n+         Remove_Ctrl_Args (Expr);\n+      end Remove_Controlling_Arguments;\n+\n+      --------------------\n+      -- Remove_Formals --\n+      --------------------\n+\n+      procedure Remove_Formals (Id : Entity_Id) is\n+         F : Entity_Id := First_Formal (Id);\n+\n+      begin\n+         while Present (F) loop\n+            Set_Is_Immediately_Visible (F, False);\n+            Remove_Homonym (F);\n+            Next_Formal (F);\n+         end loop;\n+      end Remove_Formals;\n+\n+      -----------------------------------------\n+      -- Restore_Original_Selected_Component --\n+      -----------------------------------------\n+\n+      procedure Restore_Original_Selected_Component is\n+         Restored_Nodes_List : Elist_Id := No_Elist;\n+\n+         procedure Fix_Parents (N : Node_Id);\n+         --  Traverse the subtree of N fixing the Parent field of all the\n+         --  nodes.\n+\n+         function Restore_Node (N : Node_Id) return Traverse_Result;\n+         --  Process dispatching calls to functions whose original node was\n+         --  a selected component, and replace them with their original\n+         --  node. Restored nodes are stored in the Restored_Nodes_List\n+         --  to fix the parent fields of their subtrees in a separate\n+         --  tree traversal.\n+\n+         -----------------\n+         -- Fix_Parents --\n+         -----------------\n+\n+         procedure Fix_Parents (N : Node_Id) is\n+\n+            function Fix_Parent\n+              (Parent_Node : Node_Id;\n+               Node        : Node_Id) return Traverse_Result;\n+            --  Process a single node\n+\n+            ----------------\n+            -- Fix_Parent --\n+            ----------------\n+\n+            function Fix_Parent\n+              (Parent_Node : Node_Id;\n+               Node        : Node_Id) return Traverse_Result\n+            is\n+               Par : constant Node_Id := Parent (Node);\n+\n+            begin\n+               if Par /= Parent_Node then\n+                  pragma Assert (not Is_List_Member (Node));\n+                  Set_Parent (Node, Parent_Node);\n+               end if;\n+\n+               return OK;\n+            end Fix_Parent;\n+\n+            procedure Fix_Parents is\n+               new Traverse_Proc_With_Parent (Fix_Parent);\n+\n+         begin\n+            Fix_Parents (N);\n+         end Fix_Parents;\n+\n+         ------------------\n+         -- Restore_Node --\n+         ------------------\n+\n+         function Restore_Node (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Nkind (N) = N_Function_Call\n+              and then Nkind (Original_Node (N)) = N_Selected_Component\n+              and then Is_Dispatching_Operation (Entity (Name (N)))\n+            then\n+               Rewrite (N, Original_Node (N));\n+               Set_Original_Node (N, N);\n+\n+               --  Save the restored node in the Restored_Nodes_List to fix\n+               --  the parent fields of their subtrees in a separate tree\n+               --  traversal.\n+\n+               Append_New_Elmt (N, Restored_Nodes_List);\n+            end if;\n+\n+            return OK;\n+         end Restore_Node;\n+\n+         procedure Restore_Nodes is new Traverse_Proc (Restore_Node);\n+\n+      --  Start of processing for Restore_Original_Selected_Component\n+\n+      begin\n+         Restore_Nodes (Expr);\n+\n+         --  After restoring the original node we must fix the decoration\n+         --  of the Parent attribute to ensure tree consistency; required\n+         --  because when the class-wide condition is inherited, calls to\n+         --  New_Copy_Tree will perform copies of this subtree, and formal\n+         --  occurrences with wrong Parent field cannot be mapped to the\n+         --  new formals.\n+\n+         if Present (Restored_Nodes_List) then\n+            declare\n+               Elmt : Elmt_Id := First_Elmt (Restored_Nodes_List);\n+\n+            begin\n+               while Present (Elmt) loop\n+                  Fix_Parents (Node (Elmt));\n+                  Next_Elmt (Elmt);\n+               end loop;\n+            end;\n+         end if;\n+      end Restore_Original_Selected_Component;\n+\n+   --  Start of processing for Preanalyze_Condition\n+\n+   begin\n+      pragma Assert (Present (Expr));\n+      pragma Assert (Inside_Class_Condition_Preanalysis = False);\n+\n+      Push_Scope (Subp);\n+      Install_Formals (Subp);\n+      Inside_Class_Condition_Preanalysis := True;\n+\n+      Preanalyze_Spec_Expression (Expr, Standard_Boolean);\n+\n+      Inside_Class_Condition_Preanalysis := False;\n+      Remove_Formals (Subp);\n+      Pop_Scope;\n+\n+      --  If this preanalyzed condition has occurrences of dispatching calls\n+      --  using the Object.Operation notation, during preanalysis such calls\n+      --  are rewritten as dispatching function calls; if at later stages\n+      --  this condition is inherited we must have restored the original\n+      --  selected-component node to ensure that the preanalysis of the\n+      --  inherited condition rewrites these dispatching calls in the\n+      --  correct context to avoid reporting spurious errors.\n+\n+      Restore_Original_Selected_Component;\n+\n+      --  Traverse Expr and clear the Controlling_Argument of calls to\n+      --  nonabstract functions. Required since the preanalyzed condition\n+      --  is not yet installed on its definite context and will be cloned\n+      --  and extended in derivations with additional conditions.\n+\n+      Remove_Controlling_Arguments;\n+\n+      --  Clear also attribute Unset_Reference; again because preanalysis\n+      --  occurs in a place unrelated to the actual code.\n+\n+      Clear_Unset_References;\n+   end Preanalyze_Condition;\n+\n    ----------------------------------------\n    -- Save_Global_References_In_Contract --\n    ----------------------------------------"}, {"sha": "ae6355ef410b7abedff3981804dc1f4c3d27dbd7", "filename": "gcc/ada/contracts.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45656a992eb18bfefe2e6e20d3b425afe945af28/gcc%2Fada%2Fcontracts.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45656a992eb18bfefe2e6e20d3b425afe945af28/gcc%2Fada%2Fcontracts.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.ads?ref=45656a992eb18bfefe2e6e20d3b425afe945af28", "patch": "@@ -276,6 +276,10 @@ package Contracts is\n    --  which are invoked from the caller side; they are also used to build\n    --  the dispatch-table wrapper (DTW), if required.\n \n+   procedure Preanalyze_Class_Conditions (Spec_Id : Entity_Id);\n+   --  Preanalyze class-wide pre-/postconditions of the given subprogram\n+   --  specification.\n+\n    procedure Process_Class_Conditions_At_Freeze_Point (Typ : Entity_Id);\n    --  Merge, preanalyze, and check class-wide pre/postconditions of Typ\n    --  primitives."}, {"sha": "615c6d2110c6dfe6273638b07f151f9df713bf4a", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45656a992eb18bfefe2e6e20d3b425afe945af28/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45656a992eb18bfefe2e6e20d3b425afe945af28/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=45656a992eb18bfefe2e6e20d3b425afe945af28", "patch": "@@ -26201,6 +26201,20 @@ package body Sem_Prag is\n       Check_Postcondition_Use_In_Inlined_Subprogram (N, Spec_Id);\n       Set_Is_Analyzed_Pragma (N);\n \n+      --  If the subprogram is frozen then its class-wide pre- and post-\n+      --  conditions have been preanalyzed (see Merge_Class_Conditions);\n+      --  otherwise they must be preanalyzed now to ensure the correct\n+      --  visibility of their referenced entities. This scenario occurs\n+      --  when the subprogram is defined in a nested package (since the\n+      --  end of the package does not cause freezing).\n+\n+      if Class_Present (N)\n+        and then Is_Dispatching_Operation (Spec_Id)\n+        and then not Is_Frozen (Spec_Id)\n+      then\n+         Preanalyze_Class_Conditions (Spec_Id);\n+      end if;\n+\n       Restore_Ghost_Region (Saved_GM, Saved_IGR);\n    end Analyze_Pre_Post_Condition_In_Decl_Part;\n "}]}