{"sha": "c838c4025c042f455c06f9d202c80a510a52ec63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgzOGM0MDI1YzA0MmY0NTVjMDZmOWQyMDJjODBhNTEwYTUyZWM2Mw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-09-05T14:51:09Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-09-05T14:51:09Z"}, "message": "Use rtx_insn for more scheduler things, plus CONST_CAST_RTX_INSN\n\ngcc/ChangeLog:\n2014-09-05  David Malcolm  <dmalcolm@redhat.com>\n\n\t* sched-deps.c (sched_get_condition_with_rev_uncached): Strengthen\n\tparam \"insn\" from const_rtx to const rtx_insn *.\n\t(sched_get_reverse_condition_uncached): Likewise.\n\t(sched_get_condition_with_rev): Likewise.\n\t(sched_has_condition_p): Likewise.\n\t(sched_insns_conditions_mutex_p): Likewise for both params.\n\t(sched_insn_is_legitimate_for_speculation_p): Likewise for param\n\t\"insn\"; convert use of CONST_CAST_RTX to CONST_CAST_RTX_INSN.\n\t(setup_insn_reg_uses): Move local \"list\" to be more tightly\n\tscoped, strengthening it from an rtx to an rtx_insn_list *.  Use\n\tits methods for clarity and type-safety.\n\t(sched_analyze_1): Strengthen local \"pending\" from rtx to\n\trtx_insn_list *, and local \"pending_mem\" from rtx to\n\trtx_expr_list *.  Use methods of each for clarity and type-safety.\n\t(sched_analyze_2): Likewise.\n\t(sched_analyze_insn): Likewise.\n\n\t* sched-int.h (sched_get_reverse_condition_uncached): Strengthen\n\tparam from const_rtx to const rtx_insn *.\n\t(sched_insns_conditions_mutex_p): Likewise for both params.\n\t(sched_insn_is_legitimate_for_speculation_p): Likewise for first\n\tparam.\n\n\t* system.h (CONST_CAST_RTX_INSN): New macro.\n\nFrom-SVN: r214967", "tree": {"sha": "bdd05296616190f64ce7cfbb25db2e8e21c5b630", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdd05296616190f64ce7cfbb25db2e8e21c5b630"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c838c4025c042f455c06f9d202c80a510a52ec63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c838c4025c042f455c06f9d202c80a510a52ec63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c838c4025c042f455c06f9d202c80a510a52ec63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c838c4025c042f455c06f9d202c80a510a52ec63/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c9b6043f9e53d7bfb394151eee5a7b25918364b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c9b6043f9e53d7bfb394151eee5a7b25918364b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c9b6043f9e53d7bfb394151eee5a7b25918364b"}], "stats": {"total": 129, "additions": 80, "deletions": 49}, "files": [{"sha": "2e48eb76b91cb7cd5960960d3d6eb9cb055a7bd9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c838c4025c042f455c06f9d202c80a510a52ec63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c838c4025c042f455c06f9d202c80a510a52ec63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c838c4025c042f455c06f9d202c80a510a52ec63", "patch": "@@ -1,3 +1,30 @@\n+2014-09-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* sched-deps.c (sched_get_condition_with_rev_uncached): Strengthen\n+\tparam \"insn\" from const_rtx to const rtx_insn *.\n+\t(sched_get_reverse_condition_uncached): Likewise.\n+\t(sched_get_condition_with_rev): Likewise.\n+\t(sched_has_condition_p): Likewise.\n+\t(sched_insns_conditions_mutex_p): Likewise for both params.\n+\t(sched_insn_is_legitimate_for_speculation_p): Likewise for param\n+\t\"insn\"; conver use of CONST_CAST_RTX to CONST_CAST_RTX_INSN.\n+\t(setup_insn_reg_uses): Move local \"list\" to be more tightly\n+\tscoped, strengthening it from an rtx to an rtx_insn_list *.  Use\n+\tits methods for clarity and type-safety.\n+\t(sched_analyze_1): Strengthen local \"pending\" from rtx to\n+\trtx_insn_list *, and local \"pending_mem\" from rtx to\n+\trtx_expr_list *.  Use methods of each for clarity and type-safety.\n+\t(sched_analyze_2): Likewise.\n+\t(sched_analyze_insn): Likewise.\n+\n+\t* sched-int.h (sched_get_reverse_condition_uncached): Strengthen\n+\tparam from const_rtx to const rtx_insn *.\n+\t(sched_insns_conditions_mutex_p): Likewise for both params.\n+\t(sched_insn_is_legitimate_for_speculation_p): Likewise for first\n+\tparam.\n+\n+\t* system.h (CONST_CAST_RTX_INSN): New macro.\n+\n 2014-09-05  David Malcolm  <dmalcolm@redhat.com>\n \n \t* recog.c (peep2_attempt): Strengthen return type from rtx to"}, {"sha": "cceff6dac840d8b9d112cd597f2d9ab10705ca0d", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c838c4025c042f455c06f9d202c80a510a52ec63/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c838c4025c042f455c06f9d202c80a510a52ec63/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=c838c4025c042f455c06f9d202c80a510a52ec63", "patch": "@@ -496,7 +496,7 @@ static void sched_analyze_1 (struct deps_desc *, rtx, rtx_insn *);\n static void sched_analyze_2 (struct deps_desc *, rtx, rtx_insn *);\n static void sched_analyze_insn (struct deps_desc *, rtx, rtx_insn *);\n \n-static bool sched_has_condition_p (const_rtx);\n+static bool sched_has_condition_p (const rtx_insn *);\n static int conditions_mutex_p (const_rtx, const_rtx, bool, bool);\n \n static enum DEPS_ADJUST_RESULT maybe_add_or_update_dep_1 (dep_t, bool,\n@@ -528,7 +528,7 @@ deps_may_trap_p (const_rtx mem)\n    it is set to TRUE when the returned comparison should be reversed\n    to get the actual condition.  */\n static rtx\n-sched_get_condition_with_rev_uncached (const_rtx insn, bool *rev)\n+sched_get_condition_with_rev_uncached (const rtx_insn *insn, bool *rev)\n {\n   rtx pat = PATTERN (insn);\n   rtx src;\n@@ -567,7 +567,7 @@ sched_get_condition_with_rev_uncached (const_rtx insn, bool *rev)\n    find such a condition.  The caller should make a copy of the condition\n    before using it.  */\n rtx\n-sched_get_reverse_condition_uncached (const_rtx insn)\n+sched_get_reverse_condition_uncached (const rtx_insn *insn)\n {\n   bool rev;\n   rtx cond = sched_get_condition_with_rev_uncached (insn, &rev);\n@@ -587,7 +587,7 @@ sched_get_reverse_condition_uncached (const_rtx insn)\n    We only do actual work the first time we come here for an insn; the\n    results are cached in INSN_CACHED_COND and INSN_REVERSE_COND.  */\n static rtx\n-sched_get_condition_with_rev (const_rtx insn, bool *rev)\n+sched_get_condition_with_rev (const rtx_insn *insn, bool *rev)\n {\n   bool tmp;\n \n@@ -620,7 +620,7 @@ sched_get_condition_with_rev (const_rtx insn, bool *rev)\n \n /* True when we can find a condition under which INSN is executed.  */\n static bool\n-sched_has_condition_p (const_rtx insn)\n+sched_has_condition_p (const rtx_insn *insn)\n {\n   return !! sched_get_condition_with_rev (insn, NULL);\n }\n@@ -646,7 +646,7 @@ conditions_mutex_p (const_rtx cond1, const_rtx cond2, bool rev1, bool rev2)\n /* Return true if insn1 and insn2 can never depend on one another because\n    the conditions under which they are executed are mutually exclusive.  */\n bool\n-sched_insns_conditions_mutex_p (const_rtx insn1, const_rtx insn2)\n+sched_insns_conditions_mutex_p (const rtx_insn *insn1, const rtx_insn *insn2)\n {\n   rtx cond1, cond2;\n   bool rev1 = false, rev2 = false;\n@@ -673,7 +673,7 @@ sched_insns_conditions_mutex_p (const_rtx insn1, const_rtx insn2)\n \n /* Return true if INSN can potentially be speculated with type DS.  */\n bool\n-sched_insn_is_legitimate_for_speculation_p (const_rtx insn, ds_t ds)\n+sched_insn_is_legitimate_for_speculation_p (const rtx_insn *insn, ds_t ds)\n {\n   if (HAS_INTERNAL_DEP (insn))\n     return false;\n@@ -684,7 +684,7 @@ sched_insn_is_legitimate_for_speculation_p (const_rtx insn, ds_t ds)\n   if (SCHED_GROUP_P (insn))\n     return false;\n \n-  if (IS_SPECULATION_CHECK_P (CONST_CAST_RTX (insn)))\n+  if (IS_SPECULATION_CHECK_P (CONST_CAST_RTX_INSN (insn)))\n     return false;\n \n   if (side_effects_p (PATTERN (insn)))\n@@ -1970,7 +1970,6 @@ setup_insn_reg_uses (struct deps_desc *deps, rtx_insn *insn)\n {\n   unsigned i;\n   reg_set_iterator rsi;\n-  rtx list;\n   struct reg_use_data *use, *use2, *next;\n   struct deps_reg *reg_last;\n \n@@ -1991,9 +1990,9 @@ setup_insn_reg_uses (struct deps_desc *deps, rtx_insn *insn)\n       reg_last = &deps->reg_last[i];\n \n       /* Create the cycle list of uses.  */\n-      for (list = reg_last->uses; list; list = XEXP (list, 1))\n+      for (rtx_insn_list *list = reg_last->uses; list; list = list->next ())\n \t{\n-\t  use2 = create_insn_reg_use (i, as_a <rtx_insn *> (XEXP (list, 0)));\n+\t  use2 = create_insn_reg_use (i, list->insn ());\n \t  next = use->next_regno_use;\n \t  use->next_regno_use = use2;\n \t  use2->next_regno_use = next;\n@@ -2506,33 +2505,34 @@ sched_analyze_1 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \t}\n       else\n \t{\n-\t  rtx pending, pending_mem;\n+\t  rtx_insn_list *pending;\n+\t  rtx_expr_list *pending_mem;\n \n \t  pending = deps->pending_read_insns;\n \t  pending_mem = deps->pending_read_mems;\n \t  while (pending)\n \t    {\n-\t      if (anti_dependence (XEXP (pending_mem, 0), t)\n-\t\t  && ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n-\t\tnote_mem_dep (t, XEXP (pending_mem, 0), as_a <rtx_insn *> (XEXP (pending, 0)),\n+\t      if (anti_dependence (pending_mem->element (), t)\n+\t\t  && ! sched_insns_conditions_mutex_p (insn, pending->insn ()))\n+\t\tnote_mem_dep (t, pending_mem->element (), pending->insn (),\n \t\t\t      DEP_ANTI);\n \n-\t      pending = XEXP (pending, 1);\n-\t      pending_mem = XEXP (pending_mem, 1);\n+\t      pending = pending->next ();\n+\t      pending_mem = pending_mem->next ();\n \t    }\n \n \t  pending = deps->pending_write_insns;\n \t  pending_mem = deps->pending_write_mems;\n \t  while (pending)\n \t    {\n-\t      if (output_dependence (XEXP (pending_mem, 0), t)\n-\t\t  && ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n-\t\tnote_mem_dep (t, XEXP (pending_mem, 0),\n-\t\t\t      as_a <rtx_insn *> (XEXP (pending, 0)),\n+\t      if (output_dependence (pending_mem->element (), t)\n+\t\t  && ! sched_insns_conditions_mutex_p (insn, pending->insn ()))\n+\t\tnote_mem_dep (t, pending_mem->element (),\n+\t\t\t      pending->insn (),\n \t\t\t      DEP_OUTPUT);\n \n-\t      pending = XEXP (pending, 1);\n-\t      pending_mem = XEXP (pending_mem, 1);\n+\t      pending = pending->next ();\n+\t      pending_mem = pending_mem-> next ();\n \t    }\n \n \t  add_dependence_list (insn, deps->last_pending_memory_flush, 1,\n@@ -2635,7 +2635,8 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n       {\n \t/* Reading memory.  */\n \trtx u;\n-\trtx pending, pending_mem;\n+\trtx_insn_list *pending;\n+\trtx_expr_list *pending_mem;\n \trtx t = x;\n \n \tif (sched_deps_info->use_cselib)\n@@ -2657,31 +2658,31 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \t    pending_mem = deps->pending_read_mems;\n \t    while (pending)\n \t      {\n-\t\tif (read_dependence (XEXP (pending_mem, 0), t)\n+\t\tif (read_dependence (pending_mem->element (), t)\n \t\t    && ! sched_insns_conditions_mutex_p (insn,\n-\t\t\t\t\t\t\t XEXP (pending, 0)))\n-\t\t  note_mem_dep (t, XEXP (pending_mem, 0),\n-\t\t\t\tas_a <rtx_insn *> (XEXP (pending, 0)),\n+\t\t\t\t\t\t\t pending->insn ()))\n+\t\t  note_mem_dep (t, pending_mem->element (),\n+\t\t\t\tpending->insn (),\n \t\t\t\tDEP_ANTI);\n \n-\t\tpending = XEXP (pending, 1);\n-\t\tpending_mem = XEXP (pending_mem, 1);\n+\t\tpending = pending->next ();\n+\t\tpending_mem = pending_mem->next ();\n \t      }\n \n \t    pending = deps->pending_write_insns;\n \t    pending_mem = deps->pending_write_mems;\n \t    while (pending)\n \t      {\n-\t\tif (true_dependence (XEXP (pending_mem, 0), VOIDmode, t)\n+\t\tif (true_dependence (pending_mem->element (), VOIDmode, t)\n \t\t    && ! sched_insns_conditions_mutex_p (insn,\n-\t\t\t\t\t\t\t XEXP (pending, 0)))\n-\t\t  note_mem_dep (t, XEXP (pending_mem, 0),\n-\t\t\t\tas_a <rtx_insn *> (XEXP (pending, 0)),\n+\t\t\t\t\t\t\t pending->insn ()))\n+\t\t  note_mem_dep (t, pending_mem->element (),\n+\t\t\t\tpending->insn (),\n \t\t\t\tsched_deps_info->generate_spec_deps\n \t\t\t\t? BEGIN_DATA | DEP_TRUE : DEP_TRUE);\n \n-\t\tpending = XEXP (pending, 1);\n-\t\tpending_mem = XEXP (pending_mem, 1);\n+\t\tpending = pending->next ();\n+\t\tpending_mem = pending_mem->next ();\n \t      }\n \n \t    for (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n@@ -2998,7 +2999,8 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \treg_pending_barrier = MOVE_BARRIER;\n       else\n \t{\n-\t  rtx pending, pending_mem;\n+\t  rtx_insn_list *pending;\n+\t  rtx_expr_list *pending_mem;\n \n           if (sched_deps_info->compute_jump_reg_dependencies)\n             {\n@@ -3026,23 +3028,23 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \t  pending_mem = deps->pending_write_mems;\n \t  while (pending)\n \t    {\n-\t      if (! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n-\t\tadd_dependence (insn, as_a <rtx_insn *> (XEXP (pending, 0)),\n+\t      if (! sched_insns_conditions_mutex_p (insn, pending->insn ()))\n+\t\tadd_dependence (insn, pending->insn (),\n \t\t\t\tREG_DEP_OUTPUT);\n-\t      pending = XEXP (pending, 1);\n-\t      pending_mem = XEXP (pending_mem, 1);\n+\t      pending = pending->next ();\n+\t      pending_mem = pending_mem->next ();\n \t    }\n \n \t  pending = deps->pending_read_insns;\n \t  pending_mem = deps->pending_read_mems;\n \t  while (pending)\n \t    {\n-\t      if (MEM_VOLATILE_P (XEXP (pending_mem, 0))\n-\t\t  && ! sched_insns_conditions_mutex_p (insn, XEXP (pending, 0)))\n-\t\tadd_dependence (insn, as_a <rtx_insn *> (XEXP (pending, 0)),\n+\t      if (MEM_VOLATILE_P (pending_mem->element ())\n+\t\t  && ! sched_insns_conditions_mutex_p (insn, pending->insn ()))\n+\t\tadd_dependence (insn, pending->insn (),\n \t\t\t\tREG_DEP_OUTPUT);\n-\t      pending = XEXP (pending, 1);\n-\t      pending_mem = XEXP (pending_mem, 1);\n+\t      pending = pending->next ();\n+\t      pending_mem = pending_mem->next ();\n \t    }\n \n \t  add_dependence_list (insn, deps->last_pending_memory_flush, 1,"}, {"sha": "dda394eb9c8336f2559ec3d20ece1e768d6fb5c0", "filename": "gcc/sched-int.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c838c4025c042f455c06f9d202c80a510a52ec63/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c838c4025c042f455c06f9d202c80a510a52ec63/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=c838c4025c042f455c06f9d202c80a510a52ec63", "patch": "@@ -1291,9 +1291,10 @@ extern struct sched_deps_info_def *sched_deps_info;\n \n \n /* Functions in sched-deps.c.  */\n-extern rtx sched_get_reverse_condition_uncached (const_rtx);\n-extern bool sched_insns_conditions_mutex_p (const_rtx, const_rtx);\n-extern bool sched_insn_is_legitimate_for_speculation_p (const_rtx, ds_t);\n+extern rtx sched_get_reverse_condition_uncached (const rtx_insn *);\n+extern bool sched_insns_conditions_mutex_p (const rtx_insn *,\n+\t\t\t\t\t    const rtx_insn *);\n+extern bool sched_insn_is_legitimate_for_speculation_p (const rtx_insn *, ds_t);\n extern void add_dependence (rtx_insn *, rtx_insn *, enum reg_note);\n extern void sched_analyze (struct deps_desc *, rtx_insn *, rtx_insn *);\n extern void init_deps (struct deps_desc *, bool);"}, {"sha": "a2c8f7767cde1e0a9eae5313d0f6b0e500ed8911", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c838c4025c042f455c06f9d202c80a510a52ec63/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c838c4025c042f455c06f9d202c80a510a52ec63/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=c838c4025c042f455c06f9d202c80a510a52ec63", "patch": "@@ -1034,6 +1034,7 @@ helper_const_non_const_cast (const char *p)\n #define CONST_CAST(TYPE,X) CONST_CAST2 (TYPE, const TYPE, (X))\n #define CONST_CAST_TREE(X) CONST_CAST (union tree_node *, (X))\n #define CONST_CAST_RTX(X) CONST_CAST (struct rtx_def *, (X))\n+#define CONST_CAST_RTX_INSN(X) CONST_CAST (struct rtx_insn *, (X))\n #define CONST_CAST_BB(X) CONST_CAST (struct basic_block_def *, (X))\n #define CONST_CAST_GIMPLE(X) CONST_CAST (struct gimple_statement_base *, (X))\n "}]}