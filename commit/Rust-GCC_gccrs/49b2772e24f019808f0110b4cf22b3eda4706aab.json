{"sha": "49b2772e24f019808f0110b4cf22b3eda4706aab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDliMjc3MmUyNGYwMTk4MDhmMDExMGI0Y2YyMmIzZWRhNDcwNmFhYg==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-11-28T09:58:37Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-11-28T09:58:37Z"}, "message": "extend.texi (AVR Built-in Functions): Add documentation for __builtin_avr_map8 and __builtin_avr_map16.\n\n\t* doc/extend.texi (AVR Built-in Functions): Add documentation for\n\t__builtin_avr_map8 and __builtin_avr_map16.\n\t* config/avr/avr.md: Document new %t and %T asm output codes.\n\t(define_c_enum \"unspec\"): Add UNSPEC_MAP_BITS.\n\t(adjust_len): Add map_bits.\n\t(map_bitsqi, map_bitshi): New insns.\n\t* config/avr/avr-protos.h (avr_out_map_bits): New.\n\t* config/avr/avr-protos.c (print_operand): Implement %t and %T.\n\t(adjust_insn_length): Handle ADJUST_LEN_MAP_BITS.\n\t(avr_double_int_push_digit): New function.\n\t(avr_map, avr_revert_map, avr_swap_map, avr_id_map): New functions.\n\t(avr_sig_map, avr_map_hamming_byte): New functions.\n\t(avr_out_swap_bits, avr_out_revert_bits, avr_move_bits,\n\tavr_out_map_bits): New functions.\n\t(enum avr_builtin_id): Add AVR_BUILTIN_MAP8, AVR_BUILTIN_MAP16.\n\t(avr_init_builtins): Populate __builtin_avr_map8, __builtin_avr_map16.\n\t(bdesc_2arg): Add __builtin_avr_map8, __builtin_avr_map16 ...\n\t(avr_expand_builtin): ...and expand them.\n\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): New built-in defines:\n\t__BUILTIN_AVR_MAP8, __BUILTIN_AVR_MAP16.\n\nFrom-SVN: r181773", "tree": {"sha": "60c91b070672ca210ed04345bdd844b80e1b7da3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60c91b070672ca210ed04345bdd844b80e1b7da3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49b2772e24f019808f0110b4cf22b3eda4706aab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49b2772e24f019808f0110b4cf22b3eda4706aab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49b2772e24f019808f0110b4cf22b3eda4706aab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49b2772e24f019808f0110b4cf22b3eda4706aab/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "737087cbc8393b1a95a871b15a917872f1328c6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/737087cbc8393b1a95a871b15a917872f1328c6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/737087cbc8393b1a95a871b15a917872f1328c6b"}], "stats": {"total": 517, "additions": 512, "deletions": 5}, "files": [{"sha": "d37a4411fb6575e7e8f27b51dd1494ef1175a9cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b2772e24f019808f0110b4cf22b3eda4706aab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b2772e24f019808f0110b4cf22b3eda4706aab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49b2772e24f019808f0110b4cf22b3eda4706aab", "patch": "@@ -1,3 +1,27 @@\n+2011-11-28  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* doc/extend.texi (AVR Built-in Functions): Add documentation for\n+\t__builtin_avr_map8 and __builtin_avr_map16.\n+\n+\t* config/avr/avr.md: Document new %t and %T asm output codes.\n+\t(define_c_enum \"unspec\"): Add UNSPEC_MAP_BITS.\n+\t(adjust_len): Add map_bits.\n+\t(map_bitsqi, map_bitshi): New insns.\n+\t* config/avr/avr-protos.h (avr_out_map_bits): New.\n+\t* config/avr/avr-protos.c (print_operand): Implement %t and %T.\n+\t(adjust_insn_length): Handle ADJUST_LEN_MAP_BITS.\n+\t(avr_double_int_push_digit): New function.\n+\t(avr_map, avr_revert_map, avr_swap_map, avr_id_map): New functions.\n+\t(avr_sig_map, avr_map_hamming_byte): New functions.\n+\t(avr_out_swap_bits, avr_out_revert_bits, avr_move_bits,\n+\tavr_out_map_bits): New functions.\n+\t(enum avr_builtin_id): Add AVR_BUILTIN_MAP8, AVR_BUILTIN_MAP16.\n+\t(avr_init_builtins): Populate __builtin_avr_map8, __builtin_avr_map16.\n+\t(bdesc_2arg): Add __builtin_avr_map8, __builtin_avr_map16 ...\n+\t(avr_expand_builtin): ...and expand them.\n+\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): New built-in defines:\n+\t__BUILTIN_AVR_MAP8, __BUILTIN_AVR_MAP16.\n+\n 2011-11-27  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tPR target/51278"}, {"sha": "fd03b361b5e793a973b5d34b43c8d4421efe96dd", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b2772e24f019808f0110b4cf22b3eda4706aab/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b2772e24f019808f0110b4cf22b3eda4706aab/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=49b2772e24f019808f0110b4cf22b3eda4706aab", "patch": "@@ -136,6 +136,8 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n   cpp_define (pfile, \"__BUILTIN_AVR_WDR\");\n   cpp_define (pfile, \"__BUILTIN_AVR_SLEEP\");\n   cpp_define (pfile, \"__BUILTIN_AVR_SWAP\");\n+  cpp_define (pfile, \"__BUILTIN_AVR_MAP8\");\n+  cpp_define (pfile, \"__BUILTIN_AVR_MAP16\");\n   cpp_define (pfile, \"__BUILTIN_AVR_DELAY_CYCLES\");\n \n   cpp_define (pfile, \"__BUILTIN_AVR_FMUL\");"}, {"sha": "bafd794a302eb7a3633e4fa52feffd7ff7f55141", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b2772e24f019808f0110b4cf22b3eda4706aab/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b2772e24f019808f0110b4cf22b3eda4706aab/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=49b2772e24f019808f0110b4cf22b3eda4706aab", "patch": "@@ -92,6 +92,7 @@ extern const char* avr_out_plus_noclobber (rtx*, int*, int*);\n extern const char* avr_out_addto_sp (rtx*, int*);\n extern const char* avr_out_xload (rtx, rtx*, int*);\n extern const char* avr_out_movmem (rtx, rtx*, int*);\n+extern const char* avr_out_map_bits (rtx, rtx*, int*);\n extern bool avr_popcount_each_byte (rtx, int, int);\n \n extern int extra_constraint_Q (rtx x);"}, {"sha": "bb4a08dad71768d837f883c55b507800eca7e189", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 419, "deletions": 5, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b2772e24f019808f0110b4cf22b3eda4706aab/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b2772e24f019808f0110b4cf22b3eda4706aab/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=49b2772e24f019808f0110b4cf22b3eda4706aab", "patch": "@@ -1795,8 +1795,9 @@ print_operand_address (FILE *file, rtx addr)\n }\n \n \n-/* Output X as assembler operand to file FILE.  */\n-     \n+/* Output X as assembler operand to file FILE.\n+   For a description of supported %-codes, see top of avr.md.  */\n+\n void\n print_operand (FILE *file, rtx x, int code)\n {\n@@ -1815,6 +1816,31 @@ print_operand (FILE *file, rtx x, int code)\n       if (AVR_HAVE_EIJMP_EICALL)\n \tfputc ('e', file);\n     }\n+  else if (code == 't'\n+           || code == 'T')\n+    {\n+      static int t_regno = -1;\n+      static int t_nbits = -1;\n+\n+      if (REG_P (x) && t_regno < 0 && code == 'T')\n+        {\n+          t_regno = REGNO (x);\n+          t_nbits = GET_MODE_BITSIZE (GET_MODE (x));\n+        }\n+      else if (CONST_INT_P (x) && t_regno >= 0\n+               && IN_RANGE (INTVAL (x), 0, t_nbits - 1))\n+        {\n+          int bpos = INTVAL (x);\n+\n+          fprintf (file, \"%s\", reg_names[t_regno + bpos / 8]);\n+          if (code == 'T')\n+            fprintf (file, \",%d\", bpos % 8);\n+\n+          t_regno = -1;\n+        }\n+      else\n+        fatal_insn (\"operands to %T/%t must be reg + const_int:\", x);\n+    }\n   else if (REG_P (x))\n     {\n       if (x == zero_reg_rtx)\n@@ -6403,6 +6429,8 @@ adjust_insn_length (rtx insn, int len)\n \n     case ADJUST_LEN_CALL: len = AVR_HAVE_JMP_CALL ? 2 : 1; break;\n \n+    case ADJUST_LEN_MAP_BITS: avr_out_map_bits (insn, op, &len); break;\n+\n     default:\n       gcc_unreachable();\n     }\n@@ -9857,6 +9885,345 @@ avr_expand_delay_cycles (rtx operands0)\n     }\n }\n \n+\n+/* Return VAL * BASE + DIGIT.  BASE = 0 is shortcut for BASE = 2^{32}   */\n+\n+static double_int\n+avr_double_int_push_digit (double_int val, int base,\n+                           unsigned HOST_WIDE_INT digit)\n+{\n+  val = 0 == base\n+    ? double_int_lshift (val, 32, 64, false)\n+    : double_int_mul (val, uhwi_to_double_int (base));\n+  \n+  return double_int_add (val, uhwi_to_double_int (digit));\n+}\n+\n+\n+/* Compute the image of x under f, i.e. perform   x --> f(x)    */\n+\n+static int\n+avr_map (double_int f, int x)\n+{\n+  return 0xf & double_int_to_uhwi (double_int_rshift (f, 4*x, 64, false));\n+}\n+\n+\n+/* Return the map R that reverses the bits of byte B.\n+\n+   R(0)  =  (0  7)  o  (1  6)  o   (2  5)  o   (3  4)\n+   R(1)  =  (8 15)  o  (9 14)  o  (10 13)  o  (11 12)\n+            \n+   Notice that R o R = id.  */\n+\n+static double_int\n+avr_revert_map (int b)\n+{\n+  int i;\n+  double_int r = double_int_zero;\n+\n+  for (i = 16-1; i >= 0; i--)\n+    r = avr_double_int_push_digit (r, 16, i >> 3 == b ? i ^ 7 : i);\n+\n+  return r;\n+}\n+\n+\n+/* Return the map R that swaps bit-chunks of size SIZE in byte B.\n+\n+   R(1,0)  =  (0 1)  o   (2  3)  o   (4  5)  o   (6  7)\n+   R(1,1)  =  (8 9)  o  (10 11)  o  (12 13)  o  (14 15)\n+\n+   R(4,0)  =  (0  4)  o  (1  5)  o   (2  6)  o   (3  7)\n+   R(4,1)  =  (8 12)  o  (9 13)  o  (10 14)  o  (11 15)\n+\n+   Notice that R o R = id.  */\n+\n+static double_int\n+avr_swap_map (int size, int b)\n+{\n+  int i;\n+  double_int r = double_int_zero;\n+\n+  for (i = 16-1; i >= 0; i--)\n+    r = avr_double_int_push_digit (r, 16, i ^ (i >> 3 == b ? size : 0));\n+\n+  return r;\n+}\n+\n+\n+/* Return Identity.  */\n+\n+static double_int\n+avr_id_map (void)\n+{\n+  int i;\n+  double_int r = double_int_zero;\n+\n+  for (i = 16-1; i >= 0; i--)\n+    r = avr_double_int_push_digit (r, 16, i);\n+\n+  return r;\n+}\n+\n+\n+enum\n+  {\n+    SIG_ID        = 0,\n+    /* for QI and HI */\n+    SIG_ROL       = 0xf,\n+    SIG_REVERT_0  = 1 << 4,\n+    SIG_SWAP1_0   = 1 << 5,\n+    /* HI only */\n+    SIG_REVERT_1  = 1 << 6,\n+    SIG_SWAP1_1   = 1 << 7,\n+    SIG_SWAP4_0   = 1 << 8,\n+    SIG_SWAP4_1   = 1 << 9\n+  };\n+\n+\n+/* Return basic map with signature SIG.  */\n+\n+static double_int\n+avr_sig_map (int n ATTRIBUTE_UNUSED, int sig)\n+{\n+  if (sig == SIG_ID)            return avr_id_map ();\n+  else if (sig == SIG_REVERT_0) return avr_revert_map (0);\n+  else if (sig == SIG_REVERT_1) return avr_revert_map (1);\n+  else if (sig == SIG_SWAP1_0)  return avr_swap_map (1, 0);\n+  else if (sig == SIG_SWAP1_1)  return avr_swap_map (1, 1);\n+  else if (sig == SIG_SWAP4_0)  return avr_swap_map (4, 0);\n+  else if (sig == SIG_SWAP4_1)  return avr_swap_map (4, 1);\n+  else\n+    gcc_unreachable();\n+}\n+\n+\n+/* Return the Hamming distance between the B-th byte of A and C.  */\n+\n+static bool\n+avr_map_hamming_byte (int n, int b, double_int a, double_int c, bool strict)\n+{\n+  int i, hamming = 0;\n+\n+  for (i = 8*b; i < n && i < 8*b + 8; i++)\n+    {\n+      int ai = avr_map (a, i);\n+      int ci = avr_map (c, i);\n+\n+      hamming += ai != ci && (strict || (ai < n && ci < n));\n+    }\n+  \n+  return hamming;\n+}\n+\n+\n+/* Return the non-strict Hamming distance between A and B.  */\n+\n+#define avr_map_hamming_nonstrict(N,A,B)              \\\n+  (+ avr_map_hamming_byte (N, 0, A, B, false)         \\\n+   + avr_map_hamming_byte (N, 1, A, B, false))\n+\n+\n+/* Return TRUE iff A and B represent the same mapping.  */\n+\n+#define avr_map_equal_p(N,A,B) (0 == avr_map_hamming_nonstrict (N, A, B))\n+\n+\n+/* Return TRUE iff A is a map of signature S.  Notice that there is no\n+   1:1 correspondance between maps and signatures and thus this is\n+   only supported for basic signatures recognized by avr_sig_map().  */\n+\n+#define avr_map_sig_p(N,A,S) avr_map_equal_p (N, A, avr_sig_map (N, S))\n+\n+\n+/* Swap odd/even bits of ld-reg %0:  %0 = bit-swap (%0)  */\n+\n+static const char*\n+avr_out_swap_bits (rtx *xop, int *plen)\n+{\n+  xop[1] = tmp_reg_rtx;\n+  \n+  return avr_asm_len (\"mov %1,%0\"    CR_TAB\n+                      \"andi %0,0xaa\" CR_TAB\n+                      \"eor %1,%0\"    CR_TAB\n+                      \"lsr %0\"       CR_TAB\n+                      \"lsl %1\"       CR_TAB\n+                      \"or %0,%1\", xop, plen, 6);\n+}\n+\n+/* Revert bit order:  %0 = Revert (%1) with %0 != %1 and clobber %1  */\n+\n+static const char*\n+avr_out_revert_bits (rtx *xop, int *plen)\n+{\n+  return avr_asm_len (\"inc __zero_reg__\" \"\\n\"\n+                      \"0:\\tror %1\"       CR_TAB\n+                      \"rol %0\"           CR_TAB\n+                      \"lsl __zero_reg__\" CR_TAB\n+                      \"brne 0b\", xop, plen, 5);\n+}\n+\n+\n+/* If OUT_P = true:  Output BST/BLD instruction according to MAP.\n+   If OUT_P = false: Just dry-run and fix XOP[1] to resolve\n+                     early-clobber conflicts if XOP[0] = XOP[1].  */\n+\n+static void\n+avr_move_bits (rtx *xop, double_int map, int n_bits, bool out_p, int *plen)\n+{\n+  int bit_dest, b, clobber = 0;\n+\n+  /* T-flag contains this bit of the source, i.e. of XOP[1]  */\n+  int t_bit_src = -1;\n+\n+  if (!optimize && !out_p)\n+    {\n+      avr_asm_len (\"mov __tmp_reg__,%1\", xop, plen, 1);\n+      xop[1] = tmp_reg_rtx;\n+      return;\n+    }\n+  \n+  /* We order the operations according to the requested source bit b.  */\n+  \n+  for (b = 0; b < n_bits; b++)\n+    for (bit_dest = 0; bit_dest < n_bits; bit_dest++)\n+      {\n+        int bit_src = avr_map (map, bit_dest);\n+        \n+        if (b != bit_src\n+            /* Same position: No need to copy as the caller did MOV.  */\n+            || bit_dest == bit_src\n+            /* Accessing bits 8..f for 8-bit version is void. */\n+            || bit_src >= n_bits)\n+          continue;\n+\n+        if (t_bit_src != bit_src)\n+          {\n+            /* Source bit is not yet in T: Store it to T.  */\n+              \n+            t_bit_src = bit_src;\n+\n+            if (out_p)\n+              {\n+                xop[2] = GEN_INT (bit_src);\n+                avr_asm_len (\"bst %T1%T2\", xop, plen, 1);\n+              }\n+            else if (clobber & (1 << bit_src))\n+              {\n+                /* Bit to be read was written already: Backup input\n+                   to resolve early-clobber conflict.  */\n+               \n+                avr_asm_len (\"mov __tmp_reg__,%1\", xop, plen, 1);\n+                xop[1] = tmp_reg_rtx;\n+                return;\n+              }\n+          }\n+\n+        /* Load destination bit with T.  */\n+        \n+        if (out_p)\n+          {\n+            xop[2] = GEN_INT (bit_dest);\n+            avr_asm_len (\"bld %T0%T2\", xop, plen, 1);\n+          }\n+        \n+        clobber |= 1 << bit_dest;\n+      }\n+}\n+\n+\n+/* Print assembler code for `map_bitsqi' and `map_bitshi'.  */\n+\n+const char*\n+avr_out_map_bits (rtx insn, rtx *operands, int *plen)\n+{\n+  bool copy_0, copy_1;\n+  int n_bits = GET_MODE_BITSIZE (GET_MODE (operands[0]));\n+  double_int map = rtx_to_double_int (operands[1]);\n+  rtx xop[3];\n+\n+  xop[0] = operands[0];\n+  xop[1] = operands[2];\n+\n+  if (plen)\n+    *plen = 0;\n+  else if (flag_print_asm_name)\n+    avr_fdump (asm_out_file, ASM_COMMENT_START \"%X\\n\", map);\n+\n+  switch (n_bits)\n+    {\n+    default:\n+      gcc_unreachable();\n+      \n+    case 8:\n+      if (avr_map_sig_p (n_bits, map, SIG_SWAP1_0))\n+        {\n+          return avr_out_swap_bits (xop, plen);\n+        }\n+      else if (avr_map_sig_p (n_bits, map, SIG_REVERT_0))\n+        {\n+          if (REGNO (xop[0]) == REGNO (xop[1])\n+              || !reg_unused_after (insn, xop[1]))\n+            {\n+              avr_asm_len (\"mov __tmp_reg__,%1\", xop, plen, 1);\n+              xop[1] = tmp_reg_rtx;\n+            }\n+          \n+          return avr_out_revert_bits (xop, plen);\n+        }\n+      \n+      break; /* 8 */\n+\n+    case 16:\n+      \n+      break; /* 16 */\n+    }\n+\n+  /* Copy whole byte is cheaper than moving bits that stay at the same\n+     position.  Some bits in a byte stay at the same position iff the\n+     strict Hamming distance to Identity is not 8.  */\n+\n+  copy_0 = 8 != avr_map_hamming_byte (n_bits, 0, map, avr_id_map(), true);\n+  copy_1 = 8 != avr_map_hamming_byte (n_bits, 1, map, avr_id_map(), true);\n+     \n+  /* Perform the move(s) just worked out.  */\n+\n+  if (n_bits == 8)\n+    {\n+      if (REGNO (xop[0]) == REGNO (xop[1]))\n+        {\n+          /* Fix early-clobber clashes.\n+             Notice XOP[0] hat no eary-clobber in its constraint.  */\n+          \n+          avr_move_bits (xop, map, n_bits, false, plen);\n+        }\n+      else if (copy_0)\n+        {\n+          avr_asm_len (\"mov %0,%1\", xop, plen, 1);\n+        }\n+    }\n+  else if (AVR_HAVE_MOVW && copy_0 && copy_1)\n+    {\n+      avr_asm_len (\"movw %A0,%A1\", xop, plen, 1);\n+    }\n+  else\n+    {\n+      if (copy_0)\n+        avr_asm_len (\"mov %A0,%A1\", xop, plen, 1);\n+\n+      if (copy_1)\n+        avr_asm_len (\"mov %B0,%B1\", xop, plen, 1);\n+    }\n+\n+  /* Move individual bits.  */\n+\n+  avr_move_bits (xop, map, n_bits, true, plen);\n+  \n+  return \"\";\n+}\n+\n+\n /* IDs for all the AVR builtins.  */\n \n enum avr_builtin_id\n@@ -9867,6 +10234,8 @@ enum avr_builtin_id\n     AVR_BUILTIN_WDR,\n     AVR_BUILTIN_SLEEP,\n     AVR_BUILTIN_SWAP,\n+    AVR_BUILTIN_MAP8,\n+    AVR_BUILTIN_MAP16,\n     AVR_BUILTIN_FMUL,\n     AVR_BUILTIN_FMULS,\n     AVR_BUILTIN_FMULSU,\n@@ -9923,6 +10292,18 @@ avr_init_builtins (void)\n                                 long_unsigned_type_node,\n                                 NULL_TREE);\n \n+  tree uchar_ftype_ulong_uchar\n+    = build_function_type_list (unsigned_char_type_node,\n+                                long_unsigned_type_node,\n+                                unsigned_char_type_node,\n+                                NULL_TREE);\n+\n+  tree uint_ftype_ullong_uint\n+    = build_function_type_list (unsigned_type_node,\n+                                long_long_unsigned_type_node,\n+                                unsigned_type_node,\n+                                NULL_TREE);\n+\n   DEF_BUILTIN (\"__builtin_avr_nop\", void_ftype_void, AVR_BUILTIN_NOP);\n   DEF_BUILTIN (\"__builtin_avr_sei\", void_ftype_void, AVR_BUILTIN_SEI);\n   DEF_BUILTIN (\"__builtin_avr_cli\", void_ftype_void, AVR_BUILTIN_CLI);\n@@ -9939,6 +10320,11 @@ avr_init_builtins (void)\n   DEF_BUILTIN (\"__builtin_avr_fmulsu\", int_ftype_char_uchar, \n                AVR_BUILTIN_FMULSU);\n \n+  DEF_BUILTIN (\"__builtin_avr_map8\", uchar_ftype_ulong_uchar, \n+               AVR_BUILTIN_MAP8);\n+  DEF_BUILTIN (\"__builtin_avr_map16\", uint_ftype_ullong_uint, \n+               AVR_BUILTIN_MAP16);\n+\n   avr_init_builtin_int24 ();\n }\n \n@@ -9962,7 +10348,9 @@ bdesc_2arg[] =\n   {\n     { CODE_FOR_fmul, \"__builtin_avr_fmul\", AVR_BUILTIN_FMUL },\n     { CODE_FOR_fmuls, \"__builtin_avr_fmuls\", AVR_BUILTIN_FMULS },\n-    { CODE_FOR_fmulsu, \"__builtin_avr_fmulsu\", AVR_BUILTIN_FMULSU }\n+    { CODE_FOR_fmulsu, \"__builtin_avr_fmulsu\", AVR_BUILTIN_FMULSU },\n+    { CODE_FOR_map_bitsqi, \"__builtin_avr_map8\", AVR_BUILTIN_MAP8 },\n+    { CODE_FOR_map_bitshi, \"__builtin_avr_map16\", AVR_BUILTIN_MAP16 }\n   };\n \n /* Subroutine of avr_expand_builtin to take care of unop insns.  */\n@@ -10078,6 +10466,7 @@ avr_expand_builtin (tree exp, rtx target,\n   size_t i;\n   const struct avr_builtin_description *d;\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n+  const char* bname = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n   unsigned int id = DECL_FUNCTION_CODE (fndecl);\n   tree arg0;\n   rtx op0;\n@@ -10110,12 +10499,37 @@ avr_expand_builtin (tree exp, rtx target,\n         op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n \n         if (! CONST_INT_P (op0))\n-          error (\"__builtin_avr_delay_cycles expects a\"\n-                 \" compile time integer constant.\");\n+          error (\"%s expects a compile time integer constant\", bname);\n \n         avr_expand_delay_cycles (op0);\n         return 0;\n       }\n+\n+    case AVR_BUILTIN_MAP8:\n+      {\n+        arg0 = CALL_EXPR_ARG (exp, 0);\n+        op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+\n+        if (!CONST_INT_P (op0))\n+          {\n+            error (\"%s expects a compile time long integer constant\"\n+                   \" as first argument\", bname);\n+            return target;\n+          }\n+      }\n+\n+    case AVR_BUILTIN_MAP16:\n+      {\n+        arg0 = CALL_EXPR_ARG (exp, 0);\n+        op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+\n+        if (!const_double_operand (op0, VOIDmode))\n+          {\n+            error (\"%s expects a compile time long long integer constant\"\n+                   \" as first argument\", bname);\n+            return target;\n+          }\n+      }\n     }\n \n   for (i = 0, d = bdesc_1arg; i < ARRAY_SIZE (bdesc_1arg); i++, d++)"}, {"sha": "bddfe933ee6e070eb6f81194f98b147ba9e9bb01", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b2772e24f019808f0110b4cf22b3eda4706aab/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b2772e24f019808f0110b4cf22b3eda4706aab/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=49b2772e24f019808f0110b4cf22b3eda4706aab", "patch": "@@ -33,6 +33,16 @@\n ;;  o  Displacement for (mem (plus (reg) (const_int))) operands.\n ;;  p  POST_INC or PRE_DEC address as a pointer (X, Y, Z)\n ;;  r  POST_INC or PRE_DEC address as a register (r26, r28, r30)\n+;; T/T Print operand suitable for BLD/BST instruction, i.e. register and\n+;;     bit number.  This gets 2 operands: The first %T gets a REG_P and\n+;;     just cashes the operand for the next %T.  The second %T gets\n+;;     a CONST_INT that represents a bit position.\n+;;     Example: With %0 = (reg:HI 18)  and  %1 = (const_int 13)\n+;;              \"%T0%T1\" it will print \"r19,5\".\n+;;     Notice that you must not write a comma between %T0 and %T1.\n+;; T/t Similar to above, but don't print the comma and the bit number.\n+;;     Example: With %0 = (reg:HI 18)  and  %1 = (const_int 13)\n+;;              \"%T0%t1\" it will print \"r19\".\n ;;..x..Constant Direct Program memory address.\n ;;  ~  Output 'r' if not AVR_HAVE_JMP_CALL.\n ;;  !  Output 'e' if AVR_HAVE_EIJMP_EICALL.\n@@ -64,6 +74,7 @@\n    UNSPEC_FMULSU\n    UNSPEC_COPYSIGN\n    UNSPEC_IDENTITY\n+   UNSPEC_MAP_BITS\n    ])\n \n (define_c_enum \"unspecv\"\n@@ -139,6 +150,7 @@\n    ashlhi, ashrhi, lshrhi,\n    ashlsi, ashrsi, lshrsi,\n    ashlpsi, ashrpsi, lshrpsi,\n+   map_bits,\n    no\"\n   (const_string \"no\"))\n \n@@ -5093,6 +5105,30 @@\n   [(set_attr \"length\" \"9\")\n    (set_attr \"cc\" \"clobber\")])\n \n+(define_insn \"map_bitsqi\"\n+  [(set (match_operand:QI 0 \"register_operand\"             \"=d\")\n+        (unspec:QI [(match_operand:SI 1 \"const_int_operand\" \"n\")\n+                    (match_operand:QI 2 \"register_operand\"  \"r\")]\n+                   UNSPEC_MAP_BITS))]\n+  \"\"\n+  {\n+    return avr_out_map_bits (insn, operands, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"map_bits\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"map_bitshi\"\n+  [(set (match_operand:HI 0 \"register_operand\"               \"=&r\")\n+        (unspec:HI [(match_operand:DI 1 \"const_double_operand\" \"n\")\n+                    (match_operand:HI 2 \"register_operand\"     \"r\")]\n+                   UNSPEC_MAP_BITS))]\n+  \"\"\n+  {\n+    return avr_out_map_bits (insn, operands, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"map_bits\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n \n ;; Parity\n "}, {"sha": "d52f9a0cf29dea4057eeb470ea2097d7558bf10f", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b2772e24f019808f0110b4cf22b3eda4706aab/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b2772e24f019808f0110b4cf22b3eda4706aab/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=49b2772e24f019808f0110b4cf22b3eda4706aab", "patch": "@@ -8594,11 +8594,41 @@ implements\n void __builtin_avr_delay_cycles (unsigned long ticks)\n @end smallexample\n \n+@noindent\n @code{ticks} is the number of ticks to delay execution. Note that this\n built-in does not take into account the effect of interrupts which\n might increase delay time. @code{ticks} must be a compile time\n integer constant; delays with a variable number of cycles are not supported.\n \n+@smallexample\n+     unsigned char __builtin_avr_map8 (unsigned long map, unsigned char val)\n+@end smallexample\n+\n+@noindent\n+Each bit of the result is copied from a specific bit of @code{val}.\n+@code{map} is a compile time constant that represents a map composed\n+of 8 nibbles (4-bit groups):\n+The @var{n}-th nibble of @code{map} specifies which bit of @code{val}\n+is to be moved to the @var{n}-th bit of the result.\n+For example, @code{map = 0x76543210} represents identity: The MSB of\n+the result is read from the 7-th bit of @code{val}, the LSB is\n+read from the 0-th bit to @code{val}, etc.\n+Two more examples: @code{0x01234567} reverses the bit order and\n+@code{0x32107654} is equivalent to a @code{swap} instruction.\n+\n+@noindent\n+One typical use case for this and the following built-in is adjusting input and\n+output values to non-contiguous port layouts.\n+\n+@smallexample\n+     unsigned int __builtin_avr_map16 (unsigned long long map, unsigned int val)\n+@end smallexample\n+\n+@noindent\n+Similar to the previous built-in except that it operates on @code{int}\n+and thus 16 bits are involved.  Again, @code{map} must be a compile\n+time constant.\n+\n @node Blackfin Built-in Functions\n @subsection Blackfin Built-in Functions\n "}]}