{"sha": "47e4ab6559dc857df66403824909b5ab73891fd2", "node_id": "C_kwDOANBUbNoAKDQ3ZTRhYjY1NTlkYzg1N2RmNjY0MDM4MjQ5MDliNWFiNzM4OTFmZDI", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-09T17:26:32Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-18T08:43:36Z"}, "message": "Strlen pass refactoring.\n\nThis refactors the strlen pass to avoid passing around as much state.\nIt is meant to be a start.  There's still some more refactoring\nthat could be done, especially in cleaning up the interface between\nthe strlen internals and the sprintf pass.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-strlen.c (class strlen_pass): Rename from\n\tstrlen_dom_walker.\n\t(handle_builtin_stxncpy_strncat): Move to strlen_pass.\n\t(handle_assign): Same.\n\t(adjust_last_stmt): Same.\n\t(maybe_warn_overflow): Same.\n\t(handle_builtin_strlen): Same.\n\t(handle_builtin_strchr): Same.\n\t(handle_builtin_strcpy): Same.\n\t(handle_builtin_strncat): Same.\n\t(handle_builtin_stxncpy_strncat): Same.\n\t(handle_builtin_memcpy): Same.\n\t(handle_builtin_strcat): Same.\n\t(handle_alloc_call): Same.\n\t(handle_builtin_memset): Same.\n\t(handle_builtin_memcmp): Same.\n\t(get_len_or_size): Same.\n\t(strxcmp_eqz_result): Same.\n\t(handle_builtin_string_cmp): Same.\n\t(handle_pointer_plus): Same.\n\t(count_nonzero_bytes_addr): Same.\n\t(count_nonzero_bytes): Same.\n\t(handle_store): Same.\n\t(strlen_check_and_optimize_call): Same.\n\t(handle_integral_assign): Same.\n\t(check_and_optimize_stmt): Same.\n\t(printf_strlen_execute): Rename strlen_dom_walker to strlen_pass.", "tree": {"sha": "f60ddd6159c503c0269946fe8947e10d35859d8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f60ddd6159c503c0269946fe8947e10d35859d8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47e4ab6559dc857df66403824909b5ab73891fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e4ab6559dc857df66403824909b5ab73891fd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47e4ab6559dc857df66403824909b5ab73891fd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e4ab6559dc857df66403824909b5ab73891fd2/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64f9623765da3306b0ab6a47997dc5d62c2ea261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64f9623765da3306b0ab6a47997dc5d62c2ea261", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64f9623765da3306b0ab6a47997dc5d62c2ea261"}], "stats": {"total": 482, "additions": 257, "deletions": 225}, "files": [{"sha": "8c39869616ffe448fc0e1546d1d7995b2d544ed6", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 257, "deletions": 225, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e4ab6559dc857df66403824909b5ab73891fd2/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e4ab6559dc857df66403824909b5ab73891fd2/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=47e4ab6559dc857df66403824909b5ab73891fd2", "patch": "@@ -193,9 +193,6 @@ struct laststmt_struct\n } laststmt;\n \n static int get_stridx_plus_constant (strinfo *, unsigned HOST_WIDE_INT, tree);\n-static void handle_builtin_stxncpy_strncat (bool, gimple_stmt_iterator *);\n-static bool handle_assign (gimple_stmt_iterator *, tree, bool *,\n-\t\t\t   pointer_query &);\n \n /* Sets MINMAX to either the constant value or the range VAL is in\n    and returns either the constant value or VAL on success or null\n@@ -232,6 +229,88 @@ get_range (tree val, gimple *stmt, wide_int minmax[2],\n   return NULL_TREE;\n }\n \n+class strlen_pass : public dom_walker\n+{\n+public:\n+  strlen_pass (cdi_direction direction)\n+    : dom_walker (direction),\n+      evrp (false),\n+      ptr_qry (&evrp, &var_cache),\n+      var_cache (),\n+      m_cleanup_cfg (false)\n+  {\n+  }\n+\n+  ~strlen_pass ();\n+\n+  virtual edge before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+\n+  bool check_and_optimize_stmt (bool *cleanup_eh);\n+  bool check_and_optimize_call (bool *zero_write);\n+  bool handle_assign (tree lhs, bool *zero_write);\n+  bool handle_store (bool *zero_write);\n+  void handle_pointer_plus ();\n+  void handle_builtin_strlen ();\n+  void handle_builtin_strchr ();\n+  void handle_builtin_strcpy (built_in_function);\n+  void handle_integral_assign (bool *cleanup_eh);\n+  void handle_builtin_stxncpy_strncat (bool append_p);\n+  void handle_builtin_memcpy (built_in_function bcode);\n+  void handle_builtin_strcat (built_in_function bcode);\n+  void handle_builtin_strncat (built_in_function);\n+  bool handle_builtin_memset (bool *zero_write);\n+  bool handle_builtin_memcmp ();\n+  bool handle_builtin_string_cmp ();\n+  void handle_alloc_call (built_in_function);\n+  void maybe_warn_overflow (gimple *stmt, bool call_lhs, tree len,\n+\t\t\t    strinfo *si = NULL, bool plus_one = false,\n+\t\t\t    bool rawmem = false);\n+  void maybe_warn_overflow (gimple *stmt, bool call_lhs,\n+\t\t\t    unsigned HOST_WIDE_INT len,\n+\t\t\t    strinfo *si = NULL,\n+\t\t\t    bool plus_one = false, bool rawmem = false);\n+  void adjust_last_stmt (strinfo *si, gimple *stmt, bool is_strcat);\n+  tree strxcmp_eqz_result (gimple *stmt, tree arg1, int idx1,\n+\t\t\t   tree arg2, int idx2,\n+\t\t\t   unsigned HOST_WIDE_INT bound,\n+\t\t\t   unsigned HOST_WIDE_INT len[2],\n+\t\t\t   unsigned HOST_WIDE_INT *psize);\n+  bool count_nonzero_bytes (tree expr_or_type,\n+\t\t\t    unsigned lenrange[3], bool *nulterm,\n+\t\t\t    bool *allnul, bool *allnonnul);\n+  bool count_nonzero_bytes (tree exp,\n+\t\t\t    unsigned HOST_WIDE_INT offset,\n+\t\t\t    unsigned HOST_WIDE_INT nbytes,\n+\t\t\t    unsigned lenrange[3], bool *nulterm,\n+\t\t\t    bool *allnul, bool *allnonnul,\n+\t\t\t    ssa_name_limit_t &snlim);\n+  bool count_nonzero_bytes_addr (tree exp,\n+\t\t\t\t unsigned HOST_WIDE_INT offset,\n+\t\t\t\t unsigned HOST_WIDE_INT nbytes,\n+\t\t\t\t unsigned lenrange[3], bool *nulterm,\n+\t\t\t\t bool *allnul, bool *allnonnul,\n+\t\t\t\t ssa_name_limit_t &snlim);\n+  bool get_len_or_size (gimple *stmt, tree arg, int idx,\n+\t\t\tunsigned HOST_WIDE_INT lenrng[2],\n+\t\t\tunsigned HOST_WIDE_INT *size, bool *nulterm);\n+\n+  /* EVRP analyzer used for printf argument range processing, and to\n+     track strlen results across integer variable assignments.  */\n+  evrp_range_analyzer evrp;\n+\n+  /* A pointer_query object and its cache to store information about\n+     pointers and their targets in.  */\n+  pointer_query ptr_qry;\n+  pointer_query::cache_type var_cache;\n+\n+  gimple_stmt_iterator m_gsi;\n+\n+  /* Flag that will trigger TODO_cleanup_cfg to be returned in strlen\n+     execute function.  */\n+  bool m_cleanup_cfg;\n+};\n+\n /* Return:\n \n    *  +1  if SI is known to start with more than OFF nonzero characters.\n@@ -242,7 +321,7 @@ get_range (tree val, gimple *stmt, wide_int minmax[2],\n \t  or the relationship between the number of leading nonzero\n \t  characters in SI and OFF is unknown.  */\n \n-static inline int\n+static int\n compare_nonzero_chars (strinfo *si, unsigned HOST_WIDE_INT off)\n {\n   if (si->nonzero_chars\n@@ -1664,9 +1743,8 @@ valid_builtin_call (gimple *stmt)\n    just memcpy (x, y, strlen (y)).  SI must be the zero length\n    strinfo.  */\n \n-static void\n-adjust_last_stmt (strinfo *si, gimple *stmt, bool is_strcat,\n-\t\t  pointer_query &ptr_qry)\n+void\n+strlen_pass::adjust_last_stmt (strinfo *si, gimple *stmt, bool is_strcat)\n {\n   tree vuse, callee, len;\n   struct laststmt_struct last = laststmt;\n@@ -1913,11 +1991,9 @@ maybe_set_strlen_range (tree lhs, tree src, tree bound)\n    RAWMEM may be set by memcpy and other raw memory functions\n    to allow accesses across subobject boundaries.  */\n \n-static void\n-maybe_warn_overflow (gimple *stmt, bool call_lhs, tree len,\n-\t\t     pointer_query &ptr_qry,\n-\t\t     strinfo *si = NULL, bool plus_one = false,\n-\t\t     bool rawmem = false)\n+void\n+strlen_pass::maybe_warn_overflow (gimple *stmt, bool call_lhs, tree len,\n+\t\t\t\t  strinfo *si, bool plus_one, bool rawmem)\n {\n   if (!len || warning_suppressed_p (stmt, OPT_Wstringop_overflow_))\n     return;\n@@ -2097,23 +2173,23 @@ maybe_warn_overflow (gimple *stmt, bool call_lhs, tree len,\n \n /* Convenience wrapper for the above.  */\n \n-static inline void\n-maybe_warn_overflow (gimple *stmt, bool call_lhs, unsigned HOST_WIDE_INT len,\n-\t\t     pointer_query &ptr_qry, strinfo *si = NULL,\n-\t\t     bool plus_one = false, bool rawmem = false)\n+void\n+strlen_pass::maybe_warn_overflow (gimple *stmt, bool call_lhs,\n+\t\t\t\t  unsigned HOST_WIDE_INT len,\n+\t\t\t\t  strinfo *si, bool plus_one, bool rawmem)\n {\n   tree tlen = build_int_cst (size_type_node, len);\n-  maybe_warn_overflow (stmt, call_lhs, tlen, ptr_qry, si, plus_one, rawmem);\n+  maybe_warn_overflow (stmt, call_lhs, tlen, si, plus_one, rawmem);\n }\n \n /* Handle a strlen call.  If strlen of the argument is known, replace\n    the strlen call with the known value, otherwise remember that strlen\n    of the argument is stored in the lhs SSA_NAME.  */\n \n-static void\n-handle_builtin_strlen (gimple_stmt_iterator *gsi)\n+void\n+strlen_pass::handle_builtin_strlen ()\n {\n-  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (m_gsi);\n   tree lhs = gimple_call_lhs (stmt);\n \n   if (lhs == NULL_TREE)\n@@ -2167,8 +2243,8 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t  if (bound)\n \t    rhs = fold_build2_loc (loc, MIN_EXPR, TREE_TYPE (rhs), rhs, bound);\n \n-\t  gimplify_and_update_call_from_tree (gsi, rhs);\n-\t  stmt = gsi_stmt (*gsi);\n+\t  gimplify_and_update_call_from_tree (&m_gsi, rhs);\n+\t  stmt = gsi_stmt (m_gsi);\n \t  update_stmt (stmt);\n \t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n \t    {\n@@ -2266,8 +2342,8 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t      }\n \t    if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (ret)))\n \t      ret = fold_convert_loc (loc, TREE_TYPE (lhs), ret);\n-\t    gimplify_and_update_call_from_tree (gsi, ret);\n-\t    stmt = gsi_stmt (*gsi);\n+\t    gimplify_and_update_call_from_tree (&m_gsi, ret);\n+\t    stmt = gsi_stmt (m_gsi);\n \t    update_stmt (stmt);\n \t    if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n \t      {\n@@ -2285,10 +2361,10 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n    the strchr (x, 0) call with the endptr or x + strlen, otherwise remember\n    that lhs of the call is endptr and strlen of the argument is endptr - x.  */\n \n-static void\n-handle_builtin_strchr (gimple_stmt_iterator *gsi)\n+void\n+strlen_pass::handle_builtin_strchr ()\n {\n-  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (m_gsi);\n   tree lhs = gimple_call_lhs (stmt);\n \n   if (lhs == NULL_TREE)\n@@ -2344,8 +2420,8 @@ handle_builtin_strchr (gimple_stmt_iterator *gsi)\n \t\t\t\t\t      TREE_TYPE (rhs)))\n \t\trhs = fold_convert_loc (loc, TREE_TYPE (lhs), rhs);\n \t    }\n-\t  gimplify_and_update_call_from_tree (gsi, rhs);\n-\t  stmt = gsi_stmt (*gsi);\n+\t  gimplify_and_update_call_from_tree (&m_gsi, rhs);\n+\t  stmt = gsi_stmt (m_gsi);\n \t  update_stmt (stmt);\n \t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n \t    {\n@@ -2397,14 +2473,13 @@ handle_builtin_strchr (gimple_stmt_iterator *gsi)\n    is the same after this call.  Furthermore, attempt to convert it to\n    memcpy.  Uses RVALS to determine range information.  */\n \n-static void\n-handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n-\t\t       pointer_query &ptr_qry)\n+void\n+strlen_pass::handle_builtin_strcpy (built_in_function bcode)\n {\n   int idx, didx;\n   tree src, dst, srclen, len, lhs, type, fn, oldlen;\n   bool success;\n-  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (m_gsi);\n   strinfo *si, *dsi, *olddsi, *zsi;\n   location_t loc;\n \n@@ -2425,18 +2500,18 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n     return;\n \n   if (olddsi != NULL)\n-    adjust_last_stmt (olddsi, stmt, false, ptr_qry);\n+    adjust_last_stmt (olddsi, stmt, false);\n \n   srclen = NULL_TREE;\n   if (si != NULL)\n     srclen = get_string_length (si);\n   else if (idx < 0)\n     srclen = build_int_cst (size_type_node, ~idx);\n \n-  maybe_warn_overflow (stmt, false, srclen, ptr_qry, olddsi, true);\n+  maybe_warn_overflow (stmt, false, srclen, olddsi, true);\n \n   if (olddsi != NULL)\n-    adjust_last_stmt (olddsi, stmt, false, ptr_qry);\n+    adjust_last_stmt (olddsi, stmt, false);\n \n   loc = gimple_location (stmt);\n   if (srclen == NULL_TREE)\n@@ -2627,21 +2702,21 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n   if (fn == NULL_TREE)\n     return;\n \n-  len = force_gimple_operand_gsi (gsi, len, true, NULL_TREE, true,\n+  len = force_gimple_operand_gsi (&m_gsi, len, true, NULL_TREE, true,\n \t\t\t\t  GSI_SAME_STMT);\n   if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n     {\n       fprintf (dump_file, \"Optimizing: \");\n       print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n     }\n   if (gimple_call_num_args (stmt) == 2)\n-    success = update_gimple_call (gsi, fn, 3, dst, src, len);\n+    success = update_gimple_call (&m_gsi, fn, 3, dst, src, len);\n   else\n-    success = update_gimple_call (gsi, fn, 4, dst, src, len,\n+    success = update_gimple_call (&m_gsi, fn, 4, dst, src, len,\n \t\t\t\t  gimple_call_arg (stmt, 2));\n   if (success)\n     {\n-      stmt = gsi_stmt (*gsi);\n+      stmt = gsi_stmt (m_gsi);\n       update_stmt (stmt);\n       if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n \t{\n@@ -2665,11 +2740,11 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n    size argument is derived from a call to strlen() on the source argument,\n    and if so, issue an appropriate warning.  */\n \n-static void\n-handle_builtin_strncat (built_in_function, gimple_stmt_iterator *gsi)\n+void\n+strlen_pass::handle_builtin_strncat (built_in_function)\n {\n   /* Same as stxncpy().  */\n-  handle_builtin_stxncpy_strncat (true, gsi);\n+  handle_builtin_stxncpy_strncat (true);\n }\n \n /* Return true if LEN depends on a call to strlen(SRC) in an interesting\n@@ -3074,13 +3149,13 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt,\n    and if so, issue the appropriate warning.\n    APPEND_P is true for strncat.  */\n \n-static void\n-handle_builtin_stxncpy_strncat (bool append_p, gimple_stmt_iterator *gsi)\n+void\n+strlen_pass::handle_builtin_stxncpy_strncat (bool append_p)\n {\n   if (!strlen_to_stridx)\n     return;\n \n-  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (m_gsi);\n \n   tree dst = gimple_call_arg (stmt, 0);\n   tree src = gimple_call_arg (stmt, 1);\n@@ -3158,7 +3233,7 @@ handle_builtin_stxncpy_strncat (bool append_p, gimple_stmt_iterator *gsi)\n   stridx_strlenloc *pss = strlen_to_stridx->get (len);\n   if (!pss || pss->first <= 0)\n     {\n-      if (maybe_diag_stxncpy_trunc (*gsi, src, len))\n+      if (maybe_diag_stxncpy_trunc (m_gsi, src, len))\n \tsuppress_warning (stmt, OPT_Wstringop_truncation);\n \n       return;\n@@ -3216,12 +3291,11 @@ handle_builtin_stxncpy_strncat (bool append_p, gimple_stmt_iterator *gsi)\n    is that plus one, strlen of the first argument is the same after this\n    call.  Uses RVALS to determine range information.  */\n \n-static void\n-handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n-\t\t       pointer_query &ptr_qry)\n+void\n+strlen_pass::handle_builtin_memcpy (built_in_function bcode)\n {\n   tree lhs, oldlen, newlen;\n-  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (m_gsi);\n   strinfo *si, *dsi;\n \n   tree len = gimple_call_arg (stmt, 2);\n@@ -3238,8 +3312,8 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n   if (olddsi != NULL\n       && !integer_zerop (len))\n     {\n-      maybe_warn_overflow (stmt, false, len, ptr_qry, olddsi, false, true);\n-      adjust_last_stmt (olddsi, stmt, false, ptr_qry);\n+      maybe_warn_overflow (stmt, false, len, olddsi, false, true);\n+      adjust_last_stmt (olddsi, stmt, false);\n     }\n \n   int idx = get_stridx (src);\n@@ -3316,7 +3390,7 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n     }\n \n   if (olddsi != NULL && TREE_CODE (len) == SSA_NAME)\n-    adjust_last_stmt (olddsi, stmt, false, ptr_qry);\n+    adjust_last_stmt (olddsi, stmt, false);\n \n   if (didx == 0)\n     {\n@@ -3397,14 +3471,13 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n    to convert it to memcpy/strcpy if the length of the first argument\n    is known.  */\n \n-static void\n-handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n-\t\t       pointer_query &ptr_qry)\n+void\n+strlen_pass::handle_builtin_strcat (built_in_function bcode)\n {\n   int idx, didx;\n   tree srclen, args, type, fn, objsz, endptr;\n   bool success;\n-  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (m_gsi);\n   strinfo *si, *dsi;\n   location_t loc = gimple_location (stmt);\n \n@@ -3581,7 +3654,7 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n       len = fold_convert_loc (loc, type, unshare_expr (srclen));\n       len = fold_build2_loc (loc, PLUS_EXPR, type, len,\n \t\t\t     build_int_cst (type, 1));\n-      len = force_gimple_operand_gsi (gsi, len, true, NULL_TREE, true,\n+      len = force_gimple_operand_gsi (&m_gsi, len, true, NULL_TREE, true,\n \t\t\t\t      GSI_SAME_STMT);\n     }\n   if (endptr)\n@@ -3590,14 +3663,14 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n     dst = fold_build2_loc (loc, POINTER_PLUS_EXPR, TREE_TYPE (dst), dst,\n \t\t\t   fold_convert_loc (loc, sizetype,\n \t\t\t\t\t     unshare_expr (dstlen)));\n-  dst = force_gimple_operand_gsi (gsi, dst, true, NULL_TREE, true,\n+  dst = force_gimple_operand_gsi (&m_gsi, dst, true, NULL_TREE, true,\n \t\t\t\t  GSI_SAME_STMT);\n   if (objsz)\n     {\n       objsz = fold_build2_loc (loc, MINUS_EXPR, TREE_TYPE (objsz), objsz,\n \t\t\t       fold_convert_loc (loc, TREE_TYPE (objsz),\n \t\t\t\t\t\t unshare_expr (dstlen)));\n-      objsz = force_gimple_operand_gsi (gsi, objsz, true, NULL_TREE, true,\n+      objsz = force_gimple_operand_gsi (&m_gsi, objsz, true, NULL_TREE, true,\n \t\t\t\t\tGSI_SAME_STMT);\n     }\n   if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n@@ -3606,14 +3679,14 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n       print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n     }\n   if (srclen != NULL_TREE)\n-    success = update_gimple_call (gsi, fn, 3 + (objsz != NULL_TREE),\n+    success = update_gimple_call (&m_gsi, fn, 3 + (objsz != NULL_TREE),\n \t\t\t\t  dst, src, len, objsz);\n   else\n-    success = update_gimple_call (gsi, fn, 2 + (objsz != NULL_TREE),\n+    success = update_gimple_call (&m_gsi, fn, 2 + (objsz != NULL_TREE),\n \t\t\t\t  dst, src, objsz);\n   if (success)\n     {\n-      stmt = gsi_stmt (*gsi);\n+      stmt = gsi_stmt (m_gsi);\n       update_stmt (stmt);\n       if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n \t{\n@@ -3624,7 +3697,7 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n \t computed by transforming this strcpy into stpcpy.  */\n       if (srclen == NULL_TREE && dsi->dont_invalidate)\n \tdsi->stmt = stmt;\n-      adjust_last_stmt (dsi, stmt, true, ptr_qry);\n+      adjust_last_stmt (dsi, stmt, true);\n       if (srclen != NULL_TREE)\n \t{\n \t  laststmt.stmt = stmt;\n@@ -3642,10 +3715,10 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n /* Handle a call to an allocation function like alloca, malloc or calloc,\n    or an ordinary allocation function declared with attribute alloc_size.  */\n \n-static void\n-handle_alloc_call (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n+void\n+strlen_pass::handle_alloc_call (built_in_function bcode)\n {\n-  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (m_gsi);\n   tree lhs = gimple_call_lhs (stmt);\n   if (lhs == NULL_TREE)\n     return;\n@@ -3679,11 +3752,10 @@ handle_alloc_call (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n    return true when the call is transformed, false otherwise.\n    When nonnull uses RVALS to determine range information.  */\n \n-static bool\n-handle_builtin_memset (gimple_stmt_iterator *gsi, bool *zero_write,\n-\t\t       pointer_query &ptr_qry)\n+bool\n+strlen_pass::handle_builtin_memset (bool *zero_write)\n {\n-  gimple *memset_stmt = gsi_stmt (*gsi);\n+  gimple *memset_stmt = gsi_stmt (m_gsi);\n   tree ptr = gimple_call_arg (memset_stmt, 0);\n   /* Set to the non-constant offset added to PTR.  */\n   wide_int offrng[2];\n@@ -3703,8 +3775,7 @@ handle_builtin_memset (gimple_stmt_iterator *gsi, bool *zero_write,\n   tree memset_size = gimple_call_arg (memset_stmt, 2);\n \n   /* Check for overflow.  */\n-  maybe_warn_overflow (memset_stmt, false, memset_size, ptr_qry, NULL,\n-\t\t       false, true);\n+  maybe_warn_overflow (memset_stmt, false, memset_size, NULL, false, true);\n \n   /* Bail when there is no statement associated with the destination\n      (the statement may be null even when SI1->ALLOC is not).  */\n@@ -3744,11 +3815,11 @@ handle_builtin_memset (gimple_stmt_iterator *gsi, bool *zero_write,\n   if (lhs)\n     {\n       gimple *assign = gimple_build_assign (lhs, ptr);\n-      gsi_replace (gsi, assign, false);\n+      gsi_replace (&m_gsi, assign, false);\n     }\n   else\n     {\n-      gsi_remove (gsi, true);\n+      gsi_remove (&m_gsi, true);\n       release_defs (memset_stmt);\n     }\n \n@@ -3832,10 +3903,10 @@ use_in_zero_equality (tree res, bool exclusive = true)\n    with a __builtin_memcmp_eq call where possible.\n    return true when call is transformed, return false otherwise.  */\n \n-static bool\n-handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n+bool\n+strlen_pass::handle_builtin_memcmp ()\n {\n-  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (m_gsi));\n   tree res = gimple_call_lhs (stmt);\n \n   if (!res || !use_in_zero_equality (res))\n@@ -3877,7 +3948,7 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n \t\t\t\t  fold_build2_loc (loc, NE_EXPR,\n \t\t\t\t\t\t   boolean_type_node,\n \t\t\t\t\t\t   arg1, arg2));\n-\t  gimplify_and_update_call_from_tree (gsi, res);\n+\t  gimplify_and_update_call_from_tree (&m_gsi, res);\n \t  return true;\n \t}\n     }\n@@ -3894,11 +3965,10 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n    *NULTERM to true, otherwise to false.  When nonnull uses RVALS to\n    determine range information. Returns true on success.  */\n \n-static bool\n-get_len_or_size (gimple *stmt, tree arg, int idx,\n-\t\t unsigned HOST_WIDE_INT lenrng[2],\n-\t\t unsigned HOST_WIDE_INT *size, bool *nulterm,\n-\t\t range_query *rvals)\n+bool\n+strlen_pass::get_len_or_size (gimple *stmt, tree arg, int idx,\n+\t\t\t      unsigned HOST_WIDE_INT lenrng[2],\n+\t\t\t      unsigned HOST_WIDE_INT *size, bool *nulterm)\n {\n   /* Invalidate.  */\n   *size = HOST_WIDE_INT_M1U;\n@@ -3951,7 +4021,7 @@ get_len_or_size (gimple *stmt, tree arg, int idx,\n   /* Set MAXBOUND to an arbitrary non-null non-integer node as a request\n      to have it set to the length of the longest string in a PHI.  */\n   lendata.maxbound = arg;\n-  get_range_strlen_dynamic (arg, stmt, &lendata, rvals);\n+  get_range_strlen_dynamic (arg, stmt, &lendata, ptr_qry.rvals);\n \n   unsigned HOST_WIDE_INT maxbound = HOST_WIDE_INT_M1U;\n   if (tree_fits_uhwi_p (lendata.maxbound)\n@@ -4008,18 +4078,20 @@ get_len_or_size (gimple *stmt, tree arg, int idx,\n    to be at least as long and need not be nul-terminated) and size.\n    Otherwise return null.  */\n \n-static tree\n-strxcmp_eqz_result (gimple *stmt, tree arg1, int idx1, tree arg2, int idx2,\n-\t\t    unsigned HOST_WIDE_INT bound, unsigned HOST_WIDE_INT len[2],\n-\t\t    unsigned HOST_WIDE_INT *psize, range_query *rvals)\n+tree\n+strlen_pass::strxcmp_eqz_result (gimple *stmt, tree arg1, int idx1,\n+\t\t\t\t tree arg2, int idx2,\n+\t\t\t\t unsigned HOST_WIDE_INT bound,\n+\t\t\t\t unsigned HOST_WIDE_INT len[2],\n+\t\t\t\t unsigned HOST_WIDE_INT *psize)\n {\n   /* Determine the range the length of each string is in and whether it's\n      known to be nul-terminated, or the size of the array it's stored in.  */\n   bool nul1, nul2;\n   unsigned HOST_WIDE_INT siz1, siz2;\n   unsigned HOST_WIDE_INT len1rng[2], len2rng[2];\n-  if (!get_len_or_size (stmt, arg1, idx1, len1rng, &siz1, &nul1, rvals)\n-      || !get_len_or_size (stmt, arg2, idx2, len2rng, &siz2, &nul2, rvals))\n+  if (!get_len_or_size (stmt, arg1, idx1, len1rng, &siz1, &nul1)\n+      || !get_len_or_size (stmt, arg2, idx2, len2rng, &siz2, &nul2))\n     return NULL_TREE;\n \n   /* BOUND is set to HWI_M1U for strcmp and less to strncmp, and LENiRNG\n@@ -4167,10 +4239,10 @@ maybe_warn_pointless_strcmp (gimple *stmt, HOST_WIDE_INT bound,\n    is not known.  Return true when the call has been transformed into\n    another and false otherwise.  */\n \n-static bool\n-handle_builtin_string_cmp (gimple_stmt_iterator *gsi, range_query *rvals)\n+bool\n+strlen_pass::handle_builtin_string_cmp ()\n {\n-  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (m_gsi));\n   tree lhs = gimple_call_lhs (stmt);\n \n   if (!lhs)\n@@ -4214,7 +4286,7 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi, range_query *rvals)\n        or definitely unequal and if so, either fold the result to zero\n        (when equal) or set the range of the result to ~[0, 0] otherwise.  */\n     if (tree eqz = strxcmp_eqz_result (stmt, arg1, idx1, arg2, idx2, bound,\n-\t\t\t\t       len, &siz, rvals))\n+\t\t\t\t       len, &siz))\n       {\n \tif (integer_zerop (eqz))\n \t  {\n@@ -4230,7 +4302,7 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi, range_query *rvals)\n \t  }\n \t/* When the two strings are definitely equal (such as when they\n \t   are both empty) fold the call to the constant result.  */\n-\treplace_call_with_value (gsi, integer_zero_node);\n+\treplace_call_with_value (&m_gsi, integer_zero_node);\n \treturn true;\n       }\n   }\n@@ -4250,9 +4322,8 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi, range_query *rvals)\n     unsigned HOST_WIDE_INT arsz1, arsz2;\n     bool nulterm[2];\n \n-    if (!get_len_or_size (stmt, arg1, idx1, len1rng, &arsz1, nulterm, rvals)\n-\t|| !get_len_or_size (stmt, arg2, idx2, len2rng, &arsz2, nulterm + 1,\n-\t\t\t     rvals))\n+    if (!get_len_or_size (stmt, arg1, idx1, len1rng, &arsz1, nulterm)\n+\t|| !get_len_or_size (stmt, arg2, idx2, len2rng, &arsz2, nulterm + 1))\n       return false;\n \n     if (len1rng[0] == len1rng[1] && len1rng[0] < HOST_WIDE_INT_MAX)\n@@ -4300,7 +4371,7 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi, range_query *rvals)\n \t\t\t\t\t   : BUILT_IN_STRNCMP_EQ))\n \t{\n \t  tree n = build_int_cst (size_type_node, cmpsiz);\n-\t  update_gimple_call (gsi, fn, 3, arg1, arg2, n);\n+\t  update_gimple_call (&m_gsi, fn, 3, arg1, arg2, n);\n \t  return true;\n \t}\n     }\n@@ -4313,10 +4384,10 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi, range_query *rvals)\n    p = q + off is pointing to a '\\0' character of a string, call\n    zero_length_string on it.  */\n \n-static void\n-handle_pointer_plus (gimple_stmt_iterator *gsi)\n+void\n+strlen_pass::handle_pointer_plus ()\n {\n-  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (m_gsi);\n   tree lhs = gimple_assign_lhs (stmt), off;\n   int idx = get_stridx (gimple_assign_rhs1 (stmt));\n   strinfo *si, *zsi;\n@@ -4359,8 +4430,8 @@ handle_pointer_plus (gimple_stmt_iterator *gsi)\n       enum tree_code rhs_code\n \t= useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (si->endptr))\n \t  ? SSA_NAME : NOP_EXPR;\n-      gimple_assign_set_rhs_with_ops (gsi, rhs_code, si->endptr);\n-      gcc_assert (gsi_stmt (*gsi) == stmt);\n+      gimple_assign_set_rhs_with_ops (&m_gsi, rhs_code, si->endptr);\n+      gcc_assert (gsi_stmt (m_gsi) == stmt);\n       update_stmt (stmt);\n     }\n }\n@@ -4395,11 +4466,6 @@ nonzero_bytes_for_type (tree type, unsigned lenrange[3],\n   return true;\n }\n \n-static bool\n-count_nonzero_bytes_addr (tree, unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n-\t\t\t  unsigned [3], bool *, bool *, bool *,\n-\t\t\t  range_query *, ssa_name_limit_t &);\n-\n /* Recursively determine the minimum and maximum number of leading nonzero\n    bytes in the representation of EXP and set LENRANGE[0] and LENRANGE[1]\n    to each.\n@@ -4415,12 +4481,13 @@ count_nonzero_bytes_addr (tree, unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n    Avoids recursing deeper than the limits in SNLIM allow.\n    Returns true on success and false otherwise.  */\n \n-static bool\n-count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n-\t\t     unsigned HOST_WIDE_INT nbytes,\n-\t\t     unsigned lenrange[3], bool *nulterm,\n-\t\t     bool *allnul, bool *allnonnul, range_query *rvals,\n-\t\t     ssa_name_limit_t &snlim)\n+bool\n+strlen_pass::count_nonzero_bytes (tree exp,\n+\t\t\t\t  unsigned HOST_WIDE_INT offset,\n+\t\t\t\t  unsigned HOST_WIDE_INT nbytes,\n+\t\t\t\t  unsigned lenrange[3], bool *nulterm,\n+\t\t\t\t  bool *allnul, bool *allnonnul,\n+\t\t\t\t  ssa_name_limit_t &snlim)\n {\n   if (TREE_CODE (exp) == SSA_NAME)\n     {\n@@ -4436,7 +4503,7 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \t     for an arbitrary constant.  */\n \t  exp = build_int_cst (type, 1);\n \t  return count_nonzero_bytes (exp, offset, 1, lenrange,\n-\t\t\t\t      nulterm, allnul, allnonnul, rvals, snlim);\n+\t\t\t\t      nulterm, allnul, allnonnul, snlim);\n \t}\n \n       gimple *stmt = SSA_NAME_DEF_STMT (exp);\n@@ -4463,7 +4530,7 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \t    {\n \t      tree def = gimple_phi_arg_def (stmt, i);\n \t      if (!count_nonzero_bytes (def, offset, nbytes, lenrange, nulterm,\n-\t\t\t\t\tallnul, allnonnul, rvals, snlim))\n+\t\t\t\t\tallnul, allnonnul, snlim))\n \t\treturn false;\n \t    }\n \n@@ -4520,7 +4587,7 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \n       /* Handle MEM_REF = SSA_NAME types of assignments.  */\n       return count_nonzero_bytes_addr (arg, offset, nbytes, lenrange, nulterm,\n-\t\t\t\t       allnul, allnonnul, rvals, snlim);\n+\t\t\t\t       allnul, allnonnul, snlim);\n     }\n \n   if (VAR_P (exp) || TREE_CODE (exp) == CONST_DECL)\n@@ -4630,12 +4697,13 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n /* Like count_nonzero_bytes, but instead of counting bytes in EXP, count\n    bytes that are pointed to by EXP, which should be a pointer.  */\n \n-static bool\n-count_nonzero_bytes_addr (tree exp, unsigned HOST_WIDE_INT offset,\n-\t\t\t  unsigned HOST_WIDE_INT nbytes,\n-\t\t\t  unsigned lenrange[3], bool *nulterm,\n-\t\t\t  bool *allnul, bool *allnonnul,\n-\t\t\t  range_query *rvals, ssa_name_limit_t &snlim)\n+bool\n+strlen_pass::count_nonzero_bytes_addr (tree exp,\n+\t\t\t\t       unsigned HOST_WIDE_INT offset,\n+\t\t\t\t       unsigned HOST_WIDE_INT nbytes,\n+\t\t\t\t       unsigned lenrange[3], bool *nulterm,\n+\t\t\t\t       bool *allnul, bool *allnonnul,\n+\t\t\t\t       ssa_name_limit_t &snlim)\n {\n   int idx = get_stridx (exp);\n   if (idx > 0)\n@@ -4653,7 +4721,7 @@ count_nonzero_bytes_addr (tree exp, unsigned HOST_WIDE_INT offset,\n \t       && TREE_CODE (si->nonzero_chars) == SSA_NAME)\n \t{\n \t  value_range vr;\n-\t  rvals->range_of_expr (vr, si->nonzero_chars, si->stmt);\n+\t  ptr_qry.rvals->range_of_expr (vr, si->nonzero_chars, si->stmt);\n \t  if (vr.kind () != VR_RANGE)\n \t    return false;\n \n@@ -4700,8 +4768,7 @@ count_nonzero_bytes_addr (tree exp, unsigned HOST_WIDE_INT offset,\n \n   if (TREE_CODE (exp) == ADDR_EXPR)\n     return count_nonzero_bytes (TREE_OPERAND (exp, 0), offset, nbytes,\n-\t\t\t\tlenrange, nulterm, allnul, allnonnul, rvals,\n-\t\t\t\tsnlim);\n+\t\t\t\tlenrange, nulterm, allnul, allnonnul, snlim);\n \n   if (TREE_CODE (exp) == SSA_NAME)\n     {\n@@ -4720,7 +4787,7 @@ count_nonzero_bytes_addr (tree exp, unsigned HOST_WIDE_INT offset,\n \t    {\n \t      tree def = gimple_phi_arg_def (stmt, i);\n \t      if (!count_nonzero_bytes_addr (def, offset, nbytes, lenrange,\n-\t\t\t\t\t     nulterm, allnul, allnonnul, rvals,\n+\t\t\t\t\t     nulterm, allnul, allnonnul,\n \t\t\t\t\t     snlim))\n \t\treturn false;\n \t    }\n@@ -4746,9 +4813,10 @@ count_nonzero_bytes_addr (tree exp, unsigned HOST_WIDE_INT offset,\n    RVALS is used to determine ranges of dynamically computed string lengths\n    (the results of strlen).  */\n \n-static bool\n-count_nonzero_bytes (tree expr_or_type, unsigned lenrange[3], bool *nulterm,\n-\t\t     bool *allnul, bool *allnonnul, range_query *rvals)\n+bool\n+strlen_pass::count_nonzero_bytes (tree expr_or_type,\n+\t\t\t\t  unsigned lenrange[3], bool *nulterm,\n+\t\t\t\t  bool *allnul, bool *allnonnul)\n {\n   if (TYPE_P (expr_or_type))\n     return nonzero_bytes_for_type (expr_or_type, lenrange,\n@@ -4766,7 +4834,7 @@ count_nonzero_bytes (tree expr_or_type, unsigned lenrange[3], bool *nulterm,\n   ssa_name_limit_t snlim;\n   tree expr = expr_or_type;\n   return count_nonzero_bytes (expr, 0, 0, lenrange, nulterm, allnul, allnonnul,\n-\t\t\t      rvals, snlim);\n+\t\t\t      snlim);\n }\n \n /* Handle a single or multibyte store other than by a built-in function,\n@@ -4775,11 +4843,10 @@ count_nonzero_bytes (tree expr_or_type, unsigned lenrange[3], bool *nulterm,\n    '*(int*)a = 12345').  Return true to let the caller advance *GSI to\n    the next statement in the basic block and false otherwise.  */\n \n-static bool\n-handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n-\t      pointer_query &ptr_qry)\n+bool\n+strlen_pass::handle_store (bool *zero_write)\n {\n-  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (m_gsi);\n   /* The LHS and RHS of the store.  The RHS is null if STMT is a function\n      call.  STORETYPE is the type of the store (determined from either\n      the RHS of the assignment statement or the LHS of a function call.  */\n@@ -4830,8 +4897,8 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n \t      bool dummy;\n \t      unsigned lenrange[] = { UINT_MAX, 0, 0 };\n \t      if (count_nonzero_bytes (rhs ? rhs : storetype, lenrange,\n-\t\t\t\t       &dummy, &dummy, &dummy, rvals))\n-\t\tmaybe_warn_overflow (stmt, true, lenrange[2], ptr_qry);\n+\t\t\t\t       &dummy, &dummy, &dummy))\n+\t\tmaybe_warn_overflow (stmt, true, lenrange[2]);\n \n \t      return true;\n \t    }\n@@ -4863,16 +4930,15 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n \n   const bool ranges_valid\n     = count_nonzero_bytes (rhs ? rhs : storetype, lenrange, &full_string_p,\n-\t\t\t   &storing_all_zeros_p, &storing_all_nonzero_p,\n-\t\t\t   rvals);\n+\t\t\t   &storing_all_zeros_p, &storing_all_nonzero_p);\n \n   if (ranges_valid)\n     {\n       rhs_minlen = lenrange[0];\n       storing_nonzero_p = lenrange[1] > 0;\n       *zero_write = storing_all_zeros_p;\n \n-      maybe_warn_overflow (stmt, true, lenrange[2], ptr_qry);\n+      maybe_warn_overflow (stmt, true, lenrange[2]);\n     }\n   else\n     {\n@@ -4919,13 +4985,13 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n \t    {\n \t      unlink_stmt_vdef (stmt);\n \t      release_defs (stmt);\n-\t      gsi_remove (gsi, true);\n+\t      gsi_remove (&m_gsi, true);\n \t      return false;\n \t    }\n \t  else\n \t    {\n \t      si->writable = true;\n-\t      gsi_next (gsi);\n+\t      gsi_next (&m_gsi);\n \t      return false;\n \t    }\n \t}\n@@ -4959,7 +5025,7 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n \t       size_t len4 = strlen (q);    // can be folded to len2\n \t       bar (len, len2, len3, len4);\n \t       } */\n-\t  gsi_next (gsi);\n+\t  gsi_next (&m_gsi);\n \t  return false;\n \t}\n \n@@ -4990,7 +5056,7 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n \t    /* We're overwriting the nul terminator with a nonzero or\n \t       unknown character.  If the previous stmt was a memcpy,\n \t       its length may be decreased.  */\n-\t    adjust_last_stmt (si, stmt, false, ptr_qry);\n+\t    adjust_last_stmt (si, stmt, false);\n \t  si = unshare_strinfo (si);\n \t  if (storing_nonzero_p)\n \t    {\n@@ -5206,11 +5272,10 @@ is_char_type (tree type)\n    Return true to let the caller advance *GSI to the next statement\n    in the basic block and false otherwise.  */\n \n-static bool\n-strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n-\t\t\t\tpointer_query &ptr_qry)\n+bool\n+strlen_pass::check_and_optimize_call (bool *zero_write)\n {\n-  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (m_gsi);\n \n   if (!gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n     {\n@@ -5220,12 +5285,12 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n \n       if (lookup_attribute (\"alloc_size\", TYPE_ATTRIBUTES (fntype)))\n \t{\n-\t  handle_alloc_call (BUILT_IN_NONE, gsi);\n+\t  handle_alloc_call (BUILT_IN_NONE);\n \t  return true;\n \t}\n \n       if (tree lhs = gimple_call_lhs (stmt))\n-\thandle_assign (gsi, lhs, zero_write, ptr_qry);\n+\thandle_assign (lhs, zero_write);\n \n       /* Proceed to handle user-defined formatting functions.  */\n     }\n@@ -5236,68 +5301,68 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n   if (!flag_optimize_strlen\n       || !strlen_optimize\n       || !valid_builtin_call (stmt))\n-    return !handle_printf_call (gsi, ptr_qry);\n+    return !handle_printf_call (&m_gsi, ptr_qry);\n \n   tree callee = gimple_call_fndecl (stmt);\n   switch (DECL_FUNCTION_CODE (callee))\n     {\n     case BUILT_IN_STRLEN:\n     case BUILT_IN_STRNLEN:\n-      handle_builtin_strlen (gsi);\n+      handle_builtin_strlen ();\n       break;\n     case BUILT_IN_STRCHR:\n-      handle_builtin_strchr (gsi);\n+      handle_builtin_strchr ();\n       break;\n     case BUILT_IN_STRCPY:\n     case BUILT_IN_STRCPY_CHK:\n     case BUILT_IN_STPCPY:\n     case BUILT_IN_STPCPY_CHK:\n-      handle_builtin_strcpy (DECL_FUNCTION_CODE (callee), gsi, ptr_qry);\n+      handle_builtin_strcpy (DECL_FUNCTION_CODE (callee));\n       break;\n \n     case BUILT_IN_STRNCAT:\n     case BUILT_IN_STRNCAT_CHK:\n-      handle_builtin_strncat (DECL_FUNCTION_CODE (callee), gsi);\n+      handle_builtin_strncat (DECL_FUNCTION_CODE (callee));\n       break;\n \n     case BUILT_IN_STPNCPY:\n     case BUILT_IN_STPNCPY_CHK:\n     case BUILT_IN_STRNCPY:\n     case BUILT_IN_STRNCPY_CHK:\n-      handle_builtin_stxncpy_strncat (false, gsi);\n+      handle_builtin_stxncpy_strncat (false);\n       break;\n \n     case BUILT_IN_MEMCPY:\n     case BUILT_IN_MEMCPY_CHK:\n     case BUILT_IN_MEMPCPY:\n     case BUILT_IN_MEMPCPY_CHK:\n-      handle_builtin_memcpy (DECL_FUNCTION_CODE (callee), gsi, ptr_qry);\n+      handle_builtin_memcpy (DECL_FUNCTION_CODE (callee));\n       break;\n     case BUILT_IN_STRCAT:\n     case BUILT_IN_STRCAT_CHK:\n-      handle_builtin_strcat (DECL_FUNCTION_CODE (callee), gsi, ptr_qry);\n+      handle_builtin_strcat (DECL_FUNCTION_CODE (callee));\n       break;\n     case BUILT_IN_ALLOCA:\n     case BUILT_IN_ALLOCA_WITH_ALIGN:\n     case BUILT_IN_MALLOC:\n     case BUILT_IN_CALLOC:\n-      handle_alloc_call (DECL_FUNCTION_CODE (callee), gsi);\n+      handle_alloc_call (DECL_FUNCTION_CODE (callee));\n       break;\n     case BUILT_IN_MEMSET:\n-      if (handle_builtin_memset (gsi, zero_write, ptr_qry))\n+      if (handle_builtin_memset (zero_write))\n \treturn false;\n       break;\n     case BUILT_IN_MEMCMP:\n-      if (handle_builtin_memcmp (gsi))\n+      if (handle_builtin_memcmp ())\n \treturn false;\n       break;\n     case BUILT_IN_STRCMP:\n     case BUILT_IN_STRNCMP:\n-      if (handle_builtin_string_cmp (gsi, ptr_qry.rvals))\n+      if (handle_builtin_string_cmp ())\n \treturn false;\n       break;\n     default:\n-      if (handle_printf_call (gsi, ptr_qry))\n+      if (handle_printf_call (&m_gsi, ptr_qry))\n \treturn false;\n       break;\n     }\n@@ -5308,11 +5373,10 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n /* Handle an assignment statement at *GSI to a LHS of integral type.\n    If GSI's basic block needs clean-up of EH, set *CLEANUP_EH to true.  */\n \n-static void\n-handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n-\t\t\trange_query *rvals)\n+void\n+strlen_pass::handle_integral_assign (bool *cleanup_eh)\n {\n-  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (m_gsi);\n   tree lhs = gimple_assign_lhs (stmt);\n   tree lhs_type = TREE_TYPE (lhs);\n \n@@ -5381,11 +5445,11 @@ handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \t\t  /* Reading the final '\\0' character.  */\n \t\t  tree zero = build_int_cst (lhs_type, 0);\n \t\t  gimple_set_vuse (stmt, NULL_TREE);\n-\t\t  gimple_assign_set_rhs_from_tree (gsi, zero);\n+\t\t  gimple_assign_set_rhs_from_tree (&m_gsi, zero);\n \t\t  *cleanup_eh\n \t\t    |= maybe_clean_or_replace_eh_stmt (stmt,\n-\t\t\t\t\t\t       gsi_stmt (*gsi));\n-\t\t  stmt = gsi_stmt (*gsi);\n+\t\t\t\t\t\t       gsi_stmt (m_gsi));\n+\t\t  stmt = gsi_stmt (m_gsi);\n \t\t  update_stmt (stmt);\n \n \t\t  if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n@@ -5422,8 +5486,8 @@ handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \t  tree rhs = gimple_assign_rhs1 (stmt);\n \t  const bool ranges_valid\n \t    = count_nonzero_bytes (rhs, lenrange, &full_string_p,\n-\t\t\t\t   &storing_all_zeros_p, &storing_all_nonzero_p,\n-\t\t\t\t   rvals);\n+\t\t\t\t   &storing_all_zeros_p,\n+\t\t\t\t   &storing_all_nonzero_p);\n \t  if (ranges_valid)\n \t    {\n \t      tree length = build_int_cst (sizetype, lenrange[0]);\n@@ -5446,9 +5510,8 @@ handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n /* Handle assignment statement at *GSI to LHS.  Set *ZERO_WRITE if\n    the assignent stores all zero bytes..  */\n \n-static bool\n-handle_assign (gimple_stmt_iterator *gsi, tree lhs, bool *zero_write,\n-\t       pointer_query &ptr_qry)\n+bool\n+strlen_pass::handle_assign (tree lhs, bool *zero_write)\n {\n   tree type = TREE_TYPE (lhs);\n   if (TREE_CODE (type) == ARRAY_TYPE)\n@@ -5478,7 +5541,7 @@ handle_assign (gimple_stmt_iterator *gsi, tree lhs, bool *zero_write,\n     }\n \n   /* Handle a single or multibyte assignment.  */\n-  if (is_char_store && !handle_store (gsi, zero_write, ptr_qry))\n+  if (is_char_store && !handle_store (zero_write))\n     return false;\n \n   return true;\n@@ -5491,19 +5554,18 @@ handle_assign (gimple_stmt_iterator *gsi, tree lhs, bool *zero_write,\n    true.  Return true to let the caller advance *GSI to the next statement\n    in the basic block and false otherwise.  */\n \n-static bool\n-check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n-\t\t\t pointer_query &ptr_qry)\n+bool\n+strlen_pass::check_and_optimize_stmt (bool *cleanup_eh)\n {\n-  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *stmt = gsi_stmt (m_gsi);\n \n   /* For statements that modify a string, set to true if the write\n      is only zeros.  */\n   bool zero_write = false;\n \n   if (is_gimple_call (stmt))\n     {\n-      if (!strlen_check_and_optimize_call (gsi, &zero_write, ptr_qry))\n+      if (!check_and_optimize_call (&zero_write))\n \treturn false;\n     }\n   else if (!flag_optimize_strlen || !strlen_optimize)\n@@ -5524,13 +5586,13 @@ check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \t      ssa_ver_to_stridx[SSA_NAME_VERSION (lhs)] = idx;\n \t    }\n \t  else if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n-\t    handle_pointer_plus (gsi);\n+\t    handle_pointer_plus ();\n \t}\n       else if (TREE_CODE (lhs) == SSA_NAME && INTEGRAL_TYPE_P (lhs_type))\n \t/* Handle assignment to a character.  */\n-\thandle_integral_assign (gsi, cleanup_eh, ptr_qry.rvals);\n+\thandle_integral_assign (cleanup_eh);\n       else if (TREE_CODE (lhs) != SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n-\tif (!handle_assign (gsi, lhs, &zero_write, ptr_qry))\n+\tif (!handle_assign (lhs, &zero_write))\n \t  return false;\n     }\n   else if (gcond *cond = dyn_cast<gcond *> (stmt))\n@@ -5597,39 +5659,9 @@ do_invalidate (basic_block dombb, gimple *phi, bitmap visited, int *count)\n     }\n }\n \n-class strlen_dom_walker : public dom_walker\n-{\n-public:\n-  strlen_dom_walker (cdi_direction direction)\n-    : dom_walker (direction),\n-    evrp (false),\n-    ptr_qry (&evrp, &var_cache),\n-    var_cache (),\n-    m_cleanup_cfg (false)\n-  { }\n-\n-  ~strlen_dom_walker ();\n-\n-  virtual edge before_dom_children (basic_block);\n-  virtual void after_dom_children (basic_block);\n-\n-  /* EVRP analyzer used for printf argument range processing, and\n-     to track strlen results across integer variable assignments.  */\n-  evrp_range_analyzer evrp;\n-\n-  /* A pointer_query object and its cache to store information about\n-     pointers and their targets in.  */\n-  pointer_query ptr_qry;\n-  pointer_query::cache_type var_cache;\n-\n-  /* Flag that will trigger TODO_cleanup_cfg to be returned in strlen\n-     execute function.  */\n-  bool m_cleanup_cfg;\n-};\n-\n /* Release pointer_query cache.  */\n \n-strlen_dom_walker::~strlen_dom_walker ()\n+strlen_pass::~strlen_pass ()\n {\n   ptr_qry.flush_cache ();\n }\n@@ -5638,7 +5670,7 @@ strlen_dom_walker::~strlen_dom_walker ()\n    string ops by remembering string lengths pointed by pointer SSA_NAMEs.  */\n \n edge\n-strlen_dom_walker::before_dom_children (basic_block bb)\n+strlen_pass::before_dom_children (basic_block bb)\n {\n   evrp.enter (bb);\n \n@@ -5714,9 +5746,9 @@ strlen_dom_walker::before_dom_children (basic_block bb)\n   bool cleanup_eh = false;\n \n   /* Attempt to optimize individual statements.  */\n-  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n+  for (m_gsi = gsi_start_bb (bb); !gsi_end_p (m_gsi); )\n     {\n-      gimple *stmt = gsi_stmt (gsi);\n+      gimple *stmt = gsi_stmt (m_gsi);\n \n       /* First record ranges generated by this statement so they\n \t can be used by printf argument processing.  */\n@@ -5725,8 +5757,8 @@ strlen_dom_walker::before_dom_children (basic_block bb)\n       /* Reset search depth preformance counter.  */\n       ptr_qry.depth = 0;\n \n-      if (check_and_optimize_stmt (&gsi, &cleanup_eh, ptr_qry))\n-\tgsi_next (&gsi);\n+      if (check_and_optimize_stmt (&cleanup_eh))\n+\tgsi_next (&m_gsi);\n     }\n \n   if (cleanup_eh && gimple_purge_dead_eh_edges (bb))\n@@ -5742,7 +5774,7 @@ strlen_dom_walker::before_dom_children (basic_block bb)\n    owned by the current bb, clear bb->aux.  */\n \n void\n-strlen_dom_walker::after_dom_children (basic_block bb)\n+strlen_pass::after_dom_children (basic_block bb)\n {\n   evrp.leave (bb);\n \n@@ -5790,7 +5822,7 @@ printf_strlen_execute (function *fun, bool warn_only)\n \n   /* String length optimization is implemented as a walk of the dominator\n      tree and a forward walk of statements within each block.  */\n-  strlen_dom_walker walker (CDI_DOMINATORS);\n+  strlen_pass walker (CDI_DOMINATORS);\n   walker.walk (ENTRY_BLOCK_PTR_FOR_FN (fun));\n \n   if (dump_file && (dump_flags & TDF_DETAILS))"}]}