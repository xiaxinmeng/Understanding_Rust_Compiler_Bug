{"sha": "6fd1c67b8b4b139397e122ed9440da75fdab277c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZkMWM2N2I4YjRiMTM5Mzk3ZTEyMmVkOTQ0MGRhNzVmZGFiMjc3Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-02-02T19:28:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-02-02T19:28:57Z"}, "message": "expr.c (expand_builtin_setjmp): Accept two new arguments for the labels to branch to on first and subsequent...\n\n * expr.c (expand_builtin_setjmp): Accept two new arguments for\n the labels to branch to on first and subsequent executions.  Don't\n play with __dummy.  Rename `setjmp' insn to `builtin_setjmp_setup',\n and provide it with the jmp_buf.  Use only one of\n `builtin_setjmp_receiver' or `nonlocal_goto_receiver',\n and provide the former with the target label.\n (expand_builtin) [BUILTIN_SETJMP]: Generate a label for use by setjmp.\n (expand_builtin) [BUILTIN_LONGJMP]: Split out to ...\n (expand_builtin_longjmp): ... here.  Recognize a `builtin_longjmp'\n insn to replace all of the normal nonlocal_goto code.  Don't play\n with __dummy.  Correct arguments to nonlocal_goto.\n * expr.h (expand_builtin_setjmp): Update prototype.\n * except.c (start_dynamic_handler): When using builtin_setjmp,\n generate more accurate flow information.\n * alpha.md (nonlocal_goto_receiver_osf): Delete.\n (nonlocal_goto_receiver_vms): Rename to nonlocal_goto_receiver.\n (builtin_longjmp, builtin_setjmp_receiver): New.\n * sparc.md (update_return): Disambiguate unspec number.\n (nonlocal_goto): Rearrange arguments to match caller in except.c.\n (builtin_setjmp_setup): Rename from setjmp.  Match and ignore the\n jmp_buf operand.\n * mips.md (nonlocal_goto_receiver, builtin_setjmp_receiver): Remove.\n (builtin_setjmp_setup*, builtin_longjmp): New.\n\nFrom-SVN: r17602", "tree": {"sha": "6fde390bee19acf841e5ec6c02e403d195086099", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fde390bee19acf841e5ec6c02e403d195086099"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fd1c67b8b4b139397e122ed9440da75fdab277c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd1c67b8b4b139397e122ed9440da75fdab277c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fd1c67b8b4b139397e122ed9440da75fdab277c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd1c67b8b4b139397e122ed9440da75fdab277c/comments", "author": null, "committer": null, "parents": [{"sha": "95936d18c112aa1935ee7c9338857aaa3481beb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95936d18c112aa1935ee7c9338857aaa3481beb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95936d18c112aa1935ee7c9338857aaa3481beb1"}], "stats": {"total": 456, "additions": 265, "deletions": 191}, "files": [{"sha": "3c23a831467a09a79190564f281e87d0c255fd11", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fd1c67b8b4b139397e122ed9440da75fdab277c", "patch": "@@ -1,3 +1,30 @@\n+Mon Feb  2 19:18:14 1998  Richard Henderson  <rth@cygnus.com>\n+\n+        * expr.c (expand_builtin_setjmp): Accept two new arguments for\n+        the labels to branch to on first and subsequent executions.  Don't\n+        play with __dummy.  Rename `setjmp' insn to `builtin_setjmp_setup',\n+\tand provide it with the jmp_buf.  Use only one of\n+\t`builtin_setjmp_receiver' or `nonlocal_goto_receiver',\n+        and provide the former with the target label.\n+        (expand_builtin) [BUILTIN_SETJMP]: Generate a label for use by setjmp.\n+        (expand_builtin) [BUILTIN_LONGJMP]: Split out to ...\n+        (expand_builtin_longjmp): ... here.  Recognize a `builtin_longjmp'\n+        insn to replace all of the normal nonlocal_goto code.  Don't play\n+\twith __dummy.  Correct arguments to nonlocal_goto.\n+        * expr.h (expand_builtin_setjmp): Update prototype.\n+        * except.c (start_dynamic_handler): When using builtin_setjmp,\n+        generate more accurate flow information.\n+\n+        * alpha.md (nonlocal_goto_receiver_osf): Delete.\n+        (nonlocal_goto_receiver_vms): Rename to nonlocal_goto_receiver.\n+        (builtin_longjmp, builtin_setjmp_receiver): New.\n+        * sparc.md (update_return): Disambiguate unspec number.\n+        (nonlocal_goto): Rearrange arguments to match caller in except.c.\n+        (builtin_setjmp_setup): Rename from setjmp.  Match and ignore the\n+        jmp_buf operand.\n+\t* mips.md (nonlocal_goto_receiver, builtin_setjmp_receiver): Remove.\n+\t(builtin_setjmp_setup*, builtin_longjmp): New.\n+\n Mon Feb  2 16:43:10 1998  John Carr  <jfc@mit.edu>\n \n \t* mips.md: Change gen_rtx (CONST_INT) to GEN_INT."}, {"sha": "b1cbc3bcbfdb9047913089a10f847b2f3fabc3eb", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=6fd1c67b8b4b139397e122ed9440da75fdab277c", "patch": "@@ -5050,34 +5050,43 @@\n     }\n }\")\n \n-;; Ideally we should be able to define nonlocal_goto and arrange\n-;; for the pc to be in a known place.  Or perhaps branch back via\n-;; br instead of jmp.\n-(define_insn \"nonlocal_goto_receiver_osf\"\n-  [(unspec_volatile [(const_int 0)] 2)]\n+(define_expand \"builtin_longjmp\"\n+  [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")] 3)]\n   \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n-  \"br $29,$LGOTO%=\\\\n$LGOTO%=:\\;ldgp $29,0($29)\")\n+  \"\n+{\n+  /* The elements of the buffer are, in order:  */\n+  rtx fp = gen_rtx_MEM (Pmode, operands[0]);\n+  rtx lab = gen_rtx_MEM (Pmode, plus_constant (operands[0], 8));\n+  rtx stack = gen_rtx_MEM (Pmode, plus_constant (operands[0], 16));\n+  rtx pv = gen_rtx_REG (Pmode, 27);\n+\n+  /* This bit is the same as expand_builtin_longjmp.  */\n+  emit_move_insn (hard_frame_pointer_rtx, fp);\n+  emit_move_insn (pv, lab);\n+  emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n+  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n+  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n+\n+  /* Load the label we are jumping through into $27 so that we know\n+     where to look for it when we get back to setjmp's function for\n+     restoring the gp.  */\n+  emit_indirect_jump (pv);\n+}\")\n \n-(define_expand \"nonlocal_goto_receiver_vms\"\n+(define_insn \"builtin_setjmp_receiver\"\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] 2)]\n+  \"! TARGET_OPEN_VMS && ! TARGET_WINDOWS_NT\"\n+  \"\\\\n$LSJ%=:\\;ldgp $29,$LSJ%=-%l0($27)\")\n+\n+(define_expand \"nonlocal_goto_receiver\"\n   [(unspec_volatile [(const_int 0)] 1)\n    (set (reg:DI 27) (mem:DI (reg:DI 29)))\n    (unspec_volatile [(const_int 0)] 1)\n    (use (reg:DI 27))]\n   \"TARGET_OPEN_VMS\"\n   \"\")\n \n-(define_expand \"nonlocal_goto_receiver\"\n-  [(unspec_volatile [(const_int 0)] 2)]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_OPEN_VMS)\n-    emit_insn(gen_nonlocal_goto_receiver_vms ());\n-  else if (!TARGET_WINDOWS_NT)\n-    emit_insn(gen_nonlocal_goto_receiver_osf ());\n-  DONE;\n-}\")\n-\n (define_insn \"arg_home\"\n   [(unspec [(const_int 0)] 0)\n    (use (reg:DI 1))"}, {"sha": "10c0bfe261bf1365e5ca779ce3d2dae772cfbf6d", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 51, "deletions": 22, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=6fd1c67b8b4b139397e122ed9440da75fdab277c", "patch": "@@ -8820,35 +8820,64 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"6\")])\n \n-;; ??? This is a hack to work around a problem with expand_builtin_setjmp.\n-;; It restores the frame pointer, and then does a call to restore the global\n-;; pointer (gp) register.  The call insn implicitly (via the assembler) reloads\n-;; gp from the stack.  However, call insns do not depend on $fp, so it is\n-;; possible for the instruction scheduler to move the fp restore after the\n-;; call, which then causes gp to be corrupted.  We fix this by emitting a\n-;; scheduler barrier.  A better fix is to put code here that restores the\n-;; $gp, and then the call is unnecessary.  This is only a problem when PIC\n-;; (TARGET_ABICALLS), and only when the gp register is caller-saved\n-;; (irix5/o32, but not irix6/n32/n64).\n-\n-(define_expand \"nonlocal_goto_receiver\"\n-  [(const_int 0)]\n-  \"\"\n+;; For o32/n32/n64, we save the gp in the jmp_buf as well.  While it is\n+;; possible to either pull it off the stack (in the o32 case) or recalculate\n+;; it given t9 and our target label, it takes 3 or 4 insns to do so, and\n+;; this is easy.\n+\n+(define_expand \"builtin_setjmp_setup\"\n+  [(unspec [(match_operand 0 \"register_operand\" \"r\")] 20)]\n+  \"TARGET_ABICALLS\"\n   \"\n {\n-  emit_insn (gen_blockage ());\n+  if (TARGET_LONG64)\n+    emit_insn (gen_builtin_setjmp_setup_64 (operands[0]));\n+  else\n+    emit_insn (gen_builtin_setjmp_setup_32 (operands[0]));\n+  DONE;\n }\")\n \n-;; For n32/n64, we need to restore gp after a builtin setjmp.   We do this\n-;; by making use of the fact that we've just called __dummy.\n+(define_expand \"builtin_setjmp_setup_32\"\n+  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t   (const_int 12)))\n+      (reg:SI 28))]\n+  \"TARGET_ABICALLS && ! TARGET_LONG64\"\n+  \"\")\n \n-(define_expand \"builtin_setjmp_receiver\"\n-  [(const_int 0)]\n-  \"TARGET_ABICALLS && mips_abi != ABI_32\"\n+(define_expand \"builtin_setjmp_setup_64\"\n+  [(set (mem:DI (plus:DI (match_operand:DI 0 \"register_operand\" \"r\")\n+\t\t   (const_int 24)))\n+      (reg:DI 28))]\n+  \"TARGET_ABICALLS && TARGET_LONG64\"\n+  \"\")\n+\n+;; For o32/n32/n64, we need to arrange for longjmp to put the \n+;; target address in t9 so that we can use it for loading $gp.\n+\n+(define_expand \"builtin_longjmp\"\n+  [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")] 3)]\n+  \"TARGET_ABICALLS\"\n   \"\n {\n-  emit_insn (gen_loadgp (gen_rtx (SYMBOL_REF, Pmode, \\\"__dummy\\\")));\n-  emit_insn (gen_blockage ());\n+  /* The elements of the buffer are, in order:  */\n+  int W = (TARGET_LONG64 ? 8 : 4);\n+  rtx fp = gen_rtx_MEM (Pmode, operands[0]);\n+  rtx lab = gen_rtx_MEM (Pmode, plus_constant (operands[0], 1*W));\n+  rtx stack = gen_rtx_MEM (Pmode, plus_constant (operands[0], 2*W));\n+  rtx gpv = gen_rtx_MEM (Pmode, plus_constant (operands[0], 3*W));\n+  rtx pv = gen_rtx_REG (Pmode, 25);\n+  rtx gp = gen_rtx_REG (Pmode, 28);\n+\n+  /* This bit is the same as expand_builtin_longjmp.  */\n+  emit_move_insn (hard_frame_pointer_rtx, fp);\n+  emit_move_insn (pv, lab);\n+  emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n+  emit_move_insn (gp, gpv);\n+  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n+  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n+  emit_insn (gen_rtx_USE (VOIDmode, gp));\n+  emit_indirect_jump (pv);\n+  DONE;\n }\")\n \f\n ;;"}, {"sha": "cf3c6c524f9433233594bd632d5a0de03ac9e2bb", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=6fd1c67b8b4b139397e122ed9440da75fdab277c", "patch": "@@ -5640,7 +5640,7 @@\n \n (define_insn \"update_return\"\n   [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n-\t       (match_operand:SI 1 \"register_operand\" \"r\")] 0)]\n+\t       (match_operand:SI 1 \"register_operand\" \"r\")] 1)]\n   \"! TARGET_ARCH64\"\n   \"cmp %1,0\\;be,a .+8\\;add %0,4,%0\"\n   [(set_attr \"type\" \"multi\")])\n@@ -5676,32 +5676,40 @@\n \n ;; ??? Doesn't work with -mflat.\n (define_expand \"nonlocal_goto\"\n-  [(match_operand:SI 0 \"general_operand\" \"\")\n+  [(match_operand:SI 0 \"\" \"\")\n    (match_operand:SI 1 \"general_operand\" \"\")\n    (match_operand:SI 2 \"general_operand\" \"\")\n-   (match_operand:SI 3 \"\" \"\")]\n+   (match_operand:SI 3 \"general_operand\" \"\")]\n   \"\"\n   \"\n {\n+  rtx chain = operands[0];\n+  rtx fp = operands[1];\n+  rtx stack = operands[2];\n+  rtx lab = operands[3];\n+\n   /* Trap instruction to flush all the register windows.  */\n   emit_insn (gen_flush_register_windows ());\n-  /* Load the fp value for the containing fn into %fp.\n-     This is needed because operands[2] refers to %fp.\n-     Virtual register instantiation fails if the virtual %fp isn't set from a\n-     register.  Thus we must copy operands[0] into a register if it isn't\n-     already one.  */\n-  if (GET_CODE (operands[0]) != REG)\n-    operands[0] = force_reg (Pmode, operands[0]);\n-  emit_move_insn (virtual_stack_vars_rtx, operands[0]);\n+\n+  /* Load the fp value for the containing fn into %fp.  This is needed\n+     because STACK refers to %fp.  Note that virtual register instantiation\n+     fails if the virtual %fp isn't set from a register.  */\n+  if (GET_CODE (fp) != REG)\n+    fp = force_reg (Pmode, fp);\n+  emit_move_insn (virtual_stack_vars_rtx, fp);\n+\n   /* Find the containing function's current nonlocal goto handler,\n      which will do any cleanups and then jump to the label.  */\n-  emit_move_insn (gen_rtx (REG, Pmode, 8), operands[1]);\n+  emit_move_insn (gen_rtx (REG, Pmode, 8), lab);\n+\n   /* Restore %fp from stack pointer value for containing function.\n      The restore insn that follows will move this to %sp,\n      and reload the appropriate value into %fp.  */\n-  emit_move_insn (frame_pointer_rtx, operands[2]);\n+  emit_move_insn (frame_pointer_rtx, stack);\n+\n   /* Put in the static chain register the nonlocal label address.  */\n-  emit_move_insn (static_chain_rtx, operands[3]);\n+  emit_move_insn (static_chain_rtx, chain);\n+\n   /* USE of frame_pointer_rtx added for consistency; not clear if\n      really needed.  */\n   emit_insn (gen_rtx (USE, VOIDmode, frame_pointer_rtx));\n@@ -5729,19 +5737,17 @@\n   [(set_attr \"type\" \"misc\")\n    (set_attr \"length\" \"2\")])\n \n-;; Pattern for use after a setjmp to store FP and the return register\n-;; into the stack area.\n+;; Implement setjmp.  Step one, set up the buffer.\n \n-(define_expand \"setjmp\"\n-  [(const_int 0)]\n+(define_expand \"builtin_setjmp_setup\"\n+  [(unspec [(match_operand 0 \"\" \"\")] 3)]\n   \"\"\n   \"\n {\n   if (TARGET_ARCH64)\n     emit_insn (gen_setjmp_64 ());\n   else\n     emit_insn (gen_setjmp_32 ());\n-\n   DONE;\n }\")\n "}, {"sha": "12abb103d659bfed1960aafaa0f2ae26223c1018", "filename": "gcc/except.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6fd1c67b8b4b139397e122ed9440da75fdab277c", "patch": "@@ -945,15 +945,18 @@ start_dynamic_handler ()\n #ifdef DONT_USE_BUILTIN_SETJMP\n   x = emit_library_call_value (setjmp_libfunc, NULL_RTX, 1, SImode, 1,\n \t\t\t       buf, Pmode);\n+  /* If we come back here for a catch, transfer control to the handler.  */\n+  jumpif_rtx (x, ehstack.top->entry->exception_handler_label);\n #else\n-  x = expand_builtin_setjmp (buf, NULL_RTX);\n+  {\n+    /* A label to continue execution for the no exception case.  */\n+    rtx noex = gen_label_rtx();\n+    x = expand_builtin_setjmp (buf, NULL_RTX, noex,\n+\t\t\t       ehstack.top->entry->exception_handler_label);\n+    emit_label (noex);\n+  }\n #endif\n \n-  /* If we come back here for a catch, transfer control to the\n-     handler.  */\n-\n-  jumpif_rtx (x, ehstack.top->entry->exception_handler_label);\n-\n   /* We are committed to this, so update the handler chain.  */\n \n   emit_move_insn (dhc, XEXP (arg, 0));"}, {"sha": "4d927d73052a1072234b1935079ea1de7a5e4196", "filename": "gcc/expr.c", "status": "modified", "additions": 124, "deletions": 124, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6fd1c67b8b4b139397e122ed9440da75fdab277c", "patch": "@@ -7613,20 +7613,16 @@ expand_builtin_return_addr (fndecl_code, count, tem)\n    them.  */\n \n rtx\n-expand_builtin_setjmp (buf_addr, target)\n+expand_builtin_setjmp (buf_addr, target, first_label, next_label)\n      rtx buf_addr;\n      rtx target;\n+     rtx first_label, next_label;\n {\n-  rtx lab1 = gen_label_rtx (), lab2 = gen_label_rtx ();\n+  rtx lab1 = gen_label_rtx ();\n   enum machine_mode sa_mode = Pmode, value_mode;\n   rtx stack_save;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n-  int return_pops\n-    =  RETURN_POPS_ARGS (get_identifier (\"__dummy\"),\n-\t\t\t build_function_type (void_type_node, NULL_TREE),\n-\t\t\t 0);\n   rtx next_arg_reg;\n-  CUMULATIVE_ARGS args_so_far;\n   rtx op0;\n   int i;\n \n@@ -7649,11 +7645,11 @@ expand_builtin_setjmp (buf_addr, target)\n      machine-dependent.  */\n   emit_move_insn (gen_rtx_MEM (Pmode, buf_addr),\n \t\t  virtual_stack_vars_rtx);\n-  emit_move_insn\n-    (validize_mem (gen_rtx_MEM (Pmode,\n+  emit_move_insn (validize_mem\n+\t\t  (gen_rtx_MEM (Pmode,\n \t\t\t\tplus_constant (buf_addr,\n \t\t\t\t\t       GET_MODE_SIZE (Pmode)))),\n-     gen_rtx_LABEL_REF (Pmode, lab1));\n+\t\t  gen_rtx_LABEL_REF (Pmode, lab1));\n \n #ifdef HAVE_save_stack_nonlocal\n   if (HAVE_save_stack_nonlocal)\n@@ -7665,19 +7661,23 @@ expand_builtin_setjmp (buf_addr, target)\n \t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n   emit_stack_save (SAVE_NONLOCAL, &stack_save, NULL_RTX);\n \n-#ifdef HAVE_setjmp\n-  if (HAVE_setjmp)\n-    emit_insn (gen_setjmp ());\n+  /* If there is further processing to do, do it.  */\n+#ifdef HAVE_builtin_setjmp_setup\n+  if (HAVE_builtin_setjmp_setup)\n+    emit_insn (gen_builtin_setjmp_setup (buf_addr));\n #endif\n \n-  /* Set TARGET to zero and branch around the other case.  */\n+  /* Set TARGET to zero and branch to the first-time-through label.  */\n   emit_move_insn (target, const0_rtx);\n-  emit_jump_insn (gen_jump (lab2));\n+  emit_jump_insn (gen_jump (first_label));\n   emit_barrier ();\n   emit_label (lab1);\n \n-  /* Note that setjmp clobbers FP when we get here, so we have to make\n-     sure it's marked as used by this function.  */\n+  /* Tell flow about the strange goings on.  */\n+  current_function_has_nonlocal_label = 1;\n+\n+  /* Clobber the FP when we get here, so we have to make sure it's\n+     marked as used by this function.  */\n   emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n \n   /* Mark the static chain as clobbered here so life information\n@@ -7692,8 +7692,6 @@ expand_builtin_setjmp (buf_addr, target)\n #endif\n     emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n \n-  current_function_has_nonlocal_label = 1;\n-\n #if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n   if (fixed_regs[ARG_POINTER_REGNUM])\n     {\n@@ -7721,49 +7719,107 @@ expand_builtin_setjmp (buf_addr, target)\n     }\n #endif\n \n+#ifdef HAVE_builtin_setjmp_receiver\n+  if (HAVE_builtin_setjmp_receiver)\n+    emit_insn (gen_builtin_setjmp_receiver (lab1));\n+  else\n+#endif\n #ifdef HAVE_nonlocal_goto_receiver\n-  if (HAVE_nonlocal_goto_receiver)\n-    emit_insn (gen_nonlocal_goto_receiver ());\n+    if (HAVE_nonlocal_goto_receiver)\n+      emit_insn (gen_nonlocal_goto_receiver ());\n+    else\n #endif\n-  /* The static chain pointer contains the address of dummy function.\n-     We need to call it here to handle some PIC cases of restoring a\n-     global pointer.  Then return 1.  */\n-  op0 = copy_to_mode_reg (Pmode, static_chain_rtx);\n+      ; /* Nothing */\n+\n+  /* Set TARGET, and branch to the next-time-through label.  */\n+  emit_move_insn (target, gen_lowpart (GET_MODE (target), static_chain_rtx));\n+  emit_jump_insn (gen_jump (next_label));\n+  emit_barrier ();\n \n-  /* We can't actually call emit_library_call here, so do everything\n-     it does, which isn't much for a libfunc with no args.  */\n-  op0 = memory_address (FUNCTION_MODE, op0);\n+  return target;\n+}\n \n-  INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE,\n-\t\t\tgen_rtx_SYMBOL_REF (Pmode, \"__dummy\"), 1);\n-  next_arg_reg = FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1);\n+void\n+expand_builtin_longjmp (buf_addr, value)\n+     rtx buf_addr, value;\n+{\n+  rtx fp, lab, stack;\n+  enum machine_mode sa_mode;\n \n-#ifndef ACCUMULATE_OUTGOING_ARGS\n-#ifdef HAVE_call_pop\n-  if (HAVE_call_pop)\n-    emit_call_insn (gen_call_pop (gen_rtx_MEM (FUNCTION_MODE, op0),\n-\t\t\t\t  const0_rtx, next_arg_reg,\n-\t\t\t\t  GEN_INT (return_pops)));\n-  else\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+  buf_addr = convert_memory_address (Pmode, buf_addr);\n #endif\n+  buf_addr = force_reg (Pmode, buf_addr);\n+\n+  /* The value sent by longjmp is not allowed to be zero.  Force it\n+     to one if so.  */\n+  if (GET_CODE (value) == CONST_INT)\n+    {\n+      if (INTVAL (value) == 0)\n+\tvalue = const1_rtx;\n+    }\n+  else\n+    {\n+      lab = gen_label_rtx ();\n+\n+      emit_cmp_insn (value, const0_rtx, NE, NULL_RTX, GET_MODE (value), 0, 0);\n+      emit_jump_insn (gen_bne (lab));\n+      emit_move_insn (value, const1_rtx);\n+      emit_label (lab);\n+    }\n+\n+  /* Make sure the value is in the right mode to be copied to the chain.  */\n+  if (GET_MODE (value) != VOIDmode)\n+    value = gen_lowpart (GET_MODE (static_chain_rtx), value);\n+\n+#ifdef HAVE_builtin_longjmp\n+  if (HAVE_builtin_longjmp)\n+    {\n+      /* Copy the \"return value\" to the static chain reg.  */\n+      emit_move_insn (static_chain_rtx, value);\n+      emit_insn (gen_rtx_USE (VOIDmode, static_chain_rtx));\n+      emit_insn (gen_builtin_longjmp (buf_addr));\n+    }\n+  else\n #endif\n+    {\n+      fp = gen_rtx_MEM (Pmode, buf_addr);\n+      lab = gen_rtx_MEM (Pmode, plus_constant (buf_addr,\n+\t\t\t\t\t       GET_MODE_SIZE (Pmode)));\n \n-#ifdef HAVE_call\n-    if (HAVE_call)\n-      emit_call_insn (gen_call (gen_rtx_MEM (FUNCTION_MODE, op0),\n-\t\t\t\tconst0_rtx, next_arg_reg, const0_rtx));\n-    else\n+#ifdef HAVE_save_stack_nonlocal\n+      sa_mode = (HAVE_save_stack_nonlocal\n+\t\t ? insn_operand_mode[(int) CODE_FOR_save_stack_nonlocal][0]\n+\t\t : Pmode);\n+#else\n+      sa_mode = Pmode;\n #endif\n-      abort ();\n \n-#ifdef HAVE_builtin_setjmp_receiver\n-  if (HAVE_builtin_setjmp_receiver)\n-    emit_insn (gen_builtin_setjmp_receiver ());\n+      stack = gen_rtx_MEM (sa_mode, plus_constant (buf_addr,\n+\t\t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n+\n+      /* Pick up FP, label, and SP from the block and jump.  This code is\n+\t from expand_goto in stmt.c; see there for detailed comments.  */\n+#if HAVE_nonlocal_goto\n+      if (HAVE_nonlocal_goto)\n+\temit_insn (gen_nonlocal_goto (value, fp, stack, lab));\n+      else\n #endif\n+\t{\n+\t  lab = copy_to_reg (lab);\n \n-  emit_move_insn (target, const1_rtx);\n-  emit_label (lab2);\n-  return target;\n+\t  /* Copy the \"return value\" to the static chain reg.  */\n+\t  emit_move_insn (static_chain_rtx, value);\n+\n+\t  emit_move_insn (hard_frame_pointer_rtx, fp);\n+\t  emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n+\n+\t  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n+\t  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n+\t  emit_insn (gen_rtx_USE (VOIDmode, static_chain_rtx));\n+\t  emit_indirect_jump (lab);\n+\t}\n+    }\n }\n \n \f\n@@ -8676,89 +8732,33 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       if (arglist == 0\n \t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n \tbreak;\n+      else\n+\t{\n+\t  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,\n+\t\t\t\t      VOIDmode, 0);\n+\t  rtx lab = gen_label_rtx ();\n+\t  rtx ret = expand_builtin_setjmp (buf_addr, target, lab, lab);\n+\t  emit_label (lab);\n+\t  return ret;\n+\t}\n \n-      {\n-\trtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,\n-\t\t\t\t    VOIDmode, 0);\n-\treturn expand_builtin_setjmp (buf_addr, target);\n-      }\n-\n-      /* __builtin_longjmp is passed a pointer to an array of five words\n-\t and a value, which is a dummy.  It's similar to the C library longjmp\n-\t function but works with __builtin_setjmp above.  */\n+      /* __builtin_longjmp is passed a pointer to an array of five words.\n+\t It's similar to the C library longjmp function but works with\n+\t __builtin_setjmp above.  */\n     case BUILT_IN_LONGJMP:\n       if (arglist == 0 || TREE_CHAIN (arglist) == 0\n \t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n \tbreak;\n-\n-      {\n-\ttree dummy_id = get_identifier (\"__dummy\");\n-\ttree dummy_type = build_function_type (void_type_node, NULL_TREE);\n-\ttree dummy_decl = build_decl (FUNCTION_DECL, dummy_id, dummy_type); \n-#ifdef POINTERS_EXTEND_UNSIGNED\n-\trtx buf_addr\n-\t  = force_reg (Pmode,\n-\t\t       convert_memory_address\n-\t\t       (Pmode,\n-\t\t\texpand_expr (TREE_VALUE (arglist),\n-\t\t\t\t     NULL_RTX, VOIDmode, 0)));\n-#else\n-\trtx buf_addr\n-\t  = force_reg (Pmode, expand_expr (TREE_VALUE (arglist),\n-\t\t\t\t\t   NULL_RTX,\n-\t\t\t\t\t   VOIDmode, 0));\n-#endif\n-\trtx fp = gen_rtx_MEM (Pmode, buf_addr);\n-\trtx lab = gen_rtx_MEM (Pmode,\n-\t\t\t       plus_constant (buf_addr,\n-\t\t\t\t\t      GET_MODE_SIZE (Pmode)));\n-\tenum machine_mode sa_mode\n-#ifdef HAVE_save_stack_nonlocal\n-\t  = (HAVE_save_stack_nonlocal\n-\t     ? insn_operand_mode[(int) CODE_FOR_save_stack_nonlocal][0]\n-\t     : Pmode);\n-#else\n-\t= Pmode;\n-#endif\n-\trtx stack = gen_rtx_MEM (sa_mode,\n-\t\t\t\t plus_constant (buf_addr,\n-\t\t\t\t\t\t2 * GET_MODE_SIZE (Pmode)));\n-\n-\tDECL_EXTERNAL (dummy_decl) = 1;\n-\tTREE_PUBLIC (dummy_decl) = 1;\n-\tmake_decl_rtl (dummy_decl, NULL_PTR, 1);\n-\n-\t/* Expand the second expression just for side-effects.  */\n-\texpand_expr (TREE_VALUE (TREE_CHAIN (arglist)),\n-\t\t     const0_rtx, VOIDmode, 0);\n-\n-\tassemble_external (dummy_decl);\n-\n-\t/* Pick up FP, label, and SP from the block and jump.  This code is\n-\t   from expand_goto in stmt.c; see there for detailed comments.  */\n-#if HAVE_nonlocal_goto\n-\tif (HAVE_nonlocal_goto)\n-\t  emit_insn (gen_nonlocal_goto (fp, lab, stack,\n-\t\t\t\t\tXEXP (DECL_RTL (dummy_decl), 0)));\n       else\n-#endif\n \t{\n-\t  lab = copy_to_reg (lab);\n-\t  emit_move_insn (hard_frame_pointer_rtx, fp);\n-\t  emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n-\n-\t  /* Put in the static chain register the address of the dummy\n-\t     function.  */\n-\t  emit_move_insn (static_chain_rtx, XEXP (DECL_RTL (dummy_decl), 0));\n-\t  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n-\t  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n-\t  emit_insn (gen_rtx_USE (VOIDmode, static_chain_rtx));\n-\t  emit_indirect_jump (lab);\n+\t  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,\n+\t\t\t\t      VOIDmode, 0);\n+\t  rtx value = expand_expr (TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t\t   const0_rtx, VOIDmode, 0);\n+\t  expand_builtin_longjmp (buf_addr, value);\n+\t  return const0_rtx;\n \t}\n \n-\treturn const0_rtx;\n-      }\n-\n       /* Various hooks for the DWARF 2 __throw routine.  */\n     case BUILT_IN_UNWIND_INIT:\n       expand_builtin_unwind_init ();"}, {"sha": "080992f3dd953b6bca5d3ff0d229ba4526443879", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd1c67b8b4b139397e122ed9440da75fdab277c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=6fd1c67b8b4b139397e122ed9440da75fdab277c", "patch": "@@ -752,7 +752,7 @@ extern rtx store_expr PROTO((tree, rtx, int));\n    Useful after calling expand_expr with 1 as sum_ok.  */\n extern rtx force_operand PROTO((rtx, rtx));\n \n-extern rtx expand_builtin_setjmp PROTO((rtx, rtx));\n+extern rtx expand_builtin_setjmp PROTO((rtx, rtx, rtx, rtx));\n \n #ifdef TREE_CODE\n /* Generate code for computing expression EXP."}]}