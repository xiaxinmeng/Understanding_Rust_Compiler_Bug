{"sha": "73a08f87174affa40571a17dbeba247adc358fa0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNhMDhmODcxNzRhZmZhNDA1NzFhMTdkYmViYTI0N2FkYzM1OGZhMA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2005-11-07T07:45:35Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-11-07T07:45:35Z"}, "message": "splay-tree.c (rotate_left): New function.\n\n2005-11-07  Richard Guenther  <rguenther@suse.de>\n\n\t* splay-tree.c (rotate_left): New function.\n\t(rotate_right): Likewise.\n\t(splay_tree_splay_helper): Remove.\n\t(splay_tree_splay): Re-implement.\n\nFrom-SVN: r106584", "tree": {"sha": "62e2bfe5ec7f64a63d8331a7c0ec88949cc69bd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62e2bfe5ec7f64a63d8331a7c0ec88949cc69bd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73a08f87174affa40571a17dbeba247adc358fa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a08f87174affa40571a17dbeba247adc358fa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73a08f87174affa40571a17dbeba247adc358fa0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a08f87174affa40571a17dbeba247adc358fa0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd159af7b3d3dd3a8521ff86fbb8756f0a157cbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd159af7b3d3dd3a8521ff86fbb8756f0a157cbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd159af7b3d3dd3a8521ff86fbb8756f0a157cbf"}], "stats": {"total": 198, "additions": 87, "deletions": 111}, "files": [{"sha": "6fdeba3e85214c0753651fcad2b9b19ca99883ba", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a08f87174affa40571a17dbeba247adc358fa0/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a08f87174affa40571a17dbeba247adc358fa0/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=73a08f87174affa40571a17dbeba247adc358fa0", "patch": "@@ -1,3 +1,10 @@\n+2005-11-06  Richard Guenther  <rguenther@suse.de>\n+\n+\t* splay-tree.c (rotate_left): New function.\n+\t(rotate_right): Likewise.\n+\t(splay_tree_splay_helper): Remove.\n+\t(splay_tree_splay): Re-implement.\n+\n 2005-10-31  Mark Kettenis  <kettenis@gnu.org>\n \n \t* floatformat.c (floatformat_vax_aingle, floatformat_vax_double):"}, {"sha": "060f900ae0a08792a75fe2ece703d6c837a525d9", "filename": "libiberty/splay-tree.c", "status": "modified", "additions": 80, "deletions": 111, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a08f87174affa40571a17dbeba247adc358fa0/libiberty%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a08f87174affa40571a17dbeba247adc358fa0/libiberty%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsplay-tree.c?ref=73a08f87174affa40571a17dbeba247adc358fa0", "patch": "@@ -38,12 +38,11 @@ Boston, MA 02110-1301, USA.  */\n #include \"splay-tree.h\"\n \n static void splay_tree_delete_helper (splay_tree, splay_tree_node);\n+static inline void rotate_left (splay_tree_node *,\n+\t\t\t\tsplay_tree_node, splay_tree_node);\n+static inline void rotate_right (splay_tree_node *,\n+\t\t\t\tsplay_tree_node, splay_tree_node);\n static void splay_tree_splay (splay_tree, splay_tree_key);\n-static splay_tree_node splay_tree_splay_helper (splay_tree,\n-\t\t\t\t\t\tsplay_tree_key,\n-\t\t\t\t\t\tsplay_tree_node*,\n-\t\t\t\t\t\tsplay_tree_node*,\n-\t\t\t\t\t\tsplay_tree_node*);\n static int splay_tree_foreach_helper (splay_tree, splay_tree_node,\n                                       splay_tree_foreach_fn, void*);\n \n@@ -107,125 +106,95 @@ splay_tree_delete_helper (splay_tree sp, splay_tree_node node)\n #undef VDEL\n }\n \n-/* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent\n-   and grandparent, respectively, of NODE.  */\n+/* Rotate the edge joining the left child N with its parent P.  PP is the\n+   grandparents pointer to P.  */\n \n-static splay_tree_node\n-splay_tree_splay_helper (splay_tree sp, splay_tree_key key,\n-                         splay_tree_node *node, splay_tree_node *parent,\n-                         splay_tree_node *grandparent)\n+static inline void\n+rotate_left (splay_tree_node *pp, splay_tree_node p, splay_tree_node n)\n {\n-  splay_tree_node *next;\n-  splay_tree_node n;\n-  int comparison;\n-  \n-  n = *node;\n-\n-  if (!n)\n-    return *parent;\n-\n-  comparison = (*sp->comp) (key, n->key);\n-\n-  if (comparison == 0)\n-    /* We've found the target.  */\n-    next = 0;\n-  else if (comparison < 0)\n-    /* The target is to the left.  */\n-    next = &n->left;\n-  else \n-    /* The target is to the right.  */\n-    next = &n->right;\n-\n-  if (next)\n-    {\n-      /* Continue down the tree.  */\n-      n = splay_tree_splay_helper (sp, key, next, node, parent);\n-\n-      /* The recursive call will change the place to which NODE\n-\t points.  */\n-      if (*node != n)\n-\treturn n;\n-    }\n-\n-  if (!parent)\n-    /* NODE is the root.  We are done.  */\n-    return n;\n-\n-  /* First, handle the case where there is no grandparent (i.e.,\n-     *PARENT is the root of the tree.)  */\n-  if (!grandparent) \n-    {\n-      if (n == (*parent)->left)\n-\t{\n-\t  *node = n->right;\n-\t  n->right = *parent;\n-\t}\n-      else\n-\t{\n-\t  *node = n->left;\n-\t  n->left = *parent;\n-\t}\n-      *parent = n;\n-      return n;\n-    }\n+  splay_tree_node tmp;\n+  tmp = n->right;\n+  n->right = p;\n+  p->left = tmp;\n+  *pp = n;\n+}\n \n-  /* Next handle the cases where both N and *PARENT are left children,\n-     or where both are right children.  */\n-  if (n == (*parent)->left && *parent == (*grandparent)->left)\n-    {\n-      splay_tree_node p = *parent;\n-\n-      (*grandparent)->left = p->right;\n-      p->right = *grandparent;\n-      p->left = n->right;\n-      n->right = p;\n-      *grandparent = n;\n-      return n; \n-    }\n-  else if  (n == (*parent)->right && *parent == (*grandparent)->right)\n-    {\n-      splay_tree_node p = *parent;\n-\n-      (*grandparent)->right = p->left;\n-      p->left = *grandparent;\n-      p->right = n->left;\n-      n->left = p;\n-      *grandparent = n;\n-      return n;\n-    }\n+/* Rotate the edge joining the right child N with its parent P.  PP is the\n+   grandparents pointer to P.  */\n \n-  /* Finally, deal with the case where N is a left child, but *PARENT\n-     is a right child, or vice versa.  */\n-  if (n == (*parent)->left) \n-    {\n-      (*parent)->left = n->right;\n-      n->right = *parent;\n-      (*grandparent)->right = n->left;\n-      n->left = *grandparent;\n-      *grandparent = n;\n-      return n;\n-    } \n-  else\n-    {\n-      (*parent)->right = n->left;\n-      n->left = *parent;\n-      (*grandparent)->left = n->right;\n-      n->right = *grandparent;\n-      *grandparent = n;\n-      return n;\n-    }\n+static inline void\n+rotate_right (splay_tree_node *pp, splay_tree_node p, splay_tree_node n)\n+{\n+  splay_tree_node tmp;\n+  tmp = n->left;\n+  n->left = p;\n+  p->right = tmp;\n+  *pp = n;\n }\n \n-/* Splay SP around KEY.  */\n+/* Bottom up splay of key.  */\n \n static void\n splay_tree_splay (splay_tree sp, splay_tree_key key)\n {\n   if (sp->root == 0)\n     return;\n \n-  splay_tree_splay_helper (sp, key, &sp->root, \n-\t\t\t   /*grandparent=*/0, /*parent=*/0); \n+  do {\n+    int cmp1, cmp2;\n+    splay_tree_node n, c;\n+\n+    n = sp->root;\n+    cmp1 = (*sp->comp) (key, n->key);\n+\n+    /* Found.  */\n+    if (cmp1 == 0)\n+      return;\n+\n+    /* Left or right?  If no child, then we're done.  */\n+    if (cmp1 < 0)\n+      c = n->left;\n+    else\n+      c = n->right;\n+    if (!c)\n+      return;\n+\n+    /* Next one left or right?  If found or no child, we're done\n+       after one rotation.  */\n+    cmp2 = (*sp->comp) (key, c->key);\n+    if (cmp2 == 0\n+        || (cmp2 < 0 && !c->left)\n+        || (cmp2 > 0 && !c->right))\n+      {\n+\tif (cmp1 < 0)\n+\t  rotate_left (&sp->root, n, c);\n+\telse\n+\t  rotate_right (&sp->root, n, c);\n+        return;\n+      }\n+\n+    /* Now we have the four cases of double-rotation.  */\n+    if (cmp1 < 0 && cmp2 < 0)\n+      {\n+\trotate_left (&n->left, c, c->left);\n+\trotate_left (&sp->root, n, n->left);\n+      }\n+    else if (cmp1 > 0 && cmp2 > 0)\n+      {\n+\trotate_right (&n->right, c, c->right);\n+\trotate_right (&sp->root, n, n->right);\n+      }\n+    else if (cmp1 < 0 && cmp2 > 0)\n+      {\n+\trotate_right (&n->left, c, c->right);\n+\trotate_left (&sp->root, n, n->left);\n+      }\n+    else if (cmp1 > 0 && cmp2 < 0)\n+      {\n+\trotate_left (&n->right, c, c->left);\n+\trotate_right (&sp->root, n, n->right);\n+      }\n+  } while (1);\n }\n \n /* Call FN, passing it the DATA, for every node below NODE, all of"}]}