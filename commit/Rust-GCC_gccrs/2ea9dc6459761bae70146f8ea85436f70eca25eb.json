{"sha": "2ea9dc6459761bae70146f8ea85436f70eca25eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVhOWRjNjQ1OTc2MWJhZTcwMTQ2ZjhlYTg1NDM2ZjcwZWNhMjVlYg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-04-07T15:31:37Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-04-07T15:31:37Z"}, "message": "ipa-reference.c (mark_load): Use get_base_address.\n\n2010-04-07  Richard Guenther  <rguenther@suse.de>\n\n\t* ipa-reference.c (mark_load): Use get_base_address.\n\t(mark_store): Likewise.\n\n\t* tree-ssa-ccp.c (gimplify_and_update_call_from_tree): Avoid\n\tinserting GIMPLE_NOPs into the IL.\n\t* tree-ssa-structalias.c (get_constraint_for_component_ref):\n\tExplicitly strip handled components and indirect references.\n  \n\t* fold-const.c (fold_unary_loc): Do not strip qualifiers when\n\tfolding address expressions.\n\t* gimple.c (gimple_ior_addresses_taken_1): Use get_base_address.\n\t* tree-ssa-alias.c (decl_refs_may_alias_p): Do not use\n\toperand_equal_p to compare decls.\n\t(ptr_deref_may_alias_decl_p): Likewise.\n\t* tree-ssa-operands.c (get_asm_expr_operands): Simplify\n\t* tree-ssa-forwprop.c (forward_propagate_into_gimple_cond):\n\tHandle reversed comparison ops.\n\t* tree-sra.c (asm_visit_addr): Use get_base_address.\n\t* ipa-prop.c (visit_store_addr_for_mod_analysis): Use\n\tget_base_address.\n\t* ipa-reference.c (mark_address): Use get_base_address.\n\nFrom-SVN: r158069", "tree": {"sha": "24b98f856ca6626ac198b3511f687951a4a1ec86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24b98f856ca6626ac198b3511f687951a4a1ec86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ea9dc6459761bae70146f8ea85436f70eca25eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ea9dc6459761bae70146f8ea85436f70eca25eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ea9dc6459761bae70146f8ea85436f70eca25eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ea9dc6459761bae70146f8ea85436f70eca25eb/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5fd5c97a3458128c95577bbff190795f39e4cdfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd5c97a3458128c95577bbff190795f39e4cdfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fd5c97a3458128c95577bbff190795f39e4cdfb"}], "stats": {"total": 122, "additions": 79, "deletions": 43}, "files": [{"sha": "693d69de50a32a7637d92952279f477576bf862e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ea9dc6459761bae70146f8ea85436f70eca25eb", "patch": "@@ -1,3 +1,27 @@\n+2010-04-07  Richard Guenther  <rguenther@suse.de>\n+\n+\t* ipa-reference.c (mark_load): Use get_base_address.\n+\t(mark_store): Likewise.\n+\n+\t* tree-ssa-ccp.c (gimplify_and_update_call_from_tree): Avoid\n+\tinserting GIMPLE_NOPs into the IL.\n+\t* tree-ssa-structalias.c (get_constraint_for_component_ref):\n+\tExplicitly strip handled components and indirect references.\n+  \n+\t* fold-const.c (fold_unary_loc): Do not strip qualifiers when\n+\tfolding address expressions.\n+\t* gimple.c (gimple_ior_addresses_taken_1): Use get_base_address.\n+\t* tree-ssa-alias.c (decl_refs_may_alias_p): Do not use\n+\toperand_equal_p to compare decls.\n+\t(ptr_deref_may_alias_decl_p): Likewise.\n+\t* tree-ssa-operands.c (get_asm_expr_operands): Simplify\n+\t* tree-ssa-forwprop.c (forward_propagate_into_gimple_cond):\n+\tHandle reversed comparison ops.\n+\t* tree-sra.c (asm_visit_addr): Use get_base_address.\n+\t* ipa-prop.c (visit_store_addr_for_mod_analysis): Use\n+\tget_base_address.\n+\t* ipa-reference.c (mark_address): Use get_base_address.\n+\n 2010-04-07  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-forwprop.c (forward_propagate_addr_expr):"}, {"sha": "03598a59a6f0ca3b2e46688ba4a970c734d56741", "filename": "gcc/fold-const.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2ea9dc6459761bae70146f8ea85436f70eca25eb", "patch": "@@ -8561,10 +8561,11 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t\t\t\t      &mode, &unsignedp, &volatilep, false);\n \t  /* If the reference was to a (constant) zero offset, we can use\n \t     the address of the base if it has the same base type\n-\t     as the result type.  */\n+\t     as the result type and the pointer type is unqualified.  */\n \t  if (! offset && bitpos == 0\n-\t      && TYPE_MAIN_VARIANT (TREE_TYPE (type))\n+\t      && (TYPE_MAIN_VARIANT (TREE_TYPE (type))\n \t\t  == TYPE_MAIN_VARIANT (TREE_TYPE (base)))\n+\t      && TYPE_QUALS (type) == TYPE_UNQUALIFIED)\n \t    return fold_convert_loc (loc, type,\n \t\t\t\t     build_fold_addr_expr_loc (loc, base));\n         }"}, {"sha": "ae0be4e86bc988df32e3fcbc3fc9fe67844f5c27", "filename": "gcc/gimple.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=2ea9dc6459761bae70146f8ea85436f70eca25eb", "patch": "@@ -4532,9 +4532,9 @@ gimple_ior_addresses_taken_1 (gimple stmt ATTRIBUTE_UNUSED,\n \t\t\t      tree addr, void *data)\n {\n   bitmap addresses_taken = (bitmap)data;\n-  while (handled_component_p (addr))\n-    addr = TREE_OPERAND (addr, 0);\n-  if (DECL_P (addr))\n+  addr = get_base_address (addr);\n+  if (addr\n+      && DECL_P (addr))\n     {\n       bitmap_set_bit (addresses_taken, DECL_UID (addr));\n       return true;"}, {"sha": "82a78a3b60e95a708a09d462db53e2c7f22ea175", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=2ea9dc6459761bae70146f8ea85436f70eca25eb", "patch": "@@ -199,7 +199,9 @@ visit_store_addr_for_mod_analysis (gimple stmt ATTRIBUTE_UNUSED,\n {\n   struct ipa_node_params *info = (struct ipa_node_params *) data;\n \n-  if (TREE_CODE (op) == PARM_DECL)\n+  op = get_base_address (op);\n+  if (op\n+      && TREE_CODE (op) == PARM_DECL)\n     {\n       int index = ipa_get_param_decl_index (info, op);\n       gcc_assert (index >= 0);"}, {"sha": "9eac3b10e8296fedf3b761cdaf3bd7008203902b", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=2ea9dc6459761bae70146f8ea85436f70eca25eb", "patch": "@@ -352,9 +352,9 @@ static bool\n mark_address (gimple stmt ATTRIBUTE_UNUSED, tree addr,\n \t      void *data ATTRIBUTE_UNUSED)\n {\n-  while (handled_component_p (addr))\n-    addr = TREE_OPERAND (addr, 0);\n-  mark_address_taken (addr);\n+  addr = get_base_address (addr);\n+  if (addr)\n+    mark_address_taken (addr);\n   return false;\n }\n \n@@ -364,7 +364,8 @@ static bool\n mark_load (gimple stmt ATTRIBUTE_UNUSED, tree t, void *data)\n {\n   ipa_reference_local_vars_info_t local = (ipa_reference_local_vars_info_t)data;\n-  if (TREE_CODE (t) == VAR_DECL\n+  t = get_base_address (t);\n+  if (t && TREE_CODE (t) == VAR_DECL\n       && has_proper_scope_for_analysis (t))\n     bitmap_set_bit (local->statics_read, DECL_UID (t));\n   return false;\n@@ -376,7 +377,8 @@ static bool\n mark_store (gimple stmt ATTRIBUTE_UNUSED, tree t, void *data)\n {\n   ipa_reference_local_vars_info_t local = (ipa_reference_local_vars_info_t)data;\n-  if (TREE_CODE (t) == VAR_DECL\n+  t = get_base_address (t);\n+  if (t && TREE_CODE (t) == VAR_DECL\n       && has_proper_scope_for_analysis (t))\n     {\n       if (local)"}, {"sha": "56531687f34c138812d0a71c5b26ee97f8ae22f8", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=2ea9dc6459761bae70146f8ea85436f70eca25eb", "patch": "@@ -1066,7 +1066,9 @@ static bool\n asm_visit_addr (gimple stmt ATTRIBUTE_UNUSED, tree op,\n \t\tvoid *data ATTRIBUTE_UNUSED)\n {\n-  if (DECL_P (op))\n+  op = get_base_address (op);\n+  if (op\n+      && DECL_P (op))\n     disqualify_candidate (op, \"Non-scalarizable GIMPLE_ASM operand.\");\n \n   return false;"}, {"sha": "282148ce5e9b22bf7e4c878f97013d973369a7de", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=2ea9dc6459761bae70146f8ea85436f70eca25eb", "patch": "@@ -189,7 +189,7 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n \tptr = TREE_OPERAND (base, 0);\n       else if (base\n \t       && SSA_VAR_P (base))\n-\treturn operand_equal_p (base, decl, 0);\n+\treturn base == decl;\n       else if (base\n \t       && CONSTANT_CLASS_P (base))\n \treturn false;\n@@ -629,7 +629,7 @@ decl_refs_may_alias_p (tree base1,\n   gcc_assert (SSA_VAR_P (base1) && SSA_VAR_P (base2));\n \n   /* If both references are based on different variables, they cannot alias.  */\n-  if (!operand_equal_p (base1, base2, 0))\n+  if (base1 != base2)\n     return false;\n \n   /* If both references are based on the same variable, they cannot alias if"}, {"sha": "f0106ebc94034fda04ce1de4042f21e5c51408ef", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=2ea9dc6459761bae70146f8ea85436f70eca25eb", "patch": "@@ -3354,6 +3354,7 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n   gimple_stmt_iterator i;\n   gimple_seq stmts = gimple_seq_alloc();\n   struct gimplify_ctx gctx;\n+  gimple last = NULL;\n \n   stmt = gsi_stmt (*si_p);\n \n@@ -3375,22 +3376,31 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n \n   /* The replacement can expose previously unreferenced variables.  */\n   for (i = gsi_start (stmts); !gsi_end_p (i); gsi_next (&i))\n-  {\n-    new_stmt = gsi_stmt (i);\n-    find_new_referenced_vars (new_stmt);\n-    gsi_insert_before (si_p, new_stmt, GSI_NEW_STMT);\n-    mark_symbols_for_renaming (new_stmt);\n-    gsi_next (si_p);\n-  }\n+    {\n+      if (last)\n+\t{\n+\t  gsi_insert_before (si_p, last, GSI_NEW_STMT);\n+\t  gsi_next (si_p);\n+\t}\n+      new_stmt = gsi_stmt (i);\n+      find_new_referenced_vars (new_stmt);\n+      mark_symbols_for_renaming (new_stmt);\n+      last = new_stmt;\n+    }\n \n   if (lhs == NULL_TREE)\n     {\n-      new_stmt = gimple_build_nop ();\n       unlink_stmt_vdef (stmt);\n       release_defs (stmt);\n+      new_stmt = last;\n     }\n   else\n     {\n+      if (last)\n+\t{\n+\t  gsi_insert_before (si_p, last, GSI_NEW_STMT);\n+\t  gsi_next (si_p);\n+\t}\n       new_stmt = gimple_build_assign (lhs, tmp);\n       gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n       gimple_set_vdef (new_stmt, gimple_vdef (stmt));"}, {"sha": "fc40bf46eac26d42547cfe88ceb9de5e73d09e9a", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=2ea9dc6459761bae70146f8ea85436f70eca25eb", "patch": "@@ -398,25 +398,27 @@ forward_propagate_into_gimple_cond (gimple stmt)\n \n   do {\n     tree tmp = NULL_TREE;\n-    tree name, rhs0 = NULL_TREE, rhs1 = NULL_TREE;\n+    tree name = NULL_TREE, rhs0 = NULL_TREE, rhs1 = NULL_TREE;\n     gimple def_stmt;\n     bool single_use0_p = false, single_use1_p = false;\n     enum tree_code code = gimple_cond_code (stmt);\n \n     /* We can do tree combining on SSA_NAME and comparison expressions.  */\n-    if (TREE_CODE_CLASS (gimple_cond_code (stmt)) == tcc_comparison\n-        && TREE_CODE (gimple_cond_lhs (stmt)) == SSA_NAME)\n+    if (TREE_CODE_CLASS (gimple_cond_code (stmt)) == tcc_comparison)\n       {\n \t/* For comparisons use the first operand, that is likely to\n \t   simplify comparisons against constants.  */\n-\tname = gimple_cond_lhs (stmt);\n-\tdef_stmt = get_prop_source_stmt (name, false, &single_use0_p);\n-\tif (def_stmt && can_propagate_from (def_stmt))\n+\tif (TREE_CODE (gimple_cond_lhs (stmt)) == SSA_NAME)\n \t  {\n-\t    tree op1 = gimple_cond_rhs (stmt);\n-\t    rhs0 = rhs_to_tree (TREE_TYPE (op1), def_stmt);\n-\t    tmp = combine_cond_expr_cond (loc, code, boolean_type_node, rhs0,\n-\t\t\t\t\t  op1, !single_use0_p);\n+\t    name = gimple_cond_lhs (stmt);\n+\t    def_stmt = get_prop_source_stmt (name, false, &single_use0_p);\n+\t    if (def_stmt && can_propagate_from (def_stmt))\n+\t      {\n+\t\ttree op1 = gimple_cond_rhs (stmt);\n+\t\trhs0 = rhs_to_tree (TREE_TYPE (op1), def_stmt);\n+\t\ttmp = combine_cond_expr_cond (loc, code, boolean_type_node,\n+\t\t\t\t\t      rhs0, op1, !single_use0_p);\n+\t      }\n \t  }\n \t/* If that wasn't successful, try the second operand.  */\n \tif (tmp == NULL_TREE"}, {"sha": "cd8b6f8935a943f870e88204280c1eb2830001ed", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=2ea9dc6459761bae70146f8ea85436f70eca25eb", "patch": "@@ -798,11 +798,7 @@ get_asm_expr_operands (gimple stmt)\n       /* Memory operands are addressable.  Note that STMT needs the\n \t address of this operand.  */\n       if (!allows_reg && allows_mem)\n-\t{\n-\t  tree t = get_base_address (TREE_VALUE (link));\n-\t  if (t && DECL_P (t))\n-\t    mark_address_taken (t);\n-\t}\n+\tmark_address_taken (TREE_VALUE (link));\n \n       get_expr_operands (stmt, &TREE_VALUE (link), opf_def);\n     }\n@@ -818,11 +814,7 @@ get_asm_expr_operands (gimple stmt)\n       /* Memory operands are addressable.  Note that STMT needs the\n \t address of this operand.  */\n       if (!allows_reg && allows_mem)\n-\t{\n-\t  tree t = get_base_address (TREE_VALUE (link));\n-\t  if (t && DECL_P (t))\n-\t    mark_address_taken (t);\n-\t}\n+\tmark_address_taken (TREE_VALUE (link));\n \n       get_expr_operands (stmt, &TREE_VALUE (link), 0);\n     }"}, {"sha": "2384099a242b772f559b6bdd44e0b421ab8d49a7", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea9dc6459761bae70146f8ea85436f70eca25eb/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=2ea9dc6459761bae70146f8ea85436f70eca25eb", "patch": "@@ -2951,7 +2951,8 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n   /* Some people like to do cute things like take the address of\n      &0->a.b */\n   forzero = t;\n-  while (!SSA_VAR_P (forzero) && !CONSTANT_CLASS_P (forzero))\n+  while (handled_component_p (forzero)\n+\t || INDIRECT_REF_P (forzero))\n     forzero = TREE_OPERAND (forzero, 0);\n \n   if (CONSTANT_CLASS_P (forzero) && integer_zerop (forzero))"}]}