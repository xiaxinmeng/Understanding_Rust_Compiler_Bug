{"sha": "eedff70182852a43d62a463c4dd65cdd8d567c70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVkZmY3MDE4Mjg1MmE0M2Q2MmE0NjNjNGRkNjVjZGQ4ZDU2N2M3MA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-12-11T23:21:55Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-12-11T23:21:55Z"}, "message": "PR c/81544 - attribute noreturn and warn_unused_result on the same function\n\nPR c/81544 - attribute noreturn and warn_unused_result on the same function\naccepted \n\nAdd tests missed in r255469.\n\nFrom-SVN: r255557", "tree": {"sha": "f29d5072d6dba41cdf24b54d18ce8be5bc426041", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f29d5072d6dba41cdf24b54d18ce8be5bc426041"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eedff70182852a43d62a463c4dd65cdd8d567c70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eedff70182852a43d62a463c4dd65cdd8d567c70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eedff70182852a43d62a463c4dd65cdd8d567c70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eedff70182852a43d62a463c4dd65cdd8d567c70/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0242c7f0aac22e47b73046b2d60bb5de68057d6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0242c7f0aac22e47b73046b2d60bb5de68057d6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0242c7f0aac22e47b73046b2d60bb5de68057d6a"}], "stats": {"total": 1072, "additions": 1072, "deletions": 0}, "files": [{"sha": "ecb6ac659c14b126f476a5689b0b4f787061d63b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eedff70182852a43d62a463c4dd65cdd8d567c70/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eedff70182852a43d62a463c4dd65cdd8d567c70/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eedff70182852a43d62a463c4dd65cdd8d567c70", "patch": "@@ -1,3 +1,14 @@\n+2017-12-11  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81544\n+\t* c-c++-common/Wattributes-2.c: New test.\n+\t* c-c++-common/Wattributes.c: Ditto.\n+\t* g++.dg/Wattributes-2.C: Ditto.\n+\t* gcc.dg/Wattributes-6.c: Ditto.\n+\t* gcc.dg/Wattributes-7.c: Ditto.\n+\n+\t* ../../../git/gcc/testsuite/g++.dg/pr53037-4.C: \n+\n 2017-12-07  Carl Love  <cel@us.ibm.com>\n \n \t* gcc.target/powerpc/altivec-12.c (main):  Add tests for vec_avg."}, {"sha": "0904742b01d03b4f8842af0c22e98bb59edf9723", "filename": "gcc/testsuite/c-c++-common/Wattributes-2.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eedff70182852a43d62a463c4dd65cdd8d567c70/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWattributes-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eedff70182852a43d62a463c4dd65cdd8d567c70/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWattributes-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWattributes-2.c?ref=eedff70182852a43d62a463c4dd65cdd8d567c70", "patch": "@@ -0,0 +1,74 @@\n+/* PR c/81566 - invalid attribute aligned accepted on functions\n+   { dg-do compile }\n+   { dg-options \"-Wall -Wattributes -ftrack-macro-expansion=0\" } */\n+\n+#define ATTR(list) __attribute__ (list)\n+#define ALIGN(n)   ATTR ((aligned (n)))\n+\n+/* It's okay to increase the alignment of a function.  */\n+\n+void ALIGN (16) ALIGN (32)\n+falign32_1 (void);\n+\n+void ALIGN (16) falign32_2 (void);\n+void ALIGN (32) falign32_2 (void);\n+\n+void falign32_2 (void) { }\n+\n+void ALIGN (32) falign32_2 (void);\n+\n+/* It's not okay to decrease it.  */\n+\n+void ALIGN (32) ALIGN (16)\n+falign64_3 (void);            /* { dg-warning \"ignoring attribute .aligned \\\\(16\\\\). because it conflicts with attribute .aligned \\\\(32\\\\).\" } */\n+\n+void ALIGN (32)\n+falign64_3 (void);\n+\n+void falign64_3 (void);\n+\n+void falign64_3 (void) { }\n+\n+\n+void ALIGN (32)\n+falign64_4 (void);            /* { dg-message \"previous declaration here\" } */\n+\n+void ALIGN (16)\n+falign64_4 (void);            /* { dg-warning \"ignoring attribute .aligned \\\\(16\\\\). because it conflicts with attribute .aligned \\\\(32\\\\).\" } */\n+\n+void ALIGN (32)\n+falign64_4 (void);            /* { dg-message \"previous declaration here\" } */\n+\n+void ALIGN (16)\n+falign64_4 (void);            /* { dg-warning \"ignoring attribute .aligned \\\\(16\\\\). because it conflicts with attribute .aligned \\\\(32\\\\).\" } */\n+\n+void ALIGN (64)\n+falign64_4 (void);\n+\n+void ALIGN (32)\n+falign64_4 (void);            /* { dg-warning \"ignoring attribute .aligned \\\\(32\\\\). because it conflicts with attribute .aligned \\\\(64\\\\).\" } */\n+\n+void falign64_4 (void);\n+\n+void ALIGN (64)\n+falign64_4 (void) { }\n+\n+void falign64_4 (void);\n+\n+void ALIGN (64)\n+falign64_4 (void);\n+\n+\n+void ATTR ((aligned (16), aligned (32)))\n+falign64_5 (void);\n+\n+void ATTR ((aligned (32), aligned (64)))\n+falign64_5 (void);\n+\n+void ATTR ((aligned (16), aligned (32), aligned (64)))\n+falign64_5 (void);            /* { dg-warning \"ignoring attribute .aligned \\\\(16\\\\). because it conflicts with attribute .aligned \\\\(64\\\\).\" } */\n+                              /* { dg-warning \"ignoring attribute .aligned \\\\(32\\\\). because it conflicts with attribute .aligned \\\\(64\\\\).\" \"\" { target *-*-* } .-1 } */\n+\n+\n+void ATTR ((aligned (16), aligned (32), aligned (16)))\n+falign64_6 (void);            /* { dg-warning \"ignoring attribute .aligned \\\\(16\\\\). because it conflicts with attribute .aligned \\\\(32\\\\).\" } */"}, {"sha": "902bcb61c30821d62f6f407c9206cb95bdf84418", "filename": "gcc/testsuite/c-c++-common/Wattributes.c", "status": "added", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eedff70182852a43d62a463c4dd65cdd8d567c70/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWattributes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eedff70182852a43d62a463c4dd65cdd8d567c70/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWattributes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWattributes.c?ref=eedff70182852a43d62a463c4dd65cdd8d567c70", "patch": "@@ -0,0 +1,439 @@\n+/* { dg-do compile }\n+   { dg-options \"-Wall -Wattributes -ftrack-macro-expansion=0\" } */\n+\n+#define ATTR(attrlist) __attribute__ (attrlist)\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   aligned and packed on a type definition.  */\n+\n+/* Pointless but benign.  */\n+struct ATTR ((aligned, aligned))\n+AlignedAligned { int i; };\n+\n+/* Aligned followed by packed on a type and vice versa has a valid use:\n+   to decrease the alignment of a type to the specified boundary.  */\n+struct ATTR ((aligned, packed))\n+AlignedPacked { int i; };\n+\n+struct ATTR ((packed, aligned))\n+PackedAligned { int i; };\n+\n+struct ATTR ((aligned (2)))\n+AlignedMemberPacked\n+{\n+  int ATTR ((packed)) i;\n+};\n+\n+struct ATTR ((packed))\n+PackedMemberAligned\n+{\n+  int ATTR ((aligned (2))) i;\n+};\n+\n+/* Silly but benign.  */\n+struct ATTR ((packed, packed))\n+PackedPacked { int i; };\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   aligned and packed on a function declaration.  */\n+\n+void ATTR ((aligned (8), packed))\n+faligned8_1 (void);           /* { dg-warning \".packed. attribute ignored\" } */\n+\n+void ATTR ((aligned (8)))\n+faligned8_2 (void);           /* { dg-message \"previous declaration here\" \"\" { xfail *-*-* } } */\n+\n+void ATTR ((packed))\n+faligned8_2 (void);           /* { dg-warning \".packed. attribute ignored\" } */\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   always_inline and noinline (in that order).  */\n+\n+inline void ATTR ((always_inline))\n+falways_inline1 (void);\n+\n+inline void ATTR ((__always_inline__))\n+falways_inline1 (void);\n+\n+/* Verify that repeating attribute always_inline on the same declaration\n+   doesn't trigger a warning.  */\n+inline void ATTR ((always_inline, __always_inline__))\n+falways_inline1 (void);\n+\n+/* Verify that repeating attribute always_inline on a distinct declaration\n+   doesn't trigger a warning.  */\n+inline void ATTR ((always_inline))\n+falways_inline1 (void);       /* { dg-message \"previous declaration here\" } */\n+\n+/* Verify a warning for noinline conflict.  */\n+void ATTR ((noinline))\n+falways_inline1 (void) { }    /* { dg-warning \"ignoring attribute .noinline. because it conflicts with attribute .always_inline.\" } */\n+\n+/* And again.  */\n+void ATTR ((always_inline))\n+falways_inline1 (void);\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noinline and always_inline (in that order).  */\n+\n+void ATTR ((noinline))\n+fnoinline1 (void);\n+\n+void ATTR ((__noinline__))\n+fnoinline1 (void);\n+\n+/* Verify that repeating attribute noinline on the same declaration\n+   doesn't trigger a warning.  */\n+void ATTR ((noinline, __noinline__))\n+fnoinline1 (void);\n+\n+/* Verify that repeating attribute noinline on a distinct declaration\n+   doesn't trigger a warning.  */\n+void ATTR ((noinline))\n+fnoinline1 (void);       /* { dg-message \"previous declaration here\" } */\n+\n+/* Verify a warning for always_inline conflict.  */\n+void ATTR ((always_inline))\n+fnoinline1 (void) { }    /* { dg-warning \"ignoring attribute .always_inline. because it conflicts with attribute .noinline.\" } */\n+\n+/* Verify a warning for gnu_inline conflict.  */\n+inline void ATTR ((gnu_inline))\n+fnoinline1 (void);      /* { dg-warning \"ignoring attribute .gnu_inline. because it conflicts with attribute .noinline.\" } */\n+                        /* { dg-warning \"follows declaration with attribute .noinline.\" \"inline noinline\" { target *-*-* } .-1 } */\n+\n+/* And again.  */\n+void ATTR ((noinline))\n+fnoinline1 (void);      /* { dg-warning \"follows inline declaration\" } */\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and warn_unused_result.  */\n+\n+int ATTR ((__noreturn__))\n+fnoret1 (void);\n+\n+int ATTR ((noreturn))\n+fnoret1 (void);               /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((warn_unused_result))\n+fnoret1 (void);               /* { dg-warning \"ignoring attribute .warn_unused_result. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Verify that repeating attribute noreturn doesn't trigger a warning.  */\n+int ATTR ((noreturn)) fnoret1 (void);\n+\n+int call_noret1 (void)\n+{\n+  /* Verify that attribute warn_unused_result was, in fact, ignored\n+     on the second declaration of fnoret1.  */\n+  fnoret1 ();\n+}\n+\n+int ATTR ((noreturn, warn_unused_result))\n+fnoret2 (void);               /* { dg-warning \"ignoring attribute .warn_unused_result. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Verify that repeating attribute noreturn doesn't trigger a warning.  */\n+int ATTR ((noreturn)) fnoret2 (void);\n+\n+int call_noret2 (void)\n+{\n+  /* Verify that attribute warn_unused_result was, in fact, ignored\n+     on the second declaration of fnoret2.  */\n+  fnoret2 ();\n+}\n+\n+/* Verify that attribute noreturn isn't diagnosed on a declaration\n+   that was previously declared warn_unused_result and that attribute\n+   was dropped (because the function returs void).  */\n+\n+void ATTR ((warn_unused_result))\n+fnorety6 (void);             /* { dg-warning \".warn_unused_result. attribute ignored\" } */\n+\n+void ATTR ((noreturn))\n+fnoret6 (void);\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and alloc_align.  */\n+\n+void* ATTR ((noreturn))\n+fnoret_alloc_align1 (int);    /* { dg-message \"previous declaration here\" } */\n+\n+void* ATTR ((alloc_align (1)))\n+fnoret_alloc_align1 (int);    /* { dg-warning \"ignoring attribute .alloc_align. because it conflicts with attribute .noreturn.\" } */\n+\n+void* ATTR ((noreturn, alloc_align (1)))\n+fnoret_alloc_align2 (int);    /* { dg-warning \"ignoring attribute .alloc_align. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+void* ATTR ((noreturn)) ATTR ((alloc_align (1)))\n+fnoret_alloc_align3 (int);    /* { dg-warning \"ignoring attribute .alloc_align. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+void* ATTR ((alloc_align (1)))\n+falloc_align_noret1 (int);    /* { dg-message \"previous declaration here\" } */\n+\n+void* ATTR ((noreturn))\n+falloc_align_noret1 (int);    /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .alloc_align.\" } */\n+\n+\n+void* ATTR ((alloc_align (1), noreturn))\n+falloc_align_noret2 (int);    /* { dg-warning \"ignoring attribute .(noreturn|alloc_align). because it conflicts with attribute .(alloc_align|noreturn).\" } */\n+\n+void* ATTR ((alloc_align (1))) ATTR ((noreturn))\n+falloc_align_noret3 (int);    /* { dg-warning \"ignoring attribute .(noreturn|alloc_align). because it conflicts with attribute .(noreturn|alloc_align).\" } */\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and alloc_size.  */\n+\n+void* ATTR ((noreturn))\n+fnoret_alloc_size1 (int);     /* { dg-message \"previous declaration here\" } */\n+\n+void* ATTR ((alloc_size (1)))\n+fnoret_alloc_size1 (int);     /* { dg-warning \"ignoring attribute .alloc_size. because it conflicts with attribute .noreturn.\" } */\n+\n+void* ATTR ((noreturn, alloc_size (1)))\n+fnoret_alloc_size2 (int);     /* { dg-warning \"ignoring attribute .alloc_size. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+void* ATTR ((noreturn)) ATTR ((alloc_size (1)))\n+fnoret_alloc_size3 (int);     /* { dg-warning \"ignoring attribute .alloc_size. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+void* ATTR ((alloc_size (1)))\n+falloc_size_noret1 (int);     /* { dg-message \"previous declaration here\" } */\n+\n+void* ATTR ((noreturn))\n+falloc_size_noret1 (int);     /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .alloc_size.\" } */\n+\n+\n+void* ATTR ((alloc_size (1), noreturn))\n+falloc_size_noret2 (int);     /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .alloc_size.\" } */\n+\n+void* ATTR ((alloc_size (1))) ATTR ((noreturn))\n+falloc_size_noret3 (int);     /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .alloc_size.\" } */\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and const.  */\n+\n+int ATTR ((noreturn))\n+fnoret_const1 (int);          /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((const))\n+fnoret_const1 (int);          /* { dg-warning \"ignoring attribute .const. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Unfortunately, attributes on a single declarations may not be processed\n+   in the same order as specified... */\n+int ATTR ((noreturn, const))\n+fnoret_const2 (int);          /* { dg-warning \"ignoring attribute .const. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+int ATTR ((noreturn)) ATTR ((const))\n+fnoret_const3 (int);          /* { dg-warning \"ignoring attribute .const. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+int ATTR ((const))\n+fconst_noret1 (int);          /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((noreturn))\n+fconst_noret1 (int);          /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .const.\" } */\n+\n+\n+int ATTR ((const, noreturn))\n+fconst_noret2 (int);          /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .const.\" } */\n+\n+int ATTR ((const)) ATTR ((noreturn))\n+fconst_noret3 (int);          /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .const.\" } */\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and malloc.  */\n+\n+void* ATTR ((noreturn))\n+fnoret_malloc1 (int);         /* { dg-message \"previous declaration here\" } */\n+\n+void* ATTR ((malloc))\n+fnoret_malloc1 (int);         /* { dg-warning \"ignoring attribute .malloc. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Unfortunately, attributes on a single declarations may not be processed\n+   in the same order as specified... */\n+void* ATTR ((noreturn, malloc))\n+fnoret_malloc2 (int);         /* { dg-warning \"ignoring attribute .malloc. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+void* ATTR ((noreturn)) ATTR ((malloc))\n+fnoret_malloc3 (int);         /* { dg-warning \"ignoring attribute .malloc. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+void* ATTR ((__malloc__))\n+fmalloc_noret1 (int);\n+\n+void* ATTR ((malloc))\n+fmalloc_noret1 (int);         /* { dg-message \"previous declaration here\" } */\n+\n+void* ATTR ((noreturn))\n+fmalloc_noret1 (int);         /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .malloc.\" } */\n+\n+\n+void* ATTR ((malloc, noreturn))\n+fmalloc_noret2 (int);         /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .malloc.\" } */\n+\n+void* ATTR ((malloc)) ATTR ((noreturn))\n+fmalloc_noret3 (int);         /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .malloc.\" } */\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and pure.  */\n+\n+int ATTR ((noreturn))\n+fnoret_pure1 (int);           /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((pure))\n+fnoret_pure1 (int);           /* { dg-warning \"ignoring attribute .pure. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Unfortunately, attributes on a single declarations may not be processed\n+   in the same order as specified... */\n+int ATTR ((noreturn, pure))\n+fnoret_pure2 (int);           /* { dg-warning \"ignoring attribute .pure. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+int ATTR ((noreturn)) ATTR ((pure))\n+fnoret_pure3 (int);           /* { dg-warning \"ignoring attribute .pure. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+int ATTR ((__pure__))\n+fpure_noret1 (int);\n+\n+int ATTR ((pure))\n+fpure_noret1 (int);           /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((noreturn))\n+fpure_noret1 (int);           /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .pure.\" } */\n+\n+\n+int ATTR ((pure, noreturn))\n+fpure_noret2 (int);           /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .pur.\" } */\n+\n+int ATTR ((pure)) ATTR ((noreturn))\n+fpure_noret3 (int);            /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .pure.\" } */\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and returns_twice.  */\n+\n+int ATTR ((noreturn))\n+fnoret_returns_twice1 (int);  /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((returns_twice))\n+fnoret_returns_twice1 (int);  /* { dg-warning \"ignoring attribute .returns_twice. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Unfortunately, attributes on a single declarations may not be processed\n+   in the same order as specified... */\n+int ATTR ((noreturn, returns_twice))\n+fnoret_returns_twice2 (int);  /* { dg-warning \"ignoring attribute .returns_twice. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+int ATTR ((noreturn)) ATTR ((returns_twice))\n+fnoret_returns_twice3 (int);  /* { dg-warning \"ignoring attribute .returns_twice. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+int ATTR ((returns_twice))\n+freturns_twice_noret1 (int);  /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((noreturn))\n+freturns_twice_noret1 (int);  /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .returns_twice.\" } */\n+\n+\n+int ATTR ((returns_twice, noreturn))\n+freturns_twice_noret2 (int);  /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .returns_twice.\" } */\n+\n+int ATTR ((returns_twice)) ATTR ((noreturn))\n+freturns_twice_noret3 (int);  /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .returns_twice.\" } */\n+\n+\n+/* Exercise the interaction of multiple combinations of mutually\n+   exclusive attributes specified on distinct declarations.  */\n+\n+inline int ATTR ((always_inline))\n+finline_cold_noreturn (int);\n+\n+inline int ATTR ((cold))\n+finline_cold_noreturn (int);\n+\n+inline int ATTR ((noreturn))\n+finline_cold_noreturn (int);\n+\n+inline int ATTR ((noinline))\n+finline_cold_noreturn (int);    /* { dg-warning \"ignoring attribute .noinline. because it conflicts with attribute .always_inline.\" } */\n+\n+inline int ATTR ((hot))\n+finline_cold_noreturn (int);    /* { dg-warning \"ignoring attribute .hot. because it conflicts with attribute .cold.\" } */\n+\n+inline int ATTR ((warn_unused_result))\n+finline_cold_noreturn (int);    /* { dg-warning \"ignoring attribute .warn_unused_result. because it conflicts with attribute .noreturn.\" } */\n+\n+inline int ATTR ((always_inline))\n+finline_cold_noreturn (int);\n+\n+/* Expect no warning for the missing return statement below because\n+   the function is noreturn.  */\n+inline int ATTR ((noreturn))\n+finline_cold_noreturn (int i) { (void)&i; __builtin_abort (); }\n+\n+\n+/* Exercise the interaction of multiple combinations of mutually\n+   exclusive attributes with some specified on the same declaration\n+   and some on distinct declarations.  */\n+\n+inline int ATTR ((always_inline, hot))\n+finline_hot_noret_align (int);\n+\n+inline int ATTR ((noreturn, noinline))\n+finline_hot_noret_align (int);  /* { dg-warning \"ignoring attribute .noinline. because it conflicts with attribute .always_inline.\" } */\n+\n+inline int ATTR ((cold, aligned (8)))\n+finline_hot_noret_align (int);  /* { dg-warning \"ignoring attribute .cold. because it conflicts with attribute .hot.\" } */\n+\n+inline int ATTR ((warn_unused_result))\n+finline_hot_noret_align (int);  /* { dg-warning \"ignoring attribute .warn_unused_result. because it conflicts with attribute .noreturn.\" } */\n+\n+inline int ATTR ((aligned (4)))\n+finline_hot_noret_align (int);  /* { dg-warning \"ignoring attribute .aligned \\\\(4\\\\). because it conflicts with attribute .aligned \\\\(8\\\\).\" } */\n+\n+inline int ATTR ((aligned (8)))\n+finline_hot_noret_align (int);\n+\n+inline int ATTR ((const))\n+finline_hot_noret_align (int);  /* { dg-warning \"ignoring attribute .const. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Expect no warning for the missing return statement below because\n+   the function is noreturn.  */\n+inline int ATTR ((noreturn))\n+finline_hot_noret_align (int i) { (void)&i; __builtin_abort (); }\n+\n+\n+/* Exercise variable attributes.  */\n+\n+extern int ATTR ((common))\n+decl_common1;                 /* { dg-message \"previous declaration here\" } */\n+\n+extern int ATTR ((nocommon))\n+decl_common1;                 /* { dg-warning \"ignoring attribute .nocommon. because it conflicts with attribute .common.\" } */\n+\n+\n+extern int ATTR ((nocommon))\n+decl_common2;                 /* { dg-message \"previous declaration here\" } */\n+\n+extern int ATTR ((common))\n+decl_common2;                 /* { dg-warning \"ignoring attribute .common. because it conflicts with attribute .nocommon.\" } */\n+\n+\n+extern int ATTR ((common, nocommon))\n+decl_common3;                 /* { dg-warning \"ignoring attribute .nocommon. because it conflicts with attribute .common.\" } */\n+\n+\n+extern int ATTR ((common, nocommon))\n+decl_common4;                 /* { dg-warning \"ignoring attribute .nocommon. because it conflicts with attribute .common.\" } */"}, {"sha": "1470b16c567b16ea0070f82129b104078fb8347f", "filename": "gcc/testsuite/g++.dg/Wattributes-2.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eedff70182852a43d62a463c4dd65cdd8d567c70/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWattributes-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eedff70182852a43d62a463c4dd65cdd8d567c70/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWattributes-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWattributes-2.C?ref=eedff70182852a43d62a463c4dd65cdd8d567c70", "patch": "@@ -0,0 +1,35 @@\n+// Test to verify that attributes on distinct overloads of a function\n+//  with the same name are properly looked up and applied.\n+// { dg-do compile }\n+// { dg-options \"-Wall\" }\n+\n+int\n+foo (int);\n+\n+int __attribute__ ((noreturn))\n+foo (int, int);\n+\n+int __attribute__ ((warn_unused_result))\n+foo (int, int, int);\n+\n+int call_foo_1 ()\n+{\n+  foo (1);\n+}                       // { dg-warning \"\\\\\\[-Wreturn-type]\" }\n+\n+int call_foo_2 ()\n+{\n+  foo (1, 2);\n+}\n+\n+int call_foo_3 ()\n+{\n+  foo (1, 2, 3);        // { dg-warning \"\\\\\\[-Wunused-result]\" }\n+}                       // { dg-warning \"\\\\\\[-Wreturn-type]\" }\n+\n+int call_foo_4 ()\n+{\n+  // Make sure an error doesn't trigger bogus warnings or an ICE.\n+  foo (1, 2, 3, 4);     // { dg-error \"no matching function\" }\n+  return 0;\n+}"}, {"sha": "902bcb61c30821d62f6f407c9206cb95bdf84418", "filename": "gcc/testsuite/gcc.dg/Wattributes-6.c", "status": "added", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eedff70182852a43d62a463c4dd65cdd8d567c70/gcc%2Ftestsuite%2Fgcc.dg%2FWattributes-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eedff70182852a43d62a463c4dd65cdd8d567c70/gcc%2Ftestsuite%2Fgcc.dg%2FWattributes-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWattributes-6.c?ref=eedff70182852a43d62a463c4dd65cdd8d567c70", "patch": "@@ -0,0 +1,439 @@\n+/* { dg-do compile }\n+   { dg-options \"-Wall -Wattributes -ftrack-macro-expansion=0\" } */\n+\n+#define ATTR(attrlist) __attribute__ (attrlist)\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   aligned and packed on a type definition.  */\n+\n+/* Pointless but benign.  */\n+struct ATTR ((aligned, aligned))\n+AlignedAligned { int i; };\n+\n+/* Aligned followed by packed on a type and vice versa has a valid use:\n+   to decrease the alignment of a type to the specified boundary.  */\n+struct ATTR ((aligned, packed))\n+AlignedPacked { int i; };\n+\n+struct ATTR ((packed, aligned))\n+PackedAligned { int i; };\n+\n+struct ATTR ((aligned (2)))\n+AlignedMemberPacked\n+{\n+  int ATTR ((packed)) i;\n+};\n+\n+struct ATTR ((packed))\n+PackedMemberAligned\n+{\n+  int ATTR ((aligned (2))) i;\n+};\n+\n+/* Silly but benign.  */\n+struct ATTR ((packed, packed))\n+PackedPacked { int i; };\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   aligned and packed on a function declaration.  */\n+\n+void ATTR ((aligned (8), packed))\n+faligned8_1 (void);           /* { dg-warning \".packed. attribute ignored\" } */\n+\n+void ATTR ((aligned (8)))\n+faligned8_2 (void);           /* { dg-message \"previous declaration here\" \"\" { xfail *-*-* } } */\n+\n+void ATTR ((packed))\n+faligned8_2 (void);           /* { dg-warning \".packed. attribute ignored\" } */\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   always_inline and noinline (in that order).  */\n+\n+inline void ATTR ((always_inline))\n+falways_inline1 (void);\n+\n+inline void ATTR ((__always_inline__))\n+falways_inline1 (void);\n+\n+/* Verify that repeating attribute always_inline on the same declaration\n+   doesn't trigger a warning.  */\n+inline void ATTR ((always_inline, __always_inline__))\n+falways_inline1 (void);\n+\n+/* Verify that repeating attribute always_inline on a distinct declaration\n+   doesn't trigger a warning.  */\n+inline void ATTR ((always_inline))\n+falways_inline1 (void);       /* { dg-message \"previous declaration here\" } */\n+\n+/* Verify a warning for noinline conflict.  */\n+void ATTR ((noinline))\n+falways_inline1 (void) { }    /* { dg-warning \"ignoring attribute .noinline. because it conflicts with attribute .always_inline.\" } */\n+\n+/* And again.  */\n+void ATTR ((always_inline))\n+falways_inline1 (void);\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noinline and always_inline (in that order).  */\n+\n+void ATTR ((noinline))\n+fnoinline1 (void);\n+\n+void ATTR ((__noinline__))\n+fnoinline1 (void);\n+\n+/* Verify that repeating attribute noinline on the same declaration\n+   doesn't trigger a warning.  */\n+void ATTR ((noinline, __noinline__))\n+fnoinline1 (void);\n+\n+/* Verify that repeating attribute noinline on a distinct declaration\n+   doesn't trigger a warning.  */\n+void ATTR ((noinline))\n+fnoinline1 (void);       /* { dg-message \"previous declaration here\" } */\n+\n+/* Verify a warning for always_inline conflict.  */\n+void ATTR ((always_inline))\n+fnoinline1 (void) { }    /* { dg-warning \"ignoring attribute .always_inline. because it conflicts with attribute .noinline.\" } */\n+\n+/* Verify a warning for gnu_inline conflict.  */\n+inline void ATTR ((gnu_inline))\n+fnoinline1 (void);      /* { dg-warning \"ignoring attribute .gnu_inline. because it conflicts with attribute .noinline.\" } */\n+                        /* { dg-warning \"follows declaration with attribute .noinline.\" \"inline noinline\" { target *-*-* } .-1 } */\n+\n+/* And again.  */\n+void ATTR ((noinline))\n+fnoinline1 (void);      /* { dg-warning \"follows inline declaration\" } */\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and warn_unused_result.  */\n+\n+int ATTR ((__noreturn__))\n+fnoret1 (void);\n+\n+int ATTR ((noreturn))\n+fnoret1 (void);               /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((warn_unused_result))\n+fnoret1 (void);               /* { dg-warning \"ignoring attribute .warn_unused_result. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Verify that repeating attribute noreturn doesn't trigger a warning.  */\n+int ATTR ((noreturn)) fnoret1 (void);\n+\n+int call_noret1 (void)\n+{\n+  /* Verify that attribute warn_unused_result was, in fact, ignored\n+     on the second declaration of fnoret1.  */\n+  fnoret1 ();\n+}\n+\n+int ATTR ((noreturn, warn_unused_result))\n+fnoret2 (void);               /* { dg-warning \"ignoring attribute .warn_unused_result. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Verify that repeating attribute noreturn doesn't trigger a warning.  */\n+int ATTR ((noreturn)) fnoret2 (void);\n+\n+int call_noret2 (void)\n+{\n+  /* Verify that attribute warn_unused_result was, in fact, ignored\n+     on the second declaration of fnoret2.  */\n+  fnoret2 ();\n+}\n+\n+/* Verify that attribute noreturn isn't diagnosed on a declaration\n+   that was previously declared warn_unused_result and that attribute\n+   was dropped (because the function returs void).  */\n+\n+void ATTR ((warn_unused_result))\n+fnorety6 (void);             /* { dg-warning \".warn_unused_result. attribute ignored\" } */\n+\n+void ATTR ((noreturn))\n+fnoret6 (void);\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and alloc_align.  */\n+\n+void* ATTR ((noreturn))\n+fnoret_alloc_align1 (int);    /* { dg-message \"previous declaration here\" } */\n+\n+void* ATTR ((alloc_align (1)))\n+fnoret_alloc_align1 (int);    /* { dg-warning \"ignoring attribute .alloc_align. because it conflicts with attribute .noreturn.\" } */\n+\n+void* ATTR ((noreturn, alloc_align (1)))\n+fnoret_alloc_align2 (int);    /* { dg-warning \"ignoring attribute .alloc_align. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+void* ATTR ((noreturn)) ATTR ((alloc_align (1)))\n+fnoret_alloc_align3 (int);    /* { dg-warning \"ignoring attribute .alloc_align. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+void* ATTR ((alloc_align (1)))\n+falloc_align_noret1 (int);    /* { dg-message \"previous declaration here\" } */\n+\n+void* ATTR ((noreturn))\n+falloc_align_noret1 (int);    /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .alloc_align.\" } */\n+\n+\n+void* ATTR ((alloc_align (1), noreturn))\n+falloc_align_noret2 (int);    /* { dg-warning \"ignoring attribute .(noreturn|alloc_align). because it conflicts with attribute .(alloc_align|noreturn).\" } */\n+\n+void* ATTR ((alloc_align (1))) ATTR ((noreturn))\n+falloc_align_noret3 (int);    /* { dg-warning \"ignoring attribute .(noreturn|alloc_align). because it conflicts with attribute .(noreturn|alloc_align).\" } */\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and alloc_size.  */\n+\n+void* ATTR ((noreturn))\n+fnoret_alloc_size1 (int);     /* { dg-message \"previous declaration here\" } */\n+\n+void* ATTR ((alloc_size (1)))\n+fnoret_alloc_size1 (int);     /* { dg-warning \"ignoring attribute .alloc_size. because it conflicts with attribute .noreturn.\" } */\n+\n+void* ATTR ((noreturn, alloc_size (1)))\n+fnoret_alloc_size2 (int);     /* { dg-warning \"ignoring attribute .alloc_size. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+void* ATTR ((noreturn)) ATTR ((alloc_size (1)))\n+fnoret_alloc_size3 (int);     /* { dg-warning \"ignoring attribute .alloc_size. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+void* ATTR ((alloc_size (1)))\n+falloc_size_noret1 (int);     /* { dg-message \"previous declaration here\" } */\n+\n+void* ATTR ((noreturn))\n+falloc_size_noret1 (int);     /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .alloc_size.\" } */\n+\n+\n+void* ATTR ((alloc_size (1), noreturn))\n+falloc_size_noret2 (int);     /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .alloc_size.\" } */\n+\n+void* ATTR ((alloc_size (1))) ATTR ((noreturn))\n+falloc_size_noret3 (int);     /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .alloc_size.\" } */\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and const.  */\n+\n+int ATTR ((noreturn))\n+fnoret_const1 (int);          /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((const))\n+fnoret_const1 (int);          /* { dg-warning \"ignoring attribute .const. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Unfortunately, attributes on a single declarations may not be processed\n+   in the same order as specified... */\n+int ATTR ((noreturn, const))\n+fnoret_const2 (int);          /* { dg-warning \"ignoring attribute .const. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+int ATTR ((noreturn)) ATTR ((const))\n+fnoret_const3 (int);          /* { dg-warning \"ignoring attribute .const. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+int ATTR ((const))\n+fconst_noret1 (int);          /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((noreturn))\n+fconst_noret1 (int);          /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .const.\" } */\n+\n+\n+int ATTR ((const, noreturn))\n+fconst_noret2 (int);          /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .const.\" } */\n+\n+int ATTR ((const)) ATTR ((noreturn))\n+fconst_noret3 (int);          /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .const.\" } */\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and malloc.  */\n+\n+void* ATTR ((noreturn))\n+fnoret_malloc1 (int);         /* { dg-message \"previous declaration here\" } */\n+\n+void* ATTR ((malloc))\n+fnoret_malloc1 (int);         /* { dg-warning \"ignoring attribute .malloc. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Unfortunately, attributes on a single declarations may not be processed\n+   in the same order as specified... */\n+void* ATTR ((noreturn, malloc))\n+fnoret_malloc2 (int);         /* { dg-warning \"ignoring attribute .malloc. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+void* ATTR ((noreturn)) ATTR ((malloc))\n+fnoret_malloc3 (int);         /* { dg-warning \"ignoring attribute .malloc. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+void* ATTR ((__malloc__))\n+fmalloc_noret1 (int);\n+\n+void* ATTR ((malloc))\n+fmalloc_noret1 (int);         /* { dg-message \"previous declaration here\" } */\n+\n+void* ATTR ((noreturn))\n+fmalloc_noret1 (int);         /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .malloc.\" } */\n+\n+\n+void* ATTR ((malloc, noreturn))\n+fmalloc_noret2 (int);         /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .malloc.\" } */\n+\n+void* ATTR ((malloc)) ATTR ((noreturn))\n+fmalloc_noret3 (int);         /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .malloc.\" } */\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and pure.  */\n+\n+int ATTR ((noreturn))\n+fnoret_pure1 (int);           /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((pure))\n+fnoret_pure1 (int);           /* { dg-warning \"ignoring attribute .pure. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Unfortunately, attributes on a single declarations may not be processed\n+   in the same order as specified... */\n+int ATTR ((noreturn, pure))\n+fnoret_pure2 (int);           /* { dg-warning \"ignoring attribute .pure. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+int ATTR ((noreturn)) ATTR ((pure))\n+fnoret_pure3 (int);           /* { dg-warning \"ignoring attribute .pure. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+int ATTR ((__pure__))\n+fpure_noret1 (int);\n+\n+int ATTR ((pure))\n+fpure_noret1 (int);           /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((noreturn))\n+fpure_noret1 (int);           /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .pure.\" } */\n+\n+\n+int ATTR ((pure, noreturn))\n+fpure_noret2 (int);           /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .pur.\" } */\n+\n+int ATTR ((pure)) ATTR ((noreturn))\n+fpure_noret3 (int);            /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .pure.\" } */\n+\n+\n+/* Exercise the handling of the mutually exclusive attributes\n+   noreturn and returns_twice.  */\n+\n+int ATTR ((noreturn))\n+fnoret_returns_twice1 (int);  /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((returns_twice))\n+fnoret_returns_twice1 (int);  /* { dg-warning \"ignoring attribute .returns_twice. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Unfortunately, attributes on a single declarations may not be processed\n+   in the same order as specified... */\n+int ATTR ((noreturn, returns_twice))\n+fnoret_returns_twice2 (int);  /* { dg-warning \"ignoring attribute .returns_twice. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+int ATTR ((noreturn)) ATTR ((returns_twice))\n+fnoret_returns_twice3 (int);  /* { dg-warning \"ignoring attribute .returns_twice. because it conflicts with attribute .noreturn.\" } */\n+\n+\n+int ATTR ((returns_twice))\n+freturns_twice_noret1 (int);  /* { dg-message \"previous declaration here\" } */\n+\n+int ATTR ((noreturn))\n+freturns_twice_noret1 (int);  /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .returns_twice.\" } */\n+\n+\n+int ATTR ((returns_twice, noreturn))\n+freturns_twice_noret2 (int);  /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .returns_twice.\" } */\n+\n+int ATTR ((returns_twice)) ATTR ((noreturn))\n+freturns_twice_noret3 (int);  /* { dg-warning \"ignoring attribute .noreturn. because it conflicts with attribute .returns_twice.\" } */\n+\n+\n+/* Exercise the interaction of multiple combinations of mutually\n+   exclusive attributes specified on distinct declarations.  */\n+\n+inline int ATTR ((always_inline))\n+finline_cold_noreturn (int);\n+\n+inline int ATTR ((cold))\n+finline_cold_noreturn (int);\n+\n+inline int ATTR ((noreturn))\n+finline_cold_noreturn (int);\n+\n+inline int ATTR ((noinline))\n+finline_cold_noreturn (int);    /* { dg-warning \"ignoring attribute .noinline. because it conflicts with attribute .always_inline.\" } */\n+\n+inline int ATTR ((hot))\n+finline_cold_noreturn (int);    /* { dg-warning \"ignoring attribute .hot. because it conflicts with attribute .cold.\" } */\n+\n+inline int ATTR ((warn_unused_result))\n+finline_cold_noreturn (int);    /* { dg-warning \"ignoring attribute .warn_unused_result. because it conflicts with attribute .noreturn.\" } */\n+\n+inline int ATTR ((always_inline))\n+finline_cold_noreturn (int);\n+\n+/* Expect no warning for the missing return statement below because\n+   the function is noreturn.  */\n+inline int ATTR ((noreturn))\n+finline_cold_noreturn (int i) { (void)&i; __builtin_abort (); }\n+\n+\n+/* Exercise the interaction of multiple combinations of mutually\n+   exclusive attributes with some specified on the same declaration\n+   and some on distinct declarations.  */\n+\n+inline int ATTR ((always_inline, hot))\n+finline_hot_noret_align (int);\n+\n+inline int ATTR ((noreturn, noinline))\n+finline_hot_noret_align (int);  /* { dg-warning \"ignoring attribute .noinline. because it conflicts with attribute .always_inline.\" } */\n+\n+inline int ATTR ((cold, aligned (8)))\n+finline_hot_noret_align (int);  /* { dg-warning \"ignoring attribute .cold. because it conflicts with attribute .hot.\" } */\n+\n+inline int ATTR ((warn_unused_result))\n+finline_hot_noret_align (int);  /* { dg-warning \"ignoring attribute .warn_unused_result. because it conflicts with attribute .noreturn.\" } */\n+\n+inline int ATTR ((aligned (4)))\n+finline_hot_noret_align (int);  /* { dg-warning \"ignoring attribute .aligned \\\\(4\\\\). because it conflicts with attribute .aligned \\\\(8\\\\).\" } */\n+\n+inline int ATTR ((aligned (8)))\n+finline_hot_noret_align (int);\n+\n+inline int ATTR ((const))\n+finline_hot_noret_align (int);  /* { dg-warning \"ignoring attribute .const. because it conflicts with attribute .noreturn.\" } */\n+\n+/* Expect no warning for the missing return statement below because\n+   the function is noreturn.  */\n+inline int ATTR ((noreturn))\n+finline_hot_noret_align (int i) { (void)&i; __builtin_abort (); }\n+\n+\n+/* Exercise variable attributes.  */\n+\n+extern int ATTR ((common))\n+decl_common1;                 /* { dg-message \"previous declaration here\" } */\n+\n+extern int ATTR ((nocommon))\n+decl_common1;                 /* { dg-warning \"ignoring attribute .nocommon. because it conflicts with attribute .common.\" } */\n+\n+\n+extern int ATTR ((nocommon))\n+decl_common2;                 /* { dg-message \"previous declaration here\" } */\n+\n+extern int ATTR ((common))\n+decl_common2;                 /* { dg-warning \"ignoring attribute .common. because it conflicts with attribute .nocommon.\" } */\n+\n+\n+extern int ATTR ((common, nocommon))\n+decl_common3;                 /* { dg-warning \"ignoring attribute .nocommon. because it conflicts with attribute .common.\" } */\n+\n+\n+extern int ATTR ((common, nocommon))\n+decl_common4;                 /* { dg-warning \"ignoring attribute .nocommon. because it conflicts with attribute .common.\" } */"}, {"sha": "0904742b01d03b4f8842af0c22e98bb59edf9723", "filename": "gcc/testsuite/gcc.dg/Wattributes-7.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eedff70182852a43d62a463c4dd65cdd8d567c70/gcc%2Ftestsuite%2Fgcc.dg%2FWattributes-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eedff70182852a43d62a463c4dd65cdd8d567c70/gcc%2Ftestsuite%2Fgcc.dg%2FWattributes-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWattributes-7.c?ref=eedff70182852a43d62a463c4dd65cdd8d567c70", "patch": "@@ -0,0 +1,74 @@\n+/* PR c/81566 - invalid attribute aligned accepted on functions\n+   { dg-do compile }\n+   { dg-options \"-Wall -Wattributes -ftrack-macro-expansion=0\" } */\n+\n+#define ATTR(list) __attribute__ (list)\n+#define ALIGN(n)   ATTR ((aligned (n)))\n+\n+/* It's okay to increase the alignment of a function.  */\n+\n+void ALIGN (16) ALIGN (32)\n+falign32_1 (void);\n+\n+void ALIGN (16) falign32_2 (void);\n+void ALIGN (32) falign32_2 (void);\n+\n+void falign32_2 (void) { }\n+\n+void ALIGN (32) falign32_2 (void);\n+\n+/* It's not okay to decrease it.  */\n+\n+void ALIGN (32) ALIGN (16)\n+falign64_3 (void);            /* { dg-warning \"ignoring attribute .aligned \\\\(16\\\\). because it conflicts with attribute .aligned \\\\(32\\\\).\" } */\n+\n+void ALIGN (32)\n+falign64_3 (void);\n+\n+void falign64_3 (void);\n+\n+void falign64_3 (void) { }\n+\n+\n+void ALIGN (32)\n+falign64_4 (void);            /* { dg-message \"previous declaration here\" } */\n+\n+void ALIGN (16)\n+falign64_4 (void);            /* { dg-warning \"ignoring attribute .aligned \\\\(16\\\\). because it conflicts with attribute .aligned \\\\(32\\\\).\" } */\n+\n+void ALIGN (32)\n+falign64_4 (void);            /* { dg-message \"previous declaration here\" } */\n+\n+void ALIGN (16)\n+falign64_4 (void);            /* { dg-warning \"ignoring attribute .aligned \\\\(16\\\\). because it conflicts with attribute .aligned \\\\(32\\\\).\" } */\n+\n+void ALIGN (64)\n+falign64_4 (void);\n+\n+void ALIGN (32)\n+falign64_4 (void);            /* { dg-warning \"ignoring attribute .aligned \\\\(32\\\\). because it conflicts with attribute .aligned \\\\(64\\\\).\" } */\n+\n+void falign64_4 (void);\n+\n+void ALIGN (64)\n+falign64_4 (void) { }\n+\n+void falign64_4 (void);\n+\n+void ALIGN (64)\n+falign64_4 (void);\n+\n+\n+void ATTR ((aligned (16), aligned (32)))\n+falign64_5 (void);\n+\n+void ATTR ((aligned (32), aligned (64)))\n+falign64_5 (void);\n+\n+void ATTR ((aligned (16), aligned (32), aligned (64)))\n+falign64_5 (void);            /* { dg-warning \"ignoring attribute .aligned \\\\(16\\\\). because it conflicts with attribute .aligned \\\\(64\\\\).\" } */\n+                              /* { dg-warning \"ignoring attribute .aligned \\\\(32\\\\). because it conflicts with attribute .aligned \\\\(64\\\\).\" \"\" { target *-*-* } .-1 } */\n+\n+\n+void ATTR ((aligned (16), aligned (32), aligned (16)))\n+falign64_6 (void);            /* { dg-warning \"ignoring attribute .aligned \\\\(16\\\\). because it conflicts with attribute .aligned \\\\(32\\\\).\" } */"}]}