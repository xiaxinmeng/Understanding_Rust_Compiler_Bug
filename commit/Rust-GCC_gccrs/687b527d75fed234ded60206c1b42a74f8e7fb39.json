{"sha": "687b527d75fed234ded60206c1b42a74f8e7fb39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg3YjUyN2Q3NWZlZDIzNGRlZDYwMjA2YzFiNDJhNzRmOGU3ZmIzOQ==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2005-04-20T14:30:38Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2005-04-20T14:30:38Z"}, "message": "re PR middle-end/20973 (kdelibs (khtml) miscompiled by reload)\n\n        PR20973\n        * reload.c (push_reload, find_dummy_reload): Check for uninitialized\n        pseudos.\n\nFrom-SVN: r98460", "tree": {"sha": "3ce552dca407dedbb61dd41a3c35faecde16be70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ce552dca407dedbb61dd41a3c35faecde16be70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/687b527d75fed234ded60206c1b42a74f8e7fb39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/687b527d75fed234ded60206c1b42a74f8e7fb39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/687b527d75fed234ded60206c1b42a74f8e7fb39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/687b527d75fed234ded60206c1b42a74f8e7fb39/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "71fc0c16760edea3b4d3c2afdda243bf8516df5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71fc0c16760edea3b4d3c2afdda243bf8516df5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71fc0c16760edea3b4d3c2afdda243bf8516df5c"}], "stats": {"total": 25, "additions": 23, "deletions": 2}, "files": [{"sha": "b6f7eab1973c7c1402a06b63b5474e47623acb23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/687b527d75fed234ded60206c1b42a74f8e7fb39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/687b527d75fed234ded60206c1b42a74f8e7fb39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=687b527d75fed234ded60206c1b42a74f8e7fb39", "patch": "@@ -1,3 +1,9 @@\n+2005-04-20  Michael Matz  <matz@suse.de>\n+\n+\tPR20973\n+\t* reload.c (push_reload, find_dummy_reload): Check for uninitialized\n+\tpseudos.\n+\n 2005-04-20  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-ssa-phiopt.c: Fix comment typos."}, {"sha": "29154753b85949e3e53114b3a7ff851e87d6ac0d", "filename": "gcc/reload.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/687b527d75fed234ded60206c1b42a74f8e7fb39/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/687b527d75fed234ded60206c1b42a74f8e7fb39/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=687b527d75fed234ded60206c1b42a74f8e7fb39", "patch": "@@ -1520,7 +1520,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n      But if there is no spilling in this block, that is OK.\n      An explicitly used hard reg cannot be a spill reg.  */\n \n-  if (rld[i].reg_rtx == 0 && in != 0)\n+  if (rld[i].reg_rtx == 0 && in != 0 && hard_regs_live_known)\n     {\n       rtx note;\n       int regno;\n@@ -1534,6 +1534,11 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t    && REG_P (XEXP (note, 0))\n \t    && (regno = REGNO (XEXP (note, 0))) < FIRST_PSEUDO_REGISTER\n \t    && reg_mentioned_p (XEXP (note, 0), in)\n+\t    /* Check that we don't use a hardreg for an uninitialized\n+\t       pseudo.  See also find_dummy_reload().  */\n+\t    && (ORIGINAL_REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n+\t\t|| ! bitmap_bit_p (ENTRY_BLOCK_PTR->global_live_at_end,\n+\t\t\t\t   ORIGINAL_REGNO (XEXP (note, 0))))\n \t    && ! refers_to_regno_for_reload_p (regno,\n \t\t\t\t\t       (regno\n \t\t\t\t\t\t+ hard_regno_nregs[regno]\n@@ -1997,7 +2002,17 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t\t\t\tis a subreg, and in that case, out\n \t\t\t\thas a real mode.  */\n \t\t\t     (GET_MODE (out) != VOIDmode\n-\t\t\t      ? GET_MODE (out) : outmode)))\n+\t\t\t      ? GET_MODE (out) : outmode))\n+        /* But only do all this if we can be sure, that this input\n+           operand doesn't correspond with an uninitialized pseudoreg.\n+           global can assign some hardreg to it, which is the same as\n+\t   a different pseudo also currently live (as it can ignore the\n+\t   conflict).  So we never must introduce writes to such hardregs,\n+\t   as they would clobber the other live pseudo using the same.\n+\t   See also PR20973.  */\n+      && (ORIGINAL_REGNO (in) < FIRST_PSEUDO_REGISTER\n+          || ! bitmap_bit_p (ENTRY_BLOCK_PTR->global_live_at_end,\n+\t\t\t     ORIGINAL_REGNO (in))))\n     {\n       unsigned int regno = REGNO (in) + in_offset;\n       unsigned int nwords = hard_regno_nregs[regno][inmode];"}]}