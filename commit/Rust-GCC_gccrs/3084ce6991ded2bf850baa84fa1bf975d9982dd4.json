{"sha": "3084ce6991ded2bf850baa84fa1bf975d9982dd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA4NGNlNjk5MWRlZDJiZjg1MGJhYTg0ZmExYmY5NzVkOTk4MmRkNA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-04-04T18:24:05Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-04-04T18:24:05Z"}, "message": "cprop.c: s/gcse/cprop/ everywhere except for flag_gcse.\n\n\t* cprop.c: s/gcse/cprop/ everywhere except for flag_gcse.\n\t(gcse_obstack): Renamed to cprop_obstack.\n\t(GNEW, GNEWVEC, GNEWVAR): Remove.\n\t(gmalloc): Remove.\n\t(alloc_hash_table): Use XNEWVAR instead of GNEWVAR.\n\t(GOBNEW, GOBNEWVAR): Adjust for gcse_obstack renaming.\n\t(gcse_alloc): Likewise, and rename to cprop_alloc.\n\t(alloc_gcse_men, free_gcse_mem): Remove.\n\t(gcse_constant_p): Rename to cprop_constant_p, and adjust all callers.\n\t(compute_hash_table_work): Allocate and free reg_set_bitmap here.\n\t(one_cprop_pass): Likewise. Adjust for gcse_obstack renaming.\n\nFrom-SVN: r171945", "tree": {"sha": "db753dc94d0ec86e96536ac0e6d4903f6c86c4db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db753dc94d0ec86e96536ac0e6d4903f6c86c4db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3084ce6991ded2bf850baa84fa1bf975d9982dd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3084ce6991ded2bf850baa84fa1bf975d9982dd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3084ce6991ded2bf850baa84fa1bf975d9982dd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3084ce6991ded2bf850baa84fa1bf975d9982dd4/comments", "author": null, "committer": null, "parents": [{"sha": "196565d4995d2aa82819808bfdbc57f0318140d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/196565d4995d2aa82819808bfdbc57f0318140d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/196565d4995d2aa82819808bfdbc57f0318140d6"}], "stats": {"total": 92, "additions": 40, "deletions": 52}, "files": [{"sha": "aa99741384a79810e1f3cf4df9954642db536d1c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3084ce6991ded2bf850baa84fa1bf975d9982dd4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3084ce6991ded2bf850baa84fa1bf975d9982dd4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3084ce6991ded2bf850baa84fa1bf975d9982dd4", "patch": "@@ -1,5 +1,17 @@\n 2011-04-04  Steven Bosscher  <steven@gcc.gnu.org>\n \n+\t* cprop.c: s/gcse/cprop/ everywhere except for flag_gcse.\n+\t(gcse_obstack): Renamed to cprop_obstack.\n+\t(GNEW, GNEWVEC, GNEWVAR): Remove.\n+\t(gmalloc): Remove.\n+\t(alloc_hash_table): Use XNEWVAR instead of GNEWVAR.\n+\t(GOBNEW, GOBNEWVAR): Adjust for gcse_obstack renaming.\n+\t(gcse_alloc): Likewise, and rename to cprop_alloc.\n+\t(alloc_gcse_men, free_gcse_mem): Remove.\n+\t(gcse_constant_p): Rename to cprop_constant_p, and adjust all callers.\n+\t(compute_hash_table_work): Allocate and free reg_set_bitmap here.\n+\t(one_cprop_pass): Likewise. Adjust for gcse_obstack renaming.\n+\n \t* cprop.c (oprs_not_set_p): Remove.\n \t(mark_set, mark_clobber): Remove.\n \t(mark_oprs_set): Rewrite using DF_INSN_INFO_DEFS cache."}, {"sha": "3f38be35da00cf8cee40b3bdb42808b1d701bd19", "filename": "gcc/cprop.c", "status": "modified", "additions": 28, "deletions": 52, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3084ce6991ded2bf850baa84fa1bf975d9982dd4/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3084ce6991ded2bf850baa84fa1bf975d9982dd4/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=3084ce6991ded2bf850baa84fa1bf975d9982dd4", "patch": "@@ -51,7 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n \n \f\n /* An obstack for our working variables.  */\n-static struct obstack gcse_obstack;\n+static struct obstack cprop_obstack;\n \n struct reg_use {rtx reg_rtx; };\n \n@@ -138,49 +138,16 @@ static int global_const_prop_count;\n static int global_copy_prop_count;\n \f\n \n-#define GNEW(T)\t\t\t((T *) gmalloc (sizeof (T)))\n-\n-#define GNEWVEC(T, N)\t\t((T *) gmalloc (sizeof (T) * (N)))\n-\n-#define GNEWVAR(T, S)\t\t((T *) gmalloc ((S)))\n-\n-#define GOBNEW(T)\t\t((T *) gcse_alloc (sizeof (T)))\n-#define GOBNEWVAR(T, S)\t\t((T *) gcse_alloc ((S)))\n-\f\n-/* Cover function to xmalloc to record bytes allocated.  */\n-\n-static void *\n-gmalloc (size_t size)\n-{\n-  bytes_used += size;\n-  return xmalloc (size);\n-}\n+#define GOBNEW(T)\t\t((T *) cprop_alloc (sizeof (T)))\n+#define GOBNEWVAR(T, S)\t\t((T *) cprop_alloc ((S)))\n \n /* Cover function to obstack_alloc.  */\n \n static void *\n-gcse_alloc (unsigned long size)\n+cprop_alloc (unsigned long size)\n {\n   bytes_used += size;\n-  return obstack_alloc (&gcse_obstack, size);\n-}\n-\n-/* Allocate memory for the reg/memory set tracking tables.\n-   This is called at the start of each pass.  */\n-\n-static void\n-alloc_gcse_mem (void)\n-{\n-  /* Allocate vars to track sets of regs.  */\n-  reg_set_bitmap = ALLOC_REG_SET (NULL);\n-}\n-\n-/* Free memory allocated by alloc_gcse_mem.  */\n-\n-static void\n-free_gcse_mem (void)\n-{\n-  FREE_REG_SET (reg_set_bitmap);\n+  return obstack_alloc (&cprop_obstack, size);\n }\n \f\n /* Return nonzero if register X is unchanged from INSN to the end\n@@ -292,7 +259,7 @@ insert_set_in_table (rtx x, rtx insn, struct hash_table_d *table)\n    is sharable.  */\n \n static bool\n-gcse_constant_p (const_rtx x)\n+cprop_constant_p (const_rtx x)\n {\n   return CONSTANT_P (x) && (GET_CODE (x) != CONST || shared_const_p (x));\n }\n@@ -328,15 +295,15 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n       if (note != 0\n \t  && REG_NOTE_KIND (note) == REG_EQUAL\n \t  && !REG_P (src)\n-\t  && gcse_constant_p (XEXP (note, 0)))\n+\t  && cprop_constant_p (XEXP (note, 0)))\n \tsrc = XEXP (note, 0), pat = gen_rtx_SET (VOIDmode, dest, src);\n \n       /* Record sets for constant/copy propagation.  */\n       if ((REG_P (src)\n \t   && src != dest\n \t   && ! HARD_REGISTER_P (src)\n \t   && reg_available_p (src, insn))\n-\t  || gcse_constant_p (src))\n+\t  || cprop_constant_p (src))\n \tinsert_set_in_table (pat, insn, table);\n     }\n }\n@@ -438,6 +405,9 @@ compute_hash_table_work (struct hash_table_d *table)\n {\n   basic_block bb;\n \n+  /* Allocate vars to track sets of regs.  */\n+  reg_set_bitmap = ALLOC_REG_SET (NULL);\n+\n   FOR_EACH_BB (bb)\n     {\n       rtx insn;\n@@ -467,6 +437,8 @@ compute_hash_table_work (struct hash_table_d *table)\n       if (implicit_sets[bb->index] != NULL_RTX)\n \thash_scan_set (implicit_sets[bb->index], BB_HEAD (bb), table);\n     }\n+\n+  FREE_REG_SET (reg_set_bitmap);\n }\n \n /* Allocate space for the set/expr hash TABLE.\n@@ -488,7 +460,7 @@ alloc_hash_table (struct hash_table_d *table)\n      ??? Later take some measurements.  */\n   table->size |= 1;\n   n = table->size * sizeof (struct expr *);\n-  table->table = GNEWVAR (struct expr *, n);\n+  table->table = XNEWVAR (struct expr *, n);\n }\n \n /* Free things allocated by alloc_hash_table.  */\n@@ -931,7 +903,7 @@ find_avail_set (int regno, rtx insn)\n          If the source operand changed, we may still use it for the next\n          iteration of this loop, but we may not use it for substitutions.  */\n \n-      if (gcse_constant_p (src) || reg_not_set_p (src, insn))\n+      if (cprop_constant_p (src) || reg_not_set_p (src, insn))\n \tset1 = set;\n \n       /* If the source of the set is anything except a register, then\n@@ -1145,7 +1117,7 @@ cprop_insn (rtx insn)\n       src = SET_SRC (pat);\n \n       /* Constant propagation.  */\n-      if (gcse_constant_p (src))\n+      if (cprop_constant_p (src))\n \t{\n           if (constprop_register (insn, reg_used->reg_rtx, src))\n \t    {\n@@ -1261,7 +1233,7 @@ do_local_cprop (rtx x, rtx insn)\n \t  rtx this_rtx = l->loc;\n \t  rtx note;\n \n-\t  if (gcse_constant_p (this_rtx))\n+\t  if (cprop_constant_p (this_rtx))\n \t    newcnst = this_rtx;\n \t  if (REG_P (this_rtx) && REGNO (this_rtx) >= FIRST_PSEUDO_REGISTER\n \t      /* Don't copy propagate if it has attached REG_EQUIV note.\n@@ -1400,7 +1372,7 @@ implicit_set_cond_p (const_rtx cond)\n \treturn 0;\n     }\n \n-  return gcse_constant_p (cst);\n+  return cprop_constant_p (cst);\n }\n \n /* Find the implicit sets of a function.  An \"implicit set\" is a constraint\n@@ -1497,7 +1469,7 @@ find_bypass_set (int regno, int bb)\n       gcc_assert (GET_CODE (set->expr) == SET);\n \n       src = SET_SRC (set->expr);\n-      if (gcse_constant_p (src))\n+      if (cprop_constant_p (src))\n \tresult = set;\n \n       if (! REG_P (src))\n@@ -1808,8 +1780,7 @@ one_cprop_pass (void)\n   global_copy_prop_count = local_copy_prop_count = 0;\n \n   bytes_used = 0;\n-  gcc_obstack_init (&gcse_obstack);\n-  alloc_gcse_mem ();\n+  gcc_obstack_init (&cprop_obstack);\n \n   /* Do a local const/copy propagation pass first.  The global pass\n      only handles global opportunities.\n@@ -1824,7 +1795,8 @@ one_cprop_pass (void)\n      FIXME: The global analysis would not get into infinite loops if it\n \t    would use the DF solver (via df_simple_dataflow) instead of\n \t    the solver implemented in this file.  */\n-  if (local_cprop_pass ())\n+  changed |= local_cprop_pass ();\n+  if (changed)\n     {\n       delete_unreachable_blocks ();\n       df_analyze ();\n@@ -1851,6 +1823,9 @@ one_cprop_pass (void)\n       alloc_cprop_mem (last_basic_block, set_hash_table.n_elems);\n       compute_cprop_data ();\n \n+      /* Allocate vars to track sets of regs.  */\n+      reg_set_bitmap = ALLOC_REG_SET (NULL);\n+\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb, EXIT_BLOCK_PTR, next_bb)\n \t{\n \t  /* Reset tables used to keep track of what's still valid [since\n@@ -1872,12 +1847,13 @@ one_cprop_pass (void)\n \t}\n \n       changed |= bypass_conditional_jumps ();\n+\n+      FREE_REG_SET (reg_set_bitmap);\n       free_cprop_mem ();\n     }\n \n   free_hash_table (&set_hash_table);\n-  free_gcse_mem ();\n-  obstack_free (&gcse_obstack, NULL);\n+  obstack_free (&cprop_obstack, NULL);\n \n   if (dump_file)\n     {"}]}