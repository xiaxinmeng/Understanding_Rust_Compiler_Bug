{"sha": "9042fea9722a928de2c85e1c9462ab0d3380135a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA0MmZlYTk3MjJhOTI4ZGUyYzg1ZTFjOTQ2MmFiMGQzMzgwMTM1YQ==", "commit": {"author": {"name": "Giuliano Belinassi", "email": "giuliano.belinassi@usp.br", "date": "2020-05-13T00:37:01Z"}, "committer": {"name": "Giuliano Belinassi", "email": "giuliano.belinassi@usp.br", "date": "2020-05-13T00:37:01Z"}, "message": "Refactor tree-vrp.c\n\nRefactor tree-vrp.c to eliminate all global variables except\n'x_vrp_values', which will require that 'thread_outgoing_edges'\nto accept an extra argument and pass it to the 'simplify' callback.\n\nIt also removes every access to 'cfun', retrieving the function being\ncompiled from the pass engine.\n\ngcc/ChangeLog\n2020-05-12  Giuliano Belinassi  <giuliano.belinassi@usp.br>\n\n\t* tree-vrp.c (class vrp_insert): New.\n\t(insert_range_assertions): Move to class vrp_insert.\n\t(dump_all_asserts): Same as above.\n\t(dump_asserts_for): Same as above.\n\t(live): Same as above.\n\t(need_assert_for): Same as above.\n\t(live_on_edge): Same as above.\n\t(finish_register_edge_assert_for): Same as above.\n\t(find_switch_asserts): Same as above.\n\t(find_assert_locations): Same as above.\n\t(find_assert_locations_1): Same as above.\n\t(find_conditional_asserts): Same as above.\n\t(process_assert_insertions): Same as above.\n\t(register_new_assert_for): Same as above.\n\t(vrp_prop): New variable fun.\n\t(vrp_initialize): New parameter.\n\t(identify_jump_threads): Same as above.\n\t(execute_vrp): Same as above.", "tree": {"sha": "af5a367d8b3332a69f5dff61f3a0b606a3255909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af5a367d8b3332a69f5dff61f3a0b606a3255909"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9042fea9722a928de2c85e1c9462ab0d3380135a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9042fea9722a928de2c85e1c9462ab0d3380135a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9042fea9722a928de2c85e1c9462ab0d3380135a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9042fea9722a928de2c85e1c9462ab0d3380135a/comments", "author": null, "committer": null, "parents": [{"sha": "0e6d007460f259baaab7a687f6b74211aecf4cc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e6d007460f259baaab7a687f6b74211aecf4cc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e6d007460f259baaab7a687f6b74211aecf4cc2"}], "stats": {"total": 331, "additions": 220, "deletions": 111}, "files": [{"sha": "3c53fde191e5b0133e2374f9787d278d5e09fbde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9042fea9722a928de2c85e1c9462ab0d3380135a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9042fea9722a928de2c85e1c9462ab0d3380135a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9042fea9722a928de2c85e1c9462ab0d3380135a", "patch": "@@ -1,3 +1,25 @@\n+2020-05-12  Giuliano Belinassi  <giuliano.belinassi@usp.br>\n+\n+\t* tree-vrp.c (class vrp_insert): New.\n+\t(insert_range_assertions): Move to class vrp_insert.\n+\t(dump_all_asserts): Same as above.\n+\t(dump_asserts_for): Same as above.\n+\t(live): Same as above.\n+\t(need_assert_for): Same as above.\n+\t(live_on_edge): Same as above.\n+\t(finish_register_edge_assert_for): Same as above.\n+\t(find_switch_asserts): Same as above.\n+\t(find_assert_locations): Same as above.\n+\t(find_assert_locations_1): Same as above.\n+\t(find_conditional_asserts): Same as above.\n+\t(process_assert_insertions): Same as above.\n+\t(register_new_assert_for): Same as above.\n+\t(vrp_prop): New variable fun.\n+\t(vrp_initialize): New parameter.\n+\t(identify_jump_threads): Same as above.\n+\t(execute_vrp): Same as above.\n+\n+\n 2020-05-12  Keith Packard  <keith.packard@sifive.com>\n \n \t* config/riscv/riscv.c (riscv_unique_section): New."}, {"sha": "1001c7f41d8a8aa34b4b7b2a5e7d084fe5ba7e4d", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 198, "deletions": 111, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9042fea9722a928de2c85e1c9462ab0d3380135a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9042fea9722a928de2c85e1c9462ab0d3380135a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=9042fea9722a928de2c85e1c9462ab0d3380135a", "patch": "@@ -68,9 +68,149 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"range-op.h\"\n \n-/* Set of SSA names found live during the RPO traversal of the function\n-   for still active basic-blocks.  */\n-static sbitmap *live;\n+\n+\n+/* Location information for ASSERT_EXPRs.  Each instance of this\n+   structure describes an ASSERT_EXPR for an SSA name.  Since a single\n+   SSA name may have more than one assertion associated with it, these\n+   locations are kept in a linked list attached to the corresponding\n+   SSA name.  */\n+struct assert_locus\n+{\n+  /* Basic block where the assertion would be inserted.  */\n+  basic_block bb;\n+\n+  /* Some assertions need to be inserted on an edge (e.g., assertions\n+     generated by COND_EXPRs).  In those cases, BB will be NULL.  */\n+  edge e;\n+\n+  /* Pointer to the statement that generated this assertion.  */\n+  gimple_stmt_iterator si;\n+\n+  /* Predicate code for the ASSERT_EXPR.  Must be COMPARISON_CLASS_P.  */\n+  enum tree_code comp_code;\n+\n+  /* Value being compared against.  */\n+  tree val;\n+\n+  /* Expression to compare.  */\n+  tree expr;\n+\n+  /* Next node in the linked list.  */\n+  assert_locus *next;\n+};\n+\n+class vrp_insert\n+{\n+  public:\n+\n+    vrp_insert (struct function *fn)\n+      {\n+\tfun = fn;\n+      }\n+\n+    /* Traverse the flowgraph looking for conditional jumps to insert range\n+       expressions.  These range expressions are meant to provide information\n+       to optimizations that need to reason in terms of value ranges.  They\n+       will not be expanded into RTL.  See method implementation comment\n+       for example.  */\n+    void insert_range_assertions ();\n+\n+\n+    /* Dump all the registered assertions for all the names to FILE.  */\n+    void dump_all_asserts (FILE *);\n+\n+    /* Dump all the registered assertions for NAME to FILE.  */\n+    void dump_asserts_for (FILE *file, tree name);\n+\n+    /* Dump all the registered assertions for NAME to stderr.  */\n+    DEBUG_FUNCTION void debug_asserts_for (tree name)\n+      {\n+\tdump_asserts_for (stderr, name);\n+      }\n+\n+    DEBUG_FUNCTION void debug_all_asserts ()\n+      {\n+\tdump_all_asserts (stderr);\n+      }\n+\n+  private:\n+    /* Set of SSA names found live during the RPO traversal of the function\n+       for still active basic-blocks.  */\n+    sbitmap *live;\n+\n+    /* Function to work on.  */\n+    struct function *fun;\n+\n+    /* If bit I is present, it means that SSA name N_i has a list of\n+       assertions that should be inserted in the IL.  */\n+    bitmap need_assert_for;\n+\n+    /* Array of locations lists where to insert assertions.  ASSERTS_FOR[I]\n+       holds a list of ASSERT_LOCUS_T nodes that describe where\n+       ASSERT_EXPRs for SSA name N_I should be inserted.  */\n+    assert_locus **asserts_for;\n+\n+    /* Return true if the SSA name NAME is live on the edge E.  */\n+    bool live_on_edge (edge e, tree name);\n+\n+    /* Finish found ASSERTS for E and register them at GSI.  */\n+    void finish_register_edge_assert_for (edge e, gimple_stmt_iterator gsi,\n+\t\t\t\t\t  vec<assert_info> &asserts);\n+\n+    /* Determine whether the outgoing edges of BB should receive an\n+       ASSERT_EXPR for each of the operands of BB's LAST statement.\n+       The last statement of BB must be a SWITCH_EXPR.\n+\n+       If any of the sub-graphs rooted at BB have an interesting use of\n+       the predicate operands, an assert location node is added to the\n+       list of assertions for the corresponding operands.  */\n+    void find_switch_asserts (basic_block bb, gswitch *last);\n+\n+\n+    /* Do an RPO walk over the function computing SSA name liveness\n+       on-the-fly and deciding on assert expressions to insert.  */\n+    void find_assert_locations ();\n+\n+    /* Traverse all the statements in block BB looking for statements that\n+       may generate useful assertions for the SSA names in their operand.\n+       See method implementation comentary for more information.  */\n+    void find_assert_locations_1 (basic_block bb, sbitmap live);\n+\n+    /* Determine whether the outgoing edges of BB should receive an\n+       ASSERT_EXPR for each of the operands of BB's LAST statement.\n+       The last statement of BB must be a COND_EXPR.\n+\n+       If any of the sub-graphs rooted at BB have an interesting use of\n+       the predicate operands, an assert location node is added to the\n+       list of assertions for the corresponding operands.  */\n+    void find_conditional_asserts (basic_block bb, gcond *last);\n+\n+\n+    /* Process all the insertions registered for every name N_i registered\n+       in NEED_ASSERT_FOR.  The list of assertions to be inserted are\n+       found in ASSERTS_FOR[i].  */\n+\n+    void process_assert_insertions ();\n+\n+\n+    /* If NAME doesn't have an ASSERT_EXPR registered for asserting\n+       'EXPR COMP_CODE VAL' at a location that dominates block BB or\n+       E->DEST, then register this location as a possible insertion point\n+       for ASSERT_EXPR <NAME, EXPR COMP_CODE VAL>.\n+\n+       BB, E and SI provide the exact insertion point for the new\n+       ASSERT_EXPR.  If BB is NULL, then the ASSERT_EXPR is to be inserted\n+       on edge E.  Otherwise, if E is NULL, the ASSERT_EXPR is inserted on\n+       BB.  If SI points to a COND_EXPR or a SWITCH_EXPR statement, then E\n+       must not be NULL.  */\n+    void register_new_assert_for (tree name, tree expr,\n+\t\t\t\t  enum tree_code comp_code,\n+\t\t\t\t  tree val,\n+\t\t\t\t  basic_block bb,\n+\t\t\t\t  edge e,\n+\t\t\t\t  gimple_stmt_iterator si);\n+};\n \n void\n value_range_equiv::set_equiv (bitmap equiv)\n@@ -278,51 +418,13 @@ debug (const value_range_equiv &vr)\n \n /* Return true if the SSA name NAME is live on the edge E.  */\n \n-static bool\n-live_on_edge (edge e, tree name)\n+bool\n+vrp_insert::live_on_edge (edge e, tree name)\n {\n   return (live[e->dest->index]\n \t  && bitmap_bit_p (live[e->dest->index], SSA_NAME_VERSION (name)));\n }\n \n-/* Location information for ASSERT_EXPRs.  Each instance of this\n-   structure describes an ASSERT_EXPR for an SSA name.  Since a single\n-   SSA name may have more than one assertion associated with it, these\n-   locations are kept in a linked list attached to the corresponding\n-   SSA name.  */\n-struct assert_locus\n-{\n-  /* Basic block where the assertion would be inserted.  */\n-  basic_block bb;\n-\n-  /* Some assertions need to be inserted on an edge (e.g., assertions\n-     generated by COND_EXPRs).  In those cases, BB will be NULL.  */\n-  edge e;\n-\n-  /* Pointer to the statement that generated this assertion.  */\n-  gimple_stmt_iterator si;\n-\n-  /* Predicate code for the ASSERT_EXPR.  Must be COMPARISON_CLASS_P.  */\n-  enum tree_code comp_code;\n-\n-  /* Value being compared against.  */\n-  tree val;\n-\n-  /* Expression to compare.  */\n-  tree expr;\n-\n-  /* Next node in the linked list.  */\n-  assert_locus *next;\n-};\n-\n-/* If bit I is present, it means that SSA name N_i has a list of\n-   assertions that should be inserted in the IL.  */\n-static bitmap need_assert_for;\n-\n-/* Array of locations lists where to insert assertions.  ASSERTS_FOR[I]\n-   holds a list of ASSERT_LOCUS_T nodes that describe where\n-   ASSERT_EXPRs for SSA name N_I should be inserted.  */\n-static assert_locus **asserts_for;\n \n /* VR_TYPE describes a range with mininum value *MIN and maximum\n    value *MAX.  Restrict the range to the set of values that have\n@@ -1359,15 +1461,14 @@ infer_value_range (gimple *stmt, tree op, tree_code *comp_code_p, tree *val_p)\n }\n \n \n-void dump_asserts_for (FILE *, tree);\n void debug_asserts_for (tree);\n void dump_all_asserts (FILE *);\n void debug_all_asserts (void);\n \n /* Dump all the registered assertions for NAME to FILE.  */\n \n void\n-dump_asserts_for (FILE *file, tree name)\n+vrp_insert::dump_asserts_for (FILE *file, tree name)\n {\n   assert_locus *loc;\n \n@@ -1399,19 +1500,10 @@ dump_asserts_for (FILE *file, tree name)\n }\n \n \n-/* Dump all the registered assertions for NAME to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_asserts_for (tree name)\n-{\n-  dump_asserts_for (stderr, name);\n-}\n-\n-\n /* Dump all the registered assertions for all the names to FILE.  */\n \n void\n-dump_all_asserts (FILE *file)\n+vrp_insert::dump_all_asserts (FILE *file)\n {\n   unsigned i;\n   bitmap_iterator bi;\n@@ -1423,14 +1515,6 @@ dump_all_asserts (FILE *file)\n }\n \n \n-/* Dump all the registered assertions for all the names to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_all_asserts (void)\n-{\n-  dump_all_asserts (stderr);\n-}\n-\n /* Dump assert_info structure.  */\n \n void\n@@ -1501,13 +1585,13 @@ add_assert_info (vec<assert_info> &asserts,\n    BB.  If SI points to a COND_EXPR or a SWITCH_EXPR statement, then E\n    must not be NULL.  */\n \n-static void\n-register_new_assert_for (tree name, tree expr,\n-\t\t\t enum tree_code comp_code,\n-\t\t\t tree val,\n-\t\t\t basic_block bb,\n-\t\t\t edge e,\n-\t\t\t gimple_stmt_iterator si)\n+void\n+vrp_insert::register_new_assert_for (tree name, tree expr,\n+\t\t\t\t   enum tree_code comp_code,\n+\t\t\t\t   tree val,\n+\t\t\t\t   basic_block bb,\n+\t\t\t\t   edge e,\n+\t\t\t\t   gimple_stmt_iterator si)\n {\n   assert_locus *n, *loc, *last_loc;\n   basic_block dest_bb;\n@@ -2613,9 +2697,9 @@ register_edge_assert_for (tree name, edge e,\n \n /* Finish found ASSERTS for E and register them at GSI.  */\n \n-static void\n-finish_register_edge_assert_for (edge e, gimple_stmt_iterator gsi,\n-\t\t\t\t vec<assert_info> &asserts)\n+void\n+vrp_insert::finish_register_edge_assert_for (edge e, gimple_stmt_iterator gsi,\n+\t\t\t\t\t   vec<assert_info> &asserts)\n {\n   for (unsigned i = 0; i < asserts.length (); ++i)\n     /* Only register an ASSERT_EXPR if NAME was found in the sub-graph\n@@ -2636,8 +2720,8 @@ finish_register_edge_assert_for (edge e, gimple_stmt_iterator gsi,\n    the predicate operands, an assert location node is added to the\n    list of assertions for the corresponding operands.  */\n \n-static void\n-find_conditional_asserts (basic_block bb, gcond *last)\n+void\n+vrp_insert::find_conditional_asserts (basic_block bb, gcond *last)\n {\n   gimple_stmt_iterator bsi;\n   tree op;\n@@ -2710,8 +2794,8 @@ compare_case_labels (const void *p1, const void *p2)\n    the predicate operands, an assert location node is added to the\n    list of assertions for the corresponding operands.  */\n \n-static void\n-find_switch_asserts (basic_block bb, gswitch *last)\n+void\n+vrp_insert::find_switch_asserts (basic_block bb, gswitch *last)\n {\n   gimple_stmt_iterator bsi;\n   tree op;\n@@ -2735,7 +2819,7 @@ find_switch_asserts (basic_block bb, gswitch *last)\n   for (idx = 0; idx < n; ++idx)\n     {\n       ci[idx].expr = gimple_switch_label (last, idx);\n-      ci[idx].bb = label_to_block (cfun, CASE_LABEL (ci[idx].expr));\n+      ci[idx].bb = label_to_block (fun, CASE_LABEL (ci[idx].expr));\n     }\n   edge default_edge = find_edge (bb, ci[0].bb);\n   qsort (ci, n, sizeof (struct case_info), compare_case_labels);\n@@ -2920,8 +3004,8 @@ find_switch_asserts (basic_block bb, gswitch *last)\n    dominator tree, only the location dominating all the dereference of\n    P_4 will receive an ASSERT_EXPR.  */\n \n-static void\n-find_assert_locations_1 (basic_block bb, sbitmap live)\n+void\n+vrp_insert::find_assert_locations_1 (basic_block bb, sbitmap live)\n {\n   gimple *last;\n \n@@ -3040,15 +3124,15 @@ find_assert_locations_1 (basic_block bb, sbitmap live)\n /* Do an RPO walk over the function computing SSA name liveness\n    on-the-fly and deciding on assert expressions to insert.  */\n \n-static void\n-find_assert_locations (void)\n+void\n+vrp_insert::find_assert_locations (void)\n {\n-  int *rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n-  int *bb_rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n-  int *last_rpo = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n+  int *rpo = XNEWVEC (int, last_basic_block_for_fn (fun));\n+  int *bb_rpo = XNEWVEC (int, last_basic_block_for_fn (fun));\n+  int *last_rpo = XCNEWVEC (int, last_basic_block_for_fn (fun));\n   int rpo_cnt, i;\n \n-  live = XCNEWVEC (sbitmap, last_basic_block_for_fn (cfun));\n+  live = XCNEWVEC (sbitmap, last_basic_block_for_fn (fun));\n   rpo_cnt = pre_and_rev_post_order_compute (NULL, rpo, false);\n   for (i = 0; i < rpo_cnt; ++i)\n     bb_rpo[rpo[i]] = i;\n@@ -3082,7 +3166,7 @@ find_assert_locations (void)\n \n   for (i = rpo_cnt - 1; i >= 0; --i)\n     {\n-      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, rpo[i]);\n+      basic_block bb = BASIC_BLOCK_FOR_FN (fun, rpo[i]);\n       edge e;\n       edge_iterator ei;\n \n@@ -3141,7 +3225,7 @@ find_assert_locations (void)\n   XDELETEVEC (rpo);\n   XDELETEVEC (bb_rpo);\n   XDELETEVEC (last_rpo);\n-  for (i = 0; i < last_basic_block_for_fn (cfun); ++i)\n+  for (i = 0; i < last_basic_block_for_fn (fun); ++i)\n     if (live[i])\n       sbitmap_free (live[i]);\n   XDELETEVEC (live);\n@@ -3283,8 +3367,8 @@ compare_assert_loc (const void *pa, const void *pb)\n    in NEED_ASSERT_FOR.  The list of assertions to be inserted are\n    found in ASSERTS_FOR[i].  */\n \n-static void\n-process_assert_insertions (void)\n+void\n+vrp_insert::process_assert_insertions ()\n {\n   unsigned i;\n   bitmap_iterator bi;\n@@ -3373,7 +3457,7 @@ process_assert_insertions (void)\n   if (update_edges_p)\n     gsi_commit_edge_inserts ();\n \n-  statistics_counter_event (cfun, \"Number of ASSERT_EXPR expressions inserted\",\n+  statistics_counter_event (fun, \"Number of ASSERT_EXPR expressions inserted\",\n \t\t\t    num_asserts);\n }\n \n@@ -3410,8 +3494,8 @@ process_assert_insertions (void)\n    take in different paths of the code, simply by checking the reaching\n    definition of 'x'.  */\n \n-static void\n-insert_range_assertions (void)\n+void\n+vrp_insert::insert_range_assertions (void)\n {\n   need_assert_for = BITMAP_ALLOC (NULL);\n   asserts_for = XCNEWVEC (assert_locus *, num_ssa_names);\n@@ -3441,7 +3525,9 @@ class vrp_prop : public ssa_propagation_engine\n   enum ssa_prop_result visit_stmt (gimple *, edge *, tree *) FINAL OVERRIDE;\n   enum ssa_prop_result visit_phi (gphi *) FINAL OVERRIDE;\n \n-  void vrp_initialize (void);\n+  struct function *fun;\n+\n+  void vrp_initialize (struct function *);\n   void vrp_finalize (bool);\n   void check_all_array_refs (void);\n   bool check_array_ref (location_t, tree, bool);\n@@ -4134,7 +4220,7 @@ void\n vrp_prop::check_all_array_refs ()\n {\n   check_array_bounds_dom_walker w (this);\n-  w.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  w.walk (ENTRY_BLOCK_PTR_FOR_FN (fun));\n }\n \n /* Return true if all imm uses of VAR are either in STMT, or\n@@ -4243,7 +4329,7 @@ maybe_set_nonzero_bits (edge e, tree var)\n    multiple ranges to be associated with one SSA_NAME.  */\n \n static void\n-remove_range_assertions (void)\n+remove_range_assertions (struct function *fun)\n {\n   basic_block bb;\n   gimple_stmt_iterator si;\n@@ -4255,7 +4341,7 @@ remove_range_assertions (void)\n   /* Note that the BSI iterator bump happens at the bottom of the\n      loop and no bump is necessary if we're removing the statement\n      referenced by the current BSI.  */\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     for (si = gsi_after_labels (bb), is_unreachable = -1; !gsi_end_p (si);)\n       {\n \tgimple *stmt = gsi_stmt (si);\n@@ -4379,11 +4465,12 @@ stmt_interesting_for_vrp (gimple *stmt)\n /* Initialization required by ssa_propagate engine.  */\n \n void\n-vrp_prop::vrp_initialize ()\n+vrp_prop::vrp_initialize (struct function *fn)\n {\n   basic_block bb;\n+  fun = fn;\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n \t   gsi_next (&si))\n@@ -5119,7 +5206,7 @@ vrp_dom_walker::after_dom_children (basic_block bb)\n    for later realization.  */\n \n static void\n-identify_jump_threads (class vr_values *vr_values)\n+identify_jump_threads (struct function *fun, class vr_values *vr_values)\n {\n   /* Ugh.  When substituting values earlier in this pass we can\n      wipe the dominance information.  So rebuild the dominator\n@@ -5144,7 +5231,7 @@ identify_jump_threads (class vr_values *vr_values)\n \n   vrp_dom_walker walker (CDI_DOMINATORS, equiv_stack, avail_exprs_stack);\n   walker.vr_values = vr_values;\n-  walker.walk (cfun->cfg->x_entry_block_ptr);\n+  walker.walk (fun->cfg->x_entry_block_ptr);\n \n   /* We do not actually update the CFG or SSA graphs at this point as\n      ASSERT_EXPRs are still in the IL and cfg cleanup code does not yet\n@@ -5199,7 +5286,7 @@ vrp_prop::vrp_finalize (bool warn_array_bounds_p)\n      check_array_bounds_dom_walker's ctor; vrp_folder may clear\n      it from some edges.  */\n   if (warn_array_bounds && warn_array_bounds_p)\n-    set_all_edges_as_executable (cfun);\n+    set_all_edges_as_executable (fun);\n \n   class vrp_folder vrp_folder;\n   vrp_folder.vr_values = &vr_values;\n@@ -5254,7 +5341,7 @@ vrp_prop::vrp_finalize (bool warn_array_bounds_p)\n    probabilities to aid branch prediction.  */\n \n static unsigned int\n-execute_vrp (bool warn_array_bounds_p)\n+execute_vrp (struct function *fun, bool warn_array_bounds_p)\n {\n \n   loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n@@ -5264,21 +5351,21 @@ execute_vrp (bool warn_array_bounds_p)\n   /* ???  This ends up using stale EDGE_DFS_BACK for liveness computation.\n      Inserting assertions may split edges which will invalidate\n      EDGE_DFS_BACK.  */\n-  insert_range_assertions ();\n+  vrp_insert (fun).insert_range_assertions ();\n \n   threadedge_initialize_values ();\n \n   /* For visiting PHI nodes we need EDGE_DFS_BACK computed.  */\n   mark_dfs_back_edges ();\n \n   class vrp_prop vrp_prop;\n-  vrp_prop.vrp_initialize ();\n+  vrp_prop.vrp_initialize (fun);\n   vrp_prop.ssa_propagate ();\n   vrp_prop.vrp_finalize (warn_array_bounds_p);\n \n   /* We must identify jump threading opportunities before we release\n      the datastructures built by VRP.  */\n-  identify_jump_threads (&vrp_prop.vr_values);\n+  identify_jump_threads (fun, &vrp_prop.vr_values);\n \n   /* A comparison of an SSA_NAME against a constant where the SSA_NAME\n      was set by a type conversion can often be rewritten to use the\n@@ -5288,19 +5375,19 @@ execute_vrp (bool warn_array_bounds_p)\n      So that transformation is not performed until after jump threading\n      is complete.  */\n   basic_block bb;\n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple *last = last_stmt (bb);\n       if (last && gimple_code (last) == GIMPLE_COND)\n \tvrp_prop.vr_values.simplify_cond_using_ranges_2 (as_a <gcond *> (last));\n     }\n \n-  free_numbers_of_iterations_estimates (cfun);\n+  free_numbers_of_iterations_estimates (fun);\n \n   /* ASSERT_EXPRs must be removed before finalizing jump threads\n      as finalizing jump threads calls the CFG cleanup code which\n      does not properly handle ASSERT_EXPRs.  */\n-  remove_range_assertions ();\n+  remove_range_assertions (fun);\n \n   /* If we exposed any new variables, go ahead and put them into\n      SSA form now, before we handle jump threading.  This simplifies\n@@ -5355,8 +5442,8 @@ class pass_vrp : public gimple_opt_pass\n       warn_array_bounds_p = param;\n     }\n   virtual bool gate (function *) { return flag_tree_vrp != 0; }\n-  virtual unsigned int execute (function *)\n-    { return execute_vrp (warn_array_bounds_p); }\n+  virtual unsigned int execute (function *fun)\n+    { return execute_vrp (fun, warn_array_bounds_p); }\n \n  private:\n   bool warn_array_bounds_p;"}]}