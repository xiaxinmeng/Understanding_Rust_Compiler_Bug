{"sha": "c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVkMmRlNmI0Yzk3NmRjMTUyYzg2MThhYjNlOGUxMzE5MDE4ZGMzMA==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-05-27T06:17:44Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-05-27T06:17:44Z"}, "message": "[multiple changes]\n\n2004-05-25  David Jee  <djee@redhat.com>\n\n\t* java/awt/Container.java\n\t(remove): Set component's parent to null only after we removed the\n\tcomponent from its parent's layout manager.\n\n2004-05-25  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java\n\t(GtkComponentPeer): Set bounds regardless of whether awtComponent\n\tis valid.\n\t* gnu/java/awt/peer/gtk/GtkListPeer.java\n\t(getSize): Change native method declaration.\n\t(minimumSize): Pass visible row count into getSize().\n\t(preferredSize): Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.c\n\t(Java_gnu_java_awt_peer_gtk_GtkListPeer_getSize): Use scroll window's\n\tnatural size. Use visible row count to determine the final height\n\tvalue to return.\n\n2004-05-21  Graydon Hoare  <graydon@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n\t(setClip): Minor correction to order of operations.\n\n\t* javax/swing/JScrollPane.java: Extend sketchy implementation.\n\t* javax/swing/ScrollPaneLayout.java: Likewise.\n\t* javax/swing/JViewPort.java: Likewise.\n\t* javax/swing/ViewportLayout.java: Likewise.\n\n\t* javax/swing/JComponent.java: Rewrite.\n\t* javax/swing/RepaintManager.java: Likewise.\n\n\t* javax/swing/JLayeredPane.java: Change validate() to revalidate().\n\t* javax/swing/JList.java\n\t(setSelectedIndices):\n\t(getSelectedIndices):\n\t(getSelectedValues): New functions.\n\t(getPreferredScrollableViewportSize): Return preferred size.\n\t(getScrollableUnitIncrement):\n\t(getScrollableBlockIncrement): Initial implementations.\n\t* javax/swing/JRootPane.java: Clean up slightly.\n\t(getUI):\n\t(setUI):\n\t(updateUI):\n\t(getUIClassID):\n\t(isValidateRoot): Add overrides from JComponent.\n\t* javax/swing/JScrollBar.java: Set default orientation to VERTICAL.\n\t* javax/swing/UIManager.java (getDimension): Return the dimension.\n\n\t* javax/swing/plaf/basic/BasicButtonUI.java: Set component opaque.\n\t* javax/swing/plaf/basic/BasicLabelUI.java: Likewise.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java: Likewise.\n\t* javax/swing/plaf/basic/BasicProgressBarUI.java: Likewise.\n\t* javax/swing/plaf/basic/BasicSeparatorUI.java: Likewise.\n\t* javax/swing/plaf/basic/BasicSliderUI.java: Likewise.\n\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java: Likewise.\n\t* javax/swing/plaf/basic/BasicRootPaneUI.java:\n\tLikewise, and set background.\n\t* javax/swing/plaf/basic/BasicListUI.java:\n\tLikewise, and improve a bit.\n\t* javax/swing/plaf/basic/BasicScrollBarUI.java:\n\tLikewise, and adjust calculations.\n\t* javax/swing/plaf/basic/BasicViewportUI.java:\n\tLikewise, and improve a bit.\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java\n\t(Button.margin): Shrink.\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGlyphVector.c:\n\tHack to set horizontal always, workaround pango.\n\n\t* jni/gtk-peer/gtkcairopeer.h: Change to match pattern API.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c:\n\tSynchronize more often, check cairo status after ops,\n\thandle changes to cairo pattern API, check for disposal.\n\n2004-05-21  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n\t(BasicMenuItemUI): Create propertyChangeListener.\n\t(getPath):Implemented.\n\t(installListeners): Add propertyChangeListener to menuItem.\n\t(uninstallListeners): Remove propertyChangeListener from menuItem.\n\t(update): Implemented.\n\t* javax/swing/plaf/basic/BasicMenuUI.MouseInputHandler:\n\t(mouseEntered): Take insets of popup menu into account when\n\tcalculating position of popup menu.\n\n2004-05-18  Olga Rodimina  <rodimina@redhat.com>\n\n\t* Makefile.am: Added new file.\n\t* Makefile.in: Regenerate.\n\t* javax/swing/JMenuBar.java:\n\tStarted implementation.\n\t* javax/swing/JPopupMenu.java:\n\t(setVisible): Fixed location of lightweight/mediumweight\n\tpopup menu.\n\t(show): Fixed location of PopupMenu.\n\t* javax/swing/plaf/basic/BasicMenuBarUI.java:\n\tNew file. UI Delegate for JMenuBar.\n\t* javax/swing/plaf/basic/BasicMenuUI.MouseInputHandler:\n\t(mouseEntered): Corrected position of the submenu.\n\n2004-05-18  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuPeer.c: Remove calls\n\tto _gtk_accel_group_attach.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPopupMenuPeer.c:\n\tLikewise.\n\n\t* gnu/java/awt/peer/gtk/GtkButtonPeer.java: Give gtkSetFont\n\tpackage access.  Don't override setFont.\n\t* gnu/java/awt/peer/gtk/GtkCheckboxPeer.java: Likewise.\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java: Give\n\tgtkWidgetRequestFocus package access.\n\t* gnu/java/awt/peer/gtk/GtkLabelPeer.java: Don't override\n\tsetFont.\n\t* gnu/java/awt/peer/gtk/GtkListPeer.java: Override gtkSetFont.\n\tGive gtkWidgetRequestFocus package access.\n\t* gnu/java/awt/peer/gtk/GtkTextAreaPeer.java: Give\n\tgtkWidgetRequestFocus package access.  Don't override setFont.\n\t* gnu/java/awt/peer/gtk/GtkTextFieldPeer.java: Don't override\n\tsetFont.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkButtonPeer.c\n\t(gtkSetLabel): Move call to gtk_bin_get_child into GDK critical\n\tregion.\n\t(gtkSetFont): Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.c (gtkSetFont):\n\tImplement.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextAreaPeer.c\n\t(gtkSetFont): Whitespace fix.\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(gtkWidgetSetUsize): Remove method.\n\n2004-05-18  David Jee  <djee@redhat.com>\n\n\t* java/awt/image/MemoryImageSource.java\n\t(newPixels(int,int,int,int,boolean)): Set only the specified\n\trectangle of pixels.\n\t(newPixels(byte[],ColorModel,int,int)): Implement.\n\t(newPixels(int[],ColorModel,int,int)): Implement.\n\n2004-05-18  Olga Rodimina  <rodimina@redhat.com>\n\n\t* Makefile.am: Added new file.\n\t* Makefile.in: Regenerate.\n\t* javax/swing/JMenu.java: Started\n\timplementation.\n\t* javax/swing/JPopupMenu.java:\n\t(insert): If specified index is -1, then\n\tadd component at the end.\n\t(isPopupTrigger): Reimplemented.\n\t(JPopupMenu.LightWeightPopup): setBounds\n\tof the lightWeightPopup before adding it\n\tto the layeredPane.\n\t(javax/swing/plaf/basic/BasicIconFactory.java):\n\t(getMenuArrowIcon): Implemented.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n\t(getPreferredSize): Add size of the arrow icon\n\tif this menu item is instance of JMenu.\n\t(paintMenuItem): Paint arrow icon if this\n\tmenu item is a submenu.\n\t* javax/swing/plaf/basic/BasicMenuUI.java:\n\tNew File. UI Delegate for JMenu.\n\n2004-05-17  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java (postKeyEvent):\n\tPost KEY_TYPED events.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c\n\t(generates_key_typed_event): Remove function.\n\n2004-05-17  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/JRootPane.java\n\t(JRootPane.RootLayout): Reimplemented to\n\tset bounds of contentPane and menuBar.\n\t(setJMenuBar): Add menu bar to the layered pane.\n\t(createLayeredPane): Set layout of layeredPane\n\tto null.\n\t* javax/swing/JLayeredPane.java:\n\t(addImpl): Calculate index of the component in the\n\tlayeredPane according to the specified position within\n\tthe layer.\n\n2004-05-17  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkImagePainter.java\n\t(setPixels): Change color model to the default model after\n\tconverting pixels.\n\t* java/awt/image/MemoryImageSource.java\n\t(newPixels): Set only the specified rectangle of pixels.\n\n2004-05-13  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* libgcj.spec.in (lib): Add -l-java-awt -l-java-applet\n\t-l-java-beans -l-javax-accessibility -l-javax-swing.\n\n\t* java/awt/AWTEvent.java (toString): Print source's name rather\n\tthan the source itself.\n\n2004-05-12  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkToolkit.java (loadSystemColors): Make\n\tnative.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkToolkit.c\n\t(gdk_color_to_java_color): New function.\n\t* jni/gtk-peer/gtkpeer.h: Add SystemColor defines.\n\n2004-05-12  David Jee  <djee@redhat.com>\n\n\t* java/awt/image/RGBImageFilter.java:\n\tInitialize origmodel as null.\n\t(makeColor): Fix pixel component order.\n\t(filterRGBPixels): Fix pixel iteration.\n\t(setPixels): Add extra checks for index color model. Convert pixels\n\tto default color model if necessary.\n\t(convertColorModelToDefault): New override method for byte pixels.\n\t(convertColorModelToDefault): For int pixels, fix pixel iteration.\n\t(makeColorbyDefaultCM): New override method for byte pixels.\n\t(makeColorbyDefaultCM): For int pixel, add color model as argument.\n\t(makeColor): Fix pixel component order.\n\n2004-05-11  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/Box.java:\n\tComment out more parts of Box.Filler.\n\n2004-05-11  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/Box.java:\n\tRemove reference to AccessibleAWTComponent so\n\tit compiles again.\n\n2004-05-10  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkListPeer.java,\n\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.c: Update\n\timplementation of list peer to use GtkTreeView instead of\n\tdeprecated GtkCList.\n\n2004-05-07  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java\n\t(gtkWidgetDispatchKeyEvent): Remove keyChar parameter.\n\t(handleEvent): Remove keyChar argument to\n\tgtkWidgetDispatchKeyEvent calls.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c: Fix\n\tcompiler warnings.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c: Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuPeer.c: Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextComponentPeer.c:\n\tLikewise.\n\n2004-05-06  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java\n\t(gtkWidgetRequestFocus): Mark protected.\n\t(GtkComponentPeer): Only set the peer's bounds if its component\n\tis valid.\n\t* java/awt/Component.java (static): Set the default keyboard\n\tfocus manager.\n\t(requestFocus(), requestFocus(boolean), requestFocusInWindow(),\n\trequestFocusInWindow(temporary)): Don't request focus if the\n\tcomponent is not showing.  Get tree lock before traversing\n\tcomponent hierarchy.\n\t* java/awt/DefaultKeyboardFocusManager.java (dispatchEvent):\n\tOnly set the global focus owner if it is not a Window.\n\t(processKeyEvent): Consume keystrokes associated with the focus\n\ttraversal keystroke.\n\t(focusPreviousComponent, focusNextComponent, upFocusCycle,\n\tdownFocusCycle): Call requestFocusInWindow instead of\n\trequestFocus.\n\t* java/awt/EventDispatchThread.java (run): Move setting of\n\tdefault keyboard focus manager to Component.java.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(awt_keycode_to_keysym): New function.\n\t(gtkWidgetDispatchKeyEvent): Finish implementation.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c\n\t(pre_event_handler): Add FIXME comment.\n\n\t* gnu/java/awt/peer/gtk/GtkTextAreaPeer.java,\n\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextAreaPeer.c\n\t(gtkWidgetRequestFocus): New method.\n\t* java/awt/TextArea.java (TextArea): Set focus traversal keys to\n\tdisable Tab and Shift-Tab keystrokes.\n\t(addNotify, appendText, insertText, replaceText): Simplify peer\n\tretrieval code.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextComponentPeer.c\n\t(connectSignals): Remove connections to \"commit\" signals.\n\tRemove C++-style comments.\n\n\t* gnu/java/awt/peer/gtk/GtkButtonPeer.java,\n\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkButtonPeer.c\n\t(handleEvent): Activate GTK button when the space bar key is\n\tpressed.\n\t(gtkActivate): New method.\n\n2004-05-06  David Jee  <djee@redhat.com>\n\n\t* java/awt/image/CropImageFilter.java\n\t(setPixels): Implement for byte array pixels.\n\t* java/awt/image/ReplicateScaleFilter.java\n\t(setPixels): Implement for byte array pixels.\n\t(replicatePixels): Overload for byte array pixels.\n\n2004-05-06  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/Box.java:\n\t(getAccessibleContext): Return an instance of the\n\tcorrect class.\n\n2004-05-05  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics.java\n\t(drawImage): When component is null, use SystemColor.window as\n\tthe default bgcolor.\n\t* gnu/java/awt/peer/gtk/GtkImage.java\n\t(setPixels): We can avoid iterating through the pixel rows only\n\twhen height is 1.\n\t* java/awt/Image.java\n\t(getScaledInstance): Partially implement.\n\t* java/awt/image/CropImageFilter.java\n\t(setProperties): Fix \"filter\" property.\n\t(setPixels): Implement.\n\t* java/awt/image/ReplicateScaleFilter.java\n\t(setDimensions): Use scaled dimensions.\n\t(setPixels): Implement.\n\t(replicatePixels): New method.\n\n2004-05-05  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkImagePainter.java\n\t(convertPixels): If either pixels or model is null, return null.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkImagePainter.c\n\t(Java_gnu_java_awt_peer_gtk_GtkImagePainter_drawPixels): If jpixels\n\tis null, do nothing and return.\n\n2004-05-03  Kim Ho  <kho@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkDialogPeer.java:\n\t(getGraphics): Like GtkFramePeer, the Graphics\n\tobject needs to be translate to account for\n\twindow decorations.\n\t(postMouseEvent): New method. Account for\n\ttranslation.\n\t(postExposeEvent): ditto.\n\t* javax/swing/Box.java: Stubbed.\n\t* javax/swing/JDialog.java: Ran through jalopy\n\tto fix indentation.\n\t(JDialog): Call SwingUtilities' getOwnerFrame\n\tfor null owners.\n\t(setLayout): Check isRootPaneCheckingEnabled\n\t* javax/swing/JOptionPane.java: Re-implemented.\n\t* javax/swing/SwingUtilities.java:\n\t(getOwnerFrame): Static method to grab a default\n\towner frame for Dialogs that don't specify owners.\n\t* javax/swing/event/SwingPropertyChangeSupport.java:\n\t(firePropertyChange): Fix early exit condition.\n\t* javax/swing/plaf/basic/BasicLabelUI.java:\n\t(paint): Avoid painting text if it is null\n\tor empty.\n\t* javax/swing/plaf/basic/BasicOptionPaneUI.java:\n\tImplement.\n\n2004-05-03  Olga Rodimina  <rodimina@redhat.com>\n\n\t* Makefile.am: Added new file.\n\t* Makefile.in: Regenerate.\n\t* javax/swing/JPopupMenu.java:\n\tStarted implementation.\n\t* javax/swing/JWindow.java\n\t(JWindow): call super() if parent for window\n\tis not specified.\n\t* javax/swing/plaf/basic/BasicPopupMenuUI.java:\n\tNew File. UI Delegate for JPopupMenu.\n\n2004-04-30  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/JApplet.java: Indicated that JApplet\n\timplements RootPaneContainer and made method of this\n\tinterface public.\n\t* javax/swing/JFrame.java: Ditto.\n\t* javax/swing/JWindow.java: Ditto.\n\n2004-04-29  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n\t(nativeSetBounds): Call gdk_window_move in addition to\n\tgtk_window_move.\n\n\t* java/applet/Applet.java (preferredSize): Call parent's\n\tpreferredSize if the applet stub is null.\n\t(minimumSize): Likewise for parent's minimumSize.\n\n2004-04-27  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/JMenuItem.java\n\t(createActionPropertyChangeListener): Implemented.\n\t(processMouseEvent): Ditto.\n\t(fireMenuDragMouseEntered): Ditto.\n\t(fireMenuDragMouseExited): Ditto.\n\t(fireMenuDragMouseDragged): Ditto.\n\t(fireMenuDragMouseReleased): Ditto.\n\t(menuSelectionChanged): Ditto.\n\t(getSubElements): Ditto.\n\t(getComponent): Ditto.\n\t(addMenuDragMouseListener): Ditto.\n\t(removeMenuDragMouseListener):Ditto.\n\t(addMenuKeyListener): Ditto.\n\t(removeMenuKeyListener): Ditto.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java\n\t(doClick): Imlemented.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.MouseInputHandler:\n\tDon't handle mouse events here. Pass them to\n\tMenuSelectionManager.\n\n2004-04-26  Olga Rodimina  <rodimina@redhat.com>\n\tUsed correct version of jalopy configuration\n\tfile to fix style in the files below.\n\n2004-04-26  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/JCheckBoxMenuItem.java:\n\tFixed style and removed unnecessary comments.\n\t* javax/swing/JMenuItem.java: Ditto.\n\t* javax/swing/JRadioButtonMenuItem.java: Ditto.\n\t* javax/swing/plaf/basic/BasicCheckBoxMenuItemUI.java: Ditto.\n\t* javax/swing/plaf/basic/BasicMenuItemUI.java: Ditto.\n\t* javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java: Ditto.\n\n2004-04-23  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu_java_awt_peer_gtk_GtkWindowPeer.c: Change FIXME comment to\n\tC-style.\n\n\t* gnu_java_awt_peer_gtk_GtkWindowPeer.c: Add FIXME comment.\n\n\t* java/awt/ContainerOrderFocusTraversalPolicy.java\n\t(getComponentAfter): Start from current component and work up\n\tthe component hierarchy until an acceptable component is found.\n\tSynchronize on tree lock.\n\t(getComponentBefore): Likewise.\n\n2004-04-22  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java: Remove\n\tfocus-related debugging messages.\n\t* java/awt/DefaultKeyboardFocusManager.java: Likewise.\n\t* java/awt/EventDispatchThread.java: Likewise.\n\t* java/awt/KeyboardFocusManager.java: Likewise.\n\t* java/awt/Window.java: Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c: Likewise.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c: Likewise.\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c: Change\n\tnew C++-style comments to C-style comments.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c: Likewise.\n\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java,\n\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(handleEvent): Dispatch key press and key release events to\n\tbacking widget.\n\t(requestFocus): Post a FOCUS_GAINED event to the event queue.\n\t(gtkWidgetRequestFocus): New method.\n\t(gtkWidgetDispatchKeyEvent): Likewise.\n\t* java/awt/Component.java (requestFocus, requestFocus(boolean),\n\trequestFocusInWindow, requestFocusInWindow(boolean),\n\tgetFocusCycleRootAncestor, nextFocus, transferFocus,\n\ttransferFocusBackward, transferFocusUpCycle, hasFocus,\n\tisFocusOwner): Implement and document focus-handling methods.\n\t(setFocusTraversalKeys): Inherit focus traversal keys when\n\tkeystrokes argument is null.  Fix focus-handling documentation\n\tthroughout class.\n\t* java/awt/Container.java (setFocusTraversalKeys,\n\tgetFocusTraversalKeys, areFocusTraversalKeysSet,\n\tisFocusCycleRoot, setFocusTraversalPolicy,\n\tgetFocusTraversalPolicy, isFocusTraversalPolicySet,\n\tsetFocusCycleRoot, isFocusCycleRoot, transferFocusDownCycle):\n\tImplement and document focus-handling methods.\n\t(transferFocusBackward): Remove method.\n\t(readObject, writeObject): Implement and document serialization\n\tmethods.\n\t* java/awt/ContainerOrderFocusTraversalPolicy.java: Implement\n\tand document.\n\t* java/awt/DefaultFocusTraversalPolicy.java: Implement and\n\tdocument.\n\t* java/awt/DefaultKeyboardFocusManager.java: Implement and\n\tpartially document.\n\t* java/awt/EventDispatchThread.java (run): Set default keyboard\n\tfocus manager.  Attempt to dispatch each event to the keyboard\n\tfocus manager before normal dispatch.\n\t* java/awt/KeyboardFocusManager.java: Implement and partially\n\tdocument.\n\t* java/awt/Window.java (Window): Set focusCycleRoot to true.\n\t(show): Focus initial component when window is shown for the\n\tfirst time.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c\n\t(pre_event_handler): Replace complex key press and key release\n\tlogic with simple callbacks into GtkComponentPeer.\n\t* jni/gtk-peer/gtkpeer.h: Fix FOCUS_GAINED/FOCUS_LOST reversal.\n\n2004-04-21  Olga Rodimina  <rodimina@redhat.com>\n\n\t* javax/swing/MenuSelectionManager.java\n\t(componentForPoint): Added new method.\n\t(defaultManager): New Method. Implemented.\n\t(getSelectedPath): Ditto.\n\t(isComponentPartOfCurrentMenu): Ditto.\n\t(processKeyEvent): Added new method.\n\t(processMouseEvent): New Method. Implemented.\n\t(setSelectedPath): Ditto.\n\t(getPath): Ditto.\n\n2004-04-19  Kim Ho  <kho@redhat.com>\n\n\t* java/awt/Container.java:\n\t(remove): Set the component's parent to null.\n\t(getComponentAt): Implement.\n\t* javax/swing/JComponent.java:\n\t(JComponent): Initialize defaultLocale\n\t(getDefaultLocale): Implement.\n\t(setDefaultLocale): ditto.\n\t* javax/swing/JSlider.java:\n\t(JSlider): Fix calculation of value.\n\t* javax/swing/JSplitPane.java: Implement.\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n\tChange SplitPane's default divider size.\n\t* javax/swing/plaf/basic/BasicScrollBarUI.java:\n\t(paint): Remove unused code.\n\t* javax/swing/plaf/basic/BasicSplitPaneDivider.java:\n\tAdded comments and ran through jalopy.\n\t(setBasicSplitPaneUI): Get reference to hidden divider\n\tand set up one touch buttons if necessary.\n\t(setBorder): Fire propertyChangeEvent only if\n\tborders are different.\n\t(getPreferredSize): Defer to layout manager.\n\t(propertyChange): Implement.\n\t(oneTouchExpandableChanged): ditto.\n\t(createLeftOneTouchButton): Use BasicArrowButton.\n\t(createRightOneTouchButton): ditto.\n\t(moveDividerTo): New method. Moves the divider\n\tto a set location based on the last divider location.\n\t(BasicSplitPaneDivider::MouseHandler): Implement.\n\t(BasicSplitPaneDivider::OneTouchButton): Removed.\n\t(BasicSplitPaneDivider::DragController): Implement.\n\t(BasicSplitPaneDivider::VerticalDragController):\n\tditto.\n\t(BasicSplitPaneDivider::DividerLayout): ditto.\n\t* javax/swing/plaf/basic/BasicSplitPaneUI.java: Reimplement.\n\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java:\n\t(calculateLayoutInfo): Don't show component if it's\n\tnull.\n\t(paintTab): Fix title paint logic.\n\nFrom-SVN: r82314", "tree": {"sha": "2ffcb4d3889f27364cadf6d34acb5b88d5881e8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ffcb4d3889f27364cadf6d34acb5b88d5881e8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/comments", "author": null, "committer": null, "parents": [{"sha": "e314a036a8942fe4ce5d9fd586f0a8bac90f6df3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e314a036a8942fe4ce5d9fd586f0a8bac90f6df3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e314a036a8942fe4ce5d9fd586f0a8bac90f6df3"}], "stats": {"total": 22861, "additions": 17323, "deletions": 5538}, "files": [{"sha": "092623c1f5f7886465097d5df9242feb19281fa9", "filename": "libjava/ChangeLog", "status": "modified", "additions": 556, "deletions": 0, "changes": 556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -1,3 +1,559 @@\n+2004-05-25  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/Container.java\n+\t(remove): Set component's parent to null only after we removed the\n+\tcomponent from its parent's layout manager.\n+\n+2004-05-25  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java\n+\t(GtkComponentPeer): Set bounds regardless of whether awtComponent\n+\tis valid.\n+\t* gnu/java/awt/peer/gtk/GtkListPeer.java\n+\t(getSize): Change native method declaration.\n+\t(minimumSize): Pass visible row count into getSize().\n+\t(preferredSize): Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkListPeer_getSize): Use scroll window's\n+\tnatural size. Use visible row count to determine the final height\n+\tvalue to return.\n+\n+2004-05-21  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java \n+\t(setClip): Minor correction to order of operations.\n+\n+\t* javax/swing/JScrollPane.java: Extend sketchy implementation.\n+\t* javax/swing/ScrollPaneLayout.java: Likewise.\n+\t* javax/swing/JViewPort.java: Likewise.\n+\t* javax/swing/ViewportLayout.java: Likewise.\n+\n+\t* javax/swing/JComponent.java: Rewrite.\n+\t* javax/swing/RepaintManager.java: Likewise.\n+\n+\t* javax/swing/JLayeredPane.java: Change validate() to revalidate().\n+\t* javax/swing/JList.java \n+\t(setSelectedIndices):\n+\t(getSelectedIndices):\n+\t(getSelectedValues): New functions.\n+\t(getPreferredScrollableViewportSize): Return preferred size.\n+\t(getScrollableUnitIncrement):\n+\t(getScrollableBlockIncrement): Initial implementations.\n+\t* javax/swing/JRootPane.java: Clean up slightly.\n+\t(getUI):\n+\t(setUI):\n+\t(updateUI):\n+\t(getUIClassID):\n+\t(isValidateRoot): Add overrides from JComponent.\n+\t* javax/swing/JScrollBar.java: Set default orientation to VERTICAL.\n+\t* javax/swing/UIManager.java (getDimension): Return the dimension.\n+\n+\t* javax/swing/plaf/basic/BasicButtonUI.java: Set component opaque.\n+\t* javax/swing/plaf/basic/BasicLabelUI.java: Likewise.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java: Likewise.\n+\t* javax/swing/plaf/basic/BasicProgressBarUI.java: Likewise.\n+\t* javax/swing/plaf/basic/BasicSeparatorUI.java: Likewise.\n+\t* javax/swing/plaf/basic/BasicSliderUI.java: Likewise.\n+\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java: Likewise.\n+\t* javax/swing/plaf/basic/BasicRootPaneUI.java: \n+\tLikewise, and set background.\n+\t* javax/swing/plaf/basic/BasicListUI.java: \n+\tLikewise, and improve a bit.\n+\t* javax/swing/plaf/basic/BasicScrollBarUI.java: \n+\tLikewise, and adjust calculations.\n+\t* javax/swing/plaf/basic/BasicViewportUI.java:\n+\tLikewise, and improve a bit.\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java \n+\t(Button.margin): Shrink.\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGlyphVector.c:\n+\tHack to set horizontal always, workaround pango.\n+\n+\t* jni/gtk-peer/gtkcairopeer.h: Change to match pattern API.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c:\n+\tSynchronize more often, check cairo status after ops,\n+\thandle changes to cairo pattern API, check for disposal.\n+\n+2004-05-21  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n+\t(BasicMenuItemUI): Create propertyChangeListener.\n+\t(getPath):Implemented.\n+\t(installListeners): Add propertyChangeListener to menuItem.\n+\t(uninstallListeners): Remove propertyChangeListener from menuItem.\n+\t(update): Implemented.\n+\t* javax/swing/plaf/basic/BasicMenuUI.MouseInputHandler:\n+\t(mouseEntered): Take insets of popup menu into account when\n+\tcalculating position of popup menu.\t\n+ \t\n+2004-05-18  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* Makefile.am: Added new file. \n+\t* Makefile.in: Regenerate.\n+\t* javax/swing/JMenuBar.java:\n+\tStarted implementation.\n+\t* javax/swing/JPopupMenu.java:\n+\t(setVisible): Fixed location of lightweight/mediumweight\n+\tpopup menu.\n+\t(show): Fixed location of PopupMenu.\n+\t* javax/swing/plaf/basic/BasicMenuBarUI.java:\n+\tNew file. UI Delegate for JMenuBar.\n+\t* javax/swing/plaf/basic/BasicMenuUI.MouseInputHandler:\n+\t(mouseEntered): Corrected position of the submenu.\n+\n+2004-05-18  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuPeer.c: Remove calls\n+\tto _gtk_accel_group_attach.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPopupMenuPeer.c:\n+\tLikewise.\n+\n+\t* gnu/java/awt/peer/gtk/GtkButtonPeer.java: Give gtkSetFont\n+\tpackage access.  Don't override setFont.\n+\t* gnu/java/awt/peer/gtk/GtkCheckboxPeer.java: Likewise.\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java: Give\n+\tgtkWidgetRequestFocus package access.\n+\t* gnu/java/awt/peer/gtk/GtkLabelPeer.java: Don't override\n+\tsetFont.\n+\t* gnu/java/awt/peer/gtk/GtkListPeer.java: Override gtkSetFont.\n+\tGive gtkWidgetRequestFocus package access.\n+\t* gnu/java/awt/peer/gtk/GtkTextAreaPeer.java: Give\n+\tgtkWidgetRequestFocus package access.  Don't override setFont.\n+\t* gnu/java/awt/peer/gtk/GtkTextFieldPeer.java: Don't override\n+\tsetFont.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkButtonPeer.c\n+\t(gtkSetLabel): Move call to gtk_bin_get_child into GDK critical\n+\tregion.\n+\t(gtkSetFont): Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.c (gtkSetFont):\n+\tImplement.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextAreaPeer.c\n+\t(gtkSetFont): Whitespace fix.\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(gtkWidgetSetUsize): Remove method.\n+\n+2004-05-18  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/image/MemoryImageSource.java\n+\t(newPixels(int,int,int,int,boolean)): Set only the specified\n+\trectangle of pixels.\n+\t(newPixels(byte[],ColorModel,int,int)): Implement.\n+\t(newPixels(int[],ColorModel,int,int)): Implement.\n+\n+2004-05-18  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* Makefile.am: Added new file.\n+\t* Makefile.in: Regenerate.\n+\t* javax/swing/JMenu.java: Started \n+\timplementation.\n+\t* javax/swing/JPopupMenu.java:\n+\t(insert): If specified index is -1, then\n+\tadd component at the end.\n+\t(isPopupTrigger): Reimplemented.\n+\t(JPopupMenu.LightWeightPopup): setBounds\n+\tof the lightWeightPopup before adding it \n+\tto the layeredPane.\n+\t(javax/swing/plaf/basic/BasicIconFactory.java):\n+\t(getMenuArrowIcon): Implemented.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java:\n+\t(getPreferredSize): Add size of the arrow icon \n+\tif this menu item is instance of JMenu.\n+\t(paintMenuItem): Paint arrow icon if this \n+\tmenu item is a submenu.\n+\t* javax/swing/plaf/basic/BasicMenuUI.java:\n+\tNew File. UI Delegate for JMenu.\n+\n+2004-05-17  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java (postKeyEvent):\n+\tPost KEY_TYPED events.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c\n+\t(generates_key_typed_event): Remove function.\n+\n+2004-05-17  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/JRootPane.java\n+\t(JRootPane.RootLayout): Reimplemented to \n+\tset bounds of contentPane and menuBar.\n+\t(setJMenuBar): Add menu bar to the layered pane.\n+\t(createLayeredPane): Set layout of layeredPane\n+\tto null.\n+\t* javax/swing/JLayeredPane.java:\n+\t(addImpl): Calculate index of the component in the\n+\tlayeredPane according to the specified position within \n+\tthe layer.\t\n+\n+2004-05-17  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkImagePainter.java\n+\t(setPixels): Change color model to the default model after\n+\tconverting pixels.\n+\t* java/awt/image/MemoryImageSource.java\n+\t(newPixels): Set only the specified rectangle of pixels.\n+\n+2004-05-13  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* libgcj.spec.in (lib): Add -l-java-awt -l-java-applet\n+\t-l-java-beans -l-javax-accessibility -l-javax-swing.\n+\n+\t* java/awt/AWTEvent.java (toString): Print source's name rather\n+\tthan the source itself.\n+\n+2004-05-12  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkToolkit.java (loadSystemColors): Make\n+\tnative.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkToolkit.c\n+\t(gdk_color_to_java_color): New function.\n+\t* jni/gtk-peer/gtkpeer.h: Add SystemColor defines.\n+\n+2004-05-12  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/image/RGBImageFilter.java:\n+\tInitialize origmodel as null.\n+\t(makeColor): Fix pixel component order.\n+\t(filterRGBPixels): Fix pixel iteration.\n+\t(setPixels): Add extra checks for index color model. Convert pixels\n+\tto default color model if necessary.\n+\t(convertColorModelToDefault): New override method for byte pixels.\n+\t(convertColorModelToDefault): For int pixels, fix pixel iteration.\n+\t(makeColorbyDefaultCM): New override method for byte pixels.\n+\t(makeColorbyDefaultCM): For int pixel, add color model as argument.\n+\t(makeColor): Fix pixel component order.\n+\n+2004-05-11  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/Box.java:\n+\tComment out more parts of Box.Filler.\n+\n+2004-05-11  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/Box.java:\n+\tRemove reference to AccessibleAWTComponent so\n+\tit compiles again.\n+\n+2004-05-10  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkListPeer.java,\n+\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.c: Update\n+\timplementation of list peer to use GtkTreeView instead of\n+\tdeprecated GtkCList.\n+\n+2004-05-07  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java\n+\t(gtkWidgetDispatchKeyEvent): Remove keyChar parameter.\n+\t(handleEvent): Remove keyChar argument to\n+\tgtkWidgetDispatchKeyEvent calls.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c: Fix\n+\tcompiler warnings.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c: Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuPeer.c: Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextComponentPeer.c:\n+\tLikewise.\n+\n+2004-05-06  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java\n+\t(gtkWidgetRequestFocus): Mark protected.\n+\t(GtkComponentPeer): Only set the peer's bounds if its component\n+\tis valid.\n+\t* java/awt/Component.java (static): Set the default keyboard\n+\tfocus manager.\n+\t(requestFocus(), requestFocus(boolean), requestFocusInWindow(),\n+\trequestFocusInWindow(temporary)): Don't request focus if the\n+\tcomponent is not showing.  Get tree lock before traversing\n+\tcomponent hierarchy.\n+\t* java/awt/DefaultKeyboardFocusManager.java (dispatchEvent):\n+\tOnly set the global focus owner if it is not a Window.\n+\t(processKeyEvent): Consume keystrokes associated with the focus\n+\ttraversal keystroke.\n+\t(focusPreviousComponent, focusNextComponent, upFocusCycle,\n+\tdownFocusCycle): Call requestFocusInWindow instead of\n+\trequestFocus.\n+\t* java/awt/EventDispatchThread.java (run): Move setting of\n+\tdefault keyboard focus manager to Component.java.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(awt_keycode_to_keysym): New function.\n+\t(gtkWidgetDispatchKeyEvent): Finish implementation.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c\n+\t(pre_event_handler): Add FIXME comment.\n+\n+\t* gnu/java/awt/peer/gtk/GtkTextAreaPeer.java,\n+\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextAreaPeer.c\n+\t(gtkWidgetRequestFocus): New method.\n+\t* java/awt/TextArea.java (TextArea): Set focus traversal keys to\n+\tdisable Tab and Shift-Tab keystrokes.\n+\t(addNotify, appendText, insertText, replaceText): Simplify peer\n+\tretrieval code.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextComponentPeer.c\n+\t(connectSignals): Remove connections to \"commit\" signals.\n+\tRemove C++-style comments.\n+\n+\t* gnu/java/awt/peer/gtk/GtkButtonPeer.java,\n+\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkButtonPeer.c\n+\t(handleEvent): Activate GTK button when the space bar key is\n+\tpressed.\n+\t(gtkActivate): New method.\n+\n+2004-05-06  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/image/CropImageFilter.java\n+\t(setPixels): Implement for byte array pixels.\n+\t* java/awt/image/ReplicateScaleFilter.java\n+\t(setPixels): Implement for byte array pixels.\n+\t(replicatePixels): Overload for byte array pixels.\n+\n+2004-05-06  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/Box.java:\n+\t(getAccessibleContext): Return an instance of the \n+\tcorrect class.\n+\n+2004-05-05  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics.java\n+\t(drawImage): When component is null, use SystemColor.window as\n+\tthe default bgcolor.\n+\t* gnu/java/awt/peer/gtk/GtkImage.java\n+\t(setPixels): We can avoid iterating through the pixel rows only\n+\twhen height is 1.\n+\t* java/awt/Image.java\n+\t(getScaledInstance): Partially implement.\n+\t* java/awt/image/CropImageFilter.java\n+\t(setProperties): Fix \"filter\" property.\n+\t(setPixels): Implement.\n+\t* java/awt/image/ReplicateScaleFilter.java\n+\t(setDimensions): Use scaled dimensions.\n+\t(setPixels): Implement.\n+\t(replicatePixels): New method.\n+\n+2004-05-05  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkImagePainter.java\n+\t(convertPixels): If either pixels or model is null, return null.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkImagePainter.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkImagePainter_drawPixels): If jpixels\n+\tis null, do nothing and return.\n+\n+2004-05-03  Kim Ho  <kho@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkDialogPeer.java:\n+\t(getGraphics): Like GtkFramePeer, the Graphics\n+\tobject needs to be translate to account for\n+\twindow decorations.\n+\t(postMouseEvent): New method. Account for\n+\ttranslation.\n+\t(postExposeEvent): ditto.\n+\t* javax/swing/Box.java: Stubbed.\n+\t* javax/swing/JDialog.java: Ran through jalopy\n+\tto fix indentation.\n+\t(JDialog): Call SwingUtilities' getOwnerFrame\n+\tfor null owners.\n+\t(setLayout): Check isRootPaneCheckingEnabled\n+\t* javax/swing/JOptionPane.java: Re-implemented.\n+\t* javax/swing/SwingUtilities.java:\n+\t(getOwnerFrame): Static method to grab a default\n+\towner frame for Dialogs that don't specify owners.\n+\t* javax/swing/event/SwingPropertyChangeSupport.java:\n+\t(firePropertyChange): Fix early exit condition.\n+\t* javax/swing/plaf/basic/BasicLabelUI.java:\n+\t(paint): Avoid painting text if it is null \n+\tor empty.\n+\t* javax/swing/plaf/basic/BasicOptionPaneUI.java:\n+\tImplement.\n+\n+2004-05-03  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* Makefile.am: Added new file.\n+\t* Makefile.in: Regenerate.\n+\t* javax/swing/JPopupMenu.java:\n+\tStarted implementation.\n+\t* javax/swing/JWindow.java\n+\t(JWindow): call super() if parent for window\n+\tis not specified.\n+\t* javax/swing/plaf/basic/BasicPopupMenuUI.java:\n+\tNew File. UI Delegate for JPopupMenu.\n+\n+2004-04-30  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/JApplet.java: Indicated that JApplet\n+\timplements RootPaneContainer and made method of this\n+\tinterface public. \n+\t* javax/swing/JFrame.java: Ditto.\n+\t* javax/swing/JWindow.java: Ditto.\n+\t\n+2004-04-29  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n+\t(nativeSetBounds): Call gdk_window_move in addition to\n+\tgtk_window_move.\n+\n+\t* java/applet/Applet.java (preferredSize): Call parent's\n+\tpreferredSize if the applet stub is null.\n+\t(minimumSize): Likewise for parent's minimumSize.\n+\n+2004-04-27  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/JMenuItem.java\n+\t(createActionPropertyChangeListener): Implemented.\n+\t(processMouseEvent): Ditto.\n+\t(fireMenuDragMouseEntered): Ditto.\n+\t(fireMenuDragMouseExited): Ditto.\n+\t(fireMenuDragMouseDragged): Ditto.\n+\t(fireMenuDragMouseReleased): Ditto.\n+\t(menuSelectionChanged): Ditto.\n+\t(getSubElements): Ditto.\n+\t(getComponent): Ditto.\n+\t(addMenuDragMouseListener): Ditto.\n+\t(removeMenuDragMouseListener):Ditto.\n+\t(addMenuKeyListener): Ditto.\n+\t(removeMenuKeyListener): Ditto.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java\n+\t(doClick): Imlemented.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.MouseInputHandler:\n+\tDon't handle mouse events here. Pass them to \n+\tMenuSelectionManager.\n+\t\n+2004-04-26  Olga Rodimina  <rodimina@redhat.com>\n+\tUsed correct version of jalopy configuration\n+\tfile to fix style in the files below.\n+\n+2004-04-26  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/JCheckBoxMenuItem.java: \n+\tFixed style and removed unnecessary comments.\n+\t* javax/swing/JMenuItem.java: Ditto.\n+\t* javax/swing/JRadioButtonMenuItem.java: Ditto.\n+\t* javax/swing/plaf/basic/BasicCheckBoxMenuItemUI.java: Ditto.\n+\t* javax/swing/plaf/basic/BasicMenuItemUI.java: Ditto.\n+\t* javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java: Ditto.\n+\n+2004-04-23  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu_java_awt_peer_gtk_GtkWindowPeer.c: Change FIXME comment to\n+\tC-style.\n+\n+\t* gnu_java_awt_peer_gtk_GtkWindowPeer.c: Add FIXME comment.\n+\n+\t* java/awt/ContainerOrderFocusTraversalPolicy.java\n+\t(getComponentAfter): Start from current component and work up\n+\tthe component hierarchy until an acceptable component is found.\n+\tSynchronize on tree lock.\n+\t(getComponentBefore): Likewise.\n+\n+2004-04-22  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java: Remove\n+\tfocus-related debugging messages.\n+\t* java/awt/DefaultKeyboardFocusManager.java: Likewise.\n+\t* java/awt/EventDispatchThread.java: Likewise.\n+\t* java/awt/KeyboardFocusManager.java: Likewise.\n+\t* java/awt/Window.java: Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c: Likewise.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c: Likewise.\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c: Change\n+\tnew C++-style comments to C-style comments.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c: Likewise.\n+\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java,\n+\tjni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(handleEvent): Dispatch key press and key release events to\n+\tbacking widget.\n+\t(requestFocus): Post a FOCUS_GAINED event to the event queue.\n+\t(gtkWidgetRequestFocus): New method.\n+\t(gtkWidgetDispatchKeyEvent): Likewise.\n+\t* java/awt/Component.java (requestFocus, requestFocus(boolean),\n+\trequestFocusInWindow, requestFocusInWindow(boolean),\n+\tgetFocusCycleRootAncestor, nextFocus, transferFocus,\n+\ttransferFocusBackward, transferFocusUpCycle, hasFocus,\n+\tisFocusOwner): Implement and document focus-handling methods.\n+\t(setFocusTraversalKeys): Inherit focus traversal keys when\n+\tkeystrokes argument is null.  Fix focus-handling documentation\n+\tthroughout class.\n+\t* java/awt/Container.java (setFocusTraversalKeys,\n+\tgetFocusTraversalKeys, areFocusTraversalKeysSet,\n+\tisFocusCycleRoot, setFocusTraversalPolicy,\n+\tgetFocusTraversalPolicy, isFocusTraversalPolicySet,\n+\tsetFocusCycleRoot, isFocusCycleRoot, transferFocusDownCycle):\n+\tImplement and document focus-handling methods.\n+\t(transferFocusBackward): Remove method.\n+\t(readObject, writeObject): Implement and document serialization\n+\tmethods.\n+\t* java/awt/ContainerOrderFocusTraversalPolicy.java: Implement\n+\tand document.\n+\t* java/awt/DefaultFocusTraversalPolicy.java: Implement and\n+\tdocument.\n+\t* java/awt/DefaultKeyboardFocusManager.java: Implement and\n+\tpartially document.\n+\t* java/awt/EventDispatchThread.java (run): Set default keyboard\n+\tfocus manager.  Attempt to dispatch each event to the keyboard\n+\tfocus manager before normal dispatch.\n+\t* java/awt/KeyboardFocusManager.java: Implement and partially\n+\tdocument.\n+\t* java/awt/Window.java (Window): Set focusCycleRoot to true.\n+\t(show): Focus initial component when window is shown for the\n+\tfirst time.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c\n+\t(pre_event_handler): Replace complex key press and key release\n+\tlogic with simple callbacks into GtkComponentPeer.\n+\t* jni/gtk-peer/gtkpeer.h: Fix FOCUS_GAINED/FOCUS_LOST reversal.\n+\n+2004-04-21  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* javax/swing/MenuSelectionManager.java\n+\t(componentForPoint): Added new method. \n+\t(defaultManager): New Method. Implemented.\n+\t(getSelectedPath): Ditto.\n+\t(isComponentPartOfCurrentMenu): Ditto.\n+\t(processKeyEvent): Added new method.\n+\t(processMouseEvent): New Method. Implemented.\n+\t(setSelectedPath): Ditto.\n+\t(getPath): Ditto.\n+\n+2004-04-19  Kim Ho  <kho@redhat.com>\n+\n+\t* java/awt/Container.java: \n+\t(remove): Set the component's parent to null.\n+\t(getComponentAt): Implement.\n+\t* javax/swing/JComponent.java:\n+\t(JComponent): Initialize defaultLocale\n+\t(getDefaultLocale): Implement.\n+\t(setDefaultLocale): ditto.\n+\t* javax/swing/JSlider.java:\n+\t(JSlider): Fix calculation of value.\n+\t* javax/swing/JSplitPane.java: Implement.\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n+\tChange SplitPane's default divider size.\n+\t* javax/swing/plaf/basic/BasicScrollBarUI.java:\n+\t(paint): Remove unused code.\n+\t* javax/swing/plaf/basic/BasicSplitPaneDivider.java:\n+\tAdded comments and ran through jalopy.\n+\t(setBasicSplitPaneUI): Get reference to hidden divider\n+\tand set up one touch buttons if necessary.\n+\t(setBorder): Fire propertyChangeEvent only if \n+\tborders are different.\n+\t(getPreferredSize): Defer to layout manager.\n+\t(propertyChange): Implement.\n+\t(oneTouchExpandableChanged): ditto.\n+\t(createLeftOneTouchButton): Use BasicArrowButton.\n+\t(createRightOneTouchButton): ditto.\n+\t(moveDividerTo): New method. Moves the divider\n+\tto a set location based on the last divider location.\n+\t(BasicSplitPaneDivider::MouseHandler): Implement.\n+\t(BasicSplitPaneDivider::OneTouchButton): Removed.\n+\t(BasicSplitPaneDivider::DragController): Implement.\n+\t(BasicSplitPaneDivider::VerticalDragController):\n+\tditto.\n+\t(BasicSplitPaneDivider::DividerLayout): ditto.\n+\t* javax/swing/plaf/basic/BasicSplitPaneUI.java: Reimplement.\n+\t* javax/swing/plaf/basic/BasicTabbedPaneUI.java:\n+\t(calculateLayoutInfo): Don't show component if it's\n+\tnull.\n+\t(paintTab): Fix title paint logic.\n+\n 2004-05-26  Jerry Quinn  <jlquinn@optonline.net>\n \n \tPR libgcj/8321"}, {"sha": "e8fac90557d693c45c20d48b86201c707fdd95f0", "filename": "libjava/Makefile.am", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -1325,9 +1325,12 @@ javax/swing/plaf/basic/BasicCheckBoxUI.java \\\n javax/swing/plaf/basic/BasicGraphicsUtils.java \\\n javax/swing/plaf/basic/BasicLabelUI.java \\\n javax/swing/plaf/basic/BasicListUI.java \\\n+javax/swing/plaf/basic/BasicMenuUI.java \\\n+javax/swing/plaf/basic/BasicMenuBarUI.java \\\n javax/swing/plaf/basic/BasicMenuItemUI.java \\\n javax/swing/plaf/basic/BasicOptionPaneUI.java \\\n javax/swing/plaf/basic/BasicPanelUI.java \\\n+javax/swing/plaf/basic/BasicPopupMenuUI.java \\\n javax/swing/plaf/basic/BasicProgressBarUI.java \\\n javax/swing/plaf/basic/BasicRootPaneUI.java \\\n javax/swing/plaf/basic/BasicRadioButtonUI.java \\"}, {"sha": "a68a718616c4bf30c2dbaf9c76f3d1f9c5749bfa", "filename": "libjava/Makefile.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -1004,9 +1004,12 @@ javax/swing/plaf/basic/BasicCheckBoxUI.java \\\n javax/swing/plaf/basic/BasicGraphicsUtils.java \\\n javax/swing/plaf/basic/BasicLabelUI.java \\\n javax/swing/plaf/basic/BasicListUI.java \\\n+javax/swing/plaf/basic/BasicMenuUI.java \\\n+javax/swing/plaf/basic/BasicMenuBarUI.java \\\n javax/swing/plaf/basic/BasicMenuItemUI.java \\\n javax/swing/plaf/basic/BasicOptionPaneUI.java \\\n javax/swing/plaf/basic/BasicPanelUI.java \\\n+javax/swing/plaf/basic/BasicPopupMenuUI.java \\\n javax/swing/plaf/basic/BasicProgressBarUI.java \\\n javax/swing/plaf/basic/BasicRootPaneUI.java \\\n javax/swing/plaf/basic/BasicRadioButtonUI.java \\\n@@ -4667,9 +4670,12 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/swing/plaf/basic/BasicLabelUI.P \\\n .deps/javax/swing/plaf/basic/BasicListUI.P \\\n .deps/javax/swing/plaf/basic/BasicLookAndFeel.P \\\n+.deps/javax/swing/plaf/basic/BasicMenuBarUI.P \\\n .deps/javax/swing/plaf/basic/BasicMenuItemUI.P \\\n+.deps/javax/swing/plaf/basic/BasicMenuUI.P \\\n .deps/javax/swing/plaf/basic/BasicOptionPaneUI.P \\\n .deps/javax/swing/plaf/basic/BasicPanelUI.P \\\n+.deps/javax/swing/plaf/basic/BasicPopupMenuUI.P \\\n .deps/javax/swing/plaf/basic/BasicProgressBarUI.P \\\n .deps/javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.P \\\n .deps/javax/swing/plaf/basic/BasicRadioButtonUI.P \\"}, {"sha": "8ea6817f33e583dc805f3412abd783ad8cdba3b4", "filename": "libjava/gnu/java/awt/peer/gtk/GdkGraphics.java", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -46,6 +46,7 @@\n import java.awt.Image;\n import java.awt.Rectangle;\n import java.awt.Shape;\n+import java.awt.SystemColor;\n import java.awt.image.ImageObserver;\n import java.text.AttributedCharacterIterator;\n \n@@ -149,7 +150,10 @@ public boolean drawImage (Image img, int x, int y, ImageObserver observer)\n \treturn true;\n       }\n \n-    return drawImage (img, x, y, component.getBackground (), observer);\n+    if (component != null)\n+      return drawImage (img, x, y, component.getBackground (), observer);\n+    else\n+      return drawImage (img, x, y, SystemColor.window, observer);\n   }\n \n   public boolean drawImage (Image img, int x, int y, int width, int height, \n@@ -168,8 +172,12 @@ public boolean drawImage (Image img, int x, int y, int width, int height,\n   public boolean drawImage (Image img, int x, int y, int width, int height, \n \t\t\t    ImageObserver observer)\n   {\n-    return drawImage (img, x, y, width, height, component.getBackground (),\n-\t\t      observer);\n+    if (component != null)\n+      return drawImage (img, x, y, width, height, component.getBackground (),\n+                        observer);\n+    else\n+      return drawImage (img, x, y, width, height, SystemColor.window,\n+                        observer);\n   }\n \n   public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2, \n@@ -191,8 +199,12 @@ public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2,\n \t\t\t    int sx1, int sy1, int sx2, int sy2, \n \t\t\t    ImageObserver observer) \n   {\n-    return drawImage (img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2,\n-\t\t      component.getBackground (), observer);\n+    if (component != null)\n+      return drawImage (img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2,\n+                        component.getBackground (), observer);\n+    else\n+      return drawImage (img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2,\n+                        SystemColor.window, observer);\n   }\n \n   native public void drawLine (int x1, int y1, int x2, int y2);"}, {"sha": "3e77047f72f571845aea20f53688632246b2c389", "filename": "libjava/gnu/java/awt/peer/gtk/GdkGraphics2D.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -823,13 +823,13 @@ protected Rectangle2D getClipInDevSpace ()\n \n   public void setClip (int x, int y, int width, int height)\n   {\n-    clip = new Rectangle2D.Double ((double)x, (double)y, \n-                                   (double)width, (double)height);\n-    setClip(clip);\n+    setClip(new Rectangle2D.Double ((double)x, (double)y, \n+                                    (double)width, (double)height));\n   }\n   \n   public void setClip (Shape s)\n   {\n+    clip = s;\n     if (s != null)\n       {\n         cairoNewPath ();"}, {"sha": "cdd5f9ca90705c8201123fcc6ffaa158c965c800", "filename": "libjava/gnu/java/awt/peer/gtk/GtkButtonPeer.java", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkButtonPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkButtonPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkButtonPeer.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -54,9 +54,10 @@ public class GtkButtonPeer extends GtkComponentPeer\n   public native void connectJObject ();\n   public native void connectSignals ();\n \n-  native void gtkSetFont(String name, int style, int size);\n+  native void gtkSetFont (String name, int style, int size);\n   native void gtkSetLabel(String label);\n   native void gtkWidgetSetForeground (int red, int green, int blue);\n+  native void gtkActivate ();\n \n   public GtkButtonPeer (Button b)\n   {\n@@ -87,8 +88,11 @@ public void handleEvent (AWTEvent e)\n       {\n \tKeyEvent ke = (KeyEvent) e;\n \tif (!ke.isConsumed () && ke.getKeyCode () == KeyEvent.VK_SPACE)\n-\t  postActionEvent (((Button)awtComponent).getActionCommand (),\n-\t\t\t   ke.getModifiers ());\n+          {\n+            postActionEvent (((Button) awtComponent).getActionCommand (),\n+                             ke.getModifiers ());\n+            gtkActivate ();\n+          }\n       }\n \n     super.handleEvent (e);\n@@ -100,9 +104,4 @@ public void getArgs (Component component, GtkArgList args)\n \n     args.add (\"label\", ((Button)component).getLabel ());\n   }\n-\n-  public void setFont (Font f)\n-  {\n-    gtkSetFont(f.getName(), f.getStyle(), f.getSize());\n-  }\n }"}, {"sha": "a46579881841e7738d2c3b15c4cec176cf519034", "filename": "libjava/gnu/java/awt/peer/gtk/GtkCheckboxPeer.java", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkCheckboxPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkCheckboxPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkCheckboxPeer.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -56,7 +56,7 @@ public native void nativeCreate (GtkCheckboxGroupPeer group,\n                                    boolean state);\n   public native void nativeSetCheckboxGroup (GtkCheckboxGroupPeer group);\n   public native void connectSignals ();\n-  public native void gtkSetFont (String name, int style, int size);\n+  native void gtkSetFont (String name, int style, int size);\n   public native void gtkSetLabel (String label);\n \n   public GtkCheckboxPeer (Checkbox c)\n@@ -87,11 +87,6 @@ public void setLabel (String label)\n     gtkSetLabel (label);\n   }\n \n-  public void setFont (Font f)\n-  {\n-    gtkSetFont(f.getName(), f.getStyle(), f.getSize());\n-  }\n-\n   public void setCheckboxGroup (CheckboxGroup group)\n   {\n     GtkCheckboxGroupPeer gp"}, {"sha": "fe52ef0a2dd4c1aa657f43d38c7beb3d63264a0e", "filename": "libjava/gnu/java/awt/peer/gtk/GtkComponentPeer.java", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -54,12 +54,14 @@\n import java.awt.Image;\n import java.awt.Insets;\n import java.awt.ItemSelectable;\n+import java.awt.KeyboardFocusManager;\n import java.awt.Point;\n import java.awt.Rectangle;\n import java.awt.Toolkit;\n import java.awt.Window;\n import java.awt.event.FocusEvent;\n import java.awt.event.ItemEvent;\n+import java.awt.event.FocusEvent;\n import java.awt.event.KeyEvent;\n import java.awt.event.MouseEvent;\n import java.awt.event.PaintEvent;\n@@ -91,6 +93,9 @@ public class GtkComponentPeer extends GtkGenericPeer\n   native void gtkWidgetSetCursor (int type);\n   native void gtkWidgetSetBackground (int red, int green, int blue);\n   native void gtkWidgetSetForeground (int red, int green, int blue);\n+  native void gtkWidgetRequestFocus ();\n+  native void gtkWidgetDispatchKeyEvent (int id, long when, int mods,\n+                                         int keyCode, int keyLocation);\n   native void gtkSetFont (String name, int style, int size);\n   native void gtkWidgetQueueDrawArea(int x, int y, int width, int height);\n   native void addExposeFilter();\n@@ -138,10 +143,10 @@ protected GtkComponentPeer (Component awtComponent)\n                                                      awtComponent.getX(), \n                                                      awtComponent.getY(),\n                                                      dims[0], dims[1]);\n-      }      \n+      }\n+\n       Rectangle bounds = awtComponent.getBounds ();\n       setBounds (bounds.x, bounds.y, bounds.width, bounds.height);\n-\n     } catch (RuntimeException ex) { ; }\n   }\n \n@@ -222,6 +227,7 @@ public Toolkit getToolkit ()\n   public void handleEvent (AWTEvent event)\n   {\n     int id = event.getID();\n+    KeyEvent ke = null;\n \n     switch (id)\n       {\n@@ -251,6 +257,16 @@ public void handleEvent (AWTEvent event)\n             }\n         }\n         break;\n+      case KeyEvent.KEY_PRESSED:\n+        ke = (KeyEvent) event;\n+        gtkWidgetDispatchKeyEvent (ke.getID (), ke.getWhen (), ke.getModifiers (),\n+                                   ke.getKeyCode (), ke.getKeyLocation ());\n+        break;\n+      case KeyEvent.KEY_RELEASED:\n+        ke = (KeyEvent) event;\n+        gtkWidgetDispatchKeyEvent (ke.getID (), ke.getWhen (), ke.getModifiers (),\n+                                   ke.getKeyCode (), ke.getKeyLocation ());\n+        break;\n       }\n   }\n   \n@@ -335,7 +351,11 @@ public void repaint (long tm, int x, int y, int width, int height)\n \t\t\t\t new Rectangle (x, y, width, height)));\n   }\n \n-  native public void requestFocus ();\n+  public void requestFocus ()\n+  {\n+    gtkWidgetRequestFocus ();\n+    postFocusEvent (FocusEvent.FOCUS_GAINED, false);\n+  }\n \n   public void reshape (int x, int y, int width, int height) \n   {\n@@ -453,10 +473,28 @@ protected void postExposeEvent (int x, int y, int width, int height)\n   }\n \n   protected void postKeyEvent (int id, long when, int mods,\n-\t\t\t       int keyCode, char keyChar, int keyLocation)\n-  {\n-    q.postEvent (new KeyEvent (awtComponent, id, when, mods,\n-\t\t\t       keyCode, keyChar, keyLocation));\n+                               int keyCode, char keyChar, int keyLocation)\n+  {\n+    KeyEvent keyEvent = new KeyEvent (awtComponent, id, when, mods,\n+                                      keyCode, keyChar, keyLocation);\n+\n+    // Also post a KEY_TYPED event if keyEvent is a key press that\n+    // doesn't represent an action or modifier key.\n+    if (keyEvent.getID () == KeyEvent.KEY_PRESSED\n+        && (!keyEvent.isActionKey ()\n+            && keyCode != KeyEvent.VK_SHIFT\n+            && keyCode != KeyEvent.VK_CONTROL\n+            && keyCode != KeyEvent.VK_ALT))\n+      {\n+        synchronized (q)\n+          {\n+            q.postEvent (keyEvent);\n+            q.postEvent (new KeyEvent (awtComponent, KeyEvent.KEY_TYPED, when, mods,\n+                                        KeyEvent.VK_UNDEFINED, keyChar, keyLocation));\n+          }\n+      }\n+    else\n+      q.postEvent (keyEvent);\n   }\n \n   protected void postFocusEvent (int id, boolean temporary)"}, {"sha": "4febbef9c9a0acdf5eb932b79eee606bd68e1b74", "filename": "libjava/gnu/java/awt/peer/gtk/GtkDialogPeer.java", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkDialogPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkDialogPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkDialogPeer.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -41,7 +41,10 @@\n import java.awt.AWTEvent;\n import java.awt.Component;\n import java.awt.Dialog;\n+import java.awt.Graphics;\n import java.awt.peer.DialogPeer;\n+import java.awt.Rectangle;\n+import java.awt.event.PaintEvent;\n \n public class GtkDialogPeer extends GtkWindowPeer\n   implements DialogPeer\n@@ -50,6 +53,33 @@ public GtkDialogPeer (Dialog dialog)\n   {\n     super (dialog);\n   }\n+  \n+  public Graphics getGraphics ()\n+  {\n+    Graphics g;\n+    if (GtkToolkit.useGraphics2D ())\n+      g = new GdkGraphics2D (this);\n+    else\n+      g = new GdkGraphics (this);\n+    g.translate (-insets.left, -insets.top);\n+    return g;\n+  }  \n+  \n+  protected void postMouseEvent(int id, long when, int mods, int x, int y, \n+\t\t\t\tint clickCount, boolean popupTrigger)\n+  {\n+    super.postMouseEvent (id, when, mods, \n+\t\t\t  x + insets.left, y + insets.top, \n+\t\t\t  clickCount, popupTrigger);\n+  }\n+\n+  protected void postExposeEvent (int x, int y, int width, int height)\n+  {\n+    q.postEvent (new PaintEvent (awtComponent, PaintEvent.PAINT,\n+\t\t\t\t new Rectangle (x + insets.left, \n+\t\t\t\t\t\ty + insets.top, \n+\t\t\t\t\t\twidth, height)));\n+  }  \n \n   void create ()\n   {"}, {"sha": "57c3d45c697b4c68311eff9bba91c8f69f3b581a", "filename": "libjava/gnu/java/awt/peer/gtk/GtkImage.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImage.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -241,7 +241,7 @@ public void setObserver (ImageObserver observer)\n \treturn;\n       }\n \n-    if (scansize == width)\n+    if (scansize == width && height == 1)\n       {\n \tSystem.arraycopy (pixels, offset, \n \t\t\t  pixelCache, y * this.width + x,"}, {"sha": "0476c8cf00f3be0e9284559d68ff119401151939", "filename": "libjava/gnu/java/awt/peer/gtk/GtkImagePainter.java", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImagePainter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImagePainter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImagePainter.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -119,6 +119,11 @@ public class GtkImagePainter implements Runnable, ImageConsumer\n   static int[] \n   convertPixels (int[] pixels, ColorModel model)\n   {\n+    if (pixels == null || model == null)\n+    {\n+      return null;\n+    }\n+\n     if (model.equals (ColorModel.getRGBdefault ()))\n       return pixels;\n     \n@@ -133,6 +138,11 @@ public class GtkImagePainter implements Runnable, ImageConsumer\n   static int[]\n   convertPixels (byte[] pixels, ColorModel model)\n   {\n+    if (pixels == null || model == null)\n+    {\n+      return null;\n+    }\n+\n     int ret[] = new int[pixels.length];\n \n     for (int i = 0; i < pixels.length; i++)\n@@ -178,8 +188,8 @@ width, height, convertPixels (pixels, model), offset,\n   setPixels (int x, int y, int width, int height, ColorModel model, \n \t     byte[] pixels, int offset, int scansize)\n   {\n-    setPixels (x, y, width, height, model, convertPixels (pixels, model),\n-\t       offset, scansize);\n+    setPixels (x, y, width, height, ColorModel.getRGBdefault(),\n+\t       convertPixels (pixels, model), offset, scansize);\n   }\n \n   public void "}, {"sha": "c28b7f597cc8b7acd9c1e7da63f2196c365cca26", "filename": "libjava/gnu/java/awt/peer/gtk/GtkLabelPeer.java", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkLabelPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkLabelPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkLabelPeer.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -47,7 +47,7 @@ public class GtkLabelPeer extends GtkComponentPeer\n     implements LabelPeer\n {\n   native void create (String text, float alignment);\n-  native void gtkSetFont(String name, int style, int size);\n+  native void gtkSetFont (String name, int style, int size);\n   native void nativeSetAlignment (float alignment);\n \n   native public void setText (String text);\n@@ -63,11 +63,6 @@ public GtkLabelPeer (Label l)\n     super (l);\n   }\n \n-  public void setFont (Font f)\n-  {\n-    gtkSetFont(f.getName(), f.getStyle(), f.getSize());\n-  }\n-\n   public void setAlignment (int alignment)\n   {\n     nativeSetAlignment (getGtkAlignment (alignment));"}, {"sha": "9ca30c92fa9f4c8a7ec12dd418a9869e9bb11784", "filename": "libjava/gnu/java/awt/peer/gtk/GtkListPeer.java", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkListPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkListPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkListPeer.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -48,13 +48,22 @@\n public class GtkListPeer extends GtkComponentPeer\n   implements ListPeer\n {\n-//    native void create (ComponentPeer parent, String [] items, boolean mode);\n+  void create ()\n+  {\n+    List list = (List) awtComponent;\n+\n+    create (list.getRows ());\n+\n+    setMultipleMode (list.isMultipleMode ());\n+  }\n \n-  native void create ();\n+  native void create (int rows);\n   native void connectJObject ();\n   native void connectSignals ();\n+  native void gtkSetFont (String name, int style, int size);\n+  native void gtkWidgetRequestFocus ();\n \n-  native void getSize (int rows, int dims[]);\n+  native void getSize (int rows, int visibleRows, int dims[]);\n \n   public GtkListPeer (List list)\n   {\n@@ -100,15 +109,17 @@ public Dimension minimumSize (int rows)\n   {\n     int dims[] = new int[2];\n \n-    getSize (rows, dims);\n+    int visibleRows = ((List) awtComponent).getRows();\n+    getSize (rows, visibleRows, dims);\n     return new Dimension (dims[0], dims[1]);\n   }\n \n   public Dimension preferredSize (int rows)\n   {\n     int dims[] = new int[2];\n \n-    getSize (rows, dims);\n+    int visibleRows = ((List) awtComponent).getRows();\n+    getSize (rows, visibleRows, dims);\n     return new Dimension (dims[0], dims[1]);\n   }\n \n@@ -129,19 +140,19 @@ public void handleEvent (AWTEvent e)\n   {\n     if (e.getID () == MouseEvent.MOUSE_CLICKED && isEnabled ())\n       {\n-        /* Only generate the ActionEvent on the second click of\n-\t   a multiple click */\n+        // Only generate the ActionEvent on the second click of a\n+        // multiple click.\n \tMouseEvent me = (MouseEvent) e;\n \tif (!me.isConsumed ()\n \t    && (me.getModifiers () & MouseEvent.BUTTON1_MASK) != 0\n \t    && me.getClickCount() == 2)\n \t  {\n-            String selectedItem = ((List)awtComponent).getSelectedItem ();\n+            String selectedItem = ((List) awtComponent).getSelectedItem ();\n \n-            /* Double-click only generates an Action event\n-\t       if something is selected */\n+            // Double-click only generates an Action event if\n+            // something is selected.\n             if (selectedItem != null)\n-\t      postActionEvent (((List)awtComponent).getSelectedItem (), \n+\t      postActionEvent (((List) awtComponent).getSelectedItem (), \n \t\t\t       me.getModifiers ());\n \t  }\n       }\n@@ -151,9 +162,10 @@ public void handleEvent (AWTEvent e)\n \tKeyEvent ke = (KeyEvent) e;\n \tif (!ke.isConsumed () && ke.getKeyCode () == KeyEvent.VK_ENTER)\n \t  {\n-            String selectedItem = ((List)awtComponent).getSelectedItem ();\n+            String selectedItem = ((List) awtComponent).getSelectedItem ();\n \n-            /* Enter only generates an Action event if something is selected */\n+            // Enter only generates an Action event if something is\n+            // selected.\n             if (selectedItem != null)\n \t      postActionEvent (selectedItem, ke.getModifiers ());\n \t  }"}, {"sha": "18e4d204897fb2c464601b2d358f35af60a9702e", "filename": "libjava/gnu/java/awt/peer/gtk/GtkTextAreaPeer.java", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextAreaPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextAreaPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextAreaPeer.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -50,6 +50,7 @@ public class GtkTextAreaPeer extends GtkTextComponentPeer\n   native void create (int width, int height, int scrollbarVisibility);\n \n   native void gtkSetFont (String name, int style, int size);\n+  native void gtkWidgetRequestFocus ();\n \n   void create ()\n   {\n@@ -171,9 +172,4 @@ public void insertText (String str, int pos)\n   {\n     insert (str, pos);\n   }\n-\n-  public void setFont (Font f)\n-  {\n-    gtkSetFont (f.getName (), f.getStyle (), f.getSize ());\n-  }\n }"}, {"sha": "5662336b193aa41d44c134fde3c7e6ace359381d", "filename": "libjava/gnu/java/awt/peer/gtk/GtkTextFieldPeer.java", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextFieldPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextFieldPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkTextFieldPeer.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -154,11 +154,6 @@ public void setEchoCharacter (char c)\n     setEchoChar (c);\n   }\n \n-  public void setFont (Font f)\n-  {\n-    gtkSetFont (f.getName (), f.getStyle (), f.getSize ());\n-  }\n-\n   public void handleEvent (AWTEvent e)\n   {\n     if (e.getID () == KeyEvent.KEY_PRESSED)"}, {"sha": "c9739c359b146cadcdd4177551ae5d822a1a7ac7", "filename": "libjava/gnu/java/awt/peer/gtk/GtkToolkit.java", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -428,9 +428,7 @@ protected EventQueue getSystemEventQueueImpl()\n     return q;\n   }\n \n-  protected void loadSystemColors (int[] systemColors) \n-  {\n-  }\n+  protected native void loadSystemColors (int[] systemColors);\n \n   public DragSourceContextPeer createDragSourceContextPeer(DragGestureEvent e)\n   {"}, {"sha": "009b18cedc0299edf26ea29ed5ffd58bfcf9105a", "filename": "libjava/java/applet/Applet.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fapplet%2FApplet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fapplet%2FApplet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fapplet%2FApplet.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -483,7 +483,7 @@ private Dimension getDimensions ()\n    */\n   public Dimension preferredSize()\n   {\n-    return getDimensions ();\n+    return stub == null ? super.preferredSize () : getDimensions ();\n   }\n \n   /**\n@@ -494,7 +494,7 @@ public Dimension preferredSize()\n    */\n   public Dimension minimumSize()\n   {\n-    return getDimensions ();\n+    return stub == null ? super.minimumSize () : getDimensions ();\n   }\n \n   /**"}, {"sha": "a084dcf24a0114cacf340d6ca9a8b0cb4630dea6", "filename": "libjava/java/awt/AWTEvent.java", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FAWTEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FAWTEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FAWTEvent.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -231,15 +231,15 @@ public int getID()\n   }\n \n   /**\n-   * Returns a string representation of this event. This is in the format\n-   * <code>getClass().getName() + '[' + paramString() + \"] on \"\n-   * + source</code>.\n+   * Create a string that represents this event in the format\n+   * <code>classname[eventstring] on sourcecomponentname</code>.\n    *\n-   * @return a string representation of this event\n+   * @return a string representing this event\n    */\n-  public String toString()\n+  public String toString ()\n   {\n-    return getClass().getName() + \"[\" + paramString() + \"] on \" + source;\n+    return getClass ().getName () + \"[\" + paramString () + \"] on \"\n+      + ((Component) source).getName ();\n   }\n \n   /**"}, {"sha": "3ca2b4f7aae5d41be5fedef18983c8c7cbfd2eda", "filename": "libjava/java/awt/Component.java", "status": "modified", "additions": 382, "deletions": 189, "changes": 571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FComponent.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -383,18 +383,18 @@\n   boolean focusable = true;\n \n   /**\n-   * Tracks whether this component uses default focus traversal, or has a\n-   * different policy.\n+   * Tracks whether this component's {@link #isFocusTraversable}\n+   * method has been overridden.\n    *\n-   * @see #isFocusTraversableOverridden()\n    * @since 1.4\n    */\n   int isFocusTraversableOverridden;\n \n   /**\n-   * The focus traversal keys, if not inherited from the parent or default\n-   * keyboard manager. These sets will contain only AWTKeyStrokes that\n-   * represent press and release events to use as focus control.\n+   * The focus traversal keys, if not inherited from the parent or\n+   * default keyboard focus manager. These sets will contain only\n+   * AWTKeyStrokes that represent press and release events to use as\n+   * focus control.\n    *\n    * @see #getFocusTraversalKeys(int)\n    * @see #setFocusTraversalKeys(int, Set)\n@@ -556,6 +556,12 @@\n    */\n   transient BufferStrategy bufferStrategy;\n \n+  /**\n+   * true if requestFocus was called on this component when its\n+   * top-level ancestor was not focusable.\n+   */\n+  private transient FocusEvent pendingFocusRequest = null;\n+\n   /**\n    * The system properties that affect image updating.\n    */\n@@ -566,6 +572,8 @@\n   {\n     incrementalDraw = Boolean.getBoolean (\"awt.image.incrementalDraw\");\n     redrawRate = Long.getLong (\"awt.image.redrawrate\");\n+    // Set the default KeyboardFocusManager.\n+    KeyboardFocusManager.setCurrentKeyboardFocusManager (null);\n   }\n \f\n   // Public and protected API.\n@@ -2963,6 +2971,7 @@ protected void processFocusEvent(FocusEvent e)\n   {\n     if (focusListener == null)\n       return;\n+\n     switch (e.id)\n       {\n         case FocusEvent.FOCUS_GAINED:\n@@ -3411,13 +3420,18 @@ public void setFocusable(boolean focusable)\n   }\n \n   /**\n-   * Sets the focus traversal keys for a given type of focus events. Normally,\n-   * the default values should match the operating system's native choices. To\n-   * disable a given traversal, use <code>Collections.EMPTY_SET</code>. The\n-   * event dispatcher will consume PRESSED, RELEASED, and TYPED events for the\n-   * specified key, although focus can only transfer on PRESSED or RELEASED.\n+   * Sets the focus traversal keys for one of the three focus\n+   * traversal directions supported by Components: {@link\n+   * #KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS}, {@link\n+   * #KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS}, or {@link\n+   * #KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}. Normally, the\n+   * default values should match the operating system's native\n+   * choices. To disable a given traversal, use\n+   * <code>Collections.EMPTY_SET</code>. The event dispatcher will\n+   * consume PRESSED, RELEASED, and TYPED events for the specified\n+   * key, although focus can only transfer on PRESSED or RELEASED.\n    *\n-   * <p>The defauts are:\n+   * <p>The defaults are:\n    * <table>\n    *   <th><td>Identifier</td><td>Meaning</td><td>Default</td></th>\n    *   <tr><td>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</td>\n@@ -3430,10 +3444,13 @@ public void setFocusable(boolean focusable)\n    *     <td>Go up a traversal cycle</td><td>None</td></tr>\n    * </table>\n    *\n-   * <p>Specifying null allows inheritance from the parent, or from the current\n-   * KeyboardFocusManager default set. If not null, the set must contain only\n-   * AWTKeyStrokes that are not already focus keys and are not KEY_TYPED\n-   * events.\n+   * If keystrokes is null, this component's focus traversal key set\n+   * is inherited from one of its ancestors.  If none of its ancestors\n+   * has its own set of focus traversal keys, the focus traversal keys\n+   * are set to the defaults retrieved from the current\n+   * KeyboardFocusManager.  If not null, the set must contain only\n+   * AWTKeyStrokes that are not already focus keys and are not\n+   * KEY_TYPED events.\n    *\n    * @param id one of FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS, or\n    *        UP_CYCLE_TRAVERSAL_KEYS\n@@ -3448,7 +3465,24 @@ public void setFocusable(boolean focusable)\n   public void setFocusTraversalKeys(int id, Set keystrokes)\n   {\n     if (keystrokes == null)\n-      throw new IllegalArgumentException();\n+      {\n+        Container parent = getParent ();\n+\n+        while (parent != null)\n+          {\n+            if (parent.areFocusTraversalKeysSet (id))\n+              {\n+                keystrokes = parent.getFocusTraversalKeys (id);\n+                break;\n+              }\n+            parent = parent.getParent ();\n+          }\n+\n+        if (keystrokes == null)\n+          keystrokes = KeyboardFocusManager.getCurrentKeyboardFocusManager ().\n+            getDefaultFocusTraversalKeys (id);\n+      }\n+\n     Set sa;\n     Set sb;\n     String name;\n@@ -3476,50 +3510,60 @@ public void setFocusTraversalKeys(int id, Set keystrokes)\n         name = \"upCycleFocusTraversalKeys\";\n         break;\n       default:\n-        throw new IllegalArgumentException();\n+        throw new IllegalArgumentException ();\n       }\n-    int i = keystrokes.size();\n-    Iterator iter = keystrokes.iterator();\n+\n+    int i = keystrokes.size ();\n+    Iterator iter = keystrokes.iterator ();\n+\n     while (--i >= 0)\n       {\n-        Object o = iter.next();\n-        if (! (o instanceof AWTKeyStroke)\n-            || sa.contains(o) || sb.contains(o)\n+        Object o = iter.next ();\n+        if (!(o instanceof AWTKeyStroke)\n+            || sa.contains (o) || sb.contains (o)\n             || ((AWTKeyStroke) o).keyCode == KeyEvent.VK_UNDEFINED)\n-          throw new IllegalArgumentException();\n+          throw new IllegalArgumentException ();\n       }\n+\n     if (focusTraversalKeys == null)\n       focusTraversalKeys = new Set[3];\n-    keystrokes = Collections.unmodifiableSet(new HashSet(keystrokes));\n-    firePropertyChange(name, focusTraversalKeys[id], keystrokes);\n+\n+    keystrokes = Collections.unmodifiableSet (new HashSet (keystrokes));\n+    firePropertyChange (name, focusTraversalKeys[id], keystrokes);\n+\n     focusTraversalKeys[id] = keystrokes;\n   }\n \n   /**\n-   * Returns the set of keys for a given focus traversal action, as defined\n-   * in <code>setFocusTraversalKeys</code>. If not set, this is inherited from\n-   * the parent component, which may have gotten it from the\n-   * KeyboardFocusManager.\n+   * Returns the set of keys for a given focus traversal action, as\n+   * defined in <code>setFocusTraversalKeys</code>.  If not set, this\n+   * is inherited from the parent component, which may have gotten it\n+   * from the KeyboardFocusManager.\n    *\n-   * @param id one of FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS, or\n-   *        UP_CYCLE_TRAVERSAL_KEYS\n+   * @param id one of FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS,\n+   * or UP_CYCLE_TRAVERSAL_KEYS\n    * @throws IllegalArgumentException if id is invalid\n-   * @see #setFocusTraversalKeys(int, Set)\n+   * @see #setFocusTraversalKeys (int, Set)\n    * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS\n    * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS\n    * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS\n    * @since 1.4\n    */\n-  public Set getFocusTraversalKeys(int id)\n+  public Set getFocusTraversalKeys (int id)\n   {\n-    if (id < KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS\n-        || id > KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS)\n+    if (id != KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS &&\n+        id != KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS &&\n+        id != KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS)\n       throw new IllegalArgumentException();\n+\n     Set s = null;\n+\n     if (focusTraversalKeys != null)\n       s = focusTraversalKeys[id];\n+\n     if (s == null && parent != null)\n-      s = parent.getFocusTraversalKeys(id);\n+      s = parent.getFocusTraversalKeys (id);\n+\n     return s == null ? (KeyboardFocusManager.getCurrentKeyboardFocusManager()\n                         .getDefaultFocusTraversalKeys(id)) : s;\n   }\n@@ -3528,269 +3572,417 @@ public Set getFocusTraversalKeys(int id)\n    * Tests whether the focus traversal keys for a given action are explicitly\n    * set or inherited.\n    *\n-   * @param id one of FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS, or\n-   *        UP_CYCLE_TRAVERSAL_KEYS\n+   * @param id one of FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS,\n+   * or UP_CYCLE_TRAVERSAL_KEYS\n    * @return true if that set is explicitly specified\n    * @throws IllegalArgumentException if id is invalid\n-   * @see #getFocusTraversalKeys(int)\n+   * @see #getFocusTraversalKeys (int)\n    * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS\n    * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS\n    * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS\n    * @since 1.4\n    */\n-  public boolean areFocusTraversalKeysSet(int id)\n+  public boolean areFocusTraversalKeysSet (int id)\n   {\n-    if (id < KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS\n-        || id > KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS)\n-      throw new IllegalArgumentException();\n+    if (id != KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS &&\n+        id != KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS &&\n+        id != KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS)\n+      throw new IllegalArgumentException ();\n+\n     return focusTraversalKeys != null && focusTraversalKeys[id] != null;\n   }\n \n   /**\n-   * Sets whether focus traversal keys are enabled, which consumes traversal\n-   * keys and performs the focus event automatically.\n+   * Enable or disable focus traversal keys on this Component.  If\n+   * they are, then the keyboard focus manager consumes and acts on\n+   * key press and release events that trigger focus traversal, and\n+   * discards the corresponding key typed events.  If focus traversal\n+   * keys are disabled, then all key events that would otherwise\n+   * trigger focus traversal are sent to this Component.\n    *\n    * @param focusTraversalKeysEnabled the new value of the flag\n-   * @see #getFocusTraversalKeysEnabled()\n-   * @see #setFocusTraversalKeys(int, Set)\n-   * @see #getFocusTraversalKeys(int)\n+   * @see #getFocusTraversalKeysEnabled ()\n+   * @see #setFocusTraversalKeys (int, Set)\n+   * @see #getFocusTraversalKeys (int)\n    * @since 1.4\n    */\n-  public void setFocusTraversalKeysEnabled(boolean focusTraversalKeysEnabled)\n+  public void setFocusTraversalKeysEnabled (boolean focusTraversalKeysEnabled)\n   {\n-    firePropertyChange(\"focusTraversalKeysEnabled\",\n-                       this.focusTraversalKeysEnabled,\n-                       focusTraversalKeysEnabled);\n+    firePropertyChange (\"focusTraversalKeysEnabled\",\n+\t\t\tthis.focusTraversalKeysEnabled,\n+\t\t\tfocusTraversalKeysEnabled);\n     this.focusTraversalKeysEnabled = focusTraversalKeysEnabled;\n   }\n \n   /**\n-   * Tests whether focus traversal keys are enabled. If they are, then focus\n-   * traversal keys are consumed and focus events performed automatically,\n-   * without the component seeing the keystrokes.\n+   * Check whether or not focus traversal keys are enabled on this\n+   * Component.  If they are, then the keyboard focus manager consumes\n+   * and acts on key press and release events that trigger focus\n+   * traversal, and discards the corresponding key typed events.  If\n+   * focus traversal keys are disabled, then all key events that would\n+   * otherwise trigger focus traversal are sent to this Component.\n    *\n-   * @return true if focus traversal is enabled\n-   * @see #setFocusTraversalKeysEnabled(boolean)\n-   * @see #setFocusTraversalKeys(int, Set)\n-   * @see #getFocusTraversalKeys(int)\n+   * @return true if focus traversal keys are enabled\n+   * @see #setFocusTraversalKeysEnabled (boolean)\n+   * @see #setFocusTraversalKeys (int, Set)\n+   * @see #getFocusTraversalKeys (int)\n    * @since 1.4\n    */\n-  public boolean getFocusTraversalKeysEnabled()\n+  public boolean getFocusTraversalKeysEnabled ()\n   {\n     return focusTraversalKeysEnabled;\n   }\n \n   /**\n-   * Requests that this component be given focus. A <code>FOCUS_GAINED</code>\n-   * event will be fired if and only if this request is successful. To be\n-   * successful, the component must be displayable, visible, and focusable,\n-   * and the top-level Window must be able to receive focus. Thus, this\n-   * request may fail, or be delayed until the window receives focus. It is\n-   * recommended that <code>requestFocusInWindow</code> be used where\n-   * possible to be more platform-independent.\n+   * Request that this Component be given the keyboard input focus and\n+   * that its top-level ancestor become the focused Window.\n+   *\n+   * For the request to be granted, the Component must be focusable,\n+   * displayable and showing and the top-level Window to which it\n+   * belongs must be focusable.  If the request is initially denied on\n+   * the basis that the top-level Window is not focusable, the request\n+   * will be remembered and granted when the Window does become\n+   * focused.\n+   *\n+   * Never assume that this Component is the focus owner until it\n+   * receives a FOCUS_GAINED event.\n    *\n-   * @see #requestFocusInWindow()\n+   * The behaviour of this method is platform-dependent.\n+   * {@link #requestFocusInWindow} should be used instead.\n+   *\n+   * @see #requestFocusInWindow ()\n    * @see FocusEvent\n-   * @see #addFocusListener(FocusListener)\n-   * @see #isFocusable()\n-   * @see #isDisplayable()\n-   * @see KeyboardFocusManager#clearGlobalFocusOwner()\n+   * @see #addFocusListener (FocusListener)\n+   * @see #isFocusable ()\n+   * @see #isDisplayable ()\n+   * @see KeyboardFocusManager#clearGlobalFocusOwner ()\n    */\n-  public void requestFocus()\n+  public void requestFocus ()\n   {\n-    // If there's no peer then this component can't get the focus. We\n-    // treat it as a silent rejection of the request.\n-    if (peer != null)\n-      peer.requestFocus();\n+    if (isDisplayable ()\n+\t&& isShowing ()\n+\t&& isFocusable ())\n+      {\n+        synchronized (getTreeLock ())\n+          {\n+            // Find this Component's top-level ancestor.\n+            Container parent = getParent ();\n+\n+            while (parent != null\n+                   && !(parent instanceof Window))\n+              parent = parent.getParent ();\n+\n+            Window toplevel = (Window) parent;\n+            if (toplevel.isFocusableWindow ())\n+              {\n+                if (peer != null)\n+                  // This call will cause a FOCUS_GAINED event to be\n+                  // posted to the system event queue if the native\n+                  // windowing system grants the focus request.\n+                  peer.requestFocus ();\n+                else\n+                  {\n+                    // Either our peer hasn't been created yet or we're a\n+                    // lightweight component.  In either case we want to\n+                    // post a FOCUS_GAINED event.\n+                    EventQueue eq = Toolkit.getDefaultToolkit ().getSystemEventQueue ();\n+                    eq.postEvent (new FocusEvent(this, FocusEvent.FOCUS_GAINED));\n+                  }\n+              }\n+            else\n+              pendingFocusRequest = new FocusEvent(this, FocusEvent.FOCUS_GAINED);\n+          }\n+      }\n   }\n \n   /**\n-   * Requests that this component be given focus. A <code>FOCUS_GAINED</code>\n-   * event will be fired if and only if this request is successful. To be\n-   * successful, the component must be displayable, visible, and focusable,\n-   * and the top-level Window must be able to receive focus. Thus, this\n-   * request may fail, or be delayed until the window receives focus. It is\n-   * recommended that <code>requestFocusInWindow</code> be used where\n-   * possible to be more platform-independent.\n+   * Request that this Component be given the keyboard input focus and\n+   * that its top-level ancestor become the focused Window.\n+   *\n+   * For the request to be granted, the Component must be focusable,\n+   * displayable and showing and the top-level Window to which it\n+   * belongs must be focusable.  If the request is initially denied on\n+   * the basis that the top-level Window is not focusable, the request\n+   * will be remembered and granted when the Window does become\n+   * focused.\n+   *\n+   * Never assume that this Component is the focus owner until it\n+   * receives a FOCUS_GAINED event.\n+   *\n+   * The behaviour of this method is platform-dependent.\n+   * {@link #requestFocusInWindow} should be used instead.\n    *\n-   * <p>If the return value is false, the request is guaranteed to fail. If\n-   * it is true, it will likely succeed unless the action is vetoed or\n-   * something in the native windowing system intervenes. The temporary flag,\n-   * and thus this method in general, is not designed for public use; rather\n-   * it is a hook for lightweight components to notify their container in\n-   * an attempt to reduce the amount of repainting necessary.\n+   * If the return value is false, the request is guaranteed to fail.\n+   * If the return value is true, the request will succeed unless it\n+   * is vetoed or something in the native windowing system intervenes,\n+   * preventing this Component's top-level ancestor from becoming\n+   * focused.  This method is meant to be called by derived\n+   * lightweight Components that want to avoid unnecessary repainting\n+   * when they know a given focus transfer need only be temporary.\n    *\n    * @param temporary true if the focus request is temporary\n    * @return true if the request has a chance of success\n-   * @see #requestFocusInWindow()\n+   * @see #requestFocusInWindow ()\n    * @see FocusEvent\n-   * @see #addFocusListener(FocusListener)\n-   * @see #isFocusable()\n-   * @see #isDisplayable()\n-   * @see KeyboardFocusManager#clearGlobalFocusOwner()\n+   * @see #addFocusListener (FocusListener)\n+   * @see #isFocusable ()\n+   * @see #isDisplayable ()\n+   * @see KeyboardFocusManager#clearGlobalFocusOwner ()\n    * @since 1.4\n    */\n-  protected boolean requestFocus(boolean temporary)\n+  protected boolean requestFocus (boolean temporary)\n   {\n-    // XXX Implement correctly.\n-    requestFocus();\n+    if (isDisplayable ()\n+\t&& isShowing ()\n+\t&& isFocusable ())\n+      {\n+        synchronized (getTreeLock ())\n+          {\n+            // Find this Component's top-level ancestor.\n+            Container parent = getParent ();\n+\n+            while (parent != null\n+                   && !(parent instanceof Window))\n+              parent = parent.getParent ();\n+\n+            Window toplevel = (Window) parent;\n+            if (toplevel.isFocusableWindow ())\n+              {\n+                if (peer != null)\n+                  // This call will cause a FOCUS_GAINED event to be\n+                  // posted to the system event queue if the native\n+                  // windowing system grants the focus request.\n+                  peer.requestFocus ();\n+                else\n+                  {\n+                    // Either our peer hasn't been created yet or we're a\n+                    // lightweight component.  In either case we want to\n+                    // post a FOCUS_GAINED event.\n+                    EventQueue eq = Toolkit.getDefaultToolkit ().getSystemEventQueue ();\n+                    eq.postEvent (new FocusEvent(this, FocusEvent.FOCUS_GAINED, temporary));\n+                  }\n+              }\n+            else\n+              // FIXME: need to add a focus listener to our top-level\n+              // ancestor, so that we can post this event when it becomes\n+              // the focused window.\n+              pendingFocusRequest = new FocusEvent(this, FocusEvent.FOCUS_GAINED, temporary);\n+          }\n+      }\n+    // Always return true.\n     return true;\n   }\n \n   /**\n-   * Requests that this component be given focus, if it resides in the\n-   * top-level window which already has focus. A <code>FOCUS_GAINED</code>\n-   * event will be fired if and only if this request is successful. To be\n-   * successful, the component must be displayable, visible, and focusable,\n-   * and the top-level Window must be focused.\n+   * Request that this component be given the keyboard input focus, if\n+   * its top-level ancestor is the currently focused Window.  A\n+   * <code>FOCUS_GAINED</code> event will be fired if and only if this\n+   * request is successful. To be successful, the component must be\n+   * displayable, showing, and focusable, and its ancestor top-level\n+   * Window must be focused.\n    *\n-   * <p>If the return value is false, the request is guaranteed to fail. If\n-   * it is true, it will likely succeed unless the action is vetoed or\n-   * something in the native windowing system intervenes. The temporary flag,\n-   * and thus this method in general, is not designed for public use; rather\n-   * it is a hook for lightweight components to notify their container in\n-   * an attempt to reduce the amount of repainting necessary.\n+   * If the return value is false, the request is guaranteed to fail.\n+   * If the return value is true, the request will succeed unless it\n+   * is vetoed or something in the native windowing system intervenes,\n+   * preventing this Component's top-level ancestor from becoming\n+   * focused.\n    *\n    * @return true if the request has a chance of success\n-   * @see #requestFocus()\n+   * @see #requestFocus ()\n    * @see FocusEvent\n-   * @see #addFocusListener(FocusListener)\n-   * @see #isFocusable()\n-   * @see #isDisplayable()\n-   * @see KeyboardFocusManager#clearGlobalFocusOwner()\n+   * @see #addFocusListener (FocusListener)\n+   * @see #isFocusable ()\n+   * @see #isDisplayable ()\n+   * @see KeyboardFocusManager#clearGlobalFocusOwner ()\n    * @since 1.4\n    */\n-  public boolean requestFocusInWindow()\n+  public boolean requestFocusInWindow ()\n   {\n-    // XXX Implement correctly.\n-    requestFocus();\n-    return true;\n+    return requestFocusInWindow (false);\n   }\n \n   /**\n-   * Requests that this component be given focus, if it resides in the\n-   * top-level window which already has focus. A <code>FOCUS_GAINED</code>\n-   * event will be fired if and only if this request is successful. To be\n-   * successful, the component must be displayable, visible, and focusable,\n-   * and the top-level Window must be focused.\n+   * Request that this component be given the keyboard input focus, if\n+   * its top-level ancestor is the currently focused Window.  A\n+   * <code>FOCUS_GAINED</code> event will be fired if and only if this\n+   * request is successful. To be successful, the component must be\n+   * displayable, showing, and focusable, and its ancestor top-level\n+   * Window must be focused.\n    *\n-   * <p>If the return value is false, the request is guaranteed to fail. If\n-   * it is true, it will likely succeed unless the action is vetoed or\n-   * something in the native windowing system intervenes. The temporary flag,\n-   * and thus this method in general, is not designed for public use; rather\n-   * it is a hook for lightweight components to notify their container in\n-   * an attempt to reduce the amount of repainting necessary.\n+   * If the return value is false, the request is guaranteed to fail.\n+   * If the return value is true, the request will succeed unless it\n+   * is vetoed or something in the native windowing system intervenes,\n+   * preventing this Component's top-level ancestor from becoming\n+   * focused.  This method is meant to be called by derived\n+   * lightweight Components that want to avoid unnecessary repainting\n+   * when they know a given focus transfer need only be temporary.\n    *\n    * @param temporary true if the focus request is temporary\n    * @return true if the request has a chance of success\n-   * @see #requestFocus()\n+   * @see #requestFocus ()\n    * @see FocusEvent\n-   * @see #addFocusListener(FocusListener)\n-   * @see #isFocusable()\n-   * @see #isDisplayable()\n-   * @see KeyboardFocusManager#clearGlobalFocusOwner()\n+   * @see #addFocusListener (FocusListener)\n+   * @see #isFocusable ()\n+   * @see #isDisplayable ()\n+   * @see KeyboardFocusManager#clearGlobalFocusOwner ()\n    * @since 1.4\n    */\n-  protected boolean requestFocusInWindow(boolean temporary)\n+  protected boolean requestFocusInWindow (boolean temporary)\n   {\n-    // XXX Implement correctly.\n-    requestFocus();\n-    return true;\n+    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n+\n+    Window focusedWindow = manager.getFocusedWindow ();\n+\n+    if (isDisplayable ()\n+\t&& isShowing ()\n+\t&& isFocusable ())\n+      {\n+        if (focusedWindow != null)\n+          {\n+            synchronized (getTreeLock ())\n+              {\n+                Container parent = getParent ();\n+\n+                while (parent != null\n+                       && !(parent instanceof Window))\n+                  parent = parent.getParent ();\n+\n+                Window toplevel = (Window) parent;\n+\n+                // Check if top-level ancestor is currently focused window.\n+                if (focusedWindow == toplevel)\n+                  {\n+                    if (peer != null)\n+                      // This call will cause a FOCUS_GAINED event to be\n+                      // posted to the system event queue if the native\n+                      // windowing system grants the focus request.\n+                      peer.requestFocus ();\n+                    else\n+                      {\n+                        // Either our peer hasn't been created yet or we're a\n+                        // lightweight component.  In either case we want to\n+                        // post a FOCUS_GAINED event.\n+                        EventQueue eq = Toolkit.getDefaultToolkit ().getSystemEventQueue ();\n+                        eq.postEvent (new FocusEvent(this, FocusEvent.FOCUS_GAINED, temporary));\n+                      }\n+                  }\n+                else\n+                  return false;\n+              }\n+          }\n+\n+        return true;\n+      }\n+    return false;\n   }\n \n   /**\n-   * Transfers focus to the next component in the focus traversal order, as\n-   * though this were the current focus owner.\n+   * Transfers focus to the next component in the focus traversal\n+   * order, as though this were the current focus owner.\n    *\n    * @see #requestFocus()\n    * @since 1.1\n    */\n-  public void transferFocus()\n+  public void transferFocus ()\n   {\n-    Component next;\n-    if (parent == null)\n-      next = findNextFocusComponent(null);\n-    else\n-      next = parent.findNextFocusComponent(this);\n-    if (next != null && next != this)\n-      next.requestFocus();\n+    nextFocus ();\n   }\n \n   /**\n-   * Returns the root container that owns the focus cycle where this component\n-   * resides. A focus cycle root is in two cycles, one as the ancestor, and\n-   * one as the focusable element; this call always returns the ancestor.\n+   * Returns the root container that owns the focus cycle where this\n+   * component resides. A focus cycle root is in two cycles, one as\n+   * the ancestor, and one as the focusable element; this call always\n+   * returns the ancestor.\n    *\n    * @return the ancestor container that owns the focus cycle\n    * @since 1.4\n    */\n-  public Container getFocusCycleRootAncestor()\n+  public Container getFocusCycleRootAncestor ()\n   {\n-    // XXX Implement.\n-    throw new Error(\"not implemented\");\n+    if (this instanceof Window\n+\t&& ((Container) this).isFocusCycleRoot ())\n+      return (Container) this;\n+\n+    Container parent = getParent ();\n+\n+    while (parent != null\n+\t   && !parent.isFocusCycleRoot ())\n+      parent = parent.getParent ();\n+\n+    return parent;\n   }\n \n   /**\n-   * Tests if the container is the ancestor of the focus cycle that this\n-   * component belongs to.\n+   * Tests if the container is the ancestor of the focus cycle that\n+   * this component belongs to.\n    *\n    * @param c the container to test\n    * @return true if c is the focus cycle root\n    * @since 1.4\n    */\n-  public boolean isFocusCycleRoot(Container c)\n+  public boolean isFocusCycleRoot (Container c)\n   {\n-    return c == getFocusCycleRootAncestor();\n+    return c == getFocusCycleRootAncestor ();\n   }\n \n   /**\n-   * AWT 1.0 focus event processor.\n+   * AWT 1.0 focus event processor.  Transfers focus to the next\n+   * component in the focus traversal order, as though this were the\n+   * current focus owner.\n    *\n-   * @deprecated use {@link #transferFocus()} instead\n+   * @deprecated use {@link #transferFocus ()} instead\n    */\n-  public void nextFocus()\n+  public void nextFocus ()\n   {\n-    transferFocus();\n+    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n+\n+    manager.focusNextComponent (this);\n   }\n \n   /**\n-   * Transfers focus to the previous component in the focus traversal order, as\n-   * though this were the current focus owner.\n+   * Transfers focus to the previous component in the focus traversal\n+   * order, as though this were the current focus owner.\n    *\n-   * @see #requestFocus()\n+   * @see #requestFocus ()\n    * @since 1.4\n    */\n-  public void transferFocusBackward()\n+  public void transferFocusBackward ()\n   {\n-    // XXX Implement.\n-    throw new Error(\"not implemented\");\n+    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n+\n+    manager.focusPreviousComponent (this);\n   }\n \n   /**\n-   * Transfers focus to the focus cycle root of this component. However, if\n-   * this is a Window, the default focus owner in the window in the current\n-   * focus cycle is focused instead.\n+   * Transfers focus to the focus cycle root of this component.\n+   * However, if this is a Window, the default focus owner in the\n+   * window in the current focus cycle is focused instead.\n    *\n-   * @see #requestFocus()\n-   * @see #isFocusCycleRoot()\n+   * @see #requestFocus ()\n+   * @see #isFocusCycleRoot ()\n    * @since 1.4\n    */\n-  public void transferFocusUpCycle()\n+  public void transferFocusUpCycle ()\n   {\n-    // XXX Implement.\n-    throw new Error(\"not implemented\");\n+    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n+\n+    manager.upFocusCycle (this);\n   }\n \n   /**\n-   * Tests if this component is the focus owner. Use {@link #isFocusOwner()}\n-   * instead.\n+   * Tests if this component is the focus owner. Use {@link\n+   * #isFocusOwner ()} instead.\n    *\n    * @return true if this component owns focus\n    * @since 1.2\n    */\n-  public boolean hasFocus()\n+  public boolean hasFocus ()\n   {\n-    return isFocusOwner();\n+    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n+\n+    Component focusOwner = manager.getFocusOwner ();\n+\n+    return this == focusOwner;\n   }\n \n   /**\n@@ -3801,8 +3993,7 @@ public boolean hasFocus()\n    */\n   public boolean isFocusOwner()\n   {\n-    // XXX Implement.\n-    throw new Error(\"not implemented\");\n+    return hasFocus ();\n   }\n \n   /**\n@@ -4337,6 +4528,8 @@ private PaintEvent coalescePaintEvents(PaintEvent queuedEvent,\n    * making the request. This is overridden by Container; when called for an\n    * ordinary component there is no child and so we always return null.\n    *\n+   * FIXME: is this still needed, in light of focus traversal policies?\n+   *\n    * @param child the component making the request\n    * @return the next component to focus on\n    */\n@@ -4897,23 +5090,23 @@ public Accessible getAccessibleAt(Point p)\n      * Tests whether this component can accept focus.\n      *\n      * @return true if this is focus traversable\n-     * @see #getAccessibleStateSet()\n+     * @see #getAccessibleStateSet ()\n      * @see AccessibleState#FOCUSABLE\n      * @see AccessibleState#FOCUSED\n      */\n-    public boolean isFocusTraversable()\n+    public boolean isFocusTraversable ()\n     {\n-      return Component.this.isFocusTraversable();\n+      return Component.this.isFocusTraversable ();\n     }\n \n     /**\n      * Requests focus for this component.\n      *\n-     * @see #isFocusTraversable()\n+     * @see #isFocusTraversable ()\n      */\n-    public void requestFocus()\n+    public void requestFocus ()\n     {\n-      Component.this.requestFocus();\n+      Component.this.requestFocus ();\n     }\n \n     /**"}, {"sha": "0482e6547360da0bf9e3c82ccea94011aacaf2f0", "filename": "libjava/java/awt/Container.java", "status": "modified", "additions": 305, "deletions": 28, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FContainer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FContainer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FContainer.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -46,10 +46,16 @@\n import java.awt.peer.LightweightPeer;\n import java.beans.PropertyChangeListener;\n import java.beans.PropertyChangeSupport;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n import java.io.PrintStream;\n import java.io.PrintWriter;\n import java.io.Serializable;\n+import java.util.Collections;\n import java.util.EventListener;\n+import java.util.Iterator;\n+import java.util.HashSet;\n import java.util.Set;\n import javax.accessibility.Accessible;\n import javax.swing.SwingUtilities;\n@@ -93,6 +99,21 @@ public class Container extends Component\n   transient ContainerListener containerListener;\n   transient PropertyChangeSupport changeSupport; \n \n+  /** The focus traversal policy that determines how focus is\n+      transferred between this Container and its children. */\n+  private FocusTraversalPolicy focusTraversalPolicy;\n+\n+  /**\n+   * The focus traversal keys, if not inherited from the parent or default\n+   * keyboard manager. These sets will contain only AWTKeyStrokes that\n+   * represent press and release events to use as focus control.\n+   *\n+   * @see #getFocusTraversalKeys(int)\n+   * @see #setFocusTraversalKeys(int, Set)\n+   * @since 1.4\n+   */\n+  transient Set[] focusTraversalKeys;\n+\n   /**\n    * Default constructor for subclasses.\n    */\n@@ -397,6 +418,8 @@ public void remove(int index)\n         if (layoutMgr != null)\n           layoutMgr.removeLayoutComponent(r);\n \n+        r.parent = null;\n+\n         // Post event to notify of adding the container.\n         ContainerEvent ce = new ContainerEvent(this,\n                                                ContainerEvent.COMPONENT_REMOVED,\n@@ -853,6 +876,11 @@ public Component getComponentAt(int x, int y)\n   {\n     return locate (x, y);\n   }\n+  \n+  public Component getComponentAt(int index)\n+  {\n+    return component[index];\n+  }\n \n   /**\n    * Returns the component located at the specified point.  This is done\n@@ -1068,9 +1096,89 @@ public void setFocusTraversalKeys(int id, Set keystrokes)\n       throw new IllegalArgumentException ();\n \n     if (keystrokes == null)\n-      throw new IllegalArgumentException ();\n+      {\n+        Container parent = getParent ();\n \n-    throw new Error (\"not implemented\");\n+        while (parent != null)\n+          {\n+            if (parent.areFocusTraversalKeysSet (id))\n+              {\n+                keystrokes = parent.getFocusTraversalKeys (id);\n+                break;\n+              }\n+            parent = parent.getParent ();\n+          }\n+\n+        if (keystrokes == null)\n+          keystrokes = KeyboardFocusManager.getCurrentKeyboardFocusManager ().\n+            getDefaultFocusTraversalKeys (id);\n+      }\n+\n+    Set sa;\n+    Set sb;\n+    Set sc;\n+    String name;\n+    switch (id)\n+      {\n+      case KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS:\n+        sa = getFocusTraversalKeys\n+          (KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS);\n+        sb = getFocusTraversalKeys\n+          (KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS);\n+        sc = getFocusTraversalKeys\n+          (KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS);\n+        name = \"forwardFocusTraversalKeys\";\n+        break;\n+      case KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS:\n+        sa = getFocusTraversalKeys\n+          (KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS);\n+        sb = getFocusTraversalKeys\n+          (KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS);\n+        sc = getFocusTraversalKeys\n+          (KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS);\n+        name = \"backwardFocusTraversalKeys\";\n+        break;\n+      case KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS:\n+        sa = getFocusTraversalKeys\n+          (KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS);\n+        sb = getFocusTraversalKeys\n+          (KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS);\n+        sc = getFocusTraversalKeys\n+          (KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS);\n+        name = \"upCycleFocusTraversalKeys\";\n+        break;\n+      case KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS:\n+        sa = getFocusTraversalKeys\n+          (KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS);\n+        sb = getFocusTraversalKeys\n+          (KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS);\n+        sc = getFocusTraversalKeys\n+          (KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS);\n+        name = \"downCycleFocusTraversalKeys\";\n+        break;\n+      default:\n+        throw new IllegalArgumentException ();\n+      }\n+\n+    int i = keystrokes.size ();\n+    Iterator iter = keystrokes.iterator ();\n+\n+    while (--i >= 0)\n+      {\n+        Object o = iter.next ();\n+        if (!(o instanceof AWTKeyStroke)\n+            || sa.contains (o) || sb.contains (o) || sc.contains (o)\n+            || ((AWTKeyStroke) o).keyCode == KeyEvent.VK_UNDEFINED)\n+          throw new IllegalArgumentException ();\n+      }\n+\n+    if (focusTraversalKeys == null)\n+      focusTraversalKeys = new Set[3];\n+\n+    keystrokes = Collections.unmodifiableSet (new HashSet (keystrokes));\n+    firePropertyChange (name, focusTraversalKeys[id], keystrokes);\n+\n+    focusTraversalKeys[id] = keystrokes;\n   }\n   \n   /**\n@@ -1085,17 +1193,26 @@ public void setFocusTraversalKeys(int id, Set keystrokes)\n    *\n    * @since 1.4\n    */\n-  public Set getFocusTraversalKeys(int id)\n+  public Set getFocusTraversalKeys (int id)\n   {\n     if (id != KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS &&\n         id != KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS &&\n         id != KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS &&\n         id != KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS)\n       throw new IllegalArgumentException ();\n \n-    return null;\n+    Set s = null;\n+\n+    if (focusTraversalKeys != null)\n+      s = focusTraversalKeys[id];\n+\n+    if (s == null && parent != null)\n+      s = parent.getFocusTraversalKeys (id);\n+\n+    return s == null ? (KeyboardFocusManager.getCurrentKeyboardFocusManager()\n+                        .getDefaultFocusTraversalKeys(id)) : s;\n   }\n-  \n+\n   /**\n    * Returns whether the Set of focus traversal keys for the given focus\n    * traversal operation has been explicitly defined for this Container.\n@@ -1110,51 +1227,156 @@ public Set getFocusTraversalKeys(int id)\n    *\n    * @since 1.4\n    */\n-  public boolean areFocusTraversalKeysSet(int id)\n+  public boolean areFocusTraversalKeysSet (int id)\n   {\n     if (id != KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS &&\n         id != KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS &&\n         id != KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS &&\n         id != KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS)\n       throw new IllegalArgumentException ();\n \n-    return false;\n+    return focusTraversalKeys != null && focusTraversalKeys[id] != null;\n   }\n-  \n-  public boolean isFocusCycleRoot(Container c)\n+\n+  /**\n+   * Check whether the given Container is the focus cycle root of this\n+   * Container's focus traversal cycle.  If this Container is a focus\n+   * cycle root itself, then it will be in two different focus cycles\n+   * -- it's own, and that of its ancestor focus cycle root's.  In\n+   * that case, if <code>c</code> is either of those containers, this\n+   * method will return true.\n+   *\n+   * @param c the candidate Container\n+   *\n+   * @return true if c is the focus cycle root of the focus traversal\n+   * cycle to which this Container belongs, false otherwise\n+   *\n+   * @since 1.4\n+   */\n+  public boolean isFocusCycleRoot (Container c)\n   {\n+    if (this == c\n+        && isFocusCycleRoot ())\n+      return true;\n+\n+    Container ancestor = getFocusCycleRootAncestor ();\n+\n+    if (c == ancestor)\n+      return true;\n+\n     return false;\n   }\n-  \n-  public void transferFocusBackward()\n-  {\n-  }\n-  \n-  public void setFocusTraversalPolicy(FocusTraversalPolicy policy)\n+\n+  /**\n+   * If this Container is a focus cycle root, set the focus traversal\n+   * policy that determines the focus traversal order for its\n+   * children.  If non-null, this policy will be inherited by all\n+   * inferior focus cycle roots.  If <code>policy</code> is null, this\n+   * Container will inherit its policy from the closest ancestor focus\n+   * cycle root that's had its policy set.\n+   *\n+   * @param policy the new focus traversal policy for this Container or null\n+   *\n+   * @since 1.4\n+   */\n+  public void setFocusTraversalPolicy (FocusTraversalPolicy policy)\n   {\n+    focusTraversalPolicy = policy;\n   }\n-  \n-  public FocusTraversalPolicy getFocusTraversalPolicy()\n+\n+  /**\n+   * Return the focus traversal policy that determines the focus\n+   * traversal order for this Container's children.  This method\n+   * returns null if this Container is not a focus cycle root.  If the\n+   * focus traversal policy has not been set explicitly, then this\n+   * method will return an ancestor focus cycle root's policy instead.\n+   *\n+   * @return this Container's focus traversal policy or null\n+   *\n+   * @since 1.4\n+   */\n+  public FocusTraversalPolicy getFocusTraversalPolicy ()\n   {\n-    return null;\n+    if (!isFocusCycleRoot ())\n+      return null;\n+\n+    if (focusTraversalPolicy == null)\n+      {\n+        Container ancestor = getFocusCycleRootAncestor ();\n+\n+\tif (ancestor != this)\n+\t  return ancestor.getFocusTraversalPolicy ();\n+\telse\n+\t  {\n+\t    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n+\n+\t    return manager.getDefaultFocusTraversalPolicy ();\n+\t  }\n+      }\n+    else\n+      return focusTraversalPolicy;\n   }\n-  \n-  public boolean isFocusTraversalPolicySet()\n+\n+  /**\n+   * Check whether this Container's focus traversal policy has been\n+   * explicitly set.  If it has not, then this Container will inherit\n+   * its focus traversal policy from one of its ancestor focus cycle\n+   * roots.\n+   *\n+   * @return true if focus traversal policy is set, false otherwise\n+  */\n+  public boolean isFocusTraversalPolicySet ()\n   {\n-    return false;\n+    return focusTraversalPolicy == null;\n   }\n-  \n-  public void setFocusCycleRoot(boolean focusCycleRoot)\n+\n+  /**\n+   * Set whether or not this Container is the root of a focus\n+   * traversal cycle.  This Container's focus traversal policy\n+   * determines the order of focus traversal.  Some policies prevent\n+   * the focus from being transferred between two traversal cycles\n+   * until an up or down traversal operation is performed.  In that\n+   * case, normal traversal (not up or down) is limited to this\n+   * Container and all of this Container's descendents that are not\n+   * descendents of inferior focus cycle roots.  In the default case\n+   * however, ContainerOrderFocusTraversalPolicy is in effect, and it\n+   * supports implicit down-cycle traversal operations.\n+   *\n+   * @return true if this is a focus cycle root, false otherwise\n+   *\n+   * @since 1.4\n+   */\n+  public void setFocusCycleRoot (boolean focusCycleRoot)\n   {\n+    this.focusCycleRoot = focusCycleRoot;\n   }\n-  \n-  public boolean isFocusCycleRoot()\n+\n+  /**\n+   * Check whether this Container is a focus cycle root.\n+   *\n+   * @return true if this is a focus cycle root, false otherwise\n+   *\n+   * @since 1.4\n+   */\n+  public boolean isFocusCycleRoot ()\n   {\n-    return false;\n+    return focusCycleRoot;\n   }\n-  \n-  public void transferFocusDownCycle()\n+\n+  /**\n+   * Transfer focus down one focus traversal cycle.  If this Container\n+   * is a focus cycle root, then its default component becomes the\n+   * focus owner, and this Container becomes the current focus cycle\n+   * root.  No traversal will occur if this Container is not a focus\n+   * cycle root.\n+   *\n+   * @since 1.4\n+   */\n+  public void transferFocusDownCycle ()\n   {\n+    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n+\n+    manager.downFocusCycle (this);\n   }\n \n   /**\n@@ -1371,6 +1593,61 @@ private void addNotifyContainerChildren()\n       }\n   }\n \n+  /**\n+   * Deserialize this Container:\n+   * <ol>\n+   * <li>Read from the stream the default serializable fields.</li>\n+   * <li>Read a list of serializable ContainerListeners as optional\n+   * data.  If the list is null, no listeners will be registered.</li>\n+   * <li>Read this Container's FocusTraversalPolicy as optional data.\n+   * If this is null, then this Container will use a\n+   * DefaultFocusTraversalPolicy.</li>\n+   * </ol>\n+   *\n+   * @param s the stream to read from\n+   * @throws ClassNotFoundException if deserialization fails\n+   * @throws IOException if the stream fails\n+   */\n+  private void readObject (ObjectInputStream s)\n+    throws ClassNotFoundException, IOException\n+  {\n+    s.defaultReadObject ();\n+    String key = (String) s.readObject ();\n+    while (key != null)\n+      {\n+        Object object = s.readObject ();\n+        if (\"containerL\".equals (key))\n+          addContainerListener((ContainerListener) object);\n+        // FIXME: under what key is the focus traversal policy stored?\n+        else if (\"focusTraversalPolicy\".equals (key))\n+          setFocusTraversalPolicy ((FocusTraversalPolicy) object);\n+\n+        key = (String) s.readObject();\n+      }\n+  }\n+\n+  /**\n+   * Serialize this Container:\n+   * <ol>\n+   * <li>Write to the stream the default serializable fields.</li>\n+   * <li>Write the list of serializable ContainerListeners as optional\n+   * data.</li>\n+   * <li>Write this Container's FocusTraversalPolicy as optional data.</li>\n+   * </ol>\n+   *\n+   * @param s the stream to write to\n+   * @throws IOException if the stream fails\n+   */\n+  private void writeObject (ObjectOutputStream s) throws IOException\n+  {\n+    s.defaultWriteObject ();\n+    AWTEventMulticaster.save (s, \"containerL\", containerListener);\n+    if (focusTraversalPolicy instanceof Serializable)\n+      s.writeObject (focusTraversalPolicy);\n+    else\n+      s.writeObject (null);\n+  }\n+\n   // Nested classes.\n \n   /* The following classes are used in concert with the"}, {"sha": "fa7ab4ad69a56c2ffc2796bd69c9fb90edf6e564", "filename": "libjava/java/awt/ContainerOrderFocusTraversalPolicy.java", "status": "modified", "additions": 242, "deletions": 33, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FContainerOrderFocusTraversalPolicy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FContainerOrderFocusTraversalPolicy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FContainerOrderFocusTraversalPolicy.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -41,7 +41,23 @@\n import java.io.Serializable;\n \n /**\n+ * ContainerOrderFocusTraversalPolicy defines a focus traversal order\n+ * based on the order in which Components were packed in a Container.\n+ * This policy performs a pre-order traversal of the Component\n+ * hierarchy starting from a given focus cycle root.  Portions of the\n+ * hierarchy that are not visible and displayable are skipped.\n+ *\n+ * By default, this policy transfers focus down-cycle implicitly.\n+ * That is, if a forward traversal is requested on a focus cycle root\n+ * and the focus cycle root has focusable children, the focus will\n+ * automatically be transfered down to the lower focus cycle.\n+ *\n+ * The default implementation of accept accepts only Components that\n+ * are visible, displayable, enabled and focusable.  Derived classes\n+ * can override these acceptance criteria by overriding accept.\n+ *\n  * @author Michael Koch\n+ * @author Thomas Fitzsimmons <fitzsim@redhat.com>\n  * @since 1.4\n  */\n public class ContainerOrderFocusTraversalPolicy extends FocusTraversalPolicy\n@@ -52,12 +68,15 @@ public class ContainerOrderFocusTraversalPolicy extends FocusTraversalPolicy\n    */\n   static final long serialVersionUID = 486933713763926351L;\n \n+  /**\n+   * True if implicit down cycling is enabled.\n+   */\n   private boolean implicitDownCycleTraversal = true;\n \n   /**\n    * Creates the <code>ContainerOrderFocusTraversalPolicy</code> object.\n    */\n-  public ContainerOrderFocusTraversalPolicy()\n+  public ContainerOrderFocusTraversalPolicy ()\n   {\n     // Nothing to do here\n   }\n@@ -66,37 +85,196 @@ public ContainerOrderFocusTraversalPolicy()\n    * Returns the Component that should receive the focus after current.\n    * root must be a focus cycle root of current.\n    *\n+   * @param root a focus cycle root of current\n+   * @param current a (possibly indirect) child of root, or root itself\n+   *\n+   * @return the next Component in the focus traversal order for root,\n+   * or null if no acceptable Component exists.\n+   *\n    * @exception IllegalArgumentException If root is not a focus cycle\n    * root of current, or if either root or current is null.\n    */\n-  public Component getComponentAfter(Container root, Component current)\n+  public Component getComponentAfter (Container root, Component current)\n   {\n-    if (root == null\n-        || current == null)\n-      throw new IllegalArgumentException ();\n-    \n-    return null;\n+    if (root == null)\n+      throw new IllegalArgumentException (\"focus cycle root is null\");\n+    if (current == null)\n+      throw new IllegalArgumentException (\"current component is null\");\n+\n+    if (!root.isFocusCycleRoot ())\n+      throw new IllegalArgumentException (\"root is not a focus cycle root\");\n+\n+    Container ancestor = current.getFocusCycleRootAncestor ();\n+    Container prevAncestor = ancestor;\n+    while (ancestor != root)\n+      {\n+\tancestor = current.getFocusCycleRootAncestor ();\n+\tif (ancestor == prevAncestor)\n+\t  {\n+\t    // We've reached the top focus cycle root ancestor.  Check\n+\t    // if it is root.\n+\t    if (ancestor != root)\n+\t      throw new IllegalArgumentException (\"the given container is not\"\n+\t\t\t\t\t\t  + \" a focus cycle root of the\"\n+\t\t\t\t\t\t  + \" current component\");\n+\t    else\n+\t      break;\n+\t  }\n+\tprevAncestor = ancestor;\n+      }\n+\n+    // FIXME: is this the right thing to do here? It moves the context\n+    // for traversal up one focus traversal cycle.  We'll need a test\n+    // for this.\n+    if ((Component) root == current)\n+      root = current.getFocusCycleRootAncestor ();\n+\n+    // Check if we've reached the top of the component hierarchy.  If\n+    // so then we want to loop around to the first component in the\n+    // focus traversal cycle.\n+    if (current instanceof Window)\n+      return getFirstComponent ((Container) current);\n+\n+    Container parent = current.getParent ();\n+\n+    synchronized (parent.getTreeLock ())\n+      {\n+        Component[] components = parent.getComponents ();\n+        int componentIndex = 0;\n+        int numComponents = parent.getComponentCount ();\n+\n+        // Find component's index.\n+        for (int i = 0; i < numComponents; i++)\n+          {\n+            if (components[i] == current)\n+              componentIndex = i;\n+          }\n+\n+        // Search forward for the next acceptable component.\n+        for (int i = componentIndex + 1; i < numComponents; i++)\n+          {\n+            if (accept (components[i]))\n+              return components[i];\n+\n+            if (components[i] instanceof Container)\n+              {\n+                Component result = getFirstComponent ((Container) components[i]);\n+\n+                if (result != null\n+                    && implicitDownCycleTraversal)\n+                  return result;\n+              }\n+          }\n+\n+        // No focusable components after current in its Container.  So go\n+        // to the next Component after current's Container (parent).\n+        Component result = getComponentAfter (root, parent);\n+\n+        return result;\n+      }\n   }\n \n   /**\n-   * Returns the Component that should receive the focus before current.\n-   * root must be a focus cycle root of current.\n+   * Returns the Component that should receive the focus before\n+   * <code>current</code>.  <code>root</code> must be a focus cycle\n+   * root of current.\n+   *\n+   * @param root a focus cycle root of current\n+   * @param current a (possibly indirect) child of root, or root itself\n+   *\n+   * @return the previous Component in the focus traversal order for\n+   * root, or null if no acceptable Component exists.\n    *\n    * @exception IllegalArgumentException If root is not a focus cycle\n    * root of current, or if either root or current is null.\n    */\n-  public Component getComponentBefore(Container root, Component current)\n+  public Component getComponentBefore (Container root, Component current)\n   {\n-    if (root == null\n-        || current == null)\n-      throw new IllegalArgumentException ();\n+    if (root == null)\n+      throw new IllegalArgumentException (\"focus cycle root is null\");\n+    if (current == null)\n+      throw new IllegalArgumentException (\"current component is null\");\n \n-    return null;\n+    if (!root.isFocusCycleRoot ())\n+      throw new IllegalArgumentException (\"root is not a focus cycle root\");\n+\n+    Container ancestor = current.getFocusCycleRootAncestor ();\n+    Container prevAncestor = ancestor;\n+    while (ancestor != root)\n+      {\n+\tancestor = current.getFocusCycleRootAncestor ();\n+\tif (ancestor == prevAncestor)\n+\t  {\n+\t    // We've reached the top focus cycle root ancestor.  Check\n+\t    // if it is root.\n+\t    if (ancestor != root)\n+\t      throw new IllegalArgumentException (\"the given container is not\"\n+\t\t\t\t\t\t  + \" a focus cycle root of the\"\n+\t\t\t\t\t\t  + \" current component\");\n+\t    else\n+\t      break;\n+\t  }\n+\tprevAncestor = ancestor;\n+      }\n+\n+    // FIXME: is this the right thing to do here? It moves the context\n+    // for traversal up one focus traversal cycle.  We'll need a test\n+    // for this.\n+    if ((Component) root == current)\n+      root = current.getFocusCycleRootAncestor ();\n+\n+    // Check if we've reached the top of the component hierarchy.  If\n+    // so then we want to loop around to the last component in the\n+    // focus traversal cycle.\n+    if (current instanceof Window)\n+      return getLastComponent ((Container) current);\n+\n+    Container parent = current.getParent ();\n+\n+    synchronized (parent.getTreeLock ())\n+      {\n+        Component[] components = parent.getComponents ();\n+        int componentIndex = 0;\n+        int numComponents = parent.getComponentCount ();\n+\n+        // Find component's index.\n+        for (int i = 0; i < numComponents; i++)\n+          {\n+            if (components[i] == current)\n+              componentIndex = i;\n+          }\n+\n+        // Search backward for the next acceptable component.\n+        for (int i = componentIndex - 1; i >= 0; i--)\n+          {\n+            if (accept (components[i]))\n+              return components[i];\n+\n+            if (components[i] instanceof Container)\n+              {\n+                Component result = getLastComponent ((Container) components[i]);\n+\n+                if (result != null)\n+                  return result;\n+              }\n+          }\n+\n+        // No focusable components before current in its Container.  So go\n+        // to the previous Component before current's Container (parent).\n+        Component result = getComponentBefore (root, parent);\n+\n+        return result;\n+      }\n   }\n \n   /**\n    * Returns the first Component of root that should receive the focus.\n    *\n+   * @param root a focus cycle root\n+   *\n+   * @return the first Component in the focus traversal order for\n+   * root, or null if no acceptable Component exists.\n+   *\n    * @exception IllegalArgumentException If root is null.\n    */\n   public Component getFirstComponent(Container root)\n@@ -117,18 +295,16 @@ public Component getFirstComponent(Container root)\n       {\n         Component component = componentArray [i];\n \t\n+\tif (accept (component))\n+\t  return component;\n+\n         if (component instanceof Container)\n           {\n-            Component result = getLastComponent ((Container) component);\n+            Component result = getFirstComponent ((Container) component);\n \n             if (result != null)\n               return result;\n           }\n-        else\n-          {\n-            if (accept (component))\n-              return component;\n-          }\n       }\n \n     return null;\n@@ -137,9 +313,14 @@ public Component getFirstComponent(Container root)\n   /**\n    * Returns the last Component of root that should receive the focus.\n    *\n+   * @param root a focus cycle root\n+   *\n+   * @return the last Component in the focus traversal order for\n+   * root, or null if no acceptable Component exists.\n+   *\n    * @exception IllegalArgumentException If root is null.\n    */\n-  public Component getLastComponent(Container root)\n+  public Component getLastComponent (Container root)\n   {\n     if (root == null)\n       throw new IllegalArgumentException ();\n@@ -153,22 +334,20 @@ public Component getLastComponent(Container root)\n \n     Component[] componentArray = root.getComponents ();\n     \n-    for (int i = componentArray.length - 1; i >= 0; i++)\n+    for (int i = componentArray.length - 1; i >= 0; i--)\n       {\n         Component component = componentArray [i];\n \t\n+\tif (accept (component))\n+\t  return component;\n+\n         if (component instanceof Container)\n           {\n             Component result = getLastComponent ((Container) component);\n \n             if (result != null)\n               return result;\n           }\n-        else\n-          {\n-            if (accept (component))\n-              return component;\n-          }\n       }\n \n     return null;\n@@ -177,28 +356,58 @@ public Component getLastComponent(Container root)\n   /**\n    * Returns the default Component of root that should receive the focus.\n    *\n+   * @param root a focus cycle root\n+   *\n+   * @return the default Component in the focus traversal order for\n+   * root, or null if no acceptable Component exists.\n+   *\n    * @exception IllegalArgumentException If root is null.\n    */\n-  public Component getDefaultComponent(Container root)\n+  public Component getDefaultComponent (Container root)\n   {\n     return getFirstComponent (root);\n   }\n \n-  public void setImplicitDownCycleTraversal(boolean value)\n+  /**\n+   * Set whether or not implicit down cycling is enabled.  If it is,\n+   * then initiating a forward focus traversal operation onto a focus\n+   * cycle root, the focus will be implicitly transferred into the\n+   * root container's focus cycle.\n+   *\n+   * @param value the setting for implicit down cycling\n+   */\n+  public void setImplicitDownCycleTraversal (boolean value)\n   {\n     implicitDownCycleTraversal = value;\n   }\n \n-  public boolean getImplicitDownCycleTraversal()\n+  /**\n+   * Check whether or not implicit down cycling is enabled.  If it is,\n+   * then initiating a forward focus traversal operation onto a focus\n+   * cycle root, the focus will be implicitly transferred into the\n+   * root container's focus cycle.\n+   *\n+   * @return true if the focus will be transferred down-cycle\n+   * implicitly\n+   */\n+  public boolean getImplicitDownCycleTraversal ()\n   {\n     return implicitDownCycleTraversal;\n   }\n \n-  protected boolean accept(Component current)\n+  /**\n+   * Check whether the given Component is an acceptable target for the\n+   * keyboard input focus.\n+   *\n+   * @param current the Component to check\n+   *\n+   * @return true if current is acceptable, false otherwise\n+   */\n+  protected boolean accept (Component current)\n   {\n     return (current.visible\n-            && current.isDisplayable()\n+            && current.isDisplayable ()\n             && current.enabled\n             && current.focusable);\n   }\n-} // class ContainerOrderFocusTraversalPolicy\n+}"}, {"sha": "73b1e95a9a47237b3809398c411190e0c123fc75", "filename": "libjava/java/awt/DefaultFocusTraversalPolicy.java", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FDefaultFocusTraversalPolicy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FDefaultFocusTraversalPolicy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FDefaultFocusTraversalPolicy.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -39,17 +39,73 @@\n package java.awt;\n \n /**\n- * STUB CLASS ONLY\n+ * DefaultFocusTraversalPolicy is the default focus traversal policy\n+ * used by Containers.\n+ *\n+ * This policy sharpens ContainerOrderFocusTraversalPolicy's\n+ * acceptance criteria, to reject those Components that have\n+ * unfocusable peers.  Despite this extra strictness, this policy will\n+ * always accept a Component that has explicitly been set focusable by\n+ * any means.\n+ *\n+ * This AWT implementation assumes that the peers of the following\n+ * Components are not focusable: Canvas, Panel, Label, ScrollPane,\n+ * Scrollbar, Window, and any lightweight Component.\n+ *\n+ * A Component's focusability is independent of the focusability of\n+ * its peer.\n+ *\n+ * @author Thomas Fitzsimmons <fitzsim@redhat.com>\n+ * @since 1.4\n  */\n public class DefaultFocusTraversalPolicy\n   extends ContainerOrderFocusTraversalPolicy\n {\n-  public DefaultFocusTraversalPolicy()\n+  /**\n+   * Construct a default focus traversal policy.\n+   */\n+  public DefaultFocusTraversalPolicy ()\n   {\n   }\n \n-  protected boolean accept(Component comp)\n+  /**\n+   * Check whether a given Component would be acceptable as a focus\n+   * owner.  The Component must be displayable, visible and enabled to\n+   * be acceptable.  If the Component's focus traversability has been\n+   * overridden, by overriding Component.isFocusTraversable or\n+   * Component.isFocusable, or by calling Component.setFocusable, then\n+   * the Component will be accepted if it is focusable.  If the\n+   * Component uses the default focus traversable behaviour, then\n+   * <code>comp</code> will always be rejected if it is a Canvas,\n+   * Panel, Label, ScrollPane, Scrollbar, Window or lightweight\n+   * Component.\n+   *\n+   * @param comp the Component to check\n+   *\n+   * @return true if the Component is an acceptable target for\n+   * keyboard input focus, false otherwise\n+   */\n+  protected boolean accept (Component comp)\n   {\n-    throw new Error(\"not implemented\");\n+    if (comp.visible\n+\t&& comp.isDisplayable ()\n+\t&& comp.enabled)\n+      {\n+\tif (comp.isFocusTraversableOverridden != 0\n+\t    && comp.isFocusTraversable ())\n+\t  return true;\n+\telse\n+\t  {\n+\t    if (!(comp instanceof Canvas\n+\t\t  || comp instanceof Panel\n+\t\t  || comp instanceof Label\n+\t\t  || comp instanceof ScrollPane\n+\t\t  || comp instanceof Scrollbar\n+\t\t  || comp instanceof Window\n+\t\t  || comp.isLightweight ()))\n+\t      return true;\n+\t  }\n+      }\n+    return false;\n   }\n-} // class DefaultFocusTraversalPolicy\n+}"}, {"sha": "79a986974307c3138508d76a836927784fe59d52", "filename": "libjava/java/awt/DefaultKeyboardFocusManager.java", "status": "modified", "additions": 391, "deletions": 27, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FDefaultKeyboardFocusManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FDefaultKeyboardFocusManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FDefaultKeyboardFocusManager.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -38,59 +38,423 @@\n \n package java.awt;\n \n-import java.awt.event.KeyEvent;\n+import java.util.*;\n+import java.awt.event.*;\n \n-/**\n- * STUB CLASS ONLY\n- */\n+// FIXME: finish documentation\n public class DefaultKeyboardFocusManager extends KeyboardFocusManager\n {\n-  public DefaultKeyboardFocusManager()\n+  /**\n+   * This class models a request to delay the dispatch of events that\n+   * arrive after a certain time, until a certain component becomes\n+   * the focus owner.\n+   */\n+  private class EventDelayRequest implements Comparable\n   {\n+    /** A {@link java.util.List} of {@link java.awt.event.KeyEvent}s\n+        that are being delayed, pending this request's {@link\n+        Component} receiving the keyboard focus. */\n+    private LinkedList enqueuedKeyEvents = new LinkedList ();\n+\n+    /** An event timestamp.  All events that arrive after this time\n+        should be queued in the {@link #enqueuedKeyEvents} {@link\n+        java.util.List}. */\n+    public long timestamp;\n+    /** When this {@link Component} becomes focused, all events\n+        between this EventDelayRequest and the next one in will be\n+        dispatched from {@link #enqueuedKeyEvents}. */\n+    public Component focusedComp;\n+\n+    /**\n+     * Construct a new EventDelayRequest.\n+     *\n+     * @param timestamp events that arrive after this time will be\n+     * delayed\n+     * @param focusedComp the Component that needs to receive focus\n+     * before events are dispatched\n+     */\n+    public EventDelayRequest (long timestamp, Component focusedComp)\n+    {\n+      this.timestamp = timestamp;\n+      this.focusedComp = focusedComp;\n+    }\n+\n+    public int compareTo (Object o)\n+    {\n+      if (!(o instanceof EventDelayRequest))\n+        throw new ClassCastException ();\n+\n+      EventDelayRequest request = (EventDelayRequest) o;\n+\n+      if (request.timestamp < timestamp)\n+        return -1;\n+      else if (request.timestamp == timestamp)\n+        return 0;\n+      else\n+        return 1;\n+    }\n+\n+    public boolean equals (Object o)\n+    {\n+      if (!(o instanceof EventDelayRequest) || o == null)\n+        return false;\n+\n+      EventDelayRequest request = (EventDelayRequest) o;\n+\n+      return (request.timestamp == timestamp\n+              && request.focusedComp == focusedComp);\n+    }\n+\n+    public void enqueueEvent (KeyEvent e)\n+    {\n+      KeyEvent last = (KeyEvent) enqueuedKeyEvents.getLast ();\n+      if (last != null && e.getWhen () < last.getWhen ())\n+        throw new RuntimeException (\"KeyEvents enqueued out-of-order\");\n+\n+      if (e.getWhen () <= timestamp)\n+        throw new RuntimeException (\"KeyEvents enqueued before starting timestamp\");\n+\n+      enqueuedKeyEvents.add (e);\n+    }\n+\n+    public void dispatchEvents ()\n+    {\n+      int size = enqueuedKeyEvents.size ();\n+      for (int i = 0; i < size; i++)\n+        {\n+          KeyEvent e = (KeyEvent) enqueuedKeyEvents.remove (0);\n+          dispatchKeyEvent (e);\n+        }\n+    }\n+\n+    public void discardEvents ()\n+    {\n+      enqueuedKeyEvents.clear ();\n+    }\n   }\n \n-  public boolean dispatchEvent(AWTEvent e)\n+  /** The {@link java.util.SortedSet} of current {@link\n+      #EventDelayRequest}s. */\n+  private SortedSet delayRequests = new TreeSet ();\n+\n+  public DefaultKeyboardFocusManager ()\n   {\n-    throw new Error(\"not implemented\");\n   }\n-  public boolean dispatchKeyEvent(KeyEvent e)\n+\n+  public boolean dispatchEvent (AWTEvent e)\n   {\n-    throw new Error(\"not implemented\");\n+    if (e instanceof WindowEvent)\n+      {\n+        Window target = (Window) e.getSource ();\n+\n+        if (e.id == WindowEvent.WINDOW_ACTIVATED)\n+          setGlobalActiveWindow (target);\n+        else if (e.id == WindowEvent.WINDOW_GAINED_FOCUS)\n+          setGlobalFocusedWindow (target);\n+        else if (e.id != WindowEvent.WINDOW_LOST_FOCUS\n+                 && e.id != WindowEvent.WINDOW_DEACTIVATED)\n+          return false;\n+\n+        target.dispatchEvent (e);\n+        return true;\n+      }\n+    else if (e instanceof FocusEvent)\n+      {\n+        Component target = (Component) e.getSource ();\n+\n+        if (e.id == FocusEvent.FOCUS_GAINED\n+            && !(target instanceof Window))\n+          {\n+            if (((FocusEvent) e).isTemporary ())\n+              setGlobalFocusOwner (target);\n+            else\n+              setGlobalPermanentFocusOwner (target);\n+          }\n+\n+        if (!(target instanceof Window))\n+          target.dispatchEvent (e);\n+\n+        return true;\n+      }\n+    else if (e instanceof KeyEvent)\n+      {\n+        // Loop through all registered KeyEventDispatchers, giving\n+        // each a chance to handle this event.\n+        Iterator i = keyEventDispatchers.iterator ();\n+\n+        while (i.hasNext ())\n+          {\n+            KeyEventDispatcher dispatcher = (KeyEventDispatcher) i.next ();\n+            if (dispatcher.dispatchKeyEvent ((KeyEvent) e))\n+              return true;\n+          }\n+\n+        // processKeyEvent checks if this event represents a focus\n+        // traversal key stroke.\n+        Component focusOwner = getGlobalPermanentFocusOwner ();\n+        processKeyEvent (focusOwner, (KeyEvent) e);\n+\n+        if (e.isConsumed ())\n+          return true;\n+\n+        if (enqueueKeyEvent ((KeyEvent) e))\n+          // This event was enqueued for dispatch at a later time.\n+          return true;\n+        else\n+          // This event wasn't handled by any of the registered\n+          // KeyEventDispatchers, and wasn't enqueued for dispatch\n+          // later, so send it to the default dispatcher.\n+          return dispatchKeyEvent ((KeyEvent) e);\n+      }\n+\n+    return false;\n   }\n-  public boolean postProcessKeyEvent(KeyEvent e)\n+\n+  private boolean enqueueKeyEvent (KeyEvent e)\n   {\n-    throw new Error(\"not implemented\");\n+    Iterator i = delayRequests.iterator ();\n+    boolean oneEnqueued = false;\n+    while (i.hasNext ())\n+      {\n+        EventDelayRequest request = (EventDelayRequest) i.next ();\n+        if (e.getWhen () > request.timestamp)\n+          {\n+            request.enqueueEvent (e);\n+            oneEnqueued = true;\n+          }\n+      }\n+    return oneEnqueued;\n   }\n-  public void processKeyEvent(Component comp, KeyEvent e)\n+\n+  public boolean dispatchKeyEvent (KeyEvent e)\n   {\n-    throw new Error(\"not implemented\");\n+    Component focusOwner = getGlobalPermanentFocusOwner ();\n+\n+    focusOwner.dispatchEvent (e);\n+\n+    // Loop through all registered KeyEventPostProcessors, giving\n+    // each a chance to process this event.\n+    Iterator i = keyEventPostProcessors.iterator ();\n+\n+    while (i.hasNext ())\n+      {\n+        KeyEventPostProcessor processor = (KeyEventPostProcessor) i.next ();\n+        if (processor.postProcessKeyEvent ((KeyEvent) e))\n+          return true;\n+      }\n+\n+    // The event hasn't been consumed yet.  Check if it is an\n+    // MenuShortcut.\n+    if (postProcessKeyEvent (e))\n+      return true;\n+\n+    // Always return true.\n+    return true;\n   }\n-  protected void enqueueKeyEvents(long after, Component comp)\n+\n+  public boolean postProcessKeyEvent (KeyEvent e)\n+  {\n+    // Check if this event represents a menu shortcut.\n+\n+    // MenuShortcuts are activated by Ctrl- KeyEvents.\n+    int modifiers = e.getModifiers ();\n+    if ((modifiers & KeyEvent.CTRL_MASK) != 0\n+        || (modifiers & KeyEvent.CTRL_DOWN_MASK) != 0)\n+      {\n+        Window focusedWindow = getGlobalFocusedWindow ();\n+        if (focusedWindow instanceof Frame)\n+          {\n+            MenuBar menubar = ((Frame) focusedWindow).getMenuBar ();\n+\n+            if (menubar != null)\n+              {\n+                // If there's a menubar, loop through all menu items,\n+                // checking whether each one has a shortcut, and if\n+                // so, whether this key event should activate it.\n+                int numMenus = menubar.getMenuCount ();\n+\n+                for (int i = 0; i < numMenus; i++)\n+                  {\n+                    Menu menu = menubar.getMenu (i);\n+                    int numItems = menu.getItemCount ();\n+\n+                    for (int j = 0; j < numItems; j++)\n+                      {\n+                        MenuItem item = menu.getItem (j);\n+                        MenuShortcut shortcut = item.getShortcut ();\n+\n+                        if (shortcut != null)\n+                          {\n+                            // Dispatch a new ActionEvent if this is a\n+                            // Shift- KeyEvent and the shortcut requires\n+                            // the Shift modifier, or if the shortcut\n+                            // doesn't require the Shift modifier.\n+                            if ((shortcut.usesShiftModifier ()\n+                                 && ((modifiers & KeyEvent.SHIFT_MASK) != 0\n+                                     || (modifiers & KeyEvent.SHIFT_DOWN_MASK) != 0)\n+                                 || !shortcut.usesShiftModifier ())\n+                                && shortcut.getKey () == e.getKeyCode ())\n+                              {\n+                                item.dispatchEvent (new ActionEvent (item,\n+                                                                     ActionEvent.ACTION_PERFORMED,\n+                                                                     item.getActionCommand (),\n+                                                                     modifiers));\n+                                // The event was dispatched.\n+                                return true;\n+                              }\n+                          }\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+    return false;\n+  }\n+\n+  public void processKeyEvent (Component comp, KeyEvent e)\n+  {\n+    AWTKeyStroke eventKeystroke = AWTKeyStroke.getAWTKeyStrokeForEvent (e);\n+    // For every focus traversal keystroke, we need to also consume\n+    // the other two key event types for the same key (e.g. if\n+    // KEY_PRESSED TAB is a focus traversal keystroke, we also need to\n+    // consume KEY_RELEASED and KEY_TYPED TAB key events).\n+    AWTKeyStroke oppositeKeystroke = AWTKeyStroke.getAWTKeyStroke (e.getKeyCode (),\n+                                                                   e.getModifiers (),\n+                                                                   !(e.id == KeyEvent.KEY_RELEASED));\n+\n+    Set forwardKeystrokes = comp.getFocusTraversalKeys (KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS);\n+    Set backwardKeystrokes = comp.getFocusTraversalKeys (KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS);\n+    Set upKeystrokes = comp.getFocusTraversalKeys (KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS);\n+    Set downKeystrokes = null;\n+    if (comp instanceof Container)\n+      downKeystrokes = comp.getFocusTraversalKeys (KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS);\n+\n+    if (forwardKeystrokes.contains (eventKeystroke))\n+      {\n+        focusNextComponent (comp);\n+        e.consume ();\n+      }\n+    else if (backwardKeystrokes.contains (eventKeystroke))\n+      {\n+        focusPreviousComponent (comp);\n+        e.consume ();\n+      }\n+    else if (upKeystrokes.contains (eventKeystroke))\n+      {\n+        upFocusCycle (comp);\n+        e.consume ();\n+      }\n+    else if (comp instanceof Container\n+             && downKeystrokes.contains (eventKeystroke))\n+      {\n+        downFocusCycle ((Container) comp);\n+        e.consume ();\n+      }\n+    else if (forwardKeystrokes.contains (oppositeKeystroke)\n+             || backwardKeystrokes.contains (oppositeKeystroke)\n+             || upKeystrokes.contains (oppositeKeystroke)\n+             || (comp instanceof Container &&\n+                 downKeystrokes.contains (oppositeKeystroke)))\n+      e.consume ();\n+  }\n+\n+  protected void enqueueKeyEvents (long after, Component untilFocused)\n   {\n-    throw new Error(\"not implemented\");\n+    delayRequests.add (new EventDelayRequest (after, untilFocused));\n   }\n-  protected void dequeueKeyEvents(long after, Component comp)\n+\n+  protected void dequeueKeyEvents (long after, Component untilFocused)\n   {\n-    throw new Error(\"not implemented\");\n+    // FIXME: need synchronization on delayRequests and enqueuedKeyEvents.\n+\n+    // Remove the KeyEvent with the oldest timestamp, which should be\n+    // the first element in the SortedSet.\n+    if (after < 0)\n+      {\n+        int size = delayRequests.size ();\n+        if (size > 0)\n+          delayRequests.remove (delayRequests.first ());\n+      }\n+    else\n+      {\n+        EventDelayRequest template = new EventDelayRequest (after, untilFocused);\n+        if (delayRequests.contains (template))\n+          {\n+            EventDelayRequest actual = (EventDelayRequest) delayRequests.tailSet (template).first ();\n+            delayRequests.remove (actual);\n+            actual.dispatchEvents ();\n+          }\n+      }\n   }\n-  protected void discardKeyEvents(Component comp)\n+\n+  protected void discardKeyEvents (Component comp)\n   {\n-    throw new Error(\"not implemented\");\n+    // FIXME: need synchronization on delayRequests and enqueuedKeyEvents.\n+\n+    Iterator i = delayRequests.iterator ();\n+\n+    while (i.hasNext ())\n+      {\n+        EventDelayRequest request = (EventDelayRequest) i.next ();\n+\n+        if (request.focusedComp == comp\n+            || (comp instanceof Container\n+                && ((Container) comp).isAncestorOf (request.focusedComp)))\n+          request.discardEvents ();\n+      }\n   }\n-  public void focusPreviousComponent(Component comp)\n+\n+  public void focusPreviousComponent (Component comp)\n   {\n-    throw new Error(\"not implemented\");\n+    Component focusComp = (comp == null) ? getGlobalFocusOwner () : comp;\n+    Container focusCycleRoot = focusComp.getFocusCycleRootAncestor ();\n+    FocusTraversalPolicy policy = focusCycleRoot.getFocusTraversalPolicy ();\n+\n+    Component previous = policy.getComponentBefore (focusCycleRoot, focusComp);\n+    previous.requestFocusInWindow ();\n   }\n-  public void focusNextComponent(Component comp)\n+\n+  public void focusNextComponent (Component comp)\n   {\n-    throw new Error(\"not implemented\");\n+    Component focusComp = (comp == null) ? getGlobalFocusOwner () : comp;\n+    Container focusCycleRoot = focusComp.getFocusCycleRootAncestor ();\n+    FocusTraversalPolicy policy = focusCycleRoot.getFocusTraversalPolicy ();\n+\n+    Component next = policy.getComponentAfter (focusCycleRoot, focusComp);\n+    next.requestFocusInWindow ();\n   }\n-  public void upFocusCycle(Component comp)\n+\n+  public void upFocusCycle (Component comp)\n   {\n-    throw new Error(\"not implemented\");\n+    Component focusComp = (comp == null) ? getGlobalFocusOwner () : comp;\n+    Container focusCycleRoot = focusComp.getFocusCycleRootAncestor ();\n+\n+    if (focusCycleRoot instanceof Window)\n+      {\n+        FocusTraversalPolicy policy = focusCycleRoot.getFocusTraversalPolicy ();\n+        Component defaultComponent = policy.getDefaultComponent (focusCycleRoot);\n+        defaultComponent.requestFocusInWindow ();\n+      }\n+    else\n+      {\n+        Container parentFocusCycleRoot = focusCycleRoot.getFocusCycleRootAncestor ();\n+\n+        focusCycleRoot.requestFocusInWindow ();\n+        setGlobalCurrentFocusCycleRoot (parentFocusCycleRoot);\n+      }\n   }\n-  public void downFocusCycle(Container cont)\n+\n+  public void downFocusCycle (Container cont)\n   {\n-    throw new Error(\"not implemented\");\n+    if (cont == null)\n+      return;\n+\n+    if (cont.isFocusCycleRoot (cont))\n+      {\n+        FocusTraversalPolicy policy = cont.getFocusTraversalPolicy ();\n+        Component defaultComponent = policy.getDefaultComponent (cont);\n+        defaultComponent.requestFocusInWindow ();\n+        setGlobalCurrentFocusCycleRoot (cont);\n+      }\n   }\n } // class DefaultKeyboardFocusManager"}, {"sha": "89b6095578f110bc5debe8b1af1937e045194809", "filename": "libjava/java/awt/EventDispatchThread.java", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FEventDispatchThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FEventDispatchThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FEventDispatchThread.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -67,7 +67,17 @@ public void run()\n \t      // We are interrupted when we should finish executing\n \t      return;\n \t    }\n-\t  queue.dispatchEvent(evt);\n+\n+          KeyboardFocusManager manager;\n+          manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n+\n+          // Try to dispatch this event to the current keyboard focus\n+          // manager.  It will dispatch all FocusEvents, all\n+          // WindowEvents related to focus, and all KeyEvents,\n+          // returning true.  Otherwise, it returns false and we\n+          // dispatch the event normally.\n+          if (!manager.dispatchEvent (evt))\n+            queue.dispatchEvent(evt);\n \t}\n \tcatch (InterruptedException ie)\n \t{"}, {"sha": "451b092e6de95424cc98648437f6d4c896229fab", "filename": "libjava/java/awt/Image.java", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FImage.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -39,6 +39,7 @@\n package java.awt;\n \n import java.awt.image.AreaAveragingScaleFilter;\n+import java.awt.image.FilteredImageSource;\n import java.awt.image.ImageObserver;\n import java.awt.image.ImageProducer;\n import java.awt.image.ReplicateScaleFilter;\n@@ -179,7 +180,20 @@ public Image()\n    */\n   public Image getScaledInstance(int width, int height, int flags)\n   {\n-    throw new Error(\"not implemented\");\n+    switch (flags)\n+    {\n+      case SCALE_DEFAULT:\n+      case SCALE_FAST:\n+      case SCALE_REPLICATE:\n+        ImageProducer producer =\n+          new FilteredImageSource(this.getSource(),\n+                                  new ReplicateScaleFilter(width, height));\n+        return Toolkit.getDefaultToolkit().createImage(producer);\n+      case SCALE_SMOOTH:\n+      case SCALE_AREA_AVERAGING:\n+      default:\n+        throw new Error(\"not implemented\");\n+    }\n   }\n \n   /**"}, {"sha": "8ebd9e1713cb1356b35329e59d5c3e2674eb94f5", "filename": "libjava/java/awt/KeyboardFocusManager.java", "status": "modified", "additions": 579, "deletions": 228, "changes": 807, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FKeyboardFocusManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FKeyboardFocusManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FKeyboardFocusManager.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -39,34 +39,66 @@\n package java.awt;\n \n import java.awt.event.KeyEvent;\n+import java.awt.event.FocusEvent;\n import java.beans.PropertyChangeListener;\n import java.beans.PropertyChangeSupport;\n import java.beans.PropertyVetoException;\n import java.beans.VetoableChangeListener;\n import java.beans.VetoableChangeSupport;\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n+// FIXME: finish documentation\n+\n /**\n+ *\n+ * FIXME: discuss applet contexts and thread groups and codebases\n+ * being insulated.\n+ *\n+ * FIXME: discuss where default focus traversal key sets apply\n+ * (inherited by child Components etc.)\n  *\n  * @author Eric Blake <ebb9@email.byu.edu>\n+ * @author Thomas Fitzsimmons <fitzsim@redhat.com>\n  * @since 1.4\n  * @status partially updated to 1.4, needs documentation.\n  */\n public abstract class KeyboardFocusManager\n   implements KeyEventDispatcher, KeyEventPostProcessor\n {\n+  /** Identifies {@link AWTKeyStroke}s that move the focus forward in\n+      the focus cycle. */\n   public static final int FORWARD_TRAVERSAL_KEYS = 0;\n+\n+  /** Identifies {@link AWTKeyStroke}s that move the focus backward in\n+      the focus cycle. */\n   public static final int BACKWARD_TRAVERSAL_KEYS = 1;\n+\n+  /** Identifies {@link AWTKeyStroke}s that move the focus up to the\n+      parent focus cycle root. */\n   public static final int UP_CYCLE_TRAVERSAL_KEYS = 2;\n+\n+  /** Identifies {@link AWTKeyStroke}s that move the focus down to the\n+      child focus cycle root. */\n   public static final int DOWN_CYCLE_TRAVERSAL_KEYS = 3;\n \n+  /** The set of {@link AWTKeyStroke}s that cause focus to be moved to\n+      the next focusable Component in the focus cycle. */\n   private static final Set DEFAULT_FORWARD_KEYS;\n+\n+  /** The set of {@link AWTKeyStroke}s that cause focus to be moved to\n+      the previous focusable Component in the focus cycle. */\n   private static final Set DEFAULT_BACKWARD_KEYS;\n+\n+  /** Populate the DEFAULT_FORWARD_KEYS and DEFAULT_BACKWARD_KEYS\n+      {@link java.util.Set}s. */\n   static\n   {\n     Set s = new HashSet();\n@@ -83,232 +115,402 @@\n     DEFAULT_BACKWARD_KEYS = Collections.unmodifiableSet(s);\n   }\n \n-  private static KeyboardFocusManager current\n-    = new DefaultKeyboardFocusManager();\n-\n-  // XXX Not implemented correctly. I think a good implementation here may\n-  // be to have permanentFocusOwner be null, and fall back to focusOwner,\n-  // unless a temporary focus change is in effect.\n-  private static Component focusOwner;\n-  private static Component permanentFocusOwner;\n-\n-  private static Window focusedWindow;\n-  private static Window activeWindow;\n-  private static Container focusCycleRoot;\n-\n+  /** The global object {@link java.util.Map}s. */\n+\n+  /** For security reasons, {@link java.applet.Applet}s in different\n+      codebases must be insulated from one another.  Since {@link\n+      KeyboardFocusManager}s have the ability to return {@link\n+      Component}s from a given {@link java.applet.Applet}, each\n+      codebase must have an independent {@link KeyboardFocusManager}.\n+      Since each codebase has its own {@link ThreadGroup} in which its\n+      {@link Applet}s run, it makes sense to partition {@link\n+      KeyboardFocusManager}s according to {@link\n+      java.lang.ThreadGroup}.  Thus, currentKeyboardFocusManagers is a\n+      {@link java.util.Map} keyed on {@link java.lang.ThreadGroup}. */\n+  private static Map currentKeyboardFocusManagers = new HashMap ();\n+\n+  /** {@link java.applet.Applet}s in one codebase must not be allowed\n+      to access {@link Component}s in {@link java.applet.Applet}s in\n+      other codebases.  To enforce this restriction, we key the\n+      following {@link java.util.Map}s on {@link java.lang.ThreadGroup}s (which\n+      are per-codebase).  For example, if {@link\n+      java.lang.ThreadGroup} A calls {@link #setGlobalFocusOwner},\n+      passing {@link Component} C, currentFocusOwners[A] is assigned\n+      C, and all other currentFocusOwners values are nullified.  Then\n+      if {@link java.lang.ThreadGroup} A subsequently calls {@link\n+      #getGlobalFocusOwner}, it will return currentFocusOwners[A],\n+      that is, {@link Component} C.  If another {@link\n+      java.lang.ThreadGroup} K calls {@link #getGlobalFocusOwner}, it\n+      will return currentFocusOwners[K], that is, null.\n+\n+      Since this is a static field, we ensure that there is only one\n+      focused {@link Component} per class loader. */\n+  private static Map currentFocusOwners = new HashMap ();\n+\n+  /** A {@link java.util.Map} keyed on {@link java.lang.ThreadGroup}s\n+      that stores the {@link Component} that owns the permanent\n+      keyboard focus. @see currentFocusOwners */\n+  private static Map currentPermanentFocusOwners = new HashMap ();\n+\n+  /** A {@link java.util.Map} keyed on {@link java.lang.ThreadGroup}s\n+      that stores the focused {@link Window}. @see\n+      currentFocusOwners */\n+  private static Map currentFocusedWindows = new HashMap ();\n+\n+  /** A {@link java.util.Map} keyed on {@link java.lang.ThreadGroup}s\n+      that stores the active {@link Window}. @see\n+      currentFocusOwners */\n+  private static Map currentActiveWindows = new HashMap ();\n+\n+  /** A {@link java.util.Map} keyed on {@link java.lang.ThreadGroup}s\n+      that stores the focus cycle root {@link Container}. @see\n+      currentFocusOwners */\n+  private static Map currentFocusCycleRoots = new HashMap ();\n+\n+  /** The default {@link FocusTraveralPolicy} that focus-managing\n+      {@link Container}s will use to define their initial focus\n+      traversal policy. */\n   private FocusTraversalPolicy defaultPolicy;\n-  private Set[] defaultFocusKeys = new Set[] {\n+\n+  /** An array that stores the {@link #FORWARD_TRAVERSAL_KEYS}, {@link\n+      #BACKWARD_TRAVERSAL_KEYS}, {@link #UP_CYCLE_TRAVERSAL_KEYS} and\n+      {@link #DOWN_CYCLE_TRAVERSAL_KEYS} {@link AWTKeyStroke}s {@link\n+      java.util.Set}s. */\n+  private Set[] defaultFocusKeys = new Set[]\n+  {\n     DEFAULT_FORWARD_KEYS, DEFAULT_BACKWARD_KEYS,\n     Collections.EMPTY_SET, Collections.EMPTY_SET\n   };\n \n-  private final PropertyChangeSupport propertyChangeSupport\n-    = new PropertyChangeSupport(this);\n-  private final VetoableChangeSupport vetoableChangeSupport\n-    = new VetoableChangeSupport(this);\n+  private final PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport (this);\n+  private final VetoableChangeSupport vetoableChangeSupport = new VetoableChangeSupport (this);\n+\n+  /** A list of {@link KeyEventDispatcher}s that process {@link\n+      KeyEvent}s before they are processed the default keyboard focus\n+      manager. */\n   private final ArrayList keyEventDispatchers = new ArrayList();\n+\n+  /** A list of {@link KeyEventPostProcessor}s that process unconsumed\n+      {@link KeyEvent}s. */\n   private final ArrayList keyEventPostProcessors = new ArrayList();\n \n-\f\n-  public KeyboardFocusManager()\n+  /**\n+   * Construct a KeyboardFocusManager.\n+   */\n+  public KeyboardFocusManager ()\n   {\n   }\n \n-  public static KeyboardFocusManager getCurrentKeyboardFocusManager()\n+  /**\n+   * Retrieve the keyboard focus manager associated with the {@link\n+   * java.lang.ThreadGroup} to which the calling thread belongs.\n+   *\n+   * @return the keyboard focus manager associated with the current\n+   * thread group\n+   */\n+  public static KeyboardFocusManager getCurrentKeyboardFocusManager ()\n   {\n-    // XXX Need a way to divide this into contexts.\n-    return current;\n+    ThreadGroup currentGroup = Thread.currentThread ().getThreadGroup ();\n+    return (KeyboardFocusManager) currentKeyboardFocusManagers.get (currentGroup);\n   }\n \n-  public static void setCurrentKeyboardFocusManager(KeyboardFocusManager m)\n+  /**\n+   * Set the keyboard focus manager associated with the {@link\n+   * java.lang.ThreadGroup} to which the calling thread belongs.\n+   *\n+   * @param m the keyboard focus manager for the current thread group\n+   */\n+  public static void setCurrentKeyboardFocusManager (KeyboardFocusManager m)\n   {\n-    SecurityManager sm = System.getSecurityManager();\n+    SecurityManager sm = System.getSecurityManager ();\n     if (sm != null)\n-      sm.checkPermission(new AWTPermission(\"replaceKeyboardFocusManager\"));\n-    // XXX Need a way to divide this into contexts.\n-    current = m == null ? new DefaultKeyboardFocusManager() : m;\n-  }\n-\n-  public Component getFocusOwner()\n+      sm.checkPermission (new AWTPermission (\"replaceKeyboardFocusManager\"));\n+\n+    ThreadGroup currentGroup = Thread.currentThread ().getThreadGroup ();\n+    KeyboardFocusManager manager;\n+\n+    if (m == null)\n+      manager = new DefaultKeyboardFocusManager ();\n+    else\n+      manager = m;\n+\n+    currentKeyboardFocusManagers.put (currentGroup, manager);\n+  }\n+\n+  /**\n+   * Retrieve the {@link Component} that has the keyboard focus, or\n+   * null if the focus owner was not set by a thread in the current\n+   * {@link java.lang.ThreadGroup}.\n+   *\n+   * @return the keyboard focus owner or null\n+   */\n+  public Component getFocusOwner ()\n+  {\n+    return (Component) getObject (currentFocusOwners);\n+  }\n+\n+  /**\n+   * Retrieve the {@link Component} that has the keyboard focus,\n+   * regardless of whether or not it was set by a thread in the\n+   * current {@link java.lang.ThreadGroup}.  If there is no temporary\n+   * focus owner in effect then this method will return the same value\n+   * as {@link #getGlobalPermanentFocusOwner}.\n+   *\n+   * @return the keyboard focus owner\n+   * @throws SecurityException if this is not the keyboard focus\n+   * manager associated with the current {@link java.lang.ThreadGroup}\n+   */\n+  protected Component getGlobalFocusOwner ()\n+  {\n+    // Check if there is a temporary focus owner.\n+    Component focusOwner = (Component) getGlobalObject (currentFocusOwners);\n+\n+    return (focusOwner == null) ? getGlobalPermanentFocusOwner () : focusOwner;\n+  }\n+\n+  /**\n+   * Set the {@link Component} that will be returned by {@link\n+   * #getFocusOwner} (when it is called from the current {@link\n+   * java.lang.ThreadGroup}) and {@link #getGlobalFocusOwner}.  This\n+   * method does not actually transfer the keyboard focus.\n+   *\n+   * @param owner the Component to return from getFocusOwner and\n+   * getGlobalFocusOwner\n+   *\n+   * @see Component.requestFocus ()\n+   * @see Component.requestFocusInWindow ()\n+   */\n+  protected void setGlobalFocusOwner (Component owner)\n   {\n-    // XXX Need an easy way to test if this thread is in the context of the\n-    // global focus owner, to avoid creating the exception in the first place.\n-    try\n-      {\n-        return getGlobalFocusOwner();\n-      }\n-    catch (SecurityException e)\n-      {\n-        return null;\n-      }\n-  }\n-\n-  protected Component getGlobalFocusOwner()\n-  {\n-    // XXX Need a way to test if this thread is in the context of the focus\n-    // owner, and throw a SecurityException if that is the case.\n-    // XXX Implement.\n-    return focusOwner;\n-  }\n-\n-  protected void setGlobalFocusOwner(Component owner)\n-  {\n-    // XXX Should this send focus events to the components involved?\n     if (owner == null || owner.focusable)\n-      {\n-        firePropertyChange(\"focusOwner\", focusOwner, owner);\n-        try\n-          {\n-            fireVetoableChange(\"focusOwner\", focusOwner, owner);\n-            focusOwner = owner;\n-          }\n-        catch (PropertyVetoException e)\n-          {\n-          }\n-      }\n-  }\n-\n-  public void clearGlobalFocusOwner()\n-  {\n-    // XXX Is this enough?\n-    setGlobalFocusOwner(null);\n+      setGlobalObject (currentFocusOwners, owner, \"focusOwner\");\n   }\n \n-  public Component getPermanentFocusOwner()\n+  /**\n+   * Clear the global focus owner and deliver a FOCUS_LOST event to\n+   * the previously-focused {@link Component}.  Until another {@link\n+   * Component} becomes the keyboard focus owner, key events will be\n+   * discarded by top-level windows.\n+   */\n+  public void clearGlobalFocusOwner ()\n   {\n-    // XXX Need an easy way to test if this thread is in the context of the\n-    // global focus owner, to avoid creating the exception in the first place.\n-    try\n+    synchronized (currentFocusOwners)\n       {\n-        return getGlobalPermanentFocusOwner();\n-      }\n-    catch (SecurityException e)\n-      {\n-        return null;\n-      }\n-  }\n+        Component focusOwner = getGlobalFocusOwner ();\n+        Component permanentFocusOwner = getGlobalPermanentFocusOwner ();\n \n-  protected Component getGlobalPermanentFocusOwner()\n-  {\n-    // XXX Need a way to test if this thread is in the context of the focus\n-    // owner, and throw a SecurityException if that is the case.\n-    // XXX Implement.\n-    return permanentFocusOwner == null ? focusOwner : permanentFocusOwner;\n-  }\n+        setGlobalFocusOwner (null);\n+        setGlobalPermanentFocusOwner (null);\n \n-  protected void setGlobalPermanentFocusOwner(Component focusOwner)\n-  {\n-    // XXX Should this send focus events to the components involved?\n-    if (focusOwner == null || focusOwner.focusable)\n-      {\n-        firePropertyChange(\"permanentFocusOwner\", permanentFocusOwner,\n-                           focusOwner);\n-        try\n+        // Inform the old focus owner that it has lost permanent\n+        // focus.\n+        if (focusOwner != null)\n           {\n-            fireVetoableChange(\"permanentFocusOwner\", permanentFocusOwner,\n-                               focusOwner);\n-            permanentFocusOwner = focusOwner;\n+            // We can't cache the event queue, because of\n+            // bootstrapping issues.  We need to set the default\n+            // KeyboardFocusManager in EventQueue before the event\n+            // queue is started.\n+            EventQueue q = Toolkit.getDefaultToolkit ().getSystemEventQueue ();\n+            if (focusOwner != permanentFocusOwner)\n+              q.postEvent (new FocusEvent (focusOwner, FocusEvent.FOCUS_LOST, true));\n+            else\n+              q.postEvent (new FocusEvent (focusOwner, FocusEvent.FOCUS_LOST, false));\n           }\n-        catch (PropertyVetoException e)\n+\n+        if (focusOwner != permanentFocusOwner)\n           {\n+            EventQueue q = Toolkit.getDefaultToolkit ().getSystemEventQueue ();\n+            q.postEvent (new FocusEvent (permanentFocusOwner, FocusEvent.FOCUS_LOST, false));\n           }\n       }\n   }\n \n-  public Window getFocusedWindow()\n+  /**\n+   * Retrieve the {@link Component} that has the permanent keyboard\n+   * focus, or null if the focus owner was not set by a thread in the\n+   * current {@link java.lang.ThreadGroup}.\n+   *\n+   * @return the keyboard focus owner or null\n+   */\n+  public Component getPermanentFocusOwner ()\n+  {\n+    return (Component) getObject (currentPermanentFocusOwners);\n+  }\n+\n+  /**\n+   * Retrieve the {@link Component} that has the permanent keyboard\n+   * focus, regardless of whether or not it was set by a thread in the\n+   * current {@link java.lang.ThreadGroup}.\n+   *\n+   * @return the keyboard focus owner\n+   * @throws SecurityException if this is not the keyboard focus\n+   * manager associated with the current {@link java.lang.ThreadGroup}\n+   */\n+  protected Component getGlobalPermanentFocusOwner ()\n+  {\n+    return (Component) getGlobalObject (currentPermanentFocusOwners);\n+  }\n+\n+  /**\n+   * Set the {@link Component} that will be returned by {@link\n+   * #getPermanentFocusOwner} (when it is called from the current\n+   * {@link java.lang.ThreadGroup}) and {@link\n+   * #getGlobalPermanentFocusOwner}.  This method does not actually\n+   * transfer the keyboard focus.\n+   *\n+   * @param focusOwner the Component to return from\n+   * getPermanentFocusOwner and getGlobalPermanentFocusOwner\n+   *\n+   * @see Component.requestFocus ()\n+   * @see Component.requestFocusInWindow ()\n+   */\n+  protected void setGlobalPermanentFocusOwner (Component focusOwner)\n   {\n-    // XXX Need an easy way to test if this thread is in the context of the\n-    // global focus owner, to avoid creating the exception in the first place.\n-    try\n-      {\n-        return getGlobalFocusedWindow();\n-      }\n-    catch (SecurityException e)\n-      {\n-        return null;\n-      }\n-  }\n-\n-  protected Window getGlobalFocusedWindow()\n-  {\n-    // XXX Need a way to test if this thread is in the context of the focus\n-    // owner, and throw a SecurityException if that is the case.\n-    // XXX Implement.\n-    return focusedWindow;\n-  }\n-\n-  protected void setGlobalFocusedWindow(Window window)\n+    if (focusOwner == null || focusOwner.focusable)\n+      setGlobalObject (currentPermanentFocusOwners, focusOwner,\n+\t\t       \"permanentFocusOwner\");\n+  }\n+\n+  /**\n+   * Retrieve the {@link Window} that is or contains the keyboard\n+   * focus owner, or null if the focused window was not set by a\n+   * thread in the current {@link java.lang.ThreadGroup}.\n+   *\n+   * @return the focused window or null\n+   */\n+  public Window getFocusedWindow ()\n+  {\n+    return (Window) getObject (currentFocusedWindows);\n+  }\n+\n+  /**\n+   * Retrieve the {@link Window} that is or contains the focus owner,\n+   * regardless of whether or not the {@link Window} was set focused\n+   * by a thread in the current {@link java.lang.ThreadGroup}.\n+   *\n+   * @return the focused window\n+   * @throws SecurityException if this is not the keyboard focus\n+   * manager associated with the current {@link java.lang.ThreadGroup}\n+   */\n+  protected Window getGlobalFocusedWindow ()\n+  {\n+    return (Window) getGlobalObject (currentFocusedWindows);\n+  }\n+\n+  /**\n+   * Set the {@link Window} that will be returned by {@link\n+   * #getFocusedWindow} (when it is called from the current {@link\n+   * java.lang.ThreadGroup}) and {@link #getGlobalFocusedWindow}.\n+   * This method does not actually cause <code>window</code> to become\n+   * the focused {@link Window}.\n+   *\n+   * @param window the Window to return from getFocusedWindow and\n+   * getGlobalFocusedWindow\n+   */\n+  protected void setGlobalFocusedWindow (Window window)\n   {\n-    // XXX Should this send focus events to the windows involved?\n     if (window == null || window.focusable)\n-      {\n-        firePropertyChange(\"focusedWindow\", focusedWindow, window);\n-        try\n-          {\n-            fireVetoableChange(\"focusedWindow\", focusedWindow, window);\n-            focusedWindow = window;\n-          }\n-        catch (PropertyVetoException e)\n-          {\n-          }\n-      }\n+      setGlobalObject (currentFocusedWindows, window, \"focusedWindow\");\n   }\n \n+  /**\n+   * Retrieve the active {@link Window}, or null if the active window\n+   * was not set by a thread in the current {@link\n+   * java.lang.ThreadGroup}.\n+   *\n+   * @return the active window or null\n+   */\n   public Window getActiveWindow()\n   {\n-    // XXX Need an easy way to test if this thread is in the context of the\n-    // global focus owner, to avoid creating the exception in the first place.\n-    try\n-      {\n-        return getGlobalActiveWindow();\n-      }\n-    catch (SecurityException e)\n-      {\n-        return null;\n-      }\n+    return (Window) getObject (currentActiveWindows);\n   }\n \n+  /**\n+   * Retrieve the active {@link Window}, regardless of whether or not\n+   * the {@link Window} was made active by a thread in the current\n+   * {@link java.lang.ThreadGroup}.\n+   *\n+   * @return the active window\n+   * @throws SecurityException if this is not the keyboard focus\n+   * manager associated with the current {@link java.lang.ThreadGroup}\n+   */\n   protected Window getGlobalActiveWindow()\n   {\n-    // XXX Need a way to test if this thread is in the context of the focus\n-    // owner, and throw a SecurityException if that is the case.\n-    // XXX Implement.\n-    return activeWindow;\n+    return (Window) getGlobalObject (currentActiveWindows);\n   }\n \n+  /**\n+   * Set the {@link Window} that will be returned by {@link\n+   * #getActiveWindow} (when it is called from the current {@link\n+   * java.lang.ThreadGroup}) and {@link #getGlobalActiveWindow}.  This\n+   * method does not actually cause <code>window</code> to be made\n+   * active.\n+   *\n+   * @param window the Window to return from getActiveWindow and\n+   * getGlobalActiveWindow\n+   */\n   protected void setGlobalActiveWindow(Window window)\n   {\n-    // XXX Should this send focus events to the windows involved?\n-    firePropertyChange(\"activeWindow\", activeWindow, window);\n-    try\n-      {\n-        fireVetoableChange(\"activeWindow\", activeWindow, window);\n-        activeWindow = window;\n-      }\n-    catch (PropertyVetoException e)\n-      {\n-      }\n+    setGlobalObject (currentActiveWindows, window, \"activeWindow\");\n   }\n \n-  public FocusTraversalPolicy getDefaultFocusTraversalPolicy()\n+  /**\n+   * Retrieve the default {@link FocusTraversalPolicy}.\n+   * Focus-managing {@link Container}s use the returned object to\n+   * define their initial focus traversal policy.\n+   *\n+   * @return a non-null default FocusTraversalPolicy object\n+   */\n+  public FocusTraversalPolicy getDefaultFocusTraversalPolicy ()\n   {\n     if (defaultPolicy == null)\n-      defaultPolicy = new DefaultFocusTraversalPolicy();\n+      defaultPolicy = new DefaultFocusTraversalPolicy ();\n     return defaultPolicy;\n   }\n \n-  public void setDefaultFocusTraversalPolicy(FocusTraversalPolicy policy)\n+  /**\n+   * Set the {@link FocusTraversalPolicy} returned by {@link\n+   * #getDefaultFocusTraversalPolicy}.  Focus-managing {@link\n+   * Container}s created after this call will use policy as their\n+   * initial focus traversal policy.  Existing {@link Container}s'\n+   * focus traversal policies will not be affected by calls to this\n+   * method.\n+   *\n+   * @param policy the FocusTraversalPolicy that will be returned by\n+   * subsequent calls to getDefaultFocusTraversalPolicy\n+   * @throws IllegalArgumentException if policy is null\n+   */\n+  public void setDefaultFocusTraversalPolicy (FocusTraversalPolicy policy)\n   {\n     if (policy == null)\n-      throw new IllegalArgumentException();\n-    firePropertyChange(\"defaultFocusTraversalPolicy\", defaultPolicy, policy);\n+      throw new IllegalArgumentException ();\n+    firePropertyChange (\"defaultFocusTraversalPolicy\", defaultPolicy, policy);\n     defaultPolicy = policy;\n   }\n \n-  public void setDefaultFocusTraversalKeys(int id, Set keystrokes)\n-  {\n+  /**\n+   * Set the default {@link java.util.Set} of focus traversal keys for\n+   * one of the focus traversal directions.\n+   *\n+   * @param id focus traversal direction identifier\n+   * @param keystrokes set of AWTKeyStrokes\n+   *\n+   * @see #FORWARD_TRAVERSAL_KEYS\n+   * @see #BACKWARD_TRAVERSAL_KEYS\n+   * @see #UP_CYCLE_TRAVERSAL_KEYS\n+   * @see #DOWN_CYCLE_TRAVERSAL_KEYS\n+   */\n+  public void setDefaultFocusTraversalKeys (int id, Set keystrokes)\n+  {\n+    if (id != KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS &&\n+        id != KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS &&\n+        id != KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS &&\n+        id != KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS)\n+      throw new IllegalArgumentException ();\n+\n     if (keystrokes == null)\n-      throw new IllegalArgumentException();\n+      throw new IllegalArgumentException ();\n+\n     Set sa;\n     Set sb;\n     Set sc;\n@@ -340,56 +542,82 @@ public void setDefaultFocusTraversalKeys(int id, Set keystrokes)\n         type = \"downCycleDefaultFocusTraversalKeys\";\n         break;\n       default:\n-        throw new IllegalArgumentException();\n+        throw new IllegalArgumentException ();\n       }\n-    int i = keystrokes.size();\n-    Iterator iter = keystrokes.iterator();\n+    int i = keystrokes.size ();\n+    Iterator iter = keystrokes.iterator ();\n     while (--i >= 0)\n       {\n-        Object o = iter.next();\n-        if (! (o instanceof AWTKeyStroke)\n-            || sa.contains(o) || sb.contains(o) || sc.contains(o)\n+        Object o = iter.next ();\n+        if (!(o instanceof AWTKeyStroke)\n+            || sa.contains (o) || sb.contains (o) || sc.contains (o)\n             || ((AWTKeyStroke) o).keyCode == KeyEvent.VK_UNDEFINED)\n-          throw new IllegalArgumentException();\n+          throw new IllegalArgumentException ();\n       }\n-    keystrokes = Collections.unmodifiableSet(new HashSet(keystrokes));\n-    firePropertyChange(type, defaultFocusKeys[id], keystrokes);\n+    keystrokes = Collections.unmodifiableSet (new HashSet (keystrokes));\n+    firePropertyChange (type, defaultFocusKeys[id], keystrokes);\n     defaultFocusKeys[id] = keystrokes;\n   }\n \n-  public Set getDefaultFocusTraversalKeys(int id)\n+  /**\n+   * Retrieve the default {@link java.util.Set} of focus traversal\n+   * keys for one of the focus traversal directions.\n+   *\n+   * @param id focus traversal direction identifier\n+   *\n+   * @return the default set of AWTKeyStrokes\n+   *\n+   * @see #FORWARD_TRAVERSAL_KEYS\n+   * @see #BACKWARD_TRAVERSAL_KEYS\n+   * @see #UP_CYCLE_TRAVERSAL_KEYS\n+   * @see #DOWN_CYCLE_TRAVERSAL_KEYS\n+   */\n+  public Set getDefaultFocusTraversalKeys (int id)\n   {\n     if (id < FORWARD_TRAVERSAL_KEYS || id > DOWN_CYCLE_TRAVERSAL_KEYS)\n-      throw new IllegalArgumentException();\n+      throw new IllegalArgumentException ();\n     return defaultFocusKeys[id];\n   }\n \n-  public Container getCurrentFocusCycleRoot()\n+  /**\n+   * Retrieve the current focus cycle root, or null if the focus owner\n+   * was not set by a thread in the current {@link\n+   * java.lang.ThreadGroup}.\n+   *\n+   * @return the current focus cycle root or null\n+   */\n+  public Container getCurrentFocusCycleRoot ()\n   {\n-    // XXX Need an easy way to test if this thread is in the context of the\n-    // global focus owner, to avoid creating the exception in the first place.\n-    try\n-      {\n-        return getGlobalCurrentFocusCycleRoot();\n-      }\n-    catch (SecurityException e)\n-      {\n-        return null;\n-      }\n+    return (Container) getObject (currentFocusCycleRoots);\n   }\n \n-  protected Container getGlobalCurrentFocusCycleRoot()\n+  /**\n+   * Retrieve the current focus cycle root, regardless of whether or\n+   * not it was made set by a thread in the current {@link\n+   * java.lang.ThreadGroup}.\n+   *\n+   * @return the current focus cycle root\n+   * @throws SecurityException if this is not the keyboard focus\n+   * manager associated with the current {@link java.lang.ThreadGroup}\n+   */\n+  protected Container getGlobalCurrentFocusCycleRoot ()\n   {\n-    // XXX Need a way to test if this thread is in the context of the focus\n-    // owner, and throw a SecurityException if that is the case.\n-    // XXX Implement.\n-    return focusCycleRoot;\n+    return (Container) getGlobalObject (currentFocusCycleRoots);\n   }\n \n-  public void setGlobalCurrentFocusCycleRoot(Container cycleRoot)\n+  /**\n+   * Set the {@link Container} that will be returned by {@link\n+   * #getCurrentFocusCycleRoot} (when it is called from the current\n+   * {@link java.lang.ThreadGroup}) and {@link\n+   * #getGlobalCurrentFocusCycleRoot}.  This method does not actually\n+   * make <code>cycleRoot</code> the current focus cycle root.\n+   * \n+   * @param cycleRoot the focus cycle root to return from\n+   * getCurrentFocusCycleRoot and getGlobalCurrentFocusCycleRoot\n+   */\n+  public void setGlobalCurrentFocusCycleRoot (Container cycleRoot)\n   {\n-    firePropertyChange(\"currentFocusCycleRoot\", focusCycleRoot, cycleRoot);\n-    focusCycleRoot = cycleRoot;\n+    setGlobalObject (currentFocusCycleRoots, cycleRoot, \"currentFocusCycleRoot\");\n   }\n \n   public void addPropertyChangeListener(PropertyChangeListener l)\n@@ -484,73 +712,196 @@ public void removeKeyEventDispatcher(KeyEventDispatcher dispatcher)\n     keyEventDispatchers.remove(dispatcher);\n   }\n \n-  protected List getKeyEventDispatchers()\n+  protected List getKeyEventDispatchers ()\n   {\n-    return (List) keyEventDispatchers.clone();\n+    return (List) keyEventDispatchers.clone ();\n   }\n \n-  public void addKeyEventPostProcessor(KeyEventPostProcessor postProcessor)\n+  public void addKeyEventPostProcessor (KeyEventPostProcessor postProcessor)\n   {\n     if (postProcessor != null)\n-      keyEventPostProcessors.add(postProcessor);\n+      keyEventPostProcessors.add (postProcessor);\n   }\n \n-  public void removeKeyEventPostProcessor(KeyEventPostProcessor postProcessor)\n+  public void removeKeyEventPostProcessor (KeyEventPostProcessor postProcessor)\n   {\n-    keyEventPostProcessors.remove(postProcessor);\n+    keyEventPostProcessors.remove (postProcessor);\n   }\n \n-  protected List getKeyEventPostProcessors()\n+  protected List getKeyEventPostProcessors ()\n   {\n-    return (List) keyEventPostProcessors.clone();\n+    return (List) keyEventPostProcessors.clone ();\n   }\n \n-  public abstract boolean dispatchEvent(AWTEvent e);\n+  public abstract boolean dispatchEvent (AWTEvent e);\n \n-  public final void redispatchEvent(Component target, AWTEvent e)\n+  public final void redispatchEvent (Component target, AWTEvent e)\n   {\n-    throw new Error(\"not implemented\");\n+    e.setSource (target);\n+    dispatchEvent (e);\n   }\n \n-  public abstract boolean dispatchKeyEvent(KeyEvent e);\n+  public abstract boolean dispatchKeyEvent (KeyEvent e);\n \n-  public abstract boolean postProcessKeyEvent(KeyEvent e);\n+  public abstract boolean postProcessKeyEvent (KeyEvent e);\n \n-  public abstract void processKeyEvent(Component focused, KeyEvent e);\n+  public abstract void processKeyEvent (Component focused, KeyEvent e);\n \n-  protected abstract void enqueueKeyEvents(long after, Component untilFocused);\n+  protected abstract void enqueueKeyEvents (long after, Component untilFocused);\n \n-  protected abstract void dequeueKeyEvents(long after, Component untilFocused);\n+  protected abstract void dequeueKeyEvents (long after, Component untilFocused);\n \n-  protected abstract void discardKeyEvents(Component comp);\n+  protected abstract void discardKeyEvents (Component comp);\n \n-  public abstract void focusNextComponent(Component comp);\n+  public abstract void focusNextComponent (Component comp);\n \n-  public abstract void focusPreviousComponent(Component comp);\n+  public abstract void focusPreviousComponent (Component comp);\n \n-  public abstract void upFocusCycle(Component comp);\n+  public abstract void upFocusCycle (Component comp);\n \n-  public abstract void downFocusCycle(Container cont);\n+  public abstract void downFocusCycle (Container cont);\n \n-  public final void focusNextComponent()\n+  public final void focusNextComponent ()\n   {\n-    focusNextComponent(focusOwner);\n+    focusNextComponent (null);\n   }\n \n-  public final void focusPreviousComponent()\n+  public final void focusPreviousComponent ()\n   {\n-    focusPreviousComponent(focusOwner);\n+    focusPreviousComponent (null);\n   }\n \n-  public final void upFocusCycle()\n+  public final void upFocusCycle ()\n   {\n-    upFocusCycle(focusOwner);\n+    upFocusCycle (null);\n   }\n \n-  public final void downFocusCycle()\n+  public final void downFocusCycle ()\n   {\n+    Component focusOwner = getGlobalFocusOwner ();\n     if (focusOwner instanceof Container\n-        && ((Container) focusOwner).isFocusCycleRoot())\n-      downFocusCycle((Container) focusOwner);\n+        && ((Container) focusOwner).isFocusCycleRoot ())\n+      downFocusCycle ((Container) focusOwner);\n+  }\n+\n+  /**\n+   * Retrieve an object from one of the global object {@link\n+   * java.util.Map}s, if the object was set by the a thread in the\n+   * current {@link java.lang.ThreadGroup}.  Otherwise, return null.\n+   *\n+   * @param globalMap one of the global object Maps\n+   *\n+   * @return a global object set by the current ThreadGroup, or null\n+   *\n+   * @see getFocusOwner\n+   * @see getPermanentFocusOwner\n+   * @see getFocusedWindow\n+   * @see getActiveWindow\n+   * @see getCurrentFocusCycleRoot\n+   */\n+  private Object getObject (Map globalMap)\n+  {\n+    ThreadGroup currentGroup = Thread.currentThread ().getThreadGroup ();\n+    return globalMap.get (currentGroup);\n+  }\n+\n+  /**\n+   * Retrieve an object from one of the global object {@link\n+   * java.util.Map}s, regardless of whether or not the object was set\n+   * by a thread in the current {@link java.lang.ThreadGroup}.\n+   *\n+   * @param globalMap one of the global object Maps\n+   *\n+   * @return a global object set by the current ThreadGroup, or null\n+   *\n+   * @throws SecurityException if this is not the keyboard focus\n+   * manager associated with the current {@link java.lang.ThreadGroup}\n+   *\n+   * @see getGlobalFocusOwner\n+   * @see getGlobalPermanentFocusOwner\n+   * @see getGlobalFocusedWindow\n+   * @see getGlobalActiveWindow\n+   * @see getGlobalCurrentFocusCycleRoot\n+   */\n+  private Object getGlobalObject (Map globalMap)\n+  {\n+    ThreadGroup currentGroup = Thread.currentThread ().getThreadGroup ();\n+    KeyboardFocusManager managerForCallingThread\n+      = (KeyboardFocusManager) currentKeyboardFocusManagers.get (currentGroup);\n+\n+    if (this != managerForCallingThread)\n+      throw new SecurityException (\"Attempted to retrieve an object from a \"\n+                                   + \"keyboard focus manager that isn't \"\n+                                   + \"associated with the current thread group.\");\n+\n+    synchronized (globalMap)\n+      {\n+        Collection globalObjects = globalMap.values ();\n+        Iterator i = globalObjects.iterator ();\n+        Component globalObject;\n+\n+        while (i.hasNext ())\n+          {\n+            globalObject = (Component) i.next ();\n+            if (globalObject != null)\n+              return globalObject;\n+          }\n+      }\n+\n+    // No Object was found.\n+    return null;\n+  }\n+\n+  /**\n+   * Set an object in one of the global object {@link java.util.Map}s,\n+   * that will be returned by subsequent calls to getGlobalObject on\n+   * the same {@link java.util.Map}.\n+   *\n+   * @param globalMap one of the global object Maps\n+   * @param newObject the object to set\n+   * @param property the property that will change\n+   *\n+   * @see setGlobalFocusOwner\n+   * @see setGlobalPermanentFocusOwner\n+   * @see setGlobalFocusedWindow\n+   * @see setGlobalActiveWindow\n+   * @see setGlobalCurrentFocusCycleRoot\n+   */\n+  private void setGlobalObject (Map globalMap,\n+                                Object newObject,\n+                                String property)\n+  {\n+    synchronized (globalMap)\n+      {\n+        // Save old object.\n+        Object oldObject = getGlobalObject (globalMap);\n+\n+        // Nullify old object.\n+        Collection threadGroups = globalMap.keySet ();\n+        Iterator i = threadGroups.iterator ();\n+        while (i.hasNext ())\n+          {\n+            ThreadGroup oldThreadGroup = (ThreadGroup) i.next ();\n+            if (globalMap.get (oldThreadGroup) != null)\n+              {\n+                globalMap.put (oldThreadGroup, null);\n+                // There should only be one object set at a time, so\n+                // we can short circuit.\n+                break;\n+              }\n+          }\n+\n+        ThreadGroup currentGroup = Thread.currentThread ().getThreadGroup ();\n+        firePropertyChange (property, oldObject, newObject);\n+        try\n+          {\n+            fireVetoableChange (property, oldObject, newObject);\n+            // Set new object.\n+            globalMap.put (currentGroup, newObject);\n+          }\n+        catch (PropertyVetoException e)\n+          {\n+          }\n+      }\n   }\n-} // class KeyboardFocusManager\n+}"}, {"sha": "f27c29695f4b763e2c9ebd697f24b179400ab75d", "filename": "libjava/java/awt/TextArea.java", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FTextArea.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FTextArea.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FTextArea.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -39,6 +39,9 @@\n \n import java.awt.peer.ComponentPeer;\n import java.awt.peer.TextAreaPeer;\n+import java.awt.event.KeyEvent;\n+import java.util.HashSet;\n+import java.util.Set;\n \n \n /**\n@@ -193,11 +196,19 @@ public TextArea (String text, int rows, int columns, int scrollbarVisibility)\n     this.rows = rows;\n     this.columns = columns;\n     this.scrollbarVisibility = scrollbarVisibility;\n-  }\n \n-  /*\n-   * Instance Variables\n-   */\n+    // TextAreas need to receive tab key events so we override the\n+    // default forward and backward traversal key sets.\n+    Set s = new HashSet ();\n+    s.add (AWTKeyStroke.getAWTKeyStroke (KeyEvent.VK_TAB,\n+                                         KeyEvent.CTRL_DOWN_MASK));\n+    setFocusTraversalKeys (KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, s);\n+    s = new HashSet ();\n+    s.add (AWTKeyStroke.getAWTKeyStroke (KeyEvent.VK_TAB,\n+                                         KeyEvent.SHIFT_DOWN_MASK\n+                                         | KeyEvent.CTRL_DOWN_MASK));\n+    setFocusTraversalKeys (KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, s);\n+  }\n \n   /**\n    * Retrieve the number of columns that this text area would prefer\n@@ -431,10 +442,8 @@ public int getScrollbarVisibility ()\n    */\n   public void addNotify ()\n   {\n-    if (getPeer () != null)\n-      return;\n-\n-    setPeer ((ComponentPeer) getToolkit().createTextArea (this));\n+    if (getPeer () == null)\n+      setPeer ((ComponentPeer) getToolkit().createTextArea (this));\n   }\n \n   /**\n@@ -458,10 +467,9 @@ public void append (String str)\n   public void appendText (String str)\n   {\n     TextAreaPeer peer = (TextAreaPeer) getPeer ();\n-    if (peer == null)\n-      return;\n \n-    peer.insert (str, peer.getText().length ());\n+    if (peer != null)\n+      peer.insert (str, peer.getText().length ());\n   }\n \n   /**\n@@ -489,10 +497,9 @@ public void insert (String str, int pos)\n   public void insertText (String str, int pos)\n   {\n     TextAreaPeer peer = (TextAreaPeer) getPeer ();\n-    if (peer == null)\n-      return;\n \n-    peer.insert (str, pos);\n+    if (peer != null)\n+      peer.insert (str, pos);\n   }\n \n   /**\n@@ -530,10 +537,9 @@ public void replaceRange (String str, int start, int end)\n   public void replaceText (String str, int start, int end)\n   {\n     TextAreaPeer peer = (TextAreaPeer) getPeer ();\n-    if (peer == null)\n-      return;\n \n-    peer.replaceRange (str, start, end);\n+    if (peer != null)\n+      peer.replaceRange (str, start, end);\n   }\n \n   /**"}, {"sha": "51b00dc175d194e6f9119da9fbe90b4618483105", "filename": "libjava/java/awt/Window.java", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FWindow.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2FWindow.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FWindow.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -83,6 +83,8 @@ public class Window extends Container implements Accessible\n   private transient GraphicsConfiguration graphicsConfiguration;\n   private transient AccessibleContext accessibleContext;\n \n+  private transient boolean shown;\n+\n   /** \n    * This (package access) constructor is used by subclasses that want\n    * to build windows that do not have parents.  Eg. toplevel\n@@ -92,6 +94,9 @@ public class Window extends Container implements Accessible\n   Window()\n   {\n     visible = false;\n+    // Windows are the only Containers that default to being focus\n+    // cycle roots.\n+    focusCycleRoot = true;\n     setLayout(new BorderLayout());\n   }\n \n@@ -242,6 +247,23 @@ public void show()\n     validate();\n     super.show();\n     toFront();\n+\n+    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n+    manager.setGlobalFocusedWindow (this);\n+\n+    if (!shown)\n+      {\n+        FocusTraversalPolicy policy = getFocusTraversalPolicy ();\n+        Component initialFocusOwner = null;\n+\n+        if (policy != null)\n+          initialFocusOwner = policy.getInitialComponent (this);\n+\n+        if (initialFocusOwner != null)\n+          initialFocusOwner.requestFocusInWindow (false);\n+\n+        shown = true;\n+      }\n   }\n \n   public void hide()\n@@ -627,9 +649,16 @@ else if (id == WindowEvent.WINDOW_STATE_CHANGED)\n    * @return The component that has focus, or <code>null</code> if no\n    * component has focus.\n    */\n-  public Component getFocusOwner()\n+  public Component getFocusOwner ()\n   {\n-    // FIXME\n+    KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n+\n+    Window activeWindow = manager.getActiveWindow ();\n+\n+    // The currently-focused Component belongs to the active Window.\n+    if (activeWindow == this)\n+      return manager.getFocusOwner ();\n+\n     return null;\n   }\n "}, {"sha": "c9a170b9b3b34c122ff1aae915cd7ec0f78e3b05", "filename": "libjava/java/awt/image/CropImageFilter.java", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2Fimage%2FCropImageFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2Fimage%2FCropImageFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FCropImageFilter.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -39,6 +39,7 @@\n package java.awt.image;\n \n import java.util.Hashtable;\n+import java.awt.Rectangle;\n \n /**\n  * <br>\n@@ -92,7 +93,7 @@ public void setDimensions(int width, int height)\n      */\n     public void setProperties(Hashtable props)\n     {\n-//  \tprops.put(\"filters\", \"ReplicateScaleFilter\");\n+  \tprops.put(\"filters\", \"CropImageFilter\");\n \tconsumer.setProperties(props);\n     }\n \n@@ -113,7 +114,27 @@ public void setProperties(Hashtable props)\n     public void setPixels(int x, int y, int w, int h, \n \t   ColorModel model, byte[] pixels, int offset, int scansize)\n     {\n-\tconsumer.setPixels(x, y, w, h, model, pixels, offset, scansize);\n+\tRectangle filterBounds = new Rectangle(this.x, this.y,\n+\t                                       this.width, this.height);\n+\tRectangle pixelBounds = new Rectangle(x, y, w, h);\n+\n+\tif (filterBounds.intersects(pixelBounds))\n+\t{\n+\t    Rectangle bounds = filterBounds.intersection(pixelBounds);\n+\n+\t    byte[] cropped = new byte[bounds.width * bounds.height];\n+\t    for (int i = 0; i < bounds.height; i++)\n+\t    {\n+\t\tint start = (bounds.y - pixelBounds.y + i) * scansize + offset;\n+\n+\t\tfor (int j = 0; j < bounds.width; j++)\n+\t\t    cropped[i * bounds.width + j] = pixels[start + bounds.x + j];\n+\t    }\n+\t    \n+\t    consumer.setPixels(bounds.x, bounds.y,\n+\t                       bounds.width, bounds.height,\n+\t                       model, cropped, 0, bounds.width);\n+\t}\n     }\n \n     /**\n@@ -133,7 +154,27 @@ public void setPixels(int x, int y, int w, int h,\n     public void setPixels(int x, int y, int w, int h, \n            ColorModel model, int[] pixels, int offset, int scansize)\n     {\n-\tconsumer.setPixels(x, y, w, h, model, pixels, offset, scansize);\n+\tRectangle filterBounds = new Rectangle(this.x, this.y,\n+\t                                       this.width, this.height);\n+\tRectangle pixelBounds = new Rectangle(x, y, w, h);\n+\n+\tif (filterBounds.intersects(pixelBounds))\n+\t{\n+\t    Rectangle bounds = filterBounds.intersection(pixelBounds);\n+\n+\t    int[] cropped = new int[bounds.width * bounds.height];\n+\t    for (int i = 0; i < bounds.height; i++)\n+\t    {\n+\t\tint start = (bounds.y - pixelBounds.y + i) * scansize + offset;\n+\n+\t\tfor (int j = 0; j < bounds.width; j++)\n+\t\t    cropped[i * bounds.width + j] = pixels[start + bounds.x + j];\n+\t    }\n+\t    \n+\t    consumer.setPixels(bounds.x, bounds.y,\n+\t                       bounds.width, bounds.height,\n+\t                       model, cropped, 0, bounds.width);\n+\t}\n     }\n \n }"}, {"sha": "d86119993ec919bd3e712a30b3b00eecda228858", "filename": "libjava/java/awt/image/MemoryImageSource.java", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -257,9 +257,15 @@ public synchronized void newPixels(int x,\n \t\t\t\tic.setProperties( props );\n \t\t\t    }\n \t\t\t    if( pixeli != null ) {\n-\t\t\t\tic.setPixels( 0, 0, width, height, cm, pixeli, offset, scansize );\n+\t\t\t\tint[] pixelbuf = new int[w * h];\n+\t\t\t\tfor (int row = y; row < h; row++)\n+\t\t\t\t    System.arraycopy(pixeli, row * scansize + x + offset, pixelbuf, row * w, w);\n+\t\t\t\tic.setPixels( x, y, w, h, cm, pixelbuf, 0, w );\n \t\t\t    } else {\n-\t\t\t\tic.setPixels( 0, 0, width, height, cm, pixelb, offset, scansize );\n+\t\t\t\tbyte[] pixelbuf = new byte[w * h];\n+\t\t\t\tfor (int row = y; row < h; row++)\n+\t\t\t\t    System.arraycopy(pixelb, row * scansize + x + offset, pixelbuf, row * w, w);\n+\t\t\t\tic.setPixels( x, y, w, h, cm, pixelbuf, 0, w );\n \t\t\t    }\n \t\t\t    ic.imageComplete( ImageConsumer.SINGLEFRAME );\n \t\t    }\n@@ -296,9 +302,15 @@ public synchronized void newPixels(int x,\n \t\t\t\tic.setProperties( props );\n \t\t\t    }\n \t\t\t    if( pixeli != null ) {\n-\t\t\t\tic.setPixels( 0, 0, width, height, cm, pixeli, offset, scansize );\n+\t\t\t\tint[] pixelbuf = new int[w * h];\n+\t\t\t\tfor (int row = y; row < h; row++)\n+\t\t\t\t    System.arraycopy(pixeli, row * scansize + x + offset, pixelbuf, row * w, w);\n+\t\t\t\tic.setPixels( x, y, w, h, cm, pixelbuf, 0, w );\n \t\t\t    } else {\n-\t\t\t\tic.setPixels( 0, 0, width, height, cm, pixelb, offset, scansize );\n+\t\t\t\tbyte[] pixelbuf = new byte[w * h];\n+\t\t\t\tfor (int row = y; row < h; row++)\n+\t\t\t\t    System.arraycopy(pixelb, row * scansize + x + offset, pixelbuf, row * w, w);\n+\t\t\t\tic.setPixels( x, y, w, h, cm, pixelbuf, 0, w );\n \t\t\t    }\n \t\t\t    if( framenotify == true )\n \t\t\t\tic.imageComplete( ImageConsumer.SINGLEFRAME );\n@@ -313,9 +325,14 @@ public synchronized void newPixels(byte newpix[],\n \t\t\t\t       int scansize)\n \n     {\n+\tpixeli = null;\n+\tpixelb = newpix;\n+\tcm = newmodel;\n+\tthis.offset = offset;\n+\tthis.scansize = scansize;\n \tif( animated == true )\n \t    {\n-\t\t//FIXME\n+\t\tnewPixels();\n \t    }\n     }\n \n@@ -325,9 +342,14 @@ public synchronized void newPixels(int newpix[],\n \t\t\t\t       int scansize)\n \n     {\n+\tpixelb = null;\n+\tpixeli = newpix;\n+\tcm = newmodel;\n+\tthis.offset = offset;\n+\tthis.scansize = scansize;\n \tif( animated == true )\n \t    {\n-\t\t//FIXME\n+\t\tnewPixels();\n \t    }\n     }\n "}, {"sha": "5718024e7613ef68cdebe9e18c2a86d765c5b7c3", "filename": "libjava/java/awt/image/RGBImageFilter.java", "status": "modified", "additions": 54, "deletions": 28, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2Fimage%2FRGBImageFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2Fimage%2FRGBImageFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FRGBImageFilter.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -46,7 +46,7 @@\n  */\n public abstract class RGBImageFilter extends ImageFilter\n {\n-    protected ColorModel origmodel = ColorModel.getRGBdefault();\n+    protected ColorModel origmodel;\n \n     protected ColorModel newmodel;\n     \n@@ -126,7 +126,7 @@ public IndexColorModel filterIndexColorModel(IndexColorModel icm)\n \n     private int makeColor( byte a, byte r, byte g, byte b )\n     {\n-\treturn ( 0xff000000 & (a << 24) | 0xff0000 & (r << 16) | 0xff00 & (b << 8) | 0xff & g ); \n+\treturn ( 0xff000000 & (a << 24) | 0xff0000 & (r << 16) | 0xff00 & (g << 8) | 0xff & b ); \n     }\n \n     /**\n@@ -149,11 +149,15 @@ public void filterRGBPixels(int x,\n \t\t\t\tint off,\n \t\t\t\tint scansize)\n     {\n-\tint xp, yp;\n+\tint xp, yp, i;\n \n+\ti = 0;\n \tfor( xp = x; xp < ( x + w); xp++ )\n \t    for( yp = y; yp < (y + h); yp++ )\n-\t\t pixels[ off + yp * scansize + xp ] = filterRGB( xp, yp, pixels[ off + yp * scansize + xp ] );\n+\t    {\n+\t\tpixels[i] = filterRGB( xp, yp, pixels[i] );\n+\t\ti++;\n+\t    }\n     }\n \n \n@@ -172,15 +176,19 @@ public void filterRGBPixels(int x,\n      * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n      */\n     public void setPixels(int x, int y, int w, int h, \n-\t   ColorModel model, byte[] pixels, int offset, int scansize)\n+                          ColorModel model, byte[] pixels,\n+                          int offset, int scansize)\n     {\n-\tif( model == origmodel ) {\n+\tif(model == origmodel && (model instanceof IndexColorModel) && canFilterIndexColorModel)\n+\t{\n \t    consumer.setPixels(x, y, w, h, newmodel, pixels, offset, scansize);\n-\t} else {\n-\t    //FIXME\n-\t    //convert to proper CM\n-\t    int pixelsi[] = new int[ pixels.length / 4 ];\n-\t    filterRGBPixels( x, y, w, h, pixelsi, offset, scansize );\n+\t}\n+\telse\n+\t{\n+\t    int intPixels[] =\n+\t\tconvertColorModelToDefault( x, y, w, h, model, pixels, offset, scansize );\n+\t    filterRGBPixels( x, y, w, h, intPixels, offset, scansize );\n+\t    consumer.setPixels(x, y, w, h, ColorModel.getRGBdefault(), intPixels, offset, scansize);\n \t}\n     }\n \n@@ -199,35 +207,53 @@ public void setPixels(int x, int y, int w, int h,\n      * @param scansize the width to use in extracting pixels from the <code>pixels</code> array\n      */\n     public void setPixels(int x, int y, int w, int h, \n-           ColorModel model, int[] pixels, int offset, int scansize)\n+                          ColorModel model, int[] pixels,\n+                          int offset, int scansize)\n     {\n-\tif( model == origmodel ) {\n+\tif(model == origmodel && (model instanceof IndexColorModel) && canFilterIndexColorModel)\n+\t{\n \t    consumer.setPixels(x, y, w, h, newmodel, pixels, offset, scansize);\n-\t} else {\n+\t}\n+\telse\n+\t{\n+\t    //FIXME: Store the filtered pixels in a separate temporary buffer?\n \t    convertColorModelToDefault( x, y, w, h, model, pixels, offset, scansize );\n \t    filterRGBPixels( x, y, w, h, pixels, offset, scansize );\n+\t    consumer.setPixels(x, y, w, h, ColorModel.getRGBdefault(), pixels, offset, scansize);\n \t}\n     }\n \n-    private void convertColorModelToDefault( int x, int y, int w, int h, \n-\t    ColorModel model, int pixels[], int offset, int scansize)\n-\t{\n-\tint xp, yp;\n+    private int[] convertColorModelToDefault(int x, int y, int w, int h, \n+                                            ColorModel model, byte pixels[],\n+                                            int offset, int scansize)\n+    {\n+\tint intPixels[] = new int[pixels.length];\n+\tfor (int i = 0; i < pixels.length; i++)\n+\t    intPixels[i] = makeColorbyDefaultCM(model, pixels[i]);\n+\treturn intPixels;\n+    }\n \n-\tfor( xp = x; xp < ( x + w); xp++ )\n-\t    for( yp = y; yp < (y + h); yp++ )\n-\t\t pixels[ offset + yp * scansize + xp ] =  makeColorbyDefaultCM( pixels[ offset + yp * scansize + xp ] );\n-\t    \n-\t}\n-    private int makeColorbyDefaultCM( int rgb ) \n-\t{\n-\t    return makeColor( origmodel.getRed( rgb ), origmodel.getGreen( rgb ), origmodel.getGreen( rgb ), origmodel.getBlue( rgb ) );\n-\t}\n+    private void convertColorModelToDefault(int x, int y, int w, int h, \n+                                            ColorModel model, int pixels[],\n+                                            int offset, int scansize)\n+    {\n+\tfor (int i = 0; i < pixels.length; i++)\n+\t    pixels[i] = makeColorbyDefaultCM(model, pixels[i]);\n+    }\n \n+    private int makeColorbyDefaultCM(ColorModel model, byte rgb) \n+    {\n+\treturn makeColor( model.getAlpha( rgb ) * 4, model.getRed( rgb ) * 4, model.getGreen( rgb ) * 4, model.getBlue( rgb ) * 4 );\n+    }\n+\n+    private int makeColorbyDefaultCM(ColorModel model, int rgb) \n+    {\n+\treturn makeColor( model.getAlpha( rgb ), model.getRed( rgb ), model.getGreen( rgb ), model.getBlue( rgb ) );\n+    }\n \n     private int makeColor( int a, int r, int g, int b )\n     {\n-\treturn (int)( 0xff000000 & (a << 24) | 0xff0000 & (r << 16) | 0xff00 & (b << 8) | 0xff & g ); \n+\treturn (int)( 0xff000000 & (a << 24) | 0xff0000 & (r << 16) | 0xff00 & (g << 8) | 0xff & b ); \n     }\n \n "}, {"sha": "a572da7c3bd9aaba8bf1e4b9185ec3d4d79f5262", "filename": "libjava/java/awt/image/ReplicateScaleFilter.java", "status": "modified", "additions": 84, "deletions": 3, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2Fimage%2FReplicateScaleFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjava%2Fawt%2Fimage%2FReplicateScaleFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FReplicateScaleFilter.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -104,7 +104,27 @@ public ReplicateScaleFilter(int width, int height) {\n      */\n     public void setDimensions(int width, int height)\n     {\n-\tconsumer.setDimensions(width, height);\n+\tsrcWidth = width;\n+\tsrcHeight = height;\n+\n+\t/* If either destHeight or destWidth is < 0, the image should\n+\t   maintain its original aspect ratio.  When both are < 0,\n+\t   just maintain the original width and height. */\n+\tif (destWidth < 0 && destHeight < 0)\n+        {\n+\t    destWidth = width;\n+\t    destHeight = height;\n+\t}\n+\telse if (destWidth < 0)\n+\t{\n+\t    destWidth = (int) (width * ((double) destHeight / srcHeight));\n+\t}\n+\telse if (destHeight < 0)\n+\t{\n+\t    destHeight = (int) (height * ((double) destWidth / srcWidth));\n+\t}\n+\n+\tconsumer.setDimensions(destWidth, destHeight);\n     }\n \n     /**\n@@ -136,7 +156,18 @@ public void setProperties(Hashtable props)\n     public void setPixels(int x, int y, int w, int h, \n \t   ColorModel model, byte[] pixels, int offset, int scansize)\n     {\n-\tconsumer.setPixels(x, y, w, h, model, pixels, offset, scansize);\n+\tdouble rx = ((double) srcWidth) / destWidth;\n+\tdouble ry = ((double) srcHeight) / destHeight;\n+\n+\tint destScansize = (int) Math.round(scansize / rx);\n+\n+\tbyte[] destPixels = replicatePixels(x, y, w, h,\n+                                           model, pixels, offset, scansize,\n+\t                                   rx, ry, destScansize);\n+\n+\tconsumer.setPixels((int) Math.floor(x/rx), (int) Math.floor(y/ry),\n+                           (int) Math.ceil(w/rx), (int) Math.ceil(h/ry),\n+                           model, destPixels, 0, destScansize);\n     }\n \n     /**\n@@ -156,8 +187,58 @@ public void setPixels(int x, int y, int w, int h,\n     public void setPixels(int x, int y, int w, int h, \n            ColorModel model, int[] pixels, int offset, int scansize)\n     {\n-\tconsumer.setPixels(x, y, w, h, model, pixels, offset, scansize);\n+\tdouble rx = ((double) srcWidth) / destWidth;\n+\tdouble ry = ((double) srcHeight) / destHeight;\n+\n+\tint destScansize = (int) Math.round(scansize / rx);\n+\n+\tint[] destPixels = replicatePixels(x, y, w, h,\n+                                           model, pixels, offset, scansize,\n+\t                                   rx, ry, destScansize);\n+\n+\tconsumer.setPixels((int) Math.floor(x/rx), (int) Math.floor(y/ry),\n+                           (int) Math.ceil(w/rx), (int) Math.ceil(h/ry),\n+                           model, destPixels, 0, destScansize);\n     }\n \n+    protected byte[] replicatePixels(int srcx, int srcy, int srcw, int srch,\n+                                    ColorModel model, byte[] srcPixels,\n+                                    int srcOffset, int srcScansize,\n+                                    double rx, double ry, int destScansize)\n+    {\n+\tbyte[] destPixels =\n+\t  new byte[(int) Math.ceil(srcw/rx) * (int) Math.ceil(srch/ry)];\n+\n+\tint a, b;\n+\tfor (int i = 0; i < destPixels.length; i++)\n+\t{\n+\t    a = (int) ((int) ( ((double) i) / destScansize) * ry) * srcScansize;\n+\t    b = (int) ((i % destScansize) * rx);\n+\t    if ((a + b + srcOffset) < srcPixels.length)\n+\t\tdestPixels[i] = srcPixels[a + b + srcOffset];\n+\t}\n+\n+\treturn destPixels;\n+    }\n+\n+    protected int[] replicatePixels(int srcx, int srcy, int srcw, int srch,\n+                                    ColorModel model, int[] srcPixels,\n+                                    int srcOffset, int srcScansize,\n+                                    double rx, double ry, int destScansize)\n+    {\n+\tint[] destPixels =\n+\t  new int[(int) Math.ceil(srcw/rx) * (int) Math.ceil(srch/ry)];\n+\n+\tint a, b;\n+\tfor (int i = 0; i < destPixels.length; i++)\n+\t{\n+\t    a = (int) ((int) ( ((double) i) / destScansize) * ry) * srcScansize;\n+\t    b = (int) ((i % destScansize) * rx);\n+\t    if ((a + b + srcOffset) < srcPixels.length)\n+\t\tdestPixels[i] = srcPixels[a + b + srcOffset];\n+\t}\n+\n+\treturn destPixels;\n+    }\n }\n "}, {"sha": "6c3579c8dede4562bfe0d8510b6792c7107608f8", "filename": "libjava/javax/swing/Box.java", "status": "modified", "additions": 127, "deletions": 2, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FBox.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FBox.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FBox.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -39,6 +39,12 @@\n package javax.swing;\n \n import javax.accessibility.Accessible;\n+import javax.accessibility.AccessibleContext;\n+import javax.accessibility.AccessibleRole;\n+import java.awt.LayoutManager;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.AWTError;\n \n /**\n  * Needs some work I guess....\n@@ -49,8 +55,127 @@ public class Box extends JComponent implements Accessible\n {\n   private static final long serialVersionUID = 1525417495883046342L;\n   \n-  public Box(int a)\n+  protected class AccessibleBox extends AccessibleAWTContainer\n   {\n-    setLayout(new BoxLayout(this, a));\t\n+    protected AccessibleBox()\n+    {\n+    }\n+    \n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return null;\n+    }\n   }\n+  \n+  public static class Filler extends JComponent implements Accessible\n+  {\n+    protected class AccessibleBoxFiller// extends AccessibleAWTComponent\n+    {\n+      protected AccessibleBoxFiller()\n+      {\n+      }\n+      \n+      public AccessibleRole getAccessibleRole()\n+      {\n+        return null;\n+      }\n+    }\n+    \n+    protected AccessibleContext accessibleContext;\n+    \n+    private transient Dimension min, pref, max;\n+    \n+    public Filler(Dimension min, Dimension pref, Dimension max)\n+    {\n+      changeShape(min, pref, max);\n+    }\n+    \n+    public void changeShape(Dimension min, Dimension pref, Dimension max)\n+    {\n+      this.min = min;\n+      this.pref = pref;\n+      this.max = max;    \n+    }\n+    \n+    public AccessibleContext getAccessibleContext()\n+    {\n+//      if (accessibleContext == null)\n+//        accessibleContext = new AccessibleBoxFiller();\n+      return accessibleContext;\n+    }\n+    \n+    public Dimension getMaximumSize()\n+    {\n+      return max;\n+    }\n+    \n+    public Dimension getMinimumSize()\n+    {\n+      return min;\n+    }\n+    \n+    public Dimension getPreferredSize()\n+    {\n+      return pref;\n+    }\n+  }\n+  \n+  public Box(int axis)\n+  {\n+    setLayout(new BoxLayout(this, axis));\t\n+  }\n+  \n+  public static Component createGlue()\n+  {\n+    return null;\n+  }\n+  \n+  public static Box createHorizontalBox()\n+  {\n+    return null;\n+  }\n+  \n+  public static Component createHorizontalGlue()\n+  {\n+    return null;\n+  }\n+  \n+  public static Component createHorizontalStrut(int width)\n+  {\n+    return null;\n+  }\n+  \n+  public static Component createRigidArea(Dimension d)\n+  {\n+    return null;\n+  }\n+  \n+  public static Box createVerticalBox()\n+  {\n+    return null;\n+  }\n+  \n+  public static Component createVerticalGlue()\n+  {\n+    return null;\n+  }\n+  \n+  public static Component createVerticalStrut(int height)\n+  {\n+    return null;\n+  }\n+  \n+  public void setLayout(LayoutManager l)\n+  {\n+    throw new AWTError(\"Not allowed to set layout managers for boxes.\");\n+  }\n+  \n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleBox();\n+    return accessibleContext;\n+  }\n+  \n+  \n }"}, {"sha": "43ce3e2f10772cc1e7d7192ff8c6d44b0e9777e0", "filename": "libjava/javax/swing/JApplet.java", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJApplet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJApplet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJApplet.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -49,7 +49,7 @@\n import java.awt.event.WindowEvent;\n import javax.accessibility.AccessibleContext;\n \n-public class JApplet extends Applet\n+public class JApplet extends Applet implements RootPaneContainer\n {\n \n     public final static int HIDE_ON_CLOSE        = 0;\n@@ -87,20 +87,20 @@ public Dimension getPreferredSize()\n   public  void setLayout(LayoutManager manager)\n   {    super.setLayout(manager);  }\n \n-    void setLayeredPane(JLayeredPane layeredPane) \n+   public void setLayeredPane(JLayeredPane layeredPane) \n     {   getRootPane().setLayeredPane(layeredPane);   }\n   \n-    JLayeredPane getLayeredPane()\n+   public JLayeredPane getLayeredPane()\n     {   return getRootPane().getLayeredPane();     }\n   \n-    JRootPane getRootPane()\n+   public JRootPane getRootPane()\n     {\n         if (rootPane == null)\n             setRootPane(createRootPane());\n         return rootPane;          \n     }\n \n-    void setRootPane(JRootPane root)\n+   public void setRootPane(JRootPane root)\n     {\n         if (rootPane != null)\n             remove(rootPane);\n@@ -109,19 +109,19 @@ void setRootPane(JRootPane root)\n         add(rootPane, BorderLayout.CENTER);\n     }\n \n-    JRootPane createRootPane()\n+   public JRootPane createRootPane()\n     {   return new JRootPane();    }\n \n-    Container getContentPane()\n+   public Container getContentPane()\n     {    return getRootPane().getContentPane();     }\n \n-    void setContentPane(Container contentPane)\n+   public void setContentPane(Container contentPane)\n     {    getRootPane().setContentPane(contentPane);    }\n   \n-    Component getGlassPane()\n+   public  Component getGlassPane()\n     {    return getRootPane().getGlassPane();   }\n   \n-    void setGlassPane(Component glassPane)\n+   public void setGlassPane(Component glassPane)\n     {   getRootPane().setGlassPane(glassPane);   }\n \n "}, {"sha": "f2399e2d8b3389e6ca14461d0f0d1bc9a1893119", "filename": "libjava/javax/swing/JCheckBoxMenuItem.java", "status": "modified", "additions": 124, "deletions": 49, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -39,135 +39,210 @@\n \n import java.io.IOException;\n import java.io.ObjectOutputStream;\n-\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n \n \n+/**\n+ * DOCUMENT ME!\n+ *\n+ * @author $author$\n+ * @version $Revision: 1.3.8.3 $\n+ */\n public class JCheckBoxMenuItem extends JMenuItem implements SwingConstants,\n                                                             Accessible\n {\n-  //-------------------------------------------------------------\n-  // Variables --------------------------------------------------\n-  //-------------------------------------------------------------\n   private static final String uiClassID = \"CheckBoxMenuItemUI\";\n   private boolean state;\n   private Object[] selectedObjects;\n \n-  //-------------------------------------------------------------\n-  // Initialization ---------------------------------------------\n-  //-------------------------------------------------------------\n+  /**\n+   * Creates a new JCheckBoxMenuItem object.\n+   */\n   public JCheckBoxMenuItem()\n   {\n     this(null, null);\n-  } // JCheckBoxMenuItem()\n+  }\n \n+  /**\n+   * Creates a new JCheckBoxMenuItem object.\n+   *\n+   * @param icon DOCUMENT ME!\n+   */\n   public JCheckBoxMenuItem(Icon icon)\n   {\n     this(null, icon);\n-  } // JCheckBoxMenuItem()\n+  }\n \n+  /**\n+   * Creates a new JCheckBoxMenuItem object.\n+   *\n+   * @param text DOCUMENT ME!\n+   */\n   public JCheckBoxMenuItem(String text)\n   {\n     this(text, null);\n-  } // JCheckBoxMenuItem()\n+  }\n \n+  /**\n+   * Creates a new JCheckBoxMenuItem object.\n+   *\n+   * @param action DOCUMENT ME!\n+   */\n   public JCheckBoxMenuItem(Action action)\n   {\n     this();\n     setAction(action);\n-  } // JCheckBoxMenuItem()\n-\n+  }\n+\n+  /**\n+   * Creates a new JCheckBoxMenuItem object.\n+   *\n+   * @param text DOCUMENT ME!\n+   * @param icon DOCUMENT ME!\n+   */\n   public JCheckBoxMenuItem(String text, Icon icon)\n   {\n     this(text, icon, false);\n-  } // JCheckBoxMenuItem()\n-\n+  }\n+\n+  /**\n+   * Creates a new JCheckBoxMenuItem object.\n+   *\n+   * @param text DOCUMENT ME!\n+   * @param state DOCUMENT ME!\n+   */\n   public JCheckBoxMenuItem(String text, boolean state)\n   {\n     this(text, null, state);\n-  } // JCheckBoxMenuItem()\n-\n+  }\n+\n+  /**\n+   * Creates a new JCheckBoxMenuItem object.\n+   *\n+   * @param text DOCUMENT ME!\n+   * @param icon DOCUMENT ME!\n+   * @param state DOCUMENT ME!\n+   */\n   public JCheckBoxMenuItem(String text, Icon icon, boolean state)\n   {\n     super(text, icon);\n     setModel(new JToggleButton.ToggleButtonModel());\n     this.state = state;\n-  } // JCheckBoxMenuItem()\n-\n-  //-------------------------------------------------------------\n-  // Methods ----------------------------------------------------\n-  //-------------------------------------------------------------\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param stream DOCUMENT ME!\n+   *\n+   * @throws IOException DOCUMENT ME!\n+   */\n   private void writeObject(ObjectOutputStream stream) throws IOException\n   {\n     // TODO\n-  } // writeObject()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public String getUIClassID()\n   {\n     return uiClassID;\n-  } // getUIClassID()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public boolean getState()\n   {\n     return state;\n-  } // getState()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param state DOCUMENT ME!\n+   */\n   public synchronized void setState(boolean state)\n   {\n     this.state = state;\n-  } // setState()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public Object[] getSelectedObjects()\n   {\n     return selectedObjects;\n-  } // getSelectedObjects()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   */\n   public void requestFocus()\n   {\n     // TODO\n-  } // requestFocus()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   protected String paramString()\n   {\n     return \"JCheckBoxMenuItem\";\n-  } // paramString()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      {\n-        accessibleContext = new AccessibleJCheckBoxMenuItem(this);\n-      }\n+      accessibleContext = new AccessibleJCheckBoxMenuItem(this);\n \n     return accessibleContext;\n-  } // getAccessibleContext()\n-\n-  //-------------------------------------------------------------\n-  // Classes ----------------------------------------------------\n-  //-------------------------------------------------------------\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.3.8.3 $\n+   */\n   protected class AccessibleJCheckBoxMenuItem extends AccessibleJMenuItem\n   {\n-    //-------------------------------------------------------------\n-    // Variables --------------------------------------------------\n-    //-------------------------------------------------------------\n-    //-------------------------------------------------------------\n-    // Initialization ---------------------------------------------\n-    //-------------------------------------------------------------\n+    /**\n+     * Creates a new AccessibleJCheckBoxMenuItem object.\n+     *\n+     * @param component DOCUMENT ME!\n+     */\n     protected AccessibleJCheckBoxMenuItem(JCheckBoxMenuItem component)\n     {\n       super(component);\n \n       // TODO\n-    } // AccessibleJCheckBoxMenuItem()\n+    }\n \n-    //-------------------------------------------------------------\n-    // Methods ----------------------------------------------------\n-    //-------------------------------------------------------------\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return $returnType$ DOCUMENT ME!\n+     */\n     public AccessibleRole getAccessibleRole()\n     {\n       return AccessibleRole.CHECK_BOX;\n-    } // getAccessibleRole()\n-  } // AccessibleJCheckBoxMenuItem\n-} // JCheckBoxMenuItem\n+    }\n+  }\n+}"}, {"sha": "b191635ea7769b375c2190199c17946db8ed6017", "filename": "libjava/javax/swing/JComponent.java", "status": "modified", "additions": 1725, "deletions": 928, "changes": 2653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJComponent.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -35,7 +35,6 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.awt.Color;\n@@ -55,6 +54,7 @@\n import java.awt.event.FocusEvent;\n import java.awt.event.FocusListener;\n import java.awt.event.MouseEvent;\n+import java.awt.geom.Rectangle2D;\n import java.awt.image.ImageObserver;\n import java.awt.peer.LightweightPeer;\n import java.beans.PropertyChangeListener;\n@@ -63,7 +63,8 @@\n import java.io.Serializable;\n import java.util.EventListener;\n import java.util.Hashtable;\n-\n+import java.util.Locale;\n+import java.util.Vector;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n@@ -74,242 +75,372 @@\n import javax.swing.event.SwingPropertyChangeSupport;\n import javax.swing.plaf.ComponentUI;\n \n+\n /**\n  * Every component in swing inherits from this class (JLabel, JButton, etc).\n- * It contains generic methods to manage events, properties and sizes.\n- * Actual drawing of the component is channeled to a look-and-feel class\n- * that is implemented elsewhere.\n+ * It contains generic methods to manage events, properties and sizes. Actual\n+ * drawing of the component is channeled to a look-and-feel class that is\n+ * implemented elsewhere.\n  *\n- * @author Ronald Veldema (rveldema@cs.vu.nl)\n+ * @author Ronald Veldema (rveldema&064;cs.vu.nl)\n+ * @author Graydon Hoare (graydon&064;redhat.com)\n  */\n public abstract class JComponent extends Container implements Serializable\n {\n   static final long serialVersionUID = -5242478962609715464L;\n \n-  protected EventListenerList listenerList = new EventListenerList();\n-  \n-  /**\n-   * accessibleContext\n+  /** \n+   * Accessibility support is currently missing.\n    */\n+\n   protected AccessibleContext accessibleContext;\n-  \n-  Dimension pref,min,max;\n+\n+  public abstract class AccessibleJComponent \n+    extends AccessibleAWTContainer\n+  {\n+    protected class AccessibleFocusHandler \n+      implements FocusListener\n+    {\n+      protected AccessibleFocusHandler(AccessibleJComponent component){}\n+      public void focusGained(FocusEvent event){}\n+      public void focusLost(FocusEvent valevent){}\n+    }\n+\n+    protected class AccessibleContainerHandler \n+      implements ContainerListener\n+    {\n+      protected AccessibleContainerHandler(AccessibleJComponent component) {}\n+      public void componentAdded(ContainerEvent event) {}\n+      public void componentRemoved(ContainerEvent valevent) {}\n+    }\n+\n+    protected ContainerListener accessibleContainerHandler;\n+    protected FocusListener accessibleFocusHandler;\n+\n+    protected AccessibleJComponent(JComponent component) {}\n+    public void addPropertyChangeListener(PropertyChangeListener listener) {}\n+    public void removePropertyChangeListener(PropertyChangeListener listener) {}\n+    public int getAccessibleChildrenCount() { return 0; }\n+    public Accessible getAccessibleChild(int value0) { return null; }\n+    public AccessibleStateSet getAccessibleStateSet() { return null; } \n+    public String getAccessibleName() { return null; }\n+    public String getAccessibleDescription() { return null; }\n+    public AccessibleRole getAccessibleRole() { return null; }\n+    protected String getBorderTitle(Border value0) { return null; }\n+  }\n+\n+  /** \n+   * An explicit value for the component's preferred size; if not set by a\n+   * user, this is calculated on the fly by delegating to the {@link\n+   * ComponentUI.getPreferredSize} method on the {@link #ui} property. \n+   */\n+  Dimension preferredSize;\n+\n+  /** \n+   * An explicit value for the component's minimum size; if not set by a\n+   * user, this is calculated on the fly by delegating to the {@link\n+   * ComponentUI.getMinimumSize} method on the {@link #ui} property. \n+   */\n+  Dimension minimumSize;\n+\n+  /** \n+   * An explicit value for the component's maximum size; if not set by a\n+   * user, this is calculated on the fly by delegating to the {@link\n+   * ComponentUI.getMaximumSize} method on the {@link #ui} property.\n+   */\n+  Dimension maximumSize;\n+\n+\n+  /**\n+   * A value between 0.0 and 1.0 indicating the preferred horizontal\n+   * alignment of the component, relative to its siblings. The values\n+   * {@link #LEFT_ALIGNMENT}, {@link #CENTER_ALIGNMENT}, and {@link\n+   * #RIGHT_ALIGNMENT} can also be used, as synonyms for <code>0.0</code>,\n+   * <code>0.5</code>, and <code>1.0</code>, respectively. Not all layout\n+   * managers use this property.\n+   *\n+   * @see #getAlignmentX\n+   * @see #setAlignmentX\n+   * @see javax.swing.OverlayLayout\n+   * @see javax.swing.BoxLayout\n+   */\n+  float alignmentX = 0.0f;\n+\n+  /**\n+   * A value between 0.0 and 1.0 indicating the preferred vertical\n+   * alignment of the component, relative to its siblings. The values\n+   * {@link #TOP_ALIGNMENT}, {@link #CENTER_ALIGNMENT}, and {@link\n+   * #BOTTOM_ALIGNMENT} can also be used, as synonyms for <code>0.0</code>,\n+   * <code>0.5</code>, and <code>1.0</code>, respectively. Not all layout\n+   * managers use this property.\n+   *\n+   * @see #getAlignmentY\n+   * @see #setAlignmentY\n+   * @see javax.swing.OverlayLayout\n+   * @see javax.swing.BoxLayout\n+   */\n+  float alignmentY = 0.0f;\n+\n+  /** \n+   * The border painted around this component.\n+   * \n+   * @see #paintBorder\n+   */\n   Border border;\n-  JToolTip tooltip;\n-  String tool_tip_text;\n-  boolean use_double_buffer = false, opaque;\n-  Image doubleBuffer;\n-  int doubleBufferWidth = -1;\n-  int doubleBufferHeight = -1;\n+\n+  /** \n+   * A tooltip associated with this component. \n+   * \n+   * @see #setToolTip\n+   * @see #getToolTip\n+   * @see #toolTipText\n+   */\n+  JToolTip toolTip;\n+\n+  /** \n+   * The text to show in the tooltip associated with this component. \n+   * \n+   * @see #setToolTipText\n+   * @see #getToolTipText\n+   * @see #toolTip\n+   */\n+  String toolTipText;\n+\n+  /** \n+   * <p>Whether to double buffer this component when painting. This flag\n+   * should generally be <code>false</code>, except for top level\n+   * components such as {@link JFrame} or {@link JApplet}.</p>\n+   *\n+   * <p>All children of a double buffered component are painted into the\n+   * double buffer automatically, so only the top widget in a window needs\n+   * to be double buffered.</p>\n+   *\n+   * @see #setDoubleBuffered\n+   * @see #isDoubleBuffered\n+   * @see #paintLock\n+   * @see #paint\n+   */\n+  boolean doubleBuffered = false;\n+\n+  /**\n+   * A set of flags indicating which debugging graphics facilities should\n+   * be enabled on this component. The values should be a combination of\n+   * {@link DebugGraphics.NONE_OPTION}, {@link DebugGraphics.LOG_OPTION},\n+   * {@link DebugGraphics.FLASH_OPTION}, or {@link\n+   * DebugGraphics.BUFFERED_OPTION}.\n+   *\n+   * @see setDebugGraphicsOptions\n+   * @see getDebugGraphicsOptions\n+   * @see DebugGraphics\n+   * @see getComponentGraphics\n+   */\n+  int debugGraphicsOptions;\n+\n+  /** \n+   * <p>This property controls two independent behaviors simultaneously.</p>\n+   *\n+   * <p>First, it controls whether to fill the background of this widget\n+   * when painting its body. This affects calls to {@link\n+   * JComponent#paintComponent}, which in turn calls {@link\n+   * ComponentUI#update} on the component's {@link #ui} property. If the\n+   * component is opaque during this call, the background will be filled\n+   * before calling {@link ComponentUI#paint}. This happens merely as a\n+   * convenience; you may fill the component's background yourself too,\n+   * but there is no need to do so if you will be filling with the same\n+   * color.</p>\n+   *\n+   * <p>Second, it the opaque property informs swing's repaint system\n+   * whether it will be necessary to paint the components \"underneath\" this\n+   * component, in Z-order. If the component is opaque, it is considered to\n+   * completely occlude components \"underneath\" it, so they will not be\n+   * repainted along with the opaque component.</p>\n+   *\n+   * <p>The default value for this property is <code>false</code>, but most\n+   * components will want to set it to <code>true</code> when installing UI\n+   * defaults in {@link ComponentUI#installUI}.</p>\n+   *\n+   * @see #setOpaque\n+   * @see #isOpaque\n+   * @see #paintComponent\n+   */\n+  boolean opaque = false;\n+\n+  /** \n+   * The user interface delegate for this component. Event delivery and\n+   * repainting of the component are usually delegated to this object. \n+   *\n+   * @see #setUI\n+   * @see #getUI\n+   * @see #updateUI\n+   */\n   ComponentUI ui;\n+\n+  /**\n+   * A hint to the focus system that this component should or should not\n+   * get focus. If this is <code>false</code>, swing will not try to\n+   * request focus on this component; if <code>true</code>, swing might\n+   * try to request focus, but the request might fail. Thus it is only \n+   * a hint guiding swing's behavior.\n+   *\n+   * @see #requestFocus\n+   * @see #isRequestFocusEnabled\n+   * @see #setRequestFocusEnabled\n+   */\n+  boolean requestFocusEnabled;\n+\n+  /**\n+   * Flag indicating behavior of this component when the mouse is dragged\n+   * outside the component and the mouse <em>stops moving</em>. If\n+   * <code>true</code>, synthetic mouse events will be delivered on regular\n+   * timed intervals, continuing off in the direction the mouse exited the\n+   * component, until the mouse is released or re-enters the component.\n+   *\n+   * @see setAutoscrolls\n+   * @see getAutoscrolls\n+   */\n+  boolean autoscrolls = false;\n+\n+  /**\n+   * Listeners for events other than {@link PropertyChangeEvent} are\n+   * handled by this listener list. PropertyChangeEvents are handled in\n+   * {@link #changeSupport}.\n+   */\n+  EventListenerList listenerList = new EventListenerList();\n+\n+  /** \n+   * Support for {@link PropertyChangeEvent} events. This is constructed\n+   * lazily when the component gets its first {@link\n+   * PropertyChangeListener} subscription; until then it's an empty slot.\n+   */\n   private SwingPropertyChangeSupport changeSupport;\n+\n+\n+  /** \n+   * Storage for \"client properties\", which are key/value pairs associated\n+   * with this component by a \"client\", such as a user application or a\n+   * layout manager. This is lazily constructed when the component gets its\n+   * first client property.\n+   */\n+  private Hashtable clientProperties;\n+\n+  /** \n+   * A lock held during recursive painting; this is used to serialize\n+   * access to the double buffer, and also to select the \"top level\" \n+   * object which should acquire the double buffer in a given widget\n+   * tree (which may have multiple double buffered children).\n+   *\n+   * @see #doubleBuffered\n+   * @see #paint\n+   */\n+  private static final Object paintLock = new Object();\n+\n+\n+  /**\n+   * The default locale of the component.\n+   * \n+   * @see #getDefaultLocale\n+   * @see #setDefaultLocale\n+   */\n+  private static Locale defaultLocale;\n   \n-  Hashtable prop_hash;\n-  \n \n-\t/**\n-\t * AccessibleJComponent\n-\t */\n-\tpublic abstract class AccessibleJComponent \n-\t\textends AccessibleAWTContainer {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Classes ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * AccessibleFocusHandler\n-\t\t */\n-\t\tprotected class AccessibleFocusHandler implements FocusListener {\n-\t\t\t/**\n-\t\t\t * Constructor AccessibleFocusHandler\n-\t\t\t * @param component TODO\n-\t\t\t */\n-\t\t\tprotected AccessibleFocusHandler(AccessibleJComponent component) {\n-\t\t\t\t// TODO\n-\t\t\t} // AccessibleFocusHandler()\n-\n-\t\t\t/**\n-\t\t\t * focusGained\n-\t\t\t * @param event TODO\n-\t\t\t */\n-\t\t\tpublic void focusGained(FocusEvent event) {\n-\t\t\t\t// TODO\n-\t\t\t} // focusGained()\n-\n-\t\t\t/**\n-\t\t\t * focusLost\n-\t\t\t * @param event TODO\n-\t\t\t */\n-\t\t\tpublic void focusLost(FocusEvent valevent) {\n-\t\t\t\t// TODO\n-\t\t\t} // focusLost()\n-\t\t} // AccessibleFocusHandler\n-\n-\t\t/**\n-\t\t * AccessibleContainerHandler\n-\t\t */\n-\t\tprotected class AccessibleContainerHandler implements ContainerListener {\n-\t\t\t/**\n-\t\t\t * Constructor AccessibleContainerHandler\n-\t\t\t * @param component TODO\n-\t\t\t */\n-\t\t\tprotected AccessibleContainerHandler(AccessibleJComponent component) {\n-\t\t\t\t// TODO\n-\t\t\t} // AccessibleContainerHandler()\n-\n-\t\t\t/**\n-\t\t\t * componentAdded\n-\t\t\t * @param event TODO\n-\t\t\t */\n-\t\t\tpublic void componentAdded(ContainerEvent event) {\n-\t\t\t\t// TODO\n-\t\t\t} // componentAdded()\n-\n-\t\t\t/**\n-\t\t\t * componentRemoved\n-\t\t\t * @param event TODO\n-\t\t\t */\n-\t\t\tpublic void componentRemoved(ContainerEvent valevent) {\n-\t\t\t\t// TODO\n-\t\t\t} // componentRemoved()\n-\t\t} // AccessibleContainerHandler\n-\n-\t\t/**\n-\t\t * accessibleContainerHandler\n-\t\t */\n-\t\tprotected ContainerListener accessibleContainerHandler;\n-\n-\t\t/**\n-\t\t * accessibleFocusHandler\n-\t\t */\n-\t\tprotected FocusListener accessibleFocusHandler;\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJComponent\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJComponent(JComponent component) {\n-//\t\t\tsuper((Container)component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJComponent()\n-\n-\t\t/**\n-\t\t * addPropertyChangeListener\n-\t\t * @param listener TODO\n-\t\t */\n-\t\tpublic void addPropertyChangeListener(PropertyChangeListener listener) { \n-\t\t\t// TODO\n-\t\t} // addPropertyChangeListener()\n-\n-\t\t/**\n-\t\t * removePropertyChangeListener\n-\t\t * @param listener TODO\n-\t\t */\n-\t\tpublic void removePropertyChangeListener(PropertyChangeListener listener) {\n-\t\t\t// TODO\n-\t\t} // removePropertyChangeListener()\n-\n-\t\t/**\n-\t\t * getAccessibleChildrenCount\n-\t\t * @returns int\n-\t\t */\n-\t\tpublic int getAccessibleChildrenCount() {\n-\t\t\treturn 0; // TODO\n-\t\t} // getAccessibleChildrenCount()\n-\n-\t\t/**\n-\t\t * getAccessibleChild\n-\t\t * @param value0 TODO\n-\t\t * @returns Accessible\n-\t\t */\n-\t\tpublic Accessible getAccessibleChild(int value0) {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleChild()\n-\n-\t\t/**\n-\t\t * getAccessibleStateSet\n-\t\t * @returns AccessibleStateSet\n-\t\t */\n-\t\tpublic AccessibleStateSet getAccessibleStateSet() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleStateSet()\n-\n-\t\t/**\n-\t\t * getAccessibleName\n-\t\t * @returns String\n-\t\t */\n-\t\tpublic String getAccessibleName() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleName()\n-\n-\t\t/**\n-\t\t * getAccessibleDescription\n-\t\t * @returns String\n-\t\t */\n-\t\tpublic String getAccessibleDescription() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleDescription()\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleRole()\n-\n-\t\t/**\n-\t\t * getBorderTitle\n-\t\t * @param value0 TODO\n-\t\t * @returns String\n-\t\t */\n-\t\tprotected String getBorderTitle(Border value0) {\n-\t\t\treturn null; // TODO\n-\t\t} // getBorderTitle()\n-\n-\n-\t} // AccessibleJComponent\n-\n-\n-        public JComponent()\n-\t{\n-\t\tsuper();\n-\t\tsuper.setLayout(new FlowLayout());\n-\t\t\n-\t\t//eventMask |= AWTEvent.COMP_KEY_EVENT_MASK;\n-\t\t// enableEvents( AWTEvent.KEY_EVENT_MASK );\n-\n-\t\t//updateUI(); // get a proper ui\n-\t}\n-\n-\tpublic boolean contains(int x, int y)\n-\t{\n-\t\t//return dims.contains(x,y);\n-\t\treturn super.contains(x,y);\n-\t}\n-\n-\tpublic  void addNotify()\n-\t{\n-\t\t//Notification to this component that it now has a parent component.\n-\t\tsuper.addNotify();\n-\t}\n-\n-\tHashtable get_prop_hash()\n-\t{\n-\t\tif (prop_hash == null)\n-\t\t\tprop_hash = new Hashtable();\n-\t\treturn prop_hash;\n-\t}\n-\n-\tpublic Object getClientProperty(Object key)\n-        {\treturn get_prop_hash().get(key);    }\n-\n-\tpublic void putClientProperty(Object key, Object value)\n-\t{    get_prop_hash().put(key, value);   }\n+  /**\n+   * Constant used to indicate that no condition has been assigned to a\n+   * particular action.\n+   *\n+   * @see #registerKeyboardAction\n+   */\n+  public static final int UNDEFINED_CONDITION = -1;\n+\n+  /**\n+   * Constant used to indicate that an action should be performed only when \n+   * the component has focus.\n+   *\n+   * @see #registerKeyboardAction\n+   */\n+  public static final int WHEN_FOCUSED = 0;\n+\n+  /**\n+   * Constant used to indicate that an action should be performed only when \n+   * the component is an ancestor of the component which has focus.\n+   *\n+   * @see #registerKeyboardAction\n+   */\n+  public static final int WHEN_ANCESTOR_OF_FOCUSED_COMPONENT = 1;\n+\n+  /**\n+   * Constant used to indicate that an action should be performed only when \n+   * the component is in the window which has focus.\n+   *\n+   * @see #registerKeyboardAction\n+   */\n+  public static final int WHEN_IN_FOCUSED_WINDOW = 2;\n+\n+\n+  public JComponent()\n+  {\n+    super();\n+    super.setLayout(new FlowLayout());\n+    defaultLocale = Locale.getDefault();\n+    debugGraphicsOptions = DebugGraphics.NONE_OPTION;\n+  }\n+\n+  /**\n+   * Helper to lazily construct and return the client properties table.\n+   * \n+   * @return The current client properties table\n+   *\n+   * @see #clientProperties\n+   * @see #getClientProperty\n+   * @see #putClientProperty\n+   */\n+  private Hashtable getClientProperties()\n+  {\n+    if (clientProperties == null)\n+      clientProperties = new Hashtable();\n+    return clientProperties;\n+  }\n+\n+  /**\n+   * Get a client property associated with this component and a particular\n+   * key.\n+   *\n+   * @param key The key with which to look up the client property\n+   *\n+   * @return A client property associated with this object and key\n+   *\n+   * @see #clientProperties\n+   * @see #getClientProperties\n+   * @see #putClientProperty\n+   */\n+  public Object getClientProperty(Object key)\n+  {\n+    return getClientProperties().get(key);\n+  }\n+\n+  /**\n+   * Add a client property <code>value</code> to this component, associated\n+   * with <code>key</code>. If there is an existing client property\n+   * associated with <code>key</code>, it will be replaced.\n+   *\n+   * @param key The key of the client property association to add\n+   * @param value The value of the client property association to add\n+   *\n+   * @see #clientProperties\n+   * @see #getClientProperties\n+   * @see #getClientProperty\n+   */\n+  public void putClientProperty(Object key, Object value)\n+  {\n+    getClientProperties().put(key, value);\n+  }\n \n   /**\n    * Unregister an <code>AncestorListener</code>.\n+   *\n+   * @param listener The listener to unregister\n+   * \n+   * @see addAncestorListener\n    */\n   public void removeAncestorListener(AncestorListener listener)\n   {\n@@ -318,6 +449,11 @@ public void removeAncestorListener(AncestorListener listener)\n \n   /**\n    * Unregister a <code>PropertyChangeListener</code>.\n+   *\n+   * @param listener The listener to register\n+   *\n+   * @see #addPropertyChangeListener\n+   * @see #changeSupport\n    */\n   public void removePropertyChangeListener(PropertyChangeListener listener)\n   {\n@@ -327,14 +463,26 @@ public void removePropertyChangeListener(PropertyChangeListener listener)\n \n   /**\n    * Unregister a <code>PropertyChangeListener</code>.\n+   *\n+   * @param propertyName The property name to unregister the listener from\n+   * @param listener The listener to unregister\n+   *\n+   * @see #addPropertyChangeListener\n+   * @see #changeSupport\n    */\n-  public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener)\n+  public void removePropertyChangeListener(String propertyName,\n+                                           PropertyChangeListener listener)\n   {\n-    listenerList.remove(PropertyChangeListener.class, listener);\n+    if (changeSupport != null)\n+      changeSupport.removePropertyChangeListener(propertyName, listener);\n   }\n \n   /**\n    * Unregister a <code>VetoableChangeChangeListener</code>.\n+   *\n+   * @param listener The listener to unregister\n+   *\n+   * @see #addVetoableChangeListener\n    */\n   public void removeVetoableChangeListener(VetoableChangeListener listener)\n   {\n@@ -343,14 +491,26 @@ public void removeVetoableChangeListener(VetoableChangeListener listener)\n \n   /**\n    * Register an <code>AncestorListener</code>.\n+   *\n+   * @param listener The listener to register\n+   *\n+   * @see #removeVetoableChangeListener\n    */\n   public void addAncestorListener(AncestorListener listener)\n   {\n     listenerList.add(AncestorListener.class, listener);\n   }\n \n   /**\n-   * Register a <code>PropertyChangeListener</code>.\n+   * Register a <code>PropertyChangeListener</code>. This listener will\n+   * receive any PropertyChangeEvent, regardless of property name. To\n+   * listen to a specific property name, use {@link\n+   * #addPropertyChangeListener(String,PropertyChangeListener)} instead.\n+   *\n+   * @param listener The listener to register\n+   *\n+   * @see #removePropertyChangeListener\n+   * @see #changeSupport\n    */\n   public void addPropertyChangeListener(PropertyChangeListener listener)\n   {\n@@ -360,738 +520,1375 @@ public void addPropertyChangeListener(PropertyChangeListener listener)\n   }\n \n   /**\n-   * Register a <code>PropertyChangeListener</code>.\n+   * Register a <code>PropertyChangeListener</code> for a specific, named\n+   * property. To listen to all property changes, regardless of name, use\n+   * {@link #addPropertyChangeListener(PropertyChangeListener)} instead.\n+   *\n+   * @param propertyName The property name to listen to\n+   * @param listener The listener to register\n+   *\n+   * @see #removePropertyChangeListener\n+   * @see #changeSupport\n    */\n-  public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener)\n+  public void addPropertyChangeListener(String propertyName,\n+                                        PropertyChangeListener listener)\n   {\n     listenerList.add(PropertyChangeListener.class, listener);\n   }\n \n   /**\n    * Register a <code>VetoableChangeListener</code>.\n+   *\n+   * @param listener The listener to register\n+   *\n+   * @see #removeVetoableChangeListener\n+   * @see #listenerList\n    */\n   public void addVetoableChangeListener(VetoableChangeListener listener)\n   {\n     listenerList.add(VetoableChangeListener.class, listener);\n   }\n \n   /**\n-   * Return all registered listeners of a special type.\n-   * \n-   * @since 1.3\n+   * Return all registered listeners of a particular type.\n+   *\n+   * @param listenerType The type of listener to return\n+   *\n+   * @return All listeners in the {@link #listenerList} which \n+   * are of the specified type\n+   *\n+   * @see #listenerList\n    */\n-  public EventListener[] getListeners (Class listenerType)\n+  public EventListener[] getListeners(Class listenerType)\n   {\n-    return listenerList.getListeners (listenerType);\n+    return listenerList.getListeners(listenerType);\n   }\n-  \n+\n   /**\n-   * Return all registered <code>Ancestor</code> objects.\n-   * \n-   * @since 1.4\n+   * Return all registered <code>AncestorListener</code> objects.\n+   *\n+   * @return The set of <code>AncestorListener</code> objects in {@link\n+   * #listenerList}\n    */\n   public AncestorListener[] getAncestorListeners()\n   {\n-    return (AncestorListener[]) getListeners (AncestorListener.class);\n+    return (AncestorListener[]) getListeners(AncestorListener.class);\n   }\n \n   /**\n    * Return all registered <code>VetoableChangeListener</code> objects.\n-   * \n-   * @since 1.4\n+   *\n+   * @return The set of <code>VetoableChangeListener</code> objects in {@link\n+   * #listenerList}\n    */\n   public VetoableChangeListener[] getVetoableChangeListeners()\n   {\n-    return (VetoableChangeListener[]) getListeners (VetoableChangeListener.class);\n-  }\n-\n-\tpublic void computeVisibleRect(Rectangle rect)\n-\t{\n-\t\t//Returns the Component's \"visible rect rectangle\" - the intersection of the visible rectangles for this component and all of its ancestors.\n-\t\t//super.computeVisibleRect(rect);\n-\t}\n-\t\n-        public PropertyChangeListener[] getPropertyChangeListeners(String property)\n-        {\n-          return changeSupport == null ? new PropertyChangeListener[0]\n-                 : changeSupport.getPropertyChangeListeners(property);\n-        }\t\n-\n-\tpublic void firePropertyChange(String propertyName, boolean oldValue, boolean newValue)\n-\t{\n-          if (changeSupport != null)\n-            changeSupport.firePropertyChange(propertyName, new Boolean(oldValue), \n-\t                                     new Boolean(newValue));\n-\t}\n-\tpublic void firePropertyChange(String propertyName, byte oldValue, byte newValue)\n-\t{\n-          if (changeSupport != null)\n-            changeSupport.firePropertyChange(propertyName, new Byte(oldValue), \n-\t                                     new Byte(newValue));\n-\t}\n-\tpublic void firePropertyChange(String propertyName, char oldValue, char newValue)\n-\t{\n-          if (changeSupport != null)\n-            changeSupport.firePropertyChange(propertyName, new Character(oldValue), \n-\t                                     new Character(newValue));\n-\t}\n-\n-\tpublic void firePropertyChange(String propertyName, double oldValue, double newValue)\n-\t{\n-          if (changeSupport != null)\n-            changeSupport.firePropertyChange(propertyName, new Double(oldValue), \n-\t                                     new Double(newValue));\n-\t}\n-\n-\tpublic void firePropertyChange(String propertyName, float oldValue, float newValue)\n-\t{\n-          if (changeSupport != null)\n-            changeSupport.firePropertyChange(propertyName, new Float(oldValue), \n-\t                                     new Float(newValue));\n-\t}\n-\tpublic void firePropertyChange(String propertyName, int oldValue, int newValue)\n-\t{\n-          if (changeSupport != null)\n-            changeSupport.firePropertyChange(propertyName, new Integer(oldValue), \n-\t                                     new Integer(newValue));\n-\t}\n-\tpublic void firePropertyChange(String propertyName, long oldValue, long newValue)\n-\t{\n-          if (changeSupport != null)\n-            changeSupport.firePropertyChange(propertyName, new Long(oldValue), \n-\t                                     new Long(newValue));\n-\t}\n-\n-        protected void firePropertyChange(String propertyName, Object oldValue, Object newValue)\n-\t{\n-          if (changeSupport != null)\n-            changeSupport.firePropertyChange(propertyName, oldValue, newValue);\n-\t}\n-\tpublic void firePropertyChange(String propertyName, short oldValue, short newValue)\n-\t{\n-          if (changeSupport != null)\n-            changeSupport.firePropertyChange(propertyName, new Short(oldValue), \n-\t                                     new Short(newValue));\n-\t}\n-\n-\tprotected  void fireVetoableChange(String propertyName, Object oldValue, Object newValue)\n-          throws PropertyVetoException\n-\t{\n-\t\t//       Support for reporting constrained property changes.\n-\t}\n-\n-        public AccessibleContext getAccessibleContext()\n-\t{\n-\t\t//       Get the AccessibleContext associated with this JComponent\n-\t\treturn null;\n-\t}\n-\t\n-        public ActionListener getActionForKeyStroke(KeyStroke aKeyStroke)\n-\t{\n-\t\t//Return the object that will perform the action registered for a given keystroke.\n-\t\treturn null;\n-\t}\n-\tpublic float getAlignmentX()\n-\t{\n-\t\t//    Overrides Container.getAlignmentX to return the vertical alignment.\n-\t\treturn 0;\n-\t}\n-\n-\tpublic float getAlignmentY()\n-\t{\n-\t\t//       Overrides Container.getAlignmentY to return the horizontal alignment.\n-\t\treturn 0;\n-\t}\n-\tpublic boolean getAutoscrolls()\n-\t{\n-\t\t//Returns true if this component automatically scrolls its contents when dragged, (when contained in a component that supports scrolling, like JViewport\n-\t\treturn false;\n-\t}\n-\n-\tpublic void setBorder(Border border)\n-\t{\n-\t\t//System.out.println(\"set border called !, new border = \" + border);\n-\t\tthis.border = border;\n-\t\trevalidate();\n-\t\trepaint();\n-\t}\n-\n-\tpublic Border getBorder()\n-\t{\treturn border;    }\n-\n-\n-        public Rectangle getBounds(Rectangle rv)\n-\t{\n-\t\tif (rv == null)\n-\t\t\treturn new Rectangle(getX(),getY(),getWidth(),getHeight());\n-\t\telse\n-\t\t{\n-\t\t\trv.setBounds(getX(),getY(),getWidth(),getHeight());\n-\t\t\treturn rv;\n-\t\t}\n-\t}\n-\n-\tprotected  Graphics getComponentGraphics(Graphics g)\n-\t{      return g;       }\n-\n-\tpublic int getConditionForKeyStroke(KeyStroke aKeyStroke)\n-\t{\n-\t\t//Return the condition that determines whether a registered action occurs in response to the specified keystroke.\n-\t\treturn 0;\n-\t}\n-\tpublic int getDebugGraphicsOptions()\n-\t{\n-\t\treturn 0;\n-\t}\n-\n-\tpublic Graphics getGraphics()\n-\t{\treturn super.getGraphics();    }\n-\n-\n-\t//    static MantaNative void DebugMe(Border b);\n-\n-\tpublic Insets getInsets()\n-\t{\n-\t\t//\tSystem.out.println(\"watch this border\");\n-\t\t//\tDebugMe(border);\n-\t\t//\tSystem.out.println(\"border = \" + border);\n-\n-\t\tif (border == null)\n-\t\t{\n-\t\t\t//System.out.println(\"compares to null !\");\n-\t\t\treturn super.getInsets();\n-\t\t}\n-\t\t//\tSystem.out.println(\"compare failed !\");\n-\t\treturn getBorder().getBorderInsets(this);\n-\t}\n-\n-\tpublic Insets getInsets(Insets insets)\n-\t{\n-\t    Insets t = getInsets();\n-\n-\t    if (insets == null)\n-\t\treturn t;\n-\t    \n-\t    \n-\t    return new Insets(t.top, t.left, t.bottom, t.right);\n-\t}\n-\tpublic Point getLocation(Point rv)\n-\t{\n-\t\t//Store the x,y origin of this component into \"return value\" rv and return rv.\n-\n-\t\tif (rv == null)\n-\t\t\treturn new Point(getX(),\n-\t\t\t\t\t getY());\n-\n-\t\trv.setLocation(getX(),\n-\t\t               getY());\n-\t\treturn rv;\n-\t}\n-\n-\tpublic Dimension getMaximumSize()\n-\t{\n-\t\tif (max != null)\n-\t\t{\n-\t\t\t//System.out.println(\"HAVE_MAX_SIZE =  \" + max);\n-\t\t\treturn max;\n-\t\t}\n-\t\tif (ui != null)\n-\t\t{\n-\t\t    Dimension s = ui.getMaximumSize(this);\n-\t\t    if (s != null)\n-\t\t\t{\n-\t\t\t\t//System.out.println(\"        UI-MAX = \" + s + \", UI = \" + ui + \", IM=\"+this);\n-\t\t\t\treturn s;\n-\t\t\t}\n-\t\t}\n-\t\tDimension p = super.getMaximumSize();\n-\t\t//System.out.println(\"               MAX = \" + p + \", COMP=\"+this);\n-\t\treturn p;\n-\t}\n-\n-\tpublic Dimension getMinimumSize()\n-\t{\n-\t\tif (min != null)\n-\t\t{\n-\t\t\t//System.out.println(\"HAVE_MIN_SIZE =  \" + min);\n-\t\t\treturn min;\n-\t\t}\n-\t\tif (ui != null)\n-\t\t{\n-\t\t\tDimension s = ui.getMinimumSize(this);\n-\t\t\tif (s != null)\n-\t\t\t{\n-\t\t\t\t//\tSystem.out.println(\"        UI-MIN = \" + s + \", UI = \" + ui + \", IM=\"+this);\n-\t\t\t\treturn s;\n-\t\t\t}\n-\t\t}\n-\t\tDimension p = super.getMinimumSize();\n-\t\t//\tSystem.out.println(\"              MIN = \" + p + \", COMP=\"+this);\n-\t\treturn p;\n-\t}\n-\n-\tpublic Dimension getPreferredSize()\n-\t{\n-\t\tif (pref != null)\n-\t\t{\n-\t\t\t//System.out.println(\"HAVE_PREF_SIZE =  \" + pref);\n-\t\t\treturn pref;\n-\t\t}\n-\n-\t\tif (ui != null)\n-\t\t{\n-\t\t\tDimension s = ui.getPreferredSize(this);\n-\t\t\tif (s != null)\n-\t\t\t{\n-\t\t\t\t//System.out.println(\"        UI-PREF = \" + s + \", UI = \" + ui + \", IM=\"+this);\n-\t\t\t\treturn s;\n-\t\t\t}\n-\t\t}\n-\t\tDimension p = super.getPreferredSize();\n-\t\t//\tSystem.out.println(\"              PREF = \" + p + \", COMP=\"+this);\n-\t\treturn p;\n-\t}\n-\n-\tpublic Component getNextFocusableComponent()\n-\t{\n-\t\t//          Return the next focusable component or null if the focus manager should choose the next focusable component automatically\n-\t\treturn null;\n-\t}\n-\n-\n-\tpublic KeyStroke[] getRegisteredKeyStrokes()\n-\t{\n-\t\t//          Return the KeyStrokes that will initiate registered actions.\n-\t\treturn null;\n-\t}\n-\n-\tpublic JRootPane getRootPane()\n-\t{\n-\t\tJRootPane p = SwingUtilities.getRootPane(this);\n-\t\tSystem.out.println(\"root = \" + p);\n-\t\treturn p;\n-\t}\n-\n-\tpublic Dimension getSize(Dimension rv)\n-\t{\n-\t\t//\tSystem.out.println(\"JComponent, getsize()\");\n-\t\tif (rv == null)\n-\t\t\treturn new Dimension(getWidth(),\n-\t\t\t                     getHeight());\n-\t\telse\n-\t\t{\n-\t\t\trv.setSize(getWidth(),\n-\t\t\t           getHeight());\n-\t\t\treturn rv;\n-\t\t}\n-\t}\n-\n-\tpublic JToolTip createToolTip()\n-\t{\n-\t\tif (tooltip == null)\n-\t\t\ttooltip = new JToolTip(tool_tip_text);\n-\t\treturn tooltip;\n-\t}\n-\n-\tpublic Point getToolTipLocation(MouseEvent event)\n-        {\treturn null;    }\n-\n-\tpublic void setToolTipText(String text)\n-\t{\ttool_tip_text = text;    }\n-\n-\tpublic String getToolTipText()\n-\t{\treturn tool_tip_text;    }\n-\n-\tpublic String getToolTipText(MouseEvent event)\n-\t{\treturn tool_tip_text;    }\n-\n-\tpublic Container getTopLevelAncestor()\n-\t{\n-\t\t//      Returns the top-level ancestor of this component (either the containing Window or Applet), or null if this component has not been added to any container.\n-\t\tSystem.out.println(\"JComponent, getTopLevelAncestor()\");\n-\t\treturn null;\n-\t}\n-\n-\tpublic Rectangle getVisibleRect()\n-\t{\n-\t\t///    Returns the Component's \"visible rectangle\" - the intersection of this components visible rectangle:\n-\t\tSystem.out.println(\"JComponent, getVisibleRect()\");\n-\t\treturn null;\n-\t}\n-\n-\tpublic void grabFocus()\n-\t{\n-\t\t//      Set the focus on the receiving component.\n-\t}\n-\n-\tpublic boolean hasFocus()\n-\t{\n-\t\t//      Returns true if this Component has the keyboard focus.\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean isDoubleBuffered()\n-\t{\treturn use_double_buffer;    }\n-\n-\tpublic boolean isFocusCycleRoot()\n-\t{\n-\t\t//      Override this method and return true if your component is the root of of a component tree with its own focus cycle.\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean isFocusTraversable()\n-\t{\n-\t\t//      Identifies whether or not this component can receive the focus.\n-\t\treturn false;\n-\t}\n-\n-\tpublic static boolean isLightweightComponent(Component c)\n-\t{\n-\t\treturn c.getPeer() instanceof LightweightPeer;\n-\t}\n-\n-\tpublic boolean isManagingFocus()\n-\t{\n-\t\t//      Override this method and return true if your JComponent manages focus.\n-\t\treturn false;\n-\t}\n-\n-        public boolean isOpaque()\n-\t{\treturn opaque;    }\n-\n-\tpublic boolean isOptimizedDrawingEnabled()\n-\t{\n-\t\t//      Returns true if this component tiles its children,\n-\t\treturn true;\n-\t}\n-\n-\tpublic boolean isPaintingTile()\n-\t{\n-\t\t//      Returns true if the receiving component is currently painting a tile.\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean isRequestFocusEnabled()\n-\t{\n-\t\t//      Return whether the receiving component can obtain the focus by calling requestFocus\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean isValidateRoot()\n-\t{\n-\t\t//      If this method returns true, revalidate() calls by descendants of this component will cause the entire tree beginning with this root to be validated.\n-\t\treturn false;\n-\t}\n-\n-\tpublic void paint(Graphics g)\n-\t{\n-\t\tGraphics g2 = g;\n-\t\tRectangle r = getBounds ();\n-\t\t\n-\t\tif (use_double_buffer)\n-\t\t{\n-\n-                  if (doubleBuffer == null \n-                      || doubleBufferWidth != r.width \n-                      || doubleBufferHeight != r.height)\n-                    {\n-                      doubleBuffer = createImage(r.width, r.height);\n-                      doubleBufferWidth = r.width;\n-                      doubleBufferHeight = r.height;\n-                    }\n-\n-                  g2 = doubleBuffer.getGraphics ();\n-                  if (this.getBackground() != null)\n-                    {\n-                      Color save = g2.getColor();\n-                      g2.setColor(this.getBackground());\n-                      g2.fillRect (0, 0, r.width, r.height);\n-                      g2.setColor(save);\n-                    }\n-                  else\n-                    g2.clearRect(0, 0, r.width, r.height);\n-\t\t}\n-\t\t\n-\t\tpaintBorder(g2);\n-\t\tpaintComponent(g2);\n-\t\tpaintChildren(g2);\n-\n-\t\tif (use_double_buffer)\n-\t\t{\n-\t\t\t// always draw at 0,0, because regardless of your current bounds,\n-\t\t\t// the graphics object you were passed was positioned so the origin\n-\t\t\t// was at the upper left corner of your bounds.\n-\t\t\tg.drawImage (doubleBuffer, 0, 0, (ImageObserver)null);\n-\t\t}\n-\t}\n-\n-\tprotected  void paintBorder(Graphics g)\n-\t{\n-\t\t//\tSystem.out.println(\"PAINT_BORDER      x XXXXXXX x x x x x x x x x x x x:\" + getBorder() + \", THIS=\"+this);\n-\n-\t\t//       Paint the component's border.\n-\t\tif (getBorder() != null)\n-\t\t{\n-\t\t\t//System.out.println(\"PAINT_BORDER      x XXXXXXX x x x x x x x x x x x x:\" + getBorder() + \", THIS=\"+this);\n-\n-\t\t\tgetBorder().paintBorder(this,\n-\t\t\t                        g,\n-\t\t\t                        0,\n-\t\t\t                        0,\n-\t\t\t                        getWidth(),\n-\t\t\t                        getHeight());\n-\t\t}\n-\t}\n-\n-\tprotected  void paintChildren(Graphics g)\n-\t{\n-\t    //      Paint this component's children.\n-\t\tsuper.paint(g);\n-\t}\n-\n-\tprotected  void paintComponent(Graphics g)\n-\t{\n-\t\t//      If the UI delegate is non-null, call its paint method.\n-\t\tif (ui != null)\n-\t\t{\n-\t\t\tui.paint(g, this);\n-\t\t}\n-\t}\n-    \n-    /**\n-     * Paint the specified region in this component and all of \n-     * its descendants that overlap the region, immediately.\n-     */\n-\tpublic void paintImmediately(int x, int y, int w, int h)\n-        {\n-\t\n-\t    //Ronald: this shoudld probably redirect to the PLAF ....\n-\t}\n-\n-\tpublic void paintImmediately(Rectangle r)\n-\t{\n-\t    ///      Paint the specified region now.\n-\t    paintImmediately((int)r.getX(),\n-\t\t\t     (int)r.getY(),\n-\t\t\t     (int)r.getWidth(),\n-\t\t\t     (int)r.getHeight());\n-\t}\n-\tprotected  String paramString()\n-\t{\n-\t\t//      Returns a string representation of this JComponent.\n-\t\treturn \"JComponent\";\n-\t}\n-\n-\tpublic void registerKeyboardAction(ActionListener anAction,\n-\t                            KeyStroke aKeyStroke,\n-\t                            int aCondition)\n-\t{\n-\t\tregisterKeyboardAction(anAction,\n-\t\t                       null,\n-\t\t                       aKeyStroke,\n-\t\t                       aCondition);\n-\t}\n-\n-\tpublic void registerKeyboardAction(ActionListener anAction,\n-\t                            String aCommand,\n-\t                            KeyStroke aKeyStroke,\n-\t                            int aCondition)\n-\t{\n-\t\t//  Register a new keyboard action.\n-\t}\n-\n-\n-\tpublic void removeNotify()\n-\t{\n-\t\t//      Notification to this component that it no longer has a parent component.\n-\t}\n-\n-\tpublic void repaint(long tm, int x, int y, int width, int height)\n-\t{\n-\t\t//   Adds the specified region to the dirty region list if the component is showing.\n-\t\t//System.out.println(\"JC: repaint\");\n-\t\tsuper.repaint(tm, x,y,width,height);\n-\t}\n-\n-\tpublic void repaint(Rectangle r)\n-\t{\n-\t\t//      Adds the specified region to the dirty region list if the component is showing.\n-\t\trepaint((long)0,\n-\t\t        (int)r.getX(),\n-\t\t        (int)r.getY(),\n-\t\t        (int)r.getWidth(),\n-\t\t        (int)r.getHeight());\n-\t}\n-\n-\tpublic boolean requestDefaultFocus()\n-\t{\n-\t\t//      Request the focus for the component that should have the focus by default.\n-\t\treturn false;\n-\t}\n-\n-\tpublic void requestFocus()\n-\t{\n-\t\t//      Set focus on the receiving component if isRequestFocusEnabled returns true\n-\t\tsuper.requestFocus();\n-\t}\n-\n-\tpublic void resetKeyboardActions()\n-\t{\n-\t\t//      Unregister all keyboard actions\n-\t}\n-\n-\tpublic void reshape(int x, int y, int w, int h)\n-\t{\n-\t\t///      Moves and resizes this component.\n-\t\tsuper.reshape(x,y,w,h);\n-\t}\n-\n-\tpublic void revalidate()\n-\t{\n-\t\t//     Support for deferred automatic layout.\n-\t\tif (getParent() == null)\n-\t\t\tinvalidate();\n-\t}\n-\n-\tpublic void scrollRectToVisible(Rectangle aRect)\n-\t{\n-\t\t//      Forwards the scrollRectToVisible() message to the JComponent's parent.\n-\t}\n-\n-\tpublic void setAlignmentX(float alignmentX)\n-\t{\n-\t\t//      Set the the vertical alignment.\n-\t}\n-\n-\tpublic void setAlignmentY(float alignmentY)\n-\t{\n-\t\t//      Set the the horizontal alignment.\n-\t}\n-\n-\tpublic void setAutoscrolls(boolean autoscrolls)\n-\t{\n-\t\t//      If true this component will automatically scroll its contents when dragged, if contained in a component that supports scrolling, such as JViewport\n-\t}\n-\n-\tpublic void setDebugGraphicsOptions(int debugOptions)\n-\t{\n-\t\t//      Enables or disables diagnostic information about every graphics operation performed within the component or one of its children.\n-\t}\n-\n-\tpublic void setDoubleBuffered(boolean aFlag)\n-\t{\n-\t\tuse_double_buffer = aFlag;\n-\t}\n-\n-\tpublic void setEnabled(boolean enabled)\n-\t{\n-\t\t// Sets whether or not this component is enabled.\n-\t\tsuper.setEnabled(enabled);\n-\t\trepaint();\n-\t}\n-\n-\tpublic void setFont(Font font)\n-\t{\n-\t\tsuper.setFont(font);\n-\t\trevalidate();\n-\t\trepaint();\n-\t}\n-\n-\tpublic void setBackground(Color bg)\n-\t{\n-\t\tsuper.setBackground(bg);\n-\t\trevalidate();\n-\t\trepaint();\n-\t}\n-\tpublic void setForeground(Color fg)\n-\t{\n-\t\tsuper.setForeground(fg);\n-\t\trevalidate();\n-\t\trepaint();\n-\t}\n-\n-\tpublic void setMaximumSize(Dimension maximumSize)\n-\t{\tmax = maximumSize;    }\n-\n-\tpublic void setMinimumSize(Dimension minimumSize)\n-\t{   min = minimumSize; }\n-\n-\tpublic void setPreferredSize(Dimension preferredSize)\n-\t{   pref = preferredSize;   }\n-\n-\tpublic void setNextFocusableComponent(Component aComponent)\n-\t{\n-\t\t//       Specifies the next component to get the focus after this one, for example, when the tab key is pressed.\n-\t}\n-\n-\tpublic void setOpaque(boolean isOpaque)\n-\t{\n-\t\topaque = isOpaque;\n-\t\trevalidate();\n-\t\trepaint();\n-\t}\n-\n-\n-\tpublic void setRequestFocusEnabled(boolean aFlag)\n-\t{\n-\t}\n-\n-\n-\tpublic void setVisible(boolean aFlag)\n-\t{\n-\t\t//    Makes the component visible or invisible.\n-\n-\t\tsuper.setVisible(aFlag);\n-\t\tif (getParent() != null)\n-\t\t{\n-\t\t\tRectangle dims = getBounds();\n-\t\t\tgetParent().repaint((int)dims.getX(),\n-\t\t\t                    (int)dims.getY(),\n-\t\t\t                    (int)dims.getWidth(),\n-\t\t\t                    (int)dims.getHeight());\n-\t\t}\n-\t}\n-\n-\tpublic void unregisterKeyboardAction(KeyStroke aKeyStroke)\n-\t{\n-\t\t//          Unregister a keyboard action.\n-\t}\n-\n-\n-\tpublic void update(Graphics g)\n-\t{\n-\t\tpaint(g);\n-\t}\n-\n-        public String getUIClassID()\n-\t{\n-\t\t///          Return the UIDefaults key used to look up the name of the swing.\n-\t\treturn \"ComponentUI\";\n-\t}\n-\n-\tprotected void setUI(ComponentUI newUI)\n-\t{\n-\t\tif (ui != null)\n-\t\t{\n-\t\t\tui.uninstallUI(this);\n-\t\t}\n-\n-\t\t//          Set the look and feel delegate for this component.\n-\t\tui = newUI;\n-\n-\t\tif (ui != null)\n-\t\t{\n-\t\t\tui.installUI(this);\n-\t\t}\n-\n-\t\trevalidate();\n-\t\trepaint();\n-\t}\n-\n-\tpublic void updateUI()\n-\t{\n-\t\t//        Resets the UI property to a value from the current look and feel.\n-\t\tSystem.out.println(\"update UI not overwritten in class: \" + this);\n-\t}\n+    return (VetoableChangeListener[]) getListeners(VetoableChangeListener.class);\n+  }\n+\n+  /**\n+   * Return all <code>PropertyChangeListener</code> objects registered to listen\n+   * for a particular property.\n+   *\n+   * @param property The property to return the listeners of\n+   *\n+   * @return The set of <code>PropertyChangeListener</code> objects in \n+   * {@link #changeSupport} registered to listen on the specified propert\n+   */\n+  public PropertyChangeListener[] getPropertyChangeListeners(String property)\n+  {\n+    return changeSupport == null ? new PropertyChangeListener[0]\n+                                 : changeSupport.getPropertyChangeListeners(property);\n+  }\n+\n+  /**\n+   * A variant of {@link #firePropertyChange(String,Object,Object)} \n+   * for properties with <code>boolean</code> values.\n+   */\n+  public void firePropertyChange(String propertyName, boolean oldValue,\n+                                 boolean newValue)\n+  {\n+    if (changeSupport != null)\n+      changeSupport.firePropertyChange(propertyName, new Boolean(oldValue),\n+                                       new Boolean(newValue));\n+  }\n+\n+  /**\n+   * A variant of {@link #firePropertyChange(String,Object,Object)} \n+   * for properties with <code>byte</code> values.\n+   */\n+  public void firePropertyChange(String propertyName, byte oldValue,\n+                                 byte newValue)\n+  {\n+    if (changeSupport != null)\n+      changeSupport.firePropertyChange(propertyName, new Byte(oldValue),\n+                                       new Byte(newValue));\n+  }\n+\n+  /**\n+   * A variant of {@link #firePropertyChange(String,Object,Object)} \n+   * for properties with <code>char</code> values.\n+   */\n+  public void firePropertyChange(String propertyName, char oldValue,\n+                                 char newValue)\n+  {\n+    if (changeSupport != null)\n+      changeSupport.firePropertyChange(propertyName, new Character(oldValue),\n+                                       new Character(newValue));\n+  }\n+\n+  /**\n+   * A variant of {@link #firePropertyChange(String,Object,Object)} \n+   * for properties with <code>double</code> values.\n+   */\n+  public void firePropertyChange(String propertyName, double oldValue,\n+                                 double newValue)\n+  {\n+    if (changeSupport != null)\n+      changeSupport.firePropertyChange(propertyName, new Double(oldValue),\n+                                       new Double(newValue));\n+  }\n+\n+  /**\n+   * A variant of {@link #firePropertyChange(String,Object,Object)} \n+   * for properties with <code>float</code> values.\n+   */\n+  public void firePropertyChange(String propertyName, float oldValue,\n+                                 float newValue)\n+  {\n+    if (changeSupport != null)\n+      changeSupport.firePropertyChange(propertyName, new Float(oldValue),\n+                                       new Float(newValue));\n+  }\n+\n+  /**\n+   * A variant of {@link #firePropertyChange(String,Object,Object)} \n+   * for properties with <code>int</code> values.\n+   */\n+  public void firePropertyChange(String propertyName, int oldValue,\n+                                 int newValue)\n+  {\n+    if (changeSupport != null)\n+      changeSupport.firePropertyChange(propertyName, new Integer(oldValue),\n+                                       new Integer(newValue));\n+  }\n+\n+  /**\n+   * A variant of {@link #firePropertyChange(String,Object,Object)} \n+   * for properties with <code>long</code> values.\n+   */\n+  public void firePropertyChange(String propertyName, long oldValue,\n+                                 long newValue)\n+  {\n+    if (changeSupport != null)\n+      changeSupport.firePropertyChange(propertyName, new Long(oldValue),\n+                                       new Long(newValue));\n+  }\n+\n+  /**\n+   * Call {@link PropertyChangeListener#propertyChange} on all listeners\n+   * registered to listen to a given property. Any method which changes\n+   * the specified property of this component should call this method.\n+   *\n+   * @param propertyName The property which changed\n+   * @param oldValue The old value of the property\n+   * @param newValue The new value of the property\n+   *\n+   * @see #changeSupport\n+   * @see #addPropertyChangeListener\n+   * @see #removePropertyChangeListener\n+   */\n+  protected void firePropertyChange(String propertyName, Object oldValue,\n+                                    Object newValue)\n+  {\n+    if (changeSupport != null)\n+      changeSupport.firePropertyChange(propertyName, oldValue, newValue);\n+  }\n+\n+  /**\n+   * A variant of {@link #firePropertyChange(String,Object,Object)} \n+   * for properties with <code>short</code> values.\n+   */\n+  public void firePropertyChange(String propertyName, short oldValue,\n+                                 short newValue)\n+  {\n+    if (changeSupport != null)\n+      changeSupport.firePropertyChange(propertyName, new Short(oldValue),\n+                                       new Short(newValue));\n+  }\n+\n+  /**\n+   * Call {@link VetoableChangeListener#vetoableChange} on all listeners\n+   * registered to listen to a given property. Any method which changes\n+   * the specified property of this component should call this method.\n+   *\n+   * @param propertyName The property which changed\n+   * @param oldValue The old value of the property\n+   * @param newValue The new value of the property\n+   *\n+   * @throws PropertyVetoException if the change was vetoed by a listener\n+   *\n+   * @see addVetoableChangeListener\n+   * @see removeVetoableChangeListener\n+   */\n+  protected void fireVetoableChange(String propertyName, Object oldValue,\n+                                    Object newValue)\n+    throws PropertyVetoException\n+  {\n+    //       Support for reporting constrained property changes.\n+  }\n+\n+  /**\n+   * Get the value of the accessibleContext property for this component.\n+   *\n+   * @return the current value of the property\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the ActionListener (typically an {@link Action} object) which is\n+   * associated with a particular keystroke. \n+   *\n+   * @param aKeyStroke The keystroke to retrieve the action of\n+   *\n+   * @return The action associated with the specified keystroke\n+   */\n+  public ActionListener getActionForKeyStroke(KeyStroke aKeyStroke)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the value of the {@link #alignmentX} property.\n+   *\n+   * @return The current value of the property.\n+   *\n+   * @see #setAlignmentX\n+   * @see #alignmentY\n+   */\n+  public float getAlignmentX()\n+  {\n+    return alignmentX;\n+  }\n+\n+  /**\n+   * Get the value of the {@link #alignmentY} property.\n+   *\n+   * @return The current value of the property.\n+   *\n+   * @see #setAlignmentY\n+   * @see #alignmentX\n+   */\n+  public float getAlignmentY()\n+  {\n+    return alignmentY;\n+  }\n+\n+  /**\n+   * Get the current value of the {@link #autoscrolls} property.\n+   *\n+   * @return The current value of the property\n+   */\n+  public boolean getAutoscrolls()\n+  {\n+    return autoscrolls;\n+  }\n+\n+  /**\n+   * Set the value of the {@link #border} property, revalidate\n+   * and repaint this component.\n+   *   \n+   * @param border The new value of the property\n+   *\n+   * @see #getBorder\n+   */\n+  public void setBorder(Border border)\n+  {\n+    this.border = border;\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * Get the value of the {@link #border} property.\n+   *\n+   * @return The property's current value\n+   *\n+   * @see #setBorder\n+   */\n+  public Border getBorder()\n+  {\n+    return border;\n+  }\n+\n+  /**\n+   * Get the component's current bounding box. If a rectangle is provided,\n+   * use this as the return value (adjusting its fields in place);\n+   * otherwise (of <code>null</code> is provided) return a new {@link\n+   * Rectangle}.\n+   *\n+   * @param rv Optional return value to use\n+   *\n+   * @return A rectangle bounding the component\n+   */\n+  public Rectangle getBounds(Rectangle rv)\n+  {\n+    if (rv == null)\n+      return new Rectangle(getX(), getY(), getWidth(), getHeight());\n+    else\n+      {\n+        rv.setBounds(getX(), getY(), getWidth(), getHeight());\n+        return rv;\n+      }\n+  }\n+\n+  /**\n+   * Prepares a graphics context for painting this object. If {@link\n+   * #debugGraphicsOptions} is not equal to {@link\n+   * DebugGraphics#NONE_OPTION}, produce a new {@link DebugGraphics} object\n+   * wrapping the parameter. Otherwise configure the parameter with this\n+   * component's foreground color and font.\n+   *\n+   * @param g The graphics context to wrap or configure\n+   *\n+   * @return A graphics context to paint this object with\n+   *\n+   * @see #debugGraphicsOptions\n+   * @see #paint\n+   */\n+  protected Graphics getComponentGraphics(Graphics g)\n+  {    \n+    g.setFont(this.getFont());\n+    g.setColor(this.getForeground());\n+    return g;\n+  }\n+\n+  /**\n+   * Return the condition that determines whether a registered action\n+   * occurs in response to the specified keystroke.\n+   *\n+   * @param aKeyStroke The keystroke to return the condition of\n+   *\n+   * @return One of the values {@link #UNDEFINED_CONDITION}, {@link\n+   * #WHEN_ANCESTOR_OF_FOCUSED_COMPONENT}, {@link #WHEN_FOCUSED}, or {@link\n+   * #WHEN_IN_FOCUSED_WINDOW}\n+   *\n+   * @see #registerKeyboardAction   \n+   * @see #unregisterKeyboardAction   \n+   * @see #resetKeyboardActiond\n+   */\n+  public int getConditionForKeyStroke(KeyStroke aKeyStroke)\n+  {\n+    return UNDEFINED_CONDITION;\n+  }\n+\n+  /**\n+   * Get the value of the {@link #debugGraphicsOptions} property.\n+   *\n+   * @return The current value of the property.\n+   *\n+   * @see #setDebugGraphicsOptions\n+   * @see #debugGraphicsOptions\n+   */\n+  public int getDebugGraphicsOptions()\n+  {\n+    return 0;\n+  }\n+\n+  /**\n+   * Get the component's insets, which are calculated from\n+   * the {@link #border} property. If the border is <code>null</code>,\n+   * calls {@link Container#getInsets}.\n+   *\n+   * @return The component's current insets\n+   */\n+  public Insets getInsets()\n+  {\n+    if (border == null)\n+      return super.getInsets();\n+    return getBorder().getBorderInsets(this);\n+  }\n+\n+  /**\n+   * Get the component's insets, which are calculated from the {@link\n+   * #border} property. If the border is <code>null</code>, calls {@link\n+   * Container#getInsets}. The passed-in {@link Insets} value will be\n+   * used as the return value, if possible.\n+   *\n+   * @param insets Return value object to reuse, if possible\n+   *\n+   * @return The component's current insets\n+   */\n+  public Insets getInsets(Insets insets)\n+  {\n+    Insets t = getInsets();\n+\n+    if (insets == null)\n+      return t;\n+\n+    insets.left = t.left;\n+    insets.right = t.right;\n+    insets.top = t.top;\n+    insets.bottom = t.bottom;\n+    return insets;\n+  }\n+\n+  /**\n+   * Get the component's location. The passed-in {@link Point} value\n+   * will be used as the return value, if possible.\n+   *\n+   * @param rv Return value object to reuse, if possible\n+   *\n+   * @return The component's current location\n+   */\n+  public Point getLocation(Point rv)\n+  {\n+    if (rv == null)\n+      return new Point(getX(), getY());\n+\n+    rv.setLocation(getX(), getY());\n+    return rv;\n+  }\n+\n+  /**\n+   * Get the component's maximum size. If the {@link #maximumSize} property\n+   * has been explicitly set, it is returned. If the {@link #maximumSize}\n+   * property has not been set but the {@link ui} property has been, the\n+   * result of {@link ComponentUI#getMaximumSize} is returned. If neither\n+   * property has been set, the result of {@link Container#getMaximumSize}\n+   * is returned.\n+   *\n+   * @return The maximum size of the component\n+   *\n+   * @see #maximumSize\n+   * @see #setMaximumSize\n+   */\n+  public Dimension getMaximumSize()\n+  {\n+    if (maximumSize != null)\n+      return maximumSize;\n+\n+    if (ui != null)\n+      {\n+        Dimension s = ui.getMaximumSize(this);\n+        if (s != null)\n+          return s;\n+      }\n+\n+    Dimension p = super.getMaximumSize();\n+    return p;\n+  }\n+\n+  /**\n+   * Get the component's minimum size. If the {@link #minimumSize} property\n+   * has been explicitly set, it is returned. If the {@link #minimumSize}\n+   * property has not been set but the {@link ui} property has been, the\n+   * result of {@link ComponentUI#getMinimumSize} is returned. If neither\n+   * property has been set, the result of {@link Container#getMinimumSize}\n+   * is returned.\n+   *\n+   * @return The minimum size of the component\n+   *\n+   * @see #minimumSize\n+   * @see #setMinimumSize\n+   */\n+  public Dimension getMinimumSize()\n+  {\n+    if (minimumSize != null)\n+      return minimumSize;\n+\n+    if (ui != null)\n+      {\n+        Dimension s = ui.getMinimumSize(this);\n+        if (s != null)\n+          return s;\n+      }\n+\n+    Dimension p = super.getMinimumSize();\n+    return p;\n+  }\n+\n+  /**\n+   * Get the component's preferred size. If the {@link #preferredSize}\n+   * property has been explicitly set, it is returned. If the {@link\n+   * #preferredSize} property has not been set but the {@link ui} property\n+   * has been, the result of {@link ComponentUI#getPreferredSize} is\n+   * returned. If neither property has been set, the result of {@link\n+   * Container#getPreferredSize} is returned.\n+   *\n+   * @return The preferred size of the component\n+   *\n+   * @see #preferredSize\n+   * @see #setPreferredSize\n+   */\n+  public Dimension getPreferredSize()\n+  {\n+    if (preferredSize != null)\n+      return preferredSize;\n+\n+    if (ui != null)\n+      {\n+        Dimension s = ui.getPreferredSize(this);\n+        if (s != null)\n+          return s;\n+      }\n+    Dimension p = super.getPreferredSize();\n+    return p;\n+  }\n+\n+  /**\n+   * Return the value of the {@link #nextFocusableComponent} property.\n+   * \n+   * @deprecated See {@link java.awt.FocusTraversalPolicy}\n+   *\n+   * @return The current value of the property, or <code>null</code>\n+   * if none has been set.\n+   */\n+  public Component getNextFocusableComponent()\n+  {\n+    return null;\n+  }\n \n+  /**\n+   * Return the set of {@link KeyStroke} objects which are registered\n+   * to initiate actions on this component.\n+   *\n+   * @return An array of the registered keystrokes\n+   */\n+  public KeyStroke[] getRegisteredKeyStrokes()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Returns the first ancestor of this component which is a {@link JRootPane}.\n+   * Equivalent to calling <code>SwingUtilities.getRootPane(this);</code>.\n+   *\n+   * @return An ancestral JRootPane, or <code>null</code> if none exists.\n+   */\n+  public JRootPane getRootPane()\n+  {\n+    JRootPane p = SwingUtilities.getRootPane(this);\n+    return p;\n+  }\n+\n+  /**\n+   * Get the component's size. The passed-in {@link Dimension} value\n+   * will be used as the return value, if possible.\n+   *\n+   * @param rv Return value object to reuse, if possible\n+   *\n+   * @return The component's current size\n+   */\n+  public Dimension getSize(Dimension rv)\n+  {\n+    if (rv == null)\n+      return new Dimension(getWidth(), getHeight());\n+    else\n+      {\n+        rv.setSize(getWidth(), getHeight());\n+        return rv;\n+      }\n+  }\n+\n+  /**\n+   * Return the {@link #toolTip} property of this component, creating it and\n+   * setting it if it is currently <code>null</code>. This method can be\n+   * overridden in subclasses which wish to control the exact form of\n+   * tooltip created.\n+   *\n+   * @return The current toolTip\n+   */\n+  public JToolTip createToolTip()\n+  {\n+    if (toolTip == null)\n+      toolTip = new JToolTip(toolTipText);\n+    return toolTip;\n+  }\n+\n+  /**\n+   * Return the location at which the {@link #toolTip} property should be\n+   * displayed, when triggered by a particular mouse event. \n+   *\n+   * @param event The event the tooltip is being presented in response to\n+   *\n+   * @return The point at which to display a tooltip, or <code>null</code>\n+   * if swing is to choose a default location.\n+   */\n+  public Point getToolTipLocation(MouseEvent event)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Set the value of the {@link #toolTipText} property.\n+   *\n+   * @param text The new property value\n+   *\n+   * @see #getToolTipText\n+   */\n+  public void setToolTipText(String text)\n+  {\n+    toolTipText = text;\n+  }\n+\n+  /**\n+   * Get the value of the {@link #toolTipText} property.\n+   *\n+   * @return The current property value\n+   *\n+   * @see #setToolTipText\n+   */\n+  public String getToolTipText()\n+  {\n+    return toolTipText;\n+  }\n+\n+  /**\n+   * Get the value of the {@link #toolTipText} property, in response to a\n+   * particular mouse event.\n+   *\n+   * @param event The mouse event which triggered the tooltip\n+   *\n+   * @return The current property value\n+   *\n+   * @see #setToolTipText\n+   */\n+  public String getToolTipText(MouseEvent event)\n+  {\n+    return toolTipText;\n+  }\n+\n+  /**\n+   * Return the top level ancestral container (usually a {@link\n+   * java.awt.Window} or {@link java.awt.Applet}) which this component is\n+   * contained within, or <code>null</code> if no ancestors exist.\n+   *\n+   * @return The top level container, if it exists\n+   */\n+  public Container getTopLevelAncestor()\n+  {\n+    Container c = getParent();\n+    for (Container peek = c; peek != null; peek = peek.getParent())\n+      c = peek;\n+    return c;\n+  }\n+\n+  /**\n+   * Compute the component's visible rectangle, which is defined\n+   * recursively as either the component's bounds, if it has no parent, or\n+   * the intersection of the component's bounds with the visible rectangle\n+   * of its parent.\n+   *\n+   * @param rect The return value slot to place the visible rectangle in\n+   */\n+  public void computeVisibleRect(Rectangle rect)\n+  {\n+    Component c = getParent();\n+    if (c != null && c instanceof JComponent)\n+      {\n+        ((JComponent) c).computeVisibleRect(rect);\n+        rect.translate(-getX(), -getY());\n+        Rectangle2D.intersect(rect,\n+                              new Rectangle(0, 0, getWidth(), getHeight()),\n+                              rect);\n+      }\n+    else\n+      rect.setRect(0, 0, getWidth(), getHeight());\n+  }\n+\n+  /**\n+   * Return the component's visible rectangle in a new {@link Rectangle},\n+   * rather than via a return slot.\n+   *\n+   * @return The component's visible rectangle\n+   *\n+   * @see #computeVisibleRect(Rectangle)\n+   */\n+  public Rectangle getVisibleRect()\n+  {\n+    Rectangle r = new Rectangle();\n+    computeVisibleRect(r);\n+    return r;\n+  }\n+\n+  /**\n+   * <p>Requests that this component receive input focus, giving window\n+   * focus to the top level ancestor of this component. Only works on\n+   * displayable, focusable, visible components.</p>\n+   *\n+   * <p>This method should not be called by clients; it is intended for\n+   * focus implementations. Use {@link Component#requestFocus} instead.</p>\n+   *\n+   * @see {@link Component#requestFocus}\n+   */\n+  public void grabFocus()\n+  {\n+  }\n+\n+  /**\n+   * Get the value of the {@link #doubleBuffered} property.\n+   *\n+   * @return The property's current value\n+   */\n+  public boolean isDoubleBuffered()\n+  {\n+    return doubleBuffered;\n+  }\n+\n+  /**\n+   * Return <code>true</code> if the provided component has no native peer;\n+   * in other words, if it is a \"lightweight component\".\n+   *\n+   * @param c The component to test for lightweight-ness\n+   *\n+   * @return Whether or not the component is lightweight\n+   */\n+  public static boolean isLightweightComponent(Component c)\n+  {\n+    return c.getPeer() instanceof LightweightPeer;\n+  }\n+\n+  /**\n+   * Return <code>true<code> if you wish this component to manage its own\n+   * focus. In particular: if you want this component to be sent\n+   * <code>TAB</code> and <code>SHIFT+TAB</code> key events, and to not\n+   * have its children considered as focus transfer targets. If\n+   * <code>true</code>, focus traversal around this component changes to\n+   * <code>CTRL+TAB</code> and <code>CTRL+SHIFT+TAB</code>.\n+   *\n+   * @return <code>true</code> if you want this component to manage its own\n+   * focus, otherwise (by default) <code>false</code>\n+   *\n+   * @deprecated Use {@link Component.setFocusTraversalKeys(int,Set)} and\n+   * {@link Container.setFocusCycleRoot(boolean)} instead\n+   */\n+  public boolean isManagingFocus()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * Return the current value of the {@link opaque} property. \n+   *\n+   * @return The current property value\n+   */\n+  public boolean isOpaque()\n+  {\n+    return opaque;\n+  }\n+\n+  /**\n+   * Return <code>true</code> if the component can guarantee that none of its\n+   * children will overlap in Z-order. This is a hint to the painting system.\n+   * The default is to return <code>true</code>, but some components such as\n+   * {@link JLayeredPane} should override this to return <code>false</code>.\n+   *\n+   * @return Whether the component tiles its children\n+   */\n+  public boolean isOptimizedDrawingEnabled()\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * Return <code>true</code> if this component is currently painting a tile.\n+   *\n+   * @return Whether the component is painting a tile\n+   */\n+  public boolean isPaintingTile()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * Get the value of the {@link #requestFocusEnabled} property.\n+   *\n+   * @return The current value of the property\n+   */\n+  public boolean isRequestFocusEnabled()\n+  {\n+    return requestFocusEnabled;\n+  }\n+\n+  /**\n+   * Return <code>true</code> if this component is a validation root; this\n+   * will cause calls to {@link #invalidate} in this component's children\n+   * to be \"captured\" at this component, and not propagate to its parents.\n+   * For most components this should return <code>false</code>, but some\n+   * components such as {@link JViewPort} will want to return\n+   * <code>true</code>.\n+   *\n+   * @return Whether this component is a validation root\n+   */\n+  public boolean isValidateRoot()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * <p>Paint the component. This is a delicate process, and should only be\n+   * called from the repaint thread, under control of the {@link\n+   * RepaintManager}. Client code should usually call {@link #repaint} to\n+   * trigger painting.</p>\n+   *\n+   * <p>This method will acquire a double buffer from the {@link\n+   * RepaintManager} if the component's {@link #doubleBuffered} property is\n+   * <code>true</code> and the <code>paint</code> call is the\n+   * <em>first</em> recursive <code>paint</code> call inside swing.</p>\n+   *\n+   * <p>The method will also modify the provided {@link Graphics} context\n+   * via the {@link #getComponentGraphics} method. If you want to customize\n+   * the graphics object used for painting, you should override that method\n+   * rather than <code>paint</code>.</p>\n+   *\n+   * <p>The body of the <code>paint</code> call involves calling {@link\n+   * #paintComponent}, {@link #paintBorder}, and {@link #paintChildren} in\n+   * order. If you want to customize painting behavior, you should override\n+   * one of these methods rather than <code>paint</code>.</p>\n+   *\n+   * <p>For more details on the painting sequence, see <a\n+   * href=\"http://java.sun.com/products/jfc/tsc/articles/painting/index.html\">this\n+   * article</a>.</p>\n+   *\n+   * @param g The graphics context to paint with\n+   *\n+   * @see #paintImmediately\n+   */\n+  public void paint(Graphics g)\n+  {\n+    Graphics g2 = g;\n+    Image doubleBuffer = null;\n+    RepaintManager rm = RepaintManager.currentManager(this);\n+\n+    if (isDoubleBuffered()\n+        && (rm.isDoubleBufferingEnabled())\n+        && (! Thread.holdsLock(paintLock)))\n+      {\n+        doubleBuffer = rm.getOffscreenBuffer(this, getWidth(), getHeight());\n+      }\n+\n+    synchronized (paintLock)\n+      {\n+        if (doubleBuffer != null)\n+          {\n+            g2 = doubleBuffer.getGraphics();\n+            g2.setClip(g.getClipBounds());\n+          }\n+\n+        g2 = getComponentGraphics(g2);\n+        paintComponent(g2);\n+        paintBorder(g2);\n+        paintChildren(g2);\n+        \n+        if (doubleBuffer != null)\n+          g.drawImage(doubleBuffer, 0, 0, (ImageObserver) null);\n+      }\n+  }\n+\n+  /**\n+   * Paint the component's border. This usually means calling {@link\n+   * Border#paintBorder} on the {@link #border} property, if it is\n+   * non-<code>null</code>. You may override this if you wish to customize\n+   * border painting behavior. The border is painted after the component's\n+   * body, but before the component's children.\n+   *\n+   * @param g The graphics context with which to paint the border\n+   *\n+   * @see #paint\n+   * @see #paintChildren\n+   * @see #paintComponent\n+   */\n+  protected void paintBorder(Graphics g)\n+  {\n+    if (getBorder() != null)\n+      getBorder().paintBorder(this, g, 0, 0, getWidth(), getHeight());\n+  }\n+\n+  /**\n+   * Paint the component's children. This usually means calling {@link\n+   * Container#paint}, which recursively calls {@link #paint} on any of the\n+   * component's children, with appropriate changes to coordinate space and\n+   * clipping region. You may override this if you wish to customize\n+   * children painting behavior. The children are painted after the\n+   * component's body and border.\n+   *\n+   * @param g The graphics context with which to paint the children\n+   *\n+   * @see #paint\n+   * @see #paintBorder\n+   * @see #paintComponent\n+   */\n+  protected void paintChildren(Graphics g)\n+  {\n+    super.paint(g);\n+  }\n+\n+  /**\n+   * Paint the component's body. This usually means calling {@link\n+   * ComponentUI#update} on the {@link #ui} property of the component, if\n+   * it is non-<code>null</code>. You may override this if you wish to\n+   * customize the component's body-painting behavior. The component's body\n+   * is painted first, before the border and children.\n+   *\n+   * @param g The graphics context with which to paint the body\n+   *\n+   * @see #paint\n+   * @see #paintBorder\n+   * @see #paintChildren\n+   */\n+  protected void paintComponent(Graphics g)\n+  {\n+    if (ui != null)\n+      ui.update(g, this);\n+  }\n+\n+  /**\n+   * A variant of {@link #paintImmediately(Rectangle)} which takes\n+   * integer parameters.\n+   *\n+   * @param x The left x coordinate of the dirty region\n+   * @param y The top y coordinate of the dirty region\n+   * @param w The width of the dirty region\n+   * @param h The height of the dirty region\n+   */\n+  public void paintImmediately(int x, int y, int w, int h)\n+  {\n+    paintImmediately(new Rectangle(x, y, w, h));\n+  }\n+\n+  /**\n+   * Transform the provided dirty rectangle for this component into the\n+   * appropriate ancestral {@link JRootPane} and call {@link #paint} on\n+   * that root pane. This method is called from the {@link RepaintManager}\n+   * and should always be called within the painting thread.\n+   *\n+   * @param r The dirty rectangle to paint\n+   */\n+  public void paintImmediately(Rectangle r)\n+  {\n+    Component root = this.getRootPane();\n+    if (root == null || ! root.isShowing())\n+      return;\n+    Graphics g = root.getGraphics();\n+    if (g == null)\n+      return;\n+\n+    Rectangle clip = SwingUtilities.convertRectangle(this, r, root);\n+    g.setClip(clip);\n+    root.paint(g);\n+    g.dispose();\n+  }\n+\n+  /**\n+   * Return a string representation for this component, for use in\n+   * debugging.\n+   *\n+   * @return A string describing this component.\n+   */\n+  protected String paramString()\n+  {\n+    return \"JComponent\";\n+  }\n+\n+  /**\n+   * A variant of {@link\n+   * #registerKeyboardAction(ActionListener,String,KeyStroke,int)} which\n+   * provides <code>null</code> for the command name.   \n+   */\n+  public void registerKeyboardAction(ActionListener act,\n+                                     KeyStroke stroke, \n+                                     int cond)\n+  {\n+    registerKeyboardAction(act, null, stroke, cond);\n+  }\n+\n+  /**\n+   * An obsolete method to register a keyboard action on this component.\n+   * You should use <code>getInputMap</code> and <code>getActionMap</code>\n+   * to fetch mapping tables from keystrokes to commands, and commands to\n+   * actions, respectively, and modify those mappings directly.\n+   *\n+   * @param anAction The action to be registered\n+   * @param aCommand The command to deliver in the delivered {@link\n+   * java.awt.ActionEvent}\n+   * @param aKeyStroke The keystroke to register on\n+   * @param aCondition One of the values {@link #UNDEFINED_CONDITION},\n+   * {@link #WHEN_ANCESTOR_OF_FOCUSED_COMPONENT}, {@link #WHEN_FOCUSED}, or\n+   * {@link #WHEN_IN_FOCUSED_WINDOW}, indicating the condition which must\n+   * be met for the action to be fired\n+   *\n+   * @see #unregisterKeyboardAction\n+   * @see #getConditionForKeystroke\n+   * @see #resetKeyboardActiond\n+   */\n+  public void registerKeyboardAction(ActionListener act, \n+                                     String cmd,\n+                                     KeyStroke stroke, \n+                                     int cond)\n+  {\n+  }\n+\n+  /**\n+   * Remove a keyboard action registry.\n+   *\n+   * @param stroke The keystroke to unregister\n+   *\n+   * @see #registerKeyboardAction\n+   * @see #getConditionForKeystroke\n+   * @see #resetKeyboardActiond\n+   */\n+  public void unregisterKeyboardAction(KeyStroke aKeyStroke)\n+  {\n+  }\n+\n+\n+  /**\n+   * Reset all keyboard action registries.\n+   *\n+   * @see #registerKeyboardAction\n+   * @see #unregisterKeyboardAction\n+   * @see #getConditionForKeystroke\n+   */\n+  public void resetKeyboardActions()\n+  {\n+  }\n+\n+\n+  /**\n+   * Mark the described region of this component as dirty in the current\n+   * {@link RepaintManager}. This will queue an asynchronous repaint using\n+   * the system painting thread in the near future.\n+   *\n+   * @param tm ignored\n+   * @param x coordinate of the region to mark as dirty\n+   * @param y coordinate of the region to mark as dirty\n+   * @param width dimension of the region to mark as dirty\n+   * @param height dimension of the region to mark as dirty\n+   */\n+  public void repaint(long tm, int x, int y, int width, int height)\n+  {\n+    Rectangle dirty = new Rectangle(x, y, width, height);\n+    Rectangle vis = getVisibleRect();\n+    dirty = dirty.intersection(vis);\n+    RepaintManager.currentManager(this).addDirtyRegion(this, dirty.x, dirty.y,\n+                                                       dirty.width,\n+                                                       dirty.height);\n+  }\n+\n+  /**\n+   * Mark the described region of this component as dirty in the current\n+   * {@link RepaintManager}. This will queue an asynchronous repaint using\n+   * the system painting thread in the near future.\n+   *\n+   * @param r The rectangle to mark as dirty\n+   */\n+  public void repaint(Rectangle r)\n+  {\n+    repaint((long) 0, (int) r.getX(), (int) r.getY(), (int) r.getWidth(),\n+            (int) r.getHeight());\n+  }\n+\n+  /**\n+   * Request focus on the default component of this component's {@link\n+   * FocusTraversalPolicy}.\n+   *\n+   * @return The result of {@link #requestFocus}\n+   *\n+   * @deprecated Use {@link #requestFocus()} on the default component provided from\n+   * the {@link FocusTraversalPolicy} instead.\n+   */\n+  public boolean requestDefaultFocus()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * Queue a an invalidation and revalidation of this component, using \n+   * {@link RepaintManager#addInvalidComponent}.\n+   */\n+  public void revalidate()\n+  {\n+    RepaintManager.currentManager(this).addInvalidComponent(this);\n+  }\n+\n+  /**\n+   * Calls <code>scrollRectToVisible</code> on the component's parent. \n+   * Components which can service this call should override.\n+   *\n+   * @param r The rectangle to make visible\n+   */\n+  public void scrollRectToVisible(Rectangle r)\n+  {\n+    Component p = getParent();\n+    if (p != null && p instanceof JComponent)\n+      ((JComponent) p).scrollRectToVisible(r);\n+  }\n+\n+  /**\n+   * Set the value of the {@link #alignmentX} property.\n+   *\n+   * @param a The new value of the property\n+   */\n+  public void setAlignmentX(float a)\n+  {\n+    alignmentX = a;\n+  }\n+\n+  /**\n+   * Set the value of the {@link #alignmentY} property.\n+   *\n+   * @param a The new value of the property\n+   */\n+  public void setAlignmentY(float a)\n+  {\n+    alignmentY = a;\n+  }\n+\n+  /**\n+   * Set the value of the {@link #autoscrolls} property.\n+   *\n+   * @param a The new value of the property\n+   */\n+  public void setAutoscrolls(boolean a)\n+  {\n+    autoscrolls = a;\n+  }\n+\n+  /**\n+   * Set the value of the {@link #debugGraphicsOptions} property.\n+   *\n+   * @param debugOptions The new value of the property\n+   */\n+  public void setDebugGraphicsOptions(int debugOptions)\n+  {\n+    debugGraphicsOptions = debugOptions;\n+  }\n+\n+  /**\n+   * Set the value of the {@link #doubleBuffered} property.\n+   *\n+   * @param db The new value of the property\n+   */\n+  public void setDoubleBuffered(boolean db)\n+  {\n+    doubleBuffered = db;\n+  }\n+\n+  /**\n+   * Set the value of the {@link #enabled} property, revalidate\n+   * and repaint this component.\n+   *\n+   * @param e The new value of the property\n+   */\n+  public void setEnabled(boolean e)\n+  {\n+    super.setEnabled(e);\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * Set the value of the {@link #font} property, revalidate\n+   * and repaint this component.\n+   *\n+   * @param f The new value of the property\n+   */\n+  public void setFont(Font f)\n+  {\n+    super.setFont(f);\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * Set the value of the {@link #background} property, revalidate\n+   * and repaint this component.\n+   *\n+   * @param bg The new value of the property\n+   */\n+  public void setBackground(Color bg)\n+  {\n+    super.setBackground(bg);\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * Set the value of the {@link #foreground} property, revalidate\n+   * and repaint this component.\n+   *\n+   * @param fg The new value of the property\n+   */\n+  public void setForeground(Color fg)\n+  {\n+    super.setForeground(fg);\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * Set the value of the {@link #maximumSize} property, revalidate\n+   * and repaint this component.\n+   *\n+   * @param max The new value of the property\n+   */\n+  public void setMaximumSize(Dimension max)\n+  {\n+    maximumSize = max;\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * Set the value of the {@link #minimumSize} property, revalidate\n+   * and repaint this component.\n+   *\n+   * @param min The new value of the property\n+   */\n+  public void setMinimumSize(Dimension min)\n+  {\n+    minimumSize = min;\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * Set the value of the {@link #preferredSize} property, revalidate\n+   * and repaint this component.\n+   *\n+   * @param pref The new value of the property\n+   */\n+  public void setPreferredSize(Dimension pref)\n+  {\n+    preferredSize = pref;\n+  }\n+\n+  /**\n+   * Set the specified component to be the next component in the \n+   * focus cycle, overriding the {@link FocusTraversalPolicy} for\n+   * this component.\n+   *\n+   * @param aComponent The component to set as the next focusable\n+   *\n+   * @deprecated Use FocusTraversalPolicy instead\n+   */\n+  public void setNextFocusableComponent(Component aComponent)\n+  {\n+  }\n+\n+  /**\n+   * Set the value of the {@link #requestFocusEnabled} property.\n+   *\n+   * @param e The new value of the property\n+   */\n+  public void setRequestFocusEnabled(boolean e)\n+  {\n+    requestFocusEnabled = e;\n+  }\n+\n+  /**\n+   * Set the value of the {@link #opaque} property, revalidate and repaint\n+   * this component.\n+   *\n+   * @param isOpaque The new value of the property\n+   *\n+   * @see ComponentUI#update\n+   */\n+  public void setOpaque(boolean isOpaque)\n+  {\n+    opaque = isOpaque;\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * Set the value of the visible property, and revalidate / repaint the\n+   * component.\n+   *\n+   * @param v The new value of the property\n+   */\n+  public void setVisible(boolean v)\n+  {\n+    super.setVisible(v);\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * Call {@link paint}. \n+   * \n+   * @param g The graphics context to paint into\n+   */\n+  public void update(Graphics g)\n+  {\n+    paint(g);\n+  }\n+\n+  /**\n+   * Get the value of the UIClassID property. This property should be a key\n+   * in the {@link UIDefaults} table managed by {@link UIManager}, the\n+   * value of which is the name of a class to load for the component's\n+   * {@link ui} property.\n+   *\n+   * @return A \"symbolic\" name which will map to a class to use for the\n+   * component's UI, such as <code>\"ComponentUI\"</code>\n+   *\n+   * @see #setUI\n+   * @see #updateUI\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"ComponentUI\";\n+  }\n+\n+  /**\n+   * Install a new UI delegate as the component's {@link ui} property. In\n+   * the process, this will call {@link ComponentUI.uninstallUI} on any\n+   * existing value for the {@link ui} property, and {@link\n+   * ComponentUI.installUI} on the new UI delegate.\n+   *\n+   * @param newUI The new UI delegate to install\n+   *\n+   * @see #updateUI\n+   * @see #getUIClassID\n+   */\n+  protected void setUI(ComponentUI newUI)\n+  {\n+    if (ui != null)\n+      ui.uninstallUI(this);\n+\n+    ui = newUI;\n+\n+    if (ui != null)\n+      ui.installUI(this);\n+\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * This method should be overridden in subclasses. In JComponent, the\n+   * method does nothing. In subclasses, it should a UI delegate\n+   * (corresponding to the symbolic name returned from {@link\n+   * getUIClassID}) from the {@link UIManager}, and calls {@link setUI}\n+   * with the new delegate.\n+   */\n+  public void updateUI()\n+  {\n+    System.out.println(\"update UI not overwritten in class: \" + this);\n+  }\n+\n+  public static Locale getDefaultLocale()\n+  {\n+    return defaultLocale;\n+  }\n+  \n+  public static void setDefaultLocale(Locale l)\n+  {\n+    defaultLocale = l;\n+  }\n }"}, {"sha": "b9f547e554275d3d7135280f14a1673397006635", "filename": "libjava/javax/swing/JDialog.java", "status": "modified", "additions": 470, "deletions": 204, "changes": 674, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJDialog.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJDialog.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJDialog.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -35,7 +35,6 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.awt.BorderLayout;\n@@ -45,251 +44,518 @@\n import java.awt.Dimension;\n import java.awt.Frame;\n import java.awt.Graphics;\n+import java.awt.GraphicsConfiguration;\n import java.awt.LayoutManager;\n import java.awt.event.KeyEvent;\n import java.awt.event.WindowEvent;\n+import java.awt.IllegalComponentStateException;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n \n+\n /**\n- * Unlike JComponent derivatives, JDialog inherits from\n- * java.awt.Dialog. But also lets a look-and-feel component to its work.\n+ * Unlike JComponent derivatives, JDialog inherits from java.awt.Dialog. But\n+ * also lets a look-and-feel component to its work.\n  *\n- * @author Ronald Veldema (rveldema@cs.vu.nl)\n+ * @author Ronald Veldema (rveldema_AT_cs.vu.nl)\n  */\n-public class JDialog extends Dialog implements Accessible, WindowConstants\n+public class JDialog extends Dialog implements Accessible, WindowConstants,\n+                                               RootPaneContainer\n {\n-    protected  AccessibleContext accessibleContext;\n-\n-    private int close_action = HIDE_ON_CLOSE;    \n-\n-    /***************************************************\n-     *\n-     *\n-     *  constructors\n-     *\n-     *\n-     *************/\n-\n-    public JDialog(Frame owner)\n-    {\n-\tthis(owner, \"dialog\");\n-    }\n-    \n-    public JDialog(Frame owner,\n-\t    String s)\n-    {\n-\tthis(owner, s, true);\n-    }\n-    \n-  public JDialog(Frame owner,\n-\t  String s,\n-\t  boolean modeld)\n-    {\n-\tsuper(owner, s, modeld);\n-    }\n-\n-  public JDialog(Frame owner,\n-\t  //  String s,\n-\t  boolean modeld)\n-    {\n-\tsuper(owner, \"JDialog\", modeld);\n-    }\n+\n+  /** DOCUMENT ME! */\n+  protected AccessibleContext accessibleContext;\n+\n+  /** The single RootPane in the Dialog. */\n+  protected JRootPane rootPane;\n+\n+  /** Whether checking is enabled on the RootPane */\n+  protected boolean rootPaneCheckingEnabled = true;\n+\n+  /** The default action taken when closed. */\n+  private int close_action = HIDE_ON_CLOSE;\n+  \n+  /** Whether JDialogs are decorated by the L&F. */\n+  private static boolean decorated = false;\n+\n+  /**\n+   * Creates a new non-modal JDialog with no title \n+   * using a shared Frame as the owner.\n+   */\n+  public JDialog()\n+  {\n+    this(SwingUtilities.getOwnerFrame(), \"\", false, null);\n+  }\n+\n+  /**\n+   * Creates a new non-modal JDialog with no title\n+   * using the given owner.\n+   *\n+   * @param owner The owner of the JDialog.\n+   */\n   public JDialog(Dialog owner)\n   {\n-      this(owner, \"dialog\");\n-  }\n-    \n-    public JDialog(Dialog owner,\n-\t    String s)\n-    {\n-\tthis(owner, s, true);\n-    }\n-    \n-  public JDialog(Dialog owner,\n-\t  String s,\n-\t  boolean modeld)\n-    {\n-\tsuper(owner, s, modeld);\n-    }\n-\n-\n-    /***************************************************\n-     *\n-     *\n-     *  methods, this part is shared with JDialog, JFrame\n-     *\n-     *\n-     *************/\n+    this(owner, \"\", false, null);\n+  }\n \n-  \n-    private boolean checking;\n-    protected  JRootPane         rootPane;\n+  /**\n+   * Creates a new JDialog with no title using the\n+   * given modal setting and owner.\n+   *\n+   * @param owner The owner of the JDialog.\n+   * @param modal Whether the JDialog is modal.\n+   */\n+  public JDialog(Dialog owner, boolean modal)\n+  {\n+    this(owner, \"\", modal, null);\n+  }\n \n-    void setLocationRelativeTo(Component c)\n-    {\n-    }\n+  /**\n+   * Creates a new non-modal JDialog using the \n+   * given title and owner.\n+   *\n+   * @param owner The owner of the JDialog.\n+   * @param title The title of the JDialog.\n+   */\n+  public JDialog(Dialog owner, String title)\n+  {\n+    this(owner, title, false, null);\n+  }\n \n+  /**\n+   * Creates a new JDialog using the given modal \n+   * settings, title, and owner.\n+   *\n+   * @param owner The owner of the JDialog.\n+   * @param title The title of the JDialog.\n+   * @param modal Whether the JDialog is modal.\n+   */\n+  public JDialog(Dialog owner, String title, boolean modal)\n+  {\n+    this(owner, title, modal, null);\n+  }\n \n-    protected  void frameInit()\n-    {\n-      super.setLayout(new BorderLayout(1, 1));\n-      getRootPane(); // will do set/create\n-    }\n-  \n+  /**\n+   * Creates a new JDialog using the given modal \n+   * settings, title, owner and graphics configuration.\n+   *\n+   * @param owner The owner of the JDialog.\n+   * @param title The title of the JDialog.\n+   * @param modal Whether the JDialog is modal.\n+   * @param gc The Graphics Configuration to use.\n+   */\n+  public JDialog(Dialog owner, String title, boolean modal,\n+                 GraphicsConfiguration gc)\n+  {\n+    super(owner, title, modal, gc);\n+    dialogInit();\n+  }\n+\n+  /**\n+   * Creates a new non-modal JDialog with no title\n+   * using the given owner.\n+   *\n+   * @param owner The owner of the JDialog.\n+   */\n+  public JDialog(Frame owner)\n+  {\n+    this(owner, \"\", false, null);\n+  }\n+\n+  /**\n+   * Creates a new JDialog with no title using the\n+   * given modal setting and owner.\n+   *\n+   * @param owner The owner of the JDialog.\n+   * @param modal Whether the JDialog is modal.\n+   */\n+  public JDialog(Frame owner, boolean modal)\n+  {\n+    this(owner, \"\", modal, null);\n+  }\n+\n+  /**\n+   * Creates a new non-modal JDialog using the \n+   * given title and owner.\n+   *\n+   * @param owner The owner of the JDialog.\n+   * @param title The title of the JDialog.\n+   */\n+  public JDialog(Frame owner, String title)\n+  {\n+    this(owner, title, false, null);\n+  }\n+\n+  /**\n+   * Creates a new JDialog using the given modal \n+   * settings, title, and owner.\n+   *\n+   * @param owner The owner of the JDialog.\n+   * @param title The title of the JDialog.\n+   * @param modal Whether the JDialog is modal.\n+   */\n+  public JDialog(Frame owner, String title, boolean modal)\n+  {\n+    this(owner, title, modal, null);\n+  }\n+\n+  /**\n+   * Creates a new JDialog using the given modal \n+   * settings, title, owner and graphics configuration.\n+   *\n+   * @param owner The owner of the JDialog.\n+   * @param title The title of the JDialog.\n+   * @param modal Whether the JDialog is modal.\n+   * @param gc The Graphics Configuration to use.\n+   */\n+  public JDialog(Frame owner, String title, boolean modal,\n+                 GraphicsConfiguration gc)\n+  {\n+    super((owner == null) ? SwingUtilities.getOwnerFrame() : owner, \n+          title, modal, gc);\n+    dialogInit();\n+  }\n+\n+  /**\n+   * This method is called to initialize the \n+   * JDialog. It sets the layout used, the locale, \n+   * and creates the RootPane.\n+   */\n+  protected void dialogInit()\n+  {\n+    // FIXME: Do a check on GraphicsEnvironment.isHeadless()\n+    setRootPaneCheckingEnabled(false);\n+    setLocale(JComponent.getDefaultLocale());       \n+    getRootPane(); // will do set/create  \n+    setRootPaneCheckingEnabled(true);    \n+    invalidate();\n+\n+  }\n+\n+  /**\n+   * This method returns whether JDialogs will have their\n+   * window decorations provided by the Look and Feel.\n+   *\n+   * @return Whether the window decorations are L&F provided.\n+   */\n+  public static boolean isDefaultLookAndFeelDecorated()\n+  {\n+    return decorated;\n+  }\n+\n+  /**\n+   * This method sets whether JDialogs will have their\n+   * window decorations provided by the Look and Feel.\n+   *\n+   * @param defaultLookAndFeelDecorated Whether the window\n+   * decorations are L&F provided.\n+   */\n+  public static void setDefaultLookAndFeelDecorated(boolean defaultLookAndFeelDecorated)\n+  {\n+    decorated = defaultLookAndFeelDecorated;\n+  }\n+\n+  /**\n+   * This method returns the preferred size of \n+   * the JDialog.\n+   *\n+   * @return The preferred size.\n+   */\n   public Dimension getPreferredSize()\n   {\n     Dimension d = super.getPreferredSize();\n     return d;\n   }\n \n-    JMenuBar getJMenuBar()\n-    {    return getRootPane().getJMenuBar();   }\n-    \n-    void setJMenuBar(JMenuBar menubar)\n-    {    getRootPane().setJMenuBar(menubar); }\n-    \n+  /**\n+   * This method returns the JMenuBar used\n+   * in this JDialog.\n+   *\n+   * @return The JMenuBar in the JDialog.\n+   */\n+  public JMenuBar getJMenuBar()\n+  {\n+    return getRootPane().getJMenuBar();\n+  }\n \n-  public  void setLayout(LayoutManager manager)\n-  {    super.setLayout(manager);  }\n+  /**\n+   * This method sets the JMenuBar used \n+   * in this JDialog.\n+   *\n+   * @param menubar The JMenuBar to use.\n+   */\n+  public void setJMenuBar(JMenuBar menubar)\n+  {\n+    getRootPane().setJMenuBar(menubar);\n+  }\n \n-    void setLayeredPane(JLayeredPane layeredPane) \n-    {   getRootPane().setLayeredPane(layeredPane);   }\n-  \n-    JLayeredPane getLayeredPane()\n-    {   return getRootPane().getLayeredPane();     }\n-  \n-    JRootPane getRootPane()\n-    {\n-\tif (rootPane == null)\n-\t    setRootPane(createRootPane());\n-\treturn rootPane;          \n-    }\n-\n-    void setRootPane(JRootPane root)\n-    {\n-\tif (rootPane != null)\n-\t    remove(rootPane);\n-\t    \n-\trootPane = root; \n-\tadd(rootPane, BorderLayout.CENTER);\n-    }\n-\n-    JRootPane createRootPane()\n-    {   return new JRootPane();    }\n-\n-    Container getContentPane()\n-    {    return getRootPane().getContentPane();     }\n-\n-    void setContentPane(Container contentPane)\n-    {    getRootPane().setContentPane(contentPane);    }\n-  \n-    Component getGlassPane()\n-    {    return getRootPane().getGlassPane();   }\n-  \n-    void setGlassPane(Component glassPane)\n-    {   getRootPane().setGlassPane(glassPane);   }\n+  /**\n+   * This method sets the LayoutManager used in the JDialog.\n+   * This method will throw an Error if rootPaneChecking is \n+   * enabled.\n+   *\n+   * @param manager The LayoutManager to use.\n+   */\n+  public void setLayout(LayoutManager manager)\n+  {\n+    if (isRootPaneCheckingEnabled())\n+      throw new Error(\"rootPaneChecking is enabled - cannot set layout.\");\n+    super.setLayout(manager);\n+  }\n \n-    \n-    protected  void addImpl(Component comp, Object constraints, int index)\n-    {\tsuper.addImpl(comp, constraints, index);    }\n+  /**\n+   * This method sets the JLayeredPane used in the JDialog.\n+   * If the given JLayeredPane is null, then this method\n+   * will throw an Error.\n+   *\n+   * @param layeredPane The JLayeredPane to use.\n+   */\n+  public void setLayeredPane(JLayeredPane layeredPane)\n+  {\n+    if (layeredPane == null)\n+      throw new IllegalComponentStateException(\"layeredPane cannot be null.\");\n+    getRootPane().setLayeredPane(layeredPane);\n+  }\n \n+  /**\n+   * This method returns the JLayeredPane used with this JDialog.\n+   *\n+   * @return The JLayeredPane used with this JDialog.\n+   */\n+  public JLayeredPane getLayeredPane()\n+  {\n+    return getRootPane().getLayeredPane();\n+  }\n \n-    public void remove(Component comp)\n-    {   getContentPane().remove(comp);  }\n-  \n-    protected  boolean isRootPaneCheckingEnabled()\n-    {    return checking;        }\n+  /**\n+   * This method returns the JRootPane used with this JDialog.\n+   *\n+   * @return The JRootPane used with this JDialog.\n+   */\n+  public JRootPane getRootPane()\n+  {\n+    if (rootPane == null)\n+      setRootPane(createRootPane());\n+    return rootPane;\n+  }\n \n+  /**\n+   * This method sets the JRootPane used with this JDialog.\n+   *\n+   * @param root The JRootPane to use.\n+   */\n+  protected void setRootPane(JRootPane root)\n+  {\n+    if (rootPane != null)\n+      remove(rootPane);\n \n-    protected  void setRootPaneCheckingEnabled(boolean enabled)\n-    { checking = enabled;  }\n+    rootPane = root;\n+    rootPane.show();\n+    add(rootPane);\n+  }\n \n+  /**\n+   * This method creates a new JRootPane.\n+   *\n+   * @return A new JRootPane.\n+   */\n+  protected JRootPane createRootPane()\n+  {\n+    return new JRootPane();\n+  }\n \n-    public void update(Graphics g)\n-    {   paint(g);  }\n+  /**\n+   * This method returns the ContentPane\n+   * in the JRootPane.\n+   *\n+   * @return The ContentPane in the JRootPane.\n+   */\n+  public Container getContentPane()\n+  {\n+    return getRootPane().getContentPane();\n+  }\n \n-    protected  void processKeyEvent(KeyEvent e)\n-    {\tsuper.processKeyEvent(e);    }\n+  /**\n+   * This method sets the ContentPane to use with this\n+   * JDialog. If the ContentPane given is null, this method\n+   * will throw an exception.\n+   *\n+   * @param contentPane The ContentPane to use with the JDialog.\n+   */\n+  public void setContentPane(Container contentPane)\n+  {\n+    if (contentPane == null)\n+      throw new IllegalComponentStateException(\"contentPane cannot be null.\");\n+    getRootPane().setContentPane(contentPane);\n+  }\n \n-    /////////////////////////////////////////////////////////////////////////////////\n-  \n+  /**\n+   * This method returns the GlassPane for this JDialog.\n+   *\n+   * @return The GlassPane for this JDialog.\n+   */\n+  public Component getGlassPane()\n+  {\n+    return getRootPane().getGlassPane();\n+  }\n+\n+  /**\n+   * This method sets the GlassPane for this JDialog.\n+   *\n+   * @param glassPane The GlassPane for this JDialog.\n+   */\n+  public void setGlassPane(Component glassPane)\n+  {\n+    getRootPane().setGlassPane(glassPane);\n+  }\n+\n+  /**\n+   * This method is called when a component is added to the \n+   * the JDialog. Calling this method with rootPaneCheckingEnabled\n+   * will cause an Error to be thrown.\n+   *\n+   * @param comp The component to add.\n+   * @param constraints The constraints.\n+   * @param index The position of the component.\n+   */\n+  protected void addImpl(Component comp, Object constraints, int index)\n+  {\n+    if (isRootPaneCheckingEnabled())\n+      throw new Error(\"rootPaneChecking is enabled - adding components disallowed.\");\n+    super.addImpl(comp, constraints, index);\n+  }\n+\n+  /**\n+   * This method removes a component from the JDialog.\n+   *\n+   * @param comp The component to remove.\n+   */\n+  public void remove(Component comp)\n+  {\n+    // The path changes if the component == root.\n+    if (comp == rootPane)\n+      super.remove(rootPane);\n+    else \n+      getContentPane().remove(comp);\n+  }\n \n-    protected  void processWindowEvent(WindowEvent e)\n-    {\n-\tsuper.processWindowEvent(e); \n-\tswitch (e.getID())\n+  /**\n+   * This method returns whether rootPane checking is enabled.\n+   *\n+   * @return Whether rootPane checking is enabled.\n+   */\n+  protected boolean isRootPaneCheckingEnabled()\n+  {\n+    return rootPaneCheckingEnabled;\n+  }\n+\n+  /**\n+   * This method sets whether rootPane checking is enabled.\n+   *\n+   * @param enabled Whether rootPane checking is enabled.\n+   */\n+  protected void setRootPaneCheckingEnabled(boolean enabled)\n+  {\n+    rootPaneCheckingEnabled = enabled;\n+  }\n+\n+  /**\n+   * This method simply calls paint and returns.\n+   *\n+   * @param g The Graphics object to paint with.\n+   */\n+  public void update(Graphics g)\n+  {\n+    paint(g);\n+  }\n+  \n+  \n+  /**\n+   * This method handles window events. This allows the JDialog\n+   * to honour its default close operation.\n+   *\n+   * @param e The WindowEvent.\n+   */\n+  protected void processWindowEvent(WindowEvent e)\n+  {\n+    //\tSystem.out.println(\"PROCESS_WIN_EV-1: \" + e);\n+    super.processWindowEvent(e);\n+    //\tSystem.out.println(\"PROCESS_WIN_EV-2: \" + e);\n+    switch (e.getID())\n+      {\n+      case WindowEvent.WINDOW_CLOSING:\n+        {\n+\t  switch (getDefaultCloseOperation())\n \t    {\n-\t    case WindowEvent.WINDOW_CLOSING:\n-\t\t{\n-\t\t    switch(close_action)\n-\t\t\t{\n-\t\t\tcase EXIT_ON_CLOSE:\n-\t\t\t  {\n-\t\t\t    System.exit(0);\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t\tcase DISPOSE_ON_CLOSE:\n-\t\t\t    {\n-\t\t\t\tdispose();\n-\t\t\t\tbreak;\n-\t\t\t    }\n-\t\t\tcase HIDE_ON_CLOSE:\n-\t\t\t    {\n-\t\t\t\tsetVisible(false);\n-\t\t\t\tbreak;\n-\t\t\t    }\n-\t\t\tcase DO_NOTHING_ON_CLOSE:\n-\t\t\t    break;\n-\t\t\t}\n-\t\t    break;\n-\t\t}\n-\t\t\n-\t    case WindowEvent.WINDOW_CLOSED:\n-\t    case WindowEvent.WINDOW_OPENED:\n-\t    case WindowEvent.WINDOW_ICONIFIED:\n-\t    case WindowEvent.WINDOW_DEICONIFIED:\n-\t    case WindowEvent.WINDOW_ACTIVATED:\n-\t    case WindowEvent.WINDOW_DEACTIVATED:\n+\t    case DISPOSE_ON_CLOSE:\n+\t      {\n+\t\tdispose();\n+\t\tbreak;\n+\t      }\n+\t    case HIDE_ON_CLOSE:\n+\t      {\n+\t\tsetVisible(false);\n \t\tbreak;\n+\t      }\n+\t    case DO_NOTHING_ON_CLOSE:\n+\t      break;\n \t    }\n-    }   \n- \n-\n-  /**\n-   * Defines what happens when this frame is closed. Can be one off\n-   * <code>EXIT_ON_CLOSE</code>,\n-   * <code>DISPOSE_ON_CLOSE</code>,\n-   * <code>HIDE_ON_CLOSE</code> or\n-   * <code>DO_NOTHING_ON_CLOSE</code>.\n-   * The default is <code>HIDE_ON_CLOSE</code>.\n-   * When <code>EXIT_ON_CLOSE</code> is specified this method calls\n-   * <code>SecurityManager.checkExit(0)</code> which might throw a\n-   * <code>SecurityException</code>. When the specified operation is\n-   * not one of the above a <code>IllegalArgumentException</code> is\n-   * thrown.\n+\t  break;\n+        }\n+      case WindowEvent.WINDOW_CLOSED:\n+      case WindowEvent.WINDOW_OPENED:\n+      case WindowEvent.WINDOW_ICONIFIED:\n+      case WindowEvent.WINDOW_DEICONIFIED:\n+      case WindowEvent.WINDOW_ACTIVATED:\n+      case WindowEvent.WINDOW_DEACTIVATED:\n+\tbreak;\n+      }\n+  }\n+\n+  /**\n+   * This method sets the action to take\n+   * when the JDialog is closed.\n+   *\n+   * @param operation The action to take.\n    */\n   public void setDefaultCloseOperation(int operation)\n   {\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null && operation == EXIT_ON_CLOSE)\n-      sm.checkExit(0);\n-    \n-    if (operation != EXIT_ON_CLOSE && operation != DISPOSE_ON_CLOSE\n-\t&& operation != HIDE_ON_CLOSE && operation != DO_NOTHING_ON_CLOSE)\n-      throw new IllegalArgumentException(\"operation = \" + operation);\n-    \n-    close_action = operation;\n+    if (operation == DO_NOTHING_ON_CLOSE ||\n+    \toperation == HIDE_ON_CLOSE ||\n+\toperation == DISPOSE_ON_CLOSE)\n+      close_action = operation;\n+    else\n+      throw new IllegalArgumentException(\"Default close operation must be one of DO_NOTHING_ON_CLOSE, HIDE_ON_CLOSE, or DISPOSE_ON_CLOSE\");\n   }\n-  \n+\n+  /**\n+   * This method returns the action taken when\n+   * the JDialog is closed.\n+   *\n+   * @return The action to take.\n+   */\n   public int getDefaultCloseOperation()\n-  {    return close_action;   }\n+  {\n+    return close_action;\n+  }\n \n-    protected  String paramString()\n-    {   return \"JDialog\";     }\n+  /**\n+   * This method returns a String describing the JDialog.\n+   *\n+   * @return A String describing the JDialog.\n+   */\n+  protected String paramString()\n+  {\n+    return \"JDialog\";\n+  }\n \n-    public AccessibleContext getAccessibleContext()\n-    {\n-\treturn null;\n-    }  \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    return null;\n+  }\n }"}, {"sha": "5c362cee7ab75ab9056872adf070efb4be2b9af8", "filename": "libjava/javax/swing/JFrame.java", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJFrame.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJFrame.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJFrame.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -57,7 +57,7 @@\n  *\n  * @author Ronald Veldema (rveldema@cs.vu.nl)\n  */\n-public class JFrame extends Frame implements WindowConstants\n+public class JFrame extends Frame implements WindowConstants, RootPaneContainer\n {\n     protected  AccessibleContext accessibleContext;\n \n@@ -121,20 +121,20 @@ void setJMenuBar(JMenuBar menubar)\n   public  void setLayout(LayoutManager manager)\n   {    super.setLayout(manager);  }\n \n-    void setLayeredPane(JLayeredPane layeredPane) \n+  public void setLayeredPane(JLayeredPane layeredPane) \n     {   getRootPane().setLayeredPane(layeredPane);   }\n   \n-    JLayeredPane getLayeredPane()\n+  public JLayeredPane getLayeredPane()\n     {   return getRootPane().getLayeredPane();     }\n   \n-    JRootPane getRootPane()\n+  public JRootPane getRootPane()\n     {\n \tif (rootPane == null)\n \t    setRootPane(createRootPane());\n \treturn rootPane;          \n     }\n \n-    void setRootPane(JRootPane root)\n+  public void setRootPane(JRootPane root)\n     {\n \tif (rootPane != null)\n \t    remove(rootPane);\n@@ -143,19 +143,19 @@ void setRootPane(JRootPane root)\n \tadd(rootPane, BorderLayout.CENTER);\n     }\n \n-    JRootPane createRootPane()\n+  public JRootPane createRootPane()\n     {   return new JRootPane();    }\n \n-    public Container getContentPane()\n+  public Container getContentPane()\n     {    return getRootPane().getContentPane();     }\n \n-    void setContentPane(Container contentPane)\n+  public void setContentPane(Container contentPane)\n     {    getRootPane().setContentPane(contentPane);    }\n   \n-    Component getGlassPane()\n+  public Component getGlassPane()\n     {    return getRootPane().getGlassPane();   }\n   \n-    void setGlassPane(Component glassPane)\n+  public void setGlassPane(Component glassPane)\n     {   getRootPane().setGlassPane(glassPane);   }\n \n     "}, {"sha": "37cd01221ce29c7f12646ad30cc752d2de3ea069", "filename": "libjava/javax/swing/JLayeredPane.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJLayeredPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJLayeredPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJLayeredPane.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -329,7 +329,7 @@ public void setPosition(Component c, int position)\n \t    throw new IllegalArgumentException ();\n \n     super.swapComponents (curr, targ);\n-    validate();\n+    revalidate();\n     repaint();\n   }\n     \n@@ -537,7 +537,7 @@ public void setLayer(Component c,\n   {\n     componentToLayer.put (c, getObjectForLayer (layer));\n     setPosition(c, position);\n-    validate();\n+    revalidate();\n     repaint();\n   }\n \n@@ -562,13 +562,13 @@ else if (componentToLayer.containsKey (comp))\n     else\n \t    layer = DEFAULT_LAYER;\n \n-    int newIdx = insertIndexForLayer(layer.intValue (), -1);\n+    int newIdx = insertIndexForLayer(layer.intValue (), index);\n \n     componentToLayer.put (comp, layer);\n     incrLayer (layer);\n \t\n     super.addImpl(comp, null, newIdx);\t\n-    validate();\n+    revalidate();\n     repaint();\n   }     \n }"}, {"sha": "b20c450c2565c52b395a9317afb703f985391fe7", "filename": "libjava/javax/swing/JList.java", "status": "modified", "additions": 134, "deletions": 3, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJList.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -40,6 +40,7 @@\n import java.awt.Color;\n import java.awt.Component;\n import java.awt.Dimension;\n+import java.awt.Point;\n import java.awt.Rectangle;\n import java.util.Vector;\n import javax.accessibility.Accessible;\n@@ -531,6 +532,19 @@ public void setSelectedIndex(int a)\n     selectionModel.setSelectionInterval(a, a);\n   }\n \n+  /**\n+   * For each element <code>a[i]</code> of the provided array\n+   * <code>a</code>, calls {@link #setSelectedIndex} on <code>a[i]</code>.\n+   *\n+   * @see #setSelectionMode\n+   * @see #selectionModel\n+   */\n+  public void setSelectedIndices(int [] a)\n+  {\n+    for (int i = 0; i < a.length; ++i)\n+      setSelectedIndex(a[i]);\n+  }\n+\n   /**\n    * Returns the minimum index of an element in the list which is currently\n    * selected.\n@@ -545,6 +559,32 @@ public int getSelectedIndex()\n     return selectionModel.getMinSelectionIndex();\n   }\n \n+  /**\n+   * Returns the indices of values in the {@link #model} property which are\n+   * selected.\n+   *\n+   * @return An array of model indices, each of which is selected according\n+   * to the {@link #selection} property\n+   */\n+  public int[] getSelectedIndices()\n+  {\n+    int lo, hi, n, i, j;\n+    if (selectionModel.isSelectionEmpty())\n+      return new int[0];\n+    lo = selectionModel.getMinSelectionIndex();\n+    hi = selectionModel.getMaxSelectionIndex();\n+    n = 0;\n+    for (i = lo; i < hi; ++i)\n+      if (selectionModel.isSelectedIndex(i))\n+        n++;\n+    int [] v = new int[n];\n+    j = 0;\n+    for (i = lo; i < hi; ++i)\n+      if (selectionModel.isSelectedIndex(i))\n+        v[j++] = i;\n+    return v;\n+  }\n+\n   /**\n    * Indicates whether the list element at a given index value is\n    * currently selected.\n@@ -568,6 +608,8 @@ public boolean isSelectedIndex(int a)\n    *\n    * @return The first selected element, or <code>null</code> if no element\n    * is selected.\n+   *\n+   * @see getSelectedValues\n    */\n   public Object getSelectedValue()\n   {\n@@ -577,6 +619,23 @@ public Object getSelectedValue()\n     return getModel().getElementAt(index);\n   }\n \n+  /**\n+   * Returns all the values in the list's {@link #model} property which\n+   * are selected, according to the list's {@link #selectionModel} property.\n+   *\n+   * @return An array containing all the selected values\n+   *\n+   * @see getSelectedValue\n+   */\n+  public Object[] getSelectedValues()\n+  {\n+    int [] idx = getSelectedIndices();\n+    Object [] v = new Object[idx.length];\n+    for (int i = 0; i < idx.length; ++i)\n+      v[i] = getModel().getElementAt(i);\n+    return v;\n+  }\n+\n   /**\n    * Gets the value of the {@link #selectionBackground} property.\n    *\n@@ -720,6 +779,8 @@ public void setModel(ListModel m)\n     if (model != null)\n       model.addListDataListener(listListener);\n     firePropertyChange(MODEL_PROPERTY_CHANGED, old, m);\n+    revalidate();\n+    repaint();\n   }\n \n \n@@ -744,6 +805,8 @@ public void setSelectionModel(ListSelectionModel l)\n     if (selectionModel != null)\n       selectionModel.addListSelectionListener(listListener);\n     firePropertyChange(SELECTION_MODEL_PROPERTY_CHANGED, old, l);\n+    revalidate();\n+    repaint();\n   }\n \n   /**\n@@ -842,11 +905,11 @@ public AccessibleContext getAccessibleContext()\n    * {@link Scrollable} interface, which interacts with {@link\n    * ScrollPaneLayout} and {@link Viewport} to define scrollable objects.\n    *\n-   * @return The preferred size, or <code>null</code>\n+   * @return The preferred size\n    */\n   public Dimension getPreferredScrollableViewportSize()\n   {\n-    return null;\n+    return getPreferredSize();\n   }\n \n   /**\n@@ -875,6 +938,71 @@ public Dimension getPreferredScrollableViewportSize()\n   public int getScrollableUnitIncrement(Rectangle visibleRect,\n                                         int orientation, int direction)\n   {\n+    ListUI lui = this.getUI();\n+    if (orientation == SwingConstants.VERTICAL)\n+      {\n+        if (direction > 0)\n+          {\n+            // Scrolling down\n+            Point bottomLeft = new Point(visibleRect.x,\n+                                         visibleRect.y + visibleRect.height);\n+            int curIdx = lui.locationToIndex(this, bottomLeft);\n+            Rectangle curBounds = lui.getCellBounds(this, curIdx, curIdx);\n+            if (curBounds.y + curBounds.height == bottomLeft.y)\n+              {\n+                // we are at the exact bottom of the current cell, so we \n+                // are being asked to scroll to the end of the next one\n+                if (curIdx + 1 < model.getSize())\n+                  {\n+                    // there *is* a next item in the list\n+                    Rectangle nxtBounds = lui.getCellBounds(this, curIdx + 1, curIdx + 1);\n+                    return nxtBounds.height;\n+                  }\n+                else\n+                  {\n+                    // no next item, no advance possible\n+                    return 0;\n+                  }\n+              }\n+            else\n+              {\n+                // we are part way through an existing cell, so we are being\n+                // asked to scroll to the bottom of it\n+                return (curBounds.y + curBounds.height) - bottomLeft.y;\n+              }\t\t      \n+          }\n+        else\n+          {\n+            // scrolling up\n+            Point topLeft = new Point(visibleRect.x, visibleRect.y);\n+            int curIdx = lui.locationToIndex(this, topLeft);\n+            Rectangle curBounds = lui.getCellBounds(this, curIdx, curIdx);\n+            if (curBounds.y == topLeft.y)\n+              {\n+                // we are at the exact top of the current cell, so we \n+                // are being asked to scroll to the top of the previous one\n+                if (curIdx > 0)\n+                  {\n+                    // there *is* a previous item in the list\n+                    Rectangle nxtBounds = lui.getCellBounds(this, curIdx - 1, curIdx - 1);\n+                    return -nxtBounds.height;\n+                  }\n+                else\n+                  {\n+                    // no previous item, no advance possible\n+                    return 0;\n+                  }\n+              }\n+            else\n+              {\n+                // we are part way through an existing cell, so we are being\n+                // asked to scroll to the top of it\n+                return curBounds.y - topLeft.y;\n+              }\t\t      \n+          }\n+      }\n+\n+    // FIXME: handle horizontal scrolling (also wrapping?)\n     return 1;\n   }\n \n@@ -904,7 +1032,10 @@ public int getScrollableUnitIncrement(Rectangle visibleRect,\n   public int getScrollableBlockIncrement(Rectangle visibleRect,\n                                          int orientation, int direction)\n   {\n-    return 1;\n+      if (orientation == VERTICAL)\n+\t  return visibleRect.height * direction;\n+      else\n+\t  return visibleRect.width * direction;\n   }\n \n   /**"}, {"sha": "b7d1b8269831695d3a1df64acf0ffec63596226d", "filename": "libjava/javax/swing/JMenu.java", "status": "modified", "additions": 781, "deletions": 709, "changes": 1490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJMenu.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJMenu.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJMenu.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -46,724 +46,796 @@\n import java.io.IOException;\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n+import java.util.EventListener;\n import java.util.Hashtable;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n import javax.accessibility.AccessibleSelection;\n+import javax.swing.event.ChangeListener;\n import javax.swing.event.MenuEvent;\n import javax.swing.event.MenuListener;\n-import javax.swing.event.ChangeListener;\n+import javax.swing.plaf.MenuItemUI;\n+\n \n /**\n- * JMenu\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * DOCUMENT ME!\n+ *\n+ * @author $author$\n+ * @version $Revision: 1.3.8.1 $\n  */\n-public class JMenu\n-  extends JMenuItem\n-  implements Accessible, MenuElement\n+public class JMenu extends JMenuItem implements Accessible, MenuElement\n {\n   static final long serialVersionUID = 4227225638931828014L;\n-\n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * AccessibleJMenu\n-\t */\n-\tprotected class AccessibleJMenu extends AccessibleJMenuItem \n-\t\t\timplements AccessibleSelection {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJMenu\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJMenu(JMenu component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJMenu()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleChildrenCount\n-\t\t * @returns int\n-\t\t */\n-\t\tpublic int getAccessibleChildrenCount() {\n-\t\t\treturn 0; // TODO\n-\t\t} // getAccessibleChildrenCount()\n-\n-\t\t/**\n-\t\t * getAccessibleChild\n-\t\t * @param value0 TODO\n-\t\t * @returns Accessible\n-\t\t */\n-\t\tpublic Accessible getAccessibleChild(int value0) {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleChild()\n-\n-\t\t/**\n-\t\t * getAccessibleSelection\n-\t\t * @returns AccessibleSelection\n-\t\t */\n-\t\tpublic AccessibleSelection getAccessibleSelection() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleSelection()\n-\n-\t\t/**\n-\t\t * getAccessibleSelection\n-\t\t * @param value0 TODO\n-\t\t * @returns Accessible\n-\t\t */\n-\t\tpublic Accessible getAccessibleSelection(int value0) {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleSelection()\n-\n-\t\t/**\n-\t\t * isAccessibleChildSelected\n-\t\t * @param value0 TODO\n-\t\t * @returns boolean\n-\t\t */\n-\t\tpublic boolean isAccessibleChildSelected(int value0) {\n-\t\t\treturn false; // TODO\n-\t\t} // isAccessibleChildSelected()\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn AccessibleRole.MENU;\n-\t\t} // getAccessibleRole()\n-\n-\t\t/**\n-\t\t * getAccessibleSelectionCount\n-\t\t * @returns int\n-\t\t */\n-\t\tpublic int getAccessibleSelectionCount() {\n-\t\t\treturn 0; // TODO\n-\t\t} // getAccessibleSelectionCount()\n-\n-\t\t/**\n-\t\t * addAccessibleSelection\n-\t\t * @param value0 TODO\n-\t\t */\n-\t\tpublic void addAccessibleSelection(int value0) {\n-\t\t\t// TODO\n-\t\t} // addAccessibleSelection()\n-\n-\t\t/**\n-\t\t * removeAccessibleSelection\n-\t\t * @param value0 TODO\n-\t\t */\n-\t\tpublic void removeAccessibleSelection(int value0) {\n-\t\t\t// TODO\n-\t\t} // removeAccessibleSelection()\n-\n-\t\t/**\n-\t\t * clearAccessibleSelection\n-\t\t */\n-\t\tpublic void clearAccessibleSelection() {\n-\t\t\t// TODO\n-\t\t} // clearAccessibleSelection()\n-\n-\t\t/**\n-\t\t * selectAllAccessibleSelection\n-\t\t */\n-\t\tpublic void selectAllAccessibleSelection() {\n-\t\t\t// TODO\n-\t\t} // selectAllAccessibleSelection()\n-\n-\n-\t} // AccessibleJMenu\n-\n-\t/**\n-\t * WinListener\n-\t */\n-\tprotected class WinListener extends WindowAdapter implements Serializable {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * popupMenu\n-\t\t */\n-\t\tJPopupMenu popupMenu;\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor WinListener\n-\t\t * @param value0 TODO\n-\t\t * @param value1 TODO\n-\t\t */\n-\t\tpublic WinListener(JMenu value0, JPopupMenu value1) {\n-\t\t\t// TODO\n-\t\t} // WinListener()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * windowClosing\n-\t\t * @param value0 TODO\n-\t\t */\n-\t\tpublic void windowClosing(WindowEvent value0) {\n-\t\t\t// TODO\n-\t\t} // windowClosing()\n-\n-\n-\t} // WinListener\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * uiClassID\n-\t */\n-\tprivate static final String uiClassID = \"MenuUI\";\n-\n-\t/**\n-\t * popupMenu\n-\t */\n-\tprivate JPopupMenu popupMenu;\n-\n-\t/**\n-\t * menuChangeListener\n-\t */\n-\tprivate ChangeListener menuChangeListener;\n-\n-\t/**\n-\t * menuEvent\n-\t */\n-\tprivate MenuEvent menuEvent;\n-\n-\t/**\n-\t * listenerRegistry\n-\t */\n-\tprivate static Hashtable listenerRegistry = null; // TODO\n-\n-\t/**\n-\t * delay\n-\t */\n-\tprivate int delay;\n-\n-\t/**\n-\t * TRACE\n-\t */\n-\tprivate static final boolean TRACE = false; // TODO\n-\n-\t/**\n-\t * VERBOSE\n-\t */\n-\tprivate static final boolean VERBOSE = false; // TODO\n-\n-\t/**\n-\t * DEBUG\n-\t */\n-\tprivate static final boolean DEBUG = false; // TODO\n-\n-\t/**\n-\t * popupListener\n-\t */\n-\tprotected JMenu.WinListener popupListener;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor JMenu\n-\t */\n-\tpublic JMenu() {\n-\t\t// TODO\n-\t} // JMenu()\n-\n-\t/**\n-\t * Constructor JMenu\n-\t * @param text TODO\n-\t */\n-\tpublic JMenu(String text) {\n-\t\t// TODO\n-\t} // JMenu()\n-\n-\t/**\n-\t * Constructor JMenu\n-\t * @param action TODO\n-\t */\n-\tpublic JMenu(Action action) {\n-\t\t// TODO\n-\t} // JMenu()\n-\n-\t/**\n-\t * Constructor JMenu\n-\t * @param text TODO\n-\t * @param tearoff TODO\n-\t */\n-\tpublic JMenu(String text, boolean tearoff) {\n-\t\t// TODO\n-\t} // JMenu()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * writeObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n-\t */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n-\t\t// TODO\n-\t} // writeObject()\n-\n-\t/**\n-\t * add\n-\t * @param value0 TODO\n-\t * @returns JMenuItem\n-\t */\n-\tpublic JMenuItem add(JMenuItem item) {\n-\t\treturn null; // TODO\n-\t} // add()\n-\n-\t/**\n-\t * add\n-\t * @param component TODO\n-\t * @returns Component\n-\t */\n-\tpublic Component add(Component component) {\n-\t\treturn null; // TODO\n-\t} // add()\n-\n-\t/**\n-\t * add\n-\t * @param component TODO\n-\t * @param index TODO\n-\t * @returns Component\n-\t */\n-\tpublic Component add(Component component, int index) {\n-\t\treturn null; // TODO\n-\t} // add()\n-\n-\t/**\n-\t * add\n-\t * @param text TODO\n-\t * @returns JMenuItem\n-\t */\n-\tpublic JMenuItem add(String text) {\n-\t\treturn null; // TODO\n-\t} // add()\n-\n-\t/**\n-\t * add\n-\t * @param action TODO\n-\t * @returns JMenuItem\n-\t */\n-\tpublic JMenuItem add(Action action) {\n-\t\treturn null; // TODO\n-\t} // add()\n-\n-\t/**\n-\t * remove\n-\t * @param item TODO\n-\t */\n-\tpublic void remove(JMenuItem item) {\n-\t\t// TODO\n-\t} // remove()\n-\n-\t/**\n-\t * remove\n-\t * @param index TODO\n-\t */\n-\tpublic void remove(int index) {\n-\t\t// TODO\n-\t} // remove()\n-\n-\t/**\n-\t * remove\n-\t * @param component TODO\n-\t */\n-\tpublic void remove(Component component) {\n-\t\t// TODO\n-\t} // remove()\n-\n-\t/**\n-\t * removeAll\n-\t */\n-\tpublic void removeAll() {\n-\t\t// TODO\n-\t} // removeAll()\n-\n-\t/**\n-\t * insert\n-\t * @param text TODO\n-\t * @param index TODO\n-\t */\n-\tpublic void insert(String text, int index) {\n-\t\t// TODO\n-\t} // insert()\n-\n-\t/**\n-\t * insert\n-\t * @param item TODO\n-\t * @param index TODO\n-\t * @returns JMenuItem\n-\t */\n-\tpublic JMenuItem insert(JMenuItem item, int index) {\n-\t\treturn null; // TODO\n-\t} // insert()\n-\n-\t/**\n-\t * insert\n-\t * @param action TODO\n-\t * @param index TODO\n-\t * @returns JMenuItem\n-\t */\n-\tpublic JMenuItem insert(Action action, int index) {\n-\t\treturn null; // TODO\n-\t} // insert()\n-\n-\t/**\n-\t * updateUI\n-\t */\n-\tpublic void updateUI() {\n-\t\t//setUI((MenuUI) UIManager.get(this));\n-\t\tinvalidate();\n-\t} // updateUI()\n-\n-\t/**\n-\t * getUIClassID\n-\t * @returns String\n-\t */\n-\tpublic String getUIClassID() {\n-\t\treturn uiClassID;\n-\t} // getUIClassID()\n-\n-\t/**\n-\t * setModel\n-\t * @param model TODO\n-\t */\n-\tpublic void setModel(ButtonModel model) {\n-\t\t// TODO\n-\t} // setModel()\n-\n-\t/**\n-\t * isSelected\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isSelected() {\n-\t\treturn false; // TODO\n-\t} // isSelected()\n-\n-\t/**\n-\t * setSelected\n-\t * @param selected TODO\n-\t */\n-\tpublic void setSelected(boolean selected) {\n-\t\t// TODO\n-\t} // setSelected()\n-\n-\t/**\n-\t * isPopupMenuVisible\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isPopupMenuVisible() {\n-\t\treturn false; // TODO\n-\t} // isPopupMenuVisible()\n-\n-\t/**\n-\t * setPopupMenuVisible\n-\t * @param popup TODO\n-\t */\n-\tpublic void setPopupMenuVisible(boolean popup) {\n-\t\t// TODO\n-\t} // setPopupMenuVisible()\n-\n-\t/**\n-\t * getPopupMenuOrigin\n-\t * @returns Point\n-\t */\n-\tprotected Point getPopupMenuOrigin() {\n-\t\treturn null; // TODO\n-\t} // getPopupMenuOrigin()\n-\n-\t/**\n-\t * getDelay\n-\t * @returns int\n-\t */\n-\tpublic int getDelay() {\n-\t\treturn 0; // TODO\n-\t} // getDelay()\n-\n-\t/**\n-\t * setDelay\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setDelay(int delay) {\n-\t\t// TODO\n-\t} // setDelay()\n-\n-\t/**\n-\t * setMenuLocation\n-\t * @param x TODO\n-\t * @param y TODO\n-\t */\n-\tpublic void setMenuLocation(int x, int y) {\n-\t\t// TODO\n-\t} // setMenuLocation()\n-\n-\t/**\n-\t * createActionComponent\n-\t * @param action TODO\n-\t * @returns JMenuItem\n-\t */\n-\tprotected JMenuItem createActionComponent(Action action) {\n-\t\treturn null; // TODO\n-\t} // createActionComponent()\n-\n-\t/**\n-\t * createActionChangeListener\n-\t * @param item TODO\n-\t * @returns PropertyChangeListener\n-\t */\n-\tprotected PropertyChangeListener createActionChangeListener(JMenuItem item) {\n-\t\treturn null; // TODO\n-\t} // createActionChangeListener()\n-\n-\t/**\n-\t * addSeparator\n-\t */\n-\tpublic void addSeparator() {\n-\t\t// TODO\n-\t} // addSeparator()\n-\n-\t/**\n-\t * insertSeparator\n-\t * @param index TODO\n-\t */\n-\tpublic void insertSeparator(int index) {\n-\t\t// TODO\n-\t} // insertSeparator()\n-\n-\t/**\n-\t * getItem\n-\t * @param index TODO\n-\t * @returns JMenuItem\n-\t */\n-\tpublic JMenuItem getItem(int index) {\n-\t\treturn null; // TODO\n-\t} // getItem()\n-\n-\t/**\n-\t * getItemCount\n-\t * @returns int\n-\t */\n-\tpublic int getItemCount() {\n-\t\treturn 0; // TODO\n-\t} // getItemCount()\n-\n-\t/**\n-\t * isTearOff\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isTearOff() {\n-\t\treturn false; // TODO\n-\t} // isTearOff()\n-\n-\t/**\n-\t * getMenuComponentCount\n-\t * @returns int\n-\t */\n-\tpublic int getMenuComponentCount() {\n-\t\treturn 0; // TODO\n-\t} // getMenuComponentCount()\n-\n-\t/**\n-\t * getMenuComponent\n-\t * @param index TODO\n-\t * @returns Component\n-\t */\n-\tpublic Component getMenuComponent(int index) {\n-\t\treturn null; // TODO\n-\t} // getMenuComponent()\n-\n-\t/**\n-\t * getMenuComponents\n-\t * @returns Component[]\n-\t */\n-\tpublic Component[] getMenuComponents() {\n-\t\treturn null; // TODO\n-\t} // getMenuComponents()\n-\n-\t/**\n-\t * isTopLevelMenu\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isTopLevelMenu() {\n-\t\treturn false; // TODO\n-\t} // isTopLevelMenu()\n-\n-\t/**\n-\t * isMenuComponent\n-\t * @param component TODO\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isMenuComponent(Component component) {\n-\t\treturn false; // TODO\n-\t} // isMenuComponent()\n-\n-\t/**\n-\t * getPopupMenu\n-\t * @returns JPopupMenu\n-\t */\n-\tpublic JPopupMenu getPopupMenu() {\n-\t\treturn null; // TODO\n-\t} // getPopupMenu()\n-\n-\t/**\n-\t * addMenuListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void addMenuListener(MenuListener listener) {\n-\t\t// TODO\n-\t} // addMenuListener()\n-\n-\t/**\n-\t * removeMenuListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void removeMenuListener(MenuListener listener) {\n-\t\t// TODO\n-\t} // removeMenuListener()\n-\n-\t/**\n-\t * fireMenuSelected\n-\t */\n-\tprotected void fireMenuSelected() {\n-\t\t// TODO\n-\t} // fireMenuSelected()\n-\n-\t/**\n-\t * fireMenuDeselected\n-\t */\n-\tprotected void fireMenuDeselected() {\n-\t\t// TODO\n-\t} // fireMenuDeselected()\n-\n-\t/**\n-\t * fireMenuCanceled\n-\t */\n-\tprotected void fireMenuCanceled() {\n-\t\t// TODO\n-\t} // fireMenuCanceled()\n-\n-\t/**\n-\t * createMenuChangeListener\n-\t * @returns ChangeListener\n-\t */\n-\tprivate ChangeListener createMenuChangeListener() {\n-\t\treturn null; // TODO\n-\t} // createMenuChangeListener()\n-\n-\t/**\n-\t * createWinListener\n-\t * @param popup TODO\n-\t * @returns JMenu.WinListener\n-\t */\n-\tprotected JMenu.WinListener createWinListener(JPopupMenu popup) {\n-\t\treturn null; // TODO\n-\t} // createWinListener()\n-\n-\t/**\n-\t * menuSelectionChanged\n-\t * @param value0 TODO\n-\t */\n-\tpublic void menuSelectionChanged(boolean changed) {\n-\t\t// TODO\n-\t} // menuSelectionChanged()\n-\n-\t/**\n-\t * getSubElements\n-\t * @returns MenuElement[]\n-\t */\n-\tpublic MenuElement[] getSubElements() {\n-\t\treturn null; // TODO\n-\t} // getSubElements()\n-\n-\t/**\n-\t * getComponent\n-\t * @returns Component\n-\t */\n-\tpublic Component getComponent() {\n-\t\treturn null; // TODO\n-\t} // getComponent()\n-\n-\t/**\n-\t * setAccelerator\n-\t * @param keystroke TODO\n-\t */\n-\tpublic void setAccelerator(KeyStroke keystroke) {\n-\t\t// TODO\n-\t} // setAccelerator()\n-\n-\t/**\n-\t * processKeyEvent\n-\t * @param event TODO\n-\t */\n-\tprotected void processKeyEvent(KeyEvent event) {\n-\t\t// TODO\n-\t} // processKeyEvent()\n-\n-\t/**\n-\t * doClick\n-\t * @param time TODO\n-\t */\n-\tpublic void doClick(int time) {\n-\t\t// TODO\n-\t} // doClick()\n-\n-\t/**\n-\t * paramString\n-\t * @returns String\n-\t */\n-\tprotected String paramString() {\n-\t\treturn null; // TODO\n-\t} // paramString()\n-\n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJMenu(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n-} // JMenu\n+  private static final String uiClassID = \"MenuUI\";\n+  private static Hashtable listenerRegistry = null;\n+  private JPopupMenu popupMenu = new JPopupMenu();\n+  private ChangeListener menuChangeListener;\n+  private MenuEvent menuEvent;\n+  private int delay;\n+  protected JMenu.WinListener popupListener;\n+\n+  /**\n+   * Creates a new JMenu object.\n+   */\n+  public JMenu()\n+  {\n+    super();\n+  }\n+\n+  /**\n+   * Creates a new JMenu object.\n+   *\n+   * @param text DOCUMENT ME!\n+   */\n+  public JMenu(String text)\n+  {\n+    super(text);\n+  }\n+\n+  /**\n+   * Creates a new JMenu object.\n+   *\n+   * @param action DOCUMENT ME!\n+   */\n+  public JMenu(Action action)\n+  {\n+    super(action);\n+  }\n+\n+  /**\n+   * Creates a new JMenu object.\n+   *\n+   * @param text DOCUMENT ME!\n+   * @param tearoff DOCUMENT ME!\n+   */\n+  public JMenu(String text, boolean tearoff)\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param stream DOCUMENT ME!\n+   *\n+   * @throws IOException DOCUMENT ME!\n+   */\n+  private void writeObject(ObjectOutputStream stream) throws IOException\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param item DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public JMenuItem add(JMenuItem item)\n+  {\n+    return popupMenu.add(item);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param component DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Component add(Component component)\n+  {\n+    return popupMenu.add(component);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param component DOCUMENT ME!\n+   * @param index DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Component add(Component component, int index)\n+  {\n+    return popupMenu.add(component, index);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param text DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public JMenuItem add(String text)\n+  {\n+    return popupMenu.add(text);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param action DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public JMenuItem add(Action action)\n+  {\n+    return popupMenu.add(action);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param item DOCUMENT ME!\n+   */\n+  public void remove(JMenuItem item)\n+  {\n+    popupMenu.remove(item);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param index DOCUMENT ME!\n+   */\n+  public void remove(int index)\n+  {\n+    popupMenu.remove(index);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param component DOCUMENT ME!\n+   */\n+  public void remove(Component component)\n+  {\n+    int index = popupMenu.getComponentIndex(component);\n+    popupMenu.remove(index);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  public void removeAll()\n+  {\n+    popupMenu.removeAll();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param text DOCUMENT ME!\n+   * @param index DOCUMENT ME!\n+   */\n+  public void insert(String text, int index)\n+  {\n+    popupMenu.insert(new JMenuItem(text), index);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param item DOCUMENT ME!\n+   * @param index DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public JMenuItem insert(JMenuItem item, int index)\n+  {\n+    popupMenu.insert(item, index);\n+\n+    return item;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param action DOCUMENT ME!\n+   * @param index DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public JMenuItem insert(Action action, int index)\n+  {\n+    JMenuItem item = new JMenuItem(action);\n+    popupMenu.insert(item, index);\n+\n+    return item;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  public void updateUI()\n+  {\n+    super.setUI((MenuItemUI) UIManager.getUI(this));\n+    invalidate();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public String getUIClassID()\n+  {\n+    return uiClassID;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param model DOCUMENT ME!\n+   */\n+  public void setModel(ButtonModel model)\n+  {\n+    super.setModel(model);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isSelected()\n+  {\n+    return super.isSelected();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param selected DOCUMENT ME!\n+   */\n+  public void setSelected(boolean selected)\n+  {\n+    super.setSelected(selected);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isPopupMenuVisible()\n+  {\n+    return popupMenu.isVisible();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param popup DOCUMENT ME!\n+   */\n+  public void setPopupMenuVisible(boolean popup)\n+  {\n+    if (isEnabled())\n+      popupMenu.setVisible(popup);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected Point getPopupMenuOrigin()\n+  {\n+    // if menu in the menu bar\n+    if (isTopLevelMenu())\n+      return new Point(0, this.getHeight());\n+\n+    // if submenu            \n+    return new Point(this.getWidth(), 0);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public int getDelay()\n+  {\n+    return delay;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param delay DOCUMENT ME!\n+   */\n+  public void setDelay(int delay)\n+  {\n+    this.delay = delay;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param x DOCUMENT ME!\n+   * @param y DOCUMENT ME!\n+   */\n+  public void setMenuLocation(int x, int y)\n+  {\n+    popupMenu.setLocation(x, y);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param action DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected JMenuItem createActionComponent(Action action)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param item DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected PropertyChangeListener createActionChangeListener(JMenuItem item)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  public void addSeparator()\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param index DOCUMENT ME!\n+   */\n+  public void insertSeparator(int index)\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param index DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public JMenuItem getItem(int index)\n+  {\n+    Component c = popupMenu.getComponentAtIndex(index);\n+\n+    if (c instanceof JMenuItem)\n+      return (JMenuItem) c;\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public int getItemCount()\n+  {\n+    return 0;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isTearOff()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public int getMenuComponentCount()\n+  {\n+    return popupMenu.getComponentCount();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param index DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Component getMenuComponent(int index)\n+  {\n+    return (Component) popupMenu.getComponentAtIndex(index);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Component[] getMenuComponents()\n+  {\n+    return popupMenu.getComponents();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isTopLevelMenu()\n+  {\n+    if (getParent() instanceof JMenuBar)\n+      return true;\n+    else\n+      return false;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param component DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isMenuComponent(Component component)\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public JPopupMenu getPopupMenu()\n+  {\n+    return popupMenu;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param listener DOCUMENT ME!\n+   */\n+  public void addMenuListener(MenuListener listener)\n+  {\n+    listenerList.add(MenuListener.class, listener);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param listener DOCUMENT ME!\n+   */\n+  public void removeMenuListener(MenuListener listener)\n+  {\n+    listenerList.remove(MenuListener.class, listener);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void fireMenuSelected()\n+  {\n+    EventListener[] ll = listenerList.getListeners(MenuListener.class);\n+\n+    for (int i = 0; i < ll.length; i++)\n+      ((MenuListener) ll[i]).menuSelected(new MenuEvent(this));\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void fireMenuDeselected()\n+  {\n+    EventListener[] ll = listenerList.getListeners(MenuListener.class);\n+\n+    for (int i = 0; i < ll.length; i++)\n+      ((MenuListener) ll[i]).menuDeselected(new MenuEvent(this));\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void fireMenuCanceled()\n+  {\n+    EventListener[] ll = listenerList.getListeners(MenuListener.class);\n+\n+    for (int i = 0; i < ll.length; i++)\n+      ((MenuListener) ll[i]).menuCanceled(new MenuEvent(this));\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  private ChangeListener createMenuChangeListener()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param popup DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected JMenu.WinListener createWinListener(JPopupMenu popup)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param changed DOCUMENT ME!\n+   */\n+  public void menuSelectionChanged(boolean changed)\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public MenuElement[] getSubElements()\n+  {\n+    return new MenuElement[] { popupMenu };\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Component getComponent()\n+  {\n+    return this;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param keystroke DOCUMENT ME!\n+   */\n+  public void setAccelerator(KeyStroke keystroke)\n+  {\n+    super.setAccelerator(keystroke);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   */\n+  protected void processKeyEvent(KeyEvent event)\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param time DOCUMENT ME!\n+   */\n+  public void doClick(int time)\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected String paramString()\n+  {\n+    return \"JMenu\";\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJMenu(this);\n+\n+    return accessibleContext;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.3.8.1 $\n+   */\n+  protected class AccessibleJMenu extends AccessibleJMenuItem\n+    implements AccessibleSelection\n+  {\n+    /**\n+     * Creates a new AccessibleJMenu object.\n+     *\n+     * @param component DOCUMENT ME!\n+     */\n+    protected AccessibleJMenu(JMenu component)\n+    {\n+      super(component);\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public int getAccessibleChildrenCount()\n+    {\n+      return 0;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param value0 DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Accessible getAccessibleChild(int value0)\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleSelection getAccessibleSelection()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param value0 DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Accessible getAccessibleSelection(int value0)\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param value0 DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public boolean isAccessibleChildSelected(int value0)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return AccessibleRole.MENU;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public int getAccessibleSelectionCount()\n+    {\n+      return 0;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param value0 DOCUMENT ME!\n+     */\n+    public void addAccessibleSelection(int value0)\n+    {\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param value0 DOCUMENT ME!\n+     */\n+    public void removeAccessibleSelection(int value0)\n+    {\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     */\n+    public void clearAccessibleSelection()\n+    {\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     */\n+    public void selectAllAccessibleSelection()\n+    {\n+    }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.3.8.1 $\n+   */\n+  protected class WinListener extends WindowAdapter implements Serializable\n+  {\n+    JPopupMenu popupMenu;\n+\n+    /**\n+     * Creates a new WinListener object.\n+     *\n+     * @param value0 DOCUMENT ME!\n+     * @param value1 DOCUMENT ME!\n+     */\n+    public WinListener(JMenu value0, JPopupMenu value1)\n+    {\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param value0 DOCUMENT ME!\n+     */\n+    public void windowClosing(WindowEvent value0)\n+    {\n+    }\n+  }\n+}"}, {"sha": "7ec52968a42ba43215bb213719e38e0e92c52dad", "filename": "libjava/javax/swing/JMenuBar.java", "status": "modified", "additions": 384, "deletions": 5, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJMenuBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJMenuBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJMenuBar.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -35,13 +35,392 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n+import javax.accessibility.Accessible;\n+import javax.accessibility.AccessibleContext;\n+import javax.accessibility.AccessibleRole;\n+import javax.accessibility.AccessibleSelection;\n+import javax.accessibility.AccessibleStateSet;\n+import javax.accessibility.AccessibleValue;\n+import javax.swing.UIManager;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.event.MenuDragMouseEvent;\n+import javax.swing.event.MenuDragMouseListener;\n+import javax.swing.event.MenuKeyEvent;\n+import javax.swing.event.MenuKeyListener;\n+import javax.swing.plaf.MenuBarUI;\n+import javax.swing.plaf.MenuItemUI;\n+\n \n-public class JMenuBar extends JComponent\n+/**\n+ * DOCUMENT ME!\n+ *\n+ * @author $author$\n+ * @version $Revision: 1.2.18.1 $\n+ */\n+public class JMenuBar extends JComponent implements Accessible, MenuElement\n {\n-  JMenuBar()\n-    {\n-    }\n+  private transient SingleSelectionModel selectionModel;\n+  private boolean paintBorder;\n+  private Insets margin;\n+\n+  /**\n+   * Creates a new JMenuBar object.\n+   */\n+  public JMenuBar()\n+  {\n+    selectionModel = new DefaultSingleSelectionModel();\n+    paintBorder = true;\n+    updateUI();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public JMenu add(JMenu c)\n+  {\n+    c.setAlignmentX(Component.LEFT_ALIGNMENT);\n+    super.add(c);\n+    return c;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  public void addNotify()\n+  {\n+    // FIXME: Should register this menu bar with the keyboard manager     \n+    super.addNotify();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Component getComponent()\n+  {\n+    return this;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param i DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Component getComponentAtIndex(int i)\n+  {\n+    return getComponentAt(i);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public int getComponentIndex(Component c)\n+  {\n+    Component[] comps = getComponents();\n+\n+    int index = -1;\n+\n+    for (int i = 0; i < comps.length; i++)\n+      {\n+\tif (comps[i].equals(c))\n+\t  {\n+\t    index = i;\n+\t    break;\n+\t  }\n+      }\n+\n+    return index;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public JMenu getHelpMenu()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Insets getMargin()\n+  {\n+    if (margin == null)\n+      return new Insets(0, 0, 0, 0);\n+    else\n+      return margin;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param index DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public JMenu getMenu(int index)\n+  {\n+    if (getComponentAtIndex(index) instanceof JMenu)\n+      return (JMenu) getComponentAtIndex(index);\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public int getMenuCount()\n+  {\n+    return getComponentCount();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public SingleSelectionModel getSelectionModel()\n+  {\n+    return selectionModel;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public MenuElement[] getSubElements()\n+  {\n+    MenuElement[] subElements = new MenuElement[getComponentCount()];\n+\n+    for (int i = 0; i < getComponentCount(); i++)\n+      subElements[i] = (MenuElement) getMenu(i);\n+\n+    return subElements;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public MenuBarUI getUI()\n+  {\n+    return (MenuBarUI) ui;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"MenuBarUI\";\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isBorderPainted()\n+  {\n+    return paintBorder;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isManagingFocus()\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isSelected()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param isIncluded DOCUMENT ME!\n+   */\n+  public void menuSelectionChanged(boolean isIncluded)\n+  {\n+    // Do nothing - needed for implementation of MenuElement interface\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param g DOCUMENT ME!\n+   */\n+  protected void paintBorder(Graphics g)\n+  {\n+    if (paintBorder)\n+      getBorder().paintBorder(this, g, 0, 0, getSize(null).width,\n+                              getSize(null).height);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected String paramString()\n+  {\n+    return \"JMenuBar\";\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param e DOCUMENT ME!\n+   * @param path DOCUMENT ME!\n+   * @param manager DOCUMENT ME!\n+   */\n+  public void processKeyEvent(KeyEvent e, MenuElement[] path,\n+                              MenuSelectionManager manager)\n+  {\n+    // Do nothing - needed for implementation of MenuElement interface\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   * @param path DOCUMENT ME!\n+   * @param manager DOCUMENT ME!\n+   */\n+  public void processMouseEvent(MouseEvent event, MenuElement[] path,\n+                                MenuSelectionManager manager)\n+  {\n+    // Do nothing - needed for implementation of MenuElement interface\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  public void removeNotify()\n+  {\n+    // Must unregister this menu bar with the current keyboard manager.\n+    super.removeNotify();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param b DOCUMENT ME!\n+   */\n+  public void setBorderPainted(boolean b)\n+  {\n+    paintBorder = b;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param menu DOCUMENT ME!\n+   */\n+  public void setHelpMenu(JMenu menu)\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param m DOCUMENT ME!\n+   */\n+  public void setMargin(Insets m)\n+  {\n+    this.margin = m;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param sel DOCUMENT ME!\n+   */\n+  public void setSelected(Component sel)\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param model DOCUMENT ME!\n+   */\n+  public void setSelectionModel(SingleSelectionModel model)\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param ui DOCUMENT ME!\n+   */\n+  public void setUI(MenuBarUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  public void updateUI()\n+  {\n+    MenuBarUI ui = ((MenuBarUI) UIManager.getUI(this));\n+    setUI(ui);\n+    invalidate();\n+  }\n }"}, {"sha": "2d525ce6f318f431346cd899a134884dbca6e86c", "filename": "libjava/javax/swing/JMenuItem.java", "status": "modified", "additions": 399, "deletions": 86, "changes": 485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJMenuItem.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -35,20 +35,22 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.awt.Component;\n+import java.awt.event.InputEvent;\n import java.awt.event.KeyEvent;\n import java.awt.event.MouseEvent;\n+import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n-\n+import java.util.EventListener;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n+import javax.swing.UIManager;\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n import javax.swing.event.MenuDragMouseEvent;\n@@ -57,48 +59,79 @@\n import javax.swing.event.MenuKeyListener;\n import javax.swing.plaf.MenuItemUI;\n \n+\n+/**\n+ * DOCUMENT ME!\n+ *\n+ * @author $author$\n+ * @version $Revision: 1.2.18.4 $\n+ */\n public class JMenuItem extends AbstractButton implements Accessible,\n                                                          MenuElement\n {\n-  //-------------------------------------------------------------\n-  // Variables --------------------------------------------------\n-  //-------------------------------------------------------------\n   private static final String uiClassID = \"MenuItemUI\";\n   private KeyStroke accelerator;\n \n-  //-------------------------------------------------------------\n-  // Initialization ---------------------------------------------\n-  //-------------------------------------------------------------\n+  /**\n+   * Creates a new JMenuItem object.\n+   */\n   public JMenuItem()\n   {\n     this(null, null);\n-  } // JMenuItem()\n+  }\n \n+  /**\n+   * Creates a new JMenuItem object.\n+   *\n+   * @param icon DOCUMENT ME!\n+   */\n   public JMenuItem(Icon icon)\n   {\n     this(null, icon);\n-  } // JMenuItem()\n+  }\n \n+  /**\n+   * Creates a new JMenuItem object.\n+   *\n+   * @param text DOCUMENT ME!\n+   */\n   public JMenuItem(String text)\n   {\n     this(text, null);\n-  } // JMenuItem()\n+  }\n \n+  /**\n+   * Creates a new JMenuItem object.\n+   *\n+   * @param action DOCUMENT ME!\n+   */\n   public JMenuItem(Action action)\n   {\n     // TODO\t\t\n-  } // JMenuItem()\n-\n+  }\n+\n+  /**\n+   * Creates a new JMenuItem object.\n+   *\n+   * @param text DOCUMENT ME!\n+   * @param icon DOCUMENT ME!\n+   */\n   public JMenuItem(String text, Icon icon)\n   {\n     super(text, icon);\n-  } // JMenuItem()\n-\n+  }\n+\n+  /**\n+   * Creates a new JMenuItem object.\n+   *\n+   * @param text DOCUMENT ME!\n+   * @param mnemonic DOCUMENT ME!\n+   */\n   public JMenuItem(String text, int mnemonic)\n   {\n     super(text, null);\n     setMnemonic(mnemonic);\n-  } // JMenuItem()\n+  }\n \n   //-------------------------------------------------------------\n   // Methods ----------------------------------------------------\n@@ -107,60 +140,116 @@ private void readObject(ObjectInputStream stream)\n                    throws IOException, ClassNotFoundException\n   {\n     // TODO\n-  } // readObject()\n-\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param stream DOCUMENT ME!\n+   *\n+   * @throws IOException DOCUMENT ME!\n+   */\n   private void writeObject(ObjectOutputStream stream) throws IOException\n   {\n     // TODO\n-  } // writeObject()\n-\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param text DOCUMENT ME!\n+   * @param icon DOCUMENT ME!\n+   */\n   protected void init(String text, Icon icon)\n   {\n     // TODO\n-  } // init()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param ui DOCUMENT ME!\n+   */\n   public void setUI(MenuItemUI ui)\n   {\n     super.setUI(ui);\n-  } // setUI()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   */\n   public void updateUI()\n   {\n     MenuItemUI mi = ((MenuItemUI) UIManager.getUI(this));\n     setUI(mi);\n     invalidate();\n-  } // updateUI()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public String getUIClassID()\n   {\n     return uiClassID;\n-  } // getUIClassID()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public boolean isArmed()\n   {\n     return getModel().isArmed();\n-  } // isArmed()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param armed DOCUMENT ME!\n+   */\n   public void setArmed(boolean armed)\n   {\n     getModel().setArmed(armed);\n-  } // setArmed()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param enabled DOCUMENT ME!\n+   */\n   public void setEnabled(boolean enabled)\n   {\n     setEnabled(enabled);\n-  } // setEnabled()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public KeyStroke getAccelerator()\n   {\n     return accelerator;\n-  } // getAccelerator()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param keystroke DOCUMENT ME!\n+   */\n   public void setAccelerator(KeyStroke keystroke)\n   {\n     this.accelerator = keystroke;\n-  } // setAccelerator()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param action DOCUMENT ME!\n+   */\n   protected void configurePropertiesFromAction(Action action)\n   {\n     super.configurePropertiesFromAction(action);\n@@ -169,147 +258,371 @@ protected void configurePropertiesFromAction(Action action)\n       setAccelerator(null);\n     else\n       setAccelerator((KeyStroke) (action.getValue(Action.ACCELERATOR_KEY)));\n-  \n-  } // configurePropertiesFromAction()\n-\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param action DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   protected PropertyChangeListener createActionPropertyChangeListener(Action action)\n   {\n-    return null;\n-  } // createActionPropertyChangeListener()\n-\n+    return new PropertyChangeListener()\n+      {\n+\tpublic void propertyChange(PropertyChangeEvent e)\n+\t{\n+\t  Action act = (Action) (e.getSource());\n+\t  configurePropertiesFromAction(act);\n+\t}\n+      };\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   * @param path DOCUMENT ME!\n+   * @param manager DOCUMENT ME!\n+   */\n   public void processMouseEvent(MouseEvent event, MenuElement[] path,\n                                 MenuSelectionManager manager)\n   {\n-    // TODO\n-  } // processMouseEvent()\n-\n+    switch (event.getID())\n+      {\n+      case MouseEvent.MOUSE_CLICKED:\n+\tdoClick();\n+\tbreak;\n+      case MouseEvent.MOUSE_ENTERED:\n+\tif (event.getSource() instanceof JMenuItem)\n+\t  {\n+\t    JMenuItem item = (JMenuItem) event.getSource();\n+\t    ButtonModel model = item.getModel();\n+\n+\t    if (item.isRolloverEnabled())\n+\t      model.setRollover(true);\n+\n+\t    if (model.isPressed()\n+\t        && (event.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n+\t      model.setArmed(true);\n+\t    else\n+\t      model.setArmed(false);\n+\t  }\n+\tbreak;\n+      case MouseEvent.MOUSE_EXITED:\n+\tif (event.getSource() instanceof JMenuItem)\n+\t  {\n+\t    JMenuItem item = (JMenuItem) event.getSource();\n+\t    ButtonModel model = item.getModel();\n+\t    if (item.isRolloverEnabled())\n+\t      model.setRollover(false);\n+\t    model.setArmed(false);\n+\t  }\n+\tbreak;\n+      case MouseEvent.MOUSE_PRESSED:\n+\tif (event.getSource() instanceof JMenuItem)\n+\t  {\n+\t    if ((event.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n+\t      {\n+\t\tmodel.setArmed(true);\n+\t\tmodel.setPressed(true);\n+\t      }\n+\t  }\n+\tbreak;\n+      case MouseEvent.MOUSE_RELEASED:\n+\tif (event.getSource() instanceof JMenuItem)\n+\t  {\n+\t    JMenuItem item = (JMenuItem) event.getSource();\n+\t    ButtonModel model = item.getModel();\n+\t    if ((event.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n+\t      {\n+\t\tmodel.setPressed(false);\n+\t\tmodel.setArmed(false);\n+\t\tmanager.clearSelectedPath();\n+\t      }\n+\t  }\n+\tbreak;\n+      case MouseEvent.MOUSE_MOVED:\n+\tbreak;\n+      case MouseEvent.MOUSE_DRAGGED:\n+\tMenuDragMouseEvent e = new MenuDragMouseEvent((Component) event\n+\t                                              .getSource(),\n+\t                                              event.getID(),\n+\t                                              event.getWhen(),\n+\t                                              event.getModifiers(),\n+\t                                              event.getX(),\n+\t                                              event.getY(),\n+\t                                              event.getClickCount(),\n+\t                                              event.isPopupTrigger(),\n+\t                                              path, manager);\n+\tprocessMenuDragMouseEvent(e);\n+\tbreak;\n+      }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   * @param path DOCUMENT ME!\n+   * @param manager DOCUMENT ME!\n+   */\n   public void processKeyEvent(KeyEvent event, MenuElement[] path,\n                               MenuSelectionManager manager)\n   {\n     // TODO\n-  } // processKeyEvent()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   */\n   public void processMenuDragMouseEvent(MenuDragMouseEvent event)\n   {\n-  } // processMenuDragMouseEvent()\n+    switch (event.getID())\n+      {\n+      case MouseEvent.MOUSE_ENTERED:\n+\tfireMenuDragMouseEntered(event);\n+\tbreak;\n+      case MouseEvent.MOUSE_EXITED:\n+\tfireMenuDragMouseExited(event);\n+\tbreak;\n+      case MouseEvent.MOUSE_DRAGGED:\n+\tfireMenuDragMouseDragged(event);\n+\tbreak;\n+      case MouseEvent.MOUSE_RELEASED:\n+\tfireMenuDragMouseReleased(event);\n+\tbreak;\n+      }\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   */\n   public void processMenuKeyEvent(MenuKeyEvent event)\n   {\n     // TODO\n-  } // processMenuKeyEvent()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   */\n   protected void fireMenuDragMouseEntered(MenuDragMouseEvent event)\n   {\n-    // TODO\n-  } // fireMenuDragMouseEntered()\n+    EventListener[] ll = listenerList.getListeners(MenuDragMouseListener.class);\n \n+    for (int i = 0; i < ll.length; i++)\n+      ((MenuDragMouseListener) ll[i]).menuDragMouseEntered(event);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   */\n   protected void fireMenuDragMouseExited(MenuDragMouseEvent event)\n   {\n-    // TODO\n-  } // fireMenuDragMouseExited()\n+    EventListener[] ll = listenerList.getListeners(MenuDragMouseListener.class);\n \n+    for (int i = 0; i < ll.length; i++)\n+      ((MenuDragMouseListener) ll[i]).menuDragMouseExited(event);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   */\n   protected void fireMenuDragMouseDragged(MenuDragMouseEvent event)\n   {\n-    // TODO\n-  } // fireMenuDragMouseDragged()\n+    EventListener[] ll = listenerList.getListeners(MenuDragMouseListener.class);\n \n+    for (int i = 0; i < ll.length; i++)\n+      ((MenuDragMouseListener) ll[i]).menuDragMouseDragged(event);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   */\n   protected void fireMenuDragMouseReleased(MenuDragMouseEvent event)\n   {\n-    // TODO\n-  } // fireMenuDragMouseReleased()\n+    EventListener[] ll = listenerList.getListeners(MenuDragMouseListener.class);\n \n+    for (int i = 0; i < ll.length; i++)\n+      ((MenuDragMouseListener) ll[i]).menuDragMouseReleased(event);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   */\n   protected void fireMenuKeyPressed(MenuKeyEvent event)\n   {\n     // TODO\n-  } // fireMenuKeyPressed()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   */\n   protected void fireMenuKeyReleased(MenuKeyEvent event)\n   {\n     // TODO\n-  } // fireMenuKeyReleased()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   */\n   protected void fireMenuKeyTyped(MenuKeyEvent event)\n   {\n     // TODO\n-  } // fireMenuKeyTyped()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param changed DOCUMENT ME!\n+   */\n   public void menuSelectionChanged(boolean changed)\n   {\n-    // TODO\n-  } // menuSelectionChanged()\n+    if (changed)\n+      model.setArmed(true);\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public MenuElement[] getSubElements()\n   {\n-    return null; // TODO\n-  } // getSubElements()\n+    return new MenuElement[0];\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public Component getComponent()\n   {\n-    return null; // TODO\n-  } // getComponent()\n+    return this;\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param listener DOCUMENT ME!\n+   */\n   public void addMenuDragMouseListener(MenuDragMouseListener listener)\n   {\n-    // TODO\n-  } // addMenuDragMouseListener()\n+    listenerList.add(MenuDragMouseListener.class, listener);\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param listener DOCUMENT ME!\n+   */\n   public void removeMenuDragMouseListener(MenuDragMouseListener listener)\n   {\n-  } // removeMenuDragMouseListener()\n+    listenerList.remove(MenuDragMouseListener.class, listener);\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param listener DOCUMENT ME!\n+   */\n   public void addMenuKeyListener(MenuKeyListener listener)\n   {\n-  } // addMenuKeyListener()\n+    listenerList.add(MenuKeyListener.class, listener);\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param listener DOCUMENT ME!\n+   */\n   public void removeMenuKeyListener(MenuKeyListener listener)\n   {\n-  } // removeMenuKeyListener()\n+    listenerList.remove(MenuKeyListener.class, listener);\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   protected String paramString()\n   {\n     return \"JMenuItem\";\n-  } // paramString()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      {\n-        accessibleContext = new AccessibleJMenuItem(this);\n-      }\n+      accessibleContext = new AccessibleJMenuItem(this);\n \n     return accessibleContext;\n-  } // getAccessibleContext()\n-\n-  //-------------------------------------------------------------\n-  // Classes ----------------------------------------------------\n-  //-------------------------------------------------------------\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.2.18.4 $\n+   */\n   protected class AccessibleJMenuItem extends AccessibleAbstractButton\n     implements ChangeListener\n   {\n-    //-------------------------------------------------------------\n-    // Variables --------------------------------------------------\n-    //-------------------------------------------------------------\n-    //-------------------------------------------------------------\n-    // Initialization ---------------------------------------------\n-    //-------------------------------------------------------------\n+    /**\n+     * Creates a new AccessibleJMenuItem object.\n+     *\n+     * @param component DOCUMENT ME!\n+     */\n     AccessibleJMenuItem(JMenuItem component)\n     {\n       super(component);\n \n       // TODO\n-    } // AccessibleJMenuItem()\n+    }\n \n-    //-------------------------------------------------------------\n-    // Methods ----------------------------------------------------\n-    //-------------------------------------------------------------\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param event DOCUMENT ME!\n+     */\n     public void stateChanged(ChangeEvent event)\n     {\n       // TODO\n-    } // stateChanged()\n+    }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return $returnType$ DOCUMENT ME!\n+     */\n     public AccessibleRole getAccessibleRole()\n     {\n       return AccessibleRole.MENU_ITEM;\n-    } // getAccessibleRole()\n-  } // AccessibleJMenuItem\n-} // JMenuItem\n+    }\n+  }\n+}"}, {"sha": "ae7afbf3020cc2c65325c49b268677bfac01c406", "filename": "libjava/javax/swing/JOptionPane.java", "status": "modified", "additions": 1338, "deletions": 315, "changes": 1653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJOptionPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJOptionPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJOptionPane.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -1,5 +1,5 @@\n-/* JOptionPane.java -- \n-   Copyright (C) 2002, 2004  Free Software Foundation, Inc.\n+/* JOptionPane.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,365 +35,1388 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n-import java.awt.BorderLayout;\n import java.awt.Component;\n import java.awt.Dialog;\n import java.awt.Frame;\n-\n+import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n+import javax.accessibility.AccessibleRole;\n+import javax.swing.Icon;\n import javax.swing.plaf.OptionPaneUI;\n \n-public class JOptionPane extends JComponent \n-{\n-    public static final int DEFAULT_OPTION        = 0;\n-    public static final int YES_NO_OPTION         = 1;\n-    public static final int YES_NO_CANCEL_OPTION  = 2;\n-    public static final int OK_CANCEL_OPTION      = 3;\n-    public static final int YES_OPTION            = 4;\n-    public static final int NO_OPTION             = 5;\n-    public static final int CANCEL_OPTION         = 6;\n-    public static final int OK_OPTION             = 7;\n-    public static final int CLOSED_OPTION         = 8;\n-\n-    public static final int ERROR_MESSAGE         = 0;\n-    public static final int INFORMATION_MESSAGE   = 1;\n-    public static final int WARNING_MESSAGE       = 2;\n-    public static final int QUESTION_MESSAGE      = 3;\n-    public static final int PLAIN_MESSAGE         = 4;\n-\n-    final static String VALUE_PROPERTY = \"value_prop\";\n-    final static String INPUT_VALUE_PROPERTY = \"input_value_prop\";\n-    \n-    final static String UNINITIALIZED_VALUE = \"uninit\";\n-\n-    // Ronald: shouldnt by public ?\n-    public Object msg;\n-    public int mtype;\n-    public int otype;\n-    public Icon icon;\n-    public Object []args;\n-    public Object init;\n-\n-    public JDialog dialog;\n-\n-    /*****************************************************************************\n-     *\n-     *\n-     *  joptionpanels\n-     *\n-     *\n-     ***********************************/\n \n-    JOptionPane()\n-    {\n-\tthis(\"mess\");\n-    }\n-    \n-    JOptionPane(Object m)\n-    {\n-\tthis(m, PLAIN_MESSAGE);\n-    }\n-    \n-    JOptionPane(Object m,\n-\t\t int mtype)\n+/**\n+ * This class creates different types of JDialogs and JInternalFrames that can\n+ * ask users for input or pass on information. JOptionPane can be used by\n+ * calling one of the show static methods or  by creating an instance of\n+ * JOptionPane and calling createDialog or createInternalFrame.\n+ */\n+public class JOptionPane extends JComponent implements Accessible\n+{\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected class AccessibleJOptionPane extends JComponent.AccessibleJComponent\n+  {\n+    /**\n+     * Creates a new AccessibleJOptionPane object.\n+     */\n+    protected AccessibleJOptionPane()\n     {\n-\tthis(m, mtype, DEFAULT_OPTION);\n+      super(JOptionPane.this);\n     }\n \n-    JOptionPane(Object m,\n-\t\tint mtype,\n-\t\tint otype)\n-    {\n-\tthis(m, mtype, otype, null);\n-    }\n- \n-    JOptionPane(Object m,\n-\t\t int mtype,\n-\t\t int otype,\n-\t\t Icon icon)\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleRole getAccessibleRole()\n     {\n-\tthis(m, mtype, otype, icon, null);\n+      return null;\n     }\n+  }\n \n-    JOptionPane(Object m,\n-\t\t int mtype,\n-\t\t int otype,\n-\t\t Icon icon,\n-\t\t Object []args)\n-    {\n-\tthis(m, mtype, otype, icon, args, null);\n-    }\n+  /** The value returned when cancel option is selected. */\n+  public static final int CANCEL_OPTION = 2;\n \n-    JOptionPane(Object msg,\n-\t\tint mtype,\n-\t\tint otype,\n-\t\tIcon icon,\n-\t\tObject []args,\n-\t\tObject init)\n-    {\n-\t//\tthis(m, mtype, otype, icon, args, init);\n-\tthis.msg   = msg;\n-\tthis.mtype = mtype;\n-\tthis.otype = otype;\n-\tthis.icon  = icon;\n-\tthis.args  = args;\n-\tthis.init  = init;\n-\t\n-\tupdateUI();\n-    }\n+  /** The value returned when the dialog is closed without a selection. */\n+  public static final int CLOSED_OPTION = -1;\n \n+  /** An option used in confirmation dialog methods. */\n+  public static final int DEFAULT_OPTION = -1;\n \n-    /*****************************************************************************\n-     *\n-     *\n-     *\n-     *\n-     *\n-     ***********************************/\n+  /** The value returned when the no option is selected. */\n+  public static final int NO_OPTION = 1;\n \n-    Object val;\n-    public void setValue(Object v)  \n-    {   val = v;       }\n-    public Object getValue()\n-    {\treturn val;    }\n+  /** An option used in confirmation dialog methods. */\n+  public static final int OK_CANCEL_OPTION = 2;\n \n-    public String getUIClassID()\n-    {\treturn \"OptionPaneUI\";    }\n+  /** The value returned when the ok option is selected. */\n+  public static final int OK_OPTION = 0;\n \n+  /** An option used in confirmation dialog methods. */\n+  public static final int YES_NO_CANCEL_OPTION = 1;\n \n-    public void setUI(OptionPaneUI ui) {\n-        super.setUI(ui);\n-    }\n-    \n-    public OptionPaneUI getUI() {\n-        return (OptionPaneUI)ui;\n-    }\n-    \n-    public void updateUI() {\n-\tsetUI((OptionPaneUI)UIManager.getUI(this));\n-    }\n+  /** An option used in confirmation dialog methods. */\n+  public static final int YES_NO_OPTION = 0;\n \n+  /** The value returned when the yes option is selected. */\n+  public static final int YES_OPTION = 0;\n \n-    public AccessibleContext getAccessibleContext()\n-    {\n-\treturn null;\n-    }\n-    \n-    protected  String paramString()\n-    {\n-\treturn \"JOptionPane\";\n-    }\n-    \n-    public static void showMessageDialog(Component frame,\n-\t\t\t\t  String msg,\n-\t\t\t\t  String title,\n-\t\t\t\t  int bla)\n-    {\n-\tDoShowOptionDialog(frame,\n-\t\t\t  msg,\n-\t\t\t  title,\n-\t\t\t  bla,\n-\t\t\t  0,\n-\t\t\t  null,\n-\t\t\t  null,\n-\t\t\t  null);\n-    }\n+  /** Identifier for the error message type. */\n+  public static final int ERROR_MESSAGE = 0;\n \n-    public static void showMessageDialog(Component frame,\n-\t\t\t\t String msg,\n-\t\t\t\t String title,\n-\t\t\t\t int bla,\n-\t\t\t\t Icon icon)\n-    {\n-\tDoShowOptionDialog(frame,\n-\t\t\t\t msg,\n-\t\t\t\t title,\n-\t\t\t\t bla,\n-\t\t\t\t 0,\n-\t\t\t\t icon,\n-\t\t\t\t null,\n-\t\t\t\t null);\n-    }\n+  /** Identifier for the information message type. */\n+  public static final int INFORMATION_MESSAGE = 1;\n \n-    public static void showMessageDialog(Component frame,\n-\t\t\t\t  String msg)\n-    {\n-\tshowMessageDialog(frame,\n-\t\t\t  msg,\n-\t\t\t  null);\n-    }\n-    \n-\n-    public static void showMessageDialog(Component frame,\n-\t\t\t\t  String msg,\n-\t\t\t\t  Icon icon)\n-    {\t\n-\t//System.out.println(\"++++++++++++++++++creating message dialog:\"+msg + \", frame=\"+frame);\n-         DoShowOptionDialog(frame, \n-\t\t\t\tmsg, \n-\t\t\t\t\"Message\",\t\t\t\t\n-\t\t\t\tDEFAULT_OPTION, \n-\t\t\t\tPLAIN_MESSAGE,\n-\t\t\t\ticon,\n-\t\t\t\tnull,\n-\t\t\t\tnull);\n-    }\n+  /** Identifier for the plain message type. */\n+  public static final int PLAIN_MESSAGE = -1;\n \n-    public static int showConfirmDialog(JFrame frame,\n-\t\t\t\t String yes,\n-\t\t\t\t String no, \n-\t\t\t\t int bla)\n-    {\n-\treturn 0;\n-    }\n+  /** Identifier for the question message type. */\n+  public static final int QUESTION_MESSAGE = 3;\n \n-    public static String showInputDialog(JFrame frame,\n-\t\t\t     String msg, \n-\t\t\t     String title, \n-\t\t\t     int opt_type, \n-\t\t\t     int msg_type,\n-\t\t\t     Icon icon, \n-\t\t\t     Object[] opts, \n-\t\t\t     Object init)\n-    {\n-\treturn (String) DoShowOptionDialog(frame,\n-\t\t\t\tmsg, \n-\t\t\t\ttitle, \n-\t\t\t\topt_type, \n-\t\t\t\tmsg_type,\n-\t\t\t\ticon, \n-\t\t\t\topts, \n-\t\t\t\tinit);\n-    }\n+  /** Identifier for the warning message type. */\n+  public static final int WARNING_MESSAGE = 2;\n \n-    public static Object showInputDialog(JFrame frame,\n-\t\t\t     String msg, \n-\t\t\t     String title, \n-\t\t\t     int opt_type, \n-\t\t\t     Icon icon, \n-\t\t\t     Object[] opts, \n-\t\t\t     Object init)\n-    {\n-\treturn DoShowOptionDialog(frame,\n-\t\t\t\tmsg, \n-\t\t\t\ttitle, \n-\t\t\t\topt_type, \n-\t\t\t\t0, //msg_type,\n-\t\t\t\ticon, \n-\t\t\t\topts, \n-\t\t\t\tinit);\n-    }\n+  /**\n+   * The identifier for the propertyChangeEvent when the icon property\n+   * changes.\n+   */\n+  public static final String ICON_PROPERTY = \"icon\";\n \n+  /**\n+   * The identifier for the propertyChangeEvent when the initialSelectionValue\n+   * property changes.\n+   */\n+  public static final String INITIAL_SELECTION_VALUE_PROPERTY = \"initialSelectionValue\";\n \n-    // everybody comes here eventually\n-    public static int showOptionDialog(Component frame,\n-\t\t\t\tString msg, \n-\t\t\t\tString title, \n-\t\t\t\tint opt_type, \n-\t\t\t\tint msg_type,\n-\t\t\t\tIcon icon, \n-\t\t\t\tObject[] opts, \n-\t\t\t\tObject init)\n-    {\n-\tInteger a = (Integer) DoShowOptionDialog(frame,\n-\t\t\t\t\t\t msg, \n-\t\t\t\t\t\t title, \n-\t\t\t\t\t\t opt_type, \n-\t\t\t\t\t\t msg_type,\n-\t\t\t\t\t\t icon, \n-\t\t\t\t\t\t opts, \n-\t\t\t\t\t\t init);\n-\tif (a == null)\n-\t    return -1;\n-\treturn a.intValue();\n-    }\n-    \n-    public static Object DoShowOptionDialog(Component frame,\n-\t\t\t\t   String msg, \n-\t\t\t\t   String title, \n-\t\t\t\t   int opt_type, \n-\t\t\t\t   int msg_type,\n-\t\t\t\t   Icon icon, \n-\t\t\t\t   Object[] opts, \n-\t\t\t\t   Object init)\n-    {\n-\t\n-\tJOptionPane p = new JOptionPane(msg,\n-\t\t\t\t\tmsg_type,\n-\t\t\t\t\topt_type,\n-\t\t\t\t\ticon,\n-\t\t\t\t\topts,\n-\t\t\t\t\tinit);\n-\tSystem.out.println(\"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \" + p.msg);\n-\n-\t\n-\tJDialog a;\n-\n-\tif (frame == null)\n-\t    {\n-\t\ta = new JDialog((Frame)frame,\n-\t\t\t\ttitle,\n-\t\t\t\ttrue);\n-\t    }\n-\telse if (frame instanceof Dialog)\n-\t    {\n-\t\ta = new JDialog((Dialog) frame,\n-\t\t\t\ttitle,\n-\t\t\t\ttrue);\n-\t    }\n-\telse if (frame instanceof Frame)\n-\t    {\n-\t\ta = new JDialog((Frame) frame,\n-\t\t\t\ttitle,\n-\t\t\t\ttrue);\n-\t    }\n-\telse\n-\t    {\n-\t\tSystem.out.println(\"HUUUUHHH, not a frame or dialog !\");\n-\t\t\n-\t\ta = new JDialog((Frame)null,\n-\t\t\t\ttitle,\n-\t\t\t\ttrue);\n-\t    }\n-\n-\tp.dialog = a;\n-\t\n-\ta.getContentPane().setLayout(new BorderLayout());\n-\ta.getContentPane().add(p,\n-\t\t\t       BorderLayout.CENTER);\n-\t// package the deal\n-\ta.pack();\n-\t\n-\ta.setVisible(true);\n-\t\n-\tObject s = p.getValue();\n-\n-\tSystem.out.println(\"RESULT FROM DIALOG = \" + s);\n-\n-\tif (s == null)\n-\t    return null;\n-\t\n-\treturn s;\n-    }\n+  /**\n+   * The identifier for the propertyChangeEvent when the initialValue property\n+   * changes.\n+   */\n+  public static final String INITIAL_VALUE_PROPERTY = \"initialValue\";\n \n-}\n+  /**\n+   * The identifier for the propertyChangeEvent when the inputValue property\n+   * changes.\n+   */\n+  public static final String INPUT_VALUE_PROPERTY = \"inputValue\";\n+\n+  /**\n+   * The identifier for the propertyChangeEvent when the message property\n+   * changes.\n+   */\n+  public static final String MESSAGE_PROPERTY = \"message\";\n+\n+  /**\n+   * The identifier for the propertyChangeEvent when the messageType property\n+   * changes.\n+   */\n+  public static final String MESSAGE_TYPE_PROPERTY = \"messageType\";\n+\n+  /**\n+   * The identifier for the propertyChangeEvent when the optionType property\n+   * changes.\n+   */\n+  public static final String OPTION_TYPE_PROPERTY = \"optionType\";\n+\n+  /**\n+   * The identifier for the propertyChangeEvent when the options property\n+   * changes.\n+   */\n+  public static final String OPTIONS_PROPERTY = \"options\";\n+\n+  /**\n+   * The identifier for the propertyChangeEvent when the selectionValues\n+   * property changes.\n+   */\n+  public static final String SELECTION_VALUES_PROPERTY = \"selectionValues\";\n+\n+  /**\n+   * The identifier for the propertyChangeEvent when the value property\n+   * changes.\n+   */\n+  public static final String VALUE_PROPERTY = \"value\";\n+\n+  /**\n+   * The identifier for the propertyChangeEvent when the wantsInput property\n+   * changes.\n+   */\n+  public static final String WANTS_INPUT_PROPERTY = \"wantsInput\";\n+\n+  /** The value returned when the inputValue is uninitialized. */\n+  public static Object UNINITIALIZED_VALUE = \"uninitializedValue\";\n+\n+  /** The icon displayed in the dialog/internal frame. */\n+  protected Icon icon;\n+\n+  /** The initial selected value in the input component. */\n+  protected Object initialSelectionValue;\n+\n+  /** The object that is initially selected for options. */\n+  protected Object initialValue;\n+\n+  /** The value the user inputs. */\n+  protected Object inputValue = UNINITIALIZED_VALUE;\n+\n+  /** The message displayed in the dialog/internal frame. */\n+  protected Object message = \"JOptionPane message\";\n+\n+  /** The type of message displayed. */\n+  protected int messageType = PLAIN_MESSAGE;\n+\n+  /**\n+   * The options (usually buttons) aligned at the bottom for the user to\n+   * select.\n+   */\n+  protected Object[] options;\n+\n+  /** The type of options to display. */\n+  protected int optionType = DEFAULT_OPTION;\n+\n+  /** The input values the user can select. */\n+  protected Object[] selectionValues;\n+\n+  /** The value returned by selecting an option. */\n+  protected Object value = UNINITIALIZED_VALUE;\n+\n+  /** Whether the Dialog/InternalFrame needs input. */\n+  protected boolean wantsInput;\n+\n+  /** The common frame used when no parent is provided. */\n+  private static Frame privFrame = SwingUtilities.getOwnerFrame();\n+\n+  /**\n+   * Creates a new JOptionPane object using a message of \"JOptionPane\n+   * message\", using the PLAIN_MESSAGE type and DEFAULT_OPTION.\n+   */\n+  public JOptionPane()\n+  {\n+    this(this.message, PLAIN_MESSAGE, DEFAULT_OPTION, null, null, null);\n+  }\n \n+  /**\n+   * Creates a new JOptionPane object using the given message using the\n+   * PLAIN_MESSAGE type and DEFAULT_OPTION.\n+   *\n+   * @param message The message to display.\n+   */\n+  public JOptionPane(Object message)\n+  {\n+    this(message, PLAIN_MESSAGE, DEFAULT_OPTION, null, null, null);\n+  }\n \n+  /**\n+   * Creates a new JOptionPane object using the given message and messageType\n+   * and DEFAULT_OPTION.\n+   *\n+   * @param message The message to display.\n+   * @param messageType The type of message.\n+   */\n+  public JOptionPane(Object message, int messageType)\n+  {\n+    this(message, messageType, DEFAULT_OPTION, null, null, null);\n+  }\n \n+  /**\n+   * Creates a new JOptionPane object using the given message, messageType and\n+   * optionType.\n+   *\n+   * @param message The message to display.\n+   * @param messageType The type of message.\n+   * @param optionType The type of options.\n+   */\n+  public JOptionPane(Object message, int messageType, int optionType)\n+  {\n+    this(message, messageType, optionType, null, null, null);\n+  }\n \n+  /**\n+   * Creates a new JOptionPane object using the given message, messageType,\n+   * optionType and icon.\n+   *\n+   * @param message The message to display.\n+   * @param messageType The type of message.\n+   * @param optionType The type of options.\n+   * @param icon The icon to display.\n+   */\n+  public JOptionPane(Object message, int messageType, int optionType, Icon icon)\n+  {\n+    this(message, messageType, optionType, icon, null, null);\n+  }\n \n+  /**\n+   * Creates a new JOptionPane object using the given message, messageType,\n+   * optionType, icon and options.\n+   *\n+   * @param message The message to display.\n+   * @param messageType The type of message.\n+   * @param optionType The type of options.\n+   * @param icon The icon to display.\n+   * @param options The options given.\n+   */\n+  public JOptionPane(Object message, int messageType, int optionType,\n+                     Icon icon, Object[] options)\n+  {\n+    this(message, messageType, optionType, icon, options, null);\n+  }\n \n+  /**\n+   * Creates a new JOptionPane object using the given message, messageType,\n+   * optionType, icon, options and initialValue. The initialValue will be\n+   * focused initially.\n+   *\n+   * @param message The message to display.\n+   * @param messageType The type of message.\n+   * @param optionType The type of options.\n+   * @param icon The icon to display.\n+   * @param options The options given.\n+   * @param initialValue The component to focus on initially.\n+   *\n+   * @throws IllegalArgumentException If the messageType or optionType are not\n+   *         legal values.\n+   */\n+  public JOptionPane(Object message, int messageType, int optionType,\n+                     Icon icon, Object[] options, Object initialValue)\n+  {\n+    this.message = message;\n+    if (! validMessageType(messageType))\n+      throw new IllegalArgumentException(\"Message Type not legal value.\");\n+    this.messageType = messageType;\n+    if (! validOptionType(optionType))\n+      throw new IllegalArgumentException(\"Option Type not legal value.\");\n+    this.optionType = optionType;\n+    this.icon = icon;\n+    this.options = options;\n+    this.initialValue = initialValue;\n \n+    setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));\n \n+    updateUI();\n+    invalidate();\n+    repaint();\n+  }\n \n+  /**\n+   * This method creates a new JDialog that is either centered around the\n+   * parent's frame or centered on the screen (if the parent is null). The\n+   * JDialog will not be resizable and will be modal. Once the JDialog is\n+   * disposed, the inputValue and value properties will  be set by the\n+   * optionPane.\n+   *\n+   * @param parentComponent The parent of the Dialog.\n+   * @param title The title in the bar of the JDialog.\n+   *\n+   * @return A new JDialog based on the JOptionPane configuration.\n+   */\n+  public JDialog createDialog(Component parentComponent, String title)\n+  {\n+    Frame toUse = getFrameForComponent(parentComponent);\n+    if (toUse == null)\n+      toUse = getRootFrame();\n \n+    JDialog dialog = new JDialog(toUse, title);\n+    inputValue = UNINITIALIZED_VALUE;\n+    value = UNINITIALIZED_VALUE;\n \n+    // FIXME: This dialog should be centered on the parent\n+    // or at the center of the screen (if the parent is null)\n+    // Need getGraphicsConfiguration to return non-null in\n+    // order for that to work so we know how large the \n+    // screen is.\n+    dialog.getContentPane().add(this);\n+    dialog.setModal(true);\n+    dialog.setResizable(false);\n \n+    return dialog;\n+  }\n \n+  /**\n+   * This method creates a new JInternalFrame that is in the JDesktopPane\n+   * which contains the parentComponent given. If no suitable JDesktopPane\n+   * can be found from the parentComponent given, a RuntimeException will be\n+   * thrown.\n+   *\n+   * @param parentComponent The parent to find a JDesktopPane from.\n+   * @param title The title of the JInternalFrame.\n+   *\n+   * @return A new JInternalFrame based on the JOptionPane configuration.\n+   *\n+   * @throws RuntimeException If no suitable JDesktopPane is found.\n+   */\n+  public JInternalFrame createInternalFrame(Component parentComponent,\n+                                            String title)\n+                                     throws RuntimeException\n+  {\n+    // FIXME: implement.\n+    return null;\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJOptionPane();\n+    return accessibleContext;\n+  }\n \n+  /**\n+   * This method returns the JDesktopPane for the given parentComponent or\n+   * null if none can be found.\n+   *\n+   * @param parentComponent The component to look in.\n+   *\n+   * @return The JDesktopPane for the given component or null if none can be\n+   *         found.\n+   */\n+  public static JDesktopPane getDesktopPaneForComponent(Component parentComponent)\n+  {\n+    if (parentComponent == null)\n+      return null;\n+    if (parentComponent instanceof JDesktopPane)\n+      return (JDesktopPane) parentComponent;\n+    JDesktopPane parent = null;\n+    while (parentComponent.getParent() != null)\n+      {\n+\tparentComponent = parentComponent.getParent();\n+\tif (parentComponent instanceof JDesktopPane)\n+\t  {\n+\t    parent = (JDesktopPane) parentComponent;\n+\t    break;\n+\t  }\n+      }\n+    return parent;\n+  }\n \n+  /**\n+   * This method returns the Frame for the given parentComponent or null if\n+   * none can be found.\n+   *\n+   * @param parentComponent The component to look in.\n+   *\n+   * @return The Frame for the given component or null if none can be found.\n+   */\n+  public static Frame getFrameForComponent(Component parentComponent)\n+  {\n+    if (parentComponent == null)\n+      return null;\n+    if (parentComponent instanceof Frame)\n+      return (Frame) parentComponent;\n+    Frame parent = null;\n+    while (parentComponent.getParent() != null)\n+      {\n+\tparentComponent = parentComponent.getParent();\n+\tif (parentComponent instanceof Frame)\n+\t  {\n+\t    parent = (Frame) parentComponent;\n+\t    break;\n+\t  }\n+      }\n+    return parent;\n+  }\n \n+  /**\n+   * This method returns the icon displayed.\n+   *\n+   * @return The icon displayed.\n+   */\n+  public Icon getIcon()\n+  {\n+    return icon;\n+  }\n+\n+  /**\n+   * This method returns the value initially selected from the list of values\n+   * the user can input.\n+   *\n+   * @return The initial selection value.\n+   */\n+  public Object getInitialSelectionValue()\n+  {\n+    return initialSelectionValue;\n+  }\n+\n+  /**\n+   * This method returns the value that is focused from the list of options.\n+   *\n+   * @return The initial value from options.\n+   */\n+  public Object getInitialValue()\n+  {\n+    return initialValue;\n+  }\n+\n+  /**\n+   * This method returns the value that the user input.\n+   *\n+   * @return The user's input value.\n+   */\n+  public Object getInputValue()\n+  {\n+    return inputValue;\n+  }\n+\n+  /**\n+   * This method returns the maximum characters per line. By default, this is\n+   * Integer.MAX_VALUE.\n+   *\n+   * @return The maximum characters per line.\n+   */\n+  public int getMaxCharactersPerLineCount()\n+  {\n+    return Integer.MAX_VALUE;\n+  }\n+\n+  /**\n+   * This method returns the message displayed.\n+   *\n+   * @return The message displayed.\n+   */\n+  public Object getMessage()\n+  {\n+    return message;\n+  }\n+\n+  /**\n+   * This method returns the message type.\n+   *\n+   * @return The message type.\n+   */\n+  public int getMessageType()\n+  {\n+    return messageType;\n+  }\n+\n+  /**\n+   * This method returns the options.\n+   *\n+   * @return The options.\n+   */\n+  public Object[] getOptions()\n+  {\n+    return options;\n+  }\n+\n+  /**\n+   * This method returns the option type.\n+   *\n+   * @return The option type.\n+   */\n+  public int getOptionType()\n+  {\n+    return optionType;\n+  }\n+\n+  /**\n+   * This method returns the Frame used by JOptionPane dialog's that have no\n+   * parent.\n+   *\n+   * @return The Frame used by dialogs that have no parent.\n+   */\n+  public static Frame getRootFrame()\n+  {\n+    return privFrame;\n+  }\n+\n+  /**\n+   * This method returns the selection values.\n+   *\n+   * @return The selection values.\n+   */\n+  public Object[] getSelectionValues()\n+  {\n+    return selectionValues;\n+  }\n+\n+  /**\n+   * This method returns the UI used by the JOptionPane.\n+   *\n+   * @return The UI used by the JOptionPane.\n+   */\n+  public OptionPaneUI getUI()\n+  {\n+    return (OptionPaneUI) ui;\n+  }\n+\n+  /**\n+   * This method returns an identifier to determine which UI class will act as\n+   * the UI.\n+   *\n+   * @return The UI identifier.\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"OptionPaneUI\";\n+  }\n+\n+  /**\n+   * This method returns the value that the user selected out of options.\n+   *\n+   * @return The value that the user selected out of options.\n+   */\n+  public Object getValue()\n+  {\n+    return value;\n+  }\n+\n+  /**\n+   * This method returns whether this JOptionPane wants input.\n+   *\n+   * @return Whether this JOptionPane wants input.\n+   */\n+  public boolean getWantsInput()\n+  {\n+    return wantsInput;\n+  }\n+\n+  /**\n+   * This method returns a String that describes this JOptionPane.\n+   *\n+   * @return A String that describes this JOptionPane.\n+   */\n+  protected String paramString()\n+  {\n+    return \"JOptionPane\";\n+  }\n+\n+  /**\n+   * This method requests focus for the initial value.\n+   */\n+  public void selectInitialValue()\n+  {\n+    if (ui != null)\n+      ((OptionPaneUI) ui).selectInitialValue(this);\n+  }\n+\n+  /**\n+   * This method changes the icon property.\n+   *\n+   * @param newIcon The new icon to use.\n+   */\n+  public void setIcon(Icon newIcon)\n+  {\n+    if (icon != newIcon)\n+      {\n+\tIcon old = icon;\n+\ticon = newIcon;\n+\tfirePropertyChange(ICON_PROPERTY, old, icon);\n+      }\n+  }\n+\n+  /**\n+   * This method changes the initial selection property.\n+   *\n+   * @param newValue The new initial selection.\n+   */\n+  public void setInitialSelectionValue(Object newValue)\n+  {\n+    if (initialSelectionValue != newValue)\n+      {\n+\tObject old = initialSelectionValue;\n+\tinitialSelectionValue = newValue;\n+\tfirePropertyChange(INITIAL_SELECTION_VALUE_PROPERTY, old,\n+\t                   initialSelectionValue);\n+      }\n+  }\n+\n+  /**\n+   * This method changes the initial value property.\n+   *\n+   * @param newValue The new initial value.\n+   */\n+  public void setInitialValue(Object newValue)\n+  {\n+    if (initialValue != newValue)\n+      {\n+\tObject old = initialValue;\n+\tinitialValue = newValue;\n+\tfirePropertyChange(INITIAL_VALUE_PROPERTY, old, initialValue);\n+      }\n+  }\n+\n+  /**\n+   * This method changes the inputValue property.\n+   *\n+   * @param newValue The new inputValue.\n+   */\n+  public void setInputValue(Object newValue)\n+  {\n+    if (inputValue != newValue)\n+      {\n+\tObject old = inputValue;\n+\tinputValue = newValue;\n+\tfirePropertyChange(INPUT_VALUE_PROPERTY, old, inputValue);\n+      }\n+  }\n+\n+  /**\n+   * This method changes the message property.\n+   *\n+   * @param newMessage The new message.\n+   */\n+  public void setMessage(Object newMessage)\n+  {\n+    if (message != newMessage)\n+      {\n+\tObject old = message;\n+\tmessage = newMessage;\n+\tfirePropertyChange(MESSAGE_PROPERTY, old, message);\n+      }\n+  }\n+\n+  /**\n+   * This method changes the messageType property.\n+   *\n+   * @param newType The new messageType.\n+   *\n+   * @throws IllegalArgumentException If the messageType is not valid.\n+   */\n+  public void setMessageType(int newType)\n+  {\n+    if (! validMessageType(newType))\n+      throw new IllegalArgumentException(\"Message Type not legal value.\");\n+    if (newType != messageType)\n+      {\n+\tint old = messageType;\n+\tmessageType = newType;\n+\tfirePropertyChange(MESSAGE_TYPE_PROPERTY, old, messageType);\n+      }\n+  }\n+\n+  /**\n+   * This method changes the options property.\n+   *\n+   * @param newOptions The new options.\n+   */\n+  public void setOptions(Object[] newOptions)\n+  {\n+    if (options != newOptions)\n+      {\n+\tObject[] old = options;\n+\toptions = newOptions;\n+\tfirePropertyChange(OPTIONS_PROPERTY, old, options);\n+      }\n+  }\n+\n+  /**\n+   * This method changes the optionType property.\n+   *\n+   * @param newType The new optionType.\n+   *\n+   * @throws IllegalArgumentException If the optionType is not valid.\n+   */\n+  public void setOptionType(int newType)\n+  {\n+    if (! validOptionType(newType))\n+      throw new IllegalArgumentException(\"Option Type not legal value.\");\n+    if (newType != optionType)\n+      {\n+\tint old = optionType;\n+\toptionType = newType;\n+\tfirePropertyChange(OPTION_TYPE_PROPERTY, old, optionType);\n+      }\n+  }\n+\n+  /**\n+   * This method changes the Frame used for JOptionPane dialogs that have no\n+   * parent.\n+   *\n+   * @param newRootFrame The Frame to use for dialogs that have no parent.\n+   */\n+  public static void setRootFrame(Frame newRootFrame)\n+  {\n+    privFrame = newRootFrame;\n+  }\n+\n+  /**\n+   * This method changes the selectionValues property.\n+   *\n+   * @param newValues The new selectionValues.\n+   */\n+  public void setSelectionValues(Object[] newValues)\n+  {\n+    if (newValues != selectionValues)\n+      {\n+\tif (newValues != null)\n+\t  wantsInput = true;\n+\tObject[] old = selectionValues;\n+\tselectionValues = newValues;\n+\tfirePropertyChange(SELECTION_VALUES_PROPERTY, old, selectionValues);\n+      }\n+  }\n+\n+  /**\n+   * This method sets the UI used with the JOptionPane.\n+   *\n+   * @param ui The UI used with the JOptionPane.\n+   */\n+  public void setUI(OptionPaneUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  /**\n+   * This method sets the value has been selected out of options.\n+   *\n+   * @param newValue The value that has been selected out of options.\n+   */\n+  public void setValue(Object newValue)\n+  {\n+    if (value != newValue)\n+      {\n+\tObject old = value;\n+\tvalue = newValue;\n+\tfirePropertyChange(VALUE_PROPERTY, old, value);\n+      }\n+  }\n+\n+  /**\n+   * This method changes the wantsInput property.\n+   *\n+   * @param newValue Whether this JOptionPane requires input.\n+   */\n+  public void setWantsInput(boolean newValue)\n+  {\n+    if (wantsInput != newValue)\n+      {\n+\tboolean old = wantsInput;\n+\twantsInput = newValue;\n+\tfirePropertyChange(WANTS_INPUT_PROPERTY, old, wantsInput);\n+      }\n+  }\n+\n+  /**\n+   * This method shows a confirmation dialog with the title \"Select an Option\"\n+   * and displays the given message. The parent frame will be the same as the\n+   * parent frame of the given parentComponent. This method returns the\n+   * option chosen by the user.\n+   *\n+   * @param parentComponent The parentComponent to find a frame in.\n+   * @param message The message to display.\n+   *\n+   * @return The option that was selected.\n+   */\n+  public static int showConfirmDialog(Component parentComponent, Object message)\n+  {\n+    JOptionPane pane = new JOptionPane(message);\n+    JDialog dialog = pane.createDialog(parentComponent, \"Select an Option\");\n+    dialog.pack();\n+    dialog.show();\n+\n+    return ((Integer) pane.getValue()).intValue();\n+  }\n+\n+  /**\n+   * This method shows a confirmation dialog with the given message,\n+   * optionType and title. The frame that owns the dialog will be the same\n+   * frame that holds the given parentComponent. This method returns the\n+   * option that was chosen.\n+   *\n+   * @param parentComponent The component to find a frame in.\n+   * @param message The message displayed.\n+   * @param title The title of the dialog.\n+   * @param optionType The optionType.\n+   *\n+   * @return The option that was chosen.\n+   */\n+  public static int showConfirmDialog(Component parentComponent,\n+                                      Object message, String title,\n+                                      int optionType)\n+  {\n+    JOptionPane pane = new JOptionPane(message, PLAIN_MESSAGE, optionType);\n+    JDialog dialog = pane.createDialog(parentComponent, title);\n+    dialog.pack();\n+    dialog.show();\n+\n+    return ((Integer) pane.getValue()).intValue();\n+  }\n+\n+  /**\n+   * This method shows a confirmation dialog with the given message, title,\n+   * messageType and optionType. The frame owner will be the same frame as\n+   * the one that holds the given parentComponent. This method returns the\n+   * option selected by the user.\n+   *\n+   * @param parentComponent The component to find a frame in.\n+   * @param message The message displayed.\n+   * @param title The title of the dialog.\n+   * @param optionType The optionType.\n+   * @param messageType The messageType.\n+   *\n+   * @return The selected option.\n+   */\n+  public static int showConfirmDialog(Component parentComponent,\n+                                      Object message, String title,\n+                                      int optionType, int messageType)\n+  {\n+    JOptionPane pane = new JOptionPane(message, messageType, optionType);\n+    JDialog dialog = pane.createDialog(parentComponent, title);\n+    dialog.pack();\n+    dialog.show();\n+\n+    return ((Integer) pane.getValue()).intValue();\n+  }\n+\n+  /**\n+   * This method shows a confirmation dialog with the given message, title,\n+   * optionType, messageType and icon. The frame owner will be the same as\n+   * the one that holds the given parentComponent. This method returns the\n+   * option selected by the user.\n+   *\n+   * @param parentComponent The component to find a frame in.\n+   * @param message The message displayed.\n+   * @param title The title of the dialog.\n+   * @param optionType The optionType.\n+   * @param messageType The messsageType.\n+   * @param icon The icon displayed.\n+   *\n+   * @return The selected option.\n+   */\n+  public static int showConfirmDialog(Component parentComponent,\n+                                      Object message, String title,\n+                                      int optionType, int messageType,\n+                                      Icon icon)\n+  {\n+    JOptionPane pane = new JOptionPane(message, messageType, optionType, icon);\n+    JDialog dialog = pane.createDialog(parentComponent, title);\n+    dialog.pack();\n+    dialog.show();\n+\n+    return ((Integer) pane.getValue()).intValue();\n+  }\n+\n+  /**\n+   * This method will show a QUESTION_MESSAGE input dialog with the given\n+   * message. No selectionValues is set so the Look and Feel will usually\n+   * give the user a TextField to fill out. The frame owner will be the same\n+   * frame that holds the given parentComponent. This method will return the\n+   * value entered by the user.\n+   *\n+   * @param parentComponent The component to find a frame in.\n+   * @param message The message displayed.\n+   *\n+   * @return The value entered by the user.\n+   */\n+  public static String showInputDialog(Component parentComponent,\n+                                       Object message)\n+  {\n+    JOptionPane pane = new JOptionPane(message, QUESTION_MESSAGE);\n+    pane.setWantsInput(true);\n+    JDialog dialog = pane.createDialog(parentComponent, null);\n+    dialog.pack();\n+    dialog.show();\n+\n+    return (String) pane.getInputValue();\n+  }\n+\n+  /**\n+   * This method will show a QUESTION_MESSAGE type input dialog with the given\n+   * message and initialSelectionValue. Since there is no selectionValues\n+   * set, the Look and Feel will usually give a TextField to fill out. The\n+   * frame owner will be the same as the one that holds the given\n+   * parentComponent. This method will return the value entered by the user.\n+   *\n+   * @param parentComponent The component to find a frame in.\n+   * @param message The message to display.\n+   * @param initialSelectionValue The initially selected value.\n+   *\n+   * @return The value the user input.\n+   */\n+  public static String showInputDialog(Component parentComponent,\n+                                       Object message,\n+                                       Object initialSelectionValue)\n+  {\n+    JOptionPane pane = new JOptionPane(message, QUESTION_MESSAGE);\n+    pane.setInitialSelectionValue(initialSelectionValue);\n+    pane.setWantsInput(true);\n+    JDialog dialog = pane.createDialog(parentComponent, null);\n+    dialog.pack();\n+    dialog.show();\n+\n+    return (String) pane.getInputValue();\n+  }\n+\n+  /**\n+   * This method displays a new input dialog with the given message, title and\n+   * messageType. Since no selectionValues value is given, the Look and Feel\n+   * will usually give the user a TextField to input data to. This method\n+   * returns the value the user inputs.\n+   *\n+   * @param parentComponent The component to find a frame in.\n+   * @param message The message to display.\n+   * @param title The title of the dialog.\n+   * @param messageType The messageType.\n+   *\n+   * @return The value the user input.\n+   */\n+  public static String showInputDialog(Component parentComponent,\n+                                       Object message, String title,\n+                                       int messageType)\n+  {\n+    JOptionPane pane = new JOptionPane(message, messageType);\n+    pane.setWantsInput(true);\n+    JDialog dialog = pane.createDialog(parentComponent, title);\n+    dialog.pack();\n+    dialog.show();\n+\n+    return (String) pane.getInputValue();\n+  }\n+\n+  /**\n+   * This method shows an input dialog with the given message, title,\n+   * messageType, icon, selectionValues, and initialSelectionValue. This\n+   * method returns the value that the user selects.\n+   *\n+   * @param parentComponent The component to find a frame in.\n+   * @param message The message displayed.\n+   * @param title The title of the dialog.\n+   * @param messageType The messageType.\n+   * @param icon The icon displayed.\n+   * @param selectionValues The list of values to select from.\n+   * @param initialSelectionValue The initially selected value.\n+   *\n+   * @return The user selected value.\n+   */\n+  public static Object showInputDialog(Component parentComponent,\n+                                       Object message, String title,\n+                                       int messageType, Icon icon,\n+                                       Object[] selectionValues,\n+                                       Object initialSelectionValue)\n+  {\n+    JOptionPane pane = new JOptionPane(message, messageType);\n+    pane.setWantsInput(true);\n+    pane.setIcon(icon);\n+    pane.setSelectionValues(selectionValues);\n+    pane.setInitialSelectionValue(initialSelectionValue);\n+    JDialog dialog = pane.createDialog(parentComponent, title);\n+    dialog.pack();\n+    dialog.show();\n+\n+    return (String) pane.getInputValue();\n+  }\n+\n+  /**\n+   * This method shows a QUESTION_MESSAGE type input dialog. Since no\n+   * selectionValues is set, the Look and Feel will usually give the user a\n+   * TextField to input data to. This method returns the value the user\n+   * inputs.\n+   *\n+   * @param message The message to display.\n+   *\n+   * @return The user selected value.\n+   */\n+  public static String showInputDialog(Object message)\n+  {\n+    JOptionPane pane = new JOptionPane(message, QUESTION_MESSAGE);\n+    pane.setWantsInput(true);\n+    JDialog dialog = pane.createDialog(null, null);\n+    dialog.pack();\n+    dialog.show();\n+\n+    return (String) pane.getInputValue();\n+  }\n+\n+  /**\n+   * This method shows a QUESTION_MESSAGE type input dialog. Since no\n+   * selectionValues is set, the Look and Feel will usually give the user a\n+   * TextField to input data to. The input component will be initialized with\n+   * the initialSelectionValue. This method returns the value the user\n+   * inputs.\n+   *\n+   * @param message The message to display.\n+   * @param initialSelectionValue The initialSelectionValue.\n+   *\n+   * @return The user selected value.\n+   */\n+  public static String showInputDialog(Object message,\n+                                       Object initialSelectionValue)\n+  {\n+    JOptionPane pane = new JOptionPane(message, QUESTION_MESSAGE);\n+    pane.setWantsInput(true);\n+    pane.setInitialSelectionValue(initialSelectionValue);\n+    JDialog dialog = pane.createDialog(null, null);\n+    dialog.pack();\n+    dialog.show();\n+\n+    return (String) pane.getInputValue();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param parentComponent DOCUMENT ME!\n+   * @param message DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public static int showInternalConfirmDialog(Component parentComponent,\n+                                              Object message)\n+  {\n+    // FIXME: implement\n+    return 0;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param parentComponent DOCUMENT ME!\n+   * @param message DOCUMENT ME!\n+   * @param title DOCUMENT ME!\n+   * @param optionType DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public static int showInternalConfirmDialog(Component parentComponent,\n+                                              Object message, String title,\n+                                              int optionType)\n+  {\n+    // FIXME: implement  \n+    return 0;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param parentComponent DOCUMENT ME!\n+   * @param message DOCUMENT ME!\n+   * @param title DOCUMENT ME!\n+   * @param optionType DOCUMENT ME!\n+   * @param messageType DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public static int showInternalConfirmDialog(Component parentComponent,\n+                                              Object message, String title,\n+                                              int optionType, int messageType)\n+  {\n+    // FIXME: implement  \n+    return 0;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param parentComponent DOCUMENT ME!\n+   * @param message DOCUMENT ME!\n+   * @param title DOCUMENT ME!\n+   * @param optionType DOCUMENT ME!\n+   * @param messageType DOCUMENT ME!\n+   * @param icon DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public static int showInternalConfirmDialog(Component parentComponent,\n+                                              Object message, String title,\n+                                              int optionType, int messageType,\n+                                              Icon icon)\n+  {\n+    // FIXME: implement  \n+    return 0;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param parentComponent DOCUMENT ME!\n+   * @param message DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public static String showInternalInputDialog(Component parentComponent,\n+                                               Object message)\n+  {\n+    // FIXME: implement  \n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param parentComponent DOCUMENT ME!\n+   * @param message DOCUMENT ME!\n+   * @param title DOCUMENT ME!\n+   * @param messageType DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public static String showInternalInputDialog(Component parentComponent,\n+                                               Object message, String title,\n+                                               int messageType)\n+  {\n+    // FIXME: implement  \n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param parentComponent DOCUMENT ME!\n+   * @param message DOCUMENT ME!\n+   * @param title DOCUMENT ME!\n+   * @param messageType DOCUMENT ME!\n+   * @param icon DOCUMENT ME!\n+   * @param selectionValues DOCUMENT ME!\n+   * @param initialSelectionValue DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public static Object showInternalInputDialog(Component parentComponent,\n+                                               Object message, String title,\n+                                               int messageType, Icon icon,\n+                                               Object[] selectionValues,\n+                                               Object initialSelectionValue)\n+  {\n+    // FIXME: implement  \n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param parentComponent DOCUMENT ME!\n+   * @param message DOCUMENT ME!\n+   */\n+  public static void showInternalMessageDialog(Component parentComponent,\n+                                               Object message)\n+  {\n+    // FIXME: implement  \n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param parentComponent DOCUMENT ME!\n+   * @param message DOCUMENT ME!\n+   * @param title DOCUMENT ME!\n+   * @param messageType DOCUMENT ME!\n+   */\n+  public static void showInternalMessageDialog(Component parentComponent,\n+                                               Object message, String title,\n+                                               int messageType)\n+  {\n+    // FIXME: implement\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param parentComponent DOCUMENT ME!\n+   * @param message DOCUMENT ME!\n+   * @param title DOCUMENT ME!\n+   * @param messageType DOCUMENT ME!\n+   * @param icon DOCUMENT ME!\n+   */\n+  public static void showInternalMessageDialog(Component parentComponent,\n+                                               Object message, String title,\n+                                               int messageType, Icon icon)\n+  {\n+    // FIXME: implement  \n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param parentComponent DOCUMENT ME!\n+   * @param message DOCUMENT ME!\n+   * @param title DOCUMENT ME!\n+   * @param optionType DOCUMENT ME!\n+   * @param messageType DOCUMENT ME!\n+   * @param icon DOCUMENT ME!\n+   * @param options DOCUMENT ME!\n+   * @param initialValue DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public static int showInternalOptionDialog(Component parentComponent,\n+                                             Object message, String title,\n+                                             int optionType, int messageType,\n+                                             Icon icon, Object[] options,\n+                                             Object initialValue)\n+  {\n+    // FIXME: implement  \n+    return 0;\n+  }\n+\n+  /**\n+   * This method shows an INFORMATION_MESSAGE type message dialog.\n+   *\n+   * @param parentComponent The component to find a frame in.\n+   * @param message The message displayed.\n+   */\n+  public static void showMessageDialog(Component parentComponent,\n+                                       Object message)\n+  {\n+    JOptionPane pane = new JOptionPane(message, INFORMATION_MESSAGE);\n+    JDialog dialog = pane.createDialog(parentComponent, null);\n+    dialog.pack();\n+    dialog.show();\n+  }\n+\n+  /**\n+   * This method shows a message dialog with the given message, title and\n+   * messageType.\n+   *\n+   * @param parentComponent The component to find a frame in.\n+   * @param message The message displayed.\n+   * @param title The title of the dialog.\n+   * @param messageType The messageType.\n+   */\n+  public static void showMessageDialog(Component parentComponent,\n+                                       Object message, String title,\n+                                       int messageType)\n+  {\n+    JOptionPane pane = new JOptionPane(message, messageType);\n+    JDialog dialog = pane.createDialog(parentComponent, title);\n+    dialog.pack();\n+    dialog.show();\n+  }\n+\n+  /**\n+   * This method shows a message dialog with the given message, title,\n+   * messageType and icon.\n+   *\n+   * @param parentComponent The component to find a frame in.\n+   * @param message The message displayed.\n+   * @param title The title of the dialog.\n+   * @param messageType The messageType.\n+   * @param icon The icon displayed.\n+   */\n+  public static void showMessageDialog(Component parentComponent,\n+                                       Object message, String title,\n+                                       int messageType, Icon icon)\n+  {\n+    JOptionPane pane = new JOptionPane(message, messageType);\n+    pane.setIcon(icon);\n+    JDialog dialog = pane.createDialog(parentComponent, title);\n+    dialog.pack();\n+    dialog.show();\n+  }\n+\n+  /**\n+   * This method shows an option dialog with the given message, title,\n+   * optionType, messageType, icon, options and initialValue. This method\n+   * returns the option that was selected.\n+   *\n+   * @param parentComponent The component to find a frame in.\n+   * @param message The message displayed.\n+   * @param title The title of the dialog.\n+   * @param optionType The optionType.\n+   * @param messageType The messageType.\n+   * @param icon The icon displayed.\n+   * @param options The options to choose from.\n+   * @param initialValue The initial value.\n+   *\n+   * @return The selected option.\n+   */\n+  public static int showOptionDialog(Component parentComponent,\n+                                     Object message, String title,\n+                                     int optionType, int messageType,\n+                                     Icon icon, Object[] options,\n+                                     Object initialValue)\n+  {\n+    JOptionPane pane = new JOptionPane(message, messageType, optionType, icon,\n+                                       options, initialValue);\n+    JDialog dialog = pane.createDialog(parentComponent, title);\n+    dialog.pack();\n+    dialog.show();\n+\n+    return ((Integer) pane.getValue()).intValue();\n+  }\n+\n+  /**\n+   * This method resets the UI to the Look and Feel default.\n+   */\n+  public void updateUI()\n+  {\n+    setUI((OptionPaneUI) UIManager.getUI(this));\n+    invalidate();\n+  }\n+\n+  /**\n+   * This method returns true if the key is a valid messageType.\n+   *\n+   * @param key The key to check.\n+   *\n+   * @return True if key is valid.\n+   */\n+  private boolean validMessageType(int key)\n+  {\n+    switch (key)\n+      {\n+      case ERROR_MESSAGE:\n+      case INFORMATION_MESSAGE:\n+      case PLAIN_MESSAGE:\n+      case QUESTION_MESSAGE:\n+      case WARNING_MESSAGE:\n+\treturn true;\n+      }\n+    return false;\n+  }\n+\n+  /**\n+   * This method returns true if the key is a valid optionType.\n+   *\n+   * @param key The key to check.\n+   *\n+   * @return True if key is valid.\n+   */\n+  private boolean validOptionType(int key)\n+  {\n+    switch (key)\n+      {\n+      case DEFAULT_OPTION:\n+      case OK_CANCEL_OPTION:\n+      case YES_NO_CANCEL_OPTION:\n+      case YES_NO_OPTION:\n+\treturn true;\n+      }\n+    return false;\n+  }\n+}"}, {"sha": "7aa54fb8d1fa61a753f09a263aa4dc749b6c0640", "filename": "libjava/javax/swing/JPopupMenu.java", "status": "modified", "additions": 953, "deletions": 617, "changes": 1570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJPopupMenu.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJPopupMenu.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJPopupMenu.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -1,4 +1,4 @@\n-/* JPopupMenu.java --\n+/* JPopupMenu.java\n    Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,639 +37,975 @@\n \n package javax.swing;\n \n+import java.awt.BorderLayout;\n import java.awt.Component;\n+import java.awt.Container;\n import java.awt.Dimension;\n+import java.awt.Frame;\n import java.awt.Graphics;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Window;\n import java.awt.event.KeyEvent;\n import java.awt.event.MouseEvent;\n import java.beans.PropertyChangeListener;\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n+import java.util.EventListener;\n+import java.util.Vector;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n+import javax.swing.event.PopupMenuEvent;\n import javax.swing.event.PopupMenuListener;\n import javax.swing.plaf.PopupMenuUI;\n \n+\n /**\n- * JPopupMenu\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * DOCUMENT ME!\n+ *\n+ * @author $author$\n+ * @version $Revision: 1.3.8.3 $\n  */\n public class JPopupMenu extends JComponent implements Accessible, MenuElement\n {\n-\n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Separator\n-\t */\n-\tpublic static class Separator extends JSeparator {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor Separator\n-\t\t */\n-\t\tpublic Separator() {\n-\t\t\t// TODO\n-\t\t} // Separator()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getUIClassID\n-\t\t * @returns String\n-\t\t */\n-\t\tpublic String getUIClassID() {\n-\t\t\treturn null; // TODO\n-\t\t} // getUIClassID()\n-\n-\n-\t} // Separator\n-\n-\t/**\n-\t * AccessibleJPopupMenu\n-\t */\n-\tprotected class AccessibleJPopupMenu extends AccessibleJComponent {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJPopupMenu\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJPopupMenu(JPopupMenu component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJPopupMenu()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn AccessibleRole.POPUP_MENU;\n-\t\t} // getAccessibleRole()\n-\n-\n-\t} // AccessibleJPopupMenu\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * uiClassID\n-\t */\n-\tprivate static final String uiClassID = \"PopupMenuUI\";\n-\n-\t/**\n-\t * invoker\n-\t */\n-\ttransient Component invoker;\n-\n-\t/**\n-\t * desiredLocationX\n-\t */\n-\tprivate int desiredLocationX;\n-\n-\t/**\n-\t * desiredLocationY\n-\t */\n-\tprivate int desiredLocationY;\n-\n-\t/**\n-\t * label\n-\t */\n-\tprivate String label;\n-\n-\t/**\n-\t * paintBorder\n-\t */\n-\tprivate boolean paintBorder;\n-\n-\t/**\n-\t * margin\n-\t */\n-\tprivate Insets margin;\n-\n-\t/**\n-\t * defaultLWPopupEnabledKey\n-\t */\n-\tprivate static final Object defaultLWPopupEnabledKey = null; // TODO\n-\n-\t/**\n-\t * lightWeightPopupEnabled\n-\t */\n-\tprivate boolean lightWeightPopupEnabled;\n-\n-\t/**\n-\t * selectionModel\n-\t */\n-\tprivate SingleSelectionModel selectionModel;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor JPopupMenu\n-\t */\n-\tpublic JPopupMenu() {\n-\t\t// TODO\n-\t} // JPopupMenu()\n-\n-\t/**\n-\t * Constructor JPopupMenu\n-\t * @param label TODO\n-\t */\n-\tpublic JPopupMenu(String label) {\n-\t\t// TODO\n-\t} // JPopupMenu()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * readObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n-\t * @exception ClassNotFoundException TODO\n-\t */\n-\tprivate void readObject(ObjectInputStream stream) \n-\t\t\tthrows IOException, ClassNotFoundException {\n-\t\t// TODO\n-\t} // readObject()\n-\n-\t/**\n-\t * writeObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n-\t */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n-\t\t// TODO\n-\t} // writeObject()\n-\n-\t/**\n-\t * add\n-\t * @param item TODO\n-\t * @returns JMenuItem\n-\t */\n-\tpublic JMenuItem add(JMenuItem item) {\n-\t\treturn null; // TODO\n-\t} // add()\n-\n-\t/**\n-\t * add\n-\t * @param text TODO\n-\t * @returns JMenuItem\n-\t */\n-\tpublic JMenuItem add(String text) {\n-\t\treturn null; // TODO\n-\t} // add()\n-\n-\t/**\n-\t * add\n-\t * @param action TODO\n-\t * @returns JMenuItem\n-\t */\n-\tpublic JMenuItem add(Action action) {\n-\t\treturn null; // TODO\n-\t} // add()\n-\n-\t/**\n-\t * remove\n-\t * @param index TODO\n-\t */\n-\tpublic void remove(int index) {\n-\t\t// TODO\n-\t} // remove()\n-\n-\t/**\n-\t * insert\n-\t * @param action TODO\n-\t * @param index TODO\n-\t */\n-\tpublic void insert(Action action, int index) {\n-\t\t// TODO\n-\t} // insert()\n-\n-\t/**\n-\t * insert\n-\t * @param component TODO\n-\t * @param index TODO\n-\t */\n-\tpublic void insert(Component component, int index) {\n-\t\t// TODO\n-\t} // insert()\n-\n-\t/**\n-\t * paintBorder\n-\t * @param graphics TODO\n-\t */\n-\tprotected void paintBorder(Graphics graphics) {\n-\t\t// TODO\n-\t} // paintBorder()\n-\n-\t/**\n-\t * getDefaultLightWeightPopupEnabled\n-\t * @returns boolean\n-\t */\n-\tpublic static boolean getDefaultLightWeightPopupEnabled() {\n-\t\treturn false; // TODO\n-\t} // getDefaultLightWeightPopupEnabled()\n-\n-\t/**\n-\t * setDefaultLightWeightPopupEnabled\n-\t * @param enabled TODO\n-\t */\n-\tpublic static void setDefaultLightWeightPopupEnabled(boolean enabled) {\n-\t\t// TODO\n-\t} // setDefaultLightWeightPopupEnabled()\n-\n-\t/**\n-\t * getUI\n-\t * @returns PopupMenuUI\n-\t */\n-\tpublic PopupMenuUI getUI() {\n-\t\treturn (PopupMenuUI) ui;\n-\t} // getUI()\n-\n-\t/**\n-\t * setUI\n-\t * @param ui TODO\n-\t */\n-\tpublic void setUI(PopupMenuUI ui) {\n-\t\tsuper.setUI(ui);\n-\t\t// TODO\n-\t} // setUI()\n-\n-\t/**\n-\t * updateUI\n-\t */\n-\tpublic void updateUI() {\n-\t\tsetUI((PopupMenuUI) UIManager.get(this));\n-\t\tinvalidate();\n-\t} // updateUI()\n-\n-\t/**\n-\t * getUIClassID\n-\t * @returns String\n-\t */\n-\tpublic String getUIClassID() {\n-\t\treturn uiClassID;\n-\t} // getUIClassID()\n-\n-\t/**\n-\t * getSelectionModel\n-\t * @returns SingleSelectionModel\n-\t */\n-\tpublic SingleSelectionModel getSelectionModel() {\n-\t\treturn null; // TODO\n-\t} // getSelectionModel()\n-\n-\t/**\n-\t * setSelectionModel\n-\t * @param model TODO\n-\t */\n-\tpublic void setSelectionModel(SingleSelectionModel model) {\n-\t\t// TODO\n-\t} // setSelectionModel()\n-\n-\t/**\n-\t * createActionComponent\n-\t * @param action TODO\n-\t * @returns JMenuItem\n-\t */\n-\tprotected JMenuItem createActionComponent(Action action) {\n-\t\treturn null; // TODO\n-\t} // createActionComponent()\n-\n-\t/**\n-\t * createActionChangeListener\n-\t * @param item TODO\n-\t * @returns PropertyChangeListener\n-\t */\n-\tprotected PropertyChangeListener createActionChangeListener(JMenuItem item) {\n-\t\treturn null; // TODO\n-\t} // createActionChangeListener()\n-\n-\t/**\n-\t * isLightWeightPopupEnabled\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isLightWeightPopupEnabled() {\n-\t\treturn false; // TODO\n-\t} // isLightWeightPopupEnabled()\n-\n-\t/**\n-\t * setLightWeightPopupEnabled\n-\t * @param enabled TODO\n-\t */\n-\tpublic void setLightWeightPopupEnabled(boolean enabled) {\n-\t\t// TODO\n-\t} // setLightWeightPopupEnabled()\n-\n-\t/**\n-\t * getLabel\n-\t * @returns String\n-\t */\n-\tpublic String getLabel() {\n-\t\treturn null; // TODO\n-\t} // getLabel()\n-\n-\t/**\n-\t * setLabel\n-\t * @param label TODO\n-\t */\n-\tpublic void setLabel(String label) {\n-\t\t// TODO\n-\t} // setLabel()\n-\n-\t/**\n-\t * addSeparator\n-\t */\n-\tpublic void addSeparator() {\n-\t\t// TODO\n-\t} // addSeparator()\n-\n-\t/**\n-\t * addPopupMenuListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void addPopupMenuListener(PopupMenuListener listener) {\n-\t\t// TODO\n-\t} // addPopupMenuListener()\n-\n-\t/**\n-\t * removePopupMenuListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void removePopupMenuListener(PopupMenuListener listener) {\n-\t\t// TODO\n-\t} // removePopupMenuListener()\n-\n-\t/**\n-\t * firePopupMenuWillBecomeVisible\n-\t */\n-\tprotected void firePopupMenuWillBecomeVisible() {\n-\t\t// TODO\n-\t} // firePopupMenuWillBecomeVisible()\n-\n-\t/**\n-\t * firePopupMenuWillBecomeInvisible\n-\t */\n-\tprotected void firePopupMenuWillBecomeInvisible() {\n-\t\t// TODO\n-\t} // firePopupMenuWillBecomeInvisible()\n-\n-\t/**\n-\t * firePopupMenuCanceled\n-\t */\n-\tprotected void firePopupMenuCanceled() {\n-\t\t// TODO\n-\t} // firePopupMenuCanceled()\n-\n-\t/**\n-\t * pack\n-\t */\n-\tpublic void pack() {\n-\t\t// TODO\n-\t} // pack()\n-\n-\t/**\n-\t * isVisible\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isVisible() {\n-\t\treturn false; // TODO\n-\t} // isVisible()\n-\n-\t/**\n-\t * setVisible\n-\t * @param visible TODO\n-\t */\n-\tpublic void setVisible(boolean visible) {\n-\t\t// TODO\n-\t} // setVisible()\n-\n-\t/**\n-\t * setLocation\n-\t * @param x TODO\n-\t * @param y TODO\n-\t */\n-\tpublic void setLocation(int x, int y) {\n-\t\t// TODO\n-\t} // setLocation()\n-\n-\t/**\n-\t * isPopupMenu\n-\t * @returns boolean\n-\t */\n-\tprivate boolean isPopupMenu() {\n-\t\treturn false; // TODO\n-\t} // isPopupMenu()\n-\n-\t/**\n-\t * getInvoker\n-\t * @returns Component\n-\t */\n-\tpublic Component getInvoker() {\n-\t\treturn null; // TODO\n-\t} // getInvoker()\n-\n-\t/**\n-\t * setInvoker\n-\t * @param component TODO\n-\t */\n-\tpublic void setInvoker(Component component) {\n-\t\t// TODO\n-\t} // setInvoker()\n-\n-\t/**\n-\t * show\n-\t * @param component TODO\n-\t * @param x TODO\n-\t * @param y TODO\n-\t */\n-\tpublic void show(Component component, int x, int y) {\n-\t\t// TODO\n-\t} // show()\n-\n-\t/**\n-\t * getRootPopupMenu\n-\t * @returns JPopupMenu\n-\t */\n-\tJPopupMenu getRootPopupMenu() {\n-\t\treturn null; // TODO\n-\t} // getRootPopupMenu()\n-\n-\t/**\n-\t * getComponentAtIndex\n-\t * @param index TODO\n-\t * @returns Component\n-\t */\n-\tpublic Component getComponentAtIndex(int index) {\n-\t\treturn null; // TODO\n-\t} // getComponentAtIndex()\n-\n-\t/**\n-\t * getComponentIndex\n-\t * @param component TODO\n-\t * @returns int\n-\t */\n-\tpublic int getComponentIndex(Component component) {\n-\t\treturn 0; // TODO\n-\t} // getComponentIndex()\n-\n-\t/**\n-\t * setPopupSize\n-\t * @param size TODO\n-\t */\n-\tpublic void setPopupSize(Dimension size) {\n-\t\t// TODO\n-\t} // setPopupSize()\n-\n-\t/**\n-\t * setPopupSize\n-\t * @param x TODO\n-\t * @param y TODO\n-\t */\n-\tpublic void setPopupSize(int x, int y) {\n-\t\t// TODO\n-\t} // setPopupSize()\n-\n-\t/**\n-\t * setSelected\n-\t * @param selected TODO\n-\t */\n-\tpublic void setSelected(Component selected) {\n-\t\t// TODO\n-\t} // setSelected()\n-\n-\t/**\n-\t * isBorderPainted\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isBorderPainted() {\n-\t\treturn false; // TODO\n-\t} // isBorderPainted()\n-\n-\t/**\n-\t * setBorderPainted\n-\t * @param painted TODO\n-\t */\n-\tpublic void setBorderPainted(boolean painted) {\n-\t\t// TODO\n-\t} // setBorderPainted()\n-\n-\t/**\n-\t * getMargin\n-\t * @returns Insets\n-\t */\n-\tpublic Insets getMargin() {\n-\t\treturn null; // TODO\n-\t} // getMargin()\n-\n-\t/**\n-\t * paramString\n-\t * @returns String\n-\t */\n-\tprotected String paramString() {\n-\t\treturn null; // TODO\n-\t} // paramString()\n-\n-\t/**\n-\t * processMouseEvent\n-\t * @param event TODO\n-\t * @param path TODO\n-\t * @param manager TODO\n-\t */\n-\tpublic void processMouseEvent(MouseEvent event, MenuElement[] path,\n-\t\t\tMenuSelectionManager manager) {\n-\t\t// TODO\n-\t} // processMouseEvent()\n-\n-\t/**\n-\t * processKeyEvent\n-\t * @param event TODO\n-\t * @param path TODO\n-\t * @param manager TODO\n-\t */\n-\tpublic void processKeyEvent(KeyEvent event, MenuElement[] path,\n-\t\t\tMenuSelectionManager manager) {\n-\t\t// TODO\n-\t} // processKeyEvent()\n-\n-\t/**\n-\t * menuSelectionChanged\n-\t * @param changed TODO\n-\t */\n-\tpublic void menuSelectionChanged(boolean changed) {\n-\t\t// TODO\n-\t} // menuSelectionChanged()\n-\n-\t/**\n-\t * getSubElements\n-\t * @returns MenuElement[]\n-\t */\n-\tpublic MenuElement[] getSubElements() {\n-\t\treturn null; // TODO\n-\t} // getSubElements()\n-\n-\t/**\n-\t * getComponent\n-\t * @returns Component\n-\t */\n-\tpublic Component getComponent() {\n-\t\treturn null; // TODO\n-\t} // getComponent()\n-\n-\t/**\n-\t * isPopupTrigger\n-\t * @param event TODO\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isPopupTrigger(MouseEvent event) {\n-\t\treturn false; // TODO\n-\t} // isPopupTrigger()\n-\n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJPopupMenu(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n-} // JPopupMenu\n+  private static final String uiClassID = \"PopupMenuUI\";\n+  private static final Object defaultLWPopupEnabledKey = null;\n+  private static boolean defaultLWPopupEnabled = true;\n+  transient Component invoker;\n+  private int locationX;\n+  private int locationY;\n+  private String label;\n+  private boolean paintBorder;\n+  private Insets margin;\n+  private boolean lightWeightPopupEnabled;\n+  private SingleSelectionModel selectionModel;\n+  private transient Popup popup;\n+  private Point location;\n+\n+  /**\n+   * Creates a new JPopupMenu object.\n+   */\n+  public JPopupMenu()\n+  {\n+    updateUI();\n+    \n+    lightWeightPopupEnabled = defaultLWPopupEnabled;\n+    selectionModel = new DefaultSingleSelectionModel();\n+  }\n+\n+  /**\n+   * Creates a new JPopupMenu object.\n+   *\n+   * @param label DOCUMENT ME!\n+   */\n+  public JPopupMenu(String label)\n+  {\n+    this.label = label;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param stream DOCUMENT ME!\n+   *\n+   * @throws IOException DOCUMENT ME!\n+   * @throws ClassNotFoundException DOCUMENT ME!\n+   */\n+  private void readObject(ObjectInputStream stream)\n+                   throws IOException, ClassNotFoundException\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param stream DOCUMENT ME!\n+   *\n+   * @throws IOException DOCUMENT ME!\n+   */\n+  private void writeObject(ObjectOutputStream stream) throws IOException\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param item DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public JMenuItem add(JMenuItem item)\n+  {\n+    this.insert(item, -1);\n+    return item;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param text DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public JMenuItem add(String text)\n+  {\n+    JMenuItem item = new JMenuItem(text);\n+    return add(item);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param action DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public JMenuItem add(Action action)\n+  {\n+    JMenuItem item = new JMenuItem(action);\n+    return add(item);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param index DOCUMENT ME!\n+   */\n+  public void remove(int index)\n+  {\n+    super.remove(index);\n+\n+    GridBagConstraints constraints = new GridBagConstraints();\n+    constraints.fill = GridBagConstraints.HORIZONTAL;\n+    constraints.weightx = 100.0;\n+    constraints.weighty = 100.0;\n+\n+    Component[] items = getComponents();\n+    for (int i = index; i < items.length; i++)\n+      {\n+\tconstraints.gridy = i;\n+\tsuper.add(items[i], constraints, i);\n+      }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param action DOCUMENT ME!\n+   * @param index DOCUMENT ME!\n+   */\n+  public void insert(Action action, int index)\n+  {\n+    JMenuItem item = new JMenuItem(action);\n+    this.insert(item, index);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param component DOCUMENT ME!\n+   * @param index DOCUMENT ME!\n+   */\n+  public void insert(Component component, int index)\n+  {\n+    GridBagConstraints constraints = new GridBagConstraints();\n+    constraints.fill = GridBagConstraints.HORIZONTAL;\n+    constraints.weightx = 100.0;\n+    constraints.weighty = 100.0;\n+    \n+    if (index == -1)\n+       index = getComponents().length;\n+       \n+    constraints.gridy = index;\n+    super.add(component, constraints, index);\n+\n+    // need to change constraints for the components that were moved by 1\n+    // due to the insertion\n+    if (index != -1)\n+      {\n+\tComponent[] items = getComponents();\n+\n+\tfor (int i = index + 1; i < items.length; i++)\n+\t  {\n+\t    constraints.gridy = i;\n+\t    super.add(items[i], constraints, i);\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param graphics DOCUMENT ME!\n+   */\n+  protected void paintBorder(Graphics graphics)\n+  {\n+    if (paintBorder)\n+      getBorder().paintBorder(this, graphics, 0, 0, getSize(null).width,\n+                              getSize(null).height);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public static boolean getDefaultLightWeightPopupEnabled()\n+  {\n+    return defaultLWPopupEnabled;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param enabled DOCUMENT ME!\n+   */\n+  public static void setDefaultLightWeightPopupEnabled(boolean enabled)\n+  {\n+    defaultLWPopupEnabled = enabled;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public PopupMenuUI getUI()\n+  {\n+    return (PopupMenuUI) ui;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param ui DOCUMENT ME!\n+   */\n+  public void setUI(PopupMenuUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  public void updateUI()\n+  {\n+    setUI((PopupMenuUI) UIManager.getUI(this));\n+    invalidate();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"PopupMenuUI\";\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public SingleSelectionModel getSelectionModel()\n+  {\n+    return selectionModel;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param model DOCUMENT ME!\n+   */\n+  public void setSelectionModel(SingleSelectionModel model)\n+  {\n+    if (selectionModel != model)\n+      {\n+\tSingleSelectionModel oldModel = this.selectionModel;\n+      }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param action DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected JMenuItem createActionComponent(Action action)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param item DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected PropertyChangeListener createActionChangeListener(JMenuItem item)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isLightWeightPopupEnabled()\n+  {\n+    return lightWeightPopupEnabled;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param enabled DOCUMENT ME!\n+   */\n+  public void setLightWeightPopupEnabled(boolean enabled)\n+  {\n+    lightWeightPopupEnabled = enabled;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public String getLabel()\n+  {\n+    return label;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param label DOCUMENT ME!\n+   */\n+  public void setLabel(String label)\n+  {\n+    this.label = label;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  public void addSeparator()\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param listener DOCUMENT ME!\n+   */\n+  public void addPopupMenuListener(PopupMenuListener listener)\n+  {\n+    listenerList.add(PopupMenuListener.class, listener);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param listener DOCUMENT ME!\n+   */\n+  public void removePopupMenuListener(PopupMenuListener listener)\n+  {\n+    listenerList.remove(PopupMenuListener.class, listener);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void firePopupMenuWillBecomeVisible()\n+  {\n+    EventListener[] ll = listenerList.getListeners(PopupMenuListener.class);\n+\n+    for (int i = 0; i < ll.length; i++)\n+      ((PopupMenuListener) ll[i]).popupMenuWillBecomeVisible(new PopupMenuEvent(this));\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void firePopupMenuWillBecomeInvisible()\n+  {\n+    EventListener[] ll = listenerList.getListeners(PopupMenuListener.class);\n+\n+    for (int i = 0; i < ll.length; i++)\n+      ((PopupMenuListener) ll[i]).popupMenuWillBecomeInvisible(new PopupMenuEvent(this));\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void firePopupMenuCanceled()\n+  {\n+    EventListener[] ll = listenerList.getListeners(PopupMenuListener.class);\n+\n+    for (int i = 0; i < ll.length; i++)\n+      ((PopupMenuListener) ll[i]).popupMenuCanceled(new PopupMenuEvent(this));\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  public void pack()\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isVisible()\n+  {\n+    return super.visible;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param visible DOCUMENT ME!\n+   */\n+  public void setVisible(boolean visible)\n+  {\n+    super.visible = visible;\n+\n+    firePopupMenuWillBecomeVisible();\n+\n+    if (visible)\n+      {\n+\tContainer rootContainer = (Container) SwingUtilities.getRoot(invoker);\n+\n+\tboolean fit = true;\n+\tDimension size;\n+\n+\t// Determine the size of the popup menu\n+\tif (this.getSize().width == 0 && this.getSize().width == 0)\n+\t  size = this.getPreferredSize();\n+\telse\n+\t  size = this.getSize();\n+\n+\tif ((size.width > (rootContainer.getWidth() - locationX))\n+\t    || (size.height > (rootContainer.getHeight() - locationY)))\n+\t  fit = false;\n+\n+\tif (lightWeightPopupEnabled && fit)\n+\t  popup = new LightWeightPopup(this);\n+\telse\n+\t  {\n+\t    if (fit)\n+\t      popup = new MediumWeightPopup(this);\n+\t    else\n+\t      popup = new HeavyWeightPopup(this);\n+\t  }\n+\t\n+        if (popup instanceof LightWeightPopup \n+            || popup instanceof MediumWeightPopup)\n+          {\n+            JLayeredPane layeredPane;\n+            layeredPane = SwingUtilities.getRootPane(invoker).getLayeredPane();\n+            Point lp = layeredPane.getLocationOnScreen();\n+            Point r = SwingUtilities.getRoot(invoker).getLocationOnScreen();\n+            int px = locationX - (lp.x - r.x);\n+            int py = locationY - (lp.y - r.y);\t  \n+            popup.show(px, py, size.width, size.height);\t  \t\t\n+          } \n+        else\n+          popup.show(locationX, locationY, size.width, size.height);\n+      }\n+    else\n+      {\n+\tfirePopupMenuWillBecomeInvisible();\n+\tpopup.hide();\n+      }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param x DOCUMENT ME!\n+   * @param y DOCUMENT ME!\n+   */\n+  public void setLocation(int x, int y)\n+  {\n+    locationX = x;\n+    locationY = y;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  private boolean isPopupMenu()\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Component getInvoker()\n+  {\n+    return invoker;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param component DOCUMENT ME!\n+   */\n+  public void setInvoker(Component component)\n+  {\n+    invoker = component;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param component DOCUMENT ME!\n+   * @param x DOCUMENT ME!\n+   * @param y DOCUMENT ME!\n+   */\n+  public void show(Component component, int x, int y)\n+  {\n+    setInvoker(component);\n+\n+    Point rootOnScreen;\n+    rootOnScreen = SwingUtilities.getRoot(invoker).getLocationOnScreen();\n+    Point invokerOnScreen = invoker.getLocationOnScreen();\n+    \n+    int popupX = (invokerOnScreen.x - rootOnScreen.x) + x;\n+    int popupY = (invokerOnScreen.y - rootOnScreen.y) + y;\n+    \n+    setLocation(popupX , popupY);\n+    setVisible(true);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  JPopupMenu getRootPopupMenu()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param index DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Component getComponentAtIndex(int index)\n+  {\n+    return getComponent(index);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param component DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public int getComponentIndex(Component component)\n+  {\n+    Component[] items = getComponents();\n+\n+    for (int i = 0; i < items.length; i++)\n+      {\n+\tif (items[i].equals(component))\n+\t  return i;\n+      }\n+\n+    return -1;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param size DOCUMENT ME!\n+   */\n+  public void setPopupSize(Dimension size)\n+  {\n+    super.setSize(size);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param x DOCUMENT ME!\n+   * @param y DOCUMENT ME!\n+   */\n+  public void setPopupSize(int x, int y)\n+  {\n+    super.setSize(x, y);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param selected DOCUMENT ME!\n+   */\n+  public void setSelected(Component selected)\n+  {\n+    int index = getComponentIndex(selected);\n+    selectionModel.setSelectedIndex(index);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isBorderPainted()\n+  {\n+    return paintBorder;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param painted DOCUMENT ME!\n+   */\n+  public void setBorderPainted(boolean painted)\n+  {\n+    paintBorder = painted;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Insets getMargin()\n+  {\n+    return margin;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected String paramString()\n+  {\n+    return \"JPopupMenu\";\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   * @param path DOCUMENT ME!\n+   * @param manager DOCUMENT ME!\n+   */\n+  public void processMouseEvent(MouseEvent event, MenuElement[] path,\n+                                MenuSelectionManager manager)\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   * @param path DOCUMENT ME!\n+   * @param manager DOCUMENT ME!\n+   */\n+  public void processKeyEvent(KeyEvent event, MenuElement[] path,\n+                              MenuSelectionManager manager)\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param changed DOCUMENT ME!\n+   */\n+  public void menuSelectionChanged(boolean changed)\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public MenuElement[] getSubElements()\n+  {\n+    Component[] items = getComponents();\n+    MenuElement[] subElements = new MenuElement[items.length];\n+\n+    for (int i = 0; i < items.length; i++)\n+      subElements[i] = (MenuElement) items[i];\n+\n+    return subElements;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Component getComponent()\n+  {\n+    return this;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param event DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public boolean isPopupTrigger(MouseEvent event)\n+  {\n+    return ((PopupMenuUI)getUI()).isPopupTrigger(event);\n+    \n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJPopupMenu(this);\n+\n+    return accessibleContext;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.3.8.3 $\n+   */\n+  private interface Popup\n+  {\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param x DOCUMENT ME!\n+     * @param y DOCUMENT ME!\n+     * @param width DOCUMENT ME!\n+     * @param height DOCUMENT ME!\n+     */\n+    void show(int x, int y, int width, int height);\n+\n+    /**\n+     * DOCUMENT ME!\n+     */\n+    void hide();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.3.8.3 $\n+   */\n+  private class LightWeightPopup extends JPanel implements Popup\n+  {\n+    /**\n+     * Creates a new LightWeightPopup object.\n+     *\n+     * @param c DOCUMENT ME!\n+     */\n+    public LightWeightPopup(Container c)\n+    {\n+      this.add(c);\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param x DOCUMENT ME!\n+     * @param y DOCUMENT ME!\n+     * @param width DOCUMENT ME!\n+     * @param height DOCUMENT ME!\n+     */\n+    public void show(int x, int y, int width, int height)\n+    {\n+      JLayeredPane layeredPane;\n+      layeredPane = SwingUtilities.getRootPane(invoker).getLayeredPane();\n+      this.setBounds(x, y, width, height);\n+      layeredPane.add(this, JLayeredPane.POPUP_LAYER, 0);\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     */\n+    public void hide()\n+    {\n+      JLayeredPane layeredPane;\n+      layeredPane = SwingUtilities.getRootPane(invoker).getLayeredPane();\n+      int index = layeredPane.getIndexOf(this);\n+      layeredPane.remove(index);\n+    }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.3.8.3 $\n+   */\n+  private class MediumWeightPopup extends Panel implements Popup\n+  {\n+\n+    /**\n+     * Creates a new MediumWeightPopup object.\n+     *\n+     * @param c DOCUMENT ME!\n+     */\n+    public MediumWeightPopup(Container c)\n+    {\n+      this.add(c);      \n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param x DOCUMENT ME!\n+     * @param y DOCUMENT ME!\n+     * @param width DOCUMENT ME!\n+     * @param heigth DOCUMENT ME!\n+     */\n+    public void show(int x, int y, int width, int heigth)\n+    {\n+      JLayeredPane layeredPane;\n+      layeredPane = SwingUtilities.getRootPane(invoker).getLayeredPane();\n+      layeredPane.add(this, JLayeredPane.POPUP_LAYER, 0);\n+      this.setBounds(x, y, width, height);\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     */\n+    public void hide()\n+    {\n+      JLayeredPane layeredPane;\n+      layeredPane = SwingUtilities.getRootPane(invoker).getLayeredPane(); \n+      int index = layeredPane.getIndexOf(this);\n+      layeredPane.remove(index);\n+    }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.3.8.3 $\n+   */\n+  private class HeavyWeightPopup extends JWindow implements Popup\n+  {\n+    /**\n+     * Creates a new HeavyWeightPopup object.\n+     *\n+     * @param c DOCUMENT ME!\n+     */\n+    public HeavyWeightPopup(Container c)\n+    {\n+      this.setContentPane(c);\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param x DOCUMENT ME!\n+     * @param y DOCUMENT ME!\n+     * @param width DOCUMENT ME!\n+     * @param height DOCUMENT ME!\n+     */\n+    public void show(int x, int y, int width, int height)\n+    {\n+      this.setBounds(x, y, width, height);\n+      this.show();\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     */\n+    public void hide()\n+    {\n+      this.hide();\n+    }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.3.8.3 $\n+   */\n+  public static class Separator extends JSeparator\n+  {\n+    /**\n+     * Creates a new Separator object.\n+     */\n+    public Separator()\n+    {\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public String getUIClassID()\n+    {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.3.8.3 $\n+   */\n+  protected class AccessibleJPopupMenu extends AccessibleJComponent\n+  {\n+    /**\n+     * Creates a new AccessibleJPopupMenu object.\n+     *\n+     * @param component DOCUMENT ME!\n+     */\n+    protected AccessibleJPopupMenu(JPopupMenu component)\n+    {\n+      super(component);\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return AccessibleRole.POPUP_MENU;\n+    }\n+  }\n+}"}, {"sha": "7cbb9a684b5b075720f9f0de4b20c34c81696e65", "filename": "libjava/javax/swing/JRadioButtonMenuItem.java", "status": "modified", "additions": 117, "deletions": 47, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJRadioButtonMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJRadioButtonMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJRadioButtonMenuItem.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -39,118 +39,188 @@\n \n import java.io.IOException;\n import java.io.ObjectOutputStream;\n-\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n \n \n+/**\n+ * DOCUMENT ME!\n+ *\n+ * @author $author$\n+ * @version $Revision: 1.3.8.4 $\n+ */\n public class JRadioButtonMenuItem extends JMenuItem implements Accessible\n {\n-  //-------------------------------------------------------------\n-  // Variables --------------------------------------------------\n-  //-------------------------------------------------------------\n   private static final String uiClassID = \"RadioButtonMenuItemUI\";\n \n-  //-------------------------------------------------------------\n-  // Initialization ---------------------------------------------\n-  //-------------------------------------------------------------\n+  /**\n+   * Creates a new JRadioButtonMenuItem object.\n+   */\n   public JRadioButtonMenuItem()\n   {\n     this(null, null);\n-  } // JRadioButtonMenuItem()\n+  }\n \n+  /**\n+   * Creates a new JRadioButtonMenuItem object.\n+   *\n+   * @param icon DOCUMENT ME!\n+   */\n   public JRadioButtonMenuItem(Icon icon)\n   {\n     this(null, icon);\n-  } // JRadioButtonMenuItem()\n+  }\n \n+  /**\n+   * Creates a new JRadioButtonMenuItem object.\n+   *\n+   * @param text DOCUMENT ME!\n+   */\n   public JRadioButtonMenuItem(String text)\n   {\n     this(text, null);\n-  } // JRadioButtonMenuItem()\n+  }\n \n+  /**\n+   * Creates a new JRadioButtonMenuItem object.\n+   *\n+   * @param action DOCUMENT ME!\n+   */\n   public JRadioButtonMenuItem(Action action)\n   {\n     this();\n     setAction(action);\n-  } // JRadioButtonMenuItem()\n-\n+  }\n+\n+  /**\n+   * Creates a new JRadioButtonMenuItem object.\n+   *\n+   * @param text DOCUMENT ME!\n+   * @param icon DOCUMENT ME!\n+   */\n   public JRadioButtonMenuItem(String text, Icon icon)\n   {\n     this(text, icon, false);\n-  } // JRadioButtonMenuItem()\n-\n+  }\n+\n+  /**\n+   * Creates a new JRadioButtonMenuItem object.\n+   *\n+   * @param text DOCUMENT ME!\n+   * @param selected DOCUMENT ME!\n+   */\n   public JRadioButtonMenuItem(String text, boolean selected)\n   {\n     this(text, null, selected);\n-  } // JRadioButtonMenuItem()\n-\n+  }\n+\n+  /**\n+   * Creates a new JRadioButtonMenuItem object.\n+   *\n+   * @param icon DOCUMENT ME!\n+   * @param selected DOCUMENT ME!\n+   */\n   public JRadioButtonMenuItem(Icon icon, boolean selected)\n   {\n     this(null, icon, selected);\n-  } // JRadioButtonMenuItem()\n-\n+  }\n+\n+  /**\n+   * Creates a new JRadioButtonMenuItem object.\n+   *\n+   * @param text DOCUMENT ME!\n+   * @param icon DOCUMENT ME!\n+   * @param selected DOCUMENT ME!\n+   */\n   public JRadioButtonMenuItem(String text, Icon icon, boolean selected)\n   {\n-    super(text, icon);  \n-    setModel(new JToggleButton.ToggleButtonModel());\t\n+    super(text, icon);\n+    setModel(new JToggleButton.ToggleButtonModel());\n     model.setSelected(selected);\n-  } // JRadioButtonMenuItem()\n-\n-  //-------------------------------------------------------------\n-  // Methods ----------------------------------------------------\n-  //-------------------------------------------------------------\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param stream DOCUMENT ME!\n+   *\n+   * @throws IOException DOCUMENT ME!\n+   */\n   private void writeObject(ObjectOutputStream stream) throws IOException\n   {\n     // TODO\n-  } // writeObject()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public String getUIClassID()\n   {\n     return uiClassID;\n-  } // getUIClassID()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   */\n   public void requestFocus()\n   {\n     // TODO\n-  } // requestFocus()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   protected String paramString()\n   {\n     return \"JRadioButtonMenuItem\";\n-  } // paramString()\n+  }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      {\n-        accessibleContext = new AccessibleJRadioButtonMenuItem(this);\n-      }\n-    return accessibleContext;\n-  } // getAccessibleContext()\n+      accessibleContext = new AccessibleJRadioButtonMenuItem(this);\n \n-  //-------------------------------------------------------------\n-  // Classes ----------------------------------------------------\n-  //-------------------------------------------------------------\n+    return accessibleContext;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.3.8.4 $\n+   */\n   protected class AccessibleJRadioButtonMenuItem extends AccessibleJMenuItem\n   {\n-    //-------------------------------------------------------------\n-    // Initialization ---------------------------------------------\n-    //-------------------------------------------------------------\n+    /**\n+     * Creates a new AccessibleJRadioButtonMenuItem object.\n+     *\n+     * @param component DOCUMENT ME!\n+     */\n     protected AccessibleJRadioButtonMenuItem(JRadioButtonMenuItem component)\n     {\n       super(component);\n \n       // TODO\n-    } // AccessibleJRadioButtonMenuItem()\n+    }\n \n-    //-------------------------------------------------------------\n-    // Methods ----------------------------------------------------\n-    //-------------------------------------------------------------\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return $returnType$ DOCUMENT ME!\n+     */\n     public AccessibleRole getAccessibleRole()\n     {\n       return AccessibleRole.RADIO_BUTTON;\n-    } // getAccessibleRole()\n-  } // AccessibleJRadioButtonMenuItem\n-} // JRadioButtonMenuItem\n+    }\n+  }\n+}"}, {"sha": "99907d099902edc157d2bbe4e52380718eeaa2de", "filename": "libjava/javax/swing/JRootPane.java", "status": "modified", "additions": 172, "deletions": 36, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJRootPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJRootPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJRootPane.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -43,6 +43,8 @@\n import java.awt.Container;\n import java.awt.Dimension;\n import java.awt.LayoutManager;\n+import java.awt.LayoutManager2;\n+import javax.swing.plaf.RootPaneUI;\n \n /**\n  * This class is where JComponents are added to.\n@@ -64,42 +66,164 @@ public class JRootPane extends JComponent\n     static protected class AccessibleJRootPane\n     {\n     }\n-  \n-    //A custom layout manager  \n-    static protected class RootLayout extends BorderLayout\n+\n+    // Custom Layout Manager for JRootPane. It positions contentPane and \n+    // menuBar withing its layeredPane.\n+    protected class RootLayout extends Object implements LayoutManager2\n     {\n-      public Dimension preferredLayoutSize ( Container c )\n-\t{\t    \n-\t  Dimension p = super.preferredLayoutSize(c);\n-\t  return p;\n-\t}        \n-    }\n-  \n-    /***********************************************************/\n+      public void addLayoutComponent(Component comp, Object constraints)\n+      {\n+      }\n \n-  \n-    //The glass pane that overlays the menu bar and content pane, so it can intercept mouse movements and such.\n-    protected  Component glassPane;\n-  \n-    //The layered pane that manages the menu bar and content pane.\n-    protected  JLayeredPane layeredPane;\n-  \n-    // The menu bar.\n-    protected  JMenuBar menuBar;\n-  \n-    protected Container contentPane;\n+      public void addLayoutComponent(String name, Component comp)\n+      {\n+      }\n+\n+      public float getLayoutAlignmentX(Container target)\n+      {\n+        return target.getAlignmentX();\n+      }\n+\n+      public float getLayoutAlignmentY(Container target)\n+      {\n+        return target.getAlignmentY();\n+      }\n+\n+      public void invalidateLayout(Container target)\n+      {\n+      }\n+\n+      public void layoutContainer(Container c)\n+      {\n+        Dimension menuBarSize;\n+        Dimension containerSize = c.getSize(null);\n+        Dimension contentPaneSize = contentPane.getPreferredSize();\n+\n+        /*\n+         if size of top-level window wasn't set then just set\n+         contentPane and menuBar to its preferred sizes.\n+         Otherwise, if the size of top-level window was specified then\n+         set menuBar to its preferred size and make content pane\n+         to fit into the remaining space\n+\n+\n+         +-------------------------------+\n+         |  JLayeredPane                 |  \n+         |  +--------------------------+ |\n+         |  | menuBar                  | |\n+         |  +--------------------------+ |\n+         |  +--------------------------+ |\n+         |  |contentPane               | |\n+         |  |                          | |\n+         |  |                          | |\n+         |  |                          | |\n+         |  +--------------------------+ |\n+         +-------------------------------+\n+\n+        */\n+        if (containerSize.width == 0 && containerSize.height == 0)\n+          {\n+\t      if (menuBar != null)\n+\t      {\n+\t        int maxWidth;\n+\t        menuBarSize = menuBar.getPreferredSize();\n+\t        maxWidth = Math.max(menuBarSize.width, contentPaneSize.width);\n+\t        menuBar.setBounds(0, 0, maxWidth, menuBarSize.height);\n+\t        contentPane.setBounds(0, menuBarSize.height, maxWidth,\n+\t                              contentPaneSize.height);\n+\t        layeredPane.setSize(maxWidth,\n+\t                            menuBarSize.height + contentPaneSize.height);\n+\t      }\n+\t    else\n+\t      {\n+\t        contentPane.setBounds(0, 0, contentPaneSize.width,\n+\t                              contentPaneSize.height);\n+\t        layeredPane.setSize(contentPaneSize.width, contentPaneSize.height);\n+\t      }\n+          }\n+        else\n+          {\n+\t    if (menuBar != null)\n+\t      {\n+\t        menuBarSize = menuBar.getPreferredSize();\n+\t        if (menuBarSize.height > containerSize.height)\n+\t\t   menuBarSize.height = containerSize.height;\n+\t        menuBar.setBounds(0, 0, containerSize.width, menuBarSize.height);\n+\t        int remainingHeight = containerSize.height - menuBarSize.height;\n+\t        contentPane.setBounds(0, menuBarSize.height,\n+\t                              containerSize.width,\n+\t                              (containerSize.height - menuBarSize.height));\n+\t      }\n+\t    else\n+\t      contentPane.setBounds(0, 0, containerSize.width,\n+\t                            containerSize.height);\n+\n+\t    layeredPane.setSize(containerSize.width, containerSize.height);\n+          }\n+      }\n+      \n+      public Dimension maximumLayoutSize(Container target)\n+      {\n+        return preferredLayoutSize(target);\n+      }\n \n-    /********************************************************/\n+      public Dimension minimumLayoutSize(Container target)\n+      {\n+        return preferredLayoutSize(target);\n+      }\n \n-    public String getUIClassID()\n-    {\treturn \"RootPaneUI\";    }\n+      public Dimension preferredLayoutSize(Container c)\n+      {\n+        Dimension menuBarSize;\n+        Dimension prefSize;\n \n+        Dimension containerSize = c.getSize();\n+        Dimension contentPaneSize = contentPane.getPreferredSize();\n+\n+        if (containerSize.width == 0 && containerSize.height == 0)\n+          {\n+\t    if (menuBar != null)\n+\t      {\n+\t        int maxWidth;\n+\t        menuBarSize = menuBar.getPreferredSize();\n+\t        maxWidth = Math.max(menuBarSize.width, contentPaneSize.width);\n+\t        prefSize = new Dimension(maxWidth,\n+\t                               contentPaneSize.height\n+\t                               + menuBarSize.height);\n+\t      }\n+\t    else\n+\t      prefSize = contentPaneSize;\n+          }\n+        else\n+          prefSize = c.getSize();\n+\n+        return prefSize;\n+      }\n+\n+      public void removeLayoutComponent(Component comp)\n+      {\n+      }\n+    }\n+  \n+    protected  Component glassPane;\n+    protected  JLayeredPane layeredPane;  \n+    protected  JMenuBar menuBar;  \n+    protected Container contentPane;\n+  \n     \n     void setJMenuBar(JMenuBar m)\n-    {  menuBar = m; }\n+    {  \n+      menuBar = m; \n+      getLayeredPane().add(menuBar, JLayeredPane.FRAME_CONTENT_LAYER);\n+    }\n \n     JMenuBar getJMenuBar()\n     {  return menuBar; }\n+\n+  public boolean isValidateRoot()\n+  {\n+    return true;\n+  }\n     \n \n     public Container getContentPane()\n@@ -122,7 +246,6 @@ protected void addImpl(Component comp,\n \t\t\t  int index)\n     {\n \tsuper.addImpl(comp, constraints, index);\n-\t//System.out.println(\"don't do that !\");\n     } \n \n     public Component getGlassPane() \n@@ -159,16 +282,12 @@ public void setLayeredPane(JLayeredPane f)\n     }\n     \n \n-    /********************************************************/\n-\n     JRootPane()\n     {\n \tsetLayout(createRootLayout());\n-\tsetBackground(UIManager.getColor(\"control\"));\n \tgetGlassPane();\n \tgetLayeredPane();\n \tgetContentPane();\n-\n \tsetDoubleBuffered(true);\n \tupdateUI();\n     }\n@@ -182,9 +301,6 @@ JComponent createContentPane()\n \tJPanel p = new JPanel();\n \tp.setName(this.getName()+\".contentPane\");\n \tp.setLayout(new BorderLayout());\n-\t//\tp.setVisible(true);\n-\n-\tSystem.out.println(\"Created ContentPane: \" + p);\n \treturn p;\n     }\n \n@@ -194,14 +310,34 @@ Component createGlassPane()\n \tp.setName(this.getName()+\".glassPane\");\n \tp.setLayout(new BorderLayout());\n \tp.setVisible(false);\n-\t\n-\tSystem.out.println(\"created the glasspane: \"+p);\n \treturn p;\n     }\n \n     JLayeredPane createLayeredPane()\n     {\n \tJLayeredPane l = new JLayeredPane();\n+\tl.setLayout(null);\n \treturn l;\n     }    \n+\n+\n+  public RootPaneUI getUI()\n+  {\n+    return (RootPaneUI) ui;\n+  }\n+\n+  public void setUI(RootPaneUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  public void updateUI()\n+  {\n+    setUI((RootPaneUI) UIManager.getUI(this));\n+  }\n+\n+  public String getUIClassID()\n+  {\n+    return \"RootPaneUI\";\n+  }\n }"}, {"sha": "b8404b3a940e6a9b9510b403a1c3e5a8e5d33898", "filename": "libjava/javax/swing/JScrollBar.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJScrollBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJScrollBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJScrollBar.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -169,7 +169,7 @@ public Number getMaximumAccessibleValue()\n   protected BoundedRangeModel model;\n \n   /** The orientation of the scroll bar. */\n-  protected int orientation = SwingConstants.HORIZONTAL;\n+  protected int orientation = SwingConstants.VERTICAL;\n \n   /** How much the thumb moves when moving in a unit. */\n   protected int unitIncrement = 1;\n@@ -186,7 +186,7 @@ public Number getMaximumAccessibleValue()\n    */\n   public JScrollBar()\n   {\n-    this(SwingConstants.HORIZONTAL, 0, 10, 0, 100);\n+    this(SwingConstants.VERTICAL, 0, 10, 0, 100);\n   }\n \n   /**"}, {"sha": "1a2021e3332c346340d4a4cc0f9c6ff1ea168827", "filename": "libjava/javax/swing/JScrollPane.java", "status": "modified", "additions": 87, "deletions": 25, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJScrollPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJScrollPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJScrollPane.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -40,6 +40,8 @@\n \n import java.awt.Component;\n import java.awt.ComponentOrientation;\n+import java.awt.Dimension;\n+import java.awt.LayoutManager;\n import java.awt.Insets;\n import java.awt.LayoutManager;\n import java.awt.Point;\n@@ -50,6 +52,7 @@\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n import javax.swing.plaf.ScrollPaneUI;\n+import javax.swing.plaf.UIResource;\n \n /**\n  * <table>\n@@ -430,7 +433,11 @@ public void setViewport(JViewport v)\n   {\n     JViewport old = viewport;\n     removeNonNull(old);\n+    if (old != null)\n+      old.removeChangeListener(scrollListener);\n     viewport = v;\n+    if (v != null)\n+      v.addChangeListener(scrollListener);\n     addNonNull(v);\n     revalidate();\n     repaint();\n@@ -467,29 +474,64 @@ public boolean isValidateRoot()\n \n   ChangeListener createScrollListener()\n   {\n-    return new ChangeListener() {\n+    return new ChangeListener() \n+      {\n+        \n         public void stateChanged(ChangeEvent event)\n         {\n-          int xpos = 0;\n-          int ypos = 0;\n           JScrollBar vsb = JScrollPane.this.getVerticalScrollBar();\n           JScrollBar hsb = JScrollPane.this.getHorizontalScrollBar();\n-          \n-          if (vsb != null)\n+          JViewport vp = JScrollPane.this.getViewport();\n+\n+          if (vp != null && event.getSource() == vp)\n             {\n-              BoundedRangeModel vmod = vsb.getModel();\n-              if (vmod != null)\n-                ypos = vmod.getValue();\n+              // if the viewport changed, we should update the VSB / HSB\n+              // models according to the new vertical and horizontal sizes\n+              Rectangle vr = vp.getViewRect();\n+              Dimension vs = vp.getViewSize();\n+              // System.err.println(\"got change from viewport, vr=\" + vr + \", vs=\" + vs);\n+              if (vsb != null\n+                  && (vsb.getMinimum() != 0\n+                      || vsb.getMaximum() != vs.height\n+                      || vsb.getValue() != vr.y\n+                      || vsb.getVisibleAmount() != vr.height))\n+                {\n+                  //                   System.err.println(\"setting vsb to \"\n+                  //                                      + \"pos=\" + vr.y \n+                  //                                      + \", ext=\" + vr.height \n+                  //                                      + \", min=0\"\n+                  //                                      + \", max=\" + vs.height);\n+                  vsb.setValue(vr.y, vr.height, 0, vs.height);\n+                }\n+\n+              if (hsb != null\n+                  && (hsb.getMinimum() != 0\n+                      || hsb.getMaximum() != vs.width\n+                      || hsb.getValue() != vr.width\n+                      || hsb.getVisibleAmount() != vr.height))\n+                hsb.setValue(vr.x, vr.width, 0, vs.width);\n             }\n-\n-          if (hsb != null)\n+          else\n             {\n-              BoundedRangeModel hmod = hsb.getModel();\n-              if (hmod != null)\n-                xpos = hmod.getValue();\n+              // otherwise we got a change update from either the VSB or\n+              // HSB model, and we need to update the viewport position to\n+              // match.\n+\n+              int xpos = 0;\n+              int ypos = 0;\n+              \n+              if (vsb != null)\n+                ypos = vsb.getValue();\n+              \n+              if (hsb != null)\n+                xpos = hsb.getValue();\n+\n+              Point pt = new Point(xpos, ypos);\n+\n+              if (vp != null\n+                  && vp.getViewPosition() != pt)\n+                vp.setViewPosition(pt);\n             }\n-          if (JScrollPane.this.viewport != null)\n-            JScrollPane.this.viewport.setViewPosition(new Point(xpos, ypos));\n         }\n       };\n   }\n@@ -528,12 +570,12 @@ public JScrollPane(Component view, int vsbPolicy, int hsbPolicy)\n   \n   public JScrollBar createHorizontalScrollBar()\n   {\n-    return new JScrollBar(SwingConstants.HORIZONTAL);\n+    return new ScrollBar(SwingConstants.HORIZONTAL);\n   }\n \n   public JScrollBar createVerticalScrollBar()\n   {\n-    return new JScrollBar(SwingConstants.VERTICAL);\n+    return new ScrollBar(SwingConstants.VERTICAL);\n   }\n     \n   public JViewport createViewport()\n@@ -553,25 +595,45 @@ public void updateUI()\n     setUI(b);\n   }  \n \n-  /*\n+\n   class ScrollBar \n     extends JScrollBar\n     implements UIResource\n   {\n     public ScrollBar(int orientation)\n     {\n       super(orientation);\n-      Component view = this.JScrollPane.getViewportView();\n-      if (view == null)\n-        return;\n-      if (! view instanceof Scrollable)\n+    }\n+\n+    public int getBlockIncrement(int direction)\n+    {\n+      Component view = JScrollPane.this.getViewport().getView();\n+      if (view == null || (! (view instanceof Scrollable)))\n+        return super.getBlockIncrement(direction);\n+      else\n         {\n           Scrollable s = (Scrollable) view;\n-          s.\n+          return s.getScrollableBlockIncrement(JScrollPane.this.getViewport().getViewRect(), \n+                                               this.getOrientation(),\n+                                               direction);\n+        }\n+    }\n+\n+    public int getUnitIncrement(int direction)\n+    {\n+      Component view = JScrollPane.this.getViewport().getView();\n+      if (view == null || (! (view instanceof Scrollable)))\n+        return super.getUnitIncrement(direction);\n+      else\n+        {\n+          Scrollable s = (Scrollable) view;\n+          return s.getScrollableUnitIncrement(JScrollPane.this.getViewport().getViewRect(), \n+                                              this.getOrientation(),\n+                                              direction);\n         }\n     }\n \n-  }\n-  */\n \n+  }\n+  \n }"}, {"sha": "b4db64180c373639e202bd6661ee5b9a565ab65c", "filename": "libjava/javax/swing/JSlider.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJSlider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJSlider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJSlider.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -304,7 +304,7 @@ public JSlider(int orientation)\n    */\n   public JSlider(int minimum, int maximum)\n   {\n-    this(HORIZONTAL, minimum, maximum, (maximum - minimum) / 2);\n+    this(HORIZONTAL, minimum, maximum, (maximum + minimum) / 2);\n   }\n \n   /**"}, {"sha": "a8ef310708e92305a46d14d89a421201a6c7dfc7", "filename": "libjava/javax/swing/JSplitPane.java", "status": "modified", "additions": 761, "deletions": 634, "changes": 1395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJSplitPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJSplitPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJSplitPane.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -1,648 +1,775 @@\n-/* JSplitPane.java --\n-   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n \n package javax.swing;\n \n import java.awt.Component;\n import java.awt.Graphics;\n-import java.io.IOException;\n-import java.io.ObjectOutputStream;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n import javax.accessibility.AccessibleStateSet;\n import javax.accessibility.AccessibleValue;\n+import javax.swing.UIManager;\n import javax.swing.plaf.SplitPaneUI;\n \n+\n /**\n- * JSplitPane\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * This class implements JSplitPane. It is used to divide two components. By\n+ * dragging the SplitPane's divider, the user can resize the two components.\n+ * Note that the divider cannot resize a component to smaller than it's\n+ * minimum size.\n  */\n-public class JSplitPane extends JComponent implements Accessible {\n-\n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * AccessibleJSplitPane\n-\t */\n-\tprotected class AccessibleJSplitPane extends AccessibleJComponent \n-\t\t\timplements AccessibleValue {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJSplitPane\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJSplitPane(JSplitPane component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJSplitPane()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleStateSet\n-\t\t * @returns AccessibleStateSet\n-\t\t */\n-\t\tpublic AccessibleStateSet getAccessibleStateSet() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleStateSet()\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn AccessibleRole.SPLIT_PANE;\n-\t\t} // getAccessibleRole()\n-\n-\t\t/**\n-\t\t * getAccessibleValue\n-\t\t * @returns AccessibleValue\n-\t\t */\n-\t\tpublic AccessibleValue getAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleValue()\n-\n-\t\t/**\n-\t\t * getCurrentAccessibleValue\n-\t\t * @returns Number\n-\t\t */\n-\t\tpublic Number getCurrentAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getCurrentAccessibleValue()\n-\n-\t\t/**\n-\t\t * setCurrentAccessibleValue\n-\t\t * @param value0 TODO\n-\t\t * @returns boolean\n-\t\t */\n-\t\tpublic boolean setCurrentAccessibleValue(Number value0) {\n-\t\t\treturn false; // TODO\n-\t\t} // setCurrentAccessibleValue()\n-\n-\t\t/**\n-\t\t * getMinimumAccessibleValue\n-\t\t * @returns Number\n-\t\t */\n-\t\tpublic Number getMinimumAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getMinimumAccessibleValue()\n-\n-\t\t/**\n-\t\t * getMaximumAccessibleValue\n-\t\t * @returns Number\n-\t\t */\n-\t\tpublic Number getMaximumAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getMaximumAccessibleValue()\n-\n-\n-\t} // AccessibleJSplitPane\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * uiClassID\n-\t */\n-\tprivate static final String uiClassID = \"SplitPaneUI\";\n-\n-\t/**\n-\t * VERTICAL_SPLIT\n-\t */\n-\tpublic static final int VERTICAL_SPLIT = 0;\n-\n-\t/**\n-\t * HORIZONTAL_SPLIT\n-\t */\n-\tpublic static final int HORIZONTAL_SPLIT = 1;\n-\n-\t/**\n-\t * LEFT\n-\t */\n-\tpublic static final String LEFT = \"left\";\n-\n-\t/**\n-\t * RIGHT\n-\t */\n-\tpublic static final String RIGHT = \"right\";\n-\n-\t/**\n-\t * TOP\n-\t */\n-\tpublic static final String TOP = \"top\";\n-\n-\t/**\n-\t * BOTTOM\n-\t */\n-\tpublic static final String BOTTOM = \"bottom\";\n-\n-\t/**\n-\t * DIVIDER\n-\t */\n-\tpublic static final String DIVIDER = \"divider\";\n-\n-\t/**\n-\t * ORIENTATION_PROPERTY\n-\t */\n-\tpublic static final String ORIENTATION_PROPERTY = \"orientation\";\n-\n-\t/**\n-\t * CONTINUOUS_LAYOUT_PROPERTY\n-\t */\n-\tpublic static final String CONTINUOUS_LAYOUT_PROPERTY = \"continuousLayout\";\n-\n-\t/**\n-\t * DIVIDER_SIZE_PROPERTY\n-\t */\n-\tpublic static final String DIVIDER_SIZE_PROPERTY = \"dividerSize\";\n-\n-\t/**\n-\t * ONE_TOUCH_EXPANDABLE_PROPERTY\n-\t */\n-\tpublic static final String ONE_TOUCH_EXPANDABLE_PROPERTY = \"oneTouchExpandable\";\n-\n-\t/**\n-\t * LAST_DIVIDER_LOCATION_PROPERTY\n-\t */\n-\tpublic static final String LAST_DIVIDER_LOCATION_PROPERTY = \"lastDividerLocation\";\n-\n-\t/**\n-\t * DIVIDER_LOCATION_PROPERTY\n-\t */\n-\tpublic static final String DIVIDER_LOCATION_PROPERTY = \"dividerLocation\";\n-\n-\t/**\n-\t * RESIZE_WEIGHT_PROPERTY\n-\t */\n-\tpublic static final String RESIZE_WEIGHT_PROPERTY = \"resizeWeight\";\n-\n-\t/**\n-\t * orientation\n-\t */\n-\tprotected int orientation;\n-\n-\t/**\n-\t * continuousLayout\n-\t */\n-\tprotected boolean continuousLayout;\n-\n-\t/**\n-\t * leftComponent\n-\t */\n-\tprotected Component leftComponent;\n-\n-\t/**\n-\t * rightComponent\n-\t */\n-\tprotected Component rightComponent;\n-\n-\t/**\n-\t * dividerSize\n-\t */\n-\tprotected int dividerSize;\n-\n-\t/**\n-\t * oneTouchExpandable\n-\t */\n-\tprotected boolean oneTouchExpandable;\n-\n-\t/**\n-\t * lastDividerLocation\n-\t */\n-\tprotected int lastDividerLocation;\n-\n-\t/**\n-\t * resizeWeight\n-\t */\n-\tprivate double resizeWeight;\n-\n-\t/**\n-\t * dividerLocation\n-\t */\n-\tprivate int dividerLocation;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor JSplitPane\n-\t */\n-\tpublic JSplitPane() {\n-\t\t// TODO\n-\t} // JSplitPane()\n-\n-\t/**\n-\t * Constructor JSplitPane\n-\t * @param value0 TODO\n-\t */\n-\tpublic JSplitPane(int value0) {\n-\t\t// TODO\n-\t} // JSplitPane()\n-\n-\t/**\n-\t * Constructor JSplitPane\n-\t * @param value0 TODO\n-\t * @param value1 TODO\n-\t */\n-\tpublic JSplitPane(int value0, boolean value1) {\n-\t\t// TODO\n-\t} // JSplitPane()\n-\n-\t/**\n-\t * Constructor JSplitPane\n-\t * @param value0 TODO\n-\t * @param value1 TODO\n-\t * @param value2 TODO\n-\t */\n-\tpublic JSplitPane(int value0, Component value1, Component value2) {\n-\t\t// TODO\n-\t} // JSplitPane()\n-\n-\t/**\n-\t * Constructor JSplitPane\n-\t * @param value0 TODO\n-\t * @param value1 TODO\n-\t * @param value2 TODO\n-\t * @param value3 TODO\n-\t */\n-\tpublic JSplitPane(int value0, boolean value1, Component value2, Component value3) {\n-\t\t// TODO\n-\t} // JSplitPane()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * writeObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n-\t */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n-\t\t// TODO\n-\t} // writeObject()\n-\n-\t/**\n-\t * remove\n-\t * @param value0 TODO\n-\t */\n-\tpublic void remove(Component value0) {\n-\t\t// TODO\n-\t} // remove()\n-\n-\t/**\n-\t * remove\n-\t * @param value0 TODO\n-\t */\n-\tpublic void remove(int value0) {\n-\t\t// TODO\n-\t} // remove()\n-\n-\t/**\n-\t * removeAll\n-\t */\n-\tpublic void removeAll() {\n-\t\t// TODO\n-\t} // removeAll()\n-\n-\t/**\n-\t * setUI\n-\t * @param ui TODO\n-\t */\n-\tpublic void setUI(SplitPaneUI ui) {\n-\t\tsuper.setUI(ui);\n-\t} // setUI()\n-\n-\t/**\n-\t * getUI\n-\t * @returns SplitPaneUI\n-\t */\n-\tpublic SplitPaneUI getUI() {\n-\t\treturn (SplitPaneUI) ui;\n-\t} // getUI()\n-\n-\t/**\n-\t * updateUI\n-\t */\n-\tpublic void updateUI() {\n-\t\tsetUI((SplitPaneUI) UIManager.get(this));\n-\t\tinvalidate();\n-\t} // updateUI()\n-\n-\t/**\n-\t * getUIClassID\n-\t * @returns String\n-\t */\n-\tpublic String getUIClassID() {\n-\t\treturn uiClassID;\n-\t} // getUIClassID()\n-\n-\t/**\n-\t * setDividerSize\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setDividerSize(int value0) {\n-\t\t// TODO\n-\t} // setDividerSize()\n-\n-\t/**\n-\t * getDividerSize\n-\t * @returns int\n-\t */\n-\tpublic int getDividerSize() {\n-\t\treturn 0; // TODO\n-\t} // getDividerSize()\n-\n-\t/**\n-\t * setLeftComponent\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setLeftComponent(Component value0) {\n-\t\t// TODO\n-\t} // setLeftComponent()\n-\n-\t/**\n-\t * getLeftComponent\n-\t * @returns Component\n-\t */\n-\tpublic Component getLeftComponent() {\n-\t\treturn null; // TODO\n-\t} // getLeftComponent()\n-\n-\t/**\n-\t * setTopComponent\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setTopComponent(Component value0) {\n-\t\t// TODO\n-\t} // setTopComponent()\n-\n-\t/**\n-\t * getTopComponent\n-\t * @returns Component\n-\t */\n-\tpublic Component getTopComponent() {\n-\t\treturn null; // TODO\n-\t} // getTopComponent()\n-\n-\t/**\n-\t * setRightComponent\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setRightComponent(Component value0) {\n-\t\t// TODO\n-\t} // setRightComponent()\n-\n-\t/**\n-\t * getRightComponent\n-\t * @returns Component\n-\t */\n-\tpublic Component getRightComponent() {\n-\t\treturn null; // TODO\n-\t} // getRightComponent()\n-\n-\t/**\n-\t * setBottomComponent\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setBottomComponent(Component value0) {\n-\t\t// TODO\n-\t} // setBottomComponent()\n-\n-\t/**\n-\t * getBottomComponent\n-\t * @returns Component\n-\t */\n-\tpublic Component getBottomComponent() {\n-\t\treturn null; // TODO\n-\t} // getBottomComponent()\n-\n-\t/**\n-\t * setOneTouchExpandable\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setOneTouchExpandable(boolean value0) {\n-\t\t// TODO\n-\t} // setOneTouchExpandable()\n-\n-\t/**\n-\t * isOneTouchExpandable\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isOneTouchExpandable() {\n-\t\treturn false; // TODO\n-\t} // isOneTouchExpandable()\n-\n-\t/**\n-\t * setLastDividerLocation\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setLastDividerLocation(int value0) {\n-\t\t// TODO\n-\t} // setLastDividerLocation()\n-\n-\t/**\n-\t * getLastDividerLocation\n-\t * @returns int\n-\t */\n-\tpublic int getLastDividerLocation() {\n-\t\treturn 0; // TODO\n-\t} // getLastDividerLocation()\n-\n-\t/**\n-\t * setOrientation\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setOrientation(int value0) {\n-\t\t// TODO\n-\t} // setOrientation()\n-\n-\t/**\n-\t * getOrientation\n-\t * @returns int\n-\t */\n-\tpublic int getOrientation() {\n-\t\treturn 0; // TODO\n-\t} // getOrientation()\n-\n-\t/**\n-\t * setContinuousLayout\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setContinuousLayout(boolean value0) {\n-\t\t// TODO\n-\t} // setContinuousLayout()\n-\n-\t/**\n-\t * isContinuousLayout\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isContinuousLayout() {\n-\t\treturn false; // TODO\n-\t} // isContinuousLayout()\n-\n-\t/**\n-\t * setResizeWeight\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setResizeWeight(double value0) {\n-\t\t// TODO\n-\t} // setResizeWeight()\n-\n-\t/**\n-\t * getResizeWeight\n-\t * @returns double\n-\t */\n-\tpublic double getResizeWeight() {\n-\t\treturn 0.0; // TODO\n-\t} // getResizeWeight()\n-\n-\t/**\n-\t * resetToPreferredSizes\n-\t */\n-\tpublic void resetToPreferredSizes() {\n-\t\t// TODO\n-\t} // resetToPreferredSizes()\n-\n-\t/**\n-\t * setDividerLocation\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setDividerLocation(double value0) {\n-\t\t// TODO\n-\t} // setDividerLocation()\n-\n-\t/**\n-\t * setDividerLocation\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setDividerLocation(int value0) {\n-\t\t// TODO\n-\t} // setDividerLocation()\n-\n-\t/**\n-\t * getDividerLocation\n-\t * @returns int\n-\t */\n-\tpublic int getDividerLocation() {\n-\t\treturn 0; // TODO\n-\t} // getDividerLocation()\n-\n-\t/**\n-\t * getMinimumDividerLocation\n-\t * @returns int\n-\t */\n-\tpublic int getMinimumDividerLocation() {\n-\t\treturn 0; // TODO\n-\t} // getMinimumDividerLocation()\n-\n-\t/**\n-\t * getMaximumDividerLocation\n-\t * @returns int\n-\t */\n-\tpublic int getMaximumDividerLocation() {\n-\t\treturn 0; // TODO\n-\t} // getMaximumDividerLocation()\n-\n-\t/**\n-\t * isValidateRoot\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isValidateRoot() {\n-\t\treturn false; // TODO\n-\t} // isValidateRoot()\n-\n-\t/**\n-\t * addImpl\n-\t * @param value0 TODO\n-\t * @param value1 TODO\n-\t * @param value2 TODO\n-\t */\n-\tprotected void addImpl(Component value0, Object value1, int value2) {\n-\t\t// TODO\n-\t} // addImpl()\n-\n-\t/**\n-\t * paintChildren\n-\t * @param value0 TODO\n-\t */\n-\tprotected void paintChildren(Graphics value0) {\n-\t\t// TODO\n-\t} // paintChildren()\n-\n-\t/**\n-\t * paramString\n-\t * @returns String\n-\t */\n-\tprotected String paramString() {\n-\t\treturn null; // TODO\n-\t} // paramString()\n-\n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJSplitPane(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n-} // JSplitPane\n+public class JSplitPane extends JComponent implements Accessible\n+{\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected class AccessibleJSplitPane extends JComponent.AccessibleJComponent\n+    implements AccessibleValue\n+  {\n+    /**\n+     * Creates a new AccessibleJSplitPane object.\n+     *\n+     * @param value0 DOCUMENT ME!\n+     */\n+    protected AccessibleJSplitPane(JSplitPane value0)\n+    {\n+      super(value0);\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleStateSet getAccessibleStateSet()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleValue getAccessibleValue()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Number getCurrentAccessibleValue()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param value0 DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public boolean setCurrentAccessibleValue(Number value0)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Number getMinimumAccessibleValue()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Number getMaximumAccessibleValue()\n+    {\n+      return null;\n+    }\n+  }\n+\n+  /** The constraints string used to add components to the bottom. */\n+  public static final String BOTTOM = \"bottom\";\n+\n+  /** The property fired when the continuousLayout property changes. */\n+  public static final String CONTINUOUS_LAYOUT_PROPERTY = \"continuousLayout\";\n+\n+  /** The property fired when the divider property changes. */\n+  public static final String DIVIDER = \"divider\";\n+\n+  /** The property fired when the divider location property changes. */\n+  public static final String DIVIDER_LOCATION_PROPERTY = \"dividerLocation\";\n+\n+  /** The property fired when the divider size property changes. */\n+  public static final String DIVIDER_SIZE_PROPERTY = \"dividerSize\";\n+\n+  /**\n+   * The value of the orientation when the components are split horizontally.\n+   */\n+  public static final int HORIZONTAL_SPLIT = 1;\n+\n+  /** The property fired when the last divider location property changes. */\n+  public static final String LAST_DIVIDER_LOCATION_PROPERTY = \"lastDividerLocation\";\n+\n+  /** The constraints string used to add components to the left. */\n+  public static final String LEFT = \"left\";\n+\n+  /** The property fired when the one touch expandable property changes. */\n+  public static final String ONE_TOUCH_EXPANDABLE_PROPERTY = \"oneTouchExpandable\";\n+\n+  /** The property fired when the orientation property changes. */\n+  public static final String ORIENTATION_PROPERTY = \"orientation\";\n+\n+  /** The property fired when the resize weight property changes. */\n+  public static final String RESIZE_WEIGHT_PROPERTY = \"resizeWeight\";\n+\n+  /** The constraints string used to add components to the right. */\n+  public static final String RIGHT = \"right\";\n+\n+  /** The constraints string used to add components to the top. */\n+  public static final String TOP = \"top\";\n+\n+  /** The value of the orientation when the components are split vertically. */\n+  public static final int VERTICAL_SPLIT = 0;\n+\n+  /** Whether the JSplitPane uses continuous layout. */\n+  protected boolean continuousLayout;\n+\n+  /** Whether the JSplitPane uses one touch expandable buttons. */\n+  protected boolean oneTouchExpandable = false;\n+\n+  // This is the master dividerSize variable and sets the BasicSplitPaneDivider one accordingly\n+\n+  /** The size of the divider. */\n+  protected int dividerSize = 10;\n+\n+  /** The last location of the divider given by the UI. */\n+  protected int lastDividerLocation;\n+\n+  /** The orientation of the JSplitPane. */\n+  protected int orientation;\n+\n+  /** The component on the top or left. */\n+  protected Component leftComponent;\n+\n+  /** The component on the right or bottom. */\n+  protected Component rightComponent;\n+\n+  /** Determines how extra space should be allocated. */\n+  private transient double resizeWeight;\n+\n+  /**\n+   * Creates a new JSplitPane object with the given orientation, layout mode,\n+   * and left and right components.\n+   *\n+   * @param newOrientation The orientation to use.\n+   * @param newContinuousLayout The layout mode to use.\n+   * @param newLeftComponent The left component.\n+   * @param newRightComponent The right component.\n+   *\n+   * @throws IllegalArgumentException DOCUMENT ME!\n+   */\n+  public JSplitPane(int newOrientation, boolean newContinuousLayout,\n+                    Component newLeftComponent, Component newRightComponent)\n+  {\n+    if (newOrientation != HORIZONTAL_SPLIT && newOrientation != VERTICAL_SPLIT)\n+      throw new IllegalArgumentException(\"orientation is invalid.\");\n+    orientation = newOrientation;\n+    continuousLayout = newContinuousLayout;\n+    setLeftComponent(newLeftComponent);\n+    setRightComponent(newRightComponent);\n+\n+    updateUI();\n+  }\n+\n+  /**\n+   * Creates a new JSplitPane object using nonContinuousLayout mode, the given\n+   * orientation and left and right components.\n+   *\n+   * @param newOrientation The orientation to use.\n+   * @param newLeftComponent The left component.\n+   * @param newRightComponent The right component.\n+   */\n+  public JSplitPane(int newOrientation, Component newLeftComponent,\n+                    Component newRightComponent)\n+  {\n+    this(newOrientation, false, newLeftComponent, newRightComponent);\n+  }\n+\n+  /**\n+   * Creates a new JSplitPane object with the given layout mode and\n+   * orientation.\n+   *\n+   * @param newOrientation The orientation to use.\n+   * @param newContinuousLayout The layout mode to use.\n+   */\n+  public JSplitPane(int newOrientation, boolean newContinuousLayout)\n+  {\n+    this(newOrientation, newContinuousLayout, null, null);\n+  }\n+\n+  /**\n+   * Creates a new JSplitPane object using a nonContinuousLayout mode and the\n+   * given orientation.\n+   *\n+   * @param newOrientation The orientation to use.\n+   */\n+  public JSplitPane(int newOrientation)\n+  {\n+    this(newOrientation, false, null, null);\n+  }\n+\n+  /**\n+   * Creates a new JSplitPane object using HORIZONTAL_SPLIT and a\n+   * nonContinuousLayout mode.\n+   */\n+  public JSplitPane()\n+  {\n+    this(HORIZONTAL_SPLIT, false, null, null);\n+  }\n+\n+  /**\n+   * This method adds a component to the JSplitPane. The constraints object is\n+   * a string that identifies where this component should go. If the\n+   * constraints is not a known one, it will throw an\n+   * IllegalArgumentException. The valid constraints are LEFT, TOP, RIGHT,\n+   * BOTTOM and DIVIDER.\n+   *\n+   * @param comp The component to add.\n+   * @param constraints The constraints string to use.\n+   * @param index Where to place to component in the list of components.\n+   *\n+   * @throws IllegalArgumentException When the constraints is not a known identifier.\n+   */\n+  protected void addImpl(Component comp, Object constraints, int index)\n+  {\n+    int left = 0;\n+    int right = 1;\n+    int div = 2;\n+    int place;\n+    if (constraints == null)\n+      {\n+\tif (leftComponent == null)\n+\t  constraints = LEFT;\n+\telse if (rightComponent == null)\n+\t  constraints = RIGHT;\n+      }\n+\n+    if (constraints instanceof String)\n+      {\n+\tString placement = (String) constraints;\n+\n+\tif (placement.equals(BOTTOM) || placement.equals(RIGHT))\n+\t  {\n+\t    if (rightComponent != null)\n+\t\tremove(rightComponent);\n+\t    rightComponent = comp;\n+\t  }\n+\telse if (placement.equals(LEFT) || placement.equals(TOP))\n+\t  {\n+\t    if (leftComponent != null)\n+\t      remove(leftComponent);\n+\t    leftComponent = comp;\n+\t  }\n+\telse if (placement.equals(DIVIDER))\n+\t  constraints = null;\n+\telse\n+\t  throw new IllegalArgumentException(\"Constraints is not a known identifier.\");\n+\n+\tsuper.addImpl(comp, constraints, index);\n+      }\n+    invalidate();\n+    layout();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJSplitPane(this);\n+    return accessibleContext;\n+  }\n+\n+  /**\n+   * This method returns the bottom component.\n+   *\n+   * @return The bottom component.\n+   */\n+  public Component getBottomComponent()\n+  {\n+    return rightComponent;\n+  }\n+\n+  /**\n+   * This method returns the location of the divider. This method is passed to\n+   * the UI.\n+   *\n+   * @return The location of the divider.\n+   */\n+  public int getDividerLocation()\n+  {\n+    if (ui != null)\n+      return ((SplitPaneUI) ui).getDividerLocation(this);\n+    else\n+      return -1;\n+  }\n+\n+  /**\n+   * This method returns the size of the divider.\n+   *\n+   * @return The size of the divider.\n+   */\n+  public int getDividerSize()\n+  {\n+    return dividerSize;\n+  }\n+\n+  /**\n+   * This method returns the last divider location.\n+   *\n+   * @return The last divider location.\n+   */\n+  public int getLastDividerLocation()\n+  {\n+    return lastDividerLocation;\n+  }\n+\n+  /**\n+   * This method returns the left component.\n+   *\n+   * @return The left component.\n+   */\n+  public Component getLeftComponent()\n+  {\n+    return leftComponent;\n+  }\n+\n+  /**\n+   * This method returns the maximum divider location. This method is passed\n+   * to  the UI.\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public int getMaximumDividerLocation()\n+  {\n+    if (ui != null)\n+      return ((SplitPaneUI) ui).getMaximumDividerLocation(this);\n+    else\n+      return -1;\n+  }\n+\n+  /**\n+   * This method returns the minimum divider location. This method is passed\n+   * to the UI.\n+   *\n+   * @return The minimum divider location.\n+   */\n+  public int getMinimumDividerLocation()\n+  {\n+    if (ui != null)\n+      return ((SplitPaneUI) ui).getMinimumDividerLocation(this);\n+    else\n+      return -1;\n+  }\n+\n+  /**\n+   * This method returns the orientation that the JSplitPane is using.\n+   *\n+   * @return The current orientation.\n+   */\n+  public int getOrientation()\n+  {\n+    return orientation;\n+  }\n+\n+  /**\n+   * This method returns the current resize weight.\n+   *\n+   * @return The current resize weight.\n+   */\n+  public double getResizeWeight()\n+  {\n+    return resizeWeight;\n+  }\n+\n+  /**\n+   * This method returns the right component.\n+   *\n+   * @return The right component.\n+   */\n+  public Component getRightComponent()\n+  {\n+    return rightComponent;\n+  }\n+\n+  /**\n+   * This method returns the top component.\n+   *\n+   * @return The top component.\n+   */\n+  public Component getTopComponent()\n+  {\n+    return leftComponent;\n+  }\n+\n+  /**\n+   * This method returns the UI.\n+   *\n+   * @return The UI.\n+   */\n+  public SplitPaneUI getUI()\n+  {\n+    return (SplitPaneUI) ui;\n+  }\n+\n+  /**\n+   * This method returns true if the JSplitPane is using a continuousLayout.\n+   *\n+   * @return True if using a continuousLayout.\n+   */\n+  public boolean isContinuousLayout()\n+  {\n+    return continuousLayout;\n+  }\n+\n+  /**\n+   * This method returns true if the divider has one touch expandable buttons.\n+   *\n+   * @return True if one touch expandable is used.\n+   */\n+  public boolean isOneTouchExpandable()\n+  {\n+    return oneTouchExpandable;\n+  }\n+\n+  /**\n+   * This method returns true.\n+   *\n+   * @return true.\n+   */\n+  public boolean isValidateRoot()\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * This method overrides JComponent's paintChildren so the UI can be\n+   * messaged when the children have finished painting.\n+   *\n+   * @param g The Graphics object to paint with.\n+   */\n+  protected void paintChildren(Graphics g)\n+  {\n+    super.paintChildren(g);\n+    if (ui != null)\n+      ((SplitPaneUI) ui).finishedPaintingChildren(this, g);\n+  }\n+\n+  /**\n+   * This method returns a String that describes this JSplitPane. The string\n+   * is primarily used for debugging purposes.\n+   *\n+   * @return A String used for debugging purposes.\n+   */\n+  protected String paramString()\n+  {\n+    return \"JSplitPane\";\n+  }\n+\n+  /**\n+   * This method removes the given component from the JSplitPane.\n+   *\n+   * @param component The Component to remove.\n+   */\n+  public void remove(Component component)\n+  {\n+    if (component == leftComponent)\n+      leftComponent = null;\n+    else if (component == rightComponent)\n+      rightComponent = null;\n+    super.remove(component);\n+  }\n+\n+  /**\n+   * This method removes the component at the given index.\n+   *\n+   * @param index The index of the component to remove.\n+   */\n+  public void remove(int index)\n+  {\n+    Component component = getComponentAt(index);\n+    if (component == leftComponent)\n+      leftComponent = null;\n+    else if (component == rightComponent)\n+      rightComponent = null;\n+    super.remove(index);\n+  }\n+\n+  /**\n+   * This method removes all components from the JSplitPane.\n+   */\n+  public void removeAll()\n+  {\n+    leftComponent = null;\n+    rightComponent = null;\n+    super.removeAll();\n+  }\n+\n+  /**\n+   * This method resets all children of the JSplitPane to their preferred\n+   * sizes.\n+   */\n+  public void resetToPreferredSizes()\n+  {\n+    if (ui != null)\n+      ((SplitPaneUI) ui).resetToPreferredSizes(this);\n+  }\n+\n+  /**\n+   * This method sets the bottom component.\n+   *\n+   * @param comp The Component to be placed at the bottom.\n+   */\n+  public void setBottomComponent(Component comp)\n+  {\n+    if (comp != null)\n+      add(comp, BOTTOM);\n+    else\n+      add(new JButton(\"right button\"), BOTTOM);\n+  }\n+\n+  /**\n+   * This method sets the layout mode for the JSplitPane.\n+   *\n+   * @param newContinuousLayout Whether the JSplitPane is in continuousLayout\n+   *        mode.\n+   */\n+  public void setContinuousLayout(boolean newContinuousLayout)\n+  {\n+    if (newContinuousLayout != continuousLayout)\n+      {\n+\tboolean oldValue = continuousLayout;\n+\tcontinuousLayout = newContinuousLayout;\n+\tfirePropertyChange(CONTINUOUS_LAYOUT_PROPERTY, oldValue,\n+\t                   continuousLayout);\n+      }\n+  }\n+\n+  /**\n+   * This method sets the location of the divider. A value of 0 sets the\n+   * divider to the farthest left. A value of 1 sets the divider to the\n+   * farthest right.\n+   *\n+   * @param proportionalLocation A double that describes the location of the\n+   *        divider.\n+   *\n+   * @throws IllegalArgumentException DOCUMENT ME!\n+   */\n+  public void setDividerLocation(double proportionalLocation)\n+  {\n+    if (proportionalLocation > 1 || proportionalLocation < 0)\n+      throw new IllegalArgumentException(\"proportion has to be between 0 and 1.\");\n+\n+    int max = (orientation == HORIZONTAL_SPLIT) ? getWidth() : getHeight();\n+    setDividerLocation((int) (proportionalLocation * max));\n+  }\n+\n+  /**\n+   * This method sets the location of the divider.\n+   *\n+   * @param location The location of the divider.\n+   */\n+  public void setDividerLocation(int location)\n+  {\n+    if (ui != null && location != getDividerLocation())\n+      {\n+\tint oldLocation = getDividerLocation();\n+\t((SplitPaneUI) ui).setDividerLocation(this, location);\n+\tfirePropertyChange(DIVIDER_LOCATION_PROPERTY, oldLocation, location);\n+      }\n+  }\n+\n+  /**\n+   * This method sets the size of the divider.\n+   *\n+   * @param newSize The size of the divider.\n+   */\n+  public void setDividerSize(int newSize)\n+  {\n+    if (newSize != dividerSize)\n+      {\n+\tint oldSize = dividerSize;\n+\tdividerSize = newSize;\n+\tfirePropertyChange(DIVIDER_SIZE_PROPERTY, oldSize, dividerSize);\n+      }\n+  }\n+\n+  // This doesn't appear to do anything when set from user side.\n+  // so it probably is only used from the UI side to change the\n+  // lastDividerLocation var.\n+\n+  /**\n+   * This method sets the last location of the divider.\n+   *\n+   * @param newLastLocation The last location of the divider.\n+   */\n+  public void setLastDividerLocation(int newLastLocation)\n+  {\n+    if (newLastLocation != lastDividerLocation)\n+      {\n+\tint oldValue = lastDividerLocation;\n+\tlastDividerLocation = newLastLocation;\n+\tfirePropertyChange(LAST_DIVIDER_LOCATION_PROPERTY, oldValue,\n+\t                   lastDividerLocation);\n+      }\n+  }\n+\n+  /**\n+   * This method sets the left component.\n+   *\n+   * @param comp The left component.\n+   */\n+  public void setLeftComponent(Component comp)\n+  {\n+    if (comp != null)\n+      add(comp, LEFT);\n+    else\n+      add(new JButton(\"left button\"), LEFT);\n+  }\n+\n+  /**\n+   * This method sets whether the divider has one touch expandable buttons.\n+   * The one touch expandable buttons can expand the size of either component\n+   * to the maximum allowed size.\n+   *\n+   * @param newValue Whether the divider will have one touch expandable\n+   *        buttons.\n+   */\n+  public void setOneTouchExpandable(boolean newValue)\n+  {\n+    if (newValue != oneTouchExpandable)\n+      {\n+\tboolean oldValue = oneTouchExpandable;\n+\toneTouchExpandable = newValue;\n+\tfirePropertyChange(ONE_TOUCH_EXPANDABLE_PROPERTY, oldValue,\n+\t                   oneTouchExpandable);\n+      }\n+  }\n+\n+  /**\n+   * This method sets the orientation of the JSplitPane.\n+   *\n+   * @param orientation The orientation of the JSplitPane.\n+   *\n+   * @throws IllegalArgumentException DOCUMENT ME!\n+   */\n+  public void setOrientation(int orientation)\n+  {\n+    if (orientation != HORIZONTAL_SPLIT && orientation != VERTICAL_SPLIT)\n+      throw new IllegalArgumentException(\"orientation must be one of VERTICAL_SPLIT, HORIZONTAL_SPLIT\");\n+    if (orientation != this.orientation)\n+      {\n+\tint oldOrientation = this.orientation;\n+\tthis.orientation = orientation;\n+\tfirePropertyChange(ORIENTATION_PROPERTY, oldOrientation,\n+\t                   this.orientation);\n+      }\n+  }\n+\n+  /**\n+   * This method determines how extra space will be distributed among the left\n+   * and right components. A value of 0 will allocate all extra space to the\n+   * right component. A value of 1 indicates that all extra space will go to\n+   * the left component. A value in between 1 and 0 will split the space\n+   * accordingly.\n+   *\n+   * @param value The resize weight.\n+   */\n+  public void setResizeWeight(double value)\n+  {\n+    resizeWeight = value;\n+  }\n+\n+  /**\n+   * This method sets the right component.\n+   *\n+   * @param comp The right component.\n+   */\n+  public void setRightComponent(Component comp)\n+  {\n+    if (comp != null)\n+      add(comp, RIGHT);\n+    else\n+\tadd(new JButton(\"right button\"), RIGHT);\n+  }\n+\n+  /**\n+   * This method sets the top component.\n+   *\n+   * @param comp The top component.\n+   */\n+  public void setTopComponent(Component comp)\n+  {\n+    if (comp != null)\n+      add(comp, TOP);\n+    else\n+      add(new JButton(\"left button\"), TOP);\n+  }\n+\n+  /**\n+   * This method sets the UI used by the JSplitPane.\n+   *\n+   * @param ui The UI to use.\n+   */\n+  public void setUI(SplitPaneUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  /**\n+   * This method resets the UI to the one specified by the current Look and\n+   * Feel.\n+   */\n+  public void updateUI()\n+  {\n+    setUI((SplitPaneUI) UIManager.getUI(this));\n+    invalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * This method returns a string identifier to determine which UI class it\n+   * needs.\n+   *\n+   * @return A string that identifies it's UI class.\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"SplitPaneUI\";\n+  }\n+}"}, {"sha": "b164dc7904513bb48c5a70371b59a1b63b9d884a", "filename": "libjava/javax/swing/JViewport.java", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJViewport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJViewport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJViewport.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -114,7 +114,13 @@ public class JViewport extends JComponent\n    *\n    * @see #toViewCoordinates\n    */\n-  Dimension viewExtent;\n+  Dimension extentSize;\n+\n+  /**\n+   * The width and height of the view in its own coordinate space.\n+   */\n+\n+  Dimension viewSize;\n \n   Point lastPaintPosition;\n \n@@ -124,17 +130,35 @@ public JViewport()\n     updateUI();\n   }\n \n-  public Dimension getViewSize()\n+  public Dimension getExtentSize()\n   {\n-    if (viewExtent == null)\n+    if (extentSize == null)\n       return getPreferredSize();\n     else\n-      return viewExtent;\n+      return extentSize;\n+  }\n+\n+  public void setExtentSize(Dimension newSize)\n+  {\n+    extentSize = newSize;\n+    fireStateChanged();\n+  }\n+\n+  public Dimension getViewSize()\n+  {\n+    if (viewSize == null)\n+      return getView().getPreferredSize();\n+    else\n+      return viewSize;\n   }\n \n+\n   public void setViewSize(Dimension newSize)\n   {\n-    viewExtent = newSize;\n+    viewSize = newSize;\n+    Component view = getView();\n+    if (view != null)\n+      view.setSize(newSize);\n     fireStateChanged();\n   }\n \n@@ -166,7 +190,7 @@ public void setViewPosition(Point p)\n   public Rectangle getViewRect()\n   {\n     return new Rectangle(getViewPosition(), \n-                         getViewSize());\n+                         getExtentSize());\n   }\n \n   public boolean isBackingStoreEnabled()\n@@ -207,7 +231,24 @@ public void setView(Component v)\n     add(v);\n     fireStateChanged();\n   }\n-    \n+\n+  public void revalidate()\n+  {\n+    fireStateChanged();\n+    super.revalidate();\n+  }\n+\n+  public void reshape(int x, int y, int w, int h)\n+  {\n+    boolean changed = \n+      (x != getX()) \n+      || (y != getY()) \n+      || (w != getWidth())\n+      || (h != getHeight());\n+    super.reshape(x, y, w, h);\n+    if (changed)\n+      fireStateChanged();\n+  }\n     \n   public void addImpl(Component comp, Object constraints, int index)\n   {"}, {"sha": "2c3c27f3703d1513346c0e8f0ee7028c350d6f65", "filename": "libjava/javax/swing/JWindow.java", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJWindow.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FJWindow.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJWindow.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -58,7 +58,7 @@\n  *\n  * @author Ronald Veldema (rveldema@cs.vu.nl)\n  */\n-public class JWindow extends Window implements Accessible\n+public class JWindow extends Window implements Accessible, RootPaneContainer\n {\n     public final static int HIDE_ON_CLOSE        = 0;\n     public final static int EXIT_ON_CLOSE        = 1;\n@@ -79,8 +79,8 @@ public class JWindow extends Window implements Accessible\n      *************/\n \n     public JWindow()\n-    {\n-      this(null);\n+    {      \n+     \tsuper(); \n     }\n \n     // huuu ?\n@@ -124,20 +124,20 @@ void setJMenuBar(JMenuBar menubar)\n   public  void setLayout(LayoutManager manager)\n   {    super.setLayout(manager);  }\n \n-    void setLayeredPane(JLayeredPane layeredPane) \n+    public void setLayeredPane(JLayeredPane layeredPane) \n     {   getRootPane().setLayeredPane(layeredPane);   }\n   \n-    JLayeredPane getLayeredPane()\n+    public JLayeredPane getLayeredPane()\n     {   return getRootPane().getLayeredPane();     }\n   \n-    JRootPane getRootPane()\n+    public JRootPane getRootPane()\n     {\n \tif (rootPane == null)\n \t    setRootPane(createRootPane());\n \treturn rootPane;          \n     }\n \n-    void setRootPane(JRootPane root)\n+    public void setRootPane(JRootPane root)\n     {\n \tif (rootPane != null)\n \t    remove(rootPane);\n@@ -146,19 +146,19 @@ void setRootPane(JRootPane root)\n \tadd(rootPane, BorderLayout.CENTER);\n     }\n \n-    JRootPane createRootPane()\n+    public JRootPane createRootPane()\n     {   return new JRootPane();    }\n \n-    Container getContentPane()\n+    public Container getContentPane()\n     {    return getRootPane().getContentPane();     }\n \n-    void setContentPane(Container contentPane)\n+    public void setContentPane(Container contentPane)\n     {    getRootPane().setContentPane(contentPane);    }\n   \n-    Component getGlassPane()\n+    public Component getGlassPane()\n     {    return getRootPane().getGlassPane();   }\n   \n-    void setGlassPane(Component glassPane)\n+    public void setGlassPane(Component glassPane)\n     {   getRootPane().setGlassPane(glassPane);   }\n \n     "}, {"sha": "d722b0b727544293a8e47be1c2ce0fe8500ecc1c", "filename": "libjava/javax/swing/MenuSelectionManager.java", "status": "modified", "additions": 223, "deletions": 1, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FMenuSelectionManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FMenuSelectionManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FMenuSelectionManager.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -1,5 +1,5 @@\n /* MenuSelectionManager.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,6 +38,15 @@\n \n package javax.swing;\n \n+import java.awt.Component;\n+import java.awt.Point;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n+\n+import java.util.Vector;\n+\n+import javax.swing.JMenu;\n+import javax.swing.JMenuItem;\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n import javax.swing.event.EventListenerList;\n@@ -48,6 +57,10 @@\n   \n   protected EventListenerList listenerList = new EventListenerList ();\n \n+  private static final MenuSelectionManager manager = new MenuSelectionManager();\n+  \n+  private Vector selection = new Vector();\n+  \n   protected void fireStateChanged ()\n   {\n     ChangeListener[] listeners = getChangeListeners ();\n@@ -73,4 +86,213 @@ public ChangeListener[] getChangeListeners ()\n   {\n     return (ChangeListener[]) listenerList.getListeners (ChangeListener.class);\n   }\n+  \n+  /**\n+   * Unselects all the menu elements on the selection path \n+   */\n+  public void clearSelectedPath ()\n+  {\n+    for (int i = 0; i < selection.size (); i++)\n+      ((MenuElement) selection.get (i)).menuSelectionChanged (false);\n+\n+    selection.clear ();\n+  }\n+  \n+  public Component componentForPoint (Component source, Point sourcePoint)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+\n+  /**\n+   * Returns shared instance of MenuSelection Manager\n+   *\n+   * @return default Manager\n+   */\n+  public static MenuSelectionManager defaultManager ()\n+  {\n+    return manager;\n+  }\n+\n+  /**\n+   * Returns path representing current menu selection\n+   *\n+   * @return Current selection path\n+   */\n+  public MenuElement[] getSelectedPath ()\n+  {\n+    MenuElement[] path = new MenuElement[selection.size ()];\n+\n+    for (int i = 0; i < path.length; i++)\n+      path[i] = (MenuElement) selection.get (i);\n+\n+    return path;\n+  }\n+\n+  /**\n+   * Returns true if specified component is part of current menu\n+   * heirarchy and false otherwise\n+   *\n+   * @param c Component for which to check\n+   * @return True if specified component is part of current menu\n+   */\n+  boolean isComponentPartOfCurrentMenu (Component c)\n+  {\n+    MenuElement[] subElements;\n+    for (int i = 0; i < selection.size (); i++)\n+      {\n+        subElements = ((MenuElement) selection.get (i)).getSubElements ();\n+        for (int j = 0; j < subElements.length; j++)\n+          {\n+            if ((subElements[j].getComponent ()).equals (c))\n+              return true;\n+          }\n+      }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param e DOCUMENT ME!\n+   */\n+  public void processKeyEvent (KeyEvent e)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+\n+  /**\n+   * Forwards given mouse event to all of the source subcomponents.\n+   *\n+   * @param event Mouse event\n+   */\n+  public void processMouseEvent (MouseEvent event)\n+  {\n+    \n+    Component c = ((MenuElement) event.getSource ()).getComponent ();\n+    if (selection.size () == 0)\n+      {\n+        ((MenuElement) event.getSource ()).processMouseEvent (event,\n+                                                              getPath (c),\n+                                                              manager);\n+        return;\n+      }\n+\n+    // find the index of the source component in the current menu hierarchy\n+    int i = 0;\n+    for (i = 0; i < selection.size (); i++)\n+      {\n+        MenuElement me = (MenuElement) selection.get (i);\n+        if (me.getComponent ().equals (c))\n+          break;\n+      }\n+\n+    // Forward event to all subcomponents of the source \n+    Component subComp;\n+    for (int j = i; j < selection.size (); j++)\n+      {\n+         subComp = ((MenuElement)selection.get (j)).getComponent ();\n+        ((MenuElement) selection.get (j)).processMouseEvent (event,\n+                                                             getPath (subComp),\n+                                                             manager);\n+      }\n+  }\n+\n+  /**\n+   * Sets menu selection to the specified path\n+   *\n+   * @param path new selection path\n+   */\n+  public void setSelectedPath (MenuElement[] path)\n+  {\n+    if (path == null)\n+      {\n+        clearSelectedPath ();\n+        return;\n+      }\n+\n+    int i;\n+    int minSize = path.length; // size of the smaller path. \n+\n+    if (path.length > selection.size ())\n+      {\n+        // if new selected path contains more elements then current\n+        // selection then first add all elements at \n+        // the indexes > selection.size \n+\t\n+        for (i = selection.size (); i < path.length; i++)\n+          {\n+            selection.add (path[i]);\n+            path[i].menuSelectionChanged (true);\n+          }\n+\n+        minSize = selection.size ();\n+      }\n+\n+    else if (path.length < selection.size ())\n+      {\n+        // if new selected path contains less elements then current \n+        // selection then first remove all elements from the selection\n+        // at the indexes > path.length\n+\t\n+        for (i = selection.size () - 1; i >= path.length; i--)\n+          {\n+            ((MenuElement) selection.get (i)).menuSelectionChanged (false);\n+            selection.remove (i);\n+          }\n+\n+        minSize = path.length;\n+      }\n+\n+    // Now compare elements in new and current selection path at the \n+    // same location and adjust selection until \n+    // same menu elements will be encountered at the\n+    // same index in both current and new selection path.\n+    \n+    MenuElement oldSelection;\n+\n+    for (i = minSize - 1; i >= 0; i--)\n+      {\n+        oldSelection = (MenuElement) selection.get (i);\n+\n+        if (path[i].equals (oldSelection))\n+          break;\n+\n+        oldSelection.menuSelectionChanged (false);\n+        path[i].menuSelectionChanged (true);\n+        selection.setElementAt (path[i], i);\n+      }\n+  }\n+\n+\n+  /**\n+   * Returns path to the specified component\n+   *\n+   * @param c component for which to find path for\n+   *\n+   * @return path to the specified component\n+   */\n+  private MenuElement[] getPath (Component c)\n+  {\n+    Vector path = new Vector();\n+    path.add (c);\n+\n+    Component parent = c.getParent ();\n+\n+    while (parent instanceof JMenu \n+           || parent instanceof JPopupMenu \n+           || parent instanceof JMenuItem \n+           || parent instanceof JMenuBar)\n+      {\n+        path.add (parent);\n+        parent = parent.getParent ();\n+      }\n+\n+    MenuElement[] pathArray = new MenuElement[path.size ()];\n+\n+    for (int i = 0; i < path.size (); i++)\n+      pathArray[i] = (MenuElement) path.get (path.size () - i - 1);\n+    return pathArray;\n+  }\n+  \n } // class MenuSelectionManager"}, {"sha": "ace19cb27a5e0bbaea5f68f2123bc72f6050adc3", "filename": "libjava/javax/swing/RepaintManager.java", "status": "modified", "additions": 482, "deletions": 234, "changes": 716, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FRepaintManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FRepaintManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FRepaintManager.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -35,248 +35,496 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.awt.Component;\n import java.awt.Dimension;\n import java.awt.Image;\n import java.awt.Rectangle;\n+import java.util.AbstractMap;\n+import java.util.Enumeration;\n import java.util.Hashtable;\n+import java.util.HashMap;\n+import java.util.Iterator;\n import java.util.Vector;\n \n+\n /**\n- * RepaintManager\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * <p>The repaint manager holds a set of dirty regions, invalid components,\n+ * and a double buffer surface.  The dirty regions and invalid components\n+ * are used to coalesce multiple revalidate() and repaint() calls in the\n+ * component tree into larger groups to be refreshed \"all at once\"; the\n+ * double buffer surface is used by root components to paint\n+ * themselves.</p>\n+ *\n+ * <p>In general, painting is very confusing in swing. see <a\n+ * href=\"http://java.sun.com/products/jfc/tsc/articles/painting/index.html\">this\n+ * document</a> for more details.</p>\n+ *\n+ * @author Graydon Hoare (graydon@redhat.com)\n  */\n-public class RepaintManager {\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * dirtyComponents\n-\t */\n-\tHashtable dirtyComponents;\n-\n-\t/**\n-\t * tmpDirtyComponents\n-\t */\n-\tHashtable tmpDirtyComponents;\n-\n-\t/**\n-\t * invalidComponents\n-\t */\n-\tVector invalidComponents;\n-\n-\t/**\n-\t * doubleBufferingEnabled\n-\t */\n-\tboolean doubleBufferingEnabled;\n-\n-\t/**\n-\t * doubleBuffer\n-\t */\n-\tImage doubleBuffer;\n-\n-\t/**\n-\t * doubleBufferSize\n-\t */\n-\tDimension doubleBufferSize;\n-\n-\t/**\n-\t * doubleBufferMaxSize\n-\t */\n-\tprivate Dimension doubleBufferMaxSize;\n-\n-\t/**\n-\t * resetDoubleBuffer\n-\t */\n-\tprivate boolean resetDoubleBuffer;\n-\n-\t/**\n-\t * repaintManagerKey\n-\t */\n-\tprivate static final Object repaintManagerKey = null; // TODO\n-\n-\t/**\n-\t * tmp\n-\t */\n-\tRectangle tmp;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor RepaintManager\n-\t */\n-\tpublic RepaintManager() {\n-\t\t// TODO\n-\t} // RepaintManager()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * toString\n-\t * @returns String\n-\t */\n-\tpublic synchronized String toString() {\n-\t\treturn null; // TODO\n-\t} // toString()\n-\n-\t/**\n-\t * currentManager\n-\t * @param component TODO\n-\t * @returns RepaintManager\n-\t */\n-\tpublic static RepaintManager currentManager(Component component) {\n-\t\treturn null; // TODO\n-\t} // currentManager()\n-\n-\t/**\n-\t * currentManager\n-\t * @param component TODO\n-\t * @returns RepaintManager\n-\t */\n-\tpublic static RepaintManager currentManager(JComponent component) {\n-\t\treturn null; // TODO\n-\t} // currentManager()\n-\n-\t/**\n-\t * setCurrentManager\n-\t * @param manager TODO\n-\t */\n-\tpublic static void setCurrentManager(RepaintManager manager) {\n-\t\t// TODO\n-\t} // setCurrentManager()\n-\n-\t/**\n-\t * addInvalidComponent\n-\t * @param component TODO\n-\t */\n-\tpublic synchronized void addInvalidComponent(JComponent component) {\n-\t\t// TODO\n-\t} // addInvalidComponent()\n-\n-\t/**\n-\t * removeInvalidComponent\n-\t * @param component TODO\n-\t */\n-\tpublic synchronized void removeInvalidComponent(JComponent component) {\n-\t\t// TODO\n-\t} // removeInvalidComponent()\n-\n-\t/**\n-\t * addDirtyRegion\n-\t * @param component TODO\n-\t * @param x TODO\n-\t * @param y TODO\n-\t * @param w TODO\n-\t * @param h TODO\n-\t */\n-\tpublic synchronized void addDirtyRegion(JComponent component, int x,\n-\t\t\tint y, int w, int h) {\n-\t\t// TODO\n-\t} // addDirtyRegion()\n-\n-\t/**\n-\t * getDirtyRegion\n-\t * @param component TODO\n-\t * @returns Rectangle\n-\t */\n-\tpublic Rectangle getDirtyRegion(JComponent component) {\n-\t\treturn null; // TODO\n-\t} // getDirtyRegion()\n-\n-\t/**\n-\t * markCompletelyDirty\n-\t * @param component TODO\n-\t */\n-\tpublic void markCompletelyDirty(JComponent component) {\n-\t\t// TODO\n-\t} // markCompletelyDirty()\n-\n-\t/**\n-\t * markCompletelyClean\n-\t * @param component TODO\n-\t */\n-\tpublic void markCompletelyClean(JComponent component) {\n-\t\t// TODO\n-\t} // markCompletelyClean()\n-\n-\t/**\n-\t * isCompletelyDirty\n-\t * @param component TODO\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isCompletelyDirty(JComponent component) {\n-\t\treturn false; // TODO\n-\t} // isCompletelyDirty()\n-\n-\t/**\n-\t * validateInvalidComponents\n-\t */\n-\tpublic void validateInvalidComponents() {\n-\t\t// TODO\n-\t} // validateInvalidComponents()\n-\n-\t/**\n-\t * paintDirtyRegions\n-\t */\n-\tpublic void paintDirtyRegions() {\n-\t\t// TODO\n-\t} // paintDirtyRegions()\n-\n-\t/**\n-\t * getOffscreenBuffer\n-\t * @param component TODO\n-\t * @param proposedWidth TODO\n-\t * @param proposedHeight TODO\n-\t * @returns Image\n-\t */\n-\tpublic Image getOffscreenBuffer(Component component,\n-\t\t\tint proposedWidth, int proposedHeight) {\n-\t\treturn null; // TODO\n-\t} // getOffscreenBuffer()\n-\n-\t/**\n-\t * getDoubleBufferMaximumSize\n-\t * @returns Dimension\n-\t */\n-\tpublic Dimension getDoubleBufferMaximumSize() {\n-\t\treturn null; // TODO\n-\t} // getDoubleBufferMaximumSize()\n-\n-\t/**\n-\t * setDoubleBufferMaximumSize\n-\t * @param size TODO\n-\t */\n-\tpublic void setDoubleBufferMaximumSize(Dimension size) {\n-\t\t// TODO\n-\t} // setDoubleBufferMaximumSize()\n-\n-\t/**\n-\t * setDoubleBufferingEnabled\n-\t * @param buffer TODO\n-\t */\n-\tpublic void setDoubleBufferingEnabled(boolean buffer) {\n-\t\t// TODO\n-\t} // setDoubleBufferingEnabled()\n-\n-\t/**\n-\t * isDoubleBufferingEnabled\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isDoubleBufferingEnabled() {\n-\t\treturn false; // TODO\n-\t} // isDoubleBufferingEnabled()\n-\n-\n-} // RepaintManager\n+public class RepaintManager\n+{\n+\n+  /**\n+   * <p>A helper class which is placed into the system event queue at\n+   * various times in order to facilitate repainting and layout. There is\n+   * typically only one of these objects active at any time. When the\n+   * {@link RepaintManager} is told to queue a repaint, it checks to see if\n+   * a {@link RepaintWorker} is \"live\" in the system event queue, and if\n+   * not it inserts one using {@link SwingUtilities.invokeLater}.</p>\n+   *\n+   * <p>When the {@link RepaintWorker} comes to the head of the system\n+   * event queue, its {@link RepaintWorker#run} method is executed by the\n+   * swing paint thread, which revalidates all invalid components and\n+   * repaints any damage in the swing scene.</p>\n+   */\n+\n+  protected class RepaintWorker\n+    implements Runnable\n+  {\n+    boolean live;\n+    public RepaintWorker()\n+    {\n+      live = false;\n+    }\n+    public synchronized void setLive(boolean b) \n+    {\n+      live = b;\n+    }\n+    public synchronized boolean isLive()\n+    {\n+      return live;\n+    }\n+    public void run()\n+    {\n+      RepaintManager rm = RepaintManager.globalManager;\n+      setLive(false);\n+      rm.validateInvalidComponents();\n+      rm.paintDirtyRegions();\n+    }\n+  }\n+\n+  \n+  /** \n+   * A table storing the dirty regions of components.  The keys of this\n+   * table are components, the values are rectangles. Each component maps\n+   * to exactly one rectangle.  When more regions are marked as dirty on a\n+   * component, they are union'ed with the existing rectangle.\n+   *\n+   * @see #addDirtyRegion\n+   * @see #getDirtyRegion\n+   * @see #isCompletelyDirty\n+   * @see #markCompletelyClean\n+   * @see #markCompletelyDirty\n+   */\n+  Hashtable dirtyComponents;\n+\n+  /**\n+   * A single, shared instance of the helper class. Any methods which mark\n+   * components as invalid or dirty eventually activate this instance. It\n+   * is added to the event queue if it is not already active, otherwise\n+   * reused.\n+   *\n+   * @see #addDirtyRegion\n+   * @see #addInvalidComponent\n+   */\n+  RepaintWorker repaintWorker;\n+\n+  /** \n+   * The set of components which need revalidation, in the \"layout\" sense.\n+   * There is no additional information about \"what kind of layout\" they\n+   * need (as there is with dirty regions), so it is just a vector rather\n+   * than a table.\n+   *\n+   * @see #addInvalidComponent\n+   * @see #removeInvalidComponent\n+   * @see #validateInvalidComponents\n+   */\n+  Vector invalidComponents;\n+\n+  /** \n+   * Whether or not double buffering is enabled on this repaint\n+   * manager. This is merely a hint to clients; the RepaintManager will\n+   * always return an offscreen buffer when one is requested.\n+   * \n+   * @see #getDoubleBufferingEnabled\n+   * @see #setDoubleBufferingEnabled\n+   */\n+  boolean doubleBufferingEnabled;\n+\n+  /** \n+   * The current offscreen buffer. This is reused for all requests for\n+   * offscreen drawing buffers. It grows as necessary, up to {@link\n+   * #doubleBufferMaximumSize}, but there is only one shared instance.\n+   *\n+   * @see #getOffscreenBuffer\n+   * @see #doubleBufferMaximumSize\n+   */\n+  Image doubleBuffer;\n+\n+  /**\n+   * The maximum width and height to allocate as a double buffer. Requests\n+   * beyond this size are ignored.\n+   *\n+   * @see #paintDirtyRegions\n+   * @see #getDoubleBufferMaximumSize\n+   * @see #setDoubleBufferMaximumSize\n+   */\n+  Dimension doubleBufferMaximumSize;\n+\n+\n+  /**\n+   * The global, shared RepaintManager instance. This is reused for all\n+   * components in all windows.\n+   *\n+   * @see #currentManager\n+   * @see #setCurrentManager\n+   */\n+  private static RepaintManager globalManager;\n+\n+  /**\n+   * Create a new RepaintManager object.\n+   */\n+  public RepaintManager()\n+  {\n+    dirtyComponents = new Hashtable();\n+    invalidComponents = new Vector();\n+    repaintWorker = new RepaintWorker();\n+    doubleBufferMaximumSize = new Dimension(2000,2000);\n+    doubleBufferingEnabled = true;\n+  }\n+\n+  /**\n+   * Get the value of the shared {@link #globalManager} instance, possibly\n+   * returning a special manager associated with the specified\n+   * component. The default implementaiton ignores the component parameter.\n+   *\n+   * @param component A component to look up the manager of\n+   *\n+   * @return The current repaint manager\n+   *\n+   * @see #setCurrentManager\n+   */\n+  public static RepaintManager currentManager(Component component)\n+  {\n+    if (globalManager == null)\n+      globalManager = new RepaintManager();\n+    return globalManager;\n+  }\n+\n+  /**\n+   * Get the value of the shared {@link #globalManager} instance, possibly\n+   * returning a special manager associated with the specified\n+   * component. The default implementaiton ignores the component parameter.\n+   *\n+   * @param component A component to look up the manager of\n+   *\n+   * @return The current repaint manager\n+   *\n+   * @see #setCurrentManager\n+   */\n+  public static RepaintManager currentManager(JComponent component)\n+  {\n+    return currentManager((Component)component);\n+  }\n+\n+  /**\n+   * Set the value of the shared {@link #globalManager} instance.\n+   *\n+   * @param manager The new value of the shared instance\n+   *\n+   * @see #currentManager\n+   */\n+  public static void setCurrentManager(RepaintManager manager)\n+  {\n+    globalManager = manager;\n+  }\n+\n+  /**\n+   * Add a component to the {@link #invalidComponents} vector. If the\n+   * {@link #repaintWorker} class is not active, insert it in the system\n+   * event queue.\n+   *\n+   * @param component The component to add\n+   *\n+   * @see #removeInvalidComponent\n+   */\n+  public synchronized void addInvalidComponent(JComponent component)\n+  {\n+    while ((component.getParent() != null)\n+           && (component.getParent() instanceof JComponent)\n+           && (component.isValidateRoot()))\n+      component = (JComponent) component.getParent();\n+    \n+    if (invalidComponents.contains(component))\n+      return;\n+\n+    invalidComponents.add(component);\n+    component.invalidate();\n+    \n+    if (! repaintWorker.isLive())\n+      {\n+        repaintWorker.setLive(true);\n+        SwingUtilities.invokeLater(repaintWorker);\n+      }\n+  }\n+\n+  /**\n+   * Remove a component from the {@link #invalidComponents} vector.\n+   *\n+   * @param component The component to remove\n+   *\n+   * @see #addInvalidComponent\n+   */\n+  public synchronized void removeInvalidComponent(JComponent component)\n+  {\n+    invalidComponents.removeElement(component);\n+  }\n+\n+  /**\n+   * Add a region to the set of dirty regions for a specified component.\n+   * This involves union'ing the new region with any existing dirty region\n+   * associated with the component. If the {@link #repaintWorker} class\n+   * is not active, insert it in the system event queue.\n+   *\n+   * @param component The component to add a dirty region for\n+   * @param x The left x coordinate of the new dirty region\n+   * @param y The top y coordinate of the new dirty region\n+   * @param w The width of the new dirty region\n+   * @param h The height of the new dirty region\n+   *\n+   * @see #addDirtyRegion\n+   * @see #getDirtyRegion\n+   * @see #isCompletelyDirty\n+   * @see #markCompletelyClean\n+   * @see #markCompletelyDirty\n+   */\n+  public synchronized void addDirtyRegion(JComponent component, int x, int y,\n+                                          int w, int h)\n+  {\n+    Rectangle r = new Rectangle(x, y, w, h);\n+    if (dirtyComponents.containsKey(component))\n+      r = r.union((Rectangle)dirtyComponents.get(component));\n+    dirtyComponents.put(component, r);\n+    if (! repaintWorker.isLive())\n+      {\n+        repaintWorker.setLive(true);\n+        SwingUtilities.invokeLater(repaintWorker);\n+      }\n+  }\n+  \n+  /**\n+   * Get the dirty region associated with a component, or <code>null</code>\n+   * if the component has no dirty region.\n+   *\n+   * @param component The component to get the dirty region of\n+   *\n+   * @return The dirty region of the component\n+   *\n+   * @see #dirtyComponents\n+   * @see #addDirtyRegion\n+   * @see #isCompletelyDirty\n+   * @see #markCompletelyClean\n+   * @see #markCompletelyDirty\n+   */\n+  public Rectangle getDirtyRegion(JComponent component)\n+  {\n+    return (Rectangle) dirtyComponents.get(component);\n+  }\n+  \n+  /**\n+   * Mark a component as dirty over its entire bounds.\n+   *\n+   * @param component The component to mark as dirty\n+   *\n+   * @see #dirtyComponents\n+   * @see #addDirtyRegion\n+   * @see #getDirtyRegion\n+   * @see #isCompletelyDirty\n+   * @see #markCompletelyClean\n+   */\n+  public void markCompletelyDirty(JComponent component)\n+  {\n+    Rectangle r = component.getBounds();\n+    addDirtyRegion(component, r.x, r.y, r.width, r.height);\n+  }\n+\n+  /**\n+   * Remove all dirty regions for a specified component\n+   *\n+   * @param component The component to mark as clean\n+   *\n+   * @see #dirtyComponents\n+   * @see #addDirtyRegion\n+   * @see #getDirtyRegion\n+   * @see #isCompletelyDirty\n+   * @see #markCompletelyDirty\n+   */\n+  public void markCompletelyClean(JComponent component)\n+  {\n+    dirtyComponents.remove(component);\n+  }\n+\n+  /**\n+   * Return <code>true</code> if the specified component is completely\n+   * contained within its dirty region, otherwise <code>false</code>\n+   *\n+   * @param component The component to check for complete dirtyness\n+   *\n+   * @return Whether the component is completely dirty\n+   *\n+   * @see #dirtyComponents\n+   * @see #addDirtyRegion\n+   * @see #getDirtyRegion\n+   * @see #isCompletelyDirty\n+   * @see #markCompletelyClean\n+   */\n+  public boolean isCompletelyDirty(JComponent component)\n+  {\n+    Rectangle dirty = (Rectangle) dirtyComponents.get(component);\n+    if (dirty == null)\n+      return false;\n+    Rectangle r = component.getBounds();\n+    if (r == null)\n+      return true;\n+    return dirty.contains(r);\n+  }\n+\n+  /**\n+   * Validate all components which have been marked invalid in the {@link\n+   * #invalidComponents} vector.\n+   */\n+  public void validateInvalidComponents()\n+  {\n+    for (Enumeration e = invalidComponents.elements(); e.hasMoreElements(); )\n+      {\n+        JComponent comp = (JComponent) e.nextElement();\n+        if (! (comp.isVisible() && comp.isShowing()))\n+          continue;\n+        comp.validate();\n+      }\n+    invalidComponents.clear();\n+  }\n+\n+  /**\n+   * Repaint all regions of all components which have been marked dirty in\n+   * the {@link #dirtyComponents} table.\n+   */\n+  public void paintDirtyRegions()\n+  {\n+    // step 1: pull out roots and calculate spanning damage\n+\n+    HashMap roots = new HashMap();\n+    for (Enumeration e = dirtyComponents.keys(); e.hasMoreElements(); )\n+      {\n+        JComponent comp = (JComponent) e.nextElement();\n+        if (! (comp.isVisible() && comp.isShowing()))\n+          continue;\n+        Rectangle damaged = getDirtyRegion(comp);\n+        if (damaged.width == 0 || damaged.height == 0)\n+          continue;\n+        JRootPane root = comp.getRootPane();\n+        Rectangle rootDamage = SwingUtilities.convertRectangle(comp, damaged, root);\n+        if (! roots.containsKey(root))\n+          {\n+            roots.put(root, rootDamage);\n+          }\n+        else\n+          {\n+            roots.put(root, ((Rectangle)roots.get(root)).union(rootDamage));\n+          }\n+      }\n+    dirtyComponents.clear();\n+\n+    // step 2: paint those roots\n+    Iterator i = roots.iterator(AbstractMap.ENTRIES);\n+    while(i.hasNext())\n+      {\n+        AbstractMap.BasicMapEntry ent = (AbstractMap.BasicMapEntry) i.next();\n+        JRootPane root = (JRootPane) ent.getKey();\n+        Rectangle rect = (Rectangle) ent.getValue();\n+        root.paintImmediately(rect);                \n+      }\n+  }\n+\n+  /**\n+   * Get an offscreen buffer for painting a component's image. This image\n+   * may be smaller than the proposed dimensions, depending on the value of\n+   * the {@link #doubleBufferMaximumSize} property.\n+   *\n+   * @param component The component to return an offscreen buffer for\n+   * @param proposedWidth The proposed width of the offscreen buffer\n+   * @param proposedHeight The proposed height of the offscreen buffer\n+   *\n+   * @return A shared offscreen buffer for painting\n+   *\n+   * @see #doubleBuffer\n+   */\n+  public Image getOffscreenBuffer(Component component, int proposedWidth,\n+                                  int proposedHeight)\n+  {\n+    if (doubleBuffer == null \n+        || (((doubleBuffer.getWidth(null) < proposedWidth) \n+             || (doubleBuffer.getHeight(null) < proposedHeight))\n+            && (proposedWidth < doubleBufferMaximumSize.width)\n+            && (proposedHeight < doubleBufferMaximumSize.height)))\n+      {\n+        doubleBuffer = component.createImage(proposedWidth, proposedHeight);\n+      }\n+    return doubleBuffer;\n+  }\n+\n+  /**\n+   * Get the value of the {@link #doubleBufferMaximumSize} property.\n+   *\n+   * @return The current value of the property\n+   *\n+   * @see #setDoubleBufferMaximumSize\n+   */\n+  public Dimension getDoubleBufferMaximumSize()\n+  {\n+    return doubleBufferMaximumSize;\n+  }\n+\n+  /**\n+   * Set the value of the {@link #doubleBufferMaximumSize} property.\n+   *\n+   * @param size The new value of the property\n+   *\n+   * @see #getDoubleBufferMaximumSize\n+   */\n+  public void setDoubleBufferMaximumSize(Dimension size)\n+  {\n+    doubleBufferMaximumSize = size;\n+  }\n+\n+  /**\n+   * Set the value of the {@link #doubleBufferingEnabled} property.\n+   *\n+   * @param buffer The new value of the property\n+   *\n+   * @see #getDoubleBufferingEnabled\n+   */\n+  public void setDoubleBufferingEnabled(boolean buffer)\n+  {\n+    doubleBufferingEnabled = buffer;\n+  }\n+\n+  /**\n+   * Get the value of the {@link #doubleBufferingEnabled} property.\n+   *\n+   * @return The current value of the property\n+   *\n+   * @see #setDoubleBufferingEnabled\n+   */\n+  public boolean isDoubleBufferingEnabled()\n+  {\n+    return doubleBufferingEnabled;\n+  }\n+  \n+  public String toString()\n+  {\n+    return \"RepaintManager\";\n+  }\n+}"}, {"sha": "16b6c0fae33df94a53929c7c8a1fd7446ad1f5c6", "filename": "libjava/javax/swing/ScrollPaneLayout.java", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FScrollPaneLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FScrollPaneLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FScrollPaneLayout.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -227,7 +227,17 @@ public Dimension preferredLayoutSize(Container parent)\n \n             if (horizontalScrollBar != null)\n               horizontalScrollBarSize.setSize(horizontalScrollBar.getPreferredSize());\n-            \n+\n+            /*\n+            System.err.println(\"widths: [vp=\" + viewportSize.width +\n+                               \", h=\" + columnHeaderSize.width +\n+                               \", sc=\" + horizontalScrollBarSize.width + \"]\");\n+\n+            System.err.println(\"heights: [vp=\" + viewportSize.height +\n+                               \", h=\" + rowHeaderSize.height +\n+                               \", sc=\" + verticalScrollBarSize.height + \"]\");                    \n+            */\n+\n             return new Dimension(insetsSize.width \n                                  + viewportSize.width\n                                  + viewportInsetsSize.width\n@@ -336,9 +346,9 @@ public void layoutContainer(Container parent) {\n         synchronized (sc.getTreeLock ())\n           {\n             Rectangle scrollPaneBounds = sc.getBounds();\n-            Dimension viewportSize = new Dimension(0,0);\n-            Dimension viewSize = new Dimension(0,0);\n             JViewport viewport = sc.getViewport();\n+            Dimension viewportSize = viewport.getSize();\n+            Dimension viewSize = viewport.getView().getSize(); \n \n             int x1 = 0, x2 = 0, x3 = 0, x4 = 0;\n             int y1 = 0, y2 = 0, y3 = 0, y4 = 0;\n@@ -395,7 +405,7 @@ public void layoutContainer(Container parent) {\n               rowHeader.setBounds(new Rectangle(x1, y2, x2-x1, y3-y2));\n \n             if (showVsb)\n-              verticalScrollBar.setBounds(new Rectangle(x3, y2, x4-x3, y3-y2));\n+                verticalScrollBar.setBounds(new Rectangle(x3, y2, x4-x3, y3-y2));\n \n             if (showHsb)\n               horizontalScrollBar.setBounds(new Rectangle(x2, y3, x3-x2, y4-y3));"}, {"sha": "d543f0be48b0b7d1e69f1648d232add2b8896d8a", "filename": "libjava/javax/swing/SwingUtilities.java", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FSwingUtilities.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -43,6 +43,7 @@\n import java.awt.Container;\n import java.awt.Font;\n import java.awt.FontMetrics;\n+import java.awt.Frame;\n import java.awt.Graphics;\n import java.awt.Insets;\n import java.awt.Point;\n@@ -64,6 +65,8 @@\n public class SwingUtilities implements SwingConstants\n {\n \n+  private static Frame ownerFrame;\n+\n   /**\n    * Calculates the portion of the base rectangle which is inside the\n    * insets.\n@@ -830,5 +833,18 @@ public static void paintComponent(Graphics g, Component c,\n     paintComponent(g, c, p, r.x, r.y, r.width, r.height);\n   }\n   \n+  /**\n+   * This method returns the common Frame owner used in JDialogs\n+   * when no owner is provided.\n+   *\n+   * @return The common Frame \n+   */\n+  static Frame getOwnerFrame()\n+  {\n+    if (ownerFrame == null)\n+      ownerFrame = new Frame();\n+    return ownerFrame;\n+  }\n+  \n \n }"}, {"sha": "02b7823c934adb87d234a0e0be1804500f68f97f", "filename": "libjava/javax/swing/UIManager.java", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FUIManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FUIManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FUIManager.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -178,8 +178,7 @@ public static UIDefaults getDefaults()\n    */\n   public static Dimension getDimension(Object key)\n   {\n-    System.out.println(\"UIManager.getDim\");\n-    return new Dimension(200,100);\n+    return (Dimension) getLookAndFeel().getDefaults().get(key);\n   }\n \n   /**"}, {"sha": "91bcf9b5e604c8119f1712ec95d3b813bfb1714d", "filename": "libjava/javax/swing/ViewportLayout.java", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FViewportLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2FViewportLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FViewportLayout.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -41,37 +41,62 @@\n import java.awt.Container;\n import java.awt.Dimension;\n import java.awt.LayoutManager;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n import java.io.Serializable;\n \n /**\n  * ViewportLayout\n  * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * @author\tGraydon Hoare\n  */\n public class ViewportLayout implements LayoutManager, Serializable\n {\n   static final long serialVersionUID = -788225906076097229L;\n \n-\tpublic ViewportLayout() {\n-\t}\n-\tpublic void addLayoutComponent(String name, Component c) {\n-          // ignore\n-\t}\n-\tpublic void removeLayoutComponent(Component c) {\n-          // ignore\n-\t}\n-\tpublic Dimension preferredLayoutSize(Container parent) {\n-          return null;\n-\t}\n-\tpublic Dimension minimumLayoutSize(Container parent) {\n-          return null;\n-\t}\n-\tpublic void layoutContainer(Container parent) {\n-          if (parent.countComponents() == 1)\n-            {\n-              // This should usually be true, but if it's not it is\n-              // probably nicer if we do not panic.\n-              Component c = parent.getComponent(0);\n-            }\n-\t}\n+  public ViewportLayout() \n+  {\n+  }\n+  public void addLayoutComponent(String name, Component c) \n+  {\n+  }\n+  public void removeLayoutComponent(Component c) \n+  {\n+  }\n+  public Dimension preferredLayoutSize(Container parent) \n+  {\n+    JViewport vp = (JViewport)parent;\n+    Component view = vp.getView();\n+    if (view instanceof Scrollable)\n+      {\n+        Scrollable sc = (Scrollable) view;\n+        Dimension d = sc.getPreferredScrollableViewportSize();\n+        // System.err.println(this + \".preferredLayoutSize() : scrollable -> \" + d);\n+        return d;\n+      }\n+    else\n+      return view.getPreferredSize();\n+  }\n+  public Dimension minimumLayoutSize(Container parent) \n+  {\n+    JViewport vp = (JViewport)parent;\n+    Component view = vp.getView();\n+    return view.getMinimumSize();\n+  }\n+  public void layoutContainer(Container parent) \n+  {\n+    JViewport vp = (JViewport)parent;\n+    Component view = vp.getView();\n+    Rectangle portBounds = vp.getBounds();\n+    Dimension viewMinimum = view.getMinimumSize();\n+    int width = Math.max(portBounds.width, \n+                         viewMinimum.width);\n+    int height = Math.max(portBounds.height, \n+                          viewMinimum.height);\n+    int x = Math.min(0, portBounds.width - width);\n+    int y = Math.min(0, portBounds.height - height);\n+    // System.err.println(this + \".layoutContainer() : width = \" + width + \", height = \" + height);\n+    vp.setViewPosition(new Point(x, y));\n+    vp.setViewSize(new Dimension(width, height));\n+  }\n }"}, {"sha": "b2c6a4e4defbe43c558e96f12c190dc37ba3de15", "filename": "libjava/javax/swing/event/SwingPropertyChangeSupport.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fevent%2FSwingPropertyChangeSupport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fevent%2FSwingPropertyChangeSupport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fevent%2FSwingPropertyChangeSupport.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -210,8 +210,9 @@ public void firePropertyChange(PropertyChangeEvent event) {\n \t\tPropertyChangeListener\tlistener;\n \n \t\t// Check Values if they are equal\n-\t\tif (event.getOldValue() == null || event.getNewValue() == null ||\n-\t\t\tevent.getOldValue().equals(event.getNewValue()) == true) {\n+\t\tif (event.getOldValue() == null && event.getNewValue() == null ||\n+\t\t    (event.getOldValue() != null && event.getNewValue() != null &&\n+\t            event.getOldValue().equals(event.getNewValue()))) {\n \t\t\treturn;\n \t\t} // if\n "}, {"sha": "5ebde8f57fb0e03e8aadf027652845525b036091", "filename": "libjava/javax/swing/plaf/basic/BasicButtonUI.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -92,6 +92,7 @@ protected void installDefaults(AbstractButton b)\n     b.setBackground(defaults.getColor(\"Button.background\"));\n     b.setMargin(defaults.getInsets(\"Button.margin\"));\n     b.setBorder(defaults.getBorder(\"Button.border\"));\n+    b.setOpaque(true);\n   }\n \n   protected void uninstallDefaults(AbstractButton b)"}, {"sha": "553cec3d5c002367473158b4de3b670d5202a585", "filename": "libjava/javax/swing/plaf/basic/BasicCheckBoxMenuItemUI.java", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxMenuItemUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxMenuItemUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxMenuItemUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -38,7 +38,6 @@\n package javax.swing.plaf.basic;\n \n import java.awt.event.MouseEvent;\n-\n import javax.swing.JComponent;\n import javax.swing.JMenuItem;\n import javax.swing.MenuElement;\n@@ -48,18 +47,39 @@\n import javax.swing.plaf.ComponentUI;\n \n \n+/**\n+ * DOCUMENT ME!\n+ *\n+ * @author $author$\n+ * @version $Revision: 1.1.2.3 $\n+ */\n public class BasicCheckBoxMenuItemUI extends BasicMenuItemUI\n {\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public static ComponentUI createUI(final JComponent c)\n   {\n     return new BasicCheckBoxMenuItemUI();\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   protected String getPropertyPrefix()\n   {\n     return null; // TODO\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   */\n   protected void installDefaults()\n   {\n     super.installDefaults();\n@@ -68,6 +88,14 @@ protected void installDefaults()\n     checkIcon = defaults.getIcon(\"CheckBoxMenuItem.checkIcon\");\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param item DOCUMENT ME!\n+   * @param e DOCUMENT ME!\n+   * @param path DOCUMENT ME!\n+   * @param manager DOCUMENT ME!\n+   */\n   void processMouseEvent(JMenuItem item, MouseEvent e, MenuElement[] path,\n                          MenuSelectionManager manager)\n   {"}, {"sha": "9f3a5ac5e8664a1df8a13c0b1a9c05c3a6231e26", "filename": "libjava/javax/swing/plaf/basic/BasicIconFactory.java", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicIconFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicIconFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicIconFactory.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -82,7 +82,34 @@ public static Icon getMenuItemArrowIcon()\n   }\n   public static Icon getMenuArrowIcon()\n   {\n-    return new DummyIcon();\n+    return new Icon()\n+      {\n+\tpublic int getIconHeight()\n+\t{\n+\t  return 12;\n+\t}\n+\n+\tpublic int getIconWidth()\n+\t{\n+\t  return 12;\n+\t}\n+\n+\tpublic void paintIcon(Component c, Graphics g, int x, int y)\n+\t{\n+\t  g.translate(x, y);\n+\n+\t  Color saved = g.getColor();\n+\n+\t  g.setColor(Color.BLACK);\n+\n+\t  g.fillPolygon(new Polygon(new int[] { 3, 9, 3 },\n+                                  new int[] { 2, 6, 10 },\n+                                  3));\n+\n+\t  g.setColor(saved);\n+\t  g.translate(-x, -y);\n+\t}\n+      };\n   }\n \n   public static Icon getCheckBoxIcon()"}, {"sha": "782c2f0e5fabcb592d25b22f16c536e7a53db10e", "filename": "libjava/javax/swing/plaf/basic/BasicLabelUI.java", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLabelUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLabelUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLabelUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -168,23 +168,20 @@ public void paint(Graphics g, JComponent c)\n       vr.width = 0;\n     if (vr.height < 0)\n       vr.height = 0;\n-\n+      \n     Icon icon = (b.isEnabled()) ? b.getIcon() : b.getDisabledIcon();\n \n     String text = layoutCL(b, fm, b.getText(), icon, vr, ir, tr);\n     \n-    if (b.isOpaque())\n-    {\n-      g.setColor(b.getBackground());\n-      g.fillRect(vr.x, vr.y, vr.width, vr.height);\n-    }\n-\n     if (icon != null)\n       icon.paintIcon(b, g, ir.x, ir.y);\n-    if (b.isEnabled())\n-      paintEnabledText(b, g, text, tr.x, tr.y + fm.getAscent());\n-    else\n-      paintDisabledText(b, g, text, tr.x, tr.y + fm.getAscent());\n+    if (text != null && ! text.equals(\"\"))\n+    {\n+      if (b.isEnabled())\n+        paintEnabledText(b, g, text, tr.x, tr.y + fm.getAscent());\n+      else\n+        paintDisabledText(b, g, text, tr.x, tr.y + fm.getAscent());\n+    }\n     g.setFont(saved_font);\n   }\n \n@@ -354,6 +351,7 @@ protected void installDefaults(JLabel c)\n     c.setBackground(defaults.getColor(\"Label.background\"));\n     c.setFont(defaults.getFont(\"Label.font\"));\n     c.setBorder(defaults.getBorder(\"Label.border\"));\n+    c.setOpaque(true);\n     //XXX: There are properties we don't use called disabledForeground\n     //and disabledShadow.\n   }"}, {"sha": "b356bdf2a9a6bf08a72bb804d30de372a229365f", "filename": "libjava/javax/swing/plaf/basic/BasicListUI.java", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -502,6 +502,7 @@ void installDefaults()\n     list.setBackground(defaults.getColor(\"List.background\"));\n     list.setSelectionForeground(defaults.getColor(\"List.selectionForeground\"));\n     list.setSelectionBackground(defaults.getColor(\"List.selectionBackground\"));\n+    list.setOpaque(true);\n   }\n \n   /**\n@@ -620,7 +621,8 @@ public Dimension getPreferredSize(JComponent c)\n     maybeUpdateLayoutState();\n     if (list.getModel().getSize() == 0)\n       return new Dimension(0, 0);\n-    Rectangle bounds = getCellBounds(list, 0, list.getModel().getSize() - 1);\n+    int nrows = Math.min(list.getVisibleRowCount(), list.getModel().getSize());\n+    Rectangle bounds = getCellBounds(list, 0, nrows - 1);\n     return bounds.getSize();\n   }\n \n@@ -696,11 +698,11 @@ public void paint(Graphics g, JComponent c)\n \n   public int locationToIndex(JList list, Point location)\n   {\n-    throw new Error(\"Not implemented\");\n+    return convertYToRow(location.y);\n   }\n \n   public Point indexToLocation(JList list, int index)\n   {\n-    throw new Error(\"Not implemented\");\n+    return new Point(0, convertRowToY(index));\n   }\n }"}, {"sha": "f4466ef5083d2b50b169563744870eca4b0dc58d", "filename": "libjava/javax/swing/plaf/basic/BasicLookAndFeel.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -249,7 +249,7 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"Button.foreground\", new ColorUIResource(Color.black),\n       \"Button.highlight\", new ColorUIResource(Color.white),\n       \"Button.light\", new ColorUIResource(Color.lightGray.brighter()),\n-      \"Button.margin\", new InsetsUIResource(2, 14, 2, 14),\n+      \"Button.margin\", new InsetsUIResource(2, 2, 2, 2),\n       \"Button.shadow\", new ColorUIResource(Color.gray),\n       \"Button.textIconGap\", new Integer(4),\n       \"Button.textShiftOffset\", new Integer(0),\n@@ -694,7 +694,7 @@ protected void initComponentDefaults(UIDefaults defaults)\n       }),\n       \"SplitPane.background\", new ColorUIResource(Color.lightGray),\n       \"SplitPane.border\", new BasicBorders.SplitPaneBorder(null, null),\n-      \"SplitPane.dividerSize\", new Integer(7),\n+      \"SplitPane.dividerSize\", new Integer(10),\n       \"SplitPane.highlight\", new ColorUIResource(Color.white),\n       \"SplitPane.shadow\", new ColorUIResource(Color.gray),\n       \"TabbedPane.ancestorInputMap\", new UIDefaults.LazyInputMap(new Object[] {"}, {"sha": "0fe57f1c497b299b0fbac74c8812a61124c00c0c", "filename": "libjava/javax/swing/plaf/basic/BasicMenuBarUI.java", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuBarUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -0,0 +1,277 @@\n+/* BasicMenuUI.java\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.event.ContainerEvent;\n+import java.awt.event.ContainerListener;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.awt.Dimension;\n+import javax.swing.BoxLayout;\n+import javax.swing.ButtonModel;\n+import javax.swing.Icon;\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JComponent;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPopupMenu;\n+import javax.swing.JRadioButtonMenuItem;\n+import javax.swing.KeyStroke;\n+import javax.swing.MenuElement;\n+import javax.swing.MenuSelectionManager;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.event.MenuDragMouseEvent;\n+import javax.swing.event.MenuDragMouseListener;\n+import javax.swing.event.MenuEvent;\n+import javax.swing.event.MenuKeyEvent;\n+import javax.swing.event.MenuKeyListener;\n+import javax.swing.event.MenuListener;\n+import javax.swing.event.MouseInputListener;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.MenuBarUI;\n+import javax.swing.plaf.MenuItemUI;\n+import java.awt.Insets;\n+import java.awt.GridLayout;\n+\n+\n+/**\n+ * DOCUMENT ME!\n+ *\n+ * @author $author$\n+ * @version $Revision: 1.1.2.1 $\n+ */\n+public class BasicMenuBarUI extends MenuBarUI\n+{\n+  protected ChangeListener changeListener;\n+  protected ContainerListener containerListener;\n+  protected PropertyChangeListener propertyChangeListener;\n+  protected JMenuBar menuBar;\n+\n+  /**\n+   * Creates a new BasicMenuBarUI object.\n+   */\n+  public BasicMenuBarUI()\n+  {\n+    changeListener = createChangeListener();\n+    containerListener = createContainerListener();\n+    propertyChangeListener = new PropertyChangeHandler();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected ChangeListener createChangeListener()\n+  {\n+    return new ChangeHandler();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected ContainerListener  createContainerListener()\n+  {\n+    return new ContainerHandler();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param x DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public static ComponentUI createUI(JComponent x)\n+  {\n+    return new BasicMenuBarUI();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    // let layout manager calculate its size\n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Dimension getMinimumSize(JComponent c)\n+  {\n+    // let layout manager calculate its size\n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    // let layout manager calculate its size\n+    return null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void installDefaults()\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    menuBar.setBackground(defaults.getColor(\"MenuBar.background\"));\n+    menuBar.setBorder(defaults.getBorder(\"MenuBar.border\"));\n+    menuBar.setFont(defaults.getFont(\"MenuBar.font\"));\n+    menuBar.setForeground(defaults.getColor(\"MenuBar.foreground\"));\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void installKeyboardActions()\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void installListeners()\n+  {        \n+    menuBar.addContainerListener(containerListener);\n+    menuBar.addPropertyChangeListener(propertyChangeListener);    \n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   */\n+  public void installUI(JComponent c)\n+  {\n+    super.installUI(c);\n+    menuBar = (JMenuBar) c;\n+    menuBar.setLayout(new BoxLayout(menuBar, BoxLayout.X_AXIS));\n+    installDefaults();\n+    installListeners();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void uninstallDefaults()\n+  {\n+    menuBar.setBackground(null);\n+    menuBar.setBorder(null);\n+    menuBar.setFont(null);\n+    menuBar.setForeground(null);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void uninstallKeyboardActions()\n+  {\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void uninstallListeners()\n+  {\n+    menuBar.removeContainerListener(containerListener);\n+    menuBar.removePropertyChangeListener(propertyChangeListener);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   */\n+  public void uninstallUI(JComponent c)\n+  {\n+    uninstallDefaults();\n+    uninstallListeners();    \n+    menuBar= null;\n+  }\n+\n+  protected class ChangeHandler implements ChangeListener\n+  {\n+    public void stateChanged(ChangeEvent event)\n+    {\n+    }\n+  }\n+\n+  protected class ContainerHandler implements ContainerListener\n+  {\n+    public void componentAdded(ContainerEvent e)\n+    {\n+    }\n+\n+    public void componentRemoved(ContainerEvent e)\n+    {\n+    }\n+  }\n+\n+  protected class PropertyChangeHandler implements PropertyChangeListener\n+  {\n+    public void propertyChange(PropertyChangeEvent e)\n+    {\n+    }\n+  }\n+}"}, {"sha": "29da4ec3bf2a42b52e76f56425bbfcc047199790", "filename": "libjava/javax/swing/plaf/basic/BasicMenuItemUI.java", "status": "modified", "additions": 466, "deletions": 178, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuItemUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30", "patch": "@@ -38,6 +38,7 @@\n package javax.swing.plaf.basic;\n \n import java.awt.Color;\n+import java.awt.Component;\n import java.awt.Dimension;\n import java.awt.Font;\n import java.awt.FontMetrics;\n@@ -47,12 +48,17 @@\n import java.awt.event.KeyEvent;\n import java.awt.event.MouseEvent;\n import java.beans.PropertyChangeEvent;\n-\n+import java.beans.PropertyChangeListener;\n+import java.util.Vector;\n import javax.swing.AbstractButton;\n import javax.swing.ButtonModel;\n import javax.swing.Icon;\n+import javax.swing.JCheckBoxMenuItem;\n import javax.swing.JComponent;\n+import javax.swing.JMenu;\n import javax.swing.JMenuItem;\n+import javax.swing.JPopupMenu;\n+import javax.swing.JRadioButtonMenuItem;\n import javax.swing.KeyStroke;\n import javax.swing.MenuElement;\n import javax.swing.MenuSelectionManager;\n@@ -68,116 +74,219 @@\n import javax.swing.plaf.MenuItemUI;\n \n \n+/**\n+ * DOCUMENT ME!\n+ *\n+ * @author $author$\n+ * @version $Revision: 1.1.2.10 $\n+ */\n public class BasicMenuItemUI extends MenuItemUI\n {\n-  /** Font to be used when displaying menu item's accelerator. */\n+  /**\n+   * Font to be used when displaying menu item's accelerator.\n+   */\n   protected Font acceleratorFont;\n \n-  /** Color to be used when displaying menu item's accelerator. */  \n+  /**\n+   * Color to be used when displaying menu item's accelerator.\n+   */\n   protected Color acceleratorForeground;\n \n-  /** Color to be used when displaying menu item's accelerator\n-   * when menu item is selected.\n-   */ \n+  /**\n+   * Color to be used when displaying menu item's accelerator when menu item is\n+   * selected.\n+   */\n   protected Color acceleratorSelectionForeground;\n-  \n+\n   /**\n-   * Icon that is displayed after the text to indicated that this menu\n-   * contains submenu.\n+   * Icon that is displayed after the text to indicated that this menu contains\n+   * submenu.\n    */\n   protected Icon arrowIcon;\n-  \n+\n   /**\n    * Icon that is displayed before the text. This icon is only used in\n    * JCheckBoxMenuItem or JRadioBoxMenuItem.\n    */\n   protected Icon checkIcon;\n \n-  /** Number of spaces between icon and text. */  \n+  /**\n+   * Number of spaces between icon and text.\n+   */\n   protected int defaultTextIconGap = 4;\n-  \n-  /** Color of the text when menu item is disabled*/\n+\n+  /**\n+   * Color of the text when menu item is disabled\n+   */\n   protected Color disabledForeground;\n-  \n-  /** The menu Drag mouse listener listening to the menu item. */\n+\n+  /**\n+   * The menu Drag mouse listener listening to the menu item.\n+   */\n   protected MenuDragMouseListener menuDragMouseListener;\n-  \n-  /** The menu item itself*/\n+\n+  /**\n+   * The menu item itself\n+   */\n   protected JMenuItem menuItem;\n-  \n-  /** Menu Key listener listening to the menu item. */\n+\n+  /**\n+   * Menu Key listener listening to the menu item.\n+   */\n   protected MenuKeyListener menuKeyListener;\n-  \n-  /** mouse input listener listening to menu item. */\n+\n+  /**\n+   * mouse input listener listening to menu item.\n+   */\n   protected MouseInputListener mouseInputListener;\n-  \n-  /** Indicates if border should be painted  */\n+\n+  /**\n+   * Indicates if border should be painted\n+   */\n   protected boolean oldBorderPainted;\n \n-  /** Color of text that is used when menu item is selected */\n+  /**\n+   * Color of text that is used when menu item is selected\n+   */\n   protected Color selectionBackground;\n-  \n-  /** Color of the background that is used when menu item is selected.*/ \n+\n+  /**\n+   * Color of the background that is used when menu item is selected.\n+   */\n   protected Color selectionForeground;\n \n-  /** String that separates description of the modifiers and the key*/  \n+  /**\n+   * String that separates description of the modifiers and the key\n+   */\n   private String acceleratorDelimiter;\n-  \n-  /** Number of spaces between accelerator and menu item's label. */\n+  private PropertyChangeListener propertyChangeListener;\n+\n+  /**\n+   * Number of spaces between accelerator and menu item's label.\n+   */\n   private int defaultAcceleratorLabelGap = 4;\n \n-  // Constructor Summary\n-  BasicMenuItemUI()\n+  public BasicMenuItemUI()\n   {\n     mouseInputListener = createMouseInputListener(menuItem);\n     menuDragMouseListener = createMenuDragMouseListener(menuItem);\n     menuKeyListener = createMenuKeyListener(menuItem);\n+    propertyChangeListener = new PropertyChangeHandler();\n   }\n \n-  // Method Summary\n   protected MenuDragMouseListener createMenuDragMouseListener(JComponent c)\n   {\n     return new MenuDragMouseHandler();\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   protected MenuKeyListener createMenuKeyListener(JComponent c)\n   {\n     return new MenuKeyHandler();\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   protected MouseInputListener createMouseInputListener(JComponent c)\n   {\n     return new MouseInputHandler();\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public static ComponentUI createUI(JComponent c)\n   {\n     return new BasicMenuItemUI();\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param msm DOCUMENT ME!\n+   */\n   protected void doClick(MenuSelectionManager msm)\n   {\n-    // TODO\n+    menuItem.doClick();\n+    msm.clearSelectedPath();\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public Dimension getMaximumSize(JComponent c)\n   {\n-    // TODO    \n     return null;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public Dimension getMinimumSize(JComponent c)\n   {\n-    // TODO\n     return null;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public MenuElement[] getPath()\n   {\n-    // TODO\n-    return null;\n+    Vector path = new Vector();\n+    Component c = menuItem;\n+    while (c instanceof MenuElement)\n+      {\n+\tpath.add(c);\n+\n+\tif (c instanceof JPopupMenu)\n+\t  c = ((JPopupMenu) c).getInvoker();\n+\telse\n+\t  c = c.getParent();\n+      }\n+\n+    // convert from vector to array\n+    MenuElement[] pathArray = new MenuElement[path.size()];\n+    for (int i = 0; i < path.size(); i++)\n+      pathArray[i] = (MenuElement) path.get(path.size() - i - 1);\n+\n+    return pathArray;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   * @param checkIcon DOCUMENT ME!\n+   * @param arrowIcon DOCUMENT ME!\n+   * @param defaultTextIconGap DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   protected Dimension getPreferredMenuItemSize(JComponent c, Icon checkIcon,\n                                                Icon arrowIcon,\n                                                int defaultTextIconGap)\n@@ -186,51 +295,80 @@ protected Dimension getPreferredMenuItemSize(JComponent c, Icon checkIcon,\n     return null;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   public Dimension getPreferredSize(JComponent c)\n   {\n     AbstractButton b = (AbstractButton) c;\n     Dimension d = BasicGraphicsUtils.getPreferredButtonSize(b,\n                                                             defaultTextIconGap);\n-    \n+\n     // if menu item has accelerator then take accelerator's size into account\n     // when calculating preferred size.\n-    \n     KeyStroke accelerator = ((JMenuItem) c).getAccelerator();\n     Rectangle rect;\n+\n     if (accelerator != null)\n       {\n-        rect = getAcceleratorRect(accelerator,\n-                                  b.getToolkit().getFontMetrics(acceleratorFont));\n-        \n-        // add width of accelerator's text\n-        d.width = d.width + rect.width + defaultAcceleratorLabelGap;\n-\n-        // adjust the heigth of the preferred size if necessary\n-        if (d.height < rect.height)\n-          d.height = rect.height;\n+\trect = getAcceleratorRect(accelerator,\n+\t                          b.getToolkit().getFontMetrics(acceleratorFont));\n+\n+\t// add width of accelerator's text\n+\td.width = d.width + rect.width + defaultAcceleratorLabelGap;\n+\n+\t// adjust the heigth of the preferred size if necessary\n+\tif (d.height < rect.height)\n+\t  d.height = rect.height;\n       }\n \n     if (checkIcon != null)\n       {\n-        d.width = d.width + checkIcon.getIconWidth() + defaultTextIconGap;\n-        if (checkIcon.getIconHeight() > d.height)\n-          d.height = checkIcon.getIconHeight();\n+\td.width = d.width + checkIcon.getIconWidth() + defaultTextIconGap;\n+\n+\tif (checkIcon.getIconHeight() > d.height)\n+\t  d.height = checkIcon.getIconHeight();\n       }\n-      \n+\n+    if (arrowIcon != null && (c instanceof JMenu))\n+      {\n+\td.width = d.width + arrowIcon.getIconWidth() + defaultTextIconGap;\n+\n+\tif (arrowIcon.getIconHeight() > d.height)\n+\t  d.height = arrowIcon.getIconHeight();\n+      }\n+\n     return d;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   protected String getPropertyPrefix()\n   {\n     // TODO\n     return null;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param menuItem DOCUMENT ME!\n+   */\n   protected void installComponents(JMenuItem menuItem)\n   {\n     // TODO\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   */\n   protected void installDefaults()\n   {\n     UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n@@ -240,27 +378,40 @@ protected void installDefaults()\n     menuItem.setFont(defaults.getFont(\"MenuItem.font\"));\n     menuItem.setForeground(defaults.getColor(\"MenuItem.foreground\"));\n     menuItem.setMargin(defaults.getInsets(\"MenuItem.margin\"));\n+    menuItem.setOpaque(true);\n+\n     acceleratorFont = defaults.getFont(\"MenuItem.acceleratorFont\");\n     acceleratorForeground = defaults.getColor(\"MenuItem.acceleratorForeground\");\n     acceleratorSelectionForeground = defaults.getColor(\"MenuItem.acceleratorSelectionForeground\");\n-    arrowIcon = defaults.getIcon(\"MenuItem.arrowIcon\");\n     selectionBackground = defaults.getColor(\"MenuItem.selectionBackground\");\n     selectionForeground = defaults.getColor(\"MenuItem.selectionForeground\");\n     acceleratorDelimiter = defaults.getString(\"MenuItem.acceleratorDelimiter\");\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   */\n   protected void installKeyboardActions()\n   {\n     // TODO\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   */\n   protected void installListeners()\n   {\n     menuItem.addMouseListener(mouseInputListener);\n     menuItem.addMenuDragMouseListener(menuDragMouseListener);\n     menuItem.addMenuKeyListener(menuKeyListener);\n+    menuItem.addPropertyChangeListener(propertyChangeListener);\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   */\n   public void installUI(JComponent c)\n   {\n     super.installUI(c);\n@@ -269,12 +420,25 @@ public void installUI(JComponent c)\n     installListeners();\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param g DOCUMENT ME!\n+   * @param c DOCUMENT ME!\n+   */\n   public void paint(Graphics g, JComponent c)\n   {\n-    paintMenuItem(g, c, checkIcon, arrowIcon, c.getBackground(), \n+    paintMenuItem(g, c, checkIcon, arrowIcon, c.getBackground(),\n                   c.getForeground(), defaultTextIconGap);\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param g DOCUMENT ME!\n+   * @param menuItem DOCUMENT ME!\n+   * @param bgColor DOCUMENT ME!\n+   */\n   protected void paintBackground(Graphics g, JMenuItem menuItem, Color bgColor)\n   {\n     Dimension size = getPreferredSize(menuItem);\n@@ -284,6 +448,17 @@ protected void paintBackground(Graphics g, JMenuItem menuItem, Color bgColor)\n     g.setColor(foreground);\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param g DOCUMENT ME!\n+   * @param c DOCUMENT ME!\n+   * @param checkIcon DOCUMENT ME!\n+   * @param arrowIcon DOCUMENT ME!\n+   * @param background DOCUMENT ME!\n+   * @param foreground DOCUMENT ME!\n+   * @param defaultTextIconGap DOCUMENT ME!\n+   */\n   protected void paintMenuItem(Graphics g, JComponent c, Icon checkIcon,\n                                Icon arrowIcon, Color background,\n                                Color foreground, int defaultTextIconGap)\n@@ -295,72 +470,75 @@ protected void paintMenuItem(Graphics g, JComponent c, Icon checkIcon,\n     Rectangle br = new Rectangle(); // border rectangle\n     Rectangle ar = new Rectangle(); // accelerator rectangle\n     Rectangle cr = new Rectangle(); // checkIcon rectangle\n-    \n+\n     int vertAlign = b.getVerticalAlignment();\n     int horAlign = b.getHorizontalAlignment();\n     int vertTextPos = b.getVerticalTextPosition();\n     int horTextPos = b.getHorizontalTextPosition();\n \n     Font f = c.getFont();\n     g.setFont(f);\n-    FontMetrics fm = g.getFontMetrics(f);    \n+    FontMetrics fm = g.getFontMetrics(f);\n     SwingUtilities.calculateInnerArea(b, br);\n-    SwingUtilities.calculateInsetArea(br, b.getMargin(), vr);        \n+    SwingUtilities.calculateInsetArea(br, b.getMargin(), vr);\n     paintBackground(g, (JMenuItem) c, c.getBackground());\n-    \n+\n     if ((b.getModel().isArmed() && b.getModel().isPressed()))\n       {\n-        if (((AbstractButton) b).isContentAreaFilled())\n-          {\n-            g.setColor(b.getBackground().darker());\n-            g.fillRect(br.x, br.y, br.width, br.height);\n-          }\n+\tif (((AbstractButton) b).isContentAreaFilled())\n+\t  {\n+\t    g.setColor(b.getBackground().darker());\n+\t    g.fillRect(br.x, br.y, br.width, br.height);\n+\t  }\n       }\n     else\n       {\n-        if (((AbstractButton) b).isContentAreaFilled())\n-          {\n-            g.setColor(b.getBackground());\n-            g.fillRect(br.x, br.y, br.width, br.height);\n-          }\n+\tif (((AbstractButton) b).isContentAreaFilled())\n+\t  {\n+\t    g.setColor(b.getBackground());\n+\t    g.fillRect(br.x, br.y, br.width, br.height);\n+\t  }\n       }\n-    \n-    \n+\n     if (checkIcon != null)\n       {\n-        SwingUtilities.layoutCompoundLabel(c, fm, null, checkIcon, vertAlign,\n-                                           horAlign, vertTextPos, horTextPos,\n-                                           vr, cr, tr, defaultTextIconGap);\n-        checkIcon.paintIcon(c, g, cr.x, cr.y);\n+\tSwingUtilities.layoutCompoundLabel(c, fm, null, checkIcon, vertAlign,\n+\t                                   horAlign, vertTextPos, horTextPos,\n+\t                                   vr, cr, tr, defaultTextIconGap);\n+\tcheckIcon.paintIcon(c, g, cr.x, cr.y);\n \n-        // We need to calculate position of the menu text and position of\n-        // user menu icon if there exists one relative to the check icon.\n+\t// We need to calculate position of the menu text and position of\n+\t// user menu icon if there exists one relative to the check icon.\n \t// So we need to adjust view rectangle s.t. its starting point is at\n \t// checkIcon.width + defaultTextIconGap. \n-\t \n-\t vr.x = cr.x + cr.width + defaultTextIconGap;\n+\tvr.x = cr.x + cr.width + defaultTextIconGap;\n       }\n \n-    if (arrowIcon != null)\n+    if (arrowIcon != null && (c instanceof JMenu))\n       {\n-        // FIXME: if this menu contains a submenu, we need to draw arrow icon \n-        // here as well\n+\tif (! ((JMenu) c).isTopLevelMenu())\n+\t  {\n+\t    int width = arrowIcon.getIconWidth();\n+\t    int height = arrowIcon.getIconHeight();\n+\n+\t    arrowIcon.paintIcon(c, g, vr.width - width + defaultTextIconGap,\n+\t                        vr.y + 2);\n+\t  }\n       }\n \n-\n     // paint text and user menu icon if it exists\t     \n     SwingUtilities.layoutCompoundLabel(c, fm, b.getText(), b.getIcon(),\n                                        vertAlign, horAlign, vertTextPos,\n                                        horTextPos, vr, ir, tr,\n                                        defaultTextIconGap);\n \n-    paintText(g, (JMenuItem) c, tr, b.getText());   \n-    \n+    paintText(g, (JMenuItem) c, tr, b.getText());\n+\n     // paint icon\n     // FIXME: should paint different icon at different button state's.\n     // i.e disabled icon when button is disabled.. etc.\n-    \n-    /*  \n+\n+    /*\n     Icon i = b.getIcon();\n     if (i != null)\n       {\n@@ -369,28 +547,35 @@ protected void paintMenuItem(Graphics g, JComponent c, Icon checkIcon,\n          i.paintIcon(c, g, x, y);\n       }\n     */\n-        \n+\n     // paint accelerator    \n     String acceleratorText = \"\";\n+\n     if (((JMenuItem) c).getAccelerator() != null)\n       {\n-        acceleratorText = getAcceleratorText(((JMenuItem) c).getAccelerator());\n-        fm = g.getFontMetrics(acceleratorFont);\n-        ar.width = fm.stringWidth(acceleratorText);\n-        ar.x = br.width - ar.width;      \n-        vr.x = br.width - ar.width;\n-\t\n-        SwingUtilities.layoutCompoundLabel(c, fm, acceleratorText, null,\n-                                          vertAlign, horAlign, vertTextPos,\n-                                          horTextPos, vr, ir, ar,\n-                                          defaultTextIconGap); \n-\t\n-        paintAccelerator(g, (JMenuItem) c, ar, acceleratorText);\n-\t\n-      }          \n-\n+\tacceleratorText = getAcceleratorText(((JMenuItem) c).getAccelerator());\n+\tfm = g.getFontMetrics(acceleratorFont);\n+\tar.width = fm.stringWidth(acceleratorText);\n+\tar.x = br.width - ar.width;\n+\tvr.x = br.width - ar.width;\n+\n+\tSwingUtilities.layoutCompoundLabel(c, fm, acceleratorText, null,\n+\t                                   vertAlign, horAlign, vertTextPos,\n+\t                                   horTextPos, vr, ir, ar,\n+\t                                   defaultTextIconGap);\n+\n+\tpaintAccelerator(g, (JMenuItem) c, ar, acceleratorText);\n+      }\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param g DOCUMENT ME!\n+   * @param menuItem DOCUMENT ME!\n+   * @param textRect DOCUMENT ME!\n+   * @param text DOCUMENT ME!\n+   */\n   protected void paintText(Graphics g, JMenuItem menuItem, Rectangle textRect,\n                            String text)\n   {\n@@ -400,14 +585,22 @@ protected void paintText(Graphics g, JMenuItem menuItem, Rectangle textRect,\n     g.setColor(menuItem.getForeground());\n \n     BasicGraphicsUtils.drawString(g, text, 0, textRect.x,\n-                                 textRect.y + fm.getAscent());\n+                                  textRect.y + fm.getAscent());\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param menuItem DOCUMENT ME!\n+   */\n   protected void uninstallComponents(JMenuItem menuItem)\n   {\n     // TODO\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   */\n   protected void uninstallDefaults()\n   {\n     menuItem.setForeground(null);\n@@ -428,205 +621,300 @@ protected void uninstallDefaults()\n     acceleratorDelimiter = null;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   */\n   protected void uninstallKeyboardActions()\n   {\n     // TODO\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   */\n   protected void uninstallListeners()\n   {\n     menuItem.removeMouseListener(mouseInputListener);\n     menuItem.removeMenuDragMouseListener(menuDragMouseListener);\n     menuItem.removeMenuKeyListener(menuKeyListener);\n+    menuItem.removePropertyChangeListener(propertyChangeListener);\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param c DOCUMENT ME!\n+   */\n   public void uninstallUI(JComponent c)\n   {\n     uninstallListeners();\n     uninstallDefaults();\n     menuItem = null;\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param g DOCUMENT ME!\n+   * @param c DOCUMENT ME!\n+   */\n   public void update(Graphics g, JComponent c)\n   {\n-    // TODO\n+    paint(g, c);\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param accelerator DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   private String getAcceleratorText(KeyStroke accelerator)\n   {\n-    \n     // convert keystroke into string format\n-    \n     String modifiersText = \"\";\n     int modifiers = accelerator.getModifiers();\n     char keyChar = accelerator.getKeyChar();\n     int keyCode = accelerator.getKeyCode();\n \n     if (modifiers != 0)\n-      modifiersText = KeyEvent.getKeyModifiersText(modifiers) +\n-                      acceleratorDelimiter;\n+      modifiersText = KeyEvent.getKeyModifiersText(modifiers)\n+                      + acceleratorDelimiter;\n \n     if (keyCode == KeyEvent.VK_UNDEFINED)\n       return modifiersText + keyChar;\n     else\n       return modifiersText + KeyEvent.getKeyText(keyCode);\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param accelerator DOCUMENT ME!\n+   * @param fm DOCUMENT ME!\n+   *\n+   * @return $returnType$ DOCUMENT ME!\n+   */\n   private Rectangle getAcceleratorRect(KeyStroke accelerator, FontMetrics fm)\n-  {    \n+  {\n     int width = fm.stringWidth(getAcceleratorText(accelerator));\n     int height = fm.getHeight();\n     return new Rectangle(0, 0, width, height);\n   }\n \n-  private void paintAccelerator(Graphics g, JMenuItem menuItem, Rectangle acceleratorRect,\n-                           String acceleratorText)\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param g DOCUMENT ME!\n+   * @param menuItem DOCUMENT ME!\n+   * @param acceleratorRect DOCUMENT ME!\n+   * @param acceleratorText DOCUMENT ME!\n+   */\n+  private void paintAccelerator(Graphics g, JMenuItem menuItem,\n+                                Rectangle acceleratorRect,\n+                                String acceleratorText)\n   {\n     g.setFont(acceleratorFont);\n     FontMetrics fm = g.getFontMetrics(acceleratorFont);\n     g.setColor(acceleratorForeground);\n     BasicGraphicsUtils.drawString(g, acceleratorText, 0, acceleratorRect.x,\n-                                 acceleratorRect.y + fm.getAscent());\n+                                  acceleratorRect.y + fm.getAscent());\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.1.2.10 $\n+   */\n   protected class MouseInputHandler implements MouseInputListener\n   {\n+    /**\n+     * Creates a new MouseInputHandler object.\n+     */\n     protected MouseInputHandler()\n     {\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void mouseClicked(MouseEvent e)\n     {\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.processMouseEvent(e);\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void mouseDragged(MouseEvent e)\n     {\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.processMouseEvent(e);\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void mouseEntered(MouseEvent e)\n     {\n-      if (e.getSource() instanceof AbstractButton)\n-        {\n-          AbstractButton button = (AbstractButton) e.getSource();\n-          ButtonModel model = button.getModel();\n-\n-          if (button.isRolloverEnabled())\n-            {\n-              model.setRollover(true);\n-            }\n-\n-          if (model.isPressed() &&\n-              ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0))\n-            {\n-              model.setArmed(true);\n-            }\n-          else\n-            {\n-              model.setArmed(false);\n-            }\n-        }\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.processMouseEvent(e);\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void mouseExited(MouseEvent e)\n     {\n-      if (e.getSource() instanceof AbstractButton)\n-        {\n-          AbstractButton button = (AbstractButton) e.getSource();\n-          ButtonModel model = button.getModel();\n-\n-          if (button.isRolloverEnabled())\n-            {\n-              model.setRollover(false);\n-            }\n-\n-          model.setArmed(false);\n-        }\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.processMouseEvent(e);\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void mouseMoved(MouseEvent e)\n     {\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.processMouseEvent(e);\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void mousePressed(MouseEvent e)\n     {\n-      if (e.getSource() instanceof AbstractButton)\n-        {\n-          AbstractButton button = (AbstractButton) e.getSource();\n-          ButtonModel model = button.getModel();\n-\n-          if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n-            {\n-              // It is important that these transitions happen in this order.\n-              model.setArmed(true);\n-              model.setPressed(true);\n-            }\n-        }\n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.processMouseEvent(e);\n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void mouseReleased(MouseEvent e)\n     {\n-\n-      if (e.getSource() instanceof AbstractButton)\n-        {\n-          AbstractButton button = (AbstractButton) e.getSource();\n-          ButtonModel model = button.getModel();\n-\n-          if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n-            {\n-              // It is important that these transitions happen in this order.\n-              model.setPressed(false);\n-              model.setArmed(false);\n-            }\n-        }\n+      // FIXME: Should check if the mouse released while mouse cursor\n+      // was indeed over the menu item. If this wasn't the case we probably \n+      // should sent this event to MenuSelectionManager. \n+      MenuSelectionManager manager = MenuSelectionManager.defaultManager();\n+      manager.clearSelectedPath();\n+      menuItem.doClick(0);\n     }\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.1.2.10 $\n+   */\n   protected class MenuDragMouseHandler implements MenuDragMouseListener\n   {\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void menuDragMouseDragged(MenuDragMouseEvent e)\n     {\n-      // TODO        \n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void menuDragMouseEntered(MenuDragMouseEvent e)\n     {\n-      // TODO        \n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void menuDragMouseExited(MenuDragMouseEvent e)\n     {\n-      // TODO        \n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void menuDragMouseReleased(MenuDragMouseEvent e)\n     {\n-      // TODO        \n     }\n   }\n \n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.1.2.10 $\n+   */\n   protected class MenuKeyHandler implements MenuKeyListener\n   {\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void menuKeyPressed(MenuKeyEvent e)\n     {\n-      // TODO        \n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void menuKeyReleased(MenuKeyEvent e)\n     {\n-      // TODO        \n     }\n \n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param e DOCUMENT ME!\n+     */\n     public void menuKeyTyped(MenuKeyEvent e)\n     {\n-      // TODO    \n     }\n   }\n \n-  protected class PropertyChangeHandler\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @author $author$\n+   * @version $Revision: 1.1.2.10 $\n+   */\n+  protected class PropertyChangeHandler implements PropertyChangeListener\n   {\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param evt DOCUMENT ME!\n+     */\n     public void propertyChange(PropertyChangeEvent evt)\n     {\n-      // TODO        \n     }\n   }\n }"}, {"sha": "406934e3adc96118ca8820c6e2067800ce3c680b", "filename": "libjava/javax/swing/plaf/basic/BasicMenuUI.java", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicMenuUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "8d65ee0928d5be4272890da13e0e66b594342352", "filename": "libjava/javax/swing/plaf/basic/BasicOptionPaneUI.java", "status": "modified", "additions": 1223, "deletions": 72, "changes": 1295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicOptionPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicOptionPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicOptionPaneUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "d7ced7654aef789c1743764eba15d54bb9c208c5", "filename": "libjava/javax/swing/plaf/basic/BasicPopupMenuUI.java", "status": "added", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPopupMenuUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPopupMenuUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPopupMenuUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "4a74617726d26e60c8c39cf4123a4e675b239e2c", "filename": "libjava/javax/swing/plaf/basic/BasicProgressBarUI.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "c3c3c840ddb7eb3653d661791ab726b7378b7bd3", "filename": "libjava/javax/swing/plaf/basic/BasicRadioButtonMenuItemUI.java", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonMenuItemUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonMenuItemUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonMenuItemUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "96f09a119809d40efed7f0fde7d8c56673d6a357", "filename": "libjava/javax/swing/plaf/basic/BasicRootPaneUI.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRootPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRootPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRootPaneUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "c52ca00409cf81f5ae6852c0ee0c89a36734df43", "filename": "libjava/javax/swing/plaf/basic/BasicScrollBarUI.java", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "8f4500fd58ccef2179943528c1857c2558652e4a", "filename": "libjava/javax/swing/plaf/basic/BasicSeparatorUI.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSeparatorUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSeparatorUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSeparatorUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "7b5a52f832c7f8beb3a45708f06f0a30794ce615", "filename": "libjava/javax/swing/plaf/basic/BasicSliderUI.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "3a2db55a863ca08ec01b30c2e8c75a226fbc6b93", "filename": "libjava/javax/swing/plaf/basic/BasicSplitPaneDivider.java", "status": "modified", "additions": 546, "deletions": 197, "changes": 743, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneDivider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneDivider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneDivider.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "f1ccb133997cd88930aa6f1f9fd21bad9a793162", "filename": "libjava/javax/swing/plaf/basic/BasicSplitPaneUI.java", "status": "modified", "additions": 1272, "deletions": 61, "changes": 1333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "a0100558be53d78ba56bbb66c07354c93e4a7842", "filename": "libjava/javax/swing/plaf/basic/BasicTabbedPaneUI.java", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "c1adad1853c421e48083149ab3b4e4d4dcb9b891", "filename": "libjava/javax/swing/plaf/basic/BasicViewportUI.java", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "a56e7d27d5b76dfc9602c4e9aca6c36886877e0f", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkClasspathFontPeer.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkClasspathFontPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkClasspathFontPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkClasspathFontPeer.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "5e8562455a4d72f9408164e7c24a90d4cfeeebfa", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGlyphVector.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGlyphVector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGlyphVector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGlyphVector.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "733461dcfc1b6aeb271b9c0a13b7b0ed0bdc3296", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c", "status": "modified", "additions": 234, "deletions": 54, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "9877a45fe58e7b51c0d6ff91ba340fc31f508d89", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkButtonPeer.c", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkButtonPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkButtonPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkButtonPeer.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "e8a918f966671c935339cf4a63da99dd83dc7514", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c", "status": "modified", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "b3858fb3970b7ef8820dfc8c6317253e5ace9c0f", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c", "status": "modified", "additions": 33, "deletions": 109, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkEvents.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkEvents.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkEvents.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "13282e2be4346cd04b22eae00b3f0ec75a25a654", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkImagePainter.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkImagePainter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkImagePainter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkImagePainter.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "9f8301bf7d538a344b8dc691655685b232ff73fb", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkListPeer.c", "status": "modified", "additions": 290, "deletions": 149, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkListPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkListPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkListPeer.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "0bb0ec52567fe0273d03f7b5e3271b67742be558", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkMenuPeer.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMenuPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMenuPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkMenuPeer.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "2d271ea8f2b18d6d20ec25174288ddeadfc8f44e", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkPopupMenuPeer.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkPopupMenuPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkPopupMenuPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkPopupMenuPeer.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "f9baa296459b73fdad50cc529522f30eee6ba86a", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextAreaPeer.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextAreaPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextAreaPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextAreaPeer.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "2807e6b36fcff6e926bbfc653f4feb0c4fff43aa", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkTextComponentPeer.c", "status": "modified", "additions": 15, "deletions": 47, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextComponentPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextComponentPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkTextComponentPeer.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "6234b29c9134bbf4874e03c8ce540d5f8a3149a0", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkToolkit.c", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkToolkit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkToolkit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkToolkit.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "c696a3fa6a2b9d377eb714d41366f669da46f881", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "b4021f51ed94f15316c11837c2d81d13de19d338", "filename": "libjava/jni/gtk-peer/gtkcairopeer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgtkcairopeer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgtkcairopeer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgtkcairopeer.h?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}, {"sha": "a913986c1dbd0b8dfd37afdbf56c3978f1c246ba", "filename": "libjava/jni/gtk-peer/gtkpeer.h", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgtkpeer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d2de6b4c976dc152c8618ab3e8e1319018dc30/libjava%2Fjni%2Fgtk-peer%2Fgtkpeer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgtkpeer.h?ref=c5d2de6b4c976dc152c8618ab3e8e1319018dc30"}]}