{"sha": "16b65b08484237cc2845c4f5c4f15efe3a43a32c", "node_id": "C_kwDOANBUbNoAKDE2YjY1YjA4NDg0MjM3Y2MyODQ1YzRmNWM0ZjE1ZWZlM2E0M2EzMmM", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2022-02-14T22:42:14Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2022-02-14T22:42:14Z"}, "message": "Use correct names for __ibm128 if long double is IEEE 128-bit.\n\nIf you are on a PowerPC system where the default long double is IEEE\n128-bit (either through the compiler option -mabi=ieeelongdouble or via\nthe configure option --with-long-double-format=ieee), GCC used the wrong\nnames for some of the conversion functions for the __ibm128 type.\n\nInternally, GCC uses IFmode for __ibm128 if long double is IEEE 128-bit,\ninstead of TFmode when long double is IBM 128-bit.  This patch adds the\nmissing conversions to prevent the 'if' name from being used.\n\nIn particular, before the patch, the conversions used were:\n\n    IFmode to DImode signed:\t__fixifdi\tinstead of __fixtfdi\n    IFmode to DImode unsigned\t__fixunsifti\tinstead of __fixunstfti\n    DImode to IFmode signed:\t__floatdiif\tinstead of __floatditf\n    DImode to IFmode unsigned:\t__floatundiif\tinstead of __floatunditf\n\n2022-02-14  Michael Meissner  <meissner@the-meissners.org>\n\ngcc/\n\tPR target/104253\n\t* config/rs6000/rs6000.cc (init_float128_ibm): Update the\n\tconversion functions used to convert IFmode types.\n\ngcc/testsuite/\n\tPR target/104253\n\t* gcc.target/powerpc/pr104253.c: New test.", "tree": {"sha": "834e5c3a10106e81f06be4308dec84ac03f21f0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/834e5c3a10106e81f06be4308dec84ac03f21f0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16b65b08484237cc2845c4f5c4f15efe3a43a32c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16b65b08484237cc2845c4f5c4f15efe3a43a32c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16b65b08484237cc2845c4f5c4f15efe3a43a32c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16b65b08484237cc2845c4f5c4f15efe3a43a32c/comments", "author": null, "committer": null, "parents": [{"sha": "19b517dff37b8e25f6babf8883483be73cad8fb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19b517dff37b8e25f6babf8883483be73cad8fb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19b517dff37b8e25f6babf8883483be73cad8fb3"}], "stats": {"total": 162, "additions": 162, "deletions": 0}, "files": [{"sha": "e76c0175da7d1652bf8a62d9af67341a9c8648ae", "filename": "gcc/config/rs6000/rs6000.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b65b08484237cc2845c4f5c4f15efe3a43a32c/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b65b08484237cc2845c4f5c4f15efe3a43a32c/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.cc?ref=16b65b08484237cc2845c4f5c4f15efe3a43a32c", "patch": "@@ -11018,6 +11018,12 @@ init_float128_ibm (machine_mode mode)\n       set_conv_libfunc (trunc_optab, DDmode, mode, \"__dpd_trunctfdd\");\n       set_conv_libfunc (sext_optab, TDmode, mode, \"__dpd_extendtftd\");\n \n+      set_conv_libfunc (sfix_optab, DImode, mode, \"__fixtfdi\");\n+      set_conv_libfunc (ufix_optab, DImode, mode, \"__fixunstfdi\");\n+\n+      set_conv_libfunc (sfloat_optab, mode, DImode, \"__floatditf\");\n+      set_conv_libfunc (ufloat_optab, mode, DImode, \"__floatunditf\");\n+\n       if (TARGET_POWERPC64)\n \t{\n \t  set_conv_libfunc (sfix_optab, TImode, mode, \"__fixtfti\");"}, {"sha": "02049cc978f05eff164e1b41503b72ca8ca6e26e", "filename": "gcc/testsuite/gcc.target/powerpc/pr104253.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b65b08484237cc2845c4f5c4f15efe3a43a32c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr104253.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b65b08484237cc2845c4f5c4f15efe3a43a32c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr104253.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr104253.c?ref=16b65b08484237cc2845c4f5c4f15efe3a43a32c", "patch": "@@ -0,0 +1,156 @@\n+/*\n+ * Require float128 support because __ibm128 currently is not enabled unless we\n+ * also have __float128 support.  We require software IEEE 128-bit support,\n+ * which will work on power8.  If we have hardware IEEE 128-bit support (power9\n+ * or power10), ppc_float128_sw will still enable running the test.\n+ */\n+\n+/* { dg-do run } */\n+/* { require-effective-target ppc_float128_sw } */\n+/* { dg-options \"-O2 -mvsx -mfloat128\" } */\n+\n+/*\n+ * PR target/104253\n+ *\n+ * Verify that the various conversions to and from __ibm128 work.  When the\n+ *  default for long double is changed to IEEE 128-bit, originally GCC would\n+ *  call the functions using an 'if' name instead of 'tf' name.\n+ */\n+\n+#include <stdlib.h>\n+\n+extern float              ibm128_to_sf  (__ibm128) __attribute__((noinline));\n+extern double             ibm128_to_df  (__ibm128) __attribute__((noinline));\n+extern int                ibm128_to_si  (__ibm128) __attribute__((noinline));\n+extern long long          ibm128_to_di  (__ibm128) __attribute__((noinline));\n+extern unsigned int       ibm128_to_usi (__ibm128) __attribute__((noinline));\n+extern unsigned long long ibm128_to_udi (__ibm128) __attribute__((noinline));\n+\n+extern __ibm128 sf_to_ibm128  (float)              __attribute__((noinline));\n+extern __ibm128 df_to_ibm128  (double)             __attribute__((noinline));\n+extern __ibm128 si_to_ibm128  (int)                __attribute__((noinline));\n+extern __ibm128 di_to_ibm128  (long long)          __attribute__((noinline));\n+extern __ibm128 usi_to_ibm128 (unsigned int)       __attribute__((noinline));\n+extern __ibm128 udi_to_ibm128 (unsigned long long) __attribute__((noinline));\n+\n+float\n+ibm128_to_sf  (__ibm128 x)\n+{\n+  return x;\n+}\n+\n+double\n+ibm128_to_df  (__ibm128 x)\n+{\n+  return x;\n+}\n+\n+int\n+ibm128_to_si  (__ibm128 x)\n+{\n+  return x;\n+}\n+\n+long long\n+ibm128_to_di  (__ibm128 x)\n+{\n+  return x;\n+}\n+\n+unsigned int\n+ibm128_to_usi (__ibm128 x)\n+{\n+  return x;\n+}\n+\n+unsigned long long\n+ibm128_to_udi (__ibm128 x)\n+{\n+  return x;\n+}\n+\n+__ibm128\n+sf_to_ibm128  (float x)\n+{\n+  return x;\n+}\n+\n+__ibm128\n+df_to_ibm128  (double x)\n+{\n+  return x;\n+}\n+\n+__ibm128\n+si_to_ibm128  (int x)\n+{\n+  return x;\n+}\n+\n+__ibm128\n+di_to_ibm128  (long long x)\n+{\n+  return x;\n+}\n+\n+__ibm128\n+usi_to_ibm128 (unsigned int x)\n+{\n+  return x;\n+}\n+\n+__ibm128\n+udi_to_ibm128 (unsigned long long x)\n+{\n+  return x;\n+}\n+\n+volatile float\t\t\tseven_sf\t= 7.0f;\n+volatile double\t\t\tseven_df\t= 7.0;\n+volatile int\t\t\tseven_si\t= 7;\n+volatile long long\t\tseven_di\t= 7LL;\n+volatile unsigned int\t\tseven_usi\t= 7U;\n+volatile unsigned long long\tseven_udi\t= 7ULL;\n+volatile __ibm128\t\tseven_ibm128\t= 7.0;\n+\n+int\n+main (void)\n+{\n+  if (seven_ibm128 != sf_to_ibm128 (seven_sf))\n+    abort ();\n+\n+  if (seven_ibm128 != df_to_ibm128 (seven_df))\n+    abort ();\n+\n+  if (seven_ibm128 != si_to_ibm128 (seven_si))\n+    abort ();\n+\n+  if (seven_ibm128 != di_to_ibm128 (seven_di))\n+    abort ();\n+\n+  if (seven_ibm128 != usi_to_ibm128 (seven_usi))\n+    abort ();\n+\n+  if (seven_ibm128 != udi_to_ibm128 (seven_udi))\n+    abort ();\n+\n+  if (seven_sf != ibm128_to_sf (seven_ibm128))\n+    abort ();\n+\n+  if (seven_df != ibm128_to_df (seven_ibm128))\n+    abort ();\n+\n+  if (seven_si != ibm128_to_si (seven_ibm128))\n+    abort ();\n+\n+  if (seven_di != ibm128_to_di (seven_ibm128))\n+    abort ();\n+\n+  if (seven_usi != ibm128_to_usi (seven_ibm128))\n+    abort ();\n+\n+  if (seven_udi != ibm128_to_udi (seven_ibm128))\n+    abort ();\n+\n+  return 0;\n+}"}]}