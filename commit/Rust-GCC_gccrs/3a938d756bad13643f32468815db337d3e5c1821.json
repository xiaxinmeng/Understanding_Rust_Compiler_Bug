{"sha": "3a938d756bad13643f32468815db337d3e5c1821", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E5MzhkNzU2YmFkMTM2NDNmMzI0Njg4MTVkYjMzN2QzZTVjMTgyMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-02-12T16:01:03Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-02-12T16:01:03Z"}, "message": "vec.c (vec_prefix::calculate_allocation): Move as inline variant to vec.h.\n\n2014-02-12  Richard Biener  <rguenther@suse.de>\n\n\t* vec.c (vec_prefix::calculate_allocation): Move as\n\tinline variant to vec.h.\n\t(vec_prefix::calculate_allocation_1): New out-of-line version.\n\t* vec.h (vec_prefix::calculate_allocation_1): Declare.\n\t(vec_prefix::m_has_auto_buf): Rename to ...\n\t(vec_prefix::m_using_auto_storage): ... this.\n\t(vec_prefix::calculate_allocation): Inline the easy cases\n\tand dispatch to calculate_allocation_1 which doesn't need the\n\tprefix address.\n\t(va_heap::reserve): Use gcc_checking_assert.\n\t(vec<T, A, vl_embed>::embedded_init): Add argument to initialize\n\tm_using_auto_storage.\n\t(auto_vec): Change m_vecpfx member to a vec<T, va_heap, vl_embed>\n\tmember and adjust.\n\t(vec<T, va_heap, vl_ptr>::reserve): Remove redundant check.\n\t(vec<T, va_heap, vl_ptr>::release): Avoid casting.\n\t(vec<T, va_heap, vl_ptr>::using_auto_storage): Simplify.\n\nFrom-SVN: r207729", "tree": {"sha": "4573e5bb36217b90a92b4e79ed9e8f3631260871", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4573e5bb36217b90a92b4e79ed9e8f3631260871"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a938d756bad13643f32468815db337d3e5c1821", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a938d756bad13643f32468815db337d3e5c1821", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a938d756bad13643f32468815db337d3e5c1821", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a938d756bad13643f32468815db337d3e5c1821/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad0188be2152e741de7aa4b839a3e8b72b930dfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad0188be2152e741de7aa4b839a3e8b72b930dfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad0188be2152e741de7aa4b839a3e8b72b930dfa"}], "stats": {"total": 120, "additions": 64, "deletions": 56}, "files": [{"sha": "cf015713b3f26c8a52f7958a4668cda67cc35bc0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a938d756bad13643f32468815db337d3e5c1821/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a938d756bad13643f32468815db337d3e5c1821/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a938d756bad13643f32468815db337d3e5c1821", "patch": "@@ -1,3 +1,23 @@\n+2014-02-12  Richard Biener  <rguenther@suse.de>\n+\n+\t* vec.c (vec_prefix::calculate_allocation): Move as\n+\tinline variant to vec.h.\n+\t(vec_prefix::calculate_allocation_1): New out-of-line version.\n+\t* vec.h (vec_prefix::calculate_allocation_1): Declare.\n+\t(vec_prefix::m_has_auto_buf): Rename to ...\n+\t(vec_prefix::m_using_auto_storage): ... this.\n+\t(vec_prefix::calculate_allocation): Inline the easy cases\n+\tand dispatch to calculate_allocation_1 which doesn't need the\n+\tprefix address.\n+\t(va_heap::reserve): Use gcc_checking_assert.\n+\t(vec<T, A, vl_embed>::embedded_init): Add argument to initialize\n+\tm_using_auto_storage.\n+\t(auto_vec): Change m_vecpfx member to a vec<T, va_heap, vl_embed>\n+\tmember and adjust.\n+\t(vec<T, va_heap, vl_ptr>::reserve): Remove redundant check.\n+\t(vec<T, va_heap, vl_ptr>::release): Avoid casting.\n+\t(vec<T, va_heap, vl_ptr>::using_auto_storage): Simplify.\n+\n 2014-02-12  Richard Biener  <rguenther@suse.de>\n \n \t* gcse.c (compute_transp): break from loop over canon_modify_mem_list"}, {"sha": "c0cd3386b7a4c7a411abfa41db254e841dc24ab7", "filename": "gcc/vec.c", "status": "modified", "additions": 16, "deletions": 35, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a938d756bad13643f32468815db337d3e5c1821/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a938d756bad13643f32468815db337d3e5c1821/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=3a938d756bad13643f32468815db337d3e5c1821", "patch": "@@ -171,46 +171,27 @@ vec_prefix::release_overhead (void)\n \n \n /* Calculate the number of slots to reserve a vector, making sure that\n-   RESERVE slots are free.  If EXACT grow exactly, otherwise grow\n-   exponentially.  PFX is the control data for the vector.  */\n+   it is of at least DESIRED size by growing ALLOC exponentially.  */\n \n unsigned\n-vec_prefix::calculate_allocation (vec_prefix *pfx, unsigned reserve,\n-\t\t\t\t  bool exact)\n+vec_prefix::calculate_allocation_1 (unsigned alloc, unsigned desired)\n {\n-  unsigned alloc = 0;\n-  unsigned num = 0;\n-\n-  if (pfx)\n-    {\n-      alloc = pfx->m_alloc;\n-      num = pfx->m_num;\n-    }\n-  else if (!reserve)\n-    gcc_unreachable ();\n-\n   /* We must have run out of room.  */\n-  gcc_assert (alloc - num < reserve);\n-\n-  if (exact)\n-    /* Exact size.  */\n-    alloc = num + reserve;\n+  gcc_assert (alloc < desired);\n+\n+  /* Exponential growth. */\n+  if (!alloc)\n+    alloc = 4;\n+  else if (alloc < 16)\n+    /* Double when small.  */\n+    alloc = alloc * 2;\n   else\n-    {\n-      /* Exponential growth. */\n-      if (!alloc)\n-\talloc = 4;\n-      else if (alloc < 16)\n-\t/* Double when small.  */\n-\talloc = alloc * 2;\n-      else\n-\t/* Grow slower when large.  */\n-\talloc = (alloc * 3 / 2);\n-\n-      /* If this is still too small, set it to the right size. */\n-      if (alloc < num + reserve)\n-\talloc = num + reserve;\n-    }\n+    /* Grow slower when large.  */\n+    alloc = (alloc * 3 / 2);\n+\n+  /* If this is still too small, set it to the right size. */\n+  if (alloc < desired)\n+    alloc = desired;\n   return alloc;\n }\n "}, {"sha": "587302344d5deb629e9e9ae68e22b89a813ef0e8", "filename": "gcc/vec.h", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a938d756bad13643f32468815db337d3e5c1821/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a938d756bad13643f32468815db337d3e5c1821/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=3a938d756bad13643f32468815db337d3e5c1821", "patch": "@@ -218,6 +218,7 @@ struct vec_prefix\n   void register_overhead (size_t, const char *, int, const char *);\n   void release_overhead (void);\n   static unsigned calculate_allocation (vec_prefix *, unsigned, bool);\n+  static unsigned calculate_allocation_1 (unsigned, unsigned);\n \n   /* Note that vec_prefix should be a base class for vec, but we use\n      offsetof() on vector fields of tree structures (e.g.,\n@@ -233,10 +234,25 @@ struct vec_prefix\n   friend struct va_heap;\n \n   unsigned m_alloc : 31;\n-  unsigned m_has_auto_buf : 1;\n+  unsigned m_using_auto_storage : 1;\n   unsigned m_num;\n };\n \n+/* Calculate the number of slots to reserve a vector, making sure that\n+   RESERVE slots are free.  If EXACT grow exactly, otherwise grow\n+   exponentially.  PFX is the control data for the vector.  */\n+\n+inline unsigned\n+vec_prefix::calculate_allocation (vec_prefix *pfx, unsigned reserve,\n+\t\t\t\t  bool exact)\n+{\n+  if (exact)\n+    return (pfx ? pfx->m_num : 0) + reserve;\n+  else if (!pfx)\n+    return MAX (4, reserve);\n+  return calculate_allocation_1 (pfx->m_alloc, pfx->m_num + reserve);\n+}\n+\n template<typename, typename, typename> struct vec;\n \n /* Valid vector layouts\n@@ -283,7 +299,7 @@ va_heap::reserve (vec<T, va_heap, vl_embed> *&v, unsigned reserve, bool exact\n {\n   unsigned alloc\n     = vec_prefix::calculate_allocation (v ? &v->m_vecpfx : 0, reserve, exact);\n-  gcc_assert (alloc);\n+  gcc_checking_assert (alloc);\n \n   if (GATHER_STATISTICS && v)\n     v->m_vecpfx.release_overhead ();\n@@ -479,7 +495,7 @@ struct GTY((user)) vec<T, A, vl_embed>\n   T *bsearch (const void *key, int (*compar)(const void *, const void *));\n   unsigned lower_bound (T, bool (*)(const T &, const T &)) const;\n   static size_t embedded_size (unsigned);\n-  void embedded_init (unsigned, unsigned = 0);\n+  void embedded_init (unsigned, unsigned = 0, unsigned = 0);\n   void quick_grow (unsigned len);\n   void quick_grow_cleared (unsigned len);\n \n@@ -1037,10 +1053,10 @@ vec<T, A, vl_embed>::embedded_size (unsigned alloc)\n \n template<typename T, typename A>\n inline void\n-vec<T, A, vl_embed>::embedded_init (unsigned alloc, unsigned num)\n+vec<T, A, vl_embed>::embedded_init (unsigned alloc, unsigned num, unsigned aut)\n {\n   m_vecpfx.m_alloc = alloc;\n-  m_vecpfx.m_has_auto_buf = 0;\n+  m_vecpfx.m_using_auto_storage = aut;\n   m_vecpfx.m_num = num;\n }\n \n@@ -1234,10 +1250,8 @@ class auto_vec : public vec<T, va_heap>\n public:\n   auto_vec ()\n   {\n-    m_header.m_alloc = N;\n-    m_header.m_has_auto_buf = 1;\n-    m_header.m_num = 0;\n-    this->m_vec = reinterpret_cast<vec<T, va_heap, vl_embed> *> (&m_header);\n+    m_auto.embedded_init (MAX (N, 2), 0, 1);\n+    this->m_vec = &m_auto;\n   }\n \n   ~auto_vec ()\n@@ -1246,10 +1260,8 @@ class auto_vec : public vec<T, va_heap>\n   }\n \n private:\n-  friend class vec<T, va_heap, vl_ptr>;\n-\n-  vec_prefix m_header;\n-  T m_data[N];\n+  vec<T, va_heap, vl_embed> m_auto;\n+  T m_data[MAX (N - 1, 1)];\n };\n \n /* auto_vec is a sub class of vec whose storage is released when it is\n@@ -1396,7 +1408,7 @@ template<typename T>\n inline bool\n vec<T, va_heap, vl_ptr>::reserve (unsigned nelems, bool exact MEM_STAT_DECL)\n {\n-  if (!nelems || space (nelems))\n+  if (space (nelems))\n     return false;\n \n   /* For now play a game with va_heap::reserve to hide our auto storage if any,\n@@ -1462,7 +1474,7 @@ vec<T, va_heap, vl_ptr>::release (void)\n \n   if (using_auto_storage ())\n     {\n-      static_cast<auto_vec<T, 1> *> (this)->m_header.m_num = 0;\n+      m_vec->m_vecpfx.m_num = 0;\n       return;\n     }\n \n@@ -1705,12 +1717,7 @@ template<typename T>\n inline bool\n vec<T, va_heap, vl_ptr>::using_auto_storage () const\n {\n-  if (!m_vec->m_vecpfx.m_has_auto_buf)\n-    return false;\n-\n-  const vec_prefix *auto_header\n-    = &static_cast<const auto_vec<T, 1> *> (this)->m_header;\n-  return reinterpret_cast<vec_prefix *> (m_vec) == auto_header;\n+  return m_vec->m_vecpfx.m_using_auto_storage;\n }\n \n #if (GCC_VERSION >= 3000)"}]}