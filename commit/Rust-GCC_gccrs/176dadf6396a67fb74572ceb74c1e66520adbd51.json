{"sha": "176dadf6396a67fb74572ceb74c1e66520adbd51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc2ZGFkZjYzOTZhNjdmYjc0NTcyY2ViNzRjMWU2NjUyMGFkYmQ1MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T10:16:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T10:16:43Z"}, "message": "[multiple changes]\n\n2011-08-02  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb: Minor reformatting\n\tMinor comment addition\n\tMinor error msg text change\n\n2011-08-02  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Iteration_Scheme.Uses_Secondary_Stack): New\n\tfunction. Used to be more precise when we generate a variable plus one\n\tassignment to remove side effects in the evaluation of the Bound\n\texpressions.\n\t(Analyze_Iteration_Scheme): Clean attribute analyzed in all the nodes\n\tof the bound expression to force its re-analysis and thus expand the\n\tassociated transient scope (if required). Code cleanup replacing the\n\tprevious code that declared the constant entity by an invocation to\n\troutine Force_Evaluation which centralizes this work in the frontend.\n\nFrom-SVN: r177124", "tree": {"sha": "fd678bd18c08bc1eff4551dda9a880c209adff4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd678bd18c08bc1eff4551dda9a880c209adff4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/176dadf6396a67fb74572ceb74c1e66520adbd51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176dadf6396a67fb74572ceb74c1e66520adbd51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/176dadf6396a67fb74572ceb74c1e66520adbd51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176dadf6396a67fb74572ceb74c1e66520adbd51/comments", "author": null, "committer": null, "parents": [{"sha": "d8b962d80e8388a84aec13593b8b169446c547cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8b962d80e8388a84aec13593b8b169446c547cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8b962d80e8388a84aec13593b8b169446c547cb"}], "stats": {"total": 406, "additions": 237, "deletions": 169}, "files": [{"sha": "712f5f77ac2e2962571dfafd83973a38200697f4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176dadf6396a67fb74572ceb74c1e66520adbd51/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176dadf6396a67fb74572ceb74c1e66520adbd51/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=176dadf6396a67fb74572ceb74c1e66520adbd51", "patch": "@@ -1,3 +1,21 @@\n+2011-08-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb: Minor reformatting\n+\tMinor comment addition\n+\tMinor error msg text change\n+\n+2011-08-02  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Iteration_Scheme.Uses_Secondary_Stack): New\n+\tfunction. Used to be more precise when we generate a variable plus one\n+\tassignment to remove side effects in the evaluation of the Bound\n+\texpressions.\n+\t(Analyze_Iteration_Scheme): Clean attribute analyzed in all the nodes\n+\tof the bound expression to force its re-analysis and thus expand the\n+\tassociated transient scope (if required). Code cleanup replacing the\n+\tprevious code that declared the constant entity by an invocation to\n+\troutine Force_Evaluation which centralizes this work in the frontend.\n+\n 2011-08-02  Robert Dewar  <dewar@adacore.com>\n \n \t* einfo.adb (Is_Base_Type): Improve efficiency by using a flag table"}, {"sha": "d17d9151560595ea30f5ba03971067e0f84d1c0b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176dadf6396a67fb74572ceb74c1e66520adbd51/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176dadf6396a67fb74572ceb74c1e66520adbd51/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=176dadf6396a67fb74572ceb74c1e66520adbd51", "patch": "@@ -1666,10 +1666,12 @@ package body Sem_Ch3 is\n    -----------------------------------\n \n    procedure Analyze_Component_Declaration (N : Node_Id) is\n-      Id : constant Entity_Id := Defining_Identifier (N);\n-      E  : constant Node_Id   := Expression (N);\n-      T  : Entity_Id;\n-      P  : Entity_Id;\n+      Id  : constant Entity_Id := Defining_Identifier (N);\n+      E   : constant Node_Id   := Expression (N);\n+      Typ : constant Node_Id   :=\n+              Subtype_Indication (Component_Definition (N));\n+      T   : Entity_Id;\n+      P   : Entity_Id;\n \n       function Contains_POC (Constr : Node_Id) return Boolean;\n       --  Determines whether a constraint uses the discriminant of a record\n@@ -1773,8 +1775,6 @@ package body Sem_Ch3 is\n          end if;\n       end Is_Known_Limited;\n \n-      Typ : constant Node_Id := Subtype_Indication (Component_Definition (N));\n-\n    --  Start of processing for Analyze_Component_Declaration\n \n    begin\n@@ -4005,8 +4005,9 @@ package body Sem_Ch3 is\n            (\"subtype of Boolean cannot have constraint\", N);\n       end if;\n \n-      --  Subtype of String shall have a lower index bound equal to 1 in SPARK\n-      --  or ALFA.\n+      --  String subtype must have a lower bound of 1 in SPARK/ALFA. Note that\n+      --  we do not need to test for the non-static case here, since that was\n+      --  already taken care of in Process_Range_Expr_In_Decl.\n \n       if Base_Type (T) = Standard_String\n         and then Nkind (Subtype_Indication (N)) = N_Subtype_Indication\n@@ -4015,6 +4016,7 @@ package body Sem_Ch3 is\n             Cstr   : constant Node_Id := Constraint (Subtype_Indication (N));\n             Drange : Node_Id;\n             Low    : Node_Id;\n+\n          begin\n             if Nkind (Cstr) = N_Index_Or_Discriminant_Constraint\n               and then List_Length (Constraints (Cstr)) = 1\n@@ -4028,7 +4030,7 @@ package body Sem_Ch3 is\n                     and then Expr_Value (Low) /= 1\n                   then\n                      Check_Formal_Restriction\n-                       (\"subtype of String must have 1 as lower bound\", N);\n+                       (\"String subtype must have lower bound of 1\", N);\n                   end if;\n                end if;\n             end if;\n@@ -19011,6 +19013,7 @@ package body Sem_Ch3 is\n          declare\n             Typ  : Node_Id;\n             Ctxt : Node_Id;\n+\n          begin\n             if Nkind (Parent (Def)) = N_Full_Type_Declaration then\n                Typ := Parent (Def);\n@@ -19027,14 +19030,12 @@ package body Sem_Ch3 is\n             then\n                Check_Formal_Restriction\n                  (\"type should be defined in package specification\", Typ);\n+\n             elsif Nkind (Ctxt) /= N_Package_Specification\n-              or else\n-                Nkind (Parent (Parent (Ctxt))) /= N_Compilation_Unit\n+              or else Nkind (Parent (Parent (Ctxt))) /= N_Compilation_Unit\n             then\n                Check_Formal_Restriction\n                  (\"type should be defined in library unit package\", Typ);\n-            else\n-               null;\n             end if;\n          end;\n       end if;"}, {"sha": "0780140cdd8b6ccdc2584fcdb98b5d003e100e56", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 205, "deletions": 156, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176dadf6396a67fb74572ceb74c1e66520adbd51/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176dadf6396a67fb74572ceb74c1e66520adbd51/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=176dadf6396a67fb74572ceb74c1e66520adbd51", "patch": "@@ -95,18 +95,18 @@ package body Sem_Ch5 is\n       procedure Set_Assignment_Type\n         (Opnd      : Node_Id;\n          Opnd_Type : in out Entity_Id);\n-      --  Opnd is either the Lhs or Rhs of the assignment, and Opnd_Type\n-      --  is the nominal subtype. This procedure is used to deal with cases\n-      --  where the nominal subtype must be replaced by the actual subtype.\n+      --  Opnd is either the Lhs or Rhs of the assignment, and Opnd_Type is the\n+      --  nominal subtype. This procedure is used to deal with cases where the\n+      --  nominal subtype must be replaced by the actual subtype.\n \n       -------------------------------\n       -- Diagnose_Non_Variable_Lhs --\n       -------------------------------\n \n       procedure Diagnose_Non_Variable_Lhs (N : Node_Id) is\n       begin\n-         --  Not worth posting another error if left hand side already\n-         --  flagged as being illegal in some respect.\n+         --  Not worth posting another error if left hand side already flagged\n+         --  as being illegal in some respect.\n \n          if Error_Posted (N) then\n             return;\n@@ -130,8 +130,8 @@ package body Sem_Ch5 is\n                elsif (Is_Prival (Ent)\n                         and then\n                           (Ekind (Current_Scope) = E_Function\n-                             or else Ekind (Enclosing_Dynamic_Scope (\n-                                       Current_Scope)) = E_Function))\n+                             or else Ekind (Enclosing_Dynamic_Scope\n+                                             (Current_Scope)) = E_Function))\n                    or else\n                      (Ekind (Ent) = E_Component\n                         and then Is_Protected_Type (Scope (Ent)))\n@@ -202,10 +202,10 @@ package body Sem_Ch5 is\n          Require_Entity (Opnd);\n \n          --  If the assignment operand is an in-out or out parameter, then we\n-         --  get the actual subtype (needed for the unconstrained case).\n-         --  If the operand is the actual in an entry declaration, then within\n-         --  the accept statement it is replaced with a local renaming, which\n-         --  may also have an actual subtype.\n+         --  get the actual subtype (needed for the unconstrained case). If the\n+         --  operand is the actual in an entry declaration, then within the\n+         --  accept statement it is replaced with a local renaming, which may\n+         --  also have an actual subtype.\n \n          if Is_Entity_Name (Opnd)\n            and then (Ekind (Entity (Opnd)) = E_Out_Parameter\n@@ -344,17 +344,17 @@ package body Sem_Ch5 is\n          end if;\n       end if;\n \n-      --  The resulting assignment type is T1, so now we will resolve the\n-      --  left hand side of the assignment using this determined type.\n+      --  The resulting assignment type is T1, so now we will resolve the left\n+      --  hand side of the assignment using this determined type.\n \n       Resolve (Lhs, T1);\n \n       --  Cases where Lhs is not a variable\n \n       if not Is_Variable (Lhs) then\n \n-         --  Ada 2005 (AI-327): Check assignment to the attribute Priority of\n-         --  a protected object.\n+         --  Ada 2005 (AI-327): Check assignment to the attribute Priority of a\n+         --  protected object.\n \n          declare\n             Ent : Entity_Id;\n@@ -452,9 +452,9 @@ package body Sem_Ch5 is\n            (\"target of assignment operation must not be abstract\", Lhs);\n       end if;\n \n-      --  Resolution may have updated the subtype, in case the left-hand\n-      --  side is a private protected component. Use the correct subtype\n-      --  to avoid scoping issues in the back-end.\n+      --  Resolution may have updated the subtype, in case the left-hand side\n+      --  is a private protected component. Use the correct subtype to avoid\n+      --  scoping issues in the back-end.\n \n       T1 := Etype (Lhs);\n \n@@ -631,7 +631,7 @@ package body Sem_Ch5 is\n          Apply_Scalar_Range_Check (Rhs, Etype (Lhs));\n \n       --  For array types, verify that lengths match. If the right hand side\n-      --  if a function call that has been inlined, the assignment has been\n+      --  is a function call that has been inlined, the assignment has been\n       --  rewritten as a block, and the constraint check will be applied to the\n       --  assignment within the block.\n \n@@ -648,8 +648,8 @@ package body Sem_Ch5 is\n          --  side is a type conversion to an unconstrained type, a length check\n          --  is performed on the expression itself during expansion. In rare\n          --  cases, the redundant length check is computed on an index type\n-         --  with a different representation, triggering incorrect code in\n-         --  the back end.\n+         --  with a different representation, triggering incorrect code in the\n+         --  back end.\n \n          Apply_Length_Check (Rhs, Etype (Lhs));\n \n@@ -679,11 +679,11 @@ package body Sem_Ch5 is\n \n          and then Same_Object (Lhs, Original_Node (Rhs))\n \n-         --  But exclude the case where the right side was an operation\n-         --  that got rewritten (e.g. JUNK + K, where K was known to be\n-         --  zero). We don't want to warn in such a case, since it is\n-         --  reasonable to write such expressions especially when K is\n-         --  defined symbolically in some other package.\n+         --  But exclude the case where the right side was an operation that\n+         --  got rewritten (e.g. JUNK + K, where K was known to be zero). We\n+         --  don't want to warn in such a case, since it is reasonable to write\n+         --  such expressions especially when K is defined symbolically in some\n+         --  other package.\n \n         and then Nkind (Original_Node (Rhs)) not in N_Op\n       then\n@@ -722,11 +722,11 @@ package body Sem_Ch5 is\n          Set_Referenced_Modified (Lhs, Out_Param => False);\n       end if;\n \n-      --  Final step. If left side is an entity, then we may be able to\n-      --  reset the current tracked values to new safe values. We only have\n-      --  something to do if the left side is an entity name, and expansion\n-      --  has not modified the node into something other than an assignment,\n-      --  and of course we only capture values if it is safe to do so.\n+      --  Final step. If left side is an entity, then we may be able to reset\n+      --  the current tracked values to new safe values. We only have something\n+      --  to do if the left side is an entity name, and expansion has not\n+      --  modified the node into something other than an assignment, and of\n+      --  course we only capture values if it is safe to do so.\n \n       if Is_Entity_Name (Lhs)\n         and then Nkind (N) = N_Assignment_Statement\n@@ -739,8 +739,8 @@ package body Sem_Ch5 is\n \n                --  If simple variable on left side, warn if this assignment\n                --  blots out another one (rendering it useless) and note\n-               --  location of assignment in case no one references value.\n-               --  We only do this for source assignments, otherwise we can\n+               --  location of assignment in case no one references value. We\n+               --  only do this for source assignments, otherwise we can\n                --  generate bogus warnings when an assignment is rewritten as\n                --  another assignment, and gets tied up with itself.\n \n@@ -809,9 +809,8 @@ package body Sem_Ch5 is\n    begin\n       Check_Formal_Restriction (\"block statement is not allowed\", N);\n \n-      --  If no handled statement sequence is present, things are really\n-      --  messed up, and we just return immediately (this is a defence\n-      --  against previous errors).\n+      --  If no handled statement sequence is present, things are really messed\n+      --  up, and we just return immediately (defence against previous errors).\n \n       if No (HSS) then\n          return;\n@@ -843,10 +842,9 @@ package body Sem_Ch5 is\n             Analyze (Id);\n             Ent := Entity (Id);\n \n-            --  An error defense. If we have an identifier, but no entity,\n-            --  then something is wrong. If we have previous errors, then\n-            --  just remove the identifier and continue, otherwise raise\n-            --  an exception.\n+            --  An error defense. If we have an identifier, but no entity, then\n+            --  something is wrong. If previous errors, then just remove the\n+            --  identifier and continue, otherwise raise an exception.\n \n             if No (Ent) then\n                if Total_Errors_Detected /= 0 then\n@@ -887,9 +885,9 @@ package body Sem_Ch5 is\n          Analyze (HSS);\n          Process_End_Label (HSS, 'e', Ent);\n \n-         --  If exception handlers are present, then we indicate that\n-         --  enclosing scopes contain a block with handlers. We only\n-         --  need to mark non-generic scopes.\n+         --  If exception handlers are present, then we indicate that enclosing\n+         --  scopes contain a block with handlers. We only need to mark non-\n+         --  generic scopes.\n \n          if Present (EH) then\n             S := Scope (Ent);\n@@ -932,17 +930,17 @@ package body Sem_Ch5 is\n       --  Don't care about assigned values\n \n       Statements_Analyzed : Boolean := False;\n-      --  Set True if at least some statement sequences get analyzed.\n-      --  If False on exit, means we had a serious error that prevented\n-      --  full analysis of the case statement, and as a result it is not\n-      --  a good idea to output warning messages about unreachable code.\n+      --  Set True if at least some statement sequences get analyzed. If False\n+      --  on exit, means we had a serious error that prevented full analysis of\n+      --  the case statement, and as a result it is not a good idea to output\n+      --  warning messages about unreachable code.\n \n       Save_Unblocked_Exit_Count : constant Nat := Unblocked_Exit_Count;\n       --  Recursively save value of this global, will be restored on exit\n \n       procedure Non_Static_Choice_Error (Choice : Node_Id);\n-      --  Error routine invoked by the generic instantiation below when\n-      --  the case statement has a non static choice.\n+      --  Error routine invoked by the generic instantiation below when the\n+      --  case statement has a non static choice.\n \n       procedure Process_Statements (Alternative : Node_Id);\n       --  Analyzes all the statements associated with a case alternative.\n@@ -981,16 +979,16 @@ package body Sem_Ch5 is\n          Statements_Analyzed := True;\n \n          --  An interesting optimization. If the case statement expression\n-         --  is a simple entity, then we can set the current value within\n-         --  an alternative if the alternative has one possible value.\n+         --  is a simple entity, then we can set the current value within an\n+         --  alternative if the alternative has one possible value.\n \n          --    case N is\n          --      when 1      => alpha\n          --      when 2 | 3  => beta\n          --      when others => gamma\n \n-         --  Here we know that N is initially 1 within alpha, but for beta\n-         --  and gamma, we do not know anything more about the initial value.\n+         --  Here we know that N is initially 1 within alpha, but for beta and\n+         --  gamma, we do not know anything more about the initial value.\n \n          if Is_Entity_Name (Exp) then\n             Ent := Entity (Exp);\n@@ -1080,10 +1078,10 @@ package body Sem_Ch5 is\n          return;\n       end if;\n \n-      --  If the case expression is a formal object of mode in out, then\n-      --  treat it as having a nonstatic subtype by forcing use of the base\n-      --  type (which has to get passed to Check_Case_Choices below).  Also\n-      --  use base type when the case expression is parenthesized.\n+      --  If the case expression is a formal object of mode in out, then treat\n+      --  it as having a nonstatic subtype by forcing use of the base type\n+      --  (which has to get passed to Check_Case_Choices below). Also use base\n+      --  type when the case expression is parenthesized.\n \n       if Paren_Count (Exp) > 0\n         or else (Is_Entity_Name (Exp)\n@@ -1148,13 +1146,16 @@ package body Sem_Ch5 is\n    ----------------------------\n \n    --  If the exit includes a name, it must be the name of a currently open\n-   --  loop. Otherwise there must be an innermost open loop on the stack,\n-   --  to which the statement implicitly refers.\n+   --  loop. Otherwise there must be an innermost open loop on the stack, to\n+   --  which the statement implicitly refers.\n \n    --  Additionally, in formal mode:\n-   --  * the exit can only name the closest enclosing loop;\n-   --  * an exit with a when clause must be directly contained in a loop;\n-   --  * an exit without a when clause must be directly contained in an\n+\n+   --    The exit can only name the closest enclosing loop;\n+\n+   --    An exit with a when clause must be directly contained in a loop;\n+\n+   --    An exit without a when clause must be directly contained in an\n    --    if-statement with no elsif or else, which is itself directly contained\n    --    in a loop. The exit must be the last statement in the if-statement.\n \n@@ -1177,6 +1178,7 @@ package body Sem_Ch5 is\n          if not In_Open_Scopes (U_Name) or else Ekind (U_Name) /= E_Loop then\n             Error_Msg_N (\"invalid loop name in exit statement\", N);\n             return;\n+\n          else\n             if Has_Loop_In_Inner_Open_Scopes (U_Name) then\n                Check_Formal_Restriction\n@@ -1185,6 +1187,7 @@ package body Sem_Ch5 is\n \n             Set_Has_Exit (U_Name);\n          end if;\n+\n       else\n          U_Name := Empty;\n       end if;\n@@ -1194,7 +1197,8 @@ package body Sem_Ch5 is\n          Kind := Ekind (Scope_Id);\n \n          if Kind = E_Loop\n-           and then (No (Target) or else Scope_Id = U_Name) then\n+           and then (No (Target) or else Scope_Id = U_Name)\n+         then\n             Set_Has_Exit (Scope_Id);\n             exit;\n \n@@ -1339,15 +1343,14 @@ package body Sem_Ch5 is\n \n    --  A special complication arises in the analysis of if statements\n \n-   --  The expander has circuitry to completely delete code that it\n-   --  can tell will not be executed (as a result of compile time known\n-   --  conditions). In the analyzer, we ensure that code that will be\n-   --  deleted in this manner is analyzed but not expanded. This is\n-   --  obviously more efficient, but more significantly, difficulties\n-   --  arise if code is expanded and then eliminated (e.g. exception\n-   --  table entries disappear). Similarly, itypes generated in deleted\n-   --  code must be frozen from start, because the nodes on which they\n-   --  depend will not be available at the freeze point.\n+   --  The expander has circuitry to completely delete code that it can tell\n+   --  will not be executed (as a result of compile time known conditions). In\n+   --  the analyzer, we ensure that code that will be deleted in this manner is\n+   --  analyzed but not expanded. This is obviously more efficient, but more\n+   --  significantly, difficulties arise if code is expanded and then\n+   --  eliminated (e.g. exception table entries disappear). Similarly, itypes\n+   --  generated in deleted code must be frozen from start, because the nodes\n+   --  on which they depend will not be available at the freeze point.\n \n    procedure Analyze_If_Statement (N : Node_Id) is\n       E : Node_Id;\n@@ -1358,13 +1361,13 @@ package body Sem_Ch5 is\n       Save_In_Deleted_Code : Boolean;\n \n       Del : Boolean := False;\n-      --  This flag gets set True if a True condition has been found,\n-      --  which means that remaining ELSE/ELSIF parts are deleted.\n+      --  This flag gets set True if a True condition has been found, which\n+      --  means that remaining ELSE/ELSIF parts are deleted.\n \n       procedure Analyze_Cond_Then (Cnode : Node_Id);\n-      --  This is applied to either the N_If_Statement node itself or\n-      --  to an N_Elsif_Part node. It deals with analyzing the condition\n-      --  and the THEN statements associated with it.\n+      --  This is applied to either the N_If_Statement node itself or to an\n+      --  N_Elsif_Part node. It deals with analyzing the condition and the THEN\n+      --  statements associated with it.\n \n       -----------------------\n       -- Analyze_Cond_Then --\n@@ -1390,8 +1393,8 @@ package body Sem_Ch5 is\n          elsif Compile_Time_Known_Value (Cond) then\n             Save_In_Deleted_Code := In_Deleted_Code;\n \n-            --  If condition is True, then analyze the THEN statements\n-            --  and set no expansion for ELSE and ELSIF parts.\n+            --  If condition is True, then analyze the THEN statements and set\n+            --  no expansion for ELSE and ELSIF parts.\n \n             if Is_True (Expr_Value (Cond)) then\n                Analyze_Statements (Tstm);\n@@ -1419,9 +1422,9 @@ package body Sem_Ch5 is\n    --  Start of Analyze_If_Statement\n \n    begin\n-      --  Initialize exit count for else statements. If there is no else\n-      --  part, this count will stay non-zero reflecting the fact that the\n-      --  uncovered else case is an unblocked exit.\n+      --  Initialize exit count for else statements. If there is no else part,\n+      --  this count will stay non-zero reflecting the fact that the uncovered\n+      --  else case is an unblocked exit.\n \n       Unblocked_Exit_Count := 1;\n       Analyze_Cond_Then (N);\n@@ -1481,9 +1484,8 @@ package body Sem_Ch5 is\n    -- Analyze_Implicit_Label_Declaration --\n    ----------------------------------------\n \n-   --  An implicit label declaration is generated in the innermost\n-   --  enclosing declarative part. This is done for labels as well as\n-   --  block and loop names.\n+   --  An implicit label declaration is generated in the innermost enclosing\n+   --  declarative part. This is done for labels, and block and loop names.\n \n    --  Note: any changes in this routine may need to be reflected in\n    --  Analyze_Label_Entity.\n@@ -1517,6 +1519,12 @@ package body Sem_Ch5 is\n       --  to capture the bounds, so that the function result can be finalized\n       --  in timely fashion.\n \n+      function Has_Call_Using_Secondary_Stack (N : Node_Id) return Boolean;\n+      --  N is the node for an arbitrary construct. This function searches the\n+      --  construct N to see if any expressions within it contain function\n+      --  calls that use the secondary stack, returning True if any such call\n+      --  is found, and False otherwise.\n+\n       --------------------\n       -- Process_Bounds --\n       --------------------\n@@ -1571,8 +1579,6 @@ package body Sem_Ch5 is\n \n             Analyze_And_Resolve (Original_Bound, Typ);\n \n-            Id := Make_Temporary (Loc, 'S', Original_Bound);\n-\n             --  Normally, the best approach is simply to generate a constant\n             --  declaration that captures the bound. However, there is a nasty\n             --  case where this is wrong. If the bound is complex, and has a\n@@ -1584,33 +1590,13 @@ package body Sem_Ch5 is\n             --  proper trace of the value, useful in optimizations that get rid\n             --  of junk range checks.\n \n-            --  Probably we want something like the Side_Effect_Free routine\n-            --  in Exp_Util, but for now, we just optimize the cases of 'Last\n-            --  and 'First applied to an entity, since these are the important\n-            --  cases for range check optimizations.\n-\n-            if Nkind (Original_Bound) = N_Attribute_Reference\n-              and then (Attribute_Name (Original_Bound) = Name_First\n-                          or else\n-                        Attribute_Name (Original_Bound) = Name_Last)\n-              and then Is_Entity_Name (Prefix (Original_Bound))\n-            then\n-               Decl :=\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Id,\n-                   Constant_Present    => True,\n-                   Object_Definition   => New_Occurrence_Of (Typ, Loc),\n-                   Expression          => Relocate_Node (Original_Bound));\n-\n-               --  Insert declaration at proper place. If loop comes from an\n-               --  enclosing quantified expression, the insertion point is\n-               --  arbitrarily far up in the tree.\n-\n-               Insert_Action (Parent (N), Decl);\n-               Rewrite (Original_Bound, New_Occurrence_Of (Id, Loc));\n-               return Expression (Decl);\n+            if not Has_Call_Using_Secondary_Stack (N) then\n+               Force_Evaluation (Original_Bound);\n+               return Original_Bound;\n             end if;\n \n+            Id := Make_Temporary (Loc, 'R', Original_Bound);\n+\n             --  Here we make a declaration with a separate assignment\n             --   statement, and insert before loop header.\n \n@@ -1624,6 +1610,14 @@ package body Sem_Ch5 is\n                 Name        => New_Occurrence_Of (Id, Loc),\n                 Expression  => Relocate_Node (Original_Bound));\n \n+            --  We must recursively clean in the relocated expression the flag\n+            --  analyzed to ensure that the expression is reanalyzed. Required\n+            --  to ensure that the transient scope is established now (because\n+            --  Establish_Transient_Scope discarded generating transient scopes\n+            --  in the analysis of the iteration scheme).\n+\n+            Reset_Analyzed_Flags (Expression (Assign));\n+\n             Insert_Actions (Parent (N), New_List (Decl, Assign));\n \n             Rewrite (Original_Bound, New_Occurrence_Of (Id, Loc));\n@@ -1638,11 +1632,11 @@ package body Sem_Ch5 is\n       --  Start of processing for Process_Bounds\n \n       begin\n-         --  Determine expected type of range by analyzing separate copy\n-         --  Do the analysis and resolution of the copy of the bounds with\n-         --  expansion disabled, to prevent the generation of finalization\n-         --  actions on each bound. This prevents memory leaks when the\n-         --  bounds contain calls to functions returning controlled arrays.\n+         --  Determine expected type of range by analyzing separate copy Do the\n+         --  analysis and resolution of the copy of the bounds with expansion\n+         --  disabled, to prevent the generation of finalization actions on\n+         --  each bound. This prevents memory leaks when the bounds contain\n+         --  calls to functions returning controlled arrays.\n \n          Set_Parent (R_Copy, Parent (R));\n          Save_Analysis := Full_Analysis;\n@@ -1699,11 +1693,10 @@ package body Sem_Ch5 is\n \n          Typ := Etype (R_Copy);\n \n-         --  If the type of the discrete range is Universal_Integer, then\n-         --  the bound's type must be resolved to Integer, and any object\n-         --  used to hold the bound must also have type Integer, unless the\n-         --  literal bounds are constant-folded expressions that carry a user-\n-         --  defined type.\n+         --  If the type of the discrete range is Universal_Integer, then the\n+         --  bound's type must be resolved to Integer, and any object used to\n+         --  hold the bound must also have type Integer, unless the literal\n+         --  bounds are constant-folded expressions with a user-defined type.\n \n          if Typ = Universal_Integer then\n             if Nkind (Lo) = N_Integer_Literal\n@@ -1789,12 +1782,70 @@ package body Sem_Ch5 is\n          end if;\n       end Check_Controlled_Array_Attribute;\n \n+      ------------------------------------\n+      -- Has_Call_Using_Secondary_Stack --\n+      ------------------------------------\n+\n+      function Has_Call_Using_Secondary_Stack (N : Node_Id) return Boolean is\n+\n+         function Check_Call (N : Node_Id) return Traverse_Result;\n+         --  Check if N is a function call which uses the secondary stack\n+\n+         ----------------\n+         -- Check_Call --\n+         ----------------\n+\n+         function Check_Call (N : Node_Id) return Traverse_Result is\n+            Nam        : Node_Id;\n+            Subp       : Entity_Id;\n+            Return_Typ : Entity_Id;\n+\n+         begin\n+            if Nkind (N) = N_Function_Call then\n+               Nam := Name (N);\n+\n+               --  Call using access to subprogram with explicit dereference\n+\n+               if Nkind (Nam) = N_Explicit_Dereference then\n+                  Subp := Etype (Nam);\n+\n+               --  Normal case\n+\n+               else\n+                  Subp := Entity (Nam);\n+               end if;\n+\n+               Return_Typ := Etype (Subp);\n+\n+               if Is_Composite_Type (Return_Typ)\n+                 and then not Is_Constrained (Return_Typ)\n+               then\n+                  return Abandon;\n+\n+               elsif Sec_Stack_Needed_For_Return (Subp) then\n+                  return Abandon;\n+               end if;\n+            end if;\n+\n+            --  Continue traversing the tree\n+\n+            return OK;\n+         end Check_Call;\n+\n+         function Check_Calls is new Traverse_Func (Check_Call);\n+\n+      --  Start of processing for Has_Call_Using_Secondary_Stack\n+\n+      begin\n+         return Check_Calls (N) = Abandon;\n+      end Has_Call_Using_Secondary_Stack;\n+\n    --  Start of processing for Analyze_Iteration_Scheme\n \n    begin\n-      --  If this is a rewritten quantified expression, the iteration\n-      --  scheme has been analyzed already. Do no repeat analysis because\n-      --  the loop variable is already declared.\n+      --  If this is a rewritten quantified expression, the iteration scheme\n+      --  has been analyzed already. Do no repeat analysis because the loop\n+      --  variable is already declared.\n \n       if Analyzed (N) then\n          return;\n@@ -1812,8 +1863,8 @@ package body Sem_Ch5 is\n          Cond : constant Node_Id := Condition (N);\n \n       begin\n-         --  For WHILE loop, verify that the condition is a Boolean\n-         --  expression and resolve and check it.\n+         --  For WHILE loop, verify that the condition is a Boolean expression\n+         --  and resolve and check it.\n \n          if Present (Cond) then\n             Analyze_And_Resolve (Cond, Any_Boolean);\n@@ -1835,8 +1886,8 @@ package body Sem_Ch5 is\n             begin\n                Enter_Name (Id);\n \n-               --  We always consider the loop variable to be referenced,\n-               --  since the loop may be used just for counting purposes.\n+               --  We always consider the loop variable to be referenced, since\n+               --  the loop may be used just for counting purposes.\n \n                Generate_Reference (Id, N, ' ');\n \n@@ -2000,8 +2051,8 @@ package body Sem_Ch5 is\n                         if not Inside_A_Generic\n                           and then not In_Instance\n                         then\n-                           --  Specialize msg if invalid values could make\n-                           --  the loop non-null after all.\n+                           --  Specialize msg if invalid values could make the\n+                           --  loop non-null after all.\n \n                            if Compile_Time_Compare\n                                 (L, H, Assume_Valid => False) = GT\n@@ -2010,9 +2061,9 @@ package body Sem_Ch5 is\n                                 (\"?loop range is null, loop will not execute\",\n                                  DS);\n \n-                              --  Since we know the range of the loop is\n-                              --  null, set the appropriate flag to remove\n-                              --  the loop entirely during expansion.\n+                              --  Since we know the range of the loop is null,\n+                              --  set the appropriate flag to remove the loop\n+                              --  entirely during expansion.\n \n                               Set_Is_Null_Loop (Parent (N));\n \n@@ -2179,8 +2230,8 @@ package body Sem_Ch5 is\n    begin\n       if Present (Id) then\n \n-         --  Make name visible, e.g. for use in exit statements. Loop\n-         --  labels are always considered to be referenced.\n+         --  Make name visible, e.g. for use in exit statements. Loop labels\n+         --  are always considered to be referenced.\n \n          Analyze (Id);\n          Ent := Entity (Id);\n@@ -2227,10 +2278,10 @@ package body Sem_Ch5 is\n          Set_Parent (Ent, Loop_Statement);\n       end if;\n \n-      --  Kill current values on entry to loop, since statements in body of\n-      --  loop may have been executed before the loop is entered. Similarly we\n-      --  kill values after the loop, since we do not know that the body of the\n-      --  loop was executed.\n+      --  Kill current values on entry to loop, since statements in the body of\n+      --  the loop may have been executed before the loop is entered. Similarly\n+      --  we kill values after the loop, since we do not know that the body of\n+      --  the loop was executed.\n \n       Kill_Current_Values;\n       Push_Scope (Ent);\n@@ -2251,8 +2302,8 @@ package body Sem_Ch5 is\n          Check_Infinite_Loop_Warning (N);\n       end if;\n \n-      --  Code after loop is unreachable if the loop has no WHILE or FOR\n-      --  and contains no EXIT statements within the body of the loop.\n+      --  Code after loop is unreachable if the loop has no WHILE or FOR and\n+      --  contains no EXIT statements within the body of the loop.\n \n       if No (Iter) and then not Has_Exit (Ent) then\n          Check_Unreachable_Code (N);\n@@ -2282,9 +2333,9 @@ package body Sem_Ch5 is\n \n    begin\n       --  The labels declared in the statement list are reachable from\n-      --  statements in the list. We do this as a prepass so that any\n-      --  goto statement will be properly flagged if its target is not\n-      --  reachable. This is not required, but is nice behavior!\n+      --  statements in the list. We do this as a prepass so that any goto\n+      --  statement will be properly flagged if its target is not reachable.\n+      --  This is not required, but is nice behavior!\n \n       S := First (L);\n       while Present (S) loop\n@@ -2331,10 +2382,9 @@ package body Sem_Ch5 is\n \n       Conditional_Statements_End;\n \n-      --  Make labels unreachable. Visibility is not sufficient, because\n-      --  labels in one if-branch for example are not reachable from the\n-      --  other branch, even though their declarations are in the enclosing\n-      --  declarative part.\n+      --  Make labels unreachable. Visibility is not sufficient, because labels\n+      --  in one if-branch for example are not reachable from the other branch,\n+      --  even though their declarations are in the enclosing declarative part.\n \n       S := First (L);\n       while Present (S) loop\n@@ -2365,9 +2415,8 @@ package body Sem_Ch5 is\n             Nxt := Original_Node (Next (N));\n \n             --  If a label follows us, then we never have dead code, since\n-            --  someone could branch to the label, so we just ignore it,\n-            --  unless we are in formal mode where goto statements are not\n-            --  allowed.\n+            --  someone could branch to the label, so we just ignore it, unless\n+            --  we are in formal mode where goto statements are not allowed.\n \n             if Nkind (Nxt) = N_Label and then not Formal_Verification_Mode then\n                return;\n@@ -2433,10 +2482,10 @@ package body Sem_Ch5 is\n                   end if;\n                end if;\n \n-            --  If the unconditional transfer of control instruction is\n-            --  the last statement of a sequence, then see if our parent\n-            --  is one of the constructs for which we count unblocked exits,\n-            --  and if so, adjust the count.\n+            --  If the unconditional transfer of control instruction is the\n+            --  last statement of a sequence, then see if our parent is one of\n+            --  the constructs for which we count unblocked exits, and if so,\n+            --  adjust the count.\n \n             else\n                P := Parent (N);"}]}