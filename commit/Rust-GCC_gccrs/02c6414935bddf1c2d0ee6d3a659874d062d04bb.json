{"sha": "02c6414935bddf1c2d0ee6d3a659874d062d04bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJjNjQxNDkzNWJkZGYxYzJkMGVlNmQzYTY1OTg3NGQwNjJkMDRiYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-05-04T07:29:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-05-04T07:29:55Z"}, "message": "re PR tree-optimization/31130 (VRP no longer derives range for division after negation)\n\n2017-05-04  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/31130\n\t* tree-vrp.c (needs_overflow_infinity): Remove as always returning\n\tfalse.\n\t(supports_overflow_infinity): Likewise.\n\t(is_negative_overflow_infinity): Likewise.\n\t(is_positive_overflow_infinity): Likewise.\n\t(is_overflow_infinity): Likewise.\n\t(stmt_overflow_infinity): Likewise.\n\t(overflow_infinity_range_p): Likewise.\n\t(usable_range_p): Remove as always returning true.\n\t(make_overflow_infinity): Remove.\n\t(negative_overflow_infinity): Likewise.\n\t(positive_overflow_infinity): Likewise.\n\t(avoid_overflow_infinity): Likewise.\n\t(set_value_range): Adjust accordingly.\n\t(set_value_range_to_nonnegative): Likewise, remove now unused\n\toverflow_infinity arg.\n\t(vrp_operand_equal_p): Adjust.\n\t(update_value_range): Likewise.\n\t(range_int_cst_singleton_p): Likewise.\n\t(operand_less_p): Likewise.\n\t(compare_values_warnv): Likewise.\n\t(extract_range_for_var_from_comparison_expr): Likewise.\n\t(vrp_int_const_binop): Likewise.\n\t(zero_nonzero_bits_from_vr): Likewise.\n\t(extract_range_from_multiplicative_op_1): Likewise.\n\t(extract_range_from_binary_expr_1): Likewise.\n\t(extract_range_from_unary_expr): Likewise.\n\t(extract_range_from_comparison): Likewise.\n\t(extract_range_basic): Likewise.\n\t(adjust_range_with_scev): Likewise.\n\t(compare_ranges): Likewise.\n\t(compare_range_with_value): Likewise.\n\t(dump_value_range): Likewise.\n\t(test_for_singularity): Likewise, remove strict_overflow_p parameter\n\tnever used.\n\t(simplify_cond_using_ranges): Adjust.\n\n\t* gcc.dg/Wstrict-overflow-12.c: XFAIL.\n\t* gcc.dg/Wstrict-overflow-13.c: Likewise.\n\t* gcc.dg/Wstrict-overflow-21.c: Likewise.\n\t* gcc.dg/pr52904.c: Remove XFAIL.\n\t* gcc.dg/tree-ssa/vrp114.c: New testcase.\n\nFrom-SVN: r247578", "tree": {"sha": "a83ea8598a5023f32a8c6fc5ffdea67f70364d2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a83ea8598a5023f32a8c6fc5ffdea67f70364d2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02c6414935bddf1c2d0ee6d3a659874d062d04bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02c6414935bddf1c2d0ee6d3a659874d062d04bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02c6414935bddf1c2d0ee6d3a659874d062d04bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02c6414935bddf1c2d0ee6d3a659874d062d04bb/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2b4514101fc315ce7d069ff8476b2dd8251a4223", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b4514101fc315ce7d069ff8476b2dd8251a4223", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b4514101fc315ce7d069ff8476b2dd8251a4223"}], "stats": {"total": 754, "additions": 175, "deletions": 579}, "files": [{"sha": "c690da95a26ae2939fd05b9d4eda603e2955feb5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02c6414935bddf1c2d0ee6d3a659874d062d04bb", "patch": "@@ -1,3 +1,43 @@\n+2017-05-04  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/31130\n+\t* tree-vrp.c (needs_overflow_infinity): Remove as always returning\n+\tfalse.\n+\t(supports_overflow_infinity): Likewise.\n+\t(is_negative_overflow_infinity): Likewise.\n+\t(is_positive_overflow_infinity): Likewise.\n+\t(is_overflow_infinity): Likewise.\n+\t(stmt_overflow_infinity): Likewise.\n+\t(overflow_infinity_range_p): Likewise.\n+\t(usable_range_p): Remove as always returning true.\n+\t(make_overflow_infinity): Remove.\n+\t(negative_overflow_infinity): Likewise.\n+\t(positive_overflow_infinity): Likewise.\n+\t(avoid_overflow_infinity): Likewise.\n+\t(set_value_range): Adjust accordingly.\n+\t(set_value_range_to_nonnegative): Likewise, remove now unused\n+\toverflow_infinity arg.\n+\t(vrp_operand_equal_p): Adjust.\n+\t(update_value_range): Likewise.\n+\t(range_int_cst_singleton_p): Likewise.\n+\t(operand_less_p): Likewise.\n+\t(compare_values_warnv): Likewise.\n+\t(extract_range_for_var_from_comparison_expr): Likewise.\n+\t(vrp_int_const_binop): Likewise.\n+\t(zero_nonzero_bits_from_vr): Likewise.\n+\t(extract_range_from_multiplicative_op_1): Likewise.\n+\t(extract_range_from_binary_expr_1): Likewise.\n+\t(extract_range_from_unary_expr): Likewise.\n+\t(extract_range_from_comparison): Likewise.\n+\t(extract_range_basic): Likewise.\n+\t(adjust_range_with_scev): Likewise.\n+\t(compare_ranges): Likewise.\n+\t(compare_range_with_value): Likewise.\n+\t(dump_value_range): Likewise.\n+\t(test_for_singularity): Likewise, remove strict_overflow_p parameter\n+\tnever used.\n+\t(simplify_cond_using_ranges): Adjust.\n+\n 2017-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n \n \t* brig-builtins.def: Added a builtin for class_f64."}, {"sha": "2a6bec99e8f9e728dde7867c393d3c1bd139d712", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=02c6414935bddf1c2d0ee6d3a659874d062d04bb", "patch": "@@ -1,3 +1,12 @@\n+2017-05-04  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/31130\n+\t* gcc.dg/Wstrict-overflow-12.c: XFAIL.\n+\t* gcc.dg/Wstrict-overflow-13.c: Likewise.\n+\t* gcc.dg/Wstrict-overflow-21.c: Likewise.\n+\t* gcc.dg/pr52904.c: Remove XFAIL.\n+\t* gcc.dg/tree-ssa/vrp114.c: New testcase.\n+\n 2017-05-03  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/78496"}, {"sha": "2837ce3a44eca4805fa58b7838ebcf7872d27b28", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-12.c?ref=02c6414935bddf1c2d0ee6d3a659874d062d04bb", "patch": "@@ -10,7 +10,7 @@ int\n foo ()\n {\n   int i, bits;\n-  for (i = 1, bits = 1; i > 0; i += i) /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+  for (i = 1, bits = 1; i > 0; i += i) /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" { xfail *-*-* } } */\n     ++bits;\n   return bits;\n }"}, {"sha": "8691cd82fe41ece84687f7d5a5895f23dff38733", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-13.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-13.c?ref=02c6414935bddf1c2d0ee6d3a659874d062d04bb", "patch": "@@ -11,7 +11,7 @@ int\n foo ()\n {\n   int j;\n-  for (j = 1; 0 < j; j *= 2) /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+  for (j = 1; 0 < j; j *= 2) /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" { xfail *-*-* } } */\n     if (! bigtime_test (j))\n       return 1;\n   return 0;"}, {"sha": "82a61d966f3c81dd7947103bd9db9a8177c582d1", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-21.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-21.c?ref=02c6414935bddf1c2d0ee6d3a659874d062d04bb", "patch": "@@ -5,7 +5,7 @@ int\n foo ()\n {\n   int i, bits;\n-  for (i = 1, bits = 1; i > 0; i += i) /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+  for (i = 1, bits = 1; i > 0; i += i) /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" { xfail *-*-* } } */\n     ++bits;\n   return bits;\n }"}, {"sha": "0b8910fbe180abe045901203e67d1a290fb2cf73", "filename": "gcc/testsuite/gcc.dg/pr52904.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52904.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52904.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52904.c?ref=02c6414935bddf1c2d0ee6d3a659874d062d04bb", "patch": "@@ -14,7 +14,7 @@ wait_reading_process_output (void)\n \tnfds++;\n     }\n \n-  if (nfds < 0) /* { dg-bogus \"assuming signed overflow does not occur\" \"\" { xfail *-*-* } } */\n+  if (nfds < 0) /* { dg-bogus \"assuming signed overflow does not occur\" \"\" } */\n     return 1;\n   return 0;\n }"}, {"sha": "f465005b6715be8492c62ed286c3768a7b84489a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp114.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp114.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp114.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp114.c?ref=02c6414935bddf1c2d0ee6d3a659874d062d04bb", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O2 -fdump-tree-fre1 -fdump-tree-evrp\" } */\n+\n+extern void link_error ();\n+void foo (int a)\n+{\n+  if (a < 0)\n+    {\n+      int y;\n+      a = -a;\n+      y  = a / 7;\n+      y = y * 2;\n+      if (y > 1 << 30)\n+\tlink_error ();\n+    }\n+}\n+\n+int main()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"link_error\" 1 \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"evrp\" } } */"}, {"sha": "cc38b0c5f132dc4566d2edd864828d248f9248c4", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 98, "deletions": 575, "changes": 673, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02c6414935bddf1c2d0ee6d3a659874d062d04bb/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=02c6414935bddf1c2d0ee6d3a659874d062d04bb", "patch": "@@ -213,127 +213,6 @@ vrp_val_is_min (const_tree val)\n }\n \n \n-/* Return whether TYPE should use an overflow infinity distinct from\n-   TYPE_{MIN,MAX}_VALUE.  We use an overflow infinity value to\n-   represent a signed overflow during VRP computations.  An infinity\n-   is distinct from a half-range, which will go from some number to\n-   TYPE_{MIN,MAX}_VALUE.  */\n-\n-static inline bool\n-needs_overflow_infinity (const_tree type)\n-{\n-  return INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_WRAPS (type);\n-}\n-\n-/* Return whether TYPE can support our overflow infinity\n-   representation: we use the TREE_OVERFLOW flag, which only exists\n-   for constants.  If TYPE doesn't support this, we don't optimize\n-   cases which would require signed overflow--we drop them to\n-   VARYING.  */\n-\n-static inline bool\n-supports_overflow_infinity (const_tree type)\n-{\n-  tree min = vrp_val_min (type), max = vrp_val_max (type);\n-  gcc_checking_assert (needs_overflow_infinity (type));\n-  return (min != NULL_TREE\n-\t  && CONSTANT_CLASS_P (min)\n-\t  && max != NULL_TREE\n-\t  && CONSTANT_CLASS_P (max));\n-}\n-\n-/* VAL is the maximum or minimum value of a type.  Return a\n-   corresponding overflow infinity.  */\n-\n-static inline tree\n-make_overflow_infinity (tree val)\n-{\n-  gcc_checking_assert (val != NULL_TREE && CONSTANT_CLASS_P (val));\n-  val = copy_node (val);\n-  TREE_OVERFLOW (val) = 1;\n-  return val;\n-}\n-\n-/* Return a negative overflow infinity for TYPE.  */\n-\n-static inline tree\n-negative_overflow_infinity (tree type)\n-{\n-  gcc_checking_assert (supports_overflow_infinity (type));\n-  return make_overflow_infinity (vrp_val_min (type));\n-}\n-\n-/* Return a positive overflow infinity for TYPE.  */\n-\n-static inline tree\n-positive_overflow_infinity (tree type)\n-{\n-  gcc_checking_assert (supports_overflow_infinity (type));\n-  return make_overflow_infinity (vrp_val_max (type));\n-}\n-\n-/* Return whether VAL is a negative overflow infinity.  */\n-\n-static inline bool\n-is_negative_overflow_infinity (const_tree val)\n-{\n-  return (TREE_OVERFLOW_P (val)\n-\t  && needs_overflow_infinity (TREE_TYPE (val))\n-\t  && vrp_val_is_min (val));\n-}\n-\n-/* Return whether VAL is a positive overflow infinity.  */\n-\n-static inline bool\n-is_positive_overflow_infinity (const_tree val)\n-{\n-  return (TREE_OVERFLOW_P (val)\n-\t  && needs_overflow_infinity (TREE_TYPE (val))\n-\t  && vrp_val_is_max (val));\n-}\n-\n-/* Return whether VAL is a positive or negative overflow infinity.  */\n-\n-static inline bool\n-is_overflow_infinity (const_tree val)\n-{\n-  return (TREE_OVERFLOW_P (val)\n-\t  && needs_overflow_infinity (TREE_TYPE (val))\n-\t  && (vrp_val_is_min (val) || vrp_val_is_max (val)));\n-}\n-\n-/* Return whether STMT has a constant rhs that is_overflow_infinity. */\n-\n-static inline bool\n-stmt_overflow_infinity (gimple *stmt)\n-{\n-  if (is_gimple_assign (stmt)\n-      && get_gimple_rhs_class (gimple_assign_rhs_code (stmt)) ==\n-      GIMPLE_SINGLE_RHS)\n-    return is_overflow_infinity (gimple_assign_rhs1 (stmt));\n-  return false;\n-}\n-\n-/* If VAL is now an overflow infinity, return VAL.  Otherwise, return\n-   the same value with TREE_OVERFLOW clear.  This can be used to avoid\n-   confusing a regular value with an overflow value.  */\n-\n-static inline tree\n-avoid_overflow_infinity (tree val)\n-{\n-  if (!is_overflow_infinity (val))\n-    return val;\n-\n-  if (vrp_val_is_max (val))\n-    return vrp_val_max (TREE_TYPE (val));\n-  else\n-    {\n-      gcc_checking_assert (vrp_val_is_min (val));\n-      return vrp_val_min (TREE_TYPE (val));\n-    }\n-}\n-\n-\n /* Set value range VR to VR_UNDEFINED.  */\n \n static inline void\n@@ -372,8 +251,7 @@ set_value_range (value_range *vr, enum value_range_type t, tree min,\n \n       gcc_assert (min && max);\n \n-      gcc_assert ((!TREE_OVERFLOW_P (min) || is_overflow_infinity (min))\n-\t\t  && (!TREE_OVERFLOW_P (max) || is_overflow_infinity (max)));\n+      gcc_assert (!TREE_OVERFLOW_P (min) && !TREE_OVERFLOW_P (max));\n \n       if (INTEGRAL_TYPE_P (TREE_TYPE (min)) && t == VR_ANTI_RANGE)\n \tgcc_assert (!vrp_val_is_min (min) || !vrp_val_is_max (max));\n@@ -553,23 +431,10 @@ set_value_range_to_value (value_range *vr, tree val, bitmap equiv)\n    overflow does not occur.  */\n \n static inline void\n-set_value_range_to_nonnegative (value_range *vr, tree type,\n-\t\t\t\tbool overflow_infinity)\n+set_value_range_to_nonnegative (value_range *vr, tree type)\n {\n-  tree zero;\n-\n-  if (overflow_infinity && !supports_overflow_infinity (type))\n-    {\n-      set_value_range_to_varying (vr);\n-      return;\n-    }\n-\n-  zero = build_int_cst (type, 0);\n-  set_value_range (vr, VR_RANGE, zero,\n-\t\t   (overflow_infinity\n-\t\t    ? positive_overflow_infinity (type)\n-\t\t    : TYPE_MAX_VALUE (type)),\n-\t\t   vr->equiv);\n+  tree zero = build_int_cst (type, 0);\n+  set_value_range (vr, VR_RANGE, zero, vrp_val_max (type), vr->equiv);\n }\n \n /* Set value range VR to a non-NULL range of type TYPE.  */\n@@ -743,7 +608,7 @@ vrp_operand_equal_p (const_tree val1, const_tree val2)\n     return true;\n   if (!val1 || !val2 || !operand_equal_p (val1, val2, 0))\n     return false;\n-  return is_overflow_infinity (val1) == is_overflow_infinity (val2);\n+  return true;\n }\n \n /* Return true, if the bitmaps B1 and B2 are equal.  */\n@@ -783,26 +648,8 @@ update_value_range (const_tree var, value_range *new_vr)\n       if (rtype == VR_RANGE || rtype == VR_ANTI_RANGE)\n \t{\n \t  tree nr_min, nr_max;\n-\t  /* Range info on SSA names doesn't carry overflow information\n-\t     so make sure to preserve the overflow bit on the lattice.  */\n-\t  if (rtype == VR_RANGE\n-\t      && needs_overflow_infinity (TREE_TYPE (var))\n-\t      && (new_vr->type == VR_VARYING\n-\t\t  || (new_vr->type == VR_RANGE\n-\t\t      && is_negative_overflow_infinity (new_vr->min)))\n-\t      && wi::eq_p (vrp_val_min (TREE_TYPE (var)), min))\n-\t    nr_min = negative_overflow_infinity (TREE_TYPE (var));\n-\t  else\n-\t    nr_min = wide_int_to_tree (TREE_TYPE (var), min);\n-\t  if (rtype == VR_RANGE\n-\t      && needs_overflow_infinity (TREE_TYPE (var))\n-\t      && (new_vr->type == VR_VARYING\n-\t\t  || (new_vr->type == VR_RANGE\n-\t\t      && is_positive_overflow_infinity (new_vr->max)))\n-\t      && wi::eq_p (vrp_val_max (TREE_TYPE (var)), max))\n-\t    nr_max = positive_overflow_infinity (TREE_TYPE (var));\n-\t  else\n-\t    nr_max = wide_int_to_tree (TREE_TYPE (var), max);\n+\t  nr_min = wide_int_to_tree (TREE_TYPE (var), min);\n+\t  nr_max = wide_int_to_tree (TREE_TYPE (var), max);\n \t  value_range nr = VR_INITIALIZER;\n \t  set_and_canonicalize_value_range (&nr, rtype, nr_min, nr_max, NULL);\n \t  vrp_intersect_ranges (new_vr, &nr);\n@@ -897,8 +744,6 @@ static inline bool\n range_int_cst_singleton_p (value_range *vr)\n {\n   return (range_int_cst_p (vr)\n-\t  && !is_overflow_infinity (vr->min)\n-\t  && !is_overflow_infinity (vr->max)\n \t  && tree_int_cst_equal (vr->min, vr->max));\n }\n \n@@ -1006,41 +851,6 @@ symbolic_range_based_on_p (value_range *vr, const_tree sym)\n   return (min_has_symbol || max_has_symbol);\n }\n \n-/* Return true if value range VR uses an overflow infinity.  */\n-\n-static inline bool\n-overflow_infinity_range_p (value_range *vr)\n-{\n-  return (vr->type == VR_RANGE\n-\t  && (is_overflow_infinity (vr->min)\n-\t      || is_overflow_infinity (vr->max)));\n-}\n-\n-/* Return false if we can not make a valid comparison based on VR;\n-   this will be the case if it uses an overflow infinity and overflow\n-   is not undefined (i.e., -fno-strict-overflow is in effect).\n-   Otherwise return true, and set *STRICT_OVERFLOW_P to true if VR\n-   uses an overflow infinity.  */\n-\n-static bool\n-usable_range_p (value_range *vr, bool *strict_overflow_p)\n-{\n-  gcc_assert (vr->type == VR_RANGE);\n-  if (is_overflow_infinity (vr->min))\n-    {\n-      *strict_overflow_p = true;\n-      if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (vr->min)))\n-\treturn false;\n-    }\n-  if (is_overflow_infinity (vr->max))\n-    {\n-      *strict_overflow_p = true;\n-      if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (vr->max)))\n-\treturn false;\n-    }\n-  return true;\n-}\n-\n /* Return true if the result of assignment STMT is know to be non-zero.\n    If the return value is based on the assumption that signed overflow is\n    undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change\n@@ -1180,10 +990,7 @@ operand_less_p (tree val, tree val2)\n {\n   /* LT is folded faster than GE and others.  Inline the common case.  */\n   if (TREE_CODE (val) == INTEGER_CST && TREE_CODE (val2) == INTEGER_CST)\n-    {\n-      if (! is_positive_overflow_infinity (val2))\n-\treturn tree_int_cst_lt (val, val2);\n-    }\n+    return tree_int_cst_lt (val, val2);\n   else\n     {\n       tree tcmp;\n@@ -1202,12 +1009,6 @@ operand_less_p (tree val, tree val2)\n \treturn 1;\n     }\n \n-  /* val >= val2, not considering overflow infinity.  */\n-  if (is_negative_overflow_infinity (val))\n-    return is_negative_overflow_infinity (val2) ? 0 : 1;\n-  else if (is_positive_overflow_infinity (val2))\n-    return is_positive_overflow_infinity (val) ? 0 : 1;\n-\n   return 0;\n }\n \n@@ -1323,14 +1124,6 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n \t{\n \t  if (strict_overflow_p != NULL)\n \t    *strict_overflow_p = true;\n-\t  if (is_negative_overflow_infinity (val1))\n-\t    return is_negative_overflow_infinity (val2) ? 0 : -1;\n-\t  else if (is_negative_overflow_infinity (val2))\n-\t    return 1;\n-\t  else if (is_positive_overflow_infinity (val1))\n-\t    return is_positive_overflow_infinity (val2) ? 0 : 1;\n-\t  else if (is_positive_overflow_infinity (val2))\n-\t    return -1;\n \t  return -2;\n \t}\n \n@@ -1523,7 +1316,6 @@ extract_range_for_var_from_comparison_expr (tree var, enum tree_code cond_code,\n {\n   tree  min, max, type;\n   value_range *limit_vr;\n-  limit = avoid_overflow_infinity (limit);\n   type = TREE_TYPE (var);\n   gcc_assert (limit != var);\n \n@@ -1691,9 +1483,8 @@ extract_range_for_var_from_comparison_expr (tree var, enum tree_code cond_code,\n       /* If the maximum value forces us to be out of bounds, simply punt.\n \t It would be pointless to try and do anything more since this\n \t all should be optimized away above us.  */\n-      if ((cond_code == LT_EXPR\n-\t   && compare_values (max, min) == 0)\n-\t  || is_overflow_infinity (max))\n+      if (cond_code == LT_EXPR\n+\t  && compare_values (max, min) == 0)\n \tset_value_range_to_varying (vr_p);\n       else\n \t{\n@@ -1731,9 +1522,8 @@ extract_range_for_var_from_comparison_expr (tree var, enum tree_code cond_code,\n       /* If the minimum value forces us to be out of bounds, simply punt.\n \t It would be pointless to try and do anything more since this\n \t all should be optimized away above us.  */\n-      if ((cond_code == GT_EXPR\n-\t   && compare_values (min, max) == 0)\n-\t  || is_overflow_infinity (min))\n+      if (cond_code == GT_EXPR\n+\t  && compare_values (min, max) == 0)\n \tset_value_range_to_varying (vr_p);\n       else\n \t{\n@@ -1884,42 +1674,16 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n      returns NULL_TREE.  */\n   else if (!res)\n     return NULL_TREE;\n-  else if ((TREE_OVERFLOW (res)\n-\t    && !TREE_OVERFLOW (val1)\n-\t    && !TREE_OVERFLOW (val2))\n-\t   || is_overflow_infinity (val1)\n-\t   || is_overflow_infinity (val2))\n+  else if (TREE_OVERFLOW (res)\n+\t   && ! TREE_OVERFLOW (val1)\n+\t   && ! TREE_OVERFLOW (val2))\n     {\n       /* If the operation overflowed but neither VAL1 nor VAL2 are\n \t overflown, return -INF or +INF depending on the operation\n \t and the combination of signs of the operands.  */\n       int sgn1 = tree_int_cst_sgn (val1);\n       int sgn2 = tree_int_cst_sgn (val2);\n \n-      if (needs_overflow_infinity (TREE_TYPE (res))\n-\t  && !supports_overflow_infinity (TREE_TYPE (res)))\n-\treturn NULL_TREE;\n-\n-      /* We have to punt on adding infinities of different signs,\n-\t since we can't tell what the sign of the result should be.\n-\t Likewise for subtracting infinities of the same sign.  */\n-      if (((code == PLUS_EXPR && sgn1 != sgn2)\n-\t   || (code == MINUS_EXPR && sgn1 == sgn2))\n-\t  && is_overflow_infinity (val1)\n-\t  && is_overflow_infinity (val2))\n-\treturn NULL_TREE;\n-\n-      /* Don't try to handle division or shifting of infinities.  */\n-      if ((code == TRUNC_DIV_EXPR\n-\t   || code == FLOOR_DIV_EXPR\n-\t   || code == CEIL_DIV_EXPR\n-\t   || code == EXACT_DIV_EXPR\n-\t   || code == ROUND_DIV_EXPR\n-\t   || code == RSHIFT_EXPR)\n-\t  && (is_overflow_infinity (val1)\n-\t      || is_overflow_infinity (val2)))\n-\treturn NULL_TREE;\n-\n       /* Notice that we only need to handle the restricted set of\n \t operations handled by extract_range_from_binary_expr.\n \t Among them, only multiplication, addition and subtraction\n@@ -1933,23 +1697,15 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n       if ((code == MULT_EXPR && sgn1 == sgn2)\n           /* For addition, the operands must be of the same sign\n \t     to yield an overflow.  Its sign is therefore that\n-\t     of one of the operands, for example the first.  For\n-\t     infinite operands X + -INF is negative, not positive.  */\n-\t  || (code == PLUS_EXPR\n-\t      && (sgn1 >= 0\n-\t\t  ? !is_negative_overflow_infinity (val2)\n-\t\t  : is_positive_overflow_infinity (val2)))\n-\t  /* For subtraction, non-infinite operands must be of\n+\t     of one of the operands, for example the first.  */\n+\t  || (code == PLUS_EXPR && sgn1 >= 0)\n+\t  /* For subtraction, operands must be of\n \t     different signs to yield an overflow.  Its sign is\n \t     therefore that of the first operand or the opposite of\n \t     that of the second operand.  A first operand of 0 counts\n \t     as positive here, for the corner case 0 - (-INF), which\n-\t     overflows, but must yield +INF.  For infinite operands 0\n-\t     - INF is negative, not positive.  */\n-\t  || (code == MINUS_EXPR\n-\t      && (sgn1 >= 0\n-\t\t  ? !is_positive_overflow_infinity (val2)\n-\t\t  : is_negative_overflow_infinity (val2)))\n+\t     overflows, but must yield +INF.  */\n+\t  || (code == MINUS_EXPR && sgn1 >= 0)\n \t  /* We only get in here with positive shift count, so the\n \t     overflow direction is the same as the sign of val1.\n \t     Actually rshift does not overflow at all, but we only\n@@ -1962,13 +1718,9 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n \t  || code == CEIL_DIV_EXPR\n \t  || code == EXACT_DIV_EXPR\n \t  || code == ROUND_DIV_EXPR)\n-\treturn (needs_overflow_infinity (TREE_TYPE (res))\n-\t\t? positive_overflow_infinity (TREE_TYPE (res))\n-\t\t: TYPE_MAX_VALUE (TREE_TYPE (res)));\n+\treturn TYPE_MAX_VALUE (TREE_TYPE (res));\n       else\n-\treturn (needs_overflow_infinity (TREE_TYPE (res))\n-\t\t? negative_overflow_infinity (TREE_TYPE (res))\n-\t\t: TYPE_MIN_VALUE (TREE_TYPE (res)));\n+\treturn TYPE_MIN_VALUE (TREE_TYPE (res));\n     }\n \n   return res;\n@@ -1989,9 +1741,7 @@ zero_nonzero_bits_from_vr (const tree expr_type,\n {\n   *may_be_nonzero = wi::minus_one (TYPE_PRECISION (expr_type));\n   *must_be_nonzero = wi::zero (TYPE_PRECISION (expr_type));\n-  if (!range_int_cst_p (vr)\n-      || is_overflow_infinity (vr->min)\n-      || is_overflow_infinity (vr->max))\n+  if (!range_int_cst_p (vr))\n     return false;\n \n   if (range_int_cst_singleton_p (vr))\n@@ -2146,16 +1896,15 @@ extract_range_from_multiplicative_op_1 (value_range *vr,\n   for (i = 1; i < 4; i++)\n     {\n       if (!is_gimple_min_invariant (min)\n-\t  || (TREE_OVERFLOW (min) && !is_overflow_infinity (min))\n+\t  || TREE_OVERFLOW (min)\n \t  || !is_gimple_min_invariant (max)\n-\t  || (TREE_OVERFLOW (max) && !is_overflow_infinity (max)))\n+\t  || TREE_OVERFLOW (max))\n \tbreak;\n \n       if (val[i])\n \t{\n \t  if (!is_gimple_min_invariant (val[i])\n-\t      || (TREE_OVERFLOW (val[i])\n-\t\t  && !is_overflow_infinity (val[i])))\n+\t      || TREE_OVERFLOW (val[i]))\n \t    {\n \t      /* If we found an overflowed value, set MIN and MAX\n \t\t to it so that we set the resulting range to\n@@ -2177,25 +1926,20 @@ extract_range_from_multiplicative_op_1 (value_range *vr,\n      representation.  */\n   if (min == NULL_TREE\n       || !is_gimple_min_invariant (min)\n-      || (TREE_OVERFLOW (min) && !is_overflow_infinity (min))\n+      || TREE_OVERFLOW (min)\n       || max == NULL_TREE\n       || !is_gimple_min_invariant (max)\n-      || (TREE_OVERFLOW (max) && !is_overflow_infinity (max)))\n+      || TREE_OVERFLOW (max))\n     {\n       set_value_range_to_varying (vr);\n       return;\n     }\n \n-  /* We punt if:\n-     1) [-INF, +INF]\n-     2) [-INF, +-INF(OVF)]\n-     3) [+-INF(OVF), +INF]\n-     4) [+-INF(OVF), +-INF(OVF)]\n-     We learn nothing when we have INF and INF(OVF) on both sides.\n-     Note that we do accept [-INF, -INF] and [+INF, +INF] without\n-     overflow.  */\n-  if ((vrp_val_is_min (min) || is_overflow_infinity (min))\n-      && (vrp_val_is_max (max) || is_overflow_infinity (max)))\n+  /* We punt for [-INF, +INF].\n+     We learn nothing when we have INF on both sides.\n+     Note that we do accept [-INF, -INF] and [+INF, +INF].  */\n+  if (vrp_val_is_min (min)\n+      && vrp_val_is_max (max))\n     {\n       set_value_range_to_varying (vr);\n       return;\n@@ -2609,61 +2353,20 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t      /* If overflow does not wrap, saturate to the types min/max\n \t         value.  */\n \t      if (min_ovf == -1)\n-\t\t{\n-\t\t  if (needs_overflow_infinity (expr_type)\n-\t\t      && supports_overflow_infinity (expr_type))\n-\t\t    min = negative_overflow_infinity (expr_type);\n-\t\t  else\n-\t\t    min = wide_int_to_tree (expr_type, type_min);\n-\t\t}\n+\t\tmin = wide_int_to_tree (expr_type, type_min);\n \t      else if (min_ovf == 1)\n-\t\t{\n-\t\t  if (needs_overflow_infinity (expr_type)\n-\t\t      && supports_overflow_infinity (expr_type))\n-\t\t    min = positive_overflow_infinity (expr_type);\n-\t\t  else\n-\t\t    min = wide_int_to_tree (expr_type, type_max);\n-\t\t}\n+\t\tmin = wide_int_to_tree (expr_type, type_max);\n \t      else\n \t\tmin = wide_int_to_tree (expr_type, wmin);\n \n \t      if (max_ovf == -1)\n-\t\t{\n-\t\t  if (needs_overflow_infinity (expr_type)\n-\t\t      && supports_overflow_infinity (expr_type))\n-\t\t    max = negative_overflow_infinity (expr_type);\n-\t\t  else\n-\t\t    max = wide_int_to_tree (expr_type, type_min);\n-\t\t}\n+\t\tmax = wide_int_to_tree (expr_type, type_min);\n \t      else if (max_ovf == 1)\n-\t\t{\n-\t\t  if (needs_overflow_infinity (expr_type)\n-\t\t      && supports_overflow_infinity (expr_type))\n-\t\t    max = positive_overflow_infinity (expr_type);\n-\t\t  else\n-\t\t    max = wide_int_to_tree (expr_type, type_max);\n-\t\t}\n+\t\tmax = wide_int_to_tree (expr_type, type_max);\n \t      else\n \t\tmax = wide_int_to_tree (expr_type, wmax);\n \t    }\n \n-\t  if (needs_overflow_infinity (expr_type)\n-\t      && supports_overflow_infinity (expr_type))\n-\t    {\n-\t      if ((min_op0 && is_negative_overflow_infinity (min_op0))\n-\t\t  || (min_op1\n-\t\t      && (minus_p\n-\t\t\t  ? is_positive_overflow_infinity (min_op1)\n-\t\t\t  : is_negative_overflow_infinity (min_op1))))\n-\t\tmin = negative_overflow_infinity (expr_type);\n-\t      if ((max_op0 && is_positive_overflow_infinity (max_op0))\n-\t\t  || (max_op1\n-\t\t      && (minus_p\n-\t\t\t  ? is_negative_overflow_infinity (max_op1)\n-\t\t\t  : is_positive_overflow_infinity (max_op1))))\n-\t\tmax = positive_overflow_infinity (expr_type);\n-\t    }\n-\n \t  /* If the result lower bound is constant, we're done;\n \t     otherwise, build the symbolic lower bound.  */\n \t  if (sym_min_op0 == sym_min_op1)\n@@ -3251,26 +2954,20 @@ extract_range_from_binary_expr_1 (value_range *vr,\n     gcc_unreachable ();\n \n   /* If either MIN or MAX overflowed, then set the resulting range to\n-     VARYING.  But we do accept an overflow infinity representation.  */\n+     VARYING.  */\n   if (min == NULL_TREE\n-      || (TREE_OVERFLOW_P (min) && !is_overflow_infinity (min))\n+      || TREE_OVERFLOW_P (min)\n       || max == NULL_TREE\n-      || (TREE_OVERFLOW_P (max) && !is_overflow_infinity (max)))\n+      || TREE_OVERFLOW_P (max))\n     {\n       set_value_range_to_varying (vr);\n       return;\n     }\n \n-  /* We punt if:\n-     1) [-INF, +INF]\n-     2) [-INF, +-INF(OVF)]\n-     3) [+-INF(OVF), +INF]\n-     4) [+-INF(OVF), +-INF(OVF)]\n-     We learn nothing when we have INF and INF(OVF) on both sides.\n-     Note that we do accept [-INF, -INF] and [+INF, +INF] without\n-     overflow.  */\n-  if ((vrp_val_is_min (min) || is_overflow_infinity (min))\n-      && (vrp_val_is_max (max) || is_overflow_infinity (max)))\n+  /* We punt for [-INF, +INF].\n+     We learn nothing when we have INF on both sides.\n+     Note that we do accept [-INF, -INF] and [+INF, +INF].  */\n+  if (vrp_val_is_min (min) && vrp_val_is_max (max))\n     {\n       set_value_range_to_varying (vr);\n       return;\n@@ -3497,33 +3194,17 @@ extract_range_from_unary_expr (value_range *vr,\n \t   || vr0.type == VR_ANTI_RANGE)\n \t  && TREE_CODE (vr0.min) == INTEGER_CST\n \t  && TREE_CODE (vr0.max) == INTEGER_CST\n-\t  && (!is_overflow_infinity (vr0.min)\n-\t      || (vr0.type == VR_RANGE\n-\t\t  && TYPE_PRECISION (outer_type) > TYPE_PRECISION (inner_type)\n-\t\t  && needs_overflow_infinity (outer_type)\n-\t\t  && supports_overflow_infinity (outer_type)))\n-\t  && (!is_overflow_infinity (vr0.max)\n-\t      || (vr0.type == VR_RANGE\n-\t\t  && TYPE_PRECISION (outer_type) > TYPE_PRECISION (inner_type)\n-\t\t  && needs_overflow_infinity (outer_type)\n-\t\t  && supports_overflow_infinity (outer_type)))\n \t  && (TYPE_PRECISION (outer_type) >= TYPE_PRECISION (inner_type)\n \t      || (vr0.type == VR_RANGE\n \t\t  && integer_zerop (int_const_binop (RSHIFT_EXPR,\n \t\t       int_const_binop (MINUS_EXPR, vr0.max, vr0.min),\n \t\t         size_int (TYPE_PRECISION (outer_type)))))))\n \t{\n \t  tree new_min, new_max;\n-\t  if (is_overflow_infinity (vr0.min))\n-\t    new_min = negative_overflow_infinity (outer_type);\n-\t  else\n-\t    new_min = force_fit_type (outer_type, wi::to_widest (vr0.min),\n-\t\t\t\t      0, false);\n-\t  if (is_overflow_infinity (vr0.max))\n-\t    new_max = positive_overflow_infinity (outer_type);\n-\t  else\n-\t    new_max = force_fit_type (outer_type, wi::to_widest (vr0.max),\n-\t\t\t\t      0, false);\n+\t  new_min = force_fit_type (outer_type, wi::to_widest (vr0.min),\n+\t\t\t\t    0, false);\n+\t  new_max = force_fit_type (outer_type, wi::to_widest (vr0.max),\n+\t\t\t\t    0, false);\n \t  set_and_canonicalize_value_range (vr, vr0.type,\n \t\t\t\t\t    new_min, new_max, NULL);\n \t  return;\n@@ -3568,36 +3249,15 @@ extract_range_from_unary_expr (value_range *vr,\n \n       /* ABS_EXPR may flip the range around, if the original range\n \t included negative values.  */\n-      if (is_overflow_infinity (vr0.min))\n-\tmin = positive_overflow_infinity (type);\n-      else if (!vrp_val_is_min (vr0.min))\n+      if (!vrp_val_is_min (vr0.min))\n \tmin = fold_unary_to_constant (code, type, vr0.min);\n-      else if (!needs_overflow_infinity (type))\n-\tmin = TYPE_MAX_VALUE (type);\n-      else if (supports_overflow_infinity (type))\n-\tmin = positive_overflow_infinity (type);\n       else\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n+\tmin = TYPE_MAX_VALUE (type);\n \n-      if (is_overflow_infinity (vr0.max))\n-\tmax = positive_overflow_infinity (type);\n-      else if (!vrp_val_is_min (vr0.max))\n+      if (!vrp_val_is_min (vr0.max))\n \tmax = fold_unary_to_constant (code, type, vr0.max);\n-      else if (!needs_overflow_infinity (type))\n-\tmax = TYPE_MAX_VALUE (type);\n-      else if (supports_overflow_infinity (type)\n-\t       /* We shouldn't generate [+INF, +INF] as set_value_range\n-\t\t  doesn't like this and ICEs.  */\n-\t       && !is_positive_overflow_infinity (min))\n-\tmax = positive_overflow_infinity (type);\n       else\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n+\tmax = TYPE_MAX_VALUE (type);\n \n       cmp = compare_values (min, max);\n \n@@ -3625,12 +3285,7 @@ extract_range_from_unary_expr (value_range *vr,\n \t\t\t : type_min_value);\n \t\t}\n \t      else\n-\t\t{\n-\t\t  if (overflow_infinity_range_p (&vr0))\n-\t\t    min = negative_overflow_infinity (type);\n-\t\t  else\n-\t\t    min = TYPE_MIN_VALUE (type);\n-\t\t}\n+\t\tmin = TYPE_MIN_VALUE (type);\n \t    }\n \t  else\n \t    {\n@@ -3639,18 +3294,7 @@ extract_range_from_unary_expr (value_range *vr,\n \t         anti-range.  */\n \t      vr0.type = VR_RANGE;\n \t      min = build_int_cst (type, 0);\n-\t      if (needs_overflow_infinity (type))\n-\t\t{\n-\t\t  if (supports_overflow_infinity (type))\n-\t\t    max = positive_overflow_infinity (type);\n-\t\t  else\n-\t\t    {\n-\t\t      set_value_range_to_varying (vr);\n-\t\t      return;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tmax = TYPE_MAX_VALUE (type);\n+\t      max = TYPE_MAX_VALUE (type);\n \t    }\n \t}\n \n@@ -3763,7 +3407,7 @@ extract_range_from_comparison (value_range *vr, enum tree_code code,\n      when we don't have an infinity.  So we have to ignore a result\n      which relies on overflow.  */\n \n-  if (val && !is_overflow_infinity (val) && !sop)\n+  if (val && !sop)\n     {\n       /* Since this expression was found on the RHS of an assignment,\n \t its type may be different from _Bool.  Convert VAL to EXPR's\n@@ -3933,20 +3577,17 @@ extract_range_basic (value_range *vr, gimple *stmt)\n \t      value_range *vr0 = get_value_range (arg);\n \t      /* If arg is non-zero, then ffs or popcount\n \t\t are non-zero.  */\n-\t      if (((vr0->type == VR_RANGE\n-\t\t    && range_includes_zero_p (vr0->min, vr0->max) == 0)\n-\t\t   || (vr0->type == VR_ANTI_RANGE\n-\t\t       && range_includes_zero_p (vr0->min, vr0->max) == 1))\n-\t\t  && !is_overflow_infinity (vr0->min)\n-\t\t  && !is_overflow_infinity (vr0->max))\n+\t      if ((vr0->type == VR_RANGE\n+\t\t   && range_includes_zero_p (vr0->min, vr0->max) == 0)\n+\t\t  || (vr0->type == VR_ANTI_RANGE\n+\t\t      && range_includes_zero_p (vr0->min, vr0->max) == 1))\n \t\tmini = 1;\n \t      /* If some high bits are known to be zero,\n \t\t we can decrease the maximum.  */\n \t      if (vr0->type == VR_RANGE\n \t\t  && TREE_CODE (vr0->max) == INTEGER_CST\n \t\t  && !operand_less_p (vr0->min,\n-\t\t\t\t      build_zero_cst (TREE_TYPE (vr0->min)))\n-\t\t  && !is_overflow_infinity (vr0->max))\n+\t\t\t\t      build_zero_cst (TREE_TYPE (vr0->min))))\n \t\tmaxi = tree_floor_log2 (vr0->max) + 1;\n \t    }\n \t  goto bitop_builtin;\n@@ -3980,16 +3621,14 @@ extract_range_basic (value_range *vr, gimple *stmt)\n \t      /* From clz of VR_RANGE minimum we can compute\n \t\t result maximum.  */\n \t      if (vr0->type == VR_RANGE\n-\t\t  && TREE_CODE (vr0->min) == INTEGER_CST\n-\t\t  && !is_overflow_infinity (vr0->min))\n+\t\t  && TREE_CODE (vr0->min) == INTEGER_CST)\n \t\t{\n \t\t  maxi = prec - 1 - tree_floor_log2 (vr0->min);\n \t\t  if (maxi != prec)\n \t\t    mini = 0;\n \t\t}\n \t      else if (vr0->type == VR_ANTI_RANGE\n-\t\t       && integer_zerop (vr0->min)\n-\t\t       && !is_overflow_infinity (vr0->min))\n+\t\t       && integer_zerop (vr0->min))\n \t\t{\n \t\t  maxi = prec - 1;\n \t\t  mini = 0;\n@@ -3999,8 +3638,7 @@ extract_range_basic (value_range *vr, gimple *stmt)\n \t      /* From clz of VR_RANGE maximum we can compute\n \t\t result minimum.  */\n \t      if (vr0->type == VR_RANGE\n-\t\t  && TREE_CODE (vr0->max) == INTEGER_CST\n-\t\t  && !is_overflow_infinity (vr0->max))\n+\t\t  && TREE_CODE (vr0->max) == INTEGER_CST)\n \t\t{\n \t\t  mini = prec - 1 - tree_floor_log2 (vr0->max);\n \t\t  if (mini == prec)\n@@ -4039,20 +3677,18 @@ extract_range_basic (value_range *vr, gimple *stmt)\n \t    {\n \t      value_range *vr0 = get_value_range (arg);\n \t      /* If arg is non-zero, then use [0, prec - 1].  */\n-\t      if (((vr0->type == VR_RANGE\n-\t\t    && integer_nonzerop (vr0->min))\n-\t\t   || (vr0->type == VR_ANTI_RANGE\n-\t\t       && integer_zerop (vr0->min)))\n-\t\t  && !is_overflow_infinity (vr0->min))\n+\t      if ((vr0->type == VR_RANGE\n+\t\t   && integer_nonzerop (vr0->min))\n+\t\t  || (vr0->type == VR_ANTI_RANGE\n+\t\t      && integer_zerop (vr0->min)))\n \t\t{\n \t\t  mini = 0;\n \t\t  maxi = prec - 1;\n \t\t}\n \t      /* If some high bits are known to be zero,\n \t\t we can decrease the result maximum.  */\n \t      if (vr0->type == VR_RANGE\n-\t\t  && TREE_CODE (vr0->max) == INTEGER_CST\n-\t\t  && !is_overflow_infinity (vr0->max))\n+\t\t  && TREE_CODE (vr0->max) == INTEGER_CST)\n \t\t{\n \t\t  maxi = tree_floor_log2 (vr0->max);\n \t\t  /* For vr0 [0, 0] give up.  */\n@@ -4239,8 +3875,7 @@ extract_range_basic (value_range *vr, gimple *stmt)\n     }\n   if (INTEGRAL_TYPE_P (type)\n       && gimple_stmt_nonnegative_warnv_p (stmt, &sop))\n-    set_value_range_to_nonnegative (vr, type,\n-\t\t\t\t    sop || stmt_overflow_infinity (stmt));\n+    set_value_range_to_nonnegative (vr, type);\n   else if (vrp_stmt_computes_nonzero (stmt, &sop)\n \t   && !sop)\n     set_value_range_to_nonnull (vr, type);\n@@ -4406,11 +4041,9 @@ adjust_range_with_scev (value_range *vr, struct loop *loop,\n \t\t     because the loop may exit immediately.  Overflow could\n \t\t     happen in the plus expression in this case.  */\n \t\t  if ((dir == EV_DIR_DECREASES\n-\t\t       && (is_negative_overflow_infinity (maxvr.min)\n-\t\t\t   || compare_values (maxvr.min, initvr.min) != -1))\n+\t\t       && compare_values (maxvr.min, initvr.min) != -1)\n \t\t      || (dir == EV_DIR_GROWS\n-\t\t\t  && (is_positive_overflow_infinity (maxvr.max)\n-\t\t\t      || compare_values (maxvr.max, initvr.max) != 1)))\n+\t\t\t  && compare_values (maxvr.max, initvr.max) != 1))\n \t\t    return;\n \n \t\t  tmin = maxvr.min;\n@@ -4446,11 +4079,8 @@ adjust_range_with_scev (value_range *vr, struct loop *loop,\n \t    max = init;\n \n \t  /* According to the loop information, the variable does not\n-\t     overflow.  If we think it does, probably because of an\n-\t     overflow due to arithmetic on a different INF value,\n-\t     reset now.  */\n-\t  if (is_negative_overflow_infinity (min)\n-\t      || compare_values (min, tmin) == -1)\n+\t     overflow.  */\n+\t  if (compare_values (min, tmin) == -1)\n \t    min = tmin;\n \n \t}\n@@ -4460,8 +4090,7 @@ adjust_range_with_scev (value_range *vr, struct loop *loop,\n \t  if (compare_values (init, min) == 1)\n \t    min = init;\n \n-\t  if (is_positive_overflow_infinity (max)\n-\t      || compare_values (tmax, max) == -1)\n+\t  if (compare_values (tmax, max) == -1)\n \t    max = tmax;\n \t}\n     }\n@@ -4472,20 +4101,15 @@ adjust_range_with_scev (value_range *vr, struct loop *loop,\n      greater than the maximum, we fail conservatively.\n      This should happen only in unreachable\n      parts of code, or for invalid programs.  */\n-  if (compare_values (min, max) == 1\n-      || (is_negative_overflow_infinity (min)\n-\t  && is_positive_overflow_infinity (max)))\n+  if (compare_values (min, max) == 1)\n     return;\n \n   /* Even for valid range info, sometimes overflow flag will leak in.\n      As GIMPLE IL should have no constants with TREE_OVERFLOW set, we\n-     drop them except for +-overflow_infinity which still need special\n-     handling in vrp pass.  */\n-  if (TREE_OVERFLOW_P (min)\n-      && ! is_negative_overflow_infinity (min))\n+     drop them.  */\n+  if (TREE_OVERFLOW_P (min))\n     min = drop_tree_overflow (min);\n-  if (TREE_OVERFLOW_P (max)\n-      && ! is_positive_overflow_infinity (max))\n+  if (TREE_OVERFLOW_P (max))\n     max = drop_tree_overflow (max);\n \n   set_value_range (vr, VR_RANGE, min, max, vr->equiv);\n@@ -4551,10 +4175,6 @@ compare_ranges (enum tree_code comp, value_range *vr0, value_range *vr1,\n       return NULL_TREE;\n     }\n \n-  if (!usable_range_p (vr0, strict_overflow_p)\n-      || !usable_range_p (vr1, strict_overflow_p))\n-    return NULL_TREE;\n-\n   /* Simplify processing.  If COMP is GT_EXPR or GE_EXPR, switch the\n      operands around and change the comparison code.  */\n   if (comp == GT_EXPR || comp == GE_EXPR)\n@@ -4626,23 +4246,13 @@ compare_ranges (enum tree_code comp, value_range *vr0, value_range *vr1,\n       tst = compare_values_warnv (vr0->max, vr1->min, strict_overflow_p);\n       if ((comp == LT_EXPR && tst == -1)\n \t  || (comp == LE_EXPR && (tst == -1 || tst == 0)))\n-\t{\n-\t  if (overflow_infinity_range_p (vr0)\n-\t      || overflow_infinity_range_p (vr1))\n-\t    *strict_overflow_p = true;\n-\t  return boolean_true_node;\n-\t}\n+\treturn boolean_true_node;\n \n       /* If VR0 is to the right of VR1, return false.  */\n       tst = compare_values_warnv (vr0->min, vr1->max, strict_overflow_p);\n       if ((comp == LT_EXPR && (tst == 0 || tst == 1))\n \t  || (comp == LE_EXPR && tst == 1))\n-\t{\n-\t  if (overflow_infinity_range_p (vr0)\n-\t      || overflow_infinity_range_p (vr1))\n-\t    *strict_overflow_p = true;\n-\t  return boolean_false_node;\n-\t}\n+\treturn boolean_false_node;\n \n       /* Otherwise, we don't know.  */\n       return NULL_TREE;\n@@ -4685,9 +4295,6 @@ compare_range_with_value (enum tree_code comp, value_range *vr, tree val,\n       return NULL_TREE;\n     }\n \n-  if (!usable_range_p (vr, strict_overflow_p))\n-    return NULL_TREE;\n-\n   if (comp == EQ_EXPR)\n     {\n       /* EQ_EXPR may only be computed if VR represents exactly\n@@ -4730,21 +4337,13 @@ compare_range_with_value (enum tree_code comp, value_range *vr, tree val,\n       tst = compare_values_warnv (vr->max, val, strict_overflow_p);\n       if ((comp == LT_EXPR && tst == -1)\n \t  || (comp == LE_EXPR && (tst == -1 || tst == 0)))\n-\t{\n-\t  if (overflow_infinity_range_p (vr))\n-\t    *strict_overflow_p = true;\n-\t  return boolean_true_node;\n-\t}\n+\treturn boolean_true_node;\n \n       /* If VR is to the right of VAL, return false.  */\n       tst = compare_values_warnv (vr->min, val, strict_overflow_p);\n       if ((comp == LT_EXPR && (tst == 0 || tst == 1))\n \t  || (comp == LE_EXPR && tst == 1))\n-\t{\n-\t  if (overflow_infinity_range_p (vr))\n-\t    *strict_overflow_p = true;\n-\t  return boolean_false_node;\n-\t}\n+\treturn boolean_false_node;\n \n       /* Otherwise, we don't know.  */\n       return NULL_TREE;\n@@ -4757,21 +4356,13 @@ compare_range_with_value (enum tree_code comp, value_range *vr, tree val,\n       tst = compare_values_warnv (vr->min, val, strict_overflow_p);\n       if ((comp == GT_EXPR && tst == 1)\n \t  || (comp == GE_EXPR && (tst == 0 || tst == 1)))\n-\t{\n-\t  if (overflow_infinity_range_p (vr))\n-\t    *strict_overflow_p = true;\n-\t  return boolean_true_node;\n-\t}\n+\treturn boolean_true_node;\n \n       /* If VR is to the left of VAL, return false.  */\n       tst = compare_values_warnv (vr->max, val, strict_overflow_p);\n       if ((comp == GT_EXPR && (tst == -1 || tst == 0))\n \t  || (comp == GE_EXPR && tst == -1))\n-\t{\n-\t  if (overflow_infinity_range_p (vr))\n-\t    *strict_overflow_p = true;\n-\t  return boolean_false_node;\n-\t}\n+\treturn boolean_false_node;\n \n       /* Otherwise, we don't know.  */\n       return NULL_TREE;\n@@ -4806,21 +4397,17 @@ dump_value_range (FILE *file, const value_range *vr)\n \n       fprintf (file, \"%s[\", (vr->type == VR_ANTI_RANGE) ? \"~\" : \"\");\n \n-      if (is_negative_overflow_infinity (vr->min))\n-\tfprintf (file, \"-INF(OVF)\");\n-      else if (INTEGRAL_TYPE_P (type)\n-\t       && !TYPE_UNSIGNED (type)\n-\t       && vrp_val_is_min (vr->min))\n+      if (INTEGRAL_TYPE_P (type)\n+\t  && !TYPE_UNSIGNED (type)\n+\t  && vrp_val_is_min (vr->min))\n \tfprintf (file, \"-INF\");\n       else\n \tprint_generic_expr (file, vr->min, 0);\n \n       fprintf (file, \", \");\n \n-      if (is_positive_overflow_infinity (vr->max))\n-\tfprintf (file, \"+INF(OVF)\");\n-      else if (INTEGRAL_TYPE_P (type)\n-\t       && vrp_val_is_max (vr->max))\n+      if (INTEGRAL_TYPE_P (type)\n+\t  && vrp_val_is_max (vr->max))\n \tfprintf (file, \"+INF\");\n       else\n \tprint_generic_expr (file, vr->max, 0);\n@@ -9854,8 +9441,7 @@ simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n \n static tree\n test_for_singularity (enum tree_code cond_code, tree op0,\n-\t\t      tree op1, value_range *vr,\n-\t\t      bool *strict_overflow_p)\n+\t\t      tree op1, value_range *vr)\n {\n   tree min = NULL;\n   tree max = NULL;\n@@ -9869,7 +9455,7 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n       min = TYPE_MIN_VALUE (TREE_TYPE (op0));\n \n       max = op1;\n-      if (cond_code == LT_EXPR && !is_overflow_infinity (max))\n+      if (cond_code == LT_EXPR)\n \t{\n \t  tree one = build_int_cst (TREE_TYPE (op0), 1);\n \t  max = fold_build2 (MINUS_EXPR, TREE_TYPE (op0), max, one);\n@@ -9884,7 +9470,7 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n       max = TYPE_MAX_VALUE (TREE_TYPE (op0));\n \n       min = op1;\n-      if (cond_code == GT_EXPR && !is_overflow_infinity (min))\n+      if (cond_code == GT_EXPR)\n \t{\n \t  tree one = build_int_cst (TREE_TYPE (op0), 1);\n \t  min = fold_build2 (PLUS_EXPR, TREE_TYPE (op0), min, one);\n@@ -9906,16 +9492,7 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n \t then there is only one value which can satisfy the condition,\n \t return that value.  */\n       if (operand_equal_p (min, max, 0) && is_gimple_min_invariant (min))\n-\t{\n-\t  if ((cond_code == LE_EXPR || cond_code == LT_EXPR)\n-\t      && is_overflow_infinity (vr->max))\n-\t    *strict_overflow_p = true;\n-\t  if ((cond_code == GE_EXPR || cond_code == GT_EXPR)\n-\t      && is_overflow_infinity (vr->min))\n-\t    *strict_overflow_p = true;\n-\n-\t  return min;\n-\t}\n+\treturn min;\n     }\n   return NULL;\n }\n@@ -9995,12 +9572,8 @@ simplify_cond_using_ranges_1 (gcond *stmt)\n \t able to simplify this conditional. */\n       if (vr->type == VR_RANGE)\n \t{\n-\t  enum warn_strict_overflow_code wc = WARN_STRICT_OVERFLOW_COMPARISON;\n-\t  bool sop = false;\n-\t  tree new_tree = test_for_singularity (cond_code, op0, op1, vr, &sop);\n-\n-\t  if (new_tree\n-\t      && (!sop || TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (op0))))\n+\t  tree new_tree = test_for_singularity (cond_code, op0, op1, vr);\n+\t  if (new_tree)\n \t    {\n \t      if (dump_file)\n \t\t{\n@@ -10021,30 +9594,16 @@ simplify_cond_using_ranges_1 (gcond *stmt)\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \n-\t      if (sop && issue_strict_overflow_warning (wc))\n-\t        {\n-\t          location_t location = input_location;\n-\t          if (gimple_has_location (stmt))\n-\t\t    location = gimple_location (stmt);\n-\n-\t          warning_at (location, OPT_Wstrict_overflow,\n-\t\t\t      \"assuming signed overflow does not occur when \"\n-\t\t\t      \"simplifying conditional\");\n-\t        }\n-\n \t      return true;\n \t    }\n \n \t  /* Try again after inverting the condition.  We only deal\n \t     with integral types here, so no need to worry about\n \t     issues with inverting FP comparisons.  */\n-\t  sop = false;\n \t  new_tree = test_for_singularity\n \t\t       (invert_tree_comparison (cond_code, false),\n-\t\t\top0, op1, vr, &sop);\n-\n-\t  if (new_tree\n-\t      && (!sop || TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (op0))))\n+\t\t\top0, op1, vr);\n+\t  if (new_tree)\n \t    {\n \t      if (dump_file)\n \t\t{\n@@ -10065,17 +9624,6 @@ simplify_cond_using_ranges_1 (gcond *stmt)\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \n-\t      if (sop && issue_strict_overflow_warning (wc))\n-\t        {\n-\t          location_t location = input_location;\n-\t          if (gimple_has_location (stmt))\n-\t\t    location = gimple_location (stmt);\n-\n-\t          warning_at (location, OPT_Wstrict_overflow,\n-\t\t\t      \"assuming signed overflow does not occur when \"\n-\t\t\t      \"simplifying conditional\");\n-\t        }\n-\n \t      return true;\n \t    }\n \t}\n@@ -10128,33 +9676,8 @@ simplify_cond_using_ranges_2 (gcond *stmt)\n \t      && range_fits_type_p (vr,\n \t\t\t\t    TYPE_PRECISION (TREE_TYPE (op0)),\n \t\t\t\t    TYPE_SIGN (TREE_TYPE (op0)))\n-\t      && int_fits_type_p (op1, TREE_TYPE (innerop))\n-\t      /* The range must not have overflowed, or if it did overflow\n-\t\t we must not be wrapping/trapping overflow and optimizing\n-\t\t with strict overflow semantics.  */\n-\t      && ((!is_negative_overflow_infinity (vr->min)\n-\t           && !is_positive_overflow_infinity (vr->max))\n-\t\t  || TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (innerop))))\n+\t      && int_fits_type_p (op1, TREE_TYPE (innerop)))\n \t    {\n-\t      /* If the range overflowed and the user has asked for warnings\n-\t\t when strict overflow semantics were used to optimize code,\n-\t\t issue an appropriate warning.  */\n-\t      if (cond_code != EQ_EXPR && cond_code != NE_EXPR\n-\t\t  && (is_negative_overflow_infinity (vr->min)\n-\t\t      || is_positive_overflow_infinity (vr->max))\n-\t\t  && issue_strict_overflow_warning (WARN_STRICT_OVERFLOW_CONDITIONAL))\n-\t\t{\n-\t\t  location_t location;\n-\n-\t\t  if (!gimple_has_location (stmt))\n-\t\t    location = input_location;\n-\t\t  else\n-\t\t    location = gimple_location (stmt);\n-\t\t  warning_at (location, OPT_Wstrict_overflow,\n-\t\t\t      \"assuming signed overflow does not occur when \"\n-\t\t\t      \"simplifying conditional\");\n-\t\t}\n-\n \t      tree newconst = fold_convert (TREE_TYPE (innerop), op1);\n \t      gimple_cond_set_lhs (stmt, innerop);\n \t      gimple_cond_set_rhs (stmt, newconst);"}]}