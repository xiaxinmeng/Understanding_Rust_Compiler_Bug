{"sha": "437bae3f742fc7f73ca0755a9e23c503aea872e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM3YmFlM2Y3NDJmYzdmNzNjYTA3NTVhOWUyM2M1MDNhZWE4NzJlMQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-06-06T10:37:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:37:16Z"}, "message": "sem_ch12.adb (Analyze_Associations): Diagnose use of an others association in an instance.\n\n2007-04-20  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Associations): Diagnose use of an others\n\tassociation in an instance.\n\t(Copy_Generic_Node): If the node is a string literal, no need to copy\n\tits descendants.\n\t(Is_Generic_Formal): For a formal subprogram, the declaration is the\n\tgrandparent of the entity.\n\t(Analyze_Formal_Interface_Type): Transform into a full type declaration,\n\tto simplify handling of formal interfaces that derive from other formal\n\tinterfaces.\n\t(Instantiate_Subprogram_Body): The defining unit name of the body of\n\tthe instance should be a defining identifier.\n\t(Install_Formal_Packages): make global to the package, for use in\n\tinstantiations of child units.\n\t(Analyze_Package_Instantiation): Do not attempt to set information on an\n\tenclosing master of an entry when expansion is disabled.\n\t(Instantiate_Type): If the actual is a tagged synchronized type and the\n\tgeneric ancestor is an interface, create a generic actual for the\n\tcorresponding record.\n\t(Analyze_Formal_Derived_Interface_Type): Rewrite as a derived type\n\tdeclaration, to ensure that the interface list is processed correctly.\n\t(Inline_Instance_Body): If enclosing scope is an instance body, remove\n\tits entities from visibiility as well.\n\t(Pre_Analyze_Actuals): if the actual is an allocator with  constraints\n\tgiven with a named association, analyze the expression only, not the\n\tdiscriminant association itself.\n\t(Reset_Entity): If the analysis of a selected component is transformed\n\tinto an expanded name in the prefix of a call with parameters, do not\n\ttransform the original node into an expanded name, to prevent visibility\n\terrors in the case of nested generics.\n\t(Check_Private_View): For an array type, check whether the index types\n\tmay need exchanging.\n\nFrom-SVN: r125431", "tree": {"sha": "ab28dbed29b1ad48b10bad1f35625943f1666232", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab28dbed29b1ad48b10bad1f35625943f1666232"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/437bae3f742fc7f73ca0755a9e23c503aea872e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437bae3f742fc7f73ca0755a9e23c503aea872e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/437bae3f742fc7f73ca0755a9e23c503aea872e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437bae3f742fc7f73ca0755a9e23c503aea872e1/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f35b24e9cc18e2f917aa52dfaea8cf88a85cbb68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35b24e9cc18e2f917aa52dfaea8cf88a85cbb68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f35b24e9cc18e2f917aa52dfaea8cf88a85cbb68"}], "stats": {"total": 621, "additions": 433, "deletions": 188}, "files": [{"sha": "d3eb0f8962f306733d7e829f89463b346d82d2dd", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 433, "deletions": 188, "changes": 621, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437bae3f742fc7f73ca0755a9e23c503aea872e1/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437bae3f742fc7f73ca0755a9e23c503aea872e1/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=437bae3f742fc7f73ca0755a9e23c503aea872e1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -305,14 +305,20 @@ package body Sem_Ch12 is\n    --  The following procedures treat other kinds of formal parameters\n \n    procedure Analyze_Formal_Derived_Interface_Type\n-     (T   : Entity_Id;\n+     (N   : Node_Id;\n+      T   : Entity_Id;\n       Def : Node_Id);\n \n    procedure Analyze_Formal_Derived_Type\n      (N   : Node_Id;\n       T   : Entity_Id;\n       Def : Node_Id);\n \n+   procedure Analyze_Formal_Interface_Type\n+     (N   : Node_Id;\n+      T   : Entity_Id;\n+      Def : Node_Id);\n+\n    --  The following subprograms create abbreviated declarations for formal\n    --  scalar types. We introduce an anonymous base of the proper class for\n    --  each of them, and define the formals as constrained first subtypes of\n@@ -323,7 +329,6 @@ package body Sem_Ch12 is\n                                                 (T : Entity_Id; Def : Node_Id);\n    procedure Analyze_Formal_Discrete_Type       (T : Entity_Id; Def : Node_Id);\n    procedure Analyze_Formal_Floating_Type       (T : Entity_Id; Def : Node_Id);\n-   procedure Analyze_Formal_Interface_Type      (T : Entity_Id; Def : Node_Id);\n    procedure Analyze_Formal_Signed_Integer_Type (T : Entity_Id; Def : Node_Id);\n    procedure Analyze_Formal_Modular_Type        (T : Entity_Id; Def : Node_Id);\n    procedure Analyze_Formal_Ordinary_Fixed_Point_Type\n@@ -527,6 +532,14 @@ package body Sem_Ch12 is\n    --  Save_Env because data-structures for visibility handling must be\n    --  initialized before call to Check_Generic_Child_Unit.\n \n+   procedure Install_Formal_Packages (Par : Entity_Id);\n+   --  If any of the formals of the parent are formal packages with box,\n+   --  their formal parts are visible in the parent and thus in the child\n+   --  unit as well. Analogous to what is done in Check_Generic_Actuals\n+   --  for the unit itself. This procedure is also used in an instance, to\n+   --  make visible the proper entities of the actual for a formal package\n+   --  declared with a box.\n+\n    procedure Install_Parent (P : Entity_Id; In_Body : Boolean := False);\n    --  When compiling an instance of a child unit the parent (which is\n    --  itself an instance) is an enclosing scope that must be made\n@@ -561,7 +574,7 @@ package body Sem_Ch12 is\n      (Formal          : Node_Id;\n       Actual          : Node_Id;\n       Analyzed_Formal : Node_Id;\n-      Actual_Decls    : List_Id) return Node_Id;\n+      Actual_Decls    : List_Id) return List_Id;\n \n    function Instantiate_Formal_Subprogram\n      (Formal          : Node_Id;\n@@ -927,7 +940,9 @@ package body Sem_Ch12 is\n \n          --  End of list of purely positional parameters\n \n-         if No (Actual) then\n+         if No (Actual)\n+           or else Nkind (Actual) = N_Others_Choice\n+         then\n             Found_Assoc := Empty;\n             Act         := Empty;\n \n@@ -1000,26 +1015,36 @@ package body Sem_Ch12 is\n \n       procedure Process_Default (F : Entity_Id)  is\n          Loc     : constant Source_Ptr := Sloc (I_Node);\n+         Decl    : Node_Id;\n          Default : Node_Id;\n          Id      : Entity_Id;\n \n       begin\n-         --  Append copy of formal declaration to associations.\n+         --  Append copy of formal declaration to associations, and create\n+         --  new defining identifier for it.\n \n-         Append (New_Copy_Tree (F), Assoc);\n+         Decl := New_Copy_Tree (F);\n \n-         if No (Found_Assoc) then\n-            if Nkind (F) = N_Formal_Concrete_Subprogram_Declaration then\n-               Id := Defining_Entity (F);\n-            else\n-               Id := Defining_Identifier (F);\n-            end if;\n+         if Nkind (F) = N_Formal_Concrete_Subprogram_Declaration then\n+            Id :=\n+               Make_Defining_Identifier (Sloc (Defining_Entity (F)),\n+                 Chars => Chars (Defining_Entity (F)));\n+            Set_Defining_Unit_Name (Specification (Decl), Id);\n \n+         else\n+            Id :=\n+              Make_Defining_Identifier (Sloc (Defining_Entity (F)),\n+                Chars => Chars (Defining_Identifier (F)));\n+            Set_Defining_Identifier (Decl, Id);\n+         end if;\n+\n+         Append (Decl, Assoc);\n+\n+         if No (Found_Assoc) then\n             Default :=\n                Make_Generic_Association (Loc,\n-               Selector_Name                     =>\n-                 New_Occurrence_Of (Id, Loc),\n-               Explicit_Generic_Actual_Parameter => Empty);\n+                 Selector_Name => New_Occurrence_Of (Id, Loc),\n+                 Explicit_Generic_Actual_Parameter => Empty);\n             Set_Box_Present (Default);\n             Append (Default, Default_Formals);\n          end if;\n@@ -1092,8 +1117,28 @@ package body Sem_Ch12 is\n                   Error_Msg_N (\"others must be last association\", Actual);\n                end if;\n \n-               Remove (Actual);\n+               --  This subprogram is used both for formal packages and for\n+               --  instantiations. For the latter, associations must all be\n+               --  explicit.\n+\n+               if Nkind (I_Node) /= N_Formal_Package_Declaration\n+                 and then Comes_From_Source (I_Node)\n+               then\n+                  Error_Msg_N\n+                    (\"others association not allowed in an instance\",\n+                      Actual);\n+               end if;\n+\n+               --  In any case, nothing to do after the others association\n+\n                exit;\n+\n+            elsif Box_Present (Actual)\n+              and then Comes_From_Source (I_Node)\n+              and then Nkind (I_Node) /= N_Formal_Package_Declaration\n+            then\n+               Error_Msg_N\n+                 (\"box association not allowed in an instance\", Actual);\n             end if;\n \n             Next (Actual);\n@@ -1104,6 +1149,7 @@ package body Sem_Ch12 is\n \n          First_Named := First (Actuals);\n          while Present (First_Named)\n+           and then Nkind (First_Named) /= N_Others_Choice\n            and then No (Selector_Name (First_Named))\n          loop\n             Num_Actuals := Num_Actuals + 1;\n@@ -1113,7 +1159,9 @@ package body Sem_Ch12 is\n \n       Named := First_Named;\n       while Present (Named) loop\n-         if No (Selector_Name (Named)) then\n+         if Nkind (Named) /= N_Others_Choice\n+           and then  No (Selector_Name (Named))\n+         then\n             Error_Msg_N (\"invalid positional actual after named one\", Named);\n             Abandon_Instantiation (Named);\n          end if;\n@@ -1122,7 +1170,9 @@ package body Sem_Ch12 is\n          --  introduced for a default subprogram that turns out to be local\n          --  to the outer instantiation.\n \n-         if Present (Explicit_Generic_Actual_Parameter (Named)) then\n+         if Nkind (Named) /= N_Others_Choice\n+           and then  Present (Explicit_Generic_Actual_Parameter (Named))\n+         then\n             Num_Actuals := Num_Actuals + 1;\n          end if;\n \n@@ -1184,9 +1234,10 @@ package body Sem_Ch12 is\n \n                   else\n                      Analyze (Match);\n-                     Append_To (Assoc,\n-                       Instantiate_Type\n-                         (Formal, Match, Analyzed_Formal, Assoc));\n+                     Append_List\n+                       (Instantiate_Type\n+                         (Formal, Match, Analyzed_Formal, Assoc),\n+                       Assoc);\n \n                      --  An instantiation is a freeze point for the actuals,\n                      --  unless this is a rewritten formal package.\n@@ -1509,29 +1560,25 @@ package body Sem_Ch12 is\n    -------------------------------------------\n \n    procedure Analyze_Formal_Derived_Interface_Type\n-     (T   : Entity_Id;\n+     (N   : Node_Id;\n+      T   : Entity_Id;\n       Def : Node_Id)\n    is\n-      Ifaces_List : Elist_Id;\n+      Loc   : constant Source_Ptr := Sloc (Def);\n+      New_N : Node_Id;\n \n    begin\n-      Enter_Name (T);\n-      Set_Ekind  (T, E_Record_Type);\n-      Set_Etype  (T, T);\n-      Analyze (Subtype_Indication (Def));\n-      Analyze_Interface_Declaration (T, Def);\n-      Make_Class_Wide_Type (T);\n-      Analyze_List (Interface_List (Def));\n-\n-      --  Ada 2005 (AI-251): Collect the list of progenitors that are not\n-      --  already covered by the parents.\n-\n-      Collect_Abstract_Interfaces\n-        (T                         => T,\n-         Ifaces_List               => Ifaces_List,\n-         Exclude_Parent_Interfaces => True);\n-\n-      Set_Abstract_Interfaces (T, Ifaces_List);\n+      --  Rewrite as a type declaration of a derived type. This ensures that\n+      --  the interface list and primitive operations are properly captured.\n+\n+      New_N :=\n+        Make_Full_Type_Declaration (Loc,\n+          Defining_Identifier => T,\n+           Type_Definition => Def);\n+\n+      Rewrite (N, New_N);\n+      Analyze (N);\n+      Set_Is_Generic_Type (T);\n    end Analyze_Formal_Derived_Interface_Type;\n \n    ---------------------------------\n@@ -1695,14 +1742,23 @@ package body Sem_Ch12 is\n    -- Analyze_Formal_Interface_Type;--\n    -----------------------------------\n \n-   procedure Analyze_Formal_Interface_Type (T : Entity_Id; Def : Node_Id) is\n+   procedure Analyze_Formal_Interface_Type\n+      (N   : Node_Id;\n+       T   : Entity_Id;\n+       Def : Node_Id)\n+   is\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      New_N : Node_Id;\n+\n    begin\n-      Enter_Name (T);\n-      Set_Ekind  (T, E_Record_Type);\n-      Set_Etype  (T, T);\n-      Analyze_Interface_Declaration (T, Def);\n-      Make_Class_Wide_Type (T);\n-      Set_Primitive_Operations (T, New_Elmt_List);\n+      New_N :=\n+        Make_Full_Type_Declaration (Loc,\n+          Defining_Identifier => T,\n+          Type_Definition => Def);\n+\n+      Rewrite (N, New_N);\n+      Analyze (N);\n+      Set_Is_Generic_Type (T);\n    end Analyze_Formal_Interface_Type;\n \n    ---------------------------------\n@@ -2090,7 +2146,7 @@ package body Sem_Ch12 is\n       Set_Ekind  (Formal, E_Package);\n       Set_Etype  (Formal, Standard_Void_Type);\n       Set_Inner_Instances (Formal, New_Elmt_List);\n-      New_Scope  (Formal);\n+      Push_Scope  (Formal);\n \n       if Is_Child_Unit (Gen_Unit)\n         and then Parent_Installed\n@@ -2449,10 +2505,10 @@ package body Sem_Ch12 is\n          --  record declaration or a abstract type derivation.\n \n          when N_Record_Definition                      =>\n-            Analyze_Formal_Interface_Type (T, Def);\n+            Analyze_Formal_Interface_Type (N, T, Def);\n \n          when N_Derived_Type_Definition                =>\n-            Analyze_Formal_Derived_Interface_Type (T, Def);\n+            Analyze_Formal_Derived_Interface_Type (N, T, Def);\n \n          when N_Error                                  =>\n             null;\n@@ -2589,7 +2645,7 @@ package body Sem_Ch12 is\n       Enter_Name (Id);\n       Set_Ekind (Id, E_Generic_Package);\n       Set_Etype (Id, Standard_Void_Type);\n-      New_Scope (Id);\n+      Push_Scope (Id);\n       Enter_Generic_Scope (Id);\n       Set_Inner_Instances (Id, New_Elmt_List);\n \n@@ -2679,7 +2735,7 @@ package body Sem_Ch12 is\n       Enter_Name (Id);\n \n       Set_Scope_Depth_Value (Id, Scope_Depth (Current_Scope) + 1);\n-      New_Scope (Id);\n+      Push_Scope (Id);\n       Enter_Generic_Scope (Id);\n       Set_Inner_Instances (Id, New_Elmt_List);\n       Set_Is_Pure (Id, Is_Pure (Current_Scope));\n@@ -3163,11 +3219,13 @@ package body Sem_Ch12 is\n             Check_Forward_Instantiation (Gen_Decl);\n             if Nkind (N) = N_Package_Instantiation then\n                declare\n-                  Enclosing_Master : Entity_Id := Current_Scope;\n+                  Enclosing_Master : Entity_Id;\n \n                begin\n-                  while Enclosing_Master /= Standard_Standard loop\n+                  --  Loop to search enclosing masters\n \n+                  Enclosing_Master := Current_Scope;\n+                  Scope_Loop : while Enclosing_Master /= Standard_Standard loop\n                      if Ekind (Enclosing_Master) = E_Package then\n                         if Is_Compilation_Unit (Enclosing_Master) then\n                            if In_Package_Body (Enclosing_Master) then\n@@ -3178,7 +3236,7 @@ package body Sem_Ch12 is\n                                 (Enclosing_Master);\n                            end if;\n \n-                           exit;\n+                           exit Scope_Loop;\n \n                         else\n                            Enclosing_Master := Scope (Enclosing_Master);\n@@ -3194,15 +3252,19 @@ package body Sem_Ch12 is\n                         --  the enclosing instance, if any. enclosing scope\n                         --  is void in the formal part of a generic subp.\n \n-                        exit;\n+                        exit Scope_Loop;\n \n                      else\n                         if Ekind (Enclosing_Master) = E_Entry\n                           and then\n                             Ekind (Scope (Enclosing_Master)) = E_Protected_Type\n                         then\n-                           Enclosing_Master :=\n-                             Protected_Body_Subprogram (Enclosing_Master);\n+                           if not Expander_Active then\n+                              exit Scope_Loop;\n+                           else\n+                              Enclosing_Master :=\n+                                Protected_Body_Subprogram (Enclosing_Master);\n+                           end if;\n                         end if;\n \n                         Set_Delay_Cleanups (Enclosing_Master);\n@@ -3227,9 +3289,9 @@ package body Sem_Ch12 is\n                            end;\n                         end if;\n \n-                        exit;\n+                        exit Scope_Loop;\n                      end if;\n-                  end loop;\n+                  end loop Scope_Loop;\n                end;\n \n                --  Make entry in table\n@@ -3458,17 +3520,35 @@ package body Sem_Ch12 is\n          --  removed previously.\n \n          --  If current scope is the body of a child unit, remove context of\n-         --  spec as well.\n+         --  spec as well. If an enclosing scope is an instance body. the\n+         --  context has already been removed, but the entities in the body\n+         --  must be made invisible as well.\n \n          S := Current_Scope;\n \n          while Present (S)\n            and then S /= Standard_Standard\n          loop\n-            exit when Is_Generic_Instance (S)\n-                 and then (In_Package_Body (S)\n-                            or else Ekind (S) = E_Procedure\n-                            or else Ekind (S) = E_Function);\n+            if Is_Generic_Instance (S)\n+              and then (In_Package_Body (S)\n+                          or else Ekind (S) = E_Procedure\n+                            or else Ekind (S) = E_Function)\n+            then\n+               --  We still have to remove the entities of the enclosing\n+               --  instance from direct visibility.\n+\n+               declare\n+                  E : Entity_Id;\n+               begin\n+                  E := First_Entity (S);\n+                  while Present (E) loop\n+                     Set_Is_Immediately_Visible (E, False);\n+                     Next_Entity (E);\n+                  end loop;\n+               end;\n+\n+               exit;\n+            end if;\n \n             if S = Curr_Unit\n               or else (Ekind (Curr_Unit) = E_Package_Body\n@@ -3514,7 +3594,7 @@ package body Sem_Ch12 is\n          end loop;\n          pragma Assert (Num_Inner < Num_Scopes);\n \n-         New_Scope (Standard_Standard);\n+         Push_Scope (Standard_Standard);\n          Scope_Stack.Table (Scope_Stack.Last).Is_Active_Stack_Base := True;\n          Instantiate_Package_Body\n            ((N, Act_Decl, Expander_Active, Current_Sem_Unit), True);\n@@ -3538,13 +3618,13 @@ package body Sem_Ch12 is\n             if Present (Curr_Scope)\n               and then Is_Child_Unit (Curr_Scope)\n             then\n-               New_Scope (Curr_Scope);\n+               Push_Scope (Curr_Scope);\n                Set_Is_Immediately_Visible (Curr_Scope);\n \n                --  Finally, restore inner scopes as well\n \n                for J in reverse 1 .. Num_Inner loop\n-                  New_Scope (Inner_Scopes (J));\n+                  Push_Scope (Inner_Scopes (J));\n                end loop;\n             end if;\n \n@@ -3595,9 +3675,30 @@ package body Sem_Ch12 is\n             end  loop;\n          end if;\n \n-         for J in 1 .. N_Instances loop\n-            Set_Is_Generic_Instance (Instances (J), True);\n-         end loop;\n+         --  Restore status of instances. If one of them is a body, make\n+         --  its local entities visible again.\n+\n+         declare\n+            E    : Entity_Id;\n+            Inst : Entity_Id;\n+\n+         begin\n+            for J in 1 .. N_Instances loop\n+               Inst := Instances (J);\n+               Set_Is_Generic_Instance (Inst, True);\n+\n+               if In_Package_Body (Inst)\n+                 or else Ekind (S) = E_Procedure\n+                 or else Ekind (S) = E_Function\n+               then\n+                  E := First_Entity (Instances (J));\n+                  while Present (E) loop\n+                     Set_Is_Immediately_Visible (E);\n+                     Next_Entity (E);\n+                  end loop;\n+               end if;\n+            end loop;\n+         end;\n \n       --  If generic unit is in current unit, current context is correct\n \n@@ -4970,6 +5071,17 @@ package body Sem_Ch12 is\n                then\n                   Install_Parent (Inst_Par);\n                   Parent_Installed := True;\n+\n+               elsif In_Open_Scopes (Inst_Par) then\n+\n+                  --  If the parent is already installed verify that the\n+                  --  actuals for its formal packages declared with a box\n+                  --  are already installed. This is necessary when the\n+                  --  child instance is a child of the parent instance.\n+                  --  In this case the parent is placed on the scope stack\n+                  --  but the formal packages are not made visible.\n+\n+                  Install_Formal_Packages (Inst_Par);\n                end if;\n \n             else\n@@ -5156,12 +5268,39 @@ package body Sem_Ch12 is\n          then\n             Switch_View (Designated_Type (T));\n \n-         elsif Is_Array_Type (T)\n-           and then Is_Private_Type (Component_Type (T))\n-           and then not Has_Private_View (N)\n-           and then Present (Full_View (Component_Type (T)))\n-         then\n-            Switch_View (Component_Type (T));\n+         elsif Is_Array_Type (T) then\n+            if Is_Private_Type (Component_Type (T))\n+              and then not Has_Private_View (N)\n+              and then Present (Full_View (Component_Type (T)))\n+            then\n+               Switch_View (Component_Type (T));\n+            end if;\n+\n+            --  The normal exchange mechanism relies on the setting of a\n+            --  flag on the reference in the generic. However, an additional\n+            --  mechanism is needed for types that are not explicitly mentioned\n+            --  in the generic, but may be needed in expanded code in the\n+            --  instance. This includes component types of arrays and\n+            --  designated types of access types. This processing must also\n+            --  include the index types of arrays which we take care of here.\n+\n+            declare\n+               Indx : Node_Id;\n+               Typ  : Entity_Id;\n+\n+            begin\n+               Indx := First_Index (T);\n+               Typ  := Base_Type (Etype (Indx));\n+               while Present (Indx) loop\n+                  if Is_Private_Type (Typ)\n+                    and then Present (Full_View (Typ))\n+                  then\n+                     Switch_View (Typ);\n+                  end if;\n+\n+                  Next_Index (Indx);\n+               end loop;\n+            end;\n \n          elsif Is_Private_Type (T)\n            and then Present (Full_View (T))\n@@ -5171,10 +5310,9 @@ package body Sem_Ch12 is\n             Switch_View (T);\n \n          --  Finally, a non-private subtype may have a private base type, which\n-         --  must be exchanged for consistency. This can happen when\n-         --  instantiating a package body, when the scope stack is empty but in\n-         --  fact the subtype and the base type are declared in an enclosing\n-         --  scope.\n+         --  must be exchanged for consistency. This can happen when a package\n+         --  body is instantiated, when the scope stack is empty but in fact\n+         --  the subtype and the base type are declared in an enclosing scope.\n \n          --  Note that in this case we introduce an inconsistency in the view\n          --  set, because we switch the base type BT, but there could be some\n@@ -5852,6 +5990,7 @@ package body Sem_Ch12 is\n \n       elsif Nkind (N) = N_Integer_Literal\n         or else Nkind (N) = N_Real_Literal\n+        or else Nkind (N) = N_String_Literal\n       then\n          --  No descendant fields need traversing\n \n@@ -6780,6 +6919,42 @@ package body Sem_Ch12 is\n       Mark_Rewrite_Insertion (Act_Body);\n    end Install_Body;\n \n+   -----------------------------\n+   -- Install_Formal_Packages --\n+   -----------------------------\n+\n+   procedure Install_Formal_Packages (Par : Entity_Id) is\n+      E : Entity_Id;\n+\n+   begin\n+      E := First_Entity (Par);\n+      while Present (E) loop\n+         if Ekind (E) = E_Package\n+           and then Nkind (Parent (E)) = N_Package_Renaming_Declaration\n+         then\n+            --  If this is the renaming for the parent instance, done\n+\n+            if Renamed_Object (E) = Par then\n+               exit;\n+\n+            --  The visibility of a formal of an enclosing generic is\n+            --  already correct.\n+\n+            elsif Denotes_Formal_Package (E) then\n+               null;\n+\n+            elsif Present (Associated_Formal_Package (E))\n+              and then Box_Present (Parent (Associated_Formal_Package (E)))\n+            then\n+               Check_Generic_Actuals (Renamed_Object (E), True);\n+               Set_Is_Hidden (E, False);\n+            end if;\n+         end if;\n+\n+         Next_Entity (E);\n+      end loop;\n+   end Install_Formal_Packages;\n+\n    --------------------\n    -- Install_Parent --\n    --------------------\n@@ -6794,55 +6969,13 @@ package body Sem_Ch12 is\n       First_Gen : Entity_Id;\n       Elmt      : Elmt_Id;\n \n-      procedure Install_Formal_Packages (Par : Entity_Id);\n-      --  If any of the formals of the parent are formal packages with box,\n-      --  their formal parts are visible in the parent and thus in the child\n-      --  unit as well. Analogous to what is done in Check_Generic_Actuals\n-      --  for the unit itself.\n-\n       procedure Install_Noninstance_Specs (Par : Entity_Id);\n       --  Install the scopes of noninstance parent units ending with Par\n \n       procedure Install_Spec (Par : Entity_Id);\n       --  The child unit is within the declarative part of the parent, so\n       --  the declarations within the parent are immediately visible.\n \n-      -----------------------------\n-      -- Install_Formal_Packages --\n-      -----------------------------\n-\n-      procedure Install_Formal_Packages (Par : Entity_Id) is\n-         E : Entity_Id;\n-\n-      begin\n-         E := First_Entity (Par);\n-         while Present (E) loop\n-            if Ekind (E) = E_Package\n-              and then Nkind (Parent (E)) = N_Package_Renaming_Declaration\n-            then\n-               --  If this is the renaming for the parent instance, done\n-\n-               if Renamed_Object (E) = Par then\n-                  exit;\n-\n-               --  The visibility of a formal of an enclosing generic is\n-               --  already correct.\n-\n-               elsif Denotes_Formal_Package (E) then\n-                  null;\n-\n-               elsif Present (Associated_Formal_Package (E))\n-                 and then Box_Present (Parent (Associated_Formal_Package (E)))\n-               then\n-                  Check_Generic_Actuals (Renamed_Object (E), True);\n-                  Set_Is_Hidden (E, False);\n-               end if;\n-            end if;\n-\n-            Next_Entity (E);\n-         end loop;\n-      end Install_Formal_Packages;\n-\n       -------------------------------\n       -- Install_Noninstance_Specs --\n       -------------------------------\n@@ -6895,7 +7028,7 @@ package body Sem_Ch12 is\n          --  parents then it should be possible to remove this\n          --  special check. ???\n \n-         New_Scope (Par);\n+         Push_Scope (Par);\n          Set_Is_Immediately_Visible   (Par);\n          Install_Visible_Declarations (Par);\n          Set_Use (Visible_Declarations (Spec));\n@@ -6993,7 +7126,7 @@ package body Sem_Ch12 is\n       end if;\n \n       if not In_Body then\n-         New_Scope (S);\n+         Push_Scope (S);\n       end if;\n    end Install_Parent;\n \n@@ -7422,13 +7555,15 @@ package body Sem_Ch12 is\n          --  renamings of the actuals supplied.\n \n          declare\n-            Gen_Decl    : constant Node_Id :=\n-                            Unit_Declaration_Node (Gen_Parent);\n-            Formals     : constant List_Id :=\n-                            Generic_Formal_Declarations (Gen_Decl);\n-            Actual_Ent  : Entity_Id;\n-            Formal_Node : Node_Id;\n-            Formal_Ent  : Entity_Id;\n+            Gen_Decl : constant Node_Id :=\n+                         Unit_Declaration_Node (Gen_Parent);\n+            Formals  : constant List_Id :=\n+                         Generic_Formal_Declarations (Gen_Decl);\n+\n+            Actual_Ent       : Entity_Id;\n+            Actual_Of_Formal : Node_Id;\n+            Formal_Node      : Node_Id;\n+            Formal_Ent       : Entity_Id;\n \n          begin\n             if Present (Formals) then\n@@ -7438,6 +7573,8 @@ package body Sem_Ch12 is\n             end if;\n \n             Actual_Ent := First_Entity (Actual_Pack);\n+            Actual_Of_Formal :=\n+               First (Visible_Declarations (Specification (Analyzed_Formal)));\n             while Present (Actual_Ent)\n               and then Actual_Ent /= First_Private_Entity (Actual_Pack)\n             loop\n@@ -7449,22 +7586,19 @@ package body Sem_Ch12 is\n                      Match_Formal_Entity\n                        (Formal_Node, Formal_Ent, Actual_Ent);\n \n+                     --  We iterate at the same time over the actuals of the\n+                     --  local package created for the formal, to determine\n+                     --  which one of the formals of the original generic were\n+                     --  defaulted in the formal. The corresponding actual\n+                     --  entities are visible in the enclosing instance.\n+\n                      if Box_Present (Formal)\n                        or else\n-                         (Present (Formal_Node)\n-                           and then Is_Generic_Formal (Formal_Ent))\n+                         (Present (Actual_Of_Formal)\n+                           and then\n+                             Is_Generic_Formal\n+                               (Get_Formal_Entity (Actual_Of_Formal)))\n                      then\n-                        --  This may make too many formal entities visible, but\n-                        --  it's hard to build an example that exposes this\n-                        --  excess visibility. If a reference in the generic\n-                        --  resolved to a global variable then the extra\n-                        --  visibility in an instance does not affect the\n-                        --  captured entity. If the reference resolved to a\n-                        --  local entity it will resolve again in the instance.\n-                        --  Nevertheless, we should build tests to make sure\n-                        --  that hidden entities in the generic remain hidden\n-                        --  in the instance.\n-\n                         Set_Is_Hidden (Actual_Ent, False);\n                         Set_Is_Visible_Formal (Actual_Ent);\n                         Set_Is_Potentially_Use_Visible\n@@ -7473,10 +7607,15 @@ package body Sem_Ch12 is\n                         if Ekind (Actual_Ent) = E_Package then\n                            Process_Nested_Formal (Actual_Ent);\n                         end if;\n+\n+                     else\n+                        Set_Is_Hidden (Actual_Ent);\n+                        Set_Is_Potentially_Use_Visible (Actual_Ent, False);\n                      end if;\n                   end if;\n \n                   Next_Non_Pragma (Formal_Node);\n+                  Next (Actual_Of_Formal);\n \n                else\n                   --  No further formals to match, but the generic part may\n@@ -7485,7 +7624,6 @@ package body Sem_Ch12 is\n \n                   Next_Entity (Actual_Ent);\n                end if;\n-\n             end loop;\n \n             --  Inherited subprograms generated by formal derived types are\n@@ -8170,9 +8308,9 @@ package body Sem_Ch12 is\n       --  formal object of another generic unit G, and the instantiation\n       --  containing the actual occurs within the body of G or within the body\n       --  of a generic unit declared within the declarative region of G, then\n-      --  the declaration of the formal object of G shall have a null\n-      --  exclusion. Otherwise, the subtype of the actual matching the formal\n-      --  object declaration shall exclude null.\n+      --  the declaration of the formal object of G must have a null exclusion.\n+      --  Otherwise, the subtype of the actual matching the formal object\n+      --  declaration shall exclude null.\n \n       if Ada_Version >= Ada_05\n         and then Present (Actual_Decl)\n@@ -8183,8 +8321,10 @@ package body Sem_Ch12 is\n         and then Has_Null_Exclusion (Actual_Decl)\n         and then not Has_Null_Exclusion (Analyzed_Formal)\n       then\n-         Error_Msg_N (\"null-exclusion required in formal object declaration\",\n-                      Analyzed_Formal);\n+         Error_Msg_Sloc := Sloc (Actual_Decl);\n+         Error_Msg_N\n+           (\"`NOT NULL` required in formal, to match actual #\",\n+            Analyzed_Formal);\n       end if;\n \n       return List;\n@@ -8443,7 +8583,6 @@ package body Sem_Ch12 is\n       Gen_Body      : Node_Id;\n       Gen_Body_Id   : Node_Id;\n       Act_Body      : Node_Id;\n-      Act_Body_Id   : Entity_Id;\n       Pack_Body     : Node_Id;\n       Prev_Formal   : Entity_Id;\n       Ret_Expr      : Node_Id;\n@@ -8496,9 +8635,13 @@ package body Sem_Ch12 is\n          Act_Body :=\n            Copy_Generic_Node\n              (Original_Node (Gen_Body), Empty, Instantiating => True);\n-         Act_Body_Id := Defining_Entity (Act_Body);\n-         Set_Chars (Act_Body_Id, Chars (Anon_Id));\n-         Set_Sloc (Act_Body_Id, Sloc (Defining_Entity (Inst_Node)));\n+\n+         --  Create proper defining name for the body, to correspond to\n+         --  the one in the spec.\n+\n+         Set_Defining_Unit_Name (Specification (Act_Body),\n+           Make_Defining_Identifier\n+             (Sloc (Defining_Entity (Inst_Node)), Chars (Anon_Id)));\n          Set_Corresponding_Spec (Act_Body, Anon_Id);\n          Set_Has_Completion (Anon_Id);\n          Check_Generic_Actuals (Pack_Id, False);\n@@ -8688,16 +8831,18 @@ package body Sem_Ch12 is\n      (Formal          : Node_Id;\n       Actual          : Node_Id;\n       Analyzed_Formal : Node_Id;\n-      Actual_Decls    : List_Id) return Node_Id\n+      Actual_Decls    : List_Id) return List_Id\n    is\n-      Gen_T     : constant Entity_Id  := Defining_Identifier (Formal);\n-      A_Gen_T   : constant Entity_Id  := Defining_Identifier (Analyzed_Formal);\n-      Ancestor  : Entity_Id := Empty;\n-      Def       : constant Node_Id    := Formal_Type_Definition (Formal);\n-      Act_T     : Entity_Id;\n-      Decl_Node : Node_Id;\n-      Loc       : Source_Ptr;\n-      Subt      : Entity_Id;\n+      Gen_T      : constant Entity_Id  := Defining_Identifier (Formal);\n+      A_Gen_T    : constant Entity_Id  :=\n+                     Defining_Identifier (Analyzed_Formal);\n+      Ancestor   : Entity_Id := Empty;\n+      Def        : constant Node_Id    := Formal_Type_Definition (Formal);\n+      Act_T      : Entity_Id;\n+      Decl_Node  : Node_Id;\n+      Decl_Nodes : List_Id;\n+      Loc        : Source_Ptr;\n+      Subt       : Entity_Id;\n \n       procedure Validate_Array_Type_Instance;\n       procedure Validate_Access_Subprogram_Instance;\n@@ -8832,6 +8977,14 @@ package body Sem_Ch12 is\n                  Actual, Gen_T);\n             Abandon_Instantiation (Actual);\n          end if;\n+\n+         --  Ada 2005: null-exclusion indicators of the two types must agree\n+\n+         if Can_Never_Be_Null (A_Gen_T) /=  Can_Never_Be_Null (Act_T) then\n+            Error_Msg_NE\n+              (\"non null exclusion of actual and formal & do not match\",\n+                 Actual, Gen_T);\n+         end if;\n       end Validate_Access_Type_Instance;\n \n       ----------------------------------\n@@ -8964,7 +9117,7 @@ package body Sem_Ch12 is\n          --  the actual.\n \n          if Present (Par)\n-           and then  not Interface_Present_In_Ancestor (Act_T, Par)\n+           and then not Interface_Present_In_Ancestor (Act_T, Par)\n          then\n             Error_Msg_NE\n               (\"interface actual must include progenitor&\", Actual, Par);\n@@ -8975,7 +9128,9 @@ package body Sem_Ch12 is\n \n          Elmt := First_Elmt (Abstract_Interfaces (A_Gen_T));\n          while Present (Elmt) loop\n-            if not Interface_Present_In_Ancestor (Act_T, Node (Elmt)) then\n+            if not Interface_Present_In_Ancestor\n+                     (Act_T, Get_Instance_Of (Node (Elmt)))\n+            then\n                Error_Msg_NE\n                  (\"interface actual must include progenitor&\",\n                     Actual, Node (Elmt));\n@@ -9256,7 +9411,7 @@ package body Sem_Ch12 is\n                Is_Synchronized_Interface (Act_T)\n          then\n             Error_Msg_NE\n-              (\"actual for interface& does not match ('R'M 12.5.5(5))\",\n+              (\"actual for interface& does not match ('R'M 12.5.5(4))\",\n                  Actual, Gen_T);\n          end if;\n       end Validate_Interface_Type_Instance;\n@@ -9376,7 +9531,7 @@ package body Sem_Ch12 is\n    begin\n       if Get_Instance_Of (A_Gen_T) /= A_Gen_T then\n          Error_Msg_N (\"duplicate instantiation of generic type\", Actual);\n-         return Error;\n+         return New_List (Error);\n \n       elsif not Is_Entity_Name (Actual)\n         or else not Is_Type (Entity (Actual))\n@@ -9472,7 +9627,11 @@ package body Sem_Ch12 is\n               (\"actual of non-abstract formal cannot be abstract\", Actual);\n          end if;\n \n-         if Is_Scalar_Type (Gen_T) then\n+         --  A generic scalar type is a first subtype for which we generate\n+         --  an anonymous base type. Indicate that the instance of this base\n+         --  is the base type of the actual.\n+\n+         if Is_Scalar_Type (A_Gen_T) then\n             Set_Instance_Of (Etype (A_Gen_T), Etype (Act_T));\n          end if;\n       end if;\n@@ -9571,6 +9730,8 @@ package body Sem_Ch12 is\n          Set_Has_Private_View (Subtype_Indication (Decl_Node));\n       end if;\n \n+      Decl_Nodes := New_List (Decl_Node);\n+\n       --  Flag actual derived types so their elaboration produces the\n       --  appropriate renamings for the primitive operations of the ancestor.\n       --  Flag actual for formal private types as well, to determine whether\n@@ -9582,21 +9743,71 @@ package body Sem_Ch12 is\n          Set_Generic_Parent_Type (Decl_Node, Ancestor);\n       end if;\n \n-      return Decl_Node;\n+      --  If the actual is a synchronized type that implements an interface,\n+      --  the primitive operations are attached to the corresponding record,\n+      --  and we have to treat it as an additional generic actual, so that its\n+      --  primitive operations become visible in the instance. The task or\n+      --  protected type itself does not carry primitive operations.\n+\n+      if Is_Concurrent_Type (Act_T)\n+        and then Is_Tagged_Type (Act_T)\n+        and then Present (Corresponding_Record_Type (Act_T))\n+        and then Present (Ancestor)\n+        and then Is_Interface (Ancestor)\n+      then\n+         declare\n+            Corr_Rec  : constant Entity_Id :=\n+                          Corresponding_Record_Type (Act_T);\n+            New_Corr  : Entity_Id;\n+            Corr_Decl : Node_Id;\n+\n+         begin\n+            New_Corr := Make_Defining_Identifier (Loc,\n+                            Chars => New_Internal_Name  ('S'));\n+            Corr_Decl :=\n+              Make_Subtype_Declaration (Loc,\n+                Defining_Identifier => New_Corr,\n+                Subtype_Indication  =>\n+                  New_Reference_To (Corr_Rec, Loc));\n+            Append_To (Decl_Nodes, Corr_Decl);\n+\n+            if Ekind (Act_T) = E_Task_Type then\n+               Set_Ekind (Subt, E_Task_Subtype);\n+            else\n+               Set_Ekind (Subt, E_Protected_Subtype);\n+            end if;\n+\n+            Set_Corresponding_Record_Type (Subt, Corr_Rec);\n+            Set_Generic_Parent_Type (Corr_Decl, Ancestor);\n+            Set_Generic_Parent_Type (Decl_Node, Empty);\n+         end;\n+      end if;\n+\n+      return Decl_Nodes;\n    end Instantiate_Type;\n \n    -----------------------\n    -- Is_Generic_Formal --\n    -----------------------\n \n    function Is_Generic_Formal (E : Entity_Id) return Boolean is\n-      Kind : constant Node_Kind := Nkind (Parent (E));\n+      Kind : Node_Kind;\n+\n    begin\n-      return\n-        Kind = N_Formal_Object_Declaration\n-          or else Kind = N_Formal_Package_Declaration\n-          or else Kind in N_Formal_Subprogram_Declaration\n-          or else Kind = N_Formal_Type_Declaration;\n+      if No (E) then\n+         return False;\n+      else\n+         Kind := Nkind (Parent (E));\n+         return\n+           Kind = N_Formal_Object_Declaration\n+             or else Kind = N_Formal_Package_Declaration\n+             or else Kind = N_Formal_Type_Declaration\n+             or else\n+               (Is_Formal_Subprogram (E)\n+                 and then\n+                   Nkind (Parent (Parent (E))) in\n+                     N_Formal_Subprogram_Declaration);\n+      end if;\n    end Is_Generic_Formal;\n \n    ---------------------\n@@ -9782,8 +9993,7 @@ package body Sem_Ch12 is\n                begin\n                   Error_Msg_Unit_1 := Bname;\n                   Error_Msg_N (\"this instantiation requires$!\", N);\n-                  Error_Msg_Name_1 :=\n-                    Get_File_Name (Bname, Subunit => False);\n+                  Error_Msg_File_1 := Get_File_Name (Bname, Subunit => False);\n                   Error_Msg_N (\"\\but file{ was not found!\", N);\n                   raise Unrecoverable_Error;\n                end;\n@@ -9959,7 +10169,26 @@ package body Sem_Ch12 is\n                begin\n                   if Nkind (Expr) = N_Subtype_Indication then\n                      Analyze (Subtype_Mark (Expr));\n-                     Analyze_List (Constraints (Constraint (Expr)));\n+\n+                     --  Analyze separately each discriminant constraint,\n+                     --  when given with a named association.\n+\n+                     declare\n+                        Constr : Node_Id;\n+\n+                     begin\n+                        Constr := First (Constraints (Constraint (Expr)));\n+                        while Present (Constr) loop\n+                           if Nkind (Constr) = N_Discriminant_Association then\n+                              Analyze (Expression (Constr));\n+                           else\n+                              Analyze (Constr);\n+                           end if;\n+\n+                           Next (Constr);\n+                        end loop;\n+                     end;\n+\n                   else\n                      Analyze (Expr);\n                   end if;\n@@ -10553,17 +10782,33 @@ package body Sem_Ch12 is\n \n          elsif Nkind (Parent (N)) = N_Selected_Component\n            and then Nkind (Parent (N2)) = N_Function_Call\n-           and then Is_Global (Entity (Name (Parent (N2))))\n+           and then N = Selector_Name (Parent (N))\n          then\n-            Change_Selected_Component_To_Expanded_Name (Parent (N));\n-            Set_Associated_Node (Parent (N), Name (Parent (N2)));\n-            Set_Global_Type (Parent (N), Name (Parent (N2)));\n-            Save_Entity_Descendants (N);\n+            if No (Parameter_Associations (Parent (N2))) then\n+               if Is_Global (Entity (Name (Parent (N2)))) then\n+                  Change_Selected_Component_To_Expanded_Name (Parent (N));\n+                  Set_Associated_Node (Parent (N), Name (Parent (N2)));\n+                  Set_Global_Type (Parent (N), Name (Parent (N2)));\n+                  Save_Entity_Descendants (N);\n \n-         else\n-            --  Entity is local. Reset in generic unit, so that node is\n-            --  resolved anew at the point of instantiation.\n+               else\n+                  Set_Associated_Node (N, Empty);\n+                  Set_Etype (N, Empty);\n+               end if;\n+\n+            --  In Ada 2005, X.F may be a call to a primitive operation,\n+            --  rewritten as F (X). This rewriting will be done again in an\n+            --  instance, so keep the original node. Global entities will be\n+            --  captured as for other constructs.\n \n+            else\n+               null;\n+            end if;\n+\n+         --  Entity is local. Reset in generic unit, so that node is resolved\n+         --  anew at the point of instantiation.\n+\n+         else\n             Set_Associated_Node (N, Empty);\n             Set_Etype (N, Empty);\n          end if;"}]}