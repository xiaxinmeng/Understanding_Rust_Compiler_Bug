{"sha": "43ffba00cb5ebe8498daa5431f08d329fc62080b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNmZmJhMDBjYjVlYmU4NDk4ZGFhNTQzMWYwOGQzMjlmYzYyMDgwYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-10-13T16:50:03Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-10-13T16:50:03Z"}, "message": "loop-iv.c (determine_max_iter): Fix handling of AND.\n\n\n\t* loop-iv.c (determine_max_iter): Fix handling of AND.\n\t(iv_number_of_iterations): Record upper bounds as unsigned\n\tvalues.\n\nFrom-SVN: r192424", "tree": {"sha": "ad7bfb2768d0ab6696a56bd5a867ab2a6c593fda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad7bfb2768d0ab6696a56bd5a867ab2a6c593fda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43ffba00cb5ebe8498daa5431f08d329fc62080b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ffba00cb5ebe8498daa5431f08d329fc62080b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43ffba00cb5ebe8498daa5431f08d329fc62080b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ffba00cb5ebe8498daa5431f08d329fc62080b/comments", "author": null, "committer": null, "parents": [{"sha": "544e7e783525054b1e4831e2fc001a18b67c6cbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544e7e783525054b1e4831e2fc001a18b67c6cbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/544e7e783525054b1e4831e2fc001a18b67c6cbf"}], "stats": {"total": 33, "additions": 25, "deletions": 8}, "files": [{"sha": "000b0d2cfea183c3a807d8783eb12532cea65748", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ffba00cb5ebe8498daa5431f08d329fc62080b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ffba00cb5ebe8498daa5431f08d329fc62080b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43ffba00cb5ebe8498daa5431f08d329fc62080b", "patch": "@@ -1,3 +1,9 @@\n+2012-10-13  Jan Hubicka  <jh@suse.cz>\n+\n+\t* loop-iv.c (determine_max_iter): Fix handling of AND.\n+\t(iv_number_of_iterations): Record upper bounds as unsigned\n+\tvalues.\n+\n 2012-10-13  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* ira.c (ira): Set current_loops to &ira_loops before recording"}, {"sha": "f1e19d82072079acdc96ea2cd44bf843f9a77e8e", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ffba00cb5ebe8498daa5431f08d329fc62080b/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ffba00cb5ebe8498daa5431f08d329fc62080b/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=43ffba00cb5ebe8498daa5431f08d329fc62080b", "patch": "@@ -2224,13 +2224,18 @@ determine_max_iter (struct loop *loop, struct niter_desc *desc, rtx old_niter)\n   rtx niter = desc->niter_expr;\n   rtx mmin, mmax, cmp;\n   unsigned HOST_WIDEST_INT nmax, inc;\n+  unsigned HOST_WIDEST_INT andmax = 0;\n+\n+  /* We used to look for constant operand 0 of AND,\n+     but canonicalization should always make this impossible.  */\n+  gcc_checking_assert (GET_CODE (niter) != AND\n+\t               || !CONST_INT_P (XEXP (niter, 0)));\n \n   if (GET_CODE (niter) == AND\n-      && CONST_INT_P (XEXP (niter, 0)))\n+      && CONST_INT_P (XEXP (niter, 1)))\n     {\n-      nmax = INTVAL (XEXP (niter, 0));\n-      if (!(nmax & (nmax + 1)))\n-\treturn nmax;\n+      andmax = UINTVAL (XEXP (niter, 1));\n+      niter = XEXP (niter, 0);\n     }\n \n   get_mode_bounds (desc->mode, desc->signed_p, desc->mode, &mmin, &mmax);\n@@ -2258,7 +2263,13 @@ determine_max_iter (struct loop *loop, struct niter_desc *desc, rtx old_niter)\n       if (dump_file)\n \tfprintf (dump_file, \";; improved upper bound by one.\\n\");\n     }\n-  return nmax / inc;\n+  nmax /= inc;\n+  if (andmax)\n+    nmax = MIN (nmax, andmax);\n+  if (dump_file)\n+    fprintf (dump_file, \";; Determined upper bound \"HOST_WIDEST_INT_PRINT_DEC\".\\n\",\n+\t     nmax);\n+  return nmax;\n }\n \n /* Computes number of iterations of the CONDITION in INSN in LOOP and stores\n@@ -2563,7 +2574,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t\t\t ? iv0.base\n \t\t\t : mode_mmin);\n \t  max = (up - down) / inc + 1;\n-\t  record_niter_bound (loop, double_int::from_shwi (max),\n+\t  record_niter_bound (loop, double_int::from_uhwi (max),\n \t\t\t      false, true);\n \n \t  if (iv0.step == const0_rtx)\n@@ -2776,14 +2787,14 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \n       desc->const_iter = true;\n       desc->niter = val & GET_MODE_MASK (desc->mode);\n-      record_niter_bound (loop, double_int::from_shwi (desc->niter),\n+      record_niter_bound (loop, double_int::from_uhwi (desc->niter),\n \t\t\t  false, true);\n     }\n   else\n     {\n       max = determine_max_iter (loop, desc, old_niter);\n       gcc_assert (max);\n-      record_niter_bound (loop, double_int::from_shwi (max),\n+      record_niter_bound (loop, double_int::from_uhwi (max),\n \t\t\t  false, true);\n \n       /* simplify_using_initial_values does a copy propagation on the registers"}]}