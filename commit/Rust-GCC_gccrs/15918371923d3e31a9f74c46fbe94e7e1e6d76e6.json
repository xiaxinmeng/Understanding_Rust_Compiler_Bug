{"sha": "15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU5MTgzNzE5MjNkM2UzMWE5Zjc0YzQ2ZmJlOTRlN2UxZTZkNzZlNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:17:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T12:17:35Z"}, "message": "[multiple changes]\n\n2013-10-10  Robert Dewar  <dewar@adacore.com>\n\n\t* lib-xref-spark_specific.adb, par-ch13.adb, sem_prag.adb, sem_prag.ads,\n\tsem_ch12.adb, sem_attr.adb, sem_ch6.adb, sem_ch13.adb, a-sequio.adb,\n\ts-atocou-builtin.adb: Minor reformatting.\n\n2013-10-10  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-oscons-tmplt.c (NEED_PTHREAD_CONDATTR_SETCLOCK): This\n\tconstant needs to be output to s-oscons.h, as it is tested\n\tby init.c.\n\n2013-10-10  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Variant_Part): Don't expand choices, too early\n\t* exp_ch5.adb (Expand_N_Case_Statement): Use new Has_SP_Choice\n\tflag to avoid expanding choices when not necessary.\n\t* exp_util.adb: Minor reformatting\n\t* freeze.adb (Freeze_Record_Type): Redo expansion of variants\n\t* sem_aggr.adb: Minor reformatting\n\t* sem_case.ads, sem_case.adb: Major rewrite, separating Analysis and\n\tChecking of choices.\n\t* sem_ch3.adb (Analyze_Variant_Part): Rewrite to call new\n\tAnalyze_Choices.\n\t* sem_ch4.adb (Analyze_Case_Expression): Call Analyze_Choices\n\tand Check_Choices\n\t* sem_ch5.adb (Analyze_Case_Statement): Call Analyze_Choices\n\tand Check_Choices\n\t* sem_util.adb: Minor reformatting\n\t* sinfo.ads, sinfo.adb (Has_SP_Choice): New flag.\n\n2013-10-10  Vincent Celier  <celier@adacore.com>\n\n\t* mlib-prj.adb (Build_Library): Do not issue link dynamic\n\tlibraries with an Rpath, if switch -R was used.\n\n2013-10-10  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-stalib.ads (Image_Index_Table_8, Image_Index_Table_16,\n\tImage_Index_Table_32): Remove as not used.\n\t* s-imgint.adb (Image_Integer): Call Set_Image_Integer and\n\tremove duplicated code.\n\nFrom-SVN: r203358", "tree": {"sha": "cd80a5317c5228f3994e9670042a976f5b3fa86b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd80a5317c5228f3994e9670042a976f5b3fa86b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/comments", "author": null, "committer": null, "parents": [{"sha": "b184c8f13820b011a119ce9c900b73986f3c5351", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b184c8f13820b011a119ce9c900b73986f3c5351", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b184c8f13820b011a119ce9c900b73986f3c5351"}], "stats": {"total": 976, "additions": 684, "deletions": 292}, "files": [{"sha": "97642d5e66998846a47b2379562557f66130f9f8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -1,3 +1,46 @@\n+2013-10-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* lib-xref-spark_specific.adb, par-ch13.adb, sem_prag.adb, sem_prag.ads,\n+\tsem_ch12.adb, sem_attr.adb, sem_ch6.adb, sem_ch13.adb, a-sequio.adb,\n+\ts-atocou-builtin.adb: Minor reformatting.\n+\n+2013-10-10  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-oscons-tmplt.c (NEED_PTHREAD_CONDATTR_SETCLOCK): This\n+\tconstant needs to be output to s-oscons.h, as it is tested\n+\tby init.c.\n+\n+2013-10-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Variant_Part): Don't expand choices, too early\n+\t* exp_ch5.adb (Expand_N_Case_Statement): Use new Has_SP_Choice\n+\tflag to avoid expanding choices when not necessary.\n+\t* exp_util.adb: Minor reformatting\n+\t* freeze.adb (Freeze_Record_Type): Redo expansion of variants\n+\t* sem_aggr.adb: Minor reformatting\n+\t* sem_case.ads, sem_case.adb: Major rewrite, separating Analysis and\n+\tChecking of choices.\n+\t* sem_ch3.adb (Analyze_Variant_Part): Rewrite to call new\n+\tAnalyze_Choices.\n+\t* sem_ch4.adb (Analyze_Case_Expression): Call Analyze_Choices\n+\tand Check_Choices\n+\t* sem_ch5.adb (Analyze_Case_Statement): Call Analyze_Choices\n+\tand Check_Choices\n+\t* sem_util.adb: Minor reformatting\n+\t* sinfo.ads, sinfo.adb (Has_SP_Choice): New flag.\n+\n+2013-10-10  Vincent Celier  <celier@adacore.com>\n+\n+\t* mlib-prj.adb (Build_Library): Do not issue link dynamic\n+\tlibraries with an Rpath, if switch -R was used.\n+\n+2013-10-10  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-stalib.ads (Image_Index_Table_8, Image_Index_Table_16,\n+\tImage_Index_Table_32): Remove as not used.\n+\t* s-imgint.adb (Image_Integer): Call Set_Image_Integer and\n+\tremove duplicated code.\n+\n 2013-10-10  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Analyze_Pragma): Provide a"}, {"sha": "b84252858bcc61f8d18cd99545d5e7cac241864d", "filename": "gcc/ada/a-sequio.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fa-sequio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fa-sequio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sequio.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -35,13 +35,15 @@\n --  (for specialized Sequential_IO functions)\n \n with Ada.Unchecked_Conversion;\n+\n with System;\n+with System.Byte_Swapping;\n with System.CRTL;\n with System.File_Control_Block;\n with System.File_IO;\n with System.Storage_Elements;\n+\n with Interfaces.C_Streams; use Interfaces.C_Streams;\n-with GNAT.Byte_Swapping;\n \n package body Ada.Sequential_IO is\n \n@@ -69,11 +71,11 @@ package body Ada.Sequential_IO is\n    ---------------\n \n    procedure Byte_Swap (Siz : in out size_t) is\n-      use GNAT.Byte_Swapping;\n+      use System.Byte_Swapping;\n    begin\n       case Siz'Size is\n-         when 32     => Swap4 (Siz'Address);\n-         when 64     => Swap8 (Siz'Address);\n+         when 32     => Siz := size_t (Bswap_32 (U32 (Siz)));\n+         when 64     => Siz := size_t (Bswap_64 (U64 (Siz)));\n          when others => raise Program_Error;\n       end case;\n    end Byte_Swap;\n@@ -189,6 +191,9 @@ package body Ada.Sequential_IO is\n          FIO.Read_Buf\n            (AP (File), Rsiz'Address, size_t'Size / System.Storage_Unit);\n \n+         --  If item read has non-default scalar storage order, then the size\n+         --  will have been written with that same order, so byte swap it.\n+\n          if Element_Type'Scalar_Storage_Order /= System.Default_Bit_Order then\n             Byte_Swap (Rsiz);\n          end if;\n@@ -288,6 +293,9 @@ package body Ada.Sequential_IO is\n       if not Element_Type'Definite\n         or else Element_Type'Has_Discriminants\n       then\n+         --  If item written has non-default scalar storage order, then the\n+         --  size is written with that same order, so byte swap it.\n+\n          if Element_Type'Scalar_Storage_Order /= System.Default_Bit_Order then\n             Byte_Swap (Swapped_Siz);\n          end if;"}, {"sha": "8e1124aca4b1384db366d3581ade4fb61189402a", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -5849,7 +5849,6 @@ package body Exp_Ch3 is\n    procedure Expand_N_Variant_Part (N : Node_Id) is\n       Last_Var    : constant Node_Id := Last_Non_Pragma (Variants (N));\n       Others_Node : Node_Id;\n-      Variant     : Node_Id;\n \n    begin\n       --  If the last variant does not contain the Others choice, replace it\n@@ -5866,15 +5865,12 @@ package body Exp_Ch3 is\n          Set_Discrete_Choices (Last_Var, New_List (Others_Node));\n       end if;\n \n-      --  Deal with any static predicates in the variant choices. Note that we\n-      --  don't have to look at the last variant, since we know it is an others\n-      --  choice, because we just rewrote it that way if necessary.\n+      --  We have one more expansion activity, which is to deal with static\n+      --  predicates in the variant choices. But we have to defer that to\n+      --  the freeze point, because the statically predicated subtype won't\n+      --  be fully processed till then, so this expansion activity is carried\n+      --  out in Freeze_Record_Type.\n \n-      Variant := First_Non_Pragma (Variants (N));\n-      while Variant /= Last_Var loop\n-         Expand_Static_Predicates_In_Choices (Variant);\n-         Next_Non_Pragma (Variant);\n-      end loop;\n    end Expand_N_Variant_Part;\n \n    ---------------------------------"}, {"sha": "f166ff464aed3fe4a70f17739fc684929776ce06", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -2627,7 +2627,11 @@ package body Exp_Ch5 is\n          Alt := First_Non_Pragma (Alternatives (N));\n          while Present (Alt) loop\n             Process_Statements_For_Controlled_Objects (Alt);\n-            Expand_Static_Predicates_In_Choices (Alt);\n+\n+            if Has_SP_Choice (Alt) then\n+               Expand_Static_Predicates_In_Choices (Alt);\n+            end if;\n+\n             Next_Non_Pragma (Alt);\n          end loop;\n       end;"}, {"sha": "d2955e5b2debd8eb6c2631a4d35f014671e7b30c", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -1991,7 +1991,7 @@ package body Exp_Util is\n                end if;\n \n                --  Change Sloc to referencing choice (rather than the Sloc of\n-               --  the predicate declarationo element itself).\n+               --  the predicate declaration element itself).\n \n                Set_Sloc (C, Sloc (Choice));\n                Insert_Before (Choice, C);"}, {"sha": "ac9f570fda93527b4f33bbf2fed5621ead668335", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 164, "deletions": 21, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -46,6 +46,7 @@ with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n+with Sem_Case; use Sem_Case;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch7;  use Sem_Ch7;\n@@ -846,8 +847,9 @@ package body Freeze is\n                  and then Nkind (Type_Definition (Parent (T))) =\n                                                N_Record_Definition\n                  and then not Null_Present (Type_Definition (Parent (T)))\n-                 and then Present (Variant_Part\n-                            (Component_List (Type_Definition (Parent (T)))))\n+                 and then\n+                   Present (Variant_Part\n+                              (Component_List (Type_Definition (Parent (T)))))\n                then\n                   --  If variant part is present, and type is unconstrained,\n                   --  then we must have defaulted discriminants, or a size\n@@ -2272,7 +2274,7 @@ package body Freeze is\n                begin\n                   if Present (Alloc) then\n \n-                     --  If component is pointer to a classwide type, freeze\n+                     --  If component is pointer to a class-wide type, freeze\n                      --  the specific type in the expression being allocated.\n                      --  The expression may be a subtype indication, in which\n                      --  case freeze the subtype mark.\n@@ -2367,7 +2369,8 @@ package body Freeze is\n \n          if Present (ADC) and then Base_Type (Rec) = Rec then\n             if not (Placed_Component or else Is_Packed (Rec)) then\n-               Error_Msg_N (\"??bit order specification has no effect\", ADC);\n+               Error_Msg_N\n+                 (\"??bit order specification has no effect\", ADC);\n                Error_Msg_N\n                  (\"\\??since no component clauses were specified\", ADC);\n \n@@ -2443,34 +2446,32 @@ package body Freeze is\n          --  remote type here since that is what we are semantically freezing.\n          --  This prevents the freeze node for that type in an inner scope.\n \n-         --  Also, Check for controlled components and unchecked unions.\n-         --  Finally, enforce the restriction that access attributes with a\n-         --  current instance prefix can only apply to limited types.\n-\n          if Ekind (Rec) = E_Record_Type then\n             if Present (Corresponding_Remote_Type (Rec)) then\n                Freeze_And_Append (Corresponding_Remote_Type (Rec), N, Result);\n             end if;\n \n+            --  Check for controlled components and unchecked unions.\n+\n             Comp := First_Component (Rec);\n             while Present (Comp) loop\n \n                --  Do not set Has_Controlled_Component on a class-wide\n                --  equivalent type. See Make_CW_Equivalent_Type.\n \n                if not Is_Class_Wide_Equivalent_Type (Rec)\n-                 and then (Has_Controlled_Component (Etype (Comp))\n-                            or else (Chars (Comp) /= Name_uParent\n-                                      and then Is_Controlled (Etype (Comp)))\n-                            or else (Is_Protected_Type (Etype (Comp))\n-                                      and then\n-                                        Present\n-                                          (Corresponding_Record_Type\n-                                             (Etype (Comp)))\n-                                      and then\n-                                        Has_Controlled_Component\n-                                          (Corresponding_Record_Type\n-                                             (Etype (Comp)))))\n+                 and then\n+                   (Has_Controlled_Component (Etype (Comp))\n+                     or else\n+                       (Chars (Comp) /= Name_uParent\n+                         and then Is_Controlled (Etype (Comp)))\n+                     or else\n+                       (Is_Protected_Type (Etype (Comp))\n+                         and then\n+                           Present (Corresponding_Record_Type (Etype (Comp)))\n+                         and then\n+                           Has_Controlled_Component\n+                             (Corresponding_Record_Type (Etype (Comp)))))\n                then\n                   Set_Has_Controlled_Component (Rec);\n                end if;\n@@ -2490,11 +2491,17 @@ package body Freeze is\n             end loop;\n          end if;\n \n+         --  Enforce the restriction that access attributes with a current\n+         --  instance prefix can only apply to limited types. This comment\n+         --  is floating here, but does not seem to belong here???\n+\n+         --  Set component alignment if not otherwise already set\n+\n          Set_Component_Alignment_If_Not_Set (Rec);\n \n          --  For first subtypes, check if there are any fixed-point fields with\n          --  component clauses, where we must check the size. This is not done\n-         --  till the freeze point, since for fixed-point types, we do not know\n+         --  till the freeze point since for fixed-point types, we do not know\n          --  the size until the type is frozen. Similar processing applies to\n          --  bit packed arrays.\n \n@@ -2613,6 +2620,142 @@ package body Freeze is\n                end;\n             end if;\n          end if;\n+\n+         --  All done if not a full record definition\n+\n+         if Ekind (Rec) /= E_Record_Type then\n+            return;\n+         end if;\n+\n+         --  Finallly we need to check the variant part to make sure that\n+         --  the set of choices for each variant covers the corresponding\n+         --  discriminant. This check has to be delayed to the freeze point\n+         --  because we may have statically predicated subtypes, whose choice\n+         --  list is not known till the subtype is frozen.\n+\n+         Check_Variant_Part : declare\n+            D : constant Node_Id := Declaration_Node (Rec);\n+            T : Node_Id;\n+            C : Node_Id;\n+            V : Node_Id;\n+\n+            Others_Present            : Boolean;\n+            pragma Warnings (Off, Others_Present);\n+            --  Indicates others present, not used in this case\n+\n+            procedure Non_Static_Choice_Error (Choice : Node_Id);\n+            --  Error routine invoked by the generic instantiation below when\n+            --  the variant part has a non static choice.\n+\n+            procedure Process_Declarations (Variant : Node_Id);\n+            --  Processes declarations associated with a variant. We analyzed\n+            --  the declarations earlier (in Sem_Ch3.Analyze_Variant_Part),\n+            --  but we still need the recursive call to Check_Choices for any\n+            --  nested variant to get its choices properly processed. This is\n+            --  also where we expand out the choices if expansion is active.\n+\n+            package Variant_Choices_Processing is new\n+              Generic_Check_Choices\n+                (Process_Empty_Choice      => No_OP,\n+                 Process_Non_Static_Choice => Non_Static_Choice_Error,\n+                 Process_Associated_Node   => Process_Declarations);\n+            use Variant_Choices_Processing;\n+\n+            -----------------------------\n+            -- Non_Static_Choice_Error --\n+            -----------------------------\n+\n+            procedure Non_Static_Choice_Error (Choice : Node_Id) is\n+            begin\n+               Flag_Non_Static_Expr\n+                 (\"choice given in variant part is not static!\", Choice);\n+            end Non_Static_Choice_Error;\n+\n+            --------------------------\n+            -- Process_Declarations --\n+            --------------------------\n+\n+            procedure Process_Declarations (Variant : Node_Id) is\n+               CL : constant Node_Id := Component_List (Variant);\n+               VP : Node_Id;\n+\n+            begin\n+               --  Check for static predicate present in this variant\n+\n+               if Has_SP_Choice (Variant) then\n+\n+                  --  Here we expand. You might expect to find this call in\n+                  --  Expand_N_Variant_Part, but that is called when we first\n+                  --  see the variant part, and we cannot do this expansion\n+                  --  earlier than the freeze point, since for statically\n+                  --  predicated subtypes, the predicate is not known till\n+                  --  the freeze point.\n+\n+                  --  Furthermore, we do this expansion even if the expander\n+                  --  is not active, because other semantic processing, e.g.\n+                  --  for aggregates, requires the expanded list of choices.\n+\n+                  --  If the expander is not active, then we can't just clobber\n+                  --  the list since it would invalidate the ASIS -gnatct tree.\n+                  --  So we have to rewrite the variant part with a Rewrite\n+                  --  call that replaces it with a copy and clobber the copy.\n+\n+                  if not Expander_Active then\n+                     declare\n+                        NewV : constant Node_Id := New_Copy (Variant);\n+                     begin\n+                        Set_Discrete_Choices\n+                          (NewV, New_Copy_List (Discrete_Choices (Variant)));\n+                        Rewrite (Variant, NewV);\n+                     end;\n+                  end if;\n+\n+                  Expand_Static_Predicates_In_Choices (Variant);\n+               end if;\n+\n+               --  We don't need to worry about the declarations in the variant\n+               --  (since they were analyzed by Analyze_Choices when we first\n+               --  encountered the variant), but we do need to take care of\n+               --  expansion of any nested variants.\n+\n+               if not Null_Present (CL) then\n+                  VP := Variant_Part (CL);\n+\n+                  if Present (VP) then\n+                     Check_Choices\n+                       (VP, Variants (VP), Etype (Name (VP)), Others_Present);\n+                  end if;\n+               end if;\n+            end Process_Declarations;\n+\n+         --  Start of processing for Check_Variant_Part\n+\n+         begin\n+            --  Find component list\n+\n+            C := Empty;\n+\n+            if Nkind (D) = N_Full_Type_Declaration then\n+               T := Type_Definition (D);\n+\n+               if Nkind (T) = N_Record_Definition then\n+                  C := Component_List (T);\n+\n+               elsif Nkind (T) = N_Derived_Type_Definition\n+                 and then Present (Record_Extension_Part (T))\n+               then\n+                  C := Component_List (Record_Extension_Part (T));\n+               end if;\n+            end if;\n+\n+            --  If we have a variant part, check choices\n+\n+            if Present (C) and then Present (Variant_Part (C)) then\n+               V := Variant_Part (C);\n+               Check_Choices\n+                 (V, Variants (V), Etype (Name (V)), Others_Present);\n+            end if;\n+         end Check_Variant_Part;\n       end Freeze_Record_Type;\n \n    --  Start of processing for Freeze_Entity"}, {"sha": "849ff0e2dbf715556084b50b5ec27ce287644d30", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -1022,11 +1022,10 @@ package body SPARK_Specific is\n \n             when N_Pragma =>\n \n-               --  The enclosing subprogram for a precondition, a\n-               --  postcondition, or a contract case should be the subprogram\n-               --  to which the pragma is attached, which can be found by\n-               --  following previous elements in the list to which the\n-               --  pragma belongs.\n+               --  The enclosing subprogram for a precondition, postcondition,\n+               --  or contract case should be the subprogram to which the\n+               --  pragma is attached, which can be found by following\n+               --  previous elements in the list to which the pragma belongs.\n \n                if Get_Pragma_Id (Result) = Pragma_Precondition\n                     or else"}, {"sha": "4105901a6341b0c5fc00b46398983c682b3c3b18", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2011, AdaCore                     --\n+--                     Copyright (C) 2001-2013, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1651,7 +1651,7 @@ package body MLib.Prj is\n          --  content of Rpath. As Rpath contains at least libgnat directory\n          --  path name, it is guaranteed that it is not null.\n \n-         if Path_Option /= null then\n+         if Opt.Run_Path_Option and then Path_Option /= null then\n             Opts.Increment_Last;\n             Opts.Table (Opts.Last) :=\n               new String'(Path_Option.all & Rpath (1 .. Rpath_Last));"}, {"sha": "18c63a3bf6c3989a8bd5c5969a6160717f522db6", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -88,9 +88,9 @@ package body Ch13 is\n             Result := True;\n          else\n             Scan; -- past identifier\n-            Result := Token = Tok_Arrow\n-                         or else Token = Tok_Comma\n-                         or else Token = Tok_Semicolon;\n+            Result := Token = Tok_Arrow or else\n+                      Token = Tok_Comma or else\n+                      Token = Tok_Semicolon;\n          end if;\n \n       --  If earlier than Ada 2012, check for valid aspect identifier (possibly\n@@ -113,9 +113,7 @@ package body Ch13 is\n             --  defaulted True value. Further checks when analyzing aspect\n             --  specification, which may include further aspects.\n \n-            elsif Token = Tok_Comma\n-              or else Token = Tok_Semicolon\n-            then\n+            elsif Token = Tok_Comma or else Token = Tok_Semicolon then\n                Result := True;\n \n             elsif Token = Tok_Apostrophe then"}, {"sha": "55436aa8388321e3c6a1843211332578c4ee7e2b", "filename": "gcc/ada/s-atocou-builtin.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fs-atocou-builtin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fs-atocou-builtin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-atocou-builtin.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -64,8 +64,8 @@ package body System.Atomic_Counters is\n \n    procedure Increment (Item : in out Atomic_Counter) is\n    begin\n-      --  Note: the use of Unrestricted_Access here is required because we\n-      --  are obtaining an access-to-volatile pointer to a non-volatile object.\n+      --  Note: the use of Unrestricted_Access here is required because we are\n+      --  obtaining an access-to-volatile pointer to a non-volatile object.\n       --  This is not allowed for [Unchecked_]Access, but is safe in this case\n       --  because we know that no aliases are being created.\n "}, {"sha": "88dc5849def24f8e6d1e44ed280b039c786ece0a", "filename": "gcc/ada/s-imgint.adb", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fs-imgint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fs-imgint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-imgint.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,39 +42,15 @@ package body System.Img_Int is\n    is\n       pragma Assert (S'First = 1);\n \n-      procedure Set_Digits (T : Integer);\n-      --  Set digits of absolute value of T, which is zero or negative. We work\n-      --  with the negative of the value so that the largest negative number is\n-      --  not a special case.\n-\n-      ----------------\n-      -- Set_Digits --\n-      ----------------\n-\n-      procedure Set_Digits (T : Integer) is\n-      begin\n-         if T <= -10 then\n-            Set_Digits (T / 10);\n-            P := P + 1;\n-            S (P) := Character'Val (48 - (T rem 10));\n-         else\n-            P := P + 1;\n-            S (P) := Character'Val (48 - T);\n-         end if;\n-      end Set_Digits;\n-\n-   --  Start of processing for Image_Integer\n-\n    begin\n-      P := 1;\n-\n       if V >= 0 then\n-         S (P) := ' ';\n-         Set_Digits (-V);\n+         S (1) := ' ';\n+         P := 1;\n       else\n-         S (P) := '-';\n-         Set_Digits (V);\n+         P := 0;\n       end if;\n+\n+      Set_Image_Integer (V, S, P);\n    end Image_Integer;\n \n    -----------------------"}, {"sha": "d3b0ef4e1e3afefd34c98cf64a680b7dac905a91", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1420,7 +1420,7 @@ CND(CLOCK_THREAD_CPUTIME_ID, \"Thread CPU clock\")\n  ** appropriately (see thread.c).\n  **/\n # define CLOCK_RT_Ada \"CLOCK_MONOTONIC\"\n-# define NEED_PTHREAD_CONDATTR_SETCLOCK\n+# define NEED_PTHREAD_CONDATTR_SETCLOCK 1\n \n #elif defined(HAVE_CLOCK_REALTIME)\n /* By default use CLOCK_REALTIME */\n@@ -1430,6 +1430,9 @@ CND(CLOCK_THREAD_CPUTIME_ID, \"Thread CPU clock\")\n #ifdef CLOCK_RT_Ada\n CNS(CLOCK_RT_Ada, \"\")\n #endif\n+#ifdef NEED_PTHREAD_CONDATTR_SETCLOCK\n+CND(NEED_PTHREAD_CONDATTR_SETCLOCK, \"\")\n+#endif\n \n #if defined (__APPLE__) || defined (__linux__) || defined (DUMMY)\n /*"}, {"sha": "2cb6cd1b3180055fd08e1ba201e4b2edb46c4110", "filename": "gcc/ada/s-stalib.ads", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fs-stalib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fs-stalib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stalib.ads?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -74,26 +74,6 @@ package System.Standard_Library is\n    function To_Ptr is\n      new Ada.Unchecked_Conversion (System.Address, Big_String_Ptr);\n \n-   ---------------------------------------------\n-   -- Type For Enumeration Image Index Tables --\n-   ---------------------------------------------\n-\n-   --  Note: these types are declared at the start of this unit, since\n-   --  they must appear before any enumeration types declared in this\n-   --  unit. Note that the spec of system is already elaborated at\n-   --  this point (since we are a child of system), which means that\n-   --  enumeration types in package System cannot use these types.\n-\n-   type Image_Index_Table_8 is\n-     array (Integer range <>) of Short_Short_Integer;\n-   type Image_Index_Table_16 is\n-     array (Integer range <>) of Short_Integer;\n-   type Image_Index_Table_32 is\n-     array (Integer range <>) of Integer;\n-   --  These types are used to generate the index vector used for enumeration\n-   --  type image tables. See spec of Exp_Imgv in the main GNAT sources for a\n-   --  full description of the data structures that are used here.\n-\n    -------------------------------------\n    -- Exception Declarations and Data --\n    -------------------------------------"}, {"sha": "404242f3eed45d69dfe5fccebec3307770c8a04d", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -3416,6 +3416,7 @@ package body Sem_Aggr is\n \n    begin\n       --  A record aggregate is restricted in SPARK:\n+\n       --    Each named association can have only a single choice.\n       --    OTHERS cannot be used.\n       --    Positional and named associations cannot be mixed.\n@@ -3758,6 +3759,8 @@ package body Sem_Aggr is\n             end loop;\n          end Find_Private_Ancestor;\n \n+      --  Start of processing for Step_5\n+\n       begin\n          if Is_Derived_Type (Typ) and then Is_Tagged_Type (Typ) then\n             Parent_Typ_List := New_Elmt_List;\n@@ -3822,11 +3825,12 @@ package body Sem_Aggr is\n \n                if Nkind (Dnode) = N_Full_Type_Declaration then\n                   Record_Def := Type_Definition (Dnode);\n-                  Gather_Components (Base_Type (Typ),\n-                    Component_List (Record_Def),\n-                    Governed_By   => New_Assoc_List,\n-                    Into          => Components,\n-                    Report_Errors => Errors_Found);\n+                  Gather_Components\n+                    (Base_Type (Typ),\n+                     Component_List (Record_Def),\n+                     Governed_By   => New_Assoc_List,\n+                     Into          => Components,\n+                     Report_Errors => Errors_Found);\n                end if;\n             end if;\n \n@@ -3915,19 +3919,20 @@ package body Sem_Aggr is\n                null;\n \n             elsif not Has_Unknown_Discriminants (Typ) then\n-               Gather_Components (Base_Type (Typ),\n-                 Component_List (Record_Def),\n-                 Governed_By   => New_Assoc_List,\n-                 Into          => Components,\n-                 Report_Errors => Errors_Found);\n+               Gather_Components\n+                 (Base_Type (Typ),\n+                  Component_List (Record_Def),\n+                  Governed_By   => New_Assoc_List,\n+                  Into          => Components,\n+                  Report_Errors => Errors_Found);\n \n             else\n                Gather_Components\n                  (Base_Type (Underlying_Record_View (Typ)),\n-                 Component_List (Record_Def),\n-                 Governed_By   => New_Assoc_List,\n-                 Into          => Components,\n-                 Report_Errors => Errors_Found);\n+                  Component_List (Record_Def),\n+                  Governed_By   => New_Assoc_List,\n+                  Into          => Components,\n+                  Report_Errors => Errors_Found);\n             end if;\n          end if;\n "}, {"sha": "53f66b011dbfa8a63854067e89f87a9bda6ea749", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -5041,7 +5041,8 @@ package body Sem_Attr is\n \n       when Attribute_Scalar_Storage_Order => Scalar_Storage_Order :\n       declare\n-         Ent : Entity_Id := Empty;\n+            Ent : Entity_Id := Empty;\n+\n       begin\n          Check_E0;\n          Check_Type;\n@@ -5053,7 +5054,7 @@ package body Sem_Attr is\n             --  the default bit order for the target.\n \n             if not (GNAT_Mode and then Is_Generic_Type (P_Type))\n-                  and then not In_Instance\n+                     and then not In_Instance\n             then\n                Error_Attr_P\n                  (\"prefix of % attribute must be record or array type\");"}, {"sha": "670177615e3a320cdf69f88ca1695bbdfa3eb549", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 179, "deletions": 45, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -26,6 +26,8 @@\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n+with Exp_Util; use Exp_Util;\n+with Freeze;   use Freeze;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -65,7 +67,7 @@ package body Sem_Case is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Check_Choices\n+   procedure Check_Choice_Set\n      (Choice_Table   : in out Choice_Table_Type;\n       Bounds_Type    : Entity_Id;\n       Subtyp         : Entity_Id;\n@@ -95,19 +97,19 @@ package body Sem_Case is\n      (Case_Table     : Choice_Table_Type;\n       Others_Choice  : Node_Id;\n       Choice_Type    : Entity_Id);\n-   --  The case table is the table generated by a call to Analyze_Choices\n+   --  The case table is the table generated by a call to Check_Choices\n    --  (with just 1 .. Last_Choice entries present). Others_Choice is a\n    --  pointer to the N_Others_Choice node (this routine is only called if\n    --  an others choice is present), and Choice_Type is the discrete type\n    --  of the bounds. The effect of this call is to analyze the cases and\n    --  determine the set of values covered by others. This choice list is\n    --  set in the Others_Discrete_Choices field of the N_Others_Choice node.\n \n-   -------------------\n-   -- Check_Choices --\n-   -------------------\n+   ----------------------\n+   -- Check_Choice_Set --\n+   ----------------------\n \n-   procedure Check_Choices\n+   procedure Check_Choice_Set\n      (Choice_Table   : in out Choice_Table_Type;\n       Bounds_Type    : Entity_Id;\n       Subtyp         : Entity_Id;\n@@ -598,7 +600,7 @@ package body Sem_Case is\n       Prev_Lo     : Uint;\n       Prev_Hi     : Uint;\n \n-   --  Start of processing for Check_Choices\n+   --  Start of processing for Check_Choice_Set\n \n    begin\n       --  Choice_Table must start at 0 which is an unused location used by the\n@@ -714,7 +716,7 @@ package body Sem_Case is\n             end if;\n          end if;\n       end if;\n-   end Check_Choices;\n+   end Check_Choice_Set;\n \n    ------------------\n    -- Choice_Image --\n@@ -799,11 +801,10 @@ package body Sem_Case is\n       Previous_Hi : Uint;\n \n       function Build_Choice (Value1, Value2 : Uint) return Node_Id;\n-      --  Builds a node representing the missing choices given by the\n-      --  Value1 and Value2. A N_Range node is built if there is more than\n-      --  one literal value missing. Otherwise a single N_Integer_Literal,\n-      --  N_Identifier or N_Character_Literal is built depending on what\n-      --  Choice_Type is.\n+      --  Builds a node representing the missing choices given by Value1 and\n+      --  Value2. A N_Range node is built if there is more than one literal\n+      --  value missing. Otherwise a single N_Integer_Literal, N_Identifier\n+      --  or N_Character_Literal is built depending on what Choice_Type is.\n \n       function Lit_Of (Value : Uint) return Node_Id;\n       --  Returns the Node_Id for the enumeration literal corresponding to the\n@@ -975,11 +976,11 @@ package body Sem_Case is\n       null;\n    end No_OP;\n \n-   --------------------------------\n-   -- Generic_Choices_Processing --\n-   --------------------------------\n+   -----------------------------\n+   -- Generic_Analyze_Choices --\n+   -----------------------------\n \n-   package body Generic_Choices_Processing is\n+   package body Generic_Analyze_Choices is\n \n       --  The following type is used to gather the entries for the choice\n       --  table, so that we can then allocate the right length.\n@@ -992,20 +993,143 @@ package body Sem_Case is\n          Nxt : Link_Ptr;\n       end record;\n \n-      procedure Free is new Ada.Unchecked_Deallocation (Link, Link_Ptr);\n-\n       ---------------------\n       -- Analyze_Choices --\n       ---------------------\n \n       procedure Analyze_Choices\n-        (N              : Node_Id;\n-         Subtyp         : Entity_Id;\n-         Raises_CE      : out Boolean;\n-         Others_Present : out Boolean)\n+        (Alternatives : List_Id;\n+         Subtyp       : Entity_Id)\n+      is\n+         Choice_Type : constant Entity_Id := Base_Type (Subtyp);\n+         --  The actual type against which the discrete choices are resolved.\n+         --  Note that this type is always the base type not the subtype of the\n+         --  ruling expression, index or discriminant.\n+\n+         Expected_Type : Entity_Id;\n+         --  The expected type of each choice. Equal to Choice_Type, except if\n+         --  the expression is universal, in which case the choices can be of\n+         --  any integer type.\n+\n+         Alt : Node_Id;\n+         --  A case statement alternative or a variant in a record type\n+         --  declaration.\n+\n+         Choice : Node_Id;\n+         Kind   : Node_Kind;\n+         --  The node kind of the current Choice\n+\n+      begin\n+         --  Set Expected type (= choice type except for universal integer,\n+         --  where we accept any integer type as a choice).\n+\n+         if Choice_Type = Universal_Integer then\n+            Expected_Type := Any_Integer;\n+         else\n+            Expected_Type := Choice_Type;\n+         end if;\n+\n+         --  Now loop through the case alternatives or record variants\n+\n+         Alt := First (Alternatives);\n+         while Present (Alt) loop\n+\n+            --  If pragma, just analyze it\n+\n+            if Nkind (Alt) = N_Pragma then\n+               Analyze (Alt);\n+\n+            --  Otherwise we have an alternative. In most cases the semantic\n+            --  processing leaves the list of choices unchanged\n+\n+            --  Check each choice against its base type\n+\n+            else\n+               Choice := First (Discrete_Choices (Alt));\n+               while Present (Choice) loop\n+                  Analyze (Choice);\n+                  Kind := Nkind (Choice);\n+\n+                  --  Choice is a Range\n+\n+                  if Kind = N_Range\n+                    or else (Kind = N_Attribute_Reference\n+                              and then Attribute_Name (Choice) = Name_Range)\n+                  then\n+                     Resolve (Choice, Expected_Type);\n+\n+                  --  Choice is a subtype name, nothing further to do now\n+\n+                  elsif Is_Entity_Name (Choice)\n+                    and then Is_Type (Entity (Choice))\n+                  then\n+                     null;\n+\n+                  --  Choice is a subtype indication\n+\n+                  elsif Kind = N_Subtype_Indication then\n+                     Resolve_Discrete_Subtype_Indication\n+                       (Choice, Expected_Type);\n+\n+                  --  Others choice, no analysis needed\n+\n+                  elsif Kind = N_Others_Choice then\n+                     null;\n+\n+                  --  Only other possibility is an expression\n+\n+                  else\n+                     Resolve (Choice, Expected_Type);\n+                  end if;\n+\n+                  --  Move to next choice\n+\n+                  Next (Choice);\n+               end loop;\n+\n+               Process_Associated_Node (Alt);\n+            end if;\n+\n+            Next (Alt);\n+         end loop;\n+      end Analyze_Choices;\n+\n+   end Generic_Analyze_Choices;\n+\n+   ---------------------------\n+   -- Generic_Check_Choices --\n+   ---------------------------\n+\n+   package body Generic_Check_Choices is\n+\n+      --  The following type is used to gather the entries for the choice\n+      --  table, so that we can then allocate the right length.\n+\n+      type Link;\n+      type Link_Ptr is access all Link;\n+\n+      type Link is record\n+         Val : Choice_Bounds;\n+         Nxt : Link_Ptr;\n+      end record;\n+\n+      procedure Free is new Ada.Unchecked_Deallocation (Link, Link_Ptr);\n+\n+      -------------------\n+      -- Check_Choices --\n+      -------------------\n+\n+      procedure Check_Choices\n+        (N                        : Node_Id;\n+         Alternatives             : List_Id;\n+         Subtyp                   : Entity_Id;\n+         Others_Present           : out Boolean)\n       is\n          E : Entity_Id;\n \n+         Raises_CE : Boolean;\n+         --  Set True if one of the bounds of a choice raises CE\n+\n          Enode : Node_Id;\n          --  This is where we post error messages for bounds out of range\n \n@@ -1042,9 +1166,6 @@ package body Sem_Case is\n          Kind   : Node_Kind;\n          --  The node kind of the current Choice\n \n-         Delete_Choice : Boolean;\n-         --  Set to True to delete the current choice\n-\n          Others_Choice : Node_Id := Empty;\n          --  Remember others choice if it is present (empty otherwise)\n \n@@ -1166,12 +1287,22 @@ package body Sem_Case is\n             Num_Choices := Num_Choices + 1;\n          end Check;\n \n-      --  Start of processing for Analyze_Choices\n+      --  Start of processing for Check_Choices\n \n       begin\n          Raises_CE      := False;\n          Others_Present := False;\n \n+         --  If Subtyp is not a discrete type or there was some other error,\n+         --  then don't try any semantic checking on the choices since we have\n+         --  a complete mess.\n+\n+         if not Is_Discrete_Type (Subtyp)\n+           or else Subtyp = Any_Type\n+         then\n+            return;\n+         end if;\n+\n          --  If Subtyp is not a static subtype Ada 95 requires then we use the\n          --  bounds of its base type to determine the values covered by the\n          --  discrete choices.\n@@ -1210,7 +1341,7 @@ package body Sem_Case is\n \n          --  Now loop through the case alternatives or record variants\n \n-         Alt := First (Get_Alternatives (N));\n+         Alt := First (Alternatives);\n          while Present (Alt) loop\n \n             --  If pragma, just analyze it\n@@ -1226,7 +1357,6 @@ package body Sem_Case is\n             else\n                Choice := First (Discrete_Choices (Alt));\n                while Present (Choice) loop\n-                  Delete_Choice := False;\n                   Analyze (Choice);\n                   Kind := Nkind (Choice);\n \n@@ -1244,9 +1374,19 @@ package body Sem_Case is\n                   elsif Is_Entity_Name (Choice)\n                     and then Is_Type (Entity (Choice))\n                   then\n+                     --  We have to make sure the subtype is frozen, it must be\n+                     --  before we can do the following analyses on choices!\n+\n+                     Insert_Actions\n+                       (N, Freeze_Entity (Entity (Choice), Choice));\n+\n+                     --  Check for inappropriate type\n+\n                      if not Covers (Expected_Type, Etype (Choice)) then\n                         Wrong_Type (Choice, Choice_Type);\n \n+                     --  Type is OK, so check further\n+\n                      else\n                         E := Entity (Choice);\n \n@@ -1285,6 +1425,8 @@ package body Sem_Case is\n                                     Next (P);\n                                  end loop;\n                               end;\n+\n+                              Set_Has_SP_Choice (Alt);\n                            end if;\n \n                         --  Not predicated subtype case\n@@ -1318,7 +1460,8 @@ package body Sem_Case is\n \n                            else\n                               if Is_OK_Static_Expression (L)\n-                                and then Is_OK_Static_Expression (H)\n+                                   and then\n+                                 Is_OK_Static_Expression (H)\n                               then\n                                  if Expr_Value (L) > Expr_Value (H) then\n                                     Process_Empty_Choice (Choice);\n@@ -1348,7 +1491,7 @@ package body Sem_Case is\n                   elsif Kind = N_Others_Choice then\n                      if not (Choice = First (Discrete_Choices (Alt))\n                               and then Choice = Last (Discrete_Choices (Alt))\n-                              and then Alt = Last (Get_Alternatives (N)))\n+                              and then Alt = Last (Alternatives))\n                      then\n                         Error_Msg_N\n                           (\"the choice OTHERS must appear alone and last\",\n@@ -1366,18 +1509,9 @@ package body Sem_Case is\n                      Check (Choice, Choice, Choice);\n                   end if;\n \n-                  --  Move to next choice, deleting the current one if the\n-                  --  flag requesting this deletion is set True.\n+                  --  Move to next choice\n \n-                  declare\n-                     C : constant Node_Id := Choice;\n-                  begin\n-                     Next (Choice);\n-\n-                     if Delete_Choice then\n-                        Remove (C);\n-                     end if;\n-                  end;\n+                  Next (Choice);\n                end loop;\n \n                Process_Associated_Node (Alt);\n@@ -1407,7 +1541,7 @@ package body Sem_Case is\n                end loop;\n             end;\n \n-            Check_Choices\n+            Check_Choice_Set\n               (Choice_Table,\n                Bounds_Type,\n                Subtyp,\n@@ -1426,8 +1560,8 @@ package body Sem_Case is\n                   Choice_Type   => Bounds_Type);\n             end if;\n          end;\n-      end Analyze_Choices;\n+      end Check_Choices;\n \n-   end Generic_Choices_Processing;\n+   end Generic_Check_Choices;\n \n end Sem_Case;"}, {"sha": "c6917f06837da620d6dd6ed502c16b105da3e370", "filename": "gcc/ada/sem_case.ads", "status": "modified", "additions": 95, "deletions": 23, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_case.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_case.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.ads?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -30,52 +30,124 @@\n --  aggregate case, since issues with nested aggregates make that case\n --  substantially different.\n \n+--  The following processing is required for such cases:\n+\n+--    1. Analysis of names of subtypes, constants, expressions appearing within\n+--    the choices. This must be done when the construct is encountered to get\n+--    proper visibility of names.\n+\n+--    2. Checking for semantic correctness of the choices. A lot of this could\n+--    be done at the time when the construct is encountered, but not all, since\n+--    in the case of variants, statically predicated subtypes won't be frozen\n+--    (and the choice sets known) till the enclosing record type is frozen. So\n+--    at least the check for no overlaps and covering the range must be delayed\n+--    till the freeze point in this case.\n+\n+--    3. Set the Others_Discrete_Choices list for an others choice. This is\n+--    used in various ways, e.g. to construct the disriminant checking function\n+--    for the case of a variant with an others choice.\n+\n+--    4. In the case of static predicates, we need to expand out choices that\n+--    correspond to the predicate for the back end. This expansion destroys\n+--    the list of choices, so it should be delayed to expansion time. We do\n+--    not want to mess up the -gnatct ASIS tree, which needs to be able to\n+\n+--  Step 1 is performed by the generic procedure Analyze_Choices, which is\n+--  called when the variant record or case statement/expression is first\n+--  encountered.\n+\n+--  Step 2 is performed by the generic procedure Check_Choices. We decide to\n+--  do all semantic checking in that step, since as noted above some of this\n+--  has to be deferred to the freeze point in any case for variants. For case\n+--  statements and expressions, this procedure can be called at the time the\n+--  case construct is encountered (after calling Analyze_Choices).\n+\n+--  Step 3 is also performed by Check_Choices, since we need the static ranges\n+--  for predicated subtypes to accurately construct this.\n+\n+--  Step 4 is performed by the procedure Expand_Static_Predicates_In_Choices.\n+--  For case statements, this call only happens during expansion, so the tree\n+--  generated for ASIS does not have this expansion. For the Variant case, the\n+--  expansion is done in the ASIS -gnatct case, but with a proper Rewrite call\n+--  on the N_Variant node, so ASIS can retrieve the original. The reason we do\n+--  the expansion unconditionally for variants is that other processing, for\n+--  example for aggregates, relies on having a complete list of choices.\n+\n+--  Historical note: We used to perform all four of these functions at once in\n+--  a single procedure called Analyze_Choices. This routine was called at the\n+--  time the construct was first encountered. That seemed to work OK up to Ada\n+--  2005, but the introduction of statically predicated subtypes with delayed\n+--  evaluation of the static ranges made this completely wrong, both because\n+--  the ASIS tree got destroyed by step 4, and steps 2 and 3 were too early\n+--  in the variant record case.\n+\n with Types; use Types;\n \n package Sem_Case is\n \n    procedure No_OP (C : Node_Id);\n    --  The no-operation routine. Does absolutely nothing. Can be used\n-   --  in the following generic for the parameter Process_Empty_Choice.\n+   --  in the following generics for the parameters Process_Empty_Choice,\n+   --  or Process_Associated_Node.\n \n    generic\n-      with function Get_Alternatives (N : Node_Id) return List_Id;\n-      --  Function used to get the list of case statement alternatives or\n-      --  record variants, from which we can then access the actual lists of\n-      --  discrete choices. N is the node for the original construct (case\n-      --  statement or a record variant).\n+      with procedure Process_Associated_Node (A : Node_Id);\n+      --  Associated with each case alternative or record variant A there is\n+      --  a node or list of nodes that need additional processing. This routine\n+      --  implements that processing.\n+\n+   package Generic_Analyze_Choices is\n+\n+      procedure Analyze_Choices\n+        (Alternatives : List_Id;\n+         Subtyp       : Entity_Id);\n+      --  From a case expression, case statement, or record variant, this\n+      --  routine analyzes the corresponding list of discrete choices which\n+      --  appear in each element of the list Alternatives (for the variant\n+      --  part case, this is the variants, for a case expression or statement,\n+      --  this is the Alternatives).\n+      --\n+      --  Subtyp is the subtype of the discrete choices. The type against which\n+      --  the discrete choices must be resolved is its base type.\n \n+   end Generic_Analyze_Choices;\n+\n+   generic\n       with procedure Process_Empty_Choice (Choice : Node_Id);\n       --  Processing to carry out for an empty Choice. Set to No_Op (declared\n       --  above) if no such processing is required.\n \n       with procedure Process_Non_Static_Choice (Choice : Node_Id);\n-      --  Processing to carry out for a non static Choice\n+      --  Processing to carry out for a non static Choice (gives an error msg)\n \n       with procedure Process_Associated_Node (A : Node_Id);\n       --  Associated with each case alternative or record variant A there is\n       --  a node or list of nodes that need semantic processing. This routine\n       --  implements that processing.\n \n-   package Generic_Choices_Processing is\n+   package Generic_Check_Choices is\n \n-      procedure Analyze_Choices\n-        (N              : Node_Id;\n-         Subtyp         : Entity_Id;\n-         Raises_CE      : out Boolean;\n-         Others_Present : out Boolean);\n+      procedure Check_Choices\n+        (N                        : Node_Id;\n+         Alternatives             : List_Id;\n+         Subtyp                   : Entity_Id;\n+         Others_Present           : out Boolean);\n       --  From a case expression, case statement, or record variant N, this\n-      --  routine analyzes the corresponding list of discrete choices. Subtyp\n-      --  is the subtype of the discrete choices. The type against which the\n-      --  discrete choices must be resolved is its base type.\n+      --  routine analyzes the corresponding list of discrete choices which\n+      --  appear in each element of the list Alternatives (for the variant\n+      --  part case, this is the variants, for a case expression or statement,\n+      --  this is the Alternatives).\n       --\n-      --  If one of the bounds of a discrete choice raises a constraint\n-      --  error the flag Raise_CE is set.\n+      --  Subtyp is the subtype of the discrete choices. The type against which\n+      --  the discrete choices must be resolved is its base type.\n       --\n-      --  Finally Others_Present is set to True if an Others choice is present\n-      --  in the list of choices, and in this case the call also sets\n-      --  Others_Discrete_Choices in the N_Others_Choice node.\n-\n-   end Generic_Choices_Processing;\n+      --  Others_Present is set to True if an Others choice is present in the\n+      --  list of choices, and in this case Others_Discrete_Choices is set in\n+      --  the N_Others_Choice node.\n+      --\n+      --  If a Discrete_Choice list contains at least one instance of a subtype\n+      --  with a static predicate, then the Has_SP_Choice flag is set true in\n+      --  the parent node (N_Variant, N_Case_Expression/Statement_Alternative).\n \n+   end Generic_Check_Choices;\n end Sem_Case;"}, {"sha": "df80232311a85e6da9b7cd97796b33ff7f77f7d5", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -3717,8 +3717,7 @@ package body Sem_Ch12 is\n               (Unit_Requires_Body (Gen_Unit)\n                   or else Enclosing_Body_Present\n                   or else Present (Corresponding_Body (Gen_Decl)))\n-                and then (Is_In_Main_Unit (N)\n-                           or else Might_Inline_Subp)\n+                and then (Is_In_Main_Unit (N) or else Might_Inline_Subp)\n                 and then not Is_Actual_Pack\n                 and then not Inline_Now\n                 and then (Operating_Mode = Generate_Code\n@@ -3728,8 +3727,7 @@ package body Sem_Ch12 is\n             --  If front_end_inlining is enabled, do not instantiate body if\n             --  within a generic context.\n \n-            if (Front_End_Inlining\n-                 and then not Expander_Active)\n+            if (Front_End_Inlining and then not Expander_Active)\n               or else Is_Generic_Unit (Cunit_Entity (Main_Unit))\n             then\n                Needs_Body := False;"}, {"sha": "3a2bb22b4e451efcb065b59734afd4ad37224746", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -7790,7 +7790,7 @@ package body Sem_Ch13 is\n               Aspect_Precondition         |\n               Aspect_Refined_Pre          |\n               Aspect_SPARK_Mode           |\n-              Aspect_Test_Case     =>\n+              Aspect_Test_Case            =>\n             raise Program_Error;\n \n       end case;"}, {"sha": "e900cfaa153b507b75c15a548e7402c8edeb29be", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 28, "deletions": 48, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -4590,60 +4590,31 @@ package body Sem_Ch3 is\n    --------------------------\n \n    procedure Analyze_Variant_Part (N : Node_Id) is\n+      Discr_Name : Node_Id;\n+      Discr_Type : Entity_Id;\n \n-      procedure Non_Static_Choice_Error (Choice : Node_Id);\n-      --  Error routine invoked by the generic instantiation below when the\n-      --  variant part has a non static choice.\n-\n-      procedure Process_Declarations (Variant : Node_Id);\n-      --  Analyzes all the declarations associated with a Variant. Needed by\n-      --  the generic instantiation below.\n-\n-      package Variant_Choices_Processing is new\n-        Generic_Choices_Processing\n-          (Get_Alternatives          => Variants,\n-           Process_Empty_Choice      => No_OP,\n-           Process_Non_Static_Choice => Non_Static_Choice_Error,\n-           Process_Associated_Node   => Process_Declarations);\n-      use Variant_Choices_Processing;\n-      --  Instantiation of the generic choice processing package\n+      procedure Process_Variant (A : Node_Id);\n+      --  Analyze declarations for a single variant\n \n-      -----------------------------\n-      -- Non_Static_Choice_Error --\n-      -----------------------------\n+      package Analyze_Variant_Choices is\n+        new Generic_Analyze_Choices (Process_Variant);\n+      use Analyze_Variant_Choices;\n \n-      procedure Non_Static_Choice_Error (Choice : Node_Id) is\n-      begin\n-         Flag_Non_Static_Expr\n-           (\"choice given in variant part is not static!\", Choice);\n-      end Non_Static_Choice_Error;\n-\n-      --------------------------\n-      -- Process_Declarations --\n-      --------------------------\n+      ---------------------\n+      -- Process_Variant --\n+      ---------------------\n \n-      procedure Process_Declarations (Variant : Node_Id) is\n+      procedure Process_Variant (A : Node_Id) is\n+         CL : constant Node_Id := Component_List (A);\n       begin\n-         if not Null_Present (Component_List (Variant)) then\n-            Analyze_Declarations (Component_Items (Component_List (Variant)));\n+         if not Null_Present (CL) then\n+            Analyze_Declarations (Component_Items (CL));\n \n-            if Present (Variant_Part (Component_List (Variant))) then\n-               Analyze (Variant_Part (Component_List (Variant)));\n+            if Present (Variant_Part (CL)) then\n+               Analyze (Variant_Part (CL));\n             end if;\n          end if;\n-      end Process_Declarations;\n-\n-      --  Local Variables\n-\n-      Discr_Name : Node_Id;\n-      Discr_Type : Entity_Id;\n-\n-      Dont_Care      : Boolean;\n-      Others_Present : Boolean := False;\n-\n-      pragma Warnings (Off, Dont_Care);\n-      pragma Warnings (Off, Others_Present);\n-      --  We don't care about the assigned values of any of these\n+      end Process_Variant;\n \n    --  Start of processing for Analyze_Variant_Part\n \n@@ -4672,9 +4643,18 @@ package body Sem_Ch3 is\n          return;\n       end if;\n \n-      --  Call the instantiated Analyze_Choices which does the rest of the work\n+      --  Now analyze the choices, which also analyzes the declarations that\n+      --  are associated with each choice.\n+\n+      Analyze_Choices (Variants (N), Discr_Type);\n+\n+      --  Note: we used to instantiate and call Check_Choices here to check\n+      --  that the choices covered the discriminant, but it's too early to do\n+      --  that because of statically predicated subtypes, whose analysis may\n+      --  be deferred to their freeze point which may be as late as the freeze\n+      --  point of the containing record. So this call is now to be found in\n+      --  Freeze_Record_Declaration.\n \n-      Analyze_Choices (N, Discr_Type, Dont_Care, Others_Present);\n    end Analyze_Variant_Part;\n \n    ----------------------------"}, {"sha": "bf19a3866db727988998bb7799821cd3b6835114", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -1315,13 +1315,17 @@ package body Sem_Ch4 is\n       --  Error routine invoked by the generic instantiation below when\n       --  the case expression has a non static choice.\n \n-      package Case_Choices_Processing is new\n-        Generic_Choices_Processing\n-          (Get_Alternatives          => Alternatives,\n-           Process_Empty_Choice      => No_OP,\n+      package Case_Choices_Analysis is new\n+        Generic_Analyze_Choices\n+          (Process_Associated_Node => No_OP);\n+      use Case_Choices_Analysis;\n+\n+      package Case_Choices_Checking is new\n+        Generic_Check_Choices\n+          (Process_Empty_Choice      => No_OP,\n            Process_Non_Static_Choice => Non_Static_Choice_Error,\n            Process_Associated_Node   => No_OP);\n-      use Case_Choices_Processing;\n+      use Case_Choices_Checking;\n \n       --------------------------\n       -- Has_Static_Predicate --\n@@ -1363,8 +1367,8 @@ package body Sem_Ch4 is\n       Exp_Type  : Entity_Id;\n       Exp_Btype : Entity_Id;\n \n-      Dont_Care      : Boolean;\n       Others_Present : Boolean;\n+      --  Indicates if Others was present\n \n    --  Start of processing for Analyze_Case_Expression\n \n@@ -1427,9 +1431,7 @@ package body Sem_Ch4 is\n \n       --  If error already reported by Resolve, nothing more to do\n \n-      if Exp_Btype = Any_Discrete\n-        or else Exp_Btype = Any_Type\n-      then\n+      if Exp_Btype = Any_Discrete or else Exp_Btype = Any_Type then\n          return;\n \n       elsif Exp_Btype = Any_Character then\n@@ -1461,10 +1463,11 @@ package body Sem_Ch4 is\n       then\n          null;\n \n-      --  Call instantiated Analyze_Choices which does the rest of the work\n+      --  Call Analyze_Choices and Check_Choices to do the rest of the work\n \n       else\n-         Analyze_Choices (N, Exp_Type, Dont_Care, Others_Present);\n+         Analyze_Choices (Alternatives (N), Exp_Type);\n+         Check_Choices (N, Alternatives (N), Exp_Type, Others_Present);\n       end if;\n \n       if Exp_Type = Universal_Integer and then not Others_Present then"}, {"sha": "9e282fdafa831f8da37b0da8479af9f191e3e9c5", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -1018,12 +1018,12 @@ package body Sem_Ch5 is\n       Exp_Type       : Entity_Id;\n       Exp_Btype      : Entity_Id;\n       Last_Choice    : Nat;\n-      Dont_Care      : Boolean;\n+\n       Others_Present : Boolean;\n+      --  Indicates if Others was present\n \n       pragma Warnings (Off, Last_Choice);\n-      pragma Warnings (Off, Dont_Care);\n-      --  Don't care about assigned values\n+      --  Don't care about assigned value\n \n       Statements_Analyzed : Boolean := False;\n       --  Set True if at least some statement sequences get analyzed. If False\n@@ -1039,16 +1039,21 @@ package body Sem_Ch5 is\n       --  case statement has a non static choice.\n \n       procedure Process_Statements (Alternative : Node_Id);\n-      --  Analyzes all the statements associated with a case alternative.\n-      --  Needed by the generic instantiation below.\n-\n-      package Case_Choices_Processing is new\n-        Generic_Choices_Processing\n-          (Get_Alternatives          => Alternatives,\n-           Process_Empty_Choice      => No_OP,\n+      --  Analyzes the statements associated with a case alternative. Needed\n+      --  by instantiation below.\n+\n+      package Analyze_Case_Choices is new\n+        Generic_Analyze_Choices\n+          (Process_Associated_Node   => Process_Statements);\n+      use Analyze_Case_Choices;\n+      --  Instantiation of the generic choice analysis package\n+\n+      package Check_Case_Choices is new\n+        Generic_Check_Choices\n+          (Process_Empty_Choice      => No_OP,\n            Process_Non_Static_Choice => Non_Static_Choice_Error,\n-           Process_Associated_Node   => Process_Statements);\n-      use Case_Choices_Processing;\n+           Process_Associated_Node   => No_Op);\n+      use Check_Case_Choices;\n       --  Instantiation of the generic choice processing package\n \n       -----------------------------\n@@ -1154,9 +1159,7 @@ package body Sem_Ch5 is\n \n       --  If error already reported by Resolve, nothing more to do\n \n-      if Exp_Btype = Any_Discrete\n-        or else Exp_Btype = Any_Type\n-      then\n+      if Exp_Btype = Any_Discrete or else Exp_Btype = Any_Type then\n          return;\n \n       elsif Exp_Btype = Any_Character then\n@@ -1185,12 +1188,12 @@ package body Sem_Ch5 is\n          Exp_Type := Exp_Btype;\n       end if;\n \n-      --  Call instantiated Analyze_Choices which does the rest of the work\n+      --  Call instantiated procedures to analyzwe and check discrete choices\n \n-      Analyze_Choices (N, Exp_Type, Dont_Care, Others_Present);\n+      Analyze_Choices (Alternatives (N), Exp_Type);\n+      Check_Choices (N, Alternatives (N), Exp_Type, Others_Present);\n \n-      --  A case statement with a single OTHERS alternative is not allowed\n-      --  in SPARK.\n+      --  Case statement with single OTHERS alternative not allowed in SPARK\n \n       if Others_Present and then List_Length (Alternatives (N)) = 1 then\n          Check_SPARK_Restriction\n@@ -1213,6 +1216,12 @@ package body Sem_Ch5 is\n          Unblocked_Exit_Count := Save_Unblocked_Exit_Count;\n       end if;\n \n+      --  If the expander is active it will detect the case of a statically\n+      --  determined single alternative and remove warnings for the case, but\n+      --  if we are not doing expansion, that circuit won't be active. Here we\n+      --  duplicate the effect of removing warnings in the same way, so that\n+      --  we will get the same set of warnings in -gnatc mode.\n+\n       if not Expander_Active\n         and then Compile_Time_Known_Value (Expression (N))\n         and then Serious_Errors_Detected = 0"}, {"sha": "b1c5908629744aacb22cfdef4561954a274f1b07", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -2867,12 +2867,9 @@ package body Sem_Ch6 is\n               and then Present (First_Entity (Spec_Id))\n               and then Ekind (Etype (First_Entity (Spec_Id))) = E_Record_Type\n               and then Is_Tagged_Type (Etype (First_Entity (Spec_Id)))\n-              and then\n-                Present (Interfaces (Etype (First_Entity (Spec_Id))))\n-              and then\n-                Present\n-                  (Corresponding_Concurrent_Type\n-                     (Etype (First_Entity (Spec_Id))))\n+              and then Present (Interfaces (Etype (First_Entity (Spec_Id))))\n+              and then Present (Corresponding_Concurrent_Type\n+                                  (Etype (First_Entity (Spec_Id))))\n             then\n                declare\n                   Typ  : constant Entity_Id := Etype (First_Entity (Spec_Id));\n@@ -9131,9 +9128,10 @@ package body Sem_Ch6 is\n       ------------------------\n \n       function Controlling_Formal (Prim : Entity_Id) return Entity_Id is\n-         E : Entity_Id := First_Entity (Prim);\n+         E : Entity_Id;\n \n       begin\n+         E := First_Entity (Prim);\n          while Present (E) loop\n             if Is_Formal (E) and then Is_Controlling_Formal (E) then\n                return E;\n@@ -9178,8 +9176,8 @@ package body Sem_Ch6 is\n       --  The mode of the controlling formals must match\n \n       elsif Present (Iface_Ctrl_F)\n-         and then Present (Prim_Ctrl_F)\n-         and then Ekind (Iface_Ctrl_F) /= Ekind (Prim_Ctrl_F)\n+        and then Present (Prim_Ctrl_F)\n+        and then Ekind (Iface_Ctrl_F) /= Ekind (Prim_Ctrl_F)\n       then\n          return False;\n "}, {"sha": "6f77c958d0b171d41cff9c7ef5439d7550cb5f8b", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -8969,7 +8969,9 @@ package body Sem_Prag is\n          --                        Precondition         |\n          --                        Predicate            |\n          --                        Statement_Assertions\n-         --\n+\n+         --  Shouldn't Refined_Pre be in this list???\n+\n          --  Note: The RM_ASSERTION_KIND list is language-defined, and the\n          --  ID_ASSERTION_KIND list contains implementation-defined additions\n          --  recognized by GNAT. The effect is to control the behavior of"}, {"sha": "13ec1a3b99df8b43792cfb82ba3d0d41afa5eab3", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -32,8 +32,8 @@ with Types;  use Types;\n \n package Sem_Prag is\n \n-   --  The following table lists all the user-defined pragmas that may apply to\n-   --  a body stub.\n+   --  The following table lists all the implementation-defined pragmas that\n+   --  may apply to a body stub (no language defined pragmas apply).\n \n    Pragma_On_Stub_OK : constant array (Pragma_Id) of Boolean :=\n      (Pragma_Refined_Pre  => True,"}, {"sha": "d5681492233edb82780c68f71d5ceb64101ecaa2", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -5184,9 +5184,9 @@ package body Sem_Util is\n          Discrim := First (Choices (Assoc));\n          exit Find_Constraint when Chars (Discrim_Name) = Chars (Discrim)\n            or else (Present (Corresponding_Discriminant (Entity (Discrim)))\n-                      and then\n-                    Chars (Corresponding_Discriminant (Entity (Discrim)))\n-                         = Chars  (Discrim_Name))\n+                     and then\n+                       Chars (Corresponding_Discriminant (Entity (Discrim))) =\n+                                                       Chars  (Discrim_Name))\n            or else Chars (Original_Record_Component (Entity (Discrim)))\n                          = Chars (Discrim_Name);\n \n@@ -5274,7 +5274,6 @@ package body Sem_Util is\n          Find_Discrete_Value : while Present (Variant) loop\n             Discrete_Choice := First (Discrete_Choices (Variant));\n             while Present (Discrete_Choice) loop\n-\n                exit Find_Discrete_Value when\n                  Nkind (Discrete_Choice) = N_Others_Choice;\n \n@@ -5305,8 +5304,8 @@ package body Sem_Util is\n       --  If we have found the corresponding choice, recursively add its\n       --  components to the Into list.\n \n-      Gather_Components (Empty,\n-        Component_List (Variant), Governed_By, Into, Report_Errors);\n+      Gather_Components\n+        (Empty, Component_List (Variant), Governed_By, Into, Report_Errors);\n    end Gather_Components;\n \n    ------------------------\n@@ -8655,6 +8654,7 @@ package body Sem_Util is\n                return Is_Fully_Initialized_Variant (U);\n             end if;\n          end;\n+\n       else\n          return False;\n       end if;"}, {"sha": "a453e12f125306724eeee4a0f6d9682c8c2d8b10", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -1552,6 +1552,16 @@ package body Sinfo is\n       return Flag13 (N);\n    end Has_Self_Reference;\n \n+   function Has_SP_Choice\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Case_Expression_Alternative\n+        or else NT (N).Nkind = N_Case_Statement_Alternative\n+        or else NT (N).Nkind = N_Variant);\n+      return Flag15 (N);\n+   end Has_SP_Choice;\n+\n    function Has_Storage_Size_Pragma\n       (N : Node_Id) return Boolean is\n    begin\n@@ -4680,6 +4690,16 @@ package body Sinfo is\n       Set_Flag13 (N, Val);\n    end Set_Has_Self_Reference;\n \n+   procedure Set_Has_SP_Choice\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Case_Expression_Alternative\n+        or else NT (N).Nkind = N_Case_Statement_Alternative\n+        or else NT (N).Nkind = N_Variant);\n+      Set_Flag15 (N, Val);\n+   end Set_Has_SP_Choice;\n+\n    procedure Set_Has_Storage_Size_Pragma\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "149d4c411cea96cc09bf478e3e714ae52fbc8df1", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15918371923d3e31a9f74c46fbe94e7e1e6d76e6/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=15918371923d3e31a9f74c46fbe94e7e1e6d76e6", "patch": "@@ -1243,6 +1243,12 @@ package Sinfo is\n    --    enclosing type. Such a self-reference can only appear in default-\n    --    initialized aggregate for a record type.\n \n+   --  Has_SP_Choice (Flag15-Sem)\n+   --    Present in all nodes containing a Discrete_Choices field (N_Variant,\n+   --    N_Case_Expression_Alternative, N_Case_Statement_Alternative). Set to\n+   --    True if the Discrete_Choices list has at least one occurrence of a\n+   --    statically predicated subtype.\n+\n    --  Has_Storage_Size_Pragma (Flag5-Sem)\n    --    A flag present in an N_Task_Definition node to flag the presence of a\n    --    Storage_Size pragma.\n@@ -3061,8 +3067,7 @@ package Sinfo is\n \n       --  VARIANT_PART ::=\n       --    case discriminant_DIRECT_NAME is\n-      --      VARIANT\n-      --      {VARIANT}\n+      --      VARIANT {VARIANT}\n       --    end case;\n \n       --  Note: the variants list can contain pragmas as well as variants.\n@@ -3088,12 +3093,14 @@ package Sinfo is\n       --  Enclosing_Variant (Node2-Sem)\n       --  Present_Expr (Uint3-Sem)\n       --  Dcheck_Function (Node5-Sem)\n+      --  Has_SP_Choice (Flag15-Sem)\n \n       --  Note: in the list of Discrete_Choices, the tree passed to the back\n       --  end does not have choice entries corresponding to names of statically\n       --  predicated subtypes. Such entries are always expanded out to the list\n       --  of equivalent values or ranges. The ASIS tree generated in -gnatct\n-      --  mode does not have this expansion, and has the original choices.\n+      --  mode also has this expansion, but done with a proper Rewrite call on\n+      --  the N_Variant node so that ASIS can properly retrieve the original.\n \n       ---------------------------------\n       -- 3.8.1  Discrete Choice List --\n@@ -4078,12 +4085,16 @@ package Sinfo is\n       --  Actions (List1)\n       --  Discrete_Choices (List4)\n       --  Expression (Node3)\n+      --  Has_SP_Choice (Flag15-Sem)\n \n       --  Note: The Actions field temporarily holds any actions associated with\n       --  evaluation of the Expression. During expansion of the case expression\n       --  these actions are wrapped into an N_Expressions_With_Actions node\n       --  replacing the original expression.\n \n+      --  Note: this node never appears in the tree passed to the back end,\n+      --  since the expander converts case expressions into case statements.\n+\n       ---------------------------------\n       -- 4.5.9 Quantified Expression --\n       ---------------------------------\n@@ -4392,6 +4403,7 @@ package Sinfo is\n       --  Sloc points to WHEN\n       --  Discrete_Choices (List4)\n       --  Statements (List3)\n+      --  Has_SP_Choice (Flag15-Sem)\n \n       --  Note: in the list of Discrete_Choices, the tree passed to the back\n       --  end does not have choice entries corresponding to names of statically\n@@ -8773,6 +8785,9 @@ package Sinfo is\n    function Has_Self_Reference\n      (N : Node_Id) return Boolean;    -- Flag13\n \n+   function Has_SP_Choice\n+     (N : Node_Id) return Boolean;    -- Flag15\n+\n    function Has_Storage_Size_Pragma\n      (N : Node_Id) return Boolean;    -- Flag5\n \n@@ -9769,6 +9784,9 @@ package Sinfo is\n    procedure Set_Has_Self_Reference\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n+   procedure Set_Has_SP_Choice\n+     (N : Node_Id; Val : Boolean := True);    -- Flag15\n+\n    procedure Set_Has_Storage_Size_Pragma\n      (N : Node_Id; Val : Boolean := True);    -- Flag5\n \n@@ -12195,6 +12213,7 @@ package Sinfo is\n    pragma Inline (Has_Init_Expression);\n    pragma Inline (Has_Local_Raise);\n    pragma Inline (Has_Self_Reference);\n+   pragma Inline (Has_SP_Choice);\n    pragma Inline (Has_No_Elaboration_Code);\n    pragma Inline (Has_Pragma_Suppress_All);\n    pragma Inline (Has_Private_View);\n@@ -12528,6 +12547,7 @@ package Sinfo is\n    pragma Inline (Set_Has_Private_View);\n    pragma Inline (Set_Has_Relative_Deadline_Pragma);\n    pragma Inline (Set_Has_Self_Reference);\n+   pragma Inline (Set_Has_SP_Choice);\n    pragma Inline (Set_Has_Storage_Size_Pragma);\n    pragma Inline (Set_Has_Wide_Character);\n    pragma Inline (Set_Has_Wide_Wide_Character);"}]}