{"sha": "5b43fed17bf58c31f3151dd37966e7a9b85a309e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI0M2ZlZDE3YmY1OGMzMWYzMTUxZGQzNzk2NmU3YTliODVhMzA5ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-03-13T05:42:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-03-13T05:42:40Z"}, "message": "re PR rtl-optimization/5878 (gcc 3.1 breaks on C code generated by the Mercury compiler)\n\n\tPR 5878\n\t* config/arc/arc.h, config/cris/cris.h, config/i386/i386.h,\n\tconfig/m68k/m68k.h, config/s390/s390.h, config/sparc/sparc.h\n\t(PIC_OFFSET_TABLE_REGNUM): Conditionalize on flag_pic.\n\n\t* config/arm/arm.h config/i386/i386.h, config/m68k/m68k.h,\n\tconfig/sparc/sparc.h (CONDITIONAL_REGISTER_USAGE): Set\n\tPIC_OFFSET_TABLE_REGNUM based on INVALID_REGNUM not flag_pic.\n\n\t* config/arc/arc.h (CONDITIONAL_REGISTER_USAGE): New.\n\t* config/arm/arm.c (arm_pic_register): Init to INVALID_REGNUM.\n\t(arm_override_options): Set arm_pic_register if TARGET_APCS_STACK\n\talso.  Don't set it if not flag_pic.\n\t* config/i386/i386.c (ix86_save_reg): Trust PIC_OFFSET_TABLE_REGNUM\n\tto be INVALID_REGNUM when not used.\n\n\t* gcc.dg/20020312-2.c: New.\n\nFrom-SVN: r50713", "tree": {"sha": "ff7ebe9916a64b81e187d279cffac13101372cd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff7ebe9916a64b81e187d279cffac13101372cd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b43fed17bf58c31f3151dd37966e7a9b85a309e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b43fed17bf58c31f3151dd37966e7a9b85a309e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b43fed17bf58c31f3151dd37966e7a9b85a309e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b43fed17bf58c31f3151dd37966e7a9b85a309e/comments", "author": null, "committer": null, "parents": [{"sha": "56d4fe31c5265b7f5a0aaea8d5013a7154b211e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56d4fe31c5265b7f5a0aaea8d5013a7154b211e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56d4fe31c5265b7f5a0aaea8d5013a7154b211e8"}], "stats": {"total": 314, "additions": 238, "deletions": 76}, "files": [{"sha": "85b0f026e2efe398a384e1f0e7dc3518ca890932", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b43fed17bf58c31f3151dd37966e7a9b85a309e", "patch": "@@ -1,7 +1,24 @@\n+2002-03-12  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/arc/arc.h, config/cris/cris.h, config/i386/i386.h,\n+\tconfig/m68k/m68k.h, config/s390/s390.h, config/sparc/sparc.h\n+\t(PIC_OFFSET_TABLE_REGNUM): Conditionalize on flag_pic.\n+\n+\t* config/arm/arm.h config/i386/i386.h, config/m68k/m68k.h,\n+\tconfig/sparc/sparc.h (CONDITIONAL_REGISTER_USAGE): Set\n+\tPIC_OFFSET_TABLE_REGNUM based on INVALID_REGNUM not flag_pic.\n+\n+\t* config/arc/arc.h (CONDITIONAL_REGISTER_USAGE): New.\n+\t* config/arm/arm.c (arm_pic_register): Init to INVALID_REGNUM.\n+\t(arm_override_options): Set arm_pic_register if TARGET_APCS_STACK\n+\talso.  Don't set it if not flag_pic.\n+\t* config/i386/i386.c (ix86_save_reg): Trust PIC_OFFSET_TABLE_REGNUM\n+\tto be INVALID_REGNUM when not used.\n+\n 2002-03-13  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * expmed.c (store_bit_field): Reset alias set for memory.\n-        (extract_bit_field): Same.\n+\t* expmed.c (store_bit_field): Reset alias set for memory.\n+\t(extract_bit_field): Same.\n \n 2002-03-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n@@ -372,12 +389,12 @@ Sat Mar  9 07:20:01 2002  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2002-03-08  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/rs6000.c (rs6000_va_arg): Fix alignment for\n-        vectors.\n+\t* config/rs6000/rs6000.c (rs6000_va_arg): Fix alignment for\n+\tvectors.\n \n 2002-03-08  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/sysv4.h (BIGGEST_ALIGNMENT): Change for altivec.\n+\t* config/rs6000/sysv4.h (BIGGEST_ALIGNMENT): Change for altivec.\n \n Fri Mar  8 21:27:49 CET 2002  Jan Hubicka  <jh@suse.cz>\n \n@@ -521,11 +538,11 @@ Thu Mar  7 16:33:54 CET 2002  Jan Hubicka  <jh@suse.cz>\n \n 2002-03-07  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * doc/invoke.texi: Add documentation for -mabi=no-altivec.\n+\t* doc/invoke.texi: Add documentation for -mabi=no-altivec.\n \n-        * config/rs6000/rs6000.c (rs6000_parse_abi_options): Add\n-        -mabi=no-altivec\n-        (alt_reg_names): Remove % for vrsave.\n+\t* config/rs6000/rs6000.c (rs6000_parse_abi_options): Add\n+\t-mabi=no-altivec\n+\t(alt_reg_names): Remove % for vrsave.\n \n 2002-03-06  Richard Henderson  <rth@redhat.com>\n \n@@ -537,7 +554,7 @@ Thu Mar  7 16:33:54 CET 2002  Jan Hubicka  <jh@suse.cz>\n \n 2002-03-06  Ulrich Weigand  <uweigand@de.ibm.com>\n \n-        * reload1.c (reload): Unshare all rtl after reload is done.\n+\t* reload1.c (reload): Unshare all rtl after reload is done.\n \n \t* simplify-rtx.c (simplify_plus_minus): Do not abort,\n \tbut simply fail if the expression is too complex to simplify.\n@@ -662,7 +679,7 @@ Tue Mar  5 18:31:27 CET 2002  Jan Hubicka  <jh@suse.cz>\n \n 2002-03-05  Richard Henderson  <rth@redhat.com>\n \n-        * rs6000.h (TOTAL_ALTIVEC_REGS): Fix off-by-one error.\n+\t* rs6000.h (TOTAL_ALTIVEC_REGS): Fix off-by-one error.\n \n 2002-03-04  Geoffrey Keating  <geoffk@redhat.com>\n \n@@ -709,10 +726,10 @@ Mon Mar  4 15:33:54 CET 2002  Jan Hubicka  <jh@suse.cz>\n \n 2002-03-03  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config.gcc (powerpc-*-eabialtivec*): Use t-ppcendian.\n-        (powerpc-*-eabisimaltivec*): Same.\n+\t* config.gcc (powerpc-*-eabialtivec*): Use t-ppcendian.\n+\t(powerpc-*-eabisimaltivec*): Same.\n \n-        * config/rs6000/t-ppcendian: New.\n+\t* config/rs6000/t-ppcendian: New.\n \n 2002-03-04  Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n "}, {"sha": "651d81ec92dd223149e9678e3d7dbca3a06abfed", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=5b43fed17bf58c31f3151dd37966e7a9b85a309e", "patch": "@@ -355,6 +355,16 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n   48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\t\t\\\n   27, 28, 29, 30 }\n \n+/* Macro to conditionally modify fixed_regs/call_used_regs.  */\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n+do {\t\t\t\t\t\t\t\\\n+  if (PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n+      call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+    }\t\t\t\t\t\t\t\\\n+} while (0)\n+\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n@@ -1152,7 +1162,7 @@ do {\t\t\t\t\t\t\t\\\n    pointer and frame pointer registers.  If this macro is not defined, it\n    is up to the machine-dependent files to allocate such a register (if\n    necessary).  */\n-#define PIC_OFFSET_TABLE_REGNUM 26\n+#define PIC_OFFSET_TABLE_REGNUM  (flag_pic ? 26 : INVALID_REGNUM)\n \n /* Define this macro if the register defined by PIC_OFFSET_TABLE_REGNUM is\n    clobbered by calls.  Do not define this macro if PIC_OFFSET_TABLE_REGNUM"}, {"sha": "8e85957021819b6873bc26d5234d504d52708dc0", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5b43fed17bf58c31f3151dd37966e7a9b85a309e", "patch": "@@ -268,7 +268,7 @@ enum machine_mode output_memory_reference_mode;\n \n /* The register number to be used for the PIC offset register.  */\n const char * arm_pic_register_string = NULL;\n-int arm_pic_register = 9;\n+int arm_pic_register = INVALID_REGNUM;\n \n /* Set to 1 when a return insn is output, this means that the epilogue\n    is not needed.  */\n@@ -651,8 +651,8 @@ arm_override_options ()\n   \n   /* If stack checking is disabled, we can use r10 as the PIC register,\n      which keeps r9 available.  */\n-  if (flag_pic && !TARGET_APCS_STACK)\n-    arm_pic_register = 10;\n+  if (flag_pic)\n+    arm_pic_register = TARGET_APCS_STACK ? 9 : 10;\n   \n   if (TARGET_APCS_FLOAT)\n     warning (\"passing floating point arguments in fp regs not yet supported\");\n@@ -713,18 +713,16 @@ arm_override_options ()\n \n   if (arm_pic_register_string != NULL)\n     {\n-      int pic_register;\n-\n+      int pic_register = decode_reg_name (arm_pic_register_string);\n+      \n       if (!flag_pic)\n \twarning (\"-mpic-register= is useless without -fpic\");\n \n-      pic_register = decode_reg_name (arm_pic_register_string);\n-      \n       /* Prevent the user from choosing an obviously stupid PIC register.  */\n-      if (pic_register < 0 || call_used_regs[pic_register]\n-\t  || pic_register == HARD_FRAME_POINTER_REGNUM\n-\t  || pic_register == STACK_POINTER_REGNUM\n-\t  || pic_register >= PC_REGNUM)\n+      else if (pic_register < 0 || call_used_regs[pic_register]\n+\t       || pic_register == HARD_FRAME_POINTER_REGNUM\n+\t       || pic_register == STACK_POINTER_REGNUM\n+\t       || pic_register >= PC_REGNUM)\n \terror (\"unable to use '%s' for PIC register\", arm_pic_register_string);\n       else\n \tarm_pic_register = pic_register;"}, {"sha": "240595e58f51d2aa42d97f492459c3b0d82b6efb", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=5b43fed17bf58c31f3151dd37966e7a9b85a309e", "patch": "@@ -838,7 +838,7 @@ extern const char * structure_size_string;\n \t   regno <= LAST_ARM_FP_REGNUM; ++regno)\t\t\\\n \tfixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n-  if (flag_pic)\t\t\t\t\t\t\t\\\n+  if (PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\\\n       call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\"}, {"sha": "21065a9f46258390cea43165bb95a8aeebfcd187", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=5b43fed17bf58c31f3151dd37966e7a9b85a309e", "patch": "@@ -1468,7 +1468,7 @@ call_ ## FUNC (void)\t\t\t\t\t\t\\\n \n /* Node: PIC */\n \n-#define PIC_OFFSET_TABLE_REGNUM 0\n+#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 0 : INVALID_REGNUM)\n \n #define LEGITIMATE_PIC_OPERAND_P(X) cris_legitimate_pic_operand (X)\n "}, {"sha": "2d0649944d6e23b7aaadfabec68081c5337a77b6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5b43fed17bf58c31f3151dd37966e7a9b85a309e", "patch": "@@ -3880,9 +3880,7 @@ ix86_save_reg (regno, maybe_eh_return)\n      int regno;\n      int maybe_eh_return;\n {\n-  if (flag_pic\n-      && ! TARGET_64BIT\n-      && regno == PIC_OFFSET_TABLE_REGNUM\n+  if (regno == PIC_OFFSET_TABLE_REGNUM\n       && (current_function_uses_pic_offset_table\n \t  || current_function_uses_const_pool\n \t  || current_function_calls_eh_return))"}, {"sha": "94359133c92a627df3e2c5d2ed625a7fe4198117", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=5b43fed17bf58c31f3151dd37966e7a9b85a309e", "patch": "@@ -937,7 +937,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n         call_used_regs[i] = (call_used_regs[i]\t\t\t\t\\\n \t\t\t     & (TARGET_64BIT ? 2 : 1)) != 0;\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n-    if (flag_pic && PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\t\t\\\n+    if (PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\\\n \tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\\\n@@ -1113,11 +1113,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define STATIC_CHAIN_REGNUM (TARGET_64BIT ? FIRST_REX_INT_REG + 10 - 8 : 2)\n \n /* Register to hold the addressing base for position independent\n-   code access to data items.\n-   We don't use PIC pointer for 64bit mode.  Define the regnum to\n-   dummy value to prevent gcc from pessimizing code dealing with EBX.\n- */\n-#define PIC_OFFSET_TABLE_REGNUM (TARGET_64BIT ? INVALID_REGNUM : 3)\n+   code access to data items.  We don't use PIC pointer for 64bit\n+   mode.  Define the regnum to dummy value to prevent gcc from\n+   pessimizing code dealing with EBX.  */\n+#define PIC_OFFSET_TABLE_REGNUM \\\n+  (TARGET_64BIT || !flag_pic ? INVALID_REGNUM : 3)\n \n /* Register in which address to store a structure value\n    arrives in the function.  On the 386, the prologue"}, {"sha": "55f5fd14e04de19af1168a8169740b4459dfc734", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=5b43fed17bf58c31f3151dd37966e7a9b85a309e", "patch": "@@ -387,7 +387,7 @@ extern int target_flags;\n #endif\n \n /* This defines the register which is used to hold the offset table for PIC.  */\n-#define PIC_OFFSET_TABLE_REGNUM 13\n+#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 13 : INVALID_REGNUM)\n \n #ifndef SUPPORT_SUN_FPA\n \n@@ -469,43 +469,43 @@ extern int target_flags;\n \n #ifdef SUPPORT_SUN_FPA\n \n-#define CONDITIONAL_REGISTER_USAGE \\\n-{ \t\t\t\t\t\t\\\n-  int i; \t\t\t\t\t\\\n-  HARD_REG_SET x; \t\t\t\t\\\n-  if (! TARGET_FPA)\t\t\t\t\\\n-    { \t\t\t\t\t\t\\\n-      COPY_HARD_REG_SET (x, reg_class_contents[(int)FPA_REGS]); \\\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n-       if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n-\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n-    } \t\t\t\t\t\t\\\n-  if (! TARGET_68881)\t\t\t\t\\\n-    { \t\t\t\t\t\t\\\n-      COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]); \\\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n-       if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n-\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n-    } \t\t\t\t\t\t\\\n-  if (flag_pic)\t\t\t\t\t\\\n-    fixed_regs[PIC_OFFSET_TABLE_REGNUM]\t\t\\\n-      = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\\\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n+{ \t\t\t\t\t\t\t\t\\\n+  int i; \t\t\t\t\t\t\t\\\n+  HARD_REG_SET x; \t\t\t\t\t\t\\\n+  if (! TARGET_FPA)\t\t\t\t\t\t\\\n+    { \t\t\t\t\t\t\t\t\\\n+      COPY_HARD_REG_SET (x, reg_class_contents[(int)FPA_REGS]);\t\\\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ )\t\t\\\n+       if (TEST_HARD_REG_BIT (x, i)) \t\t\t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\t\t\\\n+    } \t\t\t\t\t\t\t\t\\\n+  if (! TARGET_68881)\t\t\t\t\t\t\\\n+    { \t\t\t\t\t\t\t\t\\\n+      COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]);\t\\\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ )\t\t\\\n+       if (TEST_HARD_REG_BIT (x, i)) \t\t\t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\t\t\\\n+    } \t\t\t\t\t\t\t\t\\\n+  if (PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\t\t\\\n+    fixed_regs[PIC_OFFSET_TABLE_REGNUM]\t\t\t\t\\\n+      = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n }\n #else\n-#define CONDITIONAL_REGISTER_USAGE \\\n-{ \t\t\t\t\t\t\\\n-  int i; \t\t\t\t\t\\\n-  HARD_REG_SET x; \t\t\t\t\\\n-  if (! TARGET_68881)\t\t\t\t\\\n-    { \t\t\t\t\t\t\\\n-      COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]); \\\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n-       if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n-\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n-    } \t\t\t\t\t\t\\\n-  if (flag_pic)\t\t\t\t\t\\\n-    fixed_regs[PIC_OFFSET_TABLE_REGNUM]\t\t\\\n-      = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\\\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n+{ \t\t\t\t\t\t\t\t\\\n+  int i; \t\t\t\t\t\t\t\\\n+  HARD_REG_SET x; \t\t\t\t\t\t\\\n+  if (! TARGET_68881)\t\t\t\t\t\t\\\n+    { \t\t\t\t\t\t\t\t\\\n+      COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]);\t\\\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ )\t\t\\\n+       if (TEST_HARD_REG_BIT (x, i)) \t\t\t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\t\t\\\n+    } \t\t\t\t\t\t\t\t\\\n+  if (PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\t\t\\\n+    fixed_regs[PIC_OFFSET_TABLE_REGNUM]\t\t\t\t\\\n+      = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n }\n \n #endif /* defined SUPPORT_SUN_FPA */"}, {"sha": "93b355caf655dc0c417f2778c71a1a9735eeb803", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=5b43fed17bf58c31f3151dd37966e7a9b85a309e", "patch": "@@ -249,7 +249,7 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n    GPR 14: Return registers holds the return address\n    GPR 15: Stack pointer */\n \n-#define PIC_OFFSET_TABLE_REGNUM 12\n+#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 12 : INVALID_REGNUM)\n #define BASE_REGISTER 13\n #define RETURN_REGNUM 14\n #define STACK_POINTER_REGNUM 15"}, {"sha": "92c8ace9e1396358858777ca9b701ddffd3a0dd2", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=5b43fed17bf58c31f3151dd37966e7a9b85a309e", "patch": "@@ -984,7 +984,7 @@ if (TARGET_ARCH64\t\t\t\t\\\n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n-    if (flag_pic)\t\t\t\t\t\t\\\n+    if (PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n \tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n@@ -1159,7 +1159,7 @@ extern int sparc_mode_class[];\n /* Register which holds offset table for position-independent\n    data references.  */\n \n-#define PIC_OFFSET_TABLE_REGNUM 23\n+#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 23 : INVALID_REGNUM)\n \n /* Pick a default value we can notice from override_options:\n    !v9: Default is on."}, {"sha": "889e152be347083b9f11e9305e781720ad1f133b", "filename": "gcc/testsuite/gcc.dg/20020312-2.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b43fed17bf58c31f3151dd37966e7a9b85a309e/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c?ref=5b43fed17bf58c31f3151dd37966e7a9b85a309e", "patch": "@@ -0,0 +1,139 @@\n+/* PR 5878. \n+\n+   We ICEd in verify_local_live_at_start because we incorrectly forced\n+   the PIC register live between BAR and BAZ.  We did this because the\n+   definition of PIC_OFFSET_TABLE_REGNUM was incorrectly not INVALID_REGNUM\n+   when !flag_pic for most targets.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O -fno-pic\" } */\n+\n+#if #cpu(a29k)\n+/* No pic register.  */\n+#elif defined(__alpha__)\n+/* PIC register is $29, but is used even without -fpic.  */\n+#elif defined(__arc__)\n+# define PIC_REG  \"26\"\n+#elif defined(__arm__)\n+# define PIC_REG  \"9\"\n+#elif defined(AVR)\n+/* No pic register.  */\n+#elif defined(__clipper__)\n+/* No pic register.  */\n+#elif defined(__convex__)\n+/* No pic register.  */\n+#elif defined(__cris__)\n+# define PIC_REG  \"0\"\n+#elif defined(__D30V__)\n+/* No pic register.  */\n+#elif defined(__dsp1600__)\n+/* No pic register.  */\n+#elif defined(__elxsi__)\n+/* No pic register.  */\n+#elif defined(__fr30__)\n+/* No pic register.  */\n+#elif defined(__H8300__) || defined(__H8300H__) || defined(__H8300S__)\n+/* No pic register.  */\n+#elif #cpu(i370)\n+/* No pic register.  */\n+#elif defined(__i386__)\n+# define PIC_REG  \"ebx\"\n+#elif defined(__i860__)\n+/* No pic register.  */\n+#elif defined(__i960__)\n+/* No pic register.  */\n+#elif defined(__ia64__)\n+/* PIC register is r1, but is used even without -fpic.  */\n+#elif defined(__M32R__)\n+/* No pic register.  */\n+#elif defined(__m68k__)\n+# define PIC_REG  \"a5\"\n+#elif defined(__m88k__)\n+# define PIC_REG  \"25\"\n+#elif defined(__mc68hc1x__)\n+/* No pic register.  */\n+#elif defined(__mcore__)\n+/* No pic register.  */\n+#elif defined(__mips__)\n+/* PIC register is $28, but is used even without -fpic.  */\n+#elif defined(__mn10200__)\n+/* No pic register.  */\n+#elif defined(__mn10300__)\n+/* No pic register.  */\n+#elif #cpu(ns32k)\n+/* No pic register.  */\n+#elif defined(__parisc__)\n+/* PIC register is %r27 or %r19, but is used even without -fpic.  */\n+#elif defined(__pdp11__)\n+/* No pic register.  */\n+#elif defined(__pj__)\n+/* No pic register.  */\n+#elif defined(__powerpc__)\n+# ifdef __darwin__\n+#  define PIC_REG  \"31\"\n+# else\n+#  define PIC_REG  \"30\"\n+# endif\n+#elif defined(__ibm032__) /* aka romp */\n+/* No pic register.  */\n+#elif defined(__s390__)\n+# define PIC_REG  \"12\"\n+#elif defined(__sparc__)\n+# define PIC_REG  \"l7\"\n+#elif defined(__v850)\n+/* No pic register.  */\n+#elif defined(__vax__)\n+/* No pic register.  */\n+#elif defined(__we32000__)\n+/* No pic register.  */\n+#elif defined(__xstormy16__)\n+/* No pic register.  */\n+#elif defined(__XTENSA__)\n+/* No pic register.  */\n+#else\n+# error \"Modify the test for your target.\"\n+#endif\n+\n+#ifdef PIC_REG\n+register void *reg __asm__(PIC_REG);\n+#else\n+/* We really need a global register variable set to the PIC register\n+   to expose the bug.  Oh well, let the test case not fail.  */\n+static void *reg;\n+#endif\n+\n+void * __attribute__((noinline))\n+dummy (void *x)\n+{\n+  return x;\n+}\n+\n+void\n+f (void)\n+{\n+  goto *dummy (&&bar);\n+  for (;;)\n+    {\n+    foo:\n+      reg = (void *) 1;\n+      if (!reg)\n+        goto baz;\n+      reg = &&foo;\n+    }\n+\n+ bar:\n+ baz:\n+  reg = 0;\n+}\n+\n+int\n+main()\n+{\n+  void *old_reg = reg;\n+  reg = (void *) 1;\n+  f ();\n+  if (reg)\n+    abort ();\n+  reg = old_reg;\n+  return 0;\n+}"}]}