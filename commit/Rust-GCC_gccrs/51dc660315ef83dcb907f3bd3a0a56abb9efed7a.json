{"sha": "51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFkYzY2MDMxNWVmODNkY2I5MDdmM2JkM2EwYTU2YWJiOWVmZWQ3YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-11-07T23:09:29Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-11-07T23:09:29Z"}, "message": "Implement P0012R1, Make exception specifications part of the type system.\n\ngcc/cp/\n\t* cp-tree.h (enum tsubst_flags): Add tf_fndecl_type.\n\t(flag_noexcept_type, ce_type): New.\n\t* call.c (build_conv): Add ck_fnptr.\n\t(enum conversion_kind): Change ck_tsafe to ck_fnptr.\n\t(convert_like_real): Likewise.\n\t(standard_conversion): Likewise.  Allow function pointer\n\tconversions for pointers to member functions.\n\t(reference_compatible_p): Allow function pointer conversions.\n\t(direct_reference_binding): Likewise.\n\t(reference_binding): Reference-compatible is no longer a subset of\n\treference-related.\n\t(is_subseq): Also strip ck_lvalue after next_conversion.\n\t* class.c (instantiate_type): Check fnptr_conv_p.\n\t(resolve_address_of_overloaded_function): Likewise.\n\t* cvt.c (can_convert_tx_safety): Now static.\n\t(noexcept_conv_p, fnptr_conv_p, strip_fnptr_conv): New.\n\t* decl.c (flag_noexcept_type): Define.\n\t(cxx_init_decl_processing): Set it.\n\t(bad_specifiers): Check it.\n\t(grokdeclarator) [cdk_function]: Add exception-spec to type here.\n\t* lambda.c (maybe_add_lambda_conv_op): Add exception-spec to\n\treturned pointer.\n\t* mangle.c (struct globals): Add need_cxx1z_warning.\n\t(mangle_decl): Check it.\n\t(write_exception_spec): New.\n\t(write_function_type): Call it.\n\t(canonicalize_for_substitution): Handle exception spec.\n\t(write_type): Likewise.\n\t(write_encoding): Set processing_template_decl across mangling of\n\tpartially-instantiated type.\n\t* pt.c (determine_specialization): Pass tf_fndecl_type.\n\t(tsubst_decl, fn_type_unification): Likewise.\n\t(tsubst): Strip tf_fndecl_type, pass it to\n\ttsubst_exception_specification.\n\t(convert_nontype_argument_function): Handle function pointer\n\tconversion.\n\t(convert_nontype_argument): Likewise.\n\t(unify, for_each_template_parm_r): Walk into noexcept-specifier.\n\t* rtti.c (ptr_initializer): Encode noexcept.\n\t* tree.c (canonical_eh_spec): New.\n\t(build_exception_variant): Use it.\n\t* typeck.c (composite_pointer_type): Handle fnptr conversion.\n\t(comp_except_specs): Compare canonical EH specs.\n\t(structural_comptypes): Call it.\ngcc/c-family/\n\t* c.opt (Wc++1z-compat): New.\n\t* c-cppbuiltin.c (c_cpp_builtins): Add __cpp_noexcept_function_type.\nlibstdc++-v3/\n\t* include/bits/c++config (_GLIBCXX_NOEXCEPT_PARM)\n\t(_GLIBCXX_NOEXCEPT_QUAL): New.\n\t* include/std/type_traits (is_function): Use them.\n\t* libsubc++/new (launder): Likewise.\n\t* libsupc++/cxxabi.h (__pbase_type_info::__masks): Add\n\t__noexcept_mask.\n\t* libsupc++/pbase_type_info.cc (__do_catch): Handle function\n\tpointer conversion.\nlibiberty/\n\t* cp-demangle.c (is_fnqual_component_type): New.\n\t(d_encoding, d_print_comp_inner, d_print_mod_list): Use it.\n\t(FNQUAL_COMPONENT_CASE): New.\n\t(d_make_comp, has_return_type, d_print_comp_inner)\n\t(d_print_function_type): Use it.\n\t(next_is_type_qual): New.\n\t(d_cv_qualifiers, d_print_mod): Handle noexcept and throw-spec.\ninclude/\n\t* demangle.h (enum demangle_component_type): Add\n\tDEMANGLE_COMPONENT_NOEXCEPT, DEMANGLE_COMPONENT_THROW_SPEC.\n\nFrom-SVN: r241944", "tree": {"sha": "c9f9278ab8d390747f291ff0e7146959604797d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9f9278ab8d390747f291ff0e7146959604797d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "452811eb53e9c0457f99f4f23a4ca10354c088e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/452811eb53e9c0457f99f4f23a4ca10354c088e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/452811eb53e9c0457f99f4f23a4ca10354c088e1"}], "stats": {"total": 1008, "additions": 801, "deletions": 207}, "files": [{"sha": "5207c34c912a79eec6c10fac3c9814efd637d39f", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -1,3 +1,8 @@\n+2016-11-07  Jason Merrill  <jason@redhat.com>\n+\n+\t* c.opt (Wc++1z-compat): New.\n+\t* c-cppbuiltin.c (c_cpp_builtins): Add __cpp_noexcept_function_type.\n+\n 2016-11-07  Martin Liska  <mliska@suse.cz>\n \n \t* c-warn.c (warn_for_unused_label): Save all labels used"}, {"sha": "55dbf44d34f6141c37958920347d8784987b2caf", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -941,6 +941,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_inline_variables=201606\");\n \t  cpp_define (pfile, \"__cpp_aggregate_bases=201603\");\n \t  cpp_define (pfile, \"__cpp_deduction_guides=201606\");\n+\t  cpp_define (pfile, \"__cpp_noexcept_function_type=201510\");\n \t}\n       if (flag_concepts)\n \tcpp_define (pfile, \"__cpp_concepts=201507\");"}, {"sha": "213353b9abdf766b59dce9ee6432e04d4f094499", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -360,6 +360,13 @@ Wc++14-compat\n C++ ObjC++ Var(warn_cxx14_compat) Warning LangEnabledBy(C++ ObjC++,Wall)\n Warn about C++ constructs whose meaning differs between ISO C++ 2011 and ISO C++ 2014.\n \n+Wc++1z-compat\n+C++ ObjC++ Var(warn_cxx1z_compat) Warning LangEnabledBy(C++ ObjC++,Wall)\n+Warn about C++ constructs whose meaning differs between ISO C++ 2014 and (forthcoming) ISO C++ 201z(7?).\n+\n+Wc++17-compat\n+C++ ObjC++ Warning Alias(Wc++1z-compat) Undocumented\n+\n Wcast-qual\n C ObjC C++ ObjC++ Var(warn_cast_qual) Warning\n Warn about casts which discard qualifiers."}, {"sha": "f325ccc89322f74389e60699c39398ffe1ae0794", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -1,5 +1,52 @@\n 2016-11-07  Jason Merrill  <jason@redhat.com>\n \n+\tImplement P0012R1, Make exception specifications part of the type\n+\tsystem.\n+\t* cp-tree.h (enum tsubst_flags): Add tf_fndecl_type.\n+\t(flag_noexcept_type, ce_type): New.\n+\t* call.c (build_conv): Add ck_fnptr.\n+\t(enum conversion_kind): Change ck_tsafe to ck_fnptr.\n+\t(convert_like_real): Likewise.\n+\t(standard_conversion): Likewise.  Allow function pointer\n+\tconversions for pointers to member functions.\n+\t(reference_compatible_p): Allow function pointer conversions.\n+\t(direct_reference_binding): Likewise.\n+\t(reference_binding): Reference-compatible is no longer a subset of\n+\treference-related.\n+\t(is_subseq): Also strip ck_lvalue after next_conversion.\n+\t* class.c (instantiate_type): Check fnptr_conv_p.\n+\t(resolve_address_of_overloaded_function): Likewise.\n+\t* cvt.c (can_convert_tx_safety): Now static.\n+\t(noexcept_conv_p, fnptr_conv_p, strip_fnptr_conv): New.\n+\t* decl.c (flag_noexcept_type): Define.\n+\t(cxx_init_decl_processing): Set it.\n+\t(bad_specifiers): Check it.\n+\t(grokdeclarator) [cdk_function]: Add exception-spec to type here.\n+\t* lambda.c (maybe_add_lambda_conv_op): Add exception-spec to\n+\treturned pointer.\n+\t* mangle.c (struct globals): Add need_cxx1z_warning.\n+\t(mangle_decl): Check it.\n+\t(write_exception_spec): New.\n+\t(write_function_type): Call it.\n+\t(canonicalize_for_substitution): Handle exception spec.\n+\t(write_type): Likewise.\n+\t(write_encoding): Set processing_template_decl across mangling of\n+\tpartially-instantiated type.\n+\t* pt.c (determine_specialization): Pass tf_fndecl_type.\n+\t(tsubst_decl, fn_type_unification): Likewise.\n+\t(tsubst): Strip tf_fndecl_type, pass it to\n+\ttsubst_exception_specification.\n+\t(convert_nontype_argument_function): Handle function pointer\n+\tconversion.\n+\t(convert_nontype_argument): Likewise.\n+\t(unify, for_each_template_parm_r): Walk into noexcept-specifier.\n+\t* rtti.c (ptr_initializer): Encode noexcept.\n+\t* tree.c (canonical_eh_spec): New.\n+\t(build_exception_variant): Use it.\n+\t* typeck.c (composite_pointer_type): Handle fnptr conversion.\n+\t(comp_except_specs): Compare canonical EH specs.\n+\t(structural_comptypes): Call it.\n+\n \t* call.c (standard_conversion): Reorganize pointer conversions.\n \t* pt.c (convert_nontype_argument_function): Convert to ref here.\n \t(convert_nontype_argument): Not here."}, {"sha": "0dcf322344c07af5f44e947f2d57644e4aade41b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -45,7 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n enum conversion_kind {\n   ck_identity,\n   ck_lvalue,\n-  ck_tsafe,\n+  ck_fnptr,\n   ck_qual,\n   ck_std,\n   ck_ptr,\n@@ -771,6 +771,7 @@ build_conv (conversion_kind code, tree type, conversion *from)\n       break;\n \n     case ck_qual:\n+    case ck_fnptr:\n       if (rank < cr_exact)\n \trank = cr_exact;\n       break;\n@@ -1285,18 +1286,6 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t  conv = build_conv (ck_ptr, from, conv);\n \t  conv->base_p = true;\n \t}\n-      else if (tx_safe_fn_type_p (from_pointee))\n-\t{\n-\t  /* A prvalue of type \"pointer to transaction_safe function\" can be\n-\t     converted to a prvalue of type \"pointer to function\". */\n-\t  tree unsafe = tx_unsafe_fn_variant (from_pointee);\n-\t  if (same_type_p (unsafe, to_pointee))\n-\t    {\n-\t      from_pointee = unsafe;\n-\t      from = build_pointer_type (unsafe);\n-\t      conv = build_conv (ck_tsafe, from, conv);\n-\t    }\n-\t}\n \n       if (same_type_p (from, to))\n \t/* OK */;\n@@ -1310,6 +1299,8 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n       else if (expr && string_conv_p (to, expr, 0))\n \t/* converting from string constant to char *.  */\n \tconv = build_conv (ck_qual, to, conv);\n+      else if (fnptr_conv_p (to, from))\n+\tconv = build_conv (ck_fnptr, to, conv);\n       /* Allow conversions among compatible ObjC pointer types (base\n \t conversions have been already handled above).  */\n       else if (c_dialect_objc ()\n@@ -1332,18 +1323,29 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n       tree fbase = class_of_this_parm (fromfn);\n       tree tbase = class_of_this_parm (tofn);\n \n-      if (!DERIVED_FROM_P (fbase, tbase)\n-\t  || !same_type_p (static_fn_type (fromfn),\n-\t\t\t   static_fn_type (tofn)))\n+      if (!DERIVED_FROM_P (fbase, tbase))\n+\treturn NULL;\n+\n+      tree fstat = static_fn_type (fromfn);\n+      tree tstat = static_fn_type (tofn);\n+      if (same_type_p (tstat, fstat)\n+\t  || fnptr_conv_p (tstat, fstat))\n+\t/* OK */;\n+      else\n \treturn NULL;\n \n-      from = build_memfn_type (fromfn,\n-                               tbase,\n-                               cp_type_quals (tbase),\n-                               type_memfn_rqual (tofn));\n-      from = build_ptrmemfunc_type (build_pointer_type (from));\n-      conv = build_conv (ck_pmem, from, conv);\n-      conv->base_p = true;\n+      if (!same_type_p (fbase, tbase))\n+\t{\n+\t  from = build_memfn_type (fstat,\n+\t\t\t\t   tbase,\n+\t\t\t\t   cp_type_quals (tbase),\n+\t\t\t\t   type_memfn_rqual (tofn));\n+\t  from = build_ptrmemfunc_type (build_pointer_type (from));\n+\t  conv = build_conv (ck_pmem, from, conv);\n+\t  conv->base_p = true;\n+\t}\n+      if (fnptr_conv_p (tstat, fstat))\n+\tconv = build_conv (ck_fnptr, to, conv);\n     }\n   else if (tcode == BOOLEAN_TYPE)\n     {\n@@ -1441,10 +1443,14 @@ reference_compatible_p (tree t1, tree t2)\n {\n   /* [dcl.init.ref]\n \n-     \"cv1 T1\" is reference compatible with \"cv2 T2\" if T1 is\n-     reference-related to T2 and cv1 is the same cv-qualification as,\n-     or greater cv-qualification than, cv2.  */\n-  return (reference_related_p (t1, t2)\n+     \"cv1 T1\" is reference compatible with \"cv2 T2\" if\n+       * T1 is reference-related to T2 or\n+       * T2 is \"noexcept function\" and T1 is \"function\", where the\n+         function types are otherwise the same,\n+     and cv1 is the same cv-qualification as, or greater cv-qualification\n+     than, cv2.  */\n+  return ((reference_related_p (t1, t2)\n+\t   || fnptr_conv_p (t1, t2))\n \t  && at_least_as_qualified_p (t1, t2));\n }\n \n@@ -1478,7 +1484,7 @@ direct_reference_binding (tree type, conversion *conv)\n      either an identity conversion or, if the conversion function\n      returns an entity of a type that is a derived class of the\n      parameter type, a derived-to-base conversion.  */\n-  if (!same_type_ignoring_top_level_qualifiers_p (t, conv->type))\n+  if (is_properly_derived_from (conv->type, t))\n     {\n       /* Represent the derived-to-base conversion.  */\n       conv = build_conv (ck_base, t, conv);\n@@ -1591,7 +1597,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n      [8.5.3/5 dcl.init.ref] is changed to also require direct bindings for\n      const and rvalue references to rvalues of compatible class type.\n      We should also do direct bindings for non-class xvalues.  */\n-  if (related_p && gl_kind)\n+  if ((related_p || compatible_p) && gl_kind)\n     {\n       /* [dcl.init.ref]\n \n@@ -6978,9 +6984,9 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n     case ck_lvalue:\n       return decay_conversion (expr, complain);\n \n-    case ck_tsafe:\n+    case ck_fnptr:\n       /* ??? Should the address of a transaction-safe pointer point to the TM\n-\t clone, and this conversion look up the primary function?  */\n+        clone, and this conversion look up the primary function?  */\n       return build_nop (totype, expr);\n \n     case ck_qual:\n@@ -8863,10 +8869,15 @@ is_subseq (conversion *ics1, conversion *ics2)\n \n       ics2 = next_conversion (ics2);\n \n+      while (ics2->kind == ck_rvalue\n+\t     || ics2->kind == ck_lvalue)\n+\tics2 = next_conversion (ics2);\n+\n       if (ics2->kind == ics1->kind\n \t  && same_type_p (ics2->type, ics1->type)\n-\t  && same_type_p (next_conversion (ics2)->type,\n-\t\t\t  next_conversion (ics1)->type))\n+\t  && (ics1->kind == ck_identity\n+\t      || same_type_p (next_conversion (ics2)->type,\n+\t\t\t      next_conversion (ics1)->type)))\n \treturn true;\n     }\n }"}, {"sha": "5460ae5d6265de1758a8610c137bf3716d3ad816", "filename": "gcc/cp/class.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -8177,10 +8177,14 @@ resolve_address_of_overloaded_function (tree target_type,\n \t  if (DECL_ANTICIPATED (fn))\n \t    continue;\n \n+\t  /* In C++17 we need the noexcept-qualifier to compare types.  */\n+\t  if (flag_noexcept_type)\n+\t    maybe_instantiate_noexcept (fn);\n+\n \t  /* See if there's a match.  */\n \t  tree fntype = static_fn_type (fn);\n \t  if (same_type_p (target_fn_type, fntype)\n-\t      || can_convert_tx_safety (target_fn_type, fntype))\n+\t      || fnptr_conv_p (target_fn_type, fntype))\n \t    matches = tree_cons (fn, NULL_TREE, matches);\n \t}\n     }\n@@ -8257,10 +8261,14 @@ resolve_address_of_overloaded_function (tree target_type,\n \t      require_deduced_type (instantiation);\n \t    }\n \n+\t  /* In C++17 we need the noexcept-qualifier to compare types.  */\n+\t  if (flag_noexcept_type)\n+\t    maybe_instantiate_noexcept (instantiation);\n+\n \t  /* See if there's a match.  */\n \t  tree fntype = static_fn_type (instantiation);\n \t  if (same_type_p (target_fn_type, fntype)\n-\t      || can_convert_tx_safety (target_fn_type, fntype))\n+\t      || fnptr_conv_p (target_fn_type, fntype))\n \t    matches = tree_cons (instantiation, fn, matches);\n \t}\n \n@@ -8424,6 +8432,8 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t complain)\n       tree fntype = non_reference (lhstype);\n       if (same_type_p (fntype, TREE_TYPE (rhs)))\n \treturn rhs;\n+      if (fnptr_conv_p (fntype, TREE_TYPE (rhs)))\n+\treturn rhs;\n       if (flag_ms_extensions\n \t  && TYPE_PTRMEMFUNC_P (fntype)\n \t  && !TYPE_PTRMEMFUNC_P (TREE_TYPE (rhs)))"}, {"sha": "20b52ad675d3b470470e8b4df23f61de583ef532", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -4744,6 +4744,8 @@ enum tsubst_flags {\n \t\t\t\t    for calls in decltype (5.2.2/11).  */\n   tf_partial = 1 << 8,\t\t /* Doing initial explicit argument\n \t\t\t\t    substitution in fn_type_unification.  */\n+  tf_fndecl_type = 1 << 9,   /* Substituting the type of a function\n+\t\t\t\tdeclaration.  */\n   /* Convenient substitution flags combinations.  */\n   tf_warning_or_error = tf_warning | tf_error\n };\n@@ -4949,6 +4951,10 @@ extern int at_eof;\n \n extern bool defer_mangling_aliases;\n \n+/* True if noexcept is part of the type (i.e. in C++17).  */\n+\n+extern bool flag_noexcept_type;\n+\n /* A list of namespace-scope objects which have constructors or\n    destructors which reside in the global scope.  The decl is stored\n    in the TREE_VALUE slot and the initializer is stored in the\n@@ -5737,7 +5743,8 @@ extern tree type_promotes_to\t\t\t(tree);\n extern tree perform_qualification_conversions\t(tree, tree);\n extern bool tx_safe_fn_type_p\t\t\t(tree);\n extern tree tx_unsafe_fn_variant\t\t(tree);\n-extern bool can_convert_tx_safety\t\t(tree, tree);\n+extern bool fnptr_conv_p\t\t\t(tree, tree);\n+extern tree strip_fnptr_conv\t\t\t(tree);\n \n /* in name-lookup.c */\n extern tree pushdecl\t\t\t\t(tree);\n@@ -6577,6 +6584,7 @@ extern tree build_overload\t\t\t(tree, tree);\n extern tree ovl_scope\t\t\t\t(tree);\n extern const char *cxx_printable_name\t\t(tree, int);\n extern const char *cxx_printable_name_translate\t(tree, int);\n+extern tree canonical_eh_spec\t\t\t(tree);\n extern tree build_exception_variant\t\t(tree, tree);\n extern tree bind_template_template_parm\t\t(tree, tree);\n extern tree array_type_nelts_total\t\t(tree);\n@@ -6648,7 +6656,7 @@ extern tree complete_type\t\t\t(tree);\n extern tree complete_type_or_else\t\t(tree, tree);\n extern tree complete_type_or_maybe_complain\t(tree, tree, tsubst_flags_t);\n extern int type_unknown_p\t\t\t(const_tree);\n-enum { ce_derived, ce_normal, ce_exact };\n+enum { ce_derived, ce_type, ce_normal, ce_exact };\n extern bool comp_except_specs\t\t\t(const_tree, const_tree, int);\n extern bool comptypes\t\t\t\t(tree, tree, int);\n extern bool same_type_ignoring_top_level_qualifiers_p (tree, tree);"}, {"sha": "400566f4e361725e13d7a2e8d50620f9162e5aa4", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -1932,9 +1932,84 @@ tx_unsafe_fn_variant (tree t)\n /* Return true iff FROM can convert to TO by a transaction-safety\n    conversion.  */\n \n-bool\n+static bool\n can_convert_tx_safety (tree to, tree from)\n {\n   return (flag_tm && tx_safe_fn_type_p (from)\n \t  && same_type_p (to, tx_unsafe_fn_variant (from)));\n }\n+\n+/* Return true iff FROM can convert to TO by dropping noexcept.  */\n+\n+static bool\n+noexcept_conv_p (tree to, tree from)\n+{\n+  if (!flag_noexcept_type)\n+    return false;\n+\n+  tree t = non_reference (to);\n+  tree f = from;\n+  if (TYPE_PTRMEMFUNC_P (t)\n+      && TYPE_PTRMEMFUNC_P (f))\n+    {\n+      t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n+      f = TYPE_PTRMEMFUNC_FN_TYPE (f);\n+    }\n+  if (TREE_CODE (t) == POINTER_TYPE\n+      && TREE_CODE (f) == POINTER_TYPE)\n+    {\n+      t = TREE_TYPE (t);\n+      f = TREE_TYPE (f);\n+    }\n+  tree_code code = TREE_CODE (f);\n+  if (TREE_CODE (t) != code)\n+    return false;\n+  if (code != FUNCTION_TYPE && code != METHOD_TYPE)\n+    return false;\n+  if (!type_throw_all_p (t)\n+      || type_throw_all_p (f))\n+    return false;\n+  tree v = build_exception_variant (f, NULL_TREE);\n+  return same_type_p (t, v);\n+}\n+\n+/* Return true iff FROM can convert to TO by a function pointer conversion.  */\n+\n+bool\n+fnptr_conv_p (tree to, tree from)\n+{\n+  tree t = non_reference (to);\n+  tree f = from;\n+  if (TYPE_PTRMEMFUNC_P (t)\n+      && TYPE_PTRMEMFUNC_P (f))\n+    {\n+      t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n+      f = TYPE_PTRMEMFUNC_FN_TYPE (f);\n+    }\n+  if (TREE_CODE (t) == POINTER_TYPE\n+      && TREE_CODE (f) == POINTER_TYPE)\n+    {\n+      t = TREE_TYPE (t);\n+      f = TREE_TYPE (f);\n+    }\n+\n+  return (noexcept_conv_p (t, f)\n+\t  || can_convert_tx_safety (t, f));\n+}\n+\n+/* Return FN with any NOP_EXPRs that represent function pointer\n+   conversions stripped.  */\n+\n+tree\n+strip_fnptr_conv (tree fn)\n+{\n+  while (TREE_CODE (fn) == NOP_EXPR)\n+    {\n+      tree op = TREE_OPERAND (fn, 0);\n+      if (fnptr_conv_p (TREE_TYPE (fn), TREE_TYPE (op)))\n+\tfn = op;\n+      else\n+\tbreak;\n+    }\n+  return fn;\n+}"}, {"sha": "c0321f9f9594c1255ba5a394cdd236dd46f5c303", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -73,8 +73,6 @@ static int check_static_variable_definition (tree, tree);\n static void record_unknown_type (tree, const char *);\n static tree builtin_function_1 (tree, tree, bool);\n static int member_function_or_else (tree, tree, enum overload_flags);\n-static void bad_specifiers (tree, enum bad_spec_place, int, int, int, int,\n-\t\t\t    int);\n static void check_for_uninitialized_const_var (tree);\n static tree local_variable_p_walkfn (tree *, int *, void *);\n static const char *tag_name (enum tag_types);\n@@ -227,6 +225,9 @@ struct GTY((for_user)) named_label_entry {\n    function, two inside the body of a function in a local class, etc.)  */\n int function_depth;\n \n+/* Whether the exception-specifier is part of a function type (i.e. C++17).  */\n+bool flag_noexcept_type;\n+\n /* States indicating how grokdeclarator() should handle declspecs marked\n    with __attribute__((deprecated)).  An object declared as\n    __attribute__((deprecated)) suppresses warnings of uses of other\n@@ -4044,6 +4045,8 @@ cxx_init_decl_processing (void)\n   std_node = current_namespace;\n   pop_namespace ();\n \n+  flag_noexcept_type = (cxx_dialect >= cxx1z);\n+\n   c_common_nodes_and_builtins ();\n \n   integer_two_node = build_int_cst (NULL_TREE, 2);\n@@ -7842,6 +7845,7 @@ bad_specifiers (tree object,\n   if (friendp)\n     error (\"%q+D declared as a friend\", object);\n   if (raises\n+      && !flag_noexcept_type\n       && (TREE_CODE (object) == TYPE_DECL\n \t  || (!TYPE_PTRFN_P (TREE_TYPE (object))\n \t      && !TYPE_REFFN_P (TREE_TYPE (object))\n@@ -10477,6 +10481,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t The optional attribute-specifier-seq appertains to\n \t\t the function type.  */\n \t      decl_attributes (&type, attrs, 0);\n+\n+\t    if (raises)\n+\t      type = build_exception_variant (type, raises);\n \t  }\n \t  break;\n "}, {"sha": "c48cd5201e06ac29c4cdb6656800205932c4d281", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -1029,6 +1029,9 @@ maybe_add_lambda_conv_op (tree type)\n   tree stattype = build_function_type (fn_result, FUNCTION_ARG_CHAIN (callop));\n   stattype = (cp_build_type_attribute_variant\n \t      (stattype, TYPE_ATTRIBUTES (optype)));\n+  if (flag_noexcept_type\n+      && TYPE_NOTHROW_P (TREE_TYPE (callop)))\n+    stattype = build_exception_variant (stattype, noexcept_true_spec);\n \n   /* First build up the conversion op.  */\n "}, {"sha": "a354ec5ead3d485aee7b256c0710f4735af1ec8e", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 68, "deletions": 3, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -114,6 +114,9 @@ struct GTY(()) globals {\n   /* True if the mangling will be different in a future version of the\n      ABI.  */\n   bool need_abi_warning;\n+\n+  /* True if the mangling will be different in C++17 mode.  */\n+  bool need_cxx1z_warning;\n };\n \n static GTY (()) globals G;\n@@ -344,6 +347,43 @@ dump_substitution_candidates (void)\n     }\n }\n \n+/* <exception-spec> ::=\n+      Do  -- non-throwing exception specification\n+      DO <expression> E  -- computed (instantiation-dependent) noexcept\n+      Dw <type>* E  -- throw (types)  */\n+\n+static void\n+write_exception_spec (tree spec)\n+{\n+\n+  if (!spec || spec == noexcept_false_spec)\n+    /* Nothing.  */\n+    return;\n+\n+  if (!flag_noexcept_type)\n+    {\n+      G.need_cxx1z_warning = true;\n+      return;\n+    }\n+\n+  if (nothrow_spec_p (spec))\n+    write_string (\"Do\");\n+  else if (TREE_PURPOSE (spec))\n+    {\n+      gcc_assert (uses_template_parms (TREE_PURPOSE (spec)));\n+      write_string (\"DO\");\n+      write_expression (TREE_PURPOSE (spec));\n+      write_char ('E');\n+    }\n+  else\n+    {\n+      write_string (\"Dw\");\n+      for (tree t = spec; t; t = TREE_CHAIN (t))\n+\twrite_type (TREE_VALUE (t));\n+      write_char ('E');\n+    }\n+}\n+\n /* Both decls and types can be substitution candidates, but sometimes\n    they refer to the same thing.  For instance, a TYPE_DECL and\n    RECORD_TYPE for the same class refer to the same thing, and should\n@@ -375,7 +415,15 @@ canonicalize_for_substitution (tree node)\n \t\t\t\t\tcp_type_quals (node));\n       if (TREE_CODE (node) == FUNCTION_TYPE\n \t  || TREE_CODE (node) == METHOD_TYPE)\n-\tnode = build_ref_qualified_type (node, type_memfn_rqual (orig));\n+\t{\n+\t  node = build_ref_qualified_type (node, type_memfn_rqual (orig));\n+\t  tree r = canonical_eh_spec (TYPE_RAISES_EXCEPTIONS (orig));\n+\t  if (flag_noexcept_type)\n+\t    node = build_exception_variant (node, r);\n+\t  else\n+\t    /* Set the warning flag if appropriate.  */\n+\t    write_exception_spec (r);\n+\t}\n     }\n   return node;\n }\n@@ -777,9 +825,11 @@ write_encoding (const tree decl)\n     {\n       tree fn_type;\n       tree d;\n+      bool tmpl = decl_is_template_id (decl, NULL);\n \n-      if (decl_is_template_id (decl, NULL))\n+      if (tmpl)\n \t{\n+\t  ++processing_template_decl;\n \t  fn_type = get_mostly_instantiated_function_type (decl);\n \t  /* FN_TYPE will not have parameter types for in-charge or\n \t     VTT parameters.  Therefore, we pass NULL_TREE to\n@@ -796,6 +846,9 @@ write_encoding (const tree decl)\n       write_bare_function_type (fn_type,\n \t\t\t\tmangle_return_type_p (decl),\n \t\t\t\td);\n+\n+      if (tmpl)\n+\t--processing_template_decl;\n     }\n }\n \n@@ -2064,7 +2117,11 @@ write_type (tree type)\n       type = TYPE_MAIN_VARIANT (type);\n       if (TREE_CODE (type) == FUNCTION_TYPE\n \t  || TREE_CODE (type) == METHOD_TYPE)\n-\ttype = build_ref_qualified_type (type, type_memfn_rqual (type_orig));\n+\t{\n+\t  type = build_ref_qualified_type (type, type_memfn_rqual (type_orig));\n+\t  type = build_exception_variant (type,\n+\t\t\t\t\t  TYPE_RAISES_EXCEPTIONS (type_orig));\n+\t}\n \n       /* According to the C++ ABI, some library classes are passed the\n \t same as the scalar type of their single member and use the same\n@@ -2589,6 +2646,8 @@ write_function_type (const tree type)\n       write_CV_qualifiers_for_type (this_type);\n     }\n \n+  write_exception_spec (TYPE_RAISES_EXCEPTIONS (type));\n+\n   if (tx_safe_fn_type_p (type))\n     write_string (\"Dx\");\n \n@@ -3776,6 +3835,12 @@ mangle_decl (const tree decl)\n     }\n   SET_DECL_ASSEMBLER_NAME (decl, id);\n \n+  if (G.need_cxx1z_warning)\n+    warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wc__1z_compat,\n+\t\t\"mangled name for %qD will change in C++17 because the \"\n+\t\t\"exception specification is part of a function type\",\n+\t\tdecl);\n+\n   if (id != DECL_NAME (decl)\n       /* Don't do this for a fake symbol we aren't going to emit anyway.  */\n       && TREE_CODE (decl) != TYPE_DECL"}, {"sha": "3df71dd97dbd4ed07aa58aa91ae698d14564b58e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -2216,7 +2216,7 @@ determine_specialization (tree template_id,\n             continue;\n \n           // Then, try to form the new function type.\n-\t  insttype = tsubst (TREE_TYPE (fn), targs, tf_none, NULL_TREE);\n+\t  insttype = tsubst (TREE_TYPE (fn), targs, tf_fndecl_type, NULL_TREE);\n \t  if (insttype == error_mark_node)\n \t    continue;\n \t  fn_arg_types\n@@ -5876,7 +5876,7 @@ get_underlying_template (tree tmpl)\n }\n \n /* Subroutine of convert_nontype_argument. Converts EXPR to TYPE, which\n-   must be a function or a pointer-to-function type, as specified\n+   must be a reference-to-function or a pointer-to-function type, as specified\n    in [temp.arg.nontype]: disambiguate EXPR if it is an overload set,\n    and check that the resulting function has external linkage.  */\n \n@@ -5892,7 +5892,7 @@ convert_nontype_argument_function (tree type, tree expr,\n   if (fn == error_mark_node)\n     return error_mark_node;\n \n-  fn_no_ptr = fn;\n+  fn_no_ptr = strip_fnptr_conv (fn);\n   if (TREE_CODE (fn_no_ptr) == ADDR_EXPR)\n     fn_no_ptr = TREE_OPERAND (fn_no_ptr, 0);\n   if (BASELINK_P (fn_no_ptr))\n@@ -6672,6 +6672,11 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t  && !check_valid_ptrmem_cst_expr (type, expr, complain))\n \treturn error_mark_node;\n \n+      /* Repeated conversion can't deal with a conversion that turns PTRMEM_CST\n+\t into a CONSTRUCTOR, so build up a new PTRMEM_CST instead.  */\n+      if (fnptr_conv_p (type, TREE_TYPE (expr)))\n+\texpr = make_ptrmem_cst (type, PTRMEM_CST_MEMBER (expr));\n+\n       /* There is no way to disable standard conversions in\n \t resolve_address_of_overloaded_function (called by\n \t instantiate_type). It is possible that the call succeeded by\n@@ -8861,6 +8866,13 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n \t   want walk_tree walking into them itself.  */\n \t*walk_subtrees = 0;\n       }\n+\n+      if (flag_noexcept_type)\n+\t{\n+\t  tree spec = TYPE_RAISES_EXCEPTIONS (t);\n+\t  if (spec)\n+\t    WALK_SUBTREE (TREE_PURPOSE (spec));\n+\t}\n       break;\n \n     case TYPEOF_TYPE:\n@@ -11932,7 +11944,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    member = 0;\n \t    ctx = DECL_CONTEXT (t);\n \t  }\n-\ttype = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\ttype = tsubst (TREE_TYPE (t), args, complain|tf_fndecl_type, in_decl);\n \tif (type == error_mark_node)\n \t  RETURN (error_mark_node);\n \n@@ -13015,6 +13027,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t}\n     }\n \n+  bool fndecl_type = (complain & tf_fndecl_type);\n+  complain &= ~tf_fndecl_type;\n+\n   if (type\n       && code != TYPENAME_TYPE\n       && code != TEMPLATE_TYPE_PARM\n@@ -13512,8 +13527,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  return error_mark_node;\n \n \t/* Substitute the exception specification.  */\n-\tspecs = tsubst_exception_specification (t, args, complain,\n-\t\t\t\t\t\tin_decl, /*defer_ok*/true);\n+\tspecs = tsubst_exception_specification (t, args, complain, in_decl,\n+\t\t\t\t\t\t/*defer_ok*/fndecl_type);\n \tif (specs == error_mark_node)\n \t  return error_mark_node;\n \tif (specs)\n@@ -17991,7 +18006,7 @@ fn_type_unification (tree fn,\n \t access path at this point.  */\n       push_deferring_access_checks (dk_deferred);\n       fntype = tsubst (TREE_TYPE (fn), explicit_targs,\n-\t\t       complain | tf_partial, NULL_TREE);\n+\t\t       complain | tf_partial | tf_fndecl_type, NULL_TREE);\n       pop_deferring_access_checks ();\n       input_location = loc;\n       processing_template_decl -= incomplete;\n@@ -20333,9 +20348,27 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t  args[i] = TREE_VALUE (a);\n \tnargs = i;\n \n-\treturn type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n-\t\t\t\t      args, nargs, 1, DEDUCE_EXACT,\n-\t\t\t\t      LOOKUP_NORMAL, NULL, explain_p);\n+\tif (type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n+\t\t\t\t   args, nargs, 1, DEDUCE_EXACT,\n+\t\t\t\t   LOOKUP_NORMAL, NULL, explain_p))\n+\t  return 1;\n+\n+\tif (flag_noexcept_type)\n+\t  {\n+\t    tree pspec = TYPE_RAISES_EXCEPTIONS (parm);\n+\t    tree aspec = canonical_eh_spec (TYPE_RAISES_EXCEPTIONS (arg));\n+\t    if (pspec == NULL_TREE) pspec = noexcept_false_spec;\n+\t    if (aspec == NULL_TREE) aspec = noexcept_false_spec;\n+\t    if (TREE_PURPOSE (pspec) && TREE_PURPOSE (aspec)\n+\t\t&& uses_template_parms (TREE_PURPOSE (pspec)))\n+\t      RECUR_AND_CHECK_FAILURE (tparms, targs, TREE_PURPOSE (pspec),\n+\t\t\t\t       TREE_PURPOSE (aspec),\n+\t\t\t\t       UNIFY_ALLOW_NONE, explain_p);\n+\t    else if (nothrow_spec_p (pspec) && !nothrow_spec_p (aspec))\n+\t      return unify_type_mismatch (explain_p, parm, arg);\n+\t  }\n+\n+\treturn 0;\n       }\n \n     case OFFSET_TYPE:"}, {"sha": "247a98fc5e94af5ef76a7b38ee8ff8bffcb863ad", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -985,6 +985,14 @@ ptr_initializer (tinfo_s *ti, tree target)\n       flags |= 0x20;\n       to = tx_unsafe_fn_variant (to);\n     }\n+  if (flag_noexcept_type\n+      && (TREE_CODE (to) == FUNCTION_TYPE\n+\t  || TREE_CODE (to) == METHOD_TYPE)\n+      && TYPE_NOTHROW_P (to))\n+    {\n+      flags |= 0x40;\n+      to = build_exception_variant (to, NULL_TREE);\n+    }\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, flags));\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,"}, {"sha": "7872dd29cf82380ce37a50b9f925e69586157825", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -2209,6 +2209,27 @@ cxx_printable_name_translate (tree decl, int v)\n   return cxx_printable_name_internal (decl, v, true);\n }\n \f\n+/* Return the canonical version of exception-specification RAISES for a C++17\n+   function type, for use in type comparison and building TYPE_CANONICAL.  */\n+\n+tree\n+canonical_eh_spec (tree raises)\n+{\n+  if (raises == NULL_TREE)\n+    return raises;\n+  else if (DEFERRED_NOEXCEPT_SPEC_P (raises)\n+\t   || uses_template_parms (raises)\n+\t   || uses_template_parms (TREE_PURPOSE (raises)))\n+    /* Keep a dependent or deferred exception specification.  */\n+    return raises;\n+  else if (nothrow_spec_p (raises))\n+    /* throw() -> noexcept.  */\n+    return noexcept_true_spec;\n+  else\n+    /* For C++17 type matching, anything else -> nothing.  */\n+    return NULL_TREE;\n+}\n+\n /* Build the FUNCTION_TYPE or METHOD_TYPE which may throw exceptions\n    listed in RAISES.  */\n \n@@ -2230,6 +2251,25 @@ build_exception_variant (tree type, tree raises)\n   /* Need to build a new variant.  */\n   v = build_variant_type_copy (type);\n   TYPE_RAISES_EXCEPTIONS (v) = raises;\n+\n+  if (!flag_noexcept_type)\n+    /* The exception-specification is not part of the canonical type.  */\n+    return v;\n+\n+  /* Canonicalize the exception specification.  */\n+  tree cr = canonical_eh_spec (raises);\n+\n+  if (TYPE_STRUCTURAL_EQUALITY_P (type))\n+    /* Propagate structural equality. */\n+    SET_TYPE_STRUCTURAL_EQUALITY (v);\n+  else if (TYPE_CANONICAL (type) != type || cr != raises)\n+    /* Build the underlying canonical type, since it is different\n+       from TYPE. */\n+    TYPE_CANONICAL (v) = build_exception_variant (TYPE_CANONICAL (type), cr);\n+  else\n+    /* T is its own canonical type. */\n+    TYPE_CANONICAL (v) = v;\n+\n   return v;\n }\n "}, {"sha": "211696cf02957892b3af7d93036aa0e105872eab", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -647,6 +647,14 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n \treturn objc_common_type (t1, t2);\n     }\n \n+  /* if T1 or T2 is \"pointer to noexcept function\" and the other type is\n+     \"pointer to function\", where the function types are otherwise the same,\n+     \"pointer to function\" */\n+  if (fnptr_conv_p (t1, t2))\n+    return t1;\n+  if (fnptr_conv_p (t2, t1))\n+    return t2;\n+\n   /* [expr.eq] permits the application of a pointer conversion to\n      bring the pointers to a common type.  */\n   if (TYPE_PTR_P (t1) && TYPE_PTR_P (t2)\n@@ -710,22 +718,6 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n           return error_mark_node;\n         }\n     }\n-  else if (TYPE_PTR_P (t1) && TYPE_PTR_P (t2)\n-\t   && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (t1))\n-\t   && TREE_CODE (TREE_TYPE (t2)) == TREE_CODE (TREE_TYPE (t1)))\n-    {\n-      /* ...if T1 is \"pointer to transaction_safe function\" and T2 is \"pointer\n-\t to function\", where the function types are otherwise the same, T2, and\n-\t vice versa.... */\n-      tree f1 = TREE_TYPE (t1);\n-      tree f2 = TREE_TYPE (t2);\n-      bool safe1 = tx_safe_fn_type_p (f1);\n-      bool safe2 = tx_safe_fn_type_p (f2);\n-      if (safe1 && !safe2)\n-\tt1 = build_pointer_type (tx_unsafe_fn_variant (f1));\n-      else if (safe2 && !safe1)\n-\tt2 = build_pointer_type (tx_unsafe_fn_variant (f2));\n-    }\n \n   return composite_pointer_type_r (t1, t2, operation, complain);\n }\n@@ -1020,6 +1012,7 @@ comp_except_types (tree a, tree b, bool exact)\n \n /* Return true if TYPE1 and TYPE2 are equivalent exception specifiers.\n    If EXACT is ce_derived, T2 can be stricter than T1 (according to 15.4/5).\n+   If EXACT is ce_type, the C++17 type compatibility rules apply.\n    If EXACT is ce_normal, the compatibility rules in 15.4/3 apply.\n    If EXACT is ce_exact, the specs must be exactly the same. Exception lists\n    are unordered, but we've already filtered out duplicates. Most lists will\n@@ -1038,8 +1031,13 @@ comp_except_specs (const_tree t1, const_tree t2, int exact)\n   /* First handle noexcept.  */\n   if (exact < ce_exact)\n     {\n+      if (exact == ce_type\n+\t  && (canonical_eh_spec (CONST_CAST_TREE (t1))\n+\t      == canonical_eh_spec (CONST_CAST_TREE (t2))))\n+\treturn true;\n+\n       /* noexcept(false) is compatible with no exception-specification,\n-\t and stricter than any spec.  */\n+\t and less strict than any spec.  */\n       if (t1 == noexcept_false_spec)\n \treturn t2 == NULL_TREE || exact == ce_derived;\n       /* Even a derived noexcept(false) is compatible with no\n@@ -1222,10 +1220,17 @@ structural_comptypes (tree t1, tree t2, int strict)\n     return false;\n   /* Need to check this before TYPE_MAIN_VARIANT.\n      FIXME function qualifiers should really change the main variant.  */\n-  if ((TREE_CODE (t1) == FUNCTION_TYPE\n-       || TREE_CODE (t1) == METHOD_TYPE)\n-      && type_memfn_rqual (t1) != type_memfn_rqual (t2))\n-    return false;\n+  if (TREE_CODE (t1) == FUNCTION_TYPE\n+      || TREE_CODE (t1) == METHOD_TYPE)\n+    {\n+      if (type_memfn_rqual (t1) != type_memfn_rqual (t2))\n+\treturn false;\n+      if (flag_noexcept_type\n+\t  && !comp_except_specs (TYPE_RAISES_EXCEPTIONS (t1),\n+\t\t\t\t TYPE_RAISES_EXCEPTIONS (t2),\n+\t\t\t\t ce_type))\n+\treturn false;\n+    }\n \n   /* Allow for two different type nodes which have essentially the same\n      definition.  Note that we already checked for equality of the type"}, {"sha": "17c5c225d0c98b8e9ecffecda5985024ffaa12d0", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -5574,6 +5574,11 @@ enabled by @option{-Wall}.\n Warn about C++ constructs whose meaning differs between ISO C++ 2011\n and ISO C++ 2014.  This warning is enabled by @option{-Wall}.\n \n+@item -Wc++1z-compat @r{(C++ and Objective-C++ only)}\n+@opindex Wc++1z-compat\n+Warn about C++ constructs whose meaning differs between ISO C++ 2014\n+and the forthoming ISO C++ 2017(?).  This warning is enabled by @option{-Wall}.\n+\n @item -Wcast-qual\n @opindex Wcast-qual\n @opindex Wno-cast-qual"}, {"sha": "f4658a9606773b6afa2fdf0bc90a22ee408cfae0", "filename": "gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffeat-cxx1z.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffeat-cxx1z.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffeat-cxx1z.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -380,6 +380,12 @@\n #  error \"__cpp_capture_star_this != 201603\"\n #endif\n \n+#ifndef __cpp_noexcept_function_type\n+#  error \"__cpp_noexcept_function_type\"\n+#elif __cpp_noexcept_function_type != 201510\n+#  error \"__cpp_noexcept_function_type != 201510\"\n+#endif\n+\n #ifdef __has_cpp_attribute\n \n #  if ! __has_cpp_attribute(maybe_unused)"}, {"sha": "62e1322e35ab6fa5350b2a4b10eecd488c9a89db", "filename": "gcc/testsuite/g++.dg/cpp1z/noexcept-type1.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type1.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -0,0 +1,8 @@\n+// Testcase from P0012r1\n+// { dg-options -std=c++1z }\n+\n+void (*p)() throw(int);\n+void (**pp)() noexcept = &p;   // { dg-error \"\" } cannot convert to pointer to noexcept function\n+\n+struct S { typedef void (*p)(); operator p(); };\n+void (*q)() noexcept = S();   // { dg-error \"\" } cannot convert to pointer to noexcept function"}, {"sha": "bcd4d8d613d17e30233f5ba4b53eb47897af93f4", "filename": "gcc/testsuite/g++.dg/cpp1z/noexcept-type11.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type11.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -0,0 +1,3 @@\n+// { dg-options \"-Wall -std=c++14\" }\n+\n+void f(int(*)() noexcept) { }\t// { dg-warning \"mangled\" }"}, {"sha": "39820af136ec4fc9629b950c59791e19b8599c26", "filename": "gcc/testsuite/g++.dg/cpp1z/noexcept-type12.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type12.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -0,0 +1,23 @@\n+// { dg-options -std=c++1z }\n+\n+template <class R, class... A, bool B>\n+void f(R (*)(A...) noexcept(B)) { }\n+\n+template <class R, class... A, bool B>\n+void f2(R (*)(A...) noexcept(B)) { }\n+\n+void g(int);\n+void h(int) noexcept;\n+\n+int main()\n+{\n+  f(g);\n+  f2(h);\n+}\n+\n+// { dg-final { scan-assembler \"_Z1fIvJiELb0EEvPDOT1_EFT_DpT0_E\" } }\n+// { dg-final { scan-assembler \"_Z2f2IvJiELb1EEvPDOT1_EFT_DpT0_E\" } }\n+\n+void f3(void (*)() noexcept) { }\n+\n+// { dg-final { scan-assembler \"_Z2f3PDoFvvE\" } }"}, {"sha": "747bb194c302ead114bfde1833a75ea0c6fa20b4", "filename": "gcc/testsuite/g++.dg/cpp1z/noexcept-type2.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type2.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -0,0 +1,10 @@\n+// Test for function pointer conversion on template arguments.\n+// { dg-options -std=c++1z }\n+\n+template <void (*P)()> struct A { };\n+\n+void f() noexcept { };\n+constexpr void (*p)() noexcept = f;\n+\n+A<f> a;\n+A<p> b;"}, {"sha": "9303da87b8cf5b5618e424c1069b278e35e93334", "filename": "gcc/testsuite/g++.dg/cpp1z/noexcept-type3.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type3.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -0,0 +1,13 @@\n+// Test for overload resolution.\n+// { dg-options -std=c++1z }\n+\n+void f(void (*)() noexcept) = delete;\n+void f(void (*)()) { }\n+void g() {}\n+void h() noexcept {}\n+\n+int main()\n+{\n+  f(g);\n+  f(h);\t\t\t\t// { dg-error \"deleted\" }\n+}"}, {"sha": "621da9341ea38c1fd7796ed1ad3f95ba8b8e02d7", "filename": "gcc/testsuite/g++.dg/cpp1z/noexcept-type4.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type4.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -0,0 +1,16 @@\n+// Test for deduction.\n+// { dg-options -std=c++1z }\n+\n+template <class R, class... A>\n+void f(R (*)(A...));\n+void g(int) noexcept;\n+\n+template <class R, class... A>\n+void h(R (*)(A...) noexcept);\n+void i(int);\n+\n+int main()\n+{\n+  f(g);\n+  h(i);\t\t\t\t// { dg-error \"\" }\n+}"}, {"sha": "9e5d20224e2c6539bf22b2966a4a8c671c624fe8", "filename": "gcc/testsuite/g++.dg/cpp1z/noexcept-type5.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type5.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -0,0 +1,25 @@\n+// Test for composite pointer type.\n+// { dg-options -std=c++1z }\n+\n+typedef void (*P)();\n+typedef void (*NP)() noexcept;\n+\n+void f();\n+void g() noexcept;\n+\n+bool b;\n+\n+template <class T, class U> struct Same;\n+template <class T> struct Same<T,T> { };\n+\n+Same<decltype(b ? &f : &g),P> s;\n+\n+int main()\n+{\n+  P p = 0;\n+  NP np = 0;\n+\n+  p == np;\n+  p != np;\n+  p < np;\n+}"}, {"sha": "50684571b621022b944ddd52659df64b8c7532f2", "filename": "gcc/testsuite/g++.dg/cpp1z/noexcept-type6.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type6.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -0,0 +1,13 @@\n+// Test for lambda conversion.\n+// { dg-options -std=c++1z }\n+\n+void f()\n+{\n+  auto l = []() noexcept { return 0; };\n+  int (*p)() noexcept = l;\n+  int (*q)() = l;\n+\n+  auto l2 = []{ return 0; };\n+  p = l2;\t\t\t// { dg-error \"\" }\n+  q = l2;\n+}"}, {"sha": "1f78114dc74b9b89fa157b6f1f84c0b6f270a500", "filename": "gcc/testsuite/g++.dg/cpp1z/noexcept-type7.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type7.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -0,0 +1,14 @@\n+// Test for static_cast.\n+// { dg-options -std=c++1z }\n+\n+void f()\n+{\n+  typedef void (*P)();\n+  typedef void (*NP)() noexcept;\n+\n+  P p;\n+  NP np;\n+\n+  static_cast<P>(np);\n+  static_cast<NP>(p);\t\t// { dg-error \"\" }\n+}"}, {"sha": "0182e3a31117d70c0959e37640466675b3cd0be0", "filename": "gcc/testsuite/g++.dg/cpp1z/noexcept-type8.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type8.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -0,0 +1,22 @@\n+// Test for exception handling.\n+// { dg-options -std=c++1z }\n+// { dg-do run }\n+\n+void f() {}\n+void g() noexcept {}\n+\n+int main()\n+{\n+  try { throw g; }\n+  catch (void (*)()) { }\n+\n+  try { throw g; }\n+  catch (void (*)() noexcept) { }\n+\n+  try { throw f; }\n+  catch (void (*)()) { }\n+\n+  try { throw f; }\n+  catch (void (*)() noexcept) { __builtin_abort(); }\n+  catch (...) { }\n+}"}, {"sha": "4547c4cc4d3c2bf3f7e049b4e6c1179b85982a62", "filename": "gcc/testsuite/g++.dg/cpp1z/noexcept-type9.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnoexcept-type9.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -0,0 +1,18 @@\n+// Test for PMF template args.\n+// { dg-options -std=c++1z }\n+// { dg-do run }\n+\n+struct A\n+{\n+  void f() noexcept;\n+  void g();\n+};\n+\n+template <void (A::*)()> struct B { };\n+template <void (A::*)() noexcept> struct C { };\n+\n+B<&A::f> b1;\n+B<&A::g> b2;\n+\n+C<&A::f> c1;\n+C<&A::g> c2;\t\t\t// { dg-error \"\" }"}, {"sha": "8107f019eb7ec11b87b9a0ba95756e9a4eb9441e", "filename": "gcc/testsuite/g++.dg/eh/spec2.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec2.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -2,9 +2,9 @@\n \n struct S { void f (void); };\n \n-typedef void f1 (void) throw (int); // { dg-error \"exception\" }\n-typedef void (*f2) (void) throw (int); // { dg-error \"exception\" }\n-typedef void (S::*f3) (void) throw (int); // { dg-error \"exception\" }\n+typedef void f1 (void) throw (int); // { dg-error \"exception\" \"\" { target c++14_down } }\n+typedef void (*f2) (void) throw (int); // { dg-error \"exception\" \"\" { target c++14_down } }\n+typedef void (S::*f3) (void) throw (int); // { dg-error \"exception\" \"\" { target c++14_down } }\n \n void (*f4) (void) throw (int);\n void (S::*f5) (void) throw (int);"}, {"sha": "2a4a989913dee2864c6bc44617b9b40264da2e76", "filename": "gcc/testsuite/g++.old-deja/g++.eh/spec7.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fspec7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fspec7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fspec7.C?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -10,7 +10,7 @@ struct A\n   static void (A::*pmf)() throw ();\n };\n \n-void (A::* A::pmf)() = &A::g;\n+void (A::* A::pmf)() throw() = &A::g;\n \n int main()\n {"}, {"sha": "d029f722ae9e5227118815527a37dc131d3ab2f0", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -1,3 +1,8 @@\n+2016-11-07  Jason Merrill  <jason@redhat.com>\n+\n+\t* demangle.h (enum demangle_component_type): Add\n+\tDEMANGLE_COMPONENT_NOEXCEPT, DEMANGLE_COMPONENT_THROW_SPEC.\n+\n 2016-10-17  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2.h (enum dwarf_calling_convention): Add new DWARF5"}, {"sha": "7a03c204aac90ddfbd70918391e39ca86e44576f", "filename": "include/demangle.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -449,7 +449,9 @@ enum demangle_component_type\n   /* A transaction-safe function type.  */\n   DEMANGLE_COMPONENT_TRANSACTION_SAFE,\n   /* A cloned function.  */\n-  DEMANGLE_COMPONENT_CLONE\n+  DEMANGLE_COMPONENT_CLONE,\n+  DEMANGLE_COMPONENT_NOEXCEPT,\n+  DEMANGLE_COMPONENT_THROW_SPEC\n };\n \n /* Types which are only used internally.  */"}, {"sha": "727ffd39007b0d08de9461c2af2f0d7604192f84", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -1,3 +1,13 @@\n+2016-11-07  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-demangle.c (is_fnqual_component_type): New.\n+\t(d_encoding, d_print_comp_inner, d_print_mod_list): Use it.\n+\t(FNQUAL_COMPONENT_CASE): New.\n+\t(d_make_comp, has_return_type, d_print_comp_inner)\n+\t(d_print_function_type): Use it.\n+\t(next_is_type_qual): New.\n+\t(d_cv_qualifiers, d_print_mod): Handle noexcept and throw-spec.\n+\n 2016-11-02  Mark Wielaard  <mjw@redhat.com>\n \n \t* cplus-dem.c (demangle_signature): Move fall through comment."}, {"sha": "e239155c442f829ed20610e2c90d9a73c4306b07", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 113, "deletions": 68, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -436,6 +436,8 @@ static struct demangle_component *d_operator_name (struct d_info *);\n \n static struct demangle_component *d_special_name (struct d_info *);\n \n+static struct demangle_component *d_parmlist (struct d_info *);\n+\n static int d_call_offset (struct d_info *, int);\n \n static struct demangle_component *d_ctor_dtor_name (struct d_info *);\n@@ -559,6 +561,32 @@ static int d_demangle_callback (const char *, int,\n                                 demangle_callbackref, void *);\n static char *d_demangle (const char *, int, size_t *);\n \n+/* True iff TYPE is a demangling component representing a\n+   function-type-qualifier.  */\n+\n+static int\n+is_fnqual_component_type (enum demangle_component_type type)\n+{\n+  return (type == DEMANGLE_COMPONENT_RESTRICT_THIS\n+\t  || type == DEMANGLE_COMPONENT_VOLATILE_THIS\n+\t  || type == DEMANGLE_COMPONENT_CONST_THIS\n+\t  || type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS\n+\t  || type == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n+\t  || type == DEMANGLE_COMPONENT_NOEXCEPT\n+\t  || type == DEMANGLE_COMPONENT_THROW_SPEC\n+\t  || type == DEMANGLE_COMPONENT_REFERENCE_THIS);\n+}\n+\n+#define FNQUAL_COMPONENT_CASE\t\t\t\t\\\n+    case DEMANGLE_COMPONENT_RESTRICT_THIS:\t\t\\\n+    case DEMANGLE_COMPONENT_VOLATILE_THIS:\t\t\\\n+    case DEMANGLE_COMPONENT_CONST_THIS:\t\t\t\\\n+    case DEMANGLE_COMPONENT_REFERENCE_THIS:\t\t\\\n+    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\t\\\n+    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\t\t\\\n+    case DEMANGLE_COMPONENT_NOEXCEPT:\t\t\t\\\n+    case DEMANGLE_COMPONENT_THROW_SPEC\n+\n #ifdef CP_DEMANGLE_DEBUG\n \n static void\n@@ -984,14 +1012,9 @@ d_make_comp (struct d_info *di, enum demangle_component_type type,\n     case DEMANGLE_COMPONENT_RESTRICT:\n     case DEMANGLE_COMPONENT_VOLATILE:\n     case DEMANGLE_COMPONENT_CONST:\n-    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n-    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n-    case DEMANGLE_COMPONENT_CONST_THIS:\n-    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n-    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n-    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n     case DEMANGLE_COMPONENT_ARGLIST:\n     case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n+    FNQUAL_COMPONENT_CASE:\n       break;\n \n       /* Other types should not be seen here.  */\n@@ -1225,12 +1248,7 @@ has_return_type (struct demangle_component *dc)\n       return 0;\n     case DEMANGLE_COMPONENT_TEMPLATE:\n       return ! is_ctor_dtor_or_conversion (d_left (dc));\n-    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n-    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n-    case DEMANGLE_COMPONENT_CONST_THIS:\n-    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n-    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n-    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n+    FNQUAL_COMPONENT_CASE:\n       return has_return_type (d_left (dc));\n     }\n }\n@@ -1287,26 +1305,20 @@ d_encoding (struct d_info *di, int top_level)\n \t  while (dc->type == DEMANGLE_COMPONENT_RESTRICT_THIS\n \t\t || dc->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n \t\t || dc->type == DEMANGLE_COMPONENT_CONST_THIS\n-\t\t || dc->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n \t\t || dc->type == DEMANGLE_COMPONENT_REFERENCE_THIS\n \t\t || dc->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)\n \t    dc = d_left (dc);\n \n \t  /* If the top level is a DEMANGLE_COMPONENT_LOCAL_NAME, then\n-\t     there may be CV-qualifiers on its right argument which\n+\t     there may be function-qualifiers on its right argument which\n \t     really apply here; this happens when parsing a class\n \t     which is local to a function.  */\n \t  if (dc->type == DEMANGLE_COMPONENT_LOCAL_NAME)\n \t    {\n \t      struct demangle_component *dcr;\n \n \t      dcr = d_right (dc);\n-\t      while (dcr->type == DEMANGLE_COMPONENT_RESTRICT_THIS\n-\t\t     || dcr->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n-\t\t     || dcr->type == DEMANGLE_COMPONENT_CONST_THIS\n-\t\t     || dcr->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n-\t\t     || dcr->type == DEMANGLE_COMPONENT_REFERENCE_THIS\n-\t\t     || dcr->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)\n+\t      while (is_fnqual_component_type (dcr->type))\n \t\tdcr = d_left (dcr);\n \t      dc->u.s_binary.right = dcr;\n \t    }\n@@ -2239,6 +2251,24 @@ d_ctor_dtor_name (struct d_info *di)\n     }\n }\n \n+/* True iff we're looking at an order-insensitive type-qualifier, including\n+   function-type-qualifiers.  */\n+\n+static int\n+next_is_type_qual (struct d_info *di)\n+{\n+  char peek = d_peek_char (di);\n+  if (peek == 'r' || peek == 'V' || peek == 'K')\n+    return 1;\n+  if (peek == 'D')\n+    {\n+      peek = d_peek_next_char (di);\n+      if (peek == 'x' || peek == 'o' || peek == 'O' || peek == 'w')\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n /* <type> ::= <builtin-type>\n           ::= <function-type>\n           ::= <class-enum-type>\n@@ -2324,9 +2354,7 @@ cplus_demangle_type (struct d_info *di)\n      __vector, and it treats it as order-sensitive when mangling\n      names.  */\n \n-  peek = d_peek_char (di);\n-  if (peek == 'r' || peek == 'V' || peek == 'K'\n-      || (peek == 'D' && d_peek_next_char (di) == 'x'))\n+  if (next_is_type_qual (di))\n     {\n       struct demangle_component **pret;\n \n@@ -2361,6 +2389,7 @@ cplus_demangle_type (struct d_info *di)\n \n   can_subst = 1;\n \n+  peek = d_peek_char (di);\n   switch (peek)\n     {\n     case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':\n@@ -2648,10 +2677,10 @@ d_cv_qualifiers (struct d_info *di,\n \n   pstart = pret;\n   peek = d_peek_char (di);\n-  while (peek == 'r' || peek == 'V' || peek == 'K'\n-\t || (peek == 'D' && d_peek_next_char (di) == 'x'))\n+  while (next_is_type_qual (di))\n     {\n       enum demangle_component_type t;\n+      struct demangle_component *right = NULL;\n \n       d_advance (di, 1);\n       if (peek == 'r')\n@@ -2677,12 +2706,41 @@ d_cv_qualifiers (struct d_info *di,\n \t}\n       else\n \t{\n-\t  t = DEMANGLE_COMPONENT_TRANSACTION_SAFE;\n-\t  di->expansion += sizeof \"transaction_safe\";\n-\t  d_advance (di, 1);\n+\t  peek = d_next_char (di);\n+\t  if (peek == 'x')\n+\t    {\n+\t      t = DEMANGLE_COMPONENT_TRANSACTION_SAFE;\n+\t      di->expansion += sizeof \"transaction_safe\";\n+\t    }\n+\t  else if (peek == 'o'\n+\t\t   || peek == 'O')\n+\t    {\n+\t      t = DEMANGLE_COMPONENT_NOEXCEPT;\n+\t      di->expansion += sizeof \"noexcept\";\n+\t      if (peek == 'O')\n+\t\t{\n+\t\t  right = d_expression (di);\n+\t\t  if (right == NULL)\n+\t\t    return NULL;\n+\t\t  if (! d_check_char (di, 'E'))\n+\t\t    return NULL;\n+\t\t}\n+\t    }\n+\t  else if (peek == 'w')\n+\t    {\n+\t      t = DEMANGLE_COMPONENT_THROW_SPEC;\n+\t      di->expansion += sizeof \"throw\";\n+\t      right = d_parmlist (di);\n+\t      if (right == NULL)\n+\t\treturn NULL;\n+\t      if (! d_check_char (di, 'E'))\n+\t\treturn NULL;\n+\t    }\n+\t  else\n+\t    return NULL;\n \t}\n \n-      *pret = d_make_comp (di, t, NULL, NULL);\n+      *pret = d_make_comp (di, t, NULL, right);\n       if (*pret == NULL)\n \treturn NULL;\n       pret = &d_left (*pret);\n@@ -3973,6 +4031,8 @@ d_count_templates_scopes (int *num_templates, int *num_scopes,\n     case DEMANGLE_COMPONENT_REFERENCE_THIS:\n     case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n     case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n+    case DEMANGLE_COMPONENT_NOEXCEPT:\n+    case DEMANGLE_COMPONENT_THROW_SPEC:\n     case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n     case DEMANGLE_COMPONENT_POINTER:\n     case DEMANGLE_COMPONENT_COMPLEX:\n@@ -4587,12 +4647,7 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n \t    adpm[i].templates = dpi->templates;\n \t    ++i;\n \n-\t    if (typed_name->type != DEMANGLE_COMPONENT_RESTRICT_THIS\n-\t\t&& typed_name->type != DEMANGLE_COMPONENT_VOLATILE_THIS\n-\t\t&& typed_name->type != DEMANGLE_COMPONENT_CONST_THIS\n-\t\t&& typed_name->type != DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS\n-\t\t&& typed_name->type != DEMANGLE_COMPONENT_TRANSACTION_SAFE\n-\t\t&& typed_name->type != DEMANGLE_COMPONENT_REFERENCE_THIS)\n+\t    if (!is_fnqual_component_type (typed_name->type))\n \t      break;\n \n \t    typed_name = d_left (typed_name);\n@@ -4629,13 +4684,7 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n \t\td_print_error (dpi);\n \t\treturn;\n \t      }\n-\t    while (local_name->type == DEMANGLE_COMPONENT_RESTRICT_THIS\n-\t\t   || local_name->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n-\t\t   || local_name->type == DEMANGLE_COMPONENT_CONST_THIS\n-\t\t   || local_name->type == DEMANGLE_COMPONENT_REFERENCE_THIS\n-\t\t   || local_name->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n-\t\t   || (local_name->type\n-\t\t       == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))\n+\t    while (is_fnqual_component_type (local_name->type))\n \t      {\n \t\tif (i >= sizeof adpm / sizeof adpm[0])\n \t\t  {\n@@ -4960,16 +5009,11 @@ d_print_comp_inner (struct d_print_info *dpi, int options,\n       }\n       /* Fall through.  */\n \n-    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n-    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n-    case DEMANGLE_COMPONENT_CONST_THIS:\n-    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n-    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n     case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n     case DEMANGLE_COMPONENT_POINTER:\n     case DEMANGLE_COMPONENT_COMPLEX:\n     case DEMANGLE_COMPONENT_IMAGINARY:\n-    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n+    FNQUAL_COMPONENT_CASE:\n     modifier:\n       {\n \t/* We keep a list of modifiers on the stack.  */\n@@ -5674,13 +5718,7 @@ d_print_mod_list (struct d_print_info *dpi, int options,\n \n   if (mods->printed\n       || (! suffix\n-\t  && (mods->mod->type == DEMANGLE_COMPONENT_RESTRICT_THIS\n-\t      || mods->mod->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n-\t      || mods->mod->type == DEMANGLE_COMPONENT_CONST_THIS\n-\t      || mods->mod->type == DEMANGLE_COMPONENT_REFERENCE_THIS\n-\t      || mods->mod->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n-\t      || (mods->mod->type\n-\t\t  == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))))\n+\t  && (is_fnqual_component_type (mods->mod->type))))\n     {\n       d_print_mod_list (dpi, options, mods->next, suffix);\n       return;\n@@ -5733,12 +5771,7 @@ d_print_mod_list (struct d_print_info *dpi, int options,\n \t  dc = dc->u.s_unary_num.sub;\n \t}\n \n-      while (dc->type == DEMANGLE_COMPONENT_RESTRICT_THIS\n-\t     || dc->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n-\t     || dc->type == DEMANGLE_COMPONENT_CONST_THIS\n-\t     || dc->type == DEMANGLE_COMPONENT_REFERENCE_THIS\n-\t     || dc->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n-\t     || dc->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)\n+      while (is_fnqual_component_type (dc->type))\n \tdc = d_left (dc);\n \n       d_print_comp (dpi, options, dc);\n@@ -5777,6 +5810,24 @@ d_print_mod (struct d_print_info *dpi, int options,\n     case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n       d_append_string (dpi, \" transaction_safe\");\n       return;\n+    case DEMANGLE_COMPONENT_NOEXCEPT:\n+      d_append_string (dpi, \" noexcept\");\n+      if (d_right (mod))\n+\t{\n+\t  d_append_char (dpi, '(');\n+\t  d_print_comp (dpi, options, d_right (mod));\n+\t  d_append_char (dpi, ')');\n+\t}\n+      return;\n+    case DEMANGLE_COMPONENT_THROW_SPEC:\n+      d_append_string (dpi, \" throw\");\n+      if (d_right (mod))\n+\t{\n+\t  d_append_char (dpi, '(');\n+\t  d_print_comp (dpi, options, d_right (mod));\n+\t  d_append_char (dpi, ')');\n+\t}\n+      return;\n     case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n       d_append_char (dpi, ' ');\n       d_print_comp (dpi, options, d_right (mod));\n@@ -5864,12 +5915,7 @@ d_print_function_type (struct d_print_info *dpi, int options,\n \t  need_space = 1;\n \t  need_paren = 1;\n \t  break;\n-\tcase DEMANGLE_COMPONENT_RESTRICT_THIS:\n-\tcase DEMANGLE_COMPONENT_VOLATILE_THIS:\n-\tcase DEMANGLE_COMPONENT_CONST_THIS:\n-\tcase DEMANGLE_COMPONENT_REFERENCE_THIS:\n-\tcase DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n-\tcase DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n+\tFNQUAL_COMPONENT_CASE:\n \t  break;\n \tdefault:\n \t  break;\n@@ -6411,7 +6457,6 @@ is_ctor_or_dtor (const char *mangled,\n \t  case DEMANGLE_COMPONENT_CONST_THIS:\n \t  case DEMANGLE_COMPONENT_REFERENCE_THIS:\n \t  case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n-\t  case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n \t  default:\n \t    dc = NULL;\n \t    break;"}, {"sha": "5badc3e58493bfd894b0250c84f8c4bc35dbabfd", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -4596,3 +4596,13 @@ __10%0__S4_0T0T0\n # Inheriting constructor\n _ZN1DCI11BEi\n D::B(int)\n+\n+# exception-specification (C++17)\n+_Z1fIvJiELb0EEvPDOT1_EFT_DpT0_E\n+void f<void, int, false>(void (*)(int) noexcept(false))\n+\n+_Z1fIvJiELb0EEvPDoFT_DpT0_E\n+void f<void, int, false>(void (*)(int) noexcept)\n+\n+_Z1fIvJiELb0EEvPDwiEFT_DpT0_E\n+void f<void, int, false>(void (*)(int) throw(int))"}, {"sha": "61dafba43e9b6aa36bdcd5bd9169039dcace350f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -1,3 +1,14 @@\n+2016-11-07  Jason Merrill  <jason@redhat.com>\n+\n+\t* include/bits/c++config (_GLIBCXX_NOEXCEPT_PARM)\n+\t(_GLIBCXX_NOEXCEPT_QUAL): New.\n+\t* include/std/type_traits (is_function): Use them.\n+\t* libsubc++/new (launder): Likewise.\n+\t* libsupc++/cxxabi.h (__pbase_type_info::__masks): Add\n+\t__noexcept_mask.\n+\t* libsupc++/pbase_type_info.cc (__do_catch): Handle function\n+\tpointer conversion.\n+\n 2016-11-07  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* config/abi/pre/gnu-versioned-namespace.ver: Export C++17 new of"}, {"sha": "8a27d14f9515b219a97c1471618088d7c1ec2992", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -146,6 +146,14 @@\n # endif\n #endif\n \n+#if __cpp_noexcept_function_type\n+#define _GLIBCXX_NOEXCEPT_PARM , bool _N\n+#define _GLIBCXX_NOEXCEPT_QUAL noexcept (_N)\n+#else\n+#define _GLIBCXX_NOEXCEPT_PARM\n+#define _GLIBCXX_NOEXCEPT_QUAL\n+#endif\n+\n // Macro for extern template, ie controlling template linkage via use\n // of extern keyword on template declaration. As documented in the g++\n // manual, it inhibits all implicit instantiations and is used"}, {"sha": "e5f2bbaf745f4c87980075618c64e7e96f533e0f", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -458,100 +458,100 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct is_function\n     : public false_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...)>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes...) _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) &>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes...) & _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) &&>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes...) && _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......)>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes......) _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) &>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes......) & _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) &&>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes......) && _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) const>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes...) const _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) const &>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes...) const & _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) const &&>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes...) const && _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) const>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes......) const _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) const &>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes......) const & _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) const &&>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes......) const && _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) volatile>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes...) volatile _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) volatile &>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes...) volatile & _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) volatile &&>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes...) volatile && _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) volatile>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes......) volatile _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) volatile &>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes......) volatile & _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) volatile &&>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes......) volatile && _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) const volatile>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes...) const volatile _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) const volatile &>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes...) const volatile & _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes...) const volatile &&>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes...) const volatile && _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) const volatile>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes......) const volatile _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) const volatile &>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes......) const volatile & _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n-  template<typename _Res, typename... _ArgTypes>\n-    struct is_function<_Res(_ArgTypes......) const volatile &&>\n+  template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>\n+    struct is_function<_Res(_ArgTypes......) const volatile && _GLIBCXX_NOEXCEPT_QUAL>\n     : public true_type { };\n \n #define __cpp_lib_is_null_pointer 201309"}, {"sha": "7f1bd996a352c890509a84c42b8358121b4e8304", "filename": "libstdc++-v3/libsupc++/cxxabi.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -279,7 +279,8 @@ namespace __cxxabiv1\n \t__restrict_mask = 0x4,\n \t__incomplete_mask = 0x8,\n \t__incomplete_class_mask = 0x10,\n-\t__transaction_safe_mask = 0x20\n+\t__transaction_safe_mask = 0x20,\n+\t__noexcept_mask = 0x40\n       };\n \n   protected:"}, {"sha": "1e59649381512e66d942629665759e90241f6693", "filename": "libstdc++-v3/libsupc++/new", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -197,10 +197,10 @@ namespace std\n   // The program is ill-formed if T is a function type or\n   // (possibly cv-qualified) void.\n \n-  template<typename _Ret, typename... _Args>\n-    void launder(_Ret (*)(_Args...)) = delete;\n-  template<typename _Ret, typename... _Args>\n-    void launder(_Ret (*)(_Args......)) = delete;\n+  template<typename _Ret, typename... _Args _GLIBCXX_NOEXCEPT_PARM>\n+    void launder(_Ret (*)(_Args...) _GLIBCXX_NOEXCEPT_QUAL) = delete;\n+  template<typename _Ret, typename... _Args _GLIBCXX_NOEXCEPT_PARM>\n+    void launder(_Ret (*)(_Args......) _GLIBCXX_NOEXCEPT_QUAL) = delete;\n \n   void launder(void*) = delete;\n   void launder(const void*) = delete;"}, {"sha": "b2b9c09009788835aec5ae6a192d6f5964d0621e", "filename": "libstdc++-v3/libsupc++/pbase_type_info.cc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpbase_type_info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpbase_type_info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpbase_type_info.cc?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -80,12 +80,13 @@ __do_catch (const type_info *thr_type,\n \n   unsigned tflags = thrown_type->__flags;\n \n-  bool throw_tx = (tflags & __transaction_safe_mask);\n-  bool catch_tx = (__flags & __transaction_safe_mask);\n-  if (throw_tx && !catch_tx)\n-    /* Catch can perform a transaction-safety conversion.  */\n-    tflags &= ~__transaction_safe_mask;\n-  if (catch_tx && !throw_tx)\n+  const unsigned fqual_mask = __transaction_safe_mask|__noexcept_mask;\n+  unsigned throw_fqual = (tflags & fqual_mask);\n+  unsigned catch_fqual = (__flags & fqual_mask);\n+  if (throw_fqual & ~catch_fqual)\n+    /* Catch can perform a function pointer conversion.  */\n+    tflags &= catch_fqual;\n+  if (catch_fqual & ~throw_fqual)\n     /* But not the reverse.  */\n     return false;\n   "}, {"sha": "15cebed38f8a464b2da71574f20d85916b10c363", "filename": "libstdc++-v3/testsuite/ext/profile/mutex_extensions_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fmutex_extensions_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51dc660315ef83dcb907f3bd3a0a56abb9efed7a/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fmutex_extensions_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fprofile%2Fmutex_extensions_neg.cc?ref=51dc660315ef83dcb907f3bd3a0a56abb9efed7a", "patch": "@@ -25,7 +25,7 @@\n \n #include <vector>\n \n-// { dg-error \"multiple inlined namespaces\" \"\" { target *-*-* } 342 }\n+// { dg-error \"multiple inlined namespaces\" \"\" { target *-*-* } 350 }\n \n // \"template argument 1 is invalid\"\n // { dg-prune-output \"tuple:993\" }"}]}