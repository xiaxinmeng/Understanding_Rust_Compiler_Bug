{"sha": "9713daa015b807a9ffd349f3698cee7acbbaed23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcxM2RhYTAxNWI4MDdhOWZmZDM0OWYzNjk4Y2VlN2FjYmJhZWQyMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-11-21T15:52:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-11-21T15:52:09Z"}, "message": "Handle sibcalls with aggregate returns\n\nWe treated this g as a sibling call to f:\n\n      int f (int);\n      int g (void) { return f (1); }\n\nbut not this one:\n\n      struct s { int i; };\n      struct s f (int);\n      struct s g (void) { return f (1); }\n\nWe treated them both as sibcalls on x86 before the first patch for PR36326,\nso I suppose this is a regression of sorts from 4.3.\n\nThe patch allows function returns to be local aggregate variables as well\nas gimple registers.\n\ngcc/\n\t* tree-tailcall.c (process_assignment): Simplify the check for\n\ta valid copy, allowing the source to be a local variable as\n\twell as an SSA name.\n\t(find_tail_calls): Allow copies between local variables to follow\n\tthe call.  Allow the result to be stored in any local variable,\n\teven if it's an aggregate.\n\t(eliminate_tail_call): Check whether the result is an SSA name\n\tbefore updating its SSA_NAME_DEF_STMT.\n\ngcc/testsuite/\n\t* gcc.dg/tree-ssa/tailcall-7.c: New test.\n\nFrom-SVN: r242668", "tree": {"sha": "e99ef73d3ba4d9ddf7188f90a7bc54817d66c427", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e99ef73d3ba4d9ddf7188f90a7bc54817d66c427"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9713daa015b807a9ffd349f3698cee7acbbaed23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9713daa015b807a9ffd349f3698cee7acbbaed23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9713daa015b807a9ffd349f3698cee7acbbaed23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9713daa015b807a9ffd349f3698cee7acbbaed23/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "67b5d0b2fe8cdb72dfc56644e42c28f453cb2f76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67b5d0b2fe8cdb72dfc56644e42c28f453cb2f76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67b5d0b2fe8cdb72dfc56644e42c28f453cb2f76"}], "stats": {"total": 132, "additions": 121, "deletions": 11}, "files": [{"sha": "56fa35b269152833505f3e6be50ba9d4a847fa87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9713daa015b807a9ffd349f3698cee7acbbaed23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9713daa015b807a9ffd349f3698cee7acbbaed23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9713daa015b807a9ffd349f3698cee7acbbaed23", "patch": "@@ -1,3 +1,14 @@\n+2016-11-21  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-tailcall.c (process_assignment): Simplify the check for\n+\ta valid copy, allowing the source to be a local variable as\n+\twell as an SSA name.\n+\t(find_tail_calls): Allow copies between local variables to follow\n+\tthe call.  Allow the result to be stored in any local variable,\n+\teven if it's an aggregate.\n+\t(eliminate_tail_call): Check whether the result is an SSA name\n+\tbefore updating its SSA_NAME_DEF_STMT.\n+\n 2016-11-21  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR preprocessor/78324"}, {"sha": "828c941265ea9c40ebcbf3f25d24b04c58545064", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9713daa015b807a9ffd349f3698cee7acbbaed23/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9713daa015b807a9ffd349f3698cee7acbbaed23/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9713daa015b807a9ffd349f3698cee7acbbaed23", "patch": "@@ -1,3 +1,7 @@\n+2016-11-21  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/tree-ssa/tailcall-7.c: New test.\n+\n 2016-11-21  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR preprocessor/78324"}, {"sha": "eabf1a86dd33f12a38f77d8626ea14f2f722ce17", "filename": "gcc/testsuite/gcc.dg/tree-ssa/tailcall-7.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9713daa015b807a9ffd349f3698cee7acbbaed23/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ftailcall-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9713daa015b807a9ffd349f3698cee7acbbaed23/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ftailcall-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ftailcall-7.c?ref=9713daa015b807a9ffd349f3698cee7acbbaed23", "patch": "@@ -0,0 +1,89 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-tailc-details\" } */\n+\n+struct s { int x; };\n+struct s f (int);\n+struct s global;\n+void callit (void (*) (void));\n+\n+/* Tail call.  */\n+void\n+g1 (void)\n+{\n+  f (1);\n+}\n+\n+/* Not a tail call.  */\n+void\n+g2 (void)\n+{\n+  global = f (2);\n+}\n+\n+/* Not a tail call.  */\n+void\n+g3 (struct s *ptr)\n+{\n+  *ptr = f (3);\n+}\n+\n+/* Tail call.  */\n+struct s\n+g4 (struct s param)\n+{\n+  param = f (4);\n+  return param;\n+}\n+\n+/* Tail call.  */\n+struct s\n+g5 (void)\n+{\n+  struct s local = f (5);\n+  return local;\n+}\n+\n+/* Tail call.  */\n+struct s\n+g6 (void)\n+{\n+  return f (6);\n+}\n+\n+/* Not a tail call.  */\n+struct s\n+g7 (void)\n+{\n+  struct s local = f (7);\n+  global = local;\n+  return local;\n+}\n+\n+/* Not a tail call.  */\n+struct s\n+g8 (struct s *ptr)\n+{\n+  struct s local = f (8);\n+  *ptr = local;\n+  return local;\n+}\n+\n+/* Not a tail call.  */\n+int\n+g9 (struct s param)\n+{\n+  void inner (void) { param = f (9); }\n+  callit (inner);\n+  return 9;\n+}\n+\n+/* Tail call.  */\n+int\n+g10 (int param)\n+{\n+  void inner (void) { f (param); }\n+  callit (inner);\n+  return 10;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Found tail call\" 5 \"tailc\" } } */"}, {"sha": "f97541d35a544ab83ebe0de5aa13fe419e614e71", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9713daa015b807a9ffd349f3698cee7acbbaed23/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9713daa015b807a9ffd349f3698cee7acbbaed23/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=9713daa015b807a9ffd349f3698cee7acbbaed23", "patch": "@@ -269,7 +269,7 @@ process_assignment (gassign *stmt, gimple_stmt_iterator call, tree *m,\n      conversions that can never produce extra code between the function\n      call and the function return.  */\n   if ((rhs_class == GIMPLE_SINGLE_RHS || gimple_assign_cast_p (stmt))\n-      && (TREE_CODE (src_var) == SSA_NAME))\n+      && src_var == *ass_var)\n     {\n       /* Reject a tailcall if the type conversion might need\n \t additional code.  */\n@@ -287,9 +287,6 @@ process_assignment (gassign *stmt, gimple_stmt_iterator call, tree *m,\n \t    return false;\n \t}\n \n-      if (src_var != *ass_var)\n-\treturn false;\n-\n       *ass_var = dest;\n       return true;\n     }\n@@ -428,6 +425,13 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \t  break;\n \t}\n \n+      /* Allow simple copies between local variables, even if they're\n+\t aggregates.  */\n+      if (is_gimple_assign (stmt)\n+\t  && auto_var_in_fn_p (gimple_assign_lhs (stmt), cfun->decl)\n+\t  && auto_var_in_fn_p (gimple_assign_rhs1 (stmt), cfun->decl))\n+\tcontinue;\n+\n       /* If the statement references memory or volatile operands, fail.  */\n       if (gimple_references_memory_p (stmt)\n \t  || gimple_has_volatile_ops (stmt))\n@@ -444,18 +448,20 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n       return;\n     }\n \n-  /* If the LHS of our call is not just a simple register, we can't\n-     transform this into a tail or sibling call.  This situation happens,\n-     in (e.g.) \"*p = foo()\" where foo returns a struct.  In this case\n-     we won't have a temporary here, but we need to carry out the side\n-     effect anyway, so tailcall is impossible.\n+  /* If the LHS of our call is not just a simple register or local\n+     variable, we can't transform this into a tail or sibling call.\n+     This situation happens, in (e.g.) \"*p = foo()\" where foo returns a\n+     struct.  In this case we won't have a temporary here, but we need\n+     to carry out the side effect anyway, so tailcall is impossible.\n \n      ??? In some situations (when the struct is returned in memory via\n      invisible argument) we could deal with this, e.g. by passing 'p'\n      itself as that argument to foo, but it's too early to do this here,\n      and expand_call() will not handle it anyway.  If it ever can, then\n      we need to revisit this here, to allow that situation.  */\n-  if (ass_var && !is_gimple_reg (ass_var))\n+  if (ass_var\n+      && !is_gimple_reg (ass_var)\n+      && !auto_var_in_fn_p (ass_var, cfun->decl))\n     return;\n \n   /* We found the call, check whether it is suitable.  */\n@@ -888,7 +894,7 @@ eliminate_tail_call (struct tailcall *t)\n \n   call = gsi_stmt (t->call_gsi);\n   rslt = gimple_call_lhs (call);\n-  if (rslt != NULL_TREE)\n+  if (rslt != NULL_TREE && TREE_CODE (rslt) == SSA_NAME)\n     {\n       /* Result of the call will no longer be defined.  So adjust the\n \t SSA_NAME_DEF_STMT accordingly.  */"}]}