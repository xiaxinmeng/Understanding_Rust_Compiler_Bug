{"sha": "25f3d2f4b71199dfce42654e6a7669800ac5600a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVmM2QyZjRiNzExOTlkZmNlNDI2NTRlNmE3NjY5ODAwYWM1NjAwYQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "1998-11-23T12:03:46Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "1998-11-23T12:03:46Z"}, "message": "method.c (process_overload_item): Add call to build_mangled_C9x_name for intTI_type_nodes.\n\n\ufffd\n1998-11-23  Benjamin Kosnik  <bkoz@cygnus.com>\n        * method.c (process_overload_item): Add call to\n        build_mangled_C9x_name for intTI_type_nodes.\n        (build_mangled_C9x_name): Add prototype, define.\n        * decl.c (init_decl_processing): Add names for\n        TImode_type_node.\n\nFrom-SVN: r23798", "tree": {"sha": "9e5a41236328c8f101a5870b96199ae72849807c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e5a41236328c8f101a5870b96199ae72849807c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25f3d2f4b71199dfce42654e6a7669800ac5600a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25f3d2f4b71199dfce42654e6a7669800ac5600a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25f3d2f4b71199dfce42654e6a7669800ac5600a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25f3d2f4b71199dfce42654e6a7669800ac5600a/comments", "author": null, "committer": null, "parents": [{"sha": "5ebcdddbc8941ee2f8be1a16e3dc4f75b1666965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ebcdddbc8941ee2f8be1a16e3dc4f75b1666965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ebcdddbc8941ee2f8be1a16e3dc4f75b1666965"}], "stats": {"total": 53, "additions": 46, "deletions": 7}, "files": [{"sha": "3deaff79727e4be67cfed87642af90991f43c021", "filename": "gcc/cp/method.c", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25f3d2f4b71199dfce42654e6a7669800ac5600a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25f3d2f4b71199dfce42654e6a7669800ac5600a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=25f3d2f4b71199dfce42654e6a7669800ac5600a", "patch": "@@ -80,6 +80,7 @@ static int check_ktype PROTO((tree, int));\n static int issue_ktype PROTO((tree));\n static void build_overload_scope_ref PROTO((tree));\n static void build_mangled_template_parm_index PROTO((char *, tree));\n+static void build_mangled_C9x_name PROTO((int));\n static int is_back_referenceable_type PROTO((tree));\n static int check_btype PROTO((tree));\n static void build_mangled_name_for_type PROTO((tree));\n@@ -623,6 +624,41 @@ build_mangled_template_parm_index (s, index)\n }\n \n \n+/* Mangling for C9X integer types (and Cygnus extensions for 128-bit\n+   and other types) is based on the letter \"I\" followed by the hex\n+   representations of the bitsize for the type in question. For\n+   encodings that result in larger than two digits, a leading and\n+   trailing underscore is added.\n+\n+   Thus:\n+   int1_t   = 001 = I01\n+   int8_t   = 008 = I08 \n+   int16_t  = 010 = I10\n+   int24_t  = 018 = I18\n+   int32_t  = 020 = I20\n+   int64_t  = 040 = I40\n+   int80_t  = 050 = I50\n+   int128_t = 080 = I80\n+   int256_t = 100 = I_100_\n+   int512_t = 200 = I_200_\n+\n+   Given an integer in decimal format, mangle according to this scheme. */\n+\n+static void\n+build_mangled_C9x_name (bits)\n+     int bits;\n+{\n+  char mangled[10] = \"\";\n+\n+  if (bits > 255)\n+    sprintf (mangled, \"I_%x_\", bits);\n+  else\n+    sprintf (mangled, \"I%.2x\", bits);\n+\n+  OB_PUTCP (mangled);\n+}\n+\n+\n static void\n build_overload_value (type, value, in_template)\n      tree type, value;\n@@ -1367,15 +1403,18 @@ process_overload_item (parmtype, extra_Gcode)\n \t       || parmtype == long_long_unsigned_type_node\n \t       || parmtype == java_long_type_node)\n         OB_PUTC ('x');\n-#if 0\n-      /* it would seem there is no way to enter these in source code,\n-         yet.  (mrs) */\n-      else if (parmtype == long_long_long_integer_type_node\n-          || parmtype == long_long_long_unsigned_type_node)\n-        OB_PUTC ('q');\n-#endif\n       else if (parmtype == java_boolean_type_node)\n \tOB_PUTC ('b');\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+      else if (parmtype == intTI_type_node \n+\t       || parmtype == unsigned_intTI_type_node)\n+\t{\n+\t  /* Should just check a flag here instead of specific\n+\t   *_type_nodes, because all C9x types could use this. */\n+\t  int bits = TREE_INT_CST_LOW (TYPE_SIZE (parmtype));\n+\t  build_mangled_C9x_name (bits);\n+\t}\n+#endif\n       else\n         my_friendly_abort (73);\n       break;"}]}