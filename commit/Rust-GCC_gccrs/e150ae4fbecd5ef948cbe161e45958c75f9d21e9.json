{"sha": "e150ae4fbecd5ef948cbe161e45958c75f9d21e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE1MGFlNGZiZWNkNWVmOTQ4Y2JlMTYxZTQ1OTU4Yzc1ZjlkMjFlOQ==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-03-03T14:38:13Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-03-03T14:38:13Z"}, "message": "(pa_adjust_cost): Replace, the function of Mar 2 was an old version.\n\n(output_fp_move_double): Use %r syntax for registers.\n\nFrom-SVN: r3621", "tree": {"sha": "8168340544667cba5edeb500c7fdcdd7e36b5237", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8168340544667cba5edeb500c7fdcdd7e36b5237"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e150ae4fbecd5ef948cbe161e45958c75f9d21e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e150ae4fbecd5ef948cbe161e45958c75f9d21e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e150ae4fbecd5ef948cbe161e45958c75f9d21e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e150ae4fbecd5ef948cbe161e45958c75f9d21e9/comments", "author": null, "committer": null, "parents": [{"sha": "d36d70cc52462e9d4fb0aa8c61a107bad31b1295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d36d70cc52462e9d4fb0aa8c61a107bad31b1295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d36d70cc52462e9d4fb0aa8c61a107bad31b1295"}], "stats": {"total": 58, "additions": 38, "deletions": 20}, "files": [{"sha": "011ae64dc0568e03693200b36d3150f26fdc8936", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e150ae4fbecd5ef948cbe161e45958c75f9d21e9/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e150ae4fbecd5ef948cbe161e45958c75f9d21e9/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=e150ae4fbecd5ef948cbe161e45958c75f9d21e9", "patch": "@@ -1129,7 +1129,7 @@ output_fp_move_double (operands)\n \t  xoperands[1] = operands[1];\n \t  xoperands[2] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n \t  output_asm_insn\n-\t    (\"stw %1,-16(0,30)\\n\\tstw %2,-12(0,30)\\n\\tfldds -16(0,30),%0\",\n+\t    (\"stw %1,-16(0,%%r30)\\n\\tstw %2,-12(0,%%r30)\\n\\tfldds -16(0,%%r30),%0\",\n \t\t\t   xoperands);\n \t}\n       else \n@@ -1144,7 +1144,7 @@ output_fp_move_double (operands)\n \t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n \t  xoperands[0] = operands[0];\n \t  output_asm_insn\n-\t    (\"fstds %2,-16(0,30)\\n\\tldw -12(0,30),%1\\n\\tldw -16(0,30),%0\",\n+\t    (\"fstds %2,-16(0,%%r30)\\n\\tldw -12(0,%%r30),%1\\n\\tldw -16(0,%%r30),%0\",\n \t     xoperands);\n \t}\n       else\n@@ -2071,9 +2071,8 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n      rtx dep_insn;\n      int cost;\n {\n-  /* If the dependence is an anti-dependence, there is no cost.  For an\n-     output dependence, there is sometimes a cost, but it doesn't seem\n-     worth handling those few cases.  */\n+  if (! recog_memoized (insn))\n+    return 0;\n \n   if (REG_NOTE_KIND (link) == 0)\n     {\n@@ -2082,16 +2081,24 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \n       if (get_attr_type (insn) == TYPE_FPSTORE)\n \t{\n-\t  if (GET_CODE (PATTERN (insn)) != SET\n-\t      || GET_CODE (PATTERN (dep_insn)) != SET)\n+\t  rtx pat = PATTERN (insn);\n+\t  rtx dep_pat = PATTERN (dep_insn);\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    {\n+\t      /* This happens for the fstXs,mb patterns.  */\n+\t      pat = XVECEXP (pat, 0, 0);\n+\t    }\n+\t  if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)\n \t    /* If this happens, we have to extend this to schedule\n-\t       optimally.  */\n-\t    abort();\n+\t       optimally.  Return 0 for now.  */\n+\t  return 0;\n \n-\t  if (rtx_equal_p (SET_DEST (PATTERN (dep_insn)), SET_SRC (PATTERN (insn))))\n+\t  if (rtx_equal_p (SET_DEST (dep_pat), SET_SRC (pat)))\n \t    {\n-\t      /* INSN is a fp store and DEP_INSN is writing to the register\n-\t\t being stored.  */\n+\t      if (! recog_memoized (dep_insn))\n+\t\treturn 0;\n+\t      /* DEP_INSN is writing its result to the register\n+\t\t being stored in the fpstore INSN.  */\n \t      switch (get_attr_type (dep_insn))\n \t\t{\n \t\tcase TYPE_FPLOAD:\n@@ -2125,14 +2132,22 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \n       if (get_attr_type (insn) == TYPE_FPLOAD)\n \t{\n-\t  if (GET_CODE (PATTERN (insn)) != SET\n-\t      || GET_CODE (PATTERN (dep_insn)) != SET)\n+\t  rtx pat = PATTERN (insn);\n+\t  rtx dep_pat = PATTERN (dep_insn);\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    {\n+\t      /* This happens for the fldXs,mb patterns.  */\n+\t      pat = XVECEXP (pat, 0, 0);\n+\t    }\n+\t  if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)\n \t    /* If this happens, we have to extend this to schedule\n-\t       optimally.  */\n-\t    abort();\n+\t       optimally.  Return 0 for now.  */\n+\t  return 0;\n \n-\t  if (rtx_equal_p (SET_SRC (PATTERN (dep_insn)), SET_DEST (PATTERN (insn))))\n+\t  if (reg_mentioned_p (SET_DEST (pat), SET_SRC (dep_pat)))\n \t    {\n+\t      if (! recog_memoized (dep_insn))\n+\t\treturn 0;\n \t      switch (get_attr_type (dep_insn))\n \t\t{\n \t\tcase TYPE_FPALU:\n@@ -2141,6 +2156,10 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\tcase TYPE_FPDIVDBL:\n \t\tcase TYPE_FPSQRTSGL:\n \t\tcase TYPE_FPSQRTDBL:\n+\t\t  /* A fpload can't be issued until one cycle before a\n+\t\t     preceeding arithmetic operation has finished, if\n+\t\t     the target of the fpload is any of the sources\n+\t\t     (or destination) of the arithmetic operation.  */\n \t\t  return cost - 1;\n \n \t\tdefault:\n@@ -2153,9 +2172,8 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n       return 0;\n     }\n \n-  /* For all other cases of anti dependency and all cases of output\n-     dependence the md is correct enough for the PA7000.  */\n-  return cost;\n+  /* For output dependencies, the cost is often one too high.  */\n+  return cost - 1;\n }\n \n /* Print operand X (an rtx) in assembler syntax to file FILE."}]}