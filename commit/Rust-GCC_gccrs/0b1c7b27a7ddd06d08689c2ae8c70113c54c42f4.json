{"sha": "0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIxYzdiMjdhN2RkZDA2ZDA4Njg5YzJhZThjNzAxMTNjNTRjNDJmNA==", "commit": {"author": {"name": "Mihail Ionescu", "email": "mihail.ionescu@arm.com", "date": "2020-01-15T11:29:42Z"}, "committer": {"name": "Mihail Ionescu", "email": "mihail.ionescu@arm.com", "date": "2020-01-16T15:11:37Z"}, "message": "[PATCH, GCC/ARM, 5/10] Clear VFP registers with VSCCLRM\n\nThis patch adds a new pattern for the VSCCLRM instruction.\ncmse_clear_registers () is then modified to use the new VSCCLRM\ninstruction when targeting Armv8.1-M Mainline, thus, making the Armv8-M\nregister clearing code specific to Armv8-M.\n\nSince the VSCCLRM instruction mandates VPR in the register list, the\npattern is encoded with a parallel which only requires an unspecified\nVUNSPEC_CLRM_VPR constant modelling the APSR clearing. Other expression\nin the parallel are expected to be set expression for clearing the VFP\nregisters.\n\n*** gcc/ChangeLog ***\n\n2020-01-16  Mihail-Calin Ionescu  <mihail.ionescu@arm.com>\n2020-01-16  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n\t* config/arm/arm-protos.h (clear_operation_p): Adapt prototype.\n\t* config/arm/arm.c (clear_operation_p): Extend to be able to check a\n\tclear_vfp_multiple pattern based on a new vfp parameter.\n\t(cmse_clear_registers): Generate VSCCLRM to clear VFP registers when\n\ttargeting Armv8.1-M Mainline.\n\t(cmse_nonsecure_entry_clear_before_return): Clear VFP registers\n\tunconditionally when targeting Armv8.1-M Mainline architecture.  Check\n\twhether VFP registers are available before looking call_used_regs for a\n\tVFP register.\n\t* config/arm/predicates.md (clear_multiple_operation): Adapt to change\n\tof prototype of clear_operation_p.\n\t(clear_vfp_multiple_operation): New predicate.\n\t* config/arm/unspecs.md (VUNSPEC_VSCCLRM_VPR): New volatile unspec.\n\t* config/arm/vfp.md (clear_vfp_multiple): New define_insn.\n\n*** gcc/testsuite/ChangeLog ***\n\n2020-01-16  Mihail-Calin Ionescu  <mihail.ionescu@arm.com>\n2020-01-16  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n\t* gcc.target/arm/cmse/bitfield-1.c: Add check for VSCCLRM.\n\t* gcc.target/arm/cmse/bitfield-2.c: Likewise.\n\t* gcc.target/arm/cmse/bitfield-3.c: Likewise.\n\t* gcc.target/arm/cmse/cmse-1.c: Likewise.\n\t* gcc.target/arm/cmse/struct-1.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-13.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-5.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-7.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-8.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-13.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-5.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-7.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-8.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-5.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-5.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-5.c: Likewise.", "tree": {"sha": "b146eb47ca5ec091530e66c119ca4be3b206f6c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b146eb47ca5ec091530e66c119ca4be3b206f6c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/comments", "author": null, "committer": null, "parents": [{"sha": "9722215a027b68651c3c7a8af9204d033197e9c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9722215a027b68651c3c7a8af9204d033197e9c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9722215a027b68651c3c7a8af9204d033197e9c0"}], "stats": {"total": 380, "additions": 215, "deletions": 165}, "files": [{"sha": "f709b62c101688c343afe58c3a51d515b41d9abc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -1,6 +1,24 @@\n 2020-01-16  Mihail-Calin Ionescu <mihail.ionescu@arm.com>\n 2020-01-16  Thomas Preud'homme <thomas.preudhomme@arm.com>\n \n+\t* config/arm/arm-protos.h (clear_operation_p): Adapt prototype.\n+\t* config/arm/arm.c (clear_operation_p): Extend to be able to check a\n+\tclear_vfp_multiple pattern based on a new vfp parameter.\n+\t(cmse_clear_registers): Generate VSCCLRM to clear VFP registers when\n+\ttargeting Armv8.1-M Mainline.\n+\t(cmse_nonsecure_entry_clear_before_return): Clear VFP registers\n+\tunconditionally when targeting Armv8.1-M Mainline architecture.  Check\n+\twhether VFP registers are available before looking call_used_regs for a\n+\tVFP register.\n+\t* config/arm/predicates.md (clear_multiple_operation): Adapt to change\n+\tof prototype of clear_operation_p.\n+\t(clear_vfp_multiple_operation): New predicate.\n+\t* config/arm/unspecs.md (VUNSPEC_VSCCLRM_VPR): New volatile unspec.\n+\t* config/arm/vfp.md (clear_vfp_multiple): New define_insn.\n+\n+2020-01-16  Mihail-Calin Ionescu  <mihail.ionescu@arm.com>\n+2020-01-16  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n \t* config/arm/arm-protos.h (clear_operation_p): Declare.\n \t* config/arm/arm.c (clear_operation_p): New function.\n \t(cmse_clear_registers): Generate clear_multiple instruction pattern if"}, {"sha": "883062759e22f5a8957bd4320f2bbc0061d941b5", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -83,7 +83,7 @@ extern int thumb_legitimate_offset_p (machine_mode, HOST_WIDE_INT);\n extern int thumb1_legitimate_address_p (machine_mode, rtx, int);\n extern bool ldm_stm_operation_p (rtx, bool, machine_mode mode,\n                                  bool, bool);\n-extern bool clear_operation_p (rtx);\n+extern bool clear_operation_p (rtx, bool);\n extern int arm_const_double_rtx (rtx);\n extern int vfp3_const_double_rtx (rtx);\n extern int neon_immediate_valid_for_move (rtx, machine_mode, rtx *, int *);"}, {"sha": "250517e6fca7b386b5e927f665d7224571ded2d7", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 113, "deletions": 49, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -13709,8 +13709,9 @@ ldm_stm_operation_p (rtx op, bool load, machine_mode mode,\n   return true;\n }\n \n-/* Checks whether OP is a valid parallel pattern for a CLRM insn.  To be a\n-   valid CLRM pattern, OP must have the following form:\n+/* Checks whether OP is a valid parallel pattern for a CLRM (if VFP is false)\n+   or VSCCLRM (otherwise) insn.  To be a valid CLRM pattern, OP must have the\n+   following form:\n \n    [(set (reg:SI <N>) (const_int 0))\n     (set (reg:SI <M>) (const_int 0))\n@@ -13722,22 +13723,35 @@ ldm_stm_operation_p (rtx op, bool load, machine_mode mode,\n \n    Any number (including 0) of set expressions is valid, the volatile unspec is\n    optional.  All registers but SP and PC are allowed and registers must be in\n-   strict increasing order.  */\n+   strict increasing order.\n+\n+   To be a valid VSCCLRM pattern, OP must have the following form:\n+\n+   [(unspec_volatile [(const_int 0)]\n+\t\t     VUNSPEC_VSCCLRM_VPR)\n+    (set (reg:SF <N>) (const_int 0))\n+    (set (reg:SF <M>) (const_int 0))\n+    ...\n+   ]\n+\n+   As with CLRM, any number (including 0) of set expressions is valid, however\n+   the volatile unspec is mandatory here.  Any VFP single-precision register is\n+   accepted but all registers must be consecutive and in increasing order.  */\n \n bool\n-clear_operation_p (rtx op)\n+clear_operation_p (rtx op, bool vfp)\n {\n-  HOST_WIDE_INT i;\n   unsigned regno, last_regno;\n   rtx elt, reg, zero;\n-  machine_mode mode;\n   HOST_WIDE_INT count = XVECLEN (op, 0);\n+  HOST_WIDE_INT i, first_set = vfp ? 1 : 0;\n+  machine_mode expected_mode = vfp ? E_SFmode : E_SImode;\n \n-  for (i = 0; i < count; i++)\n+  for (i = first_set; i < count; i++)\n     {\n       elt = XVECEXP (op, 0, i);\n \n-      if (GET_CODE (elt) == UNSPEC_VOLATILE)\n+      if (!vfp && GET_CODE (elt) == UNSPEC_VOLATILE)\n \t{\n \t  if (XINT (elt, 1) != VUNSPEC_CLRM_APSR\n \t      || XVECLEN (elt, 0) != 1\n@@ -13756,17 +13770,26 @@ clear_operation_p (rtx op)\n \n       reg = SET_DEST (elt);\n       regno = REGNO (reg);\n-      mode = GET_MODE (reg);\n       zero = SET_SRC (elt);\n \n       if (!REG_P (reg)\n-\t  || GET_MODE (reg) != SImode\n-\t  || regno == SP_REGNUM\n-\t  || regno == PC_REGNUM\n-\t  || (i != 0 && regno <= last_regno)\n+\t  || GET_MODE (reg) != expected_mode\n \t  || zero != CONST0_RTX (SImode))\n \treturn false;\n \n+      if (vfp)\n+\t{\n+\t  if (i != 1 && regno != last_regno + 1)\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  if (regno == SP_REGNUM || regno == PC_REGNUM)\n+\t    return false;\n+\t  if (i != 0 && regno <= last_regno)\n+\t    return false;\n+\t}\n+\n       last_regno = REGNO (reg);\n     }\n \n@@ -18112,6 +18135,43 @@ cmse_clear_registers (sbitmap to_clear_bitmap, uint32_t *padding_bits_to_clear,\n       auto_sbitmap core_regs_bitmap (to_clear_bitmap_size);\n       auto_sbitmap to_clear_core_bitmap (to_clear_bitmap_size);\n \n+      for (i = FIRST_VFP_REGNUM; i <= maxregno; i += nb_regs)\n+\t{\n+\t  /* Find next register to clear and exit if none.  */\n+\t  for (; i <= maxregno && !bitmap_bit_p (to_clear_bitmap, i); i++);\n+\t  if (i > maxregno)\n+\t    break;\n+\n+\t  /* Compute number of consecutive registers to clear.  */\n+\t  for (j = i; j <= maxregno && bitmap_bit_p (to_clear_bitmap, j);\n+\t       j++);\n+\t  nb_regs = j - i;\n+\n+\t  /* Create VSCCLRM RTX pattern.  */\n+\t  par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (nb_regs + 1));\n+\t  vunspec_vec = gen_rtvec (1, gen_int_mode (0, SImode));\n+\t  vunspec = gen_rtx_UNSPEC_VOLATILE (SImode, vunspec_vec,\n+\t\t\t\t\t     VUNSPEC_VSCCLRM_VPR);\n+\t  XVECEXP (par, 0, 0) = vunspec;\n+\n+\t  /* Insert VFP register clearing RTX in the pattern.  */\n+\t  start_sequence ();\n+\t  for (k = 1, j = i; j <= maxregno && k < nb_regs + 1; j++)\n+\t    {\n+\t      if (!bitmap_bit_p (to_clear_bitmap, j))\n+\t\tcontinue;\n+\n+\t      reg = gen_rtx_REG (SFmode, j);\n+\t      set = gen_rtx_SET (reg, const0_rtx);\n+\t      XVECEXP (par, 0, k++) = set;\n+\t      emit_use (reg);\n+\t    }\n+\t  use_seq = get_insns ();\n+\t  end_sequence ();\n+\n+\t  emit_insn_after (use_seq, emit_insn (par));\n+\t}\n+\n       /* Get set of core registers to clear.  */\n       bitmap_clear (core_regs_bitmap);\n       bitmap_set_range (core_regs_bitmap, R0_REGNUM,\n@@ -18156,49 +18216,50 @@ cmse_clear_registers (sbitmap to_clear_bitmap, uint32_t *padding_bits_to_clear,\n       end_sequence ();\n \n       emit_insn_after (use_seq, emit_insn (par));\n-      minregno = FIRST_VFP_REGNUM;\n-    }\n-\n-  /* If not marked for clearing, clearing_reg already does not contain\n-     any secret.  */\n-  if (clearing_regno <= maxregno\n-      && bitmap_bit_p (to_clear_bitmap, clearing_regno))\n-    {\n-      emit_move_insn (clearing_reg, const0_rtx);\n-      emit_use (clearing_reg);\n-      bitmap_clear_bit (to_clear_bitmap, clearing_regno);\n     }\n-\n-  for (regno = minregno; regno <= maxregno; regno++)\n+  else\n     {\n-      if (!bitmap_bit_p (to_clear_bitmap, regno))\n-\tcontinue;\n+      /* If not marked for clearing, clearing_reg already does not contain\n+\t any secret.  */\n+      if (clearing_regno <= maxregno\n+\t  && bitmap_bit_p (to_clear_bitmap, clearing_regno))\n+\t{\n+\t  emit_move_insn (clearing_reg, const0_rtx);\n+\t  emit_use (clearing_reg);\n+\t  bitmap_clear_bit (to_clear_bitmap, clearing_regno);\n+\t}\n \n-      if (IS_VFP_REGNUM (regno))\n+      for (regno = minregno; regno <= maxregno; regno++)\n \t{\n-\t  /* If regno is an even vfp register and its successor is also to\n-\t     be cleared, use vmov.  */\n-\t  if (TARGET_VFP_DOUBLE\n-\t      && VFP_REGNO_OK_FOR_DOUBLE (regno)\n-\t      && bitmap_bit_p (to_clear_bitmap, regno + 1))\n+\t  if (!bitmap_bit_p (to_clear_bitmap, regno))\n+\t    continue;\n+\n+\t  if (IS_VFP_REGNUM (regno))\n \t    {\n-\t      emit_move_insn (gen_rtx_REG (DFmode, regno),\n-\t\t\t      CONST1_RTX (DFmode));\n-\t      emit_use (gen_rtx_REG (DFmode, regno));\n-\t      regno++;\n+\t      /* If regno is an even vfp register and its successor is also to\n+\t\t be cleared, use vmov.  */\n+\t      if (TARGET_VFP_DOUBLE\n+\t\t  && VFP_REGNO_OK_FOR_DOUBLE (regno)\n+\t\t  && bitmap_bit_p (to_clear_bitmap, regno + 1))\n+\t\t{\n+\t\t  emit_move_insn (gen_rtx_REG (DFmode, regno),\n+\t\t\t\t  CONST1_RTX (DFmode));\n+\t\t  emit_use (gen_rtx_REG (DFmode, regno));\n+\t\t  regno++;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  emit_move_insn (gen_rtx_REG (SFmode, regno),\n+\t\t\t\t  CONST1_RTX (SFmode));\n+\t\t  emit_use (gen_rtx_REG (SFmode, regno));\n+\t\t}\n \t    }\n \t  else\n \t    {\n-\t      emit_move_insn (gen_rtx_REG (SFmode, regno),\n-\t\t\t      CONST1_RTX (SFmode));\n-\t      emit_use (gen_rtx_REG (SFmode, regno));\n+\t      emit_move_insn (gen_rtx_REG (SImode, regno), clearing_reg);\n+\t      emit_use (gen_rtx_REG (SImode, regno));\n \t    }\n \t}\n-      else\n-\t{\n-\t  emit_move_insn (gen_rtx_REG (SImode, regno), clearing_reg);\n-\t  emit_use (gen_rtx_REG (SImode, regno));\n-\t}\n     }\n }\n \n@@ -26397,7 +26458,8 @@ thumb1_expand_prologue (void)\n void\n cmse_nonsecure_entry_clear_before_return (void)\n {\n-  int regno, maxregno = TARGET_HARD_FLOAT ? LAST_VFP_REGNUM : IP_REGNUM;\n+  bool clear_vfpregs = TARGET_HARD_FLOAT || TARGET_HAVE_FPCXT_CMSE;\n+  int regno, maxregno = clear_vfpregs ? LAST_VFP_REGNUM : IP_REGNUM;\n   uint32_t padding_bits_to_clear = 0;\n   auto_sbitmap to_clear_bitmap (maxregno + 1);\n   rtx r1_reg, result_rtl, clearing_reg = NULL_RTX;\n@@ -26409,7 +26471,7 @@ cmse_nonsecure_entry_clear_before_return (void)\n \n   /* If we are not dealing with -mfloat-abi=soft we will need to clear VFP\n      registers.  */\n-  if (TARGET_HARD_FLOAT)\n+  if (clear_vfpregs)\n     {\n       int float_bits = D7_VFP_REGNUM - FIRST_VFP_REGNUM + 1;\n \n@@ -26438,7 +26500,9 @@ cmse_nonsecure_entry_clear_before_return (void)\n \tcontinue;\n       if (IN_RANGE (regno, IP_REGNUM, PC_REGNUM))\n \tcontinue;\n-      if (call_used_or_fixed_reg_p (regno))\n+      if (call_used_or_fixed_reg_p (regno)\n+\t  && (!IN_RANGE (regno, FIRST_VFP_REGNUM, LAST_VFP_REGNUM)\n+\t      || TARGET_HARD_FLOAT))\n \tbitmap_set_bit (to_clear_bitmap, regno);\n     }\n "}, {"sha": "8df99e64bbb8cfcec8c703bb86341e1493fd5cab", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -548,7 +548,13 @@\n (define_special_predicate \"clear_multiple_operation\"\n   (match_code \"parallel\")\n {\n- return clear_operation_p (op);\n+ return clear_operation_p (op, /*vfp*/false);\n+})\n+\n+(define_special_predicate \"clear_vfp_multiple_operation\"\n+  (match_code \"parallel\")\n+{\n+ return clear_operation_p (op, /*vfp*/true);\n })\n \n (define_special_predicate \"load_multiple_operation\""}, {"sha": "22a1491923082d6ebe7af1b56c2c90a95bb65cfc", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -241,6 +241,8 @@\n   VUNSPEC_APSR_WRITE     ; Represent writing the APSR.\n   VUNSPEC_VSTR_VLDR\t; Represent the vstr/vldr instruction.\n   VUNSPEC_CLRM_APSR\t; Represent the clearing of APSR with clrm instruction.\n+  VUNSPEC_VSCCLRM_VPR\t; Represent the clearing of VPR with vscclrm\n+\t\t\t; instruction.\n ])\n \n ;; Enumerators for NEON unspecs."}, {"sha": "92e8d8fbd8f31834fcb776008fbd12f0dcc80ca4", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -1637,6 +1637,42 @@\n    (set_attr \"type\" \"load_4\")]\n )\n \n+;; The operands are validated through the clear_multiple_operation\n+;; match_parallel predicate rather than through constraints so enable it only\n+;; after reload.\n+(define_insn \"*clear_vfp_multiple\"\n+  [(match_parallel 0 \"clear_vfp_multiple_operation\"\n+     [(unspec_volatile [(const_int 0)]\n+\t\t       VUNSPEC_VSCCLRM_VPR)])]\n+  \"TARGET_HAVE_FPCXT_CMSE && use_cmse && reload_completed\"\n+  {\n+    int num_regs = XVECLEN (operands[0], 0);\n+    char pattern[30];\n+    const char *regname;\n+    rtx reg;\n+\n+    strcpy (pattern, \\\"vscclrm%?\\\\t{%|\\\");\n+    if (num_regs > 1)\n+      {\n+\treg = XEXP (XVECEXP (operands[0], 0, 1), 0);\n+\tstrcat (pattern, reg_names[REGNO (reg)]);\n+\tif (num_regs > 2)\n+\t  {\n+\t    strcat (pattern, \\\"-%|\\\");\n+\t    reg = XEXP (XVECEXP (operands[0], 0, num_regs - 1), 0);\n+\t    strcat (pattern, reg_names[REGNO (reg)]);\n+\t  }\n+\tstrcat (pattern, \\\", \\\");\n+      }\n+\n+    strcat (pattern, \\\"VPR}\\\");\n+    output_asm_insn (pattern, operands);\n+    return \\\"\\\";\n+  }\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"mov_reg\")]\n+)\n+\n (define_insn_and_split \"*cmpsf_split_vfp\"\n   [(set (reg:CCFP CC_REGNUM)\n \t(compare:CCFP (match_operand:SF 0 \"s_register_operand\"  \"t\")"}, {"sha": "ac2ae996fc84d2ac25ec9d0193baaacb50675f2b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -1,6 +1,26 @@\n 2020-01-16  Mihail-Calin Ionescu <mihail.ionescu@arm.com>\n 2020-01-16  Thomas Preud'homme <thomas.preudhomme@arm.com>\n \n+\t* gcc.target/arm/cmse/bitfield-1.c: Add check for VSCCLRM.\n+\t* gcc.target/arm/cmse/bitfield-2.c: Likewise.\n+\t* gcc.target/arm/cmse/bitfield-3.c: Likewise.\n+\t* gcc.target/arm/cmse/cmse-1.c: Likewise.\n+\t* gcc.target/arm/cmse/struct-1.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-13.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-5.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-7.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-8.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-13.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-5.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-7.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/hard/cmse-8.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-5.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-5.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-5.c: Likewise.\n+\n+2020-01-16  Mihail-Calin Ionescu  <mihail.ionescu@arm.com>\n+2020-01-16  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n \t* gcc.target/arm/cmse/bitfield-1.c: Add check for CLRM.\n \t* gcc.target/arm/cmse/bitfield-2.c: Likewise.\n \t* gcc.target/arm/cmse/bitfield-3.c: Likewise."}, {"sha": "cae2f06140766176c9af6e4b2b4a3e722fbad67c", "filename": "gcc/testsuite/gcc.target/arm/cmse/bitfield-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-1.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -36,6 +36,7 @@ main (void)\n /* { dg-final { scan-assembler \"movw\\tr1, #1855\" } } */\n /* { dg-final { scan-assembler \"movt\\tr1, 65535\" } } */\n /* { dg-final { scan-assembler \"ands\\tr0(, r0)?, r1\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s0-s15, VPR\\}\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r1, r2, r3, ip, APSR\\}\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"vldr\\tFPCXTNS, \\\\\\[sp\\\\\\], #4\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"bxns\" } } */"}, {"sha": "21a53cd85792e439314f5c88080d7f1c6fcdec66", "filename": "gcc/testsuite/gcc.target/arm/cmse/bitfield-2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-2.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -33,6 +33,7 @@ main (void)\n /* { dg-final { scan-assembler \"movw\\tr1, #1919\" } } */\n /* { dg-final { scan-assembler \"movt\\tr1, 2047\" } } */\n /* { dg-final { scan-assembler \"ands\\tr0(, r0)?, r1\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s0-s15, VPR\\}\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r1, r2, r3, ip, APSR\\}\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"vldr\\tFPCXTNS, \\\\\\[sp\\\\\\], #4\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"bxns\" } } */"}, {"sha": "e8f973e3f06881d33d661f81c0eb6671e48a0d01", "filename": "gcc/testsuite/gcc.target/arm/cmse/bitfield-3.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-3.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -34,6 +34,7 @@ main (void)\n /* { dg-final { scan-assembler \"movw\\tr1, #65535\" } } */\n /* { dg-final { scan-assembler \"movt\\tr1, 63\" } } */\n /* { dg-final { scan-assembler \"ands\\tr0(, r0)?, r1\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s0-s15, VPR\\}\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r1, r2, r3, ip, APSR\\}\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"vldr\\tFPCXTNS, \\\\\\[sp\\\\\\], #4\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"bxns\" } } */"}, {"sha": "29d78ddd6166321bdf0acabf011138b276151e85", "filename": "gcc/testsuite/gcc.target/arm/cmse/cmse-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-1.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -105,6 +105,7 @@ qux (int_nsfunc_t * callback)\n /* { dg-final { scan-assembler \"bic\" } } */\n /* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6\" } } */\n /* { dg-final { scan-assembler \"vstr\\tFPCXTNS, \\\\\\[sp, #-4\\\\\\]!\" { target arm_cmse_clear_ok } } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s0-s15, VPR\\}\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r1, r2, r3, ip, APSR\\}\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"vldr\\tFPCXTNS, \\\\\\[sp\\\\\\], #4\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"msr\\tAPSR_nzcvq\" { target { ! arm_cmse_clear_ok } } } } */"}, {"sha": "9719f799229e245264d377c3726190ca768ca1dd", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-13.c", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-13.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -10,21 +10,10 @@\n /* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, APSR\\}\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts0, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts1, #1\\.0\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts2, #1\\.0\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts3, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts4, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts5, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts6, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts7, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts8, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts9, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts10, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts11, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts12, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts13, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts14, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts15, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s1, VPR\\}\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s4-s15, VPR\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n /* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "dc62b742ba5ab9f7480ca93396e5eb354c5e64dd", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-5.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-5.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -6,22 +6,7 @@\n #include \"../../../cmse-5.x\"\n \n /* { dg-final { scan-assembler \"vstr\\tFPCXTNS, \\\\\\[sp, #-4\\\\\\]!\" } } */\n-/* { dg-final { scan-assembler-not \"vmov\\.f32\\ts0, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts1, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts2, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts3, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts4, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts5, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts6, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts7, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts8, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts9, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts10, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts11, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts12, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts13, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts14, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts15, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s1-s15, VPR\\}\" } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, ip, APSR\\}\" } } */\n /* { dg-final { scan-assembler \"vldr\\tFPCXTNS, \\\\\\[sp\\\\\\], #4\" } } */\n /* { dg-final { scan-assembler \"bxns\" } } */"}, {"sha": "a6951d34afeed54c0ac2e937345cbfbbfb2c4b2d", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-7.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-7.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -9,22 +9,7 @@\n /* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n /* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, APSR\\}\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts0, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts1, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts2, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts3, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts4, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts5, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts6, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts7, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts8, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts9, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts10, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts11, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts12, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts13, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts14, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts15, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s0-s15, VPR\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n /* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "23db88dc66d584acbba64a10d3f6fd06f066b321", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard-sp/cmse-8.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard-sp%2Fcmse-8.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -11,20 +11,7 @@\n /* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, APSR\\}\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts0, #1\\.0\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts1, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts2, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts3, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts4, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts5, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts6, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts7, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts8, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts9, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts10, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts11, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts12, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts13, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts14, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts15, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s2-s15, VPR\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n /* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "2898efabb2b37e3c8dacaf029b5a40be8edcc624", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard/cmse-13.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-13.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -9,18 +9,13 @@\n /* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n /* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, APSR\\}\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts1, #1\\.0\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts0, #1\\.0\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f64\\td0, #1\\.0\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f64\\td1, #1\\.0\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts2, #1\\.0\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f32\\ts3, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td2, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td3, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td4, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td5, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td6, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td7, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s1, VPR\\}\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s4-s15, VPR\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n /* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "55e7a4f7ae0c4420a40a250f246a769eff28e6c7", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard/cmse-5.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-5.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -6,15 +6,7 @@\n #include \"../../../cmse-5.x\"\n \n /* { dg-final { scan-assembler \"vstr\\tFPCXTNS, \\\\\\[sp, #-4\\\\\\]!\" } } */\n-/* { dg-final { scan-assembler-not \"vmov\\.f32\\ts0, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts1, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td1, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td2, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td3, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td4, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td5, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td6, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td7, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s1-s15, VPR\\}\" } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, ip, APSR\\}\" } } */\n /* { dg-final { scan-assembler \"vldr\\tFPCXTNS, \\\\\\[sp\\\\\\], #4\" } } */\n /* { dg-final { scan-assembler \"bxns\" } } */"}, {"sha": "a4520a9166e36b1d3220befb72a1863799b2f424", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard/cmse-7.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-7.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -9,14 +9,7 @@\n /* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n /* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, APSR\\}\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td0, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td1, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td2, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td3, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td4, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td5, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td6, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td7, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s0-s15, VPR\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n /* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "c79d3188026d9248abde7967671c05a09b75c49f", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/hard/cmse-8.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fhard%2Fcmse-8.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -10,13 +10,7 @@\n /* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r0, r1, r2, r3, APSR\\}\" } } */\n /* { dg-final { scan-assembler-not \"vmov\\.f64\\td0, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td1, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td2, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td3, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td4, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td5, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td6, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td7, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s2-s15, VPR\\}\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n /* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "d3a3a742b8b4ff99c973a8c9edd77297c7f37ae2", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-5.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-5.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -7,6 +7,7 @@\n /* { dg-final { scan-assembler \"vstr\\tFPCXTNS, \\\\\\[sp, #-4\\\\\\]!\" } } */\n /* { dg-final { scan-assembler-not \"vmov\" } } */\n /* { dg-final { scan-assembler-not \"vmsr\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s0-s15, VPR\\}\" } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r1, r2, r3, ip, APSR\\}\" } } */\n /* { dg-final { scan-assembler \"vldr\\tFPCXTNS, \\\\\\[sp\\\\\\], #4\" } } */\n /* { dg-final { scan-assembler \"bxns\" } } */"}, {"sha": "bbe16cee9c2c29e0701f54c3e393ad3c7efb8e87", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-5.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-5.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -8,22 +8,7 @@\n /* { dg-final { scan-assembler \"__acle_se_foo:\" } } */\n /* { dg-final { scan-assembler \"vstr\\tFPCXTNS, \\\\\\[sp, #-4\\\\\\]!\" } } */\n /* { dg-final { scan-assembler-not \"mov\\tr0, lr\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts0, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts1, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts2, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts3, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts4, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts5, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts6, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts7, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts8, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts9, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts10, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts11, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts12, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts13, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts14, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f32\\ts15, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s0-s15, VPR\\}\" } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r1, r2, r3, ip, APSR\\}\" } } */\n /* { dg-final { scan-assembler \"vldr\\tFPCXTNS, \\\\\\[sp\\\\\\], #4\" } } */\n /* { dg-final { scan-assembler \"bxns\" } } */"}, {"sha": "c7dda6a3d6088366358ff4bc1e6d83ad9b03ea6e", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-5.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-5.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -7,14 +7,7 @@\n \n /* { dg-final { scan-assembler \"__acle_se_foo:\" } } */\n /* { dg-final { scan-assembler \"vstr\\tFPCXTNS, \\\\\\[sp, #-4\\\\\\]!\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td0, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td1, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td2, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td3, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td4, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td5, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td6, #1\\.0\" } } */\n-/* { dg-final { scan-assembler \"vmov\\.f64\\td7, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s0-s15, VPR\\}\" } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r1, r2, r3, ip, APSR\\}\" } } */\n /* { dg-final { scan-assembler \"vldr\\tFPCXTNS, \\\\\\[sp\\\\\\], #4\" } } */\n /* { dg-final { scan-assembler \"bxns\" } } */"}, {"sha": "755564369ae7deecfb038e67591e679bb06f62b1", "filename": "gcc/testsuite/gcc.target/arm/cmse/struct-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fstruct-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fstruct-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fstruct-1.c?ref=0b1c7b27a7ddd06d08689c2ae8c70113c54c42f4", "patch": "@@ -29,6 +29,7 @@ main (void)\n /* { dg-final { scan-assembler \"movs\\tr1, #255\" } } */\n /* { dg-final { scan-assembler \"movt\\tr1, 65535\" } } */\n /* { dg-final { scan-assembler \"ands\\tr0(, r0)?, r1\" } } */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{s0-s15, VPR\\}\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"clrm\\t\\{r1, r2, r3, ip, APSR\\}\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"vldr\\tFPCXTNS, \\\\\\[sp\\\\\\], #4\" { target arm_cmse_clear_ok } } } */\n /* { dg-final { scan-assembler \"bxns\" } } */"}]}