{"sha": "5108f3e52764b6e30f6d2879e6cf1c6e03bac113", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEwOGYzZTUyNzY0YjZlMzBmNmQyODc5ZTZjZjFjNmUwM2JhYzExMw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-08-15T07:36:04Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-08-15T07:36:04Z"}, "message": "Fix all known bugs remaining in sparc64 constant formation.\n\n\t* config/sparc/sparc.c (sparc_emit_set_const64_quick1): If\n\temitting a XOR of -1 at the end, emit a NOT instead for combine's\n\tsake.\n\t(sparc_emit_set_const64): Likewise, also when computing trailing\n\tbits do not negate low_bits and make fast_int an int.\n\nFrom-SVN: r21748", "tree": {"sha": "f91411c8934c6d7058e24090ade849cfce1aaadb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f91411c8934c6d7058e24090ade849cfce1aaadb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5108f3e52764b6e30f6d2879e6cf1c6e03bac113", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5108f3e52764b6e30f6d2879e6cf1c6e03bac113", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5108f3e52764b6e30f6d2879e6cf1c6e03bac113", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5108f3e52764b6e30f6d2879e6cf1c6e03bac113/comments", "author": null, "committer": null, "parents": [{"sha": "d26df5611cf538aef12f4bd5830fd7a84123a063", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d26df5611cf538aef12f4bd5830fd7a84123a063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d26df5611cf538aef12f4bd5830fd7a84123a063"}], "stats": {"total": 66, "additions": 52, "deletions": 14}, "files": [{"sha": "39be7a8d9fe4c65ac8687f7780dec43948bb695d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5108f3e52764b6e30f6d2879e6cf1c6e03bac113/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5108f3e52764b6e30f6d2879e6cf1c6e03bac113/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5108f3e52764b6e30f6d2879e6cf1c6e03bac113", "patch": "@@ -1,3 +1,11 @@\n+Sat Aug 15 06:28:19 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* config/sparc/sparc.c (sparc_emit_set_const64_quick1): If\n+\temitting a XOR of -1 at the end, emit a NOT instead for combine's\n+\tsake.\n+\t(sparc_emit_set_const64): Likewise, also when computing trailing\n+\tbits do not negate low_bits and make fast_int an int.\n+\n Fri Aug 14 21:07:03 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* loop.c (add_label_notes): Do not ignore references to labels"}, {"sha": "56cc02a7f765832c12f632253476c0ade8d1b58a", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5108f3e52764b6e30f6d2879e6cf1c6e03bac113/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5108f3e52764b6e30f6d2879e6cf1c6e03bac113/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5108f3e52764b6e30f6d2879e6cf1c6e03bac113", "patch": "@@ -1336,12 +1336,27 @@ sparc_emit_set_const64_quick1 (op0, temp, low_bits, is_neg)\n \n   sparc_emit_set_safe_HIGH64 (temp, high_bits);\n   if (!is_neg)\n-    emit_insn (gen_rtx_SET (VOIDmode, op0,\n-\t\t\t    gen_safe_OR64 (temp, (high_bits & 0x3ff))));\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, op0,\n+\t\t\t      gen_safe_OR64 (temp, (high_bits & 0x3ff))));\n+    }\n   else\n-    emit_insn (gen_rtx_SET (VOIDmode, op0,\n-\t\t\t    gen_safe_XOR64 (temp,\n-\t\t\t\t\t    (-0x400 | (low_bits & 0x3ff)))));\n+    {\n+      /* If we are XOR'ing with -1, then we should emit a one's complement\n+\t instead.  This way the combiner will notice logical operations\n+\t such as ANDN later on and substitute.  */\n+      if ((low_bits & 0x3ff) == 0x3ff)\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n+\t\t\t\t  gen_rtx_NOT (DImode, temp)));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n+\t\t\t\t  gen_safe_XOR64 (temp,\n+\t\t\t\t\t\t  (-0x400 | (low_bits & 0x3ff)))));\n+\t}\n+    }\n }\n \n static void sparc_emit_set_const64_quick2\n@@ -1453,7 +1468,7 @@ sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits)\n \n       /* We are in the middle of reload, so this is really\n \t painful.  However we do still make an attempt to\n-\t avoid emmitting truly stupid code.  */\n+\t avoid emitting truly stupid code.  */\n       if (low1 != const0_rtx)\n \t{\n \t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n@@ -1795,17 +1810,20 @@ sparc_emit_set_const64 (op0, op1)\n   if (const64_is_2insns ((~high_bits) & 0xffffffff,\n \t\t\t (~low_bits) & 0xfffffc00))\n     {\n-      unsigned HOST_WIDE_INT trailing_bits = (~low_bits) & 0x3ff;\n+      /* NOTE: The trailing bits get XOR'd so we need the\n+\t non-negated bits, not the negated ones.  */\n+      unsigned HOST_WIDE_INT trailing_bits = low_bits & 0x3ff;\n \n       if ((((~high_bits) & 0xffffffff) == 0\n \t   && ((~low_bits) & 0x80000000) == 0)\n \t  || (((~high_bits) & 0xffffffff) == 0xffffffff\n \t      && ((~low_bits) & 0x80000000) != 0))\n \t{\n-\t  HOST_WIDE_INT fast_int = (~low_bits & 0xffffffff);\n+\t  int fast_int = (~low_bits & 0xffffffff);\n \n-\t  if (SPARC_SETHI_P (fast_int)\n-\t      || SPARC_SIMM13_P (((int)fast_int)))\n+\t  if ((SPARC_SETHI_P (fast_int)\n+\t       && (~high_bits & 0xffffffff) == 0)\n+\t      || SPARC_SIMM13_P (fast_int))\n \t    emit_insn (gen_safe_SET64 (temp, fast_int));\n \t  else\n \t    sparc_emit_set_const64 (temp, GEN_INT64 (fast_int));\n@@ -1823,10 +1841,22 @@ sparc_emit_set_const64 (op0, op1)\n #endif\n \t  sparc_emit_set_const64 (temp, negated_const);\n \t}\n-      emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t      op0,\n-\t\t\t      gen_safe_XOR64 (temp,\n-\t\t\t\t\t      (-0x400 | trailing_bits))));\n+\n+      /* If we are XOR'ing with -1, then we should emit a one's complement\n+\t instead.  This way the combiner will notice logical operations\n+\t such as ANDN later on and substitute.  */\n+      if (trailing_bits == 0x3ff)\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n+\t\t\t\t  gen_rtx_NOT (DImode, temp)));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  op0,\n+\t\t\t\t  gen_safe_XOR64 (temp,\n+\t\t\t\t\t\t  (-0x400 | trailing_bits))));\n+\t}\n       return;\n     }\n "}]}