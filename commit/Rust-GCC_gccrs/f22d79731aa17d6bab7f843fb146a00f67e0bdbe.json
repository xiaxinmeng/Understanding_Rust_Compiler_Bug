{"sha": "f22d79731aa17d6bab7f843fb146a00f67e0bdbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIyZDc5NzMxYWExN2Q2YmFiN2Y4NDNmYjE0NmEwMGY2N2UwYmRiZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-05-08T09:56:29Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-05-08T09:56:29Z"}, "message": "[AArch64] Use UNSPEC_MERGE_PTRUE for comparisons\n\nThis patch rewrites the SVE comparison handling so that it uses\nUNSPEC_MERGE_PTRUE for comparisons that are known to be predicated\non a PTRUE, for consistency with other patterns.  Specific unspecs\nare then only needed for truly predicated floating-point comparisons,\nsuch as those used in the expansion of UNEQ for flag_trapping_math.\n\nThe patch also makes sure that the comparison expanders attach\na REG_EQUAL note to instructions that use UNSPEC_MERGE_PTRUE,\nso passes can use that as an alternative to the unspec pattern.\n(This happens automatically for optabs.  The problem was that\nthis code emits instruction patterns directly.)\n\nNo specific benefit on its own, but it lays the groundwork for\nthe next patch.\n\n2018-05-08  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* config/aarch64/iterators.md (UNSPEC_COND_LO, UNSPEC_COND_LS)\n\t(UNSPEC_COND_HI, UNSPEC_COND_HS, UNSPEC_COND_UO): Delete.\n\t(SVE_INT_CMP, SVE_FP_CMP): New code iterators.\n\t(cmp_op, sve_imm_con): New code attributes.\n\t(SVE_COND_INT_CMP, imm_con): Delete.\n\t(cmp_op): Remove above unspecs from int attribute.\n\t* config/aarch64/aarch64-sve.md (*vec_cmp<cmp_op>_<mode>): Rename\n\tto...\n\t(*cmp<cmp_op><mode>): ...this.  Use UNSPEC_MERGE_PTRUE instead of\n\tcomparison-specific unspecs.\n\t(*vec_cmp<cmp_op>_<mode>_ptest): Rename to...\n\t(*cmp<cmp_op><mode>_ptest): ...this and adjust likewise.\n\t(*vec_cmp<cmp_op>_<mode>_cc): Rename to...\n\t(*cmp<cmp_op><mode>_cc): ...this and adjust likewise.\n\t(*vec_fcm<cmp_op><mode>): Rename to...\n\t(*fcm<cmp_op><mode>): ...this and adjust likewise.\n\t(*vec_fcmuo<mode>): Rename to...\n\t(*fcmuo<mode>): ...this and adjust likewise.\n\t(*pred_fcm<cmp_op><mode>): New pattern.\n\t* config/aarch64/aarch64.c (aarch64_emit_unop, aarch64_emit_binop)\n\t(aarch64_emit_sve_ptrue_op, aarch64_emit_sve_ptrue_op_cc): New\n\tfunctions.\n\t(aarch64_unspec_cond_code): Remove handling of LTU, GTU, LEU, GEU\n\tand UNORDERED.\n\t(aarch64_gen_unspec_cond, aarch64_emit_unspec_cond): Delete.\n\t(aarch64_emit_sve_predicated_cond): New function.\n\t(aarch64_expand_sve_vec_cmp_int): Use aarch64_emit_sve_ptrue_op_cc.\n\t(aarch64_emit_unspec_cond_or): Replace with...\n\t(aarch64_emit_sve_or_conds): ...this new function.  Use\n\taarch64_emit_sve_ptrue_op for the individual comparisons and\n\taarch64_emit_binop to OR them together.\n\t(aarch64_emit_inverted_unspec_cond): Replace with...\n\t(aarch64_emit_sve_inverted_cond): ...this new function.  Use\n\taarch64_emit_sve_ptrue_op for the comparison and\n\taarch64_emit_unop to invert the result.\n\t(aarch64_expand_sve_vec_cmp_float): Update after the above\n\tchanges.  Use aarch64_emit_sve_ptrue_op for native comparisons.\n\nFrom-SVN: r260029", "tree": {"sha": "726ee1b2df116e6a6defc80395b48de82c6b1fd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/726ee1b2df116e6a6defc80395b48de82c6b1fd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f22d79731aa17d6bab7f843fb146a00f67e0bdbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f22d79731aa17d6bab7f843fb146a00f67e0bdbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f22d79731aa17d6bab7f843fb146a00f67e0bdbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f22d79731aa17d6bab7f843fb146a00f67e0bdbe/comments", "author": null, "committer": null, "parents": [{"sha": "4fdd8b18ecb46da1b89c00f1ab500fb15106189d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fdd8b18ecb46da1b89c00f1ab500fb15106189d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fdd8b18ecb46da1b89c00f1ab500fb15106189d"}], "stats": {"total": 431, "additions": 265, "deletions": 166}, "files": [{"sha": "cf85cc838828af1b0167fe80aa32c4c81b16d653", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22d79731aa17d6bab7f843fb146a00f67e0bdbe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22d79731aa17d6bab7f843fb146a00f67e0bdbe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f22d79731aa17d6bab7f843fb146a00f67e0bdbe", "patch": "@@ -1,3 +1,43 @@\n+2018-05-08  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* config/aarch64/iterators.md (UNSPEC_COND_LO, UNSPEC_COND_LS)\n+\t(UNSPEC_COND_HI, UNSPEC_COND_HS, UNSPEC_COND_UO): Delete.\n+\t(SVE_INT_CMP, SVE_FP_CMP): New code iterators.\n+\t(cmp_op, sve_imm_con): New code attributes.\n+\t(SVE_COND_INT_CMP, imm_con): Delete.\n+\t(cmp_op): Remove above unspecs from int attribute.\n+\t* config/aarch64/aarch64-sve.md (*vec_cmp<cmp_op>_<mode>): Rename\n+\tto...\n+\t(*cmp<cmp_op><mode>): ...this.  Use UNSPEC_MERGE_PTRUE instead of\n+\tcomparison-specific unspecs.\n+\t(*vec_cmp<cmp_op>_<mode>_ptest): Rename to...\n+\t(*cmp<cmp_op><mode>_ptest): ...this and adjust likewise.\n+\t(*vec_cmp<cmp_op>_<mode>_cc): Rename to...\n+\t(*cmp<cmp_op><mode>_cc): ...this and adjust likewise.\n+\t(*vec_fcm<cmp_op><mode>): Rename to...\n+\t(*fcm<cmp_op><mode>): ...this and adjust likewise.\n+\t(*vec_fcmuo<mode>): Rename to...\n+\t(*fcmuo<mode>): ...this and adjust likewise.\n+\t(*pred_fcm<cmp_op><mode>): New pattern.\n+\t* config/aarch64/aarch64.c (aarch64_emit_unop, aarch64_emit_binop)\n+\t(aarch64_emit_sve_ptrue_op, aarch64_emit_sve_ptrue_op_cc): New\n+\tfunctions.\n+\t(aarch64_unspec_cond_code): Remove handling of LTU, GTU, LEU, GEU\n+\tand UNORDERED.\n+\t(aarch64_gen_unspec_cond, aarch64_emit_unspec_cond): Delete.\n+\t(aarch64_emit_sve_predicated_cond): New function.\n+\t(aarch64_expand_sve_vec_cmp_int): Use aarch64_emit_sve_ptrue_op_cc.\n+\t(aarch64_emit_unspec_cond_or): Replace with...\n+\t(aarch64_emit_sve_or_conds): ...this new function.  Use\n+\taarch64_emit_sve_ptrue_op for the individual comparisons and\n+\taarch64_emit_binop to OR them together.\n+\t(aarch64_emit_inverted_unspec_cond): Replace with...\n+\t(aarch64_emit_sve_inverted_cond): ...this new function.  Use\n+\taarch64_emit_sve_ptrue_op for the comparison and\n+\taarch64_emit_unop to invert the result.\n+\t(aarch64_expand_sve_vec_cmp_float): Update after the above\n+\tchanges.  Use aarch64_emit_sve_ptrue_op for native comparisons.\n+\n 2018-05-07  Nathan Sidwell  <nathan@acm.org>\n \n \t* doc/invoke.texi (C++ Dialect Options): Remove -ffor-scope."}, {"sha": "7a1f58a8091e6b9702048b8a1669bfcdecb65c55", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 50, "deletions": 30, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22d79731aa17d6bab7f843fb146a00f67e0bdbe/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22d79731aa17d6bab7f843fb146a00f67e0bdbe/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=f22d79731aa17d6bab7f843fb146a00f67e0bdbe", "patch": "@@ -1292,32 +1292,35 @@\n   }\n )\n \n-;; Predicated integer comparison.\n-(define_insn \"*vec_cmp<cmp_op>_<mode>\"\n+;; Integer comparisons predicated with a PTRUE.\n+(define_insn \"*cmp<cmp_op><mode>\"\n   [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n \t(unspec:<VPRED>\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n-\t   (match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n-\t   (match_operand:SVE_I 3 \"aarch64_sve_cmp_<imm_con>_operand\" \"<imm_con>, w\")]\n-\t  SVE_COND_INT_CMP))\n+\t   (SVE_INT_CMP:<VPRED>\n+\t     (match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n+\t     (match_operand:SVE_I 3 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))]\n+\t  UNSPEC_MERGE_PTRUE))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_SVE\"\n   \"@\n    cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, #%3\n    cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n )\n \n-;; Predicated integer comparison in which only the flags result is interesting.\n-(define_insn \"*vec_cmp<cmp_op>_<mode>_ptest\"\n+;; Integer comparisons predicated with a PTRUE in which only the flags result\n+;; is interesting.\n+(define_insn \"*cmp<cmp_op><mode>_ptest\"\n   [(set (reg:CC CC_REGNUM)\n \t(compare:CC\n \t  (unspec:SI\n \t    [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n \t     (unspec:<VPRED>\n \t       [(match_dup 1)\n-\t        (match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n-\t\t(match_operand:SVE_I 3 \"aarch64_sve_cmp_<imm_con>_operand\" \"<imm_con>, w\")]\n-\t       SVE_COND_INT_CMP)]\n+\t\t(SVE_INT_CMP:<VPRED>\n+\t\t  (match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n+\t\t  (match_operand:SVE_I 3 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))]\n+\t       UNSPEC_MERGE_PTRUE)]\n \t    UNSPEC_PTEST_PTRUE)\n \t  (const_int 0)))\n    (clobber (match_scratch:<VPRED> 0 \"=Upa, Upa\"))]\n@@ -1327,59 +1330,76 @@\n    cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n )\n \n-;; Predicated comparison in which both the flag and predicate results\n-;; are interesting.\n-(define_insn \"*vec_cmp<cmp_op>_<mode>_cc\"\n+;; Integer comparisons predicated with a PTRUE in which both the flag and\n+;; predicate results are interesting.\n+(define_insn \"*cmp<cmp_op><mode>_cc\"\n   [(set (reg:CC CC_REGNUM)\n \t(compare:CC\n \t  (unspec:SI\n \t    [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n \t     (unspec:<VPRED>\n \t       [(match_dup 1)\n-\t\t(match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n-\t\t(match_operand:SVE_I 3 \"aarch64_sve_cmp_<imm_con>_operand\" \"<imm_con>, w\")]\n-\t       SVE_COND_INT_CMP)]\n+\t\t(SVE_INT_CMP:<VPRED>\n+\t\t  (match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n+\t\t  (match_operand:SVE_I 3 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))]\n+\t       UNSPEC_MERGE_PTRUE)]\n \t    UNSPEC_PTEST_PTRUE)\n \t  (const_int 0)))\n    (set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n \t(unspec:<VPRED>\n \t  [(match_dup 1)\n-\t   (match_dup 2)\n-\t   (match_dup 3)]\n-\t  SVE_COND_INT_CMP))]\n+\t   (SVE_INT_CMP:<VPRED>\n+\t     (match_dup 2)\n+\t     (match_dup 3))]\n+\t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n   \"@\n    cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, #%3\n    cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n )\n \n-;; Predicated floating-point comparison (excluding FCMUO, which doesn't\n-;; allow #0.0 as an operand).\n-(define_insn \"*vec_fcm<cmp_op><mode>\"\n+;; Floating-point comparisons predicated with a PTRUE.\n+(define_insn \"*fcm<cmp_op><mode>\"\n   [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n \t(unspec:<VPRED>\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n-\t   (match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n-\t   (match_operand:SVE_F 3 \"aarch64_simd_reg_or_zero\" \"Dz, w\")]\n-\t  SVE_COND_FP_CMP))]\n+\t   (SVE_FP_CMP:<VPRED>\n+\t     (match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n+\t     (match_operand:SVE_F 3 \"aarch64_simd_reg_or_zero\" \"Dz, w\"))]\n+\t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n   \"@\n    fcm<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, #0.0\n    fcm<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n )\n \n-;; Predicated FCMUO.\n-(define_insn \"*vec_fcmuo<mode>\"\n+(define_insn \"*fcmuo<mode>\"\n   [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa\")\n \t(unspec:<VPRED>\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (match_operand:SVE_F 2 \"register_operand\" \"w\")\n-\t   (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n-\t  UNSPEC_COND_UO))]\n+\t   (unordered:<VPRED>\n+\t     (match_operand:SVE_F 2 \"register_operand\" \"w\")\n+\t     (match_operand:SVE_F 3 \"register_operand\" \"w\"))]\n+\t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n   \"fcmuo\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n )\n \n+;; Predicated floating-point comparisons.  We don't need a version\n+;; of this for unordered comparisons.\n+(define_insn \"*pred_fcm<cmp_op><mode>\"\n+  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n+\t(unspec:<VPRED>\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n+\t   (match_operand:SVE_F 3 \"aarch64_simd_reg_or_zero\" \"Dz, w\")]\n+\t  SVE_COND_FP_CMP))]\n+  \"TARGET_SVE\"\n+  \"@\n+   fcm<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, #0.0\n+   fcm<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n+)\n+\n ;; vcond_mask operand order: true, false, mask\n ;; UNSPEC_SEL operand order: mask, true, false (as for VEC_COND_EXPR)\n ;; SEL operand order:        mask, true, false"}, {"sha": "a2003fe52875f1653d644347bafd7773d1f01e91", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 144, "deletions": 108, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22d79731aa17d6bab7f843fb146a00f67e0bdbe/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22d79731aa17d6bab7f843fb146a00f67e0bdbe/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=f22d79731aa17d6bab7f843fb146a00f67e0bdbe", "patch": "@@ -1873,6 +1873,27 @@ aarch64_emit_move (rtx dest, rtx src)\n \t  : emit_move_insn_1 (dest, src));\n }\n \n+/* Apply UNOPTAB to OP and store the result in DEST.  */\n+\n+static void\n+aarch64_emit_unop (rtx dest, optab unoptab, rtx op)\n+{\n+  rtx tmp = expand_unop (GET_MODE (dest), unoptab, op, dest, 0);\n+  if (dest != tmp)\n+    emit_move_insn (dest, tmp);\n+}\n+\n+/* Apply BINOPTAB to OP0 and OP1 and store the result in DEST.  */\n+\n+static void\n+aarch64_emit_binop (rtx dest, optab binoptab, rtx op0, rtx op1)\n+{\n+  rtx tmp = expand_binop (GET_MODE (dest), binoptab, op0, op1, dest, 0,\n+\t\t\t  OPTAB_DIRECT);\n+  if (dest != tmp)\n+    emit_move_insn (dest, tmp);\n+}\n+\n /* Split a 128-bit move operation into two 64-bit move operations,\n    taking care to handle partial overlap of register to register\n    copies.  Special cases are needed when moving between GP regs and\n@@ -15675,6 +15696,34 @@ aarch64_sve_cmp_operand_p (rtx_code op_code, rtx x)\n     }\n }\n \n+/* Use predicated SVE instructions to implement the equivalent of:\n+\n+     (set TARGET OP)\n+\n+   given that PTRUE is an all-true predicate of the appropriate mode.  */\n+\n+static void\n+aarch64_emit_sve_ptrue_op (rtx target, rtx ptrue, rtx op)\n+{\n+  rtx unspec = gen_rtx_UNSPEC (GET_MODE (target),\n+\t\t\t       gen_rtvec (2, ptrue, op),\n+\t\t\t       UNSPEC_MERGE_PTRUE);\n+  rtx_insn *insn = emit_set_insn (target, unspec);\n+  set_unique_reg_note (insn, REG_EQUAL, copy_rtx (op));\n+}\n+\n+/* Likewise, but also clobber the condition codes.  */\n+\n+static void\n+aarch64_emit_sve_ptrue_op_cc (rtx target, rtx ptrue, rtx op)\n+{\n+  rtx unspec = gen_rtx_UNSPEC (GET_MODE (target),\n+\t\t\t       gen_rtvec (2, ptrue, op),\n+\t\t\t       UNSPEC_MERGE_PTRUE);\n+  rtx_insn *insn = emit_insn (gen_set_clobber_cc (target, unspec));\n+  set_unique_reg_note (insn, REG_EQUAL, copy_rtx (op));\n+}\n+\n /* Return the UNSPEC_COND_* code for comparison CODE.  */\n \n static unsigned int\n@@ -15694,35 +15743,33 @@ aarch64_unspec_cond_code (rtx_code code)\n       return UNSPEC_COND_LE;\n     case GE:\n       return UNSPEC_COND_GE;\n-    case LTU:\n-      return UNSPEC_COND_LO;\n-    case GTU:\n-      return UNSPEC_COND_HI;\n-    case LEU:\n-      return UNSPEC_COND_LS;\n-    case GEU:\n-      return UNSPEC_COND_HS;\n-    case UNORDERED:\n-      return UNSPEC_COND_UO;\n     default:\n       gcc_unreachable ();\n     }\n }\n \n-/* Return an (unspec:PRED_MODE [PRED OP0 OP1] UNSPEC_COND_<X>) expression,\n-   where <X> is the operation associated with comparison CODE.  */\n+/* Emit:\n \n-static rtx\n-aarch64_gen_unspec_cond (rtx_code code, machine_mode pred_mode,\n-\t\t\t rtx pred, rtx op0, rtx op1)\n+      (set TARGET (unspec [PRED OP0 OP1] UNSPEC_COND_<X>))\n+\n+   where <X> is the operation associated with comparison CODE.  This form\n+   of instruction is used when (and (CODE OP0 OP1) PRED) would have different\n+   semantics, such as when PRED might not be all-true and when comparing\n+   inactive lanes could have side effects.  */\n+\n+static void\n+aarch64_emit_sve_predicated_cond (rtx target, rtx_code code,\n+\t\t\t\t  rtx pred, rtx op0, rtx op1)\n {\n-  rtvec vec = gen_rtvec (3, pred, op0, op1);\n-  return gen_rtx_UNSPEC (pred_mode, vec, aarch64_unspec_cond_code (code));\n+  rtx unspec = gen_rtx_UNSPEC (GET_MODE (pred),\n+\t\t\t       gen_rtvec (3, pred, op0, op1),\n+\t\t\t       aarch64_unspec_cond_code (code));\n+  emit_set_insn (target, unspec);\n }\n \n-/* Expand an SVE integer comparison:\n+/* Expand an SVE integer comparison using the SVE equivalent of:\n \n-     TARGET = CODE (OP0, OP1).  */\n+     (set TARGET (CODE OP0 OP1)).  */\n \n void\n aarch64_expand_sve_vec_cmp_int (rtx target, rtx_code code, rtx op0, rtx op1)\n@@ -15734,78 +15781,53 @@ aarch64_expand_sve_vec_cmp_int (rtx target, rtx_code code, rtx op0, rtx op1)\n     op1 = force_reg (data_mode, op1);\n \n   rtx ptrue = force_reg (pred_mode, CONSTM1_RTX (pred_mode));\n-  rtx unspec = aarch64_gen_unspec_cond (code, pred_mode, ptrue, op0, op1);\n-  emit_insn (gen_set_clobber_cc (target, unspec));\n-}\n-\n-/* Emit an instruction:\n-\n-      (set TARGET (unspec:PRED_MODE [PRED OP0 OP1] UNSPEC_COND_<X>))\n-\n-   where <X> is the operation associated with comparison CODE.  */\n-\n-static void\n-aarch64_emit_unspec_cond (rtx target, rtx_code code, machine_mode pred_mode,\n-\t\t\t  rtx pred, rtx op0, rtx op1)\n-{\n-  rtx unspec = aarch64_gen_unspec_cond (code, pred_mode, pred, op0, op1);\n-  emit_set_insn (target, unspec);\n+  rtx cond = gen_rtx_fmt_ee (code, pred_mode, op0, op1);\n+  aarch64_emit_sve_ptrue_op_cc (target, ptrue, cond);\n }\n \n-/* Emit:\n+/* Emit the SVE equivalent of:\n \n-      (set TMP1 (unspec:PRED_MODE [PTRUE OP0 OP1] UNSPEC_COND_<X1>))\n-      (set TMP2 (unspec:PRED_MODE [PTRUE OP0 OP1] UNSPEC_COND_<X2>))\n-      (set TARGET (and:PRED_MODE (ior:PRED_MODE TMP1 TMP2) PTRUE))\n+      (set TMP1 (CODE1 OP0 OP1))\n+      (set TMP2 (CODE2 OP0 OP1))\n+      (set TARGET (ior:PRED_MODE TMP1 TMP2))\n \n-   where <Xi> is the operation associated with comparison CODEi.  */\n+   PTRUE is an all-true predicate with the same mode as TARGET.  */\n \n static void\n-aarch64_emit_unspec_cond_or (rtx target, rtx_code code1, rtx_code code2,\n-\t\t\t     machine_mode pred_mode, rtx ptrue,\n-\t\t\t     rtx op0, rtx op1)\n+aarch64_emit_sve_or_conds (rtx target, rtx_code code1, rtx_code code2,\n+\t\t\t   rtx ptrue, rtx op0, rtx op1)\n {\n+  machine_mode pred_mode = GET_MODE (ptrue);\n   rtx tmp1 = gen_reg_rtx (pred_mode);\n-  aarch64_emit_unspec_cond (tmp1, code1, pred_mode, ptrue, op0, op1);\n+  aarch64_emit_sve_ptrue_op (tmp1, ptrue,\n+\t\t\t     gen_rtx_fmt_ee (code1, pred_mode, op0, op1));\n   rtx tmp2 = gen_reg_rtx (pred_mode);\n-  aarch64_emit_unspec_cond (tmp2, code2, pred_mode, ptrue, op0, op1);\n-  emit_set_insn (target, gen_rtx_AND (pred_mode,\n-\t\t\t\t      gen_rtx_IOR (pred_mode, tmp1, tmp2),\n-\t\t\t\t      ptrue));\n+  aarch64_emit_sve_ptrue_op (tmp2, ptrue,\n+\t\t\t     gen_rtx_fmt_ee (code2, pred_mode, op0, op1));\n+  aarch64_emit_binop (target, ior_optab, tmp1, tmp2);\n }\n \n-/* If CAN_INVERT_P, emit an instruction:\n+/* Emit the SVE equivalent of:\n \n-      (set TARGET (unspec:PRED_MODE [PRED OP0 OP1] UNSPEC_COND_<X>))\n+      (set TMP (CODE OP0 OP1))\n+      (set TARGET (not TMP))\n \n-   where <X> is the operation associated with comparison CODE.  Otherwise\n-   emit:\n-\n-      (set TMP (unspec:PRED_MODE [PRED OP0 OP1] UNSPEC_COND_<X>))\n-      (set TARGET (and:PRED_MODE (not:PRED_MODE TMP) PTRUE))\n-\n-   where the second instructions sets TARGET to the inverse of TMP.  */\n+   PTRUE is an all-true predicate with the same mode as TARGET.  */\n \n static void\n-aarch64_emit_inverted_unspec_cond (rtx target, rtx_code code,\n-\t\t\t\t   machine_mode pred_mode, rtx ptrue, rtx pred,\n-\t\t\t\t   rtx op0, rtx op1, bool can_invert_p)\n+aarch64_emit_sve_inverted_cond (rtx target, rtx ptrue, rtx_code code,\n+\t\t\t\trtx op0, rtx op1)\n {\n-  if (can_invert_p)\n-    aarch64_emit_unspec_cond (target, code, pred_mode, pred, op0, op1);\n-  else\n-    {\n-      rtx tmp = gen_reg_rtx (pred_mode);\n-      aarch64_emit_unspec_cond (tmp, code, pred_mode, pred, op0, op1);\n-      emit_set_insn (target, gen_rtx_AND (pred_mode,\n-\t\t\t\t\t  gen_rtx_NOT (pred_mode, tmp),\n-\t\t\t\t\t  ptrue));\n-    }\n+  machine_mode pred_mode = GET_MODE (ptrue);\n+  rtx tmp = gen_reg_rtx (pred_mode);\n+  aarch64_emit_sve_ptrue_op (tmp, ptrue,\n+\t\t\t     gen_rtx_fmt_ee (code, pred_mode, op0, op1));\n+  aarch64_emit_unop (target, one_cmpl_optab, tmp);\n }\n \n-/* Expand an SVE floating-point comparison:\n+/* Expand an SVE floating-point comparison using the SVE equivalent of:\n \n-     TARGET = CODE (OP0, OP1)\n+     (set TARGET (CODE OP0 OP1))\n \n    If CAN_INVERT_P is true, the caller can also handle inverted results;\n    return true if the result is in fact inverted.  */\n@@ -15823,69 +15845,83 @@ aarch64_expand_sve_vec_cmp_float (rtx target, rtx_code code,\n     case UNORDERED:\n       /* UNORDERED has no immediate form.  */\n       op1 = force_reg (data_mode, op1);\n-      aarch64_emit_unspec_cond (target, code, pred_mode, ptrue, op0, op1);\n-      return false;\n-\n+      /* fall through */\n     case LT:\n     case LE:\n     case GT:\n     case GE:\n     case EQ:\n     case NE:\n-      /* There is native support for the comparison.  */\n-      aarch64_emit_unspec_cond (target, code, pred_mode, ptrue, op0, op1);\n-      return false;\n-\n-    case ORDERED:\n-      /* There is native support for the inverse comparison.  */\n-      op1 = force_reg (data_mode, op1);\n-      aarch64_emit_inverted_unspec_cond (target, UNORDERED,\n-\t\t\t\t\t pred_mode, ptrue, ptrue, op0, op1,\n-\t\t\t\t\t can_invert_p);\n-      return can_invert_p;\n+      {\n+\t/* There is native support for the comparison.  */\n+\trtx cond = gen_rtx_fmt_ee (code, pred_mode, op0, op1);\n+\taarch64_emit_sve_ptrue_op (target, ptrue, cond);\n+\treturn false;\n+      }\n \n     case LTGT:\n       /* This is a trapping operation (LT or GT).  */\n-      aarch64_emit_unspec_cond_or (target, LT, GT, pred_mode, ptrue, op0, op1);\n+      aarch64_emit_sve_or_conds (target, LT, GT, ptrue, op0, op1);\n       return false;\n \n     case UNEQ:\n       if (!flag_trapping_math)\n \t{\n \t  /* This would trap for signaling NaNs.  */\n \t  op1 = force_reg (data_mode, op1);\n-\t  aarch64_emit_unspec_cond_or (target, UNORDERED, EQ,\n-\t\t\t\t       pred_mode, ptrue, op0, op1);\n+\t  aarch64_emit_sve_or_conds (target, UNORDERED, EQ, ptrue, op0, op1);\n \t  return false;\n \t}\n       /* fall through */\n-\n     case UNLT:\n     case UNLE:\n     case UNGT:\n     case UNGE:\n-      {\n-\trtx ordered = ptrue;\n-\tif (flag_trapping_math)\n-\t  {\n-\t    /* Only compare the elements that are known to be ordered.  */\n-\t    ordered = gen_reg_rtx (pred_mode);\n-\t    op1 = force_reg (data_mode, op1);\n-\t    aarch64_emit_inverted_unspec_cond (ordered, UNORDERED, pred_mode,\n-\t\t\t\t\t       ptrue, ptrue, op0, op1, false);\n-\t  }\n-\tif (code == UNEQ)\n-\t  code = NE;\n-\telse\n-\t  code = reverse_condition_maybe_unordered (code);\n-\taarch64_emit_inverted_unspec_cond (target, code, pred_mode, ptrue,\n-\t\t\t\t\t   ordered, op0, op1, can_invert_p);\n-\treturn can_invert_p;\n-      }\n+      if (flag_trapping_math)\n+\t{\n+\t  /* Work out which elements are ordered.  */\n+\t  rtx ordered = gen_reg_rtx (pred_mode);\n+\t  op1 = force_reg (data_mode, op1);\n+\t  aarch64_emit_sve_inverted_cond (ordered, ptrue, UNORDERED, op0, op1);\n+\n+\t  /* Test the opposite condition for the ordered elements,\n+\t     then invert the result.  */\n+\t  if (code == UNEQ)\n+\t    code = NE;\n+\t  else\n+\t    code = reverse_condition_maybe_unordered (code);\n+\t  if (can_invert_p)\n+\t    {\n+\t      aarch64_emit_sve_predicated_cond (target, code,\n+\t\t\t\t\t\tordered, op0, op1);\n+\t      return true;\n+\t    }\n+\t  rtx tmp = gen_reg_rtx (pred_mode);\n+\t  aarch64_emit_sve_predicated_cond (tmp, code, ordered, op0, op1);\n+\t  aarch64_emit_unop (target, one_cmpl_optab, tmp);\n+\t  return false;\n+\t}\n+      break;\n+\n+    case ORDERED:\n+      /* ORDERED has no immediate form.  */\n+      op1 = force_reg (data_mode, op1);\n+      break;\n \n     default:\n       gcc_unreachable ();\n     }\n+\n+  /* There is native support for the inverse comparison.  */\n+  code = reverse_condition_maybe_unordered (code);\n+  if (can_invert_p)\n+    {\n+      rtx cond = gen_rtx_fmt_ee (code, pred_mode, op0, op1);\n+      aarch64_emit_sve_ptrue_op (target, ptrue, cond);\n+      return true;\n+    }\n+  aarch64_emit_sve_inverted_cond (target, ptrue, code, op0, op1);\n+  return false;\n }\n \n /* Expand an SVE vcond pattern with operands OPS.  DATA_MODE is the mode"}, {"sha": "bcedb86291fae367abd50f98c8b76c304d195051", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f22d79731aa17d6bab7f843fb146a00f67e0bdbe/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f22d79731aa17d6bab7f843fb146a00f67e0bdbe/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=f22d79731aa17d6bab7f843fb146a00f67e0bdbe", "patch": "@@ -455,11 +455,6 @@\n     UNSPEC_COND_NE\t; Used in aarch64-sve.md.\n     UNSPEC_COND_GE\t; Used in aarch64-sve.md.\n     UNSPEC_COND_GT\t; Used in aarch64-sve.md.\n-    UNSPEC_COND_LO\t; Used in aarch64-sve.md.\n-    UNSPEC_COND_LS\t; Used in aarch64-sve.md.\n-    UNSPEC_COND_HS\t; Used in aarch64-sve.md.\n-    UNSPEC_COND_HI\t; Used in aarch64-sve.md.\n-    UNSPEC_COND_UO\t; Used in aarch64-sve.md.\n     UNSPEC_LASTB\t; Used in aarch64-sve.md.\n ])\n \n@@ -1189,6 +1184,12 @@\n ;; SVE floating-point unary operations.\n (define_code_iterator SVE_FP_UNARY [neg abs sqrt])\n \n+;; SVE integer comparisons.\n+(define_code_iterator SVE_INT_CMP [lt le eq ne ge gt ltu leu geu gtu])\n+\n+;; SVE floating-point comparisons.\n+(define_code_iterator SVE_FP_CMP [lt le eq ne ge gt])\n+\n ;; -------------------------------------------------------------------\n ;; Code Attributes\n ;; -------------------------------------------------------------------\n@@ -1252,6 +1253,18 @@\n \t\t\t(ltu \"LTU\") (leu \"LEU\") (ne \"NE\") (geu \"GEU\")\n \t\t\t(gtu \"GTU\")])\n \n+;; The AArch64 condition associated with an rtl comparison code.\n+(define_code_attr cmp_op [(lt \"lt\")\n+\t\t\t  (le \"le\")\n+\t\t\t  (eq \"eq\")\n+\t\t\t  (ne \"ne\")\n+\t\t\t  (ge \"ge\")\n+\t\t\t  (gt \"gt\")\n+\t\t\t  (ltu \"lo\")\n+\t\t\t  (leu \"ls\")\n+\t\t\t  (geu \"hs\")\n+\t\t\t  (gtu \"hi\")])\n+\n (define_code_attr fix_trunc_optab [(fix \"fix_trunc\")\n \t\t\t\t   (unsigned_fix \"fixuns_trunc\")])\n \n@@ -1358,6 +1371,18 @@\n \t\t\t     (abs \"fabs\")\n \t\t\t     (sqrt \"fsqrt\")])\n \n+;; The SVE immediate constraint to use for an rtl code.\n+(define_code_attr sve_imm_con [(eq \"vsc\")\n+\t\t\t       (ne \"vsc\")\n+\t\t\t       (lt \"vsc\")\n+\t\t\t       (ge \"vsc\")\n+\t\t\t       (le \"vsc\")\n+\t\t\t       (gt \"vsc\")\n+\t\t\t       (ltu \"vsd\")\n+\t\t\t       (leu \"vsd\")\n+\t\t\t       (geu \"vsd\")\n+\t\t\t       (gtu \"vsd\")])\n+\n ;; -------------------------------------------------------------------\n ;; Int Iterators.\n ;; -------------------------------------------------------------------\n@@ -1483,12 +1508,6 @@\n \n (define_int_iterator SVE_COND_FP_OP [UNSPEC_COND_ADD UNSPEC_COND_SUB])\n \n-(define_int_iterator SVE_COND_INT_CMP [UNSPEC_COND_LT UNSPEC_COND_LE\n-\t\t\t\t       UNSPEC_COND_EQ UNSPEC_COND_NE\n-\t\t\t\t       UNSPEC_COND_GE UNSPEC_COND_GT\n-\t\t\t\t       UNSPEC_COND_LO UNSPEC_COND_LS\n-\t\t\t\t       UNSPEC_COND_HS UNSPEC_COND_HI])\n-\n (define_int_iterator SVE_COND_FP_CMP [UNSPEC_COND_LT UNSPEC_COND_LE\n \t\t\t\t      UNSPEC_COND_EQ UNSPEC_COND_NE\n \t\t\t\t      UNSPEC_COND_GE UNSPEC_COND_GT])\n@@ -1730,23 +1749,7 @@\n \t\t\t (UNSPEC_COND_EQ \"eq\")\n \t\t\t (UNSPEC_COND_NE \"ne\")\n \t\t\t (UNSPEC_COND_GE \"ge\")\n-\t\t\t (UNSPEC_COND_GT \"gt\")\n-\t\t\t (UNSPEC_COND_LO \"lo\")\n-\t\t\t (UNSPEC_COND_LS \"ls\")\n-\t\t\t (UNSPEC_COND_HS \"hs\")\n-\t\t\t (UNSPEC_COND_HI \"hi\")])\n-\n-;; The constraint to use for an UNSPEC_COND_<xx>.\n-(define_int_attr imm_con [(UNSPEC_COND_EQ \"vsc\")\n-\t\t\t  (UNSPEC_COND_NE \"vsc\")\n-\t\t\t  (UNSPEC_COND_LT \"vsc\")\n-\t\t\t  (UNSPEC_COND_GE \"vsc\")\n-\t\t\t  (UNSPEC_COND_LE \"vsc\")\n-\t\t\t  (UNSPEC_COND_GT \"vsc\")\n-\t\t\t  (UNSPEC_COND_LO \"vsd\")\n-\t\t\t  (UNSPEC_COND_LS \"vsd\")\n-\t\t\t  (UNSPEC_COND_HS \"vsd\")\n-\t\t\t  (UNSPEC_COND_HI \"vsd\")])\n+\t\t\t (UNSPEC_COND_GT \"gt\")])\n \n (define_int_attr sve_int_op [(UNSPEC_COND_ADD \"add\")\n \t\t\t     (UNSPEC_COND_SUB \"sub\")"}]}