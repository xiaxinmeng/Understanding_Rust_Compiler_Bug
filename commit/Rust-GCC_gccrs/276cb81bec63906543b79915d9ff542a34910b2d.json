{"sha": "276cb81bec63906543b79915d9ff542a34910b2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc2Y2I4MWJlYzYzOTA2NTQzYjc5OTE1ZDlmZjU0MmEzNDkxMGIyZA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-02T12:38:41Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-03-02T12:38:41Z"}, "message": "c++: Delay normalizing nested requirements until satisfaction\n\nThis sets up the functionality for controlling the initial set of\ntemplate parameters to pass to normalization when dealing with a\nconstraint-expression that is not associated with some constrained\ndeclaration, for instance when normalizing a nested requirement of a\nrequires expression, or the constraints on a placeholder type.\n\nThe main new ingredient here is the data member norm_info::initial_parms\nwhich can be set by callers of the normalization routines to communicate\nthe in-scope template parameters for the supplied constraint-expression,\nrather than always falling back to using current_template_parms.\n\nThis patch then uses this functionality in our handling of nested\nrequirements so that we can delay normalizing them until needed for\nsatisfaction.  We currently immediately normalize nested requirements at\nparse time, where we have the necessary template context, and cache the\nnormal form in their TREE_TYPE node.  With this patch, we now delay\nnormalization until needed (as with other constraint expressions), and\ninstead store the current value of current_template_parms in their\nTREE_TYPE node (which we use to restore the template context at\nnormalization time).\n\nIn the subsequent patch, this functionality will also be used to\nnormalize placeholder type constraints during auto deduction.\n\ngcc/cp/ChangeLog:\n\n\t* constraint.cc (build_parameter_mapping): Rely on the caller to\n\tdetermine the in-scope template parameters.\n\t(norm_info::norm_info): Delegate the tsubst_flags_t constructor\n\tto the two-parameter constructor.  In the two-parameter\n\tconstructor, fold in the definition of make_context, set\n\tinitial_parms appropriately, and don't set the now-removed\n\torig_decl member.\n\t(norm_info::make_context): Remove, now that its only use is\n\tinlined into the caller.\n\t(norm_info::update_context): Adjust call to\n\tbuild_parameter_mapping to pass in the relevant set of in-scope\n\ttemplate parameters.\n\t(norm_info::ctx_parms): Define this member function.\n\t(norm_info::context): Initialize to NULL_TREE.\n\t(norm_info::orig_decl): Remove this data member.\n\t(norm_info::initial_parms): Define this data member.\n\t(normalize_atom): Adjust call to build_parameter_mapping to pass\n\tin the relevant set of in-scope template parameters.  Use\n\tinfo.initial_parms instead of info.orig_decl.\n\t(normalize_constraint_expression): Take a norm_info object\n\tinstead of a bool.  Cache the result of normalization.\n\t(tsubst_nested_requirement): Call satisfy_constraint_expression\n\tinstead of satisfy_constraint, so that we normalize on demand.\n\t(satisfy_constraint_expression): Handle a NESTED_REQ argument.\n\tAdjust call to normalize_constraint_expression.\n\t(finish_nested_requirement): Set the TREE_TYPE of the NESTED_REQ\n\tto current_template_parms.\n\t(diagnose_nested_requirements): Go through\n\tsatisfy_constraint_expression, as with tsubst_nested_requirement.", "tree": {"sha": "ed9f9233bc9f3919bd45d385c9edb03775e5362a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed9f9233bc9f3919bd45d385c9edb03775e5362a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/276cb81bec63906543b79915d9ff542a34910b2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/276cb81bec63906543b79915d9ff542a34910b2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/276cb81bec63906543b79915d9ff542a34910b2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/276cb81bec63906543b79915d9ff542a34910b2d/comments", "author": null, "committer": null, "parents": [{"sha": "04b10596fe2fec1aa6652c15fd389087a78a235f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04b10596fe2fec1aa6652c15fd389087a78a235f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04b10596fe2fec1aa6652c15fd389087a78a235f"}], "stats": {"total": 138, "additions": 72, "deletions": 66}, "files": [{"sha": "fcb249a642fb0e8de06d2c6f7781e9afc23349fc", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 72, "deletions": 66, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/276cb81bec63906543b79915d9ff542a34910b2d/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/276cb81bec63906543b79915d9ff542a34910b2d/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=276cb81bec63906543b79915d9ff542a34910b2d", "patch": "@@ -133,7 +133,7 @@ struct sat_info : subst_info\n   bool diagnose_unsatisfaction;\n };\n \n-static tree satisfy_constraint (tree, tree, sat_info);\n+static tree satisfy_constraint_expression (tree, tree, sat_info);\n \n /* True if T is known to be some type other than bool. Note that this\n    is false for dependent types and errors.  */\n@@ -594,26 +594,12 @@ map_arguments (tree parms, tree args)\n   return parms;\n }\n \n-/* Build the parameter mapping for EXPR using ARGS.  */\n+/* Build the parameter mapping for EXPR using ARGS, where CTX_PARMS\n+   are the template parameters in scope for EXPR.  */\n \n static tree\n-build_parameter_mapping (tree expr, tree args, tree decl)\n+build_parameter_mapping (tree expr, tree args, tree ctx_parms)\n {\n-  tree ctx_parms = NULL_TREE;\n-  if (decl)\n-    {\n-      gcc_assert (TREE_CODE (decl) == TEMPLATE_DECL);\n-      ctx_parms = DECL_TEMPLATE_PARMS (decl);\n-    }\n-  else if (current_template_parms)\n-    {\n-      /* TODO: This should probably be the only case, but because the\n-\t point of declaration of concepts is currently set after the\n-\t initializer, the template parameter lists are not available\n-\t when normalizing concept definitions, hence the case above.  */\n-      ctx_parms = current_template_parms;\n-    }\n-\n   tree parms = find_template_parameters (expr, ctx_parms);\n   tree map = map_arguments (parms, args);\n   return map;\n@@ -645,53 +631,63 @@ parameter_mapping_equivalent_p (tree t1, tree t2)\n \n struct norm_info : subst_info\n {\n-  explicit norm_info (tsubst_flags_t complain)\n-    : subst_info (tf_warning_or_error | complain, NULL_TREE),\n-      context()\n+  explicit norm_info (tsubst_flags_t cmp)\n+    : norm_info (NULL_TREE, cmp)\n   {}\n \n   /* Construct a top-level context for DECL.  */\n \n   norm_info (tree in_decl, tsubst_flags_t complain)\n-    : subst_info (tf_warning_or_error | complain, in_decl),\n-      context (make_context (in_decl)),\n-      orig_decl (in_decl)\n-  {}\n-\n-  bool generate_diagnostics() const\n+    : subst_info (tf_warning_or_error | complain, in_decl)\n   {\n-    return complain & tf_norm;\n+    if (in_decl)\n+      {\n+\tinitial_parms = DECL_TEMPLATE_PARMS (in_decl);\n+\tif (generate_diagnostics ())\n+\t  context = build_tree_list (NULL_TREE, in_decl);\n+      }\n+    else\n+      initial_parms = current_template_parms;\n   }\n \n-  tree make_context(tree in_decl)\n+  bool generate_diagnostics() const\n   {\n-    if (generate_diagnostics ())\n-      return build_tree_list (NULL_TREE, in_decl);\n-    return NULL_TREE;\n+    return complain & tf_norm;\n   }\n \n   void update_context(tree expr, tree args)\n   {\n     if (generate_diagnostics ())\n       {\n-\ttree map = build_parameter_mapping (expr, args, in_decl);\n+\ttree map = build_parameter_mapping (expr, args, ctx_parms ());\n \tcontext = tree_cons (map, expr, context);\n       }\n     in_decl = get_concept_check_template (expr);\n   }\n \n+  /* Returns the template parameters that are in scope for the current\n+     normalization context.  */\n+\n+  tree ctx_parms()\n+  {\n+    if (in_decl)\n+      return DECL_TEMPLATE_PARMS (in_decl);\n+    else\n+      return initial_parms;\n+  }\n+\n   /* Provides information about the source of a constraint. This is a\n      TREE_LIST whose VALUE is either a concept check or a constrained\n      declaration. The PURPOSE, for concept checks is a parameter mapping\n      for that check.  */\n \n-  tree context;\n+  tree context = NULL_TREE;\n \n   /* The declaration whose constraints we're normalizing.  The targets\n      of the parameter mapping of each atom will be in terms of the\n      template parameters of ORIG_DECL.  */\n \n-  tree orig_decl = NULL_TREE;\n+  tree initial_parms = NULL_TREE;\n };\n \n static tree normalize_expression (tree, tree, norm_info);\n@@ -773,7 +769,7 @@ normalize_atom (tree t, tree args, norm_info info)\n     return normalize_concept_check (t, args, info);\n \n   /* Build the parameter mapping for the atom.  */\n-  tree map = build_parameter_mapping (t, args, info.in_decl);\n+  tree map = build_parameter_mapping (t, args, info.ctx_parms ());\n \n   /* Build a new info object for the atom.  */\n   tree ci = build_tree_list (t, info.context);\n@@ -803,10 +799,8 @@ normalize_atom (tree t, tree args, norm_info info)\n \t      tree target = TREE_PURPOSE (node);\n \t      TREE_VEC_ELT (targets, i++) = target;\n \t    }\n-\t  tree ctx_parms = (info.orig_decl\n-\t\t\t    ? DECL_TEMPLATE_PARMS (info.orig_decl)\n-\t\t\t    : current_template_parms);\n-\t  tree target_parms = find_template_parameters (targets, ctx_parms);\n+\t  tree target_parms = find_template_parameters (targets,\n+\t\t\t\t\t\t\tinfo.initial_parms);\n \t  TREE_TYPE (map) = target_parms;\n \t}\n \n@@ -983,14 +977,22 @@ normalize_nontemplate_requirements (tree decl, bool diag = false)\n /* Normalize an EXPR as a constraint.  */\n \n static tree\n-normalize_constraint_expression (tree expr, bool diag)\n+normalize_constraint_expression (tree expr, norm_info info)\n {\n   if (!expr || expr == error_mark_node)\n     return expr;\n+\n+  if (!info.generate_diagnostics ())\n+    if (tree *p = hash_map_safe_get (normalized_map, expr))\n+      return *p;\n+\n   ++processing_template_decl;\n-  norm_info info (diag ? tf_norm : tf_none);\n   tree norm = get_normalized_constraints (expr, info);\n   --processing_template_decl;\n+\n+  if (!info.generate_diagnostics ())\n+    hash_map_safe_put<hm_ggc> (normalized_map, expr, norm);\n+\n   return norm;\n }\n \n@@ -2086,16 +2088,14 @@ tsubst_compound_requirement (tree t, tree args, subst_info info)\n static tree\n tsubst_nested_requirement (tree t, tree args, subst_info info)\n {\n-  /* Perform satisfaction quietly with the regular normal form.  */\n+  /* Perform satisfaction quietly first.  */\n   sat_info quiet (tf_none, info.in_decl);\n-  tree norm = TREE_VALUE (TREE_TYPE (t));\n-  tree diag_norm = TREE_PURPOSE (TREE_TYPE (t));\n-  tree result = satisfy_constraint (norm, args, quiet);\n+  tree result = satisfy_constraint_expression (t, args, quiet);\n   if (result == error_mark_node)\n     {\n-      /* Replay the error using the diagnostic normal form.  */\n+      /* Replay the error.  */\n       sat_info noisy (tf_warning_or_error, info.in_decl);\n-      satisfy_constraint (diag_norm, args, noisy);\n+      satisfy_constraint_expression (t, args, noisy);\n     }\n   if (result != boolean_true_node)\n     return error_mark_node;\n@@ -3040,8 +3040,22 @@ satisfy_constraint_expression (tree t, tree args, sat_info info)\n       tree tmpl = get_concept_check_template (id);\n       norm = normalize_concept_definition (tmpl, info.noisy ());\n     }\n+  else if (TREE_CODE (t) == NESTED_REQ)\n+    {\n+      norm_info ninfo (info.noisy () ? tf_norm : tf_none);\n+      /* The TREE_TYPE contains the set of template parameters that were in\n+\t scope for this nested requirement; use them as the initial template\n+\t parameters for normalization.  */\n+      ninfo.initial_parms = TREE_TYPE (t);\n+      norm = normalize_constraint_expression (TREE_OPERAND (t, 0), ninfo);\n+    }\n+  else if (EXPR_P (t))\n+    {\n+      norm_info ninfo (info.noisy () ? tf_norm : tf_none);\n+      norm = normalize_constraint_expression (t, ninfo);\n+    }\n   else\n-    norm = normalize_constraint_expression (t, info.noisy ());\n+    gcc_unreachable ();\n \n   /* Perform satisfaction.  */\n   return satisfy_constraint (norm, args, info);\n@@ -3301,15 +3315,9 @@ finish_compound_requirement (location_t loc, tree expr, tree type, bool noexcept\n tree\n finish_nested_requirement (location_t loc, tree expr)\n {\n-  /* We need to normalize the constraints now, at parse time, while\n-     we have the necessary template context.  We normalize twice,\n-     once without diagnostic information and once with, which we'll\n-     later use for quiet and noisy satisfaction respectively.  */\n-  tree norm = normalize_constraint_expression (expr, /*diag=*/false);\n-  tree diag_norm = normalize_constraint_expression (expr, /*diag=*/true);\n-\n-  /* Build the constraint, saving its two normalizations as its type.  */\n-  tree r = build1 (NESTED_REQ, build_tree_list (diag_norm, norm), expr);\n+  /* Build the requirement, saving the set of in-scope template\n+     parameters as its type.  */\n+  tree r = build1 (NESTED_REQ, current_template_parms, expr);\n   SET_EXPR_LOCATION (r, loc);\n   return r;\n }\n@@ -3710,23 +3718,21 @@ diagnose_type_requirement (tree req, tree args, tree in_decl)\n static void\n diagnose_nested_requirement (tree req, tree args)\n {\n-  /* Quietly check for satisfaction first using the regular normal form.\n-     We can elaborate details later if needed.  */\n-  tree norm = TREE_VALUE (TREE_TYPE (req));\n-  tree diag_norm = TREE_PURPOSE (TREE_TYPE (req));\n-  sat_info info (tf_none, NULL_TREE);\n-  tree result = satisfy_constraint (norm, args, info);\n+  /* Quietly check for satisfaction first.  */\n+  sat_info quiet (tf_none, NULL_TREE);\n+  tree result = satisfy_constraint_expression (req, args, quiet);\n   if (result == boolean_true_node)\n     return;\n \n   tree expr = TREE_OPERAND (req, 0);\n   location_t loc = cp_expr_location (expr);\n   if (diagnosing_failed_constraint::replay_errors_p ())\n     {\n-      /* Replay the substitution error using the diagnostic normal form.  */\n+      /* Replay the substitution error with re-normalized requirements.  */\n       inform (loc, \"nested requirement %qE is not satisfied, because\", expr);\n+\n       sat_info noisy (tf_warning_or_error, NULL_TREE, /*diag_unsat=*/true);\n-      satisfy_constraint (diag_norm, args, noisy);\n+      satisfy_constraint_expression (req, args, noisy);\n     }\n   else\n     inform (loc, \"nested requirement %qE is not satisfied\", expr);"}]}