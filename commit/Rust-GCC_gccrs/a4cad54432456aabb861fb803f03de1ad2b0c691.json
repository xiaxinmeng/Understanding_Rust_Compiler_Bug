{"sha": "a4cad54432456aabb861fb803f03de1ad2b0c691", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRjYWQ1NDQzMjQ1NmFhYmI4NjFmYjgwM2YwM2RlMWFkMmIwYzY5MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-07-30T23:38:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-07-30T23:38:26Z"}, "message": "genattrtab.c (struct insn_def): Add lineno member.\n\n        * genattrtab.c (struct insn_def): Add lineno member.\n        (struct insn_ent): Likewise.\n        (struct attr_desc): Likewise.\n        (struct delay_desc): Likewise.\n        (struct function_unit_op): Likewise.\n        (struct function_unit): Likewise.\n        (check_attr_value): Use message_with_line.\n        (check_defs): Likewise.\n        (expand_units): Likewise.\n        (check_attr_test): Take a lineno argument.\n        (gen_attr): Likewise.\n        (gen_insn): Likewise.\n        (gen_delay): Likewise.\n        (gen_unit): Likewise.\n        (main): Give it to them.\n        (convert_set_attr_alternative): Take an insn_def argument\n        instead of num_alt and insn_index.\n        (convert_set_attr): Likewise.\n        (write_test_expr): Protect INSN_ADDRESSES load\n        with INSN_ADDRESSES_SET_P.\n\nFrom-SVN: r35356", "tree": {"sha": "573b498c97c10c5e0352661da11f25b8e0d39d36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/573b498c97c10c5e0352661da11f25b8e0d39d36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4cad54432456aabb861fb803f03de1ad2b0c691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4cad54432456aabb861fb803f03de1ad2b0c691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4cad54432456aabb861fb803f03de1ad2b0c691", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4cad54432456aabb861fb803f03de1ad2b0c691/comments", "author": null, "committer": null, "parents": [{"sha": "722bed0f9c974333c40bb3a6ed99c3a3f25162d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/722bed0f9c974333c40bb3a6ed99c3a3f25162d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/722bed0f9c974333c40bb3a6ed99c3a3f25162d0"}], "stats": {"total": 278, "additions": 189, "deletions": 89}, "files": [{"sha": "aedd1d04877f7fb741a3b54bcb9edd08a42d97d9", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 189, "deletions": 89, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4cad54432456aabb861fb803f03de1ad2b0c691/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4cad54432456aabb861fb803f03de1ad2b0c691/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=a4cad54432456aabb861fb803f03de1ad2b0c691", "patch": "@@ -130,10 +130,11 @@ struct obstack *temp_obstack = &obstack2;\n \n struct insn_def\n {\n-  int insn_code;\t\t/* Instruction number.  */\n-  int insn_index;\t\t/* Expression numer in file, for errors.  */\n   struct insn_def *next;\t/* Next insn in chain.  */\n   rtx def;\t\t\t/* The DEFINE_...  */\n+  int insn_code;\t\t/* Instruction number.  */\n+  int insn_index;\t\t/* Expression numer in file, for errors.  */\n+  int lineno;\t\t\t/* Line number.  */\n   int num_alternatives;\t\t/* Number of alternatives.  */\n   int vec_idx;\t\t\t/* Index of attribute vector in `def'.  */\n };\n@@ -144,9 +145,10 @@ struct insn_def\n \n struct insn_ent\n {\n+  struct insn_ent *next;\t/* Next in chain.  */\n   int insn_code;\t\t/* Instruction number.  */\n   int insn_index;\t\t/* Index of definition in file */\n-  struct insn_ent *next;\t/* Next in chain.  */\n+  int lineno;\t\t\t/* Line number.  */\n };\n \n /* Each value of an attribute (either constant or computed) is assigned a\n@@ -177,6 +179,7 @@ struct attr_desc\n   unsigned blockage_p\t: 1;\t/* this is the blockage range function */\n   struct attr_value *first_value; /* First value of this attribute.  */\n   struct attr_value *default_val; /* Default value for this attribute.  */\n+  int lineno;\t\t\t/* Line number.  */\n };\n \n #define NULL_ATTR (struct attr_desc *) NULL\n@@ -196,6 +199,7 @@ struct delay_desc\n   rtx def;\t\t\t/* DEFINE_DELAY expression.  */\n   struct delay_desc *next;\t/* Next DEFINE_DELAY.  */\n   int num;\t\t\t/* Number of DEFINE_DELAY, starting at 1.  */\n+  int lineno;\t\t\t/* Line number.  */\n };\n \n /* Record information about each DEFINE_FUNCTION_UNIT.  */\n@@ -209,6 +213,7 @@ struct function_unit_op\n   int issue_delay;\t\t/* Cost until unit can accept another insn.  */\n   rtx conflict_exp;\t\t/* Expression TRUE for insns incurring issue delay.  */\n   rtx issue_exp;\t\t/* Expression computing issue delay.  */\n+  int lineno;\t\t\t/* Line number.  */\n };\n \n /* Record information about each function unit mentioned in a\n@@ -231,6 +236,7 @@ struct function_unit\n   rtx default_cost;\t\t/* Conflict cost, if constant.  */\n   struct range issue_delay;\t/* Range of issue delay values.  */\n   int max_blockage;\t\t/* Maximum time an insn blocks the unit.  */\n+  int first_lineno;\t\t/* First seen line number.  */\n };\n \n /* Listheads of above structures.  */\n@@ -363,10 +369,10 @@ static rtx attr_rtx\t\tPARAMS ((enum rtx_code, ...));\n static char *attr_printf\tPARAMS ((int, const char *, ...))\n   ATTRIBUTE_PRINTF_2;\n static char *attr_string        PARAMS ((const char *, int));\n-static rtx check_attr_test\tPARAMS ((rtx, int));\n+static rtx check_attr_test\tPARAMS ((rtx, int, int));\n static rtx check_attr_value\tPARAMS ((rtx, struct attr_desc *));\n-static rtx convert_set_attr_alternative PARAMS ((rtx, int, int));\n-static rtx convert_set_attr\tPARAMS ((rtx, int, int));\n+static rtx convert_set_attr_alternative PARAMS ((rtx, struct insn_def *));\n+static rtx convert_set_attr\tPARAMS ((rtx, struct insn_def *));\n static void check_defs\t\tPARAMS ((void));\n #if 0\n static rtx convert_const_symbol_ref PARAMS ((rtx, struct attr_desc *));\n@@ -413,13 +419,13 @@ static rtx simplify_and_tree\tPARAMS ((rtx, rtx *, int, int));\n static rtx simplify_or_tree\tPARAMS ((rtx, rtx *, int, int));\n static rtx simplify_test_exp\tPARAMS ((rtx, int, int));\n static void optimize_attrs\tPARAMS ((void));\n-static void gen_attr\t\tPARAMS ((rtx));\n+static void gen_attr\t\tPARAMS ((rtx, int));\n static int count_alternatives\tPARAMS ((rtx));\n static int compares_alternatives_p PARAMS ((rtx));\n static int contained_in_p\tPARAMS ((rtx, rtx));\n-static void gen_insn\t\tPARAMS ((rtx));\n-static void gen_delay\t\tPARAMS ((rtx));\n-static void gen_unit\t\tPARAMS ((rtx));\n+static void gen_insn\t\tPARAMS ((rtx, int));\n+static void gen_delay\t\tPARAMS ((rtx, int));\n+static void gen_unit\t\tPARAMS ((rtx, int));\n static void write_test_expr\tPARAMS ((rtx, int));\n static int max_attr_value\tPARAMS ((rtx, int*));\n static int or_attr_value\tPARAMS ((rtx, int*));\n@@ -926,9 +932,10 @@ attr_copy_rtx (orig)\n    Return the new expression, if any.   */\n \n static rtx\n-check_attr_test (exp, is_const)\n+check_attr_test (exp, is_const, lineno)\n      rtx exp;\n      int is_const;\n+     int lineno;\n {\n   struct attr_desc *attr;\n   struct attr_value *av;\n@@ -943,7 +950,7 @@ check_attr_test (exp, is_const)\n \treturn check_attr_test (attr_rtx (NOT,\n \t\t\t\t\t  attr_eq (XSTR (exp, 0),\n \t\t\t\t\t\t   &XSTR (exp, 1)[1])),\n-\t\t\t\tis_const);\n+\t\t\t\tis_const, lineno);\n \n       else if (n_comma_elts (XSTR (exp, 1)) == 1)\n \t{\n@@ -1005,7 +1012,7 @@ check_attr_test (exp, is_const)\n \t      orexp = insert_right_side (IOR, orexp, newexp, -2, -2);\n \t    }\n \n-\t  return check_attr_test (orexp, is_const);\n+\t  return check_attr_test (orexp, is_const, lineno);\n \t}\n       break;\n \n@@ -1021,12 +1028,12 @@ check_attr_test (exp, is_const)\n \n     case IOR:\n     case AND:\n-      XEXP (exp, 0) = check_attr_test (XEXP (exp, 0), is_const);\n-      XEXP (exp, 1) = check_attr_test (XEXP (exp, 1), is_const);\n+      XEXP (exp, 0) = check_attr_test (XEXP (exp, 0), is_const, lineno);\n+      XEXP (exp, 1) = check_attr_test (XEXP (exp, 1), is_const, lineno);\n       break;\n \n     case NOT:\n-      XEXP (exp, 0) = check_attr_test (XEXP (exp, 0), is_const);\n+      XEXP (exp, 0) = check_attr_test (XEXP (exp, 0), is_const, lineno);\n       break;\n \n     case MATCH_INSN:\n@@ -1086,13 +1093,22 @@ check_attr_value (exp, attr)\n     {\n     case CONST_INT:\n       if (attr && ! attr->is_numeric)\n-\tfatal (\"CONST_INT not valid for non-numeric `%s' attribute\",\n-\t       attr->name);\n+\t{\n+\t  message_with_line (attr->lineno,\n+\t\t\t     \"CONST_INT not valid for non-numeric attribute %s\",\n+\t\t\t     attr->name);\n+\t  have_error = 1;\n+\t  break;\n+\t}\n \n       if (INTVAL (exp) < 0 && ! attr->negative_ok)\n-\tfatal (\"Negative numeric value specified for `%s' attribute\",\n-\t       attr->name);\n-\n+\t{\n+\t  message_with_line (attr->lineno,\n+\t\t\t\"negative numeric value specified for attribute %s\",\n+\t\t\tattr->name);\n+\t  have_error = 1;\n+\t  break;\n+\t}\n       break;\n \n     case CONST_STRING:\n@@ -1106,8 +1122,13 @@ check_attr_value (exp, attr)\n \t    p++;\n \t  for (; *p; p++)\n \t    if (*p > '9' || *p < '0')\n-\t      fatal (\"Non-numeric value for numeric `%s' attribute\",\n-\t\t     attr ? attr->name : \"internal\");\n+\t      {\n+\t\tmessage_with_line (attr ? attr->lineno : 0,\n+\t\t\t\t   \"non-numeric value for numeric attribute %s\",\n+\t\t\t\t   attr ? attr->name : \"internal\");\n+\t\thave_error = 1;\n+\t\tbreak;\n+\t      }\n \t  break;\n \t}\n \n@@ -1117,14 +1138,18 @@ check_attr_value (exp, attr)\n \t  break;\n \n       if (av == NULL)\n-\tfatal (\"Unknown value `%s' for `%s' attribute\",\n-\t       XSTR (exp, 0), attr ? attr->name : \"internal\");\n-\n+\t{\n+\t  message_with_line (attr->lineno,\n+\t\t\t     \"unknown value `%s' for `%s' attribute\",\n+\t\t\t     XSTR (exp, 0), attr ? attr->name : \"internal\");\n+\t  have_error = 1;\n+\t}\n       break;\n \n     case IF_THEN_ELSE:\n       XEXP (exp, 0) = check_attr_test (XEXP (exp, 0),\n-\t\t\t\t       attr ? attr->is_const : 0);\n+\t\t\t\t       attr ? attr->is_const : 0,\n+\t\t\t\t       attr ? attr->lineno : 0);\n       XEXP (exp, 1) = check_attr_value (XEXP (exp, 1), attr);\n       XEXP (exp, 2) = check_attr_value (XEXP (exp, 2), attr);\n       break;\n@@ -1135,8 +1160,13 @@ check_attr_value (exp, attr)\n     case DIV:\n     case MOD:\n       if (attr && !attr->is_numeric)\n-\tfatal (\"Invalid operation `%s' for non-numeric attribute value\",\n-\t       GET_RTX_NAME (GET_CODE (exp)));\n+\t{\n+\t  message_with_line (attr->lineno,\n+\t\t\"invalid operation `%s' for non-numeric attribute value\",\n+\t\tGET_RTX_NAME (GET_CODE (exp)));\n+\t  have_error = 1;\n+\t  break;\n+\t}\n       /* FALLTHRU */\n \n     case IOR:\n@@ -1151,12 +1181,18 @@ check_attr_value (exp, attr)\n \n     case COND:\n       if (XVECLEN (exp, 0) % 2 != 0)\n-\tfatal (\"First operand of COND must have even length\");\n+\t{\n+\t  message_with_line (attr->lineno,\n+\t\t\t     \"first operand of COND must have even length\");\n+\t  have_error = 1;\n+\t  break;\n+\t}\n \n       for (i = 0; i < XVECLEN (exp, 0); i += 2)\n \t{\n \t  XVECEXP (exp, 0, i) = check_attr_test (XVECEXP (exp, 0, i),\n-\t\t\t\t\t\t attr ? attr->is_const : 0);\n+\t\t\t\t\t\t attr ? attr->is_const : 0,\n+\t\t\t\t\t\t attr ? attr->lineno : 0);\n \t  XVECEXP (exp, 0, i + 1)\n \t    = check_attr_value (XVECEXP (exp, 0, i + 1), attr);\n \t}\n@@ -1168,15 +1204,28 @@ check_attr_value (exp, attr)\n       {\n \tstruct attr_desc *attr2 = find_attr (XSTR (exp, 0), 0);\n \tif (attr2 == NULL)\n-\t  fatal (\"Unknown attribute `%s' in ATTR\", XSTR (exp, 0));\n-\telse if ((attr && attr->is_const) && ! attr2->is_const)\n-\t  fatal (\"Non-constant attribute `%s' referenced from `%s'\",\n-\t\t XSTR (exp, 0), attr->name);\n+\t  {\n+\t    message_with_line (attr ? attr->lineno : 0,\n+\t\t\t       \"unknown attribute `%s' in ATTR\",\n+\t\t\t       XSTR (exp, 0));\n+\t    have_error = 1;\n+\t  }\n+\telse if (attr && attr->is_const && ! attr2->is_const)\n+\t  {\n+\t    message_with_line (attr->lineno,\n+\t\t\"non-constant attribute `%s' referenced from `%s'\",\n+\t\tXSTR (exp, 0), attr->name);\n+\t    have_error = 1;\n+\t  }\n \telse if (attr \n \t\t && (attr->is_numeric != attr2->is_numeric\n \t\t     || (! attr->negative_ok && attr2->negative_ok)))\n-\t  fatal (\"Numeric attribute mismatch calling `%s' from `%s'\",\n-\t\t XSTR (exp, 0), attr->name);\n+\t  {\n+\t    message_with_line (attr->lineno,\n+\t\t\"numeric attribute mismatch calling `%s' from `%s'\",\n+\t\tXSTR (exp, 0), attr->name);\n+\t    have_error = 1;\n+\t  }\n       }\n       break;\n \n@@ -1187,8 +1236,11 @@ check_attr_value (exp, attr)\n       return attr_rtx (SYMBOL_REF, XSTR (exp, 0));\n \n     default:\n-      fatal (\"Invalid operation `%s' for attribute value\",\n-\t     GET_RTX_NAME (GET_CODE (exp)));\n+      message_with_line (attr ? attr->lineno : 0,\n+\t\t\t \"invalid operation `%s' for attribute value\",\n+\t\t\t GET_RTX_NAME (GET_CODE (exp)));\n+      have_error = 1;\n+      break;\n     }\n \n   return exp;\n@@ -1198,17 +1250,21 @@ check_attr_value (exp, attr)\n    It becomes a COND with each test being (eq_attr \"alternative \"n\") */\n \n static rtx\n-convert_set_attr_alternative (exp, num_alt, insn_index)\n+convert_set_attr_alternative (exp, id)\n      rtx exp;\n-     int num_alt;\n-     int insn_index;\n+     struct insn_def *id;\n {\n+  int num_alt = id->num_alternatives;\n   rtx condexp;\n   int i;\n \n   if (XVECLEN (exp, 1) != num_alt)\n-    fatal (\"Bad number of entries in SET_ATTR_ALTERNATIVE for insn %d\",\n-\t   insn_index);\n+    {\n+      message_with_line (id->lineno,\n+\t\t\"bad number of entries in SET_ATTR_ALTERNATIVE\");\n+      have_error = 1;\n+      return NULL_RTX;\n+    }\n \n   /* Make a COND with all tests but the last.  Select the last value via the\n      default.  */\n@@ -1221,12 +1277,6 @@ convert_set_attr_alternative (exp, num_alt, insn_index)\n       p = attr_numeral (i);\n \n       XVECEXP (condexp, 0, 2 * i) = attr_eq (alternative_name, p);\n-#if 0\n-      /* Sharing this EQ_ATTR rtl causes trouble.  */   \n-      XVECEXP (condexp, 0, 2 * i) = rtx_alloc (EQ_ATTR);\n-      XSTR (XVECEXP (condexp, 0, 2 * i), 0) = alternative_name;\n-      XSTR (XVECEXP (condexp, 0, 2 * i), 1) = p;\n-#endif\n       XVECEXP (condexp, 0, 2 * i + 1) = XVECEXP (exp, 1, i);\n     }\n \n@@ -1239,10 +1289,9 @@ convert_set_attr_alternative (exp, num_alt, insn_index)\n    list of values is given, convert to SET_ATTR_ALTERNATIVE first.  */\n \n static rtx\n-convert_set_attr (exp, num_alt, insn_index)\n+convert_set_attr (exp, id)\n      rtx exp;\n-     int num_alt;\n-     int insn_index;\n+     struct insn_def *id;\n {\n   rtx newexp;\n   const char *name_ptr;\n@@ -1266,7 +1315,7 @@ convert_set_attr (exp, num_alt, insn_index)\n   while ((p = next_comma_elt (&name_ptr)) != NULL)\n     XVECEXP (newexp, 1, n++) = attr_rtx (CONST_STRING, p);\n \n-  return convert_set_attr_alternative (newexp, num_alt, insn_index);\n+  return convert_set_attr_alternative (newexp, id);\n }\n \f\n /* Scan all definitions, checking for validity.  Also, convert any SET_ATTR\n@@ -1293,28 +1342,37 @@ check_defs ()\n \t    {\n \t    case SET:\n \t      if (GET_CODE (XEXP (value, 0)) != ATTR)\n-\t\tfatal (\"Bad attribute set in pattern %d\", id->insn_index);\n+\t\t{\n+\t\t  message_with_line (id->lineno, \"bad attribute set\");\n+\t\t  have_error = 1;\n+\t\t  value = NULL_RTX;\n+\t\t}\n \t      break;\n \n \t    case SET_ATTR_ALTERNATIVE:\n-\t      value = convert_set_attr_alternative (value,\n-\t\t\t\t\t\t    id->num_alternatives,\n-\t\t\t\t\t\t    id->insn_index);\n+\t      value = convert_set_attr_alternative (value, id);\n \t      break;\n \n \t    case SET_ATTR:\n-\t      value = convert_set_attr (value, id->num_alternatives,\n-\t\t\t\t\tid->insn_index);\n+\t      value = convert_set_attr (value, id);\n \t      break;\n \n \t    default:\n-\t      fatal (\"Invalid attribute code `%s' for pattern %d\",\n-\t\t     GET_RTX_NAME (GET_CODE (value)), id->insn_index);\n+\t      message_with_line (id->lineno, \"invalid attribute code %s\",\n+\t\t\t\t GET_RTX_NAME (GET_CODE (value)));\n+\t      have_error = 1;\n+\t      value = NULL_RTX;\n \t    }\n+\t  if (value == NULL_RTX)\n+\t    continue;\n \n \t  if ((attr = find_attr (XSTR (XEXP (value, 0), 0), 0)) == NULL)\n-\t    fatal (\"Unknown attribute `%s' for pattern number %d\",\n-\t\t   XSTR (XEXP (value, 0), 0), id->insn_index);\n+\t    {\n+\t      message_with_line (id->lineno, \"unknown attribute %s\",\n+\t\t\t\t XSTR (XEXP (value, 0), 0));\n+\t      have_error = 1;\n+\t      continue;\n+\t    }\n \n \t  XVECEXP (id->def, id->vec_idx, i) = value;\n \t  XEXP (value, 1) = check_attr_value (XEXP (value, 1), attr);\n@@ -1862,7 +1920,7 @@ expand_units ()\n \n   for (unit = units; unit; unit = unit->next)\n     {\n-      unit->condexp = check_attr_test (unit->condexp, 0);\n+      unit->condexp = check_attr_test (unit->condexp, 0, unit->first_lineno);\n \n       for (op = unit->ops; op; op = op->next)\n \t{\n@@ -1890,7 +1948,7 @@ expand_units ()\n \t    }\n \n \t  /* Validate the condition.  */\n-\t  op->condexp = check_attr_test (op->condexp, 0);\n+\t  op->condexp = check_attr_test (op->condexp, 0, op->lineno);\n \t}\n     }\n \n@@ -4135,8 +4193,9 @@ count_sub_rtxs (x, max)\n /* Create table entries for DEFINE_ATTR.  */\n \n static void\n-gen_attr (exp)\n+gen_attr (exp, lineno)\n      rtx exp;\n+     int lineno;\n {\n   struct attr_desc *attr;\n   struct attr_value *av;\n@@ -4147,7 +4206,14 @@ gen_attr (exp)\n      attr->default_val, since it is initialized by this routine.  */\n   attr = find_attr (XSTR (exp, 0), 1);\n   if (attr->default_val)\n-    fatal (\"Duplicate definition for `%s' attribute\", attr->name);\n+    {\n+      message_with_line (lineno, \"duplicate definition for attribute %s\",\n+\t\t\t attr->name);\n+      message_with_line (attr->lineno, \"previous definition\");\n+      have_error = 1;\n+      return;\n+    }\n+  attr->lineno = lineno;\n \n   if (*XSTR (exp, 1) == '\\0')\n     attr->is_numeric = 1;\n@@ -4170,13 +4236,21 @@ gen_attr (exp)\n     {\n       attr->is_const = 1;\n       if (attr->is_numeric)\n-\tfatal (\"Constant attributes may not take numeric values\");\n+\t{\n+\t  message_with_line (lineno,\n+\t\t\t     \"constant attributes may not take numeric values\");\n+\t  have_error = 1;\n+\t}\n+\n       /* Get rid of the CONST node.  It is allowed only at top-level.  */\n       XEXP (exp, 2) = XEXP (XEXP (exp, 2), 0);\n     }\n \n   if (! strcmp (attr->name, \"length\") && ! attr->is_numeric)\n-    fatal (\"`length' attribute must take numeric values\");\n+    {\n+      message_with_line (lineno, \"`length' attribute must take numeric values\");\n+      have_error = 1;\n+    }\n \n   /* Set up the default value.  */\n   XEXP (exp, 2) = check_attr_value (XEXP (exp, 2), attr);\n@@ -4291,15 +4365,17 @@ contained_in_p (inner, exp)\n /* Process DEFINE_PEEPHOLE, DEFINE_INSN, and DEFINE_ASM_ATTRIBUTES.  */\n \n static void\n-gen_insn (exp)\n+gen_insn (exp, lineno)\n      rtx exp;\n+     int lineno;\n {\n   struct insn_def *id;\n \n   id = (struct insn_def *) oballoc (sizeof (struct insn_def));\n   id->next = defs;\n   defs = id;\n   id->def = exp;\n+  id->lineno = lineno;\n \n   switch (GET_CODE (exp))\n     {\n@@ -4338,14 +4414,20 @@ gen_insn (exp)\n    true or annul false is specified, and make a `struct delay_desc'.  */\n \n static void\n-gen_delay (def)\n+gen_delay (def, lineno)\n      rtx def;\n+     int lineno;\n {\n   struct delay_desc *delay;\n   int i;\n \n   if (XVECLEN (def, 1) % 3 != 0)\n-    fatal (\"Number of elements in DEFINE_DELAY must be multiple of three.\");\n+    {\n+      message_with_line (lineno,\n+\t\"number of elements in DEFINE_DELAY must be multiple of three\");\n+      have_error = 1;\n+      return;\n+    }\n \n   for (i = 0; i < XVECLEN (def, 1); i += 3)\n     {\n@@ -4359,6 +4441,7 @@ gen_delay (def)\n   delay->def = def;\n   delay->num = ++num_delays;\n   delay->next = delays;\n+  delay->lineno = lineno;\n   delays = delay;\n }\n \f\n@@ -4369,8 +4452,9 @@ gen_delay (def)\n    with information used later by `expand_unit'.  */\n \n static void\n-gen_unit (def)\n+gen_unit (def, lineno)\n      rtx def;\n+     int lineno;\n {\n   struct function_unit *unit;\n   struct function_unit_op *op;\n@@ -4389,8 +4473,14 @@ gen_unit (def)\n       {\n \tif (unit->multiplicity != multiplicity\n \t    || unit->simultaneity != simultaneity)\n-\t  fatal (\"Differing specifications given for `%s' function unit.\",\n-\t\t unit->name);\n+\t  {\n+\t    message_with_line (lineno,\n+\t\t\t\"differing specifications given for function unit %s\",\n+\t\t\tunit->name);\n+\t    message_with_line (unit->first_lineno, \"previous definition\");\n+\t    have_error = 1;\n+\t    return;\n+\t  }\n \tbreak;\n       }\n \n@@ -4406,6 +4496,7 @@ gen_unit (def)\n       unit->condexp = false_rtx;\n       unit->ops = 0;\n       unit->next = units;\n+      unit->first_lineno = lineno;\n       units = unit;\n     }\n \n@@ -4416,6 +4507,7 @@ gen_unit (def)\n   op->ready = ready_cost;\n   op->issue_delay = issue_delay;\n   op->next = unit->ops;\n+  op->lineno = lineno;\n   unit->ops = op;\n   num_unit_opclasses++;\n \n@@ -4662,7 +4754,7 @@ write_test_expr (exp, flags)\n \n     /* The address of the branch target.  */\n     case MATCH_DUP:\n-      printf (\"INSN_ADDRESSES (INSN_UID (GET_CODE (operands[%d]) == LABEL_REF ? XEXP (operands[%d], 0) : operands[%d]))\",\n+      printf (\"INSN_ADDRESSES_SET_P () ? INSN_ADDRESSES (INSN_UID (GET_CODE (operands[%d]) == LABEL_REF ? XEXP (operands[%d], 0) : operands[%d])) : 0\",\n \t      XINT (exp, 0), XINT (exp, 0), XINT (exp, 0));\n       break;\n \n@@ -5990,9 +6082,9 @@ from the machine description file `md'.  */\\n\\n\");\n \n   while (1)\n     {\n-      int line_no;\n+      int lineno;\n \n-      desc = read_md_rtx (&line_no, &insn_code_number);\n+      desc = read_md_rtx (&lineno, &insn_code_number);\n       if (desc == NULL)\n \tbreak;\n \n@@ -6001,19 +6093,19 @@ from the machine description file `md'.  */\\n\\n\");\n \t  case DEFINE_INSN:\n \t  case DEFINE_PEEPHOLE:\n \t  case DEFINE_ASM_ATTRIBUTES:\n-\t      gen_insn(desc);\n+\t      gen_insn(desc, lineno);\n \t      break;\n \t  \n \t  case DEFINE_ATTR:\n-\t      gen_attr (desc);\n+\t      gen_attr (desc, lineno);\n \t      break;\n \n \t  case DEFINE_DELAY:\n-\t      gen_delay (desc);\n+\t      gen_delay (desc, lineno);\n \t      break;\n \n \t  case DEFINE_FUNCTION_UNIT:\n-\t      gen_unit (desc);\n+\t      gen_unit (desc, lineno);\n \t      break;\n \t      \t\n \t  default:\n@@ -6023,14 +6115,17 @@ from the machine description file `md'.  */\\n\\n\");\n         insn_index_number++;\n     }\n \n+  if (have_error)\n+    return FATAL_EXIT_CODE;\n+\n   insn_code_number++;\n \n   /* If we didn't have a DEFINE_ASM_ATTRIBUTES, make a null one.  */\n   if (! got_define_asm_attributes)\n     {\n       tem = rtx_alloc (DEFINE_ASM_ATTRIBUTES);\n       XVEC (tem, 0) = rtvec_alloc (0);\n-      gen_insn (tem);\n+      gen_insn (tem, 0);\n     }\n \n   /* Expand DEFINE_DELAY information into new attribute.  */\n@@ -6071,13 +6166,18 @@ from the machine description file `md'.  */\\n\\n\");\n      away and building the attribute cases.  */\n \n   check_defs ();\n+\n   for (i = 0; i < MAX_ATTRS_INDEX; i++)\n     for (attr = attrs[i]; attr; attr = attr->next)\n-      {\n-\tattr->default_val->value\n-\t  = check_attr_value (attr->default_val->value, attr);\n-\tfill_attr (attr);\n-      }\n+      attr->default_val->value\n+\t= check_attr_value (attr->default_val->value, attr);\n+\n+  if (have_error)\n+    return FATAL_EXIT_CODE;\n+\n+  for (i = 0; i < MAX_ATTRS_INDEX; i++)\n+    for (attr = attrs[i]; attr; attr = attr->next)\n+      fill_attr (attr);\n \n   /* Construct extra attributes for `length'.  */\n   make_length_attrs ();"}]}