{"sha": "16788d44af6621f4bb0b51f3527a3e406cdfddca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY3ODhkNDRhZjY2MjFmNGJiMGI1MWYzNTI3YTNlNDA2Y2RmZGRjYQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2013-07-05T10:44:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-05T10:44:22Z"}, "message": "exp_ch4.adb, [...]: Minor reformatting.\n\n2013-07-05  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb, a-cfdlli.ads, a-ngelfu.ads, s-bignum.adb: Minor\n\treformatting.\n\nFrom-SVN: r200707", "tree": {"sha": "5aab3f14ba85585fad33a1174cf7a4b84a38487d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5aab3f14ba85585fad33a1174cf7a4b84a38487d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16788d44af6621f4bb0b51f3527a3e406cdfddca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16788d44af6621f4bb0b51f3527a3e406cdfddca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16788d44af6621f4bb0b51f3527a3e406cdfddca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16788d44af6621f4bb0b51f3527a3e406cdfddca/comments", "author": null, "committer": null, "parents": [{"sha": "da1b76c1656bca32734a9f38fb0d9a7e4b6eed71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da1b76c1656bca32734a9f38fb0d9a7e4b6eed71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da1b76c1656bca32734a9f38fb0d9a7e4b6eed71"}], "stats": {"total": 260, "additions": 140, "deletions": 120}, "files": [{"sha": "44b72d4c9690dd97552151167e2ac7413ebe84d4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16788d44af6621f4bb0b51f3527a3e406cdfddca/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16788d44af6621f4bb0b51f3527a3e406cdfddca/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=16788d44af6621f4bb0b51f3527a3e406cdfddca", "patch": "@@ -1,3 +1,8 @@\n+2013-07-05  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb, a-cfdlli.ads, a-ngelfu.ads, s-bignum.adb: Minor\n+\treformatting.\n+\n 2013-07-05  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch4.adb (Expand_Composite_Equality): Use the full view"}, {"sha": "8ea3c4c348d5d9d006895c54e15434334f1777e7", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 71, "deletions": 46, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16788d44af6621f4bb0b51f3527a3e406cdfddca/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16788d44af6621f4bb0b51f3527a3e406cdfddca/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=16788d44af6621f4bb0b51f3527a3e406cdfddca", "patch": "@@ -78,145 +78,170 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    procedure Clear (Container : in out List);\n \n-   procedure Assign (Target : in out List; Source : List)\n-   with Pre => Target.Capacity >= Length (Source);\n+   procedure Assign (Target : in out List; Source : List) with\n+     Pre => Target.Capacity >= Length (Source);\n \n    function Copy (Source : List; Capacity : Count_Type := 0) return List;\n \n-   function Element (Container : List; Position : Cursor) return Element_Type\n-   with Pre => Has_Element (Container, Position);\n+   function Element\n+     (Container : List;\n+      Position : Cursor) return Element_Type\n+   with\n+     Pre => Has_Element (Container, Position);\n \n    procedure Replace_Element\n      (Container : in out List;\n       Position  : Cursor;\n       New_Item  : Element_Type)\n-   with Pre => Has_Element (Container, Position);\n+   with\n+     Pre => Has_Element (Container, Position);\n \n-   procedure Move (Target : in out List; Source : in out List)\n-   with Pre => Target.Capacity >= Length (Source);\n+   procedure Move (Target : in out List; Source : in out List) with\n+     Pre => Target.Capacity >= Length (Source);\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n-   with Pre => Length (Container) + Count <= Container.Capacity and then\n-     (Has_Element (Container, Before) or else Before = No_Element);\n+   with\n+     Pre => Length (Container) + Count <= Container.Capacity\n+              and then (Has_Element (Container, Before)\n+                         or else Before = No_Element);\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Count     : Count_Type := 1)\n-   with Pre => Length (Container) + Count <= Container.Capacity and then\n-     (Has_Element (Container, Before) or else Before = No_Element);\n+   with\n+     Pre => Length (Container) + Count <= Container.Capacity\n+              and then (Has_Element (Container, Before)\n+                         or else Before = No_Element);\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       Position  : out Cursor;\n       Count     : Count_Type := 1)\n-   with Pre => Length (Container) + Count <= Container.Capacity and then\n-     (Has_Element (Container, Before) or else Before = No_Element);\n+   with\n+     Pre => Length (Container) + Count <= Container.Capacity\n+              and then (Has_Element (Container, Before)\n+                         or else Before = No_Element);\n \n    procedure Prepend\n      (Container : in out List;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n-   with Pre => Length (Container) + Count <= Container.Capacity;\n+   with\n+     Pre => Length (Container) + Count <= Container.Capacity;\n \n    procedure Append\n      (Container : in out List;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1)\n-   with Pre => Length (Container) + Count <= Container.Capacity;\n+   with\n+     Pre => Length (Container) + Count <= Container.Capacity;\n \n    procedure Delete\n      (Container : in out List;\n       Position  : in out Cursor;\n       Count     : Count_Type := 1)\n-   with Pre => Has_Element (Container, Position);\n+   with\n+     Pre => Has_Element (Container, Position);\n \n    procedure Delete_First\n      (Container : in out List;\n       Count     : Count_Type := 1)\n-   with Pre => not Is_Empty (Container);\n+   with\n+     Pre => not Is_Empty (Container);\n \n    procedure Delete_Last\n      (Container : in out List;\n       Count     : Count_Type := 1)\n-   with Pre => not Is_Empty (Container);\n+   with\n+     Pre => not Is_Empty (Container);\n \n    procedure Reverse_Elements (Container : in out List);\n \n    procedure Swap\n      (Container : in out List;\n       I, J      : Cursor)\n-   with Pre => Has_Element (Container, I) and then Has_Element (Container, J);\n+   with\n+     Pre => Has_Element (Container, I) and then Has_Element (Container, J);\n \n    procedure Swap_Links\n      (Container : in out List;\n       I, J      : Cursor)\n-   with Pre => Has_Element (Container, I) and then Has_Element (Container, J);\n+   with\n+     Pre => Has_Element (Container, I) and then Has_Element (Container, J);\n \n    procedure Splice\n      (Target : in out List;\n       Before : Cursor;\n       Source : in out List)\n-   with Pre => Length (Source) + Length (Target) <= Target.Capacity and then\n-     (Has_Element (Target, Before) or else Before = No_Element);\n+   with\n+     Pre => Length (Source) + Length (Target) <= Target.Capacity\n+              and then (Has_Element (Target, Before)\n+                         or else Before = No_Element);\n \n    procedure Splice\n      (Target   : in out List;\n       Before   : Cursor;\n       Source   : in out List;\n       Position : in out Cursor)\n-   with Pre => Length (Source) + Length (Target) <= Target.Capacity and then\n-     (Has_Element (Target, Before) or else Before = No_Element) and then\n-     Has_Element (Source, Position);\n+   with\n+     Pre => Length (Source) + Length (Target) <= Target.Capacity\n+              and then (Has_Element (Target, Before)\n+                         or else Before = No_Element)\n+              and then Has_Element (Source, Position);\n \n    procedure Splice\n      (Container : in out List;\n       Before    : Cursor;\n       Position  : Cursor)\n-   with Pre => 2 * Length (Container) <= Container.Capacity and then\n-     (Has_Element (Container, Before) or else Before = No_Element) and then\n-     Has_Element (Container, Position);\n+   with\n+     Pre => 2 * Length (Container) <= Container.Capacity\n+              and then (Has_Element (Container, Before)\n+                         or else Before = No_Element)\n+              and then Has_Element (Container, Position);\n \n    function First (Container : List) return Cursor;\n \n-   function First_Element (Container : List) return Element_Type\n-   with Pre => not Is_Empty (Container);\n+   function First_Element (Container : List) return Element_Type with\n+     Pre => not Is_Empty (Container);\n \n    function Last (Container : List) return Cursor;\n \n-   function Last_Element (Container : List) return Element_Type\n-   with Pre => not Is_Empty (Container);\n+   function Last_Element (Container : List) return Element_Type with\n+     Pre => not Is_Empty (Container);\n \n-   function Next (Container : List; Position : Cursor) return Cursor\n-   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n+   function Next (Container : List; Position : Cursor) return Cursor with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   procedure Next (Container : List; Position : in out Cursor)\n-   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n+   procedure Next (Container : List; Position : in out Cursor) with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   function Previous (Container : List; Position : Cursor) return Cursor\n-   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n+   function Previous (Container : List; Position : Cursor) return Cursor with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   procedure Previous (Container : List; Position : in out Cursor)\n-   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n+   procedure Previous (Container : List; Position : in out Cursor) with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Find\n      (Container : List;\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor\n-   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n+   with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Reverse_Find\n      (Container : List;\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor\n-   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n+   with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Contains\n      (Container : List;\n@@ -241,10 +266,10 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n-   function Left  (Container : List; Position : Cursor) return List\n-   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n-   function Right (Container : List; Position : Cursor) return List\n-   with Pre => Has_Element (Container, Position) or else Position = No_Element;\n+   function Left  (Container : List; Position : Cursor) return List with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+   function Right (Container : List; Position : Cursor) return List with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n    --  Left returns a container containing all elements preceding Position\n    --  (excluded) in Container. Right returns a container containing all\n    --  elements following Position (included) in Container. These two new"}, {"sha": "91e1cf7cf51307c719e13a42acbf79f928e81180", "filename": "gcc/ada/a-ngelfu.ads", "status": "modified", "additions": 40, "deletions": 65, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16788d44af6621f4bb0b51f3527a3e406cdfddca/gcc%2Fada%2Fa-ngelfu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16788d44af6621f4bb0b51f3527a3e406cdfddca/gcc%2Fada%2Fa-ngelfu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngelfu.ads?ref=16788d44af6621f4bb0b51f3527a3e406cdfddca", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---              Copyright (C) 2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2012-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -39,139 +39,114 @@ generic\n package Ada.Numerics.Generic_Elementary_Functions is\n    pragma Pure;\n \n-   function Sqrt (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Sqrt (X : Float_Type'Base) return Float_Type'Base with\n      Post => Sqrt'Result >= 0.0\n-       and then (if X = 0.0 then Sqrt'Result = 0.0)\n-       and then (if X = 1.0 then Sqrt'Result = 1.0);\n+               and then (if X = 0.0 then Sqrt'Result = 0.0)\n+               and then (if X = 1.0 then Sqrt'Result = 1.0);\n \n    function Log (X : Float_Type'Base) return Float_Type'Base\n    with\n      Post => (if X = 1.0 then Log'Result = 0.0);\n \n-   function Log (X, Base : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Log (X, Base : Float_Type'Base) return Float_Type'Base with\n      Post => (if X = 1.0 then Log'Result = 0.0);\n \n-   function Exp (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Exp (X : Float_Type'Base) return Float_Type'Base with\n      Post => (if X = 0.0 then Exp'Result = 1.0);\n \n-   function \"**\" (Left, Right : Float_Type'Base) return Float_Type'Base\n-   with\n+   function \"**\" (Left, Right : Float_Type'Base) return Float_Type'Base with\n      Post => \"**\"'Result >= 0.0\n-       and then (if Right = 0.0 then \"**\"'Result = 1.0)\n-       and then (if Right = 1.0 then \"**\"'Result = Left)\n-       and then (if Left = 1.0 then \"**\"'Result = 1.0)\n-       and then (if Left = 0.0 then \"**\"'Result = 0.0);\n+               and then (if Right = 0.0 then \"**\"'Result = 1.0)\n+               and then (if Right = 1.0 then \"**\"'Result = Left)\n+               and then (if Left = 1.0 then \"**\"'Result = 1.0)\n+               and then (if Left = 0.0 then \"**\"'Result = 0.0);\n \n-   function Sin (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Sin (X : Float_Type'Base) return Float_Type'Base with\n      Post => Sin'Result in -1.0 .. 1.0\n-       and then (if X = 0.0 then Sin'Result = 0.0);\n+               and then (if X = 0.0 then Sin'Result = 0.0);\n \n-   function Sin (X, Cycle : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Sin (X, Cycle : Float_Type'Base) return Float_Type'Base with\n      Post => Sin'Result in -1.0 .. 1.0\n-       and then (if X = 0.0 then Sin'Result = 0.0);\n+               and then (if X = 0.0 then Sin'Result = 0.0);\n \n-   function Cos (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Cos (X : Float_Type'Base) return Float_Type'Base with\n      Post => Cos'Result in -1.0 .. 1.0\n-       and then (if X = 0.0 then Cos'Result = 1.0);\n+               and then (if X = 0.0 then Cos'Result = 1.0);\n \n-   function Cos (X, Cycle : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Cos (X, Cycle : Float_Type'Base) return Float_Type'Base with\n      Post => Cos'Result in -1.0 .. 1.0\n-       and then  (if X = 0.0 then Cos'Result = 1.0);\n+               and then (if X = 0.0 then Cos'Result = 1.0);\n \n-   function Tan (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Tan (X : Float_Type'Base) return Float_Type'Base with\n      Post => (if X = 0.0 then Tan'Result = 0.0);\n \n-   function Tan (X, Cycle : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Tan (X, Cycle : Float_Type'Base) return Float_Type'Base with\n      Post => (if X = 0.0 then Tan'Result = 0.0);\n \n    function Cot (X : Float_Type'Base) return Float_Type'Base;\n \n    function Cot (X, Cycle : Float_Type'Base) return Float_Type'Base;\n \n-   function Arcsin (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Arcsin (X : Float_Type'Base) return Float_Type'Base with\n      Post => (if X = 0.0 then Arcsin'Result = 0.0);\n \n-   function Arcsin (X, Cycle : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Arcsin (X, Cycle : Float_Type'Base) return Float_Type'Base with\n      Post => (if X = 0.0 then Arcsin'Result = 0.0);\n \n-   function Arccos (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Arccos (X : Float_Type'Base) return Float_Type'Base with\n      Post => (if X = 1.0 then Arccos'Result = 0.0);\n \n-   function Arccos (X, Cycle : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Arccos (X, Cycle : Float_Type'Base) return Float_Type'Base with\n      Post => (if X = 1.0 then Arccos'Result = 0.0);\n \n    function Arctan\n-     (Y   : Float_Type'Base;\n-      X   : Float_Type'Base := 1.0)\n-     return Float_Type'Base\n+     (Y : Float_Type'Base;\n+      X : Float_Type'Base := 1.0) return Float_Type'Base\n    with\n      Post => (if X > 0.0 and Y = 0.0 then Arctan'Result = 0.0);\n \n    function Arctan\n      (Y     : Float_Type'Base;\n       X     : Float_Type'Base := 1.0;\n-      Cycle : Float_Type'Base)\n-      return  Float_Type'Base\n+      Cycle : Float_Type'Base) return Float_Type'Base\n    with\n      Post => (if X > 0.0 and Y = 0.0 then Arctan'Result = 0.0);\n \n    function Arccot\n      (X   : Float_Type'Base;\n-      Y   : Float_Type'Base := 1.0)\n-     return Float_Type'Base\n+      Y   : Float_Type'Base := 1.0) return Float_Type'Base\n    with\n      Post => (if X > 0.0 and Y = 0.0 then Arccot'Result = 0.0);\n \n    function Arccot\n      (X     : Float_Type'Base;\n       Y     : Float_Type'Base := 1.0;\n-      Cycle : Float_Type'Base)\n-     return   Float_Type'Base\n+      Cycle : Float_Type'Base) return Float_Type'Base\n    with\n      Post => (if X > 0.0 and Y = 0.0 then Arccot'Result = 0.0);\n \n-   function Sinh (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Sinh (X : Float_Type'Base) return Float_Type'Base with\n      Post => (if X = 0.0 then Sinh'Result = 0.0);\n \n-   function Cosh (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Cosh (X : Float_Type'Base) return Float_Type'Base with\n      Post => Cosh'Result >= 1.0\n-       and then (if X = 0.0 then Cosh'Result = 1.0);\n+               and then (if X = 0.0 then Cosh'Result = 1.0);\n \n-   function Tanh (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Tanh (X : Float_Type'Base) return Float_Type'Base with\n      Post => Tanh'Result in -1.0 .. 1.0\n-       and then (if X = 0.0 then Tanh'Result = 0.0);\n+               and then (if X = 0.0 then Tanh'Result = 0.0);\n \n-   function Coth (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Coth (X : Float_Type'Base) return Float_Type'Base with\n      Post => abs Coth'Result >= 1.0;\n \n-   function Arcsinh (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Arcsinh (X : Float_Type'Base) return Float_Type'Base with\n      Post => (if X = 0.0 then Arcsinh'Result = 0.0);\n \n-   function Arccosh (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Arccosh (X : Float_Type'Base) return Float_Type'Base with\n      Post => Arccosh'Result >= 0.0\n-       and then (if X = 1.0 then Arccosh'Result = 0.0);\n+               and then (if X = 1.0 then Arccosh'Result = 0.0);\n \n-   function Arctanh (X : Float_Type'Base) return Float_Type'Base\n-   with\n+   function Arctanh (X : Float_Type'Base) return Float_Type'Base with\n      Post => (if X = 0.0 then Arctanh'Result = 0.0);\n \n    function Arccoth (X : Float_Type'Base) return Float_Type'Base;"}, {"sha": "f4abc654d0785c6a5bba3c2c1400d16d8a3d4476", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16788d44af6621f4bb0b51f3527a3e406cdfddca/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16788d44af6621f4bb0b51f3527a3e406cdfddca/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=16788d44af6621f4bb0b51f3527a3e406cdfddca", "patch": "@@ -2587,6 +2587,8 @@ package body Exp_Ch4 is\n          Full_Type := Underlying_Type (Full_Type);\n       end if;\n \n+      --  Case of array types\n+\n       if Is_Array_Type (Full_Type) then\n \n          --  If the operand is an elementary type other than a floating-point\n@@ -2609,6 +2611,8 @@ package body Exp_Ch4 is\n             return Expand_Array_Equality (Nod, Lhs, Rhs, Bodies, Full_Type);\n          end if;\n \n+      --  Case of tagged record types\n+\n       elsif Is_Tagged_Type (Full_Type) then\n \n          --  Call the primitive operation \"=\" of this type\n@@ -2653,6 +2657,8 @@ package body Exp_Ch4 is\n                  (Unchecked_Convert_To (Etype (First_Formal (Eq_Op)), Lhs),\n                   Unchecked_Convert_To (Etype (First_Formal (Eq_Op)), Rhs)));\n \n+      --  Case of untagged record types\n+\n       elsif Is_Record_Type (Full_Type) then\n          Eq_Op := TSS (Full_Type, TSS_Composite_Equality);\n \n@@ -2821,9 +2827,9 @@ package body Exp_Ch4 is\n             return Expand_Record_Equality (Nod, Full_Type, Lhs, Rhs, Bodies);\n          end if;\n \n-      else\n-         --  If not array or record type, it is predefined equality.\n+      --  Non-composite types (always use predefined equality)\n \n+      else\n          return Make_Op_Eq (Loc, Left_Opnd => Lhs, Right_Opnd => Rhs);\n       end if;\n    end Expand_Composite_Equality;"}, {"sha": "cfcf7edf063b3b154efed8d2c57610bb3f94f4ce", "filename": "gcc/ada/s-bignum.adb", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16788d44af6621f4bb0b51f3527a3e406cdfddca/gcc%2Fada%2Fs-bignum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16788d44af6621f4bb0b51f3527a3e406cdfddca/gcc%2Fada%2Fs-bignum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bignum.adb?ref=16788d44af6621f4bb0b51f3527a3e406cdfddca", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2012, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2012-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -64,14 +64,18 @@ package body System.Bignums is\n    -- Local Subprograms --\n    -----------------------\n \n-   function Add (X, Y : Digit_Vector; X_Neg, Y_Neg : Boolean) return Bignum\n-   with Pre => X'First = 1 and then Y'First = 1;\n+   function Add\n+     (X, Y  : Digit_Vector;\n+      X_Neg : Boolean;\n+      Y_Neg : Boolean) return Bignum\n+   with\n+     Pre => X'First = 1 and then Y'First = 1;\n    --  This procedure adds two signed numbers returning the Sum, it is used\n    --  for both addition and subtraction. The value computed is X + Y, with\n    --  X_Neg and Y_Neg giving the signs of the operands.\n \n-   function Allocate_Bignum (Len : Length) return Bignum\n-   with Post => Allocate_Bignum'Result.Len = Len;\n+   function Allocate_Bignum (Len : Length) return Bignum with\n+     Post => Allocate_Bignum'Result.Len = Len;\n    --  Allocate Bignum value of indicated length on secondary stack. On return\n    --  the Neg and D fields are left uninitialized.\n \n@@ -81,7 +85,8 @@ package body System.Bignums is\n    function Compare\n      (X, Y         : Digit_Vector;\n       X_Neg, Y_Neg : Boolean) return Compare_Result\n-   with Pre => X'First = 1 and then Y'First = 1;\n+   with\n+     Pre => X'First = 1 and then Y'First = 1;\n    --  Compare (X with sign X_Neg) with (Y with sign Y_Neg), and return the\n    --  result of the signed comparison.\n \n@@ -113,7 +118,11 @@ package body System.Bignums is\n    -- Add --\n    ---------\n \n-   function Add (X, Y : Digit_Vector; X_Neg, Y_Neg : Boolean) return Bignum is\n+   function Add\n+     (X, Y  : Digit_Vector;\n+      X_Neg : Boolean;\n+      Y_Neg : Boolean) return Bignum\n+   is\n    begin\n       --  If signs are the same, we are doing an addition, it is convenient to\n       --  ensure that the first operand is the longer of the two."}]}