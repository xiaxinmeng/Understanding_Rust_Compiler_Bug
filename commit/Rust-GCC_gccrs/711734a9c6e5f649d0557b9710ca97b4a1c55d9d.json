{"sha": "711734a9c6e5f649d0557b9710ca97b4a1c55d9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzExNzM0YTljNmU1ZjY0OWQwNTU3Yjk3MTBjYTk3YjRhMWM1NWQ5ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-05-29T02:33:54Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-05-29T02:33:54Z"}, "message": "cp-tree.h (DECL_DESTRUCTOR_P): New macro.\n\n\t* cp-tree.h (DECL_DESTRUCTOR_P): New macro.\n\t* method.c (build_destructor_name): New fn.\n\t* decl2.c (maybe_retrofit_in_chrg): Split out...\n\t(grokclassfn): From here.  Reorganize.\n\t* decl.c (grok_ctor_properties): Make sure ctors for types with\n\tvbases have the in_chrg parm.\n\t* pt.c (instantiate_class_template): Update\n\tTYPE_USES_VIRTUAL_BASECLASSES from tsubsted bases.  Don't call\n\tgrok_*_properties.\n\t(tsubst): Call grok_ctor_properties and maybe_retrofit_in_chrg.\n\t* pt.c (instantiate_decl): Make test for whether or not static\n\tvariables should be instantiated early match its comment.\n\nFrom-SVN: r20136", "tree": {"sha": "25e2c12ee0d8b3ffa267282b86a0afbbe7af373e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25e2c12ee0d8b3ffa267282b86a0afbbe7af373e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/711734a9c6e5f649d0557b9710ca97b4a1c55d9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711734a9c6e5f649d0557b9710ca97b4a1c55d9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/711734a9c6e5f649d0557b9710ca97b4a1c55d9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711734a9c6e5f649d0557b9710ca97b4a1c55d9d/comments", "author": null, "committer": null, "parents": [{"sha": "c71407f935c633b9d092349ad14ee0df473a34f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c71407f935c633b9d092349ad14ee0df473a34f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c71407f935c633b9d092349ad14ee0df473a34f9"}], "stats": {"total": 268, "additions": 144, "deletions": 124}, "files": [{"sha": "ea4e5fb172631a1f29b0fa28329b00bd56e07840", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711734a9c6e5f649d0557b9710ca97b4a1c55d9d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711734a9c6e5f649d0557b9710ca97b4a1c55d9d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=711734a9c6e5f649d0557b9710ca97b4a1c55d9d", "patch": "@@ -1,3 +1,21 @@\n+1998-05-29  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.h (DECL_DESTRUCTOR_P): New macro.\n+\t* method.c (build_destructor_name): New fn.\n+\t* decl2.c (maybe_retrofit_in_chrg): Split out...\n+\t(grokclassfn): From here.  Reorganize.\n+\t* decl.c (grok_ctor_properties): Make sure ctors for types with \n+\tvbases have the in_chrg parm.\n+\t* pt.c (instantiate_class_template): Update \n+\tTYPE_USES_VIRTUAL_BASECLASSES from tsubsted bases.  Don't call\n+\tgrok_*_properties.\n+\t(tsubst): Call grok_ctor_properties and maybe_retrofit_in_chrg.\n+\n+1998-05-28  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* pt.c (instantiate_decl): Make test for whether or not static\n+\tvariables should be instantiated early match its comment.\n+\n 1998-05-28  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (start_decl): Always pedwarn about vacuously redeclaring "}, {"sha": "2c7917b2a6a1e2aa0b4acd596e050f58cf2538f9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711734a9c6e5f649d0557b9710ca97b4a1c55d9d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711734a9c6e5f649d0557b9710ca97b4a1c55d9d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=711734a9c6e5f649d0557b9710ca97b4a1c55d9d", "patch": "@@ -1087,6 +1087,8 @@ struct lang_decl\n \n /* For FUNCTION_DECLs: nonzero means that this function is a constructor.  */\n #define DECL_CONSTRUCTOR_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.constructor_attr)\n+#define DECL_DESTRUCTOR_P(NODE) (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME(NODE)))\n+\n /* For FUNCTION_DECLs: nonzero means that this function is a constructor\n    for an object with virtual baseclasses.  */\n #define DECL_CONSTRUCTOR_FOR_VBASE_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.constructor_for_vbase_attr)\n@@ -2396,6 +2398,7 @@ extern int lang_decode_option\t\t\tPROTO((char *));\n extern tree grok_method_quals\t\t\tPROTO((tree, tree, tree));\n extern void warn_if_unknown_interface\t\tPROTO((tree));\n extern tree grok_x_components\t\t\tPROTO((tree, tree));\n+extern void maybe_retrofit_in_chrg\t\tPROTO((tree));\n extern void grokclassfn\t\t\t\tPROTO((tree, tree, tree, enum overload_flags, tree));\n extern tree grok_alignof\t\t\tPROTO((tree));\n extern tree grok_array_decl\t\t\tPROTO((tree, tree));\n@@ -2584,6 +2587,7 @@ extern tree build_decl_overload\t\t\tPROTO((tree, tree, int));\n extern tree build_template_decl_overload        PROTO((tree, tree, tree, tree, tree, int));\n extern tree build_typename_overload\t\tPROTO((tree));\n extern tree build_overload_with_type\t\tPROTO((tree, tree));\n+extern tree build_destructor_name\t\tPROTO((tree));\n extern tree build_opfncall\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n extern tree hack_identifier\t\t\tPROTO((tree, tree));\n extern tree make_thunk\t\t\t\tPROTO((tree, int));"}, {"sha": "d61642c1402ff96d1bcf143f1669e6b6f8aa57c2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711734a9c6e5f649d0557b9710ca97b4a1c55d9d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711734a9c6e5f649d0557b9710ca97b4a1c55d9d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=711734a9c6e5f649d0557b9710ca97b4a1c55d9d", "patch": "@@ -10606,10 +10606,11 @@ grok_ctor_properties (ctype, decl)\n      added to any ctor so we can tell if the class has been initialized\n      yet.  This could screw things up in this function, so we deliberately\n      ignore the leading int if we're in that situation.  */\n-  if (parmtypes\n-      && TREE_VALUE (parmtypes) == integer_type_node\n-      && TYPE_USES_VIRTUAL_BASECLASSES (ctype))\n+  if (TYPE_USES_VIRTUAL_BASECLASSES (ctype))\n     {\n+      my_friendly_assert (parmtypes\n+\t\t\t  && TREE_VALUE (parmtypes) == integer_type_node,\n+\t\t\t  980529);\n       parmtypes = TREE_CHAIN (parmtypes);\n       parmtype = TREE_VALUE (parmtypes);\n     }"}, {"sha": "5f4d5e9bcf88daf32cdc50a406c1541053060bda", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 66, "deletions": 83, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711734a9c6e5f649d0557b9710ca97b4a1c55d9d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711734a9c6e5f649d0557b9710ca97b4a1c55d9d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=711734a9c6e5f649d0557b9710ca97b4a1c55d9d", "patch": "@@ -958,6 +958,57 @@ grok_x_components (specs, components)\n     return grok_enum_decls (components);\n }\n \n+/* Constructors for types with virtual baseclasses need an \"in-charge\" flag\n+   saying whether this constructor is responsible for initialization of\n+   virtual baseclasses or not.  All destructors also need this \"in-charge\"\n+   flag, which additionally determines whether or not the destructor should\n+   free the memory for the object.\n+\n+   This function adds the \"in-charge\" flag to member function FN if\n+   appropriate.  It is called from grokclassfn and tsubst.\n+   FN must be either a constructor or destructor.  */\n+\n+void\n+maybe_retrofit_in_chrg (fn)\n+     tree fn;\n+{\n+  tree basetype, arg_types, parms, parm, fntype;\n+\n+  if (DECL_CONSTRUCTOR_P (fn)\n+      && TYPE_USES_VIRTUAL_BASECLASSES (DECL_CLASS_CONTEXT (fn))\n+      && ! DECL_CONSTRUCTOR_FOR_VBASE_P (fn))\n+    /* OK */;\n+  else if (! DECL_CONSTRUCTOR_P (fn)\n+\t   && TREE_CHAIN (DECL_ARGUMENTS (fn)) == NULL_TREE)\n+    /* OK */;\n+  else\n+    return;\n+\n+  if (DECL_CONSTRUCTOR_P (fn))\n+    DECL_CONSTRUCTOR_FOR_VBASE_P (fn) = 1;\n+\n+  /* First add it to DECL_ARGUMENTS...  */\n+  parm = build_decl (PARM_DECL, in_charge_identifier, integer_type_node);\n+  /* Mark the artificial `__in_chrg' parameter as \"artificial\".  */\n+  SET_DECL_ARTIFICIAL (parm);\n+  DECL_ARG_TYPE (parm) = integer_type_node;\n+  TREE_READONLY (parm) = 1;\n+  parms = DECL_ARGUMENTS (fn);\n+  TREE_CHAIN (parm) = TREE_CHAIN (parms);\n+  TREE_CHAIN (parms) = parm;\n+\n+  /* ...and then to TYPE_ARG_TYPES.  */\n+  arg_types = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+  basetype = TREE_TYPE (TREE_VALUE (arg_types));\n+  arg_types = hash_tree_chain (integer_type_node, TREE_CHAIN (arg_types));\n+  fntype = build_cplus_method_type (basetype, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t\t\t    arg_types);\n+  if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn)))\n+    fntype = build_exception_variant (fntype,\n+\t\t\t\t      TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn)));\n+  TREE_TYPE (fn) = fntype;\n+}\n+\n /* Classes overload their constituent function names automatically.\n    When a function name is declared in a record structure,\n    its name is changed to it overloaded name.  Since names for\n@@ -988,8 +1039,6 @@ grokclassfn (ctype, cname, function, flags, quals)\n   tree arg_types;\n   tree parm;\n   tree qualtype;\n-  tree fntype = TREE_TYPE (function);\n-  tree raises = TYPE_RAISES_EXCEPTIONS (fntype);\n \n   if (fn_name == NULL_TREE)\n     {\n@@ -1016,24 +1065,6 @@ grokclassfn (ctype, cname, function, flags, quals)\n \t  && (flags == DTOR_FLAG || DECL_CONSTRUCTOR_P (function)))\n \tconstp = 0;\n \n-      if (DECL_CONSTRUCTOR_P (function))\n-\t{\n-\t  if (TYPE_USES_VIRTUAL_BASECLASSES (ctype))\n-\t    {\n-\t      DECL_CONSTRUCTOR_FOR_VBASE_P (function) = 1;\n-\t      /* In this case we need \"in-charge\" flag saying whether\n-\t\t this constructor is responsible for initialization\n-\t\t of virtual baseclasses or not.  */\n-\t      parm = build_decl (PARM_DECL, in_charge_identifier, integer_type_node);\n-\t      /* Mark the artificial `__in_chrg' parameter as \"artificial\".  */\n-\t      SET_DECL_ARTIFICIAL (parm);\n-\t      DECL_ARG_TYPE (parm) = integer_type_node;\n-\t      TREE_READONLY (parm) = 1;\n-\t      TREE_CHAIN (parm) = last_function_parms;\n-\t      last_function_parms = parm;\n-\t    }\n-\t}\n-\n       parm = build_decl (PARM_DECL, this_identifier, type);\n       /* Mark the artificial `this' parameter as \"artificial\".  */\n       SET_DECL_ARTIFICIAL (parm);\n@@ -1047,81 +1078,33 @@ grokclassfn (ctype, cname, function, flags, quals)\n       last_function_parms = parm;\n     }\n \n+  DECL_ARGUMENTS (function) = last_function_parms;\n+  /* First approximations.  */\n+  DECL_CONTEXT (function) = ctype;\n+  DECL_CLASS_CONTEXT (function) = ctype;\n+\n+  if (flags == DTOR_FLAG || DECL_CONSTRUCTOR_P (function))\n+    {\n+      maybe_retrofit_in_chrg (function);\n+      arg_types = TYPE_ARG_TYPES (TREE_TYPE (function));\n+    }\n+\n   if (flags == DTOR_FLAG)\n     {\n-      char *buf, *dbuf;\n-      int len = sizeof (DESTRUCTOR_DECL_PREFIX)-1;\n-\n-      arg_types = hash_tree_chain (integer_type_node, void_list_node);\n-      TREE_SIDE_EFFECTS (arg_types) = 1;\n-      /* Build the overload name.  It will look like `7Example'.  */\n-      if (IDENTIFIER_TYPE_VALUE (cname))\n-\tdbuf = build_overload_name (IDENTIFIER_TYPE_VALUE (cname), 1, 1);\n-      else if (IDENTIFIER_LOCAL_VALUE (cname))\n-\tdbuf = build_overload_name (TREE_TYPE (IDENTIFIER_LOCAL_VALUE (cname)),\n-\t\t\t\t    1, 1);\n-      else\n-      /* Using ctype fixes the `X::Y::~Y()' crash.  The cname has no type when\n-\t it's defined out of the class definition, since poplevel_class wipes\n-\t it out.  This used to be internal error 346.  */\n-\tdbuf = build_overload_name (ctype, 1, 1);\n-      buf = (char *) alloca (strlen (dbuf) + sizeof (DESTRUCTOR_DECL_PREFIX));\n-      bcopy (DESTRUCTOR_DECL_PREFIX, buf, len);\n-      buf[len] = '\\0';\n-      strcat (buf, dbuf);\n-      DECL_ASSEMBLER_NAME (function) = get_identifier (buf);\n-      parm = build_decl (PARM_DECL, in_charge_identifier, integer_type_node);\n-      /* Mark the artificial `__in_chrg' parameter as \"artificial\".  */\n-      SET_DECL_ARTIFICIAL (parm);\n-      TREE_READONLY (parm) = 1;\n-      DECL_ARG_TYPE (parm) = integer_type_node;\n-      /* This is the same chain as DECL_ARGUMENTS (...).  */\n-      TREE_CHAIN (last_function_parms) = parm;\n-\n-      fntype = build_cplus_method_type (qualtype, void_type_node,\n-\t\t\t\t\targ_types);\n-      if (raises)\n-\t{\n-\t  fntype = build_exception_variant (fntype, raises);\n-\t}\n-      TREE_TYPE (function) = fntype;\n+      DECL_ASSEMBLER_NAME (function) = build_destructor_name (ctype);\n       TYPE_HAS_DESTRUCTOR (ctype) = 1;\n     }\n   else\n     {\n-      tree these_arg_types;\n-\n-      if (DECL_CONSTRUCTOR_FOR_VBASE_P (function))\n-\t{\n-\t  arg_types = hash_tree_chain (integer_type_node,\n-\t\t\t\t       TREE_CHAIN (arg_types));\n-\t  fntype = build_cplus_method_type (qualtype,\n-\t\t\t\t\t    TREE_TYPE (TREE_TYPE (function)),\n-\t\t\t\t\t    arg_types);\n-\t  if (raises)\n-\t    {\n-\t      fntype = build_exception_variant (fntype, raises);\n-\t    }\n-\t  TREE_TYPE (function) = fntype;\n-\t  arg_types = TYPE_ARG_TYPES (TREE_TYPE (function));\n-\t}\n-\n-      these_arg_types = arg_types;\n-\n       if (TREE_CODE (TREE_TYPE (function)) == FUNCTION_TYPE)\n \t/* Only true for static member functions.  */\n-\tthese_arg_types = hash_tree_chain (build_pointer_type (qualtype),\n-\t\t\t\t\t   arg_types);\n+\targ_types = hash_tree_chain (build_pointer_type (qualtype),\n+\t\t\t\t     arg_types);\n \n       DECL_ASSEMBLER_NAME (function)\n-\t= build_decl_overload (fn_name, these_arg_types,\n+\t= build_decl_overload (fn_name, arg_types,\n \t\t\t       1 + DECL_CONSTRUCTOR_P (function));\n     }\n-\n-  DECL_ARGUMENTS (function) = last_function_parms;\n-  /* First approximations.  */\n-  DECL_CONTEXT (function) = ctype;\n-  DECL_CLASS_CONTEXT (function) = ctype;\n }\n \n /* Work on the expr used by alignof (this is only called by the parser).  */"}, {"sha": "2679d3e539ba8bacd55a5b145a0043547f85e6bf", "filename": "gcc/cp/method.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711734a9c6e5f649d0557b9710ca97b4a1c55d9d/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711734a9c6e5f649d0557b9710ca97b4a1c55d9d/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=711734a9c6e5f649d0557b9710ca97b4a1c55d9d", "patch": "@@ -1728,6 +1728,16 @@ get_id_2 (name, name2)\n   OB_FINISH ();\n   return get_identifier (obstack_base (&scratch_obstack));\n }\n+\n+/* Returns a DECL_ASSEMBLER_NAME for the destructor of type TYPE.  */\n+\n+tree\n+build_destructor_name (type)\n+     tree type;\n+{\n+  return build_overload_with_type (get_identifier (DESTRUCTOR_DECL_PREFIX),\n+\t\t\t\t   type);\n+}\n \f\n /* Given a tree_code CODE, and some arguments (at least one),\n    attempt to use an overloaded operator on the arguments."}, {"sha": "a214906eaaa16baaca1bdb36678a79b1dd2c7eab", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711734a9c6e5f649d0557b9710ca97b4a1c55d9d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711734a9c6e5f649d0557b9710ca97b4a1c55d9d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=711734a9c6e5f649d0557b9710ca97b4a1c55d9d", "patch": "@@ -3777,19 +3777,33 @@ instantiate_class_template (type)\n \tbases = make_tree_vec (len);\n \tfor (i = 0; i < len; ++i)\n \t  {\n-\t    tree elt;\n+\t    tree elt, basetype;\n \n \t    TREE_VEC_ELT (bases, i) = elt\n \t      = tsubst (TREE_VEC_ELT (pbases, i), args, NULL_TREE);\n \t    BINFO_INHERITANCE_CHAIN (elt) = binfo;\n \n-\t    if (! IS_AGGR_TYPE (TREE_TYPE (elt)))\n+\t    basetype = TREE_TYPE (elt);\n+\n+\t    if (! IS_AGGR_TYPE (basetype))\n \t      cp_error\n \t\t(\"base type `%T' of `%T' fails to be a struct or class type\",\n-\t\t TREE_TYPE (elt), type);\n-\t    else if (TYPE_SIZE (complete_type (TREE_TYPE (elt))) == NULL_TREE)\n+\t\t basetype, type);\n+\t    else if (TYPE_SIZE (complete_type (basetype)) == NULL_TREE)\n \t      cp_error (\"base class `%T' of `%T' has incomplete type\",\n-\t\t\tTREE_TYPE (elt), type);\n+\t\t\tbasetype, type);\n+\n+\t    /* These are set up in xref_basetypes for normal classes, so\n+\t       we have to handle them here for template bases.  */\n+\t    if (TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n+\t      {\n+\t\tTYPE_USES_VIRTUAL_BASECLASSES (type) = 1;\n+\t\tTYPE_USES_COMPLEX_INHERITANCE (type) = 1;\n+\t      }\n+\t    TYPE_GETS_NEW (type) |= TYPE_GETS_NEW (basetype);\n+\t    TYPE_GETS_DELETE (type) |= TYPE_GETS_DELETE (basetype);\n+\t    CLASSTYPE_LOCAL_TYPEDECLS (type)\n+\t      |= CLASSTYPE_LOCAL_TYPEDECLS (basetype);\n \t  }\n \t/* Don't initialize this until the vector is filled out, or\n \t   lookups will crash.  */\n@@ -3837,13 +3851,6 @@ instantiate_class_template (type)\n       }\n \n   TYPE_METHODS (type) = tsubst_chain (TYPE_METHODS (pattern), args);\n-  for (t = TYPE_METHODS (type); t; t = TREE_CHAIN (t))\n-    {\n-      if (DECL_CONSTRUCTOR_P (t))\n-\tgrok_ctor_properties (type, t);\n-      else if (IDENTIFIER_OPNAME_P (DECL_NAME (t)))\n-\tgrok_op_properties (t, DECL_VIRTUAL_P (t), 0);\n-    }\n \n   /* Construct the DECL_FRIENDLIST for the new class type.  */\n   typedecl = TYPE_MAIN_DECL (type);\n@@ -4542,17 +4549,30 @@ tsubst (t, args, in_decl)\n \t    DECL_NAME (r) = build_typename_overload (TREE_TYPE (type));\n \t  }\n \n-\tif (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (t)))\n+\tDECL_ARGUMENTS (r) = tsubst (DECL_ARGUMENTS (t), args, t);\n+\tDECL_MAIN_VARIANT (r) = r;\n+\tDECL_RESULT (r) = NULL_TREE;\n+\tDECL_INITIAL (r) = NULL_TREE;\n+\n+\tTREE_STATIC (r) = 0;\n+\tTREE_PUBLIC (r) = TREE_PUBLIC (t);\n+\tDECL_EXTERNAL (r) = 1;\n+\tDECL_INTERFACE_KNOWN (r) = 0;\n+\tDECL_DEFER_OUTPUT (r) = 0;\n+\tTREE_CHAIN (r) = NULL_TREE;\n+\tDECL_PENDING_INLINE_INFO (r) = 0;\n+\tTREE_USED (r) = 0;\n+\n+\tif (DECL_CONSTRUCTOR_P (r))\n \t  {\n-\t    char *buf, *dbuf = build_overload_name (ctx, 1, 1);\n-\t    int len = sizeof (DESTRUCTOR_DECL_PREFIX) - 1;\n-\t    buf = (char *) alloca (strlen (dbuf)\n-\t\t\t\t   + sizeof (DESTRUCTOR_DECL_PREFIX));\n-\t    bcopy (DESTRUCTOR_DECL_PREFIX, buf, len);\n-\t    buf[len] = '\\0';\n-\t    strcat (buf, dbuf);\n-\t    DECL_ASSEMBLER_NAME (r) = get_identifier (buf);\n+\t    maybe_retrofit_in_chrg (r);\n+\t    grok_ctor_properties (ctx, r);\n \t  }\n+\tif (IDENTIFIER_OPNAME_P (DECL_NAME (r)))\n+\t  grok_op_properties (r, DECL_VIRTUAL_P (r), DECL_FRIEND_P (r));\n+\n+\tif (DECL_DESTRUCTOR_P (t))\n+\t  DECL_ASSEMBLER_NAME (r) = build_destructor_name (ctx);\n \telse \n \t  {\n \t    /* Instantiations of template functions must be mangled\n@@ -4645,23 +4665,6 @@ tsubst (t, args, in_decl)\n \tDECL_RTL (r) = 0;\n \tmake_decl_rtl (r, NULL_PTR, 1);\n \n-\tDECL_ARGUMENTS (r) = tsubst (DECL_ARGUMENTS (t), args, t);\n-\tDECL_MAIN_VARIANT (r) = r;\n-\tDECL_RESULT (r) = NULL_TREE;\n-\tDECL_INITIAL (r) = NULL_TREE;\n-\n-\tTREE_STATIC (r) = 0;\n-\tTREE_PUBLIC (r) = TREE_PUBLIC (t);\n-\tDECL_EXTERNAL (r) = 1;\n-\tDECL_INTERFACE_KNOWN (r) = 0;\n-\tDECL_DEFER_OUTPUT (r) = 0;\n-\tTREE_CHAIN (r) = NULL_TREE;\n-\tDECL_PENDING_INLINE_INFO (r) = 0;\n-\tTREE_USED (r) = 0;\n-\n-\tif (IDENTIFIER_OPNAME_P (DECL_NAME (r)))\n-\t  grok_op_properties (r, DECL_VIRTUAL_P (r), DECL_FRIEND_P (r));\n-\n \tif (DECL_TEMPLATE_INFO (t) != NULL_TREE)\n \t  {\n \t    DECL_TEMPLATE_INFO (r) = perm_tree_cons (tmpl, argvec, NULL_TREE);\n@@ -7141,6 +7144,7 @@ instantiate_decl (d)\n     goto out;\n \n   if (TREE_CODE (d) == VAR_DECL \n+      && TREE_READONLY (d)\n       && DECL_INITIAL (d) == NULL_TREE\n       && DECL_INITIAL (code_pattern) != NULL_TREE)\n     /* We need to set up DECL_INITIAL regardless of pattern_defined if"}]}