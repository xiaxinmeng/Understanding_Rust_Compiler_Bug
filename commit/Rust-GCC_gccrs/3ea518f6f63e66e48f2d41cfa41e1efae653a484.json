{"sha": "3ea518f6f63e66e48f2d41cfa41e1efae653a484", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VhNTE4ZjZmNjNlNjZlNDhmMmQ0MWNmYTQxZTFlZmFlNjUzYTQ4NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:58:06Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:58:06Z"}, "message": "Protect against min_profitable_iters going negative\n\nWe had:\n\n      if (vec_outside_cost <= 0)\n        min_profitable_iters = 0;\n      else\n        {\n\t  min_profitable_iters = ((vec_outside_cost - scalar_outside_cost)\n\t\t\t\t  * assumed_vf\n\t\t\t\t  - vec_inside_cost * peel_iters_prologue\n\t\t\t\t  - vec_inside_cost * peel_iters_epilogue)\n\t\t\t\t / ((scalar_single_iter_cost * assumed_vf)\n\t\t\t\t    - vec_inside_cost);\n\nwhich can lead to negative min_profitable_iters when the *_outside_costs\nare the same and peel_iters_epilogue is nonzero (e.g. if we're peeling\nfor gaps).\n\nThis is tested as part of the patch that adds support for fully-predicated\nloops.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vect-loop.c (vect_estimate_min_profitable_iters): Make sure\n\tmin_profitable_iters doesn't go negative.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256621", "tree": {"sha": "7473d7808fc322d3f684496efb33cccb2be4dc00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7473d7808fc322d3f684496efb33cccb2be4dc00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ea518f6f63e66e48f2d41cfa41e1efae653a484", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea518f6f63e66e48f2d41cfa41e1efae653a484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ea518f6f63e66e48f2d41cfa41e1efae653a484", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea518f6f63e66e48f2d41cfa41e1efae653a484/comments", "author": null, "committer": null, "parents": [{"sha": "7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e11fc7f5cecffe650b672ac1af212d4bd9f1335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e11fc7f5cecffe650b672ac1af212d4bd9f1335"}], "stats": {"total": 26, "additions": 17, "deletions": 9}, "files": [{"sha": "242ecb5c145418384dcfaf35d8327d9c2486a4b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea518f6f63e66e48f2d41cfa41e1efae653a484/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea518f6f63e66e48f2d41cfa41e1efae653a484/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ea518f6f63e66e48f2d41cfa41e1efae653a484", "patch": "@@ -1,3 +1,10 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vect-loop.c (vect_estimate_min_profitable_iters): Make sure\n+\tmin_profitable_iters doesn't go negative.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "5d6f1abc0b4f856b7f0d8e591e33ca1b14757d5b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea518f6f63e66e48f2d41cfa41e1efae653a484/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea518f6f63e66e48f2d41cfa41e1efae653a484/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=3ea518f6f63e66e48f2d41cfa41e1efae653a484", "patch": "@@ -3663,23 +3663,24 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \n   if ((scalar_single_iter_cost * assumed_vf) > (int) vec_inside_cost)\n     {\n-      if (vec_outside_cost <= 0)\n+      min_profitable_iters = ((vec_outside_cost - scalar_outside_cost)\n+\t\t\t      * assumed_vf\n+\t\t\t      - vec_inside_cost * peel_iters_prologue\n+\t\t\t      - vec_inside_cost * peel_iters_epilogue);\n+\n+      if (min_profitable_iters <= 0)\n         min_profitable_iters = 0;\n       else\n-        {\n-\t  min_profitable_iters = ((vec_outside_cost - scalar_outside_cost)\n-\t\t\t\t  * assumed_vf\n-\t\t\t\t  - vec_inside_cost * peel_iters_prologue\n-\t\t\t\t  - vec_inside_cost * peel_iters_epilogue)\n-\t\t\t\t / ((scalar_single_iter_cost * assumed_vf)\n-\t\t\t\t    - vec_inside_cost);\n+\t{\n+\t  min_profitable_iters /= ((scalar_single_iter_cost * assumed_vf)\n+\t\t\t\t   - vec_inside_cost);\n \n \t  if ((scalar_single_iter_cost * assumed_vf * min_profitable_iters)\n \t      <= (((int) vec_inside_cost * min_profitable_iters)\n \t\t  + (((int) vec_outside_cost - scalar_outside_cost)\n \t\t     * assumed_vf)))\n \t    min_profitable_iters++;\n-        }\n+\t}\n     }\n   /* vector version will never be profitable.  */\n   else"}]}