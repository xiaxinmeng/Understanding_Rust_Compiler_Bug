{"sha": "f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFlMWVkMzMxNGI3YzYzMDhmNjRjYmJjZjZkMTkxNmUyMzljOGUzNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-11-08T09:01:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-11-08T09:01:41Z"}, "message": "re PR tree-optimization/92324 (ICE in expand_direct_optab_fn, at internal-fn.c:2890)\n\n2019-11-08  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/92324\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Use\n\tSTMT_VINFO_REDUC_VECTYPE for all computations, inserting\n\tsign-conversions as necessary.\n\t(vectorizable_reduction): Reject conversions in the chain\n\tthat are not sign-conversions, base analysis on a non-converting\n\tstmt and its operation sign.  Set STMT_VINFO_REDUC_VECTYPE.\n\t* tree-vect-stmts.c (vect_stmt_relevant_p): Don't dump anything\n\tfor debug stmts.\n\t* tree-vectorizer.h (_stmt_vec_info::reduc_vectype): New.\n\t(STMT_VINFO_REDUC_VECTYPE): Likewise.\n\n\t* gcc.dg/vect/pr92205.c: XFAIL.\n\t* gcc.dg/vect/pr92324-1.c: New testcase.\n\t* gcc.dg/vect/pr92324-2.c: Likewise.\n\nFrom-SVN: r277955", "tree": {"sha": "4b4eff07e352630a9034187ca4ef7c64783766dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b4eff07e352630a9034187ca4ef7c64783766dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8e02ca9f5902e17eeb69bcafa084d46a886bc067", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e02ca9f5902e17eeb69bcafa084d46a886bc067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e02ca9f5902e17eeb69bcafa084d46a886bc067"}], "stats": {"total": 212, "additions": 123, "deletions": 89}, "files": [{"sha": "4b1f408d851b840c77dceb7687b4ea4aaf956a3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35", "patch": "@@ -1,3 +1,17 @@\n+2019-11-08  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92324\n+\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Use\n+\tSTMT_VINFO_REDUC_VECTYPE for all computations, inserting\n+\tsign-conversions as necessary.\n+\t(vectorizable_reduction): Reject conversions in the chain\n+\tthat are not sign-conversions, base analysis on a non-converting\n+\tstmt and its operation sign.  Set STMT_VINFO_REDUC_VECTYPE.\n+\t* tree-vect-stmts.c (vect_stmt_relevant_p): Don't dump anything\n+\tfor debug stmts.\n+\t* tree-vectorizer.h (_stmt_vec_info::reduc_vectype): New.\n+\t(STMT_VINFO_REDUC_VECTYPE): Likewise.\n+\n 2019-11-08  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/92055"}, {"sha": "358bbf5eb342901c5b804ecbe13de63fa054c378", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35", "patch": "@@ -1,3 +1,10 @@\n+2019-11-08  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92324\n+\t* gcc.dg/vect/pr92205.c: XFAIL.\n+\t* gcc.dg/vect/pr92324-1.c: New testcase.\n+\t* gcc.dg/vect/pr92324-2.c: Likewise.\n+\n 2019-11-08  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.target/aarch64/sve/acle/general-c/gnu_vectors_1.c: New test."}, {"sha": "a031c1fe297ca8af18630f0360c09bd20de0427c", "filename": "gcc/testsuite/gcc.dg/vect/pr92205.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr92205.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr92205.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr92205.c?ref=f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35", "patch": "@@ -10,4 +10,4 @@ int b(int n, unsigned char *a)\n   return d;\n }\n \n-/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" { target { vect_unpack && { ! vect_no_bitwise } } } } } */\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" { xfail *-*-* } } } */"}, {"sha": "a2847ef6eb36a195368831818773eed224516487", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 94, "deletions": 85, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35", "patch": "@@ -4231,7 +4231,6 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n   gimple *new_phi = NULL, *phi;\n   stmt_vec_info phi_info;\n   gimple_stmt_iterator exit_gsi;\n-  tree vec_dest;\n   tree new_temp = NULL_TREE, new_name, new_scalar_dest;\n   gimple *epilog_stmt = NULL;\n   gimple *exit_phi;\n@@ -4264,7 +4263,7 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n     }\n   gcc_assert (!nested_in_vect_loop || double_reduc);\n \n-  vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  vectype = STMT_VINFO_REDUC_VECTYPE (reduc_info);\n   gcc_assert (vectype);\n   mode = TYPE_MODE (vectype);\n \n@@ -4505,48 +4504,43 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n      one vector.  */\n   if (REDUC_GROUP_FIRST_ELEMENT (stmt_info) || direct_slp_reduc)\n     {\n+      gimple_seq stmts = NULL;\n       tree first_vect = PHI_RESULT (new_phis[0]);\n-      gassign *new_vec_stmt = NULL;\n-      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+      first_vect = gimple_convert (&stmts, vectype, first_vect);\n       for (k = 1; k < new_phis.length (); k++)\n         {\n \t  gimple *next_phi = new_phis[k];\n           tree second_vect = PHI_RESULT (next_phi);\n-          tree tem = make_ssa_name (vec_dest, new_vec_stmt);\n-          new_vec_stmt = gimple_build_assign (tem, code,\n-\t\t\t\t\t      first_vect, second_vect);\n-          gsi_insert_before (&exit_gsi, new_vec_stmt, GSI_SAME_STMT);\n-\t  first_vect = tem;\n+\t  second_vect = gimple_convert (&stmts, vectype, second_vect);\n+          first_vect = gimple_build (&stmts, code, vectype,\n+\t\t\t\t     first_vect, second_vect);\n         }\n+      gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n \n       new_phi_result = first_vect;\n-      if (new_vec_stmt)\n-        {\n-          new_phis.truncate (0);\n-          new_phis.safe_push (new_vec_stmt);\n-        }\n+      new_phis.truncate (0);\n+      new_phis.safe_push (SSA_NAME_DEF_STMT (first_vect));\n     }\n   /* Likewise if we couldn't use a single defuse cycle.  */\n   else if (ncopies > 1)\n     {\n       gcc_assert (new_phis.length () == 1);\n+      gimple_seq stmts = NULL;\n       tree first_vect = PHI_RESULT (new_phis[0]);\n-      gassign *new_vec_stmt = NULL;\n-      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+      first_vect = gimple_convert (&stmts, vectype, first_vect);\n       stmt_vec_info next_phi_info = loop_vinfo->lookup_stmt (new_phis[0]);\n       for (int k = 1; k < ncopies; ++k)\n \t{\n \t  next_phi_info = STMT_VINFO_RELATED_STMT (next_phi_info);\n \t  tree second_vect = PHI_RESULT (next_phi_info->stmt);\n-          tree tem = make_ssa_name (vec_dest, new_vec_stmt);\n-          new_vec_stmt = gimple_build_assign (tem, code,\n-\t\t\t\t\t      first_vect, second_vect);\n-          gsi_insert_before (&exit_gsi, new_vec_stmt, GSI_SAME_STMT);\n-\t  first_vect = tem;\n+\t  second_vect = gimple_convert (&stmts, vectype, second_vect);\n+\t  first_vect = gimple_build (&stmts, code, vectype,\n+\t\t\t\t     first_vect, second_vect);\n \t}\n+      gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n       new_phi_result = first_vect;\n       new_phis.truncate (0);\n-      new_phis.safe_push (new_vec_stmt);\n+      new_phis.safe_push (SSA_NAME_DEF_STMT (first_vect));\n     }\n   else\n     new_phi_result = PHI_RESULT (new_phis[0]);\n@@ -4877,13 +4871,14 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n \t in a vector mode of smaller size and first reduce upper/lower\n \t halves against each other.  */\n       enum machine_mode mode1 = mode;\n+      tree stype = TREE_TYPE (vectype);\n       unsigned sz = tree_to_uhwi (TYPE_SIZE_UNIT (vectype));\n       unsigned sz1 = sz;\n       if (!slp_reduc\n \t  && (mode1 = targetm.vectorize.split_reduction (mode)) != mode)\n \tsz1 = GET_MODE_SIZE (mode1).to_constant ();\n \n-      tree vectype1 = get_vectype_for_scalar_type_and_size (scalar_type, sz1);\n+      tree vectype1 = get_vectype_for_scalar_type_and_size (stype, sz1);\n       reduce_with_shift = have_whole_vector_shift (mode1);\n       if (!VECTOR_MODE_P (mode1))\n \treduce_with_shift = false;\n@@ -4901,7 +4896,7 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n \t{\n \t  gcc_assert (!slp_reduc);\n \t  sz /= 2;\n-\t  vectype1 = get_vectype_for_scalar_type_and_size (scalar_type, sz);\n+\t  vectype1 = get_vectype_for_scalar_type_and_size (stype, sz);\n \n \t  /* The target has to make sure we support lowpart/highpart\n \t     extraction, either via direct vector extract or through\n@@ -5004,26 +4999,21 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n             dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"Reduce using vector shifts\\n\");\n \n-          vec_dest = vect_create_destination_var (scalar_dest, vectype1);\n+\t  gimple_seq stmts = NULL;\n+\t  new_temp = gimple_convert (&stmts, vectype1, new_temp);\n           for (elt_offset = nelements / 2;\n                elt_offset >= 1;\n                elt_offset /= 2)\n             {\n \t      calc_vec_perm_mask_for_shift (elt_offset, nelements, &sel);\n \t      indices.new_vector (sel, 2, nelements);\n \t      tree mask = vect_gen_perm_mask_any (vectype1, indices);\n-\t      epilog_stmt = gimple_build_assign (vec_dest, VEC_PERM_EXPR,\n-\t\t\t\t\t\t new_temp, zero_vec, mask);\n-              new_name = make_ssa_name (vec_dest, epilog_stmt);\n-              gimple_assign_set_lhs (epilog_stmt, new_name);\n-              gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n-\n-\t      epilog_stmt = gimple_build_assign (vec_dest, code, new_name,\n-\t\t\t\t\t\t new_temp);\n-              new_temp = make_ssa_name (vec_dest, epilog_stmt);\n-              gimple_assign_set_lhs (epilog_stmt, new_temp);\n-              gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+\t      new_name = gimple_build (&stmts, VEC_PERM_EXPR, vectype1,\n+\t\t\t\t       new_temp, zero_vec, mask);\n+\t      new_temp = gimple_build (&stmts, code,\n+\t\t\t\t       vectype1, new_name, new_temp);\n             }\n+\t  gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n \n \t  /* 2.4  Extract the final scalar result.  Create:\n \t     s_out3 = extract_field <v_out2, bitpos>  */\n@@ -5696,7 +5686,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n \t\t\tstmt_vector_for_cost *cost_vec)\n {\n   tree scalar_dest;\n-  tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n   tree vectype_in = NULL_TREE;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -5763,13 +5752,53 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n \t  phi_info = loop_vinfo->lookup_stmt (use_stmt);\n \t  stmt_info = vect_stmt_to_vectorize (STMT_VINFO_REDUC_DEF (phi_info));\n \t}\n-      /* STMT_VINFO_REDUC_DEF doesn't point to the first but the last\n-         element.  */\n-      if (slp_node && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n+    }\n+\n+  /* PHIs should not participate in patterns.  */\n+  gcc_assert (!STMT_VINFO_RELATED_STMT (phi_info));\n+  gphi *reduc_def_phi = as_a <gphi *> (phi_info->stmt);\n+\n+  /* Verify following REDUC_IDX from the latch def leads us back to the PHI\n+     and compute the reduction chain length.  */\n+  tree reduc_def = PHI_ARG_DEF_FROM_EDGE (reduc_def_phi,\n+\t\t\t\t\t  loop_latch_edge (loop));\n+  unsigned reduc_chain_length = 0;\n+  bool only_slp_reduc_chain = true;\n+  stmt_info = NULL;\n+  while (reduc_def != PHI_RESULT (reduc_def_phi))\n+    {\n+      stmt_vec_info def = loop_vinfo->lookup_def (reduc_def);\n+      stmt_vec_info vdef = vect_stmt_to_vectorize (def);\n+      if (STMT_VINFO_REDUC_IDX (vdef) == -1)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"reduction chain broken by patterns.\\n\");\n+\t  return false;\n+\t}\n+      if (!REDUC_GROUP_FIRST_ELEMENT (vdef))\n+\tonly_slp_reduc_chain = false;\n+      /* ???  For epilogue generation live members of the chain need\n+         to point back to the PHI via their original stmt for\n+\t info_for_reduction to work.  */\n+      if (STMT_VINFO_LIVE_P (vdef))\n+\tSTMT_VINFO_REDUC_DEF (def) = phi_info;\n+      if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (vdef->stmt)))\n \t{\n-\t  gcc_assert (!REDUC_GROUP_NEXT_ELEMENT (stmt_info));\n-\t  stmt_info = REDUC_GROUP_FIRST_ELEMENT (stmt_info);\n+\t  if (!tree_nop_conversion_p (TREE_TYPE (gimple_assign_lhs (vdef->stmt)),\n+\t\t\t\t      TREE_TYPE (gimple_assign_rhs1 (vdef->stmt))))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"conversion in the reduction chain.\\n\");\n+\t      return false;\n+\t    }\n \t}\n+      else if (!stmt_info)\n+\t/* First non-conversion stmt.  */\n+\tstmt_info = vdef;\n+      reduc_def = gimple_op (vdef->stmt, 1 + STMT_VINFO_REDUC_IDX (vdef));\n+      reduc_chain_length++;\n     }\n   /* PHIs should not participate in patterns.  */\n   gcc_assert (!STMT_VINFO_RELATED_STMT (phi_info));\n@@ -5780,6 +5809,13 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n       nested_cycle = true;\n     }\n \n+  /* STMT_VINFO_REDUC_DEF doesn't point to the first but the last\n+     element.  */\n+  if (slp_node && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n+    {\n+      gcc_assert (!REDUC_GROUP_NEXT_ELEMENT (stmt_info));\n+      stmt_info = REDUC_GROUP_FIRST_ELEMENT (stmt_info);\n+    }\n   if (REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n     gcc_assert (slp_node\n \t\t&& REDUC_GROUP_FIRST_ELEMENT (stmt_info) == stmt_info);\n@@ -5815,6 +5851,8 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n         inside the loop body. The last operand is the reduction variable,\n         which is defined by the loop-header-phi.  */\n \n+  tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n+  STMT_VINFO_REDUC_VECTYPE (reduc_info) = vectype_out;\n   gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n   bool lane_reduc_code_p\n@@ -5831,40 +5869,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n   if (!type_has_mode_precision_p (scalar_type))\n     return false;\n \n-  /* All uses but the last are expected to be defined in the loop.\n-     The last use is the reduction variable.  In case of nested cycle this\n-     assumption is not true: we use reduc_index to record the index of the\n-     reduction variable.  */\n-  gphi *reduc_def_phi = as_a <gphi *> (phi_info->stmt);\n-\n-  /* Verify following REDUC_IDX from the latch def leads us back to the PHI\n-     and compute the reduction chain length.  */\n-  tree reduc_def = PHI_ARG_DEF_FROM_EDGE (reduc_def_phi,\n-\t\t\t\t\t  loop_latch_edge (loop));\n-  unsigned reduc_chain_length = 0;\n-  bool only_slp_reduc_chain = true;\n-  while (reduc_def != PHI_RESULT (reduc_def_phi))\n-    {\n-      stmt_vec_info def = loop_vinfo->lookup_def (reduc_def);\n-      stmt_vec_info vdef = vect_stmt_to_vectorize (def);\n-      if (STMT_VINFO_REDUC_IDX (vdef) == -1)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"reduction chain broken by patterns.\\n\");\n-\t  return false;\n-\t}\n-      if (!REDUC_GROUP_FIRST_ELEMENT (vdef))\n-\tonly_slp_reduc_chain = false;\n-      /* ???  For epilogue generation live members of the chain need\n-         to point back to the PHI via their original stmt for\n-\t info_for_reduction to work.  */\n-      if (STMT_VINFO_LIVE_P (vdef))\n-\tSTMT_VINFO_REDUC_DEF (def) = phi_info;\n-      reduc_def = gimple_op (vdef->stmt, 1 + STMT_VINFO_REDUC_IDX (vdef));\n-      reduc_chain_length++;\n-    }\n-\n   /* For lane-reducing ops we're reducing the number of reduction PHIs\n      which means the only use of that may be in the lane-reducing operation.  */\n   if (lane_reduc_code_p\n@@ -5877,6 +5881,10 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n       return false;\n     }\n \n+  /* All uses but the last are expected to be defined in the loop.\n+     The last use is the reduction variable.  In case of nested cycle this\n+     assumption is not true: we use reduc_index to record the index of the\n+     reduction variable.  */\n   reduc_def = PHI_RESULT (reduc_def_phi);\n   for (i = 0; i < op_type; i++)\n     {\n@@ -5931,7 +5939,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n \t}\n     }\n   if (!vectype_in)\n-    vectype_in = vectype_out;\n+    vectype_in = STMT_VINFO_VECTYPE (phi_info);\n   STMT_VINFO_REDUC_VECTYPE_IN (reduc_info) = vectype_in;\n \n   enum vect_reduction_type v_reduc_type = STMT_VINFO_REDUC_TYPE (phi_info);\n@@ -6037,12 +6045,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n \t}\n     }\n \n-  if (REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n-    /* We changed STMT to be the first stmt in reduction chain, hence we\n-       check that in this case the first element in the chain is STMT.  */\n-    gcc_assert (REDUC_GROUP_FIRST_ELEMENT (STMT_VINFO_REDUC_DEF (phi_info))\n-\t\t== vect_orig_stmt (stmt_info));\n-\n   if (STMT_VINFO_LIVE_P (phi_info))\n     return false;\n \n@@ -6447,8 +6449,15 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n       && code != SAD_EXPR\n       && reduction_type != FOLD_LEFT_REDUCTION)\n     {\n-      STMT_VINFO_DEF_TYPE (stmt_info) = vect_internal_def;\n-      STMT_VINFO_DEF_TYPE (vect_orig_stmt (stmt_info)) = vect_internal_def;\n+      stmt_vec_info tem\n+\t= vect_stmt_to_vectorize (STMT_VINFO_REDUC_DEF (phi_info));\n+      if (slp_node && REDUC_GROUP_FIRST_ELEMENT (tem))\n+\t{\n+\t  gcc_assert (!REDUC_GROUP_NEXT_ELEMENT (tem));\n+\t  tem = REDUC_GROUP_FIRST_ELEMENT (tem);\n+\t}\n+      STMT_VINFO_DEF_TYPE (vect_orig_stmt (tem)) = vect_internal_def;\n+      STMT_VINFO_DEF_TYPE (tem) = vect_internal_def;\n     }\n   else if (loop_vinfo && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n     {"}, {"sha": "eaca014097d00b692732e21d321ba8bb81e05bae", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35", "patch": "@@ -330,13 +330,13 @@ vect_stmt_relevant_p (stmt_vec_info stmt_info, loop_vec_info loop_vinfo,\n \t  basic_block bb = gimple_bb (USE_STMT (use_p));\n \t  if (!flow_bb_inside_loop_p (loop, bb))\n \t    {\n+\t      if (is_gimple_debug (USE_STMT (use_p)))\n+\t\tcontinue;\n+\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_NOTE, vect_location,\n                                  \"vec_stmt_relevant_p: used out of loop.\\n\");\n \n-\t      if (is_gimple_debug (USE_STMT (use_p)))\n-\t\tcontinue;\n-\n \t      /* We expect all such uses to be in the loop exit phis\n \t\t (because of loop closed form)   */\n \t      gcc_assert (gimple_code (USE_STMT (use_p)) == GIMPLE_PHI);"}, {"sha": "e9575a184ad02787cbdc6ea9059ef1dc35fbca94", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f1e1ed3314b7c6308f64cbbcf6d1916e239c8e35", "patch": "@@ -1050,6 +1050,9 @@ class _stmt_vec_info {\n   /* The vector input type relevant for reduction vectorization.  */\n   tree reduc_vectype_in;\n \n+  /* The vector type for performing the actual reduction.  */\n+  tree reduc_vectype;\n+\n   /* Whether we force a single cycle PHI during reduction vectorization.  */\n   bool force_single_cycle;\n \n@@ -1175,6 +1178,7 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_REDUC_CODE(S)\t(S)->reduc_code\n #define STMT_VINFO_REDUC_FN(S)\t\t(S)->reduc_fn\n #define STMT_VINFO_REDUC_DEF(S)\t\t(S)->reduc_def\n+#define STMT_VINFO_REDUC_VECTYPE(S)     (S)->reduc_vectype\n #define STMT_VINFO_REDUC_VECTYPE_IN(S)  (S)->reduc_vectype_in\n #define STMT_VINFO_SLP_VECT_ONLY(S)     (S)->slp_vect_only_p\n "}]}