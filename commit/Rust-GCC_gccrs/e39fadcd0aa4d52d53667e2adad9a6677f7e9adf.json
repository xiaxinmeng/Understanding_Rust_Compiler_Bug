{"sha": "e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "node_id": "C_kwDOANBUbNoAKGUzOWZhZGNkMGFhNGQ1MmQ1MzY2N2UyYWRhZDlhNjY3N2Y3ZTlhZGY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-12-04T22:02:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-04T22:02:22Z"}, "message": "Merge #1611\n\n1611: Initial state capture for closures r=philberty a=philberty\n\nThis patch set adds the initial support closure captures, move semantics are not\r\nhandled here. We track what variables are being captured by a closure during\r\nname resolution so that when a VAR_DECL is resolved, we check if we are inside\r\na closure context node_id which is the same id as its associated rib id. So when\r\nwe resolve a name that resides in an outermost rib we can add this to set of \r\nnode-id's that are captured by this closure.\r\n\r\nThere is a gap here for the case where we need to check if it is inside a nested\r\nfunction and that function contains closures which could wrongly capture variables\r\nin the enclosing function. This will also be a problem for nested functions in general.\r\n\r\nFixes #195\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "b412e8330dfb14001b7c66483520fe99e029f4d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b412e8330dfb14001b7c66483520fe99e029f4d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjjRjuCRBK7hj4Ov3rIwAAV9AIAAFamYhHSubG5cbheVw/Sq9s\np3SX49bwGjexFDLFEY9PtfDEkqaT5v28CYdZmV1Qq/opVdpYqyphw1QOOGyNVnqN\ntqae6pcXScoh/cW4b0hU5QmRN0sI9nKO9g9U0a1HmJgIq5d8j6xHWpSyvYCHCTid\nrW7y+UU2nTF/EN4T/WcCo1Upj7azlBxB+t0R9F3lAw1qxpKLV3a2jwrb5DakR0Bo\nOhY892dwR4ADMieBLFtq5tVtSbQCc5OAfY2SEHAPx9nVkWL5a7Y9dAiuGX7O3a1p\nhNcS7pc/M90YW6cBCM7uAdHoy9n0qAGwBbj0CMuZaHlfP+M/Yh3cs8Ju4gGVFUY=\n=niE8\n-----END PGP SIGNATURE-----\n", "payload": "tree b412e8330dfb14001b7c66483520fe99e029f4d2\nparent 22329b03a6e0a3381d907745205012cf290b3c2a\nparent 3053ec366093560a6269aaace61ce77fb8710b01\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1670191342 +0000\ncommitter GitHub <noreply@github.com> 1670191342 +0000\n\nMerge #1611\n\n1611: Initial state capture for closures r=philberty a=philberty\n\nThis patch set adds the initial support closure captures, move semantics are not\r\nhandled here. We track what variables are being captured by a closure during\r\nname resolution so that when a VAR_DECL is resolved, we check if we are inside\r\na closure context node_id which is the same id as its associated rib id. So when\r\nwe resolve a name that resides in an outermost rib we can add this to set of \r\nnode-id's that are captured by this closure.\r\n\r\nThere is a gap here for the case where we need to check if it is inside a nested\r\nfunction and that function contains closures which could wrongly capture variables\r\nin the enclosing function. This will also be a problem for nested functions in general.\r\n\r\nFixes #195\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22329b03a6e0a3381d907745205012cf290b3c2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22329b03a6e0a3381d907745205012cf290b3c2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22329b03a6e0a3381d907745205012cf290b3c2a"}, {"sha": "3053ec366093560a6269aaace61ce77fb8710b01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3053ec366093560a6269aaace61ce77fb8710b01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3053ec366093560a6269aaace61ce77fb8710b01"}], "stats": {"total": 598, "additions": 498, "deletions": 100}, "files": [{"sha": "0687398808d03a122371b656b94093dbeda4e6d1", "filename": "gcc/rust/backend/rust-compile-context.cc", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fbackend%2Frust-compile-context.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fbackend%2Frust-compile-context.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.cc?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -142,5 +142,52 @@ Context::type_hasher (tree type)\n   return hstate.end ();\n }\n \n+void\n+Context::push_closure_context (HirId id)\n+{\n+  auto it = closure_bindings.find (id);\n+  rust_assert (it == closure_bindings.end ());\n+\n+  closure_bindings.insert ({id, {}});\n+  closure_scope_bindings.push_back (id);\n+}\n+\n+void\n+Context::pop_closure_context ()\n+{\n+  rust_assert (!closure_scope_bindings.empty ());\n+\n+  HirId ref = closure_scope_bindings.back ();\n+  closure_scope_bindings.pop_back ();\n+  closure_bindings.erase (ref);\n+}\n+\n+void\n+Context::insert_closure_binding (HirId id, tree expr)\n+{\n+  rust_assert (!closure_scope_bindings.empty ());\n+\n+  HirId ref = closure_scope_bindings.back ();\n+  closure_bindings[ref].insert ({id, expr});\n+}\n+\n+bool\n+Context::lookup_closure_binding (HirId id, tree *expr)\n+{\n+  if (closure_scope_bindings.empty ())\n+    return false;\n+\n+  HirId ref = closure_scope_bindings.back ();\n+  auto it = closure_bindings.find (ref);\n+  rust_assert (it != closure_bindings.end ());\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return false;\n+\n+  *expr = iy->second;\n+  return true;\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "7744f01dca33f2867c97859283020bc131b0372f", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -345,6 +345,11 @@ class Context\n     return mangler.mangle_item (ty, path);\n   }\n \n+  void push_closure_context (HirId id);\n+  void pop_closure_context ();\n+  void insert_closure_binding (HirId id, tree expr);\n+  bool lookup_closure_binding (HirId id, tree *expr);\n+\n   std::vector<tree> &get_type_decls () { return type_decls; }\n   std::vector<::Bvariable *> &get_var_decls () { return var_decls; }\n   std::vector<tree> &get_const_decls () { return const_decls; }\n@@ -377,6 +382,10 @@ class Context\n   std::map<HirId, tree> implicit_pattern_bindings;\n   std::map<hashval_t, tree> main_variants;\n \n+  // closure bindings\n+  std::vector<HirId> closure_scope_bindings;\n+  std::map<HirId, std::map<HirId, tree>> closure_bindings;\n+\n   // To GCC middle-end\n   std::vector<tree> type_decls;\n   std::vector<::Bvariable *> var_decls;"}, {"sha": "e50df63821f6eb156d66bfbffc35b589b0e9c5c9", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -2824,10 +2824,25 @@ CompileExpr::visit (HIR::ClosureExpr &expr)\n \n   // lets ignore state capture for now we need to instantiate the struct anyway\n   // then generate the function\n-\n   std::vector<tree> vals;\n-  // TODO\n-  // setup argument captures based on the mode?\n+  for (const auto &capture : closure_tyty->get_captures ())\n+    {\n+      // lookup the HirId\n+      HirId ref = UNKNOWN_HIRID;\n+      bool ok = ctx->get_mappings ()->lookup_node_to_hir (capture, &ref);\n+      rust_assert (ok);\n+\n+      // lookup the var decl\n+      Bvariable *var = nullptr;\n+      bool found = ctx->lookup_var_decl (ref, &var);\n+      rust_assert (found);\n+\n+      // FIXME\n+      // this should bes based on the closure move-ability\n+      tree var_expr = var->get_tree (expr.get_locus ());\n+      tree val = address_expression (var_expr, expr.get_locus ());\n+      vals.push_back (val);\n+    }\n \n   translated\n     = ctx->get_backend ()->constructor_expression (compiled_closure_tyty, false,\n@@ -2874,8 +2889,29 @@ CompileExpr::generate_closure_function (HIR::ClosureExpr &expr,\n   DECL_ARTIFICIAL (self_param->get_decl ()) = 1;\n   param_vars.push_back (self_param);\n \n+  // push a new context\n+  ctx->push_closure_context (expr.get_mappings ().get_hirid ());\n+\n   // setup the implicit argument captures\n-  // TODO\n+  size_t idx = 0;\n+  for (const auto &capture : closure_tyty.get_captures ())\n+    {\n+      // lookup the HirId\n+      HirId ref = UNKNOWN_HIRID;\n+      bool ok = ctx->get_mappings ()->lookup_node_to_hir (capture, &ref);\n+      rust_assert (ok);\n+\n+      // get the assessor\n+      tree binding = ctx->get_backend ()->struct_field_expression (\n+\tself_param->get_tree (expr.get_locus ()), idx, expr.get_locus ());\n+      tree indirection = indirect_expression (binding, expr.get_locus ());\n+\n+      // insert bindings\n+      ctx->insert_closure_binding (ref, indirection);\n+\n+      // continue\n+      idx++;\n+    }\n \n   // args tuple\n   tree args_type\n@@ -2905,7 +2941,10 @@ CompileExpr::generate_closure_function (HIR::ClosureExpr &expr,\n     }\n \n   if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n-    return error_mark_node;\n+    {\n+      ctx->pop_closure_context ();\n+      return error_mark_node;\n+    }\n \n   // lookup locals\n   HIR::Expr *function_body = expr.get_expr ().get ();\n@@ -2972,6 +3011,7 @@ CompileExpr::generate_closure_function (HIR::ClosureExpr &expr,\n   gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n   DECL_SAVED_TREE (fndecl) = bind_tree;\n \n+  ctx->pop_closure_context ();\n   ctx->pop_fn ();\n   ctx->push_function (fndecl);\n "}, {"sha": "eaa748ada3edc40f2e529be8437d5ca7133b1b5b", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -121,6 +121,14 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n       return constant_expr;\n     }\n \n+  // maybe closure binding\n+  tree closure_binding = error_mark_node;\n+  if (ctx->lookup_closure_binding (ref, &closure_binding))\n+    {\n+      TREE_USED (closure_binding) = 1;\n+      return closure_binding;\n+    }\n+\n   // this might be a variable reference or a function reference\n   Bvariable *var = nullptr;\n   if (ctx->lookup_var_decl (ref, &var))"}, {"sha": "4c72d6f56855fbc9ff238780a7806b299cdc0f38", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -19,6 +19,7 @@\n #include \"rust-compile-type.h\"\n #include \"rust-compile-expr.h\"\n #include \"rust-constexpr.h\"\n+#include \"rust-gcc.h\"\n \n #include \"tree.h\"\n \n@@ -99,11 +100,39 @@ TyTyResolveCompile::visit (const TyTy::InferType &)\n void\n TyTyResolveCompile::visit (const TyTy::ClosureType &type)\n {\n+  auto mappings = ctx->get_mappings ();\n+\n   std::vector<Backend::typed_identifier> fields;\n+\n+  size_t i = 0;\n+  for (const auto &capture : type.get_captures ())\n+    {\n+      // lookup the HirId\n+      HirId ref = UNKNOWN_HIRID;\n+      bool ok = mappings->lookup_node_to_hir (capture, &ref);\n+      rust_assert (ok);\n+\n+      // lookup the var decl type\n+      TyTy::BaseType *lookup = nullptr;\n+      bool found = ctx->get_tyctx ()->lookup_type (ref, &lookup);\n+      rust_assert (found);\n+\n+      // FIXME get the var pattern name\n+      std::string mappings_name = \"capture_\" + std::to_string (i);\n+\n+      // FIXME\n+      // this should be based on the closure move-ability\n+      tree decl_type = TyTyResolveCompile::compile (ctx, lookup);\n+      tree capture_type = build_reference_type (decl_type);\n+      fields.push_back (Backend::typed_identifier (mappings_name, capture_type,\n+\t\t\t\t\t\t   type.get_ident ().locus));\n+    }\n+\n   tree type_record = ctx->get_backend ()->struct_type (fields);\n   RS_CLOSURE_FLAG (type_record) = 1;\n \n-  std::string named_struct_str = type.get_ident ().path.get () + \"{{closure}}\";\n+  std::string named_struct_str\n+    = type.get_ident ().path.get () + \"::{{closure}}\";\n   translated = ctx->get_backend ()->named_type (named_struct_str, type_record,\n \t\t\t\t\t\ttype.get_ident ().locus);\n }"}, {"sha": "2063dceb2e1ef00b60faeefdf097cf63c7f66c2d", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.cc", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -209,7 +209,7 @@ ResolveExpr::visit (AST::IfLetExpr &expr)\n \n   for (auto &pattern : expr.get_patterns ())\n     {\n-      PatternDeclaration::go (pattern.get ());\n+      PatternDeclaration::go (pattern.get (), Rib::ItemType::Var);\n     }\n \n   ResolveExpr::go (expr.get_if_block ().get (), prefix, canonical_prefix);\n@@ -343,7 +343,7 @@ ResolveExpr::visit (AST::LoopExpr &expr)\n       auto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n       resolver->get_label_scope ().insert (\n \tCanonicalPath::new_seg (expr.get_node_id (), label_name),\n-\tlabel_lifetime_node_id, label.get_locus (), false,\n+\tlabel_lifetime_node_id, label.get_locus (), false, Rib::ItemType::Label,\n \t[&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \t  rust_error_at (label.get_locus (), \"label redefined multiple times\");\n \t  rust_error_at (locus, \"was defined here\");\n@@ -400,7 +400,7 @@ ResolveExpr::visit (AST::WhileLoopExpr &expr)\n       auto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n       resolver->get_label_scope ().insert (\n \tCanonicalPath::new_seg (label.get_node_id (), label_name),\n-\tlabel_lifetime_node_id, label.get_locus (), false,\n+\tlabel_lifetime_node_id, label.get_locus (), false, Rib::ItemType::Label,\n \t[&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \t  rust_error_at (label.get_locus (), \"label redefined multiple times\");\n \t  rust_error_at (locus, \"was defined here\");\n@@ -429,7 +429,7 @@ ResolveExpr::visit (AST::ForLoopExpr &expr)\n       auto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n       resolver->get_label_scope ().insert (\n \tCanonicalPath::new_seg (label.get_node_id (), label_name),\n-\tlabel_lifetime_node_id, label.get_locus (), false,\n+\tlabel_lifetime_node_id, label.get_locus (), false, Rib::ItemType::Label,\n \t[&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \t  rust_error_at (label.get_locus (), \"label redefined multiple times\");\n \t  rust_error_at (locus, \"was defined here\");\n@@ -446,7 +446,7 @@ ResolveExpr::visit (AST::ForLoopExpr &expr)\n   resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n \n   // resolve the expression\n-  PatternDeclaration::go (expr.get_pattern ().get ());\n+  PatternDeclaration::go (expr.get_pattern ().get (), Rib::ItemType::Var);\n   ResolveExpr::go (expr.get_iterator_expr ().get (), prefix, canonical_prefix);\n   ResolveExpr::go (expr.get_loop_block ().get (), prefix, canonical_prefix);\n \n@@ -520,7 +520,7 @@ ResolveExpr::visit (AST::MatchExpr &expr)\n       // insert any possible new patterns\n       for (auto &pattern : arm.get_patterns ())\n \t{\n-\t  PatternDeclaration::go (pattern.get ());\n+\t  PatternDeclaration::go (pattern.get (), Rib::ItemType::Var);\n \t}\n \n       // resolve the body\n@@ -581,9 +581,13 @@ ResolveExpr::visit (AST::ClosureExprInner &expr)\n       resolve_closure_param (p);\n     }\n \n+  resolver->push_closure_context (expr.get_node_id ());\n+\n   ResolveExpr::go (expr.get_definition_expr ().get (), prefix,\n \t\t   canonical_prefix);\n \n+  resolver->pop_closure_context ();\n+\n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n   resolver->get_label_scope ().pop ();\n@@ -606,9 +610,14 @@ ResolveExpr::visit (AST::ClosureExprInnerTyped &expr)\n     }\n \n   ResolveType::go (expr.get_return_type ().get ());\n+\n+  resolver->push_closure_context (expr.get_node_id ());\n+\n   ResolveExpr::go (expr.get_definition_block ().get (), prefix,\n \t\t   canonical_prefix);\n \n+  resolver->pop_closure_context ();\n+\n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n   resolver->get_label_scope ().pop ();\n@@ -617,7 +626,7 @@ ResolveExpr::visit (AST::ClosureExprInnerTyped &expr)\n void\n ResolveExpr::resolve_closure_param (AST::ClosureParam &param)\n {\n-  PatternDeclaration::go (param.get_pattern ().get ());\n+  PatternDeclaration::go (param.get_pattern ().get (), Rib::ItemType::Param);\n \n   if (param.has_type_given ())\n     ResolveType::go (param.get_type ().get ());"}, {"sha": "f334b71b884a19cc68c7af39140c3b5b8fa36718", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -56,7 +56,7 @@ class ResolveToplevelImplItem : public ResolverBase\n     auto path = prefix.append (decl);\n \n     resolver->get_type_scope ().insert (\n-      path, type.get_node_id (), type.get_locus (), false,\n+      path, type.get_node_id (), type.get_locus (), false, Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (type.get_locus ());\n \tr.add_range (locus);\n@@ -72,6 +72,7 @@ class ResolveToplevelImplItem : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       path, constant.get_node_id (), constant.get_locus (), false,\n+      Rib::ItemType::Const,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (constant.get_locus ());\n \tr.add_range (locus);\n@@ -87,6 +88,7 @@ class ResolveToplevelImplItem : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n+      Rib::ItemType::Function,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (function.get_locus ());\n \tr.add_range (locus);\n@@ -102,6 +104,7 @@ class ResolveToplevelImplItem : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       path, method.get_node_id (), method.get_locus (), false,\n+      Rib::ItemType::Function,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (method.get_locus ());\n \tr.add_range (locus);\n@@ -141,6 +144,7 @@ class ResolveTopLevelTraitItems : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n+      Rib::ItemType::Function,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (function.get_locus ());\n \tr.add_range (locus);\n@@ -159,6 +163,7 @@ class ResolveTopLevelTraitItems : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       path, method.get_node_id (), method.get_locus (), false,\n+      Rib::ItemType::Function,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (method.get_locus ());\n \tr.add_range (locus);\n@@ -177,6 +182,7 @@ class ResolveTopLevelTraitItems : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       path, constant.get_node_id (), constant.get_locus (), false,\n+      Rib::ItemType::Const,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (constant.get_locus ());\n \tr.add_range (locus);\n@@ -194,7 +200,7 @@ class ResolveTopLevelTraitItems : public ResolverBase\n     auto cpath = canonical_prefix.append (decl);\n \n     resolver->get_type_scope ().insert (\n-      path, type.get_node_id (), type.get_locus (), false,\n+      path, type.get_node_id (), type.get_locus (), false, Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (type.get_locus ());\n \tr.add_range (locus);\n@@ -233,6 +239,7 @@ class ResolveToplevelExternItem : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n+      Rib::ItemType::Function,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (function.get_locus ());\n \tr.add_range (locus);\n@@ -251,6 +258,7 @@ class ResolveToplevelExternItem : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n+      Rib::ItemType::Static,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);"}, {"sha": "8b9990f75f4384af7d1c9e7a7ee87ad45888f800", "filename": "gcc/rust/resolve/rust-ast-resolve-item.cc", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -82,7 +82,8 @@ ResolveTraitItems::visit (AST::TraitItemFunc &func)\n   for (auto &param : function.get_function_params ())\n     {\n       ResolveType::go (param.get_type ().get ());\n-      PatternDeclaration::go (param.get_pattern ().get ());\n+      PatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t      Rib::ItemType::Param);\n     }\n \n   if (function.has_where_clause ())\n@@ -138,14 +139,15 @@ ResolveTraitItems::visit (AST::TraitItemMethod &func)\n   AST::TypePath self_type_path (std::move (segments), self_param.get_locus ());\n \n   ResolveType::go (&self_type_path);\n-  PatternDeclaration::go (&self_pattern);\n+  PatternDeclaration::go (&self_pattern, Rib::ItemType::Param);\n \n   // we make a new scope so the names of parameters are resolved and shadowed\n   // correctly\n   for (auto &param : function.get_function_params ())\n     {\n       ResolveType::go (param.get_type ().get ());\n-      PatternDeclaration::go (param.get_pattern ().get ());\n+      PatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t      Rib::ItemType::Param);\n     }\n \n   if (function.has_where_clause ())\n@@ -499,10 +501,8 @@ ResolveItem::visit (AST::Function &function)\n   for (auto &param : function.get_function_params ())\n     {\n       ResolveType::go (param.get_type ().get ());\n-      PatternDeclaration::go (param.get_pattern ().get ());\n-\n-      // the mutability checker needs to verify for immutable decls the number\n-      // of assignments are <1. This marks an implicit assignment\n+      PatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t      Rib::ItemType::Param);\n     }\n \n   // resolve the function body\n@@ -631,14 +631,15 @@ ResolveItem::visit (AST::Method &method)\n   AST::TypePath self_type_path (std::move (segments), self_param.get_locus ());\n \n   ResolveType::go (&self_type_path);\n-  PatternDeclaration::go (&self_pattern);\n+  PatternDeclaration::go (&self_pattern, Rib::ItemType::Param);\n \n   // we make a new scope so the names of parameters are resolved and shadowed\n   // correctly\n   for (auto &param : method.get_function_params ())\n     {\n       ResolveType::go (param.get_type ().get ());\n-      PatternDeclaration::go (param.get_pattern ().get ());\n+      PatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t      Rib::ItemType::Param);\n     }\n \n   // resolve any where clause items"}, {"sha": "05dadfd6cd7b84b8bff634e0600a9d247412b354", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -49,7 +49,7 @@ PatternDeclaration::visit (AST::TupleStructPattern &pattern)\n \n \tfor (auto &inner_pattern : items_no_range.get_patterns ())\n \t  {\n-\t    PatternDeclaration::go (inner_pattern.get ());\n+\t    PatternDeclaration::go (inner_pattern.get (), type);\n \t  }\n       }\n       break;"}, {"sha": "6e86c409250788fa7fcd5459f794e09559d45326", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -55,9 +55,9 @@ class PatternDeclaration : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Pattern *pattern)\n+  static void go (AST::Pattern *pattern, Rib::ItemType type)\n   {\n-    PatternDeclaration resolver;\n+    PatternDeclaration resolver (type);\n     pattern->accept_vis (resolver);\n   };\n \n@@ -67,14 +67,14 @@ class PatternDeclaration : public ResolverBase\n     // as new refs to this decl will match back here so it is ok to overwrite\n     resolver->get_name_scope ().insert (\n       CanonicalPath::new_seg (pattern.get_node_id (), pattern.get_ident ()),\n-      pattern.get_node_id (), pattern.get_locus ());\n+      pattern.get_node_id (), pattern.get_locus (), type);\n   }\n \n   void visit (AST::WildcardPattern &pattern) override\n   {\n     resolver->get_name_scope ().insert (\n       CanonicalPath::new_seg (pattern.get_node_id (), \"_\"),\n-      pattern.get_node_id (), pattern.get_locus ());\n+      pattern.get_node_id (), pattern.get_locus (), type);\n   }\n \n   // cases in a match expression\n@@ -89,7 +89,9 @@ class PatternDeclaration : public ResolverBase\n   void visit (AST::RangePattern &pattern) override;\n \n private:\n-  PatternDeclaration () : ResolverBase () {}\n+  PatternDeclaration (Rib::ItemType type) : ResolverBase (), type (type) {}\n+\n+  Rib::ItemType type;\n };\n \n } // namespace Resolver"}, {"sha": "cf74ea245da893831b1b57b23bd65d9299ca3507", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -64,6 +64,7 @@ class ResolveStmt : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       path, constant.get_node_id (), constant.get_locus (), false,\n+      Rib::ItemType::Const,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (constant.get_locus ());\n \tr.add_range (locus);\n@@ -82,7 +83,7 @@ class ResolveStmt : public ResolverBase\n \t\t\t canonical_prefix);\n       }\n \n-    PatternDeclaration::go (stmt.get_pattern ().get ());\n+    PatternDeclaration::go (stmt.get_pattern ().get (), Rib::ItemType::Var);\n     if (stmt.has_type ())\n       ResolveType::go (stmt.get_type ().get ());\n   }\n@@ -97,6 +98,7 @@ class ResolveStmt : public ResolverBase\n \n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n+      Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (struct_decl.get_locus ());\n \tr.add_range (locus);\n@@ -128,6 +130,7 @@ class ResolveStmt : public ResolverBase\n \n     resolver->get_type_scope ().insert (\n       path, enum_decl.get_node_id (), enum_decl.get_locus (), false,\n+      Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (enum_decl.get_locus ());\n \tr.add_range (locus);\n@@ -158,7 +161,7 @@ class ResolveStmt : public ResolverBase\n     mappings->insert_canonical_path (item.get_node_id (), cpath);\n \n     resolver->get_type_scope ().insert (\n-      path, item.get_node_id (), item.get_locus (), false,\n+      path, item.get_node_id (), item.get_locus (), false, Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n@@ -177,7 +180,7 @@ class ResolveStmt : public ResolverBase\n     mappings->insert_canonical_path (item.get_node_id (), cpath);\n \n     resolver->get_type_scope ().insert (\n-      path, item.get_node_id (), item.get_locus (), false,\n+      path, item.get_node_id (), item.get_locus (), false, Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n@@ -202,7 +205,7 @@ class ResolveStmt : public ResolverBase\n     mappings->insert_canonical_path (item.get_node_id (), cpath);\n \n     resolver->get_type_scope ().insert (\n-      path, item.get_node_id (), item.get_locus (), false,\n+      path, item.get_node_id (), item.get_locus (), false, Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n@@ -227,7 +230,7 @@ class ResolveStmt : public ResolverBase\n     mappings->insert_canonical_path (item.get_node_id (), cpath);\n \n     resolver->get_type_scope ().insert (\n-      path, item.get_node_id (), item.get_locus (), false,\n+      path, item.get_node_id (), item.get_locus (), false, Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n@@ -247,6 +250,7 @@ class ResolveStmt : public ResolverBase\n \n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n+      Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (struct_decl.get_locus ());\n \tr.add_range (locus);\n@@ -283,6 +287,7 @@ class ResolveStmt : public ResolverBase\n \n     resolver->get_type_scope ().insert (\n       path, union_decl.get_node_id (), union_decl.get_locus (), false,\n+      Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (union_decl.get_locus ());\n \tr.add_range (locus);\n@@ -317,6 +322,7 @@ class ResolveStmt : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n+      Rib::ItemType::Function,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (function.get_locus ());\n \tr.add_range (locus);\n@@ -343,7 +349,8 @@ class ResolveStmt : public ResolverBase\n     for (auto &param : function.get_function_params ())\n       {\n \tResolveType::go (param.get_type ().get ());\n-\tPatternDeclaration::go (param.get_pattern ().get ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tRib::ItemType::Param);\n       }\n \n     // resolve the function body"}, {"sha": "c07152022d931f194120f8ca389bcc0290888946", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -57,6 +57,7 @@ class ResolveTopLevel : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       path, module.get_node_id (), module.get_locus (), false,\n+      Rib::ItemType::Module,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (module.get_locus ());\n \tr.add_range (locus);\n@@ -85,6 +86,7 @@ class ResolveTopLevel : public ResolverBase\n \n     resolver->get_type_scope ().insert (\n       path, alias.get_node_id (), alias.get_locus (), false,\n+      Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (alias.get_locus ());\n \tr.add_range (locus);\n@@ -105,6 +107,7 @@ class ResolveTopLevel : public ResolverBase\n \n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n+      Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (struct_decl.get_locus ());\n \tr.add_range (locus);\n@@ -125,6 +128,7 @@ class ResolveTopLevel : public ResolverBase\n \n     resolver->get_type_scope ().insert (\n       path, enum_decl.get_node_id (), enum_decl.get_locus (), false,\n+      Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (enum_decl.get_locus ());\n \tr.add_range (locus);\n@@ -147,7 +151,7 @@ class ResolveTopLevel : public ResolverBase\n     auto cpath = canonical_prefix.append (decl);\n \n     resolver->get_type_scope ().insert (\n-      path, item.get_node_id (), item.get_locus (), false,\n+      path, item.get_node_id (), item.get_locus (), false, Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n@@ -165,7 +169,7 @@ class ResolveTopLevel : public ResolverBase\n     auto cpath = canonical_prefix.append (decl);\n \n     resolver->get_type_scope ().insert (\n-      path, item.get_node_id (), item.get_locus (), false,\n+      path, item.get_node_id (), item.get_locus (), false, Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n@@ -183,7 +187,7 @@ class ResolveTopLevel : public ResolverBase\n     auto cpath = canonical_prefix.append (decl);\n \n     resolver->get_type_scope ().insert (\n-      path, item.get_node_id (), item.get_locus (), false,\n+      path, item.get_node_id (), item.get_locus (), false, Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n@@ -201,7 +205,7 @@ class ResolveTopLevel : public ResolverBase\n     auto cpath = canonical_prefix.append (decl);\n \n     resolver->get_type_scope ().insert (\n-      path, item.get_node_id (), item.get_locus (), false,\n+      path, item.get_node_id (), item.get_locus (), false, Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n@@ -220,6 +224,7 @@ class ResolveTopLevel : public ResolverBase\n \n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n+      Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (struct_decl.get_locus ());\n \tr.add_range (locus);\n@@ -240,6 +245,7 @@ class ResolveTopLevel : public ResolverBase\n \n     resolver->get_type_scope ().insert (\n       path, union_decl.get_node_id (), union_decl.get_locus (), false,\n+      Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (union_decl.get_locus ());\n \tr.add_range (locus);\n@@ -259,7 +265,7 @@ class ResolveTopLevel : public ResolverBase\n     auto cpath = canonical_prefix.append (decl);\n \n     resolver->get_name_scope ().insert (\n-      path, var.get_node_id (), var.get_locus (), false,\n+      path, var.get_node_id (), var.get_locus (), false, Rib::ItemType::Static,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (var.get_locus ());\n \tr.add_range (locus);\n@@ -280,6 +286,7 @@ class ResolveTopLevel : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       path, constant.get_node_id (), constant.get_locus (), false,\n+      Rib::ItemType::Const,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (constant.get_locus ());\n \tr.add_range (locus);\n@@ -300,6 +307,7 @@ class ResolveTopLevel : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n+      Rib::ItemType::Function,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (function.get_locus ());\n \tr.add_range (locus);\n@@ -343,6 +351,7 @@ class ResolveTopLevel : public ResolverBase\n \n     resolver->get_name_scope ().insert (\n       impl_prefix, impl_block.get_node_id (), impl_block.get_locus (), false,\n+      Rib::ItemType::TraitImpl,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (impl_block.get_locus ());\n \tr.add_range (locus);\n@@ -362,6 +371,7 @@ class ResolveTopLevel : public ResolverBase\n \n     resolver->get_type_scope ().insert (\n       path, trait.get_node_id (), trait.get_locus (), false,\n+      Rib::ItemType::Trait,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (trait.get_locus ());\n \tr.add_range (locus);\n@@ -437,6 +447,7 @@ class ResolveTopLevel : public ResolverBase\n \n     resolver->get_type_scope ().insert (\n       decl, resolved_crate, extern_crate.get_locus (), false,\n+      Rib::ItemType::ExternCrate,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (extern_crate.get_locus ());\n \tr.add_range (locus);"}, {"sha": "8e1dbc68e7b6701e8a717a5640129e2c2028039c", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -177,7 +177,7 @@ class ResolveGenericParam : public ResolverBase\n     auto seg = CanonicalPath::new_seg (param.get_node_id (),\n \t\t\t\t       param.get_type_representation ());\n     resolver->get_type_scope ().insert (\n-      seg, param.get_node_id (), param.get_locus (), false,\n+      seg, param.get_node_id (), param.get_locus (), false, Rib::ItemType::Type,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (param.get_locus (),\n \t\t       \"generic param redefined multiple times\");"}, {"sha": "59aed21bd876d8e3f38b7562e0dc3cefdcc9bf88", "filename": "gcc/rust/resolve/rust-name-resolver.cc", "status": "modified", "additions": 193, "deletions": 48, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -19,40 +19,17 @@\n #include \"rust-name-resolver.h\"\n #include \"rust-ast-full.h\"\n \n-#define MKBUILTIN_TYPE(_X, _R, _TY)                                            \\\n-  do                                                                           \\\n-    {                                                                          \\\n-      AST::PathIdentSegment seg (_X, Linemap::predeclared_location ());        \\\n-      auto typePath = ::std::unique_ptr<AST::TypePathSegment> (                \\\n-\tnew AST::TypePathSegment (::std::move (seg), false,                    \\\n-\t\t\t\t  Linemap::predeclared_location ()));          \\\n-      ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;           \\\n-      segs.push_back (::std::move (typePath));                                 \\\n-      auto builtin_type                                                        \\\n-\t= new AST::TypePath (::std::move (segs),                               \\\n-\t\t\t     Linemap::predeclared_location (), false);         \\\n-      _R.push_back (builtin_type);                                             \\\n-      tyctx->insert_builtin (_TY->get_ref (), builtin_type->get_node_id (),    \\\n-\t\t\t     _TY);                                             \\\n-      mappings->insert_node_to_hir (builtin_type->get_node_id (),              \\\n-\t\t\t\t    _TY->get_ref ());                          \\\n-      mappings->insert_canonical_path (                                        \\\n-\tbuiltin_type->get_node_id (),                                          \\\n-\tCanonicalPath::new_seg (builtin_type->get_node_id (), _X));            \\\n-    }                                                                          \\\n-  while (0)\n-\n namespace Rust {\n namespace Resolver {\n \n Rib::Rib (CrateNum crateNum, NodeId node_id)\n-  : crate_num (crateNum), node_id (node_id),\n-    mappings (Analysis::Mappings::get ())\n+  : crate_num (crateNum), node_id (node_id)\n {}\n \n void\n Rib::insert_name (\n   const CanonicalPath &path, NodeId id, Location locus, bool shadow,\n+  ItemType type,\n   std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n {\n   auto it = path_mappings.find (path);\n@@ -69,9 +46,10 @@ Rib::insert_name (\n     }\n \n   path_mappings[path] = id;\n-  reverse_path_mappings.insert (std::pair<NodeId, CanonicalPath> (id, path));\n-  decls_within_rib.insert (std::pair<NodeId, Location> (id, locus));\n+  reverse_path_mappings.insert ({id, path});\n+  decls_within_rib.insert ({id, locus});\n   references[id] = {};\n+  decl_type_mappings.insert ({id, type});\n }\n \n bool\n@@ -128,6 +106,17 @@ Rib::decl_was_declared_here (NodeId def) const\n   return false;\n }\n \n+bool\n+Rib::lookup_decl_type (NodeId def, ItemType *type) const\n+{\n+  auto it = decl_type_mappings.find (def);\n+  if (it == decl_type_mappings.end ())\n+    return false;\n+\n+  *type = it->second;\n+  return true;\n+}\n+\n void\n Rib::debug () const\n {\n@@ -151,15 +140,17 @@ Scope::Scope (CrateNum crate_num) : crate_num (crate_num) {}\n void\n Scope::insert (\n   const CanonicalPath &ident, NodeId id, Location locus, bool shadow,\n+  Rib::ItemType type,\n   std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n {\n-  peek ()->insert_name (ident, id, locus, shadow, dup_cb);\n+  peek ()->insert_name (ident, id, locus, shadow, type, dup_cb);\n }\n \n void\n-Scope::insert (const CanonicalPath &ident, NodeId id, Location locus)\n+Scope::insert (const CanonicalPath &ident, NodeId id, Location locus,\n+\t       Rib::ItemType type)\n {\n-  peek ()->insert_name (ident, id, locus, true,\n+  peek ()->insert_name (ident, id, locus, true, type,\n \t\t\t[] (const CanonicalPath &, NodeId, Location) -> void {\n \t\t\t});\n }\n@@ -178,6 +169,39 @@ Scope::lookup (const CanonicalPath &ident, NodeId *id)\n   return lookup != UNKNOWN_NODEID;\n }\n \n+bool\n+Scope::lookup_decl_type (NodeId id, Rib::ItemType *type)\n+{\n+  bool found = false;\n+  iterate ([&] (const Rib *r) -> bool {\n+    if (r->decl_was_declared_here (id))\n+      {\n+\tbool ok = r->lookup_decl_type (id, type);\n+\trust_assert (ok);\n+\tfound = true;\n+\treturn false;\n+      }\n+    return true;\n+  });\n+  return found;\n+}\n+\n+bool\n+Scope::lookup_rib_for_decl (NodeId id, const Rib **rib)\n+{\n+  bool found = false;\n+  iterate ([&] (const Rib *r) -> bool {\n+    if (r->decl_was_declared_here (id))\n+      {\n+\t*rib = r;\n+\tfound = true;\n+\treturn false;\n+      }\n+    return true;\n+  });\n+  return found;\n+}\n+\n void\n Scope::iterate (std::function<bool (Rib *)> cb)\n {\n@@ -344,6 +368,7 @@ Resolver::insert_builtin_types (Rib *r)\n \t\t\t\t  builtin->as_string ());\n       r->insert_name (builtin_path, builtin->get_node_id (),\n \t\t      Linemap::predeclared_location (), false,\n+\t\t      Rib::ItemType::Type,\n \t\t      [] (const CanonicalPath &, NodeId, Location) -> void {});\n     }\n }\n@@ -387,24 +412,24 @@ Resolver::generate_builtins ()\n   auto str = new TyTy::StrType (mappings->get_next_hir_id ());\n   auto never = new TyTy::NeverType (mappings->get_next_hir_id ());\n \n-  MKBUILTIN_TYPE (\"u8\", builtins, u8);\n-  MKBUILTIN_TYPE (\"u16\", builtins, u16);\n-  MKBUILTIN_TYPE (\"u32\", builtins, u32);\n-  MKBUILTIN_TYPE (\"u64\", builtins, u64);\n-  MKBUILTIN_TYPE (\"u128\", builtins, u128);\n-  MKBUILTIN_TYPE (\"i8\", builtins, i8);\n-  MKBUILTIN_TYPE (\"i16\", builtins, i16);\n-  MKBUILTIN_TYPE (\"i32\", builtins, i32);\n-  MKBUILTIN_TYPE (\"i64\", builtins, i64);\n-  MKBUILTIN_TYPE (\"i128\", builtins, i128);\n-  MKBUILTIN_TYPE (\"bool\", builtins, rbool);\n-  MKBUILTIN_TYPE (\"f32\", builtins, f32);\n-  MKBUILTIN_TYPE (\"f64\", builtins, f64);\n-  MKBUILTIN_TYPE (\"usize\", builtins, usize);\n-  MKBUILTIN_TYPE (\"isize\", builtins, isize);\n-  MKBUILTIN_TYPE (\"char\", builtins, char_tyty);\n-  MKBUILTIN_TYPE (\"str\", builtins, str);\n-  MKBUILTIN_TYPE (\"!\", builtins, never);\n+  setup_builtin (\"u8\", u8);\n+  setup_builtin (\"u16\", u16);\n+  setup_builtin (\"u32\", u32);\n+  setup_builtin (\"u64\", u64);\n+  setup_builtin (\"u128\", u128);\n+  setup_builtin (\"i8\", i8);\n+  setup_builtin (\"i16\", i16);\n+  setup_builtin (\"i32\", i32);\n+  setup_builtin (\"i64\", i64);\n+  setup_builtin (\"i128\", i128);\n+  setup_builtin (\"bool\", rbool);\n+  setup_builtin (\"f32\", f32);\n+  setup_builtin (\"f64\", f64);\n+  setup_builtin (\"usize\", usize);\n+  setup_builtin (\"isize\", isize);\n+  setup_builtin (\"char\", char_tyty);\n+  setup_builtin (\"str\", str);\n+  setup_builtin (\"!\", never);\n \n   // unit type ()\n   TyTy::TupleType *unit_tyty\n@@ -418,11 +443,32 @@ Resolver::generate_builtins ()\n   set_unit_type_node_id (unit_type->get_node_id ());\n }\n \n+void\n+Resolver::setup_builtin (const std::string &name, TyTy::BaseType *tyty)\n+{\n+  AST::PathIdentSegment seg (name, Linemap::predeclared_location ());\n+  auto typePath = ::std::unique_ptr<AST::TypePathSegment> (\n+    new AST::TypePathSegment (::std::move (seg), false,\n+\t\t\t      Linemap::predeclared_location ()));\n+  ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;\n+  segs.push_back (::std::move (typePath));\n+  auto builtin_type\n+    = new AST::TypePath (::std::move (segs), Linemap::predeclared_location (),\n+\t\t\t false);\n+  builtins.push_back (builtin_type);\n+  tyctx->insert_builtin (tyty->get_ref (), builtin_type->get_node_id (), tyty);\n+  mappings->insert_node_to_hir (builtin_type->get_node_id (), tyty->get_ref ());\n+  mappings->insert_canonical_path (\n+    builtin_type->get_node_id (),\n+    CanonicalPath::new_seg (builtin_type->get_node_id (), name));\n+}\n+\n void\n Resolver::insert_resolved_name (NodeId refId, NodeId defId)\n {\n   resolved_names[refId] = defId;\n   get_name_scope ().append_reference_for_def (refId, defId);\n+  insert_captured_item (defId);\n }\n \n bool\n@@ -519,5 +565,104 @@ Resolver::lookup_resolved_misc (NodeId refId, NodeId *defId)\n   return true;\n }\n \n+void\n+Resolver::push_closure_context (NodeId closure_expr_id)\n+{\n+  auto it = closures_capture_mappings.find (closure_expr_id);\n+  rust_assert (it == closures_capture_mappings.end ());\n+\n+  closures_capture_mappings.insert ({closure_expr_id, {}});\n+  closure_context.push_back (closure_expr_id);\n+}\n+\n+void\n+Resolver::pop_closure_context ()\n+{\n+  rust_assert (!closure_context.empty ());\n+  closure_context.pop_back ();\n+}\n+\n+void\n+Resolver::insert_captured_item (NodeId id)\n+{\n+  // nothing to do unless we are in a closure context\n+  if (closure_context.empty ())\n+    return;\n+\n+  // check that this is a VAR_DECL?\n+  Scope &name_scope = get_name_scope ();\n+  Rib::ItemType type = Rib::ItemType::Unknown;\n+  bool found = name_scope.lookup_decl_type (id, &type);\n+  if (!found)\n+    return;\n+\n+  // RIB Function { let a, let b } id = 1;\n+  //   RIB Closure { let c } id = 2;\n+  //     RIB IfStmt { <bind a>} id = 3;\n+  //   RIB ... { ... } id = 4\n+  //\n+  // if we have a resolved_node_id of 'a' and the current rib is '3' we know\n+  // this is binding exists in a rib with id < the closure rib id, other wise\n+  // its just a normal binding and we don't care\n+  //\n+  // Problem the node id's dont work like this because the inner most items are\n+  // created first so this means the root will have a larger id and a simple\n+  // less than or greater than check wont work for more complex scoping cases\n+  // but we can use our current rib context to figure this out by checking if\n+  // the rib id the decl we care about exists prior to the rib for the closure\n+  // id\n+\n+  const Rib *r = nullptr;\n+  bool ok = name_scope.lookup_rib_for_decl (id, &r);\n+  rust_assert (ok);\n+  NodeId decl_rib_node_id = r->get_node_id ();\n+\n+  // iterate the closure context and add in the mapping for all to handle the\n+  // case of nested closures\n+  for (auto &closure_expr_id : closure_context)\n+    {\n+      if (!decl_needs_capture (decl_rib_node_id, closure_expr_id, name_scope))\n+\tcontinue;\n+\n+      // is this a valid binding to take\n+      bool is_var_decl_p = type == Rib::ItemType::Var;\n+      if (!is_var_decl_p)\n+\t{\n+\t  // FIXME is this an error case?\n+\t  return;\n+\t}\n+\n+      // append it to the context info\n+      auto it = closures_capture_mappings.find (closure_expr_id);\n+      rust_assert (it != closures_capture_mappings.end ());\n+\n+      it->second.insert (id);\n+    }\n+}\n+\n+bool\n+Resolver::decl_needs_capture (NodeId decl_rib_node_id,\n+\t\t\t      NodeId closure_rib_node_id, const Scope &scope)\n+{\n+  for (const auto &rib : scope.get_context ())\n+    {\n+      bool rib_is_closure = rib->get_node_id () == closure_rib_node_id;\n+      bool rib_is_decl = rib->get_node_id () == decl_rib_node_id;\n+      if (rib_is_closure)\n+\treturn false;\n+      else if (rib_is_decl)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+const std::set<NodeId> &\n+Resolver::get_captures (NodeId id) const\n+{\n+  auto it = closures_capture_mappings.find (id);\n+  rust_assert (it != closures_capture_mappings.end ());\n+  return it->second;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "5bfdeb748ae29bd69bccc860f87bfe79bb41fbec", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -30,13 +30,33 @@ namespace Resolver {\n class Rib\n {\n public:\n-  // Rust uses local_def_ids assigned by def_collector on the AST\n-  // lets use NodeId instead\n+  enum ItemType\n+  {\n+    Var,\n+    Param,\n+    Function,\n+    Type,\n+    Module,\n+    Static,\n+    Const,\n+    Trait,\n+    Impl,\n+    TraitImpl,\n+    ExternCrate,\n+    MacroDecl,\n+    Label,\n+    Unknown\n+  };\n+\n+  // FIXME\n+  // Rust uses local_def_ids assigned by def_collector on the AST. Consider\n+  // moving to a local-def-id\n   Rib (CrateNum crateNum, NodeId node_id);\n \n   // this takes the relative paths of items within a compilation unit for lookup\n   void insert_name (\n     const CanonicalPath &path, NodeId id, Location locus, bool shadow,\n+    ItemType type,\n     std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb);\n \n   bool lookup_canonical_path (const NodeId &id, CanonicalPath *ident);\n@@ -45,6 +65,7 @@ class Rib\n   void append_reference_for_def (NodeId def, NodeId ref);\n   bool have_references_for_node (NodeId def) const;\n   bool decl_was_declared_here (NodeId def) const;\n+  bool lookup_decl_type (NodeId def, ItemType *type) const;\n   void debug () const;\n   std::string debug_str () const;\n \n@@ -59,7 +80,7 @@ class Rib\n   std::map<NodeId, CanonicalPath> reverse_path_mappings;\n   std::map<NodeId, Location> decls_within_rib;\n   std::map<NodeId, std::set<NodeId>> references;\n-  Analysis::Mappings *mappings;\n+  std::map<NodeId, ItemType> decl_type_mappings;\n };\n \n class Scope\n@@ -69,10 +90,14 @@ class Scope\n \n   void\n   insert (const CanonicalPath &ident, NodeId id, Location locus, bool shadow,\n+\t  Rib::ItemType type,\n \t  std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb);\n \n-  void insert (const CanonicalPath &ident, NodeId id, Location locus);\n+  void insert (const CanonicalPath &ident, NodeId id, Location locus,\n+\t       Rib::ItemType type = Rib::ItemType::Unknown);\n   bool lookup (const CanonicalPath &ident, NodeId *id);\n+  bool lookup_decl_type (NodeId id, Rib::ItemType *type);\n+  bool lookup_rib_for_decl (NodeId id, const Rib **rib);\n \n   void iterate (std::function<bool (Rib *)> cb);\n   void iterate (std::function<bool (const Rib *)> cb) const;\n@@ -86,6 +111,8 @@ class Scope\n \n   CrateNum get_crate_num () const { return crate_num; }\n \n+  const std::vector<Rib *> &get_context () const { return stack; };\n+\n private:\n   CrateNum crate_num;\n   std::vector<Rib *> stack;\n@@ -168,10 +195,20 @@ class Resolver\n     return current_module_stack.at (current_module_stack.size () - 2);\n   }\n \n+  void push_closure_context (NodeId closure_expr_id);\n+  void pop_closure_context ();\n+  void insert_captured_item (NodeId id);\n+  const std::set<NodeId> &get_captures (NodeId id) const;\n+\n+protected:\n+  bool decl_needs_capture (NodeId decl_rib_node_id, NodeId closure_rib_node_id,\n+\t\t\t   const Scope &scope);\n+\n private:\n   Resolver ();\n \n   void generate_builtins ();\n+  void setup_builtin (const std::string &name, TyTy::BaseType *tyty);\n \n   Analysis::Mappings *mappings;\n   TypeCheckContext *tyctx;\n@@ -210,6 +247,10 @@ class Resolver\n \n   // keep track of the current module scope ids\n   std::vector<NodeId> current_module_stack;\n+\n+  // captured variables mappings\n+  std::vector<NodeId> closure_context;\n+  std::map<NodeId, std::set<NodeId>> closures_capture_mappings;\n };\n \n } // namespace Resolver"}, {"sha": "7ea1bd900ba6c7e3b16008212a597f70b0a4c302", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -1492,8 +1492,10 @@ TypeCheckExpr::visit (HIR::ClosureExpr &expr)\n \t\t expr.get_locus ());\n \n   // generate the closure type\n+  NodeId closure_node_id = expr.get_mappings ().get_nodeid ();\n+  const std::set<NodeId> &captures = resolver->get_captures (closure_node_id);\n   infered = new TyTy::ClosureType (ref, id, ident, closure_args, result_type,\n-\t\t\t\t   subst_refs);\n+\t\t\t\t   subst_refs, captures);\n \n   // FIXME\n   // all closures automatically inherit the appropriate fn trait. Lets just"}, {"sha": "86f40af0fbe56472964d92e641826ef752e2cb2b", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -1675,8 +1675,7 @@ std::string\n ClosureType::as_string () const\n {\n   std::string params_buf = parameters->as_string ();\n-  return \"|\" + params_buf + \"| {\" + result_type.get_tyty ()->as_string ()\n-\t + \"} {\" + raw_bounds_as_string () + \"}\";\n+  return \"|\" + params_buf + \"| {\" + result_type.get_tyty ()->as_string () + \"}\";\n }\n \n BaseType *\n@@ -1714,7 +1713,7 @@ ClosureType::clone () const\n {\n   return new ClosureType (get_ref (), get_ty_ref (), ident, id,\n \t\t\t  (TyTy::TupleType *) parameters->clone (), result_type,\n-\t\t\t  clone_substs (), get_combined_refs (),\n+\t\t\t  clone_substs (), captures, get_combined_refs (),\n \t\t\t  specified_bounds);\n }\n "}, {"sha": "8b39e5138fb7c29093fc61965a01171409aead0f", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -1628,13 +1628,15 @@ class ClosureType : public BaseType, public SubstitutionRef\n   ClosureType (HirId ref, DefId id, RustIdent ident,\n \t       TyTy::TupleType *parameters, TyVar result_type,\n \t       std::vector<SubstitutionParamMapping> subst_refs,\n+\t       std::set<NodeId> captures,\n \t       std::set<HirId> refs = std::set<HirId> (),\n \t       std::vector<TypeBoundPredicate> specified_bounds\n \t       = std::vector<TypeBoundPredicate> ())\n     : BaseType (ref, ref, TypeKind::CLOSURE, ident, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n-      parameters (parameters), result_type (std::move (result_type)), id (id)\n+      parameters (parameters), result_type (std::move (result_type)), id (id),\n+      captures (captures)\n   {\n     LocalDefId local_def_id = id.localDefId;\n     rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n@@ -1644,13 +1646,15 @@ class ClosureType : public BaseType, public SubstitutionRef\n   ClosureType (HirId ref, HirId ty_ref, RustIdent ident, DefId id,\n \t       TyTy::TupleType *parameters, TyVar result_type,\n \t       std::vector<SubstitutionParamMapping> subst_refs,\n+\t       std::set<NodeId> captures,\n \t       std::set<HirId> refs = std::set<HirId> (),\n \t       std::vector<TypeBoundPredicate> specified_bounds\n \t       = std::vector<TypeBoundPredicate> ())\n     : BaseType (ref, ty_ref, TypeKind::CLOSURE, ident, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n-      parameters (parameters), result_type (std::move (result_type)), id (id)\n+      parameters (parameters), result_type (std::move (result_type)), id (id),\n+      captures (captures)\n   {\n     LocalDefId local_def_id = id.localDefId;\n     rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n@@ -1699,10 +1703,13 @@ class ClosureType : public BaseType, public SubstitutionRef\n \n   void setup_fn_once_output () const;\n \n+  const std::set<NodeId> &get_captures () const { return captures; }\n+\n private:\n   TyTy::TupleType *parameters;\n   TyVar result_type;\n   DefId id;\n+  std::set<NodeId> captures;\n };\n \n class ArrayType : public BaseType"}, {"sha": "62cf3a082cff181339e6e5f3d0bdff371e89a728", "filename": "gcc/testsuite/rust/execute/torture/closure3.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e39fadcd0aa4d52d53667e2adad9a6677f7e9adf/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure3.rs?ref=e39fadcd0aa4d52d53667e2adad9a6677f7e9adf", "patch": "@@ -0,0 +1,33 @@\n+// { dg-output \"3\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"fn_once\"]\n+pub trait FnOnce<Args> {\n+    #[lang = \"fn_once_output\"]\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+fn f<F: FnOnce(i32) -> i32>(g: F) {\n+    let call = g(1);\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, call);\n+    }\n+}\n+\n+pub fn main() -> i32 {\n+    let capture = 2;\n+    let a = |i: i32| {\n+        let b = i + capture;\n+        b\n+    };\n+    f(a);\n+    0\n+}"}]}