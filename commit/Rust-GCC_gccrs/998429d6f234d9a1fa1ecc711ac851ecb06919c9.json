{"sha": "998429d6f234d9a1fa1ecc711ac851ecb06919c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk4NDI5ZDZmMjM0ZDlhMWZhMWVjYzcxMWFjODUxZWNiMDY5MTljOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T09:14:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T09:14:07Z"}, "message": "[multiple changes]\n\n2017-04-25  Bob Duff  <duff@adacore.com>\n\n\t* uname.ads, uname.adb (Is_Predefined_Unit_Name,\n\tIs_Internal_Unit_Name): New functions for operating on unit\n\tnames, as opposed to file names. There's some duplicated code\n\twith fname.adb, which is unfortunate, but it seems like we don't\n\twant to add dependencies here.\n\t* fname-uf.adb (Get_File_Name): Change Is_Predefined_File_Name\n\tto Is_Predefined_Unit_Name; the former was wrong, because Uname\n\tis not a file name at all.\n\t* fname.ads, fname.adb: Document the fact that\n\tIs_Predefined_File_Name and Is_Internal_File_Name can be called\n\tfor ALI files, and fix the code so it works properly for ALI\n\tfiles. E.g. these should return True for \"system.ali\".\n\n2017-04-25  Justin Squirek  <squirek@adacore.com>\n\n\t* exp_util.adb (Add_Invariant): Removed,\n\tcode moved to Add_Invariant_Check, Add_Inherited_Invariant,\n\tand Add_Own_Invariant.\t(Add_Invariant_Check): Used\n\tfor adding runtime checks from any kind of invariant.\n\t(Add_Inherited_Invariant): Generates invariant checks for\n\tclass-wide invariants (Add_Interface_Invariants): Removed, code\n\tmoved to Build_Invariant_Procedure_Body (Add_Own_Invariant):\n\tCreate a types own invariant procedure (Add_Parent_Invariants):\n\tRemoved, code moved to Build_Invariant_Procedure_Body\n\t(Build_Invariant_Procedure_Body): Add refactored calls\n\tand integrated code from Add_Parent_Invariants and\n\tAdd_Interface_Invariants.\n\t(Process_Type): Removed, the\n\trelavant code was inlined into both Add_Own_Invariant and\n\tAdd_Inherited_Invariant.\n\nFrom-SVN: r247154", "tree": {"sha": "62f7b1b744fab8ae9363d2319cf7df1eaadf7f6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62f7b1b744fab8ae9363d2319cf7df1eaadf7f6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/998429d6f234d9a1fa1ecc711ac851ecb06919c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/998429d6f234d9a1fa1ecc711ac851ecb06919c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/998429d6f234d9a1fa1ecc711ac851ecb06919c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/998429d6f234d9a1fa1ecc711ac851ecb06919c9/comments", "author": null, "committer": null, "parents": [{"sha": "94d3a18d33399c807647294c973f263096fae095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94d3a18d33399c807647294c973f263096fae095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94d3a18d33399c807647294c973f263096fae095"}], "stats": {"total": 969, "additions": 552, "deletions": 417}, "files": [{"sha": "bd33c416f69c561c90a5ad81dac8db4ff885bbf2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=998429d6f234d9a1fa1ecc711ac851ecb06919c9", "patch": "@@ -1,3 +1,36 @@\n+2017-04-25  Bob Duff  <duff@adacore.com>\n+\n+\t* uname.ads, uname.adb (Is_Predefined_Unit_Name,\n+\tIs_Internal_Unit_Name): New functions for operating on unit\n+\tnames, as opposed to file names. There's some duplicated code\n+\twith fname.adb, which is unfortunate, but it seems like we don't\n+\twant to add dependencies here.\n+\t* fname-uf.adb (Get_File_Name): Change Is_Predefined_File_Name\n+\tto Is_Predefined_Unit_Name; the former was wrong, because Uname\n+\tis not a file name at all.\n+\t* fname.ads, fname.adb: Document the fact that\n+\tIs_Predefined_File_Name and Is_Internal_File_Name can be called\n+\tfor ALI files, and fix the code so it works properly for ALI\n+\tfiles. E.g. these should return True for \"system.ali\".\n+\n+2017-04-25  Justin Squirek  <squirek@adacore.com>\n+\n+\t* exp_util.adb (Add_Invariant): Removed,\n+\tcode moved to Add_Invariant_Check, Add_Inherited_Invariant,\n+\tand Add_Own_Invariant.\t(Add_Invariant_Check): Used\n+\tfor adding runtime checks from any kind of invariant.\n+\t(Add_Inherited_Invariant): Generates invariant checks for\n+\tclass-wide invariants (Add_Interface_Invariants): Removed, code\n+\tmoved to Build_Invariant_Procedure_Body (Add_Own_Invariant):\n+\tCreate a types own invariant procedure (Add_Parent_Invariants):\n+\tRemoved, code moved to Build_Invariant_Procedure_Body\n+\t(Build_Invariant_Procedure_Body): Add refactored calls\n+\tand integrated code from Add_Parent_Invariants and\n+\tAdd_Interface_Invariants.\n+\t(Process_Type): Removed, the\n+\trelavant code was inlined into both Add_Own_Invariant and\n+\tAdd_Inherited_Invariant.\n+\n 2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* make.adb, par-ch2.adb, sem_util.adb, scans.ads, sem_ch8.adb,"}, {"sha": "4bfd8b9e5ab3d2ae2cb4cac9f7af94a015169934", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 398, "deletions": 397, "changes": 795, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=998429d6f234d9a1fa1ecc711ac851ecb06919c9", "patch": "@@ -1987,16 +1987,17 @@ package body Exp_Util is\n       --  Obj_Id denotes the entity of the _object formal parameter of the\n       --  invariant procedure. All created checks are added to list Checks.\n \n-      procedure Add_Interface_Invariants\n-        (T      : Entity_Id;\n-         Obj_Id : Entity_Id;\n-         Checks : in out List_Id);\n-      --  Generate an invariant check for each inherited class-wide invariant\n-      --  coming from all interfaces implemented by type T. Obj_Id denotes the\n-      --  entity of the _object formal parameter of the invariant procedure.\n-      --  All created checks are added to list Checks.\n+      procedure Add_Invariant_Check\n+        (Prag      : Node_Id;\n+         Expr      : Node_Id;\n+         Checks    : in out List_Id;\n+         Inherited : Boolean := False);\n+      --  Subsidiary to all Add_xxx_Invariant routines. Add a runtime check to\n+      --  verify assertion expression Expr of pragma Prag. All generated code\n+      --  is added to list Checks. Flag Inherited should be set when the pragma\n+      --  is inherited from a parent or interface type.\n \n-      procedure Add_Parent_Invariants\n+      procedure Add_Inherited_Invariant\n         (T      : Entity_Id;\n          Obj_Id : Entity_Id;\n          Checks : in out List_Id);\n@@ -2005,6 +2006,16 @@ package body Exp_Util is\n       --  the _object formal parameter of the invariant procedure. All created\n       --  checks are added to list Checks.\n \n+      procedure Add_Own_Invariant\n+        (T         : Entity_Id;\n+         Obj_Id    : Entity_Id;\n+         Checks    : in out List_Id;\n+         Priv_Item : Node_Id := Empty);\n+      --  Generate an invariant check for each invariant found for type T.\n+      --  Obj_Id denotes the entity of the _object formal parameter of the\n+      --  invariant procedure. All created checks are added to list Checks.\n+      --  Priv_Item denotes the first rep item of the private type.\n+\n       procedure Add_Record_Component_Invariants\n         (T      : Entity_Id;\n          Obj_Id : Entity_Id;\n@@ -2013,27 +2024,6 @@ package body Exp_Util is\n       --  Obj_Id denotes the entity of the _object formal parameter of the\n       --  invariant procedure. All created checks are added to list Checks.\n \n-      procedure Add_Type_Invariants\n-        (Priv_Typ  : Entity_Id;\n-         Full_Typ  : Entity_Id;\n-         CRec_Typ  : Entity_Id;\n-         Obj_Id    : Entity_Id;\n-         Checks    : in out List_Id;\n-         Inherit   : Boolean := False;\n-         Priv_Item : Node_Id := Empty);\n-      --  Generate an invariant check for each invariant found in one of the\n-      --  following types (if available):\n-      --\n-      --    Priv_Typ - the partial view of a type\n-      --    Full_Typ - the full view of a type\n-      --    CRec_Typ - the corresponding record of a protected or a task type\n-      --\n-      --  Obj_Id denotes the entity of the _object formal parameter of the\n-      --  invariant procedure. All created checks are added to list Checks.\n-      --  Flag Inherit should be set when generating invariant checks for\n-      --  inherited class-wide invariants. Priv_Item denotes the first rep\n-      --  item of the private type.\n-\n       ------------------------------------\n       -- Add_Array_Component_Invariants --\n       ------------------------------------\n@@ -2176,7 +2166,7 @@ package body Exp_Util is\n                                   Expressions    => New_List (\n                                     Make_Integer_Literal (Loc, Dim))))),\n \n-                      Statements => Comp_Checks));\n+                      Statements       => Comp_Checks));\n                end if;\n             end if;\n          end Process_One_Dimension;\n@@ -2190,102 +2180,309 @@ package body Exp_Util is\n             Dim_Checks => Checks);\n       end Add_Array_Component_Invariants;\n \n-      ------------------------------\n-      -- Add_Interface_Invariants --\n-      ------------------------------\n+      -----------------------------\n+      -- Add_Inherited_Invariant --\n+      -----------------------------\n \n-      procedure Add_Interface_Invariants\n+      procedure Add_Inherited_Invariant\n         (T      : Entity_Id;\n          Obj_Id : Entity_Id;\n          Checks : in out List_Id)\n       is\n-         Iface_Elmt : Elmt_Id;\n-         Ifaces     : Elist_Id;\n+         Arg1 : Node_Id;\n+         Arg2 : Node_Id;\n+         Expr : Node_Id;\n+         Prag : Node_Id;\n+\n+         Rep_Typ : Entity_Id;\n+         --  The replacement type used in the substitution of the current\n+         --  instance of a type with the _object formal parameter\n \n       begin\n-         if Is_Tagged_Type (T) then\n-            Collect_Interfaces (T, Ifaces);\n+         if not Present (T) then\n+            return;\n+         end if;\n \n-            --  Process the class-wide invariants of all implemented interfaces\n+         Prag := First_Rep_Item (T);\n+         while Present (Prag) loop\n+            if Nkind (Prag) = N_Pragma\n+              and then Pragma_Name (Prag) = Name_Invariant\n+            then\n+               --  Nothing to do if the pragma was already processed\n \n-            Iface_Elmt := First_Elmt (Ifaces);\n-            while Present (Iface_Elmt) loop\n-               Add_Type_Invariants\n-                 (Priv_Typ => Empty,\n-                  Full_Typ => Node (Iface_Elmt),\n-                  CRec_Typ => Empty,\n-                  Obj_Id   => Obj_Id,\n-                  Checks   => Checks,\n-                  Inherit  => True);\n+               if Contains (Pragmas_Seen, Prag) then\n+                  return;\n+               end if;\n \n-               Next_Elmt (Iface_Elmt);\n-            end loop;\n-         end if;\n-      end Add_Interface_Invariants;\n+               --  Extract the arguments of the invariant pragma\n \n-      ---------------------------\n-      -- Add_Parent_Invariants --\n-      ---------------------------\n+               Arg1 := First (Pragma_Argument_Associations (Prag));\n+               Arg2 := Next (Arg1);\n \n-      procedure Add_Parent_Invariants\n-        (T      : Entity_Id;\n-         Obj_Id : Entity_Id;\n-         Checks : in out List_Id)\n-      is\n-         Dummy_1 : Entity_Id;\n-         Dummy_2 : Entity_Id;\n+               Arg1 := Get_Pragma_Arg (Arg1);\n+               Arg2 := Get_Pragma_Arg (Arg2);\n \n-         Curr_Typ : Entity_Id;\n-         --  The entity of the current type being examined\n+               --  Otherwise the pragma applies to a parent type in which case\n+               --  it will be processed at a later stage by\n+               --  Add_Parent_Invariants or Add_Interface_Invariants.\n \n-         Full_Typ : Entity_Id;\n-         --  The full view of Par_Typ\n+               if Entity (Arg1) = T then\n+                  Rep_Typ := Entity (Arg1);\n \n-         Par_Typ : Entity_Id;\n-         --  The entity of the parent type\n+               elsif Present (Full_View (T))\n+                 and then Entity (Arg1) = Full_View (T)\n+               then\n+                  Rep_Typ := Full_View (T);\n \n-         Priv_Typ : Entity_Id;\n-         --  The partial view of Par_Typ\n+               else\n+                  return;\n+               end if;\n+\n+               --  Nothing to do when the caller requests the processing of\n+               --  all inherited class-wide invariants, but the pragma does\n+               --  not fall in this category.\n+\n+               if not Class_Present (Prag) then\n+                  return;\n+               end if;\n+\n+               Expr := New_Copy_Tree (Arg2);\n+\n+               --  Substitute all references to type T with references to the\n+               --  _object formal parameter.\n+\n+               --  ??? Dispatching must be removed due to AI12-0150-1\n+\n+               Replace_Type_References\n+                 (Expr, Rep_Typ, Obj_Id, Dispatch => Class_Present (Prag));\n+\n+               Add_Invariant_Check (Prag, Expr, Checks, Inherited => True);\n+            end if;\n+\n+            Next_Rep_Item (Prag);\n+         end loop;\n+      end Add_Inherited_Invariant;\n+\n+      -------------------------\n+      -- Add_Invariant_Check --\n+      -------------------------\n+\n+      procedure Add_Invariant_Check\n+        (Prag      : Node_Id;\n+         Expr      : Node_Id;\n+         Checks    : in out List_Id;\n+         Inherited : Boolean := False)\n+      is\n+         Args    : constant List_Id    := Pragma_Argument_Associations (Prag);\n+         Nam     : constant Name_Id    := Original_Aspect_Pragma_Name (Prag);\n+         Ploc    : constant Source_Ptr := Sloc (Prag);\n+         Str_Arg : constant Node_Id    := Next (Next (First (Args)));\n+\n+         Assoc : List_Id;\n+         Str   : String_Id;\n \n       begin\n-         --  Do not process array types because they cannot have true parent\n-         --  types. This also prevents the generation of a duplicate invariant\n-         --  check when the input type is an array base type because its Etype\n-         --  denotes the first subtype, both of which share the same component\n-         --  type.\n+         --  The invariant is ignored, nothing left to do\n+\n+         if Is_Ignored (Prag) then\n+            null;\n+\n+         --  Otherwise the invariant is checked. Build a Check pragma to verify\n+         --  the expression at runtime.\n \n-         if Is_Array_Type (T) then\n+         else\n+            Assoc := New_List (\n+              Make_Pragma_Argument_Association (Ploc,\n+                Expression => Make_Identifier (Ploc, Nam)),\n+              Make_Pragma_Argument_Association (Ploc,\n+                Expression => Expr));\n+\n+            --  Handle the String argument (if any)\n+\n+            if Present (Str_Arg) then\n+               Str := Strval (Get_Pragma_Arg (Str_Arg));\n+\n+               --  When inheriting an invariant, modify the message from\n+               --  \"failed invariant\" to \"failed inherited invariant\".\n+\n+               if Inherited then\n+                  String_To_Name_Buffer (Str);\n+\n+                  if Name_Buffer (1 .. 16) = \"failed invariant\" then\n+                     Insert_Str_In_Name_Buffer (\"inherited \", 8);\n+                     Str := String_From_Name_Buffer;\n+                  end if;\n+               end if;\n+\n+               Append_To (Assoc,\n+                 Make_Pragma_Argument_Association (Ploc,\n+                   Expression => Make_String_Literal (Ploc, Str)));\n+            end if;\n+\n+            --  Generate:\n+            --    pragma Check (<Nam>, <Expr>, <Str>);\n+\n+            Append_New_To (Checks,\n+              Make_Pragma (Ploc,\n+                Chars                        => Name_Check,\n+                Pragma_Argument_Associations => Assoc));\n+         end if;\n+\n+         --  Output an info message when inheriting an invariant and the\n+         --  listing option is enabled.\n+\n+         if Inherited and Opt.List_Inherited_Aspects then\n+            Error_Msg_Sloc := Sloc (Prag);\n+            Error_Msg_N\n+              (\"info: & inherits `Invariant''Class` aspect from #?L?\", Typ);\n+         end if;\n+\n+         --  Add the pragma to the list of processed pragmas\n+\n+         Append_New_Elmt (Prag, Pragmas_Seen);\n+         Produced_Check := True;\n+      end Add_Invariant_Check;\n+\n+      -----------------------\n+      -- Add_Own_Invariant --\n+      -----------------------\n+\n+      procedure Add_Own_Invariant\n+        (T         : Entity_Id;\n+         Obj_Id    : Entity_Id;\n+         Checks    : in out List_Id;\n+         Priv_Item : Node_Id := Empty)\n+      is\n+         Arg1      : Node_Id;\n+         Arg2      : Node_Id;\n+         ASIS_Expr : Node_Id;\n+         Asp       : Node_Id;\n+         Expr      : Node_Id;\n+         Ploc      : Source_Ptr;\n+         Prag      : Node_Id;\n+\n+      begin\n+         if not Present (T) then\n             return;\n          end if;\n \n-         --  Climb the parent type chain\n+         Prag := First_Rep_Item (T);\n+         while Present (Prag) loop\n+            if Nkind (Prag) = N_Pragma\n+              and then Pragma_Name (Prag) = Name_Invariant\n+            then\n+               --  Stop the traversal of the rep item chain once a specific\n+               --  item is encountered.\n \n-         Curr_Typ := T;\n-         loop\n-            --  Do not consider subtypes as they inherit the invariants from\n-            --  their base types.\n+               if Present (Priv_Item) and then Prag = Priv_Item then\n+                  exit;\n+               end if;\n \n-            Par_Typ := Base_Type (Etype (Curr_Typ));\n+               --  Nothing to do if the pragma was already processed\n \n-            --  Stop the climb once the root of the parent chain is reached\n+               if Contains (Pragmas_Seen, Prag) then\n+                  return;\n+               end if;\n \n-            exit when Curr_Typ = Par_Typ;\n+               --  Extract the arguments of the invariant pragma\n \n-            --  Process the class-wide invariants of the parent type\n+               Arg1 := First (Pragma_Argument_Associations (Prag));\n+               Arg2 := Next (Arg1);\n \n-            Get_Views (Par_Typ, Priv_Typ, Full_Typ, Dummy_1, Dummy_2);\n+               Arg1 := Get_Pragma_Arg (Arg1);\n+               Arg2 := Get_Pragma_Arg (Arg2);\n \n-            Add_Type_Invariants\n-              (Priv_Typ => Priv_Typ,\n-               Full_Typ => Full_Typ,\n-               CRec_Typ => Empty,\n-               Obj_Id   => Obj_Id,\n-               Checks   => Checks,\n-               Inherit  => True);\n+               Asp  := Corresponding_Aspect (Prag);\n+               Ploc := Sloc (Prag);\n \n-            Curr_Typ := Par_Typ;\n+               --  Otherwise the pragma applies to a parent type in which case\n+               --  it will be processed at a later stage by\n+               --  Add_Parent_Invariants or Add_Interface_Invariants.\n+\n+               if Entity (Arg1) /= T then\n+                  return;\n+               end if;\n+\n+               Expr := New_Copy_Tree (Arg2);\n+\n+               --  Substitute all references to type T with references to\n+               --  the _object formal parameter.\n+\n+               Replace_Type_References\n+                 (Expr     => Expr,\n+                  Typ      => T,\n+                  Obj_Id   => Obj_Id,\n+                  Dispatch => Class_Present (Prag));\n+\n+               --  Preanalyze the invariant expression to detect errors and at\n+               --  the same time capture the visibility of the proper package\n+               --  part.\n+\n+               --  Historical note: the old implementation of invariants used\n+               --  node N as the parent, but a package specification as parent\n+               --  of an expression is bizarre.\n+\n+               Set_Parent (Expr, Parent (Arg2));\n+               Preanalyze_Assert_Expression (Expr, Any_Boolean);\n+\n+               --  If the pragma comes from an aspect specification, replace\n+               --  the saved expression because all type references must be\n+               --  substituted for the call to Preanalyze_Spec_Expression in\n+               --  Check_Aspect_At_xxx routines.\n+\n+               if Present (Asp) then\n+                  Set_Entity (Identifier (Asp), New_Copy_Tree (Expr));\n+               end if;\n+\n+               --  Analyze the original invariant expression for ASIS\n+\n+               if ASIS_Mode then\n+                  ASIS_Expr := Empty;\n+\n+                  if Comes_From_Source (Prag) then\n+                     ASIS_Expr := Arg2;\n+                  elsif Present (Asp) then\n+                     ASIS_Expr := Expression (Asp);\n+                  end if;\n+\n+                  if Present (ASIS_Expr) then\n+                     Replace_Type_References\n+                       (Expr     => ASIS_Expr,\n+                        Typ      => T,\n+                        Obj_Id   => Obj_Id,\n+                        Dispatch => Class_Present (Prag));\n+\n+                     Preanalyze_Assert_Expression (ASIS_Expr, Any_Boolean);\n+                  end if;\n+               end if;\n+\n+               --  A class-wide invariant may be inherited in a separate unit,\n+               --  where the corresponding expression cannot be resolved by\n+               --  visibility, because it refers to a local function. Propagate\n+               --  semantic information to the original representation item, to\n+               --  be used when an invariant procedure for a derived type is\n+               --  constructed.\n+\n+               --  ??? Unclear how to handle class-wide invariants that are not\n+               --  function calls.\n+\n+               if Class_Present (Prag)\n+                 and then Nkind (Expr) = N_Function_Call\n+                 and then Nkind (Arg2) = N_Indexed_Component\n+               then\n+                  Rewrite (Arg2,\n+                    Make_Function_Call (Ploc,\n+                      Name                   =>\n+                        New_Occurrence_Of (Entity (Name (Expr)), Ploc),\n+                      Parameter_Associations => Expressions (Arg2)));\n+               end if;\n+\n+               Add_Invariant_Check (Prag, Expr, Checks);\n+            end if;\n+\n+            Next_Rep_Item (Prag);\n          end loop;\n-      end Add_Parent_Invariants;\n+      end Add_Own_Invariant;\n \n       -------------------------------------\n       -- Add_Record_Component_Invariants --\n@@ -2513,294 +2710,12 @@ package body Exp_Util is\n          end if;\n       end Add_Record_Component_Invariants;\n \n-      -------------------------\n-      -- Add_Type_Invariants --\n-      -------------------------\n-\n-      procedure Add_Type_Invariants\n-        (Priv_Typ  : Entity_Id;\n-         Full_Typ  : Entity_Id;\n-         CRec_Typ  : Entity_Id;\n-         Obj_Id    : Entity_Id;\n-         Checks    : in out List_Id;\n-         Inherit   : Boolean := False;\n-         Priv_Item : Node_Id := Empty)\n-      is\n-         procedure Add_Invariant (Prag : Node_Id);\n-         --  Create a runtime check to verify the invariant exression of pragma\n-         --  Prag. All generated code is added to list Checks.\n-\n-         procedure Process_Type (T : Entity_Id; Stop_Item : Node_Id := Empty);\n-         --  Generate invariant checks for type T by inspecting the rep item\n-         --  chain of the type. Stop_Item denotes a rep item which once seen\n-         --  will stop the inspection.\n-\n-         -------------------\n-         -- Add_Invariant --\n-         -------------------\n-\n-         procedure Add_Invariant (Prag : Node_Id) is\n-            Asp  : constant Node_Id    := Corresponding_Aspect (Prag);\n-            Nam  : constant Name_Id    := Original_Aspect_Pragma_Name (Prag);\n-            Ploc : constant Source_Ptr := Sloc (Prag);\n-\n-            Arg1      : Node_Id;\n-            Arg2      : Node_Id;\n-            Arg3      : Node_Id;\n-            ASIS_Expr : Node_Id;\n-            Assoc     : List_Id;\n-            Expr      : Node_Id;\n-            Str       : String_Id;\n-\n-            Rep_Typ : Entity_Id;\n-            --  The replacement type used in the substitution of the current\n-            --  instance of a type with the _object formal parameter.\n-\n-         begin\n-            --  Nothing to do if the pragma was already processed\n-\n-            if Contains (Pragmas_Seen, Prag) then\n-               return;\n-            end if;\n-\n-            --  Extract the arguments of the invariant pragma\n-\n-            Arg1 := First (Pragma_Argument_Associations (Prag));\n-            Arg2 := Next (Arg1);\n-            Arg3 := Next (Arg2);\n-\n-            Arg1 := Get_Pragma_Arg (Arg1);\n-            Arg2 := Get_Pragma_Arg (Arg2);\n-\n-            --  The pragma applies to the partial view\n-\n-            if Present (Priv_Typ) and then Entity (Arg1) = Priv_Typ then\n-               Rep_Typ := Priv_Typ;\n-\n-            --  The pragma applies to the full view\n-\n-            elsif Present (Full_Typ) and then Entity (Arg1) = Full_Typ then\n-               Rep_Typ := Full_Typ;\n-\n-            --  Otherwise the pragma applies to a parent type in which case it\n-            --  will be processed at a later stage by Add_Parent_Invariants or\n-            --  Add_Interface_Invariants.\n-\n-            else\n-               return;\n-            end if;\n-\n-            --  Nothing to do when the caller requests the processing of all\n-            --  inherited class-wide invariants, but the pragma does not fall\n-            --  in this category.\n-\n-            if Inherit and then not Class_Present (Prag) then\n-               return;\n-            end if;\n-\n-            Expr := New_Copy_Tree (Arg2);\n-\n-            --  Substitute all references to type Rep_Typ with references to\n-            --  the _object formal parameter. Dispatching here must be removed\n-            --  due to AI12-0150-1 !!!\n-\n-            Replace_Type_References\n-              (Expr, Rep_Typ, Obj_Id, Dispatch => Class_Present (Prag));\n-\n-            --  Additional processing for non-class-wide invariants\n-\n-            if not Inherit then\n-\n-               --  Preanalyze the invariant expression to detect errors and at\n-               --  the same time capture the visibility of the proper package\n-               --  part.\n-\n-               --  Historical note: the old implementation of invariants used\n-               --  node N as the parent, but a package specification as parent\n-               --  of an expression is bizarre.\n-\n-               Set_Parent (Expr, Parent (Arg2));\n-               Preanalyze_Assert_Expression (Expr, Any_Boolean);\n-\n-               --  If the pragma comes from an aspect specification, replace\n-               --  the saved expression because all type references must be\n-               --  substituted for the call to Preanalyze_Spec_Expression in\n-               --  Check_Aspect_At_xxx routines.\n-\n-               if Present (Asp) then\n-                  Set_Entity (Identifier (Asp), New_Copy_Tree (Expr));\n-               end if;\n-\n-               --  Analyze the original invariant expression for ASIS\n-\n-               if ASIS_Mode then\n-                  ASIS_Expr := Empty;\n-\n-                  if Comes_From_Source (Prag) then\n-                     ASIS_Expr := Arg2;\n-                  elsif Present (Asp) then\n-                     ASIS_Expr := Expression (Asp);\n-                  end if;\n-\n-                  if Present (ASIS_Expr) then\n-                     Replace_Type_References\n-                       (ASIS_Expr, Rep_Typ, Obj_Id, Class_Present (Prag));\n-                     Preanalyze_Assert_Expression (ASIS_Expr, Any_Boolean);\n-                  end if;\n-               end if;\n-\n-               --  A class-wide invariant may be inherited in a separate unit,\n-               --  where the corresponding expression cannot be resolved by\n-               --  visibility, because it refers to a local function. Propagate\n-               --  semantic information to the original representation item, to\n-               --  be used when an invariant procedure for a derived type is\n-               --  constructed.\n-\n-               --  ??? Unclear how to handle class-wide invariants that are not\n-               --  function calls.\n-\n-               if Class_Present (Prag)\n-                 and then Nkind (Expr) = N_Function_Call\n-                 and then Nkind (Arg2) = N_Indexed_Component\n-               then\n-                  Rewrite (Arg2,\n-                    Make_Function_Call (Ploc,\n-                      Name                   =>\n-                        New_Occurrence_Of (Entity (Name (Expr)), Ploc),\n-                      Parameter_Associations => Expressions (Arg2)));\n-               end if;\n-            end if;\n-\n-            --  The invariant is ignored, nothing left to do\n-\n-            if Is_Ignored (Prag) then\n-               null;\n-\n-            --  Otherwise the invariant is checked. Build a Check pragma to\n-            --  verify the expression at runtime.\n-\n-            else\n-               Assoc := New_List (\n-                 Make_Pragma_Argument_Association (Ploc,\n-                   Expression => Make_Identifier (Ploc, Nam)),\n-                 Make_Pragma_Argument_Association (Ploc,\n-                   Expression => Expr));\n-\n-               --  Handle the String argument (if any)\n-\n-               if Present (Arg3) then\n-                  Str := Strval (Get_Pragma_Arg (Arg3));\n-\n-                  --  When inheriting an invariant, modify the message from\n-                  --  \"failed invariant\" to \"failed inherited invariant\".\n-\n-                  if Inherit then\n-                     String_To_Name_Buffer (Str);\n-\n-                     if Name_Buffer (1 .. 16) = \"failed invariant\" then\n-                        Insert_Str_In_Name_Buffer (\"inherited \", 8);\n-                        Str := String_From_Name_Buffer;\n-                     end if;\n-                  end if;\n-\n-                  Append_To (Assoc,\n-                    Make_Pragma_Argument_Association (Ploc,\n-                      Expression => Make_String_Literal (Ploc, Str)));\n-               end if;\n-\n-               --  Generate:\n-               --    pragma Check (<Nam>, <Expr>, <Str>);\n-\n-               Append_New_To (Checks,\n-                 Make_Pragma (Ploc,\n-                   Chars                        => Name_Check,\n-                   Pragma_Argument_Associations => Assoc));\n-            end if;\n-\n-            --  Output an info message when inheriting an invariant and the\n-            --  listing option is enabled.\n-\n-            if Inherit and Opt.List_Inherited_Aspects then\n-               Error_Msg_Sloc := Sloc (Prag);\n-               Error_Msg_N\n-                 (\"info: & inherits `Invariant''Class` aspect from #?L?\", Typ);\n-            end if;\n-\n-            --  Add the pragma to the list of processed pragmas\n-\n-            Append_New_Elmt (Prag, Pragmas_Seen);\n-            Produced_Check := True;\n-         end Add_Invariant;\n-\n-         ------------------\n-         -- Process_Type --\n-         ------------------\n-\n-         procedure Process_Type\n-           (T         : Entity_Id;\n-            Stop_Item : Node_Id := Empty)\n-         is\n-            Rep_Item : Node_Id;\n-\n-         begin\n-            Rep_Item := First_Rep_Item (T);\n-            while Present (Rep_Item) loop\n-               if Nkind (Rep_Item) = N_Pragma\n-                 and then Pragma_Name (Rep_Item) = Name_Invariant\n-               then\n-                  --  Stop the traversal of the rep item chain once a specific\n-                  --  item is encountered.\n-\n-                  if Present (Stop_Item) and then Rep_Item = Stop_Item then\n-                     exit;\n-\n-                  --  Otherwise generate an invariant check\n-\n-                  else\n-                     Add_Invariant (Rep_Item);\n-                  end if;\n-               end if;\n-\n-               Next_Rep_Item (Rep_Item);\n-            end loop;\n-         end Process_Type;\n-\n-      --  Start of processing for Add_Type_Invariants\n-\n-      begin\n-         --  Process the invariants of the partial view\n-\n-         if Present (Priv_Typ) then\n-            Process_Type (Priv_Typ);\n-         end if;\n-\n-         --  Process the invariants of the full view\n-\n-         if Present (Full_Typ) then\n-            Process_Type (Full_Typ, Stop_Item => Priv_Item);\n-\n-            --  Process the elements of an array type\n-\n-            if Is_Array_Type (Full_Typ) then\n-               Add_Array_Component_Invariants (Full_Typ, Obj_Id, Checks);\n-\n-            --  Process the components of a record type\n-\n-            elsif Ekind (Full_Typ) = E_Record_Type then\n-               Add_Record_Component_Invariants (Full_Typ, Obj_Id, Checks);\n-            end if;\n-         end if;\n-\n-         --  Process the components of a corresponding record type\n-\n-         if Present (CRec_Typ) then\n-            Add_Record_Component_Invariants (CRec_Typ, Obj_Id, Checks);\n-         end if;\n-      end Add_Type_Invariants;\n-\n       --  Local variables\n \n-      Dummy        : Entity_Id;\n+      Dummy_1      : Entity_Id;\n+      Dummy_2      : Entity_Id;\n+      Iface_Elmt   : Elmt_Id;\n+      Ifaces       : Elist_Id;\n       Mode         : Ghost_Mode_Type;\n       Priv_Item    : Node_Id;\n       Proc_Body    : Node_Id;\n@@ -2872,7 +2787,7 @@ package body Exp_Util is\n \n       --  Obtain both views of the type\n \n-      Get_Views (Work_Typ, Priv_Typ, Full_Typ, Dummy, CRec_Typ);\n+      Get_Views (Work_Typ, Priv_Typ, Full_Typ, Dummy_1, CRec_Typ);\n \n       --  The caller requests a body for the partial invariant procedure\n \n@@ -2953,12 +2868,10 @@ package body Exp_Util is\n       if Partial_Invariant then\n          pragma Assert (Present (Priv_Typ));\n \n-         Add_Type_Invariants\n-           (Priv_Typ => Priv_Typ,\n-            Full_Typ => Empty,\n-            CRec_Typ => Empty,\n-            Obj_Id   => Obj_Id,\n-            Checks   => Stmts);\n+         Add_Own_Invariant\n+           (T      => Priv_Typ,\n+            Obj_Id => Obj_Id,\n+            Checks => Stmts);\n \n       --  Otherwise the \"full\" invariant procedure verifies the invariants of\n       --  the full view, all array or record components, as well as class-wide\n@@ -3032,27 +2945,115 @@ package body Exp_Util is\n             end if;\n          end if;\n \n+         --  Process the elements of an array type\n+\n+         if Is_Array_Type (Full_Typ) then\n+            Add_Array_Component_Invariants (Full_Typ, Obj_Id, Stmts);\n+\n+         --  Process the components of a record type\n+\n+         elsif Ekind (Full_Typ) = E_Record_Type then\n+            Add_Record_Component_Invariants (Full_Typ, Obj_Id, Stmts);\n+         end if;\n+\n          --  Process the invariants of the full view and in certain cases those\n          --  of the partial view. This also handles any invariants on array or\n          --  record components.\n \n-         Add_Type_Invariants\n-           (Priv_Typ  => Priv_Typ,\n-            Full_Typ  => Full_Typ,\n-            CRec_Typ  => CRec_Typ,\n+         Add_Own_Invariant\n+           (T         => Priv_Typ,\n+            Obj_Id    => Obj_Id,\n+            Checks    => Stmts,\n+            Priv_Item => Priv_Item);\n+\n+         Add_Own_Invariant\n+           (T         => Full_Typ,\n             Obj_Id    => Obj_Id,\n             Checks    => Stmts,\n             Priv_Item => Priv_Item);\n \n+         if Present (CRec_Typ) then\n+            Add_Record_Component_Invariants (CRec_Typ, Obj_Id, Stmts);\n+         end if;\n+\n          --  Process the inherited class-wide invariants of all parent types.\n          --  This also handles any invariants on record components.\n \n-         Add_Parent_Invariants (Full_Typ, Obj_Id, Stmts);\n+         declare\n+            Curr_Typ : Entity_Id;\n+            --  The entity of the current type being examined\n+\n+            Par_Full : Entity_Id;\n+            --  The full view of Par_Typ\n+\n+            Par_Priv : Entity_Id;\n+            --  The partial view of Par_Typ\n+\n+            Par_Typ : Entity_Id;\n+            --  The entity of the parent type\n+\n+         begin\n+            if not Is_Array_Type (Full_Typ) then\n+\n+               --  Climb the parent type chain\n+\n+               Curr_Typ := Full_Typ;\n+               loop\n+                  --  Do not consider subtypes as they inherit the invariants\n+                  --  from their base types.\n+\n+                  Par_Typ := Base_Type (Etype (Curr_Typ));\n \n-         --  Process the inherited class-wide invariants of all implemented\n-         --  interface types.\n+                  --  Stop the climb once the root of the parent chain is\n+                  --  reached.\n \n-         Add_Interface_Invariants (Full_Typ, Obj_Id, Stmts);\n+                  exit when Curr_Typ = Par_Typ;\n+\n+                  --  Process the class-wide invariants of the parent type\n+\n+                  Get_Views (Par_Typ, Par_Priv, Par_Full, Dummy_1, Dummy_2);\n+\n+                  --  Process the elements of an array type\n+\n+                  if Is_Array_Type (Par_Full) then\n+                     Add_Array_Component_Invariants (Par_Full, Obj_Id, Stmts);\n+\n+                  --  Process the components of a record type\n+\n+                  elsif Ekind (Par_Full) = E_Record_Type then\n+                     Add_Record_Component_Invariants (Par_Full, Obj_Id, Stmts);\n+                  end if;\n+\n+                  Add_Inherited_Invariant\n+                    (T      => Par_Priv,\n+                     Obj_Id => Obj_Id,\n+                     Checks => Stmts);\n+\n+                  Curr_Typ := Par_Typ;\n+               end loop;\n+            end if;\n+         end;\n+\n+         --  Generate an invariant check for each inherited class-wide\n+         --  invariant coming from all interfaces implemented by type T. Obj_Id\n+         --  denotes the entity of the _object formal parameter of the\n+         --  invariant procedure. All created checks are added to list Checks.\n+\n+         if Is_Tagged_Type (Full_Typ) then\n+            Collect_Interfaces (Full_Typ, Ifaces);\n+\n+            --  Process the class-wide invariants of all implemented interfaces\n+\n+            Iface_Elmt := First_Elmt (Ifaces);\n+            while Present (Iface_Elmt) loop\n+               Add_Inherited_Invariant\n+                 (T      => Node (Iface_Elmt),\n+                  Obj_Id => Obj_Id,\n+                  Checks => Stmts);\n+\n+               Next_Elmt (Iface_Elmt);\n+            end loop;\n+         end if;\n       end if;\n \n       End_Scope;"}, {"sha": "416557666e2aa1f7f0adddd568f5a51164bbbfd1", "filename": "gcc/ada/fname-uf.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2Ffname-uf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2Ffname-uf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-uf.adb?ref=998429d6f234d9a1fa1ecc711ac851ecb06919c9", "patch": "@@ -231,7 +231,7 @@ package body Fname.UF is\n       --    _and_.ads\n \n       --  which is bit peculiar, but we keep it that way. This means that we\n-      --  avoid bombs due to writing a bad file name, and w get expected error\n+      --  avoid bombs due to writing a bad file name, and we get expected error\n       --  processing downstream, e.g. a compilation following gnatchop.\n \n       if Name_Buffer (1) = '\"' then\n@@ -298,12 +298,10 @@ package body Fname.UF is\n             Pent := SFN_Patterns.First;\n             while Pent <= SFN_Patterns.Last loop\n                if SFN_Patterns.Table (Pent).Typ = Unit_Char_Search then\n-                  Name_Len := 0;\n-\n                   --  Determine if we have a predefined file name\n \n                   Is_Predef :=\n-                    Is_Predefined_File_Name\n+                    Is_Predefined_Unit_Name\n                       (Uname, Renamings_Included => True);\n \n                   --  Found a match, execute the pattern"}, {"sha": "058489e693f33877760333bb9b030ab90507323e", "filename": "gcc/ada/fname.adb", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2Ffname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2Ffname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.adb?ref=998429d6f234d9a1fa1ecc711ac851ecb06919c9", "patch": "@@ -58,8 +58,9 @@ package body Fname is\n      Table_Name           => \"Fname_Dummy_Table\");\n \n    function Has_Internal_Extension (Fname : String) return Boolean;\n-   --  True if the extension is \".ads\" or \".adb\", as is always the case for\n-   --  internal/predefined units.\n+   --  True if the extension is appropriate for an internal/predefined\n+   --  unit. That means \".ads\" or \".adb\" for source files, and \".ali\" for\n+   --  ALI files.\n \n    function Has_Prefix (X, Prefix : String) return Boolean;\n    --  True if Prefix is at the beginning of X. For example,\n@@ -76,7 +77,8 @@ package body Fname is\n    begin\n       return\n         Has_Suffix (Fname, Suffix => \".ads\")\n-          or else Has_Suffix (Fname, Suffix => \".adb\");\n+          or else Has_Suffix (Fname, Suffix => \".adb\")\n+          or else Has_Suffix (Fname, Suffix => \".ali\");\n    end Has_Internal_Extension;\n \n    ----------------\n@@ -139,10 +141,11 @@ package body Fname is\n      (Fname              : File_Name_Type;\n       Renamings_Included : Boolean := True) return Boolean\n    is\n+      Result : constant Boolean :=\n+                 Is_Internal_File_Name\n+                   (Get_Name_String (Fname), Renamings_Included);\n    begin\n-      return\n-        Is_Internal_File_Name\n-          (Get_Name_String (Fname), Renamings_Included);\n+      return Result;\n    end Is_Internal_File_Name;\n \n    -----------------------------"}, {"sha": "9a725173a3d23886e32f02b7aa427738ef87b46f", "filename": "gcc/ada/fname.ads", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2Ffname.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2Ffname.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.ads?ref=998429d6f234d9a1fa1ecc711ac851ecb06919c9", "patch": "@@ -68,15 +68,16 @@ package Fname is\n    function Is_Predefined_File_Name\n      (Fname              : File_Name_Type;\n       Renamings_Included : Boolean := True) return Boolean;\n-   --  These functions determine if the given file name (which must be a\n-   --  simple file name with no directory information) is the file name for\n-   --  one of the predefined library units (i.e. part of the Ada, System, or\n-   --  Interface hierarchies). Note that units in the GNAT hierarchy are not\n-   --  considered predefined (see Is_Internal_File_Name below). The\n-   --  Renamings_Included parameter indicates whether annex J renamings such as\n-   --  Text_IO are to be considered as predefined. If Renamings_Included is\n-   --  True, then Text_IO will return True, otherwise only children of Ada,\n-   --  Interfaces and System return True.\n+   --  These functions determine if the given file name (which must be a simple\n+   --  file name with no directory information) is the source or ALI file name\n+   --  for one of the predefined library units (i.e. part of the Ada, System,\n+   --  or Interface hierarchies). Note that units in the GNAT hierarchy are not\n+   --  considered predefined (see Is_Internal_File_Name below).\n+   --\n+   --  The Renamings_Included parameter indicates whether annex J renamings\n+   --  such as Text_IO are to be considered as predefined. If\n+   --  Renamings_Included is True, then Text_IO will return True, otherwise\n+   --  only children of Ada, Interfaces and System return True.\n \n    function Is_Internal_File_Name\n      (Fname              : String;"}, {"sha": "562ee0e8412e420bdcaf932ff3faeeaa5ae8bc19", "filename": "gcc/ada/uname.adb", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2Funame.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2Funame.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Funame.adb?ref=998429d6f234d9a1fa1ecc711ac851ecb06919c9", "patch": "@@ -41,6 +41,10 @@ with Sinput;   use Sinput;\n \n package body Uname is\n \n+   function Has_Prefix (X, Prefix : String) return Boolean;\n+   --  True if Prefix is at the beginning of X. For example,\n+   --  Has_Prefix(\"a-filename.ads\", Prefix => \"a-\") is True.\n+\n    -------------------\n    -- Get_Body_Name --\n    -------------------\n@@ -472,6 +476,23 @@ package body Uname is\n       end if;\n    end Get_Unit_Name_String;\n \n+   ----------------\n+   -- Has_Prefix --\n+   ----------------\n+\n+   function Has_Prefix (X, Prefix : String) return Boolean is\n+   begin\n+      if X'Length >= Prefix'Length then\n+         declare\n+            Slice : String renames\n+                      X (X'First .. X'First + Prefix'Length - 1);\n+         begin\n+            return Slice = Prefix;\n+         end;\n+      end if;\n+      return False;\n+   end Has_Prefix;\n+\n    ------------------\n    -- Is_Body_Name --\n    ------------------\n@@ -506,6 +527,72 @@ package body Uname is\n       return True;\n    end Is_Child_Name;\n \n+   ---------------------------\n+   -- Is_Internal_Unit_Name --\n+   ---------------------------\n+\n+   function Is_Internal_Unit_Name\n+     (Name               : String;\n+      Renamings_Included : Boolean := True) return Boolean\n+   is\n+      Gnat : constant String := \"gnat\";\n+\n+   begin\n+      if Name = Gnat then\n+         return True;\n+      end if;\n+\n+      if Has_Prefix (Name, Prefix => Gnat & \".\") then\n+         return True;\n+      end if;\n+\n+      return Is_Predefined_Unit_Name (Name, Renamings_Included);\n+   end Is_Internal_Unit_Name;\n+\n+   -----------------------------\n+   -- Is_Predefined_Unit_Name --\n+   -----------------------------\n+\n+   function Is_Predefined_Unit_Name\n+     (Name               : String;\n+      Renamings_Included : Boolean := True) return Boolean\n+   is\n+      Ada        : constant String := \"ada\";\n+      Interfaces : constant String := \"interfaces\";\n+      System     : constant String := \"system\";\n+\n+   begin\n+      if Name = Ada\n+        or else Name = Interfaces\n+        or else Name = System\n+      then\n+         return True;\n+      end if;\n+\n+      if Has_Prefix (Name, Prefix => Ada & \".\")\n+        or else Has_Prefix (Name, Prefix => Interfaces & \".\")\n+        or else Has_Prefix (Name, Prefix => System & \".\")\n+      then\n+         return True;\n+      end if;\n+\n+      if not Renamings_Included then\n+         return False;\n+      end if;\n+\n+      --  The following are the predefined renamings\n+\n+      return\n+        Name = \"calendar\"\n+          or else Name = \"machine_code\"\n+          or else Name = \"unchecked_conversion\"\n+          or else Name = \"unchecked_deallocation\"\n+          or else Name = \"direct_io\"\n+          or else Name = \"io_exceptions\"\n+          or else Name = \"sequential_io\"\n+          or else Name = \"text_io\";\n+   end Is_Predefined_Unit_Name;\n+\n    ------------------\n    -- Is_Spec_Name --\n    ------------------"}, {"sha": "5dc02cfc9f29659be5b426d640f457c9f1eac8a7", "filename": "gcc/ada/uname.ads", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2Funame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998429d6f234d9a1fa1ecc711ac851ecb06919c9/gcc%2Fada%2Funame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Funame.ads?ref=998429d6f234d9a1fa1ecc711ac851ecb06919c9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -133,6 +133,18 @@ package Uname is\n    --  Returns True iff the given name is a child unit name (of either a\n    --  body or a spec).\n \n+   function Is_Internal_Unit_Name\n+     (Name               : String;\n+      Renamings_Included : Boolean := True) return Boolean;\n+   --  Same as Fname.Is_Internal_File_Name, except it works with the name of\n+   --  the unit, rather than the file name.\n+\n+   function Is_Predefined_Unit_Name\n+     (Name               : String;\n+      Renamings_Included : Boolean := True) return Boolean;\n+   --  Same as Fname.Is_Predefined_File_Name, except it works with the name of\n+   --  the unit, rather than the file name.\n+\n    function Is_Spec_Name (N : Unit_Name_Type) return Boolean;\n    --  Returns True iff the given name is the unit name of a specification\n    --  (i.e. if it ends with the characters %s)."}]}