{"sha": "4961683533a0f3dd4ecd4aef5d2084463be1e582", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk2MTY4MzUzM2EwZjNkZDRlY2Q0YWVmNWQyMDg0NDYzYmUxZTU4Mg==", "commit": {"author": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2004-06-29T17:37:13Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2004-06-29T17:37:13Z"}, "message": "Fix gcc.dg/builtin-apply2.c failures:\n\n\t* sh.h (TARGET_VARARGS_PRETEND_ARGS): Define.\n\t* sh.c (extra_push): Delete.\n\t(sh_expand_prologue): Don't do extra stack adjustment for\n\tcurrent_function_pretend_args_size if it comes from varargs setup.\n\tUse TARGET_VARARGS_PRETEND_ARGS.  Don't set extra_push.\n\t(sh_expand_epilogue): Don't use extra_push.\n\t(sh_setup_incoming_varargs): Set pretend_arg_size when necessary.\n\nFrom-SVN: r83864", "tree": {"sha": "b8d2fd39f7ce05496aa22639862e39f75ff480aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8d2fd39f7ce05496aa22639862e39f75ff480aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4961683533a0f3dd4ecd4aef5d2084463be1e582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4961683533a0f3dd4ecd4aef5d2084463be1e582", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4961683533a0f3dd4ecd4aef5d2084463be1e582", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4961683533a0f3dd4ecd4aef5d2084463be1e582/comments", "author": null, "committer": null, "parents": [{"sha": "8d2fb08dbf478c912b8e098606e18848741ba2a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2fb08dbf478c912b8e098606e18848741ba2a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d2fb08dbf478c912b8e098606e18848741ba2a2"}], "stats": {"total": 44, "additions": 30, "deletions": 14}, "files": [{"sha": "3f5889d2d161ba42bc2d6844e3060fbfbcdf7d86", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4961683533a0f3dd4ecd4aef5d2084463be1e582/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4961683533a0f3dd4ecd4aef5d2084463be1e582/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=4961683533a0f3dd4ecd4aef5d2084463be1e582", "patch": "@@ -4700,8 +4700,6 @@ output_jump_label_table (void)\n /* Number of bytes pushed for anonymous args, used to pass information\n    between expand_prologue and expand_epilogue.  */\n \n-static int extra_push;\n-\n /* Adjust the stack by SIZE bytes.  REG holds the rtl of the register to be\n    adjusted.  If epilogue_p is zero, this is for a prologue; otherwise, it's\n    for an epilogue and a negative value means that it's for a sibcall\n@@ -5321,17 +5319,21 @@ sh_expand_prologue (void)\n   int d, i;\n   int d_rounding = 0;\n   int save_flags = target_flags;\n+  int pretend_args;\n \n   current_function_interrupt = sh_cfun_interrupt_handler_p ();\n \n   /* We have pretend args if we had an object sent partially in registers\n      and partially on the stack, e.g. a large structure.  */\n-  output_stack_adjust (-current_function_pretend_args_size\n+  pretend_args = current_function_pretend_args_size;\n+  if (TARGET_VARARGS_PRETEND_ARGS (current_function_decl)\n+      && (NPARM_REGS(SImode)\n+\t  > current_function_args_info.arg_count[(int) SH_ARG_INT]))\n+    pretend_args = 0;\n+  output_stack_adjust (-pretend_args\n \t\t       - current_function_args_info.stack_regs * 8,\n \t\t       stack_pointer_rtx, 0, NULL);\n \n-  extra_push = 0;\n-\n   if (TARGET_SHCOMPACT && flag_pic && current_function_args_info.call_cookie)\n     /* We're going to use the PIC register to load the address of the\n        incoming-argument decoder and/or of the return trampoline from\n@@ -5388,9 +5390,7 @@ sh_expand_prologue (void)\n   /* Emit the code for SETUP_VARARGS.  */\n   if (current_function_stdarg)\n     {\n-      /* This is not used by the SH2E calling convention  */\n-      if (TARGET_SH1 && ! TARGET_SH2E && ! TARGET_SH5\n-\t  && ! (TARGET_HITACHI || sh_cfun_attr_renesas_p ()))\n+      if (TARGET_VARARGS_PRETEND_ARGS (current_function_decl))\n \t{\n \t  /* Push arg regs as if they'd been provided by caller in stack.  */\n \t  for (i = 0; i < NPARM_REGS(SImode); i++)\n@@ -5404,7 +5404,6 @@ sh_expand_prologue (void)\n \t\tbreak;\n \t      insn = push (rn);\n \t      RTX_FRAME_RELATED_P (insn) = 0;\n-\t      extra_push += 4;\n \t    }\n \t}\n     }\n@@ -5904,7 +5903,7 @@ sh_expand_epilogue (bool sibcall_p)\n     emit_insn (gen_toggle_sz ());\n   target_flags = save_flags;\n \n-  output_stack_adjust (extra_push + current_function_pretend_args_size\n+  output_stack_adjust (current_function_pretend_args_size\n \t\t       + save_size + d_rounding\n \t\t       + current_function_args_info.stack_regs * 8,\n \t\t       stack_pointer_rtx, e, NULL);\n@@ -6789,14 +6788,26 @@ sh_return_in_memory (tree type, tree fndecl)\n    later.  Fortunately, we already have two flags that are part of struct\n    function that tell if a function uses varargs or stdarg.  */\n static void\n-sh_setup_incoming_varargs (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n-\t\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t   tree type ATTRIBUTE_UNUSED,\n-\t\t\t   int *pretend_arg_size ATTRIBUTE_UNUSED,\n+sh_setup_incoming_varargs (CUMULATIVE_ARGS *ca,\n+\t\t\t   enum machine_mode mode,\n+\t\t\t   tree type,\n+\t\t\t   int *pretend_arg_size,\n \t\t\t   int second_time ATTRIBUTE_UNUSED)\n {\n   if (! current_function_stdarg)\n     abort ();\n+  if (TARGET_VARARGS_PRETEND_ARGS (current_function_decl))\n+    {\n+      int named_parm_regs, anon_parm_regs;\n+\n+      named_parm_regs = (ROUND_REG (*ca, mode)\n+\t\t\t + (mode == BLKmode\n+\t\t\t    ? ROUND_ADVANCE (int_size_in_bytes (type))\n+\t\t\t    : ROUND_ADVANCE (GET_MODE_SIZE (mode))));\n+      anon_parm_regs = NPARM_REGS (SImode) - named_parm_regs;\n+      if (anon_parm_regs > 0)\n+\t*pretend_arg_size = anon_parm_regs * 4;\n+    }\n }\n \n static bool"}, {"sha": "0d6d1c6570c6e94d4730c99b9ef194f3198005f5", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4961683533a0f3dd4ecd4aef5d2084463be1e582/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4961683533a0f3dd4ecd4aef5d2084463be1e582/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=4961683533a0f3dd4ecd4aef5d2084463be1e582", "patch": "@@ -263,6 +263,11 @@ extern int target_flags;\n \n #define TARGET_SAVE_ALL_TARGET_REGS (target_flags & SAVE_ALL_TR_BIT)\n \n+/* This is not used by the SH2E calling convention  */\n+#define TARGET_VARARGS_PRETEND_ARGS(FUN_DECL) \\\n+  (TARGET_SH1 && ! TARGET_SH2E && ! TARGET_SH5 \\\n+   && ! (TARGET_HITACHI || sh_attr_renesas_p (FUN_DECL)))\n+\n #ifndef TARGET_CPU_DEFAULT\n #define TARGET_CPU_DEFAULT SELECT_SH1\n #define SUPPORT_SH1"}]}