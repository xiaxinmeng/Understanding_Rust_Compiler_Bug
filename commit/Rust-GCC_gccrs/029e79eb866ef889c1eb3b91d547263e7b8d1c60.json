{"sha": "029e79eb866ef889c1eb3b91d547263e7b8d1c60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI5ZTc5ZWI4NjZlZjg4OWMxZWIzYjkxZDU0NzI2M2U3YjhkMWM2MA==", "commit": {"author": {"name": "Marcus Shawcroft", "email": "marcus.shawcroft@arm.com", "date": "2010-08-18T08:25:33Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2010-08-18T08:25:33Z"}, "message": "For Marcus - Implement sync primitives inline for ARM.\n\n2010-08-18  Marcus Shawcroft  <marcus.shawcroft@arm.com>\n\n\t* config/arm/arm-protos.h (arm_expand_sync): New.\n\t(arm_output_memory_barrier, arm_output_sync_insn): New.\n\t(arm_sync_loop_insns): New.\n\t* config/arm/arm.c (FL_ARCH7): New.\n\t(FL_FOR_ARCH7): Include FL_ARCH7.\n\t(arm_arch7): New.\n\t(arm_print_operand): Support %C markup.\n\t(arm_legitimize_sync_memory): New.\n\t(arm_emit, arm_insn_count, arm_count, arm_output_asm_insn): New.\n\t(arm_process_output_memory_barrier, arm_output_memory_barrier): New.\n\t(arm_ldrex_suffix, arm_output_ldrex, arm_output_strex): New.\n\t(arm_output_op2, arm_output_op3, arm_output_sync_loop): New.\n\t(arm_get_sync_operand, FETCH_SYNC_OPERAND): New.\n\t(arm_process_output_sync_insn, arm_output_sync_insn): New.\n\t(arm_sync_loop_insns,arm_call_generator, arm_expand_sync): New.\n\t* config/arm/arm.h (struct arm_sync_generator): New.\n\t(TARGET_HAVE_DMB, TARGET_HAVE_DMB_MCR): New.\n\t(TARGET_HAVE_MEMORY_BARRIER): New.\n\t(TARGET_HAVE_LDREX, TARGET_HAVE_LDREXBHD): New.\n\t* config/arm/arm.md: Include sync.md.\n\t(UNSPEC_MEMORY_BARRIER): New.\n\t(VUNSPEC_SYNC_COMPARE_AND_SWAP, VUNSPEC_SYNC_LOCK): New.\n\t(VUNSPEC_SYNC_OP):New.\n\t(VUNSPEC_SYNC_NEW_OP, VUNSPEC_SYNC_OLD_OP): New.\n\t(sync_result, sync_memory, sync_required_value): New attributes.\n\t(sync_new_value, sync_t1, sync_t2): Likewise.\n\t(sync_release_barrier, sync_op): Likewise.\n\t(length): Add logic to length attribute defintion to call\n\tarm_sync_loop_insns when appropriate.\n\t* config/arm/sync.md: New file.\n\nFrom-SVN: r163327", "tree": {"sha": "abb90a18a297a681918852c397794998d5918643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abb90a18a297a681918852c397794998d5918643"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/029e79eb866ef889c1eb3b91d547263e7b8d1c60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/029e79eb866ef889c1eb3b91d547263e7b8d1c60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/029e79eb866ef889c1eb3b91d547263e7b8d1c60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/029e79eb866ef889c1eb3b91d547263e7b8d1c60/comments", "author": {"login": "mshawcroft", "id": 6357566, "node_id": "MDQ6VXNlcjYzNTc1NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6357566?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mshawcroft", "html_url": "https://github.com/mshawcroft", "followers_url": "https://api.github.com/users/mshawcroft/followers", "following_url": "https://api.github.com/users/mshawcroft/following{/other_user}", "gists_url": "https://api.github.com/users/mshawcroft/gists{/gist_id}", "starred_url": "https://api.github.com/users/mshawcroft/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mshawcroft/subscriptions", "organizations_url": "https://api.github.com/users/mshawcroft/orgs", "repos_url": "https://api.github.com/users/mshawcroft/repos", "events_url": "https://api.github.com/users/mshawcroft/events{/privacy}", "received_events_url": "https://api.github.com/users/mshawcroft/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "257f5167d8eaf554f6ed21a25883925d31ac26f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/257f5167d8eaf554f6ed21a25883925d31ac26f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/257f5167d8eaf554f6ed21a25883925d31ac26f5"}], "stats": {"total": 1080, "additions": 1077, "deletions": 3}, "files": [{"sha": "48ee83322e94a2200dd8bc3e82aabf203c3bad73", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029e79eb866ef889c1eb3b91d547263e7b8d1c60/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029e79eb866ef889c1eb3b91d547263e7b8d1c60/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=029e79eb866ef889c1eb3b91d547263e7b8d1c60", "patch": "@@ -1,3 +1,36 @@\n+2010-08-18  Marcus Shawcroft  <marcus.shawcroft@arm.com>\n+\n+\t* config/arm/arm-protos.h (arm_expand_sync): New.\n+\t(arm_output_memory_barrier, arm_output_sync_insn): New.\n+\t(arm_sync_loop_insns): New.\n+\t* config/arm/arm.c (FL_ARCH7): New.\n+\t(FL_FOR_ARCH7): Include FL_ARCH7.\n+\t(arm_arch7): New.\n+\t(arm_print_operand): Support %C markup.\n+\t(arm_legitimize_sync_memory): New.\n+\t(arm_emit, arm_insn_count, arm_count, arm_output_asm_insn): New.\n+\t(arm_process_output_memory_barrier, arm_output_memory_barrier): New.\n+\t(arm_ldrex_suffix, arm_output_ldrex, arm_output_strex): New.\n+\t(arm_output_op2, arm_output_op3, arm_output_sync_loop): New.\n+\t(arm_get_sync_operand, FETCH_SYNC_OPERAND): New.\n+\t(arm_process_output_sync_insn, arm_output_sync_insn): New.\n+\t(arm_sync_loop_insns,arm_call_generator, arm_expand_sync): New.\n+\t* config/arm/arm.h (struct arm_sync_generator): New.\n+\t(TARGET_HAVE_DMB, TARGET_HAVE_DMB_MCR): New.\n+\t(TARGET_HAVE_MEMORY_BARRIER): New.\n+\t(TARGET_HAVE_LDREX, TARGET_HAVE_LDREXBHD): New.\n+\t* config/arm/arm.md: Include sync.md.\n+\t(UNSPEC_MEMORY_BARRIER): New.\n+\t(VUNSPEC_SYNC_COMPARE_AND_SWAP, VUNSPEC_SYNC_LOCK): New.\n+\t(VUNSPEC_SYNC_OP):New.\n+\t(VUNSPEC_SYNC_NEW_OP, VUNSPEC_SYNC_OLD_OP): New.\n+\t(sync_result, sync_memory, sync_required_value): New attributes.\n+\t(sync_new_value, sync_t1, sync_t2): Likewise.\n+\t(sync_release_barrier, sync_op): Likewise.\n+\t(length): Add logic to length attribute defintion to call\n+\tarm_sync_loop_insns when appropriate.\n+\t* config/arm/sync.md: New file.\n+\n 2010-08-17  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree.h (host_integerp): Add ATTRIBUTE_PURE when not"}, {"sha": "cd29ef15cfa80adf63c056d9f64a4339946bec21", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029e79eb866ef889c1eb3b91d547263e7b8d1c60/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029e79eb866ef889c1eb3b91d547263e7b8d1c60/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=029e79eb866ef889c1eb3b91d547263e7b8d1c60", "patch": "@@ -144,6 +144,11 @@ extern const char *vfp_output_fstmd (rtx *);\n extern void arm_set_return_address (rtx, rtx);\n extern int arm_eliminable_register (rtx);\n extern const char *arm_output_shift(rtx *, int);\n+extern void arm_expand_sync (enum machine_mode, struct arm_sync_generator *,\n+ \t\t\t     rtx, rtx, rtx, rtx);\n+extern const char *arm_output_memory_barrier (rtx *);\n+extern const char *arm_output_sync_insn (rtx, rtx *);\n+extern unsigned int arm_sync_loop_insns (rtx , rtx *);\n \n extern bool arm_output_addr_const_extra (FILE *, rtx);\n "}, {"sha": "3dd73e8c0d969a68e8976c4bb6158bdd832f6143", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 385, "deletions": 1, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029e79eb866ef889c1eb3b91d547263e7b8d1c60/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029e79eb866ef889c1eb3b91d547263e7b8d1c60/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=029e79eb866ef889c1eb3b91d547263e7b8d1c60", "patch": "@@ -593,6 +593,7 @@ static int thumb_call_reg_needed;\n #define FL_NEON       (1 << 20)       /* Neon instructions.  */\n #define FL_ARCH7EM    (1 << 21)\t      /* Instructions present in the ARMv7E-M\n \t\t\t\t\t architecture.  */\n+#define FL_ARCH7      (1 << 22)       /* Architecture 7.  */\n \n #define FL_IWMMXT     (1 << 29)\t      /* XScale v2 or \"Intel Wireless MMX technology\".  */\n \n@@ -617,7 +618,7 @@ static int thumb_call_reg_needed;\n #define FL_FOR_ARCH6ZK\tFL_FOR_ARCH6K\n #define FL_FOR_ARCH6T2\t(FL_FOR_ARCH6 | FL_THUMB2)\n #define FL_FOR_ARCH6M\t(FL_FOR_ARCH6 & ~FL_NOTM)\n-#define FL_FOR_ARCH7\t(FL_FOR_ARCH6T2 &~ FL_NOTM)\n+#define FL_FOR_ARCH7\t((FL_FOR_ARCH6T2 & ~FL_NOTM) | FL_ARCH7)\n #define FL_FOR_ARCH7A\t(FL_FOR_ARCH7 | FL_NOTM | FL_ARCH6K)\n #define FL_FOR_ARCH7R\t(FL_FOR_ARCH7A | FL_DIV)\n #define FL_FOR_ARCH7M\t(FL_FOR_ARCH7 | FL_DIV)\n@@ -655,6 +656,9 @@ int arm_arch6 = 0;\n /* Nonzero if this chip supports the ARM 6K extensions.  */\n int arm_arch6k = 0;\n \n+/* Nonzero if this chip supports the ARM 7 extensions.  */\n+int arm_arch7 = 0;\n+\n /* Nonzero if instructions not present in the 'M' profile can be used.  */\n int arm_arch_notm = 0;\n \n@@ -1589,6 +1593,7 @@ arm_override_options (void)\n   arm_arch6 = (insn_flags & FL_ARCH6) != 0;\n   arm_arch6k = (insn_flags & FL_ARCH6K) != 0;\n   arm_arch_notm = (insn_flags & FL_NOTM) != 0;\n+  arm_arch7 = (insn_flags & FL_ARCH7) != 0;\n   arm_arch7em = (insn_flags & FL_ARCH7EM) != 0;\n   arm_arch_thumb2 = (insn_flags & FL_THUMB2) != 0;\n   arm_arch_xscale = (insn_flags & FL_XSCALE) != 0;\n@@ -16247,6 +16252,17 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       }\n       return;\n \n+    case 'C':\n+      {\n+\trtx addr;\n+\n+\tgcc_assert (GET_CODE (x) == MEM);\n+\taddr = XEXP (x, 0);\n+\tgcc_assert (GET_CODE (addr) == REG);\n+\tasm_fprintf (stream, \"[%r]\", REGNO (addr));\n+      }\n+      return;\n+\n     /* Translate an S register number into a D register number and element index.  */\n     case 'y':\n       {\n@@ -22575,4 +22591,372 @@ arm_have_conditional_execution (void)\n   return !TARGET_THUMB1;\n }\n \n+/* Legitimize a memory reference for sync primitive implemented using\n+   ldrex / strex.  We currently force the form of the reference to be\n+   indirect without offset.  We do not yet support the indirect offset\n+   addressing supported by some ARM targets for these\n+   instructions.  */\n+static rtx\n+arm_legitimize_sync_memory (rtx memory)\n+{\n+  rtx addr = force_reg (Pmode, XEXP (memory, 0));\n+  rtx legitimate_memory = gen_rtx_MEM (GET_MODE (memory), addr);\n+\n+  set_mem_alias_set (legitimate_memory, ALIAS_SET_MEMORY_BARRIER);\n+  MEM_VOLATILE_P (legitimate_memory) = MEM_VOLATILE_P (memory);\n+  return legitimate_memory;\n+}\n+\n+/* An instruction emitter. */\n+typedef void (* emit_f) (int label, const char *, rtx *);\n+\n+/* An instruction emitter that emits via the conventional\n+   output_asm_insn.  */\n+static void\n+arm_emit (int label ATTRIBUTE_UNUSED, const char *pattern, rtx *operands)\n+{\n+  output_asm_insn (pattern, operands);\n+}\n+\n+/* Count the number of emitted synchronization instructions.  */\n+static unsigned arm_insn_count;\n+\n+/* An emitter that counts emitted instructions but does not actually\n+   emit instruction into the the instruction stream.  */\n+static void\n+arm_count (int label,\n+\t   const char *pattern ATTRIBUTE_UNUSED,\n+\t   rtx *operands ATTRIBUTE_UNUSED)\n+{\n+  if (! label)\n+    ++ arm_insn_count;\n+}\n+\n+/* Construct a pattern using conventional output formatting and feed\n+   it to output_asm_insn.  Provides a mechanism to construct the\n+   output pattern on the fly.  Note the hard limit on the pattern\n+   buffer size.  */\n+static void\n+arm_output_asm_insn (emit_f emit, int label, rtx *operands,\n+\t\t     const char *pattern, ...)\n+{\n+  va_list ap;\n+  char buffer[256];\n+\n+  va_start (ap, pattern);\n+  vsprintf (buffer, pattern, ap);\n+  va_end (ap);\n+  emit (label, buffer, operands);\n+}\n+\n+/* Emit the memory barrier instruction, if any, provided by this\n+   target to a specified emitter.  */\n+static void\n+arm_process_output_memory_barrier (emit_f emit, rtx *operands)\n+{\n+  if (TARGET_HAVE_DMB)\n+    {\n+      /* Note we issue a system level barrier. We should consider\n+         issuing a inner shareabilty zone barrier here instead, ie.\n+         \"DMB ISH\".  */\n+      emit (0, \"dmb\\tsy\", operands);\n+      return;\n+    }\n+\n+  if (TARGET_HAVE_DMB_MCR)\n+    {\n+      emit (0, \"mcr\\tp15, 0, r0, c7, c10, 5\", operands);\n+      return;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Emit the memory barrier instruction, if any, provided by this\n+   target.  */\n+const char *\n+arm_output_memory_barrier (rtx *operands)\n+{\n+  arm_process_output_memory_barrier (arm_emit, operands);\n+  return \"\";\n+}\n+\n+/* Helper to figure out the instruction suffix required on ldrex/strex\n+   for operations on an object of the specified mode.  */\n+static const char *\n+arm_ldrex_suffix (enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case QImode: return \"b\";\n+    case HImode: return \"h\";\n+    case SImode: return \"\";\n+    case DImode: return \"d\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return \"\";\n+}\n+\n+/* Emit an ldrex{b,h,d, } instruction appropriate for the specified\n+   mode.  */\n+static void\n+arm_output_ldrex (emit_f emit,\n+\t\t  enum machine_mode mode,\n+\t\t  rtx target,\n+\t\t  rtx memory)\n+{\n+  const char *suffix = arm_ldrex_suffix (mode);\n+  rtx operands[2];\n+\n+  operands[0] = target;\n+  operands[1] = memory;\n+  arm_output_asm_insn (emit, 0, operands, \"ldrex%s\\t%%0, %%C1\", suffix);\n+}\n+\n+/* Emit a strex{b,h,d, } instruction appropriate for the specified\n+   mode.  */\n+static void\n+arm_output_strex (emit_f emit,\n+\t\t  enum machine_mode mode,\n+\t\t  const char *cc,\n+\t\t  rtx result,\n+\t\t  rtx value,\n+\t\t  rtx memory)\n+{\n+  const char *suffix = arm_ldrex_suffix (mode);\n+  rtx operands[3];\n+\n+  operands[0] = result;\n+  operands[1] = value;\n+  operands[2] = memory;\n+  arm_output_asm_insn (emit, 0, operands, \"strex%s%s\\t%%0, %%1, %%C2\", suffix,\n+\t\t       cc);\n+}\n+\n+/* Helper to emit a two operand instruction.  */\n+static void\n+arm_output_op2 (emit_f emit, const char *mnemonic, rtx d, rtx s)\n+{\n+  rtx operands[2];\n+\n+  operands[0] = d;\n+  operands[1] = s;\n+  arm_output_asm_insn (emit, 0, operands, \"%s\\t%%0, %%1\", mnemonic);\n+}\n+\n+/* Helper to emit a three operand instruction.  */\n+static void\n+arm_output_op3 (emit_f emit, const char *mnemonic, rtx d, rtx a, rtx b)\n+{\n+  rtx operands[3];\n+\n+  operands[0] = d;\n+  operands[1] = a;\n+  operands[2] = b;\n+  arm_output_asm_insn (emit, 0, operands, \"%s\\t%%0, %%1, %%2\", mnemonic);\n+}\n+\n+/* Emit a load store exclusive synchronization loop.\n+\n+   do\n+     old_value = [mem]\n+     if old_value != required_value\n+       break;\n+     t1 = sync_op (old_value, new_value)\n+     [mem] = t1, t2 = [0|1]\n+   while ! t2\n+\n+   Note:\n+     t1 == t2 is not permitted\n+     t1 == old_value is permitted\n+\n+   required_value:\n+\n+   RTX register or const_int representing the required old_value for\n+   the modify to continue, if NULL no comparsion is performed.  */\n+static void\n+arm_output_sync_loop (emit_f emit,\n+\t\t      enum machine_mode mode,\n+\t\t      rtx old_value,\n+\t\t      rtx memory,\n+\t\t      rtx required_value,\n+\t\t      rtx new_value,\n+\t\t      rtx t1,\n+\t\t      rtx t2,\n+\t\t      enum attr_sync_op sync_op,\n+\t\t      int early_barrier_required)\n+{\n+  rtx operands[1];\n+\n+  gcc_assert (t1 != t2);\n+\n+  if (early_barrier_required)\n+    arm_process_output_memory_barrier (emit, NULL);\n+\n+  arm_output_asm_insn (emit, 1, operands, \"%sLSYT%%=:\", LOCAL_LABEL_PREFIX);\n+\n+  arm_output_ldrex (emit, mode, old_value, memory);\n+\n+  if (required_value)\n+    {\n+      rtx operands[2];\n+\n+      operands[0] = old_value;\n+      operands[1] = required_value;\n+      arm_output_asm_insn (emit, 0, operands, \"cmp\\t%%0, %%1\");\n+      arm_output_asm_insn (emit, 0, operands, \"bne\\t%sLSYB%%=\", LOCAL_LABEL_PREFIX);\n+    }\n+\n+  switch (sync_op)\n+    {\n+    case SYNC_OP_ADD:\n+      arm_output_op3 (emit, \"add\", t1, old_value, new_value);\n+      break;\n+\n+    case SYNC_OP_SUB:\n+      arm_output_op3 (emit, \"sub\", t1, old_value, new_value);\n+      break;\n+\n+    case SYNC_OP_IOR:\n+      arm_output_op3 (emit, \"orr\", t1, old_value, new_value);\n+      break;\n+\n+    case SYNC_OP_XOR:\n+      arm_output_op3 (emit, \"eor\", t1, old_value, new_value);\n+      break;\n+\n+    case SYNC_OP_AND:\n+      arm_output_op3 (emit,\"and\", t1, old_value, new_value);\n+      break;\n+\n+    case SYNC_OP_NAND:\n+      arm_output_op3 (emit, \"and\", t1, old_value, new_value);\n+      arm_output_op2 (emit, \"mvn\", t1, t1);\n+      break;\n+\n+    case SYNC_OP_NONE:\n+      t1 = new_value;\n+      break;\n+    }\n+\n+  arm_output_strex (emit, mode, \"\", t2, t1, memory);\n+  operands[0] = t2;\n+  arm_output_asm_insn (emit, 0, operands, \"teq\\t%%0, #0\");\n+  arm_output_asm_insn (emit, 0, operands, \"bne\\t%sLSYT%%=\", LOCAL_LABEL_PREFIX);\n+\n+  arm_process_output_memory_barrier (emit, NULL);\n+  arm_output_asm_insn (emit, 1, operands, \"%sLSYB%%=:\", LOCAL_LABEL_PREFIX);\n+}\n+\n+static rtx\n+arm_get_sync_operand (rtx *operands, int index, rtx default_value)\n+{\n+  if (index > 0)\n+    default_value = operands[index - 1];\n+\n+  return default_value;\n+}\n+\n+#define FETCH_SYNC_OPERAND(NAME, DEFAULT) \\\n+  arm_get_sync_operand (operands, (int) get_attr_sync_##NAME (insn), DEFAULT);\n+\n+/* Extract the operands for a synchroniztion instruction from the\n+   instructions attributes and emit the instruction.  */\n+static void\n+arm_process_output_sync_insn (emit_f emit, rtx insn, rtx *operands)\n+{\n+  rtx result, memory, required_value, new_value, t1, t2;\n+  int early_barrier;\n+  enum machine_mode mode;\n+  enum attr_sync_op sync_op;\n+\n+  result = FETCH_SYNC_OPERAND(result, 0);\n+  memory = FETCH_SYNC_OPERAND(memory, 0);\n+  required_value = FETCH_SYNC_OPERAND(required_value, 0);\n+  new_value = FETCH_SYNC_OPERAND(new_value, 0);\n+  t1 = FETCH_SYNC_OPERAND(t1, 0);\n+  t2 = FETCH_SYNC_OPERAND(t2, 0);\n+  early_barrier =\n+    get_attr_sync_release_barrier (insn) == SYNC_RELEASE_BARRIER_YES;\n+  sync_op = get_attr_sync_op (insn);\n+  mode = GET_MODE (memory);\n+\n+  arm_output_sync_loop (emit, mode, result, memory, required_value,\n+\t\t\tnew_value, t1, t2, sync_op, early_barrier);\n+}\n+\n+/* Emit a synchronization instruction loop.  */\n+const char *\n+arm_output_sync_insn (rtx insn, rtx *operands)\n+{\n+  arm_process_output_sync_insn (arm_emit, insn, operands);\n+  return \"\";\n+}\n+\n+/* Count the number of machine instruction that will be emitted for a\n+   synchronization instruction.  Note that the emitter used does not\n+   emit instructions, it just counts instructions being carefull not\n+   to count labels.  */\n+unsigned int\n+arm_sync_loop_insns (rtx insn, rtx *operands)\n+{\n+  arm_insn_count = 0;\n+  arm_process_output_sync_insn (arm_count, insn, operands);\n+  return arm_insn_count;\n+}\n+\n+/* Helper to call a target sync instruction generator, dealing with\n+   the variation in operands required by the different generators.  */\n+static rtx\n+arm_call_generator (struct arm_sync_generator *generator, rtx old_value,\n+  \t\t    rtx memory, rtx required_value, rtx new_value)\n+{\n+  switch (generator->op)\n+    {\n+    case arm_sync_generator_omn:\n+      gcc_assert (! required_value);\n+      return generator->u.omn (old_value, memory, new_value);\n+\n+    case arm_sync_generator_omrn:\n+      gcc_assert (required_value);\n+      return generator->u.omrn (old_value, memory, required_value, new_value);\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Expand a synchronization loop. The synchronization loop is expanded\n+   as an opaque block of instructions in order to ensure that we do\n+   not subsequently get extraneous memory accesses inserted within the\n+   critical region. The exclusive access property of ldrex/strex is\n+   only guaranteed in there are no intervening memory accesses. */\n+void\n+arm_expand_sync (enum machine_mode mode,\n+\t\t struct arm_sync_generator *generator,\n+\t\t rtx target, rtx memory, rtx required_value, rtx new_value)\n+{\n+  if (target == NULL)\n+    target = gen_reg_rtx (mode);\n+\n+  memory = arm_legitimize_sync_memory (memory);\n+  if (mode != SImode)\n+    {\n+      rtx load_temp = gen_reg_rtx (SImode);\n+\n+      if (required_value)\n+\trequired_value = convert_modes (SImode, mode, required_value, true);\n+\n+      new_value = convert_modes (SImode, mode, new_value, true);\n+      emit_insn (arm_call_generator (generator, load_temp, memory,\n+\t\t\t\t     required_value, new_value));\n+      emit_move_insn (target, gen_lowpart (mode, load_temp));\n+    }\n+  else\n+    {\n+      emit_insn (arm_call_generator (generator, target, memory, required_value,\n+\t\t\t\t     new_value));\n+    }\n+}\n+\n #include \"gt-arm.h\""}, {"sha": "9730417ee3ebd9562f9062f29242e66cce22d7c5", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029e79eb866ef889c1eb3b91d547263e7b8d1c60/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029e79eb866ef889c1eb3b91d547263e7b8d1c60/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=029e79eb866ef889c1eb3b91d547263e7b8d1c60", "patch": "@@ -126,6 +126,24 @@ enum target_cpus\n /* The processor for which instructions should be scheduled.  */\n extern enum processor_type arm_tune;\n \n+enum arm_sync_generator_tag\n+  {\n+    arm_sync_generator_omn,\n+    arm_sync_generator_omrn\n+  };\n+\n+/* Wrapper to pass around a polymorphic pointer to a sync instruction\n+   generator and.  */\n+struct arm_sync_generator\n+{\n+  enum arm_sync_generator_tag op;\n+  union\n+  {\n+    rtx (* omn) (rtx, rtx, rtx);\n+    rtx (* omrn) (rtx, rtx, rtx, rtx);\n+  } u;\n+};\n+\n typedef enum arm_cond_code\n {\n   ARM_EQ = 0, ARM_NE, ARM_CS, ARM_CC, ARM_MI, ARM_PL, ARM_VS, ARM_VC,\n@@ -270,6 +288,20 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n    for Thumb-2.  */\n #define TARGET_UNIFIED_ASM TARGET_THUMB2\n \n+/* Nonzero if this chip provides the DMB instruction.  */\n+#define TARGET_HAVE_DMB\t\t(arm_arch7)\n+\n+/* Nonzero if this chip implements a memory barrier via CP15.  */\n+#define TARGET_HAVE_DMB_MCR\t(arm_arch6k && ! TARGET_HAVE_DMB)\n+\n+/* Nonzero if this chip implements a memory barrier instruction.  */\n+#define TARGET_HAVE_MEMORY_BARRIER (TARGET_HAVE_DMB || TARGET_HAVE_DMB_MCR)\n+\n+/* Nonzero if this chip supports ldrex and strex */\n+#define TARGET_HAVE_LDREX\t((arm_arch6 && TARGET_ARM) || arm_arch7)\n+\n+/* Nonzero if this chip supports ldrex{bhd} and strex{bhd}.  */\n+#define TARGET_HAVE_LDREXBHD\t((arm_arch6k && TARGET_ARM) || arm_arch7)\n \n /* True iff the full BPABI is being used.  If TARGET_BPABI is true,\n    then TARGET_AAPCS_BASED must be true -- but the converse does not\n@@ -403,6 +435,12 @@ extern int arm_arch5e;\n /* Nonzero if this chip supports the ARM Architecture 6 extensions.  */\n extern int arm_arch6;\n \n+/* Nonzero if this chip supports the ARM Architecture 6k extensions.  */\n+extern int arm_arch6k;\n+\n+/* Nonzero if this chip supports the ARM Architecture 7 extensions.  */\n+extern int arm_arch7;\n+\n /* Nonzero if instructions not present in the 'M' profile can be used.  */\n extern int arm_arch_notm;\n "}, {"sha": "3771b9164e7cdd2bdaedeec33e9bc45b3ce39963", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029e79eb866ef889c1eb3b91d547263e7b8d1c60/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029e79eb866ef889c1eb3b91d547263e7b8d1c60/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=029e79eb866ef889c1eb3b91d547263e7b8d1c60", "patch": "@@ -103,6 +103,7 @@\n    (UNSPEC_RBIT 26)       ; rbit operation.\n    (UNSPEC_SYMBOL_OFFSET 27) ; The offset of the start of the symbol from\n                              ; another symbolic address.\n+   (UNSPEC_MEMORY_BARRIER 28) ; Represent a memory barrier.\n   ]\n )\n \n@@ -137,6 +138,11 @@\n    (VUNSPEC_WCMP_GT  14) ; Used by the iwMMXT WCMPGT instructions\n    (VUNSPEC_EH_RETURN 20); Use to override the return address for exception\n \t\t\t ; handling.\n+   (VUNSPEC_SYNC_COMPARE_AND_SWAP 21)\t; Represent an atomic compare swap.\n+   (VUNSPEC_SYNC_LOCK             22)\t; Represent a sync_lock_test_and_set.\n+   (VUNSPEC_SYNC_OP               23)\t; Represent a sync_<op>\n+   (VUNSPEC_SYNC_NEW_OP           24)\t; Represent a sync_new_<op>\n+   (VUNSPEC_SYNC_OLD_OP           25)\t; Represent a sync_old_<op>\n   ]\n )\n \f\n@@ -164,8 +170,21 @@\n (define_attr \"fpu\" \"none,fpa,fpe2,fpe3,maverick,vfp\"\n   (const (symbol_ref \"arm_fpu_attr\")))\n \n+(define_attr \"sync_result\"          \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_memory\"          \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_required_value\"  \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_new_value\"       \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_t1\"              \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_t2\"              \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_release_barrier\" \"yes,no\"           (const_string \"yes\"))\n+(define_attr \"sync_op\"              \"none,add,sub,ior,xor,and,nand\"\n+                                    (const_string \"none\"))\n+\n ; LENGTH of an instruction (in bytes)\n-(define_attr \"length\" \"\" (const_int 4))\n+(define_attr \"length\" \"\"\n+  (cond [(not (eq_attr \"sync_memory\" \"none\"))\n+ \t   (symbol_ref \"arm_sync_loop_insns (insn, operands) * 4\")\n+\t] (const_int 4)))\n \n ; The architecture which supports the instruction (or alternative).\n ; This can be \"a\" for ARM, \"t\" for either of the Thumbs, \"32\" for\n@@ -10657,4 +10676,5 @@\n (include \"thumb2.md\")\n ;; Neon patterns\n (include \"neon.md\")\n-\n+;; Synchronization Primitives\n+(include \"sync.md\")"}, {"sha": "7fd38d75484d3d9bdff69c458c2938fd4c41a5cf", "filename": "gcc/config/arm/sync.md", "status": "added", "additions": 594, "deletions": 0, "changes": 594, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029e79eb866ef889c1eb3b91d547263e7b8d1c60/gcc%2Fconfig%2Farm%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029e79eb866ef889c1eb3b91d547263e7b8d1c60/gcc%2Fconfig%2Farm%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsync.md?ref=029e79eb866ef889c1eb3b91d547263e7b8d1c60", "patch": "@@ -0,0 +1,594 @@\n+;; Machine description for ARM processor synchronization primitives.\n+;; Copyright (C) 2010 Free Software Foundation, Inc.\n+;; Written by Marcus Shawcroft (marcus.shawcroft@arm.com)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+;; ARMV6 introduced ldrex and strex instruction. These instruction\n+;; access SI width data. In order to implement synchronization\n+;; primitives for the narrower QI and HI modes we insert appropriate\n+;; AND/OR sequences into the synchronization loop to mask out the\n+;; relevant component of an SI access.\n+\n+(define_expand \"memory_barrier\"\n+  [(set (match_dup 0)\n+\t(unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]\n+  \"TARGET_HAVE_MEMORY_BARRIER\"\n+{\n+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n+  MEM_VOLATILE_P (operands[0]) = 1;\n+})\n+\n+(define_expand \"sync_compare_and_swapsi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\")\n+        (unspec_volatile:SI [(match_operand:SI 1 \"memory_operand\")\n+\t\t\t     (match_operand:SI 2 \"s_register_operand\")\n+\t\t\t     (match_operand:SI 3 \"s_register_operand\")]\n+\t\t\t     VUNSPEC_SYNC_COMPARE_AND_SWAP))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omrn;\n+    generator.u.omrn = gen_arm_sync_compare_and_swapsi;\n+    arm_expand_sync (SImode, &generator, operands[0], operands[1], operands[2],\n+                     operands[3]);\n+    DONE;\n+  })\n+\n+(define_mode_iterator NARROW [QI HI])\n+\n+(define_expand \"sync_compare_and_swap<mode>\"\n+  [(set (match_operand:NARROW 0 \"s_register_operand\")\n+        (unspec_volatile:NARROW [(match_operand:NARROW 1 \"memory_operand\")\n+\t\t\t     (match_operand:NARROW 2 \"s_register_operand\")\n+\t\t\t     (match_operand:NARROW 3 \"s_register_operand\")]\n+\t\t\t     VUNSPEC_SYNC_COMPARE_AND_SWAP))]\n+  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omrn;\n+    generator.u.omrn = gen_arm_sync_compare_and_swap<mode>;\n+    arm_expand_sync (<MODE>mode, &generator, operands[0], operands[1],\n+                     operands[2], operands[3]);\n+    DONE;\n+  })\n+\n+(define_expand \"sync_lock_test_and_setsi\"\n+  [(match_operand:SI 0 \"s_register_operand\")\n+   (match_operand:SI 1 \"memory_operand\")\n+   (match_operand:SI 2 \"s_register_operand\")]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_lock_test_and_setsi;\n+    arm_expand_sync (SImode, &generator, operands[0], operands[1], NULL,\n+                     operands[2]);\n+    DONE;\n+  })\n+\n+(define_expand \"sync_lock_test_and_set<mode>\"\n+  [(match_operand:NARROW 0 \"s_register_operand\")\n+   (match_operand:NARROW 1 \"memory_operand\")\n+   (match_operand:NARROW 2 \"s_register_operand\")]\n+  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_lock_test_and_set<mode>;\n+    arm_expand_sync (<MODE>mode, &generator, operands[0], operands[1], NULL,\n+                     operands[2]);\n+    DONE;\n+  })\n+\n+(define_code_iterator syncop [plus minus ior xor and])\n+\n+(define_code_attr sync_optab [(ior \"ior\")\n+\t\t\t      (xor \"xor\")\n+\t\t\t      (and \"and\")\n+\t\t\t      (plus \"add\")\n+\t\t\t      (minus \"sub\")])\n+\n+(define_expand \"sync_<sync_optab>si\"\n+  [(match_operand:SI 0 \"memory_operand\")\n+   (match_operand:SI 1 \"s_register_operand\")\n+   (syncop:SI (match_dup 0) (match_dup 1))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_new_<sync_optab>si;\n+    arm_expand_sync (SImode, &generator, NULL, operands[0], NULL, operands[1]);\n+    DONE;\n+  })\n+\n+(define_expand \"sync_nandsi\"\n+  [(match_operand:SI 0 \"memory_operand\")\n+   (match_operand:SI 1 \"s_register_operand\")\n+   (not:SI (and:SI (match_dup 0) (match_dup 1)))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_new_nandsi;\n+    arm_expand_sync (SImode, &generator, NULL, operands[0], NULL, operands[1]);\n+    DONE;\n+  })\n+\n+(define_expand \"sync_<sync_optab><mode>\"\n+  [(match_operand:NARROW 0 \"memory_operand\")\n+   (match_operand:NARROW 1 \"s_register_operand\")\n+   (syncop:NARROW (match_dup 0) (match_dup 1))]\n+  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_new_<sync_optab><mode>;\n+    arm_expand_sync (<MODE>mode, &generator, NULL, operands[0], NULL,\n+    \t\t     operands[1]);\n+    DONE;\n+  })\n+\n+(define_expand \"sync_nand<mode>\"\n+  [(match_operand:NARROW 0 \"memory_operand\")\n+   (match_operand:NARROW 1 \"s_register_operand\")\n+   (not:NARROW (and:NARROW (match_dup 0) (match_dup 1)))]\n+  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_new_nand<mode>;\n+    arm_expand_sync (<MODE>mode, &generator, NULL, operands[0], NULL,\n+                     operands[1]);\n+    DONE;\n+  })\n+\n+(define_expand \"sync_new_<sync_optab>si\"\n+  [(match_operand:SI 0 \"s_register_operand\")\n+   (match_operand:SI 1 \"memory_operand\")\n+   (match_operand:SI 2 \"s_register_operand\")\n+   (syncop:SI (match_dup 1) (match_dup 2))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_new_<sync_optab>si;\n+    arm_expand_sync (SImode, &generator, operands[0], operands[1], NULL,\n+                     operands[2]);\n+    DONE;\n+  })\n+\n+(define_expand \"sync_new_nandsi\"\n+  [(match_operand:SI 0 \"s_register_operand\")\n+   (match_operand:SI 1 \"memory_operand\")\n+   (match_operand:SI 2 \"s_register_operand\")\n+   (not:SI (and:SI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_new_nandsi;\n+    arm_expand_sync (SImode, &generator, operands[0], operands[1], NULL,\n+    \t\t     operands[2]);\n+    DONE;\n+  })\n+\n+(define_expand \"sync_new_<sync_optab><mode>\"\n+  [(match_operand:NARROW 0 \"s_register_operand\")\n+   (match_operand:NARROW 1 \"memory_operand\")\n+   (match_operand:NARROW 2 \"s_register_operand\")\n+   (syncop:NARROW (match_dup 1) (match_dup 2))]\n+  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_new_<sync_optab><mode>;\n+    arm_expand_sync (<MODE>mode, &generator, operands[0], operands[1],\n+    \t\t     NULL, operands[2]);\n+    DONE;\n+  })\n+\n+(define_expand \"sync_new_nand<mode>\"\n+  [(match_operand:NARROW 0 \"s_register_operand\")\n+   (match_operand:NARROW 1 \"memory_operand\")\n+   (match_operand:NARROW 2 \"s_register_operand\")\n+   (not:NARROW (and:NARROW (match_dup 1) (match_dup 2)))]\n+  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_new_nand<mode>;\n+    arm_expand_sync (<MODE>mode, &generator, operands[0], operands[1],\n+    \t\t     NULL, operands[2]);\n+    DONE;\n+  });\n+\n+(define_expand \"sync_old_<sync_optab>si\"\n+  [(match_operand:SI 0 \"s_register_operand\")\n+   (match_operand:SI 1 \"memory_operand\")\n+   (match_operand:SI 2 \"s_register_operand\")\n+   (syncop:SI (match_dup 1) (match_dup 2))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_old_<sync_optab>si;\n+    arm_expand_sync (SImode, &generator, operands[0], operands[1], NULL,\n+                     operands[2]);\n+    DONE;\n+  })\n+\n+(define_expand \"sync_old_nandsi\"\n+  [(match_operand:SI 0 \"s_register_operand\")\n+   (match_operand:SI 1 \"memory_operand\")\n+   (match_operand:SI 2 \"s_register_operand\")\n+   (not:SI (and:SI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_old_nandsi;\n+    arm_expand_sync (SImode, &generator, operands[0], operands[1], NULL,\n+                     operands[2]);\n+    DONE;\n+  })\n+\n+(define_expand \"sync_old_<sync_optab><mode>\"\n+  [(match_operand:NARROW 0 \"s_register_operand\")\n+   (match_operand:NARROW 1 \"memory_operand\")\n+   (match_operand:NARROW 2 \"s_register_operand\")\n+   (syncop:NARROW (match_dup 1) (match_dup 2))]\n+  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_old_<sync_optab><mode>;\n+    arm_expand_sync (<MODE>mode, &generator, operands[0], operands[1],\n+    \t\t     NULL, operands[2]);\n+    DONE;\n+  })\n+\n+(define_expand \"sync_old_nand<mode>\"\n+  [(match_operand:NARROW 0 \"s_register_operand\")\n+   (match_operand:NARROW 1 \"memory_operand\")\n+   (match_operand:NARROW 2 \"s_register_operand\")\n+   (not:NARROW (and:NARROW (match_dup 1) (match_dup 2)))]\n+  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    struct arm_sync_generator generator;\n+    generator.op = arm_sync_generator_omn;\n+    generator.u.omn = gen_arm_sync_old_nand<mode>;\n+    arm_expand_sync (<MODE>mode, &generator, operands[0], operands[1],\n+                     NULL, operands[2]);\n+    DONE;\n+  })\n+\n+(define_insn \"arm_sync_compare_and_swapsi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+        (unspec_volatile:SI\n+\t  [(match_operand:SI 1 \"memory_operand\" \"+m\")\n+   \t   (match_operand:SI 2 \"s_register_operand\" \"r\")\n+\t   (match_operand:SI 3 \"s_register_operand\" \"r\")]\n+\t  VUNSPEC_SYNC_COMPARE_AND_SWAP))\n+   (set (match_dup 1) (unspec_volatile:SI [(match_dup 2)]\n+                                          VUNSPEC_SYNC_COMPARE_AND_SWAP))\n+   (clobber:SI (match_scratch:SI 4 \"=&r\"))\n+   (set (reg:CC CC_REGNUM) (unspec_volatile:CC [(match_dup 1)]\n+                                                VUNSPEC_SYNC_COMPARE_AND_SWAP))\n+   ]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    return arm_output_sync_insn (insn, operands);\n+  } \n+  [(set_attr \"sync_result\"          \"0\")\n+   (set_attr \"sync_memory\"          \"1\")\n+   (set_attr \"sync_required_value\"  \"2\")\n+   (set_attr \"sync_new_value\"       \"3\")\n+   (set_attr \"sync_t1\"              \"0\")\n+   (set_attr \"sync_t2\"              \"4\")\n+   (set_attr \"conds\" \"nocond\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"arm_sync_compare_and_swap<mode>\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+        (zero_extend:SI\n+\t  (unspec_volatile:NARROW\n+\t    [(match_operand:NARROW 1 \"memory_operand\" \"+m\")\n+   \t     (match_operand:SI 2 \"s_register_operand\" \"r\")\n+\t     (match_operand:SI 3 \"s_register_operand\" \"r\")]\n+\t    VUNSPEC_SYNC_COMPARE_AND_SWAP)))\n+   (set (match_dup 1) (unspec_volatile:NARROW [(match_dup 2)]\n+                                          VUNSPEC_SYNC_COMPARE_AND_SWAP))\n+   (clobber:SI (match_scratch:SI 4 \"=&r\"))\n+   (set (reg:CC CC_REGNUM) (unspec_volatile:CC [(match_dup 1)]\n+                                                VUNSPEC_SYNC_COMPARE_AND_SWAP))\n+   ]\n+  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    return arm_output_sync_insn (insn, operands);\n+  } \n+  [(set_attr \"sync_result\"          \"0\")\n+   (set_attr \"sync_memory\"          \"1\")\n+   (set_attr \"sync_required_value\"  \"2\")\n+   (set_attr \"sync_new_value\"       \"3\")\n+   (set_attr \"sync_t1\"              \"0\")\n+   (set_attr \"sync_t2\"              \"4\")\n+   (set_attr \"conds\" \"nocond\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"arm_sync_lock_test_and_setsi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+        (match_operand:SI 1 \"memory_operand\" \"+m\"))\n+   (set (match_dup 1)\n+        (unspec_volatile:SI [(match_operand:SI 2 \"s_register_operand\" \"r\")]\n+\t                    VUNSPEC_SYNC_LOCK))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    return arm_output_sync_insn (insn, operands);\n+  } \n+  [(set_attr \"sync_release_barrier\" \"no\")\n+   (set_attr \"sync_result\"          \"0\")\n+   (set_attr \"sync_memory\"          \"1\")\n+   (set_attr \"sync_new_value\"       \"2\")\n+   (set_attr \"sync_t1\"              \"0\")\n+   (set_attr \"sync_t2\"              \"3\")\n+   (set_attr \"conds\" \"nocond\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"arm_sync_lock_test_and_set<mode>\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+        (zero_extend:SI (match_operand:NARROW 1 \"memory_operand\" \"+m\")))\n+   (set (match_dup 1)\n+        (unspec_volatile:NARROW [(match_operand:SI 2 \"s_register_operand\" \"r\")]\n+\t                        VUNSPEC_SYNC_LOCK))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    return arm_output_sync_insn (insn, operands);\n+  } \n+  [(set_attr \"sync_release_barrier\" \"no\")\n+   (set_attr \"sync_result\"          \"0\")\n+   (set_attr \"sync_memory\"          \"1\")\n+   (set_attr \"sync_new_value\"       \"2\")\n+   (set_attr \"sync_t1\"              \"0\")\n+   (set_attr \"sync_t2\"              \"3\")\n+   (set_attr \"conds\" \"nocond\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"arm_sync_new_<sync_optab>si\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+        (unspec_volatile:SI [(syncop:SI\n+                               (match_operand:SI 1 \"memory_operand\" \"+m\")\n+                               (match_operand:SI 2 \"s_register_operand\" \"r\"))\n+\t                    ]\n+\t                    VUNSPEC_SYNC_NEW_OP))\n+   (set (match_dup 1)\n+        (unspec_volatile:SI [(match_dup 1) (match_dup 2)]\n+\t                    VUNSPEC_SYNC_NEW_OP))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    return arm_output_sync_insn (insn, operands);\n+  } \n+  [(set_attr \"sync_result\"          \"0\")\n+   (set_attr \"sync_memory\"          \"1\")\n+   (set_attr \"sync_new_value\"       \"2\")\n+   (set_attr \"sync_t1\"              \"0\")\n+   (set_attr \"sync_t2\"              \"3\")\n+   (set_attr \"sync_op\"              \"<sync_optab>\")\n+   (set_attr \"conds\" \"nocond\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"arm_sync_new_nandsi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+        (unspec_volatile:SI [(not:SI (and:SI\n+                               (match_operand:SI 1 \"memory_operand\" \"+m\")\n+                               (match_operand:SI 2 \"s_register_operand\" \"r\")))\n+\t                    ]\n+\t                    VUNSPEC_SYNC_NEW_OP))\n+   (set (match_dup 1)\n+        (unspec_volatile:SI [(match_dup 1) (match_dup 2)]\n+\t                    VUNSPEC_SYNC_NEW_OP))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    return arm_output_sync_insn (insn, operands);\n+  } \n+  [(set_attr \"sync_result\"          \"0\")\n+   (set_attr \"sync_memory\"          \"1\")\n+   (set_attr \"sync_new_value\"       \"2\")\n+   (set_attr \"sync_t1\"              \"0\")\n+   (set_attr \"sync_t2\"              \"3\")\n+   (set_attr \"sync_op\"              \"nand\")\n+   (set_attr \"conds\" \"nocond\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"arm_sync_new_<sync_optab><mode>\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+        (unspec_volatile:SI [(syncop:SI\n+                               (zero_extend:SI\n+\t\t\t         (match_operand:NARROW 1 \"memory_operand\" \"+m\"))\n+                               (match_operand:SI 2 \"s_register_operand\" \"r\"))\n+\t                    ]\n+\t                    VUNSPEC_SYNC_NEW_OP))\n+   (set (match_dup 1)\n+        (unspec_volatile:NARROW [(match_dup 1) (match_dup 2)]\n+\t                        VUNSPEC_SYNC_NEW_OP))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    return arm_output_sync_insn (insn, operands);\n+  } \n+  [(set_attr \"sync_result\"          \"0\")\n+   (set_attr \"sync_memory\"          \"1\")\n+   (set_attr \"sync_new_value\"       \"2\")\n+   (set_attr \"sync_t1\"              \"0\")\n+   (set_attr \"sync_t2\"              \"3\")\n+   (set_attr \"sync_op\"              \"<sync_optab>\")\n+   (set_attr \"conds\" \"nocond\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"arm_sync_new_nand<mode>\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+        (unspec_volatile:SI\n+\t  [(not:SI\n+\t     (and:SI\n+               (zero_extend:SI\t  \n+\t         (match_operand:NARROW 1 \"memory_operand\" \"+m\"))\n+               (match_operand:SI 2 \"s_register_operand\" \"r\")))\n+\t  ] VUNSPEC_SYNC_NEW_OP))\n+   (set (match_dup 1)\n+        (unspec_volatile:NARROW [(match_dup 1) (match_dup 2)]\n+\t                        VUNSPEC_SYNC_NEW_OP))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    return arm_output_sync_insn (insn, operands);\n+  } \n+  [(set_attr \"sync_result\"          \"0\")\n+   (set_attr \"sync_memory\"          \"1\")\n+   (set_attr \"sync_new_value\"       \"2\")\n+   (set_attr \"sync_t1\"              \"0\")\n+   (set_attr \"sync_t2\"              \"3\")\n+   (set_attr \"sync_op\"              \"nand\")\n+   (set_attr \"conds\" \"nocond\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"arm_sync_old_<sync_optab>si\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+        (unspec_volatile:SI [(syncop:SI\n+                               (match_operand:SI 1 \"memory_operand\" \"+m\")\n+                               (match_operand:SI 2 \"s_register_operand\" \"r\"))\n+\t                    ]\n+\t                    VUNSPEC_SYNC_OLD_OP))\n+   (set (match_dup 1)\n+        (unspec_volatile:SI [(match_dup 1) (match_dup 2)]\n+\t                    VUNSPEC_SYNC_OLD_OP))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    return arm_output_sync_insn (insn, operands);\n+  } \n+  [(set_attr \"sync_result\"          \"0\")\n+   (set_attr \"sync_memory\"          \"1\")\n+   (set_attr \"sync_new_value\"       \"2\")\n+   (set_attr \"sync_t1\"              \"3\")\n+   (set_attr \"sync_t2\"              \"4\")\n+   (set_attr \"sync_op\"              \"<sync_optab>\")\n+   (set_attr \"conds\" \"nocond\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"arm_sync_old_nandsi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+        (unspec_volatile:SI [(not:SI (and:SI\n+                               (match_operand:SI 1 \"memory_operand\" \"+m\")\n+                               (match_operand:SI 2 \"s_register_operand\" \"r\")))\n+\t                    ]\n+\t                    VUNSPEC_SYNC_OLD_OP))\n+   (set (match_dup 1)\n+        (unspec_volatile:SI [(match_dup 1) (match_dup 2)]\n+\t                    VUNSPEC_SYNC_OLD_OP))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"TARGET_HAVE_LDREX && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    return arm_output_sync_insn (insn, operands);\n+  } \n+  [(set_attr \"sync_result\"          \"0\")\n+   (set_attr \"sync_memory\"          \"1\")\n+   (set_attr \"sync_new_value\"       \"2\")\n+   (set_attr \"sync_t1\"              \"3\")\n+   (set_attr \"sync_t2\"              \"4\")\n+   (set_attr \"sync_op\"              \"nand\")\n+   (set_attr \"conds\" \"nocond\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"arm_sync_old_<sync_optab><mode>\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+        (unspec_volatile:SI [(syncop:SI\n+                               (zero_extend:SI\n+\t\t\t         (match_operand:NARROW 1 \"memory_operand\" \"+m\"))\n+                               (match_operand:SI 2 \"s_register_operand\" \"r\"))\n+\t                    ]\n+\t                    VUNSPEC_SYNC_OLD_OP))\n+   (set (match_dup 1)\n+        (unspec_volatile:NARROW [(match_dup 1) (match_dup 2)]\n+\t                    VUNSPEC_SYNC_OLD_OP))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    return arm_output_sync_insn (insn, operands);\n+  } \n+  [(set_attr \"sync_result\"          \"0\")\n+   (set_attr \"sync_memory\"          \"1\")\n+   (set_attr \"sync_new_value\"       \"2\")\n+   (set_attr \"sync_t1\"              \"3\")\n+   (set_attr \"sync_t2\"              \"4\")\n+   (set_attr \"sync_op\"              \"<sync_optab>\")\n+   (set_attr \"conds\" \"nocond\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"arm_sync_old_nand<mode>\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r\")\n+        (unspec_volatile:SI [(not:SI (and:SI\n+                               (zero_extend:SI\n+\t\t\t         (match_operand:NARROW 1 \"memory_operand\" \"+m\"))\n+                               (match_operand:SI 2 \"s_register_operand\" \"r\")))\n+\t                    ]\n+\t                    VUNSPEC_SYNC_OLD_OP))\n+   (set (match_dup 1)\n+        (unspec_volatile:NARROW [(match_dup 1) (match_dup 2)]\n+\t                    VUNSPEC_SYNC_OLD_OP))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 3 \"=&r\"))\n+   (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"TARGET_HAVE_LDREXBHD && TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    return arm_output_sync_insn (insn, operands);\n+  } \n+  [(set_attr \"sync_result\"          \"0\")\n+   (set_attr \"sync_memory\"          \"1\")\n+   (set_attr \"sync_new_value\"       \"2\")\n+   (set_attr \"sync_t1\"              \"3\")\n+   (set_attr \"sync_t2\"              \"4\")\n+   (set_attr \"sync_op\"              \"nand\")\n+   (set_attr \"conds\" \"nocond\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_insn \"*memory_barrier\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]\n+  \"TARGET_HAVE_MEMORY_BARRIER\"\n+  {\n+    return arm_output_memory_barrier (operands);\n+  }\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"conds\" \"unconditional\")\n+   (set_attr \"predicable\" \"no\")])\n+"}]}