{"sha": "0ea37ae178ba156ec9f88134acc4bb13665c56ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVhMzdhZTE3OGJhMTU2ZWM5Zjg4MTM0YWNjNGJiMTM2NjVjNTZlZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-05-10T15:56:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-05-10T15:56:09Z"}, "message": "PR c++/79549 - C++17 ICE with non-type auto template parameter pack\n\n\t* pt.c (convert_template_argument): Just return an argument pack.\n\t(coerce_template_parameter_pack, template_parm_to_arg)\n\t(extract_fnparm_pack, make_argument_pack, tsubst_template_args)\n\t(tsubst_decl, tsubst, type_unification_real, unify_pack_expansion):\n\tDon't set the type of a NONTYPE_ARGUMENT_PACK.\n\t* parser.c (make_char_string_pack, make_string_pack): Likewise.\n\nFrom-SVN: r247842", "tree": {"sha": "ed45be60fa03a16ede91e72e7a2457450d6bdbc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed45be60fa03a16ede91e72e7a2457450d6bdbc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ea37ae178ba156ec9f88134acc4bb13665c56ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ea37ae178ba156ec9f88134acc4bb13665c56ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ea37ae178ba156ec9f88134acc4bb13665c56ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ea37ae178ba156ec9f88134acc4bb13665c56ef/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5562ebfc6456b545c500b7d22ea8bceb446fb9fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5562ebfc6456b545c500b7d22ea8bceb446fb9fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5562ebfc6456b545c500b7d22ea8bceb446fb9fc"}], "stats": {"total": 92, "additions": 26, "deletions": 66}, "files": [{"sha": "45ef8d3904c52f538b4ebe6b9f04f8b19ffb540f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ea37ae178ba156ec9f88134acc4bb13665c56ef/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ea37ae178ba156ec9f88134acc4bb13665c56ef/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0ea37ae178ba156ec9f88134acc4bb13665c56ef", "patch": "@@ -1,3 +1,13 @@\n+2017-05-10  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/79549 - C++17 ICE with non-type auto template parameter pack\n+\t* pt.c (convert_template_argument): Just return an argument pack.\n+\t(coerce_template_parameter_pack, template_parm_to_arg)\n+\t(extract_fnparm_pack, make_argument_pack, tsubst_template_args)\n+\t(tsubst_decl, tsubst, type_unification_real, unify_pack_expansion):\n+\tDon't set the type of a NONTYPE_ARGUMENT_PACK.\n+\t* parser.c (make_char_string_pack, make_string_pack): Likewise.\n+\n 2017-05-10  Nathan Sidwell  <nathan@acm.org>\n \n \t* cp-tree.h (add_method, clone_function_decl): Change last arg to"}, {"sha": "17d26797917d57bc1bf94f60dc00f0fa4fd80c77", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ea37ae178ba156ec9f88134acc4bb13665c56ef/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ea37ae178ba156ec9f88134acc4bb13665c56ef/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0ea37ae178ba156ec9f88134acc4bb13665c56ef", "patch": "@@ -4150,7 +4150,6 @@ make_char_string_pack (tree value)\n \n   /* Build the argument packs.  */\n   SET_ARGUMENT_PACK_ARGS (argpack, charvec);\n-  TREE_TYPE (argpack) = char_type_node;\n \n   TREE_VEC_ELT (argvec, 0) = argpack;\n \n@@ -4186,7 +4185,6 @@ make_string_pack (tree value)\n \n   /* Build the argument packs.  */\n   SET_ARGUMENT_PACK_ARGS (argpack, charvec);\n-  TREE_TYPE (argpack) = str_char_type_node;\n \n   TREE_VEC_ELT (argvec, 1) = argpack;\n "}, {"sha": "72256b3bd25db6d87f2f4f5036540d19a8a13d86", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 64, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ea37ae178ba156ec9f88134acc4bb13665c56ef/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ea37ae178ba156ec9f88134acc4bb13665c56ef/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0ea37ae178ba156ec9f88134acc4bb13665c56ef", "patch": "@@ -4296,7 +4296,6 @@ template_parm_to_arg (tree t)\n \t  /* Turn this argument into a NONTYPE_ARGUMENT_PACK\n \t     with a single element, which expands T.  */\n \t  tree vec = make_tree_vec (1);\n-\t  tree type = TREE_TYPE (TEMPLATE_PARM_DECL (t));\n \t  if (CHECKING_P)\n \t    SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (vec, TREE_VEC_LENGTH (vec));\n \n@@ -4305,7 +4304,6 @@ template_parm_to_arg (tree t)\n \n \t  t  = make_node (NONTYPE_ARGUMENT_PACK);\n \t  SET_ARGUMENT_PACK_ARGS (t, vec);\n-\t  TREE_TYPE (t) = type;\n \t}\n       else\n \tt = convert_from_reference (t);\n@@ -7544,13 +7542,14 @@ convert_template_argument (tree parm,\n       return error_mark_node;\n     }\n \n-  if (is_type)\n+  if (template_parameter_pack_p (parm) && ARGUMENT_PACK_P (orig_arg))\n+    /* We already did the appropriate conversion when packing args.  */\n+    val = orig_arg;\n+  else if (is_type)\n     {\n       if (requires_tmpl_type)\n \t{\n-\t  if (template_parameter_pack_p (parm) && ARGUMENT_PACK_P (orig_arg))\n-\t    val = orig_arg;\n-\t  else if (TREE_CODE (TREE_TYPE (arg)) == UNBOUND_CLASS_TEMPLATE)\n+\t  if (TREE_CODE (TREE_TYPE (arg)) == UNBOUND_CLASS_TEMPLATE)\n \t    /* The number of argument required is not known yet.\n \t       Just accept it for now.  */\n \t    val = TREE_TYPE (arg);\n@@ -7628,10 +7627,6 @@ convert_template_argument (tree parm,\n \n       if (tree a = type_uses_auto (t))\n \t{\n-\t  if (ARGUMENT_PACK_P (orig_arg))\n-\t    /* There's nothing to check for an auto argument pack.  */\n-\t    return orig_arg;\n-\n \t  t = do_auto_deduction (t, arg, a, complain, adc_unify, args);\n \t  if (t == error_mark_node)\n \t    return error_mark_node;\n@@ -7642,20 +7637,8 @@ convert_template_argument (tree parm,\n       if (invalid_nontype_parm_type_p (t, complain))\n \treturn error_mark_node;\n \n-      if (template_parameter_pack_p (parm) && ARGUMENT_PACK_P (orig_arg))\n-\t{\n-\t  if (same_type_p (t, TREE_TYPE (orig_arg)))\n-\t    val = orig_arg;\n-\t  else\n-\t    {\n-\t      /* Not sure if this is reachable, but it doesn't hurt\n-\t\t to be robust.  */\n-\t      error (\"type mismatch in nontype parameter pack\");\n-\t      val = error_mark_node;\n-\t    }\n-\t}\n-      else if (!type_dependent_expression_p (orig_arg)\n-\t       && !uses_template_parms (t))\n+      if (!type_dependent_expression_p (orig_arg)\n+\t  && !uses_template_parms (t))\n \t/* We used to call digest_init here.  However, digest_init\n \t   will report errors, which we don't want when complain\n \t   is zero.  More importantly, digest_init will try too\n@@ -7836,8 +7819,6 @@ coerce_template_parameter_pack (tree parms,\n   else\n     {\n       argument_pack = make_node (NONTYPE_ARGUMENT_PACK);\n-      TREE_TYPE (argument_pack) \n-        = tsubst (TREE_TYPE (TREE_VALUE (parm)), new_args, complain, in_decl);\n       TREE_CONSTANT (argument_pack) = 1;\n     }\n \n@@ -10832,9 +10813,7 @@ extract_fnparm_pack (tree tmpl_parm, tree *spec_p)\n   /* Collect all of the extra \"packed\" parameters into an\n      argument pack.  */\n   tree parmvec;\n-  tree parmtypevec;\n   tree argpack = make_node (NONTYPE_ARGUMENT_PACK);\n-  tree argtypepack = cxx_make_type (TYPE_ARGUMENT_PACK);\n   tree spec_parm = *spec_p;\n   int i, len;\n \n@@ -10845,18 +10824,12 @@ extract_fnparm_pack (tree tmpl_parm, tree *spec_p)\n \n   /* Fill in PARMVEC and PARMTYPEVEC with all of the parameters.  */\n   parmvec = make_tree_vec (len);\n-  parmtypevec = make_tree_vec (len);\n   spec_parm = *spec_p;\n   for (i = 0; i < len; i++, spec_parm = DECL_CHAIN (spec_parm))\n-    {\n-      TREE_VEC_ELT (parmvec, i) = spec_parm;\n-      TREE_VEC_ELT (parmtypevec, i) = TREE_TYPE (spec_parm);\n-    }\n+    TREE_VEC_ELT (parmvec, i) = spec_parm;\n \n   /* Build the argument packs.  */\n   SET_ARGUMENT_PACK_ARGS (argpack, parmvec);\n-  SET_ARGUMENT_PACK_ARGS (argtypepack, parmtypevec);\n-  TREE_TYPE (argpack) = argtypepack;\n   *spec_p = spec_parm;\n \n   return argpack;\n@@ -11596,7 +11569,6 @@ make_argument_pack (tree vec)\n   else\n     {\n       pack = make_node (NONTYPE_ARGUMENT_PACK);\n-      TREE_TYPE (pack) = TREE_TYPE (elt);\n       TREE_CONSTANT (pack) = 1;\n     }\n   SET_ARGUMENT_PACK_ARGS (pack, vec);\n@@ -11671,26 +11643,16 @@ tsubst_template_args (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n           new_arg = TYPE_P (orig_arg)\n             ? cxx_make_type (TREE_CODE (orig_arg))\n             : make_node (TREE_CODE (orig_arg));\n-          \n-          SET_ARGUMENT_PACK_ARGS (\n-            new_arg,\n-            tsubst_template_args (ARGUMENT_PACK_ARGS (orig_arg),\n-                                  args, complain, in_decl));\n \n-          if (ARGUMENT_PACK_ARGS (new_arg) == error_mark_node)\n+\t  tree pack_args = tsubst_template_args (ARGUMENT_PACK_ARGS (orig_arg),\n+\t\t\t\t\t\t args, complain, in_decl);\n+          if (pack_args == error_mark_node)\n             new_arg = error_mark_node;\n+\t  else\n+\t    SET_ARGUMENT_PACK_ARGS (new_arg, pack_args);\n \n-          if (TREE_CODE (new_arg) == NONTYPE_ARGUMENT_PACK) {\n-\t    if (type_uses_auto (TREE_TYPE (orig_arg)))\n-\t      TREE_TYPE (new_arg) = TREE_TYPE (orig_arg);\n-\t    else\n-\t      TREE_TYPE (new_arg) = tsubst (TREE_TYPE (orig_arg), args,\n-\t\t\t\t\t    complain, in_decl);\n-            TREE_CONSTANT (new_arg) = TREE_CONSTANT (orig_arg);\n-\n-            if (TREE_TYPE (new_arg) == error_mark_node)\n-              new_arg = error_mark_node;\n-          }\n+          if (TREE_CODE (new_arg) == NONTYPE_ARGUMENT_PACK)\n+\t    TREE_CONSTANT (new_arg) = TREE_CONSTANT (orig_arg);\n         }\n       else\n \tnew_arg = tsubst_template_arg (orig_arg, args, complain, in_decl);\n@@ -12634,10 +12596,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t  {\n \t    r = vec;\n \t    tree pack = make_node (NONTYPE_ARGUMENT_PACK);\n-\t    tree tpack = cxx_make_type (TYPE_ARGUMENT_PACK);\n \t    SET_ARGUMENT_PACK_ARGS (pack, vec);\n-\t    SET_ARGUMENT_PACK_ARGS (tpack, expanded_types);\n-\t    TREE_TYPE (pack) = tpack;\n \t    register_specialization (pack, t, args, false, 0);\n \t  }\n       }\n@@ -14114,11 +14073,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n         tree r;\n \n \tif (code == NONTYPE_ARGUMENT_PACK)\n-\t  {\n-\t    r = make_node (code);\n-\t    /* Set the already-substituted type.  */\n-\t    TREE_TYPE (r) = type;\n-\t  }\n+\t  r = make_node (code);\n \telse\n \t  r = cxx_make_type (code);\n \n@@ -19288,7 +19243,6 @@ type_unification_real (tree tparms,\n \t      if (TREE_CODE (tparm) == TEMPLATE_PARM_INDEX)\n \t\t{\n \t\t  arg = make_node (NONTYPE_ARGUMENT_PACK);\n-\t\t  TREE_TYPE (arg)  = TREE_TYPE (TEMPLATE_PARM_DECL (tparm));\n \t\t  TREE_CONSTANT (arg) = 1;\n \t\t}\n \t      else\n@@ -20086,8 +20040,6 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n           if (TREE_CODE (TREE_PURPOSE (pack)) == TEMPLATE_PARM_INDEX)\n             {\n               result = make_node (NONTYPE_ARGUMENT_PACK);\n-              TREE_TYPE (result) = \n-                TREE_TYPE (TEMPLATE_PARM_DECL (TREE_PURPOSE (pack)));\n               TREE_CONSTANT (result) = 1;\n             }\n           else"}]}