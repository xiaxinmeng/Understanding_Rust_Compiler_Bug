{"sha": "b5c82fa1381f4c1610f8137ede5ea6789fa90c8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVjODJmYTEzODFmNGMxNjEwZjgxMzdlZGU1ZWE2Nzg5ZmE5MGM4YQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2006-04-03T11:20:07Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2006-04-03T11:20:07Z"}, "message": "re PR target/19653 (x87 reg allocated for constants for -mfpmath=sse)\n\n2005-08-08  Paolo Bonzini  <bonzini@gnu.org>\n\t    Dale Johannesen  <dalej@apple.com>\n\n\tPR target/19653\n\t* regclass.c (struct reg_pref): Update documentation.\n\t(regclass): Set prefclass to NO_REGS if memory is the best option.\n\t(record_reg_classes): Cope with a prefclass set to NO_REGS.\n\t* reload.c (find_reloads): Take PREFERRED_OUTPUT_RELOAD_CLASS\n\tinto account.  For non-registers, equate an empty preferred\n\treload class to a `!' in the constraint; move the if clause to\n\tdo so after those that reject the insn.\n\t(push_reload): Allow PREFERRED_*_RELOAD_CLASS to liberally\n\treturn NO_REGS.\n\t(find_dummy_reload): Likewise.\n\t* doc/tm.texi (Register Classes): Document what it means\n\tif PREFERRED_*_RELOAD_CLASS return NO_REGS.\n\t* config/i386/i386.c (ix86_preferred_reload_class): Force\n\tusing SSE registers (and return NO_REGS for floating-point\n\tconstants) if math is done with SSE.\n\t(ix86_preferred_output_reload_class): New.\n\t* config/i386/i386-protos.h (ix86_preferred_output_reload_class): New.\n\t* config/i386/i386.h (PREFERRED_OUTPUT_RELOAD_CLASS): New.\n\t* config/i386/i386.md: Remove # register preferences.\n\n\nCo-Authored-By: Dale Johannesen <dalej@apple.com>\n\nFrom-SVN: r112637", "tree": {"sha": "e8c7101e8fefacd29cfe88d998da545388f1d4d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8c7101e8fefacd29cfe88d998da545388f1d4d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f096660b460d13d3a4f511071de80085300b4af9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f096660b460d13d3a4f511071de80085300b4af9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f096660b460d13d3a4f511071de80085300b4af9"}], "stats": {"total": 276, "additions": 191, "deletions": 85}, "files": [{"sha": "ebf0227b0db5d7cd19486d2bb68f5a55f61ac4c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5c82fa1381f4c1610f8137ede5ea6789fa90c8a", "patch": "@@ -1,3 +1,27 @@\n+2005-08-08  Paolo Bonzini  <bonzini@gnu.org>\n+\t    Dale Johannesen  <dalej@apple.com>\n+\n+\tPR target/19653\n+\t* regclass.c (struct reg_pref): Update documentation.\n+\t(regclass): Set prefclass to NO_REGS if memory is the best option.\n+\t(record_reg_classes): Cope with a prefclass set to NO_REGS.\n+\t* reload.c (find_reloads): Take PREFERRED_OUTPUT_RELOAD_CLASS\n+\tinto account.  For non-registers, equate an empty preferred\n+\treload class to a `!' in the constraint; move the if clause to\n+\tdo so after those that reject the insn.\n+\t(push_reload): Allow PREFERRED_*_RELOAD_CLASS to liberally\n+\treturn NO_REGS.\n+\t(find_dummy_reload): Likewise.\n+\t* doc/tm.texi (Register Classes): Document what it means\n+\tif PREFERRED_*_RELOAD_CLASS return NO_REGS.\n+\t* config/i386/i386.c (ix86_preferred_reload_class): Force\n+\tusing SSE registers (and return NO_REGS for floating-point\n+\tconstants) if math is done with SSE.\n+\t(ix86_preferred_output_reload_class): New.\n+\t* config/i386/i386-protos.h (ix86_preferred_output_reload_class): New.\n+\t* config/i386/i386.h (PREFERRED_OUTPUT_RELOAD_CLASS): New.\n+\t* config/i386/i386.md: Remove # register preferences.\n+\n 2006-04-02  Sebastian Pop  <pop@cri.ensmp.fr>\n \n \tPR bootstrap/26992"}, {"sha": "315487e8fd479da4074feb2972967e4f436b81e2", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=b5c82fa1381f4c1610f8137ede5ea6789fa90c8a", "patch": "@@ -142,6 +142,7 @@ extern int ix86_secondary_memory_needed (enum reg_class, enum reg_class,\n extern bool ix86_cannot_change_mode_class (enum machine_mode,\n \t\t\t\t\t   enum machine_mode, enum reg_class);\n extern enum reg_class ix86_preferred_reload_class (rtx, enum reg_class);\n+extern enum reg_class ix86_preferred_output_reload_class (rtx, enum reg_class);\n extern int ix86_memory_move_cost (enum machine_mode, enum reg_class, int);\n extern int ix86_mode_needed (int, rtx);\n extern void emit_i387_cw_initialization (int);"}, {"sha": "84b19b9dac2b6105f055e348c7357ee98256f8dd", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b5c82fa1381f4c1610f8137ede5ea6789fa90c8a", "patch": "@@ -16361,15 +16361,28 @@ ix86_free_from_memory (enum machine_mode mode)\n enum reg_class\n ix86_preferred_reload_class (rtx x, enum reg_class class)\n {\n+  enum machine_mode mode = GET_MODE (x);\n+\n   /* We're only allowed to return a subclass of CLASS.  Many of the \n      following checks fail for NO_REGS, so eliminate that early.  */\n   if (class == NO_REGS)\n     return NO_REGS;\n \n   /* All classes can load zeros.  */\n-  if (x == CONST0_RTX (GET_MODE (x)))\n+  if (x == CONST0_RTX (mode))\n     return class;\n \n+  /* Force constants into memory if we are loading a (non-zero) constant into\n+     an MMX or SSE register.  This is because there are no MMX/SSE instructions\n+     to load from a constant.  */\n+  if (CONSTANT_P (x)\n+      && (MAYBE_MMX_CLASS_P (class) || MAYBE_SSE_CLASS_P (class)))\n+    return NO_REGS;\n+\n+  /* Prefer SSE regs only, if we can use them for math.  */\n+  if (TARGET_SSE_MATH && !TARGET_MIX_SSE_I387 && SSE_FLOAT_MODE_P (mode))\n+    return SSE_CLASS_P (class) ? class : NO_REGS;\n+\n   /* Floating-point constants need more complex checks.  */\n   if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) != VOIDmode)\n     {\n@@ -16381,8 +16394,6 @@ ix86_preferred_reload_class (rtx x, enum reg_class class)\n \t zero above.  We only want to wind up preferring 80387 registers if\n \t we plan on doing computation with them.  */\n       if (TARGET_80387\n-\t  && (TARGET_MIX_SSE_I387 \n-\t      || !(TARGET_SSE_MATH && SSE_FLOAT_MODE_P (GET_MODE (x))))\n \t  && standard_80387_constant_p (x))\n \t{\n \t  /* Limit class to non-sse.  */\n@@ -16398,10 +16409,6 @@ ix86_preferred_reload_class (rtx x, enum reg_class class)\n \n       return NO_REGS;\n     }\n-  if (MAYBE_MMX_CLASS_P (class) && CONSTANT_P (x))\n-    return NO_REGS;\n-  if (MAYBE_SSE_CLASS_P (class) && CONSTANT_P (x))\n-    return NO_REGS;\n \n   /* Generally when we see PLUS here, it's the function invariant\n      (plus soft-fp const_int).  Which can only be computed into general\n@@ -16423,6 +16430,33 @@ ix86_preferred_reload_class (rtx x, enum reg_class class)\n   return class;\n }\n \n+/* Discourage putting floating-point values in SSE registers unless\n+   SSE math is being used, and likewise for the 387 registers.  */\n+enum reg_class\n+ix86_preferred_output_reload_class (rtx x, enum reg_class class)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  /* Restrict the output reload class to the register bank that we are doing\n+     math on.  If we would like not to return a subset of CLASS, reject this\n+     alternative: if reload cannot do this, it will still use its choice.  */\n+  mode = GET_MODE (x);\n+  if (TARGET_SSE_MATH && SSE_FLOAT_MODE_P (mode))\n+    return MAYBE_SSE_CLASS_P (class) ? SSE_REGS : NO_REGS;\n+\n+  if (TARGET_80387 && SCALAR_FLOAT_MODE_P (mode))\n+    {\n+      if (class == FP_TOP_SSE_REGS)\n+\treturn FP_TOP_REG;\n+      else if (class == FP_SECOND_SSE_REGS)\n+\treturn FP_SECOND_REG;\n+      else\n+\treturn FLOAT_CLASS_P (class) ? class : NO_REGS;\n+    }\n+\n+  return class;\n+}\n+\n /* If we are copying between general and FP registers, we need a memory\n    location. The same is true for SSE and MMX registers.\n "}, {"sha": "b7839138065d2791891f2bd8a1290e02d79b8858", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=b5c82fa1381f4c1610f8137ede5ea6789fa90c8a", "patch": "@@ -669,7 +669,9 @@ extern int x86_prefetch_sse;\n \n #define STACK_REGS\n #define IS_STACK_MODE(MODE)\t\t\t\t\t\\\n-  ((MODE) == DFmode || (MODE) == SFmode || (MODE) == XFmode)\t\\\n+  (((MODE) == SFmode && (!TARGET_SSE || !TARGET_SSE_MATH))\t\\\n+   || ((MODE) == DFmode && (!TARGET_SSE2 || !TARGET_SSE_MATH))  \\\n+   || (MODE) == XFmode)\n \n /* Number of actual hardware registers.\n    The hardware registers are assigned numbers for the compiler\n@@ -1222,6 +1224,12 @@ enum reg_class\n #define PREFERRED_RELOAD_CLASS(X, CLASS) \\\n    ix86_preferred_reload_class ((X), (CLASS))\n \n+/* Discourage putting floating-point values in SSE registers unless\n+   SSE math is being used, and likewise for the 387 registers.  */\n+\n+#define PREFERRED_OUTPUT_RELOAD_CLASS(X, CLASS) \\\n+   ix86_preferred_output_reload_class ((X), (CLASS))\n+\n /* If we are copying between general and FP registers, we need a memory\n    location. The same is true for SSE and MMX registers.  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\"}, {"sha": "ef3f36b69641f3a1a26fe165ea6f8f825002a993", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b5c82fa1381f4c1610f8137ede5ea6789fa90c8a", "patch": "@@ -968,8 +968,8 @@\n \n (define_insn \"*cmpfp_i_mixed\"\n   [(set (reg:CCFP FLAGS_REG)\n-\t(compare:CCFP (match_operand 0 \"register_operand\" \"f#x,x#f\")\n-\t\t      (match_operand 1 \"nonimmediate_operand\" \"f#x,xm#f\")))]\n+\t(compare:CCFP (match_operand 0 \"register_operand\" \"f,x\")\n+\t\t      (match_operand 1 \"nonimmediate_operand\" \"f,xm\")))]\n   \"TARGET_MIX_SSE_I387\n    && SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n@@ -1017,8 +1017,8 @@\n \n (define_insn \"*cmpfp_iu_mixed\"\n   [(set (reg:CCFPU FLAGS_REG)\n-\t(compare:CCFPU (match_operand 0 \"register_operand\" \"f#x,x#f\")\n-\t\t       (match_operand 1 \"nonimmediate_operand\" \"f#x,xm#f\")))]\n+\t(compare:CCFPU (match_operand 0 \"register_operand\" \"f,x\")\n+\t\t       (match_operand 1 \"nonimmediate_operand\" \"f,xm\")))]\n   \"TARGET_MIX_SSE_I387\n    && SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n@@ -2222,7 +2222,7 @@\n \n (define_insn \"*pushsf\"\n   [(set (match_operand:SF 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:SF 1 \"general_no_elim_operand\" \"f#rx,rFm#fx,x#rf\"))]\n+\t(match_operand:SF 1 \"general_no_elim_operand\" \"f,rFm,x\"))]\n   \"!TARGET_64BIT\"\n {\n   /* Anything else should be already split before reg-stack.  */\n@@ -2235,7 +2235,7 @@\n \n (define_insn \"*pushsf_rex64\"\n   [(set (match_operand:SF 0 \"push_operand\" \"=X,X,X\")\n-\t(match_operand:SF 1 \"nonmemory_no_elim_operand\" \"f#rx,rF#fx,x#rf\"))]\n+\t(match_operand:SF 1 \"nonmemory_no_elim_operand\" \"f,rF,x\"))]\n   \"TARGET_64BIT\"\n {\n   /* Anything else should be already split before reg-stack.  */\n@@ -2274,9 +2274,9 @@\n \n (define_insn \"*movsf_1\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\"\n-\t  \"=f#xr,m   ,f#xr,r#xf  ,m    ,x#rf,x#rf,x#rf ,m   ,!*y,!rm,!*y\")\n+\t  \"=f,m   ,f,r,m    ,x,x,x,m   ,!*y,!rm,!*y\")\n \t(match_operand:SF 1 \"general_operand\"\n-\t  \"fm#rx,f#rx,G   ,rmF#fx,Fr#fx,C   ,x   ,xm#rf,x#rf,rm ,*y ,*y\"))]\n+\t  \"fm,f,G   ,rmF,Fr,C   ,x   ,xm,x,rm ,*y ,*y\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (reload_in_progress || reload_completed\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n@@ -2389,7 +2389,7 @@\n \n (define_insn \"*pushdf_nointeger\"\n   [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<,<\")\n-\t(match_operand:DF 1 \"general_no_elim_operand\" \"f#Y,Fo#fY,*r#fY,Y#f\"))]\n+\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,Fo,*r,Y\"))]\n   \"!TARGET_64BIT && !TARGET_INTEGER_DFMODE_MOVES\"\n {\n   /* This insn should be already split before reg-stack.  */\n@@ -2401,7 +2401,7 @@\n \n (define_insn \"*pushdf_integer\"\n   [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:DF 1 \"general_no_elim_operand\" \"f#rY,rFo#fY,Y#rf\"))]\n+\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,rFo,Y\"))]\n   \"TARGET_64BIT || TARGET_INTEGER_DFMODE_MOVES\"\n {\n   /* This insn should be already split before reg-stack.  */\n@@ -2441,9 +2441,9 @@\n \n (define_insn \"*movdf_nointeger\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\t\"=f#Y,m  ,f#Y,*r  ,o  ,Y*x#f,Y*x#f,Y*x#f ,m    \")\n+\t\t\t\"=f,m  ,f,*r  ,o  ,Y*x,Y*x,Y*x,m    \")\n \t(match_operand:DF 1 \"general_operand\"\n-\t\t\t\"fm#Y,f#Y,G  ,*roF,F*r,C    ,Y*x#f,mY*x#f,Y*x#f\"))]\n+\t\t\t\"fm,f,G  ,*roF,F*r,C    ,Y*x,mY*x,Y*x\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && ((optimize_size || !TARGET_INTEGER_DFMODE_MOVES) && !TARGET_64BIT)\n    && (reload_in_progress || reload_completed\n@@ -2561,9 +2561,9 @@\n \n (define_insn \"*movdf_integer\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\"=f#Yr,m   ,f#Yr,r#Yf  ,o    ,Y*x#rf,Y*x#rf,Y*x#rf,m\")\n+\t\t\"=f,m   ,f,r,o    ,Y*x,Y*x,Y*x,m\")\n \t(match_operand:DF 1 \"general_operand\"\n-\t\t\"fm#Yr,f#Yr,G   ,roF#Yf,Fr#Yf,C     ,Y*x#rf,m     ,Y*x#rf\"))]\n+\t\t\"fm,f,G   ,roF,Fr,C     ,Y*x,m     ,Y*x\"))]\n   \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && ((!optimize_size && TARGET_INTEGER_DFMODE_MOVES) || TARGET_64BIT)\n    && (reload_in_progress || reload_completed\n@@ -2736,7 +2736,7 @@\n \n (define_insn \"*pushxf_integer\"\n   [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:XF 1 \"general_no_elim_operand\" \"f#r,ro#f\"))]\n+\t(match_operand:XF 1 \"general_no_elim_operand\" \"f,ro\"))]\n   \"!optimize_size\"\n {\n   /* This insn should be already split before reg-stack.  */\n@@ -2808,8 +2808,8 @@\n    (set_attr \"mode\" \"XF,XF,XF,SI,SI\")])\n \n (define_insn \"*movxf_integer\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f#r,m,f#r,r#f,o\")\n-\t(match_operand:XF 1 \"general_operand\" \"fm#r,f#r,G,roF#f,Fr#f\"))]\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,r,o\")\n+\t(match_operand:XF 1 \"general_operand\" \"fm,f,G,roF,Fr\"))]\n   \"!optimize_size\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && (reload_in_progress || reload_completed\n@@ -3538,8 +3538,8 @@\n })\n \n (define_insn \"*extendsfdf2_mixed\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#Y,m#fY,Y#f\")\n-        (float_extend:DF (match_operand:SF 1 \"nonimmediate_operand\" \"fm#Y,f#Y,mY#f\")))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,m,Y\")\n+        (float_extend:DF (match_operand:SF 1 \"nonimmediate_operand\" \"fm,f,mY\")))]\n   \"TARGET_SSE2 && TARGET_MIX_SSE_I387\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n {\n@@ -3872,7 +3872,7 @@\n })\n \n (define_insn \"*truncxfsf2_mixed\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=m,?f#rx,?r#fx,?x#rf\")\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=m,?f,?r,?x\")\n \t(float_truncate:SF\n \t (match_operand:XF 1 \"register_operand\" \"f,f,f,f\")))\n    (clobber (match_operand:SF 2 \"memory_operand\" \"=X,m,m,m\"))]\n@@ -3899,7 +3899,7 @@\n    (set_attr \"mode\" \"SF\")])\n \n (define_insn \"*truncxfsf2_i387\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=m,?f#r,?r#f\")\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=m,?f,?r\")\n \t(float_truncate:SF\n \t (match_operand:XF 1 \"register_operand\" \"f,f,f\")))\n    (clobber (match_operand:SF 2 \"memory_operand\" \"=X,m,m\"))]\n@@ -3970,7 +3970,7 @@\n })\n \n (define_insn \"*truncxfdf2_mixed\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=m,?f#rY,?r#fY,?Y#rf\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=m,?f,?r,?Y\")\n \t(float_truncate:DF\n \t (match_operand:XF 1 \"register_operand\" \"f,f,f,f\")))\n    (clobber (match_operand:DF 2 \"memory_operand\" \"=X,m,m,m\"))]\n@@ -3997,7 +3997,7 @@\n    (set_attr \"mode\" \"DF\")])\n \n (define_insn \"*truncxfdf2_i387\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=m,?f#r,?r#f\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=m,?f,?r\")\n \t(float_truncate:DF\n \t (match_operand:XF 1 \"register_operand\" \"f,f,f\")))\n    (clobber (match_operand:DF 2 \"memory_operand\" \"=X,m,m\"))]\n@@ -4471,7 +4471,7 @@\n   \"\")\n \n (define_insn \"*floatsisf2_mixed\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f#x,?f#x,x#f,x#f\")\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,?f,x,x\")\n \t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"m,r,r,mr\")))]\n   \"TARGET_MIX_SSE_I387\"\n   \"@\n@@ -4514,7 +4514,7 @@\n   \"\")\n \n (define_insn \"*floatdisf2_mixed\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f#x,?f#x,x#f,x#f\")\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,?f,x,x\")\n \t(float:SF (match_operand:DI 1 \"nonimmediate_operand\" \"m,r,r,mr\")))]\n   \"TARGET_64BIT && TARGET_MIX_SSE_I387\"\n   \"@\n@@ -4582,7 +4582,7 @@\n   \"\")\n \n (define_insn \"*floatsidf2_mixed\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f#Y,?f#Y,Y#f,Y#f\")\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,?f,Y,Y\")\n \t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"m,r,r,mr\")))]\n   \"TARGET_SSE2 && TARGET_MIX_SSE_I387\"\n   \"@\n@@ -4625,7 +4625,7 @@\n   \"\")\n \n (define_insn \"*floatdidf2_mixed\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f#Y,?f#Y,Y#f,Y#f\")\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,?f,Y,Y\")\n \t(float:DF (match_operand:DI 1 \"nonimmediate_operand\" \"m,r,r,mr\")))]\n   \"TARGET_64BIT && TARGET_SSE2 && TARGET_MIX_SSE_I387\"\n   \"@\n@@ -9545,9 +9545,9 @@\n   \"ix86_expand_fp_absneg_operator (ABS, SFmode, operands); DONE;\")\n \n (define_insn \"*absnegsf2_mixed\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\"    \"=x#f,x#f,f#x,rm\")\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\"    \"=x,x,f,rm\")\n \t(match_operator:SF 3 \"absneg_operator\"\n-\t  [(match_operand:SF 1 \"nonimmediate_operand\" \"0   ,x#f,0  ,0\")]))\n+\t  [(match_operand:SF 1 \"nonimmediate_operand\" \"0   ,x,0  ,0\")]))\n    (use (match_operand:V4SF 2 \"nonimmediate_operand\"  \"xm  ,0  ,X  ,X\"))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_SSE_MATH && TARGET_MIX_SSE_I387\n@@ -9641,9 +9641,9 @@\n   \"ix86_expand_fp_absneg_operator (ABS, DFmode, operands); DONE;\")\n \n (define_insn \"*absnegdf2_mixed\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\"    \"=Y#f,Y#f,f#Y,rm\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\"    \"=Y,Y,f,rm\")\n \t(match_operator:DF 3 \"absneg_operator\"\n-\t  [(match_operand:DF 1 \"nonimmediate_operand\" \"0   ,Y#f,0  ,0\")]))\n+\t  [(match_operand:DF 1 \"nonimmediate_operand\" \"0   ,Y,0  ,0\")]))\n    (use (match_operand:V2DF 2 \"nonimmediate_operand\"  \"Ym  ,0  ,X  ,X\"))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_SSE2 && TARGET_SSE_MATH && TARGET_MIX_SSE_I387\n@@ -13170,8 +13170,8 @@\n (define_insn \"*fp_jcc_1_mixed\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"f#x,x#f\")\n-\t\t\t (match_operand 2 \"nonimmediate_operand\" \"f#x,xm#f\")])\n+\t\t\t[(match_operand 1 \"register_operand\" \"f,x\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"f,xm\")])\n \t  (label_ref (match_operand 3 \"\" \"\"))\n \t  (pc)))\n    (clobber (reg:CCFP FPSR_REG))\n@@ -13215,8 +13215,8 @@\n (define_insn \"*fp_jcc_2_mixed\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand 1 \"register_operand\" \"f#x,x#f\")\n-\t\t\t (match_operand 2 \"nonimmediate_operand\" \"f#x,xm#f\")])\n+\t\t\t[(match_operand 1 \"register_operand\" \"f,x\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"f,xm\")])\n \t  (pc)\n \t  (label_ref (match_operand 3 \"\" \"\"))))\n    (clobber (reg:CCFP FPSR_REG))\n@@ -14535,10 +14535,10 @@\n ;; so use special patterns for add and mull.\n \n (define_insn \"*fop_sf_comm_mixed\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f#x,x#f\")\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,x\")\n \t(match_operator:SF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm#x,xm#f\")]))]\n+\t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm,xm\")]))]\n   \"TARGET_MIX_SSE_I387\n    && COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n@@ -14587,7 +14587,7 @@\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f,x\")\n \t(match_operator:SF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"0,fm,0\")\n-\t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm,0,xm#f\")]))]\n+\t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm,0,xm\")]))]\n   \"TARGET_MIX_SSE_I387\n    && !COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n@@ -14681,10 +14681,10 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fop_df_comm_mixed\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f#Y,Y#f\")\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,Y\")\n \t(match_operator:DF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:DF 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm#Y,Ym#f\")]))]\n+\t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm,Ym\")]))]\n   \"TARGET_SSE2 && TARGET_MIX_SSE_I387\n    && COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n@@ -14730,10 +14730,10 @@\n    (set_attr \"mode\" \"DF\")])\n \n (define_insn \"*fop_df_1_mixed\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f#Y,f#Y,Y#f\")\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,Y\")\n \t(match_operator:DF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:DF 1 \"nonimmediate_operand\" \"0,fm,0\")\n-\t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm,0,Ym#f\")]))]\n+\t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm,0,Ym\")]))]\n   \"TARGET_SSE2 && TARGET_SSE_MATH && TARGET_MIX_SSE_I387\n    && !COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n@@ -15048,8 +15048,8 @@\n })\n \n (define_insn \"*sqrtsf2_mixed\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f#x,x#f\")\n-\t(sqrt:SF (match_operand:SF 1 \"nonimmediate_operand\" \"0#x,xm#f\")))]\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,x\")\n+\t(sqrt:SF (match_operand:SF 1 \"nonimmediate_operand\" \"0,xm\")))]\n   \"TARGET_USE_FANCY_MATH_387 && TARGET_MIX_SSE_I387\"\n   \"@\n    fsqrt\n@@ -15086,8 +15086,8 @@\n })\n \n (define_insn \"*sqrtdf2_mixed\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f#Y,Y#f\")\n-\t(sqrt:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0#Y,Ym#f\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,Y\")\n+\t(sqrt:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,Ym\")))]\n   \"TARGET_USE_FANCY_MATH_387 && TARGET_SSE2 && TARGET_MIX_SSE_I387\"\n   \"@\n    fsqrt\n@@ -18584,11 +18584,11 @@\n   \"if (! ix86_expand_fp_movcc (operands)) FAIL; DONE;\")\n \n (define_insn \"*movsfcc_1_387\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f#r,f#r,r#f,r#f\")\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,r,r\")\n \t(if_then_else:SF (match_operator 1 \"fcmov_comparison_operator\" \n \t\t\t\t[(reg FLAGS_REG) (const_int 0)])\n-\t\t      (match_operand:SF 2 \"nonimmediate_operand\" \"f#r,0,rm#f,0\")\n-\t\t      (match_operand:SF 3 \"nonimmediate_operand\" \"0,f#r,0,rm#f\")))]\n+\t\t      (match_operand:SF 2 \"nonimmediate_operand\" \"f,0,rm,0\")\n+\t\t      (match_operand:SF 3 \"nonimmediate_operand\" \"0,f,0,rm\")))]\n   \"TARGET_80387 && TARGET_CMOVE\n    && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\"\n   \"@\n@@ -18608,11 +18608,11 @@\n   \"if (! ix86_expand_fp_movcc (operands)) FAIL; DONE;\")\n \n (define_insn \"*movdfcc_1\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f#r,f#r,&r#f,&r#f\")\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,&r,&r\")\n \t(if_then_else:DF (match_operator 1 \"fcmov_comparison_operator\" \n \t\t\t\t[(reg FLAGS_REG) (const_int 0)])\n-\t\t      (match_operand:DF 2 \"nonimmediate_operand\" \"f#r,0,rm#f,0\")\n-\t\t      (match_operand:DF 3 \"nonimmediate_operand\" \"0,f#r,0,rm#f\")))]\n+\t\t      (match_operand:DF 2 \"nonimmediate_operand\" \"f,0,rm,0\")\n+\t\t      (match_operand:DF 3 \"nonimmediate_operand\" \"0,f,0,rm\")))]\n   \"!TARGET_64BIT && TARGET_80387 && TARGET_CMOVE\n    && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\"\n   \"@\n@@ -18624,11 +18624,11 @@\n    (set_attr \"mode\" \"DF\")])\n \n (define_insn \"*movdfcc_1_rex64\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f#r,f#r,r#f,r#f\")\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,r,r\")\n \t(if_then_else:DF (match_operator 1 \"fcmov_comparison_operator\" \n \t\t\t\t[(reg FLAGS_REG) (const_int 0)])\n-\t\t      (match_operand:DF 2 \"nonimmediate_operand\" \"f#r,0#r,rm#f,0#f\")\n-\t\t      (match_operand:DF 3 \"nonimmediate_operand\" \"0#r,f#r,0#f,rm#f\")))]\n+\t\t      (match_operand:DF 2 \"nonimmediate_operand\" \"f,0,rm,0\")\n+\t\t      (match_operand:DF 3 \"nonimmediate_operand\" \"0,f,0,rm\")))]\n   \"TARGET_64BIT && TARGET_80387 && TARGET_CMOVE\n    && (GET_CODE (operands[2]) != MEM || GET_CODE (operands[3]) != MEM)\"\n   \"@"}, {"sha": "2e7632e5a3a6c366e3e9f0b0251266bb57a6a3e2", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b5c82fa1381f4c1610f8137ede5ea6789fa90c8a", "patch": "@@ -2404,12 +2404,22 @@ register, so @code{PREFERRED_RELOAD_CLASS} returns @code{NO_REGS} when\n into any kind of register, code generation will be better if\n @code{LEGITIMATE_CONSTANT_P} makes the constant illegitimate instead\n of using @code{PREFERRED_RELOAD_CLASS}.\n+\n+If an insn has pseudos in it after register allocation, reload will go\n+through the alternatives and call repeatedly @code{PREFERRED_RELOAD_CLASS}\n+to find the best one.  Returning @code{NO_REGS}, in this case, makes\n+reload add a @code{!} in front of the constraint: the x86 back-end uses\n+this feature to discourage usage of 387 registers when math is done in\n+the SSE registers (and vice versa).\n @end defmac\n \n @defmac PREFERRED_OUTPUT_RELOAD_CLASS (@var{x}, @var{class})\n Like @code{PREFERRED_RELOAD_CLASS}, but for output reloads instead of\n input reloads.  If you don't define this macro, the default is to use\n @var{class}, unchanged.\n+\n+You can also use @code{PREFERRED_OUTPUT_RELOAD_CLASS} to discourage\n+reload from using some alternatives, like @code{PREFERRED_RELOAD_CLASS}.\n @end defmac\n \n @defmac LIMIT_RELOAD_CLASS (@var{mode}, @var{class})"}, {"sha": "1f1e6c24166d4dcdb1e6ac09b562ba31115cb0ac", "filename": "gcc/regclass.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=b5c82fa1381f4c1610f8137ede5ea6789fa90c8a", "patch": "@@ -811,7 +811,8 @@ struct costs\n /* Structure used to record preferences of given pseudo.  */\n struct reg_pref\n {\n-  /* (enum reg_class) prefclass is the preferred class.  */\n+  /* (enum reg_class) prefclass is the preferred class.  May be\n+     NO_REGS if no class is better than memory.  */\n   char prefclass;\n \n   /* altclass is a register class that we should use for allocating\n@@ -1314,6 +1315,10 @@ regclass (rtx f, int nregs)\n \t\tbest = reg_class_subunion[(int) best][class];\n \t    }\n \n+\t  /* If no register class is better than memory, use memory. */\n+\t  if (p->mem_cost < best_cost)\n+\t    best = NO_REGS;\n+\n \t  /* Record the alternate register class; i.e., a class for which\n \t     every register in it is better than using memory.  If adding a\n \t     class would make a smaller class (i.e., no union of just those\n@@ -1524,7 +1529,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     to what we would add if this register were not in the\n \t\t     appropriate class.  */\n \n-\t\t  if (reg_pref)\n+\t\t  if (reg_pref && reg_pref[REGNO (op)].prefclass != NO_REGS)\n \t\t    alt_cost\n \t\t      += (may_move_in_cost[mode]\n \t\t\t  [(unsigned char) reg_pref[REGNO (op)].prefclass]\n@@ -1750,7 +1755,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     to what we would add if this register were not in the\n \t\t     appropriate class.  */\n \n-\t\t  if (reg_pref)\n+\t\t  if (reg_pref && reg_pref[REGNO (op)].prefclass != NO_REGS)\n \t\t    alt_cost\n \t\t      += (may_move_in_cost[mode]\n \t\t\t  [(unsigned char) reg_pref[REGNO (op)].prefclass]\n@@ -1836,7 +1841,8 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t  int class;\n \t  unsigned int nr;\n \n-\t  if (regno >= FIRST_PSEUDO_REGISTER && reg_pref != 0)\n+\t  if (regno >= FIRST_PSEUDO_REGISTER && reg_pref != 0\n+\t      && reg_pref[regno].prefclass != NO_REGS)\n \t    {\n \t      enum reg_class pref = reg_pref[regno].prefclass;\n "}, {"sha": "f3023ae78b48bbee20d898919743f7b5d77417bc", "filename": "gcc/reload.c", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c82fa1381f4c1610f8137ede5ea6789fa90c8a/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=b5c82fa1381f4c1610f8137ede5ea6789fa90c8a", "patch": "@@ -1184,15 +1184,24 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \n   /* Narrow down the class of register wanted if that is\n      desirable on this machine for efficiency.  */\n-  if (in != 0)\n-    class = PREFERRED_RELOAD_CLASS (in, class);\n+  {\n+    enum reg_class preferred_class = class;\n+\n+    if (in != 0)\n+      preferred_class = PREFERRED_RELOAD_CLASS (in, class);\n \n   /* Output reloads may need analogous treatment, different in detail.  */\n #ifdef PREFERRED_OUTPUT_RELOAD_CLASS\n-  if (out != 0)\n-    class = PREFERRED_OUTPUT_RELOAD_CLASS (out, class);\n+    if (out != 0)\n+      preferred_class = PREFERRED_OUTPUT_RELOAD_CLASS (out, preferred_class);\n #endif\n \n+    /* Discard what the target said if we cannot do it.  */\n+    if (preferred_class != NO_REGS\n+\t|| (optional && type == RELOAD_FOR_OUTPUT))\n+      class = preferred_class;\n+  }\n+\n   /* Make sure we use a class that can handle the actual pseudo\n      inside any subreg.  For example, on the 386, QImode regs\n      can appear within SImode subregs.  Although GENERAL_REGS\n@@ -1885,7 +1894,11 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \n   /* Narrow down the reg class, the same way push_reload will;\n      otherwise we might find a dummy now, but push_reload won't.  */\n-  class = PREFERRED_RELOAD_CLASS (in, class);\n+  {\n+    enum reg_class preferred_class = PREFERRED_RELOAD_CLASS (in, class);\n+    if (class != NO_REGS)\n+      class = preferred_class;\n+  }\n \n   /* See if OUT will do.  */\n   if (REG_P (out)\n@@ -3401,29 +3414,39 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t    losers++;\n \t\t}\n \n-\t      /* If we can't reload this value at all, reject this\n-\t\t alternative.  Note that we could also lose due to\n-\t\t LIMIT_RELOAD_RELOAD_CLASS, but we don't check that\n-\t\t here.  */\n-\n-\t      if (! CONSTANT_P (operand)\n-\t\t  && (enum reg_class) this_alternative[i] != NO_REGS\n-\t\t  && (PREFERRED_RELOAD_CLASS (operand,\n-\t\t\t\t\t      (enum reg_class) this_alternative[i])\n-\t\t      == NO_REGS))\n-\t\tbad = 1;\n-\n \t      /* Alternative loses if it requires a type of reload not\n \t\t permitted for this insn.  We can always reload SCRATCH\n \t\t and objects with a REG_UNUSED note.  */\n-\t      else if (GET_CODE (operand) != SCRATCH\n+\t      if (GET_CODE (operand) != SCRATCH\n \t\t       && modified[i] != RELOAD_READ && no_output_reloads\n \t\t       && ! find_reg_note (insn, REG_UNUSED, operand))\n \t\tbad = 1;\n \t      else if (modified[i] != RELOAD_WRITE && no_input_reloads\n \t\t       && ! const_to_mem)\n \t\tbad = 1;\n \n+\t      /* If we can't reload this value at all, reject this\n+\t\t alternative.  Note that we could also lose due to\n+\t\t LIMIT_RELOAD_CLASS, but we don't check that\n+\t\t here.  */\n+\n+\t      if (! CONSTANT_P (operand)\n+\t\t  && (enum reg_class) this_alternative[i] != NO_REGS)\n+\t\t{\n+\t\t  if (PREFERRED_RELOAD_CLASS\n+\t\t\t(operand, (enum reg_class) this_alternative[i])\n+\t\t      == NO_REGS)\n+\t\t    reject = 600;\n+\n+#ifdef PREFERRED_OUTPUT_RELOAD_CLASS\n+\t\t  if (operand_type[i] == RELOAD_FOR_OUTPUT\n+\t\t      && PREFERRED_OUTPUT_RELOAD_CLASS\n+\t\t\t   (operand, (enum reg_class) this_alternative[i])\n+\t\t         == NO_REGS)\n+\t\t    reject = 600;\n+#endif\n+\t\t}\n+\n \t      /* We prefer to reload pseudos over reloading other things,\n \t\t since such reloads may be able to be eliminated later.\n \t\t If we are reloading a SCRATCH, we won't be generating any"}]}