{"sha": "d16790f212312ea395cb1d2a4f9641dea9892c64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE2NzkwZjIxMjMxMmVhMzk1Y2IxZDJhNGY5NjQxZGVhOTg5MmM2NA==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "1999-02-10T23:10:43Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-02-10T23:10:43Z"}, "message": "function.c (assign_stack_temp_for_type): Clear best_p when an exact match is found.\n\n        * function.c (assign_stack_temp_for_type): Clear best_p\n        when an exact match is found.\n        * i386.h (LOCAL_ALIGNMENT): Define.\n        * function.c (assign_stack_local, assign_outer_stack_local): Use it.\n        (assign_stack_temp_for_type): New function based on assign_stack_temp.\n        (assign_stack_temp): Call it.\n        (assign_temp): Use assign_stack_temp_for_type, not assign_stack_temp.\n        * stmt.c: Use assign_temp, not assign_stack_temp.\n        * tm.texi: Document LOCAL_ALIGNMENT.\n\nFrom-SVN: r25143", "tree": {"sha": "3b7147f259c430743258b593dff47d5c7d2ab26a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b7147f259c430743258b593dff47d5c7d2ab26a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d16790f212312ea395cb1d2a4f9641dea9892c64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d16790f212312ea395cb1d2a4f9641dea9892c64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d16790f212312ea395cb1d2a4f9641dea9892c64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d16790f212312ea395cb1d2a4f9641dea9892c64/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b111589b09c11e2a18759d1ecbf75af3e53c8536", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b111589b09c11e2a18759d1ecbf75af3e53c8536", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b111589b09c11e2a18759d1ecbf75af3e53c8536"}], "stats": {"total": 171, "additions": 143, "deletions": 28}, "files": [{"sha": "92da3b23e7c1652688b21eb477eb62c8bb97beca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16790f212312ea395cb1d2a4f9641dea9892c64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16790f212312ea395cb1d2a4f9641dea9892c64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d16790f212312ea395cb1d2a4f9641dea9892c64", "patch": "@@ -1,3 +1,16 @@\n+Thu Feb 11 00:08:17 1999  John Wehle  (john@feith.com)\n+\n+\t* function.c (assign_stack_temp_for_type): Clear best_p\n+\twhen an exact match is found.\n+\n+\t* i386.h (LOCAL_ALIGNMENT): Define.\n+\t* function.c (assign_stack_local, assign_outer_stack_local): Use it.\n+\t(assign_stack_temp_for_type): New function based on assign_stack_temp.\n+\t(assign_stack_temp): Call it.\n+\t(assign_temp): Use assign_stack_temp_for_type, not assign_stack_temp.\n+\t* stmt.c: Use assign_temp, not assign_stack_temp.\n+\t* tm.texi: Document LOCAL_ALIGNMENT.\n+\n Wed Feb 10 23:28:28 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* reorg.c: Finish deleting half-deleted comment."}, {"sha": "718c719181752e16e3b69d0f1844b100a21ae0f7", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16790f212312ea395cb1d2a4f9641dea9892c64/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16790f212312ea395cb1d2a4f9641dea9892c64/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d16790f212312ea395cb1d2a4f9641dea9892c64", "patch": "@@ -502,6 +502,46 @@ extern int ix86_arch;\n \t: (ALIGN))\t\t\t\t\t\t\t\\\n     : (ALIGN))\n \n+/* If defined, a C expression to compute the alignment for a local\n+   variable.  TYPE is the data type, and ALIGN is the alignment that\n+   the object would ordinarily have.  The value of this macro is used\n+   instead of that alignment to align the object.\n+\n+   If this macro is not defined, then ALIGN is used.\n+\n+   One use of this macro is to increase alignment of medium-size\n+   data to make it all fit in fewer cache lines.  */\n+\n+#define LOCAL_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\t\\\n+    ? ((TYPE_MODE (TREE_TYPE (TYPE)) == DFmode && (ALIGN) < 64)\t\t\\\n+\t? 64\t\t\t\t\t\t\t\t\\\n+   \t: (TYPE_MODE (TREE_TYPE (TYPE)) == XFmode && (ALIGN) < 128)\t\\\n+\t? 128\t\t\t\t\t\t\t\t\\\n+\t: (ALIGN))\t\t\t\t\t\t\t\\\n+    : TREE_CODE (TYPE) == COMPLEX_TYPE\t\t\t\t\t\\\n+    ? ((TYPE_MODE (TYPE) == DCmode && (ALIGN) < 64)\t\t\t\\\n+\t? 64\t\t\t\t\t\t\t\t\\\n+   \t: (TYPE_MODE (TYPE) == XCmode && (ALIGN) < 128)\t\t\t\\\n+\t? 128\t\t\t\t\t\t\t\t\\\n+\t: (ALIGN))\t\t\t\t\t\t\t\\\n+    : ((TREE_CODE (TYPE) == RECORD_TYPE\t\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == UNION_TYPE\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == QUAL_UNION_TYPE)\t\t\t\t\\\n+\t&& TYPE_FIELDS (TYPE))\t\t\t\t\t\t\\\n+    ? ((DECL_MODE (TYPE_FIELDS (TYPE)) == DFmode && (ALIGN) < 64)\t\\\n+\t? 64\t\t\t\t\t\t\t\t\\\n+\t: (DECL_MODE (TYPE_FIELDS (TYPE)) == XFmode && (ALIGN) < 128)\t\\\n+\t? 128\t\t\t\t\t\t\t\t\\\n+\t: (ALIGN))\t\t\t\t\t\t\t\\\n+    : TREE_CODE (TYPE) == REAL_TYPE\t\t\t\t\t\\\n+    ? ((TYPE_MODE (TYPE) == DFmode && (ALIGN) < 64)\t\t\t\\\n+\t? 64\t\t\t\t\t\t\t\t\\\n+   \t: (TYPE_MODE (TYPE) == XFmode && (ALIGN) < 128)\t\t\t\\\n+\t? 128\t\t\t\t\t\t\t\t\\\n+\t: (ALIGN))\t\t\t\t\t\t\t\\\n+    : (ALIGN))\n+\n /* Set this non-zero if move instructions will actually fail to work\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 0"}, {"sha": "a14a886d4e8414db679559c360b07786bb8ed052", "filename": "gcc/function.c", "status": "modified", "additions": 77, "deletions": 22, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16790f212312ea395cb1d2a4f9641dea9892c64/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16790f212312ea395cb1d2a4f9641dea9892c64/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d16790f212312ea395cb1d2a4f9641dea9892c64", "patch": "@@ -65,6 +65,10 @@ Boston, MA 02111-1307, USA.  */\n #define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY\n #endif\n \n+#ifndef LOCAL_ALIGNMENT\n+#define LOCAL_ALIGNMENT(TYPE, ALIGNMENT) ALIGNMENT\n+#endif\n+\n /* Some systems use __main in a way incompatible with its use in gcc, in these\n    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n    give the same symbol without quotes for an alternative entry point.  You\n@@ -386,6 +390,8 @@ struct temp_slot\n   /* The rtx used to represent the address if not the address of the\n      slot above.  May be an EXPR_LIST if multiple addresses exist.  */\n   rtx address;\n+  /* The alignment (in bits) of the slot. */\n+  int align;\n   /* The size, in units, of the slot.  */\n   HOST_WIDE_INT size;\n   /* The value of `sequence_rtl_expr' when this temporary is allocated.  */\n@@ -440,6 +446,8 @@ struct fixup_replacement\n \n static rtx assign_outer_stack_local PROTO ((enum machine_mode, HOST_WIDE_INT,\n \t\t\t\t\t    int, struct function *));\n+static rtx assign_stack_temp_for_type PROTO ((enum machine_mode, HOST_WIDE_INT,\n+\t\t\t\t\t      int, tree));\n static struct temp_slot *find_temp_slot_from_address  PROTO((rtx));\n static void put_reg_into_stack\tPROTO((struct function *, rtx, tree,\n \t\t\t\t       enum machine_mode, enum machine_mode,\n@@ -716,9 +724,19 @@ assign_stack_local (mode, size, align)\n \n   if (align == 0)\n     {\n-      alignment = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+      tree type;\n+\n+      alignment = GET_MODE_ALIGNMENT (mode);\n       if (mode == BLKmode)\n-\talignment = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n+\talignment = BIGGEST_ALIGNMENT;\n+\n+      /* Allow the target to (possibly) increase the alignment of this\n+\t stack slot.  */\n+      type = type_for_mode (mode, 0);\n+      if (type)\n+\talignment = LOCAL_ALIGNMENT (type, alignment);\n+\n+      alignment /= BITS_PER_UNIT;\n     }\n   else if (align == -1)\n     {\n@@ -791,9 +809,19 @@ assign_outer_stack_local (mode, size, align, function)\n \n   if (align == 0)\n     {\n-      alignment = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+      tree type;\n+\n+      alignment = GET_MODE_ALIGNMENT (mode);\n       if (mode == BLKmode)\n-\talignment = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n+\talignment = BIGGEST_ALIGNMENT;\n+\n+      /* Allow the target to (possibly) increase the alignment of this\n+\t stack slot.  */\n+      type = type_for_mode (mode, 0);\n+      if (type)\n+\talignment = LOCAL_ALIGNMENT (type, alignment);\n+\n+      alignment /= BITS_PER_UNIT;\n     }\n   else if (align == -1)\n     {\n@@ -849,32 +877,46 @@ assign_outer_stack_local (mode, size, align, function)\n    if we are to allocate something at an inner level to be treated as\n    a variable in the block (e.g., a SAVE_EXPR).  */\n \n-rtx\n-assign_stack_temp (mode, size, keep)\n+static rtx\n+assign_stack_temp_for_type (mode, size, keep, type)\n      enum machine_mode mode;\n      HOST_WIDE_INT size;\n      int keep;\n+     tree type;\n {\n+  int align;\n   struct temp_slot *p, *best_p = 0;\n \n   /* If SIZE is -1 it means that somebody tried to allocate a temporary\n      of a variable size.  */\n   if (size == -1)\n     abort ();\n \n-  /* First try to find an available, already-allocated temporary that is the\n-     exact size we require.  */\n-  for (p = temp_slots; p; p = p->next)\n-    if (p->size == size && GET_MODE (p->slot) == mode && ! p->in_use)\n-      break;\n+  align = GET_MODE_ALIGNMENT (mode);\n+  if (mode == BLKmode)\n+    align = BIGGEST_ALIGNMENT;\n \n-  /* If we didn't find, one, try one that is larger than what we want.  We\n-     find the smallest such.  */\n-  if (p == 0)\n-    for (p = temp_slots; p; p = p->next)\n-      if (p->size > size && GET_MODE (p->slot) == mode && ! p->in_use\n-\t  && (best_p == 0 || best_p->size > p->size))\n+  if (! type)\n+    type = type_for_mode (mode, 0);\n+  if (type)\n+    align = LOCAL_ALIGNMENT (type, align);\n+\n+  /* Try to find an available, already-allocated temporary of the proper\n+     mode which meets the size and alignment requirements.  Choose the\n+     smallest one with the closest alignment.  */\n+  for (p = temp_slots; p; p = p->next)\n+    if (p->align >= align && p->size >= size && GET_MODE (p->slot) == mode\n+\t&& ! p->in_use\n+\t&& (best_p == 0 || best_p->size > p->size\n+\t    || (best_p->size == p->size && best_p->align > p->align)))\n+      {\n+\tif (p->align == align && p->size == size)\n+\t  {\n+\t    best_p = 0;\n+\t    break;\n+\t  }\n \tbest_p = p;\n+      }\n \n   /* Make our best, if any, the one to use.  */\n   if (best_p)\n@@ -884,7 +926,7 @@ assign_stack_temp (mode, size, keep)\n \t for BLKmode slots, so that we can be sure of the alignment.  */\n       if (GET_MODE (best_p->slot) == BLKmode)\n \t{\n-\t  int alignment = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n+\t  int alignment = best_p->align / BITS_PER_UNIT;\n \t  HOST_WIDE_INT rounded_size = CEIL_ROUND (size, alignment);\n \n \t  if (best_p->size - rounded_size >= alignment)\n@@ -897,6 +939,7 @@ assign_stack_temp (mode, size, keep)\n \t      p->slot = gen_rtx_MEM (BLKmode,\n \t\t\t\t     plus_constant (XEXP (best_p->slot, 0),\n \t\t\t\t\t\t    rounded_size));\n+\t      p->align = best_p->align;\n \t      p->address = 0;\n \t      p->rtl_expr = 0;\n \t      p->next = temp_slots;\n@@ -920,9 +963,9 @@ assign_stack_temp (mode, size, keep)\n \n       p = (struct temp_slot *) oballoc (sizeof (struct temp_slot));\n \n-      /* If the temp slot mode doesn't indicate the alignment,\n-\t use the largest possible, so no one will be disappointed.  */\n-      p->slot = assign_stack_local (mode, size, mode == BLKmode ? -1 : 0);\n+      p->slot = assign_stack_local (mode, size, align);\n+\n+      p->align = align;\n \n       /* The following slot size computation is necessary because we don't\n \t know the actual size of the temporary slot until assign_stack_local\n@@ -978,6 +1021,18 @@ assign_stack_temp (mode, size, keep)\n   MEM_ALIAS_SET (p->slot) = 0;\n   return p->slot;\n }\n+\n+/* Allocate a temporary stack slot and record it for possible later\n+   reuse.  First three arguments are same as in preceding function.  */\n+\n+rtx\n+assign_stack_temp (mode, size, keep)\n+     enum machine_mode mode;\n+     HOST_WIDE_INT size;\n+     int keep;\n+{\n+  return assign_stack_temp_for_type (mode, size, keep, NULL_TREE);\n+}\n \f\n /* Assign a temporary of given TYPE.\n    KEEP is as for assign_stack_temp.\n@@ -1010,7 +1065,7 @@ assign_temp (type, keep, memory_required, dont_promote)\n \t  && TREE_CODE (TYPE_ARRAY_MAX_SIZE (type)) == INTEGER_CST)\n \tsize = TREE_INT_CST_LOW (TYPE_ARRAY_MAX_SIZE (type));\n \n-      tmp = assign_stack_temp (mode, size, keep);\n+      tmp = assign_stack_temp_for_type (mode, size, keep, type);\n       MEM_SET_IN_STRUCT_P (tmp, AGGREGATE_TYPE_P (type));\n       return tmp;\n     }"}, {"sha": "a565adf640209bc718080cf54c24412ddb285eb3", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16790f212312ea395cb1d2a4f9641dea9892c64/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16790f212312ea395cb1d2a4f9641dea9892c64/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=d16790f212312ea395cb1d2a4f9641dea9892c64", "patch": "@@ -3495,12 +3495,7 @@ expand_decl (decl)\n \t  oldaddr = XEXP (DECL_RTL (decl), 0);\n \t}\n \n-      DECL_RTL (decl)\n-\t= assign_stack_temp (DECL_MODE (decl),\n-\t\t\t     ((TREE_INT_CST_LOW (DECL_SIZE (decl))\n-\t\t\t       + BITS_PER_UNIT - 1)\n-\t\t\t      / BITS_PER_UNIT),\n-\t\t\t     1);\n+      DECL_RTL (decl) = assign_temp (TREE_TYPE (decl), 1, 1, 1);\n       MEM_SET_IN_STRUCT_P (DECL_RTL (decl),\n \t\t\t   AGGREGATE_TYPE_P (TREE_TYPE (decl)));\n "}, {"sha": "d3dac9fd938b5cdbded822175d41a41bbe720d47", "filename": "gcc/tm.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d16790f212312ea395cb1d2a4f9641dea9892c64/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d16790f212312ea395cb1d2a4f9641dea9892c64/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=d16790f212312ea395cb1d2a4f9641dea9892c64", "patch": "@@ -873,6 +873,18 @@ The typical use of this macro is to increase alignment for string\n constants to be word aligned so that @code{strcpy} calls that copy\n constants can be done inline.\n \n+@findex LOCAL_ALIGNMENT\n+@item LOCAL_ALIGNMENT (@var{type}, @var{basic-align})\n+If defined, a C expression to compute the alignment for a variables in\n+the local store.  @var{type} is the data type, and @var{basic-align} is\n+the alignment that the object would ordinarily have.  The value of this\n+macro is used instead of that alignment to align the object.\n+\n+If this macro is not defined, then @var{basic-align} is used.\n+\n+One use of this macro is to increase alignment of medium-size data to\n+make it all fit in fewer cache lines.\n+\n @findex EMPTY_FIELD_BOUNDARY\n @item EMPTY_FIELD_BOUNDARY\n Alignment in bits to be given to a structure bit field that follows an"}]}