{"sha": "d2638db6537096c72a93d820748b2b9d3bba88ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI2MzhkYjY1MzcwOTZjNzJhOTNkODIwNzQ4YjJiOWQzYmJhODhhYg==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2005-02-16T17:32:59Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2005-02-16T17:32:59Z"}, "message": "PersistentByteMap.java (name, values, fc): new fields.\n\n2005-02-16  Andrew Haley  <aph@redhat.com>\n\n        * gnu/gcj/runtime/PersistentByteMap.java (name, values, fc): new\n        fields.\n        (PersistentByteMap): Set name\n        Magic number changed to 0x67636a64 (\"gcjd\").\n        (init): Force the map to be prime.\n        (emptyPersistentByteMap): File name was a string, now a File.\n        (addBytes): Share srings between entries.\n        (stringTableSize): New method.\n        (capacity): Scale by load factor.\n        (force): New method.\n        (getFile): New method.\n        (close): New method.\n        (putAll): New method.\n        (ByteWrapper): New class.\n        * gnu/gcj/tools/gcj_dbtool/Main.java (verbose): New field.\n        (main): Guess the average string size as 32, not 64.\n        Copy a database before modifying it, so that we can update a\n        database in a running system.\n        If a database isn't big enough, resize it.\n        \"-m\": new option: merges databases.\n        \"-a\": Create a new detabase if it doesn't exist.\n        (usage): Correct, add new option.\n        (addJar): Copy a database before modifying it.\n        (resizeMap): New method.\n\nFrom-SVN: r95110", "tree": {"sha": "0a54e6a6ed598b92c4838adeed72f8de693319f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a54e6a6ed598b92c4838adeed72f8de693319f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2638db6537096c72a93d820748b2b9d3bba88ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2638db6537096c72a93d820748b2b9d3bba88ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2638db6537096c72a93d820748b2b9d3bba88ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2638db6537096c72a93d820748b2b9d3bba88ab/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5fcfe0b28b4caae66a7bfe2483a4acb2d53e277f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fcfe0b28b4caae66a7bfe2483a4acb2d53e277f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fcfe0b28b4caae66a7bfe2483a4acb2d53e277f"}], "stats": {"total": 391, "additions": 332, "deletions": 59}, "files": [{"sha": "d6a90bda48d692397b0bd985a46cb1a938ba88b2", "filename": "libjava/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2638db6537096c72a93d820748b2b9d3bba88ab/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2638db6537096c72a93d820748b2b9d3bba88ab/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d2638db6537096c72a93d820748b2b9d3bba88ab", "patch": "@@ -1,3 +1,30 @@\n+2005-02-16  Andrew Haley  <aph@redhat.com>\n+\n+\t* gnu/gcj/runtime/PersistentByteMap.java (name, values, fc): new\n+\tfields.\n+\t(PersistentByteMap): Set name\n+\tMagic number changed to 0x67636a64 (\"gcjd\").\n+\t(init): Force the map to be prime.\n+\t(emptyPersistentByteMap): File name was a string, now a File.\n+\t(addBytes): Share srings between entries.\n+\t(stringTableSize): New method.\n+\t(capacity): Scale by load factor.\n+\t(force): New method.\n+\t(getFile): New method.\n+\t(close): New method.\n+\t(putAll): New method.\n+\t(ByteWrapper): New class.\n+\t* gnu/gcj/tools/gcj_dbtool/Main.java (verbose): New field.\n+\t(main): Guess the average string size as 32, not 64.\n+\tCopy a database before modifying it, so that we can update a\n+\tdatabase in a running system.\n+\tIf a database isn't big enough, resize it.\n+\t\"-m\": new option: merges databases.\n+\t\"-a\": Create a new detabase if it doesn't exist.\n+\t(usage): Correct, add new option.\n+\t(addJar): Copy a database before modifying it.\n+\t(resizeMap): New method.\n+\n 2005-02-15  David Daney <ddaney@avtrex.com>\n \t    Bryce McKinlay  <mckinlay@redhat.com>\n \t    "}, {"sha": "a20f5b8ab2bec3a3c8bf48cd8f320501e2d9778d", "filename": "libjava/gnu/gcj/runtime/PersistentByteMap.java", "status": "modified", "additions": 161, "deletions": 26, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2638db6537096c72a93d820748b2b9d3bba88ab/libjava%2Fgnu%2Fgcj%2Fruntime%2FPersistentByteMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2638db6537096c72a93d820748b2b9d3bba88ab/libjava%2Fgnu%2Fgcj%2Fruntime%2FPersistentByteMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FPersistentByteMap.java?ref=d2638db6537096c72a93d820748b2b9d3bba88ab", "patch": "@@ -39,10 +39,6 @@\n BUGS/FEATURES:\n         remove() isn't written yet.\n \n-\twe can't change the capacity of a PersistentByteMap.\n-\n-        0x12345678 is a bad choice for the magic number.\n-\n         capacity is fixed once the map has been created.\n \n         We use linear probing to resolve collisions.  It might be\n@@ -51,11 +47,7 @@\n         table is half full there are only on average 1.5 probes for a\n         successful search and 2.5 probes for an unsuccessful one.\n \n-        We don't use unique strings.  This wastes space.\n-\n-        capacity should probably be prime, but we don't check that.\n-\n-\twe don't do any locking at all: adding to a PersistentByteMap\n+\tWe don't do any locking at all: adding to a PersistentByteMap\n \tat runtime is possible, but it requires filesystem locks\n \taround get(), put(), and remove().\n */\n@@ -67,6 +59,7 @@ around get(), put(), and remove().\n import java.nio.channels.*;\n import java.util.*;\n import java.security.MessageDigest;\n+import java.math.BigInteger;\n \n public class PersistentByteMap\n {\n@@ -94,12 +87,18 @@ around get(), put(), and remove().\n \n   private long length;      // the length of the underlying file\n \n+  private final File name;  // The name of the underlying file\n+\n   static private final int UNUSED_ENTRY = -1; \n \n   static public final int KEYS = 0;\n   static public final int VALUES = 1;\n   static public final int ENTRIES = 2;\n \n+  private HashMap values;   // A map of strings in the string table.\n+\n+  FileChannel fc;           // The underlying file channel.\n+\n   static final public class AccessMode\n   {\n     private final FileChannel.MapMode mapMode;\n@@ -108,19 +107,22 @@ around get(), put(), and remove().\n     {\n       READ_ONLY = new AccessMode(FileChannel.MapMode.READ_ONLY);\n       READ_WRITE = new AccessMode(FileChannel.MapMode.READ_WRITE);\n+      PRIVATE = new AccessMode(FileChannel.MapMode.PRIVATE);\n     }\n \n     public static final AccessMode READ_ONLY;\n     public static final AccessMode READ_WRITE; \n+    public static final AccessMode PRIVATE;\n \n     private AccessMode(FileChannel.MapMode mode)\n     {\n       this.mapMode = mode;\n     }\n   }\n \n-  private PersistentByteMap()\n+  private PersistentByteMap(File name)\n   {\n+    this.name = name;\n   }\n \n   public PersistentByteMap(String filename, AccessMode mode)\n@@ -132,7 +134,7 @@ public PersistentByteMap(String filename, AccessMode mode)\n   public PersistentByteMap(File f, AccessMode mode)\n     throws IOException \n   {\n-    FileChannel fc;\n+    name = f;\n \n     if (mode == AccessMode.READ_ONLY)\n       {\n@@ -149,7 +151,7 @@ public PersistentByteMap(File f, AccessMode mode)\n     buf = fc.map(mode.mapMode, 0, length);\n \n     int magic = getWord (MAGIC);\n-    if (magic != 0x12345678)\n+    if (magic != 0x67636a64) /* \"gcjd\" */\n       throw new IllegalArgumentException(f.getName());\n \n     table_base = getWord (TABLE_BASE);\n@@ -167,8 +169,27 @@ private void init (PersistentByteMap m, File f, int capacity, int strtabSize)\n   {\n     f.createNewFile();\n     RandomAccessFile raf = new RandomAccessFile(f, \"rw\");\n-        \n-    this.capacity = capacity;\n+\n+    {        \n+      // The user has explicitly provided a size for the table.\n+      // We're going to make that size prime.  This isn't\n+      // strictly necessary but it can't hurt.\n+      //\n+      // We expand the size by 3/2 because the hash table is\n+      // intolerably slow when more than 2/3 full.\n+      \n+      BigInteger size = new BigInteger(Integer.toString(capacity * 3/2));\n+      BigInteger two = BigInteger.ONE.add(BigInteger.ONE);\n+      \n+      if (size.getLowestSetBit() != 0) // A hard way to say isEven()\n+\tsize = size.add(BigInteger.ONE);\n+    \n+      while (! size.isProbablePrime(10))\n+\tsize = size.add(two);\n+      \n+      this.capacity = capacity = size.intValue();\n+    }\n+\n     table_base = 64;\n     string_base = table_base + capacity * TABLE_ENTRY_SIZE;\n     string_size = 0;\n@@ -183,29 +204,31 @@ private void init (PersistentByteMap m, File f, int capacity, int strtabSize)\n     for (long i = 0; i < totalFileSize; i+= 4096)\n       raf.write(_4k);\n         \n-    FileChannel fc = raf.getChannel();\n+    fc = raf.getChannel();\n     buf = fc.map(FileChannel.MapMode.READ_WRITE, 0, raf.length());\n \n     for (int i = 0; i < capacity; i++)\n       putKeyPos(UNUSED_ENTRY, i);\n         \n-    putWord(0x12345678, MAGIC);\n+    putWord(0x67636a64, MAGIC);\n     putWord(0x01, VERSION);\n     putWord(capacity, CAPACITY);\n     putWord(table_base, TABLE_BASE);\n     putWord(string_base, STRING_BASE);\n     putWord(file_size, FILE_SIZE);\n     putWord(elements, ELEMENTS);\n     buf.force();\n+\n+    length = fc.size();\n+    string_size = 0;\n   }     \n \n-  static public PersistentByteMap emptyPersistentByteMap(String filename, \n-                                                         int capacity, int strtabSize)\n+  static public PersistentByteMap \n+  emptyPersistentByteMap(File name, int capacity, int strtabSize)\n     throws IOException \n   {\n-    File f = new File(filename);\n-    PersistentByteMap m = new PersistentByteMap();\n-    m.init(m, f, capacity, strtabSize);\n+    PersistentByteMap m = new PersistentByteMap(name);\n+    m.init(m, name, capacity, strtabSize);\n     return m;\n   }     \n \n@@ -313,9 +336,7 @@ public void put(byte[] digest, byte[] value)\n   {\n     int hashIndex = hash(digest);\n \n-    // With the the table 2/3 full there will be on average 2 probes\n-    // for a successful search and 5 probes for an unsuccessful one.\n-    if (elements >= capacity * 2/3)\n+    if (elements >= capacity())\n       throw new IllegalAccessException(\"Table Full: \" + elements);\n \n     do\n@@ -336,7 +357,7 @@ else if (Arrays.equals (digest, getBytes(k)))\n             int newValue = addBytes((byte[])value);\n             putValuePos(newValue, hashIndex);\n             return;\n-          }         \n+          }\n                 \n         hashIndex++;\n         hashIndex %= capacity;\n@@ -347,6 +368,33 @@ else if (Arrays.equals (digest, getBytes(k)))\n   private int addBytes (byte[] data)\n     throws IllegalAccessException\n   {\n+    if (data.length > 16)\n+      {\n+\t// Keep track of long strings in the hope that we will be able\n+\t// to re-use them.\n+\tif (values == null)\n+\t  {\n+\t    values = new HashMap();\n+\t\n+\t    for (int i = 0; i < capacity; i++)\n+\t      if (getKeyPos(i) != UNUSED_ENTRY)\n+\t\t{\n+\t\t  int pos = getValuePos(i);\n+\t\t  ByteWrapper bytes = new ByteWrapper(getBytes(pos));\n+\t\t  values.put(bytes, new Integer(pos));\n+\t\t}\n+\t  }\n+\n+\t{\n+\t  Object result = values.get(new ByteWrapper(data));\n+\t  if (result != null)\n+\t    {\n+\t      // We already have this value in the string table\n+\t      return ((Integer)result).intValue();\n+\t    }\n+\t}\n+      }\n+\n     if (data.length + INT_SIZE >= this.length)\n       throw new IllegalAccessException(\"String table Full\");\n \n@@ -363,6 +411,9 @@ private int addBytes (byte[] data)\n     file_size = extent;\n     putWord (string_size, STRING_SIZE);\n     putWord (file_size, FILE_SIZE);\n+\n+    if (data.length > 16)\n+      values.put(new ByteWrapper(data), new Integer(top - string_base));\n         \n     return top - string_base;\n   }\n@@ -377,11 +428,68 @@ public int size()\n     return elements;\n   }\n \n+  public int stringTableSize()\n+  {\n+    return string_size;\n+  }\n+\n   public int capacity()\n   {\n-    return capacity;\n+    // With the the table 2/3 full there will be on average 2 probes\n+    // for a successful search and 5 probes for an unsuccessful one.\n+    return capacity * 2/3;\n   }\n \n+  public void force()\n+  {\n+    buf.force();\n+  }\n+\n+  public File getFile()\n+  {\n+    return name;\n+  }\n+\n+  // Close the map.  Once this has been done, the map can no longer be\n+  // used.\n+  public void close()\n+  {\n+    force();\n+    fc.close();\n+  }\n+\n+  public void \n+  putAll(PersistentByteMap t)\n+    throws IllegalAccessException\n+  {\n+    // We can use a fast copy if the size of a map has not changed.\n+    if (this.elements == 0 && t.capacity == this.capacity\n+\t&& t.length == this.length)\n+      {\n+\tthis.buf.position(0);\n+\tt.buf.position(0);\n+\tthis.buf.put(t.buf);\n+\tthis.table_base = t.table_base;\n+\tthis.string_base = t.string_base;\n+\tthis.string_size = t.string_size;\n+\tthis.file_size = t.file_size;\n+\tthis.elements = t.elements;\n+\tif (t.values != null)\n+\t  this.values = (HashMap)t.values.clone();\n+\treturn;\n+      }\n+\n+    // Otherwise do it the hard way.\n+    Iterator iterator = t.iterator(PersistentByteMap.ENTRIES);\n+    while (iterator.hasNext())\n+      {\n+\tPersistentByteMap.MapEntry entry \n+\t  = (PersistentByteMap.MapEntry)iterator.next();\n+\tthis.put((byte[])entry.getKey(), (byte[])entry.getValue());\n+      }\n+  }\n+\t\n+\n   private final class HashIterator implements Iterator\n   {\n     /** Current index in the physical hash table. */\n@@ -481,4 +589,31 @@ public final int getBucket()\n       return bucket;\n     }\n   }\n+\n+  // A wrapper class for a byte array that allows collections to be\n+  // made.\n+  private final class ByteWrapper\n+  {\n+    final byte[] bytes;\n+    final int hash;\n+\n+    public ByteWrapper (byte[] bytes)\n+    {\n+      int sum = 0;\n+      this.bytes = bytes;\n+      for (int i = 0; i < bytes.length; i++)\n+\tsum += bytes[i];\n+      hash = sum;\n+    }\n+\n+    public int hashCode()\n+    {\n+      return hash;\n+    }\n+  \n+    public boolean equals(Object obj)\n+    {\n+      return Arrays.equals(bytes, ((ByteWrapper)obj).bytes);\n+    }\n+  }\n }"}, {"sha": "256b6196df5fa865463cf960309f18b0eb96c335", "filename": "libjava/gnu/gcj/tools/gcj_dbtool/Main.java", "status": "modified", "additions": 144, "deletions": 33, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2638db6537096c72a93d820748b2b9d3bba88ab/libjava%2Fgnu%2Fgcj%2Ftools%2Fgcj_dbtool%2FMain.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2638db6537096c72a93d820748b2b9d3bba88ab/libjava%2Fgnu%2Fgcj%2Ftools%2Fgcj_dbtool%2FMain.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftools%2Fgcj_dbtool%2FMain.java?ref=d2638db6537096c72a93d820748b2b9d3bba88ab", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2004  Free Software Foundation\n+/* Copyright (C) 2004, 2005  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -11,13 +11,15 @@\n \n import gnu.gcj.runtime.PersistentByteMap;\n import java.io.*;\n+import java.nio.channels.*;\n import java.util.*;\n import java.util.jar.*;\n import java.security.MessageDigest;\n-import java.math.BigInteger;\n \n public class Main\n {\n+  static private boolean verbose = false;\n+\n   public static void main (String[] s)\n   {\n     insist (s.length >= 1);\n@@ -29,7 +31,7 @@ public static void main (String[] s)\n \t\t\t   + \") \"\n \t\t\t   + System.getProperty(\"java.vm.version\"));\n \tSystem.out.println();\n-\tSystem.out.println(\"Copyright 2004 Free Software Foundation, Inc.\");\n+\tSystem.out.println(\"Copyright 2004, 2005 Free Software Foundation, Inc.\");\n \tSystem.out.println(\"This is free software; see the source for copying conditions.  There is NO\");\n \tSystem.out.println(\"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\");\n \treturn;\n@@ -42,26 +44,14 @@ public static void main (String[] s)\n \n     if (s[0].equals(\"-n\"))\n       {\n+\t// Create a new database.\n \tinsist (s.length >= 2 && s.length <= 3);\n \n \tint capacity = 32749;\n \n \tif (s.length == 3)\n-\t  {\n-\t    // The user has explicitly provided a size for the table.\n-\t    // We're going to make that size prime.  This isn't\n-\t    // strictly necessary but it can't hurt.\n-\n-\t    BigInteger size = new BigInteger(s[2], 10);\n-\t    BigInteger two = BigInteger.ONE.add(BigInteger.ONE);\n-\n-\t    if (size.getLowestSetBit() != 0) // A hard way to say isEven()\n-\t      size = size.add(BigInteger.ONE);\n-\n-\t    while (! size.isProbablePrime(10))\n-\t      size = size.add(two);\n-\n-\t    capacity = size.intValue();\n+\t  {\t    \n+\t    capacity = Integer.parseInt(s[2]);\n \n \t    if (capacity <= 2)\n \t      {\n@@ -73,7 +63,8 @@ public static void main (String[] s)\n \ttry\n \t  {\n \t    PersistentByteMap b \n-\t      = PersistentByteMap.emptyPersistentByteMap (s[1], capacity, capacity*64);\n+\t      = PersistentByteMap.emptyPersistentByteMap(new File(s[1]), \n+\t\t\t\t\t\t\t capacity, capacity*32);\n \t  }\n \tcatch (Exception e)\n \t  {\n@@ -86,18 +77,26 @@ public static void main (String[] s)\n \n     if (s[0].equals(\"-a\"))\n       {\n+\t// Add a jar file to a database, creating it if necessary.\n+\t// Copies the database, adds the jar file to the copy, and\n+\t// then renames the new database over the old.\n \ttry\n \t  {\n \t    insist (s.length == 4);\n-\t    File jar = new File(s[2]);\n-\t    PersistentByteMap b \n-\t      = new PersistentByteMap(new File(s[1]), \n-\t\t\t\t      PersistentByteMap.AccessMode.READ_WRITE);\n+\t    File database = new File(s[1]);\n+\t    database = database.getAbsoluteFile();\n+\t    File jar = new File(s[2]);\t\n+\t    PersistentByteMap map; \n+\t    if (database.isFile())\n+\t      map = new PersistentByteMap(database, \n+\t\t\t\t\t  PersistentByteMap.AccessMode.READ_ONLY);\n+\t    else\n+\t      map = PersistentByteMap.emptyPersistentByteMap(database, \n+\t\t\t\t\t\t\t     100, 100*32);\n \t    File soFile = new File(s[3]);\n \t    if (! soFile.isFile())\n \t      throw new IllegalArgumentException(s[3] + \" is not a file\");\n-\t    \n-\t    addJar(jar, b, soFile);\n+ \t    map = addJar(jar, map, soFile);\n \t  }\n \tcatch (Exception e)\n \t  {\n@@ -110,6 +109,7 @@ public static void main (String[] s)\n \n     if (s[0].equals(\"-t\"))\n       {\n+\t// Test\n \ttry\n \t  {\n \t    insist (s.length == 2);\n@@ -142,8 +142,60 @@ public static void main (String[] s)\n \treturn;\n       }\n \t \n+    if (s[0].equals(\"-m\"))\n+      {\n+\t// Merge databases.\n+\tinsist (s.length >= 3);\n+\ttry\n+\t  {\n+\t    File database = new File(s[1]);\n+\t    database = database.getAbsoluteFile();\n+\t    File temp = File.createTempFile(database.getName(), \"\", \n+\t\t\t\t\t    database.getParentFile());\n+\t    \t\n+\t    int newSize = 0;\n+\t    int newStringTableSize = 0;\n+\t    PersistentByteMap[] sourceMaps = new PersistentByteMap[s.length - 2];\n+\t    // Scan all the input files, calculating worst case string\n+\t    // table and hash table use.\n+\t    for (int i = 2; i < s.length; i++)\n+\t      {\n+\t\tPersistentByteMap b \n+\t\t  = new PersistentByteMap(new File(s[i]),\n+\t\t\t\t\t  PersistentByteMap.AccessMode.READ_ONLY);\n+\t\tnewSize += b.size();\n+\t\tnewStringTableSize += b.stringTableSize();\n+\t\tsourceMaps[i - 2] = b;\n+\t      }\n+\t    \n+\t    newSize *= 1.5; // Scaling the new size by 1.5 results in\n+\t\t\t    // fewer collisions.\n+\t    PersistentByteMap map \n+\t      = PersistentByteMap.emptyPersistentByteMap\n+\t        (temp, newSize, newStringTableSize);\n+\n+\t    for (int i = 0; i < sourceMaps.length; i++)\n+\t      {\n+\t\tif (verbose)\n+\t\t  System.err.println(\"adding \" + sourceMaps[i].size() \n+\t\t\t\t     + \" elements from \"\n+\t\t\t\t     + sourceMaps[i].getFile());\n+\t\tmap.putAll(sourceMaps[i]);\n+\t      }\n+\t    map.close();\n+\t    temp.renameTo(database);\n+\t  }\n+\tcatch (Exception e)\n+\t  {\n+\t    e.printStackTrace();\n+\t    System.exit(3);\n+\t  }\n+\treturn;\n+      }\n+\n     if (s[0].equals(\"-l\"))\n       {\n+\t// List a database.\n \tinsist (s.length == 2);\n \ttry\n \t  {\n@@ -180,6 +232,7 @@ public static void main (String[] s)\n \n     if (s[0].equals(\"-d\"))\n       {\n+\t// For testing only: fill the byte map with random data.\n \tinsist (s.length == 2);\n \ttry\n \t  {    \n@@ -225,20 +278,49 @@ private static void usage(PrintStream out)\n        + \"  Usage: \\n\"\n        + \"    gcj-dbtool -n file.gcjdb [size]     - Create a new gcj map database\\n\"\n        + \"    gcj-dbtool -a file.gcjdb file.jar file.so\\n\"\n-       + \"            - Add the contents of file.jar to the database\\n\"\n+       + \"            - Add the contents of file.jar to a new gcj map database\\n\"\n        + \"    gcj-dbtool -t file.gcjdb            - Test a gcj map database\\n\"\n-       + \"    gcj-dbtool -l file.gcjdb            - List a gcj map database\\n\");\n+       + \"    gcj-dbtool -l file.gcjdb            - List a gcj map database\\n\"\n+       + \"    gcj-dbtool -m dest.gcjdb [source.gcjdb]...\\n\"\n+       + \"             - Merge gcj map databases into dest\\n\"\n+       + \"               Replaces dest\\n\"\n+       + \"               To add to dest, include dest in the list of sources\");\n   }\n-      \n \n-  private static void addJar(File f, PersistentByteMap b, File soFile)\n-   throws Exception\n+  // Add a jar to a map.  This copies the map first and returns a\n+  // different map that contains the data.  The original map is\n+  // closed.\n+\n+  private static PersistentByteMap \n+  addJar(File f, PersistentByteMap b, File soFile)\n+    throws Exception\n   {\n     MessageDigest md = MessageDigest.getInstance(\"MD5\");\n \n     JarFile jar = new JarFile (f);\n+\n+    int count = 0;\n+    {\n+      Enumeration entries = jar.entries();      \n+      while (entries.hasMoreElements())\n+\t{\n+\t  JarEntry classfile = (JarEntry)entries.nextElement();\n+\t  if (classfile.getName().endsWith(\".class\"))\n+\t    count++;\n+\t}\n+    }\n+\n+    if (verbose)\n+      System.err.println(\"adding \" + count + \" elements from \"\n+\t\t\t + f + \" to \" + b.getFile());\n+    \n+    // Maybe resize the destination map.  We're allowing plenty of\n+    // extra space by using a loadFactor of 2.  \n+    b = resizeMap(b, (b.size() + count) * 2, true);\n+\n     Enumeration entries = jar.entries();\n \n+    byte[] soFileName = soFile.getCanonicalPath().getBytes(\"UTF-8\");\n     while (entries.hasMoreElements())\n       {\n \tJarEntry classfile = (JarEntry)entries.nextElement();\n@@ -259,12 +341,41 @@ private static void addJar(File f, PersistentByteMap b, File soFile)\n \t\t\t\t\t + classfile.getName());\n \t\tpos += len;\n \t      }\n-\t    b.put(md.digest(data), \n-\t\t  soFile.getCanonicalPath().getBytes());\n+\t    b.put(md.digest(data), soFileName);\n \t  }\n-      }\t      \n+      }\n+    return b;\n   }    \n \n+  // Resize a map by creating a new one with the same data and\n+  // renaming it.  If close is true, close the original map.\n+\n+  static PersistentByteMap resizeMap(PersistentByteMap m, int newCapacity, boolean close)\n+    throws IOException, IllegalAccessException\n+  {\n+    newCapacity = Math.max(m.capacity(), newCapacity);\n+    File name = m.getFile();\n+    File copy = File.createTempFile(name.getName(), \"\", name.getParentFile());\n+    try\n+      {\n+\tPersistentByteMap dest \n+\t  = PersistentByteMap.emptyPersistentByteMap\n+\t  (copy, newCapacity, newCapacity*32);\n+\tdest.putAll(m);\n+\tdest.force();\n+\tif (close)\n+\t  m.close();\n+\tcopy.renameTo(name);\n+\treturn dest;\n+      }\n+    catch (Exception e)\n+      {\n+\tcopy.delete();\n+      }\n+    return null;\n+  }\n+    \n+\t \n   static String bytesToString(byte[] b)\n   {\n     StringBuffer hexBytes = new StringBuffer();"}]}