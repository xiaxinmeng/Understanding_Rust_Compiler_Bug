{"sha": "401f3a81a6744d27083b8dc65460b5b3e37d3c3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAxZjNhODFhNjc0NGQyNzA4M2I4ZGM2NTQ2MGI1YjNlMzdkM2MzYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-04-08T08:20:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-04-08T08:20:39Z"}, "message": "tree-loop-distribution.c (const_with_all_bytes_same): New function.\n\n\t* tree-loop-distribution.c (const_with_all_bytes_same): New function.\n\t(generate_memset_builtin): Only handle integer_all_onesp as -1 val if\n\tTYPE_PRECISION is equal to mode bitsize.  Use const_with_all_bytes_same\n\tif possible to compute val.\n\t(classify_partition): Verify CONSTRUCTOR doesn't have any elts.\n\tFor QImode integers don't require anything about precision.  Use\n\tconst_with_all_bytes_same to find out if the constant doesn't have\n\trepeated bytes in it.\n\n\t* gcc.dg/pr56837.c: New test.\n\t* gcc.dg/tree-ssa/ldist-19.c: Don't check for\n\t\"generated memset minus one\".\n\nFrom-SVN: r197568", "tree": {"sha": "77ea0cbf6db3539a8026292020faae8c681fbc6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77ea0cbf6db3539a8026292020faae8c681fbc6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/401f3a81a6744d27083b8dc65460b5b3e37d3c3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/401f3a81a6744d27083b8dc65460b5b3e37d3c3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/401f3a81a6744d27083b8dc65460b5b3e37d3c3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/401f3a81a6744d27083b8dc65460b5b3e37d3c3a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03ed99a89eff22949d9983cb70092127a7a0c190", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03ed99a89eff22949d9983cb70092127a7a0c190", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03ed99a89eff22949d9983cb70092127a7a0c190"}], "stats": {"total": 165, "additions": 132, "deletions": 33}, "files": [{"sha": "31c760a868fdb1a9862dcd345f799c170ec93a05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/401f3a81a6744d27083b8dc65460b5b3e37d3c3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/401f3a81a6744d27083b8dc65460b5b3e37d3c3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=401f3a81a6744d27083b8dc65460b5b3e37d3c3a", "patch": "@@ -1,3 +1,14 @@\n+2013-04-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-loop-distribution.c (const_with_all_bytes_same): New function.\n+\t(generate_memset_builtin): Only handle integer_all_onesp as -1 val if\n+\tTYPE_PRECISION is equal to mode bitsize.  Use const_with_all_bytes_same\n+\tif possible to compute val.\n+\t(classify_partition): Verify CONSTRUCTOR doesn't have any elts.\n+\tFor QImode integers don't require anything about precision.  Use\n+\tconst_with_all_bytes_same to find out if the constant doesn't have\n+\trepeated bytes in it.\n+\n 2013-04-08  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* config/s390/s390.c (s390_expand_insv): Only accept insertions"}, {"sha": "ad15b184e6f4d657297282c6ea274b84736c7e08", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/401f3a81a6744d27083b8dc65460b5b3e37d3c3a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/401f3a81a6744d27083b8dc65460b5b3e37d3c3a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=401f3a81a6744d27083b8dc65460b5b3e37d3c3a", "patch": "@@ -1,3 +1,9 @@\n+2013-04-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/pr56837.c: New test.\n+\t* gcc.dg/tree-ssa/ldist-19.c: Don't check for\n+\t\"generated memset minus one\".\n+\n 2013-04-07  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/56849"}, {"sha": "d665a6db7ff3da155c59ef7cfb115b3f8a1b1433", "filename": "gcc/testsuite/gcc.dg/pr56837.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/401f3a81a6744d27083b8dc65460b5b3e37d3c3a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56837.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/401f3a81a6744d27083b8dc65460b5b3e37d3c3a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56837.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56837.c?ref=401f3a81a6744d27083b8dc65460b5b3e37d3c3a", "patch": "@@ -0,0 +1,67 @@\n+/* Limit this test to selected targets with IEEE double, 8-byte long long,\n+   supported 4x int vectors, 4-byte int.  */\n+/* { dg-do compile { target { i?86-*-* x86_64-*-* powerpc*-*-* } } } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+/* { dg-additional-options \"-msse2\" { target ia32 } } */\n+/* { dg-additional-options \"-mvsx -maltivec\" { target powerpc*-*-* } } */\n+\n+typedef int V __attribute__((__vector_size__ (16)));\n+#define N 1024\n+double d[N];\n+long long int l[N];\n+_Bool b[N];\n+_Complex double c[N];\n+V v[N];\n+\n+void\n+fd (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    d[i] = 747708026454360457216.0;\n+}\n+\n+void\n+fl (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    l[i] = 0x7c7c7c7c7c7c7c7cULL;\n+}\n+\n+void\n+fb (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    b[i] = 1;\n+}\n+\n+void\n+fc (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    c[i] = 747708026454360457216.0 + 747708026454360457216.0i;\n+}\n+\n+void\n+fv (void)\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    v[i] = (V) { 0x12121212, 0x12121212, 0x12121212, 0x12121212 };\n+}\n+\n+/* Look for\n+  __builtin_memset (&d, 68, 8192);\n+  __builtin_memset (&l, 124, 8192);\n+  __builtin_memset (&b, 1, 1024);\n+  __builtin_memset (&c, 68, 16384);\n+  __builtin_memset (&v, 18, 16384); */\n+/* { dg-final { scan-tree-dump-times \"memset ..d, 68, 8192.;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"memset ..l, 124, 8192.;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"memset ..b, 1, 1024.;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"memset ..c, 68, 16384.;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"memset ..v, 18, 16384.;\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "8ea9ceaef5d71165523667ecf410cd5408915551", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-19.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/401f3a81a6744d27083b8dc65460b5b3e37d3c3a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/401f3a81a6744d27083b8dc65460b5b3e37d3c3a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-19.c?ref=401f3a81a6744d27083b8dc65460b5b3e37d3c3a", "patch": "@@ -67,6 +67,5 @@ int main()\n }\n \n /* { dg-final { scan-tree-dump-times \"generated memset zero\" 1 \"ldist\" } } */\n-/* { dg-final { scan-tree-dump-times \"generated memset minus one\" 1 \"ldist\" } } */\n /* { dg-final { scan-tree-dump-times \"generated memset\" 5 \"ldist\" } } */\n /* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "668ceec1743473d5a3a9c36eeaf1a9cb0a8f18e3", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 48, "deletions": 32, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/401f3a81a6744d27083b8dc65460b5b3e37d3c3a/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/401f3a81a6744d27083b8dc65460b5b3e37d3c3a/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=401f3a81a6744d27083b8dc65460b5b3e37d3c3a", "patch": "@@ -297,6 +297,36 @@ build_addr_arg_loc (location_t loc, data_reference_p dr, tree nb_bytes)\n   return fold_build_pointer_plus_loc (loc, DR_BASE_ADDRESS (dr), addr_base);\n }\n \n+/* If VAL memory representation contains the same value in all bytes,\n+   return that value, otherwise return -1.\n+   E.g. for 0x24242424 return 0x24, for IEEE double\n+   747708026454360457216.0 return 0x44, etc.  */\n+\n+static int\n+const_with_all_bytes_same (tree val)\n+{\n+  unsigned char buf[64];\n+  int i, len;\n+\n+  if (integer_zerop (val)\n+      || real_zerop (val)\n+      || (TREE_CODE (val) == CONSTRUCTOR\n+          && !TREE_CLOBBER_P (val)\n+          && CONSTRUCTOR_NELTS (val) == 0))\n+    return 0;\n+\n+  if (CHAR_BIT != 8 || BITS_PER_UNIT != 8)\n+    return -1;\n+\n+  len = native_encode_expr (val, buf, sizeof (buf));\n+  if (len == 0)\n+    return -1;\n+  for (i = 1; i < len; i++)\n+    if (buf[i] != buf[0])\n+      return -1;\n+  return buf[0];\n+}\n+\n /* Generate a call to memset for PARTITION in LOOP.  */\n \n static void\n@@ -327,24 +357,20 @@ generate_memset_builtin (struct loop *loop, partition_t partition)\n \n   /* This exactly matches the pattern recognition in classify_partition.  */\n   val = gimple_assign_rhs1 (stmt);\n-  if (integer_zerop (val)\n-      || real_zerop (val)\n-      || TREE_CODE (val) == CONSTRUCTOR)\n-    val = integer_zero_node;\n-  else if (integer_all_onesp (val))\n-    val = build_int_cst (integer_type_node, -1);\n-  else\n+  /* Handle constants like 0x15151515 and similarly\n+     floating point constants etc. where all bytes are the same.  */\n+  int bytev = const_with_all_bytes_same (val);\n+  if (bytev != -1)\n+    val = build_int_cst (integer_type_node, bytev);\n+  else if (TREE_CODE (val) == INTEGER_CST)\n+    val = fold_convert (integer_type_node, val);\n+  else if (!useless_type_conversion_p (integer_type_node, TREE_TYPE (val)))\n     {\n-      if (TREE_CODE (val) == INTEGER_CST)\n-\tval = fold_convert (integer_type_node, val);\n-      else if (!useless_type_conversion_p (integer_type_node, TREE_TYPE (val)))\n-\t{\n-\t  gimple cstmt;\n-\t  tree tem = make_ssa_name (integer_type_node, NULL);\n-\t  cstmt = gimple_build_assign_with_ops (NOP_EXPR, tem, val, NULL_TREE);\n-\t  gsi_insert_after (&gsi, cstmt, GSI_CONTINUE_LINKING);\n-\t  val = tem;\n-\t}\n+      gimple cstmt;\n+      tree tem = make_ssa_name (integer_type_node, NULL);\n+      cstmt = gimple_build_assign_with_ops (NOP_EXPR, tem, val, NULL_TREE);\n+      gsi_insert_after (&gsi, cstmt, GSI_CONTINUE_LINKING);\n+      val = tem;\n     }\n \n   fn = build_fold_addr_expr (builtin_decl_implicit (BUILT_IN_MEMSET));\n@@ -354,10 +380,8 @@ generate_memset_builtin (struct loop *loop, partition_t partition)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"generated memset\");\n-      if (integer_zerop (val))\n+      if (bytev == 0)\n \tfprintf (dump_file, \" zero\\n\");\n-      else if (integer_all_onesp (val))\n-\tfprintf (dump_file, \" minus one\\n\");\n       else\n \tfprintf (dump_file, \"\\n\");\n     }\n@@ -941,18 +965,10 @@ classify_partition (loop_p loop, struct graph *rdg, partition_t partition)\n     {\n       gimple stmt = DR_STMT (single_store);\n       tree rhs = gimple_assign_rhs1 (stmt);\n-      if (!(integer_zerop (rhs)\n-\t    || real_zerop (rhs)\n-\t    || (TREE_CODE (rhs) == CONSTRUCTOR\n-\t\t&& !TREE_CLOBBER_P (rhs))\n-\t    || ((integer_all_onesp (rhs)\n-\t\t || (INTEGRAL_TYPE_P (TREE_TYPE (rhs))\n-\t\t     && (TYPE_MODE (TREE_TYPE (rhs))\n-\t\t\t == TYPE_MODE (unsigned_char_type_node))))\n-\t\t/* For stores of a non-zero value require that the precision\n-\t\t   of the value matches its actual size.  */\n-\t\t&& (TYPE_PRECISION (TREE_TYPE (rhs))\n-\t\t    == GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (rhs)))))))\n+      if (const_with_all_bytes_same (rhs) == -1\n+\t  && (!INTEGRAL_TYPE_P (TREE_TYPE (rhs))\n+\t      || (TYPE_MODE (TREE_TYPE (rhs))\n+\t\t  != TYPE_MODE (unsigned_char_type_node))))\n \treturn;\n       if (TREE_CODE (rhs) == SSA_NAME\n \t  && !SSA_NAME_IS_DEFAULT_DEF (rhs)"}]}