{"sha": "f45da49cd603917aef8f93fcd4f2f9258448cb31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ1ZGE0OWNkNjAzOTE3YWVmOGY5M2ZjZDRmMmY5MjU4NDQ4Y2IzMQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-09-05T12:24:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-05T12:24:41Z"}, "message": "pexecute.c: Updates from gcc.\n\n        * pexecute.c: Updates from gcc.  Copy in gcc has been removed.  This\n        is the canonical copy.  Define ISSPACE if !IN_GCC.\n        * alloca.c, vfprintf.c, choose-temp.c, mkstemp.c, getopt.c: Similarly.\n        * getopt1.c, obstack.c: Similarly.\n        * Makefile.in: Build mkstemp.o\n\nFrom-SVN: r22259", "tree": {"sha": "6eb652bd6e49bd3dedefcb075535322c740936f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6eb652bd6e49bd3dedefcb075535322c740936f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f45da49cd603917aef8f93fcd4f2f9258448cb31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f45da49cd603917aef8f93fcd4f2f9258448cb31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f45da49cd603917aef8f93fcd4f2f9258448cb31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f45da49cd603917aef8f93fcd4f2f9258448cb31/comments", "author": null, "committer": null, "parents": [{"sha": "2bdfeefa887fd39b27a2c456d09fbd721fd5278d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bdfeefa887fd39b27a2c456d09fbd721fd5278d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bdfeefa887fd39b27a2c456d09fbd721fd5278d"}], "stats": {"total": 179, "additions": 129, "deletions": 50}, "files": [{"sha": "6da7194b19f90ec9f5bcba213c40268ca6cca9d0", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45da49cd603917aef8f93fcd4f2f9258448cb31/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45da49cd603917aef8f93fcd4f2f9258448cb31/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=f45da49cd603917aef8f93fcd4f2f9258448cb31", "patch": "@@ -3,7 +3,7 @@ Sat Sep  5 03:24:49 1998  Jeffrey A Law  (law@cygnus.com)\n \t* pexecute.c: Updates from gcc.  Copy in gcc has been removed.  This\n \tis the canonical copy.  Define ISSPACE if !IN_GCC.\n \t* alloca.c, vfprintf.c, choose-temp.c, mkstemp.c, getopt.c: Similarly.\n-\t* getopt1.c: Similarly.\n+\t* getopt1.c, obstack.c: Similarly.\n \t* Makefile.in: Build mkstemp.o\n \n Wed Aug 19 14:05:01 1998  Mumit Khan  <khan@xraylith.wisc.edu>"}, {"sha": "bc318b37790eeb1cde7bdcde56fe383c60a9a310", "filename": "libiberty/obstack.c", "status": "modified", "additions": 128, "deletions": 49, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45da49cd603917aef8f93fcd4f2f9258448cb31/libiberty%2Fobstack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45da49cd603917aef8f93fcd4f2f9258448cb31/libiberty%2Fobstack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fobstack.c?ref=f45da49cd603917aef8f93fcd4f2f9258448cb31", "patch": "@@ -1,19 +1,28 @@\n /* obstack.c - subroutines used implicitly by object stack macros\n-   Copyright (C) 1988, 89, 90, 91, 92, 93, 94, 95, 96 Free Software Foundation, Inc.\n+   Copyright (C) 1988,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.\n \n-This program is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option) any\n-later version.\n \n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   NOTE: The canonical source of this file is maintained with the GNU C Library.\n+   Bugs can be reported to bug-glibc@gnu.org.\n \n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+   USA.  */\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n \n #include \"obstack.h\"\n \n@@ -39,23 +48,6 @@ Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #endif\n #endif\n \n-/* CYGNUS LOCAL (not to be elided!) */\n-\n-int\n-_obstack_memory_used (h)\n-     struct obstack *h;\n-{\n-  register struct _obstack_chunk* lp;\n-  register int nbytes = 0;\n-\n-  for (lp = h->chunk; lp != 0; lp = lp->prev)\n-    {\n-      nbytes += lp->limit - (char *) lp;\n-    }\n-  return nbytes;\n-}\n-\n-/* END CYGNUS LOCAL */\n \n #ifndef ELIDE_CODE\n \n@@ -84,6 +76,28 @@ union fooround {long x; double d;};\n #define COPYING_UNIT int\n #endif\n \n+\n+/* The functions allocating more room by calling `obstack_chunk_alloc'\n+   jump to the handler pointed to by `obstack_alloc_failed_handler'.\n+   This variable by default points to the internal function\n+   `print_and_abort'.  */\n+#if defined (__STDC__) && __STDC__\n+static void print_and_abort (void);\n+void (*obstack_alloc_failed_handler) (void) = print_and_abort;\n+#else\n+static void print_and_abort ();\n+void (*obstack_alloc_failed_handler) () = print_and_abort;\n+#endif\n+\n+/* Exit value used when `print_and_abort' is used.  */\n+#if defined __GNU_LIBRARY__ || defined HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifndef EXIT_FAILURE\n+#define EXIT_FAILURE 1\n+#endif\n+int obstack_exit_failure = EXIT_FAILURE;\n+\n /* The non-GNU-C macros copy the obstack into this global variable\n    to avoid multiple evaluation.  */\n \n@@ -95,6 +109,20 @@ struct obstack *_obstack;\n    For free, do not use ?:, since some compilers, like the MIPS compilers,\n    do not allow (expr) ? void : void.  */\n \n+#if defined (__STDC__) && __STDC__\n+#define CALL_CHUNKFUN(h, size) \\\n+  (((h) -> use_extra_arg) \\\n+   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \\\n+   : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))\n+\n+#define CALL_FREEFUN(h, old_chunk) \\\n+  do { \\\n+    if ((h) -> use_extra_arg) \\\n+      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \\\n+    else \\\n+      (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \\\n+  } while (0)\n+#else\n #define CALL_CHUNKFUN(h, size) \\\n   (((h) -> use_extra_arg) \\\n    ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \\\n@@ -107,6 +135,7 @@ struct obstack *_obstack;\n     else \\\n       (*(void (*) ()) (h)->freefun) ((old_chunk)); \\\n   } while (0)\n+#endif\n \n \f\n /* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).\n@@ -123,13 +152,18 @@ _obstack_begin (h, size, alignment, chunkfun, freefun)\n      struct obstack *h;\n      int size;\n      int alignment;\n+#if defined (__STDC__) && __STDC__\n+     POINTER (*chunkfun) (long);\n+     void (*freefun) (void *);\n+#else\n      POINTER (*chunkfun) ();\n      void (*freefun) ();\n+#endif\n {\n   register struct _obstack_chunk *chunk; /* points to new chunk */\n \n   if (alignment == 0)\n-    alignment = DEFAULT_ALIGNMENT;\n+    alignment = (int) DEFAULT_ALIGNMENT;\n   if (size == 0)\n     /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n     {\n@@ -147,25 +181,27 @@ _obstack_begin (h, size, alignment, chunkfun, freefun)\n       size = 4096 - extra;\n     }\n \n+#if defined (__STDC__) && __STDC__\n+  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;\n+  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n+#else\n   h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;\n   h->freefun = freefun;\n+#endif\n   h->chunk_size = size;\n   h->alignment_mask = alignment - 1;\n   h->use_extra_arg = 0;\n \n   chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n   if (!chunk)\n-    {\n-      h->alloc_failed = 1;\n-      return 0;\n-    }\n-  h->alloc_failed = 0;\n+    (*obstack_alloc_failed_handler) ();\n   h->next_free = h->object_base = chunk->contents;\n   h->chunk_limit = chunk->limit\n     = (char *) chunk + h->chunk_size;\n   chunk->prev = 0;\n   /* The initial chunk now contains no empty object.  */\n   h->maybe_empty_object = 0;\n+  h->alloc_failed = 0;\n   return 1;\n }\n \n@@ -174,14 +210,19 @@ _obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)\n      struct obstack *h;\n      int size;\n      int alignment;\n+#if defined (__STDC__) && __STDC__\n+     POINTER (*chunkfun) (POINTER, long);\n+     void (*freefun) (POINTER, POINTER);\n+#else\n      POINTER (*chunkfun) ();\n      void (*freefun) ();\n+#endif\n      POINTER arg;\n {\n   register struct _obstack_chunk *chunk; /* points to new chunk */\n \n   if (alignment == 0)\n-    alignment = DEFAULT_ALIGNMENT;\n+    alignment = (int) DEFAULT_ALIGNMENT;\n   if (size == 0)\n     /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n     {\n@@ -199,26 +240,28 @@ _obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)\n       size = 4096 - extra;\n     }\n \n+#if defined(__STDC__) && __STDC__\n+  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;\n+  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n+#else\n   h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;\n   h->freefun = freefun;\n+#endif\n   h->chunk_size = size;\n   h->alignment_mask = alignment - 1;\n   h->extra_arg = arg;\n   h->use_extra_arg = 1;\n \n   chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n   if (!chunk)\n-    {\n-      h->alloc_failed = 1;\n-      return 0;\n-    }\n-  h->alloc_failed = 0;\n+    (*obstack_alloc_failed_handler) ();\n   h->next_free = h->object_base = chunk->contents;\n   h->chunk_limit = chunk->limit\n     = (char *) chunk + h->chunk_size;\n   chunk->prev = 0;\n   /* The initial chunk now contains no empty object.  */\n   h->maybe_empty_object = 0;\n+  h->alloc_failed = 0;\n   return 1;\n }\n \n@@ -236,9 +279,9 @@ _obstack_newchunk (h, length)\n   register struct _obstack_chunk *old_chunk = h->chunk;\n   register struct _obstack_chunk *new_chunk;\n   register long\tnew_size;\n-  register int obj_size = h->next_free - h->object_base;\n-  register int i;\n-  int already;\n+  register long obj_size = h->next_free - h->object_base;\n+  register long i;\n+  long already;\n \n   /* Compute size for new chunk.  */\n   new_size = (obj_size + length) + (obj_size >> 3) + 100;\n@@ -248,11 +291,7 @@ _obstack_newchunk (h, length)\n   /* Allocate and initialize the new chunk.  */\n   new_chunk = CALL_CHUNKFUN (h, new_size);\n   if (!new_chunk)\n-    {\n-      h->alloc_failed = 1;\n-      return;\n-    }\n-  h->alloc_failed = 0;\n+    (*obstack_alloc_failed_handler) ();\n   h->chunk = new_chunk;\n   new_chunk->prev = old_chunk;\n   new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n@@ -396,6 +435,39 @@ obstack_free (h, obj)\n     abort ();\n }\n \f\n+int\n+_obstack_memory_used (h)\n+     struct obstack *h;\n+{\n+  register struct _obstack_chunk* lp;\n+  register int nbytes = 0;\n+\n+  for (lp = h->chunk; lp != 0; lp = lp->prev)\n+    {\n+      nbytes += lp->limit - (char *) lp;\n+    }\n+  return nbytes;\n+}\n+\f\n+/* Define the error handler.  */\n+#ifndef _\n+# ifdef HAVE_LIBINTL_H\n+#  include <libintl.h>\n+#  ifndef _\n+#   define _(Str) gettext (Str)\n+#  endif\n+# else\n+#  define _(Str) (Str)\n+# endif\n+#endif\n+\n+static void\n+print_and_abort ()\n+{\n+  fputs (_(\"memory exhausted\\n\"), stderr);\n+  exit (obstack_exit_failure);\n+}\n+\f\n #if 0\n /* These are now turned off because the applications do not use it\n    and it uses bcopy via obstack_grow, which causes trouble on sysV.  */\n@@ -434,6 +506,13 @@ int (obstack_room) (obstack)\n   return obstack_room (obstack);\n }\n \n+int (obstack_make_room) (obstack, length)\n+     struct obstack *obstack;\n+     int length;\n+{\n+  return obstack_make_room (obstack, length);\n+}\n+\n void (obstack_grow) (obstack, pointer, length)\n      struct obstack *obstack;\n      POINTER pointer;"}]}