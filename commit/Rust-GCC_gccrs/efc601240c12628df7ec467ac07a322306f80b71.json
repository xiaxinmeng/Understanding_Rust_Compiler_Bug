{"sha": "efc601240c12628df7ec467ac07a322306f80b71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZjNjAxMjQwYzEyNjI4ZGY3ZWM0NjdhYzA3YTMyMjMwNmY4MGI3MQ==", "commit": {"author": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2018-08-29T02:20:44Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2018-08-29T02:20:44Z"}, "message": "Rewrite pic.md to improve medany and pic code size.\n\n\tgcc/\n\t* config/riscv/pic.md: Rewrite.\n\t* config/riscv/riscv.c (riscv_address_insns): Return cost of 3 for\n\tinvalid address.\n\t* config/riscv/riscv.md (ZERO_EXTEND_LOAD): Delete.\n\t(SOFTF, default_load, softload, softstore): New.\n\nFrom-SVN: r263943", "tree": {"sha": "4cd1f1a4e8967308b9b118520ee811f34b07354e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cd1f1a4e8967308b9b118520ee811f34b07354e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efc601240c12628df7ec467ac07a322306f80b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc601240c12628df7ec467ac07a322306f80b71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efc601240c12628df7ec467ac07a322306f80b71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc601240c12628df7ec467ac07a322306f80b71/comments", "author": null, "committer": null, "parents": [{"sha": "37170829c2147718dca6c561172b44cee701c45c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37170829c2147718dca6c561172b44cee701c45c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37170829c2147718dca6c561172b44cee701c45c"}], "stats": {"total": 145, "additions": 99, "deletions": 46}, "files": [{"sha": "c41507662dddf8cd2bdbc4f8fed495eb1b5467a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc601240c12628df7ec467ac07a322306f80b71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc601240c12628df7ec467ac07a322306f80b71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=efc601240c12628df7ec467ac07a322306f80b71", "patch": "@@ -1,3 +1,11 @@\n+2018-08-28  Jim Wilson  <jimw@sifive.com>\n+\n+\t* config/riscv/pic.md: Rewrite.\n+\t* config/riscv/riscv.c (riscv_address_insns): Return cost of 3 for\n+\tinvalid address.\n+\t* config/riscv/riscv.md (ZERO_EXTEND_LOAD): Delete.\n+\t(SOFTF, default_load, softload, softstore): New.\n+\n 2018-08-28  Jeff Law  <law@redhat.com>\n \n \t* fold-const.c (fold_binary_loc): Remove recently added assert."}, {"sha": "942502058e0b923d5f541edba434373ede4b7258", "filename": "gcc/config/riscv/pic.md", "status": "modified", "additions": 71, "deletions": 42, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc601240c12628df7ec467ac07a322306f80b71/gcc%2Fconfig%2Friscv%2Fpic.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc601240c12628df7ec467ac07a322306f80b71/gcc%2Fconfig%2Friscv%2Fpic.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpic.md?ref=efc601240c12628df7ec467ac07a322306f80b71", "patch": "@@ -22,71 +22,100 @@\n ;; Simplify PIC loads to static variables.\n ;; These should go away once we figure out how to emit auipc discretely.\n \n-(define_insn \"*local_pic_load_s<mode>\"\n+(define_insn \"*local_pic_load<mode>\"\n   [(set (match_operand:ANYI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:ANYI (mem:ANYI (match_operand 1 \"absolute_symbolic_operand\" \"\"))))]\n+\t(mem:ANYI (match_operand 1 \"absolute_symbolic_operand\" \"\")))]\n+  \"USE_LOAD_ADDRESS_MACRO (operands[1])\"\n+  \"<default_load>\\t%0,%1\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"*local_pic_load_s<mode>\"\n+  [(set (match_operand:SUPERQI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SUPERQI (mem:SUBX (match_operand 1 \"absolute_symbolic_operand\" \"\"))))]\n   \"USE_LOAD_ADDRESS_MACRO (operands[1])\"\n-  \"<load>\\t%0,%1\"\n+  \"<SUBX:load>\\t%0,%1\"\n   [(set (attr \"length\") (const_int 8))])\n \n (define_insn \"*local_pic_load_u<mode>\"\n-  [(set (match_operand:ZERO_EXTEND_LOAD 0 \"register_operand\" \"=r\")\n-\t(zero_extend:ZERO_EXTEND_LOAD (mem:ZERO_EXTEND_LOAD (match_operand 1 \"absolute_symbolic_operand\" \"\"))))]\n+  [(set (match_operand:SUPERQI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SUPERQI (mem:SUBX (match_operand 1 \"absolute_symbolic_operand\" \"\"))))]\n   \"USE_LOAD_ADDRESS_MACRO (operands[1])\"\n-  \"<load>u\\t%0,%1\"\n+  \"<SUBX:load>u\\t%0,%1\"\n   [(set (attr \"length\") (const_int 8))])\n \n-(define_insn \"*local_pic_load<mode>\"\n-  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+;; We can support ANYF loads into X register if there is no double support\n+;; or if the target is 64-bit.\n+\n+(define_insn \"*local_pic_load<ANYF:mode>\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f,*r\")\n \t(mem:ANYF (match_operand 1 \"absolute_symbolic_operand\" \"\")))\n-   (clobber (match_scratch:DI 2 \"=r\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_64BIT && USE_LOAD_ADDRESS_MACRO (operands[1])\"\n-  \"<load>\\t%0,%1,%2\"\n+   (clobber (match_scratch:P 2 \"=r,X\"))]\n+  \"TARGET_HARD_FLOAT && USE_LOAD_ADDRESS_MACRO (operands[1])\n+   && (!TARGET_DOUBLE_FLOAT || TARGET_64BIT)\"\n+  \"@\n+   <ANYF:load>\\t%0,%1,%2\n+   <softload>\\t%0,%1\"\n   [(set (attr \"length\") (const_int 8))])\n \n-(define_insn \"*local_pic_load<mode>\"\n+;; ??? For a 32-bit target with double float, a DF load into a X reg isn't\n+;; supported.  ld is not valid in that case.  Punt for now.  Maybe add a split\n+;; for this later.\n+\n+(define_insn \"*local_pic_load_32d<ANYF:mode>\"\n   [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n \t(mem:ANYF (match_operand 1 \"absolute_symbolic_operand\" \"\")))\n-   (clobber (match_scratch:SI 2 \"=r\"))]\n-  \"TARGET_HARD_FLOAT && !TARGET_64BIT && USE_LOAD_ADDRESS_MACRO (operands[1])\"\n-  \"<load>\\t%0,%1,%2\"\n+   (clobber (match_scratch:P 2 \"=r\"))]\n+  \"TARGET_HARD_FLOAT && USE_LOAD_ADDRESS_MACRO (operands[1])\n+   && (TARGET_DOUBLE_FLOAT && !TARGET_64BIT)\"\n+  \"<ANYF:load>\\t%0,%1,%2\"\n   [(set (attr \"length\") (const_int 8))])\n \n-(define_insn \"*local_pic_loadu<mode>\"\n-  [(set (match_operand:SUPERQI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SUPERQI (mem:SUBX (match_operand 1 \"absolute_symbolic_operand\" \"\"))))]\n-  \"USE_LOAD_ADDRESS_MACRO (operands[1])\"\n-  \"<load>u\\t%0,%1\"\n+(define_insn \"*local_pic_load_sf<mode>\"\n+  [(set (match_operand:SOFTF 0 \"register_operand\" \"=r\")\n+\t(mem:SOFTF (match_operand 1 \"absolute_symbolic_operand\" \"\")))]\n+  \"!TARGET_HARD_FLOAT && USE_LOAD_ADDRESS_MACRO (operands[1])\"\n+  \"<softload>\\t%0,%1\"\n   [(set (attr \"length\") (const_int 8))])\n \n-(define_insn \"*local_pic_storedi<mode>\"\n-  [(set (mem:ANYI (match_operand 0 \"absolute_symbolic_operand\" \"\"))\n-\t(match_operand:ANYI 1 \"reg_or_0_operand\" \"rJ\"))\n-   (clobber (match_scratch:DI 2 \"=&r\"))]\n-  \"TARGET_64BIT && USE_LOAD_ADDRESS_MACRO (operands[0])\"\n-  \"<store>\\t%z1,%0,%2\"\n-  [(set (attr \"length\") (const_int 8))])\n+;; Simplify PIC stores to static variables.\n+;; These should go away once we figure out how to emit auipc discretely.\n \n-(define_insn \"*local_pic_storesi<mode>\"\n+(define_insn \"*local_pic_store<ANYI:mode>\"\n   [(set (mem:ANYI (match_operand 0 \"absolute_symbolic_operand\" \"\"))\n \t(match_operand:ANYI 1 \"reg_or_0_operand\" \"rJ\"))\n-   (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"!TARGET_64BIT && USE_LOAD_ADDRESS_MACRO (operands[0])\"\n-  \"<store>\\t%z1,%0,%2\"\n+   (clobber (match_scratch:P 2 \"=&r\"))]\n+  \"USE_LOAD_ADDRESS_MACRO (operands[0])\"\n+  \"<ANYI:store>\\t%z1,%0,%2\"\n   [(set (attr \"length\") (const_int 8))])\n \n-(define_insn \"*local_pic_storedi<mode>\"\n+(define_insn \"*local_pic_store<ANYF:mode>\"\n   [(set (mem:ANYF (match_operand 0 \"absolute_symbolic_operand\" \"\"))\n-\t(match_operand:ANYF 1 \"register_operand\" \"f\"))\n-   (clobber (match_scratch:DI 2 \"=r\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_64BIT && USE_LOAD_ADDRESS_MACRO (operands[0])\"\n-  \"<store>\\t%1,%0,%2\"\n+\t(match_operand:ANYF 1 \"register_operand\" \"f,*r\"))\n+   (clobber (match_scratch:P 2 \"=r,&r\"))]\n+  \"TARGET_HARD_FLOAT && USE_LOAD_ADDRESS_MACRO (operands[0])\n+   && (!TARGET_DOUBLE_FLOAT || TARGET_64BIT)\"\n+  \"@\n+   <ANYF:store>\\t%1,%0,%2\n+   <softstore>\\t%1,%0,%2\"\n   [(set (attr \"length\") (const_int 8))])\n \n-(define_insn \"*local_pic_storesi<mode>\"\n-  [(set (mem:ANYF (match_operand 0 \"absolute_symbolic_operand\" \"\"))\n-\t(match_operand:ANYF 1 \"register_operand\" \"f\"))\n-   (clobber (match_scratch:SI 2 \"=r\"))]\n-  \"TARGET_HARD_FLOAT && !TARGET_64BIT && USE_LOAD_ADDRESS_MACRO (operands[0])\"\n-  \"<store>\\t%1,%0,%2\"\n+;; ??? For a 32-bit target with double float, a DF store from a X reg isn't\n+;; supported.  sd is not valid in that case.  Punt for now.  Maybe add a split\n+;; for this later.\n+\n+(define_insn \"*local_pic_store_32d<ANYF:mode>\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(mem:ANYF (match_operand 1 \"absolute_symbolic_operand\" \"\")))\n+   (clobber (match_scratch:P 2 \"=r\"))]\n+  \"TARGET_HARD_FLOAT && USE_LOAD_ADDRESS_MACRO (operands[1])\n+   && (TARGET_DOUBLE_FLOAT && !TARGET_64BIT)\"\n+  \"<ANYF:store>\\t%1,%0,%2\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"*local_pic_store_sf<SOFTF:mode>\"\n+  [(set (mem:SOFTF (match_operand 0 \"absolute_symbolic_operand\" \"\"))\n+\t(match_operand:SOFTF 1 \"register_operand\" \"r\"))\n+   (clobber (match_scratch:P 2 \"=&r\"))]\n+  \"!TARGET_HARD_FLOAT && USE_LOAD_ADDRESS_MACRO (operands[0])\"\n+  \"<softstore>\\t%1,%0,%2\"\n   [(set (attr \"length\") (const_int 8))])"}, {"sha": "9d6d981a42aab86912dbfde787cf95404a2da39e", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc601240c12628df7ec467ac07a322306f80b71/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc601240c12628df7ec467ac07a322306f80b71/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=efc601240c12628df7ec467ac07a322306f80b71", "patch": "@@ -802,7 +802,13 @@ riscv_address_insns (rtx x, machine_mode mode, bool might_split_p)\n   int n = 1;\n \n   if (!riscv_classify_address (&addr, x, mode, false))\n-    return 0;\n+    {\n+      /* This could be a pattern from the pic.md file.  In which case we want\n+\t this address to always have a cost of 3 to make it as expensive as the\n+\t most expensive symbol.  This prevents constant propagation from\n+\t preferring symbols over register plus offset.  */\n+      return 3;\n+    }\n \n   /* BLKmode is used for single unaligned loads and stores and should\n      not count as a multiword mode. */"}, {"sha": "95fbb282c7cccdff33e9c629388239903f8c142e", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efc601240c12628df7ec467ac07a322306f80b71/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efc601240c12628df7ec467ac07a322306f80b71/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=efc601240c12628df7ec467ac07a322306f80b71", "patch": "@@ -269,9 +269,6 @@\n ;; Iterator for QImode extension patterns.\n (define_mode_iterator SUPERQI [HI SI (DI \"TARGET_64BIT\")])\n \n-;; Iterator for extending loads.\n-(define_mode_iterator ZERO_EXTEND_LOAD [QI HI (SI \"TARGET_64BIT\")])\n-\n ;; Iterator for hardware integer modes narrower than XLEN.\n (define_mode_iterator SUBX [QI HI (SI \"TARGET_64BIT\")])\n \n@@ -282,16 +279,29 @@\n (define_mode_iterator ANYF [(SF \"TARGET_HARD_FLOAT\")\n \t\t\t    (DF \"TARGET_DOUBLE_FLOAT\")])\n \n+;; Iterator for floating-point modes that can be loaded into X registers.\n+(define_mode_iterator SOFTF [SF (DF \"TARGET_64BIT\")])\n+\n ;; This attribute gives the length suffix for a sign- or zero-extension\n ;; instruction.\n (define_mode_attr size [(QI \"b\") (HI \"h\")])\n \n ;; Mode attributes for loads.\n (define_mode_attr load [(QI \"lb\") (HI \"lh\") (SI \"lw\") (DI \"ld\") (SF \"flw\") (DF \"fld\")])\n \n+;; Instruction names for integer loads that aren't explicitly sign or zero\n+;; extended.  See riscv_output_move and LOAD_EXTEND_OP.\n+(define_mode_attr default_load [(QI \"lbu\") (HI \"lhu\") (SI \"lw\") (DI \"ld\")])\n+\n+;; Mode attribute for FP loads into integer registers.\n+(define_mode_attr softload [(SF \"lw\") (DF \"ld\")])\n+\n ;; Instruction names for stores.\n (define_mode_attr store [(QI \"sb\") (HI \"sh\") (SI \"sw\") (DI \"sd\") (SF \"fsw\") (DF \"fsd\")])\n \n+;; Instruction names for FP stores from integer registers.\n+(define_mode_attr softstore [(SF \"sw\") (DF \"sd\")])\n+\n ;; This attribute gives the best constraint to use for registers of\n ;; a given mode.\n (define_mode_attr reg [(SI \"d\") (DI \"d\") (CC \"d\")])"}]}