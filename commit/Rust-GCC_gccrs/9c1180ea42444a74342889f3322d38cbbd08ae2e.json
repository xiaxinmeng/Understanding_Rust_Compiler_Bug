{"sha": "9c1180ea42444a74342889f3322d38cbbd08ae2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWMxMTgwZWE0MjQ0NGE3NDM0Mjg4OWYzMzIyZDM4Y2JiZDA4YWUyZQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2002-12-03T22:06:31Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2002-12-03T22:06:31Z"}, "message": "JarFile.java (manifest): Not final.\n\n        * java/util/jar/JarFile.java (manifest): Not final.\n        (manifestRead): New field.\n        (JarFile): Don't read Manifest in constructor.\n        (getManifest): New method.\n        (JarEnumeration.nextElement): Use new method.\n        (getEntry): Likewise.\n        * java/util/zip/ZipFile.java (name): Final.\n        (raf): Likewsie.\n        (entries): Change type to Hashtable.\n        (closed): New field.\n        (ZipFile): Don't read enties in constructor.\n        (readEntries): Use Hashtable.\n        (close): Set new close flag and set entries to null inside\n        synchronized block.\n        (entries): Contruct enumeration using new getEntries() method and\n        entries Hashtable.\n        (getEntryIndex): Removed.\n        (getEntries): New method.\n        (getEntry): Use new getEntries() method and entries Hastable.\n        (getInputStream): Likewise.\n        (size): Return getEntries().size().\n        (ZipEntryEnumeration): Wrap entries Hashtable elements.\n        * java/util/zip/ZipEntry.java (cal): Don't initialize.\n        (time): Removed\n        (dostime): New field.\n        (zipFileIndex): Removed.\n        (ZipEntry(ZipEntry)): Copy dostime.\n        (setDOSTime): Now final and doesn't convert dos time.\n        (getDOSTime): Likewise.\n        (setTime): Convert dos time.\n        (getTime): Likewise.\n        (getCalendar): New method.\n        (setExtra): Use setTime().\n        * java/util/zip/ZipInputStream.java (getNextEntry): Format error msg.\n\nFrom-SVN: r59785", "tree": {"sha": "730056898d88a253ce543c7b06b7c20328b734b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/730056898d88a253ce543c7b06b7c20328b734b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c1180ea42444a74342889f3322d38cbbd08ae2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c1180ea42444a74342889f3322d38cbbd08ae2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c1180ea42444a74342889f3322d38cbbd08ae2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c1180ea42444a74342889f3322d38cbbd08ae2e/comments", "author": null, "committer": null, "parents": [{"sha": "6e1be6b19c65ea41fa3772c835477d59429f94a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e1be6b19c65ea41fa3772c835477d59429f94a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e1be6b19c65ea41fa3772c835477d59429f94a3"}], "stats": {"total": 345, "additions": 217, "deletions": 128}, "files": [{"sha": "0fb8c6ab920443ec97b91c0a004e6c40bc880b4b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c1180ea42444a74342889f3322d38cbbd08ae2e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c1180ea42444a74342889f3322d38cbbd08ae2e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9c1180ea42444a74342889f3322d38cbbd08ae2e", "patch": "@@ -1,3 +1,40 @@\n+2002-12-03  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/util/jar/JarFile.java (manifest): Not final.\n+\t(manifestRead): New field.\n+\t(JarFile): Don't read Manifest in constructor.\n+\t(getManifest): New method.\n+\t(JarEnumeration.nextElement): Use new method.\n+\t(getEntry): Likewise.\n+\t* java/util/zip/ZipFile.java (name): Final.\n+\t(raf): Likewsie.\n+\t(entries): Change type to Hashtable.\n+\t(closed): New field.\n+\t(ZipFile): Don't read enties in constructor.\n+\t(readEntries): Use Hashtable.\n+\t(close): Set new close flag and set entries to null inside\n+\tsynchronized block.\n+\t(entries): Contruct enumeration using new getEntries() method and\n+\tentries Hashtable.\n+\t(getEntryIndex): Removed.\n+\t(getEntries): New method.\n+\t(getEntry): Use new getEntries() method and entries Hastable.\n+\t(getInputStream): Likewise.\n+\t(size): Return getEntries().size().\n+\t(ZipEntryEnumeration): Wrap entries Hashtable elements.\n+\t* java/util/zip/ZipEntry.java (cal): Don't initialize.\n+\t(time): Removed\n+\t(dostime): New field.\n+\t(zipFileIndex): Removed.\n+\t(ZipEntry(ZipEntry)): Copy dostime.\n+\t(setDOSTime): Now final and doesn't convert dos time.\n+\t(getDOSTime): Likewise.\n+\t(setTime): Convert dos time.\n+\t(getTime): Likewise.\n+\t(getCalendar): New method.\n+\t(setExtra): Use setTime().\n+\t* java/util/zip/ZipInputStream.java (getNextEntry): Format error msg.\n+\n 2002-12-03  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/Character.java (forDigit): Formatting fix."}, {"sha": "d6fd9846b6ee9ba969bdcf65872d752460886c2c", "filename": "libjava/java/util/jar/JarFile.java", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c1180ea42444a74342889f3322d38cbbd08ae2e/libjava%2Fjava%2Futil%2Fjar%2FJarFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c1180ea42444a74342889f3322d38cbbd08ae2e/libjava%2Fjava%2Futil%2Fjar%2FJarFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FJarFile.java?ref=9c1180ea42444a74342889f3322d38cbbd08ae2e", "patch": "@@ -67,18 +67,22 @@ public class JarFile extends ZipFile\n \n   /**\n    * The manifest of this file, if any, otherwise null.\n-   * Read by the constructor.\n+   * Read when first needed.\n    */\n-  private final Manifest manifest;\n+  private Manifest manifest;\n \n-  /** Wether to verify the manifest and all entries */\n+  /** Wether to verify the manifest and all entries. */\n   private boolean verify;\n \n+  /** Wether the has already been loaded. */\n+  private boolean manifestRead = false;\n+\n   // Constructors\n \n   /**\n-   * Creates a new JarFile, tries to read the manifest and if the manifest\n-   * exists verifies it.\n+   * Creates a new JarFile. All jar entries are verified (when a Manifest file\n+   * for this JarFile exists). You need to actually open and read the complete\n+   * jar entry (with <code>getInputStream()</code>) to check its signature.\n    *\n    * @param fileName the name of the file to open\n    * @exception FileNotFoundException if the fileName cannot be found\n@@ -90,8 +94,10 @@ public JarFile(String fileName) throws FileNotFoundException, IOException\n   }\n \n   /**\n-   * Creates a new JarFile, tries to read the manifest and if the manifest\n-   * exists and verify is true verfies it.\n+   * Creates a new JarFile. If verify is true then all jar entries are\n+   * verified (when a Manifest file for this JarFile exists). You need to\n+   * actually open and read the complete jar entry\n+   * (with <code>getInputStream()</code>) to check its signature.\n    *\n    * @param fileName the name of the file to open\n    * @param verify checks manifest and entries when true and a manifest\n@@ -103,14 +109,12 @@ public JarFile(String fileName, boolean verify) throws\n     FileNotFoundException, IOException\n   {\n     super(fileName);\n-    manifest = readManifest();\n-    if (verify)\n-      verify();\n   }\n \n   /**\n-   * Creates a new JarFile, tries to read the manifest and if the manifest\n-   * exists verifies it.\n+   * Creates a new JarFile. All jar entries are verified (when a Manifest file\n+   * for this JarFile exists). You need to actually open and read the complete\n+   * jar entry (with <code>getInputStream()</code>) to check its signature.\n    *\n    * @param file the file to open as a jar file\n    * @exception FileNotFoundException if the file does not exits\n@@ -122,8 +126,10 @@ public JarFile(File file) throws FileNotFoundException, IOException\n   }\n \n   /**\n-   * Creates a new JarFile, tries to read the manifest and if the manifest\n-   * exists and verify is true verfies it.\n+   * Creates a new JarFile. If verify is true then all jar entries are\n+   * verified (when a Manifest file for this JarFile exists). You need to\n+   * actually open and read the complete jar entry\n+   * (with <code>getInputStream()</code>) to check its signature.\n    *\n    * @param file the file to open to open as a jar file\n    * @param verify checks manifest and entries when true and a manifest\n@@ -135,13 +141,13 @@ public JarFile(File file, boolean verify) throws FileNotFoundException,\n     IOException\n   {\n     super(file);\n-    manifest = readManifest();\n-    if (verify)\n-      verify();\n   }\n \n   /**\n-   * Creates a new JarFile with the indicated mode, tries to read the\n+   * Creates a new JarFile with the indicated mode. If verify is true then\n+   * all jar entries are verified (when a Manifest file for this JarFile\n+   * exists). You need to actually open and read the complete jar entry\n+   * (with <code>getInputStream()</code>) to check its signature.\n    * manifest and if the manifest exists and verify is true verfies it.\n    *\n    * @param file the file to open to open as a jar file\n@@ -159,9 +165,6 @@ public JarFile(File file, boolean verify, int mode) throws\n     FileNotFoundException, IOException, IllegalArgumentException\n   {\n     super(file, mode);\n-    manifest = readManifest();\n-    if (verify)\n-      verify();\n   }\n \n   // Methods\n@@ -241,6 +244,16 @@ public Object nextElement()\n     {\n       ZipEntry zip = (ZipEntry) entries.nextElement();\n       JarEntry jar = new JarEntry(zip);\n+      Manifest manifest;\n+      try\n+\t{\n+\t  manifest = getManifest();\n+\t}\n+      catch (IOException ioe)\n+\t{\n+\t  manifest = null;\n+\t}\n+\n       if (manifest != null)\n \t{\n \t  jar.attr = manifest.getAttributes(jar.getName());\n@@ -261,6 +274,16 @@ public ZipEntry getEntry(String name)\n     if (entry != null)\n       {\n \tJarEntry jarEntry = new JarEntry(entry);\n+\tManifest manifest;\n+\ttry\n+\t  {\n+\t    manifest = getManifest();\n+\t  }\n+\tcatch (IOException ioe)\n+\t  {\n+\t    manifest = null;\n+\t  }\n+\n \tif (manifest != null)\n \t  {\n \t    jarEntry.attr = manifest.getAttributes(name);\n@@ -301,8 +324,11 @@ public JarEntry getJarEntry(String name)\n    * Returns the manifest for this JarFile or null when the JarFile does not\n    * contain a manifest file.\n    */\n-  public Manifest getManifest()\n+  public Manifest getManifest() throws IOException\n   {\n+    if (!manifestRead)\n+      manifest = readManifest();\n+\n     return manifest;\n   }\n }"}, {"sha": "c9f1b1d7d44374d32ebce863f0d2757fbc088c3e", "filename": "libjava/java/util/zip/ZipEntry.java", "status": "modified", "additions": 56, "deletions": 43, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c1180ea42444a74342889f3322d38cbbd08ae2e/libjava%2Fjava%2Futil%2Fzip%2FZipEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c1180ea42444a74342889f3322d38cbbd08ae2e/libjava%2Fjava%2Futil%2Fzip%2FZipEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipEntry.java?ref=9c1180ea42444a74342889f3322d38cbbd08ae2e", "patch": "@@ -55,19 +55,18 @@ public class ZipEntry implements ZipConstants, Cloneable\n   private static int KNOWN_CRC    = 4;\n   private static int KNOWN_TIME   = 8;\n \n-  private static Calendar cal = Calendar.getInstance();\n+  private static Calendar cal;\n \n   private String name;\n   private int size;\n   private int compressedSize;\n   private int crc;\n-  private int time;\n+  private int dostime;\n   private short known = 0;\n   private short method = -1;\n   private byte[] extra = null;\n   private String comment = null;\n \n-  int zipFileIndex = -1;  /* used by ZipFile */\n   int flags;              /* used by ZipOutputStream */\n   int offset;             /* used by ZipFile and ZipOutputStream */\n \n@@ -104,53 +103,24 @@ public ZipEntry(ZipEntry e)\n     size = e.size;\n     compressedSize = e.compressedSize;\n     crc = e.crc;\n-    time = e.time;\n+    dostime = e.dostime;\n     method = e.method;\n     extra = e.extra;\n     comment = e.comment;\n   }\n \n-  void setDOSTime(int dostime)\n+  final void setDOSTime(int dostime)\n   {\n-    int sec = 2 * (dostime & 0x1f);\n-    int min = (dostime >> 5) & 0x3f;\n-    int hrs = (dostime >> 11) & 0x1f;\n-    int day = (dostime >> 16) & 0x1f;\n-    int mon = ((dostime >> 21) & 0xf) - 1;\n-    int year = ((dostime >> 25) & 0x7f) + 1980; /* since 1900 */\n-    \n-    // Guard against invalid or missing date causing\n-    // IndexOutOfBoundsException.\n-    try\n-      {\n-\tsynchronized (cal)\n-\t  {\n-\t    cal.set(year, mon, day, hrs, min, sec);\n-\t    time = (int) (cal.getTime().getTime() / 1000L);\n-\t  }\n-\tknown |= KNOWN_TIME;\n-      }\n-    catch (RuntimeException ex)\n-      {\n-\t/* Ignore illegal time stamp */\n-\tknown &= ~KNOWN_TIME;\n-      }\n+    this.dostime = dostime;\n+    known |= KNOWN_TIME;\n   }\n \n-  int getDOSTime()\n+  final int getDOSTime()\n   {\n     if ((known & KNOWN_TIME) == 0)\n       return 0;\n-    synchronized (cal)\n-      {\n-\tcal.setTime(new Date(time*1000L));\n-\treturn (cal.get(cal.YEAR) - 1980 & 0x7f) << 25\n-\t  | (cal.get(cal.MONTH) + 1) << 21\n-\t  | (cal.get(cal.DAY_OF_MONTH)) << 16\n-\t  | (cal.get(cal.HOUR_OF_DAY)) << 11\n-\t  | (cal.get(cal.MINUTE)) << 5\n-\t  | (cal.get(cal.SECOND)) >> 1;\n-      }\n+    else\n+      return dostime;\n   }\n \n   /**\n@@ -190,7 +160,18 @@ public String getName()\n    */\n   public void setTime(long time)\n   {\n-    this.time = (int) (time / 1000L);\n+    Calendar cal = getCalendar();\n+    synchronized (cal)\n+      {\n+\tcal.setTime(new Date(time*1000L));\n+\tdostime = (cal.get(cal.YEAR) - 1980 & 0x7f) << 25\n+\t  | (cal.get(cal.MONTH) + 1) << 21\n+\t  | (cal.get(cal.DAY_OF_MONTH)) << 16\n+\t  | (cal.get(cal.HOUR_OF_DAY)) << 11\n+\t  | (cal.get(cal.MINUTE)) << 5\n+\t  | (cal.get(cal.SECOND)) >> 1;\n+      }\n+    dostime = (int) (dostime / 1000L);\n     this.known |= KNOWN_TIME;\n   }\n \n@@ -200,7 +181,39 @@ public void setTime(long time)\n    */\n   public long getTime()\n   {\n-    return (known & KNOWN_TIME) != 0 ? time * 1000L : -1;\n+    if ((known & KNOWN_TIME) == 0)\n+      return -1;\n+    \n+    int sec = 2 * (dostime & 0x1f);\n+    int min = (dostime >> 5) & 0x3f;\n+    int hrs = (dostime >> 11) & 0x1f;\n+    int day = (dostime >> 16) & 0x1f;\n+    int mon = ((dostime >> 21) & 0xf) - 1;\n+    int year = ((dostime >> 25) & 0x7f) + 1980; /* since 1900 */\n+   \n+    try\n+      {\n+\tcal = getCalendar();\n+\tsynchronized (cal)\n+\t  {\n+\t    cal.set(year, mon, day, hrs, min, sec);\n+\t    return cal.getTime().getTime();\n+\t  }\n+      }\n+    catch (RuntimeException ex)\n+      {\n+\t/* Ignore illegal time stamp */\n+\tknown &= ~KNOWN_TIME;\n+\treturn -1;\n+      }\n+  }\n+\n+  private static synchronized Calendar getCalendar()\n+  {\n+    if (cal == null)\n+      cal = Calendar.getInstance();\n+\n+    return cal;\n   }\n \n   /**\n@@ -320,11 +333,11 @@ public void setExtra(byte[] extra)\n \t\tint flags = extra[pos];\n \t\tif ((flags & 1) != 0)\n \t\t  {\n-\t\t    time = ((extra[pos+1] & 0xff)\n+\t\t    long time = ((extra[pos+1] & 0xff)\n \t\t\t    | (extra[pos+2] & 0xff) << 8\n \t\t\t    | (extra[pos+3] & 0xff) << 16\n \t\t\t    | (extra[pos+4] & 0xff) << 24);\n-\t\t    known |= KNOWN_TIME;\n+\t\t    setTime(time);\n \t\t  }\n \t      }\n \t    pos += len;"}, {"sha": "eb79d03e5941b47f7b5ea98552b25a48ba9bdbba", "filename": "libjava/java/util/zip/ZipFile.java", "status": "modified", "additions": 75, "deletions": 62, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c1180ea42444a74342889f3322d38cbbd08ae2e/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c1180ea42444a74342889f3322d38cbbd08ae2e/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java?ref=9c1180ea42444a74342889f3322d38cbbd08ae2e", "patch": "@@ -46,6 +46,7 @@\n import java.io.EOFException;\n import java.io.RandomAccessFile;\n import java.util.Enumeration;\n+import java.util.Hashtable;\n import java.util.NoSuchElementException;\n \n /**\n@@ -61,21 +62,26 @@\n public class ZipFile implements ZipConstants\n {\n \n-  /** Mode flag to open a zip file for reading \n-   *\n+  /**\n+   * Mode flag to open a zip file for reading.\n    */\n-\n   public static final int OPEN_READ = 0x1;\n \n-  /** Mode flag to delete a zip file after reading \n-   *\n+  /**\n+   * Mode flag to delete a zip file after reading.\n    */\n-\n   public static final int OPEN_DELETE = 0x4;\n \n-  private String name;\n-  RandomAccessFile raf;\n-  ZipEntry[] entries;\n+  // Name of this zip file.\n+  private final String name;\n+\n+  // File from which zip entries are read.\n+  private final RandomAccessFile raf;\n+\n+  // The entries of this zip file when initialized and not yet closed.\n+  private Hashtable entries;\n+\n+  private boolean closed = false;\n \n   /**\n    * Opens a Zip file with the given name for reading.\n@@ -87,7 +93,6 @@ public ZipFile(String name) throws ZipException, IOException\n   {\n     this.raf = new RandomAccessFile(name, \"r\");\n     this.name = name;\n-    readEntries();\n   }\n \n   /**\n@@ -100,7 +105,6 @@ public ZipFile(File file) throws ZipException, IOException\n   {\n     this.raf = new RandomAccessFile(file, \"r\");\n     this.name = file.getName();\n-    readEntries();\n   }\n \n   /**\n@@ -130,7 +134,6 @@ public ZipFile(File file, int mode) throws ZipException, IOException\n       }\n     this.raf = new RandomAccessFile(file, \"r\");\n     this.name = file.getName();\n-    readEntries();\n   }\n \n   /**\n@@ -160,7 +163,7 @@ private final int readLeInt(DataInput di) throws IOException\n \n   /**\n    * Read the central directory of a zip file and fill the entries\n-   * array.  This is called exactly once by the constructors.\n+   * array.  This is called exactly once when first needed.\n    * @exception IOException if a i/o error occured.\n    * @exception ZipException if the central directory is malformed \n    */\n@@ -187,7 +190,7 @@ private void readEntries() throws ZipException, IOException\n       throw new EOFException(name);\n     int centralOffset = readLeInt(raf);\n \n-    entries = new ZipEntry[count];\n+    entries = new Hashtable(count);\n     raf.seek(centralOffset);\n     byte[] ebs  = new byte[24];\n     ByteArrayInputStream ebais = new ByteArrayInputStream(ebs);\n@@ -236,9 +239,8 @@ private void readEntries() throws ZipException, IOException\n \t    raf.readFully(buffer, 0, commentLen);\n \t    entry.setComment(new String(buffer, 0, commentLen));\n \t  }\n-\tentry.zipFileIndex = i;\n \tentry.offset = offset;\n-\tentries[i] = entry;\n+\tentries.put(name, entry);\n       }\n   }\n \n@@ -250,9 +252,10 @@ private void readEntries() throws ZipException, IOException\n    */\n   public void close() throws IOException\n   {\n-    entries = null;\n     synchronized (raf)\n       {\n+\tclosed = true;\n+\tentries = null;\n \traf.close();\n       }\n   }\n@@ -262,17 +265,34 @@ public void close() throws IOException\n    */\n   public Enumeration entries()\n   {\n-    if (entries == null)\n-      throw new IllegalStateException(\"ZipFile has closed: \" + name);\n-    return new ZipEntryEnumeration(entries);\n+    try\n+      {\n+\treturn new ZipEntryEnumeration(getEntries().elements());\n+      }\n+    catch (IOException ioe)\n+      {\n+\treturn null;\n+      }\n   }\n \n-  private int getEntryIndex(String name)\n+  /**\n+   * Checks that the ZipFile is still open and reads entries when necessary.\n+   *\n+   * @exception IllegalStateException when the ZipFile has already been closed.\n+   * @exception IOEexception when the entries could not be read.\n+   */\n+  private Hashtable getEntries() throws IOException\n   {\n-    for (int i = 0; i < entries.length; i++)\n-      if (name.equals(entries[i].getName()))\n-\treturn i;\n-    return -1;\n+    synchronized(raf)\n+      {\n+\tif (closed)\n+\t  throw new IllegalStateException(\"ZipFile has closed: \" + name);\n+\n+\tif (entries == null)\n+\t  readEntries();\n+\n+\treturn entries;\n+      }\n   }\n \n   /**\n@@ -283,10 +303,16 @@ private int getEntryIndex(String name)\n    * @see #entries */\n   public ZipEntry getEntry(String name)\n   {\n-    if (entries == null)\n-      throw new IllegalStateException(\"ZipFile has closed: \" + name);\n-    int index = getEntryIndex(name);\n-    return index >= 0 ? (ZipEntry) entries[index].clone() : null;\n+    try\n+      {\n+\tHashtable entries = getEntries();\n+\tZipEntry entry = (ZipEntry) entries.get(name);\n+\treturn entry != null ? (ZipEntry) entry.clone() : null;\n+      }\n+    catch (IOException ioe)\n+      {\n+\treturn null;\n+      }\n   }\n \n   /**\n@@ -334,21 +360,16 @@ private long checkLocalHeader(ZipEntry entry) throws IOException\n    */\n   public InputStream getInputStream(ZipEntry entry) throws IOException\n   {\n-    if (entries == null)\n-      throw new IllegalStateException(\"ZipFile has closed\");\n-    int index = entry.zipFileIndex;\n-    if (index < 0 || index >= entries.length\n-\t|| entries[index].getName() != entry.getName())\n-      {\n-\tindex = getEntryIndex(entry.getName());\n-\tif (index < 0)\n-\t  throw new NoSuchElementException();\n-      }\n-\n-    long start = checkLocalHeader(entries[index]);\n-    int method = entries[index].getMethod();\n+    Hashtable entries = getEntries();\n+    String name = entry.getName();\n+    ZipEntry zipEntry = (ZipEntry) entries.get(name);\n+    if (zipEntry == null)\n+      throw new NoSuchElementException(name);\n+\n+    long start = checkLocalHeader(zipEntry);\n+    int method = zipEntry.getMethod();\n     InputStream is = new PartialInputStream\n-      (raf, start, entries[index].getCompressedSize());\n+      (raf, start, zipEntry.getCompressedSize());\n     switch (method)\n       {\n       case ZipOutputStream.STORED:\n@@ -375,42 +396,34 @@ public int size()\n   {\n     try\n       {\n-\treturn entries.length;\n+\treturn getEntries().size();\n       }\n-    catch (NullPointerException ex)\n+    catch (IOException ioe)\n       {\n-\tthrow new IllegalStateException(\"ZipFile has closed\");\n+\treturn 0;\n       }\n   }\n   \n   private static class ZipEntryEnumeration implements Enumeration\n   {\n-    ZipEntry[] array;\n-    int ptr = 0;\n+    private final Enumeration elements;\n \n-    public ZipEntryEnumeration(ZipEntry[] arr)\n+    public ZipEntryEnumeration(Enumeration elements)\n     {\n-      array = arr;\n+      this.elements = elements;\n     }\n \n     public boolean hasMoreElements()\n     {\n-      return ptr < array.length;\n+      return elements.hasMoreElements();\n     }\n \n     public Object nextElement()\n     {\n-      try\n-\t{\n-\t  /* We return a clone, just to be safe that the user doesn't\n-\t   * change the entry.  \n-\t   */\n-\t  return array[ptr++].clone();\n-\t}\n-      catch (ArrayIndexOutOfBoundsException ex)\n-\t{\n-\t  throw new NoSuchElementException();\n-\t}\n+      /* We return a clone, just to be safe that the user doesn't\n+       * change the entry.  \n+       */\n+      return ((ZipEntry)elements.nextElement()).clone();\n     }\n   }\n "}, {"sha": "c4905978d748fbf03c477df87e3246555fd9356c", "filename": "libjava/java/util/zip/ZipInputStream.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c1180ea42444a74342889f3322d38cbbd08ae2e/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c1180ea42444a74342889f3322d38cbbd08ae2e/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java?ref=9c1180ea42444a74342889f3322d38cbbd08ae2e", "patch": "@@ -151,7 +151,7 @@ public ZipEntry getNextEntry() throws IOException\n \treturn null;\n       }\n     if (header != LOCSIG)\n-      throw new ZipException(\"Wrong Local header signature\"\n+      throw new ZipException(\"Wrong Local header signature: \"\n \t\t\t     + Integer.toHexString(header));\n     /* skip version */\n     readLeShort();"}]}