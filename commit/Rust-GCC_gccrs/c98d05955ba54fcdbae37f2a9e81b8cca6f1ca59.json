{"sha": "c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk4ZDA1OTU1YmE1NGZjZGJhZTM3ZjJhOWU4MWI4Y2NhNmYxY2E1OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:21:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:21:45Z"}, "message": "[08/46] Add vec_info::lookup_def\n\nThis patch adds a vec_info helper for checking whether an operand is an\nSSA_NAME that is defined in the vectorisable region.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vec_info::lookup_def): Declare.\n\t* tree-vectorizer.c (vec_info::lookup_def): New function.\n\t* tree-vect-patterns.c (vect_get_internal_def): Use it.\n\t(vect_widened_op_tree): Likewise.\n\t* tree-vect-stmts.c (vect_is_simple_use): Likewise.\n\t* tree-vect-loop.c (vect_analyze_loop_operations): Likewise.\n\t(vectorizable_reduction): Likewise.\n\t(vect_valid_reduction_input_p): Take a stmt_vec_info instead\n\tof a gimple *.\n\t(vect_is_slp_reduction): Update calls accordingly.  Use\n\tvec_info::lookup_def.\n\t(vect_is_simple_reduction): Likewise\n\t* tree-vect-slp.c (vect_detect_hybrid_slp_1): Use vec_info::lookup_def.\n\nFrom-SVN: r263123", "tree": {"sha": "95f219682b2ae0c794bd3e824106dcd8939d555c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95f219682b2ae0c794bd3e824106dcd8939d555c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6585ff8f3a55bbfed6a4f2c2addac7a27ed087d3"}], "stats": {"total": 163, "additions": 81, "deletions": 82}, "files": [{"sha": "7d62e270973ce07e6bf4771e14f809b30627105d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59", "patch": "@@ -1,3 +1,19 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vec_info::lookup_def): Declare.\n+\t* tree-vectorizer.c (vec_info::lookup_def): New function.\n+\t* tree-vect-patterns.c (vect_get_internal_def): Use it.\n+\t(vect_widened_op_tree): Likewise.\n+\t* tree-vect-stmts.c (vect_is_simple_use): Likewise.\n+\t* tree-vect-loop.c (vect_analyze_loop_operations): Likewise.\n+\t(vectorizable_reduction): Likewise.\n+\t(vect_valid_reduction_input_p): Take a stmt_vec_info instead\n+\tof a gimple *.\n+\t(vect_is_slp_reduction): Update calls accordingly.  Use\n+\tvec_info::lookup_def.\n+\t(vect_is_simple_reduction): Likewise\n+\t* tree-vect-slp.c (vect_detect_hybrid_slp_1): Use vec_info::lookup_def.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (vec_info::lookup_stmt): Declare."}, {"sha": "856c1985602caabbcde146d47ad68c2d701ff338", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 40, "deletions": 66, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59", "patch": "@@ -1569,26 +1569,19 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n               if (STMT_VINFO_RELEVANT_P (stmt_info))\n                 {\n                   tree phi_op;\n-\t\t  gimple *op_def_stmt;\n \n                   if (gimple_phi_num_args (phi) != 1)\n                     return false;\n \n                   phi_op = PHI_ARG_DEF (phi, 0);\n-                  if (TREE_CODE (phi_op) != SSA_NAME)\n+\t\t  stmt_vec_info op_def_info = loop_vinfo->lookup_def (phi_op);\n+\t\t  if (!op_def_info)\n                     return false;\n \n-                  op_def_stmt = SSA_NAME_DEF_STMT (phi_op);\n-\t\t  if (gimple_nop_p (op_def_stmt)\n-\t\t      || !flow_bb_inside_loop_p (loop, gimple_bb (op_def_stmt))\n-\t\t      || !vinfo_for_stmt (op_def_stmt))\n-                    return false;\n-\n-                  if (STMT_VINFO_RELEVANT (vinfo_for_stmt (op_def_stmt))\n-                        != vect_used_in_outer\n-                      && STMT_VINFO_RELEVANT (vinfo_for_stmt (op_def_stmt))\n-                           != vect_used_in_outer_by_reduction)\n-                    return false;\n+\t\t  if (STMT_VINFO_RELEVANT (op_def_info) != vect_used_in_outer\n+\t\t      && (STMT_VINFO_RELEVANT (op_def_info)\n+\t\t\t  != vect_used_in_outer_by_reduction))\n+\t\t    return false;\n                 }\n \n               continue;\n@@ -2504,20 +2497,19 @@ report_vect_op (dump_flags_t msg_type, gimple *stmt, const char *msg)\n   dump_gimple_stmt (msg_type, TDF_SLIM, stmt, 0);\n }\n \n-/* DEF_STMT occurs in a loop that contains a potential reduction operation.\n-   Return true if the results of DEF_STMT are something that can be\n-   accumulated by such a reduction.  */\n+/* DEF_STMT_INFO occurs in a loop that contains a potential reduction\n+   operation.  Return true if the results of DEF_STMT_INFO are something\n+   that can be accumulated by such a reduction.  */\n \n static bool\n-vect_valid_reduction_input_p (gimple *def_stmt)\n+vect_valid_reduction_input_p (stmt_vec_info def_stmt_info)\n {\n-  stmt_vec_info def_stmt_info = vinfo_for_stmt (def_stmt);\n-  return (is_gimple_assign (def_stmt)\n-\t  || is_gimple_call (def_stmt)\n+  return (is_gimple_assign (def_stmt_info->stmt)\n+\t  || is_gimple_call (def_stmt_info->stmt)\n \t  || STMT_VINFO_DEF_TYPE (def_stmt_info) == vect_induction_def\n-\t  || (gimple_code (def_stmt) == GIMPLE_PHI\n+\t  || (gimple_code (def_stmt_info->stmt) == GIMPLE_PHI\n \t      && STMT_VINFO_DEF_TYPE (def_stmt_info) == vect_internal_def\n-\t      && !is_loop_header_bb_p (gimple_bb (def_stmt))));\n+\t      && !is_loop_header_bb_p (gimple_bb (def_stmt_info->stmt))));\n }\n \n /* Detect SLP reduction of the form:\n@@ -2633,18 +2625,14 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n       if (gimple_assign_rhs2 (next_stmt) == lhs)\n \t{\n \t  tree op = gimple_assign_rhs1 (next_stmt);\n-\t  gimple *def_stmt = NULL;\n-\n-          if (TREE_CODE (op) == SSA_NAME)\n-            def_stmt = SSA_NAME_DEF_STMT (op);\n+\t  stmt_vec_info def_stmt_info = loop_info->lookup_def (op);\n \n \t  /* Check that the other def is either defined in the loop\n \t     (\"vect_internal_def\"), or it's an induction (defined by a\n \t     loop-header phi-node).  */\n-          if (def_stmt\n-\t      && gimple_bb (def_stmt)\n-\t      && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))\n-\t      && vect_valid_reduction_input_p (def_stmt))\n+\t  if (def_stmt_info\n+\t      && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt_info->stmt))\n+\t      && vect_valid_reduction_input_p (def_stmt_info))\n \t    {\n \t      lhs = gimple_assign_lhs (next_stmt);\n \t      next_stmt = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n@@ -2656,18 +2644,14 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n       else\n \t{\n           tree op = gimple_assign_rhs2 (next_stmt);\n-\t  gimple *def_stmt = NULL;\n-\n-          if (TREE_CODE (op) == SSA_NAME)\n-            def_stmt = SSA_NAME_DEF_STMT (op);\n+\t  stmt_vec_info def_stmt_info = loop_info->lookup_def (op);\n \n           /* Check that the other def is either defined in the loop\n             (\"vect_internal_def\"), or it's an induction (defined by a\n             loop-header phi-node).  */\n-          if (def_stmt\n-\t      && gimple_bb (def_stmt)\n-\t      && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))\n-\t      && vect_valid_reduction_input_p (def_stmt))\n+\t  if (def_stmt_info\n+\t      && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt_info->stmt))\n+\t      && vect_valid_reduction_input_p (def_stmt_info))\n   \t    {\n \t      if (dump_enabled_p ())\n \t\t{\n@@ -2896,7 +2880,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n {\n   struct loop *loop = (gimple_bb (phi))->loop_father;\n   struct loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n-  gimple *def_stmt, *def1 = NULL, *def2 = NULL, *phi_use_stmt = NULL;\n+  gimple *def_stmt, *phi_use_stmt = NULL;\n   enum tree_code orig_code, code;\n   tree op1, op2, op3 = NULL_TREE, op4 = NULL_TREE;\n   tree type;\n@@ -3020,7 +3004,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n           return NULL;\n         }\n \n-      def1 = SSA_NAME_DEF_STMT (op1);\n+      gimple *def1 = SSA_NAME_DEF_STMT (op1);\n       if (gimple_bb (def1)\n \t  && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))\n           && loop->inner\n@@ -3178,14 +3162,9 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n      1) integer arithmetic and no trapv\n      2) floating point arithmetic, and special flags permit this optimization\n      3) nested cycle (i.e., outer loop vectorization).  */\n-  if (TREE_CODE (op1) == SSA_NAME)\n-    def1 = SSA_NAME_DEF_STMT (op1);\n-\n-  if (TREE_CODE (op2) == SSA_NAME)\n-    def2 = SSA_NAME_DEF_STMT (op2);\n-\n-  if (code != COND_EXPR\n-      && ((!def1 || gimple_nop_p (def1)) && (!def2 || gimple_nop_p (def2))))\n+  stmt_vec_info def1_info = loop_info->lookup_def (op1);\n+  stmt_vec_info def2_info = loop_info->lookup_def (op2);\n+  if (code != COND_EXPR && !def1_info && !def2_info)\n     {\n       if (dump_enabled_p ())\n \treport_vect_op (MSG_NOTE, def_stmt, \"reduction: no defs for operands: \");\n@@ -3196,22 +3175,22 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n      the other def is either defined in the loop (\"vect_internal_def\"),\n      or it's an induction (defined by a loop-header phi-node).  */\n \n-  if (def2 && def2 == phi\n+  if (def2_info\n+      && def2_info->stmt == phi\n       && (code == COND_EXPR\n-\t  || !def1 || gimple_nop_p (def1)\n-\t  || !flow_bb_inside_loop_p (loop, gimple_bb (def1))\n-\t  || vect_valid_reduction_input_p (def1)))\n+\t  || !def1_info\n+\t  || vect_valid_reduction_input_p (def1_info)))\n     {\n       if (dump_enabled_p ())\n \treport_vect_op (MSG_NOTE, def_stmt, \"detected reduction: \");\n       return def_stmt;\n     }\n \n-  if (def1 && def1 == phi\n+  if (def1_info\n+      && def1_info->stmt == phi\n       && (code == COND_EXPR\n-\t  || !def2 || gimple_nop_p (def2)\n-\t  || !flow_bb_inside_loop_p (loop, gimple_bb (def2))\n-\t  || vect_valid_reduction_input_p (def2)))\n+\t  || !def2_info\n+\t  || vect_valid_reduction_input_p (def2_info)))\n     {\n       if (! nested_in_vect_loop && orig_code != MINUS_EXPR)\n \t{\n@@ -6131,9 +6110,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   bool nested_cycle = false, found_nested_cycle_def = false;\n   bool double_reduc = false;\n   basic_block def_bb;\n-  struct loop * def_stmt_loop, *outer_loop = NULL;\n+  struct loop * def_stmt_loop;\n   tree def_arg;\n-  gimple *def_arg_stmt;\n   auto_vec<tree> vec_oprnds0;\n   auto_vec<tree> vec_oprnds1;\n   auto_vec<tree> vec_oprnds2;\n@@ -6151,7 +6129,6 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   if (nested_in_vect_loop_p (loop, stmt))\n     {\n-      outer_loop = loop;\n       loop = loop->inner;\n       nested_cycle = true;\n     }\n@@ -6731,13 +6708,10 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       def_stmt_loop = def_bb->loop_father;\n       def_arg = PHI_ARG_DEF_FROM_EDGE (reduc_def_stmt,\n                                        loop_preheader_edge (def_stmt_loop));\n-      if (TREE_CODE (def_arg) == SSA_NAME\n-          && (def_arg_stmt = SSA_NAME_DEF_STMT (def_arg))\n-          && gimple_code (def_arg_stmt) == GIMPLE_PHI\n-          && flow_bb_inside_loop_p (outer_loop, gimple_bb (def_arg_stmt))\n-          && vinfo_for_stmt (def_arg_stmt)\n-          && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def_arg_stmt))\n-              == vect_double_reduction_def)\n+      stmt_vec_info def_arg_stmt_info = loop_vinfo->lookup_def (def_arg);\n+      if (def_arg_stmt_info\n+\t  && (STMT_VINFO_DEF_TYPE (def_arg_stmt_info)\n+\t      == vect_double_reduction_def))\n         double_reduc = true;\n     }\n "}, {"sha": "4f9f0924f5119e533d7a9eb6ff5303189e4acbfa", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59", "patch": "@@ -227,14 +227,11 @@ vect_element_precision (unsigned int precision)\n static stmt_vec_info\n vect_get_internal_def (vec_info *vinfo, tree op)\n {\n-  vect_def_type dt;\n-  gimple *def_stmt;\n-  if (TREE_CODE (op) != SSA_NAME\n-      || !vect_is_simple_use (op, vinfo, &dt, &def_stmt)\n-      || dt != vect_internal_def)\n-    return NULL;\n-\n-  return vinfo_for_stmt (def_stmt);\n+  stmt_vec_info def_stmt_info = vinfo->lookup_def (op);\n+  if (def_stmt_info\n+      && STMT_VINFO_DEF_TYPE (def_stmt_info) == vect_internal_def)\n+    return def_stmt_info;\n+  return NULL;\n }\n \n /* Check whether NAME, an ssa-name used in USE_STMT,\n@@ -528,6 +525,7 @@ vect_widened_op_tree (stmt_vec_info stmt_info, tree_code code,\n \t\t      vect_unpromoted_value *unprom, tree *common_type)\n {\n   /* Check for an integer operation with the right code.  */\n+  vec_info *vinfo = stmt_info->vinfo;\n   gassign *assign = dyn_cast <gassign *> (stmt_info->stmt);\n   if (!assign)\n     return 0;\n@@ -584,7 +582,7 @@ vect_widened_op_tree (stmt_vec_info stmt_info, tree_code code,\n \n \t      /* Recursively process the definition of the operand.  */\n \t      stmt_vec_info def_stmt_info\n-\t\t= vinfo_for_stmt (SSA_NAME_DEF_STMT (this_unprom->op));\n+\t\t= vinfo->lookup_def (this_unprom->op);\n \t      nops = vect_widened_op_tree (def_stmt_info, code, widened_code,\n \t\t\t\t\t   shift_p, max_nops, this_unprom,\n \t\t\t\t\t   common_type);"}, {"sha": "78aaa71ccb65aa3ca2f1dd17fcf4a7822c110516", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59", "patch": "@@ -2389,11 +2389,8 @@ vect_detect_hybrid_slp_1 (tree *tp, int *, void *data)\n   if (wi->is_lhs)\n     return NULL_TREE;\n \n-  stmt_vec_info def_stmt_info;\n-  if (TREE_CODE (*tp) == SSA_NAME\n-      && !SSA_NAME_IS_DEFAULT_DEF (*tp)\n-      && (def_stmt_info = loop_vinfo->lookup_stmt (SSA_NAME_DEF_STMT (*tp)))\n-      && PURE_SLP_STMT (def_stmt_info))\n+  stmt_vec_info def_stmt_info = loop_vinfo->lookup_def (*tp);\n+  if (def_stmt_info && PURE_SLP_STMT (def_stmt_info))\n     {\n       if (dump_enabled_p ())\n \t{"}, {"sha": "8f4b66d12c16a53ba7f2005fd4e9657f7148a2c4", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59", "patch": "@@ -10092,11 +10092,11 @@ vect_is_simple_use (tree operand, vec_info *vinfo, enum vect_def_type *dt,\n   else\n     {\n       gimple *def_stmt = SSA_NAME_DEF_STMT (operand);\n-      if (! vect_stmt_in_region_p (vinfo, def_stmt))\n+      stmt_vec_info stmt_vinfo = vinfo->lookup_def (operand);\n+      if (!stmt_vinfo)\n \t*dt = vect_external_def;\n       else\n \t{\n-\t  stmt_vec_info stmt_vinfo = vinfo_for_stmt (def_stmt);\n \t  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n \t    {\n \t      def_stmt = STMT_VINFO_RELATED_STMT (stmt_vinfo);"}, {"sha": "372cf69e35e7c41a1b8be9d22f02ff44e41ae61b", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59", "patch": "@@ -535,6 +535,19 @@ vec_info::lookup_stmt (gimple *stmt)\n   return NULL;\n }\n \n+/* If NAME is an SSA_NAME and its definition has an associated stmt_vec_info,\n+   return that stmt_vec_info, otherwise return null.  It is safe to call\n+   this on arbitrary operands.  */\n+\n+stmt_vec_info\n+vec_info::lookup_def (tree name)\n+{\n+  if (TREE_CODE (name) == SSA_NAME\n+      && !SSA_NAME_IS_DEFAULT_DEF (name))\n+    return lookup_stmt (SSA_NAME_DEF_STMT (name));\n+  return NULL;\n+}\n+\n /* A helper function to free scev and LOOP niter information, as well as\n    clear loop constraint LOOP_C_FINITE.  */\n "}, {"sha": "5b76e45a856b1dc5fc626e3c9c23f0a5c4aae469", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c98d05955ba54fcdbae37f2a9e81b8cca6f1ca59", "patch": "@@ -219,6 +219,7 @@ struct vec_info {\n \n   stmt_vec_info add_stmt (gimple *);\n   stmt_vec_info lookup_stmt (gimple *);\n+  stmt_vec_info lookup_def (tree);\n \n   /* The type of vectorization.  */\n   vec_kind kind;"}]}