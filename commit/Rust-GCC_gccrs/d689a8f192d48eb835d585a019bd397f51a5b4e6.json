{"sha": "d689a8f192d48eb835d585a019bd397f51a5b4e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY4OWE4ZjE5MmQ0OGViODM1ZDU4NWEwMTliZDM5N2Y1MWE1YjRlNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-06-30T20:41:38Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-06-30T20:41:38Z"}, "message": "cp-tree.h (CPTI_TINFO_DECL_TYPE): Replace with ...\n\n\t* cp-tree.h (CPTI_TINFO_DECL_TYPE): Replace with ...\n\t(CPTI_TYPE_INFO_PTR_TYPE): ... this.\n\t(tinfo_decl_type): Replace with ...\n\t(type_info_ptr_type): ... this.\n\t(import_export_tinfo): Declare.\n\t(tinfo_decl_p): Rename to ...\n\t(unemitted_tinfo_decl_p): ... this.\n\t* decl2.c (import_export_decl): Break out tinfo handling into ...\n\t(import_export_tinfo): ... here. New function.\n\t(finish_file): Adjust.\n\t* rtti.c (TINFO_REAL_NAME): New macro.\n\t(init_rtti_processing): Create the tinfo types.\n\t(get_tinfo_decl_dynamic): Use type_info_ptr_type, get_tinfo_ptr.\n\t(get_tinfo_decl): Adjust.\n\t(get_tinfo_ptr): New function.\n\t(get_type_id): Use it.\n\t(tinfo_base_init): Create vtable decl here, if it doesn't exist.\n\t(ptr_initializer): Use get_tinfo_ptr.\n\t(ptm_initializer): Likewise.\n\t(synthesize_tinfo_var): Break into ...\n\t(get_pseudo_ti_init): ... this. Just create the initializer.\n\t(get_pseudo_ti_desc): .. and this.\n\t(create_real_tinfo_var): Remove.\n\t(create_pseudo_type_info): Don't create the vtable decl here.\n\t(get_vmi_pseudo_type_info): Remove.\n\t(create_tinfo_types): Adjust.\n\t(tinfo_decl_p): Rename to ...\n\t(unemitted_tinfo_decl_p): ... here. Adjust.\n\t(emit_tinfo_decl): Adjust. Create the initializer.\n\nFrom-SVN: r55124", "tree": {"sha": "2df80a2032a058bf6e9069417acae9c0b013bea2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2df80a2032a058bf6e9069417acae9c0b013bea2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d689a8f192d48eb835d585a019bd397f51a5b4e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d689a8f192d48eb835d585a019bd397f51a5b4e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d689a8f192d48eb835d585a019bd397f51a5b4e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d689a8f192d48eb835d585a019bd397f51a5b4e6/comments", "author": null, "committer": null, "parents": [{"sha": "e3223ea2938e785094c2c8c87cdb8d86fb596c6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3223ea2938e785094c2c8c87cdb8d86fb596c6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3223ea2938e785094c2c8c87cdb8d86fb596c6d"}], "stats": {"total": 720, "additions": 368, "deletions": 352}, "files": [{"sha": "18814cf207b72f125429096eabb902ce6129213d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d689a8f192d48eb835d585a019bd397f51a5b4e6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d689a8f192d48eb835d585a019bd397f51a5b4e6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d689a8f192d48eb835d585a019bd397f51a5b4e6", "patch": "@@ -1,3 +1,35 @@\n+2002-06-30  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (CPTI_TINFO_DECL_TYPE): Replace with ...\n+\t(CPTI_TYPE_INFO_PTR_TYPE): ... this.\n+\t(tinfo_decl_type): Replace with ...\n+\t(type_info_ptr_type): ... this.\n+\t(import_export_tinfo): Declare.\n+\t(tinfo_decl_p): Rename to ...\n+\t(unemitted_tinfo_decl_p): ... this.\n+\t* decl2.c (import_export_decl): Break out tinfo handling into ...\n+\t(import_export_tinfo): ... here. New function.\n+\t(finish_file): Adjust.\n+\t* rtti.c (TINFO_REAL_NAME): New macro.\n+\t(init_rtti_processing): Create the tinfo types.\n+\t(get_tinfo_decl_dynamic): Use type_info_ptr_type, get_tinfo_ptr.\n+\t(get_tinfo_decl): Adjust.\n+\t(get_tinfo_ptr): New function.\n+\t(get_type_id): Use it.\n+\t(tinfo_base_init): Create vtable decl here, if it doesn't exist.\n+\t(ptr_initializer): Use get_tinfo_ptr.\n+\t(ptm_initializer): Likewise.\n+\t(synthesize_tinfo_var): Break into ...\n+\t(get_pseudo_ti_init): ... this. Just create the initializer.\n+\t(get_pseudo_ti_desc): .. and this.\n+\t(create_real_tinfo_var): Remove.\n+\t(create_pseudo_type_info): Don't create the vtable decl here.\n+\t(get_vmi_pseudo_type_info): Remove.\n+\t(create_tinfo_types): Adjust.\n+\t(tinfo_decl_p): Rename to ...\n+\t(unemitted_tinfo_decl_p): ... here. Adjust.\n+\t(emit_tinfo_decl): Adjust. Create the initializer.\n+\n 2002-06-27  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/6695"}, {"sha": "80b0f4378d8ddc94e0d39313b6aa100baf55124b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d689a8f192d48eb835d585a019bd397f51a5b4e6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d689a8f192d48eb835d585a019bd397f51a5b4e6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d689a8f192d48eb835d585a019bd397f51a5b4e6", "patch": "@@ -567,7 +567,7 @@ enum cp_tree_index\n     CPTI_STD,\n     CPTI_ABI,\n     CPTI_TYPE_INFO_TYPE,\n-    CPTI_TINFO_DECL_TYPE,\n+    CPTI_TYPE_INFO_PTR_TYPE,\n     CPTI_ABORT_FNDECL,\n     CPTI_GLOBAL_DELETE_FNDECL,\n     CPTI_AGGR_TAG,\n@@ -654,7 +654,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define std_node\t\t\tcp_global_trees[CPTI_STD]\n #define abi_node                        cp_global_trees[CPTI_ABI]\n #define type_info_type_node\t\tcp_global_trees[CPTI_TYPE_INFO_TYPE]\n-#define tinfo_decl_type\t\t\tcp_global_trees[CPTI_TINFO_DECL_TYPE]\n+#define type_info_ptr_type\t\tcp_global_trees[CPTI_TYPE_INFO_PTR_TYPE]\n #define abort_fndecl\t\t\tcp_global_trees[CPTI_ABORT_FNDECL]\n #define global_delete_fndecl\t\tcp_global_trees[CPTI_GLOBAL_DELETE_FNDECL]\n #define current_aggr\t\t\tcp_global_trees[CPTI_AGGR_TAG]\n@@ -3935,6 +3935,7 @@ extern tree coerce_delete_type\t\t\tPARAMS ((tree));\n extern void comdat_linkage\t\t\tPARAMS ((tree));\n extern void import_export_vtable\t\tPARAMS ((tree, tree, int));\n extern void import_export_decl\t\t\tPARAMS ((tree));\n+extern void import_export_tinfo\t\t\tPARAMS ((tree, tree));\n extern tree build_cleanup\t\t\tPARAMS ((tree));\n extern void finish_file\t\t\t\tPARAMS ((void));\n extern tree reparse_absdcl_as_expr\t\tPARAMS ((tree, tree));\n@@ -4163,7 +4164,7 @@ extern tree get_tinfo_decl                      PARAMS((tree));\n extern tree get_typeid\t\t\t\tPARAMS((tree));\n extern tree build_dynamic_cast\t\t\tPARAMS((tree, tree));\n extern void emit_support_tinfos                 PARAMS((void));\n-extern int tinfo_decl_p                         PARAMS((tree, void *));\n+extern int unemitted_tinfo_decl_p    \t        PARAMS((tree, void *));\n extern int emit_tinfo_decl                      PARAMS((tree *, void *));\n \n /* in search.c */"}, {"sha": "b37dc8cec57727e1aa9018d7f3620a2c7489d22a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d689a8f192d48eb835d585a019bd397f51a5b4e6/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d689a8f192d48eb835d585a019bd397f51a5b4e6/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d689a8f192d48eb835d585a019bd397f51a5b4e6", "patch": "@@ -2509,47 +2509,44 @@ import_export_decl (decl)\n       else\n \tcomdat_linkage (decl);\n     }\n-  else if (tinfo_decl_p (decl, 0))\n-    {\n-      /* Here, we only decide whether or not the tinfo node should be\n-\t emitted with the vtable.  The decl we're considering isn't\n-\t actually the one which gets emitted; that one is generated in\n-\t create_real_tinfo_var.  */\n-\n-      tree ctype = TREE_TYPE (DECL_NAME (decl));\n-\n-      if (IS_AGGR_TYPE (ctype))\n-\timport_export_class (ctype);\n-\n-      if (IS_AGGR_TYPE (ctype) && CLASSTYPE_INTERFACE_KNOWN (ctype)\n-\t  && TYPE_POLYMORPHIC_P (ctype)\n-\t  /* If -fno-rtti, we're not necessarily emitting this stuff with\n-\t     the class, so go ahead and emit it now.  This can happen\n-\t     when a class is used in exception handling.  */\n-\t  && flag_rtti\n-\t  /* If the type is a cv-qualified variant of a type, then we\n-\t     must emit the tinfo function in this translation unit\n-\t     since it will not be emitted when the vtable for the type\n-\t     is output (which is when the unqualified version is\n-\t     generated).  */\n-\t  && same_type_p (ctype, TYPE_MAIN_VARIANT (ctype)))\n-\t{\n-\t  DECL_NOT_REALLY_EXTERN (decl)\n-\t    = ! CLASSTYPE_INTERFACE_ONLY (ctype);\n-\t  DECL_COMDAT (decl) = 0;\n-\t}\n-      else\n-\t{\n-\t  DECL_NOT_REALLY_EXTERN (decl) = 1;\n-\t  DECL_COMDAT (decl) = 1;\n-\t}\n-    } \n   else\n     comdat_linkage (decl);\n \n   DECL_INTERFACE_KNOWN (decl) = 1;\n }\n \n+/* Here, we only decide whether or not the tinfo node should be\n+   emitted with the vtable.  */\n+\n+void\n+import_export_tinfo (decl, type)\n+     tree decl;\n+     tree type;\n+{\n+  if (DECL_INTERFACE_KNOWN (decl))\n+    return;\n+  \n+  if (IS_AGGR_TYPE (type))\n+    import_export_class (type);\n+      \n+  if (IS_AGGR_TYPE (type) && CLASSTYPE_INTERFACE_KNOWN (type)\n+      && TYPE_POLYMORPHIC_P (type)\n+      /* If -fno-rtti, we're not necessarily emitting this stuff with\n+\t the class, so go ahead and emit it now.  This can happen when\n+\t a class is used in exception handling.  */\n+      && flag_rtti)\n+    {\n+      DECL_NOT_REALLY_EXTERN (decl) = !CLASSTYPE_INTERFACE_ONLY (type);\n+      DECL_COMDAT (decl) = 0;\n+    }\n+  else\n+    {\n+      DECL_NOT_REALLY_EXTERN (decl) = 1;\n+      DECL_COMDAT (decl) = 1;\n+    }\n+  DECL_INTERFACE_KNOWN (decl) = 1;\n+}\n+\n tree\n build_cleanup (decl)\n      tree decl;\n@@ -3344,7 +3341,7 @@ finish_file ()\n       \n       /* Write out needed type info variables. Writing out one variable\n          might cause others to be needed.  */\n-      if (walk_globals (tinfo_decl_p, emit_tinfo_decl, /*data=*/0))\n+      if (walk_globals (unemitted_tinfo_decl_p, emit_tinfo_decl, /*data=*/0))\n \treconsider = 1;\n \n       /* The list of objects with static storage duration is built up"}, {"sha": "3be44c5cdaa6f67f4ebe63e21c6f76267e3adf09", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 299, "deletions": 313, "changes": 612, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d689a8f192d48eb835d585a019bd397f51a5b4e6/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d689a8f192d48eb835d585a019bd397f51a5b4e6/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=d689a8f192d48eb835d585a019bd397f51a5b4e6", "patch": "@@ -1,5 +1,5 @@\n /* RunTime Type Identification\n-   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001\n+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002\n    Free Software Foundation, Inc.\n    Mostly written by Jason Merrill (jason@cygnus.com).\n \n@@ -30,16 +30,46 @@ Boston, MA 02111-1307, USA.  */\n #include \"assert.h\"\n #include \"toplev.h\"\n \n+/* C++ returns type information to the user in struct type_info\n+   objects. We also use type information to implement dynamic_cast and\n+   exception handlers. Type information for a particular type is\n+   indicated with an ABI defined structure derived from type_info.\n+   This would all be very straight forward, but for the fact that the\n+   runtime library provides the definitions of the type_info structure\n+   and the ABI defined derived classes. We cannot build declarations\n+   of them directly in the compiler, but we need to layout objects of\n+   their type.  Somewhere we have to lie.\n+\n+   We define layout compatible POD-structs with compiler-defined names\n+   and generate the appropriate initializations for them (complete\n+   with explicit mention of their vtable). When we have to provide a\n+   type_info to the user we reinterpret_cast the internal compiler\n+   type to type_info.  A well formed program can only explicitly refer\n+   to the type_infos of complete types (& cv void).  However, we chain\n+   pointer type_infos to the pointed-to-type, and that can be\n+   incomplete.  We only need the addresses of such incomplete\n+   type_info objects for static initialization.\n+\n+   The type information VAR_DECL of a type is held on the\n+   IDENTIFIER_GLOBAL_VALUE of the type's mangled name. That VAR_DECL\n+   will be the internal type.  It will usually have the correct\n+   internal type reflecting the kind of type it represents (pointer,\n+   array, function, class, inherited class, etc).  When the type it\n+   represents is incomplete, it will have the internal type\n+   corresponding to type_info.  That will only happen at the end of\n+   translation, when we are emitting the type info objects.  */\n+\n /* Accessors for the type_info objects. We need to remember several things\n    about each of the type_info types. The global tree nodes such as\n    bltn_desc_type_node are TREE_LISTs, and these macros are used to access\n    the required information. */\n /* The RECORD_TYPE of a type_info derived class. */\n #define TINFO_PSEUDO_TYPE(NODE) TREE_TYPE (NODE)\n-/* The VAR_DECL of the vtable for the type_info derived class. */\n+/* The VAR_DECL of the vtable for the type_info derived class.\n+   This is only filled in at the end of the translation. */\n #define TINFO_VTABLE_DECL(NODE) TREE_VALUE (NODE)\n-\n-extern struct obstack permanent_obstack;\n+/* The IDENTIFIER_NODE naming the real class. */\n+#define TINFO_REAL_NAME(NODE) TREE_PURPOSE (NODE)\n \n static tree build_headof PARAMS((tree));\n static tree ifnonnull PARAMS((tree, tree));\n@@ -48,7 +78,8 @@ static tree build_dynamic_cast_1 PARAMS((tree, tree));\n static tree throw_bad_cast PARAMS((void));\n static tree throw_bad_typeid PARAMS((void));\n static tree get_tinfo_decl_dynamic PARAMS((tree));\n-static bool typeid_ok_p PARAMS ((void));\n+static tree get_tinfo_ptr PARAMS((tree));\n+static bool typeid_ok_p PARAMS((void));\n static int qualifier_flags PARAMS((tree));\n static int target_incomplete_p PARAMS((tree));\n static tree tinfo_base_init PARAMS((tree, tree));\n@@ -59,15 +90,21 @@ static tree dfs_class_hint_mark PARAMS ((tree, void *));\n static tree dfs_class_hint_unmark PARAMS ((tree, void *));\n static int class_hint_flags PARAMS((tree));\n static tree class_initializer PARAMS((tree, tree, tree));\n-static tree synthesize_tinfo_var PARAMS((tree));\n-static tree create_real_tinfo_var PARAMS((tree, tree, tree, tree, int));\n static tree create_pseudo_type_info PARAMS((const char *, int, ...));\n-static tree get_vmi_pseudo_type_info PARAMS((int));\n+static tree get_pseudo_ti_init PARAMS ((tree, tree, int *));\n+static tree get_pseudo_ti_desc PARAMS((tree));\n static void create_tinfo_types PARAMS((void));\n static int typeinfo_in_lib_p PARAMS((tree));\n \n static int doing_runtime = 0;\n \f\n+\n+/* Declare language defined type_info type and a pointer to const\n+   type_info.  This is incomplete here, and will be completed when\n+   the user #includes <typeinfo>.  There are language defined\n+   restrictions on what can be done until that is included.  Create\n+   the internal versions of the ABI types.  */\n+\n void\n init_rtti_processing ()\n {\n@@ -76,8 +113,11 @@ init_rtti_processing ()\n     = xref_tag (class_type, get_identifier (\"type_info\"),\n \t\t/*attributes=*/NULL_TREE, 1);\n   pop_namespace ();\n-  tinfo_decl_type = \n-    build_qualified_type (type_info_type_node, TYPE_QUAL_CONST);\n+  type_info_ptr_type = \n+    build_pointer_type\n+     (build_qualified_type (type_info_type_node, TYPE_QUAL_CONST));\n+\n+  create_tinfo_types ();\n }\n \n /* Given the expression EXP of type `class *', return the head of the\n@@ -184,13 +224,12 @@ get_tinfo_decl_dynamic (exp)\n       /* The RTTI information is at index -1.  */\n       index = build_int_2 (-1 * TARGET_VTABLE_DATA_ENTRY_DISTANCE, -1);\n       t = build_vtbl_ref (exp, index);\n-      TREE_TYPE (t) = build_pointer_type (tinfo_decl_type);\n+      TREE_TYPE (t) = type_info_ptr_type;\n       return t;\n     }\n \n-  /* otherwise return the type_info for the static type of the expr.  */\n-  exp = get_tinfo_decl (TYPE_MAIN_VARIANT (type));\n-  return build_unary_op (ADDR_EXPR, exp, 0);\n+  /* Otherwise return the type_info for the static type of the expr.  */\n+  return get_tinfo_ptr (TYPE_MAIN_VARIANT (type));\n }\n \n static bool\n@@ -264,9 +303,9 @@ tinfo_name (type)\n   return name_string;\n }\n \n-/* Returns a decl for the type_info variable for TYPE.  You must\n-   arrange that the decl is mark_used, if actually use it --- decls in\n-   vtables are only used if the vtable is output.  */ \n+/* Return a VAR_DECL for the internal ABI defined type_info object for\n+   TYPE. You must arrange that the decl is mark_used, if actually use\n+   it --- decls in vtables are only used if the vtable is output.  */ \n \n tree\n get_tinfo_decl (type)\n@@ -279,7 +318,7 @@ get_tinfo_decl (type)\n       && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     {\n       error (\"cannot create type information for type `%T' because its size is variable\", \n-\t\ttype);\n+\t     type);\n       return error_mark_node;\n     }\n \n@@ -292,36 +331,44 @@ get_tinfo_decl (type)\n   name = mangle_typeinfo_for_type (type);\n \n   d = IDENTIFIER_GLOBAL_VALUE (name);\n-  if (d)\n-    /* OK */;\n-  else\n+  if (!d)\n     {\n-      /* The tinfo decl is the type_info object itself.  We make all\n-         tinfo objects look as type_info, even though they will end up\n-         being a subclass of that when emitted.  This means that we'll\n-         erroneously think we know the dynamic type -- be careful in the\n-         runtime.  */\n-      d = build_lang_decl (VAR_DECL, name, tinfo_decl_type);\n+      tree var_desc = get_pseudo_ti_desc (type);\n+\n+      d = build_lang_decl (VAR_DECL, name, TINFO_PSEUDO_TYPE (var_desc));\n       \n       DECL_ARTIFICIAL (d) = 1;\n-      DECL_ALIGN (d) = TYPE_ALIGN (ptr_type_node);\n-      DECL_USER_ALIGN (d) = 0;\n       TREE_READONLY (d) = 1;\n       TREE_STATIC (d) = 1;\n       DECL_EXTERNAL (d) = 1;\n-      TREE_PUBLIC (d) = 1;\n       SET_DECL_ASSEMBLER_NAME (d, name);\n-      DECL_COMDAT (d) = 1;\n       cp_finish_decl (d, NULL_TREE, NULL_TREE, 0);\n \n       pushdecl_top_level (d);\n+\n       /* Remember the type it is for.  */\n       TREE_TYPE (name) = type;\n-      TREE_USED (name) = 1;\n     }\n+\n   return d;\n }\n \n+/* Return a pointer to a type_info object describing TYPE, suitably\n+   cast to the language defined type.  */\n+\n+static tree\n+get_tinfo_ptr (type)\n+     tree type;\n+{\n+  tree exp = get_tinfo_decl (type);\n+  \n+   /* Convert to type_info type.  */\n+  exp = build_unary_op (ADDR_EXPR, exp, 0);\n+  exp = ocp_convert (type_info_ptr_type, exp, CONV_REINTERPRET, 0);\n+\n+  return exp;\n+}\n+\n /* Return the type_info object for TYPE.  */\n \n tree\n@@ -350,7 +397,7 @@ get_typeid (type)\n   if (!type)\n     return error_mark_node;\n \n-  return get_tinfo_decl (type);\n+  return build_indirect_ref (get_tinfo_ptr (type), NULL);\n }\n \n /* Check whether TEST is null before returning RESULT.  If TEST is used in\n@@ -684,6 +731,7 @@ tinfo_base_init (desc, target)\n {\n   tree init = NULL_TREE;\n   tree name_decl;\n+  tree vtable_ptr;\n   \n   {\n     tree name_name;\n@@ -711,12 +759,41 @@ tinfo_base_init (desc, target)\n     cp_finish_decl (name_decl, name_string, NULL_TREE, 0);\n     pushdecl_top_level (name_decl);\n   }\n-  \n-  if (TINFO_VTABLE_DECL (desc))\n+\n+  vtable_ptr = TINFO_VTABLE_DECL (desc);\n+  if (!vtable_ptr)\n     {\n-      tree vtbl_ptr = TINFO_VTABLE_DECL (desc);\n-      init = tree_cons (NULL_TREE, vtbl_ptr, init);\n+      tree real_type;\n+  \n+      push_nested_namespace (abi_node);\n+      real_type = xref_tag (class_type, TINFO_REAL_NAME (desc),\n+\t\t\t    /*attributes=*/NULL_TREE, 1);\n+      pop_nested_namespace (abi_node);\n+  \n+      if (!COMPLETE_TYPE_P (real_type))\n+\t{\n+          /* We never saw a definition of this type, so we need to\n+\t     tell the compiler that this is an exported class, as\n+\t     indeed all of the __*_type_info classes are.  */\n+\t  SET_CLASSTYPE_INTERFACE_KNOWN (real_type);\n+\t  CLASSTYPE_INTERFACE_ONLY (real_type) = 1;\n+\t}\n+\n+      vtable_ptr = get_vtable_decl (real_type, /*complete=*/1);\n+      vtable_ptr = build_unary_op (ADDR_EXPR, vtable_ptr, 0);\n+\n+      /* We need to point into the middle of the vtable.  */\n+      vtable_ptr = build\n+\t(PLUS_EXPR, TREE_TYPE (vtable_ptr), vtable_ptr,\n+\t size_binop (MULT_EXPR,\n+\t\t     size_int (2 * TARGET_VTABLE_DATA_ENTRY_DISTANCE),\n+\t\t     TYPE_SIZE_UNIT (vtable_entry_type)));\n+      TREE_CONSTANT (vtable_ptr) = 1;\n+\n+      TINFO_VTABLE_DECL (desc) = vtable_ptr;\n     }\n+\n+  init = tree_cons (NULL_TREE, vtable_ptr, init);\n   \n   init = tree_cons (NULL_TREE, decay_conversion (name_decl), init);\n   \n@@ -765,8 +842,7 @@ ptr_initializer (desc, target, non_public_ptr)\n     }\n   init = tree_cons (NULL_TREE, build_int_2 (flags, 0), init);\n   init = tree_cons (NULL_TREE,\n-                    build_unary_op (ADDR_EXPR,\n-                                    get_tinfo_decl (TYPE_MAIN_VARIANT (to)), 0),\n+                    get_tinfo_ptr (TYPE_MAIN_VARIANT (to)),\n                     init);\n   \n   init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, nreverse (init));\n@@ -803,12 +879,11 @@ ptm_initializer (desc, target, non_public_ptr)\n     }\n   init = tree_cons (NULL_TREE, build_int_2 (flags, 0), init);\n   init = tree_cons (NULL_TREE,\n-                    build_unary_op (ADDR_EXPR,\n-                                    get_tinfo_decl (TYPE_MAIN_VARIANT (to)), 0),\n+\t\t    get_tinfo_ptr (TYPE_MAIN_VARIANT (to)),\n                     init);\n   init = tree_cons (NULL_TREE,\n-                    build_unary_op (ADDR_EXPR, get_tinfo_decl (klass), 0),\n-                    init);  \n+\t\t    get_tinfo_ptr (klass),\n+\t\t    init);  \n   \n   init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, nreverse (init));\n   TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n@@ -929,81 +1004,63 @@ typeinfo_in_lib_p (type)\n     }\n }\n \n-/* Generate a pseudo_type_info VAR_DECL suitable for the supplied\n-   TARGET_TYPE and corresponding to PUBLIC_DECL. This is the structure expected by\n-   the runtime, and therefore has additional fields.  If we need not emit a\n-   definition (because the runtime must contain it), return NULL_TREE,\n-   otherwise return the VAR_DECL.  */\n+/* Generate the initializer for the type info describing\n+   TYPE. VAR_DESC is a . NON_PUBLIC_P is set non-zero, if the VAR_DECL\n+   should not be exported from this object file.  This should only be\n+   called at the end of translation, when we know that no further\n+   types will be completed.  */\n \n static tree\n-synthesize_tinfo_var (public_decl)\n-     tree public_decl;\n+get_pseudo_ti_init (type, var_desc, non_public_p)\n+     tree type;\n+     tree var_desc;\n+     int *non_public_p;\n {\n-  tree var_init = NULL_TREE;\n-  tree var_type = NULL_TREE;\n-  int non_public = 0;\n-  tree target_type = TREE_TYPE (DECL_NAME (public_decl));\n-  my_friendly_assert (target_type != NULL_TREE, 20000120);\n-  \n-  /* Say we've dealt with it.  */\n-  TREE_TYPE (DECL_NAME (public_decl)) = NULL_TREE;\n-  \n-  switch (TREE_CODE (target_type))\n+  my_friendly_assert (at_eof, 20021120);\n+  switch (TREE_CODE (type))\n     {\n     case POINTER_TYPE:\n-      if (TYPE_PTRMEM_P (target_type))\n-        {\n-          var_type = ptm_desc_type_node;\n-          var_init = ptm_initializer (var_type, target_type, &non_public);\n-        }\n+      if (TYPE_PTRMEM_P (type))\n+\treturn ptm_initializer (var_desc, type, non_public_p);\n       else\n-        {\n-          if (typeinfo_in_lib_p (target_type) && !doing_runtime)\n-            /* These are in the runtime.  */\n-            return NULL_TREE;\n-          var_type = ptr_desc_type_node;\n-          var_init = ptr_initializer (var_type, target_type, &non_public);\n-        }\n+\treturn ptr_initializer (var_desc, type, non_public_p);\n       break;\n     case ENUMERAL_TYPE:\n-      var_type = enum_desc_type_node;\n-      var_init = generic_initializer (var_type, target_type);\n+      return generic_initializer (var_desc, type);\n       break;\n     case FUNCTION_TYPE:\n-      var_type = func_desc_type_node;\n-      var_init = generic_initializer (var_type, target_type);\n+      return generic_initializer (var_desc, type);\n       break;\n     case ARRAY_TYPE:\n-      var_type = ary_desc_type_node;\n-      var_init = generic_initializer (var_type, target_type);\n+      return generic_initializer (var_desc, type);\n       break;\n     case UNION_TYPE:\n     case RECORD_TYPE:\n-      if (TYPE_PTRMEMFUNC_P (target_type))\n+      if (TYPE_PTRMEMFUNC_P (type))\n+\treturn ptm_initializer (var_desc, type, non_public_p);\n+      else if (var_desc == class_desc_type_node)\n         {\n-          var_type = ptm_desc_type_node;\n-          var_init = ptm_initializer (var_type, target_type, &non_public);\n-        }\n-      else if (!COMPLETE_TYPE_P (target_type))\n-        {\n-          /* Emit a non-public class_type_info.  */\n-          non_public = 1;\n-          var_type = class_desc_type_node;\n-          var_init = class_initializer (var_type, target_type, NULL_TREE);\n-        }\n-      else if (!CLASSTYPE_N_BASECLASSES (target_type))\n-        {\n-          var_type = class_desc_type_node;\n-          var_init = class_initializer (var_type, target_type, NULL_TREE);\n+\t  if (!COMPLETE_TYPE_P (type))\n+\t    /* Emit a non-public class_type_info.  */\n+\t    *non_public_p = 1;\n+\t  return class_initializer (var_desc, type, NULL_TREE);\n         }\n+      else if (var_desc == si_class_desc_type_node)\n+\t{\n+          tree base_binfos = BINFO_BASETYPES (TYPE_BINFO (type));\n+\t  tree base_binfo = TREE_VEC_ELT (base_binfos, 0);\n+\t  tree tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n+\t  tree base_inits = tree_cons (NULL_TREE, tinfo, NULL_TREE);\n+\t  \n+\t  return class_initializer (var_desc, type, base_inits);\n+\t}\n       else\n         {\n-          /* if this has a single public non-virtual base, it's easier */\n-          tree binfo = TYPE_BINFO (target_type);\n+\t  int hint = class_hint_flags (type);\n+\t  tree binfo = TYPE_BINFO (type);\n           int nbases = BINFO_N_BASETYPES (binfo);\n           tree base_binfos = BINFO_BASETYPES (binfo);\n           tree base_inits = NULL_TREE;\n-          int is_simple = nbases == 1;\n           int ix;\n           \n           /* Generate the base information initializer.  */\n@@ -1017,28 +1074,19 @@ synthesize_tinfo_var (public_decl)\n               \n               if (TREE_PUBLIC (base_binfo))\n                 flags |= 2;\n-              tinfo = get_tinfo_decl (BINFO_TYPE (base_binfo));\n-              tinfo = build_unary_op (ADDR_EXPR, tinfo, 0);\n+              tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n \t      if (TREE_VIA_VIRTUAL (base_binfo))\n \t\t{\n \t\t   /* We store the vtable offset at which the virtual\n        \t\t      base offset can be found.  */\n-\t\t  offset = BINFO_VPTR_FIELD (binfo_for_vbase (BINFO_TYPE (base_binfo),\n-\t\t\t\t\t\t\t      target_type));\n+\t\t  offset = BINFO_VPTR_FIELD\n+\t\t    (binfo_for_vbase (BINFO_TYPE (base_binfo), type));\n \t\t  offset = convert (sizetype, offset);\n \t\t  flags |= 1;\n \t\t}\n \t      else\n \t\toffset = BINFO_OFFSET (base_binfo);\n               \n-              /* is it a single public inheritance? */\n-              if (is_simple && flags == 2 && integer_zerop (offset))\n-                {\n-                  base_inits = tree_cons (NULL_TREE, tinfo, NULL_TREE);\n-                  break;\n-                }\n-              is_simple = 0;\n-              \n               /* combine offset and flags into one field */\n               offset = cp_build_binary_op (LSHIFT_EXPR, offset,\n \t\t\t\t\t   build_int_2 (8, 0));\n@@ -1049,88 +1097,23 @@ synthesize_tinfo_var (public_decl)\n               base_init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, base_init);\n               base_inits = tree_cons (NULL_TREE, base_init, base_inits);\n             }\n-          \n-          if (is_simple)\n-            var_type = si_class_desc_type_node;\n-          else\n-            {\n-              int hint = class_hint_flags (target_type);\n-              \n-              base_inits = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, base_inits);\n-              base_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);\n-              /* Prepend the number of bases.  */\n-              base_inits = tree_cons (NULL_TREE,\n-                                      build_int_2 (nbases, 0), base_inits);\n-              /* Prepend the hint flags. */\n-              base_inits = tree_cons (NULL_TREE,\n-                                      build_int_2 (hint, 0), base_inits);\n-              var_type = get_vmi_pseudo_type_info (nbases);\n-            }\n-          var_init = class_initializer (var_type, target_type, base_inits);\n+\t  base_inits = build (CONSTRUCTOR,\n+\t\t\t      NULL_TREE, NULL_TREE, base_inits);\n+\t  base_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);\n+\t  /* Prepend the number of bases.  */\n+\t  base_inits = tree_cons (NULL_TREE,\n+\t\t\t\t  build_int_2 (nbases, 0), base_inits);\n+\t  /* Prepend the hint flags. */\n+\t  base_inits = tree_cons (NULL_TREE,\n+\t\t\t\t  build_int_2 (hint, 0), base_inits);\n+\n+          return class_initializer (var_desc, type, base_inits);\n         }\n       break;\n \n     default:\n-      if (typeinfo_in_lib_p (target_type))\n-\t{\n-\t  if (!doing_runtime)\n-\t    /* These are guaranteed to be in the runtime.  */\n-\t    return NULL_TREE;\n-\t  var_type = bltn_desc_type_node;\n-\t  var_init = generic_initializer (var_type, target_type);\n-\t  break;\n-\t}\n-      abort ();\n+      return generic_initializer (var_desc, type);\n     }\n-  \n-  return create_real_tinfo_var (target_type,\n-\t\t\t\tpublic_decl, TINFO_PSEUDO_TYPE (var_type),\n-                                var_init, non_public);\n-}\n-\n-/* Create the real typeinfo variable.  NON_PUBLIC indicates that we cannot\n-   make this variable public (comdat). */\n-\n-static tree\n-create_real_tinfo_var (target_type, public_decl, type, init, non_public)\n-     tree target_type;\n-     tree public_decl;\n-     tree type;\n-     tree init;\n-     int non_public;\n-{\n-  static int count = 0;\n-  tree decl;\n-  tree hidden_name;\n-  char hidden[30];\n-  tree name = DECL_ASSEMBLER_NAME (public_decl);\n-\n-  /* We cannot give this the name NAME, as that already is globally\n-     bound to the tinfo_decl we originally created for this type in\n-     get_tinfo_decl. */\n-  sprintf (hidden, \"__ti_%d\", count++);\n-  hidden_name = get_identifier (hidden);\n-  \n-  decl = build_lang_decl (VAR_DECL, hidden_name,\n-                          build_qualified_type (type, TYPE_QUAL_CONST));\n-  DECL_ARTIFICIAL (decl) = 1;\n-  TREE_READONLY (decl) = 1;\n-  TREE_STATIC (decl) = 1;\n-  DECL_EXTERNAL (decl) = 0;\n-  \n-  if (!non_public)\n-    {\n-      TREE_PUBLIC (decl) = 1;\n-      if (flag_weak\n-\t  || (DECL_COMDAT (public_decl) && !typeinfo_in_lib_p (target_type)))\n-\tcomdat_linkage (decl);\n-    }\n-  SET_DECL_ASSEMBLER_NAME (decl, name);\n-  DECL_INITIAL (decl) = init;\n-  cp_finish_decl (decl, init, NULL_TREE, 0);\n-  pushdecl_top_level (decl);\n-  TREE_USED (decl) = 1;\n-  return decl;\n }\n \n /* Generate the RECORD_TYPE containing the data layout of a type_info\n@@ -1139,7 +1122,10 @@ create_real_tinfo_var (target_type, public_decl, type, init, non_public)\n    type's vtable. We explicitly manage the vtable member, and name it for\n    real type as used in the runtime. The RECORD type has a different name,\n    to avoid collisions.  Return a TREE_LIST who's TINFO_PSEUDO_TYPE\n-   is the generated type and TINFO_VTABLE_DECL is the vtable decl.\n+   is the generated type and TINFO_VTABLE_NAME is the name of the\n+   vtable.  We have to delay generating the VAR_DECL of the vtable\n+   until the end of the translation, when we'll have seen the library\n+   definition, if there was one.\n    \n    REAL_NAME is the runtime's name of the type. Trailing arguments are\n    additional FIELD_DECL's for the structure. The final argument must be\n@@ -1148,9 +1134,8 @@ create_real_tinfo_var (target_type, public_decl, type, init, non_public)\n static tree\n create_pseudo_type_info VPARAMS((const char *real_name, int ident, ...))\n {\n-  tree real_type, pseudo_type;\n+  tree pseudo_type;\n   char *pseudo_name;\n-  tree vtable_decl;\n   int ix;\n   tree fields[10];\n   tree field_decl;\n@@ -1167,29 +1152,6 @@ create_pseudo_type_info VPARAMS((const char *real_name, int ident, ...))\n   if (ident)\n     sprintf (pseudo_name + strlen (pseudo_name), \"%d\", ident);\n   \n-  /* Get the vtable decl. */\n-  real_type = xref_tag (class_type, get_identifier (real_name), \n-\t\t\t/*attributes=*/NULL_TREE, 1);\n-  if (! TYPE_SIZE (real_type))\n-    {\n-      /* We never saw a definition of this type, so we need to tell the\n-\t compiler that this is an exported class, as indeed all of the\n-\t __*_type_info classes are.  */\n-      SET_CLASSTYPE_INTERFACE_KNOWN (real_type);\n-      CLASSTYPE_INTERFACE_ONLY (real_type) = 1;\n-    }\n-\n-  vtable_decl = get_vtable_decl (real_type, /*complete=*/1);\n-  vtable_decl = build_unary_op (ADDR_EXPR, vtable_decl, 0);\n-\n-  /* We need to point into the middle of the vtable.  */\n-  vtable_decl\n-    = build (PLUS_EXPR, TREE_TYPE (vtable_decl), vtable_decl,\n-\t     size_binop (MULT_EXPR,\n-\t\t\t size_int (2 * TARGET_VTABLE_DATA_ENTRY_DISTANCE),\n-\t\t\t TYPE_SIZE_UNIT (vtable_entry_type)));\n-  TREE_CONSTANT (vtable_decl) = 1;\n-\n   /* First field is the pseudo type_info base class. */\n   fields[0] = build_decl (FIELD_DECL, NULL_TREE, ti_desc_type_node);\n   \n@@ -1203,53 +1165,96 @@ create_pseudo_type_info VPARAMS((const char *real_name, int ident, ...))\n   TYPE_HAS_CONSTRUCTOR (pseudo_type) = 1;\n \n   result = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n-  TINFO_VTABLE_DECL (result) = vtable_decl;\n-  TINFO_PSEUDO_TYPE (result) = pseudo_type;\n+  TINFO_REAL_NAME (result) = get_identifier (real_name);\n+  TINFO_PSEUDO_TYPE (result) =\n+    cp_build_qualified_type (pseudo_type, TYPE_QUAL_CONST);\n   \n   VA_CLOSE (ap);\n   return result;\n }\n \n-/* Return a descriptor for a vmi type with NUM_BASES bases.  */\n+/* Return a pseudo type info type node used to describe TYPE.  TYPE\n+   must be a complete type (or cv void), except at the end of the\n+   translation unit.  */\n \n static tree\n-get_vmi_pseudo_type_info (num_bases)\n-     int num_bases;\n+get_pseudo_ti_desc (type)\n+     tree type;\n {\n-  tree desc;\n-  tree array_domain, base_array;\n-  \n-  if (TREE_VEC_LENGTH (vmi_class_desc_type_node) <= num_bases)\n+  switch (TREE_CODE (type))\n     {\n-      int ix;\n-      tree extend = make_tree_vec (num_bases + 5);\n-      \n-      for (ix = TREE_VEC_LENGTH (vmi_class_desc_type_node); ix--;)\n-        TREE_VEC_ELT (extend, ix) = TREE_VEC_ELT (vmi_class_desc_type_node, ix);\n-      vmi_class_desc_type_node = extend;\n-    }\n-  desc = TREE_VEC_ELT (vmi_class_desc_type_node, num_bases);\n-  \n-  if (desc)\n-    return desc;\n+    case POINTER_TYPE:\n+      return TYPE_PTRMEM_P (type) ? ptm_desc_type_node : ptr_desc_type_node;\n+    case ENUMERAL_TYPE:\n+      return enum_desc_type_node;\n+    case FUNCTION_TYPE:\n+      return func_desc_type_node;\n+    case ARRAY_TYPE:\n+      return ary_desc_type_node;\n+    case UNION_TYPE:\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (type))\n+\treturn ptm_desc_type_node;\n+      else if (!COMPLETE_TYPE_P (type))\n+\t{\n+\t  my_friendly_assert (at_eof, 20020609);\n+\t  return class_desc_type_node;\n+\t}\n+      else if (!CLASSTYPE_N_BASECLASSES (type))\n+\treturn class_desc_type_node;\n+      else\n+\t{\n+\t  tree base_binfo =\n+\t    TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (type)), 0);\n+\t  int num_bases = BINFO_N_BASETYPES (TYPE_BINFO (type));\n+\t  \n+\t  if (num_bases == 1\n+\t      && TREE_PUBLIC (base_binfo)\n+\t      && !TREE_VIA_VIRTUAL (base_binfo)\n+\t      && integer_zerop (BINFO_OFFSET (base_binfo)))\n+\t    /* single non-virtual public. */\n+\t    return si_class_desc_type_node;\n+\t  else\n+\t    {\n+\t      tree var_desc;\n+\t      tree array_domain, base_array;\n+\t      \n+\t      if (TREE_VEC_LENGTH (vmi_class_desc_type_node) <= num_bases)\n+\t\t{\n+\t\t  int ix;\n+\t\t  tree extend = make_tree_vec (num_bases + 5);\n+\t\t  \n+\t\t  for (ix = TREE_VEC_LENGTH (vmi_class_desc_type_node); ix--;)\n+\t\t    TREE_VEC_ELT (extend, ix)\n+\t\t      = TREE_VEC_ELT (vmi_class_desc_type_node, ix);\n+\t\t  vmi_class_desc_type_node = extend;\n+\t\t}\n+\t      var_desc = TREE_VEC_ELT (vmi_class_desc_type_node, num_bases);\n+\t      if (var_desc)\n+\t\treturn var_desc;\n   \n-  /* Add number of bases and trailing array of base_class_type_info.  */\n-  array_domain = build_index_type (size_int (num_bases));\n-  base_array = build_array_type (base_desc_type_node, array_domain);\n-\n-  push_nested_namespace (abi_node);\n-\n-  desc = create_pseudo_type_info\n-            (\"__vmi_class_type_info\", num_bases,\n-             build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-             build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-             build_decl (FIELD_DECL, NULL_TREE, base_array),\n-             NULL);\n-\n-  pop_nested_namespace (abi_node);\n-\n-  TREE_VEC_ELT (vmi_class_desc_type_node, num_bases) = desc;\n-  return desc;\n+\t      /* Add number of bases and trailing array of\n+\t\t base_class_type_info.  */\n+\t      array_domain = build_index_type (size_int (num_bases));\n+\t      base_array =\n+\t\tbuild_array_type (base_desc_type_node, array_domain);\n+\n+\t      push_nested_namespace (abi_node);\n+\t      var_desc = create_pseudo_type_info\n+\t\t(\"__vmi_class_type_info\", num_bases,\n+\t\t build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+\t\t build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+\t\t build_decl (FIELD_DECL, NULL_TREE, base_array),\n+\t\t NULL);\n+\t      pop_nested_namespace (abi_node);\n+\n+\t      TREE_VEC_ELT (vmi_class_desc_type_node, num_bases) = var_desc;\n+\t      return var_desc;\n+\t    }\n+\t}\n+    default:\n+      return bltn_desc_type_node;\n+    }\n }\n \n /* Make sure the required builtin types exist for generating the type_info\n@@ -1258,15 +1263,9 @@ get_vmi_pseudo_type_info (num_bases)\n static void\n create_tinfo_types ()\n {\n-  tree ptr_type_info;\n-  \n-  if (bltn_desc_type_node)\n-    return;\n-  push_nested_namespace (abi_node);\n+  my_friendly_assert (!ti_desc_type_node, 20020609);\n \n-  ptr_type_info = build_pointer_type\n-                    (build_qualified_type\n-                      (type_info_type_node, TYPE_QUAL_CONST));\n+  push_nested_namespace (abi_node);\n   \n   /* Create the internal type_info structure. This is used as a base for\n      the other structures.  */\n@@ -1306,15 +1305,15 @@ create_tinfo_types ()\n      This is really a descendant of __class_type_info.  */\n   si_class_desc_type_node = create_pseudo_type_info\n            (\"__si_class_type_info\", 0,\n-            build_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n+            build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n             NULL);\n   \n   /* Base class internal helper. Pointer to base type, offset to base,\n      flags. */\n   {\n     tree fields[2];\n     \n-    fields[0] = build_decl (FIELD_DECL, NULL_TREE, ptr_type_info);\n+    fields[0] = build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type);\n     fields[1] = build_decl (FIELD_DECL, NULL_TREE, integer_types[itk_long]);\n     base_desc_type_node = make_aggr_type (RECORD_TYPE);\n     finish_builtin_type (base_desc_type_node, \"__base_class_type_info_pseudo\",\n@@ -1331,7 +1330,7 @@ create_tinfo_types ()\n   ptr_desc_type_node = create_pseudo_type_info\n       (\"__pointer_type_info\", 0,\n        build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-       build_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n+       build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n        NULL);\n \n   /* Pointer to member data type_info.  Add qualifications flags,\n@@ -1340,8 +1339,8 @@ create_tinfo_types ()\n   ptm_desc_type_node = create_pseudo_type_info\n        (\"__pointer_to_member_type_info\", 0,\n         build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-        build_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n-        build_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n+        build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+        build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n         NULL);\n \n   pop_nested_namespace (abi_node);\n@@ -1410,72 +1409,59 @@ emit_support_tinfos ()\n    definition emitted for it.  */\n \n int\n-tinfo_decl_p (t, data)\n+unemitted_tinfo_decl_p (t, data)\n      tree t;\n      void *data ATTRIBUTE_UNUSED;\n {\n-  return TREE_CODE (t) == VAR_DECL\n-         && IDENTIFIER_GLOBAL_VALUE (DECL_NAME (t)) == (t)\n-         && TREE_TYPE (t) == tinfo_decl_type\n-         && TREE_TYPE (DECL_NAME (t));\n+  if (/* It's a var decl */\n+      TREE_CODE (t) == VAR_DECL\n+      /* whos name points back to itself */\n+      && IDENTIFIER_GLOBAL_VALUE (DECL_NAME (t)) == t\n+      /* whos name's type is non-null */\n+      && TREE_TYPE (DECL_NAME (t))\n+      /* and whos type is a struct */\n+      && TREE_CODE (TREE_TYPE (t)) == RECORD_TYPE\n+      /* with a first field of our pseudo type info */\n+      && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (t))) == ti_desc_type_node)\n+    return 1;\n+  return 0;\n }\n \n-/* Emit a suitable type_info definition for the type_info decl pointed to by\n-   DECL_PTR. We emit a completely new variable, of the correct type for the\n-   actual type this is describing. The DECL_ASSEMBLER_NAME of the generated\n-   definition is set to that of the supplied decl, so that they can be tied\n-   up. Mark the supplied decl as having been dealt with. Emitting one\n-   definition might cause other definitions to be required.\n-   \n-   We need to do things this way, because we're trying to do something like\n-   \n-      struct B : A {\n-        ...\n-      };\n-   \n-      extern const A tinfo_var;\n-   \n-      const B tinfo_var = {...};\n-   \n-   which is not permitted. Also, we've not necessarily seen the definition of B.\n-   So we do something like the following,\n-   \n-      extern const A tinfo_var;\n-   \n-      struct pseudo_A {\n-        const void *vtable_ptr;\n-        const char *name;\n-      };\n-      struct pseudo_B {\n-        pseudo_A base;\n-        ...\n-      };\n-      \n-      const pseudo_B proxy_tinfo_var attribute((assembler_name=\"tinfo_var\")) =\n-      {\n-        {&B::vtable, \"...\"},\n-        ...\n-      };\n-   \n-   pseudo_A and pseudo_B must be layout equivalent to the real definitions in\n-   the runtime.  */\n+/* Finish a type info decl. DECL_PTR is a pointer to an unemitted\n+   tinfo decl.  Determine whether it needs emitting, and if so\n+   generate the initializer.  */\n \n int\n emit_tinfo_decl (decl_ptr, data)\n      tree *decl_ptr;\n      void *data ATTRIBUTE_UNUSED;\n {\n-  tree tinfo_decl = *decl_ptr;\n-  tree decl;\n+  tree decl = *decl_ptr;\n+  tree type = TREE_TYPE (DECL_NAME (decl));\n+  int non_public;\n+  tree var_desc, var_init;\n   \n-  my_friendly_assert (TREE_TYPE (tinfo_decl) == tinfo_decl_type, 20000121);\n+  import_export_tinfo (decl, type);\n+  if (DECL_REALLY_EXTERN (decl) || !DECL_NEEDED_P (decl))\n+    return 0;\n \n-  import_export_decl (tinfo_decl);\n-  if (DECL_REALLY_EXTERN (tinfo_decl) || !DECL_NEEDED_P (tinfo_decl))\n+  if (!doing_runtime && typeinfo_in_lib_p (type))\n     return 0;\n \n-  create_tinfo_types ();\n-  decl = synthesize_tinfo_var (tinfo_decl);\n+  non_public = 0;\n+  var_desc = get_pseudo_ti_desc (type);\n+  var_init = get_pseudo_ti_init (type, var_desc, &non_public);\n+  DECL_EXTERNAL (decl) = 0;\n+  TREE_PUBLIC (decl) = !non_public;\n+  if (!non_public\n+      && (flag_weak || (DECL_COMDAT (decl) && !typeinfo_in_lib_p (type))))\n+    comdat_linkage (decl);\n   \n-  return decl != 0;\n+  DECL_INITIAL (decl) = var_init;\n+  cp_finish_decl (decl, var_init, NULL_TREE, 0);\n+  \n+  /* Say we've dealt with it.  */\n+  TREE_TYPE (DECL_NAME (decl)) = NULL_TREE;\n+\n+  return 1;\n }"}]}