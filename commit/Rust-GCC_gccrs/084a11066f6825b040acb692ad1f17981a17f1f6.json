{"sha": "084a11066f6825b040acb692ad1f17981a17f1f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg0YTExMDY2ZjY4MjViMDQwYWNiNjkyYWQxZjE3OTgxYTE3ZjFmNg==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2002-11-27T02:29:12Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2002-11-27T02:29:12Z"}, "message": "expr.c (gen_group_rtx, [...]): New functions.\n\n\t* expr.c (gen_group_rtx, emit_group_move): New functions.\n\t* expr.h (gen_group_rtx, emit_group_move): Prototype.\n\t* function.c (expand_function_start): Use gen_group_rtx to create a\n\tPARALLEL rtx to hold the return value when the real return rtx is a\n\tPARALLEL.\n\t(expand_function_end): Use emit_group_move to move the return value\n\tfrom a PARALLEL to the real return registers.\n\t* rtl.h (REG_FUNCTION_VALUE_P): Allow function values to be returned\n\tin PARALLELs.\n\nFrom-SVN: r59554", "tree": {"sha": "fc534194a61afad57285d25be308fb71db734c93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc534194a61afad57285d25be308fb71db734c93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/084a11066f6825b040acb692ad1f17981a17f1f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/084a11066f6825b040acb692ad1f17981a17f1f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/084a11066f6825b040acb692ad1f17981a17f1f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/084a11066f6825b040acb692ad1f17981a17f1f6/comments", "author": null, "committer": null, "parents": [{"sha": "a16f235752abdce78d8e5f608762a207f4973f13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a16f235752abdce78d8e5f608762a207f4973f13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a16f235752abdce78d8e5f608762a207f4973f13"}], "stats": {"total": 113, "additions": 98, "deletions": 15}, "files": [{"sha": "a6572299b2f401faf0ef32c703e815eb0f81bbbb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084a11066f6825b040acb692ad1f17981a17f1f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084a11066f6825b040acb692ad1f17981a17f1f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=084a11066f6825b040acb692ad1f17981a17f1f6", "patch": "@@ -1,3 +1,15 @@\n+2002-11-26  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* expr.c (gen_group_rtx, emit_group_move): New functions.\n+\t* expr.h (gen_group_rtx, emit_group_move): Prototype.\n+\t* function.c (expand_function_start): Use gen_group_rtx to create a\n+\tPARALLEL rtx to hold the return value when the real return rtx is a\n+\tPARALLEL.\n+\t(expand_function_end): Use emit_group_move to move the return value\n+\tfrom a PARALLEL to the real return registers.\n+\t* rtl.h (REG_FUNCTION_VALUE_P): Allow function values to be returned\n+\tin PARALLELs.\n+\n 2002-11-26  Jason Thorpe  <thorpej@wasabisystems.com>\n \n \t* config/t-libc-ok: Fix typo."}, {"sha": "8851343299ae2c3b445d692f405482e825ad1e2b", "filename": "gcc/expr.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084a11066f6825b040acb692ad1f17981a17f1f6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084a11066f6825b040acb692ad1f17981a17f1f6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=084a11066f6825b040acb692ad1f17981a17f1f6", "patch": "@@ -2203,6 +2203,42 @@ move_block_from_reg (regno, x, nregs, size)\n     }\n }\n \n+/* Generate a PARALLEL rtx for a new non-consecutive group of registers from\n+   ORIG, where ORIG is a non-consecutive group of registers represented by\n+   a PARALLEL.  The clone is identical to the original except in that the\n+   original set of registers is replaced by a new set of pseudo registers.\n+   The new set has the same modes as the original set.  */\n+\n+rtx\n+gen_group_rtx (orig)\n+     rtx orig;\n+{\n+  int i, length;\n+  rtx *tmps;\n+\n+  if (GET_CODE (orig) != PARALLEL)\n+    abort ();\n+\n+  length = XVECLEN (orig, 0);\n+  tmps = (rtx *) alloca (sizeof (rtx) * length);\n+\n+  /* Skip a NULL entry in first slot.  */\n+  i = XEXP (XVECEXP (orig, 0, 0), 0) ? 0 : 1;\n+\n+  if (i)\n+    tmps[0] = 0;\n+\n+  for (; i < length; i++)\n+    {\n+      enum machine_mode mode = GET_MODE (XEXP (XVECEXP (orig, 0, i), 0));\n+      rtx offset = XEXP (XVECEXP (orig, 0, i), 1);\n+\n+      tmps[i] = gen_rtx_EXPR_LIST (VOIDmode, gen_reg_rtx (mode), offset);\n+    }\n+\n+  return gen_rtx_PARALLEL (GET_MODE (orig), gen_rtvec_v (length, tmps));\n+}\n+\n /* Emit code to move a block SRC to a block DST, where DST is non-consecutive\n    registers represented by a PARALLEL.  SSIZE represents the total size of\n    block SRC in bytes, or -1 if not known.  */\n@@ -2324,6 +2360,26 @@ emit_group_load (dst, orig_src, ssize)\n     emit_move_insn (XEXP (XVECEXP (dst, 0, i), 0), tmps[i]);\n }\n \n+/* Emit code to move a block SRC to block DST, where SRC and DST are\n+   non-consecutive groups of registers, each represented by a PARALLEL.  */\n+\n+void\n+emit_group_move (dst, src)\n+     rtx dst, src;\n+{\n+  int i;\n+\n+  if (GET_CODE (src) != PARALLEL\n+      || GET_CODE (dst) != PARALLEL\n+      || XVECLEN (src, 0) != XVECLEN (dst, 0))\n+    abort ();\n+\n+  /* Skip first entry if NULL.  */\n+  for (i = XEXP (XVECEXP (src, 0, 0), 0) ? 0 : 1; i < XVECLEN (src, 0); i++)\n+    emit_move_insn (XEXP (XVECEXP (dst, 0, i), 0),\n+\t\t    XEXP (XVECEXP (src, 0, i), 0));\n+}\n+\n /* Emit code to move a block SRC to a block DST, where SRC is non-consecutive\n    registers represented by a PARALLEL.  SSIZE represents the total size of\n    block DST, or -1 if not known.  */"}, {"sha": "6e8d19e994b84702c7d7c3a6aac3cea95b6e2c03", "filename": "gcc/expr.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084a11066f6825b040acb692ad1f17981a17f1f6/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084a11066f6825b040acb692ad1f17981a17f1f6/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=084a11066f6825b040acb692ad1f17981a17f1f6", "patch": "@@ -412,10 +412,17 @@ extern void move_block_to_reg PARAMS ((int, rtx, int, enum machine_mode));\n    The number of registers to be filled is NREGS.  */\n extern void move_block_from_reg PARAMS ((int, rtx, int, int));\n \n+/* Generate a non-consecutive group of registers represented by a PARALLEL.  */\n+extern rtx gen_group_rtx PARAMS ((rtx));\n+\n /* Load a BLKmode value into non-consecutive registers represented by a\n    PARALLEL.  */\n extern void emit_group_load PARAMS ((rtx, rtx, int));\n \n+/* Move a non-consecutive group of registers represented by a PARALLEL into\n+   a non-consecutive group of registers represented by a PARALLEL.  */\n+extern void emit_group_move PARAMS ((rtx, rtx));\n+\n /* Store a BLKmode value from non-consecutive registers represented by a\n    PARALLEL.  */\n extern void emit_group_store PARAMS ((rtx, rtx, int));"}, {"sha": "6e6d6d7fbf941a41e2b53f71f834c0d415bcde23", "filename": "gcc/function.c", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084a11066f6825b040acb692ad1f17981a17f1f6/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084a11066f6825b040acb692ad1f17981a17f1f6/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=084a11066f6825b040acb692ad1f17981a17f1f6", "patch": "@@ -6559,18 +6559,17 @@ expand_function_start (subr, parms_have_cleanups)\n \t\t\t       subr, 1);\n \n       /* Structures that are returned in registers are not aggregate_value_p,\n-\t so we may see a PARALLEL.  Don't play pseudo games with this.  */\n-      if (! REG_P (hard_reg))\n-\tSET_DECL_RTL (DECL_RESULT (subr), hard_reg);\n+\t so we may see a PARALLEL or a REG.  */\n+      if (REG_P (hard_reg))\n+\tSET_DECL_RTL (DECL_RESULT (subr), gen_reg_rtx (GET_MODE (hard_reg)));\n+      else if (GET_CODE (hard_reg) == PARALLEL)\n+\tSET_DECL_RTL (DECL_RESULT (subr), gen_group_rtx (hard_reg));\n       else\n-\t{\n-\t  /* Create the pseudo.  */\n-\t  SET_DECL_RTL (DECL_RESULT (subr), gen_reg_rtx (GET_MODE (hard_reg)));\n+\tabort ();\n \n-\t  /* Needed because we may need to move this to memory\n-\t     in case it's a named return value whose address is taken.  */\n-\t  DECL_REGISTER (DECL_RESULT (subr)) = 1;\n-\t}\n+      /* Set DECL_REGISTER flag so that expand_function_end will copy the\n+\t result to the real return register(s).  */\n+      DECL_REGISTER (DECL_RESULT (subr)) = 1;\n     }\n \n   /* Initialize rtx for parameters and local variables.\n@@ -6998,8 +6997,16 @@ expand_function_end (filename, line, end_bindings)\n \t      convert_move (real_decl_rtl, decl_rtl, unsignedp);\n \t    }\n \t  else if (GET_CODE (real_decl_rtl) == PARALLEL)\n-\t    emit_group_load (real_decl_rtl, decl_rtl,\n-\t\t\t     int_size_in_bytes (TREE_TYPE (decl_result)));\n+\t    {\n+\t      /* If expand_function_start has created a PARALLEL for decl_rtl,\n+\t\t move the result to the real return registers.  Otherwise, do\n+\t\t a group load from decl_rtl for a named return.  */\n+\t      if (GET_CODE (decl_rtl) == PARALLEL)\n+\t\temit_group_move (real_decl_rtl, decl_rtl);\n+\t      else\n+\t\temit_group_load (real_decl_rtl, decl_rtl,\n+\t\t\t\t int_size_in_bytes (TREE_TYPE (decl_result)));\n+\t    }\n \t  else\n \t    emit_move_insn (real_decl_rtl, decl_rtl);\n \t}"}, {"sha": "5f727b08d9c70c3c69447270b31ca42cc7ca06a2", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/084a11066f6825b040acb692ad1f17981a17f1f6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/084a11066f6825b040acb692ad1f17981a17f1f6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=084a11066f6825b040acb692ad1f17981a17f1f6", "patch": "@@ -185,7 +185,7 @@ struct rtx_def GTY((chain_next (\"RTX_NEXT (&%h)\"),\n      has used it as the function.  */\n   unsigned int used : 1;\n   /* Nonzero if this rtx came from procedure integration.\n-     1 in a REG means this reg refers to the return value\n+     1 in a REG or PARALLEL means this rtx refers to the return value\n      of the current function.\n      1 in a SYMBOL_REF if the symbol is weak.  */\n   unsigned integrated : 1;\n@@ -988,9 +988,10 @@ enum label_kind\n #define REGNO(RTX) XCUINT (RTX, 0, REG)\n #define ORIGINAL_REGNO(RTX) X0UINT (RTX, 1)\n \n-/* 1 if RTX is a reg that is the current function's return value.  */\n+/* 1 if RTX is a reg or parallel that is the current function's return\n+   value.  */\n #define REG_FUNCTION_VALUE_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"REG_FUNCTION_VALUE_P\", (RTX), REG)->integrated)\n+  (RTL_FLAG_CHECK2(\"REG_FUNCTION_VALUE_P\", (RTX), REG, PARALLEL)->integrated)\n \n /* 1 if RTX is a reg that corresponds to a variable declared by the user.  */\n #define REG_USERVAR_P(RTX)\t\t\t\t\t\t\\"}]}