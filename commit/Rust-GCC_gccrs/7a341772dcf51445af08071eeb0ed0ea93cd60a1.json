{"sha": "7a341772dcf51445af08071eeb0ed0ea93cd60a1", "node_id": "C_kwDOANBUbNoAKDdhMzQxNzcyZGNmNTE0NDVhZjA4MDcxZWViMGVkMGVhOTNjZDYwYTE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-13T09:31:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-13T09:31:52Z"}, "message": "Merge #710 #727\n\n710: Ensure for Coercion Sites we emit the code nessecary r=philberty a=philberty\n\nCoercion sites in Rust can require extra code generation for\r\nCallExpressions arguments for example. This ensures we detect\r\nthose cases and emit the extra code necessary. Please read the individual\r\ncommit messages for more detail on how this works.\r\n\r\nFixes #700 #708 #709  \n\n727: Remove lambda iterators in various HIR classes r=philberty a=dafaust\n\n(This is a revision of #726 with formatting fixes)\r\n\r\nThis patch removes the lambda iterators used in various HIR objects.\r\nThese iterators make interacting with the IR for static analysis more\r\ndifficult. Instead, get_X () helpers are added for accessing elements,\r\nand uses of the iterators replaced with for loops.\r\n\r\nThe following objects are adjusted in this patch:\r\n- HIR::ArrayElemsValues\r\n- HIR::TupleExpr\r\n- HIR::StructExprField\r\n- HIR::StructStruct\r\n- HIR::TupleStruct\r\n\r\nFixes: #703 \r\nFixes: #704 \r\nFixes: #705 \r\nFixes: #706 \r\nFixes: #707\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: David Faust <david.faust@oracle.com>", "tree": {"sha": "1a2fc5792371195fae63c36dc4989ef8032078c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a2fc5792371195fae63c36dc4989ef8032078c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a341772dcf51445af08071eeb0ed0ea93cd60a1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhZqeICRBK7hj4Ov3rIwAAZY0IAD15DPVL2CcaG/cZpisRqTPb\nSH/l/FZwxO0f6xi/j74gORmeVQTtK1dKqNPkNZwEFcNxw6JDtzkWM1ra5pBb9EQ1\nHSwi9tLzWEjVO6UDu7uu+8ksi0gfkDu1WcZkoMEFwPdkoQN3vkIx3XeF0PgJwfr/\nWd4FoaIvZpgWHN5sIFp27iWzOGswmD8eYLd0lA7iMe3V0Iay9XNhJov6XiC4gfsX\nq5FpBO1SGP3HOYhZwfteeE2nMFbGSrA4zbChoZk8qAPrtX/2PoDtqJyk26gmk8pj\ncjTBkqwosdqzz7gIvpQv5C4Mt6mbApXgqkfsCLlMUAA87OEXtJpdf9WrIFl1jYg=\n=s0V0\n-----END PGP SIGNATURE-----\n", "payload": "tree 1a2fc5792371195fae63c36dc4989ef8032078c4\nparent 6355d05a65ce8e253f83f2a7b17c80406a0c1bd5\nparent f6a04f38d51f6ca4319219f101e3f58660b128dc\nparent 85338a7f1ca9bc6d62ea3eb3e0c796b31a58bbbe\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1634117512 +0000\ncommitter GitHub <noreply@github.com> 1634117512 +0000\n\nMerge #710 #727\n\n710: Ensure for Coercion Sites we emit the code nessecary r=philberty a=philberty\n\nCoercion sites in Rust can require extra code generation for\r\nCallExpressions arguments for example. This ensures we detect\r\nthose cases and emit the extra code necessary. Please read the individual\r\ncommit messages for more detail on how this works.\r\n\r\nFixes #700 #708 #709  \n\n727: Remove lambda iterators in various HIR classes r=philberty a=dafaust\n\n(This is a revision of #726 with formatting fixes)\r\n\r\nThis patch removes the lambda iterators used in various HIR objects.\r\nThese iterators make interacting with the IR for static analysis more\r\ndifficult. Instead, get_X () helpers are added for accessing elements,\r\nand uses of the iterators replaced with for loops.\r\n\r\nThe following objects are adjusted in this patch:\r\n- HIR::ArrayElemsValues\r\n- HIR::TupleExpr\r\n- HIR::StructExprField\r\n- HIR::StructStruct\r\n- HIR::TupleStruct\r\n\r\nFixes: #703 \r\nFixes: #704 \r\nFixes: #705 \r\nFixes: #706 \r\nFixes: #707\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: David Faust <david.faust@oracle.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a341772dcf51445af08071eeb0ed0ea93cd60a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a341772dcf51445af08071eeb0ed0ea93cd60a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a341772dcf51445af08071eeb0ed0ea93cd60a1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6355d05a65ce8e253f83f2a7b17c80406a0c1bd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6355d05a65ce8e253f83f2a7b17c80406a0c1bd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6355d05a65ce8e253f83f2a7b17c80406a0c1bd5"}, {"sha": "f6a04f38d51f6ca4319219f101e3f58660b128dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6a04f38d51f6ca4319219f101e3f58660b128dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6a04f38d51f6ca4319219f101e3f58660b128dc"}, {"sha": "85338a7f1ca9bc6d62ea3eb3e0c796b31a58bbbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85338a7f1ca9bc6d62ea3eb3e0c796b31a58bbbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85338a7f1ca9bc6d62ea3eb3e0c796b31a58bbbe"}], "stats": {"total": 730, "additions": 430, "deletions": 300}, "files": [{"sha": "170580becff1b19b4450016c7049d0a0fc21fbdd", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -363,12 +363,28 @@ class CompileExpr : public HIRCompileBase\n   void visit (HIR::AssignmentExpr &expr) override\n   {\n     fncontext fn = ctx->peek_fn ();\n-    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n-    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+    auto lvalue = CompileExpr::Compile (expr.get_lhs (), ctx);\n+    auto rvalue = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+    // assignments are coercion sites so lets convert the rvalue if necessary\n+    TyTy::BaseType *expected = nullptr;\n+    TyTy::BaseType *actual = nullptr;\n+\n+    bool ok;\n+    ok = ctx->get_tyctx ()->lookup_type (\n+      expr.get_lhs ()->get_mappings ().get_hirid (), &expected);\n+    rust_assert (ok);\n+\n+    ok = ctx->get_tyctx ()->lookup_type (\n+      expr.get_rhs ()->get_mappings ().get_hirid (), &actual);\n+    rust_assert (ok);\n+\n+    rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n \n     Bstatement *assignment\n-      = ctx->get_backend ()->assignment_statement (fn.fndecl, lhs, rhs,\n+      = ctx->get_backend ()->assignment_statement (fn.fndecl, lvalue, rvalue,\n \t\t\t\t\t\t   expr.get_locus ());\n+\n     ctx->add_statement (assignment);\n   }\n \n@@ -412,11 +428,11 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::ArrayElemsValues &elems) override\n   {\n-    elems.iterate ([&] (HIR::Expr *e) mutable -> bool {\n-      Bexpression *translated_expr = CompileExpr::Compile (e, ctx);\n-      constructor.push_back (translated_expr);\n-      return true;\n-    });\n+    for (auto &elem : elems.get_values ())\n+      {\n+\tBexpression *translated_expr = CompileExpr::Compile (elem.get (), ctx);\n+\tconstructor.push_back (translated_expr);\n+      }\n   }\n \n   void visit (HIR::ArrayElemsCopied &elems) override\n@@ -646,11 +662,11 @@ class CompileExpr : public HIRCompileBase\n     // this assumes all fields are in order from type resolution and if a base\n     // struct was specified those fields are filed via accesors\n     std::vector<Bexpression *> vals;\n-    struct_expr.iterate ([&] (HIR::StructExprField *field) mutable -> bool {\n-      Bexpression *expr = CompileStructExprField::Compile (field, ctx);\n-      vals.push_back (expr);\n-      return true;\n-    });\n+    for (auto &field : struct_expr.get_fields ())\n+      {\n+\tBexpression *expr = CompileStructExprField::Compile (field.get (), ctx);\n+\tvals.push_back (expr);\n+      }\n \n     translated\n       = ctx->get_backend ()->constructor_expression (type, vals,"}, {"sha": "23a035fd46174013b3cbe5e382eefc39b4fd27bb", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 111, "deletions": 31, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -69,39 +69,120 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \t       || tyty->get_kind () == TyTy::TypeKind::FNPTR;\n   if (!is_fn)\n     {\n-      Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+      rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n+      Btype *compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n \n       // this assumes all fields are in order from type resolution and if a\n       // base struct was specified those fields are filed via accesors\n       std::vector<Bexpression *> vals;\n-      expr.iterate_params ([&] (HIR::Expr *argument) mutable -> bool {\n-\tBexpression *e = CompileExpr::Compile (argument, ctx);\n-\tvals.push_back (e);\n-\treturn true;\n-      });\n+      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n+\t{\n+\t  auto &argument = expr.get_arguments ().at (i);\n+\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\n+\t  // assignments are coercion sites so lets convert the rvalue if\n+\t  // necessary\n+\t  auto respective_field = adt->get_field (i);\n+\t  auto expected = respective_field->get_field_type ();\n+\n+\t  TyTy::BaseType *actual = nullptr;\n+\t  bool ok = ctx->get_tyctx ()->lookup_type (\n+\t    argument->get_mappings ().get_hirid (), &actual);\n+\t  rust_assert (ok);\n+\n+\t  // coerce it if required\n+\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+\n+\t  // add it to the list\n+\t  vals.push_back (rvalue);\n+\t}\n \n       translated\n-\t= ctx->get_backend ()->constructor_expression (type, vals, -1,\n-\t\t\t\t\t\t       expr.get_locus ());\n+\t= ctx->get_backend ()->constructor_expression (compiled_adt_type, vals,\n+\t\t\t\t\t\t       -1, expr.get_locus ());\n     }\n   else\n     {\n-      // must be a call to a function\n-      Bexpression *fn = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n-      rust_assert (fn != nullptr);\n+      auto get_parameter_tyty_at_index\n+\t= [] (const TyTy::BaseType *base, size_t index,\n+\t      TyTy::BaseType **result) -> bool {\n+\tbool is_fn = base->get_kind () == TyTy::TypeKind::FNDEF\n+\t\t     || base->get_kind () == TyTy::TypeKind::FNPTR;\n+\trust_assert (is_fn);\n+\n+\tif (base->get_kind () == TyTy::TypeKind::FNPTR)\n+\t  {\n+\t    const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (base);\n+\t    *result = fn->param_at (index);\n+\n+\t    return true;\n+\t  }\n+\n+\tconst TyTy::FnType *fn = static_cast<const TyTy::FnType *> (base);\n+\tauto param = fn->param_at (index);\n+\t*result = param.second;\n \n-      std::vector<Bexpression *> args;\n-      expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n-\tBexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n-\trust_assert (compiled_expr != nullptr);\n-\targs.push_back (compiled_expr);\n \treturn true;\n-      });\n+      };\n+\n+      bool is_varadic = false;\n+      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+\t{\n+\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n+\t  is_varadic = fn->is_varadic ();\n+\t}\n+\n+      size_t required_num_args;\n+      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+\t{\n+\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n+\t  required_num_args = fn->num_params ();\n+\t}\n+      else\n+\t{\n+\t  const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (tyty);\n+\t  required_num_args = fn->num_params ();\n+\t}\n \n+      std::vector<Bexpression *> args;\n+      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n+\t{\n+\t  auto &argument = expr.get_arguments ().at (i);\n+\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\n+\t  if (is_varadic && i >= required_num_args)\n+\t    {\n+\t      args.push_back (rvalue);\n+\t      continue;\n+\t    }\n+\n+\t  // assignments are coercion sites so lets convert the rvalue if\n+\t  // necessary\n+\t  bool ok;\n+\t  TyTy::BaseType *expected = nullptr;\n+\t  ok = get_parameter_tyty_at_index (tyty, i, &expected);\n+\t  rust_assert (ok);\n+\n+\t  TyTy::BaseType *actual = nullptr;\n+\t  ok = ctx->get_tyctx ()->lookup_type (\n+\t    argument->get_mappings ().get_hirid (), &actual);\n+\t  rust_assert (ok);\n+\n+\t  // coerce it if required\n+\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+\n+\t  // add it to the list\n+\t  args.push_back (rvalue);\n+\t}\n+\n+      // must be a call to a function\n+      auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n       auto fncontext = ctx->peek_fn ();\n       translated\n-\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn, args,\n-\t\t\t\t\t\tnullptr, expr.get_locus ());\n+\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn_address,\n+\t\t\t\t\t\targs, nullptr,\n+\t\t\t\t\t\texpr.get_locus ());\n     }\n }\n \n@@ -224,12 +305,12 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \n       std::vector<Bexpression *> args;\n       args.push_back (self_argument);\n-      expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n-\tBexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n-\trust_assert (compiled_expr != nullptr);\n-\targs.push_back (compiled_expr);\n-\treturn true;\n-      });\n+      for (auto &argument : expr.get_arguments ())\n+\t{\n+\t  Bexpression *compiled_expr\n+\t    = CompileExpr::Compile (argument.get (), ctx);\n+\t  args.push_back (compiled_expr);\n+\t}\n \n       Bexpression *fn_expr\n \t= ctx->get_backend ()->var_expression (fn_convert_expr_tmp,\n@@ -414,12 +495,11 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n   args.push_back (self);\n \n   // normal args\n-  expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n-    Bexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n-    rust_assert (compiled_expr != nullptr);\n-    args.push_back (compiled_expr);\n-    return true;\n-  });\n+  for (auto &argument : expr.get_arguments ())\n+    {\n+      Bexpression *compiled_expr = CompileExpr::Compile (argument.get (), ctx);\n+      args.push_back (compiled_expr);\n+    }\n \n   auto fncontext = ctx->peek_fn ();\n   translated"}, {"sha": "66de17d7433ff27273cc63a08c1871e027ad3653", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 9, "deletions": 53, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -796,14 +796,7 @@ class ArrayElemsValues : public ArrayElems\n \n   size_t get_num_elements () const { return values.size (); }\n \n-  void iterate (std::function<bool (Expr *)> cb)\n-  {\n-    for (auto it = values.begin (); it != values.end (); it++)\n-      {\n-\tif (!cb ((*it).get ()))\n-\t  return;\n-      }\n-  }\n+  std::vector<std::unique_ptr<Expr> > &get_values () { return values; }\n \n protected:\n   ArrayElemsValues *clone_array_elems_impl () const override\n@@ -1070,15 +1063,6 @@ class TupleExpr : public ExprWithoutBlock\n \n   bool is_unit () const { return tuple_elems.size () == 0; }\n \n-  void iterate (std::function<bool (Expr *)> cb)\n-  {\n-    for (auto &tuple_elem : tuple_elems)\n-      {\n-\tif (!cb (tuple_elem.get ()))\n-\t  return;\n-      }\n-  }\n-\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1491,15 +1475,6 @@ class StructExprStructFields : public StructExprStruct\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  void iterate (std::function<bool (StructExprField *)> cb)\n-  {\n-    for (auto &field : fields)\n-      {\n-\tif (!cb (field.get ()))\n-\t  return;\n-      }\n-  }\n-\n   std::vector<std::unique_ptr<StructExprField> > &get_fields ()\n   {\n     return fields;\n@@ -1510,11 +1485,6 @@ class StructExprStructFields : public StructExprStruct\n     return fields;\n   };\n \n-  std::vector<std::unique_ptr<StructExprField> > get_fields_as_owner ()\n-  {\n-    return std::move (fields);\n-  };\n-\n   void set_fields_as_owner (\n     std::vector<std::unique_ptr<StructExprField> > new_fields)\n   {\n@@ -1578,14 +1548,10 @@ class StructExprStructBase : public StructExprStruct\n   }\n };\n \n-// Forward decl for Function - used in CallExpr\n-class Function;\n-\n // Function call expression HIR node\n class CallExpr : public ExprWithoutBlock\n {\n   std::unique_ptr<Expr> function;\n-  // inlined form of CallParams\n   std::vector<std::unique_ptr<Expr> > params;\n \n   Location locus;\n@@ -1642,13 +1608,11 @@ class CallExpr : public ExprWithoutBlock\n \n   size_t num_params () const { return params.size (); }\n \n-  void iterate_params (std::function<bool (Expr *)> cb)\n+  std::vector<std::unique_ptr<Expr> > &get_arguments () { return params; }\n+\n+  const std::vector<std::unique_ptr<Expr> > &get_arguments () const\n   {\n-    for (auto &param : params)\n-      {\n-\tif (!cb (param.get ()))\n-\t  return;\n-      }\n+    return params;\n   }\n \n protected:\n@@ -1731,21 +1695,13 @@ class MethodCallExpr : public ExprWithoutBlock\n \n   PathExprSegment get_method_name () const { return method_name; };\n \n-  std::vector<std::unique_ptr<Expr> > &get_params () { return params; }\n-  const std::vector<std::unique_ptr<Expr> > &get_params () const\n-  {\n-    return params;\n-  }\n-\n   size_t num_params () const { return params.size (); }\n \n-  void iterate_params (std::function<bool (Expr *)> cb)\n+  std::vector<std::unique_ptr<Expr> > &get_arguments () { return params; }\n+\n+  const std::vector<std::unique_ptr<Expr> > &get_arguments () const\n   {\n-    for (auto &param : params)\n-      {\n-\tif (!cb (param.get ()))\n-\t  return;\n-      }\n+    return params;\n   }\n \n protected:"}, {"sha": "54e32f7465490c2e6f27a44596988de326428452", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -1492,14 +1492,7 @@ class StructStruct : public Struct\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  void iterate (std::function<bool (StructField &)> cb)\n-  {\n-    for (auto &field : fields)\n-      {\n-\tif (!cb (field))\n-\t  return;\n-      }\n-  }\n+  std::vector<StructField> &get_fields () { return fields; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object\n@@ -1610,15 +1603,6 @@ class TupleStruct : public Struct\n   std::vector<TupleField> &get_fields () { return fields; }\n   const std::vector<TupleField> &get_fields () const { return fields; }\n \n-  void iterate (std::function<bool (TupleField &)> cb)\n-  {\n-    for (auto &field : fields)\n-      {\n-\tif (!cb (field))\n-\t  return;\n-      }\n-  }\n-\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "4b095ab45bdf72c5b4a4afb9cd352e0d0ee5aa73", "filename": "gcc/rust/lint/rust-lint-marklive.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Flint%2Frust-lint-marklive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Flint%2Frust-lint-marklive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive.cc?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -149,10 +149,8 @@ MarkLive::visit (HIR::MethodCallExpr &expr)\n {\n   expr.get_receiver ()->accept_vis (*this);\n   visit_path_segment (expr.get_method_name ());\n-  expr.iterate_params ([&] (HIR::Expr *param) -> bool {\n-    param->accept_vis (*this);\n-    return true;\n-  });\n+  for (auto &argument : expr.get_arguments ())\n+    argument->accept_vis (*this);\n \n   // Trying to find the method definition and mark it alive.\n   NodeId ast_node_id = expr.get_mappings ().get_nodeid ();"}, {"sha": "7b7b68f3f976e4d95dc2339c11a34a825ab35c8e", "filename": "gcc/rust/lint/rust-lint-marklive.h", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive.h?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -81,18 +81,18 @@ class MarkLive : public MarkLiveBase\n \n   void visit (HIR::ArrayElemsValues &expr) override\n   {\n-    expr.iterate ([&] (HIR::Expr *expr) mutable -> bool {\n-      expr->accept_vis (*this);\n-      return true;\n-    });\n+    for (auto &elem : expr.get_values ())\n+      {\n+\telem->accept_vis (*this);\n+      }\n   }\n \n   void visit (HIR::TupleExpr &expr) override\n   {\n-    expr.iterate ([&] (HIR::Expr *expr) mutable -> bool {\n-      expr->accept_vis (*this);\n-      return true;\n-    });\n+    for (auto &elem : expr.get_tuple_elems ())\n+      {\n+\telem->accept_vis (*this);\n+      }\n   }\n \n   void visit (HIR::BlockExpr &expr) override\n@@ -165,10 +165,8 @@ class MarkLive : public MarkLiveBase\n   void visit (HIR::CallExpr &expr) override\n   {\n     expr.get_fnexpr ()->accept_vis (*this);\n-    expr.iterate_params ([&] (HIR::Expr *expr) -> bool {\n-      expr->accept_vis (*this);\n-      return true;\n-    });\n+    for (auto &argument : expr.get_arguments ())\n+      argument->accept_vis (*this);\n   }\n \n   void visit (HIR::ArithmeticOrLogicalExpr &expr) override\n@@ -236,10 +234,10 @@ class MarkLive : public MarkLiveBase\n \n   void visit (HIR::StructExprStructFields &stct) override\n   {\n-    stct.iterate ([&] (HIR::StructExprField *field) -> bool {\n-      field->accept_vis (*this);\n-      return true;\n-    });\n+    for (auto &field : stct.get_fields ())\n+      {\n+\tfield->accept_vis (*this);\n+      }\n \n     stct.get_struct_name ().accept_vis (*this);\n     if (stct.has_struct_base ())"}, {"sha": "152858a9e132cc4a607caf37e2b823496c16d7c5", "filename": "gcc/rust/lint/rust-lint-scan-deadcode.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Flint%2Frust-lint-scan-deadcode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Flint%2Frust-lint-scan-deadcode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-scan-deadcode.h?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -88,16 +88,16 @@ class ScanDeadcode : public MarkLiveBase\n     else\n       {\n \t// only warn the unused fields when in unwarned struct.\n-\tstct.iterate ([&] (HIR::StructField &field) -> bool {\n-\t  HirId field_hir_id = field.get_mappings ().get_hirid ();\n-\t  if (should_warn (field_hir_id))\n-\t    {\n-\t      rust_warning_at (field.get_locus (), 0,\n-\t\t\t       \"field is never read: %<%s%>\",\n-\t\t\t       field.get_field_name ().c_str ());\n-\t    }\n-\t  return true;\n-\t});\n+\tfor (auto &field : stct.get_fields ())\n+\t  {\n+\t    HirId field_hir_id = field.get_mappings ().get_hirid ();\n+\t    if (should_warn (field_hir_id))\n+\t      {\n+\t\trust_warning_at (field.get_locus (), 0,\n+\t\t\t\t \"field is never read: %<%s%>\",\n+\t\t\t\t field.get_field_name ().c_str ());\n+\t      }\n+\t  }\n       }\n   }\n "}, {"sha": "aa23e6494a5c88b14cf2f5a59c5378ba2bcec00a", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -880,10 +880,11 @@ class TypeCheckExpr : public TypeCheckBase\n   void visit (HIR::ArrayElemsValues &elems) override\n   {\n     std::vector<TyTy::BaseType *> types;\n-    elems.iterate ([&] (HIR::Expr *e) mutable -> bool {\n-      types.push_back (TypeCheckExpr::Resolve (e, false));\n-      return true;\n-    });\n+\n+    for (auto &elem : elems.get_values ())\n+      {\n+\ttypes.push_back (TypeCheckExpr::Resolve (elem.get (), false));\n+      }\n \n     infered_array_elems\n       = TyTy::TyVar::get_implicit_infer_var (root_array_expr_locus).get_tyty ();"}, {"sha": "3f8d17e53072242b21e87a1a1563dfd08278120a", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -144,17 +144,18 @@ class TypeCheckStmt : public TypeCheckBase\n     std::vector<TyTy::StructFieldType *> fields;\n \n     size_t idx = 0;\n-    struct_decl.iterate ([&] (HIR::TupleField &field) mutable -> bool {\n-      TyTy::BaseType *field_type\n-\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_field\n-\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t     std::to_string (idx), field_type);\n-      fields.push_back (ty_field);\n-      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n-      idx++;\n-      return true;\n-    });\n+    for (auto &field : struct_decl.get_fields ())\n+      {\n+\tTyTy::BaseType *field_type\n+\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n+\tTyTy::StructFieldType *ty_field\n+\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t       std::to_string (idx), field_type);\n+\tfields.push_back (ty_field);\n+\tcontext->insert_type (field.get_mappings (),\n+\t\t\t      ty_field->get_field_type ());\n+\tidx++;\n+      }\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n@@ -196,16 +197,17 @@ class TypeCheckStmt : public TypeCheckBase\n       }\n \n     std::vector<TyTy::StructFieldType *> fields;\n-    struct_decl.iterate ([&] (HIR::StructField &field) mutable -> bool {\n-      TyTy::BaseType *field_type\n-\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_field\n-\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t     field.get_field_name (), field_type);\n-      fields.push_back (ty_field);\n-      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n-      return true;\n-    });\n+    for (auto &field : struct_decl.get_fields ())\n+      {\n+\tTyTy::BaseType *field_type\n+\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n+\tTyTy::StructFieldType *ty_field\n+\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t       field.get_field_name (), field_type);\n+\tfields.push_back (ty_field);\n+\tcontext->insert_type (field.get_mappings (),\n+\t\t\t      ty_field->get_field_type ());\n+      }\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),"}, {"sha": "131149fabebf3b0441f7b10f65b91e58a34e64c2", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -79,17 +79,18 @@ class TypeCheckTopLevel : public TypeCheckBase\n     std::vector<TyTy::StructFieldType *> fields;\n \n     size_t idx = 0;\n-    struct_decl.iterate ([&] (HIR::TupleField &field) mutable -> bool {\n-      TyTy::BaseType *field_type\n-\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_field\n-\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t     std::to_string (idx), field_type);\n-      fields.push_back (ty_field);\n-      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n-      idx++;\n-      return true;\n-    });\n+    for (auto &field : struct_decl.get_fields ())\n+      {\n+\tTyTy::BaseType *field_type\n+\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n+\tTyTy::StructFieldType *ty_field\n+\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t       std::to_string (idx), field_type);\n+\tfields.push_back (ty_field);\n+\tcontext->insert_type (field.get_mappings (),\n+\t\t\t      ty_field->get_field_type ());\n+\tidx++;\n+      }\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n@@ -136,16 +137,18 @@ class TypeCheckTopLevel : public TypeCheckBase\n       }\n \n     std::vector<TyTy::StructFieldType *> fields;\n-    struct_decl.iterate ([&] (HIR::StructField &field) mutable -> bool {\n-      TyTy::BaseType *field_type\n-\t= TypeCheckType::Resolve (field.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_field\n-\t= new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n-\t\t\t\t     field.get_field_name (), field_type);\n-      fields.push_back (ty_field);\n-      context->insert_type (field.get_mappings (), ty_field->get_field_type ());\n-      return true;\n-    });\n+\n+    for (auto &field : struct_decl.get_fields ())\n+      {\n+\tTyTy::BaseType *field_type\n+\t  = TypeCheckType::Resolve (field.get_field_type ().get ());\n+\tTyTy::StructFieldType *ty_field\n+\t  = new TyTy::StructFieldType (field.get_mappings ().get_hirid (),\n+\t\t\t\t       field.get_field_name (), field_type);\n+\tfields.push_back (ty_field);\n+\tcontext->insert_type (field.get_mappings (),\n+\t\t\t      ty_field->get_field_type ());\n+      }\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),"}, {"sha": "ae5b2a01c53404e58f1523a8897234334f8832b9", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -153,20 +153,21 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n \n   std::vector<TyTy::StructFieldType *> infered_fields;\n   bool ok = true;\n-  struct_expr.iterate ([&] (HIR::StructExprField *field) mutable -> bool {\n-    resolved_field_value_expr = nullptr;\n-    field->accept_vis (*this);\n-    if (resolved_field_value_expr == nullptr)\n-      {\n-\trust_fatal_error (field->get_locus (),\n-\t\t\t  \"failed to resolve type for field\");\n-\tok = false;\n-\treturn false;\n-      }\n \n-    context->insert_type (field->get_mappings (), resolved_field_value_expr);\n-    return true;\n-  });\n+  for (auto &field : struct_expr.get_fields ())\n+    {\n+      resolved_field_value_expr = nullptr;\n+      field->accept_vis (*this);\n+      if (resolved_field_value_expr == nullptr)\n+\t{\n+\t  rust_fatal_error (field->get_locus (),\n+\t\t\t    \"failed to resolve type for field\");\n+\t  ok = false;\n+\t  break;\n+\t}\n+\n+      context->insert_type (field->get_mappings (), resolved_field_value_expr);\n+    }\n \n   // something failed setting up the fields\n   if (!ok)\n@@ -266,10 +267,8 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n       // correctly. The GIMPLE backend uses a simple algorithm that assumes each\n       // assigned field in the constructor is in the same order as the field in\n       // the type\n-      std::vector<std::unique_ptr<HIR::StructExprField> > expr_fields\n-\t= struct_expr.get_fields_as_owner ();\n-      for (auto &f : expr_fields)\n-\tf.release ();\n+      for (auto &field : struct_expr.get_fields ())\n+\tfield.release ();\n \n       std::vector<std::unique_ptr<HIR::StructExprField> > ordered_fields;\n       for (size_t i = 0; i < adtFieldIndexToField.size (); i++)"}, {"sha": "6856d0538b8e32931264d3929096e4fd2a5e7bdc", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -162,11 +162,11 @@ class TypeResolverDump : public TypeCheckBase\n \n   void visit (HIR::ArrayElemsValues &elems) override\n   {\n-    elems.iterate ([&] (HIR::Expr *e) mutable -> bool {\n-      e->accept_vis (*this);\n-      dump += \",\";\n-      return true;\n-    });\n+    for (auto &elem : elems.get_values ())\n+      {\n+\telem->accept_vis (*this);\n+\tdump += \",\";\n+      }\n   }\n \n   void visit (HIR::GroupedExpr &expr) override"}, {"sha": "3f0d8a36195674f61daed063450c8b12636f46a1", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 90, "deletions": 84, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -2383,27 +2383,28 @@ TypeCheckCallExpr::visit (ADTType &type)\n     }\n \n   size_t i = 0;\n-  call.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n-    StructFieldType *field = type.get_field (i);\n-    BaseType *field_tyty = field->get_field_type ();\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      StructFieldType *field = type.get_field (i);\n+      BaseType *field_tyty = field->get_field_type ();\n \n-    BaseType *arg = Resolver::TypeCheckExpr::Resolve (p, false);\n-    if (arg->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (p->get_locus (), \"failed to resolve argument type\");\n-\treturn false;\n-      }\n+      BaseType *arg = Resolver::TypeCheckExpr::Resolve (argument.get (), false);\n+      if (arg->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"failed to resolve argument type\");\n+\t  return;\n+\t}\n \n-    auto res = field_tyty->coerce (arg);\n-    if (res->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\treturn false;\n-      }\n+      auto res = field_tyty->coerce (arg);\n+      if (res->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  return;\n+\t}\n \n-    delete res;\n-    i++;\n-    return true;\n-  });\n+      delete res;\n+      i++;\n+    }\n \n   if (i != call.num_params ())\n     {\n@@ -2441,35 +2442,36 @@ TypeCheckCallExpr::visit (FnType &type)\n     }\n \n   size_t i = 0;\n-  call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n-    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param, false);\n-    if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (param->get_locus (),\n-\t\t       \"failed to resolve type for argument expr in CallExpr\");\n-\treturn false;\n-      }\n-\n-    auto resolved_argument_type = argument_expr_tyty;\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get (), false);\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n \n-    // it might be a varadic function\n-    if (i < type.num_params ())\n-      {\n-\tauto fnparam = type.param_at (i);\n-\tresolved_argument_type = fnparam.second->coerce (argument_expr_tyty);\n-\tif (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  {\n-\t    rust_error_at (param->get_locus (),\n-\t\t\t   \"Type Resolution failure on parameter\");\n-\t    return false;\n-\t  }\n-      }\n+      // it might be a varadic function\n+      if (i < type.num_params ())\n+\t{\n+\t  auto fnparam = type.param_at (i);\n+\t  auto resolved_argument_type\n+\t    = fnparam.second->coerce (argument_expr_tyty);\n+\t  if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+\t    {\n+\t      rust_error_at (argument->get_locus (),\n+\t\t\t     \"Type Resolution failure on parameter\");\n+\t      return;\n+\t    }\n+\t}\n \n-    context->insert_type (param->get_mappings (), resolved_argument_type);\n+      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n \n-    i++;\n-    return true;\n-  });\n+      i++;\n+    }\n \n   if (i < call.num_params ())\n     {\n@@ -2505,29 +2507,31 @@ TypeCheckCallExpr::visit (FnPtr &type)\n     }\n \n   size_t i = 0;\n-  call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n-    auto fnparam = type.param_at (i);\n-    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param, false);\n-    if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (param->get_locus (),\n-\t\t       \"failed to resolve type for argument expr in CallExpr\");\n-\treturn false;\n-      }\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto fnparam = type.param_at (i);\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get (), false);\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n \n-    auto resolved_argument_type = fnparam->coerce (argument_expr_tyty);\n-    if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (param->get_locus (),\n-\t\t       \"Type Resolution failure on parameter\");\n-\treturn false;\n-      }\n+      auto resolved_argument_type = fnparam->coerce (argument_expr_tyty);\n+      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"Type Resolution failure on parameter\");\n+\t  return;\n+\t}\n \n-    context->insert_type (param->get_mappings (), resolved_argument_type);\n+      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n \n-    i++;\n-    return true;\n-  });\n+      i++;\n+    }\n \n   if (i != call.num_params ())\n     {\n@@ -2556,29 +2560,31 @@ TypeCheckMethodCallExpr::visit (FnType &type)\n     }\n \n   size_t i = 1;\n-  call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n-    auto fnparam = type.param_at (i);\n-    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param, false);\n-    if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (param->get_locus (),\n-\t\t       \"failed to resolve type for argument expr in CallExpr\");\n-\treturn false;\n-      }\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto fnparam = type.param_at (i);\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get (), false);\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n \n-    auto resolved_argument_type = fnparam.second->coerce (argument_expr_tyty);\n-    if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (param->get_locus (),\n-\t\t       \"Type Resolution failure on parameter\");\n-\treturn false;\n-      }\n+      auto resolved_argument_type = fnparam.second->coerce (argument_expr_tyty);\n+      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"Type Resolution failure on parameter\");\n+\t  return;\n+\t}\n \n-    context->insert_type (param->get_mappings (), resolved_argument_type);\n+      context->insert_type (argument->get_mappings (), argument_expr_tyty);\n \n-    i++;\n-    return true;\n-  });\n+      i++;\n+    }\n \n   if (i != num_args_to_call)\n     {"}, {"sha": "3ab374a97b43588de4558bf347490d2c4c627206", "filename": "gcc/testsuite/rust/compile/func3.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ffunc3.rs?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -3,5 +3,9 @@ fn test(a: i32, b: i32) -> i32 {\n }\n \n fn main() {\n-    let a = test(1, true); // { dg-error \"expected .i32. got .bool.\" }\n+    let a = test(1, true);\n+    // { dg-error \"expected .i32. got .bool.\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"Type Resolution failure on parameter\" \"\" { target *-*-* } .-2 }\n+    // { dg-error \"failed to lookup type to CallExpr\" \"\" { target *-*-* } .-3 }\n+    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-4 }\n }"}, {"sha": "a70306df852b7256379486dc6de91c051a043c4f", "filename": "gcc/testsuite/rust/compile/tuple_struct3.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftuple_struct3.rs?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -3,7 +3,6 @@ struct Foo(i32, i32, bool);\n fn main() {\n     let c = Foo(1, 2f32, true);\n     // { dg-error \"expected .i32. got .f32.\" \"\" { target *-*-* } .-1 }\n-    // { dg-error \"unexpected number of arguments 1 expected 3\" \"\" { target *-*-* } .-2 }\n-    // { dg-error \"failed to lookup type to CallExpr\" \"\" { target *-*-* } .-3 }\n-    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-4 }\n+    // { dg-error \"failed to lookup type to CallExpr\" \"\" { target *-*-* } .-2 }\n+    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-3 }\n }"}, {"sha": "dff98098a425ef60fa04ce36b44c161edad1a524", "filename": "gcc/testsuite/rust/execute/torture/coercion1.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcoercion1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcoercion1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcoercion1.rs?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-output \"123\\n123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct Foo(i32);\n+trait Bar {\n+    fn baz(&self);\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+impl Bar for Foo {\n+    fn baz(&self) {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, self.0);\n+        }\n+    }\n+}\n+\n+fn static_dispatch<T: Bar>(t: &T) {\n+    t.baz();\n+}\n+\n+fn dynamic_dispatch(t: &dyn Bar) {\n+    t.baz();\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = Foo(123);\n+    static_dispatch(&a);\n+\n+    let b: &dyn Bar;\n+    b = &a;\n+    dynamic_dispatch(b);\n+\n+    0\n+}"}, {"sha": "e4049546787512dbc5db8f408f8c04af432ccc91", "filename": "gcc/testsuite/rust/execute/torture/coercion2.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcoercion2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a341772dcf51445af08071eeb0ed0ea93cd60a1/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcoercion2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcoercion2.rs?ref=7a341772dcf51445af08071eeb0ed0ea93cd60a1", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"123\\n123\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct Foo(i32);\n+trait Bar {\n+    fn baz(&self);\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+impl Bar for Foo {\n+    fn baz(&self) {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, self.0);\n+        }\n+    }\n+}\n+\n+fn static_dispatch<T: Bar>(t: &T) {\n+    t.baz();\n+}\n+\n+fn dynamic_dispatch(t: &dyn Bar) {\n+    t.baz();\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = &Foo(123);\n+\n+    static_dispatch(a);\n+    dynamic_dispatch(a);\n+\n+    0\n+}"}]}