{"sha": "a43e0dfb63ffb63e400b69acac6dd614b203d4fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQzZTBkZmI2M2ZmYjYzZTQwMGI2OWFjYWM2ZGQ2MTRiMjAzZDRmZQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2021-01-25T19:18:14Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2021-01-25T19:21:39Z"}, "message": "Add test case for PR 96843.\n\ngcc/testsuite/ChangeLog:\n\n\tPR fortran/96843\n\t* gfortran.dg/interface_assignment_7.f90: New test.", "tree": {"sha": "ea1e733fa43b64151a43b70c005a5d038c94adf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea1e733fa43b64151a43b70c005a5d038c94adf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a43e0dfb63ffb63e400b69acac6dd614b203d4fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a43e0dfb63ffb63e400b69acac6dd614b203d4fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a43e0dfb63ffb63e400b69acac6dd614b203d4fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a43e0dfb63ffb63e400b69acac6dd614b203d4fe/comments", "author": null, "committer": null, "parents": [{"sha": "0194e2f02d72731e444ae2076db339ffb1448435", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0194e2f02d72731e444ae2076db339ffb1448435", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0194e2f02d72731e444ae2076db339ffb1448435"}], "stats": {"total": 84, "additions": 84, "deletions": 0}, "files": [{"sha": "89e15e5016814ad48baff7d8b220751ceba54a2e", "filename": "gcc/testsuite/gfortran.dg/interface_assignment_7.f90", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a43e0dfb63ffb63e400b69acac6dd614b203d4fe/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_assignment_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a43e0dfb63ffb63e400b69acac6dd614b203d4fe/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_assignment_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_assignment_7.f90?ref=a43e0dfb63ffb63e400b69acac6dd614b203d4fe", "patch": "@@ -0,0 +1,84 @@\n+! { dg-do compile }\n+! PR 96843 - this was wrongly rejected.\n+! Test case by William Clodius.\n+\n+module test_shape_mismatch\n+! Implements zero based bitsets of size up to HUGE(0_INT32).\n+! The current code uses 32 bit integers to store the bits and uses all 32 bits.\n+! The code assumes two's complement integers, and treats negative integers as\n+! having the sign bit set.\n+\n+    use, intrinsic ::            &\n+        iso_fortran_env, only:   &\n+            bits_kind  => int32, &\n+            block_kind => int64, &\n+            int8,                &\n+            dp => real64\n+\n+    implicit none\n+\n+    private\n+\n+    integer, parameter ::                                                     &\n+        block_size  = bit_size(0_block_kind),                                 &\n+        block_shift = int( ceiling( log( real(block_size, dp) )/log(2._dp) ) )\n+\n+    public :: bits_kind\n+! Public constant\n+\n+    public :: bitset_t\n+! Public type\n+\n+    public ::          &\n+        assignment(=)\n+\n+    type, abstract :: bitset_t\n+        private\n+        integer(bits_kind) :: num_bits\n+\n+    end type bitset_t\n+\n+\n+    type, extends(bitset_t) :: bitset_large\n+        private\n+        integer(block_kind), private, allocatable :: blocks(:)\n+\n+    end type bitset_large\n+\n+    interface assign\n+\n+        pure module subroutine assign_log8_large( self, alogical )\n+!!     Used to define assignment from an array of type LOG for bitset_t\n+            type(bitset_large), intent(out) :: self\n+            logical(int8), intent(in) :: alogical(:)\n+        end subroutine assign_log8_large\n+\n+    end interface assign\n+\n+contains\n+\n+    pure module subroutine assign_log8_large( self, alogical )\n+!     Used to define assignment from an array of type LOG for bitset_t\n+        type(bitset_large), intent(out) :: self\n+        logical(int8), intent(in)  :: alogical(:)\n+\n+        integer(bits_kind) :: blocks\n+        integer(bits_kind) :: log_size\n+        integer(bits_kind) :: index\n+\n+        log_size = size( alogical, kind=bits_kind )\n+        self % num_bits = log_size\n+        if ( log_size == 0 ) then\n+            blocks = 0\n+\n+        else\n+            blocks = (log_size-1)/block_size + 1\n+\n+        end if\n+        allocate( self % blocks( blocks ) )\n+        self % blocks(:) = 0\n+\n+        return\n+    end subroutine assign_log8_large\n+\n+end module test_shape_mismatch"}]}