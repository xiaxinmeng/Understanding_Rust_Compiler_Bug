{"sha": "716c2d08893110f186f0fb94849524b1acf9dd02", "node_id": "C_kwDOANBUbNoAKDcxNmMyZDA4ODkzMTEwZjE4NmYwZmI5NDg0OTUyNGIxYWNmOWRkMDI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-12-08T09:41:49Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-12-08T09:43:27Z"}, "message": "range-op-float: frange_arithmetic tweaks for MODE_COMPOSITE_P\n\nAs mentioned in PR107967, ibm-ldouble-format documents that\n+- has 1ulp accuracy, * 2ulps and / 3ulps.\nSo, even if the result is exact, we need to widen the range a little bit.\n\nThe following patch does that.  I just wonder what it means for reverse\ndivision (the op1_range case), which we implement through multiplication,\nwhen division has 3ulps error and multiplication just 2ulps.  In any case,\nthis format is a mess and for non-default rounding modes can't be trusted\nat all, instead of +inf or something close to it it happily computes -inf.\n\n2022-12-08  Jakub Jelinek  <jakub@redhat.com>\n\n\t* range-op-float.cc (frange_nextafter): For MODE_COMPOSITE_P from\n\tdenormal or zero, use real_nextafter on DFmode with conversions\n\taround it.\n\t(frange_arithmetic): For mode_composite, on top of rounding in the\n\tright direction accept extra 1ulp error for PLUS/MINUS_EXPR, extra\n\t2ulps error for MULT_EXPR and extra 3ulps error for RDIV_EXPR.", "tree": {"sha": "07bfae80ed36e34ca0a10c9ca782fde6b7c65824", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07bfae80ed36e34ca0a10c9ca782fde6b7c65824"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/716c2d08893110f186f0fb94849524b1acf9dd02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/716c2d08893110f186f0fb94849524b1acf9dd02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/716c2d08893110f186f0fb94849524b1acf9dd02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/716c2d08893110f186f0fb94849524b1acf9dd02/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d4f007398bc3f8fea812fb8cff4d7d0556d12f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d4f007398bc3f8fea812fb8cff4d7d0556d12f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d4f007398bc3f8fea812fb8cff4d7d0556d12f1"}], "stats": {"total": 62, "additions": 46, "deletions": 16}, "files": [{"sha": "929ff9c3f870647c5e06ecbbb648cda8b4c41c8e", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/716c2d08893110f186f0fb94849524b1acf9dd02/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/716c2d08893110f186f0fb94849524b1acf9dd02/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=716c2d08893110f186f0fb94849524b1acf9dd02", "patch": "@@ -254,10 +254,21 @@ frange_nextafter (enum machine_mode mode,\n \t\t  REAL_VALUE_TYPE &value,\n \t\t  const REAL_VALUE_TYPE &inf)\n {\n-  const real_format *fmt = REAL_MODE_FORMAT (mode);\n-  REAL_VALUE_TYPE tmp;\n-  real_nextafter (&tmp, fmt, &value, &inf);\n-  value = tmp;\n+  if (MODE_COMPOSITE_P (mode)\n+      && (real_isdenormal (&value, mode) || real_iszero (&value)))\n+    {\n+      // IBM extended denormals only have DFmode precision.\n+      REAL_VALUE_TYPE tmp, tmp2;\n+      real_convert (&tmp2, DFmode, &value);\n+      real_nextafter (&tmp, REAL_MODE_FORMAT (DFmode), &tmp2, &inf);\n+      real_convert (&value, mode, &tmp);\n+    }\n+  else\n+    {\n+      REAL_VALUE_TYPE tmp;\n+      real_nextafter (&tmp, REAL_MODE_FORMAT (mode), &value, &inf);\n+      value = tmp;\n+    }\n }\n \n // Like real_arithmetic, but round the result to INF if the operation\n@@ -324,21 +335,40 @@ frange_arithmetic (enum tree_code code, tree type,\n     }\n   if (round && (inexact || !real_identical (&result, &value)))\n     {\n-      if (mode_composite)\n+      if (mode_composite\n+\t  && (real_isdenormal (&result, mode) || real_iszero (&result)))\n \t{\n-\t  if (real_isdenormal (&result, mode)\n-\t      || real_iszero (&result))\n-\t    {\n-\t      // IBM extended denormals only have DFmode precision.\n-\t      REAL_VALUE_TYPE tmp;\n-\t      real_convert (&tmp, DFmode, &value);\n-\t      frange_nextafter (DFmode, tmp, inf);\n-\t      real_convert (&result, mode, &tmp);\n-\t      return;\n-\t    }\n+\t  // IBM extended denormals only have DFmode precision.\n+\t  REAL_VALUE_TYPE tmp, tmp2;\n+\t  real_convert (&tmp2, DFmode, &value);\n+\t  real_nextafter (&tmp, REAL_MODE_FORMAT (DFmode), &tmp2, &inf);\n+\t  real_convert (&result, mode, &tmp);\n \t}\n-      frange_nextafter (mode, result, inf);\n+      else\n+\tfrange_nextafter (mode, result, inf);\n     }\n+  if (mode_composite)\n+    switch (code)\n+      {\n+      case PLUS_EXPR:\n+      case MINUS_EXPR:\n+\t// ibm-ldouble-format documents 1ulp for + and -.\n+\tfrange_nextafter (mode, result, inf);\n+\tbreak;\n+      case MULT_EXPR:\n+\t// ibm-ldouble-format documents 2ulps for *.\n+\tfrange_nextafter (mode, result, inf);\n+\tfrange_nextafter (mode, result, inf);\n+\tbreak;\n+      case RDIV_EXPR:\n+\t// ibm-ldouble-format documents 3ulps for /.\n+\tfrange_nextafter (mode, result, inf);\n+\tfrange_nextafter (mode, result, inf);\n+\tfrange_nextafter (mode, result, inf);\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n }\n \n // Crop R to [-INF, MAX] where MAX is the maximum representable number"}]}