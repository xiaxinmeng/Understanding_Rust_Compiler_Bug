{"sha": "749cc4b1b349c9217caca37d234e7786d04ddfbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ5Y2M0YjFiMzQ5YzkyMTdjYWNhMzdkMjM0ZTc3ODZkMDRkZGZiYg==", "commit": {"author": {"name": "Harsha Jagasia", "email": "harsha.jagasia@amd.com", "date": "2007-12-06T16:18:55Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2007-12-06T16:18:55Z"}, "message": "tree-vectorizer.c (slpeel_add_loop_guard): Gimplify the condition.\n\n2007-12-05  Harsha Jagasia <harsha.jagasia@amd.com>\n\n\t* tree-vectorizer.c (slpeel_add_loop_guard): Gimplify the condition.\n\t(set_prologue_iterations): New. Set the prologue iterations to total\n\tnumber of scalar iterations if the cost model check indicates that\n\tscalar code should be generated.\n\t(slpeel_tree_peel_loop_to_edge): Add a new parameter and code for \n\tgenerating the cost condition for epilog. Call\n\tset_prologue_iterations to generate cost condition for prolog.\n\t(new_loop_vec_info): Initialize LOOP_VINFO_NITERS_UNCHANGED.\n\t* tree-vectorizer.h (LOOP_VINFO_NITERS_UNCHANGED): New.\n\t(slpeel_tree_peel_loop_to_edge): Update declaration.\n\t(set_prologue_iterations): New declaration.\n\t* tree-vect-analyze.c (vect_analyze_loop_form): Update \n\tLOOP_VINFO_NITERS_UNCHANGED.\n\t* tree-vect-transform.c\n\t(vect_estimate_min_profitable_iters): Add new parameter and\n\tcode to  check if run time cost model test is needed.\n\tRemove code that adds builtin vectorization cost to scalar\n\toutside cost for the run time cost model test. If run time\n\tcost model test is needed add the appropriate guard cost to\n\tthe scalar outside cost. The guard cost depends on whether\n\tthe guard is generated at versioning or at prolog generation\n\tor at epilog generation. Change cost model equation to include\n\tscalar outside cost.\n\t(conservative_cost_threshold): New. Return the less conservative\n\tprofitability threshold between the cost model threshold and the\n\tuser defined vectorization threshold.\n\t(vect_do_peeling_for_loop_bound): Call conservative_cost_threshold.\n\t(vect_do_peeling_for_alignment): Same.\n\t(vect_loop_versioning): Same.\n\t(vect_create_cond_for_align_checks): ANDs the cost model condition\n\twith the alignment condition.\n\t(vect_transform_loop): Call loop versioning only when there is a\n\tmisalignment or an aliasing problem.\n\nFrom-SVN: r130651", "tree": {"sha": "eabb8bb49cc28e95fea4f091f4b02dd6cac4ad30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eabb8bb49cc28e95fea4f091f4b02dd6cac4ad30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/749cc4b1b349c9217caca37d234e7786d04ddfbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749cc4b1b349c9217caca37d234e7786d04ddfbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/749cc4b1b349c9217caca37d234e7786d04ddfbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749cc4b1b349c9217caca37d234e7786d04ddfbb/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7bd8aebf66a8a05e02b6b3e6be7169e13532380", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7bd8aebf66a8a05e02b6b3e6be7169e13532380", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7bd8aebf66a8a05e02b6b3e6be7169e13532380"}], "stats": {"total": 529, "additions": 447, "deletions": 82}, "files": [{"sha": "7994797e19ffb7239f52dae13bbc4fb4626c3fb4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749cc4b1b349c9217caca37d234e7786d04ddfbb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749cc4b1b349c9217caca37d234e7786d04ddfbb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=749cc4b1b349c9217caca37d234e7786d04ddfbb", "patch": "@@ -1,3 +1,39 @@\n+2007-12-06  Harsha Jagasia <harsha.jagasia@amd.com>\n+\n+\t* tree-vectorizer.c (slpeel_add_loop_guard): Gimplify the condition.\n+\t(set_prologue_iterations): New. Set the prologue iterations to total\n+\tnumber of scalar iterations if the cost model check indicates that\n+\tscalar code should be generated.\n+\t(slpeel_tree_peel_loop_to_edge): Add a new parameter and code for \n+\tgenerating the cost condition for epilog. Call\n+\tset_prologue_iterations to generate cost condition for prolog.\n+\t(new_loop_vec_info): Initialize LOOP_VINFO_NITERS_UNCHANGED.\n+\t* tree-vectorizer.h (LOOP_VINFO_NITERS_UNCHANGED): New.\n+\t(slpeel_tree_peel_loop_to_edge): Update declaration.\n+\t(set_prologue_iterations): New declaration.\n+\t* tree-vect-analyze.c (vect_analyze_loop_form): Update \n+\tLOOP_VINFO_NITERS_UNCHANGED.\n+\t* tree-vect-transform.c\n+\t(vect_estimate_min_profitable_iters): Add new parameter and\n+\tcode to  check if run time cost model test is needed.\n+\tRemove code that adds builtin vectorization cost to scalar\n+\toutside cost for the run time cost model test. If run time\n+\tcost model test is needed add the appropriate guard cost to\n+\tthe scalar outside cost. The guard cost depends on whether\n+\tthe guard is generated at versioning or at prolog generation\n+\tor at epilog generation. Change cost model equation to include\n+\tscalar outside cost.\n+\t(conservative_cost_threshold): New. Return the less conservative\n+\tprofitability threshold between the cost model threshold and the\n+\tuser defined vectorization threshold.\n+\t(vect_do_peeling_for_loop_bound): Call conservative_cost_threshold.\n+\t(vect_do_peeling_for_alignment): Same.\n+\t(vect_loop_versioning): Same.\n+\t(vect_create_cond_for_align_checks): ANDs the cost model condition\n+\twith the alignment condition.\n+\t(vect_transform_loop): Call loop versioning only when there is a\n+\tmisalignment or an aliasing problem.\n+\n 2007-12-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/20983"}, {"sha": "3e8002f172b6b6713d5584289c4249c4e1b16798", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749cc4b1b349c9217caca37d234e7786d04ddfbb/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749cc4b1b349c9217caca37d234e7786d04ddfbb/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=749cc4b1b349c9217caca37d234e7786d04ddfbb", "patch": "@@ -602,6 +602,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n   min_profitable_iters = vect_estimate_min_profitable_iters (loop_vinfo);\n   LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo) = min_profitable_iters;\n+\n   if (min_profitable_iters < 0)\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n@@ -4216,6 +4217,7 @@ vect_analyze_loop_form (struct loop *loop)\n \n   loop_vinfo = new_loop_vec_info (loop);\n   LOOP_VINFO_NITERS (loop_vinfo) = number_of_iterations;\n+  LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = number_of_iterations;\n \n   STMT_VINFO_TYPE (vinfo_for_stmt (loop_cond)) = loop_exit_ctrl_vec_info_type;\n "}, {"sha": "8883ee1bf9b3cc262bca991f1da3d0d77bb86038", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 197, "deletions": 61, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749cc4b1b349c9217caca37d234e7786d04ddfbb/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749cc4b1b349c9217caca37d234e7786d04ddfbb/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=749cc4b1b349c9217caca37d234e7786d04ddfbb", "patch": "@@ -119,11 +119,13 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   int vec_inside_cost = 0;\n   int vec_outside_cost = 0;\n   int scalar_single_iter_cost = 0;\n+  int scalar_outside_cost = 0;\n+  bool runtime_test = false;\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n-  int byte_misalign;\n+  int byte_misalign = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n   int peel_guard_costs = 0;\n   int innerloop_iters = 0, factor;\n   VEC (slp_instance, heap) *slp_instances;\n@@ -137,6 +139,13 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n       return 0;\n     }\n \n+  /* If the number of iterations is unknown, or the\n+     peeling-for-misalignment amount is unknown, we will have to generate\n+     a runtime test to test the loop count against the threshold.    */\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      || (byte_misalign < 0))\n+    runtime_test = true;\n+\n   /* Requires loop versioning tests to handle misalignment.  */\n \n   if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo)))\n@@ -211,8 +220,6 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n      TODO: Build an expression that represents peel_iters for prologue and\n      epilogue to be used in a run-time test.  */\n \n-  byte_misalign = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n-\n   if (byte_misalign < 0)\n     {\n       peel_iters_prologue = vf/2;\n@@ -276,24 +283,72 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n                       + (peel_iters_epilogue * scalar_single_iter_cost)\n                       + peel_guard_costs;\n \n-  /* Allow targets add additional (outside-of-loop) costs. FORNOW, the only\n-     information we provide for the target is whether testing against the\n-     threshold involves a runtime test.  */\n-  if (targetm.vectorize.builtin_vectorization_cost)\n-    {\n-      bool runtime_test = false;\n-\n-      /* If the number of iterations is unknown, or the\n-\t peeling-for-misalignment amount is unknown, we eill have to generate\n-\t a runtime test to test the loop count against the threshold.  */\n-      if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-\t  || (byte_misalign < 0))\n-\truntime_test = true;\n-      vec_outside_cost +=\n-\ttargetm.vectorize.builtin_vectorization_cost (runtime_test);\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"cost model : Adding target out-of-loop cost = %d\",\n-\t\t  targetm.vectorize.builtin_vectorization_cost (runtime_test));\n+  /* FORNOW: The scalar outside cost is incremented in one of the\n+     following ways:\n+\n+     1. The vectorizer checks for alignment and aliasing and generates\n+     a condition that allows dynamic vectorization.  A cost model\n+     check is ANDED with the versioning condition.  Hence scalar code\n+     path now has the added cost of the versioning check.\n+\n+       if (cost > th & versioning_check)\n+         jmp to vector code\n+\n+     Hence run-time scalar is incremented by not-taken branch cost.\n+\n+     2. The vectorizer then checks if a prologue is required.  If the\n+     cost model check was not done before during versioning, it has to\n+     be done before the prologue check.\n+\n+       if (cost <= th)\n+         prologue = scalar_iters\n+       if (prologue == 0)\n+         jmp to vector code\n+       else\n+         execute prologue\n+       if (prologue == num_iters)\n+\t go to exit\n+\n+     Hence the run-time scalar cost is incremented by a taken branch,\n+     plus a not-taken branch, plus a taken branch cost.\n+\n+     3. The vectorizer then checks if an epilogue is required.  If the\n+     cost model check was not done before during prologue check, it\n+     has to be done with the epilogue check.\n+\n+       if (prologue == 0)\n+         jmp to vector code\n+       else\n+         execute prologue\n+       if (prologue == num_iters)\n+\t go to exit\n+       vector code:\n+         if ((cost <= th) | (scalar_iters-prologue-epilogue == 0))\n+           jmp to epilogue\n+\n+     Hence the run-time scalar cost should be incremented by 2 taken\n+     branches.\n+\n+     TODO: The back end may reorder the BBS's differently and reverse\n+     conditions/branch directions.  Change the stimates below to\n+     something more reasonable.  */\n+\n+  if (runtime_test)\n+    {\n+      /* Cost model check occurs at versioning.  */\n+      if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n+\t  || VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n+\tscalar_outside_cost += TARG_COND_NOT_TAKEN_BRANCH_COST;\n+      else\n+\t{\n+\t  /* Cost model occurs at prologue generation.  */\n+\t  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+\t    scalar_outside_cost += 2 * TARG_COND_TAKEN_BRANCH_COST\n+\t      + TARG_COND_NOT_TAKEN_BRANCH_COST;\n+\t  /* Cost model check occurs at epilogue generation.  */\n+\t  else\n+\t    scalar_outside_cost += 2 * TARG_COND_TAKEN_BRANCH_COST;\n+\t}\n     }\n \n   /* Add SLP costs.  */\n@@ -306,25 +361,29 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n   /* Calculate number of iterations required to make the vector version \n      profitable, relative to the loop bodies only. The following condition\n-     must hold true: ((SIC*VF)-VIC)*niters > VOC*VF, where\n+     must hold true: \n+     SIC * niters + SOC > VIC * ((niters-PL_ITERS-EP_ITERS)/VF) + VOC\n+     where\n      SIC = scalar iteration cost, VIC = vector iteration cost,\n-     VOC = vector outside cost and VF = vectorization factor.  */\n+     VOC = vector outside cost, VF = vectorization factor,\n+     PL_ITERS = prologue iterations, EP_ITERS= epilogue iterations\n+     SOC = scalar outside cost for run time cost model check.  */\n \n   if ((scalar_single_iter_cost * vf) > vec_inside_cost)\n     {\n       if (vec_outside_cost <= 0)\n         min_profitable_iters = 1;\n       else\n         {\n-          min_profitable_iters = (vec_outside_cost * vf \n-                                  - vec_inside_cost * peel_iters_prologue\n+          min_profitable_iters = ((vec_outside_cost - scalar_outside_cost) * vf\n+\t\t\t\t  - vec_inside_cost * peel_iters_prologue\n                                   - vec_inside_cost * peel_iters_epilogue)\n                                  / ((scalar_single_iter_cost * vf)\n                                     - vec_inside_cost);\n \n           if ((scalar_single_iter_cost * vf * min_profitable_iters)\n               <= ((vec_inside_cost * min_profitable_iters)\n-                  + (vec_outside_cost * vf)))\n+                  + ((vec_outside_cost - scalar_outside_cost) * vf)))\n             min_profitable_iters++;\n         }\n     }\n@@ -346,7 +405,9 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \t       vec_inside_cost);\n       fprintf (vect_dump, \"  Vector outside of loop cost: %d\\n\",\n \t       vec_outside_cost);\n-      fprintf (vect_dump, \"  Scalar cost: %d\\n\", scalar_single_iter_cost);\n+      fprintf (vect_dump, \"  Scalar iteration cost: %d\\n\",\n+\t       scalar_single_iter_cost);\n+      fprintf (vect_dump, \"  Scalar outside cost: %d\\n\", scalar_outside_cost);\n       fprintf (vect_dump, \"  prologue iterations: %d\\n\",\n                peel_iters_prologue);\n       fprintf (vect_dump, \"  epilogue iterations: %d\\n\",\n@@ -6467,6 +6528,37 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n     }\n }\n \n+/* Return the more conservative threshold between the\n+   min_profitable_iters returned by the cost model and the user\n+   specified threshold, if provided.  */\n+\n+static unsigned int\n+conservative_cost_threshold (loop_vec_info loop_vinfo,\n+\t\t\t     int min_profitable_iters)\n+{\n+  unsigned int th;\n+  int min_scalar_loop_bound;\n+\n+  min_scalar_loop_bound = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n+\t\t\t    * LOOP_VINFO_VECT_FACTOR (loop_vinfo)) - 1);\n+\n+  /* Use the cost model only if it is more conservative than user specified\n+     threshold.  */\n+  th = (unsigned) min_scalar_loop_bound;\n+  if (min_profitable_iters\n+      && (!min_scalar_loop_bound\n+          || min_profitable_iters > min_scalar_loop_bound))\n+    th = (unsigned) min_profitable_iters;\n+\n+  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\t      \n+    fprintf (vect_dump, \"not vectorized: vectorization may not be\"\n+\t     \"profitable.\");\n+  \n+  if (th && vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"Vectorization may not be profitable.\");\n+\n+  return th;\n+}\n \n /* Function vect_do_peeling_for_loop_bound\n \n@@ -6487,8 +6579,8 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n   edge update_e;\n   basic_block preheader;\n   int loop_num;\n-  unsigned int th;\n-  int min_scalar_loop_bound;\n+  bool check_profitability = false;\n+  unsigned int th = 0;\n   int min_profitable_iters;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n@@ -6506,28 +6598,24 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n \n   loop_num  = loop->num; \n \n-  /* Analyze cost to set threshhold for vectorized loop.  */\n-  min_profitable_iters = LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo);\n-  min_scalar_loop_bound = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n-\t\t\t    * LOOP_VINFO_VECT_FACTOR (loop_vinfo)) - 1);\n-\n-  /* Use the cost model only if it is more conservative than user specified\n-     threshold.  */\n+  /* If cost model check not done during versioning and \n+     peeling for alignment.  */\n+  if (!VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n+      && !VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo))\n+      && !LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+    {\n+      check_profitability = true;\n \n-  th = (unsigned) min_scalar_loop_bound;\n-  if (min_profitable_iters\n-      && (!min_scalar_loop_bound\n-          || min_profitable_iters > min_scalar_loop_bound))\n-    th = (unsigned) min_profitable_iters;\n+      /* Get profitability threshold for vectorized loop.  */\n+      min_profitable_iters = LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo);\n \n-  if (((LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) < 0)\n-      || !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n-      && vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"vectorization may not be profitable.\");\n+      th = conservative_cost_threshold (loop_vinfo, \n+\t\t\t\t\tmin_profitable_iters);\n+    }\n \n   new_loop = slpeel_tree_peel_loop_to_edge (loop, single_exit (loop),\n                                             ratio_mult_vf_name, ni_name, false,\n-                                            th);\n+                                            th, check_profitability);\n   gcc_assert (new_loop);\n   gcc_assert (loop_num == loop->num);\n #ifdef ENABLE_CHECKING\n@@ -6745,6 +6833,9 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n   tree niters_of_prolog_loop, ni_name;\n   tree n_iters;\n   struct loop *new_loop;\n+  bool check_profitability = false;\n+  unsigned int th = 0;\n+  int min_profitable_iters;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_do_peeling_for_alignment ===\");\n@@ -6754,10 +6845,26 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n   ni_name = vect_build_loop_niters (loop_vinfo);\n   niters_of_prolog_loop = vect_gen_niters_for_prolog_loop (loop_vinfo, ni_name);\n   \n+\n+  /* If cost model check not done during versioning.  */\n+  if (!VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n+      && !VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n+    {\n+      check_profitability = true;\n+\n+      /* Get profitability threshold for vectorized loop.  */\n+      min_profitable_iters = LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo);\n+\n+      th = conservative_cost_threshold (loop_vinfo, \n+\t\t\t\t\tmin_profitable_iters);\n+    }\n+\n   /* Peel the prolog loop and iterate it niters_of_prolog_loop.  */\n-  new_loop = \n-\tslpeel_tree_peel_loop_to_edge (loop, loop_preheader_edge (loop), \n-\t\t\t\t       niters_of_prolog_loop, ni_name, true, 0); \n+  new_loop =\n+    slpeel_tree_peel_loop_to_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t   niters_of_prolog_loop, ni_name, true,\n+\t\t\t\t   th, check_profitability);\n+\n   gcc_assert (new_loop);\n #ifdef ENABLE_CHECKING\n   slpeel_verify_cfg_after_peeling (new_loop, loop);\n@@ -6785,6 +6892,8 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n    checked at runtime.\n \n    Input:\n+   COND_EXPR  - input conditional expression.  New conditions will be chained\n+                with logical AND operation.\n    LOOP_VINFO - two fields of the loop information are used.\n                 LOOP_VINFO_PTR_MASK is the mask used to check the alignment.\n                 LOOP_VINFO_MAY_MISALIGN_STMTS contains the refs to be checked.\n@@ -6801,8 +6910,9 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n         test can be done as a&(n-1) == 0.  For example, for 16\n         byte vectors the test is a&0xf == 0.  */\n \n-static tree\n+static void\n vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n+                                   tree *cond_expr,\n                                    tree *cond_expr_stmt_list)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -6818,6 +6928,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n   tree or_tmp_name = NULL_TREE;\n   tree and_tmp, and_tmp_name, and_stmt;\n   tree ptrsize_zero;\n+  tree part_cond_expr;\n \n   /* Check that mask is one less than a power of 2, i.e., mask is\n      all zeros followed by all ones.  */\n@@ -6891,8 +7002,13 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n   /* Make and_tmp the left operand of the conditional test against zero.\n      if and_tmp has a nonzero bit then some address is unaligned.  */\n   ptrsize_zero = build_int_cst (int_ptrsize_type, 0);\n-  return build2 (EQ_EXPR, boolean_type_node,\n-                 and_tmp_name, ptrsize_zero);\n+  part_cond_expr = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\tand_tmp_name, ptrsize_zero);\n+  if (*cond_expr)\n+    *cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t      *cond_expr, part_cond_expr);\n+  else\n+    *cond_expr = part_cond_expr;\n }\n \n /* Function vect_vfa_segment_size.\n@@ -6933,7 +7049,7 @@ vect_vfa_segment_size (struct data_reference *dr, tree vect_factor)\n \n    Input:\n    COND_EXPR  - input conditional expression.  New conditions will be chained\n-                with logical and operation.\n+                with logical AND operation.\n    LOOP_VINFO - field LOOP_VINFO_MAY_ALIAS_STMTS contains the list of ddrs\n \t        to be checked.\n \n@@ -7055,7 +7171,11 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n    data references that may or may not be aligned.  An additional\n    sequence of runtime tests is generated for each pairs of DDRs whose\n    independence was not proven.  The vectorized version of loop is \n-   executed only if both alias and alignment tests are passed.  */\n+   executed only if both alias and alignment tests are passed.  \n+  \n+   The test generated to check which version of loop is executed\n+   is modified to also check for profitability as indicated by the \n+   cost model initially.  */\n \n static void\n vect_loop_versioning (loop_vec_info loop_vinfo)\n@@ -7072,17 +7192,30 @@ vect_loop_versioning (loop_vec_info loop_vinfo)\n   tree orig_phi, new_phi, arg;\n   unsigned prob = 4 * REG_BR_PROB_BASE / 5;\n   tree gimplify_stmt_list;\n+  tree scalar_loop_iters = LOOP_VINFO_NITERS (loop_vinfo);\n+  int min_profitable_iters = 0;\n+  unsigned int th;\n \n-  if (!VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n-      && !VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n-    return;\n+  /* Get profitability threshold for vectorized loop.  */\n+  min_profitable_iters = LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo);\n+\n+  th = conservative_cost_threshold (loop_vinfo,\n+\t\t\t\t    min_profitable_iters);\n+\n+  cond_expr =\n+    build2 (GT_EXPR, boolean_type_node, scalar_loop_iters, \n+\t    build_int_cst (TREE_TYPE (scalar_loop_iters), th));\n+\n+  cond_expr = force_gimple_operand (cond_expr, &cond_expr_stmt_list,\n+\t\t\t\t    false, NULL_TREE);\n \n   if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo)))\n-    cond_expr =\n-      vect_create_cond_for_align_checks (loop_vinfo, &cond_expr_stmt_list);\n+      vect_create_cond_for_align_checks (loop_vinfo, &cond_expr,\n+\t\t\t\t\t &cond_expr_stmt_list);\n \n   if (VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n-    vect_create_cond_for_alias_checks (loop_vinfo, &cond_expr, &cond_expr_stmt_list);\n+    vect_create_cond_for_alias_checks (loop_vinfo, &cond_expr, \n+\t\t\t\t       &cond_expr_stmt_list);\n \n   cond_expr =\n     fold_build2 (NE_EXPR, boolean_type_node, cond_expr, integer_zero_node);\n@@ -7260,7 +7393,10 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vec_transform_loop ===\");\n-  vect_loop_versioning (loop_vinfo);\n+\n+  if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n+      || VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n+    vect_loop_versioning (loop_vinfo);\n \n   /* CHECKME: we wouldn't need this if we called update_ssa once\n      for all loops.  */"}, {"sha": "fcc74168c461e53f95718b7271b3655847ee59b7", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 206, "deletions": 20, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749cc4b1b349c9217caca37d234e7786d04ddfbb/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749cc4b1b349c9217caca37d234e7786d04ddfbb/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=749cc4b1b349c9217caca37d234e7786d04ddfbb", "patch": "@@ -918,20 +918,29 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n \n static edge\n slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb,\n-\t\t        basic_block dom_bb)\n+\t\t       basic_block dom_bb)\n {\n   block_stmt_iterator bsi;\n   edge new_e, enter_e;\n   tree cond_stmt;\n+  tree gimplify_stmt_list;\n \n   enter_e = EDGE_SUCC (guard_bb, 0);\n   enter_e->flags &= ~EDGE_FALLTHRU;\n   enter_e->flags |= EDGE_FALSE_VALUE;\n   bsi = bsi_last (guard_bb);\n \n+  cond =\n+    force_gimple_operand (cond, &gimplify_stmt_list, true,\n+\t\t\t  NULL_TREE);\n   cond_stmt = build3 (COND_EXPR, void_type_node, cond,\n \t\t      NULL_TREE, NULL_TREE);\n+  if (gimplify_stmt_list)\n+    bsi_insert_after (&bsi, gimplify_stmt_list, BSI_NEW_STMT);\n+\n+  bsi = bsi_last (guard_bb);\n   bsi_insert_after (&bsi, cond_stmt, BSI_NEW_STMT);\n+\n   /* Add new edge to connect guard block to the merge/loop-exit block.  */\n   new_e = make_edge (guard_bb, exit_bb, EDGE_TRUE_VALUE);\n   set_immediate_dominator (CDI_DOMINATORS, exit_bb, dom_bb);\n@@ -1007,12 +1016,89 @@ slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n }\n #endif\n \n+/* If the run time cost model check determines that vectorization is\n+   not profitable and hence scalar loop should be generated then set\n+   FIRST_NITERS to prologue peeled iterations. This will allow all the\n+   iterations to be executed in the prologue peeled scalar loop.  */\n+\n+void\n+set_prologue_iterations (basic_block bb_before_first_loop,\n+\t\t\t tree first_niters,\n+\t\t\t struct loop *loop,\n+\t\t\t unsigned int th)\n+{\n+  edge e;\n+  basic_block cond_bb, then_bb;\n+  tree var, prologue_after_cost_adjust_name, stmt;\n+  block_stmt_iterator bsi;\n+  tree newphi;\n+  edge e_true, e_false, e_fallthru;\n+  tree cond_stmt;\n+  tree gimplify_stmt_list;\n+  tree cost_pre_condition = NULL_TREE;\n+  tree scalar_loop_iters = \n+    LOOP_VINFO_NITERS_UNCHANGED (loop_vec_info_for_loop (loop));\n+\n+  e = single_pred_edge (bb_before_first_loop);\n+  cond_bb = split_edge(e);\n+\n+  e = single_pred_edge (bb_before_first_loop);\n+  then_bb = split_edge(e);\n+  set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);\n+\n+  e_false = make_single_succ_edge (cond_bb, bb_before_first_loop,\n+\t\t\t\t   EDGE_FALSE_VALUE);\n+  set_immediate_dominator (CDI_DOMINATORS, bb_before_first_loop, cond_bb);\n+\n+  e_true = EDGE_PRED (then_bb, 0);\n+  e_true->flags &= ~EDGE_FALLTHRU;\n+  e_true->flags |= EDGE_TRUE_VALUE;\n+\n+  e_fallthru = EDGE_SUCC (then_bb, 0);\n+\n+  cost_pre_condition =\n+    build2 (LE_EXPR, boolean_type_node, scalar_loop_iters, \n+\t    build_int_cst (TREE_TYPE (scalar_loop_iters), th));\n+  cost_pre_condition =\n+    force_gimple_operand (cost_pre_condition, &gimplify_stmt_list,\n+\t\t\t  true, NULL_TREE);\n+  cond_stmt = build3 (COND_EXPR, void_type_node, cost_pre_condition,\n+\t\t      NULL_TREE, NULL_TREE);\n+\n+  bsi = bsi_last (cond_bb);\n+  if (gimplify_stmt_list)\n+    bsi_insert_after (&bsi, gimplify_stmt_list, BSI_NEW_STMT);\n+\n+  bsi = bsi_last (cond_bb);\n+  bsi_insert_after (&bsi, cond_stmt, BSI_NEW_STMT);\n+\t\t\t\t\t  \n+  var = create_tmp_var (TREE_TYPE (scalar_loop_iters),\n+\t\t\t\"prologue_after_cost_adjust\");\n+  add_referenced_var (var);\n+  prologue_after_cost_adjust_name = \n+    force_gimple_operand (scalar_loop_iters, &stmt, false, var);\n+\n+  bsi = bsi_last (then_bb);\n+  if (stmt)\n+    bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n+\n+  newphi = create_phi_node (var, bb_before_first_loop);\n+  add_phi_arg (newphi, prologue_after_cost_adjust_name, e_fallthru);\n+  add_phi_arg (newphi, first_niters, e_false);\n+\n+  first_niters = PHI_RESULT (newphi);\n+}\n+\n+\n /* Function slpeel_tree_peel_loop_to_edge.\n \n    Peel the first (last) iterations of LOOP into a new prolog (epilog) loop\n    that is placed on the entry (exit) edge E of LOOP. After this transformation\n    we have two loops one after the other - first-loop iterates FIRST_NITERS\n    times, and second-loop iterates the remainder NITERS - FIRST_NITERS times.\n+   If the cost model indicates that it is profitable to emit a scalar \n+   loop instead of the vector one, then the prolog (epilog) loop will iterate\n+   for the entire unchanged scalar iterations of the loop.\n \n    Input:\n    - LOOP: the loop to be peeled.\n@@ -1027,6 +1113,13 @@ slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n         for updating the loop bound of the first-loop to FIRST_NITERS.  If it\n         is false, the caller of this function may want to take care of this\n         (this can be useful if we don't want new stmts added to first-loop).\n+   - TH: cost model profitability threshold of iterations for vectorization.\n+   - CHECK_PROFITABILITY: specify whether cost model check has not occured\n+                          during versioning and hence needs to occur during\n+\t\t\t  prologue generation or whether cost model check \n+\t\t\t  has not occured during prologue generation and hence\n+\t\t\t  needs to occur during epilogue generation.\n+\t    \n \n    Output:\n    The function returns a pointer to the new loop-copy, or NULL if it failed\n@@ -1048,18 +1141,21 @@ struct loop*\n slpeel_tree_peel_loop_to_edge (struct loop *loop, \n \t\t\t       edge e, tree first_niters, \n \t\t\t       tree niters, bool update_first_loop_count,\n-\t\t\t       unsigned int th)\n+\t\t\t       unsigned int th, bool check_profitability)\n {\n   struct loop *new_loop = NULL, *first_loop, *second_loop;\n   edge skip_e;\n-  tree pre_condition;\n+  tree pre_condition = NULL_TREE;\n   bitmap definitions;\n   basic_block bb_before_second_loop, bb_after_second_loop;\n   basic_block bb_before_first_loop;\n   basic_block bb_between_loops;\n   basic_block new_exit_bb;\n   edge exit_e = single_exit (loop);\n   LOC loop_loc;\n+  tree cost_pre_condition = NULL_TREE;\n+  tree scalar_loop_iters = \n+    LOOP_VINFO_NITERS_UNCHANGED (loop_vec_info_for_loop (loop));\n   \n   if (!slpeel_can_duplicate_loop_p (loop, e))\n     return NULL;\n@@ -1116,32 +1212,121 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   rename_variables_in_loop (new_loop);\n \n \n-  /* 2. Add the guard that controls whether the first loop is executed.\n-        Resulting CFG would be:\n+  /* 2.  Add the guard code in one of the following ways:\n \n-        bb_before_first_loop:\n-        if (FIRST_NITERS == 0) GOTO bb_before_second_loop\n-                               GOTO first-loop\n+     2.a Add the guard that controls whether the first loop is executed.\n+         This occurs when this function is invoked for prologue or epilogiue\n+\t generation and when the cost model check can be done at compile time.\n \n-        first_loop:\n-        do {\n-        } while ...\n+         Resulting CFG would be:\n \n-        bb_before_second_loop:\n+         bb_before_first_loop:\n+         if (FIRST_NITERS == 0) GOTO bb_before_second_loop\n+                                GOTO first-loop\n \n-        second_loop:\n-        do {\n-        } while ...\n+         first_loop:\n+         do {\n+         } while ...\n \n-        orig_exit_bb:\n-   */\n+         bb_before_second_loop:\n+\n+         second_loop:\n+         do {\n+         } while ...\n+\n+         orig_exit_bb:\n+\n+     2.b Add the cost model check that allows the prologue\n+         to iterate for the entire unchanged scalar\n+         iterations of the loop in the event that the cost\n+         model indicates that the scalar loop is more\n+         profitable than the vector one. This occurs when\n+\t this function is invoked for prologue generation\n+\t and the cost model check needs to be done at run\n+\t time.\n+\n+         Resulting CFG after prologue peeling would be:\n+\n+         if (scalar_loop_iterations <= th)\n+           FIRST_NITERS = scalar_loop_iterations\n+\n+         bb_before_first_loop:\n+         if (FIRST_NITERS == 0) GOTO bb_before_second_loop\n+                                GOTO first-loop\n+\n+         first_loop:\n+         do {\n+         } while ...\n+\n+         bb_before_second_loop:\n+\n+         second_loop:\n+         do {\n+         } while ...\n+\n+         orig_exit_bb:\n+\n+     2.c Add the cost model check that allows the epilogue\n+         to iterate for the entire unchanged scalar\n+         iterations of the loop in the event that the cost\n+         model indicates that the scalar loop is more\n+         profitable than the vector one. This occurs when\n+\t this function is invoked for epilogue generation\n+\t and the cost model check needs to be done at run\n+\t time.\n+\n+         Resulting CFG after prologue peeling would be:\n+\n+         bb_before_first_loop:\n+         if ((scalar_loop_iterations <= th)\n+             ||\n+             FIRST_NITERS == 0) GOTO bb_before_second_loop\n+                                GOTO first-loop\n+\n+         first_loop:\n+         do {\n+         } while ...\n+\n+         bb_before_second_loop:\n+\n+         second_loop:\n+         do {\n+         } while ...\n+\n+         orig_exit_bb:\n+  */\n \n   bb_before_first_loop = split_edge (loop_preheader_edge (first_loop));\n   bb_before_second_loop = split_edge (single_exit (first_loop));\n \n-  pre_condition =\n-    fold_build2 (LE_EXPR, boolean_type_node, first_niters, \n-\tbuild_int_cst (TREE_TYPE (first_niters), th));\n+  /* Epilogue peeling.  */\n+  if (!update_first_loop_count)\n+    {\n+      pre_condition =\n+\tfold_build2 (LE_EXPR, boolean_type_node, first_niters, \n+\t\t     build_int_cst (TREE_TYPE (first_niters), 0));\n+      if (check_profitability)\n+\t{\n+\t    cost_pre_condition = \n+\t    build2 (LE_EXPR, boolean_type_node, scalar_loop_iters, \n+\t\t    build_int_cst (TREE_TYPE (scalar_loop_iters), th));\n+  \n+\t  pre_condition = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t\t       cost_pre_condition, pre_condition);\n+\t}\n+    }\n+\n+  /* Prologue peeling.  */  \n+  else\n+    {\n+      if (check_profitability)\n+\tset_prologue_iterations (bb_before_first_loop, first_niters,\n+\t\t\t\t loop, th);\n+\n+      pre_condition =\n+\tfold_build2 (LE_EXPR, boolean_type_node, first_niters, \n+\t\t     build_int_cst (TREE_TYPE (first_niters), 0));\n+    }\n \n   skip_e = slpeel_add_loop_guard (bb_before_first_loop, pre_condition,\n                                   bb_before_second_loop, bb_before_first_loop);\n@@ -1468,6 +1653,7 @@ new_loop_vec_info (struct loop *loop)\n \n   LOOP_VINFO_BBS (res) = bbs;\n   LOOP_VINFO_NITERS (res) = NULL;\n+  LOOP_VINFO_NITERS_UNCHANGED (res) = NULL;\n   LOOP_VINFO_COST_MODEL_MIN_ITERS (res) = 0;\n   LOOP_VINFO_VECTORIZABLE_P (res) = 0;\n   LOOP_PEELING_FOR_ALIGNMENT (res) = 0;"}, {"sha": "d7d447652e949f1dd25d3a3f01c8665da1e40a4a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749cc4b1b349c9217caca37d234e7786d04ddfbb/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749cc4b1b349c9217caca37d234e7786d04ddfbb/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=749cc4b1b349c9217caca37d234e7786d04ddfbb", "patch": "@@ -228,6 +228,9 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_LOOP(L)            (L)->loop\n #define LOOP_VINFO_BBS(L)             (L)->bbs\n #define LOOP_VINFO_NITERS(L)          (L)->num_iters\n+/* Since LOOP_VINFO_NITERS can change after prologue peeling\n+   retain total unchanged scalar loop iterations for cost model.  */\n+#define LOOP_VINFO_NITERS_UNCHANGED(L)          (L)->num_iters\n #define LOOP_VINFO_COST_MODEL_MIN_ITERS(L)\t(L)->min_profitable_iters\n #define LOOP_VINFO_VECTORIZABLE_P(L)  (L)->vectorizable\n #define LOOP_VINFO_VECT_FACTOR(L)     (L)->vectorization_factor\n@@ -630,7 +633,9 @@ extern bitmap vect_memsyms_to_rename;\n    divide by the vectorization factor, and to peel the first few iterations\n    to force the alignment of data references in the loop.  */\n extern struct loop *slpeel_tree_peel_loop_to_edge \n-  (struct loop *, edge, tree, tree, bool, unsigned int);\n+  (struct loop *, edge, tree, tree, bool, unsigned int, bool);\n+extern void set_prologue_iterations (basic_block, tree,\n+\t\t\t\t     struct loop *, unsigned int);\n extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n #ifdef ENABLE_CHECKING"}]}