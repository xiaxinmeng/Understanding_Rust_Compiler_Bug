{"sha": "f13eb63a4210052ce431237de467696fe205879b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEzZWI2M2E0MjEwMDUyY2U0MzEyMzdkZTQ2NzY5NmZlMjA1ODc5Yg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.columbia.edu", "date": "1999-01-25T11:28:11Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1999-01-25T11:28:11Z"}, "message": "cppexp.c: (struct arglist): Removed.\n\n1999-01-25 14:26 -0500  Zack Weinberg  <zack@rabi.columbia.edu>\n\t* cppexp.c:\n\t    (struct arglist): Removed.\n\t    (parse_number): Use HOST_WIDE_INT for the accumulator.\n\t    Allow two `l' suffixes unless C89.  Clean up.  Make\n\t    static.\n\t    (parse_charconst): New function broken out of cpp_lex.\n\t    Code cleaned up drastically.  Don't use a token_buffer.\n\t    (token_buffer): Removed.\n\t    (cpp_lex): Don't call parse_number on a constant string.\n\t    Use parse_charconst.\n\t    (cpp_parse_expr): Properly handle an ERROR op returned by\n\t    cpp_lex.\n\nFrom-SVN: r24859", "tree": {"sha": "f7399c6915f8c6d06232933a17340674f9617978", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7399c6915f8c6d06232933a17340674f9617978"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f13eb63a4210052ce431237de467696fe205879b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f13eb63a4210052ce431237de467696fe205879b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f13eb63a4210052ce431237de467696fe205879b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f13eb63a4210052ce431237de467696fe205879b/comments", "author": null, "committer": null, "parents": [{"sha": "20dc7361944d6be4ed902115251a55cf1e7d0ba4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20dc7361944d6be4ed902115251a55cf1e7d0ba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20dc7361944d6be4ed902115251a55cf1e7d0ba4"}], "stats": {"total": 441, "additions": 229, "deletions": 212}, "files": [{"sha": "7228df49503976e82944cf14031377fa9c20f995", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13eb63a4210052ce431237de467696fe205879b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13eb63a4210052ce431237de467696fe205879b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f13eb63a4210052ce431237de467696fe205879b", "patch": "@@ -1,3 +1,18 @@\n+1999-01-25 14:26 -0500  Zack Weinberg  <zack@rabi.columbia.edu>\n+\n+\t* cppexp.c: \n+\t    (struct arglist): Removed.\n+\t    (parse_number): Use HOST_WIDE_INT for the accumulator.\n+\t    Allow two `l' suffixes unless C89.  Clean up.  Make\n+\t    static.\n+\t    (parse_charconst): New function broken out of cpp_lex.\n+\t    Code cleaned up drastically.  Don't use a token_buffer.\n+\t    (token_buffer): Removed.\n+\t    (cpp_lex): Don't call parse_number on a constant string.\n+\t    Use parse_charconst.\n+\t    (cpp_parse_expr): Properly handle an ERROR op returned by\n+\t    cpp_lex. \n+\n 1999-01-25 14:10 -0500  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n \n \t* cpplib.c: Don't include signal.h, sys/times.h, or"}, {"sha": "0e5095dd285b802fa509b4782b010fad0a2c13cb", "filename": "gcc/cppexp.c", "status": "modified", "additions": 214, "deletions": 212, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13eb63a4210052ce431237de467696fe205879b/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13eb63a4210052ce431237de467696fe205879b/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=f13eb63a4210052ce431237de467696fe205879b", "patch": "@@ -32,14 +32,6 @@ Written by Per Bothner 1994.  */\n #include <locale.h>\n #endif\n \n-/* This is used for communicating lists of keywords with cccp.c.  */\n-struct arglist {\n-  struct arglist *next;\n-  U_CHAR *name;\n-  int length;\n-  int argno;\n-};\n-\n #ifndef CHAR_TYPE_SIZE\n #define CHAR_TYPE_SIZE BITS_PER_UNIT\n #endif\n@@ -124,117 +116,243 @@ struct operation {\n     char unsignedp;    /* true if value should be treated as unsigned */\n     HOST_WIDE_INT value;        /* The value logically \"right\" of op.  */\n };\n-\f\n-/* Take care of parsing a number (anything that starts with a digit).\n-   LEN is the number of characters in it.  */\n \n-/* maybe needs to actually deal with floating point numbers */\n+/* Parse and convert an integer for #if.  Accepts decimal, hex, or octal\n+   with or without size suffixes.  */\n \n-struct operation\n-parse_number (pfile, start, olen)\n+static struct operation\n+parse_number (pfile, start, end)\n      cpp_reader *pfile;\n-     char *start;\n-     int olen;\n+     U_CHAR *start;\n+     U_CHAR *end;\n {\n   struct operation op;\n-  register char *p = start;\n-  register int c;\n-  register unsigned long n = 0, nd, ULONG_MAX_over_base;\n-  register int base = 10;\n-  register int len = olen;\n-  register int overflow = 0;\n-  register int digit, largest_digit = 0;\n+  U_CHAR *p = start;\n+  int c;\n+  unsigned HOST_WIDE_INT n = 0, nd, MAX_over_base;\n+  int base = 10;\n+  int overflow = 0;\n+  int digit, largest_digit = 0;\n   int spec_long = 0;\n \n   op.unsignedp = 0;\n \n-  for (c = 0; c < len; c++)\n-    if (p[c] == '.') {\n-      /* It's a float since it contains a point.  */\n-      cpp_error (pfile,\n-\t\t \"floating point numbers not allowed in #if expressions\");\n-      op.op = ERROR;\n-      return op;\n+  if (p[0] == '0')\n+    {\n+      if (end - start >= 3 && (p[1] == 'x' || p[1] == 'X'))\n+\t{\n+\t  p += 2;\n+\t  base = 16;\n+\t}\n+      else\n+\t{\n+\t  p += 1;\n+\t  base = 8;\n+\t}\n     }\n \n-  if (len >= 3 && (!strncmp (p, \"0x\", 2) || !strncmp (p, \"0X\", 2))) {\n-    p += 2;\n-    base = 16;\n-    len -= 2;\n-  }\n-  else if (*p == '0')\n-    base = 8;\n-\n   /* Some buggy compilers (e.g. MPW C) seem to need both casts.  */\n-  ULONG_MAX_over_base = ((unsigned long) -1) / ((unsigned long) base);\n-\n-  for (; len > 0; len--) {\n-    c = *p++;\n-\n-    if (c >= '0' && c <= '9')\n-      digit = c - '0';\n-    else if (base == 16 && c >= 'a' && c <= 'f')\n-      digit = c - 'a' + 10;\n-    else if (base == 16 && c >= 'A' && c <= 'F')\n-      digit = c - 'A' + 10;\n-    else {\n-      /* `l' means long, and `u' means unsigned.  */\n-      while (1) {\n-\tif (c == 'l' || c == 'L')\n-\t  {\n-\t    if (spec_long)\n-\t      cpp_error (pfile, \"two `l's in integer constant\");\n-\t    spec_long = 1;\n-\t  }\n-\telse if (c == 'u' || c == 'U')\n-\t  {\n-\t    if (op.unsignedp)\n-\t      cpp_error (pfile, \"two `u's in integer constant\");\n-\t    op.unsignedp = 1;\n-\t  }\n-\telse\n-\t  break;\n+  MAX_over_base = (((unsigned HOST_WIDE_INT) -1)\n+\t\t   / ((unsigned HOST_WIDE_INT) base));\n \n-\tif (--len == 0)\n+  while (p < end)\n+    {\n+      c = *p++;\n+\n+      if (c >= '0' && c <= '9')\n+\tdigit = c - '0';\n+      else if (base == 16 && c >= 'a' && c <= 'f') /* FIXME: assumes ASCII */\n+\tdigit = c - 'a' + 10;\n+      else if (base == 16 && c >= 'A' && c <= 'F')\n+\tdigit = c - 'A' + 10;\n+      else if (c == '.')\n+\t{\n+\t  /* It's a float since it contains a point.  */\n+\t  cpp_error (pfile,\n+\t\t\"floating point numbers are not allowed in #if expressions\");\n+\t  goto error;\n+\t}\n+      else\n+\t{\n+\t  /* `l' means long, and `u' means unsigned.  */\n+\t  for (;;)\n+\t    {\n+\t      if (c == 'l' || c == 'L')\n+\t\t  spec_long++;\n+\t      else if (c == 'u' || c == 'U')\n+\t\t  op.unsignedp++;\n+\t      else\n+\t\t{\n+\t\t  /* Decrement p here so that the error for an invalid number\n+\t\t     will be generated below in the case where this is the\n+\t\t     last character in the buffer.  */\n+\t\t  p--;\n+\t\t  break;\n+\t\t}\n+\t      if (p == end)\n+\t\tbreak;\n+\t      c = *p++;\n+\t    }\n+\t  /* Don't look for any more digits after the suffixes.  */\n \t  break;\n-\tc = *p++;\n-      }\n-      /* Don't look for any more digits after the suffixes.  */\n-      break;\n+\t}\n+      \n+      if (largest_digit < digit)\n+\tlargest_digit = digit;\n+      nd = n * base + digit;\n+      overflow |= MAX_over_base < n || nd < n;\n+      n = nd;\n     }\n-    if (largest_digit < digit)\n-      largest_digit = digit;\n-    nd = n * base + digit;\n-    overflow |= ULONG_MAX_over_base < n || nd < n;\n-    n = nd;\n-  }\n \n-  if (len != 0)\n+  if (p != end)\n     {\n-      cpp_error (pfile, \"Invalid number in #if expression\");\n-      op.op = ERROR;\n-      return op;\n+      cpp_error (pfile, \"invalid number in #if expression\");\n+      goto error;\n     }\n-\n+  else if (spec_long > (CPP_OPTIONS (pfile)->c89 ? 1 : 2))\n+    {\n+      cpp_error (pfile, \"too many `l' suffixes in integer constant\");\n+      goto error;\n+    }\n+  else if (op.unsignedp > 1)\n+    {\n+      cpp_error (pfile, \"too many `u' suffixes in integer constant\");\n+      goto error;\n+    }\n+  \n   if (base <= largest_digit)\n     cpp_pedwarn (pfile, \"integer constant contains digits beyond the radix\");\n \n   if (overflow)\n     cpp_pedwarn (pfile, \"integer constant out of range\");\n \n   /* If too big to be signed, consider it unsigned.  */\n-  if ((long) n < 0 && ! op.unsignedp)\n+  else if ((HOST_WIDE_INT) n < 0 && ! op.unsignedp)\n     {\n       if (base == 10)\n-\tcpp_warning (pfile, \"integer constant is so large that it is unsigned\");\n+\tcpp_warning (pfile,\n+\t\t     \"integer constant is so large that it is unsigned\");\n       op.unsignedp = 1;\n     }\n \n   op.value = n;\n   op.op = INT;\n   return op;\n+\n+ error:\n+  op.op = ERROR;\n+  return op;\n }\n \n+/* Parse and convert a character constant for #if.  Understands backslash\n+   escapes (\\n, \\031) and multibyte characters (if so configured).  */\n+static struct operation\n+parse_charconst (pfile, start, end)\n+     cpp_reader *pfile;\n+     U_CHAR *start;\n+     U_CHAR *end;\n+{\n+  struct operation op;\n+  HOST_WIDE_INT result = 0;\n+  int num_chars = 0;\n+  int num_bits;\n+  unsigned int width = MAX_CHAR_TYPE_SIZE, mask = MAX_CHAR_TYPE_MASK;\n+  int max_chars;\n+  U_CHAR *ptr = start;\n+\n+  /* FIXME: Should use reentrant multibyte functions.  */\n+#ifdef MULTIBYTE_CHARS\n+  wchar_t c;\n+  (void) mbtowc (NULL_PTR, NULL_PTR, 0);\n+#else\n+  int c;\n+#endif\n+\n+  if (*ptr == 'L')\n+    {\n+      ++ptr;\n+      width = MAX_WCHAR_TYPE_SIZE, mask = MAX_WCHAR_TYPE_MASK;\n+    }\n+  max_chars = MAX_LONG_TYPE_SIZE / width;\n+\n+  ++ptr;  /* skip initial quote */\n+\n+  while (ptr < end)\n+    {\n+#ifndef MULTIBYTE_CHARS\n+      c = *ptr++;\n+#else\n+      ptr += mbtowc (&c, ptr, end - ptr);\n+#endif\n+      if (c == '\\'' || c == '\\0')\n+\tbreak;\n+      else if (c == '\\\\')\n+\t{\n+\t  /* Hopefully valid assumption: if mbtowc returns a backslash,\n+\t     we are in initial shift state.  No valid escape-sequence\n+\t     character can take us out of initial shift state or begin\n+\t     an unshifted multibyte char, so cpp_parse_escape doesn't\n+\t     need to know about multibyte chars.  */\n+\n+\t  c = cpp_parse_escape (pfile, (char **) &ptr, mask);\n+\t  if (width < HOST_BITS_PER_INT\n+\t      && (unsigned int) c >= (unsigned int)(1 << width))\n+\t    cpp_pedwarn (pfile, \"escape sequence out of range for character\");\n+\t}\n+\t  \n+      /* Merge character into result; ignore excess chars.  */\n+      if (++num_chars <= max_chars)\n+\t{\n+\t  if (width < HOST_BITS_PER_INT)\n+\t    result = (result << width) | (c & ((1 << width) - 1));\n+\t  else\n+\t    result = c;\n+\t}\n+    }\n+\n+  if (num_chars == 0)\n+    {\n+      cpp_error (pfile, \"empty character constant\");\n+      goto error;\n+    }\n+  else if (c != '\\'')\n+    {\n+      /* cpp_get_token has already emitted an error if !traditional. */\n+      if (! CPP_TRADITIONAL (pfile))\n+\tcpp_error (pfile, \"malformatted character constant\");\n+      goto error;\n+    }\n+  else if (num_chars > max_chars)\n+    {\n+      cpp_error (pfile, \"character constant too long\");\n+      goto error;\n+    }\n+  else if (num_chars != 1 && ! CPP_TRADITIONAL (pfile))\n+    cpp_warning (pfile, \"multi-character character constant\");\n+\n+  /* If char type is signed, sign-extend the constant.  */\n+  num_bits = num_chars * width;\n+      \n+  if (cpp_lookup (pfile, (U_CHAR *)\"__CHAR_UNSIGNED__\",\n+\t\t  sizeof (\"__CHAR_UNSIGNED__\")-1, -1)\n+      || ((result >> (num_bits - 1)) & 1) == 0)\n+    op.value = result & ((unsigned long) ~0\n+\t\t\t >> (HOST_BITS_PER_LONG - num_bits));\n+  else\n+    op.value = result | ~((unsigned long) ~0\n+\t\t\t  >> (HOST_BITS_PER_LONG - num_bits));\n+\n+  /* This is always a signed type.  */\n+  op.unsignedp = 0;\n+  op.op = CHAR;\n+  return op;\n+\n+ error:\n+  op.op = ERROR;\n+  return op;\n+}\n+\n+\n struct token {\n   char *operator;\n   int token;\n@@ -254,19 +372,15 @@ static struct token tokentab2[] = {\n   {NULL, ERROR}\n };\n \n-/* This is used to accumulate the value of a character literal.  It is static\n-   so that it only gets allocated once per compilation.  */\n-static char *token_buffer = NULL;\n-\n /* Read one token.  */\n \n struct operation\n cpp_lex (pfile, skip_evaluation)\n      cpp_reader *pfile;\n      int skip_evaluation;\n {\n-  register HOST_WIDE_INT c;\n-  register struct token *toktab;\n+  U_CHAR c;\n+  struct token *toktab;\n   enum cpp_token token;\n   struct operation op;\n   U_CHAR *tok_start, *tok_end;\n@@ -308,140 +422,26 @@ cpp_lex (pfile, skip_evaluation)\n \t}\n       cpp_pop_buffer (pfile);\n       goto retry;\n-    case CPP_HSPACE:   case CPP_COMMENT: \n+    case CPP_HSPACE:\n+    case CPP_COMMENT: \n       goto retry;\n     case CPP_NUMBER:\n-      return parse_number (pfile, tok_start, tok_end - tok_start);\n+      return parse_number (pfile, tok_start, tok_end);\n     case CPP_STRING:\n       cpp_error (pfile, \"string constants not allowed in #if expressions\");\n       op.op = ERROR;\n       return op;\n     case CPP_CHAR:\n-      /* This code for reading a character constant\n-\t handles multicharacter constants and wide characters.\n-\t It is mostly copied from c-lex.c.  */\n-      {\n-        register int result = 0;\n-\tregister int num_chars = 0;\n-\tunsigned width = MAX_CHAR_TYPE_SIZE;\n-\tint wide_flag = 0;\n-\tint max_chars;\n-\tU_CHAR *ptr = tok_start;\n-\n-\t/* We need to allocate this buffer dynamically since the size is not\n-\t   a constant expression on all platforms.  */\n-\tif (token_buffer == NULL)\n-\t  {\n-#ifdef MULTIBYTE_CHARS\n-\t    token_buffer = xmalloc (MAX_LONG_TYPE_SIZE/MAX_CHAR_TYPE_SIZE\n-\t\t\t\t    + MB_CUR_MAX);\n-#else\n-\t    token_buffer = xmalloc (MAX_LONG_TYPE_SIZE/MAX_CHAR_TYPE_SIZE + 1);\n-#endif\n-\t  }\n-\n-\tif (*ptr == 'L')\n-\t  {\n-\t    ptr++;\n-\t    wide_flag = 1;\n-\t    width = MAX_WCHAR_TYPE_SIZE;\n-#ifdef MULTIBYTE_CHARS\n-\t    max_chars = MB_CUR_MAX;\n-#else\n-\t    max_chars = 1;\n-#endif\n-\t  }\n-\telse\n-\t    max_chars = MAX_LONG_TYPE_SIZE / width;\n-\n-\t++ptr;\n-\twhile (ptr < tok_end && ((c = *ptr++) != '\\''))\n-\t  {\n-\t    if (c == '\\\\')\n-\t      {\n-\t\tc = cpp_parse_escape (pfile, (char **) &ptr,\n-\t\t\t\t      wide_flag ? MAX_WCHAR_TYPE_MASK\n-\t\t\t\t      \t\t: MAX_CHAR_TYPE_MASK);\n-\t\tif (width < HOST_BITS_PER_INT\n-\t\t  && (unsigned) c >= (unsigned)(1 << width))\n-\t\t    cpp_pedwarn (pfile,\n-\t\t\t\t \"escape sequence out of range for character\");\n-\t      }\n-\n-\t    num_chars++;\n-\n-\t    /* Merge character into result; ignore excess chars.  */\n-\t    if (num_chars < max_chars + 1)\n-\t      {\n-\t        if (width < HOST_BITS_PER_INT)\n-\t\t  result = (result << width) | (c & ((1 << width) - 1));\n-\t\telse\n-\t\t  result = c;\n-\t\ttoken_buffer[num_chars - 1] = c;\n-\t      }\n-\t  }\n-\n-\ttoken_buffer[num_chars] = 0;\n-\n-\tif (c != '\\'')\n-\t  cpp_error (pfile, \"malformatted character constant\");\n-\telse if (num_chars == 0)\n-\t  cpp_error (pfile, \"empty character constant\");\n-\telse if (num_chars > max_chars)\n-\t  {\n-\t    num_chars = max_chars;\n-\t    cpp_error (pfile, \"character constant too long\");\n-\t  }\n-\telse if (num_chars != 1 && ! CPP_TRADITIONAL (pfile))\n-\t  cpp_warning (pfile, \"multi-character character constant\");\n-\n-\t/* If char type is signed, sign-extend the constant.  */\n-\tif (! wide_flag)\n-\t  {\n-\t    int num_bits = num_chars * width;\n-\n-\t    if (cpp_lookup (pfile, (U_CHAR *)\"__CHAR_UNSIGNED__\",\n-\t\t\t    sizeof (\"__CHAR_UNSIGNED__\")-1, -1)\n-\t\t|| ((result >> (num_bits - 1)) & 1) == 0)\n-\t\top.value\n-\t\t    = result & ((unsigned long) ~0 >> (HOST_BITS_PER_LONG - num_bits));\n-\t    else\n-\t\top.value\n-\t\t    = result | ~((unsigned long) ~0 >> (HOST_BITS_PER_LONG - num_bits));\n-\t  }\n-\telse\n-\t  {\n-#ifdef MULTIBYTE_CHARS\n-\t    /* Set the initial shift state and convert the next sequence.  */\n-\t      result = 0;\n-\t      /* In all locales L'\\0' is zero and mbtowc will return zero,\n-\t\t so don't use it.  */\n-\t      if (num_chars > 1\n-\t\t  || (num_chars == 1 && token_buffer[0] != '\\0'))\n-\t        {\n-\t\t  wchar_t wc;\n-\t\t  (void) mbtowc (NULL_PTR, NULL_PTR, 0);\n-\t\t  if (mbtowc (& wc, token_buffer, num_chars) == num_chars)\n-\t\t    result = wc;\n-\t\t  else\n-\t\t    cpp_pedwarn (pfile,\"Ignoring invalid multibyte character\");\n-\t        }\n-#endif\n-\t      op.value = result;\n-\t    }\n-        }\n-\n-      /* This is always a signed type.  */\n-      op.unsignedp = 0;\n-      op.op = CHAR;\n-    \n-      return op;\n+      return parse_charconst (pfile, tok_start, tok_end);\n \n     case CPP_NAME:\n       if (CPP_WARN_UNDEF (pfile) && !skip_evaluation)\n \tcpp_warning (pfile, \"`%.*s' is not defined\",\n \t\t     (int) (tok_end - tok_start), tok_start);\n-      return parse_number (pfile, \"0\", 0);\n+      op.op = INT;\n+      op.unsignedp = 0;\n+      op.value = 0;\n+      return op;\n \n     case CPP_OTHER:\n       /* See if it is a special token of length 2.  */\n@@ -733,6 +733,8 @@ cpp_parse_expr (pfile)\n         case '?':\n \t  lprio = COND_PRIO + 1;  rprio = COND_PRIO;\n \t  goto maybe_reduce;\n+\tcase ERROR:\n+\t  goto syntax_error;\n \tbinop:\n \t  flags = LEFT_OPERAND_REQUIRED|RIGHT_OPERAND_REQUIRED;\n \t  rprio = lprio + 1;"}]}