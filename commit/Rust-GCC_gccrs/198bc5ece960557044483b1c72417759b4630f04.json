{"sha": "198bc5ece960557044483b1c72417759b4630f04", "node_id": "C_kwDOANBUbNoAKDE5OGJjNWVjZTk2MDU1NzA0NDQ4M2IxYzcyNDE3NzU5YjQ2MzBmMDQ", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-19T16:33:37Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-21T16:55:13Z"}, "message": "Move postfold_gcond_edges into fur_source.\n\nThe code registering outgoing edges from a cond is living in\nfold_using_range, which makes it difficult to be called from other\nplaces.  Also, it refuses to register relations on the outgoing\ndestinations that have more than one predecessor.  This latter issue is\na problem because we would like to register outgoing edges along a path\nin the path solver (regardless of single_pred_p).\n\ngcc/ChangeLog:\n\n\t* gimple-range-fold.cc (fold_using_range::range_of_range_op):\n\tRename postfold_gcond_edges to register_outgoing_edges and\n\tadapt.\n\t(fold_using_range::postfold_gcond_edges): Rename...\n\t(fur_source::register_outgoing_edges): ...to this.\n\t* gimple-range-fold.h (postfold_gcond_edges): Rename to\n\tregister_outgoing_edges and move to fur_source.", "tree": {"sha": "e42c52ba729ef9d4a9bbe718a5075b89de11e46e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e42c52ba729ef9d4a9bbe718a5075b89de11e46e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/198bc5ece960557044483b1c72417759b4630f04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/198bc5ece960557044483b1c72417759b4630f04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/198bc5ece960557044483b1c72417759b4630f04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/198bc5ece960557044483b1c72417759b4630f04/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64b80b8819f9ea74712625bceb0ec4388e25f67d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b80b8819f9ea74712625bceb0ec4388e25f67d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64b80b8819f9ea74712625bceb0ec4388e25f67d"}], "stats": {"total": 46, "additions": 23, "deletions": 23}, "files": [{"sha": "d7fa0f2c86e0e05ebb21100542eca5ce5e624ca2", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/198bc5ece960557044483b1c72417759b4630f04/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/198bc5ece960557044483b1c72417759b4630f04/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=198bc5ece960557044483b1c72417759b4630f04", "patch": "@@ -651,7 +651,17 @@ fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n \t\t}\n \t    }\n \t  else if (is_a<gcond *> (s))\n-\t    postfold_gcond_edges (as_a<gcond *> (s), r, src);\n+\t    {\n+\t      basic_block bb = gimple_bb (s);\n+\t      edge e0 = EDGE_SUCC (bb, 0);\n+\t      edge e1 = EDGE_SUCC (bb, 1);\n+\n+\t      if (!single_pred_p (e0->dest))\n+\t\te0 = NULL;\n+\t      if (!single_pred_p (e1->dest))\n+\t\te1 = NULL;\n+\t      src.register_outgoing_edges (as_a<gcond *> (s), r, e0, e1);\n+\t    }\n \t}\n       else\n \tr.set_varying (type);\n@@ -1386,8 +1396,7 @@ fold_using_range::relation_fold_and_or (irange& lhs_range, gimple *s,\n // Register any outgoing edge relations from a conditional branch.\n \n void\n-fold_using_range::postfold_gcond_edges (gcond *s, irange& lhs_range,\n-\t\t\t\t\tfur_source &src)\n+fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge e1)\n {\n   int_range_max r;\n   int_range<2> e0_range, e1_range;\n@@ -1399,10 +1408,7 @@ fold_using_range::postfold_gcond_edges (gcond *s, irange& lhs_range,\n   if (!bb)\n     return;\n \n-  edge e0 = EDGE_SUCC (bb, 0);\n-  if (!single_pred_p (e0->dest))\n-    e0 = NULL;\n-  else\n+  if (e0)\n     {\n       // If this edge is never taken, ignore it.\n       gcond_edge_range (e0_range, e0);\n@@ -1412,10 +1418,7 @@ fold_using_range::postfold_gcond_edges (gcond *s, irange& lhs_range,\n     }\n \n \n-  edge e1 = EDGE_SUCC (bb, 1);\n-  if (!single_pred_p (e1->dest))\n-    e1 = NULL;\n-  else\n+  if (e1)\n     {\n       // If this edge is never taken, ignore it.\n       gcond_edge_range (e1_range, e1);\n@@ -1424,7 +1427,6 @@ fold_using_range::postfold_gcond_edges (gcond *s, irange& lhs_range,\n \te1 = NULL;\n     }\n \n-  // At least one edge needs to be single pred.\n   if (!e0 && !e1)\n     return;\n \n@@ -1440,27 +1442,25 @@ fold_using_range::postfold_gcond_edges (gcond *s, irange& lhs_range,\n \t{\n \t  relation_kind relation = handler->op1_op2_relation (e0_range);\n \t  if (relation != VREL_NONE)\n-\t    src.register_relation (e0, relation, ssa1, ssa2);\n+\t    register_relation (e0, relation, ssa1, ssa2);\n \t}\n       if (e1)\n \t{\n \t  relation_kind relation = handler->op1_op2_relation (e1_range);\n \t  if (relation != VREL_NONE)\n-\t    src.register_relation (e1, relation, ssa1, ssa2);\n+\t    register_relation (e1, relation, ssa1, ssa2);\n \t}\n     }\n \n   // Outgoing relations of GORI exports require a gori engine.\n-  if (!src.gori ())\n+  if (!gori ())\n     return;\n \n-  range_query *q = src.query ();\n   // Now look for other relations in the exports.  This will find stmts\n   // leading to the condition such as:\n   // c_2 = a_4 < b_7\n   // if (c_2)\n-\n-  FOR_EACH_GORI_EXPORT_NAME (*(src.gori ()), bb, name)\n+  FOR_EACH_GORI_EXPORT_NAME (*(gori ()), bb, name)\n     {\n       if (TREE_CODE (TREE_TYPE (name)) != BOOLEAN_TYPE)\n \tcontinue;\n@@ -1472,19 +1472,19 @@ fold_using_range::postfold_gcond_edges (gcond *s, irange& lhs_range,\n       tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (stmt));\n       if (ssa1 && ssa2)\n \t{\n-\t  if (e0 && src.gori ()->outgoing_edge_range_p (r, e0, name, *q)\n+\t  if (e0 && gori ()->outgoing_edge_range_p (r, e0, name, *m_query)\n \t      && r.singleton_p ())\n \t    {\n \t      relation_kind relation = handler->op1_op2_relation (r);\n \t      if (relation != VREL_NONE)\n-\t\tsrc.register_relation (e0, relation, ssa1, ssa2);\n+\t\tregister_relation (e0, relation, ssa1, ssa2);\n \t    }\n-\t  if (e1 && src.gori ()->outgoing_edge_range_p (r, e1, name, *q)\n+\t  if (e1 && gori ()->outgoing_edge_range_p (r, e1, name, *m_query)\n \t      && r.singleton_p ())\n \t    {\n \t      relation_kind relation = handler->op1_op2_relation (r);\n \t      if (relation != VREL_NONE)\n-\t\tsrc.register_relation (e1, relation, ssa1, ssa2);\n+\t\tregister_relation (e1, relation, ssa1, ssa2);\n \t    }\n \t}\n     }"}, {"sha": "d62d29b713387419340d9bcba536e541bd6c4284", "filename": "gcc/gimple-range-fold.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/198bc5ece960557044483b1c72417759b4630f04/gcc%2Fgimple-range-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/198bc5ece960557044483b1c72417759b4630f04/gcc%2Fgimple-range-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.h?ref=198bc5ece960557044483b1c72417759b4630f04", "patch": "@@ -129,6 +129,7 @@ class fur_source\n \t\t\t\t  tree op2);\n   virtual void register_relation (edge e, relation_kind k, tree op1,\n \t\t\t\t  tree op2);\n+  void register_outgoing_edges (gcond *, irange &lhs_range, edge e0, edge e1);\n protected:\n   range_query *m_query;\n   gori_compute *m_gori;\n@@ -188,6 +189,5 @@ class fold_using_range\n   void range_of_ssa_name_with_loop_info (irange &, tree, class loop *, gphi *,\n \t\t\t\t\t fur_source &src);\n   void relation_fold_and_or (irange& lhs_range, gimple *s, fur_source &src);\n-  void postfold_gcond_edges (gcond *s, irange &lhs_range, fur_source &src);\n };\n #endif // GCC_GIMPLE_RANGE_FOLD_H"}]}