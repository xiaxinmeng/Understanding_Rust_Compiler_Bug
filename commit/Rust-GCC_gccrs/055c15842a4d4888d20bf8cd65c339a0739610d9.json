{"sha": "055c15842a4d4888d20bf8cd65c339a0739610d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU1YzE1ODQyYTRkNDg4OGQyMGJmOGNkNjVjMzM5YTA3Mzk2MTBkOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-11T18:06:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-11T18:06:51Z"}, "message": "({add,sub}di{_mem,3}): Patterns merged.\n\nFrom-SVN: r9926", "tree": {"sha": "bfe56a7546ff89821e5d5830f06ddb263bac5842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfe56a7546ff89821e5d5830f06ddb263bac5842"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/055c15842a4d4888d20bf8cd65c339a0739610d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/055c15842a4d4888d20bf8cd65c339a0739610d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/055c15842a4d4888d20bf8cd65c339a0739610d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/055c15842a4d4888d20bf8cd65c339a0739610d9/comments", "author": null, "committer": null, "parents": [{"sha": "76ffb3a0be0adcb96cfddc7cbd5bc1576386ee3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76ffb3a0be0adcb96cfddc7cbd5bc1576386ee3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76ffb3a0be0adcb96cfddc7cbd5bc1576386ee3d"}], "stats": {"total": 172, "additions": 86, "deletions": 86}, "files": [{"sha": "2e2f7791205dd4f931f226b05f4d77dfe1723ac9", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/055c15842a4d4888d20bf8cd65c339a0739610d9/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/055c15842a4d4888d20bf8cd65c339a0739610d9/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=055c15842a4d4888d20bf8cd65c339a0739610d9", "patch": "@@ -2050,57 +2050,57 @@\n   return \\\"add%.l %1,%0\\\";\n } \")\n \n-(define_insn \"adddi_mem\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=o,<,>\")\n-\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"d,d,d\")))\n-   (clobber (match_scratch:SI 3 \"=d,d,d\"))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_INIT;\n-  operands[4] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n-  if (which_alternative == 2)\n-    {\n-      operands[1] = gen_rtx (MEM, SImode,\n-\t       gen_rtx (PLUS, VOIDmode, XEXP(operands[0], 0),\n-\t\t\tgen_rtx (CONST_INT, VOIDmode, -8)));\n-      return \\\"move%.l %0,%3\\;add%.l %4,%0\\;addx%.l %2,%3\\;move%.l %3,%1\\\";\n-    }\n-  if (which_alternative == 1)\n-    {\n-      operands[1] = XEXP(operands[0], 0);\n-      return \\\"add%.l %4,%0\\;move%.l %0,%3\\;addx%.l %2,%3\\;move%.l %3,%1\\\";\n-    }\n-  operands[1] = adj_offsettable_operand (operands[0], 4);\n-  return \\\"add%.l %4,%1\\;move%.l %0,%3\\;addx%.l %2,%3\\;move%.l %3,%0\\\";\n-} \")\n-\n (define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,<\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d,<,d,o<>\")\n \t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"*ao,>,d,<\")))]\n+\t\t (match_operand:DI 2 \"general_operand\" \"d,<,*ao>,d\")))\n+   (clobber (match_scratch:SI 3 \"=X,X,d,d\"))]\n   \"\"\n   \"*\n {\n-  if (which_alternative == 3)\n-    return \\\"add%.l %2,%0\\;addx%.l %2,%0\\\";\n-  operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n-  if (which_alternative == 1)\n+  if (DATA_REG_P (operands[0]))\n     {\n+      if (DATA_REG_P (operands[2]))\n+\treturn \\\"add%.l %R2,%R0\\;addx%.l %2,%0\\\";\n+      else if (GET_CODE (operands[2]) == MEM\n+\t  && GET_CODE (XEXP (operands[2], 0)) == POST_INC)\n+\t{\n+\t  return \\\"move%.l %2,%3\\;add%.l %2,%R0\\;addx%.l %3,%0\\\";\n+\t}\n+      else\n+\t{\n+\t  /* TODO : this should work also for CONST operands[2] */\n+\t  if (GET_CODE (operands[2]) == REG)\n+\t    operands[1] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+\t  else\n+\t    operands[1] = adj_offsettable_operand (operands[2], 4);\n+\t  return \\\"move%.l %2,%3\\;add%.l %1,%R0\\;addx%.l %3,%0\\\";\n+\t}\n+    }\n+  else if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (GET_CODE (operands[2]) == MEM\n+\t  && GET_CODE (XEXP (operands[2], 0)) == PRE_DEC)\n+\treturn \\\"add%.l %2,%0\\;addx%.l %2,%0\\\";\n       CC_STATUS_INIT;\n-      return \\\"add%.l %2,%0\\;add%.l %2,%1\\;negx%.l %0\\;neg%.l %0\\\";\n+      if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+\t{\n+\t  operands[1] = gen_rtx (MEM, SImode,\n+\t\t   gen_rtx (PLUS, VOIDmode, XEXP(operands[0], 0),\n+\t\t\t    gen_rtx (CONST_INT, VOIDmode, -8)));\n+\t  return \\\"move%.l %0,%3\\;add%.l %R2,%0\\;addx%.l %2,%3\\;move%.l %3,%1\\\";\n+\t}\n+      else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+\t{\n+\t  operands[1] = XEXP(operands[0], 0);\n+\t  return \\\"add%.l %R2,%0\\;move%.l %0,%3\\;addx%.l %2,%3\\;move%.l %3,%1\\\";\n+\t}\n+      else\n+\t{\n+\t  operands[1] = adj_offsettable_operand (operands[0], 4);\n+\t  return \\\"add%.l %R2,%1\\;move%.l %0,%3\\;addx%.l %2,%3\\;move%.l %3,%0\\\";\n+\t}\n     }\n-  if (GET_CODE (operands[2]) == REG)\n-    operands[3] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n-  else\n-    operands[3] = adj_offsettable_operand (operands[2], 4);\n-  if (which_alternative == 2)\n-    return \\\"add%.l %3,%1\\;addx%.l %2,%0\\\";\n-  CC_STATUS_INIT;\n-  /* negx + neg simulates (non-existent) addx #0 */\n-  /* TODO : this should work also for CONST operands[2] */\n-  return \\\"add%.l %3,%1\\;negx%.l %0\\;neg%.l %0\\;add%.l %2,%0\\\";\n } \")\n \n (define_insn \"addsi_lshrsi_31\"\n@@ -2639,57 +2639,57 @@\n   return \\\"sub%.l %1,%0\\\";\n } \")\n \n-(define_insn \"subdi_mem\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=o,<,>\")\n-\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"d,d,d\")))\n-   (clobber (match_scratch:SI 3 \"=d,d,d\"))]\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d,<,d,o<>\")\n+\t(minus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"d,<,*ao>,d\")))\n+   (clobber (match_scratch:SI 3 \"=X,X,d,d\"))]\n   \"\"\n   \"*\n {\n-  CC_STATUS_INIT;\n-  operands[4] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n-  if (which_alternative == 2)\n+  if (DATA_REG_P (operands[0]))\n     {\n-      operands[1] = gen_rtx (MEM, SImode,\n-\t       gen_rtx (PLUS, VOIDmode, XEXP(operands[0], 0),\n-\t\t\tgen_rtx (CONST_INT, VOIDmode, -8)));\n-      return \\\"move%.l %0,%3\\;sub%.l %4,%0\\;subx%.l %2,%3\\;move%.l %3,%1\\\";\n+      if (DATA_REG_P (operands[2]))\n+\treturn \\\"sub%.l %R2,%R0\\;subx%.l %2,%0\\\";\n+      else if (GET_CODE (operands[2]) == MEM\n+\t  && GET_CODE (XEXP (operands[2], 0)) == POST_INC)\n+\t{\n+\t  return \\\"move%.l %2,%3\\;sub%.l %2,%R0\\;subx%.l %3,%0\\\";\n+\t}\n+      else\n+\t{\n+\t  /* TODO : this should work also for CONST operands[2] */\n+\t  if (GET_CODE (operands[2]) == REG)\n+\t    operands[1] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+\t  else\n+\t    operands[1] = adj_offsettable_operand (operands[2], 4);\n+\t  return \\\"move%.l %2,%3\\;sub%.l %1,%R0\\;subx%.l %3,%0\\\";\n+\t}\n     }\n-  if (which_alternative == 1)\n-    {\n-      operands[1] = XEXP(operands[0], 0);\n-      return \\\"sub%.l %4,%0\\;move%.l %0,%3\\;subx%.l %2,%3\\;move%.l %3,%1\\\";\n-    }\n-  operands[1] = adj_offsettable_operand (operands[0], 4);\n-  return \\\"sub%.l %4,%1\\;move%.l %0,%3\\;subx%.l %2,%3\\;move%.l %3,%0\\\";\n-} \")\n-\n-(define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,<\")\n-\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0,0\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"*ao,>,d,<\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 3)\n-    return \\\"sub%.l %2,%0\\;subx%.l %2,%0\\\";\n-  operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n-  if (which_alternative == 1)\n+  else if (GET_CODE (operands[0]) == MEM)\n     {\n+      if (GET_CODE (operands[2]) == MEM\n+\t  && GET_CODE (XEXP (operands[2], 0)) == PRE_DEC)\n+\treturn \\\"sub%.l %2,%0\\;subx%.l %2,%0\\\";\n       CC_STATUS_INIT;\n-      return \\\"neg%.l %0\\;add%.l %2,%0\\;sub%.l %2,%1\\;negx%.l %0\\\";\n+      if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+\t{\n+\t  operands[1] = gen_rtx (MEM, SImode,\n+\t\t   gen_rtx (PLUS, VOIDmode, XEXP(operands[0], 0),\n+\t\t\t    gen_rtx (CONST_INT, VOIDmode, -8)));\n+\t  return \\\"move%.l %0,%3\\;sub%.l %R2,%0\\;subx%.l %2,%3\\;move%.l %3,%1\\\";\n+\t}\n+      else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+\t{\n+\t  operands[1] = XEXP(operands[0], 0);\n+\t  return \\\"sub%.l %R2,%0\\;move%.l %0,%3\\;subx%.l %2,%3\\;move%.l %3,%1\\\";\n+\t}\n+      else\n+\t{\n+\t  operands[1] = adj_offsettable_operand (operands[0], 4);\n+\t  return \\\"sub%.l %R2,%1\\;move%.l %0,%3\\;subx%.l %2,%3\\;move%.l %3,%0\\\";\n+\t}\n     }\n-  if (GET_CODE (operands[2]) == REG)\n-    operands[3] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n-  else\n-    operands[3] = adj_offsettable_operand (operands[2], 4);\n-  if (which_alternative == 2)\n-    return \\\"sub%.l %3,%1\\;subx%.l %2,%0\\\";\n-  CC_STATUS_INIT;\n-  /* neg + negx simulates (non-existent) subx #0 */\n-  /* TODO : this should work also for CONST operands[2] */\n-  return \\\"neg%.l %0\\;sub%.l %3,%1\\;negx%.l %0\\;sub%.l %2,%0\\\";\n } \")\n \n (define_insn \"subsi3\""}]}