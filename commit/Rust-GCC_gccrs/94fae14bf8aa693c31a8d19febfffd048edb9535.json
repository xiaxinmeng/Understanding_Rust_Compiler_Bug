{"sha": "94fae14bf8aa693c31a8d19febfffd048edb9535", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRmYWUxNGJmOGFhNjkzYzMxYThkMTlmZWJmZmZkMDQ4ZWRiOTUzNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-01-02T12:46:08Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-01-02T12:46:08Z"}, "message": "re PR fortran/51529 ([OOP] gfortran.dg/class_to_type_1.f03 is miscompiled: Uninitialized variable used)\n\n2012-01-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/51529\n\t* trans-array.c (gfc_array_allocate): Null allocated memory of\n\tnewly allocted class arrays.\n\n\tPR fortran/46262\n\tPR fortran/46328\n\tPR fortran/51052\n\t* interface.c(build_compcall_for_operator): Add a type to the\n\texpression.\n\t* trans-expr.c (conv_base_obj_fcn_val): New function.\n\t(gfc_conv_procedure_call): Use base_expr to detect non-variable\n\tbase objects and, ensuring that there is a temporary variable,\n\tbuild up the typebound call using conv_base_obj_fcn_val.\n\t(gfc_trans_class_assign): Pick out class procedure pointer\n\tassignments and do the assignment with no further prcessing.\n\t(gfc_trans_class_array_init_assign, gfc_trans_class_init_assign\n\tgfc_trans_class_assign): Move to top of file.\n\t* gfortran.h : Add 'base_expr' field to gfc_expr.\n\t* resolve.c (get_declared_from_expr): Add 'types' argument to\n\tswitch checking of derived types on or off.\n\t(resolve_typebound_generic_call): Set the new argument.\n\t(resolve_typebound_function, resolve_typebound_subroutine):\n\tSet 'types' argument for get_declared_from_expr appropriately.\n\tIdentify base expression, if not a variable, in the argument\n\tlist of class valued calls. Assign it to the 'base_expr' field\n\tof the final expression. Strip away all references after the\n\tlast class reference.\n\n\n2012-01-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/46262\n\tPR fortran/46328\n\tPR fortran/51052\n\t* gfortran.dg/typebound_operator_7.f03: New.\n\t* gfortran.dg/typebound_operator_8.f03: New.\n\nFrom-SVN: r182796", "tree": {"sha": "53e0449d8730adad6792cd4d30c5897584d9c6c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53e0449d8730adad6792cd4d30c5897584d9c6c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94fae14bf8aa693c31a8d19febfffd048edb9535", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94fae14bf8aa693c31a8d19febfffd048edb9535", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94fae14bf8aa693c31a8d19febfffd048edb9535", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94fae14bf8aa693c31a8d19febfffd048edb9535/comments", "author": null, "committer": null, "parents": [{"sha": "9ecd3a64a9a6d63bd108f2927c611fabff84745d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ecd3a64a9a6d63bd108f2927c611fabff84745d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ecd3a64a9a6d63bd108f2927c611fabff84745d"}], "stats": {"total": 1126, "additions": 956, "deletions": 170}, "files": [{"sha": "02c0def3cda913bd5c9b384c37f0ef959769fa7b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=94fae14bf8aa693c31a8d19febfffd048edb9535", "patch": "@@ -1,3 +1,33 @@\n+2012-01-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/51529\n+\t* trans-array.c (gfc_array_allocate): Null allocated memory of\n+\tnewly allocted class arrays.\n+\n+\tPR fortran/46262\n+\tPR fortran/46328\n+\tPR fortran/51052\n+\t* interface.c(build_compcall_for_operator): Add a type to the\n+\texpression.\n+\t* trans-expr.c (conv_base_obj_fcn_val): New function.\n+\t(gfc_conv_procedure_call): Use base_expr to detect non-variable\n+\tbase objects and, ensuring that there is a temporary variable,\n+\tbuild up the typebound call using conv_base_obj_fcn_val.\n+\t(gfc_trans_class_assign): Pick out class procedure pointer\n+\tassignments and do the assignment with no further prcessing.\n+\t(gfc_trans_class_array_init_assign, gfc_trans_class_init_assign\n+\tgfc_trans_class_assign): Move to top of file.\n+\t* gfortran.h : Add 'base_expr' field to gfc_expr.\n+\t* resolve.c (get_declared_from_expr): Add 'types' argument to\n+\tswitch checking of derived types on or off.\n+\t(resolve_typebound_generic_call): Set the new argument.\n+\t(resolve_typebound_function, resolve_typebound_subroutine):\n+\tSet 'types' argument for get_declared_from_expr appropriately.\n+\tIdentify base expression, if not a variable, in the argument\n+\tlist of class valued calls. Assign it to the 'base_expr' field\n+\tof the final expression. Strip away all references after the\n+\tlast class reference.\n+\n 2012-01-02  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/51682"}, {"sha": "c715b30d397343c8559080ff2993744724178527", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=94fae14bf8aa693c31a8d19febfffd048edb9535", "patch": "@@ -2330,3 +2330,4 @@ gfc_dump_parse_tree (gfc_namespace *ns, FILE *file)\n   dumpfile = file;\n   show_namespace (ns);\n }\n+"}, {"sha": "5923069996b933a058cea52fbde47817a61b9550", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=94fae14bf8aa693c31a8d19febfffd048edb9535", "patch": "@@ -1,6 +1,6 @@\n /* gfortran header file\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010, 2011\n+   2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -1697,6 +1697,10 @@ typedef struct gfc_expr\n \n   locus where;\n \n+  /* Used to store the base expression in component calls, when the expression\n+     is not a variable.  */\n+  gfc_expr *base_expr;\n+\n   /* is_boz is true if the integer is regarded as BOZ bitpatten and is_snan\n      denotes a signalling not-a-number.  */\n   unsigned int is_boz : 1, is_snan : 1;"}, {"sha": "773749d5ebcdd96982e7c85f66eea23b0beced9a", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=94fae14bf8aa693c31a8d19febfffd048edb9535", "patch": "@@ -1,6 +1,6 @@\n /* Deal with interfaces.\n    Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009,\n-   2010\n+   2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -3256,6 +3256,14 @@ build_compcall_for_operator (gfc_expr* e, gfc_actual_arglist* actual,\n   e->value.compcall.base_object = base;\n   e->value.compcall.ignore_pass = 1;\n   e->value.compcall.assign = 0;\n+  if (e->ts.type == BT_UNKNOWN\n+\t&& target->function)\n+    {\n+      if (target->is_generic)\n+\te->ts = target->u.generic->specific->u.specific->n.sym->ts;\n+      else\n+\te->ts = target->u.specific->n.sym->ts;\n+    }\n }\n \n "}, {"sha": "82045f8ea23c1dcf4cb5a8e530c00c2ebc812f86", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 75, "deletions": 9, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=94fae14bf8aa693c31a8d19febfffd048edb9535", "patch": "@@ -1,6 +1,6 @@\n /* Perform type resolution on the various structures.\n    Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n-   2010, 2011\n+   2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -5620,10 +5620,11 @@ resolve_typebound_static (gfc_expr* e, gfc_symtree** target,\n \n /* Get the ultimate declared type from an expression.  In addition,\n    return the last class/derived type reference and the copy of the\n-   reference list.  */\n+   reference list.  If check_types is set true, derived types are\n+   identified as well as class references.  */\n static gfc_symbol*\n get_declared_from_expr (gfc_ref **class_ref, gfc_ref **new_ref,\n-\t\t\tgfc_expr *e)\n+\t\t\tgfc_expr *e, bool check_types)\n {\n   gfc_symbol *declared;\n   gfc_ref *ref;\n@@ -5639,8 +5640,9 @@ get_declared_from_expr (gfc_ref **class_ref, gfc_ref **new_ref,\n       if (ref->type != REF_COMPONENT)\n \tcontinue;\n \n-      if (ref->u.c.component->ts.type == BT_CLASS\n-\t    || ref->u.c.component->ts.type == BT_DERIVED)\n+      if ((ref->u.c.component->ts.type == BT_CLASS\n+\t     || (check_types && ref->u.c.component->ts.type == BT_DERIVED))\n+\t  && ref->u.c.component->attr.flavor != FL_PROCEDURE)\n \t{\n \t  declared = ref->u.c.component->ts.u.derived;\n \t  if (class_ref)\n@@ -5735,7 +5737,7 @@ resolve_typebound_generic_call (gfc_expr* e, const char **name)\n \n success:\n   /* Make sure that we have the right specific instance for the name.  */\n-  derived = get_declared_from_expr (NULL, NULL, e);\n+  derived = get_declared_from_expr (NULL, NULL, e, true);\n \n   st = gfc_find_typebound_proc (derived, NULL, genname, true, &e->where);\n   if (st)\n@@ -5852,7 +5854,7 @@ resolve_compcall (gfc_expr* e, const char **name)\n /* Resolve a typebound function, or 'method'. First separate all\n    the non-CLASS references by calling resolve_compcall directly.  */\n \n-static gfc_try\n+gfc_try\n resolve_typebound_function (gfc_expr* e)\n {\n   gfc_symbol *declared;\n@@ -5872,6 +5874,21 @@ resolve_typebound_function (gfc_expr* e)\n   overridable = !e->value.compcall.tbp->non_overridable;\n   if (expr && expr->ts.type == BT_CLASS && e->value.compcall.name)\n     {\n+      /* If the base_object is not a variable, the corresponding actual\n+\t argument expression must be stored in e->base_expression so\n+\t that the corresponding tree temporary can be used as the base\n+\t object in gfc_conv_procedure_call.  */\n+      if (expr->expr_type != EXPR_VARIABLE)\n+\t{\n+\t  gfc_actual_arglist *args;\n+\n+\t  for (args= e->value.function.actual; args; args = args->next)\n+\t    {\n+\t      if (expr == args->expr)\n+\t\texpr = args->expr;\n+\t    }\n+\t}\n+\n       /* Since the typebound operators are generic, we have to ensure\n \t that any delays in resolution are corrected and that the vtab\n \t is present.  */\n@@ -5888,9 +5905,26 @@ resolve_typebound_function (gfc_expr* e)\n       name = name ? name : e->value.function.esym->name;\n       e->symtree = expr->symtree;\n       e->ref = gfc_copy_ref (expr->ref);\n+      get_declared_from_expr (&class_ref, NULL, e, false);\n+\n+      /* Trim away the extraneous references that emerge from nested\n+\t use of interface.c (extend_expr).  */\n+      if (class_ref && class_ref->next)\n+\t{\n+\t  gfc_free_ref_list (class_ref->next);\n+\t  class_ref->next = NULL;\n+\t}\n+      else if (e->ref && !class_ref)\n+\t{\n+\t  gfc_free_ref_list (e->ref);\n+\t  e->ref = NULL;\n+\t}\n+\n       gfc_add_vptr_component (e);\n       gfc_add_component_ref (e, name);\n       e->value.function.esym = NULL;\n+      if (expr->expr_type != EXPR_VARIABLE)\n+\te->base_expr = expr;\n       return SUCCESS;\n     }\n \n@@ -5901,7 +5935,7 @@ resolve_typebound_function (gfc_expr* e)\n     return FAILURE;\n \n   /* Get the CLASS declared type.  */\n-  declared = get_declared_from_expr (&class_ref, &new_ref, e);\n+  declared = get_declared_from_expr (&class_ref, &new_ref, e, true);\n \n   /* Weed out cases of the ultimate component being a derived type.  */\n   if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)\n@@ -5967,6 +6001,20 @@ resolve_typebound_subroutine (gfc_code *code)\n   overridable = !code->expr1->value.compcall.tbp->non_overridable;\n   if (expr && expr->ts.type == BT_CLASS && code->expr1->value.compcall.name)\n     {\n+      /* If the base_object is not a variable, the corresponding actual\n+\t argument expression must be stored in e->base_expression so\n+\t that the corresponding tree temporary can be used as the base\n+\t object in gfc_conv_procedure_call.  */\n+      if (expr->expr_type != EXPR_VARIABLE)\n+\t{\n+\t  gfc_actual_arglist *args;\n+\n+\t  args= code->expr1->value.function.actual;\n+\t  for (; args; args = args->next)\n+\t    if (expr == args->expr)\n+\t      expr = args->expr;\n+\t}\n+\n       /* Since the typebound operators are generic, we have to ensure\n \t that any delays in resolution are corrected and that the vtab\n \t is present.  */\n@@ -5982,9 +6030,27 @@ resolve_typebound_subroutine (gfc_code *code)\n       name = name ? name : code->expr1->value.function.esym->name;\n       code->expr1->symtree = expr->symtree;\n       code->expr1->ref = gfc_copy_ref (expr->ref);\n+\n+      /* Trim away the extraneous references that emerge from nested\n+\t use of interface.c (extend_expr).  */\n+      get_declared_from_expr (&class_ref, NULL, code->expr1, false);\n+      if (class_ref && class_ref->next)\n+\t{\n+\t  gfc_free_ref_list (class_ref->next);\n+\t  class_ref->next = NULL;\n+\t}\n+      else if (code->expr1->ref && !class_ref)\n+\t{\n+\t  gfc_free_ref_list (code->expr1->ref);\n+\t  code->expr1->ref = NULL;\n+\t}\n+\n+      /* Now use the procedure in the vtable.  */\n       gfc_add_vptr_component (code->expr1);\n       gfc_add_component_ref (code->expr1, name);\n       code->expr1->value.function.esym = NULL;\n+      if (expr->expr_type != EXPR_VARIABLE)\n+\tcode->expr1->base_expr = expr;\n       return SUCCESS;\n     }\n \n@@ -5995,7 +6061,7 @@ resolve_typebound_subroutine (gfc_code *code)\n     return FAILURE;\n \n   /* Get the CLASS declared type.  */\n-  get_declared_from_expr (&class_ref, &new_ref, code->expr1);\n+  get_declared_from_expr (&class_ref, &new_ref, code->expr1, true);\n \n   /* Weed out cases of the ultimate component being a derived type.  */\n   if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)"}, {"sha": "50e1ee422f90dedc77822000f72fae2846ad87f4", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=94fae14bf8aa693c31a8d19febfffd048edb9535", "patch": "@@ -1,6 +1,6 @@\n /* Array translation routines\n    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n-   2011\n+   2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -5069,6 +5069,18 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \n   gfc_add_expr_to_block (&se->pre, tmp);\n \n+  if (expr->ts.type == BT_CLASS && expr3)\n+    {\n+      tmp = build_int_cst (unsigned_char_type_node, 0);\n+      /* For class objects we need to nullify the memory in case they have\n+\t allocatable components; the reason is that _copy, which is used for\n+\t initialization, first frees the destination.  */\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t builtin_decl_explicit (BUILT_IN_MEMSET),\n+\t\t\t\t 3, pointer, tmp,  size);\n+      gfc_add_expr_to_block (&se->pre, tmp);\n+    }\n+\n   /* Update the array descriptors. */\n   if (dimension)\n     gfc_conv_descriptor_offset_set (&set_descriptor_block, se->expr, offset);"}, {"sha": "2ffa9fc2af7c36bf09cfaa378e08c9735f0558e5", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 213, "deletions": 158, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=94fae14bf8aa693c31a8d19febfffd048edb9535", "patch": "@@ -1,6 +1,6 @@\n /* Expression translation\n    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n-   2011\n+   2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -302,6 +302,179 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e,\n   parmse->expr = gfc_build_addr_expr (NULL_TREE, var);\n }\n \n+\n+static tree\n+gfc_trans_class_array_init_assign (gfc_expr *rhs, gfc_expr *lhs, gfc_expr *obj)\n+{\n+  gfc_actual_arglist *actual;\n+  gfc_expr *ppc;\n+  gfc_code *ppc_code;\n+  tree res;\n+\n+  actual = gfc_get_actual_arglist ();\n+  actual->expr = gfc_copy_expr (rhs);\n+  actual->next = gfc_get_actual_arglist ();\n+  actual->next->expr = gfc_copy_expr (lhs);\n+  ppc = gfc_copy_expr (obj);\n+  gfc_add_vptr_component (ppc);\n+  gfc_add_component_ref (ppc, \"_copy\");\n+  ppc_code = gfc_get_code ();\n+  ppc_code->resolved_sym = ppc->symtree->n.sym;\n+  /* Although '_copy' is set to be elemental in class.c, it is\n+     not staying that way.  Find out why, sometime....  */\n+  ppc_code->resolved_sym->attr.elemental = 1;\n+  ppc_code->ext.actual = actual;\n+  ppc_code->expr1 = ppc;\n+  ppc_code->op = EXEC_CALL;\n+  /* Since '_copy' is elemental, the scalarizer will take care\n+     of arrays in gfc_trans_call.  */\n+  res = gfc_trans_call (ppc_code, false, NULL, NULL, false);\n+  gfc_free_statements (ppc_code);\n+  return res;\n+}\n+\n+/* Special case for initializing a polymorphic dummy with INTENT(OUT).\n+   A MEMCPY is needed to copy the full data from the default initializer\n+   of the dynamic type.  */\n+\n+tree\n+gfc_trans_class_init_assign (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  tree tmp;\n+  gfc_se dst,src,memsz;\n+  gfc_expr *lhs, *rhs, *sz;\n+\n+  gfc_start_block (&block);\n+\n+  lhs = gfc_copy_expr (code->expr1);\n+  gfc_add_data_component (lhs);\n+\n+  rhs = gfc_copy_expr (code->expr1);\n+  gfc_add_vptr_component (rhs);\n+\n+  /* Make sure that the component backend_decls have been built, which\n+     will not have happened if the derived types concerned have not\n+     been referenced.  */\n+  gfc_get_derived_type (rhs->ts.u.derived);\n+  gfc_add_def_init_component (rhs);\n+\n+  if (code->expr1->ts.type == BT_CLASS\n+\t&& CLASS_DATA (code->expr1)->attr.dimension)\n+    tmp = gfc_trans_class_array_init_assign (rhs, lhs, code->expr1);\n+  else\n+    {\n+      sz = gfc_copy_expr (code->expr1);\n+      gfc_add_vptr_component (sz);\n+      gfc_add_size_component (sz);\n+\n+      gfc_init_se (&dst, NULL);\n+      gfc_init_se (&src, NULL);\n+      gfc_init_se (&memsz, NULL);\n+      gfc_conv_expr (&dst, lhs);\n+      gfc_conv_expr (&src, rhs);\n+      gfc_conv_expr (&memsz, sz);\n+      gfc_add_block_to_block (&block, &src.pre);\n+      tmp = gfc_build_memcpy_call (dst.expr, src.expr, memsz.expr);\n+    }\n+  gfc_add_expr_to_block (&block, tmp);\n+  \n+  return gfc_finish_block (&block);\n+}\n+\n+\n+/* Translate an assignment to a CLASS object\n+   (pointer or ordinary assignment).  */\n+\n+tree\n+gfc_trans_class_assign (gfc_expr *expr1, gfc_expr *expr2, gfc_exec_op op)\n+{\n+  stmtblock_t block;\n+  tree tmp;\n+  gfc_expr *lhs;\n+  gfc_expr *rhs;\n+  gfc_ref *ref;\n+\n+  gfc_start_block (&block);\n+\n+  ref = expr1->ref;\n+  while (ref && ref->next)\n+     ref = ref->next;\n+\n+  /* Class valued proc_pointer assignments do not need any further\n+     preparation.  */\n+  if (ref && ref->type == REF_COMPONENT\n+\t&& ref->u.c.component->attr.proc_pointer\n+\t&& expr2->expr_type == EXPR_VARIABLE\n+\t&& expr2->symtree->n.sym->attr.flavor == FL_PROCEDURE\n+\t&& op == EXEC_POINTER_ASSIGN)\n+    goto assign;\n+\n+  if (expr2->ts.type != BT_CLASS)\n+    {\n+      /* Insert an additional assignment which sets the '_vptr' field.  */\n+      gfc_symbol *vtab = NULL;\n+      gfc_symtree *st;\n+\n+      lhs = gfc_copy_expr (expr1);\n+      gfc_add_vptr_component (lhs);\n+\n+      if (expr2->ts.type == BT_DERIVED)\n+\tvtab = gfc_find_derived_vtab (expr2->ts.u.derived);\n+      else if (expr2->expr_type == EXPR_NULL)\n+\tvtab = gfc_find_derived_vtab (expr1->ts.u.derived);\n+      gcc_assert (vtab);\n+\n+      rhs = gfc_get_expr ();\n+      rhs->expr_type = EXPR_VARIABLE;\n+      gfc_find_sym_tree (vtab->name, vtab->ns, 1, &st);\n+      rhs->symtree = st;\n+      rhs->ts = vtab->ts;\n+\n+      tmp = gfc_trans_pointer_assignment (lhs, rhs);\n+      gfc_add_expr_to_block (&block, tmp);\n+\n+      gfc_free_expr (lhs);\n+      gfc_free_expr (rhs);\n+    }\n+  else if (CLASS_DATA (expr2)->attr.dimension)\n+    {\n+      /* Insert an additional assignment which sets the '_vptr' field.  */\n+      lhs = gfc_copy_expr (expr1);\n+      gfc_add_vptr_component (lhs);\n+\n+      rhs = gfc_copy_expr (expr2);\n+      gfc_add_vptr_component (rhs);\n+\n+      tmp = gfc_trans_pointer_assignment (lhs, rhs);\n+      gfc_add_expr_to_block (&block, tmp);\n+\n+      gfc_free_expr (lhs);\n+      gfc_free_expr (rhs);\n+    }\n+\n+  /* Do the actual CLASS assignment.  */\n+  if (expr2->ts.type == BT_CLASS\n+\t&& !CLASS_DATA (expr2)->attr.dimension)\n+    op = EXEC_ASSIGN;\n+  else\n+    gfc_add_data_component (expr1);\n+\n+assign:\n+\n+  if (op == EXEC_ASSIGN)\n+    tmp = gfc_trans_assignment (expr1, expr2, false, true);\n+  else if (op == EXEC_POINTER_ASSIGN)\n+    tmp = gfc_trans_pointer_assignment (expr1, expr2);\n+  else\n+    gcc_unreachable();\n+\n+  gfc_add_expr_to_block (&block, tmp);\n+\n+  return gfc_finish_block (&block);\n+}\n+\n+\n /* End of prototype trans-class.c  */\n \n \n@@ -1976,6 +2149,31 @@ get_proc_ptr_comp (gfc_expr *e)\n }\n \n \n+/* Convert a typebound function reference from a class object.  */\n+static void\n+conv_base_obj_fcn_val (gfc_se * se, tree base_object, gfc_expr * expr)\n+{\n+  gfc_ref *ref;\n+  tree var;\n+\n+  if (TREE_CODE (base_object) != VAR_DECL)\n+    {\n+      var = gfc_create_var (TREE_TYPE (base_object), NULL);\n+      gfc_add_modify (&se->pre, var, base_object);\n+    }\n+  se->expr = gfc_class_vptr_get (base_object);\n+  se->expr = build_fold_indirect_ref_loc (input_location, se->expr);\n+  ref = expr->ref;\n+  while (ref && ref->next)\n+    ref = ref->next;\n+  gcc_assert (ref && ref->type == REF_COMPONENT);\n+  if (ref->u.c.sym->attr.extension)\n+    conv_parent_component_references (se, ref);\n+  gfc_conv_component_ref (se, ref);\n+  se->expr = build_fold_addr_expr_loc (input_location, se->expr);\n+}\n+\n+\n static void\n conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)\n {\n@@ -3084,6 +3282,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   tree type;\n   tree var;\n   tree len;\n+  tree base_object;\n   VEC(tree,gc) *stringargs;\n   tree result = NULL;\n   gfc_formal_arglist *formal;\n@@ -3156,6 +3355,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t   != EXPR_CONSTANT);\n     }\n \n+  base_object = NULL_TREE;\n+\n   /* Evaluate the arguments.  */\n   for (arg = args; arg != NULL;\n        arg = arg->next, formal = formal ? formal->next : NULL)\n@@ -3301,6 +3502,13 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t{\n \t\t  gfc_conv_expr_reference (&parmse, e);\n \n+\t\t  /* Catch base objects that are not variables.  */\n+\t\t  if (e->ts.type == BT_CLASS\n+\t\t\t&& e->expr_type != EXPR_VARIABLE\n+\t\t\t&& expr && e == expr->base_expr)\n+\t\t    base_object = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\t       parmse.expr);\n+\n \t\t  /* A class array element needs converting back to be a\n \t\t     class object, if the formal argument is a class object.  */\n \t\t  if (fsym && fsym->ts.type == BT_CLASS\n@@ -4000,7 +4208,10 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   arglist = retargs;\n \n   /* Generate the actual call.  */\n-  conv_function_val (se, sym, expr);\n+  if (base_object == NULL_TREE)\n+    conv_function_val (se, sym, expr);\n+  else\n+    conv_base_obj_fcn_val (se, base_object, expr);\n \n   /* If there are alternate return labels, function type should be\n      integer.  Can't modify the type in place though, since it can be shared\n@@ -5294,7 +5505,6 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n       return;\n     }\n \n-\n   gfc_conv_expr (se, expr);\n \n   /* Create a temporary var to hold the value.  */\n@@ -6730,158 +6940,3 @@ gfc_trans_assign (gfc_code * code)\n {\n   return gfc_trans_assignment (code->expr1, code->expr2, false, true);\n }\n-\n-\n-static tree\n-gfc_trans_class_array_init_assign (gfc_expr *rhs, gfc_expr *lhs, gfc_expr *obj)\n-{\n-  gfc_actual_arglist *actual;\n-  gfc_expr *ppc;\n-  gfc_code *ppc_code;\n-  tree res;\n-\n-  actual = gfc_get_actual_arglist ();\n-  actual->expr = gfc_copy_expr (rhs);\n-  actual->next = gfc_get_actual_arglist ();\n-  actual->next->expr = gfc_copy_expr (lhs);\n-  ppc = gfc_copy_expr (obj);\n-  gfc_add_vptr_component (ppc);\n-  gfc_add_component_ref (ppc, \"_copy\");\n-  ppc_code = gfc_get_code ();\n-  ppc_code->resolved_sym = ppc->symtree->n.sym;\n-  /* Although '_copy' is set to be elemental in class.c, it is\n-     not staying that way.  Find out why, sometime....  */\n-  ppc_code->resolved_sym->attr.elemental = 1;\n-  ppc_code->ext.actual = actual;\n-  ppc_code->expr1 = ppc;\n-  ppc_code->op = EXEC_CALL;\n-  /* Since '_copy' is elemental, the scalarizer will take care\n-     of arrays in gfc_trans_call.  */\n-  res = gfc_trans_call (ppc_code, false, NULL, NULL, false);\n-  gfc_free_statements (ppc_code);\n-  return res;\n-}\n-\n-/* Special case for initializing a polymorphic dummy with INTENT(OUT).\n-   A MEMCPY is needed to copy the full data from the default initializer\n-   of the dynamic type.  */\n-\n-tree\n-gfc_trans_class_init_assign (gfc_code *code)\n-{\n-  stmtblock_t block;\n-  tree tmp;\n-  gfc_se dst,src,memsz;\n-  gfc_expr *lhs,*rhs,*sz;\n-\n-  gfc_start_block (&block);\n-\n-  lhs = gfc_copy_expr (code->expr1);\n-  gfc_add_data_component (lhs);\n-\n-  rhs = gfc_copy_expr (code->expr1);\n-  gfc_add_vptr_component (rhs);\n-\n-  /* Make sure that the component backend_decls have been built, which\n-     will not have happened if the derived types concerned have not\n-     been referenced.  */\n-  gfc_get_derived_type (rhs->ts.u.derived);\n-  gfc_add_def_init_component (rhs);\n-\n-  if (code->expr1->ts.type == BT_CLASS\n-\t&& CLASS_DATA (code->expr1)->attr.dimension)\n-    tmp = gfc_trans_class_array_init_assign (rhs, lhs, code->expr1);\n-  else\n-    {\n-      sz = gfc_copy_expr (code->expr1);\n-      gfc_add_vptr_component (sz);\n-      gfc_add_size_component (sz);\n-\n-      gfc_init_se (&dst, NULL);\n-      gfc_init_se (&src, NULL);\n-      gfc_init_se (&memsz, NULL);\n-      gfc_conv_expr (&dst, lhs);\n-      gfc_conv_expr (&src, rhs);\n-      gfc_conv_expr (&memsz, sz);\n-      gfc_add_block_to_block (&block, &src.pre);\n-      tmp = gfc_build_memcpy_call (dst.expr, src.expr, memsz.expr);\n-    }\n-  gfc_add_expr_to_block (&block, tmp);\n-  \n-  return gfc_finish_block (&block);\n-}\n-\n-\n-/* Translate an assignment to a CLASS object\n-   (pointer or ordinary assignment).  */\n-\n-tree\n-gfc_trans_class_assign (gfc_expr *expr1, gfc_expr *expr2, gfc_exec_op op)\n-{\n-  stmtblock_t block;\n-  tree tmp;\n-  gfc_expr *lhs;\n-  gfc_expr *rhs;\n-\n-  gfc_start_block (&block);\n-\n-  if (expr2->ts.type != BT_CLASS)\n-    {\n-      /* Insert an additional assignment which sets the '_vptr' field.  */\n-      gfc_symbol *vtab = NULL;\n-      gfc_symtree *st;\n-\n-      lhs = gfc_copy_expr (expr1);\n-      gfc_add_vptr_component (lhs);\n-\n-      if (expr2->ts.type == BT_DERIVED)\n-\tvtab = gfc_find_derived_vtab (expr2->ts.u.derived);\n-      else if (expr2->expr_type == EXPR_NULL)\n-\tvtab = gfc_find_derived_vtab (expr1->ts.u.derived);\n-      gcc_assert (vtab);\n-\n-      rhs = gfc_get_expr ();\n-      rhs->expr_type = EXPR_VARIABLE;\n-      gfc_find_sym_tree (vtab->name, vtab->ns, 1, &st);\n-      rhs->symtree = st;\n-      rhs->ts = vtab->ts;\n-\n-      tmp = gfc_trans_pointer_assignment (lhs, rhs);\n-      gfc_add_expr_to_block (&block, tmp);\n-\n-      gfc_free_expr (lhs);\n-      gfc_free_expr (rhs);\n-    }\n-  else if (CLASS_DATA (expr2)->attr.dimension)\n-    {\n-      /* Insert an additional assignment which sets the '_vptr' field.  */\n-      lhs = gfc_copy_expr (expr1);\n-      gfc_add_vptr_component (lhs);\n-\n-      rhs = gfc_copy_expr (expr2);\n-      gfc_add_vptr_component (rhs);\n-\n-      tmp = gfc_trans_pointer_assignment (lhs, rhs);\n-      gfc_add_expr_to_block (&block, tmp);\n-\n-      gfc_free_expr (lhs);\n-      gfc_free_expr (rhs);\n-    }\n-\n-  /* Do the actual CLASS assignment.  */\n-  if (expr2->ts.type == BT_CLASS && !CLASS_DATA (expr2)->attr.dimension)\n-    op = EXEC_ASSIGN;\n-  else\n-    gfc_add_data_component (expr1);\n-\n-  if (op == EXEC_ASSIGN)\n-    tmp = gfc_trans_assignment (expr1, expr2, false, true);\n-  else if (op == EXEC_POINTER_ASSIGN)\n-    tmp = gfc_trans_pointer_assignment (expr1, expr2);\n-  else\n-    gcc_unreachable();\n-\n-  gfc_add_expr_to_block (&block, tmp);\n-\n-  return gfc_finish_block (&block);\n-}"}, {"sha": "e24d96c452260562d96c9ed2db1a26879862dc3d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=94fae14bf8aa693c31a8d19febfffd048edb9535", "patch": "@@ -1,3 +1,11 @@\n+2012-01-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/46262\n+\tPR fortran/46328\n+\tPR fortran/51052\n+\t* gfortran.dg/typebound_operator_7.f03: New.\n+\t* gfortran.dg/typebound_operator_8.f03: New.\n+\n 2012-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tPR target/51729"}, {"sha": "c61a00c6671c3ae07a54b0ae594b8e03d001f873", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_7.f03", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_7.f03?ref=94fae14bf8aa693c31a8d19febfffd048edb9535", "patch": "@@ -0,0 +1,103 @@\n+! { dg-do run }\n+! PR46328 - complex expressions involving typebound operators of class objects.\n+!\n+module field_module\n+  implicit none\n+  type ,abstract :: field\n+  contains\n+    procedure(field_op_real) ,deferred :: multiply_real\n+    procedure(field_plus_field) ,deferred :: plus\n+    procedure(assign_field) ,deferred :: assn\n+    generic :: operator(*) => multiply_real\n+    generic :: operator(+) => plus\n+    generic :: ASSIGNMENT(=) => assn\n+  end type\n+  abstract interface\n+    function field_plus_field(lhs,rhs)\n+      import :: field\n+      class(field) ,intent(in)  :: lhs\n+      class(field) ,intent(in)  :: rhs\n+      class(field) ,allocatable :: field_plus_field\n+    end function\n+  end interface\n+  abstract interface\n+    function field_op_real(lhs,rhs)\n+      import :: field\n+      class(field) ,intent(in)  :: lhs\n+      real ,intent(in) :: rhs\n+      class(field) ,allocatable :: field_op_real\n+    end function\n+  end interface\n+  abstract interface\n+    subroutine assign_field(lhs,rhs)\n+      import :: field\n+      class(field) ,intent(OUT)  :: lhs\n+      class(field) ,intent(IN)  :: rhs\n+    end subroutine\n+  end interface\n+end module\n+\n+module i_field_module\n+  use field_module\n+  implicit none\n+  type, extends (field)  :: i_field\n+    integer :: i\n+  contains\n+    procedure :: multiply_real => i_multiply_real\n+    procedure :: plus => i_plus_i\n+    procedure :: assn => i_assn\n+  end type\n+contains\n+  function i_plus_i(lhs,rhs)\n+    class(i_field) ,intent(in)  :: lhs\n+    class(field) ,intent(in)  :: rhs\n+    class(field) ,allocatable :: i_plus_i\n+    integer :: m = 0\n+    select type (lhs)\n+      type is (i_field); m = lhs%i\n+    end select\n+    select type (rhs)\n+      type is (i_field); m = rhs%i + m\n+    end select\n+    allocate (i_plus_i, source = i_field (m))\n+  end function\n+  function i_multiply_real(lhs,rhs)\n+    class(i_field) ,intent(in)  :: lhs\n+    real ,intent(in) :: rhs\n+    class(field) ,allocatable :: i_multiply_real\n+    integer :: m = 0\n+    select type (lhs)\n+      type is (i_field); m = lhs%i * int (rhs)\n+    end select\n+    allocate (i_multiply_real, source = i_field (m))\n+  end function\n+  subroutine i_assn(lhs,rhs)\n+    class(i_field) ,intent(OUT)  :: lhs\n+    class(field) ,intent(IN)  :: rhs\n+    select type (lhs)\n+      type is (i_field)\n+        select type (rhs)\n+          type is (i_field)\n+            lhs%i = rhs%i\n+        end select         \n+      end select\n+    end subroutine\n+end module\n+\n+program main\n+  use i_field_module\n+  implicit none\n+  class(i_field) ,allocatable :: u\n+  allocate (u, source = i_field (99))\n+\n+  u = u*2.\n+  u = (u*2.0*4.0) + u*4.0\n+  u = u%multiply_real (2.0)*4.0\n+  u = i_multiply_real (u, 2.0) * 4.0\n+  \n+  select type (u)\n+    type is (i_field); if (u%i .ne. 152064) call abort\n+  end select\n+end program\n+! { dg-final { cleanup-modules \"field_module i_field_module\" } }\n+"}, {"sha": "9519e98abb0c1727e94cf7f1b76318ae9ed17120", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_8.f03", "status": "added", "additions": 499, "deletions": 0, "changes": 499, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fae14bf8aa693c31a8d19febfffd048edb9535/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_8.f03?ref=94fae14bf8aa693c31a8d19febfffd048edb9535", "patch": "@@ -0,0 +1,499 @@\n+! { dg-do run }\n+!\n+!     Solve a diffusion problem using an object-oriented approach\n+!\n+!     Author: Arjen Markus (comp.lang.fortran)\n+!     This version: pault@gcc.gnu.org\n+!\n+!     Note:\n+!     (i) This could be turned into a more sophisticated program\n+!     using the techniques described in the chapter on\n+!     mathematical abstractions.\n+!     (That would allow the selection of the time integration\n+!     method in a transparent way)\n+!\n+!     (ii) The target procedures for process_p and source_p are\n+!     different to the typebound procedures for dynamic types\n+!     because the passed argument is not type(base_pde_object).\n+!\n+!     (iii) Two solutions are calculated, one with the procedure\n+!     pointers and the other with typebound procedures. The sums\n+!     of the solutions are compared.\n+\n+!     (iv) The source is a delta function in the middle of the\n+!     mesh, whilst the process is quartic in the local value,\n+!     when it is positive.\n+!\n+! base_pde_objects --\n+!     Module to define the basic objects\n+!\n+module base_pde_objects\n+  implicit none\n+  type, abstract :: base_pde_object\n+! No data\n+    procedure(process_p), pointer, pass :: process_p\n+    procedure(source_p), pointer, pass  :: source_p\n+  contains\n+    procedure(process), deferred :: process\n+    procedure(source), deferred :: source\n+    procedure :: initialise\n+    procedure :: nabla2\n+    procedure :: print\n+    procedure(real_times_obj), pass(obj), deferred :: real_times_obj\n+    procedure(obj_plus_obj),              deferred :: obj_plus_obj\n+    procedure(obj_assign_obj),            deferred :: obj_assign_obj\n+    generic :: operator(*)    => real_times_obj\n+    generic :: operator(+)    => obj_plus_obj\n+    generic :: assignment(=)  => obj_assign_obj\n+  end type\n+  abstract interface\n+    function process_p (obj)\n+      import base_pde_object\n+      class(base_pde_object), intent(in)  :: obj\n+      class(base_pde_object), allocatable :: process_p\n+    end function process_p\n+  end interface\n+  abstract interface\n+    function source_p (obj, time)\n+      import base_pde_object\n+      class(base_pde_object), intent(in)  :: obj\n+      real, intent(in)                    :: time\n+      class(base_pde_object), allocatable :: source_p\n+    end function source_p\n+  end interface\n+  abstract interface\n+    function process (obj)\n+      import base_pde_object\n+      class(base_pde_object), intent(in)  :: obj\n+      class(base_pde_object), allocatable :: process\n+    end function process\n+  end interface\n+  abstract interface\n+    function source (obj, time)\n+      import base_pde_object\n+      class(base_pde_object), intent(in)  :: obj\n+      real, intent(in)                    :: time\n+      class(base_pde_object), allocatable :: source\n+    end function source\n+  end interface\n+  abstract interface\n+    function real_times_obj (factor, obj) result(newobj)\n+      import base_pde_object\n+      real, intent(in)                    :: factor\n+      class(base_pde_object), intent(in)  :: obj\n+      class(base_pde_object), allocatable :: newobj\n+    end function real_times_obj\n+  end interface\n+  abstract interface\n+    function obj_plus_obj (obj1, obj2) result(newobj)\n+      import base_pde_object\n+      class(base_pde_object), intent(in)  :: obj1\n+      class(base_pde_object), intent(in)  :: obj2\n+      class(base_pde_object), allocatable :: newobj\n+    end function obj_plus_obj\n+  end interface\n+  abstract interface\n+    subroutine obj_assign_obj (obj1, obj2)\n+      import base_pde_object\n+      class(base_pde_object), intent(inout)  :: obj1\n+      class(base_pde_object), intent(in)     :: obj2\n+    end subroutine obj_assign_obj\n+  end interface\n+contains\n+! print --\n+!     Print the concentration field\n+  subroutine print (obj)\n+    class(base_pde_object) :: obj\n+    ! Dummy\n+  end subroutine print\n+! initialise --\n+!     Initialise the concentration field using a specific function\n+  subroutine initialise (obj, funcxy)\n+    class(base_pde_object) :: obj\n+    interface\n+      real function funcxy (coords)\n+        real, dimension(:), intent(in) :: coords\n+      end function funcxy\n+    end interface\n+    ! Dummy\n+  end subroutine initialise\n+! nabla2 --\n+!     Determine the divergence\n+  function nabla2 (obj)\n+    class(base_pde_object), intent(in)  :: obj\n+    class(base_pde_object), allocatable :: nabla2\n+    ! Dummy\n+  end function nabla2\n+end module base_pde_objects\n+! cartesian_2d_objects --\n+!     PDE object on a 2D cartesian grid\n+!\n+module cartesian_2d_objects\n+  use base_pde_objects\n+  implicit none\n+  type, extends(base_pde_object) :: cartesian_2d_object\n+    real, dimension(:,:), allocatable :: c\n+    real                              :: dx\n+    real                              :: dy\n+  contains\n+    procedure            :: process       => process_cart2d\n+    procedure            :: source         => source_cart2d\n+    procedure            :: initialise     => initialise_cart2d\n+    procedure            :: nabla2         => nabla2_cart2d\n+    procedure            :: print          => print_cart2d\n+    procedure, pass(obj) :: real_times_obj => real_times_cart2d\n+    procedure            :: obj_plus_obj   => obj_plus_cart2d\n+    procedure            :: obj_assign_obj => obj_assign_cart2d\n+  end type cartesian_2d_object\n+  interface grid_definition\n+    module procedure grid_definition_cart2d\n+  end interface\n+contains\n+  function process_cart2d (obj)\n+    class(cartesian_2d_object), intent(in)  :: obj\n+    class(base_pde_object), allocatable :: process_cart2d\n+    allocate (process_cart2d,source = obj)\n+    select type (process_cart2d)\n+      type is (cartesian_2d_object)\n+        process_cart2d%c = -sign (obj%c, 1.0)*obj%c** 4\n+      class default\n+        call abort\n+    end select\n+  end function process_cart2d\n+  function process_cart2d_p (obj)\n+    class(base_pde_object), intent(in)  :: obj\n+    class(base_pde_object), allocatable :: process_cart2d_p\n+    allocate (process_cart2d_p,source = obj)\n+    select type (process_cart2d_p)\n+      type is (cartesian_2d_object)\n+        select type (obj)\n+          type is (cartesian_2d_object)\n+            process_cart2d_p%c = -sign (obj%c, 1.0)*obj%c** 4\n+        end select\n+      class default\n+        call abort\n+    end select\n+  end function process_cart2d_p\n+  function source_cart2d (obj, time)\n+    class(cartesian_2d_object), intent(in)  :: obj\n+    real, intent(in)                    :: time\n+    class(base_pde_object), allocatable :: source_cart2d\n+    integer :: m, n\n+    m = size (obj%c, 1)\n+    n = size (obj%c, 2)\n+    allocate (source_cart2d, source = obj)\n+    select type (source_cart2d)\n+      type is (cartesian_2d_object)\n+        if (allocated (source_cart2d%c)) deallocate (source_cart2d%c)\n+        allocate (source_cart2d%c(m, n))\n+        source_cart2d%c = 0.0\n+        if (time .lt. 5.0) source_cart2d%c(m/2, n/2) = 0.1\n+      class default\n+        call abort\n+    end select\n+  end function source_cart2d\n+\n+  function source_cart2d_p (obj, time)\n+    class(base_pde_object), intent(in)  :: obj\n+    real, intent(in)                    :: time\n+    class(base_pde_object), allocatable :: source_cart2d_p\n+    integer :: m, n\n+    select type (obj)\n+      type is (cartesian_2d_object)\n+        m = size (obj%c, 1)\n+        n = size (obj%c, 2)\n+      class default\n+       call abort\n+    end select\n+    allocate (source_cart2d_p,source = obj)\n+    select type (source_cart2d_p)\n+      type is (cartesian_2d_object)\n+        if (allocated (source_cart2d_p%c)) deallocate (source_cart2d_p%c)\n+        allocate (source_cart2d_p%c(m,n))\n+        source_cart2d_p%c = 0.0\n+        if (time .lt. 5.0) source_cart2d_p%c(m/2, n/2) = 0.1\n+      class default\n+        call abort\n+    end select\n+  end function source_cart2d_p\n+\n+! grid_definition --\n+!     Initialises the grid\n+!\n+  subroutine grid_definition_cart2d (obj, sizes, dims)\n+    class(base_pde_object), allocatable :: obj\n+    real, dimension(:)                  :: sizes\n+    integer, dimension(:)               :: dims\n+    allocate( cartesian_2d_object :: obj )\n+    select type (obj)\n+      type is (cartesian_2d_object)\n+        allocate (obj%c(dims(1), dims(2)))\n+        obj%c  = 0.0\n+        obj%dx = sizes(1)/dims(1)\n+        obj%dy = sizes(2)/dims(2)\n+      class default\n+        call abort\n+    end select\n+  end subroutine grid_definition_cart2d\n+! print_cart2d --\n+!     Print the concentration field to the screen\n+!\n+  subroutine print_cart2d (obj)\n+    class(cartesian_2d_object) :: obj\n+    character(len=20)          :: format\n+    write( format, '(a,i0,a)' ) '(', size(obj%c,1), 'f6.3)'\n+    write( *, format ) obj%c\n+  end subroutine print_cart2d\n+! initialise_cart2d --\n+!     Initialise the concentration field using a specific function\n+!\n+  subroutine initialise_cart2d (obj, funcxy)\n+    class(cartesian_2d_object) :: obj\n+    interface\n+      real function funcxy (coords)\n+        real, dimension(:), intent(in) :: coords\n+      end function funcxy\n+    end interface\n+    integer                    :: i, j\n+    real, dimension(2)         :: x\n+    obj%c = 0.0\n+    do j = 2,size (obj%c, 2)-1\n+      x(2) = obj%dy * (j-1)\n+      do i = 2,size (obj%c, 1)-1\n+        x(1) = obj%dx * (i-1)\n+        obj%c(i,j) = funcxy (x)\n+      enddo\n+    enddo\n+  end subroutine initialise_cart2d\n+! nabla2_cart2d\n+!     Determine the divergence\n+  function nabla2_cart2d (obj)\n+    class(cartesian_2d_object), intent(in)  :: obj\n+    class(base_pde_object), allocatable     :: nabla2_cart2d\n+    integer                                 :: m, n\n+    real                                    :: dx, dy\n+    m = size (obj%c, 1)\n+    n = size (obj%c, 2)\n+    dx = obj%dx\n+    dy = obj%dy\n+    allocate (cartesian_2d_object :: nabla2_cart2d)\n+    select type (nabla2_cart2d)\n+      type is (cartesian_2d_object)\n+        allocate (nabla2_cart2d%c(m,n))\n+        nabla2_cart2d%c = 0.0\n+        nabla2_cart2d%c(2:m-1,2:n-1) = &\n+          -(2.0 * obj%c(2:m-1,2:n-1) - obj%c(1:m-2,2:n-1) - obj%c(3:m,2:n-1)) / dx**2 &\n+          -(2.0 * obj%c(2:m-1,2:n-1) - obj%c(2:m-1,1:n-2) - obj%c(2:m-1,3:n)) / dy**2\n+      class default\n+        call abort\n+    end select\n+  end function nabla2_cart2d\n+  function real_times_cart2d (factor, obj) result(newobj)\n+    real, intent(in)                        :: factor\n+    class(cartesian_2d_object), intent(in)  :: obj\n+    class(base_pde_object), allocatable     :: newobj\n+    integer                                 :: m, n\n+    m = size (obj%c, 1)\n+    n = size (obj%c, 2)\n+    allocate (cartesian_2d_object :: newobj)\n+    select type (newobj)\n+      type is (cartesian_2d_object)\n+        allocate (newobj%c(m,n))\n+        newobj%c = factor * obj%c\n+      class default\n+        call abort\n+    end select\n+  end function real_times_cart2d\n+  function obj_plus_cart2d (obj1, obj2) result( newobj )\n+    class(cartesian_2d_object), intent(in)  :: obj1\n+    class(base_pde_object), intent(in)      :: obj2\n+    class(base_pde_object), allocatable     :: newobj\n+    integer                                 :: m, n\n+    m = size (obj1%c, 1)\n+    n = size (obj1%c, 2)\n+    allocate (cartesian_2d_object :: newobj)\n+    select type (newobj)\n+      type is (cartesian_2d_object)\n+        allocate (newobj%c(m,n))\n+          select type (obj2)\n+            type is (cartesian_2d_object)\n+              newobj%c = obj1%c + obj2%c\n+            class default\n+              call abort\n+          end select\n+      class default\n+        call abort\n+    end select\n+  end function obj_plus_cart2d\n+  subroutine obj_assign_cart2d (obj1, obj2)\n+    class(cartesian_2d_object), intent(inout) :: obj1\n+    class(base_pde_object), intent(in)        :: obj2\n+    select type (obj2)\n+      type is (cartesian_2d_object)\n+        obj1%c = obj2%c\n+      class default\n+        call abort\n+    end select\n+  end subroutine obj_assign_cart2d\n+end module cartesian_2d_objects\n+! define_pde_objects --\n+!     Module to bring all the PDE object types together\n+!\n+module define_pde_objects\n+  use base_pde_objects\n+  use cartesian_2d_objects\n+  implicit none\n+  interface grid_definition\n+    module procedure grid_definition_general\n+  end interface\n+contains\n+  subroutine grid_definition_general (obj, type, sizes, dims)\n+    class(base_pde_object), allocatable :: obj\n+    character(len=*)                    :: type\n+    real, dimension(:)                  :: sizes\n+    integer, dimension(:)               :: dims\n+    select case (type)\n+      case (\"cartesian 2d\")\n+        call grid_definition (obj, sizes, dims)\n+      case default\n+        write(*,*) 'Unknown grid type: ', trim (type)\n+        stop\n+    end select\n+  end subroutine grid_definition_general\n+end module define_pde_objects\n+! pde_specific --\n+!     Module holding the routines specific to the PDE that\n+!     we are solving\n+!\n+module pde_specific\n+  implicit none\n+contains\n+  real function patch (coords)\n+    real, dimension(:), intent(in) :: coords\n+    if (sum ((coords-[50.0,50.0])**2) < 40.0) then\n+      patch = 1.0\n+    else\n+      patch = 0.0\n+    endif\n+  end function patch\n+end module pde_specific\n+! test_pde_solver --\n+!     Small test program to demonstrate the usage\n+!\n+program test_pde_solver\n+  use define_pde_objects\n+  use pde_specific\n+  implicit none\n+  class(base_pde_object), allocatable :: solution, deriv\n+  integer                             :: i\n+  real                                :: time, dtime, diff, chksum(2)\n+\n+  call simulation1     ! Use proc pointers for source and process define_pde_objects\n+  select type (solution)\n+    type is (cartesian_2d_object)\n+      deallocate (solution%c)\n+  end select\n+  select type (deriv)\n+    type is (cartesian_2d_object)\n+      deallocate (deriv%c)\n+  end select\n+  deallocate (solution, deriv)\n+\n+  call simulation2     ! Use typebound procedures for source and process\n+  if (chksum(1) .ne. chksum(2)) call abort\n+  if ((chksum(1) - 0.881868720)**2 > 1e-4) call abort\n+contains\n+  subroutine simulation1\n+!\n+! Create the grid\n+!\n+    call grid_definition (solution, \"cartesian 2d\", [100.0, 100.0], [16, 16])\n+    call grid_definition (deriv,    \"cartesian 2d\", [100.0, 100.0], [16, 16])\n+!\n+! Initialise the concentration field\n+!\n+    call solution%initialise (patch)\n+!\n+! Set the procedure pointers\n+!\n+    solution%source_p => source_cart2d_p\n+    solution%process_p => process_cart2d_p\n+!\n+! Perform the integration - explicit method\n+!\n+    time  = 0.0\n+    dtime = 0.1\n+    diff =  5.0e-3\n+\n+! Give the diffusion coefficient correct dimensions.\n+    select type (solution)\n+      type is (cartesian_2d_object)\n+        diff  = diff * solution%dx * solution%dy / dtime\n+    end select\n+\n+!     write(*,*) 'Time: ', time, diff\n+!     call solution%print\n+    do i = 1,100\n+      deriv    =  solution%nabla2 ()\n+      solution = solution + diff * dtime * deriv + solution%source_p (time) + solution%process_p ()\n+!         if ( mod(i, 25) == 0 ) then\n+!             write(*,*)'Time: ', time\n+!             call solution%print\n+!         endif\n+    time = time + dtime\n+    enddo\n+!    write(*,*) 'End result 1: '\n+!    call solution%print\n+    select type (solution)\n+      type is (cartesian_2d_object)\n+        chksum(1) = sum (solution%c)\n+    end select\n+  end subroutine\n+  subroutine simulation2\n+!\n+! Create the grid\n+!\n+    call grid_definition (solution, \"cartesian 2d\", [100.0, 100.0], [16, 16])\n+    call grid_definition (deriv,    \"cartesian 2d\", [100.0, 100.0], [16, 16])\n+!\n+! Initialise the concentration field\n+!\n+    call solution%initialise (patch)\n+!\n+! Set the procedure pointers\n+!\n+    solution%source_p => source_cart2d_p\n+    solution%process_p => process_cart2d_p\n+!\n+! Perform the integration - explicit method\n+!\n+    time  = 0.0\n+    dtime = 0.1\n+    diff =  5.0e-3\n+\n+! Give the diffusion coefficient correct dimensions.\n+    select type (solution)\n+      type is (cartesian_2d_object)\n+        diff  = diff * solution%dx * solution%dy / dtime\n+    end select\n+\n+!     write(*,*) 'Time: ', time, diff\n+!     call solution%print\n+    do i = 1,100\n+      deriv    =  solution%nabla2 ()\n+      solution = solution + diff * dtime * deriv + solution%source (time) + solution%process ()\n+!         if ( mod(i, 25) == 0 ) then\n+!             write(*,*)'Time: ', time\n+!             call solution%print\n+!         endif\n+      time = time + dtime\n+    enddo\n+!    write(*,*) 'End result 2: '\n+!    call solution%print\n+    select type (solution)\n+      type is (cartesian_2d_object)\n+        chksum(2) = sum (solution%c)\n+    end select\n+  end subroutine\n+end program test_pde_solver\n+! { dg-final { cleanup-modules \"pde_specific define_pde_objects cartesian_2d_objects base_pde_objects\" } }"}]}