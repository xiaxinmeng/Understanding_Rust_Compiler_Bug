{"sha": "8660aaae7a1320536235fcb7b867a1fa1c76c9aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY2MGFhYWU3YTEzMjA1MzYyMzVmY2I3Yjg2N2ExZmExYzc2YzlhYQ==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@apple.com", "date": "2007-09-14T00:06:00Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2007-09-14T00:06:00Z"}, "message": "dse.c (find_shift_sequence): New function.\n\n2007-09-13  Eric Christopher  <echristo@apple.com>\n\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* dse.c (find_shift_sequence): New function.\n\t(replace_read): Add case to remove read if it requires shift.\n\t* config/i386/i386.c (ix86_expand_prologue): Fixed typo in comment.\n\t\n\n\nCo-Authored-By: Kenneth Zadeck <zadeck@naturalbridge.com>\n\nFrom-SVN: r128481", "tree": {"sha": "cc38c4b48945a34b4bb6c69e482e23494c7f086e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc38c4b48945a34b4bb6c69e482e23494c7f086e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8660aaae7a1320536235fcb7b867a1fa1c76c9aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8660aaae7a1320536235fcb7b867a1fa1c76c9aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8660aaae7a1320536235fcb7b867a1fa1c76c9aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8660aaae7a1320536235fcb7b867a1fa1c76c9aa/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a"}], "stats": {"total": 298, "additions": 240, "deletions": 58}, "files": [{"sha": "666d43e2e9a0676010dd76d3f0dd5f0b752ff74c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8660aaae7a1320536235fcb7b867a1fa1c76c9aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8660aaae7a1320536235fcb7b867a1fa1c76c9aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8660aaae7a1320536235fcb7b867a1fa1c76c9aa", "patch": "@@ -1,3 +1,10 @@\n+2007-09-13  Eric Christopher  <echristo@apple.com>\n+\t    Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* dse.c (find_shift_sequence): New function.\n+\t(replace_read): Add case to remove read if it requires shift.\n+\t* config/i386/i386.c (ix86_expand_prologue): Fixed typo in comment.\n+\t\n 2007-09-13  Tom Tromey  <tromey@redhat.com>\n \n \t* c-common.c (fname_as_string): Update."}, {"sha": "0d46436c23957c8e8748115645dc33112e7ca064", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8660aaae7a1320536235fcb7b867a1fa1c76c9aa/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8660aaae7a1320536235fcb7b867a1fa1c76c9aa/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8660aaae7a1320536235fcb7b867a1fa1c76c9aa", "patch": "@@ -6384,7 +6384,7 @@ ix86_expand_prologue (void)\n         insn = emit_insn (gen_set_got (pic_offset_table_rtx));\n     }\n \n-  /* Prevent function calls from be scheduled before the call to mcount.\n+  /* Prevent function calls from being scheduled before the call to mcount.\n      In the pic_reg_used case, make sure that the got load isn't deleted.  */\n   if (current_function_profile)\n     {"}, {"sha": "e04e7e820ad93af759c1f2edb0a30f308493cab6", "filename": "gcc/dse.c", "status": "modified", "additions": 232, "deletions": 57, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8660aaae7a1320536235fcb7b867a1fa1c76c9aa/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8660aaae7a1320536235fcb7b867a1fa1c76c9aa/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=8660aaae7a1320536235fcb7b867a1fa1c76c9aa", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"recog.h\"\n #include \"dse.h\"\n+#include \"optabs.h\"\n #include \"dbgcnt.h\"\n \n /* This file contains three techniques for performing Dead Store\n@@ -1381,6 +1382,112 @@ dump_insn_info (const char * start, insn_info_t insn_info)\n }\n \n \n+/* If the modes are different and the value's source and target do not\n+   line up, we need to extract the value from lower part of the rhs of\n+   the store, shift it, and then put it into a form that can be shoved\n+   into the read_insn.  This function generates a right SHIFT of a\n+   value that is at least ACCESS_SIZE bytes wide of READ_MODE.  The\n+   shift sequence is returned or NULL if we failed to find a\n+   shift.  */\n+\n+static rtx\n+find_shift_sequence (rtx read_reg,\n+\t\t     int access_size,\n+\t\t     store_info_t store_info,\n+\t\t     read_info_t read_info,\n+\t\t     int shift)\n+{\n+  enum machine_mode store_mode = GET_MODE (store_info->mem);\n+  enum machine_mode read_mode = GET_MODE (read_info->mem);\n+\n+  /* Some machines like the x86 have shift insns for each size of\n+     operand.  Other machines like the ppc or the ia-64 may only have\n+     shift insns that shift values within 32 or 64 bit registers.\n+     This loop tries to find the smallest shift insn that will right\n+     justify the value we want to read but is available in one insn on\n+     the machine.  */\n+\n+  while (access_size < UNITS_PER_WORD)\n+    {\n+      rtx target;\n+      enum machine_mode new_mode\n+\t= smallest_mode_for_size (access_size * BITS_PER_UNIT,\n+\t\t\t\t  GET_MODE_CLASS (read_mode));\n+      rtx new_reg = gen_reg_rtx (new_mode);\n+\n+      start_sequence ();\n+\n+      /* In theory we could also check for an ashr.  Ian Taylor knows\n+\t of one dsp where the cost of these two was not the same.  But\n+\t this really is a rare case anyway.  */\n+      target = expand_binop (new_mode, lshr_optab, new_reg,\n+\t\t\t     GEN_INT (shift), new_reg, 1, OPTAB_DIRECT);\n+\n+      if (target == new_reg)\n+\t{\n+\t  rtx shift_seq = get_insns ();\n+\t  end_sequence ();\n+\n+\t  /* If cost is too great, set target to NULL and\n+\t     let the iteration happen. */\n+\t  if (shift_seq != NULL)\n+\t    {\n+\t      int cost = 0;\n+\t      rtx insn;\n+\n+\t      for (insn = shift_seq; insn != NULL_RTX; insn = NEXT_INSN (insn))\n+\t\tcost += insn_rtx_cost (insn);\n+\n+\t      /* The computation up to here is essentially independent\n+\t\t of the arguments and could be precomputed.  It may\n+\t\t not be worth doing so.  We could precompute if\n+\t\t worthwhile or at least cache the results.  The result\n+\t\t technically depends on SHIFT, ACCESS_SIZE, and\n+\t\t GET_MODE_CLASS (READ_MODE).  But in practice the\n+\t\t answer will depend only on ACCESS_SIZE.  */\n+\n+\t      if (cost <= COSTS_N_INSNS (1))\n+\t\t{\n+\t\t  /* We found an acceptable shift.  Generate a move to\n+\t\t     take the value from the store and put it into the\n+\t\t     shift pseudo, then shift it, then generate another\n+\t\t     move to put in into the target of the read.  */\n+\t\t  start_sequence ();\n+\t\t  emit_move_insn (new_reg, gen_lowpart (new_mode, store_info->rhs));\n+\t\t  emit_insn (shift_seq);\n+\t\t  emit_move_insn (read_reg,  gen_lowpart (read_mode, new_reg));\n+\t\t  \n+\t\t  if (dump_file)\n+\t\t    {\n+\t\t      fprintf (dump_file, \" -- adding extract insn r%d:%s = r%d:%s\\n\",\n+\t\t\t       REGNO (new_reg), GET_MODE_NAME (new_mode),\n+\t\t\t       REGNO (store_info->rhs), GET_MODE_NAME (store_mode));\n+\t\t      \n+\t\t      fprintf (dump_file, \" -- with shift of r%d by %d\\n\",\n+\t\t\t       REGNO(new_reg), shift);\n+\t\t      fprintf (dump_file, \" -- and second extract insn r%d:%s = r%d:%s\\n\",\n+\t\t\t       REGNO (read_reg), GET_MODE_NAME (read_mode),\n+\t\t\t       REGNO (new_reg), GET_MODE_NAME (new_mode));\n+\t\t    }\n+\t\t  \n+\t\t  /* Get the three insn sequence and return it.  */\n+\t\t  shift_seq = get_insns ();\n+\t\t  end_sequence ();\n+\t\t  return shift_seq;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t/* End the sequence.  */\n+\tend_sequence ();\n+\n+      access_size = access_size * 2;\n+    }\n+\n+  return NULL;\n+}\n+\n+\n /* Take a sequence of:\n      A <- r1\n      ...\n@@ -1392,90 +1499,159 @@ dump_insn_info (const char * start, insn_info_t insn_info)\n    ...\n    ... <- r2\n \n-   The STORE_INFO and STORE_INFO are for the store and the READ_INFO\n+   or\n+\n+   r3 <- extract (r1)\n+   r3 <- r3 >> shift\n+   r2 <- extract (r3)\n+   ... <- r2\n+\n+   or\n+\n+   r2 <- extract (r1)\n+   ... <- r2\n+\n+   Depending on the alignment and the mode of the store and\n+   subsequent load.\n+\n+\n+   The STORE_INFO and STORE_INSN are for the store and READ_INFO\n    and READ_INSN are for the read.  Return true if the replacement\n    went ok.  */\n \n static bool\n replace_read (store_info_t store_info, insn_info_t store_insn, \n \t      read_info_t read_info, insn_info_t read_insn, rtx *loc)\n {\n+  enum machine_mode store_mode = GET_MODE (store_info->mem);\n+  enum machine_mode read_mode = GET_MODE (read_info->mem);\n+  int shift;\n+  int access_size; /* In bytes.  */\n+  rtx read_reg = gen_reg_rtx (read_mode);\n+  rtx shift_seq = NULL;\n+\n   if (!dbg_cnt (dse))\n     return false;\n \n+  if (GET_MODE_CLASS (read_mode) != GET_MODE_CLASS (store_mode))\n+    return false;\n+\n+  /* To get here the read is within the boundaries of the write so\n+     shift will never be negative.  Start out with the shift being in\n+     bytes.  */\n+  if (BYTES_BIG_ENDIAN)\n+    shift = store_info->end - read_info->end;\n+  else\n+    shift = read_info->begin - store_info->begin;\n+\n+  access_size = shift + GET_MODE_SIZE (read_mode);\n+\n+  /* From now on it is bits.  */\n+  shift *= BITS_PER_UNIT;\n+\n+  /* We need to keep this in perspective.  We are replacing a read\n+     with a sequence of insns, but the read will almost certainly be\n+     in cache, so it is not going to be an expensive one.  Thus, we\n+     are not willing to do a multi insn shift or worse a subroutine\n+     call to get rid of the read.  */\n+  if (shift)\n+    {\n+      if (access_size > UNITS_PER_WORD || FLOAT_MODE_P (store_mode))\n+\treturn false;\n+\n+      shift_seq = find_shift_sequence (read_reg, access_size, store_info,\n+\t\t\t\t       read_info, shift);\n+      if (!shift_seq)\n+\treturn false;\n+    }\n+\n   if (dump_file)\n-    fprintf (dump_file, \"generating move to replace load at %d from store at %d\\n\", \n+    fprintf (dump_file, \"replacing load at %d from store at %d\\n\",\n \t     INSN_UID (read_insn->insn), INSN_UID (store_insn->insn)); \n-  if (GET_MODE (store_info->mem) == GET_MODE (read_info->mem))\n+\n+  if (validate_change (read_insn->insn, loc, read_reg, 0))\n     {\n-      rtx new_reg = gen_reg_rtx (GET_MODE (store_info->mem));\n-      if (validate_change (read_insn->insn, loc, new_reg, 0))\n+      rtx insns;\n+      deferred_change_t deferred_change = pool_alloc (deferred_change_pool);\n+      \n+      if (read_mode == store_mode)\n \t{\n-\t  rtx insns;\n-\t  deferred_change_t deferred_change = pool_alloc (deferred_change_pool);\n-\n \t  start_sequence ();\n-\t  emit_move_insn (new_reg, store_info->rhs);\n+\t  \n+\t  /* The modes are the same and everything lines up.  Just\n+\t     generate a simple move.  */\n+\t  emit_move_insn (read_reg, store_info->rhs);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \" -- adding move insn r%d = r%d\\n\",\n+\t\t     REGNO (read_reg), REGNO (store_info->rhs));\n \t  insns = get_insns ();\n \t  end_sequence ();\n-\t  emit_insn_before (insns, store_insn->insn);\n-\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \" -- adding move insn %d: r%d = r%d\\n\", \n-\t\t     INSN_UID (insns), REGNO (new_reg), REGNO (store_info->rhs)); \n-\n-\t  /* And now for the cludge part: cselib croaks if you just\n-\t     return at this point.  There are two reasons for this:\n-\n-\t     1) Cselib has an idea of how many pseudos there are and\n-\t     that does not include the new one we just added.  \n-\n-\t     2) Cselib does not know about the move insn we added\n-\t     above the store_info, and there is no way to tell it\n-\t     about it, because it has \"moved on\".\n-\n-\t     So we are just going to have to lie.  The move insn is\n-\t     not really an issue, cselib did not see it.  But the use\n-\t     of the new pseudo read_insn is a real problem.  The way\n-\t     that we solve this problem is that we are just going to\n-\t     put the mem back keep a table of mems to get rid of.  At\n-\t     the end of the basic block we can put it back.  */\n-\n-\t  *loc = read_info->mem;\n-\t  deferred_change->next = deferred_change_list;\n-\t  deferred_change_list = deferred_change;\n-\t  deferred_change->loc = loc;\n-\t  deferred_change->reg = new_reg;\n-\n-\t  /* Get rid of the read_info, from the point of view of the\n-\t     rest of dse, play like this read never happened.  */\n-\t  read_insn->read_rec = read_info->next;\n-\t  pool_free (read_info_pool, read_info);\n-\t  return true;\n \t}\n-      else \n+      else if (shift)\n+\tinsns = shift_seq;\n+      else\n \t{\n+\t  /* The modes are different but the lsb are in the same\n+\t     place, we need to extract the value in the right from the\n+\t     rhs of the store.  */\n+\t  start_sequence ();\n+\t  emit_move_insn (read_reg, gen_lowpart (read_mode, store_info->rhs));\n+\t  \n \t  if (dump_file)\n-\t    fprintf (dump_file, \" -- validation failure\\n\"); \n-\t  return false;\n+\t    fprintf (dump_file, \" -- adding extract insn r%d:%s = r%d:%s\\n\",\n+\t\t     REGNO (read_reg), GET_MODE_NAME (read_mode),\n+\t\t     REGNO (store_info->rhs), GET_MODE_NAME (store_mode));\n+\t  insns = get_insns ();\n+\t  end_sequence ();\n \t}\n+\n+      /* Insert this right before the store insn where it will be safe\n+\t from later insns that might change it before the read.  */\n+      emit_insn_before (insns, store_insn->insn);\n+      \n+      /* And now for the kludge part: cselib croaks if you just\n+\t return at this point.  There are two reasons for this:\n+\t \n+\t 1) Cselib has an idea of how many pseudos there are and\n+\t that does not include the new ones we just added.\n+\t \n+\t 2) Cselib does not know about the move insn we added\n+\t above the store_info, and there is no way to tell it\n+\t about it, because it has \"moved on\".\n+\t \n+\t Problem (1) is fixable with a certain amount of engineering.\n+\t Problem (2) is requires starting the bb from scratch.  This\n+\t could be expensive.\n+\t \n+\t So we are just going to have to lie.  The move/extraction\n+\t insns are not really an issue, cselib did not see them.  But\n+\t the use of the new pseudo read_insn is a real problem because\n+\t cselib has not scanned this insn.  The way that we solve this\n+\t problem is that we are just going to put the mem back for now\n+\t and when we are finished with the block, we undo this.  We\n+\t keep a table of mems to get rid of.  At the end of the basic\n+\t block we can put them back.  */\n+      \n+      *loc = read_info->mem;\n+      deferred_change->next = deferred_change_list;\n+      deferred_change_list = deferred_change;\n+      deferred_change->loc = loc;\n+      deferred_change->reg = read_reg;\n+      \n+      /* Get rid of the read_info, from the point of view of the\n+\t rest of dse, play like this read never happened.  */\n+      read_insn->read_rec = read_info->next;\n+      pool_free (read_info_pool, read_info);\n+      return true;\n     }\n-  else\n+  else \n     {\n-      /* Someone with excellent rtl skills needs to fill this in.  You\n-\t are guaranteed that the read is of the same size or smaller\n-\t than the store, and that the read does not hang off one of\n-\t the ends of the store.  But the offsets of each must be\n-\t checked because the read does not have to line up on either\n-\t end of the store so the begin fields need to be examined in\n-\t both the store_info and read_info.  */\n       if (dump_file)\n-\tfprintf (dump_file, \" -- complex load, currently unsupported.\\n\"); \n+\tfprintf (dump_file, \" -- validation failure\\n\"); \n       return false;\n     }\n }\n \n-\n /* A for_each_rtx callback in which DATA is the bb_info.  Check to see\n    if LOC is a mem and if it is look at the address and kill any\n    appropriate stores that may be active.  */\n@@ -3105,4 +3281,3 @@ struct tree_opt_pass pass_rtl_dse2 =\n   TODO_ggc_collect,                     /* todo_flags_finish */\n   'w'                                   /* letter */\n };\n-"}]}