{"sha": "77a02b01f2a187724b84c45ef51915fc5011f8c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdhMDJiMDFmMmExODc3MjRiODRjNDVlZjUxOTE1ZmM1MDExZjhjNQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-06-03T20:40:18Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-06-03T20:40:18Z"}, "message": "entered into RCS\n\nFrom-SVN: r1150", "tree": {"sha": "f98a3d93c81c85e60764d62d3b34bbb8233495ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f98a3d93c81c85e60764d62d3b34bbb8233495ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77a02b01f2a187724b84c45ef51915fc5011f8c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77a02b01f2a187724b84c45ef51915fc5011f8c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77a02b01f2a187724b84c45ef51915fc5011f8c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77a02b01f2a187724b84c45ef51915fc5011f8c5/comments", "author": null, "committer": null, "parents": [{"sha": "12f7c8764c9f91c3fe74bd4f5c4f644583fb913f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f7c8764c9f91c3fe74bd4f5c4f644583fb913f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f7c8764c9f91c3fe74bd4f5c4f644583fb913f"}], "stats": {"total": 223, "additions": 205, "deletions": 18}, "files": [{"sha": "0e2546e51e94709d591caee0930dd85c81cc96e8", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a02b01f2a187724b84c45ef51915fc5011f8c5/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a02b01f2a187724b84c45ef51915fc5011f8c5/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=77a02b01f2a187724b84c45ef51915fc5011f8c5", "patch": "@@ -965,7 +965,7 @@ i960_function_prologue (file, size)\n   register int i, j, nr;\n   int n_iregs = 0;\n   int rsize = 0;\n-  int actual_fsize;\n+  int actual_fsize, offset;\n   char tmpstr[1000];\n   /* -1 if reg must be saved on proc entry, 0 if available, 1 if saved\n      somewhere.  */\n@@ -1051,7 +1051,12 @@ i960_function_prologue (file, size)\n #if 0\n   /* ??? The 1.2.1 compiler does this also.  This is meant to round the frame\n      size up to the nearest multiple of 16.  I don't know whether this is\n-     necessary, or even desirable.  */\n+     necessary, or even desirable.\n+\n+     The frame pointer must be aligned, but the call instruction takes care of\n+     that.  If we leave the stack pointer unaligned, we may save a little on\n+     dynamic stack allocation.  And we don't lose, at least according to the\n+     i960CA manual.  */\n   actual_fsize = (actual_fsize + 15) & ~0xF;\n #endif\n \n@@ -1063,7 +1068,10 @@ i960_function_prologue (file, size)\n       else\n \tfprintf (file, \"\\tlda\\t%d(sp),sp\\n\", actual_fsize);\n     }\n-  \n+\n+  /* Take hardware register save area created by the call instruction\n+     into account.  */\n+  offset = compute_frame_size (size) + 64;\n   /* Save registers on stack if needed.  */\n   for (i = 0, j = n_iregs; j > 0 && i < 16; i++)\n     {\n@@ -1072,10 +1080,11 @@ i960_function_prologue (file, size)\n \n       nr = 1;\n \n-      if (i <= 14 && i % 2 == 0 && regs[i+1] == -1)\n+      if (i <= 14 && i % 2 == 0 && regs[i+1] == -1 && offset % 2 == 0)\n \tnr = 2;\n \n-      if (nr == 2 && i <= 12 && i % 4 == 0 && regs[i+2] == -1)\n+      if (nr == 2 && i <= 12 && i % 4 == 0 && regs[i+2] == -1\n+\t  && offset % 4 == 0)\n \tnr = 3;\n \n       if (nr == 3 && regs[i+3] == -1)\n@@ -1085,15 +1094,16 @@ i960_function_prologue (file, size)\n \t       ((nr == 4) ? \"q\" :\n \t\t(nr == 3) ? \"t\" :\n \t\t(nr == 2) ? \"l\" : \"\"),\n-\t       reg_names[i], size+(nr*4));\n+\t       reg_names[i], offset);\n       sprintf (tmpstr,\"\\tld%s\t%d(fp),%s\\n\",\n \t       ((nr == 4) ? \"q\" :\n \t\t(nr == 3) ? \"t\" :\n \t\t(nr == 2) ? \"l\" : \"\"),\n-\t       size+(nr*4), reg_names[i]);\n+\t       offset, reg_names[i]);\n       strcat (epilogue_string, tmpstr);\n       i += nr-1;\n       j -= nr;\n+      offset += nr * 4;\n     }\n \n   if (actual_fsize == 0 && size == 0 && rsize == 0)"}, {"sha": "080936a8dc21b18df07bce3591efbd0b6cb19100", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 101, "deletions": 9, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a02b01f2a187724b84c45ef51915fc5011f8c5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a02b01f2a187724b84c45ef51915fc5011f8c5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=77a02b01f2a187724b84c45ef51915fc5011f8c5", "patch": "@@ -2749,7 +2749,7 @@ print_operand (file, x, code)\n       return;\n     case 'r':\n       /* In this case we need a register.  Use %g0 if the\n-\t operand in const0_rtx.  */\n+\t operand is const0_rtx.  */\n       if (x == const0_rtx)\n \t{\n \t  fputs (\"%g0\", file);\n@@ -2872,8 +2872,37 @@ output_double_int (file, value)\n     abort ();\n }\n \f\n-/* Compute the code to put in the .proc statement\n-   for a function that returns type TYPE.  */\n+#ifndef CHAR_TYPE_SIZE\n+#define CHAR_TYPE_SIZE BITS_PER_UNIT\n+#endif\n+\n+#ifndef SHORT_TYPE_SIZE\n+#define SHORT_TYPE_SIZE (BITS_PER_UNIT * 2)\n+#endif\n+\n+#ifndef INT_TYPE_SIZE\n+#define INT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef LONG_LONG_TYPE_SIZE\n+#define LONG_LONG_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n+#ifndef FLOAT_TYPE_SIZE\n+#define FLOAT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef DOUBLE_TYPE_SIZE\n+#define DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n+#ifndef LONG_DOUBLE_TYPE_SIZE\n+#define LONG_DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n \n unsigned long\n sparc_type_code (type)\n@@ -2923,16 +2952,79 @@ sparc_type_code (type)\n \t  return (qualifiers | 16);\n \n \tcase INTEGER_TYPE:\n-        /* This return value is not always completely the same as Sun's\n-           but the Sun assembler's peephole optimizer probably doesn't\n-           care.  */\n-        return (qualifiers | 4);\n+\t  /* Carefully distinguish all the standard types of C,\n+\t     without messing up if the language is not C.\n+\t     Note that we check only for the names that contain spaces;\n+\t     other names might occur by coincidence in other languages.  */\n+\t  if (TYPE_NAME (type) != 0\n+\t      && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t      && DECL_NAME (TYPE_NAME (type)) != 0\n+\t      && TREE_CODE (DECL_NAME (TYPE_NAME (type))) == IDENTIFIER_NODE)\n+\t    {\n+\t      char *name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n+  \n+\t      if (!strcmp (name, \"unsigned char\"))\n+\t\treturn (qualifiers | 12);\n+\t      if (!strcmp (name, \"signed char\"))\n+\t\treturn (qualifiers | 2);\n+\t      if (!strcmp (name, \"unsigned int\"))\n+\t\treturn (qualifiers | 14);\n+\t      if (!strcmp (name, \"short int\"))\n+\t\treturn (qualifiers | 3);\n+\t      if (!strcmp (name, \"short unsigned int\"))\n+\t\treturn (qualifiers | 13);\n+\t      if (!strcmp (name, \"long int\"))\n+\t\treturn (qualifiers | 5);\n+\t      if (!strcmp (name, \"long unsigned int\"))\n+\t\treturn (qualifiers | 15);\n+\t      if (!strcmp (name, \"long long int\"))\n+\t\treturn (qualifiers | 5);\t/* Who knows? */\n+\t      if (!strcmp (name, \"long long unsigned int\"))\n+\t\treturn (qualifiers | 15);\t/* Who knows? */\n+\t    }\n+  \n+\t  /* Most integer types will be sorted out above, however, for the\n+\t     sake of special `array index' integer types, the following code\n+\t     is also provided.  */\n+  \n+\t  if (TYPE_PRECISION (type) == INT_TYPE_SIZE)\n+\t    return (qualifiers | (TREE_UNSIGNED (type) ? 14 : 4));\n+  \n+\t  if (TYPE_PRECISION (type) == LONG_TYPE_SIZE)\n+\t    return (qualifiers | (TREE_UNSIGNED (type) ? 15 : 5));\n+  \n+\t  if (TYPE_PRECISION (type) == LONG_LONG_TYPE_SIZE)\n+\t    return (qualifiers | (TREE_UNSIGNED (type) ? 15 : 5));\n+  \n+\t  if (TYPE_PRECISION (type) == SHORT_TYPE_SIZE)\n+\t    return (qualifiers | (TREE_UNSIGNED (type) ? 13 : 3));\n+  \n+\t  if (TYPE_PRECISION (type) == CHAR_TYPE_SIZE)\n+\t    return (qualifiers | (TREE_UNSIGNED (type) ? 12 : 2));\n+  \n+\t  abort ();\n   \n \tcase REAL_TYPE:\n-\t  if (TYPE_PRECISION (type) == 32)\n+\t  /* Carefully distinguish all the standard types of C,\n+\t     without messing up if the language is not C.  */\n+\t  if (TYPE_NAME (type) != 0\n+\t      && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t      && DECL_NAME (TYPE_NAME (type)) != 0\n+\t      && TREE_CODE (DECL_NAME (TYPE_NAME (type))) == IDENTIFIER_NODE)\n+\t    {\n+\t      char *name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n+  \n+\t      if (!strcmp (name, \"long double\"))\n+\t\treturn (qualifiers | 7);\t/* Who knows? */\n+\t    }\n+  \n+\t  if (TYPE_PRECISION (type) == DOUBLE_TYPE_SIZE)\n+\t    return (qualifiers | 7);\n+\t  if (TYPE_PRECISION (type) == FLOAT_TYPE_SIZE)\n \t    return (qualifiers | 6);\n-\t  else\n+\t  if (TYPE_PRECISION (type) == LONG_DOUBLE_TYPE_SIZE)\n \t    return (qualifiers | 7);\t/* Who knows? */\n+\t  abort ();\n   \n \tcase COMPLEX_TYPE:\t/* GNU Fortran COMPLEX type.  */\n \tcase CHAR_TYPE:\t\t/* GNU Pascal CHAR type.  Not used in C.  */"}, {"sha": "7a5781307000c0da1761bc8507f4518988fbaed2", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a02b01f2a187724b84c45ef51915fc5011f8c5/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a02b01f2a187724b84c45ef51915fc5011f8c5/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=77a02b01f2a187724b84c45ef51915fc5011f8c5", "patch": "@@ -185,16 +185,19 @@ extern int target_flags;\n /* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 64\n \n+/* The best alignment to use in cases where we have a choice.  */\n+#define FASTEST_ALIGNMENT 64\n+\n /* Make strings word-aligned so strcpy from constants will be faster.  */\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n   (TREE_CODE (EXP) == STRING_CST\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n \n /* Make arrays of chars word-aligned for the same reasons.  */\n #define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n   (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n    && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n \n /* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */"}, {"sha": "3643efec1810f3de04b09903947dc4e412450f24", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77a02b01f2a187724b84c45ef51915fc5011f8c5/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77a02b01f2a187724b84c45ef51915fc5011f8c5/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=77a02b01f2a187724b84c45ef51915fc5011f8c5", "patch": "@@ -1845,6 +1845,88 @@\n   \"\"\n   \"subcc %1,%2,%0\")\n \n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"smul %1,%2,%0\")\n+\n+;; It is not known whether this will match.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mult:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))\n+   (set (reg:CC_NOOV 0)\n+\t(compare:CC_NOOV (mult:SI (match_dup 1) (match_dup 2))\n+\t\t\t (const_int 0)))]\n+  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"smulcc %1,%2,%0\")\n+\n+(define_insn \"mulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"arith_operand\" \"%r\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n+  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"smul %1,%2,%R0\\;rd %y,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"umulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"arith_operand\" \"%r\"))\n+\t\t (zero_extend:DI (match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n+  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"umul %1,%2,%R0\\;rd %y,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+;; The architecture specifies that there must be 3 instructions between\n+;; a y register write and a use of it for correct results.\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"TARGET_V8\"\n+  \"sra %1,31,%3\\;wr %%g0,%3,%%y\\;nop\\;nop\\;nop\\;sdiv %1,%2,%0\"\n+  [(set_attr \"length\" \"3\")])\n+\n+;; It is not known whether this will match.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))\n+   (set (reg:CC 0)\n+\t(compare:CC (div:SI (match_dup 1) (match_dup 2))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"TARGET_V8\"\n+  \"sra %1,31,%3\\;wr %%g0,%3,%%y\\;nop\\;nop\\;nop\\;sdivcc %1,%2,%0\"\n+  [(set_attr \"length\" \"3\")])\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"TARGET_V8\"\n+  \"wr %%g0,%%g0,%%y\\;nop\\;nop\\;nop\\;udiv %1,%2,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n+;; It is not known whether this will match.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))\n+   (set (reg:CC 0)\n+\t(compare:CC (udiv:SI (match_dup 1) (match_dup 2))\n+\t\t    (const_int 0)))]\n+  \"TARGET_V8\"\n+  \"wr %%g0,%%g0,%%y\\;nop\\;nop\\;nop\\;udivcc %1,%2,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n ;;- and instructions\n ;; We define DImode `and` so with DImode `not` we can get\n ;; DImode `andn`.  Other combinations are possible."}]}