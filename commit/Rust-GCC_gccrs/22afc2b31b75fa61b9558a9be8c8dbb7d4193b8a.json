{"sha": "22afc2b31b75fa61b9558a9be8c8dbb7d4193b8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJhZmMyYjMxYjc1ZmE2MWI5NTU4YTliZThjOGRiYjdkNDE5M2I4YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:16:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:16:53Z"}, "message": "poly_int: tree-vect-generic.c\n\nThis patch makes tree-vect-generic.c cope with variable-length vectors.\nDecomposition is only supported for constant-length vectors, since we\nshould never generate unsupported variable-length operations.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vect-generic.c (nunits_for_known_piecewise_op): New function.\n\t(expand_vector_piecewise): Use it instead of TYPE_VECTOR_SUBPARTS.\n\t(expand_vector_addition, add_rshift, expand_vector_divmod): Likewise.\n\t(expand_vector_condition, vector_element): Likewise.\n\t(subparts_gt): New function.\n\t(get_compute_type): Use subparts_gt.\n\t(count_type_subparts): Delete.\n\t(expand_vector_operations_1): Use subparts_gt instead of\n\tcount_type_subparts.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256143", "tree": {"sha": "0b189771ad60bc0f5069ef36328f3b9926bc9177", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b189771ad60bc0f5069ef36328f3b9926bc9177"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22afc2b31b75fa61b9558a9be8c8dbb7d4193b8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22afc2b31b75fa61b9558a9be8c8dbb7d4193b8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22afc2b31b75fa61b9558a9be8c8dbb7d4193b8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22afc2b31b75fa61b9558a9be8c8dbb7d4193b8a/comments", "author": null, "committer": null, "parents": [{"sha": "b064d4f9d6cb163da32d19cb172cbc4a5fffb39a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b064d4f9d6cb163da32d19cb172cbc4a5fffb39a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b064d4f9d6cb163da32d19cb172cbc4a5fffb39a"}], "stats": {"total": 73, "additions": 46, "deletions": 27}, "files": [{"sha": "e77cbb5deae85f630b7377434632acbfbe1e1cb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22afc2b31b75fa61b9558a9be8c8dbb7d4193b8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22afc2b31b75fa61b9558a9be8c8dbb7d4193b8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22afc2b31b75fa61b9558a9be8c8dbb7d4193b8a", "patch": "@@ -1,3 +1,17 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vect-generic.c (nunits_for_known_piecewise_op): New function.\n+\t(expand_vector_piecewise): Use it instead of TYPE_VECTOR_SUBPARTS.\n+\t(expand_vector_addition, add_rshift, expand_vector_divmod): Likewise.\n+\t(expand_vector_condition, vector_element): Likewise.\n+\t(subparts_gt): New function.\n+\t(get_compute_type): Use subparts_gt.\n+\t(count_type_subparts): Delete.\n+\t(expand_vector_operations_1): Use subparts_gt instead of\n+\tcount_type_subparts.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "27d03a7262fac90993fe61e44dd6ba882a37fbe4", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22afc2b31b75fa61b9558a9be8c8dbb7d4193b8a/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22afc2b31b75fa61b9558a9be8c8dbb7d4193b8a/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=22afc2b31b75fa61b9558a9be8c8dbb7d4193b8a", "patch": "@@ -43,6 +43,26 @@ along with GCC; see the file COPYING3.  If not see\n \n static void expand_vector_operations_1 (gimple_stmt_iterator *);\n \n+/* Return the number of elements in a vector type TYPE that we have\n+   already decided needs to be expanded piecewise.  We don't support\n+   this kind of expansion for variable-length vectors, since we should\n+   always check for target support before introducing uses of those.  */\n+static unsigned int\n+nunits_for_known_piecewise_op (const_tree type)\n+{\n+  return TYPE_VECTOR_SUBPARTS (type);\n+}\n+\n+/* Return true if TYPE1 has more elements than TYPE2, where either\n+   type may be a vector or a scalar.  */\n+\n+static inline bool\n+subparts_gt (tree type1, tree type2)\n+{\n+  poly_uint64 n1 = VECTOR_TYPE_P (type1) ? TYPE_VECTOR_SUBPARTS (type1) : 1;\n+  poly_uint64 n2 = VECTOR_TYPE_P (type2) ? TYPE_VECTOR_SUBPARTS (type2) : 1;\n+  return known_gt (n1, n2);\n+}\n \n /* Build a constant of type TYPE, made of VALUE's bits replicated\n    every TYPE_SIZE (INNER_TYPE) bits to fit TYPE's precision.  */\n@@ -256,7 +276,7 @@ expand_vector_piecewise (gimple_stmt_iterator *gsi, elem_op_func f,\n   vec<constructor_elt, va_gc> *v;\n   tree part_width = TYPE_SIZE (inner_type);\n   tree index = bitsize_int (0);\n-  int nunits = TYPE_VECTOR_SUBPARTS (type);\n+  int nunits = nunits_for_known_piecewise_op (type);\n   int delta = tree_to_uhwi (part_width)\n \t      / tree_to_uhwi (TYPE_SIZE (TREE_TYPE (type)));\n   int i;\n@@ -340,7 +360,7 @@ expand_vector_addition (gimple_stmt_iterator *gsi,\n \n   if (INTEGRAL_TYPE_P (TREE_TYPE (type))\n       && parts_per_word >= 4\n-      && TYPE_VECTOR_SUBPARTS (type) >= 4)\n+      && nunits_for_known_piecewise_op (type) >= 4)\n     return expand_vector_parallel (gsi, f_parallel,\n \t\t\t\t   type, a, b, code);\n   else\n@@ -375,7 +395,7 @@ static tree\n add_rshift (gimple_stmt_iterator *gsi, tree type, tree op0, int *shiftcnts)\n {\n   optab op;\n-  unsigned int i, nunits = TYPE_VECTOR_SUBPARTS (type);\n+  unsigned int i, nunits = nunits_for_known_piecewise_op (type);\n   bool scalar_shift = true;\n \n   for (i = 1; i < nunits; i++)\n@@ -419,7 +439,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n   bool has_vector_shift = true;\n   int mode = -1, this_mode;\n   int pre_shift = -1, post_shift;\n-  unsigned int nunits = TYPE_VECTOR_SUBPARTS (type);\n+  unsigned int nunits = nunits_for_known_piecewise_op (type);\n   int *shifts = XALLOCAVEC (int, nunits * 4);\n   int *pre_shifts = shifts + nunits;\n   int *post_shifts = pre_shifts + nunits;\n@@ -868,7 +888,6 @@ expand_vector_condition (gimple_stmt_iterator *gsi)\n   tree index = bitsize_int (0);\n   tree comp_width = width;\n   tree comp_index = index;\n-  int nunits = TYPE_VECTOR_SUBPARTS (type);\n   int i;\n   location_t loc = gimple_location (gsi_stmt (*gsi));\n \n@@ -921,6 +940,7 @@ expand_vector_condition (gimple_stmt_iterator *gsi)\n   warning_at (loc, OPT_Wvector_operation_performance,\n \t      \"vector condition will be expanded piecewise\");\n \n+  int nunits = nunits_for_known_piecewise_op (type);\n   vec_alloc (v, nunits);\n   for (i = 0; i < nunits; i++)\n     {\n@@ -1190,7 +1210,7 @@ vector_element (gimple_stmt_iterator *gsi, tree vect, tree idx, tree *ptmpvec)\n \n   vect_type = TREE_TYPE (vect);\n   vect_elt_type = TREE_TYPE (vect_type);\n-  elements = TYPE_VECTOR_SUBPARTS (vect_type);\n+  elements = nunits_for_known_piecewise_op (vect_type);\n \n   if (TREE_CODE (idx) == INTEGER_CST)\n     {\n@@ -1450,8 +1470,7 @@ get_compute_type (enum tree_code code, optab op, tree type)\n       tree vector_compute_type\n \t= type_for_widest_vector_mode (TREE_TYPE (type), op);\n       if (vector_compute_type != NULL_TREE\n-\t  && (TYPE_VECTOR_SUBPARTS (vector_compute_type)\n-\t      < TYPE_VECTOR_SUBPARTS (compute_type))\n+\t  && subparts_gt (compute_type, vector_compute_type)\n \t  && TYPE_VECTOR_SUBPARTS (vector_compute_type) > 1\n \t  && (optab_handler (op, TYPE_MODE (vector_compute_type))\n \t      != CODE_FOR_nothing))\n@@ -1480,15 +1499,6 @@ get_compute_type (enum tree_code code, optab op, tree type)\n   return compute_type;\n }\n \n-/* Helper function of expand_vector_operations_1.  Return number of\n-   vector elements for vector types or 1 for other types.  */\n-\n-static inline int\n-count_type_subparts (tree type)\n-{\n-  return VECTOR_TYPE_P (type) ? TYPE_VECTOR_SUBPARTS (type) : 1;\n-}\n-\n static tree\n do_cond (gimple_stmt_iterator *gsi, tree inner_type, tree a, tree b,\n \t tree bitpos, tree bitsize, enum tree_code code,\n@@ -1708,8 +1718,7 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n \t  /* The rtl expander will expand vector/scalar as vector/vector\n \t     if necessary.  Pick one with wider vector type.  */\n \t  tree compute_vtype = get_compute_type (code, opv, type);\n-\t  if (count_type_subparts (compute_vtype)\n-\t      > count_type_subparts (compute_type))\n+\t  if (subparts_gt (compute_vtype, compute_type))\n \t    {\n \t      compute_type = compute_vtype;\n \t      op = opv;\n@@ -1739,26 +1748,22 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n \t      tree compute_rtype = get_compute_type (RSHIFT_EXPR, opr, type);\n \t      /* The rtl expander will expand vector/scalar as vector/vector\n \t\t if necessary.  Pick one with wider vector type.  */\n-\t      if (count_type_subparts (compute_lvtype)\n-\t\t  > count_type_subparts (compute_ltype))\n+\t      if (subparts_gt (compute_lvtype, compute_ltype))\n \t\t{\n \t\t  compute_ltype = compute_lvtype;\n \t\t  opl = oplv;\n \t\t}\n-\t      if (count_type_subparts (compute_rvtype)\n-\t\t  > count_type_subparts (compute_rtype))\n+\t      if (subparts_gt (compute_rvtype, compute_rtype))\n \t\t{\n \t\t  compute_rtype = compute_rvtype;\n \t\t  opr = oprv;\n \t\t}\n \t      /* Pick the narrowest type from LSHIFT_EXPR, RSHIFT_EXPR and\n \t\t BIT_IOR_EXPR.  */\n \t      compute_type = compute_ltype;\n-\t      if (count_type_subparts (compute_type)\n-\t\t  > count_type_subparts (compute_rtype))\n+\t      if (subparts_gt (compute_type, compute_rtype))\n \t\tcompute_type = compute_rtype;\n-\t      if (count_type_subparts (compute_type)\n-\t\t  > count_type_subparts (compute_otype))\n+\t      if (subparts_gt (compute_type, compute_otype))\n \t\tcompute_type = compute_otype;\n \t      /* Verify all 3 operations can be performed in that type.  */\n \t      if (compute_type != TREE_TYPE (type))"}]}