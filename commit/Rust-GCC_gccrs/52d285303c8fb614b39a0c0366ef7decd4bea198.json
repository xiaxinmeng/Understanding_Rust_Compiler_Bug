{"sha": "52d285303c8fb614b39a0c0366ef7decd4bea198", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJkMjg1MzAzYzhmYjYxNGIzOWEwYzAzNjZlZjdkZWNkNGJlYTE5OA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-01-29T14:30:45Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-01-29T14:30:45Z"}, "message": "re PR target/15184 (Direct access to byte inside word not working with -march=pentiumpro)\n\n\tPR target/15184\n\t* combine.c (try_combine): If I0 is a memory load and I3 a store\n\tto a related address, increase the \"goodness\" of doing a 4-insn\n\tcombination with I0-I3.\n\t(make_field_assignment): Handle SUBREGs in the ior+and case.\n\n\tPR target/15184\n\t* gcc.target/i386/pr15184-1.c: New test.\n\t* gcc.target/i386/pr15184-2.c: New test.\n\nFrom-SVN: r220249", "tree": {"sha": "5f77c59797bc55ba92354910fbc0f9280546b541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f77c59797bc55ba92354910fbc0f9280546b541"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52d285303c8fb614b39a0c0366ef7decd4bea198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52d285303c8fb614b39a0c0366ef7decd4bea198", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52d285303c8fb614b39a0c0366ef7decd4bea198", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52d285303c8fb614b39a0c0366ef7decd4bea198/comments", "author": null, "committer": null, "parents": [{"sha": "b8aa7083ec7490b69bd69c21e728f381f6cd4fc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3"}], "stats": {"total": 134, "additions": 134, "deletions": 0}, "files": [{"sha": "0c02d43ff2ebe9936fd12dfe9983690090eb9fc8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d285303c8fb614b39a0c0366ef7decd4bea198/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d285303c8fb614b39a0c0366ef7decd4bea198/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52d285303c8fb614b39a0c0366ef7decd4bea198", "patch": "@@ -1,3 +1,11 @@\n+2015-01-29  Jeff Law  <law@redhat.com>\n+\n+\tPR target/15184 \n+\t* combine.c (try_combine): If I0 is a memory load and I3 a store\n+\tto a related address, increase the \"goodness\" of doing a 4-insn\n+\tcombination with I0-I3.\n+\t(make_field_assignment): Handle SUBREGs in the ior+and case.\n+\n 2015-01-29  Yuri Rumyantsev  <ysrumyan@gmail.com>\n \n \tPR tree-optimization/64746"}, {"sha": "24418df002f7ce4c3683d19d586a6bccd1cf9259", "filename": "gcc/combine.c", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d285303c8fb614b39a0c0366ef7decd4bea198/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d285303c8fb614b39a0c0366ef7decd4bea198/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=52d285303c8fb614b39a0c0366ef7decd4bea198", "patch": "@@ -2620,6 +2620,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n       int i;\n       int ngood = 0;\n       int nshift = 0;\n+      rtx set0, set3;\n \n       if (!flag_expensive_optimizations)\n \treturn 0;\n@@ -2643,6 +2644,34 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t\t   || GET_CODE (src) == LSHIFTRT)\n \t    nshift++;\n \t}\n+\n+      /* If I0 loads a memory and I3 sets the same memory, then I2 and I3\n+\t are likely manipulating its value.  Ideally we'll be able to combine\n+\t all four insns into a bitfield insertion of some kind. \n+\n+\t Note the source in I0 might be inside a sign/zero extension and the\n+\t memory modes in I0 and I3 might be different.  So extract the address\n+\t from the destination of I3 and search for it in the source of I0.\n+\n+\t In the event that there's a match but the source/dest do not actually\n+\t refer to the same memory, the worst that happens is we try some\n+\t combinations that we wouldn't have otherwise.  */\n+      if ((set0 = single_set (i0))\n+\t  /* Ensure the source of SET0 is a MEM, possibly buried inside\n+\t     an extension.  */\n+\t  && (GET_CODE (SET_SRC (set0)) == MEM\n+\t      || ((GET_CODE (SET_SRC (set0)) == ZERO_EXTEND\n+\t\t   || GET_CODE (SET_SRC (set0)) == SIGN_EXTEND)\n+\t\t  && GET_CODE (XEXP (SET_SRC (set0), 0)) == MEM))\n+\t  && (set3 = single_set (i3))\n+\t  /* Ensure the destination of SET3 is a MEM.  */\n+\t  && GET_CODE (SET_DEST (set3)) == MEM\n+\t  /* Would it be better to extract the base address for the MEM\n+\t     in SET3 and look for that?  I don't have cases where it matters\n+\t     but I could envision such cases.  */\n+\t  && rtx_referenced_p (XEXP (SET_DEST (set3), 0), SET_SRC (set0)))\n+\tngood += 2;\n+\n       if (ngood < 2 && nshift < 2)\n \treturn 0;\n     }\n@@ -9272,6 +9301,13 @@ make_field_assignment (rtx x)\n      to the appropriate position, force it to the required mode, and\n      make the extraction.  Check for the AND in both operands.  */\n \n+  /* One or more SUBREGs might obscure the constant-position field\n+     assignment.  The first one we are likely to encounter is an outer\n+     narrowing SUBREG, which we can just strip for the purposes of\n+     identifying the constant-field assignment.  */\n+  if (GET_CODE (src) == SUBREG && subreg_lowpart_p (src))\n+    src = SUBREG_REG (src);\n+\n   if (GET_CODE (src) != IOR && GET_CODE (src) != XOR)\n     return x;\n \n@@ -9282,10 +9318,38 @@ make_field_assignment (rtx x)\n       && CONST_INT_P (XEXP (rhs, 1))\n       && rtx_equal_for_field_assignment_p (XEXP (rhs, 0), dest))\n     c1 = INTVAL (XEXP (rhs, 1)), other = lhs;\n+  /* The second SUBREG that might get in the way is a paradoxical\n+     SUBREG around the first operand of the AND.  We want to \n+     pretend the operand is as wide as the destination here.   We\n+     do this by creating a new MEM in the wider mode for the sole\n+     purpose of the call to rtx_equal_for_field_assignment_p.   Also\n+     note this trick only works for MEMs.  */\n+  else if (GET_CODE (rhs) == AND\n+\t   && paradoxical_subreg_p (XEXP (rhs, 0))\n+\t   && GET_CODE (SUBREG_REG (XEXP (rhs, 0))) == MEM\n+\t   && CONST_INT_P (XEXP (rhs, 1))\n+\t   && rtx_equal_for_field_assignment_p (gen_rtx_MEM (GET_MODE (dest),\n+\t\t\t\t\t\t\t     XEXP (SUBREG_REG (XEXP (rhs, 0)), 0)),\n+\t\t\t\t\t\tdest))\n+    c1 = INTVAL (XEXP (rhs, 1)), other = lhs;\n   else if (GET_CODE (lhs) == AND\n \t   && CONST_INT_P (XEXP (lhs, 1))\n \t   && rtx_equal_for_field_assignment_p (XEXP (lhs, 0), dest))\n     c1 = INTVAL (XEXP (lhs, 1)), other = rhs;\n+  /* The second SUBREG that might get in the way is a paradoxical\n+     SUBREG around the first operand of the AND.  We want to \n+     pretend the operand is as wide as the destination here.   We\n+     do this by creating a new MEM in the wider mode for the sole\n+     purpose of the call to rtx_equal_for_field_assignment_p.   Also\n+     note this trick only works for MEMs.  */\n+  else if (GET_CODE (lhs) == AND\n+\t   && paradoxical_subreg_p (XEXP (lhs, 0))\n+\t   && GET_CODE (SUBREG_REG (XEXP (lhs, 0))) == MEM\n+\t   && CONST_INT_P (XEXP (lhs, 1))\n+\t   && rtx_equal_for_field_assignment_p (gen_rtx_MEM (GET_MODE (dest),\n+\t\t\t\t\t\t\t     XEXP (SUBREG_REG (XEXP (lhs, 0)), 0)),\n+\t\t\t\t\t\tdest))\n+    c1 = INTVAL (XEXP (lhs, 1)), other = rhs;\n   else\n     return x;\n "}, {"sha": "c60230f00dadc181c2945c7bd776c383b335a4b9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d285303c8fb614b39a0c0366ef7decd4bea198/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d285303c8fb614b39a0c0366ef7decd4bea198/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=52d285303c8fb614b39a0c0366ef7decd4bea198", "patch": "@@ -1,3 +1,9 @@\n+2015-01-29  Jeff Law  <law@redhat.com>\n+\n+\tPR target/15184\n+\t* gcc.target/i386/pr15184-1.c: New test.\n+\t* gcc.target/i386/pr15184-2.c: New test.\n+\n 2015-01-29  Yuri Rumyantsev  <ysrumyan@gmail.com>\n \n \tPR tree-optimization/64746"}, {"sha": "9eb544c10ef5a518b0dbe8cc13587c2c4c96e872", "filename": "gcc/testsuite/gcc.target/i386/pr15184-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d285303c8fb614b39a0c0366ef7decd4bea198/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr15184-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d285303c8fb614b39a0c0366ef7decd4bea198/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr15184-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr15184-1.c?ref=52d285303c8fb614b39a0c0366ef7decd4bea198", "patch": "@@ -0,0 +1,33 @@\n+/* PR 15184 first two tests, plus two addition ones.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -m32 -march=pentiumpro\" } */\n+\n+#define regparm __attribute__((__regparm__(3)))\n+\n+extern unsigned int x;\n+extern unsigned short y;\n+\n+void regparm f0(unsigned char c)\n+{\n+       x = (x & 0xFFFFFF00) | (unsigned int)c;\n+}\n+\n+void regparm f1(unsigned char c)\n+{\n+     x = (x & 0xFFFF00FF) | ((unsigned int)c << 8);\n+}\n+\n+void regparm f2(unsigned char c)\n+{\n+     x = (x & 0xFF00FFFF) | ((unsigned int)c << 16);\n+}\n+void regparm f3(unsigned char c)\n+{\n+     x = (x & 0x00FFFFFF) | ((unsigned int)c << 24);\n+}\n+\n+\n+/* Each function should compile down to a byte move from\n+   the input register into x, possibly at an offset within x.  */\n+/* { dg-final { scan-assembler-times \"\\tmovb\\t%al, x\" 4 } } */\n+"}, {"sha": "99fdbc8eed677ed8377d9af0716b4cb54344997d", "filename": "gcc/testsuite/gcc.target/i386/pr15184-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52d285303c8fb614b39a0c0366ef7decd4bea198/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr15184-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52d285303c8fb614b39a0c0366ef7decd4bea198/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr15184-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr15184-2.c?ref=52d285303c8fb614b39a0c0366ef7decd4bea198", "patch": "@@ -0,0 +1,23 @@\n+/* PR 15184 second two tests\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -m32 -march=pentiumpro\" } */\n+\n+#define regparm __attribute__((__regparm__(3)))\n+\n+extern unsigned int x;\n+extern unsigned short y;\n+\n+void regparm g0(unsigned char c)\n+{\n+        y = (y & 0xFF00) | (unsigned short)c;\n+}\n+\n+void regparm g1(unsigned char c)\n+{\n+        y = (y & 0x00FF) | ((unsigned short)c << 8);\n+}\n+\n+/* Each function should compile down to a byte move from\n+   the input register into x, possibly at an offset within x.  */\n+/* { dg-final { scan-assembler-times \"\\tmovb\\t%al, y\" 2 } } */\n+"}]}