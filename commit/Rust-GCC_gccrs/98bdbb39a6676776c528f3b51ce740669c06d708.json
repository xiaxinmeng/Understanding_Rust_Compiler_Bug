{"sha": "98bdbb39a6676776c528f3b51ce740669c06d708", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThiZGJiMzlhNjY3Njc3NmM1MjhmM2I1MWNlNzQwNjY5YzA2ZDcwOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-05-30T10:40:33Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-05-30T10:40:33Z"}, "message": "predict.h (force_edge_cold): Declare.\n\n\t* predict.h (force_edge_cold): Declare.\n\t* predict.c (force_edge_cold): New function.\n\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Fix profile\n\tupdating.\n\t(canonicalize_loop_induction_variables): Fix formating.\n\n\t* gcc.dg/tree-ssa/cunroll-12.c: New testcase.\n\t* gcc.dg/tree-ssa/cunroll-13.c: New testcase.\n\t* gcc.dg/tree-ssa/cunroll-14.c: New testcase.\n\nFrom-SVN: r236874", "tree": {"sha": "70d2283e17b094627b83cbfbd240e80625f370dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70d2283e17b094627b83cbfbd240e80625f370dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98bdbb39a6676776c528f3b51ce740669c06d708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98bdbb39a6676776c528f3b51ce740669c06d708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98bdbb39a6676776c528f3b51ce740669c06d708", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98bdbb39a6676776c528f3b51ce740669c06d708/comments", "author": null, "committer": null, "parents": [{"sha": "d5cf3d8da6ef568929fc8bdfc1809593ff1988a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5cf3d8da6ef568929fc8bdfc1809593ff1988a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5cf3d8da6ef568929fc8bdfc1809593ff1988a8"}], "stats": {"total": 181, "additions": 176, "deletions": 5}, "files": [{"sha": "815a43da5ecba537c8a96bc00ab68e940aafda1e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98bdbb39a6676776c528f3b51ce740669c06d708", "patch": "@@ -1,3 +1,11 @@\n+2016-05-30  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* predict.h (force_edge_cold): Declare.\n+\t* predict.c (force_edge_cold): New function.\n+\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Fix profile\n+\tupdating.\n+\t(canonicalize_loop_induction_variables): Fix formating.\n+\n 2016-05-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/visium/visium.c (visium_split_double_add): Minor tweaks."}, {"sha": "396e150539579c7c8ba0918857af1ca2f805fef2", "filename": "gcc/predict.c", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=98bdbb39a6676776c528f3b51ce740669c06d708", "patch": "@@ -3249,3 +3249,99 @@ report_predictor_hitrates (void)\n   loop_optimizer_finalize ();\n }\n \n+/* Force edge E to be cold.\n+   If IMPOSSIBLE is true, for edge to have count and probability 0 otherwise\n+   keep low probability to represent possible error in a guess.  This is used\n+   i.e. in case we predict loop to likely iterate given number of times but\n+   we are not 100% sure.\n+\n+   This function locally updates profile without attempt to keep global\n+   consistency which can not be reached in full generality without full profile\n+   rebuild from probabilities alone.  Doing so is not necessarily a good idea\n+   because frequencies and counts may be more realistic then probabilities.\n+\n+   In some cases (such as for elimination of early exits during full loop\n+   unrolling) the caller can ensure that profile will get consistent\n+   afterwards.  */\n+\n+void\n+force_edge_cold (edge e, bool impossible)\n+{\n+  gcov_type count_sum = 0;\n+  int prob_sum = 0;\n+  edge_iterator ei;\n+  edge e2;\n+  gcov_type old_count = e->count;\n+  int old_probability = e->probability;\n+  gcov_type gcov_scale = REG_BR_PROB_BASE;\n+  int prob_scale = REG_BR_PROB_BASE;\n+\n+  /* If edge is already improbably or cold, just return.  */\n+  if (e->probability <= impossible ? PROB_VERY_UNLIKELY : 0\n+      && (!impossible || !e->count))\n+    return;\n+  FOR_EACH_EDGE (e2, ei, e->src->succs)\n+    if (e2 != e)\n+      {\n+\tcount_sum += e2->count;\n+\tprob_sum += e2->probability;\n+      }\n+\n+  /* If there are other edges out of e->src, redistribute probabilitity\n+     there.  */\n+  if (prob_sum)\n+    {\n+      e->probability\n+\t = MIN (e->probability, impossible ? 0 : PROB_VERY_UNLIKELY);\n+      if (old_probability)\n+\te->count = RDIV (e->count * e->probability, old_probability);\n+      else\n+        e->count = MIN (e->count, impossible ? 0 : 1);\n+\n+      if (count_sum)\n+\tgcov_scale = RDIV ((count_sum + old_count - e->count) * REG_BR_PROB_BASE,\n+\t\t\t   count_sum);\n+      prob_scale = RDIV ((REG_BR_PROB_BASE - e->probability) * REG_BR_PROB_BASE,\n+\t\t\t prob_sum);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Making edge %i->%i %s by redistributing \"\n+\t\t \"probability to other edges.\\n\",\n+\t\t e->src->index, e->dest->index,\n+\t\t impossible ? \"imposisble\" : \"cold\");\n+      FOR_EACH_EDGE (e2, ei, e->src->succs)\n+\tif (e2 != e)\n+\t  {\n+\t    e2->count = RDIV (e2->count * gcov_scale, REG_BR_PROB_BASE);\n+\t    e2->probability = RDIV (e2->probability * prob_scale,\n+\t\t\t\t    REG_BR_PROB_BASE);\n+\t  }\n+    }\n+  /* If all edges out of e->src are unlikely, the basic block itself\n+     is unlikely.  */\n+  else\n+    {\n+      e->probability = REG_BR_PROB_BASE;\n+\n+      /* If we did not adjusting, the source basic block has no likely edeges\n+ \t leaving other direction. In that case force that bb cold, too.\n+\t This in general is difficult task to do, but handle special case when\n+\t BB has only one predecestor.  This is common case when we are updating\n+\t after loop transforms.  */\n+      if (!prob_sum && !count_sum && single_pred_p (e->src)\n+\t  && e->src->frequency > (impossible ? 0 : 1))\n+\t{\n+\t  int old_frequency = e->src->frequency;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Making bb %i %s.\\n\", e->src->index,\n+\t\t     impossible ? \"imposisble\" : \"cold\");\n+\t  e->src->frequency = MIN (e->src->frequency, impossible ? 0 : 1);\n+\t  e->src->count = e->count = RDIV (e->src->count * e->src->frequency,\n+\t\t\t\t\t   old_frequency);\n+\t  force_edge_cold (single_pred_edge (e->src), impossible);\n+\t}\n+      else if (dump_file && (dump_flags & TDF_DETAILS)\n+\t       && maybe_hot_bb_p (cfun, e->src))\n+\tfprintf (dump_file, \"Giving up on making bb %i %s.\\n\", e->src->index,\n+\t\t impossible ? \"imposisble\" : \"cold\");\n+    }\n+}"}, {"sha": "79942871bacc7d2d82b7985f71a7c9e32eac53df", "filename": "gcc/predict.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=98bdbb39a6676776c528f3b51ce740669c06d708", "patch": "@@ -91,5 +91,6 @@ extern tree build_predict_expr (enum br_predictor, enum prediction);\n extern const char *predictor_name (enum br_predictor);\n extern void rebuild_frequencies (void);\n extern void report_predictor_hitrates (void);\n+extern void force_edge_cold (edge, bool);\n \n #endif  /* GCC_PREDICT_H */"}, {"sha": "8b989b4e5d64f2bd4ad4d85724d7e7a20f02ddea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=98bdbb39a6676776c528f3b51ce740669c06d708", "patch": "@@ -1,3 +1,9 @@\n+2016-05-30  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/tree-ssa/cunroll-12.c: New testcase.\n+\t* gcc.dg/tree-ssa/cunroll-13.c: New testcase.\n+\t* gcc.dg/tree-ssa/cunroll-14.c: New testcase.\n+\n 2016-05-30  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/69067"}, {"sha": "0cc44f42fd809a55bb6ca1aec599e8884a511c6c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-12.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-12.c?ref=98bdbb39a6676776c528f3b51ce740669c06d708", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -Warray-bounds -fdump-tree-cunroll-blocks-details\" } */\n+struct a {int a[8];int b;};\n+void\n+t(struct a *a)\n+{\n+  for (int i=0;a->a[i];i++)\n+    a->a[i]++;\n+}\n+/* { dg-final { scan-tree-dump-times \"loop with 7 iterations completely unrolled\" 1 \"cunroll\" } } */\n+/* { dg-final { scan-tree-dump-not \"Invalid sum\" \"cunroll\" } } */"}, {"sha": "6e4417a75205acda6b643520061869183c91dec3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-13.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-13.c?ref=98bdbb39a6676776c528f3b51ce740669c06d708", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdisable-tree-cunrolli -fdisable-tree-vrp1 -fdump-tree-cunroll-blocks-details\" } */\n+struct a {int a[8];int b;};\n+void\n+t(struct a *a)\n+{\n+  for (int i=0;i<123456 && a->a[i];i++)\n+    a->a[i]++;\n+}\n+/* This pass relies on the fact that we do not eliminate the redundant test for i early.\n+   It is necessary to disable all passes that do so.  At the moment it is vrp1 and cunrolli.  */\n+/* { dg-final { scan-tree-dump-times \"Loop 1 iterates 123454 times\" 1 \"cunroll\" } } */\n+/* { dg-final { scan-tree-dump-times \"Last iteration exit edge was proved true\" 1 \"cunroll\" } } */\n+/* { dg-final { scan-tree-dump-times \"Exit condition of peeled iterations was eliminated\" 1 \"cunroll\" } } */\n+/* { dg-final { scan-tree-dump-times \"loop with 7 iterations completely unrolled\" 1 \"cunroll\" } } */\n+/* { dg-final { scan-tree-dump-not \"Invalid sum\" \"cunroll\" } } */"}, {"sha": "4d27b185a862aef34224b64db8689d8534930630", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-14.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-14.c?ref=98bdbb39a6676776c528f3b51ce740669c06d708", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-cunroll-blocks-details\" } */\n+struct a {int a[100];};\n+void\n+t(struct a *a)\n+{\n+  for (int i=0;i<5 && a->a[i];i++)\n+    a->a[i]++;\n+}\n+/* { dg-final { scan-tree-dump-times \"loop with 5 iterations completely unrolled\" 1 \"cunroll\" } } */\n+/* { dg-final { scan-tree-dump-not \"Invalid sum\" \"cunroll\" } } */\n+/* { dg-final { scan-tree-dump-times \"Loop 1 iterates 4 times\" 1 \"cunroll\" } } */\n+/* { dg-final { scan-tree-dump-times \"Last iteration exit edge was proved true\" 1 \"cunroll\" } } */\n+/* { dg-final { scan-tree-dump-times \"Exit condition of peeled iterations was eliminated\" 1 \"cunroll\" } } */"}, {"sha": "4673d02275362d29c65e3a2c4b454152a03757a3", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98bdbb39a6676776c528f3b51ce740669c06d708/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=98bdbb39a6676776c528f3b51ce740669c06d708", "patch": "@@ -730,8 +730,14 @@ try_unroll_loop_completely (struct loop *loop,\n       if (ul == UL_SINGLE_ITER)\n \treturn false;\n \n+      /* EXIT can be removed only if we are sure it passes first N_UNROLL\n+\t iterations.  */\n+      bool remove_exit = (exit && niter\n+\t\t\t  && TREE_CODE (niter) == INTEGER_CST\n+\t\t\t  && wi::leu_p (n_unroll, wi::to_widest (niter)));\n+\n       large = tree_estimate_loop_size\n-\t\t (loop, exit, edge_to_cancel, &size,\n+\t\t (loop, remove_exit ? exit : NULL, edge_to_cancel, &size,\n \t\t  PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS));\n       ninsns = size.overall;\n       if (large)\n@@ -837,8 +843,20 @@ try_unroll_loop_completely (struct loop *loop,\n \n       initialize_original_copy_tables ();\n       wont_exit = sbitmap_alloc (n_unroll + 1);\n-      bitmap_ones (wont_exit);\n-      bitmap_clear_bit (wont_exit, 0);\n+      if (exit && niter\n+\t  && TREE_CODE (niter) == INTEGER_CST\n+\t  && wi::leu_p (n_unroll, wi::to_widest (niter)))\n+\t{\n+\t  bitmap_ones (wont_exit);\n+\t  if (wi::eq_p (wi::to_widest (niter), n_unroll)\n+\t      || edge_to_cancel)\n+\t    bitmap_clear_bit (wont_exit, 0);\n+\t}\n+      else\n+\t{\n+\t  exit = NULL;\n+\t  bitmap_clear (wont_exit);\n+\t}\n \n       if (!gimple_duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t\t\t n_unroll, wont_exit,\n@@ -869,6 +887,7 @@ try_unroll_loop_completely (struct loop *loop,\n   if (edge_to_cancel)\n     {\n       gcond *cond = as_a <gcond *> (last_stmt (edge_to_cancel->src));\n+      force_edge_cold (edge_to_cancel, true);\n       if (edge_to_cancel->flags & EDGE_TRUE_VALUE)\n \tgimple_cond_make_false (cond);\n       else\n@@ -1112,8 +1131,8 @@ canonicalize_loop_induction_variables (struct loop *loop,\n   if (dump_file && (dump_flags & TDF_DETAILS)\n       && likely_max_loop_iterations_int (loop) >= 0)\n     {\n-      fprintf (dump_file, \"Loop likely %d iterates at most %i times.\\n\", loop->num,\n-\t       (int)likely_max_loop_iterations_int (loop));\n+      fprintf (dump_file, \"Loop %d likely iterates at most %i times.\\n\",\n+\t       loop->num, (int)likely_max_loop_iterations_int (loop));\n     }\n \n   /* Remove exits that are known to be never taken based on loop bound."}]}