{"sha": "16842c15359aeba1c588c153fafad99fad0f3fd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY4NDJjMTUzNTlhZWJhMWM1ODhjMTUzZmFmYWQ5OWZhZDBmM2ZkOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-04-27T23:25:20Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-04-27T23:25:20Z"}, "message": "except.c (expand_eh_region_start): Don't start a new block.\n\n        * except.c (expand_eh_region_start): Don't start a new block.\n        (expand_eh_region_end): Don't end a block.\n        * stmt.c (expand_end_bindings): Don't end EH blocks.\n        (expand_decl_cleanup): Starting an EH region won't change the block.\n        (mark_block_as_eh_region, mark_block_as_not_eh_region): Lose.\n        (is_eh_region): Lose.\n        * tree.h: Adjust.\n\nFrom-SVN: r41647", "tree": {"sha": "5d2d24c2ce6f607592d8f5fd684eb2a1ebe84c45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d2d24c2ce6f607592d8f5fd684eb2a1ebe84c45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16842c15359aeba1c588c153fafad99fad0f3fd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16842c15359aeba1c588c153fafad99fad0f3fd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16842c15359aeba1c588c153fafad99fad0f3fd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16842c15359aeba1c588c153fafad99fad0f3fd9/comments", "author": null, "committer": null, "parents": [{"sha": "6fa0f379d54a170c191110d5c89d289c280fc420", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa0f379d54a170c191110d5c89d289c280fc420", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fa0f379d54a170c191110d5c89d289c280fc420"}], "stats": {"total": 113, "additions": 14, "deletions": 99}, "files": [{"sha": "f6baaabc86554bf4ff53bbfc64ed7160ff137a9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16842c15359aeba1c588c153fafad99fad0f3fd9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16842c15359aeba1c588c153fafad99fad0f3fd9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16842c15359aeba1c588c153fafad99fad0f3fd9", "patch": "@@ -1,5 +1,17 @@\n+2001-04-28  Jason Merrill  <jason_merrill@redhat.com>\n+\n+\t* except.c (expand_eh_region_start): Don't start a new block.\n+\t(expand_eh_region_end): Don't end a block.\n+\t* stmt.c (expand_end_bindings): Don't end EH blocks.\n+\t(expand_decl_cleanup): Starting an EH region won't change the block.\n+\t(mark_block_as_eh_region, mark_block_as_not_eh_region): Lose.\n+\t(is_eh_region): Lose.\n+\t* tree.h: Adjust.\n+\n 2001-04-27  Jeffrey Oldham  <oldham@codesourcery.com>\n \n+\t* except.c (expand_eh_region_end_cleanup): word_mode, not Pmode.\n+\n \t* collect2.c (main): Add `-L' case to remove duplicate entries.\n \t(is_in_args): New function to check for a duplicate argument.\n \t* defaults.h (LINK_ELIMINATE_DUPLICATE_LDIRECTORIES): New macro."}, {"sha": "ee9892bdbb2fd2bda6374e7524f0fb437bfd1607", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16842c15359aeba1c588c153fafad99fad0f3fd9/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16842c15359aeba1c588c153fafad99fad0f3fd9/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=16842c15359aeba1c588c153fafad99fad0f3fd9", "patch": "@@ -643,17 +643,6 @@ expand_eh_region_start ()\n   if (! doing_eh (0))\n     return;\n \n-  /* We need a new block to record the start and end of the dynamic\n-     handler chain.  We also want to prevent jumping into a try block.  */\n-  expand_start_bindings (2);\n-\n-  /* But we don't need or want a new temporary level.  */\n-  pop_temp_slots ();\n-\n-  /* Mark this block as created by expand_eh_region_start.  This is so\n-     that we can pop the block with expand_end_bindings automatically.  */\n-  mark_block_as_eh_region ();\n-\n   /* Insert a new blank region as a leaf in the tree.  */\n   new_region = (struct eh_region *) xcalloc (1, sizeof (*new_region));\n   cur_region = cfun->eh->cur_region;\n@@ -691,20 +680,6 @@ expand_eh_region_end ()\n   /* Pop.  */\n   cfun->eh->cur_region = cur_region->outer;\n \n-  /* If we have already started ending the bindings, don't recurse.  */\n-  if (is_eh_region ())\n-    {\n-      /* Because we don't need or want a new temporary level and\n-\t because we didn't create one in expand_eh_region_start,\n-\t create a fake one now to avoid removing one in\n-\t expand_end_bindings.  */\n-      push_temp_slots ();\n-\n-      mark_block_as_not_eh_region ();\n-\n-      expand_end_bindings (NULL_TREE, 0, 0);\n-    }\n-\n   return cur_region;\n }\n \n@@ -739,7 +714,7 @@ expand_eh_region_end_cleanup (handler)\n      it, we need to save the EH return data registers around it.  */\n   data_save[0] = gen_reg_rtx (Pmode);\n   emit_move_insn (data_save[0], get_exception_pointer ());\n-  data_save[1] = gen_reg_rtx (Pmode);\n+  data_save[1] = gen_reg_rtx (word_mode);\n   emit_move_insn (data_save[1], get_exception_filter ());\n \n   expand_expr (handler, const0_rtx, VOIDmode, 0);"}, {"sha": "4a8b1e0c62aebd55a4305f7ec061a8957e220b5f", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 68, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16842c15359aeba1c588c153fafad99fad0f3fd9/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16842c15359aeba1c588c153fafad99fad0f3fd9/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=16842c15359aeba1c588c153fafad99fad0f3fd9", "patch": "@@ -3380,28 +3380,6 @@ is_body_block (stmt)\n   return 0;\n }\n \n-/* Mark top block of block_stack as an implicit binding for an\n-   exception region.  This is used to prevent infinite recursion when\n-   ending a binding with expand_end_bindings.  It is only ever called\n-   by expand_eh_region_start, as that it the only way to create a\n-   block stack for a exception region.  */\n-\n-void\n-mark_block_as_eh_region ()\n-{\n-  block_stack->data.block.exception_region = 1;\n-  if (block_stack->next\n-      && block_stack->next->data.block.conditional_code)\n-    {\n-      block_stack->data.block.conditional_code\n-\t= block_stack->next->data.block.conditional_code;\n-      block_stack->data.block.last_unconditional_cleanup\n-\t= block_stack->next->data.block.last_unconditional_cleanup;\n-      block_stack->data.block.cleanup_ptr\n-\t= block_stack->next->data.block.cleanup_ptr;\n-    }\n-}\n-\n /* True if we are currently emitting insns in an area of output code\n    that is controlled by a conditional expression.  This is used by\n    the cleanup handling code to generate conditional cleanup actions.  */\n@@ -3412,29 +3390,6 @@ conditional_context ()\n   return block_stack && block_stack->data.block.conditional_code;\n }\n \n-/* Mark top block of block_stack as not for an implicit binding for an\n-   exception region.  This is only ever done by expand_eh_region_end\n-   to let expand_end_bindings know that it is being called explicitly\n-   to end the binding layer for just the binding layer associated with\n-   the exception region, otherwise expand_end_bindings would try and\n-   end all implicit binding layers for exceptions regions, and then\n-   one normal binding layer.  */\n-\n-void\n-mark_block_as_not_eh_region ()\n-{\n-  block_stack->data.block.exception_region = 0;\n-}\n-\n-/* True if the top block of block_stack was marked as for an exception\n-   region by mark_block_as_eh_region.  */\n-\n-int\n-is_eh_region ()\n-{\n-  return cfun && block_stack && block_stack->data.block.exception_region;\n-}\n-\n /* Emit a handler label for a nonlocal goto handler.\n    Also emit code to store the handler label in SLOT before BEFORE_INSN.  */\n \n@@ -3637,26 +3592,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n      int mark_ends;\n      int dont_jump_in;\n {\n-  register struct nesting *thisblock;\n-\n-  while (block_stack->data.block.exception_region)\n-    {\n-      /* Because we don't need or want a new temporary level and\n-\t because we didn't create one in expand_eh_region_start,\n-\t create a fake one now to avoid removing one in\n-\t expand_end_bindings.  */\n-      push_temp_slots ();\n-\n-      block_stack->data.block.exception_region = 0;\n-\n-      expand_end_bindings (NULL_TREE, 0, 0);\n-    }\n-\n-  /* Since expand_eh_region_start does an expand_start_bindings, we\n-     have to first end all the bindings that were created by\n-     expand_eh_region_start.  */\n-\n-  thisblock = block_stack;\n+  register struct nesting *thisblock = block_stack;\n \n   /* If any of the variables in this scope were not used, warn the\n      user.  */\n@@ -4077,9 +4013,6 @@ expand_decl_cleanup (decl, cleanup)\n       else\n \texpand_eh_region_start ();\n \n-      /* If that started a new EH region, we're in a new block.  */\n-      thisblock = block_stack;\n-\n       if (cond_context)\n \t{\n \t  seq = get_insns ();"}, {"sha": "22763fad9348c8670da590e3d67fcc07b5e61643", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16842c15359aeba1c588c153fafad99fad0f3fd9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16842c15359aeba1c588c153fafad99fad0f3fd9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=16842c15359aeba1c588c153fafad99fad0f3fd9", "patch": "@@ -2552,13 +2552,8 @@ extern void start_cleanup_deferral\t\tPARAMS ((void));\n extern void end_cleanup_deferral\t\tPARAMS ((void));\n extern int is_body_block\t\t\tPARAMS ((tree));\n \n-extern void mark_block_as_eh_region\t\tPARAMS ((void));\n-extern void mark_block_as_not_eh_region\t\tPARAMS ((void));\n-extern int is_eh_region\t\t\t\tPARAMS ((void));\n extern int conditional_context\t\t\tPARAMS ((void));\n extern tree last_cleanup_this_contour\t\tPARAMS ((void));\n-extern int expand_dhc_cleanup\t\t\tPARAMS ((tree));\n-extern int expand_dcc_cleanup\t\t\tPARAMS ((tree));\n extern void expand_start_case\t\t\tPARAMS ((int, tree, tree,\n \t\t\t\t\t\t       const char *));\n extern void expand_end_case\t\t\tPARAMS ((tree));"}]}