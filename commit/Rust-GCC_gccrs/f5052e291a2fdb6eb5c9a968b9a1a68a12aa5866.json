{"sha": "f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUwNTJlMjkxYTJmZGI2ZWI1YzlhOTY4YjlhMWE2OGExMmFhNTg2Ng==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-05-01T09:32:34Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-05-01T09:32:34Z"}, "message": "tree-vrp.c (set_value_range): Do not allocate equiv bitmap if it is not about to be set.\n\n2007-05-01  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (set_value_range): Do not allocate equiv bitmap\n\tif it is not about to be set.\n\t(get_value_range): Do not pre-allocate equiv bitmap.\n\t(update_value_range): No need to clear equiv field.\n\t(add_equivalence): Change prototype to get bitmap pointer.\n\tAllocate bitmap here if it is not already.\n\t(extract_range_from_assert): Do not allocate bitmap here.\n\tUpdate callers to add_equivalence.\n\t(extract_range_from_ssa_name): Likewise.\n\t(get_vr_for_comparison): New static helper.\n\t(compare_name_with_value): Handle NULL equiv bitmap by\n\tpeeling the first iteration of the comparison loop.\n\tUse get_vr_for_comparison.\n\t(compare_names): Handle NULL equiv bitmaps by using fake\n\tones.  Use get_vr_for_comparison.\n\nFrom-SVN: r124321", "tree": {"sha": "914b1022265dcfffca36896f0385911af5e5f816", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/914b1022265dcfffca36896f0385911af5e5f816"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42b5a16d408d1c619a3bc1c21fcc08ceaeab7534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42b5a16d408d1c619a3bc1c21fcc08ceaeab7534", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42b5a16d408d1c619a3bc1c21fcc08ceaeab7534"}], "stats": {"total": 154, "additions": 93, "deletions": 61}, "files": [{"sha": "33a45f0ce139474a7556861d964c9ef1e727c03c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866", "patch": "@@ -1,3 +1,21 @@\n+2007-05-01  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (set_value_range): Do not allocate equiv bitmap\n+\tif it is not about to be set.\n+\t(get_value_range): Do not pre-allocate equiv bitmap.\n+\t(update_value_range): No need to clear equiv field.\n+\t(add_equivalence): Change prototype to get bitmap pointer.\n+\tAllocate bitmap here if it is not already.\n+\t(extract_range_from_assert): Do not allocate bitmap here.\n+\tUpdate callers to add_equivalence.\n+\t(extract_range_from_ssa_name): Likewise.\n+\t(get_vr_for_comparison): New static helper.\n+\t(compare_name_with_value): Handle NULL equiv bitmap by\n+\tpeeling the first iteration of the comparison loop.\n+\tUse get_vr_for_comparison.\n+\t(compare_names): Handle NULL equiv bitmaps by using fake\n+\tones.  Use get_vr_for_comparison.\n+\n 2007-04-30  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* double-int.c (mpz_set_double_int): Moved from"}, {"sha": "b165418b36765f97c1489972f72968a0e9fbe081", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 75, "deletions": 61, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=f5052e291a2fdb6eb5c9a968b9a1a68a12aa5866", "patch": "@@ -291,7 +291,8 @@ set_value_range (value_range_t *vr, enum value_range_type t, tree min,\n \n   /* Since updating the equivalence set involves deep copying the\n      bitmaps, only do it if absolutely necessary.  */\n-  if (vr->equiv == NULL)\n+  if (vr->equiv == NULL\n+      && equiv != NULL)\n     vr->equiv = BITMAP_ALLOC (NULL);\n \n   if (equiv != vr->equiv)\n@@ -436,8 +437,8 @@ get_value_range (tree var)\n   /* Create a default value range.  */\n   vr_value[ver] = vr = XCNEW (value_range_t);\n \n-  /* Allocate an equivalence set.  */\n-  vr->equiv = BITMAP_ALLOC (NULL);\n+  /* Defer allocating the equivalence set.  */\n+  vr->equiv = NULL;\n \n   /* If VAR is a default definition, the variable can take any value\n      in VAR's type.  */\n@@ -510,23 +511,25 @@ update_value_range (tree var, value_range_t *new_vr)\n \t             new_vr->equiv);\n \n   BITMAP_FREE (new_vr->equiv);\n-  new_vr->equiv = NULL;\n \n   return is_new;\n }\n \n \n-/* Add VAR and VAR's equivalence set to EQUIV.  */\n+/* Add VAR and VAR's equivalence set to EQUIV.  This is the central\n+   point where equivalence processing can be turned on/off.  */\n \n static void\n-add_equivalence (bitmap equiv, tree var)\n+add_equivalence (bitmap *equiv, tree var)\n {\n   unsigned ver = SSA_NAME_VERSION (var);\n   value_range_t *vr = vr_value[ver];\n \n-  bitmap_set_bit (equiv, ver);\n+  if (*equiv == NULL)\n+    *equiv = BITMAP_ALLOC (NULL);\n+  bitmap_set_bit (*equiv, ver);\n   if (vr && vr->equiv)\n-    bitmap_ior_into (equiv, vr->equiv);\n+    bitmap_ior_into (*equiv, vr->equiv);\n }\n \n \n@@ -1095,8 +1098,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n      predicates, we will need to trim the set of equivalences before\n      we are done.  */\n   gcc_assert (vr_p->equiv == NULL);\n-  vr_p->equiv = BITMAP_ALLOC (NULL);\n-  add_equivalence (vr_p->equiv, var);\n+  add_equivalence (&vr_p->equiv, var);\n \n   /* Extract a new range based on the asserted comparison for VAR and\n      LIMIT's value range.  Notice that if LIMIT has an anti-range, we\n@@ -1130,7 +1132,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t SSA name, the new range will also inherit the equivalence set\n \t from LIMIT.  */\n       if (TREE_CODE (limit) == SSA_NAME)\n-\tadd_equivalence (vr_p->equiv, limit);\n+\tadd_equivalence (&vr_p->equiv, limit);\n     }\n   else if (cond_code == NE_EXPR)\n     {\n@@ -1478,7 +1480,7 @@ extract_range_from_ssa_name (value_range_t *vr, tree var)\n   else\n     set_value_range (vr, VR_RANGE, var, var, NULL);\n \n-  add_equivalence (vr->equiv, var);\n+  add_equivalence (&vr->equiv, var);\n }\n \n \n@@ -4582,6 +4584,27 @@ vrp_visit_assignment (tree stmt, tree *output_p)\n   return SSA_PROP_VARYING;\n }\n \n+/* Helper that gets the value range of the SSA_NAME with version I\n+   or a symbolic range contaning the SSA_NAME only if the value range\n+   is varying or undefined.  */\n+\n+static inline value_range_t\n+get_vr_for_comparison (int i)\n+{\n+  value_range_t vr = *(vr_value[i]);\n+\n+  /* If name N_i does not have a valid range, use N_i as its own\n+     range.  This allows us to compare against names that may\n+     have N_i in their ranges.  */\n+  if (vr.type == VR_VARYING || vr.type == VR_UNDEFINED)\n+    {\n+      vr.type = VR_RANGE;\n+      vr.min = ssa_name (i);\n+      vr.max = ssa_name (i);\n+    }\n+\n+  return vr;\n+}\n \n /* Compare all the value ranges for names equivalent to VAR with VAL\n    using comparison code COMP.  Return the same value returned by\n@@ -4597,37 +4620,35 @@ compare_name_with_value (enum tree_code comp, tree var, tree val,\n   bitmap e;\n   tree retval, t;\n   int used_strict_overflow;\n-  \n-  t = retval = NULL_TREE;\n+  bool sop;\n+  value_range_t equiv_vr;\n \n   /* Get the set of equivalences for VAR.  */\n   e = get_value_range (var)->equiv;\n \n-  /* Add VAR to its own set of equivalences so that VAR's value range\n-     is processed by this loop (otherwise, we would have to replicate\n-     the body of the loop just to check VAR's value range).  */\n-  bitmap_set_bit (e, SSA_NAME_VERSION (var));\n-\n   /* Start at -1.  Set it to 0 if we do a comparison without relying\n      on overflow, or 1 if all comparisons rely on overflow.  */\n   used_strict_overflow = -1;\n \n-  EXECUTE_IF_SET_IN_BITMAP (e, 0, i, bi)\n-    {\n-      bool sop;\n-\n-      value_range_t equiv_vr = *(vr_value[i]);\n+  /* Compare vars' value range with val.  */\n+  equiv_vr = get_vr_for_comparison (SSA_NAME_VERSION (var));\n+  sop = false;\n+  retval = compare_range_with_value (comp, &equiv_vr, val, &sop);\n+  if (sop)\n+    used_strict_overflow = 1;\n \n-      /* If name N_i does not have a valid range, use N_i as its own\n-\t range.  This allows us to compare against names that may\n-\t have N_i in their ranges.  */\n-      if (equiv_vr.type == VR_VARYING || equiv_vr.type == VR_UNDEFINED)\n-\t{\n-\t  equiv_vr.type = VR_RANGE;\n-\t  equiv_vr.min = ssa_name (i);\n-\t  equiv_vr.max = ssa_name (i);\n-\t}\n+  /* If the equiv set is empty we have done all work we need to do.  */\n+  if (e == NULL)\n+    {\n+      if (retval\n+\t  && used_strict_overflow > 0)\n+\t*strict_overflow_p = true;\n+      return retval;\n+    }\n \n+  EXECUTE_IF_SET_IN_BITMAP (e, 0, i, bi)\n+    {\n+      equiv_vr = get_vr_for_comparison (i);\n       sop = false;\n       t = compare_range_with_value (comp, &equiv_vr, val, &sop);\n       if (t)\n@@ -4651,18 +4672,11 @@ compare_name_with_value (enum tree_code comp, tree var, tree val,\n \t}\n     }\n \n-  /* Remove VAR from its own equivalence set.  */\n-  bitmap_clear_bit (e, SSA_NAME_VERSION (var));\n-\n-  if (retval)\n-    {\n-      if (used_strict_overflow > 0)\n-\t*strict_overflow_p = true;\n-      return retval;\n-    }\n+  if (retval\n+      && used_strict_overflow > 0)\n+    *strict_overflow_p = true;\n \n-  /* We couldn't find a non-NULL value for the predicate.  */\n-  return NULL_TREE;\n+  return retval;\n }\n \n \n@@ -4682,12 +4696,27 @@ compare_names (enum tree_code comp, tree n1, tree n2,\n   bitmap_iterator bi1, bi2;\n   unsigned i1, i2;\n   int used_strict_overflow;\n+  static bitmap_obstack *s_obstack = NULL;\n+  static bitmap s_e1 = NULL, s_e2 = NULL;\n \n   /* Compare the ranges of every name equivalent to N1 against the\n      ranges of every name equivalent to N2.  */\n   e1 = get_value_range (n1)->equiv;\n   e2 = get_value_range (n2)->equiv;\n \n+  /* Use the fake bitmaps if e1 or e2 are not available.  */\n+  if (s_obstack == NULL)\n+    {\n+      s_obstack = XNEW (bitmap_obstack);\n+      bitmap_obstack_initialize (s_obstack);\n+      s_e1 = BITMAP_ALLOC (s_obstack);\n+      s_e2 = BITMAP_ALLOC (s_obstack);\n+    }\n+  if (e1 == NULL)\n+    e1 = s_e1;\n+  if (e2 == NULL)\n+    e2 = s_e2;\n+\n   /* Add N1 and N2 to their own set of equivalences to avoid\n      duplicating the body of the loop just to check N1 and N2\n      ranges.  */\n@@ -4715,29 +4744,14 @@ compare_names (enum tree_code comp, tree n1, tree n2,\n      of the loop just to check N1 and N2 ranges.  */\n   EXECUTE_IF_SET_IN_BITMAP (e1, 0, i1, bi1)\n     {\n-      value_range_t vr1 = *(vr_value[i1]);\n-\n-      /* If the range is VARYING or UNDEFINED, use the name itself.  */\n-      if (vr1.type == VR_VARYING || vr1.type == VR_UNDEFINED)\n-\t{\n-\t  vr1.type = VR_RANGE;\n-\t  vr1.min = ssa_name (i1);\n-\t  vr1.max = ssa_name (i1);\n-\t}\n+      value_range_t vr1 = get_vr_for_comparison (i1);\n \n       t = retval = NULL_TREE;\n       EXECUTE_IF_SET_IN_BITMAP (e2, 0, i2, bi2)\n \t{\n \t  bool sop;\n \n-\t  value_range_t vr2 = *(vr_value[i2]);\n-\n-\t  if (vr2.type == VR_VARYING || vr2.type == VR_UNDEFINED)\n-\t    {\n-\t      vr2.type = VR_RANGE;\n-\t      vr2.min = ssa_name (i2);\n-\t      vr2.max = ssa_name (i2);\n-\t    }\n+\t  value_range_t vr2 = get_vr_for_comparison (i2);\n \n \t  t = compare_ranges (comp, &vr1, &vr2, &sop);\n \t  if (t)"}]}