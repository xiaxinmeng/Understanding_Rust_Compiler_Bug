{"sha": "fb0746f3a6b7fd0223efa71d0dc3fc02166e338b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIwNzQ2ZjNhNmI3ZmQwMjIzZWZhNzFkMGRjM2ZjMDIxNjZlMzM4Yg==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2021-05-24T13:23:50Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2021-05-24T14:00:42Z"}, "message": "AArch64: Cleanup aarch64_classify_symbol\n\nUse a GOT indirection for extern weak symbols instead of a literal - this is\nthe same as PIC/PIE and mirrors LLVM behaviour.  Ensure PIC/PIE use the same\noffset limits for symbols that don't use the GOT.\n\nPasses bootstrap and regress.\n\nChangeLog:\n2021-04-27  Wilco Dijkstra  <wdijkstr@arm.com>\n\n\t* config/aarch64/aarch64.c (aarch64_classify_symbol): Use GOT for\n\textern weak symbols.  Limit symbol offsets for non-GOT symbols with\n\tPIC/PIE.", "tree": {"sha": "6d33863b04eb6fde1fe3119fd59b0178312ea94a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d33863b04eb6fde1fe3119fd59b0178312ea94a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb0746f3a6b7fd0223efa71d0dc3fc02166e338b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0746f3a6b7fd0223efa71d0dc3fc02166e338b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb0746f3a6b7fd0223efa71d0dc3fc02166e338b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0746f3a6b7fd0223efa71d0dc3fc02166e338b/comments", "author": null, "committer": null, "parents": [{"sha": "4eaf65ed6a6fbeefae28bd850329fb226e76f861", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eaf65ed6a6fbeefae28bd850329fb226e76f861", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eaf65ed6a6fbeefae28bd850329fb226e76f861"}], "stats": {"total": 37, "additions": 16, "deletions": 21}, "files": [{"sha": "e9f961d41faa4b82b8e5ebc0207a80b390e41067", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb0746f3a6b7fd0223efa71d0dc3fc02166e338b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb0746f3a6b7fd0223efa71d0dc3fc02166e338b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=fb0746f3a6b7fd0223efa71d0dc3fc02166e338b", "patch": "@@ -17902,50 +17902,45 @@ aarch64_classify_symbol (rtx x, HOST_WIDE_INT offset)\n \n       switch (aarch64_cmodel)\n \t{\n+\tcase AARCH64_CMODEL_TINY_PIC:\n \tcase AARCH64_CMODEL_TINY:\n+\t  /* With -fPIC non-local symbols use the GOT.  For orthogonality\n+\t     always use the GOT for extern weak symbols.  */\n+\t  if ((flag_pic || SYMBOL_REF_WEAK (x))\n+\t      && !aarch64_symbol_binds_local_p (x))\n+\t    return SYMBOL_TINY_GOT;\n+\n \t  /* When we retrieve symbol + offset address, we have to make sure\n \t     the offset does not cause overflow of the final address.  But\n \t     we have no way of knowing the address of symbol at compile time\n \t     so we can't accurately say if the distance between the PC and\n \t     symbol + offset is outside the addressible range of +/-1MB in the\n \t     TINY code model.  So we limit the maximum offset to +/-64KB and\n \t     assume the offset to the symbol is not larger than +/-(1MB - 64KB).\n-\t     If offset_within_block_p is true we allow larger offsets.\n-\t     Furthermore force to memory if the symbol is a weak reference to\n-\t     something that doesn't resolve to a symbol in this module.  */\n-\n-\t  if (SYMBOL_REF_WEAK (x) && !aarch64_symbol_binds_local_p (x))\n-\t    return SYMBOL_FORCE_TO_MEM;\n+\t     If offset_within_block_p is true we allow larger offsets.  */\n \t  if (!(IN_RANGE (offset, -0x10000, 0x10000)\n \t\t|| offset_within_block_p (x, offset)))\n \t    return SYMBOL_FORCE_TO_MEM;\n \n \t  return SYMBOL_TINY_ABSOLUTE;\n \n+\n+\tcase AARCH64_CMODEL_SMALL_SPIC:\n+\tcase AARCH64_CMODEL_SMALL_PIC:\n \tcase AARCH64_CMODEL_SMALL:\n+\t  if ((flag_pic || SYMBOL_REF_WEAK (x))\n+\t      && !aarch64_symbol_binds_local_p (x))\n+\t    return aarch64_cmodel == AARCH64_CMODEL_SMALL_SPIC\n+\t\t    ? SYMBOL_SMALL_GOT_28K : SYMBOL_SMALL_GOT_4G;\n+\n \t  /* Same reasoning as the tiny code model, but the offset cap here is\n \t     1MB, allowing +/-3.9GB for the offset to the symbol.  */\n-\n-\t  if (SYMBOL_REF_WEAK (x) && !aarch64_symbol_binds_local_p (x))\n-\t    return SYMBOL_FORCE_TO_MEM;\n \t  if (!(IN_RANGE (offset, -0x100000, 0x100000)\n \t\t|| offset_within_block_p (x, offset)))\n \t    return SYMBOL_FORCE_TO_MEM;\n \n \t  return SYMBOL_SMALL_ABSOLUTE;\n \n-\tcase AARCH64_CMODEL_TINY_PIC:\n-\t  if (!aarch64_symbol_binds_local_p (x))\n-\t    return SYMBOL_TINY_GOT;\n-\t  return SYMBOL_TINY_ABSOLUTE;\n-\n-\tcase AARCH64_CMODEL_SMALL_SPIC:\n-\tcase AARCH64_CMODEL_SMALL_PIC:\n-\t  if (!aarch64_symbol_binds_local_p (x))\n-\t    return (aarch64_cmodel == AARCH64_CMODEL_SMALL_SPIC\n-\t\t    ?  SYMBOL_SMALL_GOT_28K : SYMBOL_SMALL_GOT_4G);\n-\t  return SYMBOL_SMALL_ABSOLUTE;\n-\n \tcase AARCH64_CMODEL_LARGE:\n \t  /* This is alright even in PIC code as the constant\n \t     pool reference is always PC relative and within"}]}