{"sha": "7cfb4d93595da03abb4e6414758dc98eb7532b34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NmYjRkOTM1OTVkYTAzYWJiNGU2NDE0NzU4ZGM5OGViNzUzMmIzNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:58:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:58:52Z"}, "message": "Add support for fully-predicated loops\n\nThis patch adds support for using a single fully-predicated loop instead\nof a vector loop and a scalar tail.  An SVE WHILELO instruction generates\nthe predicate for each iteration of the loop, given the current scalar\niv value and the loop bound.  This operation is wrapped up in a new internal\nfunction called WHILE_ULT.  E.g.:\n\n   WHILE_ULT (0, 3, { 0, 0, 0, 0}) -> { 1, 1, 1, 0 }\n   WHILE_ULT (UINT_MAX - 1, UINT_MAX, { 0, 0, 0, 0 }) -> { 1, 0, 0, 0 }\n\nThe third WHILE_ULT argument is needed to make the operation\nunambiguous: without it, WHILE_ULT (0, 3) for one vector type would\nseem equivalent to WHILE_ULT (0, 3) for another, even if the types have\ndifferent numbers of elements.\n\nNote that the patch uses \"mask\" and \"fully-masked\" instead of\n\"predicate\" and \"fully-predicated\", to follow existing GCC terminology.\n\nThis patch just handles the simple cases, punting for things like\nreductions and live-out values.  Later patches remove most of these\nrestrictions.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* optabs.def (while_ult_optab): New optab.\n\t* doc/md.texi (while_ult@var{m}@var{n}): Document.\n\t* internal-fn.def (WHILE_ULT): New internal function.\n\t* internal-fn.h (direct_internal_fn_supported_p): New override\n\tthat takes two types as argument.\n\t* internal-fn.c (while_direct): New macro.\n\t(expand_while_optab_fn): New function.\n\t(convert_optab_supported_p): Likewise.\n\t(direct_while_optab_supported_p): New macro.\n\t* wide-int.h (wi::udiv_ceil): New function.\n\t* tree-vectorizer.h (rgroup_masks): New structure.\n\t(vec_loop_masks): New typedef.\n\t(_loop_vec_info): Add masks, mask_compare_type, can_fully_mask_p\n\tand fully_masked_p.\n\t(LOOP_VINFO_CAN_FULLY_MASK_P, LOOP_VINFO_FULLY_MASKED_P)\n\t(LOOP_VINFO_MASKS, LOOP_VINFO_MASK_COMPARE_TYPE): New macros.\n\t(vect_max_vf): New function.\n\t(slpeel_make_loop_iterate_ntimes): Delete.\n\t(vect_set_loop_condition, vect_get_loop_mask_type, vect_gen_while)\n\t(vect_halve_mask_nunits, vect_double_mask_nunits): Declare.\n\t(vect_record_loop_mask, vect_get_loop_mask): Likewise.\n\t* tree-vect-loop-manip.c: Include tree-ssa-loop-niter.h,\n\tinternal-fn.h, stor-layout.h and optabs-query.h.\n\t(vect_set_loop_mask): New function.\n\t(add_preheader_seq): Likewise.\n\t(add_header_seq): Likewise.\n\t(interleave_supported_p): Likewise.\n\t(vect_maybe_permute_loop_masks): Likewise.\n\t(vect_set_loop_masks_directly): Likewise.\n\t(vect_set_loop_condition_masked): Likewise.\n\t(vect_set_loop_condition_unmasked): New function, split out from\n\tslpeel_make_loop_iterate_ntimes.\n\t(slpeel_make_loop_iterate_ntimes): Rename to..\n\t(vect_set_loop_condition): ...this.  Use vect_set_loop_condition_masked\n\tfor fully-masked loops and vect_set_loop_condition_unmasked otherwise.\n\t(vect_do_peeling): Update call accordingly.\n\t(vect_gen_vector_loop_niters): Use VF as the step for fully-masked\n\tloops.\n\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize\n\tmask_compare_type, can_fully_mask_p and fully_masked_p.\n\t(release_vec_loop_masks): New function.\n\t(_loop_vec_info): Use it to free the loop masks.\n\t(can_produce_all_loop_masks_p): New function.\n\t(vect_get_max_nscalars_per_iter): Likewise.\n\t(vect_verify_full_masking): Likewise.\n\t(vect_analyze_loop_2): Save LOOP_VINFO_CAN_FULLY_MASK_P around\n\tretries, and free the mask rgroups before retrying.  Check loop-wide\n\treasons for disallowing fully-masked loops.  Make the final decision\n\tabout whether use a fully-masked loop or not.\n\t(vect_estimate_min_profitable_iters): Do not assume that peeling\n\tfor the number of iterations will be needed for fully-masked loops.\n\t(vectorizable_reduction): Disable fully-masked loops.\n\t(vectorizable_live_operation): Likewise.\n\t(vect_halve_mask_nunits): New function.\n\t(vect_double_mask_nunits): Likewise.\n\t(vect_record_loop_mask): Likewise.\n\t(vect_get_loop_mask): Likewise.\n\t(vect_transform_loop): Handle the case in which the final loop\n\titeration might handle a partial vector.  Call vect_set_loop_condition\n\tinstead of slpeel_make_loop_iterate_ntimes.\n\t* tree-vect-stmts.c: Include tree-ssa-loop-niter.h and gimple-fold.h.\n\t(check_load_store_masking): New function.\n\t(prepare_load_store_mask): Likewise.\n\t(vectorizable_store): Handle fully-masked loops.\n\t(vectorizable_load): Likewise.\n\t(supportable_widening_operation): Use vect_halve_mask_nunits for\n\tbooleans.\n\t(supportable_narrowing_operation): Likewise vect_double_mask_nunits.\n\t(vect_gen_while): New function.\n\t* config/aarch64/aarch64.md (umax<mode>3): New expander.\n\t(aarch64_uqdec<mode>): New insn.\n\ngcc/testsuite/\n\t* gcc.dg/tree-ssa/cunroll-10.c: Disable vectorization.\n\t* gcc.dg/tree-ssa/peel1.c: Likewise.\n\t* gcc.dg/vect/vect-load-lanes-peeling-1.c: Remove XFAIL for\n\tvariable-length vectors.\n\t* gcc.target/aarch64/sve/vcond_6.c: XFAIL test for AND.\n\t* gcc.target/aarch64/sve/vec_bool_cmp_1.c: Expect BIC instead of NOT.\n\t* gcc.target/aarch64/sve/slp_1.c: Check for a fully-masked loop.\n\t* gcc.target/aarch64/sve/slp_2.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_3.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_4.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_6.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_8.c: New test.\n\t* gcc.target/aarch64/sve/slp_8_run.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_9.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_9_run.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_10.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_10_run.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_11.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_11_run.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_12.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_12_run.c: Likewise.\n\t* gcc.target/aarch64/sve/ld1r_2.c: Likewise.\n\t* gcc.target/aarch64/sve/ld1r_2_run.c: Likewise.\n\t* gcc.target/aarch64/sve/while_1.c: Likewise.\n\t* gcc.target/aarch64/sve/while_2.c: Likewise.\n\t* gcc.target/aarch64/sve/while_3.c: Likewise.\n\t* gcc.target/aarch64/sve/while_4.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256625", "tree": {"sha": "09643f0b980510f92a36803a35a7f8aa08404971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09643f0b980510f92a36803a35a7f8aa08404971"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cfb4d93595da03abb4e6414758dc98eb7532b34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cfb4d93595da03abb4e6414758dc98eb7532b34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cfb4d93595da03abb4e6414758dc98eb7532b34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cfb4d93595da03abb4e6414758dc98eb7532b34/comments", "author": null, "committer": null, "parents": [{"sha": "898f07b0458a48a87df334301ada3414ff08d3de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/898f07b0458a48a87df334301ada3414ff08d3de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/898f07b0458a48a87df334301ada3414ff08d3de"}], "stats": {"total": 2337, "additions": 2243, "deletions": 94}, "files": [{"sha": "a00e7d9861e42d7644def99e5ff5e72ea8008c83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -1,3 +1,79 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* optabs.def (while_ult_optab): New optab.\n+\t* doc/md.texi (while_ult@var{m}@var{n}): Document.\n+\t* internal-fn.def (WHILE_ULT): New internal function.\n+\t* internal-fn.h (direct_internal_fn_supported_p): New override\n+\tthat takes two types as argument.\n+\t* internal-fn.c (while_direct): New macro.\n+\t(expand_while_optab_fn): New function.\n+\t(convert_optab_supported_p): Likewise.\n+\t(direct_while_optab_supported_p): New macro.\n+\t* wide-int.h (wi::udiv_ceil): New function.\n+\t* tree-vectorizer.h (rgroup_masks): New structure.\n+\t(vec_loop_masks): New typedef.\n+\t(_loop_vec_info): Add masks, mask_compare_type, can_fully_mask_p\n+\tand fully_masked_p.\n+\t(LOOP_VINFO_CAN_FULLY_MASK_P, LOOP_VINFO_FULLY_MASKED_P)\n+\t(LOOP_VINFO_MASKS, LOOP_VINFO_MASK_COMPARE_TYPE): New macros.\n+\t(vect_max_vf): New function.\n+\t(slpeel_make_loop_iterate_ntimes): Delete.\n+\t(vect_set_loop_condition, vect_get_loop_mask_type, vect_gen_while)\n+\t(vect_halve_mask_nunits, vect_double_mask_nunits): Declare.\n+\t(vect_record_loop_mask, vect_get_loop_mask): Likewise.\n+\t* tree-vect-loop-manip.c: Include tree-ssa-loop-niter.h,\n+\tinternal-fn.h, stor-layout.h and optabs-query.h.\n+\t(vect_set_loop_mask): New function.\n+\t(add_preheader_seq): Likewise.\n+\t(add_header_seq): Likewise.\n+\t(interleave_supported_p): Likewise.\n+\t(vect_maybe_permute_loop_masks): Likewise.\n+\t(vect_set_loop_masks_directly): Likewise.\n+\t(vect_set_loop_condition_masked): Likewise.\n+\t(vect_set_loop_condition_unmasked): New function, split out from\n+\tslpeel_make_loop_iterate_ntimes.\n+\t(slpeel_make_loop_iterate_ntimes): Rename to..\n+\t(vect_set_loop_condition): ...this.  Use vect_set_loop_condition_masked\n+\tfor fully-masked loops and vect_set_loop_condition_unmasked otherwise.\n+\t(vect_do_peeling): Update call accordingly.\n+\t(vect_gen_vector_loop_niters): Use VF as the step for fully-masked\n+\tloops.\n+\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize\n+\tmask_compare_type, can_fully_mask_p and fully_masked_p.\n+\t(release_vec_loop_masks): New function.\n+\t(_loop_vec_info): Use it to free the loop masks.\n+\t(can_produce_all_loop_masks_p): New function.\n+\t(vect_get_max_nscalars_per_iter): Likewise.\n+\t(vect_verify_full_masking): Likewise.\n+\t(vect_analyze_loop_2): Save LOOP_VINFO_CAN_FULLY_MASK_P around\n+\tretries, and free the mask rgroups before retrying.  Check loop-wide\n+\treasons for disallowing fully-masked loops.  Make the final decision\n+\tabout whether use a fully-masked loop or not.\n+\t(vect_estimate_min_profitable_iters): Do not assume that peeling\n+\tfor the number of iterations will be needed for fully-masked loops.\n+\t(vectorizable_reduction): Disable fully-masked loops.\n+\t(vectorizable_live_operation): Likewise.\n+\t(vect_halve_mask_nunits): New function.\n+\t(vect_double_mask_nunits): Likewise.\n+\t(vect_record_loop_mask): Likewise.\n+\t(vect_get_loop_mask): Likewise.\n+\t(vect_transform_loop): Handle the case in which the final loop\n+\titeration might handle a partial vector.  Call vect_set_loop_condition\n+\tinstead of slpeel_make_loop_iterate_ntimes.\n+\t* tree-vect-stmts.c: Include tree-ssa-loop-niter.h and gimple-fold.h.\n+\t(check_load_store_masking): New function.\n+\t(prepare_load_store_mask): Likewise.\n+\t(vectorizable_store): Handle fully-masked loops.\n+\t(vectorizable_load): Likewise.\n+\t(supportable_widening_operation): Use vect_halve_mask_nunits for\n+\tbooleans.\n+\t(supportable_narrowing_operation): Likewise vect_double_mask_nunits.\n+\t(vect_gen_while): New function.\n+\t* config/aarch64/aarch64.md (umax<mode>3): New expander.\n+\t(aarch64_uqdec<mode>): New insn.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "f2689d7d1d5c5157a8acbd638e51137d28b6e18b", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -3496,6 +3496,63 @@\n   [(set_attr \"type\" \"csel\")]\n )\n \n+;; If X can be loaded by a single CNT[BHWD] instruction,\n+;;\n+;;    A = UMAX (B, X)\n+;;\n+;; is equivalent to:\n+;;\n+;;    TMP = UQDEC[BHWD] (B, X)\n+;;    A = TMP + X\n+;;\n+;; Defining the pattern this way means that:\n+;;\n+;;    A = UMAX (B, X) - X\n+;;\n+;; becomes:\n+;;\n+;;    TMP1 = UQDEC[BHWD] (B, X)\n+;;    TMP2 = TMP1 + X\n+;;    A = TMP2 - X\n+;;\n+;; which combine can optimize to:\n+;;\n+;;    A = UQDEC[BHWD] (B, X)\n+;;\n+;; We don't use match_operand predicates because the order of the operands\n+;; can vary: the CNT[BHWD] constant will come first if the other operand is\n+;; a simpler constant (such as a CONST_INT), otherwise it will come second.\n+(define_expand \"umax<mode>3\"\n+  [(set (match_operand:GPI 0 \"register_operand\")\n+\t(umax:GPI (match_operand:GPI 1 \"\")\n+\t\t  (match_operand:GPI 2 \"\")))]\n+  \"TARGET_SVE\"\n+  {\n+    if (aarch64_sve_cnt_immediate (operands[1], <MODE>mode))\n+      std::swap (operands[1], operands[2]);\n+    else if (!aarch64_sve_cnt_immediate (operands[2], <MODE>mode))\n+      FAIL;\n+    rtx temp = gen_reg_rtx (<MODE>mode);\n+    operands[1] = force_reg (<MODE>mode, operands[1]);\n+    emit_insn (gen_aarch64_uqdec<mode> (temp, operands[1], operands[2]));\n+    emit_insn (gen_add<mode>3 (operands[0], temp, operands[2]));\n+    DONE;\n+  }\n+)\n+\n+;; Saturating unsigned subtraction of a CNT[BHWD] immediate.\n+(define_insn \"aarch64_uqdec<mode>\"\n+  [(set (match_operand:GPI 0 \"register_operand\" \"=r\")\n+\t(minus:GPI\n+\t (umax:GPI (match_operand:GPI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:GPI 2 \"aarch64_sve_cnt_immediate\" \"Usv\"))\n+\t (match_dup 2)))]\n+  \"TARGET_SVE\"\n+  {\n+    return aarch64_output_sve_cnt_immediate (\"uqdec\", \"%<w>0\", operands[2]);\n+  }\n+)\n+\n ;; -------------------------------------------------------------------\n ;; Logical operations\n ;; -------------------------------------------------------------------"}, {"sha": "f4e89c39d5d2fba9c2112c7e01c7195cf53248da", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -4954,6 +4954,19 @@ rounding behavior for @var{i} > 1.\n \n This pattern is not allowed to @code{FAIL}.\n \n+@cindex @code{while_ult@var{m}@var{n}} instruction pattern\n+@item @code{while_ult@var{m}@var{n}}\n+Set operand 0 to a mask that is true while incrementing operand 1\n+gives a value that is less than operand 2.  Operand 0 has mode @var{n}\n+and operands 1 and 2 are scalar integers of mode @var{m}.\n+The operation is equivalent to:\n+\n+@smallexample\n+operand0[0] = operand1 < operand2;\n+for (i = 1; i < GET_MODE_NUNITS (@var{n}); i++)\n+  operand0[i] = operand0[i - 1] && (operand1 + i < operand2);\n+@end smallexample\n+\n @cindex @code{vec_cmp@var{m}@var{n}} instruction pattern\n @item @samp{vec_cmp@var{m}@var{n}}\n Output a vector comparison.  Operand 0 of mode @var{n} is the destination for"}, {"sha": "44d5486adc5a7165260a6c3765b444ceebcabdad", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -88,6 +88,7 @@ init_internal_fns ()\n #define mask_store_lanes_direct { 0, 0, false }\n #define unary_direct { 0, 0, true }\n #define binary_direct { 0, 0, true }\n+#define while_direct { 0, 2, false }\n \n const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1] = {\n #define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) not_direct,\n@@ -2817,6 +2818,35 @@ expand_direct_optab_fn (internal_fn fn, gcall *stmt, direct_optab optab,\n     }\n }\n \n+/* Expand WHILE_ULT call STMT using optab OPTAB.  */\n+\n+static void\n+expand_while_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n+{\n+  expand_operand ops[3];\n+  tree rhs_type[2];\n+\n+  tree lhs = gimple_call_lhs (stmt);\n+  tree lhs_type = TREE_TYPE (lhs);\n+  rtx lhs_rtx = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  create_output_operand (&ops[0], lhs_rtx, TYPE_MODE (lhs_type));\n+\n+  for (unsigned int i = 0; i < 2; ++i)\n+    {\n+      tree rhs = gimple_call_arg (stmt, i);\n+      rhs_type[i] = TREE_TYPE (rhs);\n+      rtx rhs_rtx = expand_normal (rhs);\n+      create_input_operand (&ops[i + 1], rhs_rtx, TYPE_MODE (rhs_type[i]));\n+    }\n+\n+  insn_code icode = convert_optab_handler (optab, TYPE_MODE (rhs_type[0]),\n+\t\t\t\t\t   TYPE_MODE (lhs_type));\n+\n+  expand_insn (icode, 3, ops);\n+  if (!rtx_equal_p (lhs_rtx, ops[0].value))\n+    emit_move_insn (lhs_rtx, ops[0].value);\n+}\n+\n /* Expanders for optabs that can use expand_direct_optab_fn.  */\n \n #define expand_unary_optab_fn(FN, STMT, OPTAB) \\\n@@ -2869,6 +2899,19 @@ direct_optab_supported_p (direct_optab optab, tree_pair types,\n   return direct_optab_handler (optab, mode, opt_type) != CODE_FOR_nothing;\n }\n \n+/* Return true if OPTAB is supported for TYPES, where the first type\n+   is the destination and the second type is the source.  Used for\n+   convert optabs.  */\n+\n+static bool\n+convert_optab_supported_p (convert_optab optab, tree_pair types,\n+\t\t\t   optimization_type opt_type)\n+{\n+  return (convert_optab_handler (optab, TYPE_MODE (types.first),\n+\t\t\t\t TYPE_MODE (types.second), opt_type)\n+\t  != CODE_FOR_nothing);\n+}\n+\n /* Return true if load/store lanes optab OPTAB is supported for\n    array type TYPES.first when the optimization type is OPT_TYPE.  */\n \n@@ -2891,6 +2934,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_mask_store_optab_supported_p direct_optab_supported_p\n #define direct_store_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_mask_store_lanes_optab_supported_p multi_vector_optab_supported_p\n+#define direct_while_optab_supported_p convert_optab_supported_p\n \n /* Return the optab used by internal function FN.  */\n "}, {"sha": "39dd7fc15c276132a3a49e985b85c87a72d7cfcc", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -116,6 +116,8 @@ DEF_INTERNAL_OPTAB_FN (STORE_LANES, ECF_CONST, vec_store_lanes, store_lanes)\n DEF_INTERNAL_OPTAB_FN (MASK_STORE_LANES, 0,\n \t\t       vec_mask_store_lanes, mask_store_lanes)\n \n+DEF_INTERNAL_OPTAB_FN (WHILE_ULT, ECF_CONST | ECF_NOTHROW, while_ult, while)\n+\n DEF_INTERNAL_OPTAB_FN (VEC_SHL_INSERT, ECF_CONST | ECF_NOTHROW,\n \t\t       vec_shl_insert, binary)\n "}, {"sha": "22c15f25db5e491291bfb2b4da5a6c374f7cda59", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -174,6 +174,20 @@ extern bool direct_internal_fn_supported_p (internal_fn, tree_pair,\n \t\t\t\t\t    optimization_type);\n extern bool direct_internal_fn_supported_p (internal_fn, tree,\n \t\t\t\t\t    optimization_type);\n+\n+/* Return true if FN is supported for types TYPE0 and TYPE1 when the\n+   optimization type is OPT_TYPE.  The types are those associated with\n+   the \"type0\" and \"type1\" fields of FN's direct_internal_fn_info\n+   structure.  */\n+\n+inline bool\n+direct_internal_fn_supported_p (internal_fn fn, tree type0, tree type1,\n+\t\t\t\toptimization_type opt_type)\n+{\n+  return direct_internal_fn_supported_p (fn, tree_pair (type0, type1),\n+\t\t\t\t\t opt_type);\n+}\n+\n extern bool set_edom_supported_p (void);\n \n extern void expand_internal_call (gcall *);"}, {"sha": "318a2c7c8442aef94661fce3f4afcac2f35deff0", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -94,6 +94,8 @@ OPTAB_CD(maskstore_optab, \"maskstore$a$b\")\n OPTAB_CD(vec_extract_optab, \"vec_extract$a$b\")\n OPTAB_CD(vec_init_optab, \"vec_init$a$b\")\n \n+OPTAB_CD (while_ult_optab, \"while_ult$a$b\")\n+\n OPTAB_NL(add_optab, \"add$P$a3\", PLUS, \"add\", '3', gen_int_fp_fixed_libfunc)\n OPTAB_NX(add_optab, \"add$F$a3\")\n OPTAB_NX(add_optab, \"add$Q$a3\")"}, {"sha": "a7370ec9679156312dee96ad9bddf58b13afbee2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -1,3 +1,35 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.dg/tree-ssa/cunroll-10.c: Disable vectorization.\n+\t* gcc.dg/tree-ssa/peel1.c: Likewise.\n+\t* gcc.dg/vect/vect-load-lanes-peeling-1.c: Remove XFAIL for\n+\tvariable-length vectors.\n+\t* gcc.target/aarch64/sve/vcond_6.c: XFAIL test for AND.\n+\t* gcc.target/aarch64/sve/vec_bool_cmp_1.c: Expect BIC instead of NOT.\n+\t* gcc.target/aarch64/sve/slp_1.c: Check for a fully-masked loop.\n+\t* gcc.target/aarch64/sve/slp_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_8.c: New test.\n+\t* gcc.target/aarch64/sve/slp_8_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_9.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_9_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_10.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_10_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_11.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_11_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_12.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_12_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/ld1r_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/ld1r_2_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/while_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/while_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/while_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/while_4.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "d28029a1083493146642f8c32032262c7f9d6ca5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-10.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -Warray-bounds -fdump-tree-cunroll-details\" } */\n+/* { dg-options \"-O3 -Warray-bounds -fno-tree-vectorize -fdump-tree-cunroll-details\" } */\n int a[3];\n int b[4];\n int"}, {"sha": "36f3ea063ea1e2bf035a152f6759d58d25abd8fc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/peel1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpeel1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpeel1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpeel1.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -fdump-tree-cunroll-details\" } */\n+/* { dg-options \"-O3 -fno-tree-vectorize -fdump-tree-cunroll-details\" } */\n struct foo {int b; int a[3];} foo;\n void add(struct foo *a,int l)\n {"}, {"sha": "c9cd104e8e5885601d502c0a3ef4baa13d34150f", "filename": "gcc/testsuite/gcc.dg/vect/vect-load-lanes-peeling-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-load-lanes-peeling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-load-lanes-peeling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-load-lanes-peeling-1.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -10,4 +10,4 @@ f (int *__restrict a, int *__restrict b)\n }\n \n /* { dg-final { scan-tree-dump-not \"Data access with gaps\" \"vect\" } } */\n-/* { dg-final { scan-tree-dump-not \"epilog loop required\" \"vect\" { xfail vect_variable_length } } } */\n+/* { dg-final { scan-tree-dump-not \"epilog loop required\" \"vect\" } } */"}, {"sha": "2e6b59ab458bb731a82173179d743d834bf6cc14", "filename": "gcc/testsuite/gcc.target/aarch64/sve/ld1r_2.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fld1r_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fld1r_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fld1r_2.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-tree-loop-distribute-patterns\" } */\n+\n+#include <stdint.h>\n+\n+#define NUM_ELEMS(TYPE) (1024 / sizeof (TYPE))\n+\n+#define DEF_LOAD_BROADCAST(TYPE)\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\\\n+  set_##TYPE (TYPE *restrict a, TYPE *restrict b)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < NUM_ELEMS (TYPE); i++)\t\t\\\n+      a[i] = *b;\t\t\t\t\t\\\n+  }\n+\n+#define DEF_LOAD_BROADCAST_IMM(TYPE, IMM, SUFFIX)\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\\\n+  set_##TYPE##_##SUFFIX (TYPE *a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < NUM_ELEMS (TYPE); i++)\t\t\\\n+      a[i] = IMM;\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_LOAD_BROADCAST(T)\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (int64_t)\n+\n+#define FOR_EACH_LOAD_BROADCAST_IMM(T)\t\t\t\t\t\\\n+  T (int16_t, 129, imm_129)\t\t\t\t\t\t\\\n+  T (int32_t, 129, imm_129)\t\t\t\t\t\t\\\n+  T (int64_t, 129, imm_129)\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  T (int16_t, -130, imm_m130)\t\t\t\t\t\t\\\n+  T (int32_t, -130, imm_m130)\t\t\t\t\t\t\\\n+  T (int64_t, -130, imm_m130)\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  T (int16_t, 0x1234, imm_0x1234)\t\t\t\t\t\\\n+  T (int32_t, 0x1234, imm_0x1234)\t\t\t\t\t\\\n+  T (int64_t, 0x1234, imm_0x1234)\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  T (int16_t, 0xFEDC, imm_0xFEDC)\t\t\t\t\t\\\n+  T (int32_t, 0xFEDC, imm_0xFEDC)\t\t\t\t\t\\\n+  T (int64_t, 0xFEDC, imm_0xFEDC)\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  T (int32_t, 0x12345678, imm_0x12345678)\t\t\t\t\\\n+  T (int64_t, 0x12345678, imm_0x12345678)\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  T (int32_t, 0xF2345678, imm_0xF2345678)\t\t\t\t\\\n+  T (int64_t, 0xF2345678, imm_0xF2345678)\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  T (int64_t, (int64_t) 0xFEBA716B12371765, imm_FEBA716B12371765)\n+\n+FOR_EACH_LOAD_BROADCAST (DEF_LOAD_BROADCAST)\n+FOR_EACH_LOAD_BROADCAST_IMM (DEF_LOAD_BROADCAST_IMM)\n+\n+/* { dg-final { scan-assembler-times {\\tld1rb\\tz[0-9]+\\.b, p[0-7]/z, } 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1rh\\tz[0-9]+\\.h, p[0-7]/z, } 5 } } */\n+/* { dg-final { scan-assembler-times {\\tld1rw\\tz[0-9]+\\.s, p[0-7]/z, } 7 } } */\n+/* { dg-final { scan-assembler-times {\\tld1rd\\tz[0-9]+\\.d, p[0-7]/z, } 8 } } */"}, {"sha": "c067b88ba94fa7f686b8f93a314ab70e7725161d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/ld1r_2_run.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fld1r_2_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fld1r_2_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fld1r_2_run.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O3 -fno-tree-loop-distribute-patterns\" } */\n+\n+#include \"ld1r_2.c\"\n+\n+#define TEST_LOAD_BROADCAST(TYPE)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TYPE v[NUM_ELEMS (TYPE)];\t\t\t\\\n+    TYPE val = 99;\t\t\t\t\\\n+    set_##TYPE (v, &val);\t\t\t\\\n+    for (int i = 0; i < NUM_ELEMS (TYPE); i++)\t\\\n+      {\t\t\t\t\t\t\\\n+\tif (v[i] != (TYPE) 99)\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\\\n+      }\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST_LOAD_BROADCAST_IMM(TYPE, IMM, SUFFIX)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    TYPE v[NUM_ELEMS (TYPE)];\t\t\t\t\\\n+    set_##TYPE##_##SUFFIX (v);\t\t\t\t\\\n+    for (int i = 0; i < NUM_ELEMS (TYPE); i++ )\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (v[i] != (TYPE) IMM)\t\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (int argc, char **argv)\n+{\n+  FOR_EACH_LOAD_BROADCAST (TEST_LOAD_BROADCAST)\n+  FOR_EACH_LOAD_BROADCAST_IMM (TEST_LOAD_BROADCAST_IMM)\n+\n+  return 0;\n+}"}, {"sha": "07d71a63414b1066ea431e287286ad048515711a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_1.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_1.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -38,3 +38,22 @@ TEST_ALL (VEC_PERM)\n /* { dg-final { scan-assembler-times {\\tmov\\tz[0-9]+\\.d, [dx]} 9 } } */\n /* { dg-final { scan-assembler-times {\\tzip1\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */\n /* { dg-final { scan-assembler-not {\\tzip2\\t} } } */\n+\n+/* The loop should be fully-masked.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d} 6 } } */\n+/* { dg-final { scan-assembler-not {\\tldr} } } */\n+/* { dg-final { scan-assembler-times {\\tstr} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstr\\th[0-9]+} 2 } } */\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec} } } */"}, {"sha": "6fe9f25096c787da733004266a7b05e4f6001029", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_10.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_10.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+\n+#include <stdint.h>\n+\n+#define VEC_PERM(TYPE)\t\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\\\n+vec_slp_##TYPE (TYPE *restrict a, TYPE *restrict b, int n)\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      a[i] += 1;\t\t\t\t\t\t\\\n+      b[i * 4] += 2;\t\t\t\t\t\t\\\n+      b[i * 4 + 1] += 3;\t\t\t\t\t\\\n+      b[i * 4 + 2] += 4;\t\t\t\t\t\\\n+      b[i * 4 + 3] += 5;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (uint8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (uint16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (uint32_t)\t\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (float)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (VEC_PERM)\n+\n+/* The loop should be fully-masked.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 10 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\t} 10 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 10 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\t} 10 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 15 } } */\n+/* { dg-final { scan-assembler-not {\\tldr} } } */\n+/* { dg-final { scan-assembler-not {\\tstr} } } */\n+\n+/* We should use WHILEs for all accesses.  */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b} 20 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 20 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 30 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d} 30 } } */\n+\n+/* 6 for the 8-bit types and 2 for the 16-bit types.  */\n+/* { dg-final { scan-assembler-times {\\tuqdecb\\t} 8 } } */\n+/* 4 for the 16-bit types and 3 for the 32-bit types.  */\n+/* { dg-final { scan-assembler-times {\\tuqdech\\t} 7 } } */\n+/* 6 for the 32-bit types and 3 for the 64-bit types.  */\n+/* { dg-final { scan-assembler-times {\\tuqdecw\\t} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tuqdecd\\t} 6 } } */"}, {"sha": "ec1afcea84572a598d67b9b1d185217e77a0f579", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_10_run.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_10_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_10_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_10_run.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"slp_10.c\"\n+\n+#define N1 (103 * 2)\n+#define N2 (111 * 2)\n+\n+#define HARNESS(TYPE)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE a[N2], b[N2 * 4];\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\ta[i] = i * 2 + i % 5;\t\t\t\t\t\\\n+\tb[i * 4] = i * 3 + i % 7;\t\t\t\t\\\n+\tb[i * 4 + 1] = i * 5 + i % 9;\t\t\t\t\\\n+\tb[i * 4 + 2] = i * 7 + i % 11;\t\t\t\t\\\n+\tb[i * 4 + 3] = i * 9 + i % 13;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    vec_slp_##TYPE (a, b, N1);\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE orig_a = i * 2 + i % 5;\t\t\t\t\\\n+\tTYPE orig_b1 = i * 3 + i % 7;\t\t\t\t\\\n+\tTYPE orig_b2 = i * 5 + i % 9;\t\t\t\t\\\n+\tTYPE orig_b3 = i * 7 + i % 11;\t\t\t\t\\\n+\tTYPE orig_b4 = i * 9 + i % 13;\t\t\t\t\\\n+\tTYPE expected_a = orig_a;\t\t\t\t\\\n+\tTYPE expected_b1 = orig_b1;\t\t\t\t\\\n+\tTYPE expected_b2 = orig_b2;\t\t\t\t\\\n+\tTYPE expected_b3 = orig_b3;\t\t\t\t\\\n+\tTYPE expected_b4 = orig_b4;\t\t\t\t\\\n+\tif (i < N1)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    expected_a += 1;\t\t\t\t\t\\\n+\t    expected_b1 += 2;\t\t\t\t\t\\\n+\t    expected_b2 += 3;\t\t\t\t\t\\\n+\t    expected_b3 += 4;\t\t\t\t\t\\\n+\t    expected_b4 += 5;\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\tif (a[i] != expected_a\t\t\t\t\t\\\n+\t    || b[i * 4] != expected_b1\t\t\t\t\\\n+\t    || b[i * 4 + 1] != expected_b2\t\t\t\\\n+\t    || b[i * 4 + 2] != expected_b3\t\t\t\\\n+\t    || b[i * 4 + 3] != expected_b4)\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST_ALL (HARNESS)\n+}"}, {"sha": "3c3b088140751f172a885d480bdb8b8f3b37d1b0", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_11.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_11.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+\n+#include <stdint.h>\n+\n+#define VEC_PERM(TYPE1, TYPE2)\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\\\n+vec_slp_##TYPE1##_##TYPE2 (TYPE1 *restrict a,\t\t\t\\\n+\t\t\t   TYPE2 *restrict b, int n)\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      a[i * 2] += 1;\t\t\t\t\t\t\\\n+      a[i * 2 + 1] += 2;\t\t\t\t\t\\\n+      b[i * 4] += 3;\t\t\t\t\t\t\\\n+      b[i * 4 + 1] += 4;\t\t\t\t\t\\\n+      b[i * 4 + 2] += 5;\t\t\t\t\t\\\n+      b[i * 4 + 3] += 6;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int16_t, uint8_t)\t\t\t\t\\\n+  T (uint16_t, int8_t)\t\t\t\t\\\n+  T (int32_t, uint16_t)\t\t\t\t\\\n+  T (uint32_t, int16_t)\t\t\t\t\\\n+  T (float, uint16_t)\t\t\t\t\\\n+  T (int64_t, float)\t\t\t\t\\\n+  T (uint64_t, int32_t)\t\t\t\t\\\n+  T (double, uint32_t)\n+\n+TEST_ALL (VEC_PERM)\n+\n+/* The loop should be fully-masked.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 5 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\t} 5 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 3 } } */\n+/* { dg-final { scan-assembler-not {\\tldr} } } */\n+/* { dg-final { scan-assembler-not {\\tstr} } } */\n+\n+/* We should use the same WHILEs for both accesses.  */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 6 } } */\n+/* { dg-final { scan-assembler-not {\\twhilelo\\tp[0-7]\\.d} } } */\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec} } } */"}, {"sha": "6d515b96e8a996cf44585ad7f5a7e8d12d97d279", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_11_run.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_11_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_11_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_11_run.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"slp_11.c\"\n+\n+#define N1 (103 * 2)\n+#define N2 (111 * 2)\n+\n+#define HARNESS(TYPE1, TYPE2)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE1 a[N2];\t\t\t\t\t\t\\\n+    TYPE2 b[N2 * 2];\t\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\ta[i] = i * 2 + i % 5;\t\t\t\t\t\\\n+\tb[i * 2] = i * 3 + i % 7;\t\t\t\t\\\n+\tb[i * 2 + 1] = i * 5 + i % 9;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    vec_slp_##TYPE1##_##TYPE2 (a, b, N1 / 2);\t\t\t\\\n+    for (unsigned int i = 0; i < N2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE1 orig_a = i * 2 + i % 5;\t\t\t\t\\\n+\tTYPE2 orig_b1 = i * 3 + i % 7;\t\t\t\t\\\n+\tTYPE2 orig_b2 = i * 5 + i % 9;\t\t\t\t\\\n+\tTYPE1 expected_a = orig_a;\t\t\t\t\\\n+\tTYPE2 expected_b1 = orig_b1;\t\t\t\t\\\n+\tTYPE2 expected_b2 = orig_b2;\t\t\t\t\\\n+\tif (i < N1)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    expected_a += i & 1 ? 2 : 1;\t\t\t\\\n+\t    expected_b1 += i & 1 ? 5 : 3;\t\t\t\\\n+\t    expected_b2 += i & 1 ? 6 : 4;\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\tif (a[i] != expected_a\t\t\t\t\t\\\n+\t    || b[i * 2] != expected_b1\t\t\t\t\\\n+\t    || b[i * 2 + 1] != expected_b2)\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST_ALL (HARNESS)\n+}"}, {"sha": "0b9f8d9bdfaaf868ba0bd73ae83894c68e1613f8", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_12.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_12.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+\n+#include <stdint.h>\n+\n+#define N1 (19 * 2)\n+\n+#define VEC_PERM(TYPE)\t\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\\\n+vec_slp_##TYPE (TYPE *restrict a, TYPE *restrict b)\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < N1; ++i)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      a[i] += 1;\t\t\t\t\t\t\\\n+      b[i * 4] += 2;\t\t\t\t\t\t\\\n+      b[i * 4 + 1] += 3;\t\t\t\t\t\\\n+      b[i * 4 + 2] += 4;\t\t\t\t\t\\\n+      b[i * 4 + 3] += 5;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (uint8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (uint16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (uint32_t)\t\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (float)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (VEC_PERM)\n+\n+/* The loop should be fully-masked.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 10 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\t} 10 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 10 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\t} 10 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 15 } } */\n+/* { dg-final { scan-assembler-not {\\tldr} } } */\n+/* { dg-final { scan-assembler-not {\\tstr} } } */\n+\n+/* We should use WHILEs for all accesses.  */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b} 20 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 20 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 30 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d} 30 } } */\n+\n+/* 6 for the 8-bit types and 2 for the 16-bit types.  */\n+/* { dg-final { scan-assembler-times {\\tuqdecb\\t} 8 } } */\n+/* 4 for the 16-bit types and 3 for the 32-bit types.  */\n+/* { dg-final { scan-assembler-times {\\tuqdech\\t} 7 } } */\n+/* 6 for the 32-bit types and 3 for the 64-bit types.  */\n+/* { dg-final { scan-assembler-times {\\tuqdecw\\t} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tuqdecd\\t} 6 } } */"}, {"sha": "1c2734f43f8016c0be33df5d10874637c2ee1581", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_12_run.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_12_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_12_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_12_run.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"slp_12.c\"\n+\n+#define N2 (31 * 2)\n+\n+#define HARNESS(TYPE)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE a[N2], b[N2 * 4];\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\ta[i] = i * 2 + i % 5;\t\t\t\t\t\\\n+\tb[i * 4] = i * 3 + i % 7;\t\t\t\t\\\n+\tb[i * 4 + 1] = i * 5 + i % 9;\t\t\t\t\\\n+\tb[i * 4 + 2] = i * 7 + i % 11;\t\t\t\t\\\n+\tb[i * 4 + 3] = i * 9 + i % 13;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    vec_slp_##TYPE (a, b);\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE orig_a = i * 2 + i % 5;\t\t\t\t\\\n+\tTYPE orig_b1 = i * 3 + i % 7;\t\t\t\t\\\n+\tTYPE orig_b2 = i * 5 + i % 9;\t\t\t\t\\\n+\tTYPE orig_b3 = i * 7 + i % 11;\t\t\t\t\\\n+\tTYPE orig_b4 = i * 9 + i % 13;\t\t\t\t\\\n+\tTYPE expected_a = orig_a;\t\t\t\t\\\n+\tTYPE expected_b1 = orig_b1;\t\t\t\t\\\n+\tTYPE expected_b2 = orig_b2;\t\t\t\t\\\n+\tTYPE expected_b3 = orig_b3;\t\t\t\t\\\n+\tTYPE expected_b4 = orig_b4;\t\t\t\t\\\n+\tif (i < N1)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    expected_a += 1;\t\t\t\t\t\\\n+\t    expected_b1 += 2;\t\t\t\t\t\\\n+\t    expected_b2 += 3;\t\t\t\t\t\\\n+\t    expected_b3 += 4;\t\t\t\t\t\\\n+\t    expected_b4 += 5;\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\tif (a[i] != expected_a\t\t\t\t\t\\\n+\t    || b[i * 4] != expected_b1\t\t\t\t\\\n+\t    || b[i * 4 + 1] != expected_b2\t\t\t\\\n+\t    || b[i * 4 + 2] != expected_b3\t\t\t\\\n+\t    || b[i * 4 + 3] != expected_b4)\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST_ALL (HARNESS)\n+}"}, {"sha": "4a219f21155bb396aadaeef923a52087e65e0b18", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_2.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_2.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -35,3 +35,21 @@ TEST_ALL (VEC_PERM)\n /* { dg-final { scan-assembler-times {\\tld1rqb\\tz[0-9]+\\.b, } 3 } } */\n /* { dg-final { scan-assembler-not {\\tzip1\\t} } } */\n /* { dg-final { scan-assembler-not {\\tzip2\\t} } } */\n+\n+/* The loop should be fully-masked.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d} 6 } } */\n+/* { dg-final { scan-assembler-not {\\tldr} } } */\n+/* { dg-final { scan-assembler-not {\\tstr} } } */\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec} } } */"}, {"sha": "cfe20a8991715f2db1f3c775961cd4c6fa207c4e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_3.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_3.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -47,3 +47,23 @@ TEST_ALL (VEC_PERM)\n       ZIP1 ZIP2.  */\n /* { dg-final { scan-assembler-times {\\tzip1\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 9 } } */\n /* { dg-final { scan-assembler-times {\\tzip2\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */\n+\n+/* The loop should be fully-masked.  The 64-bit types need two loads\n+   and stores each.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d} 12 } } */\n+/* { dg-final { scan-assembler-not {\\tldr} } } */\n+/* { dg-final { scan-assembler-not {\\tstr} } } */\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec[bhw]\\t} } } */\n+/* { dg-final { scan-assembler-times {\\tuqdecd\\t} 3 } } */"}, {"sha": "98ff68f68df6d8b086a7145ad2d447d74dcc1728", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_4.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_4.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -59,3 +59,25 @@ TEST_ALL (VEC_PERM)\n       ZIP1 ZIP2 ZIP1 ZIP2.  */\n /* { dg-final { scan-assembler-times {\\tzip1\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 33 } } */\n /* { dg-final { scan-assembler-times {\\tzip2\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 15 } } */\n+\n+/* The loop should be fully-masked.  The 32-bit types need two loads\n+   and stores each and the 64-bit types need four.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 12 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 12 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 12 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d} 24 } } */\n+/* { dg-final { scan-assembler-not {\\tldr} } } */\n+/* { dg-final { scan-assembler-not {\\tstr} } } */\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec[bh]\\t} } } */\n+/* We use UQDECW instead of UQDECD ..., MUL #2.  */\n+/* { dg-final { scan-assembler-times {\\tuqdecw\\t} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tuqdecd\\t} 6 } } */"}, {"sha": "80fa3502f70042199d01a8f9db0da9e84e146a92", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_6.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_6.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -45,3 +45,5 @@ TEST_ALL (VEC_PERM)\n /* { dg-final { scan-assembler {\\tld3h\\t} } } */\n /* { dg-final { scan-assembler {\\tld3w\\t} } } */\n /* { dg-final { scan-assembler {\\tld3d\\t} } } */\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec} } } */"}, {"sha": "6cf57d26f91b85f716eb1f919f17df3b427451a2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_8.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_8.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+#define VEC_PERM(TYPE)\t\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\\\n+vec_slp_##TYPE (TYPE *restrict a, TYPE *restrict b, int n)\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      a[i * 2] += 1;\t\t\t\t\t\t\\\n+      a[i * 2 + 1] += 2;\t\t\t\t\t\\\n+      b[i * 4] += 3;\t\t\t\t\t\t\\\n+      b[i * 4 + 1] += 4;\t\t\t\t\t\\\n+      b[i * 4 + 2] += 5;\t\t\t\t\t\\\n+      b[i * 4 + 3] += 6;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (uint8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (uint16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (uint32_t)\t\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (float)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (VEC_PERM)\n+\n+/* The loop should be fully-masked.  The load XFAILs for fixed-length\n+   SVE account for extra loads from the constant pool.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 6 { xfail { aarch64_sve && { ! vect_variable_length } } } } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\t} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 6 { xfail { aarch64_sve && { ! vect_variable_length } } } } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\t} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 9 { xfail { aarch64_sve && { ! vect_variable_length } } } } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 9 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 9 { xfail { aarch64_sve && { ! vect_variable_length } } } } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 9 } } */\n+/* { dg-final { scan-assembler-not {\\tldr} } } */\n+/* { dg-final { scan-assembler-not {\\tstr} } } */\n+\n+/* We should use WHILEs for the accesses to \"a\" and ZIPs for the accesses\n+   to \"b\".  */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tzip1\\tp[0-7]\\.b} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tzip1\\tp[0-7]\\.h} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tzip1\\tp[0-7]\\.s} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tzip1\\tp[0-7]\\.d} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tzip2\\tp[0-7]\\.b} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tzip2\\tp[0-7]\\.h} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tzip2\\tp[0-7]\\.s} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tzip2\\tp[0-7]\\.d} 3 } } */\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec} } } */"}, {"sha": "3ef1e93c864df18a016314c7db6809aa2c9687d2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_8_run.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_8_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_8_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_8_run.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"slp_8.c\"\n+\n+#define N1 (103 * 2)\n+#define N2 (111 * 2)\n+\n+#define HARNESS(TYPE)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE a[N2], b[N2 * 2];\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\ta[i] = i * 2 + i % 5;\t\t\t\t\t\\\n+\tb[i * 2] = i * 3 + i % 7;\t\t\t\t\\\n+\tb[i * 2 + 1] = i * 5 + i % 9;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    vec_slp_##TYPE (a, b, N1 / 2);\t\t\t\t\\\n+    for (unsigned int i = 0; i < N2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE orig_a = i * 2 + i % 5;\t\t\t\t\\\n+\tTYPE orig_b1 = i * 3 + i % 7;\t\t\t\t\\\n+\tTYPE orig_b2 = i * 5 + i % 9;\t\t\t\t\\\n+\tTYPE expected_a = orig_a;\t\t\t\t\\\n+\tTYPE expected_b1 = orig_b1;\t\t\t\t\\\n+\tTYPE expected_b2 = orig_b2;\t\t\t\t\\\n+\tif (i < N1)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    expected_a += i & 1 ? 2 : 1;\t\t\t\\\n+\t    expected_b1 += i & 1 ? 5 : 3;\t\t\t\\\n+\t    expected_b2 += i & 1 ? 6 : 4;\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\tif (a[i] != expected_a\t\t\t\t\t\\\n+\t    || b[i * 2] != expected_b1\t\t\t\t\\\n+\t    || b[i * 2 + 1] != expected_b2)\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST_ALL (HARNESS)\n+}"}, {"sha": "26b5f03c7f8ef51232809611b341198b65a02940", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_9.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_9.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+#define VEC_PERM(TYPE1, TYPE2)\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\\\n+vec_slp_##TYPE1##_##TYPE2 (TYPE1 *restrict a,\t\t\t\\\n+\t\t\t   TYPE2 *restrict b, int n)\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      a[i * 2] += 1;\t\t\t\t\t\t\\\n+      a[i * 2 + 1] += 2;\t\t\t\t\t\\\n+      b[i * 2] += 3;\t\t\t\t\t\t\\\n+      b[i * 2 + 1] += 4;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t, uint16_t)\t\t\t\t\\\n+  T (uint8_t, int16_t)\t\t\t\t\\\n+  T (int16_t, uint32_t)\t\t\t\t\\\n+  T (uint16_t, int32_t)\t\t\t\t\\\n+  T (int32_t, double)\t\t\t\t\\\n+  T (uint32_t, int64_t)\t\t\t\t\\\n+  T (float, uint64_t)\n+\n+TEST_ALL (VEC_PERM)\n+\n+/* The loop should be fully-masked.  The load XFAILs for fixed-length\n+   SVE account for extra loads from the constant pool.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 2 { xfail { aarch64_sve && { ! vect_variable_length } } } } }*/\n+/* { dg-final { scan-assembler-times {\\tst1b\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 6 { xfail { aarch64_sve && { ! vect_variable_length } } } } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\t} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 7 { xfail { aarch64_sve && { ! vect_variable_length } } } } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 7 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 6 { xfail { aarch64_sve && { ! vect_variable_length } } } } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 6 } } */\n+/* { dg-final { scan-assembler-not {\\tldr} } } */\n+/* { dg-final { scan-assembler-not {\\tstr} } } */\n+\n+/* We should use WHILEs for the accesses to \"a\" and unpacks for the accesses\n+   to \"b\".  */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 6 } } */\n+/* { dg-final { scan-assembler-not {\\twhilelo\\tp[0-7]\\.d} } } */\n+/* { dg-final { scan-assembler-times {\\tpunpklo\\tp[0-7]\\.h} 7 } } */\n+/* { dg-final { scan-assembler-times {\\tpunpkhi\\tp[0-7]\\.h} 7 } } */\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec} } } */"}, {"sha": "01b784ec78517ccfa24193b216deb5194630772f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_9_run.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_9_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_9_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_9_run.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"slp_9.c\"\n+\n+#define N1 (103 * 2)\n+#define N2 (111 * 2)\n+\n+#define HARNESS(TYPE1, TYPE2)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE1 a[N2];\t\t\t\t\t\t\\\n+    TYPE2 b[N2];\t\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\ta[i] = i * 2 + i % 5;\t\t\t\t\t\\\n+\tb[i] = i * 3 + i % 7;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    vec_slp_##TYPE1##_##TYPE2 (a, b, N1 / 2);\t\t\t\\\n+    for (unsigned int i = 0; i < N2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE1 orig_a = i * 2 + i % 5;\t\t\t\t\\\n+\tTYPE2 orig_b = i * 3 + i % 7;\t\t\t\t\\\n+\tTYPE1 expected_a = orig_a;\t\t\t\t\\\n+\tTYPE2 expected_b = orig_b;\t\t\t\t\\\n+\tif (i < N1)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    expected_a += i & 1 ? 2 : 1;\t\t\t\\\n+\t    expected_b += i & 1 ? 4 : 3;\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\tif (a[i] != expected_a || b[i] != expected_b)\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((noinline, noclone))\n+main (void)\n+{\n+  TEST_ALL (HARNESS)\n+}"}, {"sha": "67157e3453800210661edd9fe3078f652c224913", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_6.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_6.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -40,7 +40,8 @@\n \n TEST_ALL (LOOP)\n \n-/* { dg-final { scan-assembler-times {\\tand\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b, p[0-9]+\\.b} 3 } } */\n+/* Currently we don't manage to remove ANDs from the other loops.  */\n+/* { dg-final { scan-assembler-times {\\tand\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b, p[0-9]+\\.b} 3 { xfail *-*-* } } } */\n /* { dg-final { scan-assembler {\\tand\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b, p[0-9]+\\.b} } } */\n /* { dg-final { scan-assembler-times {\\torr\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b, p[0-9]+\\.b} 3 } } */\n /* { dg-final { scan-assembler-times {\\teor\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b, p[0-9]+\\.b} 3 } } */"}, {"sha": "3aa9086c17850da51e70535cc63c47f5248390fd", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vec_bool_cmp_1.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvec_bool_cmp_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvec_bool_cmp_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvec_bool_cmp_1.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -36,5 +36,6 @@ TEST_ALL (VEC_BOOL)\n \n /* Both cmpne and cmpeq loops will contain an exclusive predicate or.  */\n /* { dg-final { scan-assembler-times {\\teors?\\tp[0-9]*\\.b, p[0-7]/z, p[0-9]*\\.b, p[0-9]*\\.b\\n} 12 } } */\n-/* cmpeq will also contain a predicate not operation.  */\n-/* { dg-final { scan-assembler-times {\\tnot\\tp[0-9]*\\.b, p[0-7]/z, p[0-9]*\\.b\\n} 6 } } */\n+/* cmpeq will also contain a masked predicate not operation, which gets\n+   folded to BIC.  */\n+/* { dg-final { scan-assembler-times {\\tbic\\tp[0-9]+\\.b, p[0-7]/z, p[0-9]+\\.b, p[0-9]+\\.b\\n} 6 } } */"}, {"sha": "70ceec869754f872f3eae9d14f97f8b7b4cf2861", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_1.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+#define ADD_LOOP(TYPE)\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\\\n+  vec_while_##TYPE (TYPE *restrict a, int n)\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\\\n+      a[i] += 1;\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (uint8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (uint16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (uint32_t)\t\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (float)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (ADD_LOOP)\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec} } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b, xzr,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b, x[0-9]+,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h, xzr,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h, x[0-9]+,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, xzr,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, x[0-9]+,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, xzr,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, x[0-9]+,} 3 } } */"}, {"sha": "651bb57404229212f12c03fcd6687dfa89928b17", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_2.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_2.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+#define ADD_LOOP(TYPE)\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\\\n+  vec_while_##TYPE (TYPE *restrict a, unsigned int n)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < n; ++i)\t\t\\\n+      a[i] += 1;\t\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (uint8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (uint16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (uint32_t)\t\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (float)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (ADD_LOOP)\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec} } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b, xzr,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b, x[0-9]+,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h, xzr,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h, x[0-9]+,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, xzr,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, x[0-9]+,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, xzr,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, x[0-9]+,} 3 } } */"}, {"sha": "68d524e04ddfeecf56bb585f4e3d22ee8ab4723e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_3.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_3.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+#define ADD_LOOP(TYPE)\t\t\t\t\t\\\n+  TYPE __attribute__ ((noinline, noclone))\t\t\\\n+  vec_while_##TYPE (TYPE *restrict a, int64_t n)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (int64_t i = 0; i < n; ++i)\t\t\t\\\n+      a[i] += 1;\t\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (uint8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (uint16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (uint32_t)\t\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (float)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (ADD_LOOP)\n+\n+/* { dg-final { scan-assembler-not {\\tuqdec} } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b, xzr,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b, x[0-9]+,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h, xzr,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h, x[0-9]+,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, xzr,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, x[0-9]+,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, xzr,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, x[0-9]+,} 3 } } */"}, {"sha": "d8ec5364ab1801f218caac589b60b3eba4dbfb30", "filename": "gcc/testsuite/gcc.target/aarch64/sve/while_4.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fwhile_4.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+\n+#include <stdint.h>\n+\n+#define ADD_LOOP(TYPE)\t\t\t\t\t\\\n+  TYPE __attribute__ ((noinline, noclone))\t\t\\\n+  vec_while_##TYPE (TYPE *restrict a, uint64_t n)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (uint64_t i = 0; i < n; ++i)\t\t\t\\\n+      a[i] += 1;\t\t\t\t\t\\\n+  }\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (uint8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (uint16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (uint32_t)\t\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (float)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (ADD_LOOP)\n+\n+/* { dg-final { scan-assembler-times {\\tuqdec} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tuqdecb\\tx[0-9]+} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b, xzr,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.b, x[0-9]+,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h, xzr,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.h, x[0-9]+,} 2 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, xzr,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s, x[0-9]+,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, xzr,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d, x[0-9]+,} 3 } } */"}, {"sha": "496df38617dff9da24e9fbc48e0f48d3a38b39ea", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 486, "deletions": 34, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -42,6 +42,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vectorizer.h\"\n #include \"tree-ssa-loop-ivopts.h\"\n #include \"gimple-fold.h\"\n+#include \"tree-ssa-loop-niter.h\"\n+#include \"internal-fn.h\"\n+#include \"stor-layout.h\"\n+#include \"optabs-query.h\"\n+#include \"vec-perm-indices.h\"\n \n /*************************************************************************\n   Simple Loop Peeling Utilities\n@@ -248,33 +253,441 @@ adjust_phi_and_debug_stmts (gimple *update_phi, edge e, tree new_def)\n \t\t\tgimple_bb (update_phi));\n }\n \n-/* Make LOOP iterate N == (NITERS - STEP) / STEP + 1 times,\n-   where NITERS is known to be outside the range [1, STEP - 1].\n-   This is equivalent to making the loop execute NITERS / STEP\n-   times when NITERS is nonzero and (1 << M) / STEP times otherwise,\n-   where M is the precision of NITERS.\n+/* Define one loop mask MASK from loop LOOP.  INIT_MASK is the value that\n+   the mask should have during the first iteration and NEXT_MASK is the\n+   value that it should have on subsequent iterations.  */\n \n-   NITERS_MAYBE_ZERO is true if NITERS can be zero, false it is known\n-   to be >= STEP.  In the latter case N is always NITERS / STEP.\n+static void\n+vect_set_loop_mask (struct loop *loop, tree mask, tree init_mask,\n+\t\t    tree next_mask)\n+{\n+  gphi *phi = create_phi_node (mask, loop->header);\n+  add_phi_arg (phi, init_mask, loop_preheader_edge (loop), UNKNOWN_LOCATION);\n+  add_phi_arg (phi, next_mask, loop_latch_edge (loop), UNKNOWN_LOCATION);\n+}\n \n-   If FINAL_IV is nonnull, it is an SSA name that should be set to\n-   N * STEP on exit from the loop.\n+/* Add SEQ to the end of LOOP's preheader block.  */\n \n-   Assumption: the exit-condition of LOOP is the last stmt in the loop.  */\n+static void\n+add_preheader_seq (struct loop *loop, gimple_seq seq)\n+{\n+  if (seq)\n+    {\n+      edge pe = loop_preheader_edge (loop);\n+      basic_block new_bb = gsi_insert_seq_on_edge_immediate (pe, seq);\n+      gcc_assert (!new_bb);\n+    }\n+}\n \n-void\n-slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters, tree step,\n-\t\t\t\t tree final_iv, bool niters_maybe_zero)\n+/* Add SEQ to the beginning of LOOP's header block.  */\n+\n+static void\n+add_header_seq (struct loop *loop, gimple_seq seq)\n+{\n+  if (seq)\n+    {\n+      gimple_stmt_iterator gsi = gsi_after_labels (loop->header);\n+      gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n+    }\n+}\n+\n+/* Return true if the target can interleave elements of two vectors.\n+   OFFSET is 0 if the first half of the vectors should be interleaved\n+   or 1 if the second half should.  When returning true, store the\n+   associated permutation in INDICES.  */\n+\n+static bool\n+interleave_supported_p (vec_perm_indices *indices, tree vectype,\n+\t\t\tunsigned int offset)\n+{\n+  poly_uint64 nelts = TYPE_VECTOR_SUBPARTS (vectype);\n+  poly_uint64 base = exact_div (nelts, 2) * offset;\n+  vec_perm_builder sel (nelts, 2, 3);\n+  for (unsigned int i = 0; i < 3; ++i)\n+    {\n+      sel.quick_push (base + i);\n+      sel.quick_push (base + i + nelts);\n+    }\n+  indices->new_vector (sel, 2, nelts);\n+  return can_vec_perm_const_p (TYPE_MODE (vectype), *indices);\n+}\n+\n+/* Try to use permutes to define the masks in DEST_RGM using the masks\n+   in SRC_RGM, given that the former has twice as many masks as the\n+   latter.  Return true on success, adding any new statements to SEQ.  */\n+\n+static bool\n+vect_maybe_permute_loop_masks (gimple_seq *seq, rgroup_masks *dest_rgm,\n+\t\t\t       rgroup_masks *src_rgm)\n+{\n+  tree src_masktype = src_rgm->mask_type;\n+  tree dest_masktype = dest_rgm->mask_type;\n+  machine_mode src_mode = TYPE_MODE (src_masktype);\n+  if (dest_rgm->max_nscalars_per_iter <= src_rgm->max_nscalars_per_iter\n+      && optab_handler (vec_unpacku_hi_optab, src_mode) != CODE_FOR_nothing\n+      && optab_handler (vec_unpacku_lo_optab, src_mode) != CODE_FOR_nothing)\n+    {\n+      /* Unpacking the source masks gives at least as many mask bits as\n+\t we need.  We can then VIEW_CONVERT any excess bits away.  */\n+      tree unpack_masktype = vect_halve_mask_nunits (src_masktype);\n+      for (unsigned int i = 0; i < dest_rgm->masks.length (); ++i)\n+\t{\n+\t  tree src = src_rgm->masks[i / 2];\n+\t  tree dest = dest_rgm->masks[i];\n+\t  tree_code code = (i & 1 ? VEC_UNPACK_HI_EXPR\n+\t\t\t    : VEC_UNPACK_LO_EXPR);\n+\t  gassign *stmt;\n+\t  if (dest_masktype == unpack_masktype)\n+\t    stmt = gimple_build_assign (dest, code, src);\n+\t  else\n+\t    {\n+\t      tree temp = make_ssa_name (unpack_masktype);\n+\t      stmt = gimple_build_assign (temp, code, src);\n+\t      gimple_seq_add_stmt (seq, stmt);\n+\t      stmt = gimple_build_assign (dest, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t  build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t  dest_masktype, temp));\n+\t    }\n+\t  gimple_seq_add_stmt (seq, stmt);\n+\t}\n+      return true;\n+    }\n+  vec_perm_indices indices[2];\n+  if (dest_masktype == src_masktype\n+      && interleave_supported_p (&indices[0], src_masktype, 0)\n+      && interleave_supported_p (&indices[1], src_masktype, 1))\n+    {\n+      /* The destination requires twice as many mask bits as the source, so\n+\t we can use interleaving permutes to double up the number of bits.  */\n+      tree masks[2];\n+      for (unsigned int i = 0; i < 2; ++i)\n+\tmasks[i] = vect_gen_perm_mask_checked (src_masktype, indices[i]);\n+      for (unsigned int i = 0; i < dest_rgm->masks.length (); ++i)\n+\t{\n+\t  tree src = src_rgm->masks[i / 2];\n+\t  tree dest = dest_rgm->masks[i];\n+\t  gimple *stmt = gimple_build_assign (dest, VEC_PERM_EXPR,\n+\t\t\t\t\t      src, src, masks[i & 1]);\n+\t  gimple_seq_add_stmt (seq, stmt);\n+\t}\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Helper for vect_set_loop_condition_masked.  Generate definitions for\n+   all the masks in RGM and return a mask that is nonzero when the loop\n+   needs to iterate.  Add any new preheader statements to PREHEADER_SEQ.\n+   Use LOOP_COND_GSI to insert code before the exit gcond.\n+\n+   RGM belongs to loop LOOP.  The loop originally iterated NITERS\n+   times and has been vectorized according to LOOP_VINFO.  Each iteration\n+   of the vectorized loop handles VF iterations of the scalar loop.\n+\n+   It is known that:\n+\n+     NITERS * RGM->max_nscalars_per_iter\n+\n+   does not overflow.  However, MIGHT_WRAP_P says whether an induction\n+   variable that starts at 0 and has step:\n+\n+     VF * RGM->max_nscalars_per_iter\n+\n+   might overflow before hitting a value above:\n+\n+     NITERS * RGM->max_nscalars_per_iter\n+\n+   This means that we cannot guarantee that such an induction variable\n+   would ever hit a value that produces a set of all-false masks for RGM.  */\n+\n+static tree\n+vect_set_loop_masks_directly (struct loop *loop, loop_vec_info loop_vinfo,\n+\t\t\t      gimple_seq *preheader_seq,\n+\t\t\t      gimple_stmt_iterator loop_cond_gsi,\n+\t\t\t      rgroup_masks *rgm, tree vf,\n+\t\t\t      tree niters, bool might_wrap_p)\n+{\n+  tree compare_type = LOOP_VINFO_MASK_COMPARE_TYPE (loop_vinfo);\n+  tree mask_type = rgm->mask_type;\n+  unsigned int nscalars_per_iter = rgm->max_nscalars_per_iter;\n+  poly_uint64 nscalars_per_mask = TYPE_VECTOR_SUBPARTS (mask_type);\n+\n+  /* Calculate the maximum number of scalar values that the rgroup\n+     handles in total and the number that it handles for each iteration\n+     of the vector loop.  */\n+  tree nscalars_total = niters;\n+  tree nscalars_step = vf;\n+  if (nscalars_per_iter != 1)\n+    {\n+      /* We checked before choosing to use a fully-masked loop that these\n+\t multiplications don't overflow.  */\n+      tree factor = build_int_cst (compare_type, nscalars_per_iter);\n+      nscalars_total = gimple_build (preheader_seq, MULT_EXPR, compare_type,\n+\t\t\t\t     nscalars_total, factor);\n+      nscalars_step = gimple_build (preheader_seq, MULT_EXPR, compare_type,\n+\t\t\t\t    nscalars_step, factor);\n+    }\n+\n+  /* Create an induction variable that counts the number of scalars\n+     processed.  */\n+  tree index_before_incr, index_after_incr;\n+  gimple_stmt_iterator incr_gsi;\n+  bool insert_after;\n+  tree zero_index = build_int_cst (compare_type, 0);\n+  standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n+  create_iv (zero_index, nscalars_step, NULL_TREE, loop, &incr_gsi,\n+\t     insert_after, &index_before_incr, &index_after_incr);\n+\n+  tree test_index, test_limit;\n+  gimple_stmt_iterator *test_gsi;\n+  if (might_wrap_p)\n+    {\n+      /* In principle the loop should stop iterating once the incremented\n+\t IV reaches a value greater than or equal to NSCALAR_TOTAL.\n+\t However, there's no guarantee that the IV hits a value above\n+\t this value before wrapping around.  We therefore adjust the\n+\t limit down by one IV step:\n+\n+\t   NSCALARS_TOTAL -[infinite-prec] NSCALARS_STEP\n+\n+\t and compare the IV against this limit _before_ incrementing it.\n+\t Since the comparison type is unsigned, we actually want the\n+\t subtraction to saturate at zero:\n+\n+\t   NSCALARS_TOTAL -[sat] NSCALARS_STEP.  */\n+      test_index = index_before_incr;\n+      test_limit = gimple_build (preheader_seq, MAX_EXPR, compare_type,\n+\t\t\t\t nscalars_total, nscalars_step);\n+      test_limit = gimple_build (preheader_seq, MINUS_EXPR, compare_type,\n+\t\t\t\t test_limit, nscalars_step);\n+      test_gsi = &incr_gsi;\n+    }\n+  else\n+    {\n+      /* Test the incremented IV, which will always hit a value above\n+\t the bound before wrapping.  */\n+      test_index = index_after_incr;\n+      test_limit = nscalars_total;\n+      test_gsi = &loop_cond_gsi;\n+    }\n+\n+  /* Provide a definition of each mask in the group.  */\n+  tree next_mask = NULL_TREE;\n+  tree mask;\n+  unsigned int i;\n+  FOR_EACH_VEC_ELT_REVERSE (rgm->masks, i, mask)\n+    {\n+      /* Previous masks will cover BIAS scalars.  This mask covers the\n+\t next batch.  */\n+      poly_uint64 bias = nscalars_per_mask * i;\n+      tree bias_tree = build_int_cst (compare_type, bias);\n+      gimple *tmp_stmt;\n+\n+      /* See whether the first iteration of the vector loop is known\n+\t to have a full mask.  */\n+      poly_uint64 const_limit;\n+      bool first_iteration_full\n+\t= (poly_int_tree_p (nscalars_total, &const_limit)\n+\t   && known_ge (const_limit, (i + 1) * nscalars_per_mask));\n+\n+      /* Rather than have a new IV that starts at BIAS and goes up to\n+\t TEST_LIMIT, prefer to use the same 0-based IV for each mask\n+\t and adjust the bound down by BIAS.  */\n+      tree this_test_limit = test_limit;\n+      if (i != 0)\n+\t{\n+\t  this_test_limit = gimple_build (preheader_seq, MAX_EXPR,\n+\t\t\t\t\t  compare_type, this_test_limit,\n+\t\t\t\t\t  bias_tree);\n+\t  this_test_limit = gimple_build (preheader_seq, MINUS_EXPR,\n+\t\t\t\t\t  compare_type, this_test_limit,\n+\t\t\t\t\t  bias_tree);\n+\t}\n+\n+      /* Create the initial mask.  */\n+      tree init_mask = NULL_TREE;\n+      if (!first_iteration_full)\n+\t{\n+\t  tree start, end;\n+\t  if (nscalars_total == test_limit)\n+\t    {\n+\t      /* Use a natural test between zero (the initial IV value)\n+\t\t and the loop limit.  The \"else\" block would be valid too,\n+\t\t but this choice can avoid the need to load BIAS_TREE into\n+\t\t a register.  */\n+\t      start = zero_index;\n+\t      end = this_test_limit;\n+\t    }\n+\t  else\n+\t    {\n+\t      start = bias_tree;\n+\t      end = nscalars_total;\n+\t    }\n+\n+\t  init_mask = make_temp_ssa_name (mask_type, NULL, \"max_mask\");\n+\t  tmp_stmt = vect_gen_while (init_mask, start, end);\n+\t  gimple_seq_add_stmt (preheader_seq, tmp_stmt);\n+\t}\n+\n+      if (!init_mask)\n+\t/* First iteration is full.  */\n+\tinit_mask = build_minus_one_cst (mask_type);\n+\n+      /* Get the mask value for the next iteration of the loop.  */\n+      next_mask = make_temp_ssa_name (mask_type, NULL, \"next_mask\");\n+      gcall *call = vect_gen_while (next_mask, test_index, this_test_limit);\n+      gsi_insert_before (test_gsi, call, GSI_SAME_STMT);\n+\n+      vect_set_loop_mask (loop, mask, init_mask, next_mask);\n+    }\n+  return next_mask;\n+}\n+\n+/* Make LOOP iterate NITERS times using masking and WHILE_ULT calls.\n+   LOOP_VINFO describes the vectorization of LOOP.  NITERS is the\n+   number of iterations of the original scalar loop.  NITERS_MAYBE_ZERO\n+   and FINAL_IV are as for vect_set_loop_condition.\n+\n+   Insert the branch-back condition before LOOP_COND_GSI and return the\n+   final gcond.  */\n+\n+static gcond *\n+vect_set_loop_condition_masked (struct loop *loop, loop_vec_info loop_vinfo,\n+\t\t\t\ttree niters, tree final_iv,\n+\t\t\t\tbool niters_maybe_zero,\n+\t\t\t\tgimple_stmt_iterator loop_cond_gsi)\n+{\n+  gimple_seq preheader_seq = NULL;\n+  gimple_seq header_seq = NULL;\n+\n+  tree compare_type = LOOP_VINFO_MASK_COMPARE_TYPE (loop_vinfo);\n+  unsigned int compare_precision = TYPE_PRECISION (compare_type);\n+  unsigned HOST_WIDE_INT max_vf = vect_max_vf (loop_vinfo);\n+  tree orig_niters = niters;\n+\n+  /* Type of the initial value of NITERS.  */\n+  tree ni_actual_type = TREE_TYPE (niters);\n+  unsigned int ni_actual_precision = TYPE_PRECISION (ni_actual_type);\n+\n+  /* Convert NITERS to the same size as the compare.  */\n+  if (compare_precision > ni_actual_precision\n+      && niters_maybe_zero)\n+    {\n+      /* We know that there is always at least one iteration, so if the\n+\t count is zero then it must have wrapped.  Cope with this by\n+\t subtracting 1 before the conversion and adding 1 to the result.  */\n+      gcc_assert (TYPE_UNSIGNED (ni_actual_type));\n+      niters = gimple_build (&preheader_seq, PLUS_EXPR, ni_actual_type,\n+\t\t\t     niters, build_minus_one_cst (ni_actual_type));\n+      niters = gimple_convert (&preheader_seq, compare_type, niters);\n+      niters = gimple_build (&preheader_seq, PLUS_EXPR, compare_type,\n+\t\t\t     niters, build_one_cst (compare_type));\n+    }\n+  else\n+    niters = gimple_convert (&preheader_seq, compare_type, niters);\n+\n+  /* Now calculate the value that the induction variable must be able\n+     to hit in order to ensure that we end the loop with an all-false mask.\n+     This involves adding the maximum number of inactive trailing scalar\n+     iterations.  */\n+  widest_int iv_limit;\n+  bool known_max_iters = max_loop_iterations (loop, &iv_limit);\n+  if (known_max_iters)\n+    {\n+      /* IV_LIMIT is the maximum number of latch iterations, which is also\n+\t the maximum in-range IV value.  Round this value down to the previous\n+\t vector alignment boundary and then add an extra full iteration.  */\n+      poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+      iv_limit = (iv_limit & -(int) known_alignment (vf)) + max_vf;\n+    }\n+\n+  /* Get the vectorization factor in tree form.  */\n+  tree vf = build_int_cst (compare_type,\n+\t\t\t   LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n+\n+  /* Iterate over all the rgroups and fill in their masks.  We could use\n+     the first mask from any rgroup for the loop condition; here we\n+     arbitrarily pick the last.  */\n+  tree test_mask = NULL_TREE;\n+  rgroup_masks *rgm;\n+  unsigned int i;\n+  vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n+  FOR_EACH_VEC_ELT (*masks, i, rgm)\n+    if (!rgm->masks.is_empty ())\n+      {\n+\t/* First try using permutes.  This adds a single vector\n+\t   instruction to the loop for each mask, but needs no extra\n+\t   loop invariants or IVs.  */\n+\tunsigned int nmasks = i + 1;\n+\tif ((nmasks & 1) == 0)\n+\t  {\n+\t    rgroup_masks *half_rgm = &(*masks)[nmasks / 2 - 1];\n+\t    if (!half_rgm->masks.is_empty ()\n+\t\t&& vect_maybe_permute_loop_masks (&header_seq, rgm, half_rgm))\n+\t      continue;\n+\t  }\n+\n+\t/* See whether zero-based IV would ever generate all-false masks\n+\t   before wrapping around.  */\n+\tbool might_wrap_p\n+\t  = (!known_max_iters\n+\t     || (wi::min_precision (iv_limit * rgm->max_nscalars_per_iter,\n+\t\t\t\t    UNSIGNED)\n+\t\t > compare_precision));\n+\n+\t/* Set up all masks for this group.  */\n+\ttest_mask = vect_set_loop_masks_directly (loop, loop_vinfo,\n+\t\t\t\t\t\t  &preheader_seq,\n+\t\t\t\t\t\t  loop_cond_gsi, rgm, vf,\n+\t\t\t\t\t\t  niters, might_wrap_p);\n+      }\n+\n+  /* Emit all accumulated statements.  */\n+  add_preheader_seq (loop, preheader_seq);\n+  add_header_seq (loop, header_seq);\n+\n+  /* Get a boolean result that tells us whether to iterate.  */\n+  edge exit_edge = single_exit (loop);\n+  tree_code code = (exit_edge->flags & EDGE_TRUE_VALUE) ? EQ_EXPR : NE_EXPR;\n+  tree zero_mask = build_zero_cst (TREE_TYPE (test_mask));\n+  gcond *cond_stmt = gimple_build_cond (code, test_mask, zero_mask,\n+\t\t\t\t\tNULL_TREE, NULL_TREE);\n+  gsi_insert_before (&loop_cond_gsi, cond_stmt, GSI_SAME_STMT);\n+\n+  /* The loop iterates (NITERS - 1) / VF + 1 times.\n+     Subtract one from this to get the latch count.  */\n+  tree step = build_int_cst (compare_type,\n+\t\t\t     LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n+  tree niters_minus_one = fold_build2 (PLUS_EXPR, compare_type, niters,\n+\t\t\t\t       build_minus_one_cst (compare_type));\n+  loop->nb_iterations = fold_build2 (TRUNC_DIV_EXPR, compare_type,\n+\t\t\t\t     niters_minus_one, step);\n+\n+  if (final_iv)\n+    {\n+      gassign *assign = gimple_build_assign (final_iv, orig_niters);\n+      gsi_insert_on_edge_immediate (single_exit (loop), assign);\n+    }\n+\n+  return cond_stmt;\n+}\n+\n+/* Like vect_set_loop_condition, but handle the case in which there\n+   are no loop masks.  */\n+\n+static gcond *\n+vect_set_loop_condition_unmasked (struct loop *loop, tree niters,\n+\t\t\t\t  tree step, tree final_iv,\n+\t\t\t\t  bool niters_maybe_zero,\n+\t\t\t\t  gimple_stmt_iterator loop_cond_gsi)\n {\n   tree indx_before_incr, indx_after_incr;\n   gcond *cond_stmt;\n   gcond *orig_cond;\n   edge pe = loop_preheader_edge (loop);\n   edge exit_edge = single_exit (loop);\n-  gimple_stmt_iterator loop_cond_gsi;\n   gimple_stmt_iterator incr_gsi;\n   bool insert_after;\n-  source_location loop_loc;\n   enum tree_code code;\n   tree niters_type = TREE_TYPE (niters);\n \n@@ -360,7 +773,6 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters, tree step,\n   standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n   create_iv (init, step, NULL_TREE, loop,\n              &incr_gsi, insert_after, &indx_before_incr, &indx_after_incr);\n-\n   indx_after_incr = force_gimple_operand_gsi (&loop_cond_gsi, indx_after_incr,\n \t\t\t\t\t      true, NULL_TREE, true,\n \t\t\t\t\t      GSI_SAME_STMT);\n@@ -372,19 +784,6 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters, tree step,\n \n   gsi_insert_before (&loop_cond_gsi, cond_stmt, GSI_SAME_STMT);\n \n-  /* Remove old loop exit test:  */\n-  gsi_remove (&loop_cond_gsi, true);\n-  free_stmt_vec_info (orig_cond);\n-\n-  loop_loc = find_loop_location (loop);\n-  if (dump_enabled_p ())\n-    {\n-      if (LOCATION_LOCUS (loop_loc) != UNKNOWN_LOCATION)\n-\tdump_printf (MSG_NOTE, \"\\nloop at %s:%d: \", LOCATION_FILE (loop_loc),\n-\t\t     LOCATION_LINE (loop_loc));\n-      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, cond_stmt, 0);\n-    }\n-\n   /* Record the number of latch iterations.  */\n   if (limit == niters)\n     /* Case A: the loop iterates NITERS times.  Subtract one to get the\n@@ -403,6 +802,59 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters, tree step,\n \t\t\t\t\t     indx_after_incr, init);\n       gsi_insert_on_edge_immediate (single_exit (loop), assign);\n     }\n+\n+  return cond_stmt;\n+}\n+\n+/* If we're using fully-masked loops, make LOOP iterate:\n+\n+      N == (NITERS - 1) / STEP + 1\n+\n+   times.  When NITERS is zero, this is equivalent to making the loop\n+   execute (1 << M) / STEP times, where M is the precision of NITERS.\n+   NITERS_MAYBE_ZERO is true if this last case might occur.\n+\n+   If we're not using fully-masked loops, make LOOP iterate:\n+\n+      N == (NITERS - STEP) / STEP + 1\n+\n+   times, where NITERS is known to be outside the range [1, STEP - 1].\n+   This is equivalent to making the loop execute NITERS / STEP times\n+   when NITERS is nonzero and (1 << M) / STEP times otherwise.\n+   NITERS_MAYBE_ZERO again indicates whether this last case might occur.\n+\n+   If FINAL_IV is nonnull, it is an SSA name that should be set to\n+   N * STEP on exit from the loop.\n+\n+   Assumption: the exit-condition of LOOP is the last stmt in the loop.  */\n+\n+void\n+vect_set_loop_condition (struct loop *loop, loop_vec_info loop_vinfo,\n+\t\t\t tree niters, tree step, tree final_iv,\n+\t\t\t bool niters_maybe_zero)\n+{\n+  gcond *cond_stmt;\n+  gcond *orig_cond = get_loop_exit_condition (loop);\n+  gimple_stmt_iterator loop_cond_gsi = gsi_for_stmt (orig_cond);\n+\n+  if (loop_vinfo && LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+    cond_stmt = vect_set_loop_condition_masked (loop, loop_vinfo, niters,\n+\t\t\t\t\t\tfinal_iv, niters_maybe_zero,\n+\t\t\t\t\t\tloop_cond_gsi);\n+  else\n+    cond_stmt = vect_set_loop_condition_unmasked (loop, niters, step,\n+\t\t\t\t\t\t  final_iv, niters_maybe_zero,\n+\t\t\t\t\t\t  loop_cond_gsi);\n+\n+  /* Remove old loop exit test.  */\n+  gsi_remove (&loop_cond_gsi, true);\n+  free_stmt_vec_info (orig_cond);\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"New loop exit condition: \");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, cond_stmt, 0);\n+    }\n }\n \n /* Helper routine of slpeel_tree_duplicate_loop_to_edge_cfg.\n@@ -1319,7 +1771,8 @@ vect_gen_vector_loop_niters (loop_vec_info loop_vinfo, tree niters,\n     ni_minus_gap = niters;\n \n   unsigned HOST_WIDE_INT const_vf;\n-  if (vf.is_constant (&const_vf))\n+  if (vf.is_constant (&const_vf)\n+      && !LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n     {\n       /* Create: niters >> log2(vf) */\n       /* If it's known that niters == number of latch executions + 1 doesn't\n@@ -1726,8 +2179,7 @@ slpeel_update_phi_nodes_for_lcssa (struct loop *epilog)\n \t\t\t      CHECK_PROFITABILITY is true.\n    Output:\n    - *NITERS_VECTOR and *STEP_VECTOR describe how the main loop should\n-     iterate after vectorization; see slpeel_make_loop_iterate_ntimes\n-     for details.\n+     iterate after vectorization; see vect_set_loop_condition for details.\n    - *NITERS_VECTOR_MULT_VF_VAR is either null or an SSA name that\n      should be set to the number of scalar iterations handled by the\n      vector loop.  The SSA name is only used on exit from the loop.\n@@ -1892,8 +2344,8 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n       niters_prolog = vect_gen_prolog_loop_niters (loop_vinfo, anchor,\n \t\t\t\t\t\t   &bound_prolog);\n       tree step_prolog = build_one_cst (TREE_TYPE (niters_prolog));\n-      slpeel_make_loop_iterate_ntimes (prolog, niters_prolog, step_prolog,\n-\t\t\t\t       NULL_TREE, false);\n+      vect_set_loop_condition (prolog, NULL, niters_prolog,\n+\t\t\t       step_prolog, NULL_TREE, false);\n \n       /* Skip the prolog loop.  */\n       if (skip_prolog)"}, {"sha": "5deb7800f43851ec278ce038db825dd0e2253d92", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 305, "deletions": 20, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -1121,12 +1121,15 @@ _loop_vec_info::_loop_vec_info (struct loop *loop_in)\n     versioning_threshold (0),\n     vectorization_factor (0),\n     max_vectorization_factor (0),\n+    mask_compare_type (NULL_TREE),\n     unaligned_dr (NULL),\n     peeling_for_alignment (0),\n     ptr_mask (0),\n     slp_unrolling_factor (1),\n     single_scalar_iteration_cost (0),\n     vectorizable (false),\n+    can_fully_mask_p (true),\n+    fully_masked_p (false),\n     peeling_for_gaps (false),\n     peeling_for_niter (false),\n     operands_swapped (false),\n@@ -1168,6 +1171,17 @@ _loop_vec_info::_loop_vec_info (struct loop *loop_in)\n   gcc_assert (nbbs == loop->num_nodes);\n }\n \n+/* Free all levels of MASKS.  */\n+\n+void\n+release_vec_loop_masks (vec_loop_masks *masks)\n+{\n+  rgroup_masks *rgm;\n+  unsigned int i;\n+  FOR_EACH_VEC_ELT (*masks, i, rgm)\n+    rgm->masks.release ();\n+  masks->release ();\n+}\n \n /* Free all memory used by the _loop_vec_info, as well as all the\n    stmt_vec_info structs of all the stmts in the loop.  */\n@@ -1233,9 +1247,98 @@ _loop_vec_info::~_loop_vec_info ()\n \n   free (bbs);\n \n+  release_vec_loop_masks (&masks);\n+\n   loop->aux = NULL;\n }\n \n+/* Return true if we can use CMP_TYPE as the comparison type to produce\n+   all masks required to mask LOOP_VINFO.  */\n+\n+static bool\n+can_produce_all_loop_masks_p (loop_vec_info loop_vinfo, tree cmp_type)\n+{\n+  rgroup_masks *rgm;\n+  unsigned int i;\n+  FOR_EACH_VEC_ELT (LOOP_VINFO_MASKS (loop_vinfo), i, rgm)\n+    if (rgm->mask_type != NULL_TREE\n+\t&& !direct_internal_fn_supported_p (IFN_WHILE_ULT,\n+\t\t\t\t\t    cmp_type, rgm->mask_type,\n+\t\t\t\t\t    OPTIMIZE_FOR_SPEED))\n+      return false;\n+  return true;\n+}\n+\n+/* Calculate the maximum number of scalars per iteration for every\n+   rgroup in LOOP_VINFO.  */\n+\n+static unsigned int\n+vect_get_max_nscalars_per_iter (loop_vec_info loop_vinfo)\n+{\n+  unsigned int res = 1;\n+  unsigned int i;\n+  rgroup_masks *rgm;\n+  FOR_EACH_VEC_ELT (LOOP_VINFO_MASKS (loop_vinfo), i, rgm)\n+    res = MAX (res, rgm->max_nscalars_per_iter);\n+  return res;\n+}\n+\n+/* Each statement in LOOP_VINFO can be masked where necessary.  Check\n+   whether we can actually generate the masks required.  Return true if so,\n+   storing the type of the scalar IV in LOOP_VINFO_MASK_COMPARE_TYPE.  */\n+\n+static bool\n+vect_verify_full_masking (loop_vec_info loop_vinfo)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  unsigned int min_ni_width;\n+\n+  /* Get the maximum number of iterations that is representable\n+     in the counter type.  */\n+  tree ni_type = TREE_TYPE (LOOP_VINFO_NITERSM1 (loop_vinfo));\n+  widest_int max_ni = wi::to_widest (TYPE_MAX_VALUE (ni_type)) + 1;\n+\n+  /* Get a more refined estimate for the number of iterations.  */\n+  widest_int max_back_edges;\n+  if (max_loop_iterations (loop, &max_back_edges))\n+    max_ni = wi::smin (max_ni, max_back_edges + 1);\n+\n+  /* Account for rgroup masks, in which each bit is replicated N times.  */\n+  max_ni *= vect_get_max_nscalars_per_iter (loop_vinfo);\n+\n+  /* Work out how many bits we need to represent the limit.  */\n+  min_ni_width = wi::min_precision (max_ni, UNSIGNED);\n+\n+  /* Find a scalar mode for which WHILE_ULT is supported.  */\n+  opt_scalar_int_mode cmp_mode_iter;\n+  tree cmp_type = NULL_TREE;\n+  FOR_EACH_MODE_IN_CLASS (cmp_mode_iter, MODE_INT)\n+    {\n+      unsigned int cmp_bits = GET_MODE_BITSIZE (cmp_mode_iter.require ());\n+      if (cmp_bits >= min_ni_width\n+\t  && targetm.scalar_mode_supported_p (cmp_mode_iter.require ()))\n+\t{\n+\t  tree this_type = build_nonstandard_integer_type (cmp_bits, true);\n+\t  if (this_type\n+\t      && can_produce_all_loop_masks_p (loop_vinfo, this_type))\n+\t    {\n+\t      /* Although we could stop as soon as we find a valid mode,\n+\t\t it's often better to continue until we hit Pmode, since the\n+\t\t operands to the WHILE are more likely to be reusable in\n+\t\t address calculations.  */\n+\t      cmp_type = this_type;\n+\t      if (cmp_bits >= GET_MODE_BITSIZE (Pmode))\n+\t\tbreak;\n+\t    }\n+\t}\n+    }\n+\n+  if (!cmp_type)\n+    return false;\n+\n+  LOOP_VINFO_MASK_COMPARE_TYPE (loop_vinfo) = cmp_type;\n+  return true;\n+}\n \n /* Calculate the cost of one scalar iteration of the loop.  */\n static void\n@@ -1980,6 +2083,12 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       vect_update_vf_for_slp (loop_vinfo);\n     }\n \n+  bool saved_can_fully_mask_p = LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo);\n+\n+  /* We don't expect to have to roll back to anything other than an empty\n+     set of rgroups.  */\n+  gcc_assert (LOOP_VINFO_MASKS (loop_vinfo).is_empty ());\n+\n   /* This is the point where we can re-start analysis with SLP forced off.  */\n start_over:\n \n@@ -2068,11 +2177,47 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       return false;\n     }\n \n+  if (LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo)\n+      && LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n+    {\n+      LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"can't use a fully-masked loop because peeling for\"\n+\t\t\t \" gaps is required.\\n\");\n+    }\n+\n+  if (LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo)\n+      && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+    {\n+      LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"can't use a fully-masked loop because peeling for\"\n+\t\t\t \" alignment is required.\\n\");\n+    }\n+\n+  /* Decide whether to use a fully-masked loop for this vectorization\n+     factor.  */\n+  LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n+    = (LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo)\n+       && vect_verify_full_masking (loop_vinfo));\n+  if (dump_enabled_p ())\n+    {\n+      if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"using a fully-masked loop.\\n\");\n+      else\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"not using a fully-masked loop.\\n\");\n+    }\n+\n   /* If epilog loop is required because of data accesses with gaps,\n      one additional iteration needs to be peeled.  Check if there is\n      enough iterations for vectorization.  */\n   if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo)\n-      && LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+      && LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && !LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n     {\n       poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n       tree scalar_niters = LOOP_VINFO_NITERSM1 (loop_vinfo);\n@@ -2153,8 +2298,11 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n   th = LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo);\n \n   unsigned HOST_WIDE_INT const_vf;\n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n+  if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+    /* The main loop handles all iterations.  */\n+    LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = false;\n+  else if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+\t   && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n     {\n       if (!multiple_p (LOOP_VINFO_INT_NITERS (loop_vinfo)\n \t\t       - LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo),\n@@ -2212,7 +2360,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \tniters_th = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n \n       /* Niters for at least one iteration of vectorized loop.  */\n-      niters_th += LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+      if (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+\tniters_th += LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n       /* One additional iteration because of peeling for gap.  */\n       if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n \tniters_th += 1;\n@@ -2315,11 +2464,14 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n   destroy_cost_data (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n   LOOP_VINFO_TARGET_COST_DATA (loop_vinfo)\n     = init_cost (LOOP_VINFO_LOOP (loop_vinfo));\n+  /* Reset accumulated rgroup information.  */\n+  release_vec_loop_masks (&LOOP_VINFO_MASKS (loop_vinfo));\n   /* Reset assorted flags.  */\n   LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = false;\n   LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) = false;\n   LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) = 0;\n   LOOP_VINFO_VERSIONING_THRESHOLD (loop_vinfo) = 0;\n+  LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = saved_can_fully_mask_p;\n \n   goto start_over;\n }\n@@ -3523,15 +3675,20 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n     = LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST (loop_vinfo);\n \n   /* Add additional cost for the peeled instructions in prologue and epilogue\n-     loop.\n+     loop.  (For fully-masked loops there will be no peeling.)\n \n      FORNOW: If we don't know the value of peel_iters for prologue or epilogue\n      at compile-time - we assume it's vf/2 (the worst would be vf-1).\n \n      TODO: Build an expression that represents peel_iters for prologue and\n      epilogue to be used in a run-time test.  */\n \n-  if (npeel  < 0)\n+  if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+    {\n+      peel_iters_prologue = 0;\n+      peel_iters_epilogue = 0;\n+    }\n+  else if (npeel < 0)\n     {\n       peel_iters_prologue = assumed_vf / 2;\n       dump_printf (MSG_NOTE, \"cost model: \"\n@@ -3762,8 +3919,9 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t       \"  Calculated minimum iters for profitability: %d\\n\",\n \t       min_profitable_iters);\n \n-  /* We want the vectorized loop to execute at least once.  */\n-  if (min_profitable_iters < (assumed_vf + peel_iters_prologue))\n+  if (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n+      && min_profitable_iters < (assumed_vf + peel_iters_prologue))\n+    /* We want the vectorized loop to execute at least once.  */\n     min_profitable_iters = assumed_vf + peel_iters_prologue;\n \n   if (dump_enabled_p ())\n@@ -6737,6 +6895,15 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n+      if (LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"can't use a fully-masked loop due to \"\n+\t\t\t     \"reduction operation.\\n\");\n+\t  LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+\t}\n+\n       if (first_p)\n \tvect_model_reduction_cost (stmt_info, reduc_fn, ncopies);\n       STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n@@ -7557,8 +7724,19 @@ vectorizable_live_operation (gimple *stmt,\n     }\n \n   if (!vec_stmt)\n-    /* No transformation required.  */\n-    return true;\n+    {\n+      if (LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"can't use a fully-masked loop because \"\n+\t\t\t     \"a value is live outside the loop.\\n\");\n+\t  LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+\t}\n+\n+      /* No transformation required.  */\n+      return true;\n+    }\n \n   /* If stmt has a related stmt, then use that for getting the lhs.  */\n   if (is_pattern_stmt_p (stmt_info))\n@@ -7573,6 +7751,8 @@ vectorizable_live_operation (gimple *stmt,\n \t     : TYPE_SIZE (TREE_TYPE (vectype)));\n   vec_bitsize = TYPE_SIZE (vectype);\n \n+  gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n+\n   /* Get the vectorized lhs of STMT and the lane to use (counted in bits).  */\n   tree vec_lhs, bitstart;\n   if (slp_node)\n@@ -7706,6 +7886,97 @@ loop_niters_no_overflow (loop_vec_info loop_vinfo)\n   return false;\n }\n \n+/* Return a mask type with half the number of elements as TYPE.  */\n+\n+tree\n+vect_halve_mask_nunits (tree type)\n+{\n+  poly_uint64 nunits = exact_div (TYPE_VECTOR_SUBPARTS (type), 2);\n+  return build_truth_vector_type (nunits, current_vector_size);\n+}\n+\n+/* Return a mask type with twice as many elements as TYPE.  */\n+\n+tree\n+vect_double_mask_nunits (tree type)\n+{\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (type) * 2;\n+  return build_truth_vector_type (nunits, current_vector_size);\n+}\n+\n+/* Record that a fully-masked version of LOOP_VINFO would need MASKS to\n+   contain a sequence of NVECTORS masks that each control a vector of type\n+   VECTYPE.  */\n+\n+void\n+vect_record_loop_mask (loop_vec_info loop_vinfo, vec_loop_masks *masks,\n+\t\t       unsigned int nvectors, tree vectype)\n+{\n+  gcc_assert (nvectors != 0);\n+  if (masks->length () < nvectors)\n+    masks->safe_grow_cleared (nvectors);\n+  rgroup_masks *rgm = &(*masks)[nvectors - 1];\n+  /* The number of scalars per iteration and the number of vectors are\n+     both compile-time constants.  */\n+  unsigned int nscalars_per_iter\n+    = exact_div (nvectors * TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t LOOP_VINFO_VECT_FACTOR (loop_vinfo)).to_constant ();\n+  if (rgm->max_nscalars_per_iter < nscalars_per_iter)\n+    {\n+      rgm->max_nscalars_per_iter = nscalars_per_iter;\n+      rgm->mask_type = build_same_sized_truth_vector_type (vectype);\n+    }\n+}\n+\n+/* Given a complete set of masks MASKS, extract mask number INDEX\n+   for an rgroup that operates on NVECTORS vectors of type VECTYPE,\n+   where 0 <= INDEX < NVECTORS.  Insert any set-up statements before GSI.\n+\n+   See the comment above vec_loop_masks for more details about the mask\n+   arrangement.  */\n+\n+tree\n+vect_get_loop_mask (gimple_stmt_iterator *gsi, vec_loop_masks *masks,\n+\t\t    unsigned int nvectors, tree vectype, unsigned int index)\n+{\n+  rgroup_masks *rgm = &(*masks)[nvectors - 1];\n+  tree mask_type = rgm->mask_type;\n+\n+  /* Populate the rgroup's mask array, if this is the first time we've\n+     used it.  */\n+  if (rgm->masks.is_empty ())\n+    {\n+      rgm->masks.safe_grow_cleared (nvectors);\n+      for (unsigned int i = 0; i < nvectors; ++i)\n+\t{\n+\t  tree mask = make_temp_ssa_name (mask_type, NULL, \"loop_mask\");\n+\t  /* Provide a dummy definition until the real one is available.  */\n+\t  SSA_NAME_DEF_STMT (mask) = gimple_build_nop ();\n+\t  rgm->masks[i] = mask;\n+\t}\n+    }\n+\n+  tree mask = rgm->masks[index];\n+  if (maybe_ne (TYPE_VECTOR_SUBPARTS (mask_type),\n+\t\tTYPE_VECTOR_SUBPARTS (vectype)))\n+    {\n+      /* A loop mask for data type X can be reused for data type Y\n+\t if X has N times more elements than Y and if Y's elements\n+\t are N times bigger than X's.  In this case each sequence\n+\t of N elements in the loop mask will be all-zero or all-one.\n+\t We can then view-convert the mask so that each sequence of\n+\t N elements is replaced by a single element.  */\n+      gcc_assert (multiple_p (TYPE_VECTOR_SUBPARTS (mask_type),\n+\t\t\t      TYPE_VECTOR_SUBPARTS (vectype)));\n+      gimple_seq seq = NULL;\n+      mask_type = build_same_sized_truth_vector_type (vectype);\n+      mask = gimple_build (&seq, VIEW_CONVERT_EXPR, mask_type, mask);\n+      if (seq)\n+\tgsi_insert_seq_before (gsi, seq, GSI_SAME_STMT);\n+    }\n+  return mask;\n+}\n+\n /* Scale profiling counters by estimation for LOOP which is vectorized\n    by factor VF.  */\n \n@@ -7840,9 +8111,12 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   epilogue = vect_do_peeling (loop_vinfo, niters, nitersm1, &niters_vector,\n \t\t\t      &step_vector, &niters_vector_mult_vf, th,\n \t\t\t      check_profitability, niters_no_overflow);\n+\n   if (niters_vector == NULL_TREE)\n     {\n-      if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) && known_eq (lowest_vf, vf))\n+      if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+\t  && !LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n+\t  && known_eq (lowest_vf, vf))\n \t{\n \t  niters_vector\n \t    = build_int_cst (TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo)),\n@@ -8124,13 +8398,15 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      a zero NITERS becomes a nonzero NITERS_VECTOR.  */\n   if (integer_onep (step_vector))\n     niters_no_overflow = true;\n-  slpeel_make_loop_iterate_ntimes (loop, niters_vector, step_vector,\n-\t\t\t\t   niters_vector_mult_vf,\n-\t\t\t\t   !niters_no_overflow);\n+  vect_set_loop_condition (loop, loop_vinfo, niters_vector, step_vector,\n+\t\t\t   niters_vector_mult_vf, !niters_no_overflow);\n \n   unsigned int assumed_vf = vect_vf_for_cost (loop_vinfo);\n   scale_profile_for_vect_loop (loop, assumed_vf);\n \n+  /* True if the final iteration might not handle a full vector's\n+     worth of scalar iterations.  */\n+  bool final_iter_may_be_partial = LOOP_VINFO_FULLY_MASKED_P (loop_vinfo);\n   /* The minimum number of iterations performed by the epilogue.  This\n      is 1 when peeling for gaps because we always need a final scalar\n      iteration.  */\n@@ -8143,16 +8419,25 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      back to latch counts.  */\n   if (loop->any_upper_bound)\n     loop->nb_iterations_upper_bound\n-      = wi::udiv_floor (loop->nb_iterations_upper_bound + bias,\n-\t\t\tlowest_vf) - 1;\n+      = (final_iter_may_be_partial\n+\t ? wi::udiv_ceil (loop->nb_iterations_upper_bound + bias,\n+\t\t\t  lowest_vf) - 1\n+\t : wi::udiv_floor (loop->nb_iterations_upper_bound + bias,\n+\t\t\t   lowest_vf) - 1);\n   if (loop->any_likely_upper_bound)\n     loop->nb_iterations_likely_upper_bound\n-      = wi::udiv_floor (loop->nb_iterations_likely_upper_bound + bias,\n-\t\t\tlowest_vf) - 1;\n+      = (final_iter_may_be_partial\n+\t ? wi::udiv_ceil (loop->nb_iterations_likely_upper_bound + bias,\n+\t\t\t  lowest_vf) - 1\n+\t : wi::udiv_floor (loop->nb_iterations_likely_upper_bound + bias,\n+\t\t\t   lowest_vf) - 1);\n   if (loop->any_estimate)\n     loop->nb_iterations_estimate\n-      = wi::udiv_floor (loop->nb_iterations_estimate + bias,\n-\t\t\tassumed_vf) - 1;\n+      = (final_iter_may_be_partial\n+\t ? wi::udiv_ceil (loop->nb_iterations_estimate + bias,\n+\t\t\t  assumed_vf) - 1\n+\t : wi::udiv_floor (loop->nb_iterations_estimate + bias,\n+\t\t\t   assumed_vf) - 1);\n \n   if (dump_enabled_p ())\n     {"}, {"sha": "1381b5f4c4510ddf2e8478a32fc77563634298b2", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 213, "deletions": 32, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -50,6 +50,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"internal-fn.h\"\n #include \"tree-vector-builder.h\"\n #include \"vec-perm-indices.h\"\n+#include \"tree-ssa-loop-niter.h\"\n+#include \"gimple-fold.h\"\n \n /* For lang_hooks.types.type_for_mode.  */\n #include \"langhooks.h\"\n@@ -1694,6 +1696,113 @@ vectorizable_internal_function (combined_fn cfn, tree fndecl,\n static tree permute_vec_elements (tree, tree, tree, gimple *,\n \t\t\t\t  gimple_stmt_iterator *);\n \n+/* Check whether a load or store statement in the loop described by\n+   LOOP_VINFO is possible in a fully-masked loop.  This is testing\n+   whether the vectorizer pass has the appropriate support, as well as\n+   whether the target does.\n+\n+   VLS_TYPE says whether the statement is a load or store and VECTYPE\n+   is the type of the vector being loaded or stored.  MEMORY_ACCESS_TYPE\n+   says how the load or store is going to be implemented and GROUP_SIZE\n+   is the number of load or store statements in the containing group.\n+\n+   Clear LOOP_VINFO_CAN_FULLY_MASK_P if a fully-masked loop is not\n+   supported, otherwise record the required mask types.  */\n+\n+static void\n+check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n+\t\t\t  vec_load_store_type vls_type, int group_size,\n+\t\t\t  vect_memory_access_type memory_access_type)\n+{\n+  /* Invariant loads need no special support.  */\n+  if (memory_access_type == VMAT_INVARIANT)\n+    return;\n+\n+  vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n+  machine_mode vecmode = TYPE_MODE (vectype);\n+  bool is_load = (vls_type == VLS_LOAD);\n+  if (memory_access_type == VMAT_LOAD_STORE_LANES)\n+    {\n+      if (is_load\n+\t  ? !vect_load_lanes_supported (vectype, group_size, true)\n+\t  : !vect_store_lanes_supported (vectype, group_size, true))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"can't use a fully-masked loop because the\"\n+\t\t\t     \" target doesn't have an appropriate masked\"\n+\t\t\t     \" load/store-lanes instruction.\\n\");\n+\t  LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+\t  return;\n+\t}\n+      unsigned int ncopies = vect_get_num_copies (loop_vinfo, vectype);\n+      vect_record_loop_mask (loop_vinfo, masks, ncopies, vectype);\n+      return;\n+    }\n+\n+  if (memory_access_type != VMAT_CONTIGUOUS\n+      && memory_access_type != VMAT_CONTIGUOUS_PERMUTE)\n+    {\n+      /* Element X of the data must come from iteration i * VF + X of the\n+\t scalar loop.  We need more work to support other mappings.  */\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"can't use a fully-masked loop because an access\"\n+\t\t\t \" isn't contiguous.\\n\");\n+      LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+      return;\n+    }\n+\n+  machine_mode mask_mode;\n+  if (!(targetm.vectorize.get_mask_mode\n+\t(GET_MODE_NUNITS (vecmode),\n+\t GET_MODE_SIZE (vecmode)).exists (&mask_mode))\n+      || !can_vec_mask_load_store_p (vecmode, mask_mode, is_load))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"can't use a fully-masked loop because the target\"\n+\t\t\t \" doesn't have the appropriate masked load or\"\n+\t\t\t \" store.\\n\");\n+      LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n+      return;\n+    }\n+  /* We might load more scalars than we need for permuting SLP loads.\n+     We checked in get_group_load_store_type that the extra elements\n+     don't leak into a new vector.  */\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  unsigned int nvectors;\n+  if (can_div_away_from_zero_p (group_size * vf, nunits, &nvectors))\n+    vect_record_loop_mask (loop_vinfo, masks, nvectors, vectype);\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Return the mask input to a masked load or store.  VEC_MASK is the vectorized\n+   form of the scalar mask condition and LOOP_MASK, if nonnull, is the mask\n+   that needs to be applied to all loads and stores in a vectorized loop.\n+   Return VEC_MASK if LOOP_MASK is null, otherwise return VEC_MASK & LOOP_MASK.\n+\n+   MASK_TYPE is the type of both masks.  If new statements are needed,\n+   insert them before GSI.  */\n+\n+static tree\n+prepare_load_store_mask (tree mask_type, tree loop_mask, tree vec_mask,\n+\t\t\t gimple_stmt_iterator *gsi)\n+{\n+  gcc_assert (useless_type_conversion_p (mask_type, TREE_TYPE (vec_mask)));\n+  if (!loop_mask)\n+    return vec_mask;\n+\n+  gcc_assert (TREE_TYPE (loop_mask) == mask_type);\n+  tree and_res = make_temp_ssa_name (mask_type, NULL, \"vec_mask_and\");\n+  gimple *and_stmt = gimple_build_assign (and_res, BIT_AND_EXPR,\n+\t\t\t\t\t  vec_mask, loop_mask);\n+  gsi_insert_before (gsi, and_stmt, GSI_SAME_STMT);\n+  return and_res;\n+}\n+\n /* STMT is a non-strided load or store, meaning that it accesses\n    elements with a known constant step.  Return -1 if that step\n    is negative, 0 if it is zero, and 1 if it is greater than zero.  */\n@@ -5796,9 +5905,29 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \treturn false;\n     }\n \n+  grouped_store = STMT_VINFO_GROUPED_ACCESS (stmt_info);\n+  if (grouped_store)\n+    {\n+      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+      first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n+      group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+    }\n+  else\n+    {\n+      first_stmt = stmt;\n+      first_dr = dr;\n+      group_size = vec_num = 1;\n+    }\n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info) = memory_access_type;\n+\n+      if (loop_vinfo\n+\t  && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n+\tcheck_load_store_masking (loop_vinfo, vectype, vls_type, group_size,\n+\t\t\t\t  memory_access_type);\n+\n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n       /* The SLP costs are calculated during SLP analysis.  */\n       if (!PURE_SLP_STMT (stmt_info))\n@@ -5962,13 +6091,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       return true;\n     }\n \n-  grouped_store = STMT_VINFO_GROUPED_ACCESS (stmt_info);\n   if (grouped_store)\n     {\n-      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n-      first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-      group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n-\n       GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt))++;\n \n       /* FORNOW */\n@@ -6003,12 +6127,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       ref_type = get_group_alias_ptr_type (first_stmt);\n     }\n   else\n-    {\n-      first_stmt = stmt;\n-      first_dr = dr;\n-      group_size = vec_num = 1;\n-      ref_type = reference_alias_ptr_type (DR_REF (first_dr));\n-    }\n+    ref_type = reference_alias_ptr_type (DR_REF (first_dr));\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -6030,6 +6149,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       /* Checked by get_load_store_type.  */\n       unsigned int const_nunits = nunits.to_constant ();\n \n+      gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n       gcc_assert (!nested_in_vect_loop_p (loop, stmt));\n \n       stride_base\n@@ -6260,10 +6380,13 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   alignment_support_scheme = vect_supportable_dr_alignment (first_dr, false);\n   gcc_assert (alignment_support_scheme);\n+  bool masked_loop_p = (loop_vinfo && LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n   /* Targets with store-lane instructions must not require explicit\n      realignment.  vect_supportable_dr_alignment always returns either\n      dr_aligned or dr_unaligned_supported for masked operations.  */\n-  gcc_assert ((memory_access_type != VMAT_LOAD_STORE_LANES && !mask)\n+  gcc_assert ((memory_access_type != VMAT_LOAD_STORE_LANES\n+\t       && !mask\n+\t       && !masked_loop_p)\n \t      || alignment_support_scheme == dr_aligned\n \t      || alignment_support_scheme == dr_unaligned_supported);\n \n@@ -6320,6 +6443,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   prev_stmt_info = NULL;\n   tree vec_mask = NULL_TREE;\n+  vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n   for (j = 0; j < ncopies; j++)\n     {\n \n@@ -6429,8 +6553,15 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      write_vector_array (stmt, gsi, vec_oprnd, vec_array, i);\n \t    }\n \n+\t  tree final_mask = NULL;\n+\t  if (masked_loop_p)\n+\t    final_mask = vect_get_loop_mask (gsi, masks, ncopies, vectype, j);\n+\t  if (vec_mask)\n+\t    final_mask = prepare_load_store_mask (mask_vectype, final_mask,\n+\t\t\t\t\t\t  vec_mask, gsi);\n+\n \t  gcall *call;\n-\t  if (mask)\n+\t  if (final_mask)\n \t    {\n \t      /* Emit:\n \t\t   MASK_STORE_LANES (DATAREF_PTR, ALIAS_PTR, VEC_MASK,\n@@ -6439,7 +6570,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      tree alias_ptr = build_int_cst (ref_type, align);\n \t      call = gimple_build_call_internal (IFN_MASK_STORE_LANES, 4,\n \t\t\t\t\t\t dataref_ptr, alias_ptr,\n-\t\t\t\t\t\t vec_mask, vec_array);\n+\t\t\t\t\t\t final_mask, vec_array);\n \t    }\n \t  else\n \t    {\n@@ -6471,6 +6602,14 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    {\n \t      unsigned align, misalign;\n \n+\t      tree final_mask = NULL_TREE;\n+\t      if (masked_loop_p)\n+\t\tfinal_mask = vect_get_loop_mask (gsi, masks, vec_num * ncopies,\n+\t\t\t\t\t\t vectype, vec_num * j + i);\n+\t      if (vec_mask)\n+\t\tfinal_mask = prepare_load_store_mask (mask_vectype, final_mask,\n+\t\t\t\t\t\t      vec_mask, gsi);\n+\n \t      if (i > 0)\n \t\t/* Bump the vector pointer.  */\n \t\tdataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,\n@@ -6517,14 +6656,14 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t}\n \n \t      /* Arguments are ready.  Create the new vector stmt.  */\n-\t      if (mask)\n+\t      if (final_mask)\n \t\t{\n \t\t  align = least_bit_hwi (misalign | align);\n \t\t  tree ptr = build_int_cst (ref_type, align);\n \t\t  gcall *call\n \t\t    = gimple_build_call_internal (IFN_MASK_STORE, 4,\n \t\t\t\t\t\t  dataref_ptr, ptr,\n-\t\t\t\t\t\t  vec_mask, vec_oprnd);\n+\t\t\t\t\t\t  final_mask, vec_oprnd);\n \t\t  gimple_call_set_nothrow (call, true);\n \t\t  new_stmt = call;\n \t\t}\n@@ -6891,6 +7030,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  return false;\n \t}\n     }\n+  else\n+    group_size = 1;\n \n   vect_memory_access_type memory_access_type;\n   if (!get_load_store_type (stmt, vectype, slp, mask, VLS_LOAD, ncopies,\n@@ -6934,6 +7075,12 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     {\n       if (!slp)\n \tSTMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info) = memory_access_type;\n+\n+      if (loop_vinfo\n+\t  && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n+\tcheck_load_store_masking (loop_vinfo, vectype, VLS_LOAD, group_size,\n+\t\t\t\t  memory_access_type);\n+\n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n       /* The SLP costs are calculated during SLP analysis.  */\n       if (!PURE_SLP_STMT (stmt_info))\n@@ -6975,6 +7122,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       /* Checked by get_load_store_type.  */\n       unsigned int const_nunits = nunits.to_constant ();\n \n+      gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n       gcc_assert (!nested_in_vect_loop);\n \n       if (slp && grouped_load)\n@@ -7251,9 +7399,13 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   alignment_support_scheme = vect_supportable_dr_alignment (first_dr, false);\n   gcc_assert (alignment_support_scheme);\n-  /* Targets with load-lane instructions must not require explicit\n-     realignment.  */\n-  gcc_assert (memory_access_type != VMAT_LOAD_STORE_LANES\n+  bool masked_loop_p = (loop_vinfo && LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n+  /* Targets with store-lane instructions must not require explicit\n+     realignment.  vect_supportable_dr_alignment always returns either\n+     dr_aligned or dr_unaligned_supported for masked operations.  */\n+  gcc_assert ((memory_access_type != VMAT_LOAD_STORE_LANES\n+\t       && !mask\n+\t       && !masked_loop_p)\n \t      || alignment_support_scheme == dr_aligned\n \t      || alignment_support_scheme == dr_unaligned_supported);\n \n@@ -7396,6 +7548,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   tree vec_mask = NULL_TREE;\n   prev_stmt_info = NULL;\n   poly_uint64 group_elt = 0;\n+  vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n   for (j = 0; j < ncopies; j++)\n     {\n       /* 1. Create the vector or array pointer update chain.  */\n@@ -7471,8 +7624,15 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t  vec_array = create_vector_array (vectype, vec_num);\n \n+\t  tree final_mask = NULL_TREE;\n+\t  if (masked_loop_p)\n+\t    final_mask = vect_get_loop_mask (gsi, masks, ncopies, vectype, j);\n+\t  if (vec_mask)\n+\t    final_mask = prepare_load_store_mask (mask_vectype, final_mask,\n+\t\t\t\t\t\t  vec_mask, gsi);\n+\n \t  gcall *call;\n-\t  if (mask)\n+\t  if (final_mask)\n \t    {\n \t      /* Emit:\n \t\t   VEC_ARRAY = MASK_LOAD_LANES (DATAREF_PTR, ALIAS_PTR,\n@@ -7481,7 +7641,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      tree alias_ptr = build_int_cst (ref_type, align);\n \t      call = gimple_build_call_internal (IFN_MASK_LOAD_LANES, 3,\n \t\t\t\t\t\t dataref_ptr, alias_ptr,\n-\t\t\t\t\t\t vec_mask);\n+\t\t\t\t\t\t final_mask);\n \t    }\n \t  else\n \t    {\n@@ -7510,6 +7670,15 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t{\n \t  for (i = 0; i < vec_num; i++)\n \t    {\n+\t      tree final_mask = NULL_TREE;\n+\t      if (masked_loop_p\n+\t\t  && memory_access_type != VMAT_INVARIANT)\n+\t\tfinal_mask = vect_get_loop_mask (gsi, masks, vec_num * ncopies,\n+\t\t\t\t\t\t vectype, vec_num * j + i);\n+\t      if (vec_mask)\n+\t\tfinal_mask = prepare_load_store_mask (mask_vectype, final_mask,\n+\t\t\t\t\t\t      vec_mask, gsi);\n+\n \t      if (i > 0)\n \t\tdataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi,\n \t\t\t\t\t       stmt, NULL_TREE);\n@@ -7540,14 +7709,14 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t      set_ptr_info_alignment (get_ptr_info (dataref_ptr),\n \t\t\t\t\t      align, misalign);\n \n-\t\t    if (mask)\n+\t\t    if (final_mask)\n \t\t      {\n \t\t\talign = least_bit_hwi (misalign | align);\n \t\t\ttree ptr = build_int_cst (ref_type, align);\n \t\t\tgcall *call\n \t\t\t  = gimple_build_call_internal (IFN_MASK_LOAD, 3,\n \t\t\t\t\t\t\tdataref_ptr, ptr,\n-\t\t\t\t\t\t\tvec_mask);\n+\t\t\t\t\t\t\tfinal_mask);\n \t\t\tgimple_call_set_nothrow (call, true);\n \t\t\tnew_stmt = call;\n \t\t\tdata_ref = NULL_TREE;\n@@ -9610,11 +9779,7 @@ supportable_widening_operation (enum tree_code code, gimple *stmt,\n       intermediate_mode = insn_data[icode1].operand[0].mode;\n       if (VECTOR_BOOLEAN_TYPE_P (prev_type))\n \t{\n-\t  poly_uint64 intermediate_nelts\n-\t    = exact_div (TYPE_VECTOR_SUBPARTS (prev_type), 2);\n-\t  intermediate_type\n-\t    = build_truth_vector_type (intermediate_nelts,\n-\t\t\t\t       current_vector_size);\n+\t  intermediate_type = vect_halve_mask_nunits (prev_type);\n \t  if (intermediate_mode != TYPE_MODE (intermediate_type))\n \t    return false;\n \t}\n@@ -9775,11 +9940,9 @@ supportable_narrowing_operation (enum tree_code code,\n       intermediate_mode = insn_data[icode1].operand[0].mode;\n       if (VECTOR_BOOLEAN_TYPE_P (prev_type))\n \t{\n-\t  intermediate_type\n-\t    = build_truth_vector_type (TYPE_VECTOR_SUBPARTS (prev_type) * 2,\n-\t\t\t\t       current_vector_size);\n+\t  intermediate_type = vect_double_mask_nunits (prev_type);\n \t  if (intermediate_mode != TYPE_MODE (intermediate_type))\n-\t      return false;\n+\t    return false;\n \t}\n       else\n \tintermediate_type\n@@ -9810,3 +9973,21 @@ supportable_narrowing_operation (enum tree_code code,\n   interm_types->release ();\n   return false;\n }\n+\n+/* Generate and return a statement that sets vector mask MASK such that\n+   MASK[I] is true iff J + START_INDEX < END_INDEX for all J <= I.  */\n+\n+gcall *\n+vect_gen_while (tree mask, tree start_index, tree end_index)\n+{\n+  tree cmp_type = TREE_TYPE (start_index);\n+  tree mask_type = TREE_TYPE (mask);\n+  gcc_checking_assert (direct_internal_fn_supported_p (IFN_WHILE_ULT,\n+\t\t\t\t\t\t       cmp_type, mask_type,\n+\t\t\t\t\t\t       OPTIMIZE_FOR_SPEED));\n+  gcall *call = gimple_build_call_internal (IFN_WHILE_ULT, 3,\n+\t\t\t\t\t    start_index, end_index,\n+\t\t\t\t\t    build_zero_cst (mask_type));\n+  gimple_call_set_lhs (call, mask);\n+  return call;\n+}"}, {"sha": "580c21eac88a33a0e2f7638f2be2bdad4dabd9d4", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 136, "deletions": 2, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -211,6 +211,102 @@ is_a_helper <_bb_vec_info *>::test (vec_info *i)\n }\n \n \n+/* In general, we can divide the vector statements in a vectorized loop\n+   into related groups (\"rgroups\") and say that for each rgroup there is\n+   some nS such that the rgroup operates on nS values from one scalar\n+   iteration followed by nS values from the next.  That is, if VF is the\n+   vectorization factor of the loop, the rgroup operates on a sequence:\n+\n+     (1,1) (1,2) ... (1,nS) (2,1) ... (2,nS) ... (VF,1) ... (VF,nS)\n+\n+   where (i,j) represents a scalar value with index j in a scalar\n+   iteration with index i.\n+\n+   [ We use the term \"rgroup\" to emphasise that this grouping isn't\n+     necessarily the same as the grouping of statements used elsewhere.\n+     For example, if we implement a group of scalar loads using gather\n+     loads, we'll use a separate gather load for each scalar load, and\n+     thus each gather load will belong to its own rgroup. ]\n+\n+   In general this sequence will occupy nV vectors concatenated\n+   together.  If these vectors have nL lanes each, the total number\n+   of scalar values N is given by:\n+\n+       N = nS * VF = nV * nL\n+\n+   None of nS, VF, nV and nL are required to be a power of 2.  nS and nV\n+   are compile-time constants but VF and nL can be variable (if the target\n+   supports variable-length vectors).\n+\n+   In classical vectorization, each iteration of the vector loop would\n+   handle exactly VF iterations of the original scalar loop.  However,\n+   in a fully-masked loop, a particular iteration of the vector loop\n+   might handle fewer than VF iterations of the scalar loop.  The vector\n+   lanes that correspond to iterations of the scalar loop are said to be\n+   \"active\" and the other lanes are said to be \"inactive\".\n+\n+   In a fully-masked loop, many rgroups need to be masked to ensure that\n+   they have no effect for the inactive lanes.  Each such rgroup needs a\n+   sequence of booleans in the same order as above, but with each (i,j)\n+   replaced by a boolean that indicates whether iteration i is active.\n+   This sequence occupies nV vector masks that again have nL lanes each.\n+   Thus the mask sequence as a whole consists of VF independent booleans\n+   that are each repeated nS times.\n+\n+   We make the simplifying assumption that if a sequence of nV masks is\n+   suitable for one (nS,nL) pair, we can reuse it for (nS/2,nL/2) by\n+   VIEW_CONVERTing it.  This holds for all current targets that support\n+   fully-masked loops.  For example, suppose the scalar loop is:\n+\n+     float *f;\n+     double *d;\n+     for (int i = 0; i < n; ++i)\n+       {\n+\t f[i * 2 + 0] += 1.0f;\n+\t f[i * 2 + 1] += 2.0f;\n+\t d[i] += 3.0;\n+       }\n+\n+   and suppose that vectors have 256 bits.  The vectorized f accesses\n+   will belong to one rgroup and the vectorized d access to another:\n+\n+     f rgroup: nS = 2, nV = 1, nL = 8\n+     d rgroup: nS = 1, nV = 1, nL = 4\n+\t       VF = 4\n+\n+     [ In this simple example the rgroups do correspond to the normal\n+       SLP grouping scheme. ]\n+\n+   If only the first three lanes are active, the masks we need are:\n+\n+     f rgroup: 1 1 | 1 1 | 1 1 | 0 0\n+     d rgroup:  1  |  1  |  1  |  0\n+\n+   Here we can use a mask calculated for f's rgroup for d's, but not\n+   vice versa.\n+\n+   Thus for each value of nV, it is enough to provide nV masks, with the\n+   mask being calculated based on the highest nL (or, equivalently, based\n+   on the highest nS) required by any rgroup with that nV.  We therefore\n+   represent the entire collection of masks as a two-level table, with the\n+   first level being indexed by nV - 1 (since nV == 0 doesn't exist) and\n+   the second being indexed by the mask index 0 <= i < nV.  */\n+\n+/* The masks needed by rgroups with nV vectors, according to the\n+   description above.  */\n+struct rgroup_masks {\n+  /* The largest nS for all rgroups that use these masks.  */\n+  unsigned int max_nscalars_per_iter;\n+\n+  /* The type of mask to use, based on the highest nS recorded above.  */\n+  tree mask_type;\n+\n+  /* A vector of nV masks, in iteration order.  */\n+  vec<tree> masks;\n+};\n+\n+typedef auto_vec<rgroup_masks> vec_loop_masks;\n+\n /*-----------------------------------------------------------------*/\n /* Info on vectorized loops.                                       */\n /*-----------------------------------------------------------------*/\n@@ -251,6 +347,14 @@ typedef struct _loop_vec_info : public vec_info {\n      if there is no particular limit.  */\n   unsigned HOST_WIDE_INT max_vectorization_factor;\n \n+  /* The masks that a fully-masked loop should use to avoid operating\n+     on inactive scalars.  */\n+  vec_loop_masks masks;\n+\n+  /* Type of the variables to use in the WHILE_ULT call for fully-masked\n+     loops.  */\n+  tree mask_compare_type;\n+\n   /* Unknown DRs according to which loop was peeled.  */\n   struct data_reference *unaligned_dr;\n \n@@ -305,6 +409,12 @@ typedef struct _loop_vec_info : public vec_info {\n   /* Is the loop vectorizable? */\n   bool vectorizable;\n \n+  /* Records whether we still have the option of using a fully-masked loop.  */\n+  bool can_fully_mask_p;\n+\n+  /* True if have decided to use a fully-masked loop.  */\n+  bool fully_masked_p;\n+\n   /* When we have grouped data accesses with gaps, we may introduce invalid\n      memory accesses.  We peel the last iteration of the loop to prevent\n      this.  */\n@@ -365,8 +475,12 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_COST_MODEL_THRESHOLD(L) (L)->th\n #define LOOP_VINFO_VERSIONING_THRESHOLD(L) (L)->versioning_threshold\n #define LOOP_VINFO_VECTORIZABLE_P(L)       (L)->vectorizable\n+#define LOOP_VINFO_CAN_FULLY_MASK_P(L)     (L)->can_fully_mask_p\n+#define LOOP_VINFO_FULLY_MASKED_P(L)       (L)->fully_masked_p\n #define LOOP_VINFO_VECT_FACTOR(L)          (L)->vectorization_factor\n #define LOOP_VINFO_MAX_VECT_FACTOR(L)      (L)->max_vectorization_factor\n+#define LOOP_VINFO_MASKS(L)                (L)->masks\n+#define LOOP_VINFO_MASK_COMPARE_TYPE(L)    (L)->mask_compare_type\n #define LOOP_VINFO_PTR_MASK(L)             (L)->ptr_mask\n #define LOOP_VINFO_LOOP_NEST(L)            (L)->loop_nest\n #define LOOP_VINFO_DATAREFS(L)             (L)->datarefs\n@@ -1172,6 +1286,17 @@ vect_nunits_for_cost (tree vec_type)\n   return estimated_poly_value (TYPE_VECTOR_SUBPARTS (vec_type));\n }\n \n+/* Return the maximum possible vectorization factor for LOOP_VINFO.  */\n+\n+static inline unsigned HOST_WIDE_INT\n+vect_max_vf (loop_vec_info loop_vinfo)\n+{\n+  unsigned HOST_WIDE_INT vf;\n+  if (LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&vf))\n+    return vf;\n+  return MAX_VECTORIZATION_FACTOR;\n+}\n+\n /* Return the size of the value accessed by unvectorized data reference DR.\n    This is only valid once STMT_VINFO_VECTYPE has been calculated for the\n    associated gimple statement, since that guarantees that DR accesses\n@@ -1194,8 +1319,8 @@ extern source_location vect_location;\n \n /* Simple loop peeling and versioning utilities for vectorizer's purposes -\n    in tree-vect-loop-manip.c.  */\n-extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree, tree,\n-\t\t\t\t\t     tree, bool);\n+extern void vect_set_loop_condition (struct loop *, loop_vec_info,\n+\t\t\t\t     tree, tree, tree, bool);\n extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n struct loop *slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *,\n \t\t\t\t\t\t     struct loop *, edge);\n@@ -1212,6 +1337,7 @@ extern tree get_vectype_for_scalar_type (tree);\n extern tree get_vectype_for_scalar_type_and_size (tree, poly_uint64);\n extern tree get_mask_type_for_scalar_type (tree);\n extern tree get_same_sized_vectype (tree, tree);\n+extern bool vect_get_loop_mask_type (loop_vec_info);\n extern bool vect_is_simple_use (tree, vec_info *, gimple **,\n                                 enum vect_def_type *);\n extern bool vect_is_simple_use (tree, vec_info *, gimple **,\n@@ -1266,6 +1392,7 @@ extern bool vect_supportable_shift (enum tree_code, tree);\n extern tree vect_gen_perm_mask_any (tree, const vec_perm_indices &);\n extern tree vect_gen_perm_mask_checked (tree, const vec_perm_indices &);\n extern void optimize_mask_stores (struct loop*);\n+extern gcall *vect_gen_while (tree, tree, tree);\n \n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, unsigned int);\n@@ -1322,6 +1449,13 @@ extern loop_vec_info vect_analyze_loop (struct loop *, loop_vec_info);\n extern tree vect_build_loop_niters (loop_vec_info, bool * = NULL);\n extern void vect_gen_vector_loop_niters (loop_vec_info, tree, tree *,\n \t\t\t\t\t tree *, bool);\n+extern tree vect_halve_mask_nunits (tree);\n+extern tree vect_double_mask_nunits (tree);\n+extern void vect_record_loop_mask (loop_vec_info, vec_loop_masks *,\n+\t\t\t\t   unsigned int, tree);\n+extern tree vect_get_loop_mask (gimple_stmt_iterator *, vec_loop_masks *,\n+\t\t\t\tunsigned int, tree, unsigned int);\n+\n /* Drive for loop transformation stage.  */\n extern struct loop *vect_transform_loop (loop_vec_info);\n extern loop_vec_info vect_analyze_loop_form (struct loop *);"}, {"sha": "8a0b77243ca1d41bdff9e85a8101cedc80a55adf", "filename": "gcc/wide-int.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfb4d93595da03abb4e6414758dc98eb7532b34/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=7cfb4d93595da03abb4e6414758dc98eb7532b34", "patch": "@@ -557,6 +557,7 @@ namespace wi\n   BINARY_FUNCTION udiv_floor (const T1 &, const T2 &);\n   BINARY_FUNCTION sdiv_floor (const T1 &, const T2 &);\n   BINARY_FUNCTION div_ceil (const T1 &, const T2 &, signop, bool * = 0);\n+  BINARY_FUNCTION udiv_ceil (const T1 &, const T2 &);\n   BINARY_FUNCTION div_round (const T1 &, const T2 &, signop, bool * = 0);\n   BINARY_FUNCTION divmod_trunc (const T1 &, const T2 &, signop,\n \t\t\t\tWI_BINARY_RESULT (T1, T2) *);\n@@ -2677,6 +2678,14 @@ wi::div_ceil (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n   return quotient;\n }\n \n+/* Return X / Y, rouding towards +inf.  Treat X and Y as unsigned values.  */\n+template <typename T1, typename T2>\n+inline WI_BINARY_RESULT (T1, T2)\n+wi::udiv_ceil (const T1 &x, const T2 &y)\n+{\n+  return div_ceil (x, y, UNSIGNED);\n+}\n+\n /* Return X / Y, rouding towards nearest with ties away from zero.\n    Treat X and Y as having the signedness given by SGN.  Indicate\n    in *OVERFLOW if the result overflows.  */"}]}