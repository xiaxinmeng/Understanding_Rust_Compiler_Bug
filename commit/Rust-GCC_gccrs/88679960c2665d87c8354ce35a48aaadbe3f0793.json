{"sha": "88679960c2665d87c8354ce35a48aaadbe3f0793", "node_id": "C_kwDOANBUbNoAKDg4Njc5OTYwYzI2NjVkODdjODM1NGNlMzVhNDhhYWFkYmUzZjA3OTM", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2023-01-14T00:15:44Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2023-01-14T00:15:44Z"}, "message": "hash table: enforce testing is_empty before is_deleted\n\nExisting hash_table traits that use the same representation for empty\nand deleted slots reject marking slots as deleted, and to not pass\nis_deleted for slots that pass is_empty.\n\nNevertheless, nearly everywhere, we only test for is_deleted after\nchecking that !is_empty first.  The one exception was the copy\nconstructor, that would fail if traits recognized is_empty slots as\nis_deleted, but then refused to mark_deleted.\n\nThis asymmetry is neither necessary nor desirable, and there is a\ntheoretical risk that traits might not only fail to refuse to\nmark_deleted, but also return is_deleted for is_empty slots.\n\nThis patch introduces checks that detect these potentially problematic\nsituations, and reorders the tests in the copy constructor so as to\nuse the conventional testing order and thus avoid them.\n\n\nfor  gcc/ChangeLog\n\n\t* hash-table.h (is_deleted): Precheck !is_empty.\n\t(mark_deleted): Postcheck !is_empty.\n\t(copy constructor): Test is_empty before is_deleted.", "tree": {"sha": "363067a301e087ea439e9e04a8120799877da304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/363067a301e087ea439e9e04a8120799877da304"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88679960c2665d87c8354ce35a48aaadbe3f0793", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88679960c2665d87c8354ce35a48aaadbe3f0793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88679960c2665d87c8354ce35a48aaadbe3f0793", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88679960c2665d87c8354ce35a48aaadbe3f0793/comments", "author": null, "committer": null, "parents": [{"sha": "31aaa6ef5a952d4f64fb04010459f28e0e793702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31aaa6ef5a952d4f64fb04010459f28e0e793702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31aaa6ef5a952d4f64fb04010459f28e0e793702"}], "stats": {"total": 16, "additions": 14, "deletions": 2}, "files": [{"sha": "e37625dc315bf169c10e1cb7837c62095827b179", "filename": "gcc/hash-table.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88679960c2665d87c8354ce35a48aaadbe3f0793/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88679960c2665d87c8354ce35a48aaadbe3f0793/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=88679960c2665d87c8354ce35a48aaadbe3f0793", "patch": "@@ -534,6 +534,11 @@ class hash_table\n   void expand ();\n   static bool is_deleted (value_type &v)\n   {\n+    /* Traits are supposed to avoid recognizing elements as both empty\n+       and deleted, but to fail safe in case custom traits fail to do\n+       that, make sure we never test for is_deleted without having\n+       first ruled out is_empty.  */\n+    gcc_checking_assert (!Descriptor::is_empty (v));\n     return Descriptor::is_deleted (v);\n   }\n \n@@ -545,6 +550,11 @@ class hash_table\n   static void mark_deleted (value_type &v)\n   {\n     Descriptor::mark_deleted (v);\n+    /* Traits are supposed to refuse to set elements as deleted if\n+       those would be indistinguishable from empty, but to fail safe\n+       in case custom traits fail to do that, check that the\n+       just-deleted element does not look empty.  */\n+    gcc_checking_assert (!Descriptor::is_empty (v));\n   }\n \n   static void mark_empty (value_type &v)\n@@ -700,9 +710,11 @@ hash_table<Descriptor, Lazy, Allocator>::hash_table (const hash_table &h,\n       for (size_t i = 0; i < size; ++i)\n \t{\n \t  value_type &entry = h.m_entries[i];\n-\t  if (is_deleted (entry))\n+\t  if (is_empty (entry))\n+\t    continue;\n+\t  else if (is_deleted (entry))\n \t    mark_deleted (nentries[i]);\n-\t  else if (!is_empty (entry))\n+\t  else\n \t    new ((void*) (nentries + i)) value_type (entry);\n \t}\n       m_entries = nentries;"}]}