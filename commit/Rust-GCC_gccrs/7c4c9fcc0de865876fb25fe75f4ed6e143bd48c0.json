{"sha": "7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M0YzlmY2MwZGU4NjU4NzZmYjI1ZmU3NWY0ZWQ2ZTE0M2JkNDhjMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-07T20:52:18Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-07T21:00:18Z"}, "message": "Fix incorrect array bounds with -fgnat-encodings=minimal in DWARF\n\nThis makes add_subscript_info query the get_array_descr_info hook for the\nactual information when it is defined.\n\ngcc/\n\t* cfgexpand.c (expand_gimple_basic_block): Do not inherit a current\n\tlocation for the outgoing edges of an empty block.\n\t* dwarf2out.c (add_subscript_info): Retrieve the bounds and index\n\ttype by means of the get_array_descr_info langhook, if it is set and\n\treturns true.  Remove obsolete code dealing with unnamed subtypes.\ngcc/testsuite/\n\t* gnat.dg/debug18.adb: New test.", "tree": {"sha": "f9b34d8fe214acb259b132a0b0af7a519f030910", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9b34d8fe214acb259b132a0b0af7a519f030910"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0/comments", "author": null, "committer": null, "parents": [{"sha": "14b0f37a644d7b59e1737fb275ec4fff044972a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14b0f37a644d7b59e1737fb275ec4fff044972a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14b0f37a644d7b59e1737fb275ec4fff044972a8"}], "stats": {"total": 72, "additions": 50, "deletions": 22}, "files": [{"sha": "747ca3e73893aaf46299af28f8e1e1ee110de668", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0", "patch": "@@ -6056,7 +6056,7 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n   /* Expand implicit goto and convert goto_locus.  */\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n-      if (e->goto_locus != UNKNOWN_LOCATION)\n+      if (e->goto_locus != UNKNOWN_LOCATION || !stmt)\n \tset_curr_insn_location (e->goto_locus);\n       if ((e->flags & EDGE_FALLTHRU) && e->dest != bb->next_bb)\n \t{"}, {"sha": "a5ec21aa456137a6894a29715be88b2587492f82", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0", "patch": "@@ -21313,18 +21313,28 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr,\n \n /* Add subscript info to TYPE_DIE, describing an array TYPE, collapsing\n    possibly nested array subscripts in a flat sequence if COLLAPSE_P is true.\n-   Note that the block of subscript information for an array type also\n-   includes information about the element type of the given array type.\n \n    This function reuses previously set type and bound information if\n    available.  */\n \n static void\n add_subscript_info (dw_die_ref type_die, tree type, bool collapse_p)\n {\n-  unsigned dimension_number;\n-  tree lower, upper;\n   dw_die_ref child = type_die->die_child;\n+  struct array_descr_info info;\n+  int dimension_number;\n+\n+  if (lang_hooks.types.get_array_descr_info)\n+    {\n+      memset (&info, 0, sizeof (info));\n+      if (lang_hooks.types.get_array_descr_info (type, &info))\n+\t/* Fortran sometimes emits array types with no dimension.  */\n+\tgcc_assert (info.ndimensions >= 0\n+\t\t    && info.ndimensions\n+\t\t       <= DWARF2OUT_ARRAY_DESCR_INFO_MAX_DIMEN);\n+    }\n+  else\n+    info.ndimensions = 0;\n \n   for (dimension_number = 0;\n        TREE_CODE (type) == ARRAY_TYPE && (dimension_number == 0 || collapse_p);\n@@ -21372,35 +21382,32 @@ add_subscript_info (dw_die_ref type_die, tree type, bool collapse_p)\n       if (domain)\n \t{\n \t  /* We have an array type with specified bounds.  */\n-\t  lower = TYPE_MIN_VALUE (domain);\n-\t  upper = TYPE_MAX_VALUE (domain);\n+\t  tree lower = TYPE_MIN_VALUE (domain);\n+\t  tree upper = TYPE_MAX_VALUE (domain);\n+\t  tree index_type = TREE_TYPE (domain);\n \n-\t  /* Define the index type.  */\n-\t  if (TREE_TYPE (domain)\n-\t      && !get_AT (subrange_die, DW_AT_type))\n+\t  if (dimension_number <= info.ndimensions - 1)\n \t    {\n-\t      /* ??? This is probably an Ada unnamed subrange type.  Ignore the\n-\t\t TREE_TYPE field.  We can't emit debug info for this\n-\t\t because it is an unnamed integral type.  */\n-\t      if (TREE_CODE (domain) == INTEGER_TYPE\n-\t\t  && TYPE_NAME (domain) == NULL_TREE\n-\t\t  && TREE_CODE (TREE_TYPE (domain)) == INTEGER_TYPE\n-\t\t  && TYPE_NAME (TREE_TYPE (domain)) == NULL_TREE)\n-\t\t;\n-\t      else\n-\t\tadd_type_attribute (subrange_die, TREE_TYPE (domain),\n-\t\t\t\t    TYPE_UNQUALIFIED, false, type_die);\n+\t      lower = info.dimen[dimension_number].lower_bound;\n+\t      upper = info.dimen[dimension_number].upper_bound;\n+\t      index_type = info.dimen[dimension_number].bounds_type;\n \t    }\n \n+\t  /* Define the index type.  */\n+\t  if (index_type && !get_AT (subrange_die, DW_AT_type))\n+\t    add_type_attribute (subrange_die, index_type, TYPE_UNQUALIFIED,\n+\t\t\t\tfalse, type_die);\n+\n \t  /* ??? If upper is NULL, the array has unspecified length,\n \t     but it does have a lower bound.  This happens with Fortran\n \t       dimension arr(N:*)\n \t     Since the debugger is definitely going to need to know N\n \t     to produce useful results, go ahead and output the lower\n \t     bound solo, and hope the debugger can cope.  */\n \n-\t  if (!get_AT (subrange_die, DW_AT_lower_bound))\n+\t  if (lower && !get_AT (subrange_die, DW_AT_lower_bound))\n \t    add_bound_info (subrange_die, DW_AT_lower_bound, lower, NULL);\n+\n \t  if (!get_AT (subrange_die, DW_AT_upper_bound)\n \t      && !get_AT (subrange_die, DW_AT_count))\n \t    {\n@@ -22129,6 +22136,7 @@ decl_start_label (tree decl)\n /* For variable-length arrays that have been previously generated, but\n    may be incomplete due to missing subscript info, fill the subscript\n    info.  Return TRUE if this is one of those cases.  */\n+\n static bool\n fill_variable_array_bounds (tree type)\n {"}, {"sha": "59ba54ddac0e5dca7617957bd3e71404d412ba91", "filename": "gcc/testsuite/gnat.dg/debug18.adb", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0/gcc%2Ftestsuite%2Fgnat.dg%2Fdebug18.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0/gcc%2Ftestsuite%2Fgnat.dg%2Fdebug18.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdebug18.adb?ref=7c4c9fcc0de865876fb25fe75f4ed6e143bd48c0", "patch": "@@ -0,0 +1,20 @@\n+-- { dg-do compile }\n+-- { dg-skip-if \"No Dwarf\" { { hppa*-*-hpux* } && { ! lp64 } } }\n+-- { dg-options \"-cargs -O0 -g -dA -fgnat-encodings=minimal -margs\" }\n+\n+procedure Debug18 is\n+\n+   procedure Check (Size : Integer) is\n+      type Bit_Array_Type is array (1 .. Size) of boolean;\n+      pragma Pack (Bit_Array_Type);\n+\n+      Bits : Bit_Array_Type := (others => False);\n+   begin\n+      Bits (Bits'First) := True;\n+   end;\n+  \n+begin\n+   Check (Size => 9);\n+end;\n+\n+-- { dg-final { scan-assembler-not \"DW_AT_lower_bound\" } }"}]}