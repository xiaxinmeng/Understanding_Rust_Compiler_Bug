{"sha": "abbfd69841b2357d242d47abda8d0430269ab829", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJiZmQ2OTg0MWIyMzU3ZDI0MmQ0N2FiZGE4ZDA0MzAyNjlhYjgyOQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-09-26T09:18:35Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-09-26T09:18:35Z"}, "message": "[Ada] Spurious dependency on secondary stack\n\nThis patch reimplements the handling of the secondary stack when the\niteration scheme of a loop statement requires this support.\n\nPrior to this modification, an iterator loop over a container was\nassumed to require unconditional secondary stack management. This is\nhowever not always true because of user-defined iterator types, where\nroutines First and Next return an iterator that does require the\nsecondary stack.\n\n------------\n-- Source --\n------------\n\n--  gnat.adc\n\npragma Restrictions (No_Secondary_Stack);\n\n--  test.ads\n\npackage Test is\n   type Test_Type is private\n   with\n      Default_Initial_Condition,\n      Iterable => (First       => First_Element,\n                   Next        => Next_Element,\n                   Has_Element => Has_Element,\n                   Element     => Element);\n\n   type Cursor_Type is private;\n\n   function First_Element (T : Test_Type) return Cursor_Type;\n\n   function Next_Element (T : Test_Type; C : Cursor_Type) return Cursor_Type;\n\n   function Has_Element (T : Test_Type; C : Cursor_Type) return Boolean;\n\n   function Element (T : Test_Type; C : Cursor_Type) return Natural;\n\nprivate\n   type Cursor_Type is new Natural;\n\n   type Test_Type is record\n      null;\n   end record;\n\n   function First_Element (T : Test_Type) return Cursor_Type\n   is (0);\n\n   function Next_Element (T : Test_Type; C : Cursor_Type) return Cursor_Type\n   is (0);\n\n   function Has_Element (T : Test_Type; C : Cursor_Type) return Boolean\n   is (False);\n\n   function Element (T : Test_Type; C : Cursor_Type) return Natural\n   is (0);\nend Test;\n\n--  main.adb\n\nwith Test; use Test;\n\nprocedure Main is\n   F : Boolean;\n   M : Test_Type;\n\nbegin\n   for Elem of M loop\n      null;\n   end loop;\n\n   F := (for all C of M => C = 1);\n   F := (for all C in M => True);\nend Main;\n\n-----------------\n-- Compilation --\n-----------------\n\n$ gnatmake -q --RTS=zfp -nostdlib main.adb\n\n2018-09-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch4.adb (Expand_N_Allocator): Ensure that the use of the\n\tsecondary stack does not clash with restriction\n\tNo_Secondary_Stack.\n\t* exp_ch6.adb (Expand_N_Extended_Return_Statement): Ensure that\n\tthe use of the secondary stack does not clash with restriction\n\tNo_Secondary_Stack.\n\t* sem_ch5.adb (Analyze_Loop_Statement): Wrap the loop in a block\n\tprior to analysis in order to either provide a local scope for\n\tan iterator, or ensure that the secondary stack is properly\n\tmanaged.\n\t(Check_Call): Account for the case where the tree may be\n\tunanalyzed or contain prior errors.\n\t(Has_Call_Using_Secondary_Stack): Renamed to Has_Sec_Stack_Call.\n\tUpdate all uses of the subprogram.\n\t(Prepare_Loop_Statement): New routine.\n\nFrom-SVN: r264625", "tree": {"sha": "0780ea6986b51d3e34b042b2235195b6dddbca58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0780ea6986b51d3e34b042b2235195b6dddbca58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abbfd69841b2357d242d47abda8d0430269ab829", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abbfd69841b2357d242d47abda8d0430269ab829", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abbfd69841b2357d242d47abda8d0430269ab829", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abbfd69841b2357d242d47abda8d0430269ab829/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c886a946134d08a3ae3ad2dacbcee8d6b981db1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c886a946134d08a3ae3ad2dacbcee8d6b981db1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c886a946134d08a3ae3ad2dacbcee8d6b981db1d"}], "stats": {"total": 557, "additions": 362, "deletions": 195}, "files": [{"sha": "d549a870de57795bacc8a23490af4f068a05f968", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbfd69841b2357d242d47abda8d0430269ab829/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbfd69841b2357d242d47abda8d0430269ab829/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=abbfd69841b2357d242d47abda8d0430269ab829", "patch": "@@ -1,3 +1,21 @@\n+2018-09-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Allocator): Ensure that the use of the\n+\tsecondary stack does not clash with restriction\n+\tNo_Secondary_Stack.\n+\t* exp_ch6.adb (Expand_N_Extended_Return_Statement): Ensure that\n+\tthe use of the secondary stack does not clash with restriction\n+\tNo_Secondary_Stack.\n+\t* sem_ch5.adb (Analyze_Loop_Statement): Wrap the loop in a block\n+\tprior to analysis in order to either provide a local scope for\n+\tan iterator, or ensure that the secondary stack is properly\n+\tmanaged.\n+\t(Check_Call): Account for the case where the tree may be\n+\tunanalyzed or contain prior errors.\n+\t(Has_Call_Using_Secondary_Stack): Renamed to Has_Sec_Stack_Call.\n+\tUpdate all uses of the subprogram.\n+\t(Prepare_Loop_Statement): New routine.\n+\n 2018-09-26  Javier Miranda  <miranda@adacore.com>\n \n \t* sem_res.adb (Resolve_Actuals): If the formal is a class-wide"}, {"sha": "09a6cd0541efaa142b9ce01e43b33f31ca9796f2", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbfd69841b2357d242d47abda8d0430269ab829/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbfd69841b2357d242d47abda8d0430269ab829/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=abbfd69841b2357d242d47abda8d0430269ab829", "patch": "@@ -4417,6 +4417,7 @@ package body Exp_Ch4 is\n             Set_Storage_Pool (N, Pool);\n \n             if Is_RTE (Pool, RE_SS_Pool) then\n+               Check_Restriction (No_Secondary_Stack, N);\n                Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n \n             --  In the case of an allocator for a simple storage pool, locate"}, {"sha": "96ee696bdb75c69629309cf4b4fb81358f175641", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbfd69841b2357d242d47abda8d0430269ab829/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbfd69841b2357d242d47abda8d0430269ab829/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=abbfd69841b2357d242d47abda8d0430269ab829", "patch": "@@ -5267,8 +5267,9 @@ package body Exp_Ch6 is\n                         Set_Comes_From_Source (Pool_Allocator, True);\n                      end if;\n \n-                     --  The allocator is returned on the secondary stack.\n+                     --  The allocator is returned on the secondary stack\n \n+                     Check_Restriction (No_Secondary_Stack, N);\n                      Set_Storage_Pool (SS_Allocator, RTE (RE_SS_Pool));\n                      Set_Procedure_To_Call\n                        (SS_Allocator, RTE (RE_SS_Allocate));"}, {"sha": "8c1f94989dcdcf4aa6f1ba853d96c4a5853a103b", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 341, "deletions": 194, "changes": 535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abbfd69841b2357d242d47abda8d0430269ab829/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abbfd69841b2357d242d47abda8d0430269ab829/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=abbfd69841b2357d242d47abda8d0430269ab829", "patch": "@@ -83,7 +83,7 @@ package body Sem_Ch5 is\n    --  messages. This variable is recursively saved on entry to processing the\n    --  construct, and restored on exit.\n \n-   function Has_Call_Using_Secondary_Stack (N : Node_Id) return Boolean;\n+   function Has_Sec_Stack_Call (N : Node_Id) return Boolean;\n    --  N is the node for an arbitrary construct. This function searches the\n    --  construct N to see if any expressions within it contain function\n    --  calls that use the secondary stack, returning True if any such call\n@@ -2850,7 +2850,7 @@ package body Sem_Ch5 is\n             --  proper trace of the value, useful in optimizations that get rid\n             --  of junk range checks.\n \n-            if not Has_Call_Using_Secondary_Stack (Analyzed_Bound) then\n+            if not Has_Sec_Stack_Call (Analyzed_Bound) then\n                Analyze_And_Resolve (Original_Bound, Typ);\n \n                --  Ensure that the bound is valid. This check should not be\n@@ -3360,18 +3360,23 @@ package body Sem_Ch5 is\n \n    procedure Analyze_Loop_Statement (N : Node_Id) is\n \n+      --  The following exception is raised by routine Prepare_Loop_Statement\n+      --  to avoid further analysis of a transformed loop.\n+\n+      Skip_Analysis : exception;\n+\n       function Disable_Constant (N : Node_Id) return Traverse_Result;\n       --  If N represents an E_Variable entity, set Is_True_Constant To False\n \n-      function Is_Container_Iterator (Iter : Node_Id) return Boolean;\n-      --  Given a loop iteration scheme, determine whether it is an Ada 2012\n-      --  container iteration.\n+      procedure Disable_Constants is new Traverse_Proc (Disable_Constant);\n+      --  Helper for Analyze_Loop_Statement, to unset Is_True_Constant on\n+      --  variables referenced within an OpenACC construct.\n \n-      function Is_Wrapped_In_Block (N : Node_Id) return Boolean;\n-      --  Determine whether loop statement N has been wrapped in a block to\n-      --  capture finalization actions that may be generated for container\n-      --  iterators. Prevents infinite recursion when block is analyzed.\n-      --  Routine is a noop if loop is single statement within source block.\n+      procedure Prepare_Loop_Statement (Iter : Node_Id);\n+      --  Determine whether loop statement N with iteration scheme Iter must be\n+      --  transformed prior to analysis, and if so, perform it. The routine\n+      --  raises Skip_Analysis to prevent further analysis of the transformed\n+      --  loop.\n \n       ----------------------\n       -- Disable_Constant --\n@@ -3385,104 +3390,328 @@ package body Sem_Ch5 is\n          then\n             Set_Is_True_Constant (Entity (N), False);\n          end if;\n+\n          return OK;\n       end Disable_Constant;\n \n-      procedure Disable_Constants is new Traverse_Proc (Disable_Constant);\n-      --  Helper for Analyze_Loop_Statement, to unset Is_True_Constant on\n-      --  variables referenced within an OpenACC environment.\n+      ----------------------------\n+      -- Prepare_Loop_Statement --\n+      ----------------------------\n+\n+      procedure Prepare_Loop_Statement (Iter : Node_Id) is\n+         function Has_Sec_Stack_Default_Iterator\n+           (Cont_Typ : Entity_Id) return Boolean;\n+         pragma Inline (Has_Sec_Stack_Default_Iterator);\n+         --  Determine whether container type Cont_Typ has a default iterator\n+         --  that requires secondary stack management.\n+\n+         function Is_Sec_Stack_Iteration_Primitive\n+           (Cont_Typ      : Entity_Id;\n+            Iter_Prim_Nam : Name_Id) return Boolean;\n+         pragma Inline (Is_Sec_Stack_Iteration_Primitive);\n+         --  Determine whether container type Cont_Typ has an iteration routine\n+         --  described by its name Iter_Prim_Nam that requires secondary stack\n+         --  management.\n+\n+         function Is_Wrapped_In_Block (Stmt : Node_Id) return Boolean;\n+         pragma Inline (Is_Wrapped_In_Block);\n+         --  Determine whether arbitrary statement Stmt is the sole statement\n+         --  wrapped within some block, excluding pragmas.\n+\n+         procedure Prepare_Iterator_Loop (Iter_Spec : Node_Id);\n+         pragma Inline (Prepare_Iterator_Loop);\n+         --  Prepare an iterator loop with iteration specification Iter_Spec\n+         --  for transformation if needed.\n+\n+         procedure Prepare_Param_Spec_Loop (Param_Spec : Node_Id);\n+         pragma Inline (Prepare_Param_Spec_Loop);\n+         --  Prepare a discrete loop with parameter specification Param_Spec\n+         --  for transformation if needed.\n+\n+         procedure Wrap_Loop_Statement (Manage_Sec_Stack : Boolean);\n+         pragma Inline (Wrap_Loop_Statement);\n+         --  Wrap loop statement N within a block. Flag Manage_Sec_Stack must\n+         --  be set when the block must mark and release the secondary stack.\n+\n+         ------------------------------------\n+         -- Has_Sec_Stack_Default_Iterator --\n+         ------------------------------------\n+\n+         function Has_Sec_Stack_Default_Iterator\n+           (Cont_Typ : Entity_Id) return Boolean\n+         is\n+            Def_Iter : constant Node_Id :=\n+                         Find_Value_Of_Aspect\n+                           (Cont_Typ, Aspect_Default_Iterator);\n+         begin\n+            return\n+              Present (Def_Iter)\n+                and then Requires_Transient_Scope (Etype (Def_Iter));\n+         end Has_Sec_Stack_Default_Iterator;\n+\n+         --------------------------------------\n+         -- Is_Sec_Stack_Iteration_Primitive --\n+         --------------------------------------\n+\n+         function Is_Sec_Stack_Iteration_Primitive\n+           (Cont_Typ      : Entity_Id;\n+            Iter_Prim_Nam : Name_Id) return Boolean\n+         is\n+            Iter_Prim : constant Entity_Id :=\n+                          Get_Iterable_Type_Primitive\n+                            (Cont_Typ, Iter_Prim_Nam);\n+         begin\n+            return\n+              Present (Iter_Prim)\n+                and then Requires_Transient_Scope (Etype (Iter_Prim));\n+         end Is_Sec_Stack_Iteration_Primitive;\n \n-      ---------------------------\n-      -- Is_Container_Iterator --\n-      ---------------------------\n+         -------------------------\n+         -- Is_Wrapped_In_Block --\n+         -------------------------\n \n-      function Is_Container_Iterator (Iter : Node_Id) return Boolean is\n-      begin\n-         --  Infinite loop\n+         function Is_Wrapped_In_Block (Stmt : Node_Id) return Boolean is\n+            Blk_HSS  : Node_Id;\n+            Blk_Id   : Entity_Id;\n+            Blk_Stmt : Node_Id;\n \n-         if No (Iter) then\n-            return False;\n+         begin\n+            Blk_Id := Current_Scope;\n \n-         --  While loop\n+            --  The current context is a block. Inspect the statements of the\n+            --  block to determine whether it wraps Stmt.\n+\n+            if Ekind (Blk_Id) = E_Block\n+              and then Present (Block_Node (Blk_Id))\n+            then\n+               Blk_HSS :=\n+                 Handled_Statement_Sequence (Parent (Block_Node (Blk_Id)));\n+\n+               --  Skip leading pragmas introduced for invariant and predicate\n+               --  checks.\n+\n+               Blk_Stmt := First (Statements (Blk_HSS));\n+               while Present (Blk_Stmt)\n+                 and then Nkind (Blk_Stmt) = N_Pragma\n+               loop\n+                  Next (Blk_Stmt);\n+               end loop;\n+\n+               return Blk_Stmt = Stmt and then No (Next (Blk_Stmt));\n+            end if;\n \n-         elsif Present (Condition (Iter)) then\n             return False;\n+         end Is_Wrapped_In_Block;\n \n-         --  for Def_Id in [reverse] Name loop\n-         --  for Def_Id [: Subtype_Indication] of [reverse] Name loop\n+         ---------------------------\n+         -- Prepare_Iterator_Loop --\n+         ---------------------------\n \n-         elsif Present (Iterator_Specification (Iter)) then\n-            declare\n-               Nam : constant Node_Id := Name (Iterator_Specification (Iter));\n-               Nam_Copy : Node_Id;\n+         procedure Prepare_Iterator_Loop (Iter_Spec : Node_Id) is\n+            Cont_Typ : Entity_Id;\n+            Nam      : Node_Id;\n+            Nam_Copy : Node_Id;\n \n-            begin\n+         begin\n+            --  The iterator specification has syntactic errors. Transform the\n+            --  loop into an infinite loop in order to safely perform at least\n+            --  some minor analysis. This check must come first.\n+\n+            if Error_Posted (Iter_Spec) then\n+               Set_Iteration_Scheme (N, Empty);\n+               Analyze (N);\n+\n+               raise Skip_Analysis;\n+\n+            --  Nothing to do when the loop is already wrapped in a block\n+\n+            elsif Is_Wrapped_In_Block (N) then\n+               null;\n+\n+            --  Otherwise the iterator loop traverses an array or a container\n+            --  and appears in the form\n+            --\n+            --    for Def_Id in [reverse] Iterator_Name loop\n+            --    for Def_Id [: Subtyp_Indic] of [reverse] Iterable_Name loop\n+\n+            else\n+               --  Prepare a copy of the iterated name for preanalysis. The\n+               --  copy is semi inserted into the tree by setting its Parent\n+               --  pointer.\n+\n+               Nam      := Name (Iter_Spec);\n                Nam_Copy := New_Copy_Tree (Nam);\n                Set_Parent (Nam_Copy, Parent (Nam));\n+\n+               --  Determine what the loop is iterating on\n+\n                Preanalyze_Range (Nam_Copy);\n+               Cont_Typ := Etype (Nam_Copy);\n \n-               --  The only two options here are iteration over a container or\n-               --  an array.\n+               --  The iterator loop is traversing an array. This case does not\n+               --  require any transformation.\n \n-               return not Is_Array_Type (Etype (Nam_Copy));\n-            end;\n+               if Is_Array_Type (Cont_Typ) then\n+                  null;\n \n-         --  for Def_Id in [reverse] Discrete_Subtype_Definition loop\n+               --  Otherwise unconditionally wrap the loop statement within\n+               --  a block. The expansion of iterator loops may relocate the\n+               --  iterator outside the loop, thus \"leaking\" its entity into\n+               --  the enclosing scope. Wrapping the loop statement allows\n+               --  for multiple iterator loops using the same iterator name\n+               --  to coexist within the same scope.\n+               --\n+               --  The block must manage the secondary stack when the iterator\n+               --  loop is traversing a container using either\n+               --\n+               --    * A default iterator obtained on the secondary stack\n+               --\n+               --    * Call to Iterate where the iterator is returned on the\n+               --      secondary stack.\n+               --\n+               --    * Combination of First, Next, and Has_Element where the\n+               --      first two return a cursor on the secondary stack.\n \n-         else\n-            declare\n-               LP : constant Node_Id := Loop_Parameter_Specification (Iter);\n-               DS : constant Node_Id := Discrete_Subtype_Definition (LP);\n-               DS_Copy : Node_Id;\n+               else\n+                  Wrap_Loop_Statement\n+                    (Manage_Sec_Stack =>\n+                       Has_Sec_Stack_Default_Iterator (Cont_Typ)\n+                         or else Has_Sec_Stack_Call (Nam_Copy)\n+                         or else Is_Sec_Stack_Iteration_Primitive\n+                                   (Cont_Typ, Name_First)\n+                         or else Is_Sec_Stack_Iteration_Primitive\n+                                   (Cont_Typ, Name_Next));\n+               end if;\n+            end if;\n+         end Prepare_Iterator_Loop;\n \n-            begin\n-               DS_Copy := New_Copy_Tree (DS);\n-               Set_Parent (DS_Copy, Parent (DS));\n-               Preanalyze_Range (DS_Copy);\n+         -----------------------------\n+         -- Prepare_Param_Spec_Loop --\n+         -----------------------------\n \n-               --  Check for a call to Iterate () or an expression with\n-               --  an iterator type.\n+         procedure Prepare_Param_Spec_Loop (Param_Spec : Node_Id) is\n+            High     : Node_Id;\n+            Low      : Node_Id;\n+            Rng      : Node_Id;\n+            Rng_Copy : Node_Id;\n+            Rng_Typ  : Entity_Id;\n \n-               return\n-                 (Nkind (DS_Copy) = N_Function_Call\n-                   and then Needs_Finalization (Etype (DS_Copy)))\n-                 or else Is_Iterator (Etype (DS_Copy));\n-            end;\n-         end if;\n-      end Is_Container_Iterator;\n+         begin\n+            Rng := Discrete_Subtype_Definition (Param_Spec);\n \n-      -------------------------\n-      -- Is_Wrapped_In_Block --\n-      -------------------------\n+            --  Nothing to do when the loop is already wrapped in a block\n \n-      function Is_Wrapped_In_Block (N : Node_Id) return Boolean is\n-         HSS  : Node_Id;\n-         Stat : Node_Id;\n+            if Is_Wrapped_In_Block (N) then\n+               null;\n \n-      begin\n+            --  The parameter specification appears in the form\n+            --\n+            --    for Def_Id in Subtype_Mark Constraint loop\n \n-         --  Check if current scope is a block that is not a transient block.\n+            elsif Nkind (Rng) = N_Subtype_Indication\n+              and then Nkind (Range_Expression (Constraint (Rng))) = N_Range\n+            then\n+               Rng := Range_Expression (Constraint (Rng));\n \n-         if Ekind (Current_Scope) /= E_Block\n-           or else No (Block_Node (Current_Scope))\n-         then\n-            return False;\n+               --  Preanalyze the bounds of the range constraint\n \n-         else\n-            HSS  :=\n-              Handled_Statement_Sequence (Parent (Block_Node (Current_Scope)));\n+               Low  := New_Copy_Tree (Low_Bound  (Rng));\n+               High := New_Copy_Tree (High_Bound (Rng));\n \n-            --  Skip leading pragmas that may be introduced for invariant and\n-            --  predicate checks.\n+               Preanalyze (Low);\n+               Preanalyze (High);\n \n-            Stat := First (Statements (HSS));\n-            while Present (Stat) and then Nkind (Stat) = N_Pragma loop\n-               Stat := Next (Stat);\n-            end loop;\n+               --  The bounds contain at least one function call that returns\n+               --  on the secondary stack. Note that the loop must be wrapped\n+               --  only when such a call exists.\n+\n+               if Has_Sec_Stack_Call (Low)\n+                    or else\n+                  Has_Sec_Stack_Call (High)\n+               then\n+                  Wrap_Loop_Statement (Manage_Sec_Stack => True);\n+               end if;\n+\n+            --  Otherwise the parameter specification appears in the form\n+            --\n+            --    for Def_Id in Range loop\n+\n+            else\n+               --  Prepare a copy of the discrete range for preanalysis. The\n+               --  copy is semi inserted into the tree by setting its Parent\n+               --  pointer.\n+\n+               Rng_Copy := New_Copy_Tree (Rng);\n+               Set_Parent (Rng_Copy, Parent (Rng));\n+\n+               --  Determine what the loop is iterating on\n+\n+               Preanalyze_Range (Rng_Copy);\n+               Rng_Typ := Etype (Rng_Copy);\n+\n+               --  Wrap the loop statement within a block in order to manage\n+               --  the secondary stack when the discrete range is\n+               --\n+               --    * Either a Forward_Iterator or a Reverse_Iterator\n+               --\n+               --    * Function call whose return type requires finalization\n+               --      actions.\n+\n+               --  ??? it is unclear why using Has_Sec_Stack_Call directly on\n+               --  the discrete range causes the freeze node of an itype to be\n+               --  in the wrong scope in complex assertion expressions.\n+\n+               if Is_Iterator (Rng_Typ)\n+                 or else (Nkind (Rng_Copy) = N_Function_Call\n+                           and then Needs_Finalization (Rng_Typ))\n+               then\n+                  Wrap_Loop_Statement (Manage_Sec_Stack => True);\n+               end if;\n+            end if;\n+         end Prepare_Param_Spec_Loop;\n+\n+         -------------------------\n+         -- Wrap_Loop_Statement --\n+         -------------------------\n \n-            return Stat = N and then No (Next (Stat));\n+         procedure Wrap_Loop_Statement (Manage_Sec_Stack : Boolean) is\n+            Loc : constant Source_Ptr := Sloc (N);\n+\n+            Blk    : Node_Id;\n+            Blk_Id : Entity_Id;\n+\n+         begin\n+            Blk :=\n+              Make_Block_Statement (Loc,\n+                Declarations               => New_List,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (Relocate_Node (N))));\n+\n+            Add_Block_Identifier (Blk, Blk_Id);\n+            Set_Uses_Sec_Stack (Blk_Id, Manage_Sec_Stack);\n+\n+            Rewrite (N, Blk);\n+            Analyze (N);\n+\n+            raise Skip_Analysis;\n+         end Wrap_Loop_Statement;\n+\n+         --  Local variables\n+\n+         Iter_Spec  : constant Node_Id := Iterator_Specification (Iter);\n+         Param_Spec : constant Node_Id := Loop_Parameter_Specification (Iter);\n+\n+      --  Start of processing for Prepare_Loop_Statement\n+\n+      begin\n+         if Present (Iter_Spec) then\n+            Prepare_Iterator_Loop (Iter_Spec);\n+\n+         elsif Present (Param_Spec) then\n+            Prepare_Param_Spec_Loop (Param_Spec);\n          end if;\n-      end Is_Wrapped_In_Block;\n+      end Prepare_Loop_Statement;\n \n       --  Local declarations\n \n@@ -3561,114 +3790,25 @@ package body Sem_Ch5 is\n          Set_Has_Created_Identifier (N);\n       end if;\n \n-      --  If the iterator specification has a syntactic error, transform\n-      --  construct into an infinite loop to prevent a crash and perform\n-      --  some analysis.\n-\n-      if Present (Iter)\n-        and then Present (Iterator_Specification (Iter))\n-        and then Error_Posted (Iterator_Specification (Iter))\n-      then\n-         Set_Iteration_Scheme (N, Empty);\n-         Analyze (N);\n-         return;\n-      end if;\n-\n-      --  Iteration over a container in Ada 2012 involves the creation of a\n-      --  controlled iterator object. Wrap the loop in a block to ensure the\n-      --  timely finalization of the iterator and release of container locks.\n-      --  The same applies to the use of secondary stack when obtaining an\n-      --  iterator.\n-\n-      if Ada_Version >= Ada_2012\n-        and then Is_Container_Iterator (Iter)\n-        and then not Is_Wrapped_In_Block (N)\n-      then\n-         declare\n-            Block_Nod : Node_Id;\n-            Block_Id  : Entity_Id;\n-\n-         begin\n-            Block_Nod :=\n-              Make_Block_Statement (Loc,\n-                Declarations               => New_List,\n-                Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements => New_List (Relocate_Node (N))));\n-\n-            Add_Block_Identifier (Block_Nod, Block_Id);\n-\n-            --  The expansion of iterator loops generates an iterator in order\n-            --  to traverse the elements of a container:\n-\n-            --    Iter : <iterator type> := Iterate (Container)'reference;\n-\n-            --  The iterator is controlled and returned on the secondary stack.\n-            --  The analysis of the call to Iterate establishes a transient\n-            --  scope to deal with the secondary stack management, but never\n-            --  really creates a physical block as this would kill the iterator\n-            --  too early (see Wrap_Transient_Declaration). To address this\n-            --  case, mark the generated block as needing secondary stack\n-            --  management.\n-\n-            Set_Uses_Sec_Stack (Block_Id);\n-\n-            Rewrite (N, Block_Nod);\n-            Analyze (N);\n-            return;\n-         end;\n-      end if;\n-\n-      --  Wrap the loop in a block when the evaluation of the loop iterator\n-      --  relies on the secondary stack. Required to ensure releasing the\n-      --  secondary stack as soon as the loop completes.\n-\n-      if Present (Iter)\n-        and then Present (Loop_Parameter_Specification (Iter))\n-        and then not Is_Wrapped_In_Block (N)\n-      then\n-         declare\n-            LPS : constant Node_Id := Loop_Parameter_Specification (Iter);\n-            DSD : constant Node_Id :=\n-                    Original_Node (Discrete_Subtype_Definition (LPS));\n-\n-            Block_Id  : Entity_Id;\n-            Block_Nod : Node_Id;\n-            HB        : Node_Id;\n-            LB        : Node_Id;\n+      --  Determine whether the loop statement must be transformed prior to\n+      --  analysis, and if so, perform it. This early modification is needed\n+      --  when:\n+      --\n+      --    * The loop has an erroneous iteration scheme. In this case the\n+      --      loop is converted into an infinite loop in order to perform\n+      --      minor analysis.\n+      --\n+      --    * The loop is an Ada 2012 iterator loop. In this case the loop is\n+      --      wrapped within a block to provide a local scope for the iterator.\n+      --      If the iterator specification requires the secondary stack in any\n+      --      way, the block is marked in order to manage it.\n+      --\n+      --    * The loop is using a parameter specification where the discrete\n+      --      range requires the secondary stack. In this case the loop is\n+      --      wrapped within a block in order to manage the secondary stack.\n \n-         begin\n-            if Nkind (DSD) = N_Subtype_Indication\n-              and then Nkind (Range_Expression (Constraint (DSD))) = N_Range\n-            then\n-               LB :=\n-                 New_Copy_Tree\n-                   (Low_Bound (Range_Expression (Constraint (DSD))));\n-               HB :=\n-                 New_Copy_Tree\n-                   (High_Bound (Range_Expression (Constraint (DSD))));\n-\n-               Preanalyze (LB);\n-               Preanalyze (HB);\n-\n-               if Has_Call_Using_Secondary_Stack (LB)\n-                 or else Has_Call_Using_Secondary_Stack (HB)\n-               then\n-                  Block_Nod :=\n-                    Make_Block_Statement (Loc,\n-                      Declarations               => New_List,\n-                      Handled_Statement_Sequence =>\n-                        Make_Handled_Sequence_Of_Statements (Loc,\n-                          Statements => New_List (Relocate_Node (N))));\n-\n-                  Add_Block_Identifier (Block_Nod, Block_Id);\n-                  Set_Uses_Sec_Stack (Block_Id);\n-                  Rewrite (N, Block_Nod);\n-                  Analyze (N);\n-                  return;\n-               end if;\n-            end if;\n-         end;\n+      if Present (Iter) then\n+         Prepare_Loop_Statement (Iter);\n       end if;\n \n       --  Kill current values on entry to loop, since statements in the body of\n@@ -3842,6 +3982,10 @@ package body Sem_Ch5 is\n       if Is_OpenAcc_Environment (Stmt) then\n          Disable_Constants (Stmt);\n       end if;\n+\n+   exception\n+      when Skip_Analysis =>\n+         null;\n    end Analyze_Loop_Statement;\n \n    ----------------------------\n@@ -4108,11 +4252,11 @@ package body Sem_Ch5 is\n       end if;\n    end Check_Unreachable_Code;\n \n-   ------------------------------------\n-   -- Has_Call_Using_Secondary_Stack --\n-   ------------------------------------\n+   ------------------------\n+   -- Has_Sec_Stack_Call --\n+   ------------------------\n \n-   function Has_Call_Using_Secondary_Stack (N : Node_Id) return Boolean is\n+   function Has_Sec_Stack_Call (N : Node_Id) return Boolean is\n       function Check_Call (N : Node_Id) return Traverse_Result;\n       --  Check if N is a function call which uses the secondary stack\n \n@@ -4144,13 +4288,16 @@ package body Sem_Ch5 is\n             end loop;\n \n             Subp := Entity (Nam);\n-            Typ  := Etype (Subp);\n \n-            if Requires_Transient_Scope (Typ) then\n-               return Abandon;\n+            if Present (Subp) then\n+               Typ := Etype (Subp);\n \n-            elsif Sec_Stack_Needed_For_Return (Subp) then\n-               return Abandon;\n+               if Requires_Transient_Scope (Typ) then\n+                  return Abandon;\n+\n+               elsif Sec_Stack_Needed_For_Return (Subp) then\n+                  return Abandon;\n+               end if;\n             end if;\n          end if;\n \n@@ -4161,11 +4308,11 @@ package body Sem_Ch5 is\n \n       function Check_Calls is new Traverse_Func (Check_Call);\n \n-   --  Start of processing for Has_Call_Using_Secondary_Stack\n+   --  Start of processing for Has_Sec_Stack_Call\n \n    begin\n       return Check_Calls (N) = Abandon;\n-   end Has_Call_Using_Secondary_Stack;\n+   end Has_Sec_Stack_Call;\n \n    ----------------------\n    -- Preanalyze_Range --"}]}