{"sha": "f1c25d3b47cbca1052d3f6b91a915f981180307c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFjMjVkM2I0N2NiY2ExMDUyZDNmNmI5MWE5MTVmOTgxMTgwMzA3Yw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-02-01T21:21:45Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-02-01T21:21:45Z"}, "message": "arm.c, [...]: Replace \"gen_rtx (FOO, \" with \"gen_rtx_FOO (\".\n\n\t* config/arm/arm.c, config/arm/arm.h, config/arm/arm.md,\n\tconfig/arm/linux-gas.h, config/arm/netbsd-elf.h,\n\tconfig/arm/netbsd.h, config/arm/pe.c, config/avr/avr.c,\n\tconfig/avr/avr.h, config/avr/avr.md, config/c4x/c4x.h,\n\tconfig/cris/cris.h, config/fr30/fr30.h, config/frv/frv.c,\n\tconfig/frv/frv.h, config/ip2k/ip2k.c, config/iq2000/iq2000.c,\n\tconfig/iq2000/iq2000.h, config/m32r/m32r.c,\n\tconfig/m68hc11/m68hc11.c, config/m68hc11/m68hc11.h,\n\tconfig/m68hc11/m68hc11.md, config/m68k/m68k.md,\n\tconfig/mcore/mcore.c, config/mcore/mcore.h,\n\tconfig/mcore/mcore.md, config/mips/mips.c,\n\tconfig/ns32k/ns32k.h, config/ns32k/ns32k.md,\n\tconfig/rs6000/rs6000.c, config/s390/s390.c,\n\tconfig/s390/s390.md, config/sparc/sparc.c, config/v850/v850.c,\n\tconfig/xtensa/xtensa.h, config/xtensa/xtensa.md: Replace\n\t\"gen_rtx (FOO, \" with \"gen_rtx_FOO (\".\n\nFrom-SVN: r77080", "tree": {"sha": "0f25f1bf0dccfa2df3cd1cf00ba9b4c252d52416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f25f1bf0dccfa2df3cd1cf00ba9b4c252d52416"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1c25d3b47cbca1052d3f6b91a915f981180307c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c25d3b47cbca1052d3f6b91a915f981180307c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1c25d3b47cbca1052d3f6b91a915f981180307c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c25d3b47cbca1052d3f6b91a915f981180307c/comments", "author": null, "committer": null, "parents": [{"sha": "3953c0578989ec9a8df4246186a9d5cf75914813", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3953c0578989ec9a8df4246186a9d5cf75914813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3953c0578989ec9a8df4246186a9d5cf75914813"}], "stats": {"total": 1000, "additions": 509, "deletions": 491}, "files": [{"sha": "6eaff19375d1a71398cef9555c50576f0d863855", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -1,3 +1,22 @@\n+2004-02-01  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/arm/arm.c, config/arm/arm.h, config/arm/arm.md,\n+\tconfig/arm/linux-gas.h, config/arm/netbsd-elf.h,\n+\tconfig/arm/netbsd.h, config/arm/pe.c, config/avr/avr.c,\n+\tconfig/avr/avr.h, config/avr/avr.md, config/c4x/c4x.h,\n+\tconfig/cris/cris.h, config/fr30/fr30.h, config/frv/frv.c,\n+\tconfig/frv/frv.h, config/ip2k/ip2k.c, config/iq2000/iq2000.c,\n+\tconfig/iq2000/iq2000.h, config/m32r/m32r.c,\n+\tconfig/m68hc11/m68hc11.c, config/m68hc11/m68hc11.h,\n+\tconfig/m68hc11/m68hc11.md, config/m68k/m68k.md,\n+\tconfig/mcore/mcore.c, config/mcore/mcore.h,\n+\tconfig/mcore/mcore.md, config/mips/mips.c,\n+\tconfig/ns32k/ns32k.h, config/ns32k/ns32k.md,\n+\tconfig/rs6000/rs6000.c, config/s390/s390.c,\n+\tconfig/s390/s390.md, config/sparc/sparc.c, config/v850/v850.c,\n+\tconfig/xtensa/xtensa.h, config/xtensa/xtensa.md: Replace\n+\t\"gen_rtx (FOO, \" with \"gen_rtx_FOO (\".\n+\n 2004-02-01  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md (two peephole2's): New."}, {"sha": "66ef9393327c92ef584b5f99893139c0572d34a7", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -12284,10 +12284,10 @@ thumb_expand_prologue (void)\n \n \t  if (regno > LAST_LO_REGNUM) /* Very unlikely.  */\n \t    {\n-\t      rtx spare = gen_rtx (REG, SImode, IP_REGNUM);\n+\t      rtx spare = gen_rtx_REG (SImode, IP_REGNUM);\n \n \t      /* Choose an arbitrary, non-argument low register.  */\n-\t      reg = gen_rtx (REG, SImode, LAST_LO_REGNUM);\n+\t      reg = gen_rtx_REG (SImode, LAST_LO_REGNUM);\n \n \t      /* Save it by copying it into a high, scratch register.  */\n \t      emit_insn (gen_movsi (spare, reg));\n@@ -12318,7 +12318,7 @@ thumb_expand_prologue (void)\n \t    }\n \t  else\n \t    {\n-\t      reg = gen_rtx (REG, SImode, regno);\n+\t      reg = gen_rtx_REG (SImode, regno);\n \n \t      emit_insn (gen_movsi (reg, GEN_INT (- amount)));\n \n@@ -12363,7 +12363,7 @@ thumb_expand_epilogue (void)\n       else\n \t{\n \t  /* r3 is always free in the epilogue.  */\n-\t  rtx reg = gen_rtx (REG, SImode, LAST_ARG_REGNUM);\n+\t  rtx reg = gen_rtx_REG (SImode, LAST_ARG_REGNUM);\n \n \t  emit_insn (gen_movsi (reg, GEN_INT (amount)));\n \t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, reg));\n@@ -12661,8 +12661,8 @@ thumb_load_double_from_address (rtx *operands)\n   switch (GET_CODE (addr))\n     {\n     case REG:\n-      operands[2] = gen_rtx (MEM, SImode,\n-\t\t\t     plus_constant (XEXP (operands[1], 0), 4));\n+      operands[2] = gen_rtx_MEM (SImode,\n+\t\t\t\t plus_constant (XEXP (operands[1], 0), 4));\n \n       if (REGNO (operands[0]) == REGNO (addr))\n \t{\n@@ -12678,8 +12678,8 @@ thumb_load_double_from_address (rtx *operands)\n       \n     case CONST:\n       /* Compute <address> + 4 for the high order load.  */\n-      operands[2] = gen_rtx (MEM, SImode,\n-\t\t\t     plus_constant (XEXP (operands[1], 0), 4));\n+      operands[2] = gen_rtx_MEM (SImode,\n+\t\t\t\t plus_constant (XEXP (operands[1], 0), 4));\n       \n       output_asm_insn (\"ldr\\t%0, %1\", operands);\n       output_asm_insn (\"ldr\\t%H0, %2\", operands);\n@@ -12722,8 +12722,8 @@ thumb_load_double_from_address (rtx *operands)\n       else\n \t{\n \t  /* Compute <address> + 4 for the high order load.  */\n-\t  operands[2] = gen_rtx (MEM, SImode,\n-\t\t\t\t plus_constant (XEXP (operands[1], 0), 4));\n+\t  operands[2] = gen_rtx_MEM (SImode,\n+\t\t\t\t     plus_constant (XEXP (operands[1], 0), 4));\n \t  \n \t  /* If the computed address is held in the low order register\n \t     then load the high order register first, otherwise always\n@@ -12744,8 +12744,8 @@ thumb_load_double_from_address (rtx *operands)\n     case LABEL_REF:\n       /* With no registers to worry about we can just load the value\n          directly.  */\n-      operands[2] = gen_rtx (MEM, SImode,\n-\t\t\t     plus_constant (XEXP (operands[1], 0), 4));\n+      operands[2] = gen_rtx_MEM (SImode,\n+\t\t\t\t plus_constant (XEXP (operands[1], 0), 4));\n \t  \n       output_asm_insn (\"ldr\\t%H0, %2\", operands);\n       output_asm_insn (\"ldr\\t%0, %1\", operands);\n@@ -12832,18 +12832,18 @@ thumb_expand_movstrqi (rtx *operands)\n   if (len >= 4)\n     {\n       rtx reg = gen_reg_rtx (SImode);\n-      emit_insn (gen_movsi (reg, gen_rtx (MEM, SImode, in)));\n-      emit_insn (gen_movsi (gen_rtx (MEM, SImode, out), reg));\n+      emit_insn (gen_movsi (reg, gen_rtx_MEM (SImode, in)));\n+      emit_insn (gen_movsi (gen_rtx_MEM (SImode, out), reg));\n       len -= 4;\n       offset += 4;\n     }\n   \n   if (len >= 2)\n     {\n       rtx reg = gen_reg_rtx (HImode);\n-      emit_insn (gen_movhi (reg, gen_rtx (MEM, HImode, \n-\t\t\t\t\t  plus_constant (in, offset))));\n-      emit_insn (gen_movhi (gen_rtx (MEM, HImode, plus_constant (out, offset)),\n+      emit_insn (gen_movhi (reg, gen_rtx_MEM (HImode, \n+\t\t\t\t\t      plus_constant (in, offset))));\n+      emit_insn (gen_movhi (gen_rtx_MEM (HImode, plus_constant (out, offset)),\n \t\t\t    reg));\n       len -= 2;\n       offset += 2;\n@@ -12852,9 +12852,9 @@ thumb_expand_movstrqi (rtx *operands)\n   if (len)\n     {\n       rtx reg = gen_reg_rtx (QImode);\n-      emit_insn (gen_movqi (reg, gen_rtx (MEM, QImode,\n-\t\t\t\t\t  plus_constant (in, offset))));\n-      emit_insn (gen_movqi (gen_rtx (MEM, QImode, plus_constant (out, offset)),\n+      emit_insn (gen_movqi (reg, gen_rtx_MEM (QImode,\n+\t\t\t\t\t      plus_constant (in, offset))));\n+      emit_insn (gen_movqi (gen_rtx_MEM (QImode, plus_constant (out, offset)),\n \t\t\t    reg));\n     }\n }"}, {"sha": "75b14455878331ee13dba75d42d273332e4dd09f", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -1801,7 +1801,7 @@ typedef struct\n   assemble_name (STREAM, ARM_MCOUNT_NAME);\t\t\\\n   fputc ('\\n', STREAM);\t\t\t\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (temp, \"LP\", LABELNO);\t\\\n-  sym = gen_rtx (SYMBOL_REF, Pmode, temp);\t\t\\\n+  sym = gen_rtx_SYMBOL_REF (Pmode, temp);\t\t\\\n   assemble_aligned_integer (UNITS_PER_WORD, sym);\t\\\n }\n #endif"}, {"sha": "7b58c81b9de39a7c57375d2471439783ae766819", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -3896,7 +3896,7 @@\n     case 5:\n       return thumb_load_double_from_address (operands);\n     case 6:\n-      operands[2] = gen_rtx (MEM, SImode,\n+      operands[2] = gen_rtx_MEM (SImode,\n \t\t\t     plus_constant (XEXP (operands[0], 0), 4));\n       output_asm_insn (\\\"str\\\\t%1, %0\\;str\\\\t%H1, %2\\\", operands);\n       return \\\"\\\";\n@@ -4472,7 +4472,7 @@\n           if (GET_CODE (operands[0]) != REG)\n \t    abort ();\n \n-          operands[0] = gen_rtx (SUBREG, SImode, operands[0], 0);\n+          operands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);\n           emit_insn (gen_movsi (operands[0], operands[1]));\n           DONE;\n         }\n@@ -4996,8 +4996,8 @@\n     case 3:\n       return thumb_load_double_from_address (operands);\n     case 4:\n-      operands[2] = gen_rtx (MEM, SImode,\n-\t\t\t     plus_constant (XEXP (operands[0], 0), 4));\n+      operands[2] = gen_rtx_MEM (SImode,\n+\t\t\t\t plus_constant (XEXP (operands[0], 0), 4));\n       output_asm_insn (\\\"str\\\\t%1, %0\\;str\\\\t%H1, %2\\\", operands);\n       return \\\"\\\";\n     case 5:\n@@ -9714,7 +9714,7 @@\n     enum rtx_code rc = GET_CODE (operands[1]);\n \n     operands[6] = gen_rtx_REG (mode, CC_REGNUM);\n-    operands[7] = gen_rtx (COMPARE, mode, operands[2], operands[3]);\n+    operands[7] = gen_rtx_COMPARE (mode, operands[2], operands[3]);\n     if (mode == CCFPmode || mode == CCFPEmode)\n       rc = reverse_condition_maybe_unordered (rc);\n     else"}, {"sha": "1be7e22b53f059d2683441c8a9cdd41f251befbc", "filename": "gcc/config/arm/linux-gas.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Flinux-gas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Flinux-gas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-gas.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -45,9 +45,9 @@\n #undef  INITIALIZE_TRAMPOLINE\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 8)),\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 8)),\t\\\n \t\t  (CXT));\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 12)),\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 12)),\t\\\n \t\t  (FNADDR));\t\t\t\t\t\t\\\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),\t\\\n \t\t     0, VOIDmode, 2, TRAMP, Pmode,\t\t\t\\"}, {"sha": "f0f0f75cfa6a02d37332ee2b4830530e647b9715", "filename": "gcc/config/arm/netbsd-elf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -145,9 +145,9 @@\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 8)),\t\\\n+    emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 8)),\t\\\n \t\t    (CXT));\t\t\t\t\t\t\\\n-    emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 12)),\t\\\n+    emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 12)),\t\\\n \t\t    (FNADDR));\t\t\t\t\t\t\\\n     emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),\t\\\n \t\t       0, VOIDmode, 2, TRAMP, Pmode,\t\t\t\\"}, {"sha": "cbcaa9e4c0f998672ec698ffa9d1002f6060427e", "filename": "gcc/config/arm/netbsd.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fnetbsd.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -146,9 +146,9 @@\n #undef  INITIALIZE_TRAMPOLINE\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)                      \\\n {                                                                      \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 8)),   \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 8)),   \\\n                  (CXT));                                               \\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 12)),  \\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 12)),  \\\n                  (FNADDR));                                            \\\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_cache\"),      \\\n                     0, VOIDmode, 2, TRAMP, Pmode,                      \\"}, {"sha": "2d38d1fc5e310d99a50137f064c71c1c831a0812", "filename": "gcc/config/arm/pe.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Fpe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Farm%2Fpe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -130,7 +130,7 @@ arm_mark_dllexport (decl)\n   idp = get_identifier (newname);\n \n   XEXP (DECL_RTL (decl), 0) =\n-    gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (idp));\n+    gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n }\n \n /* Mark a DECL as being dllimport'd.  */\n@@ -200,9 +200,9 @@ arm_mark_dllimport (decl)\n   /* ??? At least I think that's why we do this.  */\n   idp = get_identifier (newname);\n \n-  newrtl = gen_rtx (MEM, Pmode,\n-\t\t    gen_rtx (SYMBOL_REF, Pmode,\n-\t\t\t     IDENTIFIER_POINTER (idp)));\n+  newrtl = gen_rtx_MEM (Pmode,\n+\t\t\tgen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t    IDENTIFIER_POINTER (idp)));\n   XEXP (DECL_RTL (decl), 0) = newrtl;\n }\n \n@@ -236,7 +236,7 @@ arm_pe_encode_section_info (decl, rtl, first)\n     {\n       const char *oldname = XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0);\n       tree idp = get_identifier (oldname + 9);\n-      rtx newrtl = gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (idp));\n+      rtx newrtl = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n \n       XEXP (DECL_RTL (decl), 0) = newrtl;\n "}, {"sha": "331f7cdfa648e0063415ff3aea11f01b11e964dc", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -83,10 +83,10 @@ static bool avr_return_in_memory (tree, tree);\n /* Allocate registers from r25 to r8 for parameters for function calls.  */\n #define FIRST_CUM_REG 26\n \n-/* Temporary register RTX (gen_rtx (REG,QImode,TMP_REGNO)) */\n+/* Temporary register RTX (gen_rtx_REG (QImode, TMP_REGNO)) */\n static GTY(()) rtx tmp_reg_rtx;\n \n-/* Zeroed register RTX (gen_rtx (REG,QImode,ZERO_REGNO)) */\n+/* Zeroed register RTX (gen_rtx_REG (QImode, ZERO_REGNO)) */\n static GTY(()) rtx zero_reg_rtx;\n \n /* AVR register names {\"r0\", \"r1\", ..., \"r31\"} */\n@@ -1472,7 +1472,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n   int bytes = avr_num_arg_regs (mode, type);\n \n   if (cum->nregs && bytes <= cum->nregs)\n-    return gen_rtx (REG, mode, cum->regno - bytes);\n+    return gen_rtx_REG (mode, cum->regno - bytes);\n \n   return NULL_RTX;\n }\n@@ -2782,7 +2782,7 @@ out_shift_with_cnt (const char *template, rtx insn, rtx operands[],\n \t  /* No scratch register available, use one from LD_REGS (saved in\n \t     __tmp_reg__) that doesn't overlap with registers to shift.  */\n \n-\t  op[3] = gen_rtx (REG, QImode,\n+\t  op[3] = gen_rtx_REG (QImode,\n \t\t\t   ((true_regnum (operands[0]) - 1) & 15) + 16);\n \t  op[4] = tmp_reg_rtx;\n \t  saved_in_tmp = 1;\n@@ -5001,9 +5001,8 @@ avr_reorg (void)\n \t      rtx t = XEXP (src,0);\n \n \t      PUT_CODE (t, swap_condition (GET_CODE (t)));\n-\t      SET_SRC (pattern) = gen_rtx (NEG,\n-\t\t\t\t\t   GET_MODE (SET_SRC (pattern)),\n-\t\t\t\t\t   SET_SRC (pattern));\n+\t      SET_SRC (pattern) = gen_rtx_NEG (GET_MODE (SET_SRC (pattern)),\n+\t\t\t\t\t       SET_SRC (pattern));\n \t      INSN_CODE (next) = -1;\n \t      INSN_CODE (insn) = -1;\n \t    }\n@@ -5028,7 +5027,7 @@ avr_libcall_value (enum machine_mode mode)\n   int offs = GET_MODE_SIZE (mode);\n   if (offs < 2)\n     offs = 2;\n-  return gen_rtx (REG, mode, RET_REGISTER + 2 - offs);\n+  return gen_rtx_REG (mode, RET_REGISTER + 2 - offs);\n }\n \n /* Create an RTX representing the place where a\n@@ -5050,7 +5049,7 @@ avr_function_value (tree type, tree func ATTRIBUTE_UNUSED)\n   else if (offs > GET_MODE_SIZE (SImode) && offs < GET_MODE_SIZE (DImode))\n     offs = GET_MODE_SIZE (DImode);\n   \n-  return gen_rtx (REG, BLKmode, RET_REGISTER + 2 - offs);\n+  return gen_rtx_REG (BLKmode, RET_REGISTER + 2 - offs);\n }\n \n /* Returns nonzero if the number MASK has only one bit set.  */"}, {"sha": "df1c96777385cee27b89d350071b19948c8e0cfb", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -793,8 +793,8 @@ extern int avr_case_values_threshold;\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t      \\\n {\t\t\t\t\t\t\t\t\t      \\\n-  emit_move_insn (gen_rtx (MEM, HImode, plus_constant ((TRAMP), 2)), CXT);    \\\n-  emit_move_insn (gen_rtx (MEM, HImode, plus_constant ((TRAMP), 6)), FNADDR); \\\n+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant ((TRAMP), 2)), CXT);    \\\n+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant ((TRAMP), 6)), FNADDR); \\\n }\n /* Store in cc_status the expressions\n    that the condition codes will describe"}, {"sha": "8b29a21077561605917af5b025167b4a56eecaf9", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -371,8 +371,8 @@\n   operands[5] = addr0;\n   operands[6] = addr1;\n \n-  operands[0] = gen_rtx (MEM, BLKmode, addr0);\n-  operands[1] = gen_rtx (MEM, BLKmode, addr1);\n+  operands[0] = gen_rtx_MEM (BLKmode, addr0);\n+  operands[1] = gen_rtx_MEM (BLKmode, addr1);\n }\")\n \n (define_insn \"*movstrqi_insn\"\n@@ -444,7 +444,7 @@\n   addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n   operands[4] = addr0;\n   \n-  operands[0] = gen_rtx (MEM, BLKmode, addr0);\n+  operands[0] = gen_rtx_MEM (BLKmode, addr0);\n }\")\n \n (define_insn \"*clrstrqi\"\n@@ -499,7 +499,7 @@\n   if (! (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0))\n     FAIL;\n   addr = copy_to_mode_reg (Pmode, XEXP (operands[1],0));\n-  operands[1] = gen_rtx (MEM, BLKmode, addr); \n+  operands[1] = gen_rtx_MEM (BLKmode, addr); \n   operands[5] = addr;\n   operands[4] = gen_reg_rtx (HImode);\n }\")"}, {"sha": "f283c73dc5d7532ff41e1b1b761bcf45fdf37b90", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -1777,33 +1777,33 @@ do { fprintf (asm_out_file, \"\\t.sdef\\t\");\t\t\\\n       tmp2 = expand_shift (LSHIFT_EXPR, QImode,\t\t\t\t\\\n \t\t\t   GEN_INT (0x5069), size_int (16), 0, 1);\t\\\n       emit_insn (gen_iorqi3 (tmp1, tmp1, tmp2));\t\t\t\\\n-      emit_move_insn (gen_rtx (MEM, QImode,\t\t\t\t\\\n+      emit_move_insn (gen_rtx_MEM (QImode,\t\t\t\t\\\n \t\t\t       plus_constant (tramp, 0)), tmp1);\t\\\n       tmp1 = expand_and (QImode, FNADDR, GEN_INT (0xffff), 0);\t\t\\\n       tmp2 = expand_shift (LSHIFT_EXPR, QImode,\t\t\t\t\\\n \t\t\t   GEN_INT (0x1069), size_int (16), 0, 1);\t\\\n       emit_insn (gen_iorqi3 (tmp1, tmp1, tmp2));\t\t\t\\\n-      emit_move_insn (gen_rtx (MEM, QImode,\t\t\t\t\\\n+      emit_move_insn (gen_rtx_MEM (QImode,\t\t\t\t\\\n \t\t\t       plus_constant (tramp, 2)), tmp1);\t\\\n       tmp1 = expand_shift (RSHIFT_EXPR, QImode, CXT,\t\t\t\\\n \t\t\t   size_int (16), 0, 1);\t\t\t\\\n       tmp2 = expand_shift (LSHIFT_EXPR, QImode,\t\t\t\t\\\n \t\t\t   GEN_INT (0x5068), size_int (16), 0, 1);\t\\\n       emit_insn (gen_iorqi3 (tmp1, tmp1, tmp2));\t\t\t\\\n-      emit_move_insn (gen_rtx (MEM, QImode,\t\t\t\t\\\n+      emit_move_insn (gen_rtx_MEM (QImode,\t\t\t\t\\\n \t\t\t       plus_constant (tramp, 3)), tmp1);\t\\\n       tmp1 = expand_and (QImode, CXT, GEN_INT (0xffff), 0);\t\t\\\n       tmp2 = expand_shift (LSHIFT_EXPR, QImode,\t\t\t\t\\\n \t\t\t   GEN_INT (0x1068), size_int (16), 0, 1);\t\\\n       emit_insn (gen_iorqi3 (tmp1, tmp1, tmp2));\t\t\t\\\n-      emit_move_insn (gen_rtx (MEM, QImode,\t\t\t\t\\\n+      emit_move_insn (gen_rtx_MEM (QImode,\t\t\t\t\\\n \t\t\t       plus_constant (tramp, 6)), tmp1);\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      emit_move_insn (gen_rtx (MEM, QImode,\t\t\t\t\\\n+      emit_move_insn (gen_rtx_MEM (QImode,\t\t\t\t\\\n \t\t\t       plus_constant (TRAMP, 8)), FNADDR); \t\\\n-      emit_move_insn (gen_rtx (MEM, QImode,\t\t\t\t\\\n+      emit_move_insn (gen_rtx_MEM (QImode,\t\t\t\t\\\n \t\t\t       plus_constant (TRAMP, 9)), CXT); \t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }"}, {"sha": "76a4e763855f140dcfc410a30027271e1cc47754", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -822,7 +822,7 @@ enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n #define RETURN_ADDR_RTX(COUNT, FRAMEADDR) \\\n  cris_return_addr_rtx (COUNT, FRAMEADDR)\n \n-#define INCOMING_RETURN_ADDR_RTX gen_rtx (REG, Pmode, CRIS_SRP_REGNUM)\n+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, CRIS_SRP_REGNUM)\n \n /* FIXME: Any __builtin_eh_return callers must not return anything and\n    there must not be collisions with incoming parameters.  Luckily the\n@@ -915,7 +915,7 @@ enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n  ((CUM).regs < CRIS_MAX_ARGS_IN_REGS\t\t\t\t\\\n   && (TYPE) != void_type_node\t\t\t\t\t\\\n   && ! FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED)\t\\\n-  ? gen_rtx (REG, MODE, (CRIS_FIRST_ARG_REG) + (CUM).regs)\t\\\n+  ? gen_rtx_REG (MODE, (CRIS_FIRST_ARG_REG) + (CUM).regs)\t\\\n   : NULL_RTX)\n \n /* The differences between this and the previous, is that this one checks\n@@ -925,7 +925,7 @@ enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n  (((NAMED) && (CUM).regs < CRIS_MAX_ARGS_IN_REGS\t\t\t\\\n    && ! FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\t\\\n-  ? gen_rtx (REG, MODE, CRIS_FIRST_ARG_REG + (CUM).regs)\t\t\\\n+  ? gen_rtx_REG (MODE, CRIS_FIRST_ARG_REG + (CUM).regs)\t\t\\\n   : NULL_RTX)\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\\\n@@ -976,9 +976,9 @@ struct cum_args {int regs;};\n /* Let's assume all functions return in r[CRIS_FIRST_ARG_REG] for the\n    time being.  */\n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n- gen_rtx (REG, TYPE_MODE (VALTYPE), CRIS_FIRST_ARG_REG)\n+ gen_rtx_REG (TYPE_MODE (VALTYPE), CRIS_FIRST_ARG_REG)\n \n-#define LIBCALL_VALUE(MODE) gen_rtx (REG, MODE, CRIS_FIRST_ARG_REG)\n+#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, CRIS_FIRST_ARG_REG)\n \n #define FUNCTION_VALUE_REGNO_P(N) ((N) == CRIS_FIRST_ARG_REG)\n \n@@ -1063,10 +1063,10 @@ struct cum_args {int regs;};\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\\\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      emit_move_insn (gen_rtx (MEM, SImode,\t\t\t\\\n+      emit_move_insn (gen_rtx_MEM (SImode,\t\t\t\\\n \t\t\t       plus_constant (TRAMP, 10)),\t\\\n \t\t      CXT);\t\t\t\t\t\\\n-      emit_move_insn (gen_rtx (MEM, SImode,\t\t\t\\\n+      emit_move_insn (gen_rtx_MEM (SImode,\t\t\t\\\n \t\t\t       plus_constant (TRAMP, 16)),\t\\\n \t\t      FNADDR);\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\"}, {"sha": "902701dbd06686fab2c7c7b5d783e68d391340e5", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -696,7 +696,7 @@ enum reg_class\n   (  (NAMED) == 0                    ? NULL_RTX\t\t\t\\\n    : MUST_PASS_IN_STACK (MODE, TYPE) ? NULL_RTX\t\t\t\\\n    : (CUM) >= FR30_NUM_ARG_REGS      ? NULL_RTX\t\t\t\\\n-   : gen_rtx (REG, MODE, CUM + FIRST_ARG_REGNUM))\n+   : gen_rtx_REG (MODE, CUM + FIRST_ARG_REGNUM))\n \n /* A C type for declaring a variable that is used as the first argument of\n    `FUNCTION_ARG' and other related values.  For some target machines, the type\n@@ -816,7 +816,7 @@ enum reg_class\n \n    The definition of `LIBRARY_VALUE' need not be concerned aggregate data\n    types, because none of the library functions returns such types.  */\n-#define LIBCALL_VALUE(MODE) gen_rtx (REG, MODE, RETURN_VALUE_REGNUM)\n+#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, RETURN_VALUE_REGNUM)\n \n /* A C expression that is nonzero if REGNO is the number of a hard register in\n    which the values of called function may come back. */\n@@ -941,8 +941,8 @@ enum reg_class\n #define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN)\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (ADDR, 4)), STATIC_CHAIN);\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (ADDR, 12)), FNADDR);\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (ADDR, 4)), STATIC_CHAIN);\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (ADDR, 12)), FNADDR);\t\\\n } while (0);\n \n /*}}}*/ \f"}, {"sha": "24365be8d5a8c3ddcb9ac38f1bb83813a047361f", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -1933,7 +1933,7 @@ frv_expand_builtin_saveregs (void)\n     fprintf (stderr, \"expand_builtin_saveregs: offset from ap = %d\\n\",\n \t     offset);\n \n-  return gen_rtx (PLUS, Pmode, virtual_incoming_args_rtx, GEN_INT (- offset));\n+  return gen_rtx_PLUS (Pmode, virtual_incoming_args_rtx, GEN_INT (- offset));\n }\n \n \f\n@@ -2991,7 +2991,7 @@ frv_function_arg (CUMULATIVE_ARGS *cum,\n \n   else if (arg_num <= LAST_ARG_REGNUM)\n     {\n-      ret = gen_rtx (REG, xmode, arg_num);\n+      ret = gen_rtx_REG (xmode, arg_num);\n       debstr = reg_names[arg_num];\n     }\n "}, {"sha": "d111f3648e1c76bb5cda082860be16b58b1363b3", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -2013,7 +2013,7 @@ struct machine_function GTY(())\n    because these are returned in another way.  See\n    `TARGET_STRUCT_VALUE_RTX' and related macros, below.  */\n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), RETURN_VALUE_REGNUM)\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), RETURN_VALUE_REGNUM)\n \n /* A C expression to create an RTX representing the place where a library\n    function returns a value of mode MODE.\n@@ -2024,7 +2024,7 @@ struct machine_function GTY(())\n \n    The definition of `LIBRARY_VALUE' need not be concerned aggregate data\n    types, because none of the library functions returns such types.  */\n-#define LIBCALL_VALUE(MODE) gen_rtx (REG, MODE, RETURN_VALUE_REGNUM)\n+#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, RETURN_VALUE_REGNUM)\n \n /* A C expression that is nonzero if REGNO is the number of a hard register in\n    which the values of called function may come back."}, {"sha": "1b9151e28e0dcc137f694a11722f6a823b47ef77", "filename": "gcc/config/ip2k/ip2k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fip2k%2Fip2k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fip2k%2Fip2k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -3761,7 +3761,7 @@ track_dp_reload (insn, dp_current, dp_current_ok, modifying)\n \t\t\t\t+ GET_MODE_SIZE (GET_MODE (XEXP (set, 0))));\n           *dp_current = gen_rtx_MEM (HImode,\n \t\t\t\t     gen_rtx_PLUS (Pmode,\n-\t\t\t\t \t           gen_rtx_REG(HImode, REG_SP),\n+\t\t\t\t \t           gen_rtx_REG (HImode, REG_SP),\n \t\t\t\t\t\t   GEN_INT (disp)));\n \t  return 1;\n \t}"}, {"sha": "20da1148f0c92f28fda38e423514be1f7c935a6f", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -1176,7 +1176,7 @@ gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0, rtx cmp1,\n \n   if (test == ITEST_NE)\n     {\n-      convert_move (result, gen_rtx (GTU, mode, reg, const0_rtx), 0);\n+      convert_move (result, gen_rtx_GTU (mode, reg, const0_rtx), 0);\n       if (p_invert != NULL)\n \t*p_invert = 0;\n       invert = 0;\n@@ -1194,7 +1194,7 @@ gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0, rtx cmp1,\n       rtx one;\n \n       one = const1_rtx;\n-      convert_move (result, gen_rtx (XOR, mode, reg, one), 0);\n+      convert_move (result, gen_rtx_XOR (mode, reg, one), 0);\n     }\n \n   return result;\n@@ -1538,7 +1538,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n   if (mode == VOIDmode)\n     {\n       if (cum->num_adjusts > 0)\n-\tret = gen_rtx (PARALLEL, (enum machine_mode) cum->fp_code,\n+\tret = gen_rtx_PARALLEL ((enum machine_mode) cum->fp_code,\n \t\t       gen_rtvec_v (cum->num_adjusts, cum->adjust));\n     }\n \n@@ -2273,14 +2273,14 @@ save_restore_insns (int store_p)\n \t{\n \t  rtx reg_rtx;\n \t  rtx mem_rtx\n-\t    = gen_rtx (MEM, gpr_mode,\n-\t\t       gen_rtx (PLUS, Pmode, base_reg_rtx,\n+\t    = gen_rtx_MEM (gpr_mode,\n+\t\t       gen_rtx_PLUS (Pmode, base_reg_rtx,\n \t\t\t\tGEN_INT (gp_offset - base_offset)));\n \n \t  if (! current_function_calls_eh_return)\n \t    RTX_UNCHANGING_P (mem_rtx) = 1;\n \n-\t  reg_rtx = gen_rtx (REG, gpr_mode, regno);\n+\t  reg_rtx = gen_rtx_REG (gpr_mode, regno);\n \n \t  if (store_p)\n \t    iq2000_emit_frame_related_store (mem_rtx, reg_rtx, gp_offset);\n@@ -2434,9 +2434,9 @@ iq2000_expand_prologue (void)\n       for (; regno <= GP_ARG_LAST; regno++)\n \t{\n \t  if (offset != 0)\n-\t    ptr = gen_rtx (PLUS, Pmode, stack_pointer_rtx, GEN_INT (offset));\n-\t  emit_move_insn (gen_rtx (MEM, gpr_mode, ptr),\n-\t\t\t  gen_rtx (REG, gpr_mode, regno));\n+\t    ptr = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (offset));\n+\t  emit_move_insn (gen_rtx_MEM (gpr_mode, ptr),\n+\t\t\t  gen_rtx_REG (gpr_mode, regno));\n \n \t  offset += GET_MODE_SIZE (gpr_mode);\n \t}\n@@ -2449,7 +2449,7 @@ iq2000_expand_prologue (void)\n \n       if (tsize > 32767)\n \t{\n-\t  adjustment_rtx = gen_rtx (REG, Pmode, IQ2000_TEMP1_REGNUM);\n+\t  adjustment_rtx = gen_rtx_REG (Pmode, IQ2000_TEMP1_REGNUM);\n \t  emit_move_insn (adjustment_rtx, tsize_rtx);\n \t}\n       else\n@@ -2532,14 +2532,14 @@ iq2000_expand_epilogue (void)\n   if (current_function_calls_eh_return)\n     {\n       /* Perform the additional bump for __throw.  */\n-      emit_move_insn (gen_rtx (REG, Pmode, HARD_FRAME_POINTER_REGNUM),\n+      emit_move_insn (gen_rtx_REG (Pmode, HARD_FRAME_POINTER_REGNUM),\n \t\t      stack_pointer_rtx);\n-      emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, Pmode,\n+      emit_insn (gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode,\n \t\t\t\t\t\t  HARD_FRAME_POINTER_REGNUM)));\n       emit_jump_insn (gen_eh_return_internal ());\n     }\n   else\n-      emit_jump_insn (gen_return_internal (gen_rtx (REG, Pmode,\n+      emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode,\n \t\t\t\t\t\t  GP_REG_FIRST + 31)));\n }\n "}, {"sha": "d4a31023e5c4c248cafa087d4df31d728649a7be", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -499,13 +499,12 @@ typedef struct iq2000_args\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)\tiq2000_function_value (VALTYPE, FUNC)\n \n-#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n-  gen_rtx (REG,\t\t\t\t\t\t\t\t\\\n-\t   ((GET_MODE_CLASS (MODE) != MODE_INT\t\t\t\t\\\n-\t     || GET_MODE_SIZE (MODE) >= 4)\t\t\t\t\\\n-\t    ? (MODE)\t\t\t\t\t\t\t\\\n-\t    : SImode),\t\t\t\t\t\t\t\\\n-\t   GP_RETURN)\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\\\n+  gen_rtx_REG (((GET_MODE_CLASS (MODE) != MODE_INT\t\\\n+\t\t || GET_MODE_SIZE (MODE) >= 4)\t\t\\\n+\t\t? (MODE)\t\t\t\t\\\n+\t\t: SImode),\t\t\t\t\\\n+\t       GP_RETURN)\n \n /* On the IQ2000, R2 and R3 are the only register thus used.  */\n \n@@ -641,7 +640,7 @@ typedef struct iq2000_args\n     {\t\t\t\t\t\t\t\t\t\\\n       X = gen_rtx_LO_SUM (Pmode,\t\t\t\t\t\\\n \t\t\t  copy_to_mode_reg (Pmode,\t\t\t\\\n-\t\t\t\t\t    gen_rtx (HIGH, Pmode, X)),\t\\\n+\t\t\t\t\t    gen_rtx_HIGH (Pmode, X)),\t\\\n \t\t\t  X);\t\t\t\t\t\t\\\n       goto WIN;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\"}, {"sha": "1fd0f0b885ae950aa381e112c20a8472a38a24b0", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -1088,7 +1088,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \t\t  break;\n \t\tcase GT:\n \t\t  if (GET_CODE (y) == CONST_INT)\n-\t\t    tmp = gen_rtx (PLUS, SImode, y, const1_rtx);\n+\t\t    tmp = gen_rtx_PLUS (SImode, y, const1_rtx);\n \t\t  else\n \t\t    emit_insn (gen_addsi3 (tmp, y, constm1_rtx));\n \t\t  emit_insn (gen_cmp_ltsi_insn (x, tmp));\n@@ -1128,7 +1128,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \t\t  break;\n \t\tcase GTU:\n \t\t  if (GET_CODE (y) == CONST_INT)\n-\t\t    tmp = gen_rtx (PLUS, SImode, y, const1_rtx);\n+\t\t    tmp = gen_rtx_PLUS (SImode, y, const1_rtx);\n \t\t  else\n \t\t    emit_insn (gen_addsi3 (tmp, y, constm1_rtx));\n \t\t  emit_insn (gen_cmp_ltusi_insn (x, tmp));\n@@ -2205,15 +2205,15 @@ m32r_legitimize_pic_address (rtx orig, rtx reg)\n       emit_insn (gen_pic_load_addr (address, orig));\n \n       emit_insn (gen_addsi3 (address, address, pic_offset_table_rtx));\n-      pic_ref = gen_rtx (MEM, Pmode, address);\n+      pic_ref = gen_rtx_MEM (Pmode, address);\n \n       RTX_UNCHANGING_P (pic_ref) = 1;\n       insn = emit_move_insn (reg, pic_ref);\n       current_function_uses_pic_offset_table = 1;\n #if 0\n       /* Put a REG_EQUAL note on this insn, so that it can be optimized\n          by loop.  */\n-      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL, orig,\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, orig,\n                   REG_NOTES (insn));\n #endif\n       return reg;\n@@ -2256,7 +2256,7 @@ m32r_legitimize_pic_address (rtx orig, rtx reg)\n             abort ();\n         }\n \n-      return gen_rtx (PLUS, Pmode, base, offset);\n+      return gen_rtx_PLUS (Pmode, base, offset);\n     }\n \n   return orig;\n@@ -2760,13 +2760,13 @@ block_move_call (rtx dest_reg, rtx src_reg, rtx bytes_rtx)\n     bytes_rtx = convert_to_mode (Pmode, bytes_rtx, 1);\n \n #ifdef TARGET_MEM_FUNCTIONS\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"memcpy\"), 0,\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"memcpy\"), 0,\n \t\t     VOIDmode, 3, dest_reg, Pmode, src_reg, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (sizetype), bytes_rtx,\n \t\t\t\t      TREE_UNSIGNED (sizetype)),\n \t\t     TYPE_MODE (sizetype));\n #else\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"bcopy\"), 0,\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"bcopy\"), 0,\n \t\t     VOIDmode, 3, src_reg, Pmode, dest_reg, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (integer_type_node), bytes_rtx,\n \t\t\t\t      TREE_UNSIGNED (integer_type_node)),"}, {"sha": "357c6e79dbad27e261729a0b092a7463bee710a5", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -366,17 +366,17 @@ void\n create_regs_rtx (void)\n {\n   /*  regs_inited = 1; */\n-  ix_reg = gen_rtx (REG, HImode, HARD_X_REGNUM);\n-  iy_reg = gen_rtx (REG, HImode, HARD_Y_REGNUM);\n-  d_reg = gen_rtx (REG, HImode, HARD_D_REGNUM);\n-  m68hc11_soft_tmp_reg = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n-\n-  stack_push_word = gen_rtx (MEM, HImode,\n-\t\t\t     gen_rtx (PRE_DEC, HImode,\n-\t\t\t\t      gen_rtx (REG, HImode, HARD_SP_REGNUM)));\n-  stack_pop_word = gen_rtx (MEM, HImode,\n-\t\t\t    gen_rtx (POST_INC, HImode,\n-\t\t\t\t     gen_rtx (REG, HImode, HARD_SP_REGNUM)));\n+  ix_reg = gen_rtx_REG (HImode, HARD_X_REGNUM);\n+  iy_reg = gen_rtx_REG (HImode, HARD_Y_REGNUM);\n+  d_reg = gen_rtx_REG (HImode, HARD_D_REGNUM);\n+  m68hc11_soft_tmp_reg = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\n+\n+  stack_push_word = gen_rtx_MEM (HImode,\n+\t\t\t     gen_rtx_PRE_DEC (HImode,\n+\t\t\t\t      gen_rtx_REG (HImode, HARD_SP_REGNUM)));\n+  stack_pop_word = gen_rtx_MEM (HImode,\n+\t\t\t    gen_rtx_POST_INC (HImode,\n+\t\t\t\t     gen_rtx_REG (HImode, HARD_SP_REGNUM)));\n \n }\n \n@@ -828,19 +828,19 @@ m68hc11_reload_operands (rtx operands[])\n \t  offset = GEN_INT (vl);\n \t  if (!VALID_CONSTANT_OFFSET_P (offset, mode))\n \t    {\n-\t      emit_insn (gen_rtx (SET, VOIDmode, reg,\n-\t\t\t\t  gen_rtx (PLUS, HImode, reg, big_offset)));\n+\t      emit_insn (gen_rtx_SET (VOIDmode, reg,\n+\t\t\t\t  gen_rtx_PLUS (HImode, reg, big_offset)));\n \t      offset = const0_rtx;\n \t    }\n \t  else\n \t    {\n-\t      emit_insn (gen_rtx (SET, VOIDmode, reg,\n-\t\t\t\t  gen_rtx (PLUS, HImode, reg,\n+\t      emit_insn (gen_rtx_SET (VOIDmode, reg,\n+\t\t\t\t  gen_rtx_PLUS (HImode, reg,\n \t\t\t\t\t   GEN_INT (vh << 8))));\n \t    }\n \t  emit_move_insn (operands[0],\n-\t\t\t  gen_rtx (MEM, GET_MODE (operands[1]),\n-\t\t\t\t   gen_rtx (PLUS, Pmode, reg, offset)));\n+\t\t\t  gen_rtx_MEM (GET_MODE (operands[1]),\n+\t\t\t\t   gen_rtx_PLUS (Pmode, reg, offset)));\n \t  return 1;\n \t}\n     }\n@@ -1501,13 +1501,13 @@ m68hc11_function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (mode != BLKmode)\n     {\n       if (GET_MODE_SIZE (mode) == 2 * HARD_REG_SIZE)\n-\treturn gen_rtx (REG, mode, HARD_X_REGNUM);\n+\treturn gen_rtx_REG (mode, HARD_X_REGNUM);\n \n       if (GET_MODE_SIZE (mode) > HARD_REG_SIZE)\n \t{\n \t  return NULL_RTX;\n \t}\n-      return gen_rtx (REG, mode, HARD_D_REGNUM);\n+      return gen_rtx_REG (mode, HARD_D_REGNUM);\n     }\n   return NULL_RTX;\n }\n@@ -1653,9 +1653,9 @@ expand_prologue (void)\n     {\n       emit_move_after_reload (stack_push_word, m68hc11_soft_tmp_reg, scratch);\n       emit_move_after_reload (stack_push_word,\n-\t\t\t      gen_rtx (REG, HImode, SOFT_Z_REGNUM), scratch);\n+\t\t\t      gen_rtx_REG (HImode, SOFT_Z_REGNUM), scratch);\n       emit_move_after_reload (stack_push_word,\n-\t\t\t      gen_rtx (REG, HImode, SOFT_SAVED_XY_REGNUM),\n+\t\t\t      gen_rtx_REG (HImode, SOFT_SAVED_XY_REGNUM),\n \t\t\t      scratch);\n     }\n \n@@ -1704,7 +1704,7 @@ expand_prologue (void)\n       if (regs_ever_live[regno] && !call_used_regs[regno])\n \t{\n \t  emit_move_after_reload (stack_push_word,\n-\t\t\t\t  gen_rtx (REG, HImode, regno), scratch);\n+\t\t\t\t  gen_rtx_REG (HImode, regno), scratch);\n \t}\n     }\n }\n@@ -1742,7 +1742,7 @@ expand_epilogue (void)\n     {\n       if (regs_ever_live[regno] && !call_used_regs[regno])\n \t{\n-\t  emit_move_after_reload (gen_rtx (REG, HImode, regno),\n+\t  emit_move_after_reload (gen_rtx_REG (HImode, regno),\n \t\t\t\t  stack_pop_word, scratch);\n \t}\n     }\n@@ -1782,9 +1782,9 @@ expand_epilogue (void)\n   /* For an interrupt handler, restore ZTMP, ZREG and XYREG.  */\n   if (current_function_interrupt)\n     {\n-      emit_move_after_reload (gen_rtx (REG, HImode, SOFT_SAVED_XY_REGNUM),\n+      emit_move_after_reload (gen_rtx_REG (HImode, SOFT_SAVED_XY_REGNUM),\n \t\t\t      stack_pop_word, scratch);\n-      emit_move_after_reload (gen_rtx (REG, HImode, SOFT_Z_REGNUM),\n+      emit_move_after_reload (gen_rtx_REG (HImode, SOFT_Z_REGNUM),\n \t\t\t      stack_pop_word, scratch);\n       emit_move_after_reload (m68hc11_soft_tmp_reg, stack_pop_word, scratch);\n     }\n@@ -1805,12 +1805,12 @@ expand_epilogue (void)\n \t  emit_move_after_reload (scratch, stack_pointer_rtx, 0);\n \t  addr_reg = scratch;\n \t}\n-      emit_move_after_reload (gen_rtx (MEM, HImode,\n-\t\t\t\t       gen_rtx (PLUS, HImode, addr_reg,\n+      emit_move_after_reload (gen_rtx_MEM (HImode,\n+\t\t\t\t       gen_rtx_PLUS (HImode, addr_reg,\n \t\t\t\t\t\tGEN_INT (1))), d_reg, 0);\n       if (return_size > HARD_REG_SIZE)\n-\temit_move_after_reload (gen_rtx (MEM, HImode,\n-\t\t\t\t\t gen_rtx (PLUS, HImode, addr_reg,\n+\temit_move_after_reload (gen_rtx_MEM (HImode,\n+\t\t\t\t\t gen_rtx_PLUS (HImode, addr_reg,\n \t\t\t\t\t\t  GEN_INT (3))), ix_reg, 0);\n     }\n \n@@ -1830,7 +1830,7 @@ m68hc11_gen_lowpart (enum machine_mode mode, rtx x)\n      correct order.  */\n   if (GET_CODE (x) == MEM && m68hc11_auto_inc_p (XEXP (x, 0)))\n     {\n-      return gen_rtx (MEM, mode, XEXP (x, 0));\n+      return gen_rtx_MEM (mode, XEXP (x, 0));\n     }\n \n   /* Note that a CONST_DOUBLE rtx could represent either an integer or a\n@@ -1875,7 +1875,7 @@ m68hc11_gen_lowpart (enum machine_mode mode, rtx x)\n     }\n \n   if (mode == QImode && D_REG_P (x))\n-    return gen_rtx (REG, mode, HARD_B_REGNUM);\n+    return gen_rtx_REG (mode, HARD_B_REGNUM);\n \n   /* gen_lowpart crashes when it is called with a SUBREG.  */\n   if (GET_CODE (x) == SUBREG && SUBREG_BYTE (x) != 0)\n@@ -1905,7 +1905,7 @@ m68hc11_gen_highpart (enum machine_mode mode, rtx x)\n      correct order.  */\n   if (GET_CODE (x) == MEM && m68hc11_auto_inc_p (XEXP (x, 0)))\n     {\n-      return gen_rtx (MEM, mode, XEXP (x, 0));\n+      return gen_rtx_MEM (mode, XEXP (x, 0));\n     }\n \n   /* Note that a CONST_DOUBLE rtx could represent either an integer or a\n@@ -1963,7 +1963,7 @@ m68hc11_gen_highpart (enum machine_mode mode, rtx x)\n \t}\n     }\n   if (mode == QImode && D_REG_P (x))\n-    return gen_rtx (REG, mode, HARD_A_REGNUM);\n+    return gen_rtx_REG (mode, HARD_A_REGNUM);\n \n   /* There is no way in GCC to represent the upper part of a word register.\n      To obtain the 8-bit upper part of a soft register, we change the\n@@ -1976,20 +1976,20 @@ m68hc11_gen_highpart (enum machine_mode mode, rtx x)\n       /* Avoid the '*' for direct addressing mode when this\n          addressing mode is disabled.  */\n       pos = TARGET_NO_DIRECT_MODE ? 1 : 0;\n-      return gen_rtx (MEM, QImode,\n-\t\t      gen_rtx (SYMBOL_REF, Pmode,\n+      return gen_rtx_MEM (QImode,\n+\t\t      gen_rtx_SYMBOL_REF (Pmode,\n \t\t\t       &reg_names[REGNO (x)][pos]));\n     }\n \n   /* gen_highpart crashes when it is called with a SUBREG.  */\n   if (GET_CODE (x) == SUBREG)\n     {\n-      return gen_rtx (SUBREG, mode, XEXP (x, 0), XEXP (x, 1));\n+      return gen_rtx_SUBREG (mode, XEXP (x, 0), XEXP (x, 1));\n     }\n   if (GET_CODE (x) == REG)\n     {\n       if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n-        return gen_rtx (REG, mode, REGNO (x));\n+        return gen_rtx_REG (mode, REGNO (x));\n       else\n         return gen_rtx_SUBREG (mode, x, 0);\n     }\n@@ -2023,7 +2023,7 @@ dead_register_here (rtx x, rtx reg)\n   rtx p;\n \n   if (D_REG_P (reg))\n-    x_reg = gen_rtx (REG, SImode, HARD_X_REGNUM);\n+    x_reg = gen_rtx_REG (SImode, HARD_X_REGNUM);\n   else\n     x_reg = 0;\n \n@@ -2814,7 +2814,7 @@ m68hc11_split_move (rtx to, rtx from, rtx scratch)\n \n   if (TARGET_M6812\n       && IS_STACK_PUSH (to)\n-      && reg_mentioned_p (gen_rtx (REG, HImode, HARD_SP_REGNUM), from))\n+      && reg_mentioned_p (gen_rtx_REG (HImode, HARD_SP_REGNUM), from))\n     {\n       if (mode == SImode)\n         {\n@@ -2975,15 +2975,15 @@ m68hc11_emit_logical (enum machine_mode mode, int code, rtx *operands)\n       if (!H_REG_P (operands[0]) && operands[3])\n \t{\n \t  emit_move_insn (operands[3], operands[1]);\n-\t  emit_insn (gen_rtx (SET, mode,\n+\t  emit_insn (gen_rtx_SET (mode,\n \t\t\t      operands[3],\n \t\t\t      gen_rtx (code, mode,\n \t\t\t\t       operands[3], operands[2])));\n \t  insn = emit_move_insn (operands[0], operands[3]);\n \t}\n       else\n \t{\n-\t  insn = emit_insn (gen_rtx (SET, mode,\n+\t  insn = emit_insn (gen_rtx_SET (mode,\n \t\t\t\t     operands[0],\n \t\t\t\t     gen_rtx (code, mode,\n \t\t\t\t\t      operands[0], operands[2])));\n@@ -3077,10 +3077,10 @@ m68hc11_output_swap (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n \t{\n \t  cc_status = cc_prev_status;\n \t  if (D_REG_P (cc_status.value1))\n-\t    cc_status.value1 = gen_rtx (REG, GET_MODE (cc_status.value1),\n+\t    cc_status.value1 = gen_rtx_REG (GET_MODE (cc_status.value1),\n \t\t\t\t\tHARD_X_REGNUM);\n \t  else\n-\t    cc_status.value1 = gen_rtx (REG, GET_MODE (cc_status.value1),\n+\t    cc_status.value1 = gen_rtx_REG (GET_MODE (cc_status.value1),\n \t\t\t\t\tHARD_D_REGNUM);\n \t}\n       else\n@@ -3096,10 +3096,10 @@ m68hc11_output_swap (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n \t{\n \t  cc_status = cc_prev_status;\n \t  if (D_REG_P (cc_status.value1))\n-\t    cc_status.value1 = gen_rtx (REG, GET_MODE (cc_status.value1),\n+\t    cc_status.value1 = gen_rtx_REG (GET_MODE (cc_status.value1),\n \t\t\t\t\tHARD_Y_REGNUM);\n \t  else\n-\t    cc_status.value1 = gen_rtx (REG, GET_MODE (cc_status.value1),\n+\t    cc_status.value1 = gen_rtx_REG (GET_MODE (cc_status.value1),\n \t\t\t\t\tHARD_D_REGNUM);\n \t}\n       else\n@@ -4733,7 +4733,7 @@ m68hc11_find_z_replacement (rtx insn, struct replace_info *info)\n   if (info->regno >= 0)\n     {\n       reg = info->regno;\n-      info->replace_reg = gen_rtx (REG, HImode, reg);\n+      info->replace_reg = gen_rtx_REG (HImode, reg);\n     }\n   else if (info->can_use_d)\n     {\n@@ -4785,26 +4785,26 @@ m68hc11_z_replacement (rtx insn)\n \n       if (Z_REG_P (dst) && (H_REG_P (src) && !SP_REG_P (src)))\n \t{\n-\t  XEXP (body, 0) = gen_rtx (REG, GET_MODE (dst), SOFT_Z_REGNUM);\n+\t  XEXP (body, 0) = gen_rtx_REG (GET_MODE (dst), SOFT_Z_REGNUM);\n \t  return;\n \t}\n       else if (Z_REG_P (src)\n \t       && ((H_REG_P (dst) && !SP_REG_P (src)) || dst == cc0_rtx))\n \t{\n-\t  XEXP (body, 1) = gen_rtx (REG, GET_MODE (src), SOFT_Z_REGNUM);\n+\t  XEXP (body, 1) = gen_rtx_REG (GET_MODE (src), SOFT_Z_REGNUM);\n \t  return;\n \t}\n       else if (D_REG_P (dst)\n \t       && m68hc11_arith_operator (src, GET_MODE (src))\n \t       && D_REG_P (XEXP (src, 0)) && Z_REG_P (XEXP (src, 1)))\n \t{\n-\t  XEXP (src, 1) = gen_rtx (REG, GET_MODE (src), SOFT_Z_REGNUM);\n+\t  XEXP (src, 1) = gen_rtx_REG (GET_MODE (src), SOFT_Z_REGNUM);\n \t  return;\n \t}\n       else if (Z_REG_P (dst) && GET_CODE (src) == CONST_INT\n \t       && INTVAL (src) == 0)\n \t{\n-\t  XEXP (body, 0) = gen_rtx (REG, GET_MODE (dst), SOFT_Z_REGNUM);\n+\t  XEXP (body, 0) = gen_rtx_REG (GET_MODE (dst), SOFT_Z_REGNUM);\n           /* Force it to be re-recognized.  */\n           INSN_CODE (insn) = -1;\n \t  return;\n@@ -4822,19 +4822,19 @@ m68hc11_z_replacement (rtx insn)\n       rtx dst;\n \n       if (info.must_push_reg && 0)\n-\tdst = gen_rtx (MEM, HImode,\n-\t\t       gen_rtx (PRE_DEC, HImode,\n-\t\t\t\tgen_rtx (REG, HImode, HARD_SP_REGNUM)));\n+\tdst = gen_rtx_MEM (HImode,\n+\t\t       gen_rtx_PRE_DEC (HImode,\n+\t\t\t\tgen_rtx_REG (HImode, HARD_SP_REGNUM)));\n       else\n-\tdst = gen_rtx (REG, HImode, SOFT_SAVED_XY_REGNUM);\n+\tdst = gen_rtx_REG (HImode, SOFT_SAVED_XY_REGNUM);\n \n       emit_insn_before (gen_movhi (dst,\n-\t\t\t\t   gen_rtx (REG, HImode, info.regno)), insn);\n+\t\t\t\t   gen_rtx_REG (HImode, info.regno)), insn);\n     }\n   if (info.must_load_z && !info.must_push_reg)\n     {\n-      emit_insn_before (gen_movhi (gen_rtx (REG, HImode, info.regno),\n-\t\t\t\t   gen_rtx (REG, HImode, SOFT_Z_REGNUM)),\n+      emit_insn_before (gen_movhi (gen_rtx_REG (HImode, info.regno),\n+\t\t\t\t   gen_rtx_REG (HImode, SOFT_Z_REGNUM)),\n \t\t\tinsn);\n     }\n \n@@ -4894,7 +4894,7 @@ m68hc11_z_replacement (rtx insn)\n \t  if (reg_mentioned_p (z_reg, insn))\n \t    {\n \t      if (replace_reg_qi == NULL_RTX)\n-\t\treplace_reg_qi = gen_rtx (REG, QImode, REGNO (replace_reg));\n+\t\treplace_reg_qi = gen_rtx_REG (QImode, REGNO (replace_reg));\n \t      validate_replace_rtx (z_reg_qi, replace_reg_qi, insn);\n \t    }\n \n@@ -4926,8 +4926,8 @@ m68hc11_z_replacement (rtx insn)\n       if (info.save_before_last)\n \tsave_pos_insn = PREV_INSN (save_pos_insn);\n \n-      emit_insn_before (gen_movhi (gen_rtx (REG, HImode, SOFT_Z_REGNUM),\n-\t\t\t\t   gen_rtx (REG, HImode, info.regno)),\n+      emit_insn_before (gen_movhi (gen_rtx_REG (HImode, SOFT_Z_REGNUM),\n+\t\t\t\t   gen_rtx_REG (HImode, info.regno)),\n \t\t\tsave_pos_insn);\n     }\n \n@@ -4936,12 +4936,12 @@ m68hc11_z_replacement (rtx insn)\n       rtx new_body, body;\n \n       body = PATTERN (info.last);\n-      new_body = gen_rtx (PARALLEL, VOIDmode,\n+      new_body = gen_rtx_PARALLEL (VOIDmode,\n \t\t\t  gen_rtvec (3, body,\n-\t\t\t\t     gen_rtx (USE, VOIDmode,\n+\t\t\t\t     gen_rtx_USE (VOIDmode,\n \t\t\t\t\t      replace_reg),\n-\t\t\t\t     gen_rtx (USE, VOIDmode,\n-\t\t\t\t\t      gen_rtx (REG, HImode,\n+\t\t\t\t     gen_rtx_USE (VOIDmode,\n+\t\t\t\t\t      gen_rtx_REG (HImode,\n \t\t\t\t\t\t       SOFT_Z_REGNUM))));\n       PATTERN (info.last) = new_body;\n \n@@ -4961,13 +4961,13 @@ m68hc11_z_replacement (rtx insn)\n       rtx dst;\n \n       if (info.must_push_reg && 0)\n-\tdst = gen_rtx (MEM, HImode,\n-\t\t       gen_rtx (POST_INC, HImode,\n-\t\t\t\tgen_rtx (REG, HImode, HARD_SP_REGNUM)));\n+\tdst = gen_rtx_MEM (HImode,\n+\t\t       gen_rtx_POST_INC (HImode,\n+\t\t\t\tgen_rtx_REG (HImode, HARD_SP_REGNUM)));\n       else\n-\tdst = gen_rtx (REG, HImode, SOFT_SAVED_XY_REGNUM);\n+\tdst = gen_rtx_REG (HImode, SOFT_SAVED_XY_REGNUM);\n \n-      emit_insn_before (gen_movhi (gen_rtx (REG, HImode, info.regno),\n+      emit_insn_before (gen_movhi (gen_rtx_REG (HImode, info.regno),\n \t\t\t\t   dst), insn);\n     }\n \n@@ -4983,10 +4983,10 @@ m68hc11_reassign_regs (rtx first)\n {\n   rtx insn;\n \n-  ix_reg = gen_rtx (REG, HImode, HARD_X_REGNUM);\n-  iy_reg = gen_rtx (REG, HImode, HARD_Y_REGNUM);\n-  z_reg = gen_rtx (REG, HImode, HARD_Z_REGNUM);\n-  z_reg_qi = gen_rtx (REG, QImode, HARD_Z_REGNUM);\n+  ix_reg = gen_rtx_REG (HImode, HARD_X_REGNUM);\n+  iy_reg = gen_rtx_REG (HImode, HARD_Y_REGNUM);\n+  z_reg = gen_rtx_REG (HImode, HARD_Z_REGNUM);\n+  z_reg_qi = gen_rtx_REG (QImode, HARD_Z_REGNUM);\n \n   /* Scan all insns to replace Z by X or Y preserving the old value\n      of X/Y and restoring it afterward.  */\n@@ -5049,7 +5049,7 @@ m68hc11_reorg (void)\n   rtx insn, first;\n \n   z_replacement_completed = 0;\n-  z_reg = gen_rtx (REG, HImode, HARD_Z_REGNUM);\n+  z_reg = gen_rtx_REG (HImode, HARD_Z_REGNUM);\n   first = get_insns ();\n \n   /* Some RTX are shared at this point.  This breaks the Z register"}, {"sha": "8c0dd19a44dccc30c641d6255e069eaa858d0868", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -1122,13 +1122,13 @@ typedef struct m68hc11_args\n       The high part is passed in X and the low part in D.\n       For GCC, the register number must be HARD_X_REGNUM.  */\n #define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n-     gen_rtx (REG, TYPE_MODE (VALTYPE),\t\t\t\t\t\\\n+     gen_rtx_REG (TYPE_MODE (VALTYPE),\t\t\t\t\t\\\n               ((TYPE_MODE (VALTYPE) == BLKmode\t\t\t\t\\\n \t        || GET_MODE_SIZE (TYPE_MODE (VALTYPE)) <= 2)\t\t\\\n \t\t   ? HARD_D_REGNUM : HARD_X_REGNUM))\n \n #define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n-     gen_rtx (REG, MODE,\t\t\t\t\t\t\\\n+     gen_rtx_REG (MODE,\t\t\t\t\t\t\\\n               (((MODE) == BLKmode || GET_MODE_SIZE (MODE) <= 2)\t\t\\\n                    ? HARD_D_REGNUM : HARD_X_REGNUM))\n "}, {"sha": "1dbbaf54bb2a22f35d44e7f8c6bcebfbb8f44236", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 163, "deletions": 163, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -215,7 +215,7 @@\n    (set (cc0) (reg:QI D_REGNUM))\n    (parallel [(set (reg:HI D_REGNUM) (match_dup 1))\n \t      (set (match_dup 1) (reg:HI D_REGNUM))])]\n-  \"operands[1] = gen_rtx (REG, HImode, REGNO (operands[0]));\")\n+  \"operands[1] = gen_rtx_REG (HImode, REGNO (operands[0]));\")\n \n (define_insn \"tstqi_1\"\n   [(set (cc0)\n@@ -265,7 +265,7 @@\n    (set (match_dup 1) (match_dup 2))\n    (set (cc0) (match_dup 0))\n    (set (match_dup 1) (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))]\n-  \"operands[2] = gen_rtx (REG, HImode, SOFT_Z_REGNUM);\")\n+  \"operands[2] = gen_rtx_REG (HImode, SOFT_Z_REGNUM);\")\n \n \n ;;--------------------------------------------------------------------\n@@ -304,7 +304,7 @@\n   [(set (match_dup 2) (match_dup 1))\n    (set (cc0)\n         (compare (match_dup 0) (match_dup 2)))]\n-  \"operands[2] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\")\n+  \"operands[2] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\")\n \n (define_expand \"cmphi\"\n   [(set (cc0)\n@@ -381,7 +381,7 @@\n    (set (match_dup 2) (match_dup 3))\n    (set (cc0) (compare (match_dup 0) (match_dup 1)))\n    (set (match_dup 2) (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))]\n-  \"operands[3] = gen_rtx (REG, HImode, SOFT_Z_REGNUM);\")\n+  \"operands[3] = gen_rtx_REG (HImode, SOFT_Z_REGNUM);\")\n \n ;;\n ;; 8-bit comparison with address register.\n@@ -400,7 +400,7 @@\n         (compare (reg:QI D_REGNUM) (match_dup 1)))\n    (parallel [(set (reg:HI D_REGNUM) (match_dup 3))\n               (set (match_dup 3) (reg:HI D_REGNUM))])]\n-  \"operands[3] = gen_rtx (REG, HImode, REGNO (operands[0]));\")\n+  \"operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));\")\n \n (define_split\n   [(set (cc0)\n@@ -410,9 +410,9 @@\n   [(set (match_dup 3) (match_dup 4))\n    (set (cc0)\n         (compare (match_dup 0) (match_dup 2)))]\n-  \"operands[2] = gen_rtx (REG, QImode, SOFT_TMP_REGNUM);\n-   operands[3] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n-   operands[4] = gen_rtx (REG, HImode, REGNO (operands[1]));\")\n+  \"operands[2] = gen_rtx_REG (QImode, SOFT_TMP_REGNUM);\n+   operands[3] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\n+   operands[4] = gen_rtx_REG (HImode, REGNO (operands[1]));\")\n \n (define_expand \"cmpqi\"\n   [(set (cc0)\n@@ -448,9 +448,9 @@\n   \"z_replacement_completed == 2\"\n   [(set (match_dup 3) (match_dup 2))\n    (set (cc0) (and:QI (match_dup 0) (match_dup 4)))]\n-  \"operands[2] = gen_rtx (REG, HImode, REGNO (operands[1]));\n-   operands[3] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n-   operands[4] = gen_rtx (REG, QImode, SOFT_TMP_REGNUM);\")\n+  \"operands[2] = gen_rtx_REG (HImode, REGNO (operands[1]));\n+   operands[3] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\n+   operands[4] = gen_rtx_REG (QImode, SOFT_TMP_REGNUM);\")\n \n (define_insn \"bitcmpqi_z_used\"\n   [(set (cc0)\n@@ -472,7 +472,7 @@\n    (set (match_dup 2) (match_dup 3))\n    (set (cc0) (and:QI (match_dup 0) (match_dup 1)))\n    (set (match_dup 2) (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))]\n-  \"operands[3] = gen_rtx (REG, HImode, SOFT_Z_REGNUM);\")\n+  \"operands[3] = gen_rtx_REG (HImode, SOFT_Z_REGNUM);\")\n \n (define_insn \"bitcmphi\"\n   [(set (cc0)\n@@ -562,7 +562,7 @@\n    (set (match_dup 2) (match_dup 3))\n    (set (cc0) (compare (match_dup 0) (match_dup 1)))\n    (set (match_dup 2) (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))]\n-  \"operands[3] = gen_rtx (REG, HImode, SOFT_Z_REGNUM);\")\n+  \"operands[3] = gen_rtx_REG (HImode, SOFT_Z_REGNUM);\")\n \n ;;--------------------------------------------------------------------\n ;;-  Move strict_low_part\n@@ -870,7 +870,7 @@\n     {\n       rtx insn;\n \n-      insn = emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+      insn = emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n       REG_NOTES (insn) = alloc_EXPR_LIST (REG_INC,\n \t\t\t\t\t  stack_pointer_rtx,\n \t\t\t\t\t  REG_NOTES (insn));\n@@ -944,7 +944,7 @@\n    (set (reg:QI D_REGNUM) (match_dup 1))\n    (parallel [(set (reg:HI D_REGNUM) (match_dup 2))\n               (set (match_dup 2) (reg:HI D_REGNUM))])]\n-  \"operands[2] = gen_rtx (REG, HImode, REGNO (operands[0]));\")\n+  \"operands[2] = gen_rtx_REG (HImode, REGNO (operands[0]));\")\n \n ;;\n ;; 8-bit operations on address registers.\n@@ -960,7 +960,7 @@\n    (set (match_dup 0) (reg:QI D_REGNUM))\n    (parallel [(set (reg:HI D_REGNUM) (match_dup 2))\n               (set (match_dup 2) (reg:HI D_REGNUM))])]\n-  \"operands[2] = gen_rtx (REG, HImode, REGNO (operands[1]));\")\n+  \"operands[2] = gen_rtx_REG (HImode, REGNO (operands[1]));\")\n \n (define_insn \"*movqi2_push\"\n   [(set (match_operand:QI 0 \"push_operand\" \"=<,<\")\n@@ -1010,7 +1010,7 @@\n     {\n       rtx insn;\n \n-      insn = emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+      insn = emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n       REG_NOTES (insn) = alloc_EXPR_LIST (REG_INC,\n \t\t\t\t\t  stack_pointer_rtx,\n \t\t\t\t\t  REG_NOTES (insn));\n@@ -1112,7 +1112,7 @@\n    /* Source operand must be in a hard register.  */\n    if (!H_REG_P (src))\n      {\n-       src = gen_rtx (REG, QImode, REGNO (operands[2]));\n+       src = gen_rtx_REG (QImode, REGNO (operands[2]));\n        emit_move_insn (src, operands[1]);\n      }\n \n@@ -1129,24 +1129,24 @@\n        else\n \t {\n            emit_move_insn (push, operands[2]);\n-           emit_insn (gen_addhi3 (gen_rtx (REG, HImode, HARD_SP_REGNUM),\n-\t\t\t\t  gen_rtx (REG, HImode, HARD_SP_REGNUM),\n+           emit_insn (gen_addhi3 (gen_rtx_REG (HImode, HARD_SP_REGNUM),\n+\t\t\t\t  gen_rtx_REG (HImode, HARD_SP_REGNUM),\n \t\t\t          const1_rtx));\n \t }\n      }\n    else\n      {\n        /* Source is in X or Y.  It's better to push the 16-bit register\n           and then to some stack adjustment.  */\n-       src = gen_rtx (REG, HImode, REGNO (src));\n+       src = gen_rtx_REG (HImode, REGNO (src));\n        emit_move_insn (push, src);\n        emit_move_insn (operands[2], const0_rtx);\n-       emit_insn (gen_addhi3 (gen_rtx (REG, HImode, HARD_SP_REGNUM),\n-\t\t\t      gen_rtx (REG, HImode, HARD_SP_REGNUM),\n+       emit_insn (gen_addhi3 (gen_rtx_REG (HImode, HARD_SP_REGNUM),\n+\t\t\t      gen_rtx_REG (HImode, HARD_SP_REGNUM),\n \t\t\t      const1_rtx));\n        emit_move_insn (push, operands[2]);\n-       emit_insn (gen_addhi3 (gen_rtx (REG, HImode, HARD_SP_REGNUM),\n-\t\t\t      gen_rtx (REG, HImode, HARD_SP_REGNUM),\n+       emit_insn (gen_addhi3 (gen_rtx_REG (HImode, HARD_SP_REGNUM),\n+\t\t\t      gen_rtx_REG (HImode, HARD_SP_REGNUM),\n \t\t\t      const1_rtx));\n      }      \n    emit_move_insn (push, operands[2]);\n@@ -1170,13 +1170,13 @@\n    /* Source operand must be in a hard register.  */\n    if (!H_REG_P (src))\n      {\n-       src = gen_rtx (REG, QImode, REGNO (operands[2]));\n+       src = gen_rtx_REG (QImode, REGNO (operands[2]));\n        emit_move_insn (src, operands[1]);\n      }\n \n    emit_move_insn (m68hc11_gen_lowpart (QImode, low2), src);\n    emit_move_insn (operands[2], const0_rtx);\n-   src = gen_rtx (REG, QImode, REGNO (operands[2]));\n+   src = gen_rtx_REG (QImode, REGNO (operands[2]));\n    emit_move_insn (m68hc11_gen_highpart (QImode, low2), src);\n \n    emit_move_insn (m68hc11_gen_highpart (HImode, low), operands[2]);\n@@ -1315,35 +1315,35 @@\n   \"\n    if (X_REG_P (operands[1]))\n      {\n-\temit_insn (gen_swap_areg (gen_rtx (REG, HImode, HARD_D_REGNUM),\n-\t\t\t\t  gen_rtx (REG, HImode, HARD_X_REGNUM)));\n-\temit_insn (gen_zero_extendqihi2 (gen_rtx (REG, HImode, HARD_D_REGNUM),\n-\t\t\t\t\t gen_rtx (REG, QImode, HARD_D_REGNUM)));\n-\temit_move_insn (gen_rtx (REG, HImode, HARD_X_REGNUM),\n+\temit_insn (gen_swap_areg (gen_rtx_REG (HImode, HARD_D_REGNUM),\n+\t\t\t\t  gen_rtx_REG (HImode, HARD_X_REGNUM)));\n+\temit_insn (gen_zero_extendqihi2 (gen_rtx_REG (HImode, HARD_D_REGNUM),\n+\t\t\t\t\t gen_rtx_REG (QImode, HARD_D_REGNUM)));\n+\temit_move_insn (gen_rtx_REG (HImode, HARD_X_REGNUM),\n \t\t\tconst0_rtx);\n \tDONE;\n      }\n \n-   if (reg_mentioned_p (gen_rtx (REG, HImode, HARD_X_REGNUM), operands[1]))\n+   if (reg_mentioned_p (gen_rtx_REG (HImode, HARD_X_REGNUM), operands[1]))\n      {\n \temit_insn (gen_zero_extendqihi2 (m68hc11_gen_lowpart (HImode,\n \t\t\t\t\t\t\t      operands[0]),\n \t\t\t\t\t operands[1]));\n-\temit_move_insn (gen_rtx (REG, HImode, HARD_X_REGNUM), const0_rtx);\n+\temit_move_insn (gen_rtx_REG (HImode, HARD_X_REGNUM), const0_rtx);\n \tDONE;\n      }\n    operands[4] = m68hc11_gen_highpart (HImode, operands[0]);\n    operands[5] = m68hc11_gen_lowpart (HImode, operands[0]);\n    if (A_REG_P (operands[1]))\n      {\n-       operands[2] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n-       operands[3] = gen_rtx (REG, HImode, REGNO (operands[1]));\n-       operands[6] = gen_rtx (REG, QImode, SOFT_TMP_REGNUM);\n+       operands[2] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\n+       operands[3] = gen_rtx_REG (HImode, REGNO (operands[1]));\n+       operands[6] = gen_rtx_REG (QImode, SOFT_TMP_REGNUM);\n      }\n    else\n      {\n        operands[5] = operands[2] =\n-       operands[3] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+       operands[3] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n        operands[6] = operands[1];\n      }\n \")\n@@ -1429,7 +1429,7 @@\n     {\n       if (!D_REG_P (operands[1]))\n         {\n-\t  ops[0] = gen_rtx (REG, QImode, HARD_D_REGNUM);\n+\t  ops[0] = gen_rtx_REG (QImode, HARD_D_REGNUM);\n \t  ops[1] = operands[1];\n \t  m68hc11_gen_movqi (insn, ops);\n \t}\n@@ -1535,7 +1535,7 @@\n \t{\n \t  if (!D_REG_P (operands[1]))\n \t    {\n-\t      ops[0] = gen_rtx (REG, QImode, HARD_D_REGNUM);\n+\t      ops[0] = gen_rtx_REG (QImode, HARD_D_REGNUM);\n \t      ops[1] = operands[1];\n \t      m68hc11_gen_movqi (insn, ops);\n \t    }\n@@ -1616,7 +1616,7 @@\n       x_reg_used = reg_mentioned_p (ix_reg, operands[1]);\n       if (x_reg_used)\n         {\n-\t  ops[0] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+\t  ops[0] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n \t  ops[1] = operands[1];\n \t  m68hc11_gen_movhi (insn, ops);\n         }\n@@ -1629,7 +1629,7 @@\n          Don't use it; keep it for documentation.  */\n       if (!D_REG_P (operands[1]) && !x_reg_used)\n         {\n-          ops[0] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+          ops[0] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n           ops[1] = operands[1];\n           m68hc11_gen_movhi (insn, ops);\n         }\n@@ -1646,7 +1646,7 @@\n     }\n   else\n     {\n-      ops[0] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+      ops[0] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n       ops[1] = operands[1];\n       m68hc11_gen_movhi (insn, ops);\n     }\n@@ -1793,7 +1793,7 @@\n         }\n       else if (!D_REG_P (operands[1]))\n         {\n-          ops[0] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+          ops[0] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n           ops[1] = operands[1];\n           m68hc11_gen_movhi (insn, ops);\n         }\n@@ -1847,8 +1847,8 @@\n     {\n       if (H_REG_P (operands[1]))\n \t{\n-\t  ops[0] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n-\t  ops[1] = gen_rtx (REG, HImode, REGNO (operands[1]));\n+\t  ops[0] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\n+\t  ops[1] = gen_rtx_REG (HImode, REGNO (operands[1]));\n \t  m68hc11_gen_movhi (insn, ops);\n \t}\n       else\n@@ -1865,7 +1865,7 @@\n         }\n       else if (!D_REG_P (operands[1]))\n         {\n-          ops[0] = gen_rtx (REG, QImode, HARD_D_REGNUM);\n+          ops[0] = gen_rtx_REG (QImode, HARD_D_REGNUM);\n           ops[1] = operands[1];\n           m68hc11_gen_movqi (insn, ops);\n         }\n@@ -2015,7 +2015,7 @@\n   \"operands[4] = m68hc11_gen_highpart (HImode, operands[2]);\n    if (X_REG_P (operands[0]))\n      {\n-       operands[5] = operands[6] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+       operands[5] = operands[6] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n      }\n    else\n      {\n@@ -2078,13 +2078,13 @@\n {\n   if (TARGET_M6811 && SP_REG_P (operands[0]))\n     {\n-      emit_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (2,\n-\t\t\t gen_rtx (SET, VOIDmode,\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,\n+\t\t\t gen_rtx_SET (VOIDmode,\n \t\t\t\t  operand0,\n-\t\t\t\t  gen_rtx (PLUS, HImode,\n+\t\t\t\t  gen_rtx_PLUS (HImode,\n \t\t\t\t\t   operand1, operand2)),\n-\t\t\tgen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\tgen_rtx (SCRATCH, HImode)))));\n+\t\t\tgen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\tgen_rtx_SCRATCH (HImode)))));\n       DONE;\n     }\n }\")\n@@ -2214,8 +2214,8 @@\n   HOST_WIDE_INT val;\n \n   if (optimize && Y_REG_P (operands[3])\n-      && dead_register_here (insn, gen_rtx (REG, HImode, HARD_X_REGNUM)))\n-    operands[3] = gen_rtx (REG, HImode, HARD_X_REGNUM);\n+      && dead_register_here (insn, gen_rtx_REG (HImode, HARD_X_REGNUM)))\n+    operands[3] = gen_rtx_REG (HImode, HARD_X_REGNUM);\n \n   if (GET_CODE (operands[2]) == CONST_INT\n       && (val = INTVAL (operands[2])) != 0\n@@ -2260,7 +2260,7 @@\n   output_asm_insn (\\\"ts%3\\\", operands);\n   if (GET_CODE (operands[2]) == CONST_INT\n       && ((val = INTVAL (operands[2])) >= 0 && val < 0x100)\n-      && dead_register_here (insn, gen_rtx (REG, HImode, HARD_D_REGNUM)))\n+      && dead_register_here (insn, gen_rtx_REG (HImode, HARD_D_REGNUM)))\n     {\n       output_asm_insn (\\\"ldab\\\\t%2\\\", operands);\n       output_asm_insn (\\\"ab%3\\\", operands);\n@@ -2520,20 +2520,20 @@\n   if (A_REG_P (operands[2]))\n     {\n       if (TARGET_M6812)\n-        ops[0] = gen_rtx (MEM, HImode,\n-\t\t\t  gen_rtx (PRE_DEC, HImode,\n-\t\t\t\t   gen_rtx (REG, HImode, HARD_SP_REGNUM)));\n+        ops[0] = gen_rtx_MEM (HImode,\n+\t\t\t  gen_rtx_PRE_DEC (HImode,\n+\t\t\t\t   gen_rtx_REG (HImode, HARD_SP_REGNUM)));\n       else\n-        ops[0] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n+        ops[0] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\n \n       ops[1] = operands[2];\n       m68hc11_gen_movhi (insn, ops);\n       if (TARGET_M6812)\n-        operands[2] = gen_rtx (MEM, HImode,\n-\t\t\t       gen_rtx (POST_INC, HImode,\n-\t\t\t\t        gen_rtx (REG, HImode, HARD_SP_REGNUM)));\n+        operands[2] = gen_rtx_MEM (HImode,\n+\t\t\t       gen_rtx_POST_INC (HImode,\n+\t\t\t\t        gen_rtx_REG (HImode, HARD_SP_REGNUM)));\n       else\n-        operands[2] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n+        operands[2] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\n     }\n   ops[0] = gen_label_rtx (); \n   output_asm_insn (\\\"subd\\\\t%2\\\", operands);\n@@ -2556,10 +2556,10 @@\n \n   if (A_REG_P (operands[2]))\n     {\n-      ops[0] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n+      ops[0] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\n       ops[1] = operands[2];\n       m68hc11_gen_movhi (insn, ops);\n-      operands[2] = gen_rtx (REG, QImode, SOFT_TMP_REGNUM);\n+      operands[2] = gen_rtx_REG (QImode, SOFT_TMP_REGNUM);\n     }\n   ops[0] = gen_label_rtx (); \n   output_asm_insn (\\\"subb\\\\t%b2\\\", operands);\n@@ -2733,7 +2733,7 @@\n     {\n       rtx ops[2];\n \n-      ops[0] = gen_rtx (REG, QImode, SOFT_TMP_REGNUM);\n+      ops[0] = gen_rtx_REG (QImode, SOFT_TMP_REGNUM);\n       ops[1] = operands[2];\n       m68hc11_gen_movqi (insn, ops);\n       return \\\"subb\\\\t%T0\\\\n\\\\tsbca\\\\t#0\\\";\n@@ -2880,7 +2880,7 @@\n \t  operands[1] = temp;\n \t}\n \n-      ops[0] = gen_rtx (REG, QImode, HARD_A_REGNUM);\n+      ops[0] = gen_rtx_REG (QImode, HARD_A_REGNUM);\n       ops[1] = operands[2];\n       m68hc11_gen_movqi (insn, ops);\n \n@@ -2940,13 +2940,13 @@\n    (parallel [(set (reg:HI D_REGNUM) (match_dup 3))\n               (set (match_dup 3) (reg:HI D_REGNUM))])]\n   \"\n-   operands[3] = gen_rtx (REG, HImode, REGNO (operands[0]));\n+   operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));\n    if (A_REG_P (operands[1]))\n-     operands[5] = gen_rtx (REG, QImode, HARD_D_REGNUM);\n+     operands[5] = gen_rtx_REG (QImode, HARD_D_REGNUM);\n    else\n      operands[5] = operands[1];\n    if (A_REG_P (operands[2]))\n-     operands[6] = gen_rtx (REG, QImode, HARD_D_REGNUM);\n+     operands[6] = gen_rtx_REG (QImode, HARD_D_REGNUM);\n    else\n      operands[6] = operands[2];\n   \")\n@@ -2977,7 +2977,7 @@\n     {\n       rtx ops[2];\n \n-      ops[0] = gen_rtx (REG, QImode, HARD_A_REGNUM);\n+      ops[0] = gen_rtx_REG (QImode, HARD_A_REGNUM);\n       ops[1] = operands[2];\n       m68hc11_gen_movqi (insn, ops);\n     }\n@@ -3675,9 +3675,9 @@\n      {\n        operands[5] = operands[1];\n        /* Make all the (set (REG:x) (REG:y)) a nop set.  */\n-       operands[4] = gen_rtx (REG, QImode, HARD_A_REGNUM);\n-       operands[7] = gen_rtx (REG, QImode, HARD_D_REGNUM);\n-       operands[6] = gen_rtx (REG, HImode, HARD_X_REGNUM);\n+       operands[4] = gen_rtx_REG (QImode, HARD_A_REGNUM);\n+       operands[7] = gen_rtx_REG (QImode, HARD_D_REGNUM);\n+       operands[6] = gen_rtx_REG (HImode, HARD_X_REGNUM);\n      }\n    else\n      {\n@@ -3710,8 +3710,8 @@\n      {\n        operands[5] = operands[1];\n        /* Make all the (set (REG:x) (REG:y)) a nop set.  */\n-       operands[4] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n-       operands[6] = gen_rtx (REG, HImode, HARD_X_REGNUM);\n+       operands[4] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n+       operands[6] = gen_rtx_REG (HImode, HARD_X_REGNUM);\n      }\n    else\n      {\n@@ -3760,16 +3760,16 @@\n    PUT_MODE (operands[3], QImode);\n    if (D_REG_P (operands[2]))\n      {\n-       operands[4] = gen_rtx (REG, QImode, HARD_A_REGNUM);\n+       operands[4] = gen_rtx_REG (QImode, HARD_A_REGNUM);\n        operands[5] = operands[1];\n-       operands[6] = gen_rtx (REG, QImode, HARD_B_REGNUM);\n+       operands[6] = gen_rtx_REG (QImode, HARD_B_REGNUM);\n      }\n    else\n      {\n        operands[4] = m68hc11_gen_highpart (QImode, operands[2]);\n        operands[5] = m68hc11_gen_lowpart (QImode, operands[2]);\n        if (D_REG_P (operands[1]))\n-\t operands[6] = gen_rtx (REG, QImode, HARD_B_REGNUM);\n+\t operands[6] = gen_rtx_REG (QImode, HARD_B_REGNUM);\n        else\n          operands[6] = operands[1];\n      }\n@@ -3802,7 +3802,7 @@\n        operands[5] = operands[1];\n        if (D_REG_P (operands[2]))\n          {\n-           operands[4] = gen_rtx (REG, QImode, HARD_B_REGNUM);\n+           operands[4] = gen_rtx_REG (QImode, HARD_B_REGNUM);\n          }\n        else\n          {\n@@ -3835,8 +3835,8 @@\n   \"operands[5] = m68hc11_gen_highpart (HImode, operands[1]);\n    if (X_REG_P (operands[2]))\n      {\n-       operands[4] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n-       operands[6] = gen_rtx (REG, HImode, HARD_X_REGNUM);\n+       operands[4] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n+       operands[6] = gen_rtx_REG (HImode, HARD_X_REGNUM);\n      }\n    else\n      {\n@@ -3878,7 +3878,7 @@\n    if (GET_CODE (operands[3]) == AND)\n      operands[5] = const0_rtx;\n    else\n-     operands[5] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+     operands[5] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n    \")\n \n \n@@ -3977,12 +3977,12 @@\n \t   || (m68hc11_small_indexed_indirect_p (operands[2], HImode)\n \t       && reg_mentioned_p (operands[0], operands[2]))))\n      {\n-       operands[4] = gen_rtx (MEM, HImode,\n-\t\t\t      gen_rtx (PRE_DEC, HImode,\n-\t\t\t\t       gen_rtx (REG, HImode, HARD_SP_REGNUM)));\n-       operands[6] = gen_rtx (MEM, HImode,\n-\t\t\t      gen_rtx (POST_INC, HImode,\n-\t\t\t\t       gen_rtx (REG, HImode, HARD_SP_REGNUM)));\n+       operands[4] = gen_rtx_MEM (HImode,\n+\t\t\t      gen_rtx_PRE_DEC (HImode,\n+\t\t\t\t       gen_rtx_REG (HImode, HARD_SP_REGNUM)));\n+       operands[6] = gen_rtx_MEM (HImode,\n+\t\t\t      gen_rtx_POST_INC (HImode,\n+\t\t\t\t       gen_rtx_REG (HImode, HARD_SP_REGNUM)));\n        operands[5] = operands[2];\n        operands[8] = operands[7] = operands[0];\n      }\n@@ -3994,20 +3994,20 @@\n        if (GET_CODE (operands[3]) == MINUS\n \t   && reg_mentioned_p (operands[0], operands[2]))\n \t {\n-\t   operands[9] = gen_rtx (MEM, HImode,\n-\t\t\t      gen_rtx (PRE_DEC, HImode,\n-\t\t\t\t       gen_rtx (REG, HImode, HARD_SP_REGNUM)));\n-\t   operands[1] = gen_rtx (MEM, HImode,\n-\t\t\t      gen_rtx (POST_INC, HImode,\n-\t\t\t\t       gen_rtx (REG, HImode, HARD_SP_REGNUM)));\n-\t   operands[8] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n+\t   operands[9] = gen_rtx_MEM (HImode,\n+\t\t\t      gen_rtx_PRE_DEC (HImode,\n+\t\t\t\t       gen_rtx_REG (HImode, HARD_SP_REGNUM)));\n+\t   operands[1] = gen_rtx_MEM (HImode,\n+\t\t\t      gen_rtx_POST_INC (HImode,\n+\t\t\t\t       gen_rtx_REG (HImode, HARD_SP_REGNUM)));\n+\t   operands[8] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\n \t   operands[4] = operands[7] = operands[0];\n \t   operands[6] = operands[8];\n \t   operands[5] = operands[2];\n \t }\n        else \n \t {\n-       operands[4] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n+       operands[4] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\n        operands[6] = operands[4];\n        if (!H_REG_P (operands[2]))\n \t {\n@@ -4075,7 +4075,7 @@\n    && z_replacement_completed == 2 && !SP_REG_P (operands[2])\"\n   [(set (match_dup 4) (match_dup 2))\n    (set (match_dup 0) (match_op_dup 3 [(match_dup 0) (match_dup 4)]))]\n-  \"operands[4] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\")\n+  \"operands[4] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\")\n \n ;;\n ;; For 68HC12, push the operand[2] value on the stack and do the\n@@ -4090,12 +4090,12 @@\n    && z_replacement_completed == 2 && !SP_REG_P (operands[2])\"\n   [(set (match_dup 4) (match_dup 2))\n    (set (match_dup 0) (match_op_dup 3 [(match_dup 0) (match_dup 5)]))]\n-  \"operands[4] = gen_rtx (MEM, HImode,\n-\t\t\t  gen_rtx (PRE_DEC, HImode,\n-\t\t\t\t   gen_rtx (REG, HImode, HARD_SP_REGNUM)));\n-   operands[5] = gen_rtx (MEM, HImode,\n-\t\t\t  gen_rtx (POST_INC, HImode,\n-\t\t\t\t   gen_rtx (REG, HImode, HARD_SP_REGNUM)));\n+  \"operands[4] = gen_rtx_MEM (HImode,\n+\t\t\t  gen_rtx_PRE_DEC (HImode,\n+\t\t\t\t   gen_rtx_REG (HImode, HARD_SP_REGNUM)));\n+   operands[5] = gen_rtx_MEM (HImode,\n+\t\t\t  gen_rtx_POST_INC (HImode,\n+\t\t\t\t   gen_rtx_REG (HImode, HARD_SP_REGNUM)));\n    \")\n \n ;;--------------------------------------------------------------------\n@@ -4134,12 +4134,12 @@\n       || reg_mentioned_p (operands[0], operands[1]))\n     {\n       /* Move to the destination register, before the xgdx.  */\n-      operands[4] = gen_rtx (REG, GET_MODE (operands[1]), \n+      operands[4] = gen_rtx_REG (GET_MODE (operands[1]), \n \t\t\t     REGNO (operands[0]));\n       operands[5] = operands[1];\n \n       /* Apply the operation on D.  */\n-      operands[3] = gen_rtx (REG, GET_MODE (operands[1]), HARD_D_REGNUM);\n+      operands[3] = gen_rtx_REG (GET_MODE (operands[1]), HARD_D_REGNUM);\n     }\n   else\n     {\n@@ -4175,7 +4175,7 @@\n    (set (reg:QI D_REGNUM) (match_op_dup 3 [(reg:QI D_REGNUM) (match_dup 7)]))\n    (parallel [(set (reg:HI D_REGNUM) (match_dup 4))\n               (set (match_dup 4) (reg:HI D_REGNUM))])]\n-  \"operands[4] = gen_rtx (REG, HImode, REGNO (operands[0]));\n+  \"operands[4] = gen_rtx_REG (HImode, REGNO (operands[0]));\n \n    /* For the second operand is a hard register or if the address\n       register appears in the source, we have to save the operand[2]\n@@ -4184,19 +4184,19 @@\n       will result in a nop.  */\n    if (H_REG_P (operands[2]))\n      {\n-       operands[5] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n-       operands[6] = gen_rtx (REG, HImode, REGNO (operands[2]));\n-       operands[7] = gen_rtx (REG, QImode, SOFT_TMP_REGNUM);\n+       operands[5] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\n+       operands[6] = gen_rtx_REG (HImode, REGNO (operands[2]));\n+       operands[7] = gen_rtx_REG (QImode, SOFT_TMP_REGNUM);\n      }\n    else if (reg_mentioned_p (operands[0], operands[2]))\n      {\n-       operands[5] = gen_rtx (REG, QImode, SOFT_TMP_REGNUM);\n+       operands[5] = gen_rtx_REG (QImode, SOFT_TMP_REGNUM);\n        operands[6] = operands[2];\n        operands[7] = operands[5];\n      }\n    else\n      {\n-       operands[5] = operands[6] = gen_rtx (REG, QImode, HARD_D_REGNUM);\n+       operands[5] = operands[6] = gen_rtx_REG (QImode, HARD_D_REGNUM);\n        operands[7] = operands[2];\n      }\n   \")\n@@ -4221,9 +4221,9 @@\n   \"reload_completed\"\n   [(set (match_dup 5) (match_dup 6))\n    (set (match_dup 0) (match_op_dup 3 [(match_dup 0) (match_dup 4)]))]\n-  \"operands[4] = gen_rtx (REG, QImode, SOFT_TMP_REGNUM);\n-   operands[5] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n-   operands[6] = gen_rtx (REG, HImode, REGNO (operands[2]));\")\n+  \"operands[4] = gen_rtx_REG (QImode, SOFT_TMP_REGNUM);\n+   operands[5] = gen_rtx_REG (HImode, SOFT_TMP_REGNUM);\n+   operands[6] = gen_rtx_REG (HImode, REGNO (operands[2]));\")\n \n ;;--------------------------------------------------------------------\n ;; 8-bit Unary operations on X and Y:\n@@ -4256,7 +4256,7 @@\n               (set (match_dup 3) (reg:HI D_REGNUM))])]\n   \"\n {\n-  operands[3] = gen_rtx (REG, HImode, REGNO (operands[0]));\n+  operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));\n   if ((H_REG_P (operands[1])\n        && !rtx_equal_p (operands[0], operands[1]))\n       || reg_mentioned_p (operands[0], operands[1]))\n@@ -4266,7 +4266,7 @@\n       operands[5] = operands[1];\n \n       /* Apply the operation on D.  */\n-      operands[6] = gen_rtx (REG, QImode, HARD_D_REGNUM);\n+      operands[6] = gen_rtx_REG (QImode, HARD_D_REGNUM);\n     }\n   else\n     {\n@@ -4660,7 +4660,7 @@\n       rtx ops[2];\n \n       ops[1] = m68hc11_gen_lowpart (HImode, operands[1]);\n-      ops[0] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+      ops[0] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n       m68hc11_gen_movhi (insn, ops);\n       output_asm_insn (\\\"lsld\\\", ops);\n       if (!X_REG_P (operands[0]))\n@@ -4676,7 +4676,7 @@\n \t{\n \t  /* Load the high part in X in case the source operand\n \t     uses X as a memory pointer.  */\n-\t  ops[0] = gen_rtx (REG, HImode, HARD_X_REGNUM);\n+\t  ops[0] = gen_rtx_REG (HImode, HARD_X_REGNUM);\n           ops[1] = m68hc11_gen_highpart (HImode, operands[1]);\n           m68hc11_gen_movhi (insn, ops);\n           output_asm_insn (\\\"xgdx\\\", ops);\n@@ -4756,12 +4756,12 @@\n     {\n       rtx scratch = gen_reg_rtx (HImode);\n       emit_move_insn (scratch, operands[2]);\n-      emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t \t gen_rtvec (2, gen_rtx (SET, VOIDmode,\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode,\n+\t \t gen_rtvec (2, gen_rtx_SET (VOIDmode,\n \t\t\t    operand0,\n \t\t\t    gen_rtx_ASHIFT (HImode,\n \t\t\t\t\toperand1, scratch)),\n-\t\t\t      gen_rtx (CLOBBER, VOIDmode, scratch))));\n+\t\t\t      gen_rtx_CLOBBER (VOIDmode, scratch))));\n       DONE;\n     }\n }\")\n@@ -4949,7 +4949,7 @@\n   if (!D_REG_P (operands[0]) && !Q_REG_P (operands[0]))\n     return \\\"#\\\";\n \n-  ops[0] = gen_rtx (REG, QImode, HARD_A_REGNUM);\n+  ops[0] = gen_rtx_REG (QImode, HARD_A_REGNUM);\n   ops[1] = operands[2];\n   m68hc11_gen_movqi (insn, ops);\n \n@@ -4969,12 +4969,12 @@\n       rtx scratch = gen_reg_rtx (HImode);\n \n       emit_move_insn (scratch, operands[2]);\n-      emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t gen_rtvec (2, gen_rtx (SET, VOIDmode,\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode,\n+\t\t gen_rtvec (2, gen_rtx_SET (VOIDmode,\n \t\t\t\toperand0,\n \t\t\t\tgen_rtx_ASHIFTRT (HImode,\n \t\t\t\t\toperand1, scratch)),\n-\t\t\t      gen_rtx (CLOBBER, VOIDmode, scratch))));\n+\t\t\t      gen_rtx_CLOBBER (VOIDmode, scratch))));\n        DONE;\n     }\n }\")\n@@ -5213,7 +5213,7 @@\n   if (!D_REG_P (operands[0]) && !Q_REG_P (operands[0]))\n     return \\\"#\\\";\n \n-  ops[0] = gen_rtx (REG, QImode, HARD_A_REGNUM);\n+  ops[0] = gen_rtx_REG (QImode, HARD_A_REGNUM);\n   ops[1] = operands[2];\n   m68hc11_gen_movqi (insn, ops);\n \n@@ -5424,7 +5424,7 @@\n       rtx ops[2];\n \n       ops[1] = m68hc11_gen_highpart (HImode, operands[1]);\n-      ops[0] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+      ops[0] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n       m68hc11_gen_movhi (insn, ops);\n       output_asm_insn (\\\"lsrd\\\", ops);\n       if (!X_REG_P (operands[0]))\n@@ -5439,7 +5439,7 @@\n       else\n \t{\n \t  /* Load the lowpart in X in case the operands is some N,x.  */\n-\t  ops[0] = gen_rtx (REG, HImode, HARD_X_REGNUM);\n+\t  ops[0] = gen_rtx_REG (HImode, HARD_X_REGNUM);\n           ops[1] = m68hc11_gen_lowpart (HImode, operands[1]);\n           m68hc11_gen_movhi (insn, ops);\n           output_asm_insn (\\\"xgdx\\\", ops);\n@@ -5516,12 +5516,12 @@\n       operand1 = force_reg (HImode, operand1);\n \n       emit_move_insn (scratch, operands[2]);\n-      emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t gen_rtvec (2, gen_rtx (SET, VOIDmode,\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode,\n+\t\t gen_rtvec (2, gen_rtx_SET (VOIDmode,\n \t\t\t\t\toperand0,\n \t\t\t\t\tgen_rtx_LSHIFTRT (HImode,\n \t\t\t\t\t\toperand1, scratch)),\n-\t\t\t      gen_rtx (CLOBBER, VOIDmode, scratch))));\n+\t\t\t      gen_rtx_CLOBBER (VOIDmode, scratch))));\n      DONE;\n   }\n }\")\n@@ -5738,7 +5738,7 @@\n     return \\\"#\\\";\n \n   CC_STATUS_INIT;\n-  ops[0] = gen_rtx (REG, QImode, HARD_A_REGNUM);\n+  ops[0] = gen_rtx_REG (QImode, HARD_A_REGNUM);\n   ops[1] = operands[2];\n   m68hc11_gen_movqi (insn, ops);\n \n@@ -5835,12 +5835,12 @@\n       operand1 = force_reg (HImode, operand1);\n \n       emit_move_insn (scratch, operands[2]);\n-      emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t gen_rtvec (2, gen_rtx (SET, VOIDmode,\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode,\n+\t\t gen_rtvec (2, gen_rtx_SET (VOIDmode,\n \t\t\t\t\toperand0,\n \t\t\t\t\tgen_rtx_ROTATE (HImode,\n \t\t\t\t\t\toperand1, scratch)),\n-\t\t\t      gen_rtx (CLOBBER, VOIDmode, scratch))));\n+\t\t\t      gen_rtx_CLOBBER (VOIDmode, scratch))));\n       DONE;\n     }\n }\")\n@@ -5883,12 +5883,12 @@\n       operand1 = force_reg (HImode, operand1);\n \n       emit_move_insn (scratch, operands[2]);\n-      emit_insn (gen_rtx (PARALLEL, VOIDmode,\n-\t\t gen_rtvec (2, gen_rtx (SET, VOIDmode,\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode,\n+\t\t gen_rtvec (2, gen_rtx_SET (VOIDmode,\n \t\t\t\t\toperand0,\n \t\t\t\t\tgen_rtx_ROTATERT (HImode,\n \t\t\t\t\t\toperand1, scratch)),\n-\t\t\t      gen_rtx (CLOBBER, VOIDmode, scratch))));\n+\t\t\t      gen_rtx_CLOBBER (VOIDmode, scratch))));\n       DONE;\n     }\n }\")\n@@ -5979,14 +5979,14 @@\n   if (GET_MODE (operands[0]) == HImode)\n     {\n       emit_jump_insn (gen_m68hc12_dbcc_dec_hi (operands[0],\n-\t\t\t\t\t       gen_rtx (NE, HImode),\n+\t\t\t\t\t       gen_rtx_NE (HImode),\n \t\t\t\t\t       operands[4]));\n       DONE;\n     }\n   if (GET_MODE (operands[0]) == QImode)\n     {\n       emit_jump_insn (gen_m68hc12_dbcc_dec_qi (operands[0],\n-\t\t\t\t\t       gen_rtx (NE, QImode),\n+\t\t\t\t\t       gen_rtx_NE (QImode),\n \t\t\t\t\t       operands[4]));\n       DONE;\n     }\n@@ -6746,15 +6746,15 @@\n \n   if (ret_size && ret_size <= 2)\n     {\n-      emit_jump_insn (gen_rtx (PARALLEL, VOIDmode,\n+      emit_jump_insn (gen_rtx_PARALLEL (VOIDmode,\n \t\t      gen_rtvec (2, gen_rtx_RETURN (VOIDmode),\n \t\t\t         gen_rtx_USE (VOIDmode,\n \t\t\t\t\t      gen_rtx_REG (HImode, 1)))));\n       DONE;\n     }\n   if (ret_size)\n     {\n-      emit_jump_insn (gen_rtx (PARALLEL, VOIDmode,\n+      emit_jump_insn (gen_rtx_PARALLEL (VOIDmode,\n \t\t      gen_rtvec (2, gen_rtx_RETURN (VOIDmode),\n \t\t\t         gen_rtx_USE (VOIDmode,\n \t\t\t\t\t      gen_rtx_REG (SImode, 0)))));\n@@ -6936,8 +6936,8 @@\n    (match_scratch:HI 0 \"xy\")]\n   \"0 && TARGET_M6812 && optimize_size\"\n   [(set (match_dup 0) (match_dup 1))]\n-  \"operands[1] = gen_rtx (MEM, HImode,\n-\t\t\t  gen_rtx (POST_INC, HImode,\n+  \"operands[1] = gen_rtx_MEM (HImode,\n+\t\t\t  gen_rtx_POST_INC (HImode,\n \t\t\t\t   gen_rtx_REG (HImode, HARD_SP_REGNUM)));\")\n \n ;;\n@@ -7019,11 +7019,11 @@\n    && reg_mentioned_p (operands[0], operands[2])\"\n   [(set (cc0) (match_dup 3))]\n   \"if (INTVAL (operands[1]) == 1)\n-     operands[3] = gen_rtx (MEM, QImode,\n-\t\t\t    gen_rtx (PRE_INC, HImode, operands[0]));\n+     operands[3] = gen_rtx_MEM (QImode,\n+\t\t\t    gen_rtx_PRE_INC (HImode, operands[0]));\n    else\n-     operands[3] = gen_rtx (MEM, QImode,\n-\t\t\t    gen_rtx (PRE_DEC, HImode, operands[0]));\n+     operands[3] = gen_rtx_MEM (QImode,\n+\t\t\t    gen_rtx_PRE_DEC (HImode, operands[0]));\n   \")\n \n ;;\n@@ -7041,11 +7041,11 @@\n    && reg_mentioned_p (operands[0], operands[3])\"\n   [(set (cc0) (compare (match_dup 2) (match_dup 4)))]\n   \"if (INTVAL (operands[1]) == 1)\n-     operands[4] = gen_rtx (MEM, QImode,\n-\t\t\t    gen_rtx (PRE_INC, HImode, operands[0]));\n+     operands[4] = gen_rtx_MEM (QImode,\n+\t\t\t    gen_rtx_PRE_INC (HImode, operands[0]));\n    else\n-     operands[4] = gen_rtx (MEM, QImode,\n-\t\t\t    gen_rtx (PRE_DEC, HImode, operands[0]));\n+     operands[4] = gen_rtx_MEM (QImode,\n+\t\t\t    gen_rtx_PRE_DEC (HImode, operands[0]));\n   \")\n \n (define_peephole2\n@@ -7060,11 +7060,11 @@\n    && reg_mentioned_p (operands[0], operands[2])\"\n   [(set (cc0) (compare (match_dup 4) (match_dup 3)))]\n   \"if (INTVAL (operands[1]) == 1)\n-     operands[4] = gen_rtx (MEM, QImode,\n-\t\t\t    gen_rtx (PRE_INC, HImode, operands[0]));\n+     operands[4] = gen_rtx_MEM (QImode,\n+\t\t\t    gen_rtx_PRE_INC (HImode, operands[0]));\n    else\n-     operands[4] = gen_rtx (MEM, QImode,\n-\t\t\t    gen_rtx (PRE_DEC, HImode, operands[0]));\n+     operands[4] = gen_rtx_MEM (QImode,\n+\t\t\t    gen_rtx_PRE_DEC (HImode, operands[0]));\n   \")\n \n ;;\n@@ -7271,7 +7271,7 @@\n   rtx ops[2];\n \n   ops[0] = operands[0];\n-  ops[1] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+  ops[1] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n   m68hc11_gen_movhi (insn, ops);\n   return \\\"\\\";\n }\n@@ -7324,7 +7324,7 @@\n   rtx ops[2];\n \n   ops[0] = operands[0];\n-  ops[1] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+  ops[1] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n   m68hc11_gen_movhi (insn, ops);\n   return \\\"\\\";\n }\n@@ -7344,7 +7344,7 @@\n   rtx ops[2];\n \n   ops[0] = operands[0];\n-  ops[1] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+  ops[1] = gen_rtx_REG (HImode, HARD_D_REGNUM);\n   m68hc11_gen_movhi (insn, ops);\n   return \\\"\\\";\n }\n@@ -7381,8 +7381,8 @@\n   rtx ops[2];\n \n   ops[0] = operands[2];\n-  ops[1] = gen_rtx (MEM, HImode,\n-\t\t    gen_rtx (POST_INC, HImode, stack_pointer_rtx));\n+  ops[1] = gen_rtx_MEM (HImode,\n+\t\t    gen_rtx_POST_INC (HImode, stack_pointer_rtx));\n   m68hc11_gen_movhi (insn, ops);\n   return \\\"\\\";\n }"}, {"sha": "b9d41895b54b3680490bbd47494c939e157079dc", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -738,7 +738,7 @@\n \toperands[0] = force_reg (SImode, XEXP (operands[0], 0));\n       else if (GET_CODE (operands[0]) == MEM\n \t       && symbolic_operand (XEXP (operands[0], 0), SImode))\n-\toperands[0] = gen_rtx (MEM, SImode,\n+\toperands[0] = gen_rtx_MEM (SImode,\n \t\t\t       force_reg (SImode, XEXP (operands[0], 0)));\n     }\n }\")\n@@ -997,7 +997,7 @@\n \t     m68k doesn't consider PC-relative addresses to be writable.  */\n \t  if (GET_CODE (operands[0]) == MEM\n \t      && symbolic_operand (XEXP (operands[0], 0), SImode))\n-\t    operands[0] = gen_rtx (MEM, XFmode,\n+\t    operands[0] = gen_rtx_MEM (XFmode,\n \t\t\t\t   force_reg (SImode, XEXP (operands[0], 0)));\n \t}\n     }"}, {"sha": "ba7ad4073f1615509398237ee777e812ab890e59", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -207,14 +207,14 @@ output_stack_adjust (int direction, int size)\n   /* If extending stack a lot, we do it incrementally.  */\n   if (direction < 0 && size > mcore_stack_increment && mcore_stack_increment > 0)\n     {\n-      rtx tmp = gen_rtx (REG, SImode, 1);\n+      rtx tmp = gen_rtx_REG (SImode, 1);\n       rtx memref;\n \n       emit_insn (gen_movsi (tmp, GEN_INT (mcore_stack_increment)));\n       do\n \t{\n \t  emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, tmp));\n-\t  memref = gen_rtx (MEM, SImode, stack_pointer_rtx);\n+\t  memref = gen_rtx_MEM (SImode, stack_pointer_rtx);\n \t  MEM_VOLATILE_P (memref) = 1;\n \t  emit_insn (gen_movsi (memref, stack_pointer_rtx));\n \t  size -= mcore_stack_increment;\n@@ -232,7 +232,7 @@ output_stack_adjust (int direction, int size)\n \n       if (size > 32)\n \t{\n-\t  rtx nval = gen_rtx (REG, SImode, 1);\n+\t  rtx nval = gen_rtx_REG (SImode, 1);\n \t  emit_insn (gen_movsi (nval, val));\n \t  val = nval;\n \t}\n@@ -550,7 +550,7 @@ mcore_gen_compare_reg (enum rtx_code code)\n {\n   rtx op0 = arch_compare_op0;\n   rtx op1 = arch_compare_op1;\n-  rtx cc_reg = gen_rtx (REG, CCmode, CC_REG);\n+  rtx cc_reg = gen_rtx_REG (CCmode, CC_REG);\n \n   if (CONSTANT_P (op1) && GET_CODE (op1) != CONST_INT)\n     op1 = force_reg (SImode, op1);\n@@ -623,7 +623,7 @@ mcore_gen_compare_reg (enum rtx_code code)\n       break;\n     }\n \n-  emit_insn (gen_rtx (SET, VOIDmode, cc_reg, gen_rtx (code, CCmode, op0, op1)));\n+  emit_insn (gen_rtx_SET (VOIDmode, cc_reg, gen_rtx (code, CCmode, op0, op1)));\n   \n   return cc_reg;\n }\n@@ -1641,14 +1641,14 @@ mcore_expand_insv (rtx operands[])\n       if ((INTVAL(operands[3])&1) == 0)\n \t{\n \t  mask = ~(1 << posn);\n-\t  emit_insn (gen_rtx (SET, SImode, operands[0],\n-\t\t\t      gen_rtx (AND, SImode, operands[0], GEN_INT (mask))));\n+\t  emit_insn (gen_rtx_SET (SImode, operands[0],\n+\t\t\t      gen_rtx_AND (SImode, operands[0], GEN_INT (mask))));\n \t}\n       else\n \t{\n \t  mask = 1 << posn;\n-\t  emit_insn (gen_rtx (SET, SImode, operands[0],\n-\t\t\t    gen_rtx (IOR, SImode, operands[0], GEN_INT (mask))));\n+\t  emit_insn (gen_rtx_SET (SImode, operands[0],\n+\t\t\t    gen_rtx_IOR (SImode, operands[0], GEN_INT (mask))));\n \t}\n       \n       return 1;\n@@ -1677,17 +1677,17 @@ mcore_expand_insv (rtx operands[])\n       INTVAL (operands[3]) == ((1 << width) - 1))\n     {\n       mreg = force_reg (SImode, GEN_INT (INTVAL (operands[3]) << posn));\n-      emit_insn (gen_rtx (SET, SImode, operands[0],\n-                         gen_rtx (IOR, SImode, operands[0], mreg)));\n+      emit_insn (gen_rtx_SET (SImode, operands[0],\n+                         gen_rtx_IOR (SImode, operands[0], mreg)));\n       return 1;\n     }\n \n   /* Generate the clear mask.  */\n   mreg = force_reg (SImode, GEN_INT (~(((1 << width) - 1) << posn)));\n \n   /* Clear the field, to overlay it later with the source.  */\n-  emit_insn (gen_rtx (SET, SImode, operands[0], \n-\t\t      gen_rtx (AND, SImode, operands[0], mreg)));\n+  emit_insn (gen_rtx_SET (SImode, operands[0], \n+\t\t      gen_rtx_AND (SImode, operands[0], mreg)));\n \n   /* If the source is constant 0, we've nothing to add back.  */\n   if (GET_CODE (operands[3]) == CONST_INT && INTVAL (operands[3]) == 0)\n@@ -1706,17 +1706,17 @@ mcore_expand_insv (rtx operands[])\n   if (width + posn != (int) GET_MODE_SIZE (SImode))\n     {\n       ereg = force_reg (SImode, GEN_INT ((1 << width) - 1));      \n-      emit_insn (gen_rtx (SET, SImode, sreg,\n-                          gen_rtx (AND, SImode, sreg, ereg)));\n+      emit_insn (gen_rtx_SET (SImode, sreg,\n+                          gen_rtx_AND (SImode, sreg, ereg)));\n     }\n \n   /* Insert source value in dest.  */\n   if (posn != 0)\n-    emit_insn (gen_rtx (SET, SImode, sreg,\n-\t\t        gen_rtx (ASHIFT, SImode, sreg, GEN_INT (posn))));\n+    emit_insn (gen_rtx_SET (SImode, sreg,\n+\t\t        gen_rtx_ASHIFT (SImode, sreg, GEN_INT (posn))));\n   \n-  emit_insn (gen_rtx (SET, SImode, operands[0],\n-\t\t      gen_rtx (IOR, SImode, operands[0], sreg)));\n+  emit_insn (gen_rtx_SET (SImode, operands[0],\n+\t\t      gen_rtx_IOR (SImode, operands[0], sreg)));\n \n   return 1;\n }\n@@ -1870,19 +1870,19 @@ block_move_sequence (rtx dest, rtx dst_mem, rtx src, rtx src_mem,\n \t    }\n \t  \n \t  size -= amount[next];\n-\t  srcp = gen_rtx (MEM,\n+\t  srcp = gen_rtx_MEM (\n #if 0\n \t\t\t  MEM_IN_STRUCT_P (src_mem) ? mode[next] : BLKmode,\n #else\n \t\t\t  mode[next],\n #endif\n-\t\t\t  gen_rtx (PLUS, Pmode, src,\n-\t\t\t\t   gen_rtx (CONST_INT, SImode, offset_ld)));\n+\t\t\t  gen_rtx_PLUS (Pmode, src,\n+\t\t\t\t\tgen_rtx_CONST_INT (SImode, offset_ld)));\n \t  \n \t  RTX_UNCHANGING_P (srcp) = RTX_UNCHANGING_P (src_mem);\n \t  MEM_VOLATILE_P (srcp) = MEM_VOLATILE_P (src_mem);\n \t  MEM_IN_STRUCT_P (srcp) = 1;\n-\t  emit_insn (gen_rtx (SET, VOIDmode, temp[next], srcp));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, temp[next], srcp));\n \t  offset_ld += amount[next];\n \t  active[next] = TRUE;\n \t}\n@@ -1891,19 +1891,19 @@ block_move_sequence (rtx dest, rtx dst_mem, rtx src, rtx src_mem,\n \t{\n \t  active[phase] = FALSE;\n \t  \n-\t  dstp = gen_rtx (MEM,\n+\t  dstp = gen_rtx_MEM (\n #if 0\n \t\t\t  MEM_IN_STRUCT_P (dst_mem) ? mode[phase] : BLKmode,\n #else\n \t\t\t  mode[phase],\n #endif\n-\t\t\t  gen_rtx (PLUS, Pmode, dest,\n-\t\t\t\t   gen_rtx (CONST_INT, SImode, offset_st)));\n+\t\t\t  gen_rtx_PLUS (Pmode, dest,\n+\t\t\t\t\tgen_rtx_CONST_INT (SImode, offset_st)));\n \t  \n \t  RTX_UNCHANGING_P (dstp) = RTX_UNCHANGING_P (dst_mem);\n \t  MEM_VOLATILE_P (dstp) = MEM_VOLATILE_P (dst_mem);\n \t  MEM_IN_STRUCT_P (dstp) = 1;\n-\t  emit_insn (gen_rtx (SET, VOIDmode, dstp, temp[phase]));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, dstp, temp[phase]));\n \t  offset_st += amount[phase];\n \t}\n     }\n@@ -1940,7 +1940,7 @@ mcore_expand_block_move (rtx dst_mem, rtx src_mem, rtx * operands)\n     }\n \n   /* If we get here, just use the library routine.  */\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"memcpy\"), 0, VOIDmode, 3,\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"memcpy\"), 0, VOIDmode, 3,\n \t\t     operands[0], Pmode, operands[1], Pmode, operands[2],\n \t\t     SImode);\n }\n@@ -2303,9 +2303,9 @@ mcore_expand_prolog (void)\n       for (offset = fi.arg_offset; remaining >= 4; offset -= 4, rn--, remaining -= 4)\n         {\n           emit_insn (gen_movsi\n-                     (gen_rtx (MEM, SImode,\n+                     (gen_rtx_MEM (SImode,\n                                plus_constant (stack_pointer_rtx, offset)),\n-                      gen_rtx (REG, SImode, rn)));\n+                      gen_rtx_REG (SImode, rn)));\n         }\n     }\n \n@@ -2328,8 +2328,8 @@ mcore_expand_prolog (void)\n \t        first_reg--;\n \t      first_reg++;\n \n-\t      emit_insn (gen_store_multiple (gen_rtx (MEM, SImode, stack_pointer_rtx),\n-\t\t\t\t\t     gen_rtx (REG, SImode, first_reg),\n+\t      emit_insn (gen_store_multiple (gen_rtx_MEM (SImode, stack_pointer_rtx),\n+\t\t\t\t\t     gen_rtx_REG (SImode, first_reg),\n \t\t\t\t\t     GEN_INT (16 - first_reg)));\n \n \t      i -= (15 - first_reg);\n@@ -2338,9 +2338,9 @@ mcore_expand_prolog (void)\n           else if (fi.reg_mask & (1 << i))\n \t    {\n \t      emit_insn (gen_movsi\n-\t\t         (gen_rtx (MEM, SImode,\n+\t\t         (gen_rtx_MEM (SImode,\n \t\t\t           plus_constant (stack_pointer_rtx, offs)),\n-\t\t          gen_rtx (REG, SImode, i)));\n+\t\t          gen_rtx_REG (SImode, i)));\n \t      offs += 4;\n \t    }\n         }\n@@ -2422,8 +2422,8 @@ mcore_expand_epilog (void)\n \t  \n \t  first_reg++;\n \n-\t  emit_insn (gen_load_multiple (gen_rtx (REG, SImode, first_reg),\n-\t\t\t\t\tgen_rtx (MEM, SImode, stack_pointer_rtx),\n+\t  emit_insn (gen_load_multiple (gen_rtx_REG (SImode, first_reg),\n+\t\t\t\t\tgen_rtx_MEM (SImode, stack_pointer_rtx),\n \t\t\t\t\tGEN_INT (16 - first_reg)));\n \n \t  i -= (15 - first_reg);\n@@ -2432,8 +2432,8 @@ mcore_expand_epilog (void)\n       else if (fi.reg_mask & (1 << i))\n \t{\n \t  emit_insn (gen_movsi\n-\t\t     (gen_rtx (REG, SImode, i),\n-\t\t      gen_rtx (MEM, SImode,\n+\t\t     (gen_rtx_REG (SImode, i),\n+\t\t      gen_rtx_MEM (SImode,\n \t\t\t       plus_constant (stack_pointer_rtx, offs))));\n \t  offs += 4;\n \t}\n@@ -3224,7 +3224,7 @@ mcore_mark_dllexport (tree decl)\n   idp = get_identifier (newname);\n \n   XEXP (DECL_RTL (decl), 0) =\n-    gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (idp));\n+    gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n }\n \n /* Mark a DECL as being dllimport'd.  */\n@@ -3285,8 +3285,8 @@ mcore_mark_dllimport (tree decl)\n   /* ??? At least I think that's why we do this.  */\n   idp = get_identifier (newname);\n \n-  newrtl = gen_rtx (MEM, Pmode,\n-\t\t    gen_rtx (SYMBOL_REF, Pmode,\n+  newrtl = gen_rtx_MEM (Pmode,\n+\t\t    gen_rtx_SYMBOL_REF (Pmode,\n \t\t\t     IDENTIFIER_POINTER (idp)));\n   XEXP (DECL_RTL (decl), 0) = newrtl;\n }\n@@ -3337,7 +3337,7 @@ mcore_encode_section_info (tree decl, rtx rtl ATTRIBUTE_UNUSED, int first ATTRIB\n     {\n       const char * oldname = XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0);\n       tree idp = get_identifier (oldname + 9);\n-      rtx newrtl = gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (idp));\n+      rtx newrtl = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n \n       XEXP (DECL_RTL (decl), 0) = newrtl;\n "}, {"sha": "56d311c49b021100dc4731a4988571d3cee09078", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -656,7 +656,7 @@ extern const enum reg_class reg_class_from_letter[];\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n-#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, FIRST_RET_REG)\n+#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, FIRST_RET_REG)\n \n /* 1 if N is a possible register number for a function value.\n    On the MCore, only r4 can return results.  */\n@@ -775,9 +775,9 @@ extern const enum reg_class reg_class_from_letter[];\n    CXT is an RTX for the static chain value for the function.  */\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)  \\\n {\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 8)),\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 8)),\t\\\n \t\t  (CXT));\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 12)),\t\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant ((TRAMP), 12)),\t\\\n \t\t  (FNADDR));\t\t\t\t\t\t\\\n }\n "}, {"sha": "f57da64ef63d66b1f5838ca2a7f12bf5e24e0333", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -1413,13 +1413,13 @@\n   count = INTVAL (operands[2]);\n   regno = REGNO (operands[0]);\n \n-  operands[3] = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (count));\n+  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n \n   for (i = 0; i < count; i++)\n     XVECEXP (operands[3], 0, i)\n-      = gen_rtx (SET, VOIDmode,\n-\t\t gen_rtx (REG, SImode, regno + i),\n-\t\t gen_rtx (MEM, SImode, plus_constant (stack_pointer_rtx,\n+      = gen_rtx_SET (VOIDmode,\n+\t\t gen_rtx_REG (SImode, regno + i),\n+\t\t gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx,\n \t\t\t\t\t\t      i * 4)));\n }\")\n \n@@ -1452,14 +1452,14 @@\n   count = INTVAL (operands[2]);\n   regno = REGNO (operands[1]);\n \n-  operands[3] = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (count));\n+  operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n \n   for (i = 0; i < count; i++)\n     XVECEXP (operands[3], 0, i)\n-      = gen_rtx (SET, VOIDmode,\n-\t\t gen_rtx (MEM, SImode, plus_constant (stack_pointer_rtx,\n+      = gen_rtx_SET (VOIDmode,\n+\t\t gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx,\n \t\t\t\t\t\t      i * 4)),\n-\t\t gen_rtx (REG, SImode, regno + i));\n+\t\t gen_rtx_REG (SImode, regno + i));\n }\")\n \n (define_insn \"\"\n@@ -1729,7 +1729,7 @@\n   if (GET_CODE (operands[0]) == MEM\n       && ! register_operand (XEXP (operands[0], 0), SImode)\n       && ! mcore_symbolic_address_p (XEXP (operands[0], 0)))\n-    operands[0] = gen_rtx (MEM, GET_MODE (operands[0]),\n+    operands[0] = gen_rtx_MEM (GET_MODE (operands[0]),\n \t\t\t   force_reg (Pmode, XEXP (operands[0], 0)));\n }\")\n \n@@ -1751,7 +1751,7 @@\n   if (GET_CODE (operands[0]) == MEM\n       && ! register_operand (XEXP (operands[0], 0), SImode)\n       && ! mcore_symbolic_address_p (XEXP (operands[0], 0)))\n-    operands[1] = gen_rtx (MEM, GET_MODE (operands[1]),\n+    operands[1] = gen_rtx_MEM (GET_MODE (operands[1]),\n \t\t\t   force_reg (Pmode, XEXP (operands[1], 0)));\n }\")\n \n@@ -2627,11 +2627,11 @@\n ;        rtx lshft = GEN_INT (32 - (INTVAL (operands[2]) + INTVAL (operands[3])));\n ;        rtx rshft = GEN_INT (32 - INTVAL (operands[2]));\n ;\n-;        emit_insn (gen_rtx (SET, SImode, operands[0], operands[1]));\n-;        emit_insn (gen_rtx (SET, SImode, operands[0],\n-;                            gen_rtx (ASHIFT, SImode, operands[0], lshft)));\n-;        emit_insn (gen_rtx (SET, SImode, operands[0],\n-;                            gen_rtx (ASHIFTRT, SImode, operands[0], rshft)));\n+;        emit_insn (gen_rtx_SET (SImode, operands[0], operands[1]));\n+;        emit_insn (gen_rtx_SET (SImode, operands[0],\n+;                            gen_rtx_ASHIFT (SImode, operands[0], lshft)));\n+;        emit_insn (gen_rtx_SET (SImode, operands[0],\n+;                            gen_rtx_ASHIFTRT (SImode, operands[0], rshft)));\n ;        DONE;\n ;     }\n ;     else\n@@ -2662,11 +2662,11 @@\n       rtx tmp1 = gen_reg_rtx (SImode);\n       rtx tmp2 = gen_reg_rtx (SImode);\n \n-      emit_insn (gen_rtx (SET, SImode, tmp1, operands[1]));\n-      emit_insn (gen_rtx (SET, SImode, tmp2,\n-                         gen_rtx (ASHIFT, SImode, tmp1, lshft)));\n-      emit_insn (gen_rtx (SET, SImode, operands[0],\n-                         gen_rtx (ASHIFTRT, SImode, tmp2, rshft)));\n+      emit_insn (gen_rtx_SET (SImode, tmp1, operands[1]));\n+      emit_insn (gen_rtx_SET (SImode, tmp2,\n+                         gen_rtx_ASHIFT (SImode, tmp1, lshft)));\n+      emit_insn (gen_rtx_SET (SImode, operands[0],\n+                         gen_rtx_ASHIFTRT (SImode, tmp2, rshft)));\n       DONE;\n     }\n   else\n@@ -2707,11 +2707,11 @@\n         {\n           rtx rshft = GEN_INT (INTVAL (operands[3]));\n           shifted = gen_reg_rtx (SImode);\n-          emit_insn (gen_rtx (SET, SImode, shifted,\n-                         gen_rtx (LSHIFTRT, SImode, operands[1], rshft)));\n+          emit_insn (gen_rtx_SET (SImode, shifted,\n+                         gen_rtx_LSHIFTRT (SImode, operands[1], rshft)));\n         }\n-     emit_insn (gen_rtx (SET, SImode, operands[0],\n-                       gen_rtx (AND, SImode, shifted, mask)));\n+     emit_insn (gen_rtx_SET (SImode, operands[0],\n+                       gen_rtx_AND (SImode, shifted, mask)));\n      DONE;\n    }\n  else if (TARGET_W_FIELD)\n@@ -2723,11 +2723,11 @@\n      rtx tmp1 = gen_reg_rtx (SImode);\n      rtx tmp2 = gen_reg_rtx (SImode);\n \n-     emit_insn (gen_rtx (SET, SImode, tmp1, operands[1]));\n-     emit_insn (gen_rtx (SET, SImode, tmp2,\n-                         gen_rtx (ASHIFT, SImode, tmp1, lshft)));\n-     emit_insn (gen_rtx (SET, SImode, operands[0],\n-                       gen_rtx (LSHIFTRT, SImode, tmp2, rshft)));\n+     emit_insn (gen_rtx_SET (SImode, tmp1, operands[1]));\n+     emit_insn (gen_rtx_SET (SImode, tmp2,\n+                         gen_rtx_ASHIFT (SImode, tmp1, lshft)));\n+     emit_insn (gen_rtx_SET (SImode, operands[0],\n+                       gen_rtx_LSHIFTRT (SImode, tmp2, rshft)));\n      DONE;\n    }\n  else\n@@ -3072,10 +3072,10 @@\n       abort ();\n \n    if (ofs > 0) \n-      operands[4] = gen_rtx (MEM, mode, \n-                              gen_rtx (PLUS, SImode, base_reg, GEN_INT(ofs)));\n+      operands[4] = gen_rtx_MEM (mode, \n+                              gen_rtx_PLUS (SImode, base_reg, GEN_INT(ofs)));\n    else\n-      operands[4] = gen_rtx (MEM, mode, base_reg);\n+      operands[4] = gen_rtx_MEM (mode, base_reg);\n \n    if (mode == QImode)\n       return \\\"movi\t%0,0\\\\n\\\\tst.b\t%0,%4\\\";\n@@ -3284,7 +3284,7 @@\n \t  emit_insn (gen_movsi (tmp, GEN_INT (STACK_UNITS_MAXSTEP)));\n \t  do\n \t    {\n-\t      rtx memref = gen_rtx (MEM, SImode, stack_pointer_rtx);\n+\t      rtx memref = gen_rtx_MEM (SImode, stack_pointer_rtx);\n \n               MEM_VOLATILE_P (memref) = 1;\n \t      emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, tmp));\n@@ -3322,7 +3322,7 @@\n \n       /* Extend a step, probe, and adjust remaining count.  */\n       emit_insn(gen_subsi3(stack_pointer_rtx, stack_pointer_rtx, step));\n-      memref = gen_rtx (MEM, SImode, stack_pointer_rtx);\n+      memref = gen_rtx_MEM (SImode, stack_pointer_rtx);\n       MEM_VOLATILE_P (memref) = 1;\n       emit_insn(gen_movsi(memref, stack_pointer_rtx));\n       emit_insn(gen_subsi3(tmp, tmp, step));"}, {"sha": "284f57345b25921b0f5975f52021bfaf55823553", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -3008,15 +3008,15 @@ gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0,\n     {\n       if (! TARGET_MIPS16)\n \t{\n-\t  convert_move (result, gen_rtx (GTU, mode, reg, const0_rtx), 0);\n+\t  convert_move (result, gen_rtx_GTU (mode, reg, const0_rtx), 0);\n \t  if (p_invert != NULL)\n \t    *p_invert = 0;\n \t  invert = 0;\n \t}\n       else\n \t{\n \t  reg2 = invert ? gen_reg_rtx (mode) : result;\n-\t  convert_move (reg2, gen_rtx (LTU, mode, reg, const1_rtx), 0);\n+\t  convert_move (reg2, gen_rtx_LTU (mode, reg, const1_rtx), 0);\n \t  reg = reg2;\n \t}\n     }\n@@ -3044,7 +3044,7 @@ gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0,\n \t  reg = reg2;\n \t  one = force_reg (mode, const1_rtx);\n \t}\n-      convert_move (result, gen_rtx (XOR, mode, reg, one), 0);\n+      convert_move (result, gen_rtx_XOR (mode, reg, one), 0);\n     }\n \n   return result;\n@@ -7050,10 +7050,10 @@ mips_expand_epilogue (int sibcall_p)\n     {\n       /* The mips16 loads the return address into $7, not $31.  */\n       if (TARGET_MIPS16 && (cfun->machine->frame.mask & RA_MASK) != 0)\n-\temit_jump_insn (gen_return_internal (gen_rtx (REG, Pmode,\n+\temit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode,\n \t\t\t\t\t\t      GP_REG_FIRST + 7)));\n       else\n-\temit_jump_insn (gen_return_internal (gen_rtx (REG, Pmode,\n+\temit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode,\n \t\t\t\t\t\t      GP_REG_FIRST + 31)));\n     }\n }\n@@ -8076,9 +8076,9 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n \t\t: \"\"),\n \t       fp_code);\n       id = get_identifier (buf);\n-      stub_fn = gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (id));\n+      stub_fn = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (id));\n \n-      emit_move_insn (gen_rtx (REG, Pmode, 2), fn);\n+      emit_move_insn (gen_rtx_REG (Pmode, 2), fn);\n \n       if (retval == NULL_RTX)\n \tinsn = gen_call_internal (stub_fn, arg_size);\n@@ -8090,9 +8090,9 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n       if (GET_CODE (insn) != CALL_INSN)\n \tabort ();\n       CALL_INSN_FUNCTION_USAGE (insn) =\n-\tgen_rtx (EXPR_LIST, VOIDmode,\n-\t\t gen_rtx (USE, VOIDmode, gen_rtx (REG, Pmode, 2)),\n-\t\t CALL_INSN_FUNCTION_USAGE (insn));\n+\tgen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t   gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, 2)),\n+\t\t\t   CALL_INSN_FUNCTION_USAGE (insn));\n \n       /* If we are handling a floating point return value, we need to\n          save $18 in the function prologue.  Putting a note on the\n@@ -8101,9 +8101,10 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n          code.  */\n       if (fpret)\n \tCALL_INSN_FUNCTION_USAGE (insn) =\n-\t  gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t   gen_rtx (USE, VOIDmode, gen_rtx (REG, word_mode, 18)),\n-\t\t   CALL_INSN_FUNCTION_USAGE (insn));\n+\t  gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t     gen_rtx_USE (VOIDmode,\n+\t\t\t\t\t  gen_rtx_REG (word_mode, 18)),\n+\t\t\t     CALL_INSN_FUNCTION_USAGE (insn));\n \n       /* Return 1 to tell the caller that we've generated the call\n          insn.  */\n@@ -8292,9 +8293,9 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n \tabort ();\n \n       CALL_INSN_FUNCTION_USAGE (insn) =\n-\tgen_rtx (EXPR_LIST, VOIDmode,\n-\t\t gen_rtx (USE, VOIDmode, gen_rtx (REG, word_mode, 18)),\n-\t\t CALL_INSN_FUNCTION_USAGE (insn));\n+\tgen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t   gen_rtx_USE (VOIDmode, gen_rtx_REG (word_mode, 18)),\n+\t\t\t   CALL_INSN_FUNCTION_USAGE (insn));\n \n       /* Return 1 to tell the caller that we've generated the call\n          insn.  */\n@@ -8556,12 +8557,12 @@ mips16_lay_out_constants (void)\n \t\t particular string constant.  */\n \n \t      lab = add_constant (&constants, val, mode);\n-\t      newsrc = gen_rtx (MEM, mode,\n-\t\t\t\tgen_rtx (LABEL_REF, VOIDmode, lab));\n+\t      newsrc = gen_rtx_MEM (mode,\n+\t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, lab));\n \t      RTX_UNCHANGING_P (newsrc) = 1;\n-\t      PATTERN (insn) = gen_rtx (SET, VOIDmode,\n-\t\t\t\t\tSET_DEST (PATTERN (insn)),\n-\t\t\t\t\tnewsrc);\n+\t      PATTERN (insn) = gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t    SET_DEST (PATTERN (insn)),\n+\t\t\t\t\t    newsrc);\n \t      INSN_CODE (insn) = -1;\n \n \t      if (first_constant_ref < 0)"}, {"sha": "737416b1e1bf1af5009afa91c55495968fc43bb1", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -569,7 +569,7 @@ enum reg_class\n    Before the prologue, RA is at 0(sp).  */\n \n #define INCOMING_RETURN_ADDR_RTX \\\n-  gen_rtx (MEM, VOIDmode, gen_rtx (REG, VOIDmode, STACK_POINTER_REGNUM))\n+  gen_rtx_MEM (VOIDmode, gen_rtx_REG (VOIDmode, STACK_POINTER_REGNUM))\n \n /* A C expression whose value is RTL representing the value of the\n    return address for the frame COUNT steps up from the current frame,\n@@ -581,7 +581,7 @@ enum reg_class\n \n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\\\n   ((COUNT> 0 && flag_omit_frame_pointer)? NULL_RTX\t\t\t\\\n-   : gen_rtx (MEM, Pmode, gen_rtx (PLUS, Pmode, (FRAME), GEN_INT(4))))\n+   : gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, (FRAME), GEN_INT(4))))\n \n /* A C expression whose value is an integer giving the offset, in\n    bytes, from the value of the stack pointer register to the top of"}, {"sha": "f4d94ebf3d7cc7f281d0409043701c46e03b6bb4", "filename": "gcc/config/ns32k/ns32k.md", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fns32k%2Fns32k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fns32k%2Fns32k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.md?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -1249,16 +1249,16 @@\n   last = emit_move_insn(temp, temp);\n   {\n     rtx divdi, moddi, divsi, modsi;\n-    divsi = gen_rtx (UDIV, SImode, operands[1], operands[2]);\n-    modsi = gen_rtx (UMOD, SImode, operands[1], operands[2]);\n-    divdi = gen_rtx (ZERO_EXTEND, DImode, divsi);\n-    moddi = gen_rtx (ZERO_EXTEND, DImode, modsi);\n-    REG_NOTES (first) = gen_rtx (INSN_LIST, REG_LIBCALL, last,\n+    divsi = gen_rtx_UDIV (SImode, operands[1], operands[2]);\n+    modsi = gen_rtx_UMOD (SImode, operands[1], operands[2]);\n+    divdi = gen_rtx_ZERO_EXTEND (DImode, divsi);\n+    moddi = gen_rtx_ZERO_EXTEND (DImode, modsi);\n+    REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last,\n \t\t\t         REG_NOTES (first));\n-    REG_NOTES (last) = gen_rtx (INSN_LIST, REG_RETVAL, first,\n-                                gen_rtx (EXPR_LIST, REG_EQUAL,\n-                       gen_rtx (IOR, DImode, moddi,\n-                               gen_rtx (ASHIFT, DImode, divdi, GEN_INT(32))),\n+    REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first,\n+                                gen_rtx_EXPR_LIST (REG_EQUAL,\n+                       gen_rtx_IOR (DImode, moddi,\n+                               gen_rtx_ASHIFT (DImode, divdi, GEN_INT(32))),\n                        REG_NOTES (last)));\n   }\n \n@@ -1314,14 +1314,14 @@\n ;;  last = emit_move_insn(temp, temp);\n ;;  {\n ;;    rtx divdi, moddi, divhi, modhi;\n-;;    divhi = gen_rtx (UDIV, HImode, operands[1], operands[2]);\n-;;    modhi = gen_rtx (UMOD, HImode, operands[1], operands[2]);\n-;;    divdi = gen_rtx (ZERO_EXTEND, DImode, divhi);\n-;;    moddi = gen_rtx (ZERO_EXTEND, DImode, modhi);\n-;;    REG_NOTES (first) = gen_rtx (INSN_LIST, REG_LIBCALL, last,\n+;;    divhi = gen_rtx_UDIV (HImode, operands[1], operands[2]);\n+;;    modhi = gen_rtx_UMOD (HImode, operands[1], operands[2]);\n+;;    divdi = gen_rtx_ZERO_EXTEND (DImode, divhi);\n+;;    moddi = gen_rtx_ZERO_EXTEND (DImode, modhi);\n+;;    REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last,\n ;;\t\t\t         REG_NOTES (first));\n-;;    REG_NOTES (last) = gen_rtx (INSN_LIST, REG_RETVAL, first,\n-;;                                gen_rtx (EXPR_LIST, REG_EQUAL,\n+;;    REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first,\n+;;                                gen_rtx_EXPR_LIST (REG_EQUAL,\n ;;                       gen_rtx(IOR, DImode, moddi,\n ;;                               gen_rtx(ASHIFT, DImode, divdi, GEN_INT(32))),\n ;;                       REG_NOTES (last)));\n@@ -1371,14 +1371,14 @@\n ;;  last = emit_move_insn(temp, temp);\n ;;  {\n ;;    rtx divdi, moddi, divqi, modqi;\n-;;    divqi = gen_rtx (UDIV, QImode, operands[1], operands[2]);\n-;;    modqi = gen_rtx (UMOD, QImode, operands[1], operands[2]);\n-;;    divdi = gen_rtx (ZERO_EXTEND, DImode, divqi);\n-;;    moddi = gen_rtx (ZERO_EXTEND, DImode, modqi);\n-;;    REG_NOTES (first) = gen_rtx (INSN_LIST, REG_LIBCALL, last,\n+;;    divqi = gen_rtx_UDIV (QImode, operands[1], operands[2]);\n+;;    modqi = gen_rtx_UMOD (QImode, operands[1], operands[2]);\n+;;    divdi = gen_rtx_ZERO_EXTEND (DImode, divqi);\n+;;    moddi = gen_rtx_ZERO_EXTEND (DImode, modqi);\n+;;    REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last,\n ;;\t\t\t         REG_NOTES (first));\n-;;    REG_NOTES (last) = gen_rtx (INSN_LIST, REG_RETVAL, first,\n-;;                                gen_rtx (EXPR_LIST, REG_EQUAL,\n+;;    REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first,\n+;;                                gen_rtx_EXPR_LIST (REG_EQUAL,\n ;;                       gen_rtx(IOR, DImode, moddi,\n ;;                               gen_rtx(ASHIFT, DImode, divdi, GEN_INT(32))),\n ;;                       REG_NOTES (last)));"}, {"sha": "8890874751360bcbf05aaa07e08e48aec87412cb", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -5563,7 +5563,7 @@ altivec_expand_predicate_builtin (enum insn_code icode, const char *opcode,\n   scratch = gen_reg_rtx (mode0);\n \n   pat = GEN_FCN (icode) (scratch, op0, op1,\n-\t\t\t gen_rtx (SYMBOL_REF, Pmode, opcode));\n+\t\t\t gen_rtx_SYMBOL_REF (Pmode, opcode));\n   if (! pat)\n     return 0;\n   emit_insn (pat);\n@@ -9606,8 +9606,8 @@ rs6000_generate_compare (enum rtx_code code)\n \t     However, we must be careful to emit correct RTL in\n \t     the meantime, so optimizations don't get confused.  */\n \n-\t  or1 = gen_rtx (NE, SImode, compare_result, const0_rtx);\n-\t  or2 = gen_rtx (NE, SImode, compare_result2, const0_rtx);\n+\t  or1 = gen_rtx_NE (SImode, compare_result, const0_rtx);\n+\t  or2 = gen_rtx_NE (SImode, compare_result2, const0_rtx);\n \n \t  /* OR them together.  */\n \t  cmp = gen_rtx_SET (VOIDmode, or_result,\n@@ -15112,7 +15112,7 @@ rs6000_machopic_legitimize_pic_address (rtx orig, enum machine_mode mode,\n \t      return machopic_legitimize_pic_address (mem, Pmode, reg);\n \t    }\n \t}\n-      return gen_rtx (PLUS, Pmode, base, offset);\n+      return gen_rtx_PLUS (Pmode, base, offset);\n     }\n \n   /* Fall back on generic machopic code.  */"}, {"sha": "3342b36e84d95a63a9b7091389513f01274ed27c", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -6131,7 +6131,7 @@ s390_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n       if (cum->fprs + 1 > (TARGET_64BIT? 4 : 2))\n \treturn 0;\n       else\n-\treturn gen_rtx (REG, mode, cum->fprs + 16);\n+\treturn gen_rtx_REG (mode, cum->fprs + 16);\n     }\n   else if (s390_function_arg_integer (mode, type))\n     {\n@@ -6141,7 +6141,7 @@ s390_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n       if (cum->gprs + n_gprs > 5)\n \treturn 0;\n       else\n-\treturn gen_rtx (REG, mode, cum->gprs + 2);\n+\treturn gen_rtx_REG (mode, cum->gprs + 2);\n     }\n \n   /* After the real arguments, expand_call calls us once again"}, {"sha": "81dad009c793a4396683e140386bd27b43e55815", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -7249,8 +7249,8 @@\n         (reg 15))]\n  \"TARGET_BACKCHAIN\"\n {\n-    rtx stack = gen_rtx (REG, Pmode, STACK_POINTER_REGNUM);\n-    rtx chain = gen_rtx (MEM, Pmode, stack);\n+    rtx stack = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n+    rtx chain = gen_rtx_MEM (Pmode, stack);\n     rtx temp = gen_reg_rtx (Pmode);\n \n     emit_move_insn (temp, chain);"}, {"sha": "369f11a3501149af5f06e201ac88e1bafffd314b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -6567,7 +6567,7 @@ epilogue_renumber (register rtx *where, int test)\n       if (REGNO (*where) >= 8 && REGNO (*where) < 24)      /* oX or lX */\n \treturn 1;\n       if (! test && REGNO (*where) >= 24 && REGNO (*where) < 32)\n-\t*where = gen_rtx (REG, GET_MODE (*where), OUTGOING_REGNO (REGNO(*where)));\n+\t*where = gen_rtx_REG (GET_MODE (*where), OUTGOING_REGNO (REGNO(*where)));\n     case SCRATCH:\n     case CC0:\n     case PC:\n@@ -7354,7 +7354,7 @@ sparc_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)\n   /* Call __enable_execute_stack after writing onto the stack to make sure\n      the stack address is accessible.  */\n #ifdef TRANSFER_FROM_TRAMPOLINE\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__enable_execute_stack\"),\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__enable_execute_stack\"),\n                      LCT_NORMAL, VOIDmode, 1, tramp, Pmode);\n #endif\n \n@@ -7395,7 +7395,7 @@ sparc64_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)\n   /* Call __enable_execute_stack after writing onto the stack to make sure\n      the stack address is accessible.  */\n #ifdef TRANSFER_FROM_TRAMPOLINE\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__enable_execute_stack\"),\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__enable_execute_stack\"),\n                      LCT_NORMAL, VOIDmode, 1, tramp, Pmode);\n #endif\n }"}, {"sha": "83cf9d13f2313151b3a67aac0d2a88ae5dc3ce93", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -615,7 +615,7 @@ print_operand (FILE * file, rtx x, int code)\n \t{\n \tcase MEM:\n \t  if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n-\t    output_address (gen_rtx_PLUS (SImode, gen_rtx (REG, SImode, 0),\n+\t    output_address (gen_rtx_PLUS (SImode, gen_rtx_REG (SImode, 0),\n \t\t\t\t\t  XEXP (x, 0)));\n \t  else\n \t    output_address (XEXP (x, 0));"}, {"sha": "cc6d1b2d4d4b3c714a94b30458e33abd980a25ea", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -908,7 +908,7 @@ typedef struct xtensa_args {\n     rtx addr = ADDR;\t\t\t\t\t\t\t\\\n     emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 12)), CHAIN); \\\n     emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 16)), FUNC); \\\n-    emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__xtensa_sync_caches\"), \\\n+    emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__xtensa_sync_caches\"), \\\n \t\t       0, VOIDmode, 1, addr, Pmode);\t\t\t\\\n   } while (0)\n \n@@ -953,7 +953,7 @@ typedef struct xtensa_args {\n    when count == 0 and the stack pointer when count > 0.  */\n \n #define DYNAMIC_CHAIN_ADDRESS(frame)\t\t\t\t\t\\\n-  gen_rtx (PLUS, Pmode, frame, GEN_INT (-3 * UNITS_PER_WORD))\n+  gen_rtx_PLUS (Pmode, frame, GEN_INT (-3 * UNITS_PER_WORD))\n \n /* Define this if the return address of a particular stack frame is\n    accessed from the frame pointer of the previous stack frame.  */\n@@ -1098,10 +1098,10 @@ typedef struct xtensa_args {\n \t    && xtensa_simm8x256 (INTVAL (plus1) & ~0xff))\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t    rtx temp = gen_reg_rtx (Pmode);\t\t\t\t\\\n-\t    emit_insn (gen_rtx (SET, Pmode, temp,\t\t\t\\\n-\t\t\t\tgen_rtx (PLUS, Pmode, plus0,\t\t\\\n+\t    emit_insn (gen_rtx_SET (Pmode, temp,\t\t\t\\\n+\t\t\t\tgen_rtx_PLUS (Pmode, plus0,\t\t\\\n \t\t\t\t\t GEN_INT (INTVAL (plus1) & ~0xff)))); \\\n-\t    (X) = gen_rtx (PLUS, Pmode, temp,\t\t\t\t\\\n+\t    (X) = gen_rtx_PLUS (Pmode, temp,\t\t\t\t\\\n \t\t\t   GEN_INT (INTVAL (plus1) & 0xff));\t\t\\\n \t    goto WIN;\t\t\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\"}, {"sha": "51da7124b4b4b61ac083df0f65368bb04843b87b", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c25d3b47cbca1052d3f6b91a915f981180307c/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=f1c25d3b47cbca1052d3f6b91a915f981180307c", "patch": "@@ -1648,7 +1648,7 @@\n \t(match_dup 1))]\n   \"\"\n {\n-  operands[1] = gen_rtx (EQ, SImode, branch_cmp[0], branch_cmp[1]);\n+  operands[1] = gen_rtx_EQ (SImode, branch_cmp[0], branch_cmp[1]);\n   if (!xtensa_expand_scc (operands))\n     FAIL;\n   DONE;\n@@ -1659,7 +1659,7 @@\n \t(match_dup 1))]\n   \"\"\n {\n-  operands[1] = gen_rtx (NE, SImode, branch_cmp[0], branch_cmp[1]);\n+  operands[1] = gen_rtx_NE (SImode, branch_cmp[0], branch_cmp[1]);\n   if (!xtensa_expand_scc (operands))\n     FAIL;\n   DONE;\n@@ -1670,7 +1670,7 @@\n \t(match_dup 1))]\n   \"\"\n {\n-  operands[1] = gen_rtx (GT, SImode, branch_cmp[0], branch_cmp[1]);\n+  operands[1] = gen_rtx_GT (SImode, branch_cmp[0], branch_cmp[1]);\n   if (!xtensa_expand_scc (operands))\n     FAIL;\n   DONE;\n@@ -1681,7 +1681,7 @@\n \t(match_dup 1))]\n   \"\"\n {\n-  operands[1] = gen_rtx (GE, SImode, branch_cmp[0], branch_cmp[1]);\n+  operands[1] = gen_rtx_GE (SImode, branch_cmp[0], branch_cmp[1]);\n   if (!xtensa_expand_scc (operands))\n     FAIL;\n   DONE;\n@@ -1692,7 +1692,7 @@\n \t(match_dup 1))]\n   \"\"\n {\n-  operands[1] = gen_rtx (LT, SImode, branch_cmp[0], branch_cmp[1]);\n+  operands[1] = gen_rtx_LT (SImode, branch_cmp[0], branch_cmp[1]);\n   if (!xtensa_expand_scc (operands))\n     FAIL;\n   DONE;\n@@ -1703,7 +1703,7 @@\n \t(match_dup 1))]\n   \"\"\n {\n-  operands[1] = gen_rtx (LE, SImode, branch_cmp[0], branch_cmp[1]);\n+  operands[1] = gen_rtx_LE (SImode, branch_cmp[0], branch_cmp[1]);\n   if (!xtensa_expand_scc (operands))\n     FAIL;\n   DONE;"}]}