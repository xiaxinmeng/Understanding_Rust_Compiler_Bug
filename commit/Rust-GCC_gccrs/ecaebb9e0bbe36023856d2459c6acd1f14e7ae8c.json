{"sha": "ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNhZWJiOWUwYmJlMzYwMjM4NTZkMjQ1OWM2YWNkMWYxNGU3YWU4Yw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2007-05-21T10:58:29Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2007-05-21T10:58:29Z"}, "message": "builtins.c (expand_builtin_setjmp_setup): Update comment.\n\n\t* builtins.c (expand_builtin_setjmp_setup): Update comment.\n\t* function.h (struct function): Move va_list_gpr_size,\n\tva_list_fpr_size, function_frequency to front of bitfields.  Add\n\tcalls_unwind_init.\n\t(current_function_calls_unwind_init): New.\n\t* except.c (expand_builtin_unwind_init): Set\n\tcurrent_function_calls_unwind_init not\n\tcurrent_function_has_nonlocal_label.\n\t* reload1.c (has_nonexceptional_receiver): New.\n\t(reload): Use it and current_function_calls_unwind_init to\n\tdetermine whether call-saved regs must be saved.\n\nFrom-SVN: r124898", "tree": {"sha": "285b968663b9075e8e13ac5ead7cb3afd6a842d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/285b968663b9075e8e13ac5ead7cb3afd6a842d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c/comments", "author": null, "committer": null, "parents": [{"sha": "2a0ab51c7944b65fd4bb5acc26d1e66c8550f283", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a0ab51c7944b65fd4bb5acc26d1e66c8550f283", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a0ab51c7944b65fd4bb5acc26d1e66c8550f283"}], "stats": {"total": 111, "additions": 93, "deletions": 18}, "files": [{"sha": "731886946dcff90175f6137cad26d7d34b855a90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c", "patch": "@@ -1,3 +1,17 @@\n+2007-05-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* builtins.c (expand_builtin_setjmp_setup): Update comment.\n+\t* function.h (struct function): Move va_list_gpr_size,\n+\tva_list_fpr_size, function_frequency to front of bitfields.  Add\n+\tcalls_unwind_init.\n+\t(current_function_calls_unwind_init): New.\n+\t* except.c (expand_builtin_unwind_init): Set\n+\tcurrent_function_calls_unwind_init not\n+\tcurrent_function_has_nonlocal_label.\n+\t* reload1.c (has_nonexceptional_receiver): New.\n+\t(reload): Use it and current_function_calls_unwind_init to\n+\tdetermine whether call-saved regs must be saved.\n+\n 2007-05-20  Jan Hubicka  <jh@suse.cz>\n \n \t* gengtype.c (adjust_field_rtx_def): Use NOTE_KIND instead of"}, {"sha": "b4f61868205ce9097607ef46c33860b22aec6fa6", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c", "patch": "@@ -696,8 +696,7 @@ expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n      need to go on during alloca.  */\n   current_function_calls_setjmp = 1;\n \n-  /* Set this so all the registers get saved in our frame; we need to be\n-     able to copy the saved values for any registers from frames we unwind.  */\n+  /* We have a nonlocal label.   */\n   current_function_has_nonlocal_label = 1;\n }\n "}, {"sha": "29a28d7154648b0dd453a8e31d0b1cb09a63a6ba", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c", "patch": "@@ -2859,7 +2859,7 @@ expand_builtin_unwind_init (void)\n {\n   /* Set this so all the registers get saved in our frame; we need to be\n      able to copy the saved values for any registers from frames we unwind.  */\n-  current_function_has_nonlocal_label = 1;\n+  current_function_calls_unwind_init = 1;\n \n #ifdef SETUP_FRAME_ADDRESSES\n   SETUP_FRAME_ADDRESSES ();"}, {"sha": "3367380eb9d244d7692088d9cfcc4ea6db9db845", "filename": "gcc/function.h", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c", "patch": "@@ -374,6 +374,19 @@ struct function GTY(())\n \n   /* Collected bit flags.  */\n \n+  /* Number of units of general registers that need saving in stdarg\n+     function.  What unit is depends on the backend, either it is number\n+     of bytes, or it can be number of registers.  */\n+  unsigned int va_list_gpr_size : 8;\n+\n+  /* Number of units of floating point registers that need saving in stdarg\n+     function.  */\n+  unsigned int va_list_fpr_size : 8;\n+\n+  /* How commonly executed the function is.  Initialized during branch\n+     probabilities pass.  */\n+  ENUM_BITFIELD (function_frequency) function_frequency : 2;\n+\n   /* Nonzero if function being compiled needs to be given an address\n      where the value should be stored.  */\n   unsigned int returns_struct : 1;\n@@ -403,6 +416,9 @@ struct function GTY(())\n      from nested functions.  */\n   unsigned int has_nonlocal_label : 1;\n \n+  /* Nonzero if function calls builtin_unwind_init.  */\n+  unsigned int calls_unwind_init : 1;\n+  \n   /* Nonzero if function being compiled has nonlocal gotos to parent\n      function.  */\n   unsigned int has_nonlocal_goto : 1;\n@@ -459,19 +475,6 @@ struct function GTY(())\n   /* Set when the tail call has been produced.  */\n   unsigned int tail_call_emit : 1;\n \n-  /* How commonly executed the function is.  Initialized during branch\n-     probabilities pass.  */\n-  ENUM_BITFIELD (function_frequency) function_frequency : 2;\n-\n-  /* Number of units of general registers that need saving in stdarg\n-     function.  What unit is depends on the backend, either it is number\n-     of bytes, or it can be number of registers.  */\n-  unsigned int va_list_gpr_size : 8;\n-\n-  /* Number of units of floating point registers that need saving in stdarg\n-     function.  */\n-  unsigned int va_list_fpr_size : 8;\n-\n   /* FIXME tuples: This bit is temporarily here to mark when a\n      function has been gimplified, so we can make sure we're not\n      creating non GIMPLE tuples after gimplification.  */\n@@ -520,6 +523,7 @@ extern int trampolines_created;\n #define current_function_uses_const_pool (cfun->uses_const_pool)\n #define current_function_epilogue_delay_list (cfun->epilogue_delay_list)\n #define current_function_has_nonlocal_label (cfun->has_nonlocal_label)\n+#define current_function_calls_unwind_init (cfun->calls_unwind_init)\n #define current_function_has_nonlocal_goto (cfun->has_nonlocal_goto)\n \n #define return_label (cfun->x_return_label)"}, {"sha": "dd79b0bcbf248fc856ab106ecd9c84f3266e628d", "filename": "gcc/reload1.c", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ecaebb9e0bbe36023856d2459c6acd1f14e7ae8c", "patch": "@@ -622,6 +622,61 @@ replace_pseudos_in (rtx *loc, enum machine_mode mem_mode, rtx usage)\n \treplace_pseudos_in (& XVECEXP (x, i, j), mem_mode, usage);\n }\n \n+/* Determine if the current function has an exception receiver block\n+   that reaches the exit block via non-exceptional edges  */\n+\n+static bool\n+has_nonexceptional_receiver (void)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  basic_block *tos, *worklist, bb;\n+\n+  /* If we're not optimizing, then just err on the safe side.  */\n+  if (!optimize)\n+    return true;\n+  \n+  /* First determine which blocks can reach exit via normal paths.  */\n+  tos = worklist = xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n+\n+  FOR_EACH_BB (bb)\n+    bb->flags &= ~BB_REACHABLE;\n+\n+  /* Place the exit block on our worklist.  */\n+  EXIT_BLOCK_PTR->flags |= BB_REACHABLE;\n+  *tos++ = EXIT_BLOCK_PTR;\n+  \n+  /* Iterate: find everything reachable from what we've already seen.  */\n+  while (tos != worklist)\n+    {\n+      bb = *--tos;\n+\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (!(e->flags & EDGE_ABNORMAL))\n+\t  {\n+\t    basic_block src = e->src;\n+\n+\t    if (!(src->flags & BB_REACHABLE))\n+\t      {\n+\t\tsrc->flags |= BB_REACHABLE;\n+\t\t*tos++ = src;\n+\t      }\n+\t  }\n+    }\n+  free (worklist);\n+\n+  /* Now see if there's a reachable block with an exceptional incoming\n+     edge.  */\n+  FOR_EACH_BB (bb)\n+    if (bb->flags & BB_REACHABLE)\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (e->flags & EDGE_ABNORMAL)\n+\t  return true;\n+\n+  /* No exceptional block reached exit unexceptionally.  */\n+  return false;\n+}\n+\n \f\n /* Global variables used by reload and its subroutines.  */\n \n@@ -688,9 +743,12 @@ reload (rtx first, int global)\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     mark_home_live (i);\n \n-  /* A function that receives a nonlocal goto must save all call-saved\n+  /* A function that has a nonlocal label that can reach the exit\n+     block via non-exceptional paths must save all call-saved\n      registers.  */\n-  if (current_function_has_nonlocal_label)\n+  if (current_function_calls_unwind_init\n+      || (current_function_has_nonlocal_label\n+\t  && has_nonexceptional_receiver ()))\n     for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n       if (! call_used_regs[i] && ! fixed_regs[i] && ! LOCAL_REGNO (i))\n \tregs_ever_live[i] = 1;"}]}