{"sha": "336a6399a9ab84ac787c525ec2a2a469b8b488d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM2YTYzOTlhOWFiODRhYzc4N2M1MjVlYzJhMmE0NjliOGI0ODhkNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-21T21:15:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-21T21:15:37Z"}, "message": "basic-block.h (basic_block): Add eh_beg, eh_end.\n\n        * basic-block.h (basic_block): Add eh_beg, eh_end.\n        * flow.c (entry_exit_blocks): Update.\n        (find_basic_blocks): Don't allocate bb_eh_end, or pass it around.\n        Call new functions.\n        (find_basic_blocks_1): Don't record eh_list at each bb.  Use\n        lists.c functions to allocate insn lists.\n        (make_edges): Use eh_beg+eh_end, not the lists.  Split out EH\n        edge creation ...\n        (make_eh_edge): ... here.  New.\n        (move_stray_eh_region_notes): New.\n        (record_active_eh_regions): New.\n        (delete_unreachable_blocks): Split out block merging ...\n        (try_merge_blocks): ... here.  New.\n        (merge_blocks_move_predecessor_nojumps): Remove edge arg.\n        Dump debugging data.\n        (merge_blocks_move_successor_nojumps): Likewise.\n        (merge_blocks): Use eh_beg+eh_end to validate block movement.\n\nFrom-SVN: r29565", "tree": {"sha": "5f84bcf24f6d398455afd08aec40a0b90bdab8c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f84bcf24f6d398455afd08aec40a0b90bdab8c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/336a6399a9ab84ac787c525ec2a2a469b8b488d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/336a6399a9ab84ac787c525ec2a2a469b8b488d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/336a6399a9ab84ac787c525ec2a2a469b8b488d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/336a6399a9ab84ac787c525ec2a2a469b8b488d5/comments", "author": null, "committer": null, "parents": [{"sha": "9f14fb64049bc3598da0624b59c74a89abdee09d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f14fb64049bc3598da0624b59c74a89abdee09d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f14fb64049bc3598da0624b59c74a89abdee09d"}], "stats": {"total": 439, "additions": 300, "deletions": 139}, "files": [{"sha": "b1034766903f3069d0cc8eaaadbdacff96da9e95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/336a6399a9ab84ac787c525ec2a2a469b8b488d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/336a6399a9ab84ac787c525ec2a2a469b8b488d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=336a6399a9ab84ac787c525ec2a2a469b8b488d5", "patch": "@@ -1,3 +1,23 @@\n+Tue Sep 21 14:14:50 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* basic-block.h (basic_block): Add eh_beg, eh_end.\n+\t* flow.c (entry_exit_blocks): Update.\n+\t(find_basic_blocks): Don't allocate bb_eh_end, or pass it around.\n+\tCall new functions.\n+\t(find_basic_blocks_1): Don't record eh_list at each bb.  Use\n+\tlists.c functions to allocate insn lists.\n+\t(make_edges): Use eh_beg+eh_end, not the lists.  Split out EH\n+\tedge creation ...\n+\t(make_eh_edge): ... here.  New.\n+\t(move_stray_eh_region_notes): New.\n+\t(record_active_eh_regions): New.\n+\t(delete_unreachable_blocks): Split out block merging ...\n+\t(try_merge_blocks): ... here.  New.\n+\t(merge_blocks_move_predecessor_nojumps): Remove edge arg.\n+\tDump debugging data.\n+\t(merge_blocks_move_successor_nojumps): Likewise.\n+\t(merge_blocks): Use eh_beg+eh_end to validate block movement.\n+\n Tue Sep 21 11:15:03 1999  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* extend.texi (Bound member functions): Document unbound pmf"}, {"sha": "13f8c47e080c9f9d4f4c8b0a18fa3031ee4a3bf3", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/336a6399a9ab84ac787c525ec2a2a469b8b488d5/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/336a6399a9ab84ac787c525ec2a2a469b8b488d5/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=336a6399a9ab84ac787c525ec2a2a469b8b488d5", "patch": "@@ -144,6 +144,9 @@ typedef struct basic_block_def {\n   int index;\n   /* The loop depth of this block plus one.  */\n   int loop_depth;\n+\n+  /* The active eh region before head and after end.  */\n+  int eh_beg, eh_end;\n } *basic_block;\n \n /* Number of basic blocks in the current function.  */"}, {"sha": "b4970e3eb4b38c63686c381e8c7be62fcb7d95c1", "filename": "gcc/flow.c", "status": "modified", "additions": 277, "deletions": 139, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/336a6399a9ab84ac787c525ec2a2a469b8b488d5/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/336a6399a9ab84ac787c525ec2a2a469b8b488d5/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=336a6399a9ab84ac787c525ec2a2a469b8b488d5", "patch": "@@ -178,7 +178,8 @@ struct basic_block_def entry_exit_blocks[2] =\n     NULL,\t\t\t/* global_live_at_end */\n     NULL,\t\t\t/* aux */\n     ENTRY_BLOCK,\t\t/* index */\n-    0\t\t\t\t/* loop_depth */\n+    0,\t\t\t\t/* loop_depth */\n+    -1, -1\t\t\t/* eh_beg, eh_end */\n   },\n   {\n     NULL,\t\t\t/* head */\n@@ -190,7 +191,8 @@ struct basic_block_def entry_exit_blocks[2] =\n     NULL,\t\t\t/* global_live_at_end */\n     NULL,\t\t\t/* aux */\n     EXIT_BLOCK,\t\t\t/* index */\n-    0\t\t\t\t/* loop_depth */\n+    0,\t\t\t\t/* loop_depth */\n+    -1, -1\t\t\t/* eh_beg, eh_end */\n   }\n };\n \n@@ -274,13 +276,17 @@ static bitmap uid_volatile;\n \n /* Forward declarations */\n static int count_basic_blocks\t\tPROTO((rtx));\n-static rtx find_basic_blocks_1\t\tPROTO((rtx, rtx*));\n+static rtx find_basic_blocks_1\t\tPROTO((rtx));\n static void create_basic_block\t\tPROTO((int, rtx, rtx, rtx));\n static void clear_edges\t\t\tPROTO((void));\n-static void make_edges\t\t\tPROTO((rtx, rtx*));\n+static void make_edges\t\t\tPROTO((rtx));\n static void make_edge\t\t\tPROTO((basic_block, basic_block, int));\n static void make_label_edge\t\tPROTO((basic_block, rtx, int));\n+static void make_eh_edge\t\tPROTO((eh_nesting_info *, basic_block,\n+\t\t\t\t\t       rtx, int));\n static void mark_critical_edges\t\tPROTO((void));\n+static void move_stray_eh_region_notes\tPROTO((void));\n+static void record_active_eh_regions\tPROTO((rtx));\n \n static void commit_one_edge_insertion\tPROTO((edge));\n \n@@ -292,8 +298,13 @@ static int delete_block\t\t\tPROTO((basic_block));\n static void expunge_block\t\tPROTO((basic_block));\n static rtx flow_delete_insn\t\tPROTO((rtx));\n static int can_delete_label_p\t\tPROTO((rtx));\n+static int merge_blocks_move_predecessor_nojumps PROTO((basic_block,\n+\t\t\t\t\t\t\tbasic_block));\n+static int merge_blocks_move_successor_nojumps PROTO((basic_block,\n+\t\t\t\t\t\t      basic_block));\n static void merge_blocks_nomove\t\tPROTO((basic_block, basic_block));\n static int merge_blocks\t\t\tPROTO((edge,basic_block,basic_block));\n+static void try_merge_blocks\t\tPROTO((void));\n static void tidy_fallthru_edge\t\tPROTO((edge,basic_block,basic_block));\n static void calculate_loop_depth\tPROTO((rtx));\n \n@@ -354,7 +365,6 @@ find_basic_blocks (f, nregs, file, do_cleanup)\n      FILE *file ATTRIBUTE_UNUSED;\n      int do_cleanup;\n {\n-  rtx *bb_eh_end;\n   int max_uid;\n \n   /* Flush out existing data.  */\n@@ -385,11 +395,7 @@ find_basic_blocks (f, nregs, file, do_cleanup)\n \n   VARRAY_BB_INIT (basic_block_info, n_basic_blocks, \"basic_block_info\");\n \n-  /* An array to record the active exception region at the end of each\n-     basic block.  It is filled in by find_basic_blocks_1 for make_edges.  */\n-  bb_eh_end = (rtx *) alloca (n_basic_blocks * sizeof (rtx));\n-\n-  label_value_list = find_basic_blocks_1 (f, bb_eh_end);\n+  label_value_list = find_basic_blocks_1 (f);\n   \n   /* Record the block to which an insn belongs.  */\n   /* ??? This should be done another way, by which (perhaps) a label is\n@@ -407,12 +413,18 @@ find_basic_blocks (f, nregs, file, do_cleanup)\n \n   /* Discover the edges of our cfg.  */\n \n-  make_edges (label_value_list, bb_eh_end);\n+  record_active_eh_regions (f);\n+  make_edges (label_value_list);\n \n-  /* Delete unreachable blocks.  */\n+  /* Delete unreachable blocks, then merge blocks when possible.  */\n \n   if (do_cleanup)\n-    delete_unreachable_blocks ();\n+    {\n+      delete_unreachable_blocks ();\n+      move_stray_eh_region_notes ();\n+      record_active_eh_regions (f);\n+      try_merge_blocks ();\n+    }\n \n   /* Mark critical edges.  */\n \n@@ -513,20 +525,13 @@ count_basic_blocks (f)\n }\n \n /* Find all basic blocks of the function whose first insn is F.\n-   Store the correct data in the tables that describe the basic blocks,\n-   set up the chains of references for each CODE_LABEL, and\n-   delete any entire basic blocks that cannot be reached.\n-\n-   NONLOCAL_LABEL_LIST is a list of non-local labels in the function.  Blocks\n-   that are otherwise unreachable may be reachable with a non-local goto.\n \n-   BB_EH_END is an array in which we record the list of exception regions\n-   active at the end of every basic block.  */\n+   Collect and return a list of labels whose addresses are taken.  This\n+   will be used in make_edges for use with computed gotos.  */\n \n static rtx\n-find_basic_blocks_1 (f, bb_eh_end)\n+find_basic_blocks_1 (f)\n      rtx f;\n-     rtx *bb_eh_end;\n {\n   register rtx insn, next;\n   int call_has_abnormal_edge = 0;\n@@ -541,7 +546,7 @@ find_basic_blocks_1 (f, bb_eh_end)\n      previously.  This is so that we see a NOTE_BASIC_BLOCK after we have\n      closed out the previous block, so that it gets attached at the proper\n      place.  Since this form should be equivalent to the previous,\n-     find_basic_blocks_0 continues to use the old form as a check.  */\n+     count_basic_blocks continues to use the old form as a check.  */\n \n   for (insn = f; insn; insn = next)\n     {\n@@ -577,9 +582,13 @@ find_basic_blocks_1 (f, bb_eh_end)\n \n \t    /* Keep a LIFO list of the currently active exception notes.  */\n \t    if (kind == NOTE_INSN_EH_REGION_BEG)\n-\t      eh_list = gen_rtx_INSN_LIST (VOIDmode, insn, eh_list);\n+\t      eh_list = alloc_INSN_LIST (insn, eh_list);\n \t    else if (kind == NOTE_INSN_EH_REGION_END)\n-\t      eh_list = XEXP (eh_list, 1);\n+\t      {\n+\t\trtx t = eh_list;\n+\t\teh_list = XEXP (eh_list, 1);\n+\t\tfree_INSN_LIST_node (t);\n+\t      }\n \n \t    /* Look for basic block notes with which to keep the \n \t       basic_block_info pointers stable.  Unthread the note now;\n@@ -611,7 +620,6 @@ find_basic_blocks_1 (f, bb_eh_end)\n \t\t  end = emit_insn_after (nop, end);\n \t\t}\n \n-\t      bb_eh_end[i] = eh_list;\n \t      create_basic_block (i++, head, end, bb_note);\n \t      bb_note = NULL_RTX;\n \t    }\n@@ -676,7 +684,6 @@ find_basic_blocks_1 (f, bb_eh_end)\n \t      end = insn;\n \n \t    new_bb_exclusive:\n-\t      bb_eh_end[i] = eh_list;\n \t      create_basic_block (i++, head, end, bb_note);\n \t      head = end = NULL_RTX;\n \t      bb_note = NULL_RTX;\n@@ -728,10 +735,7 @@ find_basic_blocks_1 (f, bb_eh_end)\n     }\n \n   if (head != NULL_RTX)\n-    {\n-      bb_eh_end[i] = eh_list;\n-      create_basic_block (i++, head, end, bb_note);\n-    }\n+    create_basic_block (i++, head, end, bb_note);\n \n   if (i != n_basic_blocks)\n     abort ();\n@@ -870,9 +874,8 @@ clear_edges ()\n    the list of exception regions active at the end of the basic block.  */\n \n static void\n-make_edges (label_value_list, bb_eh_end)\n+make_edges (label_value_list)\n      rtx label_value_list;\n-     rtx *bb_eh_end;\n {\n   int i;\n   eh_nesting_info *eh_nest_info = init_eh_nesting_info ();\n@@ -886,26 +889,11 @@ make_edges (label_value_list, bb_eh_end)\n   for (i = 0; i < n_basic_blocks; ++i)\n     {\n       basic_block bb = BASIC_BLOCK (i);\n-      rtx insn, x, eh_list;\n+      rtx insn, x;\n       enum rtx_code code;\n       int force_fallthru = 0;\n \n-      /* If we have asynchronous exceptions, scan the notes for all exception\n-\t regions active in the block.  In the normal case, we only need the\n-\t one active at the end of the block, which is bb_eh_end[i].  */\n-\n-      eh_list = bb_eh_end[i];\n-      if (asynchronous_exceptions)\n-\t{\n-\t  for (insn = bb->end; insn != bb->head; insn = PREV_INSN (insn))\n-\t    {\n-\t      if (GET_CODE (insn) == NOTE\n-\t\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n-\t\teh_list = gen_rtx_INSN_LIST (VOIDmode, insn, eh_list);\n-\t    }\n-\t}\n-\n-      /* Now examine the last instruction of the block, and discover the\n+      /* Examine the last instruction of the block, and discover the\n \t ways we can leave the block.  */\n \n       insn = bb->end;\n@@ -984,20 +972,27 @@ make_edges (label_value_list, bb_eh_end)\n \n       if (code == CALL_INSN || asynchronous_exceptions)\n \t{\n-\t  int is_call = (code == CALL_INSN ? EDGE_ABNORMAL_CALL : 0);\n-\t  handler_info **handler_list;\n-\t  int eh_region = -1;\n-\t  int num;\n-\n-\t  if (eh_list)\n-\t    eh_region = NOTE_EH_HANDLER (XEXP (eh_list, 0));\n-\n-\t  num = reachable_handlers (eh_region, eh_nest_info,\n-\t\t\t\t    insn, &handler_list);\n-\t  for ( ; num > 0; num--)\n+\t  /* If there's an EH region active at the end of a block,\n+\t     add the appropriate edges.  */\n+\t  if (bb->eh_end >= 0)\n+\t    make_eh_edge (eh_nest_info, bb, insn, bb->eh_end);\n+\n+\t  /* If we have asynchronous exceptions, do the same for *all*\n+\t     exception regions active in the block.  */\n+\t  if (asynchronous_exceptions\n+\t      && bb->eh_beg != bb->eh_end)\n \t    {\n-\t      make_label_edge (bb, handler_list[num - 1]->handler_label,\n-\t\t\t       EDGE_ABNORMAL | EDGE_EH | is_call);\n+\t      if (bb->eh_beg >= 0)\n+\t\tmake_eh_edge (eh_nest_info, bb, NULL_RTX, bb->eh_beg);\n+\n+\t      for (x = bb->head; x != bb->end; x = PREV_INSN (x))\n+\t\tif (GET_CODE (x) == NOTE\n+\t\t    && (NOTE_LINE_NUMBER (x) == NOTE_INSN_EH_REGION_BEG\n+\t\t        || NOTE_LINE_NUMBER (x) == NOTE_INSN_EH_REGION_END))\n+\t\t  {\n+\t\t    int region = NOTE_EH_HANDLER (x);\n+\t\t    make_eh_edge (eh_nest_info, bb, NULL_RTX, region);\n+\t\t  }\n \t    }\n \n \t  if (code == CALL_INSN && nonlocal_goto_handler_labels)\n@@ -1096,7 +1091,119 @@ make_label_edge (src, label, flags)\n   make_edge (src, BLOCK_FOR_INSN (label), flags);\n }\n \n+/* Create the edges generated by INSN in REGION.  */\n+\n+static void\n+make_eh_edge (eh_nest_info, src, insn, region)\n+     eh_nesting_info *eh_nest_info;\n+     basic_block src;\n+     rtx insn;\n+     int region;\n+{\n+  handler_info **handler_list;\n+  int num, is_call;\n+\n+  is_call = (insn && GET_CODE (insn) == CALL_INSN ? EDGE_ABNORMAL_CALL : 0);\n+  num = reachable_handlers (region, eh_nest_info, insn, &handler_list);\n+  while (--num >= 0)\n+    {\n+      make_label_edge (src, handler_list[num]->handler_label,\n+\t\t       EDGE_ABNORMAL | EDGE_EH | is_call);\n+    }\n+}\n+\n+/* EH_REGION notes appearing between basic blocks is ambiguous, and even\n+   dangerous if we intend to move basic blocks around.  Move such notes\n+   into the following block.  */\n+\n+static void\n+move_stray_eh_region_notes ()\n+{\n+  int i;\n+  basic_block b1, b2;\n+\n+  if (n_basic_blocks < 2)\n+    return;\n+\n+  b2 = BASIC_BLOCK (n_basic_blocks - 1);\n+  for (i = n_basic_blocks - 2; i >= 0; --i, b2 = b1)\n+    {\n+      rtx insn, next, list = NULL_RTX;\n+\n+      b1 = BASIC_BLOCK (i);\n+      for (insn = NEXT_INSN (b1->end); insn != b2->head; insn = next)\n+\t{\n+\t  next = NEXT_INSN (insn);\n+\t  if (GET_CODE (insn) == NOTE\n+\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n+\t          || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END))\n+\t    {\n+\t      /* Unlink from the insn chain.  */\n+\t      NEXT_INSN (PREV_INSN (insn)) = next;\n+\t      PREV_INSN (next) = PREV_INSN (insn);\n+\n+\t      /* Queue it.  */\n+\t      NEXT_INSN (insn) = list;\n+\t      list = insn;\n+\t    }\n+\t}\n+\n+      if (list == NULL_RTX)\n+\tcontinue;\n+\n+      /* Find where to insert these things.  */\n+      insn = b2->head;\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\tinsn = NEXT_INSN (insn);\n+\n+      while (list)\n+\t{\n+\t  next = NEXT_INSN (list);\n+\t  add_insn_after (list, insn);\n+\t  list = next;\n+\t}\n+    }\n+}\n+\n+/* Recompute eh_beg/eh_end for each basic block.  */\n+\n+static void\n+record_active_eh_regions (f)\n+     rtx f;\n+{\n+  rtx insn, eh_list = NULL_RTX;\n+  int i = 0;\n+  basic_block bb = BASIC_BLOCK (0);\n+\n+  for (insn = f; insn ; insn = NEXT_INSN (insn))\n+    {\n+      if (bb->head == insn)\n+\tbb->eh_beg = (eh_list ? NOTE_EH_HANDLER (XEXP (eh_list, 0)) : -1);\n+\n+      if (GET_CODE (insn) == NOTE)\n+\t{\n+\t  int kind = NOTE_LINE_NUMBER (insn);\n+\t  if (kind == NOTE_INSN_EH_REGION_BEG)\n+\t    eh_list = alloc_INSN_LIST (insn, eh_list);\n+\t  else if (kind == NOTE_INSN_EH_REGION_END)\n+\t    {\n+\t      rtx t = XEXP (eh_list, 1);\n+\t      free_INSN_LIST_node (eh_list);\n+\t      eh_list = t;\n+\t    }\n+\t}\n+\n+      if (bb->end == insn)\n+\t{\n+\t  bb->eh_end = (eh_list ? NOTE_EH_HANDLER (XEXP (eh_list, 0)) : -1);\n+\t  i += 1;\n+\t  bb = BASIC_BLOCK (i);\n+\t}\n+    }\n+}\n+\n /* Identify critical edges and set the bits appropriately.  */\n+\n static void\n mark_critical_edges ()\n {\n@@ -1575,31 +1682,6 @@ delete_unreachable_blocks ()\n \ttidy_fallthru_edge (s, b, c);\n     }\n \n-  /* Attempt to merge blocks as made possible by edge removal.  If a block\n-     has only one successor, and the successor has only one predecessor, \n-     they may be combined.  */\n-\n-  for (i = 0; i < n_basic_blocks; )\n-    {\n-      basic_block c, b = BASIC_BLOCK (i);\n-      edge s;\n-\n-      /* A loop because chains of blocks might be combineable.  */\n-      while ((s = b->succ) != NULL\n-\t     && s->succ_next == NULL\n-\t     && (s->flags & EDGE_EH) == 0\n-\t     && (c = s->dest) != EXIT_BLOCK_PTR\n-\t     && c->pred->pred_next == NULL\n-\t     /* If the jump insn has side effects, we can't kill the edge.  */\n-\t     && (GET_CODE (b->end) != JUMP_INSN\n-\t\t || onlyjump_p (b->end))\n-\t     && merge_blocks (s, b, c))\n-\tcontinue;\n-\n-      /* Don't get confused by the index shift caused by deleting blocks.  */\n-      i = b->index + 1;\n-    }\n-\n   /* If we deleted an exception handler, we may have EH region begin/end\n      blocks to remove as well. */\n   if (deleted_handler)\n@@ -1858,8 +1940,7 @@ can_delete_label_p (label)\n    any jumps (aside from the jump from A to B).  */\n \n static int\n-merge_blocks_move_predecessor_nojumps (e, a, b)\n-     edge e;\n+merge_blocks_move_predecessor_nojumps (a, b)\n      basic_block a, b;\n {\n   rtx start, end, insertpoint, barrier;\n@@ -1896,6 +1977,13 @@ merge_blocks_move_predecessor_nojumps (e, a, b)\n \n   /* Now blocks A and B are contiguous.  Merge them.  */\n   merge_blocks_nomove (a, b);\n+\n+  if (rtl_dump_file)\n+    {\n+      fprintf (rtl_dump_file, \"Moved block %d before %d and merged.\\n\",\n+\t       a->index, b->index);\n+    }\n+\n   return 1;\n }\n \n@@ -1904,8 +1992,7 @@ merge_blocks_move_predecessor_nojumps (e, a, b)\n    any jumps (aside from the jump from A to B).  */\n \n static int\n-merge_blocks_move_successor_nojumps (e, a, b)\n-     edge e;\n+merge_blocks_move_successor_nojumps (a, b)\n      basic_block a, b;\n {\n   rtx start, end, insertpoint, barrier;\n@@ -1942,6 +2029,13 @@ merge_blocks_move_successor_nojumps (e, a, b)\n \n   /* Now blocks A and B are contiguous.  Merge them.  */\n   merge_blocks_nomove (a, b);\n+\n+  if (rtl_dump_file)\n+    {\n+      fprintf (rtl_dump_file, \"Moved block %d after %d and merged.\\n\",\n+\t       b->index, a->index);\n+    }\n+\n   return 1;\n }\n \n@@ -2042,35 +2136,46 @@ merge_blocks (e, b, c)\n      basic_block b, c;\n {\n   /* If B has a fallthru edge to C, no need to move anything.  */\n-  if (!(e->flags & EDGE_FALLTHRU))\n+  if (e->flags & EDGE_FALLTHRU)\n     {\n-      edge tmp_edge;\n-      int c_has_outgoing_fallthru;\n-      int b_has_incoming_fallthru;\n-\n-      /* ??? From here on out we must make sure to not munge nesting\n-\t of exception regions and lexical blocks.\n+      /* If a label still appears somewhere and we cannot delete the label,\n+\t then we cannot merge the blocks.  The edge was tidied already.  */\n \n-\t A few notes on the subject:\n+      rtx insn, stop = NEXT_INSN (c->head);\n+      for (insn = NEXT_INSN (b->end); insn != stop; insn = NEXT_INSN (insn))\n+\tif (GET_CODE (insn) == CODE_LABEL && !can_delete_label_p (insn))\n+\t  return 0;\n \n-\t  Not only do we have to be careful not to lose the nesting of\n-\t  exception regions or lexical blocks, we also have to be careful\n-\t  about merging blocks which are in different EH regions.\n+      merge_blocks_nomove (b, c);\n \n-\t  A call that throws may end a block.  The insn to copy the return\n-\t  value from its hard reg into a pseudo could end up in a\n-\t  different block than the call.  Moving either block might cause\n-\t  problems for SMALL_REGISTER_CLASS machines.\n+      if (rtl_dump_file)\n+\t{\n+\t  fprintf (rtl_dump_file, \"Merged %d and %d without moving.\\n\",\n+\t\t   b->index, c->index);\n+\t}\n \n-\t  A throw/catch edge (or any abnormal edge) should be rarely\n-\t  executed and we may want to treat blocks which have two out\n-\t  edges, one normal, one abnormal as only having one edge for\n-\t  block merging purposes.\n+      return 1;\n+    }\n+  else\n+    {\n+      edge tmp_edge;\n+      basic_block d;\n+      int c_has_outgoing_fallthru;\n+      int b_has_incoming_fallthru;\n \n-\t  For now we avoid the EH issues by not allowing any physical\n-\t  block movement when exception handling is enabled.  */\n-      if (flag_exceptions)\n-\treturn 0;\n+      /* We must make sure to not munge nesting of exception regions,\n+\t lexical blocks, and loop notes.\n+  \n+\t The first is taken care of by requiring that the active eh\n+\t region at the end of one block always matches the active eh\n+\t region at the beginning of the next block.\n+  \n+\t The later two are taken care of by squeezing out all the notes.  */\n+  \n+      /* ???  A throw/catch edge (or any abnormal edge) should be rarely\n+\t executed and we may want to treat blocks which have two out\n+\t edges, one normal, one abnormal as only having one edge for\n+\t block merging purposes.  */\n \n       for (tmp_edge = c->succ; tmp_edge ; tmp_edge = tmp_edge->succ_next)\n \tif (tmp_edge->flags & EDGE_FALLTHRU)\n@@ -2082,33 +2187,66 @@ merge_blocks (e, b, c)\n \t  break;\n       b_has_incoming_fallthru = (tmp_edge != NULL);\n \n-      /* If B does not have an incoming fallthru, then it can be moved\n-\t immediately before C without introducing or modifying jumps.\n-\n-\t Else if C does not have an outgoing fallthru, then it can be moved\n-\t immediately after B without introducing or modifying jumps.\n+      /* If B does not have an incoming fallthru, and the exception regions\n+\t match, then it can be moved immediately before C without introducing\n+\t or modifying jumps.  */\n+      d = BASIC_BLOCK (c->index - 1);\n+      if (! b_has_incoming_fallthru\n+\t  && d->eh_end == b->eh_beg\n+\t  && b->eh_end == c->eh_beg)\n+\treturn merge_blocks_move_predecessor_nojumps (b, c);\n+\n+      /* Otherwise, we're going to try to move C after B.  Make sure the\n+\t exception regions match.  */\n+      d = BASIC_BLOCK (b->index + 1);\n+      if (b->eh_end == c->eh_beg\n+\t  && c->eh_end == d->eh_beg)\n+\t{\n+\t  /* If C does not have an outgoing fallthru, then it can be moved\n+\t     immediately after B without introducing or modifying jumps.  */\n+\t  if (! c_has_outgoing_fallthru)\n+\t    return merge_blocks_move_successor_nojumps (b, c);\n+\n+\t  /* Otherwise, we'll need to insert an extra jump, and possibly\n+\t     a new block to contain it.  */\n+\t  /* ??? Not implemented yet.  */\n+\t}\n \n-\t Else move C after B, which will likely require insertion of a\n-\t new jump.  ??? Not implemented yet.  */\n-      if (! b_has_incoming_fallthru)\n-\treturn merge_blocks_move_predecessor_nojumps (e, b, c);\n-      else if (! c_has_outgoing_fallthru)\n-\treturn merge_blocks_move_successor_nojumps (e, b, c);\n-      else\n-\treturn 0;\n+      return 0;\n     }\n+}\n \n-  /* If a label still appears somewhere and we cannot delete the label,\n-     then we cannot merge the blocks.  The edge was tidied already.  */\n-  {\n-    rtx insn, stop = NEXT_INSN (c->head);\n-    for (insn = NEXT_INSN (b->end); insn != stop; insn = NEXT_INSN (insn))\n-      if (GET_CODE (insn) == CODE_LABEL && !can_delete_label_p (insn))\n-\treturn 0;\n-  }\n+/* Top level driver for merge_blocks.  */\n \n-  merge_blocks_nomove (b, c);\n-  return 1;\n+static void\n+try_merge_blocks ()\n+{\n+  int i;\n+\n+  /* Attempt to merge blocks as made possible by edge removal.  If a block\n+     has only one successor, and the successor has only one predecessor, \n+     they may be combined.  */\n+\n+  for (i = 0; i < n_basic_blocks; )\n+    {\n+      basic_block c, b = BASIC_BLOCK (i);\n+      edge s;\n+\n+      /* A loop because chains of blocks might be combineable.  */\n+      while ((s = b->succ) != NULL\n+\t     && s->succ_next == NULL\n+\t     && (s->flags & EDGE_EH) == 0\n+\t     && (c = s->dest) != EXIT_BLOCK_PTR\n+\t     && c->pred->pred_next == NULL\n+\t     /* If the jump insn has side effects, we can't kill the edge.  */\n+\t     && (GET_CODE (b->end) != JUMP_INSN\n+\t\t || onlyjump_p (b->end))\n+\t     && merge_blocks (s, b, c))\n+\tcontinue;\n+\n+      /* Don't get confused by the index shift caused by deleting blocks.  */\n+      i = b->index + 1;\n+    }\n }\n \n /* The given edge should potentially a fallthru edge.  If that is in"}]}