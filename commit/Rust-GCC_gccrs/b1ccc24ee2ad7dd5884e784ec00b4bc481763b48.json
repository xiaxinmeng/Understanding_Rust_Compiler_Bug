{"sha": "b1ccc24ee2ad7dd5884e784ec00b4bc481763b48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFjY2MyNGVlMmFkN2RkNTg4NGU3ODRlYzAwYjRiYzQ4MTc2M2I0OA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-04-14T05:16:59Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-04-14T05:16:59Z"}, "message": "re PR fortran/43747 (ICE in find_array_section, at fortran/expr.c:1551)\n\n2010-04-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/43747\n\t* constructor.c: Fix typo in comment.\n\t* expr.c (find_array_section): Add check for max array limit.\n\nFrom-SVN: r158290", "tree": {"sha": "7cc2b3d107c314cb4cd6d86f8625a64d129600d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7cc2b3d107c314cb4cd6d86f8625a64d129600d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1ccc24ee2ad7dd5884e784ec00b4bc481763b48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1ccc24ee2ad7dd5884e784ec00b4bc481763b48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1ccc24ee2ad7dd5884e784ec00b4bc481763b48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1ccc24ee2ad7dd5884e784ec00b4bc481763b48/comments", "author": null, "committer": null, "parents": [{"sha": "f89e2a3c2cfc7f07f59d398cb4ace7f339e081ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f89e2a3c2cfc7f07f59d398cb4ace7f339e081ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f89e2a3c2cfc7f07f59d398cb4ace7f339e081ce"}], "stats": {"total": 22, "additions": 20, "deletions": 2}, "files": [{"sha": "7e0d91aa5d80eac868d9e9be4444c9b50f060a77", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1ccc24ee2ad7dd5884e784ec00b4bc481763b48/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1ccc24ee2ad7dd5884e784ec00b4bc481763b48/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b1ccc24ee2ad7dd5884e784ec00b4bc481763b48", "patch": "@@ -1,3 +1,9 @@\n+2010-04-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/43747\n+\t* constructor.c: Fix typo in comment.\n+\t* expr.c (find_array_section): Add check for max array limit.\n+\n 2010-04-13  Iain Sandoe  <iains@gcc.gnu.org>\n \n \tPR bootstrap/31400"}, {"sha": "12bbdc4a5cbc2d42084dac2e6a9c386bdb3f70d0", "filename": "gcc/fortran/constructor.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1ccc24ee2ad7dd5884e784ec00b4bc481763b48/gcc%2Ffortran%2Fconstructor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1ccc24ee2ad7dd5884e784ec00b4bc481763b48/gcc%2Ffortran%2Fconstructor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconstructor.c?ref=b1ccc24ee2ad7dd5884e784ec00b4bc481763b48", "patch": "@@ -182,7 +182,7 @@ gfc_constructor_lookup (gfc_constructor_base base, int offset)\n   if (node)\n     return (gfc_constructor*) node->value;\n \n-  /* Check if the previous node as a repeat count big enough to\n+  /* Check if the previous node has a repeat count big enough to\n      cover the offset looked for.  */\n   node = splay_tree_predecessor (base, offset);\n   if (!node)"}, {"sha": "92454f6536f0999bcdbb0aba41b215accec4bcc6", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1ccc24ee2ad7dd5884e784ec00b4bc481763b48/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1ccc24ee2ad7dd5884e784ec00b4bc481763b48/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=b1ccc24ee2ad7dd5884e784ec00b4bc481763b48", "patch": "@@ -1332,6 +1332,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n   int rank;\n   int d;\n   int shape_i;\n+  int limit;\n   long unsigned one = 1;\n   bool incr_ctr;\n   mpz_t start[GFC_MAX_DIMENSIONS];\n@@ -1547,7 +1548,18 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \t    }\n \t}\n \n-      cons = gfc_constructor_lookup (base, mpz_get_ui (ptr));\n+      limit = mpz_get_ui (ptr);\n+      if (limit >= gfc_option.flag_max_array_constructor)\n+        {\n+\t  gfc_error (\"The number of elements in the array constructor \"\n+\t\t     \"at %L requires an increase of the allowed %d \"\n+\t\t     \"upper limit.   See -fmax-array-constructor \"\n+\t\t     \"option\", &expr->where,\n+\t\t     gfc_option.flag_max_array_constructor);\n+\t  return FAILURE;\n+\t}\n+\n+      cons = gfc_constructor_lookup (base, limit);\n       gcc_assert (cons);\n       gfc_constructor_append_expr (&expr->value.constructor,\n \t\t\t\t   gfc_copy_expr (cons->expr), NULL);"}]}