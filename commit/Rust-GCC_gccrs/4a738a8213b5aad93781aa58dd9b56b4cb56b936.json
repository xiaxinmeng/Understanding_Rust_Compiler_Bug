{"sha": "4a738a8213b5aad93781aa58dd9b56b4cb56b936", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE3MzhhODIxM2I1YWFkOTM3ODFhYTU4ZGQ5YjU2YjRjYjU2YjkzNg==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2004-07-09T14:09:01Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-07-09T14:09:01Z"}, "message": "2004-07-09  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/text/RuleBasedCollator.java\n\t(mergeRules): Use ArrayList instead of Vector.\n\t(subParseString): likewise.\n\t(parseString): likewise.\n\t(buildCollationVector): likewise.\n\t(getCollationKey): likewise.\n\nFrom-SVN: r84369", "tree": {"sha": "bdee4ff2ad7ab8f411714af45d75e95e87cb3d8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdee4ff2ad7ab8f411714af45d75e95e87cb3d8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a738a8213b5aad93781aa58dd9b56b4cb56b936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a738a8213b5aad93781aa58dd9b56b4cb56b936", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a738a8213b5aad93781aa58dd9b56b4cb56b936", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a738a8213b5aad93781aa58dd9b56b4cb56b936/comments", "author": null, "committer": null, "parents": [{"sha": "28e0ee766eeb780493c2e6824bd04291607ca506", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e0ee766eeb780493c2e6824bd04291607ca506", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28e0ee766eeb780493c2e6824bd04291607ca506"}], "stats": {"total": 52, "additions": 30, "deletions": 22}, "files": [{"sha": "130ca8dd84eb70ee34e5f0dde8d7f7a2973a5f49", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a738a8213b5aad93781aa58dd9b56b4cb56b936/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a738a8213b5aad93781aa58dd9b56b4cb56b936/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4a738a8213b5aad93781aa58dd9b56b4cb56b936", "patch": "@@ -1,3 +1,12 @@\n+2004-07-09  Guilhem Lavaux <guilhem@kaffe.org>\n+\n+\t* java/text/RuleBasedCollator.java\n+\t(mergeRules): Use ArrayList instead of Vector.\n+\t(subParseString): likewise.\n+\t(parseString): likewise.\n+\t(buildCollationVector): likewise.\n+\t(getCollationKey): likewise.\n+\n 2004-07-09  Dalibor Topic  <robilad@kaffe.org>\n \n \t* java/text/DateFormat.java (parse):"}, {"sha": "061d97d1b52a995516ff17e1a1984054efae2172", "filename": "libjava/java/text/RuleBasedCollator.java", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a738a8213b5aad93781aa58dd9b56b4cb56b936/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a738a8213b5aad93781aa58dd9b56b4cb56b936/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java?ref=4a738a8213b5aad93781aa58dd9b56b4cb56b936", "patch": "@@ -39,7 +39,7 @@\n \n import java.util.Enumeration;\n import java.util.HashMap;\n-import java.util.Vector;\n+import java.util.ArrayList;\n \n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n  * API docs for JDK 1.2 from http://www.javasoft.com.\n@@ -180,7 +180,7 @@ final int getValue()\n    * collation elements. It contains an instruction which specifies the new\n    * state of the generator. The sequence of instruction should not contain\n    * RESET (it is used by\n-   * {@link #mergeRules(int,java.lang.String,java.util.Vector,java.util.Vector)})\n+   * {@link #mergeRules(int,java.lang.String,java.util.ArrayList,java.util.ArrayList)})\n    * as a temporary state while merging two sets of instructions.\n    */\n   final static class CollationSorter\n@@ -304,10 +304,9 @@ static int findPrefixLength(String prefix, String s)\n    * @param patch Rules to be merged into the repository.\n    * @throws ParseException if it is impossible to find an anchor point for the new rules.\n    */\n-  private void mergeRules(int offset, String starter, Vector main, Vector patch)\n+  private void mergeRules(int offset, String starter, ArrayList main, ArrayList patch)\n     throws ParseException \n   {\n-    Enumeration elements = main.elements();\n     int insertion_point = -1;\n     int max_length = 0;\n     \n@@ -323,11 +322,11 @@ private void mergeRules(int offset, String starter, Vector main, Vector patch)\n \t\n \twhile (j < main.size())\n \t  {\n-\t    CollationSorter rule1 = (CollationSorter) patch.elementAt(i);\n-\t    CollationSorter rule2 = (CollationSorter) main.elementAt(j);\n+\t    CollationSorter rule1 = (CollationSorter) patch.get(i);\n+\t    CollationSorter rule2 = (CollationSorter) main.get(j);\n \t    \n \t    if (rule1.textElement.equals(rule2.textElement))\n-\t      main.removeElementAt(j);\n+\t      main.remove(j);\n \t    else\n \t      j++;\n \t  }\n@@ -336,7 +335,7 @@ private void mergeRules(int offset, String starter, Vector main, Vector patch)\n     // Find the insertion point... O(N)\n     for (int i = 0; i < main.size(); i++)\n       {\n-\tCollationSorter sorter = (CollationSorter) main.elementAt(i);\n+\tCollationSorter sorter = (CollationSorter) main.get(i);\n \tint length = findPrefixLength(starter, sorter.textElement);\n \t\t\n \tif (length > max_length)\n@@ -362,24 +361,24 @@ private void mergeRules(int offset, String starter, Vector main, Vector patch)\n \t * sequence. The rest of the subsequence must be appended\n \t * to the end of the sequence.\n \t */\n-\tCollationSorter sorter = (CollationSorter) patch.elementAt(0);\n+\tCollationSorter sorter = (CollationSorter) patch.get(0);\n \tCollationSorter expansionPrefix =\n-\t  (CollationSorter) main.elementAt(insertion_point-1);\n+\t  (CollationSorter) main.get(insertion_point-1);\n \t\n \tsorter.expansionOrdering = starter.substring(max_length); // Skip the first good prefix element\n \t\t\n-\tmain.insertElementAt(sorter, insertion_point);\n+\tmain.add(insertion_point, sorter);\n \t\n \t/*\n \t * This is a new set of rules. Append to the list.\n \t */\n-\tpatch.removeElementAt(0);\n+\tpatch.remove(0);\n \tinsertion_point++;\n       }\n \n     // Now insert all elements of patch at the insertion point.\n     for (int i = 0; i < patch.size(); i++)\n-      main.insertElementAt(patch.elementAt(i), i+insertion_point);\n+      main.add(i+insertion_point, patch.get(i));\n   }\n \n   /**\n@@ -397,7 +396,7 @@ private void mergeRules(int offset, String starter, Vector main, Vector patch)\n    * @throws ParseException if something turned wrong during the parsing. To get details\n    * decode the message.\n    */\n-  private int subParseString(boolean stop_on_reset, Vector v,\n+  private int subParseString(boolean stop_on_reset, ArrayList v,\n \t\t\t     int base_offset, String rules)\n     throws ParseException\n   {\n@@ -506,7 +505,7 @@ private int subParseString(boolean stop_on_reset, Vector v,\n \t     * indicated by the text element.\n \t     */\n \t    String subrules = rules.substring(i);\n-\t    Vector sorted_rules = new Vector();\n+\t    ArrayList sorted_rules = new ArrayList();\n \t    int idx;\n \n \t    // Parse the subrules but do not iterate through all\n@@ -591,10 +590,10 @@ public Object clone()\n    * @throws ParseException if something turned wrong during the parsing. To get details\n    * decode the message.\n    */\n-  private Vector parseString(String rules) \n+  private ArrayList parseString(String rules) \n     throws ParseException\n   {\n-    Vector v = new Vector();\n+    ArrayList v = new ArrayList();\n \n     // result of the first subParseString is not absolute (may be -1 or a\n     // positive integer). But we do not care.\n@@ -607,10 +606,10 @@ private Vector parseString(String rules)\n    * This method uses the sorting instructions built by {@link #parseString}\n    * to build collation elements which can be directly used to sort strings.\n    *\n-   * @param parsedElements Parsed instructions stored in a Vector.\n+   * @param parsedElements Parsed instructions stored in a ArrayList.\n    * @throws ParseException if the order of the instructions are not valid.\n    */\n-  private void buildCollationVector(Vector parsedElements)\n+  private void buildCollationVector(ArrayList parsedElements)\n     throws ParseException\n   {\n     int primary_seq = 0;\n@@ -622,13 +621,13 @@ private void buildCollationVector(Vector parsedElements)\n     final boolean DECREASING = false;\n     final boolean INCREASING = true;\n     boolean secondaryType = INCREASING;\n-    Vector v = new Vector();\n+    ArrayList v = new ArrayList();\n \n     // elts is completely sorted.\n element_loop:\n     for (int i = 0; i < parsedElements.size(); i++)\n       {\n-\tCollationSorter elt = (CollationSorter) parsedElements.elementAt(i);\n+\tCollationSorter elt = (CollationSorter) parsedElements.get(i);\n \tboolean ignoreChar = false;\n \n \tswitch (elt.comparisonType)\n@@ -947,7 +946,7 @@ public CollationElementIterator getCollationElementIterator(CharacterIterator so\n   public CollationKey getCollationKey(String source)\n   {\n     CollationElementIterator cei = getCollationElementIterator(source);\n-    Vector vect = new Vector(25);\n+    ArrayList vect = new ArrayList();\n \n     int ord = cei.next();\n     cei.reset(); //set to start of string"}]}