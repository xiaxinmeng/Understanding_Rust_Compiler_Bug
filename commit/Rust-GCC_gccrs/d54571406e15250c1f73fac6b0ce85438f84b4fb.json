{"sha": "d54571406e15250c1f73fac6b0ce85438f84b4fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU0NTcxNDA2ZTE1MjUwYzFmNzNmYWM2YjBjZTg1NDM4Zjg0YjRmYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-02-01T12:29:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-02-01T12:29:18Z"}, "message": "builtins.c (expand_builtin_alloca): allocate_dynamic_stack_space returns Pmode pseudo, but we need ptr_mode.\n\n\t* builtins.c (expand_builtin_alloca): allocate_dynamic_stack_space\n\treturns Pmode pseudo, but we need ptr_mode.\n\t* explow.c (allocate_dynamic_stack_space): Use plus_constant.\n\tRemove bogus conversions; use HOST_WIDE_INT for size.\n\tDon't use TARGET if wrong mode.\n\nFrom-SVN: r39390", "tree": {"sha": "e5b324c5c826bd74ab4f7fe2ac03b199ea6b5f34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5b324c5c826bd74ab4f7fe2ac03b199ea6b5f34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d54571406e15250c1f73fac6b0ce85438f84b4fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54571406e15250c1f73fac6b0ce85438f84b4fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d54571406e15250c1f73fac6b0ce85438f84b4fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54571406e15250c1f73fac6b0ce85438f84b4fb/comments", "author": null, "committer": null, "parents": [{"sha": "fcbfaa65a5e27ee6f772056bf52cf27202518def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcbfaa65a5e27ee6f772056bf52cf27202518def", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcbfaa65a5e27ee6f772056bf52cf27202518def"}], "stats": {"total": 43, "additions": 27, "deletions": 16}, "files": [{"sha": "b18311df517eccb18b7f185ddb0a0b268daf7c14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54571406e15250c1f73fac6b0ce85438f84b4fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54571406e15250c1f73fac6b0ce85438f84b4fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d54571406e15250c1f73fac6b0ce85438f84b4fb", "patch": "@@ -1,5 +1,11 @@\n Thu Feb  1 07:22:41 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* builtins.c (expand_builtin_alloca): allocate_dynamic_stack_space\n+\treturns Pmode pseudo, but we need ptr_mode.\n+\t* explow.c (allocate_dynamic_stack_space): Use plus_constant.\n+\tRemove bogus conversions; use HOST_WIDE_INT for size.\n+\tDon't use TARGET if wrong mode.\n+\n \t* config/i386/i386.c (ix86_compute_frame_size): Allow\n \tstack_alignment_needed to be non-default even if size is zero.\n "}, {"sha": "1a6d87f77d461e99ce9056fa91d085ea91652f39", "filename": "gcc/builtins.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54571406e15250c1f73fac6b0ce85438f84b4fb/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54571406e15250c1f73fac6b0ce85438f84b4fb/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d54571406e15250c1f73fac6b0ce85438f84b4fb", "patch": "@@ -3095,12 +3095,14 @@ expand_builtin_frame_address (exp)\n /* Expand a call to the alloca builtin, with arguments ARGLIST.  Return 0 if\n    we failed and the caller should emit a normal call, otherwise try to get\n    the result in TARGET, if convenient.  */\n+\n static rtx\n expand_builtin_alloca (arglist, target)\n      tree arglist;\n      rtx target;\n {\n   rtx op0;\n+  rtx result;\n \n   if (!validate_arglist (arglist, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n@@ -3109,13 +3111,20 @@ expand_builtin_alloca (arglist, target)\n   op0 = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);\n \n   /* Allocate the desired space.  */\n-  return allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT);\n+  result = allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT);\n+\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+  result = convert_memory_address (ptr_mode, result);\n+#endif\n+\n+  return result;\n }\n \n /* Expand a call to the ffs builtin.  The arguments are in ARGLIST.\n    Return 0 if a normal call should be emitted rather than expanding the\n    function in-line.  If convenient, the result should be placed in TARGET.\n    SUBTARGET may be used as the target for computing one of EXP's operands.  */\n+\n static rtx\n expand_builtin_ffs (arglist, target, subtarget)\n      tree arglist;\n@@ -3138,6 +3147,7 @@ expand_builtin_ffs (arglist, target, subtarget)\n \n /* If the string passed to fputs is a constant and is one character\n    long, we attempt to transform this call into __builtin_fputc(). */\n+\n static rtx\n expand_builtin_fputs (arglist, ignore)\n      tree arglist;"}, {"sha": "d36ceffa440fb65acdcd7a2a6c62419d2231be28", "filename": "gcc/explow.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54571406e15250c1f73fac6b0ce85438f84b4fb/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54571406e15250c1f73fac6b0ce85438f84b4fb/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=d54571406e15250c1f73fac6b0ce85438f84b4fb", "patch": "@@ -1294,15 +1294,10 @@ allocate_dynamic_stack_space (size, target, known_align)\n #endif\n \n   if (MUST_ALIGN)\n-    {\n-      if (GET_CODE (size) == CONST_INT)\n-\tsize = GEN_INT (INTVAL (size)\n-\t\t\t+ (BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1));\n-      else\n-\tsize = expand_binop (Pmode, add_optab, size,\n-\t\t\t     GEN_INT (BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),\n-\t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-    }\n+    size\n+      = force_operand (plus_constant (size, \n+\t\t\t\t      BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),\n+\t\t       NULL_RTX);\n \n #ifdef SETJMP_VIA_SAVE_AREA\n   /* If setjmp restores regs from a save area in the stack frame,\n@@ -1325,12 +1320,12 @@ allocate_dynamic_stack_space (size, target, known_align)\n #if !defined(PREFERRED_STACK_BOUNDARY) || !defined(MUST_ALIGN) || (PREFERRED_STACK_BOUNDARY != BIGGEST_ALIGNMENT)\n \t/* If anyone creates a target with these characteristics, let them\n \t   know that our optimization cannot work correctly in such a case.  */\n-\tabort();\n+\tabort ();\n #endif\n \n \tif (GET_CODE (size) == CONST_INT)\n \t  {\n-\t    int new = INTVAL (size) / align * align;\n+\t    HOST_WIDE_INT new = INTVAL (size) / align * align;\n \n \t    if (INTVAL (size) != new)\n \t      setjmpless_size = GEN_INT (new);\n@@ -1395,9 +1390,10 @@ allocate_dynamic_stack_space (size, target, known_align)\n   if (flag_stack_check && ! STACK_CHECK_BUILTIN)\n     probe_stack_range (STACK_CHECK_MAX_FRAME_SIZE + STACK_CHECK_PROTECT, size);\n \n-  /* Don't use a TARGET that isn't a pseudo.  */\n+  /* Don't use a TARGET that isn't a pseudo or is the wrong mode.  */\n   if (target == 0 || GET_CODE (target) != REG\n-      || REGNO (target) < FIRST_PSEUDO_REGISTER)\n+      || REGNO (target) < FIRST_PSEUDO_REGISTER\n+      || GET_MODE (target) != Pmode)\n     target = gen_reg_rtx (Pmode);\n \n   mark_reg_pointer (target, known_align);\n@@ -1422,7 +1418,6 @@ allocate_dynamic_stack_space (size, target, known_align)\n       if (mode == VOIDmode)\n \tmode = Pmode;\n \n-      size = convert_modes (mode, ptr_mode, size, 1);\n       pred = insn_data[(int) CODE_FOR_allocate_stack].operand[1].predicate;\n       if (pred && ! ((*pred) (size, mode)))\n \tsize = copy_to_mode_reg (mode, size);\n@@ -1435,7 +1430,6 @@ allocate_dynamic_stack_space (size, target, known_align)\n #ifndef STACK_GROWS_DOWNWARD\n       emit_move_insn (target, virtual_stack_dynamic_rtx);\n #endif\n-      size = convert_modes (Pmode, ptr_mode, size, 1);\n \n       /* Check stack bounds if necessary.  */\n       if (current_function_limit_stack)\n@@ -1474,6 +1468,7 @@ allocate_dynamic_stack_space (size, target, known_align)\n \t\t\t\t REG_NOTES (note_target));\n \t}\n #endif /* SETJMP_VIA_SAVE_AREA */\n+\n #ifdef STACK_GROWS_DOWNWARD\n   emit_move_insn (target, virtual_stack_dynamic_rtx);\n #endif"}]}