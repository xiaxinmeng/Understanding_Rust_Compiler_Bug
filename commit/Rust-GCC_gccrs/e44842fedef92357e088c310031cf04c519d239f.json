{"sha": "e44842fedef92357e088c310031cf04c519d239f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ0ODQyZmVkZWY5MjM1N2UwODhjMzEwMDMxY2YwNGM1MTlkMjM5Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-27T22:55:11Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-27T22:55:11Z"}, "message": "(store_constructor): Treat QUAL_UNION_TYPE just like UNION_TYPE.\n\n(safe_from_p, case ADDR_EXPR): EXP is safe from X it is is static or if the\nobject whose address is being taken is safe from X.\n(expand_expr): Fix misplaced comment from last change.\n(expand_expr, case *_DECL): If not already used, assemble external.\n(expand_expr, case EXIT_EXPR): Simplify.\n(expand_expr, TRUTH_{AND,OR}IF_EXPR): Properly handle IGNORE case.\n\nFrom-SVN: r4772", "tree": {"sha": "5941dbf153c770a14180a459515889c3e748956f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5941dbf153c770a14180a459515889c3e748956f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e44842fedef92357e088c310031cf04c519d239f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e44842fedef92357e088c310031cf04c519d239f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e44842fedef92357e088c310031cf04c519d239f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e44842fedef92357e088c310031cf04c519d239f/comments", "author": null, "committer": null, "parents": [{"sha": "c0560b8b7cb3f80668d70a89644503868d857205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0560b8b7cb3f80668d70a89644503868d857205", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0560b8b7cb3f80668d70a89644503868d857205"}], "stats": {"total": 62, "additions": 37, "deletions": 25}, "files": [{"sha": "dade3c1f8fbb5491c14ca239af8a347652abaa2a", "filename": "gcc/expr.c", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e44842fedef92357e088c310031cf04c519d239f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e44842fedef92357e088c310031cf04c519d239f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e44842fedef92357e088c310031cf04c519d239f", "patch": "@@ -2518,12 +2518,14 @@ store_constructor (exp, target)\n     }\n #endif\n \n-  if (TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE)\n+  if (TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE\n+      || TREE_CODE (type) == QUAL_UNION_TYPE)\n     {\n       register tree elt;\n \n       /* Inform later passes that the whole union value is dead.  */\n-      if (TREE_CODE (type) == UNION_TYPE)\n+      if (TREE_CODE (type) == UNION_TYPE\n+\t  || TREE_CODE (type) == QUAL_UNION_TYPE)\n \temit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n \n       /* If we are building a static constructor into a register,\n@@ -3142,7 +3144,8 @@ safe_from_p (x, exp)\n       switch (TREE_CODE (exp))\n \t{\n \tcase ADDR_EXPR:\n-\t  return staticp (TREE_OPERAND (exp, 0));\n+\t  return (staticp (TREE_OPERAND (exp, 0))\n+\t\t  || safe_from_p (x, TREE_OPERAND (exp, 0)));\n \n \tcase INDIRECT_REF:\n \t  if (GET_CODE (x) == MEM)\n@@ -3337,14 +3340,15 @@ expand_expr (exp, target, tmode, modifier)\n \t   the first. */\n \treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n \t\t\t    VOIDmode, modifier);\n-      /* If will do cse, generate all results into pseudo registers\n-\t since 1) that allows cse to find more things\n-\t and 2) otherwise cse could produce an insn the machine\n-\t cannot support.  */\n \n       target = 0, original_target = 0;\n     }\n \n+  /* If will do cse, generate all results into pseudo registers\n+     since 1) that allows cse to find more things\n+     and 2) otherwise cse could produce an insn the machine\n+     cannot support.  */\n+\n   if (! cse_not_expected && mode != BLKmode && target\n       && (GET_CODE (target) != REG || REGNO (target) < FIRST_PSEUDO_REGISTER))\n     target = subtarget;\n@@ -3389,9 +3393,15 @@ expand_expr (exp, target, tmode, modifier)\n     case RESULT_DECL:\n       if (DECL_RTL (exp) == 0)\n \tabort ();\n-      /* Ensure variable marked as used\n-\t even if it doesn't go through a parser.  */\n-      TREE_USED (exp) = 1;\n+      /* Ensure variable marked as used even if it doesn't go through\n+\t a parser.  If it hasn't be used yet, write out an external\n+\t definition.  */\n+      if (! TREE_USED (exp))\n+\t{\n+\t  assemble_external (exp);\n+\t  TREE_USED (exp) = 1;\n+\t}\n+\n       /* Handle variables inherited from containing functions.  */\n       context = decl_function_context (exp);\n \n@@ -3590,13 +3600,8 @@ expand_expr (exp, target, tmode, modifier)\n       return SAVE_EXPR_RTL (exp);\n \n     case EXIT_EXPR:\n-      /* Exit the current loop if the body-expression is true.  */\n-      {\n-\trtx label = gen_label_rtx ();\n-\tdo_jump (TREE_OPERAND (exp, 0), label, NULL_RTX);\n-\texpand_exit_loop (NULL_PTR);\n-\temit_label (label);\n-      }\n+      expand_exit_loop_if_false (NULL_PTR,\n+\t\t\t\t invert_truthvalue (TREE_OPERAND (exp, 0)));\n       return const0_rtx;\n \n     case LOOP_EXPR:\n@@ -4781,18 +4786,25 @@ expand_expr (exp, target, tmode, modifier)\n \n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n-      if (target == 0 || ! safe_from_p (target, exp)\n-\t  /* Make sure we don't have a hard reg (such as function's return\n-\t     value) live across basic blocks, if not optimizing.  */\n-\t  || (!optimize && GET_CODE (target) == REG\n-\t      && REGNO (target) < FIRST_PSEUDO_REGISTER))\n+      if (! ignore\n+\t  && (target == 0 || ! safe_from_p (target, exp)\n+\t      /* Make sure we don't have a hard reg (such as function's return\n+\t\t value) live across basic blocks, if not optimizing.  */\n+\t      || (!optimize && GET_CODE (target) == REG\n+\t\t  && REGNO (target) < FIRST_PSEUDO_REGISTER)))\n \ttarget = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);\n-      emit_clr_insn (target);\n+\n+      if (target)\n+\temit_clr_insn (target);\n+\n       op1 = gen_label_rtx ();\n       jumpifnot (exp, op1);\n-      emit_0_to_1_insn (target);\n+\n+      if (target)\n+\temit_0_to_1_insn (target);\n+\n       emit_label (op1);\n-      return target;\n+      return ignore ? const0_rtx : target;\n \n     case TRUTH_NOT_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), target, VOIDmode, 0);"}]}