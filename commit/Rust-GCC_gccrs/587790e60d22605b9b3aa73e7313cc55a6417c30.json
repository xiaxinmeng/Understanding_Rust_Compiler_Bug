{"sha": "587790e60d22605b9b3aa73e7313cc55a6417c30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg3NzkwZTYwZDIyNjA1YjliM2FhNzNlNzMxM2NjNTVhNjQxN2MzMA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2017-01-05T09:59:32Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2017-01-05T09:59:32Z"}, "message": "S/390: memset: Avoid overlapping MVC operands between iterations.\n\nA memset with a value != 0 is currently implemented using the mvc\ninstruction propagating the first byte through 256 byte blocks.  While\nfor the first mvc the byte is written with a separate instruction\nsubsequent MVCs used the last byte of the previous 256 byte block.\n\nStarting with z13 this causes a major performance degradation.  With\nthis patch we always set the first byte with an mvi or stc in order to\navoid the overlapping of the MVC operands between loop iterations.\n\nOn older machines this basically makes no measurable difference so the\npatch enables the new behavior for all machine levels in order to make\nsure that code built for older machine levels runs well when moved to\na z13.\n\nBootstrapped and regression tested on s390 and s390x using z900 and z13\nas default -march level. No regressions.\n\ngcc/ChangeLog:\n\n2017-01-05  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/s390.c (s390_expand_setmem): Avoid overlapping bytes\n\tbetween loop iterations.\n\nFrom-SVN: r244096", "tree": {"sha": "ffa2fd7e3106dd480f6f7c2a22f9439a2e9b2ab0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffa2fd7e3106dd480f6f7c2a22f9439a2e9b2ab0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/587790e60d22605b9b3aa73e7313cc55a6417c30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/587790e60d22605b9b3aa73e7313cc55a6417c30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/587790e60d22605b9b3aa73e7313cc55a6417c30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/587790e60d22605b9b3aa73e7313cc55a6417c30/comments", "author": null, "committer": null, "parents": [{"sha": "6ff92497174e84271f71d1a1ede8a0ec513ee6a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff92497174e84271f71d1a1ede8a0ec513ee6a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ff92497174e84271f71d1a1ede8a0ec513ee6a7"}], "stats": {"total": 100, "additions": 69, "deletions": 31}, "files": [{"sha": "6c47cb876ec7865417070908849557dfcb81554f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587790e60d22605b9b3aa73e7313cc55a6417c30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587790e60d22605b9b3aa73e7313cc55a6417c30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=587790e60d22605b9b3aa73e7313cc55a6417c30", "patch": "@@ -1,3 +1,8 @@\n+2017-01-05  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.c (s390_expand_setmem): Avoid overlapping bytes\n+\tbetween loop iterations.\n+\n 2017-01-05  Martin Liska  <mliska@suse.cz>\n \n \tPR sanitizer/78815"}, {"sha": "257bce7fa0933c6f276d409c65708baa0bf950ad", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 64, "deletions": 31, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587790e60d22605b9b3aa73e7313cc55a6417c30/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587790e60d22605b9b3aa73e7313cc55a6417c30/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=587790e60d22605b9b3aa73e7313cc55a6417c30", "patch": "@@ -5346,6 +5346,8 @@ s390_expand_movmem (rtx dst, rtx src, rtx len)\n void\n s390_expand_setmem (rtx dst, rtx len, rtx val)\n {\n+  const int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n+\n   if (GET_CODE (len) == CONST_INT && INTVAL (len) == 0)\n     return;\n \n@@ -5391,53 +5393,71 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n     {\n       rtx dst_addr, count, blocks, temp, dstp1 = NULL_RTX;\n       rtx_code_label *loop_start_label = gen_label_rtx ();\n-      rtx_code_label *loop_end_label = gen_label_rtx ();\n-      rtx_code_label *end_label = gen_label_rtx ();\n+      rtx_code_label *onebyte_end_label = gen_label_rtx ();\n+      rtx_code_label *zerobyte_end_label = gen_label_rtx ();\n+      rtx_code_label *restbyte_end_label = gen_label_rtx ();\n       machine_mode mode;\n \n       mode = GET_MODE (len);\n       if (mode == VOIDmode)\n-        mode = Pmode;\n+\tmode = Pmode;\n \n       dst_addr = gen_reg_rtx (Pmode);\n       count = gen_reg_rtx (mode);\n       blocks = gen_reg_rtx (mode);\n \n       convert_move (count, len, 1);\n       emit_cmp_and_jump_insns (count, const0_rtx,\n-\t\t\t       EQ, NULL_RTX, mode, 1, end_label);\n+\t\t\t       EQ, NULL_RTX, mode, 1, zerobyte_end_label,\n+\t\t\t       very_unlikely);\n \n+      /* We need to make a copy of the target address since memset is\n+\t supposed to return it unmodified.  We have to make it here\n+\t already since the new reg is used at onebyte_end_label.  */\n       emit_move_insn (dst_addr, force_operand (XEXP (dst, 0), NULL_RTX));\n       dst = change_address (dst, VOIDmode, dst_addr);\n \n-      if (val == const0_rtx)\n-        temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1,\n-\t\t\t     OPTAB_DIRECT);\n-      else\n+      if (val != const0_rtx)\n \t{\n-\t  dstp1 = adjust_address (dst, VOIDmode, 1);\n+\t  /* When using the overlapping mvc the original target\n+\t     address is only accessed as single byte entity (even by\n+\t     the mvc reading this value).  */\n \t  set_mem_size (dst, 1);\n-\n-\t  /* Initialize memory by storing the first byte.  */\n-\t  emit_move_insn (adjust_address (dst, QImode, 0), val);\n-\n-\t  /* If count is 1 we are done.  */\n-\t  emit_cmp_and_jump_insns (count, const1_rtx,\n-\t\t\t\t   EQ, NULL_RTX, mode, 1, end_label);\n-\n-\t  temp = expand_binop (mode, add_optab, count, GEN_INT (-2), count, 1,\n-\t\t\t       OPTAB_DIRECT);\n-\t}\n+\t  dstp1 = adjust_address (dst, VOIDmode, 1);\n+\t  emit_cmp_and_jump_insns (count,\n+\t\t\t\t   const1_rtx, EQ, NULL_RTX, mode, 1,\n+\t\t\t\t   onebyte_end_label, very_unlikely);\n+\t}\n+\n+      /* There is one unconditional (mvi+mvc)/xc after the loop\n+\t dealing with the rest of the bytes, subtracting two (mvi+mvc)\n+\t or one (xc) here leaves this number of bytes to be handled by\n+\t it.  */\n+      temp = expand_binop (mode, add_optab, count,\n+\t\t\t   val == const0_rtx ? constm1_rtx : GEN_INT (-2),\n+\t\t\t   count, 1, OPTAB_DIRECT);\n       if (temp != count)\n-        emit_move_insn (count, temp);\n+\temit_move_insn (count, temp);\n \n       temp = expand_binop (mode, lshr_optab, count, GEN_INT (8), blocks, 1,\n \t\t\t   OPTAB_DIRECT);\n       if (temp != blocks)\n-        emit_move_insn (blocks, temp);\n+\temit_move_insn (blocks, temp);\n \n       emit_cmp_and_jump_insns (blocks, const0_rtx,\n-\t\t\t       EQ, NULL_RTX, mode, 1, loop_end_label);\n+\t\t\t       EQ, NULL_RTX, mode, 1, restbyte_end_label);\n+\n+      emit_jump (loop_start_label);\n+\n+      if (val != const0_rtx)\n+\t{\n+\t  /* The 1 byte != 0 special case.  Not handled efficiently\n+\t     since we require two jumps for that.  However, this\n+\t     should be very rare.  */\n+\t  emit_label (onebyte_end_label);\n+\t  emit_move_insn (adjust_address (dst, QImode, 0), val);\n+\t  emit_jump (zerobyte_end_label);\n+\t}\n \n       emit_label (loop_start_label);\n \n@@ -5455,26 +5475,39 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n       if (val == const0_rtx)\n \temit_insn (gen_clrmem_short (dst, GEN_INT (255)));\n       else\n-\temit_insn (gen_movmem_short (dstp1, dst, GEN_INT (255)));\n+\t{\n+\t  /* Set the first byte in the block to the value and use an\n+\t     overlapping mvc for the block.  */\n+\t  emit_move_insn (adjust_address (dst, QImode, 0), val);\n+\t  emit_insn (gen_movmem_short (dstp1, dst, GEN_INT (254)));\n+\t}\n       s390_load_address (dst_addr,\n \t\t\t gen_rtx_PLUS (Pmode, dst_addr, GEN_INT (256)));\n \n       temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1,\n \t\t\t   OPTAB_DIRECT);\n       if (temp != blocks)\n-        emit_move_insn (blocks, temp);\n+\temit_move_insn (blocks, temp);\n \n       emit_cmp_and_jump_insns (blocks, const0_rtx,\n-\t\t\t       EQ, NULL_RTX, mode, 1, loop_end_label);\n+\t\t\t       NE, NULL_RTX, mode, 1, loop_start_label);\n \n-      emit_jump (loop_start_label);\n-      emit_label (loop_end_label);\n+      emit_label (restbyte_end_label);\n \n       if (val == const0_rtx)\n-        emit_insn (gen_clrmem_short (dst, convert_to_mode (Pmode, count, 1)));\n+\temit_insn (gen_clrmem_short (dst, convert_to_mode (Pmode, count, 1)));\n       else\n-        emit_insn (gen_movmem_short (dstp1, dst, convert_to_mode (Pmode, count, 1)));\n-      emit_label (end_label);\n+\t{\n+\t  /* Set the first byte in the block to the value and use an\n+\t     overlapping mvc for the block.  */\n+\t  emit_move_insn (adjust_address (dst, QImode, 0), val);\n+\t  /* execute only uses the lowest 8 bits of count that's\n+\t     exactly what we need here.  */\n+\t  emit_insn (gen_movmem_short (dstp1, dst,\n+\t\t\t\t       convert_to_mode (Pmode, count, 1)));\n+\t}\n+\n+      emit_label (zerobyte_end_label);\n     }\n }\n "}]}