{"sha": "f758f2992f61a18b961a151e0e8b7bac68310356", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc1OGYyOTkyZjYxYTE4Yjk2MWExNTFlMGU4YjdiYWM2ODMxMDM1Ng==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-08-16T15:28:13Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-08-16T15:28:13Z"}, "message": "re PR target/58160 (Power8 fusion support has a bug that shows up in running spec 2006)\n\n2013-08-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/58160\n\t* config/rs6000/predicates.md (fusion_gpr_mem_load): Allow the\n\tmemory rtx to contain ZERO_EXTEND and SIGN_EXTEND.\n\n\t* config/rs6000/rs6000-protos.h (fusion_gpr_load_p): Pass operands\n\tarray instead of each individual operand as a separate argument.\n\t(emit_fusion_gpr_load): Likewise.\n\t(expand_fusion_gpr_load): Add new function declaration.\n\n\t* config/rs6000/rs6000.c (fusion_gpr_load_p): Change the calling\n\tsignature to have the operands passed as an array, instead of as\n\tseparate arguments.  Allow ZERO_EXTEND to be in the memory\n\taddress, and also SIGN_EXTEND if -mpower8-fusion-sign.  Do not\n\tdepend on the register live/dead flags when peepholes are run.\n\t(expand_fusion_gpr_load): New function to be called from the\n\tpeephole2 pass, to change the register that addis sets to be the\n\ttarget register.\n\t(emit_fusion_gpr_load): Change the calling signature to have the\n\toperands passed as an array, instead of as separate arguments.\n\tAllow ZERO_EXTEND to be in the memory address, and also\n\tSIGN_EXTEND if -mpower8-fusion-sign.\n\n\t* config/rs6000/rs6000.md (UNSPEC_FUSION_GPR): Delete unused\n\tunspec enumeration.\n\t(power8 fusion peephole/peephole2): Rework the fusion peepholes to\n\tadjust the register addis loads up in the peephole2 pass.  Do not\n\tdepend on the register live/dead state when the peephole pass is\n\tdone.\n\nFrom-SVN: r201792", "tree": {"sha": "f4f06576ee4408489e14b1870e5281ac8184bff7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4f06576ee4408489e14b1870e5281ac8184bff7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f758f2992f61a18b961a151e0e8b7bac68310356", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f758f2992f61a18b961a151e0e8b7bac68310356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f758f2992f61a18b961a151e0e8b7bac68310356", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f758f2992f61a18b961a151e0e8b7bac68310356/comments", "author": null, "committer": null, "parents": [{"sha": "158f4e4f46cab61f09dfce1ff2ac7dbfec8bb615", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/158f4e4f46cab61f09dfce1ff2ac7dbfec8bb615", "html_url": "https://github.com/Rust-GCC/gccrs/commit/158f4e4f46cab61f09dfce1ff2ac7dbfec8bb615"}], "stats": {"total": 367, "additions": 224, "deletions": 143}, "files": [{"sha": "abe0d43d2bbccce2924914b71a2bf8a9f0cc4553", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f758f2992f61a18b961a151e0e8b7bac68310356/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f758f2992f61a18b961a151e0e8b7bac68310356/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f758f2992f61a18b961a151e0e8b7bac68310356", "patch": "@@ -1,3 +1,34 @@\n+2013-08-16  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/58160\n+\t* config/rs6000/predicates.md (fusion_gpr_mem_load): Allow the\n+\tmemory rtx to contain ZERO_EXTEND and SIGN_EXTEND.\n+\n+\t* config/rs6000/rs6000-protos.h (fusion_gpr_load_p): Pass operands\n+\tarray instead of each individual operand as a separate argument.\n+\t(emit_fusion_gpr_load): Likewise.\n+\t(expand_fusion_gpr_load): Add new function declaration.\n+\n+\t* config/rs6000/rs6000.c (fusion_gpr_load_p): Change the calling\n+\tsignature to have the operands passed as an array, instead of as\n+\tseparate arguments.  Allow ZERO_EXTEND to be in the memory\n+\taddress, and also SIGN_EXTEND if -mpower8-fusion-sign.  Do not\n+\tdepend on the register live/dead flags when peepholes are run.\n+\t(expand_fusion_gpr_load): New function to be called from the\n+\tpeephole2 pass, to change the register that addis sets to be the\n+\ttarget register.\n+\t(emit_fusion_gpr_load): Change the calling signature to have the\n+\toperands passed as an array, instead of as separate arguments.\n+\tAllow ZERO_EXTEND to be in the memory address, and also\n+\tSIGN_EXTEND if -mpower8-fusion-sign.\n+\n+\t* config/rs6000/rs6000.md (UNSPEC_FUSION_GPR): Delete unused\n+\tunspec enumeration.\n+\t(power8 fusion peephole/peephole2): Rework the fusion peepholes to\n+\tadjust the register addis loads up in the peephole2 pass.  Do not\n+\tdepend on the register live/dead state when the peephole pass is\n+\tdone.\n+\n 2013-08-16  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gengtype.c (create_user_defined_type): Ensure that the kind"}, {"sha": "7338e764c5cffe8db589516069f83c49d6570bc9", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f758f2992f61a18b961a151e0e8b7bac68310356/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f758f2992f61a18b961a151e0e8b7bac68310356/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=f758f2992f61a18b961a151e0e8b7bac68310356", "patch": "@@ -1740,10 +1740,18 @@\n ;; Match the second insn (lbz, lhz, lwz, ld) in fusing the combination of addis\n ;; and loads to GPR registers on power8.\n (define_predicate \"fusion_gpr_mem_load\"\n-  (match_code \"mem\")\n+  (match_code \"mem,sign_extend,zero_extend\")\n {\n   rtx addr;\n \n+  /* Handle sign/zero extend.  */\n+  if (GET_CODE (op) == ZERO_EXTEND\n+      || (TARGET_P8_FUSION_SIGN && GET_CODE (op) == SIGN_EXTEND))\n+    {\n+      op = XEXP (op, 0);\n+      mode = GET_MODE (op);\n+    }\n+\n   if (!MEM_P (op))\n     return 0;\n "}, {"sha": "3ddabb81c3925492f186bbe82b40728d6c4a1411", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f758f2992f61a18b961a151e0e8b7bac68310356/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f758f2992f61a18b961a151e0e8b7bac68310356/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=f758f2992f61a18b961a151e0e8b7bac68310356", "patch": "@@ -73,8 +73,9 @@ extern int mems_ok_for_quad_peep (rtx, rtx);\n extern bool gpr_or_gpr_p (rtx, rtx);\n extern bool direct_move_p (rtx, rtx);\n extern bool quad_load_store_p (rtx, rtx);\n-extern bool fusion_gpr_load_p (rtx, rtx, rtx, rtx, rtx);\n-extern const char *emit_fusion_gpr_load (rtx, rtx, rtx, rtx);\n+extern bool fusion_gpr_load_p (rtx *, bool);\n+extern void expand_fusion_gpr_load (rtx *);\n+extern const char *emit_fusion_gpr_load (rtx *);\n extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,\n \t\t\t\t\t\t\t    enum reg_class);\n extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,"}, {"sha": "b46993098ef599df0cda5f0684113451178948cd", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 167, "deletions": 55, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f758f2992f61a18b961a151e0e8b7bac68310356/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f758f2992f61a18b961a151e0e8b7bac68310356/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f758f2992f61a18b961a151e0e8b7bac68310356", "patch": "@@ -30429,16 +30429,25 @@ rs6000_split_logical (rtx operands[3],\n \f\n /* Return true if the peephole2 can combine a load involving a combination of\n    an addis instruction and a load with an offset that can be fused together on\n-   a power8.  */\n+   a power8.\n+\n+   The operands are:\n+\toperands[0]\tregister set with addis\n+\toperands[1]\tvalue set via addis\n+\toperands[2]\ttarget register being loaded\n+\toperands[3]\tD-form memory reference using operands[0].\n+\n+   In addition, we are passed a boolean that is true if this is a peephole2,\n+   and we can use see if the addis_reg is dead after the insn and can be\n+   replaced by the target register.  */\n \n bool\n-fusion_gpr_load_p (rtx addis_reg,\t/* reg. to hold high value.  */\n-\t\t   rtx addis_value,\t/* high value loaded.  */\n-\t\t   rtx target,\t\t/* reg. that is loaded.  */\n-\t\t   rtx mem,\t\t/* memory to load.  */\n-\t\t   rtx insn)\t\t/* insn for looking up reg notes or\n-\t\t\t\t\t   NULL_RTX if this is a peephole2.  */\n+fusion_gpr_load_p (rtx *operands, bool peep2_p)\n {\n+  rtx addis_reg = operands[0];\n+  rtx addis_value = operands[1];\n+  rtx target = operands[2];\n+  rtx mem = operands[3];\n   rtx addr;\n   rtx base_reg;\n \n@@ -30455,84 +30464,180 @@ fusion_gpr_load_p (rtx addis_reg,\t/* reg. to hold high value.  */\n   if (!fusion_gpr_mem_load (mem, GET_MODE (mem)))\n     return false;\n \n+  /* Allow sign/zero extension.  */\n+  if (GET_CODE (mem) == ZERO_EXTEND\n+      || (GET_CODE (mem) == SIGN_EXTEND && TARGET_P8_FUSION_SIGN))\n+    mem = XEXP (mem, 0);\n+\n+  if (!MEM_P (mem))\n+    return false;\n+\n+  addr = XEXP (mem, 0);\t\t\t/* either PLUS or LO_SUM.  */\n+  if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)\n+    return false;\n+\n   /* Validate that the register used to load the high value is either the\n-     register being loaded, or we can safely replace its use in a peephole.\n+     register being loaded, or we can safely replace its use in a peephole2.\n \n      If this is a peephole2, we assume that there are 2 instructions in the\n      peephole (addis and load), so we want to check if the target register was\n-     not used and the register to hold the addis result is dead after the\n-     peephole.  */\n+     not used in the memory address and the register to hold the addis result\n+     is dead after the peephole.  */\n   if (REGNO (addis_reg) != REGNO (target))\n     {\n+      if (!peep2_p)\n+\treturn false;\n+\n       if (reg_mentioned_p (target, mem))\n \treturn false;\n \n-      if (insn)\n-\t{\n-\t  if (!find_reg_note (insn, REG_DEAD, addis_reg))\n-\t    return false;\n-\t}\n-      else\n-\t{\n-\t  if (!peep2_reg_dead_p (2, addis_reg))\n-\t    return false;\n-\t}\n+      if (!peep2_reg_dead_p (2, addis_reg))\n+\treturn false;\n     }\n \n-  /* Validate that the value being loaded in the addis is used in the load.  */\n-  addr = XEXP (mem, 0);\t\t\t/* either PLUS or LO_SUM.  */\n-  if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)\n-    return false;\n-\n   base_reg = XEXP (addr, 0);\n   return REGNO (addis_reg) == REGNO (base_reg);\n }\n \n+/* During the peephole2 pass, adjust and expand the insns for a load fusion\n+   sequence.  We adjust the addis register to use the target register.  If the\n+   load sign extends, we adjust the code to do the zero extending load, and an\n+   explicit sign extension later since the fusion only covers zero extending\n+   loads.\n+\n+   The operands are:\n+\toperands[0]\tregister set with addis (to be replaced with target)\n+\toperands[1]\tvalue set via addis\n+\toperands[2]\ttarget register being loaded\n+\toperands[3]\tD-form memory reference using operands[0].  */\n+\n+void\n+expand_fusion_gpr_load (rtx *operands)\n+{\n+  rtx addis_value = operands[1];\n+  rtx target = operands[2];\n+  rtx orig_mem = operands[3];\n+  rtx  new_addr, new_mem, orig_addr, offset;\n+  enum rtx_code plus_or_lo_sum;\n+  enum machine_mode target_mode = GET_MODE (target);\n+  enum machine_mode extend_mode = target_mode;\n+  enum machine_mode ptr_mode = Pmode;\n+  enum rtx_code extend = UNKNOWN;\n+  rtx addis_reg = ((ptr_mode == target_mode)\n+\t\t   ? target\n+\t\t   : simplify_subreg (ptr_mode, target, target_mode, 0));\n+\n+  if (GET_CODE (orig_mem) == ZERO_EXTEND\n+      || (TARGET_P8_FUSION_SIGN && GET_CODE (orig_mem) == SIGN_EXTEND))\n+    {\n+      extend = GET_CODE (orig_mem);\n+      orig_mem = XEXP (orig_mem, 0);\n+      target_mode = GET_MODE (orig_mem);\n+    }\n+\n+  gcc_assert (MEM_P (orig_mem));\n+\n+  orig_addr = XEXP (orig_mem, 0);\n+  plus_or_lo_sum = GET_CODE (orig_addr);\n+  gcc_assert (plus_or_lo_sum == PLUS || plus_or_lo_sum == LO_SUM);\n+\n+  offset = XEXP (orig_addr, 1);\n+  new_addr = gen_rtx_fmt_ee (plus_or_lo_sum, ptr_mode, addis_reg, offset);\n+  new_mem = change_address (orig_mem, target_mode, new_addr);\n+\n+  if (extend != UNKNOWN)\n+    new_mem = gen_rtx_fmt_e (ZERO_EXTEND, extend_mode, new_mem);\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, addis_reg, addis_value));\n+  emit_insn (gen_rtx_SET (VOIDmode, target, new_mem));\n+\n+  if (extend == SIGN_EXTEND)\n+    {\n+      int sub_off = ((BYTES_BIG_ENDIAN)\n+\t\t     ? GET_MODE_SIZE (extend_mode) - GET_MODE_SIZE (target_mode)\n+\t\t     : 0);\n+      rtx sign_reg\n+\t= simplify_subreg (target_mode, target, extend_mode, sub_off);\n+\n+      emit_insn (gen_rtx_SET (VOIDmode, target,\n+\t\t\t      gen_rtx_SIGN_EXTEND (extend_mode, sign_reg)));\n+    }\n+\n+  return;\n+}\n+\n /* Return a string to fuse an addis instruction with a gpr load to the same\n    register that we loaded up the addis instruction.  The code is complicated,\n-   so we call output_asm_insn directly, and just return \"\".  */\n+   so we call output_asm_insn directly, and just return \"\".\n+\n+   The operands are:\n+\toperands[0]\tregister set with addis (must be same reg as target).\n+\toperands[1]\tvalue set via addis\n+\toperands[2]\ttarget register being loaded\n+\toperands[3]\tD-form memory reference using operands[0].  */\n \n const char *\n-emit_fusion_gpr_load (rtx addis_reg, rtx addis_value, rtx target, rtx mem)\n+emit_fusion_gpr_load (rtx *operands)\n {\n+  rtx addis_reg = operands[0];\n+  rtx addis_value = operands[1];\n+  rtx target = operands[2];\n+  rtx mem = operands[3];\n   rtx fuse_ops[10];\n   rtx addr;\n   rtx load_offset;\n   const char *addis_str = NULL;\n   const char *load_str = NULL;\n+  const char *extend_insn = NULL;\n   const char *mode_name = NULL;\n   char insn_template[80];\n-  enum machine_mode mode = GET_MODE (mem);\n+  enum machine_mode mode;\n   const char *comment_str = ASM_COMMENT_START;\n+  bool sign_p = false;\n+\n+  gcc_assert (REG_P (addis_reg) && REG_P (target));\n+  gcc_assert (REGNO (addis_reg) == REGNO (target));\n \n   if (*comment_str == ' ')\n     comment_str++;\n \n-  if (!MEM_P (mem))\n-    gcc_unreachable ();\n+  /* Allow sign/zero extension.  */\n+  if (GET_CODE (mem) == ZERO_EXTEND)\n+    mem = XEXP (mem, 0);\n+\n+  else if (GET_CODE (mem) == SIGN_EXTEND && TARGET_P8_FUSION_SIGN)\n+    {\n+      sign_p = true;\n+      mem = XEXP (mem, 0);\n+    }\n \n+  gcc_assert (MEM_P (mem));\n   addr = XEXP (mem, 0);\n   if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)\n     gcc_unreachable ();\n \n   load_offset = XEXP (addr, 1);\n \n   /* Now emit the load instruction to the same register.  */\n+  mode = GET_MODE (mem);\n   switch (mode)\n     {\n     case QImode:\n       mode_name = \"char\";\n       load_str = \"lbz\";\n+      extend_insn = \"extsb %0,%0\";\n       break;\n \n     case HImode:\n       mode_name = \"short\";\n       load_str = \"lhz\";\n+      extend_insn = \"extsh %0,%0\";\n       break;\n \n     case SImode:\n       mode_name = \"int\";\n       load_str = \"lwz\";\n+      extend_insn = \"extsw %0,%0\";\n       break;\n \n     case DImode:\n@@ -30541,22 +30646,20 @@ emit_fusion_gpr_load (rtx addis_reg, rtx addis_value, rtx target, rtx mem)\n \t  mode_name = \"long\";\n \t  load_str = \"ld\";\n \t}\n+      else\n+\tgcc_unreachable ();\n       break;\n \n     default:\n-      break;\n+      gcc_unreachable ();\n     }\n \n-  if (!load_str)\n-    gcc_unreachable ();\n-\n   /* Emit the addis instruction.  */\n   fuse_ops[0] = target;\n-  fuse_ops[1] = addis_reg;\n   if (satisfies_constraint_L (addis_value))\n     {\n-      fuse_ops[2] = addis_value;\n-      addis_str = \"lis %0,%v2\";\n+      fuse_ops[1] = addis_value;\n+      addis_str = \"lis %0,%v1\";\n     }\n \n   else if (GET_CODE (addis_value) == PLUS)\n@@ -30567,9 +30670,9 @@ emit_fusion_gpr_load (rtx addis_reg, rtx addis_value, rtx target, rtx mem)\n       if (REG_P (op0) && CONST_INT_P (op1)\n \t  && satisfies_constraint_L (op1))\n \t{\n-\t  fuse_ops[2] = op0;\n-\t  fuse_ops[3] = op1;\n-\t  addis_str = \"addis %0,%2,%v3\";\n+\t  fuse_ops[1] = op0;\n+\t  fuse_ops[2] = op1;\n+\t  addis_str = \"addis %0,%1,%v2\";\n \t}\n     }\n \n@@ -30578,13 +30681,13 @@ emit_fusion_gpr_load (rtx addis_reg, rtx addis_value, rtx target, rtx mem)\n       rtx value = XEXP (addis_value, 0);\n       if (GET_CODE (value) == UNSPEC && XINT (value, 1) == UNSPEC_TOCREL)\n \t{\n-\t  fuse_ops[2] = XVECEXP (value, 0, 0);\t\t/* symbol ref.  */\n-\t  fuse_ops[3] = XVECEXP (value, 0, 1);\t\t/* TOC register.  */\n+\t  fuse_ops[1] = XVECEXP (value, 0, 0);\t\t/* symbol ref.  */\n+\t  fuse_ops[2] = XVECEXP (value, 0, 1);\t\t/* TOC register.  */\n \t  if (TARGET_ELF)\n-\t    addis_str = \"addis %0,%3,%2@toc@ha\";\n+\t    addis_str = \"addis %0,%2,%1@toc@ha\";\n \n \t  else if (TARGET_XCOFF)\n-\t    addis_str = \"addis %0,%2@u(%3)\";\n+\t    addis_str = \"addis %0,%1@u(%2)\";\n \n \t  else\n \t    gcc_unreachable ();\n@@ -30599,14 +30702,14 @@ emit_fusion_gpr_load (rtx addis_reg, rtx addis_value, rtx target, rtx mem)\n \t      && XINT (op0, 1) == UNSPEC_TOCREL\n \t      && CONST_INT_P (op1))\n \t    {\n-\t      fuse_ops[2] = XVECEXP (op0, 0, 0);\t/* symbol ref.  */\n-\t      fuse_ops[3] = XVECEXP (op0, 0, 1);\t/* TOC register.  */\n-\t      fuse_ops[4] = op1;\n+\t      fuse_ops[1] = XVECEXP (op0, 0, 0);\t/* symbol ref.  */\n+\t      fuse_ops[2] = XVECEXP (op0, 0, 1);\t/* TOC register.  */\n+\t      fuse_ops[3] = op1;\n \t      if (TARGET_ELF)\n-\t\taddis_str = \"addis %0,%3,%2+%4@toc@ha\";\n+\t\taddis_str = \"addis %0,%2,%1+%3@toc@ha\";\n \n \t      else if (TARGET_XCOFF)\n-\t\taddis_str = \"addis %0,%2+%4@u(%3)\";\n+\t\taddis_str = \"addis %0,%1+%3@u(%2)\";\n \n \t      else\n \t\tgcc_unreachable ();\n@@ -30615,24 +30718,25 @@ emit_fusion_gpr_load (rtx addis_reg, rtx addis_value, rtx target, rtx mem)\n \n       else if (satisfies_constraint_L (value))\n \t{\n-\t  fuse_ops[2] = value;\n-\t  addis_str = \"lis %0,%v2\";\n+\t  fuse_ops[1] = value;\n+\t  addis_str = \"lis %0,%v1\";\n \t}\n \n       else if (TARGET_ELF && !TARGET_POWERPC64 && CONSTANT_P (value))\n \t{\n-\t  fuse_ops[2] = value;\n-\t  addis_str = \"lis %0,%2@ha\";\n+\t  fuse_ops[1] = value;\n+\t  addis_str = \"lis %0,%1@ha\";\n \t}\n     }\n \n   if (!addis_str)\n     fatal_insn (\"Could not generate addis value for fusion\", addis_value);\n \n-  sprintf (insn_template, \"%s\\t\\t%s gpr load fusion, type %s, addis reg %%1\",\n-\t   addis_str, comment_str, mode_name);\n+  sprintf (insn_template, \"%s\\t\\t%s gpr load fusion, type %s\", addis_str,\n+\t   comment_str, mode_name);\n   output_asm_insn (insn_template, fuse_ops);\n \n+  /* Emit the D-form load instruction.  */\n   if (CONST_INT_P (load_offset) && satisfies_constraint_I (load_offset))\n     {\n       sprintf (insn_template, \"%s %%0,%%1(%%0)\", load_str);\n@@ -30687,6 +30791,14 @@ emit_fusion_gpr_load (rtx addis_reg, rtx addis_value, rtx target, rtx mem)\n   else\n     fatal_insn (\"Unable to generate load offset for fusion\", load_offset);\n \n+  /* Handle sign extension.  The peephole2 pass generates this as a separate\n+     insn, but we handle it just in case it got reattached.  */\n+  if (sign_p)\n+    {\n+      gcc_assert (extend_insn != NULL);\n+      output_asm_insn (extend_insn, fuse_ops);\n+    }\n+\n   return \"\";\n }\n "}, {"sha": "637c5d368d94865d006777c1e1ab16abd9d27aa5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 14, "deletions": 85, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f758f2992f61a18b961a151e0e8b7bac68310356/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f758f2992f61a18b961a151e0e8b7bac68310356/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=f758f2992f61a18b961a151e0e8b7bac68310356", "patch": "@@ -136,7 +136,6 @@\n    UNSPEC_P8V_MTVSRD\n    UNSPEC_P8V_XXPERMDI\n    UNSPEC_P8V_RELOAD_FROM_VSX\n-   UNSPEC_FUSION_GPR\n   ])\n \n ;;\n@@ -15775,108 +15774,38 @@\n ;; a GPR.  The addis instruction must be adjacent to the load, and use the same\n ;; register that is being loaded.  The fused ops must be physically adjacent.\n \n-;; GPR fusion for single word integer types\n+;; We use define_peephole for the actual addis/load, and the register used to\n+;; hold the addis value must be the same as the register being loaded.  We use\n+;; define_peephole2 to change the register used for addis to be the register\n+;; being loaded, since we can look at whether it is dead after the load insn.\n \n (define_peephole\n   [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n \t(match_operand:P 1 \"fusion_gpr_addis\" \"\"))\n    (set (match_operand:INT1 2 \"base_reg_operand\" \"\")\n \t(match_operand:INT1 3 \"fusion_gpr_mem_load\" \"\"))]\n-  \"TARGET_P8_FUSION\n-   && fusion_gpr_load_p (operands[0], operands[1], operands[2], operands[3],\n-\t\t\t insn)\"\n+  \"TARGET_P8_FUSION && fusion_gpr_load_p (operands, false)\"\n {\n-  return emit_fusion_gpr_load (operands[0], operands[1], operands[2],\n-\t\t\t       operands[3]);\n+  return emit_fusion_gpr_load (operands);\n }\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"8\")])\n \n-(define_peephole\n-  [(set (match_operand:DI 0 \"base_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"fusion_gpr_addis\" \"\"))\n-   (set (match_operand:DI 2 \"base_reg_operand\" \"\")\n-\t(zero_extend:DI (match_operand:QHSI 3 \"fusion_gpr_mem_load\" \"\")))]\n-  \"TARGET_P8_FUSION && TARGET_POWERPC64\n-   && fusion_gpr_load_p (operands[0], operands[1], operands[2], operands[3],\n-\t\t\t insn)\"\n-{\n-  return emit_fusion_gpr_load (operands[0], operands[1], operands[2],\n-\t\t\t       operands[3]);\n-}\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n-;; Power8 does not fuse a sign extending load, so convert the sign extending\n-;; load into a zero extending load, and do an explicit sign extension.  Don't\n-;; do this if we are trying to optimize for space.  Do this as a peephole2 to\n-;; allow final rtl optimizations and scheduling to move the sign extend.\n (define_peephole2\n-  [(set (match_operand:DI 0 \"base_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"fusion_gpr_addis\" \"\"))\n-   (set (match_operand:DI 2 \"base_reg_operand\" \"\")\n-\t(sign_extend:DI (match_operand:HSI 3 \"fusion_gpr_mem_load\" \"\")))]\n-  \"TARGET_P8_FUSION && TARGET_P8_FUSION_SIGN && TARGET_POWERPC64\n-   && fusion_gpr_load_p (operands[0], operands[1], operands[2], operands[3],\n-\t\t\t NULL_RTX)\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 4) (match_dup 3))\n-   (set (match_dup 2) (sign_extend:DI (match_dup 4)))]\n-{\n-  unsigned int offset\n-    = (BYTES_BIG_ENDIAN ? 8 - GET_MODE_SIZE (<MODE>mode) : 0);\n-\n-  operands[4] = simplify_subreg (<MODE>mode, operands[2], DImode,\n-\t\t\t\t offset);\n-})\n-\n-(define_peephole\n   [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n \t(match_operand:P 1 \"fusion_gpr_addis\" \"\"))\n-   (set (match_operand:SI 2 \"base_reg_operand\" \"\")\n-\t(zero_extend:SI (match_operand:QHI 3 \"fusion_gpr_mem_load\" \"\")))]\n+   (set (match_operand:INT1 2 \"base_reg_operand\" \"\")\n+\t(match_operand:INT1 3 \"fusion_gpr_mem_load\" \"\"))]\n   \"TARGET_P8_FUSION\n-   && fusion_gpr_load_p (operands[0], operands[1], operands[2], operands[3],\n-\t\t\t insn)\"\n-{\n-  return emit_fusion_gpr_load (operands[0], operands[1], operands[2],\n-\t\t\t       operands[3]);\n-}\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_peephole2\n-  [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n-\t(match_operand:P 1 \"fusion_gpr_addis\" \"\"))\n-   (set (match_operand:SI 2 \"base_reg_operand\" \"\")\n-\t(sign_extend:SI (match_operand:HI 3 \"fusion_gpr_mem_load\" \"\")))]\n-  \"TARGET_P8_FUSION && TARGET_P8_FUSION_SIGN\n-   && fusion_gpr_load_p (operands[0], operands[1], operands[2], operands[3],\n-\t\t\t NULL_RTX)\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 4) (match_dup 3))\n-   (set (match_dup 2) (sign_extend:SI (match_dup 4)))]\n+   && (REGNO (operands[0]) != REGNO (operands[2])\n+       || GET_CODE (operands[3]) == SIGN_EXTEND)\n+   && fusion_gpr_load_p (operands, true)\"\n+  [(const_int 0)]\n {\n-  unsigned int offset = (BYTES_BIG_ENDIAN ? 2 : 0);\n-\n-  operands[4] = simplify_subreg (HImode, operands[2], SImode, offset);\n+  expand_fusion_gpr_load (operands);\n+  DONE;\n })\n \n-(define_peephole\n-  [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n-\t(match_operand:P 1 \"fusion_gpr_addis\" \"\"))\n-   (set (match_operand:HI 2 \"base_reg_operand\" \"\")\n-\t(zero_extend:HI (match_operand:QI 3 \"fusion_gpr_mem_load\" \"\")))]\n-  \"TARGET_P8_FUSION\n-   && fusion_gpr_load_p (operands[0], operands[1], operands[2], operands[3],\n-\t\t\t insn)\"\n-{\n-  return emit_fusion_gpr_load (operands[0], operands[1], operands[2],\n-\t\t\t       operands[3]);\n-}\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n \f\n \n (include \"sync.md\")"}]}