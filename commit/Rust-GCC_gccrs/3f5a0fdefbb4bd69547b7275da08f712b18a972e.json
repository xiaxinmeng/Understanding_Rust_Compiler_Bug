{"sha": "3f5a0fdefbb4bd69547b7275da08f712b18a972e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y1YTBmZGVmYmI0YmQ2OTU0N2I3Mjc1ZGEwOGY3MTJiMThhOTcyZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2018-11-15T13:22:15Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2018-11-15T13:22:15Z"}, "message": "[C++ DR 2336] Clean up synth walkers first\n\nhttps://gcc.gnu.org/ml/gcc-patches/2018-11/msg01376.html\n\t* cp-tree.h (enum special_function_kind): Reorder and comment.\n\t* method.c (SFK_CTOR_P, SFK_DTOR_P, SFK_ASSIGN_P, SFK_COPY_P)\n\t(SFK_MOVE_P): New predicates.\n\t(walk_field_subobs, synthesized_method_base_walk): Drop\n\tcopy_arg_p, move_p, assign_p args.  Use new SFK predicates.  Order\n\tparameters consistently.\n\t(synthesized_method_walk): Drop ctor_p, copy_arg_p, move_p,\n\tassign_p calculations.  Use new SFK predicates.  Adjust calls to\n\tworker functions.\n\nFrom-SVN: r266180", "tree": {"sha": "1d908115a1451ca2b4c7fedf642f79dfcfc55297", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d908115a1451ca2b4c7fedf642f79dfcfc55297"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f5a0fdefbb4bd69547b7275da08f712b18a972e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f5a0fdefbb4bd69547b7275da08f712b18a972e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f5a0fdefbb4bd69547b7275da08f712b18a972e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f5a0fdefbb4bd69547b7275da08f712b18a972e/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e99d38d0e1193a931741341af75a8c86ef654306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e99d38d0e1193a931741341af75a8c86ef654306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e99d38d0e1193a931741341af75a8c86ef654306"}], "stats": {"total": 161, "additions": 73, "deletions": 88}, "files": [{"sha": "f8efe7de9c726dffd4522cb8b16fb2b4b236f8f8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5a0fdefbb4bd69547b7275da08f712b18a972e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5a0fdefbb4bd69547b7275da08f712b18a972e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3f5a0fdefbb4bd69547b7275da08f712b18a972e", "patch": "@@ -1,3 +1,15 @@\n+2018-11-15  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (enum special_function_kind): Reorder and comment.\n+\t* method.c (SFK_CTOR_P, SFK_DTOR_P, SFK_ASSIGN_P, SFK_COPY_P)\n+\t(SFK_MOVE_P): New predicates.\n+\t(walk_field_subobs, synthesized_method_base_walk): Drop\n+\tcopy_arg_p, move_p, assign_p args.  Use new SFK predicates.  Order\n+\tparameters consistently.\n+\t(synthesized_method_walk): Drop ctor_p, copy_arg_p, move_p,\n+\tassign_p calculations.  Use new SFK predicates.  Adjust calls to\n+\tworker functions.\n+\n 2018-11-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* parser.c (make_id_declarator): Add location_t parameter."}, {"sha": "dbde05fb809a7031e3f587cf38d68705fd3041f4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5a0fdefbb4bd69547b7275da08f712b18a972e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5a0fdefbb4bd69547b7275da08f712b18a972e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3f5a0fdefbb4bd69547b7275da08f712b18a972e", "patch": "@@ -5084,20 +5084,22 @@ enum special_function_kind {\n   sfk_none = 0,\t\t   /* Not a special function.  This enumeral\n \t\t\t      must have value zero; see\n \t\t\t      special_function_p.  */\n+  /* The following are ordered, for use by member synthesis fns.  */\n+  sfk_destructor,\t   /* A destructor.  */\n   sfk_constructor,\t   /* A constructor.  */\n+  sfk_inheriting_constructor, /* An inheriting constructor */\n   sfk_copy_constructor,    /* A copy constructor.  */\n   sfk_move_constructor,    /* A move constructor.  */\n   sfk_copy_assignment,     /* A copy assignment operator.  */\n   sfk_move_assignment,     /* A move assignment operator.  */\n-  sfk_destructor,\t   /* A destructor.  */\n+  /* The following are unordered.  */\n   sfk_complete_destructor, /* A destructor for complete objects.  */\n   sfk_base_destructor,     /* A destructor for base subobjects.  */\n   sfk_deleting_destructor, /* A destructor for complete objects that\n \t\t\t      deletes the object after it has been\n \t\t\t      destroyed.  */\n   sfk_conversion,\t   /* A conversion operator.  */\n-  sfk_deduction_guide,\t   /* A class template deduction guide.  */\n-  sfk_inheriting_constructor /* An inheriting constructor */\n+  sfk_deduction_guide\t   /* A class template deduction guide.  */\n };\n \n /* The various kinds of linkage.  From [basic.link],"}, {"sha": "ebf14c52e099ac6822cfd93591d38798ec6209da", "filename": "gcc/cp/method.c", "status": "modified", "additions": 56, "deletions": 85, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5a0fdefbb4bd69547b7275da08f712b18a972e/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5a0fdefbb4bd69547b7275da08f712b18a972e/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=3f5a0fdefbb4bd69547b7275da08f712b18a972e", "patch": "@@ -1283,15 +1283,26 @@ process_subob_fn (tree fn, tree *spec_p, bool *trivial_p,\n     }\n }\n \n+/* Categorize various special_function_kinds.  */\n+#define SFK_CTOR_P(sfk) \\\n+  ((sfk) >= sfk_constructor && (sfk) <= sfk_move_constructor)\n+#define SFK_DTOR_P(sfk) \\\n+  ((sfk) == sfk_destructor)\n+#define SFK_ASSIGN_P(sfk) \\\n+  ((sfk) == sfk_copy_assignment || (sfk) == sfk_move_assignment)\n+#define SFK_COPY_P(sfk) \\\n+  ((sfk) == sfk_copy_constructor || (sfk) == sfk_copy_assignment)\n+#define SFK_MOVE_P(sfk) \\\n+  ((sfk) == sfk_move_constructor || (sfk) == sfk_move_assignment)\n+\n /* Subroutine of synthesized_method_walk to allow recursion into anonymous\n    aggregates.  If DTOR_FROM_CTOR is true, we're walking subobject destructors\n    called from a synthesized constructor, in which case we don't consider\n    the triviality of the subobject destructor.  */\n \n static void\n-walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n-\t\t   int quals, bool copy_arg_p, bool move_p,\n-\t\t   bool assign_p, tree *spec_p, bool *trivial_p,\n+walk_field_subobs (tree fields, special_function_kind sfk, tree fnname,\n+\t\t   int quals, tree *spec_p, bool *trivial_p,\n \t\t   bool *deleted_p, bool *constexpr_p,\n \t\t   bool diag, int flags, tsubst_flags_t complain,\n \t\t   bool dtor_from_ctor)\n@@ -1315,7 +1326,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \tbreak;\n \n       mem_type = strip_array_types (TREE_TYPE (field));\n-      if (assign_p)\n+      if (SFK_ASSIGN_P (sfk))\n \t{\n \t  bool bad = true;\n \t  if (CP_TYPE_CONST_P (mem_type) && !CLASS_TYPE_P (mem_type))\n@@ -1419,19 +1430,18 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \n       if (ANON_AGGR_TYPE_P (mem_type))\n \t{\n-\t  walk_field_subobs (TYPE_FIELDS (mem_type), fnname, sfk, quals,\n-\t\t\t     copy_arg_p, move_p, assign_p, spec_p, trivial_p,\n-\t\t\t     deleted_p, constexpr_p,\n+\t  walk_field_subobs (TYPE_FIELDS (mem_type), sfk, fnname, quals,\n+\t\t\t     spec_p, trivial_p, deleted_p, constexpr_p,\n \t\t\t     diag, flags, complain, dtor_from_ctor);\n \t  continue;\n \t}\n \n-      if (copy_arg_p)\n+      if (SFK_COPY_P (sfk) || SFK_MOVE_P (sfk))\n \t{\n \t  int mem_quals = cp_type_quals (mem_type) | quals;\n \t  if (DECL_MUTABLE_P (field))\n \t    mem_quals &= ~TYPE_QUAL_CONST;\n-\t  argtype = build_stub_type (mem_type, mem_quals, move_p);\n+\t  argtype = build_stub_type (mem_type, mem_quals, SFK_MOVE_P (sfk));\n \t}\n       else\n \targtype = NULL_TREE;\n@@ -1449,20 +1459,19 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n    synthesized_method_walk, or its local vars.  */\n \n static tree\n-synthesized_method_base_walk (tree binfo, tree base_binfo, \n-\t\t\t      int quals, bool copy_arg_p,\n-\t\t\t      bool move_p, bool ctor_p,\n+synthesized_method_base_walk (tree binfo, tree base_binfo,\n+\t\t\t      special_function_kind sfk, tree fnname, int quals,\n \t\t\t      tree *inheriting_ctor, tree inherited_parms,\n-\t\t\t      tree fnname, int flags, bool diag,\n+\t\t\t      int flags, bool diag,\n \t\t\t      tree *spec_p, bool *trivial_p,\n \t\t\t      bool *deleted_p, bool *constexpr_p)\n {\n   bool inherited_binfo = false;\n   tree argtype = NULL_TREE;\n   deferring_kind defer = dk_no_deferred;\n \n-  if (copy_arg_p)\n-    argtype = build_stub_type (BINFO_TYPE (base_binfo), quals, move_p);\n+  if (SFK_COPY_P (sfk) || SFK_MOVE_P (sfk))\n+    argtype = build_stub_type (BINFO_TYPE (base_binfo), quals, SFK_MOVE_P (sfk));\n   else if (inheriting_ctor\n \t   && (inherited_binfo\n \t       = binfo_inherited_from (binfo, base_binfo, *inheriting_ctor)))\n@@ -1495,7 +1504,7 @@ synthesized_method_base_walk (tree binfo, tree base_binfo,\n \n   process_subob_fn (rval, spec_p, trivial_p, deleted_p,\n \t\t    constexpr_p, diag, BINFO_TYPE (base_binfo));\n-  if (ctor_p &&\n+  if (SFK_CTOR_P (sfk) &&\n       (!BINFO_VIRTUAL_P (base_binfo)\n        || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo))))\n     {\n@@ -1529,9 +1538,13 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t\t\t bool *constexpr_p, bool diag,\n \t\t\t tree *inheriting_ctor, tree inherited_parms)\n {\n-  tree binfo, base_binfo, fnname;\n+  tree binfo, base_binfo;\n   int i;\n \n+  /* SFK must be exactly one category.  */\n+  gcc_checking_assert (SFK_DTOR_P(sfk) + SFK_CTOR_P(sfk)\n+\t\t       + SFK_ASSIGN_P(sfk) == 1);\n+\n   if (spec_p)\n     *spec_p = (cxx_dialect >= cxx11 ? noexcept_true_spec : empty_except_spec);\n \n@@ -1556,35 +1569,20 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n       *deleted_p = false;\n     }\n \n-  bool ctor_p = false;\n-  bool assign_p = false;\n   bool check_vdtor = false;\n-  switch (sfk)\n-    {\n-    case sfk_move_assignment:\n-    case sfk_copy_assignment:\n-      assign_p = true;\n-      fnname = assign_op_identifier;\n-      break;\n+  tree fnname;\n \n-    case sfk_destructor:\n+if (SFK_DTOR_P (sfk))\n+    {\n       check_vdtor = true;\n       /* The synthesized method will call base dtors, but check complete\n \t here to avoid having to deal with VTT.  */\n       fnname = complete_dtor_identifier;\n-      break;\n-\n-    case sfk_constructor:\n-    case sfk_move_constructor:\n-    case sfk_copy_constructor:\n-    case sfk_inheriting_constructor:\n-      ctor_p = true;\n-      fnname = complete_ctor_identifier;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n     }\n+  else if (SFK_ASSIGN_P (sfk))\n+    fnname = assign_op_identifier;\n+  else\n+    fnname = complete_ctor_identifier;\n \n   gcc_assert ((sfk == sfk_inheriting_constructor)\n \t      == (inheriting_ctor && *inheriting_ctor != NULL_TREE));\n@@ -1601,29 +1599,8 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \tthereof), the assignment operator selected to copy/move that\n \tmember is a constexpr function.  */\n   if (constexpr_p)\n-    *constexpr_p = ctor_p || (assign_p && cxx_dialect >= cxx14);\n-\n-  bool move_p = false;\n-  bool copy_arg_p = false;\n-  switch (sfk)\n-    {\n-    case sfk_constructor:\n-    case sfk_destructor:\n-    case sfk_inheriting_constructor:\n-      break;\n-\n-    case sfk_move_constructor:\n-    case sfk_move_assignment:\n-      move_p = true;\n-      /* FALLTHRU */\n-    case sfk_copy_constructor:\n-    case sfk_copy_assignment:\n-      copy_arg_p = true;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n+    *constexpr_p = (SFK_CTOR_P (sfk)\n+\t\t    || (SFK_ASSIGN_P (sfk) && cxx_dialect >= cxx14));\n \n   bool expected_trivial = type_has_trivial_fn (ctype, sfk);\n   if (trivial_p)\n@@ -1640,7 +1617,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n      resolution, so a constructor can be trivial even if it would otherwise\n      call a non-trivial constructor.  */\n   if (expected_trivial\n-      && (!copy_arg_p || cxx_dialect < cxx11))\n+      && (!(SFK_COPY_P (sfk) || SFK_MOVE_P (sfk)) || cxx_dialect < cxx11))\n     {\n       if (constexpr_p && sfk == sfk_constructor)\n \t{\n@@ -1675,19 +1652,17 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n   for (binfo = TYPE_BINFO (ctype), i = 0;\n        BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n     {\n-      if (!assign_p && BINFO_VIRTUAL_P (base_binfo))\n+      if (!SFK_ASSIGN_P (sfk) && BINFO_VIRTUAL_P (base_binfo))\n \t/* We'll handle virtual bases below.  */\n \tcontinue;\n \n-      tree fn = synthesized_method_base_walk (binfo, base_binfo, quals,\n-\t\t\t\t\t      copy_arg_p, move_p, ctor_p,\n-\t\t\t\t\t      inheriting_ctor,\n-\t\t\t\t\t      inherited_parms,\n-\t\t\t\t\t      fnname, flags, diag,\n-\t\t\t\t\t      spec_p, trivial_p,\n+      tree fn = synthesized_method_base_walk (binfo, base_binfo,\n+\t\t\t\t\t      sfk, fnname, quals,\n+\t\t\t\t\t      inheriting_ctor, inherited_parms,\n+\t\t\t\t\t      flags, diag, spec_p, trivial_p,\n \t\t\t\t\t      deleted_p, constexpr_p);\n \n-      if (diag && assign_p && move_p\n+      if (diag && SFK_ASSIGN_P (sfk) && SFK_MOVE_P (sfk)\n \t  && BINFO_VIRTUAL_P (base_binfo)\n \t  && fn && TREE_CODE (fn) == FUNCTION_DECL\n \t  && move_fn_p (fn) && !trivial_fn_p (fn)\n@@ -1716,7 +1691,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n     }\n \n   vec<tree, va_gc> *vbases = CLASSTYPE_VBASECLASSES (ctype);\n-  if (assign_p)\n+  if (SFK_ASSIGN_P (sfk))\n     /* Already examined vbases above.  */;\n   else if (vec_safe_is_empty (vbases))\n     /* No virtual bases to worry about.  */;\n@@ -1734,24 +1709,20 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t*constexpr_p = false;\n \n       FOR_EACH_VEC_ELT (*vbases, i, base_binfo)\n-\tsynthesized_method_base_walk (binfo, base_binfo, quals,\n-\t\t\t\t      copy_arg_p, move_p, ctor_p,\n+\tsynthesized_method_base_walk (binfo, base_binfo, sfk, fnname, quals,\n \t\t\t\t      inheriting_ctor, inherited_parms,\n-\t\t\t\t      fnname, flags, diag,\n-\t\t\t\t      spec_p, trivial_p,\n-\t\t\t\t      deleted_p, constexpr_p);\n+\t\t\t\t      flags, diag,\n+\t\t\t\t      spec_p, trivial_p, deleted_p, constexpr_p);\n     }\n \n   /* Now handle the non-static data members.  */\n-  walk_field_subobs (TYPE_FIELDS (ctype), fnname, sfk, quals,\n-\t\t     copy_arg_p, move_p, assign_p, spec_p, trivial_p,\n-\t\t     deleted_p, constexpr_p,\n+  walk_field_subobs (TYPE_FIELDS (ctype), sfk, fnname, quals,\n+\t\t     spec_p, trivial_p, deleted_p, constexpr_p,\n \t\t     diag, flags, complain, /*dtor_from_ctor*/false);\n-  if (ctor_p)\n-    walk_field_subobs (TYPE_FIELDS (ctype), complete_dtor_identifier,\n-\t\t       sfk_destructor, TYPE_UNQUALIFIED, false,\n-\t\t       false, false, NULL, NULL,\n-\t\t       deleted_p, NULL,\n+  if (SFK_CTOR_P (sfk))\n+    walk_field_subobs (TYPE_FIELDS (ctype), sfk_destructor,\n+\t\t       complete_dtor_identifier, TYPE_UNQUALIFIED,\n+\t\t       NULL, NULL, deleted_p, NULL,\n \t\t       false, flags, complain, /*dtor_from_ctor*/true);\n \n   pop_scope (scope);"}]}