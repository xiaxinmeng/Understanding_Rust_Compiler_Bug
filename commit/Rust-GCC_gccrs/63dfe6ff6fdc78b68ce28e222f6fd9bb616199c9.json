{"sha": "63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNkZmU2ZmY2ZmRjNzhiNjhjZTI4ZTIyMmY2ZmQ5YmI2MTYxOTljOQ==", "commit": {"author": {"name": "Dorit Naishlos", "email": "dorit@il.ibm.com", "date": "2004-11-19T19:39:40Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-11-19T19:39:40Z"}, "message": "re PR tree-optimization/18181 (vectorizer: problem in the peeling mechanism in the presence of loop invariants that are used after the loop)\n\n        PR tree-opt/18181\n        * tree-vectorizer.c (slpeel_tree_peel_loop_to_edge): Peeling scheme\n        changed to suppoer uses-after-loop and to void creating flow paths\n        that shouldn't exist.\n        (slpeel_update_phi_nodes_for_guard): Takes additional two arguments.\n        Modified to fit the new peeling scheme. Avoid quadratic behavior.\n        (slpeel_add_loop_guard): Takes additional argument.\n        (slpeel_verify_cfg_after_peeling): New function.\n        (vect_update_ivs_after_vectorizer): Takes additional argument. Updated\n        documentation. Use 'exit-bb' instead of creating 'new-bb'.\n        (rename_variables_in_bb): Don't update phis for BBs out of loop, to fit\n        the new peeling scheme.\n        (copy_phi_nodes): Function removed. Its functionality moved to\n        update_phis_for_duplicate_loop.\n        (slpeel_update_phis_for_duplicate_loop): Functionality of copy_phi_nodes\n        moved here. Added documentation. Modified to fit the new peeling scheme.\n        (slpeel_make_loop_iterate_ntimes): Setting loop->single_exit not not\n        needed - done in slpeel_tree_peel_loop_to_edge.\n        (slpeel_tree_duplicate_loop_to_edge_cfg): Debug printouts compacted.\n        (vect_do_peeling_for_loop_bound): Add documentation. Call\n        slpeel_verify_cfg_after_peeling. Call vect_update_ivs_after_vectorizer\n        with additional argument.\n        (vect_do_peeling_for_alignment): Call slpeel_verify_cfg_after_peeling.\n\n        (vect_finish_stmt_generation): Avoid 80 column oveflow.\n\nFrom-SVN: r90932", "tree": {"sha": "13edb3a9ae038b16cd0283198b9667757f2ba2fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13edb3a9ae038b16cd0283198b9667757f2ba2fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/comments", "author": null, "committer": null, "parents": [{"sha": "335d3d5495500663c42f1aec13694c48782a9996", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/335d3d5495500663c42f1aec13694c48782a9996", "html_url": "https://github.com/Rust-GCC/gccrs/commit/335d3d5495500663c42f1aec13694c48782a9996"}], "stats": {"total": 964, "additions": 651, "deletions": 313}, "files": [{"sha": "9026a1d7ec5b8298e1eae8d611f299121269c45d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9", "patch": "@@ -1,3 +1,31 @@\n+2004-11-19  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\tPR tree-opt/18181\n+\t* tree-vectorizer.c (slpeel_tree_peel_loop_to_edge): Peeling scheme\n+\tchanged to suppoer uses-after-loop and to void creating flow paths\n+\tthat shouldn't exist.\n+\t(slpeel_update_phi_nodes_for_guard): Takes additional two arguments.\n+\tModified to fit the new peeling scheme. Avoid quadratic behavior.\n+\t(slpeel_add_loop_guard): Takes additional argument.\n+\t(slpeel_verify_cfg_after_peeling): New function.\n+\t(vect_update_ivs_after_vectorizer): Takes additional argument. Updated\n+\tdocumentation. Use 'exit-bb' instead of creating 'new-bb'.\n+\t(rename_variables_in_bb): Don't update phis for BBs out of loop, to fit\n+\tthe new peeling scheme.\n+\t(copy_phi_nodes): Function removed. Its functionality moved to\n+\tupdate_phis_for_duplicate_loop.\n+\t(slpeel_update_phis_for_duplicate_loop): Functionality of copy_phi_nodes\n+\tmoved here. Added documentation. Modified to fit the new peeling scheme.\n+\t(slpeel_make_loop_iterate_ntimes): Setting loop->single_exit not not\n+\tneeded - done in slpeel_tree_peel_loop_to_edge.\n+\t(slpeel_tree_duplicate_loop_to_edge_cfg): Debug printouts compacted.\n+\t(vect_do_peeling_for_loop_bound): Add documentation. Call\n+\tslpeel_verify_cfg_after_peeling. Call vect_update_ivs_after_vectorizer\n+\twith additional argument.\n+\t(vect_do_peeling_for_alignment): Call slpeel_verify_cfg_after_peeling.\n+\n+\t(vect_finish_stmt_generation): Avoid 80 column oveflow.\n+\n 2004-11-19  Dorit Naishlos  <dorit@il.ibm.com>\n \n \t* tree-vectorizer.c (slpeel_make_loop_iterate_ntimes): Last two"}, {"sha": "b08e0561e7676cd4e39bf6dde6d3a88a11816cd2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9", "patch": "@@ -1,3 +1,11 @@\n+2004-11-19  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\tPR tree-opt/18181\n+\t* gcc.dg/vect/vect-85.c: New test.\n+\t* gcc.dg/vect/vect-86.c: New test.\n+\t* gcc.dg/vect/vect-87.c: New test.\n+\t* gcc.dg/vect/vect-88.c: New test.\n+\n 2004-11-19  Ben Elliston  <bje@au.ibm.com>\n \n \t* gcc.dg/pr16286.c: Test __pixel and __bool keywords."}, {"sha": "26063e8f155d63668c47fad53a04249c0555474e", "filename": "gcc/testsuite/gcc.dg/vect/vect-85.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-85.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-85.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-85.c?ref=63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+typedef int aint __attribute__ ((__aligned__(16)));\n+\n+int main1 (int *a)\n+{\n+  int i, j, k;\n+  int b[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      for (j = 0; j < N; j++)\n+        {\n+\t  k = i + N;\n+          a[j] = k;\n+        }\n+      b[i] = k;\n+    }\n+\n+\n+  for (j = 0; j < N; j++)\n+    if (a[j] != i + N - 1)\n+      abort();\t\n+\n+  for (j = 0; j < N; j++)\n+    if (b[j] != j + N)\n+      abort();\t\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  aint a[N];\n+\n+  check_vect ();\n+\n+  main1 (a);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */"}, {"sha": "9caa887b9fc3d67a6d6e43271f6da99cbe74bd9a", "filename": "gcc/testsuite/gcc.dg/vect/vect-86.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-86.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-86.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-86.c?ref=63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+int main1 (int n)\n+{\n+  int i, j, k;\n+  int a[N], b[N];\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      for (j = 0; j < n; j++)\n+        {\n+\t  k = i + n;\n+          a[j] = k;\n+        }\n+      b[i] = k;\n+    }\n+\n+\n+  for (j = 0; j < n; j++)\n+    if (a[j] != i + n - 1)\n+      abort();\t\n+\n+  for (i = 0; i < n; i++)\n+    if (b[i] != i + n)\n+      abort();\t\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+\n+  main1 (N);\n+  main1 (0);\n+  main1 (1);\n+  main1 (2);\n+  main1 (N-1);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "546178f8788e25d4084a23521734ed1cbb59dc88", "filename": "gcc/testsuite/gcc.dg/vect/vect-87.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-87.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-87.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-87.c?ref=63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+typedef int aint __attribute__ ((__aligned__(16)));\n+\n+int main1 (int n, int *a)\n+{\n+  int i, j, k;\n+  int b[N];\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      for (j = 0; j < n; j++)\n+        {\n+\t  k = i + n;\n+          a[j] = k;\n+        }\n+      b[i] = k;\n+    }\n+\n+\n+  for (j = 0; j < n; j++)\n+    if (a[j] != i + n - 1)\n+      abort();\t\n+\n+  for (j = 0; j < n; j++)\n+    if (b[j] != j + n)\n+      abort();\t\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  aint a[N];\n+\n+  check_vect ();\n+\n+  main1 (N, a);\n+  main1 (0, a);\n+  main1 (1, a);\n+  main1 (2, a);\n+  main1 (N-1, a);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "59984eaba4263d571eceea67ae26f04d90cfb7ac", "filename": "gcc/testsuite/gcc.dg/vect/vect-88.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-88.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-88.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-88.c?ref=63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+typedef int aint __attribute__ ((__aligned__(16)));\n+\n+int main1 (int n, int *a)\n+{\n+  int i, j, k;\n+  int b[N];\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      for (j = 0; j < n; j++)\n+        {\n+\t  k = i + n;\n+          a[j] = k;\n+        }\n+      b[i] = k;\n+    }\n+\n+\n+  for (j = 0; j < n; j++)\n+    if (a[j] != i + n - 1)\n+      abort();\t\n+\n+  for (j = 0; j < n; j++)\n+    if (b[j] != j + n)\n+      abort();\t\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  aint a[N+1];\n+\n+  check_vect ();\n+\n+  main1 (N, a+1);\n+  main1 (0, a+1);\n+  main1 (1, a+1);\n+  main1 (2, a+1);\n+  main1 (N-1, a+1);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "4430e18da66c2fe6be0cd0d94483a2614b723a4c", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 415, "deletions": 313, "changes": 728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=63dfe6ff6fdc78b68ce28e222f6fd9bb616199c9", "patch": "@@ -164,10 +164,11 @@ static struct loop *slpeel_tree_duplicate_loop_to_edge_cfg\n   (struct loop *, struct loops *, edge);\n static void slpeel_update_phis_for_duplicate_loop \n   (struct loop *, struct loop *, bool after);\n-static void slpeel_update_phi_nodes_for_guard (edge, struct loop *);\n+static void slpeel_update_phi_nodes_for_guard (edge, struct loop *, bool, bool);\n static void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n-static edge slpeel_add_loop_guard (basic_block, tree, basic_block);\n+static edge slpeel_add_loop_guard (basic_block, tree, basic_block, basic_block);\n static bool slpeel_can_duplicate_loop_p (struct loop *, edge);\n+static void slpeel_verify_cfg_after_peeling (struct loop *, struct loop *);\n static void allocate_new_names (bitmap);\n static void rename_use_op (use_operand_p);\n static void rename_def_op (def_operand_p, tree);\n@@ -249,7 +250,7 @@ static void vect_finish_stmt_generation\n static void vect_generate_tmps_on_preheader \n   (loop_vec_info, tree *, tree *, tree *);\n static tree vect_build_loop_niters (loop_vec_info);\n-static void vect_update_ivs_after_vectorizer (struct loop *, tree); \n+static void vect_update_ivs_after_vectorizer (struct loop *, tree, edge); \n static tree vect_gen_niters_for_prolog_loop (loop_vec_info, tree);\n static void vect_update_inits_of_dr \n   (struct data_reference *, struct loop *, tree niters);\n@@ -360,6 +361,7 @@ rename_variables_in_bb (basic_block bb)\n   unsigned i;\n   edge e;\n   edge_iterator ei;\n+  struct loop *loop = bb->loop_father;\n \n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     rename_def_op (PHI_RESULT_PTR (phi), phi);\n@@ -398,8 +400,12 @@ rename_variables_in_bb (basic_block bb)\n     }\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n-    for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n-      rename_use_op (PHI_ARG_DEF_PTR_FROM_EDGE (phi, e));\n+    {\n+      if (!flow_bb_inside_loop_p (loop, e->dest))\n+\tcontinue;\n+      for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n+        rename_use_op (PHI_ARG_DEF_PTR_FROM_EDGE (phi, e));\n+    }\n }\n \n \n@@ -441,165 +447,204 @@ rename_variables_in_loop (struct loop *loop)\n }\n \n \n-/* This function copies phis from LOOP header to\n-   NEW_LOOP header. AFTER is as\n-   in update_phis_for_duplicate_loop function.  */\n-\n-static void\n-copy_phi_nodes (struct loop *loop, struct loop *new_loop,\n-\t\t      bool after)\n-{\n-  tree phi, new_phi, def;\n-  edge new_e;\n-  edge e = (after ? loop_latch_edge (loop) : loop_preheader_edge (loop));\n-\n-  /* Second add arguments to newly created phi nodes.  */\n-  for (phi = phi_nodes (loop->header),\n-\t new_phi = phi_nodes (new_loop->header);\n-       phi;\n-       phi = PHI_CHAIN (phi),\n-\t new_phi = PHI_CHAIN (new_phi))\n-    {\n-      new_e = loop_preheader_edge (new_loop);\n-      def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n-      add_phi_arg (&new_phi, def, new_e);\n-    }\n-}\n-\n+/* Update the PHI nodes of NEW_LOOP.\n \n-/* Update the PHI nodes of the NEW_LOOP. AFTER is true if the NEW_LOOP\n-   executes after LOOP, and false if it executes before it.  */\n+   NEW_LOOP is a duplicate of ORIG_LOOP.\n+   AFTER indicates whether NEW_LOOP executes before or after ORIG_LOOP:\n+   AFTER is true if NEW_LOOP executes after ORIG_LOOP, and false if it\n+   executes before it.  */\n \n static void\n-slpeel_update_phis_for_duplicate_loop (struct loop *loop,\n+slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n \t\t\t\t       struct loop *new_loop, bool after)\n {\n-  edge old_latch;\n   tree *new_name_ptr, new_ssa_name;\n-  tree phi_new, phi_old, def;\n-  edge orig_entry_e = loop_preheader_edge (loop);\n+  tree phi_new, phi_orig;\n+  tree def;\n+  edge orig_loop_latch = loop_latch_edge (orig_loop);\n+  edge orig_entry_e = loop_preheader_edge (orig_loop);\n+  edge new_loop_exit_e = new_loop->exit_edges[0];\n+  edge new_loop_entry_e = loop_preheader_edge (new_loop);\n+  edge entry_arg_e = (after ? orig_loop_latch : orig_entry_e);\n \n-  /* Copy phis from loop->header to new_loop->header.  */\n-  copy_phi_nodes (loop, new_loop, after);\n+  /*\n+     step 1. For each loop-header-phi:\n+             Add the first phi argument for the phi in NEW_LOOP\n+            (the one associated with the entry of NEW_LOOP)\n+\n+     step 2. For each loop-header-phi:\n+             Add the second phi argument for the phi in NEW_LOOP\n+            (the one associated with the latch of NEW_LOOP)\n+\n+     step 3. Update the phis in the successor block of NEW_LOOP.\n+\n+        case 1: NEW_LOOP was placed before ORIG_LOOP:\n+                The successor block of NEW_LOOP is the header of ORIG_LOOP.\n+                Updating the phis in the successor block can therefore be done\n+                along with the scanning of the loop header phis, because the\n+                header blocks of ORIG_LOOP and NEW_LOOP have exactly the same\n+                phi nodes, organized in the same order.\n+\n+        case 2: NEW_LOOP was placed after ORIG_LOOP:\n+                The successor block of NEW_LOOP is the original exit block of \n+                ORIG_LOOP - the phis to be updated are the loop-closed-ssa phis.\n+                We postpone updating these phis to a later stage (when\n+                loop guards are added).\n+   */\n \n-  old_latch = loop_latch_edge (loop);\n \n-  /* Update PHI args for the new loop latch edge, and\n-     the old loop preheader edge, we know that the PHI nodes\n-     are ordered appropriately in copy_phi_nodes.  */\n+  /* Scan the phis in the headers of the old and new loops\n+     (they are organized in exactly the same order).  */\n+\n   for (phi_new = phi_nodes (new_loop->header),\n-       phi_old = phi_nodes (loop->header);\n-       phi_new && phi_old;\n-       phi_new = PHI_CHAIN (phi_new), phi_old = PHI_CHAIN (phi_old))\n+       phi_orig = phi_nodes (orig_loop->header);\n+       phi_new && phi_orig;\n+       phi_new = PHI_CHAIN (phi_new), phi_orig = PHI_CHAIN (phi_orig))\n     {\n-      def = PHI_ARG_DEF_FROM_EDGE (phi_old, old_latch);\n+      /* step 1.  */\n+      def = PHI_ARG_DEF_FROM_EDGE (phi_orig, entry_arg_e);\n+      add_phi_arg (&phi_new, def, new_loop_entry_e);\n \n+      /* step 2.  */\n+      def = PHI_ARG_DEF_FROM_EDGE (phi_orig, orig_loop_latch);\n       if (TREE_CODE (def) != SSA_NAME)\n-\tcontinue;\n+        continue;\n \n       new_name_ptr = SSA_NAME_AUX (def);\n-\n-      /* Something defined outside of the loop.  */\n       if (!new_name_ptr)\n-\tcontinue;\n+        /* Something defined outside of the loop.  */\n+        continue;\n \n       /* An ordinary ssa name defined in the loop.  */\n       new_ssa_name = *new_name_ptr;\n+      add_phi_arg (&phi_new, new_ssa_name, loop_latch_edge (new_loop));\n \n-      add_phi_arg (&phi_new, new_ssa_name, loop_latch_edge(new_loop));\n-\n-      /* Update PHI args for the original loop pre-header edge.  */\n-      if (! after)\n-        SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi_old, orig_entry_e),\n-\t         new_ssa_name);\n+      /* step 3 (case 1).  */\n+      if (!after)\n+        {\n+          gcc_assert (new_loop_exit_e == orig_entry_e);\n+          SET_PHI_ARG_DEF (phi_orig,\n+                           phi_arg_from_edge (phi_orig, new_loop_exit_e),\n+                           new_ssa_name);\n+        }\n     }\n }\n \n \n /* Update PHI nodes for a guard of the LOOP.\n \n-   LOOP is supposed to have a preheader bb at which a guard condition is \n-   located.  The true edge of this condition skips the LOOP and ends\n-   at the destination of the (unique) LOOP exit.  The loop exit bb is supposed \n-   to be an empty bb (created by this transformation) with one successor.\n-\n-   This function creates phi nodes at the LOOP exit bb.  These phis need to be\n-   created as a result of adding true edge coming from guard.\n-\n-   FORNOW: Only phis which have corresponding phi nodes at the header of the\n-   LOOP are created.  Here we use the assumption that after the LOOP there\n-   are no uses of defs generated in LOOP.\n-\n-   After the phis creation, the function updates the values of phi nodes at\n-   the LOOP exit successor bb:\n-\n-   Original loop:\n-\n-   bb0: loop preheader\n-        goto bb1\n-   bb1: loop header\n-        if (exit_cond) goto bb3 else goto bb2\n-   bb2: loop latch\n-        goto bb1\n-   bb3:\n-\n-\n-   After guard creation (the loop before this function):\n-\n-   bb0: loop preheader\n-        if (guard_condition) goto bb4 else goto bb1\n-   bb1: loop header\n-        if (exit_cond) goto bb4 else goto bb2\n-   bb2: loop latch\n-        goto bb1\n-   bb4: loop exit       \n-        (new empty bb)\n-        goto bb3\n-   bb3:\n-\n-   This function updates the phi nodes in bb4 and in bb3, to account for the \n-   new edge from bb0 to bb4.  */\n+   Input:\n+   - LOOP, GUARD_EDGE: LOOP is a loop for which we added guard code that\n+        controls whether LOOP is to be executed.  GUARD_EDGE is the edge that\n+        originates from the guard-bb, skips LOOP and reaches the (unique) exit\n+        bb of LOOP.  This loop-exit-bb is an empty bb with one successor.\n+        We denote this bb NEW_MERGE_BB because it had a single predecessor (the\n+        LOOP header) before the guard code was added, and now it became a merge\n+        point of two paths - the path that ends with the LOOP exit-edge, and\n+        the path that ends with GUARD_EDGE.\n+\n+        This function creates and updates the relevant phi nodes to account for\n+        the new incoming edge (GUARD_EDGE) into NEW_MERGE_BB:\n+        1. Create phi nodes at NEW_MERGE_BB.\n+        2. Update the phi nodes at the successor of NEW_MERGE_BB (denoted\n+           UPDATE_BB).  UPDATE_BB was the exit-bb of LOOP before NEW_MERGE_BB\n+           was added:\n+\n+        ===> The CFG before the guard-code was added:\n+        LOOP_header_bb:\n+          if (exit_loop) goto update_bb : LOOP_header_bb\n+        update_bb:\n+\n+        ==> The CFG after the guard-code was added:\n+        guard_bb: \n+          if (LOOP_guard_condition) goto new_merge_bb : LOOP_header_bb\n+        LOOP_header_bb:\n+          if (exit_loop_condition) goto new_merge_bb : LOOP_header_bb\n+        new_merge_bb:\n+          goto update_bb\n+        update_bb:\n+\n+   - ENTRY_PHIS: If ENTRY_PHIS is TRUE, this indicates that the phis in \n+        UPDATE_BB are loop entry phis, like the phis in the LOOP header,\n+        organized in the same order. \n+        If ENTRY_PHIs is FALSE, this indicates that the phis in UPDATE_BB are\n+        loop exit phis.\n+\n+   - IS_NEW_LOOP: TRUE if LOOP is a new loop (a duplicated copy of another\n+        \"original\" loop).  FALSE if LOOP is an original loop (not a newly \n+        created copy).  The SSA_NAME_AUX fields of the defs in the origianl\n+        loop are the corresponding new ssa-names used in the new duplicated\n+        loop copy.  IS_NEW_LOOP indicates which of the two args of the phi \n+        nodes in UPDATE_BB takes the original ssa-name, and which takes the \n+        new name: If IS_NEW_LOOP is TRUE, the phi-arg that is associated with\n+        the LOOP-exit-edge takes the new-name, and the phi-arg that is \n+        associated with GUARD_EDGE takes the original name.  If IS_NEW_LOOP is\n+        FALSE, it's the other way around.\n+  */\n \n static void\n-slpeel_update_phi_nodes_for_guard (edge guard_true_edge, struct loop * loop)\n+slpeel_update_phi_nodes_for_guard (edge guard_edge, \n+\t\t\t\t   struct loop *loop,\n+\t\t\t\t   bool entry_phis,\n+\t\t\t\t   bool is_new_loop)\n {\n-  tree phi, phi1;\n-  basic_block bb = loop->exit_edges[0]->dest;\n-\n-  for (phi = phi_nodes (loop->header); phi; phi = PHI_CHAIN (phi))\n-      {\n-\ttree new_phi;\n-\ttree phi_arg;\n-\n-\t/* Generate new phi node.  */\n-\tnew_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (phi)), bb);\n+  tree orig_phi, new_phi, update_phi;\n+  tree guard_arg, loop_arg;\n+  basic_block new_merge_bb = guard_edge->dest;\n+  edge e = EDGE_SUCC (new_merge_bb, 0);\n+  basic_block update_bb = e->dest;\n+  basic_block orig_bb = (entry_phis ? loop->header : update_bb);\n+\n+  for (orig_phi = phi_nodes (orig_bb), update_phi = phi_nodes (update_bb);\n+       orig_phi && update_phi;\n+       orig_phi = PHI_CHAIN (orig_phi), update_phi = PHI_CHAIN (update_phi))\n+    {\n+      /* 1. Generate new phi node in NEW_MERGE_BB:  */\n+      new_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (orig_phi)),\n+                                 new_merge_bb);\n+\n+      /* 2. NEW_MERGE_BB has two incoming edges: GUARD_EDGE and the exit-edge\n+            of LOOP. Set the two phi args in NEW_PHI for these edges:  */\n+      if (entry_phis)\n+        {\n+          loop_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi,\n+                                            EDGE_SUCC (loop->latch, 0));\n+          guard_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, loop->entry_edges[0]);\n+        }\n+      else /* exit phis */\n+        {\n+          tree orig_def = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n+          tree *new_name_ptr = SSA_NAME_AUX (orig_def);\n+          tree new_name;\n+\n+          if (new_name_ptr)\n+            new_name = *new_name_ptr;\n+          else\n+            /* Something defined outside of the loop  */\n+            new_name = orig_def;\n+\n+          if (is_new_loop)\n+            {\n+              guard_arg = orig_def;\n+              loop_arg = new_name;\n+            }\n+          else\n+            {\n+              guard_arg = new_name;\n+              loop_arg = orig_def;\n+            }\n+        }\n+      add_phi_arg (&new_phi, loop_arg, loop->exit_edges[0]);\n+      add_phi_arg (&new_phi, guard_arg, guard_edge);\n \n-\t/* Add argument coming from guard true edge.  */\n-\tphi_arg = PHI_ARG_DEF_FROM_EDGE (phi, loop->entry_edges[0]);\n-\tadd_phi_arg (&new_phi, phi_arg, guard_true_edge);\n+      /* 3. Update phi in successor block.  */\n+      gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi, e) == loop_arg\n+                  || PHI_ARG_DEF_FROM_EDGE (update_phi, e) == guard_arg);\n+      SET_PHI_ARG_DEF (update_phi, phi_arg_from_edge (update_phi, e),\n+                       PHI_RESULT (new_phi));\n+    }\n \n-\t/* Add argument coming from loop exit edge.  */\n-\tphi_arg = PHI_ARG_DEF_FROM_EDGE (phi, EDGE_SUCC (loop->latch, 0));\t\t\t           \n-\tadd_phi_arg (&new_phi, phi_arg, loop->exit_edges[0]);\n-      \n-\t/* Update all phi nodes at the loop exit successor.  */\n-\tfor (phi1 = phi_nodes (EDGE_SUCC (bb, 0)->dest); \n-\t     phi1; \n-\t     phi1 = PHI_CHAIN (phi1))\n-\t  {\n-\t    tree old_arg = PHI_ARG_DEF_FROM_EDGE (phi1, EDGE_SUCC (bb, 0));\n-\t    if (old_arg == phi_arg)\n-\t      {\t\n-\t\tedge e = EDGE_SUCC (bb, 0);\n-\n-\t\tSET_PHI_ARG_DEF (phi1, \n-\t\t\t\t phi_arg_from_edge (phi1, e),\n-\t\t\t\t PHI_RESULT (new_phi)); \n-\t      }\n-\t  }\n-      }       \n-\n-  set_phi_nodes (bb, phi_reverse (phi_nodes (bb)));\n+  set_phi_nodes (new_merge_bb, phi_reverse (phi_nodes (new_merge_bb)));\n }\n \n \n@@ -618,8 +663,6 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n   tree begin_label = tree_block_label (loop->latch);\n   tree exit_label = tree_block_label (loop->single_exit->dest);\n \n-  /* Flow loop scan does not update loop->single_exit field.  */\n-  loop->single_exit = loop->exit_edges[0];\n   orig_cond = get_loop_exit_condition (loop);\n   gcc_assert (orig_cond);\n   create_iv (integer_zero_node, integer_one_node, NULL_TREE, loop,\n@@ -630,7 +673,6 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n   bsi_next (&loop_exit_bsi);\n   gcc_assert (bsi_stmt (loop_exit_bsi) == orig_cond);\n \n-\n   if (exit_edge->flags & EDGE_TRUE_VALUE) /* 'then' edge exits the loop.  */\n     cond = build2 (GE_EXPR, boolean_type_node, indx_after_incr, niters);\n   else /* 'then' edge loops back.  */\n@@ -670,8 +712,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n   if (!at_exit && e != loop_preheader_edge (loop))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\t  fprintf (dump_file,\n-\t\t   \"Edge is not an entry nor an exit edge.\\n\");\n+\t  fprintf (dump_file, \"Edge is not an entry nor an exit edge.\\n\");\n       return NULL;\n     }\n \n@@ -681,8 +722,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n   if (!can_copy_bbs_p (bbs, loop->num_nodes))\n     {\n       if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n-\t  fprintf (dump_file,\n-\t\t   \"Cannot copy basic blocks.\\n\");\n+\t  fprintf (dump_file, \"Cannot copy basic blocks.\\n\");\n       free (bbs);\n       return NULL;\n     }\n@@ -692,8 +732,7 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n   if (!new_loop)\n     {\n       if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n-\t  fprintf (dump_file,\n-\t\t   \"The duplicate_loop returns NULL.\\n\");\n+\t  fprintf (dump_file, \"duplicate_loop returns NULL.\\n\");\n       free (bbs);\n       return NULL;\n     }\n@@ -776,7 +815,8 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n    Returns the skip edge.  */\n \n static edge\n-slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb)\n+slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb,\n+\t\t        basic_block dom_bb)\n {\n   block_stmt_iterator bsi;\n   edge new_e, enter_e;\n@@ -796,7 +836,7 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb)\n   bsi_insert_after (&bsi, cond_stmt, BSI_NEW_STMT);\n   /* Add new edge to connect entry block to the second loop.  */\n   new_e = make_edge (guard_bb, exit_bb, EDGE_TRUE_VALUE);\n-  set_immediate_dominator (CDI_DOMINATORS, exit_bb, guard_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, exit_bb, dom_bb);\n   return new_e;\n }\n \n@@ -837,61 +877,77 @@ slpeel_can_duplicate_loop_p (struct loop *loop, edge e)\n }\n \n \n-/* Given LOOP this function duplicates it to the edge E. \n-\n-   This transformation takes place before the loop is vectorized. \n-   For now, there are two main cases when it's used \n-   by the vectorizer: to support loops with unknown loop bounds \n-   (or loop bounds indivisible by vectorization factor) and to force the \n-   alignment of data references in the loop. In the first case, LOOP is \n-   duplicated to the exit edge, producing epilog loop. In the second case, LOOP \n-   is duplicated to the preheader edge thus generating prolog loop. In both \n-   cases, the original loop will be vectorized after the transformation. \n-\n-   The edge E is supposed to be either preheader edge of the LOOP or  \n-   its exit edge. If preheader edge is specified, the LOOP copy \n-   will precede the original one. Otherwise the copy will be located \n-   at the exit of the LOOP.\n+static void\n+slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n+                                 struct loop *second_loop)\n+{\n+  basic_block loop1_exit_bb = first_loop->exit_edges[0]->dest;\n+  basic_block loop2_entry_bb = second_loop->pre_header;\n+  basic_block loop1_entry_bb = loop_preheader_edge (first_loop)->src;\n+\n+  /* A guard that controls whether the second_loop is to be executed or skipped\n+     is placed in first_loop->exit.  first_loopt->exit therefore has two\n+     successors - one is the preheader of second_loop, and the other is a bb\n+     after second_loop.\n+   */\n+  gcc_assert (EDGE_COUNT (loop1_exit_bb->succs) == 2);\n    \n-   FIRST_NITERS (SSA_NAME) parameter specifies how many times to iterate \n-   the first loop. If UPDATE_FIRST_LOOP_COUNT parameter is false, the first \n-   loop will be iterated FIRST_NITERS times by introducing additional \n-   induction variable and replacing loop exit condition. If \n-   UPDATE_FIRST_LOOP_COUNT is true no change to the first loop is made and \n-   the caller to tree_duplicate_loop_to_edge is responsible for updating \n-   the first loop count.\n    \n-   NITERS (also SSA_NAME) parameter defines the number of iteration the\n-   original loop iterated. The function generates two if-then guards: \n-   one prior to the first loop and the other prior to the second loop. \n-   The first guard will be:\n-\n-   if (FIRST_NITERS == 0) then skip the first loop\n+  /* 1. Verify that one of the successors of first_loopt->exit is the preheader\n+        of second_loop.  */\n    \n-   The second guard will be:\n+  /* The preheader of new_loop is expected to have two predessors:\n+     first_loop->exit and the block that precedes first_loop.  */\n+\n+  gcc_assert (EDGE_COUNT (loop2_entry_bb->preds) == 2 \n+              && ((EDGE_PRED (loop2_entry_bb, 0)->src == loop1_exit_bb\n+                   && EDGE_PRED (loop2_entry_bb, 1)->src == loop1_entry_bb)\n+               || (EDGE_PRED (loop2_entry_bb, 1)->src ==  loop1_exit_bb\n+                   && EDGE_PRED (loop2_entry_bb, 0)->src == loop1_entry_bb)));\n+  \n+  /* Verify that the other successor of first_loopt->exit is after the\n+     second_loop.  */\n+  /* TODO */\n+}\n \n-   if (FIRST_NITERS == NITERS) then skip the second loop\n \n-   Thus the equivalence to the original code is guaranteed by correct values \n-   of NITERS and FIRST_NITERS and generation of if-then loop guards.\n+/* Function slpeel_tree_peel_loop_to_edge.\n \n-   For now this function supports only loop forms that are candidate for \n-   vectorization. Such types are the following: \n+   Peel the first (last) iterations of LOOP into a new prolog (epilog) loop\n+   that is placed on the entry (exit) edge E of LOOP. After this transformation\n+   we have two loops one after the other - first-loop iterates FIRST_NITERS\n+   times, and second-loop iterates the remainder NITERS - FIRST_NITERS times.\n \n-   (1) only innermost loops \n-   (2) loops built from 2 basic blocks \n-   (3) loops with one entry and one exit\n-   (4) loops without function calls\n-   (5) loops without defs that are used after the loop \n+   Input:\n+   - LOOP: the loop to be peeled.\n+   - E: the exit or entry edge of LOOP.\n+        If it is the entry edge, we peel the first iterations of LOOP. In this\n+        case first-loop is LOOP, and second-loop is the newly created loop.\n+        If it is the exit edge, we peel the last iterations of LOOP. In this\n+        case, first-loop is the newly created loop, and second-loop is LOOP.\n+   - NITERS: the number of iterations that LOOP iterates.\n+   - FIRST_NITERS: the number of iterations that the first-loop should iterate.\n+   - UPDATE_FIRST_LOOP_COUNT:  specified whether this function is responssible\n+        for updating the loop bound of the first-loop to FIRST_NITERS.  If it\n+        is false, the caller of this function may want to take care of this\n+        (this can be usefull is we don't want new stmts added to first-loop).\n \n-   (1), (3) are checked in this function; (2) - in function \n-   vect_analyze_loop_form; (4) - in function vect_analyze_data_refs;\n-   (5) is checked as part of the function vect_mark_stmts_to_be_vectorized, \n-   when excluding induction/reduction support.   \n+   Output:\n+   The function returns a pointer to the new loop-copy, or NULL if it failed\n+   to perform the trabsformation.\n+\n+   The function generates two if-then-else guards: one before the first loop,\n+   and the other before the second loop:\n+   The first guard is:\n+     if (FIRST_NITERS == 0) then skip the first loop,\n+     and go directly to the second loop.\n+   The second guard is:\n+     if (FIRST_NITERS == NITERS) then skip the second loop.\n+\n+   FORNOW only simple loops are supported (see slpeel_can_duplicate_loop_p).\n+   FORNOW the resulting code will not be in loop-closed-ssa form.\n+*/\n \n-   The function returns NULL in case one of these checks or \n-   transformations failed.  */\n-   \n struct loop*\n slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops, \n \t\t\t       edge e, tree first_niters, \n@@ -901,117 +957,151 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   edge skip_e;\n   tree pre_condition;\n   bitmap definitions;\n-  basic_block first_exit_bb, second_exit_bb;\n-  basic_block pre_header_bb;\n+  basic_block bb_before_second_loop, bb_after_second_loop;\n+  basic_block bb_before_first_loop;\n+  basic_block bb_between_loops;\n   edge exit_e = loop->exit_edges [0];\n-\n+  \n   if (!slpeel_can_duplicate_loop_p (loop, e))\n     return NULL;\n-\n-  /* We have to initialize cfg_hooks. Then, when calling \n+  \n+  /* We have to initialize cfg_hooks. Then, when calling\n    cfg_hooks->split_edge, the function tree_split_edge \n-   is actually called and, when calling cfg_hooks->duplicate_block, \n+   is actually called and, when calling cfg_hooks->duplicate_block,\n    the function tree_duplicate_bb is called.  */\n   tree_register_cfg_hooks ();\n \n-  /* 1. Generate a copy of LOOP and put it on E (entry or exit).  */\n+\n+  /* 1. Generate a copy of LOOP and put it on E (E is the entry/exit of LOOP).\n+        Resulting CFG would be:\n+\n+        first_loop:\n+        do {\n+        } while ...\n+\n+        second_loop:\n+        do {\n+        } while ...\n+\n+        orig_exit_bb:\n+   */\n+  \n   if (!(new_loop = slpeel_tree_duplicate_loop_to_edge_cfg (loop, loops, e)))\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n-\tfprintf (dump_file,\n-\t\t \"The tree_duplicate_loop_to_edge_cfg failed.\\n\");\n+      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+        fprintf (dump_file, \"tree_duplicate_loop_to_edge_cfg failed.\\n\");\n       return NULL;\n     }\n-\n-  definitions = marked_ssa_names ();\n-  allocate_new_names (definitions);\n-  slpeel_update_phis_for_duplicate_loop (loop, new_loop, e == exit_e);\n-  /* Here, using assumption (5), we do not propagate new names further \n-     than on phis of the exit from the second loop.  */\n-  rename_variables_in_loop (new_loop);\n-  free_new_names (definitions);\n-\n+  \n   if (e == exit_e)\n     {\n+      /* NEW_LOOP was placed after LOOP.  */\n       first_loop = loop;\n       second_loop = new_loop;\n     }\n-  else \n+  else\n     {\n+      /* NEW_LOOP was placed before LOOP.  */\n       first_loop = new_loop;\n       second_loop = loop;\n     }\n \n-  /* 2. Generate bb between the loops.  */\n-  first_exit_bb = split_edge (first_loop->exit_edges[0]);\n-  add_bb_to_loop (first_exit_bb, first_loop->outer);\n+  definitions = marked_ssa_names ();\n+  allocate_new_names (definitions);\n+  slpeel_update_phis_for_duplicate_loop (loop, new_loop, e == exit_e);\n+  rename_variables_in_loop (new_loop);\n+\n \n-  /* We need to update here first loop exit edge \n-     and second loop preheader edge.  */\n-  flow_loop_scan (first_loop, LOOP_ALL);\n-  flow_loop_scan (second_loop, LOOP_ALL);  \n-  /* Flow loop scan does not update loop->single_exit field.  */\n-  first_loop->single_exit = first_loop->exit_edges[0];\n-  second_loop->single_exit = second_loop->exit_edges[0];\n+  /* 2. Add the guard that controls whether the first loop is executed.\n+        Resulting CFG would be:\n \n-  /* 3. Make first loop iterate FIRST_NITERS times, if needed.  */\n-  if (!update_first_loop_count)\n-    slpeel_make_loop_iterate_ntimes (first_loop, first_niters);\n-  \n-  /* 4. Add the guard before first loop:\n+        bb_before_first_loop:\n+        if (FIRST_NITERS == 0) GOTO bb_before_second_loop\n+                               GOTO first-loop\n+\n+        first_loop:\n+        do {\n+        } while ...\n \n-     if FIRST_NITERS == 0 \n-       skip first loop\n-     else \n-       enter first loop  */\n+        bb_before_second_loop:\n \n-  /* 4a. Generate bb before first loop.  */\n-  pre_header_bb = split_edge (loop_preheader_edge (first_loop));\n-  add_bb_to_loop (pre_header_bb, first_loop->outer);\n+        second_loop:\n+        do {\n+        } while ...\n \n-  /* First loop preheader edge is changed.  */\n+        orig_exit_bb:\n+   */\n+\n+  bb_before_first_loop = split_edge (loop_preheader_edge (first_loop));\n+  add_bb_to_loop (bb_before_first_loop, first_loop->outer);\n+  bb_before_second_loop = split_edge (first_loop->exit_edges[0]);\n+  add_bb_to_loop (bb_before_second_loop, first_loop->outer);\n   flow_loop_scan (first_loop, LOOP_ALL);\n+  flow_loop_scan (second_loop, LOOP_ALL);\n+\n+  pre_condition =\n+        build (LE_EXPR, boolean_type_node, first_niters, integer_zero_node);\n+  skip_e = slpeel_add_loop_guard (bb_before_first_loop, pre_condition,\n+                                  bb_before_second_loop, bb_before_first_loop);\n+  slpeel_update_phi_nodes_for_guard (skip_e, first_loop, true /* entry-phis */,\n+                                     first_loop == new_loop);\n+\n \n-  /* 4b. Generate guard condition.  */\n-  pre_condition = build (LE_EXPR, boolean_type_node,\n-\t\t\t   first_niters, integer_zero_node);\n+  /* 3. Add the guard that controls whether the second loop is executed.\n+        Resulting CFG would be:\n \n-  /* 4c. Add condition at the end of preheader bb.  */\n-  skip_e = slpeel_add_loop_guard (pre_header_bb, pre_condition, first_exit_bb);\n+        bb_before_first_loop:\n+        if (FIRST_NITERS == 0) GOTO bb_before_second_loop (skip first loop)\n+                               GOTO first-loop\n \n-  /* 4d. Update phis at first loop exit and propagate changes \n-     to the phis of second loop.  */\n-  slpeel_update_phi_nodes_for_guard (skip_e, first_loop);\n+        first_loop:\n+        do {\n+        } while ...\n \n-  /* 5. Add the guard before second loop:\n+        bb_between_loops:\n+        if (FIRST_NITERS == NITERS) GOTO bb_after_second_loop (skip second loop)\n+                                    GOTO bb_before_second_loop\n \n-     if FIRST_NITERS == NITERS SKIP\n-       skip second loop\n-     else \n-       enter second loop  */\n+        bb_before_second_loop:\n \n-  /* 5a. Generate empty bb at the exit from the second loop.  */\n-  second_exit_bb = split_edge (second_loop->exit_edges[0]);\n-  add_bb_to_loop (second_exit_bb, second_loop->outer);\n+        second_loop:\n+        do {\n+        } while ...\n \n-  /* Second loop preheader edge is changed.  */\n+        bb_after_second_loop:\n+\n+        orig_exit_bb:\n+   */\n+\n+  bb_between_loops = split_edge (first_loop->exit_edges[0]);\n+  add_bb_to_loop (bb_between_loops, first_loop->outer);\n+  bb_after_second_loop = split_edge (second_loop->exit_edges[0]);\n+  add_bb_to_loop (bb_after_second_loop, second_loop->outer);\n+  flow_loop_scan (first_loop, LOOP_ALL);\n   flow_loop_scan (second_loop, LOOP_ALL);\n \n-  /* 5b. Generate guard condition.  */\n-  pre_condition = build (EQ_EXPR, boolean_type_node,\n-\t\t\t   first_niters, niters);\n+  pre_condition = build (EQ_EXPR, boolean_type_node, first_niters, niters);\n+  skip_e = slpeel_add_loop_guard (bb_between_loops, pre_condition,\n+                                  bb_after_second_loop, bb_before_first_loop);\n+  slpeel_update_phi_nodes_for_guard (skip_e, second_loop, false /* exit-phis */,\n+                                     second_loop == new_loop);\n \n-  /* 5c. Add condition at the end of preheader bb.  */\n-  skip_e = slpeel_add_loop_guard (first_exit_bb, pre_condition, second_exit_bb);\n-  slpeel_update_phi_nodes_for_guard (skip_e, second_loop);\n+  /* Flow loop scan does not update loop->single_exit field.  */\n+  first_loop->single_exit = first_loop->exit_edges[0];\n+  second_loop->single_exit = second_loop->exit_edges[0];\n \n+  /* 4. Make first-loop iterate FIRST_NITERS times, if requested.\n+   */\n+  if (update_first_loop_count)\n+    slpeel_make_loop_iterate_ntimes (first_loop, first_niters);\n+\n+  free_new_names (definitions);\n   BITMAP_XFREE (definitions);\n   unmark_all_for_rewrite ();\n-  \n+\n   return new_loop;\n }\n \n-\n \f\n /* Here the proper Vectorizer starts.  */\n \n@@ -2094,7 +2184,8 @@ vect_finish_stmt_generation (tree stmt, tree vec_stmt, block_stmt_iterator *bsi)\n   /* Make sure bsi points to the stmt that is being vectorized.  */\n \n   /* Assumption: any stmts created for the vectorization of stmt S were\n-     inserted before S. BSI is expected to point to S or some new stmt before S.  */\n+     inserted before S. BSI is expected to point to S or some new stmt before S.\n+   */\n \n   while (stmt != bsi_stmt (*bsi) && !bsi_end_p (*bsi))\n     bsi_next (bsi);\n@@ -2837,24 +2928,13 @@ vect_transform_loop_bound (loop_vec_info loop_vinfo, tree niters)\n               of LOOP were peeled.\n      - NITERS - the number of iterations that LOOP executes (before it is\n                 vectorized). i.e, the number of times the ivs should be bumped.\n+     - UPDATE_E - a successor edge of LOOP->exit that is on the (only) path\n+                  coming out from LOOP on which there are uses of the LOOP ivs\n+\t\t  (this is the path from LOOP->exit to epilog_loop->preheader).\n \n-     We have:\n-\n-        bb_before_loop:\n-          if (guard-cond) GOTO bb_before_epilog_loop\n-          else            GOTO loop\n-\n-        loop:\n-          do {\n-          } while ...\n-\n-        bb_before_epilog_loop:\n-\n-     bb_before_epilog_loop has edges coming in form the loop exit and\n-     from bb_before_loop.  New definitions for ivs will be placed on the edge\n-     from loop->exit to bb_before_epilog_loop.  This also requires that we update\n-     the phis in bb_before_epilog_loop. (In the code this bb is denoted \n-     \"update_bb\").\n+                  The new definitions of the ivs are placed in LOOP->exit.\n+                  The phi args associated with the edge UPDATE_E in the bb\n+                  UPDATE_E->dest are updated accordingly.\n \n      Assumption 1: Like the rest of the vectorizer, this function assumes\n      a single loop exit that has a single predecessor.\n@@ -2864,23 +2944,26 @@ vect_transform_loop_bound (loop_vec_info loop_vinfo, tree niters)\n \n      Assumption 3: The access function of the ivs is simple enough (see\n      vect_can_advance_ivs_p).  This assumption will be relaxed in the future.\n+\n+     Assumption 4: Exactly one of the successors of LOOP exit-bb is on a path\n+     coming out of LOOP on which the ivs of LOOP are used (this is the path \n+     that leads to the epilog loop; other paths skip the epilog loop).  This\n+     path starts with the edge UPDATE_E, and its destination (denoted update_bb)\n+     needs to have its phis updated.\n  */\n \n static void\n-vect_update_ivs_after_vectorizer (struct loop *loop, tree niters)\n+vect_update_ivs_after_vectorizer (struct loop *loop, tree niters, edge update_e)\n {\n-  edge exit = loop->exit_edges[0];\n+  basic_block exit_bb = loop->exit_edges[0]->dest;\n   tree phi, phi1;\n-  basic_block update_bb = exit->dest;\n-  edge update_e;\n+  basic_block update_bb = update_e->dest;\n \n-  /* Generate basic block at the exit from the loop.  */\n-  basic_block new_bb = split_edge (exit);\n+  /* gcc_assert (vect_can_advance_ivs_p (loop)); */\n+\n+  /* Make sure there exists a single-predecessor exit bb:  */\n+  gcc_assert (EDGE_COUNT (exit_bb->preds) == 1);\n \n-  add_bb_to_loop (new_bb, EDGE_SUCC (new_bb, 0)->dest->loop_father);\n-  loop->exit_edges[0] = EDGE_PRED (new_bb, 0);\n-  update_e = EDGE_SUCC (new_bb, 0);\n-  \n   for (phi = phi_nodes (loop->header), phi1 = phi_nodes (update_bb); \n        phi && phi1; \n        phi = PHI_CHAIN (phi), phi1 = PHI_CHAIN (phi1))\n@@ -2892,9 +2975,7 @@ vect_update_ivs_after_vectorizer (struct loop *loop, tree niters)\n       tree var, stmt, ni, ni_name;\n       block_stmt_iterator last_bsi;\n \n-      /* Skip virtual phi's. The data dependences that are associated with\n-         virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.  */\n-\n+      /* Skip virtual phi's.  */\n       if (!is_gimple_reg (SSA_NAME_VAR (PHI_RESULT (phi))))\n \t{\n \t  if (vect_debug_details (NULL))\n@@ -2906,10 +2987,10 @@ vect_update_ivs_after_vectorizer (struct loop *loop, tree niters)\n       gcc_assert (access_fn);\n       evolution_part =\n \t unshare_expr (evolution_part_in_loop_num (access_fn, loop->num));\n+      gcc_assert (evolution_part != NULL_TREE);\n       \n-      /* FORNOW: We do not transform initial conditions of IVs \n-\t which evolution functions are a polynomial of degree >= 2 or\n-\t exponential.  */\n+      /* FORNOW: We do not support IVs whose evolution function is a polynomial\n+         of degree >= 2 or exponential.  */\n       gcc_assert (!tree_is_chrec (evolution_part));\n \n       step_expr = evolution_part;\n@@ -2924,34 +3005,41 @@ vect_update_ivs_after_vectorizer (struct loop *loop, tree niters)\n \n       ni_name = force_gimple_operand (ni, &stmt, false, var);\n       \n-      /* Insert stmt into new_bb.  */\n-      last_bsi = bsi_last (new_bb);\n+      /* Insert stmt into exit_bb.  */\n+      last_bsi = bsi_last (exit_bb);\n       if (stmt)\n-        bsi_insert_after (&last_bsi, stmt, BSI_NEW_STMT);   \n+        bsi_insert_before (&last_bsi, stmt, BSI_SAME_STMT);   \n \n-      /* Fix phi expressions in duplicated loop.  */\n+      /* Fix phi expressions in the successor bb.  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (phi1, update_e) ==\n                   PHI_ARG_DEF_FROM_EDGE (phi, EDGE_SUCC (loop->latch, 0)));\n       SET_PHI_ARG_DEF (phi1, phi_arg_from_edge (phi1, update_e), ni_name);\n     }\n }\n \n \n-/* This function is the main driver of transformation \n-   to be done for loop before vectorizing it in case of \n-   unknown loop bound.  */\n+/* Function vect_do_peeling_for_loop_bound\n+\n+   Peel the last iterations of the loop represented by LOOP_VINFO.\n+   The peeled iterations form a new epilog loop.  Given that the loop now \n+   iterates NITERS times, the new epilog loop iterates\n+   NITERS % VECTORIZATION_FACTOR times.\n+   \n+   The original loop will later be made to iterate \n+   NITERS / VECTORIZATION_FACTOR times (this value is placed into RATIO).  */\n \n static void \n-vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree * ratio,\n+vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n \t\t\t\tstruct loops *loops)\n {\n \n   tree ni_name, ratio_mult_vf_name;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *new_loop;\n+  edge update_e;\n #ifdef ENABLE_CHECKING\n   int loop_num;\n #endif\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  struct loop *new_loop;\n \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"\\n<<vect_transtorm_for_unknown_loop_bound>>\\n\");\n@@ -2972,23 +3060,32 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree * ratio,\n   loop_num  = loop->num; \n #endif\n   new_loop = slpeel_tree_peel_loop_to_edge (loop, loops, loop->exit_edges[0],\n-\t\t\t\t\t    ratio_mult_vf_name, ni_name, true); \n+\t\t\t\t\t    ratio_mult_vf_name, ni_name, false);\n #ifdef ENABLE_CHECKING\n   gcc_assert (new_loop);\n   gcc_assert (loop_num == loop->num);\n+  slpeel_verify_cfg_after_peeling (loop, new_loop);\n #endif\n \n+  /* A guard that controls whether the new_loop is to be executed or skipped\n+     is placed in LOOP->exit.  LOOP->exit therefore has two successors - one\n+     is the preheader of NEW_LOOP, where the IVs from LOOP are used.  The other\n+     is a bb after NEW_LOOP, where these IVs are not used.  Find the edge that\n+     is on the path where the LOOP IVs are used and need to be updated.  */\n+\n+  if (EDGE_PRED (new_loop->pre_header, 0)->src == loop->exit_edges[0]->dest)\n+    update_e = EDGE_PRED (new_loop->pre_header, 0);\n+  else\n+    update_e = EDGE_PRED (new_loop->pre_header, 1);\n+\n   /* Update IVs of original loop as if they were advanced \n      by ratio_mult_vf_name steps.  */\n+  vect_update_ivs_after_vectorizer (loop, ratio_mult_vf_name, update_e); \n \n-#ifdef ENABLE_CHECKING\n-  /* Check existence of intermediate bb.  */\n-  gcc_assert (loop->exit_edges[0]->dest == new_loop->pre_header);\n-#endif\n-  vect_update_ivs_after_vectorizer (loop, ratio_mult_vf_name); \n+  /* After peeling we have to reset scalar evolution analyzer.  */\n+  scev_reset ();\n \n   return;\n-\n }\n \n \n@@ -3133,24 +3230,29 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree niters_of_prolog_loop, ni_name;\n   tree n_iters;\n+  struct loop *new_loop;\n \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"\\n<<vect_do_peeling_for_alignment>>\\n\");\n \n   ni_name = vect_build_loop_niters (loop_vinfo);\n   niters_of_prolog_loop = vect_gen_niters_for_prolog_loop (loop_vinfo, ni_name);\n   \n-\n   /* Peel the prolog loop and iterate it niters_of_prolog_loop.  */\n-  slpeel_tree_peel_loop_to_edge (loop, loops, loop_preheader_edge(loop), \n-\t\t\t\t niters_of_prolog_loop, ni_name, false); \n+  new_loop = \n+\tslpeel_tree_peel_loop_to_edge (loop, loops, loop_preheader_edge (loop), \n+\t\t\t\t       niters_of_prolog_loop, ni_name, true); \n+#ifdef ENABLE_CHECKING\n+  gcc_assert (new_loop);\n+  slpeel_verify_cfg_after_peeling (new_loop, loop);\n+#endif\n \n   /* Update number of times loop executes.  */\n   n_iters = LOOP_VINFO_NITERS (loop_vinfo);\n   LOOP_VINFO_NITERS (loop_vinfo) =\n     build (MINUS_EXPR, integer_type_node, n_iters, niters_of_prolog_loop);\n \n-  /* Update all inits of access functions of all data refs.  */\n+  /* Update the init conditions of the access functions of all data refs.  */\n   vect_update_inits_of_drs (loop_vinfo, niters_of_prolog_loop);\n \n   /* After peeling we have to reset scalar evolution analyzer.  */"}]}