{"sha": "a0ea8550734007723696ff2f3d8ce38f1df6078c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBlYTg1NTA3MzQwMDc3MjM2OTZmZjJmM2Q4Y2UzOGYxZGY2MDc4Yw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-06-24T09:48:43Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-06-24T09:48:43Z"}, "message": "Timer.java, [...]: New versions from classpath.\n\n2003-06-24  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/Timer.java,\n\tjavax/swing/plaf/ActionMapUIResource.java,\n\tjavax/swing/plaf/ButtonUI.java,\n\tjavax/swing/plaf/ColorChooserUI.java,\n\tjavax/swing/plaf/ColorUIResource.java,\n\tjavax/swing/plaf/ComboBoxUI.java,\n\tjavax/swing/plaf/ComponentInputMapUIResource.java,\n\tjavax/swing/plaf/basic/BasicBorders.java:\n\tNew versions from classpath.\n\t* javax/swing/plaf/basic/BasicSplitPaneDivider.java.\n\tjavax/swing/plaf/basic/BasicSplitPaneUI.java:\n\tNew file from classpath.\n\t* javax/swing/plaf/basic/doc-files/BasicBorders-1.png,\n\tjavax/swing/plaf/basic/doc-files/BasicBorders-2.png,\n\tjavax/swing/plaf/basic/doc-files/BasicBorders.FieldBorder-1.png,\n\tjavax/swing/plaf/doc-files/ComponentUI-1.dia,\n\tjavax/swing/plaf/doc-files/ComponentUI-1.png:\n\tNew binary files from classpath.\n\nFrom-SVN: r68409", "tree": {"sha": "73b283b47a017c9d99909acd2ee187905fd6db24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73b283b47a017c9d99909acd2ee187905fd6db24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0ea8550734007723696ff2f3d8ce38f1df6078c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ea8550734007723696ff2f3d8ce38f1df6078c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0ea8550734007723696ff2f3d8ce38f1df6078c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ea8550734007723696ff2f3d8ce38f1df6078c/comments", "author": null, "committer": null, "parents": [{"sha": "20afd4757112345a1f7d9eabe4ff0d6e772a8701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20afd4757112345a1f7d9eabe4ff0d6e772a8701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20afd4757112345a1f7d9eabe4ff0d6e772a8701"}], "stats": {"total": 2045, "additions": 1910, "deletions": 135}, "files": [{"sha": "7758e70e9206d597834b6496b25bbb4fa6f0d5a6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c", "patch": "@@ -1,3 +1,24 @@\n+2003-06-24  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/Timer.java,\n+\tjavax/swing/plaf/ActionMapUIResource.java,\n+\tjavax/swing/plaf/ButtonUI.java,\n+\tjavax/swing/plaf/ColorChooserUI.java,\n+\tjavax/swing/plaf/ColorUIResource.java,\n+\tjavax/swing/plaf/ComboBoxUI.java,\n+\tjavax/swing/plaf/ComponentInputMapUIResource.java,\n+\tjavax/swing/plaf/basic/BasicBorders.java:\n+\tNew versions from classpath.\n+\t* javax/swing/plaf/basic/BasicSplitPaneDivider.java.\n+\tjavax/swing/plaf/basic/BasicSplitPaneUI.java:\n+\tNew file from classpath.\n+\t* javax/swing/plaf/basic/doc-files/BasicBorders-1.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicBorders-2.png,\n+\tjavax/swing/plaf/basic/doc-files/BasicBorders.FieldBorder-1.png,\n+\tjavax/swing/plaf/doc-files/ComponentUI-1.dia,\n+\tjavax/swing/plaf/doc-files/ComponentUI-1.png:\n+\tNew binary files from classpath.\n+\n 2003-06-24  Michael Koch  <konqueror@gmx.de>\n \n \t* java/io/LineNumberReader.java"}, {"sha": "89df756eee263f5123baf17074f68157a463fc23", "filename": "libjava/javax/swing/Timer.java", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2FTimer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2FTimer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FTimer.java?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c", "patch": "@@ -47,12 +47,13 @@\n \n public class Timer implements Serializable\n {\n+  protected EventListenerList listenerList = new EventListenerList();\n+  \n   int ticks;\n   static boolean verbose;\n   boolean running;\n   boolean repeat_ticks = true;\n   long interval, init_delay;\n-  Vector actions = new Vector();\n     \n   class Waker extends Thread\n   {\n@@ -86,23 +87,44 @@ public void run()\n \n   public void addActionListener(ActionListener listener)\n   {\n-    actions.addElement(listener);\n+    listenerList.add (ActionListener.class, listener);\n   }\n+  \n   public void removeActionListener(ActionListener listener)\n   {\n-    actions.removeElement(listener);\n+    listenerList.remove (ActionListener.class, listener);\n+  }\n+\n+  /**\n+   * @since 1.3\n+   */\n+  public EventListener[] getListeners (Class listenerType)\n+  {\n+    return listenerList.getListeners (listenerType);\n+  }\n+  \n+  /**\n+   * @since 1.4\n+   */\n+  public ActionListener[] getActionListeners ()\n+  {\n+    return (ActionListener[]) listenerList.getListeners (ActionListener.class);\n   }\n \n-  void fireActionPerformed()\n+  protected void fireActionPerformed (ActionEvent event)\n   {\n-    for (int i=0;i<actions.size();i++)\n+    ActionListener[] listeners = getActionListeners();\n+    \n+    for (int i = 0; i < listeners.length; i++)\n       {\n-\tActionListener a = (ActionListener) actions.elementAt(i);\n-\ta.actionPerformed(new ActionEvent(this, ticks, \"Timer\"));\n+\tlisteners [i].actionPerformed (event);\n       }\n   }\n-  \n \n+  void fireActionPerformed ()\n+  {\n+    fireActionPerformed (new ActionEvent (this, ticks, \"Timer\"));\n+  }\n \n   public static void setLogTimers(boolean flag)\n   {"}, {"sha": "d48ac4bc22075220ea9cf2ed4febacc6426abfbd", "filename": "libjava/javax/swing/plaf/ActionMapUIResource.java", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2FActionMapUIResource.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2FActionMapUIResource.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2FActionMapUIResource.java?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c", "patch": "@@ -1,5 +1,5 @@\n /* ActionMapUIResource.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,26 +37,28 @@\n \n package javax.swing.plaf;\n \n-// Imports\n-import javax.swing.*;\n+import javax.swing.ActionMap;\n+\n \n /**\n- * ActionMapUIResource\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * An <code>ActionMap</code> that implements the {@link UIResource}\n+ * interface to indicate that it belongs to a pluggable\n+ * LookAndFeel.\n+ *\n+ * @see javax.swing.ActionMap\n+ *\n+ * @author Andrew Selkirk\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n-public class ActionMapUIResource extends ActionMap implements UIResource {\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor ActionMapUIResource\n-\t */\n-\tpublic ActionMapUIResource() {\n-\t\t// TODO\n-\t} // ActionMapUIResource()\n-\n-\n-} // ActionMapUIResource\n+public class ActionMapUIResource\n+  extends ActionMap\n+  implements UIResource\n+{\n+  /**\n+   * Constructs a new ActionMapUIResource.\n+   */\n+  public ActionMapUIResource()\n+  {\n+    /* The constructor does nothing. */\n+  }\n+}"}, {"sha": "ca9dc6d568d56e53318b339591f6f788496612bc", "filename": "libjava/javax/swing/plaf/ButtonUI.java", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2FButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2FButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2FButtonUI.java?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c", "patch": "@@ -1,5 +1,5 @@\n /* ButtonUI.java\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,6 +38,15 @@\n \n package javax.swing.plaf;\n \n-public class ButtonUI extends ComponentUI\n+/**\n+ * An abstract base class for delegates that implement the pluggable\n+ * look and feel for a <code>JButton</code>.\n+ *\n+ * @see javax.swing.JButton\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ */\n+public abstract class ButtonUI\n+  extends ComponentUI\n {\n }"}, {"sha": "f2f563191b793f1149bb322e0da7303bebbc1569", "filename": "libjava/javax/swing/plaf/ColorChooserUI.java", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2FColorChooserUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2FColorChooserUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2FColorChooserUI.java?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c", "patch": "@@ -1,5 +1,5 @@\n /* ColorChooserUI.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,22 +38,23 @@\n package javax.swing.plaf;\n \n /**\n- * ColorChooserUI\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * An abstract base class for delegates that implement the pluggable\n+ * look and feel for a <code>JColorChooser</code>.\n+ *\n+ * @see javax.swing.JColorChooser\n+ *\n+ * @author Andrew Selkirk\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n-public abstract class ColorChooserUI extends ComponentUI {\n+public abstract class ColorChooserUI\n+  extends ComponentUI\n+{\n+  /**\n+   * Constructs a ColorChooserUI.\n+   */\n+  public ColorChooserUI()\n+  {\n+    /* The constructor does not do anything. */\n+  }\n+}\n \n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor ColorChooserUI\n-\t */\n-\tpublic ColorChooserUI() {\n-\t\t// TODO\n-\t} // ColorChooserUI()\n-\n-\n-} // ColorChooserUI"}, {"sha": "addc9c99cdb1c4f49bffbe5e4849afe098193e72", "filename": "libjava/javax/swing/plaf/ColorUIResource.java", "status": "modified", "additions": 64, "deletions": 12, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2FColorUIResource.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2FColorUIResource.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2FColorUIResource.java?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c", "patch": "@@ -1,5 +1,5 @@\n /* ColorUIResource.java\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,26 +37,78 @@\n \n \n package javax.swing.plaf;\n+\n import java.awt.Color;\n+\n+\n /**\n- * STUBBED\n+ * A Color that is marked as <code>UIResource</code>, which indicates that\n+ * the color has been installed by a pluggable LookAndFeel. Such colors\n+ * are replaced when the LookAndFeel changes.\n+ *\n+ * @see java.awt.Color\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n-public class ColorUIResource extends Color implements UIResource\n+public class ColorUIResource\n+  extends Color\n+  implements UIResource\n {\n-  public ColorUIResource(Color c)\n+  /**\n+   * Constructs a <code>ColorUIResource</code> using the specified\n+   * red, green, and blue values, which must be given as integers in\n+   * the range of 0-255. The alpha channel value will default to 255,\n+   * meaning that the color is fully opaque.\n+   *\n+   * @param r the red intensity, which must be in the range [0 .. 255].\n+   * @param g the green intensity, which must be in the range [0 .. 255].\n+   * @param b the blue intensity, which must be in the range [0 .. 255].\n+   */\n+  public ColorUIResource(int r, int g, int b)\n   {\n-    super(c.getRGB());\n+    super(r, g, b);\n   }\n-  public ColorUIResource(float r, float g, float b)\n+\n+\n+  /**\n+   * Consructs a <code>ColorUIResource</code> using the specified\n+   * RGB value. The blue value is in bits 0-7, green in bits 8-15, and\n+   * red in bits 16-23. The other bits are ignored. The alpha value is set\n+   * to 255, meaning that the color is fully opaque.\n+   *\n+   * @param rgb the rgb value, as discussed above.\n+   */\n+  public ColorUIResource(int rgb)\n   {\n-    super(r, g, b, 1.0f);\n+    super(rgb);\n   }\n-  public ColorUIResource(int rgb)\n+\n+\n+  /**\n+   * Constructs a <code>ColorUIResource</code> using the specified\n+   * red, green, and blue intensities, which must be given as floats in\n+   * the range of 0-1. The alpha channel value will default to 1.0f,\n+   * meaning that the color is fully opaque.\n+   *\n+   * @param r the red intensity, which must be in the range [0.0 .. 1.0].\n+   * @param g the green intensity, which must be in the range [0.0 .. 1.0].\n+   * @param b the blue intensity, which must be in the range [0.0 .. 1.0].\n+   */\n+  public ColorUIResource(float r, float g, float b)\n   {\n-    super(rgb, false);\n+    super(r, g, b);\n   }\n-  public ColorUIResource(int r, int g, int b)\n+\n+\n+  /**\n+   * Constructs a <code>ColorUIResource</code>, using the intensities\n+   * of another color.\n+   *\n+   * @param c the color whose intensities will be considered when\n+   *        constructing this <code>ColorUIResource</code>.\n+   */\n+  public ColorUIResource(Color c)\n   {\n-    super(r, g, b, 255);\n+    super(c.getRGB());\n   }\n-} // class ColorUIResource\n+}"}, {"sha": "30313f44243ffec42881473cdb19b6a49f3a0b3f", "filename": "libjava/javax/swing/plaf/ComboBoxUI.java", "status": "modified", "additions": 54, "deletions": 46, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2FComboBoxUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2FComboBoxUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2FComboBoxUI.java?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c", "patch": "@@ -37,52 +37,60 @@\n \n package javax.swing.plaf;\n \n-// Imports\n-import javax.swing.*;\n+import javax.swing.JComboBox;\n \n /**\n- * ComboBoxUI\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * An abstract base class for delegates that implement the pluggable\n+ * look and feel for a <code>JButton</code>.\n+ *\n+ * @see javax.swing.JComboBox\n+ *\n+ * @author Andrew Selkirk\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n-public abstract class ComboBoxUI extends ComponentUI {\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor ComboBoxUI\n-\t */\n-\tpublic ComboBoxUI() {\n-\t\t// TODO\n-\t} // ComboBoxUI()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * setPopupVisible\n-\t * @param combobox TODO\n-\t * @param visible TODO\n-\t */\n-\tpublic abstract void setPopupVisible(JComboBox combobox, boolean visible);\n-\n-\t/**\n-\t * isPopupVisible\n-\t * @param combobox TODO\n-\t * @returns boolean\n-\t */\n-\tpublic abstract boolean isPopupVisible(JComboBox combobox);\n-\n-\t/**\n-\t * isFocusTraversable\n-\t * @param combobox TODO\n-\t * @returns boolean\n-\t */\n-\tpublic abstract boolean isFocusTraversable(JComboBox combobox);\n-\n-\n-} // ComboBoxUI\n+public abstract class ComboBoxUI\n+  extends ComponentUI\n+{\n+  /**\n+   * Constructs a new <code>ComboBoxUI</code>.\n+   */\n+  public ComboBoxUI()\n+  {\n+  }\n+  \n+  \n+  /**\n+   * Sets the visibility of the popup button.\n+   *\n+   * @param c the <code>JComboBox</code> whose popup\n+   *        is shown or hidden.\n+   *\n+   * @param visible <code>true</code> to show the popup, <code>false</code>\n+   *        to hide it.\n+   */\n+  public abstract void setPopupVisible(JComboBox c, boolean visible);\n+\n+\n+  /**\n+   * Determines whether the popup button is currently visible.\n+   *\n+   * @param c the <code>JComboBox</code> whose popup visibility\n+   *        is retrieved.\n+   *\n+   * @return <code>true</code> if the popup button is currently\n+   *         visible, <code>false</code> otherwise.\n+   */\n+  public abstract boolean isPopupVisible(JComboBox c);\n+  \n+  \n+  /**\n+   * Determines whether the combo box can receive input focus.\n+   *\n+   * @param c <code>JComboBox</code> whose focus traversability\n+   *        is to be retrieved.\n+   *\n+   * @returns <code>true</code> if <code>c</code> can receive\n+   *          input focus, <code>false</code> otherwise.\n+   */\n+  public abstract boolean isFocusTraversable(JComboBox c);\n+}"}, {"sha": "1b14e8e876c3080a032fc6ee86a5d5b5022e15ef", "filename": "libjava/javax/swing/plaf/ComponentInputMapUIResource.java", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2FComponentInputMapUIResource.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2FComponentInputMapUIResource.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2FComponentInputMapUIResource.java?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c", "patch": "@@ -1,5 +1,5 @@\n /* ComponentInputMapUIResource.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,28 +37,34 @@\n \n package javax.swing.plaf;\n \n-// Imports\n-import javax.swing.*;\n+import javax.swing.ComponentInputMap;\n+import javax.swing.JComponent;\n+\n \n /**\n- * ComponentInputMapUIResource\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * A <code>ComponentInputMap</code> that implements the {@link UIResource}\n+ * interface to indicate that it belongs to a pluggable\n+ * LookAndFeel.\n+ *\n+ * @see javax.swing.ComponentInputMap\n+ * @see javax.swing.InputMap\n+ *\n+ * @author Andrew Selkirk\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n-public class ComponentInputMapUIResource extends ComponentInputMap implements UIResource {\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor ComponentInputMapUIResource\n-\t * @param component TODO\n-\t */\n-\tpublic ComponentInputMapUIResource(JComponent component) {\n-\t\tsuper(component);\n-\t\t// TODO\n-\t} // ComponentInputMapUIResource()\n-\n+public class ComponentInputMapUIResource\n+  extends ComponentInputMap\n+  implements UIResource\n+{\n+  /**\n+   * Constructs a new <code>ComponentInputMapUIResource</code>.\n+   *\n+   * @param component the <code>JComponent</code> associated with\n+   *        this <code>InputMap</code>.\n+   */\n+  public ComponentInputMapUIResource(JComponent component)\n+  {\n+    super(component);\n+  }\n+}\n \n-} // ComponentInputMapUIResource"}, {"sha": "8b8a8513fc3f09c5c36d556d727019657f4fba1a", "filename": "libjava/javax/swing/plaf/basic/BasicBorders.java", "status": "modified", "additions": 817, "deletions": 6, "changes": 823, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicBorders.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicBorders.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicBorders.java?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c", "patch": "@@ -42,18 +42,22 @@\n import java.awt.Component;\n import java.awt.Graphics;\n import java.awt.Insets;\n+import java.awt.Rectangle;\n import java.io.Serializable;\n import javax.swing.AbstractButton;\n import javax.swing.ButtonModel;\n import javax.swing.JButton;\n import javax.swing.JPopupMenu;\n+import javax.swing.JSplitPane;\n import javax.swing.JToolBar;\n import javax.swing.UIDefaults;\n import javax.swing.UIManager;\n import javax.swing.border.AbstractBorder;\n+import javax.swing.border.BevelBorder;\n import javax.swing.border.Border;\n import javax.swing.plaf.UIResource;\n import javax.swing.plaf.BorderUIResource;\n+import javax.swing.text.JTextComponent;\n \n \n /**\n@@ -245,12 +249,178 @@ public static Border getMenuBarBorder()\n   {\n     UIDefaults defaults;\n \n+    /* See comment in methods above for why this border is not shared. */\n     defaults = UIManager.getLookAndFeelDefaults();\n     return new MenuBarBorder(defaults.getColor(\"MenuBar.shadow\"),\n                              defaults.getColor(\"MenuBar.highlight\"));\n   }\n \n \n+  /**\n+   * Returns a border for drawing a one-pixel thick border around\n+   * split panes that are interrupted where the divider joins the\n+   * border.\n+   *\n+   * <p>The colors of the border are retrieved from the\n+   * <code>UIDefaults</code> of the currently active look and feel\n+   * using the keys <code>&#x201c;SplitPane.darkShadow&#x201d;</code> and\n+   * <code>&#x201c;SplitPane.highlight&#x201d;</code>.\n+   *   \n+   * <p><img src=\"BasicBorders.SplitPaneBorder-1.png\" width=\"520\"\n+   * height=\"200\" alt=\"[A screen shot for JSplitPane.HORIZONTAL_SPLIT]\" />\n+   *\n+   * <p><img src=\"BasicBorders.SplitPaneBorder-2.png\" width=\"520\"\n+   * height=\"200\" alt=\"[A screen shot for JSplitPane.VERTICAL_SPLIT]\" />\n+   *\n+   * @return a {@link #SplitPaneBorder}.\n+   *\n+   * @see javax.swing.JSplitPane\n+   * @see #getSplitPaneDividerBorder()\n+   */\n+  public static Border getSplitPaneBorder()\n+  {\n+    UIDefaults defaults;\n+\n+    /* See comment in methods above for why this border is not shared. */\n+    defaults = UIManager.getLookAndFeelDefaults();\n+    return new SplitPaneBorder(defaults.getColor(\"SplitPane.highlight\"),\n+                               defaults.getColor(\"SplitPane.darkShadow\"));\n+  }\n+\n+\n+  /**\n+   * Returns a border for drawing a one-pixel thick border around\n+   * the divider of split panes.\n+   *\n+   * <p>The colors of the edges that are adjacent to the child components\n+   * of the <code>JSplitPane</code> are retrieved from the\n+   * <code>UIDefaults</code> of the currently active look and feel\n+   * using the keys <code>&#x201c;SplitPane.darkShadow&#x201d;</code> and\n+   * <code>&#x201c;SplitPane.highlight&#x201d;</code>. The color of the\n+   * other two edges is the background color of the divider.\n+   *\n+   * <p><img src=\"BasicBorders.SplitPaneDividerBorder-1.png\" width=\"520\"\n+   * height=\"200\" alt=\"[A screen shot for JSplitPane.HORIZONTAL_SPLIT]\" />\n+   *\n+   * @return an instance of <code>SplitPaneDividerBorder</code>, which is\n+   *         not a public API class of this package.\n+   *\n+   * @see javax.swing.JSplitPane\n+   * @see javax.swing.plaf.basic.BasicSplitPaneDivider\n+   * @see #getSplitPaneBorder()\n+   *\n+   * @since 1.3\n+   */\n+  public static Border getSplitPaneDividerBorder()\n+  {\n+    UIDefaults defaults;\n+\n+    /* See comment in methods above for why this border is not shared. */\n+    defaults = UIManager.getLookAndFeelDefaults();\n+    return new SplitPaneDividerBorder(\n+      defaults.getColor(\"SplitPane.highlight\"),\n+      defaults.getColor(\"SplitPane.darkShadow\"));\n+  }\n+\n+\n+  /**\n+   * Returns a border for drawing a border around a text field\n+   * that makes the field appear as etched into the surface.\n+   *\n+   * <p>The colors of the border are retrieved from the\n+   * <code>UIDefaults</code> of the currently active look and feel\n+   * using the keys <code>&#x201c;TextField.shadow&#x201d;</code>,\n+   * <code>&#x201c;TextField.darkShadow&#x201d;</code>,\n+   * <code>&#x201c;TextField.light&#x201d;</code>, and\n+   * <code>&#x201c;TextField.highlight&#x201d;</code>.\n+   *\n+   * <p><img src=\"BasicBorders.FieldBorder-1.png\" width=\"500\"\n+   * height=\"200\" alt=\"[A screen shot of a border returned by\n+   * this method]\" />\n+   *\n+   * @return an instance of\n+   * {@link javax.swing.plaf.basic.BasicBorders$FieldBorder}.\n+   *\n+   * @see javax.swing.JTextField\n+   * @see javax.swing.text.JTextComponent\n+   */\n+  public static Border getTextFieldBorder()\n+  {\n+    UIDefaults defaults;\n+\n+    /* See comment in methods above for why this border is not shared. */\n+    defaults = UIManager.getLookAndFeelDefaults();\n+    return new FieldBorder(\n+      defaults.getColor(\"TextField.shadow\"),\n+      defaults.getColor(\"TextField.darkShadow\"),\n+      defaults.getColor(\"TextField.light\"),\n+      defaults.getColor(\"TextField.highlight\"));\n+  }\n+  \n+\n+  /**\n+   * Returns a two-pixel thick, green\n+   * <code>LineBorderUIResource</code>.  This is so ugly that look and\n+   * feels better use different borders for their progress bars, or\n+   * they will look really terrible.\n+   *\n+   * <p><img src=\"BasicBorders-1.png\" width=\"120\" height=\"80\"\n+   * alt=\"[A screen shot of a border returned by this method]\" />\n+   */\n+  public static Border getProgressBarBorder()\n+  {\n+    /* There does not seem to exist a way to parametrize the color\n+     * or thickness of the border through UIDefaults.\n+     */\n+    return new BorderUIResource.LineBorderUIResource(Color.green, 2);\n+  }\n+\n+\n+  /**\n+   * Returns a border that is composed of a raised bevel border and a\n+   * one-pixel thick line border.\n+   *\n+   * <p><img src=\"BasicBorders-2.png\" width=\"300\" height=\"200\"\n+   * alt=\"[A screen shot of a border returned by this method]\" />\n+   *\n+   * <p>The colors of the border are retrieved from the\n+   * <code>UIDefaults</code> of the currently active look and feel\n+   * using the keys <code>&#x201c;InternalFrame.borderShadow&#x201d;</code>,\n+   * <code>&#x201c;InternalFrame.borderDarkShadow&#x201d;</code>,\n+   * <code>&#x201c;InternalFrame.borderLight&#x201d;</code>,\n+   * <code>&#x201c;InternalFrame.borderHighlight&#x201d;</code>, and\n+   * (for the inner one-pixel thick line)\n+   * <code>&#x201c;InternalFrame.borderColor&#x201d;</code>.\n+   */\n+  public static Border getInternalFrameBorder()\n+  {\n+    UIDefaults defaults;\n+    Color shadow, darkShadow, highlight, lightHighlight, line;\n+\n+    /* See comment in methods above for why this border is not shared. */\n+    defaults = UIManager.getLookAndFeelDefaults();\n+    \n+    shadow = defaults.getColor(\"InternalFrame.borderShadow\");\n+    darkShadow = defaults.getColor(\"InternalFrame.borderDarkShadow\");\n+    highlight = defaults.getColor(\"InternalFrame.borderLight\");\n+    lightHighlight = defaults.getColor(\"InternalFrame.borderHighlight\");\n+    line = defaults.getColor(\"InternalFrame.borderColor\");\n+\n+    return new BorderUIResource.CompoundBorderUIResource(\n+      /* outer border */\n+      new BorderUIResource.BevelBorderUIResource(\n+        BevelBorder.RAISED,\n+        (highlight != null) ? highlight : Color.lightGray,\n+        (lightHighlight != null) ? lightHighlight : Color.white,\n+        (darkShadow != null) ? darkShadow : Color.black,\n+        (shadow != null) ? shadow : Color.gray),\n+\n+      /* inner border */\n+      new BorderUIResource.LineBorderUIResource(\n+        (line != null) ? line : Color.lightGray));\n+  }\n+\n+\n   /**\n    * Returns a shared MarginBorder.\n    */\n@@ -442,15 +612,172 @@ public Insets getBorderInsets(Component c, Insets insets)\n   }\n   \n   \n+  /**\n+   * A border that makes its enclosed component appear as lowered\n+   * into the surface. Typically used for text fields.\n+   *\n+   * <p><img src=\"BasicBorders.FieldBorder-1.png\" width=\"500\"\n+   * height=\"200\" alt=\"[A screen shot of this border]\" />\n+   *\n+   * @see javax.swing.plaf.basic.BasicGraphicsUtils#drawEtchedRect\n+   *\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n   public static class FieldBorder\n+    extends AbstractBorder\n+    implements UIResource\n   {\n+    /**\n+     * Determined using the <code>serialver</code> tool\n+     * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+     */\n+    static final long serialVersionUID = 949220756998454908L;\n+\n+\n+    /**\n+     * The color for drawing the outer half of the top and left\n+     * edges.\n+     */\n+    protected Color shadow;\n+\n+\n+    /**\n+     * The color for drawing the inner half of the top and left\n+     * edges.\n+     */\n+    protected Color darkShadow;\n+\n+\n+    /**\n+     * The color for drawing the inner half of the bottom and right\n+     * edges.\n+     */\n+    protected Color highlight;\n+\n+\n+    /**\n+     * The color for drawing the outer half of the bottom and right\n+     * edges.\n+     */\n+    protected Color lightHighlight;\n+\n+\n+    /**\n+     * Constructs a new border for drawing a text field in the Basic\n+     * look and feel.\n+     *\n+     * @param shadow the color for drawing the outer half\n+     *        of the top and left edges.\n+     *\n+     * @param darkShadow the color for drawing the inner half\n+     *        of the top and left edges.\n+     *\n+     * @param highlight the color for drawing the inner half\n+     *        of the bottom and right edges.\n+     *\n+     * @param lightHighlight the color for drawing the outer half\n+     *        of the bottom and right edges.\n+     */\n     public FieldBorder(Color shadow, Color darkShadow,\n                        Color highlight, Color lightHighlight)\n     {\n+      /* These colors usually come from the UIDefaults of the current\n+       * look and feel. Use fallback values if the colors are not\n+       * supplied.  The API specification is silent about what\n+       * behavior is expected for null colors, so users should not\n+       * rely on this fallback (which is why it is not documented in\n+       * the above Javadoc).\n+       */\n+      this.shadow = (shadow != null) ? shadow : Color.gray;\n+      this.darkShadow = (darkShadow != null) ? darkShadow : Color.black;\n+      this.highlight = (highlight != null) ? highlight : Color.lightGray;\n+      this.lightHighlight = (lightHighlight != null)\n+        ? lightHighlight : Color.white;\n+    }\n+\n+    \n+    /**\n+     * Paints the FieldBorder around a given component.\n+     *\n+     * @param c the component whose border is to be painted.\n+     * @param g the graphics for painting.\n+     * @param x the horizontal position for painting the border.\n+     * @param y the vertical position for painting the border.\n+     * @param width the width of the available area for painting the border.\n+     * @param height the height of the available area for painting the border.\n+     *\n+     * @see javax.swing.plaf.basic.BasicGraphicsUtils#drawEtchedRect\n+     */\n+    public void paintBorder(Component c, Graphics  g,\n+                            int x, int y, int width, int height)\n+    {\n+      BasicGraphicsUtils.drawEtchedRect(g, x, y, width, height,\n+                                        shadow, darkShadow,\n+                                        highlight, lightHighlight);\n     }\n-  } // class FieldBorder\n+    \n+    \n+    /**\n+     * Measures the width of this border.\n+     *\n+     * @param c the component whose border is to be measured.\n+     *        If <code>c</code> is an instance of {@link\n+     *        javax.swing.text.JTextComponent}, its margin is\n+     *        added to the border size.\n+     *\n+     * @return an Insets object whose <code>left</code>,\n+     *         <code>right</code>, <code>top</code> and\n+     *         <code>bottom</code> fields indicate the width of the\n+     *         border at the respective edge.\n+     *\n+     * @see #getBorderInsets(java.awt.Component, java.awt.Insets)\n+     */\n+    public Insets getBorderInsets(Component c)\n+    {\n+      return getBorderInsets(c, null);\n+    }\n+\n+\n+    /**\n+     * Measures the width of this border, storing the results into a\n+     * pre-existing Insets object.\n+     *\n+     * @param c the component whose border is to be measured.\n+     *        If <code>c</code> is an instance of {@link\n+     *        javax.swing.text.JTextComponent}, its margin is\n+     *        added to the border size.\n+     *\n+     * @param insets an Insets object for holding the result values.\n+     *        After invoking this method, the <code>left</code>,\n+     *        <code>right</code>, <code>top</code> and\n+     *        <code>bottom</code> fields indicate the width of the\n+     *        border at the respective edge.\n+     *\n+     * @return the same object that was passed for <code>insets</code>.\n+     *\n+     * @see #getBorderInsets()\n+     */\n+    public Insets getBorderInsets(Component c, Insets insets)\n+    {\n+      if (insets == null)\n+        insets = new Insets(2, 2, 2, 2);\n+      else\n+        insets.top = insets.left = insets.bottom = insets.right = 2;\n \n+      if (c instanceof JTextComponent)\n+      {\n+        Insets margin = ((JTextComponent) c).getMargin();\n+        insets.top += margin.top;\n+        insets.left += margin.left;\n+        insets.bottom += margin.bottom;\n+        insets.right += margin.right;\n+      }\n \n+      return insets;\n+    }\n+  }\n+  \n+  \n   /**\n    * An invisible, but spacing border whose margin is determined\n    * by calling the <code>getMargin()</code> method of the enclosed\n@@ -512,8 +839,9 @@ public Insets getBorderInsets(Component c)\n      * determine the existence of this method, this would be slow on\n      * many virtual machines. Therefore, the current implementation\n      * knows about {@link javax.swing.AbstractButton#getMargin()},\n-     * {@link javax.swing.JPopupMenu#getMargin()}, and {@link\n-     * javax.swing.JToolBar#getMargin()}. If <code>c</code> is an\n+     * {@link javax.swing.JPopupMenu#getMargin()}, {@link\n+     * javax.swing.JToolBar#getMargin()}, and {@link\n+     * javax.swing.text.JTextComponent}. If <code>c</code> is an\n      * instance of a known class, the respective\n      * <code>getMargin()</code> method is called to determine the\n      * correct margin. Otherwise, a zero-width margin is returned.\n@@ -536,7 +864,9 @@ else if (c instanceof JPopupMenu)\n         margin = ((JPopupMenu) c).getMargin();\n       else if (c instanceof JToolBar)\n         margin = ((JToolBar) c).getMargin();\n-\n+      else if (c instanceof JTextComponent)\n+        margin = ((JTextComponent) c).getMargin();\n+      \n       if (margin == null)\n         insets.top = insets.left = insets.bottom = insets.right = 0;\n       else\n@@ -862,15 +1192,496 @@ public Insets getBorderInsets(Component c, Insets insets)\n   }\n \n \n+  /**\n+   * A one-pixel thick border for rollover buttons, for example in\n+   * tool bars.\n+   *\n+   * @since 1.4\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n   public static class RolloverButtonBorder\n+    extends ButtonBorder\n   {\n-  } // class RolloverButtonBorder\n+    /**\n+     * Determined using the <code>serialver</code> tool\n+     * of Sun JDK 1.4.1_01 on GNU/Linux 2.4.20 for x86.\n+     */\n+    static final long serialVersionUID = 1976364864896996846L;\n+\n+\n+    /**\n+     * Constructs a new border for drawing a roll-over button\n+     * in the Basic look and feel.\n+     *\n+     * @param shadow the shadow color.\n+     * @param darkShadow a darker variant of the shadow color.\n+     * @param highlight the highlight color.\n+     * @param lightHighlight a brighter variant of the highlight  color.\n+     */\n+    public RolloverButtonBorder(Color shadow, Color darkShadow,\n+                                Color highlight, Color lightHighlight)\n+    {\n+      super(shadow, darkShadow, highlight, lightHighlight);\n+    }\n+\n+\n+    /**\n+     * Paints the border around a rollover button.  If <code>c</code>\n+     * is not an {@link javax.swing.AbstractButton} whose model\n+     * returns <code>true</code> for {@link\n+     * javax.swing.ButtonModel#isRollver}, nothing gets painted at\n+     * all.\n+     *\n+     * @param c the button whose border is to be painted.\n+     * @param g the graphics for painting.\n+     * @param x the horizontal position for painting the border.\n+     * @param y the vertical position for painting the border.\n+     * @param width the width of the available area for painting the border.\n+     * @param height the height of the available area for painting the border.\n+     */\n+    public void paintBorder(Component c, Graphics  g,\n+                            int x, int y, int width, int height)\n+    {\n+      ButtonModel bmodel = null;\n+      boolean drawPressed;\n+      Color oldColor = g.getColor();\n+      int x2, y2;\n+\n+      if (c instanceof AbstractButton)\n+        bmodel = ((AbstractButton) c).getModel();\n+\n+      /* Draw nothing if c is not a rollover button. */\n+      if ((bmodel == null) || !bmodel.isRollover())\n+        return;\n+\n+      /* Draw nothing if the mouse is pressed, but outside the button. */\n+      if (bmodel.isPressed() && !bmodel.isArmed())\n+        return;\n+\n+      drawPressed = bmodel.isSelected() || bmodel.isPressed();\n+      x2 = x + width - 1;\n+      y2 = y + height - 1;\n+\n+      try\n+      {\n+        g.setColor(drawPressed ? shadow : lightHighlight);\n+        g.drawLine(x, y, x2 - 1, y);     // top edge\n+        g.drawLine(x, y + 1, x, y2 - 1); // left edge\n+\n+        g.setColor(drawPressed ? lightHighlight : shadow);\n+        g.drawLine(x, y2, x2, y2);       // bottom edge\n+        g.drawLine(x2, y, x2, y2 - 1);   // right edge\n+      }\n+      finally\n+      {\n+        g.setColor(oldColor);\n+      }\n+    }\n+  }\n+\n+\n+  /**\n+   * A border for JSplitPanes in the Basic look and feel. The divider\n+   * in the middle of the JSplitPane has its own border class, of which\n+   * an instance can be obtained with {@link #getSplitPaneDividerBorder()}.\n+   *\n+   * <p><img src=\"BasicBorders.SplitPaneBorder-1.png\" width=\"520\"\n+   * height=\"200\" alt=\"[A screen shot for JSplitPane.HORIZONTAL_SPLIT]\" />\n+   *\n+   * <p><img src=\"BasicBorders.SplitPaneBorder-2.png\" width=\"520\"\n+   * height=\"200\" alt=\"[A screen shot for JSplitPane.VERTICAL_SPLIT]\" />\n+   *\n+   * <p>In contrast to the other borders of the Basic look and feel,\n+   * this class is not serializable. While this might be unintended,\n+   * GNU Classpath follows the specification in order to be fully\n+   * compatible with the Sun reference implementation.\n+   *\n+   * <p>In the Sun JDK, the bottom edge of the divider also gets\n+   * painted if the orientation of the enclosed JSplitPane is\n+   * <code>JSplitPane.VERTICAL_SPLIT</code> (at least in versions\n+   * 1.3.1 and 1.4.1).  GNU Classpath does not replicate this bug. A\n+   * report has been filed with Sun (review ID 188773).\n+   *\n+   * <p>Note that the bottom left pixel of the border has a different\n+   * color depending on the orientation of the enclosed JSplitPane.\n+   * Although this is visually inconsistent, Classpath replicates the\n+   * appearance of the Sun reference implementation. A bug report has\n+   * been filed with Sun (review ID 188774).\n+   *\n+   * @see {@link #getSplitPaneBorder()}\n+   * @see {@link #getSplitPaneDividerBorder()}\n+   *\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n   public static class SplitPaneBorder\n+    implements Border, UIResource\n   {\n+    /**\n+     * Indicates that the top edge shall be not be painted\n+     * by {@link #paintRect(java.awt.Graphics, int, int, int, int, int)}.\n+     */\n+    private static final int SUPPRESS_TOP = 1;\n+\n+\n+    /**\n+     * Indicates that the left edge shall be not be painted\n+     * by {@link #paintRect(java.awt.Graphics, int, int, int, int, int)}.\n+     */\n+    private static final int SUPPRESS_LEFT = 2;\n+\n+\n+    /**\n+     * Indicates that the bottom edge shall be not be painted\n+     * by {@link #paintRect(java.awt.Graphics, int, int, int, int, int)}.\n+     */\n+    private static final int SUPPRESS_BOTTOM = 4;\n+\n+\n+    /**\n+     * Indicates that the right edge shall be not be painted\n+     * by {@link #paintRect(java.awt.Graphics, int, int, int, int, int)}.\n+     */\n+    private static final int SUPPRESS_RIGHT = 8;\n+\n+\n+    /**\n+     * The color for drawing the bottom and right edges of the border.\n+     */\n+    protected Color highlight;\n+\n+\n+    /**\n+     * The color for drawing the top and left edges of the border.\n+     */\n+    protected Color shadow;\n+\n+\n+    /**\n+     * Constructs a new border for drawing a JSplitPane in the Basic\n+     * look and feel.  The divider in the middle of the JSplitPane has\n+     * its own border class, <code>SplitPaneDividerBorder</code>.\n+     *\n+     * @param shadow the shadow color.\n+     * @param highlight the highlight color.\n+     */\n     public SplitPaneBorder(Color highlight, Color shadow)\n     {\n+      /* These colors usually come from the UIDefaults of the current\n+       * look and feel. Use fallback values if the colors are not\n+       * supplied.  The API specification is silent about what\n+       * behavior is expected for null colors, so users should not\n+       * rely on this fallback (which is why it is not documented in\n+       * the above Javadoc).\n+       */\n+      this.shadow = (shadow != null) ? shadow : Color.black;\n+      this.highlight = (highlight != null) ? highlight : Color.white;\n+    }\n+\n+\n+    /**\n+     * Paints the border around a <code>JSplitPane</code>.\n+     *\n+     * <p><img src=\"BasicBorders.SplitPaneBorder-1.png\" width=\"520\"\n+     * height=\"200\" alt=\"[A screen shot for JSplitPane.HORIZONTAL_SPLIT]\" />\n+     *\n+     * <p><img src=\"BasicBorders.SplitPaneBorder-2.png\" width=\"520\"\n+     * height=\"200\" alt=\"[A screen shot for JSplitPane.VERTICAL_SPLIT]\" />\n+     *\n+     * @param c the <code>JSplitPane</code> whose border is to be painted.\n+     * @param g the graphics for painting.\n+     * @param x the horizontal position for painting the border.\n+     * @param y the vertical position for painting the border.\n+     * @param width the width of the available area for painting the border.\n+     * @param height the height of the available area for painting the border.\n+     */\n+    public void paintBorder(Component c, Graphics  g,\n+                            int x, int y, int width, int height)\n+    {\n+      JSplitPane splitPane;\n+      Component content;\n+\n+      if (!(c instanceof JSplitPane))\n+        return;\n+\n+      splitPane = (JSplitPane) c;\n+      switch (splitPane.getOrientation())\n+      {\n+      case JSplitPane.HORIZONTAL_SPLIT:\n+        if ((content = splitPane.getLeftComponent()) != null)\n+          paintRect(g, SUPPRESS_RIGHT, true, x, y, content.getBounds());\n+        if ((content = splitPane.getRightComponent()) != null)\n+          paintRect(g, SUPPRESS_LEFT, true, x, y, content.getBounds());\n+        break;\n+\n+      case JSplitPane.VERTICAL_SPLIT:\n+        if ((content = splitPane.getTopComponent()) != null)\n+          paintRect(g, SUPPRESS_BOTTOM, false, x, y, content.getBounds());\n+        if ((content = splitPane.getBottomComponent()) != null)\n+          paintRect(g, SUPPRESS_TOP, false, x, y, content.getBounds());\n+        break;\n+      }\n+    }\n+\n+\n+    /**\n+     * Paints a border around a child of a <code>JSplitPane</code>,\n+     * omitting some of the edges.\n+     *\n+     * @param g the graphics for painting.\n+     *\n+     * @param suppress a bit mask indicating the set of suppressed\n+     *        edges, for example <code>SUPPRESS_TOP | SUPPRESS_RIGHT</code>.\n+     *\n+     * @param x the x coordinate of the SplitPaneBorder.\n+     *\n+     * @param y the y coordinate of the SplitPaneBorder.\n+     *\n+     * @param shadeBottomLeftPixel <code>true</code> to paint the\n+     *        bottom left pixel in the shadow color,\n+     *        <code>false</code> for the highlight color. The Basic\n+     *        look and feel uses the highlight color for the bottom\n+     *        left pixel of the border of a JSplitPane whose\n+     *        orientation is VERTICAL_SPLIT, and the shadow color\n+     *        otherwise. While this might be a strange distinction,\n+     *        Classpath tries to look identical to the reference\n+     *        implementation. A bug report has been filed with Sun;\n+     *        its review ID is 188774. We currently replicate the\n+     *        Sun behavior.\n+     *\n+     * @param rect the bounds of the child of JSplitPane whose\n+     *        border is to be painted.\n+     */\n+    private void paintRect(Graphics g, int suppress,\n+                           boolean shadeBottomLeftPixel,\n+                           int x, int y,\n+                           Rectangle rect)\n+    {\n+      if (rect == null)\n+        return;\n+\n+      /* On each edge, the border exceeds the enclosed child by one\n+       * pixel. See the image \"BasicBorders.SplitPaneBorder-1.png\" in\n+       * the directory \"doc-files\".\n+       */\n+      x += rect.x - 1;\n+      y += rect.y - 1;\n+      int right = x + rect.width + 1;\n+      int bottom = y + rect.height + 1;\n+      \n+      Color oldColor = g.getColor();\n+      try\n+      {\n+        g.setColor(shadow);\n+        if ((suppress & SUPPRESS_TOP) == 0)\n+          g.drawLine(x, y, right, y);\n+        if ((suppress & SUPPRESS_LEFT) == 0)\n+          g.drawLine(x, y, x, bottom);\n+        else\n+          g.drawLine(x, bottom, x, bottom); // one pixel\n+\n+        g.setColor(highlight);\n+        if ((suppress & SUPPRESS_BOTTOM) == 0)\n+          g.drawLine(x + (shadeBottomLeftPixel ? 1 : 0), bottom, right, bottom);\n+        else if (!shadeBottomLeftPixel)\n+          g.drawLine(x, bottom, x, bottom); // one pixel\n+\n+        if ((suppress & SUPPRESS_RIGHT) == 0)\n+          g.drawLine(right, y, right, bottom);\n+      }\n+      finally\n+      {\n+        g.setColor(oldColor);\n+      }\n+    }\n+\n+    \n+    /**\n+     * Measures the width of this border.\n+     *\n+     * @param c the component whose border is to be measured, usually\n+     *        an instance of {@link javax.swing.JSplitPane}.\n+     *\n+     * @return an Insets object whose <code>left</code>,\n+     *         <code>right</code>, <code>top</code> and\n+     *         <code>bottom</code> fields indicate the width of the\n+     *         border at the respective edge.\n+     */\n+    public Insets getBorderInsets(Component c)\n+    {\n+      return new Insets(1, 1, 1, 1);\n+    }\n+\n+\n+    /**\n+     * Determines whether this border fills every pixel in its area\n+     * when painting.\n+     *\n+     * @return <code>false</code> because this border does not\n+     *         paint over the pixels where the divider joins\n+     *         the border.\n+     */\n+    public boolean isBorderOpaque()\n+    {\n+      /* Strangely, the Sun implementation (tested with JDK 1.3.1 and\n+       * 1.4.1_01) seems to always return true. It could be a bug,\n+       * but without knowing the details of their implementation, it is\n+       * hard to decide.\n+       */\n+      return false;\n+    }\n+  }\n+\n+\n+  /**\n+   * A border for the divider inside a JSplitPane.\n+   *\n+   * <p><img src=\"BasicBorders.SplitPaneDividerBorder-1.png\"\n+   * width=\"520\" height=\"200\" alt=\"[A screen shot of this border]\" />\n+   *\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n+  private static class SplitPaneDividerBorder\n+    implements Border, UIResource, Serializable\n+  {\n+    /**\n+     * The highlight color, which is drawn on the left or top edge\n+     * depending on the orientation of the JSplitPanel.\n+     */\n+    protected Color highlight;\n+\n+\n+    /**\n+     * The highlight color, which is drawn on the right or bottom edge\n+     * depending on the orientation of the JSplitPanel.\n+     */\n+    protected Color shadow;\n+\n+\n+    /**\n+     * Constructs a new border for drawing the divider of a JSplitPane\n+     * in the Basic look and feel.  The outer parts of the JSplitPane have\n+     * their own border class, <code>SplitPaneBorder</code>.\n+     *\n+     * @param shadow the shadow color.\n+     * @param highlight the highlight color.\n+     */\n+    public SplitPaneDividerBorder(Color highlight, Color shadow)\n+    {\n+      this.highlight = (highlight != null) ? highlight : Color.white;\n+      this.shadow = (shadow != null) ? shadow : Color.black;\n+    }\n+\n+\n+    /**\n+     * Paints the border around the divider of a <code>JSplitPane</code>.\n+     *\n+     * <p><img src=\"BasicBorders.SplitPaneDividerBorder-1.png\" width=\"520\"\n+     * height=\"200\" alt=\"[A picture that shows which pixels get painted\n+     * in what color]\" />\n+     *\n+     * @param c the <code>JSplitPane</code> whose divider&#x2019;s border\n+     *        is to be painted.\n+     * @param g the graphics for painting.\n+     * @param x the horizontal position for painting the border.\n+     * @param y the vertical position for painting the border.\n+     * @param width the width of the available area for painting the border.\n+     * @param height the height of the available area for painting the border.\n+     */\n+    public void paintBorder(Component c, Graphics  g,\n+                            int x, int y, int width, int height)\n+    {\n+      Color oldColor, dcol;\n+      int x2, y2;\n+      JSplitPane sp;\n+\n+      sp = getSplitPane(c);\n+      if (sp == null)\n+        return;\n+\n+      x2 = x + width - 1;\n+      y2 = y + height - 1;\n+      oldColor = g.getColor();\n+      dcol = c.getBackground();\n+      try\n+      {\n+        switch (sp.getOrientation())\n+        {\n+        case JSplitPane.HORIZONTAL_SPLIT:\n+          g.setColor(dcol);\n+          g.drawLine(x + 1, y, x2 - 1, y);\n+          g.drawLine(x + 1, y2, x2 - 1, y2);\n+          g.setColor(sp.getLeftComponent() != null ? highlight : dcol);\n+          g.drawLine(x, y, x, y2);\n+          g.setColor(sp.getRightComponent() != null ? shadow : dcol);\n+          g.drawLine(x2, y, x2, y2);\n+          break;\n+\n+        case JSplitPane.VERTICAL_SPLIT:\n+          g.setColor(dcol);\n+          g.drawLine(x, y + 1, x, y2 - 1);\n+          g.drawLine(x2, y + 1, x2, y2 - 1);\n+          g.setColor(sp.getTopComponent() != null ? highlight : dcol);\n+          g.drawLine(x, y, x2, y);\n+          g.setColor(sp.getBottomComponent() != null ? shadow : dcol);\n+          g.drawLine(x, y2, x2, y2);\n+          break;\n+        }\n+      }\n+      finally\n+      {\n+        g.setColor(oldColor);\n+      }\n     }\n-  } // class SplitPaneBorder\n+\n+\n+    /**\n+     * Measures the width of this border.\n+     *\n+     * @param c the component whose border is to be measured, usually\n+     *        an instance of {@link javax.swing.JSplitPane}.\n+     *\n+     * @return an Insets object whose <code>left</code>,\n+     *         <code>right</code>, <code>top</code> and\n+     *         <code>bottom</code> fields indicate the width of the\n+     *         border at the respective edge.\n+     */\n+    public Insets getBorderInsets(Component c)\n+    {\n+      return new Insets(1, 1, 1, 1);\n+    }\n+\n+\n+    /**\n+     * Determines whether this border fills every pixel in its area\n+     * when painting.\n+     *\n+     * @return <code>true</code> if both highlight and shadow\n+     *         color are fully opaque.\n+     */\n+    public boolean isBorderOpaque()\n+    {\n+      return (highlight.getAlpha() == 255) && (shadow.getAlpha() == 255);\n+    }\n+\n+    \n+    /**\n+     * Determines the JSplitPane whose divider is being painted.\n+     *\n+     * @param c an instance of BasicSplitPaneDivider.\n+     *\n+     * @return a <code>JSplitPane</code>, or <code>null</code> if\n+     *         <code>c</code> is not an instance of {@link\n+     *         javax.swing.plaf.basic.BasicSplitPaneDivider}.\n+     */\n+    private JSplitPane getSplitPane(Component c)\n+    {\n+      if (c instanceof BasicSplitPaneDivider)\n+        return (((BasicSplitPaneDivider) c).getBasicSplitPaneUI())\n+          .getSplitPane();\n+      else\n+        return null;\n+    }\n+  }\n \n \n   /**"}, {"sha": "39db7e76bfb09b55d5b807e43dae43f35695b1bb", "filename": "libjava/javax/swing/plaf/basic/BasicSplitPaneDivider.java", "status": "added", "additions": 534, "deletions": 0, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneDivider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneDivider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneDivider.java?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c", "patch": "@@ -0,0 +1,534 @@\n+/* BasicSplitPaneDivider.java\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionListener;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import javax.swing.JButton;\n+import javax.swing.JSplitPane;\n+import javax.swing.border.Border;\n+\n+\n+/**\n+ * The divider that separates the two parts of a JSplitPane in the\n+ * Basic look and feel.\n+ *\n+ * <p>Implementation status: We do not have a real implementation yet.\n+ * Currently, it is mostly a stub to allow compiling other parts of\n+ * the javax.swing.plaf.basic package, although some parts are already\n+ * functional.\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ */\n+public class BasicSplitPaneDivider\n+  extends Container\n+  implements PropertyChangeListener\n+{\n+  /**\n+   * Determined using the <code>serialver</code> tool\n+   * of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5.\n+   */\n+  static final long serialVersionUID = 1463404307042803342L;\n+\n+\n+  /**\n+   * The width and height of the little buttons for showing and\n+   * hiding parts of a JSplitPane in a single mouse click.\n+   */\n+  protected static final int ONE_TOUCH_SIZE = 6;\n+\n+\n+  // FIXME: Javadoc.\n+  protected static final int ONE_TOUCH_OFFSET = 2;\n+\n+\n+  /**\n+   * An object that performs the tasks associated with an ongoing drag\n+   * operation, or <code>null</code> if the user is currently not\n+   * dragging the divider.\n+   */\n+  protected DragController dragger;\n+\n+\n+  /**\n+   * The delegate object that is responsible for the UI of the\n+   * <code>JSplitPane</code> that contains this divider.\n+   */\n+  protected BasicSplitPaneUI splitPaneUI;\n+\n+\n+  /**\n+   * The thickness of the divider in pixels.\n+   */\n+  protected int dividerSize;\n+  \n+\n+  /**\n+   * A divider that is used for layout purposes.\n+   */\n+  protected Component hiddenDivider;\n+\n+\n+  /**\n+   * The JSplitPane containing this divider.\n+   */\n+  protected JSplitPane splitPane;\n+\n+\n+  /**\n+   * The listener for handling mouse events from both the divider\n+   * and the containing <code>JSplitPane</code>.\n+   *\n+   * <p>The reason for also handling MouseEvents from the containing\n+   * <code>JSplitPane</code> is that users should be able to start\n+   * a drag gesture from inside the JSplitPane, but slightly outisde\n+   * the divider.\n+   */\n+  protected MouseHandler mouseHandler = new MouseHandler();\n+\n+\n+  /**\n+   * The current orientation of the containing <code>JSplitPane</code>,\n+   * which is either {@link javax.swing.JSplitPane#HORIZONTAL_SPLIT}\n+   * or {@link javax.swing.JSplitPane#VERTICAL_SPLIT}.\n+   */\n+  protected int orientation;\n+\n+\n+  /**\n+   * The button for showing and hiding the left (or top) component\n+   * of the <code>JSplitPane</code>.\n+   */\n+  protected JButton leftButton;\n+\n+\n+  /**\n+   * The button for showing and hiding the right (or bottom) component\n+   * of the <code>JSplitPane</code>.\n+   */\n+  protected JButton rightButton;\n+\n+\n+  /**\n+   * The border of this divider. Typically, this will be an instance of\n+   * {@link javax.swing.plaf.basic.BasicBorders.SplitPaneDividerBorder}.\n+   *\n+   * @see #getBorder()\n+   * @see #setBorder(javax.swing.border.Border)\n+   */\n+  private Border border;\n+\n+\n+  /**\n+   * Constructs a new divider.\n+   *\n+   * @param ui the UI delegate of the enclosing\n+   *           <code>JSplitPane</code>.\n+   */\n+  public BasicSplitPaneDivider(BasicSplitPaneUI ui)\n+  {\n+    setBasicSplitPaneUI(ui);\n+  }\n+\n+\n+  /**\n+   * Sets the delegate object that is responsible for the UI of the\n+   * {@link javax.swing.JSplitPane} containing this divider.\n+   *\n+   * @param newUI the UI delegate, or <code>null</code> to release\n+   *        the connection to the current delegate.\n+   */\n+  public void setBasicSplitPaneUI(BasicSplitPaneUI newUI)\n+  {\n+    /* Remove the connection to the existing JSplitPane. */\n+    if (splitPane != null)\n+    {\n+      splitPane.removePropertyChangeListener(this);\n+      splitPane.removeMouseListener(mouseHandler);\n+      splitPane.removeMouseMotionListener(mouseHandler);\n+      splitPane = null;\n+    }\n+    \n+    /* Establish the connection to the new JSplitPane. */\n+    splitPaneUI = newUI;\n+    if (splitPaneUI != null)\n+      splitPane = newUI.getSplitPane();\n+    if (splitPane != null)\n+    {\n+      splitPane.addPropertyChangeListener(this);\n+      splitPane.addMouseListener(mouseHandler);\n+      splitPane.addMouseMotionListener(mouseHandler);\n+      orientation = splitPane.getOrientation();\n+    }\n+  }\n+  \n+\n+  /**\n+   * Returns the delegate object that is responsible for the UI of the\n+   * {@link javax.swing.JSplitPane} containing this divider.\n+   */\n+  public BasicSplitPaneUI getBasicSplitPaneUI()\n+  {\n+    return splitPaneUI;\n+  }\n+\n+\n+  /**\n+   * Sets the thickness of the divider.\n+   *\n+   * @param newSize the new width or height in pixels.\n+   */\n+  public void setDividerSize(int newSize)\n+  {\n+    this.dividerSize = newSize;\n+  }\n+\n+\n+  /**\n+   * Retrieves the thickness of the divider.\n+   */\n+  public int getDividerSize()\n+  {\n+    return dividerSize;\n+  }\n+  \n+  \n+  /**\n+   * Sets the border of this divider.\n+   *\n+   * @param border the new border. Typically, this will be an instance of\n+   * {@link javax.swing.plaf.basic.BasicBorders.SplitPaneDividerBorder}.\n+   *\n+   * @since 1.3\n+   */\n+  public void setBorder(Border border)\n+  {\n+    Border oldValue = this.border;\n+    this.border = border;\n+    firePropertyChange(\"border\", oldValue, border);\n+  }\n+\n+\n+  /**\n+   * Retrieves the border of this divider.\n+   *\n+   * @return the current border, or <code>null</code> if no border\n+   *         has been set.\n+   *\n+   * @since 1.3\n+   */\n+  public Border getBorder()\n+  {\n+    return border;\n+  }\n+  \n+\n+  /**\n+   * Retrieves the insets of the divider. If a border has been\n+   * installed on the divider, the result of calling its\n+   * <code>getBorderInsets</code> method is returned. Otherwise,\n+   * the inherited implementation will be invoked.\n+   *\n+   * @see javax.swing.border.Border#getBorderInsets(java.awt.Component)\n+   */\n+  public Insets getInsets()\n+  {\n+    if (border != null)\n+      return border.getBorderInsets(this);\n+    else\n+      return super.getInsets();\n+  }\n+  \n+  \n+  /**\n+   * Returns the preferred size of this divider, which is\n+   * <code>dividerSize</code> by <code>dividerSize</code>\n+   * pixels.\n+   */\n+  public Dimension getPreferredSize()\n+  {\n+    return new Dimension(dividerSize, dividerSize);\n+  }\n+\n+\n+  /**\n+   * Returns the minimal size of this divider, which is\n+   * <code>dividerSize</code> by <code>dividerSize</code>\n+   * pixels.\n+   */\n+  public Dimension getMinimumSize()\n+  {\n+    return getPreferredSize();\n+  }\n+  \n+  \n+  /**\n+   * Processes events from the <code>JSplitPane</code> that contains\n+   * this divider.\n+   */\n+  public void propertyChange(PropertyChangeEvent e)\n+  {\n+    // FIXME: Not yet implemented.\n+  }\n+\n+\n+  /**\n+   * Paints the divider by painting its border.\n+   */\n+  public void paint(Graphics g)\n+  {\n+    Dimension dividerSize;\n+\n+    super.paint(g);\n+    if (border != null)\n+    {\n+      dividerSize = getSize();\n+      border.paintBorder(this, g, 0, 0, dividerSize.width, dividerSize.height);\n+      //System.out.println(dividerSize);\n+      //g.setColor(java.awt.Color.white);\n+      //g.drawRect(0, 0, 5, 5);\n+    }\n+  }\n+\n+\n+  /**\n+   * Reacts to changes of the <code>oneToughExpandable</code>\n+   * property of the containing <code>JSplitPane</code>.\n+   */\n+  protected void oneTouchExpandableChanged()\n+  {\n+    // FIXME: Not yet implemented.\n+  }\n+\n+\n+  /**\n+   * Creates a button for showing and hiding the left (or top)\n+   * part of a <code>JSplitPane</code>.\n+   */\n+  protected JButton createLeftOneTouchButton()\n+  {\n+    return new OneTouchButton(/* left */ true);\n+  }\n+\n+\n+  /**\n+   * Creates a button for showing and hiding the right (or bottom)\n+   * part of a <code>JSplitPane</code>.\n+   */\n+  protected JButton createRightOneTouchButton()\n+  {\n+    return new OneTouchButton(/* left */ false);\n+  }\n+  \n+\n+  /**\n+   * Prepares the divider for dragging by calling the\n+   * <code>startDragging</code> method of the UI delegate of the\n+   * enclosing <code>JSplitPane</code>.\n+   *\n+   * @see BasicSplitPaneUI#startDragging()\n+   */\n+  protected void prepareForDragging()\n+  {\n+    if (splitPaneUI != null)\n+      splitPaneUI.startDragging();\n+  }\n+\n+\n+  /**\n+   * Drags the divider to a given location by calling the\n+   * <code>dragDividerTo</code> method of the UI delegate of the\n+   * enclosing <code>JSplitPane</code>.\n+   *\n+   * @param location the new location of the divider.\n+   *\n+   * @see BasicSplitPaneUI#dragDividerTo(int location) \n+   */\n+  protected void dragDividerTo(int location)\n+  {\n+    if (splitPaneUI != null)\n+      splitPaneUI.dragDividerTo(location);\n+  }\n+\n+\n+  /**\n+   * Finishes a dragging gesture by calling the\n+   * <code>finishDraggingTo</code> method of the UI delegate of the\n+   * enclosing <code>JSplitPane</code>.\n+   *\n+   * @param location the new, final location of the divider.\n+   *\n+   * @see BasicSplitPaneUI#finishDraggingTo(int location)\n+   */\n+  protected void finishDraggingTo(int location)\n+  {\n+    if (splitPaneUI != null)\n+      splitPaneUI.finishDraggingTo(location);\n+  }\n+\n+\n+  /**\n+   * The listener for handling mouse events from both the divider\n+   * and the containing <code>JSplitPane</code>.\n+   *\n+   * <p>The reason for also handling MouseEvents from the containing\n+   * <code>JSplitPane</code> is that users should be able to start\n+   * a drag gesture from inside the JSplitPane, but slightly outisde\n+   * the divider. \n+   *\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n+  protected class MouseHandler\n+    extends MouseAdapter\n+    implements MouseMotionListener\n+  {\n+    \n+    public void mousePressed(MouseEvent e)\n+    {\n+      // FIXME: Not yet implemented.\n+    }\n+\n+\n+    public void mouseReleased(MouseEvent e)\n+    {\n+      // FIXME: Not yet implemented.\n+    }\n+\n+\n+    /**\n+     * Repeatedly invoked when the user is dragging the mouse cursor\n+     * while having pressed a mouse button.\n+     */\n+    public void mouseDragged(MouseEvent e)\n+    {\n+      // FIXME: Not yet implemented.\n+    }\n+\n+\n+    /**\n+     * Repeatedly invoked when the user is dragging the mouse cursor\n+     * without having pressed a mouse button.\n+     */\n+    public void mouseMoved(MouseEvent e)\n+    {\n+      // FIXME: Not yet implemented.\n+    }\n+  }\n+\n+\n+  /**\n+   * A small button for showing and hiding parts of a\n+   * <code>JSplitPane</code> with a single mouse click.\n+   *\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n+  private static class OneTouchButton\n+    extends JButton\n+  {\n+    OneTouchButton(boolean left)\n+    {\n+      // FIXME: Set various properties of the button.\n+      // Make  sure it looks identical to the small\n+      // buttons of the Sun reference implementation.\n+      // The size should also be the same.\n+      if (left)\n+        setText(\"<\");\n+      else\n+        setText(\">\");\n+\n+      Dimension butSize = new Dimension(ONE_TOUCH_SIZE, ONE_TOUCH_SIZE);\n+      setMinimumSize(butSize);\n+      setMaximumSize(butSize);\n+      setPreferredSize(butSize);\n+\n+      setBorderPainted(false);\n+    }\n+  }\n+\n+\n+  /**\n+   * Performs the tasks associated with an ongoing drag\n+   * operation.\n+   *\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n+   */\n+  protected class DragController\n+  {\n+    // FIXME: Not yet implemented.\n+    protected DragController(MouseEvent e)\n+    {\n+    }\n+\n+    protected boolean isValid()\n+    {\n+      // FIXME: Not yet implemented.\n+      return true;\n+    }\n+\n+    protected int positionForMouseEvent(MouseEvent e)\n+    {\n+      return 0;\n+    }\n+\n+    protected int getNeededLocation(int x, int y)\n+    {\n+      return 0;\n+    }\n+\n+    protected void continueDrag(int newX, int newY)\n+    {\n+    }\n+\n+    protected void completeDrag(int x, int y)\n+    {\n+    }\n+\n+    protected void completeDrag(MouseEvent e)\n+    {\n+    }\n+  }\n+}"}, {"sha": "5c1c7f25e4f84c7feb2b516d2bf0a8e9c6435132", "filename": "libjava/javax/swing/plaf/basic/BasicSplitPaneUI.java", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c", "patch": "@@ -0,0 +1,309 @@\n+/* BasicSplitPaneUI.java\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.event.ActionListener;\n+import java.awt.event.FocusListener;\n+import java.beans.PropertyChangeListener;\n+import javax.swing.JComponent;\n+import javax.swing.JSplitPane;\n+import javax.swing.KeyStroke;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.SplitPaneUI;\n+\n+/**\n+ * FIXME: Stubbed to allow compiling other classes,\n+ * no real implementation.\n+ */\n+public class BasicSplitPaneUI\n+  extends SplitPaneUI\n+{\n+  protected static final String NON_CONTINUOUS_DIVIDER\n+    = \"nonContinuousDivider\";\n+\n+  protected static int KEYBOARD_DIVIDER_MOVE_OFFSET;\n+\n+  protected JSplitPane splitPane;\n+  protected BasicSplitPaneDivider divider;\n+  protected PropertyChangeListener propertyChangeListener;\n+  protected FocusListener focusListener;\n+  protected int dividerSize;\n+  protected Component nonContinuousLayoutDivider;\n+  protected boolean draggingHW;\n+  protected int beginDragDividerLocation;\n+  protected KeyStroke upKey;\n+  protected KeyStroke downKey;\n+  protected KeyStroke leftKey;\n+  protected KeyStroke rightKey;\n+  protected KeyStroke homeKey;\n+  protected KeyStroke endKey;\n+  protected KeyStroke dividerResizeToggleKey;\n+  protected ActionListener keyboardUpLeftListener;\n+  protected ActionListener keyboardDownRightListener;\n+  protected ActionListener keyboardHomeListener;\n+  protected ActionListener keyboardEndListener;\n+  protected ActionListener keyboardResizeToggleListener;\n+\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    BasicSplitPaneUI newUI;\n+\n+    newUI = new BasicSplitPaneUI();\n+    newUI.installUI(c);\n+    return newUI;\n+  }\n+\n+  public BasicSplitPaneUI()\n+  {\n+    propertyChangeListener = createPropertyChangeListener();\n+    focusListener = createFocusListener();\n+  }\n+\n+  public void installUI(JComponent c)\n+  {\n+  }\n+\n+  protected void installDefaults()\n+  {\n+  }\n+\n+  protected void installListeners()\n+  {\n+  }\n+\n+  protected void installKeyboardListeners()\n+  {\n+  }\n+\n+  protected void installKeyboardActions()\n+  {\n+  }\n+\n+  public void uninstallUI(JComponent c)\n+  {\n+  }\n+\n+  protected void uninstallDefaults()\n+  {\n+  }\n+\n+  protected void uninstallListeners()\n+  {\n+  }\n+\n+  protected void uninstallKeyboardActions()\n+  {\n+  }\n+\n+  protected PropertyChangeListener createPropertyChangeListener()\n+  {\n+    return null;\n+  }\n+\n+  protected FocusListener createFocusListener()\n+  {\n+    return null;\n+  }\n+\n+  protected ActionListener createKeyboardUpLeftListener()\n+  {\n+    return null;\n+  }\n+\n+  protected ActionListener createKeyboardDownRightListener()\n+  {\n+    return null;\n+  }\n+\n+  protected ActionListener createKeyboardHomeListener()\n+  {\n+    return null;\n+  }\n+\n+  protected ActionListener createKeyboardEndListener()\n+  {\n+    return null;\n+  }\n+\n+  protected ActionListener createKeyboardResizeToggleListener()\n+  {\n+    return null;\n+  }\n+\n+  public int getOrientation()\n+  {\n+    return splitPane.getOrientation();\n+  }\n+\n+  public void setOrientation(int orientation)\n+  {\n+  }\n+\n+\n+  public boolean isContinuousLayout()\n+  {\n+    return false;\n+  }\n+\n+  public void setContinuousLayout(boolean b)\n+  {\n+  }\n+\n+  public int getLastDragLocation()\n+  {\n+    return 0;\n+  }\n+\n+  public void setLastDragLocation(int l)\n+  {\n+  }\n+\n+\n+  public BasicSplitPaneDivider getDivider()\n+  {\n+    return divider;\n+  }\n+\n+\n+  protected Component createDefaultNonContinuousLayoutDivider()\n+  {\n+    return null;\n+  }\n+\n+  protected void setNonContinuousLayoutDivider(Component newDivider)\n+  {\n+    setNonContinuousLayoutDivider(newDivider, true /* false? */);\n+  }\n+\n+  protected void setNonContinuousLayoutDivider(Component newDivider,\n+                                               boolean rememberSizes)\n+  {\n+    nonContinuousLayoutDivider = newDivider;\n+  }\n+\n+  public Component getNonContinuousLayoutDivider()\n+  {\n+    return nonContinuousLayoutDivider;\n+  }\n+\n+  public JSplitPane getSplitPane()\n+  {\n+    return splitPane;\n+  }\n+\n+  public BasicSplitPaneDivider createDefaultDivider()\n+  {\n+    return null;\n+  }\n+\n+  public void resetToPreferredSizes(JSplitPane jc)\n+  {\n+  }\n+\n+  public void setDividerLocation(JSplitPane jc, int location)\n+  {\n+  }\n+\n+  public int getDividerLocation(JSplitPane jc)\n+  {\n+    return 0;\n+  }\n+\n+  public int getMinimumDividerLocation(JSplitPane jc)\n+  {\n+    return 0;\n+  }\n+\n+  public int getMaximumDividerLocation(JSplitPane jc)\n+  {\n+    return 0;\n+  }\n+\n+  public void finishedPaintingChildren(JSplitPane jc, Graphics g)\n+  {\n+  }\n+\n+  public void paint(Graphics g, JComponent jc)\n+  {\n+  }\n+\n+  public Dimension getPreferredSize(JComponent jc)\n+  {\n+    return null;\n+  }\n+\n+  public Dimension getMinimumSize(JComponent jc)\n+  {\n+    return null;\n+  }\n+\n+  public Dimension getMaximumSize(JComponent jc)\n+  {\n+    return null;\n+  }\n+\n+  public Insets getInsets(JComponent jc)\n+  {\n+    return new Insets(0, 0, 0, 0);\n+  }\n+\n+  protected void resetLayoutManager()\n+  {\n+  }\n+\n+  protected void startDragging()\n+  {\n+  }\n+\n+  protected void dragDividerTo(int location)\n+  {\n+  }\n+\n+  protected void finishDraggingTo(int location)\n+  {\n+  }\n+\n+  protected int getDividerBorderSize()\n+  {\n+    return 0;\n+  }\n+}"}, {"sha": "daeb16c78eb2f0aaedd14cb5c83a819f988ed111", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicBorders-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders-1.png?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c"}, {"sha": "60f6a8abe4207fdd7020b25b7131684606099cd8", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicBorders-2.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders-2.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders-2.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders-2.png?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c"}, {"sha": "7c89911062c6b08eba38b440ba25376a10dcc2f3", "filename": "libjava/javax/swing/plaf/basic/doc-files/BasicBorders.FieldBorder-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.FieldBorder-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.FieldBorder-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2Fdoc-files%2FBasicBorders.FieldBorder-1.png?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c"}, {"sha": "a78d97b90e68fbc3229f179fce8721ca07ca5f62", "filename": "libjava/javax/swing/plaf/doc-files/ComponentUI-1.dia", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fdoc-files%2FComponentUI-1.dia", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fdoc-files%2FComponentUI-1.dia", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fdoc-files%2FComponentUI-1.dia?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c"}, {"sha": "da4a0fc8dc9c7a4ab1bf6360ea773f8faacaa8e8", "filename": "libjava/javax/swing/plaf/doc-files/ComponentUI-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fdoc-files%2FComponentUI-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ea8550734007723696ff2f3d8ce38f1df6078c/libjava%2Fjavax%2Fswing%2Fplaf%2Fdoc-files%2FComponentUI-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fdoc-files%2FComponentUI-1.png?ref=a0ea8550734007723696ff2f3d8ce38f1df6078c"}]}