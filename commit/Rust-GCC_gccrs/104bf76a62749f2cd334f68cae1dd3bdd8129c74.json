{"sha": "104bf76a62749f2cd334f68cae1dd3bdd8129c74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA0YmY3NmE2Mjc0OWYyY2QzMzRmNjhjYWUxZGQzYmRkODEyOWM3NA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-12-09T16:20:05Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-12-09T16:20:05Z"}, "message": "cp-tree.h (most_specialized_instantiation): New function.\n\n\t* cp-tree.h (most_specialized_instantiation): New function.\n\t(print_candidates): Likewise.\n\t* class.c (validate_lhs): Remove.\n\t(resolve_address_of_overloaded_function): New function, split out\n\tand then substantially reworked, from ...\n\t(instantiate_type): Use it.  Simplify.\n\t* cvt.c (convert_to_reference): Complain when caller has indicated\n\tthat's the right thing to do.  Don't crash if instantiate_type\n\tfails.\n\t* pt.c: Substitute `parameters' for `paramters' throughout.\n\t(print_candidates): Don't make it static.\n\t(most_specialized_instantiation): Split out from ...\n\t(most_specialized): Here.\n\nFrom-SVN: r24225", "tree": {"sha": "69c4406fe4c67481e64f9fe45b9f71d673cd6ead", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69c4406fe4c67481e64f9fe45b9f71d673cd6ead"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/104bf76a62749f2cd334f68cae1dd3bdd8129c74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/104bf76a62749f2cd334f68cae1dd3bdd8129c74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/104bf76a62749f2cd334f68cae1dd3bdd8129c74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/104bf76a62749f2cd334f68cae1dd3bdd8129c74/comments", "author": null, "committer": null, "parents": [{"sha": "f8976021c4079ce1461fffb45622437ec13ff597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8976021c4079ce1461fffb45622437ec13ff597", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8976021c4079ce1461fffb45622437ec13ff597"}], "stats": {"total": 564, "additions": 375, "deletions": 189}, "files": [{"sha": "cf09c640bcaca20251ae8d6d7364f09b2c5029e4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=104bf76a62749f2cd334f68cae1dd3bdd8129c74", "patch": "@@ -1,3 +1,19 @@\n+1998-12-09  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (most_specialized_instantiation): New function.\n+\t(print_candidates): Likewise.\n+\t* class.c (validate_lhs): Remove.\n+\t(resolve_address_of_overloaded_function): New function, split out\n+\tand then substantially reworked, from ...\n+\t(instantiate_type): Use it.  Simplify.\n+\t* cvt.c (convert_to_reference): Complain when caller has indicated\n+\tthat's the right thing to do.  Don't crash if instantiate_type\n+\tfails.\n+\t* pt.c: Substitute `parameters' for `paramters' throughout.\n+\t(print_candidates): Don't make it static.\n+\t(most_specialized_instantiation): Split out from ...\n+\t(most_specialized): Here.\n+\n Wed Dec  9 15:33:01 1998  Dave Brolley  <brolley@cygnus.com>\n \n \t* lex.c (lang_init_options): Initialize cpplib."}, {"sha": "806ba6213216b8e90e0a4c7483637837eb72620e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 243, "deletions": 157, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=104bf76a62749f2cd334f68cae1dd3bdd8129c74", "patch": "@@ -4971,27 +4971,245 @@ pop_lang_context ()\n \f\n /* Type instantiation routines.  */\n \n+/* Given an OVERLOAD and a TARGET_TYPE, return the function that\n+   matches the TARGET_TYPE.  If there is no satisfactory match, return\n+   error_mark_node, and issue an error message if COMPLAIN is\n+   non-zero.  If TEMPLATE_ONLY, the name of the overloaded function\n+   was a template-id, and EXPLICIT_TARGS are the explicitly provided\n+   template arguments.  */\n+\n static tree\n-validate_lhs (lhstype, complain)\n-     tree lhstype;\n+resolve_address_of_overloaded_function (target_type, \n+\t\t\t\t\toverload,\n+\t\t\t\t\tcomplain, \n+\t\t\t\t\ttemplate_only,\n+\t\t\t\t\texplicit_targs)\n+     tree target_type;\n+     tree overload;\n      int complain;\n+     int template_only;\n+     tree explicit_targs;\n {\n-  if (TYPE_PTRMEMFUNC_P (lhstype))\n-    lhstype = TYPE_PTRMEMFUNC_FN_TYPE (lhstype);\n+  /* Here's what the standard says:\n+     \n+       [over.over]\n+\n+       If the name is a function template, template argument deduction\n+       is done, and if the argument deduction succeeds, the deduced\n+       arguments are used to generate a single template function, which\n+       is added to the set of overloaded functions considered.\n+\n+       Non-member functions and static member functions match targets of\n+       type \"pointer-to-function\" or \"reference-to-function.\"  Nonstatic\n+       member functions match targets of type \"pointer-to-member\n+       function;\" the function type of the pointer to member is used to\n+       select the member function from the set of overloaded member\n+       functions.  If a nonstatic member function is selected, the\n+       reference to the overloaded function name is required to have the\n+       form of a pointer to member as described in 5.3.1.\n+\n+       If more than one function is selected, any template functions in\n+       the set are eliminated if the set also contains a non-template\n+       function, and any given template function is eliminated if the\n+       set contains a second template function that is more specialized\n+       than the first according to the partial ordering rules 14.5.5.2.\n+       After such eliminations, if any, there shall remain exactly one\n+       selected function.  */\n+\n+  int is_ptrmem = 0;\n+  int is_reference = 0;\n+  /* We store the matches in a TREE_LIST rooted here.  The functions\n+     are the TREE_PURPOSE, not the TREE_VALUE, in this list, for easy\n+     interoperability with most_specialized_instantiation.  */\n+  tree matches = NULL_TREE;\n+\n+  /* If the TARGET_TYPE is a pointer-to-a-method, we convert it to\n+     proper pointer-to-member type here.  */\n+  if (TREE_CODE (target_type) == POINTER_TYPE\n+      && TREE_CODE (TREE_TYPE (target_type)) == METHOD_TYPE)\n+    target_type = build_ptrmemfunc_type (target_type);\n+\n+  /* Check that the TARGET_TYPE is reasonable.  */\n+  if (TYPE_PTRFN_P (target_type))\n+    /* This is OK.  */\n+    ;\n+  else if (TYPE_PTRMEMFUNC_P (target_type))\n+    /* This is OK, too.  */\n+    is_ptrmem = 1;\n+  else if (TREE_CODE (target_type) == FUNCTION_TYPE)\n+    {\n+      /* This is OK, too.  This comes from a conversion to reference\n+\t type.  */\n+      target_type = build_reference_type (target_type);\n+      is_reference = 1;\n+    }\n+  else \n+    {\n+      if (complain)\n+\tcp_error(\"cannot resolve overloaded function `%D' based on conversion to type `%T'\", \n+\t\t DECL_NAME (OVL_FUNCTION (overload)), target_type);\n+      return error_mark_node;\n+    }\n+  \n+  /* If we can find a non-template function that matches, we can just\n+     use it.  There's no point in generating template instantiations\n+     if we're just going to throw them out anyhow.  But, of course, we\n+     can only do this when we don't *need* a template function.  */\n+  if (!template_only)\n+    {\n+      tree fns;\n+\n+      for (fns = overload; fns; fns = OVL_CHAIN (fns))\n+\t{\n+\t  tree fn = OVL_FUNCTION (fns);\n+\t  tree fntype;\n \n-  if (TREE_CODE (lhstype) == POINTER_TYPE)\n+\t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n+\t    /* We're not looking for templates just yet.  */\n+\t    continue;\n+\n+\t  if ((TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n+\t      != is_ptrmem)\n+\t    /* We're looking for a non-static member, and this isn't\n+\t       one, or vice versa.  */\n+\t    continue;\n+\t\n+\t  /* See if there's a match.  */\n+\t  fntype = TREE_TYPE (fn);\n+\t  if (is_ptrmem)\n+\t    fntype = build_ptrmemfunc_type (build_pointer_type (fntype));\n+\t  else if (!is_reference)\n+\t    fntype = build_pointer_type (fntype);\n+\n+\t  if (can_convert_arg (target_type, fntype, fn))\n+\t    matches = scratch_tree_cons (fn, NULL_TREE, matches);\n+\t}\n+    }\n+\n+  /* Now, if we've already got a match (or matches), there's no need\n+     to proceed to the template functions.  But, if we don't have a\n+     match we need to look at them, too.  */\n+  if (!matches) \n     {\n-      if (TREE_CODE (TREE_TYPE (lhstype)) == FUNCTION_TYPE\n-\t  || TREE_CODE (TREE_TYPE (lhstype)) == METHOD_TYPE)\n-\tlhstype = TREE_TYPE (lhstype);\n+      tree target_fn_type;\n+      tree target_arg_types;\n+      tree fns;\n+\n+      if (is_ptrmem)\n+\t{\n+\t  target_fn_type\n+\t    = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (target_type));\n+\t  target_arg_types = TREE_CHAIN (TYPE_ARG_TYPES (target_fn_type));\n+\t}\n       else\n \t{\n-\t  if (complain)\n-\t    error (\"invalid type combination for overload\");\n-\t  return error_mark_node;\n+\t  target_fn_type = TREE_TYPE (target_type);\n+\t  target_arg_types = TYPE_ARG_TYPES (target_fn_type);\n+\t}\n+\n+      for (fns = overload; fns; fns = OVL_CHAIN (fns))\n+\t{\n+\t  tree fn = OVL_FUNCTION (fns);\n+\t  tree fn_arg_types;\n+\t  tree instantiation;\n+\t  tree instantiation_type;\n+\t  tree targs;\n+\n+\t  if (TREE_CODE (fn) != TEMPLATE_DECL)\n+\t    /* We're only looking for templates.  */\n+\t    continue;\n+\n+\t  if ((TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n+\t      != is_ptrmem)\n+\t    /* We're looking for a non-static member, and this isn't\n+\t       one, or vice versa.  */\n+\t    continue;\n+\n+\t  /* We don't use the `this' argument to do argument deduction\n+\t     since that would prevent us from converting a base class\n+\t     pointer-to-member to a derived class pointer-to-member.  */\n+\t  fn_arg_types = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+\t  if (is_ptrmem)\n+\t    fn_arg_types = TREE_CHAIN (fn_arg_types);\n+\n+\t  /* Try to do argument deduction.  */\n+\t  targs = make_scratch_vec (DECL_NTPARMS (fn));\n+\t  if (type_unification (DECL_INNERMOST_TEMPLATE_PARMS (fn),\n+\t\t\t\ttargs,\n+\t\t\t\tfn_arg_types,\n+\t\t\t\ttarget_arg_types,\n+\t\t\t\texplicit_targs,\n+\t\t\t\tDEDUCE_EXACT,\n+\t\t\t\t/*allow_incomplete=*/1) != 0)\n+\t    /* Argument deduction failed.  */\n+\t    continue;\n+\n+\t  /* Instantiate the template.  */\n+\t  instantiation = instantiate_template (fn, targs);\n+\t  if (instantiation == error_mark_node)\n+\t    /* Instantiation failed.  */\n+\t    continue;\n+\n+\t  /* See if there's a match.  */\n+\t  instantiation_type = TREE_TYPE (instantiation);\n+\t  if (is_ptrmem)\n+\t    instantiation_type = \n+\t      build_ptrmemfunc_type (build_pointer_type (instantiation_type));\n+\t  else if (!is_reference)\n+\t    instantiation_type = build_pointer_type (instantiation_type);\n+\t  if (can_convert_arg (target_type, instantiation_type, instantiation))\n+\t    matches = scratch_tree_cons (instantiation, fn, matches);\n+\t}\n+\n+      /* Now, remove all but the most specialized of the matches.  */\n+      if (matches)\n+\t{\n+\t  tree match = most_specialized_instantiation (matches, \n+\t\t\t\t\t\t       explicit_targs);\n+\n+\t  if (match != error_mark_node)\n+\t    matches = scratch_tree_cons (match, NULL_TREE, NULL_TREE);\n+\t}\n+    }\n+\n+  /* Now we should have exactly one function in MATCHES.  */\n+  if (matches == NULL_TREE)\n+    {\n+      /* There were *no* matches.  */\n+      if (complain)\n+\t{\n+ \t  cp_error (\"cannot convert overloaded function `%D' to type `%#T'\", \n+\t\t    DECL_NAME (OVL_FUNCTION (overload)),\n+\t\t    target_type);\n+\t  cp_error (\"because no suitable overload exists\");\n+\t}\n+      return error_mark_node;\n+    }\n+  else if (TREE_CHAIN (matches))\n+    {\n+      /* There were too many matches.  */\n+\n+      if (complain)\n+\t{\n+\t  tree match;\n+\n+ \t  cp_error (\"converting overloaded function `%D' to type `%#T' is ambiguous\", \n+\t\t    DECL_NAME (OVL_FUNCTION (overload)),\n+\t\t    target_type);\n+\n+\t  /* Since print_candidates expects the functions in the\n+\t     TREE_VALUE slot, we flip them here.  */\n+\t  for (match = matches; match; match = TREE_CHAIN (match))\n+\t    TREE_VALUE (match) = TREE_PURPOSE (match);\n+\n+\t  print_candidates (matches);\n \t}\n+      \n+      return error_mark_node;\n     }\n-  return lhstype;\n+\n+  /* Good, exactly one match.  */\n+  return TREE_PURPOSE (matches);\n }\n \n /* This function will instantiate the type of the expression given in\n@@ -5009,9 +5227,6 @@ instantiate_type (lhstype, rhs, complain)\n      tree lhstype, rhs;\n      int complain;\n {\n-  tree explicit_targs = NULL_TREE;\n-  int template_only = 0;\n-\n   if (TREE_CODE (lhstype) == UNKNOWN_TYPE)\n     {\n       if (complain)\n@@ -5109,141 +5324,20 @@ instantiate_type (lhstype, rhs, complain)\n       /* Fall through.  */\n \n     case TEMPLATE_ID_EXPR:\n-      {\n-\texplicit_targs = TREE_OPERAND (rhs, 1);\n-\ttemplate_only = 1;\n-\trhs = TREE_OPERAND (rhs, 0);\n-      }\n-      /* fall through */\n-      my_friendly_assert (TREE_CODE (rhs) == OVERLOAD, 980401);\n+      return \n+\tresolve_address_of_overloaded_function (lhstype,\n+\t\t\t\t\t\tTREE_OPERAND (rhs, 0),\n+\t\t\t\t\t\tcomplain,\n+\t\t\t\t\t\t/*template_only=*/1,\n+\t\t\t\t\t\tTREE_OPERAND (rhs, 1));\n \n     case OVERLOAD:\n-      {\n-\ttree elem, elems;\n-\n-\t/* Check that the LHSTYPE and the RHS are reasonable.  */\n-\tlhstype = validate_lhs (lhstype, complain);\n-\tif (lhstype == error_mark_node)\n-\t  return lhstype;\n-\n-\tif (TREE_CODE (lhstype) != FUNCTION_TYPE\n-\t    && TREE_CODE (lhstype) != METHOD_TYPE)\n-\t  {\n-\t    if (complain)\n-\t      cp_error(\"cannot resolve overloaded function `%D' \" \n-\t\t       \"based on non-function type `%T'\", \n-\t\t       DECL_NAME (OVL_FUNCTION (rhs)), lhstype);\n-\t    return error_mark_node;\n-\t  }\n-\t\n-\t/* Look for an exact match, by searching through the\n-\t   overloaded functions.  */\n-\tif (template_only)\n-\t  /* If we're processing a template-id, only a template\n-\t     function can match, so we don't look through the\n-\t     overloaded functions.  */\n-\t  ;\n-\telse for (elems = rhs; elems; elems = OVL_CHAIN (elems))\n-\t  {\n-\t    elem = OVL_FUNCTION (elems);\n-\t    if (TREE_CODE (elem) == FUNCTION_DECL\n-\t\t&& same_type_p (lhstype, TREE_TYPE (elem)))\n-\t      {\n-\t\tmark_used (elem);\n-\t\treturn elem;\n-\t      }\n-\t  }\n-\n-\t/* No overloaded function was an exact match.  See if we can\n-\t   instantiate some template to match.  */\n-\t{\n-\t  tree save_elem = 0;\n-\t  elems = rhs;\n-\t  if (TREE_CODE (elems) == TREE_LIST)\n-\t    elems = TREE_VALUE (rhs);\n-\t  for (; elems; elems = OVL_NEXT (elems))\n-\t    if (TREE_CODE (elem = OVL_CURRENT (elems)) == TEMPLATE_DECL)\n-\t      {\n-\t\tint n = DECL_NTPARMS (elem);\n-\t\ttree t = make_scratch_vec (n);\n-\t\tint i;\n-\t\ti = type_unification\n-\t\t  (DECL_INNERMOST_TEMPLATE_PARMS (elem), t,\n-\t\t   TYPE_ARG_TYPES (TREE_TYPE (elem)),\n-\t\t   TYPE_ARG_TYPES (lhstype), explicit_targs, DEDUCE_EXACT, 1);\n-\t\tif (i == 0)\n-\t\t  {\n-\t\t    if (save_elem)\n-\t\t      {\n-\t\t\tcp_error (\"ambiguous template instantiation converting to `%#T'\", lhstype);\n-\t\t\treturn error_mark_node;\n-\t\t      }\n-\t\t    save_elem = instantiate_template (elem, t);\n-\t\t    /* Check the return type.  */\n-\t\t    if (!same_type_p (TREE_TYPE (lhstype),\n-\t\t\t\t      TREE_TYPE (TREE_TYPE (save_elem))))\n-\t\t      save_elem = 0;\n-\t\t  }\n-\t      }\n-\t  if (save_elem)\n-\t    {\n-\t      mark_used (save_elem);\n-\t      return save_elem;\n-\t    }\n-\t}\n-\n-\t/* There's no exact match, and no templates can be\n-\t   instantiated to match.  The last thing we try is to see if\n-\t   some ordinary overloaded function is close enough.  If\n-\t   we're only looking for template functions, we don't do\n-\t   this.  */\n-\tif (!template_only)\n-\t  {\n-\t    for (elems = rhs; elems; elems = OVL_NEXT (elems))\n-\t      {\n-\t\telem = OVL_CURRENT (elems);\n-\t\tif (TREE_CODE (elem) == FUNCTION_DECL\n-\t\t    && comp_target_types (lhstype, TREE_TYPE (elem), 1) > 0)\n-\t\t  break;\n-\t      }\n-\t    if (elems)\n-\t      {\n-\t\ttree save_elem = elem;\n-\t\tfor (elems = OVL_CHAIN (elems); elems; \n-\t\t     elems = OVL_CHAIN (elems))\n-\t\t  {\n-\t\t    elem = OVL_FUNCTION (elems);\n-\t\t    if (TREE_CODE (elem) == FUNCTION_DECL\n-\t\t\t&& comp_target_types (lhstype, TREE_TYPE (elem), 0) >0)\n-\t\t      break;\n-\t\t  }\n-\t\tif (elems)\n-\t\t  {\n-\t\t    if (complain)\n-\t\t      {\n-\t\t\tcp_error \n-\t\t\t  (\"cannot resolve overload to target type `%#T'\",\n-\t\t\t   lhstype);\n-\t\t\tcp_error_at (\"  ambiguity between `%#D'\", save_elem); \n-\t\t\tcp_error_at (\"  and `%#D', at least\", elem);\n-\t\t      }\n-\t\t    return error_mark_node;\n-\t\t  }\n-\t\tmark_used (save_elem);\n-\t\treturn save_elem;\n-\t      }\n-\t  }\n-\n-\t/* We failed to find a match.  */\n-\tif (complain)\n-\t  {\n-\t    cp_error (\"cannot resolve overload to target type `%#T'\", lhstype);\n-\t    cp_error \n-\t      (\"  because no suitable overload of function `%D' exists\",\n-\t       DECL_NAME (OVL_FUNCTION (rhs)));\n-\t  }\n-\treturn error_mark_node;\n-      }\n+      return \n+\tresolve_address_of_overloaded_function (lhstype, \n+\t\t\t\t\t\trhs,\n+\t\t\t\t\t\tcomplain,\n+\t\t\t\t\t\t/*template_only=*/0,\n+\t\t\t\t\t\t/*explicit_targs=*/NULL_TREE);\n \n     case TREE_LIST:\n       {\n@@ -5370,16 +5464,8 @@ instantiate_type (lhstype, rhs, complain)\n       return rhs;\n       \n     case ADDR_EXPR:\n-      if (TYPE_PTRMEMFUNC_P (lhstype))\n-\tlhstype = TYPE_PTRMEMFUNC_FN_TYPE (lhstype);\n-      else if (TREE_CODE (lhstype) != POINTER_TYPE)\n-\t{\n-\t  if (complain)\n-\t    error (\"type for resolving address of overloaded function must be pointer type\");\n-\t  return error_mark_node;\n-\t}\n       {\n-\ttree fn = instantiate_type (TREE_TYPE (lhstype), TREE_OPERAND (rhs, 0), complain);\n+\ttree fn = instantiate_type (lhstype, TREE_OPERAND (rhs, 0), complain);\n \tif (fn == error_mark_node)\n \t  return error_mark_node;\n \tmark_addressable (fn);"}, {"sha": "119efdd9888a9df09fb494c2eefdbd4fbfe0686c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=104bf76a62749f2cd334f68cae1dd3bdd8129c74", "patch": "@@ -3030,6 +3030,8 @@ extern int is_specialization_of                 PROTO((tree, tree));\n extern int comp_template_args                   PROTO((tree, tree));\n extern void maybe_process_partial_specialization PROTO((tree));\n extern void maybe_check_template_type           PROTO((tree));\n+extern tree most_specialized_instantiation      PROTO((tree, tree));\n+extern void print_candidates                    PROTO((tree));\n \n extern int processing_specialization;\n extern int processing_explicit_instantiation;"}, {"sha": "a5a91c162382f278318a11fe29e6fe9dcc5b17dd", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=104bf76a62749f2cd334f68cae1dd3bdd8129c74", "patch": "@@ -414,7 +414,11 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \n   if (TREE_CODE (type) == FUNCTION_TYPE && intype == unknown_type_node)\n     {\n-      expr = instantiate_type (type, expr, 0);\n+      expr = instantiate_type (type, expr, \n+\t\t\t       (flags & LOOKUP_COMPLAIN) != 0);\n+      if (expr == error_mark_node)\n+\treturn error_mark_node;\n+\n       intype = TREE_TYPE (expr);\n     }\n "}, {"sha": "50e44b5879ba8681a5a2c20a97f242468a5052fa", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 50, "deletions": 31, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=104bf76a62749f2cd334f68cae1dd3bdd8129c74", "patch": "@@ -112,7 +112,6 @@ static void push_inline_template_parms_recursive PROTO((tree, int));\n static tree retrieve_specialization PROTO((tree, tree));\n static tree register_specialization PROTO((tree, tree, tree));\n static int unregister_specialization PROTO((tree, tree));\n-static void print_candidates PROTO((tree));\n static tree reduce_template_parm_level PROTO((tree, tree, int));\n static tree build_template_decl PROTO((tree, tree));\n static int mark_template_parm PROTO((tree, void *));\n@@ -883,7 +882,7 @@ unregister_specialization (spec, tmpl)\n \n /* Print the list of candidate FNS in an error message.  */\n \n-static void\n+void\n print_candidates (fns)\n      tree fns;\n {\n@@ -1996,15 +1995,15 @@ process_partial_specialization (decl)\n \t\t  /* We haven't yet initialized TPD2.  Do so now.  */\n \t\t  tpd2.arg_uses_template_parms \n \t\t    =  (int*) alloca (sizeof (int) * nargs);\n-\t\t  /* The number of paramters here is the number in the\n+\t\t  /* The number of parameters here is the number in the\n \t\t     main template, which, as checked in the assertion\n \t\t     above, is NARGS.  */\n \t\t  tpd2.parms = (int*) alloca (sizeof (int) * nargs);\n \t\t  tpd2.level = \n \t\t    TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (maintmpl));\n \t\t}\n \n-\t      /* Mark the template paramters.  But this time, we're\n+\t      /* Mark the template parameters.  But this time, we're\n \t\t looking for the template parameters of the main\n \t\t template, not in the specialization.  */\n \t      tpd2.current_arg = i;\n@@ -2024,7 +2023,7 @@ process_partial_specialization (decl)\n \t\t    if (tpd2.parms[j] != 0\n \t\t\t&& tpd.arg_uses_template_parms [j])\n \t\t      {\n-\t\t\tcp_error (\"type `%T' of template argument `%E' depends on template paramter(s)\", \n+\t\t\tcp_error (\"type `%T' of template argument `%E' depends on template parameter(s)\", \n \t\t\t\t  type,\n \t\t\t\t  arg);\n \t\t\tbreak;\n@@ -2106,7 +2105,7 @@ check_default_tmpl_args (decl, parms, is_primary, is_partial)\n \n   if (current_class_type && TYPE_BEING_DEFINED (current_class_type))\n     /* If we're inside a class definition, there's no need to\n-       examine the paramters to the class itself.  On the one\n+       examine the parameters to the class itself.  On the one\n        hand, they will be checked when the class is defined, and,\n        on the other, default arguments are legal in things like:\n          template <class T = double>\n@@ -8024,35 +8023,30 @@ get_class_bindings (tparms, parms, args)\n   return vec;\n }\n \n-/* Return the most specialized of the list of templates in FNS that can\n-   produce an instantiation matching DECL, given the explicit template\n-   arguments EXPLICIT_ARGS.  */\n+/* In INSTANTIATIONS is a list of <INSTANTIATION, TEMPLATE> pairs.\n+   Pick the most specialized template, and return the corresponding\n+   instantiation, or if there is no corresponding instantiation, the\n+   template itself.  EXPLICIT_ARGS is any template arguments explicity\n+   mentioned in a template-id.  If there is no most specialized\n+   tempalte, error_mark_node is returned.  If there are no templates\n+   at all, NULL_TREE is returned.  */\n \n tree\n-most_specialized (fns, decl, explicit_args)\n-     tree fns, decl, explicit_args;\n+most_specialized_instantiation (instantiations, explicit_args)\n+     tree instantiations;\n+     tree explicit_args;\n {\n-  tree candidates = NULL_TREE;\n-  tree fn, champ, args;\n+  tree fn, champ;\n   int fate;\n \n-  for (fn = fns; fn; fn = TREE_CHAIN (fn))\n-    {\n-      tree candidate = TREE_VALUE (fn);\n-\n-      args = get_bindings (candidate, decl, explicit_args);\n-      if (args)\n-\tcandidates = scratch_tree_cons (NULL_TREE, candidate, \n-\t\t\t\t\tcandidates);\n-    }\n-\n-  if (!candidates)\n+  if (!instantiations)\n     return NULL_TREE;\n \n-  champ = TREE_VALUE (candidates);\n-  for (fn = TREE_CHAIN (candidates); fn; fn = TREE_CHAIN (fn))\n+  champ = instantiations;\n+  for (fn = TREE_CHAIN (instantiations); fn; fn = TREE_CHAIN (fn))\n     {\n-      fate = more_specialized (champ, TREE_VALUE (fn), explicit_args);\n+      fate = more_specialized (TREE_VALUE (champ), \n+\t\t\t       TREE_VALUE (fn), explicit_args);\n       if (fate == 1)\n \t;\n       else\n@@ -8063,18 +8057,43 @@ most_specialized (fns, decl, explicit_args)\n \t      if (! fn)\n \t\treturn error_mark_node;\n \t    }\n-\t  champ = TREE_VALUE (fn);\n+\t  champ = fn;\n \t}\n     }\n \n-  for (fn = candidates; fn && TREE_VALUE (fn) != champ; fn = TREE_CHAIN (fn))\n+  for (fn = instantiations; fn && fn != champ; fn = TREE_CHAIN (fn))\n     {\n-      fate = more_specialized (champ, TREE_VALUE (fn), explicit_args);\n+      fate = more_specialized (TREE_VALUE (champ), \n+\t\t\t       TREE_VALUE (fn), explicit_args);\n       if (fate != 1)\n \treturn error_mark_node;\n     }\n \n-  return champ;\n+  return TREE_PURPOSE (champ) ? TREE_PURPOSE (champ) : TREE_VALUE (champ);\n+}\n+\n+/* Return the most specialized of the list of templates in FNS that can\n+   produce an instantiation matching DECL, given the explicit template\n+   arguments EXPLICIT_ARGS.  */\n+\n+tree\n+most_specialized (fns, decl, explicit_args)\n+     tree fns, decl, explicit_args;\n+{\n+  tree candidates = NULL_TREE;\n+  tree fn, args;\n+\n+  for (fn = fns; fn; fn = TREE_CHAIN (fn))\n+    {\n+      tree candidate = TREE_VALUE (fn);\n+\n+      args = get_bindings (candidate, decl, explicit_args);\n+      if (args)\n+\tcandidates = scratch_tree_cons (NULL_TREE, candidate, \n+\t\t\t\t\tcandidates);\n+    }\n+\n+  return most_specialized_instantiation (candidates, explicit_args);\n }\n \n /* If DECL is a specialization of some template, return the most"}, {"sha": "d2c1483a9b2b0c87857e05a16a171f551ddd76b0", "filename": "gcc/testsuite/g++.old-deja/g++.other/overload8.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload8.C?ref=104bf76a62749f2cd334f68cae1dd3bdd8129c74", "patch": "@@ -0,0 +1,22 @@\n+class a {\n+public:\n+  int f()        { return 0; }\n+  int f() const  { return 1; }\n+};\n+\n+class b : public a {\n+};\n+\n+int main() \n+{\n+  int (b::* ptr1)()       = &b::f; \n+  int (b::* ptr2)() const = &b::f; \n+  \n+  b ao;\n+  \n+  if ((ao.*ptr1)() != 0)\n+    return 1;\n+  if ((ao.*ptr2)() != 1)\n+    return 1;\n+}\n+"}, {"sha": "19dd174a0196f92f773f10b8664b0e4b5091f8ff", "filename": "gcc/testsuite/g++.old-deja/g++.pt/overload10.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload10.C?ref=104bf76a62749f2cd334f68cae1dd3bdd8129c74", "patch": "@@ -0,0 +1,16 @@\n+struct B {\n+  int f(int) { return 1; }\n+};\n+\n+struct D {\n+  template <class T>\n+  int f(T) { return 0; }\n+};\n+\n+int main()\n+{\n+  int (D::*g)(int) = &D::f;\n+  \n+  D d;\n+  return (d.*g)(0);\n+}"}, {"sha": "bd9eeb1791a4445d8af6a9f9f921b7b51d56eb29", "filename": "gcc/testsuite/g++.old-deja/g++.pt/overload9.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104bf76a62749f2cd334f68cae1dd3bdd8129c74/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload9.C?ref=104bf76a62749f2cd334f68cae1dd3bdd8129c74", "patch": "@@ -0,0 +1,21 @@\n+template <class T>\n+int f(T)\n+{\n+  return 1;\n+}\n+\n+\n+template <class T>\n+int f(T*)\n+{\n+  return 0;\n+}\n+\n+\n+int main()\n+{\n+  int (*h)(int*) = &f;\n+  int (&k)(int*) = f;\n+\n+  return (*h)(0) || (*k)(0);\n+}"}]}