{"sha": "9baee6181b4e427e0b5ba417e51424c15858dce7", "node_id": "C_kwDOANBUbNoAKDliYWVlNjE4MWI0ZTQyN2UwYjViYTQxN2U1MTQyNGMxNTg1OGRjZTc", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-21T11:52:56Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-22T11:10:15Z"}, "message": "tree-optimization/106922 - missed FRE/PRE\n\nThe following enhances the store-with-same-value trick in\nvn_reference_lookup_3 by not only looking for\n\n  a = val;\n  *ptr = val;\n  .. = a;\n\nbut also\n\n  *ptr = val;\n  other = x;\n  .. = a;\n\nwhere the earlier store is more than one hop away.  It does this\nby queueing the actual value to compare until after the walk but\nas disadvantage only allows a single such skipped store from a\nconstant value.\n\nUnfortunately we cannot handle defs from non-constants this way\nsince we're prone to pick up values from the past loop iteration\nthis way and we have no good way to identify values that are\ninvariant in the currently iterated cycle.  That's why we keep\nthe single-hop lookup for those cases.  gcc.dg/tree-ssa/pr87126.c\nwould be a testcase that's un-XFAILed when we'd handle those\nas well.\n\n\tPR tree-optimization/106922\n\t* tree-ssa-sccvn.cc (vn_walk_cb_data::same_val): New member.\n\t(vn_walk_cb_data::finish): Perform delayed verification of\n\ta skipped may-alias.\n\t(vn_reference_lookup_pieces): Likewise.\n\t(vn_reference_lookup): Likewise.\n\t(vn_reference_lookup_3): When skipping stores of the same\n\tvalue also handle constant stores that are more than a\n\tsingle VDEF away by delaying the verification.\n\n\t* gcc.dg/tree-ssa/ssa-fre-100.c: New testcase.\n\t* g++.dg/tree-ssa/pr106922.C: Adjust.", "tree": {"sha": "182ea662a6fff98f9b8cf60ef8479fe4cd43eefb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/182ea662a6fff98f9b8cf60ef8479fe4cd43eefb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9baee6181b4e427e0b5ba417e51424c15858dce7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9baee6181b4e427e0b5ba417e51424c15858dce7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9baee6181b4e427e0b5ba417e51424c15858dce7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9baee6181b4e427e0b5ba417e51424c15858dce7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66d20d881647e7dd177355a851d7839394ab8341", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66d20d881647e7dd177355a851d7839394ab8341", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66d20d881647e7dd177355a851d7839394ab8341"}], "stats": {"total": 125, "additions": 93, "deletions": 32}, "files": [{"sha": "14fa061de20d6f356bf1d6b22150adb10656c942", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr106922.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baee6181b4e427e0b5ba417e51424c15858dce7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr106922.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baee6181b4e427e0b5ba417e51424c15858dce7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr106922.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr106922.C?ref=9baee6181b4e427e0b5ba417e51424c15858dce7", "patch": "@@ -87,5 +87,4 @@ void testfunctionfoo() {\n   }\n }\n \n-// { dg-final { scan-tree-dump-times \"Found fully redundant value\" 4 \"pre\" { xfail { ! lp64 } } } }\n-// { dg-final { scan-tree-dump-not \"m_initialized\" \"cddce3\" { xfail { ! lp64 } } } }\n+// { dg-final { scan-tree-dump-not \"m_initialized\" \"dce3\" } }"}, {"sha": "ead76548f3df38b509745011b994864d2a3af7a3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-100.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baee6181b4e427e0b5ba417e51424c15858dce7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-100.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baee6181b4e427e0b5ba417e51424c15858dce7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-100.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-100.c?ref=9baee6181b4e427e0b5ba417e51424c15858dce7", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+\n+float bar, baz;\n+void foo (int *p, int n)\n+{\n+  *p = 0;\n+  do\n+    {\n+      bar = 1.;\n+      /* When iterating we should have optimistically value-numbered\n+\t *p to zero, on the second iteration we have to prove the\n+\t store below does not affect the value of this load though.\n+\t We can compare the stored value against the value from the\n+\t previous iteration instead relying on a non-walking lookup.  */\n+      if (*p)\n+        {\n+          baz = 2.;\n+          *p = 0;\n+        }\n+    }\n+  while (--n);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"baz\" \"fre1\" } } */"}, {"sha": "9c12a8e4f033d1a693279a0f76b1000a9c3905f2", "filename": "gcc/tree-ssa-sccvn.cc", "status": "modified", "additions": 67, "deletions": 30, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baee6181b4e427e0b5ba417e51424c15858dce7/gcc%2Ftree-ssa-sccvn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baee6181b4e427e0b5ba417e51424c15858dce7/gcc%2Ftree-ssa-sccvn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.cc?ref=9baee6181b4e427e0b5ba417e51424c15858dce7", "patch": "@@ -1803,7 +1803,8 @@ struct vn_walk_cb_data\n \t\t   vn_lookup_kind vn_walk_kind_, bool tbaa_p_, tree mask_,\n \t\t   bool redundant_store_removal_p_)\n     : vr (vr_), last_vuse_ptr (last_vuse_ptr_), last_vuse (NULL_TREE),\n-      mask (mask_), masked_result (NULL_TREE), vn_walk_kind (vn_walk_kind_),\n+      mask (mask_), masked_result (NULL_TREE), same_val (NULL_TREE),\n+      vn_walk_kind (vn_walk_kind_),\n       tbaa_p (tbaa_p_), redundant_store_removal_p (redundant_store_removal_p_),\n       saved_operands (vNULL), first_set (-2), first_base_set (-2),\n       known_ranges (NULL)\n@@ -1864,6 +1865,7 @@ struct vn_walk_cb_data\n   tree last_vuse;\n   tree mask;\n   tree masked_result;\n+  tree same_val;\n   vn_lookup_kind vn_walk_kind;\n   bool tbaa_p;\n   bool redundant_store_removal_p;\n@@ -1902,6 +1904,8 @@ vn_walk_cb_data::finish (alias_set_type set, alias_set_type base_set, tree val)\n       masked_result = val;\n       return (void *) -1;\n     }\n+  if (same_val && !operand_equal_p (val, same_val))\n+    return (void *) -1;\n   vec<vn_reference_op_s> &operands\n     = saved_operands.exists () ? saved_operands : vr->operands;\n   return vn_reference_lookup_or_insert_for_pieces (last_vuse, set, base_set,\n@@ -2675,36 +2679,57 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t and return the found value.  */\n       if (is_gimple_reg_type (TREE_TYPE (lhs))\n \t  && types_compatible_p (TREE_TYPE (lhs), vr->type)\n-\t  && (ref->ref || data->orig_ref.ref))\n-\t{\n-\t  tree *saved_last_vuse_ptr = data->last_vuse_ptr;\n-\t  /* Do not update last_vuse_ptr in vn_reference_lookup_2.  */\n-\t  data->last_vuse_ptr = NULL;\n-\t  tree saved_vuse = vr->vuse;\n-\t  hashval_t saved_hashcode = vr->hashcode;\n-\t  void *res = vn_reference_lookup_2 (ref, gimple_vuse (def_stmt), data);\n-\t  /* Need to restore vr->vuse and vr->hashcode.  */\n-\t  vr->vuse = saved_vuse;\n-\t  vr->hashcode = saved_hashcode;\n-\t  data->last_vuse_ptr = saved_last_vuse_ptr;\n-\t  if (res && res != (void *)-1)\n+\t  && (ref->ref || data->orig_ref.ref)\n+\t  && !data->same_val\n+\t  && !data->mask\n+\t  && data->partial_defs.is_empty ()\n+\t  && multiple_p (get_object_alignment\n+\t\t\t   (ref->ref ? ref->ref : data->orig_ref.ref),\n+\t\t\t   ref->size)\n+\t  && multiple_p (get_object_alignment (lhs), ref->size))\n+\t{\n+\t  tree rhs = gimple_assign_rhs1 (def_stmt);\n+\t  /* ???  We may not compare to ahead values which might be from\n+\t     a different loop iteration but only to loop invariants.  Use\n+\t     CONSTANT_CLASS_P (unvalueized!) as conservative approximation.\n+\t     The one-hop lookup below doesn't have this issue since there's\n+\t     a virtual PHI before we ever reach a backedge to cross.  */\n+\t  if (CONSTANT_CLASS_P (rhs))\n \t    {\n-\t      vn_reference_t vnresult = (vn_reference_t) res;\n-\t      tree rhs = gimple_assign_rhs1 (def_stmt);\n-\t      if (TREE_CODE (rhs) == SSA_NAME)\n-\t\trhs = SSA_VAL (rhs);\n-\t      if (vnresult->result\n-\t\t  && operand_equal_p (vnresult->result, rhs, 0)\n-\t\t  /* We have to honor our promise about union type punning\n-\t\t     and also support arbitrary overlaps with\n-\t\t     -fno-strict-aliasing.  So simply resort to alignment to\n-\t\t     rule out overlaps.  Do this check last because it is\n-\t\t     quite expensive compared to the hash-lookup above.  */\n-\t\t  && multiple_p (get_object_alignment\n-\t\t\t\t   (ref->ref ? ref->ref : data->orig_ref.ref),\n-\t\t\t\t ref->size)\n-\t\t  && multiple_p (get_object_alignment (lhs), ref->size))\n-\t\treturn res;\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"Skipping possible redundant definition \");\n+\t\t  print_gimple_stmt (dump_file, def_stmt, 0);\n+\t\t}\n+\t      /* Delay the actual compare of the values to the end of the walk\n+\t\t but do not update last_vuse from here.  */\n+\t      data->last_vuse_ptr = NULL;\n+\t      data->same_val = rhs;\n+\t      return NULL;\n+\t    }\n+\t  else\n+\t    {\n+\t      tree *saved_last_vuse_ptr = data->last_vuse_ptr;\n+\t      /* Do not update last_vuse_ptr in vn_reference_lookup_2.  */\n+\t      data->last_vuse_ptr = NULL;\n+\t      tree saved_vuse = vr->vuse;\n+\t      hashval_t saved_hashcode = vr->hashcode;\n+\t      void *res = vn_reference_lookup_2 (ref, gimple_vuse (def_stmt),\n+\t\t\t\t\t\t data);\n+\t      /* Need to restore vr->vuse and vr->hashcode.  */\n+\t      vr->vuse = saved_vuse;\n+\t      vr->hashcode = saved_hashcode;\n+\t      data->last_vuse_ptr = saved_last_vuse_ptr;\n+\t      if (res && res != (void *)-1)\n+\t\t{\n+\t\t  vn_reference_t vnresult = (vn_reference_t) res;\n+\t\t  if (TREE_CODE (rhs) == SSA_NAME)\n+\t\t    rhs = SSA_VAL (rhs);\n+\t\t  if (vnresult->result\n+\t\t      && operand_equal_p (vnresult->result, rhs, 0))\n+\t\t    return res;\n+\t\t}\n \t    }\n \t}\n     }\n@@ -3798,6 +3823,14 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set,\n       if (ops_for_ref != shared_lookup_references)\n \tops_for_ref.release ();\n       gcc_checking_assert (vr1.operands == shared_lookup_references);\n+      if (*vnresult\n+\t  && data.same_val\n+\t  && (!(*vnresult)->result\n+\t      || !operand_equal_p ((*vnresult)->result, data.same_val)))\n+\t{\n+\t  *vnresult = NULL;\n+\t  return NULL_TREE;\n+\t}\n     }\n \n   if (*vnresult)\n@@ -3913,6 +3946,10 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n       if (wvnresult)\n \t{\n \t  gcc_assert (mask == NULL_TREE);\n+\t  if (data.same_val\n+\t      && (!wvnresult->result\n+\t\t  || !operand_equal_p (wvnresult->result, data.same_val)))\n+\t    return NULL_TREE;\n \t  if (vnresult)\n \t    *vnresult = wvnresult;\n \t  return wvnresult->result;"}]}