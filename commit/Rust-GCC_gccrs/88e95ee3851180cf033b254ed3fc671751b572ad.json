{"sha": "88e95ee3851180cf033b254ed3fc671751b572ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhlOTVlZTM4NTExODBjZjAzM2IyNTRlZDNmYzY3MTc1MWI1NzJhZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-02-10T00:34:46Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-02-10T00:34:46Z"}, "message": "re PR c++/19787 (Internal compiler error with ambiguous conversion functions)\n\n\tPR c++/19787\n\t* call.c (initialize_reference): Robustify.\n\n\tPR ++/19732\n\t* decl.c (grokdeclarator): Check for invalid use of destructor\n\tnames.\n\n\tPR c++/19762\n\t* parser.c (cp_parser_unqualified_id): Avoid creating destructor\n\tnames with invalid types.\n\n\tPR c++/19826\n\t* parser.c (cp_parser_direct_declarator): Allow type-dependent\n\texpressions as array bounds.\n\n\tPR c++/19739\n\t* parser.c (cp_parser_attributes_list): Allow empty lists.\n\n\tPR c++/19787\n\t* g++.dg/conversion/ambig1.C: New test.\n\n\tPR c++/19739\n\t* g++.dg/ext/attrib19.C: New test.\n\n\tPR c++/19732\n\t* g++.dg/parse/dtor5.C: New test.\n\n\tPR c++/19762\n\t* g++.dg/template/dtor3.C: New test.\n\n\tPR c++/19826\n\t* g++.dg/template/static11.C: New test.\n\t* g++.dg/template/crash2.C: Remove dg-error marker.\n\nFrom-SVN: r94788", "tree": {"sha": "db8f6d8142bd2c42ccac2bf7325075e8df87ea99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db8f6d8142bd2c42ccac2bf7325075e8df87ea99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88e95ee3851180cf033b254ed3fc671751b572ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e95ee3851180cf033b254ed3fc671751b572ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88e95ee3851180cf033b254ed3fc671751b572ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e95ee3851180cf033b254ed3fc671751b572ad/comments", "author": null, "committer": null, "parents": [{"sha": "ca4c3169913c944780c4c0945c626eb9d47f12ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca4c3169913c944780c4c0945c626eb9d47f12ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca4c3169913c944780c4c0945c626eb9d47f12ad"}], "stats": {"total": 368, "additions": 243, "deletions": 125}, "files": [{"sha": "01d7f75dbd810f76f9dd036c24cad7df4c352d71", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=88e95ee3851180cf033b254ed3fc671751b572ad", "patch": "@@ -1,3 +1,23 @@\n+2005-02-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/19787\n+\t* call.c (initialize_reference): Robustify.\n+\n+\tPR ++/19732\n+\t* decl.c (grokdeclarator): Check for invalid use of destructor\n+\tnames.\n+\n+\tPR c++/19762\n+\t* parser.c (cp_parser_unqualified_id): Avoid creating destructor\n+\tnames with invalid types.\n+\n+\tPR c++/19826\n+\t* parser.c (cp_parser_direct_declarator): Allow type-dependent\n+\texpressions as array bounds.\n+\n+\tPR c++/19739\n+\t* parser.c (cp_parser_attributes_list): Allow empty lists.\n+\n 2005-02-08  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/19733"}, {"sha": "5d931c8b6e30026f64f7c60829f3c7c362ef0750", "filename": "gcc/cp/call.c", "status": "modified", "additions": 70, "deletions": 65, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=88e95ee3851180cf033b254ed3fc671751b572ad", "patch": "@@ -6534,81 +6534,86 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \t\t\t\t/*inner=*/-1,\n \t\t\t\t/*issue_conversion_warnings=*/true,\n \t\t\t\t/*c_cast_p=*/false);\n-      if (!real_lvalue_p (expr))\n+      if (error_operand_p (expr))\n+\texpr = error_mark_node;\n+      else\n \t{\n-\t  tree init;\n-\t  tree type;\n-\n-\t  /* Create the temporary variable.  */\n-\t  type = TREE_TYPE (expr);\n-\t  var = make_temporary_var_for_ref_to_temp (decl, type);\n-\t  layout_decl (var, 0);\n-\t  /* If the rvalue is the result of a function call it will be\n-\t     a TARGET_EXPR.  If it is some other construct (such as a\n-\t     member access expression where the underlying object is\n-\t     itself the result of a function call), turn it into a\n-\t     TARGET_EXPR here.  It is important that EXPR be a\n-\t     TARGET_EXPR below since otherwise the INIT_EXPR will\n-\t     attempt to make a bitwise copy of EXPR to initialize\n-\t     VAR.  */\n-\t  if (TREE_CODE (expr) != TARGET_EXPR)\n-\t    expr = get_target_expr (expr);\n-\t  /* Create the INIT_EXPR that will initialize the temporary\n-\t     variable.  */\n-\t  init = build2 (INIT_EXPR, type, var, expr);\n-\t  if (at_function_scope_p ())\n+\t  if (!real_lvalue_p (expr))\n \t    {\n-\t      add_decl_expr (var);\n-\t      *cleanup = cxx_maybe_build_cleanup (var);\n-\n-\t      /* We must be careful to destroy the temporary only\n-\t\t after its initialization has taken place.  If the\n-\t\t initialization throws an exception, then the\n-\t\t destructor should not be run.  We cannot simply\n-\t\t transform INIT into something like:\n-\t     \n-\t\t     (INIT, ({ CLEANUP_STMT; }))\n-\n-\t\t because emit_local_var always treats the\n-\t\t initializer as a full-expression.  Thus, the\n-\t\t destructor would run too early; it would run at the\n-\t\t end of initializing the reference variable, rather\n-\t\t than at the end of the block enclosing the\n-\t\t reference variable.\n-\n-\t\t The solution is to pass back a cleanup expression\n-\t\t which the caller is responsible for attaching to\n-\t\t the statement tree.  */\n+\t      tree init;\n+\t      tree type;\n+\n+\t      /* Create the temporary variable.  */\n+\t      type = TREE_TYPE (expr);\n+\t      var = make_temporary_var_for_ref_to_temp (decl, type);\n+\t      layout_decl (var, 0);\n+\t      /* If the rvalue is the result of a function call it will be\n+\t\t a TARGET_EXPR.  If it is some other construct (such as a\n+\t\t member access expression where the underlying object is\n+\t\t itself the result of a function call), turn it into a\n+\t\t TARGET_EXPR here.  It is important that EXPR be a\n+\t\t TARGET_EXPR below since otherwise the INIT_EXPR will\n+\t\t attempt to make a bitwise copy of EXPR to initialize\n+\t\t VAR.  */\n+\t      if (TREE_CODE (expr) != TARGET_EXPR)\n+\t\texpr = get_target_expr (expr);\n+\t      /* Create the INIT_EXPR that will initialize the temporary\n+\t\t variable.  */\n+\t      init = build2 (INIT_EXPR, type, var, expr);\n+\t      if (at_function_scope_p ())\n+\t\t{\n+\t\t  add_decl_expr (var);\n+\t\t  *cleanup = cxx_maybe_build_cleanup (var);\n+\n+\t\t  /* We must be careful to destroy the temporary only\n+\t\t     after its initialization has taken place.  If the\n+\t\t     initialization throws an exception, then the\n+\t\t     destructor should not be run.  We cannot simply\n+\t\t     transform INIT into something like:\n+\n+\t\t\t (INIT, ({ CLEANUP_STMT; }))\n+\n+\t\t     because emit_local_var always treats the\n+\t\t     initializer as a full-expression.  Thus, the\n+\t\t     destructor would run too early; it would run at the\n+\t\t     end of initializing the reference variable, rather\n+\t\t     than at the end of the block enclosing the\n+\t\t     reference variable.\n+\n+\t\t     The solution is to pass back a cleanup expression\n+\t\t     which the caller is responsible for attaching to\n+\t\t     the statement tree.  */\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rest_of_decl_compilation (var, /*toplev=*/1, at_eof);\n+\t\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n+\t\t    static_aggregates = tree_cons (NULL_TREE, var,\n+\t\t\t\t\t\t   static_aggregates);\n+\t\t}\n+\t      /* Use its address to initialize the reference variable.  */\n+\t      expr = build_address (var);\n+\t      if (base_conv_type)\n+\t\texpr = convert_to_base (expr, \n+\t\t\t\t\tbuild_pointer_type (base_conv_type),\n+\t\t\t\t\t/*check_access=*/true,\n+\t\t\t\t\t/*nonnull=*/true);\n+\t      expr = build2 (COMPOUND_EXPR, TREE_TYPE (expr), init, expr);\n \t    }\n \t  else\n-\t    {\n-\t      rest_of_decl_compilation (var, /*toplev=*/1, at_eof);\n-\t      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-\t\tstatic_aggregates = tree_cons (NULL_TREE, var,\n-\t\t\t\t\t       static_aggregates);\n-\t    }\n-\t  /* Use its address to initialize the reference variable.  */\n-\t  expr = build_address (var);\n+\t    /* Take the address of EXPR.  */\n+\t    expr = build_unary_op (ADDR_EXPR, expr, 0);\n+\t  /* If a BASE_CONV was required, perform it now.  */\n \t  if (base_conv_type)\n-\t    expr = convert_to_base (expr, \n-\t\t\t\t    build_pointer_type (base_conv_type),\n-\t\t\t\t    /*check_access=*/true,\n-\t\t\t\t    /*nonnull=*/true);\n-\t  expr = build2 (COMPOUND_EXPR, TREE_TYPE (expr), init, expr);\n+\t    expr = (perform_implicit_conversion \n+\t\t    (build_pointer_type (base_conv_type), expr));\n+\t  expr = build_nop (type, expr);\n \t}\n-      else\n-\t/* Take the address of EXPR.  */\n-\texpr = build_unary_op (ADDR_EXPR, expr, 0);\n-      /* If a BASE_CONV was required, perform it now.  */\n-      if (base_conv_type)\n-\texpr = (perform_implicit_conversion \n-\t\t(build_pointer_type (base_conv_type), expr));\n-      expr = build_nop (type, expr);\n     }\n   else\n     /* Perform the conversion.  */\n     expr = convert_like (conv, expr);\n-  \n+\n   /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);\n "}, {"sha": "05918f553f97fb880afe5c255ef50799a0d27f21", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=88e95ee3851180cf033b254ed3fc671751b572ad", "patch": "@@ -6553,9 +6553,22 @@ grokdeclarator (const cp_declarator *declarator,\n \t      {\n \t      case BIT_NOT_EXPR:\n \t\t{\n-\t\t  tree type = TREE_OPERAND (decl, 0);\n-\t\t  type = constructor_name (type);\n-\t\t  name = IDENTIFIER_POINTER (type);\n+\t\t  tree type;\n+\n+\t\t  if (innermost_code != cdk_function)\n+\t\t    {\n+\t\t      error (\"declaration of %qD as non-function\", decl);\n+\t\t      return error_mark_node;\n+\t\t    }\n+\t\t  else if (!qualifying_scope \n+\t\t\t   && !(current_class_type && at_class_scope_p ()))\n+\t\t    {\n+\t\t      error (\"declaration of %qD as non-member\", decl);\n+\t\t      return error_mark_node;\n+\t\t    }\n+\t\t  \n+\t\t  type = TREE_OPERAND (decl, 0);\n+\t\t  name = IDENTIFIER_POINTER (constructor_name (type));\n \t\t}\n \t\tbreak;\n \n@@ -7803,15 +7816,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t    int publicp = 0;\n \t    tree function_context;\n \n-\t    /* We catch the others as conflicts with the builtin\n-\t       typedefs.  */\n-\t    if (friendp && unqualified_id == ridpointers[(int) RID_SIGNED])\n-\t      {\n-\t\terror (\"function %qD cannot be declared friend\",\n-\t\t       unqualified_id);\n-\t\tfriendp = 0;\n-\t      }\n-\n \t    if (friendp == 0)\n \t      {\n \t\tif (ctype == NULL_TREE)\n@@ -7849,6 +7853,18 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t\t\t\t     TYPE_ARG_TYPES (type));\n \t      }\n \n+\t    /* Check that the name used for a destructor makes sense.  */\n+\t    if (sfk == sfk_destructor\n+\t\t&& !same_type_p (TREE_OPERAND \n+\t\t\t\t (id_declarator->u.id.unqualified_name, 0),\n+\t\t\t\t ctype))\n+\t      {\n+\t\terror (\"declaration of %qD as member of %qT\", \n+\t\t       id_declarator->u.id.unqualified_name,\n+\t\t       ctype);\n+\t\treturn error_mark_node;\n+\t      }\n+\n \t    /* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */\n \t    function_context = (ctype != NULL_TREE) ?\n \t      decl_function_context (TYPE_MAIN_DECL (ctype)) : NULL_TREE;"}, {"sha": "f4e8ea28cc1669f42f3fd5ca301ea2fc8aa92006", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 64, "deletions": 47, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=88e95ee3851180cf033b254ed3fc671751b572ad", "patch": "@@ -3173,6 +3173,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \ttree qualifying_scope;\n \ttree object_scope;\n \ttree scope;\n+\tbool done;\n \n \t/* Consume the `~' token.  */\n \tcp_lexer_consume_token (parser->lexer);\n@@ -3229,6 +3230,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \n \t/* If there was an explicit qualification (S::~T), first look\n \t   in the scope given by the qualification (i.e., S).  */\n+\tdone = false;\n \tif (scope)\n \t  {\n \t    cp_parser_parse_tentatively (parser);\n@@ -3240,10 +3242,10 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t\t\t      /*class_head_p=*/false,\n \t\t\t\t\t      declarator_p);\n \t    if (cp_parser_parse_definitely (parser))\n-\t      return build_nt (BIT_NOT_EXPR, TREE_TYPE (type_decl));\n+\t      done = true;\n \t  }\n \t/* In \"N::S::~S\", look in \"N\" as well.  */\n-\tif (scope && qualifying_scope)\n+\tif (!done && scope && qualifying_scope)\n \t  {\n \t    cp_parser_parse_tentatively (parser);\n \t    parser->scope = qualifying_scope;\n@@ -3258,10 +3260,10 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t\t      /*class_head_p=*/false,\n \t\t\t\t      declarator_p);\n \t    if (cp_parser_parse_definitely (parser))\n-\t      return build_nt (BIT_NOT_EXPR, TREE_TYPE (type_decl));\n+\t      done = true;\n \t  }\n \t/* In \"p->S::~T\", look in the scope given by \"*p\" as well.  */\n-\telse if (object_scope)\n+\telse if (!done && object_scope)\n \t  {\n \t    cp_parser_parse_tentatively (parser);\n \t    parser->scope = object_scope;\n@@ -3276,20 +3278,23 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t\t      /*class_head_p=*/false,\n \t\t\t\t      declarator_p);\n \t    if (cp_parser_parse_definitely (parser))\n-\t      return build_nt (BIT_NOT_EXPR, TREE_TYPE (type_decl));\n+\t      done = true;\n \t  }\n \t/* Look in the surrounding context.  */\n-\tparser->scope = NULL_TREE;\n-\tparser->object_scope = NULL_TREE;\n-\tparser->qualifying_scope = NULL_TREE;\n-\ttype_decl\n-\t  = cp_parser_class_name (parser,\n-\t\t\t\t  /*typename_keyword_p=*/false,\n-\t\t\t\t  /*template_keyword_p=*/false,\n-\t\t\t\t  none_type,\n-\t\t\t\t  /*check_dependency=*/false,\n-\t\t\t\t  /*class_head_p=*/false,\n-\t\t\t\t  declarator_p);\n+\tif (!done)\n+\t  {\n+\t    parser->scope = NULL_TREE;\n+\t    parser->object_scope = NULL_TREE;\n+\t    parser->qualifying_scope = NULL_TREE;\n+\t    type_decl\n+\t      = cp_parser_class_name (parser,\n+\t\t\t\t      /*typename_keyword_p=*/false,\n+\t\t\t\t      /*template_keyword_p=*/false,\n+\t\t\t\t      none_type,\n+\t\t\t\t      /*check_dependency=*/false,\n+\t\t\t\t      /*class_head_p=*/false,\n+\t\t\t\t      declarator_p);\n+\t  }\n \t/* If an error occurred, assume that the name of the\n \t   destructor is the same as the name of the qualifying\n \t   class.  That allows us to keep parsing after running\n@@ -11099,7 +11104,17 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t\t\t\t &non_constant_p);\n \t      if (!non_constant_p)\n \t\tbounds = fold_non_dependent_expr (bounds);\n-\t      else if (!at_function_scope_p ())\n+\t      /* Normally, the array bound must be an integral constant\n+\t\t expression.  However, as an extension, we allow VLAs\n+\t\t in function scopes.  And, we allow type-dependent\n+\t\t expressions in templates; sometimes we don't know for\n+\t\t sure whether or not something is a valid integral\n+\t\t constant expression until instantiation time.  (It\n+\t\t doesn't make sense to check for value-dependency, as\n+\t\t an expression is only value-dependent when it is a\n+\t\t constant expression.)  */  \n+\t      else if (!type_dependent_expression_p (bounds)\n+\t\t       && !at_function_scope_p ())\n \t\t{\n \t\t  error (\"array bound is not an integer constant\");\n \t\t  bounds = error_mark_node;\n@@ -14042,10 +14057,10 @@ cp_parser_attributes_opt (cp_parser* parser)\n      identifier ( identifier , expression-list )\n      identifier ( expression-list )\n \n-   Returns a TREE_LIST.  Each node corresponds to an attribute.  THe\n-   TREE_PURPOSE of each node is the identifier indicating which\n-   attribute is in use.  The TREE_VALUE represents the arguments, if\n-   any.  */\n+   Returns a TREE_LIST, or NULL_TREE on error.  Each node corresponds\n+   to an attribute.  The TREE_PURPOSE of each node is the identifier\n+   indicating which attribute is in use.  The TREE_VALUE represents\n+   the arguments, if any.  */\n \n static tree\n cp_parser_attribute_list (cp_parser* parser)\n@@ -14063,37 +14078,39 @@ cp_parser_attribute_list (cp_parser* parser)\n       /* Look for the identifier.  We also allow keywords here; for\n \t example `__attribute__ ((const))' is legal.  */\n       token = cp_lexer_peek_token (parser->lexer);\n-      if (token->type != CPP_NAME\n-\t  && token->type != CPP_KEYWORD)\n-\treturn error_mark_node;\n-      /* Consume the token.  */\n-      token = cp_lexer_consume_token (parser->lexer);\n+      if (token->type == CPP_NAME\n+\t  || token->type == CPP_KEYWORD)\n+\t{\n+\t  /* Consume the token.  */\n+\t  token = cp_lexer_consume_token (parser->lexer);\n \n-      /* Save away the identifier that indicates which attribute this is.  */\n-      identifier = token->value;\n-      attribute = build_tree_list (identifier, NULL_TREE);\n+\t  /* Save away the identifier that indicates which attribute\n+\t     this is.  */ \n+\t  identifier = token->value;\n+\t  attribute = build_tree_list (identifier, NULL_TREE);\n \n-      /* Peek at the next token.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n-      /* If it's an `(', then parse the attribute arguments.  */\n-      if (token->type == CPP_OPEN_PAREN)\n-\t{\n-\t  tree arguments;\n+\t  /* Peek at the next token.  */\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\t  /* If it's an `(', then parse the attribute arguments.  */\n+\t  if (token->type == CPP_OPEN_PAREN)\n+\t    {\n+\t      tree arguments;\n \n-\t  arguments = (cp_parser_parenthesized_expression_list\n-\t\t       (parser, true, /*cast_p=*/false, \n-\t\t\t/*non_constant_p=*/NULL));\n-\t  /* Save the identifier and arguments away.  */\n-\t  TREE_VALUE (attribute) = arguments;\n-\t}\n+\t      arguments = (cp_parser_parenthesized_expression_list\n+\t\t\t   (parser, true, /*cast_p=*/false, \n+\t\t\t    /*non_constant_p=*/NULL));\n+\t      /* Save the identifier and arguments away.  */\n+\t      TREE_VALUE (attribute) = arguments;\n+\t    }\n \n-      /* Add this attribute to the list.  */\n-      TREE_CHAIN (attribute) = attribute_list;\n-      attribute_list = attribute;\n+\t  /* Add this attribute to the list.  */\n+\t  TREE_CHAIN (attribute) = attribute_list;\n+\t  attribute_list = attribute;\n \n-      /* Now, look for more attributes.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n-      /* If the next token isn't a `,', we're done.  */\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\t}\n+      /* Now, look for more attributes.  If the next token isn't a\n+\t `,', we're done.  */\n       if (token->type != CPP_COMMA)\n \tbreak;\n "}, {"sha": "ace4d02e9b8658daf674a4c8d8e125b8fbc0206b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88e95ee3851180cf033b254ed3fc671751b572ad", "patch": "@@ -1,3 +1,21 @@\n+2005-02-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/19787\n+\t* g++.dg/conversion/ambig1.C: New test.\n+\n+\tPR c++/19739\n+\t* g++.dg/ext/attrib19.C: New test.\n+\n+\tPR c++/19732\n+\t* g++.dg/parse/dtor5.C: New test.\n+\n+\tPR c++/19762\n+\t* g++.dg/template/dtor3.C: New test.\n+\n+\tPR c++/19826\n+\t* g++.dg/template/static11.C: New test.\n+\t* g++.dg/template/crash2.C: Remove dg-error marker.\n+\n 2005-02-09  Janis Johnson  <janis187@us.ibm.com>\n \n \tPR C++/18491"}, {"sha": "42ac4038ec661828f5b0e4e0f07335a845da2000", "filename": "gcc/testsuite/g++.dg/conversion/ambig1.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fambig1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fambig1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fambig1.C?ref=88e95ee3851180cf033b254ed3fc671751b572ad", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/19787\n+\n+struct H {\n+  operator char(); // { dg-error \"\" }\n+  operator short(); // { dg-error \"\" }\n+};\n+\n+int const& ref = H(); // { dg-error \"\" }"}, {"sha": "f1362c3b4844d550149f15bc3630289ff35b528e", "filename": "gcc/testsuite/g++.dg/ext/attrib19.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib19.C?ref=88e95ee3851180cf033b254ed3fc671751b572ad", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/19739\n+\n+void Dummy() __attribute__(( , ));\n+void Dummy() {}\n+\n+int main (int argc, char **argv)\n+{\n+    Dummy();\n+    return 0;\n+}"}, {"sha": "297a0e73714591830564fc49e9ae1b3fe27efd55", "filename": "gcc/testsuite/g++.dg/parse/dtor5.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor5.C?ref=88e95ee3851180cf033b254ed3fc671751b572ad", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/19732\n+\n+struct A;\n+typedef int ~A; // { dg-error \"non-function\" }\n+struct B { \n+  ~A(); // { dg-error \"\" }\n+  typedef int ~A; // { dg-error \"non-function\" }\n+  void f() {\n+    extern ~B(); // { dg-error \"non-member\" }\n+  }\n+};\n+void ~A(); // { dg-error \"non-member\" }"}, {"sha": "a02787a46fa0b8db20a7187677bb27b2c0fbf263", "filename": "gcc/testsuite/g++.dg/template/crash2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash2.C?ref=88e95ee3851180cf033b254ed3fc671751b572ad", "patch": "@@ -5,7 +5,7 @@ class A\n {\n public:\n   static const EnumType size = max; // { dg-error \"\" }\n-  int table[size]; // { dg-error \"\" }\n+  int table[size];\n };\n template <class EnumType>\n const EnumType A<EnumType>::size;"}, {"sha": "7f4099861fb667f6a86682237f115074fb9e205b", "filename": "gcc/testsuite/g++.dg/template/dtor3.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdtor3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdtor3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdtor3.C?ref=88e95ee3851180cf033b254ed3fc671751b572ad", "patch": "@@ -0,0 +1,4 @@\n+// PR c++/19762\n+\n+template<int> struct A { ~A(){} }; // { dg-error \"\" }\n+template A<>::~A(); // { dg-error \"\" }"}, {"sha": "3e489eac5b1acda73e47e95dae86abf7ba1b3300", "filename": "gcc/testsuite/g++.dg/template/static11.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e95ee3851180cf033b254ed3fc671751b572ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fstatic11.C?ref=88e95ee3851180cf033b254ed3fc671751b572ad", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/19826\n+\n+template<typename T> struct A\n+{\n+  static const T i = 1;\n+  char a[i];\n+};\n+"}]}