{"sha": "55cb8c5c9abfe83c342a7b8e8b7dd4bee1791302", "node_id": "C_kwDOANBUbNoAKDU1Y2I4YzVjOWFiZmU4M2MzNDJhN2I4ZThiN2RkNGJlZTE3OTEzMDI", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-11-22T18:03:49Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-11-22T18:04:58Z"}, "message": "Fix wrong array type conversion with different storage orde\n\nWhen two arrays of scalars have a different storage order in Ada, the\nfront-end makes sure that the conversion is performed component-wise\nso that each component can be reversed.  So it's a little bit counter\nproductive that the ldist pass performs the opposite transformation\nand synthesizes a memcpy/memmove in this case.\n\ngcc/\n\t* tree-loop-distribution.cc (loop_distribution::classify_builtin_ldst):\n\tBail out if source and destination do not have the same storage order.\n\ngcc/testsuite/\n\t* gnat.dg/sso18.adb: New test.", "tree": {"sha": "643d1a2b25dd6ece3f251992e73e9f90be3af7bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/643d1a2b25dd6ece3f251992e73e9f90be3af7bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55cb8c5c9abfe83c342a7b8e8b7dd4bee1791302", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55cb8c5c9abfe83c342a7b8e8b7dd4bee1791302", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55cb8c5c9abfe83c342a7b8e8b7dd4bee1791302", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55cb8c5c9abfe83c342a7b8e8b7dd4bee1791302/comments", "author": null, "committer": null, "parents": [{"sha": "dfc1ea414e0cebccfcffc771ebcefa3d24c9754c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfc1ea414e0cebccfcffc771ebcefa3d24c9754c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfc1ea414e0cebccfcffc771ebcefa3d24c9754c"}], "stats": {"total": 28, "additions": 27, "deletions": 1}, "files": [{"sha": "7496e965fd33b47c7c356aab238f53b351eb3c28", "filename": "gcc/testsuite/gnat.dg/sso18.adb", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55cb8c5c9abfe83c342a7b8e8b7dd4bee1791302/gcc%2Ftestsuite%2Fgnat.dg%2Fsso18.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55cb8c5c9abfe83c342a7b8e8b7dd4bee1791302/gcc%2Ftestsuite%2Fgnat.dg%2Fsso18.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsso18.adb?ref=55cb8c5c9abfe83c342a7b8e8b7dd4bee1791302", "patch": "@@ -0,0 +1,21 @@\n+--  { dg-do run }\n+--  { dg-options \"-O2\" }\n+\n+with System;\n+\n+procedure SSO18 is\n+\n+  type Arr is array (1..32) of Short_Integer;\n+  type Rev_Arr is array (1..32) of Short_Integer\n+    with Scalar_Storage_Order => System.High_Order_First;\n+  C : constant Arr := (others => 16);\n+  RA : Rev_Arr;\n+  A  : Arr;\n+\n+begin\n+  RA := Rev_Arr(C);\n+  A := Arr (RA);\n+  if A /= C or else RA(1) /= 16 then\n+     raise Program_Error;\n+  end if;\n+end;"}, {"sha": "15ae24108615cfe4581df517af03c28acbd3812d", "filename": "gcc/tree-loop-distribution.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55cb8c5c9abfe83c342a7b8e8b7dd4bee1791302/gcc%2Ftree-loop-distribution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55cb8c5c9abfe83c342a7b8e8b7dd4bee1791302/gcc%2Ftree-loop-distribution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.cc?ref=55cb8c5c9abfe83c342a7b8e8b7dd4bee1791302", "patch": "@@ -1790,10 +1790,15 @@ loop_distribution::classify_builtin_ldst (loop_p loop, struct graph *rdg,\n   if (res != 2)\n     return;\n \n-  /* They much have the same access size.  */\n+  /* They must have the same access size.  */\n   if (!operand_equal_p (size, src_size, 0))\n     return;\n \n+  /* They must have the same storage order.  */\n+  if (reverse_storage_order_for_component_p (DR_REF (dst_dr))\n+      != reverse_storage_order_for_component_p (DR_REF (src_dr)))\n+    return;\n+\n   /* Load and store in loop nest must access memory in the same way, i.e,\n      their must have the same steps in each loop of the nest.  */\n   if (dst_steps.length () != src_steps.length ())"}]}