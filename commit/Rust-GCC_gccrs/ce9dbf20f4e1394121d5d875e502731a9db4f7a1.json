{"sha": "ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U5ZGJmMjBmNGUxMzk0MTIxZDVkODc1ZTUwMjczMWE5ZGI0ZjdhMQ==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2019-07-24T12:21:38Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2019-07-24T12:21:38Z"}, "message": "[ARC] Fix and refurbish the interrupts.\n\nWhen entering an interrupt, not only the call save registers needs to\nbe place on stack but also the call clobbers one. More over, the\nARC700 return from interrupt instruction needs to be rtie, the same\nlike ARCv2 CPUs. While the ARC6xx family uses j.f [ilinkX]\ninstruction. Additionally, we need to save the state of the ZOL\nmachinery, namely the lp_count, lp_end and lp_start registers. For\narchitectures which are using extension registers (i.e., HS48) we need\nto save/restore them as well.\n\ngcc/\nxxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc-protos.h (arc_output_function_epilogue): Delete\n\tdeclaration.\n\t(arc_compute_frame_size): Millicode is disabled when compiling\n\tISR.\n\t(arc_return_address_register): Likewise.\n\t(arc_compute_function_type): Likewise.\n\t(arc_compute_frame_size): Likewise.\n\t(secondary_reload_info): Likewise.\n\t(arc_get_unalign): Likewise.\n\t(arc_can_use_return_insn): Declare.\n\t* config/arc/arc.c (AUX_LP_START): Define\n\t(AUX_LP_END): Likewise.\n\t(arc_frame_info): Update gmask member to 64-bit datum.\n\t(GMASK_LEN): Update.\n\t(arc_compute_function_type): Make it static, move it forward.\n\t(arc_must_save_register): Update, consider the extra regs.\n\t(arc_compute_millicode_save_restore_regs): Update to use the 64\n\tbit gmask.\n\t(arc_compute_frame_size): Likewise.\n\t(arc_enter_leave_p): Likewise.\n\t(arc_save_callee_saves): Likewise.\n\t(arc_restore_callee_saves): Likewise.\n\t(arc_save_callee_enter): Likewise.\n\t(arc_restore_callee_leave): Likewise.\n\t(arc_save_callee_milli): Likewise.\n\t(arc_restore_callee_milli): Likewise.\n\t(arc_expand_prologue): Add new interrupt handling.\n\t(arc_return_address_register): Make it static, move it forward.\n\t(arc_expand_epilogue): Add new interrupt handling.\n\t(arc_get_unalign): Delete.\n\t(arc_epilogue_uses): Make sure we do not remove the extra\n\tsaved/restored registers when interrupt.\n\t(arc_can_use_return_insn): New function.\n\t(push_reg): Likewise.\n\t(pop_reg): Likewise.\n\t(arc_save_callee_saves): Add ZOL and FPX aux registers saving\n\tprocedures.\n\t(arc_restore_callee_saves): Likewise, but restoring.\n\t* config/arc/arc.md (VUNSPEC_ARC_ARC600_RTIE): Define.\n\t(R33_REG): Likewise.\n\t(R34_REG): Likewise.\n\t(R35_REG): Likewise.\n\t(R36_REG): Likewise.\n\t(R37_REG): Likewise.\n\t(R38_REG): Likewise.\n\t(R39_REG): Likewise.\n\t(R45_REG): Likewise.\n\t(R46_REG): Likewise.\n\t(R47_REG): Likewise.\n\t(R48_REG): Likewise.\n\t(R49_REG): Likewise.\n\t(R50_REG): Likewise.\n\t(R51_REG): Likewise.\n\t(R52_REG): Likewise.\n\t(R53_REG): Likewise.\n\t(R54_REG): Likewise.\n\t(R55_REG): Likewise.\n\t(R56_REG): Likewise.\n\t(R58_REG): Likewise.\n\t(type): Add rtie attribute.\n\t(in_call_delay_slot): Use RETURN_ADDR_REGNUM.\n\t(movsi_insn): Accept moves to lp_count.\n\t(rtie): Update pattern.\n\t(simple_return): Simplify it, don't use this pattern as a return\n\tfrom an interrupt.\n\t(arc600_rtie): New pattern.\n\t(p_return_i): Clean up.\n\t(return): Likewise.\n\t* config/arc/builtins.def (rtie): Only available for non ARC6xx\n\tfamily CPUs.\n\t* config/arc/predicates.md (move_src_operand): Consider lp_count\n\tas a register.\n\ngcc/testsuite\nxxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* gcc.target/arc/arc.exp (check_effective_target_accregs): New\n\tpredicate.\n\t* gcc.target/arc/builtin_special.c: Update test/\n\t* gcc.target/arc/interrupt-1.c: Likewise.\n\t* gcc.target/arc/interrupt-10.c: New test.\n\t* gcc.target/arc/interrupt-11.c: Likewise.\n\t* gcc.target/arc/interrupt-12.c: Likewise.\n\nupdate\n\nFrom-SVN: r273761", "tree": {"sha": "91df072f8c367924e295db7688ad4c3d03b28315", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91df072f8c367924e295db7688ad4c3d03b28315"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4caa6bab76241bc16517bf1d1075c986d0d0b8ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4caa6bab76241bc16517bf1d1075c986d0d0b8ad"}], "stats": {"total": 1068, "additions": 713, "deletions": 355}, "files": [{"sha": "5a94c2fdd6ab28b04bf452c58d7fbb2f8d6365ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "patch": "@@ -1,3 +1,78 @@\n+2019-07-24  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc-protos.h (arc_output_function_epilogue): Delete\n+\tdeclaration.\n+\t(arc_compute_frame_size): Millicode is disabled when compiling\n+\tISR.\n+\t(arc_return_address_register): Likewise.\n+\t(arc_compute_function_type): Likewise.\n+\t(arc_compute_frame_size): Likewise.\n+\t(secondary_reload_info): Likewise.\n+\t(arc_get_unalign): Likewise.\n+\t(arc_can_use_return_insn): Declare.\n+\t* config/arc/arc.c (AUX_LP_START): Define\n+\t(AUX_LP_END): Likewise.\n+\t(arc_frame_info): Update gmask member to 64-bit datum.\n+\t(GMASK_LEN): Update.\n+\t(arc_compute_function_type): Make it static, move it forward.\n+\t(arc_must_save_register): Update, consider the extra regs.\n+\t(arc_compute_millicode_save_restore_regs): Update to use the 64\n+\tbit gmask.\n+\t(arc_compute_frame_size): Likewise.\n+\t(arc_enter_leave_p): Likewise.\n+\t(arc_save_callee_saves): Likewise.\n+\t(arc_restore_callee_saves): Likewise.\n+\t(arc_save_callee_enter): Likewise.\n+\t(arc_restore_callee_leave): Likewise.\n+\t(arc_save_callee_milli): Likewise.\n+\t(arc_restore_callee_milli): Likewise.\n+\t(arc_expand_prologue): Add new interrupt handling.\n+\t(arc_return_address_register): Make it static, move it forward.\n+\t(arc_expand_epilogue): Add new interrupt handling.\n+\t(arc_get_unalign): Delete.\n+\t(arc_epilogue_uses): Make sure we do not remove the extra\n+\tsaved/restored registers when interrupt.\n+\t(arc_can_use_return_insn): New function.\n+\t(push_reg): Likewise.\n+\t(pop_reg): Likewise.\n+\t(arc_save_callee_saves): Add ZOL and FPX aux registers saving\n+\tprocedures.\n+\t(arc_restore_callee_saves): Likewise, but restoring.\n+\t* config/arc/arc.md (VUNSPEC_ARC_ARC600_RTIE): Define.\n+\t(R33_REG): Likewise.\n+\t(R34_REG): Likewise.\n+\t(R35_REG): Likewise.\n+\t(R36_REG): Likewise.\n+\t(R37_REG): Likewise.\n+\t(R38_REG): Likewise.\n+\t(R39_REG): Likewise.\n+\t(R45_REG): Likewise.\n+\t(R46_REG): Likewise.\n+\t(R47_REG): Likewise.\n+\t(R48_REG): Likewise.\n+\t(R49_REG): Likewise.\n+\t(R50_REG): Likewise.\n+\t(R51_REG): Likewise.\n+\t(R52_REG): Likewise.\n+\t(R53_REG): Likewise.\n+\t(R54_REG): Likewise.\n+\t(R55_REG): Likewise.\n+\t(R56_REG): Likewise.\n+\t(R58_REG): Likewise.\n+\t(type): Add rtie attribute.\n+\t(in_call_delay_slot): Use RETURN_ADDR_REGNUM.\n+\t(movsi_insn): Accept moves to lp_count.\n+\t(rtie): Update pattern.\n+\t(simple_return): Simplify it, don't use this pattern as a return\n+\tfrom an interrupt.\n+\t(arc600_rtie): New pattern.\n+\t(p_return_i): Clean up.\n+\t(return): Likewise.\n+\t* config/arc/builtins.def (rtie): Only available for non ARC6xx\n+\tfamily CPUs.\n+\t* config/arc/predicates.md (move_src_operand): Consider lp_count\n+\tas a register.\n+\n 2019-07-24  Andreas Krebbel  <krebbel@linux.ibm.com>\n \n \t* config/s390/predicates.md (addv_const_operand): New predicate."}, {"sha": "1220e77206d774f10d76e0402e8d7cb319d4af02", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "patch": "@@ -25,7 +25,6 @@ extern machine_mode arc_select_cc_mode (enum rtx_code, rtx, rtx);\n extern struct rtx_def *gen_compare_reg (rtx, machine_mode);\n \n /* Declarations for various fns used in the .md file.  */\n-extern void arc_output_function_epilogue (FILE *, HOST_WIDE_INT, int);\n extern const char *output_shift (rtx *);\n extern bool compact_sda_memory_operand (rtx, machine_mode, bool);\n extern bool arc_double_limm_p (rtx);\n@@ -42,8 +41,6 @@ extern void arc_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n extern void arc_split_compare_and_swap (rtx *);\n extern void arc_expand_compare_and_swap (rtx *);\n extern bool compact_memory_operand_p (rtx, machine_mode, bool, bool);\n-extern int arc_return_address_register (unsigned int);\n-extern unsigned int arc_compute_function_type (struct function *);\n extern bool arc_is_uncached_mem_p (rtx);\n extern bool gen_operands_ldd_std (rtx *operands, bool load, bool commute);\n extern bool arc_check_multi (rtx, bool);\n@@ -52,9 +49,9 @@ extern bool arc_check_ior_const (HOST_WIDE_INT );\n extern void arc_split_ior (rtx *);\n extern bool arc_check_mov_const (HOST_WIDE_INT );\n extern bool arc_split_mov_const (rtx *);\n+extern bool arc_can_use_return_insn (void);\n #endif /* RTX_CODE */\n \n-extern unsigned int arc_compute_frame_size (int);\n extern bool arc_ccfsm_branch_deleted_p (void);\n extern void arc_ccfsm_record_branch_deleted (void);\n \n@@ -71,7 +68,6 @@ extern bool arc_is_longcall_p (rtx);\n extern bool arc_is_shortcall_p (rtx);\n extern bool valid_brcc_with_delay_p (rtx *);\n extern bool arc_ccfsm_cond_exec_p (void);\n-struct secondary_reload_info;\n extern rtx disi_highpart (rtx);\n extern int arc_adjust_insn_length (rtx_insn *, int, bool);\n extern int arc_corereg_hazard (rtx, rtx);\n@@ -89,7 +85,6 @@ extern void arc_expand_prologue (void);\n extern void arc_expand_epilogue (int);\n extern void arc_init_expanders (void);\n extern int arc_check_millicode (rtx op, int offset, int load_p);\n-extern int arc_get_unalign (void);\n extern void arc_clear_unalign (void);\n extern void arc_toggle_unalign (void);\n extern void split_addsi (rtx *);"}, {"sha": "3c4d89cdd0811e297fb126f0b9535992b2dd0d83", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 473, "deletions": 268, "changes": 741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "patch": "@@ -206,6 +206,13 @@ static int rgf_banked_register_count;\n    this to be no less than the 1/p  */\n #define MAX_INSNS_SKIPPED 3\n \n+/* ZOL control registers.  */\n+#define AUX_LP_START 0x02\n+#define AUX_LP_END 0x03\n+\n+/* FPX AUX registers.  */\n+#define AUX_DPFP_START 0x301\n+\n /* A nop is needed between a 4 byte insn that sets the condition codes and\n    a branch that uses them (the same isn't true for an 8 byte insn that sets\n    the condition codes).  Set by arc_ccfsm_advance.  Used by\n@@ -298,6 +305,129 @@ static bool arc_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT,\n /* Globally visible information about currently selected cpu.  */\n const arc_cpu_t *arc_selected_cpu;\n \n+/* Traditionally, we push saved registers first in the prologue,\n+   then we allocate the rest of the frame - and reverse in the epilogue.\n+   This has still its merits for ease of debugging, or saving code size\n+   or even execution time if the stack frame is so large that some accesses\n+   can't be encoded anymore with offsets in the instruction code when using\n+   a different scheme.\n+   Also, it would be a good starting point if we got instructions to help\n+   with register save/restore.\n+\n+   However, often stack frames are small, and the pushing / popping has\n+   some costs:\n+   - the stack modification prevents a lot of scheduling.\n+   - frame allocation / deallocation may need extra instructions.\n+   - we need to place a memory barrier after frame allocation to avoid\n+     the delay slot scheduler to reschedule a frame related info and\n+     messing up with dwarf unwinding.  The barrier before deallocation\n+     is for flushing all pending sp operations.\n+\n+   Thus, for small frames, we'd like to use a different scheme:\n+   - The frame is allocated in full with the first prologue instruction,\n+     and deallocated in full with the last epilogue instruction.\n+     Thus, the instructions in-between can be freely scheduled.\n+   - If the function has no outgoing arguments on the stack, we can allocate\n+     one register save slot at the top of the stack.  This register can then\n+     be saved simultaneously with frame allocation, and restored with\n+     frame deallocation.\n+     This register can be picked depending on scheduling considerations,\n+     although same though should go into having some set of registers\n+     to be potentially lingering after a call, and others to be available\n+     immediately - i.e. in the absence of interprocedual optimization, we\n+     can use an ABI-like convention for register allocation to reduce\n+     stalls after function return.  */\n+\n+/* ARCompact stack frames look like:\n+\n+           Before call                     After call\n+  high  +-----------------------+       +-----------------------+\n+  mem   |  reg parm save area   |       | reg parm save area    |\n+        |  only created for     |       | only created for      |\n+        |  variable arg fns     |       | variable arg fns      |\n+    AP  +-----------------------+       +-----------------------+\n+        |  return addr register |       | return addr register  |\n+        |  (if required)        |       | (if required)         |\n+        +-----------------------+       +-----------------------+\n+        |                       |       |                       |\n+        |  reg save area        |       | reg save area         |\n+        |                       |       |                       |\n+        +-----------------------+       +-----------------------+\n+        |  frame pointer        |       | frame pointer         |\n+        |  (if required)        |       | (if required)         |\n+    FP  +-----------------------+       +-----------------------+\n+        |                       |       |                       |\n+        |  local/temp variables |       | local/temp variables  |\n+        |                       |       |                       |\n+        +-----------------------+       +-----------------------+\n+        |                       |       |                       |\n+        |  arguments on stack   |       | arguments on stack    |\n+        |                       |       |                       |\n+    SP  +-----------------------+       +-----------------------+\n+                                        | reg parm save area    |\n+                                        | only created for      |\n+                                        | variable arg fns      |\n+                                    AP  +-----------------------+\n+                                        | return addr register  |\n+                                        | (if required)         |\n+                                        +-----------------------+\n+                                        |                       |\n+                                        | reg save area         |\n+                                        |                       |\n+                                        +-----------------------+\n+                                        | frame pointer         |\n+                                        | (if required)         |\n+                                    FP  +-----------------------+\n+                                        |                       |\n+                                        | local/temp variables  |\n+                                        |                       |\n+                                        +-----------------------+\n+                                        |                       |\n+                                        | arguments on stack    |\n+  low                                   |                       |\n+  mem                               SP  +-----------------------+\n+\n+Notes:\n+1) The \"reg parm save area\" does not exist for non variable argument fns.\n+   The \"reg parm save area\" can be eliminated completely if we created our\n+   own va-arc.h, but that has tradeoffs as well (so it's not done).  */\n+\n+/* Structure to be filled in by arc_compute_frame_size with register\n+   save masks, and offsets for the current function.  */\n+struct GTY (()) arc_frame_info\n+{\n+  unsigned int total_size;\t/* # bytes that the entire frame takes up.  */\n+  unsigned int extra_size;\t/* # bytes of extra stuff.  */\n+  unsigned int pretend_size;\t/* # bytes we push and pretend caller did.  */\n+  unsigned int args_size;\t/* # bytes that outgoing arguments take up.  */\n+  unsigned int reg_size;\t/* # bytes needed to store regs.  */\n+  unsigned int var_size;\t/* # bytes that variables take up.  */\n+  uint64_t gmask;\t\t/* Mask of saved gp registers.  */\n+  bool initialized; /* FALSE if frame size already calculated.  */\n+  short millicode_start_reg;\n+  short millicode_end_reg;\n+  bool save_return_addr;\n+};\n+\n+/* GMASK bit length -1.  */\n+#define GMASK_LEN 63\n+\n+/* Defining data structures for per-function information.  */\n+\n+typedef struct GTY (()) machine_function\n+{\n+  unsigned int fn_type;\n+  struct arc_frame_info frame_info;\n+  /* To keep track of unalignment caused by short insns.  */\n+  int unalign;\n+  struct arc_ccfsm ccfsm_current;\n+  /* Map from uid to ccfsm state during branch shortening.  */\n+  rtx ccfsm_current_insn;\n+  char arc_reorg_started;\n+  char prescan_initialized;\n+} machine_function;\n+\n+\n /* Given a symbol RTX (const (symb <+ const_int>), returns its\n    alignment.  */\n \n@@ -1996,6 +2126,50 @@ arc_handle_fndecl_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n+/* Type of function DECL.\n+\n+   The result is cached.  To reset the cache at the end of a function,\n+   call with DECL = NULL_TREE.  */\n+\n+static unsigned int\n+arc_compute_function_type (struct function *fun)\n+{\n+  tree attr, decl = fun->decl;\n+  unsigned int fn_type = fun->machine->fn_type;\n+\n+  if (fn_type != ARC_FUNCTION_UNKNOWN)\n+    return fn_type;\n+\n+  /* Check if it is a naked function.  */\n+  if (lookup_attribute (\"naked\", DECL_ATTRIBUTES (decl)) != NULL_TREE)\n+    fn_type |= ARC_FUNCTION_NAKED;\n+  else\n+    fn_type |= ARC_FUNCTION_NORMAL;\n+\n+  /* Now see if this is an interrupt handler.  */\n+  attr = lookup_attribute (\"interrupt\", DECL_ATTRIBUTES (decl));\n+  if (attr != NULL_TREE)\n+    {\n+      tree value, args = TREE_VALUE (attr);\n+\n+      gcc_assert (list_length (args) == 1);\n+      value = TREE_VALUE (args);\n+      gcc_assert (TREE_CODE (value) == STRING_CST);\n+\n+      if (!strcmp (TREE_STRING_POINTER (value), \"ilink1\")\n+\t  || !strcmp (TREE_STRING_POINTER (value), \"ilink\"))\n+\tfn_type |= ARC_FUNCTION_ILINK1;\n+      else if (!strcmp (TREE_STRING_POINTER (value), \"ilink2\"))\n+\tfn_type |= ARC_FUNCTION_ILINK2;\n+      else if (!strcmp (TREE_STRING_POINTER (value), \"firq\"))\n+\tfn_type |= ARC_FUNCTION_FIRQ;\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  return fun->machine->fn_type = fn_type;\n+}\n+\n /* Implement `TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS' */\n \n static bool\n@@ -2402,174 +2576,6 @@ frame_stack_add (HOST_WIDE_INT offset)\n   return frame_add (stack_pointer_rtx, offset);\n }\n \n-/* Traditionally, we push saved registers first in the prologue,\n-   then we allocate the rest of the frame - and reverse in the epilogue.\n-   This has still its merits for ease of debugging, or saving code size\n-   or even execution time if the stack frame is so large that some accesses\n-   can't be encoded anymore with offsets in the instruction code when using\n-   a different scheme.\n-   Also, it would be a good starting point if we got instructions to help\n-   with register save/restore.\n-\n-   However, often stack frames are small, and the pushing / popping has\n-   some costs:\n-   - the stack modification prevents a lot of scheduling.\n-   - frame allocation / deallocation needs extra instructions.\n-   - unless we know that we compile ARC700 user code, we need to put\n-     a memory barrier after frame allocation / before deallocation to\n-     prevent interrupts clobbering our data in the frame.\n-     In particular, we don't have any such guarantees for library functions,\n-     which tend to, on the other hand, to have small frames.\n-\n-   Thus, for small frames, we'd like to use a different scheme:\n-   - The frame is allocated in full with the first prologue instruction,\n-     and deallocated in full with the last epilogue instruction.\n-     Thus, the instructions in-betwen can be freely scheduled.\n-   - If the function has no outgoing arguments on the stack, we can allocate\n-     one register save slot at the top of the stack.  This register can then\n-     be saved simultanously with frame allocation, and restored with\n-     frame deallocation.\n-     This register can be picked depending on scheduling considerations,\n-     although same though should go into having some set of registers\n-     to be potentially lingering after a call, and others to be available\n-     immediately - i.e. in the absence of interprocedual optimization, we\n-     can use an ABI-like convention for register allocation to reduce\n-     stalls after function return.  */\n-/* Function prologue/epilogue handlers.  */\n-\n-/* ARCompact stack frames look like:\n-\n-           Before call                     After call\n-  high  +-----------------------+       +-----------------------+\n-  mem   |  reg parm save area   |       | reg parm save area    |\n-        |  only created for     |       | only created for      |\n-        |  variable arg fns     |       | variable arg fns      |\n-    AP  +-----------------------+       +-----------------------+\n-        |  return addr register |       | return addr register  |\n-        |  (if required)        |       | (if required)         |\n-        +-----------------------+       +-----------------------+\n-        |                       |       |                       |\n-        |  reg save area        |       | reg save area         |\n-        |                       |       |                       |\n-        +-----------------------+       +-----------------------+\n-        |  frame pointer        |       | frame pointer         |\n-        |  (if required)        |       | (if required)         |\n-    FP  +-----------------------+       +-----------------------+\n-        |                       |       |                       |\n-        |  local/temp variables |       | local/temp variables  |\n-        |                       |       |                       |\n-        +-----------------------+       +-----------------------+\n-        |                       |       |                       |\n-        |  arguments on stack   |       | arguments on stack    |\n-        |                       |       |                       |\n-    SP  +-----------------------+       +-----------------------+\n-                                        | reg parm save area    |\n-                                        | only created for      |\n-                                        | variable arg fns      |\n-                                    AP  +-----------------------+\n-                                        | return addr register  |\n-                                        | (if required)         |\n-                                        +-----------------------+\n-                                        |                       |\n-                                        | reg save area         |\n-                                        |                       |\n-                                        +-----------------------+\n-                                        | frame pointer         |\n-                                        | (if required)         |\n-                                    FP  +-----------------------+\n-                                        |                       |\n-                                        | local/temp variables  |\n-                                        |                       |\n-                                        +-----------------------+\n-                                        |                       |\n-                                        | arguments on stack    |\n-  low                                   |                       |\n-  mem                               SP  +-----------------------+\n-\n-Notes:\n-1) The \"reg parm save area\" does not exist for non variable argument fns.\n-   The \"reg parm save area\" can be eliminated completely if we created our\n-   own va-arc.h, but that has tradeoffs as well (so it's not done).  */\n-\n-/* Structure to be filled in by arc_compute_frame_size with register\n-   save masks, and offsets for the current function.  */\n-struct GTY (()) arc_frame_info\n-{\n-  unsigned int total_size;\t/* # bytes that the entire frame takes up.  */\n-  unsigned int extra_size;\t/* # bytes of extra stuff.  */\n-  unsigned int pretend_size;\t/* # bytes we push and pretend caller did.  */\n-  unsigned int args_size;\t/* # bytes that outgoing arguments take up.  */\n-  unsigned int reg_size;\t/* # bytes needed to store regs.  */\n-  unsigned int var_size;\t/* # bytes that variables take up.  */\n-  unsigned int gmask;\t\t/* Mask of saved gp registers.  */\n-  bool initialized; /* FALSE if frame size already calculated.  */\n-  short millicode_start_reg;\n-  short millicode_end_reg;\n-  bool save_return_addr;\n-};\n-\n-/* GMASK bit length -1.  */\n-#define GMASK_LEN 31\n-\n-/* Defining data structures for per-function information.  */\n-\n-typedef struct GTY (()) machine_function\n-{\n-  unsigned int fn_type;\n-  struct arc_frame_info frame_info;\n-  /* To keep track of unalignment caused by short insns.  */\n-  int unalign;\n-  struct arc_ccfsm ccfsm_current;\n-  /* Map from uid to ccfsm state during branch shortening.  */\n-  rtx ccfsm_current_insn;\n-  char arc_reorg_started;\n-  char prescan_initialized;\n-} machine_function;\n-\n-/* Type of function DECL.\n-\n-   The result is cached.  To reset the cache at the end of a function,\n-   call with DECL = NULL_TREE.  */\n-\n-unsigned int\n-arc_compute_function_type (struct function *fun)\n-{\n-  tree attr, decl = fun->decl;\n-  unsigned int fn_type = fun->machine->fn_type;\n-\n-  if (fn_type != ARC_FUNCTION_UNKNOWN)\n-    return fn_type;\n-\n-  /* Check if it is a naked function.  */\n-  if (lookup_attribute (\"naked\", DECL_ATTRIBUTES (decl)) != NULL_TREE)\n-    fn_type |= ARC_FUNCTION_NAKED;\n-  else\n-    fn_type |= ARC_FUNCTION_NORMAL;\n-\n-  /* Now see if this is an interrupt handler.  */\n-  attr = lookup_attribute (\"interrupt\", DECL_ATTRIBUTES (decl));\n-  if (attr != NULL_TREE)\n-    {\n-      tree value, args = TREE_VALUE (attr);\n-\n-      gcc_assert (list_length (args) == 1);\n-      value = TREE_VALUE (args);\n-      gcc_assert (TREE_CODE (value) == STRING_CST);\n-\n-      if (!strcmp (TREE_STRING_POINTER (value), \"ilink1\")\n-\t  || !strcmp (TREE_STRING_POINTER (value), \"ilink\"))\n-\tfn_type |= ARC_FUNCTION_ILINK1;\n-      else if (!strcmp (TREE_STRING_POINTER (value), \"ilink2\"))\n-\tfn_type |= ARC_FUNCTION_ILINK2;\n-      else if (!strcmp (TREE_STRING_POINTER (value), \"firq\"))\n-\tfn_type |= ARC_FUNCTION_FIRQ;\n-      else\n-\tgcc_unreachable ();\n-    }\n-\n-  return fun->machine->fn_type = fn_type;\n-}\n-\n /* Helper function to wrap FRAME_POINTER_NEEDED.  We do this as\n    FRAME_POINTER_NEEDED will not be true until the IRA (Integrated\n    Register Allocator) pass, while we want to get the frame size\n@@ -2619,14 +2625,12 @@ arc_frame_pointer_needed (void)\n }\n \n /* Tell prologue and epilogue if register REGNO should be saved /\n-   restored.  The return address, stack pointer and frame pointer are\n-   treated separately.  Don't consider them here.  Addition for pic:\n-   The gp register needs to be saved if the current function changes\n-   it to access gotoff variables.  FIXME: This will not be needed if\n-   we used some arbitrary register instead of r26.  */\n+   restored.  The SPECIAL_P is true when the register may need special\n+   ld/st sequence.  The return address, and stack pointer are treated\n+   separately.  Don't consider them here.  */\n \n static bool\n-arc_must_save_register (int regno, struct function *func)\n+arc_must_save_register (int regno, struct function *func, bool special_p)\n {\n   unsigned int fn_type = arc_compute_function_type (func);\n   bool irq_auto_save_p = ((irq_ctrl_saved.irq_save_last_reg >= regno)\n@@ -2656,27 +2660,91 @@ arc_must_save_register (int regno, struct function *func)\n \n   switch (regno)\n     {\n+    case ILINK1_REG:\n     case RETURN_ADDR_REGNUM:\n     case STACK_POINTER_REGNUM:\n+      /* The stack pointer and the return address are handled\n+\t separately.  */\n+      return false;\n+\n+    case R30_REG:\n+      /* r30 is either used as ilink2 by ARCv1 or as a free register\n+\t by ARCv2.  */\n+      if (!TARGET_V2)\n+\treturn false;\n+      break;\n+\n+    case R40_REG:\n+    case R41_REG:\n+    case R42_REG:\n+    case R43_REG:\n+    case R44_REG:\n+      /* If those ones are used by the FPX machinery, we handle them\n+\t separately.  */\n+      if (TARGET_DPFP && !special_p)\n+\treturn false;\n+      /* FALLTHRU.  */\n+\n+    case R32_REG:\n+    case R33_REG:\n+    case R34_REG:\n+    case R35_REG:\n+    case R36_REG:\n+    case R37_REG:\n+    case R38_REG:\n+    case R39_REG:\n+    case R45_REG:\n+    case R46_REG:\n+    case R47_REG:\n+    case R48_REG:\n+    case R49_REG:\n+    case R50_REG:\n+    case R51_REG:\n+    case R52_REG:\n+    case R53_REG:\n+    case R54_REG:\n+    case R55_REG:\n+    case R56_REG:\n+    case R57_REG:\n+    case R58_REG:\n+    case R59_REG:\n+      /* The Extension Registers.  */\n+      if (ARC_INTERRUPT_P (fn_type)\n+\t  && (df_regs_ever_live_p (RETURN_ADDR_REGNUM)\n+\t      || df_regs_ever_live_p (regno))\n+\t  /* Not all extension registers are available, choose the\n+\t     real ones.  */\n+\t  && !fixed_regs[regno])\n+\treturn true;\n+      return false;\n+\n+    case 61:\n+    case 62:\n+    case 63:\n+      /* Fixed/control register, nothing to do.  LP_COUNT is\n+\t different.  */\n       return false;\n \n     case HARD_FRAME_POINTER_REGNUM:\n       /* If we need FP reg as a frame pointer then don't save it as a\n \t regular reg.  */\n       if (arc_frame_pointer_needed ())\n \treturn false;\n+      break;\n \n-      /* FALLTHRU */\n     default:\n-      if (df_regs_ever_live_p (regno)\n-\t  && (!call_used_regs[regno]\n-\t      || ARC_INTERRUPT_P (fn_type))\n-\t  /* Do not emit code for auto saved regs.  */\n-\t  && !irq_auto_save_p\n-\t  && !firq_auto_save_p)\n-\treturn true;\n+      break;\n     }\n \n+  if (((df_regs_ever_live_p (regno) && !call_used_regs[regno])\n+       /* In an interrupt save everything.  */\n+       || (ARC_INTERRUPT_P (fn_type)\n+\t   && (df_regs_ever_live_p (RETURN_ADDR_REGNUM)\n+\t       || df_regs_ever_live_p (regno))))\n+      /* Do not emit code for auto saved regs.  */\n+      && !irq_auto_save_p\n+      && !firq_auto_save_p)\n+    return true;\n   return false;\n }\n \n@@ -2700,14 +2768,14 @@ arc_must_save_return_addr (struct function *func)\n    of registers to be saved / restored with a millicode call.  */\n \n static int\n-arc_compute_millicode_save_restore_regs (unsigned int gmask,\n+arc_compute_millicode_save_restore_regs (uint64_t gmask,\n \t\t\t\t\t struct arc_frame_info *frame)\n {\n   int regno;\n \n   int start_reg = 13, end_reg = 25;\n \n-  for (regno = start_reg; regno <= end_reg && (gmask & (1L << regno));)\n+  for (regno = start_reg; regno <= end_reg && (gmask & (1ULL << regno));)\n     regno++;\n   end_reg = regno - 1;\n   /* There is no point in using millicode thunks if we don't save/restore\n@@ -2731,7 +2799,7 @@ arc_compute_frame_size (void)\n   int regno;\n   unsigned int total_size, var_size, args_size, pretend_size, extra_size;\n   unsigned int reg_size;\n-  unsigned int gmask;\n+  uint64_t gmask;\n   struct arc_frame_info *frame_info;\n   int size;\n   unsigned int extra_plus_reg_size;\n@@ -2759,12 +2827,13 @@ arc_compute_frame_size (void)\n   reg_size = 0;\n   gmask = 0;\n \n-  for (regno = 0; regno <= 31; regno++)\n+  /* The last 4 regs are special, avoid them.  */\n+  for (regno = 0; regno <= (GMASK_LEN - 4); regno++)\n     {\n-      if (arc_must_save_register (regno, cfun))\n+      if (arc_must_save_register (regno, cfun, false))\n \t{\n \t  reg_size += UNITS_PER_WORD;\n-\t  gmask |= 1L << regno;\n+\t  gmask |= 1ULL << regno;\n \t}\n     }\n \n@@ -2779,7 +2848,7 @@ arc_compute_frame_size (void)\n     for (regno = 0; EH_RETURN_DATA_REGNO (regno) != INVALID_REGNUM; regno++)\n       {\n \treg_size += UNITS_PER_WORD;\n-\tgmask |= 1L << regno;\n+\tgmask |= 1ULL << regno;\n       }\n \n   /* Check if we need to save the return address.  */\n@@ -2789,12 +2858,25 @@ arc_compute_frame_size (void)\n \n   /* Saving blink reg for millicode thunk calls.  */\n   if (TARGET_MILLICODE_THUNK_SET\n-      && !crtl->calls_eh_return)\n+      && !crtl->calls_eh_return\n+      && !ARC_INTERRUPT_P (arc_compute_function_type (cfun)))\n     {\n       if (arc_compute_millicode_save_restore_regs (gmask, frame_info))\n \tframe_info->save_return_addr = true;\n     }\n \n+  /* Save lp_count, lp_start and lp_end.  */\n+  if (arc_lpcwidth != 0 && arc_must_save_register (LP_COUNT, cfun, true))\n+    reg_size += UNITS_PER_WORD * 3;\n+\n+  /* Check for the special R40-R44 regs used by FPX extension.  */\n+  if (arc_must_save_register (TARGET_BIG_ENDIAN ? R41_REG : R40_REG,\n+\t\t\t      cfun, TARGET_DPFP))\n+    reg_size += UNITS_PER_WORD * 2;\n+  if (arc_must_save_register (TARGET_BIG_ENDIAN ? R43_REG : R42_REG,\n+\t\t\t      cfun, TARGET_DPFP))\n+    reg_size += UNITS_PER_WORD * 2;\n+\n   /* 4) Calculate extra size made up of the blink + fp size.  */\n   extra_size = 0;\n   if (arc_must_save_return_addr (cfun))\n@@ -2929,6 +3011,22 @@ frame_save_reg (rtx reg, HOST_WIDE_INT offset)\n   return GET_MODE_SIZE (GET_MODE (reg)) - offset;\n }\n \n+/* Helper used when saving AUX regs during ISR.  */\n+\n+static int\n+push_reg (rtx reg)\n+{\n+  rtx stkslot = gen_rtx_MEM (GET_MODE (reg), gen_rtx_PRE_DEC (Pmode,\n+\t\t\t\t\t\t   stack_pointer_rtx));\n+  rtx insn = emit_move_insn (stkslot, reg);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\tgen_rtx_SET (stack_pointer_rtx,\n+\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t    -GET_MODE_SIZE (GET_MODE (reg)))));\n+  return GET_MODE_SIZE (GET_MODE (reg));\n+}\n+\n /* Helper for epilogue: emit frame load with post_modify or post_inc\n    to restore register REG from stack.  The initial offset is passed\n    via OFFSET.  */\n@@ -2967,12 +3065,29 @@ frame_restore_reg (rtx reg, HOST_WIDE_INT offset)\n   return GET_MODE_SIZE (GET_MODE (reg)) + offset;\n }\n \n+/* Helper used when restoring AUX regs during ISR.  */\n+\n+static int\n+pop_reg (rtx reg)\n+{\n+  rtx stkslot = gen_rtx_MEM (GET_MODE (reg), gen_rtx_POST_INC (Pmode,\n+\t\t\t\t\t\t   stack_pointer_rtx));\n+  rtx insn = emit_move_insn (reg, stkslot);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\tgen_rtx_SET (stack_pointer_rtx,\n+\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t    GET_MODE_SIZE (GET_MODE (reg)))));\n+  return GET_MODE_SIZE (GET_MODE (reg));\n+}\n+\n+\n /* Check if we have a continous range to be save/restored with the\n    help of enter/leave instructions.  A vaild register range starts\n    from $r13 and is up to (including) $r26.  */\n \n static bool\n-arc_enter_leave_p (unsigned int gmask)\n+arc_enter_leave_p (uint64_t gmask)\n {\n   int regno;\n   unsigned int rmask = 0;\n@@ -2981,8 +3096,8 @@ arc_enter_leave_p (unsigned int gmask)\n     return false;\n \n   for (regno = ENTER_LEAVE_START_REG;\n-       regno <= ENTER_LEAVE_END_REG && (gmask & (1L << regno)); regno++)\n-    rmask |= 1L << regno;\n+       regno <= ENTER_LEAVE_END_REG && (gmask & (1ULL << regno)); regno++)\n+    rmask |= 1ULL << regno;\n \n   if (rmask ^ gmask)\n     return false;\n@@ -2995,13 +3110,14 @@ arc_enter_leave_p (unsigned int gmask)\n    instructions.  */\n \n static int\n-arc_save_callee_saves (unsigned int gmask,\n+arc_save_callee_saves (uint64_t gmask,\n \t\t       bool save_blink,\n \t\t       bool save_fp,\n \t\t       HOST_WIDE_INT offset)\n {\n   rtx reg;\n   int frame_allocated = 0;\n+  int i;\n \n   /* The home-grown ABI says link register is saved first.  */\n   if (save_blink)\n@@ -3013,26 +3129,61 @@ arc_save_callee_saves (unsigned int gmask,\n \n   /* N.B. FRAME_POINTER_MASK and RETURN_ADDR_MASK are cleared in gmask.  */\n   if (gmask)\n-    for (int i = 31; i >= 0; i--)\n+    for (i = GMASK_LEN; i >= 0; i--)\n       {\n \tmachine_mode save_mode = SImode;\n \n \tif (TARGET_LL64\n \t    && ((i - 1) % 2 == 0)\n-\t    && ((gmask & (1L << i)) != 0)\n-\t    && ((gmask & (1L << (i - 1))) != 0))\n+\t    && ((gmask & (1ULL << i)) != 0)\n+\t    && ((gmask & (1ULL << (i - 1))) != 0))\n \t  {\n \t    save_mode = DImode;\n \t    --i;\n \t  }\n-\telse if ((gmask & (1L << i)) == 0)\n+\telse if ((gmask & (1ULL << i)) == 0)\n \t  continue;\n \n \treg = gen_rtx_REG (save_mode, i);\n \tframe_allocated += frame_save_reg (reg, offset);\n \toffset = 0;\n       }\n \n+  /* Check if we need to save the ZOL machinery.  */\n+  if (arc_lpcwidth != 0 && arc_must_save_register (LP_COUNT, cfun, true))\n+    {\n+      rtx reg0 = gen_rtx_REG (SImode, R0_REG);\n+      emit_insn (gen_rtx_SET (reg0,\n+\t\t\t      gen_rtx_UNSPEC_VOLATILE\n+\t\t\t      (Pmode, gen_rtvec (1, GEN_INT (AUX_LP_START)),\n+\t\t\t       VUNSPEC_ARC_LR)));\n+      frame_allocated += push_reg (reg0);\n+      emit_insn (gen_rtx_SET (reg0,\n+\t\t\t      gen_rtx_UNSPEC_VOLATILE\n+\t\t\t      (Pmode, gen_rtvec (1, GEN_INT (AUX_LP_END)),\n+\t\t\t       VUNSPEC_ARC_LR)));\n+      frame_allocated += push_reg (reg0);\n+      emit_move_insn (reg0, gen_rtx_REG (SImode, LP_COUNT));\n+      frame_allocated += push_reg (reg0);\n+    }\n+\n+  /* Save AUX regs used by FPX machinery.  */\n+  if (arc_must_save_register (TARGET_BIG_ENDIAN ? R41_REG : R40_REG,\n+\t\t\t      cfun, TARGET_DPFP))\n+    {\n+      rtx reg0 = gen_rtx_REG (SImode, R0_REG);\n+\n+      for (i = 0; i < 4; i++)\n+\t{\n+\t  emit_insn (gen_rtx_SET (reg0,\n+\t\t\t\t  gen_rtx_UNSPEC_VOLATILE\n+\t\t\t\t  (Pmode, gen_rtvec (1, GEN_INT (AUX_DPFP_START\n+\t\t\t\t\t\t\t\t + i)),\n+\t\t\t\t   VUNSPEC_ARC_LR)));\n+\t  frame_allocated += push_reg (reg0);\n+\t}\n+    }\n+\n   /* Save frame pointer if needed.  First save the FP on stack, if not\n      autosaved.  Unfortunately, I cannot add it to gmask and use the\n      above loop to save fp because our ABI states fp goes aftert all\n@@ -3054,7 +3205,7 @@ arc_save_callee_saves (unsigned int gmask,\n    if it is for an interrupt handler) using LD/LDD instructions.  */\n \n static int\n-arc_restore_callee_saves (unsigned int gmask,\n+arc_restore_callee_saves (uint64_t gmask,\n \t\t\t  bool restore_blink,\n \t\t\t  bool restore_fp,\n \t\t\t  HOST_WIDE_INT offset,\n@@ -3064,6 +3215,7 @@ arc_restore_callee_saves (unsigned int gmask,\n   int frame_deallocated = 0;\n   HOST_WIDE_INT offs = cfun->machine->frame_info.reg_size;\n   bool early_blink_restore;\n+  int i;\n \n   /* Emit mov fp,sp.  */\n   if (arc_frame_pointer_needed () && offset)\n@@ -3080,6 +3232,43 @@ arc_restore_callee_saves (unsigned int gmask,\n       frame_deallocated += frame_restore_reg (hard_frame_pointer_rtx, 0);\n     }\n \n+  /* Restore AUX-regs used by FPX machinery.  */\n+  if (arc_must_save_register (TARGET_BIG_ENDIAN ? R41_REG : R40_REG,\n+\t\t\t      cfun, TARGET_DPFP))\n+    {\n+      rtx reg0 = gen_rtx_REG (SImode, R0_REG);\n+\n+      gcc_assert (offset == 0);\n+      for (i = 0; i < 4; i++)\n+\t{\n+\t  frame_deallocated += pop_reg (reg0);\n+\t  emit_insn (gen_rtx_UNSPEC_VOLATILE\n+\t\t     (VOIDmode, gen_rtvec (2, reg0, GEN_INT (AUX_DPFP_START\n+\t\t\t\t\t\t\t     + i)),\n+\t\t      VUNSPEC_ARC_SR));\n+\t}\n+    }\n+\n+  /* Check if we need to restore the ZOL machinery.  */\n+  if (arc_lpcwidth !=0 && arc_must_save_register (LP_COUNT, cfun, true))\n+    {\n+      rtx reg0 = gen_rtx_REG (SImode, R0_REG);\n+\n+      gcc_assert (offset == 0);\n+      frame_deallocated += pop_reg (reg0);\n+      emit_move_insn (gen_rtx_REG (SImode, LP_COUNT), reg0);\n+\n+      frame_deallocated += pop_reg (reg0);\n+      emit_insn (gen_rtx_UNSPEC_VOLATILE\n+\t\t (VOIDmode, gen_rtvec (2, reg0, GEN_INT (AUX_LP_END)),\n+\t\t  VUNSPEC_ARC_SR));\n+\n+      frame_deallocated += pop_reg (reg0);\n+      emit_insn (gen_rtx_UNSPEC_VOLATILE\n+\t\t (VOIDmode, gen_rtvec (2, reg0, GEN_INT (AUX_LP_START)),\n+\t\t  VUNSPEC_ARC_SR));\n+    }\n+\n   if (offset)\n     {\n       /* No $fp involved, we need to do an add to set the $sp to the\n@@ -3090,7 +3279,8 @@ arc_restore_callee_saves (unsigned int gmask,\n     }\n \n   /* When we do not optimize for size, restore first blink.  */\n-  early_blink_restore = restore_blink && !optimize_size && offs;\n+  early_blink_restore = restore_blink && !optimize_size && offs\n+    && !ARC_INTERRUPT_P (arc_compute_function_type (cfun));\n   if (early_blink_restore)\n     {\n       rtx addr = plus_constant (Pmode, stack_pointer_rtx, offs);\n@@ -3103,29 +3293,29 @@ arc_restore_callee_saves (unsigned int gmask,\n \n   /* N.B. FRAME_POINTER_MASK and RETURN_ADDR_MASK are cleared in gmask.  */\n   if (gmask)\n-    for (int i = 0; i <= GMASK_LEN; i++)\n+    for (i = 0; i <= GMASK_LEN; i++)\n       {\n \tmachine_mode restore_mode = SImode;\n \n \tif (TARGET_LL64\n \t    && ((i % 2) == 0)\n-\t    && ((gmask & (1L << i)) != 0)\n-\t    && ((gmask & (1L << (i + 1))) != 0))\n+\t    && ((gmask & (1ULL << i)) != 0)\n+\t    && ((gmask & (1ULL << (i + 1))) != 0))\n \t  restore_mode = DImode;\n-\telse if ((gmask & (1L << i)) == 0)\n+\telse if ((gmask & (1ULL << i)) == 0)\n \t  continue;\n \n \treg = gen_rtx_REG (restore_mode, i);\n \toffs = 0;\n \tswitch (restore_mode)\n \t  {\n \t  case E_DImode:\n-\t    if ((GMASK_LEN - __builtin_clz (gmask)) == (i + 1)\n+\t    if ((GMASK_LEN - __builtin_clzll (gmask)) == (i + 1)\n \t\t&& early_blink_restore)\n \t      offs = 4;\n \t    break;\n \t  case E_SImode:\n-\t    if ((GMASK_LEN - __builtin_clz (gmask)) == i\n+\t    if ((GMASK_LEN - __builtin_clzll (gmask)) == i\n \t\t&& early_blink_restore)\n \t      offs = 4;\n \t    break;\n@@ -3158,7 +3348,7 @@ arc_restore_callee_saves (unsigned int gmask,\n    register.  */\n \n static int\n-arc_save_callee_enter (unsigned int gmask,\n+arc_save_callee_enter (uint64_t gmask,\n \t\t       bool save_blink,\n \t\t       bool save_fp,\n \t\t       HOST_WIDE_INT offset)\n@@ -3169,7 +3359,7 @@ arc_save_callee_enter (unsigned int gmask,\n   rtx insn, reg, mem;\n   int frame_allocated = 0;\n \n-  for (regno = start_reg; regno <= end_reg && (gmask & (1L << regno));)\n+  for (regno = start_reg; regno <= end_reg && (gmask & (1ULL << regno));)\n     regno++;\n \n   end_reg = regno - 1;\n@@ -3214,7 +3404,7 @@ arc_save_callee_enter (unsigned int gmask,\n \t\t\t\t\t\t  off));\n       XVECEXP (insn, 0, indx) = gen_rtx_SET (mem, reg);\n       RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx)) = 1;\n-      gmask = gmask & ~(1L << regno);\n+      gmask = gmask & ~(1ULL << regno);\n     }\n \n   if (save_fp)\n@@ -3249,7 +3439,7 @@ arc_save_callee_enter (unsigned int gmask,\n    (RESTORE_FP), and can automatic return (RETURN_P).  */\n \n static int\n-arc_restore_callee_leave (unsigned int gmask,\n+arc_restore_callee_leave (uint64_t gmask,\n \t\t\t  bool restore_blink,\n \t\t\t  bool restore_fp,\n \t\t\t  bool return_p,\n@@ -3261,7 +3451,7 @@ arc_restore_callee_leave (unsigned int gmask,\n   rtx insn, reg, mem;\n   int frame_allocated = 0;\n \n-  for (regno = start_reg; regno <= end_reg && (gmask & (1L << regno));)\n+  for (regno = start_reg; regno <= end_reg && (gmask & (1ULL << regno));)\n     regno++;\n \n   end_reg = regno - 1;\n@@ -3322,7 +3512,7 @@ arc_restore_callee_leave (unsigned int gmask,\n \t\t\t\t\t\t  off));\n       XVECEXP (insn, 0, indx) = gen_rtx_SET (reg, mem);\n       RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx)) = 1;\n-      gmask = gmask & ~(1L << regno);\n+      gmask = gmask & ~(1ULL << regno);\n     }\n \n   if (restore_fp)\n@@ -3385,7 +3575,7 @@ arc_restore_callee_leave (unsigned int gmask,\n */\n \n static int\n-arc_save_callee_milli (unsigned int gmask,\n+arc_save_callee_milli (uint64_t gmask,\n \t\t       bool save_blink,\n \t\t       bool save_fp,\n \t\t       HOST_WIDE_INT offset,\n@@ -3397,7 +3587,7 @@ arc_save_callee_milli (unsigned int gmask,\n   rtx insn, reg, mem;\n   int frame_allocated = 0;\n \n-  for (regno = start_reg; regno <= end_reg && (gmask & (1L << regno));)\n+  for (regno = start_reg; regno <= end_reg && (gmask & (1ULL << regno));)\n     regno++;\n \n   end_reg = regno - 1;\n@@ -3440,7 +3630,7 @@ arc_save_callee_milli (unsigned int gmask,\n \t\t\t\t\t\t  off));\n       XVECEXP (insn, 0, indx) = gen_rtx_SET (mem, reg);\n       RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx)) = 1;\n-      gmask = gmask & ~(1L << regno);\n+      gmask = gmask & ~(1ULL << regno);\n     }\n   insn = frame_insn (insn);\n \n@@ -3468,9 +3658,9 @@ arc_save_callee_milli (unsigned int gmask,\n     }\n \n   /* Save remaining registers using st instructions.  */\n-  for (regno = 0; regno <= 31; regno++)\n+  for (regno = 0; regno <= GMASK_LEN; regno++)\n     {\n-      if ((gmask & (1L << regno)) == 0)\n+      if ((gmask & (1ULL << regno)) == 0)\n \tcontinue;\n \n       reg = gen_rtx_REG (SImode, regno);\n@@ -3499,7 +3689,7 @@ arc_save_callee_milli (unsigned int gmask,\n /* Like the previous function but restore.  */\n \n static int\n-arc_restore_callee_milli (unsigned int gmask,\n+arc_restore_callee_milli (uint64_t gmask,\n \t\t\t  bool restore_blink,\n \t\t\t  bool restore_fp,\n \t\t\t  bool return_p,\n@@ -3511,7 +3701,7 @@ arc_restore_callee_milli (unsigned int gmask,\n   rtx insn, reg, mem;\n   int frame_allocated = 0;\n \n-  for (regno = start_reg; regno <= end_reg && (gmask & (1L << regno));)\n+  for (regno = start_reg; regno <= end_reg && (gmask & (1ULL << regno));)\n     regno++;\n \n   end_reg = regno - 1;\n@@ -3571,13 +3761,13 @@ arc_restore_callee_milli (unsigned int gmask,\n \t\t\t\t\t\t  off));\n       XVECEXP (insn, 0, indx) = gen_rtx_SET (reg, mem);\n       RTX_FRAME_RELATED_P (XVECEXP (insn, 0, indx)) = 1;\n-      gmask = gmask & ~(1L << regno);\n+      gmask = gmask & ~(1ULL << regno);\n     }\n \n   /* Restore remaining registers using LD instructions.  */\n-  for (regno = 0; regno <= 31; regno++)\n+  for (regno = 0; regno <= GMASK_LEN; regno++)\n     {\n-      if ((gmask & (1L << regno)) == 0)\n+      if ((gmask & (1ULL << regno)) == 0)\n \tcontinue;\n \n       reg = gen_rtx_REG (SImode, regno);\n@@ -3627,7 +3817,7 @@ void\n arc_expand_prologue (void)\n {\n   int size;\n-  unsigned int gmask = cfun->machine->frame_info.gmask;\n+  uint64_t gmask = cfun->machine->frame_info.gmask;\n   struct arc_frame_info *frame = &cfun->machine->frame_info;\n   unsigned int frame_size_to_allocate;\n   int first_offset = 0;\n@@ -3700,6 +3890,30 @@ arc_expand_prologue (void)\n   emit_insn (gen_blockage ());\n }\n \n+/* Return the register number of the register holding the return address\n+   for a function of type TYPE.  */\n+\n+static int\n+arc_return_address_register (unsigned int fn_type)\n+{\n+  int regno = 0;\n+\n+  if (ARC_INTERRUPT_P (fn_type))\n+    {\n+      if ((fn_type & (ARC_FUNCTION_ILINK1 | ARC_FUNCTION_FIRQ)) != 0)\n+\tregno = ILINK1_REG;\n+      else if ((fn_type & ARC_FUNCTION_ILINK2) != 0)\n+\tregno = ILINK2_REG;\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (ARC_NORMAL_P (fn_type) || ARC_NAKED_P (fn_type))\n+    regno = RETURN_ADDR_REGNUM;\n+\n+  gcc_assert (regno != 0);\n+  return regno;\n+}\n+\n /* Do any necessary cleanup after a function to restore stack, frame,\n    and regs.  */\n \n@@ -3715,12 +3929,11 @@ arc_expand_epilogue (int sibcall_p)\n   bool restore_fp = arc_frame_pointer_needed () && !ARC_AUTOFP_IRQ_P (fn_type);\n   bool restore_blink = arc_must_save_return_addr (cfun)\n     && !ARC_AUTOBLINK_IRQ_P (fn_type);\n-  unsigned int gmask = cfun->machine->frame_info.gmask;\n+  uint64_t gmask = cfun->machine->frame_info.gmask;\n   bool return_p = !sibcall_p && fn_type == ARC_FUNCTION_NORMAL\n \t\t   && !cfun->machine->frame_info.pretend_size;\n   struct arc_frame_info *frame = &cfun->machine->frame_info;\n \n-\n   /* Naked functions don't have epilogue.  */\n   if (ARC_NAKED_P (fn_type))\n     return;\n@@ -3795,7 +4008,18 @@ arc_expand_epilogue (int sibcall_p)\n \t\t\t      EH_RETURN_STACKADJ_RTX));\n \n   /* Emit the return instruction.  */\n-  if (sibcall_p == FALSE)\n+  if (ARC_INTERRUPT_P (fn_type))\n+    {\n+      rtx ra = gen_rtx_REG (Pmode, arc_return_address_register (fn_type));\n+\n+      if (TARGET_V2)\n+\temit_jump_insn (gen_rtie ());\n+      else if (TARGET_ARC700)\n+\temit_jump_insn (gen_rtie ());\n+      else\n+\temit_jump_insn (gen_arc600_rtie (ra));\n+    }\n+  else if (sibcall_p == FALSE)\n     emit_jump_insn (gen_simple_return ());\n }\n \n@@ -9702,12 +9926,6 @@ arc_check_millicode (rtx op, int offset, int load_p)\n \n /* Accessor functions for cfun->machine->unalign.  */\n \n-int\n-arc_get_unalign (void)\n-{\n-  return cfun->machine->unalign;\n-}\n-\n void\n arc_clear_unalign (void)\n {\n@@ -10142,29 +10360,6 @@ arc_can_follow_jump (const rtx_insn *follower, const rtx_insn *followee)\n   return true;\n }\n \n-/* Return the register number of the register holding the return address\n-   for a function of type TYPE.  */\n-\n-int\n-arc_return_address_register (unsigned int fn_type)\n-{\n-  int regno = 0;\n-\n-  if (ARC_INTERRUPT_P (fn_type))\n-    {\n-      if ((fn_type & (ARC_FUNCTION_ILINK1 | ARC_FUNCTION_FIRQ)) != 0)\n-\tregno = ILINK1_REG;\n-      else if ((fn_type & ARC_FUNCTION_ILINK2) != 0)\n-\tregno = ILINK2_REG;\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (ARC_NORMAL_P (fn_type) || ARC_NAKED_P (fn_type))\n-    regno = RETURN_ADDR_REGNUM;\n-\n-  gcc_assert (regno != 0);\n-  return regno;\n-}\n \n /* Implement EPILOGUE_USES.\n    Return true if REGNO should be added to the deemed uses of the epilogue.\n@@ -10177,25 +10372,25 @@ bool\n arc_epilogue_uses (int regno)\n {\n   unsigned int fn_type;\n+  fn_type = arc_compute_function_type (cfun);\n \n   if (regno == arc_tp_regno)\n     return true;\n \n-  fn_type = arc_compute_function_type (cfun);\n-  if (reload_completed)\n+  if (regno == RETURN_ADDR_REGNUM)\n+    return true;\n+\n+  if (regno == arc_return_address_register (fn_type))\n+    return true;\n+\n+  if (epilogue_completed && ARC_INTERRUPT_P (fn_type))\n     {\n-      if (ARC_INTERRUPT_P (cfun->machine->fn_type))\n-\t{\n-\t  if (!fixed_regs[regno])\n-\t    return true;\n-\t  return ((regno == arc_return_address_register (fn_type))\n-\t\t  || (regno == RETURN_ADDR_REGNUM));\n-\t}\n-      else\n-\treturn regno == RETURN_ADDR_REGNUM;\n+      /* An interrupt function restores more registers.  */\n+      if (df_regs_ever_live_p (regno) || call_used_regs[regno])\n+\treturn true;\n     }\n-  else\n-    return regno == arc_return_address_register (fn_type);\n+\n+  return false;\n }\n \n /* Helper for EH_USES macro.  */\n@@ -11491,6 +11686,16 @@ arc_check_mov_const (HOST_WIDE_INT ival)\n   return false;\n }\n \n+/* Return nonzero if this function is known to have a null epilogue.\n+   This allows the optimizer to omit jumps to jumps if no stack\n+   was created.  */\n+\n+bool\n+arc_can_use_return_insn (void)\n+{\n+  return (reload_completed && cfun->machine->frame_info.total_size == 0\n+\t  && !ARC_INTERRUPT_P (arc_compute_function_type (cfun)));\n+}\n \n #undef TARGET_USE_ANCHORS_FOR_SYMBOL_P\n #define TARGET_USE_ANCHORS_FOR_SYMBOL_P arc_use_anchors_for_symbol_p"}, {"sha": "7cd47338ec2ba10c384f8aafca06263103ff7b4d", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 61, "deletions": 78, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "patch": "@@ -163,6 +163,7 @@\n   VUNSPEC_ARC_LL\n   VUNSPEC_ARC_BLOCKAGE\n   VUNSPEC_ARC_EH_RETURN\n+  VUNSPEC_ARC_ARC600_RTIE\n   ])\n \n (define_constants\n@@ -187,17 +188,37 @@\n    (R30_REG 30)\n    (RETURN_ADDR_REGNUM 31)\n    (R32_REG 32)\n+   (R33_REG 33)\n+   (R34_REG 34)\n+   (R35_REG 35)\n+   (R36_REG 36)\n+   (R37_REG 37)\n+   (R38_REG 38)\n+   (R39_REG 39)\n    (R40_REG 40)\n    (R41_REG 41)\n    (R42_REG 42)\n    (R43_REG 43)\n    (R44_REG 44)\n+   (R45_REG 45)\n+   (R46_REG 46)\n+   (R47_REG 47)\n+   (R48_REG 48)\n+   (R49_REG 49)\n+   (R50_REG 50)\n+   (R51_REG 51)\n+   (R52_REG 52)\n+   (R53_REG 53)\n+   (R54_REG 54)\n+   (R55_REG 55)\n+   (R56_REG 56)\n    (R57_REG 57)\n+   (R58_REG 58)\n+   (R59_REG 59)\n+\n    (MUL64_OUT_REG 58)\n    (MUL32x16_REG 56)\n    (ARCV2_ACC 58)\n-   (R59_REG 59)\n-\n    (LP_COUNT 60)\n    (CC_REG 61)\n    (PCL_REG 63)\n@@ -214,7 +235,7 @@\n \n (define_attr \"type\"\n   \"move,load,store,cmove,unary,binary,compare,shift,uncond_branch,jump,branch,\n-   brcc,brcc_no_delay_slot,call,sfunc,call_no_delay_slot,\n+   brcc,brcc_no_delay_slot,call,sfunc,call_no_delay_slot,rtie,\n    multi,umulti, two_cycle_core,lr,sr,divaw,loop_setup,loop_end,return,\n    misc,spfp,dpfp_mult,dpfp_addsub,mulmac_600,cc_arith,\n    simd_vload, simd_vload128, simd_vstore, simd_vmove, simd_vmove_else_zero,\n@@ -531,9 +552,7 @@\n   (cond [(eq_attr \"in_delay_slot\" \"false\")\n \t (const_string \"no\")\n \t (match_test \"regno_clobbered_p\n-\t\t\t(arc_return_address_register\n-\t\t\t  (arc_compute_function_type (cfun)),\n-\t\t\t insn, SImode, 1)\")\n+\t\t\t(RETURN_ADDR_REGNUM, insn, SImode, 1)\")\n \t (const_string \"no\")]\n \t(const_string \"yes\")))\n \n@@ -757,9 +776,9 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n ; execution must reflect this, lest out-of-range branches are created.\n ; the iscompact attribute allows the epilogue expander to know for which\n ; insns it should lengthen the return insn.\n-(define_insn_and_split \"*movsi_insn\"\t\t; 0  1 2 3    4  5  6   7   8   9  10  11  12  13  14  15  16    17      18  19  20    21   22 23  24   25 26  27  28\n-  [(set (match_operand:SI 0 \"move_dest_operand\" \"=q, q,r,q,   h,rl, r,  r,  r,  r, ?r,  r,  q,  h, rl,  q,  S,   Us<,RcqRck,!*x,  r,!*Rsd,!*Rcd,r,Ucm,  Usd,m,  m,VUsc\")\n-\t(match_operand:SI 1 \"move_src_operand\"  \"rL,rP,q,P,hCm1,rL, I,Clo,Chi,Cbi,Cpc,Clb,Cax,Cal,Cal,Uts,Rcq,RcqRck,   Us>,Usd,Ucm,  Usd,  Ucd,m,  r,!*Rzd,r,Cm3, C32\"))]\n+(define_insn_and_split \"*movsi_insn\"\t\t; 0  1 2 3    4   5 6   7   8   9  10  11  12  13  14  15  16    17      18  19  20    21   22 23  24   25 26  27  28\n+  [(set (match_operand:SI 0 \"move_dest_operand\" \"=q, q,r,q,   h, rl,r,  r,  r,  r, ?r,  r,  q,  h, rl,  q,  S,   Us<,RcqRck,!*x,  r,!*Rsd,!*Rcd,r,Ucm,  Usd,m,  m,VUsc\")\n+\t(match_operand:SI 1 \"move_src_operand\"  \"rL,rP,q,P,hCm1,rLl,I,Clo,Chi,Cbi,Cpc,Clb,Cax,Cal,Cal,Uts,Rcq,RcqRck,   Us>,Usd,Ucm,  Usd,  Ucd,m,  r,!*Rzd,r,Cm3, C32\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\n    || (CONSTANT_P (operands[1])\n@@ -775,16 +794,16 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n    mov%?\\\\t%0,%1\t;4\n    mov%?\\\\t%0,%1\t;5\n    mov%?\\\\t%0,%1\t;6\n-   movl.cl\\\\t %0,%1\t;7\n-   movh.cl\\\\t %0,%L1>>16 ;8\n+   movl.cl\\\\t%0,%1\t;7\n+   movh.cl\\\\t%0,%L1>>16 ;8\n    * return INTVAL (operands[1]) & 0xffffff ? \\\"movbi.cl\\\\t%0,%1 >> %p1,%p1,8;9\\\" : \\\"movbi.cl\\\\t%0,%L1 >> 24,24,8;9\\\";\n    add\\\\t%0,%1\t\t;10\n    add\\\\t%0,pcl,%1@pcl  ;11\n    #\n    mov%?\\\\t%0,%j1\t;13\n    mov%?\\\\t%0,%j1\t;14\n    ld%?\\\\t%0,%1\t\t;15\n-   st%?\\\\t %1,%0\t;16\n+   st%?\\\\t%1,%0\t\t;16\n    * return arc_short_long (insn, \\\"push%?\\\\t%1%&\\\", \\\"st%U0\\\\t%1,%0%&\\\");\n    * return arc_short_long (insn, \\\"pop%?\\\\t%0%&\\\",  \\\"ld%U1\\\\t%0,%1%&\\\");\n    ld%?\\\\t%0,%1\t\t;19\n@@ -4560,13 +4579,13 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n   (set_attr \"type\" \"misc\")])\n \n (define_insn \"rtie\"\n-  [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"N\")]\n-\t\t   VUNSPEC_ARC_RTIE)]\n-  \"\"\n+  [(return)\n+   (unspec_volatile [(const_int 0)] VUNSPEC_ARC_RTIE)]\n+  \"!TARGET_ARC600_FAMILY\"\n   \"rtie\"\n   [(set_attr \"length\" \"4\")\n-  (set_attr \"type\" \"misc\")\n-  (set_attr \"cond\" \"clob\")])\n+   (set_attr \"type\" \"rtie\")\n+   (set_attr \"cond\" \"clob\")])\n \n (define_insn \"sync\"\n   [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"N\")]\n@@ -4788,88 +4807,52 @@ core_3, archs4x, archs4xd, archs4xd_slow\"\n ; forbid instructions that change blink in the return / sibcall delay slot.\n (define_insn \"simple_return\"\n   [(simple_return)]\n-  \"reload_completed\"\n-{\n-  rtx reg\n-    = gen_rtx_REG (Pmode,\n-\t\t   arc_return_address_register (arc_compute_function_type\n-\t\t\t\t\t\t(cfun)));\n+  \"\"\n+  \"j%!%*\\\\t[blink]\"\n+  [(set_attr \"type\" \"return\")\n+   (set_attr \"cond\" \"canuse\")\n+   (set_attr \"iscompact\" \"maybe\")\n+   (set_attr \"length\" \"*\")])\n \n-  if (TARGET_V2\n-      && ARC_INTERRUPT_P (arc_compute_function_type (cfun)))\n-  {\n-    return \\\"rtie\\\";\n-  }\n-  output_asm_insn (\\\"j%!%* [%0]%&\\\", &reg);\n-  return \\\"\\\";\n-}\n-  [(set (attr \"type\")\n-\t(cond [(and (match_test \"ARC_INTERRUPT_P (arc_compute_function_type (cfun))\")\n-\t\t    (match_test \"TARGET_V2\"))\n-\t       (const_string \"brcc_no_delay_slot\")]\n-\t      (const_string \"return\")))\n-   ; predicable won't help here since the canonical rtl looks different\n-   ; for branches.\n-   (set (attr \"cond\")\n-\t(cond [(and (eq (symbol_ref \"arc_compute_function_type (cfun)\")\n-\t\t\t(symbol_ref \"ARC_FUNCTION_ILINK1\"))\n-\t\t    (match_test \"TARGET_V2\"))\n-\t       (const_string \"nocond\")]\n-\t      (const_string \"canuse\")))\n-  (set (attr \"iscompact\")\n-\t(cond [(eq (symbol_ref \"arc_compute_function_type (cfun)\")\n-\t\t   (symbol_ref \"ARC_FUNCTION_NORMAL\"))\n-\t       (const_string \"maybe\")]\n-\t      (const_string \"false\")))\n-   (set (attr \"length\")\n-\t(cond [(ne (symbol_ref \"arc_compute_function_type (cfun)\")\n-\t\t   (symbol_ref \"ARC_FUNCTION_NORMAL\"))\n-\t       (const_int 4)]\n-\t      (const_int 2)))])\n+(define_insn \"arc600_rtie\"\n+  [(return)\n+   (unspec_volatile [(match_operand 0 \"pmode_register_operand\" \"\")]\n+\t\t    VUNSPEC_ARC_ARC600_RTIE)]\n+  \"TARGET_ARC600_FAMILY\"\n+  \"j.f\\\\t[%0]\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"rtie\")\n+   (set_attr \"cond\" \"clob\")])\n \n (define_insn \"p_return_i\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"proper_comparison_operator\"\n \t\t\t\t      [(reg CC_REG) (const_int 0)])\n \t\t      (simple_return) (pc)))]\n-  \"reload_completed\n-   && !(TARGET_V2\n-     && ARC_INTERRUPT_P (arc_compute_function_type (cfun)))\"\n+  \"reload_completed\"\n {\n-  rtx xop[2];\n-  xop[0] = operands[0];\n-  xop[1]\n-    = gen_rtx_REG (Pmode,\n-\t\t   arc_return_address_register (arc_compute_function_type\n-\t\t\t\t\t\t(cfun)));\n-\n-  output_asm_insn (\\\"j%d0%!%# [%1]%&\\\", xop);\n+  output_asm_insn (\\\"j%d0%!%#\\\\t[blink]\\\", operands);\n   /* record the condition in case there is a delay insn.  */\n-  arc_ccfsm_record_condition (xop[0], false, insn, 0);\n+  arc_ccfsm_record_condition (operands[0], false, insn, 0);\n   return \\\"\\\";\n }\n   [(set_attr \"type\" \"return\")\n    (set_attr \"cond\" \"use\")\n-   (set (attr \"iscompact\")\n-\t(cond [(eq (symbol_ref \"arc_compute_function_type (cfun)\")\n-\t\t   (symbol_ref \"ARC_FUNCTION_NORMAL\"))\n-\t       (const_string \"maybe\")]\n-\t      (const_string \"false\")))\n+   (set_attr \"iscompact\" \"maybe\" )\n    (set (attr \"length\")\n-\t(cond [(ne (symbol_ref \"arc_compute_function_type (cfun)\")\n-\t\t   (symbol_ref \"ARC_FUNCTION_NORMAL\"))\n-\t       (const_int 4)\n-\t       (not (match_operand 0 \"equality_comparison_operator\" \"\"))\n+\t(cond [(not (match_operand 0 \"equality_comparison_operator\" \"\"))\n \t       (const_int 4)\n \t       (eq_attr \"delay_slot_filled\" \"yes\")\n \t       (const_int 4)]\n \t      (const_int 2)))])\n \n-;; ??? #ifdefs in function.c require the presence of this pattern, with a\n-;; non-constant predicate.\n+;; Return nonzero if this function is known to have a null epilogue.\n+;; This allows the optimizer to omit jumps to jumps if no stack\n+;; was created.\n (define_expand \"return\"\n   [(return)]\n-  \"optimize < 0\")\n+  \"arc_can_use_return_insn ()\"\n+  \"\")\n \n  ;; Comment in final.c (insn_current_reference_address) says\n  ;; forward branch addresses are calculated from the next insn after branch"}, {"sha": "f1c59d5e7bb7770a5fc18f0423a5c2bb17d103b1", "filename": "gcc/config/arc/builtins.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Fconfig%2Farc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Fconfig%2Farc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fbuiltins.def?ref=ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "patch": "@@ -33,7 +33,7 @@\n \n /* Special builtins.  */\n DEF_BUILTIN (NOP,        0, void_ftype_void,        nothing,     1)\n-DEF_BUILTIN (RTIE,       0, void_ftype_void,        rtie,        1)\n+DEF_BUILTIN (RTIE,       0, void_ftype_void,        rtie,        !TARGET_ARC600_FAMILY)\n DEF_BUILTIN (SYNC,       0, void_ftype_void,        sync,        1)\n DEF_BUILTIN (BRK,        0, void_ftype_void,        brk,         1)\n DEF_BUILTIN (SWI,        0, void_ftype_void,        swi,         1)"}, {"sha": "e0013b32f0f57e5d1a5ecada1bbec16d81c3904b", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "patch": "@@ -285,6 +285,8 @@\n \treturn GET_MODE (op) == SFmode;\n       return 0;\n     case REG :\n+      if (REGNO (op) == LP_COUNT)\n+\treturn 1;\n       return register_operand (op, mode);\n     case SUBREG :\n       /* (subreg (mem ...) ...) can occur here if the inner part was once a"}, {"sha": "621eda94bf00b73c571d25cb995ab3f9699467c4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "patch": "@@ -1,3 +1,13 @@\n+2019-07-24  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* gcc.target/arc/arc.exp (check_effective_target_accregs): New\n+\tpredicate.\n+\t* gcc.target/arc/builtin_special.c: Update test/\n+\t* gcc.target/arc/interrupt-1.c: Likewise.\n+\t* gcc.target/arc/interrupt-10.c: New test.\n+\t* gcc.target/arc/interrupt-11.c: Likewise.\n+\t* gcc.target/arc/interrupt-12.c: Likewise.\n+\n 2019-07-24  Andreas Krebbel  <krebbel@linux.ibm.com>\n \n \t* gcc.target/s390/addsub-signed-overflow-1.c: New test."}, {"sha": "55e12137a2aba94edcc168d43b5f3cb2b4e6f39b", "filename": "gcc/testsuite/gcc.target/arc/arc.exp", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Farc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Farc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Farc.exp?ref=ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "patch": "@@ -94,6 +94,24 @@ proc check_effective_target_barrelshifter { } {\n     }]\n }\n \n+#return 1 if we use ARCv2 Accumulator registers\n+proc check_effective_target_accregs { } {\n+    return [check_no_compiler_messages accregs assembly {\n+\t#if !defined(__ARC_MPY_DMPY__) \\\n+\t     && !defined(__ARC_MPY_MACD__) && !defined(__ARC_MPY_QMACW__)\n+\t#error No accumulator available for this config\n+\t#endif\n+    }]\n+}\n+\n+proc check_effective_target_dpfp { } {\n+    return [check_no_compiler_messages dpfp assembly {\n+\t#if !defined(__ARC_FPX_DP__) && !defined(__ARC_FPU_ASSIST__)\n+\t#error No FPX available for this config\n+\t#endif\n+    }]\n+}\n+\n # If a testcase doesn't have special options, use these.\n global DEFAULT_CFLAGS\n if ![info exists DEFAULT_CFLAGS] then {"}, {"sha": "829528ceb55f0b117e2195a0061842b63aa9eb4c", "filename": "gcc/testsuite/gcc.target/arc/builtin_special.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_special.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_special.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_special.c?ref=ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "patch": "@@ -21,7 +21,9 @@\n \n \n NORET (nop)\n+#if !defined (__ARC600__) && !defined (__ARC601__)\n NORET (rtie)\n+#endif\n \n #ifdef __A7__\n  NORET (sync)"}, {"sha": "5a5139a2470642ada5b8397e58e40a16d6212332", "filename": "gcc/testsuite/gcc.target/arc/interrupt-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-1.c?ref=ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "patch": "@@ -6,5 +6,5 @@ void __attribute__ ((interrupt(\"ilink1\")))\n handler1 (void)\n {\n }\n-/* { dg-final { scan-assembler-times \"j.*\\[ilink1\\]\" 1 { target { arc700 || arc6xx } } } } */\n-/* { dg-final { scan-assembler-times \"rtie\" 1 { target { arcem || archs } } } } */\n+/* { dg-final { scan-assembler-times \"j.*\\[ilink1\\]\" 1 { target { arc6xx } } } } */\n+/* { dg-final { scan-assembler-times \"rtie\" 1 { target { ! { arc6xx } } } } } */"}, {"sha": "605c19f5797058ae5a39f5db4e1517a50c811c12", "filename": "gcc/testsuite/gcc.target/arc/interrupt-10.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-10.c?ref=ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-options \"-O2\" } */\n+extern void will_trig_exception(void);\n+\n+#if defined (__ARCHS__) || defined (__ARCEM__)\n+__attribute__ ((interrupt(\"ilink\")))\n+#else\n+__attribute__ ((interrupt(\"ilink1\")))\n+#endif\n+void isr_0 (void)\n+{\n+  will_trig_exception();\n+}\n+\n+/* { dg-final { scan-assembler-times \"j.*\\[ilink1\\]\" 1 { target { arc6xx } } } } */\n+/* { dg-final { scan-assembler-times \"rtie\" 1 { target { ! { arc6xx } } } } } */\n+/* { dg-final { scan-assembler-times \"blink\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fp\" 2 { target { ! { archs } } } } } */\n+/* { dg-final { scan-assembler-times \"r30\" 2 { target { archs || arcem } } } } */\n+/* { dg-final { scan-assembler-times \"r24\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r22\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r20\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r18\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r16\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r14\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r12\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r10\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r8\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r6\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r4\" 2 } } */\n+/* { dg-final { scan-assembler-times \"r2\\[,\\n\\]\" 2 } } */\n+/* { dg-final { scan-assembler-times \"lp_count\" 2 } } */\n+/* { dg-final { scan-assembler-times \"sr\\\\s+r\\[0-9\\],\" 2 { target { ! { dpfp } } } } } */\n+/* { dg-final { scan-assembler-times \"lr\\\\s+r\\[0-9\\]\" 2 { target { ! { dpfp } } } } } */\n+/* { dg-final { scan-assembler-times \"sr\\\\s+r\\[0-9\\],\" 6 { target { dpfp } } } } */\n+/* { dg-final { scan-assembler-times \"lr\\\\s+r\\[0-9\\]\" 6 { target { dpfp } } } } */\n+/* { dg-final { scan-assembler-times \"r58\" 2 { target { accregs } } } } */"}, {"sha": "ca340ee7c74738b9f437552c3cd2c71da9769d17", "filename": "gcc/testsuite/gcc.target/arc/interrupt-11.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-11.c?ref=ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "patch": "@@ -0,0 +1,16 @@\n+extern int a;\n+\n+#if defined (__ARCHS__) || defined (__ARCEM__)\n+__attribute__ ((interrupt(\"ilink\")))\n+#else\n+__attribute__ ((interrupt(\"ilink2\")))\n+#endif\n+void isr_1 (void)\n+{\n+  a++;\n+}\n+\n+/* { dg-final { scan-assembler-times \"j.*\\[ilink2\\]\" 1 { target { arc6xx } } } } */\n+/* { dg-final { scan-assembler-times \"rtie\" 1 { target { ! { arc6xx } } } } } */\n+/* { dg-final { scan-assembler-times \"push_s\\\\s+r\\[0-9\\]\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pop_s\\\\s+r\\[0-9\\]\" 1 } } */"}, {"sha": "da3e26cf0bbeefc9d3582eb66463ea192c9c0b96", "filename": "gcc/testsuite/gcc.target/arc/interrupt-12.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce9dbf20f4e1394121d5d875e502731a9db4f7a1/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finterrupt-12.c?ref=ce9dbf20f4e1394121d5d875e502731a9db4f7a1", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-options \"-O0 -g\" } */\n+\n+typedef void (*isr_routine)(void);\n+isr_routine will_trig_exception;\n+\n+ #if defined (__ARCHS__) || defined (__ARCEM__)\n+void __attribute__ ((interrupt(\"ilink\")))\n+#else\n+void __attribute__ ((interrupt(\"ilink1\")))\n+#endif\n+isr_template(void)\n+{\n+  will_trig_exception();\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\\\\\.cfi_offset 0\" 1 } } */"}]}