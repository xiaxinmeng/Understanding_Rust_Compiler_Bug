{"sha": "4f0bee4c9ae0c361ea1cb8731d928e92f610f593", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYwYmVlNGM5YWUwYzM2MWVhMWNiODczMWQ5MjhlOTJmNjEwZjU5Mw==", "commit": {"author": {"name": "Wei Mi", "email": "wmi@google.com", "date": "2013-10-03T17:18:26Z"}, "committer": {"name": "Wei Mi", "email": "wmi@gcc.gnu.org", "date": "2013-10-03T17:18:26Z"}, "message": "lra-constraints.c (insert_move_for_subreg): New function extracted from simplify_operand_subreg.\n\n2013-10-03  Wei Mi  <wmi@google.com>\n\n        * lra-constraints.c (insert_move_for_subreg): New function\n        extracted from simplify_operand_subreg.\n        (simplify_operand_subreg): Add reload for paradoxical subreg.\n\nFrom-SVN: r203169", "tree": {"sha": "eadd2e38ae179f9e9bc0ca755469fa85a03613d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eadd2e38ae179f9e9bc0ca755469fa85a03613d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f0bee4c9ae0c361ea1cb8731d928e92f610f593", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f0bee4c9ae0c361ea1cb8731d928e92f610f593", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f0bee4c9ae0c361ea1cb8731d928e92f610f593", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f0bee4c9ae0c361ea1cb8731d928e92f610f593/comments", "author": {"login": "wmi-11", "id": 59629650, "node_id": "MDQ6VXNlcjU5NjI5NjUw", "avatar_url": "https://avatars.githubusercontent.com/u/59629650?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wmi-11", "html_url": "https://github.com/wmi-11", "followers_url": "https://api.github.com/users/wmi-11/followers", "following_url": "https://api.github.com/users/wmi-11/following{/other_user}", "gists_url": "https://api.github.com/users/wmi-11/gists{/gist_id}", "starred_url": "https://api.github.com/users/wmi-11/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wmi-11/subscriptions", "organizations_url": "https://api.github.com/users/wmi-11/orgs", "repos_url": "https://api.github.com/users/wmi-11/repos", "events_url": "https://api.github.com/users/wmi-11/events{/privacy}", "received_events_url": "https://api.github.com/users/wmi-11/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "111c3f39f58e7fd55f072243e6d8dc31987f0e45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/111c3f39f58e7fd55f072243e6d8dc31987f0e45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/111c3f39f58e7fd55f072243e6d8dc31987f0e45"}], "stats": {"total": 122, "additions": 105, "deletions": 17}, "files": [{"sha": "138d6c5cd6bc66da3c0d9618c1b6257132aed5ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f0bee4c9ae0c361ea1cb8731d928e92f610f593/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f0bee4c9ae0c361ea1cb8731d928e92f610f593/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f0bee4c9ae0c361ea1cb8731d928e92f610f593", "patch": "@@ -1,3 +1,9 @@\n+2013-10-03  Wei Mi  <wmi@google.com>\n+\n+\t* lra-constraints.c (insert_move_for_subreg): New function\n+\textracted from simplify_operand_subreg.\n+\t(simplify_operand_subreg): Add reload for paradoxical subreg.\n+\n 2013-10-03  Rong Xu  <xur@google.com>\n \n         * ipa-inline-analysis.c (find_foldable_builtin_expect): Find"}, {"sha": "e741dd60a73268f360da20a23decb3f8e27cd074", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 99, "deletions": 17, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f0bee4c9ae0c361ea1cb8731d928e92f610f593/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f0bee4c9ae0c361ea1cb8731d928e92f610f593/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=4f0bee4c9ae0c361ea1cb8731d928e92f610f593", "patch": "@@ -1158,6 +1158,30 @@ process_addr_reg (rtx *loc, rtx *before, rtx *after, enum reg_class cl)\n   return true;\n }\n \n+/* Insert move insn in simplify_operand_subreg. BEFORE returns\n+   the insn to be inserted before curr insn. AFTER returns the\n+   the insn to be inserted after curr insn.  ORIGREG and NEWREG\n+   are the original reg and new reg for reload.  */\n+static void\n+insert_move_for_subreg (rtx *before, rtx *after, rtx origreg, rtx newreg)\n+{\n+  if (before)\n+    {\n+      push_to_sequence (*before);\n+      lra_emit_move (newreg, origreg);\n+      *before = get_insns ();\n+      end_sequence ();\n+    }\n+  if (after)\n+    {\n+      start_sequence ();\n+      lra_emit_move (origreg, newreg);\n+      emit_insn (*after);\n+      *after = get_insns ();\n+      end_sequence ();\n+    }\n+}\n+\n /* Make reloads for subreg in operand NOP with internal subreg mode\n    REG_MODE, add new reloads for further processing.  Return true if\n    any reload was generated.  */\n@@ -1169,6 +1193,8 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)\n   enum machine_mode mode;\n   rtx reg, new_reg;\n   rtx operand = *curr_id->operand_loc[nop];\n+  enum reg_class regclass;\n+  enum op_type type;\n \n   before = after = NULL_RTX;\n \n@@ -1177,6 +1203,7 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)\n \n   mode = GET_MODE (operand);\n   reg = SUBREG_REG (operand);\n+  type = curr_static_id->operand[nop].type;\n   /* If we change address for paradoxical subreg of memory, the\n      address might violate the necessary alignment or the access might\n      be slow.  So take this into consideration.  We should not worry\n@@ -1221,37 +1248,92 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)\n        && ! LRA_SUBREG_P (operand))\n       || CONSTANT_P (reg) || GET_CODE (reg) == PLUS || MEM_P (reg))\n     {\n-      enum op_type type = curr_static_id->operand[nop].type;\n       /* The class will be defined later in curr_insn_transform.  */\n       enum reg_class rclass\n \t= (enum reg_class) targetm.preferred_reload_class (reg, ALL_REGS);\n \n       if (get_reload_reg (curr_static_id->operand[nop].type, reg_mode, reg,\n \t\t\t  rclass, \"subreg reg\", &new_reg))\n \t{\n+\t  bool insert_before, insert_after;\n \t  bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));\n-\t  if (type != OP_OUT\n-\t      || GET_MODE_SIZE (GET_MODE (reg)) > GET_MODE_SIZE (mode))\n-\t    {\n-\t      push_to_sequence (before);\n-\t      lra_emit_move (new_reg, reg);\n-\t      before = get_insns ();\n-\t      end_sequence ();\n-\t    }\n-\t  if (type != OP_IN)\n-\t    {\n-\t      start_sequence ();\n-\t      lra_emit_move (reg, new_reg);\n-\t      emit_insn (after);\n-\t      after = get_insns ();\n-\t      end_sequence ();\n-\t    }\n+\n+\t  insert_before = (type != OP_OUT\n+\t\t\t   || GET_MODE_SIZE (GET_MODE (reg)) > GET_MODE_SIZE (mode));\n+\t  insert_after = (type != OP_IN);\n+\t  insert_move_for_subreg (insert_before ? &before : NULL,\n+\t\t\t\t  insert_after ? &after : NULL,\n+\t\t\t\t  reg, new_reg);\n \t}\n       SUBREG_REG (operand) = new_reg;\n       lra_process_new_insns (curr_insn, before, after,\n \t\t\t     \"Inserting subreg reload\");\n       return true;\n     }\n+  /* Force a reload for a paradoxical subreg. For paradoxical subreg,\n+     IRA allocates hardreg to the inner pseudo reg according to its mode\n+     instead of the outermode, so the size of the hardreg may not be enough\n+     to contain the outermode operand, in that case we may need to insert\n+     reload for the reg. For the following two types of paradoxical subreg,\n+     we need to insert reload:\n+     1. If the op_type is OP_IN, and the hardreg could not be paired with\n+        other hardreg to contain the outermode operand\n+        (checked by in_hard_reg_set_p), we need to insert the reload.\n+     2. If the op_type is OP_OUT or OP_INOUT.\n+\n+     Here is a paradoxical subreg example showing how the reload is generated:\n+\n+     (insn 5 4 7 2 (set (reg:TI 106 [ __comp ])\n+        (subreg:TI (reg:DI 107 [ __comp ]) 0)) {*movti_internal_rex64}\n+\n+     In IRA, reg107 is allocated to a DImode hardreg. We use x86-64 as example\n+     here, if reg107 is assigned to hardreg R15, because R15 is the last\n+     hardreg, compiler cannot find another hardreg to pair with R15 to\n+     contain TImode data. So we insert a TImode reload reg180 for it.\n+     After reload is inserted:\n+\n+     (insn 283 0 0 (set (subreg:DI (reg:TI 180 [orig:107 __comp ] [107]) 0)\n+        (reg:DI 107 [ __comp ])) -1\n+     (insn 5 4 7 2 (set (reg:TI 106 [ __comp ])\n+        (subreg:TI (reg:TI 180 [orig:107 __comp ] [107]) 0)) {*movti_internal_rex64}\n+\n+     Two reload hard registers will be allocated to reg180 to save TImode data\n+     in LRA_assign.  */\n+  else if (REG_P (reg)\n+\t   && REGNO (reg) >= FIRST_PSEUDO_REGISTER\n+\t   && (hard_regno = lra_get_regno_hard_regno (REGNO (reg))) >= 0\n+\t   && (hard_regno_nregs[hard_regno][GET_MODE (reg)]\n+\t       < hard_regno_nregs[hard_regno][mode])\n+\t   && (regclass = lra_get_allocno_class (REGNO (reg)))\n+\t   && (type != OP_IN\n+\t       || !in_hard_reg_set_p (reg_class_contents[regclass],\n+\t\t\t\t      mode, hard_regno)))\n+    {\n+      /* The class will be defined later in curr_insn_transform.  */\n+      enum reg_class rclass\n+\t= (enum reg_class) targetm.preferred_reload_class (reg, ALL_REGS);\n+\n+      if (get_reload_reg (curr_static_id->operand[nop].type, mode, reg,\n+                          rclass, \"paradoxical subreg\", &new_reg))\n+        {\n+\t  rtx subreg;\n+\t  bool insert_before, insert_after;\n+\n+\t  PUT_MODE (new_reg, mode);\n+          subreg = simplify_gen_subreg (GET_MODE (reg), new_reg, mode, 0);\n+\t  bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));\n+\n+\t  insert_before = (type != OP_OUT);\n+\t  insert_after = (type != OP_IN);\n+\t  insert_move_for_subreg (insert_before ? &before : NULL,\n+\t\t\t\t  insert_after ? &after : NULL,\n+\t\t\t\t  reg, subreg);\n+\t}\n+      SUBREG_REG (operand) = new_reg;\n+      lra_process_new_insns (curr_insn, before, after,\n+                             \"Inserting paradoxical subreg reload\");\n+      return true;\n+    }\n   return false;\n }\n "}]}