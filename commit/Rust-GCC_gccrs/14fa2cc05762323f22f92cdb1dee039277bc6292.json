{"sha": "14fa2cc05762323f22f92cdb1dee039277bc6292", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRmYTJjYzA1NzYyMzIzZjIyZjkyY2RiMWRlZTAzOTI3N2JjNjI5Mg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-02-04T23:47:09Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-02-04T23:47:09Z"}, "message": "cfgloopmanip.c (loop_delete_branch_edge): Removed.\n\n\t* cfgloopmanip.c (loop_delete_branch_edge): Removed.\n\t(remove_path): Use can_remove_branch_p and remove_branch instead\n\tof loop_delete_branch_edge.\n\t* tree-ssa-loop-manip.c (scale_dominated_blocks_in_loop): New function.\n\t(tree_transform_and_unroll_loop): Remove dead branches immediately.\n\tUpdate profile using scale_dominated_blocks_in_loop.\n\t* cfghooks.c (can_remove_branch_p, remove_branch): New functions.\n\t* cfghooks.h (struct cfg_hooks): Add can_remove_branch_p.\n\t(can_remove_branch_p, remove_branch): Declare.\n\t* tree-cfg.c (tree_can_remove_branch_p): New function.\n\t(tree_cfg_hooks): Add tree_can_remove_branch_p.\n\t* cfgrtl.c (rtl_can_remove_branch_p): New function.\n\t(rtl_cfg_hooks, cfg_layout_rtl_cfg_hook): Add rtl_can_remove_branch_p.\n\nFrom-SVN: r121583", "tree": {"sha": "f496fa9bd8e7472a0092f253d2c670a09063973a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f496fa9bd8e7472a0092f253d2c670a09063973a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14fa2cc05762323f22f92cdb1dee039277bc6292", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14fa2cc05762323f22f92cdb1dee039277bc6292", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14fa2cc05762323f22f92cdb1dee039277bc6292", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14fa2cc05762323f22f92cdb1dee039277bc6292/comments", "author": null, "committer": null, "parents": [{"sha": "284893341f2086559700fe966ea86e8e1196f775", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/284893341f2086559700fe966ea86e8e1196f775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/284893341f2086559700fe966ea86e8e1196f775"}], "stats": {"total": 242, "additions": 180, "deletions": 62}, "files": [{"sha": "acb109e29ede526bf93a53a3b05d3f3345d5a2b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14fa2cc05762323f22f92cdb1dee039277bc6292", "patch": "@@ -1,3 +1,19 @@\n+2007-02-04  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* cfgloopmanip.c (loop_delete_branch_edge): Removed.\n+\t(remove_path): Use can_remove_branch_p and remove_branch instead\n+\tof loop_delete_branch_edge.\n+\t* tree-ssa-loop-manip.c (scale_dominated_blocks_in_loop): New function.\n+\t(tree_transform_and_unroll_loop): Remove dead branches immediately.\n+\tUpdate profile using scale_dominated_blocks_in_loop.\n+\t* cfghooks.c (can_remove_branch_p, remove_branch): New functions.\n+\t* cfghooks.h (struct cfg_hooks): Add can_remove_branch_p.\n+\t(can_remove_branch_p, remove_branch): Declare.\n+\t* tree-cfg.c (tree_can_remove_branch_p): New function.\n+\t(tree_cfg_hooks): Add tree_can_remove_branch_p.\n+\t* cfgrtl.c (rtl_can_remove_branch_p): New function.\n+\t(rtl_cfg_hooks, cfg_layout_rtl_cfg_hook): Add rtl_can_remove_branch_p.\n+\n 2007-02-05  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/30696"}, {"sha": "d65cce98fa9131ca1660232ba7948eb68eb66dee", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=14fa2cc05762323f22f92cdb1dee039277bc6292", "patch": "@@ -318,6 +318,48 @@ redirect_edge_and_branch (edge e, basic_block dest)\n   return ret;\n }\n \n+/* Returns true if it is possible to remove the edge E by redirecting it\n+   to the destination of the other edge going from its source.  */\n+\n+bool\n+can_remove_branch_p (edge e)\n+{\n+  if (!cfg_hooks->can_remove_branch_p)\n+    internal_error (\"%s does not support can_remove_branch_p\",\n+\t\t    cfg_hooks->name);\n+\n+  if (EDGE_COUNT (e->src->succs) != 2)\n+    return false;\n+\n+  return cfg_hooks->can_remove_branch_p (e);\n+}\n+\n+/* Removes E, by redirecting it to the destination of the other edge going\n+   from its source.  Can_remove_branch_p must be true for E, hence this\n+   operation cannot fail.  */\n+\n+void\n+remove_branch (edge e)\n+{\n+  edge other;\n+  basic_block src = e->src;\n+  int irr;\n+\n+  gcc_assert (EDGE_COUNT (e->src->succs) == 2);\n+\n+  other = EDGE_SUCC (src, EDGE_SUCC (src, 0) == e);\n+  irr = other->flags & EDGE_IRREDUCIBLE_LOOP;\n+\n+  if (current_loops != NULL)\n+    rescan_loop_exit (e, false, true);\n+\n+  e = redirect_edge_and_branch (e, other->dest);\n+  gcc_assert (e != NULL);\n+\n+  e->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n+  e->flags |= irr;\n+}\n+\n /* Redirect the edge E to basic block DEST even if it requires creating\n    of a new basic block; then it returns the newly created basic block.\n    Aborts when redirection is impossible.  */"}, {"sha": "bd7d1b3195a1e8008cdebc6c7162082aa8180f00", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=14fa2cc05762323f22f92cdb1dee039277bc6292", "patch": "@@ -47,6 +47,10 @@ struct cfg_hooks\n      not be abnormal.  */\n   basic_block (*redirect_edge_and_branch_force) (edge, basic_block);\n \n+  /* Returns true if it is possible to remove the edge by redirecting it\n+     to the destination of the other edge going from its source.  */\n+  bool (*can_remove_branch_p) (edge);\n+\n   /* Remove statements corresponding to a given basic block.  */\n   void (*delete_basic_block) (basic_block);\n \n@@ -138,6 +142,8 @@ extern void verify_flow_info (void);\n extern void dump_bb (basic_block, FILE *, int);\n extern edge redirect_edge_and_branch (edge, basic_block);\n extern basic_block redirect_edge_and_branch_force (edge, basic_block);\n+extern bool can_remove_branch_p (edge);\n+extern void remove_branch (edge);\n extern edge split_block (basic_block, void *);\n extern edge split_block_after_labels (basic_block);\n extern bool move_block_after (basic_block, basic_block);"}, {"sha": "8e5f4c2bf38fc4ad44dd5b6114b543359371aa78", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 3, "deletions": 44, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=14fa2cc05762323f22f92cdb1dee039277bc6292", "patch": "@@ -35,7 +35,6 @@ static void duplicate_subloops (struct loop *, struct loop *);\n static void copy_loops_to (struct loop **, int,\n \t\t\t   struct loop *);\n static void loop_redirect_edge (edge, basic_block);\n-static bool loop_delete_branch_edge (edge, int);\n static void remove_bbs (basic_block *, int);\n static bool rpe_enum_p (basic_block, void *);\n static int find_path (edge, basic_block **);\n@@ -283,10 +282,10 @@ remove_path (edge e)\n   basic_block *rem_bbs, *bord_bbs, *dom_bbs, from, bb;\n   int i, nrem, n_bord_bbs, n_dom_bbs, nreml;\n   sbitmap seen;\n-  bool deleted, irred_invalidated = false;\n+  bool irred_invalidated = false;\n   struct loop **deleted_loop;\n \n-  if (!loop_delete_branch_edge (e, 0))\n+  if (!can_remove_branch_p (e))\n     return false;\n \n   /* Keep track of whether we need to update information about irreducible\n@@ -341,8 +340,7 @@ remove_path (edge e)\n \n   /* Remove the path.  */\n   from = e->src;\n-  deleted = loop_delete_branch_edge (e, 1);\n-  gcc_assert (deleted);\n+  remove_branch (e);\n   dom_bbs = XCNEWVEC (basic_block, n_basic_blocks);\n \n   /* Cancel loops contained in the path.  */\n@@ -698,45 +696,6 @@ loop_redirect_edge (edge e, basic_block dest)\n   redirect_edge_and_branch_force (e, dest);\n }\n \n-/* Deletes edge E from a branch if possible.  Unless REALLY_DELETE is set,\n-   just test whether it is possible to remove the edge.  */\n-static bool\n-loop_delete_branch_edge (edge e, int really_delete)\n-{\n-  basic_block src = e->src;\n-  basic_block newdest;\n-  int irr;\n-  edge snd;\n-\n-  gcc_assert (EDGE_COUNT (src->succs) > 1);\n-\n-  /* Cannot handle more than two exit edges.  */\n-  if (EDGE_COUNT (src->succs) > 2)\n-    return false;\n-  /* And it must be just a simple branch.  */\n-  if (!any_condjump_p (BB_END (src)))\n-    return false;\n-\n-  snd = e == EDGE_SUCC (src, 0) ? EDGE_SUCC (src, 1) : EDGE_SUCC (src, 0);\n-  newdest = snd->dest;\n-  if (newdest == EXIT_BLOCK_PTR)\n-    return false;\n-\n-  /* Hopefully the above conditions should suffice.  */\n-  if (!really_delete)\n-    return true;\n-\n-  /* Redirecting behaves wrongly wrto this flag.  */\n-  irr = snd->flags & EDGE_IRREDUCIBLE_LOOP;\n-\n-  if (!redirect_edge_and_branch (e, newdest))\n-    return false;\n-  single_succ_edge (src)->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n-  single_succ_edge (src)->flags |= irr;\n-\n-  return true;\n-}\n-\n /* Check whether LOOP's body can be duplicated.  */\n bool\n can_duplicate_loop_p (struct loop *loop)"}, {"sha": "1eb75abe6d20b73a86a0cfc36d8d37c7d28e93d0", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=14fa2cc05762323f22f92cdb1dee039277bc6292", "patch": "@@ -2977,6 +2977,38 @@ insert_insn_end_bb_new (rtx pat, basic_block bb)\n   return new_insn;\n }\n \n+/* Returns true if it is possible to remove edge E by redirecting\n+   it to the destination of the other edge from E->src.  */\n+\n+static bool\n+rtl_can_remove_branch_p (edge e)\n+{\n+  basic_block src = e->src;\n+  basic_block target = EDGE_SUCC (src, EDGE_SUCC (src, 0) == e)->dest;\n+  rtx insn = BB_END (src), set;\n+\n+  /* The conditions are taken from try_redirect_by_replacing_jump.  */\n+  if (target == EXIT_BLOCK_PTR)\n+    return false;\n+\n+  if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n+    return false;\n+\n+  if (find_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX)\n+      || BB_PARTITION (src) != BB_PARTITION (target))\n+    return false;\n+\n+  if (!onlyjump_p (insn)\n+      || tablejump_p (insn, NULL, NULL))\n+    return false;\n+\n+  set = single_set (insn);\n+  if (!set || side_effects_p (set))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Implementation of CFG manipulation for linearized RTL.  */\n struct cfg_hooks rtl_cfg_hooks = {\n   \"rtl\",\n@@ -2985,6 +3017,7 @@ struct cfg_hooks rtl_cfg_hooks = {\n   rtl_create_basic_block,\n   rtl_redirect_edge_and_branch,\n   rtl_redirect_edge_and_branch_force,\n+  rtl_can_remove_branch_p,\n   rtl_delete_block,\n   rtl_split_block,\n   rtl_move_block_after,\n@@ -3028,6 +3061,7 @@ struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n   cfg_layout_create_basic_block,\n   cfg_layout_redirect_edge_and_branch,\n   cfg_layout_redirect_edge_and_branch_force,\n+  rtl_can_remove_branch_p,\n   cfg_layout_delete_block,\n   cfg_layout_split_block,\n   rtl_move_block_after,"}, {"sha": "6f4920525015b302201988bd924d578d2b7587b1", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=14fa2cc05762323f22f92cdb1dee039277bc6292", "patch": "@@ -4219,6 +4219,17 @@ tree_redirect_edge_and_branch (edge e, basic_block dest)\n   return e;\n }\n \n+/* Returns true if it is possible to remove edge E by redirecting\n+   it to the destination of the other edge from E->src.  */\n+\n+static bool\n+tree_can_remove_branch_p (edge e)\n+{\n+  if (e->flags & EDGE_ABNORMAL)\n+    return false;\n+\n+  return true;\n+}\n \n /* Simple wrapper, as we can always redirect fallthru edges.  */\n \n@@ -5614,6 +5625,7 @@ struct cfg_hooks tree_cfg_hooks = {\n   create_bb,\t\t\t/* create_basic_block  */\n   tree_redirect_edge_and_branch,/* redirect_edge_and_branch  */\n   tree_redirect_edge_and_branch_force,/* redirect_edge_and_branch_force  */\n+  tree_can_remove_branch_p,\t/* can_remove_branch_p  */\n   remove_bb,\t\t\t/* delete_basic_block  */\n   tree_split_block,\t\t/* split_block  */\n   tree_move_block_after,\t/* move_block_after  */"}, {"sha": "6b220e9d3e669de6155b46d8564086a1033c3b70", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 67, "deletions": 18, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14fa2cc05762323f22f92cdb1dee039277bc6292/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=14fa2cc05762323f22f92cdb1dee039277bc6292", "patch": "@@ -756,6 +756,29 @@ determine_exit_conditions (struct loop *loop, struct tree_niter_desc *desc,\n   *exit_bound = bound;\n }\n \n+/* Scales the frequencies of all basic blocks in LOOP that are strictly\n+   dominated by BB by NUM/DEN.  */\n+\n+static void\n+scale_dominated_blocks_in_loop (struct loop *loop, basic_block bb,\n+\t\t\t\tint num, int den)\n+{\n+  basic_block son;\n+\n+  if (den == 0)\n+    return;\n+\n+  for (son = first_dom_son (CDI_DOMINATORS, bb);\n+       son;\n+       son = next_dom_son (CDI_DOMINATORS, son))\n+    {\n+      if (!flow_bb_inside_loop_p (loop, son))\n+\tcontinue;\n+      scale_bbs_frequencies_int (&son, 1, num, den);\n+      scale_dominated_blocks_in_loop (loop, son, num, den);\n+    }\n+}\n+\n /* Unroll LOOP FACTOR times.  DESC describes number of iterations of LOOP.\n    EXIT is the exit of the loop to that DESC corresponds.\n \n@@ -819,21 +842,22 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n \t\t\t\ttransform_callback transform,\n \t\t\t\tvoid *data)\n {\n-  tree dont_exit, exit_if, ctr_before, ctr_after;\n+  tree  exit_if, ctr_before, ctr_after;\n   tree enter_main_cond, exit_base, exit_step, exit_bound;\n   enum tree_code exit_cmp;\n   tree phi_old_loop, phi_new_loop, phi_rest, init, next, new_init, var;\n   struct loop *new_loop;\n   basic_block rest, exit_bb;\n   edge old_entry, new_entry, old_latch, precond_edge, new_exit;\n-  edge new_nonexit;\n+  edge new_nonexit, e;\n   block_stmt_iterator bsi;\n   use_operand_p op;\n   bool ok;\n   unsigned est_niter, prob_entry, scale_unrolled, scale_rest, freq_e, freq_h;\n-  unsigned new_est_niter;\n+  unsigned new_est_niter, i, prob;\n   unsigned irr = loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP;\n   sbitmap wont_exit;\n+  VEC (edge, heap) *to_remove = NULL;\n \n   est_niter = expected_loop_iterations (loop);\n   determine_exit_conditions (loop, desc, factor,\n@@ -882,25 +906,41 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n \tnew_est_niter = 5;\n     }\n \n-  /* Prepare the cfg and update the phi nodes.  */\n+  /* Prepare the cfg and update the phi nodes.  Move the loop exit to the\n+     loop latch (and make its condition dummy, for the moment).  */\n   rest = loop_preheader_edge (new_loop)->src;\n   precond_edge = single_pred_edge (rest);\n   split_edge (loop_latch_edge (loop));\n   exit_bb = single_pred (loop->latch);\n \n-  /* For the moment, make it appear that the new exit edge cannot\n-     be taken.  */\n+  /* Since the exit edge will be removed, the frequency of all the blocks\n+     in the loop that are dominated by it must be scaled by\n+     1 / (1 - exit->probability).  */\n+  scale_dominated_blocks_in_loop (loop, exit->src,\n+\t\t\t\t  REG_BR_PROB_BASE,\n+\t\t\t\t  REG_BR_PROB_BASE - exit->probability);\n+\n   bsi = bsi_last (exit_bb);\n   exit_if = build_if_stmt (boolean_true_node,\n \t\t\t   tree_block_label (loop->latch),\n \t\t\t   tree_block_label (rest));\n   bsi_insert_after (&bsi, exit_if, BSI_NEW_STMT);\n   new_exit = make_edge (exit_bb, rest, EDGE_FALSE_VALUE | irr);\n   rescan_loop_exit (new_exit, true, false);\n-  new_exit->count = 0;\n-  new_exit->probability = 0;\n+\n+  /* Set the probability of new exit to the same of the old one.  Fix\n+     the frequency of the latch block, by scaling it back by\n+     1 - exit->probability.  */\n+  new_exit->count = exit->count;\n+  new_exit->probability = exit->probability;\n   new_nonexit = single_pred_edge (loop->latch);\n+  new_nonexit->probability = REG_BR_PROB_BASE - exit->probability;\n   new_nonexit->flags = EDGE_TRUE_VALUE;\n+  new_nonexit->count -= exit->count;\n+  if (new_nonexit->count < 0)\n+    new_nonexit->count = 0;\n+  scale_bbs_frequencies_int (&loop->latch, 1, new_nonexit->probability,\n+\t\t\t     REG_BR_PROB_BASE);\n \n   old_entry = loop_preheader_edge (loop);\n   new_entry = loop_preheader_edge (new_loop);\n@@ -938,25 +978,30 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n       SET_USE (op, new_init);\n     }\n \n+  remove_path (exit);\n+\n   /* Transform the loop.  */\n   if (transform)\n     (*transform) (loop, data);\n \n-  /* Unroll the loop and remove the old exits.  */\n-  dont_exit = ((exit->flags & EDGE_TRUE_VALUE)\n-\t       ? boolean_false_node\n-\t       : boolean_true_node);\n-  exit_if = last_stmt (exit->src);\n-  COND_EXPR_COND (exit_if) = dont_exit;\n-  update_stmt (exit_if);\n-      \n+  /* Unroll the loop and remove the exits in all iterations except for the\n+     last one.  */\n   wont_exit = sbitmap_alloc (factor);\n   sbitmap_ones (wont_exit);\n+  RESET_BIT (wont_exit, factor - 1);\n+\n   ok = tree_duplicate_loop_to_header_edge\n \t  (loop, loop_latch_edge (loop), factor - 1,\n-\t   wont_exit, exit, NULL, DLTHE_FLAG_UPDATE_FREQ);\n+\t   wont_exit, new_exit, &to_remove, DLTHE_FLAG_UPDATE_FREQ);\n   free (wont_exit);\n   gcc_assert (ok);\n+\n+  for (i = 0; VEC_iterate (edge, to_remove, i, e); i++)\n+    {\n+      ok = remove_path (e);\n+      gcc_assert (ok);\n+    }\n+  VEC_free (edge, heap, to_remove);\n   update_ssa (TODO_update_ssa);\n \n   /* Ensure that the frequencies in the loop match the new estimated\n@@ -976,9 +1021,13 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   rest->frequency += EDGE_FREQUENCY (new_exit);\n \n   new_nonexit = single_pred_edge (loop->latch);\n+  prob = new_nonexit->probability;\n   new_nonexit->probability = REG_BR_PROB_BASE - new_exit->probability;\n+  new_nonexit->count = exit_bb->count - new_exit->count;\n+  if (new_nonexit->count < 0)\n+    new_nonexit->count = 0;\n   scale_bbs_frequencies_int (&loop->latch, 1, new_nonexit->probability,\n-\t\t\t     REG_BR_PROB_BASE);\n+\t\t\t     prob);\n \n   /* Finally create the new counter for number of iterations and add the new\n      exit instruction.  */"}]}