{"sha": "aef0e7a8c2a0fc93efb26c35babc92b4d8614c45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVmMGU3YThjMmEwZmM5M2VmYjI2YzM1YmFiYzkyYjRkODYxNGM0NQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-07-15T13:20:10Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-07-15T13:20:10Z"}, "message": "revert: re PR rtl-optimization/11320 (Scheduler bug)\n\n\tRevert\n\t2003-07-10  Eric Botcazou  <ebotcazou@libertysurf.fr>\n\tPR rtl-optimization/11320\n\t* sched-int.h (struct deps) [reg_conditional_sets]: New field.\n\t(struct sched_info) [compute_jump_reg_dependencies]: New prototype.\n\t* sched-deps.c (sched_analyze_insn) [JUMP_INSN]: Update call to\n\tcurrent_sched_info->compute_jump_reg_dependencies. Record which\n\tregisters are used and which registers are set by the jump.\n\tClear deps->reg_conditional_sets after a barrier.\n\tSet deps->reg_conditional_sets if the insn is a COND_EXEC.\n\tClear deps->reg_conditional_sets if the insn is not a COND_EXEC.\n\t(init_deps): Initialize reg_conditional_sets.\n\t(free_deps): Clear reg_conditional_sets.\n\t* sched-ebb.c (compute_jump_reg_dependencies): New prototype.\n\tMark registers live on entry of the fallthrough block and conditionally\n\tset as set by the jump. Mark registers live on entry of non-fallthrough\n\tblocks as used by the jump.\n\t* sched-rgn.c (compute_jump_reg_dependencies): New prototype.\n\tMark new parameters as unused.\n\nFrom-SVN: r176315", "tree": {"sha": "0bb9cddf8c35822d3cea46f03f9830031fecd1a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bb9cddf8c35822d3cea46f03f9830031fecd1a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45/comments", "author": null, "committer": null, "parents": [{"sha": "ce6e60b2a4e275812c7ffe2fb0f2adb98f4b6677", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce6e60b2a4e275812c7ffe2fb0f2adb98f4b6677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce6e60b2a4e275812c7ffe2fb0f2adb98f4b6677"}], "stats": {"total": 91, "additions": 40, "deletions": 51}, "files": [{"sha": "f321c8d30aa8cbef68e21bed500dcdb8f1418814", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aef0e7a8c2a0fc93efb26c35babc92b4d8614c45", "patch": "@@ -49,6 +49,26 @@\n \t* config/c6x/eqf.c: New file.\n \t* config/c6x/libgcc-c6xeabi.ver: New file.\n \n+\tRevert\n+\t2003-07-10  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\tPR rtl-optimization/11320\n+\t* sched-int.h (struct deps) [reg_conditional_sets]: New field.\n+\t(struct sched_info) [compute_jump_reg_dependencies]: New prototype.\n+\t* sched-deps.c (sched_analyze_insn) [JUMP_INSN]: Update call to\n+\tcurrent_sched_info->compute_jump_reg_dependencies. Record which\n+\tregisters are used and which registers are set by the jump.\n+\tClear deps->reg_conditional_sets after a barrier.\n+\tSet deps->reg_conditional_sets if the insn is a COND_EXEC.\n+\tClear deps->reg_conditional_sets if the insn is not a COND_EXEC.\n+\t(init_deps): Initialize reg_conditional_sets.\n+\t(free_deps): Clear reg_conditional_sets.\n+\t* sched-ebb.c (compute_jump_reg_dependencies): New prototype.\n+\tMark registers live on entry of the fallthrough block and conditionally\n+\tset as set by the jump. Mark registers live on entry of non-fallthrough\n+\tblocks as used by the jump.\n+\t* sched-rgn.c (compute_jump_reg_dependencies): New prototype.\n+\tMark new parameters as unused.\n+\n 2011-07-14  Andrew Pinski  <pinskia@gmail.com>\n \n \tPR tree-opt/49309"}, {"sha": "668aa22cafaf0b722851a501ad3a0593703d9b5a", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=aef0e7a8c2a0fc93efb26c35babc92b4d8614c45", "patch": "@@ -252,9 +252,7 @@ sms_print_insn (const_rtx insn, int aligned ATTRIBUTE_UNUSED)\n \n static void\n compute_jump_reg_dependencies (rtx insn ATTRIBUTE_UNUSED,\n-\t\t\t       regset cond_exec ATTRIBUTE_UNUSED,\n-\t\t\t       regset used ATTRIBUTE_UNUSED,\n-\t\t\t       regset set ATTRIBUTE_UNUSED)\n+\t\t\t       regset used ATTRIBUTE_UNUSED)\n {\n }\n "}, {"sha": "ba4f1bb36e66fa495de30a22afeff9ffdda55cd2", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=aef0e7a8c2a0fc93efb26c35babc92b4d8614c45", "patch": "@@ -579,7 +579,7 @@ conditions_mutex_p (const_rtx cond1, const_rtx cond2, bool rev1, bool rev2)\n \t  (rev1==rev2\n \t  ? reversed_comparison_code (cond2, NULL)\n \t  : GET_CODE (cond2))\n-      && XEXP (cond1, 0) == XEXP (cond2, 0)\n+      && rtx_equal_p (XEXP (cond1, 0), XEXP (cond2, 0))\n       && XEXP (cond1, 1) == XEXP (cond2, 1))\n     return 1;\n   return 0;\n@@ -2751,14 +2751,13 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n \n           if (sched_deps_info->compute_jump_reg_dependencies)\n             {\n-              regset_head tmp_uses, tmp_sets;\n-              INIT_REG_SET (&tmp_uses);\n-              INIT_REG_SET (&tmp_sets);\n+              regset_head tmp;\n+              INIT_REG_SET (&tmp);\n+\n+              (*sched_deps_info->compute_jump_reg_dependencies) (insn, &tmp);\n \n-              (*sched_deps_info->compute_jump_reg_dependencies)\n-                (insn, &deps->reg_conditional_sets, &tmp_uses, &tmp_sets);\n               /* Make latency of jump equal to 0 by using anti-dependence.  */\n-              EXECUTE_IF_SET_IN_REG_SET (&tmp_uses, 0, i, rsi)\n+              EXECUTE_IF_SET_IN_REG_SET (&tmp, 0, i, rsi)\n                 {\n                   struct deps_reg *reg_last = &deps->reg_last[i];\n                   add_dependence_list (insn, reg_last->sets, 0, REG_DEP_ANTI);\n@@ -2773,10 +2772,8 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n                       reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n                     }\n                 }\n-              IOR_REG_SET (reg_pending_sets, &tmp_sets);\n \n-              CLEAR_REG_SET (&tmp_uses);\n-              CLEAR_REG_SET (&tmp_sets);\n+              CLEAR_REG_SET (&tmp);\n             }\n \n \t  /* All memory writes and volatile reads must happen before the\n@@ -2949,10 +2946,7 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n \t      add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);\n \n \t      if (!deps->readonly)\n-\t\t{\n-\t\t  reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n-\t\t  SET_REGNO_REG_SET (&deps->reg_conditional_sets, i);\n-\t\t}\n+\t\treg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n \t    }\n \t}\n       else\n@@ -3014,7 +3008,6 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n \t\t  reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n \t\t  reg_last->uses_length = 0;\n \t\t  reg_last->clobbers_length = 0;\n-\t\t  CLEAR_REGNO_REG_SET (&deps->reg_conditional_sets, i);\n \t\t}\n \t    }\n \t}\n@@ -3112,8 +3105,6 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n                              && sel_insn_is_speculation_check (insn)))\n \tflush_pending_lists (deps, insn, true, true);\n \n-      if (!deps->readonly)\n-        CLEAR_REG_SET (&deps->reg_conditional_sets);\n       reg_pending_barrier = NOT_A_BARRIER;\n     }\n \n@@ -3555,7 +3546,6 @@ init_deps (struct deps_desc *deps, bool lazy_reg_last)\n   else\n     deps->reg_last = XCNEWVEC (struct deps_reg, max_reg);\n   INIT_REG_SET (&deps->reg_last_in_use);\n-  INIT_REG_SET (&deps->reg_conditional_sets);\n \n   deps->pending_read_insns = 0;\n   deps->pending_read_mems = 0;\n@@ -3624,7 +3614,6 @@ free_deps (struct deps_desc *deps)\n \tfree_INSN_LIST_list (&reg_last->clobbers);\n     }\n   CLEAR_REG_SET (&deps->reg_last_in_use);\n-  CLEAR_REG_SET (&deps->reg_conditional_sets);\n \n   /* As we initialize reg_last lazily, it is possible that we didn't allocate\n      it at all.  */\n@@ -3634,8 +3623,7 @@ free_deps (struct deps_desc *deps)\n   deps = NULL;\n }\n \n-/* Remove INSN from dependence contexts DEPS.  Caution: reg_conditional_sets\n-   is not handled.  */\n+/* Remove INSN from dependence contexts DEPS.  */\n void\n remove_from_deps (struct deps_desc *deps, rtx insn)\n {"}, {"sha": "726c7c62511271cc948aa5f6c04be83fc0216217", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=aef0e7a8c2a0fc93efb26c35babc92b4d8614c45", "patch": "@@ -257,28 +257,18 @@ ebb_contributes_to_priority (rtx next ATTRIBUTE_UNUSED,\n   return 1;\n }\n \n- /* INSN is a JUMP_INSN, COND_SET is the set of registers that are\n-    conditionally set before INSN.  Store the set of registers that\n-    must be considered as used by this jump in USED and that of\n-    registers that must be considered as set in SET.  */\n+ /* INSN is a JUMP_INSN.  Store the set of registers that\n+    must be considered as used by this jump in USED.  */\n \n void\n-ebb_compute_jump_reg_dependencies (rtx insn, regset cond_set, regset used,\n-\t\t\t\t   regset set)\n+ebb_compute_jump_reg_dependencies (rtx insn, regset used)\n {\n   basic_block b = BLOCK_FOR_INSN (insn);\n   edge e;\n   edge_iterator ei;\n \n   FOR_EACH_EDGE (e, ei, b->succs)\n-    if (e->flags & EDGE_FALLTHRU)\n-      /* The jump may be a by-product of a branch that has been merged\n-\t in the main codepath after being conditionalized.  Therefore\n-\t it may guard the fallthrough block from using a value that has\n-\t conditionally overwritten that of the main codepath.  So we\n-\t consider that it restores the value of the main codepath.  */\n-      bitmap_and (set, df_get_live_in (e->dest), cond_set);\n-    else\n+    if ((e->flags & EDGE_FALLTHRU) == 0)\n       bitmap_ior_into (used, df_get_live_in (e->dest));\n }\n "}, {"sha": "2eee49d90bbc3db84d6c2cac5fb0af056e6a3591", "filename": "gcc/sched-int.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=aef0e7a8c2a0fc93efb26c35babc92b4d8614c45", "patch": "@@ -173,7 +173,7 @@ extern struct ready_list ready;\n \n extern int max_issue (struct ready_list *, int, state_t, bool, int *);\n \n-extern void ebb_compute_jump_reg_dependencies (rtx, regset, regset, regset);\n+extern void ebb_compute_jump_reg_dependencies (rtx, regset);\n \n extern edge find_fallthru_edge_from (basic_block);\n \n@@ -517,9 +517,6 @@ struct deps_desc\n      in reg_last[N].{uses,sets,clobbers}.  */\n   regset_head reg_last_in_use;\n \n-  /* Element N is set for each register that is conditionally set.  */\n-  regset_head reg_conditional_sets;\n-\n   /* Shows the last value of reg_pending_barrier associated with the insn.  */\n   enum reg_pending_barrier_mode last_reg_pending_barrier;\n \n@@ -1147,7 +1144,7 @@ struct sched_deps_info_def\n   /* Called when computing dependencies for a JUMP_INSN.  This function\n      should store the set of registers that must be considered as set by\n      the jump in the regset.  */\n-  void (*compute_jump_reg_dependencies) (rtx, regset, regset, regset);\n+  void (*compute_jump_reg_dependencies) (rtx, regset);\n \n   /* Start analyzing insn.  */\n   void (*start_insn) (rtx);"}, {"sha": "9208ef28ae651aa5ed84911f05f9c4d96fa41e4a", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef0e7a8c2a0fc93efb26c35babc92b4d8614c45/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=aef0e7a8c2a0fc93efb26c35babc92b4d8614c45", "patch": "@@ -2062,7 +2062,7 @@ static ds_t new_ready (rtx, ds_t);\n static int schedule_more_p (void);\n static const char *rgn_print_insn (const_rtx, int);\n static int rgn_rank (rtx, rtx);\n-static void compute_jump_reg_dependencies (rtx, regset, regset, regset);\n+static void compute_jump_reg_dependencies (rtx, regset);\n \n /* Functions for speculative scheduling.  */\n static void rgn_add_remove_insn (rtx, int);\n@@ -2295,16 +2295,12 @@ contributes_to_priority (rtx next, rtx insn)\n   return BLOCK_TO_BB (BLOCK_NUM (next)) == BLOCK_TO_BB (BLOCK_NUM (insn));\n }\n \n-/* INSN is a JUMP_INSN, COND_SET is the set of registers that are\n-   conditionally set before INSN.  Store the set of registers that\n-   must be considered as used by this jump in USED and that of\n-   registers that must be considered as set in SET.  */\n+/* INSN is a JUMP_INSN.  Store the set of registers that must be\n+   considered as used by this jump in USED.  */\n \n static void\n compute_jump_reg_dependencies (rtx insn ATTRIBUTE_UNUSED,\n-\t\t\t       regset cond_exec ATTRIBUTE_UNUSED,\n-\t\t\t       regset used ATTRIBUTE_UNUSED,\n-\t\t\t       regset set ATTRIBUTE_UNUSED)\n+\t\t\t       regset used ATTRIBUTE_UNUSED)\n {\n   /* Nothing to do here, since we postprocess jumps in\n      add_branch_dependences.  */"}]}