{"sha": "c57173b69a617edf59ed2e73edda183e7aebf05e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU3MTczYjY5YTYxN2VkZjU5ZWQyZTczZWRkYTE4M2U3YWViZjA1ZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2015-09-30T21:29:00Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2015-09-30T21:29:00Z"}, "message": "[RS6000] Correct powerpc sysv stack argument accounting\n\nppc32 starts using the stack for integer arg passing when we run out\nof integer arg passing registers.  Similarly, we start using the stack\nfor floating point args when we run out of floating point registers.\nThe decision on where an integer arg goes does not depend on number of\nfloating point args, nor does the decision on where a floating point\narg goes depend on number of integer args.  Alignment of stack args\nalso simply depends on number of stack args.\n\nThis patch untangles the horrible mess we had, with intarg_count being\nwrongly used to count both integer args and stack words.\n\n\t* src/powerpc/ffi_sysv.c (ffi_prep_cif_sysv_core): Count fprs,\n\tgprs, and stack words separately.\n\t(ffi_prep_args_SYSV): Similarly.\n\nFrom-SVN: r228307", "tree": {"sha": "b1481d30acc84a559f73b046251009c89d487ef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1481d30acc84a559f73b046251009c89d487ef3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c57173b69a617edf59ed2e73edda183e7aebf05e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c57173b69a617edf59ed2e73edda183e7aebf05e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c57173b69a617edf59ed2e73edda183e7aebf05e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c57173b69a617edf59ed2e73edda183e7aebf05e/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d64f8dd280e6d2d70aec5b133e913b1af51832d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d64f8dd280e6d2d70aec5b133e913b1af51832d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d64f8dd280e6d2d70aec5b133e913b1af51832d9"}], "stats": {"total": 213, "additions": 104, "deletions": 109}, "files": [{"sha": "c7ade43d0d09d0ea602f9fa48769179005a6ebd8", "filename": "libffi/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c57173b69a617edf59ed2e73edda183e7aebf05e/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c57173b69a617edf59ed2e73edda183e7aebf05e/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=c57173b69a617edf59ed2e73edda183e7aebf05e", "patch": "@@ -1,3 +1,9 @@\n+2015-10-01  Alan Modra  <amodra@gmail.com>\n+\n+\t* src/powerpc/ffi_sysv.c (ffi_prep_cif_sysv_core): Count fprs,\n+\tgprs, and stack words separately.\n+\t(ffi_prep_args_SYSV): Similarly.\n+\n 2015-05-13  Michael Haubenwallner  <michael.haubenwallner@ssi-schaefer.com>\n \n \t* Makefile.in: Regenerated with automake-1.11.6."}, {"sha": "4078e7511629dd25eb18c74a800ba82db3c43340", "filename": "libffi/src/powerpc/ffi_sysv.c", "status": "modified", "additions": 98, "deletions": 109, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c57173b69a617edf59ed2e73edda183e7aebf05e/libffi%2Fsrc%2Fpowerpc%2Fffi_sysv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c57173b69a617edf59ed2e73edda183e7aebf05e/libffi%2Fsrc%2Fpowerpc%2Fffi_sysv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_sysv.c?ref=c57173b69a617edf59ed2e73edda183e7aebf05e", "patch": "@@ -93,7 +93,7 @@ ffi_prep_cif_sysv_core (ffi_cif *cif)\n {\n   ffi_type **ptr;\n   unsigned bytes;\n-  unsigned i, fparg_count = 0, intarg_count = 0;\n+  unsigned i, fpr_count = 0, gpr_count = 0, stack_count = 0;\n   unsigned flags = cif->flags;\n   unsigned struct_copy_size = 0;\n   unsigned type = cif->rtype->type;\n@@ -155,7 +155,7 @@ ffi_prep_cif_sysv_core (ffi_cif *cif)\n \t  flags |= FLAG_RETURNS_SMST;\n \t  break;\n \t}\n-      intarg_count++;\n+      gpr_count++;\n       flags |= FLAG_RETVAL_REFERENCE;\n       /* Fall through.  */\n     case FFI_TYPE_VOID:\n@@ -182,24 +182,41 @@ ffi_prep_cif_sysv_core (ffi_cif *cif)\n \t{\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcase FFI_TYPE_LONGDOUBLE:\n-\t  fparg_count++;\n-\t  /* Fall thru */\n+\t  if (fpr_count >= NUM_FPR_ARG_REGISTERS - 1)\n+\t    {\n+\t      fpr_count = NUM_FPR_ARG_REGISTERS;\n+\t      /* 8-byte align long doubles.  */\n+\t      stack_count += stack_count & 1;\n+\t      stack_count += 4;\n+\t    }\n+\t  else\n+\t    fpr_count += 2;\n+#ifdef __NO_FPRS__\n+\t  return FFI_BAD_ABI;\n #endif\n+\t  break;\n+#endif\n+\n \tcase FFI_TYPE_DOUBLE:\n-\t  fparg_count++;\n-\t  /* If this FP arg is going on the stack, it must be\n-\t     8-byte-aligned.  */\n-\t  if (fparg_count > NUM_FPR_ARG_REGISTERS\n-\t      && intarg_count >= NUM_GPR_ARG_REGISTERS\n-\t      && intarg_count % 2 != 0)\n-\t    intarg_count++;\n+\t  if (fpr_count >= NUM_FPR_ARG_REGISTERS)\n+\t    {\n+\t      /* 8-byte align doubles.  */\n+\t      stack_count += stack_count & 1;\n+\t      stack_count += 2;\n+\t    }\n+\t  else\n+\t    fpr_count += 1;\n #ifdef __NO_FPRS__\n \t  return FFI_BAD_ABI;\n #endif\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n-\t  fparg_count++;\n+\t  if (fpr_count >= NUM_FPR_ARG_REGISTERS)\n+\t    /* Yes, we don't follow the ABI, but neither does gcc.  */\n+\t    stack_count += 1;\n+\t  else\n+\t    fpr_count += 1;\n #ifdef __NO_FPRS__\n \t  return FFI_BAD_ABI;\n #endif\n@@ -208,11 +225,13 @@ ffi_prep_cif_sysv_core (ffi_cif *cif)\n \tcase FFI_TYPE_UINT128:\n \t  /* A long double in FFI_LINUX_SOFT_FLOAT can use only a set\n \t     of four consecutive gprs. If we do not have enough, we\n-\t     have to adjust the intarg_count value.  */\n-\t  if (intarg_count >= NUM_GPR_ARG_REGISTERS - 3\n-\t      && intarg_count < NUM_GPR_ARG_REGISTERS)\n-\t    intarg_count = NUM_GPR_ARG_REGISTERS;\n-\t  intarg_count += 4;\n+\t     have to adjust the gpr_count value.  */\n+\t  if (gpr_count >= NUM_GPR_ARG_REGISTERS - 3)\n+\t    gpr_count = NUM_GPR_ARG_REGISTERS;\n+\t  if (gpr_count >= NUM_GPR_ARG_REGISTERS)\n+\t    stack_count += 4;\n+\t  else\n+\t    gpr_count += 4;\n \t  break;\n \n \tcase FFI_TYPE_UINT64:\n@@ -225,10 +244,14 @@ ffi_prep_cif_sysv_core (ffi_cif *cif)\n \t     Also, only certain register pairs can be used for\n \t     passing long long int -- specifically (r3,r4), (r5,r6),\n \t     (r7,r8), (r9,r10).  */\n-\t  if (intarg_count == NUM_GPR_ARG_REGISTERS-1\n-\t      || intarg_count % 2 != 0)\n-\t    intarg_count++;\n-\t  intarg_count += 2;\n+\t  gpr_count += gpr_count & 1;\n+\t  if (gpr_count >= NUM_GPR_ARG_REGISTERS)\n+\t    {\n+\t      stack_count += stack_count & 1;\n+\t      stack_count += 2;\n+\t    }\n+\t  else\n+\t    gpr_count += 2;\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n@@ -249,30 +272,30 @@ ffi_prep_cif_sysv_core (ffi_cif *cif)\n \tcase FFI_TYPE_SINT8:\n \t  /* Everything else is passed as a 4-byte word in a GPR, either\n \t     the object itself or a pointer to it.  */\n-\t  intarg_count++;\n+\t  if (gpr_count >= NUM_GPR_ARG_REGISTERS)\n+\t    stack_count += 1;\n+\t  else\n+\t    gpr_count += 1;\n \t  break;\n \n \tdefault:\n \t  FFI_ASSERT (0);\n \t}\n     }\n \n-  if (fparg_count != 0)\n+  if (fpr_count != 0)\n     flags |= FLAG_FP_ARGUMENTS;\n-  if (intarg_count > 4)\n+  if (gpr_count > 4)\n     flags |= FLAG_4_GPR_ARGUMENTS;\n   if (struct_copy_size != 0)\n     flags |= FLAG_ARG_NEEDS_COPY;\n \n   /* Space for the FPR registers, if needed.  */\n-  if (fparg_count != 0)\n+  if (fpr_count != 0)\n     bytes += NUM_FPR_ARG_REGISTERS * sizeof (double);\n \n   /* Stack space.  */\n-  if (intarg_count > NUM_GPR_ARG_REGISTERS)\n-    bytes += (intarg_count - NUM_GPR_ARG_REGISTERS) * sizeof (int);\n-  if (fparg_count > NUM_FPR_ARG_REGISTERS)\n-    bytes += (fparg_count - NUM_FPR_ARG_REGISTERS) * sizeof (double);\n+  bytes += stack_count * sizeof (int);\n \n   /* The stack space allocated needs to be a multiple of 16 bytes.  */\n   bytes = (bytes + 15) & ~0xF;\n@@ -367,13 +390,13 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n   /* 'gpr_base' points at the space for gpr3, and grows upwards as\n      we use GPR registers.  */\n   valp gpr_base;\n-  int intarg_count;\n+  valp gpr_end;\n \n #ifndef __NO_FPRS__\n   /* 'fpr_base' points at the space for fpr1, and grows upwards as\n      we use FPR registers.  */\n   valp fpr_base;\n-  int fparg_count;\n+  valp fpr_end;\n #endif\n \n   /* 'copy_space' grows down as we put structures in it.  It should\n@@ -405,11 +428,11 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n   unsigned gprvalue;\n \n   stacktop.c = (char *) stack + bytes;\n-  gpr_base.u = stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS;\n-  intarg_count = 0;\n+  gpr_end.u = stacktop.u - ASM_NEEDS_REGISTERS;\n+  gpr_base.u = gpr_end.u - NUM_GPR_ARG_REGISTERS;\n #ifndef __NO_FPRS__\n-  fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS;\n-  fparg_count = 0;\n+  fpr_end.d = gpr_base.d;\n+  fpr_base.d = fpr_end.d - NUM_FPR_ARG_REGISTERS;\n   copy_space.c = ((flags & FLAG_FP_ARGUMENTS) ? fpr_base.c : gpr_base.c);\n #else\n   copy_space.c = gpr_base.c;\n@@ -425,10 +448,7 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \n   /* Deal with return values that are actually pass-by-reference.  */\n   if (flags & FLAG_RETVAL_REFERENCE)\n-    {\n-      *gpr_base.u++ = (unsigned long) (char *) ecif->rvalue;\n-      intarg_count++;\n-    }\n+    *gpr_base.u++ = (unsigned) (char *) ecif->rvalue;\n \n   /* Now for the arguments.  */\n   p_argv.v = ecif->avalue;\n@@ -448,14 +468,11 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \tcase FFI_TYPE_LONGDOUBLE:\n \t  double_tmp = (*p_argv.d)[0];\n \n-\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS - 1)\n+\t  if (fpr_base.d >= fpr_end.d - 1)\n \t    {\n-\t      if (intarg_count >= NUM_GPR_ARG_REGISTERS\n-\t\t  && intarg_count % 2 != 0)\n-\t\t{\n-\t\t  intarg_count++;\n-\t\t  next_arg.u++;\n-\t\t}\n+\t      fpr_base.d = fpr_end.d;\n+\t      if (((next_arg.u - stack) & 1) != 0)\n+\t\tnext_arg.u += 1;\n \t      *next_arg.d = double_tmp;\n \t      next_arg.u += 2;\n \t      double_tmp = (*p_argv.d)[1];\n@@ -468,42 +485,33 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \t      double_tmp = (*p_argv.d)[1];\n \t      *fpr_base.d++ = double_tmp;\n \t    }\n-\n-\t  fparg_count += 2;\n \t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n \t  break;\n # endif\n \tcase FFI_TYPE_DOUBLE:\n \t  double_tmp = **p_argv.d;\n \n-\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n+\t  if (fpr_base.d >= fpr_end.d)\n \t    {\n-\t      if (intarg_count >= NUM_GPR_ARG_REGISTERS\n-\t\t  && intarg_count % 2 != 0)\n-\t\t{\n-\t\t  intarg_count++;\n-\t\t  next_arg.u++;\n-\t\t}\n+\t      if (((next_arg.u - stack) & 1) != 0)\n+\t\tnext_arg.u += 1;\n \t      *next_arg.d = double_tmp;\n \t      next_arg.u += 2;\n \t    }\n \t  else\n \t    *fpr_base.d++ = double_tmp;\n-\t  fparg_count++;\n \t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n \t  double_tmp = **p_argv.f;\n-\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n+\t  if (fpr_base.d >= fpr_end.d)\n \t    {\n \t      *next_arg.f = (float) double_tmp;\n \t      next_arg.u += 1;\n-\t      intarg_count++;\n \t    }\n \t  else\n \t    *fpr_base.d++ = double_tmp;\n-\t  fparg_count++;\n \t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n \t  break;\n #endif /* have FPRs */\n@@ -513,42 +521,34 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \t     is passed in four consecutive GPRs if available.  A maximum of 2\n \t     long doubles can be passed in gprs.  If we do not have 4 GPRs\n \t     left, the long double is passed on the stack, 4-byte aligned.  */\n-\t  {\n-\t    unsigned int int_tmp;\n-\t    unsigned int ii;\n-\t    if (intarg_count >= NUM_GPR_ARG_REGISTERS - 3)\n-\t      {\n-\t\tif (intarg_count < NUM_GPR_ARG_REGISTERS)\n-\t\t  intarg_count = NUM_GPR_ARG_REGISTERS;\n-\t\tfor (ii = 0; ii < 4; ii++)\n-\t\t  {\n-\t\t    int_tmp = (*p_argv.ui)[ii];\n-\t\t    *next_arg.u++ = int_tmp;\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\tfor (ii = 0; ii < 4; ii++)\n-\t\t  {\n-\t\t    int_tmp = (*p_argv.ui)[ii];\n-\t\t    *gpr_base.u++ = int_tmp;\n-\t\t  }\n-\t      }\n-\t    intarg_count += 4;\n-\t    break;\n-\t  }\n+\t  if (gpr_base.u >= gpr_end.u - 3)\n+\t    {\n+\t      unsigned int ii;\n+\t      gpr_base.u = gpr_end.u;\n+\t      for (ii = 0; ii < 4; ii++)\n+\t\t{\n+\t\t  unsigned int int_tmp = (*p_argv.ui)[ii];\n+\t\t  *next_arg.u++ = int_tmp;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      unsigned int ii;\n+\t      for (ii = 0; ii < 4; ii++)\n+\t\t{\n+\t\t  unsigned int int_tmp = (*p_argv.ui)[ii];\n+\t\t  *gpr_base.u++ = int_tmp;\n+\t\t}\n+\t    }\n+\t  break;\n \n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n-\t  if (intarg_count == NUM_GPR_ARG_REGISTERS-1)\n-\t    intarg_count++;\n-\t  if (intarg_count >= NUM_GPR_ARG_REGISTERS)\n+\t  if (gpr_base.u >= gpr_end.u - 1)\n \t    {\n-\t      if (intarg_count % 2 != 0)\n-\t\t{\n-\t\t  intarg_count++;\n-\t\t  next_arg.u++;\n-\t\t}\n+\t      gpr_base.u = gpr_end.u;\n+\t      if (((next_arg.u - stack) & 1) != 0)\n+\t\tnext_arg.u++;\n \t      *next_arg.ll = **p_argv.ll;\n \t      next_arg.u += 2;\n \t    }\n@@ -559,14 +559,10 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \t\t (r5,r6), (r7,r8), (r9,r10).  If next arg is long long\n \t\t but not correct starting register of pair then skip\n \t\t until the proper starting register.  */\n-\t      if (intarg_count % 2 != 0)\n-\t\t{\n-\t\t  intarg_count ++;\n-\t\t  gpr_base.u++;\n-\t\t}\n+\t      if (((gpr_end.u - gpr_base.u) & 1) != 0)\n+\t\tgpr_base.u++;\n \t      *gpr_base.ll++ = **p_argv.ll;\n \t    }\n-\t  intarg_count += 2;\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n@@ -601,29 +597,22 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \t  gprvalue = **p_argv.ui;\n \n \tputgpr:\n-\t  if (intarg_count >= NUM_GPR_ARG_REGISTERS)\n+\t  if (gpr_base.u >= gpr_end.u)\n \t    *next_arg.u++ = gprvalue;\n \t  else\n \t    *gpr_base.u++ = gprvalue;\n-\t  intarg_count++;\n \t  break;\n \t}\n     }\n \n   /* Check that we didn't overrun the stack...  */\n   FFI_ASSERT (copy_space.c >= next_arg.c);\n-  FFI_ASSERT (gpr_base.u <= stacktop.u - ASM_NEEDS_REGISTERS);\n-  /* The assert below is testing that the number of integer arguments agrees\n-     with the number found in ffi_prep_cif_machdep().  However, intarg_count\n-     is incremented whenever we place an FP arg on the stack, so account for\n-     that before our assert test.  */\n+  FFI_ASSERT (gpr_base.u <= gpr_end.u);\n #ifndef __NO_FPRS__\n-  if (fparg_count > NUM_FPR_ARG_REGISTERS)\n-    intarg_count -= fparg_count - NUM_FPR_ARG_REGISTERS;\n-  FFI_ASSERT (fpr_base.u\n-\t      <= stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);\n+  FFI_ASSERT (fpr_base.u <= fpr_end.u);\n #endif\n-  FFI_ASSERT (flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);\n+  FFI_ASSERT (((flags & FLAG_4_GPR_ARGUMENTS) != 0)\n+\t      == (gpr_end.u - gpr_base.u < 4));\n }\n \n #define MIN_CACHE_LINE_SIZE 8"}]}