{"sha": "d6d3f03341138d3918c71ce9fc6f05b81ebe004e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZkM2YwMzM0MTEzOGQzOTE4YzcxY2U5ZmM2ZjA1YjgxZWJlMDA0ZQ==", "commit": {"author": {"name": "Rong Xu", "email": "xur@gcc.gnu.org", "date": "2013-11-13T00:24:49Z"}, "committer": {"name": "Rong Xu", "email": "xur@gcc.gnu.org", "date": "2013-11-13T00:24:49Z"}, "message": "The patch re-factors libgcov.c to make it better modulelized.\n\n2013-11-12  Rong Xu  <xur@google.com>\n\nThe patch re-factors libgcov.c to make it better modulelized.\nIt contains two pieces of work:\n1. break gcov_exit() into the following structure:\n   gcov_exit()\n      --> gcov_exit_compute_summary()\n      --> allocate_filename_struct()\n          for gi_ptr in gcov_list\n            --> gcov_exit_dump_gcov()\n                   --> gcov_exit_open_gcda_file()\n                   --> gcov_exit_merge_gcda ()\n                   --> gcov_exit_merge_summary ()\n                   --> gcov_exit_write_gcda ()\n2. split libgcov.c into the following files:\n     libgcov-profiler.c\n     libgcov-merge.c\n     libgcov-interface.c\n     libgcov-driver.c\n       libgcov-driver-system.c (source included into libgcov-driver.c)\n\n\t* libgcc/libgcov.c: Delete as part of re-factoring.\n\t* gcc/gcov-io.h (__gcov_indirect_call_profiler): Add the decl to\n        avoid warning.\n\t* libgcc/libgcov-interface.c (init_mx): Moved from libgcov.c.\n\t(init_mx_once): Ditto.\n\t(__gcov_flush): Ditto.\n\t(__gcov_reset): Ditto.\n\t(__gcov_dump): Ditto.\n\t(__gcov_fork): Ditto.\n\t(__gcov_execl): Ditto.\n\t(__gcov_execlp): Ditto.\n\t(__gcov_execle): Ditto.\n\t(__gcov_execv): Ditto.\n\t(__gcov_execvp): Ditto.\n\t(__gcov_execve): Ditto.\n        * libgcc/libgcov-merge.c (__gcov_merge_time_profile): Moved from\n        libgcov.c.\n\t(__gcov_merge_add): Ditto.\n\t(__gcov_merge_ior): Ditto.\n\t(__gcov_merge_single): Ditto.\n\t(__gcov_merge_delta): Ditto.\n\t* libgcc/libgcov-profiler.c \n\t(__gcov_interval_profiler): Ditto.\n\t(__gcov_pow2_profiler): Ditto.\n\t(__gcov_one_value_profiler_body): Ditto.\n\t(__gcov_one_value_profiler): Ditto.\n\t(__gcov_indirect_call_profiler): Ditto.\n\t(__gcov_indirect_call_profiler_v2): Ditto.\n\t(__gcov_time_profiler): Ditto.\n\t(__gcov_average_profiler): Ditto.\n\t(__gcov_ior_profiler): Ditto.\n\t* libgcc/libgcov-driver.c (set_gcov_list): New.\n\t(get_gcov_dump_complete): Ditto.\n\t(set_gcov_dump_complete):Ditto.\n\t(reset_gcov_dump_complete):Ditto.\n\t(gcov_exit_compute_summary): New function split from gcov_exit().\n\t(gcov_exit_merge_gcda): Ditto.\n\t(gcov_exit_write_gcda): Ditto.\n\t(gcov_exit_merge_summary): Ditto.\n\t(gcov_exit_dump_gcov): Ditto.\n\t(struct gcov_fn_buffer): Moved from libgcov.c\n\t(struct gcov_summary_buffer): Ditto.\n\t(free_fn_data): Ditto.\n\t(buffer_fn_data): Ditto.\n\t(crc32_unsigned): Ditto.\n\t(gcov_version): Ditto.\n\t(gcov_histogram_insert): Ditto.\n\t(gcov_compute_histogram): Ditto.\n\t(gcov_exit): Ditto.\n\t(gcov_clear): Ditto.\n\t(__gcov_init): Ditto.\n        (this_prg): Make it file scope static variable.\n        (all_prg): Ditto.\n        (crc32): Ditto.\n        (gi_filename): Ditto.\n        (fn_buffer): Ditto.\n        (sum_buffer): Ditto.\n        (struct gcov_filename_aux): New types to store auxiliary information\n        for gi_filename.\n\t* libgcc/libgcov-driver-system.c (gcov_error): New utility function.\n\t(allocate_filename_struct): New function split from gcov_exit().\n\t(gcov_exit_open_gcda_file): Ditto.\n\t(create_file_directory): Moved from libgcov.c\n\t* libgcc/Makefile.in: Change to build newly added files.\n\nFrom-SVN: r204730", "tree": {"sha": "37fb2ef6bc9b218262b6180c7c04cd43556c7d23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37fb2ef6bc9b218262b6180c7c04cd43556c7d23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6d3f03341138d3918c71ce9fc6f05b81ebe004e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6d3f03341138d3918c71ce9fc6f05b81ebe004e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6d3f03341138d3918c71ce9fc6f05b81ebe004e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/comments", "author": null, "committer": null, "parents": [{"sha": "ef61907f9c6fe96eaf21ed7157ccc0e3e83c1bd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef61907f9c6fe96eaf21ed7157ccc0e3e83c1bd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef61907f9c6fe96eaf21ed7157ccc0e3e83c1bd1"}], "stats": {"total": 3207, "additions": 1784, "deletions": 1423}, "files": [{"sha": "fb3857d18080b600e72f0e19ec3d88c0ec9f0878", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=d6d3f03341138d3918c71ce9fc6f05b81ebe004e", "patch": "@@ -519,6 +519,8 @@ extern void __gcov_merge_time_profile (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n extern void __gcov_interval_profiler (gcov_type *, gcov_type, int, unsigned);\n extern void __gcov_pow2_profiler (gcov_type *, gcov_type);\n extern void __gcov_one_value_profiler (gcov_type *, gcov_type);\n+extern void __gcov_indirect_call_profiler (gcov_type*, gcov_type,\n+                                           void*, void*);\n extern void __gcov_indirect_call_profiler_v2 (gcov_type, void *);\n extern void __gcov_average_profiler (gcov_type *, gcov_type);\n extern void __gcov_ior_profiler (gcov_type *, gcov_type);"}, {"sha": "f040bad6e5b9461e1136dc5fd92180f9263b1861", "filename": "libgcc/Makefile.in", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/libgcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/libgcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FMakefile.in?ref=d6d3f03341138d3918c71ce9fc6f05b81ebe004e", "patch": "@@ -852,18 +852,31 @@ include $(iterator)\n \n # Build libgcov components.\n \n-# Defined in libgcov.c, included only in gcov library\n-LIBGCOV = _gcov _gcov_merge_add _gcov_merge_single _gcov_merge_delta \\\n-    _gcov_fork _gcov_execl _gcov_execlp _gcov_execle \\\n-    _gcov_execv _gcov_execvp _gcov_execve _gcov_reset _gcov_dump \\\n-    _gcov_interval_profiler _gcov_pow2_profiler _gcov_one_value_profiler \\\n+LIBGCOV_MERGE = _gcov_merge_add _gcov_merge_single _gcov_merge_delta _gcov_merge_ior \\\n+     _gcov_merge_time_profile\n+LIBGCOV_PROFILER = _gcov_interval_profiler _gcov_pow2_profiler _gcov_one_value_profiler \\\n     _gcov_indirect_call_profiler _gcov_average_profiler _gcov_ior_profiler \\\n-    _gcov_merge_ior _gcov_time_profiler _gcov_indirect_call_profiler_v2 _gcov_merge_time_profile\n-\n-libgcov-objects = $(patsubst %,%$(objext),$(LIBGCOV))\n-\n-$(libgcov-objects): %$(objext): $(srcdir)/libgcov.c\n-\t$(gcc_compile) -DL$* -c $(srcdir)/libgcov.c\n+    _gcov_indirect_call_profiler_v2 _gcov_time_profiler\n+LIBGCOV_INTERFACE = _gcov_flush _gcov_fork _gcov_execl _gcov_execlp _gcov_execle \\\n+    _gcov_execv _gcov_execvp _gcov_execve _gcov_reset _gcov_dump\n+LIBGCOV_DRIVER = _gcov \n+\n+libgcov-merge-objects = $(patsubst %,%$(objext),$(LIBGCOV_MERGE))\n+libgcov-profiler-objects = $(patsubst %,%$(objext),$(LIBGCOV_PROFILER))\n+libgcov-interface-objects = $(patsubst %,%$(objext),$(LIBGCOV_INTERFACE))\n+libgcov-driver-objects = $(patsubst %,%$(objext),$(LIBGCOV_DRIVER))\n+libgcov-objects = $(libgcov-merge-objects) $(libgcov-profiler-objects) \\\n+                 $(libgcov-interface-objects) $(libgcov-driver-objects)\n+\n+$(libgcov-merge-objects): %$(objext): $(srcdir)/libgcov-merge.c\n+\t$(gcc_compile) -DL$* -c $(srcdir)/libgcov-merge.c\n+$(libgcov-profiler-objects): %$(objext): $(srcdir)/libgcov-profiler.c\n+\t$(gcc_compile) -DL$* -c $(srcdir)/libgcov-profiler.c\n+$(libgcov-interface-objects): %$(objext): $(srcdir)/libgcov-interface.c\n+\t$(gcc_compile) -DL$* -c $(srcdir)/libgcov-interface.c\n+$(libgcov-driver-objects): %$(objext): $(srcdir)/libgcov-driver.c \\\n+  $(srcdir)/libgcov-driver-system.c\n+\t$(gcc_compile) -DL$* -c $(srcdir)/libgcov-driver.c\n \n \n # Static libraries."}, {"sha": "5605d057475a36d5c890393a3da8c83a2e4c2c6f", "filename": "libgcc/libgcov-driver-system.c", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/libgcc%2Flibgcov-driver-system.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/libgcc%2Flibgcov-driver-system.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver-system.c?ref=d6d3f03341138d3918c71ce9fc6f05b81ebe004e", "patch": "@@ -0,0 +1,203 @@\n+/* Routines required for instrumenting a program.  */\n+/* Compile this one with gcc.  */\n+/* Copyright (C) 1989-2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* A utility function for outputing errors.  */\n+\n+static int __attribute__((format(printf, 1, 2)))\n+gcov_error (const char *fmt, ...)\n+{\n+  int ret;\n+  va_list argp;\n+  va_start (argp, fmt);\n+  ret = vfprintf (stderr, fmt, argp);\n+  va_end (argp);\n+  return ret;\n+}\n+\n+/* Make sure path component of the given FILENAME exists, create\n+   missing directories. FILENAME must be writable.\n+   Returns zero on success, or -1 if an error occurred.  */\n+\n+static int\n+create_file_directory (char *filename)\n+{\n+#if !defined(TARGET_POSIX_IO) && !defined(_WIN32)\n+  (void) filename;\n+  return -1;\n+#else\n+  char *s;\n+\n+  s = filename;\n+\n+  if (HAS_DRIVE_SPEC(s))\n+    s += 2;\n+  if (IS_DIR_SEPARATOR(*s))\n+    ++s;\n+  for (; *s != '\\0'; s++)\n+    if (IS_DIR_SEPARATOR(*s))\n+      {\n+        char sep = *s;\n+        *s  = '\\0';\n+\n+        /* Try to make directory if it doesn't already exist.  */\n+        if (access (filename, F_OK) == -1\n+#ifdef TARGET_POSIX_IO\n+            && mkdir (filename, 0755) == -1\n+#else\n+            && mkdir (filename) == -1\n+#endif\n+            /* The directory might have been made by another process.  */\n+            && errno != EEXIST)\n+          {\n+            gcov_error (\"profiling:%s:Cannot create directory\\n\", filename);\n+            *s = sep;\n+            return -1;\n+          };\n+\n+        *s = sep;\n+      };\n+  return 0;\n+#endif\n+}\n+\n+static void\n+allocate_filename_struct (struct gcov_filename_aux *gf)\n+{\n+  const char *gcov_prefix;\n+  int gcov_prefix_strip = 0;\n+  size_t prefix_length;\n+  char *gi_filename_up;\n+\n+  gcc_assert (gf);\n+  {\n+    /* Check if the level of dirs to strip off specified. */\n+    char *tmp = getenv(\"GCOV_PREFIX_STRIP\");\n+    if (tmp)\n+      {\n+        gcov_prefix_strip = atoi (tmp);\n+        /* Do not consider negative values. */\n+        if (gcov_prefix_strip < 0)\n+          gcov_prefix_strip = 0;\n+      }\n+  }\n+\n+  /* Get file name relocation prefix.  Non-absolute values are ignored. */\n+  gcov_prefix = getenv(\"GCOV_PREFIX\");\n+  if (gcov_prefix)\n+    {\n+      prefix_length = strlen(gcov_prefix);\n+\n+      /* Remove an unnecessary trailing '/' */\n+      if (IS_DIR_SEPARATOR (gcov_prefix[prefix_length - 1]))\n+        prefix_length--;\n+    }\n+  else\n+    prefix_length = 0;\n+\n+  /* If no prefix was specified and a prefix stip, then we assume\n+     relative.  */\n+  if (gcov_prefix_strip != 0 && prefix_length == 0)\n+    {\n+      gcov_prefix = \".\";\n+      prefix_length = 1;\n+    }\n+  /* Allocate and initialize the filename scratch space plus one.  */\n+  gi_filename = (char *) malloc (prefix_length + gcov_max_filename + 2);\n+  if (prefix_length)\n+    memcpy (gi_filename, gcov_prefix, prefix_length);\n+  gi_filename_up = gi_filename + prefix_length;\n+\n+  gf->gi_filename_up = gi_filename_up;\n+  gf->prefix_length = prefix_length;\n+  gf->gcov_prefix_strip = gcov_prefix_strip;\n+}\n+\n+/* Open a gcda file specified by GI_FILENAME.\n+   Return -1 on error.  Return 0 on success.  */\n+\n+static int\n+gcov_exit_open_gcda_file (struct gcov_info *gi_ptr, struct gcov_filename_aux *gf)\n+{\n+  int gcov_prefix_strip;\n+  size_t prefix_length;\n+  char *gi_filename_up;\n+  const char *fname, *s;\n+\n+  gcov_prefix_strip = gf->gcov_prefix_strip;\n+  gi_filename_up = gf->gi_filename_up;\n+  prefix_length = gf->prefix_length;\n+  fname = gi_ptr->filename;\n+\n+  /* Avoid to add multiple drive letters into combined path.  */\n+  if (prefix_length != 0 && HAS_DRIVE_SPEC(fname))\n+    fname += 2;\n+\n+  /* Build relocated filename, stripping off leading\n+     directories from the initial filename if requested. */\n+  if (gcov_prefix_strip > 0)\n+    {\n+      int level = 0;\n+\n+      s = fname;\n+      if (IS_DIR_SEPARATOR(*s))\n+        ++s;\n+\n+      /* Skip selected directory levels. */\n+      for (; (*s != '\\0') && (level < gcov_prefix_strip); s++)\n+        if (IS_DIR_SEPARATOR(*s))\n+          {\n+            fname = s;\n+            level++;\n+          }\n+    }\n+\n+  /* Update complete filename with stripped original. */\n+  if (prefix_length != 0 && !IS_DIR_SEPARATOR (*fname))\n+    {\n+      /* If prefix is given, add directory separator.  */\n+      strcpy (gi_filename_up, \"/\");\n+      strcpy (gi_filename_up + 1, fname);\n+    }\n+  else\n+    strcpy (gi_filename_up, fname);\n+\n+  if (!gcov_open (gi_filename))\n+    {\n+      /* Open failed likely due to missed directory.\n+         Create directory and retry to open file. */\n+      if (create_file_directory (gi_filename))\n+        {\n+          fprintf (stderr, \"profiling:%s:Skip\\n\", gi_filename);\n+          return -1;\n+        }\n+      if (!gcov_open (gi_filename))\n+        {\n+          fprintf (stderr, \"profiling:%s:Cannot open\\n\", gi_filename);\n+          return -1;\n+        }\n+    }\n+\n+  return 0;\n+}"}, {"sha": "93bf2fb7ace61add010a3c3f8d9eeda59c1b7908", "filename": "libgcc/libgcov-driver.c", "status": "added", "additions": 872, "deletions": 0, "changes": 872, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=d6d3f03341138d3918c71ce9fc6f05b81ebe004e", "patch": "@@ -0,0 +1,872 @@\n+/* Routines required for instrumenting a program.  */\n+/* Compile this one with gcc.  */\n+/* Copyright (C) 1989-2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"libgcc_tm.h\"\n+\n+#if defined(inhibit_libc)\n+#define IN_LIBGCOV (-1)\n+#else\n+#define IN_LIBGCOV 1\n+#if defined(L_gcov)\n+#define GCOV_LINKAGE /* nothing */\n+#endif\n+#endif\n+#include \"gcov-io.h\"\n+\n+#if defined(inhibit_libc)\n+/* If libc and its header files are not available, provide dummy functions.  */\n+\n+#if defined(L_gcov)\n+void __gcov_init (struct gcov_info *p __attribute__ ((unused))) {}\n+#endif\n+\n+#else /* inhibit_libc */\n+\n+#include <string.h>\n+#if GCOV_LOCKED\n+#include <fcntl.h>\n+#include <errno.h>\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef L_gcov\n+#include \"gcov-io.c\"\n+\n+/* The following functions can be called from outside of this file.  */\n+extern void gcov_clear (void) ATTRIBUTE_HIDDEN;\n+extern void gcov_exit (void) ATTRIBUTE_HIDDEN;\n+extern void set_gcov_dump_complete (void) ATTRIBUTE_HIDDEN;\n+extern void reset_gcov_dump_complete (void) ATTRIBUTE_HIDDEN;\n+extern int get_gcov_dump_complete (void) ATTRIBUTE_HIDDEN;\n+extern void set_gcov_list (struct gcov_info *) ATTRIBUTE_HIDDEN;\n+\n+struct gcov_fn_buffer\n+{\n+  struct gcov_fn_buffer *next;\n+  unsigned fn_ix;\n+  struct gcov_fn_info info;\n+  /* note gcov_fn_info ends in a trailing array.  */\n+};\n+\n+struct gcov_summary_buffer\n+{\n+  struct gcov_summary_buffer *next;\n+  struct gcov_summary summary;\n+};\n+\n+/* Chain of per-object gcov structures.  */\n+static struct gcov_info *gcov_list;\n+\n+/* Set the head of gcov_list.  */\n+void\n+set_gcov_list (struct gcov_info *head)\n+{\n+  gcov_list = head;\n+}\n+\n+/* Size of the longest file name. */\n+static size_t gcov_max_filename = 0;\n+\n+/* Flag when the profile has already been dumped via __gcov_dump().  */\n+static int gcov_dump_complete;\n+\n+/* A global functino that get the vaule of gcov_dump_complete.  */\n+\n+int\n+get_gcov_dump_complete (void)\n+{\n+  return gcov_dump_complete;\n+}\n+\n+/* A global functino that set the vaule of gcov_dump_complete. Will\n+   be used in __gcov_dump() in libgcov-interface.c.  */\n+\n+void\n+set_gcov_dump_complete (void)\n+{\n+  gcov_dump_complete = 1;\n+}\n+\n+/* A global functino that set the vaule of gcov_dump_complete. Will\n+   be used in __gcov_reset() in libgcov-interface.c.  */\n+\n+void\n+reset_gcov_dump_complete (void)\n+{\n+  gcov_dump_complete = 0;\n+}\n+\n+/* A utility function for outputing errors.  */\n+static int gcov_error (const char *, ...);\n+\n+static struct gcov_fn_buffer *\n+free_fn_data (const struct gcov_info *gi_ptr, struct gcov_fn_buffer *buffer,\n+              unsigned limit)\n+{\n+  struct gcov_fn_buffer *next;\n+  unsigned ix, n_ctr = 0;\n+\n+  if (!buffer)\n+    return 0;\n+  next = buffer->next;\n+\n+  for (ix = 0; ix != limit; ix++)\n+    if (gi_ptr->merge[ix])\n+      free (buffer->info.ctrs[n_ctr++].values);\n+  free (buffer);\n+  return next;\n+}\n+\n+static struct gcov_fn_buffer **\n+buffer_fn_data (const char *filename, const struct gcov_info *gi_ptr,\n+                struct gcov_fn_buffer **end_ptr, unsigned fn_ix)\n+{\n+  unsigned n_ctrs = 0, ix = 0;\n+  struct gcov_fn_buffer *fn_buffer;\n+  unsigned len;\n+\n+  for (ix = GCOV_COUNTERS; ix--;)\n+    if (gi_ptr->merge[ix])\n+      n_ctrs++;\n+\n+  len = sizeof (*fn_buffer) + sizeof (fn_buffer->info.ctrs[0]) * n_ctrs;\n+  fn_buffer = (struct gcov_fn_buffer *)malloc (len);\n+\n+  if (!fn_buffer)\n+    goto fail;\n+\n+  fn_buffer->next = 0;\n+  fn_buffer->fn_ix = fn_ix;\n+  fn_buffer->info.ident = gcov_read_unsigned ();\n+  fn_buffer->info.lineno_checksum = gcov_read_unsigned ();\n+  fn_buffer->info.cfg_checksum = gcov_read_unsigned ();\n+\n+  for (n_ctrs = ix = 0; ix != GCOV_COUNTERS; ix++)\n+    {\n+      gcov_unsigned_t length;\n+      gcov_type *values;\n+\n+      if (!gi_ptr->merge[ix])\n+        continue;\n+\n+      if (gcov_read_unsigned () != GCOV_TAG_FOR_COUNTER (ix))\n+        {\n+          len = 0;\n+          goto fail;\n+        }\n+\n+      length = GCOV_TAG_COUNTER_NUM (gcov_read_unsigned ());\n+      len = length * sizeof (gcov_type);\n+      values = (gcov_type *)malloc (len);\n+      if (!values)\n+        goto fail;\n+\n+      fn_buffer->info.ctrs[n_ctrs].num = length;\n+      fn_buffer->info.ctrs[n_ctrs].values = values;\n+\n+      while (length--)\n+        *values++ = gcov_read_counter ();\n+      n_ctrs++;\n+    }\n+\n+  *end_ptr = fn_buffer;\n+  return &fn_buffer->next;\n+\n+fail:\n+  gcov_error (\"profiling:%s:Function %u %s %u \\n\", filename, fn_ix,\n+              len ? \"cannot allocate\" : \"counter mismatch\", len ? len : ix);\n+\n+  return (struct gcov_fn_buffer **)free_fn_data (gi_ptr, fn_buffer, ix);\n+}\n+\n+/* Add an unsigned value to the current crc */\n+\n+static gcov_unsigned_t\n+crc32_unsigned (gcov_unsigned_t crc32, gcov_unsigned_t value)\n+{\n+  unsigned ix;\n+\n+  for (ix = 32; ix--; value <<= 1)\n+    {\n+      unsigned feedback;\n+\n+      feedback = (value ^ crc32) & 0x80000000 ? 0x04c11db7 : 0;\n+      crc32 <<= 1;\n+      crc32 ^= feedback;\n+    }\n+\n+  return crc32;\n+}\n+\n+/* Check if VERSION of the info block PTR matches libgcov one.\n+   Return 1 on success, or zero in case of versions mismatch.\n+   If FILENAME is not NULL, its value used for reporting purposes\n+   instead of value from the info block.  */\n+\n+static int\n+gcov_version (struct gcov_info *ptr, gcov_unsigned_t version,\n+              const char *filename)\n+{\n+  if (version != GCOV_VERSION)\n+    {\n+      char v[4], e[4];\n+\n+      GCOV_UNSIGNED2STRING (v, version);\n+      GCOV_UNSIGNED2STRING (e, GCOV_VERSION);\n+\n+      gcov_error (\"profiling:%s:Version mismatch - expected %.4s got %.4s\\n\",\n+                  filename? filename : ptr->filename, e, v);\n+      return 0;\n+    }\n+  return 1;\n+}\n+\n+/* Insert counter VALUE into HISTOGRAM.  */\n+\n+static void\n+gcov_histogram_insert(gcov_bucket_type *histogram, gcov_type value)\n+{\n+  unsigned i;\n+\n+  i = gcov_histo_index(value);\n+  histogram[i].num_counters++;\n+  histogram[i].cum_value += value;\n+  if (value < histogram[i].min_value)\n+    histogram[i].min_value = value;\n+}\n+\n+/* Computes a histogram of the arc counters to place in the summary SUM.  */\n+\n+static void\n+gcov_compute_histogram (struct gcov_summary *sum)\n+{\n+  struct gcov_info *gi_ptr;\n+  const struct gcov_fn_info *gfi_ptr;\n+  const struct gcov_ctr_info *ci_ptr;\n+  struct gcov_ctr_summary *cs_ptr;\n+  unsigned t_ix, f_ix, ctr_info_ix, ix;\n+  int h_ix;\n+\n+  /* This currently only applies to arc counters.  */\n+  t_ix = GCOV_COUNTER_ARCS;\n+\n+  /* First check if there are any counts recorded for this counter.  */\n+  cs_ptr = &(sum->ctrs[t_ix]);\n+  if (!cs_ptr->num)\n+    return;\n+\n+  for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n+    {\n+      cs_ptr->histogram[h_ix].num_counters = 0;\n+      cs_ptr->histogram[h_ix].min_value = cs_ptr->run_max;\n+      cs_ptr->histogram[h_ix].cum_value = 0;\n+    }\n+\n+  /* Walk through all the per-object structures and record each of\n+     the count values in histogram.  */\n+  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n+    {\n+      if (!gi_ptr->merge[t_ix])\n+        continue;\n+\n+      /* Find the appropriate index into the gcov_ctr_info array\n+         for the counter we are currently working on based on the\n+         existence of the merge function pointer for this object.  */\n+      for (ix = 0, ctr_info_ix = 0; ix < t_ix; ix++)\n+        {\n+          if (gi_ptr->merge[ix])\n+            ctr_info_ix++;\n+        }\n+      for (f_ix = 0; f_ix != gi_ptr->n_functions; f_ix++)\n+        {\n+          gfi_ptr = gi_ptr->functions[f_ix];\n+\n+          if (!gfi_ptr || gfi_ptr->key != gi_ptr)\n+            continue;\n+\n+          ci_ptr = &gfi_ptr->ctrs[ctr_info_ix];\n+          for (ix = 0; ix < ci_ptr->num; ix++)\n+            gcov_histogram_insert (cs_ptr->histogram, ci_ptr->values[ix]);\n+        }\n+    }\n+}\n+\n+/* summary for program.  */\n+static struct gcov_summary this_prg;\n+#if !GCOV_LOCKED\n+/* summary for all instances of program.  */\n+static struct gcov_summary all_prg;\n+#endif\n+/* crc32 for this program.  */\n+static gcov_unsigned_t crc32;\n+/* gcda filename.  */\n+static char *gi_filename;\n+/* buffer for the fn_data from another program.  */\n+static struct gcov_fn_buffer *fn_buffer;\n+/* buffer for summary from other programs to be written out. */\n+static struct gcov_summary_buffer *sum_buffer;\n+\n+/* This funtions computes the program level summary and the histo-gram.\n+   It initializes ALL_PRG, computes CRC32, and stores the summary in\n+   THIS_PRG. All these three variables are file statics.  */\n+\n+static void\n+gcov_exit_compute_summary (void)\n+{\n+  struct gcov_info *gi_ptr;\n+  const struct gcov_fn_info *gfi_ptr;\n+  struct gcov_ctr_summary *cs_ptr;\n+  const struct gcov_ctr_info *ci_ptr;\n+  int f_ix;\n+  unsigned t_ix;\n+  gcov_unsigned_t c_num;\n+\n+#if !GCOV_LOCKED\n+  memset (&all_prg, 0, sizeof (all_prg));\n+#endif\n+  /* Find the totals for this execution.  */\n+  memset (&this_prg, 0, sizeof (this_prg));\n+  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n+    {\n+      crc32 = crc32_unsigned (crc32, gi_ptr->stamp);\n+      crc32 = crc32_unsigned (crc32, gi_ptr->n_functions);\n+\n+      for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions; f_ix++)\n+        {\n+          gfi_ptr = gi_ptr->functions[f_ix];\n+\n+          if (gfi_ptr && gfi_ptr->key != gi_ptr)\n+            gfi_ptr = 0;\n+\n+          crc32 = crc32_unsigned (crc32, gfi_ptr ? gfi_ptr->cfg_checksum : 0);\n+          crc32 = crc32_unsigned (crc32,\n+                                  gfi_ptr ? gfi_ptr->lineno_checksum : 0);\n+          if (!gfi_ptr)\n+            continue;\n+\n+          ci_ptr = gfi_ptr->ctrs;\n+          for (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)\n+            {\n+              if (!gi_ptr->merge[t_ix])\n+                continue;\n+\n+              cs_ptr = &this_prg.ctrs[t_ix];\n+              cs_ptr->num += ci_ptr->num;\n+              crc32 = crc32_unsigned (crc32, ci_ptr->num);\n+\n+              for (c_num = 0; c_num < ci_ptr->num; c_num++)\n+                {\n+                  cs_ptr->sum_all += ci_ptr->values[c_num];\n+                  if (cs_ptr->run_max < ci_ptr->values[c_num])\n+                    cs_ptr->run_max = ci_ptr->values[c_num];\n+                }\n+              ci_ptr++;\n+            }\n+        }\n+    }\n+  gcov_compute_histogram (&this_prg);\n+}\n+\n+/* A struct that bundles all the related information about the\n+   gcda filename.  */\n+struct gcov_filename_aux{\n+  char *gi_filename_up;\n+  int gcov_prefix_strip;\n+  size_t prefix_length;\n+};\n+\n+/* Including system dependent components. */\n+#include \"libgcov-driver-system.c\"\n+\n+/* This function merges counters in GI_PTR to an existing gcda file.\n+   Return 0 on success.\n+   Return -1 on error. In this case, caller will goto read_fatal.  */\n+\n+static int\n+gcov_exit_merge_gcda (struct gcov_info *gi_ptr,\n+                      struct gcov_summary *prg_p,\n+                      gcov_position_t *summary_pos_p,\n+                      gcov_position_t *eof_pos_p)\n+{\n+  gcov_unsigned_t tag, length;\n+  unsigned t_ix;\n+  int f_ix;\n+  int error = 0;\n+  struct gcov_fn_buffer **fn_tail = &fn_buffer;\n+  struct gcov_summary_buffer **sum_tail = &sum_buffer;\n+\n+  length = gcov_read_unsigned ();\n+  if (!gcov_version (gi_ptr, length, gi_filename))\n+    return -1;\n+\n+  length = gcov_read_unsigned ();\n+  if (length != gi_ptr->stamp)\n+    /* Read from a different compilation. Overwrite the file.  */\n+    return 0;\n+\n+  /* Look for program summary.  */\n+  for (f_ix = 0;;)\n+    {\n+      struct gcov_summary tmp;\n+\n+      *eof_pos_p = gcov_position ();\n+      tag = gcov_read_unsigned ();\n+      if (tag != GCOV_TAG_PROGRAM_SUMMARY)\n+        break;\n+\n+      f_ix--;\n+      length = gcov_read_unsigned ();\n+      gcov_read_summary (&tmp);\n+      if ((error = gcov_is_error ()))\n+        goto read_error;\n+      if (*summary_pos_p)\n+        {\n+          /* Save all summaries after the one that will be\n+             merged into below. These will need to be rewritten\n+             as histogram merging may change the number of non-zero\n+             histogram entries that will be emitted, and thus the\n+             size of the merged summary.  */\n+          (*sum_tail) = (struct gcov_summary_buffer *)\n+              malloc (sizeof(struct gcov_summary_buffer));\n+          (*sum_tail)->summary = tmp;\n+          (*sum_tail)->next = 0;\n+          sum_tail = &((*sum_tail)->next);\n+          goto next_summary;\n+        }\n+      if (tmp.checksum != crc32)\n+        goto next_summary;\n+\n+      for (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)\n+        if (tmp.ctrs[t_ix].num != this_prg.ctrs[t_ix].num)\n+          goto next_summary;\n+      *prg_p = tmp;\n+      *summary_pos_p = *eof_pos_p;\n+\n+    next_summary:;\n+    }\n+\n+  /* Merge execution counts for each function.  */\n+  for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions;\n+       f_ix++, tag = gcov_read_unsigned ())\n+    {\n+      const struct gcov_ctr_info *ci_ptr;\n+      const struct gcov_fn_info *gfi_ptr = gi_ptr->functions[f_ix];\n+\n+      if (tag != GCOV_TAG_FUNCTION)\n+        goto read_mismatch;\n+\n+      length = gcov_read_unsigned ();\n+      if (!length)\n+        /* This function did not appear in the other program.\n+           We have nothing to merge.  */\n+        continue;\n+\n+      if (length != GCOV_TAG_FUNCTION_LENGTH)\n+        goto read_mismatch;\n+\n+      if (!gfi_ptr || gfi_ptr->key != gi_ptr)\n+        {\n+          /* This function appears in the other program.  We\n+             need to buffer the information in order to write\n+             it back out -- we'll be inserting data before\n+             this point, so cannot simply keep the data in the\n+             file.  */\n+          fn_tail = buffer_fn_data (gi_filename,\n+                                    gi_ptr, fn_tail, f_ix);\n+          if (!fn_tail)\n+            goto read_mismatch;\n+          continue;\n+        }\n+\n+      length = gcov_read_unsigned ();\n+      if (length != gfi_ptr->ident)\n+        goto read_mismatch;\n+\n+      length = gcov_read_unsigned ();\n+      if (length != gfi_ptr->lineno_checksum)\n+        goto read_mismatch;\n+\n+      length = gcov_read_unsigned ();\n+      if (length != gfi_ptr->cfg_checksum)\n+        goto read_mismatch;\n+\n+      ci_ptr = gfi_ptr->ctrs;\n+      for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)\n+        {\n+          gcov_merge_fn merge = gi_ptr->merge[t_ix];\n+\n+          if (!merge)\n+            continue;\n+\n+          tag = gcov_read_unsigned ();\n+          length = gcov_read_unsigned ();\n+          if (tag != GCOV_TAG_FOR_COUNTER (t_ix)\n+              || length != GCOV_TAG_COUNTER_LENGTH (ci_ptr->num))\n+            goto read_mismatch;\n+          (*merge) (ci_ptr->values, ci_ptr->num);\n+          ci_ptr++;\n+        }\n+      if ((error = gcov_is_error ()))\n+        goto read_error;\n+    }\n+\n+  if (tag)\n+    {\n+    read_mismatch:;\n+      gcov_error (\"profiling:%s:Merge mismatch for %s %u\\n\",\n+                  gi_filename, f_ix >= 0 ? \"function\" : \"summary\",\n+                  f_ix < 0 ? -1 - f_ix : f_ix);\n+      return -1;\n+    }\n+  return 0;\n+\n+read_error:\n+  gcov_error (\"profiling:%s:%s merging\\n\", gi_filename,\n+              error < 0 ? \"Overflow\": \"Error\");\n+  return -1;\n+}\n+\n+/* Write counters in GI_PTR and the summary in PRG to a gcda file. In\n+   the case of appending to an existing file, SUMMARY_POS will be non-zero.\n+   We will write the file starting from SUMMAY_POS.  */\n+\n+static void\n+gcov_exit_write_gcda (const struct gcov_info *gi_ptr,\n+                      const struct gcov_summary *prg_p,\n+                      const gcov_position_t eof_pos,\n+                      const gcov_position_t summary_pos)\n+{\n+  unsigned f_ix;\n+  struct gcov_summary_buffer *next_sum_buffer;\n+\n+  /* Write out the data.  */\n+  if (!eof_pos)\n+    {\n+      gcov_write_tag_length (GCOV_DATA_MAGIC, GCOV_VERSION);\n+      gcov_write_unsigned (gi_ptr->stamp);\n+    }\n+\n+  if (summary_pos)\n+    gcov_seek (summary_pos);\n+\n+  /* Generate whole program statistics.  */\n+  gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, prg_p);\n+\n+  /* Rewrite all the summaries that were after the summary we merged\n+     into. This is necessary as the merged summary may have a different\n+     size due to the number of non-zero histogram entries changing after\n+     merging.  */\n+\n+  while (sum_buffer)\n+    {\n+      gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &sum_buffer->summary);\n+      next_sum_buffer = sum_buffer->next;\n+      free (sum_buffer);\n+      sum_buffer = next_sum_buffer;\n+    }\n+\n+  /* Write execution counts for each function.  */\n+  for (f_ix = 0; f_ix != gi_ptr->n_functions; f_ix++)\n+    {\n+      unsigned buffered = 0;\n+      const struct gcov_fn_info *gfi_ptr;\n+      const struct gcov_ctr_info *ci_ptr;\n+      gcov_unsigned_t length;\n+      unsigned t_ix;\n+\n+      if (fn_buffer && fn_buffer->fn_ix == f_ix)\n+        {\n+          /* Buffered data from another program.  */\n+          buffered = 1;\n+          gfi_ptr = &fn_buffer->info;\n+          length = GCOV_TAG_FUNCTION_LENGTH;\n+        }\n+      else\n+        {\n+          gfi_ptr = gi_ptr->functions[f_ix];\n+          if (gfi_ptr && gfi_ptr->key == gi_ptr)\n+            length = GCOV_TAG_FUNCTION_LENGTH;\n+          else\n+                length = 0;\n+        }\n+\n+      gcov_write_tag_length (GCOV_TAG_FUNCTION, length);\n+      if (!length)\n+        continue;\n+\n+      gcov_write_unsigned (gfi_ptr->ident);\n+      gcov_write_unsigned (gfi_ptr->lineno_checksum);\n+      gcov_write_unsigned (gfi_ptr->cfg_checksum);\n+\n+      ci_ptr = gfi_ptr->ctrs;\n+      for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)\n+        {\n+          gcov_unsigned_t n_counts;\n+          gcov_type *c_ptr;\n+\n+          if (!gi_ptr->merge[t_ix])\n+            continue;\n+\n+          n_counts = ci_ptr->num;\n+          gcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),\n+                                 GCOV_TAG_COUNTER_LENGTH (n_counts));\n+          c_ptr = ci_ptr->values;\n+          while (n_counts--)\n+            gcov_write_counter (*c_ptr++);\n+          ci_ptr++;\n+        }\n+      if (buffered)\n+        fn_buffer = free_fn_data (gi_ptr, fn_buffer, GCOV_COUNTERS);\n+    }\n+\n+  gcov_write_unsigned (0);\n+}\n+\n+/* Helper function for merging summary.\n+   Return -1 on error. Return 0 on success.  */\n+\n+static int\n+gcov_exit_merge_summary (const struct gcov_info *gi_ptr, struct gcov_summary *prg)\n+{\n+  struct gcov_ctr_summary *cs_prg, *cs_tprg;\n+#if !GCOV_LOCKED\n+  struct gcov_ctr_summary *cs_all;\n+#endif\n+  unsigned t_ix;\n+\n+  /* Merge the summaries.  */\n+  for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n+    {\n+      cs_prg = &(prg->ctrs[t_ix]);\n+      cs_tprg = &this_prg.ctrs[t_ix];\n+\n+      if (gi_ptr->merge[t_ix])\n+        {\n+          if (!cs_prg->runs++)\n+            cs_prg->num = cs_tprg->num;\n+          cs_prg->sum_all += cs_tprg->sum_all;\n+          if (cs_prg->run_max < cs_tprg->run_max)\n+            cs_prg->run_max = cs_tprg->run_max;\n+          cs_prg->sum_max += cs_tprg->run_max;\n+          if (cs_prg->runs == 1)\n+            memcpy (cs_prg->histogram, cs_tprg->histogram,\n+                   sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n+          else\n+            gcov_histogram_merge (cs_prg->histogram, cs_tprg->histogram);\n+        }\n+      else if (cs_prg->runs)\n+        {\n+          gcov_error (\"profiling:%s:Merge mismatch for summary.\\n\",\n+                      gi_filename);\n+          return -1;\n+        }\n+\n+#if !GCOV_LOCKED\n+      cs_all = &all_prg.ctrs[t_ix];\n+      if (!cs_all->runs && cs_prg->runs)\n+        {\n+          cs_all->num = cs_prg->num;\n+          cs_all->runs = cs_prg->runs;\n+          cs_all->sum_all = cs_prg->sum_all;\n+          cs_all->run_max = cs_prg->run_max;\n+          cs_all->sum_max = cs_prg->sum_max;\n+        }\n+      else if (!all_prg.checksum\n+               /* Don't compare the histograms, which may have slight\n+                  variations depending on the order they were updated\n+                  due to the truncating integer divides used in the\n+                  merge.  */\n+               && (cs_all->num != cs_prg->num\n+                   || cs_all->runs != cs_prg->runs\n+                   || cs_all->sum_all != cs_prg->sum_all\n+                   || cs_all->run_max != cs_prg->run_max\n+                   || cs_all->sum_max != cs_prg->sum_max))\n+             {\n+               gcov_error (\"profiling:%s:Data file mismatch - some \"\n+                           \"data files may have been concurrently \"\n+                           \"updated without locking support\\n\", gi_filename);\n+               all_prg.checksum = ~0u;\n+             }\n+#endif\n+    }\n+\n+  prg->checksum = crc32;\n+\n+  return 0;\n+}\n+\n+/* Dump the coverage counts for one gcov_info object. We merge with existing\n+   counts when possible, to avoid growing the .da files ad infinitum. We use\n+   this program's checksum to make sure we only accumulate whole program\n+   statistics to the correct summary. An object file might be embedded\n+   in two separate programs, and we must keep the two program\n+   summaries separate.  */\n+\n+static void\n+gcov_exit_dump_gcov (struct gcov_info *gi_ptr, struct gcov_filename_aux *gf)\n+{\n+  struct gcov_summary prg; /* summary for this object over all program.  */\n+  int error;\n+  gcov_unsigned_t tag;\n+  gcov_position_t summary_pos = 0;\n+  gcov_position_t eof_pos = 0;\n+\n+  fn_buffer = 0;\n+  sum_buffer = 0;\n+\n+  error = gcov_exit_open_gcda_file (gi_ptr, gf);\n+  if (error == -1)\n+    return;\n+\n+  tag = gcov_read_unsigned ();\n+  if (tag)\n+    {\n+      /* Merge data from file.  */\n+      if (tag != GCOV_DATA_MAGIC)\n+        {\n+          gcov_error (\"profiling:%s:Not a gcov data file\\n\", gi_filename);\n+          goto read_fatal;\n+        }\n+      error = gcov_exit_merge_gcda (gi_ptr, &prg, &summary_pos, &eof_pos);\n+      if (error == -1)\n+        goto read_fatal;\n+    }\n+\n+  gcov_rewrite ();\n+\n+  if (!summary_pos)\n+    {\n+      memset (&prg, 0, sizeof (prg));\n+      summary_pos = eof_pos;\n+    }\n+\n+  error = gcov_exit_merge_summary (gi_ptr, &prg);\n+  if (error == -1)\n+    goto read_fatal;\n+\n+  gcov_exit_write_gcda (gi_ptr, &prg, eof_pos, summary_pos);\n+  /* fall through */\n+\n+read_fatal:;\n+  while (fn_buffer)\n+    fn_buffer = free_fn_data (gi_ptr, fn_buffer, GCOV_COUNTERS);\n+\n+  if ((error = gcov_close ()))\n+    gcov_error (error  < 0 ?\n+                \"profiling:%s:Overflow writing\\n\" :\n+                \"profiling:%s:Error writing\\n\",\n+                gi_filename);\n+}\n+\n+\n+/* Dump all the coverage counts for the program. It first computes program\n+   summary and then traverses gcov_list list and dumps the gcov_info\n+   objects one by one.  */\n+\n+void\n+gcov_exit (void)\n+{\n+  struct gcov_info *gi_ptr;\n+  struct gcov_filename_aux gf;\n+\n+  /* Prevent the counters from being dumped a second time on exit when the\n+     application already wrote out the profile using __gcov_dump().  */\n+  if (gcov_dump_complete)\n+    return;\n+\n+  gcov_exit_compute_summary ();\n+\n+  allocate_filename_struct (&gf);\n+\n+  /* Now merge each file.  */\n+  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n+    gcov_exit_dump_gcov (gi_ptr, &gf);\n+\n+  if (gi_filename)\n+    free (gi_filename);\n+}\n+\n+/* Reset all counters to zero.  */\n+\n+void\n+gcov_clear (void)\n+{\n+  const struct gcov_info *gi_ptr;\n+\n+  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n+    {\n+      unsigned f_ix;\n+\n+      for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)\n+        {\n+          unsigned t_ix;\n+          const struct gcov_fn_info *gfi_ptr = gi_ptr->functions[f_ix];\n+\n+          if (!gfi_ptr || gfi_ptr->key != gi_ptr)\n+            continue;\n+          const struct gcov_ctr_info *ci_ptr = gfi_ptr->ctrs;\n+          for (t_ix = 0; t_ix != GCOV_COUNTERS; t_ix++)\n+            {\n+              if (!gi_ptr->merge[t_ix])\n+                continue;\n+\n+              memset (ci_ptr->values, 0, sizeof (gcov_type) * ci_ptr->num);\n+              ci_ptr++;\n+            }\n+        }\n+    }\n+}\n+\n+/* Add a new object file onto the bb chain.  Invoked automatically\n+  when running an object file's global ctors.  */\n+\n+void\n+__gcov_init (struct gcov_info *info)\n+{\n+  if (!info->version || !info->n_functions)\n+    return;\n+  if (gcov_version (info, info->version, 0))\n+    {\n+      size_t filename_length = strlen(info->filename);\n+\n+      /* Refresh the longest file name information */\n+      if (filename_length > gcov_max_filename)\n+        gcov_max_filename = filename_length;\n+\n+      if (!gcov_list)\n+        atexit (gcov_exit);\n+\n+      info->next = gcov_list;\n+      gcov_list = info;\n+    }\n+  info->version = 0;\n+}\n+\n+#endif /* L_gcov */\n+#endif /* inhibit_libc */"}, {"sha": "5e23178b87e3b3038b007cb54c5fc2021736f291", "filename": "libgcc/libgcov-interface.c", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/libgcc%2Flibgcov-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/libgcc%2Flibgcov-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-interface.c?ref=d6d3f03341138d3918c71ce9fc6f05b81ebe004e", "patch": "@@ -0,0 +1,279 @@\n+/* Routines required for instrumenting a program.  */\n+/* Compile this one with gcc.  */\n+/* Copyright (C) 1989-2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"libgcc_tm.h\"\n+#include \"gthr.h\"\n+\n+#if defined(inhibit_libc)\n+#define IN_LIBGCOV (-1)\n+#else\n+#define IN_LIBGCOV 1\n+#endif\n+#include \"gcov-io.h\"\n+\n+#if defined(inhibit_libc)\n+\n+#ifdef L_gcov_flush\n+void __gcov_flush (void) {}\n+#endif\n+\n+#ifdef L_gcov_reset\n+void __gcov_reset (void) {}\n+#endif\n+\n+#ifdef L_gcov_dump\n+void __gcov_dump (void) {}\n+#endif\n+\n+#else\n+\n+extern void gcov_clear (void) ATTRIBUTE_HIDDEN;\n+extern void gcov_exit (void) ATTRIBUTE_HIDDEN;\n+extern void set_gcov_dump_complete (void) ATTRIBUTE_HIDDEN;\n+extern void reset_gcov_dump_complete (void) ATTRIBUTE_HIDDEN;\n+\n+#ifdef L_gcov_flush\n+\n+#ifdef __GTHREAD_MUTEX_INIT\n+ATTRIBUTE_HIDDEN __gthread_mutex_t __gcov_flush_mx = __GTHREAD_MUTEX_INIT;\n+#define init_mx_once()\n+#else\n+__gthread_mutex_t __gcov_flush_mx ATTRIBUTE_HIDDEN;\n+\n+static void\n+init_mx (void)\n+{\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&__gcov_flush_mx);\n+}\n+static void\n+init_mx_once (void)\n+{\n+  static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+  __gthread_once (&once, init_mx);\n+}\n+#endif\n+\n+/* Called before fork or exec - write out profile information gathered so\n+   far and reset it to zero.  This avoids duplication or loss of the\n+   profile information gathered so far.  */\n+\n+void\n+__gcov_flush (void)\n+{\n+  init_mx_once ();\n+  __gthread_mutex_lock (&__gcov_flush_mx);\n+\n+  gcov_exit ();\n+  gcov_clear ();\n+\n+  __gthread_mutex_unlock (&__gcov_flush_mx);\n+}\n+\n+#endif /* L_gcov_flush */\n+\n+#ifdef L_gcov_reset\n+\n+/* Function that can be called from application to reset counters to zero,\n+   in order to collect profile in region of interest.  */\n+\n+void\n+__gcov_reset (void)\n+{\n+  gcov_clear ();\n+  /* Re-enable dumping to support collecting profile in multiple regions\n+     of interest.  */\n+  reset_gcov_dump_complete ();\n+}\n+\n+#endif /* L_gcov_reset */\n+\n+#ifdef L_gcov_dump\n+\n+/* Function that can be called from application to write profile collected\n+   so far, in order to collect profile in region of interest.  */\n+\n+void\n+__gcov_dump (void)\n+{\n+  gcov_exit ();\n+  /* Prevent profile from being dumped a second time on application exit.  */\n+  set_gcov_dump_complete ();\n+}\n+\n+#endif /* L_gcov_dump */\n+\n+\n+#ifdef L_gcov_fork\n+/* A wrapper for the fork function.  Flushes the accumulated profiling data, so\n+   that they are not counted twice.  */\n+\n+pid_t\n+__gcov_fork (void)\n+{\n+  pid_t pid;\n+  extern __gthread_mutex_t __gcov_flush_mx;\n+  __gcov_flush ();\n+  pid = fork ();\n+  if (pid == 0)\n+    __GTHREAD_MUTEX_INIT_FUNCTION (&__gcov_flush_mx);\n+  return pid;\n+}\n+#endif\n+\n+#ifdef L_gcov_execl\n+/* A wrapper for the execl function.  Flushes the accumulated profiling data, so\n+   that they are not lost.  */\n+\n+int\n+__gcov_execl (const char *path, char *arg, ...)\n+{\n+  va_list ap, aq;\n+  unsigned i, length;\n+  char **args;\n+\n+  __gcov_flush ();\n+\n+  va_start (ap, arg);\n+  va_copy (aq, ap);\n+\n+  length = 2;\n+  while (va_arg (ap, char *))\n+    length++;\n+  va_end (ap);\n+\n+  args = (char **) alloca (length * sizeof (void *));\n+  args[0] = arg;\n+  for (i = 1; i < length; i++)\n+    args[i] = va_arg (aq, char *);\n+  va_end (aq);\n+\n+  return execv (path, args);\n+}\n+#endif\n+\n+#ifdef L_gcov_execlp\n+/* A wrapper for the execlp function.  Flushes the accumulated profiling data, so\n+   that they are not lost.  */\n+\n+int\n+__gcov_execlp (const char *path, char *arg, ...)\n+{\n+  va_list ap, aq;\n+  unsigned i, length;\n+  char **args;\n+\n+  __gcov_flush ();\n+\n+  va_start (ap, arg);\n+  va_copy (aq, ap);\n+\n+  length = 2;\n+  while (va_arg (ap, char *))\n+    length++;\n+  va_end (ap);\n+\n+  args = (char **) alloca (length * sizeof (void *));\n+  args[0] = arg;\n+  for (i = 1; i < length; i++)\n+    args[i] = va_arg (aq, char *);\n+  va_end (aq);\n+\n+  return execvp (path, args);\n+}\n+#endif\n+\n+#ifdef L_gcov_execle\n+/* A wrapper for the execle function.  Flushes the accumulated profiling data, so\n+   that they are not lost.  */\n+\n+int\n+__gcov_execle (const char *path, char *arg, ...)\n+{\n+  va_list ap, aq;\n+  unsigned i, length;\n+  char **args;\n+  char **envp;\n+\n+  __gcov_flush ();\n+\n+  va_start (ap, arg);\n+  va_copy (aq, ap);\n+\n+  length = 2;\n+  while (va_arg (ap, char *))\n+    length++;\n+  va_end (ap);\n+\n+  args = (char **) alloca (length * sizeof (void *));\n+  args[0] = arg;\n+  for (i = 1; i < length; i++)\n+    args[i] = va_arg (aq, char *);\n+  envp = va_arg (aq, char **);\n+  va_end (aq);\n+\n+  return execve (path, args, envp);\n+}\n+#endif\n+\n+#ifdef L_gcov_execv\n+/* A wrapper for the execv function.  Flushes the accumulated profiling data, so\n+   that they are not lost.  */\n+\n+int\n+__gcov_execv (const char *path, char *const argv[])\n+{\n+  __gcov_flush ();\n+  return execv (path, argv);\n+}\n+#endif\n+\n+#ifdef L_gcov_execvp\n+/* A wrapper for the execvp function.  Flushes the accumulated profiling data, so\n+   that they are not lost.  */\n+\n+int\n+__gcov_execvp (const char *path, char *const argv[])\n+{\n+  __gcov_flush ();\n+  return execvp (path, argv);\n+}\n+#endif\n+\n+#ifdef L_gcov_execve\n+/* A wrapper for the execve function.  Flushes the accumulated profiling data, so\n+   that they are not lost.  */\n+\n+int\n+__gcov_execve (const char *path, char *const argv[], char *const envp[])\n+{\n+  __gcov_flush ();\n+  return execve (path, argv, envp);\n+}\n+#endif\n+#endif /* inhibit_libc */"}, {"sha": "45cd48cc4c4e290e9e8ebc8450bc167135248744", "filename": "libgcc/libgcov-merge.c", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/libgcc%2Flibgcov-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/libgcc%2Flibgcov-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-merge.c?ref=d6d3f03341138d3918c71ce9fc6f05b81ebe004e", "patch": "@@ -0,0 +1,181 @@\n+/* Routines required for instrumenting a program.  */\n+/* Compile this one with gcc.  */\n+/* Copyright (C) 1989-2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"libgcc_tm.h\"\n+\n+#if defined(inhibit_libc)\n+#define IN_LIBGCOV (-1)\n+#else\n+#define IN_LIBGCOV 1\n+#endif\n+\n+#include \"gcov-io.h\"\n+\n+#if defined(inhibit_libc)\n+/* If libc and its header files are not available, provide dummy functions.  */\n+\n+#ifdef L_gcov_merge_add\n+void __gcov_merge_add (gcov_type *counters  __attribute__ ((unused)),\n+                       unsigned n_counters __attribute__ ((unused))) {}\n+#endif\n+\n+#ifdef L_gcov_merge_single\n+void __gcov_merge_single (gcov_type *counters  __attribute__ ((unused)),\n+                          unsigned n_counters __attribute__ ((unused))) {}\n+#endif\n+\n+#ifdef L_gcov_merge_delta\n+void __gcov_merge_delta (gcov_type *counters  __attribute__ ((unused)),\n+                         unsigned n_counters __attribute__ ((unused))) {}\n+#endif\n+\n+#else\n+\n+#ifdef L_gcov_merge_add\n+/* The profile merging function that just adds the counters.  It is given\n+   an array COUNTERS of N_COUNTERS old counters and it reads the same number\n+   of counters from the gcov file.  */\n+void\n+__gcov_merge_add (gcov_type *counters, unsigned n_counters)\n+{\n+  for (; n_counters; counters++, n_counters--)\n+    *counters += gcov_read_counter ();\n+}\n+#endif /* L_gcov_merge_add */\n+\n+#ifdef L_gcov_merge_ior\n+/* The profile merging function that just adds the counters.  It is given\n+   an array COUNTERS of N_COUNTERS old counters and it reads the same number\n+   of counters from the gcov file.  */\n+void\n+__gcov_merge_ior (gcov_type *counters, unsigned n_counters)\n+{\n+  for (; n_counters; counters++, n_counters--)\n+    *counters |= gcov_read_counter ();\n+}\n+#endif\n+\n+#ifdef L_gcov_merge_time_profile\n+/* Time profiles are merged so that minimum from all valid (greater than zero)\n+   is stored. There could be a fork that creates new counters. To have\n+   the profile stable, we chosen to pick the smallest function visit time.  */\n+void\n+__gcov_merge_time_profile (gcov_type *counters, unsigned n_counters)\n+{\n+  unsigned int i;\n+  gcov_type value;\n+\n+  for (i = 0; i < n_counters; i++)\n+    {\n+      value = gcov_read_counter ();\n+\n+      if (value && (!counters[i] || value < counters[i]))\n+        counters[i] = value;\n+    }\n+}\n+#endif /* L_gcov_merge_time_profile */\n+\n+#ifdef L_gcov_merge_single\n+/* The profile merging function for choosing the most common value.\n+   It is given an array COUNTERS of N_COUNTERS old counters and it\n+   reads the same number of counters from the gcov file.  The counters\n+   are split into 3-tuples where the members of the tuple have\n+   meanings:\n+\n+   -- the stored candidate on the most common value of the measured entity\n+   -- counter\n+   -- total number of evaluations of the value  */\n+void\n+__gcov_merge_single (gcov_type *counters, unsigned n_counters)\n+{\n+  unsigned i, n_measures;\n+  gcov_type value, counter, all;\n+\n+  gcc_assert (!(n_counters % 3));\n+  n_measures = n_counters / 3;\n+  for (i = 0; i < n_measures; i++, counters += 3)\n+    {\n+      value = gcov_read_counter ();\n+      counter = gcov_read_counter ();\n+      all = gcov_read_counter ();\n+\n+      if (counters[0] == value)\n+        counters[1] += counter;\n+      else if (counter > counters[1])\n+        {\n+          counters[0] = value;\n+          counters[1] = counter - counters[1];\n+        }\n+      else\n+        counters[1] -= counter;\n+      counters[2] += all;\n+    }\n+}\n+#endif /* L_gcov_merge_single */\n+\n+#ifdef L_gcov_merge_delta\n+/* The profile merging function for choosing the most common\n+   difference between two consecutive evaluations of the value.  It is\n+   given an array COUNTERS of N_COUNTERS old counters and it reads the\n+   same number of counters from the gcov file.  The counters are split\n+   into 4-tuples where the members of the tuple have meanings:\n+\n+   -- the last value of the measured entity\n+   -- the stored candidate on the most common difference\n+   -- counter\n+   -- total number of evaluations of the value  */\n+void\n+__gcov_merge_delta (gcov_type *counters, unsigned n_counters)\n+{\n+  unsigned i, n_measures;\n+  gcov_type value, counter, all;\n+\n+  gcc_assert (!(n_counters % 4));\n+  n_measures = n_counters / 4;\n+  for (i = 0; i < n_measures; i++, counters += 4)\n+    {\n+      /* last = */ gcov_read_counter ();\n+      value = gcov_read_counter ();\n+      counter = gcov_read_counter ();\n+      all = gcov_read_counter ();\n+\n+      if (counters[1] == value)\n+        counters[2] += counter;\n+      else if (counter > counters[2])\n+        {\n+          counters[1] = value;\n+          counters[2] = counter - counters[2];\n+        }\n+      else\n+        counters[2] -= counter;\n+      counters[3] += all;\n+    }\n+}\n+#endif /* L_gcov_merge_delta */\n+#endif /* inhibit_libc */"}, {"sha": "6ba1bcf365cb3f7f0b8db110f25f9c46dd015728", "filename": "libgcc/libgcov-profiler.c", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/libgcc%2Flibgcov-profiler.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d3f03341138d3918c71ce9fc6f05b81ebe004e/libgcc%2Flibgcov-profiler.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-profiler.c?ref=d6d3f03341138d3918c71ce9fc6f05b81ebe004e", "patch": "@@ -0,0 +1,223 @@\n+/* Routines required for instrumenting a program.  */\n+/* Compile this one with gcc.  */\n+/* Copyright (C) 1989-2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"libgcc_tm.h\"\n+\n+#if !defined(inhibit_libc)\n+#define IN_LIBGCOV 1\n+#include \"gcov-io.h\"\n+\n+#ifdef L_gcov_interval_profiler\n+/* If VALUE is in interval <START, START + STEPS - 1>, then increases the\n+   corresponding counter in COUNTERS.  If the VALUE is above or below\n+   the interval, COUNTERS[STEPS] or COUNTERS[STEPS + 1] is increased\n+   instead.  */\n+\n+void\n+__gcov_interval_profiler (gcov_type *counters, gcov_type value,\n+                          int start, unsigned steps)\n+{\n+  gcov_type delta = value - start;\n+  if (delta < 0)\n+    counters[steps + 1]++;\n+  else if (delta >= steps)\n+    counters[steps]++;\n+  else\n+    counters[delta]++;\n+}\n+#endif\n+\n+#ifdef L_gcov_pow2_profiler\n+/* If VALUE is a power of two, COUNTERS[1] is incremented.  Otherwise\n+   COUNTERS[0] is incremented.  */\n+\n+void\n+__gcov_pow2_profiler (gcov_type *counters, gcov_type value)\n+{\n+  if (value & (value - 1))\n+    counters[0]++;\n+  else\n+    counters[1]++;\n+}\n+#endif\n+\n+/* Tries to determine the most common value among its inputs.  Checks if the\n+   value stored in COUNTERS[0] matches VALUE.  If this is the case, COUNTERS[1]\n+   is incremented.  If this is not the case and COUNTERS[1] is not zero,\n+   COUNTERS[1] is decremented.  Otherwise COUNTERS[1] is set to one and\n+   VALUE is stored to COUNTERS[0].  This algorithm guarantees that if this\n+   function is called more than 50% of the time with one value, this value\n+   will be in COUNTERS[0] in the end.\n+\n+   In any case, COUNTERS[2] is incremented.  */\n+\n+static inline void\n+__gcov_one_value_profiler_body (gcov_type *counters, gcov_type value)\n+{\n+  if (value == counters[0])\n+    counters[1]++;\n+  else if (counters[1] == 0)\n+    {\n+      counters[1] = 1;\n+      counters[0] = value;\n+    }\n+  else\n+    counters[1]--;\n+  counters[2]++;\n+}\n+\n+#ifdef L_gcov_one_value_profiler\n+void\n+__gcov_one_value_profiler (gcov_type *counters, gcov_type value)\n+{\n+  __gcov_one_value_profiler_body (counters, value);\n+}\n+#endif\n+\n+#ifdef L_gcov_indirect_call_profiler\n+/* This function exist only for workaround of binutils bug 14342.\n+   Once this compatibility hack is obsolette, it can be removed.  */\n+\n+/* By default, the C++ compiler will use function addresses in the\n+   vtable entries.  Setting TARGET_VTABLE_USES_DESCRIPTORS to nonzero\n+   tells the compiler to use function descriptors instead.  The value\n+   of this macro says how many words wide the descriptor is (normally 2),\n+   but it may be dependent on target flags.  Since we do not have access\n+   to the target flags here we just check to see if it is set and use\n+   that to set VTABLE_USES_DESCRIPTORS to 0 or 1.\n+\n+   It is assumed that the address of a function descriptor may be treated\n+   as a pointer to a function.  */\n+\n+#ifdef TARGET_VTABLE_USES_DESCRIPTORS\n+#define VTABLE_USES_DESCRIPTORS 1\n+#else\n+#define VTABLE_USES_DESCRIPTORS 0\n+#endif\n+\n+/* Tries to determine the most common value among its inputs. */\n+void\n+__gcov_indirect_call_profiler (gcov_type* counter, gcov_type value,\n+                               void* cur_func, void* callee_func)\n+{\n+  /* If the C++ virtual tables contain function descriptors then one\n+     function may have multiple descriptors and we need to dereference\n+     the descriptors to see if they point to the same function.  */\n+  if (cur_func == callee_func\n+      || (VTABLE_USES_DESCRIPTORS && callee_func\n+          && *(void **) cur_func == *(void **) callee_func))\n+    __gcov_one_value_profiler_body (counter, value);\n+}\n+\n+#endif\n+#ifdef L_gcov_indirect_call_profiler_v2\n+\n+/* These two variables are used to actually track caller and callee.  Keep\n+   them in TLS memory so races are not common (they are written to often).\n+   The variables are set directly by GCC instrumented code, so declaration\n+   here must match one in tree-profile.c  */\n+\n+#if defined(HAVE_CC_TLS) && !defined (USE_EMUTLS)\n+__thread\n+#endif\n+void * __gcov_indirect_call_callee;\n+#if defined(HAVE_CC_TLS) && !defined (USE_EMUTLS)\n+__thread\n+#endif\n+gcov_type * __gcov_indirect_call_counters;\n+\n+/* By default, the C++ compiler will use function addresses in the\n+   vtable entries.  Setting TARGET_VTABLE_USES_DESCRIPTORS to nonzero\n+   tells the compiler to use function descriptors instead.  The value\n+   of this macro says how many words wide the descriptor is (normally 2),\n+   but it may be dependent on target flags.  Since we do not have access\n+   to the target flags here we just check to see if it is set and use\n+   that to set VTABLE_USES_DESCRIPTORS to 0 or 1.\n+\n+   It is assumed that the address of a function descriptor may be treated\n+   as a pointer to a function.  */\n+\n+#ifdef TARGET_VTABLE_USES_DESCRIPTORS\n+#define VTABLE_USES_DESCRIPTORS 1\n+#else\n+#define VTABLE_USES_DESCRIPTORS 0\n+#endif\n+\n+/* Tries to determine the most common value among its inputs. */\n+void\n+__gcov_indirect_call_profiler_v2 (gcov_type value, void* cur_func)\n+{\n+  /* If the C++ virtual tables contain function descriptors then one\n+     function may have multiple descriptors and we need to dereference\n+     the descriptors to see if they point to the same function.  */\n+  if (cur_func == __gcov_indirect_call_callee\n+      || (VTABLE_USES_DESCRIPTORS && __gcov_indirect_call_callee\n+          && *(void **) cur_func == *(void **) __gcov_indirect_call_callee))\n+    __gcov_one_value_profiler_body (__gcov_indirect_call_counters, value);\n+}\n+#endif\n+\n+#ifdef L_gcov_time_profiler\n+\n+/* Counter for first visit of each function.  */\n+static gcov_type function_counter;\n+\n+/* Sets corresponding COUNTERS if there is no value.  */\n+\n+void\n+__gcov_time_profiler (gcov_type* counters)\n+{\n+  if (!counters[0])\n+    counters[0] = ++function_counter;\n+}\n+#endif\n+\n+#ifdef L_gcov_average_profiler\n+/* Increase corresponding COUNTER by VALUE.  FIXME: Perhaps we want\n+   to saturate up.  */\n+\n+void\n+__gcov_average_profiler (gcov_type *counters, gcov_type value)\n+{\n+  counters[0] += value;\n+  counters[1] ++;\n+}\n+#endif\n+\n+#ifdef L_gcov_ior_profiler\n+/* Bitwise-OR VALUE into COUNTER.  */\n+\n+void\n+__gcov_ior_profiler (gcov_type *counters, gcov_type value)\n+{\n+  *counters |= value;\n+}\n+#endif\n+\n+#endif /* inhibit_libc */"}, {"sha": "6450fd7654867775fab7418c43b736ff66a721cc", "filename": "libgcc/libgcov.c", "status": "removed", "additions": 0, "deletions": 1412, "changes": 1412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef61907f9c6fe96eaf21ed7157ccc0e3e83c1bd1/libgcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef61907f9c6fe96eaf21ed7157ccc0e3e83c1bd1/libgcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.c?ref=ef61907f9c6fe96eaf21ed7157ccc0e3e83c1bd1", "patch": "@@ -1,1412 +0,0 @@\n-/* Routines required for instrumenting a program.  */\n-/* Compile this one with gcc.  */\n-/* Copyright (C) 1989-2013 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"tconfig.h\"\n-#include \"tsystem.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"libgcc_tm.h\"\n-#include \"gthr.h\"\n-\n-#if defined(inhibit_libc)\n-#define IN_LIBGCOV (-1)\n-#else\n-#define IN_LIBGCOV 1\n-#if defined(L_gcov)\n-#define GCOV_LINKAGE /* nothing */\n-#endif\n-#endif\n-#include \"gcov-io.h\"\n-\n-#if defined(inhibit_libc)\n-/* If libc and its header files are not available, provide dummy functions.  */\n-\n-#ifdef L_gcov\n-void __gcov_init (struct gcov_info *p __attribute__ ((unused))) {}\n-void __gcov_flush (void) {}\n-#endif\n-\n-#ifdef L_gcov_reset\n-void __gcov_reset (void) {}\n-#endif\n-\n-#ifdef L_gcov_dump\n-void __gcov_dump (void) {}\n-#endif\n-\n-#ifdef L_gcov_merge_add\n-void __gcov_merge_add (gcov_type *counters  __attribute__ ((unused)),\n-\t\t       unsigned n_counters __attribute__ ((unused))) {}\n-#endif\n-\n-#ifdef L_gcov_merge_single\n-void __gcov_merge_single (gcov_type *counters  __attribute__ ((unused)),\n-\t\t\t  unsigned n_counters __attribute__ ((unused))) {}\n-#endif\n-\n-#ifdef L_gcov_merge_delta\n-void __gcov_merge_delta (gcov_type *counters  __attribute__ ((unused)),\n-\t\t\t unsigned n_counters __attribute__ ((unused))) {}\n-#endif\n-\n-#else\n-\n-#include <string.h>\n-#if GCOV_LOCKED\n-#include <fcntl.h>\n-#include <errno.h>\n-#include <sys/stat.h>\n-#endif\n-\n-extern gcov_type function_counter ATTRIBUTE_HIDDEN;\n-extern void gcov_clear (void) ATTRIBUTE_HIDDEN;\n-extern void gcov_exit (void) ATTRIBUTE_HIDDEN;\n-extern int gcov_dump_complete ATTRIBUTE_HIDDEN;\n-\n-#ifdef L_gcov\n-#include \"gcov-io.c\"\n-\n-struct gcov_fn_buffer\n-{\n-  struct gcov_fn_buffer *next;\n-  unsigned fn_ix;\n-  struct gcov_fn_info info;\n-  /* note gcov_fn_info ends in a trailing array.  */\n-};\n-\n-struct gcov_summary_buffer\n-{\n-  struct gcov_summary_buffer *next;\n-  struct gcov_summary summary;\n-};\n-\n-/* Chain of per-object gcov structures.  */\n-static struct gcov_info *gcov_list;\n-\n-/* Size of the longest file name. */\n-static size_t gcov_max_filename = 0;\n-\n-/* Flag when the profile has already been dumped via __gcov_dump().  */\n-int gcov_dump_complete = 0;\n-\n-/* Make sure path component of the given FILENAME exists, create\n-   missing directories. FILENAME must be writable.\n-   Returns zero on success, or -1 if an error occurred.  */\n-\n-static int\n-create_file_directory (char *filename)\n-{\n-#if !defined(TARGET_POSIX_IO) && !defined(_WIN32)\n-  (void) filename;\n-  return -1;\n-#else\n-  char *s;\n-\n-  s = filename;\n-\n-  if (HAS_DRIVE_SPEC(s))\n-    s += 2;\n-  if (IS_DIR_SEPARATOR(*s))\n-    ++s;\n-  for (; *s != '\\0'; s++)\n-    if (IS_DIR_SEPARATOR(*s))\n-      {\n-        char sep = *s;\n-\t*s  = '\\0';\n-\n-        /* Try to make directory if it doesn't already exist.  */\n-        if (access (filename, F_OK) == -1\n-#ifdef TARGET_POSIX_IO\n-            && mkdir (filename, 0755) == -1\n-#else\n-            && mkdir (filename) == -1\n-#endif\n-            /* The directory might have been made by another process.  */\n-\t    && errno != EEXIST)\n-\t  {\n-            fprintf (stderr, \"profiling:%s:Cannot create directory\\n\",\n-\t\t     filename);\n-            *s = sep;\n-\t    return -1;\n-\t  };\n-\n-\t*s = sep;\n-      };\n-  return 0;\n-#endif\n-}\n-\n-static struct gcov_fn_buffer *\n-free_fn_data (const struct gcov_info *gi_ptr, struct gcov_fn_buffer *buffer,\n-\t      unsigned limit)\n-{\n-  struct gcov_fn_buffer *next;\n-  unsigned ix, n_ctr = 0;\n-  \n-  if (!buffer)\n-    return 0;\n-  next = buffer->next;\n-\n-  for (ix = 0; ix != limit; ix++)\n-    if (gi_ptr->merge[ix])\n-      free (buffer->info.ctrs[n_ctr++].values);\n-  free (buffer);\n-  return next;\n-}\n-  \n-static struct gcov_fn_buffer **\n-buffer_fn_data (const char *filename, const struct gcov_info *gi_ptr,\n-\t\tstruct gcov_fn_buffer **end_ptr, unsigned fn_ix)\n-{\n-  unsigned n_ctrs = 0, ix = 0;\n-  struct gcov_fn_buffer *fn_buffer;\n-  unsigned len;\n-\n-  for (ix = GCOV_COUNTERS; ix--;)\n-    if (gi_ptr->merge[ix])\n-      n_ctrs++;\n-\n-  len = sizeof (*fn_buffer) + sizeof (fn_buffer->info.ctrs[0]) * n_ctrs;\n-  fn_buffer = (struct gcov_fn_buffer *)malloc (len);\n-\n-  if (!fn_buffer)\n-    goto fail;\n-  \n-  fn_buffer->next = 0;\n-  fn_buffer->fn_ix = fn_ix;\n-  fn_buffer->info.ident = gcov_read_unsigned ();\n-  fn_buffer->info.lineno_checksum = gcov_read_unsigned ();\n-  fn_buffer->info.cfg_checksum = gcov_read_unsigned ();\n-\n-  for (n_ctrs = ix = 0; ix != GCOV_COUNTERS; ix++)\n-    {\n-      gcov_unsigned_t length;\n-      gcov_type *values;\n-\n-      if (!gi_ptr->merge[ix])\n-\tcontinue;\n-      \n-      if (gcov_read_unsigned () != GCOV_TAG_FOR_COUNTER (ix))\n-\t{\n-\t  len = 0;\n-\t  goto fail;\n-\t}\n-\n-      length = GCOV_TAG_COUNTER_NUM (gcov_read_unsigned ());\n-      len = length * sizeof (gcov_type);\n-      values = (gcov_type *)malloc (len);\n-      if (!values)\n-\tgoto fail;\n-      \n-      fn_buffer->info.ctrs[n_ctrs].num = length;\n-      fn_buffer->info.ctrs[n_ctrs].values = values;\n-\n-      while (length--)\n-\t*values++ = gcov_read_counter ();\n-      n_ctrs++;\n-    }\n-  \n-  *end_ptr = fn_buffer;\n-  return &fn_buffer->next;\n-\n- fail:\n-  fprintf (stderr, \"profiling:%s:Function %u %s %u \\n\", filename, fn_ix,\n-\t   len ? \"cannot allocate\" : \"counter mismatch\", len ? len : ix);\n-\n-  return (struct gcov_fn_buffer **)free_fn_data (gi_ptr, fn_buffer, ix);\n-}\n-\n-/* Add an unsigned value to the current crc */\n-\n-static gcov_unsigned_t\n-crc32_unsigned (gcov_unsigned_t crc32, gcov_unsigned_t value)\n-{\n-  unsigned ix;\n-\n-  for (ix = 32; ix--; value <<= 1)\n-    {\n-      unsigned feedback;\n-\n-      feedback = (value ^ crc32) & 0x80000000 ? 0x04c11db7 : 0;\n-      crc32 <<= 1;\n-      crc32 ^= feedback;\n-    }\n-\n-  return crc32;\n-}\n-\n-/* Check if VERSION of the info block PTR matches libgcov one.\n-   Return 1 on success, or zero in case of versions mismatch.\n-   If FILENAME is not NULL, its value used for reporting purposes\n-   instead of value from the info block.  */\n-\n-static int\n-gcov_version (struct gcov_info *ptr, gcov_unsigned_t version,\n-\t      const char *filename)\n-{\n-  if (version != GCOV_VERSION)\n-    {\n-      char v[4], e[4];\n-\n-      GCOV_UNSIGNED2STRING (v, version);\n-      GCOV_UNSIGNED2STRING (e, GCOV_VERSION);\n-\n-      fprintf (stderr,\n-\t       \"profiling:%s:Version mismatch - expected %.4s got %.4s\\n\",\n-\t       filename? filename : ptr->filename, e, v);\n-      return 0;\n-    }\n-  return 1;\n-}\n-\n-/* Insert counter VALUE into HISTOGRAM.  */\n-\n-static void\n-gcov_histogram_insert(gcov_bucket_type *histogram, gcov_type value)\n-{\n-  unsigned i;\n-\n-  i = gcov_histo_index(value);\n-  histogram[i].num_counters++;\n-  histogram[i].cum_value += value;\n-  if (value < histogram[i].min_value)\n-    histogram[i].min_value = value;\n-}\n-\n-/* Computes a histogram of the arc counters to place in the summary SUM.  */\n-\n-static void\n-gcov_compute_histogram (struct gcov_summary *sum)\n-{\n-  struct gcov_info *gi_ptr;\n-  const struct gcov_fn_info *gfi_ptr;\n-  const struct gcov_ctr_info *ci_ptr;\n-  struct gcov_ctr_summary *cs_ptr;\n-  unsigned t_ix, f_ix, ctr_info_ix, ix;\n-  int h_ix;\n-\n-  /* This currently only applies to arc counters.  */\n-  t_ix = GCOV_COUNTER_ARCS;\n-\n-  /* First check if there are any counts recorded for this counter.  */\n-  cs_ptr = &(sum->ctrs[t_ix]);\n-  if (!cs_ptr->num)\n-    return;\n-\n-  for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n-    {\n-      cs_ptr->histogram[h_ix].num_counters = 0;\n-      cs_ptr->histogram[h_ix].min_value = cs_ptr->run_max;\n-      cs_ptr->histogram[h_ix].cum_value = 0;\n-    }\n-\n-  /* Walk through all the per-object structures and record each of\n-     the count values in histogram.  */\n-  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n-    {\n-      if (!gi_ptr->merge[t_ix])\n-        continue;\n-\n-      /* Find the appropriate index into the gcov_ctr_info array\n-         for the counter we are currently working on based on the\n-         existence of the merge function pointer for this object.  */\n-      for (ix = 0, ctr_info_ix = 0; ix < t_ix; ix++)\n-        {\n-          if (gi_ptr->merge[ix])\n-            ctr_info_ix++;\n-        }\n-      for (f_ix = 0; f_ix != gi_ptr->n_functions; f_ix++)\n-        {\n-          gfi_ptr = gi_ptr->functions[f_ix];\n-\n-          if (!gfi_ptr || gfi_ptr->key != gi_ptr)\n-            continue;\n-\n-          ci_ptr = &gfi_ptr->ctrs[ctr_info_ix];\n-          for (ix = 0; ix < ci_ptr->num; ix++)\n-            gcov_histogram_insert (cs_ptr->histogram, ci_ptr->values[ix]);\n-        }\n-    }\n-}\n-\n-\n-/* Counter for first visit of each function.  */\n-gcov_type function_counter;\n-\n-/* Dump the coverage counts. We merge with existing counts when\n-   possible, to avoid growing the .da files ad infinitum. We use this\n-   program's checksum to make sure we only accumulate whole program\n-   statistics to the correct summary. An object file might be embedded\n-   in two separate programs, and we must keep the two program\n-   summaries separate.  */\n-\n-void\n-gcov_exit (void)\n-{\n-  struct gcov_info *gi_ptr;\n-  const struct gcov_fn_info *gfi_ptr;\n-  struct gcov_summary this_prg; /* summary for program.  */\n-#if !GCOV_LOCKED\n-  struct gcov_summary all_prg;  /* summary for all instances of program.  */\n-#endif\n-  struct gcov_ctr_summary *cs_ptr;\n-  const struct gcov_ctr_info *ci_ptr;\n-  unsigned t_ix;\n-  int f_ix;\n-  gcov_unsigned_t c_num;\n-  const char *gcov_prefix;\n-  int gcov_prefix_strip = 0;\n-  size_t prefix_length;\n-  char *gi_filename, *gi_filename_up;\n-  gcov_unsigned_t crc32 = 0;\n-\n-  /* Prevent the counters from being dumped a second time on exit when the\n-     application already wrote out the profile using __gcov_dump().  */\n-  if (gcov_dump_complete)\n-    return;\n-\n-#if !GCOV_LOCKED\n-  memset (&all_prg, 0, sizeof (all_prg));\n-#endif\n-  /* Find the totals for this execution.  */\n-  memset (&this_prg, 0, sizeof (this_prg));\n-  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n-    {\n-      crc32 = crc32_unsigned (crc32, gi_ptr->stamp);\n-      crc32 = crc32_unsigned (crc32, gi_ptr->n_functions);\n-      \n-      for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions; f_ix++)\n-\t{\n-\t  gfi_ptr = gi_ptr->functions[f_ix];\n-\n-\t  if (gfi_ptr && gfi_ptr->key != gi_ptr)\n-\t    gfi_ptr = 0;\n-\t  \n-\t  crc32 = crc32_unsigned (crc32, gfi_ptr ? gfi_ptr->cfg_checksum : 0);\n-\t  crc32 = crc32_unsigned (crc32,\n-\t\t\t\t  gfi_ptr ? gfi_ptr->lineno_checksum : 0);\n-\t  if (!gfi_ptr)\n-\t    continue;\n-\n-\t  ci_ptr = gfi_ptr->ctrs;\n-\t  for (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)\n-\t    {\n-\t      if (!gi_ptr->merge[t_ix])\n-\t\tcontinue;\n-\n-\t      cs_ptr = &this_prg.ctrs[t_ix];\n-\t      cs_ptr->num += ci_ptr->num;\n-\t      crc32 = crc32_unsigned (crc32, ci_ptr->num);\n-\t      \n-\t      for (c_num = 0; c_num < ci_ptr->num; c_num++)\n-\t\t{\n-\t\t  cs_ptr->sum_all += ci_ptr->values[c_num];\n-\t\t  if (cs_ptr->run_max < ci_ptr->values[c_num])\n-\t\t    cs_ptr->run_max = ci_ptr->values[c_num];\n-\t\t}\n-\t      ci_ptr++;\n-\t    }\n-\t}\n-    }\n-  gcov_compute_histogram (&this_prg);\n-\n-  {\n-    /* Check if the level of dirs to strip off specified. */\n-    char *tmp = getenv(\"GCOV_PREFIX_STRIP\");\n-    if (tmp)\n-      {\n-\tgcov_prefix_strip = atoi (tmp);\n-\t/* Do not consider negative values. */\n-\tif (gcov_prefix_strip < 0)\n-\t  gcov_prefix_strip = 0;\n-      }\n-  }\n-\n-  /* Get file name relocation prefix.  Non-absolute values are ignored. */\n-  gcov_prefix = getenv(\"GCOV_PREFIX\");\n-  if (gcov_prefix)\n-    {\n-      prefix_length = strlen(gcov_prefix);\n-\n-      /* Remove an unnecessary trailing '/' */\n-      if (IS_DIR_SEPARATOR (gcov_prefix[prefix_length - 1]))\n-\tprefix_length--;\n-    }\n-  else\n-    prefix_length = 0;\n-\n-  /* If no prefix was specified and a prefix stip, then we assume\n-     relative.  */\n-  if (gcov_prefix_strip != 0 && prefix_length == 0)\n-    {\n-      gcov_prefix = \".\";\n-      prefix_length = 1;\n-    }\n-  /* Allocate and initialize the filename scratch space plus one.  */\n-  gi_filename = (char *) alloca (prefix_length + gcov_max_filename + 2);\n-  if (prefix_length)\n-    memcpy (gi_filename, gcov_prefix, prefix_length);\n-  gi_filename_up = gi_filename + prefix_length;\n-\n-  /* Now merge each file.  */\n-  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n-    {\n-      unsigned n_counts;\n-      struct gcov_summary prg; /* summary for this object over all\n-\t\t\t\t  program.  */\n-      struct gcov_ctr_summary *cs_prg, *cs_tprg;\n-#if !GCOV_LOCKED\n-      struct gcov_ctr_summary *cs_all;\n-#endif\n-      int error = 0;\n-      gcov_unsigned_t tag, length;\n-      gcov_position_t summary_pos = 0;\n-      gcov_position_t eof_pos = 0;\n-      const char *fname, *s;\n-      struct gcov_fn_buffer *fn_buffer = 0;\n-      struct gcov_fn_buffer **fn_tail = &fn_buffer;\n-      struct gcov_summary_buffer *next_sum_buffer, *sum_buffer = 0;\n-      struct gcov_summary_buffer **sum_tail = &sum_buffer;\n-\n-      fname = gi_ptr->filename;\n-\n-      /* Avoid to add multiple drive letters into combined path.  */\n-      if (prefix_length != 0 && HAS_DRIVE_SPEC(fname))\n-        fname += 2;\n-\n-      /* Build relocated filename, stripping off leading\n-         directories from the initial filename if requested. */\n-      if (gcov_prefix_strip > 0)\n-        {\n-          int level = 0;\n-          s = fname;\n-          if (IS_DIR_SEPARATOR(*s))\n-            ++s;\n-\n-          /* Skip selected directory levels. */\n-\t  for (; (*s != '\\0') && (level < gcov_prefix_strip); s++)\n-\t    if (IS_DIR_SEPARATOR(*s))\n-\t      {\n-\t\tfname = s;\n-\t\tlevel++;\n-\t      }\n-        }\n-\n-      /* Update complete filename with stripped original. */\n-      if (prefix_length != 0 && !IS_DIR_SEPARATOR (*fname))\n-        {\n-          /* If prefix is given, add directory separator.  */\n-\t  strcpy (gi_filename_up, \"/\");\n-\t  strcpy (gi_filename_up + 1, fname);\n-\t}\n-      else\n-        strcpy (gi_filename_up, fname);\n-\n-      if (!gcov_open (gi_filename))\n-\t{\n-\t  /* Open failed likely due to missed directory.\n-\t     Create directory and retry to open file. */\n-          if (create_file_directory (gi_filename))\n-\t    {\n-\t      fprintf (stderr, \"profiling:%s:Skip\\n\", gi_filename);\n-\t      continue;\n-\t    }\n-\t  if (!gcov_open (gi_filename))\n-\t    {\n-              fprintf (stderr, \"profiling:%s:Cannot open\\n\", gi_filename);\n-\t      continue;\n-\t    }\n-\t}\n-\n-      tag = gcov_read_unsigned ();\n-      if (tag)\n-\t{\n-\t  /* Merge data from file.  */\n-\t  if (tag != GCOV_DATA_MAGIC)\n-\t    {\n-\t      fprintf (stderr, \"profiling:%s:Not a gcov data file\\n\",\n-\t\t       gi_filename);\n-\t      goto read_fatal;\n-\t    }\n-\t  length = gcov_read_unsigned ();\n-\t  if (!gcov_version (gi_ptr, length, gi_filename))\n-\t    goto read_fatal;\n-\n-\t  length = gcov_read_unsigned ();\n-\t  if (length != gi_ptr->stamp)\n-\t    /* Read from a different compilation. Overwrite the file.  */\n-\t    goto rewrite;\n-\n-\t  /* Look for program summary.  */\n-\t  for (f_ix = 0;;)\n-\t    {\n-\t      struct gcov_summary tmp;\n-\t      \n-\t      eof_pos = gcov_position ();\n-\t      tag = gcov_read_unsigned ();\n-\t      if (tag != GCOV_TAG_PROGRAM_SUMMARY)\n-\t\tbreak;\n-\n-\t      f_ix--;\n-\t      length = gcov_read_unsigned ();\n-\t      gcov_read_summary (&tmp);\n-\t      if ((error = gcov_is_error ()))\n-\t\tgoto read_error;\n-\t      if (summary_pos)\n-                {\n-                  /* Save all summaries after the one that will be\n-                     merged into below. These will need to be rewritten\n-                     as histogram merging may change the number of non-zero\n-                     histogram entries that will be emitted, and thus the\n-                     size of the merged summary.  */\n-                  (*sum_tail) = (struct gcov_summary_buffer *)\n-                      malloc (sizeof(struct gcov_summary_buffer));\n-                  (*sum_tail)->summary = tmp;\n-                  (*sum_tail)->next = 0;\n-                  sum_tail = &((*sum_tail)->next);\n-                  goto next_summary;\n-                }\n-\t      if (tmp.checksum != crc32)\n-                goto next_summary;\n-\t      \n-\t      for (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)\n-\t\tif (tmp.ctrs[t_ix].num != this_prg.ctrs[t_ix].num)\n-                  goto next_summary;\n-\t      prg = tmp;\n-\t      summary_pos = eof_pos;\n-\n-\t    next_summary:;\n-\t    }\n-\t  \n-\t  /* Merge execution counts for each function.  */\n-\t  for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions;\n-\t       f_ix++, tag = gcov_read_unsigned ())\n-\t    {\n-\t      gfi_ptr = gi_ptr->functions[f_ix];\n-\n-\t      if (tag != GCOV_TAG_FUNCTION)\n-\t\tgoto read_mismatch;\n-\n-\t      length = gcov_read_unsigned ();\n-\t      if (!length)\n-\t\t/* This function did not appear in the other program.\n-\t\t   We have nothing to merge.  */\n-\t\tcontinue;\n-\n-\t      if (length != GCOV_TAG_FUNCTION_LENGTH)\n-\t\tgoto read_mismatch;\n-\t      \n-\t      if (!gfi_ptr || gfi_ptr->key != gi_ptr)\n-\t\t{\n-\t\t  /* This function appears in the other program.  We\n-\t\t     need to buffer the information in order to write\n-\t\t     it back out -- we'll be inserting data before\n-\t\t     this point, so cannot simply keep the data in the\n-\t\t     file.  */\n-\t\t  fn_tail = buffer_fn_data (gi_filename,\n-\t\t\t\t\t    gi_ptr, fn_tail, f_ix);\n-\t\t  if (!fn_tail)\n-\t\t    goto read_mismatch;\n-\t\t  continue;\n-\t\t}\n-\n-\t      length = gcov_read_unsigned ();\n-\t      if (length != gfi_ptr->ident)\n-\t\tgoto read_mismatch;\n-\t      \n-\t      length = gcov_read_unsigned ();\n-\t      if (length != gfi_ptr->lineno_checksum)\n-\t\tgoto read_mismatch;\n-\t      \n-\t      length = gcov_read_unsigned ();\n-\t      if (length != gfi_ptr->cfg_checksum)\n-\t\tgoto read_mismatch;\n-\t      \n-\t      ci_ptr = gfi_ptr->ctrs;\n-\t      for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)\n-\t\t{\n-\t\t  gcov_merge_fn merge = gi_ptr->merge[t_ix];\n-\n-\t\t  if (!merge)\n-\t\t    continue;\n-\n-\t\t  tag = gcov_read_unsigned ();\n-\t\t  length = gcov_read_unsigned ();\n-\t\t  if (tag != GCOV_TAG_FOR_COUNTER (t_ix)\n-\t\t      || length != GCOV_TAG_COUNTER_LENGTH (ci_ptr->num))\n-\t\t    goto read_mismatch;\n-\t\t  (*merge) (ci_ptr->values, ci_ptr->num);\n-\t\t  ci_ptr++;\n-\t\t}\n-\t      if ((error = gcov_is_error ()))\n-\t\tgoto read_error;\n-\t    }\n-\n-\t  if (tag)\n-\t    {\n-\t    read_mismatch:;\n-\t      fprintf (stderr, \"profiling:%s:Merge mismatch for %s %u\\n\",\n-\t\t       gi_filename, f_ix >= 0 ? \"function\" : \"summary\",\n-\t\t       f_ix < 0 ? -1 - f_ix : f_ix);\n-\t      goto read_fatal;\n-\t    }\n-\t}\n-      goto rewrite;\n-\n-    read_error:;\n-      fprintf (stderr, \"profiling:%s:%s merging\\n\", gi_filename,\n-\t       error < 0 ? \"Overflow\": \"Error\");\n-\n-      goto read_fatal;\n-\n-    rewrite:;\n-      gcov_rewrite ();\n-      if (!summary_pos)\n-\t{\n-\t  memset (&prg, 0, sizeof (prg));\n-\t  summary_pos = eof_pos;\n-\t}\n-\n-      /* Merge the summaries.  */\n-      for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n-\t{\n-\t  cs_prg = &prg.ctrs[t_ix];\n-\t  cs_tprg = &this_prg.ctrs[t_ix];\n-\n-\t  if (gi_ptr->merge[t_ix])\n-\t    {\n-\t      if (!cs_prg->runs++)\n-\t        cs_prg->num = cs_tprg->num;\n-\t      cs_prg->sum_all += cs_tprg->sum_all;\n-\t      if (cs_prg->run_max < cs_tprg->run_max)\n-\t\tcs_prg->run_max = cs_tprg->run_max;\n-\t      cs_prg->sum_max += cs_tprg->run_max;\n-              if (cs_prg->runs == 1)\n-                memcpy (cs_prg->histogram, cs_tprg->histogram,\n-                        sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n-              else\n-                gcov_histogram_merge (cs_prg->histogram, cs_tprg->histogram);\n-\t    }\n-\t  else if (cs_prg->runs)\n-\t    goto read_mismatch;\n-\n-#if !GCOV_LOCKED\n-\t  cs_all = &all_prg.ctrs[t_ix];\n-\t  if (!cs_all->runs && cs_prg->runs)\n-            {\n-              cs_all->num = cs_prg->num;\n-              cs_all->runs = cs_prg->runs;\n-              cs_all->sum_all = cs_prg->sum_all;\n-              cs_all->run_max = cs_prg->run_max;\n-              cs_all->sum_max = cs_prg->sum_max;\n-            }\n-\t  else if (!all_prg.checksum\n-                   /* Don't compare the histograms, which may have slight\n-                      variations depending on the order they were updated\n-                      due to the truncating integer divides used in the\n-                      merge.  */\n-                   && (cs_all->num != cs_prg->num\n-                       || cs_all->runs != cs_prg->runs\n-                       || cs_all->sum_all != cs_prg->sum_all\n-                       || cs_all->run_max != cs_prg->run_max\n-                       || cs_all->sum_max != cs_prg->sum_max))\n-\t    {\n-\t      fprintf (stderr,\n-                       \"profiling:%s:Data file mismatch - some data files may \"\n-                       \"have been concurrently updated without locking support\\n\",\n-\t\t       gi_filename);\n-\t      all_prg.checksum = ~0u;\n-\t    }\n-#endif\n-\t}\n-\n-      prg.checksum = crc32;\n-\n-      /* Write out the data.  */\n-      if (!eof_pos)\n-\t{\n-\t  gcov_write_tag_length (GCOV_DATA_MAGIC, GCOV_VERSION);\n-\t  gcov_write_unsigned (gi_ptr->stamp);\n-\t}\n-\n-      if (summary_pos)\n-\tgcov_seek (summary_pos);\n-\n-      /* Generate whole program statistics.  */\n-      gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &prg);\n-\n-      /* Rewrite all the summaries that were after the summary we merged\n-         into. This is necessary as the merged summary may have a different\n-         size due to the number of non-zero histogram entries changing after\n-         merging.  */\n-      \n-      while (sum_buffer)\n-        {\n-          gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &sum_buffer->summary);\n-          next_sum_buffer = sum_buffer->next;\n-          free (sum_buffer);\n-          sum_buffer = next_sum_buffer;\n-        }\n-\n-      /* Write execution counts for each function.  */\n-      for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions; f_ix++)\n-\t{\n-\t  unsigned buffered = 0;\n-\n-\t  if (fn_buffer && fn_buffer->fn_ix == (unsigned)f_ix)\n-\t    {\n-\t      /* Buffered data from another program.  */\n-\t      buffered = 1;\n-\t      gfi_ptr = &fn_buffer->info;\n-\t      length = GCOV_TAG_FUNCTION_LENGTH;\n-\t    }\n-\t  else\n-\t    {\n-\t      gfi_ptr = gi_ptr->functions[f_ix];\n-\t      if (gfi_ptr && gfi_ptr->key == gi_ptr)\n-\t\tlength = GCOV_TAG_FUNCTION_LENGTH;\n-\t      else\n-\t\tlength = 0;\n-\t    }\n-\t  \n-\t  gcov_write_tag_length (GCOV_TAG_FUNCTION, length);\n-\t  if (!length)\n-\t    continue;\n-\t  \n-\t  gcov_write_unsigned (gfi_ptr->ident);\n-\t  gcov_write_unsigned (gfi_ptr->lineno_checksum);\n-\t  gcov_write_unsigned (gfi_ptr->cfg_checksum);\n-\n-\t  ci_ptr = gfi_ptr->ctrs;\n-\t  for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)\n-\t    {\n-\t      if (!gi_ptr->merge[t_ix])\n-\t\tcontinue;\n-\n-\t      n_counts = ci_ptr->num;\n-\t      gcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),\n-\t\t\t\t     GCOV_TAG_COUNTER_LENGTH (n_counts));\n-\t      gcov_type *c_ptr = ci_ptr->values;\n-\t      while (n_counts--)\n-\t\tgcov_write_counter (*c_ptr++);\n-\t      ci_ptr++;\n-\t    }\n-\t  if (buffered)\n-\t    fn_buffer = free_fn_data (gi_ptr, fn_buffer, GCOV_COUNTERS);\n-\t}\n-\n-      gcov_write_unsigned (0);\n-\n-    read_fatal:;\n-      while (fn_buffer)\n-\tfn_buffer = free_fn_data (gi_ptr, fn_buffer, GCOV_COUNTERS);\n-\n-      if ((error = gcov_close ()))\n-\t  fprintf (stderr, error  < 0 ?\n-\t\t   \"profiling:%s:Overflow writing\\n\" :\n-\t\t   \"profiling:%s:Error writing\\n\",\n-\t\t   gi_filename);\n-    }\n-}\n-\n-/* Reset all counters to zero.  */\n-\n-void\n-gcov_clear (void)\n-{\n-  const struct gcov_info *gi_ptr;\n-\n-  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)\n-    {\n-      unsigned f_ix;\n-\n-      for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)\n-\t{\n-\t  unsigned t_ix;\n-\t  const struct gcov_fn_info *gfi_ptr = gi_ptr->functions[f_ix];\n-\n-\t  if (!gfi_ptr || gfi_ptr->key != gi_ptr)\n-\t    continue;\n-\t  const struct gcov_ctr_info *ci_ptr = gfi_ptr->ctrs;\n-\t  for (t_ix = 0; t_ix != GCOV_COUNTERS; t_ix++)\n-\t    {\n-\t      if (!gi_ptr->merge[t_ix])\n-\t\tcontinue;\n-\t      \n-\t      memset (ci_ptr->values, 0, sizeof (gcov_type) * ci_ptr->num);\n-\t      ci_ptr++;\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Add a new object file onto the bb chain.  Invoked automatically\n-   when running an object file's global ctors.  */\n-\n-void\n-__gcov_init (struct gcov_info *info)\n-{\n-  if (!info->version || !info->n_functions)\n-    return;\n-  if (gcov_version (info, info->version, 0))\n-    {\n-      size_t filename_length = strlen(info->filename);\n-\n-      /* Refresh the longest file name information */\n-      if (filename_length > gcov_max_filename)\n-        gcov_max_filename = filename_length;\n-\n-      if (!gcov_list)\n-\tatexit (gcov_exit);\n-\n-      info->next = gcov_list;\n-      gcov_list = info;\n-    }\n-  info->version = 0;\n-}\n-\n-#ifdef __GTHREAD_MUTEX_INIT\n-ATTRIBUTE_HIDDEN __gthread_mutex_t __gcov_flush_mx = __GTHREAD_MUTEX_INIT;\n-#define init_mx_once()\n-#else\n-__gthread_mutex_t __gcov_flush_mx ATTRIBUTE_HIDDEN;\n-\n-static void\n-init_mx (void)\n-{\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&__gcov_flush_mx);\n-}\n-static void\n-init_mx_once (void)\n-{\n-  static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n-  __gthread_once (&once, init_mx);\n-}\n-#endif\n-\n-/* Called before fork or exec - write out profile information gathered so\n-   far and reset it to zero.  This avoids duplication or loss of the\n-   profile information gathered so far.  */\n-\n-void\n-__gcov_flush (void)\n-{\n-  init_mx_once ();\n-  __gthread_mutex_lock (&__gcov_flush_mx);\n-\n-  gcov_exit ();\n-  gcov_clear ();\n-\n-  __gthread_mutex_unlock (&__gcov_flush_mx);\n-}\n-\n-#endif /* L_gcov */\n-\n-#ifdef L_gcov_reset\n-\n-/* Function that can be called from application to reset counters to zero,\n-   in order to collect profile in region of interest.  */\n-\n-void\n-__gcov_reset (void)\n-{\n-  gcov_clear ();\n-  /* Re-enable dumping to support collecting profile in multiple regions\n-     of interest.  */\n-  gcov_dump_complete = 0;\n-}\n-\n-#endif /* L_gcov_reset */\n-\n-#ifdef L_gcov_dump\n-\n-/* Function that can be called from application to write profile collected\n-   so far, in order to collect profile in region of interest.  */\n-\n-void\n-__gcov_dump (void)\n-{\n-  gcov_exit ();\n-  /* Prevent profile from being dumped a second time on application exit.  */\n-  gcov_dump_complete = 1;\n-}\n-\n-#endif /* L_gcov_dump */\n-\n-#ifdef L_gcov_merge_add\n-/* The profile merging function that just adds the counters.  It is given\n-   an array COUNTERS of N_COUNTERS old counters and it reads the same number\n-   of counters from the gcov file.  */\n-void\n-__gcov_merge_add (gcov_type *counters, unsigned n_counters)\n-{\n-  for (; n_counters; counters++, n_counters--)\n-    *counters += gcov_read_counter ();\n-}\n-#endif /* L_gcov_merge_add */\n-\n-#ifdef L_gcov_merge_ior\n-/* The profile merging function that just adds the counters.  It is given\n-   an array COUNTERS of N_COUNTERS old counters and it reads the same number\n-   of counters from the gcov file.  */\n-void\n-__gcov_merge_ior (gcov_type *counters, unsigned n_counters)\n-{\n-  for (; n_counters; counters++, n_counters--)\n-    *counters |= gcov_read_counter ();\n-}\n-#endif\n-\n-/* Time profiles are merged so that minimum from all valid (greater than zero)\n- * is stored. There could be a fork that creates new counters. To have\n- * the profile stable, we chosen to pick the smallest function visit time.  */\n-\n-#ifdef L_gcov_merge_time_profile\n-void\n-__gcov_merge_time_profile (gcov_type *counters, unsigned n_counters)\n-{\n-  unsigned int i;\n-  gcov_type value;\n-\n-  for (i = 0; i < n_counters; i++)\n-  {\n-    value = gcov_read_counter ();\n-\n-    if (value && (!counters[i] || value < counters[i]))\n-      counters[i] = value;\n-  }\n-}\n-#endif /* L_gcov_merge_time_profile */\n-\n-#ifdef L_gcov_merge_single\n-/* The profile merging function for choosing the most common value.\n-   It is given an array COUNTERS of N_COUNTERS old counters and it\n-   reads the same number of counters from the gcov file.  The counters\n-   are split into 3-tuples where the members of the tuple have\n-   meanings:\n-\n-   -- the stored candidate on the most common value of the measured entity\n-   -- counter\n-   -- total number of evaluations of the value  */\n-void\n-__gcov_merge_single (gcov_type *counters, unsigned n_counters)\n-{\n-  unsigned i, n_measures;\n-  gcov_type value, counter, all;\n-\n-  gcc_assert (!(n_counters % 3));\n-  n_measures = n_counters / 3;\n-  for (i = 0; i < n_measures; i++, counters += 3)\n-    {\n-      value = gcov_read_counter ();\n-      counter = gcov_read_counter ();\n-      all = gcov_read_counter ();\n-\n-      if (counters[0] == value)\n-\tcounters[1] += counter;\n-      else if (counter > counters[1])\n-\t{\n-\t  counters[0] = value;\n-\t  counters[1] = counter - counters[1];\n-\t}\n-      else\n-\tcounters[1] -= counter;\n-      counters[2] += all;\n-    }\n-}\n-#endif /* L_gcov_merge_single */\n-\n-#ifdef L_gcov_merge_delta\n-/* The profile merging function for choosing the most common\n-   difference between two consecutive evaluations of the value.  It is\n-   given an array COUNTERS of N_COUNTERS old counters and it reads the\n-   same number of counters from the gcov file.  The counters are split\n-   into 4-tuples where the members of the tuple have meanings:\n-\n-   -- the last value of the measured entity\n-   -- the stored candidate on the most common difference\n-   -- counter\n-   -- total number of evaluations of the value  */\n-void\n-__gcov_merge_delta (gcov_type *counters, unsigned n_counters)\n-{\n-  unsigned i, n_measures;\n-  gcov_type value, counter, all;\n-\n-  gcc_assert (!(n_counters % 4));\n-  n_measures = n_counters / 4;\n-  for (i = 0; i < n_measures; i++, counters += 4)\n-    {\n-      /* last = */ gcov_read_counter ();\n-      value = gcov_read_counter ();\n-      counter = gcov_read_counter ();\n-      all = gcov_read_counter ();\n-\n-      if (counters[1] == value)\n-\tcounters[2] += counter;\n-      else if (counter > counters[2])\n-\t{\n-\t  counters[1] = value;\n-\t  counters[2] = counter - counters[2];\n-\t}\n-      else\n-\tcounters[2] -= counter;\n-      counters[3] += all;\n-    }\n-}\n-#endif /* L_gcov_merge_delta */\n-\n-#ifdef L_gcov_interval_profiler\n-/* If VALUE is in interval <START, START + STEPS - 1>, then increases the\n-   corresponding counter in COUNTERS.  If the VALUE is above or below\n-   the interval, COUNTERS[STEPS] or COUNTERS[STEPS + 1] is increased\n-   instead.  */\n-\n-void\n-__gcov_interval_profiler (gcov_type *counters, gcov_type value,\n-\t\t\t  int start, unsigned steps)\n-{\n-  gcov_type delta = value - start;\n-  if (delta < 0)\n-    counters[steps + 1]++;\n-  else if (delta >= steps)\n-    counters[steps]++;\n-  else\n-    counters[delta]++;\n-}\n-#endif\n-\n-#ifdef L_gcov_pow2_profiler\n-/* If VALUE is a power of two, COUNTERS[1] is incremented.  Otherwise\n-   COUNTERS[0] is incremented.  */\n-\n-void\n-__gcov_pow2_profiler (gcov_type *counters, gcov_type value)\n-{\n-  if (value & (value - 1))\n-    counters[0]++;\n-  else\n-    counters[1]++;\n-}\n-#endif\n-\n-/* Tries to determine the most common value among its inputs.  Checks if the\n-   value stored in COUNTERS[0] matches VALUE.  If this is the case, COUNTERS[1]\n-   is incremented.  If this is not the case and COUNTERS[1] is not zero,\n-   COUNTERS[1] is decremented.  Otherwise COUNTERS[1] is set to one and\n-   VALUE is stored to COUNTERS[0].  This algorithm guarantees that if this\n-   function is called more than 50% of the time with one value, this value\n-   will be in COUNTERS[0] in the end.\n-\n-   In any case, COUNTERS[2] is incremented.  */\n-\n-static inline void\n-__gcov_one_value_profiler_body (gcov_type *counters, gcov_type value)\n-{\n-  if (value == counters[0])\n-    counters[1]++;\n-  else if (counters[1] == 0)\n-    {\n-      counters[1] = 1;\n-      counters[0] = value;\n-    }\n-  else\n-    counters[1]--;\n-  counters[2]++;\n-}\n-\n-#ifdef L_gcov_one_value_profiler\n-void\n-__gcov_one_value_profiler (gcov_type *counters, gcov_type value)\n-{\n-  __gcov_one_value_profiler_body (counters, value);\n-}\n-#endif\n-\n-#ifdef L_gcov_indirect_call_profiler\n-/* This function exist only for workaround of binutils bug 14342.\n-   Once this compatibility hack is obsolette, it can be removed.  */\n-\n-/* By default, the C++ compiler will use function addresses in the\n-   vtable entries.  Setting TARGET_VTABLE_USES_DESCRIPTORS to nonzero\n-   tells the compiler to use function descriptors instead.  The value\n-   of this macro says how many words wide the descriptor is (normally 2),\n-   but it may be dependent on target flags.  Since we do not have access\n-   to the target flags here we just check to see if it is set and use\n-   that to set VTABLE_USES_DESCRIPTORS to 0 or 1.\n-\n-   It is assumed that the address of a function descriptor may be treated\n-   as a pointer to a function.  */\n-\n-#ifdef TARGET_VTABLE_USES_DESCRIPTORS\n-#define VTABLE_USES_DESCRIPTORS 1\n-#else\n-#define VTABLE_USES_DESCRIPTORS 0\n-#endif\n-\n-/* Tries to determine the most common value among its inputs. */\n-void\n-__gcov_indirect_call_profiler (gcov_type* counter, gcov_type value,\n-                               void* cur_func, void* callee_func)\n-{\n-  /* If the C++ virtual tables contain function descriptors then one\n-     function may have multiple descriptors and we need to dereference\n-     the descriptors to see if they point to the same function.  */\n-  if (cur_func == callee_func\n-      || (VTABLE_USES_DESCRIPTORS && callee_func\n-          && *(void **) cur_func == *(void **) callee_func))\n-    __gcov_one_value_profiler_body (counter, value);\n-}\n-\n-#endif\n-#ifdef L_gcov_indirect_call_profiler_v2\n-\n-/* These two variables are used to actually track caller and callee.  Keep\n-   them in TLS memory so races are not common (they are written to often).\n-   The variables are set directly by GCC instrumented code, so declaration\n-   here must match one in tree-profile.c  */\n-\n-#if defined(HAVE_CC_TLS) && !defined (USE_EMUTLS)\n-__thread \n-#endif\n-void * __gcov_indirect_call_callee;\n-#if defined(HAVE_CC_TLS) && !defined (USE_EMUTLS) \n-__thread \n-#endif\n-gcov_type * __gcov_indirect_call_counters;\n-\n-/* By default, the C++ compiler will use function addresses in the\n-   vtable entries.  Setting TARGET_VTABLE_USES_DESCRIPTORS to nonzero\n-   tells the compiler to use function descriptors instead.  The value\n-   of this macro says how many words wide the descriptor is (normally 2),\n-   but it may be dependent on target flags.  Since we do not have access\n-   to the target flags here we just check to see if it is set and use\n-   that to set VTABLE_USES_DESCRIPTORS to 0 or 1.\n-\n-   It is assumed that the address of a function descriptor may be treated\n-   as a pointer to a function.  */\n-\n-#ifdef TARGET_VTABLE_USES_DESCRIPTORS\n-#define VTABLE_USES_DESCRIPTORS 1\n-#else\n-#define VTABLE_USES_DESCRIPTORS 0\n-#endif\n-\n-/* Tries to determine the most common value among its inputs. */\n-void\n-__gcov_indirect_call_profiler_v2 (gcov_type value, void* cur_func)\n-{\n-  /* If the C++ virtual tables contain function descriptors then one\n-     function may have multiple descriptors and we need to dereference\n-     the descriptors to see if they point to the same function.  */\n-  if (cur_func == __gcov_indirect_call_callee\n-      || (VTABLE_USES_DESCRIPTORS && __gcov_indirect_call_callee\n-\t  && *(void **) cur_func == *(void **) __gcov_indirect_call_callee))\n-    __gcov_one_value_profiler_body (__gcov_indirect_call_counters, value);\n-}\n-#endif\n-\n-#ifdef L_gcov_time_profiler\n-\n-/* Sets corresponding COUNTERS if there is no value.  */\n-\n-void\n-__gcov_time_profiler (gcov_type* counters)\n-{\n-  if (!counters[0])\n-    counters[0] = ++function_counter;\n-}\n-#endif\n-\n-#ifdef L_gcov_average_profiler\n-/* Increase corresponding COUNTER by VALUE.  FIXME: Perhaps we want\n-   to saturate up.  */\n-\n-void\n-__gcov_average_profiler (gcov_type *counters, gcov_type value)\n-{\n-  counters[0] += value;\n-  counters[1] ++;\n-}\n-#endif\n-\n-#ifdef L_gcov_ior_profiler\n-/* Bitwise-OR VALUE into COUNTER.  */\n-\n-void\n-__gcov_ior_profiler (gcov_type *counters, gcov_type value)\n-{\n-  *counters |= value;\n-}\n-#endif\n-\n-#ifdef L_gcov_fork\n-/* A wrapper for the fork function.  Flushes the accumulated profiling data, so\n-   that they are not counted twice.  */\n-\n-pid_t\n-__gcov_fork (void)\n-{\n-  pid_t pid;\n-  extern __gthread_mutex_t __gcov_flush_mx;\n-  __gcov_flush ();\n-  pid = fork ();\n-  if (pid == 0)\n-    __GTHREAD_MUTEX_INIT_FUNCTION (&__gcov_flush_mx);\n-  return pid;\n-}\n-#endif\n-\n-#ifdef L_gcov_execl\n-/* A wrapper for the execl function.  Flushes the accumulated profiling data, so\n-   that they are not lost.  */\n-\n-int\n-__gcov_execl (const char *path, char *arg, ...)\n-{\n-  va_list ap, aq;\n-  unsigned i, length;\n-  char **args;\n-\n-  __gcov_flush ();\n-\n-  va_start (ap, arg);\n-  va_copy (aq, ap);\n-\n-  length = 2;\n-  while (va_arg (ap, char *))\n-    length++;\n-  va_end (ap);\n-\n-  args = (char **) alloca (length * sizeof (void *));\n-  args[0] = arg;\n-  for (i = 1; i < length; i++)\n-    args[i] = va_arg (aq, char *);\n-  va_end (aq);\n-\n-  return execv (path, args);\n-}\n-#endif\n-\n-#ifdef L_gcov_execlp\n-/* A wrapper for the execlp function.  Flushes the accumulated profiling data, so\n-   that they are not lost.  */\n-\n-int\n-__gcov_execlp (const char *path, char *arg, ...)\n-{\n-  va_list ap, aq;\n-  unsigned i, length;\n-  char **args;\n-\n-  __gcov_flush ();\n-\n-  va_start (ap, arg);\n-  va_copy (aq, ap);\n-\n-  length = 2;\n-  while (va_arg (ap, char *))\n-    length++;\n-  va_end (ap);\n-\n-  args = (char **) alloca (length * sizeof (void *));\n-  args[0] = arg;\n-  for (i = 1; i < length; i++)\n-    args[i] = va_arg (aq, char *);\n-  va_end (aq);\n-\n-  return execvp (path, args);\n-}\n-#endif\n-\n-#ifdef L_gcov_execle\n-/* A wrapper for the execle function.  Flushes the accumulated profiling data, so\n-   that they are not lost.  */\n-\n-int\n-__gcov_execle (const char *path, char *arg, ...)\n-{\n-  va_list ap, aq;\n-  unsigned i, length;\n-  char **args;\n-  char **envp;\n-\n-  __gcov_flush ();\n-\n-  va_start (ap, arg);\n-  va_copy (aq, ap);\n-\n-  length = 2;\n-  while (va_arg (ap, char *))\n-    length++;\n-  va_end (ap);\n-\n-  args = (char **) alloca (length * sizeof (void *));\n-  args[0] = arg;\n-  for (i = 1; i < length; i++)\n-    args[i] = va_arg (aq, char *);\n-  envp = va_arg (aq, char **);\n-  va_end (aq);\n-\n-  return execve (path, args, envp);\n-}\n-#endif\n-\n-#ifdef L_gcov_execv\n-/* A wrapper for the execv function.  Flushes the accumulated profiling data, so\n-   that they are not lost.  */\n-\n-int\n-__gcov_execv (const char *path, char *const argv[])\n-{\n-  __gcov_flush ();\n-  return execv (path, argv);\n-}\n-#endif\n-\n-#ifdef L_gcov_execvp\n-/* A wrapper for the execvp function.  Flushes the accumulated profiling data, so\n-   that they are not lost.  */\n-\n-int\n-__gcov_execvp (const char *path, char *const argv[])\n-{\n-  __gcov_flush ();\n-  return execvp (path, argv);\n-}\n-#endif\n-\n-#ifdef L_gcov_execve\n-/* A wrapper for the execve function.  Flushes the accumulated profiling data, so\n-   that they are not lost.  */\n-\n-int\n-__gcov_execve (const char *path, char *const argv[], char *const envp[])\n-{\n-  __gcov_flush ();\n-  return execve (path, argv, envp);\n-}\n-#endif\n-#endif /* inhibit_libc */"}]}