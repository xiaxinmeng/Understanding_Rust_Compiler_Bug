{"sha": "94c6d6fd7559167d3dc13698dbd58f27fb46cde4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRjNmQ2ZmQ3NTU5MTY3ZDNkYzEzNjk4ZGJkNThmMjdmYjQ2Y2RlNA==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2021-03-15T23:27:34Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-06-18T08:36:49Z"}, "message": "[Ada] Add documentation for the array fixed-lower-bound feature\n\ngcc/ada/\n\n\t* doc/gnat_rm/implementation_defined_pragmas.rst: Add\n\tdocumentation for the array fixed-lower-bound feature.\n\t* gnat_rm.texi: Regenerate.", "tree": {"sha": "c0731eeab3186e26061523af1151023cf9181722", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0731eeab3186e26061523af1151023cf9181722"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94c6d6fd7559167d3dc13698dbd58f27fb46cde4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94c6d6fd7559167d3dc13698dbd58f27fb46cde4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94c6d6fd7559167d3dc13698dbd58f27fb46cde4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94c6d6fd7559167d3dc13698dbd58f27fb46cde4/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73b670e3b1b6a2c0ecfba711401210a284fce0c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73b670e3b1b6a2c0ecfba711401210a284fce0c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73b670e3b1b6a2c0ecfba711401210a284fce0c6"}], "stats": {"total": 105, "additions": 97, "deletions": 8}, "files": [{"sha": "b4da3084ab2a58b221a23db5ba9c188232591a10", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94c6d6fd7559167d3dc13698dbd58f27fb46cde4/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94c6d6fd7559167d3dc13698dbd58f27fb46cde4/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=94c6d6fd7559167d3dc13698dbd58f27fb46cde4", "patch": "@@ -2210,7 +2210,7 @@ extension mode (the use of Off as a parameter cancels the effect\n of the *-gnatX* command switch).\n \n In extension mode, the latest version of the Ada language is\n-implemented (currently Ada 202x), and in addition a small number\n+implemented (currently Ada 2022), and in addition a number\n of GNAT specific extensions are recognized as follows:\n \n * Constrained attribute for generic objects\n@@ -2235,7 +2235,7 @@ of GNAT specific extensions are recognized as follows:\n   This new aggregate syntax for arrays and containers is provided under -gnatX\n   to experiment and confirm this new language syntax.\n \n-* Casing on composite values\n+* Casing on composite values (aka pattern matching)\n \n   The selector for a case statement may be of a composite type, subject to\n   some restrictions (described below). Aggregate syntax is used for choices\n@@ -2246,7 +2246,7 @@ of GNAT specific extensions are recognized as follows:\n \n   Consider this example:\n \n-   .. code-block:: ada\n+  .. code-block:: ada\n \n       type Rec is record\n          F1, F2 : Integer;\n@@ -2322,6 +2322,50 @@ of GNAT specific extensions are recognized as follows:\n   for a given identifer must all statically match. Currently, the case\n   of a binding for a nondiscrete component is not implemented.\n \n+* Fixed lower bounds for array types and subtypes\n+\n+  Unconstrained array types and subtypes can be specified with a lower bound\n+  that is fixed to a certain value, by writing an index range that uses the\n+  syntax \"<lower-bound-expression> .. <>\". This guarantees that all objects\n+  of the type or subtype will have the specified lower bound.\n+\n+  For example, a matrix type with fixed lower bounds of zero for each\n+  dimension can be declared by the following:\n+\n+  .. code-block:: ada\n+\n+      type Matrix is\n+        array (Natural range 0 .. <>, Natural range 0 .. <>) of Integer;\n+\n+  Objects of type Matrix declared with an index constraint must have index\n+  ranges starting at zero:\n+\n+  .. code-block:: ada\n+\n+      M1 : Matrix (0 .. 9, 0 .. 19);\n+      M2 : Matrix (2 .. 11, 3 .. 22);  -- Warning about bounds; will raise CE\n+\n+  Similarly, a subtype of String can be declared that specifies the lower\n+  bound of objects of that subtype to be 1:\n+\n+   .. code-block:: ada\n+\n+      subtype String_1 is String (1 .. <>);\n+\n+  If a string slice is passed to a formal of subtype String_1 in a call to\n+  a subprogram S, the slice's bounds will \"slide\" so that the lower bound\n+  is 1. Within S, the lower bound of the formal is known to be 1, so, unlike\n+  a normal unconstrained String formal, there is no need to worry about\n+  accounting for other possible lower-bound values. Sliding of bounds also\n+  occurs in other contexts, such as for object declarations with an\n+  unconstrained subtype with fixed lower bound, as well as in subtype\n+  conversions.\n+\n+  Use of this feature increases safety by simplifying code, and can also\n+  improve the efficiency of indexing operations, since the compiler statically\n+  knows the lower bound of unconstrained array formals when the formal's\n+  subtype has index ranges with static fixed lower bounds.\n+\n .. _Pragma-Extensions_Visible:\n \n Pragma Extensions_Visible"}, {"sha": "471d40f8754a387a95392e658397f49960200e95", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94c6d6fd7559167d3dc13698dbd58f27fb46cde4/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94c6d6fd7559167d3dc13698dbd58f27fb46cde4/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=94c6d6fd7559167d3dc13698dbd58f27fb46cde4", "patch": "@@ -3632,7 +3632,7 @@ extension mode (the use of Off as a parameter cancels the effect\n of the @emph{-gnatX} command switch).\n \n In extension mode, the latest version of the Ada language is\n-implemented (currently Ada 202x), and in addition a small number\n+implemented (currently Ada 2022), and in addition a number\n of GNAT specific extensions are recognized as follows:\n \n \n@@ -3665,7 +3665,7 @@ This new aggregate syntax for arrays and containers is provided under -gnatX\n to experiment and confirm this new language syntax.\n \n @item \n-Casing on composite values\n+Casing on composite values (aka pattern matching)\n \n The selector for a case statement may be of a composite type, subject to\n some restrictions (described below). Aggregate syntax is used for choices\n@@ -3676,8 +3676,6 @@ for discrete subcomponents).\n \n Consider this example:\n \n-@quotation\n-\n @example\n type Rec is record\n    F1, F2 : Integer;\n@@ -3695,7 +3693,6 @@ begin\n    end case;\n end Caser_1;\n @end example\n-@end quotation\n \n If Caser_1 is called and both components of X are positive, then\n Do_This will be called; otherwise, if either component is nonnegative\n@@ -3754,6 +3751,54 @@ Within the choice list for single alternative, each choice must\n define the same set of bindings and the component subtypes for\n for a given identifer must all statically match. Currently, the case\n of a binding for a nondiscrete component is not implemented.\n+\n+@item \n+Fixed lower bounds for array types and subtypes\n+\n+Unconstrained array types and subtypes can be specified with a lower bound\n+that is fixed to a certain value, by writing an index range that uses the\n+syntax \"<lower-bound-expression> .. <>\". This guarantees that all objects\n+of the type or subtype will have the specified lower bound.\n+\n+For example, a matrix type with fixed lower bounds of zero for each\n+dimension can be declared by the following:\n+\n+@example\n+type Matrix is\n+  array (Natural range 0 .. <>, Natural range 0 .. <>) of Integer;\n+@end example\n+\n+Objects of type Matrix declared with an index constraint must have index\n+ranges starting at zero:\n+\n+@example\n+M1 : Matrix (0 .. 9, 0 .. 19);\n+M2 : Matrix (2 .. 11, 3 .. 22);  -- Warning about bounds; will raise CE\n+@end example\n+\n+Similarly, a subtype of String can be declared that specifies the lower\n+bound of objects of that subtype to be 1:\n+\n+@quotation\n+\n+@example\n+subtype String_1 is String (1 .. <>);\n+@end example\n+@end quotation\n+\n+If a string slice is passed to a formal of subtype String_1 in a call to\n+a subprogram S, the slice's bounds will \"slide\" so that the lower bound\n+is 1. Within S, the lower bound of the formal is known to be 1, so, unlike\n+a normal unconstrained String formal, there is no need to worry about\n+accounting for other possible lower-bound values. Sliding of bounds also\n+occurs in other contexts, such as for object declarations with an\n+unconstrained subtype with fixed lower bound, as well as in subtype\n+conversions.\n+\n+Use of this feature increases safety by simplifying code, and can also\n+improve the efficiency of indexing operations, since the compiler statically\n+knows the lower bound of unconstrained array formals when the formal's\n+subtype has index ranges with static fixed lower bounds.\n @end itemize\n \n @node Pragma Extensions_Visible,Pragma External,Pragma Extensions_Allowed,Implementation Defined Pragmas"}]}