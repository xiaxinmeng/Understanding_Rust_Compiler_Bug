{"sha": "e5cf5e116da6f5c018ecc8f714935877c4636780", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVjZjVlMTE2ZGE2ZjVjMDE4ZWNjOGY3MTQ5MzU4NzdjNDYzNjc4MA==", "commit": {"author": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2017-11-28T18:52:49Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-11-28T18:52:49Z"}, "message": "[PR 82808] Use proper result types for arithmetic jump functions\n\n2017-11-28  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n\t    Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/82808\n\t* tree.h (expr_type_first_operand_type_p): Declare\n\t* tree.c (expr_type_first_operand_type_p): New function.\n\t* ipa-prop.h (ipa_get_type): Allow i to be out of bounds.\n\t(ipa_value_from_jfunc): Adjust declaration.\n\t* ipa-cp.c (ipa_get_jf_pass_through_result): New parameter RES_TYPE.\n\tUse it as result type for arithmetics, unless it is NULL in which case\n\tbe more conservative.\n\t(ipa_value_from_jfunc): New parameter PARM_TYPE, pass it to\n\tipa_get_jf_pass_through_result.\n\t(propagate_vals_across_pass_through): Likewise.\n\t(propagate_scalar_across_jump_function): New parameter PARM_TYPE, pass\n\tis to propagate_vals_across_pass_through.\n\t(propagate_constants_across_call): Pass PARM_TYPE to\n\tpropagate_scalar_across_jump_function.\n\t(find_more_scalar_values_for_callers_subset): Pass parameter type to\n\tipa_value_from_jfunc.\n\t(cgraph_edge_brings_all_scalars_for_node): Likewise.\n\t* ipa-fnsummary.c (evaluate_properties_for_edge): Renamed parms_info\n\tto caller_parms_info, pass parameter type to ipa_value_from_jfunc.\n\t* ipa-prop.c (try_make_edge_direct_simple_call): New parameter\n\ttarget_type, pass it to ipa_value_from_jfunc.\n\t(update_indirect_edges_after_inlining): Pass parameter type to\n\ttry_make_edge_direct_simple_call.\n\ntestsuite/\n\t* gcc.dg/ipa/pr82808.c: New test.\n\n\nCo-Authored-By: Martin Jambor <mjambor@suse.cz>\n\nFrom-SVN: r255212", "tree": {"sha": "388b7b37472dc993932261974e447d795dcdf3c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/388b7b37472dc993932261974e447d795dcdf3c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5cf5e116da6f5c018ecc8f714935877c4636780", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5cf5e116da6f5c018ecc8f714935877c4636780", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5cf5e116da6f5c018ecc8f714935877c4636780", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5cf5e116da6f5c018ecc8f714935877c4636780/comments", "author": null, "committer": null, "parents": [{"sha": "5e4a80e8a80584741b1e5dd73b936b15862e9171", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e4a80e8a80584741b1e5dd73b936b15862e9171", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e4a80e8a80584741b1e5dd73b936b15862e9171"}], "stats": {"total": 213, "additions": 172, "deletions": 41}, "files": [{"sha": "52903c27c81d72fd24280e7e2644e8ab8673016b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5cf5e116da6f5c018ecc8f714935877c4636780", "patch": "@@ -1,3 +1,31 @@\n+2017-11-28  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\t    Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/82808\n+\t* tree.h (expr_type_first_operand_type_p): Declare\n+\t* tree.c (expr_type_first_operand_type_p): New function.\n+\t* ipa-prop.h (ipa_get_type): Allow i to be out of bounds.\n+\t(ipa_value_from_jfunc): Adjust declaration.\n+\t* ipa-cp.c (ipa_get_jf_pass_through_result): New parameter RES_TYPE.\n+\tUse it as result type for arithmetics, unless it is NULL in which case\n+\tbe more conservative.\n+\t(ipa_value_from_jfunc): New parameter PARM_TYPE, pass it to\n+\tipa_get_jf_pass_through_result.\n+\t(propagate_vals_across_pass_through): Likewise.\n+\t(propagate_scalar_across_jump_function): New parameter PARM_TYPE, pass\n+\tis to propagate_vals_across_pass_through.\n+\t(propagate_constants_across_call): Pass PARM_TYPE to\n+\tpropagate_scalar_across_jump_function.\n+\t(find_more_scalar_values_for_callers_subset): Pass parameter type to\n+\tipa_value_from_jfunc.\n+\t(cgraph_edge_brings_all_scalars_for_node): Likewise.\n+\t* ipa-fnsummary.c (evaluate_properties_for_edge): Renamed parms_info\n+\tto caller_parms_info, pass parameter type to ipa_value_from_jfunc.\n+\t* ipa-prop.c (try_make_edge_direct_simple_call): New parameter\n+\ttarget_type, pass it to ipa_value_from_jfunc.\n+\t(update_indirect_edges_after_inlining): Pass parameter type to\n+\ttry_make_edge_direct_simple_call.\n+\n 2017-11-28  Jeff Law  <law@redhat.com>\n \n \t* gimple-ssa-evrp-analyze.c"}, {"sha": "aa9e300d37830cb24592f47ff97af7424ac1fa73", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=e5cf5e116da6f5c018ecc8f714935877c4636780", "patch": "@@ -1220,33 +1220,38 @@ initialize_node_lattices (struct cgraph_node *node)\n }\n \n /* Return the result of a (possibly arithmetic) pass through jump function\n-   JFUNC on the constant value INPUT.  Return NULL_TREE if that cannot be\n+   JFUNC on the constant value INPUT.  RES_TYPE is the type of the parameter\n+   to which the result is passed.  Return NULL_TREE if that cannot be\n    determined or be considered an interprocedural invariant.  */\n \n static tree\n-ipa_get_jf_pass_through_result (struct ipa_jump_func *jfunc, tree input)\n+ipa_get_jf_pass_through_result (struct ipa_jump_func *jfunc, tree input,\n+\t\t\t\ttree res_type)\n {\n-  tree restype, res;\n+  tree res;\n \n   if (ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n     return input;\n   if (!is_gimple_ip_invariant (input))\n     return NULL_TREE;\n \n-  if (TREE_CODE_CLASS (ipa_get_jf_pass_through_operation (jfunc))\n-      == tcc_unary)\n-    res = fold_unary (ipa_get_jf_pass_through_operation (jfunc),\n-\t\t      TREE_TYPE (input), input);\n-  else\n+  tree_code opcode = ipa_get_jf_pass_through_operation (jfunc);\n+  if (!res_type)\n     {\n-      if (TREE_CODE_CLASS (ipa_get_jf_pass_through_operation (jfunc))\n-\t  == tcc_comparison)\n-\trestype = boolean_type_node;\n+      if (TREE_CODE_CLASS (opcode) == tcc_comparison)\n+\tres_type = boolean_type_node;\n+      else if (expr_type_first_operand_type_p (opcode))\n+\tres_type = TREE_TYPE (input);\n       else\n-\trestype = TREE_TYPE (input);\n-      res = fold_binary (ipa_get_jf_pass_through_operation (jfunc), restype,\n-\t\t\t input, ipa_get_jf_pass_through_operand (jfunc));\n+\treturn NULL_TREE;\n     }\n+\n+  if (TREE_CODE_CLASS (opcode) == tcc_unary)\n+    res = fold_unary (opcode, res_type, input);\n+  else\n+    res = fold_binary (opcode, res_type, input,\n+\t\t       ipa_get_jf_pass_through_operand (jfunc));\n+\n   if (res && !is_gimple_ip_invariant (res))\n     return NULL_TREE;\n \n@@ -1275,10 +1280,12 @@ ipa_get_jf_ancestor_result (struct ipa_jump_func *jfunc, tree input)\n /* Determine whether JFUNC evaluates to a single known constant value and if\n    so, return it.  Otherwise return NULL.  INFO describes the caller node or\n    the one it is inlined to, so that pass-through jump functions can be\n-   evaluated.  */\n+   evaluated.  PARM_TYPE is the type of the parameter to which the result is\n+   passed.  */\n \n tree\n-ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n+ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc,\n+\t\t      tree parm_type)\n {\n   if (jfunc->type == IPA_JF_CONST)\n     return ipa_get_jf_constant (jfunc);\n@@ -1312,7 +1319,7 @@ ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n \treturn NULL_TREE;\n \n       if (jfunc->type == IPA_JF_PASS_THROUGH)\n-\treturn ipa_get_jf_pass_through_result (jfunc, input);\n+\treturn ipa_get_jf_pass_through_result (jfunc, input, parm_type);\n       else\n \treturn ipa_get_jf_ancestor_result (jfunc, input);\n     }\n@@ -1562,12 +1569,14 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n \n /* Propagate values through a pass-through jump function JFUNC associated with\n    edge CS, taking values from SRC_LAT and putting them into DEST_LAT.  SRC_IDX\n-   is the index of the source parameter.  */\n+   is the index of the source parameter.  PARM_TYPE is the type of the\n+   parameter to which the result is passed.  */\n \n static bool\n propagate_vals_across_pass_through (cgraph_edge *cs, ipa_jump_func *jfunc,\n \t\t\t\t    ipcp_lattice<tree> *src_lat,\n-\t\t\t\t    ipcp_lattice<tree> *dest_lat, int src_idx)\n+\t\t\t\t    ipcp_lattice<tree> *dest_lat, int src_idx,\n+\t\t\t\t    tree parm_type)\n {\n   ipcp_value<tree> *src_val;\n   bool ret = false;\n@@ -1581,7 +1590,8 @@ propagate_vals_across_pass_through (cgraph_edge *cs, ipa_jump_func *jfunc,\n   else\n     for (src_val = src_lat->values; src_val; src_val = src_val->next)\n       {\n-\ttree cstval = ipa_get_jf_pass_through_result (jfunc, src_val->value);\n+\ttree cstval = ipa_get_jf_pass_through_result (jfunc, src_val->value,\n+\t\t\t\t\t\t      parm_type);\n \n \tif (cstval)\n \t  ret |= dest_lat->add_value (cstval, cs, src_val, src_idx);\n@@ -1622,12 +1632,14 @@ propagate_vals_across_ancestor (struct cgraph_edge *cs,\n }\n \n /* Propagate scalar values across jump function JFUNC that is associated with\n-   edge CS and put the values into DEST_LAT.  */\n+   edge CS and put the values into DEST_LAT.  PARM_TYPE is the type of the\n+   parameter to which the result is passed.  */\n \n static bool\n propagate_scalar_across_jump_function (struct cgraph_edge *cs,\n \t\t\t\t       struct ipa_jump_func *jfunc,\n-\t\t\t\t       ipcp_lattice<tree> *dest_lat)\n+\t\t\t\t       ipcp_lattice<tree> *dest_lat,\n+\t\t\t\t       tree param_type)\n {\n   if (dest_lat->bottom)\n     return false;\n@@ -1662,7 +1674,7 @@ propagate_scalar_across_jump_function (struct cgraph_edge *cs,\n \n       if (jfunc->type == IPA_JF_PASS_THROUGH)\n \tret = propagate_vals_across_pass_through (cs, jfunc, src_lat,\n-\t\t\t\t\t\t  dest_lat, src_idx);\n+\t\t\t\t\t\t  dest_lat, src_idx, param_type);\n       else\n \tret = propagate_vals_across_ancestor (cs, jfunc, src_lat, dest_lat,\n \t\t\t\t\t      src_idx);\n@@ -2279,7 +2291,8 @@ propagate_constants_across_call (struct cgraph_edge *cs)\n       else\n \t{\n \t  ret |= propagate_scalar_across_jump_function (cs, jump_func,\n-\t\t\t\t\t\t\t&dest_plats->itself);\n+\t\t\t\t\t\t\t&dest_plats->itself,\n+\t\t\t\t\t\t\tparam_type);\n \t  ret |= propagate_context_across_jump_function (cs, jump_func, i,\n \t\t\t\t\t\t\t &dest_plats->ctxlat);\n \t  ret\n@@ -3857,6 +3870,7 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n       tree newval = NULL_TREE;\n       int j;\n       bool first = true;\n+      tree type = ipa_get_type (info, i);\n \n       if (ipa_get_scalar_lat (info, i)->bottom || known_csts[i])\n \tcontinue;\n@@ -3876,7 +3890,7 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t      break;\n \t    }\n \t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n-\t  t = ipa_value_from_jfunc (IPA_NODE_REF (cs->caller), jump_func);\n+\t  t = ipa_value_from_jfunc (IPA_NODE_REF (cs->caller), jump_func, type);\n \t  if (!t\n \t      || (newval\n \t\t  && !values_equal_for_ipcp_p (t, newval))\n@@ -4352,7 +4366,8 @@ cgraph_edge_brings_all_scalars_for_node (struct cgraph_edge *cs,\n       if (i >= ipa_get_cs_argument_count (args))\n \treturn false;\n       jump_func = ipa_get_ith_jump_func (args, i);\n-      t = ipa_value_from_jfunc (caller_info, jump_func);\n+      t = ipa_value_from_jfunc (caller_info, jump_func,\n+\t\t\t\tipa_get_type (dest_info, i));\n       if (!t || !values_equal_for_ipcp_p (val, t))\n \treturn false;\n     }"}, {"sha": "7881151d6be6c6f6c0e0f49d20e2ecbd27065a60", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=e5cf5e116da6f5c018ecc8f714935877c4636780", "patch": "@@ -443,15 +443,16 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n       && !e->call_stmt_cannot_inline_p\n       && ((clause_ptr && info->conds) || known_vals_ptr || known_contexts_ptr))\n     {\n-      struct ipa_node_params *parms_info;\n+      struct ipa_node_params *caller_parms_info, *callee_pi;\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n       struct ipa_call_summary *es = ipa_call_summaries->get (e);\n       int i, count = ipa_get_cs_argument_count (args);\n \n       if (e->caller->global.inlined_to)\n-\tparms_info = IPA_NODE_REF (e->caller->global.inlined_to);\n+\tcaller_parms_info = IPA_NODE_REF (e->caller->global.inlined_to);\n       else\n-\tparms_info = IPA_NODE_REF (e->caller);\n+\tcaller_parms_info = IPA_NODE_REF (e->caller);\n+      callee_pi = IPA_NODE_REF (e->callee);\n \n       if (count && (info->conds || known_vals_ptr))\n \tknown_vals.safe_grow_cleared (count);\n@@ -463,7 +464,8 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, i);\n-\t  tree cst = ipa_value_from_jfunc (parms_info, jf);\n+\t  tree cst = ipa_value_from_jfunc (caller_parms_info, jf,\n+\t\t\t\t\t   ipa_get_type (callee_pi, i));\n \n \t  if (!cst && e->call_stmt\n \t      && i < (int)gimple_call_num_args (e->call_stmt))\n@@ -482,8 +484,8 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t    known_vals[i] = error_mark_node;\n \n \t  if (known_contexts_ptr)\n-\t    (*known_contexts_ptr)[i] = ipa_context_from_jfunc (parms_info, e,\n-\t\t\t\t\t\t\t       i, jf);\n+\t    (*known_contexts_ptr)[i]\n+\t      = ipa_context_from_jfunc (caller_parms_info, e, i, jf);\n \t  /* TODO: When IPA-CP starts propagating and merging aggregate jump\n \t     functions, use its knowledge of the caller too, just like the\n \t     scalar case above.  */"}, {"sha": "31879a747c01ffeecf564316366868a7838f5d54", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=e5cf5e116da6f5c018ecc8f714935877c4636780", "patch": "@@ -3207,19 +3207,20 @@ try_decrement_rdesc_refcount (struct ipa_jump_func *jfunc)\n \n /* Try to find a destination for indirect edge IE that corresponds to a simple\n    call or a call of a member function pointer and where the destination is a\n-   pointer formal parameter described by jump function JFUNC.  If it can be\n-   determined, return the newly direct edge, otherwise return NULL.\n+   pointer formal parameter described by jump function JFUNC.  TARGET_TYPE is\n+   the type of the parameter to which the result of JFUNC is passed.  If it can\n+   be determined, return the newly direct edge, otherwise return NULL.\n    NEW_ROOT_INFO is the node info that JFUNC lattices are relative to.  */\n \n static struct cgraph_edge *\n try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n-\t\t\t\t  struct ipa_jump_func *jfunc,\n+\t\t\t\t  struct ipa_jump_func *jfunc, tree target_type,\n \t\t\t\t  struct ipa_node_params *new_root_info)\n {\n   struct cgraph_edge *cs;\n   tree target;\n   bool agg_contents = ie->indirect_info->agg_contents;\n-  tree scalar = ipa_value_from_jfunc (new_root_info, jfunc);\n+  tree scalar = ipa_value_from_jfunc (new_root_info, jfunc, target_type);\n   if (agg_contents)\n     {\n       bool from_global_constant;\n@@ -3397,14 +3398,15 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n {\n   struct ipa_edge_args *top;\n   struct cgraph_edge *ie, *next_ie, *new_direct_edge;\n-  struct ipa_node_params *new_root_info;\n+  struct ipa_node_params *new_root_info, *inlined_node_info;\n   bool res = false;\n \n   ipa_check_create_edge_args ();\n   top = IPA_EDGE_REF (cs);\n   new_root_info = IPA_NODE_REF (cs->caller->global.inlined_to\n \t\t\t\t? cs->caller->global.inlined_to\n \t\t\t\t: cs->caller);\n+  inlined_node_info = IPA_NODE_REF (cs->callee->function_symbol ());\n \n   for (ie = node->indirect_calls; ie; ie = next_ie)\n     {\n@@ -3445,8 +3447,13 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t  new_direct_edge = try_make_edge_direct_virtual_call (ie, jfunc, ctx);\n \t}\n       else\n-\tnew_direct_edge = try_make_edge_direct_simple_call (ie, jfunc,\n-\t\t\t\t\t\t\t    new_root_info);\n+\t{\n+\t  tree target_type =  ipa_get_type (inlined_node_info, param_index);\n+\t  new_direct_edge = try_make_edge_direct_simple_call (ie, jfunc,\n+\t\t\t\t\t\t\t      target_type,\n+\t\t\t\t\t\t\t      new_root_info);\n+\t}\n+\n       /* If speculation was removed, then we need to do nothing.  */\n       if (new_direct_edge && new_direct_edge != ie\n \t  && new_direct_edge->callee == spec_target)"}, {"sha": "c3624052bbc1476b40ba2255533796010005a6ee", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=e5cf5e116da6f5c018ecc8f714935877c4636780", "patch": "@@ -464,7 +464,8 @@ ipa_get_param (struct ipa_node_params *info, int i)\n static inline tree\n ipa_get_type (struct ipa_node_params *info, int i)\n {\n-  gcc_checking_assert (info->descriptors);\n+  if (vec_safe_length (info->descriptors) <= (unsigned) i)\n+    return NULL;\n   tree t = (*info->descriptors)[i].decl_or_type;\n   if (!t)\n     return NULL;\n@@ -773,7 +774,7 @@ void ipcp_write_transformation_summaries (void);\n void ipcp_read_transformation_summaries (void);\n int ipa_get_param_decl_index (struct ipa_node_params *, tree);\n tree ipa_value_from_jfunc (struct ipa_node_params *info,\n-\t\t\t   struct ipa_jump_func *jfunc);\n+\t\t\t   struct ipa_jump_func *jfunc, tree type);\n unsigned int ipcp_transform_function (struct cgraph_node *node);\n ipa_polymorphic_call_context ipa_context_from_jfunc (ipa_node_params *,\n \t\t\t\t\t\t     cgraph_edge *,"}, {"sha": "67c1f272e624e76f884885898fb0a1a78fc46a83", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e5cf5e116da6f5c018ecc8f714935877c4636780", "patch": "@@ -1,3 +1,9 @@\n+2017-11-28  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\t    Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/82808\n+\t* gcc.dg/ipa/pr82808.c: New test.\n+\n 2017-11-28  Julia Koval  <julia.koval@intel.com>\n \n \t* gcc.target/i386/avx-1.c: Handle new intrinsics."}, {"sha": "9c95d0b6ed75d07defccad8b47c1e188d6c77796", "filename": "gcc/testsuite/gcc.dg/ipa/pr82808.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr82808.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr82808.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr82808.c?ref=e5cf5e116da6f5c018ecc8f714935877c4636780", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-options \"-O2\" } */\n+/* { dg-do run } */\n+\n+static void __attribute__((noinline))\n+foo (double *a, double x)\n+{\n+  *a = x;\n+}\n+\n+static double  __attribute__((noinline))\n+f_c1 (int m, double *a)\n+{\n+  foo (a, m);\n+  return *a;\n+}\n+\n+int\n+main (){\n+  double data;\n+  double ret = 0 ;\n+\n+  if ((ret = f_c1 (2, &data)) != 2)\n+    {\n+      __builtin_abort ();\n+    }\n+  return 0;\n+}"}, {"sha": "b99304c2ff1d44246a02e21bd5d8ca491ea30ac2", "filename": "gcc/tree.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e5cf5e116da6f5c018ecc8f714935877c4636780", "patch": "@@ -13898,6 +13898,50 @@ arg_size_in_bytes (const_tree type)\n   return TYPE_EMPTY_P (type) ? size_zero_node : size_in_bytes (type);\n }\n \n+/* Return true if an expression with CODE has to have the same result type as\n+   its first operand.  */\n+\n+bool\n+expr_type_first_operand_type_p (tree_code code)\n+{\n+  switch (code)\n+    {\n+    case NEGATE_EXPR:\n+    case ABS_EXPR:\n+    case BIT_NOT_EXPR:\n+    case PAREN_EXPR:\n+    case CONJ_EXPR:\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* List of pointer types used to declare builtins before we have seen their\n    real declaration.\n "}, {"sha": "bd713f81263f1952092b6bb00efd879b519213cd", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cf5e116da6f5c018ecc8f714935877c4636780/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e5cf5e116da6f5c018ecc8f714935877c4636780", "patch": "@@ -5445,6 +5445,7 @@ extern bool is_redundant_typedef (const_tree);\n extern bool default_is_empty_record (const_tree);\n extern HOST_WIDE_INT arg_int_size_in_bytes (const_tree);\n extern tree arg_size_in_bytes (const_tree);\n+extern bool expr_type_first_operand_type_p (tree_code);\n \n extern location_t\n set_source_range (tree expr, location_t start, location_t finish);"}]}