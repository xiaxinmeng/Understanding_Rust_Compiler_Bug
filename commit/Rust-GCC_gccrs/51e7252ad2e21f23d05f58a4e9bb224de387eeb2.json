{"sha": "51e7252ad2e21f23d05f58a4e9bb224de387eeb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFlNzI1MmFkMmUyMWYyM2QwNWY1OGE0ZTliYjIyNGRlMzg3ZWViMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-08-08T15:46:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-08-08T15:46:08Z"}, "message": "mips-protos.h (mips_emit_move): Declare.\n\ngcc/\n\t* config/mips/mips-protos.h (mips_emit_move): Declare.\n\t* config/mips/mips.c (mips_emit_move): New function.\n\t(mips_force_temporary): Use mips_emit_move instead of emit_move_insn.\n\t(mips_legitimize_const_move): Likewise.\n\t(mips_legitimize_move): Likewise.\n\t(mips_split_64bit_move): Likewise.\n\t(mips_restore_gp): Likewise.\n\t(mips_load_call_address): Likewise.\n\t(mips_emit_fcc_reload): Likewise.\n\t(mips_set_return_address): Likewise.\n\t(mips_block_move_straight): Likewise.\n\t(mips_block_move_loop): Likewise.\n\t(mips_setup_incoming_varargs): Likewise.\n\t(mips_save_reg): Likewise.\n\t(mips_expand_prologue): Likewise.\n\t(mips_restore_reg): Likewise.\n\t(mips_expand_epilogue): Likewise.\n\t(mips_output_mi_thunk): Likewise.\n\t(build_mips16_call_stub): Likewise.\n\t(mips_builtin_branch_and_move): Likewise.\n\t* config/mips/mips.h (INITIALIZE_TRAMPOLINE): Likewise.\n\t* config/mips/mips.md (fixuns_truncdfsi2): Likewise.\n\t(fixuns_truncdfdi2): Likewise.\n\t(fixuns_truncsfsi2): Likewise.\n\t(fixuns_truncsfdi2): Likewise.\n\t(loadgp_absolute): Likewise.\n\t(builtin_setjmp_setup): Likewise.\n\t(builtin_longjmp): Likewise.\n\t(untyped_call): Likewise.\n\nFrom-SVN: r127299", "tree": {"sha": "68f658db6459efd7f842f352433ff10fd8f5047b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68f658db6459efd7f842f352433ff10fd8f5047b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51e7252ad2e21f23d05f58a4e9bb224de387eeb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51e7252ad2e21f23d05f58a4e9bb224de387eeb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51e7252ad2e21f23d05f58a4e9bb224de387eeb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51e7252ad2e21f23d05f58a4e9bb224de387eeb2/comments", "author": null, "committer": null, "parents": [{"sha": "390ea488c1753eaf9c747ead8f653c9023058109", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390ea488c1753eaf9c747ead8f653c9023058109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/390ea488c1753eaf9c747ead8f653c9023058109"}], "stats": {"total": 176, "additions": 111, "deletions": 65}, "files": [{"sha": "f78ecf60e3e0d406e6732da626cc5328868ff45f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51e7252ad2e21f23d05f58a4e9bb224de387eeb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51e7252ad2e21f23d05f58a4e9bb224de387eeb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51e7252ad2e21f23d05f58a4e9bb224de387eeb2", "patch": "@@ -1,3 +1,35 @@\n+2007-08-08  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/mips/mips-protos.h (mips_emit_move): Declare.\n+\t* config/mips/mips.c (mips_emit_move): New function.\n+\t(mips_force_temporary): Use mips_emit_move instead of emit_move_insn.\n+\t(mips_legitimize_const_move): Likewise.\n+\t(mips_legitimize_move): Likewise.\n+\t(mips_split_64bit_move): Likewise.\n+\t(mips_restore_gp): Likewise.\n+\t(mips_load_call_address): Likewise.\n+\t(mips_emit_fcc_reload): Likewise.\n+\t(mips_set_return_address): Likewise.\n+\t(mips_block_move_straight): Likewise.\n+\t(mips_block_move_loop): Likewise.\n+\t(mips_setup_incoming_varargs): Likewise.\n+\t(mips_save_reg): Likewise.\n+\t(mips_expand_prologue): Likewise.\n+\t(mips_restore_reg): Likewise.\n+\t(mips_expand_epilogue): Likewise.\n+\t(mips_output_mi_thunk): Likewise.\n+\t(build_mips16_call_stub): Likewise.\n+\t(mips_builtin_branch_and_move): Likewise.\n+\t* config/mips/mips.h (INITIALIZE_TRAMPOLINE): Likewise.\n+\t* config/mips/mips.md (fixuns_truncdfsi2): Likewise.\n+\t(fixuns_truncdfdi2): Likewise.\n+\t(fixuns_truncsfsi2): Likewise.\n+\t(fixuns_truncsfdi2): Likewise.\n+\t(loadgp_absolute): Likewise.\n+\t(builtin_setjmp_setup): Likewise.\n+\t(builtin_longjmp): Likewise.\n+\t(untyped_call): Likewise.\n+\n 2007-08-08  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config/mips/mips-protos.h (mips_split_symbol): Add a mode and"}, {"sha": "139276efa0b2ee24d84035f8895aa1253463da85", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51e7252ad2e21f23d05f58a4e9bb224de387eeb2/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51e7252ad2e21f23d05f58a4e9bb224de387eeb2/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=51e7252ad2e21f23d05f58a4e9bb224de387eeb2", "patch": "@@ -171,6 +171,7 @@ extern int mips_idiv_insns (void);\n extern int fp_register_operand (rtx, enum machine_mode);\n extern int lo_operand (rtx, enum machine_mode);\n extern bool mips_legitimate_address_p (enum machine_mode, rtx, int);\n+extern rtx mips_emit_move (rtx, rtx);\n extern bool mips_split_symbol (rtx, rtx, enum machine_mode, rtx *);\n extern rtx mips_unspec_address (rtx, enum mips_symbol_type);\n extern bool mips_legitimize_address (rtx *, enum machine_mode);"}, {"sha": "2544b21824e527066decda2fa49040e50172ad97", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 58, "deletions": 45, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51e7252ad2e21f23d05f58a4e9bb224de387eeb2/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51e7252ad2e21f23d05f58a4e9bb224de387eeb2/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=51e7252ad2e21f23d05f58a4e9bb224de387eeb2", "patch": "@@ -2096,6 +2096,19 @@ mips_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n   return mips_classify_address (&addr, x, mode, strict);\n }\n \n+/* Emit a move from SRC to DEST.  Assume that the move expanders can\n+   handle all moves if !can_create_pseudo_p ().  The distinction is\n+   important because, unlike emit_move_insn, the move expanders know\n+   how to force Pmode objects into the constant pool even when the\n+   constant pool address is not itself legitimate.  */\n+\n+rtx\n+mips_emit_move (rtx dest, rtx src)\n+{\n+  return (can_create_pseudo_p ()\n+\t  ? emit_move_insn (dest, src)\n+\t  : emit_move_insn_1 (dest, src));\n+}\n \n /* Copy VALUE to a register and return that register.  If new psuedos\n    are allowed, copy it into a new register, otherwise use DEST.  */\n@@ -2107,7 +2120,7 @@ mips_force_temporary (rtx dest, rtx value)\n     return force_reg (Pmode, value);\n   else\n     {\n-      emit_move_insn (copy_rtx (dest), value);\n+      mips_emit_move (copy_rtx (dest), value);\n       return dest;\n     }\n }\n@@ -2532,7 +2545,7 @@ mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n \n   if (mips_tls_operand_p (src))\n     {\n-      emit_move_insn (dest, mips_legitimize_tls_address (src));\n+      mips_emit_move (dest, mips_legitimize_tls_address (src));\n       return;\n     }\n \n@@ -2545,7 +2558,7 @@ mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n       && (can_create_pseudo_p () || SMALL_INT (offset)))\n     {\n       base = mips_force_temporary (dest, base);\n-      emit_move_insn (dest, mips_add_offset (0, base, INTVAL (offset)));\n+      mips_emit_move (dest, mips_add_offset (0, base, INTVAL (offset)));\n       return;\n     }\n \n@@ -2554,7 +2567,7 @@ mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n   /* When using explicit relocs, constant pool references are sometimes\n      not legitimate addresses.  */\n   mips_split_symbol (dest, XEXP (src, 0), mode, &XEXP (src, 0));\n-  emit_move_insn (dest, src);\n+  mips_emit_move (dest, src);\n }\n \n \n@@ -2566,7 +2579,7 @@ mips_legitimize_move (enum machine_mode mode, rtx dest, rtx src)\n {\n   if (!register_operand (dest, mode) && !reg_or_0_operand (src, mode))\n     {\n-      emit_move_insn (dest, force_reg (mode, src));\n+      mips_emit_move (dest, force_reg (mode, src));\n       return true;\n     }\n \n@@ -3080,12 +3093,12 @@ mips_split_64bit_move (rtx dest, rtx src)\n       if (ISA_HAS_MXHC1)\n \t{\n \t  src = gen_lowpart (DFmode, src);\n-\t  emit_move_insn (mips_subword (dest, 0), mips_subword (src, 0));\n+\t  mips_emit_move (mips_subword (dest, 0), mips_subword (src, 0));\n \t  emit_insn (gen_mfhc1 (mips_subword (dest, 1), src));\n \t}\n       else\n \t{\n-\t  emit_move_insn (mips_subword (dest, 0), mips_subword (src, 0));\n+\t  mips_emit_move (mips_subword (dest, 0), mips_subword (src, 0));\n \t  emit_insn (gen_store_df_high (mips_subword (dest, 1), src));\n \t}\n     }\n@@ -3099,13 +3112,13 @@ mips_split_64bit_move (rtx dest, rtx src)\n       if (REG_P (low_dest)\n \t  && reg_overlap_mentioned_p (low_dest, src))\n \t{\n-\t  emit_move_insn (mips_subword (dest, 1), mips_subword (src, 1));\n-\t  emit_move_insn (low_dest, mips_subword (src, 0));\n+\t  mips_emit_move (mips_subword (dest, 1), mips_subword (src, 1));\n+\t  mips_emit_move (low_dest, mips_subword (src, 0));\n \t}\n       else\n \t{\n-\t  emit_move_insn (low_dest, mips_subword (src, 0));\n-\t  emit_move_insn (mips_subword (dest, 1), mips_subword (src, 1));\n+\t  mips_emit_move (low_dest, mips_subword (src, 0));\n+\t  mips_emit_move (mips_subword (dest, 1), mips_subword (src, 1));\n \t}\n     }\n }\n@@ -3266,7 +3279,7 @@ mips_restore_gp (void)\n \t\t\t     current_function_outgoing_args_size);\n   slot = gen_rtx_MEM (Pmode, address);\n \n-  emit_move_insn (pic_offset_table_rtx, slot);\n+  mips_emit_move (pic_offset_table_rtx, slot);\n   if (!TARGET_EXPLICIT_RELOCS)\n     emit_insn (gen_blockage ());\n }\n@@ -3655,7 +3668,7 @@ mips_load_call_address (rtx dest, rtx addr, int sibcall_p)\n \temit_insn (gen_load_calldi (dest, high, lo_sum_symbol));\n     }\n   else\n-    emit_move_insn (dest, addr);\n+    mips_emit_move (dest, addr);\n }\n \n \n@@ -3745,8 +3758,8 @@ mips_emit_fcc_reload (rtx dest, rtx src, rtx scratch)\n   fp1 = gen_rtx_REG (SFmode, REGNO (scratch));\n   fp2 = gen_rtx_REG (SFmode, REGNO (scratch) + MAX_FPRS_PER_FMT);\n \n-  emit_move_insn (copy_rtx (fp1), src);\n-  emit_move_insn (copy_rtx (fp2), CONST0_RTX (SFmode));\n+  mips_emit_move (copy_rtx (fp1), src);\n+  mips_emit_move (copy_rtx (fp2), CONST0_RTX (SFmode));\n   emit_insn (gen_slt_sf (dest, fp2, fp1));\n }\n \f\n@@ -3764,7 +3777,7 @@ mips_set_return_address (rtx address, rtx scratch)\n   slot_address = mips_add_offset (scratch, stack_pointer_rtx,\n \t\t\t\t  cfun->machine->frame.gp_sp_offset);\n \n-  emit_move_insn (gen_rtx_MEM (GET_MODE (address), slot_address), address);\n+  mips_emit_move (gen_rtx_MEM (GET_MODE (address), slot_address), address);\n }\n \f\n /* Emit straight-line code to move LENGTH bytes from SRC to DEST.\n@@ -3802,7 +3815,7 @@ mips_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)\n     {\n       regs[i] = gen_reg_rtx (mode);\n       if (MEM_ALIGN (src) >= bits)\n-\temit_move_insn (regs[i], adjust_address (src, mode, offset));\n+\tmips_emit_move (regs[i], adjust_address (src, mode, offset));\n       else\n \t{\n \t  rtx part = adjust_address (src, BLKmode, offset);\n@@ -3814,7 +3827,7 @@ mips_block_move_straight (rtx dest, rtx src, HOST_WIDE_INT length)\n   /* Copy the chunks to the destination.  */\n   for (offset = 0, i = 0; offset + delta <= length; offset += delta, i++)\n     if (MEM_ALIGN (dest) >= bits)\n-      emit_move_insn (adjust_address (dest, mode, offset), regs[i]);\n+      mips_emit_move (adjust_address (dest, mode, offset), regs[i]);\n     else\n       {\n \trtx part = adjust_address (dest, BLKmode, offset);\n@@ -3887,8 +3900,8 @@ mips_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length)\n   mips_block_move_straight (dest, src, MAX_MOVE_BYTES);\n \n   /* Move on to the next block.  */\n-  emit_move_insn (src_reg, plus_constant (src_reg, MAX_MOVE_BYTES));\n-  emit_move_insn (dest_reg, plus_constant (dest_reg, MAX_MOVE_BYTES));\n+  mips_emit_move (src_reg, plus_constant (src_reg, MAX_MOVE_BYTES));\n+  mips_emit_move (dest_reg, plus_constant (dest_reg, MAX_MOVE_BYTES));\n \n   /* Emit the loop condition.  */\n   if (Pmode == DImode)\n@@ -4411,7 +4424,7 @@ mips_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t      ptr = plus_constant (virtual_incoming_args_rtx, off);\n \t      mem = gen_rtx_MEM (mode, ptr);\n \t      set_mem_alias_set (mem, get_varargs_alias_set ());\n-\t      emit_move_insn (mem, gen_rtx_REG (mode, FP_ARG_FIRST + i));\n+\t      mips_emit_move (mem, gen_rtx_REG (mode, FP_ARG_FIRST + i));\n \t      off += UNITS_PER_HWFPVALUE;\n \t    }\n \t}\n@@ -7259,7 +7272,7 @@ mips_save_reg (rtx reg, rtx mem)\n       if (mips_split_64bit_move_p (mem, reg))\n \tmips_split_64bit_move (mem, reg);\n       else\n-\temit_move_insn (mem, reg);\n+\tmips_emit_move (mem, reg);\n \n       x1 = mips_frame_set (mips_subword (mem, 0), mips_subword (reg, 0));\n       x2 = mips_frame_set (mips_subword (mem, 1), mips_subword (reg, 1));\n@@ -7274,11 +7287,11 @@ mips_save_reg (rtx reg, rtx mem)\n \t  /* Save a non-mips16 register by moving it through a temporary.\n \t     We don't need to do this for $31 since there's a special\n \t     instruction for it.  */\n-\t  emit_move_insn (MIPS_PROLOGUE_TEMP (GET_MODE (reg)), reg);\n-\t  emit_move_insn (mem, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));\n+\t  mips_emit_move (MIPS_PROLOGUE_TEMP (GET_MODE (reg)), reg);\n+\t  mips_emit_move (mem, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));\n \t}\n       else\n-\temit_move_insn (mem, reg);\n+\tmips_emit_move (mem, reg);\n \n       mips_set_frame_expr (mips_frame_set (mem, reg));\n     }\n@@ -7748,19 +7761,19 @@ mips_expand_prologue (void)\n \t\t\t\t\t\t       GEN_INT (-size)))) = 1;\n       else\n \t{\n-\t  emit_move_insn (MIPS_PROLOGUE_TEMP (Pmode), GEN_INT (size));\n+\t  mips_emit_move (MIPS_PROLOGUE_TEMP (Pmode), GEN_INT (size));\n \t  if (TARGET_MIPS16)\n \t    {\n \t      /* There are no instructions to add or subtract registers\n \t\t from the stack pointer, so use the frame pointer as a\n \t\t temporary.  We should always be using a frame pointer\n \t\t in this case anyway.  */\n \t      gcc_assert (frame_pointer_needed);\n-\t      emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n+\t      mips_emit_move (hard_frame_pointer_rtx, stack_pointer_rtx);\n \t      emit_insn (gen_sub3_insn (hard_frame_pointer_rtx,\n \t\t\t\t\thard_frame_pointer_rtx,\n \t\t\t\t\tMIPS_PROLOGUE_TEMP (Pmode)));\n-\t      emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);\n+\t      mips_emit_move (stack_pointer_rtx, hard_frame_pointer_rtx);\n \t    }\n \t  else\n \t    emit_insn (gen_sub3_insn (stack_pointer_rtx,\n@@ -7790,8 +7803,8 @@ mips_expand_prologue (void)\n \t\t\t\t\t offset))) = 1;\n \t  else\n \t    {\n-\t      emit_move_insn (MIPS_PROLOGUE_TEMP (Pmode), offset);\n-\t      emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n+\t      mips_emit_move (MIPS_PROLOGUE_TEMP (Pmode), offset);\n+\t      mips_emit_move (hard_frame_pointer_rtx, stack_pointer_rtx);\n \t      emit_insn (gen_add3_insn (hard_frame_pointer_rtx,\n \t\t\t\t\thard_frame_pointer_rtx,\n \t\t\t\t\tMIPS_PROLOGUE_TEMP (Pmode)));\n@@ -7802,7 +7815,7 @@ mips_expand_prologue (void)\n \t    }\n \t}\n       else\n-\tRTX_FRAME_RELATED_P (emit_move_insn (hard_frame_pointer_rtx,\n+\tRTX_FRAME_RELATED_P (mips_emit_move (hard_frame_pointer_rtx,\n \t\t\t\t\t     stack_pointer_rtx)) = 1;\n     }\n \n@@ -7867,11 +7880,11 @@ mips_restore_reg (rtx reg, rtx mem)\n   if (TARGET_MIPS16 && !M16_REG_P (REGNO (reg)))\n     {\n       /* Can't restore directly; move through a temporary.  */\n-      emit_move_insn (MIPS_EPILOGUE_TEMP (GET_MODE (reg)), mem);\n-      emit_move_insn (reg, MIPS_EPILOGUE_TEMP (GET_MODE (reg)));\n+      mips_emit_move (MIPS_EPILOGUE_TEMP (GET_MODE (reg)), mem);\n+      mips_emit_move (reg, MIPS_EPILOGUE_TEMP (GET_MODE (reg)));\n     }\n   else\n-    emit_move_insn (reg, mem);\n+    mips_emit_move (reg, mem);\n }\n \n \n@@ -7955,7 +7968,7 @@ mips_expand_epilogue (int sibcall_p)\n       adjust = GEN_INT (step1);\n       if (!SMALL_OPERAND (step1))\n \t{\n-\t  emit_move_insn (MIPS_EPILOGUE_TEMP (Pmode), adjust);\n+\t  mips_emit_move (MIPS_EPILOGUE_TEMP (Pmode), adjust);\n \t  adjust = MIPS_EPILOGUE_TEMP (Pmode);\n \t}\n \n@@ -7968,7 +7981,7 @@ mips_expand_epilogue (int sibcall_p)\n \n   /* Copy TARGET into the stack pointer.  */\n   if (target != stack_pointer_rtx)\n-    emit_move_insn (stack_pointer_rtx, target);\n+    mips_emit_move (stack_pointer_rtx, target);\n \n   /* If we're using addressing macros, $gp is implicitly used by all\n      SYMBOL_REFs.  We must emit a blockage insn before restoring $gp\n@@ -8017,11 +8030,11 @@ mips_expand_epilogue (int sibcall_p)\n     {\n       if (TARGET_MIPS16)\n \t{\n-\t  emit_move_insn (MIPS_EPILOGUE_TEMP (Pmode), stack_pointer_rtx);\n+\t  mips_emit_move (MIPS_EPILOGUE_TEMP (Pmode), stack_pointer_rtx);\n \t  emit_insn (gen_add3_insn (MIPS_EPILOGUE_TEMP (Pmode),\n \t\t\t\t    MIPS_EPILOGUE_TEMP (Pmode),\n \t\t\t\t    EH_RETURN_STACKADJ_RTX));\n-\t  emit_move_insn (stack_pointer_rtx, MIPS_EPILOGUE_TEMP (Pmode));\n+\t  mips_emit_move (stack_pointer_rtx, MIPS_EPILOGUE_TEMP (Pmode));\n \t}\n       else\n \temit_insn (gen_add3_insn (stack_pointer_rtx,\n@@ -8119,7 +8132,7 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n       rtx offset = GEN_INT (delta);\n       if (!SMALL_OPERAND (delta))\n \t{\n-\t  emit_move_insn (temp1, offset);\n+\t  mips_emit_move (temp1, offset);\n \t  offset = temp1;\n \t}\n       emit_insn (gen_add3_insn (this, this, offset));\n@@ -8131,13 +8144,13 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n       rtx addr;\n \n       /* Set TEMP1 to *THIS.  */\n-      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this));\n+      mips_emit_move (temp1, gen_rtx_MEM (Pmode, this));\n \n       /* Set ADDR to a legitimate address for *THIS + VCALL_OFFSET.  */\n       addr = mips_add_offset (temp2, temp1, vcall_offset);\n \n       /* Load the offset and add it to THIS.  */\n-      emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n+      mips_emit_move (temp1, gen_rtx_MEM (Pmode, addr));\n       emit_insn (gen_add3_insn (this, this, temp1));\n     }\n \n@@ -8165,7 +8178,7 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n       if (TARGET_USE_PIC_FN_ADDR_REG\n \t  && REGNO (temp1) != PIC_FUNCTION_ADDR_REGNUM)\n-\temit_move_insn (gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM), temp1);\n+\tmips_emit_move (gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM), temp1);\n       emit_jump_insn (gen_indirect_jump (temp1));\n     }\n   else\n@@ -9126,7 +9139,7 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n       id = get_identifier (buf);\n       stub_fn = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (id));\n \n-      emit_move_insn (gen_rtx_REG (Pmode, 2), fn);\n+      mips_emit_move (gen_rtx_REG (Pmode, 2), fn);\n \n       if (retval == NULL_RTX)\n \tinsn = gen_call_internal (stub_fn, arg_size);\n@@ -11853,7 +11866,7 @@ mips_builtin_branch_and_move (rtx condition, rtx target,\n   done_label = gen_label_rtx ();\n \n   /* First assume that CONDITION is false.  */\n-  emit_move_insn (target, value_if_false);\n+  mips_emit_move (target, value_if_false);\n \n   /* Branch to TRUE_LABEL if CONDITION is true and DONE_LABEL otherwise.  */\n   emit_jump_insn (gen_condjump (condition, true_label));\n@@ -11862,7 +11875,7 @@ mips_builtin_branch_and_move (rtx condition, rtx target,\n \n   /* Fix TARGET if CONDITION is true.  */\n   emit_label (true_label);\n-  emit_move_insn (target, value_if_true);\n+  mips_emit_move (target, value_if_true);\n \n   emit_label (done_label);\n   return target;"}, {"sha": "e8abdcaef9ee8eae24b8dd471f4ce7d21d774910", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51e7252ad2e21f23d05f58a4e9bb224de387eeb2/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51e7252ad2e21f23d05f58a4e9bb224de387eeb2/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=51e7252ad2e21f23d05f58a4e9bb224de387eeb2", "patch": "@@ -2171,8 +2171,8 @@ typedef struct mips_args {\n \t\t\t\t\t\t\t\t\t    \\\n   func_addr = plus_constant (ADDR, 32);\t\t\t\t\t    \\\n   chain_addr = plus_constant (func_addr, GET_MODE_SIZE (ptr_mode));\t    \\\n-  emit_move_insn (gen_rtx_MEM (ptr_mode, func_addr), FUNC);\t\t    \\\n-  emit_move_insn (gen_rtx_MEM (ptr_mode, chain_addr), CHAIN);\t\t    \\\n+  mips_emit_move (gen_rtx_MEM (ptr_mode, func_addr), FUNC);\t\t    \\\n+  mips_emit_move (gen_rtx_MEM (ptr_mode, chain_addr), CHAIN);\t\t    \\\n   end_addr = gen_reg_rtx (Pmode);\t\t\t\t\t    \\\n   emit_insn (gen_add3_insn (end_addr, copy_rtx (ADDR),\t\t\t    \\\n                             GEN_INT (TRAMPOLINE_SIZE)));\t\t    \\"}, {"sha": "88d8fd6266cf4d38be948c8ab3977677b129a01a", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51e7252ad2e21f23d05f58a4e9bb224de387eeb2/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51e7252ad2e21f23d05f58a4e9bb224de387eeb2/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=51e7252ad2e21f23d05f58a4e9bb224de387eeb2", "patch": "@@ -2791,7 +2791,7 @@\n \n   if (reg1)\t\t\t/* Turn off complaints about unreached code.  */\n     {\n-      emit_move_insn (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, DFmode));\n+      mips_emit_move (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, DFmode));\n       do_pending_stack_adjust ();\n \n       emit_insn (gen_cmpdf (operands[1], reg1));\n@@ -2803,8 +2803,8 @@\n       emit_barrier ();\n \n       emit_label (label1);\n-      emit_move_insn (reg2, gen_rtx_MINUS (DFmode, operands[1], reg1));\n-      emit_move_insn (reg3, GEN_INT (trunc_int_for_mode\n+      mips_emit_move (reg2, gen_rtx_MINUS (DFmode, operands[1], reg1));\n+      mips_emit_move (reg3, GEN_INT (trunc_int_for_mode\n \t\t\t\t     (BITMASK_HIGH, SImode)));\n \n       emit_insn (gen_fix_truncdfsi2 (operands[0], reg2));\n@@ -2834,7 +2834,7 @@\n \n   real_2expN (&offset, 63);\n \n-  emit_move_insn (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, DFmode));\n+  mips_emit_move (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, DFmode));\n   do_pending_stack_adjust ();\n \n   emit_insn (gen_cmpdf (operands[1], reg1));\n@@ -2846,8 +2846,8 @@\n   emit_barrier ();\n \n   emit_label (label1);\n-  emit_move_insn (reg2, gen_rtx_MINUS (DFmode, operands[1], reg1));\n-  emit_move_insn (reg3, GEN_INT (BITMASK_HIGH));\n+  mips_emit_move (reg2, gen_rtx_MINUS (DFmode, operands[1], reg1));\n+  mips_emit_move (reg3, GEN_INT (BITMASK_HIGH));\n   emit_insn (gen_ashldi3 (reg3, reg3, GEN_INT (32)));\n \n   emit_insn (gen_fix_truncdfdi2 (operands[0], reg2));\n@@ -2876,7 +2876,7 @@\n \n   real_2expN (&offset, 31);\n \n-  emit_move_insn (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, SFmode));\n+  mips_emit_move (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, SFmode));\n   do_pending_stack_adjust ();\n \n   emit_insn (gen_cmpsf (operands[1], reg1));\n@@ -2888,8 +2888,8 @@\n   emit_barrier ();\n \n   emit_label (label1);\n-  emit_move_insn (reg2, gen_rtx_MINUS (SFmode, operands[1], reg1));\n-  emit_move_insn (reg3, GEN_INT (trunc_int_for_mode\n+  mips_emit_move (reg2, gen_rtx_MINUS (SFmode, operands[1], reg1));\n+  mips_emit_move (reg3, GEN_INT (trunc_int_for_mode\n \t\t\t\t (BITMASK_HIGH, SImode)));\n \n   emit_insn (gen_fix_truncsfsi2 (operands[0], reg2));\n@@ -2918,7 +2918,7 @@\n \n   real_2expN (&offset, 63);\n \n-  emit_move_insn (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, SFmode));\n+  mips_emit_move (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, SFmode));\n   do_pending_stack_adjust ();\n \n   emit_insn (gen_cmpsf (operands[1], reg1));\n@@ -2930,8 +2930,8 @@\n   emit_barrier ();\n \n   emit_label (label1);\n-  emit_move_insn (reg2, gen_rtx_MINUS (SFmode, operands[1], reg1));\n-  emit_move_insn (reg3, GEN_INT (BITMASK_HIGH));\n+  mips_emit_move (reg2, gen_rtx_MINUS (SFmode, operands[1], reg1));\n+  mips_emit_move (reg3, GEN_INT (BITMASK_HIGH));\n   emit_insn (gen_ashldi3 (reg3, reg3, GEN_INT (32)));\n \n   emit_insn (gen_fix_truncsfdi2 (operands[0], reg2));\n@@ -4148,7 +4148,7 @@\n   \"\"\n   [(const_int 0)]\n {\n-  emit_move_insn (pic_offset_table_rtx, operands[0]);\n+  mips_emit_move (pic_offset_table_rtx, operands[0]);\n   DONE;\n }\n   [(set_attr \"length\" \"8\")])\n@@ -5096,7 +5096,7 @@\n   rtx addr;\n \n   addr = plus_constant (operands[0], GET_MODE_SIZE (Pmode) * 3);\n-  emit_move_insn (gen_rtx_MEM (Pmode, addr), pic_offset_table_rtx);\n+  mips_emit_move (gen_rtx_MEM (Pmode, addr), pic_offset_table_rtx);\n   DONE;\n })\n \n@@ -5122,10 +5122,10 @@\n \n   /* This bit is similar to expand_builtin_longjmp except that it\n      restores $gp as well.  */\n-  emit_move_insn (hard_frame_pointer_rtx, fp);\n-  emit_move_insn (pv, lab);\n+  mips_emit_move (hard_frame_pointer_rtx, fp);\n+  mips_emit_move (pv, lab);\n   emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n-  emit_move_insn (gp, gpv);\n+  mips_emit_move (gp, gpv);\n   emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n   emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n   emit_insn (gen_rtx_USE (VOIDmode, gp));\n@@ -5516,7 +5516,7 @@\n   for (i = 0; i < XVECLEN (operands[2], 0); i++)\n     {\n       rtx set = XVECEXP (operands[2], 0, i);\n-      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+      mips_emit_move (SET_DEST (set), SET_SRC (set));\n     }\n \n   emit_insn (gen_blockage ());"}]}