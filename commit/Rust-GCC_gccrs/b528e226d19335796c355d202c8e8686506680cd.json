{"sha": "b528e226d19335796c355d202c8e8686506680cd", "node_id": "C_kwDOANBUbNoAKGI1MjhlMjI2ZDE5MzM1Nzk2YzM1NWQyMDJjOGU4Njg2NTA2NjgwY2Q", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-27T08:35:24Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-27T09:30:16Z"}, "message": "Refactor try_vectorize_loop_1\n\nThis refactors epilogue loop handling in try_vectorize_loop_1 to not\nsuggest we're analyzing those there by splitting out the transform\nphase which then can handle the epilogues.\n\n2021-10-27  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.c (vect_transform_loops): New function,\n\tsplit out from ...\n\t(try_vectorize_loop_1): ... here.  Simplify as epilogues\n\tare now fully handled in the split part.", "tree": {"sha": "8bf23f0be0ddd72ee8951942c00ee45515913214", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bf23f0be0ddd72ee8951942c00ee45515913214"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b528e226d19335796c355d202c8e8686506680cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b528e226d19335796c355d202c8e8686506680cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b528e226d19335796c355d202c8e8686506680cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b528e226d19335796c355d202c8e8686506680cd/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f899b23f36f94f907a025d3eeaf3e4640544927", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f899b23f36f94f907a025d3eeaf3e4640544927", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f899b23f36f94f907a025d3eeaf3e4640544927"}], "stats": {"total": 105, "additions": 50, "deletions": 55}, "files": [{"sha": "89fa883fbb9b3c004563a1fdd1256962d4d09358", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 50, "deletions": 55, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b528e226d19335796c355d202c8e8686506680cd/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b528e226d19335796c355d202c8e8686506680cd/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=b528e226d19335796c355d202c8e8686506680cd", "patch": "@@ -979,6 +979,50 @@ set_uid_loop_bbs (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n   free (bbs);\n }\n \n+/* Generate vectorized code for LOOP and its epilogues.  */\n+\n+static void\n+vect_transform_loops (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n+\t\t      loop_p loop, gimple *loop_vectorized_call)\n+{\n+  loop_vec_info loop_vinfo = loop_vec_info_for_loop (loop);\n+\n+  if (loop_vectorized_call)\n+    set_uid_loop_bbs (loop_vinfo, loop_vectorized_call);\n+\n+  unsigned HOST_WIDE_INT bytes;\n+  if (dump_enabled_p ())\n+    {\n+      if (GET_MODE_SIZE (loop_vinfo->vector_mode).is_constant (&bytes))\n+\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t\t \"loop vectorized using %wu byte vectors\\n\", bytes);\n+      else\n+\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t\t \"loop vectorized using variable length vectors\\n\");\n+    }\n+\n+  loop_p new_loop = vect_transform_loop (loop_vinfo,\n+\t\t\t\t\t loop_vectorized_call);\n+  /* Now that the loop has been vectorized, allow it to be unrolled\n+     etc.  */\n+  loop->force_vectorize = false;\n+\n+  if (loop->simduid)\n+    {\n+      simduid_to_vf *simduid_to_vf_data = XNEW (simduid_to_vf);\n+      if (!simduid_to_vf_htab)\n+\tsimduid_to_vf_htab = new hash_table<simduid_to_vf> (15);\n+      simduid_to_vf_data->simduid = DECL_UID (loop->simduid);\n+      simduid_to_vf_data->vf = loop_vinfo->vectorization_factor;\n+      *simduid_to_vf_htab->find_slot (simduid_to_vf_data, INSERT)\n+\t  = simduid_to_vf_data;\n+    }\n+\n+  /* Epilogue of vectorized loop must be vectorized too.  */\n+  if (new_loop)\n+    vect_transform_loops (simduid_to_vf_htab, new_loop, NULL);\n+}\n+\n /* Try to vectorize LOOP.  */\n \n static unsigned\n@@ -999,17 +1043,9 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n \t\t LOCATION_FILE (vect_location.get_location_t ()),\n \t\t LOCATION_LINE (vect_location.get_location_t ()));\n \n-  opt_loop_vec_info loop_vinfo = opt_loop_vec_info::success (NULL);\n-  /* In the case of epilogue vectorization the loop already has its\n-     loop_vec_info set, we do not require to analyze the loop in this case.  */\n-  if (loop_vec_info vinfo = loop_vec_info_for_loop (loop))\n-    loop_vinfo = opt_loop_vec_info::success (vinfo);\n-  else\n-    {\n-      /* Try to analyze the loop, retaining an opt_problem if dump_enabled_p.  */\n-      loop_vinfo = vect_analyze_loop (loop, &shared);\n-      loop->aux = loop_vinfo;\n-    }\n+  /* Try to analyze the loop, retaining an opt_problem if dump_enabled_p.  */\n+  opt_loop_vec_info loop_vinfo = vect_analyze_loop (loop, &shared);\n+  loop->aux = loop_vinfo;\n \n   if (!loop_vinfo)\n     if (dump_enabled_p ())\n@@ -1083,8 +1119,7 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n       return ret;\n     }\n \n-  /* Only count the original scalar loops.  */\n-  if (!LOOP_VINFO_EPILOGUE_P (loop_vinfo) && !dbg_cnt (vect_loop))\n+  if (!dbg_cnt (vect_loop))\n     {\n       /* Free existing information if loop is analyzed with some\n \t assumptions.  */\n@@ -1093,62 +1128,22 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n       return ret;\n     }\n \n-  if (loop_vectorized_call)\n-    set_uid_loop_bbs (loop_vinfo, loop_vectorized_call);\n-\n-  unsigned HOST_WIDE_INT bytes;\n-  if (dump_enabled_p ())\n-    {\n-      if (GET_MODE_SIZE (loop_vinfo->vector_mode).is_constant (&bytes))\n-\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t\t \"loop vectorized using %wu byte vectors\\n\", bytes);\n-      else\n-\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t\t \"loop vectorized using variable length vectors\\n\");\n-    }\n-\n-  loop_p new_loop = vect_transform_loop (loop_vinfo,\n-\t\t\t\t\t loop_vectorized_call);\n   (*num_vectorized_loops)++;\n-  /* Now that the loop has been vectorized, allow it to be unrolled\n-     etc.  */\n-  loop->force_vectorize = false;\n-\n-  if (loop->simduid)\n-    {\n-      simduid_to_vf *simduid_to_vf_data = XNEW (simduid_to_vf);\n-      if (!simduid_to_vf_htab)\n-\tsimduid_to_vf_htab = new hash_table<simduid_to_vf> (15);\n-      simduid_to_vf_data->simduid = DECL_UID (loop->simduid);\n-      simduid_to_vf_data->vf = loop_vinfo->vectorization_factor;\n-      *simduid_to_vf_htab->find_slot (simduid_to_vf_data, INSERT)\n-\t  = simduid_to_vf_data;\n-    }\n+  /* Transform LOOP and its epilogues.  */\n+  vect_transform_loops (simduid_to_vf_htab, loop, loop_vectorized_call);\n \n   if (loop_vectorized_call)\n     {\n       fold_loop_internal_call (loop_vectorized_call, boolean_true_node);\n-      loop_vectorized_call = NULL;\n       ret |= TODO_cleanup_cfg;\n     }\n   if (loop_dist_alias_call)\n     {\n       tree value = gimple_call_arg (loop_dist_alias_call, 1);\n       fold_loop_internal_call (loop_dist_alias_call, value);\n-      loop_dist_alias_call = NULL;\n       ret |= TODO_cleanup_cfg;\n     }\n \n-  /* Epilogue of vectorized loop must be vectorized too.  */\n-  if (new_loop)\n-    {\n-      /* Don't include vectorized epilogues in the \"vectorized loops\" count.\n-       */\n-      unsigned dont_count = *num_vectorized_loops;\n-      ret |= try_vectorize_loop_1 (simduid_to_vf_htab, &dont_count,\n-\t\t\t\t   new_loop, NULL, NULL);\n-    }\n-\n   return ret;\n }\n "}]}