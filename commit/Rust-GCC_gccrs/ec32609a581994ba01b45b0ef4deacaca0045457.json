{"sha": "ec32609a581994ba01b45b0ef4deacaca0045457", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMzMjYwOWE1ODE5OTRiYTAxYjQ1YjBlZjRkZWFjYWNhMDA0NTQ1Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-08-31T20:00:19Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-08-31T20:00:19Z"}, "message": "(struct compiler): spec field is now array of 4 elements.\n\n(read_specs): Clear the entire new element of compilers.\n(lookup_compiler): Copy all of spec array.  Check element 0 for @.\n(main): Concatenate all elements of compiler spec.\n(validate_all_switches): Validate from all elements of compiler spec.\n(default_compilers): Split CPP commands into separate strings.\n\nFrom-SVN: r2005", "tree": {"sha": "06ca91bf08e2e5dc232f557749eebce26d7cd2d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06ca91bf08e2e5dc232f557749eebce26d7cd2d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec32609a581994ba01b45b0ef4deacaca0045457", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec32609a581994ba01b45b0ef4deacaca0045457", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec32609a581994ba01b45b0ef4deacaca0045457", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec32609a581994ba01b45b0ef4deacaca0045457/comments", "author": null, "committer": null, "parents": [{"sha": "9029f44dd73414fd72f322183841ee901950a019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9029f44dd73414fd72f322183841ee901950a019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9029f44dd73414fd72f322183841ee901950a019"}], "stats": {"total": 67, "additions": 45, "deletions": 22}, "files": [{"sha": "c6f6860c6faecc69b7ad4b891df186f9f0537aa0", "filename": "gcc/gcc.c", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec32609a581994ba01b45b0ef4deacaca0045457/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec32609a581994ba01b45b0ef4deacaca0045457/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=ec32609a581994ba01b45b0ef4deacaca0045457", "patch": "@@ -398,8 +398,9 @@ struct compiler\n {\n   char *suffix;\t\t\t/* Use this compiler for input files\n \t\t\t\t   whose names end in this suffix.  */\n-  char *spec;\t\t\t/* To use this compiler, pass this spec\n-\t\t\t\t   to do_spec.  */\n+\n+  char *spec[4];\t\t/* To use this compiler, concatenate these\n+\t\t\t\t   specs and pass to do_spec.  */\n };\n \n /* Pointer to a vector of `struct compiler' that gives the spec for\n@@ -431,8 +432,8 @@ static struct compiler default_compilers[] =\n         %c %{O*:-D__OPTIMIZE__} %{traditional} %{ftraditional:-traditional}\\\n         %{traditional-cpp:-traditional}\\\n \t%{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C\\\n-        %i %{!M:%{!MM:%{!E:%{!pipe:%g.i}}}}%{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}} |\\n\\\n-    %{!M:%{!MM:%{!E:cc1 %{!pipe:%g.i} %1 \\\n+        %i %{!M:%{!MM:%{!E:%{!pipe:%g.i}}}}%{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}} |\\n\",\n+   \"%{!M:%{!MM:%{!E:cc1 %{!pipe:%g.i} %1 \\\n \t\t   %{!Q:-quiet} -dumpbase %b.c %{d*} %{m*} %{a}\\\n \t\t   %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi} \\\n \t\t   %{traditional} %{v:-version} %{pg:-p} %{p} %{f*}\\\n@@ -463,8 +464,8 @@ static struct compiler default_compilers[] =\n         %c %{O*:-D__OPTIMIZE__} %{traditional} %{ftraditional:-traditional}\\\n         %{traditional-cpp:-traditional}\\\n \t%{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C\\\n-        %i %{!M:%{!MM:%{!E:%{!pipe:%g.i}}}}%{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}} |\\n\\\n-    %{!M:%{!MM:%{!E:cc1obj %{!pipe:%g.i} %1 \\\n+        %i %{!M:%{!MM:%{!E:%{!pipe:%g.i}}}}%{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}} |\\n\"\n+   \"%{!M:%{!MM:%{!E:cc1obj %{!pipe:%g.i} %1 \\\n \t\t   %{!Q:-quiet} -dumpbase %b.m %{d*} %{m*} %{a}\\\n \t\t   %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi} \\\n \t\t   %{traditional} %{v:-version} %{pg:-p} %{p} %{f*} \\\n@@ -499,8 +500,8 @@ static struct compiler default_compilers[] =\n         %c %{O*:-D__OPTIMIZE__} %{traditional} %{ftraditional:-traditional}\\\n         %{traditional-cpp:-traditional} %{trigraphs}\\\n \t%{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C\\\n-        %i %{!M:%{!MM:%{!E:%{!pipe:%g.i}}}}%{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}} |\\n\\\n-    %{!M:%{!MM:%{!E:cc1plus %{!pipe:%g.i} %1 %2\\\n+        %i %{!M:%{!MM:%{!E:%{!pipe:%g.i}}}}%{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}} |\\n\"\n+   \"%{!M:%{!MM:%{!E:cc1plus %{!pipe:%g.i} %1 %2\\\n \t\t   %{!Q:-quiet} -dumpbase %b.cc %{d*} %{m*} %{a}\\\n \t\t   %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi} %{traditional}\\\n \t\t   %{v:-version} %{pg:-p} %{p} %{f*}\\\n@@ -544,8 +545,8 @@ static struct compiler default_compilers[] =\n         %c %{O*:-D__OPTIMIZE__} %{traditional} %{ftraditional:-traditional}\\\n         %{traditional-cpp:-traditional}\\\n \t%{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C\\\n-        %i %{!M:%{!MM:%{!E:%{!pipe:%g.s}}}}%{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}} |\\n\\\n-    %{!M:%{!MM:%{!E:%{!S:as %{R} %{j} %{J} %{h} %{d2} %a %Y\\\n+        %i %{!M:%{!MM:%{!E:%{!pipe:%g.s}}}}%{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}} |\\n\"\n+   \"%{!M:%{!MM:%{!E:%{!S:as %{R} %{j} %{J} %{h} %{d2} %a %Y\\\n                     %{c:%W{o*}%{!o*:-o %w%b.o}}%{!c:-o %d%w%u.o}\\\n \t\t    %{!pipe:%g.s} %A\\n }}}}\"},\n   /* Mark end of table */\n@@ -691,7 +692,9 @@ read_specs (filename)\n \t    = ((struct compiler *)\n \t       xrealloc (compilers, (n_compilers + 2) * sizeof (struct compiler)));\n \t  compilers[n_compilers].suffix = suffix;\n-\t  compilers[n_compilers].spec = spec;\n+\t  bzero (compilers[n_compilers].spec,\n+\t\t sizeof compilers[n_compilers].spec);\n+\t  compilers[n_compilers].spec[0] = spec;\n \t  n_compilers++;\n \t}\n \n@@ -3332,6 +3335,7 @@ main (argc, argv)\n \t  /* Ok, we found an applicable compiler.  Run its spec.  */\n \t  /* First say how much of input_filename to substitute for %b  */\n \t  register char *p;\n+\t  int len;\n \n \t  input_basename = input_filename;\n \t  for (p = input_filename; *p; p++)\n@@ -3351,7 +3355,21 @@ main (argc, argv)\n \t  else\n \t    input_suffix = \"\";\n \n-\t  value = do_spec (cp->spec);\n+\t  len = 0;\n+\t  for (i = 0; i < sizeof cp->spec / sizeof cp->spec[0]; i++)\n+\t    len += strlen (cp->spec[i]);\n+\n+\t  p = (char *) xmalloc (len + 1);\n+\n+\t  len = 0;\n+\t  for (i = 0; i < sizeof cp->spec / sizeof cp->spec[0]; i++)\n+\t    {\n+\t      strcpy (p + len, cp->spec[i]);\n+\t      len += strlen (cp->spec[i]);\n+\t    }\n+\n+\t  value = do_spec (p);\n+\t  free (p);\n \t  if (value < 0)\n \t    this_file_error = 1;\n \t}\n@@ -3480,17 +3498,18 @@ lookup_compiler (name, length, language)\n \t       /* The suffix `-' matches only the file name `-'.  */\n \t       && !(!strcmp (cp->suffix, \"-\") && length != 1))\n \t{\n-\t  if (cp->spec[0] == '@')\n+\t  if (cp->spec[0][0] == '@')\n \t    {\n \t      struct compiler *new;\n \t      /* An alias entry maps a suffix to a language.\n \t\t Search for the language; pass 0 for NAME and LENGTH\n \t\t to avoid infinite recursion if language not found.\n \t\t Construct the new compiler spec.  */\n-\t      language = cp->spec + 1;\n+\t      language = cp->spec[0] + 1;\n \t      new = (struct compiler *) xmalloc (sizeof (struct compiler));\n \t      new->suffix = cp->suffix;\n-\t      new->spec = lookup_compiler (NULL_PTR, 0, language)->spec;\n+\t      bcopy (lookup_compiler (NULL_PTR, 0, language)->spec,\n+\t\t     new->spec, sizeof new->spec);\n \t      return new;\n \t    }\n \t  /* A non-alias entry: return it.  */\n@@ -3668,17 +3687,21 @@ validate_all_switches ()\n   register char c;\n   struct spec_list *spec;\n \n-  for (comp = compilers; comp->spec; comp++)\n+  for (comp = compilers; comp->spec[0]; comp++)\n     {\n-      p = comp->spec;\n-      while (c = *p++)\n-\tif (c == '%' && *p == '{')\n-\t  /* We have a switch spec.  */\n-\t  validate_switches (p + 1);\n+      int i;\n+      for (i = 0; i < sizeof comp->spec / sizeof comp->spec[0]; i++)\n+\t{\n+\t  p = comp->spec[i];\n+\t  while (c = *p++)\n+\t    if (c == '%' && *p == '{')\n+\t      /* We have a switch spec.  */\n+\t      validate_switches (p + 1);\n+\t}\n     }\n \n   /* look through the linked list of extra specs read from the specs file */\n-  for (spec = specs ; spec ; spec = spec->next)\n+  for (spec = specs; spec ; spec = spec->next)\n     {\n       p = spec->spec;\n       while (c = *p++)"}]}