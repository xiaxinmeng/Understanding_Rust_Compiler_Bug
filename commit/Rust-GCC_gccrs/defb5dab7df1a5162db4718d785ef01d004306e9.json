{"sha": "defb5dab7df1a5162db4718d785ef01d004306e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVmYjVkYWI3ZGYxYTUxNjJkYjQ3MThkNzg1ZWYwMWQwMDQzMDZlOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-21T22:10:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-21T22:10:47Z"}, "message": "Upate comments and copyright notice.\n\nFrom-SVN: r7130", "tree": {"sha": "80e48fedbdfd967fad8ffd11791ffd58cd268156", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80e48fedbdfd967fad8ffd11791ffd58cd268156"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/defb5dab7df1a5162db4718d785ef01d004306e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/defb5dab7df1a5162db4718d785ef01d004306e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/defb5dab7df1a5162db4718d785ef01d004306e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/defb5dab7df1a5162db4718d785ef01d004306e9/comments", "author": null, "committer": null, "parents": [{"sha": "ac4cf5d96fdc73187bf097a0ea4fa9c5cc99d554", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac4cf5d96fdc73187bf097a0ea4fa9c5cc99d554", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac4cf5d96fdc73187bf097a0ea4fa9c5cc99d554"}], "stats": {"total": 940, "additions": 347, "deletions": 593}, "files": [{"sha": "fecd932a6f7010f2009ee293fcbab87caf86c5da", "filename": "gcc/real.c", "status": "modified", "additions": 347, "deletions": 593, "changes": 940, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/defb5dab7df1a5162db4718d785ef01d004306e9/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/defb5dab7df1a5162db4718d785ef01d004306e9/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=defb5dab7df1a5162db4718d785ef01d004306e9", "patch": "@@ -58,10 +58,9 @@ transcendental functions can be obtained by ftp from\n research.att.com: netlib/cephes/ldouble.shar.Z  */\n \f\n /* Type of computer arithmetic.\n- * Only one of DEC, IBM, MIEEE, IBMPC, or UNK should get defined.\n- */\n+   Only one of DEC, IBM, MIEEE, IBMPC, or UNK should get defined.\n \n-/* `MIEEE' refers generically to big-endian IEEE floating-point data\n+   `MIEEE' refers generically to big-endian IEEE floating-point data\n    structure.  This definition should work in SFmode `float' type and\n    DFmode `double' type on virtually all big-endian IEEE machines.\n    If LONG_DOUBLE_TYPE_SIZE has been defined to be 96, then MIEEE\n@@ -142,6 +141,7 @@ unknown arithmetic type\n    target machine's structure and will get its ends swapped\n    accordingly (but not here).  Probably only the decimal <-> binary\n    functions in this file will actually be used in this case.  */\n+\n #if HOST_FLOAT_FORMAT == VAX_FLOAT_FORMAT\n #define DEC 1\n #else /* it's not VAX */\n@@ -530,8 +530,7 @@ endian (e, x, mode)\n }\n \n \n-/* This is the implementation of the REAL_ARITHMETIC macro.\n- */\n+/* This is the implementation of the REAL_ARITHMETIC macro.  */\n \n void \n earith (value, icode, r1, r2)\n@@ -609,9 +608,9 @@ PUT_REAL (v, value);\n }\n \n \n-/* Truncate REAL_VALUE_TYPE toward zero to signed HOST_WIDE_INT\n- * implements REAL_VALUE_RNDZINT (x) (etrunci (x))\n- */\n+/* Truncate REAL_VALUE_TYPE toward zero to signed HOST_WIDE_INT.\n+   implements REAL_VALUE_RNDZINT (x) (etrunci (x)).  */\n+\n REAL_VALUE_TYPE \n etrunci (x)\n      REAL_VALUE_TYPE x;\n@@ -632,9 +631,9 @@ etrunci (x)\n }\n \n \n-/* Truncate REAL_VALUE_TYPE toward zero to unsigned HOST_WIDE_INT\n- * implements REAL_VALUE_UNSIGNED_RNDZINT (x) (etruncui (x))\n- */\n+/* Truncate REAL_VALUE_TYPE toward zero to unsigned HOST_WIDE_INT;\n+   implements REAL_VALUE_UNSIGNED_RNDZINT (x) (etruncui (x)).  */\n+\n REAL_VALUE_TYPE \n etruncui (x)\n      REAL_VALUE_TYPE x;\n@@ -655,11 +654,10 @@ etruncui (x)\n }\n \n \n-/* This is the REAL_VALUE_ATOF function.\n- * It converts a decimal string to binary, rounding off\n- * as indicated by the machine_mode argument.  Then it\n- * promotes the rounded value to REAL_VALUE_TYPE.\n- */\n+/* This is the REAL_VALUE_ATOF function.  It converts a decimal string to\n+   binary, rounding off as indicated by the machine_mode argument.  Then it\n+   promotes the rounded value to REAL_VALUE_TYPE.  */\n+\n REAL_VALUE_TYPE \n ereal_atof (s, t)\n      char *s;\n@@ -694,8 +692,8 @@ ereal_atof (s, t)\n }\n \n \n-/* Expansion of REAL_NEGATE.\n- */\n+/* Expansion of REAL_NEGATE.  */\n+\n REAL_VALUE_TYPE \n ereal_negate (x)\n      REAL_VALUE_TYPE x;\n@@ -710,9 +708,9 @@ ereal_negate (x)\n }\n \n \n-/* Round real toward zero to HOST_WIDE_INT\n- * implements REAL_VALUE_FIX (x).\n- */\n+/* Round real toward zero to HOST_WIDE_INT;\n+   implements REAL_VALUE_FIX (x).  */\n+\n HOST_WIDE_INT\n efixi (x)\n      REAL_VALUE_TYPE x;\n@@ -733,9 +731,9 @@ efixi (x)\n }\n \n /* Round real toward zero to unsigned HOST_WIDE_INT\n- * implements  REAL_VALUE_UNSIGNED_FIX (x).\n- * Negative input returns zero.\n- */\n+   implements  REAL_VALUE_UNSIGNED_FIX (x).\n+   Negative input returns zero.  */\n+\n unsigned HOST_WIDE_INT\n efixui (x)\n      REAL_VALUE_TYPE x;\n@@ -756,8 +754,8 @@ efixui (x)\n }\n \n \n-/* REAL_VALUE_FROM_INT macro.\n- */\n+/* REAL_VALUE_FROM_INT macro.  */\n+\n void \n ereal_from_int (d, i, j)\n      REAL_VALUE_TYPE *d;\n@@ -790,8 +788,7 @@ ereal_from_int (d, i, j)\n }\n \n \n-/* REAL_VALUE_FROM_UNSIGNED_INT macro.\n- */\n+/* REAL_VALUE_FROM_UNSIGNED_INT macro.   */\n \n void \n ereal_from_uint (d, i, j)\n@@ -812,8 +809,8 @@ ereal_from_uint (d, i, j)\n }\n \n \n-/* REAL_VALUE_TO_INT macro\n- */\n+/* REAL_VALUE_TO_INT macro.  */\n+\n void \n ereal_to_int (low, high, rr)\n      HOST_WIDE_INT *low, *high;\n@@ -856,8 +853,8 @@ ereal_to_int (low, high, rr)\n }\n \n \n-/* REAL_VALUE_LDEXP macro.\n- */\n+/* REAL_VALUE_LDEXP macro.  */\n+\n REAL_VALUE_TYPE\n ereal_ldexp (x, n)\n      REAL_VALUE_TYPE x;\n@@ -877,10 +874,12 @@ ereal_ldexp (x, n)\n }\n \n /* These routines are conditionally compiled because functions\n- * of the same names may be defined in fold-const.c.  */\n+   of the same names may be defined in fold-const.c.  */\n+\n #ifdef REAL_ARITHMETIC\n \n /* Check for infinity in a REAL_VALUE_TYPE. */\n+\n int\n target_isinf (x)\n      REAL_VALUE_TYPE x;\n@@ -914,8 +913,7 @@ target_isnan (x)\n \n \n /* Check for a negative REAL_VALUE_TYPE number.\n- * This just checks the sign bit, so that -0 counts as negative.\n- */\n+   This just checks the sign bit, so that -0 counts as negative. */\n \n int\n target_negative (x)\n@@ -925,8 +923,8 @@ target_negative (x)\n }\n \n /* Expansion of REAL_VALUE_TRUNCATE.\n- * The result is in floating point, rounded to nearest or even.\n- */\n+   The result is in floating point, rounded to nearest or even.  */\n+\n REAL_VALUE_TYPE\n real_value_truncate (mode, arg)\n      enum machine_mode mode;\n@@ -970,6 +968,7 @@ real_value_truncate (mode, arg)\n     /* If an unsupported type was requested, presume that\n        the machine files know something useful to do with\n        the unmodified value.  */\n+\n     default:\n       return (arg);\n     }\n@@ -997,6 +996,7 @@ debug_real (r)\n    to be at least 32 bits wide. */\n \n /* 128-bit long double */\n+\n void \n etartdouble (r, l)\n      REAL_VALUE_TYPE r;\n@@ -1010,6 +1010,7 @@ etartdouble (r, l)\n }\n \n /* 80-bit long double */\n+\n void \n etarldouble (r, l)\n      REAL_VALUE_TYPE r;\n@@ -1081,186 +1082,160 @@ ereal_isneg (x)\n \n /* End of REAL_ARITHMETIC interface */\n \f\n-/*\t\t\t\t\t\t\tieee.c\n- *\n- *    Extended precision IEEE binary floating point arithmetic routines\n- *\n- * Numbers are stored in C language as arrays of 16-bit unsigned\n- * short integers.  The arguments of the routines are pointers to\n- * the arrays.\n- *\n- *\n- * External e type data structure, simulates Intel 8087 chip\n- * temporary real format but possibly with a larger significand:\n- *\n- *\tNE-1 significand words\t(least significant word first,\n- *\t\t\t\t most significant bit is normally set)\n- *\texponent\t\t(value = EXONE for 1.0,\n- *\t\t\t\ttop bit is the sign)\n- *\n- *\n- * Internal data structure of a number (a \"word\" is 16 bits):\n- *\n- * ei[0]\tsign word\t(0 for positive, 0xffff for negative)\n- * ei[1]\tbiased exponent\t(value = EXONE for the number 1.0)\n- * ei[2]\thigh guard word\t(always zero after normalization)\n- * ei[3]\n- * to ei[NI-2]\tsignificand\t(NI-4 significand words,\n- *\t\t\t\t most significant word first,\n- *\t\t\t\t most significant bit is set)\n- * ei[NI-1]\tlow guard word\t(0x8000 bit is rounding place)\n- *\n- *\n- *\n- *\t\tRoutines for external format numbers\n- *\n- *\tasctoe (string, e)\tASCII string to extended double e type\n- *\tasctoe64 (string, &d)\tASCII string to long double\n- *\tasctoe53 (string, &d)\tASCII string to double\n- *\tasctoe24 (string, &f)\tASCII string to single\n- *\tasctoeg (string, e, prec) ASCII string to specified precision\n- *\te24toe (&f, e)\t\tIEEE single precision to e type\n- *\te53toe (&d, e)\t\tIEEE double precision to e type\n- *\te64toe (&d, e)\t\tIEEE long double precision to e type\n- *\te113toe (&d, e)\t\t128-bit long double precision to e type\n- *\teabs (e)\t\t\tabsolute value\n- *\teadd (a, b, c)\t\tc = b + a\n- *\teclear (e)\t\te = 0\n- *\tecmp (a, b)\t\tReturns 1 if a > b, 0 if a == b,\n- *\t\t\t\t-1 if a < b, -2 if either a or b is a NaN.\n- *\tediv (a, b, c)\t\tc = b / a\n- *\tefloor (a, b)\t\ttruncate to integer, toward -infinity\n- *\tefrexp (a, exp, s)\textract exponent and significand\n- *\teifrac (e, &l, frac)    e to HOST_WIDE_INT and e type fraction\n- *\teuifrac (e, &l, frac)   e to unsigned HOST_WIDE_INT and e type fraction\n- *\teinfin (e)\t\tset e to infinity, leaving its sign alone\n- *\teldexp (a, n, b)\tmultiply by 2**n\n- *\temov (a, b)\t\tb = a\n- *\temul (a, b, c)\t\tc = b * a\n- *\teneg (e)\t\t\te = -e\n- *\teround (a, b)\t\tb = nearest integer value to a\n- *\tesub (a, b, c)\t\tc = b - a\n- *\te24toasc (&f, str, n)\tsingle to ASCII string, n digits after decimal\n- *\te53toasc (&d, str, n)\tdouble to ASCII string, n digits after decimal\n- *\te64toasc (&d, str, n)\t80-bit long double to ASCII string\n- *\te113toasc (&d, str, n)\t128-bit long double to ASCII string\n- *\tetoasc (e, str, n)\te to ASCII string, n digits after decimal\n- *\tetoe24 (e, &f)\t\tconvert e type to IEEE single precision\n- *\tetoe53 (e, &d)\t\tconvert e type to IEEE double precision\n- *\tetoe64 (e, &d)\t\tconvert e type to IEEE long double precision\n- *\tltoe (&l, e)\t\tHOST_WIDE_INT to e type\n- *\tultoe (&l, e)\t\tunsigned HOST_WIDE_INT to e type\n- *      eisneg (e)              1 if sign bit of e != 0, else 0\n- *      eisinf (e)              1 if e has maximum exponent (non-IEEE)\n- *\t\t\t\tor is infinite (IEEE)\n- *      eisnan (e)              1 if e is a NaN\n- *\n- *\n- *\t\tRoutines for internal format numbers\n- *\n- *\teaddm (ai, bi)\t\tadd significands, bi = bi + ai\n- *\tecleaz (ei)\t\tei = 0\n- *\tecleazs (ei)\t\tset ei = 0 but leave its sign alone\n- *\tecmpm (ai, bi)\t\tcompare significands, return 1, 0, or -1\n- *\tedivm (ai, bi)\t\tdivide  significands, bi = bi / ai\n- *\temdnorm (ai,l,s,exp)\tnormalize and round off\n- *\temovi (a, ai)\t\tconvert external a to internal ai\n- *\temovo (ai, a)\t\tconvert internal ai to external a\n- *\temovz (ai, bi)\t\tbi = ai, low guard word of bi = 0\n- *\temulm (ai, bi)\t\tmultiply significands, bi = bi * ai\n- *\tenormlz (ei)\t\tleft-justify the significand\n- *\teshdn1 (ai)\t\tshift significand and guards down 1 bit\n- *\teshdn8 (ai)\t\tshift down 8 bits\n- *\teshdn6 (ai)\t\tshift down 16 bits\n- *\teshift (ai, n)\t\tshift ai n bits up (or down if n < 0)\n- *\teshup1 (ai)\t\tshift significand and guards up 1 bit\n- *\teshup8 (ai)\t\tshift up 8 bits\n- *\teshup6 (ai)\t\tshift up 16 bits\n- *\tesubm (ai, bi)\t\tsubtract significands, bi = bi - ai\n- *      eiisinf (ai)            1 if infinite\n- *      eiisnan (ai)            1 if a NaN\n- *\teiisneg (ai)\t\t1 if sign bit of ai != 0, else 0\n- *      einan (ai)              set ai = NaN\n- *      eiinfin (ai)            set ai = infinity\n- *\n- *\n- * The result is always normalized and rounded to NI-4 word precision\n- * after each arithmetic operation.\n- *\n- * Exception flags are NOT fully supported.\n- *\n- * Signaling NaN's are NOT supported; they are treated the same\n- * as quiet NaN's.\n- *\n- * Define INFINITY for support of infinity; otherwise a\n- * saturation arithmetic is implemented.\n- *\n- * Define NANS for support of Not-a-Number items; otherwise the\n- * arithmetic will never produce a NaN output, and might be confused\n- * by a NaN input.\n- * If NaN's are supported, the output of `ecmp (a,b)' is -2 if\n- * either a or b is a NaN. This means asking `if (ecmp (a,b) < 0)'\n- * may not be legitimate. Use `if (ecmp (a,b) == -1)' for `less than'\n- * if in doubt.\n- *\n- * Denormals are always supported here where appropriate (e.g., not\n- * for conversion to DEC numbers).\n- *\n- */\n-\n+/*\n+  Extended precision IEEE binary floating point arithmetic routines\n+\n+  Numbers are stored in C language as arrays of 16-bit unsigned\n+  short integers.  The arguments of the routines are pointers to\n+  the arrays.\n+\n+  External e type data structure, simulates Intel 8087 chip\n+  temporary real format but possibly with a larger significand:\n+\n+\tNE-1 significand words\t(least significant word first,\n+\t\t\t\t most significant bit is normally set)\n+\texponent\t\t(value = EXONE for 1.0,\n+\t\t\t\ttop bit is the sign)\n+\n+\n+  Internal data structure of a number (a \"word\" is 16 bits):\n+\n+  ei[0]\tsign word\t(0 for positive, 0xffff for negative)\n+  ei[1]\tbiased exponent\t(value = EXONE for the number 1.0)\n+  ei[2]\thigh guard word\t(always zero after normalization)\n+  ei[3]\n+  to ei[NI-2]\tsignificand\t(NI-4 significand words,\n+ \t\t\t\t most significant word first,\n+ \t\t\t\t most significant bit is set)\n+  ei[NI-1]\tlow guard word\t(0x8000 bit is rounding place)\n+ \n+ \n+ \n+ \t\tRoutines for external format numbers\n+ \n+ \tasctoe (string, e)\tASCII string to extended double e type\n+ \tasctoe64 (string, &d)\tASCII string to long double\n+ \tasctoe53 (string, &d)\tASCII string to double\n+ \tasctoe24 (string, &f)\tASCII string to single\n+ \tasctoeg (string, e, prec) ASCII string to specified precision\n+ \te24toe (&f, e)\t\tIEEE single precision to e type\n+ \te53toe (&d, e)\t\tIEEE double precision to e type\n+ \te64toe (&d, e)\t\tIEEE long double precision to e type\n+ \te113toe (&d, e)\t\t128-bit long double precision to e type\n+ \teabs (e)\t\t\tabsolute value\n+ \teadd (a, b, c)\t\tc = b + a\n+ \teclear (e)\t\te = 0\n+ \tecmp (a, b)\t\tReturns 1 if a > b, 0 if a == b,\n+ \t\t\t\t-1 if a < b, -2 if either a or b is a NaN.\n+ \tediv (a, b, c)\t\tc = b / a\n+ \tefloor (a, b)\t\ttruncate to integer, toward -infinity\n+ \tefrexp (a, exp, s)\textract exponent and significand\n+ \teifrac (e, &l, frac)    e to HOST_WIDE_INT and e type fraction\n+ \teuifrac (e, &l, frac)   e to unsigned HOST_WIDE_INT and e type fraction\n+ \teinfin (e)\t\tset e to infinity, leaving its sign alone\n+ \teldexp (a, n, b)\tmultiply by 2**n\n+ \temov (a, b)\t\tb = a\n+ \temul (a, b, c)\t\tc = b * a\n+ \teneg (e)\t\t\te = -e\n+ \teround (a, b)\t\tb = nearest integer value to a\n+ \tesub (a, b, c)\t\tc = b - a\n+ \te24toasc (&f, str, n)\tsingle to ASCII string, n digits after decimal\n+ \te53toasc (&d, str, n)\tdouble to ASCII string, n digits after decimal\n+ \te64toasc (&d, str, n)\t80-bit long double to ASCII string\n+ \te113toasc (&d, str, n)\t128-bit long double to ASCII string\n+ \tetoasc (e, str, n)\te to ASCII string, n digits after decimal\n+ \tetoe24 (e, &f)\t\tconvert e type to IEEE single precision\n+ \tetoe53 (e, &d)\t\tconvert e type to IEEE double precision\n+ \tetoe64 (e, &d)\t\tconvert e type to IEEE long double precision\n+ \tltoe (&l, e)\t\tHOST_WIDE_INT to e type\n+ \tultoe (&l, e)\t\tunsigned HOST_WIDE_INT to e type\n+\teisneg (e)              1 if sign bit of e != 0, else 0\n+\teisinf (e)              1 if e has maximum exponent (non-IEEE)\n+ \t\t\t\tor is infinite (IEEE)\n+        eisnan (e)              1 if e is a NaN\n+ \n+\n+ \t\tRoutines for internal format numbers\n+ \n+ \teaddm (ai, bi)\t\tadd significands, bi = bi + ai\n+ \tecleaz (ei)\t\tei = 0\n+ \tecleazs (ei)\t\tset ei = 0 but leave its sign alone\n+ \tecmpm (ai, bi)\t\tcompare significands, return 1, 0, or -1\n+ \tedivm (ai, bi)\t\tdivide  significands, bi = bi / ai\n+ \temdnorm (ai,l,s,exp)\tnormalize and round off\n+ \temovi (a, ai)\t\tconvert external a to internal ai\n+ \temovo (ai, a)\t\tconvert internal ai to external a\n+ \temovz (ai, bi)\t\tbi = ai, low guard word of bi = 0\n+ \temulm (ai, bi)\t\tmultiply significands, bi = bi * ai\n+ \tenormlz (ei)\t\tleft-justify the significand\n+ \teshdn1 (ai)\t\tshift significand and guards down 1 bit\n+ \teshdn8 (ai)\t\tshift down 8 bits\n+ \teshdn6 (ai)\t\tshift down 16 bits\n+ \teshift (ai, n)\t\tshift ai n bits up (or down if n < 0)\n+ \teshup1 (ai)\t\tshift significand and guards up 1 bit\n+ \teshup8 (ai)\t\tshift up 8 bits\n+ \teshup6 (ai)\t\tshift up 16 bits\n+ \tesubm (ai, bi)\t\tsubtract significands, bi = bi - ai\n+        eiisinf (ai)            1 if infinite\n+        eiisnan (ai)            1 if a NaN\n+ \teiisneg (ai)\t\t1 if sign bit of ai != 0, else 0\n+        einan (ai)              set ai = NaN\n+        eiinfin (ai)            set ai = infinity\n+\n+  The result is always normalized and rounded to NI-4 word precision\n+  after each arithmetic operation.\n+\n+  Exception flags are NOT fully supported.\n+ \n+  Signaling NaN's are NOT supported; they are treated the same\n+  as quiet NaN's.\n+ \n+  Define INFINITY for support of infinity; otherwise a\n+  saturation arithmetic is implemented.\n+ \n+  Define NANS for support of Not-a-Number items; otherwise the\n+  arithmetic will never produce a NaN output, and might be confused\n+  by a NaN input.\n+  If NaN's are supported, the output of `ecmp (a,b)' is -2 if\n+  either a or b is a NaN. This means asking `if (ecmp (a,b) < 0)'\n+  may not be legitimate. Use `if (ecmp (a,b) == -1)' for `less than'\n+  if in doubt.\n+ \n+  Denormals are always supported here where appropriate (e.g., not\n+  for conversion to DEC numbers).  */\n+\n+/* Definitions for error codes that are passed to the common error handling\n+   routine mtherr.\n+\n+   For Digital Equipment PDP-11 and VAX computers, certain\n+  IBM systems, and others that use numbers with a 56-bit\n+  significand, the symbol DEC should be defined.  In this\n+  mode, most floating point constants are given as arrays\n+  of octal integers to eliminate decimal to binary conversion\n+  errors that might be introduced by the compiler.\n+ \n+  For computers, such as IBM PC, that follow the IEEE\n+  Standard for Binary Floating Point Arithmetic (ANSI/IEEE\n+  Std 754-1985), the symbol IBMPC or MIEEE should be defined.\n+  These numbers have 53-bit significands.  In this mode, constants\n+  are provided as arrays of hexadecimal 16 bit integers.\n+ \n+  To accommodate other types of computer arithmetic, all\n+  constants are also provided in a normal decimal radix\n+  which one can hope are correctly converted to a suitable\n+  format by the available C language compiler.  To invoke\n+  this mode, the symbol UNK is defined.\n+ \n+  An important difference among these modes is a predefined\n+  set of machine arithmetic constants for each.  The numbers\n+  MACHEP (the machine roundoff error), MAXNUM (largest number\n+  represented), and several other parameters are preset by\n+  the configuration symbol.  Check the file const.c to\n+  ensure that these values are correct for your computer.\n+ \n+  For ANSI C compatibility, define ANSIC equal to 1.  Currently\n+  this affects only the atan2 function and others that use it. */\n \n-/*\t\t\t\t\t\t\tmconf.h\n- *\n- *\tCommon include file for math routines\n- *\n- *\n- *\n- * SYNOPSIS:\n- *\n- * #include \"mconf.h\"\n- *\n- *\n- *\n- * DESCRIPTION:\n- *\n- * This file contains definitions for error codes that are\n- * passed to the common error handling routine mtherr\n- * (which see).\n- *\n- * The file also includes a conditional assembly definition\n- * for the type of computer arithmetic (Intel IEEE, DEC, Motorola\n- * IEEE, or UNKnown).\n- *\n- * For Digital Equipment PDP-11 and VAX computers, certain\n- * IBM systems, and others that use numbers with a 56-bit\n- * significand, the symbol DEC should be defined.  In this\n- * mode, most floating point constants are given as arrays\n- * of octal integers to eliminate decimal to binary conversion\n- * errors that might be introduced by the compiler.\n- *\n- * For computers, such as IBM PC, that follow the IEEE\n- * Standard for Binary Floating Point Arithmetic (ANSI/IEEE\n- * Std 754-1985), the symbol IBMPC or MIEEE should be defined.\n- * These numbers have 53-bit significands.  In this mode, constants\n- * are provided as arrays of hexadecimal 16 bit integers.\n- *\n- * To accommodate other types of computer arithmetic, all\n- * constants are also provided in a normal decimal radix\n- * which one can hope are correctly converted to a suitable\n- * format by the available C language compiler.  To invoke\n- * this mode, the symbol UNK is defined.\n- *\n- * An important difference among these modes is a predefined\n- * set of machine arithmetic constants for each.  The numbers\n- * MACHEP (the machine roundoff error), MAXNUM (largest number\n- * represented), and several other parameters are preset by\n- * the configuration symbol.  Check the file const.c to\n- * ensure that these values are correct for your computer.\n- *\n- * For ANSI C compatibility, define ANSIC equal to 1.  Currently\n- * this affects only the atan2 function and others that use it.\n- */\n-\f\n /* Constant definitions for math error conditions.  */\n \n #define DOMAIN\t\t1\t/* argument domain error */\n@@ -1345,20 +1320,12 @@ unsigned EMUSHORT epi[NE] =\n \n \n /* Control register for rounding precision.\n- * This can be set to 113 (if NE=10), 80 (if NE=6), 64, 56, 53, or 24 bits.\n- */\n+   This can be set to 113 (if NE=10), 80 (if NE=6), 64, 56, 53, or 24 bits.  */\n+\n int rndprc = NBITS;\n extern int rndprc;\n \n-static void toe24 (), toe53 (), toe64 (), toe113 ();\n-\n-\n-/*\n-; Clear out entire external format number.\n-;\n-; unsigned EMUSHORT x[];\n-; eclear (x);\n-*/\n+/*  Clear out entire external format number.  */\n \n static void \n eclear (x)\n@@ -1372,10 +1339,7 @@ eclear (x)\n \n \n \n-/* Move external format number from a to b.\n- *\n- * emov (a, b);\n- */\n+/* Move external format number from a to b.  */\n \n static void \n emov (a, b)\n@@ -1388,12 +1352,7 @@ emov (a, b)\n }\n \n \n-/*\n-;\tAbsolute value of external format number\n-;\n-;\tEMUSHORT x[NE];\n-;\teabs (x);\n-*/\n+/* Absolute value of external format number.  */\n \n static void \n eabs (x)\n@@ -1403,15 +1362,7 @@ eabs (x)\n   x[NE - 1] &= 0x7fff;\t\t\n }\n \n-\n-\n-\n-/*\n-;\tNegate external format number\n-;\n-;\tunsigned EMUSHORT x[NE];\n-;\teneg (x);\n-*/\n+/* Negate external format number.  */\n \n static void \n eneg (x)\n@@ -1423,9 +1374,8 @@ eneg (x)\n \n \n \n-/* Return 1 if sign bit of external format number is nonzero,\n- * else return zero.\n- */\n+/* Return 1 if sign bit of external format number is nonzero, else zero.  */\n+\n static int \n eisneg (x)\n      unsigned EMUSHORT x[];\n@@ -1438,9 +1388,7 @@ eisneg (x)\n }\n \n \n-/* Return 1 if external format number is infinity.\n- * else return zero.\n- */\n+/* Return 1 if external format number is infinity, else return zero.  */\n \n static int \n eisinf (x)\n@@ -1458,27 +1406,27 @@ eisinf (x)\n }\n \n \n-/* Check if e-type number is not a number.\n-   The bit pattern is one that we defined, so we know for sure how to\n-   detect it.  */\n+/* Check if e-type number is not a number.  The bit pattern is one that we\n+   defined, so we know for sure how to detect it.  */\n \n static int \n eisnan (x)\n      unsigned EMUSHORT x[];\n {\n-\n #ifdef NANS\n   int i;\n-/* NaN has maximum exponent */\n+\n+  /* NaN has maximum exponent */\n   if ((x[NE - 1] & 0x7fff) != 0x7fff)\n     return (0);\n-/* ... and non-zero significand field. */\n+  /* ... and non-zero significand field. */\n   for (i = 0; i < NE - 1; i++)\n     {\n       if (*x++ != 0)\n         return (1);\n     }\n #endif\n+\n   return (0);\n }\n \n@@ -1543,9 +1491,8 @@ enan (x, sign)\n }\n \n \n-/* Move in external format number,\n- * converting it to internal format.\n- */\n+/* Move in external format number, converting it to internal format.  */\n+\n static void \n emovi (a, b)\n      unsigned EMUSHORT *a, *b;\n@@ -1575,11 +1522,13 @@ emovi (a, b)\n \t  return;\n \t}\n #endif\n+\n       for (i = 2; i < NI; i++)\n \t*q++ = 0;\n       return;\n     }\n #endif\n+\n   /* clear high guard word */\n   *q++ = 0;\n   /* move in the significand */\n@@ -1590,9 +1539,8 @@ emovi (a, b)\n }\n \n \n-/* Move internal format number out,\n- * converting it to external format.\n- */\n+/* Move internal format number out, converting it to external format.  */\n+\n static void \n emovo (a, b)\n      unsigned EMUSHORT *a, *b;\n@@ -1630,11 +1578,7 @@ emovo (a, b)\n     *q-- = *p++;\n }\n \n-\n-\n-\n-/* Clear out internal format number.\n- */\n+/* Clear out internal format number.  */\n \n static void \n ecleaz (xi)\n@@ -1647,7 +1591,7 @@ ecleaz (xi)\n }\n \n \n-/* same, but don't touch the sign. */\n+/* Same, but don't touch the sign. */\n \n static void \n ecleazs (xi)\n@@ -1662,8 +1606,7 @@ ecleazs (xi)\n \n \n \n-/* Move internal format number from a to b.\n- */\n+/* Move internal format number from a to b.  */\n \n static void \n emovz (a, b)\n@@ -1679,7 +1622,7 @@ emovz (a, b)\n \n /* Generate internal format NaN.\n    The explicit pattern for this is maximum exponent and\n-   top two significand bits set.  */\n+   top two significant bits set.  */\n \n static void\n einan (x)\n@@ -1749,18 +1692,12 @@ eiisinf (x)\n }\n \n \n-/*\n-;\tCompare significands of numbers in internal format.\n-;\tGuard words are included in the comparison.\n-;\n-;\tunsigned EMUSHORT a[NI], b[NI];\n-;\tcmpm (a, b);\n-;\n-;\tfor the significands:\n-;\treturns\t+1 if a > b\n-;\t\t 0 if a == b\n-;\t\t-1 if a < b\n-*/\n+/* Compare significands of numbers in internal format.\n+   Guard words are included in the comparison.\n+\n+   Returns\t+1 if a > b\n+\t\t 0 if a == b\n+\t\t-1 if a < b   */\n \n static int\n ecmpm (a, b)\n@@ -1785,9 +1722,7 @@ ecmpm (a, b)\n }\n \n \n-/*\n-;\tShift significand down by 1 bit\n-*/\n+/* Shift significand down by 1 bit.  */\n \n static void \n eshdn1 (x)\n@@ -1813,9 +1748,7 @@ eshdn1 (x)\n \n \n \n-/*\n-;\tShift significand up by 1 bit\n-*/\n+/* Shift significand up by 1 bit.  */\n \n static void \n eshup1 (x)\n@@ -1840,10 +1773,7 @@ eshup1 (x)\n }\n \n \n-\n-/*\n-;\tShift significand down by 8 bits\n-*/\n+/* Shift significand down by 8 bits.  */\n \n static void \n eshdn8 (x)\n@@ -1864,9 +1794,7 @@ eshdn8 (x)\n     }\n }\n \n-/*\n-;\tShift significand up by 8 bits\n-*/\n+/* Shift significand up by 8 bits.  */\n \n static void \n eshup8 (x)\n@@ -1888,9 +1816,7 @@ eshup8 (x)\n     }\n }\n \n-/*\n-;\tShift significand up by 16 bits\n-*/\n+/* Shift significand up by 16 bits.  */\n \n static void \n eshup6 (x)\n@@ -1908,9 +1834,7 @@ eshup6 (x)\n   *p = 0;\n }\n \n-/*\n-;\tShift significand down by 16 bits\n-*/\n+/* Shift significand down by 16 bits.  */\n \n static void \n eshdn6 (x)\n@@ -1928,10 +1852,7 @@ eshdn6 (x)\n   *(--p) = 0;\n }\n \f\n-/*\n-;\tAdd significands\n-;\tx + y replaces y\n-*/\n+/* Add significands.  x + y replaces y.  */\n \n static void \n eaddm (x, y)\n@@ -1957,10 +1878,7 @@ eaddm (x, y)\n     }\n }\n \n-/*\n-;\tSubtract significands\n-;\ty - x replaces y\n-*/\n+/* Subtract significands.  y - x replaces y.  */\n \n static void \n esubm (x, y)\n@@ -2013,9 +1931,9 @@ edivm (den, num)\n       *p++ = 0;\n     }\n \n-  /* Use faster compare and subtraction if denominator\n-   * has only 15 bits of significance.\n-   */\n+  /* Use faster compare and subtraction if denominator has only 15 bits of\n+     significance.  */\n+\n   p = &den[M + 2];\n   if (*p++ == 0)\n     {\n@@ -2050,9 +1968,9 @@ edivm (den, num)\n       goto divdon;\n     }\n \n-  /* The number of quotient bits to calculate is\n-   * NBITS + 1 scaling guard bit + 1 roundoff bit.\n-   */\n+  /* The number of quotient bits to calculate is NBITS + 1 scaling guard\n+     bit + 1 roundoff bit.  */\n+\n  fulldiv:\n \n   p = &equot[NI - 2];\n@@ -2107,7 +2025,7 @@ emulm (a, b)\n \n   p = &a[NI - 2];\n   k = NBITS;\n-  while (*p == 0)\t\t/* significand is not supposed to be all zero */\n+  while (*p == 0)\t\t/* significand is not supposed to be zero */\n     {\n       eshdn6 (a);\n       k -= 16;\n@@ -2297,25 +2215,23 @@ emulm (a, b)\n #endif\n \n \n-/*\n- * Normalize and round off.\n- *\n- * The internal format number to be rounded is \"s\".\n- * Input \"lost\" indicates whether or not the number is exact.\n- * This is the so-called sticky bit.\n- *\n- * Input \"subflg\" indicates whether the number was obtained\n- * by a subtraction operation.  In that case if lost is nonzero\n- * then the number is slightly smaller than indicated.\n- *\n- * Input \"exp\" is the biased exponent, which may be negative.\n- * the exponent field of \"s\" is ignored but is replaced by\n- * \"exp\" as adjusted by normalization and rounding.\n- *\n- * Input \"rcntrl\" is the rounding control.\n- */\n+/* Normalize and round off.\n \n-/* For future reference:  In order for emdnorm to round off denormal\n+  The internal format number to be rounded is \"s\".\n+  Input \"lost\" indicates whether or not the number is exact.\n+  This is the so-called sticky bit.\n+ \n+  Input \"subflg\" indicates whether the number was obtained\n+  by a subtraction operation.  In that case if lost is nonzero\n+  then the number is slightly smaller than indicated.\n+ \n+  Input \"exp\" is the biased exponent, which may be negative.\n+  the exponent field of \"s\" is ignored but is replaced by\n+  \"exp\" as adjusted by normalization and rounding.\n+ \n+  Input \"rcntrl\" is the rounding control.\n+\n+  For future reference:  In order for emdnorm to round off denormal\n    significands at the right point, the input exponent must be\n    adjusted to be the actual value it would have after conversion to\n    the final floating point type.  This adjustment has been\n@@ -2528,12 +2444,7 @@ emdnorm (s, lost, subflg, exp, rcntrl)\n \n \n \n-/*\n-;\tSubtract external format numbers.\n-;\n-;\tunsigned EMUSHORT a[NE], b[NE], c[NE];\n-;\tesub (a, b, c);\t c = b - a\n-*/\n+/*  Subtract external format numbers.  */\n \n static int subflg = 0;\n \n@@ -2568,12 +2479,7 @@ esub (a, b, c)\n }\n \n \n-/*\n-;\tAdd.\n-;\n-;\tunsigned EMUSHORT a[NE], b[NE], c[NE];\n-;\teadd (a, b, c);\t c = b + a\n-*/\n+/* Add.  */\n \n static void \n eadd (a, b, c)\n@@ -2710,12 +2616,7 @@ eadd1 (a, b, c)\n \n \n \n-/*\n-;\tDivide.\n-;\n-;\tunsigned EMUSHORT a[NE], b[NE], c[NE];\n-;\tediv (a, b, c);\tc = b / a\n-*/\n+/* Divide.  */\n \n static void \n ediv (a, b, c)\n@@ -2819,12 +2720,7 @@ ediv (a, b, c)\n \n \n \n-/*\n-;\tMultiply.\n-;\n-;\tunsigned EMUSHORT a[NE], b[NE], c[NE];\n-;\temul (a, b, c);\tc = b * a\n-*/\n+/* Multiply.  */\n \n static void \n emul (a, b, c)\n@@ -2917,12 +2813,7 @@ emul (a, b, c)\n \n \n \n-/*\n-; Convert IEEE double precision to e type\n-;\tdouble d;\n-;\tunsigned EMUSHORT x[N+2];\n-;\te53toe (&d, x);\n-*/\n+/* Convert IEEE double precision to e type.  */\n \n static void\n e53toe (pe, y)\n@@ -2984,7 +2875,8 @@ e53toe (pe, y)\n #endif  /* INFINITY */\n   r >>= 4;\n   /* If zero exponent, then the significand is denormalized.\n-   * So, take back the understood high significand bit. */\n+     So take back the understood high significand bit. */\n+\n   if (r == 0)\n     {\n       denorm = 1;\n@@ -3166,12 +3058,7 @@ e113toe (pe, y)\n }\n \n \n-/*\n-; Convert IEEE single precision to e type\n-;\tfloat d;\n-;\tunsigned EMUSHORT x[N+2];\n-;\tdtox (&d, x);\n-*/\n+/* Convert IEEE single precision to e type.  */\n \n static void \n e24toe (pe, y)\n@@ -3229,7 +3116,7 @@ e24toe (pe, y)\n #endif  /* INFINITY */\n   r >>= 7;\n   /* If zero exponent, then the significand is denormalized.\n-   * So, take back the understood high significand bit. */\n+     So take back the understood high significand bit. */\n   if (r == 0)\n     {\n       denorm = 1;\n@@ -3291,7 +3178,7 @@ etoe113 (x, e)\n   toe113 (xi, e);\n }\n \n-/* move out internal format to ieee long double */\n+/* Move out internal format to ieee long double */\n \n static void \n toe113 (a, b)\n@@ -3376,7 +3263,8 @@ etoe64 (x, e)\n }\n \n \n-/* move out internal format to ieee long double */\n+/* Move out internal format to ieee long double. */\n+\n static void \n toe64 (a, b)\n      unsigned EMUSHORT *a, *b;\n@@ -3429,12 +3317,7 @@ toe64 (a, b)\n }\n \n \n-/*\n-; e type to IEEE double precision\n-;\tdouble d;\n-;\tunsigned EMUSHORT x[NE];\n-;\tetoe53 (x, &d);\n-*/\n+/* e type to IEEE double precision.  */\n \n #ifdef DEC\n \n@@ -3586,12 +3469,8 @@ toe53 (x, y)\n \n \n \n-/*\n-; e type to IEEE single precision\n-;\tfloat d;\n-;\tunsigned EMUSHORT x[N+2];\n-;\txtod (x, &d);\n-*/\n+/* e type to IEEE single precision.  */\n+\n #ifdef IBM\n \n void \n@@ -3724,16 +3603,11 @@ toe24 (x, y)\n }\n #endif  /* not IBM */\n \n-/* Compare two e type numbers.\n- *\n- * unsigned EMUSHORT a[NE], b[NE];\n- * ecmp (a, b);\n- *\n- *  returns +1 if a > b\n- *           0 if a == b\n- *          -1 if a < b\n- *          -2 if either a or b is a NaN.\n- */\n+/* Compare two e type numbers. \n+   Return +1 if a > b\n+           0 if a == b\n+          -1 if a < b\n+          -2 if either a or b is a NaN.  */\n \n static int \n ecmp (a, b)\n@@ -3800,11 +3674,7 @@ ecmp (a, b)\n \n \n \n-/* Find nearest integer to x = floor (x + 0.5)\n- *\n- * unsigned EMUSHORT x[NE], y[NE]\n- * eround (x, y);\n- */\n+/* Find nearest integer to x = floor (x + 0.5).  */\n \n static void \n eround (x, y)\n@@ -3817,14 +3687,7 @@ eround (x, y)\n \n \n \n-/*\n-; convert HOST_WIDE_INT to e type\n-;\n-;\tHOST_WIDE_INT l;\n-;\tunsigned EMUSHORT x[NE];\n-;\tltoe (&l, x);\n-; note &l is the memory address of l\n-*/\n+/* Convert HOST_WIDE_INT to e type.  */\n \n static void \n ltoe (lp, y)\n@@ -3866,14 +3729,7 @@ ltoe (lp, y)\n   emovo (yi, y);\t\t/* output the answer */\n }\n \n-/*\n-; convert unsigned HOST_WIDE_INT to e type\n-;\n-;\tunsigned HOST_WIDE_INT l;\n-;\tunsigned EMUSHORT x[NE];\n-;\tltox (&l, x);\n-; note &l is the memory address of l\n-*/\n+/* Convert unsigned HOST_WIDE_INT to e type.  */\n \n static void \n ultoe (lp, y)\n@@ -4067,12 +3923,7 @@ euifrac (x, i, frac)\n \n \n \n-/*\n-;\tShift significand\n-;\n-;\tShifts significand area up or down by the number of bits\n-;\tgiven by the variable sc.\n-*/\n+/* Shift significand area up or down by the number of bits given by SC.  */\n \n static int \n eshift (x, sc)\n@@ -4139,12 +3990,8 @@ eshift (x, sc)\n \n \n \n-/*\n-;\tnormalize\n-;\n-; Shift normalizes the significand area pointed to by argument\n-; shift count (up = positive) is returned.\n-*/\n+/* Shift normalize the significand area pointed to by argument.\n+   Shift count (up = positive) is returned.  */\n \n static int \n enormlz (x)\n@@ -4164,9 +4011,9 @@ enormlz (x)\n     {\n       eshup6 (x);\n       sc += 16;\n+\n       /* With guard word, there are NBITS+16 bits available.\n-       * return true if all are zero.\n-       */\n+       Return true if all are zero.  */\n       if (sc > NBITS)\n \treturn (sc);\n     }\n@@ -4216,8 +4063,7 @@ enormlz (x)\n \n \n /* Convert e type number to decimal format ASCII string.\n- * The constants are for 64 bit precision.\n- */\n+   The constants are for 64 bit precision.  */\n \n #define NTEN 12\n #define MAXP 4096\n@@ -4679,26 +4525,13 @@ etoasc (x, string, ndigs)\n }\n \n \n+/* Convert ASCII string to quadruple precision floating point\n \n-\n-/*\n-;\t\t\t\t\t\t\t\tASCTOQ\n-;\t\tASCTOQ.MAC\t\tLATEST REV: 11 JAN 84\n-;\t\t\t\t\tSLM, 3 JAN 78\n-;\n-;\tConvert ASCII string to quadruple precision floating point\n-;\n-;\t\tNumeric input is free field decimal number\n-;\t\twith max of 15 digits with or without\n-;\t\tdecimal point entered as ASCII from teletype.\n-;\tEntering E after the number followed by a second\n-;\tnumber causes the second number to be interpreted\n-;\tas a power of 10 to be multiplied by the first number\n-;\t(i.e., \"scientific\" notation).\n-;\n-;\tUsage:\n-;\t\tasctoq (string, q);\n-*/\n+   Numeric input is free field decimal number with max of 15 digits with or\n+   without decimal point entered as ASCII from teletype.  Entering E after\n+   the number followed by a second number causes the second number to be\n+   interpreted as a power of 10 to be multiplied by the first number\n+   (i.e., \"scientific\" notation).  */\n \n /* ASCII to single */\n \n@@ -4747,6 +4580,7 @@ asctoe113 (s, y)\n }\n \n /* ASCII to super double */\n+\n static void \n asctoe (s, y)\n      char *s;\n@@ -4757,6 +4591,7 @@ asctoe (s, y)\n \n \n /* ASCII to e type, with specified rounding precision = oprec. */\n+\n static void \n asctoeg (ss, y, oprec)\n      char *ss;\n@@ -4818,11 +4653,12 @@ asctoeg (ss, y, oprec)\n \t  if (*s == 'z')\n \t    goto donchr;\n \t}\n+\n       /* If enough digits were given to more than fill up the yy register,\n-       * continuing until overflow into the high guard word yy[2]\n-       * guarantees that there will be a roundoff bit at the top\n-       * of the low guard word after normalization.\n-       */\n+\t continuing until overflow into the high guard word yy[2]\n+\t guarantees that there will be a roundoff bit at the top\n+\t of the low guard word after normalization.  */\n+\n       if (yy[2] == 0)\n \t{\n \t  if (decflg)\n@@ -4958,15 +4794,15 @@ asctoeg (ss, y, oprec)\n     }\n   lexp = (EXONE - 1 + NBITS) - k;\n   emdnorm (yy, lost, 0, lexp, 64);\n-  /* convert to external format */\n \n+  /* Convert to external format:\n+\n+     Multiply by 10**nexp.  If precision is 64 bits,\n+     the maximum relative error incurred in forming 10**n\n+     for 0 <= n <= 324 is 8.2e-20, at 10**180.\n+     For 0 <= n <= 999, the peak relative error is 1.4e-19 at 10**947.\n+     For 0 >= n >= -999, it is -1.55e-19 at 10**-435.  */\n \n-  /* Multiply by 10**nexp.  If precision is 64 bits,\n-   * the maximum relative error incurred in forming 10**n\n-   * for 0 <= n <= 324 is 8.2e-20, at 10**180.\n-   * For 0 <= n <= 999, the peak relative error is 1.4e-19 at 10**947.\n-   * For 0 >= n >= -999, it is -1.55e-19 at 10**-435.\n-   */\n   lexp = yy[E];\n   if (nexp == 0)\n     {\n@@ -4979,7 +4815,8 @@ asctoeg (ss, y, oprec)\n       nexp = -nexp;\n       esign = -1;\n       if (nexp > 4096)\n-\t{\t\t\t/* Punt.  Can't handle this without 2 divides. */\n+\t{\n+\t  /* Punt.  Can't handle this without 2 divides. */\n \t  emovi (etens[0], tt);\n \t  lexp -= tt[E];\n \t  k = edivm (tt, yy);\n@@ -5068,13 +4905,8 @@ asctoeg (ss, y, oprec)\n \n \n \n-/* y = largest integer not greater than x\n- * (truncated toward minus infinity)\n- *\n- * unsigned EMUSHORT x[NE], y[NE]\n- *\n- * efloor (x, y);\n- */\n+/* y = largest integer not greater than x (truncated toward minus infinity)  */\n+\n static unsigned EMUSHORT bmask[] =\n {\n   0xffff,\n@@ -5143,15 +4975,9 @@ efloor (x, y)\n }\n \n \n-/* unsigned EMUSHORT x[], s[];\n- * int *exp;\n- *\n- * efrexp (x, exp, s);\n- *\n- * Returns s and exp such that  s * 2**exp = x and .5 <= s < 1.\n- * For example, 1.1 = 0.55 * 2**1\n- * Handles denormalized numbers properly using long integer exp.\n- */\n+/* Returns s and exp such that  s * 2**exp = x and .5 <= s < 1.\n+   For example, 1.1 = 0.55 * 2**1\n+   Handles denormalized numbers properly using long integer exp.  */\n \n static void \n efrexp (x, exp, s)\n@@ -5176,13 +5002,7 @@ efrexp (x, exp, s)\n \n \n \n-/* unsigned EMUSHORT x[], y[];\n- * int pwr2;\n- *\n- * eldexp (x, pwr2, y);\n- *\n- * Returns y = x * 2**pwr2.\n- */\n+/* Return y = x * 2**pwr2.  */\n \n static void \n eldexp (x, pwr2, y)\n@@ -5204,8 +5024,7 @@ eldexp (x, pwr2, y)\n \n \n /* c = remainder after dividing b by a\n- * Least significant integer quotient bits left in equot[].\n- */\n+   Least significant integer quotient bits left in equot[].  */\n \n static void \n eremain (a, b, c)\n@@ -5271,69 +5090,36 @@ eiremain (den, num)\n   emdnorm (num, 0, 0, ln, 0);\n }\n \n-/*\t\t\t\t\t\t\tmtherr.c\n- *\n- *\tLibrary common error handling routine\n- *\n- *\n- *\n- * SYNOPSIS:\n- *\n- * char *fctnam;\n- * int code;\n- * void mtherr ();\n- *\n- * mtherr (fctnam, code);\n- *\n- *\n- *\n- * DESCRIPTION:\n- *\n- * This routine may be called to report one of the following\n- * error conditions (in the include file mconf.h).\n- *\n- *   Mnemonic        Value          Significance\n- *\n- *    DOMAIN            1       argument domain error\n- *    SING              2       function singularity\n- *    OVERFLOW          3       overflow range error\n- *    UNDERFLOW         4       underflow range error\n- *    TLOSS             5       total loss of precision\n- *    PLOSS             6       partial loss of precision\n- *    INVALID           7       NaN - producing operation\n- *    EDOM             33       Unix domain error code\n- *    ERANGE           34       Unix range error code\n- *\n- * The default version of the file prints the function name,\n- * passed to it by the pointer fctnam, followed by the\n- * error condition.  The display is directed to the standard\n- * output device.  The routine then returns to the calling\n- * program.  Users may wish to modify the program to abort by\n- * calling exit under severe error conditions such as domain\n- * errors.\n- *\n- * Since all error conditions pass control to this function,\n- * the display may be easily changed, eliminated, or directed\n- * to an error logging device.\n- *\n- * SEE ALSO:\n- *\n- * mconf.h\n- *\n- */\n-\f\n-/*\n-Cephes Math Library Release 2.0:  April, 1987\n-Copyright 1984, 1987 by Stephen L. Moshier\n-Direct inquiries to 30 Frost Street, Cambridge, MA 02140\n-*/\n-\n-/* include \"mconf.h\" */\n+/* This routine may be called to report one of the following\n+   error conditions (in the include file mconf.h).\n+\n+    Mnemonic        Value          Significance\n+ \n+     DOMAIN            1       argument domain error\n+     SING              2       function singularity\n+     OVERFLOW          3       overflow range error\n+     UNDERFLOW         4       underflow range error\n+     TLOSS             5       total loss of precision\n+     PLOSS             6       partial loss of precision\n+     INVALID           7       NaN - producing operation\n+     EDOM             33       Unix domain error code\n+     ERANGE           34       Unix range error code\n+ \n+  The default version of the file prints the function name,\n+  passed to it by the pointer fctnam, followed by the\n+  error condition.  The display is directed to the standard\n+  output device.  The routine then returns to the calling\n+  program.  Users may wish to modify the program to abort by\n+  calling exit under severe error conditions such as domain\n+  errors.\n+ \n+  Since all error conditions pass control to this function,\n+  the display may be easily changed, eliminated, or directed\n+  to an error logging device. */\n+\n+/* Note: the order of appearance of the following messages is bound to the\n+   error codes defined above.  */\n \n-/* Notice: the order of appearance of the following\n- * messages is bound to the error codes defined\n- * in mconf.h.\n- */\n #define NMSGS 8\n static char *ermsg[NMSGS] =\n {\n@@ -5357,38 +5143,22 @@ mtherr (name, code)\n {\n   char errstr[80];\n \n-  /* Display string passed by calling program,\n-   * which is supposed to be the name of the\n-   * function in which the error occurred.\n-   */\n+  /* Display string passed by calling program, which is supposed to be the\n+     name of the function in which the error occurred.\n+\n+     Display error message defined by the code argument.  */\n \n-  /* Display error message defined\n-   * by the code argument.\n-   */\n   if ((code <= 0) || (code >= NMSGS))\n     code = 0;\n   sprintf (errstr, \" %s %s error\", name, ermsg[code]);\n   if (extra_warnings)\n     warning (errstr);\n   /* Set global error message word */\n   merror = code + 1;\n-\n-  /* Return to calling\n-   * program\n-   */\n }\n \n #ifdef DEC\n-/* Here is etodec.c .\n- *\n- */\n-\n-/*\n-;\tconvert DEC double precision to e type\n-;\tdouble d;\n-;\tEMUSHORT e[NE];\n-;\tdectoe (&d, e);\n-*/\n+/* Convert DEC double precision to e type.  */\n \n static void \n dectoe (d, e)\n@@ -5499,17 +5269,7 @@ todec (x, y)\n #endif /* DEC */\n \n #ifdef IBM\n-/* Here is etoibm\n- *\n- */\n-\n-/*\n-;\tconvert IBM single/double precision to e type\n-;\tsingle/double d;\n-;\tEMUSHORT e[NE];\n-;\tenum machine_mode mode;\tSFmode/DFmode\n-;\tibmtoe (&d, e, mode);\n-*/\n+/* Convert IBM single/double precision to e type.  */\n \n static void \n ibmtoe (d, e, mode)\n@@ -5553,13 +5313,7 @@ ibmtoe (d, e, mode)\n \n \n \n-/*\n-;\tconvert e type to IBM single/double precision\n-;\tsingle/double d;\n-;\tEMUSHORT e[NE];\n-;\tenum machine_mode mode;\tSFmode/DFmode\n-;\tetoibm (e, &d, mode);\n-*/\n+/* Convert e type to IBM single/double precision.  */\n \n static void \n etoibm (x, d, mode)"}]}