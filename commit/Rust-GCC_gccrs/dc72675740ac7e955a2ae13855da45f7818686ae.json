{"sha": "dc72675740ac7e955a2ae13855da45f7818686ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM3MjY3NTc0MGFjN2U5NTVhMmFlMTM4NTVkYTQ1Zjc4MTg2ODZhZQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2014-01-20T13:50:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T13:50:15Z"}, "message": "einfo.adb (Non_Limited_View): Applies to abstract states.\n\n2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb (Non_Limited_View): Applies to abstract states.\n\t(Set_From_Limited_With): Applies to abstract states.\n\t(Set_Non_Limited_View): Applies to abstract states.\n\t(Write_Field17): Output the non-limited view of an abstract state.\n\t* einfo.ads: Update the comment on usage and occurrences in\n\tnodes for attributes From_Limited_With and Non_Limited_View.\n\t* sem_aux.adb (Available_View): This routine can now handle\n\tabstract states.\n\t* sem_aux.ads (Available_View): This routine can now handle\n\tabstract states. Update the comment on usage.\n\t* sem_ch8.adb (Find_Expanded_Name): Handle abstract views\n\tof states and variables.\n\t(In_Pragmas_Depends_Or_Global): New routine.\n\t* sem_ch10.adb (Build_Limited_Views): Implement\n\tabstract (limited) views of variables and states.\n\t(Build_Shadow_Entity): This routine is now a procedure. Add\n\tformal parameter Shadow. Update the comment on usage. Add\n\tcontext-specific decoration for states and variables.\n\t(Decorate_State): New routine.\t(Decorate_Variable): New routine.\n\t(Find_And_Process_States): New routine.\n\t(Process_Declarations): Renamed to Process_Declarations_And_States.\n\t(Process_Declarations_And_States): Add formal parameters\n\tPack and Create_Abstract_Views. Update the comment on usage.\n\t(Process_States): New routine.\n\t* sem_prag.adb (Check_Dependency_Clause): Handle abstract\n\tviews of states and variables. Match the abstract view of a state\n\tagainst its corresponding non-abstract view.\n\t(Is_Matching_Input):\n\tHandle abstract views of states and variables. Match the abstract\n\tview of a state against its corresponding non-abstract view.\n\t(Process_Global_Item): Handle abstract views of states and\n\tvariables.\n\nFrom-SVN: r206808", "tree": {"sha": "00eb459a45c4eeae5ec4e623607630628e07a750", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00eb459a45c4eeae5ec4e623607630628e07a750"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc72675740ac7e955a2ae13855da45f7818686ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc72675740ac7e955a2ae13855da45f7818686ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc72675740ac7e955a2ae13855da45f7818686ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc72675740ac7e955a2ae13855da45f7818686ae/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3a5de596b6eba17526176085ef7162bab6e88591", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a5de596b6eba17526176085ef7162bab6e88591", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a5de596b6eba17526176085ef7162bab6e88591"}], "stats": {"total": 605, "additions": 494, "deletions": 111}, "files": [{"sha": "3eb79d67b9b30a8ad5f22ba0ebbe3c7dcaa45493", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=dc72675740ac7e955a2ae13855da45f7818686ae", "patch": "@@ -1,3 +1,38 @@\n+2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb (Non_Limited_View): Applies to abstract states.\n+\t(Set_From_Limited_With): Applies to abstract states.\n+\t(Set_Non_Limited_View): Applies to abstract states.\n+\t(Write_Field17): Output the non-limited view of an abstract state.\n+\t* einfo.ads: Update the comment on usage and occurrences in\n+\tnodes for attributes From_Limited_With and Non_Limited_View.\n+\t* sem_aux.adb (Available_View): This routine can now handle\n+\tabstract states.\n+\t* sem_aux.ads (Available_View): This routine can now handle\n+\tabstract states. Update the comment on usage.\n+\t* sem_ch8.adb (Find_Expanded_Name): Handle abstract views\n+\tof states and variables.\n+\t(In_Pragmas_Depends_Or_Global): New routine.\n+\t* sem_ch10.adb (Build_Limited_Views): Implement\n+\tabstract (limited) views of variables and states.\n+\t(Build_Shadow_Entity): This routine is now a procedure. Add\n+\tformal parameter Shadow. Update the comment on usage. Add\n+\tcontext-specific decoration for states and variables.\n+\t(Decorate_State): New routine.\t(Decorate_Variable): New routine.\n+\t(Find_And_Process_States): New routine.\n+\t(Process_Declarations): Renamed to Process_Declarations_And_States.\n+\t(Process_Declarations_And_States): Add formal parameters\n+\tPack and Create_Abstract_Views. Update the comment on usage.\n+\t(Process_States): New routine.\n+\t* sem_prag.adb (Check_Dependency_Clause): Handle abstract\n+\tviews of states and variables. Match the abstract view of a state\n+\tagainst its corresponding non-abstract view.\n+\t(Is_Matching_Input):\n+\tHandle abstract views of states and variables. Match the abstract\n+\tview of a state against its corresponding non-abstract view.\n+\t(Process_Global_Item): Handle abstract views of states and\n+\tvariables.\n+\n 2014-01-20  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch10.adb (Expand_With_Clause): Don't"}, {"sha": "3ae97862085d0007c07e7b5351c8ba53eca237cd", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=dc72675740ac7e955a2ae13855da45f7818686ae", "patch": "@@ -2497,7 +2497,8 @@ package body Einfo is\n \n    function Non_Limited_View (Id : E) return E is\n    begin\n-      pragma Assert (Ekind (Id) in Incomplete_Kind);\n+      pragma Assert\n+        (Ekind (Id) in Incomplete_Kind or else Ekind (Id) = E_Abstract_State);\n       return Node17 (Id);\n    end Non_Limited_View;\n \n@@ -3865,7 +3866,8 @@ package body Einfo is\n \n    procedure Set_From_Limited_With (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Is_Type (Id) or else Ekind (Id) = E_Package);\n+      pragma Assert\n+        (Is_Type (Id) or else Ekind_In (Id, E_Abstract_State, E_Package));\n       Set_Flag159 (Id, V);\n    end Set_From_Limited_With;\n \n@@ -5172,7 +5174,8 @@ package body Einfo is\n \n    procedure Set_Non_Limited_View (Id : E; V : E) is\n    begin\n-      pragma Assert (Ekind (Id) in Incomplete_Kind);\n+      pragma Assert\n+        (Ekind (Id) in Incomplete_Kind or else Ekind (Id) = E_Abstract_State);\n       Set_Node17 (Id, V);\n    end Set_Non_Limited_View;\n \n@@ -8787,7 +8790,8 @@ package body Einfo is\n          when Modular_Integer_Kind                         =>\n             Write_Str (\"Modulus\");\n \n-         when E_Incomplete_Type                            =>\n+         when E_Abstract_State                             |\n+              E_Incomplete_Type                            =>\n             Write_Str (\"Non_Limited_View\");\n \n          when E_Incomplete_Subtype                         =>"}, {"sha": "ba6adc636ce53405af46954a176c9ad88b0cbf62", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=dc72675740ac7e955a2ae13855da45f7818686ae", "patch": "@@ -1316,10 +1316,11 @@ package Einfo is\n --       Freeze for further details.\n \n --    From_Limited_With (Flag159)\n---       Defined in package and type entities. Set to True when the related\n---       entity is generated by the expansion of a limited with clause. Such\n---       an entity is said to be a \"shadow\" - it acts as the incomplete view\n---       of a type by inheriting relevant attributes from the said type.\n+--       Defined in abtract states, package and type entities. Set to True when\n+--       the related entity is generated by the expansion of a limited with\n+--       clause. Such an entity is said to be a \"shadow\" - it acts as the\n+--       abstract view of a state or variable or as the incomplete view of a\n+--       type by inheriting relevant attributes from the said entity.\n \n --    Full_View (Node11)\n --       Defined in all type and subtype entities and in deferred constants.\n@@ -3262,9 +3263,9 @@ package Einfo is\n --       types if the modulus value is other than a power of 2.\n \n --    Non_Limited_View (Node17)\n---       Defined in incomplete types that are the shadow entities created\n---       when analyzing a limited_with_clause (Ada 2005: AI-50217). Points to\n---       the defining entity in the original declaration.\n+--       Defined in abstract states and incomplete types that act as shadow\n+--       entities created when analysing a limited with clause (Ada 2005:\n+--       AI-50217). Points to the defining entity of the original declaration.\n \n --    Nonzero_Is_True (Flag162) [base type only]\n --       Defined in enumeration types. Set if any non-zero value is to be\n@@ -5120,6 +5121,8 @@ package Einfo is\n    --    Refinement_Constituents             (Elist8)\n    --    Refined_State                       (Node10)\n    --    Body_References                     (Elist16)\n+   --    Non_Limited_View                    (Node17)\n+   --    From_Limited_With                   (Flag159)\n    --    Has_Body_References                 (Flag264)\n    --    Has_Visible_Refinement              (Flag263)\n    --    Has_Non_Null_Refinement             (synth)"}, {"sha": "12c20ac6126602e972a8deea060314e00f37421f", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=dc72675740ac7e955a2ae13855da45f7818686ae", "patch": "@@ -76,28 +76,35 @@ package body Sem_Aux is\n    -- Available_View --\n    --------------------\n \n-   function Available_View (Typ : Entity_Id) return Entity_Id is\n+   function Available_View (Ent : Entity_Id) return Entity_Id is\n    begin\n-      if Is_Incomplete_Type (Typ)\n-        and then Present (Non_Limited_View (Typ))\n+      --  Obtain the non-limited (non-abstract) view of a state or variable\n+\n+      if Ekind (Ent) = E_Abstract_State\n+        and then Present (Non_Limited_View (Ent))\n       then\n-         --  The non-limited view may itself be an incomplete type, in which\n-         --  case get its full view.\n+         return Non_Limited_View (Ent);\n+\n+      --  The non-limited view of an incomplete type may itself be incomplete\n+      --  in which case obtain its full view.\n \n-         return Get_Full_View (Non_Limited_View (Typ));\n+      elsif Is_Incomplete_Type (Ent)\n+        and then Present (Non_Limited_View (Ent))\n+      then\n+         return Get_Full_View (Non_Limited_View (Ent));\n \n-      --  If it is class_wide, check whether the specific type comes from\n-      --  A limited_with.\n+      --  If it is class_wide, check whether the specific type comes from a\n+      --  limited_with.\n \n-      elsif Is_Class_Wide_Type (Typ)\n-        and then Is_Incomplete_Type (Etype (Typ))\n-        and then From_Limited_With (Etype (Typ))\n-        and then Present (Non_Limited_View (Etype (Typ)))\n+      elsif Is_Class_Wide_Type (Ent)\n+        and then Is_Incomplete_Type (Etype (Ent))\n+        and then From_Limited_With (Etype (Ent))\n+        and then Present (Non_Limited_View (Etype (Ent)))\n       then\n-         return Class_Wide_Type (Non_Limited_View (Etype (Typ)));\n+         return Class_Wide_Type (Non_Limited_View (Etype (Ent)));\n \n       else\n-         return Typ;\n+         return Ent;\n       end if;\n    end Available_View;\n "}, {"sha": "5d500a3afa3641b36021095ecb97831d192ce849", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=dc72675740ac7e955a2ae13855da45f7818686ae", "patch": "@@ -90,12 +90,10 @@ package Sem_Aux is\n    --  subtype then it returns the subtype or type from which the subtype was\n    --  obtained, otherwise it returns Empty.\n \n-   function Available_View (Typ : Entity_Id) return Entity_Id;\n-   --  Typ is typically a type that has the With_Type flag set. Returns the\n-   --  non-limited view of the type, if available, otherwise the type itself.\n-   --  For class-wide types, there is no direct link in the tree, so we have\n-   --  to retrieve the class-wide type of the non-limited view of the Etype.\n-   --  Returns the argument unchanged if it is not one of these cases.\n+   function Available_View (Ent : Entity_Id) return Entity_Id;\n+   --  Ent denotes an abstract state or a type that may come from a limited\n+   --  with clause. Return the non-limited view of Ent if there is one or Ent\n+   --  if this is not the case.\n \n    function Constant_Value (Ent : Entity_Id) return Node_Id;\n    --  Ent is a variable, constant, named integer, or named real entity. This"}, {"sha": "23083cddd88f9efc9fc7cf4f3dc7e735e6ed03b7", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 314, "deletions": 70, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=dc72675740ac7e955a2ae13855da45f7818686ae", "patch": "@@ -5385,31 +5385,36 @@ package body Sem_Ch10 is\n    -------------------------\n \n    procedure Build_Limited_Views (N : Node_Id) is\n-      Nam  : constant Node_Id          := Name (N);\n-      Unum : constant Unit_Number_Type := Get_Source_Unit (Library_Unit (N));\n-      Pack : constant Entity_Id        := Cunit_Entity (Unum);\n+      Unum        : constant Unit_Number_Type :=\n+                      Get_Source_Unit (Library_Unit (N));\n+      Is_Analyzed : constant Boolean := Analyzed (Cunit (Unum));\n \n       Shadow_Pack : Entity_Id;\n       --  The corresponding shadow entity of the withed package. This entity\n-      --  offers incomplete views of all types and visible packages declared\n-      --  within.\n+      --  offers incomplete views of packages and types as well as abstract\n+      --  views of states and variables declared within.\n \n       Last_Shadow : Entity_Id := Empty;\n       --  The last shadow entity created by routine Build_Shadow_Entity\n \n-      function Build_Shadow_Entity\n+      procedure Build_Shadow_Entity\n         (Ent       : Entity_Id;\n          Scop      : Entity_Id;\n-         Is_Tagged : Boolean := False) return Entity_Id;\n-      --  Create a shadow entity that hides Ent and offers an incomplete view\n-      --  of Ent. Scop is the proper scope. Flag Is_Tagged should be set when\n-      --  Ent is a tagged type. The generated entity is added to Lim_Header.\n-      --  This routine updates the value of Last_Shadow.\n+         Shadow    : out Entity_Id;\n+         Is_Tagged : Boolean := False);\n+      --  Create a shadow entity that hides Ent and offers an abstract or\n+      --  incomplete view of Ent. Scop is the proper scope. Flag Is_Tagged\n+      --  should be set when Ent is a tagged type. The generated entity is\n+      --  added to Lim_Header. This routine updates the value of Last_Shadow.\n \n       procedure Decorate_Package (Ent : Entity_Id; Scop : Entity_Id);\n       --  Perform minimal decoration of a package or its corresponding shadow\n       --  entity denoted by Ent. Scop is the proper scope.\n \n+      procedure Decorate_State (Ent : Entity_Id; Scop : Entity_Id);\n+      --  Perform full decoration of an abstract state or its corresponding\n+      --  shadow entity denoted by Ent. Scop is the proper scope.\n+\n       procedure Decorate_Type\n         (Ent         : Entity_Id;\n          Scop        : Entity_Id;\n@@ -5421,28 +5426,47 @@ package body Sem_Ch10 is\n       --  set when Ent is a tagged type and its class-wide type needs to appear\n       --  in the tree.\n \n-      procedure Process_Declarations (Decls : List_Id; Scop : Entity_Id);\n-      --  Inspect declarative list Decls and create shadow entities for all\n-      --  types and packages encountered. Scop is the proper scope.\n+      procedure Decorate_Variable (Ent : Entity_Id; Scop : Entity_Id);\n+      --  Perform minimal decoration of a variable denoted by Ent. Scop is the\n+      --  proper scope.\n+\n+      procedure Process_Declarations_And_States\n+        (Pack  : Entity_Id;\n+         Decls : List_Id;\n+         Scop  : Entity_Id;\n+         Create_Abstract_Views : Boolean);\n+      --  Inspect the states of package Pack and declarative list Decls. Create\n+      --  shadow entities for all nested packages, states, types and variables\n+      --  encountered. Scop is the proper scope. Create_Abstract_Views should\n+      --  be set when the abstract states and variables need to be processed.\n \n       -------------------------\n       -- Build_Shadow_Entity --\n       -------------------------\n \n-      function Build_Shadow_Entity\n+      procedure Build_Shadow_Entity\n         (Ent       : Entity_Id;\n          Scop      : Entity_Id;\n-         Is_Tagged : Boolean := False) return Entity_Id\n+         Shadow    : out Entity_Id;\n+         Is_Tagged : Boolean := False)\n       is\n-         Shadow : constant Entity_Id := Make_Temporary (Sloc (Ent), 'Z');\n-\n       begin\n+         Shadow := Make_Temporary (Sloc (Ent), 'Z');\n+\n          --  The shadow entity must share the same name and parent as the\n          --  entity it hides.\n \n-         Set_Chars             (Shadow, Chars (Ent));\n-         Set_Parent            (Shadow, Parent (Ent));\n-         Set_Ekind             (Shadow, Ekind (Ent));\n+         Set_Chars  (Shadow, Chars (Ent));\n+         Set_Parent (Shadow, Parent (Ent));\n+\n+         --  The abstract view of a variable is a state, not another variable\n+\n+         if Ekind (Ent) = E_Variable then\n+            Set_Ekind (Shadow, E_Abstract_State);\n+         else\n+            Set_Ekind (Shadow, Ekind (Ent));\n+         end if;\n+\n          Set_Is_Internal       (Shadow);\n          Set_From_Limited_With (Shadow);\n \n@@ -5451,20 +5475,27 @@ package body Sem_Ch10 is\n          Last_Shadow := Shadow;\n          Append_Entity (Shadow, Shadow_Pack);\n \n-         if Is_Type (Ent) then\n-            Decorate_Type (Shadow, Scop, Is_Tagged);\n+         --  Perform context-specific decoration of the shadow entity\n+\n+         if Ekind (Ent) = E_Abstract_State then\n+            Decorate_State       (Shadow, Scop);\n+            Set_Non_Limited_View (Shadow, Ent);\n+\n+         elsif Ekind (Ent) = E_Package then\n+            Decorate_Package (Shadow, Scop);\n+\n+         elsif Is_Type (Ent) then\n+            Decorate_Type        (Shadow, Scop, Is_Tagged);\n+            Set_Non_Limited_View (Shadow, Ent);\n \n             if Is_Incomplete_Or_Private_Type (Ent) then\n                Set_Private_Dependents (Shadow, New_Elmt_List);\n             end if;\n \n+         elsif Ekind (Ent) = E_Variable then\n+            Decorate_State       (Shadow, Scop);\n             Set_Non_Limited_View (Shadow, Ent);\n-\n-         elsif Ekind (Ent) = E_Package then\n-            Decorate_Package (Shadow, Scop);\n          end if;\n-\n-         return Shadow;\n       end Build_Shadow_Entity;\n \n       ----------------------\n@@ -5478,6 +5509,19 @@ package body Sem_Ch10 is\n          Set_Scope (Ent, Scop);\n       end Decorate_Package;\n \n+      --------------------\n+      -- Decorate_State --\n+      --------------------\n+\n+      procedure Decorate_State (Ent : Entity_Id; Scop : Entity_Id) is\n+      begin\n+         Set_Ekind                   (Ent, E_Abstract_State);\n+         Set_Etype                   (Ent, Standard_Void_Type);\n+         Set_Scope                   (Ent, Scop);\n+         Set_Refined_State           (Ent, Empty);\n+         Set_Refinement_Constituents (Ent, New_Elmt_List);\n+      end Decorate_State;\n+\n       -------------------\n       -- Decorate_Type --\n       -------------------\n@@ -5540,36 +5584,229 @@ package body Sem_Ch10 is\n          end if;\n       end Decorate_Type;\n \n-      --------------------------\n-      -- Process_Declarations --\n-      --------------------------\n+      -----------------------\n+      -- Decorate_Variable --\n+      -----------------------\n+\n+      procedure Decorate_Variable (Ent : Entity_Id; Scop : Entity_Id) is\n+      begin\n+         Set_Ekind (Ent, E_Variable);\n+         Set_Etype (Ent, Standard_Void_Type);\n+         Set_Scope (Ent, Scop);\n+      end Decorate_Variable;\n+\n+      -------------------------------------\n+      -- Process_Declarations_And_States --\n+      -------------------------------------\n+\n+      procedure Process_Declarations_And_States\n+        (Pack  : Entity_Id;\n+         Decls : List_Id;\n+         Scop  : Entity_Id;\n+         Create_Abstract_Views : Boolean)\n+      is\n+         procedure Find_And_Process_States;\n+         --  Determine whether package Pack defines abstract state either by\n+         --  using an aspect or a pragma. If this is the case, build shadow\n+         --  entities for all abstract states of Pack.\n+\n+         procedure Process_States (States : Elist_Id);\n+         --  Generate shadow entities for all abstract states in list States\n+\n+         -----------------------------\n+         -- Find_And_Process_States --\n+         -----------------------------\n+\n+         procedure Find_And_Process_States is\n+            procedure Process_State (State : Node_Id);\n+            --  Generate shadow entities for a single abstract state or\n+            --  multiple states expressed as an aggregate.\n+\n+            -------------------\n+            -- Process_State --\n+            -------------------\n+\n+            procedure Process_State (State : Node_Id) is\n+               Loc  : constant Source_Ptr := Sloc (State);\n+               Elmt : Node_Id;\n+               Id   : Entity_Id;\n+               Name : Name_Id;\n+\n+               Dummy : Entity_Id;\n+               pragma Unreferenced (Dummy);\n+\n+            begin\n+               --  Multiple abstract states appear as an aggregate\n+\n+               if Nkind (State) = N_Aggregate then\n+                  Elmt := First (Expressions (State));\n+                  while Present (Elmt) loop\n+                     Process_State (Elmt);\n+\n+                     Next (Elmt);\n+                  end loop;\n+                  return;\n+\n+               --  A null state has no abstract view\n+\n+               elsif Nkind (State) = N_Null then\n+                  return;\n+\n+               --  State declaration with various options appears as an\n+               --  extension aggregate.\n+\n+               elsif Nkind (State) = N_Extension_Aggregate then\n+                  Name := Chars (Ancestor_Part (State));\n+\n+               --  Simple state declaration\n+\n+               elsif Nkind (State) = N_Identifier then\n+                  Name := Chars (State);\n+\n+               --  Possibly an illegal state declaration\n+\n+               else\n+                  return;\n+               end if;\n+\n+               --  Construct a dummy state for the purposes of establishing a\n+               --  non-limited => limited view relation. Note that the dummy\n+               --  state is not added to list Abstract_States to avoid multiple\n+               --  definitions.\n+\n+               Id := Make_Defining_Identifier (Loc, New_External_Name (Name));\n+               Set_Parent     (Id, State);\n+               Decorate_State (Id, Scop);\n+\n+               Build_Shadow_Entity (Id, Scop, Dummy);\n+            end Process_State;\n \n-      procedure Process_Declarations (Decls : List_Id; Scop : Entity_Id) is\n-         Is_Analyzed : constant Boolean := Analyzed (Cunit (Unum));\n-         Is_Tagged   : Boolean;\n-         Decl        : Node_Id;\n-         Def         : Node_Id;\n-         Pack        : Entity_Id;\n-         Shadow      : Entity_Id;\n-         Typ         : Entity_Id;\n+            --  Local variables\n+\n+            Pack_Decl : constant Node_Id := Unit_Declaration_Node (Pack);\n+            Asp       : Node_Id;\n+            Decl      : Node_Id;\n+\n+         --  Start of processing for Find_And_Process_States\n+\n+         begin\n+            --  Find aspect Abstract_State\n+\n+            Asp := First (Aspect_Specifications (Pack_Decl));\n+            while Present (Asp) loop\n+               if Chars (Identifier (Asp)) = Name_Abstract_State then\n+                  Process_State (Expression (Asp));\n+\n+                  return;\n+               end if;\n+\n+               Next (Asp);\n+            end loop;\n+\n+            --  Find pragma Abstract_State by inspecting the declarations\n+\n+            Decl := First (Decls);\n+            while Present (Decl) and then Nkind (Decl) = N_Pragma loop\n+               if Pragma_Name (Decl) = Name_Abstract_State then\n+                  Process_State\n+                    (Get_Pragma_Arg\n+                       (First (Pragma_Argument_Associations (Decl))));\n+\n+                  return;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end Find_And_Process_States;\n+\n+         --------------------\n+         -- Process_States --\n+         --------------------\n+\n+         procedure Process_States (States : Elist_Id) is\n+            Dummy : Entity_Id;\n+            Elmt  : Elmt_Id;\n+\n+         begin\n+            Elmt := First_Elmt (States);\n+            while Present (Elmt) loop\n+               Build_Shadow_Entity (Node (Elmt), Scop, Dummy);\n+\n+               Next_Elmt (Elmt);\n+            end loop;\n+         end Process_States;\n+\n+         --  Local variables\n+\n+         Is_Tagged : Boolean;\n+         Decl      : Node_Id;\n+         Def       : Node_Id;\n+         Def_Id    : Entity_Id;\n+         Shadow    : Entity_Id;\n+\n+      --  Start of processing for Process_Declarations_And_States\n \n       begin\n-         --  Inspect the declarative list, looking for type declarations and\n-         --  nested packages.\n+         --  Build abstract views for all states defined in the package\n+\n+         if Create_Abstract_Views then\n+\n+            --  When a package has been analyzed, all states are stored in list\n+            --  Abstract_States. Generate the shadow entities directly.\n+\n+            if Is_Analyzed then\n+               if Present (Abstract_States (Pack)) then\n+                  Process_States (Abstract_States (Pack));\n+               end if;\n+\n+            --  The package may declare abstract states by using an aspect or a\n+            --  pragma. Attempt to locate one of these construct and if found,\n+            --  build the shadow entities.\n+\n+            else\n+               Find_And_Process_States;\n+            end if;\n+         end if;\n+\n+         --  Inspect the declarative list, looking for nested packages, types\n+         --  and variable declarations.\n \n          Decl := First (Decls);\n          while Present (Decl) loop\n \n+            --  Packages\n+\n+            if Nkind (Decl) = N_Package_Declaration then\n+               Def_Id := Defining_Entity (Decl);\n+\n+               --  Perform minor decoration when the withed package has not\n+               --  been analyzed.\n+\n+               if not Is_Analyzed then\n+                  Decorate_Package (Def_Id, Scop);\n+               end if;\n+\n+               --  Create a shadow entity that offers a limited view of all\n+               --  visible types declared within.\n+\n+               Build_Shadow_Entity (Def_Id, Scop, Shadow);\n+\n+               Process_Declarations_And_States\n+                 (Pack  => Def_Id,\n+                  Decls => Visible_Declarations (Specification (Decl)),\n+                  Scop  => Shadow,\n+                  Create_Abstract_Views => Create_Abstract_Views);\n+\n             --  Types\n \n-            if Nkind_In (Decl, N_Full_Type_Declaration,\n-                               N_Incomplete_Type_Declaration,\n-                               N_Private_Extension_Declaration,\n-                               N_Private_Type_Declaration,\n-                               N_Protected_Type_Declaration,\n-                               N_Task_Type_Declaration)\n+            elsif Nkind_In (Decl, N_Full_Type_Declaration,\n+                                  N_Incomplete_Type_Declaration,\n+                                  N_Private_Extension_Declaration,\n+                                  N_Private_Type_Declaration,\n+                                  N_Protected_Type_Declaration,\n+                                  N_Task_Type_Declaration)\n             then\n-               Typ := Defining_Entity (Decl);\n+               Def_Id := Defining_Entity (Decl);\n \n                --  Determine whether the type is tagged. Note that packages\n                --  included via a limited with clause are not always analyzed,\n@@ -5602,42 +5839,44 @@ package body Sem_Ch10 is\n                --  been analyzed.\n \n                if not Is_Analyzed then\n-                  Decorate_Type (Typ, Scop, Is_Tagged, True);\n+                  Decorate_Type (Def_Id, Scop, Is_Tagged, True);\n                end if;\n \n                --  Create a shadow entity that hides the type and offers an\n                --  incomplete view of the said type.\n \n-               Shadow := Build_Shadow_Entity (Typ, Scop, Is_Tagged);\n+               Build_Shadow_Entity (Def_Id, Scop, Shadow, Is_Tagged);\n \n-            --  Packages\n+            --  Variables\n \n-            elsif Nkind (Decl) = N_Package_Declaration then\n-               Pack := Defining_Entity (Decl);\n+            elsif Create_Abstract_Views\n+              and then Nkind (Decl) = N_Object_Declaration\n+              and then not Constant_Present (Decl)\n+            then\n+               Def_Id := Defining_Entity (Decl);\n \n                --  Perform minor decoration when the withed package has not\n                --  been analyzed.\n \n                if not Is_Analyzed then\n-                  Decorate_Package (Pack, Scop);\n+                  Decorate_Variable (Def_Id, Scop);\n                end if;\n \n-               --  Create a shadow entity that offers a limited view of all\n-               --  visible types declared within.\n-\n-               Shadow := Build_Shadow_Entity (Pack, Scop);\n+               --  Create a shadow entity that hides the variable and offers an\n+               --  abstract view of the said variable.\n \n-               Process_Declarations\n-                 (Decls => Visible_Declarations (Specification (Decl)),\n-                  Scop  => Shadow);\n+               Build_Shadow_Entity (Def_Id, Scop, Shadow);\n             end if;\n \n             Next (Decl);\n          end loop;\n-      end Process_Declarations;\n+      end Process_Declarations_And_States;\n \n       --  Local variables\n \n+      Nam  : constant Node_Id   := Name (N);\n+      Pack : constant Entity_Id := Cunit_Entity (Unum);\n+\n       Last_Public_Shadow : Entity_Id := Empty;\n       Private_Shadow     : Entity_Id;\n       Spec               : Node_Id;\n@@ -5719,21 +5958,26 @@ package body Sem_Ch10 is\n       Set_Is_Internal  (Shadow_Pack);\n       Set_Limited_View (Pack, Shadow_Pack);\n \n-      --  Inspect the visible declarations of the withed unit and create shadow\n-      --  entities that hide existing types and packages.\n+      --  Inspect the abstract states and visible declarations of the withed\n+      --  unit and create shadow entities that hide existing packages, states,\n+      --  variables and types.\n \n-      Process_Declarations\n-        (Decls => Visible_Declarations (Spec),\n-         Scop  => Pack);\n+      Process_Declarations_And_States\n+        (Pack  => Pack,\n+         Decls => Visible_Declarations (Spec),\n+         Scop  => Pack,\n+         Create_Abstract_Views => True);\n \n       Last_Public_Shadow := Last_Shadow;\n \n       --  Ada 2005 (AI-262): Build the limited view of the private declarations\n       --  to accomodate limited private with clauses.\n \n-      Process_Declarations\n-        (Decls => Private_Declarations (Spec),\n-         Scop  => Pack);\n+      Process_Declarations_And_States\n+        (Pack  => Pack,\n+         Decls => Private_Declarations (Spec),\n+         Scop  => Pack,\n+         Create_Abstract_Views => False);\n \n       if Present (Last_Public_Shadow) then\n          Private_Shadow := Next_Entity (Last_Public_Shadow);"}, {"sha": "f5c96acea18cb739c4b9e87692e9242f1249ba0e", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 64, "deletions": 5, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=dc72675740ac7e955a2ae13855da45f7818686ae", "patch": "@@ -5171,11 +5171,51 @@ package body Sem_Ch8 is\n    --  the scope of its declaration.\n \n    procedure Find_Expanded_Name (N : Node_Id) is\n+      function In_Pragmas_Depends_Or_Global (N : Node_Id) return Boolean;\n+      --  Determine whether an arbitrary node N appears in pragmas [Refined_]\n+      --  Depends or [Refined_]Global.\n+\n+      ----------------------------------\n+      -- In_Pragmas_Depends_Or_Global --\n+      ----------------------------------\n+\n+      function In_Pragmas_Depends_Or_Global (N : Node_Id) return Boolean is\n+         Par : Node_Id;\n+\n+      begin\n+         --  Climb the parent chain looking for a pragma\n+\n+         Par := N;\n+         while Present (Par) loop\n+            if Nkind (Par) = N_Pragma\n+              and then Nam_In (Pragma_Name (Par), Name_Depends,\n+                                                  Name_Global,\n+                                                  Name_Refined_Depends,\n+                                                  Name_Refined_Global)\n+            then\n+               return True;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               return False;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         return False;\n+      end In_Pragmas_Depends_Or_Global;\n+\n+      --  Local variables\n+\n       Selector  : constant Node_Id := Selector_Name (N);\n       Candidate : Entity_Id        := Empty;\n       P_Name    : Entity_Id;\n       Id        : Entity_Id;\n \n+   --  Start of processing for Find_Expanded_Name\n+\n    begin\n       P_Name := Entity (Prefix (N));\n \n@@ -5210,6 +5250,27 @@ package body Sem_Ch8 is\n                Candidate        := Id;\n                Is_New_Candidate := True;\n \n+               --  Handle abstract views of states and variables. These are\n+               --  acceptable only when the reference to the view appears in\n+               --  pragmas [Refined_]Depends and [Refined_]Global.\n+\n+               if Ekind (Id) = E_Abstract_State\n+                 and then From_Limited_With (Id)\n+                 and then Present (Non_Limited_View (Id))\n+               then\n+                  if In_Pragmas_Depends_Or_Global (N) then\n+                     Candidate        := Non_Limited_View (Id);\n+                     Is_New_Candidate := True;\n+\n+                  --  Hide the candidate because it is not used in a proper\n+                  --  context.\n+\n+                  else\n+                     Candidate        := Empty;\n+                     Is_New_Candidate := False;\n+                  end if;\n+               end if;\n+\n             --  Ada 2005 (AI-217): Handle shadow entities associated with types\n             --  declared in limited-withed nested packages. We don't need to\n             --  handle E_Incomplete_Subtype entities because the entities in\n@@ -5221,9 +5282,8 @@ package body Sem_Ch8 is\n             --  The non-limited view may itself be incomplete, in which case\n             --  get the full view if available.\n \n-            elsif From_Limited_With (Id)\n-              and then Is_Type (Id)\n-              and then Ekind (Id) = E_Incomplete_Type\n+            elsif Ekind (Id) = E_Incomplete_Type\n+              and then From_Limited_With (Id)\n               and then Present (Non_Limited_View (Id))\n               and then Scope (Non_Limited_View (Id)) = P_Name\n             then\n@@ -5528,8 +5588,7 @@ package body Sem_Ch8 is\n          else\n             Error_Msg_N\n               (\"limited withed package can only be used to access \"\n-               & \"incomplete types\",\n-                N);\n+               & \"incomplete types\", N);\n          end if;\n       end if;\n "}, {"sha": "7ab8c1981757a6f16c0b90f7566cb4bd8e398226", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc72675740ac7e955a2ae13855da45f7818686ae/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=dc72675740ac7e955a2ae13855da45f7818686ae", "patch": "@@ -19905,7 +19905,7 @@ package body Sem_Prag is\n          function Output_Constituents (State_Id : Entity_Id) return Elist_Id;\n          --  Given a state denoted by State_Id, return a list of all output\n          --  constituents that may be referenced within Refined_Depends. The\n-         --  contents of the list depend on whethe Refined_Global is present.\n+         --  contents of the list depend on whether Refined_Global is present.\n \n          procedure Report_Unused_Constituents (Constits : Elist_Id);\n          --  Emit errors for all constituents found in list Constits\n@@ -19989,7 +19989,10 @@ package body Sem_Prag is\n                --  Remaining cases are formal parameters, variables, and states\n \n                else\n-                  Dep_Id := Entity_Of (Dep_Input);\n+                  --  Handle abstract views of states and variables generated\n+                  --  for limited with clauses.\n+\n+                  Dep_Id := Available_View (Entity_Of (Dep_Input));\n \n                   --  Inspect all inputs of the refinement clause and attempt\n                   --  to match against the inputs of the dependence clause.\n@@ -20061,6 +20064,18 @@ package body Sem_Prag is\n                                  Remove (Ref_Input);\n                               end if;\n                            end if;\n+\n+                        --  The abstract view of a state matches its\n+                        --  corresponding non-abstract view:\n+\n+                        --    Depends         => (<output> => Lim_Pack.State)\n+                        --    Refined_Depends => (<output> => State)\n+\n+                        elsif Is_Entity_Name (Ref_Input)\n+                          and then Entity_Of (Ref_Input) = Dep_Id\n+                        then\n+                           Remove (Ref_Input);\n+                           return True;\n                         end if;\n \n                      --  Formal parameters and variables are matched on\n@@ -20364,14 +20379,18 @@ package body Sem_Prag is\n             --  The remaining cases are formal parameters, variables and states\n \n             elsif Is_Entity_Name (Dep_Output) then\n-               Dep_Id := Entity_Of (Dep_Output);\n+\n+               --  Handle abstract views of states and variables generated for\n+               --  limited with clauses.\n+\n+               Dep_Id := Available_View (Entity_Of (Dep_Output));\n \n                if Ekind (Dep_Id) = E_Abstract_State then\n \n                   --  A state with a null refinement matches either a null\n                   --  output list or nothing at all (no clause):\n \n-                  --    Refined_State => (State => null)\n+                  --    Refined_State   => (State => null)\n \n                   --  No clause\n \n@@ -20446,6 +20465,18 @@ package body Sem_Prag is\n                            Remove (Out_Constits, Ref_Id);\n                         end if;\n                      end if;\n+\n+                  --  The abstract view of a state matches is corresponding\n+                  --  non-abstract view:\n+\n+                  --    Depends         => (Lim_Pack.State => <input>)\n+                  --    Refined_Depends => (State          => <input>)\n+\n+                  elsif Is_Entity_Name (Ref_Output)\n+                    and then Entity_Of (Ref_Output) = Dep_Id\n+                  then\n+                     Matching_Clause := Ref_Clause;\n+                     exit;\n                   end if;\n \n                --  Formal parameters and variables match if their inputs match\n@@ -22127,7 +22158,9 @@ package body Sem_Prag is\n          -------------------------\n \n          procedure Process_Global_Item (Item : Node_Id; Mode : Name_Id) is\n-            Item_Id : constant Entity_Id := Entity_Of (Item);\n+            Item_Id : constant Entity_Id := Available_View (Entity_Of (Item));\n+            --  The above handles abstract views of variables and states built\n+            --  for limited with clauses.\n \n          begin\n             --  Signal that the global list contains at least one abstract"}]}