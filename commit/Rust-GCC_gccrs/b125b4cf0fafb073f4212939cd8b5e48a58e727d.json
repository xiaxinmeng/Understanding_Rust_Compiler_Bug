{"sha": "b125b4cf0fafb073f4212939cd8b5e48a58e727d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEyNWI0Y2YwZmFmYjA3M2Y0MjEyOTM5Y2Q4YjVlNDhhNThlNzI3ZA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-07-13T18:43:14Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-07-13T18:43:14Z"}, "message": "[multiple changes]\n\n2005-07-13 Paul Thomas  <pault@gcc.gnu.org>\n\n\t* io/read.c (read_complex): Prevent X formatting during reads\n\tfrom going beyond EOR to fix NIST fm908.FOR failure.\n\t* io/list_read.c (read_complex): Allow complex data in list-\n\tdirected reads to have eols either side of the comma to\n\tfix NIST FM906.FOR failure.\n\n2005-07-13  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.dg/past_eor.f90: New.\n\t* gfortran.dg/complex_read.f90: New.\n\nFrom-SVN: r101984", "tree": {"sha": "1c28fb5dafb8fc2f620f979446e0d67d6873cd05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c28fb5dafb8fc2f620f979446e0d67d6873cd05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b125b4cf0fafb073f4212939cd8b5e48a58e727d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b125b4cf0fafb073f4212939cd8b5e48a58e727d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b125b4cf0fafb073f4212939cd8b5e48a58e727d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b125b4cf0fafb073f4212939cd8b5e48a58e727d/comments", "author": null, "committer": null, "parents": [{"sha": "ecd485052f235f6fcf01a1c3a24c678ee0c159e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecd485052f235f6fcf01a1c3a24c678ee0c159e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecd485052f235f6fcf01a1c3a24c678ee0c159e1"}], "stats": {"total": 118, "additions": 111, "deletions": 7}, "files": [{"sha": "9b30550462891693d6874b5823137ba553eba36c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b125b4cf0fafb073f4212939cd8b5e48a58e727d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b125b4cf0fafb073f4212939cd8b5e48a58e727d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b125b4cf0fafb073f4212939cd8b5e48a58e727d", "patch": "@@ -1,9 +1,7 @@\n-2005-07-13  Jeff Law  <law@redhat.com>\n+2005-07-13  Paul Thomas  <pault@gcc.gnu.org>\n \n-\t* gcc.dg/tree-ssa/pr22051-2.c: Tweak expected output to allow\n-\tadditional casts.\n-\n-\t* gcc.dg/tree-ssa/pr22321.c: New test\n+\t* gfortran.dg/past_eor.f90: New.\n+\t* gfortran.dg/complex_read.f90: New.\n \n 2005-07-13  Paolo Bonzini  <bonzini@gnu.org>\n "}, {"sha": "c12b66c5b43aef6f8448fda553dad707e256fd02", "filename": "gcc/testsuite/gfortran.dg/complex_read.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b125b4cf0fafb073f4212939cd8b5e48a58e727d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_read.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b125b4cf0fafb073f4212939cd8b5e48a58e727d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_read.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_read.f90?ref=b125b4cf0fafb073f4212939cd8b5e48a58e727d", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do run }\n+! Test of the fix to the bug in NIST fm906.for.\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+program complex_read\n+  complex            ::  a\n+  open (10, status=\"scratch\")\n+\n+! Test that we have not broken the one line form.\n+\n+  write (10, *) \" ( 0.99  ,  9.9  )\"\n+  rewind (10)\n+  read (10,*) a\n+  if (a.ne.(0.99, 9.90)) call abort ()\n+\n+! Test a new record after the.comma (the original bug).\n+\n+  rewind (10)\n+  write (10, *) \" ( 99.0   ,\"\n+  write (10, *) \"   999.0  )\"\n+  rewind (10)\n+  read (10,*) a\n+  if (a.ne.(99.0, 999.0)) call abort ()\n+\n+! Test a new record before the.comma \n+\n+  rewind (10)\n+  write (10, *) \" ( 0.99  \"\n+  write (10, *) \" , 9.9  )\"\n+  rewind (10)\n+  read (10,*) a\n+  if (a.ne.(0.99, 9.90)) call abort ()\n+\n+! Test a new records before and after the.comma \n+\n+  rewind (10)\n+  write (10, *) \" ( 99.0   \"\n+  write (10, *) \",         \"\n+  write (10, *) \"  999.0  )\"\n+  rewind (10)\n+  read (10,*) a\n+  if (a.ne.(99.0, 999.0)) call abort ()\n+\n+! Test a new records and blank records before and after the.comma \n+\n+  rewind (10)\n+  write (10, *) \" ( 0.99   \"\n+  write (10, *) \"          \"\n+  write (10, *) \",         \"\n+  write (10, *) \"          \"\n+  write (10, *) \"  9.9    )\"\n+  rewind (10)\n+  read (10,*) a\n+  if (a.ne.(0.99, 9.9)) call abort ()\n+\n+  close (10)\n+end program complex_read\n+"}, {"sha": "e89ed22726667960ac307e24140766ab268785b0", "filename": "gcc/testsuite/gfortran.dg/past_eor.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b125b4cf0fafb073f4212939cd8b5e48a58e727d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpast_eor.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b125b4cf0fafb073f4212939cd8b5e48a58e727d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpast_eor.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpast_eor.f90?ref=b125b4cf0fafb073f4212939cd8b5e48a58e727d", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+! Test of the fix to the bug triggered by NIST fm908.for.\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+program past_eor\n+  character(len=82)         ::  buffer\n+  real                      ::  a(2), b(2), c(2), d(2), e(2)\n+\n+  e = (/2.34,2.456/)\n+\n+! tests 28-31 from fm908.for\n+\n+  buffer = '  2.34 ,  2.456     2.34 ,  2.456     0.234E01,  2.456E00&\n+ &   0.234E+001, 2.456E-000'\n+\n+  READ (UNIT=buffer,FMT=10) a, b, c, d\n+10 FORMAT (2(2(G7.5,1X),2X),2(G10.4E2,1X),1X,2(G11.7E4,1X))\n+\n+  if (any (a.ne.e).or.any (b.ne.e).or.any (c.ne.e).or.any (d.ne.e)) call abort ()\n+\n+end program past_eor\n+"}, {"sha": "25f55c7398a13c4f68d57979ebd99b0dfd56be7a", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b125b4cf0fafb073f4212939cd8b5e48a58e727d/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b125b4cf0fafb073f4212939cd8b5e48a58e727d/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b125b4cf0fafb073f4212939cd8b5e48a58e727d", "patch": "@@ -1,3 +1,11 @@\n+2005-07-13 Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* io/read.c (read_complex): Prevent X formatting during reads\n+\tfrom going beyond EOR to fix NIST fm908.FOR failure.\n+\t* io/list_read.c (read_complex): Allow complex data in list-\n+\tdirected reads to have eols either side of the comma to\n+\tfix NIST FM906.FOR failure.\n+\n 2005-07-12  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \tPR libfortran/21593"}, {"sha": "df99e7858a7581abedfe206c5f1955e804ced2a3", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b125b4cf0fafb073f4212939cd8b5e48a58e727d/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b125b4cf0fafb073f4212939cd8b5e48a58e727d/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=b125b4cf0fafb073f4212939cd8b5e48a58e727d", "patch": "@@ -984,11 +984,25 @@ read_complex (int length)\n   if (parse_real (value, length))\n     return;\n \n+eol_1:\n   eat_spaces ();\n+  c = next_char ();\n+  if (c == '\\n' || c== '\\r')\n+    goto eol_1;\n+  else\n+    unget_char (c);\n+\n   if (next_char () != ',')\n     goto bad_complex;\n \n+eol_2:\n   eat_spaces ();\n+  c = next_char ();\n+  if (c == '\\n' || c== '\\r')\n+    goto eol_2;\n+  else\n+    unget_char (c);\n+\n   if (parse_real (value + length, length))\n     return;\n "}, {"sha": "4cfad8d7785ef2db1f703ba76745b774297bee6f", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b125b4cf0fafb073f4212939cd8b5e48a58e727d/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b125b4cf0fafb073f4212939cd8b5e48a58e727d/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=b125b4cf0fafb073f4212939cd8b5e48a58e727d", "patch": "@@ -784,8 +784,12 @@ read_f (fnode * f, char *dest, int length)\n void\n read_x (fnode * f)\n {\n-  int n;\n+  int n, m;\n \n   n = f->u.n;\n-  read_block (&n);\n+  m = (int)current_unit->bytes_left;\n+  if (f->format == FMT_X)\n+    n = (n > m) ? m : n;\n+  if (n)\n+    read_block (&n);\n }"}]}