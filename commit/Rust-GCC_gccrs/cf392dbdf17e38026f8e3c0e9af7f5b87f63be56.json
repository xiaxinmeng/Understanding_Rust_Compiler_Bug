{"sha": "cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YzOTJkYmRmMTdlMzgwMjZmOGUzYzBlOWFmN2Y1Yjg3ZjYzYmU1Ng==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-11-07T15:25:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-11-10T15:25:32Z"}, "message": "libgo: update to Go 1.15.4 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/268177", "tree": {"sha": "6b1df9cdc36cc47b6164db69a14bc86a63dc77c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b1df9cdc36cc47b6164db69a14bc86a63dc77c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0000ea4fb4eaacbd2c954d78d7f8e9f03c7be739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0000ea4fb4eaacbd2c954d78d7f8e9f03c7be739", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0000ea4fb4eaacbd2c954d78d7f8e9f03c7be739"}], "stats": {"total": 296, "additions": 267, "deletions": 29}, "files": [{"sha": "e62578fc781e19061153563bc5e4e66cb8700008", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -1,4 +1,4 @@\n-ae20684902b82883d3d65f2cde0894c7cb3b995b\n+893fa057e36ae6c9b2ac5ffdf74634c35b3489c6\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "ad239c92fa95cea460ee147130531c8095ff35a1", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -1,4 +1,4 @@\n-1984ee00048b63eacd2155cd6d74a2d13e998272\n+0e953add9656c32a788e06438cd7b533e968b7f8\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "baff2224d623f7da1f7d5053325e707bc064d2cc", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -1 +1 @@\n-go1.15.3\n+go1.15.4"}, {"sha": "9a0cd7dba69743cbc55b37432725007a5053983c", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo_test.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -655,11 +655,6 @@ var codeRepoVersionsTests = []struct {\n \t\tpath:     \"swtch.com/testmod\",\n \t\tversions: []string{\"v1.0.0\", \"v1.1.1\"},\n \t},\n-\t{\n-\t\tvcs:      \"git\",\n-\t\tpath:     \"gopkg.in/russross/blackfriday.v2\",\n-\t\tversions: []string{\"v2.0.0\", \"v2.0.1\"},\n-\t},\n \t{\n \t\tvcs:      \"git\",\n \t\tpath:     \"gopkg.in/natefinch/lumberjack.v2\","}, {"sha": "8a22b8e6f928fcf53ade7123f4ea1f3b4d60144e", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"internal/testenv\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"math/rand\"\n \t\"reflect\"\n \t\"runtime/debug\"\n \t\"sync\"\n@@ -896,6 +897,62 @@ func TestBestSpeedMaxMatchOffset(t *testing.T) {\n \t}\n }\n \n+func TestBestSpeedShiftOffsets(t *testing.T) {\n+\t// Test if shiftoffsets properly preserves matches and resets out-of-range matches\n+\t// seen in https://github.com/golang/go/issues/4142\n+\tenc := newDeflateFast()\n+\n+\t// testData may not generate internal matches.\n+\ttestData := make([]byte, 32)\n+\trng := rand.New(rand.NewSource(0))\n+\tfor i := range testData {\n+\t\ttestData[i] = byte(rng.Uint32())\n+\t}\n+\n+\t// Encode the testdata with clean state.\n+\t// Second part should pick up matches from the first block.\n+\twantFirstTokens := len(enc.encode(nil, testData))\n+\twantSecondTokens := len(enc.encode(nil, testData))\n+\n+\tif wantFirstTokens <= wantSecondTokens {\n+\t\tt.Fatalf(\"test needs matches between inputs to be generated\")\n+\t}\n+\t// Forward the current indicator to before wraparound.\n+\tenc.cur = bufferReset - int32(len(testData))\n+\n+\t// Part 1 before wrap, should match clean state.\n+\tgot := len(enc.encode(nil, testData))\n+\tif wantFirstTokens != got {\n+\t\tt.Errorf(\"got %d, want %d tokens\", got, wantFirstTokens)\n+\t}\n+\n+\t// Verify we are about to wrap.\n+\tif enc.cur != bufferReset {\n+\t\tt.Errorf(\"got %d, want e.cur to be at bufferReset (%d)\", enc.cur, bufferReset)\n+\t}\n+\n+\t// Part 2 should match clean state as well even if wrapped.\n+\tgot = len(enc.encode(nil, testData))\n+\tif wantSecondTokens != got {\n+\t\tt.Errorf(\"got %d, want %d token\", got, wantSecondTokens)\n+\t}\n+\n+\t// Verify that we wrapped.\n+\tif enc.cur >= bufferReset {\n+\t\tt.Errorf(\"want e.cur to be < bufferReset (%d), got %d\", bufferReset, enc.cur)\n+\t}\n+\n+\t// Forward the current buffer, leaving the matches at the bottom.\n+\tenc.cur = bufferReset\n+\tenc.shiftOffsets()\n+\n+\t// Ensure that no matches were picked up.\n+\tgot = len(enc.encode(nil, testData))\n+\tif wantFirstTokens != got {\n+\t\tt.Errorf(\"got %d, want %d tokens\", got, wantFirstTokens)\n+\t}\n+}\n+\n func TestMaxStackSize(t *testing.T) {\n \t// This test must not run in parallel with other tests as debug.SetMaxStack\n \t// affects all goroutines."}, {"sha": "6aa439f13d9772afe28ec0a24510b0cf4564a02e", "filename": "libgo/go/compress/flate/deflatefast.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflatefast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflatefast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflatefast.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -270,6 +270,7 @@ func (e *deflateFast) matchLen(s, t int32, src []byte) int32 {\n func (e *deflateFast) reset() {\n \te.prev = e.prev[:0]\n \t// Bump the offset, so all matches will fail distance check.\n+\t// Nothing should be >= e.cur in the table.\n \te.cur += maxMatchOffset\n \n \t// Protect against e.cur wraparound.\n@@ -288,17 +289,21 @@ func (e *deflateFast) shiftOffsets() {\n \t\tfor i := range e.table[:] {\n \t\t\te.table[i] = tableEntry{}\n \t\t}\n-\t\te.cur = maxMatchOffset\n+\t\te.cur = maxMatchOffset + 1\n \t\treturn\n \t}\n \n \t// Shift down everything in the table that isn't already too far away.\n \tfor i := range e.table[:] {\n-\t\tv := e.table[i].offset - e.cur + maxMatchOffset\n+\t\tv := e.table[i].offset - e.cur + maxMatchOffset + 1\n \t\tif v < 0 {\n+\t\t\t// We want to reset e.cur to maxMatchOffset + 1, so we need to shift\n+\t\t\t// all table entries down by (e.cur - (maxMatchOffset + 1)).\n+\t\t\t// Because we ignore matches > maxMatchOffset, we can cap\n+\t\t\t// any negative offsets at 0.\n \t\t\tv = 0\n \t\t}\n \t\te.table[i].offset = v\n \t}\n-\te.cur = maxMatchOffset\n+\te.cur = maxMatchOffset + 1\n }"}, {"sha": "71592e976752d9e5b97f2ad894eb86893cba54c7", "filename": "libgo/go/net/http/h2_bundle.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -5265,6 +5265,7 @@ func (sc *http2serverConn) processData(f *http2DataFrame) error {\n \t\tif len(data) > 0 {\n \t\t\twrote, err := st.body.Write(data)\n \t\t\tif err != nil {\n+\t\t\t\tsc.sendWindowUpdate(nil, int(f.Length)-wrote)\n \t\t\t\treturn http2streamError(id, http2ErrCodeStreamClosed)\n \t\t\t}\n \t\t\tif wrote != len(data) {\n@@ -7167,6 +7168,7 @@ func (t *http2Transport) newClientConn(c net.Conn, singleUse bool) (*http2Client\n \tcc.inflow.add(http2transportDefaultConnFlow + http2initialWindowSize)\n \tcc.bw.Flush()\n \tif cc.werr != nil {\n+\t\tcc.Close()\n \t\treturn nil, cc.werr\n \t}\n \n@@ -7532,6 +7534,15 @@ func (cc *http2ClientConn) roundTrip(req *Request) (res *Response, gotErrAfterRe\n \tbodyWriter := cc.t.getBodyWriterState(cs, body)\n \tcs.on100 = bodyWriter.on100\n \n+\tdefer func() {\n+\t\tcc.wmu.Lock()\n+\t\twerr := cc.werr\n+\t\tcc.wmu.Unlock()\n+\t\tif werr != nil {\n+\t\t\tcc.Close()\n+\t\t}\n+\t}()\n+\n \tcc.wmu.Lock()\n \tendStream := !hasBody && !hasTrailers\n \twerr := cc.writeHeaders(cs.ID, endStream, int(cc.maxFrameSize), hdrs)"}, {"sha": "54ec1c5593cca96b7dcf3334583c511d8bc7f264", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -382,7 +382,7 @@ func (r *Request) Clone(ctx context.Context) *Request {\n \tif s := r.TransferEncoding; s != nil {\n \t\ts2 := make([]string, len(s))\n \t\tcopy(s2, s)\n-\t\tr2.TransferEncoding = s\n+\t\tr2.TransferEncoding = s2\n \t}\n \tr2.Form = cloneURLValues(r.Form)\n \tr2.PostForm = cloneURLValues(r.PostForm)"}, {"sha": "461d66e05d70798a22d2aad0f549df59e6f48980", "filename": "libgo/go/net/http/request_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest_test.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -828,6 +828,27 @@ func TestWithContextDeepCopiesURL(t *testing.T) {\n \t}\n }\n \n+// Ensure that Request.Clone creates a deep copy of TransferEncoding.\n+// See issue 41907.\n+func TestRequestCloneTransferEncoding(t *testing.T) {\n+\tbody := strings.NewReader(\"body\")\n+\treq, _ := NewRequest(\"POST\", \"https://example.org/\", body)\n+\treq.TransferEncoding = []string{\n+\t\t\"encoding1\",\n+\t}\n+\n+\tclonedReq := req.Clone(context.Background())\n+\t// modify original after deep copy\n+\treq.TransferEncoding[0] = \"encoding2\"\n+\n+\tif req.TransferEncoding[0] != \"encoding2\" {\n+\t\tt.Error(\"expected req.TransferEncoding to be changed\")\n+\t}\n+\tif clonedReq.TransferEncoding[0] != \"encoding1\" {\n+\t\tt.Error(\"expected clonedReq.TransferEncoding to be unchanged\")\n+\t}\n+}\n+\n func TestNoPanicOnRoundTripWithBasicAuth_h1(t *testing.T) {\n \ttestNoPanicWithBasicAuth(t, h1Mode)\n }"}, {"sha": "b99c345e7bf1832b3400b8acbd28c5dce4eba2c4", "filename": "libgo/go/reflect/deepequal.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Freflect%2Fdeepequal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Freflect%2Fdeepequal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fdeepequal.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -37,7 +37,17 @@ func deepValueEqual(v1, v2 Value, visited map[visit]bool, depth int) bool {\n \t// and it's safe and valid to get Value's internal pointer.\n \thard := func(v1, v2 Value) bool {\n \t\tswitch v1.Kind() {\n-\t\tcase Map, Slice, Ptr, Interface:\n+\t\tcase Ptr:\n+\t\t\tif v1.typ.ptrdata == 0 {\n+\t\t\t\t// go:notinheap pointers can't be cyclic.\n+\t\t\t\t// At least, all of our current uses of go:notinheap have\n+\t\t\t\t// that property. The runtime ones aren't cyclic (and we don't use\n+\t\t\t\t// DeepEqual on them anyway), and the cgo-generated ones are\n+\t\t\t\t// all empty structs.\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tfallthrough\n+\t\tcase Map, Slice, Interface:\n \t\t\t// Nil pointers cannot be cyclic. Avoid putting them in the visited map.\n \t\t\treturn !v1.IsNil() && !v2.IsNil()\n \t\t}"}, {"sha": "1394dd308c4910985479639bc89cbb6a2ba54551", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -91,6 +91,7 @@ func (f flag) ro() flag {\n \n // pointer returns the underlying pointer represented by v.\n // v.Kind() must be Ptr, Map, Chan, Func, or UnsafePointer\n+// if v.Kind() == Ptr, the base type must not be go:notinheap.\n func (v Value) pointer() unsafe.Pointer {\n \tif v.typ.size != ptrSize || !v.typ.pointers() {\n \t\tpanic(\"can't call pointer on a non-pointer Value\")\n@@ -1263,7 +1264,16 @@ func (v Value) Pointer() uintptr {\n \t// TODO: deprecate\n \tk := v.kind()\n \tswitch k {\n-\tcase Chan, Map, Ptr, UnsafePointer:\n+\tcase Ptr:\n+\t\tif v.typ.ptrdata == 0 {\n+\t\t\t// Handle pointers to go:notinheap types directly,\n+\t\t\t// so we never materialize such pointers as an\n+\t\t\t// unsafe.Pointer. (Such pointers are always indirect.)\n+\t\t\t// See issue 42076.\n+\t\t\treturn *(*uintptr)(v.ptr)\n+\t\t}\n+\t\tfallthrough\n+\tcase Chan, Map, UnsafePointer:\n \t\treturn uintptr(v.pointer())\n \tcase Func:\n \t\tp := v.pointer()"}, {"sha": "72a136d363f1927de720a065a093e8c9c52fd2ab", "filename": "libgo/go/runtime/netpoll.go", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -82,16 +82,17 @@ type pollDesc struct {\n \tlock    mutex // protects the following fields\n \tfd      uintptr\n \tclosing bool\n-\teverr   bool    // marks event scanning error happened\n-\tuser    uint32  // user settable cookie\n-\trseq    uintptr // protects from stale read timers\n-\trg      uintptr // pdReady, pdWait, G waiting for read or nil\n-\trt      timer   // read deadline timer (set if rt.f != nil)\n-\trd      int64   // read deadline\n-\twseq    uintptr // protects from stale write timers\n-\twg      uintptr // pdReady, pdWait, G waiting for write or nil\n-\twt      timer   // write deadline timer\n-\twd      int64   // write deadline\n+\teverr   bool      // marks event scanning error happened\n+\tuser    uint32    // user settable cookie\n+\trseq    uintptr   // protects from stale read timers\n+\trg      uintptr   // pdReady, pdWait, G waiting for read or nil\n+\trt      timer     // read deadline timer (set if rt.f != nil)\n+\trd      int64     // read deadline\n+\twseq    uintptr   // protects from stale write timers\n+\twg      uintptr   // pdReady, pdWait, G waiting for write or nil\n+\twt      timer     // write deadline timer\n+\twd      int64     // write deadline\n+\tself    *pollDesc // storage for indirect interface. See (*pollDesc).makeArg.\n }\n \n type pollCache struct {\n@@ -160,6 +161,7 @@ func poll_runtime_pollOpen(fd uintptr) (uintptr, int) {\n \tpd.wseq++\n \tpd.wg = 0\n \tpd.wd = 0\n+\tpd.self = pd\n \tunlock(&pd.lock)\n \n \tvar errno int32\n@@ -279,14 +281,14 @@ func poll_runtime_pollSetDeadline(ctx uintptr, d int64, mode int) {\n \t\t\t// Copy current seq into the timer arg.\n \t\t\t// Timer func will check the seq against current descriptor seq,\n \t\t\t// if they differ the descriptor was reused or timers were reset.\n-\t\t\tpd.rt.arg = pd\n+\t\t\tpd.rt.arg = pd.makeArg()\n \t\t\tpd.rt.seq = pd.rseq\n \t\t\tresettimer(&pd.rt, pd.rd)\n \t\t}\n \t} else if pd.rd != rd0 || combo != combo0 {\n \t\tpd.rseq++ // invalidate current timers\n \t\tif pd.rd > 0 {\n-\t\t\tmodtimer(&pd.rt, pd.rd, 0, rtf, pd, pd.rseq)\n+\t\t\tmodtimer(&pd.rt, pd.rd, 0, rtf, pd.makeArg(), pd.rseq)\n \t\t} else {\n \t\t\tdeltimer(&pd.rt)\n \t\t\tpd.rt.f = nil\n@@ -295,14 +297,14 @@ func poll_runtime_pollSetDeadline(ctx uintptr, d int64, mode int) {\n \tif pd.wt.f == nil {\n \t\tif pd.wd > 0 && !combo {\n \t\t\tpd.wt.f = netpollWriteDeadline\n-\t\t\tpd.wt.arg = pd\n+\t\t\tpd.wt.arg = pd.makeArg()\n \t\t\tpd.wt.seq = pd.wseq\n \t\t\tresettimer(&pd.wt, pd.wd)\n \t\t}\n \t} else if pd.wd != wd0 || combo != combo0 {\n \t\tpd.wseq++ // invalidate current timers\n \t\tif pd.wd > 0 && !combo {\n-\t\t\tmodtimer(&pd.wt, pd.wd, 0, netpollWriteDeadline, pd, pd.wseq)\n+\t\t\tmodtimer(&pd.wt, pd.wd, 0, netpollWriteDeadline, pd.makeArg(), pd.wseq)\n \t\t} else {\n \t\t\tdeltimer(&pd.wt)\n \t\t\tpd.wt.f = nil\n@@ -556,3 +558,21 @@ func (c *pollCache) alloc() *pollDesc {\n \tunlock(&c.lock)\n \treturn pd\n }\n+\n+// makeArg converts pd to an interface{}.\n+// makeArg does not do any allocation. Normally, such\n+// a conversion requires an allocation because pointers to\n+// go:notinheap types (which pollDesc is) must be stored\n+// in interfaces indirectly. See issue 42076.\n+func (pd *pollDesc) makeArg() (i interface{}) {\n+\tx := (*eface)(unsafe.Pointer(&i))\n+\tx._type = pdType\n+\t// For gccgo, we still use pd.self here, not &pd.self.\n+\tx.data = unsafe.Pointer(pd.self)\n+\treturn\n+}\n+\n+var (\n+\tpdEface interface{} = (*pollDesc)(nil)\n+\tpdType  *_type      = efaceOf(&pdEface)._type\n+)"}, {"sha": "0ca6c02bce85b182ef3d08cc8f9ec8ea7c155ea6", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -1258,6 +1258,14 @@ found:\n \tcheckdead()\n \tunlock(&sched.lock)\n \n+\tif GOOS == \"darwin\" {\n+\t\t// Make sure pendingPreemptSignals is correct when an M exits.\n+\t\t// For #41702.\n+\t\tif atomic.Load(&m.signalPending) != 0 {\n+\t\t\tatomic.Xadd(&pendingPreemptSignals, -1)\n+\t\t}\n+\t}\n+\n \tif osStack {\n \t\t// Return from mstart and let the system thread\n \t\t// library free the g0 stack and terminate the thread.\n@@ -3349,11 +3357,24 @@ func syscall_runtime_AfterForkInChild() {\n \tinForkedChild = false\n }\n \n+// pendingPreemptSignals is the number of preemption signals\n+// that have been sent but not received. This is only used on Darwin.\n+// For #41702.\n+var pendingPreemptSignals uint32\n+\n // Called from syscall package before Exec.\n //go:linkname syscall_runtime_BeforeExec syscall.runtime_BeforeExec\n func syscall_runtime_BeforeExec() {\n \t// Prevent thread creation during exec.\n \texecLock.lock()\n+\n+\t// On Darwin, wait for all pending preemption signals to\n+\t// be received. See issue #41702.\n+\tif GOOS == \"darwin\" {\n+\t\tfor int32(atomic.Load(&pendingPreemptSignals)) > 0 {\n+\t\t\tosyield()\n+\t\t}\n+\t}\n }\n \n // Called from syscall package after Exec."}, {"sha": "6b69dcf06d258c1d819bad3ac8b5d93327dd08ca", "filename": "libgo/go/runtime/signal_unix.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_unix.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -347,6 +347,10 @@ func doSigPreempt(gp *g, ctxt *sigctxt, sigpc uintptr) {\n \t// Acknowledge the preemption.\n \tatomic.Xadd(&gp.m.preemptGen, 1)\n \tatomic.Store(&gp.m.signalPending, 0)\n+\n+\tif GOOS == \"darwin\" {\n+\t\tatomic.Xadd(&pendingPreemptSignals, -1)\n+\t}\n }\n \n // This is false for gccgo.\n@@ -404,6 +408,9 @@ func sigtrampgo(sig uint32, info *_siginfo_t, ctx unsafe.Pointer) {\n \t\t\t// no non-Go signal handler for sigPreempt.\n \t\t\t// The default behavior for sigPreempt is to ignore\n \t\t\t// the signal, so badsignal will be a no-op anyway.\n+\t\t\tif GOOS == \"darwin\" {\n+\t\t\t\tatomic.Xadd(&pendingPreemptSignals, -1)\n+\t\t\t}\n \t\t\treturn\n \t\t}\n \t\tbadsignal(uintptr(sig), &c)"}, {"sha": "13991491c2fa6edc5e705ec8c8fa46ac84cd2029", "filename": "libgo/go/syscall/exec_unix_test.go", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fsyscall%2Fexec_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Fsyscall%2Fexec_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_unix_test.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -9,12 +9,14 @@ package syscall_test\n import (\n \t\"internal/testenv\"\n \t\"io\"\n+\t\"math/rand\"\n \t\"os\"\n \t\"os/exec\"\n \t\"os/signal\"\n \t\"runtime\"\n \t\"syscall\"\n \t\"testing\"\n+\t\"time\"\n \t\"unsafe\"\n )\n \n@@ -245,3 +247,46 @@ func TestInvalidExec(t *testing.T) {\n \t\t}\n \t})\n }\n+\n+// TestExec is for issue #41702.\n+func TestExec(t *testing.T) {\n+\ttestenv.MustHaveExec(t)\n+\tcmd := exec.Command(os.Args[0], \"-test.run=TestExecHelper\")\n+\tcmd.Env = append(os.Environ(), \"GO_WANT_HELPER_PROCESS=2\")\n+\to, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tt.Errorf(\"%s\\n%v\", o, err)\n+\t}\n+}\n+\n+// TestExecHelper is used by TestExec. It does nothing by itself.\n+// In testing on macOS 10.14, this used to fail with\n+// \"signal: illegal instruction\" more than half the time.\n+func TestExecHelper(t *testing.T) {\n+\tif os.Getenv(\"GO_WANT_HELPER_PROCESS\") != \"2\" {\n+\t\treturn\n+\t}\n+\n+\t// We don't have to worry about restoring these values.\n+\t// We are in a child process that only runs this test,\n+\t// and we are going to call syscall.Exec anyhow.\n+\truntime.GOMAXPROCS(50)\n+\tos.Setenv(\"GO_WANT_HELPER_PROCESS\", \"3\")\n+\n+\tstop := time.Now().Add(time.Second)\n+\tfor i := 0; i < 100; i++ {\n+\t\tgo func(i int) {\n+\t\t\tr := rand.New(rand.NewSource(int64(i)))\n+\t\t\tfor time.Now().Before(stop) {\n+\t\t\t\tr.Uint64()\n+\t\t\t}\n+\t\t}(i)\n+\t}\n+\n+\ttime.Sleep(10 * time.Millisecond)\n+\n+\targv := []string{os.Args[0], \"-test.run=TestExecHelper\"}\n+\tsyscall.Exec(os.Args[0], argv, os.Environ())\n+\n+\tt.Error(\"syscall.Exec returned\")\n+}"}, {"sha": "1e3586fdaf220c6c55f31d08daf0c67933a290f9", "filename": "libgo/go/time/zoneinfo_read.go", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Ftime%2Fzoneinfo_read.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Ftime%2Fzoneinfo_read.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_read.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -325,10 +325,27 @@ func LoadLocationFromTZData(name string, data []byte) (*Location, error) {\n \t\tif tx[i].when <= sec && (i+1 == len(tx) || sec < tx[i+1].when) {\n \t\t\tl.cacheStart = tx[i].when\n \t\t\tl.cacheEnd = omega\n+\t\t\tzoneIdx := tx[i].index\n \t\t\tif i+1 < len(tx) {\n \t\t\t\tl.cacheEnd = tx[i+1].when\n+\t\t\t} else if l.extend != \"\" {\n+\t\t\t\t// If we're at the end of the known zone transitions,\n+\t\t\t\t// try the extend string.\n+\t\t\t\tif name, _, estart, eend, ok := tzset(l.extend, l.cacheEnd, sec); ok {\n+\t\t\t\t\tl.cacheStart = estart\n+\t\t\t\t\tl.cacheEnd = eend\n+\t\t\t\t\t// Find the zone that is returned by tzset,\n+\t\t\t\t\t// the last transition is not always the correct zone.\n+\t\t\t\t\tfor i, z := range l.zone {\n+\t\t\t\t\t\tif z.name == name {\n+\t\t\t\t\t\t\tzoneIdx = uint8(i)\n+\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tl.cacheZone = &l.zone[tx[i].index]\n+\t\t\tl.cacheZone = &l.zone[zoneIdx]\n+\t\t\tbreak\n \t\t}\n \t}\n "}, {"sha": "d543f93e3b71598d1ec5fd8fec3eff0400331b3a", "filename": "libgo/go/time/zoneinfo_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Ftime%2Fzoneinfo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf392dbdf17e38026f8e3c0e9af7f5b87f63be56/libgo%2Fgo%2Ftime%2Fzoneinfo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_test.go?ref=cf392dbdf17e38026f8e3c0e9af7f5b87f63be56", "patch": "@@ -189,6 +189,25 @@ func TestMalformedTZData(t *testing.T) {\n \t}\n }\n \n+func TestLoadLocationFromTZDataSlim(t *testing.T) {\n+\t// A 2020b slim tzdata for Europe/Berlin\n+\ttzData := \"TZif2\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00TZif2\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00<\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x12\\xff\\xff\\xff\\xffo\\xa2a\\xf8\\xff\\xff\\xff\\xff\\x9b\\f\\x17`\\xff\\xff\\xff\\xff\\x9b\\xd5\\xda\\xf0\\xff\\xff\\xff\\xff\\x9c\u066e\\x90\\xff\\xff\\xff\\xff\\x9d\\xa4\\xb5\\x90\\xff\\xff\\xff\\xff\\x9e\\xb9\\x90\\x90\\xff\\xff\\xff\\xff\\x9f\\x84\\x97\\x90\\xff\\xff\\xff\\xff\\xc8\\tq\\x90\\xff\\xff\\xff\\xff\\xcc\\xe7K\\x10\\xff\\xff\\xff\\xff\u0369\\x17\\x90\\xff\\xff\\xff\\xff\\u03a2C\\x10\\xff\\xff\\xff\\xff\u03d24\\x10\\xff\\xff\\xff\\xff\u0402%\\x10\\xff\\xff\\xff\\xff\\xd1r\\x16\\x10\\xff\\xff\\xff\\xff\u0476\\x96\\x00\\xff\\xff\\xff\\xff\\xd2X\\xbe\\x80\\xff\\xff\\xff\\xff\u04a1O\\x10\\xff\\xff\\xff\\xff\\xd3c\\x1b\\x90\\xff\\xff\\xff\\xff\\xd4K#\\x90\\xff\\xff\\xff\\xff\\xd59\\xd1 \\xff\\xff\\xff\\xff\\xd5g\\xe7\\x90\\xff\\xff\\xff\\xff\u0568s\\x00\\xff\\xff\\xff\\xff\\xd6)\\xb4\\x10\\xff\\xff\\xff\\xff\\xd7,\\x1a\\x10\\xff\\xff\\xff\\xff\\xd8\\t\\x96\\x10\\xff\\xff\\xff\\xff\\xd9\\x02\\xc1\\x90\\xff\\xff\\xff\\xff\\xd9\\xe9x\\x10\\x00\\x00\\x00\\x00\\x13MD\\x10\\x00\\x00\\x00\\x00\\x143\\xfa\\x90\\x00\\x00\\x00\\x00\\x15#\\xeb\\x90\\x00\\x00\\x00\\x00\\x16\\x13\u0710\\x00\\x00\\x00\\x00\\x17\\x03\u0350\\x00\\x00\\x00\\x00\\x17\\xf3\\xbe\\x90\\x00\\x00\\x00\\x00\\x18\u3bd0\\x00\\x00\\x00\\x00\\x19\u04e0\\x90\\x00\\x00\\x00\\x00\\x1a\u00d1\\x90\\x00\\x00\\x00\\x00\\x1b\\xbc\\xbd\\x10\\x00\\x00\\x00\\x00\\x1c\\xac\\xae\\x10\\x00\\x00\\x00\\x00\\x1d\\x9c\\x9f\\x10\\x00\\x00\\x00\\x00\\x1e\\x8c\\x90\\x10\\x00\\x00\\x00\\x00\\x1f|\\x81\\x10\\x00\\x00\\x00\\x00 lr\\x10\\x00\\x00\\x00\\x00!\\\\c\\x10\\x00\\x00\\x00\\x00\\\"LT\\x10\\x00\\x00\\x00\\x00#<E\\x10\\x00\\x00\\x00\\x00$,6\\x10\\x00\\x00\\x00\\x00%\\x1c'\\x10\\x00\\x00\\x00\\x00&\\f\\x18\\x10\\x00\\x00\\x00\\x00'\\x05C\\x90\\x00\\x00\\x00\\x00'\\xf54\\x90\\x00\\x00\\x00\\x00(\\xe5%\\x90\\x00\\x00\\x00\\x00)\\xd5\\x16\\x90\\x00\\x00\\x00\\x00*\\xc5\\a\\x90\\x00\\x00\\x00\\x00+\\xb4\\xf8\\x90\\x00\\x00\\x00\\x00,\\xa4\\xe9\\x90\\x00\\x00\\x00\\x00-\\x94\u0690\\x00\\x00\\x00\\x00.\\x84\u02d0\\x00\\x00\\x00\\x00/t\\xbc\\x90\\x00\\x00\\x00\\x000d\\xad\\x90\\x00\\x00\\x00\\x001]\\xd9\\x10\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x03\\x01\\x02\\x01\\x02\\x01\\x03\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x00\\x00\\f\\x88\\x00\\x00\\x00\\x00\\x1c \\x01\\x04\\x00\\x00\\x0e\\x10\\x00\\t\\x00\\x00*0\\x01\\rLMT\\x00CEST\\x00CET\\x00CEMT\\x00\\nCET-1CEST,M3.5.0,M10.5.0/3\\n\"\n+\n+\treference, err := time.LoadLocationFromTZData(\"Europe/Berlin\", []byte(tzData))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\td := time.Date(2020, time.October, 29, 15, 30, 0, 0, reference)\n+\ttzName, tzOffset := d.Zone()\n+\tif want := \"CET\"; tzName != want {\n+\t\tt.Errorf(\"Zone name == %s, want %s\", tzName, want)\n+\t}\n+\tif want := 3600; tzOffset != want {\n+\t\tt.Errorf(\"Zone offset == %d, want %d\", tzOffset, want)\n+\t}\n+}\n+\n func TestTzset(t *testing.T) {\n \tfor _, test := range []struct {\n \t\tinStr string"}]}