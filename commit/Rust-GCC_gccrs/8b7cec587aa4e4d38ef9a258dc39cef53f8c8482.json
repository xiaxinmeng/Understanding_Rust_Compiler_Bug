{"sha": "8b7cec587aa4e4d38ef9a258dc39cef53f8c8482", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI3Y2VjNTg3YWE0ZTRkMzhlZjlhMjU4ZGMzOWNlZjUzZjhjODQ4Mg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2015-01-05T17:15:17Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2015-01-05T17:15:17Z"}, "message": "re PR fortran/47674 (gfortran.dg/realloc_on_assign_5.f03: Segfault at run time for deferred (allocatable) string length)\n\n2015-01-05  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/47674\n\t* dependency.c:  Update copyright years.\n\t(gfc_discard_nops):  Add prototype.\n\t* dependency.c (discard_nops):  Rename to gfc_discard_nops,\n\tmake non-static.\n\t(gfc_discard_nops):  Use gfc_discard_nops.\n\t(gfc_dep_difference):  Likewise.\n\t* frontend-passes.c  Update copyright years.\n\t(realloc_strings):  New function.  Add prototype.\n\t(gfc_run_passes):  Call realloc_strings.\n\t(realloc_string_callback):  New function.\n\t(create_var):  Add prototype.  Handle case of a\n\tscalar character variable.\n\t(optimize_trim):  Do not handle allocatable variables.\n\n2015-01-05  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/47674\n\t* gfortran.dg/realloc_on_assign_25.f90:  New test.\n\nFrom-SVN: r219193", "tree": {"sha": "8c4081077c27175971eec83c26efa6ad349c7dde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c4081077c27175971eec83c26efa6ad349c7dde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482/comments", "author": null, "committer": null, "parents": [{"sha": "24fa8749bba103b9258434fc2e3f9a1d99b64385", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24fa8749bba103b9258434fc2e3f9a1d99b64385", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24fa8749bba103b9258434fc2e3f9a1d99b64385"}], "stats": {"total": 222, "additions": 198, "deletions": 24}, "files": [{"sha": "d5a2198b77cb0cfed28d601d2ec5d40d16d37a91", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8b7cec587aa4e4d38ef9a258dc39cef53f8c8482", "patch": "@@ -1,3 +1,20 @@\n+2015-01-05  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/47674\n+\t* dependency.c:  Update copyright years.\n+\t(gfc_discard_nops):  Add prototype.\n+\t* dependency.c (discard_nops):  Rename to gfc_discard_nops,\n+\tmake non-static.\n+\t(gfc_discard_nops):  Use gfc_discard_nops.\n+\t(gfc_dep_difference):  Likewise.\n+\t* frontend-passes.c  Update copyright years.\n+\t(realloc_strings):  New function.  Add prototype.\n+\t(gfc_run_passes):  Call realloc_strings.\n+\t(realloc_string_callback):  New function.\n+\t(create_var):  Add prototype.  Handle case of a\n+\tscalar character variable.\n+\t(optimize_trim):  Do not handle allocatable variables.\n+\n 2015-01-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "c5825b8f8192038b358e33dbf4bb21e9b12fd6b2", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=8b7cec587aa4e4d38ef9a258dc39cef53f8c8482", "patch": "@@ -243,8 +243,8 @@ gfc_dep_compare_functions (gfc_expr *e1, gfc_expr *e2, bool impure_ok)\n /* Helper function to look through parens, unary plus and widening\n    integer conversions.  */\n \n-static gfc_expr*\n-discard_nops (gfc_expr *e)\n+gfc_expr *\n+gfc_discard_nops (gfc_expr *e)\n {\n   gfc_actual_arglist *arglist;\n \n@@ -297,8 +297,8 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n   if (e1 == NULL && e2 == NULL)\n     return 0;\n \n-  e1 = discard_nops (e1);\n-  e2 = discard_nops (e2);\n+  e1 = gfc_discard_nops (e1);\n+  e2 = gfc_discard_nops (e2);\n \n   if (e1->expr_type == EXPR_OP && e1->value.op.op == INTRINSIC_PLUS)\n     {\n@@ -515,8 +515,8 @@ gfc_dep_difference (gfc_expr *e1, gfc_expr *e2, mpz_t *result)\n   if (e1->ts.type != BT_INTEGER || e2->ts.type != BT_INTEGER)\n     return false;\n \n-  e1 = discard_nops (e1);\n-  e2 = discard_nops (e2);\n+  e1 = gfc_discard_nops (e1);\n+  e2 = gfc_discard_nops (e2);\n \n   /* Inizialize tentatively, clear if we don't return anything.  */\n   mpz_init (*result);\n@@ -531,8 +531,8 @@ gfc_dep_difference (gfc_expr *e1, gfc_expr *e2, mpz_t *result)\n \n   if (e1->expr_type == EXPR_OP && e1->value.op.op == INTRINSIC_PLUS)\n     {\n-      e1_op1 = discard_nops (e1->value.op.op1);\n-      e1_op2 = discard_nops (e1->value.op.op2);\n+      e1_op1 = gfc_discard_nops (e1->value.op.op1);\n+      e1_op2 = gfc_discard_nops (e1->value.op.op2);\n \n       /* Case 2: (X + c1) - X = c1.  */\n       if (e1_op2->expr_type == EXPR_CONSTANT\n@@ -552,8 +552,8 @@ gfc_dep_difference (gfc_expr *e1, gfc_expr *e2, mpz_t *result)\n \n       if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_PLUS)\n \t{\n-\t  e2_op1 = discard_nops (e2->value.op.op1);\n-\t  e2_op2 = discard_nops (e2->value.op.op2);\n+\t  e2_op1 = gfc_discard_nops (e2->value.op.op1);\n+\t  e2_op2 = gfc_discard_nops (e2->value.op.op2);\n \n \t  if (e1_op2->expr_type == EXPR_CONSTANT)\n \t    {\n@@ -597,8 +597,8 @@ gfc_dep_difference (gfc_expr *e1, gfc_expr *e2, mpz_t *result)\n \n       if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_MINUS)\n \t{\n-\t  e2_op1 = discard_nops (e2->value.op.op1);\n-\t  e2_op2 = discard_nops (e2->value.op.op2);\n+\t  e2_op1 = gfc_discard_nops (e2->value.op.op1);\n+\t  e2_op2 = gfc_discard_nops (e2->value.op.op2);\n \n \t  if (e1_op2->expr_type == EXPR_CONSTANT)\n \t    {\n@@ -627,8 +627,8 @@ gfc_dep_difference (gfc_expr *e1, gfc_expr *e2, mpz_t *result)\n \n   if (e1->expr_type == EXPR_OP && e1->value.op.op == INTRINSIC_MINUS)\n     {\n-      e1_op1 = discard_nops (e1->value.op.op1);\n-      e1_op2 = discard_nops (e1->value.op.op2);\n+      e1_op1 = gfc_discard_nops (e1->value.op.op1);\n+      e1_op2 = gfc_discard_nops (e1->value.op.op2);\n \n       if (e1_op2->expr_type == EXPR_CONSTANT)\n \t{\n@@ -642,8 +642,8 @@ gfc_dep_difference (gfc_expr *e1, gfc_expr *e2, mpz_t *result)\n \n \t  if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_PLUS)\n \t    {\n-\t      e2_op1 = discard_nops (e2->value.op.op1);\n-\t      e2_op2 = discard_nops (e2->value.op.op2);\n+\t      e2_op1 = gfc_discard_nops (e2->value.op.op1);\n+\t      e2_op2 = gfc_discard_nops (e2->value.op.op2);\n \n \t      /* Case 11: (X - c1) - (X + c2) = -( c1 + c2).  */\n \t      if (e2_op2->expr_type == EXPR_CONSTANT\n@@ -668,8 +668,8 @@ gfc_dep_difference (gfc_expr *e1, gfc_expr *e2, mpz_t *result)\n \n \t  if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_MINUS)\n \t    {\n-\t      e2_op1 = discard_nops (e2->value.op.op1);\n-\t      e2_op2 = discard_nops (e2->value.op.op2);\n+\t      e2_op1 = gfc_discard_nops (e2->value.op.op1);\n+\t      e2_op2 = gfc_discard_nops (e2->value.op.op2);\n \n \t      /* Case 13: (X - c1) - (X - c2) = c2 - c1.  */\n \t      if (e2_op2->expr_type == EXPR_CONSTANT\n@@ -685,8 +685,8 @@ gfc_dep_difference (gfc_expr *e1, gfc_expr *e2, mpz_t *result)\n \t{\n \t  if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_MINUS)\n \t    {\n-\t      e2_op1 = discard_nops (e2->value.op.op1);\n-\t      e2_op2 = discard_nops (e2->value.op.op2);\n+\t      e2_op1 = gfc_discard_nops (e2->value.op.op1);\n+\t      e2_op2 = gfc_discard_nops (e2->value.op.op2);\n \n \t      /* Case 14: (c1 - X) - (c2 - X) == c1 - c2.  */\n \t      if (gfc_dep_compare_expr (e1_op2, e2_op2) == 0)\n@@ -702,8 +702,8 @@ gfc_dep_difference (gfc_expr *e1, gfc_expr *e2, mpz_t *result)\n \n   if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_PLUS)\n     {\n-      e2_op1 = discard_nops (e2->value.op.op1);\n-      e2_op2 = discard_nops (e2->value.op.op2);\n+      e2_op1 = gfc_discard_nops (e2->value.op.op1);\n+      e2_op2 = gfc_discard_nops (e2->value.op.op2);\n \n       /* Case 15: X - (X + c2) = -c2.  */\n       if (e2_op2->expr_type == EXPR_CONSTANT\n@@ -723,8 +723,8 @@ gfc_dep_difference (gfc_expr *e1, gfc_expr *e2, mpz_t *result)\n \n   if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_MINUS)\n     {\n-      e2_op1 = discard_nops (e2->value.op.op1);\n-      e2_op2 = discard_nops (e2->value.op.op2);\n+      e2_op1 = gfc_discard_nops (e2->value.op.op1);\n+      e2_op2 = gfc_discard_nops (e2->value.op.op2);\n \n       /* Case 17: X - (X - c2) = c2.  */\n       if (e2_op2->expr_type == EXPR_CONSTANT"}, {"sha": "ddc982d3c521e2504c69428afe8532bafede2e8b", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=8b7cec587aa4e4d38ef9a258dc39cef53f8c8482", "patch": "@@ -42,6 +42,8 @@ static bool is_empty_string (gfc_expr *e);\n static void doloop_warn (gfc_namespace *);\n static void optimize_reduction (gfc_namespace *);\n static int callback_reduction (gfc_expr **, int *, void *);\n+static void realloc_strings (gfc_namespace *);\n+static gfc_expr *create_var (gfc_expr *);\n \n /* How deep we are inside an argument list.  */\n \n@@ -113,6 +115,51 @@ gfc_run_passes (gfc_namespace *ns)\n \n       expr_array.release ();\n     }\n+\n+  if (flag_realloc_lhs)\n+    realloc_strings (ns);\n+}\n+\n+/* Callback for each gfc_code node invoked from check_realloc_strings.\n+   For an allocatable LHS string which also appears as a variable on\n+   the RHS, replace \n+\n+   a = a(x:y)\n+\n+   with\n+\n+   tmp = a(x:y)\n+   a = tmp\n+ */\n+\n+static int\n+realloc_string_callback (gfc_code **c, int *walk_subtrees,\n+\t\t\t void *data ATTRIBUTE_UNUSED)\n+{\n+  gfc_expr *expr1, *expr2;\n+  gfc_code *co = *c;\n+  gfc_expr *n;\n+\n+  *walk_subtrees = 0;\n+  if (co->op != EXEC_ASSIGN)\n+    return 0;\n+\n+  expr1 = co->expr1;\n+  if (expr1->ts.type != BT_CHARACTER || expr1->rank != 0\n+      || !expr1->symtree->n.sym->attr.allocatable)\n+    return 0;\n+\n+  expr2 = gfc_discard_nops (co->expr2);\n+  if (expr2->expr_type != EXPR_VARIABLE)\n+    return 0;\n+\n+  if (!gfc_check_dependency (expr1, expr2, true))\n+    return 0;\n+  \n+  current_code = c;\n+  n = create_var (expr2);\n+  co->expr2 = n;\n+  return 0;\n }\n \n /* Callback for each gfc_code node invoked through gfc_code_walker\n@@ -430,6 +477,52 @@ is_fe_temp (gfc_expr *e)\n   return e->symtree->n.sym->attr.fe_temp;\n }\n \n+/* Determine the length of a string, if it can be evaluated as a constant\n+   expression.  Return a newly allocated gfc_expr or NULL on failure.\n+   If the user specified a substring which is potentially longer than\n+   the string itself, the string will be padded with spaces, which\n+   is harmless.  */\n+\n+static gfc_expr *\n+constant_string_length (gfc_expr *e)\n+{\n+\n+  gfc_expr *length;\n+  gfc_ref *ref;\n+  gfc_expr *res;\n+  mpz_t value;\n+\n+  if (e->ts.u.cl)\n+    {\n+      length = e->ts.u.cl->length;\n+      if (length && length->expr_type == EXPR_CONSTANT)\n+\treturn gfc_copy_expr(length);\n+    }\n+\n+  /* Return length of substring, if constant. */\n+  for (ref = e->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type == REF_SUBSTRING\n+\t  && gfc_dep_difference (ref->u.ss.end, ref->u.ss.start, &value))\n+\t{\n+\t  res = gfc_get_constant_expr (BT_INTEGER, gfc_charlen_int_kind,\n+\t\t\t\t       &e->where);\n+\t  \n+\t  mpz_add_ui (res->value.integer, value, 1);\n+\t  mpz_clear (value);\n+\t  return res;\n+\t}\n+    }\n+\n+  /* Return length of char symbol, if constant.  */\n+\n+  if (e->symtree->n.sym->ts.u.cl && e->symtree->n.sym->ts.u.cl->length\n+      && e->symtree->n.sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n+    return gfc_copy_expr (e->symtree->n.sym->ts.u.cl->length);\n+\n+  return NULL;\n+\n+}\n \n /* Returns a new expression (a variable) to be used in place of the old one,\n    with an assignment statement before the current statement to set\n@@ -525,6 +618,20 @@ create_var (gfc_expr * e)\n \t}\n     }\n \n+  if (e->ts.type == BT_CHARACTER && e->rank == 0)\n+    {\n+      gfc_expr *length;\n+\n+      length = constant_string_length (e);\n+      if (length)\n+\t{\n+\t  symbol->ts.u.cl = gfc_new_charlen (ns, NULL);\n+\t  symbol->ts.u.cl->length = length;\n+\t}\n+      else\n+\tsymbol->attr.allocatable = 1;\n+    }\n+\n   symbol->attr.flavor = FL_VARIABLE;\n   symbol->attr.referenced = 1;\n   symbol->attr.dimension = e->rank > 0;\n@@ -849,6 +956,26 @@ optimize_namespace (gfc_namespace *ns)\n     }\n }\n \n+/* Handle dependencies for allocatable strings which potentially redefine\n+   themselves in an assignment.  */\n+\n+static void\n+realloc_strings (gfc_namespace *ns)\n+{\n+  current_ns = ns;\n+  gfc_code_walker (&ns->code, realloc_string_callback, dummy_expr_callback, NULL);\n+\n+  for (ns = ns->contained; ns; ns = ns->sibling)\n+    {\n+      if (ns->code == NULL || ns->code->op != EXEC_BLOCK)\n+\t{\n+\t  // current_ns = ns;\n+\t  realloc_strings (ns);\n+\t}\n+    }\n+\n+}\n+\n static void\n optimize_reduction (gfc_namespace *ns)\n {\n@@ -1567,6 +1694,11 @@ optimize_trim (gfc_expr *e)\n   if (a->expr_type != EXPR_VARIABLE)\n     return false;\n \n+  /* This would pessimize the idiom a = trim(a) for reallocatable strings.  */\n+\n+  if (a->symtree->n.sym->attr.allocatable)\n+    return false;\n+\n   /* Follow all references to find the correct place to put the newly\n      created reference.  FIXME:  Also handle substring references and\n      array references.  Array references cause strange regressions at"}, {"sha": "ee90726c331880dae60be478ea58e7db40535fe0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b7cec587aa4e4d38ef9a258dc39cef53f8c8482", "patch": "@@ -1,3 +1,8 @@\n+2015-01-05  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/47674\n+\t* gfortran.dg/realloc_on_assign_25.f90:  New test.\n+\n 2015-01-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "1e2a27389769ae6da03e4465ab8359e73eff6589", "filename": "gcc/testsuite/gfortran.dg/realloc_on_assign_25.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7cec587aa4e4d38ef9a258dc39cef53f8c8482/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_25.f90?ref=8b7cec587aa4e4d38ef9a258dc39cef53f8c8482", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+! PR 47674 - this would segfault if MALLOC_PERTURB is set.\n+! This checks a code path where it is not possible to determine\n+! the length of the string at compile time.\n+!\n+program main\n+  implicit none\n+  character(:), allocatable :: a\n+  integer :: m, n\n+  a = 'a'\n+  if (a .ne. 'a') call abort\n+  a = a // 'x'\n+  if (a .ne. 'ax') call abort\n+  if (len (a) .ne. 2) call abort\n+  n = 2\n+  m = 2\n+  a = a(m:n)\n+  if (a .ne. 'x') call abort\n+  if (len (a) .ne. 1) call abort\n+end program main"}]}