{"sha": "10b6a27401cfaff93dbb479de0fea2e49bb6530a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBiNmEyNzQwMWNmYWZmOTNkYmI0NzlkZTBmZWEyZTQ5YmI2NTMwYQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-05-05T21:57:54Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-05-05T21:57:54Z"}, "message": "rtl.h (STRING_POOL_ADDRESS_P): Rename to DEFERRED_CONSTANT_P.\n\n\t* rtl.h (STRING_POOL_ADDRESS_P): Rename to DEFERRED_CONSTANT_P.\n\t* varasm.c (struct varasm_status): Add deferred_constants field.\n\t(n_deferred_strings): Delete variable.\n\t(n_deferred_constants): New #define.\n\t(struct constant_descriptor_tree): Kill next and label fields.\n\t(const_hash_table, MAX_HASH_TABLE): Delete.\n\t(const_desc_htab): New static variable.\n\t(const_hash): Rename const_desc_hash, and make it fit the\n\thashtab.h interface.\n\t(const_desc_eq): New.\n\t(const_hash_1, compare_constant): Const-ify arguments.\n\t(build_constant_desc): Set DEFERRED_CONSTANT_P on all new\n\tSYMBOL_REFs.  Clarify comments.  Don't set desc->label.\n\t(output_constant_def): Do the lookup/insert using the\n\thashtab.h interface.  Don't muck with n_deferred_constants or\n\tDEFERRED_CONSTANT_P here.\n\tAlways call maybe_output_constant_def_contents.\n\t(maybe_output_constant_def_contents): Take a pointer to the\n\tdescriptor, not the EXP and RTL separately.  Return\n\timmediately if this constant is not deferred.  Defer output of\n\teverything, except writable string constants.  Update\n\tn_deferred_constants here.\n\t(output_constant_def_contents): Now takes just one argument,\n\tan rtx.  Clear DEFERRED_CONSTANT_P here.\n\t(mark_constant_pool): Update for rename of n_deferred_strings.\n\t(mark_constant): Don't clear DEFERRED_CONSTANT_P here.\n\n\t(init_varasm_status): Clear p->deferred_constants.\n\t(init_varasm_once): Call htab_create_ggc for const_desc_htab.\n\n\t* gcc.dg/const-elim-1.c, gcc.dg/const-elim-2.c: New testcases.\n\nFrom-SVN: r66505", "tree": {"sha": "25c76bfeefa5b878c52eeeb1f17d57eb566eb1a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25c76bfeefa5b878c52eeeb1f17d57eb566eb1a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10b6a27401cfaff93dbb479de0fea2e49bb6530a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b6a27401cfaff93dbb479de0fea2e49bb6530a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b6a27401cfaff93dbb479de0fea2e49bb6530a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b6a27401cfaff93dbb479de0fea2e49bb6530a/comments", "author": null, "committer": null, "parents": [{"sha": "68ef8841db44baf4b390349b630dd8bcbdfd5223", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ef8841db44baf4b390349b630dd8bcbdfd5223", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ef8841db44baf4b390349b630dd8bcbdfd5223"}], "stats": {"total": 307, "additions": 208, "deletions": 99}, "files": [{"sha": "6ba41bdceb1e94839a940396f1b69be47bddf76a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 21, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b6a27401cfaff93dbb479de0fea2e49bb6530a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b6a27401cfaff93dbb479de0fea2e49bb6530a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10b6a27401cfaff93dbb479de0fea2e49bb6530a", "patch": "@@ -1,13 +1,45 @@\n+2003-05-05  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* rtl.h (STRING_POOL_ADDRESS_P): Rename to DEFERRED_CONSTANT_P.\n+\t* varasm.c (struct varasm_status): Add deferred_constants field.\n+\t(n_deferred_strings): Delete variable.\n+\t(n_deferred_constants): New #define.\n+\t(struct constant_descriptor_tree): Kill next and label fields.\n+\t(const_hash_table, MAX_HASH_TABLE): Delete.\n+\t(const_desc_htab): New static variable.\n+\t(const_hash): Rename const_desc_hash, and make it fit the\n+\thashtab.h interface.\n+\t(const_desc_eq): New.\n+\t(const_hash_1, compare_constant): Const-ify arguments.\n+\t(build_constant_desc): Set DEFERRED_CONSTANT_P on all new\n+\tSYMBOL_REFs.  Clarify comments.  Don't set desc->label.\n+\t(output_constant_def): Do the lookup/insert using the\n+\thashtab.h interface.  Don't muck with n_deferred_constants or\n+\tDEFERRED_CONSTANT_P here.\n+\tAlways call maybe_output_constant_def_contents.\n+\t(maybe_output_constant_def_contents): Take a pointer to the\n+\tdescriptor, not the EXP and RTL separately.  Return\n+\timmediately if this constant is not deferred.  Defer output of\n+\teverything, except writable string constants.  Update\n+\tn_deferred_constants here.\n+\t(output_constant_def_contents): Now takes just one argument,\n+\tan rtx.  Clear DEFERRED_CONSTANT_P here.\n+\t(mark_constant_pool): Update for rename of n_deferred_strings.\n+\t(mark_constant): Don't clear DEFERRED_CONSTANT_P here.\n+\n+\t(init_varasm_status): Clear p->deferred_constants.\n+\t(init_varasm_once): Call htab_create_ggc for const_desc_htab.\n+\n 2003-05-05  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* builtins.c (expand_builtin_stpcpy): Only expand when the length\n \tof the source string can be evaluated at compile-time.\n \n 2003-05-05  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * testsuite/gcc.c-torture/compile/simd-6.c: New.\n+\t* testsuite/gcc.c-torture/compile/simd-6.c: New.\n \n-        * c-typeck.c (digest_init): Handle arrays of vector constants.\n+\t* c-typeck.c (digest_init): Handle arrays of vector constants.\n \n 2003-05-05  Jakub Jelinek  <jakub@redhat.com>\n \n@@ -19,17 +51,17 @@\n \n 2003-05-05  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * testsuite/gcc.dg/20030505.c: New.\n+\t* testsuite/gcc.dg/20030505.c: New.\n \n-        * c-typeck.c (convert_for_assignment): Opaque pointers can\n-        interconvert.\n+\t* c-typeck.c (convert_for_assignment): Opaque pointers can\n+\tinterconvert.\n \n-        * config/rs6000/rs6000.c: New global opaque_p_V2SI_type_node.\n-        (rs6000_init_builtins): Initialize opaque_p_V2SI_type_node.\n-        (spe_init_builtins): Rename all pv2si_type_node to\n-        opaque_p_V2SI_type_node.\n-        Remove declaration of pv2si_type_node.\n-        (is_ev64_opaque_type): Accept opaque pointers.\n+\t* config/rs6000/rs6000.c: New global opaque_p_V2SI_type_node.\n+\t(rs6000_init_builtins): Initialize opaque_p_V2SI_type_node.\n+\t(spe_init_builtins): Rename all pv2si_type_node to\n+\topaque_p_V2SI_type_node.\n+\tRemove declaration of pv2si_type_node.\n+\t(is_ev64_opaque_type): Accept opaque pointers.\n \n 2003-05-05  Geoffrey Keating  <geoffk@apple.com>\n \n@@ -40,27 +72,27 @@\n \t(rs6000_generate_compare): Use flag_finite_math_only.\n \t(rs6000_emit_cmove): Handle UNLE.  Support UNEQ under -ffast-math.\n \tUse HONOR_* rather than flag_unsafe_math_optimizations.  Correct\n-\tUNGE and GT cases.  Handle UNEQ and LTGT when ! HONOR_NANS.  \n+\tUNGE and GT cases.  Handle UNEQ and LTGT when ! HONOR_NANS.\n \n \t* toplev.c (check_global_declarations): Suppress not-used warning\n \tfor volatile variables.\n \n 2003-05-05  Olivier Hainque  <hainque@act-europe.fr>\n \n-        * expr.c (expand_expr, case BIT_FIELD_REF): Refine the test forcing\n-        usage of bitfield instructions for mode1 != BLKmode, only ignoring\n-        SLOW_UNALIGNED_ACCESS if the field is not byte aligned. \n-        (store_field): Likewise.\n+\t* expr.c (expand_expr, case BIT_FIELD_REF): Refine the test forcing\n+\tusage of bitfield instructions for mode1 != BLKmode, only ignoring\n+\tSLOW_UNALIGNED_ACCESS if the field is not byte aligned.\n+\t(store_field): Likewise.\n \n 2003-05-05  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/rs6000.c (rs6000_expand_binop_builtin): Add\n-        evsubifw to builtins accepting 5-bit unsigned constants.\n-        (easy_vector_constant): Return if V1DImode.  Fix typo.\n+\t* config/rs6000/rs6000.c (rs6000_expand_binop_builtin): Add\n+\tevsubifw to builtins accepting 5-bit unsigned constants.\n+\t(easy_vector_constant): Return if V1DImode.  Fix typo.\n \n 2003-05-05  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/spe.h: Revert licensing change from last patch.\n+\t* config/rs6000/spe.h: Revert licensing change from last patch.\n \n 2003-05-05  DJ Delorie  <dj@redhat.com>\n \n@@ -77,7 +109,7 @@\n 2003-05-05  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* libgcov.c (__gcov_merge_add): Do not use gcov_type when inhibit_libc\n-\tis defined.\t\n+\tis defined.\n \n 2003-05-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n "}, {"sha": "eab41e2918e1e4a2deb54087cf0b177f64393fd6", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b6a27401cfaff93dbb479de0fea2e49bb6530a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b6a27401cfaff93dbb479de0fea2e49bb6530a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=10b6a27401cfaff93dbb479de0fea2e49bb6530a", "patch": "@@ -1234,10 +1234,11 @@ do {\t\t\t\t\t\t\\\n #define CONSTANT_POOL_ADDRESS_P(RTX)\t\t\t\t\t\\\n   (RTL_FLAG_CHECK1(\"CONSTANT_POOL_ADDRESS_P\", (RTX), SYMBOL_REF)->unchanging)\n \n-/* 1 if RTX is a symbol_ref that addresses this function's string constant\n-   pool  */\n-#define STRING_POOL_ADDRESS_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK1(\"STRING_POOL_ADDRESS_P\", (RTX), SYMBOL_REF)->frame_related)\n+/* 1 if RTX is a symbol_ref that addresses a value in the file's constant\n+   pool which has not yet been output.  This information is private to\n+   varasm.c.  */\n+#define DEFERRED_CONSTANT_P(RTX)\t\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"DEFERRED_CONSTANT_P\", (RTX), SYMBOL_REF)->frame_related)\n \n /* Used if RTX is a symbol_ref, for machine-specific purposes.  */\n #define SYMBOL_REF_FLAG(RTX)\t\t\t\t\t\t\\"}, {"sha": "05b06a0b5f8e3eacda4dab5c2098ea7a2ec9bb00", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b6a27401cfaff93dbb479de0fea2e49bb6530a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b6a27401cfaff93dbb479de0fea2e49bb6530a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10b6a27401cfaff93dbb479de0fea2e49bb6530a", "patch": "@@ -1,3 +1,7 @@\n+2003-05-05  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* gcc.dg/const-elim-1.c, gcc.dg/const-elim-2.c: New testcases.\n+\n 2003-05-05  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/execute/string-opt-18.c (main): Add 3 new tests."}, {"sha": "b704408b6e3b5d74ef5d14816f1d826af0fcf266", "filename": "gcc/testsuite/gcc.dg/const-elim-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b6a27401cfaff93dbb479de0fea2e49bb6530a/gcc%2Ftestsuite%2Fgcc.dg%2Fconst-elim-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b6a27401cfaff93dbb479de0fea2e49bb6530a/gcc%2Ftestsuite%2Fgcc.dg%2Fconst-elim-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fconst-elim-1.c?ref=10b6a27401cfaff93dbb479de0fea2e49bb6530a", "patch": "@@ -0,0 +1,48 @@\n+/* Verify that constants in memory, referenced only by dead code,\n+   are not emitted to the object file.\n+   FIXME: Not presently possible to apply -pedantic to code with\n+   complex constants in it.  The __extension__ should shut up the\n+   warning but doesn't.  (Hard to fix -- the lexer is not aware of\n+   the parser's state.)  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -std=c99\" } */\n+/* { dg-final { scan-assembler-not \"LC\" } } */\n+\n+#define I (__extension__ 1.0iF)\n+\n+struct S { int a; double b[2]; void *c; };\n+\n+extern void use_str(const char *);\n+extern void use_S(const struct S *);\n+extern void use_cplx(__complex__ double);\n+\n+static inline int\n+returns_23(void) { return 23; }\n+\n+void\n+test1(void)\n+{\n+\tif (returns_23() == 23)\n+\t\treturn;\n+\n+\tuse_str(\"waltz, nymph, for quick jigs vex bud\");\n+\tuse_S(&(const struct S){12, {3.1415, 2.1828}, 0 });\n+\tuse_cplx(3.1415 + 2.1828*I);\n+}\n+\n+void\n+test2(void)\n+{\n+\tconst char *str = \"pack my box with five dozen liquor jugs\";\n+\tconst struct S S = { 23, { 1.414, 1.618 }, 0 };\n+\tconst __complex__ double cplx = 1.414 + 1.618*I;\n+\n+\tif (returns_23() == 23)\n+\t\treturn;\n+\n+\tuse_str(str);\n+\tuse_S(&S);\n+\tuse_cplx(cplx);\n+}\n+"}, {"sha": "ce55ba1c8242d2f60fafef718643a3df2b4a457d", "filename": "gcc/testsuite/gcc.dg/const-elim-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b6a27401cfaff93dbb479de0fea2e49bb6530a/gcc%2Ftestsuite%2Fgcc.dg%2Fconst-elim-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b6a27401cfaff93dbb479de0fea2e49bb6530a/gcc%2Ftestsuite%2Fgcc.dg%2Fconst-elim-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fconst-elim-2.c?ref=10b6a27401cfaff93dbb479de0fea2e49bb6530a", "patch": "@@ -0,0 +1,10 @@\n+/* The string constant in this test case should be emitted exactly once.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-times \"hi there\" 1 } } */\n+\n+static inline int returns_23() { return 23; }\n+\n+const char *test1(void) { if (returns_23()) return 0; return \"hi there\"; }\n+const char *test2(void) { return \"hi there\"; }\n+const char *test3(void) { return \"hi there\"; }"}, {"sha": "1e17a0696516a8d54cc478d9f66a77a89f438c4d", "filename": "gcc/varasm.c", "status": "modified", "additions": 88, "deletions": 74, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b6a27401cfaff93dbb479de0fea2e49bb6530a/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b6a27401cfaff93dbb479de0fea2e49bb6530a/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=10b6a27401cfaff93dbb479de0fea2e49bb6530a", "patch": "@@ -96,13 +96,18 @@ struct varasm_status GTY(())\n   /* Current offset in constant pool (does not include any machine-specific\n      header).  */\n   HOST_WIDE_INT x_pool_offset;\n+\n+  /* Number of tree-constants deferred during the expansion of this\n+     function.  */\n+  unsigned int deferred_constants;\n };\n \n #define const_rtx_hash_table (cfun->varasm->x_const_rtx_hash_table)\n #define const_rtx_sym_hash_table (cfun->varasm->x_const_rtx_sym_hash_table)\n #define first_pool (cfun->varasm->x_first_pool)\n #define last_pool (cfun->varasm->x_last_pool)\n #define pool_offset (cfun->varasm->x_pool_offset)\n+#define n_deferred_constants (cfun->varasm->deferred_constants)\n \n /* Number for making the label on the next\n    constant that is stored in memory.  */\n@@ -138,12 +143,12 @@ static HOST_WIDE_INT const_alias_set;\n static const char *strip_reg_name\tPARAMS ((const char *));\n static int contains_pointers_p\t\tPARAMS ((tree));\n static void decode_addr_const\t\tPARAMS ((tree, struct addr_const *));\n-static unsigned int const_hash\t\tPARAMS ((tree));\n-static unsigned int const_hash_1\tPARAMS ((tree));\n-static int compare_constant\t\tPARAMS ((tree, tree));\n+static hashval_t const_desc_hash\tPARAMS ((const void *));\n+static int const_desc_eq\t\tPARAMS ((const void *, const void *));\n+static hashval_t const_hash_1\t\tPARAMS ((const tree));\n+static int compare_constant\t\tPARAMS ((const tree, const tree));\n static tree copy_constant\t\tPARAMS ((tree));\n-static void maybe_output_constant_def_contents PARAMS ((tree, rtx, int));\n-static void output_constant_def_contents  PARAMS ((tree, const char *));\n+static void output_constant_def_contents  PARAMS ((rtx));\n static void decode_rtx_const\t\tPARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t       struct rtx_const *));\n static unsigned int const_hash_rtx\tPARAMS ((enum machine_mode, rtx));\n@@ -2143,41 +2148,35 @@ struct rtx_const GTY(())\n \n struct constant_descriptor_tree GTY(())\n {\n-  /* More constant_descriptors with the same hash code.  */\n-  struct constant_descriptor_tree *next;\n-\n-  /* The label of the constant.  */\n-  const char *label;\n-\n   /* A MEM for the constant.  */\n   rtx rtl;\n \n   /* The value of the constant.  */\n   tree value;\n };\n \n-#define MAX_HASH_TABLE 1009\n-static GTY(()) struct constant_descriptor_tree *\n-  const_hash_table[MAX_HASH_TABLE];\n+static GTY((param_is (struct constant_descriptor_tree)))\n+     htab_t const_desc_htab;\n \n static struct constant_descriptor_tree * build_constant_desc PARAMS ((tree));\n-static unsigned int n_deferred_strings = 0;\n+static void maybe_output_constant_def_contents\n+    PARAMS ((struct constant_descriptor_tree *, int));\n \n /* Compute a hash code for a constant expression.  */\n \n-static unsigned int\n-const_hash (exp)\n-     tree exp;\n+static hashval_t\n+const_desc_hash (ptr)\n+     const void *ptr;\n {\n-  return const_hash_1 (exp) % MAX_HASH_TABLE;\n+  return const_hash_1 (((struct constant_descriptor_tree *)ptr)->value);\n }\n \n-static unsigned int\n+static hashval_t\n const_hash_1 (exp)\n-     tree exp;\n+     const tree exp;\n {\n   const char *p;\n-  unsigned int hi;\n+  hashval_t hi;\n   int len, i;\n   enum tree_code code = TREE_CODE (exp);\n \n@@ -2198,7 +2197,6 @@ const_hash_1 (exp)\n       p = TREE_STRING_POINTER (exp);\n       len = TREE_STRING_LENGTH (exp);\n       break;\n-\n     case COMPLEX_CST:\n       return (const_hash_1 (TREE_REALPART (exp)) * 5\n \t      + const_hash_1 (TREE_IMAGPART (exp)));\n@@ -2272,13 +2270,23 @@ const_hash_1 (exp)\n   return hi;\n }\n \n+/* Wrapper of compare_constant, for the htab interface.  */\n+static int\n+const_desc_eq (p1, p2)\n+     const void *p1;\n+     const void *p2;\n+{\n+  return compare_constant (((struct constant_descriptor_tree *)p1)->value,\n+\t\t\t   ((struct constant_descriptor_tree *)p2)->value);\n+}\n+\n /* Compare t1 and t2, and return 1 only if they are known to result in\n    the same bit pattern on output.  */\n \n static int\n compare_constant (t1, t2)\n-     tree t1;\n-     tree t2;\n+     const tree t1;\n+     const tree t2;\n {\n   enum tree_code typecode;\n \n@@ -2531,11 +2539,18 @@ build_constant_desc (exp)\n   /* Set flags or add text to the name to record information, such as\n      that it is a local symbol.  If the name is changed, the macro\n      ASM_OUTPUT_LABELREF will have to know how to strip this\n-     information.  */\n+     information.  This call might invalidate our local variable\n+     SYMBOL; we can't use it afterward.  */\n+\n   (*targetm.encode_section_info) (exp, rtl, true);\n \n+  /* Descriptors start out deferred; this simplifies the logic in\n+     maybe_output_constant_def_contents.  However, we do not bump\n+     n_deferred_constants here, because we don't know if we're inside\n+     a function and have an n_deferred_constants to bump.  */\n+  DEFERRED_CONSTANT_P (XEXP (rtl, 0)) = 1;\n+\n   desc->rtl = rtl;\n-  desc->label = XSTR (XEXP (desc->rtl, 0), 0);\n \n   return desc;\n }\n@@ -2548,8 +2563,8 @@ build_constant_desc (exp)\n    Otherwise, output such a constant in memory\n    and generate an rtx for it.\n \n-   If DEFER is nonzero, the output of string constants can be deferred\n-   and output only if referenced in the function after all optimizations.\n+   If DEFER is nonzero, this constant can be deferred and output only\n+   if referenced in the function after all optimizations.\n \n    The const_hash_table records which constants already have label strings.  */\n \n@@ -2558,70 +2573,64 @@ output_constant_def (exp, defer)\n      tree exp;\n      int defer;\n {\n-  int hash;\n   struct constant_descriptor_tree *desc;\n+  struct constant_descriptor_tree key;\n+  void **loc;\n \n-  /* Compute hash code of EXP.  Search the descriptors for that hash code\n-     to see if any of them describes EXP.  If yes, the descriptor records\n-     the label number already assigned.  */\n-\n-  hash = const_hash (exp);\n-  for (desc = const_hash_table[hash]; desc; desc = desc->next)\n-    if (compare_constant (exp, desc->value))\n-      break;\n+  /* Look up EXP in the table of constant descriptors.  If we didn't find\n+     it, create a new one.  */\n+  key.value = exp;\n+  loc = htab_find_slot (const_desc_htab, &key, INSERT);\n \n+  desc = *loc;\n   if (desc == 0)\n     {\n       desc = build_constant_desc (exp);\n-      desc->next = const_hash_table[hash];\n-      const_hash_table[hash] = desc;\n-\n-      maybe_output_constant_def_contents (exp, desc->rtl, defer);\n-    }\n-  else if (!defer && STRING_POOL_ADDRESS_P (XEXP (desc->rtl, 0)))\n-    {\n-      /* This string is currently deferred but we need to output it\n-\t now; mark it no longer deferred.  */\n-      STRING_POOL_ADDRESS_P (XEXP (desc->rtl, 0)) = 0;\n-      n_deferred_strings--;\n-      maybe_output_constant_def_contents (exp, desc->rtl, 0);\n+      *loc = desc;\n     }\n \n+  maybe_output_constant_def_contents (desc, defer);\n   return desc->rtl;\n }\n \n-/* Subroutine of output_constant_def:\n-   Decide whether or not to defer the output of EXP, which can be\n-   accesed through rtl RTL, and either do the output or record EXP in\n-   the table of deferred strings.  */\n+/* Subroutine of output_constant_def: Decide whether or not we need to\n+   output the constant DESC now, and if so, do it.  */\n static void\n-maybe_output_constant_def_contents (exp, rtl, defer)\n-     tree exp;\n-     rtx rtl;\n+maybe_output_constant_def_contents (desc, defer)\n+     struct constant_descriptor_tree *desc;\n      int defer;\n {\n+  rtx symbol = XEXP (desc->rtl, 0);\n+\n   if (flag_syntax_only)\n     return;\n \n-  /* Is this a string constant that can be deferred?  */\n-  if (defer && TREE_CODE (exp) == STRING_CST && !flag_writable_strings)\n+  if (!DEFERRED_CONSTANT_P (symbol))\n+    /* Already output; don't do it again.  */\n+    return;\n+\n+  /* The only constants that cannot safely be deferred, assuming the\n+     context allows it, are strings under flag_writable_strings.  */\n+  if (defer && (TREE_CODE (desc->value) != STRING_CST\n+\t\t|| !flag_writable_strings))\n     {\n-      STRING_POOL_ADDRESS_P (XEXP (rtl, 0)) = 1;\n-      n_deferred_strings++;\n+      if (cfun)\n+\tn_deferred_constants++;\n       return;\n     }\n \n-  output_constant_def_contents (exp, XSTR (XEXP (rtl, 0), 0));\n+  output_constant_def_contents (symbol);\n }\n \n-/* Now output assembler code to define the label for EXP,\n-   and follow it with the data of EXP.  */\n+/* We must output the constant data referred to by SYMBOL; do so.  */\n \n static void\n-output_constant_def_contents (exp, label)\n-     tree exp;\n-     const char *label;\n+output_constant_def_contents (symbol)\n+     rtx symbol;\n {\n+  tree exp = SYMBOL_REF_DECL (symbol);\n+  const char *label = XSTR (symbol, 0);\n+\n   /* Make sure any other constants whose addresses appear in EXP\n      are assigned label numbers.  */\n   int reloc = output_addressed_constants (exp);\n@@ -2632,6 +2641,9 @@ output_constant_def_contents (exp, label)\n   align = CONSTANT_ALIGNMENT (exp, align);\n #endif\n \n+  /* We are no longer deferring this constant.  */\n+  DEFERRED_CONSTANT_P (symbol) = 0;\n+\n   if (IN_NAMED_SECTION (exp))\n     named_section (exp, NULL, reloc);\n   else\n@@ -2715,6 +2727,7 @@ init_varasm_status (f)\n \n   p->x_first_pool = p->x_last_pool = 0;\n   p->x_pool_offset = 0;\n+  p->deferred_constants = 0;\n }\n \f\n \n@@ -3329,8 +3342,8 @@ output_constant_pool (fnname, fndecl)\n }\n \n /* Look through the instructions for this function, and mark all the\n-   entries in the constant pool which are actually being used.\n-   Emit used deferred strings.  */\n+   entries in the constant pool which are actually being used.  Emit\n+   deferred constants which have indeed been used.  */\n \n static void\n mark_constant_pool ()\n@@ -3339,7 +3352,7 @@ mark_constant_pool ()\n   rtx link;\n   struct pool_constant *pool;\n \n-  if (first_pool == 0 && n_deferred_strings == 0)\n+  if (first_pool == 0 && n_deferred_constants == 0)\n     return;\n \n   for (pool = first_pool; pool; pool = pool->next)\n@@ -3453,11 +3466,10 @@ mark_constant (current_rtx, data)\n \t  else\n \t    return -1;\n \t}\n-      else if (STRING_POOL_ADDRESS_P (x))\n+      else if (DEFERRED_CONSTANT_P (x))\n \t{\n-\t  STRING_POOL_ADDRESS_P (x) = 0;\n-\t  n_deferred_strings--;\n-\t  output_constant_def_contents (SYMBOL_REF_DECL (x), XSTR (x, 0));\n+\t  n_deferred_constants--;\n+\t  output_constant_def_contents (x);\n \t}\n     }\n   return 0;\n@@ -4544,6 +4556,8 @@ init_varasm_once ()\n {\n   in_named_htab = htab_create_ggc (31, in_named_entry_hash,\n \t\t\t\t   in_named_entry_eq, NULL);\n+  const_desc_htab = htab_create_ggc (1009, const_desc_hash,\n+\t\t\t\t     const_desc_eq, NULL);\n \n   const_alias_set = new_alias_set ();\n }"}]}