{"sha": "5cf447dbf18327c71263f9afff56905d2a86dc0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNmNDQ3ZGJmMTgzMjdjNzEyNjNmOWFmZmY1NjkwNWQyYTg2ZGMwZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-09-24T14:04:58Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-24T14:04:58Z"}, "message": "re PR c++/16889 (ambiguity is not detected)\n\ncp:\n\tPR c++/16889\n\t* search.c (lookup_field_queue_p): Correct check for hidden base.\n\n\t* search.c (bfs_walk): Remove.\n\t(lookup_member): Use dfs_walk_real.\n\t(dfs_walk_real): Move and adjust documentation from bfs_walk.\ntestsuite:\n\tPR c++/16889\n\t* g++.dg/lookup/ambig3.C: New.\n\nFrom-SVN: r88037", "tree": {"sha": "4b7df1428bb79c3d0495988b626d036f1c30c384", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b7df1428bb79c3d0495988b626d036f1c30c384"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cf447dbf18327c71263f9afff56905d2a86dc0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cf447dbf18327c71263f9afff56905d2a86dc0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cf447dbf18327c71263f9afff56905d2a86dc0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cf447dbf18327c71263f9afff56905d2a86dc0d/comments", "author": null, "committer": null, "parents": [{"sha": "c5466b25b4642820236eb73f895488da192cbab0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5466b25b4642820236eb73f895488da192cbab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5466b25b4642820236eb73f895488da192cbab0"}], "stats": {"total": 148, "additions": 47, "deletions": 101}, "files": [{"sha": "80c2b79effc539cad3fd053e1246815967590f6c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf447dbf18327c71263f9afff56905d2a86dc0d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf447dbf18327c71263f9afff56905d2a86dc0d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5cf447dbf18327c71263f9afff56905d2a86dc0d", "patch": "@@ -1,3 +1,12 @@\n+2004-09-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/16889\n+\t* search.c (lookup_field_queue_p): Correct check for hidden base.\n+\n+\t* search.c (bfs_walk): Remove.\n+\t(lookup_member): Use dfs_walk_real.\n+\t(dfs_walk_real): Move and adjust documentation from bfs_walk.\n+\n 2004-09-23  Zack Weinberg  <zack@codesourcery.com>\n \n \t* decl.c (grokfndecl): If ::main is found not to return int,"}, {"sha": "67b891f85e3257a4e75af2e059528972db83d209", "filename": "gcc/cp/search.c", "status": "modified", "additions": 15, "deletions": 101, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf447dbf18327c71263f9afff56905d2a86dc0d/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf447dbf18327c71263f9afff56905d2a86dc0d/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=5cf447dbf18327c71263f9afff56905d2a86dc0d", "patch": "@@ -57,8 +57,6 @@ static tree split_conversions (tree, tree, tree, tree);\n static int lookup_conversions_r (tree, int, int,\n \t\t\t\t tree, tree, tree, tree, tree *, tree *);\n static int look_for_overrides_r (tree, tree);\n-static tree bfs_walk (tree, tree (*) (tree, void *),\n-\t\t      tree (*) (tree, int, void *), void *);\n static tree lookup_field_queue_p (tree, int, void *);\n static int shared_member_p (tree);\n static tree lookup_field_r (tree, void *);\n@@ -991,7 +989,7 @@ lookup_field_queue_p (tree derived, int ix, void *data)\n \n   /* If this base class is hidden by the best-known value so far, we\n      don't need to look.  */\n-  if (lfi->rval_binfo && original_binfo (binfo, lfi->rval_binfo))\n+  if (lfi->rval_binfo && derived == lfi->rval_binfo)\n     return NULL_TREE;\n \n   /* If this is a dependent base, don't look in it.  */\n@@ -1256,7 +1254,8 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n   lfi.type = type;\n   lfi.name = name;\n   lfi.want_type = want_type;\n-  bfs_walk (basetype_path, &lookup_field_r, &lookup_field_queue_p, &lfi);\n+  dfs_walk_real (basetype_path, &lookup_field_r, 0,\n+\t\t &lookup_field_queue_p, &lfi);\n   rval = lfi.rval;\n   rval_binfo = lfi.rval_binfo;\n   if (rval_binfo)\n@@ -1513,101 +1512,16 @@ adjust_result_of_qualified_name_lookup (tree decl,\n }\n \n \f\n-/* Walk the class hierarchy dominated by TYPE.  FN is called for each\n-   type in the hierarchy, in a breadth-first preorder traversal.\n-   If it ever returns a non-NULL value, that value is immediately\n-   returned and the walk is terminated.  At each node, FN is passed a\n-   BINFO indicating the path from the currently visited base-class to\n-   TYPE.  Before each base-class is walked QFN is called.  If the\n-   value returned is nonzero, the base-class is walked; otherwise it\n-   is not.  If QFN is NULL, it is treated as a function which always\n-   returns 1.  Both FN and QFN are passed the DATA whenever they are\n-   called.\n-\n-   Implementation notes: Uses a circular queue, which starts off on\n-   the stack but gets moved to the malloc arena if it needs to be\n-   enlarged.  The underflow and overflow conditions are\n-   indistinguishable except by context: if head == tail and we just\n-   moved the head pointer, the queue is empty, but if we just moved\n-   the tail pointer, the queue is full.  \n-   Start with enough room for ten concurrent base classes.  That\n-   will be enough for most hierarchies.  */\n-#define BFS_WALK_INITIAL_QUEUE_SIZE 10\n-\n-static tree\n-bfs_walk (tree binfo,\n-\t  tree (*fn) (tree, void *),\n-\t  tree (*qfn) (tree, int, void *),\n-\t  void *data)\n-{\n-  tree rval = NULL_TREE;\n-\n-  tree bases_initial[BFS_WALK_INITIAL_QUEUE_SIZE];\n-  /* A circular queue of the base classes of BINFO.  These will be\n-     built up in breadth-first order, except where QFN prunes the\n-     search.  */\n-  size_t head, tail;\n-  size_t base_buffer_size = BFS_WALK_INITIAL_QUEUE_SIZE;\n-  tree *base_buffer = bases_initial;\n-\n-  head = tail = 0;\n-  base_buffer[tail++] = binfo;\n-\n-  while (head != tail)\n-    {\n-      int n_bases, ix;\n-      tree binfo = base_buffer[head++];\n-      if (head == base_buffer_size)\n-\thead = 0;\n-\n-      /* Is this the one we're looking for?  If so, we're done.  */\n-      rval = fn (binfo, data);\n-      if (rval)\n-\tgoto done;\n-\n-      n_bases = BINFO_N_BASE_BINFOS (binfo);\n-      for (ix = 0; ix != n_bases; ix++)\n-\t{\n-\t  tree base_binfo;\n-\t  \n-\t  if (qfn)\n-\t    base_binfo = (*qfn) (binfo, ix, data);\n-\t  else\n-\t    base_binfo = BINFO_BASE_BINFO (binfo, ix);\n-\t  \n- \t  if (base_binfo)\n-\t    {\n-\t      base_buffer[tail++] = base_binfo;\n-\t      if (tail == base_buffer_size)\n-\t\ttail = 0;\n-\t      if (tail == head)\n-\t\t{\n-\t\t  tree *new_buffer = xmalloc (2 * base_buffer_size\n-\t\t\t\t\t      * sizeof (tree));\n-\t\t  memcpy (&new_buffer[0], &base_buffer[0],\n-\t\t\t  tail * sizeof (tree));\n-\t\t  memcpy (&new_buffer[head + base_buffer_size],\n-\t\t\t  &base_buffer[head],\n-\t\t\t  (base_buffer_size - head) * sizeof (tree));\n-\t\t  if (base_buffer_size != BFS_WALK_INITIAL_QUEUE_SIZE)\n-\t\t    free (base_buffer);\n-\t\t  base_buffer = new_buffer;\n-\t\t  head += base_buffer_size;\n-\t\t  base_buffer_size *= 2;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n- done:\n-  if (base_buffer_size != BFS_WALK_INITIAL_QUEUE_SIZE)\n-    free (base_buffer);\n-  return rval;\n-}\n-\n-/* Exactly like bfs_walk, except that a depth-first traversal is\n-   performed, and PREFN is called in preorder, while POSTFN is called\n-   in postorder.  */\n+/* Walk the class hierarchy within BINFO, in a depth-first traversal.\n+   PREFN is called in preorder, while POSTFN is called in postorder.\n+   If they ever returns a non-NULL value, that value is immediately\n+   returned and the walk is terminated.  Both PREFN and POSTFN can be\n+   NULL.  At each node, PREFN and POSTFN are passed the binfo to\n+   examine.  Before each base-binfo of BINFO is walked, QFN is called.\n+   If the value returned is nonzero, the base-binfo is walked;\n+   otherwise it is not.  If QFN is NULL, it is treated as a function\n+   which always returns 1.  All callbacks are passed DATA whenever\n+   they are called.  */\n \n tree\n dfs_walk_real (tree binfo,\n@@ -1649,8 +1563,8 @@ dfs_walk_real (tree binfo,\n   return rval;\n }\n \n-/* Exactly like bfs_walk, except that a depth-first post-order traversal is\n-   performed.  */\n+/* Exactly like dfs_walk_real, except that there is no pre-order\n+   function call and  FN is called in post-order.  */\n \n tree\n dfs_walk (tree binfo,"}, {"sha": "e543df5d392163058e8ee5f3d424d2d5ef02708d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf447dbf18327c71263f9afff56905d2a86dc0d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf447dbf18327c71263f9afff56905d2a86dc0d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5cf447dbf18327c71263f9afff56905d2a86dc0d", "patch": "@@ -1,3 +1,8 @@\n+2004-08-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/16889\n+\t* g++.dg/lookup/ambig3.C: New.\n+\n 2004-09-24  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/17624"}, {"sha": "7a0a8377a9168b4ad7bf6f5c4f0515dae8874b76", "filename": "gcc/testsuite/g++.dg/lookup/ambig3.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cf447dbf18327c71263f9afff56905d2a86dc0d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fambig3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cf447dbf18327c71263f9afff56905d2a86dc0d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fambig3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fambig3.C?ref=5cf447dbf18327c71263f9afff56905d2a86dc0d", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 23 Sep 2004 <nathan@codesourcery.com>\n+// Origin: Wolfgang Bangerth  <bangerth@dealii.org>\n+\n+// Follow on from Bug 16889:Undetected ambiguity.\n+\n+struct B { \n+  int f(); // { dg-error \"int B::f\" \"\" }\n+}; \n+ \n+struct B1 : virtual B {}; \n+struct B2 : B {};\n+struct B2_2 : B2 {};\n+struct BB : B1, B2_2 {}; \n+ \n+int i = BB().f();  // { dg-error \"ambiguous\" \"\" }"}]}