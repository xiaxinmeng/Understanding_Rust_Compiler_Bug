{"sha": "cde85594f0979f7295cc6c01d0211ad49f5ab08e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RlODU1OTRmMDk3OWY3Mjk1Y2M2YzAxZDAyMTFhZDQ5ZjVhYjA4ZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2003-10-18T07:39:56Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2003-10-18T07:39:56Z"}, "message": "sparc.c (function_arg_record_value_1): New fourth parameter packed_p.\n\n\t* config/sparc/sparc.c (function_arg_record_value_1): New fourth\n\tparameter packed_p.  Search for a DECL_PACKED field only if\n\tpacked_p is false.  Pass packed_p recursively.\n\t(function_arg_record_value_2): Likewise.\n\t(function_arg_record_value): Update calls to\n\tfunction_arg_record_value_1 and function_arg_record_value_2.\n\nFrom-SVN: r72636", "tree": {"sha": "bb3e55c951331a37ccbaf2af45da3204b9d2b4b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb3e55c951331a37ccbaf2af45da3204b9d2b4b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cde85594f0979f7295cc6c01d0211ad49f5ab08e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde85594f0979f7295cc6c01d0211ad49f5ab08e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cde85594f0979f7295cc6c01d0211ad49f5ab08e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde85594f0979f7295cc6c01d0211ad49f5ab08e/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9d8de1de895cbaae3122dc0d9ab0079926dfb15c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d8de1de895cbaae3122dc0d9ab0079926dfb15c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d8de1de895cbaae3122dc0d9ab0079926dfb15c"}], "stats": {"total": 80, "additions": 48, "deletions": 32}, "files": [{"sha": "d451f0b4005bb989d3ef09a1707be7a88e16d85c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde85594f0979f7295cc6c01d0211ad49f5ab08e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde85594f0979f7295cc6c01d0211ad49f5ab08e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cde85594f0979f7295cc6c01d0211ad49f5ab08e", "patch": "@@ -1,3 +1,12 @@\n+2003-10-18  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* config/sparc/sparc.c (function_arg_record_value_1): New fourth\n+\tparameter packed_p.  Search for a DECL_PACKED field only if\n+\tpacked_p is false.  Pass packed_p recursively.\n+\t(function_arg_record_value_2): Likewise.\n+\t(function_arg_record_value): Update calls to\n+\tfunction_arg_record_value_1 and function_arg_record_value_2.\n+\n 2003-10-18  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* cse.c (cse_insn) [src_folded]: Check that the tentative replacement"}, {"sha": "82244d8daba0a5cbc9487b2d06b7fec930f2f158", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cde85594f0979f7295cc6c01d0211ad49f5ab08e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cde85594f0979f7295cc6c01d0211ad49f5ab08e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=cde85594f0979f7295cc6c01d0211ad49f5ab08e", "patch": "@@ -4910,37 +4910,37 @@ struct function_arg_record_value_parms\n static void function_arg_record_value_3\n  (HOST_WIDE_INT, struct function_arg_record_value_parms *);\n static void function_arg_record_value_2\n- (tree, HOST_WIDE_INT, struct function_arg_record_value_parms *);\n+ (tree, HOST_WIDE_INT, struct function_arg_record_value_parms *, bool);\n static void function_arg_record_value_1\n- (tree, HOST_WIDE_INT, struct function_arg_record_value_parms *);\n+ (tree, HOST_WIDE_INT, struct function_arg_record_value_parms *, bool);\n static rtx function_arg_record_value (tree, enum machine_mode, int, int, int);\n \n /* A subroutine of function_arg_record_value.  Traverse the structure\n    recursively and determine how many registers will be required.  */\n \n static void\n function_arg_record_value_1 (tree type, HOST_WIDE_INT startbitpos,\n-\t\t\t     struct function_arg_record_value_parms *parms)\n+\t\t\t     struct function_arg_record_value_parms *parms,\n+\t\t\t     bool packed_p)\n {\n   tree field;\n \n-  /* The ABI obviously doesn't specify how packed structures are\n-     passed.  These are defined to be passed in int regs if possible,\n-     otherwise memory.  */\n-  int packed_p = 0;\n-\n   /* We need to compute how many registers are needed so we can\n      allocate the PARALLEL but before we can do that we need to know\n-     whether there are any packed fields.  If there are, int regs are\n-     used regardless of whether there are fp values present.  */\n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-    {\n-      if (TREE_CODE (field) == FIELD_DECL && DECL_PACKED (field))\n-\t{\n-\t  packed_p = 1;\n-\t  break;\n-\t}\n-    }\n+     whether there are any packed fields.  The ABI obviously doesn't\n+     specify how structures are passed in this case, so they are\n+     defined to be passed in int regs if possible, otherwise memory,\n+     regardless of whether there are fp values present.  */\n+\n+  if (! packed_p)\n+    for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      {\n+\tif (TREE_CODE (field) == FIELD_DECL && DECL_PACKED (field))\n+\t  {\n+\t    packed_p = true;\n+\t    break;\n+\t  }\n+      }\n \n   /* Compute how many registers we need.  */\n   for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n@@ -4956,7 +4956,10 @@ function_arg_record_value_1 (tree type, HOST_WIDE_INT startbitpos,\n \t  /* ??? FIXME: else assume zero offset.  */\n \n \t  if (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n-\t    function_arg_record_value_1 (TREE_TYPE (field), bitpos, parms);\n+\t    function_arg_record_value_1 (TREE_TYPE (field),\n+\t    \t\t\t\t bitpos,\n+\t\t\t\t\t parms,\n+\t\t\t\t\t packed_p);\n \t  else if ((TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n \t\t    || (TREE_CODE (TREE_TYPE (field)) == COMPLEX_TYPE\n \t\t\t&& (TREE_CODE (TREE_TYPE (TREE_TYPE (field)))\n@@ -5062,19 +5065,20 @@ function_arg_record_value_3 (HOST_WIDE_INT bitpos,\n \n static void\n function_arg_record_value_2 (tree type, HOST_WIDE_INT startbitpos,\n-\t\t\t     struct function_arg_record_value_parms *parms)\n+\t\t\t     struct function_arg_record_value_parms *parms,\n+\t\t\t     bool packed_p)\n {\n   tree field;\n-  int packed_p = 0;\n \n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-    {\n-      if (TREE_CODE (field) == FIELD_DECL && DECL_PACKED (field))\n-\t{\n-\t  packed_p = 1;\n-\t  break;\n-\t}\n-    }\n+  if (! packed_p)\n+    for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      {\n+\tif (TREE_CODE (field) == FIELD_DECL && DECL_PACKED (field))\n+\t  {\n+\t    packed_p = true;\n+\t    break;\n+\t  }\n+      }\n \n   for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n     {\n@@ -5089,7 +5093,10 @@ function_arg_record_value_2 (tree type, HOST_WIDE_INT startbitpos,\n \t  /* ??? FIXME: else assume zero offset.  */\n \n \t  if (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n-\t    function_arg_record_value_2 (TREE_TYPE (field), bitpos, parms);\n+\t    function_arg_record_value_2 (TREE_TYPE (field),\n+\t    \t\t\t\t bitpos,\n+\t\t\t\t\t parms,\n+\t\t\t\t\t packed_p);\n \t  else if ((TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n \t\t    || (TREE_CODE (TREE_TYPE (field)) == COMPLEX_TYPE\n \t\t\t&& (TREE_CODE (TREE_TYPE (TREE_TYPE (field)))\n@@ -5170,7 +5177,7 @@ function_arg_record_value (tree type, enum machine_mode mode,\n   /* Compute how many registers we need.  */\n   parms.nregs = 0;\n   parms.intoffset = 0;\n-  function_arg_record_value_1 (type, 0, &parms);\n+  function_arg_record_value_1 (type, 0, &parms, false);\n \n   if (parms.intoffset != -1)\n     {\n@@ -5232,7 +5239,7 @@ function_arg_record_value (tree type, enum machine_mode mode,\n   /* Fill in the entries.  */\n   parms.nregs = 0;\n   parms.intoffset = 0;\n-  function_arg_record_value_2 (type, 0, &parms);\n+  function_arg_record_value_2 (type, 0, &parms, false);\n   function_arg_record_value_3 (typesize * BITS_PER_UNIT, &parms);\n \n   if (parms.nregs != nregs)"}]}