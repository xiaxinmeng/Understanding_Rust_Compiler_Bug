{"sha": "533ab6c4c88206b3ea5fadca9894ddd3c8113ac8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMzYWI2YzRjODgyMDZiM2VhNWZhZGNhOTg5NGRkZDNjODExM2FjOA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-06-01T12:38:48Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-06-01T12:38:48Z"}, "message": "Change use to type-based pool allocator in sh.c.\n\n\t* config/sh/sh.c (add_constant):Use new type-based pool allocator.\n\t(sh_reorg) Likewise.\n\nFrom-SVN: r223951", "tree": {"sha": "82f378af8c97fd9d2f810acfd75bfa2e5cd9e779", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82f378af8c97fd9d2f810acfd75bfa2e5cd9e779"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/533ab6c4c88206b3ea5fadca9894ddd3c8113ac8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533ab6c4c88206b3ea5fadca9894ddd3c8113ac8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/533ab6c4c88206b3ea5fadca9894ddd3c8113ac8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533ab6c4c88206b3ea5fadca9894ddd3c8113ac8/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ac0539d7ac678bb4f7adbebb2e69ee96edf84523", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac0539d7ac678bb4f7adbebb2e69ee96edf84523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac0539d7ac678bb4f7adbebb2e69ee96edf84523"}], "stats": {"total": 35, "additions": 27, "deletions": 8}, "files": [{"sha": "cf39571caa605b5f0b07444eb98b510625458736", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533ab6c4c88206b3ea5fadca9894ddd3c8113ac8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533ab6c4c88206b3ea5fadca9894ddd3c8113ac8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=533ab6c4c88206b3ea5fadca9894ddd3c8113ac8", "patch": "@@ -1,3 +1,8 @@\n+2015-06-01  Martin Liska  <mliska@suse.cz>\n+\n+\t* config/sh/sh.c (add_constant):Use new type-based pool allocator.\n+\t(sh_reorg) Likewise.\n+\n 2015-06-01  Martin Liska  <mliska@suse.cz>\n \n \t* cfg.c (initialize_original_copy_tables):Use new type-based pool allocator."}, {"sha": "285aa1808ed15512d1d32c4510baac2f9a13b1f1", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/533ab6c4c88206b3ea5fadca9894ddd3c8113ac8/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/533ab6c4c88206b3ea5fadca9894ddd3c8113ac8/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=533ab6c4c88206b3ea5fadca9894ddd3c8113ac8", "patch": "@@ -4648,14 +4648,31 @@ gen_datalabel_ref (rtx sym)\n }\n \n \f\n-static alloc_pool label_ref_list_pool;\n-\n typedef struct label_ref_list_d\n {\n   rtx_code_label *label;\n   struct label_ref_list_d *next;\n+\n+  /* Pool allocation new operator.  */\n+  inline void *operator new (size_t)\n+  {\n+    return pool.allocate ();\n+  }\n+\n+  /* Delete operator utilizing pool allocation.  */\n+  inline void operator delete (void *ptr)\n+  {\n+    pool.remove ((label_ref_list_d *) ptr);\n+  }\n+\n+  /* Memory allocation pool.  */\n+  static pool_allocator<label_ref_list_d> pool;\n+\n } *label_ref_list_t;\n \n+pool_allocator<label_ref_list_d> label_ref_list_d::pool\n+  (\"label references list\", 30);\n+\n /* The SH cannot load a large constant into a register, constants have to\n    come from a pc relative load.  The reference of a pc relative load\n    instruction must be less than 1k in front of the instruction.  This\n@@ -4775,7 +4792,7 @@ add_constant (rtx x, machine_mode mode, rtx last_value)\n \t\t}\n \t      if (lab && pool_window_label)\n \t\t{\n-\t\t  newref = (label_ref_list_t) pool_alloc (label_ref_list_pool);\n+\t\t  newref = new label_ref_list_d;\n \t\t  newref->label = pool_window_label;\n \t\t  ref = pool_vector[pool_window_last].wend;\n \t\t  newref->next = ref;\n@@ -4804,7 +4821,7 @@ add_constant (rtx x, machine_mode mode, rtx last_value)\n   pool_vector[pool_size].part_of_sequence_p = (lab == 0);\n   if (lab && pool_window_label)\n     {\n-      newref = (label_ref_list_t) pool_alloc (label_ref_list_pool);\n+      newref = new label_ref_list_d;\n       newref->label = pool_window_label;\n       ref = pool_vector[pool_window_last].wend;\n       newref->next = ref;\n@@ -6359,9 +6376,6 @@ sh_reorg (void)\n \n   /* Scan the function looking for move instructions which have to be\n      changed to pc-relative loads and insert the literal tables.  */\n-  label_ref_list_pool = create_alloc_pool (\"label references list\",\n-\t\t\t\t\t   sizeof (struct label_ref_list_d),\n-\t\t\t\t\t   30);\n   mdep_reorg_phase = SH_FIXUP_PCLOAD;\n   for (insn = first, num_mova = 0; insn; insn = NEXT_INSN (insn))\n     {\n@@ -6553,7 +6567,7 @@ sh_reorg (void)\n \t  insn = barrier;\n \t}\n     }\n-  free_alloc_pool (label_ref_list_pool);\n+  label_ref_list_d::pool.release ();\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     PUT_MODE (insn, VOIDmode);\n "}]}