{"sha": "3bf78d3be26e89446da009f5c5e562d8ba1a1179", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JmNzhkM2JlMjZlODk0NDZkYTAwOWY1YzVlNTYyZDhiYTFhMTE3OQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-02-14T02:59:42Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-02-14T02:59:42Z"}, "message": "optabs.c (expand_abs): Don't call do_jump_by_parts_greater_rtx directly...\n\n\n\t* optabs.c (expand_abs): Don't call do_jump_by_parts_greater_rtx\n\tdirectly, instead let do_compare_rtx_and_jump handle this for us.\n\t* expr.c (expand_expr_real_1): Likewise.\n\t* dojump.c (do_jump_by_parts_greater_rtx): Make static.  Move\n\tbefore do_jump_by_parts_greater.\n\t(do_jump_by_parts_greater): Move after do_jump_by_parts_greater_rtx.\n\t* expr.h (do_jump_by_parts_greater_rtx): Delete prototype.\n\nFrom-SVN: r110954", "tree": {"sha": "ad6d3c452b2626d6643772b84fef9585f0dd5c22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad6d3c452b2626d6643772b84fef9585f0dd5c22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bf78d3be26e89446da009f5c5e562d8ba1a1179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bf78d3be26e89446da009f5c5e562d8ba1a1179", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bf78d3be26e89446da009f5c5e562d8ba1a1179", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bf78d3be26e89446da009f5c5e562d8ba1a1179/comments", "author": null, "committer": null, "parents": [{"sha": "0fe4610e618b184172ecaa49fb4729e7c349025c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fe4610e618b184172ecaa49fb4729e7c349025c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fe4610e618b184172ecaa49fb4729e7c349025c"}], "stats": {"total": 82, "additions": 33, "deletions": 49}, "files": [{"sha": "6ffd3321150b5e30c6b73ed94216de0a236057fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf78d3be26e89446da009f5c5e562d8ba1a1179/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf78d3be26e89446da009f5c5e562d8ba1a1179/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3bf78d3be26e89446da009f5c5e562d8ba1a1179", "patch": "@@ -1,3 +1,13 @@\n+2006-02-13  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* optabs.c (expand_abs): Don't call do_jump_by_parts_greater_rtx\n+\tdirectly, instead let do_compare_rtx_and_jump handle this for us.\n+\t* expr.c (expand_expr_real_1): Likewise.\n+\t* dojump.c (do_jump_by_parts_greater_rtx): Make static.  Move\n+\tbefore do_jump_by_parts_greater.\n+\t(do_jump_by_parts_greater): Move after do_jump_by_parts_greater_rtx.\n+\t* expr.h (do_jump_by_parts_greater_rtx): Delete prototype.\n+\n 2006-02-13  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* pa/quadlib.c: Use defines instead of enum qfcmp_magic."}, {"sha": "da162d676802c6a764293fb7bde2a9c7de12b763", "filename": "gcc/dojump.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf78d3be26e89446da009f5c5e562d8ba1a1179/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf78d3be26e89446da009f5c5e562d8ba1a1179/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=3bf78d3be26e89446da009f5c5e562d8ba1a1179", "patch": "@@ -609,29 +609,11 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n     }\n }\n \f\n-/* Given a comparison expression EXP for values too wide to be compared\n-   with one insn, test the comparison and jump to the appropriate label.\n-   The code of EXP is ignored; we always test GT if SWAP is 0,\n-   and LT if SWAP is 1.  */\n-\n-static void\n-do_jump_by_parts_greater (tree exp, int swap, rtx if_false_label,\n-\t\t\t  rtx if_true_label)\n-{\n-  rtx op0 = expand_normal (TREE_OPERAND (exp, swap));\n-  rtx op1 = expand_normal (TREE_OPERAND (exp, !swap));\n-  enum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0)));\n-\n-  do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label,\n-\t\t\t\tif_true_label);\n-}\n-\n /* Compare OP0 with OP1, word at a time, in mode MODE.\n    UNSIGNEDP says to do unsigned comparison.\n    Jump to IF_TRUE_LABEL if OP0 is greater, IF_FALSE_LABEL otherwise.  */\n \n-void\n+static void\n do_jump_by_parts_greater_rtx (enum machine_mode mode, int unsignedp, rtx op0,\n \t\t\t      rtx op1, rtx if_false_label, rtx if_true_label)\n {\n@@ -677,6 +659,24 @@ do_jump_by_parts_greater_rtx (enum machine_mode mode, int unsignedp, rtx op0,\n   if (drop_through_label)\n     emit_label (drop_through_label);\n }\n+\n+/* Given a comparison expression EXP for values too wide to be compared\n+   with one insn, test the comparison and jump to the appropriate label.\n+   The code of EXP is ignored; we always test GT if SWAP is 0,\n+   and LT if SWAP is 1.  */\n+\n+static void\n+do_jump_by_parts_greater (tree exp, int swap, rtx if_false_label,\n+\t\t\t  rtx if_true_label)\n+{\n+  rtx op0 = expand_normal (TREE_OPERAND (exp, swap));\n+  rtx op1 = expand_normal (TREE_OPERAND (exp, !swap));\n+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\n+  do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label,\n+\t\t\t\tif_true_label);\n+}\n \f\n /* Jump according to whether OP0 is 0.  We assume that OP0 has an integer\n    mode, MODE, that is too wide for the available compare insns.  Either"}, {"sha": "92d8d280758d0380adfc1a91277067af52e9765f", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf78d3be26e89446da009f5c5e562d8ba1a1179/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf78d3be26e89446da009f5c5e562d8ba1a1179/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3bf78d3be26e89446da009f5c5e562d8ba1a1179", "patch": "@@ -8184,24 +8184,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  emit_move_insn (target, op0);\n \n \ttemp = gen_label_rtx ();\n-\n-\t/* If this mode is an integer too wide to compare properly,\n-\t   compare word by word.  Rely on cse to optimize constant cases.  */\n-\tif (GET_MODE_CLASS (mode) == MODE_INT\n-\t    && ! can_compare_p (GE, mode, ccp_jump))\n-\t  {\n-\t    if (code == MAX_EXPR)\n-\t      do_jump_by_parts_greater_rtx (mode, unsignedp, target, op1,\n-\t\t\t\t\t    NULL_RTX, temp);\n-\t    else\n-\t      do_jump_by_parts_greater_rtx (mode, unsignedp, op1, target,\n-\t\t\t\t\t    NULL_RTX, temp);\n-\t  }\n-\telse\n-\t  {\n-\t    do_compare_rtx_and_jump (target, cmpop1, comparison_code,\n-\t\t\t\t     unsignedp, mode, NULL_RTX, NULL_RTX, temp);\n-\t  }\n+\tdo_compare_rtx_and_jump (target, cmpop1, comparison_code,\n+\t\t\t\t unsignedp, mode, NULL_RTX, NULL_RTX, temp);\n       }\n       emit_move_insn (target, op1);\n       emit_label (temp);"}, {"sha": "d52d57a9741791b0c952e2c05a9cae37683f230a", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf78d3be26e89446da009f5c5e562d8ba1a1179/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf78d3be26e89446da009f5c5e562d8ba1a1179/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=3bf78d3be26e89446da009f5c5e562d8ba1a1179", "patch": "@@ -743,9 +743,6 @@ extern void init_all_optabs (void);\n /* Call this to initialize an optab function entry.  */\n extern rtx init_one_libfunc (const char *);\n \n-extern void do_jump_by_parts_greater_rtx (enum machine_mode, int, rtx, rtx,\n-\t\t\t\t\t  rtx, rtx);\n-\n extern int vector_mode_valid_p (enum machine_mode);\n \n #endif /* GCC_EXPR_H */"}, {"sha": "0ab8406d3ec3fe34a5f2daee6c3a4afbb34567eb", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf78d3be26e89446da009f5c5e562d8ba1a1179/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf78d3be26e89446da009f5c5e562d8ba1a1179/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=3bf78d3be26e89446da009f5c5e562d8ba1a1179", "patch": "@@ -2898,15 +2898,8 @@ expand_abs (enum machine_mode mode, rtx op0, rtx target,\n   emit_move_insn (target, op0);\n   NO_DEFER_POP;\n \n-  /* If this mode is an integer too wide to compare properly,\n-     compare word by word.  Rely on CSE to optimize constant cases.  */\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n-      && ! can_compare_p (GE, mode, ccp_jump))\n-    do_jump_by_parts_greater_rtx (mode, 0, target, const0_rtx,\n-\t\t\t\t  NULL_RTX, op1);\n-  else\n-    do_compare_rtx_and_jump (target, CONST0_RTX (mode), GE, 0, mode,\n-\t\t\t     NULL_RTX, NULL_RTX, op1);\n+  do_compare_rtx_and_jump (target, CONST0_RTX (mode), GE, 0, mode,\n+\t\t\t   NULL_RTX, NULL_RTX, op1);\n \n   op0 = expand_unop (mode, result_unsignedp ? neg_optab : negv_optab,\n                      target, target, 0);"}]}