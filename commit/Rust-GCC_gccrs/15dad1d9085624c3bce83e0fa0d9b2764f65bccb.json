{"sha": "15dad1d9085624c3bce83e0fa0d9b2764f65bccb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVkYWQxZDkwODU2MjRjM2JjZTgzZTBmYTBkOWIyNzY0ZjY1YmNjYg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-05-18T15:55:46Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-05-18T15:55:46Z"}, "message": "cppexp.c (parse_assertion): New.\n\n\t* cppexp.c (parse_assertion): New.\n\t(lex): Call it for CPP_HASH.  Remove CPP_ASSERTION case.\n\t(_cpp_parse_expr): Remove case '#'.  Don't set\n\tparsing_if_directive.\n\t* cpphash.c (collect_objlike_expansion,\n\tcollect_funlike_expansion, collect_params,\n\t_cpp_create_definition): The list no longer has a trailing\n\tVSPACE token.\n\t* cpphash.h (enum node_type): Add T_ASSERTION.\n\t(struct hashnode): Remove aschain, add pred.\n\t(struct predicate): New.\n\tUpdate prototypes.\n\n\t* cpplex.c (expand_token_space): Handle both offset and\n\tnonoffset lists.\n\t(init_token_list, _cpp_free_token_list, _cpp_parse_assertion): Delete.\n\t(_cpp_init_toklist, _cpp_clear_toklist, _cpp_free_toklist,\n\t_cpp_slice_toklist, _cpp_squeeze_toklist, _cpp_equiv_tokens,\n\t_cpp_equiv_toklists): New.\n\t(_cpp_scan_line): Rename to _cpp_scan_until; add ability to\n\tstop at any single-character token, not just newline.\n\t(_cpp_lex_token): Remove special cases for #define and #if.\n\t(cpp_get_token): Expect # as a separate token type.  Remove\n\tDIRECTIVE case.\n\t(_cpp_get_directive_token): Remove DIRECTIVE case.\n\t(_cpp_lex_line, _cpp_lex_file, _cpp_init_input_buffer): Update.\n\n\t* cpplib.c (_cpp_check_directive): Set dirno and\n\tSYNTAX_INCLUDE bit of flags, not dir_handler and dir_flags.\n\t(_cpp_handle_directive): Run # <number> through the same logic\n\tas normal directives.\n\t(do_define): Don't set parsing_define_directive.  Use\n\t_cpp_scan_until.  The list does not have a VSPACE at the end.\n\t(do_if): Save, clear, and restore only_seen_white around\n\t_cpp_parse_expr.\n\t(skip_if_group): s/CPP_DIRECTIVE/CPP_HASH/\n\t(do_assert, do_unassert): Rewrite.\n\n\t* cpplib.h (TTYPE_TABLE): Remove CPP_ASSERTION.\n\t(LIST_OFFSET): New flag.\n\t(struct cpp_toklist): Replace dir_handler and dir_flags with\n\tdirno and flags.\n\t(struct cpp_reader): Remove parsing_if_directive and\n\tparsing_define_directive.\n\nFrom-SVN: r33984", "tree": {"sha": "eae8b6ec3c589f4957c72e8c82be5c3cc2ea4bbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eae8b6ec3c589f4957c72e8c82be5c3cc2ea4bbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15dad1d9085624c3bce83e0fa0d9b2764f65bccb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15dad1d9085624c3bce83e0fa0d9b2764f65bccb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15dad1d9085624c3bce83e0fa0d9b2764f65bccb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/comments", "author": null, "committer": null, "parents": [{"sha": "7021bb50d4366bf1630d5a685704d0118b06621a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7021bb50d4366bf1630d5a685704d0118b06621a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7021bb50d4366bf1630d5a685704d0118b06621a"}], "stats": {"total": 894, "additions": 552, "deletions": 342}, "files": [{"sha": "66fdc617a77b7afd193a0bfa10a4e5d26e61cc0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15dad1d9085624c3bce83e0fa0d9b2764f65bccb", "patch": "@@ -1,3 +1,50 @@\n+2000-05-18  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppexp.c (parse_assertion): New.\n+\t(lex): Call it for CPP_HASH.  Remove CPP_ASSERTION case.\n+\t(_cpp_parse_expr): Remove case '#'.  Don't set\n+\tparsing_if_directive.\n+\t* cpphash.c (collect_objlike_expansion,\n+\tcollect_funlike_expansion, collect_params,\n+\t_cpp_create_definition): The list no longer has a trailing\n+\tVSPACE token.\n+\t* cpphash.h (enum node_type): Add T_ASSERTION.\n+\t(struct hashnode): Remove aschain, add pred.\n+\t(struct predicate): New.\n+\tUpdate prototypes.\n+\n+\t* cpplex.c (expand_token_space): Handle both offset and\n+\tnonoffset lists.\n+\t(init_token_list, _cpp_free_token_list, _cpp_parse_assertion): Delete.\n+\t(_cpp_init_toklist, _cpp_clear_toklist, _cpp_free_toklist,\n+\t_cpp_slice_toklist, _cpp_squeeze_toklist, _cpp_equiv_tokens,\n+\t_cpp_equiv_toklists): New.\n+\t(_cpp_scan_line): Rename to _cpp_scan_until; add ability to\n+\tstop at any single-character token, not just newline.\n+\t(_cpp_lex_token): Remove special cases for #define and #if.\n+\t(cpp_get_token): Expect # as a separate token type.  Remove\n+\tDIRECTIVE case.\n+\t(_cpp_get_directive_token): Remove DIRECTIVE case.\n+\t(_cpp_lex_line, _cpp_lex_file, _cpp_init_input_buffer): Update.\n+\n+\t* cpplib.c (_cpp_check_directive): Set dirno and\n+\tSYNTAX_INCLUDE bit of flags, not dir_handler and dir_flags.\n+\t(_cpp_handle_directive): Run # <number> through the same logic\n+\tas normal directives.\n+\t(do_define): Don't set parsing_define_directive.  Use\n+\t_cpp_scan_until.  The list does not have a VSPACE at the end.\n+\t(do_if): Save, clear, and restore only_seen_white around \n+\t_cpp_parse_expr.\n+\t(skip_if_group): s/CPP_DIRECTIVE/CPP_HASH/\n+\t(do_assert, do_unassert): Rewrite.\n+\n+\t* cpplib.h (TTYPE_TABLE): Remove CPP_ASSERTION.\n+\t(LIST_OFFSET): New flag.\n+\t(struct cpp_toklist): Replace dir_handler and dir_flags with\n+\tdirno and flags.\n+\t(struct cpp_reader): Remove parsing_if_directive and\n+\tparsing_define_directive.\n+\n 2000-05-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* fixinc/inclhack.def (broken_cabs): Update fix to handle comments"}, {"sha": "4e6191504871265647504b84a135d66fa79cd3f2", "filename": "gcc/cppexp.c", "status": "modified", "additions": 87, "deletions": 21, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=15dad1d9085624c3bce83e0fa0d9b2764f65bccb", "patch": "@@ -82,6 +82,7 @@ static struct operation parse_number PARAMS ((cpp_reader *, U_CHAR *,\n static struct operation parse_charconst PARAMS ((cpp_reader *, U_CHAR *,\n \t\t\t\t\t\t U_CHAR *));\n static struct operation parse_defined PARAMS ((cpp_reader *));\n+static struct operation parse_assertion PARAMS ((cpp_reader *));\n static HOST_WIDEST_INT parse_escape PARAMS ((cpp_reader *, U_CHAR **,\n \t\t\t\t\t     HOST_WIDEST_INT));\n static struct operation lex PARAMS ((cpp_reader *, int));\n@@ -110,6 +111,15 @@ struct operation\n   HOST_WIDEST_INT value; /* The value logically \"right\" of op.  */\n };\n \n+/* With -O2, gcc appears to produce nice code, moving the error\n+   message load and subsequent jump completely out of the main path.  */\n+#define CPP_ICE(msgid) \\\n+  do { cpp_ice (pfile, msgid); goto syntax_error; } while(0)\n+#define SYNTAX_ERROR(msgid) \\\n+  do { cpp_error (pfile, msgid); goto syntax_error; } while(0)\n+#define SYNTAX_ERROR2(msgid, arg) \\\n+  do { cpp_error (pfile, msgid, arg); goto syntax_error; } while(0)\n+\n /* Parse and convert an integer for #if.  Accepts decimal, hex, or octal\n    with or without size suffixes.  */\n \n@@ -379,6 +389,81 @@ parse_defined (pfile)\n   return op;\n }\n \n+static struct operation\n+parse_assertion (pfile)\n+     cpp_reader *pfile;\n+{\n+  struct operation op;\n+  HASHNODE *hp;\n+  struct predicate *pred;\n+  cpp_toklist query;\n+  enum cpp_ttype type;\n+  U_CHAR *tok;\n+  size_t len;\n+  unsigned int old_written;\n+  int specific = 0;\n+\n+  old_written = CPP_WRITTEN (pfile);\n+  CPP_PUTC (pfile, '#');\n+  pfile->no_macro_expand++;\n+  type = _cpp_get_directive_token (pfile);\n+  if (type == CPP_VSPACE)\n+    SYNTAX_ERROR (\"assertion without predicate\");\n+  else if (type != CPP_NAME)\n+    SYNTAX_ERROR (\"assertion predicate is not an identifier\");\n+\n+  tok = pfile->token_buffer + old_written;\n+  len = CPP_WRITTEN (pfile) - old_written;\n+  hp = _cpp_lookup (pfile, tok, len);\n+\n+  /* Look ahead for an open paren.  */\n+  _cpp_skip_hspace (pfile);\n+  if (CPP_BUF_PEEK (CPP_BUFFER (pfile)) == '(')\n+    {\n+      if (_cpp_get_directive_token (pfile) != CPP_OPEN_PAREN)\n+\tCPP_ICE (\"impossible token, expecting ( in parse_assertion\");\n+\n+      _cpp_init_toklist (&query);\n+      specific = 1;\n+      if (_cpp_scan_until (pfile, &query, CPP_CLOSE_PAREN) != CPP_CLOSE_PAREN)\n+\tSYNTAX_ERROR (\"missing close paren on assertion answer\");\n+\n+      if (_cpp_get_directive_token (pfile) != CPP_CLOSE_PAREN)\n+\tCPP_ICE (\"impossible token, expecting ) in parse_assertion\");\n+    }\n+\n+  /* If we get here, the syntax is valid.  */\n+  op.op = INT;\n+  op.value = 0;\n+  /* Has this predicate been asserted at all?  */\n+  if (hp->type == T_ASSERTION)\n+    {\n+      if (specific)\n+\t{\n+\t  for (pred = hp->value.pred; pred; pred = pred->next)\n+\t    if (_cpp_equiv_toklists (&query, &pred->answer))\n+\t      {\n+\t\top.value = 1;\n+\t\tbreak;\n+\t      }\n+\t  _cpp_free_toklist (&query);\n+\t}\n+      else\n+\top.value = 1;\n+    }\n+\n+ out:\n+  pfile->no_macro_expand--;\n+  CPP_SET_WRITTEN (pfile, old_written);\n+  return op;\n+\n+ syntax_error:\n+  if (specific)\n+    _cpp_free_toklist (&query);\n+  op.op = ERROR;\n+  goto out;\n+}\n+\n struct token\n {\n   const char *operator;\n@@ -451,11 +536,8 @@ lex (pfile, skip_evaluation)\n \t\t     (int) (tok_end - tok_start), tok_start);\n       return op;\n \n-    case CPP_ASSERTION:\n-      op.op = INT;\n-      op.unsignedp = 0;\n-      op.value = cpp_defined (pfile, tok_start, tok_end - tok_start);\n-      return op;\n+    case CPP_HASH:\n+      return parse_assertion (pfile);\n \n     case CPP_OTHER:\n       /* See if it is a special token of length 2.  */\n@@ -734,15 +816,6 @@ be handled with operator-specific code.  */\n   top->value = v1 OP v2; \\\n   top->unsignedp = unsigned1 | unsigned2;\n \n-/* With -O2, gcc appears to produce nice code, moving the error\n-   message load and subsequent jump completely out of the main path.  */\n-#define CPP_ICE(msgid) \\\n-  do { cpp_ice (pfile, msgid); goto syntax_error; } while(0)\n-#define SYNTAX_ERROR(msgid) \\\n-  do { cpp_error (pfile, msgid); goto syntax_error; } while(0)\n-#define SYNTAX_ERROR2(msgid, arg) \\\n-  do { cpp_error (pfile, msgid, arg); goto syntax_error; } while(0)\n-\n /* Parse and evaluate a C expression, reading from PFILE.\n    Returns the truth value of the expression.  */\n \n@@ -770,7 +843,6 @@ _cpp_parse_expr (pfile)\n   int result;\n   char buff[5];\n \n-  pfile->parsing_if_directive++;\n   /* We've finished when we try to reduce this.  */\n   top->op = FINISHED;\n   /* Nifty way to catch missing '('.  */\n@@ -796,11 +868,6 @@ _cpp_parse_expr (pfile)\n \t  CPP_ICE (\"lex returns a NAME\");\n \tcase ERROR:\n \t  goto syntax_error;\n-\tcase '#':\n-\t  /* We get '#' when get_directive_token hits a syntactically\n-\t     invalid assertion predicate.  _cpp_parse_assertion has\n-\t     already issued an error.  */\n-\t  goto syntax_error;\n \tdefault:\n \t  SYNTAX_ERROR (\"invalid character in #if\");\n \n@@ -1094,7 +1161,6 @@ _cpp_parse_expr (pfile)\n   /* Free dynamic stack if we allocated one.  */\n   if (stack != init_stack)\n     free (stack);\n-  pfile->parsing_if_directive--;\n   CPP_SET_WRITTEN (pfile, old_written);\n   return result;\n }"}, {"sha": "3eb7d1a0e7a259e7e0baf42631a95964aa332e7f", "filename": "gcc/cpphash.c", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=15dad1d9085624c3bce83e0fa0d9b2764f65bccb", "patch": "@@ -480,12 +480,6 @@ collect_objlike_expansion (pfile, list)\n     {\n       switch (TOK_TYPE (list, i))\n \t{\n-\tcase CPP_EOF:\n-\t  cpp_ice (pfile, \"EOF in collect_expansion\");\n-\t  /* fall through */\n-\tcase CPP_VSPACE:\n-\t  goto done;\n-\n \tcase CPP_PASTE:\n \t  /* ## is not special if it appears right after another ##;\n \t     nor is it special if -traditional.  */\n@@ -506,7 +500,6 @@ collect_objlike_expansion (pfile, list)\n       CPP_PUTS (pfile, TOK_NAME (list, i), TOK_LEN (list, i));\n       last_was_paste = 0;\n     }\n- done:\n \n   if (last_was_paste)\n     cpp_error (pfile, \"`##' at end of macro definition\");\n@@ -568,12 +561,6 @@ collect_funlike_expansion (pfile, list, arglist, replacement)\n       len = TOK_LEN (list, i);\n       switch (token)\n \t{\n-\tcase CPP_EOF:\n-\t  cpp_ice (pfile, \"EOF in collect_expansion\");\n-\t  /* fall through */\n-\tcase CPP_VSPACE:\n-\t  goto done;\n-\n \tcase CPP_HASH:\n \t  /* # is special in function-like macros with no args.\n \t     (6.10.3.2 para 1.)  However, it is not special after\n@@ -677,7 +664,6 @@ collect_funlike_expansion (pfile, list, arglist, replacement)\n       }\n       last_token = ARG;\n     }\n- done:\n \n   if (last_token == STRIZE)\n     cpp_error (pfile, \"`#' is not followed by a macro argument name\");\n@@ -759,8 +745,8 @@ collect_params (pfile, list, arglist)\n       case CPP_CLOSE_PAREN:\n \tgoto scanned;\n       case CPP_VSPACE:\n-\tcpp_error_with_line (pfile, list->line, TOK_COL (list, i),\n-\t\t\t     \"missing right paren in macro argument list\");\n+      case CPP_EOF:\n+\tcpp_ice (pfile, \"impossible token in macro argument list\");\n \treturn 0;\n \n       default:\n@@ -783,9 +769,8 @@ collect_params (pfile, list, arglist)\n \t  }\n \tgoto scanned;\n       }\n-\n-  cpp_ice (pfile, \"collect_params: unreachable - i=%d, ntokens=%d, type=%d\",\n-\t   i, list->tokens_used, TOK_TYPE (list, i-1));\n+  cpp_error_with_line (pfile, list->line, TOK_COL (list, i-1),\n+\t\t       \"missing right paren in macro argument list\");\n   return 0;\n \n  scanned:\n@@ -892,9 +877,9 @@ _cpp_create_definition (pfile, list, hp)\n      #define FUNC(a, b, ...) // nothing\n      #define FUNC(a, b, c) FUNC(a, b, c)  */\n \n-  if (list->tokens_used == 2)\n+  if (list->tokens_used == 1)\n     ntype = T_EMPTY;    /* Empty definition of object-like macro.  */\n-  else if (list->tokens_used == 3 && TOK_TYPE (list, 1) == CPP_NAME\n+  else if (list->tokens_used == 2 && TOK_TYPE (list, 1) == CPP_NAME\n \t   && TOK_LEN (list, 0) == TOK_LEN (list, 1)\n \t   && !ustrncmp (TOK_NAME (list, 0), TOK_NAME (list, 1),\n \t\t\t TOK_LEN (list, 0)))"}, {"sha": "927927c03d3657128eea16dcf850a0f5851ac5b1", "filename": "gcc/cpphash.h", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=15dad1d9085624c3bce83e0fa0d9b2764f65bccb", "patch": "@@ -49,7 +49,8 @@ enum node_type\n   T_MACRO,\t   /* object-like macro */\n   T_FMACRO,\t   /* function-like macro */\n   T_IDENTITY,\t   /* macro defined to itself */\n-  T_EMPTY\t   /* macro defined to nothing */\n+  T_EMPTY,\t   /* macro defined to nothing */\n+  T_ASSERTION\t   /* predicate for #assert */\n };\n \n typedef struct hashnode HASHNODE;\n@@ -64,12 +65,19 @@ struct hashnode\n     const U_CHAR *cpval;\t\t/* some predefined macros */\n     const struct object_defn *odefn;\t/* #define foo bar */\n     const struct funct_defn *fdefn;\t/* #define foo(x) bar(x) */\n-    struct hashnode *aschain;\t\t/* #assert */\n+    struct predicate *pred;\t\t/* #assert */\n   } value;\n \n   const U_CHAR name[1];\t\t\t/* name[length] */\n };\n \n+/* Structure used for assertion predicates.  */\n+struct predicate\n+{\n+  struct predicate *next;\n+  struct cpp_toklist answer;\n+};\n+\n /* List of directories to look for include files in. */\n struct file_name_list\n {\n@@ -250,7 +258,20 @@ extern enum cpp_ttype _cpp_get_directive_token\n \t\t\t\t\tPARAMS ((cpp_reader *));\n extern enum cpp_ttype _cpp_get_define_token\n \t\t\t\t\tPARAMS ((cpp_reader *));\n-extern void _cpp_scan_line\t\tPARAMS ((cpp_reader *, cpp_toklist *));\n+extern enum cpp_ttype _cpp_scan_until\tPARAMS ((cpp_reader *, cpp_toklist *,\n+\t\t\t\t\t\t enum cpp_ttype));\n+extern void _cpp_init_toklist\t\tPARAMS ((cpp_toklist *));\n+extern void _cpp_clear_toklist\t\tPARAMS ((cpp_toklist *));\n+extern void _cpp_free_toklist\t\tPARAMS ((cpp_toklist *));\n+extern void _cpp_slice_toklist\t\tPARAMS ((cpp_toklist *,\n+\t\t\t\t\t\t const cpp_token *,\n+\t\t\t\t\t\t const cpp_token *));\n+extern void _cpp_squeeze_toklist\tPARAMS ((cpp_toklist *));\n+extern int _cpp_equiv_tokens\t\tPARAMS ((const cpp_token *,\n+\t\t\t\t\t\t const cpp_token *));\n+extern int _cpp_equiv_toklists\t\tPARAMS ((const cpp_toklist *,\n+\t\t\t\t\t\t const cpp_toklist *));\n+\n \n /* In cpplib.c */\n extern int _cpp_handle_directive\tPARAMS ((cpp_reader *));"}, {"sha": "117f61039f341dec0780d73eb15cd60479549443", "filename": "gcc/cpplex.c", "status": "modified", "additions": 227, "deletions": 191, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=15dad1d9085624c3bce83e0fa0d9b2764f65bccb", "patch": "@@ -55,7 +55,6 @@ static void bump_column\t\tPARAMS ((cpp_printer *, unsigned int,\n \t\t\t\t\t unsigned int));\n static void expand_name_space   PARAMS ((cpp_toklist *, unsigned int));\n static void expand_token_space\tPARAMS ((cpp_toklist *));\n-static void init_token_list\tPARAMS ((cpp_reader *, cpp_toklist *, int));\n static void pedantic_whitespace\tPARAMS ((cpp_reader *, U_CHAR *,\n \t\t\t\t\t unsigned int));\n \n@@ -491,7 +490,7 @@ cpp_scan_buffer (pfile, print)\n   for (;;)\n     {\n       token = cpp_get_token (pfile);\n-      if (token == CPP_EOF || token == CPP_VSPACE\n+      if (token == CPP_VSPACE || token == CPP_EOF\n \t  /* XXX Temporary kluge - force flush after #include only */\n \t  || (token == CPP_DIRECTIVE\n \t      && CPP_BUFFER (pfile)->nominal_fname != print->last_fname))\n@@ -548,63 +547,212 @@ expand_token_space (list)\n      cpp_toklist *list;\n {\n   list->tokens_cap *= 2;\n+  if (list->flags & LIST_OFFSET)\n+    list->tokens--;\n   list->tokens = (cpp_token *)\n-    xrealloc (list->tokens - 1, (list->tokens_cap + 1) * sizeof (cpp_token));\n-  list->tokens++;\t\t/* Skip the dummy.  */\n+    xrealloc (list->tokens, (list->tokens_cap + 1) * sizeof (cpp_token));\n+  if (list->flags & LIST_OFFSET)\n+    list->tokens++;\t\t/* Skip the dummy.  */\n }\n \n /* Initialize a token list.  We allocate an extra token in front of\n    the token list, as this allows us to always peek at the previous\n    token without worrying about underflowing the list.  */\n-static void\n-init_token_list (pfile, list, recycle)\n-     cpp_reader *pfile;\n+void\n+_cpp_init_toklist (list)\n      cpp_toklist *list;\n-     int recycle;\n {\n-  /* Recycling a used list saves 3 free-malloc pairs.  */\n-  if (!recycle)\n-    {\n-      /* Initialize token space.  Put a dummy token before the start\n-         that will fail matches.  */\n-      list->tokens_cap = 256;\t/* 4K's worth.  */\n-      list->tokens = (cpp_token *)\n-\txmalloc ((list->tokens_cap + 1) * sizeof (cpp_token));\n-      list->tokens[0].type = CPP_EOF;\n-      list->tokens++;\n-\n-      /* Initialize name space.  */\n-      list->name_cap = 1024;\n-      list->namebuf = (unsigned char *) xmalloc (list->name_cap);\n-\n-      /* Only create a comment space on demand.  */\n-      list->comments_cap = 0;\n-      list->comments = 0;\n-    }\n+  /* Initialize token space.  Put a dummy token before the start\n+     that will fail matches.  */\n+  list->tokens_cap = 256;\t/* 4K's worth.  */\n+  list->tokens = (cpp_token *)\n+    xmalloc ((list->tokens_cap + 1) * sizeof (cpp_token));\n+  list->tokens[0].type = CPP_EOF;\n+  list->tokens++;\n+\n+  /* Initialize name space.  */\n+  list->name_cap = 1024;\n+  list->namebuf = (unsigned char *) xmalloc (list->name_cap);\n+\n+  /* Only create a comment space on demand.  */\n+  list->comments_cap = 0;\n+  list->comments = 0;\n+\n+  list->flags = LIST_OFFSET;\n+  _cpp_clear_toklist (list);\n+}\n \n+/* Clear a token list.  */\n+void\n+_cpp_clear_toklist (list)\n+     cpp_toklist *list;\n+{\n   list->tokens_used = 0;\n   list->name_used = 0;\n   list->comments_used = 0;\n-  if (pfile->buffer)\n-    list->line = pfile->buffer->lineno;\n-  list->dir_handler = 0;\n-  list->dir_flags = 0;\n+  list->dirno = -1;\n+  list->flags &= LIST_OFFSET;  /* clear all but that one */\n+}\n+\n+/* Free a token list.  Does not free the list itself, which may be\n+   embedded in a larger structure.  */\n+void\n+_cpp_free_toklist (list)\n+     cpp_toklist *list;\n+{\n+  if (list->comments)\n+    free (list->comments);\n+  if (list->flags & LIST_OFFSET)\n+    free (list->tokens - 1);\t/* Backup over dummy token.  */\n+  else\n+    free (list->tokens);\n+  free (list->namebuf);\n }\n \n-/* Scan an entire line and create a token list for it.  Does not\n-   macro-expand or execute directives.  */\n+/* Slice a token list: copy the sublist [START, FINISH) into COPY.\n+   COPY is assumed not to be initialized.  The comment space is not\n+   copied.  */\n+void\n+_cpp_slice_toklist (copy, start, finish)\n+     cpp_toklist *copy;\n+     const cpp_token *start, *finish;\n+{\n+  unsigned int i, n;\n+  size_t bytes;\n+\n+  n = finish - start;\n+  copy->tokens_cap = n;\n+  copy->tokens = (cpp_token *) xmalloc (n * sizeof (cpp_token));\n+  memcpy (copy->tokens, start, n * sizeof (cpp_token));\n+\n+  bytes = 0;\n+  for (i = 0; i < n; i++)\n+    if (token_spellings[start[i].type].type > SPELL_NONE)\n+      bytes += start[i].val.name.len;\n+\n+  copy->namebuf = xmalloc (bytes);\n+  bytes = 0;\n+  for (i = 0; i < n; i++)\n+    if (token_spellings[start[i].type].type > SPELL_NONE)\n+      {\n+\tmemcpy (copy->namebuf + bytes,\n+\t\tstart[i].val.name.text, start[i].val.name.len);\n+\tcopy->tokens[i].val.name.text = copy->namebuf + bytes;\n+\tbytes += start[i].val.name.len;\n+      }\n+\n+  copy->tokens_cap = n;\n+  copy->tokens_used = n;\n+  copy->name_used = bytes;\n+  copy->name_cap = bytes;\n+  copy->comments = 0;\n+  copy->comments_cap = 0;\n+  copy->comments_used = 0;\n+  \n+  copy->flags = 0;\n+  copy->dirno = -1;\n+}\n \n+/* Shrink a token list down to the minimum size.  */\n void\n-_cpp_scan_line (pfile, list)\n+_cpp_squeeze_toklist (list)\n+     cpp_toklist *list;\n+{\n+  long delta;\n+  const U_CHAR *old_namebuf;\n+\n+  if (list->flags & LIST_OFFSET)\n+    {\n+      list->tokens--;\n+      memmove (list->tokens, list->tokens + 1,\n+\t       list->tokens_used * sizeof (cpp_token));\n+      list->tokens = xrealloc (list->tokens,\n+\t\t\t       list->tokens_used * sizeof (cpp_token));\n+      list->flags &= ~LIST_OFFSET;\n+    }\n+  else\n+    list->tokens = xrealloc (list->tokens,\n+\t\t\t     list->tokens_used * sizeof (cpp_token));\n+  list->tokens_cap = list->tokens_used;\n+\n+  old_namebuf = list->namebuf;\n+  list->namebuf = xrealloc (list->namebuf, list->name_used);\n+  list->name_cap = list->name_used;\n+\n+  /* Fix up token text pointers.  */\n+  delta = list->namebuf - old_namebuf;\n+  if (delta)\n+    {\n+      unsigned int i;\n+\n+      for (i = 0; i < list->tokens_used; i++)\n+\tif (token_spellings[list->tokens[i].type].type > SPELL_NONE)\n+\t  list->tokens[i].val.name.text += delta;\n+    }\n+  \n+  if (list->comments_cap)\n+    {\n+      list->comments = xrealloc (list->comments,\n+\t\t\t\t list->comments_used * sizeof (cpp_token));\n+      list->comments_cap = list->comments_used;\n+    }\n+}\n+\n+/* Compare two tokens.  */\n+int\n+_cpp_equiv_tokens (a, b)\n+     const cpp_token *a, *b;\n+{\n+  if (a->type != b->type\n+      || a->flags != b->flags\n+      || a->aux != b->aux)\n+    return 0;\n+\n+  if (token_spellings[a->type].type > SPELL_NONE)\n+    {\n+      if (a->val.name.len != b->val.name.len\n+\t  || ustrncmp(a->val.name.text,\n+\t\t      b->val.name.text,\n+\t\t      a->val.name.len))\n+\treturn 0;\n+    }\n+  return 1;\n+}\n+\n+/* Compare two token lists.  */\n+int\n+_cpp_equiv_toklists (a, b)\n+     const cpp_toklist *a, *b;\n+{\n+  unsigned int i;\n+\n+  if (a->tokens_used != b->tokens_used)\n+    return 0;\n+\n+  for (i = 0; i < a->tokens_used; i++)\n+    if (! _cpp_equiv_tokens (&a->tokens[i], &b->tokens[i]))\n+      return 0;\n+  return 1;\n+}\n+\n+/* Scan until we encounter a token of type STOP or a newline, and\n+   create a token list for it.  Does not macro-expand or execute\n+   directives.  The final token is not included in the list or\n+   consumed from the input.  Returns the type of the token stopped at. */\n+\n+enum cpp_ttype\n+_cpp_scan_until (pfile, list, stop)\n      cpp_reader *pfile;\n      cpp_toklist *list;\n+     enum cpp_ttype stop;\n {\n   int i, col;\n   long written, len;\n   enum cpp_ttype type;\n   int space_before;\n \n-  init_token_list (pfile, list, 1);\n+  _cpp_clear_toklist (list);\n+  list->line = CPP_BUF_LINE (CPP_BUFFER (pfile));\n \n   written = CPP_WRITTEN (pfile);\n   i = 0;\n@@ -636,14 +784,14 @@ _cpp_scan_line (pfile, list)\n       if (type == CPP_MACRO)\n \ttype = CPP_NAME;\n \n+      if (type == CPP_VSPACE || type == stop)\n+\tbreak;\n+\n       list->tokens_used++;\n       TOK_TYPE  (list, i) = type;\n       TOK_COL   (list, i) = col;\n       TOK_FLAGS (list, i) = space_before ? PREV_WHITESPACE : 0;\n       \n-      if (type == CPP_VSPACE)\n-\tbreak;\n-\n       TOK_LEN (list, i) = len;\n       if (token_spellings[type].type > SPELL_NONE)\n \t{\n@@ -656,12 +804,14 @@ _cpp_scan_line (pfile, list)\n       i++;\n       space_before = 0;\n     }\n-  TOK_AUX (list, i) = CPP_BUFFER (pfile)->lineno + 1;\n \n-  /* XXX Temporary kluge: put back the newline.  */\n+  /* XXX Temporary kluge: put back the newline (or whatever).  */\n   FORWARD(-1);\n-}\n \n+  /* Don't consider the first token to have white before.  */\n+  TOK_FLAGS (list, 0) &= ~PREV_WHITESPACE;\n+  return type;\n+}\n \n /* Skip a C-style block comment.  We know it's a comment, and point is\n    at the second character of the starter.  */\n@@ -1060,85 +1210,6 @@ parse_string (pfile, c)\n       CPP_PUTC_Q (pfile, *start);\n }\n \n-/* Read an assertion into the token buffer, converting to\n-   canonical form: `#predicate(a n swe r)'  The next non-whitespace\n-   character to read should be the first letter of the predicate.\n-   Returns 0 for syntax error, 1 for bare predicate, 2 for predicate\n-   with answer (see callers for why). In case of 0, an error has been\n-   printed. */\n-int\n-_cpp_parse_assertion (pfile)\n-     cpp_reader *pfile;\n-{\n-  int c, dropwhite;\n-  _cpp_skip_hspace (pfile);\n-  c = PEEKC();\n-  if (c == '\\n')\n-    {\n-      cpp_error (pfile, \"assertion without predicate\");\n-      return 0;\n-    }\n-  else if (! is_idstart(c))\n-    {\n-      cpp_error (pfile, \"assertion predicate is not an identifier\");\n-      return 0;\n-    }\n-  CPP_PUTC(pfile, '#');\n-  FORWARD(1);\n-  _cpp_parse_name (pfile, c);\n-\n-  c = PEEKC();\n-  if (c != '(')\n-    {\n-      if (is_hspace(c) || c == '\\r')\n-\t_cpp_skip_hspace (pfile);\n-      c = PEEKC();\n-    }\n-  if (c != '(')\n-    return 1;\n-\n-  CPP_PUTC(pfile, '(');\n-  FORWARD(1);\n-  dropwhite = 1;\n-  while ((c = GETC()) != ')')\n-    {\n-      if (is_space(c))\n-\t{\n-\t  if (! dropwhite)\n-\t    {\n-\t      CPP_PUTC(pfile, ' ');\n-\t      dropwhite = 1;\n-\t    }\n-\t}\n-      else if (c == '\\n' || c == EOF)\n-\t{\n-\t  if (c == '\\n') FORWARD(-1);\n-\t  cpp_error (pfile, \"un-terminated assertion answer\");\n-\t  return 0;\n-\t}\n-      else if (c == '\\r')\n-\t/* \\r cannot be a macro escape here. */\n-\tCPP_BUMP_LINE (pfile);\n-      else\n-\t{\n-\t  CPP_PUTC (pfile, c);\n-\t  dropwhite = 0;\n-\t}\n-    }\n-\n-  if (pfile->limit[-1] == ' ')\n-    pfile->limit[-1] = ')';\n-  else if (pfile->limit[-1] == '(')\n-    {\n-      cpp_error (pfile, \"empty token sequence in assertion\");\n-      return 0;\n-    }\n-  else\n-    CPP_PUTC (pfile, ')');\n-\n-  return 2;\n-}\n-\n /* Get the next token, and add it to the text in pfile->token_buffer.\n    Return the kind of token we got.  */\n \n@@ -1176,11 +1247,7 @@ _cpp_lex_token (pfile)\n       if (!CPP_OPTION (pfile, discard_comments))\n \treturn CPP_COMMENT;\n       else if (CPP_TRADITIONAL (pfile))\n-\t{\n-\t  if (pfile->parsing_define_directive)\n-\t    return CPP_COMMENT;\n-\t  goto get_next;\n-\t}\n+\tgoto get_next;\n       else\n \t{\n \t  CPP_PUTC (pfile, c);\n@@ -1191,42 +1258,24 @@ _cpp_lex_token (pfile)\n       CPP_PUTC (pfile, c);\n \n     hash:\n-      if (pfile->parsing_if_directive)\n+      c2 = PEEKC ();\n+      if (c2 == '#')\n \t{\n-\t  CPP_ADJUST_WRITTEN (pfile, -1);\n-\t  if (_cpp_parse_assertion (pfile))\n-\t    return CPP_ASSERTION;\n-\t  return CPP_OTHER;\n+\t  FORWARD (1);\n+\t  CPP_PUTC (pfile, c2);\n+\t  return CPP_PASTE;\n \t}\n-\n-      if (pfile->parsing_define_directive)\n+      else if (c2 == '%' && PEEKN (1) == ':')\n \t{\n-\t  c2 = PEEKC ();\n-\t  if (c2 == '#')\n-\t    {\n-\t      FORWARD (1);\n-\t      CPP_PUTC (pfile, c2);\n-\t    }\n-\t  else if (c2 == '%' && PEEKN (1) == ':')\n-\t    {\n-\t      /* Digraph: \"%:\" == \"#\".  */\n-\t      FORWARD (1);\n-\t      CPP_RESERVE (pfile, 2);\n-\t      CPP_PUTC_Q (pfile, c2);\n-\t      CPP_PUTC_Q (pfile, GETC ());\n-\t    }\n-\t  else\n-\t    return CPP_HASH;\n-\n+\t  /* Digraph: \"%:\" == \"#\".  */\n+\t  FORWARD (1);\n+\t  CPP_RESERVE (pfile, 2);\n+\t  CPP_PUTC_Q (pfile, c2);\n+\t  CPP_PUTC_Q (pfile, GETC ());\n \t  return CPP_PASTE;\n \t}\n-\n-      if (!pfile->only_seen_white)\n-\treturn CPP_OTHER;\n-\n-      /* Remove the \"#\" or \"%:\" from the token buffer.  */\n-      CPP_ADJUST_WRITTEN (pfile, (c == '#' ? -1 : -2));\n-      return CPP_DIRECTIVE;\n+      else\n+\treturn CPP_HASH;\n \n     case '\\\"':\n     case '\\'':\n@@ -1697,13 +1746,22 @@ cpp_get_token (pfile)\n     case CPP_COMMENT:\n       return token;\n \n-    case CPP_DIRECTIVE:\n+    case CPP_HASH:\n       pfile->potential_control_macro = 0;\n+      if (!pfile->only_seen_white)\n+\treturn CPP_HASH;\n+      /* XXX shouldn't have to do this - remove the hash or %: from\n+\t the token buffer.  */\n+      if (CPP_PWRITTEN (pfile)[-1] == '#')\n+\tCPP_ADJUST_WRITTEN (pfile, -1);\n+      else\n+\tCPP_ADJUST_WRITTEN (pfile, -2);\n+\n       if (_cpp_handle_directive (pfile))\n-\treturn CPP_DIRECTIVE;\n+\treturn CPP_DIRECTIVE; \n       pfile->only_seen_white = 0;\n       CPP_PUTC (pfile, '#');\n-      return CPP_OTHER;\n+      return CPP_HASH;\n \n     case CPP_MACRO:\n       pfile->potential_control_macro = 0;\n@@ -1777,11 +1835,6 @@ _cpp_get_directive_token (pfile)\n       goto get_next;\n       return CPP_HSPACE;\n \n-    case CPP_DIRECTIVE:\n-      /* Don't execute the directive, but don't smash it to OTHER either.  */\n-      CPP_PUTC (pfile, '#');\n-      return CPP_DIRECTIVE;\n-\n     case CPP_MACRO:\n       if (! pfile->no_macro_expand\n \t  && maybe_macroexpand (pfile, old_written))\n@@ -2134,7 +2187,7 @@ _cpp_init_input_buffer (pfile)\n   U_CHAR *tmp;\n \n   init_chartab ();\n-  init_token_list (pfile, &pfile->directbuf, 0);\n+  _cpp_init_toklist (&pfile->directbuf);\n \n   /* Determine the appropriate size for the input buffer.  Normal C\n      source files are smaller than eight K.  */\n@@ -2294,17 +2347,6 @@ expand_comment_space (list)\n     }\n }\n \n-void\n-cpp_free_token_list (list)\n-     cpp_toklist *list;\n-{\n-  if (list->comments)\n-    free (list->comments);\n-  free (list->tokens - 1);\t/* Backup over dummy token.  */\n-  free (list->namebuf);\n-  free (list);\n-}\n-\n void\n init_trigraph_map ()\n {\n@@ -3175,7 +3217,7 @@ _cpp_lex_line (pfile, list)\n \t      break;\n \t    }\n \t  /* Is this the beginning of a header name?  */\n-\t  if (list->dir_flags & SYNTAX_INCLUDE)\n+\t  if (list->flags & SYNTAX_INCLUDE)\n \t    {\n \t      c = '>';\t/* Terminator.  */\n \t      cur_token->type = CPP_HEADER_NAME;\n@@ -3304,7 +3346,7 @@ _cpp_lex_line (pfile, list)\n      invalid directives in assembly source, we don't know where the\n      comments are, and # may introduce assembler pseudo-ops.  */\n \n-  if (IS_DIRECTIVE (list) && list->dir_handler == 0\n+  if (IS_DIRECTIVE (list) && list->dirno == -1\n       && list->tokens[1].type != CPP_VSPACE\n       && !CPP_OPTION (pfile, lang_asm))\n     cpp_error_with_line (pfile, list->line, list->tokens[1].col,\n@@ -3385,31 +3427,25 @@ void\n _cpp_lex_file (pfile)\n      cpp_reader* pfile;\n {\n-  int recycle;\n   cpp_toklist* list;\n \n   init_trigraph_map ();\n   list = (cpp_toklist *) xmalloc (sizeof (cpp_toklist));\n+  _cpp_init_toklist (list);\n \n-  for (recycle = 0; ;)\n+  for (;;)\n     {\n-      init_token_list (pfile, list, recycle);\n-      recycle = 1;\n-\n       _cpp_lex_line (pfile, list);\n       if (list->tokens[0].type == CPP_EOF)\n \tbreak;\n \n-      if (list->dir_handler)\n-\t{\n-\t  if (list->dir_handler (pfile))\n-\t    {\n-\t      list = (cpp_toklist *) xmalloc (sizeof (cpp_toklist));\n-\t      recycle = 0;\n-\t    }\n-\t}\n+#if 0\n+      if (list->dirno)\n+\t_cpp_handle_directive (pfile, list);\n       else\n+#endif\n \t_cpp_output_list (pfile, list);\n+      _cpp_clear_toklist (list);\n     }\n }\n "}, {"sha": "23b522c2b957e475ce32f26745d490da8ff725d1", "filename": "gcc/cpplib.c", "status": "modified", "additions": 152, "deletions": 93, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=15dad1d9085624c3bce83e0fa0d9b2764f65bccb", "patch": "@@ -160,14 +160,15 @@ _cpp_check_directive (list, token)\n   size_t len = token->val.name.len;\n   unsigned int i;\n \n-  list->dir_handler = 0;\n-  list->dir_flags = 0;\n+  list->dirno = -1;\n+  list->flags &= ~SYNTAX_INCLUDE;\n \n   for (i = 0; i < N_DIRECTIVES; i++)\n     if (dtable[i].length == len && !ustrncmp (dtable[i].name, name, len)) \n       {\n-\tlist->dir_handler = dtable[i].func;\n-\tlist->dir_flags = dtable[i].flags;\n+\tlist->dirno = i;\n+\tif (dtable[i].flags & SYNTAX_INCLUDE)\n+\t  list->flags |= SYNTAX_INCLUDE;\n \tbreak;\n       }\n }\n@@ -219,8 +220,8 @@ _cpp_handle_directive (pfile)\n \t  && CPP_BUFFER (pfile)->ihash\n \t  && ! CPP_OPTION (pfile, preprocessed))\n \tcpp_pedwarn (pfile, \"# followed by integer\");\n-      do_line (pfile);\n-      return 1;\n+      i = T_LINE;\n+      goto process_directive;\n     }\n \n   /* If we are rescanning preprocessed input, don't obey any directives\n@@ -300,6 +301,7 @@ _cpp_handle_directive (pfile)\n   pfile->no_macro_expand--;\n   CPP_SET_WRITTEN (pfile, old_written);\n \n+ process_directive:\n   /* Some directives (e.g. #if) may return a request to execute\n      another directive handler immediately.  No directive ever\n      requests that #define be executed immediately, so it is safe for\n@@ -343,14 +345,14 @@ do_define (pfile)\n   cpp_toklist *list = &pfile->directbuf;\n \n   pfile->no_macro_expand++;\n-  pfile->parsing_define_directive++;\n   CPP_OPTION (pfile, discard_comments)++;\n \n-  _cpp_scan_line (pfile, list);\n+  _cpp_scan_until (pfile, list, CPP_VSPACE);\n \n-  /* First token on the line must be a NAME.  There must be at least\n-     one token (the VSPACE at the end).  */\n-  if (TOK_TYPE (list, 0) != CPP_NAME)\n+  /* First token on the line must be a NAME.  There may not be any\n+     tokens in the list (if we had #define all by itself on a line).  */\n+  if (list->tokens_used == 0\n+      || TOK_TYPE (list, 0) != CPP_NAME)\n     {\n       cpp_error_with_line (pfile, list->line, TOK_COL (list, 0),\n \t\t\t   \"#define must be followed by an identifier\");\n@@ -389,7 +391,6 @@ do_define (pfile)\n \n  out:\n   pfile->no_macro_expand--;\n-  pfile->parsing_define_directive--;\n   CPP_OPTION (pfile, discard_comments)--;\n   return 0;\n }\n@@ -1097,8 +1098,16 @@ static int\n do_if (pfile)\n      cpp_reader *pfile;\n {\n-  U_CHAR *control_macro = detect_if_not_defined (pfile);\n-  int value = _cpp_parse_expr (pfile);\n+  U_CHAR *control_macro;\n+  int value;\n+  int save_only_seen_white = pfile->only_seen_white;\n+\n+  control_macro = detect_if_not_defined (pfile);  \n+\n+  pfile->only_seen_white = 0;\n+  value = _cpp_parse_expr (pfile);\n+  pfile->only_seen_white = save_only_seen_white;\n+\n   return conditional_skip (pfile, value == 0, T_IF, control_macro);\n }\n \n@@ -1383,7 +1392,7 @@ skip_if_group (pfile)\n \n       token = _cpp_get_directive_token (pfile);\n \n-      if (token == CPP_DIRECTIVE)\n+      if (token == CPP_HASH)\n \t{\n \t  ret = consider_directive_while_skipping (pfile, save_if_stack);\n \t  if (ret)\n@@ -1509,125 +1518,175 @@ _cpp_unwind_if_stack (pfile, pbuf)\n   pfile->if_stack = ifs;\n }\n \n+#define WARNING(msgid) do { cpp_warning(pfile, msgid); goto error; } while (0)\n+#define ERROR(msgid) do { cpp_error(pfile, msgid); goto error; } while (0)\n+#define ICE(msgid) do { cpp_ice(pfile, msgid); goto error; } while (0)\n static int\n do_assert (pfile)\n      cpp_reader *pfile;\n {\n   long old_written;\n   U_CHAR *sym;\n-  int ret;\n-  HASHNODE *base, *this;\n-  size_t blen, tlen;\n+  size_t len;\n+  HASHNODE *hp;\n+  struct predicate *pred = 0;\n+  enum cpp_ttype type;\n \n-  old_written = CPP_WRITTEN (pfile);\t/* remember where it starts */\n-  ret = _cpp_parse_assertion (pfile);\n-  if (ret == 0)\n-    goto error;\n-  else if (ret == 1)\n-    {\n-      cpp_error (pfile, \"missing token-sequence in #assert\");\n-      goto error;\n-    }\n-  tlen = CPP_WRITTEN (pfile) - old_written;\n+  old_written = CPP_WRITTEN (pfile);\n+  pfile->no_macro_expand++;\n+\n+  CPP_PUTC (pfile, '#');\t/* force token out of macro namespace */\n+  type = _cpp_get_directive_token (pfile);\n+  if (type == CPP_VSPACE)\n+    ERROR (\"#assert without predicate\");\n+  else if (type != CPP_NAME)\n+    ERROR (\"assertion predicate is not an identifier\");\n \n-  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n-    {\n-      cpp_error (pfile, \"junk at end of #assert\");\n-      goto error;\n-    }\n   sym = pfile->token_buffer + old_written;\n+  len = CPP_WRITTEN (pfile) - old_written;\n+  hp = _cpp_lookup (pfile, sym, len);\n+\n+  if (_cpp_get_directive_token (pfile) != CPP_OPEN_PAREN)\n+    ERROR (\"missing token-sequence in #assert\");\n+\n+  pred = (struct predicate *) xmalloc (sizeof (struct predicate));\n+  _cpp_init_toklist (&pred->answer);\n+\n+  if (_cpp_scan_until (pfile, &pred->answer, CPP_CLOSE_PAREN)\n+      != CPP_CLOSE_PAREN)\n+    ERROR (\"missing close paren in #assert\");\n \n-  this = _cpp_lookup (pfile, sym, tlen);\n-  if (this->type == T_ASSERT)\n+  if (_cpp_get_directive_token (pfile) != CPP_CLOSE_PAREN)\n+    ICE (\"impossible token, expecting ) in do_assert\");\n+\n+  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n+    ERROR (\"junk at end of #assert\");\n+\n+  if (hp->type == T_ASSERTION)\n     {\n-      cpp_warning (pfile, \"%s re-asserted\", sym);\n-      goto error;\n+      /* Check for reassertion.  */\n+      const struct predicate *old;\n+\n+      for (old = hp->value.pred; old; old = old->next)\n+\tif (_cpp_equiv_toklists (&pred->answer, &old->answer))\n+\t  /* We used to warn about this, but SVR4 cc doesn't, so let's\n+\t     match that (also consistent with #define).  goto error will\n+\t     clean up.  */\n+\t  goto error;\n+      pred->next = hp->value.pred;\n     }\n-      \n-  blen = ustrchr (sym, '(') - sym;\n-  base = _cpp_lookup (pfile, sym, blen);\n-  if (base->type == T_VOID)\n+  else\n     {\n-      base->type = T_ASSERT;\n-      base->value.aschain = 0;\n+      hp->type = T_ASSERTION;\n+      pred->next = 0;\n     }\n-\n-  this->type = T_ASSERT;\n-  this->value.aschain = base->value.aschain;\n-  base->value.aschain = this;\n+  \n+  _cpp_squeeze_toklist (&pred->answer);\n+  hp->value.pred = pred;\n+  pfile->no_macro_expand--;\n+  CPP_SET_WRITTEN (pfile, old_written);\n+  return 0;\n \n  error:\n   _cpp_skip_rest_of_line (pfile);\n+  pfile->no_macro_expand--;\n   CPP_SET_WRITTEN (pfile, old_written);\n+  if (pred)\n+    {\n+      _cpp_free_toklist (&pred->answer);\n+      free (pred);\n+    }\n   return 0;\n }\n \n static int\n do_unassert (pfile)\n      cpp_reader *pfile;\n {\n-  int ret;\n   long old_written;\n   U_CHAR *sym;\n-  long baselen, thislen;\n-  HASHNODE *base, *this, *next;\n+  size_t len;\n+  HASHNODE *hp;\n+  struct predicate *pred = 0;\n+  enum cpp_ttype type;\n \n   old_written = CPP_WRITTEN (pfile);\n-  ret = _cpp_parse_assertion (pfile);\n-  if (ret == 0)\n-    goto out;\n-  thislen = CPP_WRITTEN (pfile) - old_written;\n+  pfile->no_macro_expand++;\n \n-  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n+  CPP_PUTC (pfile, '#');\t/* force token out of macro namespace */\n+  if (_cpp_get_directive_token (pfile) != CPP_NAME)\n+    ERROR (\"#unassert must be followed by an identifier\");\n+\n+  sym = pfile->token_buffer + old_written;\n+  len = CPP_WRITTEN (pfile) - old_written;\n+  hp = _cpp_lookup (pfile, sym, len);\n+\n+  type = _cpp_get_directive_token (pfile);\n+  if (type == CPP_OPEN_PAREN)\n     {\n-      cpp_error (pfile, \"junk at end of #unassert\");\n-      goto out;\n+      pred = (struct predicate *) xmalloc (sizeof (struct predicate));\n+      _cpp_init_toklist (&pred->answer);\n+\n+      if (_cpp_scan_until (pfile, &pred->answer, CPP_CLOSE_PAREN)\n+\t  != CPP_CLOSE_PAREN)\n+\tERROR (\"missing close paren in #unassert\");\n+\n+      if (_cpp_get_directive_token (pfile) != CPP_CLOSE_PAREN)\n+\tICE (\"impossible token, expecting ) in do_unassert\");\n+\n+      type = _cpp_get_directive_token (pfile);\n     }\n-  sym = pfile->token_buffer + old_written;\n-  CPP_SET_WRITTEN (pfile, old_written);\n \n-  if (ret == 1)\n+  if (type != CPP_VSPACE)\n+    ERROR (\"junk at end of #unassert\");\n+\n+  if (hp->type != T_ASSERTION)\n+    /* Not an error to #unassert something that isn't asserted.\n+       goto error to clean up.  */\n+    goto error;\n+\n+  if (pred)\n     {\n-      base = _cpp_lookup (pfile, sym, thislen);\n-      if (base->type == T_VOID)\n-\tgoto out;  /* It isn't an error to #undef what isn't #defined,\n-\t\t      so it isn't an error to #unassert what isn't\n-\t\t      #asserted either. */\n-\n-      for (this = base->value.aschain; this; this = next)\n-        {\n-\t  next = this->value.aschain;\n-\t  this->value.aschain = NULL;\n-\t  this->type = T_VOID;\n-\t}\n-      base->value.aschain = NULL;\n-      base->type = T_VOID;\n+      /* Find this specific answer and remove it.  */\n+      struct predicate *o, *p;\n+\n+      for (p = NULL, o = hp->value.pred; o; p = o, o = o->next)\n+\tif (_cpp_equiv_toklists (&pred->answer, &o->answer))\n+\t  {\n+\t    if (p)\n+\t      p->next = o->next;\n+\t    else\n+\t      hp->value.pred = o->next;\n+\n+\t    _cpp_free_toklist (&o->answer);\n+\t    free (o);\n+\t    break;\n+\t  }\n     }\n   else\n     {\n-      baselen = ustrchr (sym, '(') - sym;\n-      base = _cpp_lookup (pfile, sym, baselen);\n-      if (base->type == T_VOID) goto out;\n-      this = _cpp_lookup (pfile, sym, thislen);\n-      if (this->type == T_VOID) goto out;\n-\n-      next = base;\n-      while (next->value.aschain != this)\n-\tnext = next->value.aschain;\n-\n-      next->value.aschain = this->value.aschain;\n-      this->value.aschain = NULL;\n-      this->type = T_VOID;\n-\n-      if (base->value.aschain == NULL)\n-\t/* Last answer for this predicate deleted. */\n-\tbase->type = T_VOID;\n+      struct predicate *o, *p;\n+      for (o = hp->value.pred; o; o = p)\n+\t{\n+\t  p = o->next;\n+\t  _cpp_free_toklist ((cpp_toklist *) &o->answer);\n+\t  free (o);\n+\t}\n+      hp->value.pred = NULL;\n     }\n-  return 0;\n \n- out:\n+  if (hp->value.pred == NULL)\n+    hp->type = T_VOID;  /* Last answer for this predicate deleted.  */\n+\n+ error:\n   _cpp_skip_rest_of_line (pfile);\n+  pfile->no_macro_expand--;\n   CPP_SET_WRITTEN (pfile, old_written);\n+  if (pred)\n+    {\n+      _cpp_free_toklist (&pred->answer);\n+      free (pred);\n+    }\n   return 0;\n }\n "}, {"sha": "6ecab526c48e2178c713c2dba887809549e6cbc5", "filename": "gcc/cpplib.h", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15dad1d9085624c3bce83e0fa0d9b2764f65bccb/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=15dad1d9085624c3bce83e0fa0d9b2764f65bccb", "patch": "@@ -124,7 +124,6 @@ typedef struct cpp_name cpp_name;\n   T(CPP_VSPACE,\t\t\"\\n\")\t/* End of line.  */\t\t\\\n   N(CPP_EOF,\t\t0)\t/* End of file.  */\t\t\\\n   N(CPP_HEADER_NAME,\t0)\t/* <stdio.h> in #include */\t\\\n-  N(CPP_ASSERTION,\t0)\t/* (...) in #assert */\t\t\\\n \\\n   /* Obsolete - will be removed when no code uses them still.  */\t\\\n   N(CPP_HSPACE,\t\t0)\t/* Horizontal white space.  */\t\\\n@@ -189,6 +188,9 @@ struct cpp_token\n   } val;\n };\n \n+/* General flags.  */\n+#define LIST_OFFSET    (1 << 0)\n+\n /* Directive flags.  */\n #define SYNTAX_INCLUDE (1 << 8)\n \n@@ -211,12 +213,12 @@ struct cpp_toklist\n   unsigned int comments_used;\t/* comment tokens used.  */\n   unsigned int comments_cap;\t/* comment token capacity.  */\n \n-  /* Only used if tokens[0].type == CPP_DIRECTIVE.  This is the\n-     handler to call after lexing the rest of this line.  The flags\n-     indicate whether the rest of the line gets special treatment\n-     during lexing (#include, #if, #assert, #unassert).  */\n-  directive_handler dir_handler;\n-  unsigned short dir_flags;\n+  /* The handler to call after lexing the rest of this line.\n+     -1 for none */\n+  short dirno;\n+\n+  /* Per-list flags, see above */\n+  unsigned short flags;\n };\n \n struct cpp_buffer\n@@ -544,12 +546,6 @@ struct cpp_reader\n   /* If true, characters between '<' and '>' are a single (string) token.  */\n   unsigned char parsing_include_directive;\n \n-  /* If true, # introduces an assertion (see do_assert) */\n-  unsigned char parsing_if_directive;\n-\n-  /* If true, # and ## are the STRINGIZE and TOKPASTE operators */\n-  unsigned char parsing_define_directive;\n-\n   /* True if escape sequences (as described for has_escapes in\n      parse_buffer) should be emitted.  */\n   unsigned char output_escapes;"}]}