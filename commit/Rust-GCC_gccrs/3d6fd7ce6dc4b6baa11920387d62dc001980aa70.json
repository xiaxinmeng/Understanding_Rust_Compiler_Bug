{"sha": "3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q2ZmQ3Y2U2ZGM0YjZiYWExMTkyMDM4N2Q2MmRjMDAxOTgwYWE3MA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-03-03T10:01:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-03-03T10:02:28Z"}, "message": "tree-optimization/93946 - fix bogus redundant store removal in FRE, DSE and DOM\n\nThis fixes a common mistake in removing a store that looks redudnant but\nis not because it changes the dynamic type of the memory and thus makes\na difference for following loads with TBAA.\n\n2020-03-03  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/93946\n\t* alias.h (refs_same_for_tbaa_p): Declare.\n\t* alias.c (refs_same_for_tbaa_p): New function.\n\t* tree-ssa-alias.c (ao_ref_alias_set): For a NULL ref return\n\tzero.\n\t* tree-ssa-scopedtables.h\n\t(avail_exprs_stack::lookup_avail_expr): Add output argument\n\tgiving access to the hashtable entry.\n\t* tree-ssa-scopedtables.c (avail_exprs_stack::lookup_avail_expr):\n\tLikewise.\n\t* tree-ssa-dom.c: Include alias.h.\n\t(dom_opt_dom_walker::optimize_stmt): Validate TBAA state before\n\tremoving redundant store.\n\t* tree-ssa-sccvn.h (vn_reference_s::base_set): New member.\n\t(ao_ref_init_from_vn_reference): Adjust prototype.\n\t(vn_reference_lookup_pieces): Likewise.\n\t(vn_reference_insert_pieces): Likewise.\n\t* tree-ssa-sccvn.c: Track base alias set in addition to alias\n\tset everywhere.\n\t(eliminate_dom_walker::eliminate_stmt): Also check base alias\n\tset when removing redundant stores.\n\t(visit_reference_op_store): Likewise.\n\t* dse.c (record_store): Adjust valdity check for redundant\n\tstore removal.\n\n\t* gcc.dg/torture/pr93946-1.c: New testcase.\n\t* gcc.dg/torture/pr93946-2.c: Likewise.", "tree": {"sha": "8254ced343f8ecb9cdfe76b13dd1680c361cbbef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8254ced343f8ecb9cdfe76b13dd1680c361cbbef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01eb1bb0237a24fe50ed0631857f3dfc31782f54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01eb1bb0237a24fe50ed0631857f3dfc31782f54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01eb1bb0237a24fe50ed0631857f3dfc31782f54"}], "stats": {"total": 428, "additions": 305, "deletions": 123}, "files": [{"sha": "b764b6152b18d65479b198c0e79b7898e36e64ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -1,3 +1,30 @@\n+2020-03-03  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/93946\n+\t* alias.h (refs_same_for_tbaa_p): Declare.\n+\t* alias.c (refs_same_for_tbaa_p): New function.\n+\t* tree-ssa-alias.c (ao_ref_alias_set): For a NULL ref return\n+\tzero.\n+\t* tree-ssa-scopedtables.h\n+\t(avail_exprs_stack::lookup_avail_expr): Add output argument\n+\tgiving access to the hashtable entry.\n+\t* tree-ssa-scopedtables.c (avail_exprs_stack::lookup_avail_expr):\n+\tLikewise.\n+\t* tree-ssa-dom.c: Include alias.h.\n+\t(dom_opt_dom_walker::optimize_stmt): Validate TBAA state before\n+\tremoving redundant store.\n+\t* tree-ssa-sccvn.h (vn_reference_s::base_set): New member.\n+\t(ao_ref_init_from_vn_reference): Adjust prototype.\n+\t(vn_reference_lookup_pieces): Likewise.\n+\t(vn_reference_insert_pieces): Likewise.\n+\t* tree-ssa-sccvn.c: Track base alias set in addition to alias\n+\tset everywhere.\n+\t(eliminate_dom_walker::eliminate_stmt): Also check base alias\n+\tset when removing redundant stores.\n+\t(visit_reference_op_store): Likewise.\n+\t* dse.c (record_store): Adjust valdity check for redundant\n+\tstore removal.\n+\n 2020-03-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/26877"}, {"sha": "d38e386d0e8ce6894c6602cdbc0aafe022c50441", "filename": "gcc/alias.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -368,6 +368,26 @@ rtx_refs_may_alias_p (const_rtx x, const_rtx mem, bool tbaa_p)\n \t\t\t     && MEM_ALIAS_SET (mem) != 0);\n }\n \n+/* Return true if the ref EARLIER behaves the same as LATER with respect\n+   to TBAA for every memory reference that might follow LATER.  */\n+\n+bool\n+refs_same_for_tbaa_p (tree earlier, tree later)\n+{\n+  ao_ref earlier_ref, later_ref;\n+  ao_ref_init (&earlier_ref, earlier);\n+  ao_ref_init (&later_ref, later);\n+  alias_set_type earlier_set = ao_ref_alias_set (&earlier_ref);\n+  alias_set_type later_set = ao_ref_alias_set (&later_ref);\n+  if (!(earlier_set == later_set\n+\t|| alias_set_subset_of (later_set, earlier_set)))\n+    return false;\n+  alias_set_type later_base_set = ao_ref_base_alias_set (&later_ref);\n+  alias_set_type earlier_base_set = ao_ref_base_alias_set (&earlier_ref);\n+  return (earlier_base_set == later_base_set\n+\t  || alias_set_subset_of (later_base_set, earlier_base_set));\n+}\n+\n /* Returns a pointer to the alias set entry for ALIAS_SET, if there is\n    such an entry, or NULL otherwise.  */\n "}, {"sha": "4453d9723ce970eee444e1653f0074158c93f67d", "filename": "gcc/alias.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Falias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Falias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.h?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -38,6 +38,7 @@ extern void dump_alias_stats_in_alias_c (FILE *s);\n tree reference_alias_ptr_type (tree);\n bool alias_ptr_types_compatible_p (tree, tree);\n int compare_base_decls (tree, tree);\n+bool refs_same_for_tbaa_p (tree, tree);\n \n /* This alias set can be used to force a memory to conflict with all\n    other memories, creating a barrier across which no memory reference"}, {"sha": "0d96bd43457becb83850f20ddd64a9fbf7e88235", "filename": "gcc/dse.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -1540,9 +1540,12 @@ record_store (rtx body, bb_info_t bb_info)\n \t\t\t\t\t width)\n \t      /* We can only remove the later store if the earlier aliases\n \t\t at least all accesses the later one.  */\n-\t      && (MEM_ALIAS_SET (mem) == MEM_ALIAS_SET (s_info->mem)\n-\t\t  || alias_set_subset_of (MEM_ALIAS_SET (mem),\n-\t\t\t\t\t  MEM_ALIAS_SET (s_info->mem))))\n+\t      && ((MEM_ALIAS_SET (mem) == MEM_ALIAS_SET (s_info->mem)\n+\t\t   || alias_set_subset_of (MEM_ALIAS_SET (mem),\n+\t\t\t\t\t   MEM_ALIAS_SET (s_info->mem)))\n+\t\t  && (!MEM_EXPR (s_info->mem)\n+\t\t      || refs_same_for_tbaa_p (MEM_EXPR (s_info->mem),\n+\t\t\t\t\t       MEM_EXPR (mem)))))\n \t    {\n \t      if (GET_MODE (mem) == BLKmode)\n \t\t{"}, {"sha": "3990df0166f1cb0739ce379f522d50e5cb1df6b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -1,3 +1,9 @@\n+2020-03-03  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/93946\n+\t* gcc.dg/torture/pr93946-1.c: New testcase.\n+\t* gcc.dg/torture/pr93946-2.c: Likewise.\n+\n 2020-03-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/94002"}, {"sha": "d7cfc91f95c4cfe69ca723ee37347e3a873fba08", "filename": "gcc/testsuite/gcc.dg/torture/pr93946-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93946-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93946-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93946-1.c?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+\n+union U { long long i; long f; };\n+struct a {union U u;};\n+struct aa {struct a a;};\n+struct b {union U u;};\n+struct bb {struct b b;};\n+\n+long __attribute__((noipa))\n+foo (struct bb *bv, void *ptr)\n+{\n+  struct aa *a = ptr;\n+  struct bb *b = ptr;\n+  bv->b.u.f = 1;\n+  a->a.u.i = 0;\n+  b->b.u.f = 0;\n+  return bv->b.u.f;\n+}\n+\n+int\n+main ()\n+{\n+  union C {struct aa aa; struct bb bb;} v;\n+  if (foo (&v.bb, &v) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "4c73e58f407e28f833963655f6dda5274f0d35c2", "filename": "gcc/testsuite/gcc.dg/torture/pr93946-2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93946-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93946-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr93946-2.c?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-fno-tree-dse\" } */\n+\n+union U { long long i; long f; };\n+struct a {union U u;};\n+struct aa {struct a a;};\n+struct b {union U u;};\n+struct bb {struct b b;};\n+\n+long __attribute__((noipa))\n+foo (struct bb *bv, void *ptr)\n+{\n+  struct aa *a = ptr;\n+  struct bb *b = ptr;\n+  bv->b.u.f = 1;\n+  a->a.u.i = 0;\n+  b->b.u.f = 0;\n+  return bv->b.u.f;\n+}\n+\n+int\n+main ()\n+{\n+  union C {struct aa aa; struct bb bb;} v;\n+  if (foo (&v.bb, &v) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "df9ba0de0d6774c40c0c6076c6a42d81e601af85", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -697,6 +697,8 @@ ao_ref_alias_set (ao_ref *ref)\n {\n   if (ref->ref_alias_set != -1)\n     return ref->ref_alias_set;\n+  if (!ref->ref)\n+    return 0;\n   ref->ref_alias_set = get_alias_set (ref->ref);\n   return ref->ref_alias_set;\n }"}, {"sha": "eea494c8a961ece523bae3b7af4c14cb974cd9c5", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vrp.h\"\n #include \"vr-values.h\"\n #include \"gimple-ssa-evrp-analyze.h\"\n+#include \"alias.h\"\n \n /* This file implements optimizations on the dominator tree.  */\n \n@@ -2155,9 +2156,14 @@ dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator *si,\n \t  else\n \t    new_stmt = gimple_build_assign (rhs, lhs);\n \t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n+\t  expr_hash_elt *elt = NULL;\n \t  cached_lhs = m_avail_exprs_stack->lookup_avail_expr (new_stmt, false,\n-\t\t\t\t\t\t\t       false);\n-\t  if (cached_lhs && operand_equal_p (rhs, cached_lhs, 0))\n+\t\t\t\t\t\t\t       false, &elt);\n+\t  if (cached_lhs\n+\t      && operand_equal_p (rhs, cached_lhs, 0)\n+\t      && refs_same_for_tbaa_p (elt->expr ()->kind == EXPR_SINGLE\n+\t\t\t\t       ? elt->expr ()->ops.single.rhs\n+\t\t\t\t       : NULL_TREE, lhs))\n \t    {\n \t      basic_block bb = gimple_bb (stmt);\n \t      unlink_stmt_vdef (stmt);"}, {"sha": "f2a4ed97a361bf9771324e9276bd4edb365e7a59", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -658,6 +658,17 @@ dse_optimize_redundant_stores (gimple *stmt)\n {\n   int cnt = 0;\n \n+  /* TBAA state of STMT, if it is a call it is effectively alias-set zero.  */\n+  alias_set_type earlier_set = 0;\n+  alias_set_type earlier_base_set = 0;\n+  if (is_gimple_assign (stmt))\n+    {\n+      ao_ref lhs_ref;\n+      ao_ref_init (&lhs_ref, gimple_assign_lhs (stmt));\n+      earlier_set = ao_ref_alias_set (&lhs_ref);\n+      earlier_base_set = ao_ref_base_alias_set (&lhs_ref);\n+    }\n+\n   /* We could do something fairly complex and look through PHIs\n      like DSE_CLASSIFY_STORE, but it doesn't seem to be worth\n      the effort.\n@@ -698,10 +709,27 @@ dse_optimize_redundant_stores (gimple *stmt)\n \t    {\n \t      gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n \t      if (is_gimple_assign (use_stmt))\n-\t\tdelete_dead_or_redundant_assignment (&gsi, \"redundant\",\n-\t\t\t\t\t\t     need_eh_cleanup);\n+\t\t{\n+\t\t  ao_ref lhs_ref;\n+\t\t  ao_ref_init (&lhs_ref, gimple_assign_lhs (use_stmt));\n+\t\t  if ((earlier_set == ao_ref_alias_set (&lhs_ref)\n+\t\t       || alias_set_subset_of (ao_ref_alias_set (&lhs_ref),\n+\t\t\t\t\t       earlier_set))\n+\t\t      && (earlier_base_set == ao_ref_base_alias_set (&lhs_ref)\n+\t\t\t  || alias_set_subset_of\n+\t\t\t       (ao_ref_base_alias_set (&lhs_ref),\n+\t\t\t\t\t\t  earlier_base_set)))\n+\t\t    delete_dead_or_redundant_assignment (&gsi, \"redundant\",\n+\t\t\t\t\t\t\t need_eh_cleanup);\n+\t\t}\n \t      else if (is_gimple_call (use_stmt))\n-\t\tdelete_dead_or_redundant_call (&gsi, \"redundant\");\n+\t\t{\n+\t\t  if ((earlier_set == 0\n+\t\t       || alias_set_subset_of (0, earlier_set))\n+\t\t      && (earlier_base_set == 0\n+\t\t\t  || alias_set_subset_of (0, earlier_base_set)))\n+\t\t  delete_dead_or_redundant_call (&gsi, \"redundant\");\n+\t\t}\n \t      else\n \t\tgcc_unreachable ();\n \t    }"}, {"sha": "29987d840fdb1b9fc92a71d314bfe3d5a77f16b0", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -1140,7 +1140,8 @@ fully_constant_expression (pre_expr e)\n \n static tree\n translate_vuse_through_block (vec<vn_reference_op_s> operands,\n-\t\t\t      alias_set_type set, tree type, tree vuse,\n+\t\t\t      alias_set_type set, alias_set_type base_set,\n+\t\t\t      tree type, tree vuse,\n \t\t\t      basic_block phiblock,\n \t\t\t      basic_block block, bool *same_valid)\n {\n@@ -1156,7 +1157,8 @@ translate_vuse_through_block (vec<vn_reference_op_s> operands,\n     return vuse;\n \n   unsigned int cnt = param_sccvn_max_alias_queries_per_access;\n-  use_oracle = ao_ref_init_from_vn_reference (&ref, set, type, operands);\n+  use_oracle = ao_ref_init_from_vn_reference (&ref, set, base_set,\n+\t\t\t\t\t      type, operands);\n \n   /* Use the alias-oracle to find either the PHI node in this block,\n      the first VUSE used in this block that is equivalent to vuse or\n@@ -1535,7 +1537,8 @@ phi_translate_1 (bitmap_set_t dest,\n \t  {\n \t    newvuse = translate_vuse_through_block (newoperands.exists ()\n \t\t\t\t\t\t    ? newoperands : operands,\n-\t\t\t\t\t\t    ref->set, ref->type,\n+\t\t\t\t\t\t    ref->set, ref->base_set,\n+\t\t\t\t\t\t    ref->type,\n \t\t\t\t\t\t    vuse, phiblock, pred,\n \t\t\t\t\t\t    changed\n \t\t\t\t\t\t    ? NULL : &same_valid);\n@@ -1551,6 +1554,7 @@ phi_translate_1 (bitmap_set_t dest,\n \t    unsigned int new_val_id;\n \n \t    tree result = vn_reference_lookup_pieces (newvuse, ref->set,\n+\t\t\t\t\t\t      ref->base_set,\n \t\t\t\t\t\t      ref->type,\n \t\t\t\t\t\t      newoperands.exists ()\n \t\t\t\t\t\t      ? newoperands : operands,\n@@ -1608,7 +1612,7 @@ phi_translate_1 (bitmap_set_t dest,\n \t\tif (!newoperands.exists ())\n \t\t  newoperands = operands.copy ();\n \t\tnewref = vn_reference_insert_pieces (newvuse, ref->set,\n-\t\t\t\t\t\t     ref->type,\n+\t\t\t\t\t\t     ref->base_set, ref->type,\n \t\t\t\t\t\t     newoperands,\n \t\t\t\t\t\t     result, new_val_id);\n \t\tnewoperands = vNULL;\n@@ -1827,8 +1831,8 @@ value_dies_in_block_x (pre_expr expr, basic_block block)\n \n       /* Init ref only if we really need it.  */\n       if (ref.base == NULL_TREE\n-\t  && !ao_ref_init_from_vn_reference (&ref, refx->set, refx->type,\n-\t\t\t\t\t     refx->operands))\n+\t  && !ao_ref_init_from_vn_reference (&ref, refx->set, refx->base_set,\n+\t\t\t\t\t     refx->type, refx->operands))\n \t{\n \t  res = true;\n \t  break;\n@@ -3914,12 +3918,16 @@ compute_avail (void)\n \t\t  case VN_REFERENCE:\n \t\t    {\n \t\t      tree rhs1 = gimple_assign_rhs1 (stmt);\n-\t\t      alias_set_type set = get_alias_set (rhs1);\n+\t\t      ao_ref rhs1_ref;\n+\t\t      ao_ref_init (&rhs1_ref, rhs1);\n+\t\t      alias_set_type set = ao_ref_alias_set (&rhs1_ref);\n+\t\t      alias_set_type base_set\n+\t\t\t= ao_ref_base_alias_set (&rhs1_ref);\n \t\t      vec<vn_reference_op_s> operands\n \t\t\t= vn_reference_operands_for_lookup (rhs1);\n \t\t      vn_reference_t ref;\n \t\t      vn_reference_lookup_pieces (gimple_vuse (stmt), set,\n-\t\t\t\t\t\t  TREE_TYPE (rhs1),\n+\t\t\t\t\t\t  base_set, TREE_TYPE (rhs1),\n \t\t\t\t\t\t  operands, &ref, VN_WALK);\n \t\t      if (!ref)\n \t\t\t{"}, {"sha": "1015875591c50b26d9e3a0a55226ba67d24bbe35", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 122, "deletions": 100, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -367,7 +367,8 @@ static void init_vn_nary_op_from_pieces (vn_nary_op_t, unsigned int,\n \t\t\t\t\t enum tree_code, tree, tree *);\n static tree vn_lookup_simplify_result (gimple_match_op *);\n static vn_reference_t vn_reference_lookup_or_insert_for_pieces\n-\t  (tree, alias_set_type, tree, vec<vn_reference_op_s, va_heap>, tree);\n+\t  (tree, alias_set_type, alias_set_type, tree,\n+\t   vec<vn_reference_op_s, va_heap>, tree);\n \n /* Return whether there is value numbering information for a given SSA name.  */\n \n@@ -982,8 +983,8 @@ copy_reference_ops_from_ref (tree ref, vec<vn_reference_op_s> *result)\n \n bool\n ao_ref_init_from_vn_reference (ao_ref *ref,\n-\t\t\t       alias_set_type set, tree type,\n-\t\t\t       vec<vn_reference_op_s> ops)\n+\t\t\t       alias_set_type set, alias_set_type base_set,\n+\t\t\t       tree type, vec<vn_reference_op_s> ops)\n {\n   vn_reference_op_t op;\n   unsigned i;\n@@ -993,7 +994,6 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n   poly_offset_int max_size;\n   poly_offset_int size = -1;\n   tree size_tree = NULL_TREE;\n-  alias_set_type base_alias_set = -1;\n \n   /* First get the final access size from just the outermost expression.  */\n   op = &ops[0];\n@@ -1050,7 +1050,6 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n \n \t/* Record the base objects.  */\n \tcase MEM_REF:\n-\t  base_alias_set = get_deref_alias_set (op->op0);\n \t  *op0_p = build2 (MEM_REF, op->type,\n \t\t\t   NULL_TREE, op->op0);\n \t  MR_DEPENDENCE_CLIQUE (*op0_p) = op->clique;\n@@ -1140,10 +1139,7 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n   ref->ref = NULL_TREE;\n   ref->base = base;\n   ref->ref_alias_set = set;\n-  if (base_alias_set != -1)\n-    ref->base_alias_set = base_alias_set;\n-  else\n-    ref->base_alias_set = get_alias_set (base);\n+  ref->base_alias_set = base_set;\n   /* We discount volatiles from value-numbering elsewhere.  */\n   ref->volatile_p = false;\n \n@@ -1689,15 +1685,17 @@ struct vn_walk_cb_data\n \t\t   vn_lookup_kind vn_walk_kind_, bool tbaa_p_)\n     : vr (vr_), last_vuse_ptr (last_vuse_ptr_), last_vuse (NULL_TREE),\n       vn_walk_kind (vn_walk_kind_), tbaa_p (tbaa_p_),\n-      saved_operands (vNULL), first_set (-2), known_ranges (NULL)\n+      saved_operands (vNULL), first_set (-2), first_base_set (-2),\n+      known_ranges (NULL)\n    {\n      if (!last_vuse_ptr)\n        last_vuse_ptr = &last_vuse;\n      ao_ref_init (&orig_ref, orig_ref_);\n    }\n   ~vn_walk_cb_data ();\n-  void *finish (alias_set_type, tree);\n-  void *push_partial_def (const pd_data& pd, alias_set_type, HOST_WIDE_INT);\n+  void *finish (alias_set_type, alias_set_type, tree);\n+  void *push_partial_def (const pd_data& pd,\n+\t\t\t  alias_set_type, alias_set_type, HOST_WIDE_INT);\n \n   vn_reference_t vr;\n   ao_ref orig_ref;\n@@ -1712,6 +1710,7 @@ struct vn_walk_cb_data\n   /* The first defs range to avoid splay tree setup in most cases.  */\n   pd_range first_range;\n   alias_set_type first_set;\n+  alias_set_type first_base_set;\n   splay_tree known_ranges;\n   obstack ranges_obstack;\n };\n@@ -1727,12 +1726,15 @@ vn_walk_cb_data::~vn_walk_cb_data ()\n }\n \n void *\n-vn_walk_cb_data::finish (alias_set_type set, tree val)\n+vn_walk_cb_data::finish (alias_set_type set, alias_set_type base_set, tree val)\n {\n   if (first_set != -2)\n-    set = first_set;\n+    {\n+      set = first_set;\n+      base_set = first_base_set;\n+    }\n   return vn_reference_lookup_or_insert_for_pieces\n-      (last_vuse, set, vr->type,\n+      (last_vuse, set, base_set, vr->type,\n        saved_operands.exists () ? saved_operands : vr->operands, val);\n }\n \n@@ -1769,7 +1771,8 @@ pd_tree_dealloc (void *, void *)\n \n void *\n vn_walk_cb_data::push_partial_def (const pd_data &pd,\n-\t\t\t\t   alias_set_type set, HOST_WIDE_INT maxsizei)\n+\t\t\t\t   alias_set_type set, alias_set_type base_set,\n+\t\t\t\t   HOST_WIDE_INT maxsizei)\n {\n   const HOST_WIDE_INT bufsize = 64;\n   /* We're using a fixed buffer for encoding so fail early if the object\n@@ -1794,6 +1797,7 @@ vn_walk_cb_data::push_partial_def (const pd_data &pd,\n       first_range.offset = pd.offset;\n       first_range.size = pd.size;\n       first_set = set;\n+      first_base_set = base_set;\n       last_vuse_ptr = NULL;\n       /* Continue looking for partial defs.  */\n       return NULL;\n@@ -2062,7 +2066,7 @@ vn_walk_cb_data::push_partial_def (const pd_data &pd,\n \t\t \"Successfully combined %u partial definitions\\n\", ndefs);\n       /* We are using the alias-set of the first store we encounter which\n \t should be appropriate here.  */\n-      return finish (first_set, val);\n+      return finish (first_set, first_base_set, val);\n     }\n   else\n     {\n@@ -2107,7 +2111,7 @@ vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse, void *data_)\n   if (slot)\n     {\n       if ((*slot)->result && data->saved_operands.exists ())\n-\treturn data->finish (vr->set, (*slot)->result);\n+\treturn data->finish (vr->set, vr->base_set, (*slot)->result);\n       return *slot;\n     }\n \n@@ -2121,6 +2125,7 @@ vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse, void *data_)\n static vn_reference_t\n vn_reference_lookup_or_insert_for_pieces (tree vuse,\n \t\t\t\t\t  alias_set_type set,\n+\t\t\t\t\t  alias_set_type base_set,\n \t\t\t\t\t  tree type,\n \t\t\t\t\t  vec<vn_reference_op_s,\n \t\t\t\t\t        va_heap> operands,\n@@ -2133,14 +2138,15 @@ vn_reference_lookup_or_insert_for_pieces (tree vuse,\n   vr1.operands = operands;\n   vr1.type = type;\n   vr1.set = set;\n+  vr1.base_set = base_set;\n   vr1.hashcode = vn_reference_compute_hash (&vr1);\n   if (vn_reference_lookup_1 (&vr1, &result))\n     return result;\n   if (TREE_CODE (value) == SSA_NAME)\n     value_id = VN_INFO (value)->value_id;\n   else\n     value_id = get_or_alloc_constant_value_id (value);\n-  return vn_reference_insert_pieces (vuse, set, type,\n+  return vn_reference_insert_pieces (vuse, set, base_set, type,\n \t\t\t\t     operands.copy (), value, value_id);\n }\n \n@@ -2407,22 +2413,16 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t  lhs_ops = valueize_refs_1 (lhs_ops, &valueized_anything, true);\n \t}\n       vn_context_bb = saved_rpo_bb;\n-      if (valueized_anything)\n+      ao_ref_init (&lhs_ref, lhs);\n+      lhs_ref_ok = true;\n+      if (valueized_anything\n+\t  && ao_ref_init_from_vn_reference\n+\t       (&lhs_ref, ao_ref_alias_set (&lhs_ref),\n+\t\tao_ref_base_alias_set (&lhs_ref), TREE_TYPE (lhs), lhs_ops)\n+\t  && !refs_may_alias_p_1 (ref, &lhs_ref, data->tbaa_p))\n \t{\n-\t  lhs_ref_ok = ao_ref_init_from_vn_reference (&lhs_ref,\n-\t\t\t\t\t\t      get_alias_set (lhs),\n-\t\t\t\t\t\t      TREE_TYPE (lhs), lhs_ops);\n-\t  if (lhs_ref_ok\n-\t      && !refs_may_alias_p_1 (ref, &lhs_ref, data->tbaa_p))\n-\t    {\n-\t      *disambiguate_only = TR_VALUEIZE_AND_DISAMBIGUATE;\n-\t      return NULL;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  ao_ref_init (&lhs_ref, lhs);\n-\t  lhs_ref_ok = true;\n+\t  *disambiguate_only = TR_VALUEIZE_AND_DISAMBIGUATE;\n+\t  return NULL;\n \t}\n \n       /* Besides valueizing the LHS we can also use access-path based\n@@ -2673,7 +2673,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t      if (!val)\n \t\treturn (void *)-1;\n \t    }\n-\t  return data->finish (0, val);\n+\t  return data->finish (0, 0, val);\n \t}\n       /* For now handle clearing memory with partial defs.  */\n       else if (known_eq (ref->size, maxsize)\n@@ -2691,7 +2691,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t  pd.rhs = build_constructor (NULL_TREE, NULL);\n \t  pd.offset = offset2i - offseti;\n \t  pd.size = leni << LOG2_BITS_PER_UNIT;\n-\t  return data->push_partial_def (pd, 0, maxsizei);\n+\t  return data->push_partial_def (pd, 0, 0, maxsizei);\n \t}\n     }\n \n@@ -2701,22 +2701,14 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t   && gimple_assign_rhs_code (def_stmt) == CONSTRUCTOR\n \t   && CONSTRUCTOR_NELTS (gimple_assign_rhs1 (def_stmt)) == 0)\n     {\n-      tree lhs = gimple_assign_lhs (def_stmt);\n       tree base2;\n       poly_int64 offset2, size2, maxsize2;\n       HOST_WIDE_INT offset2i, size2i;\n-      bool reverse;\n-      if (lhs_ref_ok)\n-\t{\n-\t  base2 = ao_ref_base (&lhs_ref);\n-\t  offset2 = lhs_ref.offset;\n-\t  size2 = lhs_ref.size;\n-\t  maxsize2 = lhs_ref.max_size;\n-\t  reverse = reverse_storage_order_for_component_p (lhs);\n-\t}\n-      else\n-\tbase2 = get_ref_base_and_extent (lhs,\n-\t\t\t\t\t &offset2, &size2, &maxsize2, &reverse);\n+      gcc_assert (lhs_ref_ok);\n+      base2 = ao_ref_base (&lhs_ref);\n+      offset2 = lhs_ref.offset;\n+      size2 = lhs_ref.size;\n+      maxsize2 = lhs_ref.max_size;\n       if (known_size_p (maxsize2)\n \t  && known_eq (maxsize2, size2)\n \t  && adjust_offsets_for_equal_base_address (base, &offset,\n@@ -2730,7 +2722,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t      if (gimple_clobber_p (def_stmt))\n \t\treturn (void *)-1;\n \t      tree val = build_zero_cst (vr->type);\n-\t      return data->finish (get_alias_set (lhs), val);\n+\t      return data->finish (ao_ref_alias_set (&lhs_ref),\n+\t\t\t\t   ao_ref_base_alias_set (&lhs_ref), val);\n \t    }\n \t  else if (known_eq (ref->size, maxsize)\n \t\t   && maxsize.is_constant (&maxsizei)\n@@ -2747,7 +2740,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t      pd.rhs = gimple_assign_rhs1 (def_stmt);\n \t      pd.offset = offset2i - offseti;\n \t      pd.size = size2i;\n-\t      return data->push_partial_def (pd, get_alias_set (lhs), maxsizei);\n+\t      return data->push_partial_def (pd, ao_ref_alias_set (&lhs_ref),\n+\t\t\t\t\t     ao_ref_base_alias_set (&lhs_ref),\n+\t\t\t\t\t     maxsizei);\n \t    }\n \t}\n     }\n@@ -2774,17 +2769,12 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n       poly_int64 offset2, size2, maxsize2;\n       HOST_WIDE_INT offset2i, size2i;\n       bool reverse;\n-      if (lhs_ref_ok)\n-\t{\n-\t  base2 = ao_ref_base (&lhs_ref);\n-\t  offset2 = lhs_ref.offset;\n-\t  size2 = lhs_ref.size;\n-\t  maxsize2 = lhs_ref.max_size;\n-\t  reverse = reverse_storage_order_for_component_p (lhs);\n-\t}\n-      else\n-\tbase2 = get_ref_base_and_extent (lhs,\n-\t\t\t\t\t &offset2, &size2, &maxsize2, &reverse);\n+      gcc_assert (lhs_ref_ok);\n+      base2 = ao_ref_base (&lhs_ref);\n+      offset2 = lhs_ref.offset;\n+      size2 = lhs_ref.size;\n+      maxsize2 = lhs_ref.max_size;\n+      reverse = reverse_storage_order_for_component_p (lhs);\n       if (base2\n \t  && !reverse\n \t  && !storage_order_barrier_p (lhs)\n@@ -2887,7 +2877,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t\t    }\n \n \t\t  if (val)\n-\t\t    return data->finish (get_alias_set (lhs), val);\n+\t\t    return data->finish (ao_ref_alias_set (&lhs_ref),\n+\t\t\t\t\t ao_ref_base_alias_set (&lhs_ref), val);\n \t\t}\n \t    }\n \t  else if (ranges_known_overlap_p (offseti, maxsizei, offset2i,\n@@ -2900,7 +2891,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t      pd.rhs = rhs;\n \t      pd.offset = offset2i - offseti;\n \t      pd.size = size2i;\n-\t      return data->push_partial_def (pd, get_alias_set (lhs), maxsizei);\n+\t      return data->push_partial_def (pd, ao_ref_alias_set (&lhs_ref),\n+\t\t\t\t\t     ao_ref_base_alias_set (&lhs_ref),\n+\t\t\t\t\t     maxsizei);\n \t    }\n \t}\n     }\n@@ -2918,17 +2911,12 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n       poly_int64 offset2, size2, maxsize2;\n       HOST_WIDE_INT offset2i, size2i, offseti;\n       bool reverse;\n-      if (lhs_ref_ok)\n-\t{\n-\t  base2 = ao_ref_base (&lhs_ref);\n-\t  offset2 = lhs_ref.offset;\n-\t  size2 = lhs_ref.size;\n-\t  maxsize2 = lhs_ref.max_size;\n-\t  reverse = reverse_storage_order_for_component_p (lhs);\n-\t}\n-      else\n-\tbase2 = get_ref_base_and_extent (lhs,\n-\t\t\t\t\t &offset2, &size2, &maxsize2, &reverse);\n+      gcc_assert (lhs_ref_ok);\n+      base2 = ao_ref_base (&lhs_ref);\n+      offset2 = lhs_ref.offset;\n+      size2 = lhs_ref.size;\n+      maxsize2 = lhs_ref.max_size;\n+      reverse = reverse_storage_order_for_component_p (lhs);\n       tree def_rhs = gimple_assign_rhs1 (def_stmt);\n       if (!reverse\n \t  && !storage_order_barrier_p (lhs)\n@@ -2968,7 +2956,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t      if (val\n \t\t  && (TREE_CODE (val) != SSA_NAME\n \t\t      || ! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (val)))\n-\t\treturn data->finish (get_alias_set (lhs), val);\n+\t\treturn data->finish (ao_ref_alias_set (&lhs_ref),\n+\t\t\t\t     ao_ref_base_alias_set (&lhs_ref), val);\n \t    }\n \t  else if (maxsize.is_constant (&maxsizei)\n \t\t   && offset.is_constant (&offseti)\n@@ -2980,7 +2969,9 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t      pd.rhs = SSA_VAL (def_rhs);\n \t      pd.offset = offset2i - offseti;\n \t      pd.size = size2i;\n-\t      return data->push_partial_def (pd, get_alias_set (lhs), maxsizei);\n+\t      return data->push_partial_def (pd, ao_ref_alias_set (&lhs_ref),\n+\t\t\t\t\t     ao_ref_base_alias_set (&lhs_ref),\n+\t\t\t\t\t     maxsizei);\n \t    }\n \t}\n     }\n@@ -2993,15 +2984,13 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t       || TREE_CODE (gimple_assign_rhs1 (def_stmt)) == MEM_REF\n \t       || handled_component_p (gimple_assign_rhs1 (def_stmt))))\n     {\n-      tree lhs = gimple_assign_lhs (def_stmt);\n       tree base2;\n       int i, j, k;\n       auto_vec<vn_reference_op_s> rhs;\n       vn_reference_op_t vro;\n       ao_ref r;\n \n-      if (!lhs_ref_ok)\n-\treturn (void *)-1;\n+      gcc_assert (lhs_ref_ok);\n \n       /* See if the assignment kills REF.  */\n       base2 = ao_ref_base (&lhs_ref);\n@@ -3104,7 +3093,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n       if (val)\n \t{\n \t  if (data->partial_defs.is_empty ())\n-\t    return data->finish (get_alias_set (lhs), val);\n+\t    return data->finish (ao_ref_alias_set (&lhs_ref),\n+\t\t\t\t ao_ref_base_alias_set (&lhs_ref), val);\n \t  /* This is the only interesting case for partial-def handling\n \t     coming from targets that like to gimplify init-ctors as\n \t     aggregate copies from constant data like aarch64 for\n@@ -3115,7 +3105,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t      pd.rhs = val;\n \t      pd.offset = 0;\n \t      pd.size = maxsizei;\n-\t      return data->push_partial_def (pd, get_alias_set (lhs),\n+\t      return data->push_partial_def (pd, ao_ref_alias_set (&lhs_ref),\n+\t\t\t\t\t     ao_ref_base_alias_set (&lhs_ref),\n \t\t\t\t\t     maxsizei);\n \t    }\n \t}\n@@ -3127,7 +3118,10 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \treturn (void *)-1;\n \n       /* Adjust *ref from the new operands.  */\n-      if (!ao_ref_init_from_vn_reference (&r, get_alias_set (rhs1),\n+      ao_ref rhs1_ref;\n+      ao_ref_init (&rhs1_ref, rhs1);\n+      if (!ao_ref_init_from_vn_reference (&r, ao_ref_alias_set (&rhs1_ref),\n+\t\t\t\t\t  ao_ref_base_alias_set (&rhs1_ref),\n \t\t\t\t\t  vr->type, vr->operands))\n \treturn (void *)-1;\n       /* This can happen with bitfields.  */\n@@ -3142,7 +3136,10 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n       data->orig_ref.ref = NULL_TREE;\n       /* Use the alias-set of this LHS for recording an eventual result.  */\n       if (data->first_set == -2)\n-\tdata->first_set = get_alias_set (lhs);\n+\t{\n+\t  data->first_set = ao_ref_alias_set (&lhs_ref);\n+\t  data->first_base_set = ao_ref_base_alias_set (&lhs_ref);\n+\t}\n \n       /* Keep looking for the adjusted *REF / VR pair.  */\n       return NULL;\n@@ -3302,10 +3299,10 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n       /* Try folding the new reference to a constant.  */\n       tree val = fully_constant_vn_reference_p (vr);\n       if (val)\n-\treturn data->finish (0, val);\n+\treturn data->finish (0, 0, val);\n \n       /* Adjust *ref from the new operands.  */\n-      if (!ao_ref_init_from_vn_reference (&r, 0, vr->type, vr->operands))\n+      if (!ao_ref_init_from_vn_reference (&r, 0, 0, vr->type, vr->operands))\n \treturn (void *)-1;\n       /* This can happen with bitfields.  */\n       if (maybe_ne (ref->size, r.size))\n@@ -3319,7 +3316,10 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n       data->orig_ref.ref = NULL_TREE;\n       /* Use the alias-set of this stmt for recording an eventual result.  */\n       if (data->first_set == -2)\n-\tdata->first_set = 0;\n+\t{\n+\t  data->first_set = 0;\n+\t  data->first_base_set = 0;\n+\t}\n \n       /* Keep looking for the adjusted *REF / VR pair.  */\n       return NULL;\n@@ -3346,7 +3346,8 @@ vn_reference_operands_for_lookup (tree op)\n    vn_reference_t stored in the hashtable if something is found.  */\n \n tree\n-vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,\n+vn_reference_lookup_pieces (tree vuse, alias_set_type set,\n+\t\t\t    alias_set_type base_set, tree type,\n \t\t\t    vec<vn_reference_op_s> operands,\n \t\t\t    vn_reference_t *vnresult, vn_lookup_kind kind)\n {\n@@ -3369,6 +3370,7 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,\n     = valueize_refs (shared_lookup_references);\n   vr1.type = type;\n   vr1.set = set;\n+  vr1.set = base_set;\n   vr1.hashcode = vn_reference_compute_hash (&vr1);\n   if ((cst = fully_constant_vn_reference_p (&vr1)))\n     return cst;\n@@ -3381,7 +3383,7 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,\n       ao_ref r;\n       unsigned limit = param_sccvn_max_alias_queries_per_access;\n       vn_walk_cb_data data (&vr1, NULL_TREE, NULL, kind, true);\n-      if (ao_ref_init_from_vn_reference (&r, set, type, vr1.operands))\n+      if (ao_ref_init_from_vn_reference (&r, set, base_set, type, vr1.operands))\n \t*vnresult =\n \t  (vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse, true,\n \t\t\t\t\t\t  vn_reference_lookup_2,\n@@ -3420,7 +3422,10 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n   vr1.operands = operands\n     = valueize_shared_reference_ops_from_ref (op, &valuezied_anything);\n   vr1.type = TREE_TYPE (op);\n-  vr1.set = get_alias_set (op);\n+  ao_ref op_ref;\n+  ao_ref_init (&op_ref, op);\n+  vr1.set = ao_ref_alias_set (&op_ref);\n+  vr1.base_set = ao_ref_base_alias_set (&op_ref);\n   vr1.hashcode = vn_reference_compute_hash (&vr1);\n   if ((cst = fully_constant_vn_reference_p (&vr1)))\n     return cst;\n@@ -3434,8 +3439,8 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n       /* Make sure to use a valueized reference if we valueized anything.\n          Otherwise preserve the full reference for advanced TBAA.  */\n       if (!valuezied_anything\n-\t  || !ao_ref_init_from_vn_reference (&r, vr1.set, vr1.type,\n-\t\t\t\t\t     vr1.operands))\n+\t  || !ao_ref_init_from_vn_reference (&r, vr1.set, vr1.base_set,\n+\t\t\t\t\t     vr1.type, vr1.operands))\n \tao_ref_init (&r, op);\n       vn_walk_cb_data data (&vr1, r.ref ? NULL_TREE : op,\n \t\t\t    last_vuse_ptr, kind, tbaa_p);\n@@ -3476,6 +3481,7 @@ vn_reference_lookup_call (gcall *call, vn_reference_t *vnresult,\n   vr->operands = valueize_shared_reference_ops_from_call (call);\n   vr->type = gimple_expr_type (call);\n   vr->set = 0;\n+  vr->base_set = 0;\n   vr->hashcode = vn_reference_compute_hash (vr);\n   vn_reference_lookup_1 (vr, vnresult);\n }\n@@ -3497,7 +3503,10 @@ vn_reference_insert (tree op, tree result, tree vuse, tree vdef)\n   vr1->vuse = vuse_ssa_val (vuse);\n   vr1->operands = valueize_shared_reference_ops_from_ref (op, &tem).copy ();\n   vr1->type = TREE_TYPE (op);\n-  vr1->set = get_alias_set (op);\n+  ao_ref op_ref;\n+  ao_ref_init (&op_ref, op);\n+  vr1->set = ao_ref_alias_set (&op_ref);\n+  vr1->base_set = ao_ref_base_alias_set (&op_ref);\n   vr1->hashcode = vn_reference_compute_hash (vr1);\n   vr1->result = TREE_CODE (result) == SSA_NAME ? SSA_VAL (result) : result;\n   vr1->result_vdef = vdef;\n@@ -3539,7 +3548,8 @@ vn_reference_insert (tree op, tree result, tree vuse, tree vdef)\n    structure we created.  */\n \n vn_reference_t\n-vn_reference_insert_pieces (tree vuse, alias_set_type set, tree type,\n+vn_reference_insert_pieces (tree vuse, alias_set_type set,\n+\t\t\t    alias_set_type base_set, tree type,\n \t\t\t    vec<vn_reference_op_s> operands,\n \t\t\t    tree result, unsigned int value_id)\n \n@@ -3553,6 +3563,7 @@ vn_reference_insert_pieces (tree vuse, alias_set_type set, tree type,\n   vr1->operands = valueize_refs (operands);\n   vr1->type = type;\n   vr1->set = set;\n+  vr1->base_set = base_set;\n   vr1->hashcode = vn_reference_compute_hash (vr1);\n   if (result && TREE_CODE (result) == SSA_NAME)\n     result = SSA_VAL (result);\n@@ -4735,6 +4746,7 @@ visit_reference_op_call (tree lhs, gcall *stmt)\n       vr2->operands = vr1.operands.copy ();\n       vr2->type = vr1.type;\n       vr2->set = vr1.set;\n+      vr2->base_set = vr1.base_set;\n       vr2->hashcode = vr1.hashcode;\n       vr2->result = lhs;\n       vr2->result_vdef = vdef_val;\n@@ -4839,9 +4851,14 @@ visit_reference_op_store (tree lhs, tree op, gimple *stmt)\n \t{\n \t  /* If the TBAA state isn't compatible for downstream reads\n \t     we cannot value-number the VDEFs the same.  */\n-\t  alias_set_type set = get_alias_set (lhs);\n-\t  if (vnresult->set != set\n-\t      && ! alias_set_subset_of (set, vnresult->set))\n+\t  ao_ref lhs_ref;\n+\t  ao_ref_init (&lhs_ref, lhs);\n+\t  alias_set_type set = ao_ref_alias_set (&lhs_ref);\n+\t  alias_set_type base_set = ao_ref_base_alias_set (&lhs_ref);\n+\t  if ((vnresult->set != set\n+\t       && ! alias_set_subset_of (set, vnresult->set))\n+\t      || (vnresult->base_set != base_set\n+\t\t  && ! alias_set_subset_of (base_set, vnresult->base_set)))\n \t    resultsame = false;\n \t}\n     }\n@@ -5915,10 +5932,15 @@ eliminate_dom_walker::eliminate_stmt (basic_block b, gimple_stmt_iterator *gsi)\n \t  /* We can only remove the later store if the former aliases\n \t     at least all accesses the later one does or if the store\n \t     was to readonly memory storing the same value.  */\n-\t  alias_set_type set = get_alias_set (lhs);\n+\t  ao_ref lhs_ref;\n+\t  ao_ref_init (&lhs_ref, lhs);\n+\t  alias_set_type set = ao_ref_alias_set (&lhs_ref);\n+\t  alias_set_type base_set = ao_ref_base_alias_set (&lhs_ref);\n \t  if (! vnresult\n-\t      || vnresult->set == set\n-\t      || alias_set_subset_of (set, vnresult->set))\n+\t      || ((vnresult->set == set\n+\t\t   || alias_set_subset_of (set, vnresult->set))\n+\t\t  && (vnresult->base_set == base_set\n+\t\t      || alias_set_subset_of (base_set, vnresult->base_set))))\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{"}, {"sha": "2042df118d7ebe3acbdcf87196cab8d742e9b0d6", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -143,6 +143,7 @@ typedef struct vn_reference_s\n   hashval_t hashcode;\n   tree vuse;\n   alias_set_type set;\n+  alias_set_type base_set;\n   tree type;\n   vec<vn_reference_op_s> operands;\n   tree result;\n@@ -249,17 +250,17 @@ tree vn_nary_op_lookup_pieces (unsigned int, enum tree_code,\n \t\t\t       tree, tree *, vn_nary_op_t *);\n vn_nary_op_t vn_nary_op_insert_pieces (unsigned int, enum tree_code,\n \t\t\t\t       tree, tree *, tree, unsigned int);\n-bool ao_ref_init_from_vn_reference (ao_ref *, alias_set_type, tree,\n-\t\t\t\t    vec<vn_reference_op_s> );\n+bool ao_ref_init_from_vn_reference (ao_ref *, alias_set_type, alias_set_type,\n+\t\t\t\t    tree, vec<vn_reference_op_s> );\n vec<vn_reference_op_s> vn_reference_operands_for_lookup (tree);\n-tree vn_reference_lookup_pieces (tree, alias_set_type, tree,\n+tree vn_reference_lookup_pieces (tree, alias_set_type, alias_set_type, tree,\n \t\t\t\t vec<vn_reference_op_s> ,\n \t\t\t\t vn_reference_t *, vn_lookup_kind);\n tree vn_reference_lookup (tree, tree, vn_lookup_kind, vn_reference_t *, bool,\n \t\t\t  tree * = NULL);\n void vn_reference_lookup_call (gcall *, vn_reference_t *, vn_reference_t);\n-vn_reference_t vn_reference_insert_pieces (tree, alias_set_type, tree,\n-\t\t\t\t\t   vec<vn_reference_op_s> ,\n+vn_reference_t vn_reference_insert_pieces (tree, alias_set_type, alias_set_type,\n+\t\t\t\t\t   tree, vec<vn_reference_op_s>,\n \t\t\t\t\t   tree, unsigned int);\n \n bool vn_nary_op_eq (const_vn_nary_op_t const vno1,"}, {"sha": "c1aa59f65d578aa1baa6b0404a8486814800e0c7", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -223,7 +223,8 @@ avail_exprs_stack::simplify_binary_operation (gimple *stmt,\n    we finish processing this block and its children.  */\n \n tree\n-avail_exprs_stack::lookup_avail_expr (gimple *stmt, bool insert, bool tbaa_p)\n+avail_exprs_stack::lookup_avail_expr (gimple *stmt, bool insert, bool tbaa_p,\n+\t\t\t\t      expr_hash_elt **elt)\n {\n   expr_hash_elt **slot;\n   tree lhs;\n@@ -317,6 +318,8 @@ avail_exprs_stack::lookup_avail_expr (gimple *stmt, bool insert, bool tbaa_p)\n   /* Extract the LHS of the assignment so that it can be used as the current\n      definition of another variable.  */\n   lhs = (*slot)->lhs ();\n+  if (elt)\n+    *elt = *slot;\n \n   /* Valueize the result.  */\n   if (TREE_CODE (lhs) == SSA_NAME)"}, {"sha": "ecb3b97eebf2a1fc7ebb8f99d08963ec42e8b4fb", "filename": "gcc/tree-ssa-scopedtables.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-scopedtables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d6fd7ce6dc4b6baa11920387d62dc001980aa70/gcc%2Ftree-ssa-scopedtables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.h?ref=3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "patch": "@@ -148,7 +148,7 @@ class avail_exprs_stack\n \n   /* Lookup and conditionally insert an expression into the table,\n      recording enough information to unwind as needed.  */\n-  tree lookup_avail_expr (gimple *, bool, bool);\n+  tree lookup_avail_expr (gimple *, bool, bool, expr_hash_elt ** = NULL);\n \n   void record_cond (cond_equivalence *);\n "}]}