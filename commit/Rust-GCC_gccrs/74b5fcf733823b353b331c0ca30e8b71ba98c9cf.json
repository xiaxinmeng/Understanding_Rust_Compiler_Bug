{"sha": "74b5fcf733823b353b331c0ca30e8b71ba98c9cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRiNWZjZjczMzgyM2IzNTNiMzMxYzBjYTMwZThiNzFiYTk4YzljZg==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2019-06-18T05:08:02Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2019-06-18T05:08:02Z"}, "message": "Add predict_doloop_p target hook\n\n    Add one target hook predict_doloop_p, it return true if we can predict it\n    is possible to use a low-overhead loop, it can help ivopts to make some\n    better decisions.\n\n    PR middle-end/80791\n    * target.def (predict_doloop_p): New hook.\n    * targhooks.h (default_predict_doloop_p): New declaration.\n    * targhooks.c (default_predict_doloop_p): New function.\n    * doc/tm.texi.in (TARGET_PREDICT_DOLOOP_P): New hook.\n    * doc/tm.texi: Regenerate.\n    * config/rs6000/rs6000.c (rs6000_predict_doloop_p): New function.\n    (TARGET_PREDICT_DOLOOP_P): New macro.\n    * tree-ssa-loop-ivopts.c (generic_predict_doloop_p): New function.\n\nFrom-SVN: r272405", "tree": {"sha": "b9ed33a1d95fac033d35268b37e4cf0e4bcf2ca1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9ed33a1d95fac033d35268b37e4cf0e4bcf2ca1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74b5fcf733823b353b331c0ca30e8b71ba98c9cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74b5fcf733823b353b331c0ca30e8b71ba98c9cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74b5fcf733823b353b331c0ca30e8b71ba98c9cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "702eb490a864239256203b7fad53e397d3e7fa54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/702eb490a864239256203b7fad53e397d3e7fa54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/702eb490a864239256203b7fad53e397d3e7fa54"}], "stats": {"total": 127, "additions": 126, "deletions": 1}, "files": [{"sha": "9a46f93d89d2a4b898f10efb19f8ace5e0ba265d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74b5fcf733823b353b331c0ca30e8b71ba98c9cf", "patch": "@@ -1,3 +1,15 @@\n+2019-06-18  Kewen Lin  <linkw@gcc.gnu.org>\n+\n+\tPR middle-end/80791\n+\t* target.def (predict_doloop_p): New hook.\n+\t* targhooks.h (default_predict_doloop_p): New declaration.\n+\t* targhooks.c (default_predict_doloop_p): New function.\n+\t* doc/tm.texi.in (TARGET_PREDICT_DOLOOP_P): New hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* config/rs6000/rs6000.c (rs6000_predict_doloop_p): New function.\n+\t(TARGET_PREDICT_DOLOOP_P): New macro.\n+\t* tree-ssa-loop-ivopts.c (generic_predict_doloop_p): New function.\n+\n 2019-06-17  Jakub Jelinek  <jakub@redhat.com>\n \n \t* omp-low.c (struct omp_context): Add scan_inclusive field."}, {"sha": "07e00a9b593f2b99724ba4b3df59a98f75bcea8d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=74b5fcf733823b353b331c0ca30e8b71ba98c9cf", "patch": "@@ -1909,6 +1909,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_CAN_USE_DOLOOP_P\n #define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n \n+#undef TARGET_PREDICT_DOLOOP_P\n+#define TARGET_PREDICT_DOLOOP_P rs6000_predict_doloop_p\n+\n #undef TARGET_ATOMIC_ASSIGN_EXPAND_FENV\n #define TARGET_ATOMIC_ASSIGN_EXPAND_FENV rs6000_atomic_assign_expand_fenv\n \n@@ -39417,7 +39420,27 @@ rs6000_mangle_decl_assembler_name (tree decl, tree id)\n   return id;\n }\n \n-\f\n+/* Predict whether the given loop in gimple will be transformed in the RTL\n+   doloop_optimize pass.  */\n+\n+static bool\n+rs6000_predict_doloop_p (struct loop *loop)\n+{\n+  gcc_assert (loop);\n+\n+  /* On rs6000, targetm.can_use_doloop_p is actually\n+     can_use_doloop_if_innermost.  Just ensure the loop is innermost.  */\n+  if (loop->inner != NULL)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Predict doloop failure due to\"\n+\t\t\t    \" loop nesting.\\n\");\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-rs6000.h\""}, {"sha": "c2aa4d04777f3c30bd115512002639cea8dfc4e0", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=74b5fcf733823b353b331c0ca30e8b71ba98c9cf", "patch": "@@ -11610,6 +11610,14 @@ function version at run-time for a given set of function versions.\n body must be generated.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_PREDICT_DOLOOP_P (struct loop *@var{loop})\n+Return true if we can predict it is possible to use a low-overhead loop\n+for a particular loop.  The parameter @var{loop} is a pointer to the loop.\n+This target hook is required only when the target supports low-overhead\n+loops, and will help ivopts to make some decisions.\n+The default version of this hook returns false.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_CAN_USE_DOLOOP_P (const widest_int @var{&iterations}, const widest_int @var{&iterations_max}, unsigned int @var{loop_depth}, bool @var{entered_at_top})\n Return true if it is possible to use low-overhead loops (@code{doloop_end}\n and @code{doloop_begin}) for a particular loop.  @var{iterations} gives the"}, {"sha": "b4d57b86e2fb834973673bcde84cc80f599e9c50", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=74b5fcf733823b353b331c0ca30e8b71ba98c9cf", "patch": "@@ -7944,6 +7944,8 @@ to by @var{ce_info}.\n \n @hook TARGET_GENERATE_VERSION_DISPATCHER_BODY\n \n+@hook TARGET_PREDICT_DOLOOP_P\n+\n @hook TARGET_CAN_USE_DOLOOP_P\n \n @hook TARGET_INVALID_WITHIN_DOLOOP"}, {"sha": "71b69723b7587fe7e23d88ec994185db2ab82851", "filename": "gcc/target.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=74b5fcf733823b353b331c0ca30e8b71ba98c9cf", "patch": "@@ -4236,6 +4236,15 @@ DEFHOOK\n rtx, (machine_mode mode, rtx result, rtx val, rtx failval),\n  default_speculation_safe_value)\n  \n+DEFHOOK\n+(predict_doloop_p,\n+ \"Return true if we can predict it is possible to use a low-overhead loop\\n\\\n+for a particular loop.  The parameter @var{loop} is a pointer to the loop.\\n\\\n+This target hook is required only when the target supports low-overhead\\n\\\n+loops, and will help ivopts to make some decisions.\\n\\\n+The default version of this hook returns false.\",\n+ bool, (struct loop *loop),\n+ default_predict_doloop_p)\n \n DEFHOOK\n (can_use_doloop_p,"}, {"sha": "0da885ec1526937532b75289f729fb804c355f78", "filename": "gcc/targhooks.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=74b5fcf733823b353b331c0ca30e8b71ba98c9cf", "patch": "@@ -643,6 +643,19 @@ default_has_ifunc_p (void)\n   return HAVE_GNU_INDIRECT_FUNCTION;\n }\n \n+/* Return true if we predict the loop LOOP will be transformed to a\n+   low-overhead loop, otherwise return false.\n+\n+   By default, false is returned, as this hook's applicability should be\n+   verified for each target.  Target maintainers should re-define the hook\n+   if the target can take advantage of it.  */\n+\n+bool\n+default_predict_doloop_p (struct loop *loop ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n /* NULL if INSN insn is valid within a low-overhead loop, otherwise returns\n    an error message.\n "}, {"sha": "50b03ce3aa0dc0c8663972596fc08949e061548b", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=74b5fcf733823b353b331c0ca30e8b71ba98c9cf", "patch": "@@ -85,6 +85,7 @@ extern bool default_fixed_point_supported_p (void);\n \n extern bool default_has_ifunc_p (void);\n \n+extern bool default_predict_doloop_p (struct loop *);\n extern const char * default_invalid_within_doloop (const rtx_insn *);\n \n extern tree default_builtin_vectorized_function (unsigned int, tree, tree);"}, {"sha": "bbae83cbc6eaa432212a4c71463a449ee9a30b33", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b5fcf733823b353b331c0ca30e8b71ba98c9cf/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=74b5fcf733823b353b331c0ca30e8b71ba98c9cf", "patch": "@@ -3734,6 +3734,63 @@ prepare_decl_rtl (tree *expr_p, int *ws, void *data)\n   return NULL_TREE;\n }\n \n+/* Predict whether the given loop will be transformed in the RTL\n+   doloop_optimize pass.  Attempt to duplicate some doloop_optimize checks.\n+   This is only for target independent checks, see targetm.predict_doloop_p\n+   for the target dependent ones.\n+\n+   Note that according to some initial investigation, some checks like costly\n+   niter check and invalid stmt scanning don't have much gains among general\n+   cases, so keep this as simple as possible first.\n+\n+   Some RTL specific checks seems unable to be checked in gimple, if any new\n+   checks or easy checks _are_ missing here, please add them.  */\n+\n+static bool ATTRIBUTE_UNUSED\n+generic_predict_doloop_p (struct ivopts_data *data)\n+{\n+  struct loop *loop = data->current_loop;\n+\n+  /* Call target hook for target dependent checks.  */\n+  if (!targetm.predict_doloop_p (loop))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Predict doloop failure due to\"\n+\t\t\t    \" target specific checks.\\n\");\n+      return false;\n+    }\n+\n+  /* Similar to doloop_optimize, check iteration description to know it's\n+     suitable or not.  Keep it as simple as possible, feel free to extend it\n+     if you find any multiple exits cases matter.  */\n+  edge exit = single_dom_exit (loop);\n+  struct tree_niter_desc *niter_desc;\n+  if (!exit || !(niter_desc = niter_for_exit (data, exit)))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Predict doloop failure due to\"\n+\t\t\t    \" unexpected niters.\\n\");\n+      return false;\n+    }\n+\n+  /* Similar to doloop_optimize, check whether iteration count too small\n+     and not profitable.  */\n+  HOST_WIDE_INT est_niter = get_estimated_loop_iterations_int (loop);\n+  if (est_niter == -1)\n+    est_niter = get_likely_max_loop_iterations_int (loop);\n+  if (est_niter >= 0 && est_niter < 3)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Predict doloop failure due to\"\n+\t\t \" too few iterations (%u).\\n\",\n+\t\t (unsigned int) est_niter);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n /* Determines cost of the computation of EXPR.  */\n \n static unsigned"}]}