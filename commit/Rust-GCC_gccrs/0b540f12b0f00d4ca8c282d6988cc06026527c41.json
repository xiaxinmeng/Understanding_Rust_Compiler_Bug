{"sha": "0b540f12b0f00d4ca8c282d6988cc06026527c41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI1NDBmMTJiMGYwMGQ0Y2E4YzI4MmQ2OTg4Y2MwNjAyNjUyN2M0MQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-08-22T22:09:12Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-08-22T22:09:12Z"}, "message": "reload.c (find_reloads_address): Make return value tri-state.\n\n\t* reload.c (find_reloads_address): Make return value tri-state.\n\tReturn -1 if LEGITIMIZE_RELOAD_ADDRESS succeeded.\n\t(find_reloads): Assume that reloaded addresses match 'o' or\n\tEXTRA_MEMORY_CONSTRAINT constraints only if find_reloads_address\n\treturned 1 (not -1).  Omit optional reloads for address operands\n\tonly if find_reloads_address returned 1 (not -1).\n\n\t* config/s390/s390.c (legitimize_reload_address): New function.\n\t* config/s390/s390-protos.h (legitimize_reload_address): Declare.\n\t* config/s390/s390.h (LEGITIMIZE_RELOAD_ADDRESS): Define.  Call\n\tlegitimize_reload_address.\n\nFrom-SVN: r86388", "tree": {"sha": "aacc554b79463f2000c1ff1d2e71c98b7ddc340f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aacc554b79463f2000c1ff1d2e71c98b7ddc340f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b540f12b0f00d4ca8c282d6988cc06026527c41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b540f12b0f00d4ca8c282d6988cc06026527c41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b540f12b0f00d4ca8c282d6988cc06026527c41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b540f12b0f00d4ca8c282d6988cc06026527c41/comments", "author": null, "committer": null, "parents": [{"sha": "7f5e63076a3e596e2dd88825f0fe2659c20a5e84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f5e63076a3e596e2dd88825f0fe2659c20a5e84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f5e63076a3e596e2dd88825f0fe2659c20a5e84"}], "stats": {"total": 93, "additions": 85, "deletions": 8}, "files": [{"sha": "11d177860fd255bfdc8b9fd736aa6238fa0a4689", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b540f12b0f00d4ca8c282d6988cc06026527c41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b540f12b0f00d4ca8c282d6988cc06026527c41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b540f12b0f00d4ca8c282d6988cc06026527c41", "patch": "@@ -1,3 +1,17 @@\n+2004-08-22  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* reload.c (find_reloads_address): Make return value tri-state.\n+\tReturn -1 if LEGITIMIZE_RELOAD_ADDRESS succeeded.\n+\t(find_reloads): Assume that reloaded addresses match 'o' or\n+\tEXTRA_MEMORY_CONSTRAINT constraints only if find_reloads_address\n+\treturned 1 (not -1).  Omit optional reloads for address operands\n+\tonly if find_reloads_address returned 1 (not -1).\n+\n+\t* config/s390/s390.c (legitimize_reload_address): New function.\n+\t* config/s390/s390-protos.h (legitimize_reload_address): Declare.\n+\t* config/s390/s390.h (LEGITIMIZE_RELOAD_ADDRESS): Define.  Call\n+\tlegitimize_reload_address.\n+\n 2004-08-22  Richard Hendersion  <rth@redhat.com>\n \n \t* tree.h (SAVE_EXPR_RESOLVED_P): New."}, {"sha": "6f05d80d545ba8516144b7a98ea64600923e838c", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b540f12b0f00d4ca8c282d6988cc06026527c41/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b540f12b0f00d4ca8c282d6988cc06026527c41/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=0b540f12b0f00d4ca8c282d6988cc06026527c41", "patch": "@@ -65,6 +65,7 @@ extern int legitimate_reload_constant_p (rtx);\n extern int legitimate_address_p (enum machine_mode, rtx, int);\n extern rtx legitimize_pic_address (rtx, rtx);\n extern rtx legitimize_address (rtx, rtx, enum machine_mode);\n+extern rtx legitimize_reload_address (rtx, enum machine_mode, int, int);\n extern enum reg_class s390_preferred_reload_class (rtx, enum reg_class);\n extern enum reg_class s390_secondary_input_reload_class (enum reg_class,\n \t\t\t\t\t\t\t enum machine_mode,"}, {"sha": "06953ae776f809ee7e22aa00074d8c7bceb54676", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b540f12b0f00d4ca8c282d6988cc06026527c41/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b540f12b0f00d4ca8c282d6988cc06026527c41/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=0b540f12b0f00d4ca8c282d6988cc06026527c41", "patch": "@@ -3210,6 +3210,52 @@ legitimize_address (register rtx x, register rtx oldx ATTRIBUTE_UNUSED,\n   return x;\n }\n \n+/* Try a machine-dependent way of reloading an illegitimate address AD\n+   operand.  If we find one, push the reload and and return the new address.\n+\n+   MODE is the mode of the enclosing MEM.  OPNUM is the operand number\n+   and TYPE is the reload type of the current reload.  */\n+\n+rtx \n+legitimize_reload_address (rtx ad, enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t   int opnum, int type)\n+{\n+  if (!optimize || TARGET_LONG_DISPLACEMENT)\n+    return NULL_RTX;\n+\n+  if (GET_CODE (ad) == PLUS)\n+    {\n+      rtx tem = simplify_binary_operation (PLUS, Pmode,\n+\t\t\t\t\t   XEXP (ad, 0), XEXP (ad, 1));\n+      if (tem)\n+\tad = tem;\n+    }\n+\n+  if (GET_CODE (ad) == PLUS\n+      && GET_CODE (XEXP (ad, 0)) == REG\n+      && GET_CODE (XEXP (ad, 1)) == CONST_INT\n+      && !DISP_IN_RANGE (INTVAL (XEXP (ad, 1))))\n+    {\n+      HOST_WIDE_INT lower = INTVAL (XEXP (ad, 1)) & 0xfff;\n+      HOST_WIDE_INT upper = INTVAL (XEXP (ad, 1)) ^ lower;\n+      rtx cst, tem, new;\n+\n+      cst = GEN_INT (upper);\n+      if (!legitimate_reload_constant_p (cst))\n+\tcst = force_const_mem (Pmode, cst);\n+\n+      tem = gen_rtx_PLUS (Pmode, XEXP (ad, 0), cst);\n+      new = gen_rtx_PLUS (Pmode, tem, GEN_INT (lower));\n+\n+      push_reload (XEXP (tem, 1), 0, &XEXP (tem, 1), 0,\n+\t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, \n+\t\t   opnum, (enum reload_type) type);\n+      return new;\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n /* Emit code to move LEN bytes from DST to SRC.  */\n \n void"}, {"sha": "f361ce4d37409e060f50e341ef865f103bb6af0b", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b540f12b0f00d4ca8c282d6988cc06026527c41/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b540f12b0f00d4ca8c282d6988cc06026527c41/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=0b540f12b0f00d4ca8c282d6988cc06026527c41", "patch": "@@ -819,6 +819,19 @@ CUMULATIVE_ARGS;\n     goto WIN;                                                           \\\n }\n \n+/* Try a machine-dependent way of reloading an illegitimate address\n+   operand.  If we find one, push the reload and jump to WIN.  This\n+   macro is used in only one place: `find_reloads_address' in reload.c.  */\n+#define LEGITIMIZE_RELOAD_ADDRESS(AD, MODE, OPNUM, TYPE, IND, WIN)\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  rtx new = legitimize_reload_address (AD, MODE, OPNUM, (int)(TYPE));\t\\\n+  if (new)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      (AD) = new;\t\t\t\t\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n #define LEGITIMATE_CONSTANT_P(X) \\"}, {"sha": "260e4b7a3aaa7a94b9f25e3196fa7356082103ca", "filename": "gcc/reload.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b540f12b0f00d4ca8c282d6988cc06026527c41/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b540f12b0f00d4ca8c282d6988cc06026527c41/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0b540f12b0f00d4ca8c282d6988cc06026527c41", "patch": "@@ -2485,9 +2485,11 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n      a register.  */\n   enum reg_class preferred_class[MAX_RECOG_OPERANDS];\n   char pref_or_nothing[MAX_RECOG_OPERANDS];\n-  /* Nonzero for a MEM operand whose entire address needs a reload.  */\n+  /* Nonzero for a MEM operand whose entire address needs a reload. \n+     May be -1 to indicate the entire address may or may not need a reload.  */\n   int address_reloaded[MAX_RECOG_OPERANDS];\n-  /* Nonzero for an address operand that needs to be completely reloaded.  */\n+  /* Nonzero for an address operand that needs to be completely reloaded.\n+     May be -1 to indicate the entire operand may or may not need a reload.  */\n   int address_operand_reloaded[MAX_RECOG_OPERANDS];\n   /* Value of enum reload_type to use for operand.  */\n   enum reload_type operand_type[MAX_RECOG_OPERANDS];\n@@ -3180,7 +3182,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t  : offsettable_nonstrict_memref_p (operand))\n \t\t\t /* A reloaded address is offsettable because it is now\n \t\t\t    just a simple register indirect.  */\n-\t\t\t || address_reloaded[i]))\n+\t\t\t || address_reloaded[i] == 1))\n \t\t    || (REG_P (operand)\n \t\t\t&& REGNO (operand) >= FIRST_PSEUDO_REGISTER\n \t\t\t&& reg_renumber[REGNO (operand)] < 0\n@@ -3291,7 +3293,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t/* If the address was already reloaded,\n \t\t\t   we win as well.  */\n \t\t\telse if (MEM_P (operand)\n-\t\t\t\t && address_reloaded[i])\n+\t\t\t\t && address_reloaded[i] == 1)\n \t\t\t  win = 1;\n \t\t\t/* Likewise if the address will be reloaded because\n \t\t\t   reg_equiv_address is nonzero.  For reg_equiv_mem\n@@ -3891,7 +3893,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n       }\n     else if (goal_alternative_matched[i] < 0\n \t     && goal_alternative_matches[i] < 0\n-\t     && !address_operand_reloaded[i]\n+\t     && address_operand_reloaded[i] != 1\n \t     && optimize)\n       {\n \t/* For each non-matching operand that's a MEM or a pseudo-register\n@@ -4631,8 +4633,9 @@ maybe_memory_address_p (enum machine_mode mode, rtx ad, rtx *part)\n    to determine if we may generate output reloads, and where to put USEs\n    for pseudos that we have to replace with stack slots.\n \n-   Value is nonzero if this address is reloaded or replaced as a whole.\n-   This is interesting to the caller if the address is an autoincrement.\n+   Value is one if this address is reloaded or replaced as a whole; it is\n+   zero if the top level of this address was not reloaded or replaced, and\n+   it is -1 if it may or may not have been reloaded or replaced.\n \n    Note that there is no verification that the address will be valid after\n    this routine does its work.  Instead, we rely on the fact that the address\n@@ -4771,7 +4774,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n       *memrefloc = copy_rtx (*memrefloc);\n       XEXP (*memrefloc, 0) = ad;\n       move_replacements (&ad, &XEXP (*memrefloc, 0));\n-      return 1;\n+      return -1;\n     }\n   while (0);\n #endif"}]}