{"sha": "bd695e1e9d018a98de8d09bd855574dc6e183ad9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ2OTVlMWU5ZDAxOGE5OGRlOGQwOWJkODU1NTc0ZGM2ZTE4M2FkOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-11-05T00:35:10Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-11-05T00:35:10Z"}, "message": "function.c (diddle_return_value): New.\n\n        * function.c (diddle_return_value): New.\n        (expand_function_end): Use it.\n        * stmt.c (expand_null_return): Likewise.\n        (expand_value_return): Likewise.\n\n        * reg-stack.c (subst_stack_regs_pat): Handle clobbers at top-level.\n\n        * reload1.c (reload): Don't remove return value clobbers.\n\nFrom-SVN: r30401", "tree": {"sha": "3bf8e0ad4395b139c88e9c1ff7b7933ea4b1d9db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bf8e0ad4395b139c88e9c1ff7b7933ea4b1d9db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd695e1e9d018a98de8d09bd855574dc6e183ad9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd695e1e9d018a98de8d09bd855574dc6e183ad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd695e1e9d018a98de8d09bd855574dc6e183ad9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd695e1e9d018a98de8d09bd855574dc6e183ad9/comments", "author": null, "committer": null, "parents": [{"sha": "49886fe1cef61d4d3957033290d324dd27f7d389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49886fe1cef61d4d3957033290d324dd27f7d389", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49886fe1cef61d4d3957033290d324dd27f7d389"}], "stats": {"total": 172, "additions": 118, "deletions": 54}, "files": [{"sha": "145a329c37169c9dda96c68fb88a511a7d70b4a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd695e1e9d018a98de8d09bd855574dc6e183ad9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd695e1e9d018a98de8d09bd855574dc6e183ad9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd695e1e9d018a98de8d09bd855574dc6e183ad9", "patch": "@@ -1,3 +1,14 @@\n+Fri Nov  5 19:38:14 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* function.c (diddle_return_value): New.\n+\t(expand_function_end): Use it.\n+\t* stmt.c (expand_null_return): Likewise.\n+\t(expand_value_return): Likewise.\n+\n+\t* reg-stack.c (subst_stack_regs_pat): Handle clobbers at top-level.\n+\n+\t* reload1.c (reload): Don't remove return value clobbers.\n+\n Thu Nov  4 13:33:46 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* rtl.c (read_rtx): Use fatal_with_file_and_line not fatal.\n@@ -78,17 +89,17 @@ Wed Nov  3 14:51:59 1999  Mark P. Mitchell  <mark@codesourcery.com>\n \t\n Wed Nov  3 15:40:23 1999  Catherine Moore  <clm@cygnus.com>\n \n-        * defaults.h (ASM_OUTPUT_ALTERNATE_LABEL_NAME): Provide default.\n-        * emit-rtl.c (gen_label_rtx): Support LABEL_ALTERNATE_NAME.\n-        * final.c (final_scan_insn): Emit LABEL_ALTERNATE_NAME.\n-        * ggc-common.c (ggc_mark_rtx_children): Mark LABEL_ALTERNATE_NAME.\n-        * jump.c (delete_unreferenced_labels): Don't delete if\n-        LABEL_ALTERNATE_NAME is set.\n-        * print-rtl.c (print_rtx): Dump alternate name.\n-        * rtl.def (CODE_LABEL): Change format to \"iuuis00s\".\n-        * rtl.h (LABEL_ALTERNATE_NAME): Define.\n-        * rtl.texi (LABEL_ALTERNATE_NAME): Document.\n-        * tm.texi (ASM_OUTPUT_ALTERNATE_LABEL_NAME): Document.\n+\t* defaults.h (ASM_OUTPUT_ALTERNATE_LABEL_NAME): Provide default.\n+\t* emit-rtl.c (gen_label_rtx): Support LABEL_ALTERNATE_NAME.\n+\t* final.c (final_scan_insn): Emit LABEL_ALTERNATE_NAME.\n+\t* ggc-common.c (ggc_mark_rtx_children): Mark LABEL_ALTERNATE_NAME.\n+\t* jump.c (delete_unreferenced_labels): Don't delete if\n+\tLABEL_ALTERNATE_NAME is set.\n+\t* print-rtl.c (print_rtx): Dump alternate name.\n+\t* rtl.def (CODE_LABEL): Change format to \"iuuis00s\".\n+\t* rtl.h (LABEL_ALTERNATE_NAME): Define.\n+\t* rtl.texi (LABEL_ALTERNATE_NAME): Document.\n+\t* tm.texi (ASM_OUTPUT_ALTERNATE_LABEL_NAME): Document.\n \n Wed Nov  3 15:39:19 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n "}, {"sha": "0df0b82092d8a4aa03f16a0fabf1b9f1e5fa0a83", "filename": "gcc/function.c", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd695e1e9d018a98de8d09bd855574dc6e183ad9/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd695e1e9d018a98de8d09bd855574dc6e183ad9/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bd695e1e9d018a98de8d09bd855574dc6e183ad9", "patch": "@@ -6150,6 +6150,36 @@ expand_dummy_function_end ()\n   current_function = 0;\n }\n \n+/* Emit CODE for each register of the return value.  Useful values for\n+   code are USE and CLOBBER.  */\n+\n+void\n+diddle_return_value (code)\n+     enum rtx_code code;\n+{\n+  rtx return_reg = DECL_RTL (DECL_RESULT (current_function_decl));\n+\n+  if (return_reg)\n+    {\n+      if (GET_CODE (return_reg) == REG\n+\t  && REGNO (return_reg) < FIRST_PSEUDO_REGISTER)\n+\temit_insn (gen_rtx_fmt_e (code, VOIDmode, return_reg));\n+      else if (GET_CODE (return_reg) == PARALLEL)\n+\t{\n+\t  int i;\n+\n+\t  for (i = 0; i < XVECLEN (return_reg, 0); i++)\n+\t    {\n+\t      rtx x = XEXP (XVECEXP (return_reg, 0, i), 0);\n+\n+\t      if (GET_CODE (x) == REG\n+\t\t  && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+\t\temit_insn (gen_rtx_fmt_e (code, VOIDmode, x));\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Generate RTL for the end of the current function.\n    FILENAME and LINE are the current position in the source file. \n \n@@ -6332,7 +6362,16 @@ expand_function_end (filename, line, end_bindings)\n      structure returning.  */\n \n   if (return_label)\n-    emit_label (return_label);\n+    {\n+      /* Before the return label, clobber the return registers so that\n+         they are not propogated live to the rest of the function.  This\n+\t can only happen with functions that drop through; if there had\n+\t been a return statement, there would have either been a return\n+\t rtx, or a jump to the return label.  */\n+      diddle_return_value (CLOBBER);\n+\n+      emit_label (return_label);\n+    }\n \n   /* C++ uses this.  */\n   if (end_bindings)"}, {"sha": "f476bbee93736f1794d7c1c49b995b1faef8175e", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd695e1e9d018a98de8d09bd855574dc6e183ad9/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd695e1e9d018a98de8d09bd855574dc6e183ad9/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=bd695e1e9d018a98de8d09bd855574dc6e183ad9", "patch": "@@ -578,6 +578,10 @@ extern void free_expr_status\t\tPROTO((struct function *));\n \n extern rtx get_first_block_beg\t\tPROTO((void));\n \n+#ifdef RTX_CODE\n+extern void diddle_return_value\t\tPROTO((enum rtx_code));\n+#endif\n+\n extern void init_virtual_regs\t\tPROTO((struct emit_status *));\n \n /* Called once, at initialization, to initialize function.c.  */"}, {"sha": "4efaea1c73f59f8b330ebee915d04b6c0d849335", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd695e1e9d018a98de8d09bd855574dc6e183ad9/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd695e1e9d018a98de8d09bd855574dc6e183ad9/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=bd695e1e9d018a98de8d09bd855574dc6e183ad9", "patch": "@@ -1394,27 +1394,48 @@ subst_stack_regs_pat (insn, regstack, pat)\n       {\n \trtx note;\n \n-\t/* The fix_truncdi_1 pattern wants to be able to allocate it's\n-\t   own scratch register.  It does this by clobbering an fp reg\n-\t   so that it is assured of an empty reg-stack register.\n-\t   If the register is live, kill it now.  Remove the DEAD/UNUSED\n-\t   note so we don't try to kill it later too.  */\n-\n \tdest = get_true_reg (&XEXP (pat, 0));\n \tif (STACK_REG_P (*dest))\n \t  {\n \t    note = find_reg_note (insn, REG_DEAD, *dest);\n-\t    if (note)\n-\t      emit_pop_insn (insn, regstack, *dest, EMIT_BEFORE);\n-\t    else\n+\n+\t    if (pat != PATTERN (insn))\n \t      {\n-\t\tnote = find_reg_note (insn, REG_UNUSED, *dest);\n-\t\tif (!note)\n-\t\t  abort ();\n+\t\t/* The fix_truncdi_1 pattern wants to be able to allocate\n+\t\t   it's own scratch register.  It does this by clobbering\n+\t\t   an fp reg so that it is assured of an empty reg-stack\n+\t\t   register.  If the register is live, kill it now. \n+\t\t   Remove the DEAD/UNUSED note so we don't try to kill it\n+\t\t   later too.  */\n+\n+\t\tif (note)\n+\t\t  emit_pop_insn (insn, regstack, *dest, EMIT_BEFORE);\n+\t\telse\n+\t\t  {\n+\t\t    note = find_reg_note (insn, REG_UNUSED, *dest);\n+\t\t    if (!note)\n+\t\t      abort ();\n+\t\t  }\n+\t\tremove_note (insn, note);\n+\t\treplace_reg (dest, LAST_STACK_REG);\n \t      }\n+\t    else\n+\t      {\n+\t\t/* A top-level clobber with no REG_DEAD, and no hard-regnum\n+\t\t   indicates an uninitialized value.  Because reload removed\n+\t\t   all other clobbers, this must be due to a function \n+\t\t   returning without a value.  Load up a NaN.  */\n \n-\t    remove_note (insn, note);\n-\t    replace_reg (dest, LAST_STACK_REG);\n+\t\tif (! note\n+\t\t    && get_hard_regnum (regstack, *dest) == -1)\n+\t\t  {\n+\t\t    pat = gen_rtx_SET (VOIDmode,\n+\t\t\t\t       FP_MODE_REG (REGNO (*dest), SFmode),\n+\t\t\t\t       nan);\n+\t\t    PATTERN (insn) = pat;\n+\t\t    move_for_stack_reg (insn, regstack, pat);\n+\t\t  }\n+\t      }\n \t  }\n \tbreak;\n       }"}, {"sha": "2f50fb33c4d78d160ceb9b16578bbed18ac5e855", "filename": "gcc/reload1.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd695e1e9d018a98de8d09bd855574dc6e183ad9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd695e1e9d018a98de8d09bd855574dc6e183ad9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=bd695e1e9d018a98de8d09bd855574dc6e183ad9", "patch": "@@ -1106,13 +1106,12 @@ reload (first, global, dumpfile)\n      which are only valid during and after reload.  */\n   reload_completed = 1;\n \n-  /* Make a pass over all the insns and delete all USEs which we\n-     inserted only to tag a REG_EQUAL note on them.  Remove all\n-     REG_DEAD and REG_UNUSED notes.  Delete all CLOBBER insns and\n-     simplify (subreg (reg)) operands.  Also remove all REG_RETVAL and\n-     REG_LIBCALL notes since they are no longer useful or accurate.\n-     Strip and regenerate REG_INC notes that may have been moved\n-     around.  */\n+  /* Make a pass over all the insns and delete all USEs which we inserted\n+     only to tag a REG_EQUAL note on them.  Remove all REG_DEAD and REG_UNUSED\n+     notes.  Delete all CLOBBER insns that don't refer to the return value\n+     and simplify (subreg (reg)) operands.  Also remove all REG_RETVAL and\n+     REG_LIBCALL notes since they are no longer useful or accurate.  Strip\n+     and regenerate REG_INC notes that may have been moved around.  */\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n@@ -1121,7 +1120,9 @@ reload (first, global, dumpfile)\n \n \tif ((GET_CODE (PATTERN (insn)) == USE\n \t     && find_reg_note (insn, REG_EQUAL, NULL_RTX))\n-\t    || GET_CODE (PATTERN (insn)) == CLOBBER)\n+\t    || (GET_CODE (PATTERN (insn)) == CLOBBER\n+\t\t&& (GET_CODE (XEXP (PATTERN (insn), 0)) != REG\n+\t\t    || ! REG_FUNCTION_VALUE_P (XEXP (PATTERN (insn), 0)))))\n \t  {\n \t    PUT_CODE (insn, NOTE);\n \t    NOTE_SOURCE_FILE (insn) = 0;"}, {"sha": "f38b94fc942177c57894b0ad8eb2ab3e30c45c04", "filename": "gcc/stmt.c", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd695e1e9d018a98de8d09bd855574dc6e183ad9/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd695e1e9d018a98de8d09bd855574dc6e183ad9/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=bd695e1e9d018a98de8d09bd855574dc6e183ad9", "patch": "@@ -2665,7 +2665,13 @@ void\n expand_null_return ()\n {\n   struct nesting *block = block_stack;\n-  rtx last_insn = 0;\n+  rtx last_insn = get_last_insn ();\n+\n+  /* If this function was declared to return a value, but we \n+     didn't, clobber the return registers so that they are not\n+     propogated live to the rest of the function.  */\n+\n+  diddle_return_value (CLOBBER);\n \n   /* Does any pending block have cleanups?  */\n \n@@ -2710,25 +2716,7 @@ expand_value_return (val)\n \temit_move_insn (return_reg, val);\n     }\n \n-  if (GET_CODE (return_reg) == REG\n-      && REGNO (return_reg) < FIRST_PSEUDO_REGISTER)\n-    emit_insn (gen_rtx_USE (VOIDmode, return_reg));\n-\n-  /* Handle calls that return values in multiple non-contiguous locations.\n-     The Irix 6 ABI has examples of this.  */\n-  else if (GET_CODE (return_reg) == PARALLEL)\n-    {\n-      int i;\n-\n-      for (i = 0; i < XVECLEN (return_reg, 0); i++)\n-\t{\n-\t  rtx x = XEXP (XVECEXP (return_reg, 0, i), 0);\n-\n-\t  if (GET_CODE (x) == REG\n-\t      && REGNO (x) < FIRST_PSEUDO_REGISTER)\n-\t    emit_insn (gen_rtx_USE (VOIDmode, x));\n-\t}\n-    }\n+  diddle_return_value (USE);\n \n   /* Does any pending block have cleanups?  */\n "}]}