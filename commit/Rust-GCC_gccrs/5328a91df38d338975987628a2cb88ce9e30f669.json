{"sha": "5328a91df38d338975987628a2cb88ce9e30f669", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMyOGE5MWRmMzhkMzM4OTc1OTg3NjI4YTJjYjg4Y2U5ZTMwZjY2OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-21T14:45:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-21T14:45:41Z"}, "message": "[multiple changes]\n\n2011-11-21  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_imgv.adb (Expand_Width_Attribute): Handle case of\n\tDiscard_Names.\n\t* sem_attr.adb (Eval_Attribute, case Width): Ditto.\n\n2011-11-21  Thomas Quinot  <quinot@adacore.com>\n\n\t* sinfo.ads: Minor reformatting.\n\n2011-11-21  Yannick Moy  <moy@adacore.com>\n\n\t* exp_util.adb: Minor reformatting. Update comments.\n\nFrom-SVN: r181581", "tree": {"sha": "dab8f12c65357b2bffc32eba37c7d94f989d151b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dab8f12c65357b2bffc32eba37c7d94f989d151b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5328a91df38d338975987628a2cb88ce9e30f669", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5328a91df38d338975987628a2cb88ce9e30f669", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5328a91df38d338975987628a2cb88ce9e30f669", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5328a91df38d338975987628a2cb88ce9e30f669/comments", "author": null, "committer": null, "parents": [{"sha": "8a06151a7377c8175813ef6d587234553a47a0a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a06151a7377c8175813ef6d587234553a47a0a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a06151a7377c8175813ef6d587234553a47a0a5"}], "stats": {"total": 179, "additions": 146, "deletions": 33}, "files": [{"sha": "65cb5e92cf473018f0070ddd78386f6c28033bb9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5328a91df38d338975987628a2cb88ce9e30f669/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5328a91df38d338975987628a2cb88ce9e30f669/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5328a91df38d338975987628a2cb88ce9e30f669", "patch": "@@ -1,3 +1,17 @@\n+2011-11-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_imgv.adb (Expand_Width_Attribute): Handle case of\n+\tDiscard_Names.\n+\t* sem_attr.adb (Eval_Attribute, case Width): Ditto.\n+\n+2011-11-21  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sinfo.ads: Minor reformatting.\n+\n+2011-11-21  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_util.adb: Minor reformatting. Update comments.\n+\n 2011-11-21  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_prag.adb, exp_util.adb, sinfo.ads, sem_res.adb, s-stposu.adb,"}, {"sha": "14443b0ef887ba6bf866d6d8c0772e252f4fae1c", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 117, "deletions": 24, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5328a91df38d338975987628a2cb88ce9e30f669/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5328a91df38d338975987628a2cb88ce9e30f669/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=5328a91df38d338975987628a2cb88ce9e30f669", "patch": "@@ -27,7 +27,6 @@ with Atree;    use Atree;\n with Casing;   use Casing;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n-with Errout;   use Errout;\n with Exp_Util; use Exp_Util;\n with Lib;      use Lib;\n with Namet;    use Namet;\n@@ -246,7 +245,10 @@ package body Exp_Imgv is\n    --  Snn (1 .. Pnn) then occurs as in the other cases. A special case is\n    --  when pragma Discard_Names applies, in which case we replace expr by:\n \n-   --    Missing ???\n+   --     (rt'pos (expr))'Img\n+\n+   --  So that the result is a space followed by the decimal value for the\n+   --  position of the enumeration value in the enumeration type.\n \n    procedure Expand_Image_Attribute (N : Node_Id) is\n       Loc       : constant Source_Ptr := Sloc (N);\n@@ -369,7 +371,7 @@ package body Exp_Imgv is\n            or else No (Lit_Strings (Root_Type (Ptyp)))\n          then\n             --  When pragma Discard_Names applies to the first subtype, build\n-            --  (Pref'Pos)'Img.\n+            --  (Pref'Pos (Expr))'Img.\n \n             Rewrite (N,\n               Make_Attribute_Reference (Loc,\n@@ -1056,9 +1058,14 @@ package body Exp_Imgv is\n    --                   typ'Pos (Typ'Last))\n    --                   Wide_Character_Encoding_Method);\n \n-   --  where typS and typI are the enumeration image strings and\n-   --  indexes table, as described in Build_Enumeration_Image_Tables.\n-   --  NN is 8/16/32 for depending on the element type for typI.\n+   --  where typS and typI are the enumeration image strings and indexes\n+   --  table, as described in Build_Enumeration_Image_Tables. NN is 8/16/32\n+   --  for depending on the element type for typI.\n+\n+   --  Finally if Discard_Names is in effect for an enumeration type, then\n+   --  a special conditional expression is built that yields the space needed\n+   --  for the decimal representation of the largest pos value in the subtype.\n+   --  See code below for details.\n \n    procedure Expand_Width_Attribute (N : Node_Id; Attr : Atype := Normal) is\n       Loc     : constant Source_Ptr := Sloc (N);\n@@ -1126,7 +1133,6 @@ package body Exp_Imgv is\n       --  Real types\n \n       elsif Is_Real_Type (Rtyp) then\n-\n          Rewrite (N,\n            Make_Conditional_Expression (Loc,\n              Expressions => New_List (\n@@ -1156,29 +1162,116 @@ package body Exp_Imgv is\n       else\n          pragma Assert (Is_Enumeration_Type (Rtyp));\n \n-         --  Whenever pragma Discard_Names is in effect, it suppresses the\n-         --  generation of string literals for enumeration types. Since the\n-         --  literals are required to evaluate the 'Width of an enumeration\n-         --  type, emit an error.\n+         --  Whenever pragma Discard_Names is in effect, the value we need\n+         --  is the value needed to accomodate the largest integer pos value\n+         --  in the range of the subtype + 1 for the space at the start. We\n+         --  build:\n \n-         --  ??? This is fine for configurable runtimes, but dubious in the\n-         --  general case. For now keep both error messages until this issue\n-         --  has been verified with the ARG.\n+         --     Tnn : constant Integer := Rtyp'Pos (Ptyp'Last)\n \n-         if Discard_Names (Rtyp) then\n-            Error_Msg_Name_1 := Attribute_Name (N);\n+         --  and replace the expression by\n \n-            if Configurable_Run_Time_Mode then\n-               Error_Msg_N (\"attribute % not supported in configurable \" &\n-                            \"run-time mode\", N);\n-            else\n-               Error_Msg_N (\"attribute % not supported when pragma \" &\n-                            \"Discard_Names is in effect\", N);\n-            end if;\n+         --     (if Ptyp'Range_Length = 0 then 0\n+         --      else (if Tnn < 10 then 2\n+         --            else (if Tnn < 100 then 3\n+         --                  ...\n+         --                      else n)))...\n \n-            return;\n+         --  where n is equal to Rtyp'Pos (Rtyp'Last) + 1\n+\n+         --  Note: The above processing is in accordance with the intent of\n+         --  the RM, which is that Width should be related to the impl-defined\n+         --  behavior of Image. It is not clear what this means if Image is\n+         --  not defined (as in the configurable run-time case for GNAT) and\n+         --  gives an error at compile time.\n+\n+         --  We choose in this case to just go ahead and implement Width the\n+         --  same way, returning what Image would have returned if it has been\n+         --  available in the configurable run-time library.\n+\n+         if Discard_Names (Rtyp) then\n+            declare\n+               Tnn : constant Entity_Id :=\n+                       Make_Defining_Identifier (Loc,\n+                         Chars => New_Internal_Name ('T'));\n+\n+               Cexpr : Node_Id;\n+               P     : Int;\n+               M     : Int;\n+               K     : Int;\n+\n+            begin\n+               Insert_Action (N,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Tnn,\n+                   Constant_Present    => True,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Standard_Integer, Loc),\n+                   Expression =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix            => New_Occurrence_Of (Rtyp, Loc),\n+                       Attribute_Name    => Name_Pos,\n+                       Expressions       => New_List (\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix            => New_Occurrence_Of (Ptyp, Loc),\n+                           Attribute_Name    => Name_Last)))));\n+\n+               --  OK, now we need to build the conditional expression. First\n+               --  get the value of M, the largest possible value needed.\n+\n+               P := UI_To_Int\n+                      (Enumeration_Pos (Entity (Type_High_Bound (Rtyp))));\n+\n+               K := 1;\n+               M := 1;\n+               while M < P loop\n+                  M := M * 10;\n+                  K := K + 1;\n+               end loop;\n+\n+               --  Build inner else\n+\n+               Cexpr := Make_Integer_Literal (Loc, K);\n+\n+               --  Wrap in inner if's until counted down to 2\n+\n+               while K > 2 loop\n+                  M := M / 10;\n+                  K := K - 1;\n+\n+                  Cexpr :=\n+                    Make_Conditional_Expression (Loc,\n+                      Expressions => New_List (\n+                        Make_Op_Lt (Loc,\n+                          Left_Opnd  => New_Occurrence_Of (Tnn, Loc),\n+                          Right_Opnd => Make_Integer_Literal (Loc, M)),\n+                        Make_Integer_Literal (Loc, K),\n+                        Cexpr));\n+               end loop;\n+\n+               --  Add initial comparison for null range and we are done, so\n+               --  rewrite the attribute occurrence with this expression.\n+\n+               Rewrite (N,\n+                 Convert_To (Typ,\n+                   Make_Conditional_Expression (Loc,\n+                     Expressions => New_List (\n+                       Make_Op_Eq (Loc,\n+                         Left_Opnd  =>\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix         => New_Occurrence_Of (Ptyp, Loc),\n+                             Attribute_Name => Name_Range_Length),\n+                         Right_Opnd => Make_Integer_Literal (Loc, 0)),\n+                       Make_Integer_Literal (Loc, 0),\n+                       Cexpr))));\n+\n+               Analyze_And_Resolve (N, Typ);\n+               return;\n+            end;\n          end if;\n \n+         --  Normal case, not Discard_Names\n+\n          Ttyp := Component_Type (Etype (Lit_Indexes (Rtyp)));\n \n          case Attr is"}, {"sha": "83506f08ff7cb71baa25cd0945b0da01e7dfccec", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5328a91df38d338975987628a2cb88ce9e30f669/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5328a91df38d338975987628a2cb88ce9e30f669/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=5328a91df38d338975987628a2cb88ce9e30f669", "patch": "@@ -6420,23 +6420,29 @@ package body Exp_Util is\n    --  Start of processing for Remove_Side_Effects\n \n    begin\n-      --  Handle cases in which there is nothing to do. In particular,\n-      --  side-effects are not removed in Alfa mode for formal verification.\n-      --  Instead, formal verification is performed only on those expressions\n-      --  provably side-effect free.\n-\n-      --  Why? Is the Alfa mode test just an optimization? Most likely not,\n-      --  most likely it is functionally necessary, if so why ???\n+      --  We only need to do removal of side effects if we are generating\n+      --  actual code. That's because the whole issue of side effects is purely\n+      --  a run-time issue, and the removal is required only to get proper\n+      --  behavior at run-time.\n+\n+      --  In the Alfa case, we don't need to remove side effects because we\n+      --  only perform formal verification is performed only on expressions\n+      --  that are provably side-effect free. If we tried to remove side\n+      --  effects in the Alfa case, we would get into a mess since in the case\n+      --  of limited types in particular, removal of side effects involves the\n+      --  use of access types or references which are not permitted in Alfa\n+      --  mode.\n \n       if not Full_Expander_Active then\n          return;\n+      end if;\n \n       --  Cannot generate temporaries if the invocation to remove side effects\n       --  was issued too early and the type of the expression is not resolved\n       --  (this happens because routines Duplicate_Subexpr_XX implicitly invoke\n       --  Remove_Side_Effects).\n \n-      elsif No (Exp_Type)\n+      if No (Exp_Type)\n         or else Ekind (Exp_Type) = E_Access_Attribute_Type\n       then\n          return;"}, {"sha": "7e308ec328e15389dc8e8b2d63112bffa6154969", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5328a91df38d338975987628a2cb88ce9e30f669/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5328a91df38d338975987628a2cb88ce9e30f669/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=5328a91df38d338975987628a2cb88ce9e30f669", "patch": "@@ -761,7 +761,7 @@ package Sinfo is\n    --    if there is no corresponding spec, as in the case of a subprogram body\n    --    that serves as its own spec.\n    --\n-   --    In Ada2012, Corresponding_Spec is set on expression functions that\n+   --    In Ada 2012, Corresponding_Spec is set on expression functions that\n    --    complete a subprogram declaration.\n \n    --  Corresponding_Stub (Node3-Sem)"}]}