{"sha": "7964ab6c364c410c34efe7ca2eba797d36525349", "node_id": "C_kwDOANBUbNoAKDc5NjRhYjZjMzY0YzQxMGMzNGVmZTdjYTJlYmE3OTdkMzY1MjUzNDk", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-04-22T20:52:50Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-04-22T20:52:50Z"}, "message": "fortran: Use pointer arithmetic to index arrays [PR102043]\n\nThe code generated for array references used to be ARRAY_REF trees as\ncould be expected.  However, the middle-end may conclude from those\ntrees that the indexes used are non-negative (more precisely not below\nthe lower bound), which is a wrong assumption in the case of \"reversed-\norder\" arrays.\n\nThe problematic arrays are those with a descriptor and having a negative\nstride for at least one dimension.  The descriptor data points to the\nfirst element in array order (which is not the first in memory order in\nthat case), and the negative stride(s) makes walking the array backwards\n(towards lower memory addresses), and we can access elements with\nnegative index wrt data pointer.\n\nWith this change, pointer arithmetic is generated by default for array\nreferences, unless we are in a case where negative indexes can\u2019t happen\n(array descriptor\u2019s dim element, substrings, explicit shape,\nallocatable, or assumed shape contiguous).  A new flag is added to\nchoose between array indexing and pointer arithmetic, and it\u2019s set\nif the context can tell array indexing is safe (descriptor dim\nelement, substring, temporary array), or a new method is called\nto decide on whether the flag should be set for one given array\nexpression.\n\n\tPR fortran/102043\n\ngcc/fortran/ChangeLog:\n\n\t* trans.h (gfc_build_array_ref): Add non_negative_offset\n\targument.\n\t* trans.cc (gfc_build_array_ref): Ditto. Use pointer arithmetic\n\tif non_negative_offset is false.\n\t* trans-expr.cc (gfc_conv_substring): Set flag in the call to\n\tgfc_build_array_ref.\n\t* trans-array.cc (gfc_get_cfi_dim_item,\n\tgfc_conv_descriptor_dimension): Same.\n\t(build_array_ref): Decide on whether to set the flag and update\n\tthe call.\n\t(gfc_conv_scalarized_array_ref): Same.  New argument tmp_array.\n\t(gfc_conv_tmp_array_ref): Update call to\n\tgfc_conv_scalarized_ref.\n\t(non_negative_strides_array_p): New function.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/array_reference_3.f90: New.\n\t* gfortran.dg/negative_stride_1.f90: New.\n\t* gfortran.dg/vector_subscript_8.f90: New.\n\t* gfortran.dg/vector_subscript_9.f90: New.\n\t* gfortran.dg/c_loc_test_22.f90: Update dump patterns.\n\t* gfortran.dg/finalize_10.f90: Same.\n\nCo-Authored-By: Richard Biener <rguenther@suse.de>", "tree": {"sha": "14d6772bc609d489a89758648820419d0014da7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14d6772bc609d489a89758648820419d0014da7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7964ab6c364c410c34efe7ca2eba797d36525349", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7964ab6c364c410c34efe7ca2eba797d36525349", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7964ab6c364c410c34efe7ca2eba797d36525349", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7964ab6c364c410c34efe7ca2eba797d36525349/comments", "author": null, "committer": null, "parents": [{"sha": "761dda57482295f9c41fcf87e5defa2ac1959f03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/761dda57482295f9c41fcf87e5defa2ac1959f03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/761dda57482295f9c41fcf87e5defa2ac1959f03"}], "stats": {"total": 369, "additions": 354, "deletions": 15}, "files": [{"sha": "e4b6270ccf8572ba2c5fb8657ec13950fca78b77", "filename": "gcc/fortran/trans-array.cc", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ffortran%2Ftrans-array.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ffortran%2Ftrans-array.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.cc?ref=7964ab6c364c410c34efe7ca2eba797d36525349", "patch": "@@ -172,7 +172,7 @@ static tree\n gfc_get_cfi_dim_item (tree desc, tree idx, unsigned field_idx)\n {\n   tree tmp = gfc_get_cfi_descriptor_field (desc, CFI_FIELD_DIM);\n-  tmp = gfc_build_array_ref (tmp, idx, NULL);\n+  tmp = gfc_build_array_ref (tmp, idx, NULL_TREE, true);\n   tree field = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (tmp)), field_idx);\n   gcc_assert (field != NULL_TREE);\n   return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n@@ -424,7 +424,7 @@ gfc_conv_descriptor_dimension (tree desc, tree dim)\n \n   tmp = gfc_get_descriptor_dimension (desc);\n \n-  return gfc_build_array_ref (tmp, dim, NULL);\n+  return gfc_build_array_ref (tmp, dim, NULL_TREE, true);\n }\n \n \n@@ -3664,10 +3664,51 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n }\n \n \n+/* Indicates that the tree EXPR is a reference to an array that can\u2019t\n+   have any negative stride.  */\n+\n+static bool\n+non_negative_strides_array_p (tree expr)\n+{\n+  if (expr == NULL_TREE)\n+    return false;\n+\n+  tree type = TREE_TYPE (expr);\n+  if (POINTER_TYPE_P (type))\n+    type = TREE_TYPE (type);\n+\n+  if (TYPE_LANG_SPECIFIC (type))\n+    {\n+      gfc_array_kind array_kind = GFC_TYPE_ARRAY_AKIND (type);\n+\n+      if (array_kind == GFC_ARRAY_ALLOCATABLE\n+\t  || array_kind == GFC_ARRAY_ASSUMED_SHAPE_CONT)\n+\treturn true;\n+    }\n+\n+  /* An array with descriptor can have negative strides.\n+     We try to be conservative and return false by default here\n+     if we don\u2019t recognize a contiguous array instead of\n+     returning false if we can identify a non-contiguous one.  */\n+  if (!GFC_ARRAY_TYPE_P (type))\n+    return false;\n+\n+  /* If the array was originally a dummy with a descriptor, strides can be\n+     negative.  */\n+  if (DECL_P (expr)\n+      && DECL_LANG_SPECIFIC (expr))\n+    if (tree orig_decl = GFC_DECL_SAVED_DESCRIPTOR (expr))\n+      return non_negative_strides_array_p (orig_decl);\n+\n+  return true;\n+}\n+\n+\n /* Build a scalarized reference to an array.  */\n \n static void\n-gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n+gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar,\n+\t\t\t       bool tmp_array = false)\n {\n   gfc_array_info *info;\n   tree decl = NULL_TREE;\n@@ -3717,7 +3758,10 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n \tdecl = info->descriptor;\n     }\n \n-  se->expr = gfc_build_array_ref (base, index, decl);\n+  bool non_negative_stride = tmp_array\n+\t\t\t     || non_negative_strides_array_p (info->descriptor);\n+  se->expr = gfc_build_array_ref (base, index, decl,\n+\t\t\t\t  non_negative_stride);\n }\n \n \n@@ -3727,7 +3771,7 @@ void\n gfc_conv_tmp_array_ref (gfc_se * se)\n {\n   se->string_length = se->ss->info->string_length;\n-  gfc_conv_scalarized_array_ref (se, NULL);\n+  gfc_conv_scalarized_array_ref (se, NULL, true);\n   gfc_advance_se_ss_chain (se);\n }\n \n@@ -3779,7 +3823,9 @@ build_array_ref (tree desc, tree offset, tree decl, tree vptr)\n \n   tmp = gfc_conv_array_data (desc);\n   tmp = build_fold_indirect_ref_loc (input_location, tmp);\n-  tmp = gfc_build_array_ref (tmp, offset, decl, vptr);\n+  tmp = gfc_build_array_ref (tmp, offset, decl,\n+\t\t\t     non_negative_strides_array_p (desc),\n+\t\t\t     vptr);\n   return tmp;\n }\n "}, {"sha": "850007fd2e14da21c39e075d55904a25627e552e", "filename": "gcc/fortran/trans-expr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ffortran%2Ftrans-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ffortran%2Ftrans-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.cc?ref=7964ab6c364c410c34efe7ca2eba797d36525349", "patch": "@@ -2612,7 +2612,7 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       /* For BIND(C), a BT_CHARACTER is not an ARRAY_TYPE.  */\n       if (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE)\n \t{\n-\t  tmp = gfc_build_array_ref (tmp, start.expr, NULL);\n+\t  tmp = gfc_build_array_ref (tmp, start.expr, NULL_TREE, true);\n \t  se->expr = gfc_build_addr_expr (type, tmp);\n \t}\n     }"}, {"sha": "f0a5dfb50fc60a913c5930254b58be1ffed02ff1", "filename": "gcc/fortran/trans.cc", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ffortran%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ffortran%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.cc?ref=7964ab6c364c410c34efe7ca2eba797d36525349", "patch": "@@ -446,10 +446,14 @@ gfc_build_spanned_array_ref (tree base, tree offset, tree span)\n }\n \n \n-/* Build an ARRAY_REF with its natural type.  */\n+/* Build an ARRAY_REF with its natural type.\n+   NON_NEGATIVE_OFFSET indicates if it\u2019s true that OFFSET can\u2019t be negative,\n+   and thus that an ARRAY_REF can safely be generated.  If it\u2019s false, we\n+   have to play it safe and use pointer arithmetic.  */\n \n tree\n-gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n+gfc_build_array_ref (tree base, tree offset, tree decl,\n+\t\t     bool non_negative_offset, tree vptr)\n {\n   tree type = TREE_TYPE (base);\n   tree span = NULL_TREE;\n@@ -495,10 +499,40 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n      pointer arithmetic.  */\n   if (span != NULL_TREE)\n     return gfc_build_spanned_array_ref (base, offset, span);\n-  /* Otherwise use a straightforward array reference.  */\n-  else\n+  /* Else use a straightforward array reference if possible.  */\n+  else if (non_negative_offset)\n     return build4_loc (input_location, ARRAY_REF, type, base, offset,\n \t\t       NULL_TREE, NULL_TREE);\n+  /* Otherwise use pointer arithmetic.  */\n+  else\n+    {\n+      gcc_assert (TREE_CODE (TREE_TYPE (base)) == ARRAY_TYPE);\n+      tree min = NULL_TREE;\n+      if (TYPE_DOMAIN (TREE_TYPE (base))\n+\t  && !integer_zerop (TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (base)))))\n+\tmin = TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (base)));\n+\n+      tree zero_based_index\n+\t   = min ? fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t    gfc_array_index_type,\n+\t\t\t\t    fold_convert (gfc_array_index_type, offset),\n+\t\t\t\t    fold_convert (gfc_array_index_type, min))\n+\t\t : fold_convert (gfc_array_index_type, offset);\n+\n+      tree elt_size = fold_convert (gfc_array_index_type,\n+\t\t\t\t    TYPE_SIZE_UNIT (type));\n+\n+      tree offset_bytes = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t   gfc_array_index_type,\n+\t\t\t\t\t   zero_based_index, elt_size);\n+\n+      tree base_addr = gfc_build_addr_expr (pvoid_type_node, base);\n+\n+      tree ptr = fold_build_pointer_plus_loc (input_location, base_addr,\n+\t\t\t\t\t      offset_bytes);\n+      return build1_loc (input_location, INDIRECT_REF, type,\n+\t\t\t fold_convert (build_pointer_type (type), ptr));\n+    }\n }\n \n "}, {"sha": "623aceed52052fe810d064d943bcd8b4c004cae3", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=7964ab6c364c410c34efe7ca2eba797d36525349", "patch": "@@ -619,7 +619,9 @@ tree gfc_get_extern_function_decl (gfc_symbol *,\n tree gfc_build_addr_expr (tree, tree);\n \n /* Build an ARRAY_REF.  */\n-tree gfc_build_array_ref (tree, tree, tree, tree vptr = NULL_TREE);\n+tree gfc_build_array_ref (tree, tree, tree,\n+\t\t\t  bool non_negative_offset = false,\n+\t\t\t  tree vptr = NULL_TREE);\n \n /* Build an array ref using pointer arithmetic.  */\n tree gfc_build_spanned_array_ref (tree base, tree offset, tree span);"}, {"sha": "85fa3317d985c22fc0adaffcd51b3107c901d6bf", "filename": "gcc/testsuite/gfortran.dg/array_reference_3.f90", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_reference_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_reference_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_reference_3.f90?ref=7964ab6c364c410c34efe7ca2eba797d36525349", "patch": "@@ -0,0 +1,195 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/102043\n+! Array indexing was causing the middle-end to conclude the index\n+! to be non-negative, which can be wrong for arrays with a \"reversed-order\"\n+! descriptor.  This was fixed by using pointer arithmetic when\n+! the index can be negative.\n+! \n+! This test checks the code generated for array references of various kinds\n+! of arrays, using either array indexing or pointer arithmetic.\n+\n+program p\n+  implicit none\n+  call check_assumed_shape_elem\n+  call check_assumed_shape_scalarized\n+  call check_descriptor_dim\n+  call check_cfi_dim\n+  call check_substring\n+  call check_ptr_elem\n+  call check_ptr_scalarized\n+  call check_explicit_shape_elem\n+  call check_explicit_shape_scalarized\n+  call check_tmp_array\n+  call check_allocatable_array_elem\n+  call check_allocatable_array_scalarized\n+contains\n+  subroutine cases(assumed_shape_x)\n+    integer :: assumed_shape_x(:)\n+    assumed_shape_x(2) = 10\n+  end subroutine cases \n+  subroutine check_assumed_shape_elem\n+    integer :: x(3)\n+    x = 0\n+    call cases(x)\n+    if (any(x /= (/ 0, 10, 0 /))) stop 10\n+    ! Assumed shape array are referenced with pointer arithmetic.\n+    ! { dg-final { scan-tree-dump-times \"\\\\*\\\\(\\\\(integer\\\\(kind=4\\\\) \\\\*\\\\) assumed_shape_x.\\\\d+ \\\\+ \\\\(sizetype\\\\) \\\\(\\\\(stride.\\\\d+ \\\\* 2 \\\\+ offset.\\\\d+\\\\) \\\\* 4\\\\)\\\\) = 10;\" 1 \"original\" } }\n+  end subroutine check_assumed_shape_elem\n+  subroutine casss(assumed_shape_y)\n+    integer :: assumed_shape_y(:)\n+    assumed_shape_y = 11\n+  end subroutine casss \n+  subroutine check_assumed_shape_scalarized\n+    integer :: y(3)\n+    call casss(y)\n+    if (any(y /= 11)) stop 11\n+    ! Assumed shape array are referenced with pointer arithmetic.\n+    ! { dg-final { scan-tree-dump-times \"\\\\*\\\\(\\\\(integer\\\\(kind=4\\\\) \\\\*\\\\) assumed_shape_y.\\\\d+ \\\\+ \\\\(sizetype\\\\) \\\\(\\\\(S.\\\\d+ \\\\* D.\\\\d+ \\\\+ D.\\\\d+\\\\) \\\\* 4\\\\)\\\\) = 11;\" 1 \"original\" } }\n+  end subroutine check_assumed_shape_scalarized\n+  subroutine check_descriptor_dim\n+    integer, allocatable :: descriptor(:)\n+    allocate(descriptor(4))\n+    descriptor(:) = 12\n+    if (any(descriptor /= 12)) stop 12\n+    ! The descriptor\u2019s dim array is referenced with array indexing.\n+    ! { dg-final { scan-tree-dump-times \"descriptor\\\\.dim\\\\\\[0\\\\\\]\\\\.ubound = 4;\" 1 \"original\" } }\n+  end subroutine check_descriptor_dim\n+  subroutine ccfis(cfi_descriptor) bind(c)\n+    integer :: cfi_descriptor(:)\n+    cfi_descriptor = 13\n+  end subroutine ccfis \n+  subroutine check_cfi_dim \n+    integer :: x(5)\n+    call ccfis(x)\n+    if (any(x /= 13)) stop 13\n+    ! The cfi descriptor\u2019s dim array is referenced with array indexing.\n+    ! { dg-final { scan-tree-dump-times \"cfi_descriptor->dim\\\\\\[idx.\\\\d+\\\\\\]\\\\.ubound = _cfi_descriptor->dim\\\\\\[idx.\\\\d+\\\\\\]\\\\.extent \\\\+ \\\\(cfi_descriptor->dim\\\\\\[idx.\\\\d+\\\\\\]\\\\.lbound \\\\+ -1\\\\);\" 1 \"original\" } }\n+  end subroutine check_cfi_dim\n+  subroutine css(c) bind(c)\n+    character :: c\n+    c = 'k'\n+  end subroutine css\n+  subroutine check_substring\n+    character(5) :: x\n+    x = 'abcde'\n+    call css(x(3:3))\n+    if (x /= 'abkde') stop 14\n+    ! Substrings use array indexing\n+    ! { dg-final { scan-tree-dump-times \"css \\\\(\\\\(character\\\\(kind=1\\\\)\\\\\\[\\\\d+:\\\\d+\\\\\\] \\\\*\\\\) &x\\\\\\[3\\\\\\].lb: \\\\d+ sz: \\\\d+.\\\\);\" 1 \"original\" } }\n+  end subroutine check_substring\n+  subroutine check_ptr_elem\n+    integer, target :: x(7)\n+    integer, pointer :: ptr_x(:)\n+    x = 0\n+    ptr_x => x\n+    ptr_x(4) = 16\n+    if (any(ptr_x /= (/ 0, 0, 0, 16, 0, 0, 0 /))) stop 16\n+    ! pointers are referenced with pointer arithmetic.\n+    ! { dg-final { scan-tree-dump-times \"\\\\*\\\\(integer\\\\(kind=4\\\\) \\\\*\\\\) \\\\(ptr_x\\\\.data \\\\+ \\\\(sizetype\\\\) \\\\(\\\\(ptr_x\\\\.offset \\\\+ ptr_x\\\\.dim\\\\\\[0\\\\\\]\\\\.stride \\\\* 4\\\\) \\\\* ptr_x\\\\.span\\\\)\\\\) = 16;\" 1 \"original\" } }\n+  end subroutine check_ptr_elem\n+  subroutine check_ptr_scalarized\n+    integer, target :: y(8)\n+    integer, pointer :: ptr_y(:)\n+    y = 0\n+    ptr_y => y\n+    ptr_y = 17\n+    if (any(ptr_y /= 17)) stop 17\n+    ! pointers are referenced with pointer arithmetic.\n+    ! { dg-final { scan-tree-dump-times \"\\\\*\\\\(\\\\(integer\\\\(kind=4\\\\) \\\\*\\\\) D.\\\\d+ \\\\+ \\\\(sizetype\\\\) \\\\(\\\\(S.\\\\d+ \\\\* D.\\\\d+ \\\\+ D.\\\\d+\\\\) \\\\* ptr_y\\\\.span\\\\)\\\\) = 17;\" 1 \"original\" } }\n+  end subroutine check_ptr_scalarized\n+  subroutine check_explicit_shape_elem\n+    integer :: explicit_shape_x(9)\n+    explicit_shape_x = 0\n+    explicit_shape_x(5) = 18\n+    if (any(explicit_shape_x /= (/ 0, 0, 0, 0, 18, 0, 0, 0, 0 /))) stop 18\n+    ! Explicit shape arrays are referenced with array indexing.\n+    ! { dg-final { scan-tree-dump-times \"explicit_shape_x\\\\\\[4\\\\\\] = 18;\" 1 \"original\" } }\n+  end subroutine check_explicit_shape_elem\n+  subroutine check_explicit_shape_scalarized\n+    integer :: explicit_shape_y(3)\n+    explicit_shape_y = 19\n+    if (any(explicit_shape_y /= 19)) stop 19\n+    ! Explicit shape arrays are referenced with array indexing.\n+    ! { dg-final { scan-tree-dump-times \"explicit_shape_y\\\\\\[S.\\\\d+ \\\\+ -1\\\\\\] = 19;\" 1 \"original\" } }\n+  end subroutine check_explicit_shape_scalarized\n+  subroutine check_tmp_array\n+    integer :: non_tmp(6)\n+    non_tmp = 15\n+    non_tmp(2:5) = non_tmp(1:4) + non_tmp(3:6)\n+    if (any(non_tmp /= (/ 15, 30, 30, 30, 30, 15 /))) stop 15\n+    ! temporary arrays use array indexing\n+    ! { dg-final { scan-tree-dump-times \"\\\\(*\\\\(integer\\\\(kind=4\\\\)\\\\\\[4\\\\\\] \\\\* restrict\\\\) atmp.\\\\d+\\\\.data\\\\)\\\\\\[S.\\\\d+\\\\\\] = non_tmp\\\\\\[S.\\\\d+\\\\\\] \\\\+ non_tmp\\\\\\[S.\\\\d+ \\\\+ 2\\\\\\];\" 1 \"original\" } }\n+    ! { dg-final { scan-tree-dump-times \"non_tmp\\\\\\[S.\\\\d+ \\\\+ 1\\\\\\] = \\\\(\\\\*\\\\(integer\\\\(kind=4\\\\)\\\\\\[4\\\\\\] \\\\* restrict\\\\) atmp.\\\\d+\\\\.data\\\\)\\\\\\[S.\\\\d+\\\\\\];\" 1 \"original\" } }\n+  end subroutine check_tmp_array\n+  subroutine check_allocatable_array_elem\n+    integer, allocatable :: allocatable_x(:)\n+    allocate(allocatable_x(4),source=0)\n+    allocatable_x(2) = 20\n+    if (any(allocatable_x /= (/ 0, 20, 0, 0 /))) stop 20\n+    ! Allocatable arrays are referenced with array indexing.\n+    ! { dg-final { scan-tree-dump-times \"\\\\(\\\\*\\\\(integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\] \\\\* restrict\\\\) allocatable_x\\\\.data\\\\)\\\\\\[allocatable_x\\\\.offset \\\\+ 2\\\\\\] = 20;\" 1 \"original\" } }\n+  end subroutine check_allocatable_array_elem\n+  subroutine check_allocatable_array_scalarized\n+    integer, allocatable :: allocatable_y(:)\n+    allocate(allocatable_y(5),source=0)\n+    allocatable_y = 21\n+    if (any(allocatable_y /= 21)) stop 21\n+    ! Allocatable arrays are referenced with array indexing.\n+    ! { dg-final { scan-tree-dump-times \"\\\\(\\\\*D.\\\\d+\\\\)\\\\\\[S.\\\\d+ \\\\+ \\\\D.\\\\d+\\\\\\] = 21;\" 1 \"original\" } }\n+  end subroutine check_allocatable_array_scalarized\n+  subroutine cares(assumed_rank_x)\n+    integer :: assumed_rank_x(..)\n+    select rank(rank_1_var_x => assumed_rank_x)\n+      rank(1)\n+        rank_1_var_x(3) = 22\n+    end select\n+  end subroutine cares \n+  subroutine check_assumed_rank_elem\n+    integer :: x(6)\n+    x = 0\n+    call cares(x)\n+    if (any(x /= (/ 0, 0, 22, 0, 0, 0 /))) stop 22\n+    ! Assumed rank arrays are referenced with pointer arithmetic.\n+    ! { dg-final { scan-tree-dump-times \"\\\\*\\\\(\\\\(integer\\\\(kind=4\\\\) \\\\*\\\\) __tmp_INTEGER_4_rank_1\\\\.data \\\\+ \\\\(sizetype\\\\) \\\\(\\\\(__tmp_INTEGER_4_rank_1\\\\.offset \\\\+ __tmp_INTEGER_4_rank_1\\\\.dim\\\\\\[0\\\\\\]\\\\.stride \\\\* 3\\\\) \\\\* 4\\\\)\\\\) = 22;\" 1 \"original\" } }\n+  end subroutine check_assumed_rank_elem\n+  subroutine carss(assumed_rank_y)\n+    integer :: assumed_rank_y(..)\n+    select rank(rank_1_var_y => assumed_rank_y)\n+      rank(1)\n+        rank_1_var_y = 23\n+    end select\n+  end subroutine carss \n+  subroutine check_assumed_rank_scalarized\n+    integer :: y(7)\n+    call carss(y)\n+    if (any(y /= 23)) stop 23\n+    ! Assumed rank arrays are referenced with pointer arithmetic.\n+    ! { dg-final { scan-tree-dump-times \"\\\\*\\\\(\\\\(integer\\\\(kind=4\\\\) \\\\*\\\\) D.\\\\d+ \\\\+ \\\\(sizetype\\\\) \\\\(\\\\(S.\\\\d+ \\\\* D.\\\\d+ \\\\+ D.\\\\d+\\\\) \\\\* 4\\\\)\\\\) = 23;\" 1 \"original\" } }\n+  end subroutine check_assumed_rank_scalarized\n+  subroutine casces(assumed_shape_cont_x)\n+    integer, dimension(:), contiguous :: assumed_shape_cont_x\n+    assumed_shape_cont_x(4) = 24\n+  end subroutine casces \n+  subroutine check_assumed_shape_cont_elem\n+    integer :: x(8)\n+    x = 0\n+    call casces(x)\n+    if (any(x /= (/ 0, 0, 0, 24, 0, 0, 0, 0 /))) stop 24\n+    ! Contiguous assumed shape arrays are referenced with array indexing.\n+    ! { dg-final { scan-tree-dump-times \"\\\\(\\\\*assumed_shape_cont_x.\\\\d+\\\\)\\\\\\[stride.\\\\d+ \\\\* 4 \\\\+ offset.\\\\d+\\\\\\] = 24;\" 1 \"original\" } }\n+  end subroutine check_assumed_shape_cont_elem\n+  subroutine cascss(assumed_shape_cont_y)\n+    integer, dimension(:), contiguous :: assumed_shape_cont_y\n+    assumed_shape_cont_y = 25\n+  end subroutine cascss \n+  subroutine check_assumed_shape_cont_scalarized\n+    integer :: y(9)\n+    call cascss(y)\n+    if (any(y /= 25)) stop 25\n+    ! Contiguous assumed shape arrays are referenced with array indexing.\n+    ! { dg-final { scan-tree-dump-times \"\\\\(\\\\*assumed_shape_cont_y.\\\\d+\\\\)\\\\\\[S.\\\\d+ \\\\* D.\\\\d+ \\\\+ D.\\\\d+\\\\\\] = 25;\" 1 \"original\" } }\n+  end subroutine check_assumed_shape_cont_scalarized\n+end program p\n+"}, {"sha": "7b1149aaa4599780c4580def8fe133496b19623e", "filename": "gcc/testsuite/gfortran.dg/c_loc_test_22.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_22.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_22.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_test_22.f90?ref=7964ab6c364c410c34efe7ca2eba797d36525349", "patch": "@@ -17,7 +17,7 @@ subroutine sub(xxx, yyy)\n ! { dg-final { scan-tree-dump-not \" _gfortran_internal_pack\" \"original\" } }\n ! { dg-final { scan-tree-dump-times \"parm.\\[0-9\\]+.data = \\\\(void .\\\\) &\\\\(.xxx.\\[0-9\\]+\\\\)\\\\\\[0\\\\\\];\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"parm.\\[0-9\\]+.data = \\\\(void .\\\\) &\\\\(.xxx.\\[0-9\\]+\\\\)\\\\\\[D.\\[0-9\\]+ \\\\* 4\\\\\\];\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"parm.\\[0-9\\]+.data = \\\\(void .\\\\) &\\\\(.yyy.\\[0-9\\]+\\\\)\\\\\\[0\\\\\\];\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"parm.\\[0-9\\]+.data = \\\\(void .\\\\) &\\\\(.yyy.\\[0-9\\]+\\\\)\\\\\\[D.\\[0-9\\]+ \\\\* 4\\\\\\];\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"parm.\\[0-9\\]+.data = \\\\(void .\\\\) yyy.\\[0-9\\]+;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"parm.\\[0-9\\]+.data = \\\\(void .\\\\) yyy.\\[0-9\\]+ \\\\+ \\\\(sizetype\\\\) \\\\(D.\\[0-9\\]+ \\\\* 16\\\\);\" 1 \"original\" } }\n \n ! { dg-final { scan-tree-dump-times \"D.\\[0-9\\]+ = parm.\\[0-9\\]+.data;\\[^;]+ptr\\[1-4\\] = D.\\[0-9\\]+;\" 4 \"original\" } }"}, {"sha": "c0e4170fd66f6be2f40c8d0a868a73514557f20a", "filename": "gcc/testsuite/gfortran.dg/finalize_10.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_10.f90?ref=7964ab6c364c410c34efe7ca2eba797d36525349", "patch": "@@ -31,7 +31,7 @@ end subroutine foo\n ! { dg-final { scan-tree-dump-times \"x->_vptr->_copy \\\\(\" 1 \"original\" } }\n \n ! FINALIZE TYPE:\n-! { dg-final { scan-tree-dump-times \"parm.\\[0-9\\]+.data = \\\\(void \\\\*\\\\) &\\\\(\\\\*aa.\\[0-9\\]+\\\\)\\\\\\[0\\\\\\];\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"parm.\\[0-9\\]+.data = \\\\(void \\\\*\\\\) aa.\\[0-9\\]+;\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"__final_m_T2 \\\\(&parm.\\[0-9\\]+, 0, 0\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"desc.\\[0-9\\]+.data = \\\\(void \\\\* restrict\\\\) bb;\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"__final_m_T2 \\\\(&desc.\\[0-9\\]+, 0, 0\\\\);\" 1 \"original\" } }"}, {"sha": "45da92a223f5d109f255d976955ac22c28b3154c", "filename": "gcc/testsuite/gfortran.dg/negative_stride_1.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ftestsuite%2Fgfortran.dg%2Fnegative_stride_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ftestsuite%2Fgfortran.dg%2Fnegative_stride_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnegative_stride_1.f90?ref=7964ab6c364c410c34efe7ca2eba797d36525349", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+!\n+! PR fortran/102043\n+! The middle-end used to conclude from array indexing that the index\n+! should be non-negative and thus that array accesses to reversed arrays\n+! (i.e. with negative strides) only access the last element of the array,\n+! as the access involves a pointer to array that is initialized to point\n+! to the last element in the case of a reversed array.\n+\n+program main\n+   implicit none\n+   integer :: a(3, 3)\n+   integer :: i\n+   a = 0\n+   call s(a(3:1:-1,:))\n+   if (any(a(:,1) /= (/  7,  5,  3 /))) stop 1\n+   if (any(a(:,2) /= (/ 17, 13, 11 /))) stop 2\n+   if (any(a(:,3) /= (/ 29, 23, 19 /))) stop 3\n+contains\n+  subroutine s(b)\n+    implicit none\n+    integer, dimension(:,:) :: b\n+    b = reshape((/ 3, 5, 7, 11, 13, 17, 19, 23, 29 /), (/ 3, 3 /)) \n+  end subroutine s\n+end program main"}, {"sha": "e90450b2f1b53b0f798d317df2f02941e59696fc", "filename": "gcc/testsuite/gfortran.dg/vector_subscript_8.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_8.f90?ref=7964ab6c364c410c34efe7ca2eba797d36525349", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+!\n+! PR fortran/102043\n+! The middle-end used to conclude from array indexing that the index\n+! should be non-negative and thus that array accesses to reversed arrays\n+! (i.e. with negative strides) only access the last element of the array,\n+! as the access involves a pointer to array that is initialized to point\n+! to the last element in the case of a reversed array.\n+\n+program main\n+   integer, dimension (4) :: idx, a, b\n+   a = (/ 11, 13, 17, 19 /)\n+   idx = (/ 1, 2, 3, 4 /)\n+   a(idx(4:1:-1)) = idx\n+   if (a(1).ne.4) STOP 1\n+end program main"}, {"sha": "d70a773287d43a33be1e496ebc20a3e386ce7147", "filename": "gcc/testsuite/gfortran.dg/vector_subscript_9.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7964ab6c364c410c34efe7ca2eba797d36525349/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_9.f90?ref=7964ab6c364c410c34efe7ca2eba797d36525349", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+!\n+! PR fortran/102043\n+! The middle-end used to conclude from array indexing that the index\n+! should be non-negative and thus that array accesses to reversed arrays\n+! (i.e. with negative strides) only access the last element of the array,\n+! as the access involves a pointer to array that is initialized to point\n+! to the last element in the case of a reversed array.\n+\n+program main\n+   integer, dimension (2) :: idx, a, b\n+   a = (/ 3, 4 /)\n+   idx = (/ 1, 2 /)\n+   call check_values(a(idx(2:1:-1)), (/ 4, 3 /))\n+contains\n+   subroutine check_values(values, expected)\n+      integer, dimension(:) :: values, expected\n+      if (size(values) /= size(expected)) stop 1\n+      if (any(values /= expected)) stop 2\n+   end subroutine check_values\n+end program main"}]}