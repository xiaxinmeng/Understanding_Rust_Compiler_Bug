{"sha": "b9dd78fa1e85a6c0b2bc1256a529f5960e503d79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjlkZDc4ZmExZTg1YTZjMGIyYmMxMjU2YTUyOWY1OTYwZTUwM2Q3OQ==", "commit": {"author": {"name": "Laurynas Biveinis", "email": "laurynas.biveinis@gmail.com", "date": "2007-09-07T01:33:41Z"}, "committer": {"name": "Laurynas Biveinis", "email": "lauras@gcc.gnu.org", "date": "2007-09-07T01:33:41Z"}, "message": "tree-loop-linear.c: Include obstack.h.\n\n2007-09-06  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* tree-loop-linear.c: Include obstack.h.\n\t(linear_transform_loops): New obstack lambda_obstack.\n\tInitialize it, pass it to gcc_loopnest_to_lambda_loopnest,\n\tlambda_loopnest_transform, lambda_loopnest_to_gcc_loopnest calls\n\tand free afterwards.\n\t* lambda.h (struct obstack): New forward declaration.\n\t(lambda_linear_expression_new): New parameter of type struct\n\tobstack *.\n\t(lambda_loopnest_new): Likewise.\n\t(lambda_loopnest_transform): Likewise.\n\t(lambda_body_vector_new): Likewise.\n\t(lambda_body_vector_compute_new): Likewise.\n\t(gcc_loopnest_to_lambda_loopnest): Likewise.\n\t(lambda_loopnest_to_gcc_loopnest): Likewise.\n\t* lambda-code.c: Include obstack.h.\n\t(lambda_lattice_new): New parameter lambda_obstack.  Use it for\n\tallocation of ret.\n\t(lambda_body_vector_new): Likewise.\n\t(lambda_linear_expression_new): Likewise.\n\t(lambda_lattice_new): Likewise.\n\t(lambda_loopnest_new): Likewise.  Additionally use obstack to\n\tallocate LN_LOOPS(ret).\n\t(lambda_lattice_compute_base): New parameter lambda_obstack.  Pass\n\tit to lambda_lattice_new.\n\t(lambda_body_vector_compute_new): New parameter lambda_obstack.\n\tPass it to lambda_body_vector_new.\n\t(lambda_lattice_compute_base): New paramater lambda_obstack.  Pass\n\tit to lambda_lattice_new.\n\t(compute_nest_using_fourier_motzkin): New parameter lambda_obstack.\n\tPass it to lambda_loopnest_new, lambda_linear_expression_new.\n\t(lambda_compute_target_space): Likewise.\n\t(lambda_compute_auxillary_space): New parameter lambda_obstack.\n\tPass it to lambda_lattice_compute_base and\n\tcompute_nest_using_fourieer_motzkin.\n\t(lambda_loopnest_transform): New parameter lambda_obstack.  Pass\n\tit to lambda_lattice_compute_base, lambda_lattice_auxillary_space\n\tand lambda_lattice_compute_target_space.\n\t(gcc_tree_to_linear_expression): Nex parameter lambda_obstack.\n\tPass it to lambda_linear_expression_new.\n\t(gcc_loop_to_lambda_loop): New parameter lambda_obstack.  Pass it\n\tto gcc_tree_to_linear_expression.\n\t(gcc_loopnest_to_lambda_loopnest): New parameter lambda_obstack.\n\tPass it to gcc_loop_to_lambda_loop and lambda_loopnest_new.\n\t(lambda_loopnest_to_gcc_loopnest): New parameter lambda_obstack.\n\tPass it to lambda_body_vector_new and\n\tlambda_body_vector_compute_new.\n\t* Makefile.in (tree-loop-linear.o): Add $(OBSTACK_H) dependency.\n\t(lambda-code.o): Likewise.\n\nFrom-SVN: r128219", "tree": {"sha": "90465e7e91a5775e8c20ea92e5e97726c297376d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90465e7e91a5775e8c20ea92e5e97726c297376d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79/comments", "author": {"login": "laurynas-biveinis", "id": 58894, "node_id": "MDQ6VXNlcjU4ODk0", "avatar_url": "https://avatars.githubusercontent.com/u/58894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/laurynas-biveinis", "html_url": "https://github.com/laurynas-biveinis", "followers_url": "https://api.github.com/users/laurynas-biveinis/followers", "following_url": "https://api.github.com/users/laurynas-biveinis/following{/other_user}", "gists_url": "https://api.github.com/users/laurynas-biveinis/gists{/gist_id}", "starred_url": "https://api.github.com/users/laurynas-biveinis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/laurynas-biveinis/subscriptions", "organizations_url": "https://api.github.com/users/laurynas-biveinis/orgs", "repos_url": "https://api.github.com/users/laurynas-biveinis/repos", "events_url": "https://api.github.com/users/laurynas-biveinis/events{/privacy}", "received_events_url": "https://api.github.com/users/laurynas-biveinis/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f996086cbf16283b2494ca36c7573abb5f06df7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f996086cbf16283b2494ca36c7573abb5f06df7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f996086cbf16283b2494ca36c7573abb5f06df7"}], "stats": {"total": 211, "additions": 149, "deletions": 62}, "files": [{"sha": "7b0c48390f21b3436877e3bd1b79a0f36b868f64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9dd78fa1e85a6c0b2bc1256a529f5960e503d79", "patch": "@@ -1,3 +1,54 @@\n+2007-09-06  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* tree-loop-linear.c: Include obstack.h.\n+\t(linear_transform_loops): New obstack lambda_obstack.\n+\tInitialize it, pass it to gcc_loopnest_to_lambda_loopnest,\n+\tlambda_loopnest_transform, lambda_loopnest_to_gcc_loopnest calls\n+\tand free afterwards.\n+\t* lambda.h (struct obstack): New forward declaration.\n+\t(lambda_linear_expression_new): New parameter of type struct\n+\tobstack *.\n+\t(lambda_loopnest_new): Likewise.\n+\t(lambda_loopnest_transform): Likewise.\n+\t(lambda_body_vector_new): Likewise.\n+\t(lambda_body_vector_compute_new): Likewise.\n+\t(gcc_loopnest_to_lambda_loopnest): Likewise.\n+\t(lambda_loopnest_to_gcc_loopnest): Likewise.\n+\t* lambda-code.c: Include obstack.h.\n+\t(lambda_lattice_new): New parameter lambda_obstack.  Use it for\n+\tallocation of ret.\n+\t(lambda_body_vector_new): Likewise.\n+\t(lambda_linear_expression_new): Likewise.\n+\t(lambda_lattice_new): Likewise.\n+\t(lambda_loopnest_new): Likewise.  Additionally use obstack to\n+\tallocate LN_LOOPS(ret).\n+\t(lambda_lattice_compute_base): New parameter lambda_obstack.  Pass\n+\tit to lambda_lattice_new.\n+\t(lambda_body_vector_compute_new): New parameter lambda_obstack.\n+\tPass it to lambda_body_vector_new.\n+\t(lambda_lattice_compute_base): New paramater lambda_obstack.  Pass\n+\tit to lambda_lattice_new.\n+\t(compute_nest_using_fourier_motzkin): New parameter lambda_obstack.\n+\tPass it to lambda_loopnest_new, lambda_linear_expression_new.\n+\t(lambda_compute_target_space): Likewise.\n+\t(lambda_compute_auxillary_space): New parameter lambda_obstack.\n+\tPass it to lambda_lattice_compute_base and\n+\tcompute_nest_using_fourieer_motzkin.\n+\t(lambda_loopnest_transform): New parameter lambda_obstack.  Pass\n+\tit to lambda_lattice_compute_base, lambda_lattice_auxillary_space\n+\tand lambda_lattice_compute_target_space.\n+\t(gcc_tree_to_linear_expression): Nex parameter lambda_obstack.\n+\tPass it to lambda_linear_expression_new.\n+\t(gcc_loop_to_lambda_loop): New parameter lambda_obstack.  Pass it\n+\tto gcc_tree_to_linear_expression.\n+\t(gcc_loopnest_to_lambda_loopnest): New parameter lambda_obstack.\n+\tPass it to gcc_loop_to_lambda_loop and lambda_loopnest_new.\n+\t(lambda_loopnest_to_gcc_loopnest): New parameter lambda_obstack.\n+\tPass it to lambda_body_vector_new and\n+\tlambda_body_vector_compute_new.\n+\t* Makefile.in (tree-loop-linear.o): Add $(OBSTACK_H) dependency.\n+\t(lambda-code.o): Likewise.\n+\n 2007-09-06  Chao-ying Fu  <fu@mips.com>\n \n \t* ginclude/stdfix.h: New file."}, {"sha": "93f277a3ac0b21b404af5aa1c84a7cacfd265c42", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b9dd78fa1e85a6c0b2bc1256a529f5960e503d79", "patch": "@@ -2268,7 +2268,7 @@ tree-loop-linear.o: tree-loop-linear.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    tree-pass.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) $(LAMBDA_H) \\\n-   $(TARGET_H) tree-chrec.h\n+   $(TARGET_H) tree-chrec.h $(OBSTACK_H)\n tree-stdarg.o: tree-stdarg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FUNCTION_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-pass.h \\\n    tree-stdarg.h $(TARGET_H) langhooks.h\n@@ -2842,7 +2842,7 @@ lambda-code.o: lambda-code.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \\\n    $(TM_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) coretypes.h $(TARGET_H) \\\n-   tree-chrec.h tree-pass.h vec.h vecprim.h\n+   tree-chrec.h tree-pass.h vec.h vecprim.h $(OBSTACK_H)\n params.o : params.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(PARAMS_H) toplev.h\n pointer-set.o: pointer-set.c pointer-set.h $(CONFIG_H) $(SYSTEM_H)\n hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(HOOKS_H)"}, {"sha": "c5734375c297a88913d0943279b7983e7e318e21", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 71, "deletions": 47, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=b9dd78fa1e85a6c0b2bc1256a529f5960e503d79", "patch": "@@ -28,6 +28,7 @@\n #include \"rtl.h\"\n #include \"basic-block.h\"\n #include \"diagnostic.h\"\n+#include \"obstack.h\"\n #include \"tree-flow.h\"\n #include \"tree-dump.h\"\n #include \"timevar.h\"\n@@ -141,20 +142,21 @@ typedef struct lambda_lattice_s\n \n static bool lle_equal (lambda_linear_expression, lambda_linear_expression,\n \t\t       int, int);\n-static lambda_lattice lambda_lattice_new (int, int);\n-static lambda_lattice lambda_lattice_compute_base (lambda_loopnest);\n+static lambda_lattice lambda_lattice_new (int, int, struct obstack *);\n+static lambda_lattice lambda_lattice_compute_base (lambda_loopnest,\n+                                                   struct obstack *);\n \n static tree find_induction_var_from_exit_cond (struct loop *);\n static bool can_convert_to_perfect_nest (struct loop *);\n \n /* Create a new lambda body vector.  */\n \n lambda_body_vector\n-lambda_body_vector_new (int size)\n+lambda_body_vector_new (int size, struct obstack * lambda_obstack)\n {\n   lambda_body_vector ret;\n \n-  ret = GGC_NEW (struct lambda_body_vector_s);\n+  ret = (lambda_body_vector)obstack_alloc (lambda_obstack, sizeof (*ret));\n   LBV_COEFFICIENTS (ret) = lambda_vector_new (size);\n   LBV_SIZE (ret) = size;\n   LBV_DENOMINATOR (ret) = 1;\n@@ -166,7 +168,8 @@ lambda_body_vector_new (int size)\n \n lambda_body_vector\n lambda_body_vector_compute_new (lambda_trans_matrix transform,\n-\t\t\t\tlambda_body_vector vect)\n+                                lambda_body_vector vect,\n+                                struct obstack * lambda_obstack)\n {\n   lambda_body_vector temp;\n   int depth;\n@@ -176,7 +179,7 @@ lambda_body_vector_compute_new (lambda_trans_matrix transform,\n \n   depth = LTM_ROWSIZE (transform);\n \n-  temp = lambda_body_vector_new (depth);\n+  temp = lambda_body_vector_new (depth, lambda_obstack);\n   LBV_DENOMINATOR (temp) =\n     LBV_DENOMINATOR (vect) * LTM_DENOMINATOR (transform);\n   lambda_vector_matrix_mult (LBV_COEFFICIENTS (vect), depth,\n@@ -222,12 +225,13 @@ lle_equal (lambda_linear_expression lle1, lambda_linear_expression lle2,\n    of invariants INVARIANTS.  */\n \n lambda_linear_expression\n-lambda_linear_expression_new (int dim, int invariants)\n+lambda_linear_expression_new (int dim, int invariants,\n+                              struct obstack * lambda_obstack)\n {\n   lambda_linear_expression ret;\n \n-  ret = GGC_CNEW (struct lambda_linear_expression_s);\n-\n+  ret = (lambda_linear_expression)obstack_alloc (lambda_obstack,\n+                                                 sizeof (*ret));\n   LLE_COEFFICIENTS (ret) = lambda_vector_new (dim);\n   LLE_CONSTANT (ret) = 0;\n   LLE_INVARIANT_COEFFICIENTS (ret) = lambda_vector_new (invariants);\n@@ -324,12 +328,14 @@ print_lambda_loop (FILE * outfile, lambda_loop loop, int depth,\n    number of invariants.  */\n \n lambda_loopnest\n-lambda_loopnest_new (int depth, int invariants)\n+lambda_loopnest_new (int depth, int invariants,\n+                     struct obstack * lambda_obstack)\n {\n   lambda_loopnest ret;\n-  ret = GGC_NEW (struct lambda_loopnest_s);\n+  ret = (lambda_loopnest)obstack_alloc (lambda_obstack, sizeof (*ret));\n \n-  LN_LOOPS (ret) = GGC_CNEWVEC (lambda_loop, depth);\n+  LN_LOOPS (ret) = (lambda_loop *)\n+      obstack_alloc (lambda_obstack, depth * sizeof(LN_LOOPS(ret)));\n   LN_DEPTH (ret) = depth;\n   LN_INVARIANTS (ret) = invariants;\n \n@@ -356,10 +362,10 @@ print_lambda_loopnest (FILE * outfile, lambda_loopnest nest, char start)\n    of invariants.  */\n \n static lambda_lattice\n-lambda_lattice_new (int depth, int invariants)\n+lambda_lattice_new (int depth, int invariants, struct obstack * lambda_obstack)\n {\n-  lambda_lattice ret;\n-  ret = GGC_NEW (struct lambda_lattice_s);\n+  lambda_lattice ret\n+      = (lambda_lattice)obstack_alloc (lambda_obstack, sizeof (*ret));\n   LATTICE_BASE (ret) = lambda_matrix_new (depth, depth);\n   LATTICE_ORIGIN (ret) = lambda_vector_new (depth);\n   LATTICE_ORIGIN_INVARIANTS (ret) = lambda_matrix_new (depth, invariants);\n@@ -376,7 +382,8 @@ lambda_lattice_new (int depth, int invariants)\n    identity matrix) if NEST is a sparse space.  */\n \n static lambda_lattice\n-lambda_lattice_compute_base (lambda_loopnest nest)\n+lambda_lattice_compute_base (lambda_loopnest nest,\n+                             struct obstack * lambda_obstack)\n {\n   lambda_lattice ret;\n   int depth, invariants;\n@@ -389,7 +396,7 @@ lambda_lattice_compute_base (lambda_loopnest nest)\n   depth = LN_DEPTH (nest);\n   invariants = LN_INVARIANTS (nest);\n \n-  ret = lambda_lattice_new (depth, invariants);\n+  ret = lambda_lattice_new (depth, invariants, lambda_obstack);\n   base = LATTICE_BASE (ret);\n   for (i = 0; i < depth; i++)\n     {\n@@ -479,7 +486,8 @@ compute_nest_using_fourier_motzkin (int size,\n \t\t\t\t    int invariants,\n \t\t\t\t    lambda_matrix A,\n \t\t\t\t    lambda_matrix B,\n-\t\t\t\t    lambda_vector a)\n+                                    lambda_vector a,\n+                                    struct obstack * lambda_obstack)\n {\n \n   int multiple, f1, f2;\n@@ -495,7 +503,7 @@ compute_nest_using_fourier_motzkin (int size,\n   B1 = lambda_matrix_new (128, invariants);\n   a1 = lambda_vector_new (128);\n \n-  auxillary_nest = lambda_loopnest_new (depth, invariants);\n+  auxillary_nest = lambda_loopnest_new (depth, invariants, lambda_obstack);\n \n   for (i = depth - 1; i >= 0; i--)\n     {\n@@ -509,7 +517,8 @@ compute_nest_using_fourier_motzkin (int size,\n \t    {\n \t      /* Any linear expression in the matrix with a coefficient less\n \t\t than 0 becomes part of the new lower bound.  */ \n-\t      expression = lambda_linear_expression_new (depth, invariants);\n+              expression = lambda_linear_expression_new (depth, invariants,\n+                                                         lambda_obstack);\n \n \t      for (k = 0; k < i; k++)\n \t\tLLE_COEFFICIENTS (expression)[k] = A[j][k];\n@@ -533,7 +542,8 @@ compute_nest_using_fourier_motzkin (int size,\n \t    {\n \t      /* Any linear expression with a coefficient greater than 0\n \t\t becomes part of the new upper bound.  */ \n-\t      expression = lambda_linear_expression_new (depth, invariants);\n+              expression = lambda_linear_expression_new (depth, invariants,\n+                                                         lambda_obstack);\n \t      for (k = 0; k < i; k++)\n \t\tLLE_COEFFICIENTS (expression)[k] = -1 * A[j][k];\n \n@@ -625,7 +635,8 @@ compute_nest_using_fourier_motzkin (int size,\n \n static lambda_loopnest\n lambda_compute_auxillary_space (lambda_loopnest nest,\n-\t\t\t\tlambda_trans_matrix trans)\n+                                lambda_trans_matrix trans,\n+                                struct obstack * lambda_obstack)\n {\n   lambda_matrix A, B, A1, B1;\n   lambda_vector a, a1;\n@@ -723,7 +734,7 @@ lambda_compute_auxillary_space (lambda_loopnest nest,\n \n   /* Compute the lattice base x = base * y + origin, where y is the\n      base space.  */\n-  lattice = lambda_lattice_compute_base (nest);\n+  lattice = lambda_lattice_compute_base (nest, lambda_obstack);\n \n   /* Ax <= a + B then becomes ALy <= a+B - A*origin.  L is the lattice base  */\n \n@@ -752,7 +763,7 @@ lambda_compute_auxillary_space (lambda_loopnest nest,\n   lambda_matrix_mult (A1, invertedtrans, A, size, depth, depth);\n \n   return compute_nest_using_fourier_motzkin (size, depth, invariants,\n-\t\t\t\t\t     A, B1, a1);\n+                                             A, B1, a1, lambda_obstack);\n }\n \n /* Compute the loop bounds for the target space, using the bounds of\n@@ -765,7 +776,8 @@ lambda_compute_auxillary_space (lambda_loopnest nest,\n \n static lambda_loopnest\n lambda_compute_target_space (lambda_loopnest auxillary_nest,\n-\t\t\t     lambda_trans_matrix H, lambda_vector stepsigns)\n+                             lambda_trans_matrix H, lambda_vector stepsigns,\n+                             struct obstack * lambda_obstack)\n {\n   lambda_matrix inverse, H1;\n   int determinant, i, j;\n@@ -796,7 +808,7 @@ lambda_compute_target_space (lambda_loopnest auxillary_nest,\n   target = lambda_matrix_new (depth, depth);\n   lambda_matrix_mult (H1, inverse, target, depth, depth, depth);\n \n-  target_nest = lambda_loopnest_new (depth, invariants);\n+  target_nest = lambda_loopnest_new (depth, invariants, lambda_obstack);\n \n   for (i = 0; i < depth; i++)\n     {\n@@ -815,7 +827,8 @@ lambda_compute_target_space (lambda_loopnest auxillary_nest,\n       for (j = 0; j < i; j++)\n \ttarget[i][j] = target[i][j] / gcd1;\n \n-      expression = lambda_linear_expression_new (depth, invariants);\n+      expression = lambda_linear_expression_new (depth, invariants,\n+                                                 lambda_obstack);\n       lambda_vector_copy (target[i], LLE_COEFFICIENTS (expression), depth);\n       LLE_DENOMINATOR (expression) = determinant / gcd1;\n       LLE_CONSTANT (expression) = 0;\n@@ -838,7 +851,8 @@ lambda_compute_target_space (lambda_loopnest auxillary_nest,\n       for (; auxillary_expr != NULL;\n \t   auxillary_expr = LLE_NEXT (auxillary_expr))\n \t{\n-\t  target_expr = lambda_linear_expression_new (depth, invariants);\n+          target_expr = lambda_linear_expression_new (depth, invariants,\n+                                                      lambda_obstack);\n \t  lambda_vector_matrix_mult (LLE_COEFFICIENTS (auxillary_expr),\n \t\t\t\t     depth, inverse, depth,\n \t\t\t\t     LLE_COEFFICIENTS (target_expr));\n@@ -895,7 +909,8 @@ lambda_compute_target_space (lambda_loopnest auxillary_nest,\n       for (; auxillary_expr != NULL;\n \t   auxillary_expr = LLE_NEXT (auxillary_expr))\n \t{\n-\t  target_expr = lambda_linear_expression_new (depth, invariants);\n+          target_expr = lambda_linear_expression_new (depth, invariants,\n+                                                      lambda_obstack);\n \t  lambda_vector_matrix_mult (LLE_COEFFICIENTS (auxillary_expr),\n \t\t\t\t     depth, inverse, depth,\n \t\t\t\t     LLE_COEFFICIENTS (target_expr));\n@@ -1020,7 +1035,8 @@ lambda_compute_step_signs (lambda_trans_matrix trans, lambda_vector stepsigns)\n    triangular portion.  */ \n \n lambda_loopnest\n-lambda_loopnest_transform (lambda_loopnest nest, lambda_trans_matrix trans)\n+lambda_loopnest_transform (lambda_loopnest nest, lambda_trans_matrix trans,\n+                           struct obstack * lambda_obstack)\n {\n   lambda_loopnest auxillary_nest, target_nest;\n \n@@ -1049,7 +1065,7 @@ lambda_loopnest_transform (lambda_loopnest nest, lambda_trans_matrix trans)\n     }\n \n   /* Compute the lattice base.  */\n-  lattice = lambda_lattice_compute_base (nest);\n+  lattice = lambda_lattice_compute_base (nest, lambda_obstack);\n   trans1 = lambda_trans_matrix_new (depth, depth);\n \n   /* Multiply the transformation matrix by the lattice base.  */\n@@ -1065,15 +1081,16 @@ lambda_loopnest_transform (lambda_loopnest nest, lambda_trans_matrix trans)\n \n   /* Compute the auxiliary loop nest's space from the unimodular\n      portion.  */\n-  auxillary_nest = lambda_compute_auxillary_space (nest, U);\n+  auxillary_nest = lambda_compute_auxillary_space (nest, U, lambda_obstack);\n \n   /* Compute the loop step signs from the old step signs and the\n      transformation matrix.  */\n   stepsigns = lambda_compute_step_signs (trans1, stepsigns);\n \n   /* Compute the target loop nest space from the auxiliary nest and\n      the lower triangular matrix H.  */\n-  target_nest = lambda_compute_target_space (auxillary_nest, H, stepsigns);\n+  target_nest = lambda_compute_target_space (auxillary_nest, H, stepsigns,\n+                                             lambda_obstack);\n   origin = lambda_vector_new (depth);\n   origin_invariants = lambda_matrix_new (depth, invariants);\n   lambda_matrix_vector_mult (LTM_MATRIX (trans), depth, depth,\n@@ -1111,14 +1128,15 @@ lambda_loopnest_transform (lambda_loopnest nest, lambda_trans_matrix trans)\n static lambda_linear_expression\n gcc_tree_to_linear_expression (int depth, tree expr,\n \t\t\t       VEC(tree,heap) *outerinductionvars,\n-\t\t\t       VEC(tree,heap) *invariants, int extra)\n+                               VEC(tree,heap) *invariants, int extra,\n+                               struct obstack * lambda_obstack)\n {\n   lambda_linear_expression lle = NULL;\n   switch (TREE_CODE (expr))\n     {\n     case INTEGER_CST:\n       {\n-\tlle = lambda_linear_expression_new (depth, 2 * depth);\n+        lle = lambda_linear_expression_new (depth, 2 * depth, lambda_obstack);\n \tLLE_CONSTANT (lle) = TREE_INT_CST_LOW (expr);\n \tif (extra != 0)\n \t  LLE_CONSTANT (lle) += extra;\n@@ -1135,7 +1153,8 @@ gcc_tree_to_linear_expression (int depth, tree expr,\n \t    {\n \t      if (SSA_NAME_VAR (iv) == SSA_NAME_VAR (expr))\n \t\t{\n-\t\t  lle = lambda_linear_expression_new (depth, 2 * depth);\n+                  lle = lambda_linear_expression_new (depth, 2 * depth,\n+                                                      lambda_obstack);\n \t\t  LLE_COEFFICIENTS (lle)[i] = 1;\n \t\t  if (extra != 0)\n \t\t    LLE_CONSTANT (lle) = extra;\n@@ -1148,7 +1167,8 @@ gcc_tree_to_linear_expression (int depth, tree expr,\n \t    {\n \t      if (SSA_NAME_VAR (invar) == SSA_NAME_VAR (expr))\n \t\t{\n-\t\t  lle = lambda_linear_expression_new (depth, 2 * depth);\n+                  lle = lambda_linear_expression_new (depth, 2 * depth,\n+                                                      lambda_obstack);\n \t\t  LLE_INVARIANT_COEFFICIENTS (lle)[i] = 1;\n \t\t  if (extra != 0)\n \t\t    LLE_CONSTANT (lle) = extra;\n@@ -1210,7 +1230,8 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n \t\t\t VEC(tree,heap) * outerinductionvars,\n \t\t\t VEC(tree,heap) ** lboundvars,\n \t\t\t VEC(tree,heap) ** uboundvars,\n-\t\t\t VEC(int,heap) ** steps)\n+                         VEC(int,heap) ** steps,\n+                         struct obstack * lambda_obstack)\n {\n   tree phi;\n   tree exit_cond;\n@@ -1335,14 +1356,14 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n       lboundvar = PHI_ARG_DEF (phi, 1);\n       lbound = gcc_tree_to_linear_expression (depth, lboundvar,\n \t\t\t\t\t      outerinductionvars, *invariants,\n-\t\t\t\t\t      0);\n+                                              0, lambda_obstack);\n     }\n   else\n     {\n       lboundvar = PHI_ARG_DEF (phi, 0);\n       lbound = gcc_tree_to_linear_expression (depth, lboundvar,\n \t\t\t\t\t      outerinductionvars, *invariants,\n-\t\t\t\t\t      0);\n+                                              0, lambda_obstack);\n     }\n   \n   if (!lbound)\n@@ -1390,7 +1411,7 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n   \n   ubound = gcc_tree_to_linear_expression (depth, uboundvar,\n \t\t\t\t\t  outerinductionvars,\n-\t\t\t\t\t  *invariants, extra);\n+                                          *invariants, extra, lambda_obstack);\n   uboundresult = build2 (PLUS_EXPR, TREE_TYPE (uboundvar), uboundvar,\n \t\t\t build_int_cst (TREE_TYPE (uboundvar), extra));\n   VEC_safe_push (tree, heap, *uboundvars, uboundresult);\n@@ -1456,7 +1477,8 @@ DEF_VEC_ALLOC_P(lambda_loop,heap);\n lambda_loopnest\n gcc_loopnest_to_lambda_loopnest (struct loop *loop_nest,\n \t\t\t\t VEC(tree,heap) **inductionvars,\n-\t\t\t\t VEC(tree,heap) **invariants)\n+                                 VEC(tree,heap) **invariants,\n+                                 struct obstack * lambda_obstack)\n {\n   lambda_loopnest ret = NULL;\n   struct loop *temp = loop_nest;\n@@ -1478,7 +1500,7 @@ gcc_loopnest_to_lambda_loopnest (struct loop *loop_nest,\n       newloop = gcc_loop_to_lambda_loop (temp, depth, invariants,\n \t\t\t\t\t &inductionvar, *inductionvars,\n \t\t\t\t\t &lboundvars, &uboundvars,\n-\t\t\t\t\t &steps);\n+                                         &steps, lambda_obstack);\n       if (!newloop)\n \tgoto fail;\n \n@@ -1502,7 +1524,7 @@ gcc_loopnest_to_lambda_loopnest (struct loop *loop_nest,\n \t\t \"Successfully converted loop nest to perfect loop nest.\\n\");\n     }\n \n-  ret = lambda_loopnest_new (depth, 2 * depth);\n+  ret = lambda_loopnest_new (depth, 2 * depth, lambda_obstack);\n \n   for (i = 0; VEC_iterate (lambda_loop, loops, i, newloop); i++)\n     LN_LOOPS (ret)[i] = newloop;\n@@ -1671,7 +1693,8 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t\t\t\t VEC(tree,heap) *old_ivs,\n \t\t\t\t VEC(tree,heap) *invariants,\n \t\t\t\t lambda_loopnest new_loopnest,\n-\t\t\t\t lambda_trans_matrix transform)\n+                                 lambda_trans_matrix transform,\n+                                 struct obstack * lambda_obstack)\n {\n   struct loop *temp;\n   size_t i = 0;\n@@ -1818,10 +1841,11 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t  /* Compute the new expression for the induction\n \t     variable.  */\n \t  depth = VEC_length (tree, new_ivs);\n-\t  lbv = lambda_body_vector_new (depth);\n+          lbv = lambda_body_vector_new (depth, lambda_obstack);\n \t  LBV_COEFFICIENTS (lbv)[i] = 1;\n \t  \n-\t  newlbv = lambda_body_vector_compute_new (transform, lbv);\n+          newlbv = lambda_body_vector_compute_new (transform, lbv,\n+                                                   lambda_obstack);\n \n \t  newiv = lbv_to_gcc_expression (newlbv, TREE_TYPE (oldiv),\n \t\t\t\t\t new_ivs, &stmts);"}, {"sha": "e7a75fdb66f06bb6ca830302105826b875627f94", "filename": "gcc/lambda.h", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=b9dd78fa1e85a6c0b2bc1256a529f5960e503d79", "patch": "@@ -97,7 +97,10 @@ typedef struct lambda_linear_expression_s\n #define LLE_DENOMINATOR(T) ((T)->denominator)\n #define LLE_NEXT(T) ((T)->next)\n \n-lambda_linear_expression lambda_linear_expression_new (int, int);\n+struct obstack;\n+\n+lambda_linear_expression lambda_linear_expression_new (int, int,\n+                                                       struct obstack *);\n void print_lambda_linear_expression (FILE *, lambda_linear_expression, int,\n \t\t\t\t     int, char);\n \n@@ -137,8 +140,10 @@ typedef struct lambda_loopnest_s\n #define LN_DEPTH(T) ((T)->depth)\n #define LN_INVARIANTS(T) ((T)->invariants)\n \n-lambda_loopnest lambda_loopnest_new (int, int);\n-lambda_loopnest lambda_loopnest_transform (lambda_loopnest, lambda_trans_matrix);\n+lambda_loopnest lambda_loopnest_new (int, int, struct obstack *);\n+lambda_loopnest lambda_loopnest_transform (lambda_loopnest,\n+                                           lambda_trans_matrix,\n+                                           struct obstack *);\n struct loop;\n bool perfect_nest_p (struct loop *);\n void print_lambda_loopnest (FILE *, lambda_loopnest, char);\n@@ -190,17 +195,19 @@ void lambda_matrix_vector_mult (lambda_matrix, int, int, lambda_vector,\n \t\t\t\tlambda_vector);\n bool lambda_trans_matrix_id_p (lambda_trans_matrix);\n \n-lambda_body_vector lambda_body_vector_new (int);\n-lambda_body_vector lambda_body_vector_compute_new (lambda_trans_matrix, \n-\t\t\t\t\t\t   lambda_body_vector);\n+lambda_body_vector lambda_body_vector_new (int, struct obstack *);\n+lambda_body_vector lambda_body_vector_compute_new (lambda_trans_matrix,\n+                                                   lambda_body_vector,\n+                                                   struct obstack *);\n void print_lambda_body_vector (FILE *, lambda_body_vector);\n lambda_loopnest gcc_loopnest_to_lambda_loopnest (struct loop *,\n \t\t\t\t\t\t VEC(tree,heap) **,\n-\t\t\t\t\t\t VEC(tree,heap) **);\n+                                                 VEC(tree,heap) **,\n+                                                 struct obstack *);\n void lambda_loopnest_to_gcc_loopnest (struct loop *,\n \t\t\t\t      VEC(tree,heap) *, VEC(tree,heap) *,\n-\t\t\t\t      lambda_loopnest, lambda_trans_matrix);\n-\n+                                      lambda_loopnest, lambda_trans_matrix,\n+                                      struct obstack *);\n \n static inline void lambda_vector_negate (lambda_vector, lambda_vector, int);\n static inline void lambda_vector_mult_const (lambda_vector, lambda_vector, int, int);"}, {"sha": "d04045ded4fe30c4d9a3e9589c22e9fe1896355b", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9dd78fa1e85a6c0b2bc1256a529f5960e503d79/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=b9dd78fa1e85a6c0b2bc1256a529f5960e503d79", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl.h\"\n #include \"basic-block.h\"\n #include \"diagnostic.h\"\n+#include \"obstack.h\"\n #include \"tree-flow.h\"\n #include \"tree-dump.h\"\n #include \"timevar.h\"\n@@ -253,7 +254,7 @@ linear_transform_loops (void)\n   VEC(tree,heap) *oldivs = NULL;\n   VEC(tree,heap) *invariants = NULL;\n   struct loop *loop_nest;\n-  \n+\n   FOR_EACH_LOOP (li, loop_nest, 0)\n     {\n       unsigned int depth = 0;\n@@ -263,6 +264,9 @@ linear_transform_loops (void)\n       lambda_loopnest before, after;\n       lambda_trans_matrix trans;\n       bool problem = false;\n+      struct obstack lambda_obstack;\n+      gcc_obstack_init (&lambda_obstack);\n+\n       /* If it's not a loop nest, we don't want it.\n          We also don't handle sibling loops properly, \n          which are loops of the following form:\n@@ -327,7 +331,7 @@ linear_transform_loops (void)\n \t}\n \n       before = gcc_loopnest_to_lambda_loopnest (loop_nest, &oldivs,\n-\t\t\t\t\t\t&invariants);\n+                                                &invariants, &lambda_obstack);\n \n       if (!before)\n \tgoto free_and_continue;\n@@ -338,7 +342,7 @@ linear_transform_loops (void)\n \t  print_lambda_loopnest (dump_file, before, 'i');\n \t}\n   \n-      after = lambda_loopnest_transform (before, trans);\n+      after = lambda_loopnest_transform (before, trans, &lambda_obstack);\n \n       if (dump_file)\n \t{\n@@ -347,13 +351,14 @@ linear_transform_loops (void)\n \t}\n \n       lambda_loopnest_to_gcc_loopnest (loop_nest, oldivs, invariants,\n-\t\t\t\t       after, trans);\n+                                       after, trans, &lambda_obstack);\n       modified = true;\n \n       if (dump_file)\n \tfprintf (dump_file, \"Successfully transformed loop.\\n\");\n \n     free_and_continue:\n+      obstack_free (&lambda_obstack, NULL);\n       free_dependence_relations (dependence_relations);\n       free_data_refs (datarefs);\n     }"}]}