{"sha": "5a5325cb7288ba6ee85682f079aebc26131cceba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE1MzI1Y2I3Mjg4YmE2ZWU4NTY4MmYwNzlhZWJjMjYxMzFjY2ViYQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-08-18T08:24:51Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-08-18T08:24:51Z"}, "message": "From Kaveh R. Ghazi.\n\n\t* config/sparc/sparc.c (ultra_find_type): Add empty semicolon\n\tstatement after end of loop label.\n\tFrom me...\n\t* config/sparc/sparc.c (ultra_types_avail): New variable.\n\t(ultra_build_types_avail): New function to record mask of insn\n\ttypes in ready list at this cycle.\n\t(ultrasparc_sched_reorder): Call it.\n\t(ultra_find_type): Use it to quicken the search.  Also simplif\n\tdependency check, don't use rtx_equal_p because we know exactly\n\twhat we are looking for.\n\nFrom-SVN: r21817", "tree": {"sha": "fe8f8049f63b8601f354fe7c6469a749992479c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe8f8049f63b8601f354fe7c6469a749992479c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a5325cb7288ba6ee85682f079aebc26131cceba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5325cb7288ba6ee85682f079aebc26131cceba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a5325cb7288ba6ee85682f079aebc26131cceba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5325cb7288ba6ee85682f079aebc26131cceba/comments", "author": null, "committer": null, "parents": [{"sha": "a2767b67092e13dea0a795f77285ae54bc15debf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2767b67092e13dea0a795f77285ae54bc15debf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2767b67092e13dea0a795f77285ae54bc15debf"}], "stats": {"total": 59, "additions": 56, "deletions": 3}, "files": [{"sha": "d1c7cff21caed021701c312ac12e7da6d37fd732", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5325cb7288ba6ee85682f079aebc26131cceba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5325cb7288ba6ee85682f079aebc26131cceba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a5325cb7288ba6ee85682f079aebc26131cceba", "patch": "@@ -1,3 +1,18 @@\n+Tue Aug 18 07:15:27 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* config/sparc/sparc.c (ultra_find_type): Add empty semicolon\n+\tstatement after end of loop label.\n+\n+Tue Aug 18 07:13:27 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* config/sparc/sparc.c (ultra_types_avail): New variable.\n+\t(ultra_build_types_avail): New function to record mask of insn\n+\ttypes in ready list at this cycle.\n+\t(ultrasparc_sched_reorder): Call it.\n+\t(ultra_find_type): Use it to quicken the search.  Also simplif\n+\tdependency check, don't use rtx_equal_p because we know exactly\n+\twhat we are looking for.\n+\n Tue Aug 18 03:20:53 1998  Richard Earnshaw  (rearnsha@arm.com)\n \n \t* arm.h (SECONDARY_INPUT_RELOAD_CLASS): Return NO_REGS if compiling"}, {"sha": "dd75d7fe731dad3e1d6ef2b9e24cd6c529184aec", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5325cb7288ba6ee85682f079aebc26131cceba/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5325cb7288ba6ee85682f079aebc26131cceba/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5a5325cb7288ba6ee85682f079aebc26131cceba", "patch": "@@ -6316,6 +6316,9 @@ ultra_fpmode_conflict_exists (fpmode)\n \n    NOTE: This scheme depends upon the fact that we\n          have less than 32 distinct type attributes.  */\n+\n+static int ultra_types_avail;\n+\n static rtx *\n ultra_find_type (type_mask, list, start)\n      int type_mask;\n@@ -6324,6 +6327,11 @@ ultra_find_type (type_mask, list, start)\n {\n   int i;\n \n+  /* Short circuit if no such insn exists in the ready\n+     at the moment.  */\n+  if ((type_mask & ultra_types_avail) == 0)\n+    return 0;\n+\n   for (i = start; i >= 0; i--)\n     {\n       rtx insn = list[i];\n@@ -6366,14 +6374,22 @@ ultra_find_type (type_mask, list, start)\n \t\t      || (check_depend == 1\n \t\t\t  && GET_CODE (slot_insn) == INSN\n \t\t\t  && GET_CODE (slot_pat) == SET\n-\t\t\t  && rtx_equal_p (SET_DEST (slot_pat),\n-\t\t\t\t\t  SET_SRC (pat)))\n+\t\t\t  && ((GET_CODE (SET_DEST (slot_pat)) == REG\n+\t\t\t       && GET_CODE (SET_SRC (pat)) == REG\n+\t\t\t       && REGNO (SET_DEST (slot_pat)) ==\n+\t\t\t            REGNO (SET_SRC (pat)))\n+\t\t\t      || (GET_CODE (SET_DEST (slot_pat)) == SUBREG\n+\t\t\t\t  && GET_CODE (SET_SRC (pat)) == SUBREG\n+\t\t\t\t  && REGNO (SUBREG_REG (SET_DEST (slot_pat))) ==\n+\t\t\t\t       REGNO (SUBREG_REG (SET_SRC (pat)))\n+\t\t\t\t  && SUBREG_WORD (SET_DEST (slot_pat)) ==\n+\t\t\t\t       SUBREG_WORD (SET_SRC (pat))))\n \t\t      || (check_fpmode_conflict == 1\n \t\t\t  && GET_CODE (slot_insn) == INSN\n \t\t\t  && GET_CODE (slot_pat) == SET\n \t\t\t  && ((GET_MODE (SET_DEST (slot_pat)) == SFmode\n \t\t\t       || GET_MODE (SET_DEST (slot_pat)) == DFmode)\n-\t\t\t      && GET_MODE (SET_DEST (slot_pat)) != fpmode))))\n+\t\t\t      && GET_MODE (SET_DEST (slot_pat)) != fpmode)))))\n \t\tgoto next;\n \t    }\n \n@@ -6403,10 +6419,30 @@ ultra_find_type (type_mask, list, start)\n \t  return &list[i];\n \t}\n     next:\n+      ;\n     }\n   return 0;\n }\n \n+static void\n+ultra_build_types_avail (ready, n_ready)\n+  rtx *ready;\n+  int n_ready;\n+{\n+  int i = n_ready - 1;\n+\n+  ultra_types_avail = 0;\n+  while(i >= 0)\n+    {\n+      rtx insn = ready[i];\n+\n+      if (recog_memoized (insn) >= 0)\n+\tultra_types_avail |= TMASK (get_attr_type (insn));\n+\n+      i -= 1;\n+    }\n+}\n+\n /* Place insn pointed to my IP into the pipeline.\n    Make element THIS of READY be that insn if it\n    is not already.  TYPE indicates the pipeline class\n@@ -6602,6 +6638,8 @@ ultrasparc_sched_reorder (dump, sched_verbose, ready, n_ready)\n \t && recog_memoized (ready[this_insn]) < 0)\n     this_insn--;\n \n+  ultra_build_types_avail (ready, this_insn + 1);\n+\n   while (this_insn >= 0) {\n     int old_group_size = up->group_size;\n "}]}