{"sha": "6eab5a95753e09c22158046f43129d6a1c194af5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVhYjVhOTU3NTNlMDljMjIxNTgwNDZmNDMxMjlkNmExYzE5NGFmNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-15T12:57:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-15T12:57:06Z"}, "message": "[multiple changes]\n\n2009-07-15  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch10.adb: Minor reformatting throughout\n\tMinor code reorganization (put nested subprograms in alpha order)\n\n2009-07-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call): Prevent double attachment of the result\n\twhen compiling a call to a protected function that returns a controlled\n\tobject.\n\n2009-07-15  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sysdep.c (__gnat_localtime_tzoff): Consolidate the Lynx cases into\n\tone. Add task locking and unlocking around the critical region which\n\tmentions localtime_r and global variable timezone for various targets.\n\tComment reformatting.\n\nFrom-SVN: r149686", "tree": {"sha": "c19274c9c9a54b6f86ad93ec6ba9d3ab9d26ad8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c19274c9c9a54b6f86ad93ec6ba9d3ab9d26ad8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6eab5a95753e09c22158046f43129d6a1c194af5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eab5a95753e09c22158046f43129d6a1c194af5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eab5a95753e09c22158046f43129d6a1c194af5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eab5a95753e09c22158046f43129d6a1c194af5/comments", "author": null, "committer": null, "parents": [{"sha": "3eb532e6aad1fb8ddbd6d437f66313a382a91535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb532e6aad1fb8ddbd6d437f66313a382a91535", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eb532e6aad1fb8ddbd6d437f66313a382a91535"}], "stats": {"total": 709, "additions": 374, "deletions": 335}, "files": [{"sha": "8139e607c3fd999dfc2ceb50c50c043b1752c9fb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eab5a95753e09c22158046f43129d6a1c194af5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eab5a95753e09c22158046f43129d6a1c194af5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6eab5a95753e09c22158046f43129d6a1c194af5", "patch": "@@ -1,3 +1,21 @@\n+2009-07-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch10.adb: Minor reformatting throughout\n+\tMinor code reorganization (put nested subprograms in alpha order)\n+\n+2009-07-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call): Prevent double attachment of the result\n+\twhen compiling a call to a protected function that returns a controlled\n+\tobject.\n+\n+2009-07-15  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sysdep.c (__gnat_localtime_tzoff): Consolidate the Lynx cases into\n+\tone. Add task locking and unlocking around the critical region which\n+\tmentions localtime_r and global variable timezone for various targets.\n+\tComment reformatting.\n+\n 2009-07-15  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_rm.texi: Document s-ststop.ads"}, {"sha": "8530816c9b3e31c570744886e2c7340d41b744b5", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eab5a95753e09c22158046f43129d6a1c194af5/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eab5a95753e09c22158046f43129d6a1c194af5/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=6eab5a95753e09c22158046f43129d6a1c194af5", "patch": "@@ -3097,10 +3097,17 @@ package body Exp_Ch6 is\n \n       --  Functions returning controlled objects need special attention:\n       --  if the return type is limited, the context is an initialization\n-      --  and different processing applies.\n+      --  and different processing applies. If the call is to a protected\n+      --  function, the expansion above will call Expand_Call recusively.\n+      --  To prevent a double attachment, check that the current call is\n+      --  not a rewriting of a protected function call.\n \n       if Needs_Finalization (Etype (Subp))\n         and then not Is_Inherently_Limited_Type (Etype (Subp))\n+        and then\n+          (No (First_Formal (Subp))\n+            or else\n+              not Is_Concurrent_Record_Type (Etype (First_Formal (Subp))))\n       then\n          Expand_Ctrl_Function_Call (N);\n       end if;"}, {"sha": "687dd5c2f9ae0cf42c44073d801fd92237378a0e", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 308, "deletions": 321, "changes": 629, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eab5a95753e09c22158046f43129d6a1c194af5/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eab5a95753e09c22158046f43129d6a1c194af5/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=6eab5a95753e09c22158046f43129d6a1c194af5", "patch": "@@ -77,13 +77,13 @@ package body Sem_Ch10 is\n    procedure Build_Limited_Views (N : Node_Id);\n    --  Build and decorate the list of shadow entities for a package mentioned\n    --  in a limited_with clause. If the package was not previously analyzed\n-   --  then it also performs a basic decoration of the real entities; this\n-   --  is required to do not pass non-decorated entities to the back-end.\n+   --  then it also performs a basic decoration of the real entities. This is\n+   --  required to do not pass non-decorated entities to the back-end.\n    --  Implements Ada 2005 (AI-50217).\n \n    procedure Check_Body_Needed_For_SAL (Unit_Name : Entity_Id);\n-   --  Check whether the source for the body of a compilation unit must\n-   --  be included in a standalone library.\n+   --  Check whether the source for the body of a compilation unit must be\n+   --  included in a standalone library.\n \n    procedure Check_Private_Child_Unit (N : Node_Id);\n    --  If a with_clause mentions a private child unit, the compilation\n@@ -130,8 +130,8 @@ package body Sem_Ch10 is\n    --  and use_clauses for current unit and its library unit if any.\n \n    procedure Install_Limited_Context_Clauses (N : Node_Id);\n-   --  Subsidiary to Install_Context. Process only limited with_clauses\n-   --  for current unit. Implements Ada 2005 (AI-50217).\n+   --  Subsidiary to Install_Context. Process only limited with_clauses for\n+   --  current unit. Implements Ada 2005 (AI-50217).\n \n    procedure Install_Limited_Withed_Unit (N : Node_Id);\n    --  Place shadow entities for a limited_with package in the visibility\n@@ -140,11 +140,11 @@ package body Sem_Ch10 is\n    procedure Install_Withed_Unit\n      (With_Clause     : Node_Id;\n       Private_With_OK : Boolean := False);\n-   --  If the unit is not a child unit, make unit immediately visible.\n-   --  The caller ensures that the unit is not already currently installed.\n-   --  The flag Private_With_OK is set true in Install_Private_With_Clauses,\n-   --  which is called when compiling the private part of a package, or\n-   --  installing the private declarations of a parent unit.\n+   --  If the unit is not a child unit, make unit immediately visible. The\n+   --  caller ensures that the unit is not already currently installed. The\n+   --  flag Private_With_OK is set true in Install_Private_With_Clauses, which\n+   --  is called when compiling the private part of a package, or installing\n+   --  the private declarations of a parent unit.\n \n    procedure Install_Parents (Lib_Unit : Node_Id; Is_Private : Boolean);\n    --  This procedure establishes the context for the compilation of a child\n@@ -170,8 +170,8 @@ package body Sem_Ch10 is\n    --  True, then Parent_Spec (Lib_Unit) is non-Empty and points to the\n    --  compilation unit for the parent spec.\n    --\n-   --  Lib_Unit can also be a subprogram body that acts as its own spec. If\n-   --  the Parent_Spec is  non-empty, this is also a child unit.\n+   --  Lib_Unit can also be a subprogram body that acts as its own spec. If the\n+   --  Parent_Spec is non-empty, this is also a child unit.\n \n    procedure Remove_Context_Clauses (N : Node_Id);\n    --  Subsidiary of previous one. Remove use_ and with_clauses\n@@ -664,13 +664,13 @@ package body Sem_Ch10 is\n \n       Analyze_Context (N);\n \n-      --  If the unit is a package body, the spec is already loaded and must\n-      --  be analyzed first, before we analyze the body.\n+      --  If the unit is a package body, the spec is already loaded and must be\n+      --  analyzed first, before we analyze the body.\n \n       if Nkind (Unit_Node) = N_Package_Body then\n \n-         --  If no Lib_Unit, then there was a serious previous error, so\n-         --  just ignore the entire analysis effort\n+         --  If no Lib_Unit, then there was a serious previous error, so just\n+         --  ignore the entire analysis effort\n \n          if No (Lib_Unit) then\n             return;\n@@ -688,8 +688,8 @@ package body Sem_Ch10 is\n                  (\"no legal package declaration for package body\", N);\n                return;\n \n-            --  Otherwise, the entity in the declaration is visible. Update\n-            --  the version to reflect dependence of this body on the spec.\n+            --  Otherwise, the entity in the declaration is visible. Update the\n+            --  version to reflect dependence of this body on the spec.\n \n             else\n                Spec_Id := Defining_Entity (Unit (Lib_Unit));\n@@ -1108,29 +1108,29 @@ package body Sem_Ch10 is\n             --  Case of units which do not require elaboration checks\n \n             if\n-               --  Pure units do not need checks\n+              --  Pure units do not need checks\n \n-                 Is_Pure (Spec_Id)\n+              Is_Pure (Spec_Id)\n \n-               --  Preelaborated units do not need checks\n+              --  Preelaborated units do not need checks\n \n-                 or else Is_Preelaborated (Spec_Id)\n+              or else Is_Preelaborated (Spec_Id)\n \n-               --  No checks needed if pragma Elaborate_Body present\n+              --  No checks needed if pragma Elaborate_Body present\n \n-                 or else Has_Pragma_Elaborate_Body (Spec_Id)\n+              or else Has_Pragma_Elaborate_Body (Spec_Id)\n \n-               --  No checks needed if unit does not require a body\n+              --  No checks needed if unit does not require a body\n \n-                 or else not Unit_Requires_Body (Spec_Id)\n+              or else not Unit_Requires_Body (Spec_Id)\n \n-               --  No checks needed for predefined files\n+              --  No checks needed for predefined files\n \n-                 or else Is_Predefined_File_Name (Unit_File_Name (Unum))\n+              or else Is_Predefined_File_Name (Unit_File_Name (Unum))\n \n-               --  No checks required if no separate spec\n+              --  No checks required if no separate spec\n \n-                 or else Acts_As_Spec (N)\n+              or else Acts_As_Spec (N)\n             then\n                --  This is a case where we only need the entity for\n                --  checking to prevent multiple elaboration checks.\n@@ -1283,15 +1283,15 @@ package body Sem_Ch10 is\n \n       while Present (Item) loop\n \n-         --  For with clause, analyze the with clause, and then update\n-         --  the version, since we are dependent on a unit that we with.\n+         --  For with clause, analyze the with clause, and then update the\n+         --  version, since we are dependent on a unit that we with.\n \n          if Nkind (Item) = N_With_Clause\n            and then not Limited_Present (Item)\n          then\n             --  Skip analyzing with clause if no unit, nothing to do (this\n-            --  happens for a with that references a non-existent unit)\n-            --  Skip as well if this is a with_clause for the main unit, which\n+            --  happens for a with that references a non-existent unit). Skip\n+            --  as well if this is a with_clause for the main unit, which\n             --  happens if a subunit has a useless with_clause on its parent.\n \n             if Present (Library_Unit (Item)) then\n@@ -1338,8 +1338,8 @@ package body Sem_Ch10 is\n \n             if not Implicit_With (Item) then\n \n-               --  Verify that the illegal contexts given in 10.1.2 (18/2)\n-               --  are properly rejected, including renaming declarations.\n+               --  Verify that the illegal contexts given in 10.1.2 (18/2) are\n+               --  properly rejected, including renaming declarations.\n \n                if not Nkind_In (Ukind, N_Package_Declaration,\n                                        N_Subprogram_Declaration)\n@@ -1400,8 +1400,8 @@ package body Sem_Ch10 is\n                           and then not Limited_Present (It)\n                           and then\n                             Nkind_In (Unit (Library_Unit (It)),\n-                                       N_Package_Declaration,\n-                                       N_Package_Renaming_Declaration)\n+                                      N_Package_Declaration,\n+                                      N_Package_Renaming_Declaration)\n                         then\n                            if Nkind (Unit (Library_Unit (It))) =\n                                                       N_Package_Declaration\n@@ -1512,8 +1512,8 @@ package body Sem_Ch10 is\n    -------------------------\n \n    procedure Analyze_Proper_Body (N : Node_Id; Nam : Entity_Id) is\n-      Subunit_Name      : constant Unit_Name_Type := Get_Unit_Name (N);\n-      Unum              : Unit_Number_Type;\n+      Subunit_Name : constant Unit_Name_Type := Get_Unit_Name (N);\n+      Unum         : Unit_Number_Type;\n \n       procedure Optional_Subunit;\n       --  This procedure is called when the main unit is a stub, or when we\n@@ -1556,8 +1556,8 @@ package body Sem_Ch10 is\n          then\n             Comp_Unit := Cunit (Unum);\n \n-            --  If the file was empty or seriously mangled, the unit\n-            --  itself may be missing.\n+            --  If the file was empty or seriously mangled, the unit itself may\n+            --  be missing.\n \n             if No (Unit (Comp_Unit)) then\n                Error_Msg_N\n@@ -1588,16 +1588,16 @@ package body Sem_Ch10 is\n    --  Start of processing for Analyze_Proper_Body\n \n    begin\n-      --  If the subunit is already loaded, it means that the main unit\n-      --  is a subunit, and that the current unit is one of its parents\n-      --  which was being analyzed to provide the needed context for the\n-      --  analysis of the subunit. In this case we analyze the subunit and\n-      --  continue with the parent, without looking a subsequent subunits.\n+      --  If the subunit is already loaded, it means that the main unit is a\n+      --  subunit, and that the current unit is one of its parents which was\n+      --  being analyzed to provide the needed context for the analysis of the\n+      --  subunit. In this case we analyze the subunit and continue with the\n+      --  parent, without looking a subsequent subunits.\n \n       if Is_Loaded (Subunit_Name) then\n \n-         --  If the proper body is already linked to the stub node,\n-         --  the stub is in a generic unit and just needs analyzing.\n+         --  If the proper body is already linked to the stub node, the stub is\n+         --  in a generic unit and just needs analyzing.\n \n          if Present (Library_Unit (N)) then\n             Set_Corresponding_Stub (Unit (Library_Unit (N)), N);\n@@ -1606,9 +1606,9 @@ package body Sem_Ch10 is\n          --  Otherwise we must load the subunit and link to it\n \n          else\n-            --  Load the subunit, this must work, since we originally\n-            --  loaded the subunit earlier on. So this will not really\n-            --  load it, just give access to it.\n+            --  Load the subunit, this must work, since we originally loaded\n+            --  the subunit earlier on. So this will not really load it, just\n+            --  give access to it.\n \n             Unum :=\n               Load_Unit\n@@ -1814,13 +1814,12 @@ package body Sem_Ch10 is\n    -- Analyze_Subprogram_Body_Stub --\n    ----------------------------------\n \n-   --  A subprogram body stub can appear with or without a previous\n-   --  specification. If there is one, the analysis of the body will\n-   --  find it and verify conformance.  The formals appearing in the\n-   --  specification of the stub play no role, except for requiring an\n-   --  additional conformance check. If there is no previous subprogram\n-   --  declaration, the stub acts as a spec, and provides the defining\n-   --  entity for the subprogram.\n+   --  A subprogram body stub can appear with or without a previous spec. If\n+   --  there is one, then the analysis of the body will find it and verify\n+   --  conformance. The formals appearing in the specification of the stub play\n+   --  no role, except for requiring an additional conformance check. If there\n+   --  is no previous subprogram declaration, the stub acts as a spec, and\n+   --  provides the defining entity for the subprogram.\n \n    procedure Analyze_Subprogram_Body_Stub (N : Node_Id) is\n       Decl : Node_Id;\n@@ -1861,21 +1860,19 @@ package body Sem_Ch10 is\n    -- Analyze_Subunit --\n    ---------------------\n \n-   --  A subunit is compiled either by itself (for semantic checking)\n-   --  or as part of compiling the parent (for code generation). In\n-   --  either case, by the time we actually process the subunit, the\n-   --  parent has already been installed and analyzed. The node N is\n-   --  a compilation unit, whose context needs to be treated here,\n-   --  because we come directly here from the parent without calling\n-   --  Analyze_Compilation_Unit.\n-\n-   --  The compilation context includes the explicit context of the\n-   --  subunit, and the context of the parent, together with the parent\n-   --  itself. In order to compile the current context, we remove the\n-   --  one inherited from the parent, in order to have a clean visibility\n-   --  table. We restore the parent context before analyzing the proper\n-   --  body itself. On exit, we remove only the explicit context of the\n-   --  subunit.\n+   --  A subunit is compiled either by itself (for semantic checking) or as\n+   --  part of compiling the parent (for code generation). In either case, by\n+   --  the time we actually process the subunit, the parent has already been\n+   --  installed and analyzed. The node N is a compilation unit, whose context\n+   --  needs to be treated here, because we come directly here from the parent\n+   --  without calling Analyze_Compilation_Unit.\n+\n+   --  The compilation context includes the explicit context of the subunit,\n+   --  and the context of the parent, together with the parent itself. In order\n+   --  to compile the current context, we remove the one inherited from the\n+   --  parent, in order to have a clean visibility table. We restore the parent\n+   --  context before analyzing the proper body itself. On exit, we remove only\n+   --  the explicit context of the subunit.\n \n    procedure Analyze_Subunit (N : Node_Id) is\n       Lib_Unit : constant Node_Id   := Library_Unit (N);\n@@ -1888,29 +1885,29 @@ package body Sem_Ch10 is\n       Svg             : constant Suppress_Array := Scope_Suppress;\n \n       procedure Analyze_Subunit_Context;\n-      --  Capture names in use clauses of the subunit. This must be done\n-      --  before re-installing parent declarations, because items in the\n-      --  context must not be hidden by declarations local to the parent.\n+      --  Capture names in use clauses of the subunit. This must be done before\n+      --  re-installing parent declarations, because items in the context must\n+      --  not be hidden by declarations local to the parent.\n \n       procedure Re_Install_Parents (L : Node_Id; Scop : Entity_Id);\n       --  Recursive procedure to restore scope of all ancestors of subunit,\n       --  from outermost in. If parent is not a subunit, the call to install\n-      --  context installs context of spec and (if parent is a child unit)\n-      --  the context of its parents as well. It is confusing that parents\n-      --  should be treated differently in both cases, but the semantics are\n-      --  just not identical.\n+      --  context installs context of spec and (if parent is a child unit) the\n+      --  context of its parents as well. It is confusing that parents should\n+      --  be treated differently in both cases, but the semantics are just not\n+      --  identical.\n \n       procedure Re_Install_Use_Clauses;\n       --  As part of the removal of the parent scope, the use clauses are\n-      --  removed, to be reinstalled when the context of the subunit has\n-      --  been analyzed. Use clauses may also have been affected by the\n-      --  analysis of the context of the subunit, so they have to be applied\n-      --  again, to insure that the compilation environment of the rest of\n-      --  the parent unit is identical.\n+      --  removed, to be reinstalled when the context of the subunit has been\n+      --  analyzed. Use clauses may also have been affected by the analysis of\n+      --  the context of the subunit, so they have to be applied again, to\n+      --  insure that the compilation environment of the rest of the parent\n+      --  unit is identical.\n \n       procedure Remove_Scope;\n-      --  Remove current scope from scope stack, and preserve the list\n-      --  of use clauses in it, to be reinstalled after context is analyzed.\n+      --  Remove current scope from scope stack, and preserve the list of use\n+      --  clauses in it, to be reinstalled after context is analyzed.\n \n       -----------------------------\n       -- Analyze_Subunit_Context --\n@@ -1969,8 +1966,8 @@ package body Sem_Ch10 is\n             Next (Item);\n          end loop;\n \n-         --  Reset visibility of withed units. They will be made visible\n-         --  again when we install the subunit context.\n+         --  Reset visibility of withed units. They will be made visible again\n+         --  when we install the subunit context.\n \n          Item := First (Context_Items (N));\n          while Present (Item) loop\n@@ -2038,9 +2035,9 @@ package body Sem_Ch10 is\n             Next_Entity (E);\n          end loop;\n \n-         --  A subunit appears within a body, and for a nested subunits\n-         --  all the parents are bodies. Restore full visibility of their\n-         --  private entities.\n+         --  A subunit appears within a body, and for a nested subunits all the\n+         --  parents are bodies. Restore full visibility of their private\n+         --  entities.\n \n          if Is_Package_Or_Generic_Package (Scop) then\n             Set_In_Package_Body (Scop);\n@@ -2097,8 +2094,8 @@ package body Sem_Ch10 is\n          Remove_Scope;\n          Remove_Context (Lib_Unit);\n \n-         --  Now remove parents and their context, including enclosing\n-         --  subunits and the outer parent body which is not a subunit.\n+         --  Now remove parents and their context, including enclosing subunits\n+         --  and the outer parent body which is not a subunit.\n \n          if Present (Lib_Spec) then\n             Remove_Context (Lib_Spec);\n@@ -2125,12 +2122,12 @@ package body Sem_Ch10 is\n          Re_Install_Parents (Lib_Unit, Par_Unit);\n          Set_Is_Immediately_Visible (Par_Unit);\n \n-         --  If the context includes a child unit of the parent of the\n-         --  subunit, the parent will have been removed from visibility,\n-         --  after compiling that cousin in the context. The visibility\n-         --  of the parent must be restored now. This also applies if the\n-         --  context includes another subunit of the same parent which in\n-         --  turn includes a child unit in its context.\n+         --  If the context includes a child unit of the parent of the subunit,\n+         --  the parent will have been removed from visibility, after compiling\n+         --  that cousin in the context. The visibility of the parent must be\n+         --  restored now. This also applies if the context includes another\n+         --  subunit of the same parent which in turn includes a child unit in\n+         --  its context.\n \n          if Is_Package_Or_Generic_Package (Par_Unit) then\n             if not Is_Immediately_Visible (Par_Unit)\n@@ -2151,9 +2148,9 @@ package body Sem_Ch10 is\n \n          Scope_Suppress := Svg;\n \n-         --  If the subunit is within a child unit, then siblings of any\n-         --  parent unit that appear in the context clause of the subunit\n-         --  must also be made immediately visible.\n+         --  If the subunit is within a child unit, then siblings of any parent\n+         --  unit that appear in the context clause of the subunit must also be\n+         --  made immediately visible.\n \n          if Present (Enclosing_Child) then\n             Install_Siblings (Enclosing_Child, N);\n@@ -2164,10 +2161,10 @@ package body Sem_Ch10 is\n       Analyze (Proper_Body (Unit (N)));\n       Remove_Context (N);\n \n-      --  The subunit may contain a with_clause on a sibling of some\n-      --  ancestor. Removing the context will remove from visibility those\n-      --  ancestor child units, which must be restored to the visibility\n-      --  they have in the enclosing body.\n+      --  The subunit may contain a with_clause on a sibling of some ancestor.\n+      --  Removing the context will remove from visibility those ancestor child\n+      --  units, which must be restored to the visibility they have in the\n+      --  enclosing body.\n \n       if Present (Enclosing_Child) then\n          declare\n@@ -2202,21 +2199,19 @@ package body Sem_Ch10 is\n          Nam := Full_View (Nam);\n       end if;\n \n-      if No (Nam)\n-        or else not Is_Task_Type (Etype (Nam))\n-      then\n+      if No (Nam) or else not Is_Task_Type (Etype (Nam)) then\n          Error_Msg_N (\"missing specification for task body\", N);\n       else\n          Set_Scope (Defining_Entity (N), Current_Scope);\n          Generate_Reference (Nam, Defining_Identifier (N), 'b');\n          Set_Has_Completion (Etype (Nam));\n          Analyze_Proper_Body (N, Etype (Nam));\n \n-         --  Set elaboration flag to indicate that entity is callable.\n-         --  This cannot be done in the expansion of the body  itself,\n-         --  because the proper body is not in a declarative part. This\n-         --  is only done if expansion is active, because the context\n-         --  may be generic and the flag not defined yet.\n+         --  Set elaboration flag to indicate that entity is callable. This\n+         --  cannot be done in the expansion of the body itself, because the\n+         --  proper body is not in a declarative part. This is only done if\n+         --  expansion is active, because the context may be generic and the\n+         --  flag not defined yet.\n \n          if Expander_Active then\n             Insert_After (N,\n@@ -2226,24 +2221,23 @@ package body Sem_Ch10 is\n                     New_External_Name (Chars (Etype (Nam)), 'E')),\n                  Expression => New_Reference_To (Standard_True, Loc)));\n          end if;\n-\n       end if;\n    end Analyze_Task_Body_Stub;\n \n    -------------------------\n    -- Analyze_With_Clause --\n    -------------------------\n \n-   --  Analyze the declaration of a unit in a with clause. At end,\n-   --  label the with clause with the defining entity for the unit.\n+   --  Analyze the declaration of a unit in a with clause. At end, label the\n+   --  with clause with the defining entity for the unit.\n \n    procedure Analyze_With_Clause (N : Node_Id) is\n \n-      --  Retrieve the original kind of the unit node, before analysis.\n-      --  If it is a subprogram instantiation, its analysis below will\n-      --  rewrite as the declaration of the wrapper package. If the same\n-      --  instantiation appears indirectly elsewhere in the context, it\n-      --  will have been analyzed already.\n+      --  Retrieve the original kind of the unit node, before analysis. If it\n+      --  is a subprogram instantiation, its analysis below will rewrite the\n+      --  node as the declaration of the wrapper package. If the same\n+      --  instantiation appears indirectly elsewhere in the context, it will\n+      --  have been analyzed already.\n \n       Unit_Kind : constant Node_Kind :=\n                     Nkind (Original_Node (Unit (Library_Unit (N))));\n@@ -2533,6 +2527,10 @@ package body Sem_Ch10 is\n       --  Returns true if and only if the library unit is declared with\n       --  an explicit designation of private.\n \n+      -----------------------------\n+      -- Is_Private_Library_Unit --\n+      -----------------------------\n+\n       function Is_Private_Library_Unit (Unit : Entity_Id) return Boolean is\n          Comp_Unit : constant Node_Id := Parent (Unit_Declaration_Node (Unit));\n \n@@ -2792,8 +2790,7 @@ package body Sem_Ch10 is\n       Set_Implicit_With      (Withn, True);\n \n       --  If the unit is a package declaration, a private_with_clause on a\n-      --  child unit implies that the implicit with on the parent is also\n-      --  private.\n+      --  child unit implies the implicit with on the parent is also private.\n \n       if Nkind (Unit (N)) = N_Package_Declaration then\n          Set_Private_Present (Withn, Private_Present (Item));\n@@ -2930,9 +2927,11 @@ package body Sem_Ch10 is\n \n       function Build_Unit_Name return Node_Id is\n          Result : Node_Id;\n+\n       begin\n          if No (Parent_Spec (P_Unit)) then\n             return New_Reference_To (P_Name, Loc);\n+\n          else\n             Result :=\n               Make_Expanded_Name (Loc,\n@@ -3120,13 +3119,10 @@ package body Sem_Ch10 is\n \n             if Sloc (Library_Unit (Item)) /= No_Location then\n                License_Check : declare\n-\n                   Withu : constant Unit_Number_Type :=\n                             Get_Source_Unit (Library_Unit (Item));\n-\n                   Withl : constant License_Type :=\n                             License (Source_Index (Withu));\n-\n                   Unitl : constant License_Type :=\n                            License (Source_Index (Current_Sem_Unit));\n \n@@ -3306,13 +3302,13 @@ package body Sem_Ch10 is\n \n       procedure Check_Private_Limited_Withed_Unit (Item : Node_Id);\n       --  Check that if a limited_with clause of a given compilation_unit\n-      --  mentions a descendant of a private child of some library unit,\n-      --  then the given compilation_unit shall be the declaration of a\n-      --  private descendant of that library unit, or a public descendant\n-      --  of such. The code is analogous to that of Check_Private_Child_Unit\n-      --  but we cannot use entities on the limited with_clauses because\n-      --  their units have not been analyzed, so we have to climb the tree\n-      --  of ancestors looking for private keywords.\n+      --  mentions a descendant of a private child of some library unit, then\n+      --  the given compilation_unit shall be the declaration of a private\n+      --  descendant of that library unit, or a public descendant of such. The\n+      --  code is analogous to that of Check_Private_Child_Unit but we cannot\n+      --  use entities on the limited with_clauses because their units have not\n+      --  been analyzed, so we have to climb the tree of ancestors looking for\n+      --  private keywords.\n \n       procedure Expand_Limited_With_Clause\n         (Comp_Unit : Node_Id;\n@@ -3431,7 +3427,7 @@ package body Sem_Ch10 is\n          Child_Parent := Library_Unit (Item);\n \n          --  If the child unit is a public child, then locate its nearest\n-         --  private ancestor, if any; Child_Parent will then be set to\n+         --  private ancestor, if any, then Child_Parent will then be set to\n          --  the parent of that ancestor.\n \n          if not Private_Present (Library_Unit (Item)) then\n@@ -3448,8 +3444,8 @@ package body Sem_Ch10 is\n \n          Child_Parent := Parent_Spec (Unit (Child_Parent));\n \n-         --  Traverse all the ancestors of the current compilation\n-         --  unit to check if it is a descendant of named library unit.\n+         --  Traverse all the ancestors of the current compilation unit to\n+         --  check if it is a descendant of named library unit.\n \n          Curr_Parent := Parent (Item);\n          Curr_Private := Private_Present (Curr_Parent);\n@@ -3472,8 +3468,8 @@ package body Sem_Ch10 is\n             or else Curr_Private\n             or else Private_Present (Item)\n             or else Nkind_In (Unit (Parent (Item)), N_Package_Body,\n-                                                        N_Subprogram_Body,\n-                                                        N_Subunit)\n+                                                    N_Subprogram_Body,\n+                                                    N_Subunit)\n          then\n             --  Current unit is private, of descendant of a private unit\n \n@@ -3646,8 +3642,8 @@ package body Sem_Ch10 is\n       end loop;\n \n       --  Ada 2005 (AI-412): Examine the visible declarations of a package\n-      --  spec, looking for incomplete subtype declarations of incomplete\n-      --  types visible through a limited with clause.\n+      --  spec, looking for incomplete subtype declarations of incomplete types\n+      --  visible through a limited with clause.\n \n       if Ada_Version >= Ada_05\n         and then Analyzed (N)\n@@ -3872,10 +3868,10 @@ package body Sem_Ch10 is\n       Item := First (Context_Items (N));\n       while Present (Item) loop\n \n-         --  Do not install private_with_clauses declaration, unless\n-         --  unit is itself a private child unit, or is a body.\n-         --  Note that for a subprogram body the private_with_clause does\n-         --  not take effect until after the specification.\n+         --  Do not install private_with_clauses declaration, unless unit\n+         --  is itself a private child unit, or is a body. Note that for a\n+         --  subprogram body the private_with_clause does not take effect until\n+         --  after the specification.\n \n          if Nkind (Item) /= N_With_Clause\n            or else Implicit_With (Item)\n@@ -3894,8 +3890,8 @@ package body Sem_Ch10 is\n             then\n                Set_Is_Immediately_Visible (Id);\n \n-               --  Check for the presence of another unit in the context,\n-               --  that may be inadvertently hidden by the child.\n+               --  Check for the presence of another unit in the context that\n+               --  may be inadvertently hidden by the child.\n \n                Prev := Current_Entity (Id);\n \n@@ -4119,7 +4115,8 @@ package body Sem_Ch10 is\n                Next (Decl);\n             end loop;\n \n-            --  Look for declarations that require the presence of a body\n+            --  Look for declarations that require the presence of a body. We\n+            --  have already skipped pragmas at the start of the list.\n \n             while Present (Decl) loop\n \n@@ -4395,7 +4392,7 @@ package body Sem_Ch10 is\n                Next (Item);\n             end loop;\n \n-            --  If it's a body not acting as spec, follow pointer to\n+            --  If it is a body not acting as spec, follow pointer to the\n             --  corresponding spec, otherwise follow pointer to parent spec.\n \n             if Present (Library_Unit (Aux_Unit))\n@@ -4506,7 +4503,7 @@ package body Sem_Ch10 is\n          --  One of the ancestors has a limited with clause\n \n         and then Nkind (Parent (Parent (Main_Unit_Entity))) =\n-                   N_Package_Specification\n+                                                   N_Package_Specification\n         and then Has_Limited_With_Clause (Scope (Main_Unit_Entity), P)\n       then\n          return;\n@@ -4532,8 +4529,7 @@ package body Sem_Ch10 is\n       if Analyzed (P_Unit)\n         and then\n           (Is_Immediately_Visible (P)\n-            or else\n-              (Is_Child_Package and then Is_Visible_Child_Unit (P)))\n+            or else (Is_Child_Package and then Is_Visible_Child_Unit (P)))\n       then\n          return;\n       end if;\n@@ -4775,9 +4771,9 @@ package body Sem_Ch10 is\n          Write_Eol;\n       end if;\n \n-      --  We do not apply the restrictions to an internal unit unless\n-      --  we are compiling the internal unit as a main unit. This check\n-      --  is also skipped for dummy units (for missing packages).\n+      --  We do not apply the restrictions to an internal unit unless we are\n+      --  compiling the internal unit as a main unit. This check is also\n+      --  skipped for dummy units (for missing packages).\n \n       if Sloc (Uname) /= No_Location\n         and then (not Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit))\n@@ -4949,8 +4945,9 @@ package body Sem_Ch10 is\n       C_Unit : constant Node_Id := Cunit (Current_Sem_Unit);\n    begin\n       return Nkind (Unit (C_Unit)) = N_Package_Body\n-        and then Has_With_Clause (C_Unit,\n-                   Cunit_Entity (Get_Source_Unit (Non_Limited_View (T))));\n+        and then\n+          Has_With_Clause\n+            (C_Unit, Cunit_Entity (Get_Source_Unit (Non_Limited_View (T))));\n    end Is_Legal_Shadow_Entity_In_Body;\n \n    -----------------------\n@@ -5024,9 +5021,7 @@ package body Sem_Ch10 is\n       Last_Lim_E     : Entity_Id := Empty; --  Last limited entity built\n       Last_Pub_Lim_E : Entity_Id;          --  To set the first private entity\n \n-      procedure Decorate_Incomplete_Type\n-        (E    : Entity_Id;\n-         Scop : Entity_Id);\n+      procedure Decorate_Incomplete_Type (E : Entity_Id; Scop : Entity_Id);\n       --  Add attributes of an incomplete type to a shadow entity. The same\n       --  attributes are placed on the real entity, so that gigi receives\n       --  a consistent view.\n@@ -5042,9 +5037,7 @@ package body Sem_Ch10 is\n       --  Set basic attributes of tagged type T, including its class_wide type.\n       --  The parameters Loc, Scope are used to decorate the class_wide type.\n \n-      procedure Build_Chain\n-        (Scope      : Entity_Id;\n-         First_Decl : Node_Id);\n+      procedure Build_Chain (Scope : Entity_Id; First_Decl : Node_Id);\n       --  Construct list of shadow entities and attach it to entity of\n       --  package that is mentioned in a limited_with clause.\n \n@@ -5055,122 +5048,11 @@ package body Sem_Ch10 is\n       --  Build a new internal entity and append it to the list of shadow\n       --  entities available through the limited-header\n \n-      ------------------------------\n-      -- Decorate_Incomplete_Type --\n-      ------------------------------\n-\n-      procedure Decorate_Incomplete_Type\n-        (E    : Entity_Id;\n-         Scop : Entity_Id)\n-      is\n-      begin\n-         Set_Ekind             (E, E_Incomplete_Type);\n-         Set_Scope             (E, Scop);\n-         Set_Etype             (E, E);\n-         Set_Is_First_Subtype  (E, True);\n-         Set_Stored_Constraint (E, No_Elist);\n-         Set_Full_View         (E, Empty);\n-         Init_Size_Align       (E);\n-      end Decorate_Incomplete_Type;\n-\n-      --------------------------\n-      -- Decorate_Tagged_Type --\n-      --------------------------\n-\n-      procedure Decorate_Tagged_Type\n-        (Loc  : Source_Ptr;\n-         T    : Entity_Id;\n-         Scop : Entity_Id)\n-      is\n-         CW : Entity_Id;\n-\n-      begin\n-         Decorate_Incomplete_Type (T, Scop);\n-         Set_Is_Tagged_Type (T);\n-\n-         --  Build corresponding class_wide type, if not previously done\n-\n-         --  Note: The class-wide entity is shared by the limited-view\n-         --  and the full-view.\n-\n-         if No (Class_Wide_Type (T)) then\n-            CW := Make_Defining_Identifier (Loc,  New_Internal_Name ('S'));\n-\n-            --  Set parent to be the same as the parent of the tagged type.\n-            --  We need a parent field set, and it is supposed to point to\n-            --  the declaration of the type. The tagged type declaration\n-            --  essentially declares two separate types, the tagged type\n-            --  itself and the corresponding class-wide type, so it is\n-            --  reasonable for the parent fields to point to the declaration\n-            --  in both cases.\n-\n-            Set_Parent (CW, Parent (T));\n-\n-            --  Set remaining fields of classwide type\n-\n-            Set_Ekind                     (CW, E_Class_Wide_Type);\n-            Set_Etype                     (CW, T);\n-            Set_Scope                     (CW, Scop);\n-            Set_Is_Tagged_Type            (CW);\n-            Set_Is_First_Subtype          (CW, True);\n-            Init_Size_Align               (CW);\n-            Set_Has_Unknown_Discriminants (CW, True);\n-            Set_Class_Wide_Type           (CW, CW);\n-            Set_Equivalent_Type           (CW, Empty);\n-            Set_From_With_Type            (CW, From_With_Type (T));\n-\n-            --  Link type to its class-wide type\n-\n-            Set_Class_Wide_Type           (T, CW);\n-         end if;\n-      end Decorate_Tagged_Type;\n-\n-      ------------------------------------\n-      -- Decorate_Package_Specification --\n-      ------------------------------------\n-\n-      procedure Decorate_Package_Specification (P : Entity_Id) is\n-      begin\n-         --  Place only the most basic attributes\n-\n-         Set_Ekind (P, E_Package);\n-         Set_Etype (P, Standard_Void_Type);\n-      end Decorate_Package_Specification;\n-\n-      --------------------------------\n-      -- New_Internal_Shadow_Entity --\n-      --------------------------------\n-\n-      function New_Internal_Shadow_Entity\n-        (Kind       : Entity_Kind;\n-         Sloc_Value : Source_Ptr;\n-         Id_Char    : Character) return Entity_Id\n-      is\n-         E : constant Entity_Id :=\n-               Make_Defining_Identifier (Sloc_Value,\n-                 Chars => New_Internal_Name (Id_Char));\n-\n-      begin\n-         Set_Ekind       (E, Kind);\n-         Set_Is_Internal (E, True);\n-\n-         if Kind in Type_Kind then\n-            Init_Size_Align (E);\n-         end if;\n-\n-         Append_Entity (E, Lim_Header);\n-         Last_Lim_E := E;\n-         return E;\n-      end New_Internal_Shadow_Entity;\n-\n       -----------------\n       -- Build_Chain --\n       -----------------\n \n-      procedure Build_Chain\n-        (Scope         : Entity_Id;\n-         First_Decl    : Node_Id)\n-      is\n+      procedure Build_Chain (Scope : Entity_Id; First_Decl : Node_Id) is\n          Analyzed_Unit : constant Boolean := Analyzed (Cunit (Unum));\n          Is_Tagged     : Boolean;\n          Decl          : Node_Id;\n@@ -5219,10 +5101,11 @@ package body Sem_Ch10 is\n \n                --  Create shadow entity for type\n \n-               Lim_Typ := New_Internal_Shadow_Entity\n-                 (Kind       => Ekind (Comp_Typ),\n-                  Sloc_Value => Sloc (Comp_Typ),\n-                  Id_Char    => 'Z');\n+               Lim_Typ :=\n+                 New_Internal_Shadow_Entity\n+                   (Kind       => Ekind (Comp_Typ),\n+                    Sloc_Value => Sloc (Comp_Typ),\n+                    Id_Char    => 'Z');\n \n                Set_Chars  (Lim_Typ, Chars (Comp_Typ));\n                Set_Parent (Lim_Typ, Parent (Comp_Typ));\n@@ -5256,10 +5139,11 @@ package body Sem_Ch10 is\n                   end if;\n                end if;\n \n-               Lim_Typ  := New_Internal_Shadow_Entity\n-                 (Kind       => Ekind (Comp_Typ),\n-                  Sloc_Value => Sloc (Comp_Typ),\n-                  Id_Char    => 'Z');\n+               Lim_Typ :=\n+                 New_Internal_Shadow_Entity\n+                   (Kind       => Ekind (Comp_Typ),\n+                    Sloc_Value => Sloc (Comp_Typ),\n+                    Id_Char    => 'Z');\n \n                Set_Chars  (Lim_Typ, Chars (Comp_Typ));\n                Set_Parent (Lim_Typ, Parent (Comp_Typ));\n@@ -5282,10 +5166,11 @@ package body Sem_Ch10 is\n \n                --  Create shadow entity for type\n \n-               Lim_Typ := New_Internal_Shadow_Entity\n-                 (Kind       => Ekind (Comp_Typ),\n-                  Sloc_Value => Sloc (Comp_Typ),\n-                  Id_Char    => 'Z');\n+               Lim_Typ :=\n+                 New_Internal_Shadow_Entity\n+                   (Kind       => Ekind (Comp_Typ),\n+                    Sloc_Value => Sloc (Comp_Typ),\n+                    Id_Char    => 'Z');\n \n                Set_Chars  (Lim_Typ, Chars (Comp_Typ));\n                Set_Parent (Lim_Typ, Parent (Comp_Typ));\n@@ -5309,10 +5194,11 @@ package body Sem_Ch10 is\n                      Set_Scope (Comp_Typ, Scope);\n                   end if;\n \n-                  Lim_Typ  := New_Internal_Shadow_Entity\n-                    (Kind       => Ekind (Comp_Typ),\n-                     Sloc_Value => Sloc (Comp_Typ),\n-                     Id_Char    => 'Z');\n+                  Lim_Typ :=\n+                    New_Internal_Shadow_Entity\n+                      (Kind       => Ekind (Comp_Typ),\n+                       Sloc_Value => Sloc (Comp_Typ),\n+                       Id_Char    => 'Z');\n \n                   Decorate_Package_Specification (Lim_Typ);\n                   Set_Scope (Lim_Typ, Scope);\n@@ -5334,6 +5220,111 @@ package body Sem_Ch10 is\n          end loop;\n       end Build_Chain;\n \n+      ------------------------------\n+      -- Decorate_Incomplete_Type --\n+      ------------------------------\n+\n+      procedure Decorate_Incomplete_Type (E : Entity_Id; Scop : Entity_Id) is\n+      begin\n+         Set_Ekind             (E, E_Incomplete_Type);\n+         Set_Scope             (E, Scop);\n+         Set_Etype             (E, E);\n+         Set_Is_First_Subtype  (E, True);\n+         Set_Stored_Constraint (E, No_Elist);\n+         Set_Full_View         (E, Empty);\n+         Init_Size_Align       (E);\n+      end Decorate_Incomplete_Type;\n+\n+      --------------------------\n+      -- Decorate_Tagged_Type --\n+      --------------------------\n+\n+      procedure Decorate_Tagged_Type\n+        (Loc  : Source_Ptr;\n+         T    : Entity_Id;\n+         Scop : Entity_Id)\n+      is\n+         CW : Entity_Id;\n+\n+      begin\n+         Decorate_Incomplete_Type (T, Scop);\n+         Set_Is_Tagged_Type (T);\n+\n+         --  Build corresponding class_wide type, if not previously done\n+\n+         --  Note: The class-wide entity is shared by the limited-view\n+         --  and the full-view.\n+\n+         if No (Class_Wide_Type (T)) then\n+            CW := Make_Defining_Identifier (Loc,  New_Internal_Name ('S'));\n+\n+            --  Set parent to be the same as the parent of the tagged type.\n+            --  We need a parent field set, and it is supposed to point to\n+            --  the declaration of the type. The tagged type declaration\n+            --  essentially declares two separate types, the tagged type\n+            --  itself and the corresponding class-wide type, so it is\n+            --  reasonable for the parent fields to point to the declaration\n+            --  in both cases.\n+\n+            Set_Parent (CW, Parent (T));\n+\n+            --  Set remaining fields of classwide type\n+\n+            Set_Ekind                     (CW, E_Class_Wide_Type);\n+            Set_Etype                     (CW, T);\n+            Set_Scope                     (CW, Scop);\n+            Set_Is_Tagged_Type            (CW);\n+            Set_Is_First_Subtype          (CW, True);\n+            Init_Size_Align               (CW);\n+            Set_Has_Unknown_Discriminants (CW, True);\n+            Set_Class_Wide_Type           (CW, CW);\n+            Set_Equivalent_Type           (CW, Empty);\n+            Set_From_With_Type            (CW, From_With_Type (T));\n+\n+            --  Link type to its class-wide type\n+\n+            Set_Class_Wide_Type           (T, CW);\n+         end if;\n+      end Decorate_Tagged_Type;\n+\n+      ------------------------------------\n+      -- Decorate_Package_Specification --\n+      ------------------------------------\n+\n+      procedure Decorate_Package_Specification (P : Entity_Id) is\n+      begin\n+         --  Place only the most basic attributes\n+\n+         Set_Ekind (P, E_Package);\n+         Set_Etype (P, Standard_Void_Type);\n+      end Decorate_Package_Specification;\n+\n+      --------------------------------\n+      -- New_Internal_Shadow_Entity --\n+      --------------------------------\n+\n+      function New_Internal_Shadow_Entity\n+        (Kind       : Entity_Kind;\n+         Sloc_Value : Source_Ptr;\n+         Id_Char    : Character) return Entity_Id\n+      is\n+         E : constant Entity_Id :=\n+               Make_Defining_Identifier (Sloc_Value,\n+                 Chars => New_Internal_Name (Id_Char));\n+\n+      begin\n+         Set_Ekind       (E, Kind);\n+         Set_Is_Internal (E, True);\n+\n+         if Kind in Type_Kind then\n+            Init_Size_Align (E);\n+         end if;\n+\n+         Append_Entity (E, Lim_Header);\n+         Last_Lim_E := E;\n+         return E;\n+      end New_Internal_Shadow_Entity;\n+\n    --  Start of processing for Build_Limited_Views\n \n    begin\n@@ -5420,11 +5411,11 @@ package body Sem_Ch10 is\n                    First_Decl => First (Private_Declarations (Spec)));\n \n       if Last_Pub_Lim_E /= Empty then\n-         Set_First_Private_Entity (Lim_Header,\n-                                   Next_Entity (Last_Pub_Lim_E));\n+         Set_First_Private_Entity\n+           (Lim_Header, Next_Entity (Last_Pub_Lim_E));\n       else\n-         Set_First_Private_Entity (Lim_Header,\n-                                   First_Entity (P));\n+         Set_First_Private_Entity\n+           (Lim_Header, First_Entity (P));\n       end if;\n \n       Set_Limited_View_Installed (Spec);\n@@ -5467,8 +5458,7 @@ package body Sem_Ch10 is\n             return True;\n \n          elsif Ekind (E) = E_Package\n-           and then\n-             Nkind (Unit_Declaration_Node (E)) = N_Package_Declaration\n+           and then Nkind (Unit_Declaration_Node (E)) = N_Package_Declaration\n            and then Present (Corresponding_Body (Unit_Declaration_Node (E)))\n          then\n             Ent := First_Entity (E);\n@@ -5491,16 +5481,16 @@ package body Sem_Ch10 is\n \n    begin\n       if Ekind (Unit_Name) = E_Generic_Package\n-        and then\n-          Nkind (Unit_Declaration_Node (Unit_Name)) =\n+        and then Nkind (Unit_Declaration_Node (Unit_Name)) =\n                                             N_Generic_Package_Declaration\n         and then\n           Present (Corresponding_Body (Unit_Declaration_Node (Unit_Name)))\n       then\n          Set_Body_Needed_For_SAL (Unit_Name);\n \n       elsif Ekind (Unit_Name) = E_Generic_Procedure\n-        or else Ekind (Unit_Name) = E_Generic_Function\n+              or else\n+            Ekind (Unit_Name) = E_Generic_Function\n       then\n          Set_Body_Needed_For_SAL (Unit_Name);\n \n@@ -5696,15 +5686,13 @@ package body Sem_Ch10 is\n             if Ekind (Lim_Typ) /= E_Package\n               and then not Is_Child_Unit (Non_Limited_View (Lim_Typ))\n             then\n-\n-               --  If the package has incomplete types, the limited view\n-               --  of the incomplete type is in fact never visible (AI05-129)\n-               --  but we have created a shadow entity E1 for it, that points\n-               --  to E2, a non-limited incomplete type. This in turn has a\n-               --  full view E3 that is the full declaration. There is a\n-               --  corresponding shadow entity E4. When reinstalling the\n-               --  non-limited view, E2 must become the current entity and\n-               --  E3 must be ignored.\n+               --  If the package has incomplete types, the limited view of the\n+               --  incomplete type is in fact never visible (AI05-129) but we\n+               --  have created a shadow entity E1 for it, that points to E2,\n+               --  a non-limited incomplete type. This in turn has a full view\n+               --  E3 that is the full declaration. There is a corresponding\n+               --  shadow entity E4. When reinstalling the non-limited view,\n+               --  E2 must become the current entity and E3 must be ignored.\n \n                E := Non_Limited_View (Lim_Typ);\n \n@@ -5714,8 +5702,8 @@ package body Sem_Ch10 is\n                then\n \n                   --  Lim_Typ is the limited view of a full type declaration\n-                  --  that has a previous incomplete declaration, i.e. E3\n-                  --  from the previous description. Nothing to insert.\n+                  --  that has a previous incomplete declaration, i.e. E3 from\n+                  --  the previous description. Nothing to insert.\n \n                   null;\n \n@@ -5778,7 +5766,6 @@ package body Sem_Ch10 is\n       end if;\n \n       if Present (P_Spec) then\n-\n          P := Unit (P_Spec);\n          P_Name := Get_Parent_Entity (P);\n          Remove_Context_Clauses (P_Spec);\n@@ -5799,9 +5786,9 @@ package body Sem_Ch10 is\n \n          Set_In_Package_Body (P_Name, False);\n \n-         --  This is the recursive call to remove the context of any\n-         --  higher level parent. This recursion ensures that all parents\n-         --  are removed in the reverse order of their installation.\n+         --  This is the recursive call to remove the context of any higher\n+         --  level parent. This recursion ensures that all parents are removed\n+         --  in the reverse order of their installation.\n \n          Remove_Parents (P);\n       end if;\n@@ -5815,9 +5802,9 @@ package body Sem_Ch10 is\n       Item : Node_Id;\n \n       function In_Regular_With_Clause (E : Entity_Id) return Boolean;\n-      --  Check whether a given unit appears in a regular with_clause.\n-      --  Used to determine whether a private_with_clause, implicit or\n-      --  explicit, should be ignored.\n+      --  Check whether a given unit appears in a regular with_clause. Used to\n+      --  determine whether a private_with_clause, implicit or explicit, should\n+      --  be ignored.\n \n       ----------------------------\n       -- In_Regular_With_Clause --"}, {"sha": "a27c1479e228aa506eeaa50b8b63960c31d14fa8", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eab5a95753e09c22158046f43129d6a1c194af5/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eab5a95753e09c22158046f43129d6a1c194af5/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=6eab5a95753e09c22158046f43129d6a1c194af5", "patch": "@@ -814,7 +814,10 @@ __gnat_localtime_tzoff (const time_t *timer, long *off)\n }\n \n #else\n-#if defined (__Lynx__) && defined (___THREADS_POSIX4ad4__)\n+\n+/* On Lynx, all time values are treated in GMT */\n+\n+#if defined (__Lynx__)\n \n /* As of LynxOS 3.1.0a patch level 040, LynuxWorks changes the\n    prototype to the C library function localtime_r from the POSIX.4\n@@ -828,44 +831,58 @@ __gnat_localtime_tzoff (const time_t *, long *);\n void\n __gnat_localtime_tzoff (const time_t *timer, long *off)\n {\n-  /* Treat all time values in GMT */\n   *off = 0;\n }\n \n #else\n+\n+/* VMS does not need __gnat_locatime_tzoff */\n+\n #if defined (VMS)\n \n-/* __gnat_localtime_tzoff is not needed on VMS */\n+/* Other targets except Lynx, VMS and Windows provide a standard locatime_r */\n \n #else\n \n-/* All other targets provide a standard localtime_r */\n+#define Lock_Task system__soft_links__lock_task\n+extern void (*Lock_Task) (void);\n+\n+#define Unlock_Task system__soft_links__unlock_task\n+extern void (*Unlock_Task) (void);\n \n extern void\n __gnat_localtime_tzoff (const time_t *, long *);\n \n void\n __gnat_localtime_tzoff (const time_t *timer, long *off)\n {\n-   struct tm tp;\n-   localtime_r (timer, &tp);\n+  struct tm tp;\n \n /* AIX, HPUX, SGI Irix, Sun Solaris */\n #if defined (_AIX) || defined (__hpux__) || defined (sgi) || defined (sun)\n-   *off = (long) -timezone;\n-   if (tp.tm_isdst > 0)\n-     *off = *off + 3600;\n+{\n+  (*Lock_Task) ();\n \n-/* Lynx - Treat all time values in GMT */\n-#elif defined (__Lynx__)\n-  *off = 0;\n+  localtime_r (timer, &tp);\n+  *off = (long) -timezone;\n+\n+  (*Unlock_Task) ();\n+\n+  if (tp.tm_isdst > 0)\n+    *off = *off + 3600;\n+}\n \n /* VxWorks */\n #elif defined (__vxworks)\n #include <stdlib.h>\n {\n+  (*Lock_Task) ();\n+\n+  localtime_r (timer, &tp);\n+\n   /* Try to read the environment variable TIMEZONE. The variable may not have\n      been initialize, in that case return an offset of zero (0) for UTC. */\n+\n   char *tz_str = getenv (\"TIMEZONE\");\n \n   if ((tz_str == NULL) || (*tz_str == '\\0'))\n@@ -880,24 +897,34 @@ __gnat_localtime_tzoff (const time_t *timer, long *off)\n        the value of U involves setting two pointers, one at the beginning and\n        one at the end of the value. The end pointer is then set to null in\n        order to delimit a string slice for atol to process. */\n+\n     tz_start = index (tz_str, ':') + 2;\n     tz_end = index (tz_start, ':');\n     tz_end = '\\0';\n \n     /* The Ada layer expects an offset in seconds */\n+\n     *off = atol (tz_start) * 60;\n   }\n+\n+  (*Unlock_Task) ();\n }\n \n /* Darwin, Free BSD, Linux, Tru64, where component tm_gmtoff is present in\n    struct tm */\n+\n #elif defined (__APPLE__) || defined (__FreeBSD__) || defined (linux) ||\\\n      (defined (__alpha__) && defined (__osf__)) || defined (__GLIBC__)\n+{\n+  localtime_r (timer, &tp);\n   *off = tp.tm_gmtoff;\n+}\n+\n+/* Default: treat all time values in GMT */\n \n-/* All other platforms: Treat all time values in GMT */\n #else\n   *off = 0;\n+\n #endif\n }\n "}]}