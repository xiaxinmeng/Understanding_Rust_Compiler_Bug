{"sha": "61321991ff5f055015750ddf36444705b9921464", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEzMjE5OTFmZjVmMDU1MDE1NzUwZGRmMzY0NDQ3MDViOTkyMTQ2NA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-03-01T22:24:19Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-03-01T22:24:19Z"}, "message": "re PR fortran/26393 (ICE with function returning variable lenght array)\n\n2006-03-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* iresolve.c (gfc_resolve_dot_product):  Remove any difference in\n\ttreatment of logical types.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_dot_product):  New function. \n\n\tPR fortran/26393\n\t* trans-decl.c (gfc_get_symbol_decl): Extend condition that symbols\n\tmust be referenced to include unreferenced symbols in an interface\n\tbody. \n\n\tPR fortran/20938\n\t* trans-array.c (gfc_conv_resolve_dependencies): Add call to\n\tgfc_are_equivalenced_arrays.\n\t* symbol.c (gfc_free_equiv_infos, gfc_free_equiv_lists): New\n\tfunctions. (gfc_free_namespace): Call them.\n\t* trans-common.c (copy_equiv_list_to_ns): New function.\n\t(add_equivalences): Call it.\n\t* gfortran.h: Add equiv_lists to gfc_namespace and define\n\tgfc_equiv_list and gfc_equiv_info.\n\t* dependency.c (gfc_are_equivalenced_arrays): New function.\n\t(gfc_check_dependency): Call it.\n\t* dependency.h: Prototype for gfc_are_equivalenced_arrays.\n\n2006-03-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.dg/logical_dot_product.f90: New test. \n\n\tPR fortran/26393\n\t* gfortran.dg/used_interface_ref.f90: New test.\n\n\tPR fortran/20938\n\t* gfortran.dg/dependency_2.f90: New test.\n\t* gfortran.fortran-torture/execute/where17.f90: New test.\n\t* gfortran.fortran-torture/execute/where18.f90: New test.\n\t* gfortran.fortran-torture/execute/where19.f90: New test.\n\t* gfortran.fortran-torture/execute/where20.f90: New test.\n\nFrom-SVN: r111616", "tree": {"sha": "1fb7018901bd09ec73d55b0ccf66775cd2947e62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fb7018901bd09ec73d55b0ccf66775cd2947e62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61321991ff5f055015750ddf36444705b9921464", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61321991ff5f055015750ddf36444705b9921464", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61321991ff5f055015750ddf36444705b9921464", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61321991ff5f055015750ddf36444705b9921464/comments", "author": null, "committer": null, "parents": [{"sha": "8acb1b3d1c6369349372f74e815db2375ea8e0c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8acb1b3d1c6369349372f74e815db2375ea8e0c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8acb1b3d1c6369349372f74e815db2375ea8e0c5"}], "stats": {"total": 487, "additions": 467, "deletions": 20}, "files": [{"sha": "f2f74e5447d23e6f8711da255615514ac1c7fa1b", "filename": "MAINTAINERS", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -120,6 +120,8 @@ fortran 95\t\tFran\n fortran 95              Bud Davis               jmdavis@link.com\n fortran 95\t\tSteve Kargl\t\tsgk@troutmask.apl.washington.edu\n fortran 95              Erik Edelmann           erik.edelmann@iki.fi\n+fortran 95\t\tPaul Thomas\t\tpault@gcc.gnu.org\n+fortran 95\t\tTobias Schl\ufffdter\t\ttobias.schlueter@physik.uni-muenchen.de\n c++\t\t\tJason Merrill\t\tjason@redhat.com\n c++                     Mark Mitchell\t\tmark@codesourcery.com\n c++\t\t\tNathan Sidwell\t\tnathan@codesourcery.com\n@@ -327,7 +329,6 @@ Ira Ruben\t\t\t\t\tira@apple.com\n Douglas Rupp\t\t\t\t\trupp@gnat.com\n Matthew Sachs\t\t\t\t\tmsachs@apple.com\n Alex Samuel\t\t\t\t\tsamuel@codesourcery.com\n-Tobias Schl\ufffdter\t\t\t\t\ttobias.schlueter@physik.uni-muenchen.de\n Svein Seldal                                    svein@dev.seldal.com\n Thiemo Seufer\t\t\t\t\tths@networkno.de\n Franz Sirl\t\t\t\t\tfranz.sirl-kernel@lauterbach.com\n@@ -336,7 +337,6 @@ Richard Stallman\t\t\t\trms@gnu.org\n Graham Stott\t\t\t\t\tgraham.stott@btinternet.com\n Mike Stump\t\t\t\t\tmrs@apple.com\n Jeff Sturm\t\t\t\t\tjsturm@gcc.gnu.org\n-Paul Thomas\t\t\t\t\tpault@gcc.gnu.org\n Kresten Krab Thorup\t\t\t\tkrab@gcc.gnu.org\n Caroline Tice\t\t\t\t\tctice@apple.com\n Michael Tiemann\t\t\t\t\ttiemann@redhat.com"}, {"sha": "d434281c10b0e9599cba38f6d8b032470bc4d973", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -1,3 +1,27 @@\n+2006-03-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* iresolve.c (gfc_resolve_dot_product):  Remove any difference in\n+\ttreatment of logical types.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_dot_product):  New function. \n+\n+\tPR fortran/26393\n+\t* trans-decl.c (gfc_get_symbol_decl): Extend condition that symbols\n+\tmust be referenced to include unreferenced symbols in an interface\n+\tbody. \n+\n+\tPR fortran/20938\n+\t* trans-array.c (gfc_conv_resolve_dependencies): Add call to\n+\tgfc_are_equivalenced_arrays.\n+\t* symbol.c (gfc_free_equiv_infos, gfc_free_equiv_lists): New\n+\tfunctions. (gfc_free_namespace): Call them.\n+\t* trans-common.c (copy_equiv_list_to_ns): New function.\n+\t(add_equivalences): Call it.\n+\t* gfortran.h: Add equiv_lists to gfc_namespace and define\n+\tgfc_equiv_list and gfc_equiv_info.\n+\t* dependency.c (gfc_are_equivalenced_arrays): New function.\n+\t(gfc_check_dependency): Call it.\n+\t* dependency.h: Prototype for gfc_are_equivalenced_arrays.\n+\n 2006-03-01  Roger Sayle  <roger@eyesopen.com>\n \n \t* dependency.c (gfc_is_same_range): Compare the stride, lower and"}, {"sha": "f764873dc0707c9031c1bf7b9c42cbf69d161c00", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -359,6 +359,51 @@ gfc_check_fncall_dependency (gfc_expr * other, sym_intent intent,\n }\n \n \n+/* Return 1 if e1 and e2 are equivalenced arrays, either\n+   directly or indirectly; ie. equivalence (a,b) for a and b\n+   or equivalence (a,c),(b,c).  This function uses the equiv_\n+   lists, generated in trans-common(add_equivalences), that are\n+   guaranteed to pick up indirect equivalences.  A rudimentary\n+   use is made of the offset to ensure that cases where the\n+   source elements are moved down to the destination are not\n+   identified as dependencies.  */\n+\n+int\n+gfc_are_equivalenced_arrays (gfc_expr *e1, gfc_expr *e2)\n+{\n+  gfc_equiv_list *l;\n+  gfc_equiv_info *s, *fl1, *fl2;\n+\n+  gcc_assert (e1->expr_type == EXPR_VARIABLE\n+\t\t&& e2->expr_type == EXPR_VARIABLE);\n+\n+  if (!e1->symtree->n.sym->attr.in_equivalence\n+\t|| !e2->symtree->n.sym->attr.in_equivalence\n+\t|| !e1->rank\n+\t|| !e2->rank)\n+    return 0;\n+\n+  /* Go through the equiv_lists and return 1 if the variables\n+     e1 and e2 are members of the same group and satisfy the\n+     requirement on their relative offsets.  */\n+  for (l = gfc_current_ns->equiv_lists; l; l = l->next)\n+    {\n+      fl1 = NULL;\n+      fl2 = NULL;\n+      for (s = l->equiv; s; s = s->next)\n+\t{\n+\t  if (s->sym == e1->symtree->n.sym)\n+\t    fl1 = s;\n+\t  if (s->sym == e2->symtree->n.sym)\n+\t    fl2 = s;\n+\t  if (fl1 && fl2 && (fl1->offset > fl2->offset))\n+\t    return 1;\n+\t}\n+    }\n+return 0;\n+}\n+\n+\n /* Return true if the statement body redefines the condition.  Returns\n    true if expr2 depends on expr1.  expr1 should be a single term\n    suitable for the lhs of an assignment.  The IDENTICAL flag indicates\n@@ -405,6 +450,10 @@ gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, bool identical)\n \t    return 1;\n \t}\n \n+      /* Return 1 if expr1 and expr2 are equivalenced arrays.  */\n+      if (gfc_are_equivalenced_arrays (expr1, expr2))\n+\treturn 1;\n+\n       if (expr1->symtree->n.sym != expr2->symtree->n.sym)\n \treturn 0;\n "}, {"sha": "3851ca21d482bec0143b360a795c26224213de8b", "filename": "gcc/fortran/dependency.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Fdependency.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Fdependency.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.h?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -30,3 +30,4 @@ int gfc_is_same_range (gfc_array_ref *, gfc_array_ref *, int, int);\n int gfc_expr_is_one (gfc_expr *, int);\n \n int gfc_dep_resolver(gfc_ref *, gfc_ref *);\n+int gfc_are_equivalenced_arrays (gfc_expr *, gfc_expr *);"}, {"sha": "99b98652a9f45a9c19c9606ac8b5035a70c8c540", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -950,6 +950,10 @@ typedef struct gfc_namespace\n \n   /* Points to the equivalences set up in this namespace.  */\n   struct gfc_equiv *equiv;\n+\n+  /* Points to the equivalence groups produced by trans_common.  */\n+  struct gfc_equiv_list *equiv_lists;\n+\n   gfc_interface *operator[GFC_INTRINSIC_OPS];\n \n   /* Points to the parent namespace, i.e. the namespace of a module or\n@@ -1343,6 +1347,20 @@ gfc_equiv;\n \n #define gfc_get_equiv() gfc_getmem(sizeof(gfc_equiv))\n \n+/* Holds a single equivalence member after processing.  */\n+typedef struct gfc_equiv_info\n+{\n+  gfc_symbol *sym;\n+  HOST_WIDE_INT offset;\n+  struct gfc_equiv_info *next;\n+} gfc_equiv_info;\n+\n+/* Holds equivalence groups, after they have been processed.  */\n+typedef struct gfc_equiv_list\n+{\n+  gfc_equiv_info *equiv;\n+  struct gfc_equiv_list *next;\n+} gfc_equiv_list;\n \n /* gfc_case stores the selector list of a case statement.  The *low\n    and *high pointers can point to the same expression in the case of"}, {"sha": "f961c776e211ea8fe9cc7f6141838a962cb2d181", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -549,21 +549,13 @@ gfc_resolve_dot_product (gfc_expr * f, gfc_expr * a, gfc_expr * b)\n {\n   gfc_expr temp;\n \n-  if (a->ts.type == BT_LOGICAL && b->ts.type == BT_LOGICAL)\n-    {\n-      f->ts.type = BT_LOGICAL;\n-      f->ts.kind = gfc_default_logical_kind;\n-    }\n-  else\n-    {\n-      temp.expr_type = EXPR_OP;\n-      gfc_clear_ts (&temp.ts);\n-      temp.value.op.operator = INTRINSIC_NONE;\n-      temp.value.op.op1 = a;\n-      temp.value.op.op2 = b;\n-      gfc_type_convert_binary (&temp);\n-      f->ts = temp.ts;\n-    }\n+  temp.expr_type = EXPR_OP;\n+  gfc_clear_ts (&temp.ts);\n+  temp.value.op.operator = INTRINSIC_NONE;\n+  temp.value.op.op1 = a;\n+  temp.value.op.op2 = b;\n+  gfc_type_convert_binary (&temp);\n+  f->ts = temp.ts;\n \n   f->value.function.name =\n     gfc_get_string (PREFIX(\"dot_product_%c%d\"), gfc_type_letter (f->ts.type),"}, {"sha": "285c276be9e898408df448aeea587c2854ca5677", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -2424,6 +2424,31 @@ gfc_free_dt_list (gfc_dt_list * dt)\n }\n \n \n+/* Free the gfc_equiv_info's.  */\n+\n+static void\n+gfc_free_equiv_infos (gfc_equiv_info * s)\n+{\n+  if (s == NULL)\n+    return;\n+  gfc_free_equiv_infos (s->next);\n+  gfc_free (s);\n+}\n+\n+\n+/* Free the gfc_equiv_lists.  */\n+\n+static void\n+gfc_free_equiv_lists (gfc_equiv_list * l)\n+{\n+  if (l == NULL)\n+    return;\n+  gfc_free_equiv_lists (l->next);\n+  gfc_free_equiv_infos (l->equiv);\n+  gfc_free (l);\n+}\n+\n+\n /* Free a namespace structure and everything below it.  Interface\n    lists associated with intrinsic operators are not freed.  These are\n    taken care of when a specific name is freed.  */\n@@ -2459,6 +2484,7 @@ gfc_free_namespace (gfc_namespace * ns)\n   free_st_labels (ns->st_labels);\n \n   gfc_free_equiv (ns->equiv);\n+  gfc_free_equiv_lists (ns->equiv_lists);\n \n   gfc_free_dt_list (ns->derived_types);\n "}, {"sha": "5e4405ec2631fc2bb9a6cfed03401e89cf344400", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -2581,7 +2581,8 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n       if (ss->type != GFC_SS_SECTION)\n \tcontinue;\n \n-      if (gfc_could_be_alias (dest, ss))\n+      if (gfc_could_be_alias (dest, ss)\n+\t    || gfc_are_equivalenced_arrays (dest->expr, ss->expr))\n \t{\n \t  nDepend = 1;\n \t  break;"}, {"sha": "3b34b334c2c7fd2a9ad531518ab07ae783954242", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -122,6 +122,7 @@ typedef struct segment_info\n static segment_info * current_segment;\n static gfc_namespace *gfc_common_ns = NULL;\n \n+\n /* Make a segment_info based on a symbol.  */\n \n static segment_info *\n@@ -144,6 +145,34 @@ get_segment_info (gfc_symbol * sym, HOST_WIDE_INT offset)\n   return s;\n }\n \n+\n+/* Add a copy of a segment list to the namespace.  This is specifically for\n+   equivalence segments, so that dependency checking can be done on\n+   equivalence group members.  */\n+\n+static void\n+copy_equiv_list_to_ns (segment_info *c)\n+{\n+  segment_info *f;\n+  gfc_equiv_info *s;\n+  gfc_equiv_list *l;\n+\n+  l = (gfc_equiv_list *) gfc_getmem (sizeof (gfc_equiv_list));\n+\n+  l->next = c->sym->ns->equiv_lists;\n+  c->sym->ns->equiv_lists = l;\n+\n+  for (f = c; f; f = f->next)\n+    {\n+      s = (gfc_equiv_info *) gfc_getmem (sizeof (gfc_equiv_info));\n+      s->next = l->equiv;\n+      l->equiv = s;\n+      s->sym = f->sym;\n+      s->offset = f->offset;\n+    }\n+}\n+\n+\n /* Add combine segment V and segment LIST.  */\n \n static segment_info *\n@@ -787,6 +816,9 @@ add_equivalences (bool *saw_equiv)\n \t    }\n \t}\n     }\n+\n+  /* Add a copy of this segment list to the namespace.  */\n+  copy_equiv_list_to_ns (current_segment);\n }\n \n "}, {"sha": "47911ff14553f17f6f10659f2ea6f10442ca7fed", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -846,7 +846,8 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n   tree length = NULL_TREE;\n   int byref;\n \n-  gcc_assert (sym->attr.referenced);\n+  gcc_assert (sym->attr.referenced\n+               || sym->ns->proc_name->attr.if_source == IFSRC_IFBODY);\n \n   if (sym->ns && sym->ns->proc_name->attr.function)\n     byref = gfc_return_by_reference (sym->ns->proc_name);"}, {"sha": "39ac9396fa188941333e3bb813ef649708f8f0b2", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 102, "deletions": 1, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -1561,6 +1561,104 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, int op)\n   se->expr = resvar;\n }\n \n+\n+/* Inline implementation of the dot_product intrinsic. This function\n+   is based on gfc_conv_intrinsic_arith (the previous function).  */\n+static void\n+gfc_conv_intrinsic_dot_product (gfc_se * se, gfc_expr * expr)\n+{\n+  tree resvar;\n+  tree type;\n+  stmtblock_t body;\n+  stmtblock_t block;\n+  tree tmp;\n+  gfc_loopinfo loop;\n+  gfc_actual_arglist *actual;\n+  gfc_ss *arrayss1, *arrayss2;\n+  gfc_se arrayse1, arrayse2;\n+  gfc_expr *arrayexpr1, *arrayexpr2;\n+\n+  type = gfc_typenode_for_spec (&expr->ts);\n+\n+  /* Initialize the result.  */\n+  resvar = gfc_create_var (type, \"val\");\n+  if (expr->ts.type == BT_LOGICAL)\n+    tmp = convert (type, integer_zero_node);\n+  else\n+    tmp = gfc_build_const (type, integer_zero_node);\n+\n+  gfc_add_modify_expr (&se->pre, resvar, tmp);\n+\n+  /* Walk argument #1.  */\n+  actual = expr->value.function.actual;\n+  arrayexpr1 = actual->expr;\n+  arrayss1 = gfc_walk_expr (arrayexpr1);\n+  gcc_assert (arrayss1 != gfc_ss_terminator);\n+\n+  /* Walk argument #2.  */\n+  actual = actual->next;\n+  arrayexpr2 = actual->expr;\n+  arrayss2 = gfc_walk_expr (arrayexpr2);\n+  gcc_assert (arrayss2 != gfc_ss_terminator);\n+\n+  /* Initialize the scalarizer.  */\n+  gfc_init_loopinfo (&loop);\n+  gfc_add_ss_to_loop (&loop, arrayss1);\n+  gfc_add_ss_to_loop (&loop, arrayss2);\n+\n+  /* Initialize the loop.  */\n+  gfc_conv_ss_startstride (&loop);\n+  gfc_conv_loop_setup (&loop);\n+\n+  gfc_mark_ss_chain_used (arrayss1, 1);\n+  gfc_mark_ss_chain_used (arrayss2, 1);\n+\n+  /* Generate the loop body.  */\n+  gfc_start_scalarized_body (&loop, &body);\n+  gfc_init_block (&block);\n+\n+  /* Make the tree expression for [conjg(]array1[)].  */\n+  gfc_init_se (&arrayse1, NULL);\n+  gfc_copy_loopinfo_to_se (&arrayse1, &loop);\n+  arrayse1.ss = arrayss1;\n+  gfc_conv_expr_val (&arrayse1, arrayexpr1);\n+  if (expr->ts.type == BT_COMPLEX)\n+    arrayse1.expr = build1 (CONJ_EXPR, type, arrayse1.expr);\n+  gfc_add_block_to_block (&block, &arrayse1.pre);\n+\n+  /* Make the tree expression for array2.  */\n+  gfc_init_se (&arrayse2, NULL);\n+  gfc_copy_loopinfo_to_se (&arrayse2, &loop);\n+  arrayse2.ss = arrayss2;\n+  gfc_conv_expr_val (&arrayse2, arrayexpr2);\n+  gfc_add_block_to_block (&block, &arrayse2.pre);\n+\n+  /* Do the actual product and sum.  */\n+  if (expr->ts.type == BT_LOGICAL)\n+    {\n+      tmp = build2 (TRUTH_AND_EXPR, type, arrayse1.expr, arrayse2.expr);\n+      tmp = build2 (TRUTH_OR_EXPR, type, resvar, tmp);\n+    }\n+  else\n+    {\n+      tmp = build2 (MULT_EXPR, type, arrayse1.expr, arrayse2.expr);\n+      tmp = build2 (PLUS_EXPR, type, resvar, tmp);\n+    }\n+  gfc_add_modify_expr (&block, resvar, tmp);\n+\n+  /* Finish up the loop block and the loop.  */\n+  tmp = gfc_finish_block (&block);\n+  gfc_add_expr_to_block (&body, tmp);\n+\n+  gfc_trans_scalarizing_loops (&loop, &body);\n+  gfc_add_block_to_block (&se->pre, &loop.pre);\n+  gfc_add_block_to_block (&se->pre, &loop.post);\n+  gfc_cleanup_loop (&loop);\n+\n+  se->expr = resvar;\n+}\n+\n+\n static void\n gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n {\n@@ -3135,6 +3233,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_dim (se, expr);\n       break;\n \n+    case GFC_ISYM_DOT_PRODUCT:\n+      gfc_conv_intrinsic_dot_product (se, expr);\n+      break;\n+\n     case GFC_ISYM_DPROD:\n       gfc_conv_intrinsic_dprod (se, expr);\n       break;\n@@ -3304,7 +3406,6 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case GFC_ISYM_CHDIR:\n-    case GFC_ISYM_DOT_PRODUCT:\n     case GFC_ISYM_ETIME:\n     case GFC_ISYM_FGET:\n     case GFC_ISYM_FGETC:"}, {"sha": "26c178be26156573c949be8464d771c8b93243ac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -1,3 +1,17 @@\n+2006-03-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* gfortran.dg/logical_dot_product.f90: New test. \n+\n+\tPR fortran/26393\n+\t* gfortran.dg/used_interface_ref.f90: New test.\n+\n+\tPR fortran/20938\n+\t* gfortran.dg/dependency_2.f90: New test.\n+\t* gfortran.fortran-torture/execute/where17.f90: New test.\n+\t* gfortran.fortran-torture/execute/where18.f90: New test.\n+\t* gfortran.fortran-torture/execute/where19.f90: New test.\n+\t* gfortran.fortran-torture/execute/where20.f90: New test.\n+\n 2006-03-01  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* g++.dg/tree-ssa/pr26443.C: New test case."}, {"sha": "1cbdec795e1f919f5ea8bd45ed84b506d39896be", "filename": "gcc/testsuite/gfortran.dg/dependency_2.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_2.f90?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do run }\n+! Tests the fix for PR20938 in which dependencies between equivalenced \n+! arrays were not detected.\n+! \n+real, dimension (3) :: a = (/1., 2., 3./), b, c\n+equivalence (a(2), b), (a(1), c)\n+b = a;\n+if (any(b .ne. (/1., 2., 3./))) call abort ()\n+b = c\n+if (any(b .ne. (/1., 1., 2./))) call abort ()\n+end"}, {"sha": "e35595c430f93985fbdaaa64573e8e6c2dd1d312", "filename": "gcc/testsuite/gfortran.dg/logical_dot_product.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.dg%2Flogical_dot_product.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.dg%2Flogical_dot_product.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flogical_dot_product.f90?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do run }\n+! Checks the LOGICAL version of dot_product\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+   logical :: l1(4) = (/.TRUE.,.FALSE.,.TRUE.,.FALSE./)\n+   logical :: l2(4) = (/.FALSE.,.TRUE.,.FALSE.,.TRUE./)\n+   if (dot_product (l1, l2)) call abort ()\n+   l2 = .TRUE.\n+   if (.not.dot_product (l1, l2)) call abort ()\n+end\n\\ No newline at end of file"}, {"sha": "d4a9c96edac1b0e439778b796ef274ab1d68454b", "filename": "gcc/testsuite/gfortran.dg/used_interface_ref.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_interface_ref.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_interface_ref.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_interface_ref.f90?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do run }\n+! Tests the fix for PR26393, in which an ICE would occur in trans-decl.c\n+! (gfc_get_symbol_decl) because anzKomponenten is not referenced in the\n+! interface for solveCConvert. The solution was to assert that the symbol\n+! is either referenced or in an interface body.\n+!\n+! Based on the testcase in the PR.\n+!\n+  MODULE MODULE_CONC\n+    INTEGER, SAVE :: anzKomponenten = 2\n+  END MODULE MODULE_CONC\n+\n+  MODULE MODULE_THERMOCALC\n+    INTERFACE\n+      FUNCTION solveCConvert ()\n+        USE MODULE_CONC, ONLY: anzKomponenten\n+        REAL :: solveCConvert(1:anzKomponenten)\n+        END FUNCTION solveCConvert\n+    END INTERFACE\n+  END MODULE MODULE_THERMOCALC\n+\n+  SUBROUTINE outDiffKoeff\n+    USE MODULE_CONC\n+    USE MODULE_THERMOCALC\n+    REAL :: buffer_conc(1:anzKomponenten)\n+    buffer_conc = solveCConvert ()\n+    if (any(buffer_conc .ne. (/(real(i), i = 1, anzKomponenten)/))) &\n+          call abort ()\n+  END SUBROUTINE outDiffKoeff\n+\n+  program missing_ref\n+    USE MODULE_CONC\n+    call outDiffKoeff\n+! Now set anzKomponenten to a value that would cause a segfault if\n+! buffer_conc and solveCConvert did not have the correct allocation\n+! of memory.\n+    anzKomponenten = 5000\n+    call outDiffKoeff\n+  end program missing_ref\n+ \n+  FUNCTION solveCConvert ()\n+    USE MODULE_CONC, ONLY: anzKomponenten\n+    REAL :: solveCConvert(1:anzKomponenten)\n+    solveCConvert = (/(real(i), i = 1, anzKomponenten)/)\n+  END FUNCTION solveCConvert\n+   \n+\n+"}, {"sha": "b4323ca81fbe5311ba377ce9c84e23de9cec76dc", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/where17.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere17.f90?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -0,0 +1,15 @@\n+! Check to ensure only the first true clause in WHERE is\n+! executed.\n+program where_17\n+   integer :: a(3)\n+\n+   a = (/1, 2, 3/)\n+   where (a .eq. 1)\n+     a = 2\n+   elsewhere (a .le. 2)\n+     a = 3\n+   elsewhere (a .le. 3)\n+     a = 4\n+   endwhere\n+   if (any (a .ne. (/2, 3, 4/))) call abort\n+end program"}, {"sha": "403646460b8184820720520ecfe282356ec59136", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/where18.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere18.f90?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -0,0 +1,26 @@\n+! Check to ensure mask is calculated first in WHERE\n+! statements.\n+program where_18\n+   integer :: a(4)\n+   integer :: b(3)\n+   integer :: c(3)\n+   equivalence (a(1), b(1)), (a(2), c(1))\n+\n+   a = (/1, 1, 1, 1/)\n+   where (b .eq. 1)\n+     c = 2\n+   elsewhere (b .eq. 2)\n+     c = 3\n+   endwhere\n+   if (any (a .ne. (/1, 2, 2, 2/))) &\n+     call abort\n+\n+   a = (/1, 1, 1, 1/)\n+   where (c .eq. 1)\n+     b = 2\n+   elsewhere (b .eq. 2)\n+     b = 3\n+   endwhere\n+   if (any (a .ne. (/2, 2, 2, 1/))) &\n+     call abort\n+end program"}, {"sha": "3c41b89978cd389ea1db3dee65c3ba98162bbb95", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/where19.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere19.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere19.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere19.f90?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -0,0 +1,23 @@\n+! Check to ensure result is calculated from unmodified\n+! version of the right-hand-side in WHERE statements.\n+program where_19\n+   integer :: a(4)\n+   integer :: b(3)\n+   integer :: c(3)\n+   equivalence (a(1), b(1)), (a(2), c(1))\n+\n+   a = (/1, 2, 3, 4/)\n+   where (b .gt. 1)\n+     c = b\n+   endwhere\n+   if (any (a .ne. (/1, 2, 2, 3/))) &\n+     call abort ()\n+\n+   a = (/1, 2, 3, 4/)\n+   where (c .gt. 1)\n+     b = c\n+   endwhere\n+   if (any (a .ne. (/2, 3, 4, 4/))) &\n+     call abort ()\n+end program\n+"}, {"sha": "b0456500d13f9d3f905c0088003db1a030eb187f", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/where20.f90", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere20.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61321991ff5f055015750ddf36444705b9921464/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere20.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere20.f90?ref=61321991ff5f055015750ddf36444705b9921464", "patch": "@@ -0,0 +1,54 @@\n+! Test the dependency checking in simple where. This\n+! did not work and was fixed as part of the patch for\n+! pr24519.\n+!\n+program where_20\n+   integer :: a(4)\n+   integer :: b(3)\n+   integer :: c(3)\n+   integer :: d(3) = (/1, 2, 3/)\n+   equivalence (a(1), b(1)), (a(2), c(1))\n+\n+! This classic case worked before the patch.\n+   a = (/1, 2, 3, 4/)\n+   where (b .gt. 1) a(2:4) = a(1:3)\n+   if (any(a .ne. (/1,2,2,3/))) call abort ()\n+\n+! This is the original manifestation of the problem\n+! and is repeated in where_19.f90.\n+   a = (/1, 2, 3, 4/)\n+   where (b .gt. 1)\n+     c = b\n+   endwhere\n+   if (any(a .ne. (/1,2,2,3/))) call abort ()\n+\n+! Mask to.destination dependency.\n+   a = (/1, 2, 3, 4/)\n+   where (b .gt. 1)\n+     c = d\n+   endwhere\n+   if (any(a .ne. (/1,2,2,3/))) call abort ()\n+\n+! Source to.destination dependency.\n+   a = (/1, 2, 3, 4/)\n+   where (d .gt. 1)\n+     c = b\n+   endwhere\n+   if (any(a .ne. (/1,2,2,3/))) call abort ()\n+\n+! Check the simple where.\n+   a = (/1, 2, 3, 4/)\n+   where (b .gt. 1) c = b\n+   if (any(a .ne. (/1,2,2,3/))) call abort ()\n+\n+! This was OK before the patch.\n+   a = (/1, 2, 3, 4/)\n+   where (b .gt. 1)\n+     where (d .gt. 1)\n+       c = b\n+     end where\n+   endwhere\n+   if (any(a .ne. (/1,2,2,3/))) call abort ()\n+\n+end program\n+"}]}