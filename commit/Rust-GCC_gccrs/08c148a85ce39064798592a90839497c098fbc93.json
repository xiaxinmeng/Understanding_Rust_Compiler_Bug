{"sha": "08c148a85ce39064798592a90839497c098fbc93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhjMTQ4YTg1Y2UzOTA2NDc5ODU5MmE5MDgzOTQ5N2MwOThmYmM5Mw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-07-06T18:40:17Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-07-06T18:40:17Z"}, "message": "Makefile.in (final.o): Depend on target.h.\n\n\t* Makefile.in (final.o): Depend on target.h.\n\t* final.c: Include target.h.\n\t(default_function_pro_epilogue): New.\n\t(final_start_function): Use target structure for function prologues.\n\t(final_end_function): Use target structure for function epilogues.\n\t* fold-const.c (real_hex_to_f): Constify s and p.\n\t* output.h (default_function_pro_epilogue): New.\n\t* real.h (real_hex_to_f): Update prototype.\n\t* target-def.h (TARGET_ASM_FUNCTION_PROLOGUE,\n\tTARGET_ASM_FUNCTION_EPILOGUE, TARGET_ASM_OUT): New.\n\t(TARGET_INITIALIZER): Update.\n\t* target.h (gcc_target): Add struct asm_out.\n\t* doc/tm.texi: Update.\n\nconfig:\n\tUpdate each arch to use TARGET_ASM_FUNCTION_PROLOGUE and\n\tTARGET_ASM_FUNCTION_EPILOGUE.  Move macro code to functions\n\tin cpu/cpu.c, or rename old functions consistently.  Take\n\ta HOST_WIDE INT not an int as the SIZE parameter.  Remove now\n\tredundant macros and prototypes.  Make new functions static.\n\n\t* 1750a/1750a.c: Similarly.\n\t* 1750a/1750a.h: Similarly.\n\t* a29k/a29k-protos.h: Similarly.\n\t* a29k/a29k.c: Similarly.\n\t* a29k/a29k.h: Similarly.\n\t* arc/arc-protos.h: Similarly.\n\t* arc/arc.c: Similarly.\n\t* arc/arc.h: Similarly.\n\t* arm/arm-protos.h: Similarly.\n\t* arm/arm.c: Similarly.\n\t* arm/arm.h: Similarly.\n\t* avr/avr-protos.h: Similarly.\n\t* avr/avr.c: Similarly.\n\t* avr/avr.h: Similarly.\n\t* clipper/clipper-protos.h: Similarly.\n\t* clipper/clipper.c: Similarly.\n\t* clipper/clipper.h: Similarly.\n\t* convex/convex.c: Similarly.\n\t* convex/convex.h: Similarly.\n\t* d30v/d30v-protos.h: Similarly.\n\t* d30v/d30v.c: Similarly.\n\t* d30v/d30v.h: Similarly.\n\t* d30v/d30v.md: Similarly.\n\t* dsp16xx/dsp16xx-protos.h: Similarly.\n\t* dsp16xx/dsp16xx.c: Similarly.\n\t* dsp16xx/dsp16xx.h: Similarly.\n\t* elxsi/elxsi.c: Similarly.\n\t* elxsi/elxsi.h: Similarly.\n\t* fr30/fr30.c: Similarly.\n\t* fr30/fr30.md: Similarly.\n\t* h8300/h8300-protos.h: Similarly.\n\t* h8300/h8300.c: Similarly.\n\t* h8300/h8300.h: Similarly.\n\t* i370/i370-protos.h: Similarly.\n\t* i370/i370.c: Similarly.\n\t* i370/i370.h: Similarly.\n\t* i386/i386.c: Similarly.\n\t* i386/osf1elf.h: Similarly.\n\t* i386/osfrose.h: Similarly.\n\t* i860/i860-protos.h: Similarly.\n\t* i860/i860.c: Similarly.\n\t* i860/i860.h: Similarly.\n\t* i960/i960-protos.h: Similarly.\n\t* i960/i960.c: Similarly.\n\t* i960/i960.h: Similarly.\n\t* ia64/ia64-protos.h: Similarly.\n\t* ia64/ia64.c: Similarly.\n\t* ia64/ia64.h: Similarly.\n\t* m32r/m32r-protos.h: Similarly.\n\t* m32r/m32r.c: Similarly.\n\t* m32r/m32r.h: Similarly.\n\t* m68hc11/m68hc11-protos.h: Similarly.\n\t* m68hc11/m68hc11.c: Similarly.\n\t* m68hc11/m68hc11.h: Similarly.\n\t* m68k/crds.h: Similarly.\n\t* m68k/dpx2.h: Similarly.\n\t* m68k/m68k-protos.h: Similarly.\n\t* m68k/m68k.c: Similarly.\n\t* m68k/m68k.h: Similarly.\n\t* m68k/news.h: Similarly.\n\t* m88k/m88k-protos.h: Similarly.\n\t* m88k/m88k.c: Similarly.\n\t* m88k/m88k.h: Similarly.\n\t* mips/mips-protos.h: Similarly.\n\t* mips/mips.c: Similarly.\n\t* mips/mips.h: Similarly.\n\t* ns32k/merlin.h: Similarly.\n\t* ns32k/ns32k.c: Similarly.\n\t* ns32k/ns32k.h: Similarly.\n\t* ns32k/tek6000.h: Similarly.\n\t* pa/pa-protos.h: Similarly.\n\t* pa/pa.c: Similarly.\n\t* pa/pa.h: Similarly.\n\t* pdp11/2bsd.h: Similarly.\n\t* pdp11/pdp11-protos.h: Similarly.\n\t* pdp11/pdp11.c: Similarly.\n\t* pdp11/pdp11.h: Similarly.\n\t* romp/romp-protos.h: Similarly.\n\t* romp/romp.c: Similarly.\n\t* romp/romp.h: Similarly.\n\t* rs6000/rs6000-protos.h: Similarly.\n\t* rs6000/rs6000.c: Similarly.\n\t* rs6000/rs6000.h: Similarly.\n\t* rs6000/sysv4.h: Similarly.\n\t* sh/sh-protos.h: Similarly.\n\t* sh/sh.c: Similarly.\n\t* sh/sh.h: Similarly.\n\t* sparc/sparc-protos.h: Similarly.\n\t* sparc/sparc.c: Similarly.\n\t* sparc/sparc.h: Similarly.\n\t* vax/vax.c: Similarly.\n\t* vax/vax.h: Similarly.\n\t* vax/vms.h: Similarly.\n\t* we32k/we32k.c: Similarly.\n\t* we32k/we32k.h: Similarly.\n\nFrom-SVN: r43817", "tree": {"sha": "0ff4b9170093f108e4988c09e21e8b9ff5dd462a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ff4b9170093f108e4988c09e21e8b9ff5dd462a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08c148a85ce39064798592a90839497c098fbc93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c148a85ce39064798592a90839497c098fbc93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08c148a85ce39064798592a90839497c098fbc93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c148a85ce39064798592a90839497c098fbc93/comments", "author": null, "committer": null, "parents": [{"sha": "b62c888152fb7d3245bbea7464c50aef8fe1c8fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b62c888152fb7d3245bbea7464c50aef8fe1c8fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b62c888152fb7d3245bbea7464c50aef8fe1c8fa"}], "stats": {"total": 4683, "additions": 2180, "deletions": 2503}, "files": [{"sha": "84eaf0ca35ef11faec758ebc390541f050514b5f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1518,7 +1518,7 @@ final.o : final.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h intl.h \\\n    $(REGS_H) $(RECOG_H) conditions.h insn-config.h $(INSN_ATTR_H) function.h \\\n    real.h output.h hard-reg-set.h except.h \\\n    xcoffout.h toplev.h reload.h dwarfout.h dwarf2out.h sdbout.h \\\n-   dbxout.h $(BASIC_BLOCK_H) $(TM_P_H)\n+   dbxout.h $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H)\n recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) function.h $(BASIC_BLOCK_H) \\\n    $(REGS_H) $(RECOG_H) hard-reg-set.h flags.h insn-config.h $(INSN_ATTR_H) \\\n    real.h toplev.h output.h reload.h $(TM_P_H)"}, {"sha": "e9b10ef750d250bfad0d92d851a8ba47c52d5bca", "filename": "gcc/config.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1,4 +1,4 @@\n-/* config.in.  Generated automatically from configure.in by autoheader.  */\n+/* config.in.  Generated automatically from configure.in by autoheader 2.13.  */\n \n /* Define to empty if the keyword does not work.  */\n #undef const"}, {"sha": "39a0ebb0ba796a242f7e7140c2df6070591869d7", "filename": "gcc/config/1750a/1750a.c", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2F1750a%2F1750a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2F1750a%2F1750a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"regs.h\"\n #include \"output.h\"\n+#include \"flags.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n@@ -46,11 +47,106 @@ const char *const sectname[4] =\n {\"Init\", \"Normal\", \"Konst\", \"Static\"};\n \n static int which_bit PARAMS ((int));\n+static void output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n+/* Generate the assembly code for function entry.  FILE is a stdio\n+   stream to output the code to.  SIZE is an int: how many units of\n+   temporary storage to allocate.\n+\n+   Refer to the array `regs_ever_live' to determine which registers to\n+   save; `regs_ever_live[I]' is nonzero if register number I is ever\n+   used in the function.  This function is responsible for knowing\n+   which registers should not be saved even if used.  */\n+\n+static void\n+output_function_prologue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size;\n+{\n+  if (flag_verbose_asm)\n+    {\n+      int regno, regs_used = 0;\n+\n+      fprintf (file, \"\\t; registers used: \");\n+      for (regno = 0; regno < 14; regno++)\n+\tif (regs_ever_live[regno])\n+\t  {\n+\t    fprintf (file, \" %s\", reg_names[regno]);\n+\t    regs_used++;\n+\t  }\n+\n+      if (regs_used == 0)\n+\tfprintf (file, \"(none)\");\n+    }\n+\n+  if (size > 0)\n+    {\n+      fprintf (file, \"\\n\\t%s\\tr15,%d\",\n+\t       (size <= 16 ? \"sisp\" : \"sim\"), size);\n+      if (flag_verbose_asm)\n+\tfprintf (file, \"  ; reserve local-variable space\");\n+    }\n+\n+  if (frame_pointer_needed)\n+    {\n+      fprintf(file, \"\\n\\tpshm\\tr14,r14\");\n+      if (flag_verbose_asm)\n+\tfprintf (file, \"  ; push old frame\");\n+      fprintf (file, \"\\n\\tlr\\tr14,r15\");\n+      if (flag_verbose_asm)\n+\tfprintf (file, \"  ; set new frame\");\n+    }\n+\n+  fprintf (file, \"\\n\");\n+  program_counter = 0;\n+  jmplbl_ndx = -1;\n+}\n+\n+/* This function generates the assembly code for function exit.\n+   Args are as for output_function_prologue ().\n+\n+   The function epilogue should not depend on the current stack\n+   pointer!  It should use the frame pointer only.  This is mandatory\n+   because of alloca; we also take advantage of it to omit stack\n+   adjustments before returning. */\n+\n+static void\n+output_function_epilogue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size;\n+{\n+  if (frame_pointer_needed)\n+    {\n+      fprintf (file, \"\\tlr\\tr15,r14\");\n+      if (flag_verbose_asm)\n+        fprintf (file, \"  ; set stack ptr to frame ptr\");\n+      fprintf (file, \"\\n\\tpopm\\tr14,r14\");\n+      if (flag_verbose_asm)\n+        fprintf (file, \"  ; restore previous frame ptr\");\n+      fprintf (file, \"\\n\");\n+    }\n+\n+  if (size > 0)\n+    {\n+      fprintf (file, \"\\t%s\\tr15,%d\",\n+\t       (size <= 16 ? \"aisp\" : \"aim\"), size);\n+      if (flag_verbose_asm)\n+\tfprintf (file, \"  ; free up local-var space\");\n+      fprintf (file, \"\\n\");\n+    }\n+\n+  fprintf (file, \"\\turs\\tr15\\n\\n\");\n+}\n+\n void\n notice_update_cc (exp)\n      rtx exp;"}, {"sha": "26ce2edb277e4ce89b01d586206c216b1a8d33ea", "filename": "gcc/config/1750a/1750a.h", "status": "modified", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2F1750a%2F1750a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2F1750a%2F1750a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -550,51 +550,6 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \n #define DEFAULT_CALLER_SAVES\n \n-\n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) {   \\\n-  if (flag_verbose_asm)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      int regno, regs_used = 0;\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t; registers used: \");\t\t\t\\\n-      for (regno = 0; regno < 14; regno++)\t\t\t\\\n-\tif (regs_ever_live[regno])\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \" %s\", reg_names[regno]);\t\t\\\n-\t    regs_used++;\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-      if (regs_used == 0)\t\t\t\t\t\\\n-\tfprintf (FILE, \"(none)\");\t\t\t \t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (SIZE > 0)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\n\\t%s\\tr15,%d\",\t\t\t\t\\\n-\t       (SIZE <= 16 ? \"sisp\" : \"sim\"), SIZE);\t\t\\\n-      if (flag_verbose_asm)\t\t\t\t\t\\\n-\tfprintf (FILE, \"  ; reserve local-variable space\");\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf(FILE, \"\\n\\tpshm\\tr14,r14\");\t\t\t\\\n-      if (flag_verbose_asm)\t\t\t\t\t\\\n-\tfprintf (FILE, \"  ; push old frame\");\t\t\t\\\n-      fprintf (FILE, \"\\n\\tlr\\tr14,r15\");\t\t\t\\\n-      if (flag_verbose_asm)\t\t\t\t\t\\\n-\tfprintf (FILE, \"  ; set new frame\");\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t \t\\\n-  program_counter = 0;\t\t\t\t\t\t\\\n-  jmplbl_ndx = -1;\t\t\t\t\t\t\\\n-}\n-\n /************* 1750: PROFILER HANDLING NOT YET DONE !!!!!!! *************/\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n@@ -619,38 +574,6 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \n #define EXIT_IGNORE_STACK 0\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning. */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) {\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tlr\\tr15,r14\");\t\t\t\t\\\n-      if (flag_verbose_asm)\t\t\t\t\t\\\n-        fprintf (FILE, \"  ; set stack ptr to frame ptr\");\t\\\n-      fprintf (FILE, \"\\n\\tpopm\\tr14,r14\");\t\t\t\\\n-      if (flag_verbose_asm)\t\t\t\t\t\\\n-        fprintf (FILE, \"  ; restore previous frame ptr\");\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (SIZE > 0)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t%s\\tr15,%d\",\t\t\t\t\\\n-\t       (SIZE <= 16 ? \"aisp\" : \"aim\"), SIZE);\t\t\\\n-      if (flag_verbose_asm)\t\t\t\t\t\\\n-\tfprintf (FILE, \"  ; free up local-var space\");\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\turs\\tr15\\n\\n\");\t\t\t\t\\\n-}\n-\n /* If the memory address ADDR is relative to the frame pointer,\n    correct it to be relative to the stack pointer instead.\n    This is for when we don't use a frame pointer."}, {"sha": "a2821e30df321f785c5a6e4e8081b5d192c755b0", "filename": "gcc/config/a29k/a29k-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fa29k%2Fa29k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fa29k%2Fa29k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -60,6 +60,4 @@ extern int uses_local_reg_p PARAMS ((rtx));\n extern int null_epilogue PARAMS ((void));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n extern void a29k_compute_reg_names PARAMS ((void));\n-extern void output_prolog PARAMS ((FILE *, int));\n-extern void output_epilog PARAMS ((FILE *, int));\n #endif /* RTX_CODE */"}, {"sha": "67c84efb80a6544c4bd11306402adb0361f40b5d", "filename": "gcc/config/a29k/a29k.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fa29k%2Fa29k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fa29k%2Fa29k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -46,6 +46,8 @@ static int shift_constant_operand PARAMS ((rtx, enum machine_mode, int));\n static void a29k_set_memflags_1 PARAMS ((rtx, int, int, int, int));\n static void compute_regstack_size PARAMS ((void));\n static void check_epilogue_internal_label PARAMS ((FILE *));\n+static void output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \n #define min(A,B)\t((A) < (B) ? (A) : (B))\n \n@@ -93,6 +95,10 @@ rtx a29k_compare_op0, a29k_compare_op1;\n int a29k_compare_fp_p;\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -1293,10 +1299,10 @@ a29k_compute_reg_names ()\n \n /* Output function prolog code to file FILE.  Memory stack size is SIZE.  */\n \n-void\n-output_prolog (file, size)\n+static void\n+output_function_prologue (file, size)\n      FILE *file;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n   int i;\n   int arg_count = 0;\n@@ -1465,10 +1471,10 @@ check_epilogue_internal_label (file)\n    stack size.  The register stack size is in the variable\n    A29K_REGSTACK_SIZE.  */\n \n-void\n-output_epilog (file, size)\n+static void\n+output_function_epilogue (file, size)\n      FILE *file;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n   rtx insn;\n   int locals_unavailable = 0;\t/* True until after first insn"}, {"sha": "f6bfe38277897a313d99936332b08360b59b2206", "filename": "gcc/config/a29k/a29k.h", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -935,16 +935,6 @@ extern const char *a29k_function_name;\n   a29k_function_name = NAME; \\\n   a29k_compute_reg_names ();\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE)  output_prolog (FILE, SIZE)\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -957,18 +947,6 @@ extern const char *a29k_function_name;\n \n #define EXIT_IGNORE_STACK 1\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE)\toutput_epilog (FILE, SIZE)\n-\n /* Define the number of delay slots needed for the function epilogue.\n \n    On the 29k, we need a slot except when we have a register stack adjustment,"}, {"sha": "fef052b942846d27d77f9723e1f2701e4a36b8e3", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -71,8 +71,6 @@ extern void arc_asm_file_start PARAMS ((FILE *));\n extern unsigned int arc_compute_frame_size PARAMS ((int));\n extern void arc_save_restore PARAMS ((FILE *, const char *, unsigned int,\n \t\t\t\t      unsigned int, const char *));\n-extern void arc_output_function_prologue PARAMS ((FILE *, int));\n-extern void arc_output_function_epilogue PARAMS ((FILE *, int));\n extern int arc_delay_slots_for_epilogue PARAMS ((void));\n extern void arc_finalize_pic PARAMS ((void));\n extern void arc_ccfsm_at_label PARAMS ((const char *, int));"}, {"sha": "03e77ae1a0dbd70f240939d6f7ccfd48a1a163a7", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -88,8 +88,14 @@ static void record_cc_ref PARAMS ((rtx));\n static void arc_init_reg_tables PARAMS ((void));\n static int get_arc_condition_code PARAMS ((rtx));\n static int arc_valid_decl_attribute PARAMS ((tree, tree, tree, tree));\n+static void arc_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void arc_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE arc_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE arc_output_function_epilogue\n #undef TARGET_VALID_DECL_ATTRIBUTE\n #define TARGET_VALID_DECL_ATTRIBUTE arc_valid_decl_attribute\n \n@@ -1087,10 +1093,10 @@ arc_save_restore (file, base_reg, offset, gmask, op)\n \f\n /* Set up the stack and frame pointer (if desired) for the function.  */\n \n-void\n+static void\n arc_output_function_prologue (file, size)\n      FILE *file;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n   const char *sp_str = reg_names[STACK_POINTER_REGNUM];\n   const char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n@@ -1165,10 +1171,10 @@ arc_output_function_prologue (file, size)\n /* Do any necessary cleanup after a function to restore stack, frame,\n    and regs. */\n \n-void\n+static void\n arc_output_function_epilogue (file, size)\n      FILE *file;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n   rtx epilogue_delay = current_function_epilogue_delay_list;\n   int noepilogue = FALSE;"}, {"sha": "9695d8ce6643d375580cbd1a5e462ad51e1b0a74", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -834,36 +834,12 @@ arc_setup_incoming_varargs(&ARGS_SO_FAR, MODE, TYPE, &PRETEND_SIZE, NO_RTL)\n    is passed to a function, or 0 to use `invisible' first argument.  */\n #define STRUCT_VALUE 0\n \f\n-/* Function entry and exit.  */\n-\n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n-arc_output_function_prologue (FILE, SIZE)\n-\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers.\n    No definition is equivalent to always zero.  */\n #define EXIT_IGNORE_STACK 0\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-arc_output_function_epilogue (FILE, SIZE)\n-\n /* Epilogue delay slots.  */\n #define DELAY_SLOTS_FOR_EPILOGUE arc_delay_slots_for_epilogue ()\n "}, {"sha": "70780582022cd9765fb678c535c6b2e6133aabf2", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -29,7 +29,6 @@ extern int    arm_regno_class \t\tPARAMS ((int));\n extern void   arm_finalize_pic\t\tPARAMS ((int));\n extern int    arm_volatile_func\t\tPARAMS ((void));\n extern const char * arm_output_epilogue\tPARAMS ((int));\n-extern void   output_func_epilogue\tPARAMS ((int));\n extern void   arm_expand_prologue\tPARAMS ((void));\n /* Used in arm.md, but defined in output.c.  */\n extern void   assemble_align\t\tPARAMS ((int)); \n@@ -123,7 +122,6 @@ extern const char * arithmetic_instr\tPARAMS ((rtx, int));\n extern void   output_ascii_pseudo_op\tPARAMS ((FILE *, const unsigned char *, int));\n extern const char * output_return_instruction PARAMS ((rtx, int, int));\n extern void   arm_poke_function_name\tPARAMS ((FILE *, char *));\n-extern void   output_arm_prologue\tPARAMS ((FILE *, int));\n extern void   arm_print_operand\t\tPARAMS ((FILE *, rtx, int));\n extern void   arm_print_operand_address\tPARAMS ((FILE *, rtx));\n extern void   arm_final_prescan_insn\tPARAMS ((rtx));\n@@ -160,7 +158,6 @@ extern void   thumb_expand_epilogue\tPARAMS ((void));\n extern int    is_called_in_ARM_mode\tPARAMS ((tree));\n #endif\n extern int    thumb_shiftable_const\tPARAMS ((unsigned HOST_WIDE_INT));\n-extern void   output_thumb_prologue\tPARAMS ((FILE *));\n #ifdef RTX_CODE\n extern void   thumb_final_prescan_insn\tPARAMS ((rtx));\n extern const char * thumb_load_double_from_address"}, {"sha": "7d18b71ec6fb4ed57d7b0dfd0271c906b95fbcb3", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -106,6 +106,12 @@ static int\t arm_valid_type_attribute_p\tPARAMS ((tree, tree,\n \t\t\t\t\t\t\t tree, tree));\n static int\t arm_valid_decl_attribute_p\tPARAMS ((tree, tree,\n \t\t\t\t\t\t\t tree, tree));\n+static void\t arm_output_function_epilogue\tPARAMS ((FILE *,\n+\t\t\t\t\t\t\t HOST_WIDE_INT));\n+static void\t arm_output_function_prologue\tPARAMS ((FILE *,\n+\t\t\t\t\t\t\t HOST_WIDE_INT));\n+static void\t thumb_output_function_prologue PARAMS ((FILE *,\n+\t\t\t\t\t\t\t HOST_WIDE_INT));\n static int\t arm_comp_type_attributes\tPARAMS ((tree, tree));\n static void\t arm_set_default_type_attributes\tPARAMS ((tree));\n #undef Hint\n@@ -130,6 +136,12 @@ static void\t arm_set_default_type_attributes\tPARAMS ((tree));\n #  define TARGET_VALID_DECL_ATTRIBUTE arm_valid_decl_attribute_p\n #endif\n \n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE arm_output_function_prologue\n+\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE arm_output_function_epilogue\n+\n #undef TARGET_COMP_TYPE_ATTRIBUTES\n #define TARGET_COMP_TYPE_ATTRIBUTES arm_comp_type_attributes\n \n@@ -7313,12 +7325,18 @@ arm_poke_function_name (stream, name)\n /* Place some comments into the assembler stream\n    describing the current function.  */\n \n-void\n-output_arm_prologue (f, frame_size)\n+static void\n+arm_output_function_prologue (f, frame_size)\n      FILE * f;\n-     int frame_size;\n+     HOST_WIDE_INT frame_size;\n {\n   unsigned long func_type;\n+\n+  if (!TARGET_ARM)\n+    {\n+      thumb_output_function_prologue (f, frame_size);\n+      return;\n+    }\n   \n   /* Sanity check.  */\n   if (arm_ccfsm_state || arm_target_insn)\n@@ -7637,9 +7655,10 @@ arm_output_epilogue (really_return)\n   return \"\";\n }\n \n-void\n-output_func_epilogue (frame_size)\n-     int frame_size;\n+static void\n+arm_output_function_epilogue (file, frame_size)\n+     FILE *file ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT frame_size;\n {\n   if (TARGET_THUMB)\n     {\n@@ -9892,9 +9911,10 @@ thumb_expand_epilogue ()\n     emit_insn (gen_blockage ());\n }\n \n-void\n-output_thumb_prologue (f)\n+static void\n+thumb_output_function_prologue (f, size)\n      FILE * f;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   int live_regs_mask = 0;\n   int high_regs_pushed = 0;"}, {"sha": "59884cdf3908c059d8286318424dece4691a3670", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1532,17 +1532,6 @@ typedef struct\n     (PRETEND_SIZE) = (NUM_ARG_REGS - (CUM).nregs) * UNITS_PER_WORD;\t\\\n }\n \n-/* Generate assembly output for the start of a function.  */\n-#define FUNCTION_PROLOGUE(STREAM, SIZE)\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      if (TARGET_ARM)\t\t\t\t\\\n-        output_arm_prologue (STREAM, SIZE);\t\\\n-      else\t\t\t\t\t\\\n-\toutput_thumb_prologue (STREAM);\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n /* If your target environment doesn't prefix user functions with an\n    underscore, you may wish to re-define this to prevent any conflicts.\n    e.g. AOF may prefix mcount with an underscore.  */\n@@ -1602,10 +1591,6 @@ typedef struct\n    frame.  */\n #define EXIT_IGNORE_STACK 1\n \n-/* Generate the assembly code for function exit. */\n-#define FUNCTION_EPILOGUE(STREAM, SIZE)\t\\\n-  output_func_epilogue (SIZE)\n-\n #define EPILOGUE_USES(REGNO) (reload_completed && (REGNO) == LR_REGNUM)\n \n /* Determine if the epilogue should be output as RTL."}, {"sha": "9d9839831b3051b1628745e949d93772a6c6144a", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -35,8 +35,6 @@ extern int    frame_pointer_required_p          PARAMS ((void));\n extern void   asm_globalize_label         PARAMS ((FILE *file, const char *name));\n extern void   order_regs_for_local_alloc  PARAMS ((void));\n extern int    initial_elimination_offset  PARAMS ((int from, int to));\n-extern void   function_prologue           PARAMS ((FILE *file, int size));\n-extern void   function_epilogue           PARAMS ((FILE *file, int size));\n extern void   progmem_section             PARAMS ((void));\n extern int    mask_one_bit_p              PARAMS ((HOST_WIDE_INT mask));\n extern void   gas_output_limited_string PARAMS ((FILE *file, const char *str));"}, {"sha": "f242aa45b2d988382bd6deef27802170a17691a6", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -60,6 +60,8 @@ static int    io_address_p         PARAMS ((rtx x, int size));\n void          debug_hard_reg_set   PARAMS ((HARD_REG_SET set));\n static int    avr_valid_type_attribute PARAMS ((tree, tree, tree, tree));\n static int    avr_valid_decl_attribute PARAMS ((tree, tree, tree, tree));\n+static void   avr_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void   avr_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \n /* Allocate registers from r25 to r8 for parameters for function calls */\n #define FIRST_CUM_REG 26\n@@ -171,6 +173,10 @@ static const struct mcu_type_s avr_mcu_types[] = {\n int avr_case_values_threshold = 30000;\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE avr_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE avr_output_function_epilogue\n #undef TARGET_VALID_DECL_ATTRIBUTE\n #define TARGET_VALID_DECL_ATTRIBUTE avr_valid_decl_attribute\n \n@@ -538,10 +544,10 @@ out_set_stack_ptr (file, before, after)\n \n /* Output function prologue */\n \n-void\n-function_prologue (file, size)\n+static void\n+avr_output_function_prologue (file, size)\n      FILE *file;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n   int reg;\n   int interrupt_func_p;\n@@ -675,10 +681,10 @@ function_prologue (file, size)\n \n /* Output function epilogue */\n \n-void\n-function_epilogue (file, size)\n+static void\n+avr_output_function_epilogue (file, size)\n      FILE *file;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n   int reg;\n   int interrupt_func_p;"}, {"sha": "8d6764e4e0519deefc96037a8a08b92d16c54d7f", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1349,133 +1349,12 @@ extern int avr_reg_order[];\n    the frame pointer.  A definition of 0 means that the address is\n    passed as an \"invisible\" first argument.  */\n \n-#define FUNCTION_PROLOGUE(FILE, SIZE) function_prologue (FILE, SIZE)\n-/* A C compound statement that outputs the assembler code for entry\n-   to a function.  The prologue is responsible for setting up the\n-   stack frame, initializing the frame pointer register, saving\n-   registers that must be saved, and allocating SIZE additional bytes\n-   of storage for the local variables.  SIZE is an integer.  FILE is\n-   a stdio stream to which the assembler code should be output.\n-\n-   The label for the beginning of the function need not be output by\n-   this macro.  That has already been done when the macro is run.\n-\n-   To determine which registers to save, the macro can refer to the\n-   array `regs_ever_live': element R is nonzero if hard register R is\n-   used anywhere within the function.  This implies the function\n-   prologue should save register R, provided it is not one of the\n-   call-used registers.  (`FUNCTION_EPILOGUE' must likewise use\n-   `regs_ever_live'.)\n-\n-   On machines that have \"register windows\", the function entry code\n-   does not save on the stack the registers that are in the windows,\n-   even if they are supposed to be preserved by function calls;\n-   instead it takes appropriate steps to \"push\" the register stack,\n-   if any non-call-used registers are used in the function.\n-\n-   On machines where functions may or may not have frame-pointers, the\n-   function entry code must vary accordingly; it must set up the frame\n-   pointer if one is wanted, and not otherwise.  To determine whether\n-   a frame pointer is in wanted, the macro can refer to the variable\n-   `frame_pointer_needed'.  The variable's value will be 1 at run\n-   time in a function that needs a frame pointer.  *Note\n-   Elimination::.\n-\n-   The function entry code is responsible for allocating any stack\n-   space required for the function.  This stack space consists of the\n-   regions listed below.  In most cases, these regions are allocated\n-   in the order listed, with the last listed region closest to the\n-   top of the stack (the lowest address if `STACK_GROWS_DOWNWARD' is\n-   defined, and the highest address if it is not defined).  You can\n-   use a different order for a machine if doing so is more convenient\n-   or required for compatibility reasons.  Except in cases where\n-   required by standard or by a debugger, there is no reason why the\n-   stack layout used by GCC need agree with that used by other\n-   compilers for a machine.\n-\n-   * A region of `current_function_pretend_args_size' bytes of\n-   uninitialized space just underneath the first argument\n-   arriving on the stack.  (This may not be at the very start of\n-   the allocated stack region if the calling sequence has pushed\n-   anything else since pushing the stack arguments.  But\n-   usually, on such machines, nothing else has been pushed yet,\n-   because the function prologue itself does all the pushing.)\n-   This region is used on machines where an argument may be\n-   passed partly in registers and partly in memory, and, in some\n-   cases to support the features in `varargs.h' and `stdargs.h'.\n-\n-   * An area of memory used to save certain registers used by the\n-   function.  The size of this area, which may also include\n-   space for such things as the return address and pointers to\n-   previous stack frames, is machine-specific and usually\n-   depends on which registers have been used in the function.\n-   Machines with register windows often do not require a save\n-   area.\n-\n-   * A region of at least SIZE bytes, possibly rounded up to an\n-   allocation boundary, to contain the local variables of the\n-   function.  On some machines, this region and the save area\n-   may occur in the opposite order, with the save area closer to\n-   the top of the stack.\n-\n-   * Optionally, when `ACCUMULATE_OUTGOING_ARGS' is defined, a\n-   region of `current_function_outgoing_args_size' bytes to be\n-   used for outgoing argument lists of the function.  *Note\n-   Stack Arguments::.\n-\n-   Normally, it is necessary for the macros `FUNCTION_PROLOGUE' and\n-   `FUNCTION_EPILOGE' to treat leaf functions specially.  The C\n-   variable `leaf_function' is nonzero for such a function.  */\n-\n #define EPILOGUE_USES(REGNO) 0\n /* Define this macro as a C expression that is nonzero for registers\n    are used by the epilogue or the `return' pattern.  The stack and\n    frame pointer registers are already be assumed to be used as\n    needed.  */\n \n-#define FUNCTION_EPILOGUE(FILE, SIZE) function_epilogue (FILE, SIZE)\n-/* A C compound statement that outputs the assembler code for exit\n-   from a function.  The epilogue is responsible for restoring the\n-   saved registers and stack pointer to their values when the\n-   function was called, and returning control to the caller.  This\n-   macro takes the same arguments as the macro `FUNCTION_PROLOGUE',\n-   and the registers to restore are determined from `regs_ever_live'\n-   and `CALL_USED_REGISTERS' in the same way.\n-\n-   On some machines, there is a single instruction that does all the\n-   work of returning from the function.  On these machines, give that\n-   instruction the name `return' and do not define the macro\n-   `FUNCTION_EPILOGUE' at all.\n-\n-   Do not define a pattern named `return' if you want the\n-   `FUNCTION_EPILOGUE' to be used.  If you want the target switches\n-   to control whether return instructions or epilogues are used,\n-   define a `return' pattern with a validity condition that tests the\n-   target switches appropriately.  If the `return' pattern's validity\n-   condition is false, epilogues will be used.\n-\n-   On machines where functions may or may not have frame-pointers, the\n-   function exit code must vary accordingly.  Sometimes the code for\n-   these two cases is completely different.  To determine whether a\n-   frame pointer is wanted, the macro can refer to the variable\n-   `frame_pointer_needed'.  The variable's value will be 1 when\n-   compiling a function that needs a frame pointer.\n-\n-   Normally, `FUNCTION_PROLOGUE' and `FUNCTION_EPILOGUE' must treat\n-   leaf functions specially.  The C variable `leaf_function' is\n-   nonzero for such a function.  *Note Leaf Functions::.\n-\n-   On some machines, some functions pop their arguments on exit while\n-   others leave that for the caller to do.  For example, the 68020\n-   when given `-mrtd' pops arguments in functions that take a fixed\n-   number of arguments.\n-\n-   Your definition of the macro `RETURN_POPS_ARGS' decides which\n-   functions pop their own arguments.  `FUNCTION_EPILOGUE' needs to\n-   know what was decided.  The variable that is called\n-   `current_function_pops_args' is the number of bytes of its\n-   arguments that a function should pop.  *Note Scalar Return::.  */\n-\n #define STRICT_ARGUMENT_NAMING 1\n /* Define this macro if the location where a function argument is\n    passed depends on whether or not it is a named argument."}, {"sha": "bfdb7c7b9dad58a13bed627702aadbc4a53dbafc", "filename": "gcc/config/clipper/clipper-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fclipper%2Fclipper-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fclipper%2Fclipper-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -33,8 +33,6 @@ extern int fp_reg_operand PARAMS ((rtx, enum machine_mode));\n \n extern struct rtx_def *clipper_builtin_saveregs PARAMS ((void));\n extern int clipper_frame_size PARAMS ((int));\n-extern void output_function_prologue PARAMS ((FILE *, int));\n-extern void output_function_epilogue PARAMS ((FILE *, int));\n #ifdef TREE_CODE\n extern tree clipper_build_va_list PARAMS ((void));\n #endif /* TREE_CODE */"}, {"sha": "3adcff7c6a8ebb30fff73840b288f192158a7900", "filename": "gcc/config/clipper/clipper.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fclipper%2Fclipper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fclipper%2Fclipper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -31,22 +31,29 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"insn-attr.h\"\n #include \"tree.h\"\n+#include \"expr.h\"\n #include \"c-tree.h\"\n #include \"function.h\"\n-#include \"expr.h\"\n #include \"flags.h\"\n #include \"recog.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n \n+static void clipper_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void clipper_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+\n extern char regs_ever_live[];\n \n extern int frame_pointer_needed;\n \n static int frame_size;\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE clipper_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE clipper_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -84,10 +91,10 @@ clipper_frame_size (lsize)\n    can run with misaligned stack -> subq $4,sp / add $4,sp on entry and exit\n    can be omitted.  */\n \n-void\n-output_function_prologue (file, lsize)\n+static void\n+clipper_output_function_prologue (file, lsize)\n      FILE *file;\n-     int lsize;\t\t\t\t/* size for locals */\n+     HOST_WIDE_INT lsize;\t\t\t/* size for locals */\n {\n   int i, offset;\n   int size;\n@@ -138,10 +145,10 @@ output_function_prologue (file, lsize)\n     }\n }\n \n-void\n-output_function_epilogue (file, size)\n+static void\n+clipper_output_function_epilogue (file, size)\n      FILE *file;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   int i, offset;\n "}, {"sha": "4b43973294440ec83edd56448afc95562d3152e8", "filename": "gcc/config/clipper/clipper.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fclipper%2Fclipper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fclipper%2Fclipper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -550,16 +550,6 @@ do\t\t\t\t\t\t\t\t\t      \\\n \n #define EXPAND_BUILTIN_SAVEREGS() clipper_builtin_saveregs ()\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) output_function_prologue (FILE,SIZE)\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -582,13 +572,6 @@ do\t\t\t\t\t\t\t\t\t      \\\n \n #define EXIT_IGNORE_STACK 1\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) output_function_epilogue(FILE,SIZE)\n-\n /* Store in the variable DEPTH the initial difference between the\n    frame pointer reg contents and the stack pointer reg contents,\n    as of the start of the function body.  This depends on the layout"}, {"sha": "6f563e29edc0cfea98205257498d1c0b09ce5a5f", "filename": "gcc/config/convex/convex.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fconvex%2Fconvex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fconvex%2Fconvex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -64,11 +64,53 @@ static int frame_argblock_size;\n static rtx convert_arg_pushes ();\n #endif\n static void expand_movstr_call PARAMS ((rtx *));\n+static void convex_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void convex_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE convex_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE convex_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n+/* Generate the assembly code for function entry.  FILE is a stdio\n+   stream to output the code to.  SIZE is an int: how many units of\n+   temporary storage to allocate.\n+\n+   Refer to the array `regs_ever_live' to determine which registers to\n+   save; `regs_ever_live[I]' is nonzero if register number I is ever\n+   used in the function.  This function is responsible for knowing\n+   which registers should not be saved even if used.  */\n+\n+static void\n+convex_output_function_prologue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size;\n+{\n+  size = ((size) + 7) & -8;\n+  if (size)\n+    fprintf (file, \"\\tsub.w #%d,sp\\n\", size);\n+}\n+\n+/* This function generates the assembly code for function exit.\n+   Args are as for output_function_prologue ().\n+\n+   The function epilogue should not depend on the current stack\n+   pointer!  It should use the frame pointer only.  This is mandatory\n+   because of alloca; we also take advantage of it to omit stack\n+   adjustments before returning. */\n+\n+static void\n+convex_output_function_epilogue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+{\n+  /* Follow function with a zero to stop c34 icache prefetching. */\n+  fprintf (file, \"\\tds.h 0\\n\");\n+}\n+\n /* Here from OVERRIDE_OPTIONS at startup.  Initialize constant tables. */\n \n void"}, {"sha": "10f8cb957942e8ef670ed345cb4bc108ed751330", "filename": "gcc/config/convex/convex.h", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -818,32 +818,6 @@ enum reg_class {\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   ((MODE) == VOIDmode ? GEN_INT ((CUM)) : 0)\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) \t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  int size = ((SIZE) + 7) & -8;\t\t\t\t\t\t\\\n-  if (size != 0)\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tsub.w #%d,sp\\n\", size);\t\t\t\t\\\n-}\n-\n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  /* Follow function with a zero to stop c34 icache prefetching. */\t\\\n-  fprintf (FILE, \"\\tds.h 0\\n\");\t\t\t\t\t\t\\\n-}\n-\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.  */\n "}, {"sha": "f681a40fd8b36ffcfec9b879a30d0b82030706e0", "filename": "gcc/config/d30v/d30v-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -110,9 +110,7 @@ extern rtx d30v_expand_builtin_va_arg\tPARAMS ((tree, tree));\n #endif\t/* RTX_CODE */\n #endif\t/* TREE_CODE */\n \n-extern void d30v_function_prologue\tPARAMS ((FILE *, int));\n extern void d30v_expand_prologue\tPARAMS ((void));\n-extern void d30v_function_epilogue\tPARAMS ((FILE *, int));\n extern void d30v_expand_epilogue\tPARAMS ((void));\n extern void d30v_function_profiler\tPARAMS ((FILE *, int));\n #ifdef RTX_CODE"}, {"sha": "e73cad011ff1f827797d0809dad3d1a7fab67e71", "filename": "gcc/config/d30v/d30v.c", "status": "modified", "additions": 46, "deletions": 131, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fd30v%2Fd30v.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fd30v%2Fd30v.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -49,6 +49,8 @@ static void d30v_add_gc_roots PARAMS ((void));\n static void d30v_init_machine_status PARAMS ((struct function *));\n static void d30v_mark_machine_status PARAMS ((struct function *));\n static void d30v_free_machine_status PARAMS ((struct function *));\n+static void d30v_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void d30v_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  */\n@@ -80,6 +82,10 @@ enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n enum reg_class reg_class_from_letter[256];\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE d30v_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE d30v_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -2321,96 +2327,32 @@ d30v_expand_builtin_va_arg(valist, type)\n   return ptr_rtx;\n }\n \f\n+/* Generate the assembly code for function entry.  FILE is a stdio\n+   stream to output the code to.  SIZE is an int: how many units of\n+   temporary storage to allocate.\n \n-/* A C compound statement that outputs the assembler code for entry to a\n-   function.  The prologue is responsible for setting up the stack frame,\n-   initializing the frame pointer register, saving registers that must be\n-   saved, and allocating SIZE additional bytes of storage for the local\n-   variables.  SIZE is an integer.  FILE is a stdio stream to which the\n-   assembler code should be output.\n-\n-   The label for the beginning of the function need not be output by this\n-   macro.  That has already been done when the macro is run.\n-\n-   To determine which registers to save, the macro can refer to the array\n-   `regs_ever_live': element R is nonzero if hard register R is used anywhere\n-   within the function.  This implies the function prologue should save\n-   register R, provided it is not one of the call-used registers.\n-   (`FUNCTION_EPILOGUE' must likewise use `regs_ever_live'.)\n-\n-   On machines that have \"register windows\", the function entry code does not\n-   save on the stack the registers that are in the windows, even if they are\n-   supposed to be preserved by function calls; instead it takes appropriate\n-   steps to \"push\" the register stack, if any non-call-used registers are used\n-   in the function.\n-\n-   On machines where functions may or may not have frame-pointers, the function\n-   entry code must vary accordingly; it must set up the frame pointer if one is\n-   wanted, and not otherwise.  To determine whether a frame pointer is in\n-   wanted, the macro can refer to the variable `frame_pointer_needed'.  The\n-   variable's value will be 1 at run time in a function that needs a frame\n-   pointer.  *Note Elimination::.\n-\n-   The function entry code is responsible for allocating any stack space\n-   required for the function.  This stack space consists of the regions listed\n-   below.  In most cases, these regions are allocated in the order listed, with\n-   the last listed region closest to the top of the stack (the lowest address\n-   if `STACK_GROWS_DOWNWARD' is defined, and the highest address if it is not\n-   defined).  You can use a different order for a machine if doing so is more\n-   convenient or required for compatibility reasons.  Except in cases where\n-   required by standard or by a debugger, there is no reason why the stack\n-   layout used by GCC need agree with that used by other compilers for a\n-   machine.\n-\n-      * A region of `current_function_pretend_args_size' bytes of\n-        uninitialized space just underneath the first argument\n-        arriving on the stack.  (This may not be at the very start of\n-        the allocated stack region if the calling sequence has pushed\n-        anything else since pushing the stack arguments.  But\n-        usually, on such machines, nothing else has been pushed yet,\n-        because the function prologue itself does all the pushing.)\n-        This region is used on machines where an argument may be\n-        passed partly in registers and partly in memory, and, in some\n-        cases to support the features in `varargs.h' and `stdargs.h'.\n-\n-      * An area of memory used to save certain registers used by the\n-        function.  The size of this area, which may also include\n-        space for such things as the return address and pointers to\n-        previous stack frames, is machine-specific and usually\n-        depends on which registers have been used in the function.\n-        Machines with register windows often do not require a save\n-        area.\n-\n-      * A region of at least SIZE bytes, possibly rounded up to an\n-        allocation boundary, to contain the local variables of the\n-        function.  On some machines, this region and the save area\n-        may occur in the opposite order, with the save area closer to\n-        the top of the stack.\n-\n-      * Optionally, when `ACCUMULATE_OUTGOING_ARGS' is defined, a\n-        region of `current_function_outgoing_args_size' bytes to be\n-        used for outgoing argument lists of the function.  *Note\n-        Stack Arguments::.\n-\n-   Normally, it is necessary for the macros `FUNCTION_PROLOGUE' and\n-   `FUNCTION_EPILOGUE' to treat leaf functions specially.  The C variable\n-   `leaf_function' is nonzero for such a function.  */\n-\n-/* For the d30v, move all of the prologue processing into separate insns.  */\n-void\n-d30v_function_prologue (stream, size)\n+   Refer to the array `regs_ever_live' to determine which registers to\n+   save; `regs_ever_live[I]' is nonzero if register number I is ever\n+   used in the function.  This function is responsible for knowing\n+   which registers should not be saved even if used.  */\n+\n+static void\n+d30v_output_function_prologue (stream, size)\n      FILE *stream ATTRIBUTE_UNUSED;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n+  /* For the d30v, move all of the prologue processing into separate\n+     insns.  */\n }\n \n \f\n-/* Called after register allocation to add any instructions needed for the\n-   prologue.  Using a prologue insn is favored compared to putting all of the\n-   instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n-   to intermix instructions with the saves of the caller saved registers.  In\n-   some cases, it might be necessary to emit a barrier instruction as the last\n-   insn to prevent such scheduling.  */\n+/* Called after register allocation to add any instructions needed for\n+   the prologue.  Using a prologue insn is favored compared to putting\n+   all of the instructions in output_function_prologue (), since it\n+   allows the scheduler to intermix instructions with the saves of the\n+   caller saved registers.  In some cases, it might be necessary to\n+   emit a barrier instruction as the last insn to prevent such\n+   scheduling.  */\n \n void\n d30v_expand_prologue ()\n@@ -2492,60 +2434,33 @@ d30v_expand_prologue ()\n }\n \n \f\n-/* A C compound statement that outputs the assembler code for exit from a\n-   function.  The epilogue is responsible for restoring the saved registers and\n-   stack pointer to their values when the function was called, and returning\n-   control to the caller.  This macro takes the same arguments as the macro\n-   `FUNCTION_PROLOGUE', and the registers to restore are determined from\n-   `regs_ever_live' and `CALL_USED_REGISTERS' in the same way.\n-\n-   On some machines, there is a single instruction that does all the work of\n-   returning from the function.  On these machines, give that instruction the\n-   name `return' and do not define the macro `FUNCTION_EPILOGUE' at all.\n-\n-   Do not define a pattern named `return' if you want the `FUNCTION_EPILOGUE'\n-   to be used.  If you want the target switches to control whether return\n-   instructions or epilogues are used, define a `return' pattern with a\n-   validity condition that tests the target switches appropriately.  If the\n-   `return' pattern's validity condition is false, epilogues will be used.\n-\n-   On machines where functions may or may not have frame-pointers, the function\n-   exit code must vary accordingly.  Sometimes the code for these two cases is\n-   completely different.  To determine whether a frame pointer is wanted, the\n-   macro can refer to the variable `frame_pointer_needed'.  The variable's\n-   value will be 1 when compiling a function that needs a frame pointer.\n-\n-   Normally, `FUNCTION_PROLOGUE' and `FUNCTION_EPILOGUE' must treat leaf\n-   functions specially.  The C variable `leaf_function' is nonzero for such a\n-   function.  *Note Leaf Functions::.\n-\n-   On some machines, some functions pop their arguments on exit while others\n-   leave that for the caller to do.  For example, the 68020 when given `-mrtd'\n-   pops arguments in functions that take a fixed number of arguments.\n-\n-   Your definition of the macro `RETURN_POPS_ARGS' decides which functions pop\n-   their own arguments.  `FUNCTION_EPILOGUE' needs to know what was decided.\n-   The variable that is called `current_function_pops_args' is the number of\n-   bytes of its arguments that a function should pop.  *Note Scalar Return::.  */\n-\n-/* For the d30v, move all processing to be as insns, but do any cleanup\n-   here, since it is done after handling all of the insns.  */\n-void\n-d30v_function_epilogue (stream, size)\n+/* This function generates the assembly code for function exit.\n+   Args are as for output_function_prologue ().\n+\n+   The function epilogue should not depend on the current stack\n+   pointer!  It should use the frame pointer only.  This is mandatory\n+   because of alloca; we also take advantage of it to omit stack\n+   adjustments before returning.  */\n+\n+static void\n+d30v_output_function_epilogue (stream, size)\n      FILE *stream ATTRIBUTE_UNUSED;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n+  /* For the d30v, move all processing to be as insns, but do any\n+     cleanup here, since it is done after handling all of the insns.  */\n   d30v_stack_cache = (d30v_stack_t *)0;\t/* reset stack cache */\n }\n \n \f\n \n-/* Called after register allocation to add any instructions needed for the\n-   epilogue.  Using a epilogue insn is favored compared to putting all of the\n-   instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n-   to intermix instructions with the saves of the caller saved registers.  In\n-   some cases, it might be necessary to emit a barrier instruction as the last\n-   insn to prevent such scheduling.  */\n+/* Called after register allocation to add any instructions needed for\n+   the epilogue.  Using a epilogue insn is favored compared to putting\n+   all of the instructions in output_function_prologue(), since it\n+   allows the scheduler to intermix instructions with the saves of the\n+   caller saved registers.  In some cases, it might be necessary to\n+   emit a barrier instruction as the last insn to prevent such\n+   scheduling.  */\n \n void\n d30v_expand_epilogue ()"}, {"sha": "3565cc71a4ceef9571f0717614ba4c6a4feb72b1", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 19, "deletions": 142, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -2656,93 +2656,6 @@ typedef int CUMULATIVE_ARGS;\n /* #define CALLER_SAVE_PROFITABLE(REFS, CALLS) */\n \n \f\n-/* Function Entry and Exit */\n-\n-/* A C compound statement that outputs the assembler code for entry to a\n-   function.  The prologue is responsible for setting up the stack frame,\n-   initializing the frame pointer register, saving registers that must be\n-   saved, and allocating SIZE additional bytes of storage for the local\n-   variables.  SIZE is an integer.  FILE is a stdio stream to which the\n-   assembler code should be output.\n-\n-   The label for the beginning of the function need not be output by this\n-   macro.  That has already been done when the macro is run.\n-\n-   To determine which registers to save, the macro can refer to the array\n-   `regs_ever_live': element R is nonzero if hard register R is used anywhere\n-   within the function.  This implies the function prologue should save\n-   register R, provided it is not one of the call-used registers.\n-   (`FUNCTION_EPILOGUE' must likewise use `regs_ever_live'.)\n-\n-   On machines that have \"register windows\", the function entry code does not\n-   save on the stack the registers that are in the windows, even if they are\n-   supposed to be preserved by function calls; instead it takes appropriate\n-   steps to \"push\" the register stack, if any non-call-used registers are used\n-   in the function.\n-\n-   On machines where functions may or may not have frame-pointers, the function\n-   entry code must vary accordingly; it must set up the frame pointer if one is\n-   wanted, and not otherwise.  To determine whether a frame pointer is in\n-   wanted, the macro can refer to the variable `frame_pointer_needed'.  The\n-   variable's value will be 1 at run time in a function that needs a frame\n-   pointer.  *Note Elimination::.\n-\n-   The function entry code is responsible for allocating any stack space\n-   required for the function.  This stack space consists of the regions listed\n-   below.  In most cases, these regions are allocated in the order listed, with\n-   the last listed region closest to the top of the stack (the lowest address\n-   if `STACK_GROWS_DOWNWARD' is defined, and the highest address if it is not\n-   defined).  You can use a different order for a machine if doing so is more\n-   convenient or required for compatibility reasons.  Except in cases where\n-   required by standard or by a debugger, there is no reason why the stack\n-   layout used by GCC need agree with that used by other compilers for a\n-   machine.\n-\n-      * A region of `current_function_pretend_args_size' bytes of\n-        uninitialized space just underneath the first argument\n-        arriving on the stack.  (This may not be at the very start of\n-        the allocated stack region if the calling sequence has pushed\n-        anything else since pushing the stack arguments.  But\n-        usually, on such machines, nothing else has been pushed yet,\n-        because the function prologue itself does all the pushing.)\n-        This region is used on machines where an argument may be\n-        passed partly in registers and partly in memory, and, in some\n-        cases to support the features in `varargs.h' and `stdargs.h'.\n-\n-      * An area of memory used to save certain registers used by the\n-        function.  The size of this area, which may also include\n-        space for such things as the return address and pointers to\n-        previous stack frames, is machine-specific and usually\n-        depends on which registers have been used in the function.\n-        Machines with register windows often do not require a save\n-        area.\n-\n-      * A region of at least SIZE bytes, possibly rounded up to an\n-        allocation boundary, to contain the local variables of the\n-        function.  On some machines, this region and the save area\n-        may occur in the opposite order, with the save area closer to\n-        the top of the stack.\n-\n-      * Optionally, when `ACCUMULATE_OUTGOING_ARGS' is defined, a\n-        region of `current_function_outgoing_args_size' bytes to be\n-        used for outgoing argument lists of the function.  *Note\n-        Stack Arguments::.\n-\n-   Normally, it is necessary for the macros `FUNCTION_PROLOGUE' and\n-   `FUNCTION_EPILOGUE' to treat leaf functions specially.  The C variable\n-   `leaf_function' is nonzero for such a function.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) d30v_function_prologue (FILE, SIZE)\n-\n-/* Define this macro as a C expression that is nonzero if the return\n-   instruction or the function epilogue ignores the value of the stack pointer;\n-   in other words, if it is safe to delete an instruction to adjust the stack\n-   pointer before a return from the function.\n-\n-   Note that this macro's value is relevant only for functions for which frame\n-   pointers are maintained.  It is never safe to delete a final stack\n-   adjustment in a function that has no frame pointer, and the compiler knows\n-   this regardless of `EXIT_IGNORE_STACK'.  */\n /* #define EXIT_IGNORE_STACK */\n \n /* Define this macro as a C expression that is nonzero for registers\n@@ -2751,44 +2664,6 @@ typedef int CUMULATIVE_ARGS;\n    needed.  */\n #define EPILOGUE_USES(REGNO)  ((REGNO) == GPR_LINK)\n \n-/* A C compound statement that outputs the assembler code for exit from a\n-   function.  The epilogue is responsible for restoring the saved registers and\n-   stack pointer to their values when the function was called, and returning\n-   control to the caller.  This macro takes the same arguments as the macro\n-   `FUNCTION_PROLOGUE', and the registers to restore are determined from\n-   `regs_ever_live' and `CALL_USED_REGISTERS' in the same way.\n-\n-   On some machines, there is a single instruction that does all the work of\n-   returning from the function.  On these machines, give that instruction the\n-   name `return' and do not define the macro `FUNCTION_EPILOGUE' at all.\n-\n-   Do not define a pattern named `return' if you want the `FUNCTION_EPILOGUE'\n-   to be used.  If you want the target switches to control whether return\n-   instructions or epilogues are used, define a `return' pattern with a\n-   validity condition that tests the target switches appropriately.  If the\n-   `return' pattern's validity condition is false, epilogues will be used.\n-\n-   On machines where functions may or may not have frame-pointers, the function\n-   exit code must vary accordingly.  Sometimes the code for these two cases is\n-   completely different.  To determine whether a frame pointer is wanted, the\n-   macro can refer to the variable `frame_pointer_needed'.  The variable's\n-   value will be 1 when compiling a function that needs a frame pointer.\n-\n-   Normally, `FUNCTION_PROLOGUE' and `FUNCTION_EPILOGUE' must treat leaf\n-   functions specially.  The C variable `leaf_function' is nonzero for such a\n-   function.  *Note Leaf Functions::.\n-\n-   On some machines, some functions pop their arguments on exit while others\n-   leave that for the caller to do.  For example, the 68020 when given `-mrtd'\n-   pops arguments in functions that take a fixed number of arguments.\n-\n-   Your definition of the macro `RETURN_POPS_ARGS' decides which functions pop\n-   their own arguments.  `FUNCTION_EPILOGUE' needs to know what was decided.\n-   The variable that is called `current_function_pops_args' is the number of\n-   bytes of its arguments that a function should pop.  *Note Scalar Return::.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) d30v_function_epilogue (FILE, SIZE)\n-\n /* Define this macro if the function epilogue contains delay slots to which\n    instructions from the rest of the function can be \"moved\".  The definition\n    should be a C expression whose value is an integer representing the number\n@@ -2809,8 +2684,8 @@ typedef int CUMULATIVE_ARGS;\n    The insns accepted to fill the epilogue delay slots are put in an\n    RTL list made with `insn_list' objects, stored in the variable\n    `current_function_epilogue_delay_list'.  The insn for the first\n-   delay slot comes first in the list.  Your definition of the macro\n-   `FUNCTION_EPILOGUE' should fill the delay slots by outputting the\n+   delay slot comes first in the list.  Your definition of the function\n+   output_function_epilogue() should fill the delay slots by outputting the\n    insns in this list, usually by calling `final_scan_insn'.\n \n    You need not define this macro if you did not define\n@@ -2833,10 +2708,10 @@ typedef int CUMULATIVE_ARGS;\n    the return address.  Hence returning from FUNCTION will return to whoever\n    called the current `thunk'.\n \n-   The effect must be as if FUNCTION had been called directly with the adjusted\n-   first argument.  This macro is responsible for emitting all of the code for\n-   a thunk function; `FUNCTION_PROLOGUE' and `FUNCTION_EPILOGUE' are not\n-   invoked.\n+   The effect must be as if FUNCTION had been called directly with the\n+   adjusted first argument.  This macro is responsible for emitting\n+   all of the code for a thunk function; output_function_prologue()\n+   and output_function_epilogue() are not invoked.\n \n    The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already been\n    extracted from it.)  It might possibly be useful on some targets, but\n@@ -2975,8 +2850,8 @@ typedef struct machine_function\n    code to call function `__bb_trace_ret'.  The assembler code should\n    only be output if the global compile flag `profile_block_flag' ==\n    2.  This macro has to be used at every place where code for\n-   returning from a function is generated (e.g. `FUNCTION_EPILOGUE').\n-   Although you have to write the definition of `FUNCTION_EPILOGUE'\n+   returning from a function is generated (e.g. output_function_epilogue()).\n+   Although you have to write the definition of output_function_epilogue()\n    as well, you have to define this macro to tell the compiler, that\n    the proper call to `__bb_trace_ret' is produced.  */\n /* #define FUNCTION_BLOCK_PROFILER_EXIT(FILE) */\n@@ -2987,17 +2862,18 @@ typedef struct machine_function\n    the assembler code can be concatenated with the string ID, to obtain a\n    unique lable name.\n \n-   Registers or condition codes clobbered by `FUNCTION_PROLOGUE' or\n-   `FUNCTION_EPILOGUE' must be saved in the macros `FUNCTION_BLOCK_PROFILER',\n-   `FUNCTION_BLOCK_PROFILER_EXIT' and `BLOCK_PROFILER' prior calling\n-   `__bb_init_trace_func', `__bb_trace_ret' and `__bb_trace_func' respectively.  */\n+   Registers or condition codes clobbered by output_function_prologue()\n+   or output_function_epilogue() must be saved in the macros\n+   `FUNCTION_BLOCK_PROFILER', FUNCTION_BLOCK_PROFILER_EXIT' and\n+   `BLOCK_PROFILER' prior calling `__bb_init_trace_func', `__bb_trace_ret'\n+   and `__bb_trace_func' respectively.  */\n /* #define MACHINE_STATE_SAVE(ID) */\n \n /* A C statement or compound statement to restore all registers, including\n    condition codes, saved by `MACHINE_STATE_SAVE'.\n \n-   Registers or condition codes clobbered by `FUNCTION_PROLOGUE' or\n-   `FUNCTION_EPILOGUE' must be restored in the macros\n+   Registers or condition codes clobbered by output_function_prologue()\n+   or output_function_epilogue() must be restored in the macros\n    `FUNCTION_BLOCK_PROFILER', `FUNCTION_BLOCK_PROFILER_EXIT' and\n    `BLOCK_PROFILER' after calling `__bb_init_trace_func', `__bb_trace_ret' and\n    `__bb_trace_func' respectively.  */\n@@ -3131,7 +3007,8 @@ typedef struct machine_function\n    stack slot.  This default is right for most machines.  The exceptions are\n    machines where it is impossible to execute instructions in the stack area.\n    On such machines, you may have to implement a separate stack, using this\n-   macro in conjunction with `FUNCTION_PROLOGUE' and `FUNCTION_EPILOGUE'.\n+   macro in conjunction with output_function_prologue () and\n+   output_function_epilogue ().\n \n    FP points to a data structure, a `struct function', which describes the\n    compilation status of the immediate containing function of the function\n@@ -5399,8 +5276,8 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n    To support optional call frame debugging information, you must also define\n    `INCOMING_RETURN_ADDR_RTX' and either set `RTX_FRAME_RELATED_P' on the\n    prologue insns if you use RTL for the prologue, or call `dwarf2out_def_cfa'\n-   and `dwarf2out_reg_save' as appropriate from `FUNCTION_PROLOGUE' if you\n-   don't.\n+   and `dwarf2out_reg_save' as appropriate from output_function_prologue() if\n+   you don't.\n \n    Defined in svr4.h.  */\n /* #define DWARF2_DEBUGGING_INFO */"}, {"sha": "4f62f3c64d47c2c47eabe1002c35917986393c45", "filename": "gcc/config/d30v/d30v.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fd30v%2Fd30v.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fd30v%2Fd30v.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.md?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -2934,7 +2934,7 @@\n \n ;; Called after register allocation to add any instructions needed for the\n ;; prologue.  Using a prologue insn is favored compared to putting all of the\n-;; instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n+;; instructions in output_function_prologue (), since it allows the scheduler\n ;; to intermix instructions with the saves of the caller saved registers.  In\n ;; some cases, it might be necessary to emit a barrier instruction as the last\n ;; insn to prevent such scheduling.\n@@ -2950,7 +2950,7 @@\n \n ;; Called after register allocation to add any instructions needed for the\n ;; epilogue.  Using a epilogue insn is favored compared to putting all of the\n-;; instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n+;; instructions in output_function_epilogue (), since it allows the scheduler\n ;; to intermix instructions with the saves of the caller saved registers.  In\n ;; some cases, it might be necessary to emit a barrier instruction as the last\n ;; insn to prevent such scheduling."}, {"sha": "6401f70ee49897c524e29b415cd24df914d61a95", "filename": "gcc/config/dsp16xx/dsp16xx-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -81,5 +81,3 @@ extern struct rtx_def *(*dsp16xx_compare_gen) PARAMS (());\n extern int hard_regno_mode_ok PARAMS ((int, enum machine_mode));\n extern enum reg_class dsp16xx_reg_class_from_letter PARAMS ((int));\n extern int regno_reg_class PARAMS ((int));\n-extern void function_prologue PARAMS ((FILE *, int));\n-extern void function_epilogue PARAMS ((FILE *, int));"}, {"sha": "f20754fc945d735946c71c77f79edd1f1e56af26", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -58,7 +58,6 @@ const char *save_chip_name;\n \n rtx dsp16xx_compare_op0;\n rtx dsp16xx_compare_op1;\n-struct rtx_def *(*dsp16xx_compare_gen)();\n \n static const char *fp;\n static const char *sp;\n@@ -147,8 +146,14 @@ static const char *const lshift_right_asm_first[] =\n };\n \n static int reg_save_size PARAMS ((void));\n+static void dsp16xx_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void dsp16xx_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE dsp16xx_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE dsp16xx_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -1176,10 +1181,10 @@ ybase_regs_ever_used ()\n   return live;\n }\n \n-void \n-function_prologue (file, size)\n+static void \n+dsp16xx_output_function_prologue (file, size)\n      FILE *file;\n-     int  size;\n+     HOST_WIDE_INT size;\n {\n   int regno;\n   long total_size;\n@@ -1294,10 +1299,11 @@ init_emulation_routines ()\n  dsp16xx_lshrhi3_libcall = (rtx) 0;\n \n }\n-void\n-function_epilogue (file, size)\n+\n+static void\n+dsp16xx_output_function_epilogue (file, size)\n      FILE *file;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   int regno;\n #if OLD_REGISTER_SAVE  \n@@ -1669,7 +1675,7 @@ print_operand(file, op, letter)\n \telse if (letter == 'm')\n \t  fprintf (file, \"%s\", himode_reg_name[REGNO (op)]);\n         else\n-\t  output_operand_lossgae (\"Bad register extension code\");\n+\t  output_operand_lossage (\"Bad register extension code\");\n     }\n     else if (code == MEM)\n       output_address (XEXP(op,0));\n@@ -1682,7 +1688,7 @@ print_operand(file, op, letter)\n \telse if (letter == 'h')\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, val);\n         else if (letter == 'U')\n-\t  fprint(f file, HOST_WIDE_INT_PRINT_HEX, (val >> 16) & 0xffff);\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_HEX, (val >> 16) & 0xffff);\n         else\n \t  output_addr_const (file, op);\n       }"}, {"sha": "15bd722fd4c3db94ff24d350917d51a4b510add2", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1162,16 +1162,6 @@ extern struct dsp16xx_frame_info current_frame_info;\n #define FUNCTION_ARG_REGNO_P(N)   \\\n   ((N) == REG_Y || (N) == REG_YL || (N) == REG_PROD || (N) == REG_PRODL)\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used. */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE)     function_prologue(FILE, SIZE)\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry. */\n \n@@ -1211,18 +1201,6 @@ extern struct dsp16xx_frame_info current_frame_info;\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n   internal_error (\"Trampolines not yet implemented\");\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning. */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE)   function_epilogue(FILE, SIZE)\n-\n /* A C expression which is nonzero if a function must have and use a\n    frame pointer. If its value is nonzero the functions will have a\n    frame pointer. */"}, {"sha": "0939bd1f36bf8b5d5917887849edb07e29e88ee2", "filename": "gcc/config/elxsi/elxsi.c", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Felxsi%2Felxsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Felxsi%2Felxsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -37,11 +37,104 @@ rtx cmp_op0=0, cmp_op1=0;\n static const char *const cmp_tab[] = {\n     \"gt\", \"gt\", \"eq\", \"eq\", \"ge\", \"ge\", \"lt\", \"lt\", \"ne\", \"ne\",\n     \"le\", \"le\" };\n+\n+static void elxsi_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void elxsi_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE elxsi_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE elxsi_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n+/* Generate the assembly code for function entry.  FILE is a stdio\n+   stream to output the code to.  SIZE is an int: how many units of\n+   temporary storage to allocate.\n+\n+   Refer to the array `regs_ever_live' to determine which registers to\n+   save; `regs_ever_live[I]' is nonzero if register number I is ever\n+   used in the function.  This function is responsible for knowing\n+   which registers should not be saved even if used.  */\n+\n+static void\n+elxsi_output_function_prologue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size;\n+{\n+  register int regno;\n+  register int cnt = 0;\n+  extern char call_used_regs[];\n+\n+  /* the below two lines are a HACK, and should be deleted, but\n+     for now are very much needed (1.35) */\n+  if (frame_pointer_needed)\n+    regs_ever_live[14] = 1, call_used_regs[14] = 0;\n+\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (regs_ever_live[regno] && !call_used_regs[regno])\n+      cnt += 8;\n+\n+  if (size + cnt)\n+    fprintf (file, \"\\tadd.64\\t.sp,=%d\\n\", -size - cnt);\n+\n+  cnt = 0;\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (regs_ever_live[regno] && !call_used_regs[regno])\n+      fprintf (file, \"\\tst.64\\t.r%d,[.sp]%d\\n\", regno, (cnt += 8) - 12);\n+\n+  if (frame_pointer_needed)\n+    fprintf (file, \"\\tadd.64\\t.r14,.sp,=%d\\n\", size + cnt);\n+}\n+\n+/* This function generates the assembly code for function exit.\n+   Args are as for output_function_prologue ().\n+\n+   The function epilogue should not depend on the current stack\n+   pointer!  It should use the frame pointer only.  This is mandatory\n+   because of alloca; we also take advantage of it to omit stack\n+   adjustments before returning. */\n+\n+static void\n+elxsi_output_function_epilogue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size;\n+{\n+  register int regno;\n+  register int cnt = 0;\n+  extern char call_used_regs[];\n+\n+  /* this conditional is ONLY here because there is a BUG;\n+     EXIT_IGNORE_STACK is ignored itself when the first part of\n+     the condition is true! (at least in version 1.35) */\n+  /* the 8*10 is for 64 bits of .r5 - .r14 */\n+  if (current_function_calls_alloca || size >= (256 - 8 * 10))\n+    {\n+      /* use .r4 as a temporary! Ok for now.... */\n+      fprintf (file, \"\\tld.64\\t.r4,.r14\\n\");\n+\n+      for (regno = FIRST_PSEUDO_REGISTER-1; regno >= 0; --regno)\n+\tif (regs_ever_live[regno] && !call_used_regs[regno])\n+\t  cnt += 8;\n+\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n+\tif (regs_ever_live[regno] && !call_used_regs[regno])\n+\t  fprintf (file, \"\\tld.64\\t.r%d,[.r14]%d\\n\", regno,\n+\t\t   -((cnt -= 8) + 8) - 4 - size);\n+\n+      fprintf (file, \"\\tld.64\\t.sp,.r4\\n\\texit\\t0\\n\");\n+    }\n+  else\n+    {\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n+\tif (regs_ever_live[regno] && !call_used_regs[regno])\n+\t  fprintf (file, \"\\tld.64\\t.r%d,[.sp]%d\\n\", regno, (cnt + =8) - 12);\n+\n+      fprintf (file, \"\\texit\\t%d\\n\", size + cnt);\n+    }\n+}\n+\n /* type is the index into the above table */\n /* s is \"\" for signed, or \"u\" for unsigned */\n const char *"}, {"sha": "fb2885d1165ce6504549b592c47cb5c55c253995", "filename": "gcc/config/elxsi/elxsi.h", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Felxsi%2Felxsi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Felxsi%2Felxsi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -390,35 +390,6 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE)\t\t\t\t\t\\\n-{ register int regno;\t\t\t\t\t\t\t\\\n-  register int cnt = 0;\t\t\t\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\t\\\n-  /* the below two lines are a HACK, and should be deleted, but \t\\\n-     for now are very much needed (1.35) */\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\t\\\n-    regs_ever_live[14]=1, call_used_regs[14]=0;\t\t\t\t\\\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\t\\\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n-\tcnt+=8;\t\t\t\t\t\t\t\t\\\n-  if ((SIZE)+cnt)\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tadd.64\\t.sp,=%d\\n\", -(SIZE)-cnt);\t\t\t\\\n-  cnt = 0;\t\t\t\t\t\t\t\t\\\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\t\\\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n-      fprintf (FILE, \"\\tst.64\\t.r%d,[.sp]%d\\n\", regno, (cnt+=8)-12); \t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tadd.64\\t.r14,.sp,=%d\\n\", (SIZE)+cnt);\t\t\\\n-}\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -432,37 +403,6 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define EXIT_IGNORE_STACK 0\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\t\t\\\n-{ register int regno;\t\t\t\t\t\t\t\\\n-  register int cnt = 0;\t\t\t\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\t\\\n-  /* this conditional is ONLY here because there is a BUG;\t\t\\\n-\t     EXIT_IGNORE_STACK is ignored itself when the first part of\t\\\n-\t     the condition is true! (at least in version 1.35) */\t\\\n-  /* the 8*10 is for 64 bits of .r5 - .r14 */\t\t\t\t\\\n-  if (current_function_calls_alloca || (SIZE)>=(256-8*10)) {\t\t\\\n-    /* use .r4 as a temporary! Ok for now.... */\t\t\t\\\n-    fprintf (FILE, \"\\tld.64\\t.r4,.r14\\n\");\t\t\t\t\\\n-    for (regno = FIRST_PSEUDO_REGISTER-1; regno >= 0; --regno)\t\t\\\n-      if (regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n-       \tcnt+=8;\t\t\t\t\t\t\t\t\\\n-    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\t\t\\\n-      if (regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n-       fprintf (FILE, \"\\tld.64\\t.r%d,[.r14]%d\\n\", regno,\t\t\\\n-\t\t-((cnt-=8) + 8)-4-(SIZE));\t\t\t\t\\\n-    fprintf (FILE, \"\\tld.64\\t.sp,.r4\\n\\texit\\t0\\n\");\t\t\t\\\n-  } else {\t\t\t\t\t\t\t\t\\\n-    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\t\t\\\n-      if (regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n-         fprintf (FILE, \"\\tld.64\\t.r%d,[.sp]%d\\n\", regno, (cnt+=8)-12);\t\\\n-    fprintf (FILE, \"\\texit\\t%d\\n\", (SIZE)+cnt);\t\t\t\t\\\n-  } }\n-\n /* If the memory address ADDR is relative to the frame pointer,\n    correct it to be relative to the stack pointer instead.\n    This is for when we don't use a frame pointer."}, {"sha": "3086334b0c7512efdb6dd6098990709a7ddbbedc", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -204,7 +204,7 @@ fr30_compute_frame_size (from_reg, to_reg)\n \n /* Called after register allocation to add any instructions needed for the\n    prologue.  Using a prologue insn is favored compared to putting all of the\n-   instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n+   instructions in output_function_prologue(), since it allows the scheduler\n    to intermix instructions with the saves of the caller saved registers.  In\n    some cases, it might be necessary to emit a barrier instruction as the last\n    insn to prevent such scheduling.  */\n@@ -333,7 +333,7 @@ fr30_expand_prologue ()\n \n /* Called after register allocation to add any instructions needed for the\n    epilogue.  Using a epilogue insn is favored compared to putting all of the\n-   instructions in the FUNCTION_EPILOGUE macro, since it allows the scheduler\n+   instructions in output_function_epilogue(), since it allows the scheduler\n    to intermix instructions with the restores of the caller saved registers.\n    In some cases, it might be necessary to emit a barrier instruction as the\n    first insn to prevent such scheduling.  */"}, {"sha": "bf3ae73a66786b530e1660bc94ca5b29b6347941", "filename": "gcc/config/fr30/fr30.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Ffr30%2Ffr30.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Ffr30%2Ffr30.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.md?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1358,7 +1358,7 @@\n \n ;; Called after register allocation to add any instructions needed for the\n ;; prologue.  Using a prologue insn is favored compared to putting all of the\n-;; instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n+;; instructions in output_function_prologue(), since it allows the scheduler\n ;; to intermix instructions with the saves of the caller saved registers.  In\n ;; some cases, it might be necessary to emit a barrier instruction as the last\n ;; insn to prevent such scheduling.\n@@ -1373,7 +1373,7 @@\n \n ;; Called after register allocation to add any instructions needed for the\n ;; epilogue.  Using a epilogue insn is favored compared to putting all of the\n-;; instructions in the FUNCTION_EPILOGUE macro, since it allows the scheduler\n+;; instructions in output_function_epilogue(), since it allows the scheduler\n ;; to intermix instructions with the restores of the caller saved registers.\n ;; In some cases, it might be necessary to emit a barrier instruction as the\n ;; first insn to prevent such scheduling."}, {"sha": "9b0fa0297ecf2e85b79eacc38a79120311e92a67", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -68,8 +68,6 @@ extern void h8300_encode_label PARAMS ((tree));\n #endif /* TREE_CODE */\n \n extern void h8300_init_once PARAMS ((void));\n-extern void function_prologue PARAMS ((FILE *, int));\n-extern void function_epilogue PARAMS ((FILE *, int));\n extern void asm_file_start PARAMS ((FILE *));\n extern void asm_file_end PARAMS ((FILE *));\n extern int ok_for_bclr PARAMS ((HOST_WIDE_INT));"}, {"sha": "5fa079fda4159ae7e0eaa21963068fb2c7c83caf", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -54,6 +54,8 @@ static void push PARAMS ((FILE *, int));\n static void pop PARAMS ((FILE *, int));\n static const char *cond_string PARAMS ((enum rtx_code));\n static int h8300_valid_decl_attribute PARAMS ((tree, tree, tree, tree));\n+static void h8300_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void h8300_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \n /* CPU_TYPE, says what cpu we're compiling for.  */\n int cpu_type;\n@@ -98,6 +100,11 @@ const char *h8_push_op, *h8_pop_op, *h8_mov_op;\n #undef TARGET_VALID_DECL_ATTRIBUTE\n #define TARGET_VALID_DECL_ATTRIBUTE h8300_valid_decl_attribute\n \n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE h8300_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE h8300_output_function_epilogue\n+\n struct gcc_target target = TARGET_INITIALIZER;\n \f\n /* Initialize various cpu specific globals at start up.  */\n@@ -271,10 +278,10 @@ pop (file, rn)\n \n /* Output assembly language code for the function prologue.  */\n \n-void\n-function_prologue (file, size)\n+static void\n+h8300_output_function_prologue (file, size)\n      FILE *file;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n   int fsize = round_frame_size (size);\n   int idx;\n@@ -382,10 +389,10 @@ function_prologue (file, size)\n \n /* Output assembly language code for the function epilogue.  */\n \n-void\n-function_epilogue (file, size)\n+static void\n+h8300_output_function_epilogue (file, size)\n      FILE *file;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n   int fsize = round_frame_size (size);\n   int idx;"}, {"sha": "1df7c08a65e13fe7e6a14c9b58d36934fbfdc5a0", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -664,11 +664,6 @@ struct cum_arg\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (&CUM, MODE, TYPE, NAMED)\n \n-/* Generate assembly output for the start of a function.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n-  function_prologue (FILE, SIZE)\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -710,14 +705,6 @@ struct cum_arg\n \n #define EXIT_IGNORE_STACK 0\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-  function_epilogue (FILE, SIZE)\n-\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.  \n "}, {"sha": "8ca7ca640853ebab1f775d1c786ba7ec02bb40c6", "filename": "gcc/config/i370/i370-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi370%2Fi370-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi370%2Fi370-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -46,7 +46,6 @@ extern void mvs_add_alias PARAMS ((const char *, const char *, int));\n extern int mvs_need_alias PARAMS ((const char *));\n extern int mvs_get_alias PARAMS ((const char *, char *));\n extern int mvs_check_alias PARAMS ((const char *, char *));\n-extern void i370_function_prolog PARAMS ((FILE *, int));\n extern void check_label_emit PARAMS ((void));\n extern void mvs_free_label_list PARAMS ((void));\n "}, {"sha": "43b5929805c0e6985c8a4e6cf8e63e4ed38005e9", "filename": "gcc/config/i370/i370.c", "status": "modified", "additions": 64, "deletions": 6, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -100,6 +100,8 @@ static FILE *assembler_source = 0;\n \n static label_node_t * mvs_get_label PARAMS ((int));\n static void i370_label_scan PARAMS ((void));\n+static void i370_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void i370_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \n /* ===================================================== */\n /* defines and functions specific to the HLASM assembler */\n@@ -287,6 +289,10 @@ static const unsigned char ebcasc[256] =\n };\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE i370_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE i370_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -1195,13 +1201,21 @@ unsigned_jump_follows_p (insn)\n     }\n }\n \n+/* Generate the assembly code for function entry.  FILE is a stdio\n+   stream to output the code to.  SIZE is an int: how many units of\n+   temporary storage to allocate.\n+\n+   Refer to the array `regs_ever_live' to determine which registers to\n+   save; `regs_ever_live[I]' is nonzero if register number I is ever\n+   used in the function.  This function is responsible for knowing\n+   which registers should not be saved even if used.  */\n \n #ifdef TARGET_HLASM\n \n-void\n-i370_function_prolog (f, l)\n+static void\n+i370_output_function_prologue (f, l)\n      FILE *f;\n-     int l;\n+     HOST_WIDE_INT l;\n {\n #if MACROPROLOGUE == 1\n   fprintf (f, \"* Function %s prologue\\n\", mvs_function_name);\n@@ -1388,10 +1402,10 @@ i370_function_prolog (f, l)\n    also, to quite using addresses 136, 140, etc.\n  */\n \n-void\n-i370_function_prolog (f, frame_size)\n+static void\n+i370_output_function_prologue (f, frame_size)\n      FILE *f;\n-     int frame_size;\n+     HOST_WIDE_INT frame_size;\n {\n   static int function_label_index = 1;\n   static int function_first = 0;\n@@ -1461,3 +1475,47 @@ i370_function_prolog (f, frame_size)\n   i370_label_scan ();\n }\n #endif /* TARGET_ELF_ABI */\n+\n+/* This function generates the assembly code for function exit.\n+   Args are as for output_function_prologue ().\n+\n+   The function epilogue should not depend on the current stack\n+   pointer!  It should use the frame pointer only.  This is mandatory\n+   because of alloca; we also take advantage of it to omit stack\n+   adjustments before returning. */\n+\n+static void\n+i370_output_function_epilogue (file, l)\n+     FILE *file;\n+     HOST_WIDE_INT l ATTRIBUTE_UNUSED;\n+{\n+  int i;\n+\n+  check_label_emit ();\n+  mvs_check_page (file, 14, 0);\n+  fprintf (file, \"* Function %s epilogue\\n\", mvs_function_name);\n+  mvs_page_num++;\n+\n+#if MACROEPILOGUE == 1\n+  fprintf (file, \"\\tEDCEPIL\\n\");\n+#else /* MACROEPILOGUE != 1 */\n+  fprintf (file, \"\\tL\\t13,4(,13)\\n\");\n+  fprintf (file, \"\\tL\\t14,12(,13)\\n\");\n+  fprintf (file, \"\\tLM\\t2,12,28(13)\\n\");\n+  fprintf (file, \"\\tBALR\\t1,14\\n\");\n+  fprintf (file, \"\\tDC\\tA(\");\n+  assemble_name (file, mvs_function_name);\n+  fprintf (file, \")\\n\" );\n+#endif /* MACROEPILOGUE */\n+\n+  fprintf (file, \"* Function %s literal pool\\n\", mvs_function_name);\n+  fprintf (file, \"\\tDS\\t0F\\n\" );\n+  fprintf (file, \"\\tLTORG\\n\");\n+  fprintf (file, \"* Function %s page table\\n\", mvs_function_name);\n+  fprintf (file, \"\\tDS\\t0F\\n\");\n+  fprintf (file, \"PGT%d\\tEQU\\t*\\n\", function_base_page);\n+\n+  mvs_free_label_list();\n+  for (i = function_base_page; i < mvs_page_num; i++)\n+    fprintf (file, \"\\tDC\\tA(PG%d)\\n\", i);\n+}"}, {"sha": "fa187f33afdcc949e58ea6b5cc5fd3cf5e6379bb", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1590,10 +1590,6 @@ enum reg_class\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n-/* This macro generates the assembly code for function entry.\n-   All of the C/370 environment is preserved.  */\n-#define FUNCTION_PROLOGUE(FILE, LSIZE) i370_function_prolog ((FILE), (LSIZE));\n-\n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (strlen (NAME) + 1 > mvs_function_name_length)\t\t\t\\\n@@ -1618,62 +1614,6 @@ enum reg_class\n   fputs (\"\\tCSECT\\n\", FILE);\t\t\t\t\t\t\\\n }\n \n-/* This macro generates the assembly code for function exit, on machines\n-   that need it.  If FUNCTION_EPILOGUE is not defined then individual\n-   return instructions are generated for each return statement.  Args are\n-   same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#if MACROEPILOGUE == 1\n-#define FUNCTION_EPILOGUE(FILE, LSIZE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  int i;\t\t\t\t\t\t\t\t\\\n-  check_label_emit();\t\t\t\t\t\t\t\\\n-  mvs_check_page (FILE,14,0);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"* Function %s epilogue\\n\", mvs_function_name);\t\\\n-  fprintf (FILE, \"\\tEDCEPIL\\n\");\t\t\t\t\t\\\n-  mvs_page_num++;\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"* Function %s literal pool\\n\", mvs_function_name);\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\" );\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tLTORG\\n\");\t\t\t\t\t\t\\\n-  fprintf (FILE, \"* Function %s page table\\n\", mvs_function_name);\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n-  fprintf (FILE, \"PGT%d\\tEQU\\t*\\n\", function_base_page);\t\t\\\n-  mvs_free_label_list();\t\t\t\t\t\t\\\n-  for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\t\\\n-    fprintf (FILE, \"\\tDC\\tA(PG%d)\\n\", i);\t\t\t\t\\\n-}\n-#else /* MACROEPILOGUE != 1 */\n-#define FUNCTION_EPILOGUE(FILE, LSIZE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  int i;\t\t\t\t\t\t\t\t\\\n-  check_label_emit();\t\t\t\t\t\t\t\\\n-  mvs_check_page (FILE,14,0);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"* Function %s epilogue\\n\", mvs_function_name);\t\\\n-  fprintf (FILE, \"\\tL\\t13,4(,13)\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tL\\t14,12(,13)\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tLM\\t2,12,28(13)\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\tBALR\\t1,14\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDC\\tA(\");\t\t\t\t\t\t\\\n-  mvs_page_num++;\t\t\t\t\t\t\t\\\n-  assemble_name (FILE, mvs_function_name);\t\t\t\t\\\n-  fprintf (FILE, \")\\n\" );\t\t\t\t\t\t\\\n-  fprintf (FILE, \"* Function %s literal pool\\n\", mvs_function_name);\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\" );\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tLTORG\\n\");\t\t\t\t\t\t\\\n-  fprintf (FILE, \"* Function %s page table\\n\", mvs_function_name);\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n-  fprintf (FILE, \"PGT%d\\tEQU\\t*\\n\", function_base_page);\t\t\\\n-  mvs_free_label_list();\t\t\t\t\t\t\\\n-  for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\t\\\n-    fprintf (FILE, \"\\tDC\\tA(PG%d)\\n\", i);\t\t\t\t\\\n-}\n-#endif /* MACROEPILOGUE */\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -1951,40 +1891,6 @@ abort(); \\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n-/* This macro generates the assembly code for function exit, on machines\n-   that need it.  If FUNCTION_EPILOGUE is not defined then individual\n-   return instructions are generated for each return statement.  Args are\n-   same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, LSIZE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  int i;\t\t\t\t\t\t\t\t\\\n-  check_label_emit();\t\t\t\t\t\t\t\\\n-  mvs_check_page (FILE,14,0);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"# Function epilogue\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\tL\\tsp,4(0,sp)\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tL\\tlr,12(0,sp)\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tLM\\t2,12,28(sp)\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\tBASR\\t1,lr\\n\");\t\t\t\t\t\\\n-  mvs_page_num++;\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"# Function literal pool\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\t.balign\\t4\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.ltorg\\n\");\t\t\t\t\t\t\\\n-  fprintf (FILE, \"# Function page table\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\t.balign\\t4\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \".LPGT%d:\\n\", function_base_page);\t\t\t\\\n-  mvs_free_label_list();\t\t\t\t\t\t\\\n-  for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\t\\\n-    fprintf (FILE, \"\\t.long\\t.LPG%d\\n\", i);\t\t\t\t\\\n-}\n-\n-#define FUNCTION_PROLOGUE(FILE, LSIZE) i370_function_prolog ((FILE), (LSIZE));\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n /* Make it a no-op for now, so we can at least compile glibc */"}, {"sha": "bb337a2537cf49f4875637d1f83c75ca6f1267b2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -624,6 +624,13 @@ static int ix86_comp_type_attributes PARAMS ((tree, tree));\n #undef TARGET_COMP_TYPE_ATTRIBUTES\n #define TARGET_COMP_TYPE_ATTRIBUTES ix86_comp_type_attributes\n \n+#if defined (OSF_OS) || defined (TARGET_OSF1ELF)\n+   static void ix86_osf_output_function_prologue PARAMS ((FILE *,\n+\t\t\t\t\t\t\t  HOST_WIDE_INT));\n+#  undef TARGET_ASM_FUNCTION_PROLOGUE\n+#  define TARGET_ASM_FUNCTION_PROLOGUE ix86_osf_output_function_prologue\n+#endif\n+\n struct gcc_target target = TARGET_INITIALIZER;\n \f\n /* Sometimes certain combinations of command options do not make\n@@ -931,6 +938,105 @@ ix86_valid_type_attribute_p (type, attributes, identifier, args)\n   return 0;\n }\n \n+#if defined (OSF_OS) || defined (TARGET_OSF1ELF)\n+\n+/* Generate the assembly code for function entry.  FILE is a stdio\n+   stream to output the code to.  SIZE is an int: how many units of\n+   temporary storage to allocate.\n+\n+   Refer to the array `regs_ever_live' to determine which registers to\n+   save; `regs_ever_live[I]' is nonzero if register number I is ever\n+   used in the function.  This function is responsible for knowing\n+   which registers should not be saved even if used.\n+\n+   We override it here to allow for the new profiling code to go before\n+   the prologue and the old mcount code to go after the prologue (and\n+   after %ebx has been set up for ELF shared library support).  */\n+\n+static void\n+ix86_osf_output_function_prologue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size;\n+{\n+  char *prefix = \"\";\n+  char *lprefix = LPREFIX;\n+  int labelno = profile_label_no;\n+\n+#ifdef OSF_OS\n+\n+  if (TARGET_UNDERSCORES)\n+    prefix = \"_\";\n+\n+  if (profile_flag && OSF_PROFILE_BEFORE_PROLOGUE)\n+    {\n+      if (!flag_pic && !HALF_PIC_P ())\n+\t{\n+\t  fprintf (file, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\n+\t  fprintf (file, \"\\tcall *%s_mcount_ptr\\n\", prefix);\n+\t}\n+\n+      else if (HALF_PIC_P ())\n+\t{\n+\t  rtx symref;\n+\n+\t  HALF_PIC_EXTERNAL (\"_mcount_ptr\");\n+\t  symref = HALF_PIC_PTR (gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t\t     \"_mcount_ptr\"));\n+\n+\t  fprintf (file, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\n+\t  fprintf (file, \"\\tmovl %s%s,%%eax\\n\", prefix,\n+\t\t   XSTR (symref, 0));\n+\t  fprintf (file, \"\\tcall *(%%eax)\\n\");\n+\t}\n+\n+      else\n+\t{\n+\t  static int call_no = 0;\n+\n+\t  fprintf (file, \"\\tcall %sPc%d\\n\", lprefix, call_no);\n+\t  fprintf (file, \"%sPc%d:\\tpopl %%eax\\n\", lprefix, call_no);\n+\t  fprintf (file, \"\\taddl $_GLOBAL_OFFSET_TABLE_+[.-%sPc%d],%%eax\\n\",\n+\t\t   lprefix, call_no++);\n+\t  fprintf (file, \"\\tleal %sP%d@GOTOFF(%%eax),%%edx\\n\",\n+\t\t   lprefix, labelno);\n+\t  fprintf (file, \"\\tmovl %s_mcount_ptr@GOT(%%eax),%%eax\\n\",\n+\t\t   prefix);\n+\t  fprintf (file, \"\\tcall *(%%eax)\\n\");\n+\t}\n+    }\n+\n+#else  /* !OSF_OS */\n+\n+  if (profile_flag && OSF_PROFILE_BEFORE_PROLOGUE)\n+    {\n+      if (!flag_pic)\n+\t{\n+\t  fprintf (file, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\n+\t  fprintf (file, \"\\tcall *%s_mcount_ptr\\n\", prefix);\n+\t}\n+\n+      else\n+\t{\n+\t  static int call_no = 0;\n+\n+\t  fprintf (file, \"\\tcall %sPc%d\\n\", lprefix, call_no);\n+\t  fprintf (file, \"%sPc%d:\\tpopl %%eax\\n\", lprefix, call_no);\n+\t  fprintf (file, \"\\taddl $_GLOBAL_OFFSET_TABLE_+[.-%sPc%d],%%eax\\n\",\n+\t\t   lprefix, call_no++);\n+\t  fprintf (file, \"\\tleal %sP%d@GOTOFF(%%eax),%%edx\\n\",\n+\t\t   lprefix, labelno);\n+\t  fprintf (file, \"\\tmovl %s_mcount_ptr@GOT(%%eax),%%eax\\n\",\n+\t\t   prefix);\n+\t  fprintf (file, \"\\tcall *(%%eax)\\n\");\n+\t}\n+    }\n+#endif /* !OSF_OS */\n+\n+  function_prologue (file, size);\n+}\n+\n+#endif  /* OSF_OS || TARGET_OSF1ELF */\n+\n /* Return 0 if the attributes for two types are incompatible, 1 if they\n    are compatible, and 2 if they are nearly compatible (which causes a\n    warning to be generated).  */"}, {"sha": "4c5238990e94898477e0b74c3a1c00eac65bfb6a", "filename": "gcc/config/i386/osf1elf.h", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi386%2Fosf1elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi386%2Fosf1elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosf1elf.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -8,6 +8,8 @@\n #undef TARGET_VERSION\n #define TARGET_VERSION fprintf (stderr, \" (i386 OSF/1)\");\n \n+#define TARGET_OSF1ELF\n+\n /* WORD_SWITCH_TAKES_ARG defined in svr4 is not correct. We also\n  need an extra -soname */\n #undef WORD_SWITCH_TAKES_ARG\n@@ -133,41 +135,6 @@\n #else\n #define OSF_PROFILE_BEFORE_PROLOGUE 0\n #endif\n-#undef\tFUNCTION_PROLOGUE\n-#define FUNCTION_PROLOGUE(FILE, SIZE)\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    char *prefix = \"\";\t\t\t\\\n-    char *lprefix = LPREFIX;\t\t\t\t\t\t\\\n-    int labelno = profile_label_no;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (profile_flag && OSF_PROFILE_BEFORE_PROLOGUE)\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (!flag_pic)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\t\\\n-\t    fprintf (FILE, \"\\tcall *%s_mcount_ptr\\n\", prefix);\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    static int call_no = 0;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tcall %sPc%d\\n\", lprefix, call_no);\t\\\n-\t    fprintf (FILE, \"%sPc%d:\\tpopl %%eax\\n\", lprefix, call_no);\t\\\n-\t    fprintf (FILE, \"\\taddl $_GLOBAL_OFFSET_TABLE_+[.-%sPc%d],%%eax\\n\", \\\n-\t\t     lprefix, call_no++);\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%eax),%%edx\\n\",\t\\\n-\t\t     lprefix, labelno);\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tmovl %s_mcount_ptr@GOT(%%eax),%%eax\\n\",\t\\\n-\t\t     prefix);\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tcall *(%%eax)\\n\");\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    function_prologue (FILE, SIZE);\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n \n /* A C statement or compound statement to output to FILE some assembler code to\n    call the profiling subroutine `mcount'.  Before calling, the assembler code"}, {"sha": "7d74f7ac1bcef3dc85eb91e2e77682f7ece57c36", "filename": "gcc/config/i386/osfrose.h", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi386%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi386%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosfrose.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -183,18 +183,6 @@ Boston, MA 02111-1307, USA.  */\n #undef LONG_DOUBLE_TYPE_SIZE\n #define LONG_DOUBLE_TYPE_SIZE 64\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.\n-\n-   We override it here to allow for the new profiling code to go before\n-   the prologue and the old mcount code to go after the prologue (and\n-   after %ebx has been set up for ELF shared library support).  */\n-\n #define OSF_PROFILE_BEFORE_PROLOGUE\t\t\t\t\t\\\n   (!TARGET_MCOUNT\t\t\t\t\t\t\t\\\n    && !current_function_needs_context\t\t\t\t\t\\\n@@ -203,56 +191,6 @@ Boston, MA 02111-1307, USA.  */\n        || (!current_function_uses_pic_offset_table\t\t\t\\\n \t   && !current_function_uses_const_pool)))\n \n-#undef\tFUNCTION_PROLOGUE\n-#define FUNCTION_PROLOGUE(FILE, SIZE)\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    char *prefix = (TARGET_UNDERSCORES) ? \"_\" : \"\";\t\t\t\\\n-    char *lprefix = LPREFIX;\t\t\t\t\t\t\\\n-    int labelno = profile_label_no;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (profile_flag && OSF_PROFILE_BEFORE_PROLOGUE)\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (!flag_pic && !HALF_PIC_P ())\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\t\\\n-\t    fprintf (FILE, \"\\tcall *%s_mcount_ptr\\n\", prefix);\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\telse if (HALF_PIC_P ())\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    rtx symref;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t    HALF_PIC_EXTERNAL (\"_mcount_ptr\");\t\t\t\t\\\n-\t    symref = HALF_PIC_PTR (gen_rtx_SYMBOL_REF (Pmode,\t\t\\\n-\t\t\t\t\t\t       \"_mcount_ptr\"));\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\t\\\n-\t    fprintf (FILE, \"\\tmovl %s%s,%%eax\\n\", prefix,\t\t\\\n-\t\t     XSTR (symref, 0));\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tcall *(%%eax)\\n\");\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    static int call_no = 0;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tcall %sPc%d\\n\", lprefix, call_no);\t\\\n-\t    fprintf (FILE, \"%sPc%d:\\tpopl %%eax\\n\", lprefix, call_no);\t\\\n-\t    fprintf (FILE, \"\\taddl $_GLOBAL_OFFSET_TABLE_+[.-%sPc%d],%%eax\\n\", \\\n-\t\t     lprefix, call_no++);\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%eax),%%edx\\n\",\t\\\n-\t\t     lprefix, labelno);\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tmovl %s_mcount_ptr@GOT(%%eax),%%eax\\n\",\t\\\n-\t\t     prefix);\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tcall *(%%eax)\\n\");\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    function_prologue (FILE, SIZE);\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n /* A C statement or compound statement to output to FILE some assembler code to\n    call the profiling subroutine `mcount'.  Before calling, the assembler code\n    must load the address of a counter variable into a register where `mcount'"}, {"sha": "42cbe184fae31d48cb00f2d36f78f1ecb1ea40e2", "filename": "gcc/config/i860/i860-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi860%2Fi860-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi860%2Fi860-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -59,6 +59,3 @@ extern rtx i860_va_arg PARAMS ((tree, tree));\n #ifdef TREE_CODE\n extern tree i860_build_va_list PARAMS ((void));\n #endif /* TREE_CODE */\n-\n-extern void function_prologue PARAMS ((FILE *, unsigned));\n-extern void function_epilogue PARAMS ((FILE *, unsigned));"}, {"sha": "ae72157e77498362dc3307ce42f4ebd4ee645fb8", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -51,6 +51,8 @@ static const char *singlemove_string PARAMS ((rtx *));\n static const char *load_opcode PARAMS ((enum machine_mode, const char *, rtx));\n static const char *store_opcode PARAMS ((enum machine_mode, const char *, rtx));\n static void output_size_for_block_move PARAMS ((rtx, rtx, rtx));\n+static void i860_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void i860_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \n #ifndef I860_REG_PREFIX\n #define I860_REG_PREFIX \"\"\n@@ -63,6 +65,10 @@ const char *i860_reg_prefix = I860_REG_PREFIX;\n rtx i860_compare_op0, i860_compare_op1;\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE i860_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE i860_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -1557,7 +1563,6 @@ sfmode_constant_to_ulong (x)\n }\n \f\n /* This function generates the assembly code for function entry.\n-   The macro FUNCTION_PROLOGUE in i860.h is defined to call this function.\n \n    ASM_FILE is a stdio stream to output the code to.\n    SIZE is an int: how many units of temporary storage to allocate.\n@@ -1663,14 +1668,14 @@ char *current_function_original_name;\n static int must_preserve_r1;\n static unsigned must_preserve_bytes;\n \n-void\n-function_prologue (asm_file, local_bytes)\n+static void\n+i860_output_function_prologue (asm_file, local_bytes)\n      register FILE *asm_file;\n-     register unsigned local_bytes;\n+     register HOST_WIDE_INT local_bytes;\n {\n-  register unsigned frame_lower_bytes;\n-  register unsigned frame_upper_bytes;\n-  register unsigned total_fsize;\n+  register HOST_WIDE_INT frame_lower_bytes;\n+  register HOST_WIDE_INT frame_upper_bytes;\n+  register HOST_WIDE_INT total_fsize;\n   register unsigned preserved_reg_bytes = 0;\n   register unsigned i;\n   register unsigned preserved_so_far = 0;\n@@ -1929,7 +1934,6 @@ function_prologue (asm_file, local_bytes)\n }\n \f\n /* This function generates the assembly code for function exit.\n-   The macro FUNCTION_EPILOGUE in i860.h is defined to call this function.\n \n    ASM_FILE is a stdio stream to output the code to.\n    SIZE is an int: how many units of temporary storage to allocate.\n@@ -1985,14 +1989,14 @@ typedef struct TDESC {\n \tunsigned int negative_frame_size;\t/* same as frame_lower_bytes */\n } TDESC;\n \n-void\n-function_epilogue (asm_file, local_bytes)\n+static void\n+i860_output_function_epilogue (asm_file, local_bytes)\n      register FILE *asm_file;\n-     register unsigned local_bytes;\n+     register HOST_WIDE_INT local_bytes;\n {\n-  register unsigned frame_upper_bytes;\n-  register unsigned frame_lower_bytes;\n-  register unsigned preserved_reg_bytes = 0;\n+  register HOST_WIDE_INT frame_upper_bytes;\n+  register HOST_WIDE_INT frame_lower_bytes;\n+  register HOST_WIDE_INT preserved_reg_bytes = 0;\n   register unsigned i;\n   register unsigned restored_so_far = 0;\n   register unsigned int_restored;"}, {"sha": "1f681314374a5584ff5d7a1b0b0d8b6fef03bd39", "filename": "gcc/config/i860/i860.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -557,14 +557,6 @@ struct cumulative_args { int ints, floats; };\n       ? PARM_BOUNDARY\t\t\t\t\t\t\\\n       : GET_MODE_ALIGNMENT(MODE)))\n \n-/* This macro generates the assembly code for function entry.\n-\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-*/\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) function_prologue ((FILE), (SIZE))\n-\n /* Output a no-op just before the beginning of the function,\n    to ensure that there does not appear to be a delayed branch there.\n    Such a thing would confuse interrupt recovery.  */\n@@ -584,19 +576,6 @@ struct cumulative_args { int ints, floats; };\n \n #define EXIT_IGNORE_STACK 1\n \n-/* This macro generates the assembly code for function exit.\n-\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.\n-*/\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) function_epilogue ((FILE), (SIZE))\n-\n /* Generate necessary RTL for __builtin_saveregs().  */\n #define EXPAND_BUILTIN_SAVEREGS() \\\n   i860_saveregs()"}, {"sha": "483c15bb4173b176eb9d7b72f6629b1ae35c9efe", "filename": "gcc/config/i960/i960-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi960%2Fi960-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi960%2Fi960-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -101,9 +101,7 @@ extern int bitpos PARAMS ((unsigned int));\n extern int is_mask PARAMS ((unsigned int));\n extern int bitstr PARAMS ((unsigned int, int *, int *));\n extern int compute_frame_size PARAMS ((int));\n-extern void i960_function_prologue PARAMS ((FILE *, unsigned int));\n extern void output_function_profiler PARAMS ((FILE *, int));\n-extern void i960_function_epilogue PARAMS ((FILE *, unsigned int));\n extern void i960_scan_opcode PARAMS ((const char *));\n \n #ifdef GCC_C_PRAGMA_H"}, {"sha": "264f7ee439f6a346cb241eb93b1a1e4a6030bdc0", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -47,6 +47,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"target-def.h\"\n \n+static void i960_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void i960_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+\n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n \n@@ -90,6 +93,10 @@ static int ret_label = 0;\n  || current_function_varargs)\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE i960_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE i960_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -1261,16 +1268,16 @@ i960_split_reg_group (reg_groups, nw, subgroup_length)\n \n /* Output code for the function prologue.  */\n \n-void\n-i960_function_prologue (file, size)\n+static void\n+i960_output_function_prologue (file, size)\n      FILE *file;\n-     unsigned int size;\n+     HOST_WIDE_INT size;\n {\n   register int i, j, nr;\n   int n_saved_regs = 0;\n   int n_remaining_saved_regs;\n-  int lvar_size;\n-  int actual_fsize, offset;\n+  HOST_WIDE_INT lvar_size;\n+  HOST_WIDE_INT actual_fsize, offset;\n   int gnw, lnw;\n   struct reg_group *g, *l;\n   char tmpstr[1000];\n@@ -1539,10 +1546,10 @@ output_function_profiler (file, labelno)\n \n /* Output code for the function epilogue.  */\n \n-void\n-i960_function_epilogue (file, size)\n+static void\n+i960_output_function_epilogue (file, size)\n      FILE *file;\n-     unsigned int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   if (i960_leaf_ret_reg >= 0)\n     {"}, {"sha": "3a11007a04e5b16b3064bddc5008be3b43bb9024", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -997,16 +997,6 @@ struct cum_args { int ca_nregparms; int ca_nstackparms; };\n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n   i960_function_name_declare (FILE, NAME, DECL)\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) i960_function_prologue ((FILE), (SIZE))\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -1019,18 +1009,6 @@ struct cum_args { int ca_nregparms; int ca_nstackparms; };\n    No definition is equivalent to always zero.  */\n \n #define\tEXIT_IGNORE_STACK 1\n-\n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) i960_function_epilogue (FILE, SIZE)\n \f\n /* Addressing modes, and classification of registers for them.  */\n "}, {"sha": "1bdfbc4cee1a048ecc8c23a91c4b3143c7a1ecaa", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -77,8 +77,6 @@ extern void ia64_expand_call PARAMS((rtx, rtx, rtx, int));\n extern HOST_WIDE_INT ia64_initial_elimination_offset PARAMS((int, int));\n extern void ia64_expand_prologue PARAMS((void));\n extern void ia64_expand_epilogue PARAMS((int));\n-extern void ia64_function_prologue PARAMS((FILE *, int));\n-extern void ia64_function_epilogue PARAMS((FILE *, int));\n \n extern int ia64_direct_return PARAMS((void));\n extern void ia64_expand_load_address PARAMS((rtx, rtx, rtx));"}, {"sha": "296306b1f82000a462ac9b40d600cbe67b67ec73", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -137,11 +137,18 @@ static rtx ia64_expand_lock_test_and_set PARAMS ((enum machine_mode,\n \t\t\t\t\t\t  tree, rtx));\n static rtx ia64_expand_lock_release PARAMS ((enum machine_mode, tree, rtx));\n static int ia64_valid_type_attribute PARAMS((tree, tree, tree, tree));\n+static void ia64_function_prologue PARAMS((FILE *, HOST_WIDE_INT));\n+static void ia64_function_epilogue PARAMS((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_VALID_TYPE_ATTRIBUTE\n #define TARGET_VALID_TYPE_ATTRIBUTE ia64_valid_type_attribute\n \n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE ia64_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE ia64_output_function_epilogue\n+\n struct gcc_target target = TARGET_INITIALIZER;\n \f\n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n@@ -1830,7 +1837,7 @@ gen_fr_restore_x (dest, src, offset)\n \n /* Called after register allocation to add any instructions needed for the\n    prologue.  Using a prologue insn is favored compared to putting all of the\n-   instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n+   instructions in output_function_prologue(), since it allows the scheduler\n    to intermix instructions with the saves of the caller saved registers.  In\n    some cases, it might be necessary to emit a barrier instruction as the last\n    insn to prevent such scheduling.\n@@ -2188,7 +2195,7 @@ ia64_expand_prologue ()\n \n /* Called after register allocation to add any instructions needed for the\n    epilogue.  Using a epilogue insn is favored compared to putting all of the\n-   instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n+   instructions in output_function_prologue(), since it allows the scheduler\n    to intermix instructions with the saves of the caller saved registers.  In\n    some cases, it might be necessary to emit a barrier instruction as the last\n    insn to prevent such scheduling.  */\n@@ -2496,10 +2503,10 @@ ia64_hard_regno_rename_ok (from, to)\n \n /* Emit the function prologue.  */\n \n-void\n-ia64_function_prologue (file, size)\n+static void\n+ia64_output_function_prologue (file, size)\n      FILE *file;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   int mask, grsave, grsave_prev;\n \n@@ -2577,10 +2584,10 @@ ia64_output_end_prologue (file)\n \n /* Emit the function epilogue.  */\n \n-void\n-ia64_function_epilogue (file, size)\n+static void\n+ia64_output_function_epilogue (file, size)\n      FILE *file ATTRIBUTE_UNUSED;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   int i;\n "}, {"sha": "05b8f9eba21f22d8d029933fc4e5a22c3d42105f", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1458,12 +1458,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* Function Entry and Exit */\n \n-/* A C compound statement that outputs the assembler code for entry to a\n-   function.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n-  ia64_function_prologue (FILE, SIZE)\n-\n /* This macro notes the end of the prologue.  */\n \n #define FUNCTION_END_PROLOGUE(FILE)  ia64_output_end_prologue (FILE)\n@@ -1480,12 +1474,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define EPILOGUE_USES(REGNO) ia64_epilogue_uses (REGNO)\n \n-/* A C compound statement that outputs the assembler code for exit from a\n-   function.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-  ia64_function_epilogue (FILE, SIZE)\n-\n /* Output at beginning of assembler file.  */\n \n #define ASM_FILE_START(FILE) \\"}, {"sha": "f0a1a5bed0ab9dbc8856bd6055c1758c500cbef8", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -29,8 +29,6 @@ extern void   m32r_init_expanders\t\tPARAMS ((void));\n extern unsigned m32r_compute_frame_size\t\tPARAMS ((int));\n extern int    m32r_first_insn_address\t\tPARAMS ((void));\n extern void   m32r_expand_prologue\t\tPARAMS ((void));\n-extern void   m32r_output_function_prologue\tPARAMS ((FILE *, int));\n-extern void   m32r_output_function_epilogue\tPARAMS ((FILE *, int));\n extern void   m32r_finalize_pic\t\t\tPARAMS ((void));\n extern void   m32r_asm_file_start\t\tPARAMS ((FILE *));\n extern void   m32r_sched_init \t\t\tPARAMS ((FILE *, int));"}, {"sha": "12dad0d31717fd501f9410e72462b6505588cfa3", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -64,11 +64,18 @@ static void  block_move_call\t\t\tPARAMS ((rtx, rtx, rtx));\n static int   m32r_is_insn\t\t\tPARAMS ((rtx));\n static int   m32r_valid_decl_attribute\t\tPARAMS ((tree, tree,\n \t\t\t\t\t\t\t tree, tree));\n+static void  m32r_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void  m32r_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_VALID_DECL_ATTRIBUTE\n #define TARGET_VALID_DECL_ATTRIBUTE m32r_valid_decl_attribute\n \n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE m32r_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE m32r_output_function_epilogue\n+\n struct gcc_target target = TARGET_INITIALIZER;\n \f\n /* Called by OVERRIDE_OPTIONS to initialize various things.  */\n@@ -1962,10 +1969,10 @@ m32r_expand_prologue ()\n    Note, if this is changed, you need to mirror the changes in\n    m32r_compute_frame_size which calculates the prolog size.  */\n \n-void\n+static void\n m32r_output_function_prologue (file, size)\n      FILE * file;\n-     int    size;\n+     HOST_WIDE_INT size;\n {\n   enum m32r_function_type fn_type = m32r_compute_function_type (current_function_decl);\n \n@@ -1992,10 +1999,10 @@ m32r_output_function_prologue (file, size)\n /* Do any necessary cleanup after a function to restore stack, frame,\n    and regs. */\n \n-void\n+static void\n m32r_output_function_epilogue (file, size)\n      FILE * file;\n-     int    size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   int regno;\n   int noepilogue = FALSE;"}, {"sha": "69efdb7d50c41f9f9fab5897d85be9e54d4540b7", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1190,34 +1190,12 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n    init_emit, once for each function, before code is generated.  */\n #define INIT_EXPANDERS m32r_init_expanders ()\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n-m32r_output_function_prologue (FILE, SIZE)\n-\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers.\n    No definition is equivalent to always zero.  */\n #define EXIT_IGNORE_STACK 1\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-m32r_output_function_epilogue (FILE, SIZE)\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n #define FUNCTION_PROFILER(FILE, LABELNO) abort ()"}, {"sha": "af265e889205b1a50579a2927e737e5d4c13c296", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -30,8 +30,6 @@ extern int m68hc11_initial_elimination_offset PARAMS((int, int));\n \n extern void expand_prologue PARAMS((void));\n extern void expand_epilogue PARAMS((void));\n-extern void output_function_prologue PARAMS((FILE*, int));\n-extern void output_function_epilogue PARAMS((FILE*, int));\n extern int m68hc11_function_block_profiler PARAMS((FILE*,int));\n \n extern int m68hc11_block_profiler PARAMS((FILE*,int));"}, {"sha": "a05eae51843965473b963189da48a88635080569", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -70,8 +70,10 @@ static int m68hc11_valid_type_attribute_p PARAMS((tree, tree,\n \t\t\t\t\t\t  tree, tree));\n \n void create_regs_rtx PARAMS ((void));\n+static void m68hc11_add_gc_roots PARAMS ((void));\n \n static void asm_print_register PARAMS ((FILE *, int));\n+static void m68hc11_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \n rtx m68hc11_soft_tmp_reg;\n \n@@ -202,14 +204,15 @@ const char *m68hc11_regparm_string;\n const char *m68hc11_reg_alloc_order;\n const char *m68hc11_soft_reg_count;\n \n-static void m68hc11_add_gc_roots PARAMS ((void));\n-\n static int nb_soft_regs;\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_VALID_TYPE_ATTRIBUTE\n #define TARGET_VALID_TYPE_ATTRIBUTE m68hc11_valid_type_attribute_p\n \n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE m68hc11_output_function_epilogue\n+\n struct gcc_target target = TARGET_INITIALIZER;\n \f\n int\n@@ -1529,10 +1532,10 @@ m68hc11_total_frame_size ()\n   return size;\n }\n \n-void\n-m68hc11_function_epilogue (out, size)\n+static void\n+m68hc11_output_function_epilogue (out, size)\n      FILE *out ATTRIBUTE_UNUSED;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   /* We catch the function epilogue generation to have a chance\n      to clear the z_replacement_completed flag.  */"}, {"sha": "5f5982638a3e77f5a52622f4272f4042c7e1adff", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1092,8 +1092,6 @@ typedef struct m68hc11_args\n #define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n   m68hc11_va_arg (valist, type)\n \n-#define FUNCTION_EPILOGUE(FILE, SIZE)\tm68hc11_function_epilogue(FILE, SIZE)\n-\n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero."}, {"sha": "b2442d48770349ae46abb4f4fa6db085d8e44407", "filename": "gcc/config/m68k/crds.h", "status": "modified", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68k%2Fcrds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68k%2Fcrds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fcrds.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -459,160 +459,8 @@ do {  int i;\t\t\t\t\t\t\t\t\\\n \t   (sdb_begin_function_line\t\t\\\n \t    ? last_linenum - sdb_begin_function_line : 1))\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-/* Note that the order of the bit mask for fmovem is the opposite\n-   of the order for movem!  */\n-\n-#undef FUNCTION_PROLOGUE\n-#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n-{ register int regno;\t\t\t\t\t\t\\\n-  register int mask = 0;\t\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n-  /* unos stack probe */\t\t\t\t\t\\\n-  if ( fsize > 30000 ) {\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tmovel sp,a0\\n\");\t\t\t\t\\\n-    fprintf (FILE, \"\\taddl $-%d,a0\\n\", 2048 + fsize);\t\t\\\n-    fprintf (FILE, \"\\ttstb (a0)\\n\");\t\t\t\t\\\n-  } else {\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\ttstb -%d(sp)\\n\", 2048 + fsize);\t\t\\\n-  }\t\t\t\t\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    { if (TARGET_68020 || fsize < 0x8000)\t\t\t\\\n-        fprintf (FILE, \"\\tlink a6,$%d\\n\", -fsize);\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tlink a6,$0\\n\\tsubl $%d,sp\\n\", fsize); }  \\\n-  else if (fsize)\t\t\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t      \\\n-      /* Adding negative number is faster on the 68040.  */\t      \\\n-      if (fsize + 4 < 0x8000)\t\t\t\t\t      \\\n-\t{\t\t\t\t\t\t\t      \\\n-\t  fprintf (FILE, \"\\tadd.w #%d,sp\\n\", - (fsize + 4));\t      \\\n-\t}\t\t\t\t\t\t\t      \\\n-      else\t\t\t\t\t\t\t      \\\n-\t{\t\t\t\t\t\t\t      \\\n-\t  fprintf (FILE, \"\\tadd.l #%d,sp\\n\", - (fsize + 4));          \\\n-\t}\t\t\t\t\t\t\t      \\\n-    }\t\t\t\t\t\t\t\t      \\\n-  for (regno = 16; regno < 24; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-       mask |= 1 << (regno - 16);\t\t\t\t\\\n-  if ((mask & 0xff) != 0)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tfmovem $0x%x,-(sp)\\n\", mask & 0xff);       \\\n-  mask = 0;\t\t\t\t\t\t\t\\\n-  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-       mask |= 1 << (15 - regno);\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    mask &= ~ (1 << (15-FRAME_POINTER_REGNUM));\t\t\t\\\n-  if (exact_log2 (mask) >= 0)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tmovel %s,-(sp)\\n\", reg_names[15 - exact_log2 (mask)]);  \\\n-  else if (mask) fprintf (FILE, \"\\tmovem $0x%x,-(sp)\\n\", mask); }\n-\n /* Must put address in  %a0 , not  %d0 . -- LGM, 7/15/88 */\n /* UNOS ?? */\n #undef FUNCTION_PROFILER\n #define FUNCTION_PROFILER(FILE, LABEL_NO)\t\\\n     fprintf (FILE, \"\\tmovl &LP%%%d,%%a0\\n\\tjsr mcount\\n\", (LABEL_NO))\n-\n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#undef FUNCTION_EPILOGUE\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-{ register int regno;\t\t\t\t\t\t\\\n-  register int mask, fmask;\t\t\t\t\t\\\n-  register int nregs;\t\t\t\t\t\t\\\n-  int offset, foffset, fpoffset;\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n-  int big = 0;\t\t\t\t\t\t\t\\\n-  nregs = 0;  fmask = 0; fpoffset = 0;\t\t\t\t\\\n-  for (regno = 16; regno < 24; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      { nregs++; fmask |= 1 << (23 - regno); }\t\t\t\\\n-  foffset = fpoffset + nregs * 12;\t\t\t\t\\\n-  nregs = 0;  mask = 0;\t\t\t\t\t\t\\\n-  if (frame_pointer_needed) regs_ever_live[FRAME_POINTER_REGNUM] = 0; \\\n-  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      { nregs++; mask |= 1 << regno; }\t\t\t\t\\\n-  offset = foffset + nregs * 4;\t\t\t\t\t\\\n-  if (offset + fsize >= 0x8000 \t\t\t\t\t\\\n-      && frame_pointer_needed \t\t\t\t\t\\\n-      && (mask || fmask || fpoffset)) \t\t\t\t\\\n-    { fprintf (FILE, \"\\tmovel $%d,a0\\n\", -fsize);\t\t\\\n-      fsize = 0, big = 1; }\t\t\t\t\t\\\n-  if (exact_log2 (mask) >= 0) {\t\t\t\t\t\\\n-    if (big)\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovel -%d(a6,a0.l),%s\\n\",\t\t\\\n-\t       offset + fsize, reg_names[exact_log2 (mask)]);\t\\\n-    else if (! frame_pointer_needed)\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovel (sp)+,%s\\n\",\t\t\t\\\n-\t       reg_names[exact_log2 (mask)]);\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovel -%d(a6),%s\\n\",\t\t\t\\\n-\t       offset + fsize, reg_names[exact_log2 (mask)]); }\t\\\n-  else if (mask) {\t\t\t\t\t\t\\\n-    if (big)\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovem -%d(a6,a0.l),$0x%x\\n\",\t\t\\\n-\t       offset + fsize, mask);\t\t\t\t\\\n-    else if (! frame_pointer_needed)\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovem (sp)+,$0x%x\\n\", mask);\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovem -%d(a6),$0x%x\\n\",\t\t\\\n-\t       offset + fsize, mask); }\t\t\t\t\\\n-  if (fmask) {\t\t\t\t\t\t\t\\\n-    if (big)\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tfmovem -%d(a6,a0.l),$0x%x\\n\",\t\t\\\n-\t       foffset + fsize, fmask);\t\t\t\t\\\n-    else if (! frame_pointer_needed)\t\t\t\t\\\n-      fprintf (FILE, \"\\tfmovem (sp)+,$0x%x\\n\", fmask);\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tfmovem -%d(a6),$0x%x\\n\",\t\t\\\n-\t       foffset + fsize, fmask); }\t\t\t\\\n-  if (fpoffset != 0)\t\t\t\t\t\t\\\n-    for (regno = 55; regno >= 24; regno--)\t\t\t\\\n-      if (regs_ever_live[regno] && ! call_used_regs[regno]) {\t\\\n-\tif (big)\t\t\t\t\t\t\\\n-\t  fprintf(FILE, \"\\tfpmoved -%d(a6,a0.l), %s\\n\",\t\\\n-\t\t  fpoffset + fsize, reg_names[regno]);\t\t\\\n-\telse if (! frame_pointer_needed)\t\t\t\\\n-\t  fprintf(FILE, \"\\tfpmoved (sp)+, %s\\n\",\t\t\t\\\n-\t\t  reg_names[regno]);\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\\\n-\t  fprintf(FILE, \"\\tfpmoved -%d(a6), %s\\n\",\t\t\\\n-\t\t  fpoffset + fsize, reg_names[regno]);\t\t\\\n-\tfpoffset -= 8;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tunlk a6\\n\");\t\t\t\t\\\n-  else if (fsize)                                                     \\\n-    {                                                                 \\\n-      if (fsize + 4 < 0x8000)                                         \\\n-\t{                                                             \\\n-\t  fprintf (FILE, \"\\tadd.w #%d,sp\\n\", fsize + 4);              \\\n-\t}                                                             \\\n-      else                                                            \\\n-\t{                                                             \\\n-\t  fprintf (FILE, \"\\tadd.l #%d,sp\\n\", fsize + 4);              \\\n-\t}                                                             \\\n-    }                                                                 \\\n-  if (current_function_pops_args)\t\t\t\t\\\n-    fprintf (FILE, \"\\trtd $%d\\n\", current_function_pops_args);\t\\\n-  else fprintf (FILE, \"\\trts\\n\"); }\n-"}, {"sha": "886a34b2f7ac75e81274ae1f36146f53d40f6d01", "filename": "gcc/config/m68k/dpx2.h", "status": "modified", "additions": 2, "deletions": 263, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fdpx2.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -31,6 +31,8 @@ Boston, MA 02111-1307, USA.  */\n #undef SELECT_RTX_SECTION\n #include \"svr3.h\"\n \n+#define DPX2\n+\n /* See m68k.h.  7 means 68020 with 68881.\n  * We really have 68030 and 68882,\n  * but this will get us going.  \n@@ -238,269 +240,6 @@ Boston, MA 02111-1307, USA.  */\n /* Output type in decimal not in octal as done in sdbout.c */\t\n #define PUT_SDB_TYPE(a) fprintf(asm_out_file, \"\\t.type\\t0%d%s\", a, SDB_DELIM)\n \t\t\n-#undef FUNCTION_PROLOGUE\n-#define FUNCTION_PROLOGUE(FILE, SIZE)                                 \\\n-{                                                                     \\\n-  register int regno;                                                 \\\n-  register int mask = 0;                                              \\\n-  int num_saved_regs = 0, first = 1;                                  \\\n-  extern char call_used_regs[];                                       \\\n-  int fsize = ((SIZE) + 3) & -4;                                      \\\n-                                                                      \\\n-                                                                      \\\n-  if (frame_pointer_needed)                                           \\\n-    {                                                                 \\\n-      /* Adding negative number is faster on the 68040.  */           \\\n-      if (fsize < 0x8000 && !TARGET_68040)                            \\\n-\t{                                                             \\\n-\t  fprintf (FILE, \"\\tlink %s,#%d\\n\", \t                      \\\n-\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);      \\\n-\t}                                                             \\\n-      else if (TARGET_68020)                                          \\\n-\t{                                                             \\\n-\t  fprintf (FILE, \"\\tlink %s,#%d\\n\",\t                      \\\n-\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);      \\\n-\t}                                                             \\\n-      else                                                            \\\n-\t{                                                             \\\n-\t  fprintf (FILE, \"\\tlink %s,#0\\n\\tadd.l #%d,sp\\n\",\t      \\\n-\t\t       reg_names[FRAME_POINTER_REGNUM], -fsize);      \\\n-\t}\t\t\t\t\t\t\t      \\\n-    }\t\t\t\t\t\t\t\t      \\\n-  else if (fsize)\t\t\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t      \\\n-      /* Adding negative number is faster on the 68040.  */\t      \\\n-      if (fsize + 4 < 0x8000)\t\t\t\t\t      \\\n-\t{\t\t\t\t\t\t\t      \\\n-\t  fprintf (FILE, \"\\tadd.w #%d,sp\\n\", - (fsize + 4));\t      \\\n-\t}\t\t\t\t\t\t\t      \\\n-      else\t\t\t\t\t\t\t      \\\n-\t{\t\t\t\t\t\t\t      \\\n-\t  fprintf (FILE, \"\\tadd.l #%d,sp\\n\", - (fsize + 4));          \\\n-\t}\t\t\t\t\t\t\t      \\\n-    }\t\t\t\t\t\t\t\t      \\\n-  for (regno = 23; regno >= 16; regno--)                              \\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])             \\\n-      if (first) {\t\t\t\t\t\t      \\\n-        fprintf (FILE, \"\\tfmovem.x %s\", reg_names[regno]);            \\\n-\tfirst = 0;\t\t\t\t\t\t      \\\n-       }\t\t\t\t\t\t\t      \\\n-      else fprintf (FILE, \"/%s\", reg_names[regno]);            \t      \\\n-  if (!first) fprintf (FILE, \",-(sp)\\n\");\t\t\t      \\\n-\t\t\t\t\t\t\t\t      \\\n-  mask = 0;\t\t\t\t\t\t\t      \\\n-  for (regno = 0; regno < 16; regno++)\t\t\t\t      \\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t      \\\n-      {\t\t\t\t\t\t\t\t      \\\n-        mask |= 1 << (15 - regno);\t\t\t\t      \\\n-        num_saved_regs++;                   \t\t\t      \\\n-      }                                                               \\\n-  if (frame_pointer_needed)                                           \\\n-    {                                                                 \\\n-      mask &= ~ (1 << (15 - FRAME_POINTER_REGNUM));                   \\\n-      num_saved_regs--;                                               \\\n-    }                                                                 \\\n-                                                                      \\\n-                                                                      \\\n-  if (num_saved_regs <= 2)                                            \\\n-    {                                                                 \\\n-      /* Store each separately in the same order moveml uses.         \\\n-         Using two movel instructions instead of a single moveml      \\\n-         is about 15% faster for the 68020 and 68030 at no expense    \\\n-         in code size */                                              \\\n-                                                                      \\\n-      int i;                                                          \\\n-                                                                      \\\n-      /* Undo the work from above. */                                 \\\n-      for (i = 0; i< 16; i++)                                         \\\n-        if (mask & (1 << i))                                          \\\n-          fprintf (FILE, \"\\tmove.l %s,-(sp)\\n\", reg_names[15 - i]);   \\\n-    }                                                                 \\\n-  else if (mask)                                                      \\\n-    {                                                                 \\\n-      first = 1;                                                      \\\n-      for (regno = 0; regno < 16; regno++)                            \\\n-        if (mask & (1 << regno))                                      \\\n-          if (first) {                                                \\\n-            fprintf (FILE, \"\\tmovem.l %s\", reg_names[15 - regno]);    \\\n-            first = 0;                                                \\\n-           }                                                          \\\n-          else fprintf (FILE, \"/%s\", reg_names[15 - regno]);\t      \\\n-      fprintf (FILE, \",-(sp)\\n\");\t           \t\t      \\\n-    }                                                                 \\\n-  if (flag_pic && current_function_uses_pic_offset_table)             \\\n-    {                                                                 \\\n-      fprintf (FILE, \"\\tmove.l #__GLOBAL_OFFSET_TABLE_, %s\\n\",        \\\n-\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM]);               \\\n-      fprintf (FILE, \"\\tlea.l (pc,%s.l),%s\\n\",                        \\\n-\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM],                \\\n-\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM]);               \\\n-    }                                                                 \\\n-}\n-\n-\n-#undef FUNCTION_EPILOGUE\n-#define FUNCTION_EPILOGUE(FILE, SIZE)                                 \\\n-{                                                                     \\\n-  register int regno;                                                 \\\n-  register int mask, fmask;                                           \\\n-  register int nregs;                                                 \\\n-  int offset, foffset, fpoffset, first = 1;\t\t              \\\n-  extern char call_used_regs[];                                       \\\n-  int fsize = ((SIZE) + 3) & -4;                                      \\\n-  int big = 0;                                                        \\\n-  rtx insn = get_last_insn ();                                        \\\n-                                                                      \\\n-  /* If the last insn was a BARRIER, we don't have to write any code.  */ \\\n-  if (GET_CODE (insn) == NOTE)                                        \\\n-    insn = prev_nonnote_insn (insn);                                  \\\n-  if (insn && GET_CODE (insn) == BARRIER)                             \\\n-    {                                                                 \\\n-      /* Output just a no-op so that debuggers don't get confused     \\\n-\t about which function the pc is in at this address.  */       \\\n-      fprintf (FILE, \"\\tnop\\n\");                                      \\\n-      return;                                                         \\\n-    }                                                                 \\\n-                                                                      \\\n-  nregs = 0;  fmask = 0; fpoffset = 0;                                \\\n-  for (regno = 16; regno < 24; regno++)                               \\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])             \\\n-      {                                                               \\\n-        nregs++;                                                      \\\n-\tfmask |= 1 << (23 - regno);                                   \\\n-      }                                                               \\\n-  foffset = fpoffset + nregs * 12;                                    \\\n-  nregs = 0;  mask = 0;                                               \\\n-  if (frame_pointer_needed)                                           \\\n-    regs_ever_live[FRAME_POINTER_REGNUM] = 0;                         \\\n-  for (regno = 0; regno < 16; regno++)                                \\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])             \\\n-      {                                                               \\\n-        nregs++;                                                      \\\n-\tmask |= 1 << regno;                                           \\\n-      }                                                               \\\n-  offset = foffset + nregs * 4;                                       \\\n-  if (offset + fsize >= 0x8000                                        \\\n-      && frame_pointer_needed                                         \\\n-      && (mask || fmask || fpoffset))                                 \\\n-    {                                                                 \\\n-      fprintf (FILE, \"\\tmove.l #%d,a0\\n\", -fsize);                    \\\n-      fsize = 0, big = 1;                                             \\\n-    }                                                                 \\\n-  if (nregs <= 2)                                                     \\\n-    {                                                                 \\\n-      /* Restore each separately in the same order moveml does.       \\\n-         Using two movel instructions instead of a single moveml      \\\n-         is about 15% faster for the 68020 and 68030 at no expense    \\\n-         in code size. */                                             \\\n-                                                                      \\\n-      int i;                                                          \\\n-                                                                      \\\n-      /* Undo the work from above. */                                 \\\n-      for (i = 0; i< 16; i++)                                         \\\n-        if (mask & (1 << i))                                          \\\n-          {                                                           \\\n-            if (big)                                                  \\\n-\t      {                                                       \\\n-\t\tfprintf (FILE, \"\\tmove.l -%d(%s,a0.l),%s\\n\",          \\\n-\t\t\t     offset + fsize,                          \\\n-\t\t\t     reg_names[FRAME_POINTER_REGNUM],         \\\n-\t\t\t     reg_names[i]);                           \\\n-\t      }                                                       \\\n-            else if (! frame_pointer_needed)                          \\\n-\t      {                                                       \\\n-\t\tfprintf (FILE, \"\\tmove.l (sp)+,%s\\n\",                 \\\n-\t\t\t     reg_names[i]);                           \\\n-\t      }                                                       \\\n-            else                                                      \\\n-\t      {                                                       \\\n-\t\tfprintf (FILE, \"\\tmove.l -%d(%s),%s\\n\",               \\\n-\t\t\t     offset + fsize,                          \\\n-\t\t\t     reg_names[FRAME_POINTER_REGNUM],         \\\n-\t\t\t     reg_names[i]);                           \\\n-\t      }                                                       \\\n-            offset = offset - 4;                                      \\\n-          }                                                           \\\n-    }                                                                 \\\n-  else if (mask)                                                      \\\n-    {                                                                 \\\n-      first = 1;\t\t\t\t\t\t      \\\n-      for (regno = 0; regno < 16; regno++)                            \\\n-        if (mask & (1 << regno))                                      \\\n-          if (first && big) {                                         \\\n-            fprintf (FILE, \"\\tmovem.l -%d(%s,a0.l),%s\",               \\\n-\t\t     offset + fsize,                                  \\\n-\t\t     reg_names[FRAME_POINTER_REGNUM],                 \\\n-\t\t     reg_names[regno]);                               \\\n-            first = 0;                                                \\\n-           }                                                          \\\n-          else if (first && ! frame_pointer_needed) {                 \\\n-            fprintf (FILE, \"\\tmovem.l (sp)+,%s\",                      \\\n-\t\t     offset + fsize,                                  \\\n-\t\t     reg_names[FRAME_POINTER_REGNUM],                 \\\n-\t\t     reg_names[regno]);                               \\\n-            first = 0;                                                \\\n-           }                                                          \\\n-          else if (first) {   \t\t\t\t              \\\n-            fprintf (FILE, \"\\tmovem.l -%d(%s),%s\",                    \\\n-\t\t     offset + fsize,                                  \\\n-\t\t     reg_names[FRAME_POINTER_REGNUM],                 \\\n-\t\t     reg_names[regno]);                               \\\n-            first = 0;                                                \\\n-           }                                                          \\\n-          else  \t\t\t\t\t\t      \\\n-\t    fprintf (FILE, \"/%s\", reg_names[regno]);\t              \\\n-      fprintf (FILE, \"\\n\");\t                 \t\t      \\\n-    }                                                                 \\\n-  if (fmask)                                                          \\\n-    {                                                                 \\\n-      first = 1;\t\t\t\t\t\t      \\\n-      for (regno = 16; regno < 24; regno++)                           \\\n-        if (fmask & (1 << (23 - regno)))                               \\\n-          if (first && big) {\t                                      \\\n-            fprintf (FILE, \"\\tfmovem.x -%d(%s,a0.l),%s\",              \\\n-\t\t     foffset + fsize,                                 \\\n-\t\t     reg_names[FRAME_POINTER_REGNUM],                 \\\n-\t\t     reg_names[regno]);                               \\\n-\t    first = 0;\t\t\t\t\t\t      \\\n-           }                                                          \\\n-          else if (first && ! frame_pointer_needed) {                 \\\n-            fprintf (FILE, \"\\tfmovem.x (sp)+,%s\",                     \\\n-\t\t     foffset + fsize,                                 \\\n-\t\t     reg_names[FRAME_POINTER_REGNUM],                 \\\n-\t\t     reg_names[regno]);                               \\\n-\t    first = 0;\t\t\t\t\t\t      \\\n-           }                                                          \\\n-          else if (first) {    \t\t\t\t              \\\n-            fprintf (FILE, \"\\tfmovem.x -%d(%s),%s\",                   \\\n-\t\t     foffset + fsize,                                 \\\n-\t\t     reg_names[FRAME_POINTER_REGNUM],                 \\\n-\t\t     reg_names[regno]);                               \\\n-\t    first = 0;\t\t\t\t\t\t      \\\n-           }                                                          \\\n-\t  else fprintf (FILE, \"/%s\", reg_names[regno]); \t      \\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t      \\\n-    }                                                                 \\\n-  if (frame_pointer_needed)                                           \\\n-    fprintf (FILE, \"\\tunlk %s\\n\",                                     \\\n-\t     reg_names[FRAME_POINTER_REGNUM]);                        \\\n-  else if (fsize)                                                     \\\n-    {                                                                 \\\n-      if (fsize + 4 < 0x8000)                                         \\\n-\t{                                                             \\\n-\t  fprintf (FILE, \"\\tadd.w #%d,sp\\n\", fsize + 4);              \\\n-\t}                                                             \\\n-      else                                                            \\\n-\t{                                                             \\\n-\t  fprintf (FILE, \"\\tadd.l #%d,sp\\n\", fsize + 4);              \\\n-\t}                                                             \\\n-    }                                                                 \\\n-  if (current_function_pops_args)                                     \\\n-    fprintf (FILE, \"\\trtd #%d\\n\", current_function_pops_args);        \\\n-  else                                                                \\\n-    fprintf (FILE, \"\\trts\\n\");                                        \\\n-}\n-\n /* Translate Motorola opcodes such as `jbeq'\n    into VERSAdos opcodes such as `beq'.\n    Change `fbeq' to `fbseq', `fbne' to `fbsneq'."}, {"sha": "6a132beeb62f066123a8520dcee3e01bc47d4ea0", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -65,8 +65,6 @@ extern rtx legitimize_pic_address PARAMS ((rtx, enum machine_mode, rtx));\n #endif /* RTX_CODE */\n \n extern int flags_in_68881 PARAMS ((void));\n-extern void output_function_prologue PARAMS ((FILE *, int));\n-extern void output_function_epilogue PARAMS ((FILE *, int));\n extern int use_return_insn PARAMS ((void));\n extern void override_options PARAMS ((void));\n extern void init_68881_table PARAMS ((void));"}, {"sha": "5df64bf1503df8289533cbfd2d0f587cd0a83ae3", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 624, "deletions": 15, "changes": 639, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -56,6 +56,8 @@ int switch_table_difference_label_flag;\n \n static rtx find_addr_reg PARAMS ((rtx));\n static const char *singlemove_string PARAMS ((rtx *));\n+static void m68k_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void m68k_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n \n /* Alignment to use for loops and jumps */\n@@ -79,6 +81,10 @@ int m68k_align_funcs;\n int m68k_last_compare_had_fp_operands;\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE m68k_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE m68k_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -146,18 +152,236 @@ override_options ()\n /* Note that the order of the bit mask for fmovem is the opposite\n    of the order for movem!  */\n \n+#ifdef CRDS\n \n-void\n-output_function_prologue (stream, size)\n+static void\n+m68k_output_function_prologue (stream, size)\n+     FILE *stream;\n+     HOST_WIDE_INT size;\n+{\n+  register int regno;\n+  register int mask = 0;\n+  extern char call_used_regs[];\n+  HOST_WIDE_INT fsize = ((size) + 3) & -4;\n+\n+  /* unos stack probe */\n+  if (fsize > 30000)\n+    {\n+      fprintf (stream, \"\\tmovel sp,a0\\n\");\n+      fprintf (stream, \"\\taddl $-%d,a0\\n\", 2048 + fsize);\n+      fprintf (stream, \"\\ttstb (a0)\\n\");\n+    }\n+  else\n+    fprintf (stream, \"\\ttstb -%d(sp)\\n\", 2048 + fsize);\n+\n+  if (frame_pointer_needed)\n+    {\n+      if (TARGET_68020 || fsize < 0x8000)\n+\tfprintf (stream, \"\\tlink a6,$%d\\n\", -fsize);\n+      else\n+\tfprintf (stream, \"\\tlink a6,$0\\n\\tsubl $%d,sp\\n\", fsize);\n+    }\n+  else if (fsize)\n+    {\n+      /* Adding negative number is faster on the 68040.  */\n+      if (fsize + 4 < 0x8000)\n+\t  fprintf (stream, \"\\tadd.w #%d,sp\\n\", - (fsize + 4));\n+      else\n+\t  fprintf (stream, \"\\tadd.l #%d,sp\\n\", - (fsize + 4));\n+    }\n+\n+  for (regno = 16; regno < 24; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      mask |= 1 << (regno - 16);\n+\n+  if ((mask & 0xff) != 0)\n+    fprintf (stream, \"\\tfmovem $0x%x,-(sp)\\n\", mask & 0xff);\n+\n+  mask = 0;\n+  for (regno = 0; regno < 16; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      mask |= 1 << (15 - regno);\n+  if (frame_pointer_needed)\n+    mask &= ~ (1 << (15-FRAME_POINTER_REGNUM));\n+\n+  if (exact_log2 (mask) >= 0)\n+    fprintf (stream, \"\\tmovel %s,-(sp)\\n\", reg_names[15 - exact_log2 (mask)]);\n+  else if (mask)\n+    fprintf (stream, \"\\tmovem $0x%x,-(sp)\\n\", mask);\n+}\n+\n+#else\n+#if defined (DPX2) && defined (MOTOROLA)\n+\n+static void\n+m68k_output_function_prologue (stream, size)\n+     FILE *stream;\n+     HOST_WIDE_INT size;\n+{\n+  register int regno;\n+  register int mask = 0;\n+  int num_saved_regs = 0, first = 1;\n+  extern char call_used_regs[];\n+  HOST_WIDE_INT fsize = ((size) + 3) & -4;\n+\n+  if (frame_pointer_needed)\n+    {\n+      /* Adding negative number is faster on the 68040.  */\n+      if (fsize < 0x8000 && !TARGET_68040)\n+\tfprintf (stream, \"\\tlink %s,#%d\\n\",\n+\t\t reg_names[FRAME_POINTER_REGNUM], -fsize);\n+      else if (TARGET_68020)\n+\tfprintf (stream, \"\\tlink %s,#%d\\n\",\n+\t\t reg_names[FRAME_POINTER_REGNUM], -fsize);\n+      else\n+\tfprintf (stream, \"\\tlink %s,#0\\n\\tadd.l #%d,sp\\n\",\n+\t\t reg_names[FRAME_POINTER_REGNUM], -fsize);\n+    }\n+  else if (fsize)\n+    {\n+      /* Adding negative number is faster on the 68040.  */\n+      if (fsize + 4 < 0x8000)\n+\tfprintf (stream, \"\\tadd.w #%d,sp\\n\", - (fsize + 4));\n+      else\n+\tfprintf (stream, \"\\tadd.l #%d,sp\\n\", - (fsize + 4));\n+    }\n+\n+  for (regno = 23; regno >= 16; regno--)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+\tif (first)\n+\t  {\n+\t    fprintf (stream, \"\\tfmovem.x %s\", reg_names[regno]);\n+\t    first = 0;\n+\t  }\n+\telse\n+\t  fprintf (stream, \"/%s\", reg_names[regno]);\n+      }\n+  if (!first)\n+    fprintf (stream, \",-(sp)\\n\");\n+\n+  mask = 0;\n+  for (regno = 0; regno < 16; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+        mask |= 1 << (15 - regno);\n+        num_saved_regs++;\n+      }\n+\n+  if (frame_pointer_needed)\n+    {\n+      mask &= ~ (1 << (15 - FRAME_POINTER_REGNUM));\n+      num_saved_regs--;\n+    }\n+\n+  if (num_saved_regs <= 2)\n+    {\n+      /* Store each separately in the same order moveml uses.\n+         Using two movel instructions instead of a single moveml\n+         is about 15% faster for the 68020 and 68030 at no expense\n+         in code size */\n+\n+      int i;\n+\n+      /* Undo the work from above. */\n+      for (i = 0; i< 16; i++)\n+        if (mask & (1 << i))\n+          fprintf (stream, \"\\tmove.l %s,-(sp)\\n\", reg_names[15 - i]);\n+    }\n+  else if (mask)\n+    {\n+      first = 1;\n+      for (regno = 0; regno < 16; regno++)\n+        if (mask & (1 << regno))\n+\t  {\n+\t    if (first)\n+\t      {\n+\t\tfprintf (stream, \"\\tmovem.l %s\", reg_names[15 - regno]);\n+\t\tfirst = 0;\n+\t      }\n+\t    else\n+\t      fprintf (stream, \"/%s\", reg_names[15 - regno]);\n+\t  }\n+      fprintf (stream, \",-(sp)\\n\");\n+    }\n+\n+  if (flag_pic && current_function_uses_pic_offset_table)\n+    {\n+      fprintf (stream, \"\\tmove.l #__GLOBAL_OFFSET_TABLE_, %s\\n\",\n+\t       reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+      fprintf (stream, \"\\tlea.l (pc,%s.l),%s\\n\",\n+\t       reg_names[PIC_OFFSET_TABLE_REGNUM],\n+\t       reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+    }\n+}\n+\n+#else\n+#if defined (NEWS) && defined (MOTOROLA)\n+\n+static void\n+m68k_output_function_prologue (stream, size)\n      FILE *stream;\n-     int size;\n+     HOST_WIDE_INT size;\n+{\n+  register int regno;\n+  register int mask = 0;\n+  extern char call_used_regs[];\n+  HOST_WIDE_INT fsize = ((size) + 3) & -4;\n+\n+  if (frame_pointer_needed)\n+    {\n+      if (fsize < 0x8000)\n+\tfprintf (stream, \"\\tlink fp,#%d\\n\", -fsize);\n+      else if (TARGET_68020)\n+\tfprintf (stream, \"\\tlink.l fp,#%d\\n\", -fsize);\n+      else\n+\tfprintf (stream, \"\\tlink fp,#0\\n\\tsub.l #%d,sp\\n\", fsize);\n+    }\n+  else if (fsize)\n+    {\n+      int amt = fsize + 4;\n+      /* Adding negative number is faster on the 68040.  */\n+      if (fsize + 4 < 0x8000)\n+\tasm_fprintf (stream, \"\\tadd.w %0I%d,%Rsp\\n\", - amt);\n+      else\n+\tasm_fprintf (stream, \"\\tadd.l %0I%d,%Rsp\\n\", - amt);\n+    }\n+\n+  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      mask |= 1 << (regno - 16);\n+\n+  if (mask != 0)\n+    fprintf (stream, \"\\tfmovem.x #0x%x,-(sp)\\n\", mask & 0xff);\n+\n+  mask = 0;\n+  for (regno = 0; regno < 16; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      mask |= 1 << (15 - regno);\n+\n+  if (frame_pointer_needed)\n+    mask &= ~ (1 << (15-FRAME_POINTER_REGNUM));\n+\n+  if (exact_log2 (mask) >= 0)\n+    fprintf (stream, \"\\tmove.l %s,-(sp)\\n\", reg_names[15 - exact_log2 (mask)]);\n+  else\n+    if (mask) fprintf (stream, \"\\tmovem.l #0x%x,-(sp)\\n\", mask);\n+}\n+\n+#else  /* !CRDS && ! (NEWS && MOTOROLA) && ! (DPX2 && MOTOROLA) */\n+\n+static void\n+m68k_output_function_prologue (stream, size)\n+     FILE *stream;\n+     HOST_WIDE_INT size;\n {\n   register int regno;\n   register int mask = 0;\n   int num_saved_regs = 0;\n   extern char call_used_regs[];\n-  int fsize = (size + 3) & -4;\n-  int cfa_offset = INCOMING_FRAME_SP_OFFSET, cfa_store_offset = cfa_offset;\n+  HOST_WIDE_INT fsize = (size + 3) & -4;\n+  HOST_WIDE_INT cfa_offset = INCOMING_FRAME_SP_OFFSET;\n+  HOST_WIDE_INT cfa_store_offset = cfa_offset;\n   \n   /* If the stack limit is a symbol, we can check it here,\n      before actually allocating the space.  */\n@@ -385,11 +609,7 @@ output_function_prologue (stream, size)\n \n #if NEED_PROBE\n #ifdef MOTOROLA\n-#ifdef CRDS\n-  asm_fprintf (stream, \"\\ttstl %d(%Rsp)\\n\", NEED_PROBE - num_saved_regs * 4);\n-#else\n   asm_fprintf (stream, \"\\ttst.l %d(%Rsp)\\n\", NEED_PROBE - num_saved_regs * 4);\n-#endif\n #else\n   asm_fprintf (stream, \"\\ttstl %Rsp@(%d)\\n\", NEED_PROBE - num_saved_regs * 4);\n #endif\n@@ -515,6 +735,9 @@ output_function_prologue (stream, size)\n #endif\n     }\n }\n+#endif   /* ! (DPX2 && MOTOROLA)  */\n+#endif   /* ! (NEWS && MOTOROLA)  */\n+#endif   /* !CRDS  */\n \f\n /* Return true if this function's epilogue can be output as RTL.  */\n \n@@ -540,24 +763,406 @@ use_return_insn ()\n }\n \n /* This function generates the assembly code for function exit,\n-   on machines that need it.  Args are same as for FUNCTION_PROLOGUE.\n+   on machines that need it.\n \n    The function epilogue should not depend on the current stack pointer!\n    It should use the frame pointer only, if there is a frame pointer.\n    This is mandatory because of alloca; we also take advantage of it to\n    omit stack adjustments before returning.  */\n \n-void\n-output_function_epilogue (stream, size)\n+#ifdef CRDS\n+\n+static void\n+m68k_output_function_epilogue (stream, size)\n      FILE *stream;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n   register int regno;\n   register int mask, fmask;\n   register int nregs;\n-  int offset, foffset, fpoffset;\n+  HOST_WIDE_INT offset, foffset, fpoffset;\n   extern char call_used_regs[];\n-  int fsize = (size + 3) & -4;\n+  HOST_WIDE_INT fsize = ((size) + 3) & -4;\n+  int big = 0;\n+\n+  nregs = 0;  fmask = 0; fpoffset = 0;\n+  for (regno = 16; regno < 24; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+\tnregs++;\n+\tfmask |= 1 << (23 - regno);\n+      }\n+\n+  foffset = fpoffset + nregs * 12;\n+  nregs = 0;  mask = 0;\n+  if (frame_pointer_needed)\n+    regs_ever_live[FRAME_POINTER_REGNUM] = 0;\n+\n+  for (regno = 0; regno < 16; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+\tnregs++;\n+\tmask |= 1 << regno;\n+      }\n+\n+  offset = foffset + nregs * 4;\n+  if (offset + fsize >= 0x8000\n+      && frame_pointer_needed\n+      && (mask || fmask || fpoffset))\n+    {\n+      fprintf (stream, \"\\tmovel $%d,a0\\n\", -fsize);\n+      fsize = 0, big = 1;\n+    }\n+\n+  if (exact_log2 (mask) >= 0)\n+    {\n+      if (big)\n+\tfprintf (stream, \"\\tmovel -%d(a6,a0.l),%s\\n\",\n+\t\t offset + fsize, reg_names[exact_log2 (mask)]);\n+      else if (! frame_pointer_needed)\n+\tfprintf (stream, \"\\tmovel (sp)+,%s\\n\",\n+\t\t reg_names[exact_log2 (mask)]);\n+      else\n+\tfprintf (stream, \"\\tmovel -%d(a6),%s\\n\",\n+\t\t offset + fsize, reg_names[exact_log2 (mask)]);\n+    }\n+  else if (mask)\n+    {\n+      if (big)\n+\tfprintf (stream, \"\\tmovem -%d(a6,a0.l),$0x%x\\n\",\n+\t\t offset + fsize, mask);\n+      else if (! frame_pointer_needed)\n+\tfprintf (stream, \"\\tmovem (sp)+,$0x%x\\n\", mask);\n+      else\n+\tfprintf (stream, \"\\tmovem -%d(a6),$0x%x\\n\",\n+\t\t offset + fsize, mask);\n+    }\n+\n+  if (fmask)\n+    {\n+      if (big)\n+\tfprintf (stream, \"\\tfmovem -%d(a6,a0.l),$0x%x\\n\",\n+\t\t foffset + fsize, fmask);\n+      else if (! frame_pointer_needed)\n+\tfprintf (stream, \"\\tfmovem (sp)+,$0x%x\\n\", fmask);\n+      else\n+\tfprintf (stream, \"\\tfmovem -%d(a6),$0x%x\\n\",\n+\t\t foffset + fsize, fmask);\n+    }\n+\n+  if (fpoffset != 0)\n+    for (regno = 55; regno >= 24; regno--)\n+      if (regs_ever_live[regno] && ! call_used_regs[regno])\n+\t{\n+\t  if (big)\n+\t    fprintf(stream, \"\\tfpmoved -%d(a6,a0.l), %s\\n\",\n+\t\t    fpoffset + fsize, reg_names[regno]);\n+\t  else if (! frame_pointer_needed)\n+\t    fprintf(stream, \"\\tfpmoved (sp)+, %s\\n\",\n+\t\t    reg_names[regno]);\n+\t  else\n+\t    fprintf(stream, \"\\tfpmoved -%d(a6), %s\\n\",\n+\t\t    fpoffset + fsize, reg_names[regno]);\n+\t  fpoffset -= 8;\n+\t}\n+\n+  if (frame_pointer_needed)\n+    fprintf (stream, \"\\tunlk a6\\n\");\n+  else if (fsize)\n+    {\n+      if (fsize + 4 < 0x8000)\n+\tfprintf (stream, \"\\tadd.w #%d,sp\\n\", fsize + 4);\n+      else\n+\tfprintf (stream, \"\\tadd.l #%d,sp\\n\", fsize + 4);\n+    }\n+\n+  if (current_function_pops_args)\n+    fprintf (stream, \"\\trtd $%d\\n\", current_function_pops_args);\n+  else\n+    fprintf (stream, \"\\trts\\n\");\n+}\n+\n+#else\n+#if defined (DPX2) && defined (MOTOROLA)\n+\n+static void\n+m68k_output_function_epilogue (stream, size)\n+     FILE *stream;\n+     HOST_WIDE_INT size;\n+{\n+  register int regno;\n+  register int mask, fmask;\n+  register int nregs;\n+  HOST_WIDE_INT offset, foffset, fpoffset, first = 1;\n+  extern char call_used_regs[];\n+  HOST_WIDE_INT fsize = ((size) + 3) & -4;\n+  int big = 0;\n+  rtx insn = get_last_insn ();\n+\n+  /* If the last insn was a BARRIER, we don't have to write any code.  */\n+  if (GET_CODE (insn) == NOTE)\n+    insn = prev_nonnote_insn (insn);\n+  if (insn && GET_CODE (insn) == BARRIER)\n+    {\n+      /* Output just a no-op so that debuggers don't get confused\n+\t about which function the pc is in at this address.  */\n+      fprintf (stream, \"\\tnop\\n\");\n+      return;\n+    }\n+\n+  nregs = 0;  fmask = 0; fpoffset = 0;\n+  for (regno = 16; regno < 24; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+        nregs++;\n+\tfmask |= 1 << (23 - regno);\n+      }\n+\n+  foffset = fpoffset + nregs * 12;\n+  nregs = 0;  mask = 0;\n+  if (frame_pointer_needed)\n+    regs_ever_live[FRAME_POINTER_REGNUM] = 0;\n+\n+  for (regno = 0; regno < 16; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+        nregs++;\n+\tmask |= 1 << regno;\n+      }\n+\n+  offset = foffset + nregs * 4;\n+  if (offset + fsize >= 0x8000\n+      && frame_pointer_needed\n+      && (mask || fmask || fpoffset))\n+    {\n+      fprintf (stream, \"\\tmove.l #%d,a0\\n\", -fsize);\n+      fsize = 0, big = 1;\n+    }\n+\n+  if (nregs <= 2)\n+    {\n+      /* Restore each separately in the same order moveml does.\n+         Using two movel instructions instead of a single moveml\n+         is about 15% faster for the 68020 and 68030 at no expense\n+         in code size. */\n+\n+      int i;\n+\n+      /* Undo the work from above. */\n+      for (i = 0; i< 16; i++)\n+        if (mask & (1 << i))\n+          {\n+            if (big)\n+\t      fprintf (stream, \"\\tmove.l -%d(%s,a0.l),%s\\n\",\n+\t\t       offset + fsize,\n+\t\t       reg_names[FRAME_POINTER_REGNUM],\n+\t\t       reg_names[i]);\n+            else if (! frame_pointer_needed)\n+\t      fprintf (stream, \"\\tmove.l (sp)+,%s\\n\",\n+\t\t       reg_names[i]);\n+            else\n+\t      fprintf (stream, \"\\tmove.l -%d(%s),%s\\n\",\n+\t\t       offset + fsize,\n+\t\t       reg_names[FRAME_POINTER_REGNUM],\n+\t\t       reg_names[i]);\n+            offset = offset - 4;\n+          }\n+    }\n+  else if (mask)\n+    {\n+      first = 1;\n+      for (regno = 0; regno < 16; regno++)\n+        if (mask & (1 << regno))\n+\t  {\n+\t    if (first && big)\n+\t      {\n+\t\tfprintf (stream, \"\\tmovem.l -%d(%s,a0.l),%s\",\n+\t\t\t offset + fsize,\n+\t\t\t reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t reg_names[regno]);\n+\t\tfirst = 0;\n+\t      }\n+\t    else if (first && ! frame_pointer_needed)\n+\t      {\n+\t\tfprintf (stream, \"\\tmovem.l (sp)+,%s\",\n+\t\t\t reg_names[regno]);\n+\t\tfirst = 0;\n+\t      }\n+\t    else if (first)\n+\t      {\n+\t\tfprintf (stream, \"\\tmovem.l -%d(%s),%s\",\n+\t\t\t offset + fsize,\n+\t\t\t reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t reg_names[regno]);\n+\t\tfirst = 0;\n+\t      }\n+\t    else\n+\t      fprintf (stream, \"/%s\", reg_names[regno]);\n+\t  }\n+      fprintf (stream, \"\\n\");\n+    }\n+\n+  if (fmask)\n+    {\n+      first = 1;\n+      for (regno = 16; regno < 24; regno++)\n+        if (fmask & (1 << (23 - regno)))\n+\t  {\n+\t    if (first && big)\n+\t      {\n+\t\tfprintf (stream, \"\\tfmovem.x -%d(%s,a0.l),%s\",\n+\t\t\t foffset + fsize,\n+\t\t\t reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t reg_names[regno]);\n+\t\tfirst = 0;\n+\t      }\n+\t    else if (first && ! frame_pointer_needed)\n+\t      {\n+\t\tfprintf (stream, \"\\tfmovem.x (sp)+,%s\",\n+\t\t\t reg_names[regno]);\n+\t\tfirst = 0;\n+\t      }\n+\t    else if (first)\n+\t      {\n+\t\tfprintf (stream, \"\\tfmovem.x -%d(%s),%s\",\n+\t\t\t foffset + fsize,\n+\t\t\t reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t reg_names[regno]);\n+\t\tfirst = 0;\n+\t      }\n+\t    else\n+\t      fprintf (stream, \"/%s\", reg_names[regno]);\n+\t  }\n+      fprintf (stream, \"\\n\");\n+    }\n+\n+  if (frame_pointer_needed)\n+    fprintf (stream, \"\\tunlk %s\\n\",\n+\t     reg_names[FRAME_POINTER_REGNUM]);\n+  else if (fsize)\n+    {\n+      if (fsize + 4 < 0x8000)\n+\tfprintf (stream, \"\\tadd.w #%d,sp\\n\", fsize + 4);\n+      else\n+\tfprintf (stream, \"\\tadd.l #%d,sp\\n\", fsize + 4);\n+    }\n+\n+  if (current_function_pops_args)\n+    fprintf (stream, \"\\trtd #%d\\n\", current_function_pops_args);\n+  else\n+    fprintf (stream, \"\\trts\\n\");\n+}\n+\n+#else\n+#if defined (NEWS) && defined (MOTOROLA)\n+\n+static void\n+m68k_output_function_epilogue (stream, size)\n+     FILE *stream;\n+     HOST_WIDE_INT size;\n+{\n+  register int regno;\n+  register int mask, fmask;\n+  register int nregs;\n+  HOST_WIDE_INT offset, foffset;\n+  extern char call_used_regs[];\n+  HOST_WIDE_INT fsize = ((size) + 3) & -4;\n+  int big = 0;\n+\n+  nregs = 0;  fmask = 0;\n+  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+\tnregs++;\n+\tfmask |= 1 << (23 - regno);\n+      }\n+\n+  foffset = nregs * 12;\n+  nregs = 0;  mask = 0;\n+  if (frame_pointer_needed)\n+    regs_ever_live[FRAME_POINTER_REGNUM] = 0;\n+\n+  for (regno = 0; regno < 16; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+\tnregs++;\n+\tmask |= 1 << regno;\n+      }\n+\n+  offset = foffset + nregs * 4;\n+  if (offset + fsize >= 0x8000\n+      && frame_pointer_needed\n+      && (mask || fmask))\n+    {\n+      fprintf (stream, \"\\tmove.l #%d,a0\\n\", -fsize);\n+      fsize = 0, big = 1;\n+    }\n+\n+  if (exact_log2 (mask) >= 0)\n+    {\n+      if (big)\n+\tfprintf (stream, \"\\tmove.l (-%d,fp,a0.l),%s\\n\",\n+\t\t offset + fsize, reg_names[exact_log2 (mask)]);\n+      else if (! frame_pointer_needed)\n+\tfprintf (stream, \"\\tmove.l (sp)+,%s\\n\",\n+\t\t reg_names[exact_log2 (mask)]);\n+      else\n+\tfprintf (stream, \"\\tmove.l (-%d,fp),%s\\n\",\n+\t\t offset + fsize, reg_names[exact_log2 (mask)]);\n+    }\n+  else if (mask)\n+    {\n+      if (big)\n+\tfprintf (stream, \"\\tmovem.l (-%d,fp,a0.l),#0x%x\\n\",\n+\t\t offset + fsize, mask);\n+      else if (! frame_pointer_needed)\n+\tfprintf (stream, \"\\tmovem.l (sp)+,#0x%x\\n\", mask);\n+      else\n+\tfprintf (stream, \"\\tmovem.l (-%d,fp),#0x%x\\n\",\n+\t\t offset + fsize, mask);\n+    }\n+\n+  if (fmask)\n+    {\n+      if (big)\n+\tfprintf (stream, \"\\tfmovem.x (-%d,fp,a0.l),#0x%x\\n\",\n+\t\t foffset + fsize, fmask);\n+      else if (! frame_pointer_needed)\n+\tfprintf (stream, \"\\tfmovem.x (sp)+,#0x%x\\n\", fmask);\n+      else\n+\tfprintf (stream, \"\\tfmovem.x (-%d,fp),#0x%x\\n\",\n+\t\t foffset + fsize, fmask);\n+    }\n+\n+  if (frame_pointer_needed)\n+    fprintf (stream, \"\\tunlk fp\\n\");\n+  else if (fsize)\n+    {\n+      if (fsize + 4 < 0x8000)\n+\tfprintf (stream, \"\\tadd.w #%d,sp\\n\", fsize + 4);\n+      else\n+\tfprintf (stream, \"\\tadd.l #%d,sp\\n\", fsize + 4);\n+    }\n+\n+  if (current_function_pops_args)\n+    fprintf (stream, \"\\trtd #%d\\n\", current_function_pops_args);\n+  else\n+    fprintf (stream, \"\\trts\\n\");\n+}\n+\n+#else  /* !CRDS && ! (NEWS && MOTOROLA) && ! (DPX2 && MOTOROLA) */\n+\n+static void\n+m68k_output_function_epilogue (stream, size)\n+     FILE *stream;\n+     HOST_WIDE_INT size;\n+{\n+  register int regno;\n+  register int mask, fmask;\n+  register int nregs;\n+  HOST_WIDE_INT offset, foffset, fpoffset;\n+  extern char call_used_regs[];\n+  HOST_WIDE_INT fsize = (size + 3) & -4;\n   int big = 0;\n   rtx insn = get_last_insn ();\n   int restore_from_sp = 0;\n@@ -875,6 +1480,10 @@ output_function_epilogue (stream, size)\n   else\n     fprintf (stream, \"\\trts\\n\");\n }\n+\n+#endif   /* ! (DPX2 && MOTOROLA)  */\n+#endif   /* ! (NEWS && MOTOROLA)  */\n+#endif   /* !CRDS  */\n \f\n /* Similar to general_operand, but exclude stack_pointer_rtx.  */\n "}, {"sha": "68017af17dedfda1c9160497a1b5c0ac785d7111", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1050,9 +1050,6 @@ extern enum reg_class regno_reg_class[];\n \t\t      : GET_MODE_SIZE (MODE))))  \t\t\\\n  ? 2 - (CUM) / 4 : 0)\n \n-/* Generate the assembly code for function entry. */\n-#define FUNCTION_PROLOGUE(FILE, SIZE) output_function_prologue(FILE, SIZE)\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -1228,9 +1225,6 @@ while(0)\n \n #define EXIT_IGNORE_STACK 1\n \n-/* Generate the assembly code for function exit. */\n-#define FUNCTION_EPILOGUE(FILE, SIZE) output_function_epilogue (FILE, SIZE)\n-  \n /* This is a hook for other tm files to change.  */\n /* #define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE) */\n "}, {"sha": "96ce23c53f16246800f8b8d5befbfcf37febf895", "filename": "gcc/config/m68k/news.h", "status": "modified", "additions": 1, "deletions": 104, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68k%2Fnews.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm68k%2Fnews.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnews.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -25,6 +25,7 @@ Boston, MA 02111-1307, USA.  */\n #define SGS_NO_LI\t\t/* Suppress jump table label usage */\n #endif\n \n+#define NEWS\n #define NO_DOLLAR_IN_LABEL\n #define NO_DOT_IN_LABEL\n \n@@ -98,8 +99,6 @@ Boston, MA 02111-1307, USA.  */\n #undef FUNCTION_PROFILER\n \n #ifdef MOTOROLA\n-#undef FUNCTION_PROLOGUE\n-#undef FUNCTION_EPILOGUE\n #undef REGISTER_NAMES\n #undef ASM_OUTPUT_REG_PUSH\n #undef ASM_OUTPUT_REG_POP\n@@ -139,111 +138,9 @@ Boston, MA 02111-1307, USA.  */\n \f\n #ifdef MOTOROLA\n \n-#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n-{ register int regno;\t\t\t\t\t\t\\\n-  register int mask = 0;\t\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    { if (fsize < 0x8000)\t\t\t                \\\n-        fprintf (FILE, \"\\tlink fp,#%d\\n\", -fsize);\t\t\\\n-      else if (TARGET_68020)                                    \\\n-        fprintf (FILE, \"\\tlink.l fp,#%d\\n\", -fsize);            \\\n-      else\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tlink fp,#0\\n\\tsub.l #%d,sp\\n\", fsize);\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (fsize)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      int amt = fsize + 4;\t\t\t\t\t\\\n-      /* Adding negative number is faster on the 68040.  */\t\\\n-      if (fsize + 4 < 0x8000)\t\t\t\t\t\\\n-\tasm_fprintf (FILE, \"\\tadd.w %0I%d,%Rsp\\n\", - amt);\t\\\n-      else\t\t\t\t\t\t\t\\\n-\tasm_fprintf (FILE, \"\\tadd.l %0I%d,%Rsp\\n\", - amt);\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-       mask |= 1 << (regno - 16);\t\t\t\t\\\n-  if (mask != 0)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tfmovem.x #0x%x,-(sp)\\n\", mask & 0xff);    \\\n-  mask = 0;\t\t\t\t\t\t\t\\\n-  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-       mask |= 1 << (15 - regno);\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    mask &= ~ (1 << (15-FRAME_POINTER_REGNUM));\t\t\t\\\n-  if (exact_log2 (mask) >= 0)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tmove.l %s,-(sp)\\n\", reg_names[15 - exact_log2 (mask)]);  \\\n-  else if (mask) fprintf (FILE, \"\\tmovem.l #0x%x,-(sp)\\n\", mask); }\n-\n #define FUNCTION_PROFILER(FILE, LABEL_NO) \\\n    fprintf (FILE, \"\\tmove.l #LP%d,d0\\n\\tjsr mcount\\n\", (LABEL_NO));\n \n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-{ register int regno;\t\t\t\t\t\t\\\n-  register int mask, fmask;\t\t\t\t\t\\\n-  register int nregs;\t\t\t\t\t\t\\\n-  int offset, foffset;\t\t\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n-  int big = 0;\t\t\t\t\t\t\t\\\n-  nregs = 0;  fmask = 0;\t\t\t\t\t\\\n-  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      { nregs++; fmask |= 1 << (23 - regno); }\t\t\t\\\n-  foffset = nregs * 12;\t\t\t\t\t\t\\\n-  nregs = 0;  mask = 0;\t\t\t\t\t\t\\\n-  if (frame_pointer_needed) regs_ever_live[FRAME_POINTER_REGNUM] = 0; \\\n-  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      { nregs++; mask |= 1 << regno; }\t\t\t\t\\\n-  offset = foffset + nregs * 4;\t\t\t\t\t\\\n-  if (offset + fsize >= 0x8000 \t\t\t\t\t\\\n-      && frame_pointer_needed\t\t\t\t\t\\\n-      && (mask || fmask))\t\t\t\t\t\\\n-    { fprintf (FILE, \"\\tmove.l #%d,a0\\n\", -fsize);\t\t\\\n-      fsize = 0, big = 1; }\t\t\t\t\t\\\n-  if (exact_log2 (mask) >= 0) {\t\t\t\t\t\\\n-    if (big)\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmove.l (-%d,fp,a0.l),%s\\n\",\t\t\\\n-\t       offset + fsize, reg_names[exact_log2 (mask)]);\t\\\n-    else if (! frame_pointer_needed)\t\t\t\t\\\n-      fprintf (FILE, \"\\tmove.l (sp)+,%s\\n\",\t\t\t\\\n-\t       reg_names[exact_log2 (mask)]);\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmove.l (-%d,fp),%s\\n\",\t\t\t\\\n-\t       offset + fsize, reg_names[exact_log2 (mask)]); }\t\\\n-  else if (mask) {\t\t\t\t\t\t\\\n-    if (big)\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovem.l (-%d,fp,a0.l),#0x%x\\n\",\t\t\\\n-\t       offset + fsize, mask);\t\t\t\t\\\n-    else if (! frame_pointer_needed)\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovem.l (sp)+,#0x%x\\n\", mask);\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovem.l (-%d,fp),#0x%x\\n\",\t\t\\\n-\t       offset + fsize, mask); }\t\t\t\t\\\n-  if (fmask) {\t\t\t\t\t\t\t\\\n-    if (big)\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tfmovem.x (-%d,fp,a0.l),#0x%x\\n\",\t\\\n-\t       foffset + fsize, fmask);\t\t\t\t\\\n-    else if (! frame_pointer_needed)\t\t\t\t\\\n-      fprintf (FILE, \"\\tfmovem.x (sp)+,#0x%x\\n\", fmask);\t\\\n-    else\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tfmovem.x (-%d,fp),#0x%x\\n\",\t\t\\\n-\t       foffset + fsize, fmask); }\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tunlk fp\\n\");\t\t\t\t\\\n-  else if (fsize)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (fsize + 4 < 0x8000)\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tadd.w #%d,sp\\n\", fsize + 4);\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tadd.l #%d,sp\\n\", fsize + 4);\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (current_function_pops_args)\t\t\t\t\\\n-    fprintf (FILE, \"\\trtd #%d\\n\", current_function_pops_args);\t\\\n-  else fprintf (FILE, \"\\trts\\n\"); }\n-\n /* Difference from m68k.h is in `fp' instead of `a6'.  */\n \n #define REGISTER_NAMES \\"}, {"sha": "a8204a37dec4af5670174b3c5a18ed058ecde5a7", "filename": "gcc/config/m88k/m88k-protos.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm88k%2Fm88k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm88k%2Fm88k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -84,16 +84,14 @@ extern int null_prologue PARAMS ((void));\n extern int integer_ok_for_set PARAMS ((unsigned));\n extern void m88k_layout_frame PARAMS ((void));\n extern void m88k_expand_prologue PARAMS ((void));\n-extern void m88k_begin_prologue PARAMS ((FILE *, int));\n extern void m88k_end_prologue PARAMS ((FILE *));\n extern void m88k_expand_epilogue PARAMS ((void));\n extern void m88k_begin_epilogue PARAMS ((FILE *));\n-extern void m88k_end_epilogue PARAMS ((FILE *, int));\n extern void output_function_profiler PARAMS ((FILE *, int, const char *, int));\n extern void output_function_block_profiler PARAMS ((FILE *, int));\n extern void output_block_profiler PARAMS ((FILE *, int));\n extern void output_ascii PARAMS ((FILE *, const char *, int,\n-\t\t\t\t  const unsigned char *, int));\n+\t\t\t\t  const char *, int));\n extern void output_label PARAMS ((int));\n extern struct rtx_def *m88k_builtin_saveregs PARAMS ((void));\n extern enum m88k_instruction classify_integer PARAMS ((enum machine_mode, int));"}, {"sha": "3cb88902c5e299317306e17dbc6db5474b279b11", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -62,8 +62,15 @@ rtx m88k_compare_op0;\t\t/* cmpsi operand 0 */\n rtx m88k_compare_op1;\t\t/* cmpsi operand 1 */\n \n enum processor_type m88k_cpu;\t/* target cpu */\n+\n+static void m88k_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void m88k_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE m88k_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE m88k_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -1611,7 +1618,7 @@ output_ascii (file, opcode, max, p, size)\n      FILE *file;\n      const char *opcode;\n      int max;\n-     const unsigned char *p;\n+     const char *p;\n      int size;\n {\n   int i;\n@@ -1622,7 +1629,7 @@ output_ascii (file, opcode, max, p, size)\n   fprintf (file, \"%s\\\"\", opcode);\n   for (i = 0; i < size; i++)\n     {\n-      register int c = p[i];\n+      register int c = (unsigned char) p[i];\n \n       if (num > max)\n \t{\n@@ -1781,7 +1788,8 @@ static int  prologue_marked;\n   (((BYTES) + (STACK_UNIT_BOUNDARY - 1)) & ~(STACK_UNIT_BOUNDARY - 1))\n \f\n /* Establish the position of the FP relative to the SP.  This is done\n-   either during FUNCTION_PROLOGUE or by INITIAL_ELIMINATION_OFFSET.  */\n+   either during output_function_prologue() or by\n+   INITIAL_ELIMINATION_OFFSET.  */\n \n void\n m88k_layout_frame ()\n@@ -1935,10 +1943,10 @@ uses_arg_area_p ()\n   return 0;\n }\n \f\n-void\n-m88k_begin_prologue (stream, size)\n+static void\n+m88k_output_function_prologue (stream, size)\n      FILE *stream ATTRIBUTE_UNUSED;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   if (TARGET_OMIT_LEAF_FRAME_POINTER && ! quiet_flag && leaf_function_p ())\n     fprintf (stderr, \"$\");\n@@ -2016,7 +2024,7 @@ m88k_expand_prologue ()\n }\n \f\n /* This function generates the assembly code for function exit,\n-   on machines that need it.  Args are same as for FUNCTION_PROLOGUE.\n+   on machines that need it.\n \n    The function epilogue should not depend on the current stack pointer!\n    It should use the frame pointer only, if there is a frame pointer.\n@@ -2034,10 +2042,10 @@ m88k_begin_epilogue (stream)\n   epilogue_marked = 1;\n }\n \n-void\n-m88k_end_epilogue (stream, size)\n+static void\n+m88k_output_function_epilogue (stream, size)\n      FILE *stream;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   rtx insn = get_last_insn ();\n "}, {"sha": "3af1c291a6d7ff2f337defef6422dcd5cfcec89c", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -86,7 +86,7 @@ enum m88k_instruction {\n enum processor_type {\n   PROCESSOR_M88100,\n   PROCESSOR_M88110,\n-  PROCESSOR_M88000,\n+  PROCESSOR_M88000\n };\n \n /* Recast the cpu class to be the cpu attribute.  */\n@@ -1046,9 +1046,6 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n #define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n   m88k_va_arg (valist, type)\n \n-/* Generate the assembly code for function entry. */\n-#define FUNCTION_PROLOGUE(FILE, SIZE) m88k_begin_prologue(FILE, SIZE)\n-\n /* Perform special actions at the point where the prologue ends.  */\n #define FUNCTION_END_PROLOGUE(FILE) m88k_end_prologue(FILE)\n \n@@ -1083,9 +1080,6 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n    No definition is equivalent to always zero.  */\n #define EXIT_IGNORE_STACK (1)\n \n-/* Generate the assembly code for function exit. */\n-#define FUNCTION_EPILOGUE(FILE, SIZE) m88k_end_epilogue(FILE, SIZE)\n-\n /* Perform special actions at the point where the epilogue begins.  */\n #define FUNCTION_BEGIN_EPILOGUE(FILE) m88k_begin_epilogue(FILE)\n "}, {"sha": "21abf47fc822e9e391bbecef09568ab3a677b59e", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -27,8 +27,6 @@ Boston, MA 02111-1307, USA.  */\n #define GCC_MIPS_PROTOS_H\n \n extern HOST_WIDE_INT\tcompute_frame_size PARAMS ((HOST_WIDE_INT));\n-extern void\t\tfunction_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-extern void\t\tfunction_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n extern void\t\tmips_asm_file_end PARAMS ((FILE *));\n extern void\t\tmips_asm_file_start PARAMS ((FILE *));\n extern int\t\tmips_can_use_return_insn PARAMS ((void));"}, {"sha": "94308af3a409f6134f384aee38e907f1d60c9abf", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -107,6 +107,8 @@ static void abort_with_insn\t\t\tPARAMS ((rtx, const char *))\n   ATTRIBUTE_NORETURN;\n static int symbolic_expression_p                PARAMS ((rtx));\n static void mips_add_gc_roots                   PARAMS ((void));\n+static void mips_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void mips_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static enum processor_type mips_parse_cpu       PARAMS ((const char *));\n \n /* Global variables for machine-dependent things.  */\n@@ -439,6 +441,10 @@ enum reg_class mips_char_to_class[256] =\n };\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE mips_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE mips_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -6846,8 +6852,8 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \f\n /* Set up the stack and frame (if desired) for the function.  */\n \n-void\n-function_prologue (file, size)\n+static void\n+mips_output_function_prologue (file, size)\n      FILE *file;\n      HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n@@ -7437,12 +7443,12 @@ mips_expand_prologue ()\n #define RA_MASK BITMASK_HIGH\t/* 1 << 31 */\n #define PIC_OFFSET_TABLE_MASK (1 << (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \n-void\n-function_epilogue (file, size)\n+static void\n+mips_output_function_epilogue (file, size)\n      FILE *file ATTRIBUTE_UNUSED;\n      HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n-  const char *fnname;\n+  const char *fnname = \"\";\t/* FIXME: Correct initialisation?  */\n \n #ifndef FUNCTION_NAME_ALREADY_DECLARED\n   /* Get the function name the same way that toplev.c does before calling"}, {"sha": "134b546b7ce79c5a5b0b18a2d3b25d809737f6a8", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -2584,23 +2584,6 @@ typedef struct mips_args {\n \t\t: GET_MODE_ALIGNMENT(MODE)))\n \n \f\n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) function_prologue(FILE, SIZE)\n-\n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) function_epilogue(FILE, SIZE)\n-\n /* Tell prologue and epilogue if register REGNO should be saved / restored.  */\n \n #define MUST_SAVE_REGISTER(regno) \\"}, {"sha": "a3b41baf260e7f89586d10d0549c531ad7f173fc", "filename": "gcc/config/ns32k/merlin.h", "status": "modified", "additions": 2, "deletions": 102, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fns32k%2Fmerlin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fns32k%2Fmerlin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fmerlin.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -26,6 +26,8 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"ns32k/ns32k.h\"\n \n+#define MERLIN_TARGET\n+\n /* This is BSD, so it wants DBX format.  */\n #define DBX_DEBUGGING_INFO\n \n@@ -123,108 +125,6 @@ Boston, MA 02111-1307, USA.  */\n \t   fprintf (FILE, \"$0f%.20e\", u.d); }\t\t\t\t\\\n   else output_addr_const (FILE, X); }\n \n-#undef  FUNCTION_PROLOGUE\n-\n-/* This differs from the one in ns32k.h in printing a bitmask\n-   rather than a register list in the enter or save instruction.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n-{ register int regno, g_regs_used = 0;\t\t\t\t\\\n-  int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n-  int used_fregs_buf[8], *fbufp = used_fregs_buf;\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  MAIN_FUNCTION_PROLOGUE;\t\t\t\t\t\\\n-  for (regno = 0; regno < 8; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno]\t\t\t\t\t\\\n-\t&& ! call_used_regs[regno])\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      *bufp++ = regno; g_regs_used++;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  *bufp = -1;\t\t\t\t\t\t\t\\\n-  for (; regno < 16; regno++)\t\t\t\t\t\\\n-    if (regs_ever_live[regno] && !call_used_regs[regno]) {\t\\\n-      *fbufp++ = regno;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  *fbufp = -1;\t\t\t\t\t\t\t\\\n-  bufp = used_regs_buf;\t\t\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tenter \");\t\t\t\t\t\\\n-  else if (g_regs_used)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tsave \");\t\t\t\t\t\\\n-  if (frame_pointer_needed || g_regs_used)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      char mask = 0;\t\t\t\t\t\t\\\n-      while (*bufp >= 0)\t\t\t\t\t\\\n-\tmask |= 1 << *bufp++;\t\t\t\t\t\\\n-      fprintf (FILE, \"$0x%x\", (int) mask & 0xff);\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    fprintf (FILE, \",%d\\n\", SIZE);\t\t\t\t\\\n-  else if (g_regs_used)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n-  fbufp = used_fregs_buf;\t\t\t\t\t\\\n-  while (*fbufp >= 0)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if ((*fbufp & 1) || (fbufp[0] != fbufp[1] - 1))\t\t\\\n-\tfprintf (FILE, \"\\tmovf f%d,tos\\n\", *fbufp++ - 8);\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tmovl f%d,tos\\n\", fbufp[0] - 8);\t\\\n-\t  fbufp += 2;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-\n-#undef  FUNCTION_EPILOGUE\n-\n-/* This differs from the one in ns32k.h in printing a bitmask\n-   rather than a register list in the exit or restore instruction.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-{ register int regno, g_regs_used = 0, f_regs_used = 0;\t\t\\\n-  int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n-  int used_fregs_buf[8], *fbufp = used_fregs_buf;\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  *fbufp++ = -2;\t\t\t\t\t\t\\\n-  for (regno = 8; regno < 16; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && !call_used_regs[regno]) {\t\\\n-       *fbufp++ = regno; f_regs_used++;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  fbufp--;\t\t\t\t\t\t\t\\\n-  for (regno = 0; regno < 8; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno]\t\t\t\t\t\\\n-\t&& ! call_used_regs[regno])\t\t\t\t\\\n-    {                                                         \t\\\n-      *bufp++ = regno; g_regs_used++;\t\t\t\t\\\n-    }                                                         \t\\\n-  while (fbufp > used_fregs_buf)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if ((*fbufp & 1) && fbufp[0] == fbufp[-1] + 1)\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tmovl tos,f%d\\n\", fbufp[-1] - 8);\t\\\n-\t  fbufp -= 2;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      else fprintf (FILE, \"\\tmovf tos,f%d\\n\", *fbufp-- - 8);\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\texit \");\t\t\t\t\t\\\n-  else if (g_regs_used)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\trestore \");\t\t\t\t\\\n-  if (g_regs_used || frame_pointer_needed)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      char mask = 0;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      while (bufp > used_regs_buf)\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  /* Utek assembler takes care of reversing this */\t\\\n-\t  mask |= 1 << *--bufp;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"$0x%x\\n\", (int) mask & 0xff);\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (current_function_pops_args)\t\t\t\t\\\n-    fprintf (FILE, \"\\tret %d\\n\", current_function_pops_args);\t\\\n-  else fprintf (FILE, \"\\tret 0\\n\"); }\n-\n #endif /* UTEK_ASM */\n \n #undef PRINT_OPERAND_ADDRESS"}, {"sha": "ca84f6e3feb60379b239422a2e179d1f99b2988d", "filename": "gcc/config/ns32k/ns32k.c", "status": "modified", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -65,13 +65,393 @@ static rtx gen_indexed_expr PARAMS ((rtx, rtx, rtx));\n static const char *singlemove_string PARAMS ((rtx *));\n static void move_tail PARAMS ((rtx[], int, int));\n static int ns32k_valid_type_attribute_p PARAMS ((tree, tree, tree, tree));\n+static void ns32k_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void ns32k_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_VALID_TYPE_ATTRIBUTE\n #define TARGET_VALID_TYPE_ATTRIBUTE ns32k_valid_type_attribute_p\n \n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE ns32k_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE ns32k_output_function_epilogue\n+\n struct gcc_target target = TARGET_INITIALIZER;\n \f\n+/* Generate the assembly code for function entry.  FILE is a stdio\n+   stream to output the code to.  SIZE is an int: how many units of\n+   temporary storage to allocate.\n+\n+   Refer to the array `regs_ever_live' to determine which registers to\n+   save; `regs_ever_live[I]' is nonzero if register number I is ever\n+   used in the function.  This function is responsible for knowing\n+   which registers should not be saved even if used.  */\n+\n+/*\n+ * The function prologue for the ns32k is fairly simple.\n+ * If a frame pointer is needed (decided in reload.c ?) then\n+ * we need assembler of the form\n+ *\n+ *  # Save the oldframe pointer, set the new frame pointer, make space\n+ *  # on the stack and save any general purpose registers necessary\n+ *\n+ *  enter [<general purpose regs to save>], <local stack space>\n+ *\n+ *  movf  fn, tos    # Save any floating point registers necessary\n+ *  .\n+ *  .\n+ *\n+ * If a frame pointer is not needed we need assembler of the form\n+ *\n+ *  # Make space on the stack\n+ *\n+ *  adjspd <local stack space + 4>\n+ *\n+ *  # Save any general purpose registers necessary\n+ *\n+ *  save [<general purpose regs to save>]\n+ *\n+ *  movf  fn, tos    # Save any floating point registers necessary\n+ *  .\n+ *  .\n+ */\n+\n+#if !defined (MERLIN_TARGET) && !defined (UTEK_ASM)\n+\n+#if defined(IMMEDIATE_PREFIX) && IMMEDIATE_PREFIX\n+#define ADJSP(FILE, N) \\\n+        fprintf (FILE, \"\\tadjspd %c%d\\n\", IMMEDIATE_PREFIX, (N))\n+#else\n+#define ADJSP(FILE, N) \\\n+        fprintf (FILE, \"\\tadjspd %d\\n\", (N))\n+#endif\n+\n+static void\n+ns32k_output_function_prologue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size;\n+{\n+  register int regno, g_regs_used = 0;\n+  int used_regs_buf[8], *bufp = used_regs_buf;\n+  int used_fregs_buf[17], *fbufp = used_fregs_buf;\n+  extern char call_used_regs[];\n+\n+  for (regno = R0_REGNUM; regno < F0_REGNUM; regno++)\n+    if (regs_ever_live[regno]\n+\t&& ! call_used_regs[regno])\n+      {\n+        *bufp++ = regno; g_regs_used++;\n+      }\n+  *bufp = -1;\n+\n+  for (; regno < FRAME_POINTER_REGNUM; regno++)\n+    if (regs_ever_live[regno] && !call_used_regs[regno])\n+      {\n+        *fbufp++ = regno;\n+      }\n+  *fbufp = -1;\n+\n+  bufp = used_regs_buf;\n+  if (frame_pointer_needed)\n+    fprintf (file, \"\\tenter [\");\n+  else\n+    {\n+      if (size)\n+        ADJSP (file, size + 4);\n+      if (g_regs_used && g_regs_used > 4)\n+        fprintf (file, \"\\tsave [\");\n+      else\n+\t{\n+\t  while (*bufp >= 0)\n+            fprintf (file, \"\\tmovd r%d,tos\\n\", *bufp++);\n+\t  g_regs_used = 0;\n+\t}\n+    }\n+\n+  while (*bufp >= 0)\n+    {\n+      fprintf (file, \"r%d\", *bufp++);\n+      if (*bufp >= 0)\n+\tfputc (',', file);\n+    }\n+\n+  if (frame_pointer_needed)\n+    fprintf (file, \"],%d\\n\", size);\n+  else if (g_regs_used)\n+    fprintf (file, \"]\\n\");\n+\n+  fbufp = used_fregs_buf;\n+  while (*fbufp >= 0)\n+    {\n+      if ((*fbufp & 1) || (fbufp[0] != fbufp[1] - 1))\n+\tfprintf (file, \"\\tmovf %s,tos\\n\", ns32k_out_reg_names[*fbufp++]);\n+      else\n+\t{\n+\t  fprintf (file, \"\\tmovl %s,tos\\n\",\n+\t\t   ns32k_out_reg_names[fbufp[0]]);\n+\t  fbufp += 2;\n+\t}\n+    }\n+\n+  if (flag_pic && current_function_uses_pic_offset_table)\n+    {\n+      fprintf (file, \"\\tsprd sb,tos\\n\");\n+      if (TARGET_REGPARM)\n+\t{\n+\t  fprintf (file, \"\\taddr __GLOBAL_OFFSET_TABLE_(pc),tos\\n\");\n+\t  fprintf (file, \"\\tlprd sb,tos\\n\");\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\taddr __GLOBAL_OFFSET_TABLE_(pc),r0\\n\");\n+\t  fprintf (file, \"\\tlprd sb,r0\\n\");\n+\t}\n+    }\n+}\n+\n+#else /* MERLIN_TARGET || UTEK_ASM  */\n+\n+/* This differs from the standard one above in printing a bitmask\n+   rather than a register list in the enter or save instruction.  */\n+\n+static void\n+ns32k_output_function_prologue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size;\n+{\n+  register int regno, g_regs_used = 0;\n+  int used_regs_buf[8], *bufp = used_regs_buf;\n+  int used_fregs_buf[8], *fbufp = used_fregs_buf;\n+  extern char call_used_regs[];\n+\n+  for (regno = 0; regno < 8; regno++)\n+    if (regs_ever_live[regno]\n+\t&& ! call_used_regs[regno])\n+      {\n+\t*bufp++ = regno; g_regs_used++;\n+      }\n+  *bufp = -1;\n+\n+  for (; regno < 16; regno++)\n+    if (regs_ever_live[regno] && !call_used_regs[regno]) {\n+      *fbufp++ = regno;\n+    }\n+  *fbufp = -1;\n+\n+  bufp = used_regs_buf;\n+  if (frame_pointer_needed)\n+    fprintf (file, \"\\tenter \");\n+  else if (g_regs_used)\n+    fprintf (file, \"\\tsave \");\n+\n+  if (frame_pointer_needed || g_regs_used)\n+    {\n+      char mask = 0;\n+      while (*bufp >= 0)\n+\tmask |= 1 << *bufp++;\n+      fprintf (file, \"$0x%x\", (int) mask & 0xff);\n+    }\n+\n+  if (frame_pointer_needed)\n+#ifdef UTEK_ASM\n+    fprintf (file, \",$%d\\n\", size);\n+#else\n+    fprintf (file, \",%d\\n\", size);\n+#endif\n+  else if (g_regs_used)\n+    fprintf (file, \"\\n\");\n+\n+  fbufp = used_fregs_buf;\n+  while (*fbufp >= 0)\n+    {\n+      if ((*fbufp & 1) || (fbufp[0] != fbufp[1] - 1))\n+\tfprintf (file, \"\\tmovf f%d,tos\\n\", *fbufp++ - 8);\n+      else\n+\t{\n+\t  fprintf (file, \"\\tmovl f%d,tos\\n\", fbufp[0] - 8);\n+\t  fbufp += 2;\n+\t}\n+    }\n+}\n+\n+#endif /* MERLIN_TARGET || UTEK_ASM  */\n+\n+/* This function generates the assembly code for function exit,\n+   on machines that need it.\n+\n+   The function epilogue should not depend on the current stack pointer,\n+   if EXIT_IGNORE_STACK is nonzero.  That doesn't apply here.\n+\n+   If a frame pointer is needed (decided in reload.c ?) then\n+   we need assembler of the form\n+\n+    movf  tos, fn\t# Restore any saved floating point registers\n+    .\n+    .\n+\n+    # Restore any saved general purpose registers, restore the stack\n+    # pointer from the frame pointer, restore the old frame pointer.\n+    exit [<general purpose regs to save>]\n+\n+   If a frame pointer is not needed we need assembler of the form\n+    # Restore any general purpose registers saved\n+\n+    movf  tos, fn\t# Restore any saved floating point registers\n+    .\n+    .\n+    .\n+    restore [<general purpose regs to save>]\n+\n+    # reclaim space allocated on stack\n+\n+    adjspd <-(local stack space + 4)> */\n+\n+#if !defined (MERLIN_TARGET) && !defined (UTEK_ASM)\n+\n+static void\n+ns32k_output_function_epilogue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size;\n+{\n+  register int regno, g_regs_used = 0, f_regs_used = 0;\n+  int used_regs_buf[8], *bufp = used_regs_buf;\n+  int used_fregs_buf[17], *fbufp = used_fregs_buf;\n+  extern char call_used_regs[];\n+\n+  if (flag_pic && current_function_uses_pic_offset_table)\n+    fprintf (file, \"\\tlprd sb,tos\\n\");\n+\n+  *fbufp++ = -2;\n+  for (regno = F0_REGNUM; regno < FRAME_POINTER_REGNUM; regno++)\n+    if (regs_ever_live[regno] && !call_used_regs[regno])\n+      {\n+\t*fbufp++ = regno; f_regs_used++;\n+      }\n+  fbufp--;\n+\n+  for (regno = 0; regno < F0_REGNUM; regno++)\n+    if (regs_ever_live[regno]\n+\t&& ! call_used_regs[regno])\n+      {\n+        *bufp++ = regno; g_regs_used++;\n+      }\n+\n+  while (fbufp > used_fregs_buf)\n+    {\n+      if ((*fbufp & 1) && fbufp[0] == fbufp[-1] + 1)\n+\t{\n+\t  fprintf (file, \"\\tmovl tos,%s\\n\",\n+\t\t   ns32k_out_reg_names[fbufp[-1]]);\n+\t  fbufp -= 2;\n+\t}\n+      else fprintf (file, \"\\tmovf tos,%s\\n\", ns32k_out_reg_names[*fbufp--]);\n+    }\n+\n+  if (frame_pointer_needed)\n+    fprintf (file, \"\\texit [\");\n+  else\n+    {\n+      if (g_regs_used && g_regs_used > 4)\n+        fprintf (file, \"\\trestore [\");\n+      else\n+        {\n+\t  while (bufp > used_regs_buf)\n+            fprintf (file, \"\\tmovd tos,r%d\\n\", *--bufp);\n+\t  g_regs_used = 0;\n+        }\n+    }\n+\n+  while (bufp > used_regs_buf)\n+    {\n+      fprintf (file, \"r%d\", *--bufp);\n+      if (bufp > used_regs_buf)\n+\tfputc (',', file);\n+    }\n+\n+  if (g_regs_used || frame_pointer_needed)\n+    fprintf (file, \"]\\n\");\n+\n+  if (size && !frame_pointer_needed)\n+    ADJSP (file, -(size + 4));\n+\n+  if (current_function_pops_args)\n+    fprintf (file, \"\\tret %d\\n\", current_function_pops_args);\n+  else\n+    fprintf (file, \"\\tret 0\\n\");\n+}\n+\n+#else /* MERLIN_TARGET || UTEK_ASM  */\n+\n+/* This differs from the standard one above in printing a bitmask\n+   rather than a register list in the exit or restore instruction.  */\n+\n+static void\n+ns32k_output_function_epilogue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+{\n+  register int regno, g_regs_used = 0, f_regs_used = 0;\n+  int used_regs_buf[8], *bufp = used_regs_buf;\n+  int used_fregs_buf[8], *fbufp = used_fregs_buf;\n+  extern char call_used_regs[];\n+\n+  *fbufp++ = -2;\n+  for (regno = 8; regno < 16; regno++)\n+    if (regs_ever_live[regno] && !call_used_regs[regno]) {\n+      *fbufp++ = regno; f_regs_used++;\n+    }\n+  fbufp--;\n+\n+  for (regno = 0; regno < 8; regno++)\n+    if (regs_ever_live[regno]\n+\t&& ! call_used_regs[regno])\n+      {\n+\t*bufp++ = regno; g_regs_used++;\n+      }\n+\n+  while (fbufp > used_fregs_buf)\n+    {\n+      if ((*fbufp & 1) && fbufp[0] == fbufp[-1] + 1)\n+\t{\n+\t  fprintf (file, \"\\tmovl tos,f%d\\n\", fbufp[-1] - 8);\n+\t  fbufp -= 2;\n+\t}\n+      else fprintf (file, \"\\tmovf tos,f%d\\n\", *fbufp-- - 8);\n+    }\n+\n+  if (frame_pointer_needed)\n+    fprintf (file, \"\\texit \");\n+  else if (g_regs_used)\n+    fprintf (file, \"\\trestore \");\n+\n+  if (g_regs_used || frame_pointer_needed)\n+    {\n+      char mask = 0;\n+\n+      while (bufp > used_regs_buf)\n+\t{\n+\t  /* Utek assembler takes care of reversing this */\n+\t  mask |= 1 << *--bufp;\n+\t}\n+      fprintf (file, \"$0x%x\\n\", (int) mask & 0xff);\n+    }\n+\n+#ifdef UTEK_ASM\n+  if (current_function_pops_args)\n+    fprintf (file, \"\\tret $%d\\n\", current_function_pops_args);\n+  else\n+    fprintf (file, \"\\tret $0\\n\");\n+#else\n+  if (current_function_pops_args)\n+    fprintf (file, \"\\tret %d\\n\", current_function_pops_args);\n+  else\n+    fprintf (file, \"\\tret 0\\n\");\n+#endif\n+}\n+\n+#endif /* MERLIN_TARGET || UTEK_ASM  */\n+\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */ \n int\n hard_regno_mode_ok (regno, mode)"}, {"sha": "778644c5a4183997363d97a79087dccf301c60f5", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 1, "deletions": 204, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -678,119 +678,6 @@ enum reg_class\n \t\t      : GET_MODE_SIZE (MODE))))  \t\t\\\n  ? 2 - (CUM) / 4 : 0)\n \n-#ifndef MAIN_FUNCTION_PROLOGUE\n-#define MAIN_FUNCTION_PROLOGUE\n-#endif\n-\n-/*\n- * The function prologue for the ns32k is fairly simple.\n- * If a frame pointer is needed (decided in reload.c ?) then\n- * we need assembler of the form\n- *\n- *  # Save the oldframe pointer, set the new frame pointer, make space\n- *  # on the stack and save any general purpose registers necessary\n- *\n- *  enter [<general purpose regs to save>], <local stack space>\n- *\n- *  movf  fn, tos    # Save any floating point registers necessary\n- *  .\n- *  .\n- *\n- * If a frame pointer is not needed we need assembler of the form\n- *\n- *  # Make space on the stack\n- *\n- *  adjspd <local stack space + 4>\n- *\n- *  # Save any general purpose registers necessary\n- *\n- *  save [<general purpose regs to save>]\n- *\n- *  movf  fn, tos    # Save any floating point registers necessary\n- *  .\n- *  .\n- */\n-#if defined(IMMEDIATE_PREFIX) && IMMEDIATE_PREFIX\n-#define ADJSP(FILE, N) \\\n-        fprintf (FILE, \"\\tadjspd %c%d\\n\", IMMEDIATE_PREFIX, (N))\n-#else\n-#define ADJSP(FILE, N) \\\n-        fprintf (FILE, \"\\tadjspd %d\\n\", (N))\n-#endif\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n-{ register int regno, g_regs_used = 0;\t\t\t\t\\\n-  int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n-  int used_fregs_buf[17], *fbufp = used_fregs_buf;\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  MAIN_FUNCTION_PROLOGUE;\t\t\t\t\t\\\n-  for (regno = R0_REGNUM; regno < F0_REGNUM; regno++)\t\t\\\n-    if (regs_ever_live[regno]\t\t\t\t\t\\\n-\t&& ! call_used_regs[regno])\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-        *bufp++ = regno; g_regs_used++;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-  *bufp = -1;\t\t\t\t\t\t\t\\\n-  for (; regno < FRAME_POINTER_REGNUM; regno++)\t\t\t\\\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-        *fbufp++ = regno;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-  *fbufp = -1;\t\t\t\t\t\t\t\\\n-  bufp = used_regs_buf;\t\t\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tenter [\");\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (SIZE)\t\t\t\t\t\t\t\\\n-        ADJSP (FILE, SIZE + 4);\t\t\t\t\t\\\n-      if (g_regs_used && g_regs_used > 4)\t\t\t\\\n-        fprintf (FILE, \"\\tsave [\");\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  while (*bufp >= 0)\t\t\t\t\t\\\n-            fprintf (FILE, \"\\tmovd r%d,tos\\n\", *bufp++);\t\\\n-\t  g_regs_used = 0;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (*bufp >= 0)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"r%d\", *bufp++);\t\t\t\t\\\n-      if (*bufp >= 0)\t\t\t\t\t\t\\\n-\tfputc (',', FILE);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    fprintf (FILE, \"],%d\\n\", SIZE);\t\t\t\t\\\n-  else if (g_regs_used)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"]\\n\");\t\t\t\t\t\\\n-  fbufp = used_fregs_buf;\t\t\t\t\t\\\n-  while (*fbufp >= 0)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if ((*fbufp & 1) || (fbufp[0] != fbufp[1] - 1))\t\\\n-\tfprintf (FILE, \"\\tmovf %s,tos\\n\", ns32k_out_reg_names[*fbufp++]); \\\n-      else\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tmovl %s,tos\\n\",                     \\\n-\t\t   ns32k_out_reg_names[fbufp[0]]);                    \\\n-\t  fbufp += 2;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (flag_pic && current_function_uses_pic_offset_table)\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tsprd sb,tos\\n\");\t\t\t\\\n-      if (TARGET_REGPARM)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\taddr __GLOBAL_OFFSET_TABLE_(pc),tos\\n\"); \\\n-\t  fprintf (FILE, \"\\tlprd sb,tos\\n\");\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\taddr __GLOBAL_OFFSET_TABLE_(pc),r0\\n\"); \\\n-\t  fprintf (FILE, \"\\tlprd sb,r0\\n\");\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.\n \n@@ -804,101 +691,11 @@ enum reg_class\n    functions that have frame pointers.\n    No definition is equivalent to always zero.\n \n-   We use 0, because using 1 requires hair in FUNCTION_EPILOGUE\n+   We use 0, because using 1 requires hair in output_function_epilogue()\n    that is worse than the stack adjust we could save.  */\n \n /* #define EXIT_IGNORE_STACK 1 */\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer,\n-   if EXIT_IGNORE_STACK is nonzero.  That doesn't apply here.\n-\n-   If a frame pointer is needed (decided in reload.c ?) then\n-   we need assembler of the form\n-\n-    movf  tos, fn\t# Restore any saved floating point registers\n-    .\n-    .\n-\n-    # Restore any saved general purpose registers, restore the stack\n-    # pointer from the frame pointer, restore the old frame pointer.\n-    exit [<general purpose regs to save>]\n-\n-   If a frame pointer is not needed we need assembler of the form\n-    # Restore any general purpose registers saved\n-\n-    movf  tos, fn\t# Restore any saved floating point registers\n-    .\n-    .\n-    .\n-    restore [<general purpose regs to save>]\n-\n-    # reclaim space allocated on stack\n-\n-    adjspd <-(local stack space + 4)> */\n-\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-{ register int regno, g_regs_used = 0, f_regs_used = 0;\t\t\\\n-  int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n-  int used_fregs_buf[17], *fbufp = used_fregs_buf;\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  if (flag_pic && current_function_uses_pic_offset_table)\t\\\n-    fprintf (FILE, \"\\tlprd sb,tos\\n\");\t\t\t\t\\\n-  *fbufp++ = -2;\t\t\t\t\t\t\\\n-  for (regno = F0_REGNUM; regno < FRAME_POINTER_REGNUM; regno++) \\\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-       *fbufp++ = regno; f_regs_used++;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-  fbufp--;\t\t\t\t\t\t\t\\\n-  for (regno = 0; regno < F0_REGNUM; regno++)\t\t\t\\\n-    if (regs_ever_live[regno]\t\t\t\t\t\\\n-\t&& ! call_used_regs[regno])\t\t\t\t\\\n-      {                                                        \t\\\n-        *bufp++ = regno; g_regs_used++;\t\t\t\t\\\n-      }                                                        \t\\\n-  while (fbufp > used_fregs_buf)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if ((*fbufp & 1) && fbufp[0] == fbufp[-1] + 1)\t        \\\n-\t{\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tmovl tos,%s\\n\",                     \\\n-\t\t   ns32k_out_reg_names[fbufp[-1]]);                   \\\n-\t  fbufp -= 2;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      else fprintf (FILE, \"\\tmovf tos,%s\\n\", ns32k_out_reg_names[*fbufp--]); \\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\texit [\");\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (g_regs_used && g_regs_used > 4)\t\t\t\\\n-        fprintf (FILE, \"\\trestore [\");\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-\t  while (bufp > used_regs_buf)\t\t\t\t\\\n-            fprintf (FILE, \"\\tmovd tos,r%d\\n\", *--bufp);\t\\\n-\t  g_regs_used = 0;\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (bufp > used_regs_buf)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"r%d\", *--bufp);\t\t\t\t\\\n-      if (bufp > used_regs_buf)\t\t\t\t\t\\\n-\tfputc (',', FILE);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (g_regs_used || frame_pointer_needed)\t\t\t\\\n-    fprintf (FILE, \"]\\n\");\t\t\t\t\t\\\n-  if (SIZE && !frame_pointer_needed)\t\t\t\t\\\n-    ADJSP (FILE, -(SIZE + 4));\t\t\t\t\t\\\n-  if (current_function_pops_args)\t\t\t\t\\\n-    fprintf (FILE, \"\\tret %d\\n\", current_function_pops_args);\t\\\n-  else fprintf (FILE, \"\\tret 0\\n\"); }\n-\n /* Store in the variable DEPTH the initial difference between the\n    frame pointer reg contents and the stack pointer reg contents,\n    as of the start of the function body.  This depends on the layout"}, {"sha": "219d9198903861aa79f98d30c140873dd2c21173", "filename": "gcc/config/ns32k/tek6000.h", "status": "modified", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fns32k%2Ftek6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fns32k%2Ftek6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Ftek6000.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -112,107 +112,6 @@ Boston, MA 02111-1307, USA.  */\n #define SHARED_SECTION_ASM_OP \"\\t.shdata\"\n \n #ifdef UTEK_ASM\n-#undef  FUNCTION_PROLOGUE\n-\n-/* This differs from the one in ns32k.h in printing a bitmask\n-   rather than a register list in the enter or save instruction.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n-{ register int regno, g_regs_used = 0;\t\t\t\t\\\n-  int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n-  int used_fregs_buf[8], *fbufp = used_fregs_buf;\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  MAIN_FUNCTION_PROLOGUE;\t\t\t\t\t\\\n-  for (regno = 0; regno < 8; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno]\t\t\t\t\t\\\n-\t&& ! call_used_regs[regno])\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      *bufp++ = regno; g_regs_used++;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  *bufp = -1;\t\t\t\t\t\t\t\\\n-  for (; regno < 16; regno++)\t\t\t\t\t\\\n-    if (regs_ever_live[regno] && !call_used_regs[regno]) {\t\\\n-      *fbufp++ = regno;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  *fbufp = -1;\t\t\t\t\t\t\t\\\n-  bufp = used_regs_buf;\t\t\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tenter \");\t\t\t\t\t\\\n-  else if (g_regs_used)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tsave \");\t\t\t\t\t\\\n-  if (frame_pointer_needed || g_regs_used)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      char mask = 0;\t\t\t\t\t\t\\\n-      while (*bufp >= 0)\t\t\t\t\t\\\n-\tmask |= 1 << *bufp++;\t\t\t\t\t\\\n-      fprintf (FILE, \"$0x%x\", (int) mask & 0xff);\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    fprintf (FILE, \",$%d\\n\", SIZE);\t\t\t\t\\\n-  else if (g_regs_used)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n-  fbufp = used_fregs_buf;\t\t\t\t\t\\\n-  while (*fbufp >= 0)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if ((*fbufp & 1) || (fbufp[0] != fbufp[1] - 1))\t\t\\\n-\tfprintf (FILE, \"\\tmovf f%d,tos\\n\", *fbufp++ - 8);\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tmovl f%d,tos\\n\", fbufp[0] - 8);\t\\\n-\t  fbufp += 2;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-\n-#undef  FUNCTION_EPILOGUE\n-\n-/* This differs from the one in ns32k.h in printing a bitmask\n-   rather than a register list in the exit or restore instruction.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-{ register int regno, g_regs_used = 0, f_regs_used = 0;\t\t\\\n-  int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n-  int used_fregs_buf[8], *fbufp = used_fregs_buf;\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  *fbufp++ = -2;\t\t\t\t\t\t\\\n-  for (regno = 8; regno < 16; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && !call_used_regs[regno]) {\t\\\n-       *fbufp++ = regno; f_regs_used++;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  fbufp--;\t\t\t\t\t\t\t\\\n-  for (regno = 0; regno < 8; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno]\t\t\t\t\t\\\n-\t&& ! call_used_regs[regno])\t\t\t\t\\\n-    {                                                         \t\\\n-      *bufp++ = regno; g_regs_used++;\t\t\t\t\\\n-    }                                                         \t\\\n-  while (fbufp > used_fregs_buf)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if ((*fbufp & 1) && fbufp[0] == fbufp[-1] + 1)\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tmovl tos,f%d\\n\", fbufp[-1] - 8);\t\\\n-\t  fbufp -= 2;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      else fprintf (FILE, \"\\tmovf tos,f%d\\n\", *fbufp-- - 8);\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\texit \");\t\t\t\t\t\\\n-  else if (g_regs_used)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\trestore \");\t\t\t\t\\\n-  if (g_regs_used || frame_pointer_needed)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      char mask = 0;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      while (bufp > used_regs_buf)\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  /* Utek assembler takes care of reversing this */\t\\\n-\t  mask |= 1 << *--bufp;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"$0x%x\\n\", (int) mask & 0xff);\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (current_function_pops_args)\t\t\t\t\\\n-    fprintf (FILE, \"\\tret $%d\\n\", current_function_pops_args);\t\\\n-  else fprintf (FILE, \"\\tret $0\\n\"); }\n \n /* UTek assembler needs \"ret $0\", not \"ret 0\". */\n #undef  TRANSFER_FROM_TRAMPOLINE"}, {"sha": "6446f5b2a23515b303ec5ec6cbbe88d0f8978f74", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -132,8 +132,6 @@ extern struct rtx_def *hppa_builtin_saveregs PARAMS ((void));\n extern void output_deferred_plabels PARAMS ((FILE *));\n extern void override_options PARAMS ((void));\n extern void output_ascii PARAMS ((FILE *, const unsigned char *, int));\n-extern void output_function_prologue PARAMS ((FILE *, int));\n-extern void output_function_epilogue PARAMS ((FILE *, int));\n extern int compute_frame_size PARAMS ((int, int *));\n extern int and_mask_p PARAMS ((unsigned HOST_WIDE_INT));\n extern int cint_ok_for_move PARAMS ((HOST_WIDE_INT));"}, {"sha": "04233835cdeeb7f391b6c3134df94a4dae94a886", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -68,6 +68,8 @@ static void remove_useless_addtr_insns PARAMS ((rtx, int));\n static rtx store_reg PARAMS ((int, int, int));\n static rtx load_reg PARAMS ((int, int, int));\n static rtx set_reg_plus_d PARAMS ((int, int, int));\n+static void pa_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void pa_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n@@ -109,6 +111,10 @@ struct deferred_plabel\n int n_deferred_plabels = 0;\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE pa_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE pa_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -2778,7 +2784,7 @@ remove_useless_addtr_insns (insns, check_notes)\n \n */\n \n-/* Global variables set by FUNCTION_PROLOGUE.  */\n+/* Global variables set by output_function_prologue().  */\n /* Size of frame.  Need to know this to emit return insns from\n    leaf procedures.  */\n static int actual_fsize;\n@@ -2893,10 +2899,27 @@ compute_frame_size (size, fregs_live)\n   return (fsize + STACK_BOUNDARY - 1) & ~(STACK_BOUNDARY - 1);\n }\n \n-void\n-output_function_prologue (file, size)\n+/* Generate the assembly code for function entry.  FILE is a stdio\n+   stream to output the code to.  SIZE is an int: how many units of\n+   temporary storage to allocate.\n+\n+   Refer to the array `regs_ever_live' to determine which registers to\n+   save; `regs_ever_live[I]' is nonzero if register number I is ever\n+   used in the function.  This function is responsible for knowing\n+   which registers should not be saved even if used.  */\n+\n+/* On HP-PA, move-double insns between fpu and cpu need an 8-byte block\n+   of memory.  If any fpu reg is used in the function, we allocate\n+   such a block here, at the bottom of the frame, just in case it's needed.\n+\n+   If this function is a leaf procedure, then we may choose not\n+   to do a \"save\" insn.  The decision about whether or not\n+   to do this is made in regclass.c.  */\n+\n+static void\n+pa_output_function_prologue (file, size)\n      FILE *file;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   /* The function's label and associated .PROC must never be\n      separated and must be output *after* any profiling declarations\n@@ -3213,10 +3236,18 @@ load_reg (reg, disp, base)\n   return i;\n }\n \n-void\n-output_function_epilogue (file, size)\n+/* This function generates the assembly code for function exit.\n+   Args are as for output_function_prologue ().\n+\n+   The function epilogue should not depend on the current stack\n+   pointer!  It should use the frame pointer only.  This is mandatory\n+   because of alloca; we also take advantage of it to omit stack\n+   adjustments before returning. */\n+\n+static void\n+pa_output_function_epilogue (file, size)\n      FILE *file;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   rtx insn = get_last_insn ();\n "}, {"sha": "380b6d2b7d40b6fbff113fd3e015fb53b3ed34bd", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -887,25 +887,6 @@ extern enum cmp_type hppa_branch_type;\n   fprintf (FILE, \"\\n\\t.EXIT\\n\\t.PROCEND\\n\"); \\\n }\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-/* On HP-PA, move-double insns between fpu and cpu need an 8-byte block\n-   of memory.  If any fpu reg is used in the function, we allocate\n-   such a block here, at the bottom of the frame, just in case it's needed.\n-\n-   If this function is a leaf procedure, then we may choose not\n-   to do a \"save\" insn.  The decision about whether or not\n-   to do this is made in regclass.c.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n-  output_function_prologue (FILE, SIZE)\n-\n /* On HPPA, we emit profiling code as rtl via PROFILE_HOOK rather than\n    as assembly via FUNCTION_PROFILER.  */\n \n@@ -925,20 +906,6 @@ extern int may_call_alloca;\n  (get_frame_size () != 0\t\\\n   || current_function_calls_alloca || current_function_outgoing_args_size)\n \n-\n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\\\n-  output_function_epilogue (FILE, SIZE)\n-\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.\\\n "}, {"sha": "1994d803a5ba32f389e7ebecee7a4704fcdac1ef", "filename": "gcc/config/pdp11/2bsd.h", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpdp11%2F2bsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpdp11%2F2bsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2F2bsd.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -19,18 +19,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* This macro generates the assembly code for function entry. */\n-#undef FUNCTION_PROLOGUE\n-#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n-do {\t\t\t\t\t\t\t\t\t\\\n-fprintf(FILE, \"\\tjsr\tr5, csv\\n\");\t\t\t\t\t\\\n-if ((SIZE) != 0)\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    fprintf(FILE, \"\\t/*abuse empty parameter slot for locals!*/\\n\");\t\\\n-    if ((SIZE) > 2)\t\t\t\t\t\t\t\\\n-      fprintf(FILE, \"\\tsub $%d, sp\\n\", (SIZE)-2);\t\t\t\\\n-  };\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+#define TWO_BSD\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n@@ -40,19 +29,6 @@ if ((SIZE) != 0)\t\t\t\t\t\t\t\\\n #undef EXIT_IGNORE_STACK\n #define EXIT_IGNORE_STACK\t1\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-*/\n-\n-#undef FUNCTION_EPILOGUE\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-do {                                                                    \\\n-fprintf(FILE, \"\\t/* SP ignored by cret? */\\n\");     \t\t\t\\\n-fprintf(FILE, \"\\tjmp cret\\n\");                                    \t\\\n-} while (0)\n-\n #undef INITIAL_FRAME_POINTER_OFFSET  \n #define INITIAL_FRAME_POINTER_OFFSET(DEPTH_VAR)\t\\\n {\t\t\t\t\t\t\t\t\\"}, {"sha": "e2031c3ab81d7c35cc7de5192c5f7e96589ee4dd", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -40,6 +40,4 @@ extern int comparison_operator_index PARAMS ((rtx));\n #endif /* RTX_CODE */\n \n extern void output_ascii PARAMS ((FILE *, const char *, int));\n-extern void output_function_epilogue PARAMS ((FILE *, int));\n-extern void output_function_prologue PARAMS ((FILE *, int));\n extern const char *output_jump PARAMS ((const char *, const char *, int));"}, {"sha": "2fdf0b05796157589c5989ef0f34b52b569c6019", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 56, "deletions": 14, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -52,8 +52,14 @@ int current_first_parm_offset;\n \n static rtx find_addr_reg PARAMS ((rtx)); \n static const char *singlemove_string PARAMS ((rtx *)); \n+static void pdp11_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void pdp11_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE pdp11_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE pdp11_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -102,23 +108,43 @@ expand_shift_operand (op, mode)\n    knowing which registers should not be saved even if used.  \n */\n \n-void \n-output_function_prologue(stream, size)\n-  FILE *stream;\n-  int size;\n+#ifdef TWO_BSD\n+\n+static void\n+pdp11_output_function_prologue (stream, size)\n+     FILE *stream;\n+     HOST_WIDE_INT size;\n {\t\t\t\t\t\t\t       \n-    int fsize = ((size) + 1) & ~1;      \t\t\t\t\n-    int regno;\n+  fprintf (stream, \"\\tjsr\tr5, csv\\n\");\n+  if (size)\n+    {\n+      fprintf (stream, \"\\t/*abuse empty parameter slot for locals!*/\\n\");\n+      if (size > 2)\n+\tfprintf(stream, \"\\tsub $%d, sp\\n\", size - 2);\n \n+    }\n+}\n+\n+#else  /* !TWO_BSD */\n+\n+static void\n+pdp11_output_function_prologue (stream, size)\n+     FILE *stream;\n+     HOST_WIDE_INT size;\n+{\t\t\t\t\t\t\t       \n+    HOST_WIDE_INT fsize = ((size) + 1) & ~1;\n+    int regno;\n     int via_ac = -1;\n-    \n-    fprintf (stream, \"\\n\\t;\t/* function prologue %s*/\\n\", current_function_name);\t\t\n+\n+    fprintf (stream,\n+\t     \"\\n\\t;\t/* function prologue %s*/\\n\", current_function_name);\n \n     /* if we are outputting code for main, \n        the switch FPU to right mode if TARGET_FPU */\n     if (MAIN_NAME_P (DECL_NAME (current_function_decl)) && TARGET_FPU)\n     {\n-\tfprintf(stream, \"\\t;/* switch cpu to double float, single integer */\\n\");\n+\tfprintf(stream,\n+\t\t\"\\t;/* switch cpu to double float, single integer */\\n\");\n \tfprintf(stream, \"\\tsetd\\n\");\n \tfprintf(stream, \"\\tseti\\n\\n\");\n     }\n@@ -176,6 +202,8 @@ output_function_prologue(stream, size)\n     fprintf (stream, \"\\t;/* end of prologue */\\n\\n\");\t\t\n }\n \n+#endif /* !TWO_BSD */\n+\n /*\n    The function epilogue should not depend on the current stack pointer!\n    It should use the frame pointer only.  This is mandatory because\n@@ -195,13 +223,25 @@ output_function_prologue(stream, size)\n \n    maybe as option if you want to generate code for kernel mode? */\n \n+#ifdef TWO_BSD\n+\n+static void\n+pdp11_output_function_epilogue (stream, size)\n+     FILE *stream;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+{\t\t\t\t\t\t\t\t\n+  fprintf (stream, \"\\t/* SP ignored by cret? */\\n\");\n+  fprintf (stream, \"\\tjmp cret\\n\");\n+}\n \n-void \n-output_function_epilogue(stream, size)\n-  FILE *stream;\n-  int size;\n+#else  /* !TWO_BSD */\n+\n+static void\n+pdp11_output_function_epilogue (stream, size)\n+     FILE *stream;\n+     HOST_WIDE_INT size;\n {\t\t\t\t\t\t\t\t\n-    int fsize = ((size) + 1) & ~1;      \t\t\t\t\n+    HOST_WIDE_INT fsize = ((size) + 1) & ~1;\n     int i, j, k;\n \n     int via_ac;\n@@ -299,6 +339,8 @@ output_function_epilogue(stream, size)\n     fprintf (stream, \"\\trts pc\\n\");\t\t\t\t\t\n     fprintf (stream, \"\\t;/* end of epilogue*/\\n\\n\\n\");\t\t\n }\n+\n+#endif /* !TWO_BSD */\n \t\n /* Return the best assembler insn template\n    for moving operands[1] into operands[0] as a fullword.  */"}, {"sha": "f931b45da4962dda55d033a6781677b14b72f291", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -649,10 +649,6 @@ maybe ac0 ? - as option someday! */\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n-/* This macro generates the assembly code for function entry. */\n-#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n-    output_function_prologue(FILE, SIZE);\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -668,15 +664,6 @@ extern int may_call_alloca;\n \n #define EXIT_IGNORE_STACK\t1\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-*/\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-    output_function_epilogue(FILE, SIZE);\n-  \n #define INITIAL_FRAME_POINTER_OFFSET(DEPTH_VAR)\t\\\n {\t\t\t\t\t\t\t\t\\\n   int offset, regno;\t\t      \t\t\t\t\\"}, {"sha": "fcf2439a54c592e29c28ad1fb7bebd43a5602276", "filename": "gcc/config/romp/romp-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fromp%2Fromp-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fromp%2Fromp-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -55,9 +55,7 @@ extern int romp_using_r14 PARAMS ((void));\n extern int null_epilogue PARAMS ((void));\n extern int romp_sa_size PARAMS ((void));\n extern int romp_makes_calls PARAMS ((void));\n-extern void output_prolog PARAMS ((FILE *, int));\n extern void output_encoded_offset PARAMS ((FILE *, unsigned));\n-extern void output_epilog PARAMS ((FILE *, int));\n extern int romp_debugger_auto_correction PARAMS ((int));\n extern int romp_debugger_arg_correction PARAMS ((int));\n extern const char *output_in_line_mul PARAMS ((void));"}, {"sha": "3fd24b5387f068d917c9d0a6151735bb738e6de5", "filename": "gcc/config/romp/romp.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fromp%2Fromp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fromp%2Fromp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -50,8 +50,14 @@ static void output_fpops PARAMS ((FILE *));\n static void init_fpops PARAMS ((void));\n static int memory_offset_in_range_p PARAMS ((rtx, enum machine_mode, int, int));\n static unsigned int hash_rtx PARAMS ((rtx));\n+static void romp_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void romp_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE romp_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE romp_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -1078,14 +1084,14 @@ romp_pushes_stack ()\n    word for static link, as many words as required for general register\n    save area, plus 2 words for each FP reg 2-7 that must be saved.  */\n \n-void\n-output_prolog (file, size)\n+static void\n+romp_output_function_prologue (file, size)\n      FILE *file;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n   int first_reg;\n   int reg_save_offset;\n-  int fp_save = size + current_function_outgoing_args_size;\n+  HOST_WIDE_INT fp_save = size + current_function_outgoing_args_size;\n \n   init_fpops ();\n \n@@ -1133,7 +1139,7 @@ output_prolog (file, size)\n }\n \f\n /* Output the offset information used by debuggers.\n-   This is the exactly the total_size value of output_epilog\n+   This is the exactly the total_size value of output_function_epilogue()\n    which is added to the frame pointer. However the value in the debug\n    table is encoded in a space-saving way as follows:\n \n@@ -1188,17 +1194,17 @@ output_encoded_offset (file, reg_offset)\n \f\n /* Write function epilogue.  */\n \n-void\n-output_epilog (file, size)\n+static void\n+romp_output_function_epilogue (file, size)\n      FILE *file;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n   int first_reg = first_reg_to_save();\n   int pushes_stack = romp_pushes_stack ();\n   int reg_save_offset = - ((16 - first_reg) + 1 + 4 + 4) * 4;\n-  int total_size = (size + romp_sa_size ()\n-\t\t    + current_function_outgoing_args_size);\n-  int fp_save = size + current_function_outgoing_args_size;\n+  HOST_WIDE_INT total_size = (size + romp_sa_size ()\n+\t\t\t      + current_function_outgoing_args_size);\n+  HOST_WIDE_INT fp_save = size + current_function_outgoing_args_size;\n   int long_frame = total_size >= 32768;\n   rtx insn = get_last_insn ();\n   int write_code = 1;"}, {"sha": "3c82c6545ef1bf7f36a1216281e5f14a1a789896", "filename": "gcc/config/romp/romp.h", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fromp%2Fromp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fromp%2Fromp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -719,16 +719,6 @@ struct rt_cargs {int gregs, fregs; };\n \n #define SELECT_RTX_SECTION(MODE, X)\tdata_section ()\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) output_prolog (FILE, SIZE)\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -740,18 +730,6 @@ struct rt_cargs {int gregs, fregs; };\n    functions that have frame pointers.\n    No definition is equivalent to always zero.  */\n /* #define EXIT_IGNORE_STACK\t1\t*/\n-\n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) output_epilog (FILE, SIZE)\n \f\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts."}, {"sha": "66547b10ba0fa38b45117543a5a4efdfed2bba2c", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -158,8 +158,6 @@ extern union tree_node *rs6000_build_va_list PARAMS ((void));\n extern int first_reg_to_save PARAMS ((void));\n extern int first_fp_reg_to_save PARAMS ((void));\n extern rs6000_stack_t *rs6000_stack_info PARAMS ((void));\n-extern void output_prolog PARAMS ((FILE *, int));\n-extern void output_epilog PARAMS ((FILE *, int));\n extern void output_ascii PARAMS ((FILE *, const char *, int));\n extern void rs6000_gen_section_name PARAMS ((char **, const char *,\n \t\t\t\t\t     const char *));"}, {"sha": "9c77e7a3590af649120e1eade28e17f302460788", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -126,6 +126,8 @@ static void rs6000_free_machine_status PARAMS ((struct function *));\n static void rs6000_init_machine_status PARAMS ((struct function *));\n static int rs6000_ra_ever_killed PARAMS ((void));\n static int rs6000_valid_type_attribute_p PARAMS ((tree, tree, tree, tree));\n+static void rs6000_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void rs6000_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Default register names.  */\n char rs6000_reg_names[][8] =\n@@ -168,6 +170,11 @@ static char alt_reg_names[][8] =\n #undef TARGET_VALID_TYPE_ATTRIBUTE\n #define TARGET_VALID_TYPE_ATTRIBUTE rs6000_valid_type_attribute_p\n \n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE rs6000_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE rs6000_output_function_epilogue\n+\n struct gcc_target target = TARGET_INITIALIZER;\n \f\n /* Override command line options.  Mostly we process the processor\n@@ -6175,10 +6182,10 @@ rs6000_emit_prologue ()\n \n \n /* Write function prologue.  */\n-void\n-output_prolog (file, size)\n+static void\n+rs6000_output_function_prologue (file, size)\n      FILE *file;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   rs6000_stack_t *info = rs6000_stack_info ();\n \n@@ -6532,10 +6539,10 @@ rs6000_emit_epilogue (sibcall)\n \n /* Write function epilogue.  */\n \n-void\n-output_epilog (file, size)\n+static void\n+rs6000_output_function_epilogue (file, size)\n      FILE *file;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   rs6000_stack_t *info = rs6000_stack_info ();\n \n@@ -6793,8 +6800,8 @@ output_epilog (file, size)\n \n    The effect must be as if FUNCTION had been called directly with the adjusted\n    first argument.  This macro is responsible for emitting all of the code for\n-   a thunk function; `FUNCTION_PROLOGUE' and `FUNCTION_EPILOGUE' are not\n-   invoked.\n+   a thunk function; output_function_prologue() and output_function_epilogue()\n+   are not invoked.\n \n    The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already been\n    extracted from it.)  It might possibly be useful on some targets, but"}, {"sha": "eca6be15fc7740dc9073c88cadfd310008f0da04", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1551,16 +1551,6 @@ typedef struct rs6000_args\n    argument is passed depends on whether or not it is a named argument.  */\n #define STRICT_ARGUMENT_NAMING 1\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) output_prolog (FILE, SIZE)\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -1585,18 +1575,6 @@ typedef struct rs6000_args\n    || (current_function_calls_eh_return\t\t\t\t\\\n        && TARGET_AIX\t\t\t\t\t\t\\\n        && (REGNO) == TOC_REGISTER))\n-\n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) output_epilog (FILE, SIZE)\n \f\n /* TRAMPOLINE_TEMPLATE deleted */\n "}, {"sha": "9500e72025cb600ee64331fc507a638ab92df953", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -694,9 +694,10 @@ extern int rs6000_pic_labelno;\n     the return address.  Hence returning from FUNCTION will return to whoever\n     called the current thunk'.\n \n-    The effect must be as if FUNCTION had been called directly with the adjusted\n-    first argument.  This macro is responsible for emitting all of the code for\n-    a thunk function; FUNCTION_PROLOGUE' and FUNCTION_EPILOGUE' are not\n+    The effect must be as if FUNCTION had been called directly with\n+    the adjusted first argument.  This macro is responsible for\n+    emitting all of the code for a thunk function;\n+    output_function_prologue() and output_function_epilogue() are not\n     invoked.\n \n     The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already been"}, {"sha": "5cfec06a91178e6e4b498ccaacf0a05089bee47f", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -116,7 +116,6 @@ extern void output_file_start PARAMS ((FILE *));\n extern void sh_expand_prologue PARAMS ((void));\n extern void sh_expand_epilogue PARAMS ((void));\n extern int sh_need_epilogue PARAMS ((void));\n-extern void function_epilogue PARAMS ((FILE *, int));\n extern int initial_elimination_offset PARAMS ((int, int));\n extern int fldi_ok PARAMS ((void));\n "}, {"sha": "63c0f166a70a452fe7ca5f3d18240f6f36721075", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -154,11 +154,15 @@ static void mark_use PARAMS ((rtx, rtx *));\n static HOST_WIDE_INT rounded_frame_size PARAMS ((int));\n static rtx mark_constant_pool_use PARAMS ((rtx));\n static int sh_valid_decl_attribute PARAMS ((tree, tree, tree, tree));\n+static void sh_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_VALID_DECL_ATTRIBUTE\n #define TARGET_VALID_DECL_ATTRIBUTE sh_valid_decl_attribute\n \n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE sh_output_function_epilogue\n+\n struct gcc_target target = TARGET_INITIALIZER;\n \f\n /* Print the operand address in x to the stream.  */\n@@ -4194,10 +4198,10 @@ sh_need_epilogue ()\n \n /* Clear variables at function end.  */\n \n-void\n-function_epilogue (stream, size)\n-     FILE *stream ATTRIBUTE_UNUSED;\n-     int size ATTRIBUTE_UNUSED;\n+static void\n+sh_output_function_epilogue (file, size)\n+     FILE *file ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   trap_exit = pragma_interrupt = pragma_trapa = pragma_nosave_low_regs = 0;\n   sh_need_epilogue_known = 0;"}, {"sha": "8c34084e1fd20f637868fd52593f2e63af131e50", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1217,11 +1217,6 @@ extern int current_function_anonymous_args;\n \n #define EXIT_IGNORE_STACK 1\n \n-/* Generate the assembly code for function exit\n-   Just dump out any accumulated constant table.  */\n-\n-#define FUNCTION_EPILOGUE(STREAM, SIZE)  function_epilogue ((STREAM), (SIZE))\n-\n /* \n    On the SH, the trampoline looks like\n    2 0002 D202     \t   \tmov.l\tl2,r2"}, {"sha": "b941aa95da080196f2bd4c2cff18ed5ff8d42049", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -53,10 +53,6 @@ extern enum direction function_arg_padding PARAMS ((enum machine_mode, tree));\n extern void ultrasparc_sched_init PARAMS ((FILE *, int));\n extern void load_pic_register PARAMS ((void));\n extern void order_regs_for_local_alloc PARAMS ((void));\n-extern void output_function_epilogue PARAMS ((FILE *, int, int));\n-extern void output_function_prologue PARAMS ((FILE *, int, int));\n-extern void sparc_flat_output_function_epilogue PARAMS ((FILE *, int));\n-extern void sparc_flat_output_function_prologue PARAMS ((FILE *, int));\n extern int compute_frame_size PARAMS ((int, int));\n extern int check_pic PARAMS ((int));\n extern int short_branch PARAMS ((int, int));"}, {"sha": "ad63e331035a01bf32ea1ddb91906ab09d751850", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 76, "deletions": 16, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -156,6 +156,14 @@ static void ultra_flush_pipeline PARAMS ((void));\n static void ultra_rescan_pipeline_state PARAMS ((rtx *, int));\n static int set_extends PARAMS ((rtx));\n static void output_restore_regs PARAMS ((FILE *, int));\n+static void sparc_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void sparc_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void sparc_flat_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void sparc_flat_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void sparc_nonflat_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT,\n+\t\t\t\t\t\t     int));\n+static void sparc_nonflat_function_prologue PARAMS ((FILE *, HOST_WIDE_INT,\n+\t\t\t\t\t\t     int));\n \f\n /* Option handling.  */\n \n@@ -179,6 +187,10 @@ struct sparc_cpu_select sparc_select[] =\n enum processor_type sparc_cpu;\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE sparc_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE sparc_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n@@ -3388,12 +3400,40 @@ sparc_output_scratch_registers (file)\n #endif\n }\n \n+/* This function generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+/* On SPARC, move-double insns between fpu and cpu need an 8-byte block\n+   of memory.  If any fpu reg is used in the function, we allocate\n+   such a block here, at the bottom of the frame, just in case it's needed.\n+\n+   If this function is a leaf procedure, then we may choose not\n+   to do a \"save\" insn.  The decision about whether or not\n+   to do this is made in regclass.c.  */\n+\n+static void\n+sparc_output_function_prologue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size;\n+{\n+  if (TARGET_FLAT)\n+    sparc_flat_function_prologue (file, size);\n+  else\n+    sparc_nonflat_function_prologue (file, size,\n+\t\t\t\t     current_function_uses_only_leaf_regs);\n+}\n+\n /* Output code for the function prologue.  */\n \n-void\n-output_function_prologue (file, size, leaf_function)\n+static void\n+sparc_nonflat_function_prologue (file, size, leaf_function)\n      FILE *file;\n-     int size;\n+     HOST_WIDE_INT size;\n      int leaf_function;\n {\n   sparc_output_scratch_registers (file);\n@@ -3555,12 +3595,32 @@ output_restore_regs (file, leaf_function)\n     restore_regs (file, 32, TARGET_V9 ? 96 : 64, base, offset, n_regs);\n }\n \n+/* This function generates the assembly code for function exit,\n+   on machines that need it.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+static void\n+sparc_output_function_epilogue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size;\n+{\n+  if (TARGET_FLAT)\n+    sparc_flat_function_epilogue (file, size);\n+  else\n+    sparc_nonflat_function_epilogue (file, size,\n+\t\t\t\t     current_function_uses_only_leaf_regs);\n+}\n+\n /* Output code for the function epilogue.  */\n \n-void\n-output_function_epilogue (file, size, leaf_function)\n+static void\n+sparc_nonflat_function_epilogue (file, size, leaf_function)\n      FILE *file;\n-     int size ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n      int leaf_function;\n {\n   const char *ret;\n@@ -6571,10 +6631,10 @@ sparc_flat_save_restore (file, base_reg, offset, gmask, fmask, word_op,\n \f\n /* Set up the stack and frame (if desired) for the function.  */\n \n-void\n-sparc_flat_output_function_prologue (file, size)\n+static void\n+sparc_flat_function_prologue (file, size)\n      FILE *file;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n   const char *sp_str = reg_names[STACK_POINTER_REGNUM];\n   unsigned long gmask = current_frame_info.gmask;\n@@ -6688,9 +6748,9 @@ sparc_flat_output_function_prologue (file, size)\n \t  /* Subtract %sp in two steps, but make sure there is always a\n \t     64 byte register save area, and %sp is properly aligned.  */\n \t  /* Amount to decrement %sp by, the first time.  */\n-\t  unsigned int size1 = ((size - reg_offset + 64) + 15) & -16;\n+\t  unsigned HOST_WIDE_INT size1 = ((size - reg_offset + 64) + 15) & -16;\n \t  /* Offset to register save area from %sp.  */\n-\t  unsigned int offset = size1 - (size - reg_offset);\n+\t  unsigned HOST_WIDE_INT offset = size1 - (size - reg_offset);\n \t  \n \t  if (size1 <= 4096)\n \t    {\n@@ -6756,10 +6816,10 @@ sparc_flat_output_function_prologue (file, size)\n /* Do any necessary cleanup after a function to restore stack, frame,\n    and regs. */\n \n-void\n-sparc_flat_output_function_epilogue (file, size)\n+static void\n+sparc_flat_function_epilogue (file, size)\n      FILE *file;\n-     int size;\n+     HOST_WIDE_INT size;\n {\n   rtx epilogue_delay = current_function_epilogue_delay_list;\n   int noepilogue = FALSE;\n@@ -6791,8 +6851,8 @@ sparc_flat_output_function_epilogue (file, size)\n \n   if (!noepilogue)\n     {\n-      unsigned int reg_offset = current_frame_info.reg_offset;\n-      unsigned int size1;\n+      unsigned HOST_WIDE_INT reg_offset = current_frame_info.reg_offset;\n+      unsigned HOST_WIDE_INT size1;\n       const char *sp_str = reg_names[STACK_POINTER_REGNUM];\n       const char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n       const char *t1_str = \"%g1\";"}, {"sha": "e413964e6a27aad37f186735ab644e239e89490f", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -435,7 +435,7 @@ extern int target_flags;\n #define MASK_FPU 1\n #define TARGET_FPU (target_flags & MASK_FPU)\n \n-/* Nonzero if we should use FUNCTION_EPILOGUE.  Otherwise, we\n+/* Nonzero if we should use function_epilogue().  Otherwise, we\n    use fast return insns, but lose some generality.  */\n #define MASK_EPILOGUE 2\n #define TARGET_EPILOGUE (target_flags & MASK_EPILOGUE)\n@@ -584,9 +584,9 @@ extern int target_flags;\n      N_(\"Do not use hardware fp\") },\t\t\t\t\t\\\n     {\"soft-float\", MASK_FPU_SET,\t\t\tNULL },\t\t\\\n     {\"epilogue\", MASK_EPILOGUE,\t\t\t\t\t\t\\\n-     N_(\"Use FUNCTION_EPILOGUE\") },\t\t\t\t\t\\\n+     N_(\"Use function_epilogue()\") },\t\t\t\t\t\\\n     {\"no-epilogue\", -MASK_EPILOGUE,\t\t\t\t\t\\\n-     N_(\"Do not use FUNCTION_EPILOGUE\") }, \t\t\t\t\\\n+     N_(\"Do not use function_epilogue()\") }, \t\t\t\t\\\n     {\"unaligned-doubles\", MASK_UNALIGNED_DOUBLES,\t\t\t\\\n      N_(\"Assume possible double misalignment\") },\t\t\t\\\n     {\"no-unaligned-doubles\", -MASK_UNALIGNED_DOUBLES,\t\t\t\\\n@@ -1929,26 +1929,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n } while (0)\n #endif\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-/* On SPARC, move-double insns between fpu and cpu need an 8-byte block\n-   of memory.  If any fpu reg is used in the function, we allocate\n-   such a block here, at the bottom of the frame, just in case it's needed.\n-\n-   If this function is a leaf procedure, then we may choose not\n-   to do a \"save\" insn.  The decision about whether or not\n-   to do this is made in regclass.c.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n-  (TARGET_FLAT ? sparc_flat_output_function_prologue (FILE, (int)SIZE) \\\n-   : output_function_prologue (FILE, (int)SIZE, \\\n-\t\t\t       current_function_uses_only_leaf_regs))\n \f\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n@@ -2128,21 +2108,6 @@ LFLGRET\"ID\":\\n\\\n  (get_frame_size () != 0\t\\\n   || current_function_calls_alloca || current_function_outgoing_args_size)\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-  (TARGET_FLAT ? sparc_flat_output_function_epilogue (FILE, (int)SIZE) \\\n-   : output_function_epilogue (FILE, (int)SIZE, \\\n-\t\t\t       current_function_uses_only_leaf_regs))\n-\n #define DELAY_SLOTS_FOR_EPILOGUE \\\n   (TARGET_FLAT ? sparc_flat_epilogue_delay_slots () : 1)\n #define ELIGIBLE_FOR_EPILOGUE_DELAY(trial, slots_filled) \\"}, {"sha": "50d9f708b2aa1b9d1593828de65b55e52c67eb45", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 74, "deletions": 3, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -30,17 +30,88 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"output.h\"\n #include \"insn-attr.h\"\n-#ifdef VMS_TARGET\n #include \"tree.h\"\n-#endif\n+#include \"recog.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n+\n+static void vax_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE vax_output_function_prologue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n+/* Generate the assembly code for function entry.  FILE is a stdio\n+   stream to output the code to.  SIZE is an int: how many units of\n+   temporary storage to allocate.\n+\n+   Refer to the array `regs_ever_live' to determine which registers to\n+   save; `regs_ever_live[I]' is nonzero if register number I is ever\n+   used in the function.  This function is responsible for knowing\n+   which registers should not be saved even if used.  */\n+\n+static void\n+vax_output_function_prologue (file, size)\n+     FILE * file;\n+     HOST_WIDE_INT size;\n+{\n+  register int regno;\n+  register int mask = 0;\n+  extern char call_used_regs[];\n+\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (regs_ever_live[regno] && !call_used_regs[regno])\n+      mask |= 1 << regno;\n+\n+  fprintf (file, \"\\t.word 0x%x\\n\", mask);\n+\n+  if (VMS_TARGET)\n+    {\n+      /*\n+       * This works for both gcc and g++.  It first checks to see if\n+       * the current routine is \"main\", which will only happen for\n+       * GCC, and add the jsb if it is.  If is not the case then try\n+       * and see if __MAIN_NAME is part of current_function_name,\n+       * which will only happen if we are running g++, and add the jsb\n+       * if it is.  In gcc there should never be a paren in the\n+       * function name, and in g++ there is always a \"(\" in the\n+       * function name, thus there should never be any confusion.\n+       *\n+       * Adjusting the stack pointer by 4 before calling C$MAIN_ARGS\n+       * is required when linking with the VMS POSIX version of the C\n+       * run-time library; using `subl2 $4,r0' is adequate but we use\n+       * `clrl -(sp)' instead.  The extra 4 bytes could be removed\n+       * after the call because STARTING_FRAME_OFFSET's setting of -4\n+       * will end up adding them right back again, but don't bother.\n+       */\n+\n+      const char *p = current_function_name;\n+      int is_main = strcmp (\"main\", p) == 0;\n+#     define __MAIN_NAME \" main(\"\n+\n+      while (!is_main && *p != '\\0')\n+\t{\n+\t  if (*p == *__MAIN_NAME\n+\t      && strncmp (p, __MAIN_NAME, sizeof __MAIN_NAME - sizeof \"\") == 0)\n+\t    is_main = 1;\n+\t  else\n+\t    p++;\n+\t}\n+\n+      if (is_main)\n+\tfprintf (file, \"\\t%s\\n\\t%s\\n\", \"clrl -(sp)\", \"jsb _C$MAIN_ARGS\");\n+    }\n+\n+    size -= STARTING_FRAME_OFFSET;\n+    if (size >= 64)\n+      fprintf (file, \"\\tmovab %d(sp),sp\\n\", -size);\n+    else if (size)\n+      fprintf (file, \"\\tsubl2 $%d,sp\\n\", size);\n+}\n+\n /* This is like nonimmediate_operand with a restriction on the type of MEM.  */\n \n void\n@@ -665,7 +736,7 @@ check_float_value (mode, d, overflow)\n   return 0;\n }\n \f\n-#ifdef VMS_TARGET\n+#if VMS_TARGET\n /* Additional support code for VMS target. */\n \n /* Linked list of all externals that are to be emitted when optimizing"}, {"sha": "fb461a90c42b3450caa0ec3b73d46a88ba76cde3", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -19,6 +19,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#define VMS_TARGET 0\n \n /* Names to predefine in the preprocessor for this target machine.  */\n \n@@ -452,31 +453,6 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate,\n-   adjusted by STARTING_FRAME_OFFSET to accommodate vms.h.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n-{ register int regno;\t\t\t\t\t\t\\\n-  register int mask = 0;\t\t\t\t\t\\\n-  register int size = SIZE - STARTING_FRAME_OFFSET;\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n-       mask |= 1 << regno;\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.word 0x%x\\n\", mask);\t\t\t\\\n-  MAYBE_VMS_FUNCTION_PROLOGUE(FILE)\t\t\t\t\\\n-  if ((size) >= 64) fprintf (FILE, \"\\tmovab %d(sp),sp\\n\", -size);\\\n-  else if (size) fprintf (FILE, \"\\tsubl2 $%d,sp\\n\", (size)); }\n-\n-/* vms.h redefines this.  */\n-#define MAYBE_VMS_FUNCTION_PROLOGUE(FILE)\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -510,13 +486,6 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define EXIT_IGNORE_STACK 1\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n-\n-/* #define FUNCTION_EPILOGUE(FILE, SIZE)  */\n-\n /* Store in the variable DEPTH the initial difference between the\n    frame pointer reg contents and the stack pointer reg contents,\n    as of the start of the function body.  This depends on the layout"}, {"sha": "ccc1715dcd4f38eb2407a3a96a7a513cb601dfd6", "filename": "gcc/config/vax/vms.h", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fvax%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fvax%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvms.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -18,8 +18,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#define VMS_TARGET\n-\n #define TARGET_EXECUTABLE_SUFFIX \".exe\"\n #define TARGET_OBJECT_SUFFIX \".obj\"\n \n@@ -32,12 +30,14 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"vax/vax.h\"\n \n+#undef VMS_TARGET\n+#define VMS_TARGET 1\n+\n #undef LIB_SPEC\n #undef CPP_PREDEFINES\n #undef TARGET_NAME\n #undef TARGET_DEFAULT\n #undef CALL_USED_REGISTERS\n-#undef MAYBE_VMS_FUNCTION_PROLOGUE\n #undef STARTING_FRAME_OFFSET\n \n /* Predefine this in CPP because VMS limits the size of command options\n@@ -80,37 +80,6 @@ Boston, MA 02111-1307, USA.  */\n \n #define STARTING_FRAME_OFFSET -4\n \n-#define __MAIN_NAME \" main(\"\n-/*\n- * The MAYBE_VMS_FUNCTION_PROLOGUE macro works for both gcc and g++.  It\n- * first checks to see if the current routine is \"main\", which will only\n- * happen for GCC, and add the jsb if it is.  If is not the case then try and \n- * see if __MAIN_NAME is part of current_function_name, which will only happen\n- * if we are running g++, and add the jsb if it is.  In gcc there should never\n- * be a paren in the function name, and in g++ there is always a \"(\" in the\n- * function name, thus there should never be any confusion.\n- *\n- * Adjusting the stack pointer by 4 before calling C$MAIN_ARGS is required\n- * when linking with the VMS POSIX version of the C run-time library; using\n- * `subl2 $4,r0' is adequate but we use `clrl -(sp)' instead.  The extra 4\n- * bytes could be removed after the call because STARTING_FRAME_OFFSET's\n- * setting of -4 will end up adding them right back again, but don't bother.\n- */\n-#define MAYBE_VMS_FUNCTION_PROLOGUE(FILE)\t\\\n-{ const char *p = current_function_name;\t\\\n-  int is_main = strcmp (\"main\", p) == 0;\t\\\n-  while (!is_main && *p != '\\0')\t\t\\\n-    {\t\t\t\t\t\t\\\n-      if (*p == *__MAIN_NAME\t\t\t\\\n-\t  && strncmp (p, __MAIN_NAME, sizeof __MAIN_NAME - sizeof \"\") == 0) \\\n-\tis_main = 1;\t\t\t\t\\\n-      else\t\t\t\t\t\\\n-\tp++;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  if (is_main)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\n\\t%s\\n\", \"clrl -(sp)\", \"jsb _C$MAIN_ARGS\");\t\\\n-}\n-\n /* This macro definition sets up a default value for `main' to return.  */\n #define DEFAULT_MAIN_RETURN  c_expand_return (integer_one_node)\n \f"}, {"sha": "1a4fe881735cb702fdc06369e27f7050d1881e20", "filename": "gcc/config/we32k/we32k.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fwe32k%2Fwe32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fwe32k%2Fwe32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -29,14 +29,76 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"recog.h\"\n #include \"output.h\"\n+#include \"regs.h\"\n+#include \"tree.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n+\n+static void we32k_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void we32k_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE we32k_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE we32k_output_function_epilogue\n \n struct gcc_target target = TARGET_INITIALIZER;\n \f\n+/* Generate the assembly code for function entry.  FILE is a stdio\n+   stream to output the code to.  SIZE is an int: how many units of\n+   temporary storage to allocate.\n+\n+   Refer to the array `regs_ever_live' to determine which registers to\n+   save; `regs_ever_live[I]' is nonzero if register number I is ever\n+   used in the function.  This function is responsible for knowing\n+   which registers should not be saved even if used.  */\n+\n+static void\n+we32k_output_function_prologue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size;\n+{\n+  register int nregs_to_save;\n+  register int regno;\n+  extern char call_used_regs[];\n+\n+  nregs_to_save = 0;\n+  for (regno = 8; regno > 2; regno--)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      nregs_to_save = (9 - regno);\n+\n+  fprintf (file, \"\\tsave &%d\\n\", nregs_to_save);\n+  if (size)\n+    fprintf (file, \"\\taddw2 &%d,%%sp\\n\", (size + 3) & ~3);\n+}\n+\n+/* This function generates the assembly code for function exit.\n+   Args are as for output_function_prologue ().\n+\n+   The function epilogue should not depend on the current stack\n+   pointer!  It should use the frame pointer only.  This is mandatory\n+   because of alloca; we also take advantage of it to omit stack\n+   adjustments before returning. */\n+\n+static void\n+we32k_output_function_epilogue (file, size)\n+     FILE *file;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+{\n+  register int nregs_to_restore;\n+  register int regno;\n+  extern char call_used_regs[];\n+\n+  nregs_to_restore = 0;\n+  for (regno = 8; regno > 2; regno--)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      nregs_to_restore = (9 - regno);\n+\n+  fprintf (file, \"\\tret &%d\\n\", nregs_to_restore);\n+}\n+\n void\n output_move_double (operands)\n      rtx *operands;"}, {"sha": "8a94790cccad706f3e4e8b61474b7304a05b68fd", "filename": "gcc/config/we32k/we32k.h", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -396,26 +396,6 @@ enum reg_class { NO_REGS, GENERAL_REGS,\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n-{ register int nregs_to_save;\t\t\t\t\t\\\n-  register int regno;\t\t\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  nregs_to_save = 0;\t\t\t\t\t\t\\\n-  for (regno = 8; regno > 2; regno--)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      nregs_to_save = (9 - regno);\t\t\t\t\\\n-  fprintf (FILE, \"\\tsave &%d\\n\", nregs_to_save);  \t\t\\\n-  if (SIZE)\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\taddw2 &%d,%%sp\\n\", ((SIZE) + 3) & ~3);\t}\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -442,26 +422,6 @@ enum reg_class { NO_REGS, GENERAL_REGS,\n \n #define EXIT_IGNORE_STACK 0\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-{ register int nregs_to_restore;\t\t\t\t\\\n-  register int regno;\t\t\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  nregs_to_restore = 0;\t\t\t\t\t\t\\\n-  for (regno = 8; regno > 2; regno--)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-       nregs_to_restore = (9 - regno);\t\t\t\t\\\n-  fprintf (FILE, \"\\tret &%d\\n\", nregs_to_restore);  \t\t}\n-\n /* Store in the variable DEPTH the initial difference between the\n    frame pointer reg contents and the stack pointer reg contents,\n    as of the start of the function body.  This depends on the layout"}, {"sha": "71b5a91666c5d84de14432fde7827e345f96767b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 94, "deletions": 85, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -2004,13 +2004,14 @@ this.\n \n @findex current_function_is_leaf\n @findex current_function_uses_only_leaf_regs\n-Normally, @code{FUNCTION_PROLOGUE} and @code{FUNCTION_EPILOGUE} must\n-treat leaf functions specially.  They can test the C variable\n-@code{current_function_is_leaf} which is nonzero for leaf functions.\n-@code{current_function_is_leaf} is set prior to local register allocation\n-and is valid for the remaining compiler passes.  They can also test the C\n-variable @code{current_function_uses_only_leaf_regs} which is nonzero for\n-leaf functions which only use leaf registers.\n+Normally, @code{TARGET_ASM_FUNCTION_PROLOGUE} and\n+@code{TARGET_ASM_FUNCTION_EPILOGUE} must treat leaf functions specially.\n+They can test the C variable @code{current_function_is_leaf} which is\n+nonzero for leaf functions.  @code{current_function_is_leaf} is set\n+prior to local register allocation and is valid for the remaining\n+compiler passes.  They can also test the C variable\n+@code{current_function_uses_only_leaf_regs} which is nonzero for leaf\n+functions which only use leaf registers.\n @code{current_function_uses_only_leaf_regs} is valid after reload and is\n only useful if @code{LEAF_REGISTERS} is defined.\n @c changed this to fix overfull.  ALSO:  why the \"it\" at the beginning\n@@ -2772,7 +2773,8 @@ the stack, if the @option{-fstack-check} is specified, in one of three ways:\n If the value of the @code{STACK_CHECK_BUILTIN} macro is nonzero, GCC\n will assume that you have arranged for stack checking to be done at\n appropriate places in the configuration files, e.g., in\n-@code{FUNCTION_PROLOGUE}.  GCC will do not other special processing.\n+@code{TARGET_ASM_FUNCTION_PROLOGUE}.  GCC will do not other special\n+processing.\n \n @item\n If @code{STACK_CHECK_BUILTIN} is zero and you defined a named pattern\n@@ -3696,10 +3698,8 @@ will select the smallest suitable mode.\n This section describes the macros that output function entry\n (@dfn{prologue}) and exit (@dfn{epilogue}) code.\n \n-@table @code\n-@findex FUNCTION_PROLOGUE\n-@item FUNCTION_PROLOGUE (@var{file}, @var{size})\n-A C compound statement that outputs the assembler code for entry to a\n+@deftypefn {Target Hook} void TARGET_ASM_FUNCTION_PROLOGUE (FILE *@var{file}, HOST_WIDE_INT @var{size})\n+If defined, a function that outputs the assembler code for entry to a\n function.  The prologue is responsible for setting up the stack frame,\n initializing the frame pointer register, saving registers that must be\n saved, and allocating @var{size} additional bytes of storage for the\n@@ -3714,7 +3714,7 @@ To determine which registers to save, the macro can refer to the array\n @code{regs_ever_live}: element @var{r} is nonzero if hard register\n @var{r} is used anywhere within the function.  This implies the function\n prologue should save register @var{r}, provided it is not one of the\n-call-used registers.  (@code{FUNCTION_EPILOGUE} must likewise use\n+call-used registers.  (@code{TARGET_ASM_FUNCTION_EPILOGUE} must likewise use\n @code{regs_ever_live}.)\n \n On machines that have ``register windows'', the function entry code does\n@@ -3741,6 +3741,57 @@ for a machine if doing so is more convenient or required for\n compatibility reasons.  Except in cases where required by standard\n or by a debugger, there is no reason why the stack layout used by GCC\n need agree with that used by other compilers for a machine.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_ASM_FUNCTION_EPILOGUE (FILE *@var{file}, HOST_WIDE_INT @var{size})\n+If defined, a function that outputs the assembler code for exit from a\n+function.  The epilogue is responsible for restoring the saved\n+registers and stack pointer to their values when the function was\n+called, and returning control to the caller.  This macro takes the\n+same arguments as the macro @code{TARGET_ASM_FUNCTION_PROLOGUE}, and the\n+registers to restore are determined from @code{regs_ever_live} and\n+@code{CALL_USED_REGISTERS} in the same way.\n+\n+On some machines, there is a single instruction that does all the work\n+of returning from the function.  On these machines, give that\n+instruction the name @samp{return} and do not define the macro\n+@code{TARGET_ASM_FUNCTION_EPILOGUE} at all.\n+\n+Do not define a pattern named @samp{return} if you want the\n+@code{TARGET_ASM_FUNCTION_EPILOGUE} to be used.  If you want the target\n+switches to control whether return instructions or epilogues are used,\n+define a @samp{return} pattern with a validity condition that tests the\n+target switches appropriately.  If the @samp{return} pattern's validity\n+condition is false, epilogues will be used.\n+\n+On machines where functions may or may not have frame-pointers, the\n+function exit code must vary accordingly.  Sometimes the code for these\n+two cases is completely different.  To determine whether a frame pointer\n+is wanted, the macro can refer to the variable\n+@code{frame_pointer_needed}.  The variable's value will be 1 when compiling\n+a function that needs a frame pointer.\n+\n+Normally, @code{TARGET_ASM_FUNCTION_PROLOGUE} and\n+@code{TARGET_ASM_FUNCTION_EPILOGUE} must treat leaf functions specially.\n+The C variable @code{current_function_is_leaf} is nonzero for such a\n+function.  @xref{Leaf Functions}.\n+\n+On some machines, some functions pop their arguments on exit while\n+others leave that for the caller to do.  For example, the 68020 when\n+given @option{-mrtd} pops arguments in functions that take a fixed\n+number of arguments.\n+\n+@findex current_function_pops_args\n+Your definition of the macro @code{RETURN_POPS_ARGS} decides which\n+functions pop their own arguments.  @code{TARGET_ASM_FUNCTION_EPILOGUE}\n+needs to know what was decided.  The variable that is called\n+@code{current_function_pops_args} is the number of bytes of its\n+arguments that a function should pop.  @xref{Scalar Return}.\n+@c what is the \"its arguments\" in the above sentence referring to, pray\n+@c tell?  --mew 5feb93\n+@end deftypefn\n+\n+@table @code\n \n @itemize @bullet\n @item\n@@ -3776,9 +3827,11 @@ Optionally, when @code{ACCUMULATE_OUTGOING_ARGS} is defined, a region of\n argument lists of the function.  @xref{Stack Arguments}.\n @end itemize\n \n-Normally, it is necessary for the macros @code{FUNCTION_PROLOGUE} and\n-@code{FUNCTION_EPILOGUE} to treat leaf functions specially.  The C\n-variable @code{current_function_is_leaf} is nonzero for such a function.\n+Normally, it is necessary for the macros\n+@code{TARGET_ASM_FUNCTION_PROLOGUE} and\n+@code{TARGET_ASM_FUNCTION_EPILOGUE} to treat leaf functions specially.\n+The C variable @code{current_function_is_leaf} is nonzero for such a\n+function.\n \n @findex EXIT_IGNORE_STACK\n @item EXIT_IGNORE_STACK\n@@ -3798,53 +3851,6 @@ Define this macro as a C expression that is nonzero for registers that are\n used by the epilogue or the @samp{return} pattern.  The stack and frame\n pointer registers are already be assumed to be used as needed.\n \n-@findex FUNCTION_EPILOGUE\n-@item FUNCTION_EPILOGUE (@var{file}, @var{size})\n-A C compound statement that outputs the assembler code for exit from a\n-function.  The epilogue is responsible for restoring the saved\n-registers and stack pointer to their values when the function was\n-called, and returning control to the caller.  This macro takes the\n-same arguments as the macro @code{FUNCTION_PROLOGUE}, and the\n-registers to restore are determined from @code{regs_ever_live} and\n-@code{CALL_USED_REGISTERS} in the same way.\n-\n-On some machines, there is a single instruction that does all the work\n-of returning from the function.  On these machines, give that\n-instruction the name @samp{return} and do not define the macro\n-@code{FUNCTION_EPILOGUE} at all.\n-\n-Do not define a pattern named @samp{return} if you want the\n-@code{FUNCTION_EPILOGUE} to be used.  If you want the target switches\n-to control whether return instructions or epilogues are used, define a\n-@samp{return} pattern with a validity condition that tests the target\n-switches appropriately.  If the @samp{return} pattern's validity\n-condition is false, epilogues will be used.\n-\n-On machines where functions may or may not have frame-pointers, the\n-function exit code must vary accordingly.  Sometimes the code for these\n-two cases is completely different.  To determine whether a frame pointer\n-is wanted, the macro can refer to the variable\n-@code{frame_pointer_needed}.  The variable's value will be 1 when compiling\n-a function that needs a frame pointer.\n-\n-Normally, @code{FUNCTION_PROLOGUE} and @code{FUNCTION_EPILOGUE} must\n-treat leaf functions specially.  The C variable @code{current_function_is_leaf}\n-is nonzero for such a function.  @xref{Leaf Functions}.\n-\n-On some machines, some functions pop their arguments on exit while\n-others leave that for the caller to do.  For example, the 68020 when\n-given @option{-mrtd} pops arguments in functions that take a fixed\n-number of arguments.\n-\n-@findex current_function_pops_args\n-Your definition of the macro @code{RETURN_POPS_ARGS} decides which\n-functions pop their own arguments.  @code{FUNCTION_EPILOGUE} needs to\n-know what was decided.  The variable that is called\n-@code{current_function_pops_args} is the number of bytes of its\n-arguments that a function should pop.  @xref{Scalar Return}.\n-@c what is the \"its arguments\" in the above sentence referring to, pray\n-@c tell?  --mew 5feb93\n-\n @findex DELAY_SLOTS_FOR_EPILOGUE\n @item DELAY_SLOTS_FOR_EPILOGUE\n Define this macro if the function epilogue contains delay slots to which\n@@ -3872,8 +3878,9 @@ The insns accepted to fill the epilogue delay slots are put in an RTL\n list made with @code{insn_list} objects, stored in the variable\n @code{current_function_epilogue_delay_list}.  The insn for the first\n delay slot comes first in the list.  Your definition of the macro\n-@code{FUNCTION_EPILOGUE} should fill the delay slots by outputting the\n-insns in this list, usually by calling @code{final_scan_insn}.\n+@code{TARGET_ASM_FUNCTION_EPILOGUE} should fill the delay slots by\n+outputting the insns in this list, usually by calling\n+@code{final_scan_insn}.\n \n You need not define this macro if you did not define\n @code{DELAY_SLOTS_FOR_EPILOGUE}.\n@@ -3900,8 +3907,8 @@ return to whoever called the current @samp{thunk}.\n \n The effect must be as if @var{function} had been called directly with\n the adjusted first argument.  This macro is responsible for emitting all\n-of the code for a thunk function; @code{FUNCTION_PROLOGUE} and\n-@code{FUNCTION_EPILOGUE} are not invoked.\n+of the code for a thunk function; @code{TARGET_ASM_FUNCTION_PROLOGUE}\n+and @code{TARGET_ASM_FUNCTION_EPILOGUE} are not invoked.\n \n The @var{thunk_fndecl} is redundant.  (@var{delta} and @var{function}\n have already been extracted from it.)  It might possibly be useful on\n@@ -4076,15 +4083,15 @@ call __bb_trace_func\n @findex __bb_trace_ret\n @vindex profile_block_flag\n @item FUNCTION_BLOCK_PROFILER_EXIT (@var{file})\n-A C statement or compound statement to output to @var{file}\n-assembler code to call function @code{__bb_trace_ret}.  The\n-assembler code should only be output\n-if the global compile flag @code{profile_block_flag} == 2.  This\n-macro has to be used at every place where code for returning from\n-a function is generated (e.g.@: @code{FUNCTION_EPILOGUE}).  Although\n-you have to write the definition of @code{FUNCTION_EPILOGUE}\n-as well, you have to define this macro to tell the compiler, that\n-the proper call to @code{__bb_trace_ret} is produced.\n+A C statement or compound statement to output to @var{file} assembler\n+code to call function @code{__bb_trace_ret}.  The assembler code should\n+only be output if the global compile flag @code{profile_block_flag} ==\n+2.  This macro has to be used at every place where code for returning\n+from a function is generated (e.g.@:\n+@code{TARGET_ASM_FUNCTION_EPILOGUE}).  Although you have to write the\n+definition of @code{TARGET_ASM_FUNCTION_EPILOGUE} as well, you have to\n+define this macro to tell the compiler, that the proper call to\n+@code{__bb_trace_ret} is produced.\n \n @findex MACHINE_STATE_SAVE\n @findex __bb_init_trace_func\n@@ -4097,8 +4104,9 @@ be clobbered by a function call, including condition codes.  The\n task.  Local labels in the assembler code can be concatenated with the\n string @var{id}, to obtain a unique label name.\n \n-Registers or condition codes clobbered by @code{FUNCTION_PROLOGUE} or\n-@code{FUNCTION_EPILOGUE} must be saved in the macros\n+Registers or condition codes clobbered by\n+@code{TARGET_ASM_FUNCTION_PROLOGUE} or\n+@code{TARGET_ASM_FUNCTION_EPILOGUE} must be saved in the macros\n @code{FUNCTION_BLOCK_PROFILER}, @code{FUNCTION_BLOCK_PROFILER_EXIT} and\n @code{BLOCK_PROFILER} prior calling @code{__bb_init_trace_func},\n @code{__bb_trace_ret} and @code{__bb_trace_func} respectively.\n@@ -4111,8 +4119,9 @@ Registers or condition codes clobbered by @code{FUNCTION_PROLOGUE} or\n A C statement or compound statement to restore all registers, including\n condition codes, saved by @code{MACHINE_STATE_SAVE}.\n \n-Registers or condition codes clobbered by @code{FUNCTION_PROLOGUE} or\n-@code{FUNCTION_EPILOGUE} must be restored in the macros\n+Registers or condition codes clobbered by\n+@code{TARGET_ASM_FUNCTION_PROLOGUE} or\n+@code{TARGET_ASM_FUNCTION_EPILOGUE} must be restored in the macros\n @code{FUNCTION_BLOCK_PROFILER}, @code{FUNCTION_BLOCK_PROFILER_EXIT} and\n @code{BLOCK_PROFILER} after calling @code{__bb_init_trace_func},\n @code{__bb_trace_ret} and @code{__bb_trace_func} respectively.\n@@ -4412,14 +4421,14 @@ A C expression to allocate run-time space for a trampoline.  The\n expression value should be an RTX representing a memory reference to the\n space for the trampoline.\n \n-@cindex @code{FUNCTION_EPILOGUE} and trampolines\n-@cindex @code{FUNCTION_PROLOGUE} and trampolines\n+@cindex @code{TARGET_ASM_FUNCTION_EPILOGUE} and trampolines\n+@cindex @code{TARGET_ASM_FUNCTION_PROLOGUE} and trampolines\n If this macro is not defined, by default the trampoline is allocated as\n a stack slot.  This default is right for most machines.  The exceptions\n are machines where it is impossible to execute instructions in the stack\n area.  On such machines, you may have to implement a separate stack,\n-using this macro in conjunction with @code{FUNCTION_PROLOGUE} and\n-@code{FUNCTION_EPILOGUE}.\n+using this macro in conjunction with @code{TARGET_ASM_FUNCTION_PROLOGUE}\n+and @code{TARGET_ASM_FUNCTION_EPILOGUE}.\n \n @var{fp} points to a data structure, a @code{struct function}, which\n describes the compilation status of the immediate containing function of\n@@ -7565,7 +7574,7 @@ To support optional call frame debugging information, you must also\n define @code{INCOMING_RETURN_ADDR_RTX} and either set\n @code{RTX_FRAME_RELATED_P} on the prologue insns if you use RTL for the\n prologue, or call @code{dwarf2out_def_cfa} and @code{dwarf2out_reg_save}\n-as appropriate from @code{FUNCTION_PROLOGUE} if you don't.\n+as appropriate from @code{TARGET_ASM_FUNCTION_PROLOGUE} if you don't.\n \n @findex DWARF2_FRAME_INFO\n @item DWARF2_FRAME_INFO"}, {"sha": "f40492b8da02a1eb5af47ff84fc3154c21ab2df7", "filename": "gcc/final.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -41,8 +41,8 @@ Boston, MA 02111-1307, USA.  */\n    (the one that tests the condition codes) to be modified.\n \n    The code for the function prologue and epilogue are generated\n-   directly as assembler code by the macros FUNCTION_PROLOGUE and\n-   FUNCTION_EPILOGUE.  Those instructions never exist as rtl.  */\n+   directly in assembler by the target functions function_prologue and\n+   function_epilogue.  Those instructions never exist as rtl.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -65,6 +65,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"reload.h\"\n #include \"intl.h\"\n #include \"basic-block.h\"\n+#include \"target.h\"\n \n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n #include \"dbxout.h\"\n@@ -534,6 +535,17 @@ end_final (filename)\n     }\n }\n \n+/* Default target function prologue and epilogue assembler output.\n+  \n+   If not overridden for epilogue code, then the function body itself\n+   contains return instructions wherever needed.  */\n+void\n+default_function_pro_epilogue (file, size)\n+     FILE *file ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+{\n+}\n+\n /* Enable APP processing of subsequent output.\n    Used before the output from an `asm' statement.  */\n \n@@ -1617,10 +1629,8 @@ final_start_function (first, file, optimize)\n       TREE_ASM_WRITTEN (DECL_INITIAL (current_function_decl)) = 1;\n     }\n \n-#ifdef FUNCTION_PROLOGUE\n   /* First output the function prologue: code to set up the stack frame.  */\n-  FUNCTION_PROLOGUE (file, get_frame_size ());\n-#endif\n+  (*target.asm_out.function_prologue) (file, get_frame_size ());\n \n   /* If the machine represents the prologue as RTL, the profiling code must\n      be emitted when NOTE_INSN_PROLOGUE_END is scanned.  */\n@@ -1761,11 +1771,9 @@ final_end_function (first, file, optimize)\n     xcoffout_end_function (file, high_function_linenum);\n #endif\n \n-#ifdef FUNCTION_EPILOGUE\n   /* Finally, output the function epilogue:\n      code to restore the stack frame and return to the caller.  */\n-  FUNCTION_EPILOGUE (file, get_frame_size ());\n-#endif\n+  (*target.asm_out.function_epilogue) (file, get_frame_size ());\n \n #ifdef SDB_DEBUGGING_INFO\n   if (write_symbols == SDB_DEBUG)\n@@ -1788,9 +1796,6 @@ final_end_function (first, file, optimize)\n #endif\n \n   bb_func_label_num = -1;\t/* not in function, nuke label # */\n-\n-  /* If FUNCTION_EPILOGUE is not defined, then the function body\n-     itself contains return instructions wherever needed.  */\n }\n \f\n /* Add a block to the linked list that remembers the current line/file/function"}, {"sha": "ce96f1138607644f62bbadcee5c0476d6af78596", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -1051,11 +1051,11 @@ exact_real_inverse (mode, r)\n \n REAL_VALUE_TYPE\n real_hex_to_f (s, mode)\n-   char *s;\n+   const char *s;\n    enum machine_mode mode;\n {\n   REAL_VALUE_TYPE ip;\n-  char *p = s;\n+  const char *p = s;\n   unsigned HOST_WIDE_INT low, high;\n   int shcount, nrmcount, k;\n   int sign, expsign, isfloat;"}, {"sha": "a1d5923411d665c3ae2a7e3265a82bf83d5152aa", "filename": "gcc/output.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -448,3 +448,6 @@ extern const char *user_label_prefix;\n /* Assign unique numbers to labels generated for profiling.  */\n \n extern int profile_label_no;\n+\n+/* Default target function prologue and epilogue assembler output.  */\n+extern void default_function_pro_epilogue PARAMS ((FILE *, HOST_WIDE_INT));"}, {"sha": "3a19864979cee03bea8d88f08816c388e5cd2a05", "filename": "gcc/real.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -392,7 +392,8 @@ extern double (atof) ();\n /* Hexadecimal floating constant input for use with host computer's\n    fp arithmetic.  */\n #ifndef REAL_VALUE_HTOF\n-extern REAL_VALUE_TYPE real_hex_to_f PARAMS ((char *, enum machine_mode));\n+extern REAL_VALUE_TYPE real_hex_to_f PARAMS ((const char *,\n+\t\t\t\t\t      enum machine_mode));\n #define REAL_VALUE_HTOF(s,m) real_hex_to_f(s,m)\n #endif\n "}, {"sha": "c0894936f66774f7b9a9519eb5a718f57c70a206", "filename": "gcc/target-def.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -25,6 +25,12 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    We want to have non-NULL default definitions of all hook functions,\n    even if they do nothing.  */\n \n+#define TARGET_ASM_FUNCTION_PROLOGUE default_function_pro_epilogue\n+#define TARGET_ASM_FUNCTION_EPILOGUE default_function_pro_epilogue\n+\n+#define TARGET_ASM_OUT {TARGET_ASM_FUNCTION_PROLOGUE,\t\\\n+\t\t\tTARGET_ASM_FUNCTION_EPILOGUE}\n+\n /* All in tree.c.  */\n #define TARGET_MERGE_DECL_ATTRIBUTES merge_decl_attributes\n #define TARGET_MERGE_TYPE_ATTRIBUTES merge_type_attributes\n@@ -36,6 +42,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n /* The whole shebang.  */\n #define TARGET_INITIALIZER\t\t\t\\\n {\t\t\t\t\t\t\\\n+  TARGET_ASM_OUT,\t\t\t\t\\\n   TARGET_MERGE_DECL_ATTRIBUTES,\t\t\t\\\n   TARGET_MERGE_TYPE_ATTRIBUTES,\t\t\t\\\n   TARGET_VALID_DECL_ATTRIBUTE,\t\t\t\\"}, {"sha": "9515aff31db060262d54162c6326ef01a8514b7b", "filename": "gcc/target.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c148a85ce39064798592a90839497c098fbc93/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c148a85ce39064798592a90839497c098fbc93/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=08c148a85ce39064798592a90839497c098fbc93", "patch": "@@ -46,6 +46,16 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n struct gcc_target\n {\n+  /* Functions that output assembler for the target.  */\n+  struct asm_out\n+  {\n+    /* Output the assembler code for entry to a function.  */\n+    void (* function_prologue) PARAMS ((FILE *, HOST_WIDE_INT));\n+\n+    /* Output the assembler code for function exit.  */\n+    void (* function_epilogue) PARAMS ((FILE *, HOST_WIDE_INT));\n+  } asm_out;\n+\n   /* Given two decls, merge their attributes and return the result.  */\n   tree (* merge_decl_attributes) PARAMS ((tree, tree));\n "}]}