{"sha": "266007a7d6985c467758bbb61b3b23667de075cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY2MDA3YTdkNjk4NWM0Njc3NThiYmI2MWIzYjIzNjY3ZGUwNzVjZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-14T11:40:16Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-14T11:40:16Z"}, "message": "(movstr_optab): New variable.\n\n(init_expr_once): Initialize it.\n(emit_block_move): Rework code that generates movstrxx insns to check\npredicates and use an optab.\n\nFrom-SVN: r1827", "tree": {"sha": "e3384ae57db51caa4f72b6aa04dfee65fec64cd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3384ae57db51caa4f72b6aa04dfee65fec64cd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/266007a7d6985c467758bbb61b3b23667de075cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266007a7d6985c467758bbb61b3b23667de075cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266007a7d6985c467758bbb61b3b23667de075cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266007a7d6985c467758bbb61b3b23667de075cf/comments", "author": null, "committer": null, "parents": [{"sha": "efb07da787b7220a320f7f93b752f82fc34cef0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efb07da787b7220a320f7f93b752f82fc34cef0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efb07da787b7220a320f7f93b752f82fc34cef0b"}], "stats": {"total": 105, "additions": 57, "deletions": 48}, "files": [{"sha": "1959bf9055d8a0ee11247075de092ae0a173240e", "filename": "gcc/expr.c", "status": "modified", "additions": 57, "deletions": 48, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266007a7d6985c467758bbb61b3b23667de075cf/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266007a7d6985c467758bbb61b3b23667de075cf/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=266007a7d6985c467758bbb61b3b23667de075cf", "patch": "@@ -113,7 +113,7 @@ static char direct_store[NUM_MACHINE_MODES];\n    a block move.  */\n \n #ifndef MOVE_RATIO\n-#if defined (HAVE_movstrqi) || defined (HAVE_movstrhi) || defined (HAVE_movstrsi) || defined (HAVE_movstrdi)\n+#if defined (HAVE_movstrqi) || defined (HAVE_movstrhi) || defined (HAVE_movstrsi) || defined (HAVE_movstrdi) || defined (HAVE_movstrti)\n #define MOVE_RATIO 2\n #else\n /* A value of around 6 would minimize code size; infinity would minimize\n@@ -122,14 +122,17 @@ static char direct_store[NUM_MACHINE_MODES];\n #endif\n #endif\n \n+/* This array records the insn_code of insns to perform block moves.  */\n+static enum insn_code movstr_optab[NUM_MACHINE_MODES];\n+\n /* SLOW_UNALIGNED_ACCESS is non-zero if unaligned accesses are very slow. */\n \n #ifndef SLOW_UNALIGNED_ACCESS\n #define SLOW_UNALIGNED_ACCESS 0\n #endif\n \f\n /* This is run once per compilation to set up which modes can be used\n-   directly in memory.  */\n+   directly in memory and to initialize the block move optab.  */\n \n void\n init_expr_once ()\n@@ -169,9 +172,32 @@ init_expr_once ()\n       SET_SRC (pat) = reg;\n       SET_DEST (pat) = mem;\n       direct_store[(int) mode] = (recog (pat, insn, &num_clobbers)) >= 0;\n+\n+      movstr_optab[(int) mode] = CODE_FOR_nothing;\n     }\n \n   end_sequence ();\n+\n+#ifdef HAVE_movstrqi\n+  if (HAVE_movstrqi)\n+    movstr_optab[(int) QImode] = CODE_FOR_movstrqi;\n+#endif\n+#ifdef HAVE_movstrhi\n+  if (HAVE_movstrhi)\n+    movstr_optab[(int) HImode] = CODE_FOR_movstrhi;\n+#endif\n+#ifdef HAVE_movstrsi\n+  if (HAVE_movstrsi)\n+    movstr_optab[(int) SImode] = CODE_FOR_movstrsi;\n+#endif\n+#ifdef HAVE_movstrdi\n+  if (HAVE_movstrdi)\n+    movstr_optab[(int) DImode] = CODE_FOR_movstrdi;\n+#endif\n+#ifdef HAVE_movstrti\n+  if (HAVE_movstrti)\n+    movstr_optab[(int) TImode] = CODE_FOR_movstrti;\n+#endif\n }\n       \n /* This is run at the start of compiling a function.  */\n@@ -1142,56 +1168,39 @@ emit_block_move (x, y, size, align)\n       /* Try the most limited insn first, because there's no point\n \t including more than one in the machine description unless\n \t the more limited one has some advantage.  */\n-#ifdef HAVE_movstrqi\n-      if (HAVE_movstrqi\n-\t  && GET_CODE (size) == CONST_INT\n-\t  && ((unsigned) INTVAL (size)\n-\t      < (1 << (GET_MODE_BITSIZE (QImode) - 1))))\n-\t{\n-\t  rtx insn = gen_movstrqi (x, y, size, GEN_INT (align));\n-\t  if (insn)\n-\t    {\n-\t      emit_insn (insn);\n-\t      return;\n-\t    }\n-\t}\n-#endif\n-#ifdef HAVE_movstrhi\n-      if (HAVE_movstrhi\n-\t  && GET_CODE (size) == CONST_INT\n-\t  && ((unsigned) INTVAL (size)\n-\t      < (1 << (GET_MODE_BITSIZE (HImode) - 1))))\n-\t{\n-\t  rtx insn = gen_movstrhi (x, y, size, GEN_INT (align));\n-\t  if (insn)\n-\t    {\n-\t      emit_insn (insn);\n-\t      return;\n-\t    }\n-\t}\n-#endif\n-#ifdef HAVE_movstrsi\n-      if (HAVE_movstrsi)\n-\t{\n-\t  rtx insn = gen_movstrsi (x, y, size, GEN_INT (align));\n-\t  if (insn)\n-\t    {\n-\t      emit_insn (insn);\n-\t      return;\n-\t    }\n-\t}\n-#endif\n-#ifdef HAVE_movstrdi\n-      if (HAVE_movstrdi)\n+\n+      enum machine_mode mode;\n+\n+      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n+\t   mode = GET_MODE_WIDER_MODE (mode))\n \t{\n-\t  rtx insn = gen_movstrdi (x, y, size, GEN_INT (align));\n-\t  if (insn)\n+\t  enum insn_code code = movstr_optab[(int) mode];\n+\t  rtx opalign = GEN_INT (align);\n+\n+\t  if (code != CODE_FOR_nothing\n+\t      && GET_MODE_BITSIZE (mode) < HOST_BITS_PER_WIDE_INT\n+\t      && (unsigned) INTVAL (size) <= GET_MODE_MASK (mode)\n+\t      && (*insn_operand_predicate[(int) code][0]) (x, Pmode)\n+\t      && (*insn_operand_predicate[(int) code][1]) (y, Pmode)\n+\t      && (*insn_operand_predicate[(int) code][3]) (opalign, VOIDmode))\n \t    {\n-\t      emit_insn (insn);\n-\t      return;\n+\t      rtx op2 = size;\n+\t      rtx last = get_last_insn ();\n+\t      rtx pat;\n+\n+\t      if (! (*insn_operand_predicate[(int) code][2]) (op2, mode))\n+\t\top2 = copy_to_mode_reg (mode, op2);\n+\n+\t      pat = GEN_FCN ((int) code) (x, y, op2, opalign);\n+\t      if (pat)\n+\t\t{\n+\t\t  emit_insn (pat);\n+\t\t  return;\n+\t\t}\n+\t      else\n+\t\tdelete_insns_since (last);\n \t    }\n \t}\n-#endif\n \n #ifdef TARGET_MEM_FUNCTIONS\n       emit_library_call (memcpy_libfunc, 1,"}]}