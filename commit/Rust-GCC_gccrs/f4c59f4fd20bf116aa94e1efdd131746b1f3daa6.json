{"sha": "f4c59f4fd20bf116aa94e1efdd131746b1f3daa6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRjNTlmNGZkMjBiZjExNmFhOTRlMWVmZGQxMzE3NDZiMWYzZGFhNg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2008-11-03T14:28:35Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2008-11-03T14:28:35Z"}, "message": "bfin.c (bfin_optimize_loop): Properly handle case where we have one entry point in the loop which isn't the head.\n\n\t* config/bfin/bfin.c (bfin_optimize_loop): Properly handle case\n\twhere we have one entry point in the loop which isn't the head.\n\nFrom-SVN: r141548", "tree": {"sha": "3077f0e616f18ce43df44ef0fdbade3a9d9d64ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3077f0e616f18ce43df44ef0fdbade3a9d9d64ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4c59f4fd20bf116aa94e1efdd131746b1f3daa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4c59f4fd20bf116aa94e1efdd131746b1f3daa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4c59f4fd20bf116aa94e1efdd131746b1f3daa6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4c59f4fd20bf116aa94e1efdd131746b1f3daa6/comments", "author": null, "committer": null, "parents": [{"sha": "da4b6efcd6ed9d2c6f3b100dc8552753276df586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da4b6efcd6ed9d2c6f3b100dc8552753276df586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da4b6efcd6ed9d2c6f3b100dc8552753276df586"}], "stats": {"total": 46, "additions": 35, "deletions": 11}, "files": [{"sha": "32ebb5d077beed376e1a90848d627dd67cae8496", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c59f4fd20bf116aa94e1efdd131746b1f3daa6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c59f4fd20bf116aa94e1efdd131746b1f3daa6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4c59f4fd20bf116aa94e1efdd131746b1f3daa6", "patch": "@@ -1,3 +1,8 @@\n+2008-11-03  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin.c (bfin_optimize_loop): Properly handle case\n+\twhere we have one entry point in the loop which isn't the head.\n+\n 2008-11-03  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/37573"}, {"sha": "e9c6297513c1f34180bb2bb22ae1e06523761ccf", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c59f4fd20bf116aa94e1efdd131746b1f3daa6/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c59f4fd20bf116aa94e1efdd131746b1f3daa6/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=f4c59f4fd20bf116aa94e1efdd131746b1f3daa6", "patch": "@@ -4059,12 +4059,33 @@ bfin_optimize_loop (loop_info loop)\n       print_rtl_single (dump_file, loop->loop_end);\n     }\n \n+  /* Create a sequence containing the loop setup.  */\n   start_sequence ();\n \n   if (loop->init != NULL_RTX)\n     emit_insn (loop->init);\n   seq_end = emit_insn (loop->loop_init);\n \n+  /* If the loop isn't entered at the top, also create a jump to the entry\n+     point.  */\n+  if (!loop->incoming_src && loop->head != loop->incoming_dest)\n+    {\n+      rtx label = BB_HEAD (loop->incoming_dest);\n+      /* If we're jumping to the final basic block in the loop, and there's\n+\t only one cheap instruction before the end (typically an increment of\n+\t an induction variable), we can just emit a copy here instead of a\n+\t jump.  */\n+      if (loop->incoming_dest == loop->tail\n+\t  && next_real_insn (label) == last_insn\n+\t  && asm_noperands (last_insn) < 0\n+\t  && GET_CODE (PATTERN (last_insn)) == SET)\n+\t{\n+\t  seq_end = emit_insn (copy_rtx (PATTERN (last_insn)));\n+\t}\n+      else\n+\tseq_end = emit_insn (gen_jump (label));\n+    }\n+\n   seq = get_insns ();\n   end_sequence ();\n \n@@ -4084,21 +4105,19 @@ bfin_optimize_loop (loop_info loop)\n       basic_block new_bb;\n       edge e;\n       edge_iterator ei;\n-      \n+\n+#ifdef ENABLE_CHECKING\n       if (loop->head != loop->incoming_dest)\n \t{\n+\t  /* We aren't entering the loop at the top.  Since we've established\n+\t     that the loop is entered only at one point, this means there\n+\t     can't be fallthru edges into the head.  Any such fallthru edges\n+\t     would become invalid when we insert the new block, so verify\n+\t     that this does not in fact happen.  */\n \t  FOR_EACH_EDGE (e, ei, loop->head->preds)\n-\t    {\n-\t      if (e->flags & EDGE_FALLTHRU)\n-\t\t{\n-\t\t  rtx newjump = gen_jump (loop->start_label);\n-\t\t  emit_insn_before (newjump, BB_HEAD (loop->head));\n-\t\t  new_bb = create_basic_block (newjump, newjump, loop->head->prev_bb);\n-\t\t  gcc_assert (new_bb = loop->head->prev_bb);\n-\t\t  break;\n-\t\t}\n-\t    }\n+\t    gcc_assert (!(e->flags & EDGE_FALLTHRU));\n \t}\n+#endif\n \n       emit_insn_before (seq, BB_HEAD (loop->head));\n       seq = emit_label_before (gen_label_rtx (), seq);"}]}