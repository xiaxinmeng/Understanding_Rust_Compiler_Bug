{"sha": "bd909071ac04e94f4b6f0baab64d0687ec55681d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ5MDkwNzFhYzA0ZTk0ZjRiNmYwYmFhYjY0ZDA2ODdlYzU1NjgxZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-09-16T07:42:33Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-09-16T07:42:33Z"}, "message": "store-merging: Consider also overlapping stores earlier in the by bitpos sorting [PR97053]\n\nAs the testcases show, if we have something like:\n  MEM <char[12]> [&b + 8B] = {};\n  MEM[(short *) &b] = 5;\n  _5 = *x_4(D);\n  MEM <long long unsigned int> [&b + 2B] = _5;\n  MEM[(char *)&b + 16B] = 88;\n  MEM[(int *)&b + 20B] = 1;\nthen in sort_by_bitpos the stores are almost like in the given order,\nexcept the first store is after the = _5; store.\nWe can't coalesce the = 5; store with = _5;, because the latter is MEM_REF,\nwhile the former INTEGER_CST, and we can't coalesce the = _5 store with\nthe = {} store because the former is MEM_REF, the latter INTEGER_CST.\nBut we happily coalesce the remaining 3 stores, which is wrong, because the\n= _5; store overlaps those and is in between them in the program order.\nWe already have code to deal with similar cases in check_no_overlap, but we\ndeal only with the following stores in sort_by_bitpos order, not the earlier\nones.\n\nThe following patch checks also the earlier ones.  In coalesce_immediate_stores\nit computes the first one that needs to be checked (all the ones whose\nbitpos + bitsize is smaller or equal to merged_store->start don't need to be\nchecked and don't need to be checked even for any following attempts because\nof the sort_by_bitpos sorting) and the end of that (that is the first store\nin the merged_store).\n\n2020-09-16  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/97053\n\t* gimple-ssa-store-merging.c (check_no_overlap): Add FIRST_ORDER,\n\tSTART, FIRST_EARLIER and LAST_EARLIER arguments.  Return false if\n\tany stores between FIRST_EARLIER inclusive and LAST_EARLIER exclusive\n\thas order in between FIRST_ORDER and LAST_ORDER and overlaps the to\n\tbe merged store.\n\t(imm_store_chain_info::try_coalesce_bswap): Add FIRST_EARLIER argument.\n\tAdjust check_no_overlap caller.\n\t(imm_store_chain_info::coalesce_immediate_stores): Add first_earlier\n\tand last_earlier variables, adjust them during iterations.  Adjust\n\tcheck_no_overlap callers, call check_no_overlap even when extending\n\toverlapping stores by extra INTEGER_CST stores.\n\n\t* gcc.dg/store_merging_31.c: New test.\n\t* gcc.dg/store_merging_32.c: New test.", "tree": {"sha": "8237c390b904234ce07177ebd08bfc3c4e786115", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8237c390b904234ce07177ebd08bfc3c4e786115"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd909071ac04e94f4b6f0baab64d0687ec55681d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd909071ac04e94f4b6f0baab64d0687ec55681d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd909071ac04e94f4b6f0baab64d0687ec55681d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd909071ac04e94f4b6f0baab64d0687ec55681d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c45b9ee5ca53f4e19be33c57e2347538d47f8bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c45b9ee5ca53f4e19be33c57e2347538d47f8bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c45b9ee5ca53f4e19be33c57e2347538d47f8bb"}], "stats": {"total": 232, "additions": 222, "deletions": 10}, "files": [{"sha": "fa2609f4d866d6aa55d7d06789f0ef6747c16cfb", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 66, "deletions": 10, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd909071ac04e94f4b6f0baab64d0687ec55681d/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd909071ac04e94f4b6f0baab64d0687ec55681d/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=bd909071ac04e94f4b6f0baab64d0687ec55681d", "patch": "@@ -2116,7 +2116,8 @@ class imm_store_chain_info\n       }\n   }\n   bool terminate_and_process_chain ();\n-  bool try_coalesce_bswap (merged_store_group *, unsigned int, unsigned int);\n+  bool try_coalesce_bswap (merged_store_group *, unsigned int, unsigned int,\n+\t\t\t   unsigned int);\n   bool coalesce_immediate_stores ();\n   bool output_merged_store (merged_store_group *);\n   bool output_merged_stores ();\n@@ -2443,14 +2444,39 @@ gather_bswap_load_refs (vec<tree> *refs, tree val)\n    into the group.  That way it will be its own store group and will\n    not be touched.  If ALL_INTEGER_CST_P and there are overlapping\n    INTEGER_CST stores, those are mergeable using merge_overlapping,\n-   so don't return false for those.  */\n+   so don't return false for those.\n+\n+   Similarly, check stores from FIRST_EARLIER (inclusive) to END_EARLIER\n+   (exclusive), whether they don't overlap the bitrange START to END\n+   and have order in between FIRST_ORDER and LAST_ORDER.  This is to\n+   prevent merging in cases like:\n+     MEM <char[12]> [&b + 8B] = {};\n+     MEM[(short *) &b] = 5;\n+     _5 = *x_4(D);\n+     MEM <long long unsigned int> [&b + 2B] = _5;\n+     MEM[(char *)&b + 16B] = 88;\n+     MEM[(int *)&b + 20B] = 1;\n+   The = {} store comes in sort_by_bitpos before the = 88 store, and can't\n+   be merged with it, because the = _5 store overlaps these and is in between\n+   them in sort_by_order ordering.  If it was merged, the merged store would\n+   go after the = _5 store and thus change behavior.  */\n \n static bool\n check_no_overlap (vec<store_immediate_info *> m_store_info, unsigned int i,\n-\t\t  bool all_integer_cst_p, unsigned int last_order,\n-\t\t  unsigned HOST_WIDE_INT end)\n+\t\t  bool all_integer_cst_p, unsigned int first_order,\n+\t\t  unsigned int last_order, unsigned HOST_WIDE_INT start,\n+\t\t  unsigned HOST_WIDE_INT end, unsigned int first_earlier,\n+\t\t  unsigned end_earlier)\n {\n   unsigned int len = m_store_info.length ();\n+  for (unsigned int j = first_earlier; j < end_earlier; j++)\n+    {\n+      store_immediate_info *info = m_store_info[j];\n+      if (info->order > first_order\n+\t  && info->order < last_order\n+\t  && info->bitpos + info->bitsize > start)\n+\treturn false;\n+    }\n   for (++i; i < len; ++i)\n     {\n       store_immediate_info *info = m_store_info[i];\n@@ -2471,7 +2497,8 @@ check_no_overlap (vec<store_immediate_info *> m_store_info, unsigned int i,\n bool\n imm_store_chain_info::try_coalesce_bswap (merged_store_group *merged_store,\n \t\t\t\t\t  unsigned int first,\n-\t\t\t\t\t  unsigned int try_size)\n+\t\t\t\t\t  unsigned int try_size,\n+\t\t\t\t\t  unsigned int first_earlier)\n {\n   unsigned int len = m_store_info.length (), last = first;\n   unsigned HOST_WIDE_INT width = m_store_info[first]->bitsize;\n@@ -2611,7 +2638,8 @@ imm_store_chain_info::try_coalesce_bswap (merged_store_group *merged_store,\n   if (n.base_addr == NULL_TREE && !is_gimple_val (n.src))\n     return false;\n \n-  if (!check_no_overlap (m_store_info, last, false, last_order, end))\n+  if (!check_no_overlap (m_store_info, last, false, first_order, last_order,\n+\t\t\t merged_store->start, end, first_earlier, first))\n     return false;\n \n   /* Don't handle memory copy this way if normal non-bswap processing\n@@ -2703,6 +2731,8 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \n   store_immediate_info *info;\n   unsigned int i, ignore = 0;\n+  unsigned int first_earlier = 0;\n+  unsigned int end_earlier = 0;\n \n   /* Order the stores by the bitposition they write to.  */\n   m_store_info.qsort (sort_by_bitpos);\n@@ -2719,6 +2749,12 @@ imm_store_chain_info::coalesce_immediate_stores ()\n       if (i <= ignore)\n \tgoto done;\n \n+      while (first_earlier < end_earlier\n+\t     && (m_store_info[first_earlier]->bitpos\n+\t\t + m_store_info[first_earlier]->bitsize\n+\t\t <= merged_store->start))\n+\tfirst_earlier++;\n+\n       /* First try to handle group of stores like:\n \t p[0] = data >> 24;\n \t p[1] = data >> 16;\n@@ -2733,15 +2769,19 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t{\n \t  unsigned int try_size;\n \t  for (try_size = 64; try_size >= 16; try_size >>= 1)\n-\t    if (try_coalesce_bswap (merged_store, i - 1, try_size))\n+\t    if (try_coalesce_bswap (merged_store, i - 1, try_size,\n+\t\t\t\t    first_earlier))\n \t      break;\n \n \t  if (try_size >= 16)\n \t    {\n \t      ignore = i + merged_store->stores.length () - 1;\n \t      m_merged_store_groups.safe_push (merged_store);\n \t      if (ignore < m_store_info.length ())\n-\t\tmerged_store = new merged_store_group (m_store_info[ignore]);\n+\t\t{\n+\t\t  merged_store = new merged_store_group (m_store_info[ignore]);\n+\t\t  end_earlier = ignore;\n+\t\t}\n \t      else\n \t\tmerged_store = NULL;\n \t      goto done;\n@@ -2776,12 +2816,16 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t      && merged_store->only_constants\n \t      && info->lp_nr == merged_store->lp_nr)\n \t    {\n+\t      unsigned int first_order\n+\t\t= MIN (merged_store->first_order, info->order);\n \t      unsigned int last_order\n \t\t= MAX (merged_store->last_order, info->order);\n \t      unsigned HOST_WIDE_INT end\n \t\t= MAX (merged_store->start + merged_store->width,\n \t\t       info->bitpos + info->bitsize);\n-\t      if (check_no_overlap (m_store_info, i, true, last_order, end))\n+\t      if (check_no_overlap (m_store_info, i, true, first_order,\n+\t\t\t\t    last_order, merged_store->start, end,\n+\t\t\t\t    first_earlier, end_earlier))\n \t\t{\n \t\t  /* check_no_overlap call above made sure there are no\n \t\t     overlapping stores with non-INTEGER_CST rhs_code\n@@ -2810,6 +2854,7 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t\t  do\n \t\t    {\n \t\t      unsigned int max_order = 0;\n+\t\t      unsigned int min_order = first_order;\n \t\t      unsigned first_nonmergeable_int_order = ~0U;\n \t\t      unsigned HOST_WIDE_INT this_end = end;\n \t\t      k = i;\n@@ -2836,6 +2881,7 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t\t\t\t  break;\n \t\t\t\t}\n \t\t\t      k = j;\n+\t\t\t      min_order = MIN (min_order, info2->order);\n \t\t\t      this_end = MAX (this_end,\n \t\t\t\t\t      info2->bitpos + info2->bitsize);\n \t\t\t    }\n@@ -2852,6 +2898,12 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t\t\t    first_nonmergeable_order\n \t\t\t      = MIN (first_nonmergeable_order, info2->order);\n \t\t\t}\n+\t\t      if (k > i\n+\t\t\t  && !check_no_overlap (m_store_info, len - 1, true,\n+\t\t\t\t\t\tmin_order, try_order,\n+\t\t\t\t\t\tmerged_store->start, this_end,\n+\t\t\t\t\t\tfirst_earlier, end_earlier))\n+\t\t\tk = 0;\n \t\t      if (k == 0)\n \t\t\t{\n \t\t\t  if (last_order == try_order)\n@@ -2937,9 +2989,12 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t      info->ops_swapped_p = true;\n \t    }\n \t  if (check_no_overlap (m_store_info, i, false,\n+\t\t\t\tMIN (merged_store->first_order, info->order),\n \t\t\t\tMAX (merged_store->last_order, info->order),\n+\t\t\t\tmerged_store->start,\n \t\t\t\tMAX (merged_store->start + merged_store->width,\n-\t\t\t\t     info->bitpos + info->bitsize)))\n+\t\t\t\t     info->bitpos + info->bitsize),\n+\t\t\t\tfirst_earlier, end_earlier))\n \t    {\n \t      /* Turn MEM_REF into BIT_INSERT_EXPR for bit-field stores.  */\n \t      if (info->rhs_code == MEM_REF && infof->rhs_code != MEM_REF)\n@@ -2985,6 +3040,7 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \tdelete merged_store;\n \n       merged_store = new merged_store_group (info);\n+      end_earlier = i;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfputs (\"New store group\\n\", dump_file);\n "}, {"sha": "32c21eb053cefab99dd543292a1b77a2a2a206b4", "filename": "gcc/testsuite/gcc.dg/store_merging_31.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd909071ac04e94f4b6f0baab64d0687ec55681d/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd909071ac04e94f4b6f0baab64d0687ec55681d/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_31.c?ref=bd909071ac04e94f4b6f0baab64d0687ec55681d", "patch": "@@ -0,0 +1,27 @@\n+/* PR tree-optimization/97053 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+struct S { short a; char b[9]; int c; char d; int e; };\n+\n+__attribute__((noipa)) void\n+foo (char *x, char *y)\n+{\n+  if (__builtin_strcmp (x, \"ABCDXXXX\") != 0\n+      || __builtin_strcmp (y, \"ABCDXXXX\") != 0)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  char a[9] = \"XXXXXXXX\";\n+  struct S b = {};\n+  __builtin_memcpy (a, \"ABCD\", 4);\n+  b.a = 5;\n+  __builtin_memcpy (b.b, a, 8); \n+  b.d = 'X';\n+  b.e = 1;\n+  foo (a, b.b);\n+  return 0;\n+}"}, {"sha": "8c90489bdebf45f7719617df0fb788dc5565f893", "filename": "gcc/testsuite/gcc.dg/store_merging_32.c", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd909071ac04e94f4b6f0baab64d0687ec55681d/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd909071ac04e94f4b6f0baab64d0687ec55681d/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_32.c?ref=bd909071ac04e94f4b6f0baab64d0687ec55681d", "patch": "@@ -0,0 +1,129 @@\n+/* PR tree-optimization/97053 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-tree-dse\" } */\n+\n+struct __attribute__((packed, may_alias)) S { long long s; };\n+struct __attribute__((packed, may_alias)) T { short t; };\n+\n+__attribute__((noipa)) void\n+test (char *p, char *q, int s)\n+{\n+  if ((s & 1) == 0)\n+    {\n+      if (*(short __attribute__((may_alias)) *) &p[sizeof (short)]\n+\t  != *(short __attribute__((may_alias)) *) &q[sizeof (short)]\n+\t  || (((struct S __attribute__((may_alias)) *) &p[1])->s\n+\t      != ((struct S __attribute__((may_alias)) *) &q[1])->s)\n+\t  || (*(short __attribute__((may_alias)) *) &p[2 * sizeof (short)]\n+\t      != *(short __attribute__((may_alias)) *) &q[2 * sizeof (short)]))\n+\t__builtin_abort ();\n+    }\n+  else\n+    {\n+      if (*(short __attribute__((may_alias)) *) &p[sizeof (short)]\n+\t  != *(short __attribute__((may_alias)) *) &q[sizeof (short)]\n+\t  || (((struct S __attribute__((may_alias)) *) &p[1])->s\n+\t      != ((struct S __attribute__((may_alias)) *) &q[1])->s)\n+\t  || (((struct T __attribute__((may_alias)) *) &p[2 * sizeof (short) - 1])->t\n+\t      != ((struct T __attribute__((may_alias)) *) &q[2 * sizeof (short) - 1])->t)\n+\t  || p[3 * sizeof (short) - 2] != q[3 * sizeof (short) - 2])\n+\t__builtin_abort ();\n+    }\n+}\n+\n+__attribute__((noipa)) void\n+foo (long long *p, char *q, char *r, char *s)\n+{\n+  char a[64] __attribute__((aligned (__alignof (short))));\n+  *(short __attribute__((may_alias)) *) &a[sizeof (short)] = 1;\n+  ((struct S __attribute__((may_alias)) *) &a[1])->s = p[0];\n+  *(short __attribute__((may_alias)) *) &a[2 * sizeof (short)] = 2;\n+  *(short __attribute__((may_alias)) *) &q[sizeof (short)] = 1;\n+  ((struct S __attribute__((may_alias)) *) &r[1])->s = p[0];\n+  *(short __attribute__((may_alias)) *) &s[2 * sizeof (short)] = 2;\n+  test (a, q, 0);\n+}\n+\n+__attribute__((noipa)) void\n+bar (long long *p, char *q, char *r, char *s, char *t)\n+{\n+  char a[64] __attribute__((aligned (__alignof (short))));\n+  *(short __attribute__((may_alias)) *) &a[sizeof (short)] = 1;\n+  ((struct S __attribute__((may_alias)) *) &a[1])->s = p[0];\n+  ((struct T __attribute__((may_alias)) *) &a[2 * sizeof (short) - 1])->t = 2;\n+  a[3 * sizeof (short) - 2] = 3;\n+  *(short __attribute__((may_alias)) *) &q[sizeof (short)] = 1;\n+  ((struct S __attribute__((may_alias)) *) &r[1])->s = p[0];\n+  ((struct T __attribute__((may_alias)) *) &s[2 * sizeof (short) - 1])->t = 2;\n+  t[3 * sizeof (short) - 2] = 3;\n+  test (a, q, 1);\n+}\n+\n+__attribute__((noipa)) void\n+baz (long long *p, char *q, char *r, char *s)\n+{\n+  char a[64] __attribute__((aligned (__alignof (short))));\n+  *(short __attribute__((may_alias)) *) &a[2 * sizeof (short)] = 2;\n+  ((struct S __attribute__((may_alias)) *) &a[1])->s = p[0];\n+  *(short __attribute__((may_alias)) *) &a[sizeof (short)] = 1;\n+  *(short __attribute__((may_alias)) *) &q[2 * sizeof (short)] = 2;\n+  ((struct S __attribute__((may_alias)) *) &r[1])->s = p[0];\n+  *(short __attribute__((may_alias)) *) &s[sizeof (short)] = 1;\n+  test (a, q, 2);\n+}\n+\n+__attribute__((noipa)) void\n+qux (long long *p, char *q, char *r, char *s, char *t)\n+{\n+  char a[64] __attribute__((aligned (__alignof (short))));\n+  *(short __attribute__((may_alias)) *) &a[2 * sizeof (short) - 1] = 2;\n+  ((struct S __attribute__((may_alias)) *) &a[1])->s = p[0];\n+  a[3 * sizeof (short) - 2] = 3;\n+  *(short __attribute__((may_alias)) *) &a[sizeof (short)] = 1;\n+  ((struct T __attribute__((may_alias)) *) &q[2 * sizeof (short) - 1])->t = 2;\n+  ((struct S __attribute__((may_alias)) *) &r[1])->s = p[0];\n+  s[3 * sizeof (short) - 2] = 3;\n+  ((struct T __attribute__((may_alias)) *) &t[sizeof (short)])->t = 1;\n+  test (a, q, 3);\n+}\n+\n+__attribute__((noipa)) void\n+corge (long long *p, char *q, char *r, char *s, short u[3])\n+{\n+  char a[64] __attribute__((aligned (__alignof (short))));\n+  *(short __attribute__((may_alias)) *) &a[2 * sizeof (short)] = u[2];\n+  ((struct S __attribute__((may_alias)) *) &a[1])->s = p[0];\n+  *(short __attribute__((may_alias)) *) &a[sizeof (short)] = u[1];\n+  *(short __attribute__((may_alias)) *) &q[2 * sizeof (short)] = u[2];\n+  ((struct S __attribute__((may_alias)) *) &r[1])->s = p[0];\n+  *(short __attribute__((may_alias)) *) &s[sizeof (short)] = u[1];\n+  test (a, q, 4);\n+}\n+\n+__attribute__((noipa)) void\n+garply (long long *p, char *q, char *r, char *s, short u[3])\n+{\n+  char a[64] __attribute__((aligned (__alignof (short))));\n+  *(short __attribute__((may_alias)) *) &a[sizeof (short)] = u[1];\n+  ((struct S __attribute__((may_alias)) *) &a[1])->s = p[0];\n+  *(short __attribute__((may_alias)) *) &a[2 * sizeof (short)] = u[2];\n+  *(short __attribute__((may_alias)) *) &s[sizeof (short)] = u[1];\n+  ((struct S __attribute__((may_alias)) *) &r[1])->s = p[0];\n+  *(short __attribute__((may_alias)) *) &q[2 * sizeof (short)] = u[2];\n+  test (a, q, 6);\n+}\n+\n+int\n+main ()\n+{\n+  char a[64] __attribute__((aligned (__alignof (short))));\n+  long long p = -1LL;\n+  short u[] = { 1, 2, 3 };\n+  foo (&p, &a[0], &a[0], &a[0]);\n+  bar (&p, &a[0], &a[0], &a[0], &a[0]);\n+  baz (&p, &a[0], &a[0], &a[0]);\n+  qux (&p, &a[0], &a[0], &a[0], &a[0]);\n+  corge (&p, &a[0], &a[0], &a[0], u);\n+  garply (&p, &a[0], &a[0], &a[0], u);\n+  return 0;\n+}"}]}