{"sha": "50e8c419f93ca99039d60ba32068ae637d700c71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBlOGM0MTlmOTNjYTk5MDM5ZDYwYmEzMjA2OGFlNjM3ZDcwMGM3MQ==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2003-12-30T13:21:16Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-12-30T13:21:16Z"}, "message": "2003-12-30  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/io/LineNumberReader.java\n\t(countLines): Removed.\n\t(fill): New private method.\n\t(mark): Changed logic to use and matchedNewLine.\n\t(reset): Likewise.\n\t(read): Likewise.\n\t(skipRedundantLF): Likewise.\n\nFrom-SVN: r75232", "tree": {"sha": "2e3c358adc0b15df653b1e0b94c2f5953c62369b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e3c358adc0b15df653b1e0b94c2f5953c62369b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50e8c419f93ca99039d60ba32068ae637d700c71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e8c419f93ca99039d60ba32068ae637d700c71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e8c419f93ca99039d60ba32068ae637d700c71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e8c419f93ca99039d60ba32068ae637d700c71/comments", "author": null, "committer": null, "parents": [{"sha": "b0af5c039d9bdcbde6927786d657e1fbf2d52c6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0af5c039d9bdcbde6927786d657e1fbf2d52c6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0af5c039d9bdcbde6927786d657e1fbf2d52c6d"}], "stats": {"total": 130, "additions": 74, "deletions": 56}, "files": [{"sha": "f7fbbb715ee8b7f5717e6f99c43cc40179c9413b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e8c419f93ca99039d60ba32068ae637d700c71/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e8c419f93ca99039d60ba32068ae637d700c71/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=50e8c419f93ca99039d60ba32068ae637d700c71", "patch": "@@ -1,3 +1,13 @@\n+2003-12-30  Guilhem Lavaux <guilhem@kaffe.org>\n+\n+\t* java/io/LineNumberReader.java\n+\t(countLines): Removed.\n+\t(fill): New private method.\n+\t(mark): Changed logic to use and matchedNewLine.\n+\t(reset): Likewise.\n+\t(read): Likewise.\n+\t(skipRedundantLF): Likewise.\n+\n 2003-12-30  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/net/protocol/http/Connection.java"}, {"sha": "b3cb582693007e29aed389605a3e1321a5fbb792", "filename": "libjava/java/io/LineNumberReader.java", "status": "modified", "additions": 64, "deletions": 56, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e8c419f93ca99039d60ba32068ae637d700c71/libjava%2Fjava%2Fio%2FLineNumberReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e8c419f93ca99039d60ba32068ae637d700c71/libjava%2Fjava%2Fio%2FLineNumberReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FLineNumberReader.java?ref=50e8c419f93ca99039d60ba32068ae637d700c71", "patch": "@@ -54,7 +54,8 @@\n  *\n  * @author Per Bothner <bothner@cygnus.com>\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n- * @date April 22, 1998.  \n+ * @author Guilhem Lavaux <guilhem@kaffe.org>\n+ * @date December 28, 2003.\n  */\n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n  * API docs for JDK 1.2 beta from http://www.javasoft.com.\n@@ -71,6 +72,10 @@ public class LineNumberReader extends BufferedReader\n {\n   /** The current line number. */\n   private int lineNumber;\n+  /** Whether we already found a new line in the former call. */\n+  private boolean matchedNewLine;\n+  /** The saved line number when calling mark() */\n+  private int savedLineNumber;\n \n   /**\n     * Create a new <code>LineNumberReader</code> that reads from the\n@@ -117,20 +122,6 @@ public void setLineNumber(int lineNumber)\n     this.lineNumber = lineNumber;\n   }\n \n-  private static int countLines (char[] buffer, int off, int len)\n-  {\n-    int count = 0;\n-    char prev = '\\0';\n-    for (int i = 0;  i < len;  i++)\n-      {\n-        char ch = buffer[i+off];\n-        if ((ch == '\\n' && prev != '\\r') || ch == '\\r')\n-          count++;\n-        prev = ch;\n-      }\n-    return count;\n-  }\n-\n   /**\n     * This method marks a position in the input to which the stream can be\n     * \"reset\" char calling the <code>reset()</code> method.  The parameter\n@@ -165,11 +156,12 @@ public void mark(int readLimit) throws IOException\n \t// save that 'r', in case the next character is a '\\n'.\n \tif (pos + readLimit > limit)\n \t  {\n-\t    int saveCR = (pos > 0 && buffer[pos-1] == '\\r') ? 1 : 0;\n+\t    int saveCR = matchedNewLine ? 1 : 0;\n \t    char[] old_buffer = buffer;\n \t    if (readLimit > limit)\n \t      buffer = new char[saveCR + readLimit];\n \t    int copy_start = pos - saveCR;\n+\t    savedLineNumber = lineNumber;\n \t    limit -= copy_start;\n \t    System.arraycopy(old_buffer, copy_start, buffer, 0, limit);\n \t    pos = saveCR;\n@@ -195,14 +187,34 @@ public void reset() throws IOException\n       {\n \tif (markPos < 0)\n \t  throw new IOException(\"mark never set or invalidated\");\n-\tif (markPos > 0 && pos > markPos && buffer[markPos-1] == '\\r'\n-\t    && buffer[markPos] == '\\n')\n-\t  lineNumber--;\n-\tlineNumber -= countLines(buffer, markPos, pos - markPos);\n+\tlineNumber = savedLineNumber;\n \tpos = markPos;\n+\tmatchedNewLine = (markPos > 0 && buffer[markPos-1] == '\\r');\n       }\n   }\n \n+  /**\n+   * This private method fills the input buffer whatever pos is.\n+   * Consequently pos should be checked before calling this method.\n+   *\n+   * @return the number of bytes actually read from the input stream or\n+   * -1 if end of stream.\n+   * @exception IOException If an error occurs.\n+   */\n+  private int fill() throws IOException\n+  {\n+    if (markPos >= 0 && limit == buffer.length)\n+      markPos = -1;\n+    if (markPos < 0)\n+      pos = limit = 0;\n+    int count = in.read(buffer, limit, buffer.length - limit);\n+    if (count <= 0)\n+      return -1;\n+    limit += count;\n+\n+    return count;\n+  }\n+\n   /**\n     * This method reads an unsigned char from the input stream and returns it\n     * as an int in the range of 0-65535.  This method will return -1 if the\n@@ -226,30 +238,24 @@ public int read() throws IOException\n     synchronized (lock)\n       {\n \tskipRedundantLF();\n-\tif (pos >= limit)\n-\t  {\n-\t    if (markPos >= 0 && limit == buffer.length)\n-\t      markPos = -1;\n-\t    if (markPos < 0)\n-\t      pos = limit = 0;\n-\t    int count = in.read(buffer, limit, buffer.length - limit);\n-\t    if (count <= 0)\n-\t      return -1;\n-\t    limit += count;\n-\t  }\n+\tif (pos >= limit && fill() < 0)\n+\t  return -1;\n \tchar ch = buffer[pos++];\n-\tif (ch == '\\r' || ch == '\\n')\n+\t\n+\tif ((matchedNewLine = (ch == '\\r')) || ch == '\\n')\n \t  {\n \t    lineNumber++;\n \t    return '\\n';\n \t  }\n+\tmatchedNewLine = false;\n \treturn (int) ch;\n       }\n   }\n \n   /**\n     * This method reads chars from a stream and stores them into a caller\n-    * supplied buffer.  It starts storing data at index <code>offset</code> into    * the buffer and attemps to read <code>len</code> chars.  This method can\n+    * supplied buffer.  It starts storing data at index <code>offset</code> into   \n+    * the buffer and attemps to read <code>len</code> chars.  This method can\n     * return before reading the number of chars requested.  The actual number\n     * of chars read is returned as an int.  A -1 is returned to indicated the\n     * end of the stream.\n@@ -276,6 +282,7 @@ public int read(char[] buf, int offset, int count) throws IOException\n   {\n     if (buf == null)\n       throw new NullPointerException();\n+\n     if (offset + count > buf.length || offset < 0)\n       throw new IndexOutOfBoundsException();\n \n@@ -285,54 +292,54 @@ public int read(char[] buf, int offset, int count) throws IOException\n \t  throw new IndexOutOfBoundsException();\n \treturn 0;\n       }\n+\n     synchronized (lock)\n       {\n-\tint first = read();\n-\tif (first < 0)\n+\tif (pos >= limit && fill() < 0)\n \t  return -1;\n+\t\n \tint start_offset = offset;\n-\tbuf[offset++] = (char) first;\n-\tif (buffer[pos-1] == '\\r' && pos < limit && buffer[pos] == '\\n')\n-\t  pos++;\n-\tcount--;\n+\tboolean matched = matchedNewLine;\n+\t\n \twhile (count-- > 0 && pos < limit)\n \t  {\n \t    char ch = buffer[pos++];\n \t    if (ch == '\\r')\n \t      {\n \t\tlineNumber++;\n-\t\tch = '\\n';\n-\t\tif (pos < limit && buffer[pos] == '\\n')\n-\t\t  pos++;\n+\t\tmatched = true;\n \t      }\n-\t    else if (ch == '\\n')\n+\t    else if (ch == '\\n' && !matched)\n \t      lineNumber++;\n+\t    else\n+\t      matched = false;\n+\n \t    buf[offset++] = ch;\n \t  }\n+\n+\tmatchedNewLine = matched;\n \treturn offset - start_offset;\n       }\n   }\n \n   private void skipRedundantLF() throws IOException\n   {\n-    if (pos > 0 && buffer[pos-1] == '\\r')\n+    if (pos > 0 && matchedNewLine)\n       {\n \tif (pos < limit)\n \t  { // fast case\n \t    if (buffer[pos] == '\\n')\n \t      pos++;\n \t  }\n \telse\n-\t  { // use read() to deal with the general case.\n-\t    // Set pos and limit to zero to avoid infinite recursion in read.\n-\t    // May need to invalidate markPos if we've exceeded the buffer.  \n-\t    if (pos >= buffer.length)\n-\t      markPos = -1;\n-\t    pos = limit = 0;\n-\t    int ch = read();\n-\t    if (ch >= 0 && ch != '\\n')\n-\t      pos--;\n+\t  { // check whether the next buffer begins with '\\n'.\n+\t    // in that case kill the '\\n'.\n+\t    if (fill() <= 0)\n+\t      return;\n+\t    if (buffer[pos] == '\\n')\n+\t      pos++;\n \t  }\n+\tmatchedNewLine = true;\n       }\n   }\n \n@@ -366,8 +373,9 @@ public String readLine() throws IOException\n     if (pos > limit)\n       --pos;\n \n-    int ch;\n-    if (pos > 0 && ((ch = buffer[pos - 1]) == '\\n' || ch == '\\r'))\n+    // The only case where you mustn't increment the line number is you are\n+    // at the EOS.\n+    if (str != null)\n       lineNumber = tmpLineNumber + 1;\n \n     return str;\n@@ -394,7 +402,7 @@ public long skip (long count) throws IOException\n \n     int skipped;\n     char[] buf = new char[1];\n-   \n+\n     for (skipped = 0; skipped < count; skipped++)\n       {\n         int ch = read(buf, 0, 1);"}]}