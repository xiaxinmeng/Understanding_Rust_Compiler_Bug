{"sha": "58db834b27756ef397b96597ce0a541d8ae89dec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThkYjgzNGIyNzc1NmVmMzk3Yjk2NTk3Y2UwYTU0MWQ4YWU4OWRlYw==", "commit": {"author": {"name": "Bob Wilson", "email": "bob.wilson@acm.org", "date": "2002-11-22T00:23:31Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2002-11-22T00:23:31Z"}, "message": "xtensa-protos.h (xtensa_copy_incoming_a7): Declare.\n\n        * config/xtensa/xtensa-protos.h (xtensa_copy_incoming_a7): Declare.\n        * config/xtensa/xtensa.c (struct machine_function): Add\n        incoming_a7_copied flag.\n        (xtensa_copy_incoming_a7): Define.\n        (xtensa_emit_move_sequence): Use xtensa_copy_incoming_a7.\n        * config/xtensa/xtensa.md (movdi, movsf, movdf): Ditto.\n\nFrom-SVN: r59364", "tree": {"sha": "14dbde98b223724f8db35d54e3274299e7aed2f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14dbde98b223724f8db35d54e3274299e7aed2f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58db834b27756ef397b96597ce0a541d8ae89dec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58db834b27756ef397b96597ce0a541d8ae89dec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58db834b27756ef397b96597ce0a541d8ae89dec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58db834b27756ef397b96597ce0a541d8ae89dec/comments", "author": null, "committer": null, "parents": [{"sha": "c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c05dbe8131d5d1f1b4cfb1a1f08af5c9e79942e1"}], "stats": {"total": 144, "additions": 87, "deletions": 57}, "files": [{"sha": "ab62b5063aa0de0d9363db513c12893e5e35fdd3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58db834b27756ef397b96597ce0a541d8ae89dec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58db834b27756ef397b96597ce0a541d8ae89dec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58db834b27756ef397b96597ce0a541d8ae89dec", "patch": "@@ -1,3 +1,12 @@\n+2002-11-21  Bob Wilson  <bob.wilson@acm.org>\n+\n+\t* config/xtensa/xtensa-protos.h (xtensa_copy_incoming_a7): Declare.\n+\t* config/xtensa/xtensa.c (struct machine_function): Add\n+\tincoming_a7_copied flag.\n+\t(xtensa_copy_incoming_a7): Define.\n+\t(xtensa_emit_move_sequence): Use xtensa_copy_incoming_a7.\n+\t* config/xtensa/xtensa.md (movdi, movsf, movdf): Ditto.\n+\n Thu Nov 21 23:52:04 CET 2002  Jan Hubicka  <jH@suse.cz>\n \n \t* i386-protos.h (x86_64_sign_extended_value): Fix prototype."}, {"sha": "195d71da6426305ee5e2b51bd53937c790ce1015", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58db834b27756ef397b96597ce0a541d8ae89dec/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58db834b27756ef397b96597ce0a541d8ae89dec/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=58db834b27756ef397b96597ce0a541d8ae89dec", "patch": "@@ -70,6 +70,7 @@ extern int xtensa_expand_conditional_move PARAMS ((rtx *, int));\n extern int xtensa_expand_scc PARAMS ((rtx *));\n extern int xtensa_expand_block_move PARAMS ((rtx *));\n extern int xtensa_emit_move_sequence PARAMS ((rtx *, enum machine_mode));\n+extern bool xtensa_copy_incoming_a7 PARAMS ((rtx *, enum machine_mode));\n extern void xtensa_emit_block_move PARAMS ((rtx *, rtx *, int));\n extern void xtensa_expand_nonlocal_goto PARAMS ((rtx *));\n extern void xtensa_emit_loop_end PARAMS ((rtx, rtx *));"}, {"sha": "babb5b06a515be31fb1e85081e997ea5b919eeff", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 71, "deletions": 39, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58db834b27756ef397b96597ce0a541d8ae89dec/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58db834b27756ef397b96597ce0a541d8ae89dec/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=58db834b27756ef397b96597ce0a541d8ae89dec", "patch": "@@ -90,6 +90,7 @@ const char *xtensa_st_opcodes[(int) MAX_MACHINE_MODE];\n struct machine_function GTY(())\n {\n   int accesses_prev_frame;\n+  bool incoming_a7_copied;\n };\n \n /* Vector, indexed by hard register number, which contains 1 for a\n@@ -1275,45 +1276,8 @@ xtensa_emit_move_sequence (operands, mode)\n       if (!xtensa_valid_move (mode, operands))\n \toperands[1] = force_reg (mode, operands[1]);\n \n-      /* Check if this move is copying an incoming argument in a7.  If\n-\t so, emit the move, followed by the special \"set_frame_ptr\"\n-\t unspec_volatile insn, at the very beginning of the function.\n-\t This is necessary because the register allocator will ignore\n-\t conflicts with a7 and may assign some other pseudo to a7.  If\n-\t that pseudo was assigned prior to this move, it would clobber\n-\t the incoming argument in a7.  By copying the argument out of\n-\t a7 as the very first thing, and then immediately following\n-\t that with an unspec_volatile to keep the scheduler away, we\n-\t should avoid any problems.  */\n-\n-      if (a7_overlap_mentioned_p (operands[1]))\n-\t{\n-\t  rtx mov;\n-\t  switch (mode)\n-\t    {\n-\t    case SImode:\n-\t      mov = gen_movsi_internal (operands[0], operands[1]);\n-\t      break;\n-\t    case HImode:\n-\t      mov = gen_movhi_internal (operands[0], operands[1]);\n-\t      break;\n-\t    case QImode:\n-\t      mov = gen_movqi_internal (operands[0], operands[1]);\n-\t      break;\n-\t    default:\n-\t      abort ();\n-\t    }\n-\n-\t  /* Insert the instructions before any other argument copies.\n-\t     (The set_frame_ptr insn comes _after_ the move, so push it\n-\t     out first.)  */\n-\t  push_topmost_sequence ();\n-\t  emit_insn_after (gen_set_frame_ptr (), get_insns ());\n-\t  emit_insn_after (mov, get_insns ());\n-\t  pop_topmost_sequence ();\n-\n-\t  return 1;\n-\t}\n+      if (xtensa_copy_incoming_a7 (operands, mode))\n+\treturn 1;\n     }\n \n   /* During reload we don't want to emit (subreg:X (mem:Y)) since that\n@@ -1345,6 +1309,74 @@ fixup_subreg_mem (x)\n }\n \n \n+/* Check if this move is copying an incoming argument in a7.  If so,\n+   emit the move, followed by the special \"set_frame_ptr\"\n+   unspec_volatile insn, at the very beginning of the function.  This\n+   is necessary because the register allocator will ignore conflicts\n+   with a7 and may assign some other pseudo to a7.  If that pseudo was\n+   assigned prior to this move, it would clobber the incoming argument\n+   in a7.  By copying the argument out of a7 as the very first thing,\n+   and then immediately following that with an unspec_volatile to keep\n+   the scheduler away, we should avoid any problems.  */\n+\n+bool\n+xtensa_copy_incoming_a7 (operands, mode)\n+     rtx *operands;\n+     enum machine_mode mode;\n+{\n+  if (a7_overlap_mentioned_p (operands[1])\n+      && !cfun->machine->incoming_a7_copied)\n+    {\n+      rtx mov;\n+      switch (mode)\n+\t{\n+\tcase DFmode:\n+\t  mov = gen_movdf_internal (operands[0], operands[1]);\n+\t  break;\n+\tcase SFmode:\n+\t  mov = gen_movsf_internal (operands[0], operands[1]);\n+\t  break;\n+\tcase DImode:\n+\t  mov = gen_movdi_internal (operands[0], operands[1]);\n+\t  break;\n+\tcase SImode:\n+\t  mov = gen_movsi_internal (operands[0], operands[1]);\n+\t  break;\n+\tcase HImode:\n+\t  mov = gen_movhi_internal (operands[0], operands[1]);\n+\t  break;\n+\tcase QImode:\n+\t  mov = gen_movqi_internal (operands[0], operands[1]);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      /* Insert the instructions before any other argument copies.\n+\t (The set_frame_ptr insn comes _after_ the move, so push it\n+\t out first.)  */\n+      push_topmost_sequence ();\n+      emit_insn_after (gen_set_frame_ptr (), get_insns ());\n+      emit_insn_after (mov, get_insns ());\n+      pop_topmost_sequence ();\n+\n+      /* Ideally the incoming argument in a7 would only be copied\n+\t once, since propagating a7 into the body of a function\n+\t will almost certainly lead to errors.  However, there is\n+\t at least one harmless case (in GCSE) where the original\n+\t copy from a7 is changed to copy into a new pseudo.  Thus,\n+\t we use a flag to only do this special treatment for the\n+\t first copy of a7.  */\n+\n+      cfun->machine->incoming_a7_copied = true;\n+\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+\n /* Try to expand a block move operation to an RTL block move instruction.\n    If not optimizing or if the block size is not a constant or if the\n    block is small, the expansion fails and GCC falls back to calling"}, {"sha": "5db5c0ca487dfd6191562f27283e4ed1bcba1ac8", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58db834b27756ef397b96597ce0a541d8ae89dec/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58db834b27756ef397b96597ce0a541d8ae89dec/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=58db834b27756ef397b96597ce0a541d8ae89dec", "patch": "@@ -929,12 +929,8 @@\n \t  && !register_operand (operands[1], DImode))\n \toperands[1] = force_reg (DImode, operands[1]);\n \n-      if (a7_overlap_mentioned_p (operands[1]))\n-\t{\n-\t  emit_insn (gen_movdi_internal (operands[0], operands[1]));\n-\t  emit_insn (gen_set_frame_ptr ());\n-\t  DONE;\n-\t}\n+      if (xtensa_copy_incoming_a7 (operands, DImode))\n+\tDONE;\n     }\n }\")\n \n@@ -1107,12 +1103,8 @@\n \t      && constantpool_mem_p (operands[1]))))\n \toperands[1] = force_reg (SFmode, operands[1]);\n \n-      if (a7_overlap_mentioned_p (operands[1]))\n-\t{\n-\t  emit_insn (gen_movsf_internal (operands[0], operands[1]));\n-\t  emit_insn (gen_set_frame_ptr ());\n-\t  DONE;\n-\t}\n+      if (xtensa_copy_incoming_a7 (operands, SFmode))\n+\tDONE;\n     }\n }\")\n \n@@ -1193,12 +1185,8 @@\n \t  && !register_operand (operands[1], DFmode))\n \toperands[1] = force_reg (DFmode, operands[1]);\n \n-      if (a7_overlap_mentioned_p (operands[1]))\n-\t{\n-\t  emit_insn (gen_movdf_internal (operands[0], operands[1]));\n-\t  emit_insn (gen_set_frame_ptr ());\n-\t  DONE;\n-\t}\n+      if (xtensa_copy_incoming_a7 (operands, DFmode))\n+\tDONE;\n     }\n }\")\n "}]}