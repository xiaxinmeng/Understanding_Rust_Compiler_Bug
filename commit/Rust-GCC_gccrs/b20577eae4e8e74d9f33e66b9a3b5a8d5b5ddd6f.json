{"sha": "b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIwNTc3ZWFlNGU4ZTc0ZDlmMzNlNjZiOWEzYjVhOGQ1YjVkZGQ2Zg==", "commit": {"author": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2011-10-26T12:37:59Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2011-10-26T12:37:59Z"}, "message": "re PR target/48108 (lto should be containerized in a single mach-o section on darwin)\n\n\ngcc:\n\n\tPR target/48108\n\t* config/darwin.c (top level): Amend comments concerning LTO output.\n\t(lto_section_num): New variable.  (darwin_lto_section_e): New GTY.\n\t(LTO_SECTS_SECTION, LTO_INDEX_SECTION): New.\n\t(LTO_NAMES_SECTION): Rename.\n\t(darwin_asm_named_section): Record LTO section counts and switches\n\tin a vec of darwin_lto_section_e.\n\t(darwin_file_start): Remove unused code.\n\t(darwin_file_end): Put an LTO section termination label.  Handle\n\toutput of the wrapped LTO sections, index and names table.\n\nlibiberty:\n\n\tPR target/48108\n\t* simple-object-mach-o.c  (GNU_WRAPPER_SECTS, GNU_WRAPPER_INDEX,\n\tGNU_WRAPPER_NAMES): New macros.\n\t(simple_object_mach_o_segment): Handle wrapper scheme.\n\t(simple_object_mach_o_write_section_header): Allow the segment name\n\tto be supplied.\n\t(simple_object_mach_o_write_segment): Handle wrapper scheme.  Ensure\n\tthat the top-level segment name in the load command is empty.\n\t(simple_object_mach_o_write_to_file): Determine the number of\n\tsections during segment output, use that in writing the header.\n\nFrom-SVN: r180523", "tree": {"sha": "039da77aa32443d7a75ccb7ce1ccffc11fbdb255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/039da77aa32443d7a75ccb7ce1ccffc11fbdb255"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d44b26bdf402498112c770368f75529847d13067", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d44b26bdf402498112c770368f75529847d13067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d44b26bdf402498112c770368f75529847d13067"}], "stats": {"total": 708, "additions": 576, "deletions": 132}, "files": [{"sha": "de8a85516db3063a758a696d4cfe861a7266980e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f", "patch": "@@ -1,3 +1,16 @@\n+2011-10-14  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tPR target/48108\n+\t* config/darwin.c (top level): Amend comments concerning LTO output.\n+\t(lto_section_num): New variable.  (darwin_lto_section_e): New GTY.\n+\t(LTO_SECTS_SECTION, LTO_INDEX_SECTION): New.\n+\t(LTO_NAMES_SECTION): Rename.\n+\t(darwin_asm_named_section): Record LTO section counts and switches\n+\tin a vec of darwin_lto_section_e.\n+\t(darwin_file_start): Remove unused code.\n+\t(darwin_file_end): Put an LTO section termination label.  Handle\n+\toutput of the wrapped LTO sections, index and names table.\n+\n 2011-10-26  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (rs6000_make_savres_rtx): Delete unneeded"}, {"sha": "7c33a533fff1ab18c91e7fe2235638be29c9fb47", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 115, "deletions": 52, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f", "patch": "@@ -1753,19 +1753,51 @@ darwin_label_is_anonymous_local_objc_name (const char *name)\n   return (!strncmp ((const char *)p, \"_OBJC_\", 6));\n }\n \n-/* LTO support for Mach-O.  */\n+/* LTO support for Mach-O.\n \n-/* Section names for LTO sections.  */\n-static unsigned int lto_section_names_offset = 0;\n+   This version uses three mach-o sections to encapsulate the (unlimited\n+   number of) lto sections.\n \n-/* This is the obstack which we use to allocate the many strings.  */\n-static struct obstack lto_section_names_obstack;\n+   __GNU_LTO, __lto_sections  contains the concatented GNU LTO section data.\n+   __GNU_LTO, __section_names contains the GNU LTO section names.\n+   __GNU_LTO, __section_index contains an array of values that index these.\n \n-/* Segment name for LTO sections.  */\n+   Indexed thus:\n+     <section offset from the start of __GNU_LTO, __lto_sections>,\n+     <section length>\n+     <name offset from the start of __GNU_LTO, __section_names,\n+     <name length>.\n+\n+   At present, for both m32 and m64 mach-o files each of these fields is\n+   represented  by a uint32_t.  This is because, AFAICT, a mach-o object\n+   cannot exceed 4Gb because the section_64 offset field (see below) is 32bits.\n+\n+    uint32_t offset;\n+   \"offset  An integer specifying the offset to this section in the file.\"  */\n+\n+/* Count lto section numbers.  */\n+static unsigned int lto_section_num = 0;\n+\n+/* A vector of information about LTO sections, at present, we only have\n+   the name.  TODO: see if we can get the data length somehow.  */\n+typedef struct GTY (()) darwin_lto_section_e {\n+  const char *sectname;\n+} darwin_lto_section_e ;\n+DEF_VEC_O(darwin_lto_section_e);\n+DEF_VEC_ALLOC_O(darwin_lto_section_e, gc);\n+\n+static GTY (()) VEC (darwin_lto_section_e, gc) * lto_section_names;\n+\n+/* Segment for LTO data.  */\n #define LTO_SEGMENT_NAME \"__GNU_LTO\"\n \n-/* Section name for LTO section names section.  */\n-#define LTO_NAMES_SECTION \"__section_names\"\n+/* Section wrapper scheme (used here to wrap the unlimited number of LTO\n+   sections into three Mach-O ones).\n+   NOTE: These names MUST be kept in sync with those in\n+\t libiberty/simple-object-mach-o.  */\n+#define LTO_SECTS_SECTION \"__wrapper_sects\"\n+#define LTO_NAMES_SECTION \"__wrapper_names\"\n+#define LTO_INDEX_SECTION \"__wrapper_index\"\n \n /* File to temporarily store LTO data.  This is appended to asm_out_file\n    in darwin_end_file.  */\n@@ -1808,37 +1840,38 @@ darwin_asm_named_section (const char *name,\n \t\t\t  unsigned int flags,\n \t\t\t  tree decl ATTRIBUTE_UNUSED)\n {\n-  /* LTO sections go in a special segment __GNU_LTO.  We want to replace the\n-     section name with something we can use to represent arbitrary-length\n-     names (section names in Mach-O are at most 16 characters long).  */\n+  /* LTO sections go in a special section that encapsulates the (unlimited)\n+     number of GNU LTO sections within a single mach-o one.  */\n   if (strncmp (name, LTO_SECTION_NAME_PREFIX,\n \t       strlen (LTO_SECTION_NAME_PREFIX)) == 0)\n     {\n+      darwin_lto_section_e e;\n       /* We expect certain flags to be set...  */\n       gcc_assert ((flags & (SECTION_DEBUG | SECTION_NAMED))\n \t\t  == (SECTION_DEBUG | SECTION_NAMED));\n \n-      /* Add the section name to the things to output when we end the\n-\t current assembler output file.\n-\t This is all not very efficient, but that doesn't matter -- this\n-\t shouldn't be a hot path in the compiler...  */\n-      obstack_1grow (&lto_section_names_obstack, '\\t');\n-      obstack_grow (&lto_section_names_obstack, \".ascii \", 7);\n-      obstack_1grow (&lto_section_names_obstack, '\"');\n-      obstack_grow (&lto_section_names_obstack, name, strlen (name));\n-      obstack_grow (&lto_section_names_obstack, \"\\\\0\\\"\\n\", 4);\n-\n-      /* Output the dummy section name.  */\n-      fprintf (asm_out_file, \"\\t# %s\\n\", name);\n-      fprintf (asm_out_file, \"\\t.section %s,__%08X,regular,debug\\n\",\n-\t       LTO_SEGMENT_NAME, lto_section_names_offset);\n-\n-      /* Update the offset for the next section name.  Make sure we stay\n-\t within reasonable length.  */  \n-      lto_section_names_offset += strlen (name) + 1;\n-      gcc_assert (lto_section_names_offset > 0\n-\t\t  && lto_section_names_offset < ((unsigned) 1 << 31));\n-    }\n+      /* Switch to our combined section.  */\n+      fprintf (asm_out_file, \"\\t.section %s,%s,regular,debug\\n\",\n+\t       LTO_SEGMENT_NAME, LTO_SECTS_SECTION);\n+      /* Output a label for the start of this sub-section.  */\n+      fprintf (asm_out_file, \"L_GNU_LTO%d:\\t;# %s\\n\",\n+\t       lto_section_num, name);\n+      /* We have to jump through hoops to get the values of the intra-section\n+         offsets... */\n+      fprintf (asm_out_file, \"\\t.set L$gnu$lto$offs%d,L_GNU_LTO%d-L_GNU_LTO0\\n\",\n+\t       lto_section_num, lto_section_num);\n+      fprintf (asm_out_file,\n+\t       \"\\t.set L$gnu$lto$size%d,L_GNU_LTO%d-L_GNU_LTO%d\\n\",\n+\t       lto_section_num, lto_section_num+1, lto_section_num);\n+      lto_section_num++;\n+      e.sectname = xstrdup (name);\n+      /* Keep the names, we'll need to make a table later.\n+         TODO: check that we do not revisit sections, that would break\n+         the assumption of how this is done.  */\n+      if (lto_section_names == NULL)\n+        lto_section_names = VEC_alloc (darwin_lto_section_e, gc, 16);\n+      VEC_safe_push (darwin_lto_section_e, gc, lto_section_names, &e);\n+   }\n   else if (strncmp (name, \"__DWARF,\", 8) == 0)\n     darwin_asm_dwarf_section (name, flags, decl);\n   else\n@@ -2711,16 +2744,12 @@ darwin_asm_output_dwarf_offset (FILE *file, int size, const char * lab,\n   darwin_asm_output_dwarf_delta (file, size, lab, sname);\n }\n \n-/* Called from the within the TARGET_ASM_FILE_START for each target. \n-  Initialize the stuff we need for LTO long section names support.  */\n+/* Called from the within the TARGET_ASM_FILE_START for each target.  */\n \n void\n darwin_file_start (void)\n {\n-  /* We fill this obstack with the complete section text for the lto section\n-     names to write in darwin_file_end.  */\n-  obstack_init (&lto_section_names_obstack);\n-  lto_section_names_offset = 0;\n+  /* Nothing to do.  */\n }\n \n /* Called for the TARGET_ASM_FILE_END hook.\n@@ -2731,8 +2760,6 @@ darwin_file_start (void)\n void\n darwin_file_end (void)\n {\n-  const char *lto_section_names;\n-\n   machopic_finish (asm_out_file);\n   if (strcmp (lang_hooks.name, \"GNU C++\") == 0)\n     {\n@@ -2762,6 +2789,13 @@ darwin_file_end (void)\n \t  lto_asm_txt = buf = (char *) xmalloc (n + 1);\n \t  while (fgets (lto_asm_txt, n, lto_asm_out_file))\n \t    fputs (lto_asm_txt, asm_out_file);\n+\t  /* Put a termination label.  */\n+\t  fprintf (asm_out_file, \"\\t.section %s,%s,regular,debug\\n\",\n+\t\t   LTO_SEGMENT_NAME, LTO_SECTS_SECTION);\n+\t  fprintf (asm_out_file, \"L_GNU_LTO%d:\\t;# end of lto\\n\",\n+\t\t   lto_section_num);\n+\t  /* Make sure our termination label stays in this section.  */\n+\t  fputs (\"\\t.space\\t1\\n\", asm_out_file);\n \t}\n \n       /* Remove the temporary file.  */\n@@ -2770,21 +2804,50 @@ darwin_file_end (void)\n       free (lto_asm_out_name);\n     }\n \n-  /* Finish the LTO section names obstack.  Don't output anything if\n-     there are no recorded section names.  */\n-  obstack_1grow (&lto_section_names_obstack, '\\0');\n-  lto_section_names = XOBFINISH (&lto_section_names_obstack, const char *);\n-  if (strlen (lto_section_names) > 0)\n+  /* Output the names and indices.  */\n+  if (lto_section_names && VEC_length (darwin_lto_section_e, lto_section_names))\n     {\n-      fprintf (asm_out_file,\n-\t       \"\\t.section %s,%s,regular,debug\\n\",\n+      int count;\n+      darwin_lto_section_e *ref;\n+      /* For now, we'll make the offsets 4 bytes and unaligned - we'll fix\n+         the latter up ourselves.  */\n+      const char *op = integer_asm_op (4,0);\n+\n+      /* Emit the names.  */\n+      fprintf (asm_out_file, \"\\t.section %s,%s,regular,debug\\n\",\n \t       LTO_SEGMENT_NAME, LTO_NAMES_SECTION);\n-      fprintf (asm_out_file,\n-\t       \"\\t# Section names in %s are offsets into this table\\n\",\n-\t       LTO_SEGMENT_NAME);\n-      fprintf (asm_out_file, \"%s\\n\", lto_section_names);\n+      FOR_EACH_VEC_ELT (darwin_lto_section_e, lto_section_names, count, ref)\n+\t{\n+\t  fprintf (asm_out_file, \"L_GNU_LTO_NAME%d:\\n\", count);\n+         /* We have to jump through hoops to get the values of the intra-section\n+            offsets... */\n+\t  fprintf (asm_out_file,\n+\t\t   \"\\t.set L$gnu$lto$noff%d,L_GNU_LTO_NAME%d-L_GNU_LTO_NAME0\\n\",\n+\t\t   count, count);\n+\t  fprintf (asm_out_file,\n+\t\t   \"\\t.set L$gnu$lto$nsiz%d,L_GNU_LTO_NAME%d-L_GNU_LTO_NAME%d\\n\",\n+\t\t   count, count+1, count);\n+\t  fprintf (asm_out_file, \"\\t.asciz\\t\\\"%s\\\"\\n\", ref->sectname);\n+\t}\n+      fprintf (asm_out_file, \"L_GNU_LTO_NAME%d:\\t;# end\\n\", lto_section_num);\n+      /* make sure our termination label stays in this section.  */\n+      fputs (\"\\t.space\\t1\\n\", asm_out_file);\n+\n+      /* Emit the Index.  */\n+      fprintf (asm_out_file, \"\\t.section %s,%s,regular,debug\\n\",\n+\t       LTO_SEGMENT_NAME, LTO_INDEX_SECTION);\n+      fputs (\"\\t.align\\t2\\n\", asm_out_file);\n+      fputs (\"# Section offset, Section length, Name offset, Name length\\n\",\n+\t     asm_out_file);\n+      FOR_EACH_VEC_ELT (darwin_lto_section_e, lto_section_names, count, ref)\n+\t{\n+\t  fprintf (asm_out_file, \"%s L$gnu$lto$offs%d\\t;# %s\\n\",\n+\t\t   op, count, ref->sectname);\n+\t  fprintf (asm_out_file, \"%s L$gnu$lto$size%d\\n\", op, count);\n+\t  fprintf (asm_out_file, \"%s L$gnu$lto$noff%d\\n\", op, count);\n+\t  fprintf (asm_out_file, \"%s L$gnu$lto$nsiz%d\\n\", op, count);\n+\t}\n     }\n-  obstack_free (&lto_section_names_obstack, NULL);\n \n   /* If we have section anchors, then we must prevent the linker from\n      re-arranging data.  */"}, {"sha": "8f8e9b2246b852229b9c34646a887a110aa3a12c", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f", "patch": "@@ -1,3 +1,16 @@\n+2011-10-26  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tPR target/48108\n+\t* simple-object-mach-o.c  (GNU_WRAPPER_SECTS, GNU_WRAPPER_INDEX,\n+\tGNU_WRAPPER_NAMES): New macros.\n+\t(simple_object_mach_o_segment): Handle wrapper scheme.\n+\t(simple_object_mach_o_write_section_header): Allow the segment name\n+\tto be supplied.\n+\t(simple_object_mach_o_write_segment): Handle wrapper scheme.  Ensure\n+\tthat the top-level segment name in the load command is empty.\n+\t(simple_object_mach_o_write_to_file): Determine the number of\n+\tsections during segment output, use that in writing the header.\n+\n 2011-10-10  Ian Lance Taylor  <iant@google.com>\n \n \tPR c++/48665"}, {"sha": "af5e4f9ca8841d825b56d6bc044d268f30ab9cfd", "filename": "libiberty/simple-object-mach-o.c", "status": "modified", "additions": 435, "deletions": 80, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f/libiberty%2Fsimple-object-mach-o.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f/libiberty%2Fsimple-object-mach-o.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-mach-o.c?ref=b20577eae4e8e74d9f33e66b9a3b5a8d5b5ddd6f", "patch": "@@ -1,5 +1,5 @@\n /* simple-object-mach-o.c -- routines to manipulate Mach-O object files.\n-   Copyright 2010 Free Software Foundation, Inc.\n+   Copyright 2010, 2011 Free Software Foundation, Inc.\n    Written by Ian Lance Taylor, Google.\n \n This program is free software; you can redistribute it and/or modify it\n@@ -174,6 +174,15 @@ struct mach_o_section_64\n \n #define GNU_SECTION_NAMES \"__section_names\"\n \n+/* A GNU-specific extension to wrap multiple sections using three\n+   mach-o sections within a given segment.  The section '__wrapper_sects'\n+   is subdivided according to the index '__wrapper_index' and each sub\n+   sect is named according to the names supplied in '__wrapper_names'.  */\n+\n+#define GNU_WRAPPER_SECTS \"__wrapper_sects\"\n+#define GNU_WRAPPER_INDEX \"__wrapper_index\"\n+#define GNU_WRAPPER_NAMES \"__wrapper_names\"\n+\n /* Private data for an simple_object_read.  */\n \n struct simple_object_mach_o_read\n@@ -214,7 +223,18 @@ struct simple_object_mach_o_attributes\n   unsigned int reserved;\n };\n \n-/* See if we have a Mach-O file.  */\n+/* See if we have a Mach-O MH_OBJECT file:\n+\n+   A standard MH_OBJECT (from as) will have three load commands:\n+   0 - LC_SEGMENT/LC_SEGMENT64\n+   1 - LC_SYMTAB\n+   2 - LC_DYSYMTAB\n+\n+   The LC_SEGMENT/LC_SEGMENT64 will introduce a single anonymous segment\n+   containing all the sections.\n+\n+   Files written by simple-object will have only the segment command\n+   (no symbol tables).  */\n \n static void *\n simple_object_mach_o_match (\n@@ -356,8 +376,29 @@ simple_object_mach_o_section_info (int is_big_endian, int is_32,\n     }\n }\n \n-/* Handle a segment in a Mach-O file.  Return 1 if we should continue,\n-   0 if the caller should return.  */\n+/* Handle a segment in a Mach-O Object file.\n+\n+   This will callback to the function pfn for each \"section found\" the meaning\n+   of which depends on gnu extensions to mach-o:\n+\n+   If we find mach-o sections (with the segment name as specified) which also\n+   contain: a 'sects' wrapper, an index, and a  name table, we expand this into\n+   as many sections as are specified in the index.  In this case, there will\n+   be a callback for each of these.\n+\n+   We will also allow an extension that permits long names (more than 16\n+   characters) to be used with mach-o.  In this case, the section name has\n+   a specific format embedding an index into a name table, and the file must\n+   contain such name table.\n+\n+   Return 1 if we should continue, 0 if the caller should return.  */\n+\n+#define SOMO_SECTS_PRESENT 0x01\n+#define SOMO_INDEX_PRESENT 0x02\n+#define SOMO_NAMES_PRESENT 0x04\n+#define SOMO_LONGN_PRESENT 0x08\n+#define SOMO_WRAPPING (SOMO_SECTS_PRESENT | SOMO_INDEX_PRESENT \\\n+\t\t       | SOMO_NAMES_PRESENT)\n \n static int\n simple_object_mach_o_segment (simple_object_read *sobj, off_t offset,\n@@ -378,9 +419,20 @@ simple_object_mach_o_segment (simple_object_read *sobj, off_t offset,\n   unsigned int nsects;\n   unsigned char *secdata;\n   unsigned int i;\n+  unsigned int gnu_sections_found;\n   unsigned int strtab_index;\n+  unsigned int index_index;\n+  unsigned int nametab_index;\n+  unsigned int sections_index;\n   char *strtab;\n+  char *nametab;\n+  unsigned char *index;\n   size_t strtab_size;\n+  size_t nametab_size;\n+  size_t index_size;\n+  unsigned int n_wrapped_sects;\n+  size_t wrapper_sect_size;\n+  off_t wrapper_sect_offset;\n \n   fetch_32 = (omr->is_big_endian\n \t      ? simple_object_fetch_big_32\n@@ -409,6 +461,8 @@ simple_object_mach_o_segment (simple_object_read *sobj, off_t offset,\n \t\t\t\t\tnsects));\n     }\n \n+  /* Fetch the section headers from the segment command.  */\n+\n   secdata = XNEWVEC (unsigned char, nsects * sechdrsize);\n   if (!simple_object_internal_read (sobj->descriptor, offset + seghdrsize,\n \t\t\t\t    secdata, nsects * sechdrsize, errmsg, err))\n@@ -417,28 +471,117 @@ simple_object_mach_o_segment (simple_object_read *sobj, off_t offset,\n       return 0;\n     }\n \n-  /* Scan for a __section_names section.  This is in effect a GNU\n-     extension that permits section names longer than 16 chars.  */\n+  /* Scan for special sections that signal GNU extensions to the format.  */\n \n+  gnu_sections_found = 0;\n+  index_index = nsects;\n+  sections_index = nsects;\n+  strtab_index = nsects;\n+  nametab_index = nsects;\n   for (i = 0; i < nsects; ++i)\n     {\n       size_t nameoff;\n \n       nameoff = i * sechdrsize + segname_offset;\n       if (strcmp ((char *) secdata + nameoff, omr->segment_name) != 0)\n \tcontinue;\n+\n       nameoff = i * sechdrsize + sectname_offset;\n-      if (strcmp ((char *) secdata + nameoff, GNU_SECTION_NAMES) == 0)\n-\tbreak;\n+      if (strcmp ((char *) secdata + nameoff, GNU_WRAPPER_NAMES) == 0)\n+\t{\n+\t  nametab_index = i;\n+\t  gnu_sections_found |= SOMO_NAMES_PRESENT;\n+\t}\n+      else if (strcmp ((char *) secdata + nameoff, GNU_WRAPPER_INDEX) == 0)\n+\t{\n+\t  index_index = i;\n+\t  gnu_sections_found |= SOMO_INDEX_PRESENT;\n+\t}\n+      else if (strcmp ((char *) secdata + nameoff, GNU_WRAPPER_SECTS) == 0)\n+\t{\n+\t  sections_index = i;\n+\t  gnu_sections_found |= SOMO_SECTS_PRESENT;\n+\t}\n+      else if (strcmp ((char *) secdata + nameoff, GNU_SECTION_NAMES) == 0)\n+\t{\n+\t  strtab_index = i;\n+\t  gnu_sections_found |= SOMO_LONGN_PRESENT;\n+\t}\n     }\n \n-  strtab_index = i;\n-  if (strtab_index >= nsects)\n+  /* If any of the special wrapper section components is present, then\n+     they all should be.  */\n+\n+  if ((gnu_sections_found & SOMO_WRAPPING) != 0)\n     {\n-      strtab = NULL;\n-      strtab_size = 0;\n+      off_t nametab_offset;\n+      off_t index_offset;\n+\n+      if ((gnu_sections_found & SOMO_WRAPPING) != SOMO_WRAPPING)\n+\t{\n+\t  *errmsg = \"GNU Mach-o section wrapper: required section missing\";\n+\t  *err = 0; /* No useful errno.  */\n+\t  XDELETEVEC (secdata);\n+\t  return 0;\n+\t}\n+\n+      /* Fetch the name table.  */\n+\n+      simple_object_mach_o_section_info (omr->is_big_endian, is_32,\n+\t\t\t\t\t secdata + nametab_index * sechdrsize,\n+\t\t\t\t\t &nametab_offset, &nametab_size);\n+      nametab = XNEWVEC (char, nametab_size);\n+      if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t\tsobj->offset + nametab_offset,\n+\t\t\t\t\t(unsigned char *) nametab, nametab_size,\n+\t\t\t\t\terrmsg, err))\n+\t{\n+\t  XDELETEVEC (nametab);\n+\t  XDELETEVEC (secdata);\n+\t  return 0;\n+\t}\n+\n+      /* Fetch the index.  */\n+\n+      simple_object_mach_o_section_info (omr->is_big_endian, is_32,\n+\t\t\t\t\t secdata + index_index * sechdrsize,\n+\t\t\t\t\t &index_offset, &index_size);\n+      index = XNEWVEC (unsigned char, index_size);\n+      if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t\tsobj->offset + index_offset,\n+\t\t\t\t\tindex, index_size,\n+\t\t\t\t\terrmsg, err))\n+\t{\n+\t  XDELETEVEC (index);\n+\t  XDELETEVEC (nametab);\n+\t  XDELETEVEC (secdata);\n+\t  return 0;\n+\t}\n+\n+      /* The index contains 4 unsigned ints per sub-section:\n+\t sub-section offset/length, sub-section name/length.\n+\t We fix this for both 32 and 64 bit mach-o for now, since\n+\t other fields limit the maximum size of an object to 4G.  */\n+      n_wrapped_sects = index_size / 16;\n+\n+      /* Get the parameters for the wrapper too.  */\n+      simple_object_mach_o_section_info (omr->is_big_endian, is_32,\n+\t\t\t\t\t secdata + sections_index * sechdrsize,\n+\t\t\t\t\t &wrapper_sect_offset,\n+\t\t\t\t\t &wrapper_sect_size);\n     }\n   else\n+    {\n+      index = NULL;\n+      index_size = 0;\n+      nametab = NULL;\n+      nametab_size = 0;\n+      n_wrapped_sects = 0;\n+    }\n+\n+  /* If we have a long names section, fetch it.  */\n+\n+  if ((gnu_sections_found & SOMO_LONGN_PRESENT) != 0)\n     {\n       off_t strtab_offset;\n \n@@ -452,65 +595,137 @@ simple_object_mach_o_segment (simple_object_read *sobj, off_t offset,\n \t\t\t\t\terrmsg, err))\n \t{\n \t  XDELETEVEC (strtab);\n+\t  XDELETEVEC (index);\n+\t  XDELETEVEC (nametab);\n \t  XDELETEVEC (secdata);\n \t  return 0;\n \t}\n     }\n+  else\n+    {\n+      strtab = NULL;\n+      strtab_size = 0;\n+      strtab_index = nsects;\n+    }\n \n   /* Process the sections.  */\n \n   for (i = 0; i < nsects; ++i)\n     {\n       const unsigned char *sechdr;\n-      char namebuf[MACH_O_NAME_LEN + 1];\n+      char namebuf[MACH_O_NAME_LEN * 2 + 2];\n       char *name;\n       off_t secoffset;\n       size_t secsize;\n+      int l;\n \n-      if (i == strtab_index)\n+      sechdr = secdata + i * sechdrsize;\n+\n+      /* We've already processed the long section names.  */\n+\n+      if ((gnu_sections_found & SOMO_LONGN_PRESENT) != 0\n+\t  && i == strtab_index)\n \tcontinue;\n \n-      sechdr = secdata + i * sechdrsize;\n+      /* We only act on the segment named.  */\n \n       if (strcmp ((char *) sechdr + segname_offset, omr->segment_name) != 0)\n \tcontinue;\n \n-      memcpy (namebuf, sechdr + sectname_offset, MACH_O_NAME_LEN);\n-      namebuf[MACH_O_NAME_LEN] = '\\0';\n+      /* Process sections associated with the wrapper.  */\n \n-      name = &namebuf[0];\n-      if (strtab != NULL && name[0] == '_' && name[1] == '_')\n+      if ((gnu_sections_found & SOMO_WRAPPING) != 0)\n \t{\n-\t  unsigned long stringoffset;\n+\t  if (i == nametab_index || i == index_index)\n+\t    continue;\n \n-\t  if (sscanf (name + 2, \"%08lX\", &stringoffset) == 1)\n+\t  if (i == sections_index)\n \t    {\n-\t      if (stringoffset >= strtab_size)\n+\t      unsigned int j;\n+\t      for (j = 0; j < n_wrapped_sects; ++j)\n \t\t{\n-\t\t  *errmsg = \"section name offset out of range\";\n-\t\t  *err = 0;\n-\t\t  XDELETEVEC (strtab);\n-\t\t  XDELETEVEC (secdata);\n-\t\t  return 0;\n+\t\t  unsigned int subsect_offset, subsect_length, name_offset;\n+\t\t  subsect_offset = (*fetch_32) (index + 16 * j);\n+\t\t  subsect_length = (*fetch_32) (index + 16 * j + 4);\n+\t\t  name_offset = (*fetch_32) (index + 16 * j + 8);\n+\t\t  /* We don't need the name_length yet.  */\n+\n+\t\t  secoffset = wrapper_sect_offset + subsect_offset;\n+\t\t  secsize = subsect_length;\n+\t\t  name = nametab + name_offset;\n+\n+\t\t  if (!(*pfn) (data, name, secoffset, secsize))\n+\t\t    {\n+\t\t      *errmsg = NULL;\n+\t\t      *err = 0;\n+\t\t      XDELETEVEC (index);\n+\t\t      XDELETEVEC (nametab);\n+\t\t      XDELETEVEC (strtab);\n+\t\t      XDELETEVEC (secdata);\n+\t\t      return 0;\n+\t\t    }\n \t\t}\n-\n-\t      name = strtab + stringoffset;\n+\t      continue;\n \t    }\n \t}\n \n+      if ((gnu_sections_found & SOMO_LONGN_PRESENT) != 0)\n+\t{\n+\t  memcpy (namebuf, sechdr + sectname_offset, MACH_O_NAME_LEN);\n+\t  namebuf[MACH_O_NAME_LEN] = '\\0';\n+\n+\t  name = &namebuf[0];\n+\t  if (strtab != NULL && name[0] == '_' && name[1] == '_')\n+\t    {\n+\t      unsigned long stringoffset;\n+\n+\t      if (sscanf (name + 2, \"%08lX\", &stringoffset) == 1)\n+\t\t{\n+\t\t  if (stringoffset >= strtab_size)\n+\t\t    {\n+\t\t      *errmsg = \"section name offset out of range\";\n+\t\t      *err = 0;\n+\t\t      XDELETEVEC (index);\n+\t\t      XDELETEVEC (nametab);\n+\t\t      XDELETEVEC (strtab);\n+\t\t      XDELETEVEC (secdata);\n+\t\t      return 0;\n+\t\t    }\n+\n+\t\t  name = strtab + stringoffset;\n+\t\t}\n+\t  }\n+\t}\n+      else\n+\t{\n+\t   /* Otherwise, make a name like __segment,__section as per the\n+\t      convention in mach-o asm.  */\n+\t  name = &namebuf[0];\n+\t  memset (namebuf, 0, MACH_O_NAME_LEN * 2 + 2);\n+\t  memcpy (namebuf, (char *) sechdr + segname_offset, MACH_O_NAME_LEN);\n+\t  l = strlen (namebuf);\n+\t  namebuf[l] = ',';\n+\t  memcpy (namebuf + l + 1, (char *) sechdr + sectname_offset,\n+\t\t  MACH_O_NAME_LEN);\n+\t}\n+\n       simple_object_mach_o_section_info (omr->is_big_endian, is_32, sechdr,\n \t\t\t\t\t &secoffset, &secsize);\n \n       if (!(*pfn) (data, name, secoffset, secsize))\n \t{\n \t  *errmsg = NULL;\n \t  *err = 0;\n+\t  XDELETEVEC (index);\n+\t  XDELETEVEC (nametab);\n \t  XDELETEVEC (strtab);\n \t  XDELETEVEC (secdata);\n \t  return 0;\n \t}\n     }\n \n+  XDELETEVEC (index);\n+  XDELETEVEC (nametab);\n   XDELETEVEC (strtab);\n   XDELETEVEC (secdata);\n \n@@ -724,9 +939,9 @@ static int\n simple_object_mach_o_write_section_header (simple_object_write *sobj,\n \t\t\t\t\t   int descriptor,\n \t\t\t\t\t   size_t sechdr_offset,\n-\t\t\t\t\t   const char *name, size_t secaddr,\n-\t\t\t\t\t   size_t secsize, size_t offset,\n-\t\t\t\t\t   unsigned int align,\n+\t\t\t\t\t   const char *name, const char *segn,\n+\t\t\t\t\t   size_t secaddr, size_t secsize,\n+\t\t\t\t\t   size_t offset, unsigned int align,\n \t\t\t\t\t   const char **errmsg, int *err)\n {\n   struct simple_object_mach_o_attributes *attrs =\n@@ -748,7 +963,7 @@ simple_object_mach_o_write_section_header (simple_object_write *sobj,\n       strncpy ((char *) hdr + offsetof (struct mach_o_section_32, sectname),\n \t       name, MACH_O_NAME_LEN);\n       strncpy ((char *) hdr + offsetof (struct mach_o_section_32, segname),\n-\t       sobj->segment_name, MACH_O_NAME_LEN);\n+\t       segn, MACH_O_NAME_LEN);\n       set_32 (hdr + offsetof (struct mach_o_section_32, addr), secaddr);\n       set_32 (hdr + offsetof (struct mach_o_section_32, size), secsize);\n       set_32 (hdr + offsetof (struct mach_o_section_32, offset), offset);\n@@ -773,7 +988,7 @@ simple_object_mach_o_write_section_header (simple_object_write *sobj,\n       strncpy ((char *) hdr + offsetof (struct mach_o_section_64, sectname),\n \t       name, MACH_O_NAME_LEN);\n       strncpy ((char *) hdr + offsetof (struct mach_o_section_64, segname),\n-\t       sobj->segment_name, MACH_O_NAME_LEN);\n+\t       segn, MACH_O_NAME_LEN);\n       set_64 (hdr + offsetof (struct mach_o_section_64, addr), secaddr);\n       set_64 (hdr + offsetof (struct mach_o_section_64, size), secsize);\n       set_32 (hdr + offsetof (struct mach_o_section_64, offset), offset);\n@@ -793,11 +1008,25 @@ simple_object_mach_o_write_section_header (simple_object_write *sobj,\n \t\t\t\t       sechdrsize, errmsg, err);\n }\n \n-/* Write out the single segment and the sections of a Mach-O file.  */\n+/* Write out the single (anonymous) segment containing the sections of a Mach-O\n+   Object file.\n+\n+   As a GNU extension to mach-o, when the caller specifies a segment name in\n+   sobj->segment_name, all the sections passed will be output under a single\n+   mach-o section header.  The caller's sections are indexed within this\n+   'wrapper' section by a table stored in a second mach-o section.  Finally,\n+   arbitrary length section names are permitted by the extension and these are\n+   stored in a table in a third mach-o section.\n+\n+   Note that this is only likely to make any sense for the __GNU_LTO segment\n+   at present.\n+\n+   If the wrapper extension is not in force, we assume that the section name\n+   is in the form __SEGMENT_NAME,__section_name as per Mach-O asm.  */\n \n static int\n simple_object_mach_o_write_segment (simple_object_write *sobj, int descriptor,\n-\t\t\t\t    size_t nsects, const char **errmsg,\n+\t\t\t\t    size_t *nsects, const char **errmsg,\n \t\t\t\t    int *err)\n {\n   struct simple_object_mach_o_attributes *attrs =\n@@ -814,6 +1043,10 @@ simple_object_mach_o_write_segment (simple_object_write *sobj, int descriptor,\n   simple_object_write_section *section;\n   unsigned char hdrbuf[sizeof (struct mach_o_segment_command_64)];\n   unsigned char *hdr;\n+  size_t nsects_in;\n+  unsigned int *index;\n+  char *snames;\n+  unsigned int sect;\n \n   set_32 = (attrs->is_big_endian\n \t    ? simple_object_set_big_32\n@@ -834,19 +1067,62 @@ simple_object_mach_o_write_segment (simple_object_write *sobj, int descriptor,\n       sechdrsize = sizeof (struct mach_o_section_64);\n     }\n \n+  name_offset = 0;\n+  *nsects = nsects_in = 0;\n+\n+  /* Count the number of sections we start with.  */\n+\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    nsects_in++;\n+\n+  if (sobj->segment_name != NULL)\n+    {\n+      /* We will only write 3 sections: wrapped data, index and names.  */\n+\n+      *nsects = 3;\n+\n+      /* The index has four entries per wrapped section:\n+\t   Section Offset, length,  Name offset, length.\n+\t Where the offsets are based at the start of the wrapper and name\n+\t sections respectively.\n+\t The values are stored as 32 bit int for both 32 and 64 bit mach-o\n+\t since the size of a mach-o MH_OBJECT cannot exceed 4G owing to\n+\t other constraints.  */\n+\n+      index = XNEWVEC (unsigned int, nsects_in * 4);\n+\n+      /* We now need to figure out the size of the names section.  This just\n+\t stores the names as null-terminated c strings, packed without any\n+\t alignment padding.  */\n+\n+      for (section = sobj->sections, sect = 0; section != NULL;\n+\t   section = section->next, sect++)\n+\t{\n+\t  index[sect*4+2] = name_offset;\n+\t  index[sect*4+3] = strlen (section->name) + 1;\n+\t  name_offset += strlen (section->name) + 1;\n+\t}\n+      snames = XNEWVEC (char, name_offset);\n+    }\n+  else\n+    {\n+      *nsects = nsects_in;\n+      index = NULL;\n+      snames = NULL;\n+    }\n+\n   sechdr_offset = hdrsize + seghdrsize;\n-  cmdsize = seghdrsize + nsects * sechdrsize;\n+  cmdsize = seghdrsize + *nsects * sechdrsize;\n   offset = hdrsize + cmdsize;\n-  name_offset = 0;\n   secaddr = 0;\n \n-  for (section = sobj->sections; section != NULL; section = section->next)\n+  for (section = sobj->sections, sect = 0;\n+       section != NULL; section = section->next, sect++)\n     {\n       size_t mask;\n       size_t new_offset;\n       size_t secsize;\n       struct simple_object_write_section_buffer *buffer;\n-      char namebuf[MACH_O_NAME_LEN + 1];\n \n       mask = (1U << section->align) - 1;\n       new_offset = offset + mask;\n@@ -877,39 +1153,126 @@ simple_object_mach_o_write_segment (simple_object_write *sobj, int descriptor,\n \t  secsize += buffer->size;\n \t}\n \n-      snprintf (namebuf, sizeof namebuf, \"__%08X\", name_offset);\n+      if (sobj->segment_name != NULL)\n+\t{\n+\t  index[sect*4+0] = (unsigned int) offset;\n+\t  index[sect*4+1] = secsize;\n+\t  /* Stash the section name in our table.  */\n+\t  memcpy (snames + index[sect * 4 + 2], section->name,\n+\t\t  index[sect * 4 + 3]);\n+\t}\n+      else\n+\t{\n+\t  char namebuf[MACH_O_NAME_LEN + 1];\n+\t  char segnbuf[MACH_O_NAME_LEN + 1];\n+\t  char *comma;\n+\n+\t  /* Try to extract segment,section from the input name.  */\n+\n+\t  memset (namebuf, 0, sizeof namebuf);\n+\t  memset (segnbuf, 0, sizeof segnbuf);\n+\t  comma = strchr (section->name, ',');\n+\t  if (comma != NULL)\n+\t    {\n+\t      int len = comma - section->name;\n+\t      len = len > MACH_O_NAME_LEN ? MACH_O_NAME_LEN : len;\n+\t      strncpy (namebuf, section->name, len);\n+\t      strncpy (segnbuf, comma + 1, MACH_O_NAME_LEN);\n+\t    }\n+\t  else /* just try to copy the name, leave segment blank.  */\n+\t    strncpy (namebuf, section->name, MACH_O_NAME_LEN);\n+\n+\t  if (!simple_object_mach_o_write_section_header (sobj, descriptor,\n+\t\t\t\t\t\t\t  sechdr_offset,\n+\t\t\t\t\t\t\t  namebuf, segnbuf,\n+\t\t\t\t\t\t\t  secaddr, secsize,\n+\t\t\t\t\t\t\t  offset,\n+\t\t\t\t\t\t\t  section->align,\n+\t\t\t\t\t\t\t  errmsg, err))\n+\t    return 0;\n+\t  sechdr_offset += sechdrsize;\n+\t}\n+\n+      offset += secsize;\n+      secaddr += secsize;\n+    }\n+\n+  if (sobj->segment_name != NULL)\n+    {\n+      size_t secsize;\n+      unsigned int i;\n+\n+      /* Write the section header for the wrapper.  */\n+      /* Account for any initial aligment - which becomes the alignment for this\n+\t created section.  */\n+\n+      secsize = (offset - index[0]);\n       if (!simple_object_mach_o_write_section_header (sobj, descriptor,\n-\t\t\t\t\t\t      sechdr_offset, namebuf,\n-\t\t\t\t\t\t      secaddr, secsize, offset,\n-\t\t\t\t\t\t      section->align,\n+\t\t\t\t\t\t      sechdr_offset,\n+\t\t\t\t\t\t      GNU_WRAPPER_SECTS,\n+\t\t\t\t\t\t      sobj->segment_name,\n+\t\t\t\t\t\t      0 /*secaddr*/,\n+\t\t\t\t\t\t      secsize, index[0],\n+\t\t\t\t\t\t      sobj->sections->align,\n \t\t\t\t\t\t      errmsg, err))\n \treturn 0;\n \n+      /* Subtract the wrapper section start from the begining of each sub\n+\t section.  */\n+\n+      for (i = 1; i < nsects_in; ++i)\n+\tindex[4 * i] -= index[0];\n+      index[0] = 0;\n+\n       sechdr_offset += sechdrsize;\n-      offset += secsize;\n-      name_offset += strlen (section->name) + 1;\n-      secaddr += secsize;\n-    }\n \n-  /* Write out the section names.  */\n+      /* Write out the section names.\n+\t ... the header ...\n+\t name_offset contains the length of the section.  It is not aligned.  */\n \n-  if (!simple_object_mach_o_write_section_header (sobj, descriptor,\n-\t\t\t\t\t\t  sechdr_offset,\n-\t\t\t\t\t\t  GNU_SECTION_NAMES, secaddr,\n-\t\t\t\t\t\t  name_offset, offset, 0,\n-\t\t\t\t\t\t  errmsg, err))\n-    return 0;\n+      if (!simple_object_mach_o_write_section_header (sobj, descriptor,\n+\t\t\t\t\t\t      sechdr_offset,\n+\t\t\t\t\t\t      GNU_WRAPPER_NAMES,\n+\t\t\t\t\t\t      sobj->segment_name,\n+\t\t\t\t\t\t      0 /*secaddr*/,\n+\t\t\t\t\t\t      name_offset,\n+\t\t\t\t\t\t      offset,\n+\t\t\t\t\t\t      0, errmsg, err))\n+\treturn 0;\n \n-  for (section = sobj->sections; section != NULL; section = section->next)\n-    {\n-      size_t namelen;\n+      /* ... and the content.. */\n+      if (!simple_object_internal_write (descriptor, offset,\n+\t\t\t\t\t (const unsigned char *) snames,\n+\t\t\t\t\t name_offset, errmsg, err))\n+\treturn 0;\n+\n+      sechdr_offset += sechdrsize;\n+      secaddr += name_offset;\n+      offset += name_offset;\n+\n+      /* Now do the index, we'll align this to 4 bytes although the read code\n+\t will handle unaligned.  */\n+\n+      offset += 3;\n+      offset &= ~0x03;\n+      if (!simple_object_mach_o_write_section_header (sobj, descriptor,\n+\t\t\t\t\t\t      sechdr_offset,\n+\t\t\t\t\t\t      GNU_WRAPPER_INDEX,\n+\t\t\t\t\t\t      sobj->segment_name,\n+\t\t\t\t\t\t      0 /*secaddr*/,\n+\t\t\t\t\t\t      nsects_in * 16,\n+\t\t\t\t\t\t      offset,\n+\t\t\t\t\t\t      2, errmsg, err))\n+\treturn 0;\n \n-      namelen = strlen (section->name) + 1;\n+      /* ... and the content.. */\n       if (!simple_object_internal_write (descriptor, offset,\n-\t\t\t\t\t (const unsigned char *) section->name,\n-\t\t\t\t\t namelen, errmsg, err))\n+\t\t\t\t\t (const unsigned char *) index,\n+\t\t\t\t\t nsects_in*16, errmsg, err))\n \treturn 0;\n-      offset += namelen;\n+\n+      XDELETEVEC (index);\n+      XDELETEVEC (snames);\n     }\n \n   /* Write out the segment header.  */\n@@ -923,9 +1286,8 @@ simple_object_mach_o_write_segment (simple_object_write *sobj, int descriptor,\n \t      MACH_O_LC_SEGMENT);\n       set_32 (hdr + offsetof (struct mach_o_segment_command_32, cmdsize),\n \t      cmdsize);\n-      strncpy (((char *) hdr\n-\t\t+ offsetof (struct mach_o_segment_command_32, segname)),\n-\t       sobj->segment_name, MACH_O_NAME_LEN);\n+     /* MH_OBJECTS have a single, anonymous, segment - so the segment name\n+\t is left empty.  */\n       /* vmaddr left as zero.  */\n       /* vmsize left as zero.  */\n       set_32 (hdr + offsetof (struct mach_o_segment_command_32, fileoff),\n@@ -935,7 +1297,7 @@ simple_object_mach_o_write_segment (simple_object_write *sobj, int descriptor,\n       /* maxprot left as zero.  */\n       /* initprot left as zero.  */\n       set_32 (hdr + offsetof (struct mach_o_segment_command_32, nsects),\n-\t      nsects);\n+\t      *nsects);\n       /* flags left as zero.  */\n     }\n   else\n@@ -951,9 +1313,8 @@ simple_object_mach_o_write_segment (simple_object_write *sobj, int descriptor,\n \t      MACH_O_LC_SEGMENT);\n       set_32 (hdr + offsetof (struct mach_o_segment_command_64, cmdsize),\n \t      cmdsize);\n-      strncpy (((char *) hdr\n-\t\t+ offsetof (struct mach_o_segment_command_64, segname)),\n-\t       sobj->segment_name, MACH_O_NAME_LEN);\n+      /* MH_OBJECTS have a single, anonymous, segment - so the segment name\n+\t is left empty.  */\n       /* vmaddr left as zero.  */\n       /* vmsize left as zero.  */\n       set_64 (hdr + offsetof (struct mach_o_segment_command_64, fileoff),\n@@ -963,7 +1324,7 @@ simple_object_mach_o_write_segment (simple_object_write *sobj, int descriptor,\n       /* maxprot left as zero.  */\n       /* initprot left as zero.  */\n       set_32 (hdr + offsetof (struct mach_o_segment_command_64, nsects),\n-\t      nsects);\n+\t      *nsects);\n       /* flags left as zero.  */\n #endif\n     }\n@@ -978,23 +1339,17 @@ static const char *\n simple_object_mach_o_write_to_file (simple_object_write *sobj, int descriptor,\n \t\t\t\t    int *err)\n {\n-  size_t nsects;\n-  simple_object_write_section *section;\n+  size_t nsects = 0;\n   const char *errmsg;\n \n-  /* Start at 1 for symbol_names section.  */\n-  nsects = 1;\n-  for (section = sobj->sections; section != NULL; section = section->next)\n-    ++nsects;\n+  if (!simple_object_mach_o_write_segment (sobj, descriptor, &nsects,\n+\t\t\t\t\t   &errmsg, err))\n+    return errmsg;\n \n   if (!simple_object_mach_o_write_header (sobj, descriptor, nsects,\n \t\t\t\t\t  &errmsg, err))\n     return errmsg;\n \n-  if (!simple_object_mach_o_write_segment (sobj, descriptor, nsects,\n-\t\t\t\t\t   &errmsg, err))\n-    return errmsg;\n-\n   return NULL;\n }\n "}]}