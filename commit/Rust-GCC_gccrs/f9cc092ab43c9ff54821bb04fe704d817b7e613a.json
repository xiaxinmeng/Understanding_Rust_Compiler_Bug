{"sha": "f9cc092ab43c9ff54821bb04fe704d817b7e613a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjljYzA5MmFiNDNjOWZmNTQ4MjFiYjA0ZmU3MDRkODE3YjdlNjEzYQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "1999-04-12T09:43:37Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "1999-04-12T09:43:37Z"}, "message": "arm.h (target_fp_name, [...]): Const-ify.\n\n* arm.h (target_fp_name, structure_size_string, arm_cpu_select):\nConst-ify.\n* arm.c (target_fp_name, structure_size_string): Const-ify.\n* arm.md (reload_inhi, reload_outhi): Make the scratch DImode.\n* arm.c (arm_reload_in_hi): Handle cases when the input is still\na pseudo, make use of scratch registers for reloading the address\nas appropriate.\n(arm_reload_outhi): Similarly for when the output is still a pseudo.\n* riscix.h (SUBTARGET_SWITCHES): Document.\n\nFrom-SVN: r26368", "tree": {"sha": "8646829e9aa1a088f704b218ddaa48c09562c84b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8646829e9aa1a088f704b218ddaa48c09562c84b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9cc092ab43c9ff54821bb04fe704d817b7e613a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9cc092ab43c9ff54821bb04fe704d817b7e613a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9cc092ab43c9ff54821bb04fe704d817b7e613a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9cc092ab43c9ff54821bb04fe704d817b7e613a/comments", "author": null, "committer": null, "parents": [{"sha": "c3c55f86323524018e8ccf0ba1221bb0198cc254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3c55f86323524018e8ccf0ba1221bb0198cc254", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3c55f86323524018e8ccf0ba1221bb0198cc254"}], "stats": {"total": 297, "additions": 264, "deletions": 33}, "files": [{"sha": "8f086b63474a53cd29e2ae8715bb2cbf72a5acb7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9cc092ab43c9ff54821bb04fe704d817b7e613a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9cc092ab43c9ff54821bb04fe704d817b7e613a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9cc092ab43c9ff54821bb04fe704d817b7e613a", "patch": "@@ -1,3 +1,17 @@\n+Mon Apr 12 09:30:03 1999  Richard Earnshaw (rearnsha@arm.com)\n+\n+\t* arm.h (target_fp_name, structure_size_string, arm_cpu_select):\n+\tConst-ify.\n+\t* arm.c (target_fp_name, structure_size_string): Const-ify.\n+\n+\t* arm.md (reload_inhi, reload_outhi): Make the scratch DImode.\n+\t* arm.c (arm_reload_in_hi): Handle cases when the input is still\n+\ta pseudo, make use of scratch registers for reloading the address\n+\tas appropriate.\n+\t(arm_reload_outhi): Similarly for when the output is still a pseudo.\n+\n+\t* riscix.h (SUBTARGET_SWITCHES): Document.\n+\n 1999-04-12  Bruce Korb <ddsinc09@ix.netcom.com>\n \n \t* fixincludes:"}, {"sha": "dc33088a073fcec743c05fd5e708fb82f91de316", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 236, "deletions": 21, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9cc092ab43c9ff54821bb04fe704d817b7e613a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9cc092ab43c9ff54821bb04fe704d817b7e613a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f9cc092ab43c9ff54821bb04fe704d817b7e613a", "patch": "@@ -84,10 +84,10 @@ enum floating_point_type arm_fpu_arch;\n enum prog_mode_type arm_prgmode;\n \n /* Set by the -mfp=... option */\n-char * target_fp_name = NULL;\n+const char * target_fp_name = NULL;\n \n /* Used to parse -mstructure_size_boundary command line option.  */\n-char * structure_size_string = NULL;\n+const char * structure_size_string = NULL;\n int    arm_structure_size_boundary = 32; /* Used to be 8 */\n \n /* Bit values used to identify processor capabilities.  */\n@@ -3609,64 +3609,279 @@ void\n arm_reload_in_hi (operands)\n      rtx *operands;\n {\n-  rtx base = find_replacement (&XEXP (operands[1], 0));\n+  rtx ref = operands[1];\n+  rtx base, scratch;\n+  HOST_WIDE_INT offset = 0;\n+\n+  if (GET_CODE (ref) == SUBREG)\n+    {\n+      offset = SUBREG_WORD (ref) * UNITS_PER_WORD;\n+      if (BYTES_BIG_ENDIAN)\n+\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (ref)))\n+\t\t   - MIN (UNITS_PER_WORD,\n+\t\t\t  GET_MODE_SIZE (GET_MODE (SUBREG_REG (ref)))));\n+      ref = SUBREG_REG (ref);\n+    }\n+\n+  if (GET_CODE (ref) == REG)\n+    {\n+      /* We have a pseudo which has been spilt onto the stack; there\n+\t are two cases here: the first where there is a simple\n+\t stack-slot replacement and a second where the stack-slot is\n+\t out of range, or is used as a subreg.  */\n+      if (reg_equiv_mem[REGNO (ref)])\n+\t{\n+\t  ref = reg_equiv_mem[REGNO (ref)];\n+\t  base = find_replacement (&XEXP (ref, 0));\n+\t}\n+      else\n+\t/* The slot is out of range, or was dressed up in a SUBREG */\n+\tbase = reg_equiv_address[REGNO (ref)];\n+    }\n+  else\n+    base = find_replacement (&XEXP (ref, 0));\n \n-  emit_insn (gen_zero_extendqisi2 (operands[2], gen_rtx_MEM (QImode, base)));\n   /* Handle the case where the address is too complex to be offset by 1.  */\n   if (GET_CODE (base) == MINUS\n       || (GET_CODE (base) == PLUS && GET_CODE (XEXP (base, 1)) != CONST_INT))\n     {\n-      rtx base_plus = gen_rtx_REG (SImode, REGNO (operands[0]));\n+      rtx base_plus = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n \n       emit_insn (gen_rtx_SET (VOIDmode, base_plus, base));\n       base = base_plus;\n     }\n+  else if (GET_CODE (base) == PLUS)\n+    {\n+      /* The addend must be CONST_INT, or we would have dealt with it above */\n+      HOST_WIDE_INT hi, lo;\n+\n+      offset += INTVAL (XEXP (base, 1));\n+      base = XEXP (base, 0);\n+\n+      /* Rework the address into a legal sequence of insns */\n+      /* Valid range for lo is -4095 -> 4095 */\n+      lo = (offset >= 0\n+\t    ? (offset & 0xfff)\n+\t    : -((-offset) & 0xfff));\n+\n+      /* Corner case, if lo is the max offset then we would be out of range\n+\t once we have added the additional 1 below, so bump the msb into the\n+\t pre-loading insn(s).  */\n+      if (lo == 4095)\n+\tlo &= 0x7ff;\n+\n+      hi = ((((offset - lo) & (HOST_WIDE_INT) 0xFFFFFFFF)\n+\t     ^ (HOST_WIDE_INT) 0x80000000)\n+\t    - (HOST_WIDE_INT) 0x80000000);\n+\n+      if (hi + lo != offset)\n+\tabort ();\n+\n+      if (hi != 0)\n+\t{\n+\t  rtx base_plus = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n+\n+\t  /* Get the base address; addsi3 knows how to handle constants\n+\t     that require more than one insn */\n+\t  emit_insn (gen_addsi3 (base_plus, base, GEN_INT (hi)));\n+\t  base = base_plus;\n+\t  offset = lo;\n+\t}\n+    }\n \n+  scratch = gen_rtx_REG (SImode, REGNO (operands[2]));\n+  emit_insn (gen_zero_extendqisi2 (scratch,\n+\t\t\t\t   gen_rtx_MEM (QImode,\n+\t\t\t\t\t\tplus_constant (base,\n+\t\t\t\t\t\t\t       offset))));\n   emit_insn (gen_zero_extendqisi2 (gen_rtx_SUBREG (SImode, operands[0], 0),\n \t\t\t\t   gen_rtx_MEM (QImode, \n-\t\t\t\t\t\tplus_constant (base, 1))));\n+\t\t\t\t\t\tplus_constant (base,\n+\t\t\t\t\t\t\t       offset + 1))));\n   if (BYTES_BIG_ENDIAN)\n     emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_SUBREG (SImode, operands[0], 0),\n \t\t\tgen_rtx_IOR (SImode, \n \t\t\t\t     gen_rtx_ASHIFT\n \t\t\t\t     (SImode,\n \t\t\t\t      gen_rtx_SUBREG (SImode, operands[0], 0),\n \t\t\t\t      GEN_INT (8)),\n-\t\t\t\t     operands[2])));\n+\t\t\t\t     scratch)));\n   else\n     emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_SUBREG (SImode, operands[0], 0),\n \t\t\t    gen_rtx_IOR (SImode, \n-\t\t\t\t\t gen_rtx_ASHIFT (SImode, operands[2],\n+\t\t\t\t\t gen_rtx_ASHIFT (SImode, scratch,\n \t\t\t\t\t\t\t GEN_INT (8)),\n \t\t\t\t\t gen_rtx_SUBREG (SImode, operands[0],\n \t\t\t\t\t\t\t 0))));\n }\n \n+/* Handle storing a half-word to memory during reload by synthesising as two\n+   byte stores.  Take care not to clobber the input values until after we\n+   have moved them somewhere safe.  This code assumes that if the DImode\n+   scratch in operands[2] overlaps either the input value or output address\n+   in some way, then that value must die in this insn (we absolutely need\n+   two scratch registers for some corner cases).  */\n void\n arm_reload_out_hi (operands)\n      rtx *operands;\n {\n-  rtx base = find_replacement (&XEXP (operands[0], 0));\n+  rtx ref = operands[0];\n+  rtx outval = operands[1];\n+  rtx base, scratch;\n+  HOST_WIDE_INT offset = 0;\n+\n+  if (GET_CODE (ref) == SUBREG)\n+    {\n+      offset = SUBREG_WORD (ref) * UNITS_PER_WORD;\n+      if (BYTES_BIG_ENDIAN)\n+\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (ref)))\n+\t\t   - MIN (UNITS_PER_WORD,\n+\t\t\t  GET_MODE_SIZE (GET_MODE (SUBREG_REG (ref)))));\n+      ref = SUBREG_REG (ref);\n+    }\n+\n+\n+  if (GET_CODE (ref) == REG)\n+    {\n+      /* We have a pseudo which has been spilt onto the stack; there\n+\t are two cases here: the first where there is a simple\n+\t stack-slot replacement and a second where the stack-slot is\n+\t out of range, or is used as a subreg.  */\n+      if (reg_equiv_mem[REGNO (ref)])\n+\t{\n+\t  ref = reg_equiv_mem[REGNO (ref)];\n+\t  base = find_replacement (&XEXP (ref, 0));\n+\t}\n+      else\n+\t/* The slot is out of range, or was dressed up in a SUBREG */\n+\tbase = reg_equiv_address[REGNO (ref)];\n+    }\n+  else\n+    base = find_replacement (&XEXP (ref, 0));\n+\n+  scratch = gen_rtx_REG (SImode, REGNO (operands[2]));\n+\n+  /* Handle the case where the address is too complex to be offset by 1.  */\n+  if (GET_CODE (base) == MINUS\n+      || (GET_CODE (base) == PLUS && GET_CODE (XEXP (base, 1)) != CONST_INT))\n+    {\n+      rtx base_plus = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n+\n+      /* Be careful not to destroy OUTVAL.  */\n+      if (reg_overlap_mentioned_p (base_plus, outval))\n+\t{\n+\t  /* Updating base_plus might destroy outval, see if we can\n+\t     swap the scratch and base_plus.  */\n+\t  if (! reg_overlap_mentioned_p (scratch, outval))\n+\t    {\n+\t      rtx tmp = scratch;\n+\t      scratch = base_plus;\n+\t      base_plus = tmp;\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx scratch_hi = gen_rtx_REG (HImode, REGNO (operands[2]));\n+\n+\t      /* Be conservative and copy OUTVAL into the scratch now,\n+\t\t this should only be necessary if outval is a subreg\n+\t\t of something larger than a word.  */\n+\t      /* XXX Might this clobber base?  I can't see how it can,\n+\t\t since scratch is known to overlap with OUTVAL, and\n+\t\t must be wider than a word.  */\n+\t      emit_insn (gen_movhi (scratch_hi, outval));\n+\t      outval = scratch_hi;\n+\t    }\n+\t}\n+\n+      emit_insn (gen_rtx_SET (VOIDmode, base_plus, base));\n+      base = base_plus;\n+    }\n+  else if (GET_CODE (base) == PLUS)\n+    {\n+      /* The addend must be CONST_INT, or we would have dealt with it above */\n+      HOST_WIDE_INT hi, lo;\n+\n+      offset += INTVAL (XEXP (base, 1));\n+      base = XEXP (base, 0);\n+\n+      /* Rework the address into a legal sequence of insns */\n+      /* Valid range for lo is -4095 -> 4095 */\n+      lo = (offset >= 0\n+\t    ? (offset & 0xfff)\n+\t    : -((-offset) & 0xfff));\n+\n+      /* Corner case, if lo is the max offset then we would be out of range\n+\t once we have added the additional 1 below, so bump the msb into the\n+\t pre-loading insn(s).  */\n+      if (lo == 4095)\n+\tlo &= 0x7ff;\n+\n+      hi = ((((offset - lo) & (HOST_WIDE_INT) 0xFFFFFFFF)\n+\t     ^ (HOST_WIDE_INT) 0x80000000)\n+\t    - (HOST_WIDE_INT) 0x80000000);\n+\n+      if (hi + lo != offset)\n+\tabort ();\n+\n+      if (hi != 0)\n+\t{\n+\t  rtx base_plus = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n+\n+\t  /* Be careful not to destroy OUTVAL.  */\n+\t  if (reg_overlap_mentioned_p (base_plus, outval))\n+\t    {\n+\t      /* Updating base_plus might destroy outval, see if we\n+\t\t can swap the scratch and base_plus.  */\n+\t      if (! reg_overlap_mentioned_p (scratch, outval))\n+\t\t{\n+\t\t  rtx tmp = scratch;\n+\t\t  scratch = base_plus;\n+\t\t  base_plus = tmp;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx scratch_hi = gen_rtx_REG (HImode, REGNO (operands[2]));\n+\n+\t\t  /* Be conservative and copy outval into scratch now,\n+\t\t     this should only be necessary if outval is a\n+\t\t     subreg of something larger than a word.  */\n+\t\t  /* XXX Might this clobber base?  I can't see how it\n+\t\t     can, since scratch is known to overlap with\n+\t\t     outval.  */\n+\t\t  emit_insn (gen_movhi (scratch_hi, outval));\n+\t\t  outval = scratch_hi;\n+\t\t}\n+\t    }\n+\n+\t  /* Get the base address; addsi3 knows how to handle constants\n+\t     that require more than one insn */\n+\t  emit_insn (gen_addsi3 (base_plus, base, GEN_INT (hi)));\n+\t  base = base_plus;\n+\t  offset = lo;\n+\t}\n+    }\n \n   if (BYTES_BIG_ENDIAN)\n     {\n-      emit_insn (gen_movqi (gen_rtx_MEM (QImode, plus_constant (base, 1)),\n-\t\t\t    gen_rtx_SUBREG (QImode, operands[1], 0)));\n-      emit_insn (gen_lshrsi3 (operands[2],\n-\t\t\t      gen_rtx_SUBREG (SImode, operands[1], 0),\n+      emit_insn (gen_movqi (gen_rtx_MEM (QImode, \n+\t\t\t\t\t plus_constant (base, offset + 1)),\n+\t\t\t    gen_rtx_SUBREG (QImode, outval, 0)));\n+      emit_insn (gen_lshrsi3 (scratch,\n+\t\t\t      gen_rtx_SUBREG (SImode, outval, 0),\n \t\t\t      GEN_INT (8)));\n-      emit_insn (gen_movqi (gen_rtx_MEM (QImode, base),\n-\t\t\t    gen_rtx_SUBREG (QImode, operands[2], 0)));\n+      emit_insn (gen_movqi (gen_rtx_MEM (QImode, plus_constant (base, offset)),\n+\t\t\t    gen_rtx_SUBREG (QImode, scratch, 0)));\n     }\n   else\n     {\n-      emit_insn (gen_movqi (gen_rtx_MEM (QImode, base),\n-\t\t\t    gen_rtx_SUBREG (QImode, operands[1], 0)));\n-      emit_insn (gen_lshrsi3 (operands[2],\n-\t\t\t      gen_rtx_SUBREG (SImode, operands[1], 0),\n+      emit_insn (gen_movqi (gen_rtx_MEM (QImode, plus_constant (base, offset)),\n+\t\t\t    gen_rtx_SUBREG (QImode, outval, 0)));\n+      emit_insn (gen_lshrsi3 (scratch,\n+\t\t\t      gen_rtx_SUBREG (SImode, outval, 0),\n \t\t\t      GEN_INT (8)));\n-      emit_insn (gen_movqi (gen_rtx_MEM (QImode, plus_constant (base, 1)),\n-\t\t\t    gen_rtx_SUBREG (QImode, operands[2], 0)));\n+      emit_insn (gen_movqi (gen_rtx_MEM (QImode,\n+\t\t\t\t\t plus_constant (base, offset + 1)),\n+\t\t\t    gen_rtx_SUBREG (QImode, scratch, 0)));\n     }\n }\n \f"}, {"sha": "86fe2481e1e5142c21a50a20bb8ae3af2f40d3cb", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9cc092ab43c9ff54821bb04fe704d817b7e613a/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9cc092ab43c9ff54821bb04fe704d817b7e613a/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=f9cc092ab43c9ff54821bb04fe704d817b7e613a", "patch": "@@ -248,7 +248,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n extern int target_flags;\n \n /* The floating point instruction architecture, can be 2 or 3 */\n-extern char * target_fp_name;\n+extern const char * target_fp_name;\n \n /* Nonzero if the function prologue (and epilogue) should obey\n    the ARM Procedure Call Standard.  */\n@@ -404,9 +404,9 @@ function tries to return. */\n \n struct arm_cpu_select\n {\n-  char *              string;\n-  char *              name;\n-  struct processors * processors;\n+  const char *              string;\n+  const char *              name;\n+  const struct processors * processors;\n };\n \n /* This is a magic array.  If the user specifies a command line switch\n@@ -585,7 +585,7 @@ extern int arm_is_6_or_7;\n #endif\n \n /* Used when parsing command line option -mstructure_size_boundary.  */\n-extern char * structure_size_string;\n+extern const char * structure_size_string;\n \n /* Non-zero if move instructions will actually fail to work\n    when given unaligned data.  */"}, {"sha": "2c2d48b7e7ff9accc6a6bdab38c492f4ede2f746", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9cc092ab43c9ff54821bb04fe704d817b7e613a/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9cc092ab43c9ff54821bb04fe704d817b7e613a/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=f9cc092ab43c9ff54821bb04fe704d817b7e613a", "patch": "@@ -3128,11 +3128,13 @@\n    mov%?\\\\t%0, %1\\\\t%@ movhi\n    mvn%?\\\\t%0, #%B1\\\\t%@ movhi\")\n \n-\n+;; We use a DImode scratch because we may occasionally need an additional\n+;; temporary if the address isn't offsettable -- push_reload doesn't seem\n+;; to take any notice of the \"o\" constraints on reload_memory_operand operand.\n (define_expand \"reload_outhi\"\n   [(parallel [(match_operand:HI 0 \"reload_memory_operand\" \"=o\")\n \t      (match_operand:HI 1 \"s_register_operand\" \"r\")\n-\t      (match_operand:SI 2 \"s_register_operand\" \"=&r\")])]\n+\t      (match_operand:DI 2 \"s_register_operand\" \"=&r\")])]\n   \"\"\n   \"\n   arm_reload_out_hi (operands);\n@@ -3142,7 +3144,7 @@\n (define_expand \"reload_inhi\"\n   [(parallel [(match_operand:HI 0 \"s_register_operand\" \"=r\")\n \t      (match_operand:HI 1 \"reload_memory_operand\" \"o\")\n-\t      (match_operand:SI 2 \"s_register_operand\" \"=&r\")])]\n+\t      (match_operand:DI 2 \"s_register_operand\" \"=&r\")])]\n   \"TARGET_SHORT_BY_BYTES\"\n   \"\n   arm_reload_in_hi (operands);"}, {"sha": "fad0293337a6121e305864faadc3f5fccd0ac6a1", "filename": "gcc/config/arm/riscix.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9cc092ab43c9ff54821bb04fe704d817b7e613a/gcc%2Fconfig%2Farm%2Friscix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9cc092ab43c9ff54821bb04fe704d817b7e613a/gcc%2Fconfig%2Farm%2Friscix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Friscix.h?ref=f9cc092ab43c9ff54821bb04fe704d817b7e613a", "patch": "@@ -79,10 +79,10 @@ Boston, MA 02111-1307, USA.  */\n /* None of these is actually used in cc1.  If we don't define them in target\n    switches cc1 complains about them.  For the sake of argument lets allocate\n    bit 31 of target flags for such options.  */\n-#define SUBTARGET_SWITCHES \t\t\\\n-{\"bsd\", 0x80000000, \"\"},\t\t\\\n-{\"xopen\", 0x80000000, \"\"},\t\t\\\n-{\"no-symrename\", 0x80000000, \"\"},\n+#define SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n+  {\"bsd\",\t   0x80000000, \"Do symbol renaming for BSD\"},\t\t\\\n+  {\"xopen\",\t   0x80000000, \"Do symbol renaming for X/OPEN\"},\t\\\n+  {\"no-symrename\", 0x80000000, \"Don't do symbol renaming\"},\n     \n \n /* Run-time Target Specification.  */"}]}