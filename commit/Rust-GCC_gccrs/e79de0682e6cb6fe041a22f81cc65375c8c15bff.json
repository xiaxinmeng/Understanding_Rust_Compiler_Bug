{"sha": "e79de0682e6cb6fe041a22f81cc65375c8c15bff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc5ZGUwNjgyZTZjYjZmZTA0MWEyMmY4MWNjNjUzNzVjOGMxNWJmZg==", "commit": {"author": {"name": "Strager Neds", "email": "strager.nds@gmail.com", "date": "2020-11-11T03:53:14Z"}, "committer": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2020-11-11T03:53:14Z"}, "message": "Refactor section name ref counting\n\ngcc/\n\n\t* symtab.c (symtab_node::set_section_for_node): Extract reference\n\tcounting logic into ...\n\t(retain_section_hash_entry): ... here (new function) and ...\n\t(release_section_hash_entry): ... here (new function).", "tree": {"sha": "3c7884a629f338df8cb95355376bb01f3ae063c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c7884a629f338df8cb95355376bb01f3ae063c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e79de0682e6cb6fe041a22f81cc65375c8c15bff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79de0682e6cb6fe041a22f81cc65375c8c15bff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e79de0682e6cb6fe041a22f81cc65375c8c15bff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79de0682e6cb6fe041a22f81cc65375c8c15bff/comments", "author": {"login": "strager", "id": 48666, "node_id": "MDQ6VXNlcjQ4NjY2", "avatar_url": "https://avatars.githubusercontent.com/u/48666?v=4", "gravatar_id": "", "url": "https://api.github.com/users/strager", "html_url": "https://github.com/strager", "followers_url": "https://api.github.com/users/strager/followers", "following_url": "https://api.github.com/users/strager/following{/other_user}", "gists_url": "https://api.github.com/users/strager/gists{/gist_id}", "starred_url": "https://api.github.com/users/strager/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/strager/subscriptions", "organizations_url": "https://api.github.com/users/strager/orgs", "repos_url": "https://api.github.com/users/strager/repos", "events_url": "https://api.github.com/users/strager/events{/privacy}", "received_events_url": "https://api.github.com/users/strager/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6b797b651f5e3a8a2867053dbaf4f2a70ed27da0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b797b651f5e3a8a2867053dbaf4f2a70ed27da0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b797b651f5e3a8a2867053dbaf4f2a70ed27da0"}], "stats": {"total": 55, "additions": 36, "deletions": 19}, "files": [{"sha": "c84259f1032b2ef6d6b60cabc95777fd9ff4ed8f", "filename": "gcc/symtab.c", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79de0682e6cb6fe041a22f81cc65375c8c15bff/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79de0682e6cb6fe041a22f81cc65375c8c15bff/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=e79de0682e6cb6fe041a22f81cc65375c8c15bff", "patch": "@@ -368,6 +368,36 @@ section_name_hasher::equal (section_hash_entry *n1, const char *name)\n   return n1->name == name || !strcmp (n1->name, name);\n }\n \n+/* Bump the reference count on ENTRY so that it is retained.  */\n+\n+static section_hash_entry *\n+retain_section_hash_entry (section_hash_entry *entry)\n+{\n+  entry->ref_count++;\n+  return entry;\n+}\n+\n+/* Drop the reference count on ENTRY and remove it if the reference\n+   count drops to zero.  */\n+\n+static void\n+release_section_hash_entry (section_hash_entry *entry)\n+{\n+  if (entry)\n+    {\n+      entry->ref_count--;\n+      if (!entry->ref_count)\n+\t{\n+\t  hashval_t hash = htab_hash_string (entry->name);\n+\t  section_hash_entry **slot\n+\t    = symtab->section_hash->find_slot_with_hash (entry->name,\n+\t\t\t\t\t\t hash, INSERT);\n+\t  ggc_free (entry);\n+\t  symtab->section_hash->clear_slot (slot);\n+\t}\n+    }\n+}\n+\n /* Add node into symbol table.  This function is not used directly, but via\n    cgraph/varpool node creation routines.  */\n \n@@ -1609,46 +1639,33 @@ void\n symtab_node::set_section_for_node (const char *section)\n {\n   const char *current = get_section ();\n-  section_hash_entry **slot;\n \n   if (current == section\n       || (current && section\n \t  && !strcmp (current, section)))\n     return;\n \n-  if (current)\n-    {\n-      x_section->ref_count--;\n-      if (!x_section->ref_count)\n-\t{\n-\t  hashval_t hash = htab_hash_string (x_section->name);\n-\t  slot = symtab->section_hash->find_slot_with_hash (x_section->name,\n-\t\t\t\t\t\t\t    hash, INSERT);\n-\t  ggc_free (x_section);\n-\t  symtab->section_hash->clear_slot (slot);\n-\t}\n-      x_section = NULL;\n-    }\n+  release_section_hash_entry (x_section);\n   if (!section)\n     {\n+      x_section = NULL;\n       implicit_section = false;\n       return;\n     }\n   if (!symtab->section_hash)\n     symtab->section_hash = hash_table<section_name_hasher>::create_ggc (10);\n-  slot = symtab->section_hash->find_slot_with_hash (section,\n-\t\t\t\t\t\t    htab_hash_string (section),\n-\t\t\t\t\t\t    INSERT);\n+  section_hash_entry **slot = symtab->section_hash->find_slot_with_hash\n+    (section, htab_hash_string (section), INSERT);\n   if (*slot)\n-    x_section = (section_hash_entry *)*slot;\n+    x_section = retain_section_hash_entry (*slot);\n   else\n     {\n       int len = strlen (section);\n       *slot = x_section = ggc_cleared_alloc<section_hash_entry> ();\n+      x_section->ref_count = 1;\n       x_section->name = ggc_vec_alloc<char> (len + 1);\n       memcpy (x_section->name, section, len + 1);\n     }\n-  x_section->ref_count++;\n }\n \n /* Worker for set_section.  */"}]}