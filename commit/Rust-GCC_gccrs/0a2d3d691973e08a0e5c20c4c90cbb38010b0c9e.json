{"sha": "0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEyZDNkNjkxOTczZTA4YTBlNWMyMGM0YzkwY2JiMzgwMTBiMGM5ZQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-02-06T20:17:00Z"}, "committer": {"name": "Josef Zlomek", "email": "zlomek@gcc.gnu.org", "date": "2004-02-06T20:17:00Z"}, "message": "dwarf2out.c (struct gcc_debug_hooks): Call dwarf2out_begin_function at the beginning of function...\n\n\t* dwarf2out.c (struct gcc_debug_hooks): Call dwarf2out_begin_function\n\tat the beginning of function, call dwarf2out_var_location for\n\tNOTE_INSN_VAR_LOCATION note.\n\t(struct var_loc_node, struct var_loc_list_def, loclabel_num,\n\tdecl_loc_table): New.\n\t(lookup_decl_loc): New function.\n\t(add_var_loc_to_decl): New function.\n\t(based_loc_descr): Added parameter can_use_fbreg, DW_OP_fbreg is used\n\tonly if can_use_fbreg.\n\t(mem_loc_descriptor): Added parameter can_use_fbreg, pass it to other\n\tfunctions.\n\t(loc_descriptor): Likewise. Process VAR_LOCATION.\n\t(concat_loc_descriptor): Call loc_descriptor with can_use_fbreg == true.\n\t(loc_descriptor_from_tree): Call mem_loc_descriptor with\n\tcan_use_fbreg == true.\n\t(add_location_or_const_value_attribute): Added parameter enum\n\tdwarf_attribute attr, generate attribute ATTR.  Create the location list.\n\t(add_bound_info): Call loc_descriptor with can_use_fbreg == true.\n\t(gen_formal_parameter_die): Call add_location_or_const_value_attribute\n\twith attr == DW_AT_location.\n\t(gen_subprogram_die): Generate the location list for DW_AT_frame_base\n\tif frame_base_decl is defined and has a location list.\n\t(gen_variable_die): Call add_location_or_const_value_attribute with\n\tattr == DW_AT_location.\n\t(dwarf2out_var_location): New function.\n\t(dwarf2out_begin_function): New function.\n\t(dwarf2out_init): Create decl_loc_table.\n\nCo-Authored-By: Josef Zlomek <zlomekj@suse.cz>\n\nFrom-SVN: r77421", "tree": {"sha": "d98bc37ca59d5cfa744b6a4d9411d21ff3a847c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d98bc37ca59d5cfa744b6a4d9411d21ff3a847c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f0db3dfca894ec75f6b6a9f360faa9b1253f0a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f0db3dfca894ec75f6b6a9f360faa9b1253f0a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f0db3dfca894ec75f6b6a9f360faa9b1253f0a1"}], "stats": {"total": 409, "additions": 374, "deletions": 35}, "files": [{"sha": "b44197f3e1ae263d39d6ee11913d667176a29c88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e", "patch": "@@ -1,3 +1,34 @@\n+2004-02-06  Daniel Berlin <dberlin@dberlin.org>\n+            Josef Zlomek  <zlomekj@suse.cz>\n+\n+\t* dwarf2out.c (struct gcc_debug_hooks): Call dwarf2out_begin_function\n+\tat the beginning of function, call dwarf2out_var_location for\n+\tNOTE_INSN_VAR_LOCATION note.\n+\t(struct var_loc_node, struct var_loc_list_def, loclabel_num,\n+\tdecl_loc_table): New.\n+\t(lookup_decl_loc): New function.\n+\t(add_var_loc_to_decl): New function.\n+\t(based_loc_descr): Added parameter can_use_fbreg, DW_OP_fbreg is used\n+\tonly if can_use_fbreg.\n+\t(mem_loc_descriptor): Added parameter can_use_fbreg, pass it to other\n+\tfunctions.\n+\t(loc_descriptor): Likewise. Process VAR_LOCATION.\n+\t(concat_loc_descriptor): Call loc_descriptor with can_use_fbreg == true.\n+\t(loc_descriptor_from_tree): Call mem_loc_descriptor with\n+\tcan_use_fbreg == true.\n+\t(add_location_or_const_value_attribute): Added parameter enum\n+\tdwarf_attribute attr, generate attribute ATTR.  Create the location list.\n+\t(add_bound_info): Call loc_descriptor with can_use_fbreg == true.\n+\t(gen_formal_parameter_die): Call add_location_or_const_value_attribute\n+\twith attr == DW_AT_location.\n+\t(gen_subprogram_die): Generate the location list for DW_AT_frame_base\n+\tif frame_base_decl is defined and has a location list.\n+\t(gen_variable_die): Call add_location_or_const_value_attribute with\n+\tattr == DW_AT_location.\n+\t(dwarf2out_var_location): New function.\n+\t(dwarf2out_begin_function): New function.\n+\t(dwarf2out_init): Create decl_loc_table.\n+\n 2004-02-06  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* loop.c (force_movables): Transitively increase the priorities of"}, {"sha": "b35b5ea8ea8b3e4d5e03c6920751ad589b244e4f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 343, "deletions": 35, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=0a2d3d691973e08a0e5c20c4c90cbb38010b0c9e", "patch": "@@ -3251,6 +3251,8 @@ static bool dwarf2out_ignore_block (tree);\n static void dwarf2out_global_decl (tree);\n static void dwarf2out_imported_module_or_decl (tree, tree);\n static void dwarf2out_abstract_function (tree);\n+static void dwarf2out_var_location (rtx);\n+static void dwarf2out_begin_function (tree);\n \n /* The debug hooks structure.  */\n \n@@ -3269,7 +3271,7 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =\n   dwarf2out_begin_prologue,\n   debug_nothing_int_charstar,\t/* end_prologue */\n   dwarf2out_end_epilogue,\n-  debug_nothing_tree,\t\t/* begin_function */\n+  dwarf2out_begin_function,\n   debug_nothing_int,\t\t/* end_function */\n   dwarf2out_decl,\t\t/* function_decl */\n   dwarf2out_global_decl,\n@@ -3281,7 +3283,7 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =\n   dwarf2out_abstract_function,\t/* outlining_inline_function */\n   debug_nothing_rtx,\t\t/* label */\n   debug_nothing_int,\t\t/* handle_pch */\n-  debug_nothing_rtx\t\t/* var_location */\n+  dwarf2out_var_location\n };\n #endif\n \f\n@@ -3477,6 +3479,34 @@ static GTY(()) size_t file_table_last_lookup_index;\n    The key is a DECL_UID() which is a unique number identifying each decl.  */\n static GTY ((param_is (struct die_struct))) htab_t decl_die_table;\n \n+/* Node of the variable location list.  */\n+struct var_loc_node GTY ((chain_next (\"%h.next\")))\n+{\n+  rtx GTY (()) var_loc_note;\n+  const char * GTY (()) label;\n+  struct var_loc_node * GTY (()) next;\n+};\n+\n+/* Variable location list.  */\n+struct var_loc_list_def GTY (())\n+{\n+  struct var_loc_node * GTY (()) first;\n+\n+  /* Do not mark the last element of the chained list because\n+     it is marked through the chain.  */\n+  struct var_loc_node * GTY ((skip (\"%h\"))) last;\n+\n+  /* DECL_UID of the variable decl.  */\n+  unsigned int decl_id;\n+};\n+typedef struct var_loc_list_def var_loc_list;\n+\n+/* Unique label counter.  */\n+static unsigned int loclabel_num = 0;\n+\n+/* Table of decl location linked lists.  */\n+static GTY ((param_is (var_loc_list))) htab_t decl_loc_table;\n+\n /* A pointer to the base of a list of references to DIE's that\n    are uniquely identified by their tag, presence/absence of\n    children DIE's, and list of attribute/value pairs.  */\n@@ -3651,7 +3681,11 @@ static void equate_type_number_to_die (tree, dw_die_ref);\n static hashval_t decl_die_table_hash (const void *);\n static int decl_die_table_eq (const void *, const void *);\n static dw_die_ref lookup_decl_die (tree);\n+static hashval_t decl_loc_table_hash (const void *);\n+static int decl_loc_table_eq (const void *, const void *);\n+static var_loc_list *lookup_decl_loc (tree);\n static void equate_decl_number_to_die (tree, dw_die_ref);\n+static void add_var_loc_to_decl (tree, struct var_loc_node *);\n static void print_spaces (FILE *);\n static void print_die (dw_die_ref, FILE *);\n static void print_dwarf_line_table (FILE *);\n@@ -3717,11 +3751,11 @@ static dw_loc_descr_ref reg_loc_descriptor (rtx);\n static dw_loc_descr_ref one_reg_loc_descriptor (unsigned int);\n static dw_loc_descr_ref multiple_reg_loc_descriptor (rtx, rtx);\n static dw_loc_descr_ref int_loc_descriptor (HOST_WIDE_INT);\n-static dw_loc_descr_ref based_loc_descr (unsigned, HOST_WIDE_INT);\n+static dw_loc_descr_ref based_loc_descr (unsigned, HOST_WIDE_INT, bool);\n static int is_based_loc (rtx);\n-static dw_loc_descr_ref mem_loc_descriptor (rtx, enum machine_mode mode);\n+static dw_loc_descr_ref mem_loc_descriptor (rtx, enum machine_mode mode, bool);\n static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx);\n-static dw_loc_descr_ref loc_descriptor (rtx);\n+static dw_loc_descr_ref loc_descriptor (rtx, bool);\n static dw_loc_descr_ref loc_descriptor_from_tree (tree, int);\n static HOST_WIDE_INT ceiling (HOST_WIDE_INT, unsigned int);\n static tree field_type (tree);\n@@ -3734,7 +3768,8 @@ static void add_AT_location_description\t(dw_die_ref, enum dwarf_attribute,\n static void add_data_member_location_attribute (dw_die_ref, tree);\n static void add_const_value_attribute (dw_die_ref, rtx);\n static rtx rtl_for_decl_location (tree);\n-static void add_location_or_const_value_attribute (dw_die_ref, tree);\n+static void add_location_or_const_value_attribute (dw_die_ref, tree,\n+\t\t\t\t\t\t   enum dwarf_attribute);\n static void tree_add_const_value_attribute (dw_die_ref, tree);\n static void add_name_attribute (dw_die_ref, const char *);\n static void add_comp_dir_attribute (dw_die_ref);\n@@ -5229,6 +5264,31 @@ lookup_decl_die (tree decl)\n   return htab_find_with_hash (decl_die_table, decl, DECL_UID (decl));\n }\n \n+/* Returns a hash value for X (which really is a var_loc_list).  */\n+\n+static hashval_t\n+decl_loc_table_hash (const void *x)\n+{\n+  return (hashval_t) ((const var_loc_list *) x)->decl_id;\n+}\n+\n+/* Return nonzero if decl_id of var_loc_list X is the same as\n+   UID of decl *Y.  */\n+\n+static int\n+decl_loc_table_eq (const void *x, const void *y)\n+{\n+  return (((const var_loc_list *) x)->decl_id == DECL_UID ((const tree) y));\n+}\n+\n+/* Return the var_loc list associated with a given declaration.  */\n+\n+static inline var_loc_list *\n+lookup_decl_loc (tree decl)\n+{\n+  return htab_find_with_hash (decl_loc_table, decl, DECL_UID (decl));\n+}\n+\n /* Equate a DIE to a particular declaration.  */\n \n static void\n@@ -5241,6 +5301,45 @@ equate_decl_number_to_die (tree decl, dw_die_ref decl_die)\n   *slot = decl_die;\n   decl_die->decl_id = decl_id;\n }\n+\n+/* Add a variable location node to the linked list for DECL.  */\n+\n+static void\n+add_var_loc_to_decl (tree decl, struct var_loc_node *loc)\n+{\n+  unsigned int decl_id = DECL_UID (decl);\n+  var_loc_list *temp;\n+  void **slot;\n+\n+  slot = htab_find_slot_with_hash (decl_loc_table, decl, decl_id, INSERT);\n+  if (*slot == NULL)\n+    {\n+      temp = ggc_alloc_cleared (sizeof (var_loc_list));\n+      temp->decl_id = decl_id;\n+      *slot = temp;\n+    }\n+  else\n+    temp = *slot;\n+\n+  if (temp->last)\n+    {\n+      /* If the current location is the same as the end of the list,\n+\t we have nothing to do.  */\n+      if (!rtx_equal_p (NOTE_VAR_LOCATION_LOC (temp->last->var_loc_note),\n+\t\t\tNOTE_VAR_LOCATION_LOC (loc->var_loc_note)))\n+\t{\n+\t  /* Add LOC to the end of list and update LAST.  */\n+\t  temp->last->next = loc;\n+\t  temp->last = loc;\n+\t}\n+    }\n+  /* Do not add empty location to the beginning of the list.  */\n+  else if (NOTE_VAR_LOCATION_LOC (loc->var_loc_note) != NULL_RTX)\n+    {\n+      temp->first = loc;\n+      temp->last = loc;\n+    }\n+}\n \f\n /* Keep track of the number of spaces used to indent the\n    output of the debugging routines that print the structure of\n@@ -8204,7 +8303,7 @@ int_loc_descriptor (HOST_WIDE_INT i)\n /* Return a location descriptor that designates a base+offset location.  */\n \n static dw_loc_descr_ref\n-based_loc_descr (unsigned int reg, HOST_WIDE_INT offset)\n+based_loc_descr (unsigned int reg, HOST_WIDE_INT offset, bool can_use_fbreg)\n {\n   dw_loc_descr_ref loc_result;\n   /* For the \"frame base\", we use the frame pointer or stack pointer\n@@ -8214,7 +8313,7 @@ based_loc_descr (unsigned int reg, HOST_WIDE_INT offset)\n \t\t\t\t\t ? HARD_FRAME_POINTER_REGNUM\n \t\t\t\t\t : STACK_POINTER_REGNUM);\n \n-  if (reg == fp_reg)\n+  if (reg == fp_reg && can_use_fbreg)\n     loc_result = new_loc_descr (DW_OP_fbreg, offset, 0);\n   else if (reg <= 31)\n     loc_result = new_loc_descr (DW_OP_breg0 + reg, offset, 0);\n@@ -8248,10 +8347,15 @@ is_based_loc (rtx rtl)\n    MODE is the mode of the memory reference, needed to handle some\n    autoincrement addressing modes.\n \n+   CAN_USE_FBREG is a flag whether we can use DW_AT_frame_base in the location\n+   list for RTL. We can't use it when we are emitting location list for\n+   virtual variable frame_base_decl (i.e. a location list for DW_AT_frame_base)\n+   which describes how frame base changes when !frame_pointer_needed.\n+\n    Return 0 if we can't represent the location.  */\n \n static dw_loc_descr_ref\n-mem_loc_descriptor (rtx rtl, enum machine_mode mode)\n+mem_loc_descriptor (rtx rtl, enum machine_mode mode, bool can_use_fbreg)\n {\n   dw_loc_descr_ref mem_loc_result = NULL;\n \n@@ -8297,11 +8401,12 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode)\n \t memory) so DWARF consumers need to be aware of the subtle\n \t distinction between OP_REG and OP_BASEREG.  */\n       if (REGNO (rtl) < FIRST_PSEUDO_REGISTER)\n-\tmem_loc_result = based_loc_descr (reg_number (rtl), 0);\n+\tmem_loc_result = based_loc_descr (reg_number (rtl), 0, can_use_fbreg);\n       break;\n \n     case MEM:\n-      mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl));\n+      mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl),\n+\t\t\t\t\t   can_use_fbreg);\n       if (mem_loc_result != 0)\n \tadd_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_deref, 0, 0));\n       break;\n@@ -8368,10 +8473,12 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode)\n     plus:\n       if (is_based_loc (rtl))\n \tmem_loc_result = based_loc_descr (reg_number (XEXP (rtl, 0)),\n-\t\t\t\t\t  INTVAL (XEXP (rtl, 1)));\n+\t\t\t\t\t  INTVAL (XEXP (rtl, 1)),\n+\t\t\t\t\t  can_use_fbreg);\n       else\n \t{\n-\t  mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), mode);\n+\t  mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+\t\t\t\t\t       can_use_fbreg);\n \t  if (mem_loc_result == 0)\n \t    break;\n \n@@ -8383,7 +8490,8 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode)\n \t  else\n \t    {\n \t      add_loc_descr (&mem_loc_result,\n-\t\t\t     mem_loc_descriptor (XEXP (rtl, 1), mode));\n+\t\t\t     mem_loc_descriptor (XEXP (rtl, 1), mode,\n+\t\t\t\t\t\t can_use_fbreg));\n \t      add_loc_descr (&mem_loc_result,\n \t\t\t     new_loc_descr (DW_OP_plus, 0, 0));\n \t    }\n@@ -8394,8 +8502,10 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode)\n       {\n \t/* If a pseudo-reg is optimized away, it is possible for it to\n \t   be replaced with a MEM containing a multiply.  */\n-\tdw_loc_descr_ref op0 = mem_loc_descriptor (XEXP (rtl, 0), mode);\n-\tdw_loc_descr_ref op1 = mem_loc_descriptor (XEXP (rtl, 1), mode);\n+\tdw_loc_descr_ref op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+\t\t\t\t\t\t   can_use_fbreg);\n+\tdw_loc_descr_ref op1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n+\t\t\t\t\t\t   can_use_fbreg);\n \n \tif (op0 == 0 || op1 == 0)\n \t  break;\n@@ -8414,7 +8524,8 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode)\n       /* If this is a MEM, return its address.  Otherwise, we can't\n \t represent this.  */\n       if (GET_CODE (XEXP (rtl, 0)) == MEM)\n-\treturn mem_loc_descriptor (XEXP (XEXP (rtl, 0), 0), mode);\n+\treturn mem_loc_descriptor (XEXP (XEXP (rtl, 0), 0), mode,\n+\t\t\t\t   can_use_fbreg);\n       else\n \treturn 0;\n \n@@ -8432,8 +8543,8 @@ static dw_loc_descr_ref\n concat_loc_descriptor (rtx x0, rtx x1)\n {\n   dw_loc_descr_ref cc_loc_result = NULL;\n-  dw_loc_descr_ref x0_ref = loc_descriptor (x0);\n-  dw_loc_descr_ref x1_ref = loc_descriptor (x1);\n+  dw_loc_descr_ref x0_ref = loc_descriptor (x0, true);\n+  dw_loc_descr_ref x1_ref = loc_descriptor (x1, true);\n \n   if (x0_ref == 0 || x1_ref == 0)\n     return 0;\n@@ -8460,7 +8571,7 @@ concat_loc_descriptor (rtx x0, rtx x1)\n    If we don't know how to describe it, return 0.  */\n \n static dw_loc_descr_ref\n-loc_descriptor (rtx rtl)\n+loc_descriptor (rtx rtl, bool can_use_fbreg)\n {\n   dw_loc_descr_ref loc_result = NULL;\n \n@@ -8481,13 +8592,49 @@ loc_descriptor (rtx rtl)\n       break;\n \n     case MEM:\n-      loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl));\n+      loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl),\n+\t\t\t\t       can_use_fbreg);\n       break;\n \n     case CONCAT:\n       loc_result = concat_loc_descriptor (XEXP (rtl, 0), XEXP (rtl, 1));\n       break;\n \n+    case VAR_LOCATION:\n+      /* Single part.  */\n+      if (GET_CODE (XEXP (rtl, 1)) != PARALLEL)\n+\t{\n+\t  loc_result = loc_descriptor (XEXP (XEXP (rtl, 1), 0), can_use_fbreg);\n+\t}\n+      /* Multiple parts.  */\n+      else\n+\t{\n+\t  rtvec par_elems = XVEC (XEXP (rtl, 1), 0);\n+\t  int num_elem = GET_NUM_ELEM (par_elems);\n+\t  enum machine_mode mode;\n+\t  int i;\n+\n+\t  /* Create the first one, so we have something to add to.  */\n+\t  loc_result = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0),\n+\t\t\t\t       can_use_fbreg);\n+\t  mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, 0), 0));\n+\t  add_loc_descr (&loc_result,\n+\t\t\t new_loc_descr (DW_OP_piece, GET_MODE_SIZE (mode), 0));\n+\t  for (i = 1; i < num_elem; i++)\n+\t    {\n+\t      dw_loc_descr_ref temp;\n+\n+\t      temp = loc_descriptor (XEXP (RTVEC_ELT (par_elems, i), 0),\n+\t\t\t\t     can_use_fbreg);\n+\t      add_loc_descr (&loc_result, temp);\n+\t      mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, i), 0));\n+\t      add_loc_descr (&loc_result,\n+\t\t\t     new_loc_descr (DW_OP_piece,\n+\t\t\t\t\t    GET_MODE_SIZE (mode), 0));\n+\t    }\n+\t}\n+      break;\n+\n     default:\n       abort ();\n     }\n@@ -8603,7 +8750,7 @@ loc_descriptor_from_tree (tree loc, int addressp)\n \t\trtl = XEXP (rtl, 0);\n \t      }\n \n-\t    ret = mem_loc_descriptor (rtl, mode);\n+\t    ret = mem_loc_descriptor (rtl, mode, true);\n \t  }\n       }\n       break;\n@@ -8687,7 +8834,7 @@ loc_descriptor_from_tree (tree loc, int addressp)\n \trtl = (*targetm.delegitimize_address) (rtl);\n \n \tindirect_p = 1;\n-\tret = mem_loc_descriptor (rtl, mode);\n+\tret = mem_loc_descriptor (rtl, mode, true);\n \tbreak;\n       }\n \n@@ -9481,16 +9628,110 @@ rtl_for_decl_location (tree decl)\n    function call evaluates to a compile-time constant address.  */\n \n static void\n-add_location_or_const_value_attribute (dw_die_ref die, tree decl)\n+add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n+\t\t\t\t       enum dwarf_attribute attr)\n {\n   rtx rtl;\n   dw_loc_descr_ref descr;\n+  var_loc_list *loc_list;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return;\n   else if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != PARM_DECL)\n     abort ();\n \n+  /* See if we possibly have multiple locations for this variable.  */\n+  loc_list = lookup_decl_loc (decl);\n+\n+  /* If it truly has multiple locations, the first and last node will\n+     differ.  */\n+  if (loc_list && loc_list->first != loc_list->last)\n+    {\n+      const char *secname;\n+      const char *endname;\n+      dw_loc_list_ref list;\n+      rtx varloc;\n+      struct var_loc_node *node;\n+\n+      /* We need to figure out what section we should use as the base\n+\t for the address ranges where a given location is valid.\n+\t 1. If this particular DECL has a section associated with it,\n+\t use that.\n+\t 2. If this function has a section associated with it, use\n+\t that.\n+\t 3. Otherwise, use the text section.\n+\t XXX: If you split a variable across multiple sections, this\n+\t won't notice.  */\n+\n+      if (DECL_SECTION_NAME (decl))\n+\t{\n+\t  tree sectree = DECL_SECTION_NAME (decl);\n+\t  secname = TREE_STRING_POINTER (sectree);\n+\t}\n+      else if (current_function_decl\n+\t       && DECL_SECTION_NAME (current_function_decl))\n+\t{\n+\t  tree sectree = DECL_SECTION_NAME (current_function_decl);\n+\t  secname = TREE_STRING_POINTER (sectree);\n+\t}\n+      else\n+\tsecname = TEXT_SECTION_NAME;\n+\n+      /* Now that we know what section we are using for a base,\n+         actually construct the list of locations.\n+\t The first location information is what is passed to the\n+\t function that creates the location list, and the remaining\n+\t locations just get added on to that list.\n+\t Note that we only know the start address for a location\n+\t (IE location changes), so to build the range, we use\n+\t the range [current location start, next location start].\n+\t This means we have to special case the last node, and generate\n+\t a range of [last location start, end of function label].  */\n+\n+      node = loc_list->first;\n+      varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n+      list = new_loc_list (loc_descriptor (varloc, attr != DW_AT_frame_base),\n+\t\t\t   node->label, node->next->label, secname, 1);\n+      node = node->next;\n+\n+      for (; node->next; node = node->next)\n+\tif (NOTE_VAR_LOCATION_LOC (node->var_loc_note) != NULL_RTX)\n+\t  {\n+\t    /* The variable has a location between NODE->LABEL and\n+\t       NODE->NEXT->LABEL.  */\n+\t    varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n+\t    add_loc_descr_to_loc_list (&list,\n+\t\t\t\t       loc_descriptor (varloc,\n+\t\t\t\t\t\t       attr != DW_AT_frame_base),\n+\t\t\t\t       node->label, node->next->label, secname);\n+\t  }\n+\n+      /* If the variable has a location at the last label\n+\t it keeps its location until the end of function.  */\n+      if (NOTE_VAR_LOCATION_LOC (node->var_loc_note) != NULL_RTX)\n+\t{\n+\t  char label_id[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+\t  varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n+\t  if (!current_function_decl)\n+\t    endname = text_end_label;\n+\t  else\n+\t    {\n+\t      ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n+\t\t\t\t\t   current_function_funcdef_no);\n+\t      endname = ggc_strdup (label_id);\n+\t    }\n+\t  add_loc_descr_to_loc_list (&list,\n+\t\t\t\t     loc_descriptor (varloc,\n+\t\t\t\t\t\t     attr != DW_AT_frame_base),\n+\t\t\t\t     node->label, endname, secname);\n+\t}\n+\n+      /* Finally, add the location list to the DIE, and we are done.  */\n+      add_AT_loc_list (die, attr, list);\n+      return;\n+    }\n+\n   rtl = rtl_for_decl_location (decl);\n   if (rtl == NULL_RTX)\n     return;\n@@ -9527,9 +9768,9 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl)\n \tcase REG:\n \tcase SUBREG:\n \tcase CONCAT:\n-\t  descr = loc_descriptor (rtl);\n+\t  descr = loc_descriptor (rtl, true);\n \t}\n-      add_AT_location_description (die, DW_AT_location, descr);\n+      add_AT_location_description (die, attr, descr);\n       break;\n \n     case PARALLEL:\n@@ -9540,15 +9781,15 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl)\n \tint i;\n \n \t/* Create the first one, so we have something to add to.  */\n-\tdescr = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0));\n+\tdescr = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0), true);\n \tmode = GET_MODE (XEXP (RTVEC_ELT (par_elems, 0), 0));\n \tadd_loc_descr (&descr,\n \t\t       new_loc_descr (DW_OP_piece, GET_MODE_SIZE (mode), 0));\n \tfor (i = 1; i < num_elem; i++)\n \t  {\n \t    dw_loc_descr_ref temp;\n \n-\t    temp = loc_descriptor (XEXP (RTVEC_ELT (par_elems, i), 0));\n+\t    temp = loc_descriptor (XEXP (RTVEC_ELT (par_elems, i), 0), true);\n \t    add_loc_descr (&descr, temp);\n \t    mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, i), 0));\n \t    add_loc_descr (&descr,\n@@ -9694,7 +9935,7 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr, tree b\n \t  add_AT_flag (decl_die, DW_AT_artificial, 1);\n \t  add_type_attribute (decl_die, TREE_TYPE (bound), 1, 0, ctx);\n \t  add_AT_location_description (decl_die, DW_AT_location,\n-\t\t\t\t       loc_descriptor (loc));\n+\t\t\t\t       loc_descriptor (loc, true));\n \t  add_AT_die_ref (subrange_die, bound_attr, decl_die);\n \t}\n \n@@ -10517,7 +10758,7 @@ gen_formal_parameter_die (tree node, dw_die_ref context_die)\n \n       equate_decl_number_to_die (node, parm_die);\n       if (! DECL_ABSTRACT (node))\n-\tadd_location_or_const_value_attribute (parm_die, node);\n+\tadd_location_or_const_value_attribute (parm_die, node, DW_AT_location);\n \n       break;\n \n@@ -10851,9 +11092,17 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       /* Define the \"frame base\" location for this routine.  We use the\n \t frame pointer or stack pointer registers, since the RTL for local\n \t variables is relative to one of them.  */\n-      fp_reg\n-\t= frame_pointer_needed ? hard_frame_pointer_rtx : stack_pointer_rtx;\n-      add_AT_loc (subr_die, DW_AT_frame_base, reg_loc_descriptor (fp_reg));\n+      if (frame_base_decl && lookup_decl_loc (frame_base_decl) != NULL)\n+\t{\n+\t  add_location_or_const_value_attribute (subr_die, frame_base_decl,\n+\t\t\t\t\t\t DW_AT_frame_base);\n+\t}\n+      else\n+\t{\n+\t  fp_reg\n+\t    = frame_pointer_needed ? hard_frame_pointer_rtx : stack_pointer_rtx;\n+\t  add_AT_loc (subr_die, DW_AT_frame_base, reg_loc_descriptor (fp_reg));\n+\t}\n \n #if 0\n       /* ??? This fails for nested inline functions, because context_display\n@@ -11022,7 +11271,7 @@ gen_variable_die (tree decl, dw_die_ref context_die)\n \n   if (! declaration && ! DECL_ABSTRACT (decl))\n     {\n-      add_location_or_const_value_attribute (var_die, decl);\n+      add_location_or_const_value_attribute (var_die, decl, DW_AT_location);\n       add_pubname (decl, var_die);\n     }\n   else\n@@ -12542,6 +12791,61 @@ init_file_table (void)\n   file_table_last_lookup_index = 0;\n }\n \n+/* Called by the final INSN scan whenever we see a var location.  We\n+   use it to drop labels in the right places, and throw the location in\n+   our lookup table.  */\n+\n+static void\n+dwarf2out_var_location (rtx loc_note)\n+{\n+  char loclabel[MAX_ARTIFICIAL_LABEL_BYTES];\n+  struct var_loc_node *newloc;\n+  rtx prev_insn;\n+  static rtx last_insn;\n+  static const char *last_label;\n+\n+  if (!DECL_P (NOTE_VAR_LOCATION_DECL (loc_note)))\n+    return;\n+  prev_insn = PREV_INSN (loc_note);\n+\n+  newloc = ggc_alloc_cleared (sizeof (struct var_loc_node));\n+  /* If the insn we processed last time is the previous insn\n+     and it is also a var location note, use the label we emitted\n+     last time.  */\n+  if (last_insn != NULL_RTX\n+      && last_insn == prev_insn\n+      && GET_CODE (prev_insn) == NOTE\n+      && NOTE_LINE_NUMBER (prev_insn) == NOTE_INSN_VAR_LOCATION)\n+    {\n+      newloc->label = last_label;\n+    }\n+  else\n+    {\n+      ASM_GENERATE_INTERNAL_LABEL (loclabel, \"LVL\", loclabel_num);\n+      ASM_OUTPUT_DEBUG_LABEL (asm_out_file, \"LVL\", loclabel_num);\n+      loclabel_num++;\n+      newloc->label = ggc_strdup (loclabel);\n+    }\n+  newloc->var_loc_note = loc_note;\n+  newloc->next = NULL;\n+\n+  last_insn = loc_note;\n+  last_label = newloc->label;\n+\n+  add_var_loc_to_decl (NOTE_VAR_LOCATION_DECL (loc_note), newloc);\n+}\n+\n+/* We need to reset the locations at the beginning of each\n+   function. We can't do this in the end_function hook, because the\n+   declarations that use the locations won't have been outputted when\n+   that hook is called.  */\n+\n+static void\n+dwarf2out_begin_function (tree unused ATTRIBUTE_UNUSED)\n+{\n+  htab_empty (decl_loc_table);\n+}\n+\n /* Output a label to mark the beginning of a source code line entry\n    and record information relating to this source line, in\n    'line_info_table' for later output of the .debug_line section.  */\n@@ -12714,10 +13018,14 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n {\n   init_file_table ();\n \n-  /* Allocate the initial hunk of the decl_die_table.  */\n+  /* Allocate the decl_die_table.  */\n   decl_die_table = htab_create_ggc (10, decl_die_table_hash,\n \t\t\t\t    decl_die_table_eq, NULL);\n \n+  /* Allocate the decl_loc_table.  */\n+  decl_loc_table = htab_create_ggc (10, decl_loc_table_hash,\n+\t\t\t\t    decl_loc_table_eq, NULL);\n+\n   /* Allocate the initial hunk of the decl_scope_table.  */\n   VARRAY_TREE_INIT (decl_scope_table, 256, \"decl_scope_table\");\n "}]}