{"sha": "223706ad626f262e18f9ae7786cbc88509b088a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIzNzA2YWQ2MjZmMjYyZTE4ZjlhZTc3ODZjYmM4ODUwOWIwODhhNQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-12-30T18:26:56Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-12-30T18:26:56Z"}, "message": "In gcc/objc/: 2010-12-30 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/objc/:\n2010-12-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* objc-act.c (objc_add_method): When emitting an error because a\n\tmethod with the same name but conflicting types is found in the\n\tsame class or category interface, print a note with the location\n\tof the original method.  Also, improved the error message to\n\tclearly state that the conflict is due to conflicting types, and\n\tproduce it for protocols as well.  Emit an error if two identical\n\tmethods are declared in a protocol, but one is @required and the\n\tother one is @optional.  When\n\nIn gcc/testsuite/:\n2010-12-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n\t\n\t* objc.dg/class-extension-3.m: Updated.\n\t* objc.dg/method-1.m: Updated.\n\t* objc.dg/method-conflict-1.m: New.\n\t* objc.dg/method-conflict-2.m: New.\t\n\t* obj-c++.dg/class-extension-3.mm: Updated.\n\t* obj-c++.dg/method-8.mm: Updated.\n\t* obj-c++.dg/method-conflict-1.mm: New.\n\t* obj-c++.dg/method-conflict-2.mm: New.\n\nFrom-SVN: r168350", "tree": {"sha": "43a6e7abb3563b355e1079efa3f54b7b92198ea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43a6e7abb3563b355e1079efa3f54b7b92198ea8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/223706ad626f262e18f9ae7786cbc88509b088a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/223706ad626f262e18f9ae7786cbc88509b088a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/223706ad626f262e18f9ae7786cbc88509b088a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/223706ad626f262e18f9ae7786cbc88509b088a5/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ae480e548c664521c9c79bfc586b8a2fc135ffde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae480e548c664521c9c79bfc586b8a2fc135ffde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae480e548c664521c9c79bfc586b8a2fc135ffde"}], "stats": {"total": 285, "additions": 244, "deletions": 41}, "files": [{"sha": "43ef65d6ec9fda2bbacf40fb1ad66d212e049c5e", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=223706ad626f262e18f9ae7786cbc88509b088a5", "patch": "@@ -1,4 +1,15 @@\n-2010-12-30  Nicola Pero  <nicola@nicola.brainstorm.co.uk>\n+2010-12-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (objc_add_method): When emitting an error because a\n+\tmethod with the same name but conflicting types is found in the\n+\tsame class or category interface, print a note with the location\n+\tof the original method.  Also, improved the error message to\n+\tclearly state that the conflict is due to conflicting types, and\n+\tproduce it for protocols as well.  Emit an error if two identical\n+\tmethods are declared in a protocol, but one is @required and the\n+\tother one is @optional.  When\n+\n+2010-12-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (start_class): Warn when a class attribute is\n \tignored."}, {"sha": "ec7fea59dd3334c3d69a491d751bc2ae319af5b4", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 95, "deletions": 34, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=223706ad626f262e18f9ae7786cbc88509b088a5", "patch": "@@ -8898,22 +8898,69 @@ add_method_to_hash_list (hash *hash_list, tree method)\n static tree\n objc_add_method (tree klass, tree method, int is_class, bool is_optional)\n {\n-  tree mth;\n+  tree existing_method = NULL_TREE;\n \n-  /* @optional methods are added to protocol's OPTIONAL list.  Note\n-     that this disables checking that the methods are implemented by\n-     classes implementing the protocol, since these checks only use\n-     the CLASS_CLS_METHODS and CLASS_NST_METHODS.  */\n-  if (is_optional)\n+  /* The first thing we do is look up the method in the list of\n+     methods already defined in the interface (or implementation).  */\n+  if (is_class)\n+    existing_method = lookup_method (CLASS_CLS_METHODS (klass), method);\n+  else\n+    existing_method = lookup_method (CLASS_NST_METHODS (klass), method);\n+\n+  /* In the case of protocols, we have a second list of methods to\n+     consider, the list of optional ones.  */\n+  if (TREE_CODE (klass) == PROTOCOL_INTERFACE_TYPE)\n     {\n-      gcc_assert (TREE_CODE (klass) == PROTOCOL_INTERFACE_TYPE);\n-      if (!(mth = lookup_method (is_class\n-\t\t\t\t? PROTOCOL_OPTIONAL_CLS_METHODS (klass)\n-\t\t\t\t: PROTOCOL_OPTIONAL_NST_METHODS (klass), \n-\t\t\t\t\t\t\t\tmethod)))\n+      /* @required methods are added to the protocol's normal list.\n+\t @optional methods are added to the protocol's OPTIONAL lists.\n+\t Note that adding the methods to the optional lists disables\n+\t checking that the methods are implemented by classes\n+\t implementing the protocol, since these checks only use the\n+\t CLASS_CLS_METHODS and CLASS_NST_METHODS.  */\n+\n+      /* First of all, if the method to add is @optional, and we found\n+\t it already existing as @required, emit an error.  */\n+      if (is_optional && existing_method)\n+\t{\n+\t  error (\"method %<%c%E%> declared %<@optional%> and %<@required%> at the same time\",\n+\t\t (is_class ? '+' : '-'),\n+\t\t METHOD_SEL_NAME (existing_method));\n+\t  inform (DECL_SOURCE_LOCATION (existing_method),\n+\t\t  \"previous declaration of %<%c%E%> as %<@required%>\",\n+\t\t  (is_class ? '+' : '-'),\n+\t\t  METHOD_SEL_NAME (existing_method));\n+\t}\n+\n+      /* Now check the list of @optional methods if we didn't find the\n+\t method in the @required list.  */\n+      if (!existing_method)\n \t{\n \t  if (is_class)\n+\t    existing_method = lookup_method (PROTOCOL_OPTIONAL_CLS_METHODS (klass), method);\n+\t  else\n+\t    existing_method = lookup_method (PROTOCOL_OPTIONAL_NST_METHODS (klass), method);\n+\t  \n+\t  if (!is_optional && existing_method)\n \t    {\n+\t      error (\"method %<%c%E%> declared %<@optional%> and %<@required%> at the same time\",\n+\t\t     (is_class ? '+' : '-'),\n+\t\t     METHOD_SEL_NAME (existing_method));\n+\t      inform (DECL_SOURCE_LOCATION (existing_method),\n+\t\t      \"previous declaration of %<%c%E%> as %<@optional%>\",\n+\t\t      (is_class ? '+' : '-'),\n+\t\t      METHOD_SEL_NAME (existing_method));\n+\t    }\n+\t}\n+    }\n+\n+  /* If the method didn't exist already, add it.  */\n+  if (!existing_method)\n+    {\n+      if (is_optional)\n+\t{\n+\t  if (is_class)\n+\t    {\n+\t      /* Put the method on the list in reverse order.  */\n \t      TREE_CHAIN (method) = PROTOCOL_OPTIONAL_CLS_METHODS (klass);\n \t      PROTOCOL_OPTIONAL_CLS_METHODS (klass) = method;\n \t    }\n@@ -8923,36 +8970,50 @@ objc_add_method (tree klass, tree method, int is_class, bool is_optional)\n \t      PROTOCOL_OPTIONAL_NST_METHODS (klass) = method;\n \t    }\n \t}\n-    }\n-  else if (!(mth = lookup_method (is_class\n-\t\t\t     ? CLASS_CLS_METHODS (klass)\n-\t\t\t     : CLASS_NST_METHODS (klass), method)))\n-    {\n-      /* put method on list in reverse order */\n-      if (is_class)\n-\t{\n-\t  DECL_CHAIN (method) = CLASS_CLS_METHODS (klass);\n-\t  CLASS_CLS_METHODS (klass) = method;\n-\t}\n       else\n \t{\n-\t  DECL_CHAIN (method) = CLASS_NST_METHODS (klass);\n-\t  CLASS_NST_METHODS (klass) = method;\n+\t  if (is_class)\n+\t    {\n+\t      DECL_CHAIN (method) = CLASS_CLS_METHODS (klass);\n+\t      CLASS_CLS_METHODS (klass) = method;\n+\t    }\n+\t  else\n+\t    {\n+\t      DECL_CHAIN (method) = CLASS_NST_METHODS (klass);\n+\t      CLASS_NST_METHODS (klass) = method;\n+\t    }\n \t}\n     }\n   else\n     {\n-      /* When processing an @interface for a class or category, give hard\n-\t errors on methods with identical selectors but differing argument\n-\t and/or return types. We do not do this for @implementations, because\n-\t C/C++ will do it for us (i.e., there will be duplicate function\n-\t definition errors).  */\n+      /* The method was already defined.  Check that the types match\n+\t for an @interface for a class or category, or for a\n+\t @protocol.  Give hard errors on methods with identical\n+\t selectors but differing argument and/or return types.  We do\n+\t not do this for @implementations, because C/C++ will do it\n+\t for us (i.e., there will be duplicate function definition\n+\t errors).  */\n       if ((TREE_CODE (klass) == CLASS_INTERFACE_TYPE\n-\t   || TREE_CODE (klass) == CATEGORY_INTERFACE_TYPE)\n-\t  && !comp_proto_with_proto (method, mth, 1))\n-\terror (\"duplicate declaration of method %<%c%E%>\",\n-\t\tis_class ? '+' : '-',\n-\t\tMETHOD_SEL_NAME (mth));\n+\t   || TREE_CODE (klass) == CATEGORY_INTERFACE_TYPE\n+\t   /* Starting with GCC 4.6, we emit the same error for\n+\t      protocols too.  The situation is identical to\n+\t      @interfaces as there is no possible meaningful reason\n+\t      for defining the same method with different signatures\n+\t      in the very same @protocol.  If that was allowed,\n+\t      whenever the protocol is used (both at compile and run\n+\t      time) there wouldn't be any meaningful way to decide\n+\t      which of the two method signatures should be used.  */\n+\t   || TREE_CODE (klass) == PROTOCOL_INTERFACE_TYPE)\n+\t  && !comp_proto_with_proto (method, existing_method, 1))\n+\t{\n+\t  error (\"duplicate declaration of method %<%c%E%> with conflicting types\",\n+\t\t (is_class ? '+' : '-'),\n+\t\t METHOD_SEL_NAME (existing_method));\n+\t  inform (DECL_SOURCE_LOCATION (existing_method),\n+\t\t  \"previous declaration of %<%c%E%>\",\n+\t\t  (is_class ? '+' : '-'),\n+\t\t  METHOD_SEL_NAME (existing_method));\n+\t}\n     }\n \n   if (is_class)"}, {"sha": "681c27ef6793760436606446ce909e5d5e1e34ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=223706ad626f262e18f9ae7786cbc88509b088a5", "patch": "@@ -1,3 +1,14 @@\n+2010-12-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\t\n+\t* objc.dg/class-extension-3.m: Updated.\n+\t* objc.dg/method-1.m: Updated.\n+\t* objc.dg/method-conflict-1.m: New.\n+\t* objc.dg/method-conflict-2.m: New.\t\n+\t* obj-c++.dg/class-extension-3.mm: Updated.\n+\t* obj-c++.dg/method-8.mm: Updated.\n+\t* obj-c++.dg/method-conflict-1.mm: New.\n+\t* obj-c++.dg/method-conflict-2.mm: New.\t\n+\t\n 2010-12-30  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/46889"}, {"sha": "1d9d11b684e817b02809b102234d22ec840130db", "filename": "gcc/testsuite/obj-c++.dg/class-extension-3.mm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fclass-extension-3.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fclass-extension-3.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fclass-extension-3.mm?ref=223706ad626f262e18f9ae7786cbc88509b088a5", "patch": "@@ -10,7 +10,7 @@ @interface MyObject\n   Class isa;\n   int count;\n }\n-- (int) test;\n+- (int) test;        /* { dg-warning \"previous declaration\" } */\n @property int count; /* { dg-warning \"originally specified here\" } */\n @end\n "}, {"sha": "11ec1751bb963c5d98c946fb1e7052880a7db06b", "filename": "gcc/testsuite/obj-c++.dg/method-8.mm", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fmethod-8.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fmethod-8.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fmethod-8.mm?ref=223706ad626f262e18f9ae7786cbc88509b088a5", "patch": "@@ -2,12 +2,12 @@\n /* { dg-do compile } */\n \n @interface class1\n-- (int) meth1;\n+- (int) meth1;   /* { dg-error \"previous declaration\" } */\n - (void) meth1;  /* { dg-error \"duplicate declaration of method .\\\\-meth1.\" } */\n @end\n \n @interface class2\n-+ (void) meth1;\n++ (void) meth1; /* { dg-error \"previous declaration\" } */\n + (int) meth1;  /* { dg-error \"duplicate declaration of method .\\\\+meth1.\" } */\n @end\n "}, {"sha": "9073125ee61ab8e75183ce43098dee5a50d131b4", "filename": "gcc/testsuite/obj-c++.dg/method-conflict-1.mm", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fmethod-conflict-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fmethod-conflict-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fmethod-conflict-1.mm?ref=223706ad626f262e18f9ae7786cbc88509b088a5", "patch": "@@ -0,0 +1,26 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test that you can not declare two methods, in the same protocol,\n+   with the same name but conflicting method signatures.  */\n+\n+@protocol MyProtocol\n++ (int) method1: (int)x;   /* { dg-error \"previous declaration\" } */\n++ (float) method1: (int)x; /* { dg-error \"duplicate declaration of method .\\\\+method1.\" } */\n+\n+- (int) method2: (int)x;   /* { dg-error \"previous declaration\" } */\n+- (int) method2: (float)x; /* { dg-error \"duplicate declaration of method .\\\\-method2.\" } */\n+\n+@optional\n++ (int *) method3: (int)x;    /* { dg-error \"previous declaration\" } */\n++ (int *) method3: (int **)x; /* { dg-error \"duplicate declaration of method .\\\\+method3.\" } */\n+\n+- (id) method4: (id)x;   /* { dg-error \"previous declaration\" } */\n+- (void) method4: (id)x; /* { dg-error \"duplicate declaration of method .\\\\-method4.\" } */\n+@end\n+\n+/* We don't test conflicting types between @required and @optional\n+   methods, as that is tested in method-conflict-2.  */\n+"}, {"sha": "ad6023d1af71a7ec533676d67c9157aa552f3ab4", "filename": "gcc/testsuite/obj-c++.dg/method-conflict-2.mm", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fmethod-conflict-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fmethod-conflict-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fmethod-conflict-2.mm?ref=223706ad626f262e18f9ae7786cbc88509b088a5", "patch": "@@ -0,0 +1,34 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test that you can not declare two methods, in the same protocol,\n+   with the same name and method signature, but one as @required and\n+   once as @optional.  */\n+\n+/* First, @required conflicting with @optional.  */\n+@protocol MyProtocol\n+\n+@optional\n++ (void) method1: (id)x; /* { dg-error \"previous declaration\" } */\n+- (id) method2: (long)x; /* { dg-error \"previous declaration\" } */\n+\n+@required\n++ (void) method1: (id)x; /* { dg-error \"declared .@optional. and .@required. at the same time\" } */\n+- (id) method2: (long)x; /* { dg-error \"declared .@optional. and .@required. at the same time\" } */\n+\n+@end\n+\n+/* Second, @optional conflicting with @required.  */\n+@protocol MyProtocol2\n+\n+@required\n++ (void) method3: (Class)x; /* { dg-error \"previous declaration\" } */\n+- (id *) method4: (long)x;  /* { dg-error \"previous declaration\" } */\n+\n+@optional\n++ (void) method3: (Class)x; /* { dg-error \"declared .@optional. and .@required. at the same time\" } */\n+- (id *) method4: (long)x;  /* { dg-error \"declared .@optional. and .@required. at the same time\" } */\n+\n+@end"}, {"sha": "69e5705396989b4a739eed05f065f61c86664777", "filename": "gcc/testsuite/objc.dg/class-extension-3.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobjc.dg%2Fclass-extension-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobjc.dg%2Fclass-extension-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fclass-extension-3.m?ref=223706ad626f262e18f9ae7786cbc88509b088a5", "patch": "@@ -10,7 +10,7 @@ @interface MyObject\n   Class isa;\n   int count;\n }\n-- (int) test;\n+- (int) test;        /* { dg-message \"previous declaration\" } */\n @property int count; /* { dg-message \"originally specified here\" } */\n @end\n "}, {"sha": "194c64fac4e04dcf3c6d92c4d4878d0c9fdfd476", "filename": "gcc/testsuite/objc.dg/method-1.m", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-1.m?ref=223706ad626f262e18f9ae7786cbc88509b088a5", "patch": "@@ -2,12 +2,12 @@\n /* { dg-do compile } */\n \n @interface class1\n-- (int) meth1;\n+- (int) meth1;   /* { dg-message \"previous declaration\" } */\n - (void) meth1;  /* { dg-error \"duplicate declaration of method .\\\\-meth1.\" } */\n @end\n \n @interface class2\n-+ (void) meth1;\n++ (void) meth1; /* { dg-message \"previous declaration\" } */\n + (int) meth1;  /* { dg-error \"duplicate declaration of method .\\\\+meth1.\" } */\n @end\n "}, {"sha": "2cc96e4fd08ca9c913f624eb1217111ea4319fde", "filename": "gcc/testsuite/objc.dg/method-conflict-1.m", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-conflict-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-conflict-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-conflict-1.m?ref=223706ad626f262e18f9ae7786cbc88509b088a5", "patch": "@@ -0,0 +1,26 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test that you can not declare two methods, in the same protocol,\n+   with the same name but conflicting method signatures.  */\n+\n+@protocol MyProtocol\n++ (int) method1: (int)x;   /* { dg-message \"previous declaration\" } */\n++ (float) method1: (int)x; /* { dg-error \"duplicate declaration of method .\\\\+method1.\" } */\n+\n+- (int) method2: (int)x;   /* { dg-message \"previous declaration\" } */\n+- (int) method2: (float)x; /* { dg-error \"duplicate declaration of method .\\\\-method2.\" } */\n+\n+@optional\n++ (int *) method3: (int)x;    /* { dg-message \"previous declaration\" } */\n++ (int *) method3: (int **)x; /* { dg-error \"duplicate declaration of method .\\\\+method3.\" } */\n+\n+- (id) method4: (id)x;   /* { dg-message \"previous declaration\" } */\n+- (void) method4: (id)x; /* { dg-error \"duplicate declaration of method .\\\\-method4.\" } */\n+@end\n+\n+/* We don't test conflicting types between @required and @optional\n+   methods, as that is tested in method-conflict-2.  */\n+"}, {"sha": "0b0612d771e030da739b481ea8a04e77b96da103", "filename": "gcc/testsuite/objc.dg/method-conflict-2.m", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-conflict-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223706ad626f262e18f9ae7786cbc88509b088a5/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-conflict-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-conflict-2.m?ref=223706ad626f262e18f9ae7786cbc88509b088a5", "patch": "@@ -0,0 +1,34 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test that you can not declare two methods, in the same protocol,\n+   with the same name and method signature, but one as @required and\n+   once as @optional.  */\n+\n+/* First, @required conflicting with @optional.  */\n+@protocol MyProtocol\n+\n+@optional\n++ (void) method1: (id)x; /* { dg-message \"previous declaration\" } */\n+- (id) method2: (long)x; /* { dg-message \"previous declaration\" } */\n+\n+@required\n++ (void) method1: (id)x; /* { dg-error \"declared .@optional. and .@required. at the same time\" } */\n+- (id) method2: (long)x; /* { dg-error \"declared .@optional. and .@required. at the same time\" } */\n+\n+@end\n+\n+/* Second, @optional conflicting with @required.  */\n+@protocol MyProtocol2\n+\n+@required\n++ (void) method3: (Class)x; /* { dg-message \"previous declaration\" } */\n+- (id *) method4: (long)x;  /* { dg-message \"previous declaration\" } */\n+\n+@optional\n++ (void) method3: (Class)x; /* { dg-error \"declared .@optional. and .@required. at the same time\" } */\n+- (id *) method4: (long)x;  /* { dg-error \"declared .@optional. and .@required. at the same time\" } */\n+\n+@end"}]}