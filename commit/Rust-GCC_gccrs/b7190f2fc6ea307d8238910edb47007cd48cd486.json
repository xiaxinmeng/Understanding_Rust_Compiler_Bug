{"sha": "b7190f2fc6ea307d8238910edb47007cd48cd486", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcxOTBmMmZjNmVhMzA3ZDgyMzg5MTBlZGI0NzAwN2NkNDhjZDQ4Ng==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-24T04:06:44Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-24T04:06:44Z"}, "message": "Rename is_open_array_type to is_slice_type.\n\nFrom-SVN: r180361", "tree": {"sha": "ab60c2d0a2afd391b859db4da3bc867fd4f64372", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab60c2d0a2afd391b859db4da3bc867fd4f64372"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7190f2fc6ea307d8238910edb47007cd48cd486", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7190f2fc6ea307d8238910edb47007cd48cd486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7190f2fc6ea307d8238910edb47007cd48cd486", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7190f2fc6ea307d8238910edb47007cd48cd486/comments", "author": null, "committer": null, "parents": [{"sha": "bb12a72a480421a89e860414cf69065fd4607443", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb12a72a480421a89e860414cf69065fd4607443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb12a72a480421a89e860414cf69065fd4607443"}], "stats": {"total": 75, "additions": 37, "deletions": 38}, "files": [{"sha": "97c75584db95658bd622c9dda46f5cd50bc3b0d3", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7190f2fc6ea307d8238910edb47007cd48cd486/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7190f2fc6ea307d8238910edb47007cd48cd486/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=b7190f2fc6ea307d8238910edb47007cd48cd486", "patch": "@@ -234,8 +234,7 @@ Expression::convert_for_assignment(Translate_context* context, Type* lhs_type,\n   else if (rhs_type->interface_type() != NULL)\n     return Expression::convert_interface_to_type(context, lhs_type, rhs_type,\n \t\t\t\t\t\t rhs_tree, location);\n-  else if (lhs_type->is_open_array_type()\n-\t   && rhs_type->is_nil_type())\n+  else if (lhs_type->is_slice_type() && rhs_type->is_nil_type())\n     {\n       // Assigning nil to an open array.\n       go_assert(TREE_CODE(lhs_type_tree) == RECORD_TYPE);\n@@ -3315,7 +3314,7 @@ Type_conversion_expression::do_lower(Gogo*, Named_object*,\n       mpfr_clear(imag);\n     }\n \n-  if (type->is_open_array_type() && type->named_type() == NULL)\n+  if (type->is_slice_type() && type->named_type() == NULL)\n     {\n       Type* element_type = type->array_type()->element_type()->forwarded();\n       bool is_byte = element_type == Type::lookup_integer_type(\"uint8\");\n@@ -3663,7 +3662,7 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n \t\t\t\t   len);\n \t}\n     }\n-  else if (type->is_open_array_type() && expr_type->is_string_type())\n+  else if (type->is_slice_type() && expr_type->is_string_type())\n     {\n       Type* e = type->array_type()->element_type()->forwarded();\n       go_assert(e->integer_type() != NULL);\n@@ -3831,9 +3830,9 @@ Unsafe_type_conversion_expression::do_get_tree(Translate_context* context)\n   source_location loc = this->location();\n \n   bool use_view_convert = false;\n-  if (t->is_open_array_type())\n+  if (t->is_slice_type())\n     {\n-      go_assert(et->is_open_array_type());\n+      go_assert(et->is_slice_type());\n       use_view_convert = true;\n     }\n   else if (t->map_type() != NULL)\n@@ -7302,7 +7301,7 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n       if (args == NULL || args->empty())\n \treturn this;\n       Type* slice_type = args->front()->type();\n-      if (!slice_type->is_open_array_type())\n+      if (!slice_type->is_slice_type())\n \t{\n \t  error_at(args->front()->location(), \"argument 1 must be a slice\");\n \t  this->set_is_error();\n@@ -7342,7 +7341,7 @@ Builtin_call_expression::lower_make()\n   bool is_slice = false;\n   bool is_map = false;\n   bool is_chan = false;\n-  if (type->is_open_array_type())\n+  if (type->is_slice_type())\n     is_slice = true;\n   else if (type->map_type() != NULL)\n     is_map = true;\n@@ -7554,7 +7553,7 @@ Builtin_call_expression::do_is_constant() const\n \n \tif (arg_type->points_to() != NULL\n \t    && arg_type->points_to()->array_type() != NULL\n-\t    && !arg_type->points_to()->is_open_array_type())\n+\t    && !arg_type->points_to()->is_slice_type())\n \t  arg_type = arg_type->points_to();\n \n \tif (arg_type->array_type() != NULL\n@@ -7633,7 +7632,7 @@ Builtin_call_expression::do_integer_constant_value(bool iota_is_constant,\n \n       if (arg_type->points_to() != NULL\n \t  && arg_type->points_to()->array_type() != NULL\n-\t  && !arg_type->points_to()->is_open_array_type())\n+\t  && !arg_type->points_to()->is_slice_type())\n \targ_type = arg_type->points_to();\n \n       if (arg_type->array_type() != NULL\n@@ -8080,7 +8079,7 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t    Type* arg_type = this->one_arg()->type();\n \t    if (arg_type->points_to() != NULL\n \t\t&& arg_type->points_to()->array_type() != NULL\n-\t\t&& !arg_type->points_to()->is_open_array_type())\n+\t\t&& !arg_type->points_to()->is_slice_type())\n \t      arg_type = arg_type->points_to();\n \t    if (this->code_ == BUILTIN_CAP)\n \t      {\n@@ -8135,7 +8134,7 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t\t    || type->channel_type() != NULL\n \t\t    || type->map_type() != NULL\n \t\t    || type->function_type() != NULL\n-\t\t    || type->is_open_array_type())\n+\t\t    || type->is_slice_type())\n \t\t  ;\n \t\telse\n \t\t  this->report_error(_(\"unsupported argument type to \"\n@@ -8192,7 +8191,7 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t  break;\n \n \tType* e1;\n-\tif (arg1_type->is_open_array_type())\n+\tif (arg1_type->is_slice_type())\n \t  e1 = arg1_type->array_type()->element_type();\n \telse\n \t  {\n@@ -8201,7 +8200,7 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t  }\n \n \tType* e2;\n-\tif (arg2_type->is_open_array_type())\n+\tif (arg2_type->is_slice_type())\n \t  e2 = arg2_type->array_type()->element_type();\n \telse if (arg2_type->is_string_type())\n \t  e2 = Type::lookup_integer_type(\"uint8\");\n@@ -8321,7 +8320,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t  {\n \t    arg_type = arg_type->points_to();\n \t    go_assert(arg_type->array_type() != NULL\n-\t\t       && !arg_type->is_open_array_type());\n+\t\t       && !arg_type->is_slice_type());\n \t    go_assert(POINTER_TYPE_P(TREE_TYPE(arg_tree)));\n \t    arg_tree = build_fold_indirect_ref(arg_tree);\n \t  }\n@@ -8515,7 +8514,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t\tfnname = \"__go_print_interface\";\n \t\t      }\n \t\t  }\n-\t\telse if (type->is_open_array_type())\n+\t\telse if (type->is_slice_type())\n \t\t  {\n \t\t    static tree print_slice_fndecl;\n \t\t    pfndecl = &print_slice_fndecl;\n@@ -8694,7 +8693,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tType* arg2_type = arg2->type();\n \ttree arg2_val;\n \ttree arg2_len;\n-\tif (arg2_type->is_open_array_type())\n+\tif (arg2_type->is_slice_type())\n \t  {\n \t    at = arg2_type->array_type();\n \t    arg2_tree = save_expr(arg2_tree);\n@@ -9078,7 +9077,7 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n   source_location loc = this->location();\n \n   go_assert(param_count > 0);\n-  go_assert(varargs_type->is_open_array_type());\n+  go_assert(varargs_type->is_slice_type());\n \n   size_t arg_count = this->args_ == NULL ? 0 : this->args_->size();\n   if (arg_count < param_count - 1)\n@@ -9903,7 +9902,7 @@ Index_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n     return Expression::make_array_index(left, start, end, location);\n   else if (type->points_to() != NULL\n \t   && type->points_to()->array_type() != NULL\n-\t   && !type->points_to()->is_open_array_type())\n+\t   && !type->points_to()->is_slice_type())\n     {\n       Expression* deref = Expression::make_unary(OPERATOR_MULT, left,\n \t\t\t\t\t\t location);\n@@ -10060,7 +10059,7 @@ Array_index_expression::do_type()\n \tthis->type_ = Type::make_error_type();\n       else if (this->end_ == NULL)\n \tthis->type_ = type->element_type();\n-      else if (type->is_open_array_type())\n+      else if (type->is_slice_type())\n \t{\n \t  // A slice of a slice has the same type as the original\n \t  // slice.\n@@ -10150,7 +10149,7 @@ Array_index_expression::do_check_types(Gogo*)\n \n   // A slice of an array requires an addressable array.  A slice of a\n   // slice is always possible.\n-  if (this->end_ != NULL && !array_type->is_open_array_type())\n+  if (this->end_ != NULL && !array_type->is_slice_type())\n     {\n       if (!this->array_->is_addressable())\n \tthis->report_error(_(\"array is not addressable\"));\n@@ -10169,7 +10168,7 @@ Array_index_expression::do_is_addressable() const\n     return false;\n \n   // An index into a slice is addressable.\n-  if (this->array_->type()->is_open_array_type())\n+  if (this->array_->type()->is_slice_type())\n     return true;\n \n   // An index into an array is addressable if the array is\n@@ -12234,7 +12233,7 @@ Expression*\n Expression::make_slice_composite_literal(Type* type, Expression_list* vals,\n \t\t\t\t\t source_location location)\n {\n-  go_assert(type->is_open_array_type());\n+  go_assert(type->is_slice_type());\n   return new Open_array_construction_expression(type, vals, location);\n }\n "}, {"sha": "9998ab81830502ae0282feb6d9808f2bb6471f72", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7190f2fc6ea307d8238910edb47007cd48cd486/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7190f2fc6ea307d8238910edb47007cd48cd486/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=b7190f2fc6ea307d8238910edb47007cd48cd486", "patch": "@@ -3662,7 +3662,7 @@ Variable::type_from_range(Expression* expr, bool get_index_type,\n   if (t->array_type() != NULL\n       || (t->points_to() != NULL\n \t  && t->points_to()->array_type() != NULL\n-\t  && !t->points_to()->is_open_array_type()))\n+\t  && !t->points_to()->is_slice_type()))\n     {\n       if (get_index_type)\n \treturn Type::lookup_integer_type(\"int\");"}, {"sha": "c079fdf285e5d224e6cb38a53142fd6e5659fa6e", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7190f2fc6ea307d8238910edb47007cd48cd486/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7190f2fc6ea307d8238910edb47007cd48cd486/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=b7190f2fc6ea307d8238910edb47007cd48cd486", "patch": "@@ -4319,7 +4319,7 @@ Send_statement::do_get_backend(Translate_context* context)\n \n     case Type::TYPE_ARRAY:\n       is_small = false;\n-      can_take_address = !element_type->is_open_array_type();\n+      can_take_address = !element_type->is_slice_type();\n       break;\n \n     default:\n@@ -5181,7 +5181,7 @@ For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n   Type* range_type = this->range_->type();\n   if (range_type->points_to() != NULL\n       && range_type->points_to()->array_type() != NULL\n-      && !range_type->points_to()->is_open_array_type())\n+      && !range_type->points_to()->is_slice_type())\n     range_type = range_type->points_to();\n \n   Type* index_type;"}, {"sha": "c596de95b446dc007dda9aec517c34cf38516b18", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7190f2fc6ea307d8238910edb47007cd48cd486/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7190f2fc6ea307d8238910edb47007cd48cd486/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=b7190f2fc6ea307d8238910edb47007cd48cd486", "patch": "@@ -240,7 +240,7 @@ Type::points_to() const\n // Return whether this is an open array type.\n \n bool\n-Type::is_open_array_type() const\n+Type::is_slice_type() const\n {\n   return this->array_type() != NULL && this->array_type()->length() == NULL;\n }\n@@ -457,15 +457,15 @@ Type::are_compatible_for_binop(const Type* lhs, const Type* rhs)\n   if (lhs->is_nil_type()\n       && (rhs->points_to() != NULL\n \t  || rhs->interface_type() != NULL\n-\t  || rhs->is_open_array_type()\n+\t  || rhs->is_slice_type()\n \t  || rhs->map_type() != NULL\n \t  || rhs->channel_type() != NULL\n \t  || rhs->function_type() != NULL))\n     return true;\n   if (rhs->is_nil_type()\n       && (lhs->points_to() != NULL\n \t  || lhs->interface_type() != NULL\n-\t  || lhs->is_open_array_type()\n+\t  || lhs->is_slice_type()\n \t  || lhs->map_type() != NULL\n \t  || lhs->channel_type() != NULL\n \t  || lhs->function_type() != NULL))\n@@ -556,7 +556,7 @@ Type::are_assignable_check_hidden(const Type* lhs, const Type* rhs,\n   if (rhs->is_nil_type()\n       && (lhs->points_to() != NULL\n \t  || lhs->function_type() != NULL\n-\t  || lhs->is_open_array_type()\n+\t  || lhs->is_slice_type()\n \t  || lhs->map_type() != NULL\n \t  || lhs->channel_type() != NULL\n \t  || lhs->interface_type() != NULL))\n@@ -662,7 +662,7 @@ Type::are_convertible(const Type* lhs, const Type* rhs, std::string* reason)\n     {\n       if (rhs->integer_type() != NULL)\n \treturn true;\n-      if (rhs->is_open_array_type() && rhs->named_type() == NULL)\n+      if (rhs->is_slice_type() && rhs->named_type() == NULL)\n \t{\n \t  const Type* e = rhs->array_type()->element_type()->forwarded();\n \t  if (e->integer_type() != NULL\n@@ -674,7 +674,7 @@ Type::are_convertible(const Type* lhs, const Type* rhs, std::string* reason)\n \n   // A string may be converted to []byte or []int.\n   if (rhs->is_string_type()\n-      && lhs->is_open_array_type()\n+      && lhs->is_slice_type()\n       && lhs->named_type() == NULL)\n     {\n       const Type* e = lhs->array_type()->element_type()->forwarded();\n@@ -6480,7 +6480,7 @@ Find_type_use::type(Type* type)\n   // essentially a pointer: a pointer, a slice, a function, a map, or\n   // a channel.\n   if (type->points_to() != NULL\n-      || type->is_open_array_type()\n+      || type->is_slice_type()\n       || type->function_type() != NULL\n       || type->map_type() != NULL\n       || type->channel_type() != NULL)\n@@ -6699,7 +6699,7 @@ Named_type::convert(Gogo* gogo)\n \n     case TYPE_ARRAY:\n       // Slice types were completed in create_placeholder.\n-      if (!base->is_open_array_type())\n+      if (!base->is_slice_type())\n \t{\n \t  Btype* bet = base->array_type()->get_backend_element(gogo);\n \t  Bexpression* blen = base->array_type()->get_backend_length(gogo);\n@@ -6789,7 +6789,7 @@ Named_type::create_placeholder(Gogo* gogo)\n       break;\n \n     case TYPE_ARRAY:\n-      if (base->is_open_array_type())\n+      if (base->is_slice_type())\n \tbt = gogo->backend()->placeholder_struct_type(this->name(),\n \t\t\t\t\t\t      this->location_);\n       else\n@@ -6822,7 +6822,7 @@ Named_type::create_placeholder(Gogo* gogo)\n \n   this->named_btype_ = bt;\n \n-  if (base->is_open_array_type())\n+  if (base->is_slice_type())\n     {\n       // We do not record slices as dependencies of other types,\n       // because we can fill them in completely here with the final"}, {"sha": "2ec828f6b2a5278ee3b686e894c095af61ca6270", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7190f2fc6ea307d8238910edb47007cd48cd486/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7190f2fc6ea307d8238910edb47007cd48cd486/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=b7190f2fc6ea307d8238910edb47007cd48cd486", "patch": "@@ -741,9 +741,9 @@ class Type\n   array_type() const\n   { return this->convert<const Array_type, TYPE_ARRAY>(); }\n \n-  // Return whether if this is an open array type.\n+  // Return whether if this is a slice type.\n   bool\n-  is_open_array_type() const;\n+  is_slice_type() const;\n \n   // If this is a map type, return it.  Otherwise, return NULL.\n   Map_type*"}]}