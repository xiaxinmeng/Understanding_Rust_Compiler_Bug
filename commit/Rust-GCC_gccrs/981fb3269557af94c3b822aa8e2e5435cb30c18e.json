{"sha": "981fb3269557af94c3b822aa8e2e5435cb30c18e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgxZmIzMjY5NTU3YWY5NGMzYjgyMmFhOGUyZTU0MzVjYjMwYzE4ZQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2009-12-29T21:05:13Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2009-12-29T21:05:13Z"}, "message": "i386.c (ix86_expand_int_vcond): Reformat.\n\n2009-12-29  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* config/i386/i386.c (ix86_expand_int_vcond): Reformat.\n\nFrom-SVN: r155509", "tree": {"sha": "c8c6bd048741a10458dfeb077438003350ff0ba4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8c6bd048741a10458dfeb077438003350ff0ba4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/981fb3269557af94c3b822aa8e2e5435cb30c18e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/981fb3269557af94c3b822aa8e2e5435cb30c18e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/981fb3269557af94c3b822aa8e2e5435cb30c18e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/981fb3269557af94c3b822aa8e2e5435cb30c18e/comments", "author": null, "committer": null, "parents": [{"sha": "8b5f6dd83d7887c725337c83f302279946767212", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b5f6dd83d7887c725337c83f302279946767212", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b5f6dd83d7887c725337c83f302279946767212"}], "stats": {"total": 194, "additions": 100, "deletions": 94}, "files": [{"sha": "a1160cfcb7fb2a553c2e70a7ebd58b8633980f3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981fb3269557af94c3b822aa8e2e5435cb30c18e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981fb3269557af94c3b822aa8e2e5435cb30c18e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=981fb3269557af94c3b822aa8e2e5435cb30c18e", "patch": "@@ -1,6 +1,10 @@\n+2009-12-29  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config/i386/i386.c (ix86_expand_int_vcond): Reformat.\n+\n 2009-12-29  Dave Korn  <dave.korn.cygwin@gmail.com>\n \n-  2009-10-06 Iain Sandoe <iain.sandoe@sandoe-acoustics.co.uk>\n+\t2009-10-06 Iain Sandoe <iain.sandoe@sandoe-acoustics.co.uk>\n \n \tPR objective-c++/41595\n \t* config/darwin.c (darwin_label_is_anonymous_local_objc_name):"}, {"sha": "3e15b9dd0f545be87a8641ecec502e6a5e9600a7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 95, "deletions": 93, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981fb3269557af94c3b822aa8e2e5435cb30c18e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981fb3269557af94c3b822aa8e2e5435cb30c18e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=981fb3269557af94c3b822aa8e2e5435cb30c18e", "patch": "@@ -16189,116 +16189,118 @@ ix86_expand_int_vcond (rtx operands[])\n   /* XOP supports all of the comparisons on all vector int types.  */\n   if (!TARGET_XOP)\n     {\n-  /* Canonicalize the comparison to EQ, GT, GTU.  */\n-  switch (code)\n-    {\n-    case EQ:\n-    case GT:\n-    case GTU:\n-      break;\n-\n-    case NE:\n-    case LE:\n-    case LEU:\n-      code = reverse_condition (code);\n-      negate = true;\n-      break;\n-\n-    case GE:\n-    case GEU:\n-      code = reverse_condition (code);\n-      negate = true;\n-      /* FALLTHRU */\n-\n-    case LT:\n-    case LTU:\n-      code = swap_condition (code);\n-      x = cop0, cop0 = cop1, cop1 = x;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  /* Only SSE4.1/SSE4.2 supports V2DImode.  */\n-  if (mode == V2DImode)\n-    {\n+      /* Canonicalize the comparison to EQ, GT, GTU.  */\n       switch (code)\n \t{\n \tcase EQ:\n-\t  /* SSE4.1 supports EQ.  */\n-\t  if (!TARGET_SSE4_1)\n-\t    return false;\n-\t  break;\n-\n \tcase GT:\n \tcase GTU:\n-\t  /* SSE4.2 supports GT/GTU.  */\n-\t  if (!TARGET_SSE4_2)\n-\t    return false;\n+\t  break;\n+\n+\tcase NE:\n+\tcase LE:\n+\tcase LEU:\n+\t  code = reverse_condition (code);\n+\t  negate = true;\n+\t  break;\n+\n+\tcase GE:\n+\tcase GEU:\n+\t  code = reverse_condition (code);\n+\t  negate = true;\n+\t  /* FALLTHRU */\n+\n+\tcase LT:\n+\tcase LTU:\n+\t  code = swap_condition (code);\n+\t  x = cop0, cop0 = cop1, cop1 = x;\n \t  break;\n \n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-    }\n \n-  /* Unsigned parallel compare is not supported by the hardware.  Play some\n-     tricks to turn this into a signed comparison against 0.  */\n-  if (code == GTU)\n-    {\n-      cop0 = force_reg (mode, cop0);\n+      /* Only SSE4.1/SSE4.2 supports V2DImode.  */\n+      if (mode == V2DImode)\n+\t{\n+\t  switch (code)\n+\t    {\n+\t    case EQ:\n+\t      /* SSE4.1 supports EQ.  */\n+\t      if (!TARGET_SSE4_1)\n+\t\treturn false;\n+\t      break;\n \n-      switch (mode)\n+\t    case GT:\n+\t    case GTU:\n+\t      /* SSE4.2 supports GT/GTU.  */\n+\t      if (!TARGET_SSE4_2)\n+\t\treturn false;\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+\n+      /* Unsigned parallel compare is not supported by the hardware.\n+\t Play some tricks to turn this into a signed comparison\n+\t against 0.  */\n+      if (code == GTU)\n \t{\n-\tcase V4SImode:\n-\tcase V2DImode:\n-\t  {\n-\t    rtx t1, t2, mask;\n-\n-\t    /* Perform a parallel modulo subtraction.  */\n-\t    t1 = gen_reg_rtx (mode);\n-\t    emit_insn ((mode == V4SImode\n-\t\t\t? gen_subv4si3\n-\t\t\t: gen_subv2di3) (t1, cop0, cop1));\n-\n-\t    /* Extract the original sign bit of op0.  */\n-\t    mask = ix86_build_signbit_mask (GET_MODE_INNER (mode),\n-\t\t\t\t\t    true, false);\n-\t    t2 = gen_reg_rtx (mode);\n-\t    emit_insn ((mode == V4SImode\n-\t\t\t? gen_andv4si3\n-\t\t\t: gen_andv2di3) (t2, cop0, mask));\n-\n-\t    /* XOR it back into the result of the subtraction.  This results\n-\t       in the sign bit set iff we saw unsigned underflow.  */\n-\t    x = gen_reg_rtx (mode);\n-\t    emit_insn ((mode == V4SImode\n-\t\t\t? gen_xorv4si3\n-\t\t\t: gen_xorv2di3) (x, t1, t2));\n-\n-\t    code = GT;\n-\t  }\n-\t  break;\n+\t  cop0 = force_reg (mode, cop0);\n \n-\tcase V16QImode:\n-\tcase V8HImode:\n-\t  /* Perform a parallel unsigned saturating subtraction.  */\n-\t  x = gen_reg_rtx (mode);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, x,\n-\t\t\t\t  gen_rtx_US_MINUS (mode, cop0, cop1)));\n+\t  switch (mode)\n+\t    {\n+\t    case V4SImode:\n+\t    case V2DImode:\n+\t\t{\n+\t\t  rtx t1, t2, mask;\n+\n+\t\t  /* Perform a parallel modulo subtraction.  */\n+\t\t  t1 = gen_reg_rtx (mode);\n+\t\t  emit_insn ((mode == V4SImode\n+\t\t\t      ? gen_subv4si3\n+\t\t\t      : gen_subv2di3) (t1, cop0, cop1));\n+\n+\t\t  /* Extract the original sign bit of op0.  */\n+\t\t  mask = ix86_build_signbit_mask (GET_MODE_INNER (mode),\n+\t\t\t\t\t\t  true, false);\n+\t\t  t2 = gen_reg_rtx (mode);\n+\t\t  emit_insn ((mode == V4SImode\n+\t\t\t      ? gen_andv4si3\n+\t\t\t      : gen_andv2di3) (t2, cop0, mask));\n+\n+\t\t  /* XOR it back into the result of the subtraction.\n+\t\t     This results in the sign bit set iff we saw\n+\t\t     unsigned underflow.  */\n+\t\t  x = gen_reg_rtx (mode);\n+\t\t  emit_insn ((mode == V4SImode\n+\t\t\t      ? gen_xorv4si3\n+\t\t\t      : gen_xorv2di3) (x, t1, t2));\n+\n+\t\t  code = GT;\n+\t\t}\n+\t      break;\n \n-\t  code = EQ;\n-\t  negate = !negate;\n-\t  break;\n+\t    case V16QImode:\n+\t    case V8HImode:\n+\t      /* Perform a parallel unsigned saturating subtraction.  */\n+\t      x = gen_reg_rtx (mode);\n+\t      emit_insn (gen_rtx_SET (VOIDmode, x,\n+\t\t\t\t      gen_rtx_US_MINUS (mode, cop0, cop1)));\n \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+\t      code = EQ;\n+\t      negate = !negate;\n+\t      break;\n \n-      cop0 = x;\n-      cop1 = CONST0_RTX (mode);\n-    }\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\n+\t  cop0 = x;\n+\t  cop1 = CONST0_RTX (mode);\n+\t}\n     }\n \n   x = ix86_expand_sse_cmp (operands[0], code, cop0, cop1,"}]}