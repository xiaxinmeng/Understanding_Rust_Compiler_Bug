{"sha": "61362d9d18916bd5b694385982cf4a02b7537b0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEzNjJkOWQxODkxNmJkNWI2OTQzODU5ODJjZjRhMDJiNzUzN2IwZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-09-30T11:59:16Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-09-30T11:59:16Z"}, "message": "gimple.c (gimple_get_lhs): For PHIs return the result.\n\n2019-09-30  Richard Biener  <rguenther@suse.de>\n\n\t* gimple.c (gimple_get_lhs): For PHIs return the result.\n\t* tree-vectorizer.h (vectorizable_live_operation): Also get the\n\tSLP instance as argument.\n\t* tree-vect-loop.c (vect_analyze_loop_operations): Also handle\n\tdouble-reduction PHIs with vectorizable_lc_phi.\n\t(vect_analyze_loop_operations): Adjust.\n\t(vect_create_epilog_for_reduction): Remove all code not dealing\n\twith reduction LC PHI or epilogue generation.\n\t(vectorizable_live_operation): Call vect_create_epilog_for_reduction\n\tfor live stmts of reductions.\n\t* tree-vect-stmts.c (vectorizable_condition): When !for_reduction\n\tdo not handle defs that are not vect_internal_def.\n\t(can_vectorize_live_stmts): Adjust.\n\t(vect_analyze_stmt): When the vectorized stmt defined a value\n\tused on backedges adjust the backedge uses of vectorized PHIs.\n\nFrom-SVN: r276299", "tree": {"sha": "7b3dbdbfe377d426f7d2bdb1eb1b6441279a7e6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b3dbdbfe377d426f7d2bdb1eb1b6441279a7e6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61362d9d18916bd5b694385982cf4a02b7537b0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61362d9d18916bd5b694385982cf4a02b7537b0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61362d9d18916bd5b694385982cf4a02b7537b0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61362d9d18916bd5b694385982cf4a02b7537b0e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "582c57a17eaf02e90492145cd7217bda5499076b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/582c57a17eaf02e90492145cd7217bda5499076b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/582c57a17eaf02e90492145cd7217bda5499076b"}], "stats": {"total": 404, "additions": 167, "deletions": 237}, "files": [{"sha": "7583de8ac5bfb81c7df3757984f79f0e74b660a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61362d9d18916bd5b694385982cf4a02b7537b0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61362d9d18916bd5b694385982cf4a02b7537b0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61362d9d18916bd5b694385982cf4a02b7537b0e", "patch": "@@ -1,3 +1,21 @@\n+2019-09-30  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple.c (gimple_get_lhs): For PHIs return the result.\n+\t* tree-vectorizer.h (vectorizable_live_operation): Also get the\n+\tSLP instance as argument.\n+\t* tree-vect-loop.c (vect_analyze_loop_operations): Also handle\n+\tdouble-reduction PHIs with vectorizable_lc_phi.\n+\t(vect_analyze_loop_operations): Adjust.\n+\t(vect_create_epilog_for_reduction): Remove all code not dealing\n+\twith reduction LC PHI or epilogue generation.\n+\t(vectorizable_live_operation): Call vect_create_epilog_for_reduction\n+\tfor live stmts of reductions.\n+\t* tree-vect-stmts.c (vectorizable_condition): When !for_reduction\n+\tdo not handle defs that are not vect_internal_def.\n+\t(can_vectorize_live_stmts): Adjust.\n+\t(vect_analyze_stmt): When the vectorized stmt defined a value\n+\tused on backedges adjust the backedge uses of vectorized PHIs.\n+\n 2019-09-30  Martin Jambor  <mjambor@suse.cz>\n \n \tPR ipa/91853"}, {"sha": "8e828a5f169dfcfb83005ff4451e15aa0a32c26c", "filename": "gcc/gimple.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61362d9d18916bd5b694385982cf4a02b7537b0e/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61362d9d18916bd5b694385982cf4a02b7537b0e/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=61362d9d18916bd5b694385982cf4a02b7537b0e", "patch": "@@ -1797,6 +1797,8 @@ gimple_get_lhs (const gimple *stmt)\n     return gimple_assign_lhs (stmt);\n   else if (code == GIMPLE_CALL)\n     return gimple_call_lhs (stmt);\n+  else if (code == GIMPLE_PHI)\n+    return gimple_phi_result (stmt);\n   else\n     return NULL_TREE;\n }"}, {"sha": "69cd683152afd86cfda345272b8f615124c4cd6e", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 76, "deletions": 216, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61362d9d18916bd5b694385982cf4a02b7537b0e/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61362d9d18916bd5b694385982cf4a02b7537b0e/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=61362d9d18916bd5b694385982cf4a02b7537b0e", "patch": "@@ -1526,7 +1526,9 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n \t\t\t  != vect_used_in_outer_by_reduction))\n \t\t    return opt_result::failure_at (phi, \"unsupported phi\\n\");\n \n-\t\t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_internal_def\n+\t\t  if ((STMT_VINFO_DEF_TYPE (stmt_info) == vect_internal_def\n+\t\t       || (STMT_VINFO_DEF_TYPE (stmt_info)\n+\t\t\t   == vect_double_reduction_def))\n \t\t      && !vectorizable_lc_phi (stmt_info, NULL, NULL))\n \t\t    return opt_result::failure_at (phi, \"unsupported phi\\n\");\n                 }\n@@ -1564,8 +1566,8 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n \t  if (ok\n \t      && STMT_VINFO_LIVE_P (stmt_info)\n \t      && !PURE_SLP_STMT (stmt_info))\n-\t    ok = vectorizable_live_operation (stmt_info, NULL, NULL, -1, NULL,\n-\t\t\t\t\t      &cost_vec);\n+\t    ok = vectorizable_live_operation (stmt_info, NULL, NULL, NULL,\n+\t\t\t\t\t      -1, NULL, &cost_vec);\n \n           if (!ok)\n \t    return opt_result::failure_at (phi,\n@@ -4260,6 +4262,20 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n \t\t\t\t  slp_instance slp_node_instance)\n {\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  /* For double reductions we need to get at the inner loop reduction\n+     stmt which has the meta info attached.  Our stmt_info is that of the\n+     loop-closed PHI of the inner loop which we remember as\n+     def for the reduction PHI generation.  */\n+  bool double_reduc = false;\n+  stmt_vec_info rdef_info = stmt_info;\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n+    {\n+      gcc_assert (!slp_node);\n+      double_reduc = true;\n+      stmt_info = loop_vinfo->lookup_def (gimple_phi_arg_def\n+\t\t\t\t\t    (stmt_info->stmt, 0));\n+      stmt_info = vect_stmt_to_vectorize (stmt_info);\n+    }\n   gphi *reduc_def_stmt\n     = as_a <gphi *> (STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info))->stmt);\n   enum tree_code code = STMT_VINFO_REDUC_CODE (stmt_info);\n@@ -4269,20 +4285,6 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n     neutral_op\n       = neutral_op_for_slp_reduction (slp_node_instance->reduc_phis, code,\n \t\t\t\t      REDUC_GROUP_FIRST_ELEMENT (stmt_info));\n-  bool double_reduc = false;\n-  if (nested_in_vect_loop_p (LOOP_VINFO_LOOP (loop_vinfo), stmt_info))\n-    {\n-      tree def_arg\n-\t= PHI_ARG_DEF_FROM_EDGE (reduc_def_stmt,\n-\t\t\t\t loop_preheader_edge \n-\t\t\t\t   (LOOP_VINFO_LOOP (loop_vinfo)->inner));\n-      stmt_vec_info def_arg_stmt_info = loop_vinfo->lookup_def (def_arg);\n-      if (def_arg_stmt_info\n-\t  && (STMT_VINFO_DEF_TYPE (def_arg_stmt_info)\n-\t      == vect_double_reduction_def))\n-\tdouble_reduc = true;\n-    }\n-  tree induc_val = NULL_TREE;\n   stmt_vec_info prev_phi_info;\n   tree vectype;\n   machine_mode mode;\n@@ -4298,23 +4300,20 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n   gimple *epilog_stmt = NULL;\n   gimple *exit_phi;\n   tree bitsize;\n-  tree adjustment_def = NULL;\n-  tree expr, def, initial_def = NULL;\n+  tree expr, def;\n   tree orig_name, scalar_result;\n   imm_use_iterator imm_iter, phi_imm_iter;\n   use_operand_p use_p, phi_use_p;\n   gimple *use_stmt;\n   bool nested_in_vect_loop = false;\n   auto_vec<gimple *> new_phis;\n-  auto_vec<stmt_vec_info> inner_phis;\n   int j, i;\n   auto_vec<tree> scalar_results;\n-  unsigned int group_size = 1, k, ratio;\n+  unsigned int group_size = 1, k;\n   auto_vec<gimple *> phis;\n   bool slp_reduc = false;\n   bool direct_slp_reduc;\n   tree new_phi_result;\n-  stmt_vec_info inner_phi = NULL;\n   tree induction_index = NULL_TREE;\n \n   if (slp_node)\n@@ -4327,28 +4326,15 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n       nested_in_vect_loop = true;\n       gcc_assert (!slp_node);\n     }\n+  gcc_assert (!nested_in_vect_loop || double_reduc);\n \n   vectype = STMT_VINFO_VECTYPE (stmt_info);\n   gcc_assert (vectype);\n   mode = TYPE_MODE (vectype);\n \n-  /* 1. Create the reduction def-use cycle:\n-     Set the backedge argument of REDUCTION_PHIS, i.e., transform\n-\n-        loop:\n-          vec_def = phi <vec_init, null>        # REDUCTION_PHI\n-          VECT_DEF = vector_stmt                # vectorized form of STMT\n-          ...\n-\n-     into:\n-\n-        loop:\n-          vec_def = phi <vec_init, VECT_DEF>    # REDUCTION_PHI\n-          VECT_DEF = vector_stmt                # vectorized form of STMT\n-          ...\n-\n-     (in case of SLP, do it for all the phis).  */\n-\n+  tree initial_def = NULL;\n+  tree induc_val = NULL_TREE;\n+  tree adjustment_def = NULL;\n   if (slp_node)\n     ;\n   else\n@@ -4357,9 +4343,8 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n \t of the reduction variable.  */\n       initial_def = PHI_ARG_DEF_FROM_EDGE (reduc_def_stmt,\n \t\t\t\t\t   loop_preheader_edge (loop));\n-      /* Optimize: if initial_def is for REDUC_MAX smaller than the base\n-\t and we can't use zero for induc_val, use initial_def.  Similarly\n-\t for REDUC_MIN and initial_def larger than the base.  */\n+      /* Optimize: for induction condition reduction, if we can't use zero\n+         for induc_val, use initial_def.  */\n       if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n \t  == INTEGER_INDUC_COND_REDUCTION)\n \tinduc_val = STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (stmt_info);\n@@ -4371,50 +4356,26 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n \tadjustment_def = STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (stmt_info);\n     }\n \n-  /* Set phi nodes latch arguments.  */\n-  unsigned vec_num = 1;\n-  int ncopies = 0;\n+  unsigned vec_num;\n+  int ncopies;\n   if (slp_node)\n-    vec_num = SLP_TREE_VEC_STMTS (slp_node_instance->reduc_phis).length ();\n-  for (unsigned i = 0; i < vec_num; i++)\n     {\n-      if (slp_node)\n-\t{\n-\t  def = gimple_get_lhs (SLP_TREE_VEC_STMTS (slp_node)[i]->stmt);\n-\t  phi_info = SLP_TREE_VEC_STMTS (slp_node_instance->reduc_phis)[i];\n-\t}\n-      else\n+      vec_num = SLP_TREE_VEC_STMTS (slp_node_instance->reduc_phis).length ();\n+      ncopies = 1;\n+    }\n+  else\n+    {\n+      vec_num = 1;\n+      ncopies = 0;\n+      phi_info = STMT_VINFO_VEC_STMT (loop_vinfo->lookup_stmt (reduc_def_stmt));\n+      do\n \t{\n-\t  def = gimple_get_lhs (STMT_VINFO_VEC_STMT (stmt_info)->stmt);\n-\t  phi_info = STMT_VINFO_VEC_STMT (loop_vinfo->lookup_stmt (reduc_def_stmt));\n+\t  ncopies++;\n+\t  phi_info = STMT_VINFO_RELATED_STMT (phi_info);\n \t}\n-      for (ncopies = 0;; ncopies++)\n-        {\n-          /* Set the loop-latch arg for the reduction-phi.  */\n-\t  if (ncopies != 0)\n-\t    {\n-\t      if (slp_node)\n-\t\tbreak;\n-\t      phi_info = STMT_VINFO_RELATED_STMT (phi_info);\n-\t      if (!phi_info)\n-\t\tbreak;\n-\t      def = vect_get_vec_def_for_stmt_copy (loop_vinfo, def);\n-\t    }\n-\n-\t  gphi *phi = as_a <gphi *> (phi_info->stmt);\n-\t  add_phi_arg (phi, def, loop_latch_edge (loop), UNKNOWN_LOCATION);\n-\n-          if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"transform reduction: created def-use cycle: %G%G\",\n-\t\t\t     phi, SSA_NAME_DEF_STMT (def));\n-        }\n+      while (phi_info);\n     }\n \n-  /* For vectorizing nested cycles the above is all we need to do.  */\n-  if (nested_in_vect_loop && !double_reduc)\n-    return;\n-\n   /* For cond reductions we want to create a new vector (INDEX_COND_EXPR)\n      which is updated with the current index of the loop for every match of\n      the original loop's cond_expr (VEC_STMT).  This results in a vector\n@@ -4533,7 +4494,8 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n   /* 2.1 Create new loop-exit-phis to preserve loop-closed form:\n          v_out1 = phi <VECT_DEF> \n          Store them in NEW_PHIS.  */\n-\n+  if (double_reduc)\n+    loop = outer_loop;\n   exit_bb = single_exit (loop)->dest;\n   prev_phi_info = NULL;\n   new_phis.create (slp_node ? vec_num : ncopies);\n@@ -4542,7 +4504,7 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n       if (slp_node)\n \tdef = gimple_get_lhs (SLP_TREE_VEC_STMTS (slp_node)[i]->stmt);\n       else\n-\tdef = gimple_get_lhs (STMT_VINFO_VEC_STMT (stmt_info)->stmt);\n+\tdef = gimple_get_lhs (STMT_VINFO_VEC_STMT (rdef_info)->stmt);\n       for (j = 0; j < ncopies; j++)\n         {\n \t  tree new_def = copy_ssa_name (def);\n@@ -4561,37 +4523,6 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n         }\n     }\n \n-  /* The epilogue is created for the outer-loop, i.e., for the loop being\n-     vectorized.  Create exit phis for the outer loop.  */\n-  if (double_reduc)\n-    {\n-      loop = outer_loop;\n-      exit_bb = single_exit (loop)->dest;\n-      inner_phis.create (slp_node ? vec_num : ncopies);\n-      FOR_EACH_VEC_ELT (new_phis, i, phi)\n-\t{\n-\t  stmt_vec_info phi_info = loop_vinfo->lookup_stmt (phi);\n-\t  tree new_result = copy_ssa_name (PHI_RESULT (phi));\n-\t  gphi *outer_phi = create_phi_node (new_result, exit_bb);\n-\t  SET_PHI_ARG_DEF (outer_phi, single_exit (loop)->dest_idx,\n-\t\t\t   PHI_RESULT (phi));\n-\t  prev_phi_info = loop_vinfo->add_stmt (outer_phi);\n-\t  inner_phis.quick_push (phi_info);\n-\t  new_phis[i] = outer_phi;\n-\t  while (STMT_VINFO_RELATED_STMT (phi_info))\n-            {\n-\t      phi_info = STMT_VINFO_RELATED_STMT (phi_info);\n-\t      new_result = copy_ssa_name (PHI_RESULT (phi_info->stmt));\n-\t      outer_phi = create_phi_node (new_result, exit_bb);\n-\t      SET_PHI_ARG_DEF (outer_phi, single_exit (loop)->dest_idx,\n-\t\t\t       PHI_RESULT (phi_info->stmt));\n-\t      stmt_vec_info outer_phi_info = loop_vinfo->add_stmt (outer_phi);\n-\t      STMT_VINFO_RELATED_STMT (prev_phi_info) = outer_phi_info;\n-\t      prev_phi_info = outer_phi_info;\n-\t    }\n-\t}\n-    }\n-\n   exit_gsi = gsi_after_labels (exit_bb);\n \n   /* 2.2 Get the relevant tree-code to use in the epilog for schemes 2,3\n@@ -5381,23 +5312,10 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n      correspond to the first vector stmt, etc.\n      (RATIO is equal to (REDUC_GROUP_SIZE / number of new vector stmts)).  */\n   if (group_size > new_phis.length ())\n-    {\n-      ratio = group_size / new_phis.length ();\n-      gcc_assert (!(group_size % new_phis.length ()));\n-    }\n-  else\n-    ratio = 1;\n+    gcc_assert (!(group_size % new_phis.length ()));\n \n-  stmt_vec_info epilog_stmt_info = NULL;\n   for (k = 0; k < group_size; k++)\n     {\n-      if (k % ratio == 0)\n-        {\n-\t  epilog_stmt_info = loop_vinfo->lookup_stmt (new_phis[k / ratio]);\n-\t  if (double_reduc)\n-\t    inner_phi = inner_phis[k / ratio];\n-        }\n-\n       if (slp_reduc)\n         {\n \t  stmt_vec_info scalar_stmt_info = SLP_TREE_SCALAR_STMTS (slp_node)[k];\n@@ -5408,84 +5326,6 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n \t  scalar_dest = gimple_assign_lhs (scalar_stmt_info->stmt);\n         }\n \n-      if (outer_loop)\n-\t{\n-      phis.create (3);\n-      /* Find the loop-closed-use at the loop exit of the original scalar\n-         result.  (The reduction result is expected to have two immediate uses -\n-         one at the latch block, and one at the loop exit).  */\n-      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, scalar_dest)\n-        if (!flow_bb_inside_loop_p (loop, gimple_bb (USE_STMT (use_p)))\n-\t    && !is_gimple_debug (USE_STMT (use_p)))\n-          phis.safe_push (USE_STMT (use_p));\n-\n-      /* While we expect to have found an exit_phi because of loop-closed-ssa\n-         form we can end up without one if the scalar cycle is dead.  */\n-\n-      FOR_EACH_VEC_ELT (phis, i, exit_phi)\n-        {\n-\t      stmt_vec_info exit_phi_vinfo\n-\t\t= loop_vinfo->lookup_stmt (exit_phi);\n-              gphi *vect_phi;\n-\n-\t      if (double_reduc)\n-\t\tSTMT_VINFO_VEC_STMT (exit_phi_vinfo) = inner_phi;\n-\t      else\n-\t\tSTMT_VINFO_VEC_STMT (exit_phi_vinfo) = epilog_stmt_info;\n-              if (!double_reduc\n-                  || STMT_VINFO_DEF_TYPE (exit_phi_vinfo)\n-                      != vect_double_reduction_def)\n-                continue;\n-\n-              /* Handle double reduction:\n-\n-                 stmt1: s1 = phi <s0, s2>  - double reduction phi (outer loop)\n-                 stmt2:   s3 = phi <s1, s4> - (regular) reduc phi (inner loop)\n-                 stmt3:   s4 = use (s3)     - (regular) reduc stmt (inner loop)\n-                 stmt4: s2 = phi <s4>      - double reduction stmt (outer loop)\n-\n-                 At that point the regular reduction (stmt2 and stmt3) is\n-                 already vectorized, as well as the exit phi node, stmt4.\n-                 Here we vectorize the phi node of double reduction, stmt1, and\n-                 update all relevant statements.  */\n-\n-              /* Go through all the uses of s2 to find double reduction phi\n-                 node, i.e., stmt1 above.  */\n-              orig_name = PHI_RESULT (exit_phi);\n-              FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, orig_name)\n-                {\n-                  stmt_vec_info use_stmt_vinfo;\n-                  basic_block bb = gimple_bb (use_stmt);\n-\n-                  /* Check that USE_STMT is really double reduction phi\n-                     node.  */\n-                  if (gimple_code (use_stmt) != GIMPLE_PHI\n-                      || gimple_phi_num_args (use_stmt) != 2\n-                      || bb->loop_father != outer_loop)\n-                    continue;\n-\t\t  use_stmt_vinfo = loop_vinfo->lookup_stmt (use_stmt);\n-                  if (!use_stmt_vinfo\n-                      || STMT_VINFO_DEF_TYPE (use_stmt_vinfo)\n-                          != vect_double_reduction_def)\n-\t\t    continue;\n-\n-                  /* Set the outer loop vector phi args.  The PHI node\n-\t\t     itself was created in vectorizable_reduction.  */\n-\t\t  vect_phi = as_a <gphi *>\n-\t\t\t\t(STMT_VINFO_VEC_STMT (use_stmt_vinfo)->stmt);\n-\n-                  /* Update phi node argument with vs2.  */\n-\t\t  add_phi_arg (vect_phi, PHI_RESULT (inner_phi->stmt),\n-\t\t\t       loop_latch_edge (outer_loop), UNKNOWN_LOCATION);\n-                  if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t     \"created double reduction phi node: %G\",\n-\t\t\t\t     vect_phi);\n-                }\n-        }\n-      phis.release ();\n-\t}\n-\n       if (nested_in_vect_loop)\n         {\n           if (double_reduc)\n@@ -7153,10 +6993,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   if (single_defuse_cycle && !slp_node)\n     STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n \n-  /* Finalize the reduction-phi (set its arguments) and create the\n-     epilog reduction code.  */\n-  vect_create_epilog_for_reduction (stmt_info, slp_node, slp_node_instance);\n-\n   return true;\n }\n \n@@ -7172,10 +7008,8 @@ vectorizable_lc_phi (stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n       || gimple_phi_num_args (stmt_info->stmt) != 1)\n     return false;\n \n-  /* To handle the nested_cycle_def for double-reductions we have to\n-     refactor epilogue generation more.  */\n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def\n-      /* && STMT_VINFO_DEF_TYPE (stmt_info) != vect_double_reduction_def */)\n+      && STMT_VINFO_DEF_TYPE (stmt_info) != vect_double_reduction_def)\n     return false;\n \n   if (!vec_stmt) /* transformation not required.  */\n@@ -7833,8 +7667,8 @@ vectorizable_induction (stmt_vec_info stmt_info,\n bool\n vectorizable_live_operation (stmt_vec_info stmt_info,\n \t\t\t     gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n-\t\t\t     slp_tree slp_node, int slp_index,\n-\t\t\t     stmt_vec_info *vec_stmt,\n+\t\t\t     slp_tree slp_node, slp_instance slp_node_instance,\n+\t\t\t     int slp_index, stmt_vec_info *vec_stmt,\n \t\t\t     stmt_vector_for_cost *)\n {\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -7851,8 +7685,34 @@ vectorizable_live_operation (stmt_vec_info stmt_info,\n \n   gcc_assert (STMT_VINFO_LIVE_P (stmt_info));\n \n-  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n-    return false;\n+  /* The last stmt of a reduction is live and vectorized via\n+     vect_create_epilog_for_reduction.  vectorizable_reduction assessed\n+     validity so just trigger the transform here.  */\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n+      || STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n+    {\n+      if (!vec_stmt)\n+\treturn true;\n+      if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n+\t{\n+\t  if (STMT_VINFO_REDUC_TYPE (stmt_info) == FOLD_LEFT_REDUCTION)\n+\t    return true;\n+\t  if (slp_node)\n+\t    {\n+\t      /* For reduction chains the meta-info is attached to\n+\t         the group leader.  */\n+\t      if (REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n+\t\tstmt_info = REDUC_GROUP_FIRST_ELEMENT (stmt_info);\n+\t      /* For SLP reductions we vectorize the epilogue for\n+\t         all involved stmts together.  */\n+\t      else if (slp_index != 0)\n+\t\treturn true;\n+\t    }\n+\t}\n+      vect_create_epilog_for_reduction (stmt_info, slp_node,\n+\t\t\t\t\tslp_node_instance);\n+      return true;\n+    }\n \n   /* FORNOW.  CHECKME.  */\n   if (nested_in_vect_loop_p (loop, stmt_info))"}, {"sha": "7fcd2fa19a848b05ce3977bc5de017b486100bb1", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 69, "deletions": 20, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61362d9d18916bd5b694385982cf4a02b7537b0e/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61362d9d18916bd5b694385982cf4a02b7537b0e/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=61362d9d18916bd5b694385982cf4a02b7537b0e", "patch": "@@ -9809,19 +9809,17 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   tree vec_cmp_type;\n   bool masked = false;\n \n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n+    return false;\n+\n   if (for_reduction && STMT_SLP_TYPE (stmt_info))\n     return false;\n \n   vect_reduction_type reduction_type\n     = STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info);\n-  if (reduction_type == TREE_CODE_REDUCTION)\n+  if (!for_reduction)\n     {\n-      if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n-\treturn false;\n-\n-      if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def\n-\t  && !(STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle\n-\t       && for_reduction))\n+      if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n \treturn false;\n \n       /* FORNOW: not yet supported.  */\n@@ -10472,7 +10470,8 @@ vectorizable_comparison (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n static bool\n can_vectorize_live_stmts (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t\t  slp_tree slp_node, stmt_vec_info *vec_stmt,\n+\t\t\t  slp_tree slp_node, slp_instance slp_node_instance,\n+\t\t\t  stmt_vec_info *vec_stmt,\n \t\t\t  stmt_vector_for_cost *cost_vec)\n {\n   if (slp_node)\n@@ -10482,13 +10481,15 @@ can_vectorize_live_stmts (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (slp_node), i, slp_stmt_info)\n \t{\n \t  if (STMT_VINFO_LIVE_P (slp_stmt_info)\n-\t      && !vectorizable_live_operation (slp_stmt_info, gsi, slp_node, i,\n+\t      && !vectorizable_live_operation (slp_stmt_info, gsi, slp_node,\n+\t\t\t\t\t       slp_node_instance, i,\n \t\t\t\t\t       vec_stmt, cost_vec))\n \t    return false;\n \t}\n     }\n   else if (STMT_VINFO_LIVE_P (stmt_info)\n-\t   && !vectorizable_live_operation (stmt_info, gsi, slp_node, -1,\n+\t   && !vectorizable_live_operation (stmt_info, gsi, slp_node,\n+\t\t\t\t\t    slp_node_instance, -1,\n \t\t\t\t\t    vec_stmt, cost_vec))\n     return false;\n \n@@ -10704,7 +10705,9 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n       need extra handling, except for vectorizable reductions.  */\n   if (!bb_vinfo\n       && STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type\n-      && !can_vectorize_live_stmts (stmt_info, NULL, node, NULL, cost_vec))\n+      && STMT_VINFO_TYPE (stmt_info) != lc_phi_info_type\n+      && !can_vectorize_live_stmts (stmt_info, NULL, node, node_instance,\n+\t\t\t\t    NULL, cost_vec))\n     return opt_result::failure_at (stmt_info->stmt,\n \t\t\t\t   \"not vectorized:\"\n \t\t\t\t   \" live stmt not supported: %G\",\n@@ -10878,19 +10881,65 @@ vect_transform_stmt (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  }\n     }\n \n-  /* Handle stmts whose DEF is used outside the loop-nest that is\n-     being vectorized.  */\n-  if (STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type)\n+  if (vec_stmt)\n+    STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n+\n+  if (STMT_VINFO_TYPE (stmt_info) == store_vec_info_type)\n+    return is_store;\n+\n+  /* If this stmt defines a value used on a backedge, update the\n+     vectorized PHIs.  */\n+  stmt_vec_info orig_stmt_info = vect_orig_stmt (stmt_info);\n+  if (!slp_node && STMT_VINFO_REDUC_DEF (orig_stmt_info)\n+      && STMT_VINFO_REDUC_TYPE (orig_stmt_info) != FOLD_LEFT_REDUCTION\n+      && is_a <gphi *> (STMT_VINFO_REDUC_DEF (orig_stmt_info)->stmt))\n+    {\n+      gphi *phi = as_a <gphi *> (STMT_VINFO_REDUC_DEF (orig_stmt_info)->stmt);\n+      if (dominated_by_p (CDI_DOMINATORS,\n+\t\t\t  gimple_bb (orig_stmt_info->stmt), gimple_bb (phi)))\n+\t{\n+\t  edge e = loop_latch_edge (gimple_bb (phi)->loop_father);\n+\t  stmt_vec_info phi_info\n+\t      = STMT_VINFO_VEC_STMT (STMT_VINFO_REDUC_DEF (orig_stmt_info));\n+\t  stmt_vec_info vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n+\t  do\n+\t    {\n+\t      add_phi_arg (as_a <gphi *> (phi_info->stmt),\n+\t\t\t   gimple_get_lhs (vec_stmt->stmt), e,\n+\t\t\t   gimple_phi_arg_location (phi, e->dest_idx));\n+\t      phi_info = STMT_VINFO_RELATED_STMT (phi_info);\n+\t      vec_stmt = STMT_VINFO_RELATED_STMT (vec_stmt);\n+\t    }\n+\t  while (phi_info);\n+\t  gcc_assert (!vec_stmt);\n+\t}\n+    }\n+  else if (slp_node && STMT_VINFO_REDUC_DEF (orig_stmt_info)\n+\t   /* Going back and forth via STMT_VINFO_REDUC_DEF gets us to the\n+\t      stmt with the reduction meta in case of reduction groups.  */\n+\t   && (STMT_VINFO_REDUC_TYPE\n+\t         (STMT_VINFO_REDUC_DEF (STMT_VINFO_REDUC_DEF (orig_stmt_info)))\n+\t       != FOLD_LEFT_REDUCTION)\n+\t   && slp_node != slp_node_instance->reduc_phis)\n     {\n-      done = can_vectorize_live_stmts (stmt_info, gsi, slp_node, &vec_stmt,\n-\t\t\t\t       NULL);\n-      gcc_assert (done);\n+      slp_tree phi_node = slp_node_instance->reduc_phis;\n+      gphi *phi = as_a <gphi *> (SLP_TREE_SCALAR_STMTS (phi_node)[0]->stmt);\n+      edge e = loop_latch_edge (gimple_bb (phi)->loop_father);\n+      gcc_assert (SLP_TREE_VEC_STMTS (phi_node).length ()\n+\t\t  == SLP_TREE_VEC_STMTS (slp_node).length ());\n+      for (unsigned i = 0; i < SLP_TREE_VEC_STMTS (phi_node).length (); ++i)\n+\tadd_phi_arg (as_a <gphi *> (SLP_TREE_VEC_STMTS (phi_node)[i]->stmt),\n+\t\t     gimple_get_lhs (SLP_TREE_VEC_STMTS (slp_node)[i]->stmt),\n+\t\t     e, gimple_phi_arg_location (phi, e->dest_idx));\n     }\n \n-  if (vec_stmt)\n-    STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n+  /* Handle stmts whose DEF is used outside the loop-nest that is\n+     being vectorized.  */\n+  done = can_vectorize_live_stmts (stmt_info, gsi, slp_node,\n+\t\t\t\t   slp_node_instance, &vec_stmt, NULL);\n+  gcc_assert (done);\n \n-  return is_store;\n+  return false;\n }\n \n "}, {"sha": "462a968f2ba963feeb67abdfae4493dd88326022", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61362d9d18916bd5b694385982cf4a02b7537b0e/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61362d9d18916bd5b694385982cf4a02b7537b0e/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=61362d9d18916bd5b694385982cf4a02b7537b0e", "patch": "@@ -1649,7 +1649,8 @@ extern class loop *vect_transform_loop (loop_vec_info);\n extern opt_loop_vec_info vect_analyze_loop_form (class loop *,\n \t\t\t\t\t\t vec_info_shared *);\n extern bool vectorizable_live_operation (stmt_vec_info, gimple_stmt_iterator *,\n-\t\t\t\t\t slp_tree, int, stmt_vec_info *,\n+\t\t\t\t\t slp_tree, slp_instance, int,\n+\t\t\t\t\t stmt_vec_info *,\n \t\t\t\t\t stmt_vector_for_cost *);\n extern bool vectorizable_reduction (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t    stmt_vec_info *, slp_tree, slp_instance,"}]}