{"sha": "cfb582f62791dfadc243d97d37f0b83ef77cf480", "node_id": "C_kwDOANBUbNoAKGNmYjU4MmY2Mjc5MWRmYWRjMjQzZDk3ZDM3ZjBiODNlZjc3Y2Y0ODA", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-05-04T22:31:48Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-01T19:34:48Z"}, "message": "libstdc++: Optimize std::visit for the common case [PR 78113]\n\nGCC does not do a good job of optimizing the table of function pointers\nused for variant visitation. This avoids using the table for the common\ncase of visiting a single variant with a small number of alternative\ntypes. Instead we use:\n\n  switch(v.index())\n  {\n  case 0: return visitor(get<0>(v));\n  case 1: return visitor(get<1>(v));\n  ...\n  }\n\nIt's not quite that simple, because get<1>(v) is ill-formed if the\nvariant only has one alternative, and similarly for each get<N>.  We\nneed to ensure each case only applies the visitor if the index is in\nrange for the actual type we're dealing with, and tell the compiler that\nthe case is unreachable otherwise. We also need to invoke the visitor\nvia the __gen_vtable_impl::__visit_invoke function, to handle the raw\nvisitation cases used to implement std::variant assignments and\ncomparisons.\n\nBecause that gets quite verbose and repetitive, a macro is used to stamp\nout the cases.\n\nWe also need to handle the valueless_by_exception case, but only for raw\nvisitation, because std::visit already checks for it before calling\n__do_visit.\n\nSigned-off-by: Jonathan Wakely <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/78113\n\t* include/std/variant (__do_visit): Use a switch when we have a\n\tsingle variant with a small number of alternatives.", "tree": {"sha": "8c6798f1e8fce4f6a6cde8ce0f14da32fdc5d23f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c6798f1e8fce4f6a6cde8ce0f14da32fdc5d23f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfb582f62791dfadc243d97d37f0b83ef77cf480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfb582f62791dfadc243d97d37f0b83ef77cf480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfb582f62791dfadc243d97d37f0b83ef77cf480", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfb582f62791dfadc243d97d37f0b83ef77cf480/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c46ecb0112e91c80ee111439e79a58a953e4479d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c46ecb0112e91c80ee111439e79a58a953e4479d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c46ecb0112e91c80ee111439e79a58a953e4479d"}], "stats": {"total": 93, "additions": 88, "deletions": 5}, "files": [{"sha": "19b2158690a9b4d03081f697e6a945d7c2a4e56f", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 88, "deletions": 5, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfb582f62791dfadc243d97d37f0b83ef77cf480/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfb582f62791dfadc243d97d37f0b83ef77cf480/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=cfb582f62791dfadc243d97d37f0b83ef77cf480", "patch": "@@ -485,6 +485,12 @@ namespace __variant\n       {\n \tif constexpr (__variant::__never_valueless<_Types...>())\n \t  return true;\n+\t// It would be nice if we could just return true for -fno-exceptions.\n+\t// It's possible (but inadvisable) that a std::variant could become\n+\t// valueless in a translation unit compiled with -fexceptions and then\n+\t// be passed to functions compiled with -fno-exceptions. We would need\n+\t// some #ifdef _GLIBCXX_NO_EXCEPTIONS_GLOBALLY property to elide all\n+\t// checks for valueless_by_exception().\n \treturn this->_M_index != static_cast<__index_type>(variant_npos);\n       }\n \n@@ -1754,12 +1760,89 @@ namespace __variant\n     constexpr decltype(auto)\n     __do_visit(_Visitor&& __visitor, _Variants&&... __variants)\n     {\n-      constexpr auto& __vtable = __detail::__variant::__gen_vtable<\n-\t_Result_type, _Visitor&&, _Variants&&...>::_S_vtable;\n+      // Get the silly case of visiting no variants out of the way first.\n+      if constexpr (sizeof...(_Variants) == 0)\n+\treturn std::forward<_Visitor>(__visitor)();\n+      else\n+\t{\n+\t  constexpr size_t __max = 11; // \"These go to eleven.\"\n+\n+\t  // The type of the first variant in the pack.\n+\t  using _V0\n+\t    = typename __detail::__variant::_Nth_type<0, _Variants...>::type;\n+\t  // The number of alternatives in that first variant.\n+\t  constexpr auto __n = variant_size_v<remove_reference_t<_V0>>;\n+\n+\t  if constexpr (sizeof...(_Variants) > 1 || __n > __max)\n+\t    {\n+\t      // Use a jump table for the general case.\n+\t      constexpr auto& __vtable = __detail::__variant::__gen_vtable<\n+\t\t_Result_type, _Visitor&&, _Variants&&...>::_S_vtable;\n+\n+\t      auto __func_ptr = __vtable._M_access(__variants.index()...);\n+\t      return (*__func_ptr)(std::forward<_Visitor>(__visitor),\n+\t\t\t\t   std::forward<_Variants>(__variants)...);\n+\t    }\n+\t  else // We have a single variant with a small number of alternatives.\n+\t    {\n+\t      // A name for the first variant in the pack.\n+\t      _V0& __v0\n+\t\t= [](_V0& __v, ...) -> _V0& { return __v; }(__variants...);\n+\n+\t      using __detail::__variant::_Multi_array;\n+\t      using __detail::__variant::__gen_vtable_impl;\n+\t      using _Ma = _Multi_array<_Result_type (*)(_Visitor&&, _V0&&)>;\n \n-      auto __func_ptr = __vtable._M_access(__variants.index()...);\n-      return (*__func_ptr)(std::forward<_Visitor>(__visitor),\n-\t\t\t   std::forward<_Variants>(__variants)...);\n+#ifdef _GLIBCXX_DEBUG\n+# define _GLIBCXX_VISIT_UNREACHABLE __builtin_trap\n+#else\n+# define _GLIBCXX_VISIT_UNREACHABLE __builtin_unreachable\n+#endif\n+\n+#define _GLIBCXX_VISIT_CASE(N)\t\t\t\t\t\t\\\n+  case N:\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if constexpr (N < __n)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\treturn __gen_vtable_impl<_Ma, index_sequence<N>>::\t\t\\\n+\t  __visit_invoke(std::forward<_Visitor>(__visitor),\t\t\\\n+\t\t\t std::forward<_V0>(__v0));\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else _GLIBCXX_VISIT_UNREACHABLE();\t\t\t\t\t\\\n+  }\n+\n+\t      switch (__v0.index())\n+\t\t{\n+\t\t  _GLIBCXX_VISIT_CASE(0)\n+\t\t  _GLIBCXX_VISIT_CASE(1)\n+\t\t  _GLIBCXX_VISIT_CASE(2)\n+\t\t  _GLIBCXX_VISIT_CASE(3)\n+\t\t  _GLIBCXX_VISIT_CASE(4)\n+\t\t  _GLIBCXX_VISIT_CASE(5)\n+\t\t  _GLIBCXX_VISIT_CASE(6)\n+\t\t  _GLIBCXX_VISIT_CASE(7)\n+\t\t  _GLIBCXX_VISIT_CASE(8)\n+\t\t  _GLIBCXX_VISIT_CASE(9)\n+\t\t  _GLIBCXX_VISIT_CASE(10)\n+\t\tcase variant_npos:\n+\t\t  using __detail::__variant::__variant_idx_cookie;\n+\t\t  using __detail::__variant::__variant_cookie;\n+\t\t  if constexpr (is_same_v<_Result_type, __variant_idx_cookie>\n+\t\t\t\t|| is_same_v<_Result_type, __variant_cookie>)\n+\t\t    {\n+\t\t      return __gen_vtable_impl<_Ma, index_sequence<-1>>::\n+\t\t\t__visit_invoke(std::forward<_Visitor>(__visitor),\n+\t\t\t\t       std::forward<_V0>(__v0));\n+\t\t    }\n+\t\t  else\n+\t\t    _GLIBCXX_VISIT_UNREACHABLE();\n+\t\tdefault:\n+\t\t  _GLIBCXX_VISIT_UNREACHABLE();\n+\t\t}\n+#undef _GLIBCXX_VISIT_CASE\n+#undef _GLIBCXX_VISIT_UNREACHABLE\n+\t    }\n+\t}\n     }\n   /// @endcond\n "}]}