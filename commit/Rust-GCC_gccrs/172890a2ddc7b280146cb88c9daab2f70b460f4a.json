{"sha": "172890a2ddc7b280146cb88c9daab2f70b460f4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTcyODkwYTJkZGM3YjI4MDE0NmNiODhjOWRhYWIyZjcwYjQ2MGY0YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-02-16T19:29:49Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-02-16T19:29:49Z"}, "message": "gcse.c (hash_scan_set): If cprop, see if REG_EQUAL or REG_EQUIV.\n\n\t* gcse.c (hash_scan_set): If cprop, see if REG_EQUAL or REG_EQUIV.\n\tDon't CSE a nop.\n\t(hash_scan_insn): Clean up calls to hash_scan_set.\n\t(compute_kill_rd): REGNO now unsigned.\n\t(try_replace_reg): Rework to use simplify_replace_rtx.\n\t(cprop_jump, cprop_cc0_jump): Likewise.\n\t(cprop_insn): Call find_reg_equal_equiv_note.\n\tReflect changes to cprop_jump and cprop_cc0_jump.\n\nFrom-SVN: r39774", "tree": {"sha": "9e827a88ee3e8c8964cf2f67d525acf57abbd4f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e827a88ee3e8c8964cf2f67d525acf57abbd4f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/172890a2ddc7b280146cb88c9daab2f70b460f4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/172890a2ddc7b280146cb88c9daab2f70b460f4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/172890a2ddc7b280146cb88c9daab2f70b460f4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/172890a2ddc7b280146cb88c9daab2f70b460f4a/comments", "author": null, "committer": null, "parents": [{"sha": "b71e8e8477eb854aed39b89a3bc5f9107a4b28ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b71e8e8477eb854aed39b89a3bc5f9107a4b28ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b71e8e8477eb854aed39b89a3bc5f9107a4b28ee"}], "stats": {"total": 287, "additions": 131, "deletions": 156}, "files": [{"sha": "1f9ca43e15713c0f0a71c4550885c83c79240dee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/172890a2ddc7b280146cb88c9daab2f70b460f4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/172890a2ddc7b280146cb88c9daab2f70b460f4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=172890a2ddc7b280146cb88c9daab2f70b460f4a", "patch": "@@ -8,6 +8,15 @@\n \n Fri Feb 16 12:41:30 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* gcse.c (hash_scan_set): If cprop, see if REG_EQUAL or REG_EQUIV.\n+\tDon't CSE a nop.\n+\t(hash_scan_insn): Clean up calls to hash_scan_set.\n+\t(compute_kill_rd): REGNO now unsigned.\n+\t(try_replace_reg): Rework to use simplify_replace_rtx.\n+\t(cprop_jump, cprop_cc0_jump): Likewise.\n+\t(cprop_insn): Call find_reg_equal_equiv_note.\n+\tReflect changes to cprop_jump and cprop_cc0_jump.\n+\n \t* recog.c (validate_replace_rtx): Replace in operands of\n \tZERO_EXTRACT in SET_DEST.\n "}, {"sha": "5bb86809bad3c8f46b5efc6bb8dacc1e13216093", "filename": "gcc/gcse.c", "status": "modified", "additions": 122, "deletions": 156, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/172890a2ddc7b280146cb88c9daab2f70b460f4a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/172890a2ddc7b280146cb88c9daab2f70b460f4a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=172890a2ddc7b280146cb88c9daab2f70b460f4a", "patch": "@@ -583,7 +583,7 @@ static void compute_cprop_data\tPARAMS ((void));\n static void find_used_regs\tPARAMS ((rtx));\n static int try_replace_reg\tPARAMS ((rtx, rtx, rtx));\n static struct expr *find_avail_set PARAMS ((int, rtx));\n-static int cprop_jump\t\tPARAMS ((rtx, rtx, struct reg_use *, rtx));\n+static int cprop_jump\t\tPARAMS ((rtx, rtx, rtx));\n #ifdef HAVE_cc0\n static int cprop_cc0_jump\tPARAMS ((rtx, struct reg_use *, rtx));\n #endif\n@@ -1114,7 +1114,7 @@ record_one_set (regno, insn)\n      int regno;\n      rtx insn;\n {\n-  /* allocate a new reg_set element and link it onto the list */\n+  /* Allocate a new reg_set element and link it onto the list.  */\n   struct reg_set *new_reg_info;\n \n   /* If the table isn't big enough, enlarge it.  */\n@@ -1334,7 +1334,9 @@ hash_expr (x, mode, do_not_record_p, hash_table_size)\n   hash = hash_expr_1 (x, mode, do_not_record_p);\n   return hash % hash_table_size;\n }\n+\n /* Hash a string.  Just add its bytes up.  */\n+\n static inline unsigned\n hash_string_1 (ps)\n      const char *ps;\n@@ -1857,7 +1859,6 @@ insert_set_in_table (x, insn)\n       /* Set the fields of the expr element.\n \t We must copy X because it can be modified when copy propagation is\n \t performed on its operands.  */\n-      /* ??? Should this go in a different obstack?  */\n       cur_expr->expr = copy_rtx (x);\n       cur_expr->bitmap_index = n_sets++;\n       cur_expr->next_same_hash = NULL;\n@@ -1910,22 +1911,31 @@ hash_scan_set (pat, insn, set_p)\n {\n   rtx src = SET_SRC (pat);\n   rtx dest = SET_DEST (pat);\n+  rtx note;\n \n   if (GET_CODE (src) == CALL)\n     hash_scan_call (src, insn);\n \n-  if (GET_CODE (dest) == REG)\n+  else if (GET_CODE (dest) == REG)\n     {\n-      int regno = REGNO (dest);\n+      unsigned int regno = REGNO (dest);\n       rtx tmp;\n \n+      /* If this is a single set and we are doing constant propagation,\n+\t see if a REG_NOTE shows this equivalent to a constant.  */\n+      if (set_p && (note = find_reg_equal_equiv_note (insn)) != 0\n+\t  && CONSTANT_P (XEXP (note, 0)))\n+\tsrc = XEXP (note, 0), pat = gen_rtx_SET (VOIDmode, dest, src);\n+\n       /* Only record sets of pseudo-regs in the hash table.  */\n       if (! set_p\n \t  && regno >= FIRST_PSEUDO_REGISTER\n \t  /* Don't GCSE something if we can't do a reg/reg copy.  */\n \t  && can_copy_p [GET_MODE (dest)]\n \t  /* Is SET_SRC something we want to gcse?  */\n-\t  && want_to_gcse_p (src))\n+\t  && want_to_gcse_p (src)\n+\t  /* Don't CSE a nop.  */\n+\t  && src != dest)\n \t{\n \t  /* An expression is not anticipatable if its operands are\n \t     modified before this insn.  */\n@@ -1942,7 +1952,8 @@ hash_scan_set (pat, insn, set_p)\n \t       && regno >= FIRST_PSEUDO_REGISTER\n \t       && ((GET_CODE (src) == REG\n \t\t    && REGNO (src) >= FIRST_PSEUDO_REGISTER\n-\t\t    && can_copy_p [GET_MODE (dest)])\n+\t\t    && can_copy_p [GET_MODE (dest)]\n+\t\t    && REGNO (src) != regno)\n \t\t   || GET_CODE (src) == CONST_INT\n \t\t   || GET_CODE (src) == SYMBOL_REF\n \t\t   || GET_CODE (src) == CONST_DOUBLE)\n@@ -1992,25 +2003,21 @@ hash_scan_insn (insn, set_p, in_libcall_block)\n   rtx pat = PATTERN (insn);\n   int i;\n \n+  if (in_libcall_block)\n+    return;\n+\n   /* Pick out the sets of INSN and for other forms of instructions record\n      what's been modified.  */\n \n-  if (GET_CODE (pat) == SET && ! in_libcall_block)\n-    {\n-      /* Ignore obvious no-ops.  */\n-      if (SET_SRC (pat) != SET_DEST (pat))\n-\thash_scan_set (pat, insn, set_p);\n-    }\n+  if (GET_CODE (pat) == SET)\n+    hash_scan_set (pat, insn, set_p);\n   else if (GET_CODE (pat) == PARALLEL)\n     for (i = 0; i < XVECLEN (pat, 0); i++)\n       {\n \trtx x = XVECEXP (pat, 0, i);\n \n \tif (GET_CODE (x) == SET)\n-\t  {\n-\t    if (GET_CODE (SET_SRC (x)) == CALL)\n-\t      hash_scan_call (SET_SRC (x), insn);\n-\t  }\n+\t  hash_scan_set (x, insn, set_p);\n \telse if (GET_CODE (x) == CLOBBER)\n \t  hash_scan_clobber (x, insn);\n \telse if (GET_CODE (x) == CALL)\n@@ -2611,7 +2618,8 @@ static void\n compute_kill_rd ()\n {\n   int bb, cuid;\n-  int regno, i;\n+  unsigned int regno;\n+  int i;\n \n   /* For each block\n        For each set bit in `gen' of the block (i.e each insn which\n@@ -3603,63 +3611,53 @@ static int\n try_replace_reg (from, to, insn)\n      rtx from, to, insn;\n {\n-  rtx note;\n+  rtx note = find_reg_equal_equiv_note (insn);\n   rtx src;\n-  int success;\n-  rtx set;\n-\n-  note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-\n-  if (!note)\n-    note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n-\n-  /* If this fails we could try to simplify the result of the\n-     replacement and attempt to recognize the simplified insn.\n-\n-     But we need a general simplify_rtx that doesn't have pass\n-     specific state variables.  I'm not aware of one at the moment.  */\n-\n-  success = validate_replace_src (from, to, insn);\n-  set = single_set (insn);\n+  int success = 0;\n+  rtx set = single_set (insn);\n \n-  /* We've failed to do replacement. Try to add REG_EQUAL note to not loose\n-     information.  */\n-  if (!success && !note)\n+  /* If this is a single set, try to simplify the source of the set given\n+     our substitution.  We could perhaps try this for multiple SETs, but\n+     it probably won't buy us anything.  */\n+  if (set != 0)\n     {\n-      if (!set)\n-\treturn 0;\n-\n-      note = REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL,\n-\t\t\t\t\t\t   copy_rtx (SET_SRC (set)),\n-\t\t\t\t\t\t   REG_NOTES (insn));\n+      src = simplify_replace_rtx (SET_SRC (set), from, to);\n+\n+      /* Try this two ways: first just replace SET_SRC.  If that doesn't\n+\t work and this is a PARALLEL, try to replace the whole pattern\n+\t with a new SET.  */\n+      if (validate_change (insn, &SET_SRC (set), src, 0))\n+\tsuccess = 1;\n+      else if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t       && validate_change (insn, &PATTERN (insn),\n+\t\t\t\t   gen_rtx_SET (VOIDmode, SET_DEST (set),\n+\t\t\t\t\t\tsrc),\n+\t\t\t\t   0))\n+\tsuccess = 1;\n     }\n \n-  /* Always do the replacement in REQ_EQUAL and REG_EQUIV notes.  Also\n-     try to simplify them.  */\n-  if (note)\n-    {\n-      rtx simplified;\n+  /* Otherwise, try to do a global replacement within the insn.  */\n+  if (!success)\n+    success = validate_replace_src (from, to, insn);\n \n-      if (!validate_replace_rtx_subexp (from, to, insn, &XEXP (note, 0)))\n-\tabort();\n+  /* We've failed to do replacement, have a single SET, and don't already\n+     have a note, two to add a REG_EQUAL note to not lose information.  */\n+  if (!success && note == 0 && set != 0)\n+    note= REG_NOTES (insn)\n+      = gen_rtx_EXPR_LIST (REG_EQUAL, src, REG_NOTES (insn));\n \n-      src = XEXP (note, 0);\n+  /* If there is already a NOTE, update the expression in it with our\n+     replacement.  */\n+  else if (note != 0)\n+    XEXP (note, 0) = simplify_replace_rtx (XEXP (note, 0), from, to);\n \n-      /* Try to simplify resulting note. */\n-      simplified = simplify_rtx (src);\n-      if (simplified)\n-\t{\n-\t  src = simplified;\n-\t  XEXP (note, 0) = src;\n-\t}\n+  /* REG_EQUAL may get simplified into register.\n+     We don't allow that. Remove that note. This code ought\n+     not to hapen, because previous code ought to syntetize\n+     reg-reg move, but be on the safe side.  */\n+  if (note && REG_P (XEXP (note, 0)))\n+    remove_note (insn, note);\n \n-      /* REG_EQUAL may get simplified into register.\n-         We don't allow that. Remove that note. This code ought\n-         not to hapen, because previous code ought to syntetize\n-         reg-reg move, but be on the safe side.  */\n-      else if (REG_P (src))\n-\tremove_note (insn, note);\n-    }\n   return success;\n }\n \n@@ -3734,82 +3732,57 @@ find_avail_set (regno, insn)\n }\n \n /* Subroutine of cprop_insn that tries to propagate constants into\n-   JUMP_INSNS.  INSN must be a conditional jump; COPY is a copy of it\n-   that we can use for substitutions.\n-   REG_USED is the use we will try to replace, SRC is the constant we\n-   will try to substitute for it.\n-   Returns nonzero if a change was made.  */\n+   JUMP_INSNS.  INSN must be a conditional jump.  FROM is what we will try to\n+   replace, SRC is the constant we will try to substitute for it.  Returns\n+   nonzero if a change was made.  We know INSN has just a SET.  */\n \n static int\n-cprop_jump (insn, copy, reg_used, src)\n-     rtx insn, copy;\n-     struct reg_use *reg_used;\n+cprop_jump (insn, from, src)\n+     rtx insn;\n+     rtx from;\n      rtx src;\n {\n-  rtx set = PATTERN (copy);\n-  rtx temp;\n-\n-  /* Replace the register with the appropriate constant.  */\n-  replace_rtx (SET_SRC (set), reg_used->reg_rtx, src);\n-\n-  temp = simplify_ternary_operation (GET_CODE (SET_SRC (set)),\n-\t\t\t\t     GET_MODE (SET_SRC (set)),\n-\t\t\t\t     GET_MODE (XEXP (SET_SRC (set), 0)),\n-\t\t\t\t     XEXP (SET_SRC (set), 0),\n-\t\t\t\t     XEXP (SET_SRC (set), 1),\n-\t\t\t\t     XEXP (SET_SRC (set), 2));\n+  rtx set = PATTERN (insn);\n+  rtx new = simplify_replace_rtx (SET_SRC (set), from, src);\n \n   /* If no simplification can be made, then try the next\n      register.  */\n-  if (temp == 0)\n+  if (rtx_equal_p (new, SET_SRC (set)))\n     return 0;\n  \n-  SET_SRC (set) = temp;\n-\n-  /* That may have changed the structure of TEMP, so\n-     force it to be rerecognized if it has not turned\n-     into a nop or unconditional jump.  */\n-\t\t\n-  INSN_CODE (copy) = -1;\n-  if ((SET_DEST (set) == pc_rtx\n-       && (SET_SRC (set) == pc_rtx\n-\t   || GET_CODE (SET_SRC (set)) == LABEL_REF))\n-      || recog (PATTERN (copy), copy, NULL) >= 0)\n+  /* If this is now a no-op leave it that way, but update LABEL_NUSED if\n+     necessary.  */\n+  if (new == pc_rtx)\n     {\n-      /* This has either become an unconditional jump\n-\t or a nop-jump.  We'd like to delete nop jumps\n-\t here, but doing so confuses gcse.  So we just\n-\t make the replacement and let later passes\n-\t sort things out.  */\n-      PATTERN (insn) = set;\n-      INSN_CODE (insn) = -1;\n-\n-      /* One less use of the label this insn used to jump to\n-\t if we turned this into a NOP jump.  */\n-      if (SET_SRC (set) == pc_rtx && JUMP_LABEL (insn) != 0)\n+      SET_SRC (set) = new;\n+\n+      if (JUMP_LABEL (insn) != 0)\n \t--LABEL_NUSES (JUMP_LABEL (insn));\n+    }\n \n-      /* If this has turned into an unconditional jump,\n-\t then put a barrier after it so that the unreachable\n-\t code will be deleted.  */\n-      if (GET_CODE (SET_SRC (set)) == LABEL_REF)\n-\temit_barrier_after (insn);\n+  /* Otherwise, this must be a valid instruction.  */\n+  else if (! validate_change (insn, &SET_SRC (set), new, 0))\n+    return 0;\n \n-      run_jump_opt_after_gcse = 1;\n+  /* If this has turned into an unconditional jump,\n+     then put a barrier after it so that the unreachable\n+     code will be deleted.  */\n+  if (GET_CODE (SET_SRC (set)) == LABEL_REF)\n+    emit_barrier_after (insn);\n \n-      const_prop_count++;\n-      if (gcse_file != NULL)\n-\t{\n-\t  fprintf (gcse_file,\n-\t\t   \"CONST-PROP: Replacing reg %d in insn %d with constant \",\n-\t\t   REGNO (reg_used->reg_rtx), INSN_UID (insn));\n-\t  print_rtl (gcse_file, src);\n-\t  fprintf (gcse_file, \"\\n\");\n-\t}\n+  run_jump_opt_after_gcse = 1;\n \n-      return 1;\n+  const_prop_count++;\n+  if (gcse_file != NULL)\n+    {\n+      fprintf (gcse_file,\n+\t       \"CONST-PROP: Replacing reg %d in insn %d with constant \",\n+\t       REGNO (from), INSN_UID (insn));\n+      print_rtl (gcse_file, src);\n+      fprintf (gcse_file, \"\\n\");\n     }\n-  return 0;\n+\n+  return 1;\n }\n \n #ifdef HAVE_cc0\n@@ -3826,20 +3799,20 @@ cprop_cc0_jump (insn, reg_used, src)\n      struct reg_use *reg_used;\n      rtx src;\n {\n+  /* First substitute in the SET_SRC of INSN, then substitute that for\n+     CC0 in JUMP.  */\n   rtx jump = NEXT_INSN (insn);\n-  rtx copy = copy_rtx (jump);\n-  rtx set = PATTERN (copy);\n+  rtx new_src = simplify_replace_rtx (SET_SRC (PATTERN (insn)),\n+\t\t\t\t      reg_used->reg_rtx, src);\n \n-  /* We need to copy the source of the cc0 setter, as cprop_jump is going to\n-     substitute into it.  */\n-  replace_rtx (SET_SRC (set), cc0_rtx, copy_rtx (SET_SRC (PATTERN (insn))));\n-  if (! cprop_jump (jump, copy, reg_used, src))\n+  if (! cprop_jump (jump, cc0_rtx, new_src))\n     return 0;\n \n   /* If we succeeded, delete the cc0 setter.  */\n   PUT_CODE (insn, NOTE);\n   NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n   NOTE_SOURCE_FILE (insn) = 0;\n+\n   return 1;\n  }\n #endif\n@@ -3858,17 +3831,13 @@ cprop_insn (insn, alter_jumps)\n \n   /* Only propagate into SETs.  Note that a conditional jump is a\n      SET with pc_rtx as the destination.  */\n-  if ((GET_CODE (insn) != INSN\n-       && GET_CODE (insn) != JUMP_INSN)\n-      || GET_CODE (PATTERN (insn)) != SET)\n+  if (GET_CODE (insn) != INSN && GET_CODE (insn) != JUMP_INSN)\n     return 0;\n \n   reg_use_count = 0;\n   find_used_regs (PATTERN (insn));\n   \n-  note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n-  if (!note)\n-    note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n+  note = find_reg_equal_equiv_note (insn);\n \n   /* We may win even when propagating constants into notes. */\n   if (note)\n@@ -3938,7 +3907,8 @@ cprop_insn (insn, alter_jumps)\n \t\t   && GET_CODE (insn) == JUMP_INSN\n \t\t   && condjump_p (insn)\n \t\t   && ! simplejump_p (insn))\n-\t    changed |= cprop_jump (insn, copy_rtx (insn), reg_used, src);\n+\t    changed |= cprop_jump (insn, reg_used->reg_rtx, src);\n+\n #ifdef HAVE_cc0\n \t  /* Similar code for machines that use a pair of CC0 setter and\n \t     conditional jump insn.  */\n@@ -3947,13 +3917,11 @@ cprop_insn (insn, alter_jumps)\n \t\t   && SET_DEST (PATTERN (insn)) == cc0_rtx\n \t\t   && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n \t\t   && condjump_p (NEXT_INSN (insn))\n-\t\t   && ! simplejump_p (NEXT_INSN (insn)))\n-            {\n-\t      if (cprop_cc0_jump (insn, reg_used, src))\n-\t\t{\n-\t\t  changed = 1;\n-\t\t  break;\n-\t\t}\n+\t\t   && ! simplejump_p (NEXT_INSN (insn))\n+\t\t   && cprop_cc0_jump (insn, reg_used, src))\n+\t    {\n+\t      changed = 1;\n+\t      break;\n \t    }\n #endif\n \t}\n@@ -4006,17 +3974,15 @@ cprop (alter_jumps)\n       for (insn = BLOCK_HEAD (bb);\n \t   insn != NULL && insn != NEXT_INSN (BLOCK_END (bb));\n \t   insn = NEXT_INSN (insn))\n-\t{\n-\t  if (INSN_P (insn))\n-\t    {\n-\t      changed |= cprop_insn (insn, alter_jumps);\n+\tif (INSN_P (insn))\n+\t  {\n+\t    changed |= cprop_insn (insn, alter_jumps);\n \n-\t      /* Keep track of everything modified by this insn.  */\n-\t      /* ??? Need to be careful w.r.t. mods done to INSN.  Don't\n-\t         call mark_oprs_set if we turned the insn into a NOTE.  */\n-\t      if (GET_CODE (insn) != NOTE)\n-\t\tmark_oprs_set (insn);\n-\t    }\n+\t    /* Keep track of everything modified by this insn.  */\n+\t    /* ??? Need to be careful w.r.t. mods done to INSN.  Don't\n+\t       call mark_oprs_set if we turned the insn into a NOTE.  */\n+\t    if (GET_CODE (insn) != NOTE)\n+\t      mark_oprs_set (insn);\n \t}\n     }\n "}]}