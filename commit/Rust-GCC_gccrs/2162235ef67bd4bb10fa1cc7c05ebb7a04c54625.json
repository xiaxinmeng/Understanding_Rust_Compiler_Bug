{"sha": "2162235ef67bd4bb10fa1cc7c05ebb7a04c54625", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE2MjIzNWVmNjdiZDRiYjEwZmExY2M3YzA1ZWJiN2EwNGM1NDYyNQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-05-12T17:29:32Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-05-12T17:29:32Z"}, "message": "Move global state in timevar.c to a new \"timer\" class\n\ngcc/ChangeLog:\n\t* timevar.c (timevar_enable): Delete in favor of...\n\t(g_timer): New global.\n\t(struct timevar_def): Move to timevar.h inside class timer.\n\t(struct timevar_stack_def): Likewise.\n\t(timevars): Delete global in favor of field \"m_timevars\" within\n\tclass timer in timevar.h\n\t(stack): Likewise, in favor of field \"m_stack\".\n\t(unused_stack_instances): Likewise, in favor of field\n\t\"m_unused_stack_instances\".\n\t(start_time): Likewise, in favor of field \"m_start_time\".\n\t(get_time): Eliminate check for timevar_enable.\n\t(timer::timer): New function, built from part of timevar_init.\n\t(timevar_init): Rewrite idempotency test from using\n\t\"timevar_enable\" bool to using dynamic allocation of \"g_timer\".\n\tMove rest of implementation into timer's constructor.\n\t(timevar_push_1): Rename to...\n\t(timer::push): ...this, adding \"m_\" prefixes to variables that\n\tare now fields of timer.\n\t(timevar_pop_1): Likewise, rename to...\n\t(timer::pop): ...this, and add \"m_\" prefixes.\n\t(timevar_start): Replace test for \"timevar_enable\" with one for\n\t\"g_timer\", and move bulk of implementation to...\n\t(timer::start): ...here, adding \"m_\" prefixes.\n\t(timevar_stop): Likewise, from here...\n\t(timer::stop): ...to here.\n\t(timevar_cond_start): Likewise, from here...\n\t(timer::cond_start): ...to here.\n\t(timevar_cond_stop): Likewise, from here...\n\t(timer::cond_stop): ...to here.\n\t(validate_phases): Rename to...\n\t(timer::validate_phases): ...this, and add \"m_\" prefixes.  Make\n\tlocals \"total\" and \"tv\" const.\n\t(timevar_print): Rename to...\n\t(timer::print): ...this, and add \"m_\" prefixes.  Make locals\n\t\"total\" and \"tv\" const.  Eliminate test for timevar_enable.\n\t* timevar.h (timevar_enable): Eliminate.\n\t(g_timer): New declaration.\n\t(timevar_push_1): Eliminate.\n\t(timevar_pop_1): Eliminate.\n\t(timevar_print): Eliminate.\n\t(class timer): New class.\n\t(timevar_push): Rewrite to use g_timer.\n\t(timevar_pop): Likewise.\n\t* toplev.c (toplev::~toplev): Likewise.\n\nFrom-SVN: r223092", "tree": {"sha": "fa9c6420956ceaeda45b771bd1f988fdc65ddc59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa9c6420956ceaeda45b771bd1f988fdc65ddc59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2637afb722eeaf503bf60b57e4817a0682dba045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2637afb722eeaf503bf60b57e4817a0682dba045", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2637afb722eeaf503bf60b57e4817a0682dba045"}], "stats": {"total": 364, "additions": 241, "deletions": 123}, "files": [{"sha": "2e423a45151c1b31bec5a6cf879e91d09065b821", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2162235ef67bd4bb10fa1cc7c05ebb7a04c54625", "patch": "@@ -1,3 +1,50 @@\n+2015-05-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* timevar.c (timevar_enable): Delete in favor of...\n+\t(g_timer): New global.\n+\t(struct timevar_def): Move to timevar.h inside class timer.\n+\t(struct timevar_stack_def): Likewise.\n+\t(timevars): Delete global in favor of field \"m_timevars\" within\n+\tclass timer in timevar.h\n+\t(stack): Likewise, in favor of field \"m_stack\".\n+\t(unused_stack_instances): Likewise, in favor of field\n+\t\"m_unused_stack_instances\".\n+\t(start_time): Likewise, in favor of field \"m_start_time\".\n+\t(get_time): Eliminate check for timevar_enable.\n+\t(timer::timer): New function, built from part of timevar_init.\n+\t(timevar_init): Rewrite idempotency test from using\n+\t\"timevar_enable\" bool to using dynamic allocation of \"g_timer\".\n+\tMove rest of implementation into timer's constructor.\n+\t(timevar_push_1): Rename to...\n+\t(timer::push): ...this, adding \"m_\" prefixes to variables that\n+\tare now fields of timer.\n+\t(timevar_pop_1): Likewise, rename to...\n+\t(timer::pop): ...this, and add \"m_\" prefixes.\n+\t(timevar_start): Replace test for \"timevar_enable\" with one for\n+\t\"g_timer\", and move bulk of implementation to...\n+\t(timer::start): ...here, adding \"m_\" prefixes.\n+\t(timevar_stop): Likewise, from here...\n+\t(timer::stop): ...to here.\n+\t(timevar_cond_start): Likewise, from here...\n+\t(timer::cond_start): ...to here.\n+\t(timevar_cond_stop): Likewise, from here...\n+\t(timer::cond_stop): ...to here.\n+\t(validate_phases): Rename to...\n+\t(timer::validate_phases): ...this, and add \"m_\" prefixes.  Make\n+\tlocals \"total\" and \"tv\" const.\n+\t(timevar_print): Rename to...\n+\t(timer::print): ...this, and add \"m_\" prefixes.  Make locals\n+\t\"total\" and \"tv\" const.  Eliminate test for timevar_enable.\n+\t* timevar.h (timevar_enable): Eliminate.\n+\t(g_timer): New declaration.\n+\t(timevar_push_1): Eliminate.\n+\t(timevar_pop_1): Eliminate.\n+\t(timevar_print): Eliminate.\n+\t(class timer): New class.\n+\t(timevar_push): Rewrite to use g_timer.\n+\t(timevar_pop): Likewise.\n+\t* toplev.c (toplev::~toplev): Likewise.\n+\n 2015-05-12  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm-protos.h (arm_sched_autopref): Delete."}, {"sha": "76ad22ac9ef32fb8f7a35255106f26b2dd01d13c", "filename": "gcc/timevar.c", "status": "modified", "additions": 96, "deletions": 111, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=2162235ef67bd4bb10fa1cc7c05ebb7a04c54625", "patch": "@@ -99,10 +99,10 @@ static double clocks_to_msec;\n #define CLOCKS_TO_MSEC (1 / (double)CLOCKS_PER_SEC)\n #endif\n \n-/* True if timevars should be used.  In GCC, this happens with\n+/* Non-NULL if timevars should be used.  In GCC, this happens with\n    the -ftime-report flag.  */\n \n-bool timevar_enable;\n+timer *g_timer;\n \n /* Total amount of memory allocated by garbage collector.  */\n \n@@ -115,57 +115,6 @@ size_t timevar_ggc_mem_total;\n \n /* See timevar.h for an explanation of timing variables.  */\n \n-/* A timing variable.  */\n-\n-struct timevar_def\n-{\n-  /* Elapsed time for this variable.  */\n-  struct timevar_time_def elapsed;\n-\n-  /* If this variable is timed independently of the timing stack,\n-     using timevar_start, this contains the start time.  */\n-  struct timevar_time_def start_time;\n-\n-  /* The name of this timing variable.  */\n-  const char *name;\n-\n-  /* Nonzero if this timing variable is running as a standalone\n-     timer.  */\n-  unsigned standalone : 1;\n-\n-  /* Nonzero if this timing variable was ever started or pushed onto\n-     the timing stack.  */\n-  unsigned used : 1;\n-};\n-\n-/* An element on the timing stack.  Elapsed time is attributed to the\n-   topmost timing variable on the stack.  */\n-\n-struct timevar_stack_def\n-{\n-  /* The timing variable at this stack level.  */\n-  struct timevar_def *timevar;\n-\n-  /* The next lower timing variable context in the stack.  */\n-  struct timevar_stack_def *next;\n-};\n-\n-/* Declared timing variables.  Constructed from the contents of\n-   timevar.def.  */\n-static struct timevar_def timevars[TIMEVAR_LAST];\n-\n-/* The top of the timing stack.  */\n-static struct timevar_stack_def *stack;\n-\n-/* A list of unused (i.e. allocated and subsequently popped)\n-   timevar_stack_def instances.  */\n-static struct timevar_stack_def *unused_stack_instances;\n-\n-/* The time at which the topmost element on the timing stack was\n-   pushed.  Time elapsed since then is attributed to the topmost\n-   element.  */\n-static struct timevar_time_def start_time;\n-\n static void get_time (struct timevar_time_def *);\n static void timevar_accumulate (struct timevar_time_def *,\n \t\t\t\tstruct timevar_time_def *,\n@@ -183,9 +132,6 @@ get_time (struct timevar_time_def *now)\n   now->wall = 0;\n   now->ggc_mem = timevar_ggc_mem_total;\n \n-  if (!timevar_enable)\n-    return;\n-\n   {\n #ifdef USE_TIMES\n     struct tms tms;\n@@ -218,25 +164,24 @@ timevar_accumulate (struct timevar_time_def *timer,\n   timer->ggc_mem += stop_time->ggc_mem - start_time->ggc_mem;\n }\n \n-/* Initialize timing variables.  */\n+/* Class timer's constructor.  */\n \n-void\n-timevar_init (void)\n+timer::timer () :\n+  m_stack (NULL),\n+  m_unused_stack_instances (NULL),\n+  m_start_time ()\n {\n-  if (timevar_enable)\n-    return;\n-\n-  timevar_enable = true;\n-\n   /* Zero all elapsed times.  */\n-  memset (timevars, 0, sizeof (timevars));\n+  memset (m_timevars, 0, sizeof (m_timevars));\n \n   /* Initialize the names of timing variables.  */\n #define DEFTIMEVAR(identifier__, name__) \\\n-  timevars[identifier__].name = name__;\n+  m_timevars[identifier__].name = name__;\n #include \"timevar.def\"\n #undef DEFTIMEVAR\n \n+  /* Initialize configuration-specific state.\n+     Ideally this would be one-time initialization.  */\n #ifdef USE_TIMES\n   ticks_to_msec = TICKS_TO_MSEC;\n #endif\n@@ -245,6 +190,17 @@ timevar_init (void)\n #endif\n }\n \n+/* Initialize timing variables.  */\n+\n+void\n+timevar_init (void)\n+{\n+  if (g_timer)\n+    return;\n+\n+  g_timer = new timer ();\n+}\n+\n /* Push TIMEVAR onto the timing stack.  No further elapsed time is\n    attributed to the previous topmost timing variable on the stack;\n    subsequent elapsed time is attributed to TIMEVAR, until it is\n@@ -253,9 +209,9 @@ timevar_init (void)\n    TIMEVAR cannot be running as a standalone timer.  */\n \n void\n-timevar_push_1 (timevar_id_t timevar)\n+timer::push (timevar_id_t timevar)\n {\n-  struct timevar_def *tv = &timevars[timevar];\n+  struct timevar_def *tv = &m_timevars[timevar];\n   struct timevar_stack_def *context;\n   struct timevar_time_def now;\n \n@@ -270,27 +226,27 @@ timevar_push_1 (timevar_id_t timevar)\n \n   /* If the stack isn't empty, attribute the current elapsed time to\n      the old topmost element.  */\n-  if (stack)\n-    timevar_accumulate (&stack->timevar->elapsed, &start_time, &now);\n+  if (m_stack)\n+    timevar_accumulate (&m_stack->timevar->elapsed, &m_start_time, &now);\n \n   /* Reset the start time; from now on, time is attributed to\n      TIMEVAR.  */\n-  start_time = now;\n+  m_start_time = now;\n \n   /* See if we have a previously-allocated stack instance.  If so,\n      take it off the list.  If not, malloc a new one.  */\n-  if (unused_stack_instances != NULL)\n+  if (m_unused_stack_instances != NULL)\n     {\n-      context = unused_stack_instances;\n-      unused_stack_instances = unused_stack_instances->next;\n+      context = m_unused_stack_instances;\n+      m_unused_stack_instances = m_unused_stack_instances->next;\n     }\n   else\n     context = XNEW (struct timevar_stack_def);\n \n   /* Fill it in and put it on the stack.  */\n   context->timevar = tv;\n-  context->next = stack;\n-  stack = context;\n+  context->next = m_stack;\n+  m_stack = context;\n }\n \n /* Pop the topmost timing variable element off the timing stack.  The\n@@ -300,30 +256,30 @@ timevar_push_1 (timevar_id_t timevar)\n    timing variable.  */\n \n void\n-timevar_pop_1 (timevar_id_t timevar)\n+timer::pop (timevar_id_t timevar)\n {\n   struct timevar_time_def now;\n-  struct timevar_stack_def *popped = stack;\n+  struct timevar_stack_def *popped = m_stack;\n \n-  gcc_assert (&timevars[timevar] == stack->timevar);\n+  gcc_assert (&m_timevars[timevar] == m_stack->timevar);\n \n   /* What time is it?  */\n   get_time (&now);\n \n   /* Attribute the elapsed time to the element we're popping.  */\n-  timevar_accumulate (&popped->timevar->elapsed, &start_time, &now);\n+  timevar_accumulate (&popped->timevar->elapsed, &m_start_time, &now);\n \n   /* Reset the start time; from now on, time is attributed to the\n      element just exposed on the stack.  */\n-  start_time = now;\n+  m_start_time = now;\n \n   /* Take the item off the stack.  */\n-  stack = stack->next;\n+  m_stack = m_stack->next;\n \n   /* Don't delete the stack element; instead, add it to the list of\n      unused elements for later use.  */\n-  popped->next = unused_stack_instances;\n-  unused_stack_instances = popped;\n+  popped->next = m_unused_stack_instances;\n+  m_unused_stack_instances = popped;\n }\n \n /* Start timing TIMEVAR independently of the timing stack.  Elapsed\n@@ -333,11 +289,19 @@ timevar_pop_1 (timevar_id_t timevar)\n void\n timevar_start (timevar_id_t timevar)\n {\n-  struct timevar_def *tv = &timevars[timevar];\n-\n-  if (!timevar_enable)\n+  if (!g_timer)\n     return;\n \n+  g_timer->start (timevar);\n+}\n+\n+/* See timevar_start above.  */\n+\n+void\n+timer::start (timevar_id_t timevar)\n+{\n+  struct timevar_def *tv = &m_timevars[timevar];\n+\n   /* Mark this timing variable as used.  */\n   tv->used = 1;\n \n@@ -355,12 +319,20 @@ timevar_start (timevar_id_t timevar)\n void\n timevar_stop (timevar_id_t timevar)\n {\n-  struct timevar_def *tv = &timevars[timevar];\n-  struct timevar_time_def now;\n-\n-  if (!timevar_enable)\n+  if (!g_timer)\n     return;\n \n+  g_timer->stop (timevar);\n+}\n+\n+/* See timevar_stop above.  */\n+\n+void\n+timer::stop (timevar_id_t timevar)\n+{\n+  struct timevar_def *tv = &m_timevars[timevar];\n+  struct timevar_time_def now;\n+\n   /* TIMEVAR must have been started via timevar_start.  */\n   gcc_assert (tv->standalone);\n   tv->standalone = 0; /* Enable a restart.  */\n@@ -379,11 +351,19 @@ timevar_stop (timevar_id_t timevar)\n bool\n timevar_cond_start (timevar_id_t timevar)\n {\n-  struct timevar_def *tv = &timevars[timevar];\n-\n-  if (!timevar_enable)\n+  if (!g_timer)\n     return false;\n \n+  return g_timer->cond_start (timevar);\n+}\n+\n+/* See timevar_cond_start above.  */\n+\n+bool\n+timer::cond_start (timevar_id_t timevar)\n+{\n+  struct timevar_def *tv = &m_timevars[timevar];\n+\n   /* Mark this timing variable as used.  */\n   tv->used = 1;\n \n@@ -405,14 +385,22 @@ timevar_cond_start (timevar_id_t timevar)\n \n void\n timevar_cond_stop (timevar_id_t timevar, bool running)\n+{\n+  if (!g_timer || running)\n+    return;\n+\n+  g_timer->cond_stop (timevar);\n+}\n+\n+/* See timevar_cond_stop above.  */\n+\n+void\n+timer::cond_stop (timevar_id_t timevar)\n {\n   struct timevar_def *tv;\n   struct timevar_time_def now;\n \n-  if (!timevar_enable || running)\n-    return;\n-\n-  tv = &timevars[timevar];\n+  tv = &m_timevars[timevar];\n \n   /* TIMEVAR must have been started via timevar_cond_start.  */\n   gcc_assert (tv->standalone);\n@@ -425,11 +413,11 @@ timevar_cond_stop (timevar_id_t timevar, bool running)\n \n /* Validate that phase times are consistent.  */\n \n-static void\n-validate_phases (FILE *fp)\n+void\n+timer::validate_phases (FILE *fp) const\n {\n   unsigned int /* timevar_id_t */ id;\n-  struct timevar_time_def *total = &timevars[TV_TOTAL].elapsed;\n+  const timevar_time_def *total = &m_timevars[TV_TOTAL].elapsed;\n   double phase_user = 0.0;\n   double phase_sys = 0.0;\n   double phase_wall = 0.0;\n@@ -439,7 +427,7 @@ validate_phases (FILE *fp)\n \n   for (id = 0; id < (unsigned int) TIMEVAR_LAST; ++id)\n     {\n-      struct timevar_def *tv = &timevars[(timevar_id_t) id];\n+      const timevar_def *tv = &m_timevars[(timevar_id_t) id];\n \n       /* Don't evaluate timing variables that were never used.  */\n       if (!tv->used)\n@@ -480,17 +468,14 @@ validate_phases (FILE *fp)\n    for normalizing the others, and is displayed last.  */\n \n void\n-timevar_print (FILE *fp)\n+timer::print (FILE *fp)\n {\n   /* Only print stuff if we have some sort of time information.  */\n #if defined (HAVE_USER_TIME) || defined (HAVE_SYS_TIME) || defined (HAVE_WALL_TIME)\n   unsigned int /* timevar_id_t */ id;\n-  struct timevar_time_def *total = &timevars[TV_TOTAL].elapsed;\n+  const timevar_time_def *total = &m_timevars[TV_TOTAL].elapsed;\n   struct timevar_time_def now;\n \n-  if (!timevar_enable)\n-    return;\n-\n   /* Update timing information in case we're calling this from GDB.  */\n \n   if (fp == 0)\n@@ -501,17 +486,17 @@ timevar_print (FILE *fp)\n \n   /* If the stack isn't empty, attribute the current elapsed time to\n      the old topmost element.  */\n-  if (stack)\n-    timevar_accumulate (&stack->timevar->elapsed, &start_time, &now);\n+  if (m_stack)\n+    timevar_accumulate (&m_stack->timevar->elapsed, &m_start_time, &now);\n \n   /* Reset the start time; from now on, time is attributed to\n      TIMEVAR.  */\n-  start_time = now;\n+  m_start_time = now;\n \n   fputs (\"\\nExecution times (seconds)\\n\", fp);\n   for (id = 0; id < (unsigned int) TIMEVAR_LAST; ++id)\n     {\n-      struct timevar_def *tv = &timevars[(timevar_id_t) id];\n+      const timevar_def *tv = &m_timevars[(timevar_id_t) id];\n       const double tiny = 5e-3;\n \n       /* Don't print the total execution time here; that goes at the"}, {"sha": "71a814a7d600ee1a63cbda54a121a370f06ee321", "filename": "gcc/timevar.h", "status": "modified", "additions": 93, "deletions": 10, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625/gcc%2Ftimevar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625/gcc%2Ftimevar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.h?ref=2162235ef67bd4bb10fa1cc7c05ebb7a04c54625", "patch": "@@ -79,35 +79,118 @@ typedef enum\n timevar_id_t;\n #undef DEFTIMEVAR\n \n-/* True if timevars should be used.  In GCC, this happens with\n-   the -ftime-report flag.  */\n-extern bool timevar_enable;\n+/* A class to hold all state relating to timing.  */\n+\n+class timer;\n+\n+/* The singleton instance of timing state.\n+\n+   This is non-NULL if timevars should be used.  In GCC, this happens with\n+   the -ftime-report flag.  Hence this is NULL for the common,\n+   needs-to-be-fast case, with an early reject happening for this being\n+   NULL.  */\n+extern timer *g_timer;\n \n /* Total amount of memory allocated by garbage collector.  */\n extern size_t timevar_ggc_mem_total;\n \n extern void timevar_init (void);\n-extern void timevar_push_1 (timevar_id_t);\n-extern void timevar_pop_1 (timevar_id_t);\n extern void timevar_start (timevar_id_t);\n extern void timevar_stop (timevar_id_t);\n extern bool timevar_cond_start (timevar_id_t);\n extern void timevar_cond_stop (timevar_id_t, bool);\n-extern void timevar_print (FILE *);\n+\n+/* The public (within GCC) interface for timing.  */\n+\n+class timer\n+{\n+ public:\n+  timer ();\n+  ~timer ();\n+\n+  void start (timevar_id_t tv);\n+  void stop (timevar_id_t tv);\n+  void push (timevar_id_t tv);\n+  void pop (timevar_id_t tv);\n+  bool cond_start (timevar_id_t tv);\n+  void cond_stop (timevar_id_t tv);\n+\n+  void print (FILE *fp);\n+\n+ private:\n+  /* Private member functions.  */\n+  void validate_phases (FILE *fp) const;\n+\n+ private:\n+\n+  /* Private type: a timing variable.  */\n+  struct timevar_def\n+  {\n+    /* Elapsed time for this variable.  */\n+    struct timevar_time_def elapsed;\n+\n+    /* If this variable is timed independently of the timing stack,\n+       using timevar_start, this contains the start time.  */\n+    struct timevar_time_def start_time;\n+\n+    /* The name of this timing variable.  */\n+    const char *name;\n+\n+    /* Nonzero if this timing variable is running as a standalone\n+       timer.  */\n+    unsigned standalone : 1;\n+\n+    /* Nonzero if this timing variable was ever started or pushed onto\n+       the timing stack.  */\n+    unsigned used : 1;\n+  };\n+\n+  /* Private type: an element on the timing stack\n+     Elapsed time is attributed to the topmost timing variable on the\n+     stack.  */\n+  struct timevar_stack_def\n+  {\n+    /* The timing variable at this stack level.  */\n+    struct timevar_def *timevar;\n+\n+    /* The next lower timing variable context in the stack.  */\n+    struct timevar_stack_def *next;\n+  };\n+\n+ private:\n+\n+  /* Data members (all private).  */\n+\n+  /* Declared timing variables.  Constructed from the contents of\n+     timevar.def.  */\n+  timevar_def m_timevars[TIMEVAR_LAST];\n+\n+  /* The top of the timing stack.  */\n+  timevar_stack_def *m_stack;\n+\n+  /* A list of unused (i.e. allocated and subsequently popped)\n+     timevar_stack_def instances.  */\n+  timevar_stack_def *m_unused_stack_instances;\n+\n+  /* The time at which the topmost element on the timing stack was\n+     pushed.  Time elapsed since then is attributed to the topmost\n+     element.  */\n+  timevar_time_def m_start_time;\n+};\n \n /* Provided for backward compatibility.  */\n static inline void\n timevar_push (timevar_id_t tv)\n {\n-  if (timevar_enable)\n-    timevar_push_1 (tv);\n+  if (g_timer)\n+    g_timer->push (tv);\n }\n \n static inline void\n timevar_pop (timevar_id_t tv)\n {\n-  if (timevar_enable)\n-    timevar_pop_1 (tv);\n+  if (g_timer)\n+    g_timer->pop (tv);\n }\n \n // This is a simple timevar wrapper class that pushes a timevar in its"}, {"sha": "9b1151b01869f72ebf1b6b5039bbe989cb5eeb01", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2162235ef67bd4bb10fa1cc7c05ebb7a04c54625/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=2162235ef67bd4bb10fa1cc7c05ebb7a04c54625", "patch": "@@ -2095,8 +2095,11 @@ toplev::toplev (bool use_TV_TOTAL, bool init_signals)\n \n toplev::~toplev ()\n {\n-  timevar_stop (TV_TOTAL);\n-  timevar_print (stderr);\n+  if (g_timer)\n+    {\n+      g_timer->stop (TV_TOTAL);\n+      g_timer->print (stderr);\n+    }\n }\n \n void"}]}