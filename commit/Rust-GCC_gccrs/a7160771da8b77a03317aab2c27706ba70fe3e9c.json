{"sha": "a7160771da8b77a03317aab2c27706ba70fe3e9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcxNjA3NzFkYThiNzdhMDMzMTdhYWIyYzI3NzA2YmE3MGZlM2U5Yw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-10-09T21:35:11Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-10-09T21:35:11Z"}, "message": "PR tree-optimization/90879 - fold zero-equality of strcmp between a longer string and a smaller array\n\ngcc/c-family/ChangeLog:\n\n\tPR tree-optimization/90879\n\t* c.opt (-Wstring-compare): New option.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/90879\n\t* gcc.dg/Wstring-compare-2.c: New test.\n\t* gcc.dg/Wstring-compare.c: New test.\n\t* gcc.dg/strcmpopt_3.c: Scan the optmized dump instead of strlen.\n\t* gcc.dg/strcmpopt_6.c: New test.\n\t* gcc.dg/strlenopt-65.c: Remove uinnecessary declarations, add\n\ttest cases.\n\t* gcc.dg/strlenopt-66.c: Run it.\n\t* gcc.dg/strlenopt-68.c: New test.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/90879\n\t* builtins.c (check_access): Avoid using maxbound when null.\n\t* calls.c (maybe_warn_nonstring_arg): Adjust to get_range_strlen change.\n\t* doc/invoke.texi (-Wstring-compare): Document new warning option.\n\t* gimple-fold.c (get_range_strlen_tree): Make setting maxbound\n\tconditional.\n\t(get_range_strlen): Overwrite initial maxbound when non-null.\n\t* gimple-ssa-sprintf.c (get_string_length): Adjust to get_range_strlen\n\tchanges.\n\t* tree-ssa-strlen.c (maybe_diag_stxncpy_trunc): Same.\n\t(used_only_for_zero_equality): New function.\n\t(handle_builtin_memcmp): Call it.\n\t(determine_min_objsize): Return an integer instead of tree.\n\t(get_len_or_size, strxcmp_eqz_result): New functions.\n\t(maybe_warn_pointless_strcmp): New function.\n\t(handle_builtin_string_cmp): Call it.  Fold zero-equality of strcmp\n\tbetween a longer string and a smaller array.\n\t(get_range_strlen_dynamic): Overwrite initial maxbound when non-null.\n\nFrom-SVN: r276773", "tree": {"sha": "d959d13c4cf04cf2f20c0cc56cd382c62d3b3b45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d959d13c4cf04cf2f20c0cc56cd382c62d3b3b45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7160771da8b77a03317aab2c27706ba70fe3e9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7160771da8b77a03317aab2c27706ba70fe3e9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7160771da8b77a03317aab2c27706ba70fe3e9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7160771da8b77a03317aab2c27706ba70fe3e9c/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e0a492af5bec8ffa2ec5d99c4858df50d22c16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e0a492af5bec8ffa2ec5d99c4858df50d22c16"}], "stats": {"total": 1576, "additions": 1261, "deletions": 315}, "files": [{"sha": "ada9be7cc1fcc62092c53dc659fa2c52037e893a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -1,3 +1,24 @@\n+2019-10-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/90879\n+\t* builtins.c (check_access): Avoid using maxbound when null.\n+\t* calls.c (maybe_warn_nonstring_arg): Adjust to get_range_strlen change.\n+\t* doc/invoke.texi (-Wstring-compare): Document new warning option.\n+\t* gimple-fold.c (get_range_strlen_tree): Make setting maxbound\n+\tconditional.\n+\t(get_range_strlen): Overwrite initial maxbound when non-null.\n+\t* gimple-ssa-sprintf.c (get_string_length): Adjust to get_range_strlen\n+\tchanges.\n+\t* tree-ssa-strlen.c (maybe_diag_stxncpy_trunc): Same.\n+\t(used_only_for_zero_equality): New function.\n+\t(handle_builtin_memcmp): Call it.\n+\t(determine_min_objsize): Return an integer instead of tree.\n+\t(get_len_or_size, strxcmp_eqz_result): New functions.\n+\t(maybe_warn_pointless_strcmp): New function.\n+\t(handle_builtin_string_cmp): Call it.  Fold zero-equality of strcmp\n+\tbetween a longer string and a smaller array.\n+\t(get_range_strlen_dynamic): Overwrite initial maxbound when non-null.\n+\n 2019-10-09  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* config/darwin.c (darwin_override_options): Make the check for"}, {"sha": "5d811f113c9071329a631aacd275d80ba6013c75", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -3334,7 +3334,7 @@ check_access (tree exp, tree, tree, tree dstwrite,\n \t  c_strlen_data lendata = { };\n \t  get_range_strlen (srcstr, &lendata, /* eltsize = */ 1);\n \t  range[0] = lendata.minlen;\n-\t  range[1] = lendata.maxbound;\n+\t  range[1] = lendata.maxbound ? lendata.maxbound : lendata.maxlen;\n \t  if (range[0] && (!maxread || TREE_CODE (maxread) == INTEGER_CST))\n \t    {\n \t      if (maxread && tree_int_cst_le (maxread, range[0]))"}, {"sha": "398ba6decb367687a08fdb7f21827b264558aa46", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -1,3 +1,8 @@\n+2019-10-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/90879\n+\t* c.opt (-Wstring-compare): New option.\n+\n 2019-10-08  Andrew Sutton  <asutton@lock3software.com>\n \t    Jason Merrill  <jason@redhat.com>\n "}, {"sha": "a1360ba01c2fc2459a7e24aab2c1228eda666888", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -795,6 +795,12 @@ Wsizeof-array-argument\n C ObjC C++ ObjC++ Var(warn_sizeof_array_argument) Warning Init(1)\n Warn when sizeof is applied on a parameter declared as an array.\n \n+Wstring-compare\n+C ObjC C++ LTO ObjC++ Warning Var(warn_string_compare) Warning LangEnabledBy(C ObjC C++ ObjC++, Wextra)\n+Warn about calls to strcmp and strncmp used in equality expressions that\n+are necessarily true or false due to the length of one and size of the other\n+argument.\n+\n Wstringop-overflow\n C ObjC C++ LTO ObjC++ Warning Alias(Wstringop-overflow=, 2, 0)\n Warn about buffer overflow in string manipulation functions like memcpy"}, {"sha": "ae904473d0dc6a718a355dbdcf330f20144c2b4a", "filename": "gcc/calls.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -1614,6 +1614,10 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n \t    if (!get_attr_nonstring_decl (arg))\n \t      {\n \t\tc_strlen_data lendata = { };\n+\t\t/* Set MAXBOUND to an arbitrary non-null non-integer\n+\t\t   node as a request to have it set to the length of\n+\t\t   the longest string in a PHI.  */\n+\t\tlendata.maxbound = arg;\n \t\tget_range_strlen (arg, &lendata, /* eltsize = */ 1);\n \t\tmaxlen = lendata.maxbound;\n \t      }\n@@ -1639,6 +1643,10 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n \tif (!get_attr_nonstring_decl (arg))\n \t  {\n \t    c_strlen_data lendata = { };\n+\t    /* Set MAXBOUND to an arbitrary non-null non-integer\n+\t       node as a request to have it set to the length of\n+\t       the longest string in a PHI.  */\n+\t    lendata.maxbound = arg;\n \t    get_range_strlen (arg, &lendata, /* eltsize = */ 1);\n \t    maxlen = lendata.maxbound;\n \t  }"}, {"sha": "92476031a3fa4b112ce3a23b247bd1f3eeb00356", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -349,6 +349,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wsizeof-pointer-memaccess  -Wsizeof-array-argument @gol\n -Wstack-protector  -Wstack-usage=@var{byte-size}  -Wstrict-aliasing @gol\n -Wstrict-aliasing=n  -Wstrict-overflow  -Wstrict-overflow=@var{n} @gol\n+-Wstring-compare @gol\n -Wstringop-overflow=@var{n}  -Wstringop-truncation  -Wsubobject-linkage @gol\n -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}malloc@r{]} @gol\n -Wsuggest-final-types @gol  -Wsuggest-final-methods  -Wsuggest-override @gol\n@@ -4485,6 +4486,7 @@ name is still supported, but the newer name is more descriptive.)\n -Wold-style-declaration @r{(C only)}  @gol\n -Woverride-init  @gol\n -Wsign-compare @r{(C only)} @gol\n+-Wstring-compare @gol\n -Wredundant-move @r{(only for C++)}  @gol\n -Wtype-limits  @gol\n -Wuninitialized  @gol\n@@ -5800,6 +5802,30 @@ comparisons, so this warning level gives a very large number of\n false positives.\n @end table\n \n+@item -Wstring-compare\n+@opindex Wstring-compare\n+@opindex Wno-string-compare\n+Warn for calls to @code{strcmp} and @code{strncmp} whose result is\n+determined to be either zero or non-zero in tests for such equality\n+owing to the length of one argument being greater than the size of\n+the array the other argument is stored in (or the bound in the case\n+of @code{strncmp}).  Such calls could be mistakes.  For example,\n+the call to @code{strcmp} below is diagnosed because its result is\n+necessarily non-zero irrespective of the contents of the array @code{a}.\n+\n+@smallexample\n+extern char a[4];\n+void f (char *d)\n+@{\n+  strcpy (d, \"string\");\n+  @dots{}\n+  if (0 == strcmp (a, d))   // cannot be true\n+    puts (\"a and d are the same\");\n+@}\n+@end smallexample\n+\n+@option{-Wstring-compare} is enabled by @option{-Wextra}.\n+\n @item -Wstringop-overflow\n @itemx -Wstringop-overflow=@var{type}\n @opindex Wstringop-overflow"}, {"sha": "a085ab2beaf597288458a37278e2f883946a5a8d", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -1348,6 +1348,10 @@ get_range_strlen_tree (tree arg, bitmap *visited, strlen_range_kind rkind,\n \t}\n     }\n \n+  /* Set if VAL represents the maximum length based on array size (set\n+     when exact length cannot be determined).  */\n+  bool maxbound = false;\n+\n   if (!val && rkind == SRK_LENRANGE)\n     {\n       if (TREE_CODE (arg) == ADDR_EXPR)\n@@ -1443,6 +1447,7 @@ get_range_strlen_tree (tree arg, bitmap *visited, strlen_range_kind rkind,\n \t      pdata->minlen = ssize_int (0);\n \t    }\n \t}\n+      maxbound = true;\n     }\n \n   if (!val)\n@@ -1456,25 +1461,23 @@ get_range_strlen_tree (tree arg, bitmap *visited, strlen_range_kind rkind,\n \t  && tree_int_cst_lt (val, pdata->minlen)))\n     pdata->minlen = val;\n \n-  if (pdata->maxbound)\n+  if (pdata->maxbound && TREE_CODE (pdata->maxbound) == INTEGER_CST)\n     {\n       /* Adjust the tighter (more optimistic) string length bound\n \t if necessary and proceed to adjust the more conservative\n \t bound.  */\n       if (TREE_CODE (val) == INTEGER_CST)\n \t{\n-\t  if (TREE_CODE (pdata->maxbound) == INTEGER_CST)\n-\t    {\n-\t      if (tree_int_cst_lt (pdata->maxbound, val))\n-\t\tpdata->maxbound = val;\n-\t    }\n-\t  else\n-\t    pdata->maxbound = build_all_ones_cst (size_type_node);\n+\t  if (tree_int_cst_lt (pdata->maxbound, val))\n+\t    pdata->maxbound = val;\n \t}\n       else\n \tpdata->maxbound = val;\n     }\n-  else\n+  else if (pdata->maxbound || maxbound)\n+    /* Set PDATA->MAXBOUND only if it either isn't INTEGER_CST or\n+       if VAL corresponds to the maximum length determined based\n+       on the type of the object.  */\n     pdata->maxbound = val;\n \n   if (tight_bound)\n@@ -1655,8 +1658,11 @@ get_range_strlen (tree arg, bitmap *visited,\n \n /* Try to obtain the range of the lengths of the string(s) referenced\n    by ARG, or the size of the largest array ARG refers to if the range\n-   of lengths cannot be determined, and store all in *PDATA.  ELTSIZE\n-   is the expected size of the string element in bytes: 1 for char and\n+   of lengths cannot be determined, and store all in *PDATA which must\n+   be zero-initialized on input except PDATA->MAXBOUND may be set to\n+   a non-null tree node other than INTEGER_CST to request to have it\n+   set to the length of the longest string in a PHI.  ELTSIZE is\n+   the expected size of the string element in bytes: 1 for char and\n    some power of 2 for wide characters.\n    Return true if the range [PDATA->MINLEN, PDATA->MAXLEN] is suitable\n    for optimization.  Returning false means that a nonzero PDATA->MINLEN\n@@ -1668,6 +1674,7 @@ bool\n get_range_strlen (tree arg, c_strlen_data *pdata, unsigned eltsize)\n {\n   bitmap visited = NULL;\n+  tree maxbound = pdata->maxbound;\n \n   if (!get_range_strlen (arg, &visited, SRK_LENRANGE, pdata, eltsize))\n     {\n@@ -1680,9 +1687,10 @@ get_range_strlen (tree arg, c_strlen_data *pdata, unsigned eltsize)\n   else if (!pdata->minlen)\n     pdata->minlen = ssize_int (0);\n \n-  /* Unless its null, leave the more conservative MAXBOUND unchanged.  */\n-  if (!pdata->maxbound)\n-    pdata->maxbound = pdata->maxlen;\n+  /* If it's unchanged from it initial non-null value, set the conservative\n+     MAXBOUND to SIZE_MAX.  Otherwise leave it null (if it is null).  */\n+  if (maxbound && pdata->maxbound == maxbound)\n+    pdata->maxbound = build_all_ones_cst (size_type_node);\n \n   if (visited)\n     BITMAP_FREE (visited);"}, {"sha": "b548bbd95e3e861c5c9baecb882d2656aba26fb5", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -1974,8 +1974,11 @@ get_string_length (tree str, unsigned eltsize, const vr_values *vr)\n   if (!str)\n     return fmtresult ();\n \n-  /* Try to determine the dynamic string length first.  */\n+  /* Try to determine the dynamic string length first.\n+     Set MAXBOUND to an arbitrary non-null non-integer node as a request\n+     to have it set to the length of the longest string in a PHI.  */\n   c_strlen_data lendata = { };\n+  lendata.maxbound = str;\n   if (eltsize == 1)\n     get_range_strlen_dynamic (str, &lendata, vr);\n   else\n@@ -1988,26 +1991,27 @@ get_string_length (tree str, unsigned eltsize, const vr_values *vr)\n       get_range_strlen (str, &lendata, eltsize);\n     }\n \n-  /* LENDATA.MAXBOUND is null when LENDATA.MIN corresponds to the shortest\n-     string referenced by STR.  Otherwise, if it's not equal to .MINLEN it\n-     corresponds to the bound of the largest array STR refers to, if known,\n-     or it's SIZE_MAX otherwise.  */\n+  /* If LENDATA.MAXBOUND is not equal to .MINLEN it corresponds to the bound\n+     of the largest array STR refers to, if known, or it's set to SIZE_MAX\n+     otherwise.  */\n \n   /* Return the default result when nothing is known about the string.  */\n-  if (lendata.maxbound)\n+  if ((lendata.maxbound && !tree_fits_uhwi_p (lendata.maxbound))\n+      || !tree_fits_uhwi_p (lendata.maxlen))\n     {\n-      if (integer_all_onesp (lendata.maxbound)\n-      \t  && integer_all_onesp (lendata.maxlen))\n-      \treturn fmtresult ();\n-\n-      if (!tree_fits_uhwi_p (lendata.maxbound)\n-\t  || !tree_fits_uhwi_p (lendata.maxlen))\n-      \treturn fmtresult ();\n-\n-      unsigned HOST_WIDE_INT lenmax = tree_to_uhwi (max_object_size ()) - 2;\n-      if (lenmax <= tree_to_uhwi (lendata.maxbound)\n-\t  && lenmax <= tree_to_uhwi (lendata.maxlen))\n-\treturn fmtresult ();\n+      fmtresult res;\n+      res.nonstr = lendata.decl;\n+      return res;\n+    }\n+\n+  unsigned HOST_WIDE_INT lenmax = tree_to_uhwi (max_object_size ()) - 2;\n+  if (integer_zerop (lendata.minlen)\n+      && (!lendata.maxbound || lenmax <= tree_to_uhwi (lendata.maxbound))\n+      && lenmax <= tree_to_uhwi (lendata.maxlen))\n+    {\n+      fmtresult res;\n+      res.nonstr = lendata.decl;\n+      return res;\n     }\n \n   HOST_WIDE_INT min\n@@ -2056,9 +2060,9 @@ get_string_length (tree str, unsigned eltsize, const vr_values *vr)\n     {\n       /* When the upper bound is unknown (it can be zero or excessive)\n \t set the likely length to the greater of 1.  If MAXBOUND is\n-\t set, also reset the length of the lower bound to zero.  */\n+\t known, also reset the length of the lower bound to zero.  */\n       res.range.likely = res.range.min ? res.range.min : warn_level > 1;\n-      if (lendata.maxbound)\n+      if (lendata.maxbound && !integer_all_onesp (lendata.maxbound))\n \tres.range.min = 0;\n     }\n "}, {"sha": "d03827d9e4ff3e40dc4027871017612be6378675", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -1,3 +1,15 @@\n+2019-10-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/90879\n+\t* gcc.dg/Wstring-compare-2.c: New test.\n+\t* gcc.dg/Wstring-compare.c: New test.\n+\t* gcc.dg/strcmpopt_3.c: Scan the optmized dump instead of strlen.\n+\t* gcc.dg/strcmpopt_6.c: New test.\n+\t* gcc.dg/strlenopt-65.c: Remove uinnecessary declarations, add\n+\ttest cases.\n+\t* gcc.dg/strlenopt-66.c: Run it.\n+\t* gcc.dg/strlenopt-68.c: New test.\n+\n 2019-10-09  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/91364 - P0388R4: Permit conversions to arrays of\tunknown bound."}, {"sha": "e6ca2a6999949a96b0032183ff69b367fcb34bdd", "filename": "gcc/testsuite/gcc.dg/Wstring-compare-2.c", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2FWstring-compare-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2FWstring-compare-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstring-compare-2.c?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -0,0 +1,127 @@\n+/* PR tree-optimization/90879 - fold zero-equality of strcmp between\n+   a longer string and a smaller array\n+   Test for a warning for strcmp of a longer string against smaller\n+   array.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wstring-compare -Wno-stringop-truncation -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void* memcpy (void*, const void*, size_t);\n+\n+extern int strcmp (const char*, const char*);\n+extern size_t strlen (const char*);\n+extern char* strcpy (char*, const char*);\n+extern char* strncpy (char*, const char*, size_t);\n+extern int strncmp (const char*, const char*, size_t);\n+\n+void sink (int, ...);\n+#define sink(...) sink (__LINE__, __VA_ARGS__)\n+\n+\n+extern char a1[1], a2[2], a3[3], a4[4], a5[5], a6[6], a7[7], a8[8], a9[9];\n+\n+#define T(a, b) sink (0 == strcmp (a, b))\n+\n+\n+void test_string_cst (void)\n+{\n+  const char *s1 = \"1\", *s2 = \"12\";\n+\n+  T (s1, a1);                 // { dg-warning \".strcmp. of a string of length 1 and an array of size 1 evaluates to nonzero\" }\n+  T (s1, a2);\n+  T (s1, a3);\n+\n+  T (a1, s1);                 // { dg-warning \".strcmp. of a string of length 1 and an array of size 1 evaluates to nonzero\" }\n+  T (a2, s1);\n+  T (a3, s1);\n+\n+  T (s2, a1);                 // { dg-warning \".strcmp. of a string of length 2 and an array of size 1 evaluates to nonzero\" }\n+  T (s2, a2);                 // { dg-warning \".strcmp. of a string of length 2 and an array of size 2 evaluates to nonzero\" }\n+  T (s2, a3);\n+\n+  T (a1, s2);                 // { dg-warning \".strcmp. of a string of length 2 and an array of size 1 evaluates to nonzero\" }\n+  T (a2, s2);                 // { dg-warning \".strcmp. of a string of length 2 and an array of size 2 evaluates to nonzero\" }\n+  T (a3, s2);\n+}\n+\n+\n+void test_string_cst_off_cst (void)\n+{\n+  const char *s1 = \"1\", *s2 = \"12\", *s3 = \"123\", *s4 = \"1234\";\n+\n+  T (s1, a2 + 1);              // { dg-warning \".strcmp. of a string of length 1 and an array of size 1 evaluates to nonzero\" }\n+  T (a2 + 1, s1);              // { dg-warning \".strcmp. of a string of length 1 and an array of size 1 evaluates to nonzero\" }\n+\n+\n+  T (s3 + 1, a2);             // { dg-warning \".strcmp. of a string of length 2 and an array of size 2 evaluates to nonzero\" }\n+  T (s3 + 1, a3);\n+\n+  T (s2, a4 + 1);\n+  T (s2, a4 + 2);             // { dg-warning \".strcmp. of a string of length 2 and an array of size 2 evaluates to nonzero\" }\n+\n+  T (s4, a4 + 1);             // { dg-warning \".strcmp. of a string of length 4 and an array of size 3 evaluates to nonzero\" }\n+  T (s3, a5 + 1);\n+}\n+\n+\n+/* Use strncpy below rather than memcpy until PR 91183 is resolved.  */\n+\n+#undef T\n+#define T(s, n, a)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    char arr[32];\t\t\t\t\t\\\n+    sink (arr);\t\t\t\t\t\t\\\n+    strncpy (arr, s, n < 0 ? strlen (s) + 1: n);\t\\\n+    sink (0 == strcmp (arr, a));\t\t\t\\\n+  } while (0)\n+\n+void test_string_exact_length (void)\n+{\n+  const char *s1 = \"1\", *s2 = \"12\";\n+\n+  T (s1, -1, a1);             // { dg-warning \".strcmp. of a string of length 1 and an array of size 1 evaluates to nonzero\" }\n+  T (s1, -1, a2);\n+  T (s1, -1, a3);\n+\n+  T (s2, -1, a1);             // { dg-warning \".strcmp. of a string of length 2 and an array of size 1 evaluates to nonzero\" }\n+  T (s2, -1, a2);             // { dg-warning \".strcmp. of a string of length 2 and an array of size 2 evaluates to nonzero\" }\n+  T (s2, -1, a3);\n+}\n+\n+\n+void test_string_min_length (void)\n+{\n+  const char *s1 = \"1\", *s2 = \"12\";\n+\n+  T (s1,  1, a1);             // { dg-warning \".strcmp. of a string of length 1 or more and an array of size 1 evaluates to nonzero\" }\n+  T (s1,  1, a2);\n+  T (s1,  1, a3);\n+\n+  T (s2,  2, a1);             // { dg-warning \".strcmp. of a string of length 2 or more and an array of size 1 evaluates to nonzero\" }\n+  T (s2,  2, a2);             // { dg-warning \".strcmp. of a string of length 2 or more and an array of size 2 evaluates to nonzero\" }\n+  T (s2,  2, a3);\n+}\n+\n+\n+int test_strncmp_str_lit_var (const char *s, long n)\n+{\n+  if (strncmp (s, \"123456\", n) == 0)    // { dg-bogus \"\\\\\\[-Wstring-compare\" }\n+    return 1;\n+\n+  return 0;\n+}\n+\n+int test_strlen_strncmp_str_lit_var (const char *s, long n)\n+{\n+  if (__builtin_strlen (s) < n)\n+    return -1;\n+\n+  if (n == 6)\n+    if (strncmp (s, \"123456\", n) == 0)  // { dg-bogus \"\\\\\\[-Wstring-compare\" }\n+      return 1;\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "0ca492db0ab6c756a5ca7f69397863e2f2a883e3", "filename": "gcc/testsuite/gcc.dg/Wstring-compare.c", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2FWstring-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2FWstring-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstring-compare.c?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -0,0 +1,181 @@\n+/* PR tree-optimization/90879 - fold zero-equality of strcmp between\n+   a longer string and a smaller array\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wextra -ftrack-macro-expansion=0\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define T(a, b) sink (0 == strcmp (a, b), a, b)\n+\n+void sink (int, ...);\n+\n+struct S { char a4[4], c; };\n+\n+extern char a4[4];\n+extern char a5[5];\n+extern char b4[4];\n+\n+/* Verify that comparison of string literals with arrays with unknown\n+   content but size that prevents them from comparing equal is diagnosed.  */\n+\n+void strcmp_array_lit (void)\n+{\n+  if (strcmp (a4, \"1234\"))  // { dg-warning \"'strcmp' of a string of length 4 and an array of size 4 evaluates to nonzero\" }\n+                            // { dg-bogus \"in this expreession\" \"unwanted note\" { target *-*-* } .-1 }\n+    sink (0, a4);\n+\n+  int cmp;\n+  cmp = strcmp (a4, \"1234\");  // { dg-warning \"'strcmp' of a string of length 4 and an array of size 4 evaluates to nonzero\" }\n+  if (cmp)                  // { dg-message \"in this expression\" }\n+    sink (0, a4);\n+\n+  T (a4, \"4321\");           // { dg-warning \"'strcmp' of a string of length 4 and an array of size 4 evaluates to nonzero \" }\n+  T (a4, \"12345\");          // { dg-warning \"length 5 and an array of size 4 \" }\n+  T (a4, \"123456\");         // { dg-warning \"length 6 and an array of size 4 \" }\n+  T (\"1234\", a4);           // { dg-warning \"length 4 and an array of size 4 \" }\n+  T (\"12345\", a4);          // { dg-warning \"length 5 and an array of size 4 \" }\n+  T (\"123456\", a4);         // { dg-warning \"length 6 and an array of size 4 \" }\n+}\n+\n+\n+void strcmp_array_pstr (void)\n+{\n+  const char *s4 = \"1234\";\n+\n+  {\n+    if (strcmp (a4, s4))    // { dg-warning \"'strcmp' of a string of length 4 and an array of size 4 evaluates to nonzero\" }\n+                            // { dg-bogus \"in this expreession\" \"unwanted note\" { target *-*-* } .-1 }\n+      sink (1, a4);\n+    else\n+      sink (0, a4);\n+  }\n+\n+  {\n+    int c;\n+    c = strcmp (a4, s4);    // { dg-warning \"'strcmp' of a string of length 4 and an array of size 4 evaluates to nonzero\" }\n+    if (c)                  // { dg-message \"in this expression\" }\n+      sink (1, a4);\n+    else\n+      sink (0, a4);\n+  }\n+\n+  const char *t4 = \"4321\";\n+  const char *s5 = \"12345\";\n+  const char *s6 = \"123456\";\n+\n+  T (a4, t4);               // { dg-warning \"'strcmp' of a string of length 4 and an array of size 4 evaluates to nonzero \" }\n+  T (a4, s5);               // { dg-warning \"length 5 and an array of size 4 \" }\n+  T (a4, s6);               // { dg-warning \"length 6 and an array of size 4 \" }\n+  T (s4, a4);               // { dg-warning \"length 4 and an array of size 4 \" }\n+  T (s5, a4);               // { dg-warning \"length 5 and an array of size 4 \" }\n+  T (s6, a4);               // { dg-warning \"length 6 and an array of size 4 \" }\n+}\n+\n+\n+void strcmp_array_cond_pstr (int i)\n+{\n+  const char *s4 = i ? \"1234\" : \"4321\";\n+  T (a4, s4);               // { dg-warning \"'strcmp' of a string of length 4 and an array of size 4 evaluates to nonzero \" }\n+  T (a5, s4);\n+}\n+\n+void strcmp_array_copy (void)\n+{\n+  char s[8];\n+\n+  {\n+    strcpy (s, \"1234\");\n+    if (strcmp (a4, s))     // { dg-warning \"'strcmp' of a string of length 4 and an array of size 4 evaluates to nonzero\" }\n+                            // { dg-bogus \"in this expreession\" \"unwanted note\" { target *-*-* } .-1 }\n+      sink (1, a4);\n+    else\n+      sink (0, a4);\n+  }\n+\n+  {\n+    strcpy (s, \"1234\");\n+\n+    int c;\n+    c = strcmp (a4, s);     // { dg-warning \"'strcmp' of a string of length 4 and an array of size 4 evaluates to nonzero\" }\n+    if (c)                  // { dg-message \"in this expression\" }\n+      sink (1, a4);\n+    else\n+      sink (0, a4);\n+  }\n+\n+  strcpy (s, \"4321\");\n+  T (a4, s);                // { dg-warning \"'strcmp' of a string of length 4 and an array of size 4 evaluates to nonzero \" }\n+  strcpy (s, \"12345\");\n+  T (a4, s);                // { dg-warning \"length 5 and an array of size 4 \" }\n+  strcpy (s, \"123456\");\n+  T (a4, s);                // { dg-warning \"length 6 and an array of size 4 \" }\n+  strcpy (s, \"4321\");\n+  T (s, a4);                // { dg-warning \"length 4 and an array of size 4 \" }\n+  strcpy (s, \"54321\");\n+  T (s, a4);                // { dg-warning \"length 5 and an array of size 4 \" }\n+  strcpy (s, \"654321\");\n+  T (s, a4);                // { dg-warning \"length 6 and an array of size 4 \" }\n+}\n+\n+\n+void strcmp_member_array_lit (const struct S *p)\n+{\n+  T (p->a4, \"1234\");        // { dg-warning \"length 4 and an array of size 4 \" }\n+}\n+\n+\n+#undef T\n+#define T(a, b, n) sink (0 == strncmp (a, b, n), a, b)\n+\n+void strncmp_array_lit (void)\n+{\n+  if (strncmp (a4, \"12345\", 5))   // { dg-warning \"'strncmp' of a string of length 5, an array of size 4 and bound of 5 evaluates to nonzero\" }\n+                                  // { dg-bogus \"in this expreession\" \"unwanted note\" { target *-*-* } .-1 }\n+    sink (0, a4);\n+\n+  int cmp;\n+  cmp = strncmp (a4, \"54321\", 5);   // { dg-warning \"'strncmp' of a string of length 5, an array of size 4 and bound of 5 evaluates to nonzero\" }\n+  if (cmp)                          // { dg-message \"in this expression\" }\n+    sink (0, a4);\n+\n+  // Verify no warning when the bound is the same as the array size.\n+  T (a4, \"4321\", 4);\n+  T (a4, \"654321\", 4);\n+\n+  T (a4, \"12345\", 5);       // { dg-warning \"length 5, an array of size 4 and bound of 5 \" }\n+  T (a4, \"123456\", 6);      // { dg-warning \"length 6, an array of size 4 and bound of 6\" }\n+\n+  T (\"1234\", a4, 4);\n+  T (\"12345\", a4, 4);\n+\n+  T (\"12345\", a4, 5);       // { dg-warning \"length 5, an array of size 4 and bound of 5 \" }\n+  T (\"123456\", a4, 6);      // { dg-warning \"length 6, an array of size 4 and bound of 6 \" }\n+}\n+\n+\n+void strncmp_strarray_copy (void)\n+{\n+  {\n+    char a[] = \"1234\";\n+    char b[6];\n+    strcpy (b, \"12345\");\n+    if (strncmp (a, b, 5))  // { dg-warning \"'strncmp' of strings of length 4 and 5 and bound of 5 evaluates to nonzero\" }\n+                            // { dg-bogus \"in this expreession\" \"unwanted note\" { target *-*-* } .-1 }\n+      sink (0, a, b);\n+  }\n+\n+  {\n+    char a[] = \"4321\";\n+    char b[6];\n+    strcpy (b, \"54321\");\n+    int cmp;\n+    cmp = strncmp (a, b, 5);  // { dg-warning \"'strncmp' of strings of length 4 and 5 and bound of 5 evaluates to nonzero\" }\n+    if (cmp)                  // { dg-message \"in this expression\" }\n+      sink (0, a, b);\n+  }\n+\n+  strcpy (a4, \"abc\");\n+  T (a4, \"54321\", 5);       // { dg-warning \"'strncmp' of strings of length 3 and 5 and bound of 5 evaluates to nonzero \" }\n+}\n+\n+"}, {"sha": "35941bee57593a7d5178daab8595acdc0cd560b3", "filename": "gcc/testsuite/gcc.dg/strcmpopt_3.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_3.c?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -1,31 +1,31 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n \n-__attribute__ ((noinline)) int \n-f1 (void) \n-{ \n+__attribute__ ((noinline)) int\n+f1 (void)\n+{\n   char *s0= \"abcd\";\n   char s[8];\n   __builtin_strcpy (s, s0);\n-  return __builtin_strcmp(s, \"abc\") != 0; \n+  return __builtin_strcmp (s, \"abc\") != 0;\n }\n \n __attribute__ ((noinline)) int\n-f2 (void) \n-{ \n+f2 (void)\n+{\n   char *s0 = \"ab\";\n   char s[8];\n   __builtin_strcpy (s, s0);\n-  return __builtin_strcmp(\"abc\", s) != 0; \n+  return __builtin_strcmp (\"abc\", s) != 0;\n }\n \n int main (void)\n {\n-  if (f1 () != 1 \n+  if (f1 () != 1\n       || f2 () != 1)\n     __builtin_abort ();\n \n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"strcmp\" 0 \"strlen1\" } } */\n+/* { dg-final { scan-tree-dump-times \"strcmp\" 0 \"optimized\" } } */"}, {"sha": "cb99294e5faa67c862cf6b1d6d3b3040d7f6cea5", "filename": "gcc/testsuite/gcc.dg/strcmpopt_6.c", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_6.c?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -0,0 +1,207 @@\n+/* Verify that strcmp and strncmp calls with mixed constant and\n+   non-constant strings are evaluated correctly.\n+   { dg-do run }\n+   { dg-options \"-O2\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define A(expr)                                                 \\\n+  ((expr)                                                       \\\n+   ? (void)0                                                    \\\n+   : (__builtin_printf (\"assertion failed on line %i: %s\\n\",    \\\n+                        __LINE__, #expr),                       \\\n+      __builtin_abort ()))\n+\n+__attribute__ ((noclone, noinline)) int\n+test_strlen_gt2_strcmp_abcd (const char *s)\n+{\n+  if (strlen (s) < 3)\n+    return -1;\n+\n+  return strcmp (s, \"abcd\") == 0;\n+}\n+\n+__attribute__ ((noclone, noinline)) int\n+test_strlen_lt6_strcmp_abcd (const char *s)\n+{\n+  if (strlen (s) > 5)\n+    return -1;\n+\n+  return strcmp (s, \"abcd\") == 0;\n+}\n+\n+__attribute__ ((noclone, noinline)) int\n+test_strcpy_strcmp_abc (const char *s)\n+{\n+  char a[4];\n+  strcpy (a, s);\n+  return strcmp (a, \"abc\") == 0;\n+}\n+\n+__attribute__ ((noclone, noinline)) int\n+test_strcpy_abc_strcmp (const char *s)\n+{\n+  char a[4], b[6];\n+  strcpy (a, \"abc\");\n+  strcpy (b, s);\n+  return strcmp (a, b) == 0;\n+}\n+\n+/* Exercise strcmp of two strings between 1 and 3 characters long\n+   stored in arrays of the same known size.  */\n+char ga4[4], gb4[4];\n+\n+__attribute__ ((noclone, noinline)) int\n+test_store_0_nulterm_strcmp_same_size_arrays (void)\n+{\n+  ga4[0] = gb4[0] = 'x';\n+  ga4[3] = gb4[3] = '\\0';\n+  return strcmp (ga4, gb4) == 0;\n+}\n+\n+__attribute__ ((noclone, noinline)) int\n+test_store_0_nulterm_strncmp_bound_2_same_size_arrays (void)\n+{\n+  ga4[0] = gb4[0] = 'x';\n+  ga4[3] = gb4[3] = '\\0';\n+  return strncmp (ga4, gb4, 2) == 0;\n+}\n+\n+__attribute__ ((noclone, noinline)) int\n+test_store_0_nulterm_strncmp_bound_equal_same_size_arrays (void)\n+{\n+  ga4[0] = gb4[0] = 'x';\n+  ga4[3] = gb4[3] = '\\0';\n+  return strncmp (ga4, gb4, 4) == 0;\n+}\n+\n+/* Exercise strcmp of two strings between 0 and 3 characters long\n+   stored in arrays of the same known size.  */\n+\n+__attribute__ ((noclone, noinline)) int\n+test_nulterm_strcmp_same_size_arrays (void)\n+{\n+  ga4[3] = gb4[3] = '\\0';\n+  return strcmp (ga4, gb4) == 0;\n+}\n+\n+/* Exercise strcmp of two strings between 1 and 3 and 1 and 4 characters\n+   long, respectively, stored in arrays of known but different sizes.  */\n+char gc5[5];\n+\n+__attribute__ ((noclone, noinline)) int\n+test_store_0_nulterm_strcmp_arrays (void)\n+{\n+  ga4[0] = gc5[0] = 'x';\n+  ga4[3] = gc5[4] = '\\0';\n+  return strcmp (ga4, gc5) == 0;\n+}\n+\n+/* Exercise strcmp of two strings between 0 and 3 and 1 and 4 characters\n+   long, respectively, stored in arrays of known but different sizes.  */\n+\n+__attribute__ ((noclone, noinline)) int\n+test_nulterm_strcmp_arrays (void)\n+{\n+  ga4[3] = gc5[4] = '\\0';\n+  return strcmp (ga4, gc5) == 0;\n+}\n+\n+\n+__attribute__ ((noclone, noinline)) int\n+test_strcpy_strncmp_abcd (const char *s)\n+{\n+  char a[6];\n+  strcpy (a, s);\n+  return strcmp (a, \"abcd\") == 0;\n+}\n+\n+__attribute__ ((noclone, noinline)) int\n+test_strcpy_abcd_strncmp_3 (const char *s)\n+{\n+  char a[6], b[8];\n+  strcpy (a, \"abcd\");\n+  strcpy (b, s);\n+  return strncmp (a, b, 3) == 0;\n+}\n+\n+__attribute__ ((noclone, noinline)) int\n+test_strcpy_abcd_strncmp_4 (const char *s)\n+{\n+  char a[6], b[8];\n+  strcpy (a, \"abcd\");\n+  strcpy (b, s);\n+  return strncmp (a, b, 4) == 0;\n+}\n+\n+\n+int main (void)\n+{\n+  test_strlen_gt2_strcmp_abcd (\"abcd\");\n+  test_strlen_lt6_strcmp_abcd (\"abcd\");\n+\n+  A (0 == test_strcpy_strcmp_abc (\"ab\"));\n+  A (0 != test_strcpy_strcmp_abc (\"abc\"));\n+  A (0 == test_strcpy_strcmp_abc (\"abcd\"));\n+\n+  A (0 == test_strcpy_abc_strcmp (\"ab\"));\n+  A (0 != test_strcpy_abc_strcmp (\"abc\"));\n+  A (0 == test_strcpy_abc_strcmp (\"abcd\"));\n+\n+  strcpy (ga4, \"abc\"); strcpy (gb4, \"abd\");\n+  A (0 == test_store_0_nulterm_strcmp_same_size_arrays ());\n+  strcpy (ga4, \"abd\"); strcpy (gb4, \"abc\");\n+  A (0 == test_store_0_nulterm_strcmp_same_size_arrays ());\n+  strcpy (ga4, \"abc\"); strcpy (gb4, \"abc\");\n+  A (0 != test_store_0_nulterm_strcmp_same_size_arrays ());\n+\n+  strcpy (ga4, \"abc\"); strcpy (gb4, \"acd\");\n+  A (0 == test_store_0_nulterm_strncmp_bound_2_same_size_arrays ());\n+  strcpy (ga4, \"acd\"); strcpy (gb4, \"abc\");\n+  A (0 == test_store_0_nulterm_strncmp_bound_2_same_size_arrays ());\n+  strcpy (ga4, \"abc\"); strcpy (gb4, \"abc\");\n+  A (0 != test_store_0_nulterm_strncmp_bound_2_same_size_arrays ());\n+\n+  strcpy (ga4, \"abc\"); strcpy (gb4, \"abd\");\n+  A (0 == test_store_0_nulterm_strncmp_bound_equal_same_size_arrays ());\n+  strcpy (ga4, \"abd\"); strcpy (gb4, \"abc\");\n+  A (0 == test_store_0_nulterm_strncmp_bound_equal_same_size_arrays ());\n+  strcpy (ga4, \"abc\"); strcpy (gb4, \"abc\");\n+  A (0 != test_store_0_nulterm_strncmp_bound_equal_same_size_arrays ());\n+\n+  strcpy (ga4, \"abc\"); strcpy (gb4, \"abd\");\n+  A (0 == test_nulterm_strcmp_same_size_arrays ());\n+  strcpy (ga4, \"abd\"); strcpy (gb4, \"abc\");\n+  A (0 == test_nulterm_strcmp_same_size_arrays ());\n+  strcpy (ga4, \"abc\"); strcpy (gb4, \"abc\");\n+  A (0 != test_nulterm_strcmp_same_size_arrays ());\n+\n+  strcpy (ga4, \"abc\"); strcpy (gc5, \"abcd\");\n+  A (0 == test_store_0_nulterm_strcmp_arrays ());\n+  strcpy (ga4, \"abd\"); strcpy (gc5, \"abcd\");\n+  A (0 == test_store_0_nulterm_strcmp_arrays ());\n+  strcpy (ga4, \"abc\"); strcpy (gc5, \"abc\");\n+  A (0 != test_store_0_nulterm_strcmp_arrays ());\n+\n+  strcpy (ga4, \"abc\"); strcpy (gc5, \"abcd\");\n+  A (0 == test_nulterm_strcmp_arrays ());\n+  strcpy (ga4, \"abd\"); strcpy (gc5, \"abc\");\n+  A (0 == test_nulterm_strcmp_arrays ());\n+  strcpy (ga4, \"abc\"); strcpy (gc5, \"abc\");\n+  A (0 != test_nulterm_strcmp_arrays ());\n+\n+  A (0 == test_strcpy_strncmp_abcd (\"ab\"));\n+  A (0 == test_strcpy_strncmp_abcd (\"abc\"));\n+  A (0 != test_strcpy_strncmp_abcd (\"abcd\"));\n+  A (0 == test_strcpy_strncmp_abcd (\"abcde\"));\n+\n+  A (0 == test_strcpy_abcd_strncmp_3 (\"ab\"));\n+  A (0 != test_strcpy_abcd_strncmp_3 (\"abc\"));\n+  A (0 != test_strcpy_abcd_strncmp_3 (\"abcd\"));\n+  A (0 != test_strcpy_abcd_strncmp_3 (\"abcde\"));\n+\n+  A (0 == test_strcpy_abcd_strncmp_4 (\"ab\"));\n+  A (0 == test_strcpy_abcd_strncmp_4 (\"abc\"));\n+  A (0 != test_strcpy_abcd_strncmp_4 (\"abcd\"));\n+  A (0 != test_strcpy_abcd_strncmp_4 (\"abcde\"));\n+}"}, {"sha": "521d7ac2b42e41a0fb6b948b218f3ae3749a299a", "filename": "gcc/testsuite/gcc.dg/strlenopt-65.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-65.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-65.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-65.c?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -1,17 +1,10 @@\n /* PRE tree-optimization/90626 - fold strcmp(a, b) == 0 to zero when\n    one string length is exact and the other is unequal\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+   { dg-options \"-O2 -Wall -Wno-string-compare -fdump-tree-optimized -ftrack-macro-expansion=0\" } */\n \n #include \"strlenopt.h\"\n \n-typedef __SIZE_TYPE__ size_t;\n-\n-extern void abort (void);\n-extern void* memcpy (void *, const void *, size_t);\n-extern int strcmp (const char *, const char *);\n-extern int strncmp (const char *, const char *, size_t);\n-\n #define CAT(x, y) x ## y\n #define CONCAT(x, y) CAT (x, y)\n #define FAILNAME(name) CONCAT (call_ ## name ##_on_line_, __LINE__)\n@@ -142,21 +135,45 @@ void test_strcmp_keep (const char *s, const char *t)\n #undef CMPFUNC\n #define CMPFUNC(a, b, dummy) strcmp (a, b)\n \n-  KEEP (\"1\", \"1\", a, b, -1);\n+  KEEP (\"123\", \"123\\0\", a, b, /* bnd = */ -1);\n+  KEEP (\"123\\0\", \"123\", a, b, -1);\n+\n+  {\n+    char a[8], b[8];\n+    sink (a, b);\n+    strcpy (a, s);\n+    strcpy (b, t);\n+    TEST_KEEP (0 == strcmp (a, b));\n+  }\n+}\n+\n+\n+void test_strncmp_keep (const char *s, const char *t)\n+{\n+#undef CMPFUNC\n+#define CMPFUNC(a, b, n) strncmp (a, b, n)\n+\n+  KEEP (\"1\", \"1\", a, b, 2);\n \n-  KEEP (\"1\\0\", \"1\", a, b, -1);\n-  KEEP (\"1\",   \"1\\0\", a, b, -1);\n+  KEEP (\"1\\0\", \"1\", a, b, 2);\n+  KEEP (\"1\",   \"1\\0\", a, b, 2);\n \n-  KEEP (\"12\\0\", \"12\", a, b, -1);\n-  KEEP (\"12\",   \"12\\0\", a, b, -1);\n+  KEEP (\"12\\0\", \"12\", a, b, 2);\n+  KEEP (\"12\",   \"12\\0\", a, b, 2);\n \n-  KEEP (\"111\\0\", \"111\", a, b, -1);\n-  KEEP (\"112\", \"112\\0\", a, b, -1);\n+  KEEP (\"111\\0\", \"111\", a, b, 3);\n+  KEEP (\"112\", \"112\\0\", a, b, 3);\n \n-  KEEP (s, t, a, b, -1);\n+  {\n+    char a[8], b[8];\n+    sink (a, b);\n+    strcpy (a, s);\n+    strcpy (b, t);\n+    TEST_KEEP (0 == strncmp (a, b, sizeof a));\n+  }\n }\n \n /* { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated_\" 0 \"optimized\" } }\n \n-   { dg-final { scan-tree-dump-times \"call_made_in_true_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 8 \"optimized\" } }\n-   { dg-final { scan-tree-dump-times \"call_made_in_false_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 8 \"optimized\" } } */\n+   { dg-final { scan-tree-dump-times \"call_made_in_true_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 11 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"call_made_in_false_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 11 \"optimized\" } } */"}, {"sha": "4ba31a845b0cb59e961937fe81b4625df16fdc28", "filename": "gcc/testsuite/gcc.dg/strlenopt-66.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-66.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-66.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-66.c?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -1,6 +1,6 @@\n /* PRE tree-optimization/90626 - fold strcmp(a, b) == 0 to zero when\n    one string length is exact and the other is unequal\n-   { dg-do compile }\n+   { dg-do run }\n    { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n \n #include \"strlenopt.h\"\n@@ -65,8 +65,44 @@ test_strncmp (void)\n   A (0 <  strncmp (b, a, 5));\n }\n \n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+test_strncmp_a4_cond_s5_s2_2 (const char *s, int i)\n+{\n+  char a4[4];\n+  strcpy (a4, s);\n+  A (0 == strncmp (a4, i ? \"12345\" : \"12\", 2));\n+}\n+\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+test_strncmp_a4_cond_a5_s2_5 (const char *s, const char *t, int i)\n+{\n+  char a4[4], a5[5];\n+  strcpy (a4, s);\n+  strcpy (a5, t);\n+  A (0 == strncmp (a4, i ? a5 : \"12\", 5));\n+}\n+\n+__attribute__ ((noclone, noinline, noipa)) void\n+test_strncmp_a4_cond_a5_a3_n (const char *s1, const char *s2, const char *s3,\n+\t\t\t      int i, unsigned n)\n+{\n+  char a3[3], a4[4], a5[5];\n+  strcpy (a3, s1);\n+  strcpy (a4, s2);\n+  strcpy (a5, s3);\n+  A (0 == strncmp (a4, i ? a5 : a3, n));\n+}\n+\n+\n int main (void)\n {\n   test_strcmp ();\n   test_strncmp ();\n+  test_strncmp_a4_cond_s5_s2_2 (\"12\", 0);\n+  test_strncmp_a4_cond_a5_s2_5 (\"12\", \"1234\", 0);\n+\n+  test_strncmp_a4_cond_a5_a3_n (\"12\", \"123\", \"1234\", 0, 2);\n+  test_strncmp_a4_cond_a5_a3_n (\"123\", \"12\", \"12\", 1, 3);\n }"}, {"sha": "46ceb9ddb054dc5f891cc64afc0e34ff9c37a4b1", "filename": "gcc/testsuite/gcc.dg/strlenopt-69.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-69.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-69.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-69.c?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -0,0 +1,126 @@\n+/* PR tree-optimization/90879 - fold zero-equality of strcmp between\n+   a longer string and a smaller array\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-string-compare -fdump-tree-optimized -ftrack-macro-expansion=0\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define A(expr)                                                 \\\n+  ((expr)                                                       \\\n+   ? (void)0                                                    \\\n+   : (__builtin_printf (\"assertion failed on line %i: %s\\n\",    \\\n+                        __LINE__, #expr),                       \\\n+      __builtin_abort ()))\n+\n+void clobber (void*, ...);\n+\n+struct S { char a4[4], c; };\n+\n+extern char a4[4];\n+extern char b4[4];\n+\n+/* Verify that comparison of string literals with arrays with unknown\n+   content but size that prevents them from comparing equal is folded\n+   to a constant.  */\n+\n+void test_array_lit (void)\n+{\n+  A (strcmp (a4, \"1234\")); clobber (a4);\n+  A (strcmp (a4, \"12345\")); clobber (a4);\n+  A (strcmp (a4, \"123456\")); clobber (a4);\n+  A (strcmp (\"1234\", a4)); clobber (a4);\n+  A (strcmp (\"12345\", a4)); clobber (a4);\n+  A (strcmp (\"123456\", a4)); clobber (a4);\n+}\n+\n+void test_memarray_lit (struct S *p)\n+{\n+  A (strcmp (p->a4, \"1234\"));\n+  A (strcmp (p->a4, \"12345\"));\n+  A (strcmp (p->a4, \"123456\"));\n+\n+  A (strcmp (\"1234\", p->a4));\n+  A (strcmp (\"12345\", p->a4));\n+  A (strcmp (\"123456\", p->a4));\n+}\n+\n+/* Verify that the equality of empty strings is folded.  */\n+\n+void test_empty_string (void)\n+{\n+  A (0 == strcmp (\"\", \"\"));\n+\n+  *a4 = '\\0';\n+  A (0 == strcmp (a4, \"\"));\n+  A (0 == strcmp (\"\", a4));\n+  A (0 == strcmp (a4, a4));\n+\n+  char s[8] = \"\";\n+  A (0 == strcmp (a4, s));\n+\n+  a4[1] = '\\0';\n+  b4[1] = '\\0';\n+  A (0 == strcmp (a4 + 1, b4 + 1));\n+\n+  a4[2] = '\\0';\n+  b4[2] = '\\0';\n+  A (0 == strcmp (&a4[2], &b4[2]));\n+\n+  clobber (a4, b4);\n+\n+  memset (a4, 0, sizeof a4);\n+  memset (b4, 0, sizeof b4);\n+  A (0 == strcmp (a4, b4));\n+}\n+\n+/* Verify that comparison of dynamically created strings with unknown\n+   arrays is folded.  */\n+\n+void test_array_copy (void)\n+{\n+  char s[8];\n+  strcpy (s, \"1234\");\n+  A (strcmp (a4, s));\n+\n+  strcpy (s, \"12345\");\n+  A (strlen (s) == 5);\n+  A (strcmp (a4, s)); clobber (a4);\n+\n+  strcpy (s, \"123456\");\n+  A (strcmp (a4, s)); clobber (a4);\n+\n+  strcpy (s, \"1234\");\n+  A (strcmp (s, a4)); clobber (a4);\n+\n+  strcpy (s, \"12345\");\n+  A (strcmp (s, a4)); clobber (a4);\n+\n+  strcpy (s, \"123456\");\n+  A (strcmp (s, a4)); clobber (a4);\n+}\n+\n+\n+void test_array_bounded (void)\n+{\n+  A (strncmp (a4, \"12345\", 5)); clobber (a4);\n+  A (strncmp (\"54321\", a4, 5)); clobber (a4);\n+\n+  A (strncmp (a4, \"123456\", 5)); clobber (a4);\n+  A (strncmp (\"654321\", a4, 5)); clobber (a4);\n+}\n+\n+void test_array_copy_bounded (void)\n+{\n+  char s[8];\n+  strcpy (s, \"12345\");\n+  A (strncmp (a4, s, 5)); clobber (a4);\n+  strcpy (s, \"54321\");\n+  A (strncmp (s, a4, 5)); clobber (a4);\n+\n+  strcpy (s, \"123456\");\n+  A (strncmp (a4, s, 5)); clobber (a4);\n+  strcpy (s, \"654321\");\n+  A (strncmp (s, a4, 5)); clobber (a4);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"abort|strcmp|strncmp\" \"optimized\" } } */"}, {"sha": "ef2717d6a29e230c3907e68960fb465be93100e0", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 413, "deletions": 251, "changes": 664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7160771da8b77a03317aab2c27706ba70fe3e9c/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=a7160771da8b77a03317aab2c27706ba70fe3e9c", "patch": "@@ -915,6 +915,7 @@ get_range_strlen_dynamic (tree src, c_strlen_data *pdata, bitmap *visited,\n \t\t\t      && tree_int_cst_lt (pdata->maxlen, argdata.maxlen)))\n \t\t\tpdata->maxlen = argdata.maxlen;\n \t\t      if (!pdata->maxbound\n+\t\t\t  || TREE_CODE (pdata->maxbound) != INTEGER_CST\n \t\t\t  || (argdata.maxbound\n \t\t\t      && tree_int_cst_lt (pdata->maxbound,\n \t\t\t\t\t\t  argdata.maxbound)\n@@ -1042,6 +1043,7 @@ get_range_strlen_dynamic (tree src, c_strlen_data *pdata,\n \t\t\t  const vr_values *rvals)\n {\n   bitmap visited = NULL;\n+  tree maxbound = pdata->maxbound;\n \n   unsigned limit = PARAM_VALUE (PARAM_SSA_NAME_DEF_CHAIN_LIMIT);\n   if (!get_range_strlen_dynamic (src, pdata, &visited, rvals, &limit))\n@@ -1055,6 +1057,11 @@ get_range_strlen_dynamic (tree src, c_strlen_data *pdata,\n   else if (!pdata->minlen)\n     pdata->minlen = ssize_int (0);\n \n+  /* If it's unchanged from it initial non-null value, set the conservative\n+     MAXBOUND to SIZE_MAX.  Otherwise leave it null (if it is null).  */\n+  if (maxbound && pdata->maxbound == maxbound)\n+    pdata->maxbound = build_all_ones_cst (size_type_node);\n+\n   if (visited)\n     BITMAP_FREE (visited);\n }\n@@ -2454,6 +2461,9 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n   else\n     {\n       c_strlen_data lendata = { };\n+      /* Set MAXBOUND to an arbitrary non-null non-integer node as a request\n+\t to have it set to the length of the longest string in a PHI.  */\n+      lendata.maxbound = src;\n       get_range_strlen (src, &lendata, /* eltsize = */1);\n       if (TREE_CODE (lendata.minlen) == INTEGER_CST\n \t  && TREE_CODE (lendata.maxbound) == INTEGER_CST)\n@@ -3226,51 +3236,78 @@ handle_builtin_memset (gimple_stmt_iterator *gsi)\n   return true;\n }\n \n-/* Handle a call to memcmp.  We try to handle small comparisons by\n-   converting them to load and compare, and replacing the call to memcmp\n-   with a __builtin_memcmp_eq call where possible.\n-   return true when call is transformed, return false otherwise.  */\n+/* Return a pointer to the first such equality expression if RES is used\n+   only in expressions testing its equality to zero, and null otherwise.  */\n \n-static bool\n-handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n+static gimple *\n+used_only_for_zero_equality (tree res)\n {\n-  gcall *stmt2 = as_a <gcall *> (gsi_stmt (*gsi));\n-  tree res = gimple_call_lhs (stmt2);\n-  tree arg1 = gimple_call_arg (stmt2, 0);\n-  tree arg2 = gimple_call_arg (stmt2, 1);\n-  tree len = gimple_call_arg (stmt2, 2);\n-  unsigned HOST_WIDE_INT leni;\n+  gimple *first_use = NULL;\n+\n   use_operand_p use_p;\n   imm_use_iterator iter;\n \n-  if (!res)\n-    return false;\n-\n   FOR_EACH_IMM_USE_FAST (use_p, iter, res)\n     {\n-      gimple *ustmt = USE_STMT (use_p);\n+      gimple *use_stmt = USE_STMT (use_p);\n \n-      if (is_gimple_debug (ustmt))\n-\tcontinue;\n-      if (gimple_code (ustmt) == GIMPLE_ASSIGN)\n+      if (is_gimple_debug (use_stmt))\n+        continue;\n+      if (gimple_code (use_stmt) == GIMPLE_ASSIGN)\n \t{\n-\t  gassign *asgn = as_a <gassign *> (ustmt);\n-\t  tree_code code = gimple_assign_rhs_code (asgn);\n-\t  if ((code != EQ_EXPR && code != NE_EXPR)\n-\t      || !integer_zerop (gimple_assign_rhs2 (asgn)))\n-\t    return false;\n+\t  tree_code code = gimple_assign_rhs_code (use_stmt);\n+\t  if (code == COND_EXPR)\n+\t    {\n+\t      tree cond_expr = gimple_assign_rhs1 (use_stmt);\n+\t      if ((TREE_CODE (cond_expr) != EQ_EXPR\n+\t\t   && (TREE_CODE (cond_expr) != NE_EXPR))\n+\t\t  || !integer_zerop (TREE_OPERAND (cond_expr, 1)))\n+\t\treturn NULL;\n+\t    }\n+\t  else if (code == EQ_EXPR || code == NE_EXPR)\n+\t    {\n+\t      if (!integer_zerop (gimple_assign_rhs2 (use_stmt)))\n+\t\treturn NULL;\n+            }\n+\t  else\n+\t    return NULL;\n \t}\n-      else if (gimple_code (ustmt) == GIMPLE_COND)\n+      else if (gimple_code (use_stmt) == GIMPLE_COND)\n \t{\n-\t  tree_code code = gimple_cond_code (ustmt);\n+\t  tree_code code = gimple_cond_code (use_stmt);\n \t  if ((code != EQ_EXPR && code != NE_EXPR)\n-\t      || !integer_zerop (gimple_cond_rhs (ustmt)))\n-\t    return false;\n+\t      || !integer_zerop (gimple_cond_rhs (use_stmt)))\n+\t    return NULL;\n \t}\n       else\n-\treturn false;\n+        return NULL;\n+\n+      if (!first_use)\n+\tfirst_use = use_stmt;\n     }\n \n+  return first_use;\n+}\n+\n+/* Handle a call to memcmp.  We try to handle small comparisons by\n+   converting them to load and compare, and replacing the call to memcmp\n+   with a __builtin_memcmp_eq call where possible.\n+   return true when call is transformed, return false otherwise.  */\n+\n+static bool\n+handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n+{\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n+  tree res = gimple_call_lhs (stmt);\n+\n+  if (!res || !used_only_for_zero_equality (res))\n+    return false;\n+\n+  tree arg1 = gimple_call_arg (stmt, 0);\n+  tree arg2 = gimple_call_arg (stmt, 1);\n+  tree len = gimple_call_arg (stmt, 2);\n+  unsigned HOST_WIDE_INT leni;\n+\n   if (tree_fits_uhwi_p (len)\n       && (leni = tree_to_uhwi (len)) <= GET_MODE_SIZE (word_mode)\n       && pow2p_hwi (leni))\n@@ -3283,7 +3320,7 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n       if (int_mode_for_size (leni, 1).exists (&mode)\n \t  && (align >= leni || !targetm.slow_unaligned_access (mode, align)))\n \t{\n-\t  location_t loc = gimple_location (stmt2);\n+\t  location_t loc = gimple_location (stmt);\n \t  tree type, off;\n \t  type = build_nonstandard_integer_type (leni, 1);\n \t  gcc_assert (known_eq (GET_MODE_BITSIZE (TYPE_MODE (type)), leni));\n@@ -3307,78 +3344,10 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n \t}\n     }\n \n-  gimple_call_set_fndecl (stmt2, builtin_decl_explicit (BUILT_IN_MEMCMP_EQ));\n+  gimple_call_set_fndecl (stmt, builtin_decl_explicit (BUILT_IN_MEMCMP_EQ));\n   return true;\n }\n \n-/* If IDX1 and IDX2 refer to strings A and B of unequal lengths, return\n-   the result of 0 == strncmp (A, B, N) (which is the same as strcmp for\n-   sufficiently large N).  Otherwise return false.  */\n-\n-static bool\n-strxcmp_unequal (int idx1, int idx2, unsigned HOST_WIDE_INT n)\n-{\n-  unsigned HOST_WIDE_INT len1;\n-  unsigned HOST_WIDE_INT len2;\n-\n-  bool nulterm1;\n-  bool nulterm2;\n-\n-  if (idx1 < 0)\n-    {\n-      len1 = ~idx1;\n-      nulterm1 = true;\n-    }\n-  else if (strinfo *si = get_strinfo (idx1))\n-    {\n-      if (tree_fits_uhwi_p (si->nonzero_chars))\n-\t{\n-\t  len1 = tree_to_uhwi (si->nonzero_chars);\n-\t  nulterm1 = si->full_string_p;\n-\t}\n-      else\n-\treturn false;\n-    }\n-  else\n-    return false;\n-\n-  if (idx2 < 0)\n-    {\n-      len2 = ~idx2;\n-      nulterm2 = true;\n-    }\n-  else if (strinfo *si = get_strinfo (idx2))\n-    {\n-      if (tree_fits_uhwi_p (si->nonzero_chars))\n-\t{\n-\t  len2 = tree_to_uhwi (si->nonzero_chars);\n-\t  nulterm2 = si->full_string_p;\n-\t}\n-      else\n-\treturn false;\n-    }\n-  else\n-    return false;\n-\n-  /* N is set to UHWI_MAX for strcmp and less to strncmp.  Adjust\n-     the length of each string to consider to be no more than N.  */\n-  if (len1 > n)\n-    len1 = n;\n-  if (len2 > n)\n-    len2 = n;\n-\n-  if ((len1 < len2 && nulterm1)\n-      || (len2 < len1 && nulterm2))\n-    /* The string lengths are definitely unequal and the result can\n-       be folded to one (since it's used for comparison with zero).  */\n-    return true;\n-\n-  /* The string lengths may be equal or unequal.  Even when equal and\n-     both strings nul-terminated, without the string contents there's\n-     no way to determine whether they are equal.  */\n-  return false;\n-}\n-\n /* Given an index to the strinfo vector, compute the string length\n    for the corresponding string. Return -1 when unknown.  */\n \n@@ -3407,232 +3376,425 @@ compute_string_length (int idx)\n \n /* Determine the minimum size of the object referenced by DEST expression\n    which must have a pointer type.\n-   Return the minimum size of the object if successful or NULL when the size\n-   cannot be determined.  */\n-static tree\n+   Return the minimum size of the object if successful or HWI_M1U when\n+   the size cannot be determined.  */\n+\n+static unsigned HOST_WIDE_INT\n determine_min_objsize (tree dest)\n {\n   unsigned HOST_WIDE_INT size = 0;\n \n   if (compute_builtin_object_size (dest, 2, &size))\n-    return build_int_cst (sizetype, size);\n+    return size;\n \n   /* Try to determine the size of the object through the RHS\n      of the assign statement.  */\n   if (TREE_CODE (dest) == SSA_NAME)\n     {\n       gimple *stmt = SSA_NAME_DEF_STMT (dest);\n       if (!is_gimple_assign (stmt))\n-\treturn NULL_TREE;\n+\treturn HOST_WIDE_INT_M1U;\n \n       if (!gimple_assign_single_p (stmt)\n \t  && !gimple_assign_unary_nop_p (stmt))\n-\treturn NULL_TREE;\n+\treturn HOST_WIDE_INT_M1U;\n \n       dest = gimple_assign_rhs1 (stmt);\n       return determine_min_objsize (dest);\n     }\n \n   /* Try to determine the size of the object from its type.  */\n   if (TREE_CODE (dest) != ADDR_EXPR)\n-    return NULL_TREE;\n+    return HOST_WIDE_INT_M1U;\n \n   tree type = TREE_TYPE (dest);\n   if (TREE_CODE (type) == POINTER_TYPE)\n     type = TREE_TYPE (type);\n \n   type = TYPE_MAIN_VARIANT (type);\n \n-  /* We cannot determine the size of the array if it's a flexible array,\n-     which is declared at the end of a structure.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      && !array_at_struct_end_p (dest))\n+  /* The size of a flexible array cannot be determined.  Otherwise,\n+     for arrays with more than one element, return the size of its\n+     type.  GCC itself misuses arrays of both zero and one elements\n+     as flexible array members so they are excluded as well.  */\n+  if (TREE_CODE (type) != ARRAY_TYPE\n+      || !array_at_struct_end_p (dest))\n     {\n-      tree size_t = TYPE_SIZE_UNIT (type);\n-      if (size_t && TREE_CODE (size_t) == INTEGER_CST\n-\t  && !integer_zerop (size_t))\n-        return size_t;\n+      tree type_size = TYPE_SIZE_UNIT (type);\n+      if (type_size && TREE_CODE (type_size) == INTEGER_CST\n+\t  && !integer_onep (type_size)\n+\t  && !integer_zerop (type_size))\n+        return tree_to_uhwi (type_size);\n     }\n \n-  return NULL_TREE;\n+  return HOST_WIDE_INT_M1U;\n }\n \n-/* Handle a call to strcmp or strncmp. When the result is ONLY used to do\n-   equality test against zero:\n-\n-   A. When the lengths of both arguments are constant and it's a strcmp:\n-      * if the lengths are NOT equal, we can safely fold the call\n-        to a non-zero value.\n-      * otherwise, do nothing now.\n-\n-   B. When the length of one argument is constant, try to replace the call\n-   with a __builtin_str(n)cmp_eq call where possible, i.e:\n-\n-   strncmp (s, STR, C) (!)= 0 in which, s is a pointer to a string, STR\n-   is a string with constant length , C is a constant.\n-     if (C <= strlen(STR) && sizeof_array(s) > C)\n-       {\n-         replace this call with\n-         strncmp_eq (s, STR, C) (!)= 0\n-       }\n-     if (C > strlen(STR)\n-       {\n-         it can be safely treated as a call to strcmp (s, STR) (!)= 0\n-         can handled by the following strcmp.\n-       }\n-\n-   strcmp (s, STR) (!)= 0 in which, s is a pointer to a string, STR\n-   is a string with constant length.\n-     if  (sizeof_array(s) > strlen(STR))\n-       {\n-         replace this call with\n-         strcmp_eq (s, STR, strlen(STR)+1) (!)= 0\n-       }\n-\n-   Return true when the call is transformed, return false otherwise.\n- */\n+/* Given strinfo IDX for ARG, set LENRNG[] to the range of lengths\n+   of  the string(s) referenced by ARG if it can be determined.\n+   If the length cannot be determined, set *SIZE to the size of\n+   the array the string is stored in, if any.  If no such array is\n+   known, set *SIZE to -1.  When the strings are nul-terminated set\n+   *NULTERM to true, otherwise to false.  Return true on success.  */\n \n static bool\n-handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n+get_len_or_size (tree arg, int idx, unsigned HOST_WIDE_INT lenrng[2],\n+\t\t unsigned HOST_WIDE_INT *size, bool *nulterm)\n {\n-  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n-  tree res = gimple_call_lhs (stmt);\n-  use_operand_p use_p;\n-  imm_use_iterator iter;\n-  tree arg1 = gimple_call_arg (stmt, 0);\n-  tree arg2 = gimple_call_arg (stmt, 1);\n-  int idx1 = get_stridx (arg1);\n-  int idx2 = get_stridx (arg2);\n-  HOST_WIDE_INT length = -1;\n-  bool is_ncmp = false;\n+  /* Set so that both LEN and ~LEN are invalid lengths, i.e.,\n+     maximum possible length + 1.  */\n+  lenrng[0] = lenrng[1] = HOST_WIDE_INT_MAX;\n \n-  if (!res)\n-    return false;\n-\n-  /* When both arguments are unknown, do nothing.  */\n-  if (idx1 == 0 && idx2 == 0)\n-    return false;\n+  *size = HOST_WIDE_INT_M1U;\n \n-  /* Handle strncmp function.  */\n-  if (gimple_call_num_args (stmt) == 3)\n+  if (idx < 0)\n     {\n-      tree len = gimple_call_arg (stmt, 2);\n-      if (tree_fits_shwi_p (len))\n-        length = tree_to_shwi (len);\n-\n-      is_ncmp = true;\n+      /* IDX is the inverted constant string length.  */\n+      lenrng[0] = ~idx;\n+      lenrng[1] = lenrng[0];\n+      *nulterm = true;\n     }\n-\n-  /* For strncmp, if the length argument is NOT known, do nothing.  */\n-  if (is_ncmp && length < 0)\n-    return false;\n-\n-  /* When the result is ONLY used to do equality test against zero.  */\n-  FOR_EACH_IMM_USE_FAST (use_p, iter, res)\n+  else if (idx == 0)\n+    ; /* Handled below.  */\n+  else if (strinfo *si = get_strinfo (idx))\n     {\n-      gimple *use_stmt = USE_STMT (use_p);\n+      if (!si->nonzero_chars)\n+\targ = si->ptr;\n+      else if (tree_fits_uhwi_p (si->nonzero_chars))\n+\t{\n+\t  lenrng[0] = tree_to_uhwi (si->nonzero_chars);\n+\t  *nulterm = si->full_string_p;\n+\t  /* Set the upper bound only if the string is known to be\n+\t     nul-terminated, otherwise leave it at maximum + 1.  */\n+\t  if (*nulterm)\n+\t    lenrng[1] = lenrng[0];\n+\t}\n+      else if (TREE_CODE (si->nonzero_chars) == SSA_NAME)\n+\t{\n+\t  wide_int min, max;\n+\t  value_range_kind rng = get_range_info (si->nonzero_chars, &min, &max);\n+\t  if (rng == VR_RANGE)\n+\t    {\n+\t      lenrng[0] = min.to_uhwi ();\n+\t      lenrng[1] = max.to_uhwi ();\n+\t      *nulterm = si->full_string_p;\n+\t    }\n+\t}\n+      else if (si->ptr)\n+\targ = si->ptr;\n+    }\n \n-      if (is_gimple_debug (use_stmt))\n-        continue;\n-      if (gimple_code (use_stmt) == GIMPLE_ASSIGN)\n+  if (lenrng[0] == HOST_WIDE_INT_MAX)\n+    {\n+      /* Compute the minimum and maximum real or possible lengths.  */\n+      c_strlen_data lendata = { };\n+      if (get_range_strlen (arg, &lendata, /* eltsize = */1))\n \t{\n-\t  tree_code code = gimple_assign_rhs_code (use_stmt);\n-\t  if (code == COND_EXPR)\n+\t  if (tree_fits_shwi_p (lendata.maxlen) && !lendata.maxbound)\n \t    {\n-\t      tree cond_expr = gimple_assign_rhs1 (use_stmt);\n-\t      if ((TREE_CODE (cond_expr) != EQ_EXPR\n-\t\t   && (TREE_CODE (cond_expr) != NE_EXPR))\n-\t\t  || !integer_zerop (TREE_OPERAND (cond_expr, 1)))\n-\t\treturn false;\n+\t      lenrng[0] = tree_to_shwi (lendata.minlen);\n+\t      lenrng[1] = tree_to_shwi (lendata.maxlen);\n+\t      *nulterm = true;\n \t    }\n-\t  else if (code == EQ_EXPR || code == NE_EXPR)\n+\t  else if (lendata.maxbound && tree_fits_shwi_p (lendata.maxbound))\n \t    {\n-\t      if (!integer_zerop (gimple_assign_rhs2 (use_stmt)))\n-\t\treturn false;\n-            }\n-\t  else\n-\t    return false;\n+\t      /* Set *SIZE to the conservative LENDATA.MAXBOUND which\n+\t\t is a conservative estimate of the longest string based\n+\t\t on the sizes of the arrays referenced by ARG.  */\n+\t      *size = tree_to_uhwi (lendata.maxbound) + 1;\n+\t      *nulterm = false;\n+\t    }\n \t}\n-      else if (gimple_code (use_stmt) == GIMPLE_COND)\n+      else\n \t{\n-\t  tree_code code = gimple_cond_code (use_stmt);\n-\t  if ((code != EQ_EXPR && code != NE_EXPR)\n-\t      || !integer_zerop (gimple_cond_rhs (use_stmt)))\n-\t    return false;\n+\t  /* Set *SIZE to the size of the smallest object referenced\n+\t     by ARG if ARG denotes a single object, or to HWI_M1U\n+\t     otherwise.  */\n+\t  *size = determine_min_objsize (arg);\n+\t  *nulterm = false;\n \t}\n-      else\n-        return false;\n     }\n \n-  /* When the lengths of the arguments are known to be unequal\n-     we can safely fold the call to a non-zero value for strcmp;\n-     otherwise, do nothing now.  */\n-  if (idx1 != 0 && idx2 != 0)\n-    {\n-      if (strxcmp_unequal (idx1, idx2, length))\n-\t{\n-\t  replace_call_with_value (gsi, integer_one_node);\n-\t  return true;\n-\t}\n-      return false;\n+  return lenrng[0] != HOST_WIDE_INT_MAX || *size != HOST_WIDE_INT_M1U;\n+}\n+\n+/* If IDX1 and IDX2 refer to strings A and B of unequal lengths, return\n+   the result of 0 == strncmp (A, B, BOUND) (which is the same as strcmp\n+   for a sufficiently large BOUND).  If the result is based on the length\n+   of one string being greater than the longest string that would fit in\n+   the array pointer to by the argument, set *PLEN and *PSIZE to\n+   the corresponding length (or its complement when the string is known\n+   to be at least as long and need not be nul-terminated) and size.\n+   Otherwise return null.  */\n+\n+static tree\n+strxcmp_eqz_result (tree arg1, int idx1, tree arg2, int idx2,\n+\t\t    unsigned HOST_WIDE_INT bound, unsigned HOST_WIDE_INT len[2],\n+\t\t    unsigned HOST_WIDE_INT *psize)\n+{\n+  /* Determine the range the length of each string is in and whether it's\n+     known to be nul-terminated, or the size of the array it's stored in.  */\n+  bool nul1, nul2;\n+  unsigned HOST_WIDE_INT siz1, siz2;\n+  unsigned HOST_WIDE_INT len1rng[2], len2rng[2];\n+  if (!get_len_or_size (arg1, idx1, len1rng, &siz1, &nul1)\n+      || !get_len_or_size (arg2, idx2, len2rng, &siz2, &nul2))\n+    return NULL_TREE;\n+\n+  /* BOUND is set to HWI_M1U for strcmp and less to strncmp, and LENiRNG\n+     to HWI_MAX when invalid.  Adjust the length of each string to consider\n+     to be no more than BOUND.  */\n+  if (len1rng[0] < HOST_WIDE_INT_MAX && len1rng[0] > bound)\n+    len1rng[0] = bound;\n+  if (len1rng[1] < HOST_WIDE_INT_MAX && len1rng[1] > bound)\n+    len1rng[1] = bound;\n+  if (len2rng[0] < HOST_WIDE_INT_MAX && len2rng[0] > bound)\n+    len2rng[0] = bound;\n+  if (len2rng[1] < HOST_WIDE_INT_MAX && len2rng[1] > bound)\n+    len2rng[1] = bound;\n+\n+  /* Two empty strings are equal.  */\n+  if (len1rng[1] == 0 && len2rng[1] == 0)\n+    return integer_one_node;\n+\n+  /* The strings are definitely unequal when the lower bound of the length\n+     of one of them is greater than the length of the longest string that\n+     would fit into the other array.  */\n+  if (len1rng[0] == HOST_WIDE_INT_MAX\n+      && len2rng[0] != HOST_WIDE_INT_MAX\n+      && ((len2rng[0] < bound && len2rng[0] >= siz1)\n+\t  || len2rng[0] > siz1))\n+    {\n+      *psize = siz1;\n+      len[0] = len1rng[0];\n+      /* Set LEN[0] to the lower bound of ARG1's length when it's\n+\t nul-terminated or to the complement of its minimum length\n+\t otherwise,  */\n+      len[1] = nul2 ? len2rng[0] : ~len2rng[0];\n+      return integer_zero_node;\n+    }\n+\n+  if (len2rng[0] == HOST_WIDE_INT_MAX\n+      && len1rng[0] != HOST_WIDE_INT_MAX\n+      && ((len1rng[0] < bound && len1rng[0] >= siz2)\n+\t  || len1rng[0] > siz2))\n+    {\n+      *psize = siz2;\n+      len[0] = nul1 ? len1rng[0] : ~len1rng[0];\n+      len[1] = len2rng[0];\n+      return integer_zero_node;\n+    }\n+\n+  /* The strings are also definitely unequal when their lengths are unequal\n+     and at least one is nul-terminated.  */\n+  if (len1rng[0] != HOST_WIDE_INT_MAX\n+      && len2rng[0] != HOST_WIDE_INT_MAX\n+      && ((len1rng[1] < len2rng[0] && nul1)\n+\t  || (len2rng[1] < len1rng[0] && nul2)))\n+    {\n+      if (bound <= len1rng[0] || bound <= len2rng[0])\n+\t*psize = bound;\n+      else\n+\t*psize = HOST_WIDE_INT_M1U;\n+\n+      len[0] = len1rng[0];\n+      len[1] = len2rng[0];\n+      return integer_zero_node;\n     }\n \n-  /* When the length of one argument is constant.  */\n-  tree var_string = NULL_TREE;\n-  HOST_WIDE_INT const_string_leni = -1;\n+  /* The string lengths may be equal or unequal.  Even when equal and\n+     both strings nul-terminated, without the string contents there's\n+     no way to determine whether they are equal.  */\n+  return NULL_TREE;\n+}\n+\n+/* Diagnose pointless calls to strcmp or strncmp STMT with string\n+   arguments of lengths LEN or size SIZ and (for strncmp) BOUND,\n+   whose result is used in equality expressions that evaluate to\n+   a constant due to one argument being longer than the size of\n+   the other.  */\n \n-  if (idx1)\n+static void\n+maybe_warn_pointless_strcmp (gimple *stmt, HOST_WIDE_INT bound,\n+\t\t\t     unsigned HOST_WIDE_INT len[2],\n+\t\t\t     unsigned HOST_WIDE_INT siz)\n+{\n+  gimple *use = used_only_for_zero_equality (gimple_call_lhs (stmt));\n+  if (!use)\n+    return;\n+\n+  bool at_least = false;\n+\n+  /* Excessive LEN[i] indicates a lower bound.  */\n+  if (len[0] > HOST_WIDE_INT_MAX)\n     {\n-      const_string_leni = compute_string_length (idx1);\n-      var_string = arg2;\n+      at_least = true;\n+      len[0] = ~len[0];\n     }\n-  else\n+\n+  if (len[1] > HOST_WIDE_INT_MAX)\n     {\n-      gcc_checking_assert (idx2);\n-      const_string_leni = compute_string_length (idx2);\n-      var_string = arg1;\n+      at_least = true;\n+      len[1] = ~len[1];\n     }\n \n-  if (const_string_leni < 0)\n-    return false;\n+  unsigned HOST_WIDE_INT minlen = MIN (len[0], len[1]);\n \n-  unsigned HOST_WIDE_INT var_sizei = 0;\n-  /* try to determine the minimum size of the object pointed by var_string.  */\n-  tree size = determine_min_objsize (var_string);\n+  /* FIXME: Include a note pointing to the declaration of the smaller\n+     array.  */\n+  location_t stmt_loc = gimple_location (stmt);\n+  tree callee = gimple_call_fndecl (stmt);\n+  bool warned = false;\n+  if (siz <= minlen && bound == -1)\n+    warned = warning_at (stmt_loc, OPT_Wstring_compare,\n+\t\t\t (at_least\n+\t\t\t  ? G_(\"%G%qD of a string of length %wu or more and \"\n+\t\t\t       \"an array of size %wu evaluates to nonzero\")\n+\t\t\t  : G_(\"%G%qD of a string of length %wu and an array \"\n+\t\t\t       \"of size %wu evaluates to nonzero\")),\n+\t\t\t stmt, callee, minlen, siz);\n+  else if (!at_least && siz <= HOST_WIDE_INT_MAX)\n+    {\n+      if (len[0] != HOST_WIDE_INT_MAX && len[1] != HOST_WIDE_INT_MAX)\n+\twarned = warning_at (stmt_loc, OPT_Wstring_compare,\n+\t\t\t     \"%G%qD of strings of length %wu and %wu \"\n+\t\t\t     \"and bound of %wu evaluates to nonzero\",\n+\t\t\t     stmt, callee, len[0], len[1], bound);\n+      else\n+\twarned = warning_at (stmt_loc, OPT_Wstring_compare,\n+\t\t\t     \"%G%qD of a string of length %wu, an array \"\n+\t\t\t     \"of size %wu and bound of %wu evaluates to \"\n+\t\t\t     \"nonzero\",\n+\t\t\t     stmt, callee, minlen, siz, bound);\n+    }\n+\n+  if (warned)\n+    {\n+      location_t use_loc = gimple_location (use);\n+      if (LOCATION_LINE (stmt_loc) != LOCATION_LINE (use_loc))\n+\tinform (use_loc, \"in this expression\");\n+    }\n+}\n \n-  if (!size)\n-    return false;\n \n-  if (tree_fits_uhwi_p (size))\n-    var_sizei = tree_to_uhwi (size);\n+/* Optimize a call to strcmp or strncmp either by folding it to a constant\n+   when possible or by transforming the latter to the former.  Warn about\n+   calls where the length of one argument is greater than the size of\n+   the array to which the other argument points if the latter's length\n+   is not known.  Return true when the call has been transformed into\n+   another and false otherwise.  */\n+\n+static bool\n+handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n+{\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n+  tree lhs = gimple_call_lhs (stmt);\n \n-  if (var_sizei == 0)\n+  if (!lhs)\n     return false;\n \n-  /* For strncmp, if length > const_string_leni , this call can be safely\n-     transformed to a strcmp.  */\n-  if (is_ncmp && length > const_string_leni)\n-    is_ncmp = false;\n+  tree arg1 = gimple_call_arg (stmt, 0);\n+  tree arg2 = gimple_call_arg (stmt, 1);\n+  int idx1 = get_stridx (arg1);\n+  int idx2 = get_stridx (arg2);\n \n-  unsigned HOST_WIDE_INT final_length\n-    = is_ncmp ? length : const_string_leni + 1;\n+  /* For strncmp set to the the value of the third argument if known.  */\n+  HOST_WIDE_INT bound = -1;\n \n-  /* Replace strcmp or strncmp with the corresponding str(n)cmp_eq.  */\n-  if (var_sizei > final_length)\n+  /* Extract the strncmp bound.  */\n+  if (gimple_call_num_args (stmt) == 3)\n     {\n-      tree fn\n-\t= (is_ncmp\n-\t   ? builtin_decl_implicit (BUILT_IN_STRNCMP_EQ)\n-\t   : builtin_decl_implicit (BUILT_IN_STRCMP_EQ));\n-      if (!fn)\n+      tree len = gimple_call_arg (stmt, 2);\n+      if (tree_fits_shwi_p (len))\n+        bound = tree_to_shwi (len);\n+\n+      /* If the bound argument is NOT known, do nothing.  */\n+      if (bound < 0)\n \treturn false;\n-      tree const_string_len = build_int_cst (size_type_node, final_length);\n-      update_gimple_call (gsi, fn, 3, arg1, arg2, const_string_len);\n     }\n+\n+  {\n+    /* Set to the length of one argument (or its complement if it's\n+       the lower bound of a range) and the size of the array storing\n+       the other if the result is based on the former being equal to\n+       or greater than the latter.  */\n+    unsigned HOST_WIDE_INT len[2] = { HOST_WIDE_INT_MAX, HOST_WIDE_INT_MAX };\n+    unsigned HOST_WIDE_INT siz = HOST_WIDE_INT_M1U;\n+\n+    /* Try to determine if the two strings are either definitely equal\n+       or definitely unequal and if so, either fold the result to zero\n+       (when equal) or set the range of the result to ~[0, 0] otherwise.  */\n+    if (tree eqz = strxcmp_eqz_result (arg1, idx1, arg2, idx2, bound,\n+\t\t\t\t       len, &siz))\n+      {\n+\tif (integer_zerop (eqz))\n+\t  {\n+\t    maybe_warn_pointless_strcmp (stmt, bound, len, siz);\n+\n+\t    /* When the lengths of the first two string arguments are\n+\t       known to be unequal set the range of the result to non-zero.\n+\t       This allows the call to be eliminated if its result is only\n+\t       used in tests for equality to zero.  */\n+\t    wide_int zero = wi::zero (TYPE_PRECISION (TREE_TYPE (lhs)));\n+\t    set_range_info (lhs, VR_ANTI_RANGE, zero, zero);\n+\t    return false;\n+\t  }\n+\t/* When the two strings are definitely equal (such as when they\n+\t   are both empty) fold the call to the constant result.  */\n+\treplace_call_with_value (gsi, integer_zero_node);\n+\treturn true;\n+      }\n+  }\n+\n+  /* Return if nothing is known about the strings pointed to by ARG1\n+     and ARG2.  */\n+  if (idx1 == 0 && idx2 == 0)\n+    return false;\n+\n+  /* Determine either the length or the size of each of the strings,\n+     whichever is available.  */\n+  HOST_WIDE_INT cstlen1 = -1, cstlen2 = -1;\n+  HOST_WIDE_INT arysiz1 = -1, arysiz2 = -1;\n+\n+  if (idx1)\n+    cstlen1 = compute_string_length (idx1) + 1;\n   else\n+    arysiz1 = determine_min_objsize (arg1);\n+\n+  /* Bail if neither the string length nor the size of the array\n+     it is stored in can be determined.  */\n+  if (cstlen1 < 0 && arysiz1 < 0)\n     return false;\n \n-  return true;\n+  /* Repeat for the second argument.  */\n+  if (idx2)\n+    cstlen2 = compute_string_length (idx2) + 1;\n+  else\n+    arysiz2 = determine_min_objsize (arg2);\n+\n+  if (cstlen2 < 0 && arysiz2 < 0)\n+    return false;\n+\n+  /* The exact number of characters to compare.  */\n+  HOST_WIDE_INT cmpsiz = bound < 0 ? cstlen1 < 0 ? cstlen2 : cstlen1 : bound;\n+  /* The size of the array in which the unknown string is stored.  */\n+  HOST_WIDE_INT varsiz = arysiz1 < 0 ? arysiz2 : arysiz1;\n+\n+  if (cmpsiz < varsiz && used_only_for_zero_equality (lhs))\n+    {\n+      /* If the known length is less than the size of the other array\n+\t and the strcmp result is only used to test equality to zero,\n+\t transform the call to the equivalent _eq call.  */\n+      if (tree fn = builtin_decl_implicit (bound < 0 ? BUILT_IN_STRCMP_EQ\n+\t\t\t\t\t   : BUILT_IN_STRNCMP_EQ))\n+\t{\n+\t  tree n = build_int_cst (size_type_node, cmpsiz);\n+\t  update_gimple_call (gsi, fn, 3, arg1, arg2, n);\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n }\n \n /* Handle a POINTER_PLUS_EXPR statement."}]}