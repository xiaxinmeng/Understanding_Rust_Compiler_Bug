{"sha": "f83e63a89a030fce62c8de56b3c1e61cec77ef52", "node_id": "C_kwDOANBUbNoAKGY4M2U2M2E4OWEwMzBmY2U2MmM4ZGU1NmIzYzFlNjFjZWM3N2VmNTI", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-04-04T14:49:20Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-04-05T09:24:55Z"}, "message": "gccrs: refactor resolve_method_address to be inside base class\n\ngcc/rust/ChangeLog:\n\n\t* backend/rust-compile-base.cc (HIRCompileBase::resolve_method_address): moved here\n\t* backend/rust-compile-base.h: refactored prototype\n\t* backend/rust-compile-expr.cc (CompileExpr::resolve_method_address): refactor\n\t* backend/rust-compile-expr.h: likewise\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "57a9fb7ca2c5cd967d86c78680788a96067ff8b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57a9fb7ca2c5cd967d86c78680788a96067ff8b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f83e63a89a030fce62c8de56b3c1e61cec77ef52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f83e63a89a030fce62c8de56b3c1e61cec77ef52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f83e63a89a030fce62c8de56b3c1e61cec77ef52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f83e63a89a030fce62c8de56b3c1e61cec77ef52/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4713107dffad79ac0c7863411928b536f90f768a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4713107dffad79ac0c7863411928b536f90f768a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4713107dffad79ac0c7863411928b536f90f768a"}], "stats": {"total": 182, "additions": 91, "deletions": 91}, "files": [{"sha": "9650d1a47ee6fedac30c46b1af93455bf12878ce", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83e63a89a030fce62c8de56b3c1e61cec77ef52/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83e63a89a030fce62c8de56b3c1e61cec77ef52/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=f83e63a89a030fce62c8de56b3c1e61cec77ef52", "patch": "@@ -27,6 +27,9 @@\n #include \"rust-diagnostics.h\"\n #include \"rust-expr.h\"\t// for AST::AttrInputLiteral\n #include \"rust-macro.h\" // for AST::MetaNameValueStr\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-type-util.h\"\n+#include \"rust-compile-implitem.h\"\n \n #include \"fold-const.h\"\n #include \"stringpool.h\"\n@@ -739,5 +742,87 @@ HIRCompileBase::named_constant_expression (tree type_tree,\n   return decl;\n }\n \n+tree\n+HIRCompileBase::resolve_method_address (\n+  TyTy::FnType *fntype, HirId ref, TyTy::BaseType *receiver,\n+  const HIR::PathIdentSegment &segment,\n+  const Analysis::NodeMapping &expr_mappings, Location expr_locus)\n+{\n+  // Now we can try and resolve the address since this might be a forward\n+  // declared function, generic function which has not be compiled yet or\n+  // its an not yet trait bound function\n+  HIR::ImplItem *resolved_item\n+    = ctx->get_mappings ()->lookup_hir_implitem (ref, nullptr);\n+  if (resolved_item != nullptr)\n+    {\n+      if (!fntype->has_subsititions_defined ())\n+\treturn CompileInherentImplItem::Compile (resolved_item, ctx);\n+\n+      return CompileInherentImplItem::Compile (resolved_item, ctx, fntype);\n+    }\n+\n+  // it might be resolved to a trait item\n+  HIR::TraitItem *trait_item\n+    = ctx->get_mappings ()->lookup_hir_trait_item (ref);\n+  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n+    trait_item->get_mappings ().get_hirid ());\n+\n+  Resolver::TraitReference *trait_ref\n+    = &Resolver::TraitReference::error_node ();\n+  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n+    trait->get_mappings ().get_defid (), &trait_ref);\n+  rust_assert (ok);\n+\n+  // the type resolver can only resolve type bounds to their trait\n+  // item so its up to us to figure out if this path should resolve\n+  // to an trait-impl-block-item or if it can be defaulted to the\n+  // trait-impl-item's definition\n+\n+  auto root = receiver->get_root ();\n+  auto candidates\n+    = Resolver::PathProbeImplTrait::Probe (root, segment, trait_ref);\n+  if (candidates.size () == 0)\n+    {\n+      // this means we are defaulting back to the trait_item if\n+      // possible\n+      Resolver::TraitItemReference *trait_item_ref = nullptr;\n+      bool ok = trait_ref->lookup_hir_trait_item (*trait_item, &trait_item_ref);\n+      rust_assert (ok);\t\t\t\t    // found\n+      rust_assert (trait_item_ref->is_optional ()); // has definition\n+\n+      // FIXME Optional means it has a definition and an associated\n+      // block which can be a default implementation, if it does not\n+      // contain an implementation we should actually return\n+      // error_mark_node\n+\n+      return CompileTraitItem::Compile (trait_item_ref->get_hir_trait_item (),\n+\t\t\t\t\tctx, fntype, true, expr_locus);\n+    }\n+\n+  // FIXME this will be a case to return error_mark_node, there is\n+  // an error scenario where a Trait Foo has a method Bar, but this\n+  // receiver does not implement this trait or has an incompatible\n+  // implementation and we should just return error_mark_node\n+\n+  rust_assert (candidates.size () == 1);\n+  auto &candidate = *candidates.begin ();\n+  rust_assert (candidate.is_impl_candidate ());\n+  rust_assert (candidate.ty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *candidate_call = static_cast<TyTy::FnType *> (candidate.ty);\n+  HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n+\n+  TyTy::BaseType *monomorphized = candidate_call;\n+  if (candidate_call->needs_generic_substitutions ())\n+    {\n+      TyTy::BaseType *infer_impl_call\n+\t= candidate_call->infer_substitions (expr_locus);\n+      monomorphized\n+\t= Resolver::unify_site (ref, TyTy::TyWithLocation (infer_impl_call),\n+\t\t\t\tTyTy::TyWithLocation (fntype), expr_locus);\n+    }\n+\n+  return CompileInherentImplItem::Compile (impl_item, ctx, monomorphized);\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "d276ec3cbd14b719eb38e84661df0ae81f40b86c", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83e63a89a030fce62c8de56b3c1e61cec77ef52/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83e63a89a030fce62c8de56b3c1e61cec77ef52/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=f83e63a89a030fce62c8de56b3c1e61cec77ef52", "patch": "@@ -80,6 +80,12 @@ class HIRCompileBase\n   tree resolve_unsized_dyn_adjustment (Resolver::Adjustment &adjustment,\n \t\t\t\t       tree expression, Location locus);\n \n+  tree resolve_method_address (TyTy::FnType *fntype, HirId ref,\n+\t\t\t       TyTy::BaseType *receiver,\n+\t\t\t       const HIR::PathIdentSegment &segment,\n+\t\t\t       const Analysis::NodeMapping &expr_mappings,\n+\t\t\t       Location expr_locus);\n+\n   static void setup_fndecl (tree fndecl, bool is_main_entry_point,\n \t\t\t    bool is_generic_fn, HIR::Visibility &visibility,\n \t\t\t    const HIR::FunctionQualifiers &qualifiers,"}, {"sha": "7a04e2b8e428751ccf5052e76004ff90e645ba32", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83e63a89a030fce62c8de56b3c1e61cec77ef52/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83e63a89a030fce62c8de56b3c1e61cec77ef52/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=f83e63a89a030fce62c8de56b3c1e61cec77ef52", "patch": "@@ -18,13 +18,11 @@\n \n #include \"rust-compile-expr.h\"\n #include \"rust-compile-struct-field-expr.h\"\n-#include \"rust-hir-path-probe.h\"\n #include \"rust-compile-pattern.h\"\n #include \"rust-compile-resolve-path.h\"\n #include \"rust-compile-block.h\"\n #include \"rust-compile-implitem.h\"\n #include \"rust-constexpr.h\"\n-#include \"rust-type-util.h\"\n #include \"rust-compile-type.h\"\n #include \"rust-gcc.h\"\n \n@@ -1880,89 +1878,6 @@ CompileExpr::get_receiver_from_dyn (const TyTy::DynamicObjectType *dyn,\n \t\t\t\t\t\t       expr_locus);\n }\n \n-tree\n-CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n-\t\t\t\t     TyTy::BaseType *receiver,\n-\t\t\t\t     HIR::PathIdentSegment &segment,\n-\t\t\t\t     Analysis::NodeMapping expr_mappings,\n-\t\t\t\t     Location expr_locus)\n-{\n-  // Now we can try and resolve the address since this might be a forward\n-  // declared function, generic function which has not be compiled yet or\n-  // its an not yet trait bound function\n-  HIR::ImplItem *resolved_item\n-    = ctx->get_mappings ()->lookup_hir_implitem (ref, nullptr);\n-  if (resolved_item != nullptr)\n-    {\n-      if (!fntype->has_subsititions_defined ())\n-\treturn CompileInherentImplItem::Compile (resolved_item, ctx);\n-\n-      return CompileInherentImplItem::Compile (resolved_item, ctx, fntype);\n-    }\n-\n-  // it might be resolved to a trait item\n-  HIR::TraitItem *trait_item\n-    = ctx->get_mappings ()->lookup_hir_trait_item (ref);\n-  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n-    trait_item->get_mappings ().get_hirid ());\n-\n-  Resolver::TraitReference *trait_ref\n-    = &Resolver::TraitReference::error_node ();\n-  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n-    trait->get_mappings ().get_defid (), &trait_ref);\n-  rust_assert (ok);\n-\n-  // the type resolver can only resolve type bounds to their trait\n-  // item so its up to us to figure out if this path should resolve\n-  // to an trait-impl-block-item or if it can be defaulted to the\n-  // trait-impl-item's definition\n-\n-  auto root = receiver->get_root ();\n-  auto candidates\n-    = Resolver::PathProbeImplTrait::Probe (root, segment, trait_ref);\n-  if (candidates.size () == 0)\n-    {\n-      // this means we are defaulting back to the trait_item if\n-      // possible\n-      Resolver::TraitItemReference *trait_item_ref = nullptr;\n-      bool ok = trait_ref->lookup_hir_trait_item (*trait_item, &trait_item_ref);\n-      rust_assert (ok);\t\t\t\t    // found\n-      rust_assert (trait_item_ref->is_optional ()); // has definition\n-\n-      // FIXME Optional means it has a definition and an associated\n-      // block which can be a default implementation, if it does not\n-      // contain an implementation we should actually return\n-      // error_mark_node\n-\n-      return CompileTraitItem::Compile (trait_item_ref->get_hir_trait_item (),\n-\t\t\t\t\tctx, fntype, true, expr_locus);\n-    }\n-\n-  // FIXME this will be a case to return error_mark_node, there is\n-  // an error scenario where a Trait Foo has a method Bar, but this\n-  // receiver does not implement this trait or has an incompatible\n-  // implementation and we should just return error_mark_node\n-\n-  rust_assert (candidates.size () == 1);\n-  auto &candidate = *candidates.begin ();\n-  rust_assert (candidate.is_impl_candidate ());\n-  rust_assert (candidate.ty->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::FnType *candidate_call = static_cast<TyTy::FnType *> (candidate.ty);\n-  HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n-\n-  TyTy::BaseType *monomorphized = candidate_call;\n-  if (candidate_call->needs_generic_substitutions ())\n-    {\n-      TyTy::BaseType *infer_impl_call\n-\t= candidate_call->infer_substitions (expr_locus);\n-      monomorphized\n-\t= Resolver::unify_site (ref, TyTy::TyWithLocation (infer_impl_call),\n-\t\t\t\tTyTy::TyWithLocation (fntype), expr_locus);\n-    }\n-\n-  return CompileInherentImplItem::Compile (impl_item, ctx, monomorphized);\n-}\n-\n tree\n CompileExpr::resolve_operator_overload (\n   Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExprMeta expr,"}, {"sha": "0962652f9a2e37538f06a8107f624e5bec029bec", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f83e63a89a030fce62c8de56b3c1e61cec77ef52/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f83e63a89a030fce62c8de56b3c1e61cec77ef52/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=f83e63a89a030fce62c8de56b3c1e61cec77ef52", "patch": "@@ -97,12 +97,6 @@ class CompileExpr : private HIRCompileBase, protected HIR::HIRExpressionVisitor\n \t\t\t      TyTy::BaseType *receiver, TyTy::FnType *fntype,\n \t\t\t      tree receiver_ref, Location expr_locus);\n \n-  tree resolve_method_address (TyTy::FnType *fntype, HirId ref,\n-\t\t\t       TyTy::BaseType *receiver,\n-\t\t\t       HIR::PathIdentSegment &segment,\n-\t\t\t       Analysis::NodeMapping expr_mappings,\n-\t\t\t       Location expr_locus);\n-\n   tree\n   resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n \t\t\t     HIR::OperatorExprMeta expr, tree lhs, tree rhs,"}]}