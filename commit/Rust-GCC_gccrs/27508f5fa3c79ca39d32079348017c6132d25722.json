{"sha": "27508f5fa3c79ca39d32079348017c6132d25722", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc1MDhmNWZhM2M3OWNhMzlkMzIwNzkzNDgwMTdjNjEzMmQyNTcyMg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2011-12-05T17:02:54Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2011-12-05T17:02:54Z"}, "message": "re PR other/50775 (Register allocator sets up frame and frame pointer with low register pressure)\n\n2011-12-05  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR other/50775\n\t* ira-int.h (struct ira_object): Remove add_data.\n\t(OBJECT_ADD_DATA): Remove.\n\n\t* ira-build.c (ira_create_object): Remove OBJECT_ADD_DATA\n\tinitialization.\n\n\t* ira-color.c (object_hard_regs_t, object_hard_regs): Rename to\n\tallocno_hard_regs_t, allocno_hard_regs.\n\t(object_hard_regs_node_t, object_hard_regs_node): Rename to\n\tallocno_hard_regs_node_t and allocno_hard_regs_node.\n\t(struct allocno_color_data): Add new member last_process.  Move\n\tprofitable_hard_regs, hard_regs_node, and hard_regs_subnodes_start\n\tfrom object_color_data.\n\t(object_color_data_t, object_color_data, OBJECT_COLOR_DATA):\n\tRemove.\n\t(curr_allocno_process): New static variable.\n\t(object_hard_regs_eq, object_hard_regs_htab): Rename to\n\tallocno_hard_regs_eq and allocno_hard_regs_htab.\n\t(init_object_hard_regs, finish_object_hard_regs): Rename to\n\tinit_allocno_hard_regs and finish_allocno_hard_regs.\n\t(object_hard_regs_compare, object_hard_regs_node_t): Rename to\n\tallocno_hard_regs_compare and allocno_hard_regs_node_t.\n\t(create_new_object_hard_regs_node): Rename to\n\tcreate_new_allocno_hard_regs_node.\n\t(add_new_object_hard_regs_node_to_forest): Rename to\n\tadd_new_allocno_hard_regs_node_to_forest.\n\t(add_object_hard_regs_to_forest, collect_object_hard_regs_cover):\n\tRename to add_allocno_hard_regs_to_forest and collect_allocno_hard_regs_cover.\n\t(setup_object_hard_regs_nodes_parent): Rename to setup_allocno_hard_regs_nodes_parent.\n\t(remove_unused_object_hard_regs_nodes): Rename to remove_unused_allocno_hard_regs_nodes.\n\t(enumerate_object_hard_regs_nodes, object_hard_regs_nodes_num):\n\tRename to enumerate_allocno_hard_regs_nodes and allocno_hard_regs_nodes_num.\n\t(object_hard_regs_nodes, object_hard_regs_subnode_t): Rename to\n\tallocno_hard_regs_nodes and allocno_hard_regs_subnode_t.\n\t(object_hard_regs_subnode, object_hard_regs_subnodes): Rename to\n\tallocno_hard_regs_subnode and allocno_hard_regs_subnodes.\n\t(object_hard_regs_subnode_index): Rename to allocno_hard_regs_subnode_index.\n\t(setup_object_hard_regs_subnode_index): Rename to\n\tsetup_allocno_hard_regs_subnode_index.\n\t(get_object_hard_regs_subnodes_num): Rename to get_allocno_hard_regs_subnodes_num.\n\t(form_object_hard_regs_nodes_forest): Rename to form_allocno_hard_regs_nodes_forest.\n\t(finish_object_hard_regs_nodes_tree): Rename to form_allocno_hard_regs_nodes_forest\n\t(finish_object_hard_regs_nodes_forest): Rename to\n\tfinish_allocno_hard_regs_nodes_forest.\n\t(setup_left_conflict_sizes_p): Use allocno data instead of object\n\tones.  Process conflict allocnos once.\n\t(update_left_conflict_sizes_p): Use allocno data instead of object\n\tones.  Change prototype signature.\n\t(empty_profitable_hard_regs): Use allocno data instead of object\n\tones.\n\t(setup_profitable_hard_regs): Ditto.\n\t(get_conflict_profitable_regs): Rename to\n\tget_conflict_and_start_profitable_regs.  Use allocno data for\n\tprofitable regs calculation.\n\t(check_hard_reg_p): Change prototype signature.  Check profitable\n\tregs for allocno not the objects.\n\t(assign_hard_reg): Process conflict allocnos only once for\n\tupdating conflict costs.\n\t(setup_allocno_available_regs_num): Use allocno data instead of\n\tobject ones.  Modify debug output.\n\t(color_pass): Remove initialization and finalization of object\n\tcolor data.\n\nFrom-SVN: r182015", "tree": {"sha": "ac97eb31c03d69f989850d75019d61a7531b8133", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac97eb31c03d69f989850d75019d61a7531b8133"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27508f5fa3c79ca39d32079348017c6132d25722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27508f5fa3c79ca39d32079348017c6132d25722", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27508f5fa3c79ca39d32079348017c6132d25722", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27508f5fa3c79ca39d32079348017c6132d25722/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "100ed614f49dc076ce55c695398a0aa41bbd9b75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/100ed614f49dc076ce55c695398a0aa41bbd9b75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/100ed614f49dc076ce55c695398a0aa41bbd9b75"}], "stats": {"total": 1097, "additions": 534, "deletions": 563}, "files": [{"sha": "3a21b74c541bf32649335bb70868d5c4040a036b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27508f5fa3c79ca39d32079348017c6132d25722/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27508f5fa3c79ca39d32079348017c6132d25722/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27508f5fa3c79ca39d32079348017c6132d25722", "patch": "@@ -1,3 +1,69 @@\n+2011-12-05  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR other/50775\n+\t* ira-int.h (struct ira_object): Remove add_data.\n+\t(OBJECT_ADD_DATA): Remove.\n+\n+\t* ira-build.c (ira_create_object): Remove OBJECT_ADD_DATA\n+\tinitialization.\n+\n+\t* ira-color.c (object_hard_regs_t, object_hard_regs): Rename to\n+\tallocno_hard_regs_t, allocno_hard_regs.\n+\t(object_hard_regs_node_t, object_hard_regs_node): Rename to\n+\tallocno_hard_regs_node_t and allocno_hard_regs_node.\n+\t(struct allocno_color_data): Add new member last_process.  Move\n+\tprofitable_hard_regs, hard_regs_node, and hard_regs_subnodes_start\n+\tfrom object_color_data.\n+\t(object_color_data_t, object_color_data, OBJECT_COLOR_DATA):\n+\tRemove.\n+\t(curr_allocno_process): New static variable.\n+\t(object_hard_regs_eq, object_hard_regs_htab): Rename to\n+\tallocno_hard_regs_eq and allocno_hard_regs_htab.\n+\t(init_object_hard_regs, finish_object_hard_regs): Rename to\n+\tinit_allocno_hard_regs and finish_allocno_hard_regs.\n+\t(object_hard_regs_compare, object_hard_regs_node_t): Rename to\n+\tallocno_hard_regs_compare and allocno_hard_regs_node_t.\n+\t(create_new_object_hard_regs_node): Rename to\n+\tcreate_new_allocno_hard_regs_node.\n+\t(add_new_object_hard_regs_node_to_forest): Rename to\n+\tadd_new_allocno_hard_regs_node_to_forest.\n+\t(add_object_hard_regs_to_forest, collect_object_hard_regs_cover):\n+\tRename to add_allocno_hard_regs_to_forest and collect_allocno_hard_regs_cover.\n+\t(setup_object_hard_regs_nodes_parent): Rename to setup_allocno_hard_regs_nodes_parent.\n+\t(remove_unused_object_hard_regs_nodes): Rename to remove_unused_allocno_hard_regs_nodes.\n+\t(enumerate_object_hard_regs_nodes, object_hard_regs_nodes_num):\n+\tRename to enumerate_allocno_hard_regs_nodes and allocno_hard_regs_nodes_num.\n+\t(object_hard_regs_nodes, object_hard_regs_subnode_t): Rename to\n+\tallocno_hard_regs_nodes and allocno_hard_regs_subnode_t.\n+\t(object_hard_regs_subnode, object_hard_regs_subnodes): Rename to\n+\tallocno_hard_regs_subnode and allocno_hard_regs_subnodes.\n+\t(object_hard_regs_subnode_index): Rename to allocno_hard_regs_subnode_index.\n+\t(setup_object_hard_regs_subnode_index): Rename to\n+\tsetup_allocno_hard_regs_subnode_index.\n+\t(get_object_hard_regs_subnodes_num): Rename to get_allocno_hard_regs_subnodes_num.\n+\t(form_object_hard_regs_nodes_forest): Rename to form_allocno_hard_regs_nodes_forest.\n+\t(finish_object_hard_regs_nodes_tree): Rename to form_allocno_hard_regs_nodes_forest\n+\t(finish_object_hard_regs_nodes_forest): Rename to\n+\tfinish_allocno_hard_regs_nodes_forest.\n+\t(setup_left_conflict_sizes_p): Use allocno data instead of object\n+\tones.  Process conflict allocnos once.\n+\t(update_left_conflict_sizes_p): Use allocno data instead of object\n+\tones.  Change prototype signature.\n+\t(empty_profitable_hard_regs): Use allocno data instead of object\n+\tones.\n+\t(setup_profitable_hard_regs): Ditto.\n+\t(get_conflict_profitable_regs): Rename to\n+\tget_conflict_and_start_profitable_regs.  Use allocno data for\n+\tprofitable regs calculation.\n+\t(check_hard_reg_p): Change prototype signature.  Check profitable\n+\tregs for allocno not the objects.\n+\t(assign_hard_reg): Process conflict allocnos only once for\n+\tupdating conflict costs.\n+\t(setup_allocno_available_regs_num): Use allocno data instead of\n+\tobject ones.  Modify debug output.\n+\t(color_pass): Remove initialization and finalization of object\n+\tcolor data.\n+\n 2011-12-05  Kazu Hirata  <kazu@codesourcery.com>\n \n \tPR target/51408"}, {"sha": "2d8708a4e65e08ed4562a71672963a37a3353bb6", "filename": "gcc/ira-build.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27508f5fa3c79ca39d32079348017c6132d25722/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27508f5fa3c79ca39d32079348017c6132d25722/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=27508f5fa3c79ca39d32079348017c6132d25722", "patch": "@@ -442,7 +442,6 @@ ira_create_object (ira_allocno_t a, int subword)\n   OBJECT_MIN (obj) = INT_MAX;\n   OBJECT_MAX (obj) = -1;\n   OBJECT_LIVE_RANGES (obj) = NULL;\n-  OBJECT_ADD_DATA (obj) = NULL;\n \n   VEC_safe_push (ira_object_t, heap, ira_object_id_map_vec, obj);\n   ira_object_id_map"}, {"sha": "c7a7033ebc145c246dedeecda4c199484c1fe20c", "filename": "gcc/ira-color.c", "status": "modified", "additions": 468, "deletions": 558, "changes": 1026, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27508f5fa3c79ca39d32079348017c6132d25722/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27508f5fa3c79ca39d32079348017c6132d25722/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=27508f5fa3c79ca39d32079348017c6132d25722", "patch": "@@ -39,15 +39,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"ira-int.h\"\n \n-typedef struct object_hard_regs *object_hard_regs_t;\n+typedef struct allocno_hard_regs *allocno_hard_regs_t;\n \n /* The structure contains information about hard registers can be\n-   assigned to objects.  Usually it is allocno profitable hard\n+   assigned to allocnos.  Usually it is allocno profitable hard\n    registers but in some cases this set can be a bit different.  Major\n    reason of the difference is a requirement to use hard register sets\n    that form a tree or a forest (set of trees), i.e. hard register set\n    of a node should contain hard register sets of its subnodes.  */\n-struct object_hard_regs\n+struct allocno_hard_regs\n {\n   /* Hard registers can be assigned to an allocno.  */\n   HARD_REG_SET set;\n@@ -56,22 +56,22 @@ struct object_hard_regs\n   long long int cost;\n };\n \n-typedef struct object_hard_regs_node *object_hard_regs_node_t;\n+typedef struct allocno_hard_regs_node *allocno_hard_regs_node_t;\n \n-/* A node representing object hard registers.  Such nodes form a\n+/* A node representing allocno hard registers.  Such nodes form a\n    forest (set of trees).  Each subnode of given node in the forest\n-   refers for hard register set (usually object profitable hard\n+   refers for hard register set (usually allocno profitable hard\n    register set) which is a subset of one referred from given\n    node.  */\n-struct object_hard_regs_node\n+struct allocno_hard_regs_node\n {\n   /* Set up number of the node in preorder traversing of the forest.  */\n   int preorder_num;\n   /* Used for different calculation like finding conflict size of an\n      allocno.  */\n   int check;\n   /* Used for calculation of conflict size of an allocno.  The\n-     conflict size of the allocno is maximal number of given object\n+     conflict size of the allocno is maximal number of given allocno\n      hard registers needed for allocation of the conflicting allocnos.\n      Given allocno is trivially colored if this number plus the number\n      of hard registers needed for given allocno is not greater than\n@@ -82,10 +82,10 @@ struct object_hard_regs_node\n   /* The following member is used to form the final forest.  */\n   bool used_p;\n   /* Pointer to the corresponding profitable hard registers.  */\n-  object_hard_regs_t hard_regs;\n+  allocno_hard_regs_t hard_regs;\n   /* Parent, first subnode, previous and next node with the same\n      parent in the forest.  */\n-  object_hard_regs_node_t parent, first, prev, next;\n+  allocno_hard_regs_node_t parent, first, prev, next;\n };\n \n /* To decrease footprint of ira_allocno structure we store all data\n@@ -98,7 +98,7 @@ struct allocno_color_data\n   /* TRUE if it is put on the stack to make other allocnos\n      colorable.  */\n   unsigned int may_be_spilled_p : 1;\n-  /* TRUE if the object is trivially colorable.  */\n+  /* TRUE if the allocno is trivially colorable.  */\n   unsigned int colorable_p : 1;\n   /* Number of hard registers of the allocno class really\n      available for the allocno allocation.  It is number of the\n@@ -110,45 +110,37 @@ struct allocno_color_data\n   ira_allocno_t prev_bucket_allocno;\n   /* Used for temporary purposes.  */\n   int temp;\n-};\n-\n-/* See above.  */\n-typedef struct allocno_color_data *allocno_color_data_t;\n-\n-/* Container for storing allocno data concerning coloring.  */\n-static allocno_color_data_t allocno_color_data;\n-\n-/* Macro to access the data concerning coloring.  */\n-#define ALLOCNO_COLOR_DATA(a) ((allocno_color_data_t) ALLOCNO_ADD_DATA (a))\n-\n-/* To decrease footprint of ira_object structure we store all data\n-   needed only for coloring in the following structure.  */\n-struct object_color_data\n-{\n+  /* Used to exclude repeated processing.  */\n+  int last_process;\n   /* Profitable hard regs available for this pseudo allocation.  It\n      means that the set excludes unavailable hard regs and hard regs\n      conflicting with given pseudo.  They should be of the allocno\n      class.  */\n   HARD_REG_SET profitable_hard_regs;\n-  /* The object hard registers node.  */\n-  object_hard_regs_node_t hard_regs_node;\n-  /* Array of structures object_hard_regs_subnode representing\n-     given object hard registers node (the 1st element in the array)\n-     and all its subnodes in the tree (forest) of object hard\n+  /* The allocno hard registers node.  */\n+  allocno_hard_regs_node_t hard_regs_node;\n+  /* Array of structures allocno_hard_regs_subnode representing\n+     given allocno hard registers node (the 1st element in the array)\n+     and all its subnodes in the tree (forest) of allocno hard\n      register nodes (see comments above).  */\n   int hard_regs_subnodes_start;\n   /* The length of the previous array. */\n   int hard_regs_subnodes_num;\n };\n \n /* See above.  */\n-typedef struct object_color_data *object_color_data_t;\n+typedef struct allocno_color_data *allocno_color_data_t;\n \n-/* Container for storing object data concerning coloring.  */\n-static object_color_data_t object_color_data;\n+/* Container for storing allocno data concerning coloring.  */\n+static allocno_color_data_t allocno_color_data;\n \n /* Macro to access the data concerning coloring.  */\n-#define OBJECT_COLOR_DATA(o) ((object_color_data_t) OBJECT_ADD_DATA (o))\n+#define ALLOCNO_COLOR_DATA(a) ((allocno_color_data_t) ALLOCNO_ADD_DATA (a))\n+\n+/* Used for finding allocno colorability to exclude repeated allocno\n+   processing and for updating preferencing to exclude repeated\n+   allocno processing during assignment.  */\n+static int curr_allocno_process;\n \n /* This file contains code for regional graph coloring, spill/restore\n    code placement optimization, and code helping the reload pass to do\n@@ -177,108 +169,108 @@ static VEC(ira_allocno_t,heap) *allocno_stack_vec;\n \n \f\n \n-/* Definition of vector of object hard registers.  */\n-DEF_VEC_P(object_hard_regs_t);\n-DEF_VEC_ALLOC_P(object_hard_regs_t, heap);\n+/* Definition of vector of allocno hard registers.  */\n+DEF_VEC_P(allocno_hard_regs_t);\n+DEF_VEC_ALLOC_P(allocno_hard_regs_t, heap);\n \n-/* Vector of unique object hard registers.  */\n-static VEC(object_hard_regs_t, heap) *object_hard_regs_vec;\n+/* Vector of unique allocno hard registers.  */\n+static VEC(allocno_hard_regs_t, heap) *allocno_hard_regs_vec;\n \n-/* Returns hash value for object hard registers V.  */\n+/* Returns hash value for allocno hard registers V.  */\n static hashval_t\n-object_hard_regs_hash (const void *v)\n+allocno_hard_regs_hash (const void *v)\n {\n-  const struct object_hard_regs *hv = (const struct object_hard_regs *) v;\n+  const struct allocno_hard_regs *hv = (const struct allocno_hard_regs *) v;\n \n   return iterative_hash (&hv->set, sizeof (HARD_REG_SET), 0);\n }\n \n-/* Compares object hard registers V1 and V2.  */\n+/* Compares allocno hard registers V1 and V2.  */\n static int\n-object_hard_regs_eq (const void *v1, const void *v2)\n+allocno_hard_regs_eq (const void *v1, const void *v2)\n {\n-  const struct object_hard_regs *hv1 = (const struct object_hard_regs *) v1;\n-  const struct object_hard_regs *hv2 = (const struct object_hard_regs *) v2;\n+  const struct allocno_hard_regs *hv1 = (const struct allocno_hard_regs *) v1;\n+  const struct allocno_hard_regs *hv2 = (const struct allocno_hard_regs *) v2;\n \n   return hard_reg_set_equal_p (hv1->set, hv2->set);\n }\n \n-/* Hash table of unique object hard registers.  */\n-static htab_t object_hard_regs_htab;\n+/* Hash table of unique allocno hard registers.  */\n+static htab_t allocno_hard_regs_htab;\n \n-/* Return object hard registers in the hash table equal to HV.  */\n-static object_hard_regs_t\n-find_hard_regs (object_hard_regs_t hv)\n+/* Return allocno hard registers in the hash table equal to HV.  */\n+static allocno_hard_regs_t\n+find_hard_regs (allocno_hard_regs_t hv)\n {\n-  return (object_hard_regs_t) htab_find (object_hard_regs_htab, hv);\n+  return (allocno_hard_regs_t) htab_find (allocno_hard_regs_htab, hv);\n }\n \n /* Insert allocno hard registers HV in the hash table (if it is not\n    there yet) and return the value which in the table.  */\n-static object_hard_regs_t\n-insert_hard_regs (object_hard_regs_t hv)\n+static allocno_hard_regs_t\n+insert_hard_regs (allocno_hard_regs_t hv)\n {\n-  PTR *slot = htab_find_slot (object_hard_regs_htab, hv, INSERT);\n+  PTR *slot = htab_find_slot (allocno_hard_regs_htab, hv, INSERT);\n \n   if (*slot == NULL)\n     *slot = hv;\n-  return (object_hard_regs_t) *slot;\n+  return (allocno_hard_regs_t) *slot;\n }\n \n-/* Initialize data concerning object hard registers.  */\n+/* Initialize data concerning allocno hard registers.  */\n static void\n-init_object_hard_regs (void)\n+init_allocno_hard_regs (void)\n {\n-  object_hard_regs_vec = VEC_alloc (object_hard_regs_t, heap, 200);\n-  object_hard_regs_htab\n-    = htab_create (200, object_hard_regs_hash, object_hard_regs_eq, NULL);\n+  allocno_hard_regs_vec = VEC_alloc (allocno_hard_regs_t, heap, 200);\n+  allocno_hard_regs_htab\n+    = htab_create (200, allocno_hard_regs_hash, allocno_hard_regs_eq, NULL);\n }\n \n-/* Add (or update info about) object hard registers with SET and\n+/* Add (or update info about) allocno hard registers with SET and\n    COST.  */\n-static object_hard_regs_t\n-add_object_hard_regs (HARD_REG_SET set, long long int cost)\n+static allocno_hard_regs_t\n+add_allocno_hard_regs (HARD_REG_SET set, long long int cost)\n {\n-  struct object_hard_regs temp;\n-  object_hard_regs_t hv;\n+  struct allocno_hard_regs temp;\n+  allocno_hard_regs_t hv;\n \n   gcc_assert (! hard_reg_set_empty_p (set));\n   COPY_HARD_REG_SET (temp.set, set);\n   if ((hv = find_hard_regs (&temp)) != NULL)\n     hv->cost += cost;\n   else\n     {\n-      hv = ((struct object_hard_regs *)\n-\t    ira_allocate (sizeof (struct object_hard_regs)));\n+      hv = ((struct allocno_hard_regs *)\n+\t    ira_allocate (sizeof (struct allocno_hard_regs)));\n       COPY_HARD_REG_SET (hv->set, set);\n       hv->cost = cost;\n-      VEC_safe_push (object_hard_regs_t, heap, object_hard_regs_vec, hv);\n+      VEC_safe_push (allocno_hard_regs_t, heap, allocno_hard_regs_vec, hv);\n       insert_hard_regs (hv);\n     }\n   return hv;\n }\n \n /* Finalize data concerning allocno hard registers.  */\n static void\n-finish_object_hard_regs (void)\n+finish_allocno_hard_regs (void)\n {\n   int i;\n-  object_hard_regs_t hv;\n+  allocno_hard_regs_t hv;\n \n   for (i = 0;\n-       VEC_iterate (object_hard_regs_t, object_hard_regs_vec, i, hv);\n+       VEC_iterate (allocno_hard_regs_t, allocno_hard_regs_vec, i, hv);\n        i++)\n     ira_free (hv);\n-  htab_delete (object_hard_regs_htab);\n-  VEC_free (object_hard_regs_t, heap, object_hard_regs_vec);\n+  htab_delete (allocno_hard_regs_htab);\n+  VEC_free (allocno_hard_regs_t, heap, allocno_hard_regs_vec);\n }\n \n /* Sort hard regs according to their frequency of usage. */\n static int\n-object_hard_regs_compare (const void *v1p, const void *v2p)\n+allocno_hard_regs_compare (const void *v1p, const void *v2p)\n {\n-  object_hard_regs_t hv1 = *(const object_hard_regs_t *) v1p;\n-  object_hard_regs_t hv2 = *(const object_hard_regs_t *) v2p;\n+  allocno_hard_regs_t hv1 = *(const allocno_hard_regs_t *) v1p;\n+  allocno_hard_regs_t hv2 = *(const allocno_hard_regs_t *) v2p;\n \n   if (hv2->cost > hv1->cost)\n     return 1;\n@@ -301,25 +293,25 @@ object_hard_regs_compare (const void *v1p, const void *v2p)\n static int node_check_tick;\n \n /* Roots of the forest containing hard register sets can be assigned\n-   to objects.  */\n-static object_hard_regs_node_t hard_regs_roots;\n+   to allocnos.  */\n+static allocno_hard_regs_node_t hard_regs_roots;\n \n-/* Definition of vector of object hard register nodes.  */\n-DEF_VEC_P(object_hard_regs_node_t);\n-DEF_VEC_ALLOC_P(object_hard_regs_node_t, heap);\n+/* Definition of vector of allocno hard register nodes.  */\n+DEF_VEC_P(allocno_hard_regs_node_t);\n+DEF_VEC_ALLOC_P(allocno_hard_regs_node_t, heap);\n \n /* Vector used to create the forest.  */\n-static VEC(object_hard_regs_node_t, heap) *hard_regs_node_vec;\n+static VEC(allocno_hard_regs_node_t, heap) *hard_regs_node_vec;\n \n-/* Create and return object hard registers node containing object\n+/* Create and return allocno hard registers node containing allocno\n    hard registers HV.  */\n-static object_hard_regs_node_t\n-create_new_object_hard_regs_node (object_hard_regs_t hv)\n+static allocno_hard_regs_node_t\n+create_new_allocno_hard_regs_node (allocno_hard_regs_t hv)\n {\n-  object_hard_regs_node_t new_node;\n+  allocno_hard_regs_node_t new_node;\n \n-  new_node = ((struct object_hard_regs_node *)\n-\t      ira_allocate (sizeof (struct object_hard_regs_node)));\n+  new_node = ((struct allocno_hard_regs_node *)\n+\t      ira_allocate (sizeof (struct allocno_hard_regs_node)));\n   new_node->check = 0;\n   new_node->hard_regs = hv;\n   new_node->hard_regs_num = hard_reg_set_size (hv->set);\n@@ -328,11 +320,11 @@ create_new_object_hard_regs_node (object_hard_regs_t hv)\n   return new_node;\n }\n \n-/* Add object hard registers node NEW_NODE to the forest on its level\n+/* Add allocno hard registers node NEW_NODE to the forest on its level\n    given by ROOTS.  */\n static void\n-add_new_object_hard_regs_node_to_forest (object_hard_regs_node_t *roots,\n-\t\t\t\t\t  object_hard_regs_node_t new_node)\n+add_new_allocno_hard_regs_node_to_forest (allocno_hard_regs_node_t *roots,\n+\t\t\t\t\t  allocno_hard_regs_node_t new_node)\n {\n   new_node->next = *roots;\n   if (new_node->next != NULL)\n@@ -341,58 +333,58 @@ add_new_object_hard_regs_node_to_forest (object_hard_regs_node_t *roots,\n   *roots = new_node;\n }\n \n-/* Add object hard registers HV (or its best approximation if it is\n+/* Add allocno hard registers HV (or its best approximation if it is\n    not possible) to the forest on its level given by ROOTS.  */\n static void\n-add_object_hard_regs_to_forest (object_hard_regs_node_t *roots,\n-\t\t\t\tobject_hard_regs_t hv)\n+add_allocno_hard_regs_to_forest (allocno_hard_regs_node_t *roots,\n+\t\t\t\t allocno_hard_regs_t hv)\n {\n   unsigned int i, start;\n-  object_hard_regs_node_t node, prev, new_node;\n+  allocno_hard_regs_node_t node, prev, new_node;\n   HARD_REG_SET temp_set;\n-  object_hard_regs_t hv2;\n+  allocno_hard_regs_t hv2;\n \n-  start = VEC_length (object_hard_regs_node_t, hard_regs_node_vec);\n+  start = VEC_length (allocno_hard_regs_node_t, hard_regs_node_vec);\n   for (node = *roots; node != NULL; node = node->next)\n     {\n       if (hard_reg_set_equal_p (hv->set, node->hard_regs->set))\n \treturn;\n       if (hard_reg_set_subset_p (hv->set, node->hard_regs->set))\n \t{\n-\t  add_object_hard_regs_to_forest (&node->first, hv);\n+\t  add_allocno_hard_regs_to_forest (&node->first, hv);\n \t  return;\n \t}\n       if (hard_reg_set_subset_p (node->hard_regs->set, hv->set))\n-\tVEC_safe_push (object_hard_regs_node_t, heap,\n+\tVEC_safe_push (allocno_hard_regs_node_t, heap,\n \t\t       hard_regs_node_vec, node);\n       else if (hard_reg_set_intersect_p (hv->set, node->hard_regs->set))\n \t{\n \t  COPY_HARD_REG_SET (temp_set, hv->set);\n \t  AND_HARD_REG_SET (temp_set, node->hard_regs->set);\n-\t  hv2 = add_object_hard_regs (temp_set, hv->cost);\n-\t  add_object_hard_regs_to_forest (&node->first, hv2);\n+\t  hv2 = add_allocno_hard_regs (temp_set, hv->cost);\n+\t  add_allocno_hard_regs_to_forest (&node->first, hv2);\n \t}\n     }\n-  if (VEC_length (object_hard_regs_node_t, hard_regs_node_vec)\n+  if (VEC_length (allocno_hard_regs_node_t, hard_regs_node_vec)\n       > start + 1)\n     {\n       /* Create a new node which contains nodes in hard_regs_node_vec.  */\n       CLEAR_HARD_REG_SET (temp_set);\n       for (i = start;\n-\t   i < VEC_length (object_hard_regs_node_t, hard_regs_node_vec);\n+\t   i < VEC_length (allocno_hard_regs_node_t, hard_regs_node_vec);\n \t   i++)\n \t{\n-\t  node = VEC_index (object_hard_regs_node_t, hard_regs_node_vec, i);\n+\t  node = VEC_index (allocno_hard_regs_node_t, hard_regs_node_vec, i);\n \t  IOR_HARD_REG_SET (temp_set, node->hard_regs->set);\n \t}\n-      hv = add_object_hard_regs (temp_set, hv->cost);\n-      new_node = create_new_object_hard_regs_node (hv);\n+      hv = add_allocno_hard_regs (temp_set, hv->cost);\n+      new_node = create_new_allocno_hard_regs_node (hv);\n       prev = NULL;\n       for (i = start;\n-\t   i < VEC_length (object_hard_regs_node_t, hard_regs_node_vec);\n+\t   i < VEC_length (allocno_hard_regs_node_t, hard_regs_node_vec);\n \t   i++)\n \t{\n-\t  node = VEC_index (object_hard_regs_node_t, hard_regs_node_vec, i);\n+\t  node = VEC_index (allocno_hard_regs_node_t, hard_regs_node_vec, i);\n \t  if (node->prev == NULL)\n \t    *roots = node->next;\n \t  else\n@@ -407,50 +399,50 @@ add_object_hard_regs_to_forest (object_hard_regs_node_t *roots,\n \t  node->next = NULL;\n \t  prev = node;\n \t}\n-      add_new_object_hard_regs_node_to_forest (roots, new_node);\n+      add_new_allocno_hard_regs_node_to_forest (roots, new_node);\n     }\n-  VEC_truncate (object_hard_regs_node_t, hard_regs_node_vec, start);\n+  VEC_truncate (allocno_hard_regs_node_t, hard_regs_node_vec, start);\n }\n \n-/* Add object hard registers nodes starting with the forest level\n+/* Add allocno hard registers nodes starting with the forest level\n    given by FIRST which contains biggest set inside SET.  */\n static void\n-collect_object_hard_regs_cover (object_hard_regs_node_t first,\n+collect_allocno_hard_regs_cover (allocno_hard_regs_node_t first,\n \t\t\t\t HARD_REG_SET set)\n {\n-  object_hard_regs_node_t node;\n+  allocno_hard_regs_node_t node;\n \n   ira_assert (first != NULL);\n   for (node = first; node != NULL; node = node->next)\n     if (hard_reg_set_subset_p (node->hard_regs->set, set))\n-      VEC_safe_push (object_hard_regs_node_t, heap, hard_regs_node_vec,\n+      VEC_safe_push (allocno_hard_regs_node_t, heap, hard_regs_node_vec,\n \t\t     node);\n     else if (hard_reg_set_intersect_p (set, node->hard_regs->set))\n-      collect_object_hard_regs_cover (node->first, set);\n+      collect_allocno_hard_regs_cover (node->first, set);\n }\n \n-/* Set up field parent as PARENT in all object hard registers nodes\n+/* Set up field parent as PARENT in all allocno hard registers nodes\n    in forest given by FIRST.  */\n static void\n-setup_object_hard_regs_nodes_parent (object_hard_regs_node_t first,\n-\t\t\t\t     object_hard_regs_node_t parent)\n+setup_allocno_hard_regs_nodes_parent (allocno_hard_regs_node_t first,\n+\t\t\t\t      allocno_hard_regs_node_t parent)\n {\n-  object_hard_regs_node_t node;\n+  allocno_hard_regs_node_t node;\n \n   for (node = first; node != NULL; node = node->next)\n     {\n       node->parent = parent;\n-      setup_object_hard_regs_nodes_parent (node->first, node);\n+      setup_allocno_hard_regs_nodes_parent (node->first, node);\n     }\n }\n \n-/* Return object hard registers node which is a first common ancestor\n+/* Return allocno hard registers node which is a first common ancestor\n    node of FIRST and SECOND in the forest.  */\n-static object_hard_regs_node_t\n-first_common_ancestor_node (object_hard_regs_node_t first,\n-\t\t\t    object_hard_regs_node_t second)\n+static allocno_hard_regs_node_t\n+first_common_ancestor_node (allocno_hard_regs_node_t first,\n+\t\t\t    allocno_hard_regs_node_t second)\n {\n-  object_hard_regs_node_t node;\n+  allocno_hard_regs_node_t node;\n \n   node_check_tick++;\n   for (node = first; node != NULL; node = node->parent)\n@@ -490,14 +482,14 @@ print_hard_reg_set (FILE *f, HARD_REG_SET set, bool new_line_p)\n     fprintf (f, \"\\n\");\n }\n \n-/* Print object hard register subforest given by ROOTS and its LEVEL\n+/* Print allocno hard register subforest given by ROOTS and its LEVEL\n    to F.  */\n static void\n-print_hard_regs_subforest (FILE *f, object_hard_regs_node_t roots,\n+print_hard_regs_subforest (FILE *f, allocno_hard_regs_node_t roots,\n \t\t\t   int level)\n {\n   int i;\n-  object_hard_regs_node_t node;\n+  allocno_hard_regs_node_t node;\n \n   for (node = roots; node != NULL; node = node->next)\n     {\n@@ -511,34 +503,34 @@ print_hard_regs_subforest (FILE *f, object_hard_regs_node_t roots,\n     }\n }\n \n-/* Print the object hard register forest to F.  */\n+/* Print the allocno hard register forest to F.  */\n static void\n print_hard_regs_forest (FILE *f)\n {\n   fprintf (f, \"    Hard reg set forest:\\n\");\n   print_hard_regs_subforest (f, hard_regs_roots, 1);\n }\n \n-/* Print the object hard register forest to stderr.  */\n+/* Print the allocno hard register forest to stderr.  */\n void\n ira_debug_hard_regs_forest (void)\n {\n   print_hard_regs_forest (stderr);\n }\n \n-/* Remove unused object hard registers nodes from forest given by its\n+/* Remove unused allocno hard registers nodes from forest given by its\n    *ROOTS.  */\n static void\n-remove_unused_object_hard_regs_nodes (object_hard_regs_node_t *roots)\n+remove_unused_allocno_hard_regs_nodes (allocno_hard_regs_node_t *roots)\n {\n-  object_hard_regs_node_t node, prev, next, last;\n+  allocno_hard_regs_node_t node, prev, next, last;\n \n   for (prev = NULL, node = *roots; node != NULL; node = next)\n     {\n       next = node->next;\n       if (node->used_p)\n \t{\n-\t  remove_unused_object_hard_regs_nodes (&node->first);\n+\t  remove_unused_allocno_hard_regs_nodes (&node->first);\n \t  prev = node;\n \t}\n       else\n@@ -572,45 +564,45 @@ remove_unused_object_hard_regs_nodes (object_hard_regs_node_t *roots)\n     }\n }\n \n-/* Set up fields preorder_num starting with START_NUM in all object\n+/* Set up fields preorder_num starting with START_NUM in all allocno\n    hard registers nodes in forest given by FIRST.  Return biggest set\n    PREORDER_NUM increased by 1.  */\n static int\n-enumerate_object_hard_regs_nodes (object_hard_regs_node_t first,\n-\t\t\t\t  object_hard_regs_node_t parent,\n-\t\t\t\t  int start_num)\n+enumerate_allocno_hard_regs_nodes (allocno_hard_regs_node_t first,\n+\t\t\t\t   allocno_hard_regs_node_t parent,\n+\t\t\t\t   int start_num)\n {\n-  object_hard_regs_node_t node;\n+  allocno_hard_regs_node_t node;\n \n   for (node = first; node != NULL; node = node->next)\n     {\n       node->preorder_num = start_num++;\n       node->parent = parent;\n-      start_num\t= enumerate_object_hard_regs_nodes (node->first, node,\n-\t\t\t\t\t\t    start_num);\n+      start_num = enumerate_allocno_hard_regs_nodes (node->first, node,\n+\t\t\t\t\t\t     start_num);\n     }\n   return start_num;\n }\n \n-/* Number of object hard registers nodes in the forest.  */\n-static int object_hard_regs_nodes_num;\n+/* Number of allocno hard registers nodes in the forest.  */\n+static int allocno_hard_regs_nodes_num;\n \n-/* Table preorder number of object hard registers node in the forest\n-   -> the object hard registers node.  */\n-static object_hard_regs_node_t *object_hard_regs_nodes;\n+/* Table preorder number of allocno hard registers node in the forest\n+   -> the allocno hard registers node.  */\n+static allocno_hard_regs_node_t *allocno_hard_regs_nodes;\n \n /* See below.  */\n-typedef struct object_hard_regs_subnode *object_hard_regs_subnode_t;\n+typedef struct allocno_hard_regs_subnode *allocno_hard_regs_subnode_t;\n \n /* The structure is used to describes all subnodes (not only immediate\n-   ones) in the mentioned above tree for given object hard register\n+   ones) in the mentioned above tree for given allocno hard register\n    node.  The usage of such data accelerates calculation of\n    colorability of given allocno.  */\n-struct object_hard_regs_subnode\n+struct allocno_hard_regs_subnode\n {\n   /* The conflict size of conflicting allocnos whose hard register\n      sets are equal sets (plus supersets if given node is given\n-     object hard registers node) of one in the given node.  */\n+     allocno hard registers node) of one in the given node.  */\n   int left_conflict_size;\n   /* The summary conflict size of conflicting allocnos whose hard\n      register sets are strict subsets of one in the given node.\n@@ -623,200 +615,187 @@ struct object_hard_regs_subnode\n   short max_node_impact;\n };\n \n-/* Container for hard regs subnodes of all objects.  */\n-static object_hard_regs_subnode_t object_hard_regs_subnodes;\n+/* Container for hard regs subnodes of all allocnos.  */\n+static allocno_hard_regs_subnode_t allocno_hard_regs_subnodes;\n \n-/* Table (preorder number of object hard registers node in the\n-   forest, preorder number of object hard registers subnode) -> index\n+/* Table (preorder number of allocno hard registers node in the\n+   forest, preorder number of allocno hard registers subnode) -> index\n    of the subnode relative to the node.  -1 if it is not a\n    subnode.  */\n-static int *object_hard_regs_subnode_index;\n+static int *allocno_hard_regs_subnode_index;\n \n-/* Setup arrays OBJECT_HARD_REGS_NODES and\n-   OBJECT_HARD_REGS_SUBNODE_INDEX.  */\n+/* Setup arrays ALLOCNO_HARD_REGS_NODES and\n+   ALLOCNO_HARD_REGS_SUBNODE_INDEX.  */\n static void\n-setup_object_hard_regs_subnode_index (object_hard_regs_node_t first)\n+setup_allocno_hard_regs_subnode_index (allocno_hard_regs_node_t first)\n {\n-  object_hard_regs_node_t node, parent;\n+  allocno_hard_regs_node_t node, parent;\n   int index;\n \n   for (node = first; node != NULL; node = node->next)\n     {\n-      object_hard_regs_nodes[node->preorder_num] = node;\n+      allocno_hard_regs_nodes[node->preorder_num] = node;\n       for (parent = node; parent != NULL; parent = parent->parent)\n \t{\n-\t  index = parent->preorder_num * object_hard_regs_nodes_num;\n-\t  object_hard_regs_subnode_index[index + node->preorder_num]\n+\t  index = parent->preorder_num * allocno_hard_regs_nodes_num;\n+\t  allocno_hard_regs_subnode_index[index + node->preorder_num]\n \t    = node->preorder_num - parent->preorder_num;\n \t}\n-      setup_object_hard_regs_subnode_index (node->first);\n+      setup_allocno_hard_regs_subnode_index (node->first);\n     }\n }\n \n-/* Count all object hard registers nodes in tree ROOT.  */\n+/* Count all allocno hard registers nodes in tree ROOT.  */\n static int\n-get_object_hard_regs_subnodes_num (object_hard_regs_node_t root)\n+get_allocno_hard_regs_subnodes_num (allocno_hard_regs_node_t root)\n {\n   int len = 1;\n \n   for (root = root->first; root != NULL; root = root->next)\n-    len += get_object_hard_regs_subnodes_num (root);\n+    len += get_allocno_hard_regs_subnodes_num (root);\n   return len;\n }\n \n-/* Build the forest of object hard registers nodes and assign each\n+/* Build the forest of allocno hard registers nodes and assign each\n    allocno a node from the forest.  */\n static void\n-form_object_hard_regs_nodes_forest (void)\n+form_allocno_hard_regs_nodes_forest (void)\n {\n   unsigned int i, j, size, len;\n-  int start, k;\n+  int start;\n   ira_allocno_t a;\n-  object_hard_regs_t hv;\n+  allocno_hard_regs_t hv;\n   bitmap_iterator bi;\n   HARD_REG_SET temp;\n-  object_hard_regs_node_t node, object_hard_regs_node;\n+  allocno_hard_regs_node_t node, allocno_hard_regs_node;\n+  allocno_color_data_t allocno_data;\n \n   node_check_tick = 0;\n-  init_object_hard_regs ();\n+  init_allocno_hard_regs ();\n   hard_regs_roots = NULL;\n-  hard_regs_node_vec = VEC_alloc (object_hard_regs_node_t, heap, 100);\n+  hard_regs_node_vec = VEC_alloc (allocno_hard_regs_node_t, heap, 100);\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, i))\n       {\n \tCLEAR_HARD_REG_SET (temp);\n \tSET_HARD_REG_BIT (temp, i);\n-\thv = add_object_hard_regs (temp, 0);\n-\tnode = create_new_object_hard_regs_node (hv);\n-\tadd_new_object_hard_regs_node_to_forest (&hard_regs_roots, node);\n+\thv = add_allocno_hard_regs (temp, 0);\n+\tnode = create_new_allocno_hard_regs_node (hv);\n+\tadd_new_allocno_hard_regs_node_to_forest (&hard_regs_roots, node);\n       }\n-  start = VEC_length (object_hard_regs_t, object_hard_regs_vec);\n+  start = VEC_length (allocno_hard_regs_t, allocno_hard_regs_vec);\n   EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, i, bi)\n     {\n       a = ira_allocnos[i];\n-      for (k = 0; k < ALLOCNO_NUM_OBJECTS (a); k++)\n-\t{\n-\t  ira_object_t obj = ALLOCNO_OBJECT (a, k);\n-\t  object_color_data_t obj_data = OBJECT_COLOR_DATA (obj);\n-\n-\t  if (hard_reg_set_empty_p (obj_data->profitable_hard_regs))\n-\t    continue;\n-\t  hv = (add_object_hard_regs\n-\t\t(obj_data->profitable_hard_regs,\n-\t\t ALLOCNO_MEMORY_COST (a) - ALLOCNO_CLASS_COST (a)));\n-\t}\n+      allocno_data = ALLOCNO_COLOR_DATA (a);\n+      \n+      if (hard_reg_set_empty_p (allocno_data->profitable_hard_regs))\n+\tcontinue;\n+      hv = (add_allocno_hard_regs\n+\t    (allocno_data->profitable_hard_regs,\n+\t     ALLOCNO_MEMORY_COST (a) - ALLOCNO_CLASS_COST (a)));\n     }\n   SET_HARD_REG_SET (temp);\n   AND_COMPL_HARD_REG_SET (temp, ira_no_alloc_regs);\n-  add_object_hard_regs (temp, 0);\n-  qsort (VEC_address (object_hard_regs_t, object_hard_regs_vec) + start,\n-\t VEC_length (object_hard_regs_t, object_hard_regs_vec) - start,\n-\t sizeof (object_hard_regs_t), object_hard_regs_compare);\n+  add_allocno_hard_regs (temp, 0);\n+  qsort (VEC_address (allocno_hard_regs_t, allocno_hard_regs_vec) + start,\n+\t VEC_length (allocno_hard_regs_t, allocno_hard_regs_vec) - start,\n+\t sizeof (allocno_hard_regs_t), allocno_hard_regs_compare);\n   for (i = start;\n-       VEC_iterate (object_hard_regs_t, object_hard_regs_vec, i, hv);\n+       VEC_iterate (allocno_hard_regs_t, allocno_hard_regs_vec, i, hv);\n        i++)\n     {\n-      add_object_hard_regs_to_forest (&hard_regs_roots, hv);\n-      ira_assert (VEC_length (object_hard_regs_node_t,\n+      add_allocno_hard_regs_to_forest (&hard_regs_roots, hv);\n+      ira_assert (VEC_length (allocno_hard_regs_node_t,\n \t\t\t      hard_regs_node_vec) == 0);\n     }\n   /* We need to set up parent fields for right work of\n      first_common_ancestor_node. */\n-  setup_object_hard_regs_nodes_parent (hard_regs_roots, NULL);\n+  setup_allocno_hard_regs_nodes_parent (hard_regs_roots, NULL);\n   EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, i, bi)\n     {\n       a = ira_allocnos[i];\n-      for (k = 0; k < ALLOCNO_NUM_OBJECTS (a); k++)\n-\t{\n-\t  ira_object_t obj = ALLOCNO_OBJECT (a, k);\n-\t  object_color_data_t obj_data = OBJECT_COLOR_DATA (obj);\n-\t  \n-\t  if (hard_reg_set_empty_p (obj_data->profitable_hard_regs))\n-\t    continue;\n-\t  VEC_truncate (object_hard_regs_node_t, hard_regs_node_vec, 0);\n-\t  collect_object_hard_regs_cover (hard_regs_roots,\n-\t\t\t\t\t  obj_data->profitable_hard_regs);\n-\t  object_hard_regs_node = NULL;\n-\t  for (j = 0;\n-\t       VEC_iterate (object_hard_regs_node_t, hard_regs_node_vec,\n-\t\t\t    j, node);\n-\t       j++)\n-\t    object_hard_regs_node\n-\t      = (j == 0\n-\t\t ? node\n-\t\t : first_common_ancestor_node (node, object_hard_regs_node));\n-\t  /* That is a temporary storage.  */\n-\t  object_hard_regs_node->used_p = true;\n-\t  obj_data->hard_regs_node = object_hard_regs_node;\n-\t}\n+      allocno_data = ALLOCNO_COLOR_DATA (a);\n+      if (hard_reg_set_empty_p (allocno_data->profitable_hard_regs))\n+\tcontinue;\n+      VEC_truncate (allocno_hard_regs_node_t, hard_regs_node_vec, 0);\n+      collect_allocno_hard_regs_cover (hard_regs_roots,\n+\t\t\t\t       allocno_data->profitable_hard_regs);\n+      allocno_hard_regs_node = NULL;\n+      for (j = 0;\n+\t   VEC_iterate (allocno_hard_regs_node_t, hard_regs_node_vec,\n+\t\t\tj, node);\n+\t   j++)\n+\tallocno_hard_regs_node\n+\t  = (j == 0\n+\t     ? node\n+\t     : first_common_ancestor_node (node, allocno_hard_regs_node));\n+      /* That is a temporary storage.  */\n+      allocno_hard_regs_node->used_p = true;\n+      allocno_data->hard_regs_node = allocno_hard_regs_node;\n     }\n   ira_assert (hard_regs_roots->next == NULL);\n   hard_regs_roots->used_p = true;\n-  remove_unused_object_hard_regs_nodes (&hard_regs_roots);\n-  object_hard_regs_nodes_num\n-    = enumerate_object_hard_regs_nodes (hard_regs_roots, NULL, 0);\n-  object_hard_regs_nodes\n-    = ((object_hard_regs_node_t *)\n-       ira_allocate (object_hard_regs_nodes_num\n-\t\t     * sizeof (object_hard_regs_node_t)));\n-  size = object_hard_regs_nodes_num * object_hard_regs_nodes_num;\n-  object_hard_regs_subnode_index\n+  remove_unused_allocno_hard_regs_nodes (&hard_regs_roots);\n+  allocno_hard_regs_nodes_num\n+    = enumerate_allocno_hard_regs_nodes (hard_regs_roots, NULL, 0);\n+  allocno_hard_regs_nodes\n+    = ((allocno_hard_regs_node_t *)\n+       ira_allocate (allocno_hard_regs_nodes_num\n+\t\t     * sizeof (allocno_hard_regs_node_t)));\n+  size = allocno_hard_regs_nodes_num * allocno_hard_regs_nodes_num;\n+  allocno_hard_regs_subnode_index\n     = (int *) ira_allocate (size * sizeof (int));\n   for (i = 0; i < size; i++)\n-    object_hard_regs_subnode_index[i] = -1;\n-  setup_object_hard_regs_subnode_index (hard_regs_roots);\n+    allocno_hard_regs_subnode_index[i] = -1;\n+  setup_allocno_hard_regs_subnode_index (hard_regs_roots);\n   start = 0;\n   EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, i, bi)\n     {\n       a = ira_allocnos[i];\n-      for (k = 0; k < ALLOCNO_NUM_OBJECTS (a); k++)\n-\t{\n-\t  ira_object_t obj = ALLOCNO_OBJECT (a, k);\n-\t  object_color_data_t obj_data = OBJECT_COLOR_DATA (obj);\n-\t  \n-\t  if (hard_reg_set_empty_p (obj_data->profitable_hard_regs))\n-\t    continue;\n-\t  len = get_object_hard_regs_subnodes_num (obj_data->hard_regs_node);\n-\t  obj_data->hard_regs_subnodes_start = start;\n-\t  obj_data->hard_regs_subnodes_num = len;\n-\t  start += len;\n-\t}\n+      allocno_data = ALLOCNO_COLOR_DATA (a);\n+      if (hard_reg_set_empty_p (allocno_data->profitable_hard_regs))\n+\tcontinue;\n+      len = get_allocno_hard_regs_subnodes_num (allocno_data->hard_regs_node);\n+      allocno_data->hard_regs_subnodes_start = start;\n+      allocno_data->hard_regs_subnodes_num = len;\n+      start += len;\n     }\n-  object_hard_regs_subnodes\n-    = ((object_hard_regs_subnode_t)\n-       ira_allocate (sizeof (struct object_hard_regs_subnode) * start));\n-  VEC_free (object_hard_regs_node_t, heap, hard_regs_node_vec);\n+  allocno_hard_regs_subnodes\n+    = ((allocno_hard_regs_subnode_t)\n+       ira_allocate (sizeof (struct allocno_hard_regs_subnode) * start));\n+  VEC_free (allocno_hard_regs_node_t, heap, hard_regs_node_vec);\n }\n \n-/* Free tree of object hard registers nodes given by its ROOT.  */\n+/* Free tree of allocno hard registers nodes given by its ROOT.  */\n static void\n-finish_object_hard_regs_nodes_tree (object_hard_regs_node_t root)\n+finish_allocno_hard_regs_nodes_tree (allocno_hard_regs_node_t root)\n {\n-  object_hard_regs_node_t child, next;\n+  allocno_hard_regs_node_t child, next;\n \n   for (child = root->first; child != NULL; child = next)\n     {\n       next = child->next;\n-      finish_object_hard_regs_nodes_tree (child);\n+      finish_allocno_hard_regs_nodes_tree (child);\n     }\n   ira_free (root);\n }\n \n-/* Finish work with the forest of object hard registers nodes.  */\n+/* Finish work with the forest of allocno hard registers nodes.  */\n static void\n-finish_object_hard_regs_nodes_forest (void)\n+finish_allocno_hard_regs_nodes_forest (void)\n {\n-  object_hard_regs_node_t node, next;\n+  allocno_hard_regs_node_t node, next;\n   \n-  ira_free (object_hard_regs_subnodes);\n+  ira_free (allocno_hard_regs_subnodes);\n   for (node = hard_regs_roots; node != NULL; node = next)\n     {\n       next = node->next;\n-      finish_object_hard_regs_nodes_tree (node);\n+      finish_allocno_hard_regs_nodes_tree (node);\n     }\n-  ira_free (object_hard_regs_nodes);\n-  ira_free (object_hard_regs_subnode_index);\n-  finish_object_hard_regs ();\n+  ira_free (allocno_hard_regs_nodes);\n+  ira_free (allocno_hard_regs_subnode_index);\n+  finish_allocno_hard_regs ();\n }\n \n /* Set up left conflict sizes and left conflict subnodes sizes of hard\n@@ -825,46 +804,47 @@ finish_object_hard_regs_nodes_forest (void)\n static bool\n setup_left_conflict_sizes_p (ira_allocno_t a)\n {\n-  int k, nobj, conflict_size;\n+  int i, k, nobj, start;\n+  int conflict_size, left_conflict_subnodes_size, node_preorder_num;\n   allocno_color_data_t data;\n+  HARD_REG_SET profitable_hard_regs;\n+  allocno_hard_regs_subnode_t subnodes;\n+  allocno_hard_regs_node_t node;\n+  HARD_REG_SET node_set;\n \n   nobj = ALLOCNO_NUM_OBJECTS (a);\n   conflict_size = 0;\n   data = ALLOCNO_COLOR_DATA (a);\n+  subnodes = allocno_hard_regs_subnodes + data->hard_regs_subnodes_start;\n+  COPY_HARD_REG_SET (profitable_hard_regs, data->profitable_hard_regs);\n+  node = data->hard_regs_node;\n+  node_preorder_num = node->preorder_num;\n+  COPY_HARD_REG_SET (node_set, node->hard_regs->set);\n+  node_check_tick++;\n+  curr_allocno_process++;\n   for (k = 0; k < nobj; k++)\n     {\n-      int i, node_preorder_num, start, left_conflict_subnodes_size;\n-      HARD_REG_SET profitable_hard_regs;\n-      object_hard_regs_subnode_t subnodes;\n-      object_hard_regs_node_t node;\n-      HARD_REG_SET node_set;\n       ira_object_t obj = ALLOCNO_OBJECT (a, k);\n       ira_object_t conflict_obj;\n       ira_object_conflict_iterator oci;\n-      object_color_data_t obj_data;\n       \n-      node_check_tick++;\n-      obj_data = OBJECT_COLOR_DATA (obj);\n-      subnodes = object_hard_regs_subnodes + obj_data->hard_regs_subnodes_start;\n-      COPY_HARD_REG_SET (profitable_hard_regs, obj_data->profitable_hard_regs);\n-      node = obj_data->hard_regs_node;\n-      node_preorder_num = node->preorder_num;\n-      COPY_HARD_REG_SET (node_set, node->hard_regs->set);\n       FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n \t{\n \t  int size;\n  \t  ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n-\t  object_hard_regs_node_t conflict_node, temp_node;\n+\t  allocno_hard_regs_node_t conflict_node, temp_node;\n \t  HARD_REG_SET conflict_node_set;\n-\t  object_color_data_t conflict_obj_data;\n+\t  allocno_color_data_t conflict_data;\n \n-\t  conflict_obj_data = OBJECT_COLOR_DATA (conflict_obj);\n+\t  conflict_data = ALLOCNO_COLOR_DATA (conflict_a);\n \t  if (! ALLOCNO_COLOR_DATA (conflict_a)->in_graph_p\n+\t      || conflict_data->last_process == curr_allocno_process\n \t      || ! hard_reg_set_intersect_p (profitable_hard_regs,\n-\t\t\t\t\t     conflict_obj_data\n+\t\t\t\t\t     conflict_data\n \t\t\t\t\t     ->profitable_hard_regs))\n \t    continue;\n-\t  conflict_node = conflict_obj_data->hard_regs_node;\n+\t  conflict_data->last_process = curr_allocno_process;\n+\t  conflict_node = conflict_data->hard_regs_node;\n \t  COPY_HARD_REG_SET (conflict_node_set, conflict_node->hard_regs->set);\n \t  if (hard_reg_set_subset_p (node_set, conflict_node_set))\n \t    temp_node = node;\n@@ -885,164 +865,139 @@ setup_left_conflict_sizes_p (ira_allocno_t a)\n \t    size = 1;\n \t  temp_node->conflict_size += size;\n \t}\n-      for (i = 0; i < obj_data->hard_regs_subnodes_num; i++)\n+    }\n+  for (i = 0; i < data->hard_regs_subnodes_num; i++)\n+    {\n+      allocno_hard_regs_node_t temp_node;\n+      \n+      temp_node = allocno_hard_regs_nodes[i + node_preorder_num];\n+      ira_assert (temp_node->preorder_num == i + node_preorder_num);\n+      subnodes[i].left_conflict_size = (temp_node->check != node_check_tick\n+\t\t\t\t\t? 0 : temp_node->conflict_size);\n+      if (hard_reg_set_subset_p (temp_node->hard_regs->set,\n+\t\t\t\t profitable_hard_regs))\n+\tsubnodes[i].max_node_impact = temp_node->hard_regs_num;\n+      else\n \t{\n-\t  object_hard_regs_node_t temp_node;\n-\n-\t  temp_node = object_hard_regs_nodes[i + node_preorder_num];\n-\t  ira_assert (temp_node->preorder_num == i + node_preorder_num);\n-\t  subnodes[i].left_conflict_size = (temp_node->check != node_check_tick\n-\t\t\t\t\t    ? 0 : temp_node->conflict_size);\n-\t  if (hard_reg_set_subset_p (temp_node->hard_regs->set,\n-\t\t\t\t     profitable_hard_regs))\n-\t    subnodes[i].max_node_impact = temp_node->hard_regs_num;\n-\t  else\n+\t  HARD_REG_SET temp_set;\n+\t  int j, n, hard_regno;\n+\t  enum reg_class aclass;\n+\t  \n+\t  COPY_HARD_REG_SET (temp_set, temp_node->hard_regs->set);\n+\t  AND_HARD_REG_SET (temp_set, profitable_hard_regs);\n+\t  aclass = ALLOCNO_CLASS (a);\n+\t  for (n = 0, j = ira_class_hard_regs_num[aclass] - 1; j >= 0; j--)\n \t    {\n-\t      HARD_REG_SET temp_set;\n-\t      int j, n;\n-\t      enum reg_class aclass;\n-\t      \n-\t      COPY_HARD_REG_SET (temp_set, temp_node->hard_regs->set);\n-\t      AND_HARD_REG_SET (temp_set, profitable_hard_regs);\n-\t      aclass = ALLOCNO_CLASS (a);\n-\t      for (n = 0, j = ira_class_hard_regs_num[aclass] - 1; j >= 0; j--)\n-\t\tif (TEST_HARD_REG_BIT (temp_set, ira_class_hard_regs[aclass][j]))\n-\t\t  n++;\n-\t      subnodes[i].max_node_impact = n;\n+\t      hard_regno = ira_class_hard_regs[aclass][j];\n+\t      if (TEST_HARD_REG_BIT (temp_set, hard_regno))\n+\t\tn++;\n \t    }\n-\t  subnodes[i].left_conflict_subnodes_size = 0;\n+\t  subnodes[i].max_node_impact = n;\n \t}\n-      start = node_preorder_num * object_hard_regs_nodes_num;\n-      for (i = obj_data->hard_regs_subnodes_num - 1; i >= 0; i--)\n-\t{\n-\t  int size, parent_i;\n-\t  object_hard_regs_node_t parent;\n-\n-\t  size = (subnodes[i].left_conflict_subnodes_size\n-\t\t  + MIN (subnodes[i].max_node_impact\n-\t\t\t - subnodes[i].left_conflict_subnodes_size,\n-\t\t\t subnodes[i].left_conflict_size));\n-\t  parent = object_hard_regs_nodes[i + node_preorder_num]->parent;\n-\t  if (parent == NULL)\n-\t    continue;\n-\t  parent_i\n-\t    = object_hard_regs_subnode_index[start + parent->preorder_num];\n-\t  if (parent_i < 0)\n-\t    continue;\n-\t  subnodes[parent_i].left_conflict_subnodes_size += size;\n-\t}\n-      left_conflict_subnodes_size = subnodes[0].left_conflict_subnodes_size;\n-      conflict_size\n-\t+= (left_conflict_subnodes_size\n-\t    + MIN (subnodes[0].max_node_impact - left_conflict_subnodes_size,\n-\t\t   subnodes[0].left_conflict_size));\n+      subnodes[i].left_conflict_subnodes_size = 0;\n     }\n+  start = node_preorder_num * allocno_hard_regs_nodes_num;\n+  for (i = data->hard_regs_subnodes_num - 1; i >= 0; i--)\n+    {\n+      int size, parent_i;\n+      allocno_hard_regs_node_t parent;\n+      \n+      size = (subnodes[i].left_conflict_subnodes_size\n+\t      + MIN (subnodes[i].max_node_impact\n+\t\t     - subnodes[i].left_conflict_subnodes_size,\n+\t\t     subnodes[i].left_conflict_size));\n+      parent = allocno_hard_regs_nodes[i + node_preorder_num]->parent;\n+      if (parent == NULL)\n+\tcontinue;\n+      parent_i\n+\t= allocno_hard_regs_subnode_index[start + parent->preorder_num];\n+      if (parent_i < 0)\n+\tcontinue;\n+      subnodes[parent_i].left_conflict_subnodes_size += size;\n+    }\n+  left_conflict_subnodes_size = subnodes[0].left_conflict_subnodes_size;\n+  conflict_size\n+    += (left_conflict_subnodes_size\n+\t+ MIN (subnodes[0].max_node_impact - left_conflict_subnodes_size,\n+\t       subnodes[0].left_conflict_size));\n   conflict_size += ira_reg_class_max_nregs[ALLOCNO_CLASS (a)][ALLOCNO_MODE (a)];\n   data->colorable_p = conflict_size <= data->available_regs_num;\n   return data->colorable_p;\n }\n \n /* Update left conflict sizes of hard registers subnodes of allocno A\n-   after removing allocno containing object REMOVED_OBJ with SIZE from\n-   the conflict graph.  Return TRUE if A is trivially colorable.  */\n+   after removing allocno REMOVED_A with SIZE from the conflict graph.\n+   Return TRUE if A is trivially colorable.  */\n static bool\n update_left_conflict_sizes_p (ira_allocno_t a,\n-\t\t\t      ira_object_t removed_obj, int size)\n+\t\t\t      ira_allocno_t removed_a, int size)\n {\n-  int i, k, conflict_size, before_conflict_size, diff, start;\n+  int i, conflict_size, before_conflict_size, diff, start;\n   int node_preorder_num, parent_i;\n-  object_hard_regs_node_t node, removed_node, parent;\n-  object_hard_regs_subnode_t subnodes;\n+  allocno_hard_regs_node_t node, removed_node, parent;\n+  allocno_hard_regs_subnode_t subnodes;\n   allocno_color_data_t data = ALLOCNO_COLOR_DATA (a);\n-  bool colorable_p = true;\n \n   ira_assert (! data->colorable_p);\n-  for (k = 0; k < ALLOCNO_NUM_OBJECTS (a); k++)\n+  node = data->hard_regs_node;\n+  node_preorder_num = node->preorder_num;\n+  removed_node = ALLOCNO_COLOR_DATA (removed_a)->hard_regs_node;\n+  ira_assert (hard_reg_set_subset_p (removed_node->hard_regs->set,\n+\t\t\t       node->hard_regs->set)\n+\t      || hard_reg_set_subset_p (node->hard_regs->set,\n+\t\t\t\t\tremoved_node->hard_regs->set));\n+  start = node_preorder_num * allocno_hard_regs_nodes_num;\n+  i = allocno_hard_regs_subnode_index[start + removed_node->preorder_num];\n+  if (i < 0)\n+    i = 0;\n+  subnodes = allocno_hard_regs_subnodes + data->hard_regs_subnodes_start;\n+  before_conflict_size\n+    = (subnodes[i].left_conflict_subnodes_size\n+       + MIN (subnodes[i].max_node_impact\n+\t      - subnodes[i].left_conflict_subnodes_size,\n+\t      subnodes[i].left_conflict_size));\n+  subnodes[i].left_conflict_size -= size;\n+  for (;;)\n     {\n-      ira_object_t obj = ALLOCNO_OBJECT (a, k);\n-      object_color_data_t obj_data = OBJECT_COLOR_DATA (obj);\n-\n-      node = obj_data->hard_regs_node;\n-      node_preorder_num = node->preorder_num;\n-      removed_node = OBJECT_COLOR_DATA (removed_obj)->hard_regs_node;\n-      if (! hard_reg_set_subset_p (removed_node->hard_regs->set,\n-\t\t\t\t   node->hard_regs->set)\n-\t  && ! hard_reg_set_subset_p (node->hard_regs->set,\n-\t\t\t\t      removed_node->hard_regs->set))\n-\t/* It is a rare case which can happen for conflicting\n-\t   multi-object allocnos where only one pair of objects might\n-\t   conflict.  */\n-\tcontinue;\n-      start = node_preorder_num * object_hard_regs_nodes_num;\n-      i = object_hard_regs_subnode_index[start + removed_node->preorder_num];\n-      if (i < 0)\n-\ti = 0;\n-      subnodes = object_hard_regs_subnodes + obj_data->hard_regs_subnodes_start;\n+      conflict_size\n+\t= (subnodes[i].left_conflict_subnodes_size\n+\t   + MIN (subnodes[i].max_node_impact\n+\t\t  - subnodes[i].left_conflict_subnodes_size,\n+\t\t  subnodes[i].left_conflict_size));\n+      if ((diff = before_conflict_size - conflict_size) == 0)\n+\tbreak;\n+      ira_assert (conflict_size < before_conflict_size);\n+      parent = allocno_hard_regs_nodes[i + node_preorder_num]->parent;\n+      if (parent == NULL)\n+\tbreak;\n+      parent_i\n+\t= allocno_hard_regs_subnode_index[start + parent->preorder_num];\n+      if (parent_i < 0)\n+\tbreak;\n+      i = parent_i;\n       before_conflict_size\n \t= (subnodes[i].left_conflict_subnodes_size\n \t   + MIN (subnodes[i].max_node_impact\n \t\t  - subnodes[i].left_conflict_subnodes_size,\n \t\t  subnodes[i].left_conflict_size));\n-      subnodes[i].left_conflict_size -= size;\n-      for (;;)\n-\t{\n-\t  conflict_size\n-\t    = (subnodes[i].left_conflict_subnodes_size\n-\t       + MIN (subnodes[i].max_node_impact\n-\t\t      - subnodes[i].left_conflict_subnodes_size,\n-\t\t      subnodes[i].left_conflict_size));\n-\t  if ((diff = before_conflict_size - conflict_size) == 0)\n-\t    break;\n-\t  ira_assert (conflict_size < before_conflict_size);\n-\t  parent = object_hard_regs_nodes[i + node_preorder_num]->parent;\n-\t  if (parent == NULL)\n-\t    break;\n-\t  parent_i\n-\t    = object_hard_regs_subnode_index[start + parent->preorder_num];\n-\t  if (parent_i < 0)\n-\t    break;\n-\t  i = parent_i;\n-\t  before_conflict_size\n-\t    = (subnodes[i].left_conflict_subnodes_size\n-\t       + MIN (subnodes[i].max_node_impact\n-\t\t      - subnodes[i].left_conflict_subnodes_size,\n-\t\t      subnodes[i].left_conflict_size));\n-\t  subnodes[i].left_conflict_subnodes_size -= diff;\n-\t}\n-      if (i != 0\n-\t  || (conflict_size \n-\t      + ira_reg_class_max_nregs[ALLOCNO_CLASS (a)][ALLOCNO_MODE (a)]\n-\t      > data->available_regs_num))\n-\t{\n-\t  colorable_p = false;\n-\t  break;\n-\t}\n-      }\n-  if (colorable_p)\n-    {\n-      data->colorable_p = true;\n-      return true;\n+      subnodes[i].left_conflict_subnodes_size -= diff;\n     }\n-  return false;\n+  if (i != 0\n+      || (conflict_size \n+\t  + ira_reg_class_max_nregs[ALLOCNO_CLASS (a)][ALLOCNO_MODE (a)]\n+\t  > data->available_regs_num))\n+    return false;\n+  data->colorable_p = true;\n+  return true;\n }\n \n-/* Return true if allocno A has an object with empty profitable hard\n-   regs.  */\n+/* Return true if allocno A has empty profitable hard regs.  */\n static bool\n empty_profitable_hard_regs (ira_allocno_t a)\n {\n-  int k, nobj;\n-\n-  nobj = ALLOCNO_NUM_OBJECTS (a);\n-  for (k = 0; k < nobj; k++)\n-    {\n-      ira_object_t obj = ALLOCNO_OBJECT (a, k);\n-      object_color_data_t obj_data = OBJECT_COLOR_DATA (obj);\n+  allocno_color_data_t data = ALLOCNO_COLOR_DATA (a);\n \n-      if (hard_reg_set_empty_p (obj_data->profitable_hard_regs))\n-\treturn true;\n-    }\n-  return false;\n+  return hard_reg_set_empty_p (data->profitable_hard_regs);\n }\n \n /* Set up profitable hard registers for each allocno being\n@@ -1056,6 +1011,7 @@ setup_profitable_hard_regs (void)\n   bitmap_iterator bi;\n   enum reg_class aclass;\n   enum machine_mode mode;\n+  allocno_color_data_t data;\n \n   /* Initial set up from allocno classes and explicitly conflicting\n      hard regs.  */\n@@ -1064,23 +1020,22 @@ setup_profitable_hard_regs (void)\n       a = ira_allocnos[i];\n       if ((aclass = ALLOCNO_CLASS (a)) == NO_REGS)\n \tcontinue;\n-      mode = ALLOCNO_MODE (a);\n-      nobj = ALLOCNO_NUM_OBJECTS (a);\n-      for (k = 0; k < nobj; k++)\n+      data = ALLOCNO_COLOR_DATA (a);\n+      if (ALLOCNO_UPDATED_HARD_REG_COSTS (a) == NULL\n+\t  && ALLOCNO_CLASS_COST (a) > ALLOCNO_MEMORY_COST (a))\n+\tCLEAR_HARD_REG_SET (data->profitable_hard_regs);\n+      else\n \t{\n-\t  ira_object_t obj = ALLOCNO_OBJECT (a, k);\n-\t  object_color_data_t obj_data = OBJECT_COLOR_DATA (obj);\n-\n-\t  if (ALLOCNO_UPDATED_HARD_REG_COSTS (a) == NULL\n-\t      && ALLOCNO_CLASS_COST (a) > ALLOCNO_MEMORY_COST (a))\n-\t    CLEAR_HARD_REG_SET (obj_data->profitable_hard_regs);\n-\t  else\n+\t  COPY_HARD_REG_SET (data->profitable_hard_regs,\n+\t\t\t     reg_class_contents[aclass]);\n+\t  AND_COMPL_HARD_REG_SET (data->profitable_hard_regs,\n+\t\t\t\t  ira_no_alloc_regs);\n+\t  nobj = ALLOCNO_NUM_OBJECTS (a);\n+\t  for (k = 0; k < nobj; k++)\n \t    {\n-\t      COPY_HARD_REG_SET (obj_data->profitable_hard_regs,\n-\t\t\t\t reg_class_contents[aclass]);\n-\t      AND_COMPL_HARD_REG_SET (obj_data->profitable_hard_regs,\n-\t\t\t\t      ira_no_alloc_regs);\n-\t      AND_COMPL_HARD_REG_SET (obj_data->profitable_hard_regs,\n+\t      ira_object_t obj = ALLOCNO_OBJECT (a, k);\n+\t      \n+\t      AND_COMPL_HARD_REG_SET (data->profitable_hard_regs,\n \t\t\t\t      OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n \t    }\n \t}\n@@ -1104,22 +1059,26 @@ setup_profitable_hard_regs (void)\n \n \t  FOR_EACH_OBJECT_CONFLICT (obj, conflict_obj, oci)\n \t    {\n+\t      ira_allocno_t conflict_a = OBJECT_ALLOCNO (conflict_obj);\n+\n+\t      /* We can process the conflict allocno repeatedly with\n+\t\t the same result.  */\n \t      if (nregs == nobj && nregs > 1)\n \t\t{\n \t\t  int num = OBJECT_SUBWORD (conflict_obj);\n \t\t  \n \t\t  if (WORDS_BIG_ENDIAN)\n \t\t    CLEAR_HARD_REG_BIT\n-\t\t      (OBJECT_COLOR_DATA (conflict_obj)->profitable_hard_regs,\n+\t\t      (ALLOCNO_COLOR_DATA (conflict_a)->profitable_hard_regs,\n \t\t       hard_regno + nobj - num - 1);\n \t\t  else\n \t\t    CLEAR_HARD_REG_BIT\n-\t\t      (OBJECT_COLOR_DATA (conflict_obj)->profitable_hard_regs,\n+\t\t      (ALLOCNO_COLOR_DATA (conflict_a)->profitable_hard_regs,\n \t\t       hard_regno + num);\n \t\t}\n \t      else\n \t\tAND_COMPL_HARD_REG_SET\n-\t\t  (OBJECT_COLOR_DATA (conflict_obj)->profitable_hard_regs,\n+\t\t  (ALLOCNO_COLOR_DATA (conflict_a)->profitable_hard_regs,\n \t\t   ira_reg_mode_hard_regset[hard_regno][mode]);\n \t    }\n \t}\n@@ -1134,44 +1093,28 @@ setup_profitable_hard_regs (void)\n       if ((aclass = ALLOCNO_CLASS (a)) == NO_REGS\n \t  || empty_profitable_hard_regs (a))\n \tcontinue;\n+      data = ALLOCNO_COLOR_DATA (a);\n       mode = ALLOCNO_MODE (a);\n-      nobj = ALLOCNO_NUM_OBJECTS (a);\n-      for (k = 0; k < nobj; k++)\n+      if ((costs = ALLOCNO_UPDATED_HARD_REG_COSTS (a)) != NULL\n+\t  || (costs = ALLOCNO_HARD_REG_COSTS (a)) != NULL)\n \t{\n-\t  ira_object_t obj = ALLOCNO_OBJECT (a, k);\n-\t  object_color_data_t obj_data = OBJECT_COLOR_DATA (obj);\n-\n-\t  if ((costs = ALLOCNO_UPDATED_HARD_REG_COSTS (a)) != NULL\n-\t      || (costs = ALLOCNO_HARD_REG_COSTS (a)) != NULL)\n+\t  class_size = ira_class_hard_regs_num[aclass];\n+\t  for (j = 0; j < class_size; j++)\n \t    {\n-\t      class_size = ira_class_hard_regs_num[aclass];\n-\t      for (j = 0; j < class_size; j++)\n-\t\t{\n-\t\t  hard_regno = ira_class_hard_regs[aclass][j];\n-\t\t  nregs = hard_regno_nregs[hard_regno][mode];\n-\t\t  if (nregs == nobj && nregs > 1)\n-\t\t    {\n-\t\t      int num = OBJECT_SUBWORD (obj);\n-\n-\t\t      if (WORDS_BIG_ENDIAN)\n-\t\t\thard_regno += nobj - num - 1;\n-\t\t      else\n-\t\t\thard_regno += num;\n-\t\t    }\n-\t\t  if (! TEST_HARD_REG_BIT (obj_data->profitable_hard_regs,\n-\t\t\t\t\t   hard_regno))\n-\t\t    continue;\n-\t\t  if (ALLOCNO_UPDATED_MEMORY_COST (a) < costs[j])\n-\t\t    CLEAR_HARD_REG_BIT (obj_data->profitable_hard_regs,\n-\t\t\t\t\thard_regno);\n-\t\t  else if (min_cost > costs[j])\n-\t\t    min_cost = costs[j];\n-\t\t}\n+\t      hard_regno = ira_class_hard_regs[aclass][j];\n+\t      if (! TEST_HARD_REG_BIT (data->profitable_hard_regs,\n+\t\t\t\t       hard_regno))\n+\t\tcontinue;\n+\t      if (ALLOCNO_UPDATED_MEMORY_COST (a) < costs[j])\n+\t\tCLEAR_HARD_REG_BIT (data->profitable_hard_regs,\n+\t\t\t\t    hard_regno);\n+\t      else if (min_cost > costs[j])\n+\t\tmin_cost = costs[j];\n \t    }\n-\t  else if (ALLOCNO_UPDATED_MEMORY_COST (a)\n-\t\t   < ALLOCNO_UPDATED_CLASS_COST (a))\n-\t    CLEAR_HARD_REG_SET (obj_data->profitable_hard_regs);\n \t}\n+      else if (ALLOCNO_UPDATED_MEMORY_COST (a)\n+\t       < ALLOCNO_UPDATED_CLASS_COST (a))\n+\tCLEAR_HARD_REG_SET (data->profitable_hard_regs);\n       if (ALLOCNO_UPDATED_CLASS_COST (a) > min_cost)\n \tALLOCNO_UPDATED_CLASS_COST (a) = min_cost;\n     }\n@@ -1447,14 +1390,16 @@ update_conflict_hard_regno_costs (int *costs, enum reg_class aclass,\n       }\n }\n \n-/* Set up conflicting and profitable regs (through CONFLICT_REGS and\n-   PROFITABLE_REGS) for each object of allocno A.  Remember that the\n-   profitable regs exclude hard regs which can not hold value of mode\n-   of allocno A.  */\n+/* Set up conflicting (through CONFLICT_REGS) for each object of\n+   allocno A and the start allocno profitable regs (through\n+   START_PROFITABLE_REGS).  Remember that the start profitable regs\n+   exclude hard regs which can not hold value of mode of allocno A.\n+   This covers mostly cases when multi-register value should be\n+   aligned.  */\n static inline void\n-get_conflict_profitable_regs (ira_allocno_t a, bool retry_p,\n-\t\t\t      HARD_REG_SET *conflict_regs,\n-\t\t\t      HARD_REG_SET *profitable_regs)\n+get_conflict_and_start_profitable_regs (ira_allocno_t a, bool retry_p,\n+\t\t\t\t\tHARD_REG_SET *conflict_regs,\n+\t\t\t\t\tHARD_REG_SET *start_profitable_regs)\n {\n   int i, nwords;\n   ira_object_t obj;\n@@ -1465,25 +1410,25 @@ get_conflict_profitable_regs (ira_allocno_t a, bool retry_p,\n       obj = ALLOCNO_OBJECT (a, i);\n       COPY_HARD_REG_SET (conflict_regs[i],\n \t\t\t OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));\n-      if (retry_p)\n-\t{\n-\t  COPY_HARD_REG_SET (profitable_regs[i],\n-\t\t\t     reg_class_contents[ALLOCNO_CLASS (a)]);\n-\t  AND_COMPL_HARD_REG_SET (profitable_regs[i],\n-\t\t\t\t  ira_prohibited_class_mode_regs\n-\t\t\t\t  [ALLOCNO_CLASS (a)][ALLOCNO_MODE (a)]);\n-\t}\n-      else\n-\tCOPY_HARD_REG_SET (profitable_regs[i],\n-\t\t\t   OBJECT_COLOR_DATA (obj)->profitable_hard_regs);\n     }\n+  if (retry_p)\n+    {\n+      COPY_HARD_REG_SET (*start_profitable_regs,\n+\t\t\t reg_class_contents[ALLOCNO_CLASS (a)]);\n+      AND_COMPL_HARD_REG_SET (*start_profitable_regs,\n+\t\t\t      ira_prohibited_class_mode_regs\n+\t\t\t      [ALLOCNO_CLASS (a)][ALLOCNO_MODE (a)]);\n+    }\n+  else\n+    COPY_HARD_REG_SET (*start_profitable_regs,\n+\t\t       ALLOCNO_COLOR_DATA (a)->profitable_hard_regs);\n }\n \n-/* Return true if HARD_REGNO is ok for assigning to allocno A whose\n-   objects have corresponding CONFLICT_REGS and PROFITABLE_REGS.  */\n+/* Return true if HARD_REGNO is ok for assigning to allocno A with\n+   PROFITABLE_REGS and whose objects have CONFLICT_REGS.  */\n static inline bool\n check_hard_reg_p (ira_allocno_t a, int hard_regno,\n-\t\t  HARD_REG_SET *conflict_regs, HARD_REG_SET *profitable_regs)\n+\t\t  HARD_REG_SET *conflict_regs, HARD_REG_SET profitable_regs)\n {\n   int j, nwords, nregs;\n   enum reg_class aclass;\n@@ -1494,6 +1439,9 @@ check_hard_reg_p (ira_allocno_t a, int hard_regno,\n   if (TEST_HARD_REG_BIT (ira_prohibited_class_mode_regs[aclass][mode],\n \t\t\t hard_regno))\n     return false;\n+  /* Checking only profitable hard regs.  */\n+  if (! TEST_HARD_REG_BIT (profitable_regs, hard_regno))\n+    return false;\n   nregs = hard_regno_nregs[hard_regno][mode];\n   nwords = ALLOCNO_NUM_OBJECTS (a);\n   for (j = 0; j < nregs; j++)\n@@ -1510,9 +1458,7 @@ check_hard_reg_p (ira_allocno_t a, int hard_regno,\n \t  set_to_test_end = set_to_test_start + 1;\n \t}\n       for (k = set_to_test_start; k < set_to_test_end; k++)\n-\t/* Checking only profitable hard regs.  */\n-\tif (TEST_HARD_REG_BIT (conflict_regs[k], hard_regno + j)\n-\t    || ! TEST_HARD_REG_BIT (profitable_regs[k], hard_regno + j))\n+\tif (TEST_HARD_REG_BIT (conflict_regs[k], hard_regno + j))\n \t  break;\n       if (k != set_to_test_end)\n \tbreak;\n@@ -1566,7 +1512,7 @@ calculate_saved_nregs (int hard_regno, enum machine_mode mode)\n static bool\n assign_hard_reg (ira_allocno_t a, bool retry_p)\n {\n-  HARD_REG_SET conflicting_regs[2], profitable_hard_regs[2];\n+  HARD_REG_SET conflicting_regs[2], profitable_hard_regs;\n   int i, j, hard_regno, best_hard_regno, class_size;\n   int cost, mem_cost, min_cost, full_cost, min_full_cost, nwords, word;\n   int *a_costs;\n@@ -1583,8 +1529,9 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n #endif\n \n   ira_assert (! ALLOCNO_ASSIGNED_P (a));\n-  get_conflict_profitable_regs (a, retry_p,\n-\t\t\t\tconflicting_regs, profitable_hard_regs);\n+  get_conflict_and_start_profitable_regs (a, retry_p,\n+\t\t\t\t\t  conflicting_regs,\n+\t\t\t\t\t  &profitable_hard_regs);\n   aclass = ALLOCNO_CLASS (a);\n   class_size = ira_class_hard_regs_num[aclass];\n   best_hard_regno = -1;\n@@ -1618,6 +1565,7 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n \tfull_costs[i] += cost;\n       }\n   nwords = ALLOCNO_NUM_OBJECTS (a);\n+  curr_allocno_process++;\n   for (word = 0; word < nwords; word++)\n     {\n       ira_object_t conflict_obj;\n@@ -1638,9 +1586,9 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n \t\t  || ((!ALLOCNO_ASSIGNED_P (conflict_a)\n \t\t       || ALLOCNO_HARD_REGNO (conflict_a) < 0)\n \t\t      && !(hard_reg_set_intersect_p\n-\t\t\t   (profitable_hard_regs[word],\n-\t\t\t    OBJECT_COLOR_DATA\n-\t\t\t    (conflict_obj)->profitable_hard_regs)))))\n+\t\t\t   (profitable_hard_regs,\n+\t\t\t    ALLOCNO_COLOR_DATA\n+\t\t\t    (conflict_a)->profitable_hard_regs)))))\n \t    continue;\n \t  conflict_aclass = ALLOCNO_CLASS (conflict_a);\n \t  ira_assert (ira_reg_classes_intersect_p\n@@ -1673,16 +1621,21 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n \t\t    IOR_HARD_REG_SET\n \t\t      (conflicting_regs[word],\n \t\t       ira_reg_mode_hard_regset[hard_regno][mode]);\n-\t\t  if (hard_reg_set_subset_p (profitable_hard_regs[word],\n+\t\t  if (hard_reg_set_subset_p (profitable_hard_regs,\n \t\t\t\t\t     conflicting_regs[word]))\n \t\t    goto fail;\n \t\t}\n \t    }\n \t  else if (! retry_p\n-\t\t   && ! ALLOCNO_COLOR_DATA (conflict_a)->may_be_spilled_p)\n+\t\t   && ! ALLOCNO_COLOR_DATA (conflict_a)->may_be_spilled_p\n+\t\t   /* Don't process the conflict allocno twice.  */\n+\t\t   && (ALLOCNO_COLOR_DATA (conflict_a)->last_process\n+\t\t       != curr_allocno_process))\n \t    {\n \t      int k, *conflict_costs;\n \t      \n+\t      ALLOCNO_COLOR_DATA (conflict_a)->last_process\n+\t\t= curr_allocno_process;\n \t      ira_allocate_and_copy_costs\n \t\t(&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (conflict_a),\n \t\t conflict_aclass,\n@@ -1983,15 +1936,15 @@ push_allocno_to_stack (ira_allocno_t a)\n \t      || ! conflict_data->in_graph_p\n \t      || ALLOCNO_ASSIGNED_P (conflict_a)\n \t      || !(hard_reg_set_intersect_p\n-\t\t   (OBJECT_COLOR_DATA (obj)->profitable_hard_regs,\n-\t\t    OBJECT_COLOR_DATA (conflict_obj)->profitable_hard_regs)))\n+\t\t   (ALLOCNO_COLOR_DATA (a)->profitable_hard_regs,\n+\t\t    conflict_data->profitable_hard_regs)))\n \t    continue;\n \t  ira_assert (bitmap_bit_p (coloring_allocno_bitmap,\n \t\t\t\t    ALLOCNO_NUM (conflict_a)));\n-\t  if (update_left_conflict_sizes_p (conflict_a, obj, size))\n+\t  if (update_left_conflict_sizes_p (conflict_a, a, size))\n \t    {\n \t      delete_allocno_from_bucket\n-\t\t    (conflict_a, &uncolorable_allocno_bucket);\n+\t\t(conflict_a, &uncolorable_allocno_bucket);\n \t      add_allocno_to_ordered_bucket\n \t\t(conflict_a, &colorable_allocno_bucket);\n \t      if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n@@ -2228,9 +2181,8 @@ pop_allocnos_from_stack (void)\n static void\n setup_allocno_available_regs_num (ira_allocno_t a)\n {\n-  int i, j, n, hard_regno, hard_regs_num, nwords, nregs;\n+  int i, n, hard_regno, hard_regs_num, nwords;\n   enum reg_class aclass;\n-  enum machine_mode mode;\n   allocno_color_data_t data;\n \n   aclass = ALLOCNO_CLASS (a);\n@@ -2239,74 +2191,43 @@ setup_allocno_available_regs_num (ira_allocno_t a)\n   if (aclass == NO_REGS)\n     return;\n   hard_regs_num = ira_class_hard_regs_num[aclass];\n-  mode = ALLOCNO_MODE (a);\n   nwords = ALLOCNO_NUM_OBJECTS (a);\n   for (n = 0, i = hard_regs_num - 1; i >= 0; i--)\n     {\n       hard_regno = ira_class_hard_regs[aclass][i];\n-      nregs = hard_regno_nregs[hard_regno][mode];\n-      for (j = 0; j < nregs; j++)\n-\t{\n-\t  int k;\n-\t  int set_to_test_start = 0, set_to_test_end = nwords;\n-\n-\t  if (nregs == nwords)\n-\t    {\n-\t      if (WORDS_BIG_ENDIAN)\n-\t\tset_to_test_start = nwords - j - 1;\n-\t      else\n-\t\tset_to_test_start = j;\n-\t      set_to_test_end = set_to_test_start + 1;\n-\t    }\n-\t  for (k = set_to_test_start; k < set_to_test_end; k++)\n-\t    {\n-\t      ira_object_t obj = ALLOCNO_OBJECT (a, k);\n-\t      object_color_data_t obj_data = OBJECT_COLOR_DATA (obj);\n-\n-\t      /* Checking only profitable hard regs which exclude\n-\t\t object's conflict hard regs.  */\n-\t      if (TEST_HARD_REG_BIT (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n-\t\t\t\t     hard_regno + j)\n-\t\t  || ! TEST_HARD_REG_BIT (obj_data->profitable_hard_regs,\n-\t\t\t\t\t  hard_regno + j))\n-\t\tbreak;\n-\t    }\n-\t  if (k != set_to_test_end)\n-\t    break;\n-\t}\n-      if (j == nregs)\n+      /* Checking only profitable hard regs.  */\n+      if (TEST_HARD_REG_BIT (data->profitable_hard_regs, hard_regno))\n \tn++;\n     }\n   data->available_regs_num = n;\n   if (internal_flag_ira_verbose <= 2 || ira_dump_file == NULL)\n     return;\n   fprintf\n     (ira_dump_file,\n-     \"      Allocno a%dr%d of %s(%d) has %d avail. regs\",\n+     \"      Allocno a%dr%d of %s(%d) has %d avail. regs \",\n      ALLOCNO_NUM (a), ALLOCNO_REGNO (a),\n      reg_class_names[aclass], ira_class_hard_regs_num[aclass], n);\n+  print_hard_reg_set (ira_dump_file, data->profitable_hard_regs, false);\n+  fprintf (ira_dump_file, \", %snode: \",\n+\t   hard_reg_set_equal_p (data->profitable_hard_regs,\n+\t\t\t\t data->hard_regs_node->hard_regs->set)\n+\t   ? \"\" : \"^\");\n+  print_hard_reg_set (ira_dump_file,\n+\t\t      data->hard_regs_node->hard_regs->set, false);\n   for (i = 0; i < nwords; i++)\n     {\n       ira_object_t obj = ALLOCNO_OBJECT (a, i);\n-      object_color_data_t obj_data = OBJECT_COLOR_DATA (obj);\n \n       if (nwords != 1)\n \t{\n \t  if (i != 0)\n \t    fprintf (ira_dump_file, \", \");\n \t  fprintf (ira_dump_file, \" obj %d\", i);\n \t}\n-      print_hard_reg_set (ira_dump_file, obj_data->profitable_hard_regs, false);\n       fprintf (ira_dump_file, \" (confl regs = \");\n       print_hard_reg_set (ira_dump_file, OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),\n \t\t\t  false);\n-      fprintf (ira_dump_file, \" ) %snode: \",\n-\t       hard_reg_set_equal_p (obj_data->profitable_hard_regs,\n-\t\t\t\t     obj_data->hard_regs_node->hard_regs->set)\n-\t       ? \"\" : \"^\");\n-      print_hard_reg_set (ira_dump_file,\n-\t\t\t  obj_data->hard_regs_node->hard_regs->set, false);\n-\n+      fprintf (ira_dump_file, \")\");\n     }\n   fprintf (ira_dump_file, \"\\n\");\n }\n@@ -2402,7 +2323,7 @@ improve_allocation (void)\n   enum machine_mode mode;\n   int *allocno_costs;\n   int costs[FIRST_PSEUDO_REGISTER];\n-  HARD_REG_SET conflicting_regs[2], profitable_hard_regs[2];\n+  HARD_REG_SET conflicting_regs[2], profitable_hard_regs;\n   ira_allocno_t a;\n   bitmap_iterator bi;\n \n@@ -2434,8 +2355,9 @@ improve_allocation (void)\n       else\n \tbase_cost = allocno_costs[ira_class_hard_reg_index[aclass][hregno]];\n       try_p = false;\n-      get_conflict_profitable_regs (a, false,\n-\t\t\t\t    conflicting_regs, profitable_hard_regs);\n+      get_conflict_and_start_profitable_regs (a, false,\n+\t\t\t\t\t      conflicting_regs,\n+\t\t\t\t\t      &profitable_hard_regs);\n       class_size = ira_class_hard_regs_num[aclass];\n       /* Set up cost improvement for usage of each profitable hard\n \t register for allocno A.  */\n@@ -2684,7 +2606,7 @@ color_allocnos (void)\n     }\n   else\n     {\n-      form_object_hard_regs_nodes_forest ();\n+      form_allocno_hard_regs_nodes_forest ();\n       if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n \tprint_hard_regs_forest (ira_dump_file);\n       EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, i, bi)\n@@ -2717,7 +2639,7 @@ color_allocnos (void)\n \t}\n       push_allocnos_to_stack ();\n       pop_allocnos_from_stack ();\n-      finish_object_hard_regs_nodes_forest ();\n+      finish_allocno_hard_regs_nodes_forest ();\n     }\n   improve_allocation ();\n }\n@@ -2785,7 +2707,7 @@ print_loop_title (ira_loop_tree_node_t loop_tree_node)\n static void\n color_pass (ira_loop_tree_node_t loop_tree_node)\n {\n-  int i, regno, hard_regno, index = -1, n, nobj;\n+  int regno, hard_regno, index = -1, n;\n   int cost, exit_freq, enter_freq;\n   unsigned int j;\n   bitmap_iterator bi;\n@@ -2800,12 +2722,11 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \n   bitmap_copy (coloring_allocno_bitmap, loop_tree_node->all_allocnos);\n   bitmap_copy (consideration_allocno_bitmap, coloring_allocno_bitmap);\n-  n = nobj = 0;\n+  n = 0;\n   EXECUTE_IF_SET_IN_BITMAP (consideration_allocno_bitmap, 0, j, bi)\n     {\n       a = ira_allocnos[j];\n       n++;\n-      nobj += ALLOCNO_NUM_OBJECTS (a);\n       if (! ALLOCNO_ASSIGNED_P (a))\n \tcontinue;\n       bitmap_clear_bit (coloring_allocno_bitmap, ALLOCNO_NUM (a));\n@@ -2814,21 +2735,13 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n     = (allocno_color_data_t) ira_allocate (sizeof (struct allocno_color_data)\n \t\t\t\t\t   * n);\n   memset (allocno_color_data, 0, sizeof (struct allocno_color_data) * n);\n-  object_color_data\n-    = (object_color_data_t) ira_allocate (sizeof (struct object_color_data)\n-\t\t\t\t\t   * nobj);\n-  memset (object_color_data, 0, sizeof (struct object_color_data) * nobj);\n-  n = nobj = 0;\n+  curr_allocno_process = 0;\n+  n = 0;\n   EXECUTE_IF_SET_IN_BITMAP (consideration_allocno_bitmap, 0, j, bi)\n     {\n       a = ira_allocnos[j];\n       ALLOCNO_ADD_DATA (a) = allocno_color_data + n;\n       n++;\n-      for (i = 0; i < ALLOCNO_NUM_OBJECTS (a); i++)\n-\t{\n-\t  OBJECT_ADD_DATA (ALLOCNO_OBJECT (a, i)) = object_color_data + nobj;\n-\t  nobj++;\n-\t}\n     }\n   /* Color all mentioned allocnos including transparent ones.  */\n   color_allocnos ();\n@@ -2960,14 +2873,11 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t    }\n \t}\n     }\n-  ira_free (object_color_data);\n   ira_free (allocno_color_data);\n   EXECUTE_IF_SET_IN_BITMAP (coloring_allocno_bitmap, 0, j, bi)\n     {\n       a = ira_allocnos[j];\n       ALLOCNO_ADD_DATA (a) = NULL;\n-      for (i = 0; i < ALLOCNO_NUM_OBJECTS (a); i++)\n-\tOBJECT_ADD_DATA (a) = NULL;\n     }\n }\n "}, {"sha": "61998942d9e96a3401032b96bb99c3b2e0640afe", "filename": "gcc/ira-int.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27508f5fa3c79ca39d32079348017c6132d25722/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27508f5fa3c79ca39d32079348017c6132d25722/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=27508f5fa3c79ca39d32079348017c6132d25722", "patch": "@@ -262,9 +262,6 @@ struct ira_object\n      ira_object structures.  Otherwise, we use a bit vector indexed\n      by conflict ID numbers.  */\n   unsigned int conflict_vec_p : 1;\n-  /* Different additional data.  It is used to decrease size of\n-     allocno data footprint.  */\n-  void *add_data;\n };\n \n /* A structure representing an allocno (allocation entity).  Allocno\n@@ -499,7 +496,6 @@ allocno_emit_reg (ira_allocno_t a)\n #define OBJECT_MAX(O) ((O)->max)\n #define OBJECT_CONFLICT_ID(O) ((O)->id)\n #define OBJECT_LIVE_RANGES(O) ((O)->live_ranges)\n-#define OBJECT_ADD_DATA(O) ((O)->add_data)\n \n /* Map regno -> allocnos with given regno (see comments for\n    allocno member `next_regno_allocno').  */"}]}