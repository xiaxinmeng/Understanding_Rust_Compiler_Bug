{"sha": "a2581005856d53ccff513e04c05a85c97ef474df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI1ODEwMDU4NTZkNTNjY2ZmNTEzZTA0YzA1YTg1Yzk3ZWY0NzRkZg==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gmx.de", "date": "2015-03-24T11:47:45Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2015-03-24T11:47:45Z"}, "message": "re PR fortran/55901 ([OOP] type is (character(len=*)) misinterpreted as array)\n\n2015-03-24  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/55901\n\t* trans-expr.c (gfc_conv_structure): Fixed indendation.\n\tUsing integer_zero_node now instead of explicitly\n\tconstructing a integer constant zero node.\n\t(gfc_conv_derived_to_class): Add handling of _len component,\n\ti.e., when the rhs has a string_length then assign that to\n\tclass' _len, else assign 0.\n\t(gfc_conv_intrinsic_to_class): Likewise.\n\nFrom-SVN: r221627", "tree": {"sha": "b618f7a46a9cfa0f75d4ea733faf57cd2c56326b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b618f7a46a9cfa0f75d4ea733faf57cd2c56326b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2581005856d53ccff513e04c05a85c97ef474df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2581005856d53ccff513e04c05a85c97ef474df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2581005856d53ccff513e04c05a85c97ef474df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2581005856d53ccff513e04c05a85c97ef474df/comments", "author": {"login": "vehre", "id": 4761547, "node_id": "MDQ6VXNlcjQ3NjE1NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4761547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vehre", "html_url": "https://github.com/vehre", "followers_url": "https://api.github.com/users/vehre/followers", "following_url": "https://api.github.com/users/vehre/following{/other_user}", "gists_url": "https://api.github.com/users/vehre/gists{/gist_id}", "starred_url": "https://api.github.com/users/vehre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vehre/subscriptions", "organizations_url": "https://api.github.com/users/vehre/orgs", "repos_url": "https://api.github.com/users/vehre/repos", "events_url": "https://api.github.com/users/vehre/events{/privacy}", "received_events_url": "https://api.github.com/users/vehre/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "29ec68cb98fbf1eedfaead7afc7673e9cd229b24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ec68cb98fbf1eedfaead7afc7673e9cd229b24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ec68cb98fbf1eedfaead7afc7673e9cd229b24"}], "stats": {"total": 125, "additions": 85, "deletions": 40}, "files": [{"sha": "7c330c7ec213aaac237ad1168eb73541eb981803", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2581005856d53ccff513e04c05a85c97ef474df/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2581005856d53ccff513e04c05a85c97ef474df/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a2581005856d53ccff513e04c05a85c97ef474df", "patch": "@@ -1,3 +1,14 @@\n+2015-03-24  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/55901\n+\t* trans-expr.c (gfc_conv_structure): Fixed indendation.\n+\tUsing integer_zero_node now instead of explicitly\n+\tconstructing a integer constant zero node.\n+\t(gfc_conv_derived_to_class): Add handling of _len component,\n+\ti.e., when the rhs has a string_length then assign that to\n+\tclass' _len, else assign 0.\n+\t(gfc_conv_intrinsic_to_class): Likewise.\n+\n 2015-03-24  Andre Vehreschild  <vehre@gmx.de>\n \n \tPR fortran/64787"}, {"sha": "88f1af80e01b7669a388a169c22610383b5edb07", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 74, "deletions": 40, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2581005856d53ccff513e04c05a85c97ef474df/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2581005856d53ccff513e04c05a85c97ef474df/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a2581005856d53ccff513e04c05a85c97ef474df", "patch": "@@ -569,6 +569,34 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \t}\n     }\n \n+  if (class_ts.u.derived->components->ts.type == BT_DERIVED\n+      && class_ts.u.derived->components->ts.u.derived\n+\t\t ->attr.unlimited_polymorphic)\n+    {\n+      /* Take care about initializing the _len component correctly.  */\n+      ctree = gfc_class_len_get (var);\n+      if (UNLIMITED_POLY (e))\n+\t{\n+\t  gfc_expr *len;\n+\t  gfc_se se;\n+\n+\t  len = gfc_copy_expr (e);\n+\t  gfc_add_len_component (len);\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr (&se, len);\n+\t  if (optional)\n+\t    tmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (se.expr),\n+\t\t\t      cond_optional, se.expr,\n+\t\t\t      fold_convert (TREE_TYPE (se.expr),\n+\t\t\t\t\t    integer_zero_node));\n+\t  else\n+\t    tmp = se.expr;\n+\t}\n+      else\n+\ttmp = integer_zero_node;\n+      gfc_add_modify (&parmse->pre, ctree, fold_convert (TREE_TYPE (ctree),\n+\t\t\t\t\t\t\t  tmp));\n+    }\n   /* Pass the address of the class object.  */\n   parmse->expr = gfc_build_addr_expr (NULL_TREE, var);\n \n@@ -727,44 +755,54 @@ gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,\n \t}\n     }\n \n-  /* When the actual arg is a char array, then set the _len component of the\n-     unlimited polymorphic entity, too.  */\n-  if (e->ts.type == BT_CHARACTER)\n+  gcc_assert (class_ts.type == BT_CLASS);\n+  if (class_ts.u.derived->components->ts.type == BT_DERIVED\n+      && class_ts.u.derived->components->ts.u.derived\n+\t\t ->attr.unlimited_polymorphic)\n     {\n       ctree = gfc_class_len_get (var);\n-      /* Start with parmse->string_length because this seems to be set to a\n-\t correct value more often.  */\n-      if (parmse->string_length)\n-\t  gfc_add_modify (&parmse->pre, ctree, parmse->string_length);\n-      /* When the string_length is not yet set, then try the backend_decl of\n-\t the cl.  */\n-      else if (e->ts.u.cl->backend_decl)\n-          gfc_add_modify (&parmse->pre, ctree, e->ts.u.cl->backend_decl);\n-      /* If both of the above approaches fail, then try to generate an\n-\t expression from the input, which is only feasible currently, when the\n-\t expression can be evaluated to a constant one.  */\n-      else\n-        {\n-\t  /* Try to simplify the expression.  */\n-\t  gfc_simplify_expr (e, 0);\n-\t  if (e->expr_type == EXPR_CONSTANT && !e->ts.u.cl->resolved)\n-\t    {\n-\t      /* Amazingly all data is present to compute the length of a\n-\t\t constant string, but the expression is not yet there.  */\n-\t      e->ts.u.cl->length = gfc_get_constant_expr (BT_INTEGER, 4,\n-\t\t\t\t\t\t\t  &e->where);\n-\t      mpz_set_ui (e->ts.u.cl->length->value.integer,\n-\t\t\t  e->value.character.length);\n-\t      gfc_conv_const_charlen (e->ts.u.cl);\n-\t      e->ts.u.cl->resolved = 1;\n-\t      gfc_add_modify (&parmse->pre, ctree, e->ts.u.cl->backend_decl);\n-\t    }\n+      /* When the actual arg is a char array, then set the _len component of the\n+       unlimited polymorphic entity, too.  */\n+      if (e->ts.type == BT_CHARACTER)\n+\t{\n+\t  /* Start with parmse->string_length because this seems to be set to a\n+\t   correct value more often.  */\n+\t  if (parmse->string_length)\n+\t    tmp = parmse->string_length;\n+\t  /* When the string_length is not yet set, then try the backend_decl of\n+\t   the cl.  */\n+\t  else if (e->ts.u.cl->backend_decl)\n+\t    tmp = e->ts.u.cl->backend_decl;\n+\t  /* If both of the above approaches fail, then try to generate an\n+\t   expression from the input, which is only feasible currently, when the\n+\t   expression can be evaluated to a constant one.  */\n \t  else\n \t    {\n-\t      gfc_error (\"Can't compute the length of the char array at %L.\",\n-\t\t\t &e->where);\n+\t      /* Try to simplify the expression.  */\n+\t      gfc_simplify_expr (e, 0);\n+\t      if (e->expr_type == EXPR_CONSTANT && !e->ts.u.cl->resolved)\n+\t\t{\n+\t\t  /* Amazingly all data is present to compute the length of a\n+\t\t   constant string, but the expression is not yet there.  */\n+\t\t  e->ts.u.cl->length = gfc_get_constant_expr (BT_INTEGER, 4,\n+\t\t\t\t\t\t\t      &e->where);\n+\t\t  mpz_set_ui (e->ts.u.cl->length->value.integer,\n+\t\t\t      e->value.character.length);\n+\t\t  gfc_conv_const_charlen (e->ts.u.cl);\n+\t\t  e->ts.u.cl->resolved = 1;\n+\t\t  tmp = e->ts.u.cl->backend_decl;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gfc_error (\"Can't compute the length of the char array at %L.\",\n+\t\t\t     &e->where);\n+\t\t}\n \t    }\n \t}\n+      else\n+\ttmp = integer_zero_node;\n+\n+      gfc_add_modify (&parmse->pre, ctree, tmp);\n     }\n   /* Pass the address of the class object.  */\n   parmse->expr = gfc_build_addr_expr (NULL_TREE, var);\n@@ -7039,7 +7077,7 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n \t of EXPR_NULL,... by default, the static nullify is not needed\n \t since this is done every time we come into scope.  */\n       if (!c->expr || (cm->attr.allocatable && cm->attr.flavor != FL_PROCEDURE))\n-        continue;\n+\tcontinue;\n \n       if (cm->initializer && cm->initializer->expr_type != EXPR_NULL\n \t  && strcmp (cm->name, \"_extends\") == 0\n@@ -7060,13 +7098,9 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n \t\t\t\t\t\tval));\n \t}\n       else if (cm->ts.type == BT_INTEGER && strcmp (cm->name, \"_len\") == 0)\n-        {\n-          gfc_expr *e = gfc_get_int_expr (gfc_default_integer_kind, NULL, 0);\n-          val = gfc_conv_constant_to_tree (e);\n-          CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl,\n-                                  fold_convert (TREE_TYPE (cm->backend_decl),\n-                                                val));\n-        }\n+\tCONSTRUCTOR_APPEND_ELT (v, cm->backend_decl,\n+\t\t\t\tfold_convert (TREE_TYPE (cm->backend_decl),\n+\t\t\t\t\t      integer_zero_node));\n       else\n \t{\n \t  val = gfc_conv_initializer (c->expr, &cm->ts,"}]}