{"sha": "07ea0048ed82fe689ebc0f3fdccc634510ac0f99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdlYTAwNDhlZDgyZmU2ODllYmMwZjNmZGNjYzYzNDUxMGFjMGY5OQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2011-05-05T09:41:53Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2011-05-05T09:41:53Z"}, "message": "spu.c (TARGET_ASM_OUTPUT_MI_THUNK): Define.\n\n\t* config/spu/spu.c (TARGET_ASM_OUTPUT_MI_THUNK): Define.\n\t(TARGET_ASM_CAN_OUTPUT_MI_THUNK): Likewise.\n\t(spu_output_mi_thunk): New function.\n\nFrom-SVN: r173420", "tree": {"sha": "7fdec05d3cf8c9e9099bbb164bbe34a42a9b7aa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fdec05d3cf8c9e9099bbb164bbe34a42a9b7aa5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07ea0048ed82fe689ebc0f3fdccc634510ac0f99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ea0048ed82fe689ebc0f3fdccc634510ac0f99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07ea0048ed82fe689ebc0f3fdccc634510ac0f99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ea0048ed82fe689ebc0f3fdccc634510ac0f99/comments", "author": null, "committer": null, "parents": [{"sha": "d634bfa1ae963dfea8c2b0eda147dd7ab9cf8254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d634bfa1ae963dfea8c2b0eda147dd7ab9cf8254", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d634bfa1ae963dfea8c2b0eda147dd7ab9cf8254"}], "stats": {"total": 99, "additions": 99, "deletions": 0}, "files": [{"sha": "7c0776a1f65fcfc981a44ec422ef881ffe7325f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ea0048ed82fe689ebc0f3fdccc634510ac0f99/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ea0048ed82fe689ebc0f3fdccc634510ac0f99/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07ea0048ed82fe689ebc0f3fdccc634510ac0f99", "patch": "@@ -1,3 +1,9 @@\n+2011-05-05  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/spu/spu.c (TARGET_ASM_OUTPUT_MI_THUNK): Define.\n+\t(TARGET_ASM_CAN_OUTPUT_MI_THUNK): Likewise.\n+\t(spu_output_mi_thunk): New function.\n+\n 2011-05-05  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config/sparc/sol2.h (ASM_OUTPUT_CALL): Use"}, {"sha": "ca065ca44de4be9823d4a9af7c082c07ee72cd9d", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ea0048ed82fe689ebc0f3fdccc634510ac0f99/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ea0048ed82fe689ebc0f3fdccc634510ac0f99/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=07ea0048ed82fe689ebc0f3fdccc634510ac0f99", "patch": "@@ -232,6 +232,8 @@ static rtx spu_expand_load (rtx, rtx, rtx, int);\n static void spu_trampoline_init (rtx, tree, rtx);\n static void spu_conditional_register_usage (void);\n static bool spu_ref_may_alias_errno (ao_ref *);\n+static void spu_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n+\t\t\t\t HOST_WIDE_INT, tree);\n \n /* Which instruction set architecture to use.  */\n int spu_arch;\n@@ -502,6 +504,11 @@ static const struct attribute_spec spu_attribute_table[] =\n #undef TARGET_REF_MAY_ALIAS_ERRNO\n #define TARGET_REF_MAY_ALIAS_ERRNO spu_ref_may_alias_errno\n \n+#undef TARGET_ASM_OUTPUT_MI_THUNK\n+#define TARGET_ASM_OUTPUT_MI_THUNK spu_output_mi_thunk\n+#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_const_tree_hwi_hwi_const_tree_true\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n static void\n@@ -7192,4 +7199,90 @@ spu_ref_may_alias_errno (ao_ref *ref)\n   return default_ref_may_alias_errno (ref);\n }\n \n+/* Output thunk to FILE that implements a C++ virtual function call (with\n+   multiple inheritance) to FUNCTION.  The thunk adjusts the this pointer\n+   by DELTA, and unless VCALL_OFFSET is zero, applies an additional adjustment\n+   stored at VCALL_OFFSET in the vtable whose address is located at offset 0\n+   relative to the resulting this pointer.  */\n+\n+static void\n+spu_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n+\t\t     HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n+\t\t     tree function)\n+{\n+  rtx op[8];\n+\n+  /* Make sure unwind info is emitted for the thunk if needed.  */\n+  final_start_function (emit_barrier (), file, 1);\n+\n+  /* Operand 0 is the target function.  */\n+  op[0] = XEXP (DECL_RTL (function), 0);\n+\n+  /* Operand 1 is the 'this' pointer.  */\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n+    op[1] = gen_rtx_REG (Pmode, FIRST_ARG_REGNUM + 1);\n+  else\n+    op[1] = gen_rtx_REG (Pmode, FIRST_ARG_REGNUM);\n+\n+  /* Operands 2/3 are the low/high halfwords of delta.  */\n+  op[2] = GEN_INT (trunc_int_for_mode (delta, HImode));\n+  op[3] = GEN_INT (trunc_int_for_mode (delta >> 16, HImode));\n+\n+  /* Operands 4/5 are the low/high halfwords of vcall_offset.  */\n+  op[4] = GEN_INT (trunc_int_for_mode (vcall_offset, HImode));\n+  op[5] = GEN_INT (trunc_int_for_mode (vcall_offset >> 16, HImode));\n+\n+  /* Operands 6/7 are temporary registers.  */\n+  op[6] = gen_rtx_REG (Pmode, 79);\n+  op[7] = gen_rtx_REG (Pmode, 78);\n+\n+  /* Add DELTA to this pointer.  */\n+  if (delta)\n+    {\n+      if (delta >= -0x200 && delta < 0x200)\n+\toutput_asm_insn (\"ai\\t%1,%1,%2\", op);\n+      else if (delta >= -0x8000 && delta < 0x8000)\n+\t{\n+\t  output_asm_insn (\"il\\t%6,%2\", op);\n+\t  output_asm_insn (\"a\\t%1,%1,%6\", op);\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (\"ilhu\\t%6,%3\", op);\n+\t  output_asm_insn (\"iohl\\t%6,%2\", op);\n+\t  output_asm_insn (\"a\\t%1,%1,%6\", op);\n+\t}\n+    }\n+\n+  /* Perform vcall adjustment.  */\n+  if (vcall_offset)\n+    {\n+      output_asm_insn (\"lqd\\t%7,0(%1)\", op);\n+      output_asm_insn (\"rotqby\\t%7,%7,%1\", op);\n+\n+      if (vcall_offset >= -0x200 && vcall_offset < 0x200)\n+\toutput_asm_insn (\"ai\\t%7,%7,%4\", op);\n+      else if (vcall_offset >= -0x8000 && vcall_offset < 0x8000)\n+\t{\n+\t  output_asm_insn (\"il\\t%6,%4\", op);\n+\t  output_asm_insn (\"a\\t%7,%7,%6\", op);\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (\"ilhu\\t%6,%5\", op);\n+\t  output_asm_insn (\"iohl\\t%6,%4\", op);\n+\t  output_asm_insn (\"a\\t%7,%7,%6\", op);\n+\t}\n+\n+      output_asm_insn (\"lqd\\t%6,0(%7)\", op);\n+      output_asm_insn (\"rotqby\\t%6,%6,%7\", op);\n+      output_asm_insn (\"a\\t%1,%1,%6\", op);\n+    }\n+\n+  /* Jump to target.  */\n+  output_asm_insn (\"br\\t%0\", op);\n+\n+  final_end_function ();\n+}\n+\n #include \"gt-spu.h\""}]}