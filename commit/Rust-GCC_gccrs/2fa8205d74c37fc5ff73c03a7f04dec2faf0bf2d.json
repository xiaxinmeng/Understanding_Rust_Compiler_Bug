{"sha": "2fa8205d74c37fc5ff73c03a7f04dec2faf0bf2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZhODIwNWQ3NGMzN2ZjNWZmNzNjMDNhN2YwNGRlYzJmYWYwYmYyZA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2009-08-11T13:56:52Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2009-08-11T13:56:52Z"}, "message": "reload.c (find_reloads_subreg_address): Check the original req_equiv_mem address to detect the case where an address is...\n\n\t* reload.c (find_reloads_subreg_address): Check the original\n\treq_equiv_mem address to detect the case where an address is\n\tnot valid in the outer mode.\n\nFrom-SVN: r150649", "tree": {"sha": "94fab32a99a814eb73941f89c976a03386a862da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94fab32a99a814eb73941f89c976a03386a862da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fa8205d74c37fc5ff73c03a7f04dec2faf0bf2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fa8205d74c37fc5ff73c03a7f04dec2faf0bf2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fa8205d74c37fc5ff73c03a7f04dec2faf0bf2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fa8205d74c37fc5ff73c03a7f04dec2faf0bf2d/comments", "author": null, "committer": null, "parents": [{"sha": "ac8f7e421b35b2f8b045058e83bf7111cc4e2b38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8f7e421b35b2f8b045058e83bf7111cc4e2b38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac8f7e421b35b2f8b045058e83bf7111cc4e2b38"}], "stats": {"total": 36, "additions": 25, "deletions": 11}, "files": [{"sha": "8aaa86509b5c7441bc172b58cae1283edcfca418", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa8205d74c37fc5ff73c03a7f04dec2faf0bf2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa8205d74c37fc5ff73c03a7f04dec2faf0bf2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2fa8205d74c37fc5ff73c03a7f04dec2faf0bf2d", "patch": "@@ -1,3 +1,9 @@\n+2009-08-11  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* reload.c (find_reloads_subreg_address): Check the original\n+\treq_equiv_mem address to detect the case where an address is\n+\tnot valid in the outer mode.\n+\n 2009-08-11  Richard Guenther  <rguenther@suse.de>\n         \n         PR bootstrap/40788"}, {"sha": "257acd0a50903891e3447fe828bb9eda2d122cb2", "filename": "gcc/reload.c", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fa8205d74c37fc5ff73c03a7f04dec2faf0bf2d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fa8205d74c37fc5ff73c03a7f04dec2faf0bf2d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=2fa8205d74c37fc5ff73c03a7f04dec2faf0bf2d", "patch": "@@ -6133,18 +6133,26 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t      /* For some processors an address may be valid in the\n \t\t original mode but not in a smaller mode.  For\n \t\t example, ARM accepts a scaled index register in\n-\t\t SImode but not in HImode.  Similarly, the address may\n-\t\t have been valid before the subreg offset was added,\n-\t\t but not afterwards.  find_reloads_address\n-\t\t assumes that we pass it a valid address, and doesn't\n-\t\t force a reload.  This will probably be fine if\n-\t\t find_reloads_address finds some reloads.  But if it\n-\t\t doesn't find any, then we may have just converted a\n-\t\t valid address into an invalid one.  Check for that\n-\t\t here.  */\n+\t\t SImode but not in HImode.  Note that this is only\n+\t\t a problem if the address in reg_equiv_mem is already\n+\t\t invalid in the new mode; other cases would be fixed\n+\t\t by find_reloads_address as usual.\n+\n+\t\t ??? We attempt to handle such cases here by doing an\n+\t\t additional reload of the full address after the\n+\t\t usual processing by find_reloads_address.  Note that\n+\t\t this may not work in the general case, but it seems\n+\t\t to cover the cases where this situation currently\n+\t\t occurs.  A more general fix might be to reload the\n+\t\t *value* instead of the address, but this would not\n+\t\t be expected by the callers of this routine as-is.\n+\n+\t\t If find_reloads_address already completed replaced\n+\t\t the address, there is nothing further to do.  */\n \t      if (reloaded == 0\n-\t\t  && !strict_memory_address_p (GET_MODE (tem),\n-\t\t\t\t\t       XEXP (tem, 0)))\n+\t\t  && reg_equiv_mem[regno] != 0\n+\t\t  && !strict_memory_address_p (GET_MODE (x),\n+\t\t\t\t\t       XEXP (reg_equiv_mem[regno], 0)))\n \t\tpush_reload (XEXP (tem, 0), NULL_RTX, &XEXP (tem, 0), (rtx*) 0,\n \t\t\t     base_reg_class (GET_MODE (tem), MEM, SCRATCH),\n \t\t\t     GET_MODE (XEXP (tem, 0)), VOIDmode, 0, 0,"}]}