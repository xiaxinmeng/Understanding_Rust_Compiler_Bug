{"sha": "1420b484a811ceb52d51dea8ac553872f61f77d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQyMGI0ODRhODExY2ViNTJkNTFkZWE4YWM1NTM4NzJmNjFmNzdkMg==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2005-09-05T08:03:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T08:03:17Z"}, "message": "sem_res.adb (Resolve_Membership_Op): In case of the membership test \"Iface_CW_Typ in T'Class\" we have nothing else...\n\n2005-09-01  Javier Miranda  <miranda@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_res.adb (Resolve_Membership_Op): In case of the membership test\n\t\"Iface_CW_Typ in T'Class\" we have nothing else to do in the frontend;\n\tthe expander will generate the corresponding run-time check to evaluate\n\tthe expression.\n\t(Resolve_Call): Check for legal type of procedure name or prefix that\n\tappears as a trigger in a triggering alternative.\n\t(Valid_Conversion): If expression is ambiguous and the context involves\n\tan extension of System, remove System.Address interpretations.\n\t(Resolve_Qualified_Expression): Reject the case of a specific-type\n\tqualification applied to a class-wide argument. Enhance comment\n\tto explain checking of Original_Node.\n\t(Resolve_Type_Conversion): The location of the error message was not\n\tgeneral enough to handle the general case and hence it has been removed.\n\tIn addition, this patch improves the text of the message.\n\t(Resolve_Type_Conversion): Add missing support for access to interface\n\ttypes.\n\t(Resolve_Type_Conversion): If the target is a class-wide interface type,\n\tdo not expand if the expression is the actual in a call, because proper\n\texpansion will take place when the call itself is expanded.\n\t(Resolve_Allocator): If the context is an unchecked conversion, the\n\tallocator inherits its storage pool, if any, from the target type of\n\tthe conversion.\n\nFrom-SVN: r103886", "tree": {"sha": "4663bbbd134b9b4ba2e686e242037c12cbd32abe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4663bbbd134b9b4ba2e686e242037c12cbd32abe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1420b484a811ceb52d51dea8ac553872f61f77d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1420b484a811ceb52d51dea8ac553872f61f77d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1420b484a811ceb52d51dea8ac553872f61f77d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1420b484a811ceb52d51dea8ac553872f61f77d2/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9cca32af39afce68bdc9c76702b1d31235c257c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cca32af39afce68bdc9c76702b1d31235c257c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cca32af39afce68bdc9c76702b1d31235c257c3"}], "stats": {"total": 198, "additions": 115, "deletions": 83}, "files": [{"sha": "e1e9b7b4ec3f89f5ab9d51159aec7df06d0228b9", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 115, "deletions": 83, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1420b484a811ceb52d51dea8ac553872f61f77d2/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1420b484a811ceb52d51dea8ac553872f61f77d2/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=1420b484a811ceb52d51dea8ac553872f61f77d2", "patch": "@@ -244,14 +244,10 @@ package body Sem_Res is\n            (\"\\possible interpretations: Character, Wide_Character!\", C);\n \n          E := Current_Entity (C);\n-\n-         if Present (E) then\n-\n-            while Present (E) loop\n-               Error_Msg_NE (\"\\possible interpretation:}!\", C, Etype (E));\n-               E := Homonym (E);\n-            end loop;\n-         end if;\n+         while Present (E) loop\n+            Error_Msg_NE (\"\\possible interpretation:}!\", C, Etype (E));\n+            E := Homonym (E);\n+         end loop;\n       end if;\n    end Ambiguous_Character;\n \n@@ -557,7 +553,6 @@ package body Sem_Res is\n       else\n          D := PN;\n          P := Parent (PN);\n-\n          while Nkind (P) /= N_Component_Declaration\n            and then Nkind (P) /= N_Subtype_Indication\n            and then Nkind (P) /= N_Entry_Declaration\n@@ -742,9 +737,7 @@ package body Sem_Res is\n \n          elsif Is_Record_Type (T) then\n             Comp := First_Component (T);\n-\n             while Present (Comp) loop\n-\n                if Ekind (Comp) = E_Component\n                  and then Nkind (Parent (Comp)) = N_Component_Declaration\n                then\n@@ -996,9 +989,7 @@ package body Sem_Res is\n \n          else\n             Get_First_Interp (Nod, I, It);\n-\n             while Present (It.Typ) loop\n-\n                if Scope (Base_Type (It.Typ)) = S then\n                   return True;\n                end if;\n@@ -1066,9 +1057,7 @@ package body Sem_Res is\n \n          else\n             E := First_Entity (Pack);\n-\n             while Present (E) loop\n-\n                if Test (E)\n                  and then not In_Decl\n                then\n@@ -1672,10 +1661,9 @@ package body Sem_Res is\n       --  is compatible with the context (i.e. the type passed to Resolve)\n \n       else\n-         Get_First_Interp (N, I, It);\n-\n          --  Loop through possible interpretations\n \n+         Get_First_Interp (N, I, It);\n          Interp_Loop : while Present (It.Typ) loop\n \n             --  We are only interested in interpretations that are compatible\n@@ -1726,10 +1714,11 @@ package body Sem_Res is\n                        or else Nkind (N) = N_Procedure_Call_Statement\n                      then\n                         declare\n-                           A : Node_Id := First_Actual (N);\n+                           A : Node_Id;\n                            E : Node_Id;\n \n                         begin\n+                           A := First_Actual (N);\n                            while Present (A) loop\n                               E := A;\n \n@@ -2076,10 +2065,9 @@ package body Sem_Res is\n \n                      begin\n                         Error_Msg_N (\"\\possible interpretations:\", N);\n-                        Get_First_Interp (Name (N), Index, It);\n \n+                        Get_First_Interp (Name (N), Index, It);\n                         while Present (It.Nam) loop\n-\n                               Error_Msg_Sloc := Sloc (It.Nam);\n                               Error_Msg_Node_2 := It.Typ;\n                               Error_Msg_NE (\"\\&  declared#, type&\",\n@@ -2769,16 +2757,14 @@ package body Sem_Res is\n \n                if Ada_Version >= Ada_05\n                  and then Is_Access_Type (F_Typ)\n-                 and then (Can_Never_Be_Null (F)\n-                           or else Can_Never_Be_Null (F_Typ))\n+                 and then Can_Never_Be_Null (F_Typ)\n+                 and then Nkind (A) = N_Null\n                then\n-                  if Nkind (A) = N_Null then\n-                     Apply_Compile_Time_Constraint_Error\n-                       (N      => A,\n-                        Msg    => \"(Ada 2005) NULL not allowed in \"\n-                                   & \"null-excluding formal?\",\n-                        Reason => CE_Null_Not_Allowed);\n-                  end if;\n+                  Apply_Compile_Time_Constraint_Error\n+                    (N      => A,\n+                     Msg    => \"(Ada 2005) NULL not allowed in \"\n+                               & \"null-excluding formal?\",\n+                     Reason => CE_Null_Not_Allowed);\n                end if;\n             end if;\n \n@@ -3013,7 +2999,6 @@ package body Sem_Res is\n             if Has_Discriminants (Subtyp) then\n                Discrim := First_Discriminant (Base_Type (Subtyp));\n                Constr := First (Constraints (Constraint (Original_Node (E))));\n-\n                while Present (Discrim) and then Present (Constr) loop\n                   if Ekind (Etype (Discrim)) = E_Anonymous_Access_Type then\n                      if Nkind (Constr) = N_Discriminant_Association then\n@@ -3104,14 +3089,24 @@ package body Sem_Res is\n       if No_Pool_Assigned (Typ) then\n          declare\n             Loc : constant Source_Ptr := Sloc (N);\n-\n          begin\n             Error_Msg_N (\"?allocation from empty storage pool!\", N);\n             Error_Msg_N (\"?Storage_Error will be raised at run time!\", N);\n             Insert_Action (N,\n               Make_Raise_Storage_Error (Loc,\n                 Reason => SE_Empty_Storage_Pool));\n          end;\n+\n+      --  If the context is an unchecked conversion, as may happen within\n+      --  an inlined subprogram, the allocator is being resolved with its\n+      --  own anonymous type. In that case, if the target type has a specific\n+      --  storage pool, it must be inherited explicitly by the allocator type.\n+\n+      elsif Nkind (Parent (N)) = N_Unchecked_Type_Conversion\n+        and then No (Associated_Storage_Pool (Typ))\n+      then\n+         Set_Associated_Storage_Pool\n+           (Typ, Associated_Storage_Pool (Etype (Parent (N))));\n       end if;\n    end Resolve_Allocator;\n \n@@ -3161,9 +3156,7 @@ package body Sem_Res is\n               or else T = Universal_Real;\n          else\n             Get_First_Interp (N, Index, It);\n-\n             while Present (It.Typ) loop\n-\n                if Base_Type (It.Typ) = Base_Type (Standard_Integer)\n                  or else It.Typ = Universal_Integer\n                  or else It.Typ = Universal_Real\n@@ -3251,7 +3244,6 @@ package body Sem_Res is\n             --  interpretation or an integer interpretation, but not both.\n \n             Get_First_Interp (N, Index, It);\n-\n             while Present (It.Typ) loop\n                if Base_Type (It.Typ) = Base_Type (Standard_Integer) then\n \n@@ -3548,9 +3540,9 @@ package body Sem_Res is\n             --  return type that is compatible with the context. Analysis of\n             --  the node has established that one exists.\n \n-            Get_First_Interp (Subp,  I, It);\n             Nam := Empty;\n \n+            Get_First_Interp (Subp,  I, It);\n             while Present (It.Typ) loop\n                if Covers (Typ, Etype (It.Typ)) then\n                   Nam := It.Typ;\n@@ -3609,10 +3601,9 @@ package body Sem_Res is\n \n       else\n          pragma Assert (Is_Overloaded (Subp));\n-         Nam := Empty;  --  We know that it will be assigned in loop below.\n+         Nam := Empty;  --  We know that it will be assigned in loop below\n \n          Get_First_Interp (Subp,  I, It);\n-\n          while Present (It.Typ) loop\n             if Covers (Typ, It.Typ) then\n                Nam := It.Nam;\n@@ -3714,7 +3705,23 @@ package body Sem_Res is\n         and then Nkind (N) /= N_Entry_Call_Statement\n         and then Entry_Call_Statement (Parent (N)) = N\n       then\n-         Error_Msg_N (\"entry call required in select statement\", N);\n+         if Ada_Version < Ada_05 then\n+            Error_Msg_N (\"entry call required in select statement\", N);\n+\n+         --  Ada 2005 (AI-345): If a procedure_call_statement is used\n+         --  for a procedure_or_entry_call, the procedure_name or pro-\n+         --  cedure_prefix of the procedure_call_statement shall denote\n+         --  an entry renamed by a procedure, or (a view of) a primitive\n+         --  subprogram of a limited interface whose first parameter is\n+         --  a controlling parameter.\n+\n+         elsif Nkind (N) = N_Procedure_Call_Statement\n+           and then not Is_Renamed_Entry (Nam)\n+           and then not Is_Controlling_Limited_Procedure (Nam)\n+         then\n+            Error_Msg_N\n+              (\"procedure or entry call required in select statement\", N);\n+         end if;\n       end if;\n \n       --  Check that this is not a call to a protected procedure or\n@@ -4050,7 +4057,6 @@ package body Sem_Res is\n \n       else\n          C := Current_Entity (N);\n-\n          while Present (C) loop\n             if Etype (C) = B_Typ then\n                Set_Entity_With_Style_Check (N, C);\n@@ -4092,6 +4098,7 @@ package body Sem_Res is\n \n       if Scope (Entity (N)) /= Standard_Standard then\n          T := Etype (First_Entity (Entity (N)));\n+\n       else\n          T := Find_Unique_Type (L, R);\n \n@@ -4475,7 +4482,6 @@ package body Sem_Res is\n                --  the type in the same declarative part.\n \n                Tsk := Next_Entity (S);\n-\n                while Etype (Tsk) /= S loop\n                   Next_Entity (Tsk);\n                end loop;\n@@ -4515,9 +4521,7 @@ package body Sem_Res is\n \n          begin\n             Get_First_Interp (Pref, I, It);\n-\n             while Present (It.Typ) loop\n-\n                if Scope (Ent) = It.Typ then\n                   Set_Etype (Pref, It.Typ);\n                   exit;\n@@ -4586,9 +4590,7 @@ package body Sem_Res is\n \n          begin\n             Get_First_Interp (Selector_Name (Entry_Name), I, It);\n-\n             while Present (It.Typ) loop\n-\n                if Covers (Typ, It.Typ) then\n                   Set_Entity (Selector_Name (Entry_Name), It.Nam);\n                   Set_Etype  (Entry_Name, It.Typ);\n@@ -4740,7 +4742,7 @@ package body Sem_Res is\n          Set_Analyzed (N, True);\n \n       --  Protected functions can return on the secondary stack, in which\n-      --  case we must trigger the transient scope mechanism\n+      --  case we must trigger the transient scope mechanism.\n \n       elsif Expander_Active\n         and then Requires_Transient_Scope (Etype (Nam))\n@@ -4780,7 +4782,7 @@ package body Sem_Res is\n       function Find_Unique_Access_Type return Entity_Id is\n          Acc : Entity_Id;\n          E   : Entity_Id;\n-         S   : Entity_Id := Current_Scope;\n+         S   : Entity_Id;\n \n       begin\n          if Ekind (Etype (R)) =  E_Allocator_Type then\n@@ -4793,11 +4795,10 @@ package body Sem_Res is\n             return Empty;\n          end if;\n \n+         S := Current_Scope;\n          while S /= Standard_Standard loop\n             E := First_Entity (S);\n-\n             while Present (E) loop\n-\n                if Is_Type (E)\n                  and then Is_Access_Type (E)\n                  and then Ekind (E) /= E_Allocator_Type\n@@ -4826,12 +4827,10 @@ package body Sem_Res is\n       end if;\n \n       if T /= Any_Type then\n-\n          if T = Any_String\n            or else T = Any_Composite\n            or else T = Any_Character\n          then\n-\n             if T = Any_Character then\n                Ambiguous_Character (L);\n             else\n@@ -4936,7 +4935,6 @@ package body Sem_Res is\n         and then Is_Tagged_Type (Directly_Designated_Type (Etype (Prefix (N))))\n       then\n          null;\n-\n       else\n          Check_Fully_Declared (Typ, N);\n       end if;\n@@ -4950,7 +4948,6 @@ package body Sem_Res is\n          while Present (It.Typ) loop\n             exit when Is_Access_Type (It.Typ)\n               and then Covers (Typ, Designated_Type (It.Typ));\n-\n             Get_Next_Interp (I, It);\n          end loop;\n \n@@ -5044,12 +5041,7 @@ package body Sem_Res is\n \n          begin\n             Get_First_Interp (P, I, It);\n-\n-      --  the task has access discriminants, the designated type may be\n-      --  incomplete at the point the expression is resolved. This resolution\n-      --  takes place within the body of the initialization proc\n             while Present (It.Typ) loop\n-\n                if (Is_Array_Type (It.Typ)\n                      and then Covers (Typ, Component_Type (It.Typ)))\n                  or else (Is_Access_Type (It.Typ)\n@@ -5153,7 +5145,6 @@ package body Sem_Res is\n \n    begin\n       Op := Entity (N);\n-\n       while Scope (Op) /= Standard_Standard loop\n          Op := Homonym (Op);\n          pragma Assert (Present (Op));\n@@ -5231,7 +5222,6 @@ package body Sem_Res is\n \n    begin\n       Op := Entity (N);\n-\n       while Scope (Op) /= Standard_Standard loop\n          Op := Homonym (Op);\n          pragma Assert (Present (Op));\n@@ -5334,6 +5324,28 @@ package body Sem_Res is\n         and then Is_Overloaded (L)\n       then\n          T := Etype (R);\n+\n+      --  Ada 2005 (AI-251): Give support to the following case:\n+\n+      --      type I is interface;\n+      --      type T is tagged ...\n+\n+      --      function Test (O : in I'Class) is\n+      --      begin\n+      --         return O in T'Class.\n+      --      end Test;\n+\n+      --  In this case we have nothing else to do; the membership test will be\n+      --  done at run-time.\n+\n+      elsif Ada_Version >= Ada_05\n+        and then Is_Class_Wide_Type (Etype (L))\n+        and then Is_Interface (Etype (L))\n+        and then Is_Class_Wide_Type (Etype (R))\n+        and then not Is_Interface (Etype (R))\n+      then\n+         return;\n+\n       else\n          T := Intersect_Types (L, R);\n       end if;\n@@ -5465,9 +5477,7 @@ package body Sem_Res is\n \n                   begin\n                      Get_First_Interp (Arg, I, It);\n-\n                      while Present (It.Nam) loop\n-\n                         if Base_Type (Etype (It.Nam)) = Base_Type (Typ)\n                           or else Base_Type (Etype (It.Nam)) =\n                             Base_Type (Component_Type (Typ))\n@@ -5725,9 +5735,16 @@ package body Sem_Res is\n       Resolve (Expr, Target_Typ);\n \n       --  A qualified expression requires an exact match of the type,\n-      --  class-wide matching is not allowed.\n-\n-      if Is_Class_Wide_Type (Target_Typ)\n+      --  class-wide matching is not allowed. However, if the qualifying\n+      --  type is specific and the expression has a class-wide type, it\n+      --  may still be okay, since it can be the result of the expansion\n+      --  of a call to a dispatching function, so we also have to check\n+      --  class-wideness of the type of the expression's original node.\n+\n+      if (Is_Class_Wide_Type (Target_Typ)\n+           or else\n+             (Is_Class_Wide_Type (Etype (Expr))\n+               and then Is_Class_Wide_Type (Etype (Original_Node (Expr)))))\n         and then Base_Type (Etype (Expr)) /= Base_Type (Target_Typ)\n       then\n          Wrong_Type (Expr, Target_Typ);\n@@ -5944,9 +5961,7 @@ package body Sem_Res is\n \n             if Is_Record_Type (T) then\n                Comp := First_Entity (T);\n-\n                while Present (Comp) loop\n-\n                   if Chars (Comp) = Chars (S)\n                     and then Covers (Etype (Comp), Typ)\n                   then\n@@ -5974,7 +5989,6 @@ package body Sem_Res is\n                               --  Find the component with the right name.\n \n                               Comp1 := First_Entity (It1.Typ);\n-\n                               while Present (Comp1)\n                                 and then Chars (Comp1) /= Chars (S)\n                               loop\n@@ -6118,9 +6132,7 @@ package body Sem_Res is\n \n          begin\n             Get_First_Interp (P, I,  It);\n-\n             while Present (It.Typ) loop\n-\n                if (Is_Array_Type (It.Typ)\n                     and then Covers (Typ,  It.Typ))\n                  or else (Is_Access_Type (It.Typ)\n@@ -6630,6 +6642,10 @@ package body Sem_Res is\n          end if;\n \n          if Is_Interface (Target_Type) then\n+            if Is_Access_Type (Opnd_Type) then\n+               Opnd_Type := Directly_Designated_Type (Opnd_Type);\n+            end if;\n+\n             if Is_Class_Wide_Type (Opnd_Type) then\n                Opnd_Type := Etype (Opnd_Type);\n             end if;\n@@ -6638,19 +6654,25 @@ package body Sem_Res is\n                      (Typ   => Opnd_Type,\n                       Iface => Target_Type)\n             then\n-               if Nkind (Operand) = N_Attribute_Reference then\n-                  Error_Msg_Name_1 := Chars (Prefix (Operand));\n-               else\n-                  Error_Msg_Name_1 := Chars (Operand);\n-               end if;\n-\n-               Error_Msg_Name_2 := Chars (Target_Type);\n                Error_Msg_NE\n-                 (\"(Ada 2005) % does not implement interface %\",\n+                 (\"(Ada 2005) does not implement interface }\",\n                   Operand, Target_Type);\n \n             else\n-               Expand_Interface_Conversion (N);\n+               --  If a conversion to an interface type appears as an actual in\n+               --  a source call, it will be expanded when the enclosing call\n+               --  itself is examined in Expand_Interface_Formals. Otherwise,\n+               --  generate the proper conversion code now, using the tag of\n+               --  the interface.\n+\n+               if (Nkind (Parent (N)) = N_Procedure_Call_Statement\n+                     or else Nkind (Parent (N)) = N_Function_Call)\n+                 and then Comes_From_Source (N)\n+               then\n+                  null;\n+               else\n+                  Expand_Interface_Conversion (N);\n+               end if;\n             end if;\n          end if;\n       end if;\n@@ -7000,7 +7022,6 @@ package body Sem_Res is\n       Scop := Current_Scope;\n       while Scop /= Standard_Standard loop\n          T2 := First_Entity (Scop);\n-\n          while Present (T2) loop\n             if Is_Fixed_Point_Type (T2)\n               and then Current_Entity (T2) = T2\n@@ -7027,7 +7048,6 @@ package body Sem_Res is\n          if Nkind (Item) = N_With_Clause then\n             Scop := Entity (Name (Item));\n             T2 := First_Entity (Scop);\n-\n             while Present (T2) loop\n                if Is_Fixed_Point_Type (T2)\n                  and then Scope (Base_Type (T2)) = Scop\n@@ -7160,14 +7180,26 @@ package body Sem_Res is\n             --  in this context, but which cannot be removed by type checking,\n             --  because the context does not impose a type.\n \n+            --  When compiling for VMS, spurious ambiguities can be produced\n+            --  when arithmetic operations have a literal operand and return\n+            --  System.Address or a descendant of it. These ambiguities are\n+            --  otherwise resolved by the context, but for conversions there\n+            --  is no context type and the removal of the spurious operations\n+            --  must be done explicitly here.\n+\n             Get_First_Interp (Operand, I, It);\n \n             while Present (It.Typ) loop\n-\n                if It.Typ = Standard_Void_Type then\n                   Remove_Interp (I);\n                end if;\n \n+               if Present (System_Aux_Id)\n+                 and then Is_Descendent_Of_Address (It.Typ)\n+               then\n+                  Remove_Interp (I);\n+               end if;\n+\n                Get_Next_Interp (I, It);\n             end loop;\n \n@@ -7557,10 +7589,10 @@ package body Sem_Res is\n                O_Gen : constant Node_Id :=\n                          Enclosing_Generic_Body (Opnd_Type);\n \n-               T_Gen : Node_Id :=\n-                         Enclosing_Generic_Body (Target_Type);\n+               T_Gen : Node_Id;\n \n             begin\n+               T_Gen := Enclosing_Generic_Body (Target_Type);\n                while Present (T_Gen) and then T_Gen /= O_Gen loop\n                   T_Gen := Enclosing_Generic_Body (T_Gen);\n                end loop;"}]}