{"sha": "fe90c504416e6423c6a56f37a9265deabdb03de9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU5MGM1MDQ0MTZlNjQyM2M2YTU2ZjM3YTkyNjVkZWFiZGIwM2RlOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-27T15:25:12Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-27T15:25:12Z"}, "message": "Fix ipa-modref signature updates\n\n\tPR ipa/97586\n\t* ipa-modref-tree.h (modref_tree::remap_params): New member function.\n\t* ipa-modref.c (modref_summaries_lto::duplicate): Check that\n\toptimization summaries are not duplicated.\n\t(remap_arguments): Remove.\n\t(modref_transform): Rename to ...\n\t(update_signature): ... this one; handle also lto summary.\n\t(pass_ipa_modref::execute): Update signatures here rather\n\tthan in transform hook.", "tree": {"sha": "287f2371095262766b08226c9ce621c1a3b149c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/287f2371095262766b08226c9ce621c1a3b149c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe90c504416e6423c6a56f37a9265deabdb03de9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe90c504416e6423c6a56f37a9265deabdb03de9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe90c504416e6423c6a56f37a9265deabdb03de9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe90c504416e6423c6a56f37a9265deabdb03de9/comments", "author": null, "committer": null, "parents": [{"sha": "e579f66c3c6566e94be842bea7f2a93370489626", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e579f66c3c6566e94be842bea7f2a93370489626", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e579f66c3c6566e94be842bea7f2a93370489626"}], "stats": {"total": 98, "additions": 59, "deletions": 39}, "files": [{"sha": "2787764a6673ab22f76ff46f76907e03bc5e44de", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe90c504416e6423c6a56f37a9265deabdb03de9/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe90c504416e6423c6a56f37a9265deabdb03de9/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=fe90c504416e6423c6a56f37a9265deabdb03de9", "patch": "@@ -544,6 +544,32 @@ struct GTY((user)) modref_tree\n   {\n     collapse ();\n   }\n+\n+  /* Update parameter indexes in TT according to MAP.  */\n+  void\n+  remap_params (vec <int> *map)\n+  {\n+    size_t i;\n+    modref_base_node <T> *base_node;\n+    FOR_EACH_VEC_SAFE_ELT (bases, i, base_node)\n+      {\n+\tsize_t j;\n+\tmodref_ref_node <T> *ref_node;\n+\tFOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n+\t  {\n+\t    size_t k;\n+\t    modref_access_node *access_node;\n+\t    FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n+\t      if (access_node->parm_index > 0)\n+\t\t{\n+\t\t  if (access_node->parm_index < (int)map->length ())\n+\t\t    access_node->parm_index = (*map)[access_node->parm_index];\n+\t\t  else\n+\t\t    access_node->parm_index = -1;\n+\t\t}\n+\t  }\n+      }\n+  }\n };\n \n void modref_c_tests ();"}, {"sha": "b903d772c3b04ef111fcd01fc39b97917256820b", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 33, "deletions": 39, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe90c504416e6423c6a56f37a9265deabdb03de9/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe90c504416e6423c6a56f37a9265deabdb03de9/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=fe90c504416e6423c6a56f37a9265deabdb03de9", "patch": "@@ -1080,6 +1080,9 @@ modref_summaries_lto::duplicate (cgraph_node *, cgraph_node *,\n \t\t\t\t modref_summary_lto *src_data,\n \t\t\t\t modref_summary_lto *dst_data)\n {\n+  /* Be sure that no furhter cloning happens after ipa-modref.  If it does\n+     we will need to update signatures for possible param changes.  */\n+  gcc_checking_assert (!((modref_summaries_lto *)summaries_lto)->propagated);\n   dst_data->stores = modref_records_lto::create_ggc\n \t\t\t(src_data->stores->max_bases,\n \t\t\t src_data->stores->max_refs,\n@@ -1474,43 +1477,20 @@ modref_read (void)\n     }\n }\n \n-/* Update parameter indexes in TT according to MAP.  */\n-\n-void\n-remap_arguments (vec <int> *map, modref_records *tt)\n-{\n-  size_t i;\n-  modref_base_node <alias_set_type> *base_node;\n-  FOR_EACH_VEC_SAFE_ELT (tt->bases, i, base_node)\n-    {\n-      size_t j;\n-      modref_ref_node <alias_set_type> *ref_node;\n-      FOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n-\t{\n-\t  size_t k;\n-\t  modref_access_node *access_node;\n-\t  FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n-\t    if (access_node->parm_index > 0)\n-\t      {\n-\t\tif (access_node->parm_index < (int)map->length ())\n-\t\t  access_node->parm_index = (*map)[access_node->parm_index];\n-\t\telse\n-\t\t  access_node->parm_index = -1;\n-\t      }\n-\t}\n-    }\n-}\n-\n /* If signature changed, update the summary.  */\n \n-static unsigned int\n-modref_transform (struct cgraph_node *node)\n+static void\n+update_signature (struct cgraph_node *node)\n {\n-  if (!node->clone.param_adjustments || !optimization_summaries)\n-    return 0;\n-  modref_summary *r = optimization_summaries->get (node);\n-  if (!r)\n-    return 0;\n+  if (!node->clone.param_adjustments)\n+    return;\n+\n+  modref_summary *r = optimization_summaries\n+\t\t      ? optimization_summaries->get (node) : NULL;\n+  modref_summary_lto *r_lto = summaries_lto\n+\t\t\t      ? summaries_lto->get (node) : NULL;\n+  if (!r && !r_lto)\n+    return;\n   if (dump_file)\n     {\n       fprintf (dump_file, \"Updating summary for %s from:\\n\",\n@@ -1539,14 +1519,25 @@ modref_transform (struct cgraph_node *node)\n       if (idx >= 0)\n \tmap[idx] = i;\n     }\n-  remap_arguments (&map, r->loads);\n-  remap_arguments (&map, r->stores);\n+  if (r)\n+    {\n+      r->loads->remap_params (&map);\n+      r->stores->remap_params (&map);\n+    }\n+  if (r_lto)\n+    {\n+      r_lto->loads->remap_params (&map);\n+      r_lto->stores->remap_params (&map);\n+    }\n   if (dump_file)\n     {\n       fprintf (dump_file, \"to:\\n\");\n-      r->dump (dump_file);\n+      if (r)\n+        r->dump (dump_file);\n+      if (r_lto)\n+        r_lto->dump (dump_file);\n     }\n-  return 0;\n+  return;\n }\n \n /* Definition of the modref IPA pass.  */\n@@ -1575,7 +1566,7 @@ class pass_ipa_modref : public ipa_opt_pass_d\n \t\t      modref_read,     /* read_optimization_summary */\n \t\t      NULL,            /* stmt_fixup */\n \t\t      0,               /* function_transform_todo_flags_start */\n-\t\t      modref_transform,/* function_transform */\n+\t\t      NULL,\t       /* function_transform */\n \t\t      NULL)            /* variable_transform */\n   {}\n \n@@ -2137,6 +2128,9 @@ pass_ipa_modref::execute (function *)\n \n       modref_propagate_in_scc (component_node);\n     }\n+  cgraph_node *node;\n+  FOR_EACH_FUNCTION (node)\n+    update_signature (node);\n   if (summaries_lto)\n     ((modref_summaries_lto *)summaries_lto)->propagated = true;\n   ipa_free_postorder_info ();"}]}