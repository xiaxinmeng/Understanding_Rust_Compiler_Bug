{"sha": "ab156144da05dcb8df7fb55a10e937a17372f6a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIxNTYxNDRkYTA1ZGNiOGRmN2ZiNTVhMTBlOTM3YTE3MzcyZjZhNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-11-16T17:23:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-11-16T17:23:23Z"}, "message": "re PR rtl-optimization/24160 (ICE with -O1 -ftree-vectorize -msse)\n\n        PR rtl-opt/24160\n        PR target/24621\n        * reload1.c (reg_equiv_invariant): New.\n        (reload): Allocate, initialize, and free it.\n        (calculate_needs_all_insns): Check it when skipping equivalence\n        setting insns.\n        (alter_reg): Likewise.\n        (eliminate_regs_1): Rename from eliminate_regs.  Add new\n        may_use_invariant argument; only use reg_equiv_invariant when true.\n        (eliminate_regs): New.\n        (eliminate_regs_in_insn): Use eliminate_regs_1; track when we're in\n        a context for which may_use_invariant may be true.\n\nCo-Authored-By: J\"orn Rennecke <joern.rennecke@st.com>\nCo-Authored-By: Ulrich Weigand <uweigand@de.ibm.com>\n\nFrom-SVN: r107093", "tree": {"sha": "479e47b191740fed0eb2763df9e6cdf379877114", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/479e47b191740fed0eb2763df9e6cdf379877114"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab156144da05dcb8df7fb55a10e937a17372f6a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab156144da05dcb8df7fb55a10e937a17372f6a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab156144da05dcb8df7fb55a10e937a17372f6a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab156144da05dcb8df7fb55a10e937a17372f6a7/comments", "author": null, "committer": null, "parents": [{"sha": "68328cdaefaee1b9e218e08ff2955806ddd20403", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68328cdaefaee1b9e218e08ff2955806ddd20403", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68328cdaefaee1b9e218e08ff2955806ddd20403"}], "stats": {"total": 148, "additions": 104, "deletions": 44}, "files": [{"sha": "9c2d85af78da68af33573dad4d9a9bd62236c026", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab156144da05dcb8df7fb55a10e937a17372f6a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab156144da05dcb8df7fb55a10e937a17372f6a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab156144da05dcb8df7fb55a10e937a17372f6a7", "patch": "@@ -1,3 +1,20 @@\n+2005-11-16  Richard Henderson  <rth@redhat.com>\n+\t    J\"orn Rennecke <joern.rennecke@st.com>\n+\t    Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\tPR rtl-opt/24160\n+\tPR target/24621\n+\t* reload1.c (reg_equiv_invariant): New.\n+\t(reload): Allocate, initialize, and free it.\n+\t(calculate_needs_all_insns): Check it when skipping equivalence\n+\tsetting insns.\n+\t(alter_reg): Likewise.\n+\t(eliminate_regs_1): Rename from eliminate_regs.  Add new\n+\tmay_use_invariant argument; only use reg_equiv_invariant when true.\n+\t(eliminate_regs): New.\n+\t(eliminate_regs_in_insn): Use eliminate_regs_1; track when we're in\n+\ta context for which may_use_invariant may be true.\n+\n 2005-11-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* fold-const.c (const_binop): Don't constant fold the operation"}, {"sha": "ba395da22a3624dee78322907574131ecccf83f6", "filename": "gcc/reload1.c", "status": "modified", "additions": 87, "deletions": 44, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab156144da05dcb8df7fb55a10e937a17372f6a7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab156144da05dcb8df7fb55a10e937a17372f6a7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ab156144da05dcb8df7fb55a10e937a17372f6a7", "patch": "@@ -96,6 +96,11 @@ static HARD_REG_SET reg_is_output_reload;\n    with the constant it stands for.  */\n rtx *reg_equiv_constant;\n \n+/* Element N is an invariant value to which pseudo reg N is equivalent.\n+   eliminate_regs_in_insn uses this to replace pseudos in particular\n+   contexts.  */\n+rtx *reg_equiv_invariant;\n+\n /* Element N is a memory location to which pseudo reg N is equivalent,\n    prior to any register elimination (such as frame pointer to stack\n    pointer).  Depending on whether or not it is a valid address, this value\n@@ -693,6 +698,7 @@ reload (rtx first, int global)\n      be substituted eventually by altering the REG-rtx's.  */\n \n   reg_equiv_constant = xcalloc (max_regno, sizeof (rtx));\n+  reg_equiv_invariant = xcalloc (max_regno, sizeof (rtx));\n   reg_equiv_mem = xcalloc (max_regno, sizeof (rtx));\n   reg_equiv_address = xcalloc (max_regno, sizeof (rtx));\n   reg_max_ref_width = xcalloc (max_regno, sizeof (int));\n@@ -762,13 +768,12 @@ reload (rtx first, int global)\n \t\t    {\n \t\t      /* This is PLUS of frame pointer and a constant,\n \t\t\t and might be shared.  Unshare it.  */\n-\t\t      reg_equiv_constant[i] = copy_rtx (x);\n+\t\t      reg_equiv_invariant[i] = copy_rtx (x);\n \t\t      num_eliminable_invariants++;\n \t\t    }\n-\t\t  else if (x == frame_pointer_rtx\n-\t\t\t   || x == arg_pointer_rtx)\n+\t\t  else if (x == frame_pointer_rtx || x == arg_pointer_rtx)\n \t\t    {\n-\t\t      reg_equiv_constant[i] = x;\n+\t\t      reg_equiv_invariant[i] = x;\n \t\t      num_eliminable_invariants++;\n \t\t    }\n \t\t  else if (LEGITIMATE_CONSTANT_P (x))\n@@ -1238,7 +1243,10 @@ reload (rtx first, int global)\n   /* Indicate that we no longer have known memory locations or constants.  */\n   if (reg_equiv_constant)\n     free (reg_equiv_constant);\n+  if (reg_equiv_invariant)\n+    free (reg_equiv_invariant);\n   reg_equiv_constant = 0;\n+  reg_equiv_invariant = 0;\n   VARRAY_GROW (reg_equiv_memory_loc_varray, 0);\n   reg_equiv_memory_loc = 0;\n \n@@ -1454,7 +1462,9 @@ calculate_needs_all_insns (int global)\n \t  /* Skip insns that only set an equivalence.  */\n \t  if (set && REG_P (SET_DEST (set))\n \t      && reg_renumber[REGNO (SET_DEST (set))] < 0\n-\t      && reg_equiv_constant[REGNO (SET_DEST (set))])\n+\t      && (reg_equiv_constant[REGNO (SET_DEST (set))]\n+\t\t  || (reg_equiv_invariant[REGNO (SET_DEST (set))]))\n+\t\t      && reg_equiv_init[REGNO (SET_DEST (set))])\n \t    continue;\n \n \t  /* If needed, eliminate any eliminable registers.  */\n@@ -1944,6 +1954,7 @@ alter_reg (int i, int from_reg)\n   if (reg_renumber[i] < 0\n       && REG_N_REFS (i) > 0\n       && reg_equiv_constant[i] == 0\n+      && (reg_equiv_invariant[i] == 0 || reg_equiv_init[i] == 0)\n       && reg_equiv_memory_loc[i] == 0)\n     {\n       rtx x;\n@@ -2252,8 +2263,9 @@ set_label_offsets (rtx x, rtx insn, int initial_p)\n    encounter, return the actual location so that find_reloads will do\n    the proper thing.  */\n \n-rtx\n-eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n+static rtx\n+eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n+\t\t  bool may_use_invariant)\n {\n   enum rtx_code code = GET_CODE (x);\n   struct elim_table *ep;\n@@ -2296,10 +2308,16 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n \n \t}\n       else if (reg_renumber && reg_renumber[regno] < 0\n-\t       && reg_equiv_constant && reg_equiv_constant[regno]\n-\t       && ! CONSTANT_P (reg_equiv_constant[regno]))\n-\treturn eliminate_regs (copy_rtx (reg_equiv_constant[regno]),\n-\t\t\t       mem_mode, insn);\n+\t       && reg_equiv_invariant && reg_equiv_invariant[regno])\n+\t{\n+\t  if (may_use_invariant)\n+\t    return eliminate_regs_1 (copy_rtx (reg_equiv_invariant[regno]),\n+\t\t\t             mem_mode, insn, true);\n+\t  /* There exists at least one use of REGNO that cannot be\n+\t     eliminated.  Prevent the defining insn from being deleted.  */\n+\t  reg_equiv_init[regno] = NULL_RTX;\n+\t  alter_reg (regno, -1);\n+\t}\n       return x;\n \n     /* You might think handling MINUS in a manner similar to PLUS is a\n@@ -2359,8 +2377,8 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n \t operand of a load-address insn.  */\n \n       {\n-\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n-\trtx new1 = eliminate_regs (XEXP (x, 1), mem_mode, insn);\n+\trtx new0 = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, true);\n+\trtx new1 = eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, true);\n \n \tif (reg_renumber && (new0 != XEXP (x, 0) || new1 != XEXP (x, 1)))\n \t  {\n@@ -2432,9 +2450,9 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n     case GE:       case GT:       case GEU:    case GTU:\n     case LE:       case LT:       case LEU:    case LTU:\n       {\n-\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n-\trtx new1\n-\t  = XEXP (x, 1) ? eliminate_regs (XEXP (x, 1), mem_mode, insn) : 0;\n+\trtx new0 = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, false);\n+\trtx new1 = XEXP (x, 1)\n+\t\t   ? eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, false) : 0;\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n \t  return gen_rtx_fmt_ee (code, GET_MODE (x), new0, new1);\n@@ -2445,15 +2463,15 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n       /* If we have something in XEXP (x, 0), the usual case, eliminate it.  */\n       if (XEXP (x, 0))\n \t{\n-\t  new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n+\t  new = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, true);\n \t  if (new != XEXP (x, 0))\n \t    {\n \t      /* If this is a REG_DEAD note, it is not valid anymore.\n \t\t Using the eliminated version could result in creating a\n \t\t REG_DEAD note for the stack or frame pointer.  */\n \t      if (GET_MODE (x) == REG_DEAD)\n \t\treturn (XEXP (x, 1)\n-\t\t\t? eliminate_regs (XEXP (x, 1), mem_mode, insn)\n+\t\t\t? eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, true)\n \t\t\t: NULL_RTX);\n \n \t      x = gen_rtx_EXPR_LIST (REG_NOTE_KIND (x), new, XEXP (x, 1));\n@@ -2468,7 +2486,7 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n \t strictly needed, but it simplifies the code.  */\n       if (XEXP (x, 1))\n \t{\n-\t  new = eliminate_regs (XEXP (x, 1), mem_mode, insn);\n+\t  new = eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, true);\n \t  if (new != XEXP (x, 1))\n \t    return\n \t      gen_rtx_fmt_ee (GET_CODE (x), GET_MODE (x), XEXP (x, 0), new);\n@@ -2492,7 +2510,7 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n     case CTZ:\n     case POPCOUNT:\n     case PARITY:\n-      new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n+      new = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, false);\n       if (new != XEXP (x, 0))\n \treturn gen_rtx_fmt_e (code, GET_MODE (x), new);\n       return x;\n@@ -2513,7 +2531,7 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n \t  new = SUBREG_REG (x);\n \t}\n       else\n-\tnew = eliminate_regs (SUBREG_REG (x), mem_mode, insn);\n+\tnew = eliminate_regs_1 (SUBREG_REG (x), mem_mode, insn, false);\n \n       if (new != SUBREG_REG (x))\n \t{\n@@ -2549,12 +2567,12 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n \t case more efficiently.  */\n       return\n \treplace_equiv_address_nv (x,\n-\t\t\t\t  eliminate_regs (XEXP (x, 0),\n-\t\t\t\t\t\t  GET_MODE (x), insn));\n+\t\t\t\t  eliminate_regs_1 (XEXP (x, 0), GET_MODE (x),\n+\t\t\t\t\t\t    insn, true));\n \n     case USE:\n       /* Handle insn_list USE that a call to a pure function may generate.  */\n-      new = eliminate_regs (XEXP (x, 0), 0, insn);\n+      new = eliminate_regs_1 (XEXP (x, 0), 0, insn, false);\n       if (new != XEXP (x, 0))\n \treturn gen_rtx_USE (GET_MODE (x), new);\n       return x;\n@@ -2575,7 +2593,7 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n     {\n       if (*fmt == 'e')\n \t{\n-\t  new = eliminate_regs (XEXP (x, i), mem_mode, insn);\n+\t  new = eliminate_regs_1 (XEXP (x, i), mem_mode, insn, false);\n \t  if (new != XEXP (x, i) && ! copied)\n \t    {\n \t      rtx new_x = rtx_alloc (code);\n@@ -2590,7 +2608,7 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n \t  int copied_vec = 0;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n-\t      new = eliminate_regs (XVECEXP (x, i, j), mem_mode, insn);\n+\t      new = eliminate_regs_1 (XVECEXP (x, i, j), mem_mode, insn, false);\n \t      if (new != XVECEXP (x, i, j) && ! copied_vec)\n \t\t{\n \t\t  rtvec new_v = gen_rtvec_v (XVECLEN (x, i),\n@@ -2613,6 +2631,12 @@ eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n   return x;\n }\n \n+rtx\n+eliminate_regs (rtx x, enum machine_mode mem_mode, rtx insn)\n+{\n+  return eliminate_regs_1 (x, mem_mode, insn, false);\n+}\n+\n /* Scan rtx X for modifications of elimination target registers.  Update\n    the table of eliminables to reflect the changed state.  MEM_MODE is\n    the mode of an enclosing MEM rtx, or VOIDmode if not within a MEM.  */\n@@ -2870,7 +2894,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n   rtx substed_operand[MAX_RECOG_OPERANDS];\n   rtx orig_operand[MAX_RECOG_OPERANDS];\n   struct elim_table *ep;\n-  rtx plus_src;\n+  rtx plus_src, plus_cst_src;\n \n   if (! insn_is_asm && icode < 0)\n     {\n@@ -2975,16 +2999,19 @@ eliminate_regs_in_insn (rtx insn, int replace)\n   /* We allow one special case which happens to work on all machines we\n      currently support: a single set with the source or a REG_EQUAL\n      note being a PLUS of an eliminable register and a constant.  */\n-  plus_src = 0;\n+  plus_src = plus_cst_src = 0;\n   if (old_set && REG_P (SET_DEST (old_set)))\n     {\n-      /* First see if the source is of the form (plus (reg) CST).  */\n-      if (GET_CODE (SET_SRC (old_set)) == PLUS\n-\t  && REG_P (XEXP (SET_SRC (old_set), 0))\n-\t  && GET_CODE (XEXP (SET_SRC (old_set), 1)) == CONST_INT\n-\t  && REGNO (XEXP (SET_SRC (old_set), 0)) < FIRST_PSEUDO_REGISTER)\n+      if (GET_CODE (SET_SRC (old_set)) == PLUS)\n \tplus_src = SET_SRC (old_set);\n-      else if (REG_P (SET_SRC (old_set)))\n+      /* First see if the source is of the form (plus (reg) CST).  */\n+      if (plus_src\n+\t  && REG_P (XEXP (plus_src, 0))\n+\t  && GET_CODE (XEXP (plus_src, 1)) == CONST_INT\n+\t  && REGNO (XEXP (plus_src, 0)) < FIRST_PSEUDO_REGISTER)\n+\tplus_cst_src = plus_src;\n+      else if (REG_P (SET_SRC (old_set))\n+\t       || plus_src)\n \t{\n \t  /* Otherwise, see if we have a REG_EQUAL note of the form\n \t     (plus (reg) CST).  */\n@@ -2997,16 +3024,16 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t\t  && GET_CODE (XEXP (XEXP (links, 0), 1)) == CONST_INT\n \t\t  && REGNO (XEXP (XEXP (links, 0), 0)) < FIRST_PSEUDO_REGISTER)\n \t\t{\n-\t\t  plus_src = XEXP (links, 0);\n+\t\t  plus_cst_src = XEXP (links, 0);\n \t\t  break;\n \t\t}\n \t    }\n \t}\n     }\n-  if (plus_src)\n+  if (plus_cst_src)\n     {\n-      rtx reg = XEXP (plus_src, 0);\n-      HOST_WIDE_INT offset = INTVAL (XEXP (plus_src, 1));\n+      rtx reg = XEXP (plus_cst_src, 0);\n+      HOST_WIDE_INT offset = INTVAL (XEXP (plus_cst_src, 1));\n \n       for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n \tif (ep->from_rtx == reg && ep->can_eliminate)\n@@ -3038,9 +3065,9 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t    /* If we have a nonzero offset, and the source is already\n \t       a simple REG, the following transformation would\n \t       increase the cost of the insn by replacing a simple REG\n-\t       with (plus (reg sp) CST).  So try only when plus_src\n-\t       comes from old_set proper, not REG_NOTES.  */\n-\t    else if (SET_SRC (old_set) == plus_src)\n+\t       with (plus (reg sp) CST).  So try only when we already\n+\t       had a PLUS before.  */\n+\t    else if (plus_src)\n \t      {\n \t\tnew_body = old_body;\n \t\tif (! replace)\n@@ -3079,6 +3106,8 @@ eliminate_regs_in_insn (rtx insn, int replace)\n       /* For an asm statement, every operand is eliminable.  */\n       if (insn_is_asm || insn_data[icode].operand[i].eliminable)\n \t{\n+\t  bool is_set_src, in_plus;\n+\n \t  /* Check for setting a register that we know about.  */\n \t  if (recog_data.operand_type[i] != OP_IN\n \t      && REG_P (orig_operand[i]))\n@@ -3093,8 +3122,21 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t\t  ep->can_eliminate = 0;\n \t    }\n \n-\t  substed_operand[i] = eliminate_regs (recog_data.operand[i], 0,\n-\t\t\t\t\t       replace ? insn : NULL_RTX);\n+\t  /* Companion to the above plus substitution, we can allow\n+\t     invariants as the source of a plain move.  */\n+\t  is_set_src = false;\n+\t  if (old_set && recog_data.operand_loc[i] == &SET_SRC (old_set))\n+\t    is_set_src = true;\n+\t  in_plus = false;\n+\t  if (plus_src\n+\t      && (recog_data.operand_loc[i] == &XEXP (plus_src, 0)\n+\t\t  || recog_data.operand_loc[i] == &XEXP (plus_src, 1)))\n+\t    in_plus = true;\n+\n+\t  substed_operand[i]\n+\t    = eliminate_regs_1 (recog_data.operand[i], 0,\n+\t\t\t        replace ? insn : NULL_RTX,\n+\t\t\t\tis_set_src || in_plus);\n \t  if (substed_operand[i] != orig_operand[i])\n \t    val = 1;\n \t  /* Terminate the search in check_eliminable_occurrences at\n@@ -3222,7 +3264,8 @@ eliminate_regs_in_insn (rtx insn, int replace)\n      of spill registers to be needed in the final reload pass than in\n      the pre-passes.  */\n   if (val && REG_NOTES (insn) != 0)\n-    REG_NOTES (insn) = eliminate_regs (REG_NOTES (insn), 0, REG_NOTES (insn));\n+    REG_NOTES (insn)\n+      = eliminate_regs_1 (REG_NOTES (insn), 0, REG_NOTES (insn), true);\n \n   return val;\n }"}]}