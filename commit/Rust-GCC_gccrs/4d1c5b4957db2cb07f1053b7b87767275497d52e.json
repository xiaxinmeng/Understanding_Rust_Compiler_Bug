{"sha": "4d1c5b4957db2cb07f1053b7b87767275497d52e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQxYzViNDk1N2RiMmNiMDdmMTA1M2I3Yjg3NzY3Mjc1NDk3ZDUyZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-07-20T19:06:46Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-07-20T19:06:46Z"}, "message": "libstdc++: Avoid overflow in istream::get(streambuf&) [LWG 3464]\n\nSimilar to the recent changes to basic_istream::ignore, this change\nensures that _M_gcount doesn't overflow when extracting characters and\ninserting them into another streambuf.\n\nThe solution used here is to use unsigned long long for the count. We\nassume that the number of characters extracted won't exceed the maximum\nvalue for that type, but even if it does we avoid any undefined\nbehaviour.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/istream.tcc\n\t(basic_istream::get(__streambuf_type&, char_type): Use unsigned\n\tlong long for counter and check if it would overflow _M_gcount.\n\t* testsuite/27_io/basic_istream/get/char/lwg3464.cc: New test.\n\t* testsuite/27_io/basic_istream/get/wchar_t/lwg3464.cc: New test.", "tree": {"sha": "177ba6f54bbfb42d2f020e0295ebf30ae0604107", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/177ba6f54bbfb42d2f020e0295ebf30ae0604107"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d1c5b4957db2cb07f1053b7b87767275497d52e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d1c5b4957db2cb07f1053b7b87767275497d52e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d1c5b4957db2cb07f1053b7b87767275497d52e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d1c5b4957db2cb07f1053b7b87767275497d52e/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "138b1d4f58af17986e856e665ffbd561c2c8740e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/138b1d4f58af17986e856e665ffbd561c2c8740e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/138b1d4f58af17986e856e665ffbd561c2c8740e"}], "stats": {"total": 191, "additions": 190, "deletions": 1}, "files": [{"sha": "0289867c50b6bec31da3959b7d18944bcd0917d0", "filename": "libstdc++-v3/include/bits/istream.tcc", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1c5b4957db2cb07f1053b7b87767275497d52e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1c5b4957db2cb07f1053b7b87767275497d52e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc?ref=4d1c5b4957db2cb07f1053b7b87767275497d52e", "patch": "@@ -375,17 +375,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      __streambuf_type* __this_sb = this->rdbuf();\n \t      int_type __c = __this_sb->sgetc();\n \t      char_type __c2 = traits_type::to_char_type(__c);\n+\t      unsigned long long __gcount = 0;\n \n \t      while (!traits_type::eq_int_type(__c, __eof)\n \t\t     && !traits_type::eq_int_type(__c, __idelim)\n \t\t     && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))\n \t\t{\n-\t\t  ++_M_gcount;\n+\t\t  ++__gcount;\n \t\t  __c = __this_sb->snextc();\n \t\t  __c2 = traits_type::to_char_type(__c);\n \t\t}\n \t      if (traits_type::eq_int_type(__c, __eof))\n \t\t__err |= ios_base::eofbit;\n+\t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t      // 3464. istream::gcount() can overflow\n+\t      if (__gcount <= __gnu_cxx::__numeric_traits<streamsize>::__max)\n+\t\t_M_gcount = __gcount;\n+\t      else\n+\t\t_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;\n \t    }\n \t  __catch(__cxxabiv1::__forced_unwind&)\n \t    {"}, {"sha": "6123ca5b713fdd9007ba476b553b782010e49e42", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/get/char/lwg3464.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1c5b4957db2cb07f1053b7b87767275497d52e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fget%2Fchar%2Flwg3464.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1c5b4957db2cb07f1053b7b87767275497d52e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fget%2Fchar%2Flwg3464.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fget%2Fchar%2Flwg3464.cc?ref=4d1c5b4957db2cb07f1053b7b87767275497d52e", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target { ! lp64 } } }\n+\n+#include <istream>\n+#include <streambuf>\n+#include <limits>\n+#include <testsuite_hooks.h>\n+\n+typedef char C;\n+\n+struct buff : std::basic_streambuf<C>\n+{\n+  typedef std::streamsize\t\t  streamsize;\n+  typedef std::numeric_limits<streamsize> limits;\n+\n+  buff() : count(0), buf() { }\n+\n+  int_type underflow()\n+  {\n+    // Number of characters left until we overflow the counter\n+    const streamsize headroom = limits::max() - count;\n+\n+    if (headroom == 0)\n+      return traits_type::eof();\n+\n+    if (bufsz < headroom)\n+      count += bufsz;\n+    else\n+      count = limits::max();\n+\n+    this->setg(buf + 1, buf + 1, buf + bufsz);\n+\n+    return buf[0];\n+  }\n+\n+  int_type overflow(int_type c)\n+  {\n+    if (traits_type::eq_int_type(c , traits_type::eof()))\n+      return c;\n+    this->setp(buf, buf + bufsz - 1);\n+    return traits_type::not_eof(c);\n+  }\n+\n+  streamsize count;\n+\n+  static const streamsize bufsz = (2048 << limits::digits10) + 1;\n+  char_type buf[bufsz];\n+};\n+\n+void\n+test01()\n+{\n+  // Not possible to overflow 64-bit streamsize in reasonable time.\n+  if (std::numeric_limits<std::streamsize>::digits > 32)\n+    return;\n+\n+  std::basic_istream<C> in(new buff);\n+  buff out;\n+  in.get(out);\n+  VERIFY( in.gcount() == std::numeric_limits<std::streamsize>::max() );\n+\n+  delete in.rdbuf(new buff);\n+\n+  in.get();\n+  VERIFY( in.gcount() == 1 );\n+\n+  in.get(out, 'a');\n+  VERIFY( in.gcount() == std::numeric_limits<std::streamsize>::max() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "6df244cc32d993fa7d51589c96ab555f5892ef00", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/get/wchar_t/lwg3464.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1c5b4957db2cb07f1053b7b87767275497d52e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fget%2Fwchar_t%2Flwg3464.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1c5b4957db2cb07f1053b7b87767275497d52e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fget%2Fwchar_t%2Flwg3464.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fget%2Fwchar_t%2Flwg3464.cc?ref=4d1c5b4957db2cb07f1053b7b87767275497d52e", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target { ! lp64 } } }\n+\n+#include <istream>\n+#include <streambuf>\n+#include <limits>\n+#include <testsuite_hooks.h>\n+\n+typedef wchar_t C;\n+\n+struct buff : std::basic_streambuf<C>\n+{\n+  typedef std::streamsize\t\t  streamsize;\n+  typedef std::numeric_limits<streamsize> limits;\n+\n+  buff() : count(0), buf() { }\n+\n+  int_type underflow()\n+  {\n+    // Number of characters left until we overflow the counter\n+    const streamsize headroom = limits::max() - count;\n+\n+    if (headroom == 0)\n+      return traits_type::eof();\n+\n+    if (bufsz < headroom)\n+      count += bufsz;\n+    else\n+      count = limits::max();\n+\n+    this->setg(buf + 1, buf + 1, buf + bufsz);\n+\n+    return buf[0];\n+  }\n+\n+  int_type overflow(int_type c)\n+  {\n+    if (traits_type::eq_int_type(c , traits_type::eof()))\n+      return c;\n+    this->setp(buf, buf + bufsz - 1);\n+    return traits_type::not_eof(c);\n+  }\n+\n+  streamsize count;\n+\n+  static const streamsize bufsz = (2048 << limits::digits10) + 1;\n+  char_type buf[bufsz];\n+};\n+\n+void\n+test01()\n+{\n+  // Not possible to overflow 64-bit streamsize in reasonable time.\n+  if (std::numeric_limits<std::streamsize>::digits > 32)\n+    return;\n+\n+  std::basic_istream<C> in(new buff);\n+  buff out;\n+  in.get(out);\n+  VERIFY( in.gcount() == std::numeric_limits<std::streamsize>::max() );\n+\n+  delete in.rdbuf(new buff);\n+\n+  in.get();\n+  VERIFY( in.gcount() == 1 );\n+\n+  in.get(out, 'a');\n+  VERIFY( in.gcount() == std::numeric_limits<std::streamsize>::max() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}]}