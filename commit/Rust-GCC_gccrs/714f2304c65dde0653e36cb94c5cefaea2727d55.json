{"sha": "714f2304c65dde0653e36cb94c5cefaea2727d55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE0ZjIzMDRjNjVkZGUwNjUzZTM2Y2I5NGM1Y2VmYWVhMjcyN2Q1NQ==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2007-09-24T12:14:57Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2007-09-24T12:14:57Z"}, "message": "re PR c++/33112 (ICE : canonical types differ for identical types const _CharT* [14] and const _CharT* [14])\n\n2007-09-24  Douglas Gregor  <doug.gregor@gmail.com>\n\n\tPR c++/33112\n\tPR c++/33185\t\n\t* tree.c (cplus_array_compare): Compare pointers, not types.\n\t(build_cplus_array_type_1): Store new array type into the hash\n\ttable before building the canonical type; build the canonical type\n\tcorrectly.\n\t(cp_build_qualified_type_real): Put all of the array types with\n\tcv-qualified element types into the C++ array hash table, built as \n\tvariants of the unqualified versions.\n\nFrom-SVN: r128711", "tree": {"sha": "43fb0347a8b05451a453a47db18a6cc43185d35e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43fb0347a8b05451a453a47db18a6cc43185d35e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/714f2304c65dde0653e36cb94c5cefaea2727d55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/714f2304c65dde0653e36cb94c5cefaea2727d55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/714f2304c65dde0653e36cb94c5cefaea2727d55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/714f2304c65dde0653e36cb94c5cefaea2727d55/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "996caac6daf068f5db3b8455db336c1df62ec4f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/996caac6daf068f5db3b8455db336c1df62ec4f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/996caac6daf068f5db3b8455db336c1df62ec4f9"}], "stats": {"total": 131, "additions": 61, "deletions": 70}, "files": [{"sha": "ed3c7ff9031440460a4c25a2dfee7de403dac896", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714f2304c65dde0653e36cb94c5cefaea2727d55/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714f2304c65dde0653e36cb94c5cefaea2727d55/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=714f2304c65dde0653e36cb94c5cefaea2727d55", "patch": "@@ -1,3 +1,15 @@\n+2007-09-24  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\tPR c++/33112\n+\tPR c++/33185\t\n+\t* tree.c (cplus_array_compare): Compare pointers, not types.\n+\t(build_cplus_array_type_1): Store new array type into the hash\n+\ttable before building the canonical type; build the canonical type\n+\tcorrectly.\n+\t(cp_build_qualified_type_real): Put all of the array types with\n+\tcv-qualified element types into the C++ array hash table, built as \n+\tvariants of the unqualified versions.\n+\t\n 2007-09-23  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/16370"}, {"sha": "5f46cbdbf9d9847514e32d448f03e5db99043b3a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 49, "deletions": 70, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714f2304c65dde0653e36cb94c5cefaea2727d55/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714f2304c65dde0653e36cb94c5cefaea2727d55/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=714f2304c65dde0653e36cb94c5cefaea2727d55", "patch": "@@ -512,18 +512,12 @@ cplus_array_compare (const void * k1, const void * k2)\n   const_tree const t1 = (const_tree) k1;\n   const cplus_array_info *const t2 = (const cplus_array_info*) k2;\n \n-  if (!comptypes (TREE_TYPE (t1), t2->type, COMPARE_STRUCTURAL))\n-    return 0;\n-\n-  if (!TYPE_DOMAIN (t1))\n-    return !t2->domain;\n-\n-  if (!t2->domain)\n-    return 0;\n-\n-  return comptypes (TYPE_DOMAIN (t1), t2->domain, COMPARE_STRUCTURAL);\n+  return (TREE_TYPE (t1) == t2->type && TYPE_DOMAIN (t1) == t2->domain);\n }\n \n+/* Hash table containing all of the C++ array types, including\n+   dependent array types and array types whose element type is\n+   cv-qualified.  */\n static GTY ((param_is (union tree_node))) htab_t cplus_array_htab;\n \n \n@@ -542,7 +536,7 @@ build_cplus_array_type_1 (tree elt_type, tree index_type)\n       void **e;\n       cplus_array_info cai;\n       hashval_t hash;\n-      \n+\n       if (cplus_array_htab == NULL)\n \tcplus_array_htab = htab_create_ggc (61, &cplus_array_hash,\n \t\t\t\t\t    &cplus_array_compare, NULL);\n@@ -554,31 +548,31 @@ build_cplus_array_type_1 (tree elt_type, tree index_type)\n \n       e = htab_find_slot_with_hash (cplus_array_htab, &cai, hash, INSERT); \n       if (*e)\n-\t/* We have found the type: we're done. */\n+\t/* We have found the type: we're done.  */\n \treturn (tree) *e;\n       else\n \t{\n-\t  /* Build a new array type. */\n+\t  /* Build a new array type.  */\n \t  t = make_node (ARRAY_TYPE);\n \t  TREE_TYPE (t) = elt_type;\n \t  TYPE_DOMAIN (t) = index_type;\n \n-\t  /* Complete building the array type. */\n+\t  /* Store it in the hash table. */\n+\t  *e = t;\n+\n+\t  /* Set the canonical type for this new node.  */\n \t  if (TYPE_STRUCTURAL_EQUALITY_P (elt_type)\n \t      || (index_type && TYPE_STRUCTURAL_EQUALITY_P (index_type)))\n \t    SET_TYPE_STRUCTURAL_EQUALITY (t);\n \t  else if (TYPE_CANONICAL (elt_type) != elt_type\n \t\t   || (index_type \n \t\t       && TYPE_CANONICAL (index_type) != index_type))\n-\t    TYPE_CANONICAL (t) \n-\t      = TYPE_CANONICAL \n-\t          (build_cplus_array_type_1 (TYPE_CANONICAL (elt_type),\n-\t\t\t\t\t     index_type? \n-\t\t\t\t\t       TYPE_CANONICAL (index_type)\n-\t\t\t\t\t       : index_type));\n-\n-\t  /* Store it in the hash table. */\n-\t  *e = t;\n+\t    TYPE_CANONICAL (t)\n+\t\t= build_cplus_array_type \n+\t\t   (TYPE_CANONICAL (elt_type),\n+\t\t    index_type? TYPE_CANONICAL (index_type) : index_type);\n+\t  else\n+\t    TYPE_CANONICAL (t) = t;\n \t}\n     }\n   else\n@@ -713,59 +707,44 @@ cp_build_qualified_type_real (tree type,\n \n       if (!t)\n \t{\n-\t  tree domain = TYPE_DOMAIN (type);\n+\t  tree index_type = TYPE_DOMAIN (type);\n+\t  void **e;\n+\t  cplus_array_info cai;\n+\t  hashval_t hash;\n+\n+\t  if (cplus_array_htab == NULL)\n+\t    cplus_array_htab = htab_create_ggc (61, &cplus_array_hash,\n+\t\t\t\t\t\t&cplus_array_compare, \n+\t\t\t\t\t\tNULL);\n+\n+\t  hash = (htab_hash_pointer (element_type)\n+\t\t  ^ htab_hash_pointer (index_type));\n+\t  cai.type = element_type;\n+\t  cai.domain = index_type;\n+\t  \n+\t  e = htab_find_slot_with_hash (cplus_array_htab, &cai, hash, INSERT);\n+\t  if (*e)\n+\t    /* We have found the type: we're done. */\n+\t    return (tree) *e;\n \n-\t  /* Make a new array type, just like the old one, but with the\n-\t     appropriately qualified element type.  */\n+\t  /* Build a new array type and add it into the table.  */\n \t  t = build_variant_type_copy (type);\n \t  TREE_TYPE (t) = element_type;\n+\t  *e = t;\n \n-\t  /* This is a new type. */\n-\t  TYPE_CANONICAL (t) = t;\n-\n-\t  if (dependent_type_p (element_type)\n-\t      || (domain\n-\t\t  && value_dependent_expression_p (TYPE_MAX_VALUE (domain))))\n-\t    {\n-\t      /* The new dependent array type we just created might be\n-\t\t equivalent to an existing dependent array type, so we\n-\t\t need to keep track of this new array type with a\n-\t\t lookup into CPLUS_ARRAY_HTAB. Note that we cannot\n-\t\t directly call build_cplus_array_type (that would\n-\t\t recurse) or build_cplus_array_type_1 (that would lose\n-\t\t attributes). */\n-\t      void **e;\n-\t      cplus_array_info cai;\n-\t      hashval_t hash;\n-\n-\t      if (cplus_array_htab == NULL)\n-\t\tcplus_array_htab = htab_create_ggc (61, &cplus_array_hash,\n-\t\t\t\t\t\t    &cplus_array_compare, \n-\t\t\t\t\t\t    NULL);\n-\t  \n-\t      hash = (htab_hash_pointer (element_type)\n-\t\t      ^ htab_hash_pointer (domain));\n-\t      cai.type = element_type;\n-\t      cai.domain = domain;\n-\t  \n-\t      e = htab_find_slot_with_hash (cplus_array_htab, &cai, hash, \n-\t\t\t\t\t    INSERT); \n-\t      if (! *e)\n-\t\t/* Save this new type. */\n-\t\t*e = t;\n-\t    }\n-\n-\t  if (TYPE_STRUCTURAL_EQUALITY_P (TREE_TYPE (t))\n-\t\t   || (TYPE_DOMAIN (t)\n-\t\t       && TYPE_STRUCTURAL_EQUALITY_P (TYPE_DOMAIN (t))))\n+\t  /* Set the canonical type for this new node.  */\n+\t  if (TYPE_STRUCTURAL_EQUALITY_P (element_type)\n+\t      || (index_type && TYPE_STRUCTURAL_EQUALITY_P (index_type)))\n \t    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+\t  else if (TYPE_CANONICAL (element_type) != element_type\n+\t\t   || (index_type \n+\t\t       && TYPE_CANONICAL (index_type) != index_type))\n+\t    TYPE_CANONICAL (t)\n+\t      = build_cplus_array_type\n+\t         (TYPE_CANONICAL (element_type),\n+\t\t  index_type? TYPE_CANONICAL (index_type) : index_type);\n \t  else\n-\t    TYPE_CANONICAL (t) \n-\t      = TYPE_CANONICAL \n-\t          (build_array_type (TYPE_CANONICAL (TREE_TYPE (t)),\n-\t\t\t\t     TYPE_DOMAIN (t)? \n-\t\t\t\t       TYPE_CANONICAL (TYPE_DOMAIN(t))\n-\t\t\t\t       : TYPE_DOMAIN (t)));\n+\t    TYPE_CANONICAL (t) = t;\n \t}\n \n       /* Even if we already had this variant, we update"}]}