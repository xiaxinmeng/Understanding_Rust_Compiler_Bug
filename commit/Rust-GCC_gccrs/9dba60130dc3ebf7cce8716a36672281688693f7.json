{"sha": "9dba60130dc3ebf7cce8716a36672281688693f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRiYTYwMTMwZGMzZWJmN2NjZTg3MTZhMzY2NzIyODE2ODg2OTNmNw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-03-27T14:54:33Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-03-27T14:54:33Z"}, "message": "c++: Fix ICE after ambiguous inline namespace reopen [PR94257]\n\nFollowing DR2061, 'namespace F', looks for 'F's inside inline namespaces.\nThat can result in ambiguous lookups that we failed to diagnose early enough,\nleading us to push a new namespace and ICE later.  Diagnose the ambiguity\nearlier, and then pick one.\n\n\tPR c++/94257\n\t* name-lookup.c (push_namespace): Triage ambiguous lookups that\n\tcontain namespaces.", "tree": {"sha": "038d92e6564dfe1bfaafff5dcb2ccf62171e78e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/038d92e6564dfe1bfaafff5dcb2ccf62171e78e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dba60130dc3ebf7cce8716a36672281688693f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dba60130dc3ebf7cce8716a36672281688693f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dba60130dc3ebf7cce8716a36672281688693f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dba60130dc3ebf7cce8716a36672281688693f7/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6969ac301f2229366a812942a906257e5c060762", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6969ac301f2229366a812942a906257e5c060762", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6969ac301f2229366a812942a906257e5c060762"}], "stats": {"total": 66, "additions": 54, "deletions": 12}, "files": [{"sha": "7224ff195d611f0ce43a01f6c415b244dfd5fb2a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dba60130dc3ebf7cce8716a36672281688693f7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dba60130dc3ebf7cce8716a36672281688693f7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9dba60130dc3ebf7cce8716a36672281688693f7", "patch": "@@ -1,3 +1,9 @@\n+2020-03-27  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/94257\n+\t* name-lookup.c (push_namespace): Triage ambiguous lookups that\n+\tcontain namespaces.\n+\n 2020-03-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/94326"}, {"sha": "e6dfb9cc723575e7b313a005ede57da7f424c570", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dba60130dc3ebf7cce8716a36672281688693f7/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dba60130dc3ebf7cce8716a36672281688693f7/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=9dba60130dc3ebf7cce8716a36672281688693f7", "patch": "@@ -7372,23 +7372,59 @@ push_namespace (tree name, bool make_inline)\n     name_lookup lookup (name, 0);\n     if (!lookup.search_qualified (current_namespace, /*usings=*/false))\n       ;\n-    else if (TREE_CODE (lookup.value) != NAMESPACE_DECL)\n-      ;\n-    else if (tree dna = DECL_NAMESPACE_ALIAS (lookup.value))\n+    else if (TREE_CODE (lookup.value) == TREE_LIST)\n       {\n-\t/* A namespace alias is not allowed here, but if the alias\n-\t   is for a namespace also inside the current scope,\n-\t   accept it with a diagnostic.  That's better than dying\n-\t   horribly.  */\n-\tif (is_nested_namespace (current_namespace, CP_DECL_CONTEXT (dna)))\n+\t/* An ambiguous lookup.  If exactly one is a namespace, we\n+\t   want that.  If more than one is a namespace, error, but\n+\t   pick one of them.  */\n+\t/* DR2061 can cause us to find multiple namespaces of the same\n+\t   name.  We must treat that carefully and avoid thinking we\n+\t   need to push a new (possibly) duplicate namespace.  Hey,\n+\t   if you want to use the same identifier within an inline\n+\t   nest, knock yourself out.  */\n+\tfor (tree *chain = &lookup.value, next; (next = *chain);)\n+\t  {\n+\t    tree decl = TREE_VALUE (next);\n+\t    if (TREE_CODE (decl) == NAMESPACE_DECL)\n+\t      {\n+\t\tif (!ns)\n+\t\t  ns = decl;\n+\t\telse if (SCOPE_DEPTH (ns) >= SCOPE_DEPTH (decl))\n+\t\t  ns = decl;\n+\n+\t\t/* Advance.  */\n+\t\tchain = &TREE_CHAIN (next);\n+\t      }\n+\t    else\n+\t      /* Stitch out.  */\n+\t      *chain = TREE_CHAIN (next);\n+\t  }\n+\n+\tif (TREE_CHAIN (lookup.value))\n \t  {\n-\t    error (\"namespace alias %qD not allowed here, \"\n-\t\t   \"assuming %qD\", lookup.value, dna);\n-\t    ns = dna;\n+\t    error (\"%<namespace %E%> is ambiguous\", name);\n+\t    print_candidates (lookup.value);\n \t  }\n       }\n-    else\n+    else if (TREE_CODE (lookup.value) == NAMESPACE_DECL)\n       ns = lookup.value;\n+\n+    if (ns)\n+      if (tree dna = DECL_NAMESPACE_ALIAS (ns))\n+\t{\n+\t  /* A namespace alias is not allowed here, but if the alias\n+\t     is for a namespace also inside the current scope,\n+\t     accept it with a diagnostic.  That's better than dying\n+\t     horribly.  */\n+\t  if (is_nested_namespace (current_namespace, CP_DECL_CONTEXT (dna)))\n+\t    {\n+\t      error (\"namespace alias %qD not allowed here, \"\n+\t\t     \"assuming %qD\", ns, dna);\n+\t      ns = dna;\n+\t    }\n+\t  else\n+\t    ns = NULL_TREE;\n+\t}\n   }\n \n   bool new_ns = false;"}]}