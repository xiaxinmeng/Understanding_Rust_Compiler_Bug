{"sha": "50e0c6e429e7cc664f6fcea59db22826f005ca19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBlMGM2ZTQyOWU3Y2M2NjRmNmZjZWE1OWRiMjI4MjZmMDA1Y2ExOQ==", "commit": {"author": {"name": "Andrew Sutton", "email": "asutton@lock3software.com", "date": "2019-11-27T15:16:37Z"}, "committer": {"name": "Andrew Sutton", "email": "asutton@gcc.gnu.org", "date": "2019-11-27T15:16:37Z"}, "message": "re PR c++/92439 ([concepts] trunk crashes on constraint satisfaction failure)\n\n2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n\n\tPR c++/92439\n\tImprove quality of diagnostics for subexpressions that need parens.\n\ngcc/cp/\n\t* parser.c (cp_parser_requires_clause_opt): Add a flag to indicate\n\twhen parsing a requires-clause before lambda parameters, and...\n\t(cp_parser_lambda_declarator_opt): ... use that here ...\n\t(cp_parser_type_parameter): ... and here ...\n\t(cp_parser_late_return_type_opt): ... and here ...\n\t(cp_parser_explicit_template_declaration): ... and here.\n\t(cp_parser_diagnose_ungrouped_constraint_plain): Adjust the message\n\tbecause this can apply to subexpressions that are not immediately\n\tafter a requires-clause.\n\t(cp_parser_diagnose_ungrouped_constraint_rich): Likewise.\n\t(primary_constraint_error): New.\n\t(cp_parser_constraint_requires_parens): New.\n\t(cp_parser_unary_constraint_requires_parens): New.\n\t(cp_parser_constraint_primary_expression): Check for unary expressions\n\tbefore parsing the primary expression. Also check for binary and\n\tpostfix operators after a successful parse of the primary expression.\n\tForce a re-parse if the result would form a lower-precedence string.\n\t(cp_parser_constraint_logical_and_expression): Propagate lambda flag;\n\tmove checks for ill-formed constraints into the constraint primary\n\texpression.\n\t(cp_parser_constraint_logical_or_expression): Likewise.\n\t(cp_parser_requires_clause_expression): Propagate lambda flag.\n\ngcc/testsuite/\n\t* g++.dg/cpp2a/concepts-requires20.C: New.\n\nFrom-SVN: r278774", "tree": {"sha": "64d5c8552df1714eea45f75ccb12ffbf7b2cb181", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64d5c8552df1714eea45f75ccb12ffbf7b2cb181"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50e0c6e429e7cc664f6fcea59db22826f005ca19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e0c6e429e7cc664f6fcea59db22826f005ca19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e0c6e429e7cc664f6fcea59db22826f005ca19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e0c6e429e7cc664f6fcea59db22826f005ca19/comments", "author": {"login": "asutton", "id": 570796, "node_id": "MDQ6VXNlcjU3MDc5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/570796?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asutton", "html_url": "https://github.com/asutton", "followers_url": "https://api.github.com/users/asutton/followers", "following_url": "https://api.github.com/users/asutton/following{/other_user}", "gists_url": "https://api.github.com/users/asutton/gists{/gist_id}", "starred_url": "https://api.github.com/users/asutton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asutton/subscriptions", "organizations_url": "https://api.github.com/users/asutton/orgs", "repos_url": "https://api.github.com/users/asutton/repos", "events_url": "https://api.github.com/users/asutton/events{/privacy}", "received_events_url": "https://api.github.com/users/asutton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "72479e324313e8a68a534527f79e741f9a7df6fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72479e324313e8a68a534527f79e741f9a7df6fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72479e324313e8a68a534527f79e741f9a7df6fa"}], "stats": {"total": 375, "additions": 275, "deletions": 100}, "files": [{"sha": "36302e43aca7995645a621e836a5a352365cde49", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e0c6e429e7cc664f6fcea59db22826f005ca19/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e0c6e429e7cc664f6fcea59db22826f005ca19/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=50e0c6e429e7cc664f6fcea59db22826f005ca19", "patch": "@@ -1,3 +1,30 @@\n+2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n+\n+\tPR c++/92439\n+\tImprove quality of diagnostics for subexpressions that need parens.\n+\t* parser.c (cp_parser_requires_clause_opt): Add a flag to indicate\n+\twhen parsing a requires-clause before lambda parameters, and...\n+\t(cp_parser_lambda_declarator_opt): ... use that here ...\n+\t(cp_parser_type_parameter): ... and here ...\n+\t(cp_parser_late_return_type_opt): ... and here ...\n+\t(cp_parser_explicit_template_declaration): ... and here.\n+\t(cp_parser_diagnose_ungrouped_constraint_plain): Adjust the message\n+\tbecause this can apply to subexpressions that are not immediately\n+\tafter a requires-clause.\n+\t(cp_parser_diagnose_ungrouped_constraint_rich): Likewise.\n+\t(primary_constraint_error): New.\n+\t(cp_parser_constraint_requires_parens): New.\n+\t(cp_parser_unary_constraint_requires_parens): New.\n+\t(cp_parser_constraint_primary_expression): Check for unary expressions\n+\tbefore parsing the primary expression. Also check for binary and\n+\tpostfix operators after a successful parse of the primary expression.\n+\tForce a re-parse if the result would form a lower-precedence string.\n+\t(cp_parser_constraint_logical_and_expression): Propagate lambda flag;\n+\tmove checks for ill-formed constraints into the constraint primary\n+\texpression.\n+\t(cp_parser_constraint_logical_or_expression): Likewise.\n+\t(cp_parser_requires_clause_expression): Propagate lambda flag.\n+\n 2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n \n \tPR c++/88395"}, {"sha": "27318d3aeed9c321950809354306e8f56d13911f", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 177, "deletions": 99, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e0c6e429e7cc664f6fcea59db22826f005ca19/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e0c6e429e7cc664f6fcea59db22826f005ca19/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=50e0c6e429e7cc664f6fcea59db22826f005ca19", "patch": "@@ -2440,7 +2440,7 @@ static tree cp_parser_concept_definition\n static tree cp_parser_constraint_expression\n   (cp_parser *);\n static tree cp_parser_requires_clause_opt\n-  (cp_parser *);\n+  (cp_parser *, bool);\n static tree cp_parser_requires_expression\n   (cp_parser *);\n static tree cp_parser_requirement_parameter_list\n@@ -10897,7 +10897,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n       /* We may have a constrained generic lambda; parse the requires-clause\n \t immediately after the template-parameter-list and combine with any\n \t shorthand constraints present.  */\n-      tree dreqs = cp_parser_requires_clause_opt (parser);\n+      tree dreqs = cp_parser_requires_clause_opt (parser, true);\n       if (flag_concepts)\n \t{\n \t  tree reqs = get_shorthand_constraints (current_template_parms);\n@@ -10990,7 +10990,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \tgnu_attrs = cp_parser_gnu_attributes_opt (parser);\n \n       /* Parse optional trailing requires clause.  */\n-      trailing_requires_clause = cp_parser_requires_clause_opt (parser);\n+      trailing_requires_clause = cp_parser_requires_clause_opt (parser, false);\n \n       /* The function parameters must be in scope all the way until after the\n          trailing-return-type in case of decltype.  */\n@@ -16328,11 +16328,11 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n \t/* Look for the `>'.  */\n \tcp_parser_require (parser, CPP_GREATER, RT_GREATER);\n \n-        // If template requirements are present, parse them.\n+\t/* If template requirements are present, parse them.  */\n \tif (flag_concepts)\n           {\n \t    tree reqs = get_shorthand_constraints (current_template_parms);\n-\t    if (tree dreqs = cp_parser_requires_clause_opt (parser))\n+\t    if (tree dreqs = cp_parser_requires_clause_opt (parser, false))\n               reqs = combine_constraint_expressions (reqs, dreqs);\n \t    TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;\n           }\n@@ -21940,7 +21940,7 @@ cp_parser_late_return_type_opt (cp_parser* parser, cp_declarator *declarator,\n \n   /* Function declarations may be followed by a trailing\n      requires-clause.  */\n-  requires_clause = cp_parser_requires_clause_opt (parser);\n+  requires_clause = cp_parser_requires_clause_opt (parser, false);\n \n   if (declare_simd_p)\n     declarator->attributes\n@@ -27122,8 +27122,7 @@ cp_parser_concept_definition (cp_parser *parser)\n static void\n cp_parser_diagnose_ungrouped_constraint_plain (location_t loc)\n {\n-  error_at (loc, \"expression after %<requires%> must be enclosed \"\n-\t\t \"in parentheses\");\n+  error_at (loc, \"expression must be enclosed in parentheses\");\n }\n \n static void\n@@ -27132,56 +27131,48 @@ cp_parser_diagnose_ungrouped_constraint_rich (location_t loc)\n   gcc_rich_location richloc (loc);\n   richloc.add_fixit_insert_before (\"(\");\n   richloc.add_fixit_insert_after (\")\");\n-  error_at (&richloc, \"expression after %<requires%> must be enclosed \"\n-\t\t      \"in parentheses\");\n+  error_at (&richloc, \"expression must be enclosed in parentheses\");\n }\n \n-/* Parse a primary expression within a constraint.  */\n-\n-static cp_expr\n-cp_parser_constraint_primary_expression (cp_parser *parser)\n+/* Characterizes the likely kind of expression intended by a mis-written\n+   primary constraint.  */\n+enum primary_constraint_error\n {\n-  cp_parser_parse_tentatively (parser);\n-  cp_id_kind idk;\n-  location_t loc = input_location;\n-  cp_expr expr = cp_parser_primary_expression (parser,\n-\t\t\t\t\t       /*address_p=*/false,\n-\t\t\t\t\t       /*cast_p=*/false,\n-\t\t\t\t\t       /*template_arg_p=*/false,\n-\t\t\t\t\t       &idk);\n-  expr.maybe_add_location_wrapper ();\n-  if (expr != error_mark_node)\n-    expr = finish_constraint_primary_expr (expr);\n-  if (cp_parser_parse_definitely (parser))\n-    return expr;\n-\n-  /* Retry the parse at a lower precedence. If that succeeds, diagnose the\n-     error, but return the expression as if it were valid.  */\n-  cp_parser_parse_tentatively (parser);\n-  expr = cp_parser_simple_cast_expression (parser);\n-  if (cp_parser_parse_definitely (parser))\n-    {\n-      cp_parser_diagnose_ungrouped_constraint_rich (expr.get_location());\n-      return expr;\n-    }\n-\n-  /* Otherwise, something has gone wrong, but we can't generate a more\n-     meaningful diagnostic or recover.  */\n-  cp_parser_diagnose_ungrouped_constraint_plain (loc);\n-  return error_mark_node;\n-}\n+  pce_ok,\n+  pce_maybe_operator,\n+  pce_maybe_postfix,\n+};\n \n-/* Examine the token following EXPR. If it is an operator in a non-logical\n-   binary expression, diagnose that as an error. Returns ERROR_MARK_NODE.  */\n+/* Returns true if the token(s) following a primary-expression in a\n+   constraint-logical-* expression would require parentheses.  */\n \n-static cp_expr\n-cp_parser_check_non_logical_constraint (cp_parser *parser, cp_expr lhs)\n+static primary_constraint_error\n+cp_parser_constraint_requires_parens (cp_parser *parser, bool lambda_p)\n {\n   cp_token *token = cp_lexer_peek_token (parser->lexer);\n   switch (token->type)\n     {\n       default:\n-        return lhs;\n+\treturn pce_ok;\n+\n+      case CPP_EQ:\n+\t{\n+\t  /* An equal sign may be part of the the definition of a function,\n+\t     and not an assignment operator, when parsing the expression\n+\t     for a trailing requires-clause. For example:\n+\n+\t\ttemplate<typename T>\n+\t\tstruct S {\n+\t\t  S() requires C<T> = default;\n+\t\t};\n+\n+\t     Don't try to reparse this a binary operator.  */\n+\t  if (cp_lexer_nth_token_is_keyword (parser->lexer, 2, RID_DELETE)\n+\t      || cp_lexer_nth_token_is_keyword (parser->lexer, 2, RID_DEFAULT))\n+\t    return pce_ok;\n+\n+\t  gcc_fallthrough ();\n+\t}\n \n       /* Arithmetic operators.  */\n       case CPP_PLUS:\n@@ -27196,15 +27187,13 @@ cp_parser_check_non_logical_constraint (cp_parser *parser, cp_expr lhs)\n       case CPP_RSHIFT:\n       case CPP_LSHIFT:\n       /* Relational operators.  */\n-      /* FIXME: Handle '<=>'.  */\n       case CPP_EQ_EQ:\n       case CPP_NOT_EQ:\n       case CPP_LESS:\n       case CPP_GREATER:\n       case CPP_LESS_EQ:\n       case CPP_GREATER_EQ:\n-      /* Conditional operator */\n-      case CPP_QUERY:\n+      case CPP_SPACESHIP:\n       /* Pointer-to-member.  */\n       case CPP_DOT_STAR:\n       case CPP_DEREF_STAR:\n@@ -27219,52 +27208,138 @@ cp_parser_check_non_logical_constraint (cp_parser *parser, cp_expr lhs)\n       case CPP_XOR_EQ:\n       case CPP_RSHIFT_EQ:\n       case CPP_LSHIFT_EQ:\n-        break;\n+      /* Conditional operator */\n+      case CPP_QUERY:\n+\t/* Unenclosed binary or conditional operator.  */\n+\treturn pce_maybe_operator;\n \n-      case CPP_EQ: {\n-\t/* An equal sign may be part of the the definition of a function,\n-\t   and not an assignment operator, when parsing the expression\n-\t   for a trailing requires-clause. For example:\n+      case CPP_OPEN_PAREN:\n+\t{\n+\t  /* A primary constraint that precedes the parameter-list of a\n+\t     lambda expression is followed by an open paren.\n \n-\t      template<typename T>\n-\t      struct S {\n-\t\tS() requires C<T> = default;\n-\t      }\n+\t\t[]<typename T> requires C (T a, T b) { ... }\n \n-\t   This is not an error.  */\n-\tif (cp_lexer_nth_token_is_keyword (parser->lexer, 2, RID_DELETE)\n-\t    || cp_lexer_nth_token_is_keyword (parser->lexer, 2, RID_DEFAULT))\n-\t  return lhs;\n+\t     Don't try to re-parse this as a postfix expression.  */\n+\t  if (lambda_p)\n+\t    return pce_ok;\n \n-        break;\n-      }\n+\t  gcc_fallthrough ();\n+\t}\n+      case CPP_OPEN_SQUARE:\n+      case CPP_PLUS_PLUS:\n+      case CPP_MINUS_MINUS:\n+      case CPP_DOT:\n+      case CPP_DEREF:\n+\t/* Unenclosed postfix operator.  */\n+\treturn pce_maybe_postfix;\n    }\n+}\n+\n+/* Returns true if the next token begins a unary expression, preceded by\n+   an operator or keyword.  */\n+\n+static bool\n+cp_parser_unary_constraint_requires_parens (cp_parser *parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  switch (token->type)\n+    {\n+      case CPP_NOT:\n+      case CPP_PLUS:\n+      case CPP_MINUS:\n+      case CPP_MULT:\n+      case CPP_COMPL:\n+      case CPP_PLUS_PLUS:\n+      case CPP_MINUS_MINUS:\n+\treturn true;\n+\n+      case CPP_KEYWORD:\n+\t{\n+\t  switch (token->keyword)\n+\t    {\n+\t      case RID_STATCAST:\n+\t      case RID_DYNCAST:\n+\t      case RID_REINTCAST:\n+\t      case RID_CONSTCAST:\n+\t      case RID_TYPEID:\n+\t      case RID_SIZEOF:\n+\t      case RID_ALIGNOF:\n+\t      case RID_NOEXCEPT:\n+\t      case RID_NEW:\n+\t      case RID_DELETE:\n+\t      case RID_THROW:\n+\t\treturn true;\n+\n+\t     default:\n+\t\tbreak;\n+\t  }\n+\t}\n+\n+      default:\n+\tbreak;\n+    }\n+\n+  return false;\n+}\n+\n+/* Parse a primary expression within a constraint.  */\n+\n+static cp_expr\n+cp_parser_constraint_primary_expression (cp_parser *parser, bool lambda_p)\n+{\n+  /* If this looks like a unary expression, parse it as such, but diagnose\n+     it as ill-formed; it requires parens.  */\n+  if (cp_parser_unary_constraint_requires_parens (parser))\n+    {\n+      cp_expr e = cp_parser_assignment_expression (parser, NULL, false, false);\n+      cp_parser_diagnose_ungrouped_constraint_rich (e.get_location());\n+      return e;\n+    }\n \n-   /* Try to parse the RHS as either the remainder of a conditional-expression\n-      or a logical-or-expression so we can form a good diagnostic.  */\n   cp_parser_parse_tentatively (parser);\n-  cp_expr rhs;\n-  if (token->type == CPP_QUERY)\n-    rhs = cp_parser_question_colon_clause (parser, lhs);\n-  else\n+  cp_id_kind idk;\n+  location_t loc = input_location;\n+  cp_expr expr = cp_parser_primary_expression (parser,\n+\t\t\t\t\t       /*address_p=*/false,\n+\t\t\t\t\t       /*cast_p=*/false,\n+\t\t\t\t\t       /*template_arg_p=*/false,\n+\t\t\t\t\t       &idk);\n+  expr.maybe_add_location_wrapper ();\n+\n+  primary_constraint_error pce = pce_ok;\n+  if (expr != error_mark_node)\n     {\n-      cp_lexer_consume_token (parser->lexer);\n-      rhs = cp_parser_binary_expression (parser, false, false, false,\n-\t\t\t\t\t PREC_NOT_OPERATOR, NULL);\n+      /* The primary-expression could be part of an unenclosed non-logical\n+\t compound expression.  */\n+      pce = cp_parser_constraint_requires_parens (parser, lambda_p);\n+      if (pce != pce_ok)\n+\tcp_parser_simulate_error (parser);\n+      else\n+\texpr = finish_constraint_primary_expr (expr);\n     }\n+  if (cp_parser_parse_definitely (parser))\n+    return expr;\n+  if (expr == error_mark_node)\n+    return error_mark_node;\n \n-  /* If we couldn't parse the RHS, then emit the best diagnostic we can.  */\n-  if (!cp_parser_parse_definitely (parser))\n+  /* Retry the parse at a lower precedence. If that succeeds, diagnose the\n+     error, but return the expression as if it were valid.  */\n+  gcc_assert (pce != pce_ok);\n+  cp_parser_parse_tentatively (parser);\n+  if (pce == pce_maybe_operator)\n+    expr = cp_parser_assignment_expression (parser, NULL, false, false);\n+  else\n+    expr = cp_parser_simple_cast_expression (parser);\n+  if (cp_parser_parse_definitely (parser))\n     {\n-      cp_parser_diagnose_ungrouped_constraint_plain (token->location);\n-      return error_mark_node;\n+      cp_parser_diagnose_ungrouped_constraint_rich (expr.get_location());\n+      return expr;\n     }\n \n-  /* Otherwise, emit a fixit for the complete binary expression.  */\n-  location_t loc = make_location (token->location,\n-\t\t\t\t  lhs.get_start(),\n-\t\t\t\t  rhs.get_finish());\n-  cp_parser_diagnose_ungrouped_constraint_rich (loc);\n+  /* Otherwise, something has gone very wrong, and we can't generate a more\n+     meaningful diagnostic or recover.  */\n+  cp_parser_diagnose_ungrouped_constraint_plain (loc);\n   return error_mark_node;\n }\n \n@@ -27275,16 +27350,16 @@ cp_parser_check_non_logical_constraint (cp_parser *parser, cp_expr lhs)\n        constraint-logical-and-expression '&&' primary-expression  */\n \n static cp_expr\n-cp_parser_constraint_logical_and_expression (cp_parser *parser)\n+cp_parser_constraint_logical_and_expression (cp_parser *parser, bool lambda_p)\n {\n-  cp_expr lhs = cp_parser_constraint_primary_expression (parser);\n+  cp_expr lhs = cp_parser_constraint_primary_expression (parser, lambda_p);\n   while (cp_lexer_next_token_is (parser->lexer, CPP_AND_AND))\n     {\n       cp_token *op = cp_lexer_consume_token (parser->lexer);\n-      tree rhs = cp_parser_constraint_primary_expression (parser);\n+      tree rhs = cp_parser_constraint_primary_expression (parser, lambda_p);\n       lhs = finish_constraint_and_expr (op->location, lhs, rhs);\n     }\n-  return cp_parser_check_non_logical_constraint (parser, lhs);\n+  return lhs;\n }\n \n /* Parse a constraint-logical-or-expression.\n@@ -27294,27 +27369,27 @@ cp_parser_constraint_logical_and_expression (cp_parser *parser)\n        constraint-logical-or-expression '||' constraint-logical-and-expression  */\n \n static cp_expr\n-cp_parser_constraint_logical_or_expression (cp_parser *parser)\n+cp_parser_constraint_logical_or_expression (cp_parser *parser, bool lambda_p)\n {\n-  cp_expr lhs = cp_parser_constraint_logical_and_expression (parser);\n+  cp_expr lhs = cp_parser_constraint_logical_and_expression (parser, lambda_p);\n   while (cp_lexer_next_token_is (parser->lexer, CPP_OR_OR))\n     {\n       cp_token *op = cp_lexer_consume_token (parser->lexer);\n-      cp_expr rhs = cp_parser_constraint_logical_and_expression (parser);\n+      cp_expr rhs = cp_parser_constraint_logical_and_expression (parser, lambda_p);\n       lhs = finish_constraint_or_expr (op->location, lhs, rhs);\n     }\n-  return cp_parser_check_non_logical_constraint (parser, lhs);\n+  return lhs;\n }\n \n /* Parse the expression after a requires-clause. This has a different grammar\n     than that in the concepts TS.  */\n \n static tree\n-cp_parser_requires_clause_expression (cp_parser *parser)\n+cp_parser_requires_clause_expression (cp_parser *parser, bool lambda_p)\n {\n   processing_constraint_expression_sentinel parsing_constraint;\n   ++processing_template_decl;\n-  cp_expr expr = cp_parser_constraint_logical_or_expression (parser);\n+  cp_expr expr = cp_parser_constraint_logical_or_expression (parser, lambda_p);\n   if (check_for_bare_parameter_packs (expr))\n     expr = error_mark_node;\n   --processing_template_decl;\n@@ -27347,12 +27422,15 @@ cp_parser_constraint_expression (cp_parser *parser)\n /* Optionally parse a requires clause:\n \n       requires-clause:\n-        `requires` constraint-logical-or-expression.\n+\t`requires` constraint-logical-or-expression.\n    [ConceptsTS]\n-        `requires constraint-expression.  */\n+\t`requires constraint-expression.\n+\n+   LAMBDA_P is true when the requires-clause is parsed before the\n+   parameter-list of a lambda-declarator.  */\n \n static tree\n-cp_parser_requires_clause_opt (cp_parser *parser)\n+cp_parser_requires_clause_opt (cp_parser *parser, bool lambda_p)\n {\n   cp_token *tok = cp_lexer_peek_token (parser->lexer);\n   if (tok->keyword != RID_REQUIRES)\n@@ -27372,7 +27450,7 @@ cp_parser_requires_clause_opt (cp_parser *parser)\n   cp_lexer_consume_token (parser->lexer);\n \n   if (!flag_concepts_ts)\n-    return cp_parser_requires_clause_expression (parser);\n+    return cp_parser_requires_clause_expression (parser, lambda_p);\n   else\n     return cp_parser_constraint_expression (parser);\n }\n@@ -28927,7 +29005,7 @@ cp_parser_explicit_template_declaration (cp_parser* parser, bool member_p)\n   if (flag_concepts)\n   {\n     tree reqs = get_shorthand_constraints (current_template_parms);\n-    if (tree treqs = cp_parser_requires_clause_opt (parser))\n+    if (tree treqs = cp_parser_requires_clause_opt (parser, false))\n       reqs = combine_constraint_expressions (reqs, treqs);\n     TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;\n   }"}, {"sha": "9b22c91ce69bf1d752e58f9419fd26ad9ca03f3e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e0c6e429e7cc664f6fcea59db22826f005ca19/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e0c6e429e7cc664f6fcea59db22826f005ca19/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=50e0c6e429e7cc664f6fcea59db22826f005ca19", "patch": "@@ -1,4 +1,9 @@\n-2019-11-18  Andrew Sutton  <asutton@lock3software.com>\n+2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n+\n+\tPR c++/92439\n+\t* g++.dg/cpp2a/concepts-requires20.C: New.\n+\n+2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n \n \tPR c++/88395\n \t* g++.dg/cpp2a/concepts-pr88395.C: New."}, {"sha": "089db2ba01351bc884bdda507151ee19cf615dd6", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires20.C", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e0c6e429e7cc664f6fcea59db22826f005ca19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e0c6e429e7cc664f6fcea59db22826f005ca19/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires20.C?ref=50e0c6e429e7cc664f6fcea59db22826f005ca19", "patch": "@@ -0,0 +1,65 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename ...>\n+constexpr bool r () { return true; }\n+\n+template<typename ... Ts>\n+  requires r<Ts...>() // { dg-error \"enclose\" }\n+void f() { }\n+\n+template<typename T, T N>\n+  requires ++N // { dg-error \"enclose\" }\n+void f() { }\n+\n+template<typename T, T N>\n+  requires N++ // { dg-error \"enclose\" }\n+void f() { }\n+\n+template<typename T, T N>\n+  requires N == 0 // { dg-error \"enclose\" }\n+void f() { }\n+\n+template<typename T, T N>\n+  requires N ? true : false // { dg-error \"enclose\" }\n+void f() { }\n+\n+template<typename T, T N>\n+  requires N = 0 // { dg-error \"enclose\" }\n+void f() { }\n+\n+template<typename T, T N>\n+  requires N + 1 // { dg-error \"enclose\" }\n+void f() { }\n+\n+template<typename T, T N>\n+  requires N - 1 // { dg-error \"enclose\" }\n+void f() { }\n+\n+template<typename T, T N>\n+  requires N.x // { dg-error \"enclose\" }\n+void f() { }\n+\n+template<typename T, T N>\n+  requires N->x && true // { dg-error \"enclose\" }\n+void f() { }\n+\n+template<typename T, T N>\n+  requires N && N\n+void f() { }\n+\n+template<typename T, T N>\n+  requires N || N\n+void f() { }\n+\n+template<typename T, T N>\n+  requires N || !N // { dg-error \"enclose\" }\n+void f() { }\n+\n+template<typename T, T N>\n+  requires N[0] // { dg-error \"enclose\" }\n+void f() { }\n+\n+template<typename T, T N>\n+  requires static_cast<bool>(N) // { dg-error \"enclose\" }\n+void f() { }\n+"}]}