{"sha": "494bec025002df422f2faa947138bf3643d80b54", "node_id": "C_kwDOANBUbNoAKDQ5NGJlYzAyNTAwMmRmNDIyZjJmYWE5NDcxMzhiZjM2NDNkODBiNTQ", "commit": {"author": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2022-06-12T03:20:16Z"}, "committer": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2022-06-12T03:25:04Z"}, "message": "PR96463: Optimise svld1rq from vectors for little endian AArch64 targets.\n\nThe patch folds:\nlhs = svld1rq({-1, -1, ...}, rhs)\ninto:\ntmp = mem_ref<vectype> [(elem_type * {ref-all}) rhs]\nlhs = vec_perm_expr<tmp, tmp, {0, 1, 2, 3 ...}>.\nwhich is then expanded using aarch64_expand_sve_dupq.\n\nExample:\n\nsvint32_t\nfoo (int32x4_t x)\n{\n  return svld1rq (svptrue_b8 (), &x[0]);\n}\n\ncode-gen:\nfoo:\n.LFB4350:\n\tdup     z0.q, z0.q[0]\n\tret\n\nThe patch relaxes type-checking for VEC_PERM_EXPR by allowing different\nvector types for lhs and rhs provided:\n(1) rhs3 is constant and has integer type element.\n(2) len(lhs) == len(rhs3) and len(rhs1) == len(rhs2)\n(3) lhs and rhs have same element type.\n\ngcc/ChangeLog:\n\tPR target/96463\n\t* config/aarch64/aarch64-sve-builtins-base.cc: Include ssa.h.\n\t(svld1rq_impl::fold): Define.\n\t* config/aarch64/aarch64.cc (expand_vec_perm_d): Define new members\n\top_mode and op_vec_flags.\n\t(aarch64_evpc_reencode): Initialize newd.op_mode and\n\tnewd.op_vec_flags.\n\t(aarch64_evpc_sve_dup): New function.\n\t(aarch64_expand_vec_perm_const_1): Gate existing calls to\n\taarch64_evpc_* functions under d->vmode == d->op_mode,\n\tand call aarch64_evpc_sve_dup.\n\t(aarch64_vectorize_vec_perm_const): Remove assert\n\td->vmode != d->op_mode, and initialize d.op_mode and d.op_vec_flags.\n\t* tree-cfg.cc (verify_gimple_assign_ternary): Allow different\n\tvector types for lhs and rhs in VEC_PERM_EXPR if rhs3 is\n\tconstant.\n\ngcc/testsuite/ChangeLog:\n\tPR target/96463\n\t* gcc.target/aarch64/sve/acle/general/pr96463-1.c: New test.\n\t* gcc.target/aarch64/sve/acle/general/pr96463-2.c: Likewise.", "tree": {"sha": "e6c5ba8e07f688100d879290d8b2f3ad929e34e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6c5ba8e07f688100d879290d8b2f3ad929e34e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/494bec025002df422f2faa947138bf3643d80b54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494bec025002df422f2faa947138bf3643d80b54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/494bec025002df422f2faa947138bf3643d80b54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494bec025002df422f2faa947138bf3643d80b54/comments", "author": null, "committer": null, "parents": [{"sha": "cbd842717ec5cab989141bf1575846c2acef818d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbd842717ec5cab989141bf1575846c2acef818d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbd842717ec5cab989141bf1575846c2acef818d"}], "stats": {"total": 252, "additions": 212, "deletions": 40}, "files": [{"sha": "82f9eba5c397af04924bdebdc684a1d77682d3fd", "filename": "gcc/config/aarch64/aarch64-sve-builtins-base.cc", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bec025002df422f2faa947138bf3643d80b54/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bec025002df422f2faa947138bf3643d80b54/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins-base.cc?ref=494bec025002df422f2faa947138bf3643d80b54", "patch": "@@ -44,6 +44,7 @@\n #include \"aarch64-sve-builtins-shapes.h\"\n #include \"aarch64-sve-builtins-base.h\"\n #include \"aarch64-sve-builtins-functions.h\"\n+#include \"ssa.h\"\n \n using namespace aarch64_sve;\n \n@@ -1207,6 +1208,64 @@ class svld1rq_impl : public load_replicate\n     insn_code icode = code_for_aarch64_sve_ld1rq (e.vector_mode (0));\n     return e.use_contiguous_load_insn (icode);\n   }\n+\n+  gimple *\n+  fold (gimple_folder &f) const override\n+  {\n+    tree arg0 = gimple_call_arg (f.call, 0);\n+    tree arg1 = gimple_call_arg (f.call, 1);\n+\n+    /* Transform:\n+       lhs = svld1rq ({-1, -1, ... }, arg1)\n+       into:\n+       tmp = mem_ref<vectype> [(elem * {ref-all}) arg1]\n+       lhs = vec_perm_expr<tmp, tmp, {0, 1, 2, 3, ...}>.\n+       on little endian target.\n+       vectype is the corresponding ADVSIMD type.  */\n+\n+    if (!BYTES_BIG_ENDIAN\n+\t&& integer_all_onesp (arg0))\n+      {\n+\ttree lhs = gimple_call_lhs (f.call);\n+\ttree lhs_type = TREE_TYPE (lhs);\n+\tpoly_uint64 lhs_len = TYPE_VECTOR_SUBPARTS (lhs_type);\n+\ttree eltype = TREE_TYPE (lhs_type);\n+\n+\tscalar_mode elmode = GET_MODE_INNER (TYPE_MODE (lhs_type));\n+\tmachine_mode vq_mode = aarch64_vq_mode (elmode).require ();\n+\ttree vectype = build_vector_type_for_mode (eltype, vq_mode);\n+\n+\ttree elt_ptr_type\n+\t  = build_pointer_type_for_mode (eltype, VOIDmode, true);\n+\ttree zero = build_zero_cst (elt_ptr_type);\n+\n+\t/* Use element type alignment.  */\n+\ttree access_type\n+\t  = build_aligned_type (vectype, TYPE_ALIGN (eltype));\n+\n+\ttree mem_ref_lhs = make_ssa_name_fn (cfun, access_type, 0);\n+\ttree mem_ref_op = fold_build2 (MEM_REF, access_type, arg1, zero);\n+\tgimple *mem_ref_stmt\n+\t  = gimple_build_assign (mem_ref_lhs, mem_ref_op);\n+\tgsi_insert_before (f.gsi, mem_ref_stmt, GSI_SAME_STMT);\n+\n+\tint source_nelts = TYPE_VECTOR_SUBPARTS (access_type).to_constant ();\n+\tvec_perm_builder sel (lhs_len, source_nelts, 1);\n+\tfor (int i = 0; i < source_nelts; i++)\n+\t  sel.quick_push (i);\n+\n+\tvec_perm_indices indices (sel, 1, source_nelts);\n+\tgcc_checking_assert (can_vec_perm_const_p (TYPE_MODE (lhs_type),\n+\t\t\t\t\t\t   TYPE_MODE (access_type),\n+\t\t\t\t\t\t   indices));\n+\ttree mask_type = build_vector_type (ssizetype, lhs_len);\n+\ttree mask = vec_perm_indices_to_tree (mask_type, indices);\n+\treturn gimple_build_assign (lhs, VEC_PERM_EXPR,\n+\t\t\t\t    mem_ref_lhs, mem_ref_lhs, mask);\n+      }\n+\n+    return NULL;\n+  }\n };\n \n class svld1ro_impl : public load_replicate"}, {"sha": "d21e041eccbc755b73703e144cd71559f86dc241", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 68, "deletions": 27, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bec025002df422f2faa947138bf3643d80b54/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bec025002df422f2faa947138bf3643d80b54/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=494bec025002df422f2faa947138bf3643d80b54", "patch": "@@ -23342,7 +23342,9 @@ struct expand_vec_perm_d\n   rtx target, op0, op1;\n   vec_perm_indices perm;\n   machine_mode vmode;\n+  machine_mode op_mode;\n   unsigned int vec_flags;\n+  unsigned int op_vec_flags;\n   bool one_vector_p;\n   bool testing_p;\n };\n@@ -23577,6 +23579,8 @@ aarch64_evpc_reencode (struct expand_vec_perm_d *d)\n \n   newd.vmode = new_mode;\n   newd.vec_flags = VEC_ADVSIMD;\n+  newd.op_mode = newd.vmode;\n+  newd.op_vec_flags = newd.vec_flags;\n   newd.target = d->target ? gen_lowpart (new_mode, d->target) : NULL;\n   newd.op0 = d->op0 ? gen_lowpart (new_mode, d->op0) : NULL;\n   newd.op1 = d->op1 ? gen_lowpart (new_mode, d->op1) : NULL;\n@@ -23891,6 +23895,33 @@ aarch64_evpc_sve_tbl (struct expand_vec_perm_d *d)\n   return true;\n }\n \n+/* Try to implement D using SVE dup instruction.  */\n+\n+static bool\n+aarch64_evpc_sve_dup (struct expand_vec_perm_d *d)\n+{\n+  if (BYTES_BIG_ENDIAN\n+      || !d->one_vector_p\n+      || d->vec_flags != VEC_SVE_DATA\n+      || d->op_vec_flags != VEC_ADVSIMD\n+      || d->perm.encoding ().nelts_per_pattern () != 1\n+      || !known_eq (d->perm.encoding ().npatterns (),\n+\t\t    GET_MODE_NUNITS (d->op_mode))\n+      || !known_eq (GET_MODE_BITSIZE (d->op_mode), 128))\n+    return false;\n+\n+  int npatterns = d->perm.encoding ().npatterns ();\n+  for (int i = 0; i < npatterns; i++)\n+    if (!known_eq (d->perm[i], i))\n+      return false;\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  aarch64_expand_sve_dupq (d->target, GET_MODE (d->target), d->op0);\n+  return true;\n+}\n+\n /* Try to implement D using SVE SEL instruction.  */\n \n static bool\n@@ -24014,6 +24045,8 @@ aarch64_evpc_ins (struct expand_vec_perm_d *d)\n static bool\n aarch64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n {\n+  gcc_assert (d->op_mode != E_VOIDmode);\n+\n   /* The pattern matching functions above are written to look for a small\n      number to begin the sequence (0, 1, N/2).  If we begin with an index\n      from the second operand, we can swap the operands.  */\n@@ -24030,30 +24063,39 @@ aarch64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n        || d->vec_flags == VEC_SVE_PRED)\n       && known_gt (nelt, 1))\n     {\n-      if (aarch64_evpc_rev_local (d))\n-\treturn true;\n-      else if (aarch64_evpc_rev_global (d))\n-\treturn true;\n-      else if (aarch64_evpc_ext (d))\n-\treturn true;\n-      else if (aarch64_evpc_dup (d))\n-\treturn true;\n-      else if (aarch64_evpc_zip (d))\n-\treturn true;\n-      else if (aarch64_evpc_uzp (d))\n-\treturn true;\n-      else if (aarch64_evpc_trn (d))\n-\treturn true;\n-      else if (aarch64_evpc_sel (d))\n-\treturn true;\n-      else if (aarch64_evpc_ins (d))\n-\treturn true;\n-      else if (aarch64_evpc_reencode (d))\n-\treturn true;\n-      if (d->vec_flags == VEC_SVE_DATA)\n-\treturn aarch64_evpc_sve_tbl (d);\n-      else if (d->vec_flags == VEC_ADVSIMD)\n-\treturn aarch64_evpc_tbl (d);\n+      if (d->vmode == d->op_mode)\n+\t{\n+\t  if (aarch64_evpc_rev_local (d))\n+\t    return true;\n+\t  else if (aarch64_evpc_rev_global (d))\n+\t    return true;\n+\t  else if (aarch64_evpc_ext (d))\n+\t    return true;\n+\t  else if (aarch64_evpc_dup (d))\n+\t    return true;\n+\t  else if (aarch64_evpc_zip (d))\n+\t    return true;\n+\t  else if (aarch64_evpc_uzp (d))\n+\t    return true;\n+\t  else if (aarch64_evpc_trn (d))\n+\t    return true;\n+\t  else if (aarch64_evpc_sel (d))\n+\t    return true;\n+\t  else if (aarch64_evpc_ins (d))\n+\t    return true;\n+\t  else if (aarch64_evpc_reencode (d))\n+\t    return true;\n+\n+\t  if (d->vec_flags == VEC_SVE_DATA)\n+\t    return aarch64_evpc_sve_tbl (d);\n+\t  else if (d->vec_flags == VEC_ADVSIMD)\n+\t    return aarch64_evpc_tbl (d);\n+\t}\n+      else\n+\t{\n+\t  if (aarch64_evpc_sve_dup (d))\n+\t    return true;\n+\t}\n     }\n   return false;\n }\n@@ -24065,9 +24107,6 @@ aarch64_vectorize_vec_perm_const (machine_mode vmode, machine_mode op_mode,\n \t\t\t\t  rtx target, rtx op0, rtx op1,\n \t\t\t\t  const vec_perm_indices &sel)\n {\n-  if (vmode != op_mode)\n-    return false;\n-\n   struct expand_vec_perm_d d;\n \n   /* Check whether the mask can be applied to a single vector.  */\n@@ -24091,6 +24130,8 @@ aarch64_vectorize_vec_perm_const (machine_mode vmode, machine_mode op_mode,\n \t\t     sel.nelts_per_input ());\n   d.vmode = vmode;\n   d.vec_flags = aarch64_classify_vector_mode (d.vmode);\n+  d.op_mode = op_mode;\n+  d.op_vec_flags = aarch64_classify_vector_mode (d.op_mode);\n   d.target = target;\n   d.op0 = op0 ? force_reg (vmode, op0) : NULL_RTX;\n   if (op0 == op1)"}, {"sha": "b68f43cc3ba41205aef52dc2beb51740a422cfa7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/pr96463-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bec025002df422f2faa947138bf3643d80b54/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpr96463-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bec025002df422f2faa947138bf3643d80b54/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpr96463-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpr96463-1.c?ref=494bec025002df422f2faa947138bf3643d80b54", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+\n+#include \"arm_neon.h\"\n+#include \"arm_sve.h\"\n+\n+#define TEST(ret_type, param_type, suffix) \\\n+ret_type test_##suffix(param_type x) \\\n+{ \\\n+  return svld1rq_##suffix (svptrue_b8 (), &x[0]); \\\n+}\n+\n+TEST(svint8_t, int8x16_t, s8)\n+TEST(svint16_t, int16x8_t, s16)\n+TEST(svint32_t, int32x4_t, s32)\n+TEST(svint64_t, int64x2_t, s64)\n+\n+TEST(svuint8_t, uint8x16_t, u8)\n+TEST(svuint16_t, uint16x8_t, u16)\n+TEST(svuint32_t, uint32x4_t, u32)\n+TEST(svuint64_t, uint64x2_t, u64)\n+\n+TEST(svfloat16_t, float16x8_t, f16)\n+TEST(svfloat32_t, float32x4_t, f32)\n+TEST(svfloat64_t, float64x2_t, f64)\n+\n+TEST(svbfloat16_t, bfloat16x8_t, bf16)\n+\n+/* { dg-final { scan-assembler-times {\\tdup\\tz[0-9]+\\.q, z[0-9]+\\.q\\[0\\]} 12 { target aarch64_little_endian } } } */"}, {"sha": "196de3f5e0a3b7050c3fec11a566d0fc52ce71cf", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/pr96463-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bec025002df422f2faa947138bf3643d80b54/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpr96463-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bec025002df422f2faa947138bf3643d80b54/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpr96463-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Fpr96463-2.c?ref=494bec025002df422f2faa947138bf3643d80b54", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+\n+#include \"arm_neon.h\"\n+#include \"arm_sve.h\"\n+\n+#define TEST(ret_type, param_type, suffix) \\\n+ret_type test_##suffix(param_type *x) \\\n+{ \\\n+  return svld1rq_##suffix (svptrue_b8 (), &x[0]); \\\n+}\n+\n+TEST(svint8_t, int8_t, s8)\n+TEST(svint16_t, int16_t, s16)\n+TEST(svint32_t, int32_t, s32)\n+TEST(svint64_t, int64_t, s64)\n+\n+TEST(svuint8_t, uint8_t, u8)\n+TEST(svuint16_t, uint16_t, u16)\n+TEST(svuint32_t, uint32_t, u32)\n+TEST(svuint64_t, uint64_t, u64)\n+\n+TEST(svfloat16_t, float16_t, f16)\n+TEST(svfloat32_t, float32_t, f32)\n+TEST(svfloat64_t, float64_t, f64)\n+\n+TEST(svbfloat16_t, bfloat16_t, bf16)\n+\n+/* { dg-final { scan-assembler-times {\\tdup\\tz[0-9]+\\.q, z[0-9]+\\.q\\[0\\]} 12 { target aarch64_little_endian } } } */"}, {"sha": "9e5d84a980552667dc7dce48519fb45c8e36449c", "filename": "gcc/tree-cfg.cc", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494bec025002df422f2faa947138bf3643d80b54/gcc%2Ftree-cfg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494bec025002df422f2faa947138bf3643d80b54/gcc%2Ftree-cfg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.cc?ref=494bec025002df422f2faa947138bf3643d80b54", "patch": "@@ -4297,18 +4297,14 @@ verify_gimple_assign_ternary (gassign *stmt)\n       break;\n \n     case VEC_PERM_EXPR:\n-      if (!useless_type_conversion_p (lhs_type, rhs1_type)\n-\t  || !useless_type_conversion_p (lhs_type, rhs2_type))\n-\t{\n-\t  error (\"type mismatch in %qs\", code_name);\n-\t  debug_generic_expr (lhs_type);\n-\t  debug_generic_expr (rhs1_type);\n-\t  debug_generic_expr (rhs2_type);\n-\t  debug_generic_expr (rhs3_type);\n-\t  return true;\n-\t}\n+      /* If permute is constant, then we allow for lhs and rhs\n+\t to have different vector types, provided:\n+\t (1) lhs, rhs1, rhs2 have same element type.\n+\t (2) rhs3 vector is constant and has integer element type.\n+\t (3) len(lhs) == len(rhs3) && len(rhs1) == len(rhs2).  */\n \n-      if (TREE_CODE (rhs1_type) != VECTOR_TYPE\n+      if (TREE_CODE (lhs_type) != VECTOR_TYPE\n+\t  || TREE_CODE (rhs1_type) != VECTOR_TYPE\n \t  || TREE_CODE (rhs2_type) != VECTOR_TYPE\n \t  || TREE_CODE (rhs3_type) != VECTOR_TYPE)\n \t{\n@@ -4320,10 +4316,28 @@ verify_gimple_assign_ternary (gassign *stmt)\n \t  return true;\n \t}\n \n+      /* If rhs3 is constant, we allow lhs, rhs1 and rhs2 to be different vector types,\n+\t as long as lhs, rhs1 and rhs2 have same element type.  */\n+      if (TREE_CONSTANT (rhs3)\n+\t  ? (!useless_type_conversion_p (TREE_TYPE (lhs_type), TREE_TYPE (rhs1_type))\n+\t     || !useless_type_conversion_p (TREE_TYPE (lhs_type), TREE_TYPE (rhs2_type)))\n+\t  : (!useless_type_conversion_p (lhs_type, rhs1_type)\n+\t     || !useless_type_conversion_p (lhs_type, rhs2_type)))\n+\t{\n+\t    error (\"type mismatch in %qs\", code_name);\n+\t    debug_generic_expr (lhs_type);\n+\t    debug_generic_expr (rhs1_type);\n+\t    debug_generic_expr (rhs2_type);\n+\t    debug_generic_expr (rhs3_type);\n+\t    return true;\n+\t}\n+\n+      /* If rhs3 is constant, relax the check len(rhs2) == len(rhs3).  */\n       if (maybe_ne (TYPE_VECTOR_SUBPARTS (rhs1_type),\n \t\t    TYPE_VECTOR_SUBPARTS (rhs2_type))\n-\t  || maybe_ne (TYPE_VECTOR_SUBPARTS (rhs2_type),\n-\t\t       TYPE_VECTOR_SUBPARTS (rhs3_type))\n+\t  || (!TREE_CONSTANT(rhs3)\n+\t      && maybe_ne (TYPE_VECTOR_SUBPARTS (rhs2_type),\n+\t\t\t   TYPE_VECTOR_SUBPARTS (rhs3_type)))\n \t  || maybe_ne (TYPE_VECTOR_SUBPARTS (rhs3_type),\n \t\t       TYPE_VECTOR_SUBPARTS (lhs_type)))\n \t{"}]}