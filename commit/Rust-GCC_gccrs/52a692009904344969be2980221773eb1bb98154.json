{"sha": "52a692009904344969be2980221773eb1bb98154", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJhNjkyMDA5OTA0MzQ0OTY5YmUyOTgwMjIxNzczZWIxYmI5ODE1NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-29T20:12:40Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-29T20:12:40Z"}, "message": "(FRAME_POINTER_REGNUM): Now register 63.\n\n(HARD_FRAME_POINTER_REGNUM): New macro.\n(CONDITIONAL_REGISTER_USAGE, REG_CLASS_CONTENTS, REGNO_REG_CLASS):\nShow register 63 is not an FP register.\n(REGHNO_OK_FOR_BASE_P, REG_OK_FOR_BASE_P, REGISTER_NAMES): Likewise.\n(ALPHA_ROUND): New macro.\n(STARTING_FRAME_OFFSET, ELIMINABLE_REGS, INITIAL_ELIMINATION_OFFSET):\nModify to reflect save area between outgoing args and local vars.\n\nFrom-SVN: r7607", "tree": {"sha": "21489975d4c5c20c6f477307c66c8246b1e44b62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21489975d4c5c20c6f477307c66c8246b1e44b62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52a692009904344969be2980221773eb1bb98154", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a692009904344969be2980221773eb1bb98154", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52a692009904344969be2980221773eb1bb98154", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a692009904344969be2980221773eb1bb98154/comments", "author": null, "committer": null, "parents": [{"sha": "d60a05a1c4bfb76cb83594b531df4a3884c30829", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60a05a1c4bfb76cb83594b531df4a3884c30829", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d60a05a1c4bfb76cb83594b531df4a3884c30829"}], "stats": {"total": 63, "additions": 37, "deletions": 26}, "files": [{"sha": "5e53b959d1ac0ef68775e04ce719018fa302dc6e", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a692009904344969be2980221773eb1bb98154/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a692009904344969be2980221773eb1bb98154/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=52a692009904344969be2980221773eb1bb98154", "patch": "@@ -108,7 +108,7 @@ extern int target_flags;\n \n #define CONDITIONAL_REGISTER_USAGE\t\\\n   if (! TARGET_FPREGS)\t\t\t\\\n-    for (i = 32; i < 64; i++)\t\t\\\n+    for (i = 32; i < 63; i++)\t\t\\\n       fixed_regs[i] = call_used_regs[i] = 1;\n \n /* Show we can debug even without a frame pointer.  */\n@@ -276,7 +276,11 @@ extern int target_flags;\n    Since $31 is always zero, we will use register number 31 as the\n    argument pointer.  It will never appear in the generated code\n    because we will always be eliminating it in favor of the stack\n-   poointer or frame pointer.  */\n+   pointer or hardware frame pointer.\n+\n+   Likewise, we use $f31 for the frame pointer, which will always\n+   be eliminated in favor of the hardware frame pointer or the\n+   stack pointer.  */\n \n #define FIRST_PSEUDO_REGISTER 64\n \n@@ -321,7 +325,7 @@ extern int target_flags;\n    $26\t\t\t(return PC)\n    $15\t\t\t(frame pointer)\n    $29\t\t\t(global pointer)\n-   $30, $31, $f31\t(stack pointer and always zero/ap)  */\n+   $30, $31, $f31\t(stack pointer and always zero/ap & fp)  */\n \n #define REG_ALLOC_ORDER\t\t\\\n   {33,\t\t\t\t\t\\\n@@ -376,7 +380,7 @@ extern int target_flags;\n #define STACK_POINTER_REGNUM 30\n \n /* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 15\n+#define HARD_FRAME_POINTER_REGNUM 15\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n@@ -387,6 +391,9 @@ extern int target_flags;\n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM 31\n \n+/* Base register for access to local variables of function.  */\n+#define FRAME_POINTER_REGNUM 63\n+\n /* Register in which static-chain is passed to a function. \n \n    For the Alpha, this is based on an example; the calling sequence\n@@ -433,14 +440,15 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    of length N_REG_CLASSES.  */\n \n #define REG_CLASS_CONTENTS\t\\\n-  { {0, 0}, {~0, 0}, {0, ~0}, {~0, ~0} }\n+  { {0, 0}, {~0, 0x80000000}, {0, 0x7fffffff}, {~0, ~0} }\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-#define REGNO_REG_CLASS(REGNO) ((REGNO) >= 32 ? FLOAT_REGS : GENERAL_REGS)\n+#define REGNO_REG_CLASS(REGNO) \\\n+ ((REGNO) >= 32 && (REGNO) <= 62 ? FLOAT_REGS : GENERAL_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS NO_REGS\n@@ -615,7 +623,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    first local allocated.  Otherwise, it is the offset to the BEGINNING\n    of the first local allocated.  */\n \n-#define STARTING_FRAME_OFFSET current_function_outgoing_args_size\n+#define STARTING_FRAME_OFFSET 0\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n@@ -643,10 +651,11 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    followed by \"to\".  Eliminations of the same \"from\" register are listed\n    in order of preference.  */\n \n-#define ELIMINABLE_REGS\t\t\t\t\\\n-{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n- { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},   \\\n- { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+#define ELIMINABLE_REGS\t\t\t\t     \\\n+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t     \\\n+ { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},   \\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t     \\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n \n /* Given FROM and TO register numbers, say whether this elimination is allowed.\n    Frame pointer elimination is automatically handled.\n@@ -656,20 +665,19 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n \n #define CAN_ELIMINATE(FROM, TO) 1\n \n+/* Round up to a multiple of 16 bytes.  */\n+#define ALPHA_ROUND(X) (((X) + 15) & ~ 15)\n+\n /* Define the offset between two registers, one to be eliminated, and the other\n    its replacement, at the start of a routine.  */\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n-{ if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n-    (OFFSET) = 0;\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      (OFFSET) = ((get_frame_size () + current_function_outgoing_args_size \\\n-\t\t   + current_function_pretend_args_size\t\t\t\\\n-\t\t   + alpha_sa_size () + 15)\t\t\t\t\\\n-\t\t  & ~ 15);\t\t\t\t\t\t\\\n-      if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\t\\\n-\t(OFFSET) -= current_function_pretend_args_size;\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+{ if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t\t\\\n+    (OFFSET) = (ALPHA_ROUND (current_function_outgoing_args_size)\t\\\n+\t\t+ alpha_sa_size ());\t\t\t\t\t\\\n+  else if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\\\n+    (OFFSET) = (ALPHA_ROUND (current_function_outgoing_args_size)\t\\\n+\t\t+ alpha_sa_size ()\t\t\t\t\t\\\n+\t\t+ ALPHA_ROUND (get_frame_size ()));\t\t\t\\\n }\n \n /* Define this if stack space is still allocated for a parameter passed\n@@ -1020,7 +1028,8 @@ __enable_execute_stack (addr)\t\t\t\t\t\t\\\n \n #define REGNO_OK_FOR_INDEX_P(REGNO) 0\n #define REGNO_OK_FOR_BASE_P(REGNO) \\\n-(((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32))\n+((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32  \\\n+ || (REGNO) == 63 || reg_renumber[REGNO] == 63)\n \f\n /* Maximum number of registers that can appear in a valid memory address.  */\n #define MAX_REGS_PER_ADDRESS 1\n@@ -1061,7 +1070,7 @@ __enable_execute_stack (addr)\t\t\t\t\t\t\\\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X)  \\\n-  (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+  (REGNO (X) < 32 || REGNO (X) == 63 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n \n #else\n \n@@ -1467,7 +1476,7 @@ literal_section ()\t\t\t\t\t\t\\\n  \"$f0\", \"$f1\", \"$f2\", \"$f3\", \"$f4\", \"$f5\", \"$f6\", \"$f7\", \"$f8\",\t\\\n  \"$f9\", \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\t\t\\\n  \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\\\n- \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\"}\n+ \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"FP\"}\n \n /* How to renumber registers for dbx and gdb.  */\n \n@@ -1629,6 +1638,7 @@ literal_section ()\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t      \\\n   }\t\t\t\t\t\t\t\t\t      \\\n   while (0)\n+\n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n \n@@ -1787,7 +1797,8 @@ literal_section ()\t\t\t\t\t\t\\\n #define MIPS_DEBUGGING_INFO\t\t/* MIPS specific debugging info */\n \n #ifndef PREFERRED_DEBUGGING_TYPE\t/* assume SDB_DEBUGGING_INFO */\n-#define PREFERRED_DEBUGGING_TYPE ((len > 1 && !strncmp (str, \"ggdb\", len)) ? DBX_DEBUG : SDB_DEBUG)\n+#define PREFERRED_DEBUGGING_TYPE  \\\n+ ((len > 1 && !strncmp (str, \"ggdb\", len)) ? DBX_DEBUG : SDB_DEBUG)\n #endif\n \n "}]}