{"sha": "fed2b1017993c0db4fb6788bd83870d289e84827", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVkMmIxMDE3OTkzYzBkYjRmYjY3ODhiZDgzODcwZDI4OWU4NDgyNw==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-12-17T22:12:34Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-12-17T22:12:34Z"}, "message": "init.c: Include objc/runtime.h and objc-private/module-abi-8.h instead of objc/objc-api.h.\n\n2010-12-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* init.c: Include objc/runtime.h and objc-private/module-abi-8.h\n\tinstead of objc/objc-api.h.\n\t(init_check_module_version): Take a 'struct objc_module *'\n\targument instead of 'Module_t'.  Use 'struct objc_module *'\n\tinstead of 'Module_t'.\n\t(__objc_created_classes_tree): Take a 'struct objc_module *'\n\targument instead of 'Module_t'; use 'struct objc_symtab *' instead\n\tof 'Symtab_t'.\n\t(__objc_call_callback): Take a 'struct objc_module *' argument\n\tinstead of 'Module_t'; use 'struct objc_symtab *' instead of\n\t'Symtab_t' and 'struct objc_category *' instead of 'Category_t'.\n\t(_objc_load_callback): Take a 'struct objc_category *' argument\n\tinstead of 'Category *'.\n\t(class_superclass_of_class): Use objc_getClass() instead of\n\tobjc_lookup_class().\n\t(create_tree_of_subclasses_inherited_from): Same change (also, use\n\tan explicit 'if' instead of '?').\n\t(objc_init_statics): Same change.\n\t(objc_send_load): Same change.\n\t(__objc_init_protocol): same change.\n\t(__objc_send_message_in_list): Take a 'struct objc_method_list *'\n\targument instead of 'MethodList_t'.  Use 'struct objc_method *'\n\tinstead of 'Method_t'.\n\t(__objc_send_load): Use 'struct objc_method_list *' instead of\n\t'MethodList_t'.  Use sel_registerName() instead of\n\tsel_register_name().\n\t(__objc_exec_class): Take a 'struct objc_module *' argument\n\tinstead of 'Module_t'.  Use 'struct objc_symtab *' instead of\n\t'Symtab_t'.  Use objc_getClass() instead of objc_lookup_class().\n\tUse 'struct objc_category *' instead of 'Category_t'.\n\nFrom-SVN: r168000", "tree": {"sha": "c8e53dd768c82abd845d6a952d17afe5922f9348", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8e53dd768c82abd845d6a952d17afe5922f9348"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fed2b1017993c0db4fb6788bd83870d289e84827", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fed2b1017993c0db4fb6788bd83870d289e84827", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fed2b1017993c0db4fb6788bd83870d289e84827", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fed2b1017993c0db4fb6788bd83870d289e84827/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "29ce73cb955296716da85268e4b8faf91e6c5fcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ce73cb955296716da85268e4b8faf91e6c5fcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ce73cb955296716da85268e4b8faf91e6c5fcf"}], "stats": {"total": 131, "additions": 85, "deletions": 46}, "files": [{"sha": "e3c7a6f95dbff9681f70a6f172e5783dd7538cb3", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed2b1017993c0db4fb6788bd83870d289e84827/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed2b1017993c0db4fb6788bd83870d289e84827/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=fed2b1017993c0db4fb6788bd83870d289e84827", "patch": "@@ -1,3 +1,36 @@\n+2010-12-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* init.c: Include objc/runtime.h and objc-private/module-abi-8.h\n+\tinstead of objc/objc-api.h.\n+\t(init_check_module_version): Take a 'struct objc_module *'\n+\targument instead of 'Module_t'.  Use 'struct objc_module *'\n+\tinstead of 'Module_t'.\n+\t(__objc_created_classes_tree): Take a 'struct objc_module *'\n+\targument instead of 'Module_t'; use 'struct objc_symtab *' instead\n+\tof 'Symtab_t'.\n+\t(__objc_call_callback): Take a 'struct objc_module *' argument\n+\tinstead of 'Module_t'; use 'struct objc_symtab *' instead of\n+\t'Symtab_t' and 'struct objc_category *' instead of 'Category_t'.\n+\t(_objc_load_callback): Take a 'struct objc_category *' argument\n+\tinstead of 'Category *'.\n+\t(class_superclass_of_class): Use objc_getClass() instead of\n+\tobjc_lookup_class().\n+\t(create_tree_of_subclasses_inherited_from): Same change (also, use\n+\tan explicit 'if' instead of '?').\n+\t(objc_init_statics): Same change.\n+\t(objc_send_load): Same change.\n+\t(__objc_init_protocol): same change.\n+\t(__objc_send_message_in_list): Take a 'struct objc_method_list *'\n+\targument instead of 'MethodList_t'.  Use 'struct objc_method *'\n+\tinstead of 'Method_t'.\n+\t(__objc_send_load): Use 'struct objc_method_list *' instead of\n+\t'MethodList_t'.  Use sel_registerName() instead of\n+\tsel_register_name().\n+\t(__objc_exec_class): Take a 'struct objc_module *' argument\n+\tinstead of 'Module_t'.  Use 'struct objc_symtab *' instead of\n+\t'Symtab_t'.  Use objc_getClass() instead of objc_lookup_class().\n+\tUse 'struct objc_category *' instead of 'Category_t'.\n+\t\n 2010-12-16  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* sendmsg.c: Include objc/runtime.h instead of objc/objc-api.h."}, {"sha": "641af7a4603fd5b904f7b307e53859179296c70e", "filename": "libobjc/init.c", "status": "modified", "additions": 52, "deletions": 46, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fed2b1017993c0db4fb6788bd83870d289e84827/libobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fed2b1017993c0db4fb6788bd83870d289e84827/libobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Finit.c?ref=fed2b1017993c0db4fb6788bd83870d289e84827", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime initialization \n-   Copyright (C) 1993, 1995, 1996, 1997, 2002, 2009\n+   Copyright (C) 1993, 1995, 1996, 1997, 2002, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup\n    +load support contributed by Ovidiu Predescu <ovidiu@net-community.com>\n@@ -26,10 +26,11 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include \"objc-private/common.h\"\n #include \"objc-private/error.h\"\n-#include \"objc/objc-api.h\"\n+#include \"objc/runtime.h\"\n #include \"objc/thr.h\"\n #include \"objc-private/hash.h\"\n #include \"objc-private/objc-list.h\" \n+#include \"objc-private/module-abi-8.h\" \n #include \"objc-private/runtime.h\"\n #include \"objc-private/objc-sync.h\" /* For __objc_sync_init() */\n #include \"objc-private/protocols.h\" /* For __objc_protocols_init(),\n@@ -68,7 +69,7 @@ objc_mutex_t __objc_runtime_mutex = 0;\n int __objc_runtime_threads_alive = 1;\t\t\t/* !T:MUTEX */\n \n /* Check compiler vs runtime version.  */\n-static void init_check_module_version (Module_t);\n+static void init_check_module_version (struct objc_module *);\n \n /* Assign isa links to protos.  */\n static void __objc_init_protocols (struct objc_protocol_list *protos);\n@@ -83,11 +84,13 @@ static void __objc_class_add_protocols (Class, struct objc_protocol_list *);\n    class or a category is loaded into the runtime.  This may e.g. help\n    a dynamic loader determine the classes that have been loaded when\n    an object file is dynamically linked in.  */\n-void (*_objc_load_callback) (Class class, Category *category); /* !T:SAFE */\n+/* TODO: This needs to be declared in a public file with the new API.  */\n+void (*_objc_load_callback) (Class class, struct objc_category *category); /* !T:SAFE */\n \n-/* Is all categories/classes resolved?  */\n+/* Are all categories/classes resolved?  */\n BOOL __objc_dangling_categories = NO;           /* !T:UNUSED */\n \n+/* TODO: This needs to go into objc-private/selector.h.  */\n extern SEL\n __sel_register_typed_name (const char *name, const char *types, \n \t\t\t   struct objc_selector *orig, BOOL is_const);\n@@ -101,9 +104,9 @@ static void objc_send_load (void);\n    methods were not executed before. The algorithm ensures that when\n    the +load method of a class is executed all the superclasses have\n    been already received the +load message.  */\n-static void __objc_create_classes_tree (Module_t module);\n+static void __objc_create_classes_tree (struct objc_module *module);\n \n-static void __objc_call_callback (Module_t module);\n+static void __objc_call_callback (struct objc_module *module);\n \n /* A special version that works only before the classes are completely\n    installed in the runtime.  */\n@@ -163,7 +166,7 @@ static Class  class_superclass_of_class (Class class)\n     return Nil;\n \n   /* Lookup the superclass of non-root classes.  */\n-  return objc_lookup_class (super_class_name);\n+  return objc_getClass (super_class_name);\n }\n \n \n@@ -176,12 +179,14 @@ static Class  class_superclass_of_class (Class class)\n static objc_class_tree *\n create_tree_of_subclasses_inherited_from (Class bottom_class, Class upper)\n {\n-  Class superclass = bottom_class->super_class ?\n-\t\t\tobjc_lookup_class ((char *) bottom_class->super_class)\n-\t\t      : Nil;\n-\t\t\t\t\t\n+  Class superclass;\n   objc_class_tree *tree, *prev;\n \n+  if (bottom_class->super_class)\n+    superclass = objc_getClass ((char *) bottom_class->super_class);\n+  else\n+    superclass = Nil;\n+\n   DEBUG_PRINTF (\"create_tree_of_subclasses_inherited_from:\");\n   DEBUG_PRINTF (\"bottom_class = %s, upper = %s\\n\",\n \t\t(bottom_class ? bottom_class->name : NULL),\n@@ -371,7 +376,7 @@ __objc_tree_print (objc_class_tree *tree, int level)\n    added to the class methods.  */\n \n static void\n-__objc_send_message_in_list (MethodList_t method_list, Class class, SEL op)\n+__objc_send_message_in_list (struct objc_method_list *method_list, Class class, SEL op)\n {\n   int i;\n \n@@ -384,7 +389,7 @@ __objc_send_message_in_list (MethodList_t method_list, Class class, SEL op)\n   /* Search the method list.  */\n   for (i = 0; i < method_list->method_count; i++)\n     {\n-      Method_t mth = &method_list->method_list[i];\n+      struct objc_method *mth = &method_list->method_list[i];\n \n       if (mth->method_name && sel_eq (mth->method_name, op)\n \t  && ! objc_hash_is_key_in_hash (__objc_load_methods, mth->method_imp))\n@@ -410,10 +415,10 @@ __objc_send_load (objc_class_tree *tree,\n {\n   static SEL load_sel = 0;\n   Class class = tree->class;\n-  MethodList_t method_list = class->class_pointer->methods;\n+  struct objc_method_list *method_list = class->class_pointer->methods;\n \n   if (! load_sel)\n-    load_sel = sel_register_name (\"load\");\n+    load_sel = sel_registerName (\"load\");\n \n   __objc_send_message_in_list (method_list, class, load_sel);\n }\n@@ -475,7 +480,7 @@ objc_init_statics (void)\n \t   *statics_in_module; statics_in_module++)\n \t{\n \t  struct objc_static_instances *statics = *statics_in_module;\n-\t  Class class = objc_lookup_class (statics->class_name);\n+\t  Class class = objc_getClass (statics->class_name);\n \n \t  if (! class)\n \t    {\n@@ -536,30 +541,31 @@ objc_init_statics (void)\n    module compiled.  (_GLOBAL_$I$...) The purpose of this function is\n    to gather the module pointers so that they may be processed by the\n    initialization routines as soon as possible.  */\n-\n void\n-__objc_exec_class (Module_t module)\n+__objc_exec_class (struct objc_module *module)\n {\n-  /* Have we processed any constructors previously?  This flag is used to\n-     indicate that some global data structures need to be built.  */\n+  /* Have we processed any constructors previously?  This flag is used\n+     to indicate that some global data structures need to be\n+     built.  */\n   static BOOL previous_constructors = 0;\n \n   static struct objc_list *unclaimed_categories = 0;\n \n-  /* The symbol table (defined in objc-api.h) generated by gcc */\n-  Symtab_t symtab = module->symtab;\n+  /* The symbol table (defined in objc-private/module-abi-8.h)\n+     generated by gcc.  */\n+  struct objc_symtab *symtab = module->symtab;\n \n-  /* The statics in this module */\n+  /* The statics in this module.  */\n   struct objc_static_instances **statics\n     = symtab->defs[symtab->cls_def_cnt + symtab->cat_def_cnt];\n \n-  /* Entry used to traverse hash lists */\n+  /* Entry used to traverse hash lists.  */\n   struct objc_list **cell;\n \n-  /* The table of selector references for this module */\n+  /* The table of selector references for this module.  */\n   SEL selectors = symtab->refs; \n \n-  /* dummy counter */\n+  /* dummy counter.  */\n   int i;\n \n   DEBUG_PRINTF (\"received module: %s\\n\", module->name);\n@@ -628,15 +634,15 @@ __objc_exec_class (Module_t module)\n \n       /* Check to see if the superclass is known in this point. If it's not\n \t add the class to the unresolved_classes list.  */\n-      if (superclass && ! objc_lookup_class (superclass))\n+      if (superclass && ! objc_getClass (superclass))\n \tunresolved_classes = list_cons (class, unresolved_classes);\n    }\n \n   /* Process category information from the module.  */\n   for (i = 0; i < symtab->cat_def_cnt; ++i)\n     {\n-      Category_t category = symtab->defs[i + symtab->cls_def_cnt];\n-      Class class = objc_lookup_class (category->class_name);\n+      struct objc_category *category = symtab->defs[i + symtab->cls_def_cnt];\n+      Class class = objc_getClass (category->class_name);\n       \n       /* If the class for the category exists then append its methods.  */\n       if (class)\n@@ -682,8 +688,8 @@ __objc_exec_class (Module_t module)\n      categories to objects.  */\n   for (cell = &unclaimed_categories; *cell; )\n     {\n-      Category_t category = (*cell)->head;\n-      Class class = objc_lookup_class (category->class_name);\n+      struct objc_category *category = (*cell)->head;\n+      Class class = objc_getClass (category->class_name);\n       \n       if (class)\n \t{\n@@ -713,7 +719,7 @@ __objc_exec_class (Module_t module)\n \tcell = &(*cell)->tail;\n     }\n   \n-  if (unclaimed_proto_list && objc_lookup_class (\"Protocol\"))\n+  if (unclaimed_proto_list && objc_getClass (\"Protocol\"))\n     {\n       list_mapcar (unclaimed_proto_list,\n \t\t   (void (*) (void *))__objc_init_protocols);\n@@ -740,7 +746,7 @@ objc_send_load (void)\n     {\n       Class class = unresolved_classes->head;\n \n-      while (objc_lookup_class ((char *) class->super_class))\n+      while (objc_getClass ((char *) class->super_class))\n \t{\n \t  list_remove_head (&unresolved_classes);\n \t  if (unresolved_classes)\n@@ -758,7 +764,7 @@ objc_send_load (void)\n \n   /* Special check.  If 'Object', which is used by meta-classes, has\n      not been loaded yet, delay sending of +load.  */\n-  if (! objc_lookup_class (\"Object\"))\n+  if (! objc_getClass (\"Object\"))\n     return;\n \n   /* Iterate over all modules in the __objc_module_list and call on\n@@ -786,11 +792,11 @@ objc_send_load (void)\n }\n \n static void\n-__objc_create_classes_tree (Module_t module)\n+__objc_create_classes_tree (struct objc_module *module)\n {\n   /* The runtime mutex is locked in this point */\n \n-  Symtab_t symtab = module->symtab;\n+  struct objc_symtab *symtab = module->symtab;\n   int i;\n \n   /* Iterate thru classes defined in this module and insert them in\n@@ -804,11 +810,11 @@ __objc_create_classes_tree (Module_t module)\n }\n \n static void\n-__objc_call_callback (Module_t module)\n+__objc_call_callback (struct objc_module *module)\n {\n   /* The runtime mutex is locked in this point.  */\n \n-  Symtab_t symtab = module->symtab;\n+  struct objc_symtab *symtab = module->symtab;\n   int i;\n \n   /* Iterate thru classes defined in this module and call the callback\n@@ -827,9 +833,9 @@ __objc_call_callback (Module_t module)\n      since they were already added in the class.  */\n   for (i = 0; i < symtab->cat_def_cnt; i++)\n     {\n-      Category_t category = symtab->defs[i + symtab->cls_def_cnt];\n-      Class class = objc_lookup_class (category->class_name);\n-      \n+      struct objc_category *category = symtab->defs[i + symtab->cls_def_cnt];\n+      Class class = objc_getClass (category->class_name);\n+\n       if (_objc_load_callback)\n \t_objc_load_callback (class, category);\n     }\n@@ -838,9 +844,9 @@ __objc_call_callback (Module_t module)\n /* Sanity check the version of gcc used to compile `module'.  */\n \n static void\n-init_check_module_version (Module_t module)\n+init_check_module_version (struct objc_module *module)\n {\n-  if ((module->version != OBJC_VERSION) || (module->size != sizeof (Module)))\n+  if ((module->version != OBJC_VERSION) || (module->size != sizeof (struct objc_module)))\n     {\n       _objc_abort (\"Module %s version %d doesn't match runtime %d\\n\",\n \t\t   module->name, (int)module->version, OBJC_VERSION);\n@@ -878,7 +884,7 @@ __objc_init_protocol (struct objc_protocol *protocol)\n   static Class proto_class = 0;\n \n   if (! proto_class)\n-    proto_class = objc_get_class (\"Protocol\");\n+    proto_class = objc_getClass (\"Protocol\");\n \n   if (((size_t)protocol->class_pointer) == PROTOCOL_VERSION)\n     {\n@@ -925,7 +931,7 @@ __objc_init_protocols (struct objc_protocol_list *protos)\n   objc_mutex_lock (__objc_runtime_mutex);\n \n   if (! proto_class)\n-    proto_class = objc_lookup_class (\"Protocol\");\n+    proto_class = objc_getClass (\"Protocol\");\n \n   if (! proto_class)\n     {"}]}