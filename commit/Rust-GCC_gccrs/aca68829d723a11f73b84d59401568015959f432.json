{"sha": "aca68829d723a11f73b84d59401568015959f432", "node_id": "C_kwDOANBUbNoAKGFjYTY4ODI5ZDcyM2ExMWY3M2I4NGQ1OTQwMTU2ODAxNTk1OWY0MzI", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-11-30T03:22:27Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-11-30T03:22:27Z"}, "message": "rs6000: Modify the way for extra penalized cost\n\nThis patch follows the discussions here[1][2], where Segher\npointed out the existing way to guard the extra penalized\ncost for strided/elementwise loads with a magic bound does\nnot scale.\n\nThe way with nunits * stmt_cost can get one much\nexaggerated penalized cost, such as: for V16QI on P8, it's\n16 * 20 = 320, that's why we need one bound.  To make it\nbetter and more readable, the penalized cost is simplified\nas:\n\n    unsigned adjusted_cost = (nunits == 2) ? 2 : 1;\n    unsigned extra_cost = nunits * adjusted_cost;\n\nFor V2DI/V2DF, it uses 2 penalized cost for each scalar load\nwhile for the other modes, it uses 1.  It's mainly concluded\nfrom the performance evaluations.  One thing might be\nrelated is that: More units vector gets constructed, more\ninstructions are used.  It has more chances to schedule them\nbetter (even run in parallelly when enough available units\nat that time), so it seems reasonable not to penalize more\nfor them.\n\nThe SPEC2017 evaluations on Power8/Power9/Power10 at option\nsets O2-vect and Ofast-unroll show this change is neutral.\n\n[1] https://gcc.gnu.org/pipermail/gcc-patches/2021-September/579121.html\n[2] https://gcc.gnu.org/pipermail/gcc-patches/2021-September/580099.html\n\ngcc/ChangeLog:\n\n\t* config/rs6000/rs6000.c\n\t(rs6000_cost_data::update_target_cost_per_stmt): Adjust the way to\n\tcompute extra penalized cost.  Remove useless parameter.\n\t(rs6000_cost_data::rs6000_add_stmt_cost): Adjust the call to function\n\tupdate_target_cost_per_stmt.", "tree": {"sha": "a230fea6c4c6db4a6a779398a6cdbb31ee925b66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a230fea6c4c6db4a6a779398a6cdbb31ee925b66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aca68829d723a11f73b84d59401568015959f432", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca68829d723a11f73b84d59401568015959f432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aca68829d723a11f73b84d59401568015959f432", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca68829d723a11f73b84d59401568015959f432/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcb163eee8c290a1c023f89b401ba7406dcac605", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcb163eee8c290a1c023f89b401ba7406dcac605", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcb163eee8c290a1c023f89b401ba7406dcac605"}], "stats": {"total": 35, "additions": 19, "deletions": 16}, "files": [{"sha": "289c1b3df24c992e86e27180213cc766303c27e6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca68829d723a11f73b84d59401568015959f432/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca68829d723a11f73b84d59401568015959f432/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=aca68829d723a11f73b84d59401568015959f432", "patch": "@@ -5272,8 +5272,7 @@ class rs6000_cost_data : public vector_costs\n \n protected:\n   void update_target_cost_per_stmt (vect_cost_for_stmt, stmt_vec_info,\n-\t\t\t\t    vect_cost_model_location, int,\n-\t\t\t\t    unsigned int);\n+\t\t\t\t    vect_cost_model_location, unsigned int);\n   void density_test (loop_vec_info);\n   void adjust_vect_cost_per_loop (loop_vec_info);\n \n@@ -5414,7 +5413,6 @@ void\n rs6000_cost_data::update_target_cost_per_stmt (vect_cost_for_stmt kind,\n \t\t\t\t\t       stmt_vec_info stmt_info,\n \t\t\t\t\t       vect_cost_model_location where,\n-\t\t\t\t\t       int stmt_cost,\n \t\t\t\t\t       unsigned int orig_count)\n {\n \n@@ -5456,17 +5454,23 @@ rs6000_cost_data::update_target_cost_per_stmt (vect_cost_for_stmt kind,\n \t{\n \t  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n \t  unsigned int nunits = vect_nunits_for_cost (vectype);\n-\t  unsigned int extra_cost = nunits * stmt_cost;\n-\t  /* As function rs6000_builtin_vectorization_cost shows, we have\n-\t     priced much on V16QI/V8HI vector construction as their units,\n-\t     if we penalize them with nunits * stmt_cost, it can result in\n-\t     an unreliable body cost, eg: for V16QI on Power8, stmt_cost\n-\t     is 20 and nunits is 16, the extra cost is 320 which looks\n-\t     much exaggerated.  So let's use one maximum bound for the\n-\t     extra penalized cost for vector construction here.  */\n-\t  const unsigned int MAX_PENALIZED_COST_FOR_CTOR = 12;\n-\t  if (extra_cost > MAX_PENALIZED_COST_FOR_CTOR)\n-\t    extra_cost = MAX_PENALIZED_COST_FOR_CTOR;\n+\t  /* We don't expect strided/elementwise loads for just 1 nunit.  */\n+\t  gcc_assert (nunits > 1);\n+\t  /* i386 port adopts nunits * stmt_cost as the penalized cost\n+\t     for this kind of penalization, we used to follow it but\n+\t     found it could result in an unreliable body cost especially\n+\t     for V16QI/V8HI modes.  To make it better, we choose this\n+\t     new heuristic: for each scalar load, we use 2 as penalized\n+\t     cost for the case with 2 nunits and use 1 for the other\n+\t     cases.  It's without much supporting theory, mainly\n+\t     concluded from the broad performance evaluations on Power8,\n+\t     Power9 and Power10.  One possibly related point is that:\n+\t     vector construction for more units would use more insns,\n+\t     it has more chances to schedule them better (even run in\n+\t     parallelly when enough available units at that time), so\n+\t     it seems reasonable not to penalize that much for them.  */\n+\t  unsigned int adjusted_cost = (nunits == 2) ? 2 : 1;\n+\t  unsigned int extra_cost = nunits * adjusted_cost;\n \t  m_extra_ctor_cost += extra_cost;\n \t}\n     }\n@@ -5491,8 +5495,7 @@ rs6000_cost_data::add_stmt_cost (int count, vect_cost_for_stmt kind,\n       retval = adjust_cost_for_freq (stmt_info, where, count * stmt_cost);\n       m_costs[where] += retval;\n \n-      update_target_cost_per_stmt (kind, stmt_info, where,\n-\t\t\t\t   stmt_cost, orig_count);\n+      update_target_cost_per_stmt (kind, stmt_info, where, orig_count);\n     }\n \n   return retval;"}]}