{"sha": "698114484e668abf28c70d989bc93fa399dda9ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk4MTE0NDg0ZTY2OGFiZjI4YzcwZDk4OWJjOTNmYTM5OWRkYTlhYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-07T08:36:06Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-07T08:36:06Z"}, "message": "[i386] Make the vzeroupper pattern describe its effects (PR91994)\n\nThe problem in this PR was that vzeroupper has an effect on register\ncontents, but those effects weren't modelled in the rtl pattern,\nwhich was just an unspec_volatile.\n\nThis patch fixes that by running a subpass after vzeroupper insertion\nto add SETs and CLOBBERs as appropriate.  See the comments in the patch\nfor more details.\n\n2019-10-07  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR target/91994\n\t* config/i386/sse.md (avx_vzeroupper): Turn into a define_expand\n\tand wrap the unspec_volatile in a parallel.\n\t(*avx_vzeroupper): New define_insn.  Use a match_parallel around\n\tthe unspec_volatile.\n\t* config/i386/predicates.md (vzeroupper_pattern): Expect the\n\tunspec_volatile to be wrapped in a parallel.\n\t* config/i386/i386-features.c (ix86_add_reg_usage_to_vzeroupper)\n\t(ix86_add_reg_usage_to_vzerouppers): New functions.\n\t(rest_of_handle_insert_vzeroupper): Use them to add register\n\tusage information to the vzeroupper instructions.\n\ngcc/testsuite/\n\tPR target/91994\n\t* gcc.target/i386/pr91994.c: New test.\n\nFrom-SVN: r276648", "tree": {"sha": "fd1f0dfc8c900a11da102a8bbfba388877795b9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd1f0dfc8c900a11da102a8bbfba388877795b9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/698114484e668abf28c70d989bc93fa399dda9ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/698114484e668abf28c70d989bc93fa399dda9ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/698114484e668abf28c70d989bc93fa399dda9ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/698114484e668abf28c70d989bc93fa399dda9ac/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "806bdf4e40d31cf55744c876eb9f17654de36b99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/806bdf4e40d31cf55744c876eb9f17654de36b99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/806bdf4e40d31cf55744c876eb9f17654de36b99"}], "stats": {"total": 135, "additions": 130, "deletions": 5}, "files": [{"sha": "ef8731fb3a0d58b3351cbd08ba87651ad00141e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698114484e668abf28c70d989bc93fa399dda9ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698114484e668abf28c70d989bc93fa399dda9ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=698114484e668abf28c70d989bc93fa399dda9ac", "patch": "@@ -1,3 +1,17 @@\n+2019-10-07  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR target/91994\n+\t* config/i386/sse.md (avx_vzeroupper): Turn into a define_expand\n+\tand wrap the unspec_volatile in a parallel.\n+\t(*avx_vzeroupper): New define_insn.  Use a match_parallel around\n+\tthe unspec_volatile.\n+\t* config/i386/predicates.md (vzeroupper_pattern): Expect the\n+\tunspec_volatile to be wrapped in a parallel.\n+\t* config/i386/i386-features.c (ix86_add_reg_usage_to_vzeroupper)\n+\t(ix86_add_reg_usage_to_vzerouppers): New functions.\n+\t(rest_of_handle_insert_vzeroupper): Use them to add register\n+\tusage information to the vzeroupper instructions.\n+\n 2019-10-07  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91975"}, {"sha": "4781a33a545b3824a4f6ed7ce6543473cda0780e", "filename": "gcc/config/i386/i386-features.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698114484e668abf28c70d989bc93fa399dda9ac/gcc%2Fconfig%2Fi386%2Fi386-features.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698114484e668abf28c70d989bc93fa399dda9ac/gcc%2Fconfig%2Fi386%2Fi386-features.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.c?ref=698114484e668abf28c70d989bc93fa399dda9ac", "patch": "@@ -1757,6 +1757,68 @@ convert_scalars_to_vector (bool timode_p)\n   return 0;\n }\n \n+/* Modify the vzeroupper pattern in INSN so that it describes the effect\n+   that the instruction has on the SSE registers.  LIVE_REGS are the set\n+   of registers that are live across the instruction.\n+\n+   For a live register R we use:\n+\n+     (set (reg:V2DF R) (reg:V2DF R))\n+\n+   which preserves the low 128 bits but clobbers the upper bits.\n+   For a dead register we just use:\n+\n+     (clobber (reg:V2DF R))\n+\n+   which invalidates any previous contents of R and stops R from becoming\n+   live across the vzeroupper in future.  */\n+\n+static void\n+ix86_add_reg_usage_to_vzeroupper (rtx_insn *insn, bitmap live_regs)\n+{\n+  rtx pattern = PATTERN (insn);\n+  unsigned int nregs = TARGET_64BIT ? 16 : 8;\n+  rtvec vec = rtvec_alloc (nregs + 1);\n+  RTVEC_ELT (vec, 0) = XVECEXP (pattern, 0, 0);\n+  for (unsigned int i = 0; i < nregs; ++i)\n+    {\n+      unsigned int regno = GET_SSE_REGNO (i);\n+      rtx reg = gen_rtx_REG (V2DImode, regno);\n+      if (bitmap_bit_p (live_regs, regno))\n+\tRTVEC_ELT (vec, i + 1) = gen_rtx_SET (reg, reg);\n+      else\n+\tRTVEC_ELT (vec, i + 1) = gen_rtx_CLOBBER (VOIDmode, reg);\n+    }\n+  XVEC (pattern, 0) = vec;\n+  df_insn_rescan (insn);\n+}\n+\n+/* Walk the vzeroupper instructions in the function and annotate them\n+   with the effect that they have on the SSE registers.  */\n+\n+static void\n+ix86_add_reg_usage_to_vzerouppers (void)\n+{\n+  basic_block bb;\n+  rtx_insn *insn;\n+  auto_bitmap live_regs;\n+\n+  df_analyze ();\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      bitmap_copy (live_regs, df_get_live_out (bb));\n+      df_simulate_initialize_backwards (bb, live_regs);\n+      FOR_BB_INSNS_REVERSE (bb, insn)\n+\t{\n+\t  if (!NONDEBUG_INSN_P (insn))\n+\t    continue;\n+\t  if (vzeroupper_pattern (PATTERN (insn), VOIDmode))\n+\t    ix86_add_reg_usage_to_vzeroupper (insn, live_regs);\n+\t  df_simulate_one_insn_backwards (bb, insn, live_regs);\n+\t}\n+    }\n+}\n+\n static unsigned int\n rest_of_handle_insert_vzeroupper (void)\n {\n@@ -1773,6 +1835,7 @@ rest_of_handle_insert_vzeroupper (void)\n \n   /* Call optimize_mode_switching.  */\n   g->get_passes ()->execute_pass_mode_switching ();\n+  ix86_add_reg_usage_to_vzerouppers ();\n   return 0;\n }\n "}, {"sha": "31f1ceabc3a7af305cc7a47d02e889999c71d2c8", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698114484e668abf28c70d989bc93fa399dda9ac/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698114484e668abf28c70d989bc93fa399dda9ac/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=698114484e668abf28c70d989bc93fa399dda9ac", "patch": "@@ -1441,8 +1441,9 @@\n \n ;; return true if OP is a vzeroupper pattern.\n (define_predicate \"vzeroupper_pattern\"\n-  (and (match_code \"unspec_volatile\")\n-       (match_test \"XINT (op, 1) == UNSPECV_VZEROUPPER\")))\n+  (and (match_code \"parallel\")\n+       (match_code \"unspec_volatile\" \"a\")\n+       (match_test \"XINT (XVECEXP (op, 0, 0), 1) == UNSPECV_VZEROUPPER\")))\n \n ;; Return true if OP is an addsub vec_merge operation\n (define_predicate \"addsub_vm_operator\""}, {"sha": "07922a1bf971fc64751259fa4af2f7ad72692f86", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698114484e668abf28c70d989bc93fa399dda9ac/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698114484e668abf28c70d989bc93fa399dda9ac/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=698114484e668abf28c70d989bc93fa399dda9ac", "patch": "@@ -19622,9 +19622,16 @@\n    (set_attr \"mode\" \"OI\")])\n \n ;; Clear the upper 128bits of AVX registers, equivalent to a NOP\n-;; if the upper 128bits are unused.\n-(define_insn \"avx_vzeroupper\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_VZEROUPPER)]\n+;; if the upper 128bits are unused.  Initially we expand the instructions\n+;; as though they had no effect on the SSE registers, but later add SETs and\n+;; CLOBBERs to the PARALLEL to model the real effect.\n+(define_expand \"avx_vzeroupper\"\n+  [(parallel [(unspec_volatile [(const_int 0)] UNSPECV_VZEROUPPER)])]\n+  \"TARGET_AVX\")\n+\n+(define_insn \"*avx_vzeroupper\"\n+  [(match_parallel 0 \"vzeroupper_pattern\"\n+     [(unspec_volatile [(const_int 0)] UNSPECV_VZEROUPPER)])]\n   \"TARGET_AVX\"\n   \"vzeroupper\"\n   [(set_attr \"type\" \"sse\")"}, {"sha": "01253be441d21323038c2f6e4d90daa59e498716", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698114484e668abf28c70d989bc93fa399dda9ac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698114484e668abf28c70d989bc93fa399dda9ac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=698114484e668abf28c70d989bc93fa399dda9ac", "patch": "@@ -1,3 +1,8 @@\n+2019-10-07  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR target/91994\n+\t* gcc.target/i386/pr91994.c: New test.\n+\n 2019-10-07  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91975"}, {"sha": "033be68e7d0381356be5f84544367b3baf466e2c", "filename": "gcc/testsuite/gcc.target/i386/pr91994.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698114484e668abf28c70d989bc93fa399dda9ac/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91994.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698114484e668abf28c70d989bc93fa399dda9ac/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91994.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91994.c?ref=698114484e668abf28c70d989bc93fa399dda9ac", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx } */\n+/* { dg-options \"-O2 -mavx -mvzeroupper\" } */\n+\n+#include \"avx-check.h\"\n+\n+#include <immintrin.h>\n+\n+__m256i x1, x2, x3;\n+\n+__attribute__ ((noinline))\n+static void\n+foo (void)\n+{\n+  x1 = x2;\n+}\n+\n+void\n+bar (void)\n+{\n+  __m256i x = x1;\n+  foo ();\n+  x3 = x;\n+}\n+\n+__attribute__ ((noinline))\n+void\n+avx_test (void)\n+{\n+  __m256i x = _mm256_set1_epi8 (3);\n+  x1 = x;\n+  bar ();\n+  if (__builtin_memcmp (&x3, &x, sizeof (x)))\n+    __builtin_abort ();\n+}"}]}