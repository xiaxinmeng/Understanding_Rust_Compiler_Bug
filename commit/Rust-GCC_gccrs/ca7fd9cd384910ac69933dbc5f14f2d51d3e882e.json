{"sha": "ca7fd9cd384910ac69933dbc5f14f2d51d3e882e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E3ZmQ5Y2QzODQ5MTBhYzY5OTMzZGJjNWYxNGYyZDUxZDNlODgyZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-26T15:01:11Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-26T15:01:11Z"}, "message": "alias.c: Fix formatting.\n\n\t* alias.c: Fix formatting.\n\t* attribs.c: Likewise.\n\t* bb-reorder.c: Likewise.\n\t* bitmap.c: Likewise.\n\t* bitmap.h: Likewise.\n\t* builtins.c: Likewise.\n\nFrom-SVN: r53898", "tree": {"sha": "29efe3b87d6765a6332a2a1b7d4548c91d80fe0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29efe3b87d6765a6332a2a1b7d4548c91d80fe0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/comments", "author": null, "committer": null, "parents": [{"sha": "7aacf9892018dafdc9da54ae14c0c357626f76ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aacf9892018dafdc9da54ae14c0c357626f76ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aacf9892018dafdc9da54ae14c0c357626f76ac"}], "stats": {"total": 317, "additions": 163, "deletions": 154}, "files": [{"sha": "085dc40f98a140615046c7ed4a7b5b885ce80794", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca7fd9cd384910ac69933dbc5f14f2d51d3e882e", "patch": "@@ -1,3 +1,12 @@\n+2002-05-26  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* alias.c: Fix formatting.\n+\t* attribs.c: Likewise.\n+\t* bb-reorder.c: Likewise.\n+\t* bitmap.c: Likewise.\n+\t* bitmap.h: Likewise.\n+\t* builtins.c: Likewise.\n+\n Sun May 26 14:00:44 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* reload.c (find_valid_class): Accept new argument DEST,"}, {"sha": "140e58aaffc5cd652545eb547adfff11642f9df1", "filename": "gcc/alias.c", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ca7fd9cd384910ac69933dbc5f14f2d51d3e882e", "patch": "@@ -75,7 +75,7 @@ typedef struct alias_set_entry\n   /* The children of the alias set.  These are not just the immediate\n      children, but, in fact, all descendents.  So, if we have:\n \n-       struct T { struct S s; float f; } \n+       struct T { struct S s; float f; }\n \n      continuing our example above, the children here will be all of\n      `int', `double', `float', and `struct S'.  */\n@@ -131,7 +131,7 @@ static int nonlocal_set_p               PARAMS ((rtx));\n /* Cap the number of passes we make over the insns propagating alias\n    information through set chains.   10 is a completely arbitrary choice.  */\n #define MAX_ALIAS_LOOP_PASSES 10\n-   \n+\n /* reg_base_value[N] gives an address to which register N is related.\n    If all sets after the first add or subtract to the current value\n    or otherwise modify it so it does not point to a different top level\n@@ -140,7 +140,7 @@ static int nonlocal_set_p               PARAMS ((rtx));\n \n    A base address can be an ADDRESS, SYMBOL_REF, or LABEL_REF.  ADDRESS\n    expressions represent certain special values: function arguments and\n-   the stack, frame, and argument pointers.  \n+   the stack, frame, and argument pointers.\n \n    The contents of an ADDRESS is not normally used, the mode of the\n    ADDRESS determines whether the ADDRESS is a function argument or some\n@@ -215,12 +215,12 @@ get_alias_set_entry (alias_set)\n /* Returns nonzero if the alias sets for MEM1 and MEM2 are such that\n    the two MEMs cannot alias each other.  */\n \n-static int \n+static int\n mems_in_disjoint_alias_sets_p (mem1, mem2)\n      rtx mem1;\n      rtx mem2;\n {\n-#ifdef ENABLE_CHECKING\t\n+#ifdef ENABLE_CHECKING\n /* Perform a basic sanity check.  Namely, that there are no alias sets\n    if we're not using strict aliasing.  This helps to catch bugs\n    whereby someone uses PUT_CODE, but doesn't clear MEM_ALIAS_SET, or\n@@ -514,8 +514,8 @@ get_alias_set (t)\n \t\t  else\n \t\t    {\n \t\t      DECL_POINTER_ALIAS_SET (decl) = new_alias_set ();\n-\t\t      record_alias_subset  (pointed_to_alias_set,\n-\t\t\t\t\t    DECL_POINTER_ALIAS_SET (decl));\n+\t\t      record_alias_subset (pointed_to_alias_set,\n+\t\t\t\t\t   DECL_POINTER_ALIAS_SET (decl));\n \t\t    }\n \t\t}\n \n@@ -601,7 +601,7 @@ new_alias_set ()\n    not vice versa.  For example, in C, a store to an `int' can alias a\n    structure containing an `int', but not vice versa.  Here, the\n    structure would be the SUPERSET and `int' the SUBSET.  This\n-   function should be called only once per SUPERSET/SUBSET pair. \n+   function should be called only once per SUPERSET/SUBSET pair.\n \n    It is illegal for SUPERSET to be zero; everything is implicitly a\n    subset of alias set zero.  */\n@@ -623,14 +623,14 @@ record_alias_subset (superset, subset)\n     abort ();\n \n   superset_entry = get_alias_set_entry (superset);\n-  if (superset_entry == 0) \n+  if (superset_entry == 0)\n     {\n       /* Create an entry for the SUPERSET, so that we have a place to\n \t attach the SUBSET.  */\n       superset_entry\n \t= (alias_set_entry) xmalloc (sizeof (struct alias_set_entry));\n       superset_entry->alias_set = superset;\n-      superset_entry->children \n+      superset_entry->children\n \t= splay_tree_new (splay_tree_compare_ints, 0, 0);\n       superset_entry->has_zero_child = 0;\n       splay_tree_insert (alias_sets, (splay_tree_key) superset,\n@@ -644,7 +644,7 @@ record_alias_subset (superset, subset)\n       subset_entry = get_alias_set_entry (subset);\n       /* If there is an entry for the subset, enter all of its children\n \t (if they are not already present) as children of the SUPERSET.  */\n-      if (subset_entry) \n+      if (subset_entry)\n \t{\n \t  if (subset_entry->has_zero_child)\n \t    superset_entry->has_zero_child = 1;\n@@ -654,7 +654,7 @@ record_alias_subset (superset, subset)\n \t}\n \n       /* Enter the SUBSET itself as a child of the SUPERSET.  */\n-      splay_tree_insert (superset_entry->children, \n+      splay_tree_insert (superset_entry->children,\n \t\t\t (splay_tree_key) subset, 0);\n     }\n }\n@@ -687,15 +687,15 @@ record_component_aliases (type)\n     case QUAL_UNION_TYPE:\n       /* Recursively record aliases for the base classes, if there are any */\n       if (TYPE_BINFO (type) != NULL && TYPE_BINFO_BASETYPES (type) != NULL)\n-        {\n-          int i;\n-          for (i = 0; i < TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (type)); i++)\n-            {\n-              tree binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), i);\n-              record_alias_subset (superset,\n+\t{\n+\t  int i;\n+\t  for (i = 0; i < TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (type)); i++)\n+\t    {\n+\t      tree binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), i);\n+\t      record_alias_subset (superset,\n \t\t\t\t   get_alias_set (BINFO_TYPE (binfo)));\n-            }\n-        }\n+\t    }\n+\t}\n       for (field = TYPE_FIELDS (type); field != 0; field = TREE_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL && ! DECL_NONADDRESSABLE_P (field))\n \t  record_alias_subset (superset, get_alias_set (TREE_TYPE (field)));\n@@ -1120,7 +1120,7 @@ rtx_equal_for_memref_p (x, y)\n \n     case LABEL_REF:\n       return XEXP (x, 0) == XEXP (y, 0);\n-      \n+\n     case SYMBOL_REF:\n       return XSTR (x, 0) == XSTR (y, 0);\n \n@@ -1257,7 +1257,7 @@ find_base_term (x)\n \n     case TRUNCATE:\n       if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (Pmode))\n-        return 0;\n+\treturn 0;\n       /* Fall through.  */\n     case HIGH:\n     case PRE_INC:\n@@ -1311,7 +1311,7 @@ find_base_term (x)\n \t   tests can certainly be added.  For example, if one of the operands\n \t   is a shift or multiply, then it must be the index register and the\n \t   other operand is the base register.  */\n-\t\n+\n \tif (tmp1 == pic_offset_table_rtx && CONSTANT_P (tmp2))\n \t  return find_base_term (tmp2);\n \n@@ -1409,7 +1409,7 @@ base_alias_check (x, y, x_mode, y_mode)\n   if (rtx_equal_p (x_base, y_base))\n     return 1;\n \n-  /* The base addresses of the read and write are different expressions. \n+  /* The base addresses of the read and write are different expressions.\n      If they are both symbols and they are not accessed via AND, there is\n      no conflict.  We can bring knowledge of object alignment into play\n      here.  For example, on alpha, \"char a, b;\" can alias one another,\n@@ -1484,7 +1484,7 @@ addr_side_effect_eval (addr, size, n_refs)\n      int n_refs;\n {\n   int offset = 0;\n-  \n+\n   switch (GET_CODE (addr))\n     {\n     case PRE_INC:\n@@ -1503,7 +1503,7 @@ addr_side_effect_eval (addr, size, n_refs)\n     default:\n       return addr;\n     }\n-  \n+\n   if (offset)\n     addr = gen_rtx_PLUS (GET_MODE (addr), XEXP (addr, 0), GEN_INT (offset));\n   else\n@@ -1666,7 +1666,7 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n       }\n \n   /* Treat an access through an AND (e.g. a subword access on an Alpha)\n-     as an access with indeterminate size.  Assume that references \n+     as an access with indeterminate size.  Assume that references\n      besides AND are aligned, so if the size of the other reference is\n      at least as large as the alignment, assume no other overlap.  */\n   if (GET_CODE (x) == AND && GET_CODE (XEXP (x, 1)) == CONST_INT)\n@@ -1678,7 +1678,7 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n   if (GET_CODE (y) == AND && GET_CODE (XEXP (y, 1)) == CONST_INT)\n     {\n       /* ??? If we are indexing far enough into the array/structure, we\n-\t may yet be able to determine that we can not overlap.  But we \n+\t may yet be able to determine that we can not overlap.  But we\n \t also need to that we are far enough from the end not to overlap\n \t a following reference, so we do nothing with that for now.  */\n       if (GET_CODE (x) == AND || xsize < -INTVAL (XEXP (y, 1)))\n@@ -1740,7 +1740,7 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n    If both memory references are volatile, then there must always be a\n    dependence between the two references, since their order can not be\n    changed.  A volatile and non-volatile reference can be interchanged\n-   though. \n+   though.\n \n    A MEM_IN_STRUCT reference at a non-AND varying address can never\n    conflict with a non-MEM_IN_STRUCT reference at a fixed address.  We\n@@ -1767,23 +1767,23 @@ read_dependence (mem, x)\n    to decide whether or not an address may vary; it should return\n    nonzero whenever variation is possible.\n    MEM1_ADDR and MEM2_ADDR are the addresses of MEM1 and MEM2.  */\n-  \n+\n static rtx\n fixed_scalar_and_varying_struct_p (mem1, mem2, mem1_addr, mem2_addr, varies_p)\n      rtx mem1, mem2;\n      rtx mem1_addr, mem2_addr;\n      int (*varies_p) PARAMS ((rtx, int));\n-{  \n+{\n   if (! flag_strict_aliasing)\n     return NULL_RTX;\n \n-  if (MEM_SCALAR_P (mem1) && MEM_IN_STRUCT_P (mem2) \n+  if (MEM_SCALAR_P (mem1) && MEM_IN_STRUCT_P (mem2)\n       && !varies_p (mem1_addr, 1) && varies_p (mem2_addr, 1))\n     /* MEM1 is a scalar at a fixed address; MEM2 is a struct at a\n        varying address.  */\n     return mem1;\n \n-  if (MEM_IN_STRUCT_P (mem1) && MEM_SCALAR_P (mem2) \n+  if (MEM_IN_STRUCT_P (mem1) && MEM_SCALAR_P (mem2)\n       && varies_p (mem1_addr, 1) && !varies_p (mem2_addr, 1))\n     /* MEM2 is a scalar at a fixed address; MEM1 is a struct at a\n        varying address.  */\n@@ -1803,7 +1803,7 @@ aliases_everything_p (mem)\n     /* If the address is an AND, its very hard to know at what it is\n        actually pointing.  */\n     return 1;\n-    \n+\n   return 0;\n }\n \n@@ -1861,7 +1861,7 @@ nonoverlapping_component_refs_p (x, y)\n   while (x && y\n \t && TREE_CODE (x) == COMPONENT_REF\n \t && TREE_CODE (y) == COMPONENT_REF);\n-  \n+\n   return false;\n }\n \n@@ -1894,7 +1894,7 @@ adjust_offset_for_component_ref (x, offset)\n     return NULL_RTX;\n \n   ioffset = INTVAL (offset);\n-  do \n+  do\n     {\n       tree field = TREE_OPERAND (x, 1);\n \n@@ -1980,15 +1980,15 @@ nonoverlapping_memrefs_p (x, y)\n     offsety = INTVAL (XEXP (basey, 1)), basey = XEXP (basey, 0);\n \n   /* If the bases are different, we know they do not overlap if both\n-     are constants or if one is a constant and the other a pointer into the \n+     are constants or if one is a constant and the other a pointer into the\n      stack frame.  Otherwise a different base means we can't tell if they\n      overlap or not.  */\n   if (! rtx_equal_p (basex, basey))\n-      return ((CONSTANT_P (basex) && CONSTANT_P (basey))\n-\t      || (CONSTANT_P (basex) && REG_P (basey)\n-\t\t  && REGNO_PTR_FRAME_P (REGNO (basey)))\n-\t      || (CONSTANT_P (basey) && REG_P (basex)\n-\t\t  && REGNO_PTR_FRAME_P (REGNO (basex))));\n+    return ((CONSTANT_P (basex) && CONSTANT_P (basey))\n+\t    || (CONSTANT_P (basex) && REG_P (basey)\n+\t\t&& REGNO_PTR_FRAME_P (REGNO (basey)))\n+\t    || (CONSTANT_P (basey) && REG_P (basex)\n+\t\t&& REGNO_PTR_FRAME_P (REGNO (basex))));\n \n   sizex = (GET_CODE (rtlx) != MEM ? (int) GET_MODE_SIZE (GET_MODE (rtlx))\n \t   : MEM_SIZE (rtlx) ? INTVAL (MEM_SIZE (rtlx))\n@@ -2105,9 +2105,9 @@ true_dependence (mem, mem_mode, x, varies)\n }\n \n /* Canonical true dependence: X is read after store in MEM takes place.\n-   Variant of true_dependence which assumes MEM has already been \n-   canonicalized (hence we no longer do that here).  \n-   The mem_addr argument has been added, since true_dependence computed \n+   Variant of true_dependence which assumes MEM has already been\n+   canonicalized (hence we no longer do that here).\n+   The mem_addr argument has been added, since true_dependence computed\n    this value prior to canonicalizing.  */\n \n int\n@@ -2233,7 +2233,7 @@ write_dependence_p (mem, x, writep)\n \t\t\t   SIZE_FOR_MODE (x), x_addr, 0))\n     return 0;\n \n-  fixed_scalar \n+  fixed_scalar\n     = fixed_scalar_and_varying_struct_p (mem, x, mem_addr, x_addr,\n \t\t\t\t\t rtx_addr_varies_p);\n \n@@ -2378,9 +2378,9 @@ nonlocal_mentioned_p (x)\n \t  x = CALL_INSN_FUNCTION_USAGE (x);\n \t  if (x == 0)\n \t    return 0;\n-        }\n+\t}\n       else\n-        x = PATTERN (x);\n+\tx = PATTERN (x);\n     }\n \n   return for_each_rtx (&x, nonlocal_mentioned_p_1, NULL);\n@@ -2476,9 +2476,9 @@ nonlocal_referenced_p (x)\n \t  x = CALL_INSN_FUNCTION_USAGE (x);\n \t  if (x == 0)\n \t    return 0;\n-        }\n+\t}\n       else\n-        x = PATTERN (x);\n+\tx = PATTERN (x);\n     }\n \n   return for_each_rtx (&x, nonlocal_referenced_p_1, NULL);\n@@ -2556,9 +2556,9 @@ nonlocal_set_p (x)\n \t  x = CALL_INSN_FUNCTION_USAGE (x);\n \t  if (x == 0)\n \t    return 0;\n-        }\n+\t}\n       else\n-        x = PATTERN (x);\n+\tx = PATTERN (x);\n     }\n \n   return for_each_rtx (&x, nonlocal_set_p_1, NULL);\n@@ -2597,16 +2597,16 @@ mark_constant_function ()\n \n       if (nonlocal_set_p (insn) || global_reg_mentioned_p (insn)\n \t  || volatile_refs_p (PATTERN (insn)))\n-  \tbreak;\n+\tbreak;\n \n       if (! nonlocal_memory_referenced)\n \tnonlocal_memory_referenced = nonlocal_referenced_p (insn);\n     }\n-  \n+\n   end_alias_analysis ();\n-  \n+\n   /* Mark the function.  */\n-  \n+\n   if (insn)\n     ;\n   else if (nonlocal_memory_referenced)\n@@ -2651,10 +2651,10 @@ init_alias_analysis ()\n \n   reg_known_value_size = maxreg;\n \n-  reg_known_value \n+  reg_known_value\n     = (rtx *) xcalloc ((maxreg - FIRST_PSEUDO_REGISTER), sizeof (rtx))\n     - FIRST_PSEUDO_REGISTER;\n-  reg_known_equiv_p \n+  reg_known_equiv_p\n     = (char*) xcalloc ((maxreg - FIRST_PSEUDO_REGISTER), sizeof (char))\n     - FIRST_PSEUDO_REGISTER;\n "}, {"sha": "cbeba86c2e8801700a9cf438698bb4f383c05d91", "filename": "gcc/attribs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=ca7fd9cd384910ac69933dbc5f14f2d51d3e882e", "patch": "@@ -323,7 +323,7 @@ split_specs_attrs (specs_attrs, declspecs, prefix_attributes)\n   tree t, s, a, next, specs, attrs;\n \n   /* This can happen after an __extension__ in pedantic mode.  */\n-  if (specs_attrs != NULL_TREE \n+  if (specs_attrs != NULL_TREE\n       && TREE_CODE (specs_attrs) == INTEGER_CST)\n     {\n       *declspecs = NULL_TREE;"}, {"sha": "6ae4c76d382f2b4fddc4e0681091a6a0119a377a", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=ca7fd9cd384910ac69933dbc5f14f2d51d3e882e", "patch": "@@ -122,9 +122,9 @@ make_reorder_chain ()\n \t    next = bb;\n \t    break;\n \t  }\n-      \n+\n       if (next)\n-        prev = make_reorder_chain_1 (next, prev);\n+\tprev = make_reorder_chain_1 (next, prev);\n     }\n   while (next);\n   RBI (prev)->next = NULL;"}, {"sha": "189c06edc7010ec9839c5e44f11ed01bf220250c", "filename": "gcc/bitmap.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=ca7fd9cd384910ac69933dbc5f14f2d51d3e882e", "patch": "@@ -236,7 +236,7 @@ bitmap_clear (head)\n       bitmap_free = element;\n     }\n \n-  head->first = head->current =  0;\n+  head->first = head->current = 0;\n }\n \f\n /* Copy a bitmap to another bitmap.  */\n@@ -397,7 +397,7 @@ bitmap_bit_p (head, bit)\n /* Return the bit number of the first set bit in the bitmap, or -1\n    if the bitmap is empty.  */\n \n-int \n+int\n bitmap_first_set_bit (a)\n      bitmap a;\n {\n@@ -450,7 +450,7 @@ bitmap_first_set_bit (a)\n /* Return the bit number of the last set bit in the bitmap, or -1\n    if the bitmap is empty.  */\n \n-int \n+int\n bitmap_last_set_bit (a)\n      bitmap a;\n {"}, {"sha": "c2dcb9df30eb4460c8ab483dff9519ae446ec031", "filename": "gcc/bitmap.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=ca7fd9cd384910ac69933dbc5f14f2d51d3e882e", "patch": "@@ -20,7 +20,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n #ifndef GCC_BITMAP_H\n-#define GCC_BITMAP_H \n+#define GCC_BITMAP_H\n \n /* Number of words to use for each element in the linked list.  */\n \n@@ -129,7 +129,7 @@ do { \\\n   bitmap temp_bitmap_ = (bitmap) alloca (sizeof (bitmap_head)); \\\n   (PTR) = bitmap_initialize (temp_bitmap_); \\\n } while (0)\n-  \n+\n /* Allocate a bitmap with xmalloc.  */\n #define BITMAP_XMALLOC()                                        \\\n   bitmap_initialize ((bitmap) xmalloc (sizeof (bitmap_head)))"}, {"sha": "f7a78ca63df73d0ef4ae1aa5f59502ca71d470c9", "filename": "gcc/builtins.c", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7fd9cd384910ac69933dbc5f14f2d51d3e882e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ca7fd9cd384910ac69933dbc5f14f2d51d3e882e", "patch": "@@ -101,7 +101,7 @@ static rtx expand_builtin_va_start\tPARAMS ((int, tree));\n static rtx expand_builtin_va_end\tPARAMS ((tree));\n static rtx expand_builtin_va_copy\tPARAMS ((tree));\n static rtx expand_builtin_memcmp\tPARAMS ((tree, tree, rtx,\n-                                                 enum machine_mode));\n+\t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_strcmp\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_strncmp\tPARAMS ((tree, rtx,\n@@ -117,9 +117,9 @@ static rtx expand_builtin_strspn\tPARAMS ((tree, rtx,\n static rtx expand_builtin_strcspn\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_memcpy\tPARAMS ((tree, rtx,\n-                                                 enum machine_mode));\n+\t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_strcpy\tPARAMS ((tree, rtx,\n-                                                 enum machine_mode));\n+\t\t\t\t\t\t enum machine_mode));\n static rtx builtin_strncpy_read_str\tPARAMS ((PTR, HOST_WIDE_INT,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_strncpy\tPARAMS ((tree, rtx,\n@@ -129,7 +129,7 @@ static rtx builtin_memset_read_str\tPARAMS ((PTR, HOST_WIDE_INT,\n static rtx builtin_memset_gen_str\tPARAMS ((PTR, HOST_WIDE_INT,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_memset\tPARAMS ((tree, rtx,\n-                                                 enum machine_mode));\n+\t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_bzero\t\tPARAMS ((tree));\n static rtx expand_builtin_strlen\tPARAMS ((tree, rtx));\n static rtx expand_builtin_strstr\tPARAMS ((tree, rtx,\n@@ -512,7 +512,7 @@ expand_builtin_setjmp_setup (buf_addr, receiver_label)\n \n void\n expand_builtin_setjmp_receiver (receiver_label)\n-      rtx receiver_label ATTRIBUTE_UNUSED;\n+     rtx receiver_label ATTRIBUTE_UNUSED;\n {\n   /* Clobber the FP when we get here, so we have to make sure it's\n      marked as used by this function.  */\n@@ -718,7 +718,7 @@ expand_builtin_longjmp (buf_addr, value)\n \t  break;\n \t}\n       else if (GET_CODE (insn) == CALL_INSN)\n-        break;\n+\tbreak;\n     }\n }\n \n@@ -744,7 +744,7 @@ expand_builtin_prefetch (arglist)\n     {\n       arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n       if (TREE_CHAIN (TREE_CHAIN (arglist)))\n-        arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\targ2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n       else\n \targ2 = build_int_2 (3, 0);\n     }\n@@ -760,8 +760,8 @@ expand_builtin_prefetch (arglist)\n   /* Argument 1 (read/write flag) must be a compile-time constant int.  */\n   if (TREE_CODE (arg1) != INTEGER_CST)\n     {\n-       error (\"second arg to `__builtin_prefetch' must be a constant\");\n-       arg1 = integer_zero_node;\n+      error (\"second arg to `__builtin_prefetch' must be a constant\");\n+      arg1 = integer_zero_node;\n     }\n   op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n   /* Argument 1 must be either zero or one.  */\n@@ -791,14 +791,14 @@ expand_builtin_prefetch (arglist)\n       if ((! (*insn_data[(int)CODE_FOR_prefetch].operand[0].predicate)\n \t     (op0,\n \t      insn_data[(int)CODE_FOR_prefetch].operand[0].mode)) ||\n-          (GET_MODE(op0) != Pmode))\n-        {\n+\t  (GET_MODE(op0) != Pmode))\n+\t{\n #ifdef POINTERS_EXTEND_UNSIGNED\n \t  if (GET_MODE(op0) != Pmode)\n \t    op0 = convert_memory_address (Pmode, op0);\n #endif\n-          op0 = force_reg (Pmode, op0);\n-        }\n+\t  op0 = force_reg (Pmode, op0);\n+\t}\n       emit_insn (gen_prefetch (op0, op1, op2));\n     }\n   else\n@@ -1556,16 +1556,16 @@ expand_builtin_mathfn (exp, target, subtarget)\n \t\t\t       0, lab1);\n \n #ifdef TARGET_EDOM\n-\t{\n+      {\n #ifdef GEN_ERRNO_RTX\n-\t  rtx errno_rtx = GEN_ERRNO_RTX;\n+\trtx errno_rtx = GEN_ERRNO_RTX;\n #else\n-\t  rtx errno_rtx\n-\t    = gen_rtx_MEM (word_mode, gen_rtx_SYMBOL_REF (Pmode, \"errno\"));\n+\trtx errno_rtx\n+\t  = gen_rtx_MEM (word_mode, gen_rtx_SYMBOL_REF (Pmode, \"errno\"));\n #endif\n \n-\t  emit_move_insn (errno_rtx, GEN_INT (TARGET_EDOM));\n-\t}\n+\temit_move_insn (errno_rtx, GEN_INT (TARGET_EDOM));\n+      }\n #else\n       /* We can't set errno=EDOM directly; let the library call do it.\n \t Pop the arguments right away in case the call gets deleted.  */\n@@ -1948,20 +1948,20 @@ expand_builtin_memcpy (arglist, target, mode)\n \n       /* If DEST is not a pointer type, call the normal function.  */\n       if (dest_align == 0)\n-        return 0;\n+\treturn 0;\n \n       /* If the LEN parameter is zero, return DEST.  */\n       if (host_integerp (len, 1) && tree_low_cst (len, 1) == 0)\n-        {\n-          /* Evaluate and ignore SRC in case it has side-effects.  */\n-          expand_expr (src, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-          return expand_expr (dest, target, mode, EXPAND_NORMAL);\n-        }\n+\t{\n+\t  /* Evaluate and ignore SRC in case it has side-effects.  */\n+\t  expand_expr (src, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n+\t}\n \n       /* If either SRC is not a pointer type, don't do this\n          operation in-line.  */\n       if (src_align == 0)\n-        return 0;\n+\treturn 0;\n \n       dest_mem = get_memory_rtx (dest);\n       set_mem_align (dest_mem, dest_align);\n@@ -2024,7 +2024,7 @@ expand_builtin_strcpy (exp, target, mode)\n   len = size_binop (PLUS_EXPR, len, ssize_int (1));\n   chainon (arglist, build_tree_list (NULL_TREE, len));\n   return expand_expr (build_function_call_expr (fn, arglist),\n-                      target, mode, EXPAND_NORMAL);\n+\t\t      target, mode, EXPAND_NORMAL);\n }\n \n /* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)\n@@ -2069,9 +2069,9 @@ expand_builtin_strncpy (arglist, target, mode)\n \n       /* If the len parameter is zero, return the dst parameter.  */\n       if (integer_zerop (len))\n-        {\n-\t/* Evaluate and ignore the src argument in case it has\n-           side-effects.  */\n+\t{\n+\t  /* Evaluate and ignore the src argument in case it has\n+\t     side-effects.  */\n \t  expand_expr (TREE_VALUE (TREE_CHAIN (arglist)), const0_rtx,\n \t\t       VOIDmode, EXPAND_NORMAL);\n \t  /* Return the dst parameter.  */\n@@ -2112,9 +2112,9 @@ expand_builtin_strncpy (arglist, target, mode)\n       /* OK transform into builtin memcpy.  */\n       fn = built_in_decls[BUILT_IN_MEMCPY];\n       if (!fn)\n-        return 0;\n+\treturn 0;\n       return expand_expr (build_function_call_expr (fn, arglist),\n-                          target, mode, EXPAND_NORMAL);\n+\t\t\t  target, mode, EXPAND_NORMAL);\n     }\n }\n \n@@ -2198,41 +2198,41 @@ expand_builtin_memset (exp, target, mode)\n \n       /* If the LEN parameter is zero, return DEST.  */\n       if (host_integerp (len, 1) && tree_low_cst (len, 1) == 0)\n-        {\n-          /* Evaluate and ignore VAL in case it has side-effects.  */\n-          expand_expr (val, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-          return expand_expr (dest, target, mode, EXPAND_NORMAL);\n-        }\n+\t{\n+\t  /* Evaluate and ignore VAL in case it has side-effects.  */\n+\t  expand_expr (val, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n+\t}\n \n       if (TREE_CODE (val) != INTEGER_CST)\n-        {\n-          rtx val_rtx;\n+\t{\n+\t  rtx val_rtx;\n \n-          if (!host_integerp (len, 1))\n-            return 0;\n+\t  if (!host_integerp (len, 1))\n+\t    return 0;\n \n-          if (optimize_size && tree_low_cst (len, 1) > 1)\n-            return 0;\n+\t  if (optimize_size && tree_low_cst (len, 1) > 1)\n+\t    return 0;\n \n-          /* Assume that we can memset by pieces if we can store the\n-           * the coefficients by pieces (in the required modes).\n-           * We can't pass builtin_memset_gen_str as that emits RTL.  */\n-          c = 1;\n+\t  /* Assume that we can memset by pieces if we can store the\n+\t   * the coefficients by pieces (in the required modes).\n+\t   * We can't pass builtin_memset_gen_str as that emits RTL.  */\n+\t  c = 1;\n \t  if (!can_store_by_pieces (tree_low_cst (len, 1),\n \t\t\t\t    builtin_memset_read_str,\n-                                    (PTR) &c, dest_align))\n+\t\t\t\t    (PTR) &c, dest_align))\n \t    return 0;\n \n-          val = fold (build1 (CONVERT_EXPR, unsigned_char_type_node, val));\n-          val_rtx = expand_expr (val, NULL_RTX, VOIDmode, 0);\n-          val_rtx = force_reg (TYPE_MODE (unsigned_char_type_node),\n-                               val_rtx);\n+\t  val = fold (build1 (CONVERT_EXPR, unsigned_char_type_node, val));\n+\t  val_rtx = expand_expr (val, NULL_RTX, VOIDmode, 0);\n+\t  val_rtx = force_reg (TYPE_MODE (unsigned_char_type_node),\n+\t\t\t       val_rtx);\n \t  dest_mem = get_memory_rtx (dest);\n \t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n \t\t\t   builtin_memset_gen_str,\n \t\t\t   (PTR)val_rtx, dest_align);\n \t  return force_operand (XEXP (dest_mem, 0), NULL_RTX);\n-        }\n+\t}\n \n       if (target_char_cast (val, &c))\n \treturn 0;\n@@ -2317,7 +2317,7 @@ expand_builtin_memcmp (exp, arglist, target, mode)\n   const char *p1, *p2;\n \n   if (!validate_arglist (arglist,\n-\t\t      POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n \n   arg1 = TREE_VALUE (arglist);\n@@ -2356,12 +2356,12 @@ expand_builtin_memcmp (exp, arglist, target, mode)\n       tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n       tree ind1 =\n       fold (build1 (CONVERT_EXPR, integer_type_node,\n-                    build1 (INDIRECT_REF, cst_uchar_node,\n-                            build1 (NOP_EXPR, cst_uchar_ptr_node, arg1))));\n+\t\t    build1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t    build1 (NOP_EXPR, cst_uchar_ptr_node, arg1))));\n       tree ind2 =\n       fold (build1 (CONVERT_EXPR, integer_type_node,\n-                    build1 (INDIRECT_REF, cst_uchar_node,\n-                            build1 (NOP_EXPR, cst_uchar_ptr_node, arg2))));\n+\t\t    build1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t    build1 (NOP_EXPR, cst_uchar_ptr_node, arg2))));\n       tree result = fold (build (MINUS_EXPR, integer_type_node, ind1, ind2));\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n@@ -2498,12 +2498,12 @@ expand_builtin_strcmp (exp, target, mode)\n   if (!len || TREE_CODE (len) != INTEGER_CST)\n     {\n       if (len2 && !TREE_SIDE_EFFECTS (len2))\n-        len = len2;\n+\tlen = len2;\n       else if (len == 0)\n-        return 0;\n+\treturn 0;\n     }\n   else if (len2 && TREE_CODE (len2) == INTEGER_CST\n-           && tree_int_cst_lt (len2, len))\n+\t   && tree_int_cst_lt (len2, len))\n     len = len2;\n \n   /* If both arguments have side effects, we cannot optimize.  */\n@@ -2516,7 +2516,7 @@ expand_builtin_strcmp (exp, target, mode)\n \n   chainon (arglist, build_tree_list (NULL_TREE, len));\n   return expand_expr (build_function_call_expr (fn, arglist),\n-                      target, mode, EXPAND_NORMAL);\n+\t\t      target, mode, EXPAND_NORMAL);\n }\n \n /* Expand expression EXP, which is a call to the strncmp builtin.  Return 0\n@@ -2544,23 +2544,23 @@ expand_builtin_strncmp (exp, target, mode)\n \n   /* If the len parameter is zero, return zero.  */\n   if (host_integerp (arg3, 1) && tree_low_cst (arg3, 1) == 0)\n-  {\n-    /* Evaluate and ignore arg1 and arg2 in case they have\n-       side-effects.  */\n-    expand_expr (arg1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-    expand_expr (arg2, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-    return const0_rtx;\n-  }\n+    {\n+      /* Evaluate and ignore arg1 and arg2 in case they have\n+\t side-effects.  */\n+      expand_expr (arg1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      expand_expr (arg2, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      return const0_rtx;\n+    }\n \n   p1 = c_getstr (arg1);\n   p2 = c_getstr (arg2);\n \n   /* If all arguments are constant, evaluate at compile-time.  */\n   if (host_integerp (arg3, 1) && p1 && p2)\n-  {\n-    const int r = strncmp (p1, p2, tree_low_cst (arg3, 1));\n-    return (r < 0 ? constm1_rtx : (r > 0 ? const1_rtx : const0_rtx));\n-  }\n+    {\n+      const int r = strncmp (p1, p2, tree_low_cst (arg3, 1));\n+      return (r < 0 ? constm1_rtx : (r > 0 ? const1_rtx : const0_rtx));\n+    }\n \n   /* If len == 1 or (either string parameter is \"\" and (len >= 1)),\n       return (*(const u_char*)arg1 - *(const u_char*)arg2).  */\n@@ -2618,7 +2618,7 @@ expand_builtin_strncmp (exp, target, mode)\n   newarglist = tree_cons (NULL_TREE, arg2, newarglist);\n   newarglist = tree_cons (NULL_TREE, arg1, newarglist);\n   return expand_expr (build_function_call_expr (fn, newarglist),\n-                      target, mode, EXPAND_NORMAL);\n+\t\t      target, mode, EXPAND_NORMAL);\n }\n \n /* Expand expression EXP, which is a call to the strcat builtin.\n@@ -2670,7 +2670,7 @@ expand_builtin_strncat (arglist, target, mode)\n       /* If the requested length is zero, or the src parameter string\n           length is zero, return the dst parameter.  */\n       if (integer_zerop (len) || (p && *p == '\\0'))\n-        {\n+\t{\n \t  /* Evaluate and ignore the src and len parameters in case\n \t     they have side-effects.  */\n \t  expand_expr (src, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -2682,7 +2682,7 @@ expand_builtin_strncat (arglist, target, mode)\n          length, call strcat.  */\n       if (TREE_CODE (len) == INTEGER_CST && p\n \t  && compare_tree_int (len, strlen (p)) >= 0)\n-        {\n+\t{\n \t  tree newarglist\n \t    = tree_cons (NULL_TREE, dst, build_tree_list (NULL_TREE, src));\n \t  tree fn = built_in_decls[BUILT_IN_STRCAT];\n@@ -2718,14 +2718,14 @@ expand_builtin_strspn (arglist, target, mode)\n \n       /* If both arguments are constants, evaluate at compile-time.  */\n       if (p1 && p2)\n-        {\n+\t{\n \t  const size_t r = strspn (p1, p2);\n \t  return expand_expr (size_int (r), target, mode, EXPAND_NORMAL);\n \t}\n \n       /* If either argument is \"\", return 0.  */\n       if ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0'))\n-        {\n+\t{\n \t  /* Evaluate and ignore both arguments in case either one has\n \t     side-effects.  */\n \t  expand_expr (s1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -2755,14 +2755,14 @@ expand_builtin_strcspn (arglist, target, mode)\n \n       /* If both arguments are constants, evaluate at compile-time.  */\n       if (p1 && p2)\n-        {\n+\t{\n \t  const size_t r = strcspn (p1, p2);\n \t  return expand_expr (size_int (r), target, mode, EXPAND_NORMAL);\n \t}\n \n       /* If the first argument is \"\", return 0.  */\n       if (p1 && *p1 == '\\0')\n-        {\n+\t{\n \t  /* Evaluate and ignore argument s2 in case it has\n \t     side-effects.  */\n \t  expand_expr (s2, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -2771,7 +2771,7 @@ expand_builtin_strcspn (arglist, target, mode)\n \n       /* If the second argument is \"\", return __builtin_strlen(s1).  */\n       if (p2 && *p2 == '\\0')\n-        {\n+\t{\n \t  tree newarglist = build_tree_list (NULL_TREE, s1),\n \t    fn = built_in_decls[BUILT_IN_STRLEN];\n \n@@ -3708,11 +3708,11 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       case BUILT_IN_FPUTC_UNLOCKED:\n       case BUILT_IN_FPUTS_UNLOCKED:\n       case BUILT_IN_FWRITE_UNLOCKED:\n-        return expand_call (exp, target, ignore);\n+\treturn expand_call (exp, target, ignore);\n \n       default:\n-        break;\n-    }\n+\tbreak;\n+      }\n \n   switch (fcode)\n     {\n@@ -3824,11 +3824,11 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n        0 otherwise.  */\n     case BUILT_IN_AGGREGATE_INCOMING_ADDRESS:\n       if (arglist != 0\n-          || ! AGGREGATE_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl)))\n-          || GET_CODE (DECL_RTL (DECL_RESULT (current_function_decl))) != MEM)\n-        return const0_rtx;\n+\t  || ! AGGREGATE_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl)))\n+\t  || GET_CODE (DECL_RTL (DECL_RESULT (current_function_decl))) != MEM)\n+\treturn const0_rtx;\n       else\n-        return XEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);\n+\treturn XEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);\n \n     case BUILT_IN_ALLOCA:\n       target = expand_builtin_alloca (arglist, target);"}]}