{"sha": "23d0939b41bb640efeb07a7711ee3f6f88af46c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNkMDkzOWI0MWJiNjQwZWZlYjA3YTc3MTFlZTNmNmY4OGFmNDZjOQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-04-11T23:03:20Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-04-11T23:03:20Z"}, "message": "sh.h (RETURN_ADDR_RTX): Use NULL_RTX instead of 0.\n\n\t* config/sh/sh.h (RETURN_ADDR_RTX): Use NULL_RTX instead of 0.\n\t* config/sh/sh.c (INSN_REGMODE_WEIGHT, CURR_REGMODE_PRESSURE):\n\tFix line width.\n\t(dump_table): Use bool type for need_align and have_df variables.\n\t(find_barrier, sfunc_uses_reg): Use NULL_RTX instead of 0.\n\t(regs_used): Remove register modifier.\n\t(barrier_align): Move variables slot, credit, jump_to_next\n\tinto if block above for loop.  Use bool type for jump_to_next.\n\t(sh_function_arg): Use NULL_RTX instead of 0.\n\nFrom-SVN: r186366", "tree": {"sha": "8e120dc8f7d18c9b4f20138344156e9a4b7b59fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e120dc8f7d18c9b4f20138344156e9a4b7b59fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23d0939b41bb640efeb07a7711ee3f6f88af46c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23d0939b41bb640efeb07a7711ee3f6f88af46c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23d0939b41bb640efeb07a7711ee3f6f88af46c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23d0939b41bb640efeb07a7711ee3f6f88af46c9/comments", "author": null, "committer": null, "parents": [{"sha": "da97611d45bc266f3f6b0fc502bb2e7a0cee2529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da97611d45bc266f3f6b0fc502bb2e7a0cee2529", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da97611d45bc266f3f6b0fc502bb2e7a0cee2529"}], "stats": {"total": 99, "additions": 59, "deletions": 40}, "files": [{"sha": "c5e54d34b114d577b9af1cba6842eb1b3ae35533", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d0939b41bb640efeb07a7711ee3f6f88af46c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d0939b41bb640efeb07a7711ee3f6f88af46c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23d0939b41bb640efeb07a7711ee3f6f88af46c9", "patch": "@@ -1,3 +1,15 @@\n+2012-04-12  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* config/sh/sh.h (RETURN_ADDR_RTX): Use NULL_RTX instead of 0.\n+\t* config/sh/sh.c (INSN_REGMODE_WEIGHT, CURR_REGMODE_PRESSURE):\n+\tFix line width.\n+\t(dump_table): Use bool type for need_align and have_df variables.\n+\t(find_barrier, sfunc_uses_reg): Use NULL_RTX instead of 0.\n+\t(regs_used): Remove register modifier.\n+\t(barrier_align): Move variables slot, credit, jump_to_next\n+\tinto if block above for loop.  Use bool type for jump_to_next.\n+\t(sh_function_arg): Use NULL_RTX instead of 0.\n+\n 2012-04-11  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* config/m68k/m68k.md (rotrhi3+1): Name it rotrhi_lowpart."}, {"sha": "7dbbe1c57281e12131d36443bcc676363bca3a11", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 46, "deletions": 39, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d0939b41bb640efeb07a7711ee3f6f88af46c9/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d0939b41bb640efeb07a7711ee3f6f88af46c9/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=23d0939b41bb640efeb07a7711ee3f6f88af46c9", "patch": "@@ -547,10 +547,12 @@ static const struct attribute_spec sh_attribute_table[] =\n #define TARGET_FRAME_POINTER_REQUIRED sh_frame_pointer_required\n \n /* Return regmode weight for insn.  */\n-#define INSN_REGMODE_WEIGHT(INSN, MODE)  regmode_weight[((MODE) == SImode) ? 0 : 1][INSN_UID (INSN)]\n+#define INSN_REGMODE_WEIGHT(INSN, MODE)\\\n+  regmode_weight[((MODE) == SImode) ? 0 : 1][INSN_UID (INSN)]\n \n /* Return current register pressure for regmode.  */\n-#define CURR_REGMODE_PRESSURE(MODE) \tcurr_regmode_pressure[((MODE) == SImode) ? 0 : 1]\n+#define CURR_REGMODE_PRESSURE(MODE)\\\n+  curr_regmode_pressure[((MODE) == SImode) ? 0 : 1]\n \n #undef  TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO\tsh_encode_section_info\n@@ -4202,10 +4204,10 @@ dump_table (rtx start, rtx barrier)\n {\n   rtx scan = barrier;\n   int i;\n-  int need_align = 1;\n+  bool need_align = true;\n   rtx lab;\n   label_ref_list_t ref;\n-  int have_df = 0;\n+  bool have_df = false;\n \n   /* Do two passes, first time dump out the HI sized constants.  */\n \n@@ -4218,7 +4220,7 @@ dump_table (rtx start, rtx barrier)\n \t  if (need_align)\n \t    {\n \t      scan = emit_insn_after (gen_align_2 (), scan);\n-\t      need_align = 0;\n+\t      need_align = false;\n \t    }\n \t  for (lab = p->label; lab; lab = LABEL_REFS (lab))\n \t    scan = emit_label_after (lab, scan);\n@@ -4231,15 +4233,15 @@ dump_table (rtx start, rtx barrier)\n \t    }\n \t}\n       else if (p->mode == DFmode)\n-\thave_df = 1;\n+\thave_df = true;\n     }\n \n-  need_align = 1;\n+  need_align = true;\n \n   if (start)\n     {\n       scan = emit_insn_after (gen_align_4 (), scan);\n-      need_align = 0;\n+      need_align = false;\n       for (; start != barrier; start = NEXT_INSN (start))\n \tif (NONJUMP_INSN_P (start)\n \t    && recog_memoized (start) == CODE_FOR_casesi_worker_2)\n@@ -4256,7 +4258,7 @@ dump_table (rtx start, rtx barrier)\n \n       scan = emit_label_after (gen_label_rtx (), scan);\n       scan = emit_insn_after (gen_align_log (GEN_INT (3)), scan);\n-      need_align = 0;\n+      need_align = false;\n \n       for (i = 0; i < pool_size; i++)\n \t{\n@@ -4298,7 +4300,7 @@ dump_table (rtx start, rtx barrier)\n \t\t{\n \t\t  scan = emit_insn_after (gen_align_log (GEN_INT (3)), scan);\n \t\t  align_insn = scan;\n-\t\t  need_align = 0;\n+\t\t  need_align = false;\n \t\t}\n \t    case DImode:\n \t      for (lab = p->label; lab; lab = LABEL_REFS (lab))\n@@ -4336,7 +4338,7 @@ dump_table (rtx start, rtx barrier)\n \tcase SFmode:\n \t  if (need_align)\n \t    {\n-\t      need_align = 0;\n+\t      need_align = false;\n \t      scan = emit_label_after (gen_label_rtx (), scan);\n \t      scan = emit_insn_after (gen_align_4 (), scan);\n \t    }\n@@ -4349,7 +4351,7 @@ dump_table (rtx start, rtx barrier)\n \tcase DImode:\n \t  if (need_align)\n \t    {\n-\t      need_align = 0;\n+\t      need_align = false;\n \t      scan = emit_label_after (gen_label_rtx (), scan);\n \t      scan = emit_insn_after (gen_align_4 (), scan);\n \t    }\n@@ -4548,7 +4550,9 @@ find_barrier (int num_mova, rtx mova, rtx from)\n   int hi_align = 2;\n   int si_align = 2;\n   int leading_mova = num_mova;\n-  rtx barrier_before_mova = 0, found_barrier = 0, good_barrier = 0;\n+  rtx barrier_before_mova = NULL_RTX;\n+  rtx found_barrier = NULL_RTX;\n+  rtx good_barrier = NULL_RTX;\n   int si_limit;\n   int hi_limit;\n   rtx orig = from;\n@@ -4882,19 +4886,19 @@ sfunc_uses_reg (rtx insn)\n   rtx pattern, part, reg_part, reg;\n \n   if (!NONJUMP_INSN_P (insn))\n-    return 0;\n+    return NULL_RTX;\n   pattern = PATTERN (insn);\n   if (GET_CODE (pattern) != PARALLEL || get_attr_type (insn) != TYPE_SFUNC)\n-    return 0;\n+    return NULL_RTX;\n \n-  for (reg_part = 0, i = XVECLEN (pattern, 0) - 1; i >= 1; i--)\n+  for (reg_part = NULL_RTX, i = XVECLEN (pattern, 0) - 1; i >= 1; i--)\n     {\n       part = XVECEXP (pattern, 0, i);\n       if (GET_CODE (part) == USE && GET_MODE (XEXP (part, 0)) == SImode)\n \treg_part = part;\n     }\n   if (! reg_part)\n-    return 0;\n+    return NULL_RTX;\n   reg = XEXP (reg_part, 0);\n   for (i = XVECLEN (pattern, 0) - 1; i >= 0; i--)\n     {\n@@ -4904,7 +4908,7 @@ sfunc_uses_reg (rtx insn)\n       if (reg_mentioned_p (reg, ((GET_CODE (part) == SET\n \t\t\t\t  && REG_P (SET_DEST (part)))\n \t\t\t\t ? SET_SRC (part) : part)))\n-\treturn 0;\n+\treturn NULL_RTX;\n     }\n   return reg;\n }\n@@ -5054,7 +5058,7 @@ regs_used (rtx x, int is_dest)\n     {\n       if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    used |= regs_used (XVECEXP (x, i, j), is_dest);\n \t}\n@@ -5339,7 +5343,6 @@ int\n barrier_align (rtx barrier_or_label)\n {\n   rtx next = next_real_insn (barrier_or_label), pat, prev;\n-  int slot, credit, jump_to_next = 0;\n \n   if (! next)\n     return 0;\n@@ -5391,13 +5394,17 @@ barrier_align (rtx barrier_or_label)\n \n       /* PREV is presumed to be the JUMP_INSN for the barrier under\n \t investigation.  Skip to the insn before it.  */\n+\n+      int slot, credit;\n+      bool jump_to_next = false;\n+\n       prev = prev_real_insn (prev);\n \n       for (slot = 2, credit = (1 << (CACHE_LOG - 2)) + 2;\n \t   credit >= 0 && prev && NONJUMP_INSN_P (prev);\n \t   prev = prev_real_insn (prev))\n \t{\n-\t  jump_to_next = 0;\n+\t  jump_to_next = false;\n \t  if (GET_CODE (PATTERN (prev)) == USE\n \t      || GET_CODE (PATTERN (prev)) == CLOBBER)\n \t    continue;\n@@ -5407,7 +5414,7 @@ barrier_align (rtx barrier_or_label)\n \t      if (INSN_UID (prev) == INSN_UID (next))\n \t\t{\n \t  \t  /* Delay slot was filled with insn at jump target.  */\n-\t\t  jump_to_next = 1;\n+\t\t  jump_to_next = true;\n \t\t  continue;\n   \t\t}\n \t    }\n@@ -8438,7 +8445,7 @@ sh_function_arg (cumulative_args_t ca_v, enum machine_mode mode,\n \n       regno = (BASE_ARG_REG (mode) + ROUND_REG (*ca, mode))\n \t       ^ (mode == SFmode && TARGET_SH4\n-\t\t  && TARGET_LITTLE_ENDIAN != 0\n+\t\t  && TARGET_LITTLE_ENDIAN\n \t\t  && ! TARGET_HITACHI && ! ca->renesas_abi);\n       return gen_rtx_REG (mode, regno);\n \n@@ -8476,10 +8483,10 @@ sh_function_arg (cumulative_args_t ca_v, enum machine_mode mode,\n \t\t\t\t       + ca->arg_count[(int) SH_ARG_INT]));\n \t}\n \n-      return 0;\n+      return NULL_RTX;\n     }\n \n-  return 0;\n+  return NULL_RTX;\n }\n \n /* Update the data in CUM to advance over an argument\n@@ -8640,7 +8647,7 @@ static rtx\n sh_struct_value_rtx (tree fndecl, int incoming ATTRIBUTE_UNUSED)\n {\n   if (TARGET_HITACHI || sh_attr_renesas_p (fndecl))\n-    return 0;\n+    return NULL_RTX;\n   return gen_rtx_REG (Pmode, 2);\n }\n \n@@ -9195,7 +9202,7 @@ sh_attr_renesas_p (const_tree td)\n {\n   if (TARGET_HITACHI)\n     return true;\n-  if (td == 0)\n+  if (td == NULL_TREE)\n     return false;\n   if (DECL_P (td))\n     td = TREE_TYPE (td);\n@@ -9423,7 +9430,7 @@ reg_unused_after (rtx reg, rtx insn)\n \t\t  else\n \t\t    return false;\n \t\t}\n-\t      if (set == 0\n+\t      if (set == NULL_RTX\n \t\t  && reg_overlap_mentioned_p (reg, PATTERN (this_insn)))\n \t\treturn false;\n \t    }\n@@ -9618,7 +9625,7 @@ sh_insn_length_adjustment (rtx insn)\n       rtx body = PATTERN (insn);\n       const char *templ;\n       char c;\n-      int maybe_label = 1;\n+      bool maybe_label = true;\n \n       if (GET_CODE (body) == ASM_INPUT)\n \ttempl = XSTR (body, 0);\n@@ -9654,7 +9661,7 @@ sh_insn_length_adjustment (rtx insn)\n \t\t  break;\n \t\t}\n \t      else if (c == '\\'' || c == '\"')\n-\t\tmaybe_label = 0;\n+\t\tmaybe_label = false;\n \t      c = *templ++;\n \t    }\n \t  sum += ppi_adjust;\n@@ -9820,15 +9827,15 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n   if (GET_CODE (orig) == LABEL_REF\n       || (GET_CODE (orig) == SYMBOL_REF && SYMBOL_REF_LOCAL_P (orig)))\n     {\n-      if (reg == 0)\n+      if (reg == NULL_RTX)\n \treg = gen_reg_rtx (Pmode);\n \n       emit_insn (gen_symGOTOFF2reg (reg, orig));\n       return reg;\n     }\n   else if (GET_CODE (orig) == SYMBOL_REF)\n     {\n-      if (reg == 0)\n+      if (reg == NULL_RTX)\n \treg = gen_reg_rtx (Pmode);\n \n       emit_insn (gen_symGOT2reg (reg, orig));\n@@ -10069,7 +10076,7 @@ mark_constant_pool_use (rtx x)\n {\n   rtx insn, lab, pattern;\n \n-  if (x == NULL)\n+  if (x == NULL_RTX)\n     return x;\n \n   switch (GET_CODE (x))\n@@ -11347,12 +11354,12 @@ sh_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   enum machine_mode tmode = VOIDmode;\n   int nop = 0, i;\n   rtx op[4];\n-  rtx pat = 0;\n+  rtx pat = NULL_RTX;\n \n   if (signature_args[signature][0])\n     {\n       if (ignore)\n-\treturn 0;\n+\treturn NULL_RTX;\n \n       tmode = insn_data[icode].operand[0].mode;\n       if (! target\n@@ -11411,7 +11418,7 @@ sh_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       gcc_unreachable ();\n     }\n   if (! pat)\n-    return 0;\n+    return NULL_RTX;\n   emit_insn (pat);\n   return target;\n }\n@@ -12189,16 +12196,16 @@ replace_n_hard_rtx (rtx x, rtx *replacements, int n_replacements, int modify)\n \n   /* The following prevents loops occurrence when we change MEM in\n      CONST_DOUBLE onto the same CONST_DOUBLE.  */\n-  if (x != 0 && GET_CODE (x) == CONST_DOUBLE)\n+  if (x != NULL_RTX && GET_CODE (x) == CONST_DOUBLE)\n     return x;\n \n   for (i = n_replacements - 1; i >= 0 ; i--)\n   if (x == replacements[i*2] && GET_MODE (x) == GET_MODE (replacements[i*2+1]))\n     return replacements[i*2+1];\n \n   /* Allow this function to make replacements in EXPR_LISTs.  */\n-  if (x == 0)\n-    return 0;\n+  if (x == NULL_RTX)\n+    return NULL_RTX;\n \n   if (GET_CODE (x) == SUBREG)\n     {"}, {"sha": "a6fac9484c2443ed44e128fa3606461c9d7ea286", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23d0939b41bb640efeb07a7711ee3f6f88af46c9/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23d0939b41bb640efeb07a7711ee3f6f88af46c9/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=23d0939b41bb640efeb07a7711ee3f6f88af46c9", "patch": "@@ -1651,7 +1651,7 @@ struct sh_args {\n    can ignore COUNT.  */\n \n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\\\n-  (((COUNT) == 0) ? sh_get_pr_initial_val () : (rtx) 0)\n+  (((COUNT) == 0) ? sh_get_pr_initial_val () : NULL_RTX)\n \n /* A C expression whose value is RTL representing the location of the\n    incoming return address at the beginning of any function, before the"}]}