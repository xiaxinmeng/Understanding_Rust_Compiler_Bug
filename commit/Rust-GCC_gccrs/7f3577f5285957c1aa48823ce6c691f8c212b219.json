{"sha": "7f3577f5285957c1aa48823ce6c691f8c212b219", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YzNTc3ZjUyODU5NTdjMWFhNDg4MjNjZTZjNjkxZjhjMjEyYjIxOQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-05T08:13:31Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-05T08:13:31Z"}, "message": "Simplify gcov_histogram as it's used only for ARCS counters.\n\n2018-06-05  Martin Liska  <mliska@suse.cz>\n\n\t* auto-profile.c (read_autofdo_file): Do not use\n\tgcov_ctr_summary struct.\n\t(afdo_callsite_hot_enough_for_early_inline): Likewise.\n\t* coverage.c (struct counts_entry): Likewise.\n\t(read_counts_file): Read just single summary entry.\n\t(get_coverage_counts): Use gcov_summary struct.\n\t* coverage.h (get_coverage_counts): Likewise.\n\t* gcov-dump.c (dump_working_sets): Likewise.\n\t(tag_summary): Dump just single summary.\n\t* gcov-io.c (gcov_write_summary): Write just histogram\n\tsummary.\n\t(gcov_read_summary): Read just single summary.\n\t(compute_working_sets): Use gcov_summary struct.\n\t* gcov-io.h (GCOV_TAG_SUMMARY_LENGTH): Remove usage\n\tof GCOV_COUNTERS_SUMMABLE.\n\t(GCOV_COUNTERS_SUMMABLE): Remove.\n\t(GCOV_FIRST_VALUE_COUNTER): Replace with\n\tGCOV_COUNTER_V_INTERVAL.\n\t(struct gcov_ctr_summary): Remove.\n\t(struct gcov_summary): Directly use fields of former\n\tgcov_ctr_summary.\n\t(compute_working_sets): Use gcov_summary struct.\n\t* gcov.c (read_count_file): Do not use ctrs fields.\n\t* lto-cgraph.c (merge_profile_summaries): Use gcov_summary\n\tstruct.\n\t* lto-streamer.h (struct GTY): Make profile_info gcov_summary\n\tstruct.\n\t* profile.c: Likewise.\n\t* profile.h: Likewise.\n2018-06-05  Martin Liska  <mliska@suse.cz>\n\n\t* libgcov-driver.c (gcov_compute_histogram): Remove usage\n\tof gcov_ctr_summary.\n\t(compute_summary): Do it just for a single summary.\n\t(merge_one_data): Likewise.\n\t(merge_summary): Simplify as we read just single summary.\n\t(dump_one_gcov): Pass proper argument.\n\t* libgcov-util.c (compute_one_gcov): Simplify as we have just\n\tsingle summary.\n\t(gcov_info_count_all_cold): Likewise.\n\t(calculate_overlap): Likewise.\n\nFrom-SVN: r261189", "tree": {"sha": "5127bd697a20fb3805447c7cd1857b52f04112ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5127bd697a20fb3805447c7cd1857b52f04112ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f3577f5285957c1aa48823ce6c691f8c212b219", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f3577f5285957c1aa48823ce6c691f8c212b219", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f3577f5285957c1aa48823ce6c691f8c212b219", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f3577f5285957c1aa48823ce6c691f8c212b219/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "632b10e14156db1e429f623628ad4f270c1550c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/632b10e14156db1e429f623628ad4f270c1550c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/632b10e14156db1e429f623628ad4f270c1550c4"}], "stats": {"total": 635, "additions": 281, "deletions": 354}, "files": [{"sha": "6e968d696a647b401c8b0fa486320305dd71e827", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -1,3 +1,35 @@\n+2018-06-05  Martin Liska  <mliska@suse.cz>\n+\n+\t* auto-profile.c (read_autofdo_file): Do not use\n+\tgcov_ctr_summary struct.\n+\t(afdo_callsite_hot_enough_for_early_inline): Likewise.\n+\t* coverage.c (struct counts_entry): Likewise.\n+\t(read_counts_file): Read just single summary entry.\n+\t(get_coverage_counts): Use gcov_summary struct.\n+\t* coverage.h (get_coverage_counts): Likewise.\n+\t* gcov-dump.c (dump_working_sets): Likewise.\n+\t(tag_summary): Dump just single summary.\n+\t* gcov-io.c (gcov_write_summary): Write just histogram\n+\tsummary.\n+\t(gcov_read_summary): Read just single summary.\n+\t(compute_working_sets): Use gcov_summary struct.\n+\t* gcov-io.h (GCOV_TAG_SUMMARY_LENGTH): Remove usage\n+\tof GCOV_COUNTERS_SUMMABLE.\n+\t(GCOV_COUNTERS_SUMMABLE): Remove.\n+\t(GCOV_FIRST_VALUE_COUNTER): Replace with\n+\tGCOV_COUNTER_V_INTERVAL.\n+\t(struct gcov_ctr_summary): Remove.\n+\t(struct gcov_summary): Directly use fields of former\n+\tgcov_ctr_summary.\n+\t(compute_working_sets): Use gcov_summary struct.\n+\t* gcov.c (read_count_file): Do not use ctrs fields.\n+\t* lto-cgraph.c (merge_profile_summaries): Use gcov_summary\n+\tstruct.\n+\t* lto-streamer.h (struct GTY): Make profile_info gcov_summary\n+\tstruct.\n+\t* profile.c: Likewise.\n+\t* profile.h: Likewise.\n+\n 2018-06-05  Martin Liska  <mliska@suse.cz>\n \n \tPR gcov-profile/84846"}, {"sha": "197fa10e08c83c1ba5a2509d6d0ccc6b31da62b7", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -318,8 +318,8 @@ static string_table *afdo_string_table;\n /* Store the AutoFDO source profile.  */\n static autofdo_source_profile *afdo_source_profile;\n \n-/* gcov_ctr_summary structure to store the profile_info.  */\n-static struct gcov_ctr_summary *afdo_profile_info;\n+/* gcov_summary structure to store the profile_info.  */\n+static gcov_summary *afdo_profile_info;\n \n /* Helper functions.  */\n \n@@ -1682,8 +1682,7 @@ read_autofdo_file (void)\n   if (auto_profile_file == NULL)\n     auto_profile_file = DEFAULT_AUTO_PROFILE_FILE;\n \n-  autofdo::afdo_profile_info = (struct gcov_ctr_summary *)xcalloc (\n-      1, sizeof (struct gcov_ctr_summary));\n+  autofdo::afdo_profile_info = XNEW (gcov_summary);\n   autofdo::afdo_profile_info->runs = 1;\n   autofdo::afdo_profile_info->sum_max = 0;\n   autofdo::afdo_profile_info->sum_all = 0;\n@@ -1713,7 +1712,7 @@ afdo_callsite_hot_enough_for_early_inline (struct cgraph_edge *edge)\n   if (count > 0)\n     {\n       bool is_hot;\n-      const struct gcov_ctr_summary *saved_profile_info = profile_info;\n+      const gcov_summary *saved_profile_info = profile_info;\n       /* At early inline stage, profile_info is not set yet. We need to\n          temporarily set it to afdo_profile_info to calculate hotness.  */\n       profile_info = autofdo::afdo_profile_info;"}, {"sha": "84fff1370bf0ab358043270c7824f59188e1a89b", "filename": "gcc/coverage.c", "status": "modified", "additions": 18, "deletions": 31, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -73,7 +73,7 @@ struct counts_entry : pointer_hash <counts_entry>\n   unsigned lineno_checksum;\n   unsigned cfg_checksum;\n   gcov_type *counts;\n-  struct gcov_ctr_summary summary;\n+  gcov_summary summary;\n \n   /* hash_table support.  */\n   static inline hashval_t hash (const counts_entry *);\n@@ -185,7 +185,7 @@ static void\n read_counts_file (void)\n {\n   gcov_unsigned_t fn_ident = 0;\n-  struct gcov_summary summary;\n+  gcov_summary summary;\n   unsigned new_summary = 1;\n   gcov_unsigned_t tag;\n   int is_error = 0;\n@@ -241,27 +241,21 @@ read_counts_file (void)\n       else if (tag == GCOV_TAG_PROGRAM_SUMMARY)\n \t{\n \t  struct gcov_summary sum;\n-\t  unsigned ix;\n \n \t  if (new_summary)\n \t    memset (&summary, 0, sizeof (summary));\n \n \t  gcov_read_summary (&sum);\n-\t  for (ix = 0; ix != GCOV_COUNTERS_SUMMABLE; ix++)\n-\t    {\n-\t      summary.ctrs[ix].runs += sum.ctrs[ix].runs;\n-\t      summary.ctrs[ix].sum_all += sum.ctrs[ix].sum_all;\n-\t      if (summary.ctrs[ix].run_max < sum.ctrs[ix].run_max)\n-\t\tsummary.ctrs[ix].run_max = sum.ctrs[ix].run_max;\n-\t      summary.ctrs[ix].sum_max += sum.ctrs[ix].sum_max;\n-\t    }\n+\t  summary.runs += sum.runs;\n+\t  summary.sum_all += sum.sum_all;\n+\t  if (summary.run_max < sum.run_max)\n+\t    summary.run_max = sum.run_max;\n+\t  summary.sum_max += sum.sum_max;\n           if (new_summary)\n-            memcpy (summary.ctrs[GCOV_COUNTER_ARCS].histogram,\n-                    sum.ctrs[GCOV_COUNTER_ARCS].histogram,\n-                    sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n+\t    memcpy (summary.histogram, sum.histogram,\n+\t\tsizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n           else\n-            gcov_histogram_merge (summary.ctrs[GCOV_COUNTER_ARCS].histogram,\n-                                  sum.ctrs[GCOV_COUNTER_ARCS].histogram);\n+\t    gcov_histogram_merge (summary.histogram, sum.histogram);\n \t  new_summary = 0;\n \t}\n       else if (GCOV_TAG_IS_COUNTER (tag) && fn_ident)\n@@ -282,8 +276,8 @@ read_counts_file (void)\n \t      entry->ctr = elt.ctr;\n \t      entry->lineno_checksum = lineno_checksum;\n \t      entry->cfg_checksum = cfg_checksum;\n-              if (elt.ctr < GCOV_COUNTERS_SUMMABLE)\n-                entry->summary = summary.ctrs[elt.ctr];\n+\t      if (elt.ctr == GCOV_COUNTER_ARCS)\n+\t\tentry->summary = summary;\n               entry->summary.num = n_counts;\n \t      entry->counts = XCNEWVEC (gcov_type, n_counts);\n \t    }\n@@ -306,23 +300,16 @@ read_counts_file (void)\n \t      counts_hash = NULL;\n \t      break;\n \t    }\n-\t  else if (elt.ctr >= GCOV_COUNTERS_SUMMABLE)\n-\t    {\n-\t      error (\"cannot merge separate %s counters for function %u\",\n-\t\t     ctr_names[elt.ctr], fn_ident);\n-\t      goto skip_merge;\n-\t    }\n \t  else\n \t    {\n-\t      entry->summary.runs += summary.ctrs[elt.ctr].runs;\n-\t      entry->summary.sum_all += summary.ctrs[elt.ctr].sum_all;\n-\t      if (entry->summary.run_max < summary.ctrs[elt.ctr].run_max)\n-\t\tentry->summary.run_max = summary.ctrs[elt.ctr].run_max;\n-\t      entry->summary.sum_max += summary.ctrs[elt.ctr].sum_max;\n+\t      entry->summary.runs += summary.runs;\n+\t      entry->summary.sum_all += summary.sum_all;\n+\t      if (entry->summary.run_max < summary.run_max)\n+\t\tentry->summary.run_max = summary.run_max;\n+\t      entry->summary.sum_max += summary.sum_max;\n \t    }\n \t  for (ix = 0; ix != n_counts; ix++)\n \t    entry->counts[ix] += gcov_read_counter ();\n-\tskip_merge:;\n \t}\n       gcov_sync (offset, length);\n       if ((is_error = gcov_is_error ()))\n@@ -345,7 +332,7 @@ read_counts_file (void)\n gcov_type *\n get_coverage_counts (unsigned counter, unsigned expected,\n                      unsigned cfg_checksum, unsigned lineno_checksum,\n-\t\t     const struct gcov_ctr_summary **summary)\n+\t\t     const gcov_summary **summary)\n {\n   counts_entry *entry, elt;\n "}, {"sha": "842d6952c16e5700be7771e27ead964dba1f9a4a", "filename": "gcc/coverage.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fcoverage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fcoverage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.h?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -54,7 +54,7 @@ extern gcov_type *get_coverage_counts (unsigned /*counter*/,\n \t\t\t\t       unsigned /*expected*/,\n \t\t\t\t       unsigned /*cfg_checksum*/,\n \t\t\t\t       unsigned /*lineno_checksum*/,\n-\t\t\t\t       const struct gcov_ctr_summary **);\n+\t\t\t\t       const gcov_summary **);\n \n extern tree get_gcov_type (void);\n extern bool coverage_node_map_initialized_p (void);"}, {"sha": "3ff11a6aa0bec6e6f561489de5b5fc0ba35ff008", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -39,7 +39,7 @@ static void tag_lines (const char *, unsigned, unsigned, unsigned);\n static void tag_counters (const char *, unsigned, unsigned, unsigned);\n static void tag_summary (const char *, unsigned, unsigned, unsigned);\n static void dump_working_sets (const char *filename ATTRIBUTE_UNUSED,\n-\t\t\t       const struct gcov_ctr_summary *summary,\n+\t\t\t       const gcov_summary *summary,\n \t\t\t       unsigned depth);\n extern int main (int, char **);\n \n@@ -467,52 +467,47 @@ tag_summary (const char *filename ATTRIBUTE_UNUSED,\n \t     unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED,\n \t     unsigned depth)\n {\n-  struct gcov_summary summary;\n-  unsigned ix, h_ix;\n+  gcov_summary summary;\n+  unsigned h_ix;\n   gcov_bucket_type *histo_bucket;\n \n   gcov_read_summary (&summary);\n   printf (\" checksum=0x%08x\", summary.checksum);\n \n-  for (ix = 0; ix != GCOV_COUNTERS_SUMMABLE; ix++)\n+  printf (\"\\n\");\n+  print_prefix (filename, depth, 0);\n+  printf (VALUE_PADDING_PREFIX \"counts=%u, runs=%u\",\n+\t  summary.num, summary.runs);\n+\n+  printf (\", sum_all=%\" PRId64,\n+\t  (int64_t)summary.sum_all);\n+  printf (\", run_max=%\" PRId64,\n+\t  (int64_t)summary.run_max);\n+  printf (\", sum_max=%\" PRId64,\n+\t  (int64_t)summary.sum_max);\n+  printf (\"\\n\");\n+  print_prefix (filename, depth, 0);\n+  printf (VALUE_PADDING_PREFIX \"counter histogram:\");\n+  for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n     {\n+      histo_bucket = &summary.histogram[h_ix];\n+      if (!histo_bucket->num_counters)\n+\tcontinue;\n       printf (\"\\n\");\n       print_prefix (filename, depth, 0);\n-      printf (VALUE_PADDING_PREFIX \"counts=%u, runs=%u\",\n-\t      summary.ctrs[ix].num, summary.ctrs[ix].runs);\n-\n-      printf (\", sum_all=%\" PRId64,\n-\t      (int64_t)summary.ctrs[ix].sum_all);\n-      printf (\", run_max=%\" PRId64,\n-\t      (int64_t)summary.ctrs[ix].run_max);\n-      printf (\", sum_max=%\" PRId64,\n-\t      (int64_t)summary.ctrs[ix].sum_max);\n-      if (ix != GCOV_COUNTER_ARCS)\n-        continue;\n-      printf (\"\\n\");\n-      print_prefix (filename, depth, 0);\n-      printf (VALUE_PADDING_PREFIX \"counter histogram:\");\n-      for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n-        {\n-\t  histo_bucket = &summary.ctrs[ix].histogram[h_ix];\n-\t  if (!histo_bucket->num_counters)\n-\t    continue;\n-\t  printf (\"\\n\");\n-\t  print_prefix (filename, depth, 0);\n-\t  printf (VALUE_PADDING_PREFIX VALUE_PREFIX \"num counts=%u, \"\n-\t\t  \"min counter=%\" PRId64 \", cum_counter=%\" PRId64,\n-\t\t  h_ix, histo_bucket->num_counters,\n-\t\t  (int64_t)histo_bucket->min_value,\n-\t\t  (int64_t)histo_bucket->cum_value);\n-        }\n-      if (flag_dump_working_sets)\n-\tdump_working_sets (filename, &summary.ctrs[ix], depth);\n+      printf (VALUE_PADDING_PREFIX VALUE_PREFIX \"num counts=%u, \"\n+\t      \"min counter=%\" PRId64 \", cum_counter=%\" PRId64,\n+\t      h_ix, histo_bucket->num_counters,\n+\t      (int64_t)histo_bucket->min_value,\n+\t      (int64_t)histo_bucket->cum_value);\n     }\n+  if (flag_dump_working_sets)\n+    dump_working_sets (filename, &summary, depth);\n }\n \n static void\n dump_working_sets (const char *filename ATTRIBUTE_UNUSED,\n-\t\t   const struct gcov_ctr_summary *summary,\n+\t\t   const gcov_summary *summary,\n \t\t   unsigned depth)\n {\n   gcov_working_set_t gcov_working_sets[NUM_GCOV_WORKING_SETS];"}, {"sha": "e07ae76420bf321984023ad5b6449fdd23f95c5d", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 67, "deletions": 81, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -446,47 +446,37 @@ gcov_write_tag_length (gcov_unsigned_t tag, gcov_unsigned_t length)\n GCOV_LINKAGE void\n gcov_write_summary (gcov_unsigned_t tag, const struct gcov_summary *summary)\n {\n-  unsigned ix, h_ix, bv_ix, h_cnt = 0;\n-  const struct gcov_ctr_summary *csum;\n+  unsigned h_ix, bv_ix, h_cnt = 0;\n   unsigned histo_bitvector[GCOV_HISTOGRAM_BITVECTOR_SIZE];\n \n   /* Count number of non-zero histogram entries, and fill in a bit vector\n      of non-zero indices. The histogram is only currently computed for arc\n      counters.  */\n   for (bv_ix = 0; bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE; bv_ix++)\n     histo_bitvector[bv_ix] = 0;\n-  csum = &summary->ctrs[GCOV_COUNTER_ARCS];\n   for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n-    if (csum->histogram[h_ix].num_counters)\n+    if (summary->histogram[h_ix].num_counters)\n       {\n \thisto_bitvector[h_ix / 32] |= 1 << (h_ix % 32);\n \th_cnt++;\n       }\n   gcov_write_tag_length (tag, GCOV_TAG_SUMMARY_LENGTH (h_cnt));\n   gcov_write_unsigned (summary->checksum);\n-  for (csum = summary->ctrs, ix = GCOV_COUNTERS_SUMMABLE; ix--; csum++)\n+\n+  gcov_write_unsigned (summary->num);\n+  gcov_write_unsigned (summary->runs);\n+  gcov_write_counter (summary->sum_all);\n+  gcov_write_counter (summary->run_max);\n+  gcov_write_counter (summary->sum_max);\n+  for (bv_ix = 0; bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE; bv_ix++)\n+    gcov_write_unsigned (histo_bitvector[bv_ix]);\n+  for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n     {\n-      gcov_write_unsigned (csum->num);\n-      gcov_write_unsigned (csum->runs);\n-      gcov_write_counter (csum->sum_all);\n-      gcov_write_counter (csum->run_max);\n-      gcov_write_counter (csum->sum_max);\n-      if (ix != GCOV_COUNTER_ARCS)\n-        {\n-          for (bv_ix = 0; bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE; bv_ix++)\n-            gcov_write_unsigned (0);\n-          continue;\n-        }\n-      for (bv_ix = 0; bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE; bv_ix++)\n-        gcov_write_unsigned (histo_bitvector[bv_ix]);\n-      for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n-        {\n-          if (!csum->histogram[h_ix].num_counters)\n-            continue;\n-          gcov_write_unsigned (csum->histogram[h_ix].num_counters);\n-          gcov_write_counter (csum->histogram[h_ix].min_value);\n-          gcov_write_counter (csum->histogram[h_ix].cum_value);\n-        }\n+      if (!summary->histogram[h_ix].num_counters)\n+\tcontinue;\n+      gcov_write_unsigned (summary->histogram[h_ix].num_counters);\n+      gcov_write_counter (summary->histogram[h_ix].min_value);\n+      gcov_write_counter (summary->histogram[h_ix].cum_value);\n     }\n }\n #endif /* IN_LIBGCOV */\n@@ -598,68 +588,64 @@ gcov_read_string (void)\n GCOV_LINKAGE void\n gcov_read_summary (struct gcov_summary *summary)\n {\n-  unsigned ix, h_ix, bv_ix, h_cnt = 0;\n-  struct gcov_ctr_summary *csum;\n+  unsigned h_ix, bv_ix, h_cnt = 0;\n   unsigned histo_bitvector[GCOV_HISTOGRAM_BITVECTOR_SIZE];\n   unsigned cur_bitvector;\n \n   summary->checksum = gcov_read_unsigned ();\n-  for (csum = summary->ctrs, ix = GCOV_COUNTERS_SUMMABLE; ix--; csum++)\n+  summary->num = gcov_read_unsigned ();\n+  summary->runs = gcov_read_unsigned ();\n+  summary->sum_all = gcov_read_counter ();\n+  summary->run_max = gcov_read_counter ();\n+  summary->sum_max = gcov_read_counter ();\n+  memset (summary->histogram, 0,\n+\t  sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n+  for (bv_ix = 0; bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE; bv_ix++)\n     {\n-      csum->num = gcov_read_unsigned ();\n-      csum->runs = gcov_read_unsigned ();\n-      csum->sum_all = gcov_read_counter ();\n-      csum->run_max = gcov_read_counter ();\n-      csum->sum_max = gcov_read_counter ();\n-      memset (csum->histogram, 0,\n-              sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n-      for (bv_ix = 0; bv_ix < GCOV_HISTOGRAM_BITVECTOR_SIZE; bv_ix++)\n-        {\n-          histo_bitvector[bv_ix] = gcov_read_unsigned ();\n+      histo_bitvector[bv_ix] = gcov_read_unsigned ();\n #if IN_LIBGCOV\n-          /* When building libgcov we don't include system.h, which includes\n-             hwint.h (where popcount_hwi is declared). However, libgcov.a\n-             is built by the bootstrapped compiler and therefore the builtins\n-             are always available.  */\n-          h_cnt += __builtin_popcount (histo_bitvector[bv_ix]);\n+      /* When building libgcov we don't include system.h, which includes\n+\t hwint.h (where popcount_hwi is declared). However, libgcov.a\n+\t is built by the bootstrapped compiler and therefore the builtins\n+\t are always available.  */\n+      h_cnt += __builtin_popcount (histo_bitvector[bv_ix]);\n #else\n-          h_cnt += popcount_hwi (histo_bitvector[bv_ix]);\n+      h_cnt += popcount_hwi (histo_bitvector[bv_ix]);\n #endif\n-        }\n-      bv_ix = 0;\n-      h_ix = 0;\n-      cur_bitvector = 0;\n-      while (h_cnt--)\n-        {\n-          /* Find the index corresponding to the next entry we will read in.\n-             First find the next non-zero bitvector and re-initialize\n-             the histogram index accordingly, then right shift and increment\n-             the index until we find a set bit.  */\n-          while (!cur_bitvector)\n-            {\n-              h_ix = bv_ix * 32;\n-              if (bv_ix >= GCOV_HISTOGRAM_BITVECTOR_SIZE)\n-                gcov_error (\"corrupted profile info: summary histogram \"\n-                            \"bitvector is corrupt\");\n-              cur_bitvector = histo_bitvector[bv_ix++];\n-            }\n-          while (!(cur_bitvector & 0x1))\n-            {\n-              h_ix++;\n-              cur_bitvector >>= 1;\n-            }\n-          if (h_ix >= GCOV_HISTOGRAM_SIZE)\n-            gcov_error (\"corrupted profile info: summary histogram \"\n-                        \"index is corrupt\");\n-\n-          csum->histogram[h_ix].num_counters = gcov_read_unsigned ();\n-          csum->histogram[h_ix].min_value = gcov_read_counter ();\n-          csum->histogram[h_ix].cum_value = gcov_read_counter ();\n-          /* Shift off the index we are done with and increment to the\n-             corresponding next histogram entry.  */\n-          cur_bitvector >>= 1;\n-          h_ix++;\n-        }\n+    }\n+  bv_ix = 0;\n+  h_ix = 0;\n+  cur_bitvector = 0;\n+  while (h_cnt--)\n+    {\n+      /* Find the index corresponding to the next entry we will read in.\n+\t First find the next non-zero bitvector and re-initialize\n+\t the histogram index accordingly, then right shift and increment\n+\t the index until we find a set bit.  */\n+      while (!cur_bitvector)\n+\t{\n+\t  h_ix = bv_ix * 32;\n+\t  if (bv_ix >= GCOV_HISTOGRAM_BITVECTOR_SIZE)\n+\t    gcov_error (\"corrupted profile info: summary histogram \"\n+\t\t\t\"bitvector is corrupt\");\n+\t  cur_bitvector = histo_bitvector[bv_ix++];\n+\t}\n+      while (!(cur_bitvector & 0x1))\n+\t{\n+\t  h_ix++;\n+\t  cur_bitvector >>= 1;\n+\t}\n+      if (h_ix >= GCOV_HISTOGRAM_SIZE)\n+\tgcov_error (\"corrupted profile info: summary histogram \"\n+\t\t    \"index is corrupt\");\n+\n+      summary->histogram[h_ix].num_counters = gcov_read_unsigned ();\n+      summary->histogram[h_ix].min_value = gcov_read_counter ();\n+      summary->histogram[h_ix].cum_value = gcov_read_counter ();\n+      /* Shift off the index we are done with and increment to the\n+\t corresponding next histogram entry.  */\n+      cur_bitvector >>= 1;\n+      h_ix++;\n     }\n }\n \n@@ -921,7 +907,7 @@ static void gcov_histogram_merge (gcov_bucket_type *tgt_histo,\n    the minimum counter value in that working set.  */\n \n GCOV_LINKAGE void\n-compute_working_sets (const struct gcov_ctr_summary *summary,\n+compute_working_sets (const gcov_summary *summary,\n                       gcov_working_set_t *gcov_working_sets)\n {\n   gcov_type working_set_cum_values[NUM_GCOV_WORKING_SETS];"}, {"sha": "56391defab36be0173d6f4c23c99bb927625db88", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -140,9 +140,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \t\tint32:lineno_checksum int32:cfg_checksum\n \tpresent: header int32:present\n \tcounts: header int64:count*\n-\tsummary: int32:checksum {count-summary}GCOV_COUNTERS_SUMMABLE\n-\tcount-summary:\tint32:num int32:runs int64:sum\n-\t\t\tint64:max int64:sum_max histogram\n+\tsummary: int32:checksum int32:num int32:runs int64:sum\n+\t\t int64:max int64:sum_max histogram\n         histogram: {int32:bitvector}8 histogram-buckets*\n         histogram-buckets: int32:num int64:min int64:sum\n \n@@ -243,8 +242,7 @@ typedef uint64_t gcov_type_unsigned;\n #define GCOV_TAG_COUNTER_NUM(LENGTH) ((LENGTH) / 2)\n #define GCOV_TAG_OBJECT_SUMMARY  ((gcov_unsigned_t)0xa1000000) /* Obsolete */\n #define GCOV_TAG_PROGRAM_SUMMARY ((gcov_unsigned_t)0xa3000000)\n-#define GCOV_TAG_SUMMARY_LENGTH(NUM)  \\\n-        (1 + GCOV_COUNTERS_SUMMABLE * (10 + 3 * 2) + (NUM) * 5)\n+#define GCOV_TAG_SUMMARY_LENGTH(NUM) (1 + (10 + 3 * 2) + (NUM) * 5)\n #define GCOV_TAG_AFDO_FILE_NAMES ((gcov_unsigned_t)0xaa000000)\n #define GCOV_TAG_AFDO_FUNCTION ((gcov_unsigned_t)0xac000000)\n #define GCOV_TAG_AFDO_WORKING_SET ((gcov_unsigned_t)0xaf000000)\n@@ -259,13 +257,10 @@ GCOV_COUNTERS\n };\n #undef DEF_GCOV_COUNTER\n \n-/* Counters which can be summaried.  */\n-#define GCOV_COUNTERS_SUMMABLE\t(GCOV_COUNTER_ARCS + 1)\n-\n /* The first of counters used for value profiling.  They must form a\n    consecutive interval and their order must match the order of\n    HIST_TYPEs in value-prof.h.  */\n-#define GCOV_FIRST_VALUE_COUNTER GCOV_COUNTERS_SUMMABLE\n+#define GCOV_FIRST_VALUE_COUNTER GCOV_COUNTER_V_INTERVAL\n \n /* The last of counters used for value profiling.  */\n #define GCOV_LAST_VALUE_COUNTER (GCOV_COUNTERS - 1)\n@@ -337,23 +332,18 @@ typedef struct\n    This is essentially a ceiling divide by 32 bits.  */\n #define GCOV_HISTOGRAM_BITVECTOR_SIZE (GCOV_HISTOGRAM_SIZE + 31) / 32\n \n-/* Cumulative counter data.  */\n-struct gcov_ctr_summary\n-{\n-  gcov_unsigned_t num;\t\t/* number of counters.  */\n-  gcov_unsigned_t runs;\t\t/* number of program runs */\n-  gcov_type sum_all;\t\t/* sum of all counters accumulated.  */\n-  gcov_type run_max;\t\t/* maximum value on a single run.  */\n-  gcov_type sum_max;    \t/* sum of individual run max values.  */\n-  gcov_bucket_type histogram[GCOV_HISTOGRAM_SIZE]; /* histogram of\n-                                                      counter values.  */\n-};\n-\n /* Object & program summary record.  */\n+\n struct gcov_summary\n {\n-  gcov_unsigned_t checksum;\t/* checksum of program */\n-  struct gcov_ctr_summary ctrs[GCOV_COUNTERS_SUMMABLE];\n+  gcov_unsigned_t checksum;\t/* Checksum of program.  */\n+  gcov_unsigned_t num;\t\t/* Number of counters.  */\n+  gcov_unsigned_t runs;\t\t/* Number of program runs.  */\n+  gcov_type sum_all;\t\t/* Sum of all counters accumulated.  */\n+  gcov_type run_max;\t\t/* Maximum value on a single run.  */\n+  gcov_type sum_max;    \t/* Sum of individual run max values.  */\n+  gcov_bucket_type histogram[GCOV_HISTOGRAM_SIZE]; /* Histogram of\n+\t\t\t\t\t\t      counter values.  */\n };\n \n #if !defined(inhibit_libc)\n@@ -414,7 +404,7 @@ typedef struct gcov_working_set_info\n   gcov_type min_counter;\n } gcov_working_set_t;\n \n-GCOV_LINKAGE void compute_working_sets (const struct gcov_ctr_summary *summary,\n+GCOV_LINKAGE void compute_working_sets (const gcov_summary *summary,\n                                         gcov_working_set_t *gcov_working_sets);\n #endif\n "}, {"sha": "2114a43d14082171783fa3db00f0d574807004d0", "filename": "gcc/gcov.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -1801,7 +1801,7 @@ read_count_file (void)\n \t{\n \t  struct gcov_summary summary;\n \t  gcov_read_summary (&summary);\n-\t  object_runs += summary.ctrs[GCOV_COUNTER_ARCS].runs;\n+\t  object_runs += summary.runs;\n \t  program_count++;\n \t}\n       else if (tag == GCOV_TAG_FUNCTION && !length)"}, {"sha": "8439babc4fedba4ddf3b5a75049811b7e5955f87", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -1657,7 +1657,7 @@ input_refs (struct lto_input_block *ib,\n }\n \t    \n \n-static struct gcov_ctr_summary lto_gcov_summary;\n+static gcov_summary lto_gcov_summary;\n \n /* Input profile_info from IB.  */\n static void\n@@ -1715,7 +1715,7 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n   struct cgraph_node *node;\n   struct cgraph_edge *edge;\n   gcov_type saved_sum_all = 0;\n-  gcov_ctr_summary *saved_profile_info = 0;\n+  gcov_summary *saved_profile_info = 0;\n   int saved_scale = 0;\n \n   /* Find unit with maximal number of runs.  If we ever get serious about"}, {"sha": "025929fe56009091df0bc52695df681e156f468d", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -582,7 +582,7 @@ struct GTY(()) lto_file_decl_data\n   vec<res_pair>  GTY((skip)) respairs;\n   unsigned max_index;\n \n-  struct gcov_ctr_summary GTY((skip)) profile_info;\n+  gcov_summary GTY((skip)) profile_info;\n \n   /* Map assigning declarations their resolutions.  */\n   hash_map<tree, ld_plugin_symbol_resolution> * GTY((skip)) resolution_map;"}, {"sha": "8ba6dc7baec8d475cb6cdbd2d1ae8b30785c2c6b", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -84,7 +84,7 @@ struct bb_profile_info {\n \n /* Counter summary from the last set of coverage counts read.  */\n \n-const struct gcov_ctr_summary *profile_info;\n+const gcov_summary *profile_info;\n \n /* Counter working set information computed from the current counter\n    summary. Not initialized unless profile_info summary is non-NULL.  */"}, {"sha": "6b37bb6f3df5ee989795d7f5eb0873cfd58bf695", "filename": "gcc/profile.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fprofile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/gcc%2Fprofile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.h?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -75,6 +75,6 @@ extern void get_working_sets (void);\n \n /* Counter summary from the last set of coverage counts read by\n    profile.c.  */\n-extern const struct gcov_ctr_summary *profile_info;\n+extern const struct gcov_summary *profile_info;\n \n #endif /* PROFILE_H */"}, {"sha": "f2297c0a369b1d5b3985d63770dd3fed532299e1", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -1,3 +1,16 @@\n+2018-06-05  Martin Liska  <mliska@suse.cz>\n+\n+\t* libgcov-driver.c (gcov_compute_histogram): Remove usage\n+\tof gcov_ctr_summary.\n+\t(compute_summary): Do it just for a single summary.\n+\t(merge_one_data): Likewise.\n+\t(merge_summary): Simplify as we read just single summary.\n+\t(dump_one_gcov): Pass proper argument.\n+\t* libgcov-util.c (compute_one_gcov): Simplify as we have just\n+\tsingle summary.\n+\t(gcov_info_count_all_cold): Likewise.\n+\t(calculate_overlap): Likewise.\n+\n 2018-06-02  Chung-Ju Wu  <jasonwucj@gmail.com>\n \t    Monk Chiang  <sh.chiang04@gmail.com>\n "}, {"sha": "922d9dde8334cabfa88f38ea6a4f11006b36dfe7", "filename": "libgcc/libgcov-driver.c", "status": "modified", "additions": 68, "deletions": 111, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -221,50 +221,34 @@ gcov_compute_histogram (struct gcov_info *list, struct gcov_summary *sum)\n   struct gcov_info *gi_ptr;\n   const struct gcov_fn_info *gfi_ptr;\n   const struct gcov_ctr_info *ci_ptr;\n-  struct gcov_ctr_summary *cs_ptr;\n-  unsigned t_ix, f_ix, ctr_info_ix, ix;\n+  unsigned f_ix, ix;\n   int h_ix;\n \n-  /* This currently only applies to arc counters.  */\n-  t_ix = GCOV_COUNTER_ARCS;\n-\n   /* First check if there are any counts recorded for this counter.  */\n-  cs_ptr = &(sum->ctrs[t_ix]);\n-  if (!cs_ptr->num)\n+  if (!sum->num)\n     return;\n \n   for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n     {\n-      cs_ptr->histogram[h_ix].num_counters = 0;\n-      cs_ptr->histogram[h_ix].min_value = cs_ptr->run_max;\n-      cs_ptr->histogram[h_ix].cum_value = 0;\n+      sum->histogram[h_ix].num_counters = 0;\n+      sum->histogram[h_ix].min_value = sum->run_max;\n+      sum->histogram[h_ix].cum_value = 0;\n     }\n \n   /* Walk through all the per-object structures and record each of\n      the count values in histogram.  */\n   for (gi_ptr = list; gi_ptr; gi_ptr = gi_ptr->next)\n     {\n-      if (!gi_ptr->merge[t_ix])\n-        continue;\n-\n-      /* Find the appropriate index into the gcov_ctr_info array\n-         for the counter we are currently working on based on the\n-         existence of the merge function pointer for this object.  */\n-      for (ix = 0, ctr_info_ix = 0; ix < t_ix; ix++)\n-        {\n-          if (gi_ptr->merge[ix])\n-            ctr_info_ix++;\n-        }\n       for (f_ix = 0; f_ix != gi_ptr->n_functions; f_ix++)\n         {\n           gfi_ptr = gi_ptr->functions[f_ix];\n \n           if (!gfi_ptr || gfi_ptr->key != gi_ptr)\n             continue;\n \n-          ci_ptr = &gfi_ptr->ctrs[ctr_info_ix];\n-          for (ix = 0; ix < ci_ptr->num; ix++)\n-            gcov_histogram_insert (cs_ptr->histogram, ci_ptr->values[ix]);\n+\t  ci_ptr = &gfi_ptr->ctrs[0];\n+\t  for (ix = 0; ix < ci_ptr->num; ix++)\n+\t    gcov_histogram_insert (sum->histogram, ci_ptr->values[ix]);\n         }\n     }\n }\n@@ -287,10 +271,8 @@ compute_summary (struct gcov_info *list, struct gcov_summary *this_prg,\n {\n   struct gcov_info *gi_ptr;\n   const struct gcov_fn_info *gfi_ptr;\n-  struct gcov_ctr_summary *cs_ptr;\n   const struct gcov_ctr_info *ci_ptr;\n   int f_ix;\n-  unsigned t_ix;\n   gcov_unsigned_t c_num;\n   gcov_unsigned_t crc32 = 0;\n \n@@ -319,25 +301,18 @@ compute_summary (struct gcov_info *list, struct gcov_summary *this_prg,\n           if (!gfi_ptr)\n             continue;\n \n-          ci_ptr = gfi_ptr->ctrs;\n-          for (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)\n-            {\n-              if (!gi_ptr->merge[t_ix])\n-                continue;\n-\n-              cs_ptr = &(this_prg->ctrs[t_ix]);\n-              cs_ptr->num += ci_ptr->num;\n-              crc32 = crc32_unsigned (crc32, ci_ptr->num);\n-\n-              for (c_num = 0; c_num < ci_ptr->num; c_num++)\n-                {\n-                  cs_ptr->sum_all += ci_ptr->values[c_num];\n-                  if (cs_ptr->run_max < ci_ptr->values[c_num])\n-                    cs_ptr->run_max = ci_ptr->values[c_num];\n-                }\n-              ci_ptr++;\n-            }\n-        }\n+\t  ci_ptr = gfi_ptr->ctrs;\n+\t  this_prg->num += ci_ptr->num;\n+\t  crc32 = crc32_unsigned (crc32, ci_ptr->num);\n+\n+\t  for (c_num = 0; c_num < ci_ptr->num; c_num++)\n+\t    {\n+\t      this_prg->sum_all += ci_ptr->values[c_num];\n+\t      if (this_prg->run_max < ci_ptr->values[c_num])\n+\t\tthis_prg->run_max = ci_ptr->values[c_num];\n+\t    }\n+\t  ci_ptr++;\n+\t}\n     }\n   gcov_compute_histogram (list, this_prg);\n   return crc32;\n@@ -411,9 +386,8 @@ merge_one_data (const char *filename,\n       if (tmp.checksum != crc32)\n         goto next_summary;\n \n-      for (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)\n-        if (tmp.ctrs[t_ix].num != this_prg->ctrs[t_ix].num)\n-          goto next_summary;\n+      if (tmp.num != this_prg->num)\n+\tgoto next_summary;\n       *prg_p = tmp;\n       *summary_pos_p = *eof_pos_p;\n \n@@ -600,77 +574,60 @@ write_one_data (const struct gcov_info *gi_ptr,\n    Return -1 on error. Return 0 on success.  */\n \n static int\n-merge_summary (const char *filename, int run_counted,\n-\t       const struct gcov_info *gi_ptr, struct gcov_summary *prg,\n+merge_summary (const char *filename __attribute__ ((unused)), int run_counted,\n+\t       struct gcov_summary *prg,\n \t       struct gcov_summary *this_prg, gcov_unsigned_t crc32,\n \t       struct gcov_summary *all_prg __attribute__ ((unused)))\n {\n-  struct gcov_ctr_summary *cs_prg, *cs_tprg;\n-  unsigned t_ix;\n #if !GCOV_LOCKED \n   /* summary for all instances of program.  */ \n-  struct gcov_ctr_summary *cs_all;\n+  struct gcov_summary *cs_all;\n #endif \n \n-  /* Merge the summaries.  */\n-  for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n-    {\n-      cs_prg = &(prg->ctrs[t_ix]);\n-      cs_tprg = &(this_prg->ctrs[t_ix]);\n-\n-      if (gi_ptr->merge[t_ix])\n-        {\n-\t  int first = !cs_prg->runs;\n-\n-\t  if (!run_counted)\n-\t    cs_prg->runs++;\n-          if (first)\n-            cs_prg->num = cs_tprg->num;\n-          cs_prg->sum_all += cs_tprg->sum_all;\n-          if (cs_prg->run_max < cs_tprg->run_max)\n-            cs_prg->run_max = cs_tprg->run_max;\n-          cs_prg->sum_max += cs_tprg->run_max;\n-          if (first)\n-            memcpy (cs_prg->histogram, cs_tprg->histogram,\n-                   sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n-          else\n-            gcov_histogram_merge (cs_prg->histogram, cs_tprg->histogram);\n-        }\n-      else if (cs_prg->runs)\n-        {\n-          gcov_error (\"profiling:%s:Merge mismatch for summary.\\n\",\n-                      filename);\n-          return -1;\n-        }\n+  /* Merge the summary.  */\n+  int first = !prg->runs;\n+\n+  if (!run_counted)\n+    prg->runs++;\n+  if (first)\n+    prg->num = this_prg->num;\n+  prg->sum_all += this_prg->sum_all;\n+  if (prg->run_max < this_prg->run_max)\n+    prg->run_max = this_prg->run_max;\n+  prg->sum_max += this_prg->run_max;\n+  if (first)\n+    memcpy (prg->histogram, this_prg->histogram,\n+\t    sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n+  else\n+    gcov_histogram_merge (prg->histogram, this_prg->histogram);\n #if !GCOV_LOCKED\n-      cs_all = &all_prg->ctrs[t_ix];\n-      if (!cs_all->runs && cs_prg->runs)\n-        {\n-          cs_all->num = cs_prg->num;\n-          cs_all->runs = cs_prg->runs;\n-          cs_all->sum_all = cs_prg->sum_all;\n-          cs_all->run_max = cs_prg->run_max;\n-          cs_all->sum_max = cs_prg->sum_max;\n-        }\n-      else if (!all_prg->checksum\n-               /* Don't compare the histograms, which may have slight\n-                  variations depending on the order they were updated\n-                  due to the truncating integer divides used in the\n-                  merge.  */\n-               && (cs_all->num != cs_prg->num\n-                   || cs_all->runs != cs_prg->runs\n-                   || cs_all->sum_all != cs_prg->sum_all\n-                   || cs_all->run_max != cs_prg->run_max\n-                   || cs_all->sum_max != cs_prg->sum_max))\n-             {\n-               gcov_error (\"profiling:%s:Data file mismatch - some \"\n-                           \"data files may have been concurrently \"\n-                           \"updated without locking support\\n\", filename);\n-               all_prg->checksum = ~0u;\n-             }\n-#endif\n+  all = &all_prg->ctrs[t_ix];\n+  if (!all->runs && prg->runs)\n+    {\n+      all->num = prg->num;\n+      all->runs = prg->runs;\n+      all->sum_all = prg->sum_all;\n+      all->run_max = prg->run_max;\n+      all->sum_max = prg->sum_max;\n     }\n-  \n+  else if (!all_prg->checksum\n+\t   /* Don't compare the histograms, which may have slight\n+\t      variations depending on the order they were updated\n+\t      due to the truncating integer divides used in the\n+\t      merge.  */\n+\t   && (all->num != prg->num\n+\t       || all->runs != prg->runs\n+\t       || all->sum_all != prg->sum_all\n+\t       || all->run_max != prg->run_max\n+\t       || all->sum_max != prg->sum_max))\n+    {\n+      gcov_error (\"profiling:%s:Data file mismatch - some \"\n+\t\t  \"data files may have been concurrently \"\n+\t\t  \"updated without locking support\\n\", filename);\n+      all_prg->checksum = ~0u;\n+    }\n+#endif\n+\n   prg->checksum = crc32;\n \n   return 0;\n@@ -806,7 +763,7 @@ dump_one_gcov (struct gcov_info *gi_ptr, struct gcov_filename *gf,\n       summary_pos = eof_pos;\n     }\n \n-  error = merge_summary (gf->filename, run_counted, gi_ptr, &prg, this_prg,\n+  error = merge_summary (gf->filename, run_counted, &prg, this_prg,\n \t\t\t crc32, all_prg);\n   if (error == -1)\n     goto read_fatal;"}, {"sha": "1d26176940b24b18a2abcdb60f84d579f4f517be", "filename": "libgcc/libgcov-util.c", "status": "modified", "additions": 29, "deletions": 61, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f3577f5285957c1aa48823ce6c691f8c212b219/libgcc%2Flibgcov-util.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f3577f5285957c1aa48823ce6c691f8c212b219/libgcc%2Flibgcov-util.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-util.c?ref=7f3577f5285957c1aa48823ce6c691f8c212b219", "patch": "@@ -930,32 +930,20 @@ compute_one_gcov (const struct gcov_info *gcov_info1,\n   {\n     for (f_ix = 0; f_ix < gcov_info->n_functions; f_ix++)\n       {\n-        unsigned t_ix;\n         const struct gcov_fn_info *gfi_ptr = gcov_info->functions[f_ix];\n         if (!gfi_ptr || gfi_ptr->key != gcov_info)\n           continue;\n         const struct gcov_ctr_info *ci_ptr = gfi_ptr->ctrs;\n-        for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n-          {\n-            unsigned c_num;\n-\n-            if (!gcov_info->merge[t_ix])\n-              continue;\n-\n-            for (c_num = 0; c_num < ci_ptr->num; c_num++)\n-              {\n-                cum_1 += ci_ptr->values[c_num] / sum;\n-              }\n-            ci_ptr++;\n-          }\n+\tunsigned c_num;\n+\tfor (c_num = 0; c_num < ci_ptr->num; c_num++)\n+\t  cum_1 += ci_ptr->values[c_num] / sum;\n       }\n     *cum_p = cum_1;\n     return 0.0;\n   }\n \n   for (f_ix = 0; f_ix < gcov_info1->n_functions; f_ix++)\n     {\n-      unsigned t_ix;\n       double func_cum_1 = 0.0;\n       double func_cum_2 = 0.0;\n       double func_val = 0.0;\n@@ -971,32 +959,24 @@ compute_one_gcov (const struct gcov_info *gcov_info1,\n \n       const struct gcov_ctr_info *ci_ptr1 = gfi_ptr1->ctrs;\n       const struct gcov_ctr_info *ci_ptr2 = gfi_ptr2->ctrs;\n-      for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n-        {\n-          unsigned c_num;\n+      unsigned c_num;\n+      for (c_num = 0; c_num < ci_ptr1->num; c_num++)\n+\t{\n+\t  if (ci_ptr1->values[c_num] | ci_ptr2->values[c_num])\n+\t    {\n+\t      func_val += calculate_2_entries (ci_ptr1->values[c_num],\n+\t\t\t\t\t       ci_ptr2->values[c_num],\n+\t\t\t\t\t       sum_1, sum_2);\n+\n+\t      func_cum_1 += ci_ptr1->values[c_num] / sum_1;\n+\t      func_cum_2 += ci_ptr2->values[c_num] / sum_2;\n+\t      nonzero = 1;\n+\t      if (ci_ptr1->values[c_num] / sum_1 >= overlap_hot_threshold\n+\t\t  || ci_ptr2->values[c_num] / sum_2 >= overlap_hot_threshold)\n+\t\thot = 1;\n+\t    }\n+\t}\n \n-          if (!gcov_info1->merge[t_ix])\n-            continue;\n-\n-          for (c_num = 0; c_num < ci_ptr1->num; c_num++)\n-            {\n-              if (ci_ptr1->values[c_num] | ci_ptr2->values[c_num])\n-                {\n-                  func_val += calculate_2_entries (ci_ptr1->values[c_num],\n-                                          ci_ptr2->values[c_num],\n-                                          sum_1, sum_2);\n-\n-                  func_cum_1 += ci_ptr1->values[c_num] / sum_1;\n-                  func_cum_2 += ci_ptr2->values[c_num] / sum_2;\n-                  nonzero = 1;\n-                  if (ci_ptr1->values[c_num] / sum_1 >= overlap_hot_threshold ||\n-                      ci_ptr2->values[c_num] / sum_2 >= overlap_hot_threshold)\n-                    hot = 1;\n-                }\n-            }\n-          ci_ptr1++;\n-          ci_ptr2++;\n-        }\n       ret += func_val;\n       cum_1 += func_cum_1;\n       cum_2 += func_cum_2;\n@@ -1023,26 +1003,14 @@ gcov_info_count_all_cold (const struct gcov_info *gcov_info,\n \n   for (f_ix = 0; f_ix < gcov_info->n_functions; f_ix++)\n     {\n-      unsigned t_ix;\n       const struct gcov_fn_info *gfi_ptr = gcov_info->functions[f_ix];\n \n       if (!gfi_ptr || gfi_ptr->key != gcov_info)\n         continue;\n       const struct gcov_ctr_info *ci_ptr = gfi_ptr->ctrs;\n-      for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n-        {\n-          unsigned c_num;\n-\n-          if (!gcov_info->merge[t_ix])\n-            continue;\n-\n-          for (c_num = 0; c_num < ci_ptr->num; c_num++)\n-            {\n-              if (ci_ptr->values[c_num] > threshold)\n-                return false;\n-            }\n-          ci_ptr++;\n-        }\n+      for (unsigned c_num = 0; c_num < ci_ptr->num; c_num++)\n+\tif (ci_ptr->values[c_num] > threshold)\n+\t  return false;\n     }\n \n   return true;\n@@ -1252,13 +1220,13 @@ calculate_overlap (struct gcov_info *gcov_list1,\n   struct overlap_t *all_infos;\n \n   compute_summary (gcov_list1, &this_prg, &max_length);\n-  overlap_sum_1 = (double) (this_prg.ctrs[0].sum_all);\n-  p1_sum_all = this_prg.ctrs[0].sum_all;\n-  p1_run_max = this_prg.ctrs[0].run_max;\n+  overlap_sum_1 = (double) (this_prg.sum_all);\n+  p1_sum_all = this_prg.sum_all;\n+  p1_run_max = this_prg.run_max;\n   compute_summary (gcov_list2, &this_prg, &max_length);\n-  overlap_sum_2 = (double) (this_prg.ctrs[0].sum_all);\n-  p2_sum_all = this_prg.ctrs[0].sum_all;\n-  p2_run_max = this_prg.ctrs[0].run_max;\n+  overlap_sum_2 = (double) (this_prg.sum_all);\n+  p2_sum_all = this_prg.sum_all;\n+  p2_run_max = this_prg.run_max;\n \n   for (gi_ptr = gcov_list1; gi_ptr; gi_ptr = gi_ptr->next)\n     list1_cnt++;"}]}