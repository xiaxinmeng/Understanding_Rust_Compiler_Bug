{"sha": "e230f11e9784eefed316df7dbc5df6ac999841b2", "node_id": "C_kwDOANBUbNoAKGUyMzBmMTFlOTc4NGVlZmVkMzE2ZGY3ZGJjNWRmNmFjOTk5ODQxYjI", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2022-09-09T13:17:21Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2022-09-09T13:17:21Z"}, "message": "Handle OPAQUE_TYPE specially in verify_type [PR106833]\n\nAs PR106833 shows, cv-qualified opaque type can cause ICE\nduring LTO.  It exposes that we missd to handle OPAQUE_TYPE\nwell in type verification.  As Richi pointed out, also\nassuming that target will always define TYPE_MAIN_VARIANT\nTYPE_CANONICAL for opaque type, this patch is to check\nboth are OPAQUE_TYPE_P and their modes are of MODE_OPAQUE\nclass.  Besides, it also checks the only available size\nand alignment information.\n\n\tPR middle-end/106833\n\ngcc/ChangeLog:\n\n\t* tree.cc (verify_opaque_type): New function.\n\t(verify_type): Call verify_opaque_type for OPAQUE_TYPE.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/powerpc/pr106833.c: New test.", "tree": {"sha": "c7f2407f148538c7fe4305e29d2d4839a0255b35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7f2407f148538c7fe4305e29d2d4839a0255b35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e230f11e9784eefed316df7dbc5df6ac999841b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e230f11e9784eefed316df7dbc5df6ac999841b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e230f11e9784eefed316df7dbc5df6ac999841b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e230f11e9784eefed316df7dbc5df6ac999841b2/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eff73c104a3db882f3bc7f567f322e40470c7571", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff73c104a3db882f3bc7f567f322e40470c7571", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eff73c104a3db882f3bc7f567f322e40470c7571"}], "stats": {"total": 88, "additions": 87, "deletions": 1}, "files": [{"sha": "968d75184ff3763d45fb2199e6a0bf42d082720a", "filename": "gcc/testsuite/gcc.target/powerpc/pr106833.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e230f11e9784eefed316df7dbc5df6ac999841b2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr106833.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e230f11e9784eefed316df7dbc5df6ac999841b2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr106833.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr106833.c?ref=e230f11e9784eefed316df7dbc5df6ac999841b2", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do link } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-require-effective-target lto } */\n+/* { dg-options \"-flto -mdejagnu-cpu=power10\" } */\n+\n+/* Verify there is no ICE in LTO mode.  */\n+\n+int main ()\n+{\n+  float *b;\n+  const __vector_quad c;\n+  __builtin_mma_disassemble_acc (b, &c);\n+  return 0;\n+}"}, {"sha": "0546c8f402569adcd3692e4e61a13ba5978aba07", "filename": "gcc/tree.cc", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e230f11e9784eefed316df7dbc5df6ac999841b2/gcc%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e230f11e9784eefed316df7dbc5df6ac999841b2/gcc%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.cc?ref=e230f11e9784eefed316df7dbc5df6ac999841b2", "patch": "@@ -13680,13 +13680,86 @@ gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n     }\n }\n \n+/* For OPAQUE_TYPE T, it should have only size and alignment information\n+   and its mode should be of class MODE_OPAQUE.  This function verifies\n+   these properties of T match TV which is the main variant of T and TC\n+   which is the canonical of T.  */\n+\n+static void\n+verify_opaque_type (const_tree t, tree tv, tree tc)\n+{\n+  gcc_assert (OPAQUE_TYPE_P (t));\n+  gcc_assert (tv && tv == TYPE_MAIN_VARIANT (tv));\n+  gcc_assert (tc && tc == TYPE_CANONICAL (tc));\n+\n+  /* For an opaque type T1, check if some of its properties match\n+     the corresponding ones of the other opaque type T2, emit some\n+     error messages for those inconsistent ones.  */\n+  auto check_properties_for_opaque_type = [](const_tree t1, tree t2,\n+\t\t\t\t\t     const char *kind_msg)\n+  {\n+    if (!OPAQUE_TYPE_P (t2))\n+      {\n+\terror (\"type %s is not an opaque type\", kind_msg);\n+\tdebug_tree (t2);\n+\treturn;\n+      }\n+    if (!OPAQUE_MODE_P (TYPE_MODE (t2)))\n+      {\n+\terror (\"type %s is not with opaque mode\", kind_msg);\n+\tdebug_tree (t2);\n+\treturn;\n+      }\n+    if (TYPE_MODE (t1) != TYPE_MODE (t2))\n+      {\n+\terror (\"type %s differs by %<TYPE_MODE%>\", kind_msg);\n+\tdebug_tree (t2);\n+\treturn;\n+      }\n+    poly_uint64 t1_size = tree_to_poly_uint64 (TYPE_SIZE (t1));\n+    poly_uint64 t2_size = tree_to_poly_uint64 (TYPE_SIZE (t2));\n+    if (maybe_ne (t1_size, t2_size))\n+      {\n+\terror (\"type %s differs by %<TYPE_SIZE%>\", kind_msg);\n+\tdebug_tree (t2);\n+\treturn;\n+      }\n+    if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2))\n+      {\n+\terror (\"type %s differs by %<TYPE_ALIGN%>\", kind_msg);\n+\tdebug_tree (t2);\n+\treturn;\n+      }\n+    if (TYPE_USER_ALIGN (t1) != TYPE_USER_ALIGN (t2))\n+      {\n+\terror (\"type %s differs by %<TYPE_USER_ALIGN%>\", kind_msg);\n+\tdebug_tree (t2);\n+\treturn;\n+      }\n+  };\n+\n+  if (t != tv)\n+    check_properties_for_opaque_type (t, tv, \"variant\");\n+\n+  if (t != tc)\n+    check_properties_for_opaque_type (t, tc, \"canonical\");\n+}\n+\n /* Verify type T.  */\n \n void\n verify_type (const_tree t)\n {\n   bool error_found = false;\n   tree mv = TYPE_MAIN_VARIANT (t);\n+  tree ct = TYPE_CANONICAL (t);\n+\n+  if (OPAQUE_TYPE_P (t))\n+    {\n+      verify_opaque_type (t, mv, ct);\n+      return;\n+    }\n+\n   if (!mv)\n     {\n       error (\"main variant is not defined\");\n@@ -13701,7 +13774,6 @@ verify_type (const_tree t)\n   else if (t != mv && !verify_type_variant (t, mv))\n     error_found = true;\n \n-  tree ct = TYPE_CANONICAL (t);\n   if (!ct)\n     ;\n   else if (TYPE_CANONICAL (ct) != ct)"}]}