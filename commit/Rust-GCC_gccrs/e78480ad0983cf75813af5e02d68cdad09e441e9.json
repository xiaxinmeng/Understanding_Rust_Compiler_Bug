{"sha": "e78480ad0983cf75813af5e02d68cdad09e441e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc4NDgwYWQwOTgzY2Y3NTgxM2FmNWUwMmQ2OGNkYWQwOWU0NDFlOQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-07-15T15:48:45Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-07-28T04:24:26Z"}, "message": "Bind(c): Improve error checking in CFI_* functions\n\nThis patch adds additional run-time checking for invalid arguments to\nCFI_establish and CFI_setpointer.  It also changes existing messages\nthroughout the CFI_* functions to use PRIiPTR to format CFI_index_t\nvalues instead of casting them to int and using %d (which may not work\non targets where int is a smaller type), simplifies wording of some\nmessages, and fixes issues with capitalization, typos, and the like.\nAdditionally some coding standards problems such as >80 character lines\nare addressed.\n\n2021-07-24  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tPR libfortran/101317\n\nlibgfortran/\n\t* runtime/ISO_Fortran_binding.c: Include <inttypes.h>.\n\t(CFI_address): Tidy error messages and comments.\n\t(CFI_allocate): Likewise.\n\t(CFI_deallocate): Likewise.\n\t(CFI_establish): Likewise.  Add new checks for validity of\n\telem_len when it's used, plus type argument and extents.\n\t(CFI_is_contiguous): Tidy error messages and comments.\n\t(CFI_section): Likewise.  Refactor some repetitive code to\n\tmake it more understandable.\n\t(CFI_select_part): Likewise.\n\t(CFI_setpointer): Likewise.  Check that source is not an\n\tunallocated allocatable array or an assumed-size array.\n\ngcc/testsuite/\n\t* gfortran.dg/ISO_Fortran_binding_17.f90: Fix typo in error\n\tmessage patterns.", "tree": {"sha": "119e874fc8e6152a726c45033abd0db054219327", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/119e874fc8e6152a726c45033abd0db054219327"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e78480ad0983cf75813af5e02d68cdad09e441e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e78480ad0983cf75813af5e02d68cdad09e441e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e78480ad0983cf75813af5e02d68cdad09e441e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e78480ad0983cf75813af5e02d68cdad09e441e9/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4a9bc7856ee1d3ff98b04402334a362540af2cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4a9bc7856ee1d3ff98b04402334a362540af2cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4a9bc7856ee1d3ff98b04402334a362540af2cf"}], "stats": {"total": 292, "additions": 172, "deletions": 120}, "files": [{"sha": "5902334a66a710fd27d49b84953010f7f3be516c", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_17.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e78480ad0983cf75813af5e02d68cdad09e441e9/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e78480ad0983cf75813af5e02d68cdad09e441e9/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_17.f90?ref=e78480ad0983cf75813af5e02d68cdad09e441e9", "patch": "@@ -71,7 +71,7 @@ subroutine Csub(a, loc_a_1, invalid_idx) bind(C, name=\"Csub\")\n    end block blk2\n end\n \n-! { dg-output \"CFI_address: subscripts\\\\\\[0\\\\\\] is out of bounds. For dimension = 0, subscripts = -1, lower_bound = 0, upper bound = 4, extend = 4(\\n|\\r\\n|\\r)\" }\n-! { dg-output \"CFI_address: subscripts\\\\\\[0\\\\\\] is out of bounds. For dimension = 0, subscripts = 5, lower_bound = 0, upper bound = 4, extend = 4(\\n|\\r\\n|\\r).*\" }\n-! { dg-output \"CFI_address: subscripts\\\\\\[0\\\\\\] is out of bounds. For dimension = 0, subscripts = -3, lower_bound = -2, upper bound = 6, extend = 4(\\n|\\r\\n|\\r)\" }\n-! { dg-output \"CFI_address: subscripts\\\\\\[0\\\\\\] is out of bounds. For dimension = 0, subscripts = 2, lower_bound = -2, upper bound = 6, extend = 4(\\n|\\r\\n|\\r)\" }\n+! { dg-output \"CFI_address: subscripts\\\\\\[0\\\\\\] is out of bounds. For dimension = 0, subscripts = -1, lower_bound = 0, upper bound = 4, extent = 4(\\n|\\r\\n|\\r)\" }\n+! { dg-output \"CFI_address: subscripts\\\\\\[0\\\\\\] is out of bounds. For dimension = 0, subscripts = 5, lower_bound = 0, upper bound = 4, extent = 4(\\n|\\r\\n|\\r).*\" }\n+! { dg-output \"CFI_address: subscripts\\\\\\[0\\\\\\] is out of bounds. For dimension = 0, subscripts = -3, lower_bound = -2, upper bound = 6, extent = 4(\\n|\\r\\n|\\r)\" }\n+! { dg-output \"CFI_address: subscripts\\\\\\[0\\\\\\] is out of bounds. For dimension = 0, subscripts = 2, lower_bound = -2, upper bound = 6, extent = 4(\\n|\\r\\n|\\r)\" }"}, {"sha": "f8b3ecd004680e235df88a1a3910cca93e0fda30", "filename": "libgfortran/runtime/ISO_Fortran_binding.c", "status": "modified", "additions": 168, "deletions": 116, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e78480ad0983cf75813af5e02d68cdad09e441e9/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e78480ad0983cf75813af5e02d68cdad09e441e9/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2FISO_Fortran_binding.c?ref=e78480ad0983cf75813af5e02d68cdad09e441e9", "patch": "@@ -29,6 +29,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n #include \"ISO_Fortran_binding.h\"\n #include <string.h>\n+#include <inttypes.h>   /* for PRIiPTR */\n \n extern void cfi_desc_to_gfc_desc (gfc_array_void *, CFI_cdesc_t **);\n export_proto(cfi_desc_to_gfc_desc);\n@@ -190,17 +191,17 @@ void *CFI_address (const CFI_cdesc_t *dv, const CFI_index_t subscripts[])\n \n   if (unlikely (compile_options.bounds_check))\n     {\n-      /* C Descriptor must not be NULL. */\n+      /* C descriptor must not be NULL. */\n       if (dv == NULL)\n \t{\n-\t  fprintf (stderr, \"CFI_address: C Descriptor is NULL.\\n\");\n+\t  fprintf (stderr, \"CFI_address: C descriptor is NULL.\\n\");\n \t  return NULL;\n \t}\n \n-      /* Base address of C Descriptor must not be NULL. */\n+      /* Base address of C descriptor must not be NULL. */\n       if (dv->base_addr == NULL)\n \t{\n-\t  fprintf (stderr, \"CFI_address: base address of C Descriptor \"\n+\t  fprintf (stderr, \"CFI_address: base address of C descriptor \"\n \t\t   \"must not be NULL.\\n\");\n \t  return NULL;\n \t}\n@@ -224,10 +225,12 @@ void *CFI_address (const CFI_cdesc_t *dv, const CFI_index_t subscripts[])\n \t    {\n \t      fprintf (stderr, \"CFI_address: subscripts[%d] is out of \"\n \t\t       \"bounds. For dimension = %d, subscripts = %d, \"\n-\t\t       \"lower_bound = %d, upper bound = %d, extend = %d\\n\",\n-\t\t       i, i, (int)subscripts[i], (int)dv->dim[i].lower_bound,\n-\t\t       (int)(dv->dim[i].extent - dv->dim[i].lower_bound),\n-\t\t       (int)dv->dim[i].extent);\n+\t\t       \"lower_bound = %\" PRIiPTR \", upper bound = %\" PRIiPTR\n+\t\t       \", extent = %\" PRIiPTR \"\\n\",\n+\t\t       i, i, (int)subscripts[i],\n+\t\t       (ptrdiff_t)dv->dim[i].lower_bound,\n+\t\t       (ptrdiff_t)(dv->dim[i].extent - dv->dim[i].lower_bound),\n+\t\t       (ptrdiff_t)dv->dim[i].extent);\n               return NULL;\n             }\n \n@@ -245,22 +248,22 @@ CFI_allocate (CFI_cdesc_t *dv, const CFI_index_t lower_bounds[],\n {\n   if (unlikely (compile_options.bounds_check))\n     {\n-      /* C Descriptor must not be NULL. */\n+      /* C descriptor must not be NULL. */\n       if (dv == NULL)\n \t{\n-\t  fprintf (stderr, \"CFI_allocate: C Descriptor is NULL.\\n\");\n+\t  fprintf (stderr, \"CFI_allocate: C descriptor is NULL.\\n\");\n \t  return CFI_INVALID_DESCRIPTOR;\n \t}\n \n-      /* The C Descriptor must be for an allocatable or pointer object. */\n+      /* The C descriptor must be for an allocatable or pointer object. */\n       if (dv->attribute == CFI_attribute_other)\n \t{\n \t  fprintf (stderr, \"CFI_allocate: The object of the C descriptor \"\n \t\t   \"must be a pointer or allocatable variable.\\n\");\n \t  return CFI_INVALID_ATTRIBUTE;\n \t}\n \n-      /* Base address of C Descriptor must be NULL. */\n+      /* Base address of C descriptor must be NULL. */\n       if (dv->base_addr != NULL)\n \t{\n \t  fprintf (stderr, \"CFI_allocate: Base address of C descriptor \"\n@@ -284,8 +287,9 @@ CFI_allocate (CFI_cdesc_t *dv, const CFI_index_t lower_bounds[],\n       if (unlikely (compile_options.bounds_check)\n \t  && (lower_bounds == NULL || upper_bounds == NULL))\n \t{\n-\t  fprintf (stderr, \"CFI_allocate: If 0 < rank (= %d) upper_bounds[] \"\n-\t\t   \"and lower_bounds[], must not be NULL.\\n\", dv->rank);\n+\t  fprintf (stderr, \"CFI_allocate: The lower_bounds and \"\n+\t\t   \"upper_bounds arguments must be non-NULL when \"\n+\t\t   \"rank is greater than zero.\\n\");\n \t  return CFI_INVALID_EXTENT;\n \t}\n \n@@ -314,10 +318,10 @@ CFI_deallocate (CFI_cdesc_t *dv)\n {\n   if (unlikely (compile_options.bounds_check))\n     {\n-      /* C Descriptor must not be NULL */\n+      /* C descriptor must not be NULL */\n       if (dv == NULL)\n \t{\n-\t  fprintf (stderr, \"CFI_deallocate: C Descriptor is NULL.\\n\");\n+\t  fprintf (stderr, \"CFI_deallocate: C descriptor is NULL.\\n\");\n \t  return CFI_INVALID_DESCRIPTOR;\n \t}\n \n@@ -328,10 +332,10 @@ CFI_deallocate (CFI_cdesc_t *dv)\n \t  return CFI_ERROR_BASE_ADDR_NULL;\n \t}\n \n-      /* C Descriptor must be for an allocatable or pointer variable. */\n+      /* C descriptor must be for an allocatable or pointer variable. */\n       if (dv->attribute == CFI_attribute_other)\n \t{\n-\t  fprintf (stderr, \"CFI_deallocate: C Descriptor must describe a \"\n+\t  fprintf (stderr, \"CFI_deallocate: C descriptor must describe a \"\n \t\t  \"pointer or allocatable object.\\n\");\n \t  return CFI_INVALID_ATTRIBUTE;\n \t}\n@@ -366,14 +370,13 @@ int CFI_establish (CFI_cdesc_t *dv, void *base_addr, CFI_attribute_t attribute,\n \t  return CFI_INVALID_RANK;\n \t}\n \n-      /* If base address is not NULL, the established C Descriptor is for a\n+      /* If base address is not NULL, the established C descriptor is for a\n \t  nonallocatable entity. */\n       if (attribute == CFI_attribute_allocatable && base_addr != NULL)\n \t{\n-\t  fprintf (stderr, \"CFI_establish: If base address is not NULL \"\n-\t\t   \"(base_addr != NULL), the established C descriptor is \"\n-\t\t   \"for a nonallocatable entity (attribute != %d).\\n\",\n-\t\t   CFI_attribute_allocatable);\n+\t  fprintf (stderr, \"CFI_establish: If base address is not NULL, \"\n+\t\t   \"the established C descriptor must be \"\n+\t\t   \"for a nonallocatable entity.\\n\");\n \t  return CFI_INVALID_ATTRIBUTE;\n \t}\n     }\n@@ -382,11 +385,26 @@ int CFI_establish (CFI_cdesc_t *dv, void *base_addr, CFI_attribute_t attribute,\n \n   if (type == CFI_type_char || type == CFI_type_ucs4_char\n       || type == CFI_type_struct || type == CFI_type_other)\n-    dv->elem_len = elem_len;\n+    {\n+      /* Note that elem_len has type size_t, which is unsigned.  */\n+      if (unlikely (compile_options.bounds_check) && elem_len == 0)\n+\t{\n+\t  fprintf (stderr, \"CFI_establish: The supplied elem_len must \"\n+\t\t   \"be greater than zero.\\n\");\n+\t  return CFI_INVALID_ELEM_LEN;\n+\t}\n+      dv->elem_len = elem_len;\n+    }\n   else if (type == CFI_type_cptr)\n     dv->elem_len = sizeof (void *);\n   else if (type == CFI_type_cfunptr)\n     dv->elem_len = sizeof (void (*)(void));\n+  else if (unlikely (compile_options.bounds_check) && type < 0)\n+    {\n+      fprintf (stderr, \"CFI_establish: Invalid type (type = %d).\\n\",\n+\t       (int)type);\n+      return CFI_INVALID_TYPE;\n+    }\n   else\n     {\n       /* base_type describes the intrinsic type with kind parameter. */\n@@ -416,13 +434,24 @@ int CFI_establish (CFI_cdesc_t *dv, void *base_addr, CFI_attribute_t attribute,\n       if (unlikely (compile_options.bounds_check) && extents == NULL)\n         {\n \t  fprintf (stderr, \"CFI_establish: Extents must not be NULL \"\n-\t\t   \"(extents != NULL) if rank (= %d) > 0 and base address \"\n-\t\t   \"is not NULL (base_addr != NULL).\\n\", (int)rank);\n+\t\t   \"if rank is greater than zero and base address is \"\n+\t\t   \"not NULL.\\n\");\n \t  return CFI_INVALID_EXTENT;\n \t}\n \n       for (int i = 0; i < rank; i++)\n \t{\n+\t  /* The standard requires all dimensions to be nonnegative.\n+\t     Apparently you can have an extent-zero dimension but can't\n+\t     construct an assumed-size array with -1 as the extent\n+\t     of the last dimension.  */\n+\t  if (unlikely (compile_options.bounds_check) && extents[i] < 0)\n+\t    {\n+\t      fprintf (stderr, \"CFI_establish: Extents must be nonnegative \"\n+\t\t       \"(extents[%d] = %\" PRIiPTR \").\\n\",\n+\t\t       i, (ptrdiff_t)extents[i]);\n+\t      return CFI_INVALID_EXTENT;\n+\t    }\n \t  dv->dim[i].lower_bound = 0;\n \t  dv->dim[i].extent = extents[i];\n \t  if (i == 0)\n@@ -455,16 +484,16 @@ int CFI_is_contiguous (const CFI_cdesc_t *dv)\n       /* Base address must not be NULL. */\n       if (dv->base_addr == NULL)\n \t{\n-\t  fprintf (stderr, \"CFI_is_contiguous: Base address of C Descriptor \"\n+\t  fprintf (stderr, \"CFI_is_contiguous: Base address of C descriptor \"\n \t\t   \"is already NULL.\\n\");\n \t  return 0;\n \t}\n \n       /* Must be an array. */\n-      if (dv->rank == 0)\n+      if (dv->rank <= 0)\n \t{\n-\t  fprintf (stderr, \"CFI_is_contiguous: C Descriptor must describe an \"\n-\t\t   \"array (0 < dv->rank = %d).\\n\", dv->rank);\n+\t  fprintf (stderr, \"CFI_is_contiguous: C descriptor must describe \"\n+\t\t   \"an array.\\n\");\n \t  return 0;\n \t}\n     }\n@@ -473,8 +502,8 @@ int CFI_is_contiguous (const CFI_cdesc_t *dv)\n   if (dv->rank > 0 && dv->dim[dv->rank - 1].extent == -1)\n     return 1;\n \n-  /* If an array is not contiguous the memory stride is different to the element\n-   * length. */\n+  /* If an array is not contiguous the memory stride is different to\n+     the element length. */\n   for (int i = 0; i < dv->rank; i++)\n     {\n       if (i == 0 && dv->dim[i].sm == (CFI_index_t)dv->elem_len)\n@@ -501,14 +530,13 @@ int CFI_section (CFI_cdesc_t *result, const CFI_cdesc_t *source,\n   CFI_index_t upper[CFI_MAX_RANK];\n   CFI_index_t stride[CFI_MAX_RANK];\n   int zero_count = 0;\n-  bool assumed_size;\n \n   if (unlikely (compile_options.bounds_check))\n     {\n-      /* C Descriptors must not be NULL. */\n+      /* C descriptors must not be NULL. */\n       if (source == NULL)\n \t{\n-\t  fprintf (stderr, \"CFI_section: Source must not be  NULL.\\n\");\n+\t  fprintf (stderr, \"CFI_section: Source must not be NULL.\\n\");\n \t  return CFI_INVALID_DESCRIPTOR;\n \t}\n \n@@ -538,18 +566,17 @@ int CFI_section (CFI_cdesc_t *result, const CFI_cdesc_t *source,\n \t allocated allocatable array or an associated pointer array). */\n       if (source->rank <= 0)\n \t{\n-\t  fprintf (stderr, \"CFI_section: Source must describe an array \"\n-\t\t       \"(0 < source->rank, 0 !< %d).\\n\", source->rank);\n+\t  fprintf (stderr, \"CFI_section: Source must describe an array.\\n\");\n \t  return CFI_INVALID_RANK;\n \t}\n \n       /* Element lengths of source and result must be equal. */\n       if (result->elem_len != source->elem_len)\n \t{\n \t  fprintf (stderr, \"CFI_section: The element lengths of \"\n-\t\t   \"source (source->elem_len = %d) and result \"\n-\t\t   \"(result->elem_len = %d) must be equal.\\n\",\n-\t\t   (int)source->elem_len, (int)result->elem_len);\n+\t\t   \"source (source->elem_len = %\" PRIiPTR \") and result \"\n+\t\t   \"(result->elem_len = %\" PRIiPTR \") must be equal.\\n\",\n+\t\t   (ptrdiff_t)source->elem_len, (ptrdiff_t)result->elem_len);\n \t  return CFI_INVALID_ELEM_LEN;\n \t}\n \n@@ -601,7 +628,7 @@ int CFI_section (CFI_cdesc_t *result, const CFI_cdesc_t *source,\n       if (unlikely (compile_options.bounds_check)\n \t  && source->dim[source->rank - 1].extent == -1)\n         {\n-\t  fprintf (stderr, \"CFI_section: Source must not be an assumed size \"\n+\t  fprintf (stderr, \"CFI_section: Source must not be an assumed-size \"\n \t\t   \"array if upper_bounds is NULL.\\n\");\n \t  return CFI_INVALID_EXTENT;\n \t}\n@@ -630,64 +657,70 @@ int CFI_section (CFI_cdesc_t *result, const CFI_cdesc_t *source,\n \t  if (unlikely (compile_options.bounds_check)\n \t      && stride[i] == 0 && lower[i] != upper[i])\n \t    {\n-\t      fprintf (stderr, \"CFI_section: If strides[%d] = 0, then the \"\n-\t\t       \"lower bounds, lower_bounds[%d] = %d, and \"\n-\t\t       \"upper_bounds[%d] = %d, must be equal.\\n\",\n-\t\t       i, i, (int)lower_bounds[i], i, (int)upper_bounds[i]);\n+\t      fprintf (stderr, \"CFI_section: If strides[%d] = 0, then \"\n+\t\t       \"lower_bounds[%d] = %\" PRIiPTR \" and \"\n+\t\t       \"upper_bounds[%d] = %\" PRIiPTR \" must be equal.\\n\",\n+\t\t       i, i, (ptrdiff_t)lower_bounds[i], i,\n+\t\t       (ptrdiff_t)upper_bounds[i]);\n \t      return CFI_ERROR_OUT_OF_BOUNDS;\n \t    }\n \t}\n     }\n \n   /* Check that section upper and lower bounds are within the array bounds. */\n-  for (int i = 0; i < source->rank; i++)\n-    {\n-      assumed_size = (i == source->rank - 1)\n-\t\t     && (source->dim[i].extent == -1);\n-      if (unlikely (compile_options.bounds_check)\n-\t  && lower_bounds != NULL\n-\t  && (lower[i] < source->dim[i].lower_bound ||\n-\t      (!assumed_size && lower[i] > source->dim[i].lower_bound\n-\t\t\t\t\t   + source->dim[i].extent - 1)))\n-\t{\n-\t  fprintf (stderr, \"CFI_section: Lower bounds must be within the \"\n-\t\t   \"bounds of the fortran array (source->dim[%d].lower_bound \"\n-\t\t   \"<= lower_bounds[%d] <= source->dim[%d].lower_bound \"\n-\t\t   \"+ source->dim[%d].extent - 1, %d <= %d <= %d).\\n\",\n-\t\t   i, i, i, i, (int)source->dim[i].lower_bound, (int)lower[i],\n-\t\t   (int)(source->dim[i].lower_bound\n-\t\t\t + source->dim[i].extent - 1));\n-\t  return CFI_ERROR_OUT_OF_BOUNDS;\n-        }\n-\n-      if (unlikely (compile_options.bounds_check)\n-\t  && upper_bounds != NULL\n-\t  && (upper[i] < source->dim[i].lower_bound\n-\t      || (!assumed_size\n-\t\t  && upper[i] > source->dim[i].lower_bound\n-\t\t\t\t+ source->dim[i].extent - 1)))\n-\t{\n-\t  fprintf (stderr, \"CFI_section: Upper bounds must be within the \"\n-\t\t   \"bounds of the fortran array (source->dim[%d].lower_bound \"\n-\t\t   \"<= upper_bounds[%d] <= source->dim[%d].lower_bound + \"\n-\t\t   \"source->dim[%d].extent - 1, %d !<= %d !<= %d).\\n\",\n-\t\t   i, i, i, i, (int)source->dim[i].lower_bound, (int)upper[i],\n-\t\t   (int)(source->dim[i].lower_bound\n-\t\t\t + source->dim[i].extent - 1));\n-\t  return CFI_ERROR_OUT_OF_BOUNDS;\n-\t}\n-\n-      if (unlikely (compile_options.bounds_check)\n-\t  && upper[i] < lower[i] && stride[i] >= 0)\n-        {\n-          fprintf (stderr, \"CFI_section: If the upper bound is smaller than \"\n-\t\t   \"the lower bound for a given dimension (upper[%d] < \"\n-\t\t   \"lower[%d], %d < %d), then he stride for said dimension\"\n-\t\t   \"t must be negative (stride[%d] < 0, %d < 0).\\n\",\n-\t\t   i, i, (int)upper[i], (int)lower[i], i, (int)stride[i]);\n-\t  return CFI_INVALID_STRIDE;\n-\t}\n-    }\n+  if (unlikely (compile_options.bounds_check))\n+    for (int i = 0; i < source->rank; i++)\n+      {\n+\tbool assumed_size\n+\t  = (i == source->rank - 1 && source->dim[i].extent == -1);\n+\tCFI_index_t ub\n+\t  = source->dim[i].lower_bound + source->dim[i].extent - 1;\n+\tif (lower_bounds != NULL\n+\t    && (lower[i] < source->dim[i].lower_bound\n+\t\t|| (!assumed_size && lower[i] > ub)))\n+\t  {\n+\t    fprintf (stderr, \"CFI_section: Lower bounds must be within \"\n+\t\t     \"the bounds of the Fortran array \"\n+\t\t     \"(source->dim[%d].lower_bound \"\n+\t\t     \"<= lower_bounds[%d] <= source->dim[%d].lower_bound \"\n+\t\t     \"+ source->dim[%d].extent - 1, \"\n+\t\t     \"%\" PRIiPTR \" <= %\" PRIiPTR \" <= %\" PRIiPTR \").\\n\",\n+\t\t     i, i, i, i,\n+\t\t     (ptrdiff_t)source->dim[i].lower_bound,\n+\t\t     (ptrdiff_t)lower[i],\n+\t\t     (ptrdiff_t)ub);\n+\t    return CFI_ERROR_OUT_OF_BOUNDS;\n+\t  }\n+\n+\tif (upper_bounds != NULL\n+\t    && (upper[i] < source->dim[i].lower_bound\n+\t\t|| (!assumed_size && upper[i] > ub)))\n+\t  {\n+\t    fprintf (stderr, \"CFI_section: Upper bounds must be within \"\n+\t\t     \"the bounds of the Fortran array \"\n+\t\t     \"(source->dim[%d].lower_bound \"\n+\t\t     \"<= upper_bounds[%d] <= source->dim[%d].lower_bound \"\n+\t\t     \"+ source->dim[%d].extent - 1, \"\n+\t\t     \"%\" PRIiPTR \" !<= %\" PRIiPTR \" !<= %\" PRIiPTR \").\\n\",\n+\t\t     i, i, i, i,\n+\t\t     (ptrdiff_t)source->dim[i].lower_bound,\n+\t\t     (ptrdiff_t)upper[i],\n+\t\t     (ptrdiff_t)ub);\n+\t    return CFI_ERROR_OUT_OF_BOUNDS;\n+\t  }\n+\n+\tif (upper[i] < lower[i] && stride[i] >= 0)\n+\t  {\n+\t    fprintf (stderr, \"CFI_section: If the upper bound is smaller than \"\n+\t\t     \"the lower bound for a given dimension (upper[%d] < \"\n+\t\t     \"lower[%d], %\" PRIiPTR \" < %\" PRIiPTR \"), then the \"\n+\t\t     \"stride for said dimension must be negative \"\n+\t\t     \"(stride[%d] < 0, %\" PRIiPTR \" < 0).\\n\",\n+\t\t     i, i, (ptrdiff_t)upper[i], (ptrdiff_t)lower[i],\n+\t\t     i, (ptrdiff_t)stride[i]);\n+\t    return CFI_INVALID_STRIDE;\n+\t  }\n+      }\n \n   /* Set the base address.  We have to compute this first in the case\n      where source == result, before we overwrite the dimension data.  */\n@@ -714,7 +747,7 @@ int CFI_select_part (CFI_cdesc_t *result, const CFI_cdesc_t *source,\n {\n   if (unlikely (compile_options.bounds_check))\n     {\n-      /* C Descriptors must not be NULL. */\n+      /* C descriptors must not be NULL. */\n       if (source == NULL)\n \t{\n \t  fprintf (stderr, \"CFI_select_part: Source must not be NULL.\\n\");\n@@ -777,8 +810,9 @@ int CFI_select_part (CFI_cdesc_t *result, const CFI_cdesc_t *source,\n \t{\n \t  fprintf (stderr, \"CFI_select_part: Displacement must be within the \"\n \t\t   \"bounds of source (0 <= displacement <= source->elem_len \"\n-\t\t   \"- 1, 0 <= %d <= %d).\\n\", (int)displacement,\n-\t\t   (int)(source->elem_len - 1));\n+\t\t   \"- 1, 0 <= %\" PRIiPTR \" <= %\" PRIiPTR \").\\n\",\n+\t\t   (ptrdiff_t)displacement,\n+\t\t   (ptrdiff_t)(source->elem_len - 1));\n \t  return CFI_ERROR_OUT_OF_BOUNDS;\n \t}\n \n@@ -789,10 +823,12 @@ int CFI_select_part (CFI_cdesc_t *result, const CFI_cdesc_t *source,\n \t  fprintf (stderr, \"CFI_select_part: Displacement plus the element \"\n \t\t   \"length of result must be less than or equal to the \"\n \t\t   \"element length of source (displacement + result->elem_len \"\n-\t\t   \"<= source->elem_len, %d + %d = %d <= %d).\\n\",\n-\t\t   (int)displacement, (int)result->elem_len,\n-\t\t   (int)(displacement + result->elem_len),\n-\t\t   (int)source->elem_len);\n+\t\t   \"<= source->elem_len, \"\n+\t\t   \"%\" PRIiPTR \" + %\" PRIiPTR \" = %\" PRIiPTR \" <= %\" PRIiPTR\n+\t\t   \").\\n\",\n+\t\t   (ptrdiff_t)displacement, (ptrdiff_t)result->elem_len,\n+\t\t   (ptrdiff_t)(displacement + result->elem_len),\n+\t\t   (ptrdiff_t)source->elem_len);\n \t  return CFI_ERROR_OUT_OF_BOUNDS;\n \t}\n     }\n@@ -832,7 +868,7 @@ int CFI_setpointer (CFI_cdesc_t *result, CFI_cdesc_t *source,\n  \t}\n     }\n       \n-  /* If source is NULL, the result is a C Descriptor that describes a\n+  /* If source is NULL, the result is a C descriptor that describes a\n    * disassociated pointer. */\n   if (source == NULL)\n     {\n@@ -841,40 +877,56 @@ int CFI_setpointer (CFI_cdesc_t *result, CFI_cdesc_t *source,\n     }\n   else\n     {\n-      /* Check that element lengths, ranks and types of source and result are\n-       * the same. */\n+      /* Check that the source is valid and that element lengths, ranks\n+\t and types of source and result are the same. */\n       if (unlikely (compile_options.bounds_check))\n \t{\n+\t  if (source->base_addr == NULL\n+\t      && source->attribute == CFI_attribute_allocatable)\n+\t    {\n+\t      fprintf (stderr, \"CFI_setpointer: The source is an \"\n+\t\t       \"allocatable object but is not allocated.\\n\");\n+\t      return CFI_ERROR_BASE_ADDR_NULL;\n+\t    }\n+\t  if (source->rank > 0\n+\t      && source->dim[source->rank - 1].extent == -1)\n+\t    {\n+\t      fprintf (stderr, \"CFI_setpointer: The source is an \"\n+\t\t       \"assumed-size array.\\n\");\n+\t      return CFI_INVALID_EXTENT;\n+\t    }\n \t  if (result->elem_len != source->elem_len)\n \t    {\n \t      fprintf (stderr, \"CFI_setpointer: Element lengths of result \"\n-\t\t       \"(result->elem_len = %d) and source (source->elem_len \"\n-\t\t       \"= %d) must be the same.\\n\", (int)result->elem_len,\n-\t\t       (int)source->elem_len);\n+\t\t       \"(result->elem_len = %\" PRIiPTR \") and source \"\n+\t\t       \"(source->elem_len = %\" PRIiPTR \") \"\n+\t\t       \" must be the same.\\n\",\n+\t\t       (ptrdiff_t)result->elem_len,\n+\t\t       (ptrdiff_t)source->elem_len);\n \t      return CFI_INVALID_ELEM_LEN;\n \t    }\n \n \t  if (result->rank != source->rank)\n \t    {\n-\t      fprintf (stderr, \"CFI_setpointer: Ranks of result (result->rank \"\n-\t\t       \"= %d) and source (source->rank = %d) must be the same.\"\n-\t\t       \"\\n\", result->rank, source->rank);\n+\t      fprintf (stderr, \"CFI_setpointer: Ranks of result \"\n+\t\t       \"(result->rank = %d) and source (source->rank = %d) \"\n+\t\t       \"must be the same.\\n\", result->rank, source->rank);\n \t      return CFI_INVALID_RANK;\n \t    }\n \n \t  if (result->type != source->type)\n \t    {\n-\t      fprintf (stderr, \"CFI_setpointer: Types of result (result->type\"\n-\t\t       \"= %d) and source (source->type = %d) must be the same.\"\n-\t\t       \"\\n\", result->type, source->type);\n+\t      fprintf (stderr, \"CFI_setpointer: Types of result \"\n+\t\t       \"(result->type = %d) and source (source->type = %d) \"\n+\t\t       \"must be the same.\\n\", result->type, source->type);\n \t      return CFI_INVALID_TYPE;\n \t    }\n \t}\n \n-      /* If the source is a disassociated pointer, the result must also describe\n-       * a disassociated pointer. */\n-      if (source->base_addr == NULL &&\n-          source->attribute == CFI_attribute_pointer)\n+      /* If the source is a disassociated pointer, the result must also\n+\t describe a disassociated pointer. */\n+      if (source->base_addr == NULL\n+\t  && source->attribute == CFI_attribute_pointer)\n \tresult->base_addr = NULL;\n       else\n \tresult->base_addr = source->base_addr;"}]}