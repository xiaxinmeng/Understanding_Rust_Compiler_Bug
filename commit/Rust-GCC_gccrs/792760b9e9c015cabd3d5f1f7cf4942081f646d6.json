{"sha": "792760b9e9c015cabd3d5f1f7cf4942081f646d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkyNzYwYjllOWMwMTVjYWJkM2Q1ZjFmN2NmNDk0MjA4MWY2NDZkNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-07-04T17:43:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-07-04T17:43:18Z"}, "message": "emit-rtl.c (replace_equiv_address): New function.\n\n\t* emit-rtl.c (replace_equiv_address): New function.\n\t* expr.h (replace_equiv_address): New declaration.\n\t* explow.c (validize_mem): Call it instead of change_address and\n\talso call if -fforce-addr and address is constant.\n\t* expr.c: Replace more calls to change_address with adjust_address\n\tand/or replace_equiv_address or to validize_mem.\n\t* function.c, regmove.c, config/alpha/alpha.c: Likewise.\n\t* config/arm/arm.md, config/clipper/clipper.md: Likewise.\n\t* config/dsp16xx/dsp16xx.md, config/fr30/fr30.c: Likewise.\n\t* config/i370/i370.md, config/i860/i860.md: Likewise.\n\t* config/i960/i960.md, config/mips/mips.c: Likewise.\n\t* config/mips/mips.md, config/pa/pa.md: Likewise.\n\t* config/pdp11/pdp11.md, config/rs6000/rs6000.c: Likewise.\n\t* config/rs6000/rs6000.md, config/sh/sh.md: Likewise.\n\nFrom-SVN: r43762", "tree": {"sha": "df66055b376252d4e98b02a6a2492ca9f4731ad2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df66055b376252d4e98b02a6a2492ca9f4731ad2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/792760b9e9c015cabd3d5f1f7cf4942081f646d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792760b9e9c015cabd3d5f1f7cf4942081f646d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/792760b9e9c015cabd3d5f1f7cf4942081f646d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792760b9e9c015cabd3d5f1f7cf4942081f646d6/comments", "author": null, "committer": null, "parents": [{"sha": "861c44d0c94742492ae78c5ed6c1fc5b6364501c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861c44d0c94742492ae78c5ed6c1fc5b6364501c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/861c44d0c94742492ae78c5ed6c1fc5b6364501c"}], "stats": {"total": 325, "additions": 170, "deletions": 155}, "files": [{"sha": "dc2a6fa9010f01e0100792a557317c1ce5097bce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -1,3 +1,20 @@\n+Wed Jul  4 13:40:02 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* emit-rtl.c (replace_equiv_address): New function.\n+\t* expr.h (replace_equiv_address): New declaration.\n+\t* explow.c (validize_mem): Call it instead of change_address and\n+\talso call if -fforce-addr and address is constant.\n+\t* expr.c: Replace more calls to change_address with adjust_address\n+\tand/or replace_equiv_address or to validize_mem.\n+\t* function.c, regmove.c, config/alpha/alpha.c: Likewise.\n+\t* config/arm/arm.md, config/clipper/clipper.md: Likewise.\n+\t* config/dsp16xx/dsp16xx.md, config/fr30/fr30.c: Likewise.\n+\t* config/i370/i370.md, config/i860/i860.md: Likewise.\n+\t* config/i960/i960.md, config/mips/mips.c: Likewise.\n+\t* config/mips/mips.md, config/pa/pa.md: Likewise.\n+\t* config/pdp11/pdp11.md, config/rs6000/rs6000.c: Likewise.\n+\t* config/rs6000/rs6000.md, config/sh/sh.md: Likewise.\n+\n 2001-07-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* bitmap.c (bitmap_union_of_diff): Don't use BITMAP_ALLOCA."}, {"sha": "3ddd7f3d9e19bedd6e9c3d2241ffba61843c1923", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -2930,8 +2930,8 @@ alpha_expand_block_move (operands)\n \t}\n \n       /* No appropriate mode; fall back on memory.  */\n-      orig_src = change_address (orig_src, GET_MODE (orig_src),\n-\t\t\t\t copy_addr_to_reg (XEXP (orig_src, 0)));\n+      orig_src = replace_equiv_address (orig_src,\n+\t\t\t\t\tcopy_addr_to_reg (XEXP (orig_src, 0)));\n       src_align = GET_MODE_BITSIZE (GET_MODE (tmp));\n     }\n \n@@ -2961,9 +2961,7 @@ alpha_expand_block_move (operands)\n \n       for (i = 0; i < words; ++i)\n \temit_move_insn (data_regs[nregs + i],\n-\t\t\tchange_address (orig_src, SImode,\n-\t\t\t\t\tplus_constant (XEXP (orig_src, 0),\n-\t\t\t\t\t\t       ofs + i * 4)));\n+\t\t\tadjust_address (orig_src, SImode, ofs + i * 4));\n \n       nregs += words;\n       bytes -= words * 4;\n@@ -3076,8 +3074,8 @@ alpha_expand_block_move (operands)\n \n       /* No appropriate mode; fall back on memory.  We can speed things\n \t up by recognizing extra alignment information.  */\n-      orig_dst = change_address (orig_dst, GET_MODE (orig_dst),\n-\t\t\t\t copy_addr_to_reg (XEXP (orig_dst, 0)));\n+      orig_dst = replace_equiv_address (orig_dst,\n+\t\t\t\t\tcopy_addr_to_reg (XEXP (orig_dst, 0)));\n       dst_align = GET_MODE_BITSIZE (GET_MODE (tmp));\n     }\n \n@@ -3229,8 +3227,7 @@ alpha_expand_block_clear (operands)\n \t}\n \n       /* No appropriate mode; fall back on memory.  */\n-      orig_dst = change_address (orig_dst, GET_MODE (orig_dst),\n-\t\t\t\t copy_addr_to_reg (tmp));\n+      orig_dst = replace_equiv_address (orig_dst, copy_addr_to_reg (tmp));\n       align = GET_MODE_BITSIZE (GET_MODE (XEXP (tmp, 0)));\n     }\n "}, {"sha": "fea195483d559e2ba605ee2c0f7c961a90fd779a", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -4282,15 +4282,15 @@\n   \"TARGET_ARM\"\n   \"\n   {\n-    rtx addr = XEXP (operands[1], 0);\n+    rtx op1 = operands[1];\n+    rtx addr = XEXP (op1, 0);\n     enum rtx_code code = GET_CODE (addr);\n \n     if ((code == PLUS && GET_CODE (XEXP (addr, 1)) != CONST_INT)\n \t|| code == MINUS)\n-      addr = force_reg (SImode, addr);\n+      op1 = replace_equiv_address (operands[1], force_reg (SImode, addr));\n \n-    operands[4] = change_address (operands[1], QImode,\n-\t\t\t\t  plus_constant (addr, 1));\n+    operands[4] = adjust_address (op1, QImode, 1);\n     operands[1] = adjust_address (operands[1], QImode, 0);\n     operands[3] = gen_lowpart (QImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);\n@@ -4306,15 +4306,15 @@\n   \"TARGET_ARM\"\n   \"\n   {\n-    rtx addr = XEXP (operands[1], 0);\n+    rtx op1 = operands[1];\n+    rtx addr = XEXP (op1, 0);\n     enum rtx_code code = GET_CODE (addr);\n \n     if ((code == PLUS && GET_CODE (XEXP (addr, 1)) != CONST_INT)\n \t|| code == MINUS)\n-      addr = force_reg (SImode, addr);\n+      op1 = replace_equiv_address (op1, force_reg (SImode, addr));\n \n-    operands[4] = change_address (operands[1], QImode,\n-\t\t\t\t  plus_constant (addr, 1));\n+    operands[4] = adjust_address (op1, QImode, 1);\n     operands[1] = adjust_address (operands[1], QImode, 0);\n     operands[3] = gen_lowpart (QImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);\n@@ -4332,11 +4332,12 @@\n   {\n     HOST_WIDE_INT value = INTVAL (operands[1]);\n     rtx addr = XEXP (operands[0], 0);\n+    rtx op0 = operands[0];\n     enum rtx_code code = GET_CODE (addr);\n \n     if ((code == PLUS && GET_CODE (XEXP (addr, 1)) != CONST_INT)\n \t|| code == MINUS)\n-      addr = force_reg (SImode, addr);\n+      op0 = replace_equiv_address (op0, force_reg (SImode, addr));\n \n     operands[1] = gen_reg_rtx (SImode);\n     if (BYTES_BIG_ENDIAN)\n@@ -4362,8 +4363,7 @@\n \t  }\n       }\n \n-    operands[3] = change_address (operands[0], QImode,\n-\t\t\t\t  plus_constant (addr, 1));\n+    operands[3] = adjust_address (op0, QImode, 1);\n     operands[0] = adjust_address (operands[0], QImode, 0);\n   }\"\n )\n@@ -4550,18 +4550,16 @@\n           if (GET_CODE (operands[0]) == MEM\n \t      && !memory_address_p (GET_MODE (operands[0]),\n \t\t\t\t    XEXP (operands[0], 0)))\n-\t    {\n-\t      rtx temp = copy_to_reg (XEXP (operands[0], 0));\n-\t      operands[0] = change_address (operands[0], VOIDmode, temp);\n-\t    }\n+\t    operands[0]\n+\t      = replace_equiv_address (operands[0],\n+\t\t\t\t       copy_to_reg (XEXP (operands[0], 0)));\n    \n           if (GET_CODE (operands[1]) == MEM\n \t      && !memory_address_p (GET_MODE (operands[1]),\n \t\t\t\t    XEXP (operands[1], 0)))\n-\t    {\n-\t      rtx temp = copy_to_reg (XEXP (operands[1], 0));\n-\t      operands[1] = change_address (operands[1], VOIDmode, temp);\n-\t    }\n+\t    operands[1]\n+\t      = replace_equiv_address (operands[1],\n+\t\t\t\t       copy_to_reg (XEXP (operands[1], 0)));\n         }\n       /* Handle loading a large integer during reload */\n       else if (GET_CODE (operands[1]) == CONST_INT\n@@ -4850,17 +4848,15 @@\n           if (GET_CODE (operands[0]) == MEM\n \t      && !memory_address_p (GET_MODE (operands[0]),\n \t\t  \t\t     XEXP (operands[0], 0)))\n-\t    {\n-\t      rtx temp = copy_to_reg (XEXP (operands[0], 0));\n-\t      operands[0] = change_address (operands[0], VOIDmode, temp);\n-\t    }\n+\t    operands[0]\n+\t      = replace_equiv_address (operands[0],\n+\t\t\t\t       copy_to_reg (XEXP (operands[0], 0)));\n           if (GET_CODE (operands[1]) == MEM\n \t      && !memory_address_p (GET_MODE (operands[1]),\n \t\t\t\t    XEXP (operands[1], 0)))\n-\t    {\n-\t       rtx temp = copy_to_reg (XEXP (operands[1], 0));\n-\t       operands[1] = change_address (operands[1], VOIDmode, temp);\n-\t    }\n+\t     operands[1]\n+\t       = replace_equiv_address (operands[1],\n+\t\t\t\t\tcopy_to_reg (XEXP (operands[1], 0)));\n         }\n       /* Handle loading a large integer during reload */\n       else if (GET_CODE (operands[1]) == CONST_INT"}, {"sha": "2d2a504d6b8d6877da2729a4c15dc77e5fec2f36", "filename": "gcc/config/clipper/clipper.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fclipper%2Fclipper.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fclipper%2Fclipper.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.md?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -531,8 +531,8 @@\n   operands[6] = addr0;\n   operands[7] = addr1;\n \n-  operands[0] = change_address (operands[0], VOIDmode, addr0);\n-  operands[1] = change_address (operands[1], VOIDmode, addr1);\n+  operands[0] = replace_equiv_address (operands[0], addr0);\n+  operands[1] = replace_equiv_address (operands[1], addr1);\n \n   if (GET_CODE (operands[2]) != CONST_INT)\n     operands[2] = force_reg (SImode, operands[2]);"}, {"sha": "4e851554b27942ef58438f11264ad264196e3467", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -1131,8 +1131,8 @@\n   operands[5] = addr0;\n   operands[6] = addr1;\n \n-  operands[0] = change_address (operands[0], VOIDmode, addr0);\n-  operands[1] = change_address (operands[1], VOIDmode, addr1);\n+  operands[0] = replace_equiv_address (operands[0], VOIDmode, addr0);\n+  operands[1] = replace_equiv_address (operands[1], VOIDmode, addr1);\n }\")\n \n (define_insn \"\""}, {"sha": "8fcad88314afe1ac3e4c53ed71bf63b1c70e6d59", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -1007,7 +1007,7 @@ fr30_move_double (operands)\n \t  if (reverse)\n \t    {\n \t      emit_insn (gen_rtx_SET (VOIDmode, dest1,\n-\t\t\t\t      change_address (src, SImode, addr)));\n+\t\t\t\t      adjust_address (src, SImode, 0)));\n \t      emit_insn (gen_rtx_SET (SImode, dest0,\n \t\t\t\t      gen_rtx_REG (SImode, REGNO (addr))));\n \t      emit_insn (gen_rtx_SET (SImode, dest0,\n@@ -1021,7 +1021,7 @@ fr30_move_double (operands)\n \t  else\n \t    {\n \t      emit_insn (gen_rtx_SET (VOIDmode, dest0,\n-\t\t\t\t      change_address (src, SImode, addr)));\n+\t\t\t\t      adjust_address (src, SImode, 0)));\n \t      emit_insn (gen_rtx_SET (SImode, dest1,\n \t\t\t\t      gen_rtx_REG (SImode, REGNO (addr))));\n \t      emit_insn (gen_rtx_SET (SImode, dest1,\n@@ -1058,8 +1058,7 @@ fr30_move_double (operands)\n       src0 = operand_subword (src, 0, TRUE, mode);\n       src1 = operand_subword (src, 1, TRUE, mode);\n       \n-      emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t      change_address (dest, SImode, addr),\n+      emit_insn (gen_rtx_SET (VOIDmode, adjust_address (dest, SImode, 0),\n \t\t\t      src0));\n \n       if (REGNO (addr) == STACK_POINTER_REGNUM"}, {"sha": "c0d05e6e791c11faf0723feccad8bafe6c4aa2c9", "filename": "gcc/config/i370/i370.md", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fi370%2Fi370.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fi370%2Fi370.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.md?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -1380,21 +1380,6 @@ check_label_emit ();\n    \"\"\n    \"\n {\n-/*\n-  XXX bogus, i think, unless change_address has a side effet we need\n-  rtx op0;\n-\n-  op0 = XEXP (operands[0], 0);\n-  if (GET_CODE (op0) == REG\n-      || (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 0)) == REG\n-\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t  && (unsigned) INTVAL (XEXP (op0, 1)) < 4096))\n-    op0 = operands[0];\n-  else\n-    op0 = change_address (operands[0], VOIDmode,\n-\t\t\t  copy_to_mode_reg (SImode, op0));\n-\n-*/\n   {\n         /* implementation suggested by  Richard Henderson <rth@cygnus.com> */\n         rtx reg1 = gen_reg_rtx (DImode);\n@@ -1442,8 +1427,7 @@ check_label_emit ();\n \t  && (unsigned) INTVAL (XEXP (op0, 1)) < 4096))\n     op0 = operands[0];\n   else\n-    op0 = change_address (operands[0], VOIDmode,\n-\t\t\t  copy_to_mode_reg (SImode, op0));\n+    op0 = replace_equiv_address (operands[0], copy_to_mode_reg (SImode, op0));\n \n   op1 = XEXP (operands[1], 0);\n   if (GET_CODE (op1) == REG\n@@ -1452,8 +1436,7 @@ check_label_emit ();\n \t  && (unsigned) INTVAL (XEXP (op1, 1)) < 4096))\n     op1 = operands[1];\n   else\n-    op1 = change_address (operands[1], VOIDmode,\n-\t\t\t  copy_to_mode_reg (SImode, op1));\n+    op1 = replace_equiv_address (operands[1], copy_to_mode_reg (SImode, op1));\n \n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 256)\n     emit_insn (gen_rtx_PARALLEL (VOIDmode,"}, {"sha": "eda051c5b572a8a88ded02b2f123a2ab14d1b46c", "filename": "gcc/config/i860/i860.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fi860%2Fi860.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fi860%2Fi860.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.md?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -1022,8 +1022,8 @@\n   operands[7] = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n   operands[8] = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n \n-  operands[0] = change_address (operands[0], VOIDmode, operands[7]);\n-  operands[1] = change_address (operands[1], VOIDmode, operands[8]);\n+  operands[0] = replace_equiv_address (operands[0], operands[7]);\n+  operands[1] = replace_equiv_address (operands[1], operands[8]);\n }\")\n \n (define_insn \"\"\n@@ -2127,8 +2127,9 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n   /* Make sure the address is just one reg and will stay that way.  */\n   if (! call_insn_operand (operands[0], QImode))\n     operands[0]\n-      = change_address (operands[0], VOIDmode,\n-\t\t\tcopy_to_mode_reg (Pmode, XEXP (operands[0], 0)));\n+      = replace_equiv_address (operands[0],\n+\t\t\t       copy_to_mode_reg (Pmode,\n+\t\t\t\t\t\t XEXP (operands[0], 0)));\n   if (INTVAL (operands[1]) > 0)\n     {\n       emit_move_insn (arg_pointer_rtx, stack_pointer_rtx);\n@@ -2195,8 +2196,9 @@ fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n   /* Make sure the address is just one reg and will stay that way.  */\n   if (! call_insn_operand (operands[1], QImode))\n     operands[1]\n-      = change_address (operands[1], VOIDmode,\n-\t\t\tcopy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n+      = replace_equiv_address (operands[1],\n+\t\t\t       copy_to_mode_reg (Pmode,\n+\t\t\t\t\t\t XEXP (operands[1], 0)));\n   if (INTVAL (operands[2]) > 0)\n     {\n       emit_move_insn (arg_pointer_rtx, stack_pointer_rtx);"}, {"sha": "282297d5a7d0bc0e380d589ee32405b412094f8a", "filename": "gcc/config/i960/i960.md", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -1004,7 +1004,7 @@\n {\n   int regno;\n   int count;\n-  rtx from;\n+  int offset = 0;\n \n   if (GET_CODE (operands[0]) != MEM\n       || GET_CODE (operands[1]) != REG\n@@ -1016,30 +1016,29 @@\n     FAIL;\n \n   regno = REGNO (operands[1]);\n-  from = memory_address (SImode, XEXP (operands[0], 0));\n   while (count >= 4 && ((regno & 3) == 0))\n     {\n-      emit_move_insn (change_address (operands[0], TImode, from),\n+      emit_move_insn (adjust_address (operands[0], TImode, offset),\n \t\t      gen_rtx_REG (TImode, regno));\n       count -= 4;\n       regno += 4;\n-      from = memory_address (TImode, plus_constant (from, 16));\n+      offset += 16;\n     }\n   while (count >= 2 && ((regno & 1) == 0))\n     {\n-      emit_move_insn (change_address (operands[0], DImode, from),\n+      emit_move_insn (adjust_address (operands[0], DImode, offset),\n \t\t      gen_rtx_REG (DImode, regno));\n       count -= 2;\n       regno += 2;\n-      from = memory_address (DImode, plus_constant (from, 8));\n+      offset += 8;\n     }\n   while (count > 0)\n     {\n-      emit_move_insn (change_address (operands[0], SImode, from),\n+      emit_move_insn (adjust_address (operands[0], SImode, offset),\n \t\t      gen_rtx_REG (SImode, regno));\n       count -= 1;\n       regno += 1;\n-      from = memory_address (SImode, plus_constant (from, 4));\n+      offset += 4;\n     }\n   DONE;\n }\")"}, {"sha": "37cb19bc31b6f1a8f6cbc89c78fc70efe680af94", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -3248,11 +3248,11 @@ block_move_loop (dest_reg, src_reg, bytes, align, orig_dest, orig_src)\n      rtx src_reg;\t\t/* register holding source address */\n      unsigned int bytes;\t/* # bytes to move */\n      int align;\t\t\t/* alignment */\n-     rtx orig_dest;\t\t/* original dest for change_address */\n+     rtx orig_dest;\t\t/* original dest */\n      rtx orig_src;\t\t/* original source for making a reg note */\n {\n-  rtx dest_mem = change_address (orig_dest, BLKmode, dest_reg);\n-  rtx src_mem = change_address (orig_src, BLKmode, src_reg);\n+  rtx dest_mem = replace_equiv_address (orig_dest, dest_reg);\n+  rtx src_mem = replace_equiv_address (orig_src, src_reg);\n   rtx align_rtx = GEN_INT (align);\n   rtx label;\n   rtx final_src;\n@@ -3383,10 +3383,10 @@ expand_block_move (operands)\n     move_by_pieces (orig_dest, orig_src, bytes, align * BITS_PER_WORD);\n \t\n   else if (constp && bytes <= (unsigned)2 * MAX_MOVE_BYTES)\n-    emit_insn (gen_movstrsi_internal (change_address (orig_dest, BLKmode,\n-\t\t\t\t\t\t      dest_reg),\n-\t\t\t\t      change_address (orig_src, BLKmode,\n-\t\t\t\t\t\t      src_reg),\n+    emit_insn (gen_movstrsi_internal (replace_equiv_address (orig_dest,\n+\t\t\t\t\t\t\t     dest_reg),\n+\t\t\t\t      replace_equiv_address (orig_src,\n+\t\t\t\t\t\t\t     src_reg),\n \t\t\t\t      bytes_rtx, align_rtx));\n \n   else if (constp && align >= (unsigned) UNITS_PER_WORD && optimize)\n@@ -3433,10 +3433,10 @@ expand_block_move (operands)\n \n       /* Bytes at the end of the loop.  */\n       if (leftover)\n-\temit_insn (gen_movstrsi_internal (change_address (orig_dest, BLKmode,\n-\t\t\t\t\t\t\t  dest_reg),\n-\t\t\t\t\t  change_address (orig_src, BLKmode,\n-\t\t\t\t\t\t\t  src_reg),\n+\temit_insn (gen_movstrsi_internal (replace_equiv_address (orig_dest,\n+\t\t\t\t\t\t\t\t dest_reg),\n+\t\t\t\t\t  replace_equiv_address (orig_src,\n+\t\t\t\t\t\t\t\t src_reg),\n \t\t\t\t\t  GEN_INT (leftover),\n \t\t\t\t\t  GEN_INT (align)));\n     }"}, {"sha": "c55c128f3310d42b8617493cff9a616d897adb95", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -5066,7 +5066,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t{\n \t  rtx memword, offword, hi_word, lo_word;\n \t  rtx addr = find_replacement (&XEXP (operands[1], 0));\n-\t  rtx op1 = change_address (operands[1], VOIDmode, addr);\n+\t  rtx op1 = replace_equiv_address (operands[1], addr);\n \n \t  scratch = gen_rtx_REG (SImode, REGNO (scratch));\n \t  memword = adjust_address (op1, SImode, 0);\n@@ -5146,7 +5146,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t{\n \t  rtx scratch, memword, offword, hi_word, lo_word;\n \t  rtx addr = find_replacement (&XEXP (operands[0], 0));\n-\t  rtx op0 = change_address (operands[0], VOIDmode, addr);\n+\t  rtx op0 = replace_equiv_address (operands[0], addr);\n \n \t  scratch = gen_rtx_REG (SImode, REGNO (operands[2]));\n \t  memword = adjust_address (op0, SImode, 0);"}, {"sha": "59b4c766fa292021de1fdb6a0263c67119e9d324", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -2814,11 +2814,11 @@\n   \n   /* Fall through means we're going to use our block move pattern.  */\n   operands[0]\n-    = change_address (operands[0], VOIDmode,\n-\t\t      copy_to_mode_reg (SImode, XEXP (operands[0], 0)));\n+    = replace_equiv_address (operands[0],\n+\t\t\t     copy_to_mode_reg (SImode, XEXP (operands[0], 0)));\n   operands[1]\n-    = change_address (operands[1], VOIDmode,\n-\t\t      copy_to_mode_reg (SImode, XEXP (operands[1], 0)));\n+    = replace_equiv_address (operands[1],\n+\t\t\t     copy_to_mode_reg (SImode, XEXP (operands[1], 0)));\n   operands[4] = gen_reg_rtx (SImode);\n   operands[5] = gen_reg_rtx (SImode);\n   operands[6] = gen_reg_rtx (SImode);"}, {"sha": "98a10c01e48c823d1456af50e3e43bc895369bcd", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -696,11 +696,11 @@\n   \"\n {\n   operands[0]\n-    = change_address (operands[0], VOIDmode,\n-\t\t      copy_to_mode_reg (Pmode, XEXP (operands[0], 0)));\n+    = replace_equiv_address (operands[0],\n+\t\t\t     copy_to_mode_reg (Pmode, XEXP (operands[0], 0)));\n   operands[1]\n-    = change_address (operands[1], VOIDmode,\n-\t\t      copy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n+    = replace_equiv_address (operands[1],\n+\t\t\t     copy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n \n   operands[5] = XEXP (operands[0], 0);\n   operands[6] = XEXP (operands[1], 0);"}, {"sha": "2f35583bb3461b3b4f858c01c5c528ec272f19ca", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -1866,14 +1866,16 @@ rs6000_emit_move (dest, source, mode)\n       if (GET_CODE (operands[0]) == MEM\n \t  && GET_CODE (XEXP (operands[0], 0)) != REG\n \t  && ! reload_in_progress)\n-\toperands[0] = change_address (operands[0], TImode,\n-\t\t\t\t      copy_addr_to_reg (XEXP (operands[0], 0)));\n+\toperands[0]\n+\t  = replace_equiv_address (operands[0],\n+\t\t\t\t   copy_addr_to_reg (XEXP (operands[0], 0)));\n \n       if (GET_CODE (operands[1]) == MEM\n \t  && GET_CODE (XEXP (operands[1], 0)) != REG\n \t  && ! reload_in_progress)\n-\toperands[1] = change_address (operands[1], TImode,\n-\t\t\t\t      copy_addr_to_reg (XEXP (operands[1], 0)));\n+\toperands[1]\n+\t  = replace_equiv_address (operands[1],\n+\t\t\t\t   copy_addr_to_reg (XEXP (operands[1], 0)));\n       break;\n \n     default:"}, {"sha": "e23e289ec33a6fc9d6165edff06306776d86a06d", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -1,6 +1,6 @@\n ;; Machine description for IBM RISC System 6000 (POWER) for GNU C compiler\n ;; Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, \n-;; 1999, 2000 Free Software Foundation, Inc.\n+;; 1999, 2000, 2001 Free Software Foundation, Inc.\n ;; Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n ;; This file is part of GNU CC.\n@@ -8257,7 +8257,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n {\n   int regno;\n   int count;\n-  rtx from;\n+  rtx op1;\n   int i;\n \n   /* Support only loading a constant number of fixed-point registers from\n@@ -8275,13 +8275,13 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   regno = REGNO (operands[0]);\n \n   operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n-  from = force_reg (SImode, XEXP (operands[1], 0));\n+  op1 = replace_equiv_address (operands[1],\n+\t\t\t       force_reg (SImode, XEXP (operands[1], 0)));\n \n   for (i = 0; i < count; i++)\n     XVECEXP (operands[3], 0, i)\n       = gen_rtx_SET (VOIDmode, gen_rtx_REG (SImode, regno + i),\n-\t\t     change_address (operands[1], SImode,\n-\t\t\t\t     plus_constant (from, i * 4)));\n+\t\t     adjust_address (op1, SImode, i * 4));\n }\")\n \n (define_insn \"\"\n@@ -8354,6 +8354,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   int regno;\n   int count;\n   rtx to;\n+  rtx op0;\n   int i;\n \n   /* Support only storing a constant number of fixed-point registers to\n@@ -8372,18 +8373,17 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \n   operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count + 1));\n   to = force_reg (SImode, XEXP (operands[0], 0));\n+  op0 = replace_equiv_address (operands[0], to);\n \n   XVECEXP (operands[3], 0, 0)\n-    = gen_rtx_SET (VOIDmode, change_address (operands[0], SImode, to),\n-\t\t   operands[1]);\n+    = gen_rtx_SET (VOIDmode, op0, operands[1]);\n   XVECEXP (operands[3], 0, 1) = gen_rtx_CLOBBER (VOIDmode,\n \t\t\t\t\t\t gen_rtx_SCRATCH (SImode));\n \n   for (i = 1; i < count; i++)\n     XVECEXP (operands[3], 0, i + 1)\n       = gen_rtx_SET (VOIDmode,\n-\t\t     change_address (operands[0], SImode,\n-\t\t\t\t     plus_constant (to, i * 4)),\n+\t\t     adjust_address (op0, SImode, i * 4),\n \t\t     gen_rtx_REG (SImode, regno + i));\n }\")\n "}, {"sha": "c625b702a0513debe0a8910337649b1bd3cfc84e", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -5028,7 +5028,7 @@\n   emit_insn (gen_movsi (shift_reg, operands[3]));\n   addr_target = copy_addr_to_reg (plus_constant (orig_address, size - 1));\n \n-  operands[0] = change_address (operands[0], QImode, addr_target);\n+  operands[0] = replace_equiv_address (operands[0], addr_target);\n   emit_insn (gen_movqi (operands[0], gen_rtx_SUBREG (QImode, shift_reg, 0)));\n \n   while (size -= 1)"}, {"sha": "deca99b7459f6c8beb9f17689e8f8c322624fff7", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -1601,6 +1601,7 @@ change_address (memref, mode, addr)\n   MEM_COPY_ATTRIBUTES (new, memref);\n   return new;\n }\n+\n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address offset by OFFSET bytes.  */\n \n@@ -1615,6 +1616,21 @@ adjust_address (memref, mode, offset)\n   return\n     change_address (memref, mode, plus_constant (XEXP (memref, 0), offset));\n }\n+\n+/* Return a memory reference like MEMREF, but with its address changed to\n+   ADDR.  The caller is asserting that the actual piece of memory pointed\n+   to is the same, just the form of the address is being changed, such as\n+   by putting something into a register.  */\n+\n+rtx\n+replace_equiv_address (memref, addr)\n+     rtx memref;\n+     rtx addr;\n+{\n+  /* For now, this is just a wrapper for change_address, but eventually\n+     will do memref tracking.  */\n+  return change_address (memref, VOIDmode, addr);\n+}\n \f\n /* Return a newly created CODE_LABEL rtx with a unique label number.  */\n "}, {"sha": "68394598271e30a0af1c4cc9bad6879c7cd87460", "filename": "gcc/explow.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -610,10 +610,12 @@ validize_mem (ref)\n {\n   if (GET_CODE (ref) != MEM)\n     return ref;\n-  if (memory_address_p (GET_MODE (ref), XEXP (ref, 0)))\n+  if (! (flag_force_addr && CONSTANT_ADDRESS_P (XEXP (ref, 0)))\n+      && memory_address_p (GET_MODE (ref), XEXP (ref, 0)))\n     return ref;\n+\n   /* Don't alter REF itself, since that is probably a stack slot.  */\n-  return change_address (ref, GET_MODE (ref), XEXP (ref, 0));\n+  return replace_equiv_address (ref, XEXP (ref, 0));\n }\n \f\n /* Given REF, either a MEM or a REG, and T, either the type of X or"}, {"sha": "3264aca20808d0af5ce48f8541fdffda6b1fd154", "filename": "gcc/expr.c", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -1879,8 +1879,7 @@ move_block_from_reg (regno, x, nregs, size)\n   if (size <= UNITS_PER_WORD\n       && (mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0)) != BLKmode)\n     {\n-      emit_move_insn (change_address (x, mode, NULL),\n-\t\t      gen_rtx_REG (mode, regno));\n+      emit_move_insn (adjust_address (x, mode, 0), gen_rtx_REG (mode, regno));\n       return;\n     }\n \n@@ -2746,13 +2745,13 @@ emit_move_insn (x, y)\n \t   && ! push_operand (x, GET_MODE (x)))\n \t  || (flag_force_addr\n \t      && CONSTANT_ADDRESS_P (XEXP (x, 0)))))\n-    x = change_address (x, VOIDmode, XEXP (x, 0));\n+    x = validize_mem (x);\n \n   if (GET_CODE (y) == MEM\n       && (! memory_address_p (GET_MODE (y), XEXP (y, 0))\n \t  || (flag_force_addr\n \t      && CONSTANT_ADDRESS_P (XEXP (y, 0)))))\n-    y = change_address (y, VOIDmode, XEXP (y, 0));\n+    y = validize_mem (y);\n \n   if (mode == BLKmode)\n     abort ();\n@@ -3752,9 +3751,9 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t      if (GET_CODE (XEXP (temp, 0)) == REG)\n \t        to_rtx = temp;\n \t      else\n-\t\tto_rtx = change_address (to_rtx, mode1,\n-\t\t\t\t         force_reg (GET_MODE (XEXP (temp, 0)),\n-\t\t\t\t\t\t    XEXP (temp, 0)));\n+\t\tto_rtx = (replace_equiv_address\n+\t\t\t  (to_rtx, force_reg (GET_MODE (XEXP (temp, 0)),\n+\t\t\t\t\t      XEXP (temp, 0))));\n \t      bitpos = 0;\n \t    }\n \n@@ -5331,14 +5330,13 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t\t&& GET_CODE (XEXP (addr, 1)) == CONST_INT\n \t\t&& (XEXP (addr, 0) == virtual_incoming_args_rtx\n \t\t    || XEXP (addr, 0) == virtual_stack_vars_rtx)))\n-\taddr = copy_to_reg (addr);\n+\ttarget = replace_equiv_address (target, copy_to_reg (addr));\n \n       /* Now build a reference to just the desired component.  */\n \n-      to_rtx = copy_rtx (change_address (target, mode,\n-\t\t\t\t\t plus_constant (addr,\n-\t\t\t\t\t\t\t(bitpos\n-\t\t\t\t\t\t\t / BITS_PER_UNIT))));\n+      to_rtx = copy_rtx (adjust_address (target, mode,\n+\t\t\t\t\t bitpos / BITS_PER_UNIT));\n+\n       MEM_SET_IN_STRUCT_P (to_rtx, 1);\n       /* If the address of the structure varies, then it might be on\n \t the stack.  And, stack slots may be shared across scopes.\n@@ -5683,13 +5681,12 @@ save_noncopied_parts (lhs, list)\n \t\t\t\t\t\t| TYPE_QUAL_CONST)),\n \t\t\t 0, 1, 1);\n \n-\tif (! memory_address_p (TYPE_MODE (part_type), XEXP (target, 0)))\n-\t  target = change_address (target, TYPE_MODE (part_type), NULL_RTX);\n \tparts = tree_cons (to_be_saved,\n \t\t\t   build (RTL_EXPR, part_type, NULL_TREE,\n-\t\t\t\t  (tree) target),\n+\t\t\t\t  (tree) validize_mem (target)),\n \t\t\t   parts);\n-\tstore_expr (TREE_PURPOSE (parts), RTL_EXPR_RTL (TREE_VALUE (parts)), 0);\n+\tstore_expr (TREE_PURPOSE (parts),\n+\t\t    RTL_EXPR_RTL (TREE_VALUE (parts)), 0);\n       }\n   return parts;\n }\n@@ -6342,12 +6339,13 @@ expand_expr (exp, target, tmode, modifier)\n \t    abort ();\n \t  addr = XEXP (DECL_RTL (exp), 0);\n \t  if (GET_CODE (addr) == MEM)\n-\t    addr = change_address (addr, Pmode,\n-\t\t\t\t   fix_lexical_addr (XEXP (addr, 0), exp));\n+\t    addr\n+\t      = replace_equiv_address (addr,\n+\t\t\t\t       fix_lexical_addr (XEXP (addr, 0), exp));\n \t  else\n \t    addr = fix_lexical_addr (addr, exp);\n \n-\t  temp = change_address (DECL_RTL (exp), mode, addr);\n+\t  temp = replace_equiv_address (DECL_RTL (exp), addr);\n \t}\n \n       /* This is the case of an array whose size is to be determined\n@@ -6356,8 +6354,7 @@ expand_expr (exp, target, tmode, modifier)\n \n       else if (GET_CODE (DECL_RTL (exp)) == MEM\n \t       && GET_CODE (XEXP (DECL_RTL (exp), 0)) == REG)\n-\ttemp = change_address (DECL_RTL (exp), GET_MODE (DECL_RTL (exp)),\n-\t\t\t       XEXP (DECL_RTL (exp), 0));\n+\ttemp = validize_mem (DECL_RTL (exp));\n \n       /* If DECL_RTL is memory, we are in the normal case and either\n \t the address is not valid or it is not a register and -fforce-addr\n@@ -6371,8 +6368,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t       XEXP (DECL_RTL (exp), 0))\n \t\t   || (flag_force_addr\n \t\t       && GET_CODE (XEXP (DECL_RTL (exp), 0)) != REG)))\n-\ttemp = change_address (DECL_RTL (exp), VOIDmode,\n-\t\t\t       copy_rtx (XEXP (DECL_RTL (exp), 0)));\n+\ttemp = replace_equiv_address (DECL_RTL (exp),\n+\t\t\t\t      copy_rtx (XEXP (DECL_RTL (exp), 0)));\n \n       /* If we got something, return it.  But first, set the alignment\n \t if the address is a register.  */\n@@ -6441,8 +6438,8 @@ expand_expr (exp, target, tmode, modifier)\n \t  && (! memory_address_p (mode, XEXP (TREE_CST_RTL (exp), 0))\n \t      || (flag_force_addr\n \t\t  && GET_CODE (XEXP (TREE_CST_RTL (exp), 0)) != REG)))\n-\treturn change_address (TREE_CST_RTL (exp), VOIDmode,\n-\t\t\t       copy_rtx (XEXP (TREE_CST_RTL (exp), 0)));\n+\treturn replace_equiv_address (TREE_CST_RTL (exp),\n+\t\t\t\t      copy_rtx (XEXP (TREE_CST_RTL (exp), 0)));\n       return TREE_CST_RTL (exp);\n \n     case EXPR_WITH_FILE_LOCATION:\n@@ -6491,8 +6488,9 @@ expand_expr (exp, target, tmode, modifier)\n \t    }\n \t  if (temp == 0 || GET_CODE (temp) != MEM)\n \t    abort ();\n-\t  return change_address (temp, mode,\n-\t\t\t\t fix_lexical_addr (XEXP (temp, 0), exp));\n+\t  return\n+\t    replace_equiv_address (temp,\n+\t\t\t\t   fix_lexical_addr (XEXP (temp, 0), exp));\n \t}\n       if (SAVE_EXPR_RTL (exp) == 0)\n \t{\n@@ -6747,13 +6745,9 @@ expand_expr (exp, target, tmode, modifier)\n \n \t  if (modifier != EXPAND_CONST_ADDRESS\n \t      && modifier != EXPAND_INITIALIZER\n-\t      && modifier != EXPAND_SUM\n-\t      && (! memory_address_p (GET_MODE (constructor),\n-\t\t\t\t      XEXP (constructor, 0))\n-\t\t  || (flag_force_addr\n-\t\t      && GET_CODE (XEXP (constructor, 0)) != REG)))\n-\t    constructor = change_address (constructor, VOIDmode,\n-\t\t\t\t\t  XEXP (constructor, 0));\n+\t      && modifier != EXPAND_SUM)\n+\t    constructor = validize_mem (constructor);\n+\n \t  return constructor;\n \t}\n       else\n@@ -7095,9 +7089,10 @@ expand_expr (exp, target, tmode, modifier)\n \t\tif (GET_CODE (XEXP (temp, 0)) == REG)\n \t\t  op0 = temp;\n \t\telse\n-\t\t  op0 = change_address (op0, mode1,\n-\t\t\t\t\tforce_reg (GET_MODE (XEXP (temp, 0)),\n-\t\t\t\t\t\t   XEXP (temp, 0)));\n+\t\t  op0 = (replace_equiv_address\n+\t\t\t (op0,\n+\t\t\t  force_reg (GET_MODE (XEXP (temp, 0)),\n+\t\t\t\t     XEXP (temp, 0))));\n \t\tbitpos = 0;\n \t      }\n \n@@ -9400,7 +9395,7 @@ expand_increment (exp, post, ignore)\n \t\t      : copy_to_reg (XEXP (op0, 0)));\n \t  rtx temp, result;\n \n-\t  op0 = change_address (op0, VOIDmode, addr);\n+\t  op0 = replace_equiv_address (op0, addr);\n \t  temp = force_reg (GET_MODE (op0), op0);\n \t  if (! (*insn_data[icode].operand[2].predicate) (op1, mode))\n \t    op1 = force_reg (mode, op1);"}, {"sha": "0e8f875113bda24aa084c7301ba4b22a9a3d4f3d", "filename": "gcc/expr.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -1154,6 +1154,12 @@ extern rtx change_address PARAMS ((rtx, enum machine_mode, rtx));\n    to MODE and its address offset by OFFSET bytes.  */\n extern rtx adjust_address PARAMS ((rtx, enum machine_mode, HOST_WIDE_INT));\n \n+/* Return a memory reference like MEMREF, but with its address changed to\n+   ADDR.  The caller is asserting that the actual piece of memory pointed\n+   to is the same, just the form of the address is being changed, such as\n+   by putting something into a register.  */\n+extern rtx replace_equiv_address PARAMS ((rtx, rtx));\n+\n /* Return a memory reference like MEMREF, but which is known to have a\n    valid address.  */\n extern rtx validize_mem PARAMS ((rtx));"}, {"sha": "4e0c4f8c2656b318d4b8af327d91fc3320aa83fb", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -2617,7 +2617,7 @@ fixup_stack_1 (x, insn)\n \t  seq = gen_sequence ();\n \t  end_sequence ();\n \t  emit_insn_before (seq, insn);\n-\t  return change_address (x, VOIDmode, temp);\n+\t  return replace_equiv_address (x, temp);\n \t}\n       return x;\n     }"}, {"sha": "5d3f18eba840b20a5755bce00932519d547e8baa", "filename": "gcc/regmove.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792760b9e9c015cabd3d5f1f7cf4942081f646d6/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=792760b9e9c015cabd3d5f1f7cf4942081f646d6", "patch": "@@ -2458,8 +2458,9 @@ combine_stack_adjustments_for_block (bb)\n \t      && ! reg_mentioned_p (stack_pointer_rtx, src)\n \t      && memory_address_p (GET_MODE (dest), stack_pointer_rtx)\n \t      && validate_change (insn, &SET_DEST (set),\n-\t\t\t\t  change_address (dest, VOIDmode,\n-\t\t\t\t\t\t  stack_pointer_rtx), 0))\n+\t\t\t\t  replace_equiv_address (dest,\n+\t\t\t\t\t\t\t stack_pointer_rtx),\n+\t\t\t\t  0))\n \t    {\n \t      if (last_sp_set == bb->head)\n \t\tbb->head = NEXT_INSN (last_sp_set);"}]}