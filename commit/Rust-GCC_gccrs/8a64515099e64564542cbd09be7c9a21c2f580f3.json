{"sha": "8a64515099e64564542cbd09be7c9a21c2f580f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE2NDUxNTA5OWU2NDU2NDU0MmNiZDA5YmU3YzlhMjFjMmY1ODBmMw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-11-06T19:50:50Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-11-06T19:50:50Z"}, "message": "Reimplement diagnostic_show_locus, introducing rich_location classes\n\ngcc/ChangeLog:\n\t* diagnostic-color.c (color_dict): Eliminate \"caret\"; add \"range1\"\n\tand \"range2\".\n\t(parse_gcc_colors): Update comment to describe default GCC_COLORS.\n\t* diagnostic-core.h (warning_at_rich_loc): New declaration.\n\t(error_at_rich_loc): New declaration.\n\t(permerror_at_rich_loc): New declaration.\n\t(inform_at_rich_loc): New declaration.\n\t* diagnostic-show-locus.c (adjust_line): Delete.\n\t(struct point_state): New struct.\n\t(class colorizer): New class.\n\t(class layout_point): New class.\n\t(class layout_range): New class.\n\t(struct line_bounds): New.\n\t(class layout): New class.\n\t(colorizer::colorizer): New ctor.\n\t(colorizer::~colorizer): New dtor.\n\t(layout::layout): New ctor.\n\t(layout::print_source_line): New method.\n\t(layout::print_annotation_line): New method.\n\t(layout::get_state_at_point): New method.\n\t(layout::get_x_bound_for_row): New method.\n\t(diagnostic_show_locus): Reimplement in terms of class layout.\n\t(diagnostic_print_caret_line): Delete.\n\t* diagnostic.c (diagnostic_initialize): Replace\n\tMAX_LOCATIONS_PER_MESSAGE with rich_location::MAX_RANGES.\n\t(diagnostic_set_info_translated): Convert param from location_t\n\tto rich_location *.  Eliminate calls to set_location on the\n\tmessage in favor of storing the rich_location ptr there.\n\t(diagnostic_set_info): Convert param from location_t to\n\trich_location *.\n\t(diagnostic_build_prefix): Break out array into...\n\t(diagnostic_kind_color): New variable.\n\t(diagnostic_get_color_for_kind): New function.\n\t(diagnostic_report_diagnostic): Colorize the option_text\n\tusing the color for the severity.\n\t(diagnostic_append_note): Update for change in signature of\n\tdiagnostic_set_info.\n\t(diagnostic_append_note_at_rich_loc): New function.\n\t(emit_diagnostic): Update for change in signature of\n\tdiagnostic_set_info.\n\t(inform): Likewise.\n\t(inform_at_rich_loc): New function.\n\t(inform_n): Update for change in signature of diagnostic_set_info.\n\t(warning): Likewise.\n\t(warning_at): Likewise.\n\t(warning_at_rich_loc): New function.\n\t(warning_n): Update for change in signature of diagnostic_set_info.\n\t(pedwarn): Likewise.\n\t(permerror): Likewise.\n\t(permerror_at_rich_loc): New function.\n\t(error): Update for change in signature of diagnostic_set_info.\n\t(error_n): Likewise.\n\t(error_at): Likewise.\n\t(error_at_rich_loc): New function.\n\t(sorry): Update for change in signature of diagnostic_set_info.\n\t(fatal_error): Likewise.\n\t(internal_error): Likewise.\n\t(internal_error_no_backtrace): Likewise.\n\t(source_range::debug): New function.\n\t* diagnostic.h (struct diagnostic_info): Eliminate field\n\t\"override_column\".  Add field \"richloc\".\n\t(struct diagnostic_context): Add field \"colorize_source_p\".\n\t(diagnostic_override_column): Delete.\n\t(diagnostic_set_info): Convert param from location_t to\n\trich_location *.\n\t(diagnostic_set_info_translated): Likewise.\n\t(diagnostic_append_note_at_rich_loc): New function.\n\t(diagnostic_num_locations): New function.\n\t(diagnostic_expand_location): Get the location from the\n\trich_location.\n\t(diagnostic_print_caret_line): Delete.\n\t(diagnostic_get_color_for_kind): New declaration.\n\t* genmatch.c (linemap_client_expand_location_to_spelling_point): New.\n\t(error_cb): Update for change in signature of \"error\" callback.\n\t(fatal_at): Likewise.\n\t(warning_at): Likewise.\n\t* input.c (linemap_client_expand_location_to_spelling_point): New.\n\t* pretty-print.c (text_info::set_range): New method.\n\t(text_info::get_location): New method.\n\t* pretty-print.h (MAX_LOCATIONS_PER_MESSAGE): Eliminate this macro.\n\t(struct text_info): Eliminate \"locations\" array in favor of\n\t\"m_richloc\", a rich_location *.\n\t(textinfo::set_location): Add a \"caret_p\" param, and reimplement\n\tin terms of a call to set_range.\n\t(textinfo::get_location): Eliminate inline implementation in favor of\n\tan out-of-line reimplementation.\n\t(textinfo::set_range): New method.\n\t* rtl-error.c (diagnostic_for_asm): Update for change in signature\n\tof diagnostic_set_info.\n\t* tree-diagnostic.c (default_tree_printer): Update for new\n\t\"caret_p\" param for textinfo::set_location.\n\t* tree-pretty-print.c (percent_K_format): Likewise.\n\ngcc/c-family/ChangeLog:\n\t* c-common.c (c_cpp_error): Convert parameter from location_t to\n\trich_location *.  Eliminate the \"column_override\" parameter and\n\tthe call to diagnostic_override_column.\n\tUpdate the \"done_lexing\" clause to set range 0\n\ton the rich_location, rather than overwriting a location_t.\n\t* c-common.h (c_cpp_error): Convert parameter from location_t to\n\trich_location *.  Eliminate the \"column_override\" parameter.\n\ngcc/c/ChangeLog:\n\t* c-decl.c (warn_defaults_to): Update for change in signature\n\tof diagnostic_set_info.\n\t* c-errors.c (pedwarn_c99): Likewise.\n\t(pedwarn_c90): Likewise.\n\t* c-objc-common.c (c_tree_printer): Update for new \"caret_p\" param\n\tfor textinfo::set_location.\n\ngcc/cp/ChangeLog:\n\t* error.c (cp_printer): Update for new \"caret_p\" param for\n\ttextinfo::set_location.\n\t(pedwarn_cxx98): Update for change in signature of\n\tdiagnostic_set_info.\n\ngcc/fortran/ChangeLog:\n\t* cpp.c (cb_cpp_error): Convert parameter from location_t to\n\trich_location *.  Eliminate the \"column_override\" parameter.\n\t* error.c (gfc_warning): Update for change in signature of\n\tdiagnostic_set_info.\n\t(gfc_format_decoder): Update handling of %C/%L for changes\n\tto struct text_info.\n\t(gfc_diagnostic_starter): Use richloc when determining whether to\n\tprint one locus or two.  When handling a location that will\n\tinvolve a call to diagnostic_show_locus, only attempt to print the\n\tlocus for the primary location, and don't call into\n\tdiagnostic_print_caret_line.\n\t(gfc_warning_now_at): Update for change in signature of\n\tdiagnostic_set_info.\n\t(gfc_warning_now): Likewise.\n\t(gfc_error_now): Likewise.\n\t(gfc_fatal_error): Likewise.\n\t(gfc_error): Likewise.\n\t(gfc_internal_error): Likewise.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/diagnostic-test-show-locus-bw.c: New file.\n\t* gcc.dg/plugin/diagnostic-test-show-locus-color.c: New file.\n\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c: New file.\n\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add the above.\n\t* lib/gcc-dg.exp: Load multiline.exp.\n\nlibcpp/ChangeLog:\n\t* errors.c (cpp_diagnostic): Update for change in signature\n\tof \"error\" callback.\n\t(cpp_diagnostic_with_line): Likewise, calling override_column\n\ton the rich_location.\n\t* include/cpplib.h (struct cpp_callbacks): Within \"error\"\n\tcallback, convert param from source_location to rich_location *,\n\tand drop column_override param.\n\t* include/line-map.h (struct source_range): New struct.\n\t(struct location_range): New struct.\n\t(class rich_location): New class.\n\t(linemap_client_expand_location_to_spelling_point): New declaration.\n\t* line-map.c (rich_location::rich_location): New ctors.\n\t(rich_location::lazily_expand_location): New method.\n\t(rich_location::override_column): New method.\n\t(rich_location::add_range): New methods.\n\t(rich_location::set_range): New method.\n\nFrom-SVN: r229884", "tree": {"sha": "de618a78e7240cd1dec5c9b663ed1464c2775915", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de618a78e7240cd1dec5c9b663ed1464c2775915"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a64515099e64564542cbd09be7c9a21c2f580f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a64515099e64564542cbd09be7c9a21c2f580f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a64515099e64564542cbd09be7c9a21c2f580f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a64515099e64564542cbd09be7c9a21c2f580f3/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "277ec793cbb5053626a75bcfdb82af03fc735b3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/277ec793cbb5053626a75bcfdb82af03fc735b3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/277ec793cbb5053626a75bcfdb82af03fc735b3e"}], "stats": {"total": 2450, "additions": 2161, "deletions": 289}, "files": [{"sha": "7b922364abce1a070035563c1159109c750c52da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -1,3 +1,98 @@\n+2015-11-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* diagnostic-color.c (color_dict): Eliminate \"caret\"; add \"range1\"\n+\tand \"range2\".\n+\t(parse_gcc_colors): Update comment to describe default GCC_COLORS.\n+\t* diagnostic-core.h (warning_at_rich_loc): New declaration.\n+\t(error_at_rich_loc): New declaration.\n+\t(permerror_at_rich_loc): New declaration.\n+\t(inform_at_rich_loc): New declaration.\n+\t* diagnostic-show-locus.c (adjust_line): Delete.\n+\t(struct point_state): New struct.\n+\t(class colorizer): New class.\n+\t(class layout_point): New class.\n+\t(class layout_range): New class.\n+\t(struct line_bounds): New.\n+\t(class layout): New class.\n+\t(colorizer::colorizer): New ctor.\n+\t(colorizer::~colorizer): New dtor.\n+\t(layout::layout): New ctor.\n+\t(layout::print_source_line): New method.\n+\t(layout::print_annotation_line): New method.\n+\t(layout::get_state_at_point): New method.\n+\t(layout::get_x_bound_for_row): New method.\n+\t(diagnostic_show_locus): Reimplement in terms of class layout.\n+\t(diagnostic_print_caret_line): Delete.\n+\t* diagnostic.c (diagnostic_initialize): Replace\n+\tMAX_LOCATIONS_PER_MESSAGE with rich_location::MAX_RANGES.\n+\t(diagnostic_set_info_translated): Convert param from location_t\n+\tto rich_location *.  Eliminate calls to set_location on the\n+\tmessage in favor of storing the rich_location ptr there.\n+\t(diagnostic_set_info): Convert param from location_t to\n+\trich_location *.\n+\t(diagnostic_build_prefix): Break out array into...\n+\t(diagnostic_kind_color): New variable.\n+\t(diagnostic_get_color_for_kind): New function.\n+\t(diagnostic_report_diagnostic): Colorize the option_text\n+\tusing the color for the severity.\n+\t(diagnostic_append_note): Update for change in signature of\n+\tdiagnostic_set_info.\n+\t(diagnostic_append_note_at_rich_loc): New function.\n+\t(emit_diagnostic): Update for change in signature of\n+\tdiagnostic_set_info.\n+\t(inform): Likewise.\n+\t(inform_at_rich_loc): New function.\n+\t(inform_n): Update for change in signature of diagnostic_set_info.\n+\t(warning): Likewise.\n+\t(warning_at): Likewise.\n+\t(warning_at_rich_loc): New function.\n+\t(warning_n): Update for change in signature of diagnostic_set_info.\n+\t(pedwarn): Likewise.\n+\t(permerror): Likewise.\n+\t(permerror_at_rich_loc): New function.\n+\t(error): Update for change in signature of diagnostic_set_info.\n+\t(error_n): Likewise.\n+\t(error_at): Likewise.\n+\t(error_at_rich_loc): New function.\n+\t(sorry): Update for change in signature of diagnostic_set_info.\n+\t(fatal_error): Likewise.\n+\t(internal_error): Likewise.\n+\t(internal_error_no_backtrace): Likewise.\n+\t(source_range::debug): New function.\n+\t* diagnostic.h (struct diagnostic_info): Eliminate field\n+\t\"override_column\".  Add field \"richloc\".\n+\t(struct diagnostic_context): Add field \"colorize_source_p\".\n+\t(diagnostic_override_column): Delete.\n+\t(diagnostic_set_info): Convert param from location_t to\n+\trich_location *.\n+\t(diagnostic_set_info_translated): Likewise.\n+\t(diagnostic_append_note_at_rich_loc): New function.\n+\t(diagnostic_num_locations): New function.\n+\t(diagnostic_expand_location): Get the location from the\n+\trich_location.\n+\t(diagnostic_print_caret_line): Delete.\n+\t(diagnostic_get_color_for_kind): New declaration.\n+\t* genmatch.c (linemap_client_expand_location_to_spelling_point): New.\n+\t(error_cb): Update for change in signature of \"error\" callback.\n+\t(fatal_at): Likewise.\n+\t(warning_at): Likewise.\n+\t* input.c (linemap_client_expand_location_to_spelling_point): New.\n+\t* pretty-print.c (text_info::set_range): New method.\n+\t(text_info::get_location): New method.\n+\t* pretty-print.h (MAX_LOCATIONS_PER_MESSAGE): Eliminate this macro.\n+\t(struct text_info): Eliminate \"locations\" array in favor of\n+\t\"m_richloc\", a rich_location *.\n+\t(textinfo::set_location): Add a \"caret_p\" param, and reimplement\n+\tin terms of a call to set_range.\n+\t(textinfo::get_location): Eliminate inline implementation in favor of\n+\tan out-of-line reimplementation.\n+\t(textinfo::set_range): New method.\n+\t* rtl-error.c (diagnostic_for_asm): Update for change in signature\n+\tof diagnostic_set_info.\n+\t* tree-diagnostic.c (default_tree_printer): Update for new\n+\t\"caret_p\" param for textinfo::set_location.\n+\t* tree-pretty-print.c (percent_K_format): Likewise.\n+\n 2015-11-06  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \tProperly apply."}, {"sha": "e6d632d8b9763f875969ec12843dc99fc9eb7bc7", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -1,3 +1,13 @@\n+2015-11-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-common.c (c_cpp_error): Convert parameter from location_t to\n+\trich_location *.  Eliminate the \"column_override\" parameter and\n+\tthe call to diagnostic_override_column.\n+\tUpdate the \"done_lexing\" clause to set range 0\n+\ton the rich_location, rather than overwriting a location_t.\n+\t* c-common.h (c_cpp_error): Convert parameter from location_t to\n+\trich_location *.  Eliminate the \"column_override\" parameter.\n+\n 2015-11-05  Cesar Philippidis  <cesar@codesourcery.com>\n \t    Thomas Schwinge  <thomas@codesourcery.com>\n \t    James Norris  <jnorris@codesourcery.com>"}, {"sha": "b7ae7541d43d0945fa976c7b45a935c69a0ebc8a", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -10543,15 +10543,14 @@ c_option_controlling_cpp_error (int reason)\n /* Callback from cpp_error for PFILE to print diagnostics from the\n    preprocessor.  The diagnostic is of type LEVEL, with REASON set\n    to the reason code if LEVEL is represents a warning, at location\n-   LOCATION unless this is after lexing and the compiler's location\n-   should be used instead, with column number possibly overridden by\n-   COLUMN_OVERRIDE if not zero; MSG is the translated message and AP\n+   RICHLOC unless this is after lexing and the compiler's location\n+   should be used instead; MSG is the translated message and AP\n    the arguments.  Returns true if a diagnostic was emitted, false\n    otherwise.  */\n \n bool\n c_cpp_error (cpp_reader *pfile ATTRIBUTE_UNUSED, int level, int reason,\n-\t     location_t location, unsigned int column_override,\n+\t     rich_location *richloc,\n \t     const char *msg, va_list *ap)\n {\n   diagnostic_info diagnostic;\n@@ -10592,11 +10591,11 @@ c_cpp_error (cpp_reader *pfile ATTRIBUTE_UNUSED, int level, int reason,\n       gcc_unreachable ();\n     }\n   if (done_lexing)\n-    location = input_location;\n+    richloc->set_range (0,\n+\t\t\tsource_range::from_location (input_location),\n+\t\t\ttrue, true);\n   diagnostic_set_info_translated (&diagnostic, msg, ap,\n-\t\t\t\t  location, dlevel);\n-  if (column_override)\n-    diagnostic_override_column (&diagnostic, column_override);\n+\t\t\t\t  richloc, dlevel);\n   diagnostic_override_option_index (&diagnostic,\n                                     c_option_controlling_cpp_error (reason));\n   ret = report_diagnostic (&diagnostic);"}, {"sha": "c82545405e4b33b5388bf404473c52e462eeb949", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -995,9 +995,9 @@ extern void init_c_lex (void);\n \n extern void c_cpp_builtins (cpp_reader *);\n extern void c_cpp_builtins_optimize_pragma (cpp_reader *, tree, tree);\n-extern bool c_cpp_error (cpp_reader *, int, int, location_t, unsigned int,\n+extern bool c_cpp_error (cpp_reader *, int, int, rich_location *,\n \t\t\t const char *, va_list *)\n-     ATTRIBUTE_GCC_DIAG(6,0);\n+     ATTRIBUTE_GCC_DIAG(5,0);\n extern int c_common_has_attribute (cpp_reader *);\n \n extern bool parse_optimize_options (tree, bool);"}, {"sha": "991d0d34851648ee01a95cc3009343b060184b56", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -1,3 +1,12 @@\n+2015-11-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-decl.c (warn_defaults_to): Update for change in signature\n+\tof diagnostic_set_info.\n+\t* c-errors.c (pedwarn_c99): Likewise.\n+\t(pedwarn_c90): Likewise.\n+\t* c-objc-common.c (c_tree_printer): Update for new \"caret_p\" param\n+\tfor textinfo::set_location.\n+\n 2015-11-05  Cesar Philippidis  <cesar@codesourcery.com>\n \t    Thomas Schwinge  <thomas@codesourcery.com>\n \t    James Norris  <jnorris@codesourcery.com>"}, {"sha": "e9bdceb8a99e8c72980c423b6463083c07114fe5", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -5285,9 +5285,10 @@ warn_defaults_to (location_t location, int opt, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n+  rich_location richloc (location);\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, location,\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc,\n                        flag_isoc99 ? DK_PEDWARN : DK_WARNING);\n   diagnostic.option_index = opt;\n   report_diagnostic (&diagnostic);"}, {"sha": "b458957474d58b895bfea549aaec6b0071374a05", "filename": "gcc/c/c-errors.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc%2Fc-errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc%2Fc-errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-errors.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -41,13 +41,14 @@ pedwarn_c99 (location_t location, int opt, const char *gmsgid, ...)\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool warned = false;\n+  rich_location richloc (location);\n \n   va_start (ap, gmsgid);\n   /* If desired, issue the C99/C11 compat warning, which is more specific\n      than -pedantic.  */\n   if (warn_c99_c11_compat > 0)\n     {\n-      diagnostic_set_info (&diagnostic, gmsgid, &ap, location,\n+      diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc,\n \t\t\t   (pedantic && !flag_isoc11)\n \t\t\t   ? DK_PEDWARN : DK_WARNING);\n       diagnostic.option_index = OPT_Wc99_c11_compat;\n@@ -59,7 +60,7 @@ pedwarn_c99 (location_t location, int opt, const char *gmsgid, ...)\n   /* For -pedantic outside C11, issue a pedwarn.  */\n   else if (pedantic && !flag_isoc11)\n     {\n-      diagnostic_set_info (&diagnostic, gmsgid, &ap, location, DK_PEDWARN);\n+      diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_PEDWARN);\n       diagnostic.option_index = opt;\n       warned = report_diagnostic (&diagnostic);\n     }\n@@ -79,6 +80,7 @@ pedwarn_c90 (location_t location, int opt, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n+  rich_location richloc (location);\n \n   va_start (ap, gmsgid);\n   /* Warnings such as -Wvla are the most specific ones.  */\n@@ -89,7 +91,7 @@ pedwarn_c90 (location_t location, int opt, const char *gmsgid, ...)\n         goto out;\n       else if (opt_var > 0)\n \t{\n-\t  diagnostic_set_info (&diagnostic, gmsgid, &ap, location,\n+\t  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc,\n \t\t\t       (pedantic && !flag_isoc99)\n \t\t\t       ? DK_PEDWARN : DK_WARNING);\n \t  diagnostic.option_index = opt;\n@@ -101,7 +103,7 @@ pedwarn_c90 (location_t location, int opt, const char *gmsgid, ...)\n      specific than -pedantic.  */\n   if (warn_c90_c99_compat > 0)\n     {\n-      diagnostic_set_info (&diagnostic, gmsgid, &ap, location,\n+      diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc,\n \t\t\t   (pedantic && !flag_isoc99)\n \t\t\t   ? DK_PEDWARN : DK_WARNING);\n       diagnostic.option_index = OPT_Wc90_c99_compat;\n@@ -113,7 +115,7 @@ pedwarn_c90 (location_t location, int opt, const char *gmsgid, ...)\n   /* For -pedantic outside C99, issue a pedwarn.  */\n   else if (pedantic && !flag_isoc99)\n     {\n-      diagnostic_set_info (&diagnostic, gmsgid, &ap, location, DK_PEDWARN);\n+      diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_PEDWARN);\n       diagnostic.option_index = opt;\n       report_diagnostic (&diagnostic);\n     }"}, {"sha": "270b03da5ca8d78e8d6fa71c9d55c4d4902e6b2d", "filename": "gcc/c/c-objc-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -100,7 +100,7 @@ c_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n     {\n       t = va_arg (*text->args_ptr, tree);\n       if (set_locus)\n-\ttext->set_location (0, DECL_SOURCE_LOCATION (t));\n+\ttext->set_location (0, DECL_SOURCE_LOCATION (t), true);\n     }\n \n   switch (*spec)"}, {"sha": "fc92a5f0561c05e37bd2f3c538bf338a5263c62b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -1,3 +1,10 @@\n+2015-11-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* error.c (cp_printer): Update for new \"caret_p\" param for\n+\ttextinfo::set_location.\n+\t(pedwarn_cxx98): Update for change in signature of\n+\tdiagnostic_set_info.\n+\n 2015-11-06  Jason Merrill  <jason@redhat.com>\n \n \tSupport non-type constrained-type-specifiers."}, {"sha": "286389c8aea657074b00e614c020a0d42afc4f3a", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -3563,7 +3563,7 @@ cp_printer (pretty_printer *pp, text_info *text, const char *spec,\n \n   pp_string (pp, result);\n   if (set_locus && t != NULL)\n-    text->set_location (0, location_of (t));\n+    text->set_location (0, location_of (t), true);\n   return true;\n #undef next_tree\n #undef next_tcode\n@@ -3677,9 +3677,10 @@ pedwarn_cxx98 (location_t location, int opt, const char *gmsgid, ...)\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n+  rich_location richloc (location);\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, location,\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc,\n \t\t       (cxx_dialect == cxx98) ? DK_PEDWARN : DK_WARNING);\n   diagnostic.option_index = opt;\n   ret = report_diagnostic (&diagnostic);"}, {"sha": "d848dfca52e62d0744ae2da07e7ffaa12277a282", "filename": "gcc/diagnostic-color.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fdiagnostic-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fdiagnostic-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-color.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -164,7 +164,8 @@ static struct color_cap color_dict[] =\n   { \"warning\", SGR_SEQ (COLOR_BOLD COLOR_SEPARATOR COLOR_FG_MAGENTA),\n \t       7, false },\n   { \"note\", SGR_SEQ (COLOR_BOLD COLOR_SEPARATOR COLOR_FG_CYAN), 4, false },\n-  { \"caret\", SGR_SEQ (COLOR_BOLD COLOR_SEPARATOR COLOR_FG_GREEN), 5, false },\n+  { \"range1\", SGR_SEQ (COLOR_FG_GREEN), 6, false },\n+  { \"range2\", SGR_SEQ (COLOR_FG_BLUE), 6, false },\n   { \"locus\", SGR_SEQ (COLOR_BOLD), 5, false },\n   { \"quote\", SGR_SEQ (COLOR_BOLD), 5, false },\n   { NULL, NULL, 0, false }\n@@ -195,7 +196,7 @@ colorize_stop (bool show_color)\n }\n \n /* Parse GCC_COLORS.  The default would look like:\n-   GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'\n+   GCC_COLORS='error=01;31:warning=01;35:note=01;36:range1=32:range2=34;locus=01:quote=01'\n    No character escaping is needed or supported.  */\n static bool\n parse_gcc_colors (void)"}, {"sha": "749c847c9ce8072df229f30e4220df2bdd92845b", "filename": "gcc/diagnostic-core.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fdiagnostic-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fdiagnostic-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-core.h?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -63,18 +63,26 @@ extern bool warning_n (location_t, int, int, const char *, const char *, ...)\n     ATTRIBUTE_GCC_DIAG(4,6) ATTRIBUTE_GCC_DIAG(5,6);\n extern bool warning_at (location_t, int, const char *, ...)\n     ATTRIBUTE_GCC_DIAG(3,4);\n+extern bool warning_at_rich_loc (rich_location *, int, const char *, ...)\n+    ATTRIBUTE_GCC_DIAG(3,4);\n extern void error (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n extern void error_n (location_t, int, const char *, const char *, ...)\n     ATTRIBUTE_GCC_DIAG(3,5) ATTRIBUTE_GCC_DIAG(4,5);\n extern void error_at (location_t, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n+extern void error_at_rich_loc (rich_location *, const char *, ...)\n+  ATTRIBUTE_GCC_DIAG(2,3);\n extern void fatal_error (location_t, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3)\n      ATTRIBUTE_NORETURN;\n /* Pass one of the OPT_W* from options.h as the second parameter.  */\n extern bool pedwarn (location_t, int, const char *, ...)\n      ATTRIBUTE_GCC_DIAG(3,4);\n extern bool permerror (location_t, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n+extern bool permerror_at_rich_loc (rich_location *, const char *,\n+\t\t\t\t   ...) ATTRIBUTE_GCC_DIAG(2,3);\n extern void sorry (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n extern void inform (location_t, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n+extern void inform_at_rich_loc (rich_location *, const char *,\n+\t\t\t\t...) ATTRIBUTE_GCC_DIAG(2,3);\n extern void inform_n (location_t, int, const char *, const char *, ...)\n     ATTRIBUTE_GCC_DIAG(3,5) ATTRIBUTE_GCC_DIAG(4,5);\n extern void verbatim (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);"}, {"sha": "22203cdbaa380d88aef3f8f2b38ea265d6f08d13", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 655, "deletions": 100, "changes": 755, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -36,131 +36,686 @@ along with GCC; see the file COPYING3.  If not see\n # include <sys/ioctl.h>\n #endif\n \n-/* If LINE is longer than MAX_WIDTH, and COLUMN is not smaller than\n-   MAX_WIDTH by some margin, then adjust the start of the line such\n-   that the COLUMN is smaller than MAX_WIDTH minus the margin.  The\n-   margin is either CARET_LINE_MARGIN characters or the difference\n-   between the column and the length of the line, whatever is smaller.\n-   The length of LINE is given by LINE_WIDTH.  */\n-static const char *\n-adjust_line (const char *line, int line_width,\n-\t     int max_width, int *column_p)\n-{\n-  int right_margin = CARET_LINE_MARGIN;\n-  int column = *column_p;\n-\n-  gcc_checking_assert (line_width >= column);\n-  right_margin = MIN (line_width - column, right_margin);\n-  right_margin = max_width - right_margin;\n-  if (line_width >= max_width && column > right_margin)\n+/* Classes for rendering source code and diagnostics, within an\n+   anonymous namespace.\n+   The work is done by \"class layout\", which embeds and uses\n+   \"class colorizer\" and \"class layout_range\" to get things done.  */\n+\n+namespace {\n+\n+/* The state at a given point of the source code, assuming that we're\n+   in a range: which range are we in, and whether we should draw a caret at\n+   this point.  */\n+\n+struct point_state\n+{\n+  int range_idx;\n+  bool draw_caret_p;\n+};\n+\n+/* A class to inject colorization codes when printing the diagnostic locus.\n+\n+   It has one kind of colorization for each of:\n+     - normal text\n+     - range 0 (the \"primary location\")\n+     - range 1\n+     - range 2\n+\n+   The class caches the lookup of the color codes for the above.\n+\n+   The class also has responsibility for tracking which of the above is\n+   active, filtering out unnecessary changes.  This allows\n+   layout::print_source_line and layout::print_annotation_line\n+   to simply request a colorization code for *every* character they print,\n+   via this class, and have the filtering be done for them here.  */\n+\n+class colorizer\n+{\n+ public:\n+  colorizer (diagnostic_context *context,\n+\t     const diagnostic_info *diagnostic);\n+  ~colorizer ();\n+\n+  void set_range (int range_idx) { set_state (range_idx); }\n+  void set_normal_text () { set_state (STATE_NORMAL_TEXT); }\n+\n+ private:\n+  void set_state (int state);\n+  void begin_state (int state);\n+  void finish_state (int state);\n+\n+ private:\n+  static const int STATE_NORMAL_TEXT = -1;\n+\n+  diagnostic_context *m_context;\n+  const diagnostic_info *m_diagnostic;\n+  int m_current_state;\n+  const char *m_caret_cs;\n+  const char *m_caret_ce;\n+  const char *m_range1_cs;\n+  const char *m_range2_cs;\n+  const char *m_range_ce;\n+};\n+\n+/* A point within a layout_range; similar to an expanded_location,\n+   but after filtering on file.  */\n+\n+class layout_point\n+{\n+ public:\n+  layout_point (const expanded_location &exploc)\n+  : m_line (exploc.line),\n+    m_column (exploc.column) {}\n+\n+  int m_line;\n+  int m_column;\n+};\n+\n+/* A class for use by \"class layout\" below: a filtered location_range.  */\n+\n+class layout_range\n+{\n+ public:\n+  layout_range (const location_range *loc_range);\n+\n+  bool contains_point (int row, int column) const;\n+\n+  layout_point m_start;\n+  layout_point m_finish;\n+  bool m_show_caret_p;\n+  layout_point m_caret;\n+};\n+\n+/* A struct for use by layout::print_source_line for telling\n+   layout::print_annotation_line the extents of the source line that\n+   it printed, so that underlines can be clipped appropriately.  */\n+\n+struct line_bounds\n+{\n+  int m_first_non_ws;\n+  int m_last_non_ws;\n+};\n+\n+/* A class to control the overall layout when printing a diagnostic.\n+\n+   The layout is determined within the constructor.\n+   It is then printed by repeatedly calling the \"print_source_line\"\n+   and \"print_annotation_line\" methods.\n+\n+   We assume we have disjoint ranges.  */\n+\n+class layout\n+{\n+ public:\n+  layout (diagnostic_context *context,\n+\t  const diagnostic_info *diagnostic);\n+\n+  int get_first_line () const { return m_first_line; }\n+  int get_last_line () const { return m_last_line; }\n+\n+  bool print_source_line (int row, line_bounds *lbounds_out);\n+  void print_annotation_line (int row, const line_bounds lbounds);\n+\n+ private:\n+  bool\n+  get_state_at_point (/* Inputs.  */\n+\t\t      int row, int column,\n+\t\t      int first_non_ws, int last_non_ws,\n+\t\t      /* Outputs.  */\n+\t\t      point_state *out_state);\n+\n+  int\n+  get_x_bound_for_row (int row, int caret_column,\n+\t\t       int last_non_ws);\n+\n+ private:\n+  diagnostic_context *m_context;\n+  pretty_printer *m_pp;\n+  diagnostic_t m_diagnostic_kind;\n+  expanded_location m_exploc;\n+  colorizer m_colorizer;\n+  bool m_colorize_source_p;\n+  auto_vec <layout_range> m_layout_ranges;\n+  int m_first_line;\n+  int m_last_line;\n+  int m_x_offset;\n+};\n+\n+/* Implementation of \"class colorizer\".  */\n+\n+/* The constructor for \"colorizer\".  Lookup and store color codes for the\n+   different kinds of things we might need to print.  */\n+\n+colorizer::colorizer (diagnostic_context *context,\n+\t\t      const diagnostic_info *diagnostic) :\n+  m_context (context),\n+  m_diagnostic (diagnostic),\n+  m_current_state (STATE_NORMAL_TEXT)\n+{\n+  m_caret_ce = colorize_stop (pp_show_color (context->printer));\n+  m_range1_cs = colorize_start (pp_show_color (context->printer), \"range1\");\n+  m_range2_cs = colorize_start (pp_show_color (context->printer), \"range2\");\n+  m_range_ce = colorize_stop (pp_show_color (context->printer));\n+}\n+\n+/* The destructor for \"colorize\".  If colorization is on, print a code to\n+   turn it off.  */\n+\n+colorizer::~colorizer ()\n+{\n+  finish_state (m_current_state);\n+}\n+\n+/* Update state, printing color codes if necessary if there's a state\n+   change.  */\n+\n+void\n+colorizer::set_state (int new_state)\n+{\n+  if (m_current_state != new_state)\n     {\n-      line += column - right_margin;\n-      *column_p = right_margin;\n+      finish_state (m_current_state);\n+      m_current_state = new_state;\n+      begin_state (new_state);\n     }\n-  return line;\n }\n \n-/* Print the physical source line corresponding to the location of\n-   this diagnostic, and a caret indicating the precise column.  This\n-   function only prints two caret characters if the two locations\n-   given by DIAGNOSTIC are on the same line according to\n-   diagnostic_same_line().  */\n+/* Turn on any colorization for STATE.  */\n+\n void\n-diagnostic_show_locus (diagnostic_context * context,\n-\t\t       const diagnostic_info *diagnostic)\n+colorizer::begin_state (int state)\n {\n-  if (!context->show_caret\n-      || diagnostic_location (diagnostic, 0) <= BUILTINS_LOCATION\n-      || diagnostic_location (diagnostic, 0) == context->last_location)\n-    return;\n+  switch (state)\n+    {\n+    case STATE_NORMAL_TEXT:\n+      break;\n \n-  context->last_location = diagnostic_location (diagnostic, 0);\n-  expanded_location s0 = diagnostic_expand_location (diagnostic, 0);\n-  expanded_location s1 = { };\n-  /* Zero-initialized. This is checked later by diagnostic_print_caret_line.  */\n+    case 0:\n+      /* Make range 0 be the same color as the \"kind\" text\n+\t (error vs warning vs note).  */\n+      pp_string\n+\t(m_context->printer,\n+\t colorize_start (pp_show_color (m_context->printer),\n+\t\t\t diagnostic_get_color_for_kind (m_diagnostic->kind)));\n+      break;\n \n-  if (diagnostic_location (diagnostic, 1) > BUILTINS_LOCATION)\n-    s1 = diagnostic_expand_location (diagnostic, 1);\n+    case 1:\n+      pp_string (m_context->printer, m_range1_cs);\n+      break;\n \n-  diagnostic_print_caret_line (context, s0, s1,\n-\t\t\t       context->caret_chars[0],\n-\t\t\t       context->caret_chars[1]);\n+    case 2:\n+      pp_string (m_context->printer, m_range2_cs);\n+      break;\n+\n+    default:\n+      /* We don't expect more than 3 ranges per diagnostic.  */\n+      gcc_unreachable ();\n+      break;\n+    }\n }\n \n-/* Print (part) of the source line given by xloc1 with caret1 pointing\n-   at the column.  If xloc2.column != 0 and it fits within the same\n-   line as xloc1 according to diagnostic_same_line (), then caret2 is\n-   printed at xloc2.colum.  Otherwise, the caller has to set up things\n-   to print a second caret line for xloc2.  */\n+/* Turn off any colorization for STATE.  */\n+\n void\n-diagnostic_print_caret_line (diagnostic_context * context,\n-\t\t\t     expanded_location xloc1,\n-\t\t\t     expanded_location xloc2,\n-\t\t\t     char caret1, char caret2)\n-{\n-  if (!diagnostic_same_line (context, xloc1, xloc2))\n-    /* This will mean ignore xloc2.  */\n-    xloc2.column = 0;\n-  else if (xloc1.column == xloc2.column)\n-    xloc2.column++;\n-\n-  int cmax = MAX (xloc1.column, xloc2.column);\n+colorizer::finish_state (int state)\n+{\n+  switch (state)\n+    {\n+    case STATE_NORMAL_TEXT:\n+      break;\n+\n+    case 0:\n+      pp_string (m_context->printer, m_caret_ce);\n+      break;\n+\n+    default:\n+      /* Within a range.  */\n+      gcc_assert (state > 0);\n+      pp_string (m_context->printer, m_range_ce);\n+      break;\n+    }\n+}\n+\n+/* Implementation of class layout_range.  */\n+\n+/* The constructor for class layout_range.\n+   Initialize various layout_point fields from expanded_location\n+   equivalents; we've already filtered on file.  */\n+\n+layout_range::layout_range (const location_range *loc_range)\n+: m_start (loc_range->m_start),\n+  m_finish (loc_range->m_finish),\n+  m_show_caret_p (loc_range->m_show_caret_p),\n+  m_caret (loc_range->m_caret)\n+{\n+}\n+\n+/* Is (column, row) within the given range?\n+   We've already filtered on the file.\n+\n+   Ranges are closed (both limits are within the range).\n+\n+   Example A: a single-line range:\n+     start:  (col=22, line=2)\n+     finish: (col=38, line=2)\n+\n+  |00000011111111112222222222333333333344444444444\n+  |34567890123456789012345678901234567890123456789\n+--+-----------------------------------------------\n+01|bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n+02|bbbbbbbbbbbbbbbbbbbSwwwwwwwwwwwwwwwFaaaaaaaaaaa\n+03|aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+\n+   Example B: a multiline range with\n+     start:  (col=14, line=3)\n+     finish: (col=08, line=5)\n+\n+  |00000011111111112222222222333333333344444444444\n+  |34567890123456789012345678901234567890123456789\n+--+-----------------------------------------------\n+01|bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n+02|bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n+03|bbbbbbbbbbbSwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n+04|wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n+05|wwwwwFaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+06|aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+--+-----------------------------------------------\n+\n+   Legend:\n+   - 'b' indicates a point *before* the range\n+   - 'S' indicates the start of the range\n+   - 'w' indicates a point within the range\n+   - 'F' indicates the finish of the range (which is\n+\t within it).\n+   - 'a' indicates a subsequent point *after* the range.  */\n+\n+bool\n+layout_range::contains_point (int row, int column) const\n+{\n+  gcc_assert (m_start.m_line <= m_finish.m_line);\n+  /* ...but the equivalent isn't true for the columns;\n+     consider example B in the comment above.  */\n+\n+  if (row < m_start.m_line)\n+    /* Points before the first line of the range are\n+       outside it (corresponding to line 01 in example A\n+       and lines 01 and 02 in example B above).  */\n+    return false;\n+\n+  if (row == m_start.m_line)\n+    /* On same line as start of range (corresponding\n+       to line 02 in example A and line 03 in example B).  */\n+    {\n+      if (column < m_start.m_column)\n+\t/* Points on the starting line of the range, but\n+\t   before the column in which it begins.  */\n+\treturn false;\n+\n+      if (row < m_finish.m_line)\n+\t/* This is a multiline range; the point\n+\t   is within it (corresponds to line 03 in example B\n+\t   from column 14 onwards) */\n+\treturn true;\n+      else\n+\t{\n+\t  /* This is a single-line range.  */\n+\t  gcc_assert (row == m_finish.m_line);\n+\t  return column <= m_finish.m_column;\n+\t}\n+    }\n+\n+  /* The point is in a line beyond that containing the\n+     start of the range: lines 03 onwards in example A,\n+     and lines 04 onwards in example B.  */\n+  gcc_assert (row > m_start.m_line);\n+\n+  if (row > m_finish.m_line)\n+    /* The point is beyond the final line of the range\n+       (lines 03 onwards in example A, and lines 06 onwards\n+       in example B).  */\n+    return false;\n+\n+  if (row < m_finish.m_line)\n+    {\n+      /* The point is in a line that's fully within a multiline\n+\t range (e.g. line 04 in example B).  */\n+      gcc_assert (m_start.m_line < m_finish.m_line);\n+      return true;\n+    }\n+\n+  gcc_assert (row ==  m_finish.m_line);\n+\n+  return column <= m_finish.m_column;\n+}\n+\n+/* Given a source line LINE of length LINE_WIDTH, determine the width\n+   without any trailing whitespace.  */\n+\n+static int\n+get_line_width_without_trailing_whitespace (const char *line, int line_width)\n+{\n+  int result = line_width;\n+  while (result > 0)\n+    {\n+      char ch = line[result - 1];\n+      if (ch == ' ' || ch == '\\t')\n+\tresult--;\n+      else\n+\tbreak;\n+    }\n+  gcc_assert (result >= 0);\n+  gcc_assert (result <= line_width);\n+  gcc_assert (result == 0 ||\n+\t      (line[result - 1] != ' '\n+\t       && line[result -1] != '\\t'));\n+  return result;\n+}\n+\n+/* Implementation of class layout.  */\n+\n+/* Constructor for class layout.\n+\n+   Filter the ranges from the rich_location to those that we can\n+   sanely print, populating m_layout_ranges.\n+   Determine the range of lines that we will print.\n+   Determine m_x_offset, to ensure that the primary caret\n+   will fit within the max_width provided by the diagnostic_context.  */\n+\n+layout::layout (diagnostic_context * context,\n+\t\tconst diagnostic_info *diagnostic)\n+: m_context (context),\n+  m_pp (context->printer),\n+  m_diagnostic_kind (diagnostic->kind),\n+  m_exploc (diagnostic->richloc->lazily_expand_location ()),\n+  m_colorizer (context, diagnostic),\n+  m_colorize_source_p (context->colorize_source_p),\n+  m_layout_ranges (rich_location::MAX_RANGES),\n+  m_first_line (m_exploc.line),\n+  m_last_line  (m_exploc.line),\n+  m_x_offset (0)\n+{\n+  rich_location *richloc = diagnostic->richloc;\n+  for (unsigned int idx = 0; idx < richloc->get_num_locations (); idx++)\n+    {\n+      /* This diagnostic printer can only cope with \"sufficiently sane\" ranges.\n+\t Ignore any ranges that are awkward to handle.  */\n+      location_range *loc_range = richloc->get_range (idx);\n+\n+      /* If any part of the range isn't in the same file as the primary\n+\t location of this diagnostic, ignore the range.  */\n+      if (loc_range->m_start.file != m_exploc.file)\n+\tcontinue;\n+      if (loc_range->m_finish.file != m_exploc.file)\n+\tcontinue;\n+      if (loc_range->m_show_caret_p)\n+\tif (loc_range->m_caret.file != m_exploc.file)\n+\t  continue;\n+\n+      /* Passed all the tests; add the range to m_layout_ranges so that\n+\t it will be printed.  */\n+      layout_range ri (loc_range);\n+      m_layout_ranges.safe_push (ri);\n+\n+      /* Update m_first_line/m_last_line if necessary.  */\n+      if (loc_range->m_start.line < m_first_line)\n+\tm_first_line = loc_range->m_start.line;\n+      if (loc_range->m_finish.line > m_last_line)\n+\tm_last_line = loc_range->m_finish.line;\n+    }\n+\n+  /* Adjust m_x_offset.\n+     Center the primary caret to fit in max_width; all columns\n+     will be adjusted accordingly.  */\n+  int max_width = m_context->caret_max_width;\n   int line_width;\n-  const char *line = location_get_source_line (xloc1.file, xloc1.line,\n+  const char *line = location_get_source_line (m_exploc.file, m_exploc.line,\n \t\t\t\t\t       &line_width);\n-  if (line == NULL || cmax > line_width)\n-    return;\n+  if (line && m_exploc.column <= line_width)\n+    {\n+      int right_margin = CARET_LINE_MARGIN;\n+      int column = m_exploc.column;\n+      right_margin = MIN (line_width - column, right_margin);\n+      right_margin = max_width - right_margin;\n+      if (line_width >= max_width && column > right_margin)\n+\tm_x_offset = column - right_margin;\n+      gcc_assert (m_x_offset >= 0);\n+    }\n+}\n \n-  /* Center the interesting part of the source line to fit in\n-     max_width, and adjust all columns accordingly.  */\n-  int max_width = context->caret_max_width;\n-  int offset = (int) cmax;\n-  line = adjust_line (line, line_width, max_width, &offset);\n-  offset -= cmax;\n-  cmax += offset;\n-  xloc1.column += offset;\n-  if (xloc2.column)\n-    xloc2.column += offset;\n-\n-  /* Print the source line.  */\n-  pp_newline (context->printer);\n-  const char *saved_prefix = pp_get_prefix (context->printer);\n-  pp_set_prefix (context->printer, NULL);\n-  pp_space (context->printer);\n-  while (max_width > 0 && line_width > 0)\n+/* Attempt to print line ROW of source code, potentially colorized at any\n+   ranges.\n+   Return true if the line was printed, populating *LBOUNDS_OUT.\n+   Return false if the source line could not be read, leaving *LBOUNDS_OUT\n+   untouched.  */\n+\n+bool\n+layout::print_source_line (int row, line_bounds *lbounds_out)\n+{\n+  int line_width;\n+  const char *line = location_get_source_line (m_exploc.file, row,\n+\t\t\t\t\t       &line_width);\n+  if (!line)\n+    return false;\n+\n+  line += m_x_offset;\n+\n+  m_colorizer.set_normal_text ();\n+\n+  /* We will stop printing the source line at any trailing\n+     whitespace.  */\n+  line_width = get_line_width_without_trailing_whitespace (line,\n+\t\t\t\t\t\t\t   line_width);\n+\n+  pp_space (m_pp);\n+  int first_non_ws = INT_MAX;\n+  int last_non_ws = 0;\n+  int column;\n+  for (column = 1 + m_x_offset; column <= line_width; column++)\n     {\n+      /* Assuming colorization is enabled for the caret and underline\n+\t characters, we may also colorize the associated characters\n+\t within the source line.\n+\n+\t For frontends that generate range information, we color the\n+\t associated characters in the source line the same as the\n+\t carets and underlines in the annotation line, to make it easier\n+\t for the reader to see the pertinent code.\n+\n+\t For frontends that only generate carets, we don't colorize the\n+\t characters above them, since this would look strange (e.g.\n+\t colorizing just the first character in a token).  */\n+      if (m_colorize_source_p)\n+\t{\n+\t  bool in_range_p;\n+\t  point_state state;\n+\t  in_range_p = get_state_at_point (row, column,\n+\t\t\t\t\t   0, INT_MAX,\n+\t\t\t\t\t   &state);\n+\t  if (in_range_p)\n+\t    m_colorizer.set_range (state.range_idx);\n+\t  else\n+\t    m_colorizer.set_normal_text ();\n+\t}\n       char c = *line == '\\t' ? ' ' : *line;\n       if (c == '\\0')\n \tc = ' ';\n-      pp_character (context->printer, c);\n-      max_width--;\n-      line_width--;\n+      if (c != ' ')\n+\t{\n+\t  last_non_ws = column;\n+\t  if (first_non_ws == INT_MAX)\n+\t    first_non_ws = column;\n+\t}\n+      pp_character (m_pp, c);\n       line++;\n     }\n-  pp_newline (context->printer);\n+  pp_newline (m_pp);\n+\n+  lbounds_out->m_first_non_ws = first_non_ws;\n+  lbounds_out->m_last_non_ws = last_non_ws;\n+  return true;\n+}\n+\n+/* Print a line consisting of the caret/underlines for the given\n+   source line.  */\n \n-  /* Print the caret under the line.  */\n-  const char *caret_cs, *caret_ce;\n-  caret_cs = colorize_start (pp_show_color (context->printer), \"caret\");\n-  caret_ce = colorize_stop (pp_show_color (context->printer));\n-  int cmin = xloc2.column\n-    ? MIN (xloc1.column, xloc2.column) : xloc1.column;\n-  int caret_min = cmin == xloc1.column ? caret1 : caret2;\n-  int caret_max = cmin == xloc1.column ? caret2 : caret1;\n-\n-  /* cmin is >= 1, but we indent with an extra space at the start like\n-     we did above.  */\n+void\n+layout::print_annotation_line (int row, const line_bounds lbounds)\n+{\n+  int x_bound = get_x_bound_for_row (row, m_exploc.column,\n+\t\t\t\t     lbounds.m_last_non_ws);\n+\n+  pp_space (m_pp);\n+  for (int column = 1 + m_x_offset; column < x_bound; column++)\n+    {\n+      bool in_range_p;\n+      point_state state;\n+      in_range_p = get_state_at_point (row, column,\n+\t\t\t\t       lbounds.m_first_non_ws,\n+\t\t\t\t       lbounds.m_last_non_ws,\n+\t\t\t\t       &state);\n+      if (in_range_p)\n+\t{\n+\t  /* Within a range.  Draw either the caret or an underline.  */\n+\t  m_colorizer.set_range (state.range_idx);\n+\t  if (state.draw_caret_p)\n+\t    /* Draw the caret.  */\n+\t    pp_character (m_pp, m_context->caret_chars[state.range_idx]);\n+\t  else\n+\t    pp_character (m_pp, '~');\n+\t}\n+      else\n+\t{\n+\t  /* Not in a range.  */\n+\t  m_colorizer.set_normal_text ();\n+\t  pp_character (m_pp, ' ');\n+\t}\n+    }\n+  pp_newline (m_pp);\n+}\n+\n+/* Return true if (ROW/COLUMN) is within a range of the layout.\n+   If it returns true, OUT_STATE is written to, with the\n+   range index, and whether we should draw the caret at\n+   (ROW/COLUMN) (as opposed to an underline).  */\n+\n+bool\n+layout::get_state_at_point (/* Inputs.  */\n+\t\t\t    int row, int column,\n+\t\t\t    int first_non_ws, int last_non_ws,\n+\t\t\t    /* Outputs.  */\n+\t\t\t    point_state *out_state)\n+{\n+  layout_range *range;\n   int i;\n-  for (i = 0; i < cmin; i++)\n-    pp_space (context->printer);\n-  pp_printf (context->printer, \"%s%c%s\", caret_cs, caret_min, caret_ce);\n+  FOR_EACH_VEC_ELT (m_layout_ranges, i, range)\n+    {\n+      if (range->contains_point (row, column))\n+\t{\n+\t  out_state->range_idx = i;\n+\n+\t  /* Are we at the range's caret?  is it visible? */\n+\t  out_state->draw_caret_p = false;\n+\t  if (row == range->m_caret.m_line\n+\t      && column == range->m_caret.m_column)\n+\t    out_state->draw_caret_p = range->m_show_caret_p;\n \n-  if (xloc2.column)\n+\t  /* Within a multiline range, don't display any underline\n+\t     in any leading or trailing whitespace on a line.\n+\t     We do display carets, however.  */\n+\t  if (!out_state->draw_caret_p)\n+\t    if (column < first_non_ws || column > last_non_ws)\n+\t      return false;\n+\n+\t  /* We are within a range.  */\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Helper function for use by layout::print_line when printing the\n+   annotation line under the source line.\n+   Get the column beyond the rightmost one that could contain a caret or\n+   range marker, given that we stop rendering at trailing whitespace.\n+   ROW is the source line within the given file.\n+   CARET_COLUMN is the column of range 0's caret.\n+   LAST_NON_WS_COLUMN is the last column containing a non-whitespace\n+   character of source (as determined when printing the source line).  */\n+\n+int\n+layout::get_x_bound_for_row (int row, int caret_column,\n+\t\t\t     int last_non_ws_column)\n+{\n+  int result = caret_column + 1;\n+\n+  layout_range *range;\n+  int i;\n+  FOR_EACH_VEC_ELT (m_layout_ranges, i, range)\n     {\n-      for (i++; i < cmax; i++)\n-\tpp_space (context->printer);\n-      pp_printf (context->printer, \"%s%c%s\", caret_cs, caret_max, caret_ce);\n+      if (row >= range->m_start.m_line)\n+\t{\n+\t  if (range->m_finish.m_line == row)\n+\t    {\n+\t      /* On the final line within a range; ensure that\n+\t\t we render up to the end of the range.  */\n+\t      if (result <= range->m_finish.m_column)\n+\t\tresult = range->m_finish.m_column + 1;\n+\t    }\n+\t  else if (row < range->m_finish.m_line)\n+\t    {\n+\t      /* Within a multiline range; ensure that we render up to the\n+\t\t last non-whitespace column.  */\n+\t      if (result <= last_non_ws_column)\n+\t\tresult = last_non_ws_column + 1;\n+\t    }\n+\t}\n     }\n+\n+  return result;\n+}\n+\n+} /* End of anonymous namespace.  */\n+\n+/* Print the physical source code corresponding to the location of\n+   this diagnostic, with additional annotations.  */\n+\n+void\n+diagnostic_show_locus (diagnostic_context * context,\n+\t\t       const diagnostic_info *diagnostic)\n+{\n+  if (!context->show_caret\n+      || diagnostic_location (diagnostic, 0) <= BUILTINS_LOCATION\n+      || diagnostic_location (diagnostic, 0) == context->last_location)\n+    return;\n+\n+  context->last_location = diagnostic_location (diagnostic, 0);\n+\n+  pp_newline (context->printer);\n+\n+  const char *saved_prefix = pp_get_prefix (context->printer);\n+  pp_set_prefix (context->printer, NULL);\n+\n+  {\n+    layout layout (context, diagnostic);\n+    int last_line = layout.get_last_line ();\n+    for (int row = layout.get_first_line ();\n+\t row <= last_line;\n+\t row++)\n+      {\n+\t/* Print the source line, followed by an annotation line\n+\t   consisting of any caret/underlines.  If the source line can't\n+\t   be read, print nothing.  */\n+\tline_bounds lbounds;\n+\tif (layout.print_source_line (row, &lbounds))\n+\t  layout.print_annotation_line (row, lbounds);\n+      }\n+\n+    /* The closing scope here leads to the dtor for layout and thus\n+       colorizer being called here, which affects the precise\n+       place where colorization is turned off in the unittest\n+       for colorized output.  */\n+  }\n+\n   pp_set_prefix (context->printer, saved_prefix);\n-  pp_needs_newline (context->printer) = true;\n }"}, {"sha": "ee034e7717014f2054915b1f53296f316caa28e2", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 170, "deletions": 32, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -144,7 +144,7 @@ diagnostic_initialize (diagnostic_context *context, int n_opts)\n     context->classify_diagnostic[i] = DK_UNSPECIFIED;\n   context->show_caret = false;\n   diagnostic_set_caret_max_width (context, pp_line_cutoff (context->printer));\n-  for (i = 0; i < MAX_LOCATIONS_PER_MESSAGE; i++)\n+  for (i = 0; i < rich_location::MAX_RANGES; i++)\n     context->caret_chars[i] = '^';\n   context->show_option_requested = false;\n   context->abort_on_error = false;\n@@ -234,16 +234,15 @@ diagnostic_finish (diagnostic_context *context)\n    translated.  */\n void\n diagnostic_set_info_translated (diagnostic_info *diagnostic, const char *msg,\n-\t\t\t\tva_list *args, location_t location,\n+\t\t\t\tva_list *args, rich_location *richloc,\n \t\t\t\tdiagnostic_t kind)\n {\n+  gcc_assert (richloc);\n   diagnostic->message.err_no = errno;\n   diagnostic->message.args_ptr = args;\n   diagnostic->message.format_spec = msg;\n-  diagnostic->message.set_location (0, location);\n-  for (int i = 1; i < MAX_LOCATIONS_PER_MESSAGE; i++)\n-    diagnostic->message.set_location (i, UNKNOWN_LOCATION);\n-  diagnostic->override_column = 0;\n+  diagnostic->message.m_richloc = richloc;\n+  diagnostic->richloc = richloc;\n   diagnostic->kind = kind;\n   diagnostic->option_index = 0;\n }\n@@ -252,10 +251,27 @@ diagnostic_set_info_translated (diagnostic_info *diagnostic, const char *msg,\n    translated.  */\n void\n diagnostic_set_info (diagnostic_info *diagnostic, const char *gmsgid,\n-\t\t     va_list *args, location_t location,\n+\t\t     va_list *args, rich_location *richloc,\n \t\t     diagnostic_t kind)\n {\n-  diagnostic_set_info_translated (diagnostic, _(gmsgid), args, location, kind);\n+  gcc_assert (richloc);\n+  diagnostic_set_info_translated (diagnostic, _(gmsgid), args, richloc, kind);\n+}\n+\n+static const char *const diagnostic_kind_color[] = {\n+#define DEFINE_DIAGNOSTIC_KIND(K, T, C) (C),\n+#include \"diagnostic.def\"\n+#undef DEFINE_DIAGNOSTIC_KIND\n+  NULL\n+};\n+\n+/* Get a color name for diagnostics of type KIND\n+   Result could be NULL.  */\n+\n+const char *\n+diagnostic_get_color_for_kind (diagnostic_t kind)\n+{\n+  return diagnostic_kind_color[kind];\n }\n \n /* Return a malloc'd string describing a location.  The caller is\n@@ -270,12 +286,6 @@ diagnostic_build_prefix (diagnostic_context *context,\n #undef DEFINE_DIAGNOSTIC_KIND\n     \"must-not-happen\"\n   };\n-  static const char *const diagnostic_kind_color[] = {\n-#define DEFINE_DIAGNOSTIC_KIND(K, T, C) (C),\n-#include \"diagnostic.def\"\n-#undef DEFINE_DIAGNOSTIC_KIND\n-    NULL\n-  };\n   gcc_assert (diagnostic->kind < DK_LAST_DIAGNOSTIC_KIND);\n \n   const char *text = _(diagnostic_kind_text[diagnostic->kind]);\n@@ -770,10 +780,14 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n \n       if (option_text)\n \t{\n+\t  const char *cs\n+\t    = colorize_start (pp_show_color (context->printer),\n+\t\t\t      diagnostic_kind_color[diagnostic->kind]);\n+\t  const char *ce = colorize_stop (pp_show_color (context->printer));\n \t  diagnostic->message.format_spec\n \t    = ACONCAT ((diagnostic->message.format_spec,\n \t\t\t\" \", \n-\t\t\t\"[\", option_text, \"]\",\n+\t\t\t\"[\", cs, option_text, ce, \"]\",\n \t\t\tNULL));\n \t  free (option_text);\n \t}\n@@ -853,9 +867,40 @@ diagnostic_append_note (diagnostic_context *context,\n   diagnostic_info diagnostic;\n   va_list ap;\n   const char *saved_prefix;\n+  rich_location richloc (location);\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, location, DK_NOTE);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_NOTE);\n+  if (context->inhibit_notes_p)\n+    {\n+      va_end (ap);\n+      return;\n+    }\n+  saved_prefix = pp_get_prefix (context->printer);\n+  pp_set_prefix (context->printer,\n+                 diagnostic_build_prefix (context, &diagnostic));\n+  pp_newline (context->printer);\n+  pp_format (context->printer, &diagnostic.message);\n+  pp_output_formatted_text (context->printer);\n+  pp_destroy_prefix (context->printer);\n+  pp_set_prefix (context->printer, saved_prefix);\n+  diagnostic_show_locus (context, &diagnostic);\n+  va_end (ap);\n+}\n+\n+/* Same as diagnostic_append_note, but at RICHLOC. */\n+\n+void\n+diagnostic_append_note_at_rich_loc (diagnostic_context *context,\n+\t\t\t\t    rich_location *richloc,\n+\t\t\t\t    const char * gmsgid, ...)\n+{\n+  diagnostic_info diagnostic;\n+  va_list ap;\n+  const char *saved_prefix;\n+\n+  va_start (ap, gmsgid);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, richloc, DK_NOTE);\n   if (context->inhibit_notes_p)\n     {\n       va_end (ap);\n@@ -880,16 +925,17 @@ emit_diagnostic (diagnostic_t kind, location_t location, int opt,\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n+  rich_location richloc (location);\n \n   va_start (ap, gmsgid);\n   if (kind == DK_PERMERROR)\n     {\n-      diagnostic_set_info (&diagnostic, gmsgid, &ap, location,\n+      diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc,\n \t\t\t   permissive_error_kind (global_dc));\n       diagnostic.option_index = permissive_error_option (global_dc);\n     }\n   else {\n-      diagnostic_set_info (&diagnostic, gmsgid, &ap, location, kind);\n+      diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, kind);\n       if (kind == DK_WARNING || kind == DK_PEDWARN)\n \tdiagnostic.option_index = opt;\n   }\n@@ -903,12 +949,26 @@ emit_diagnostic (diagnostic_t kind, location_t location, int opt,\n    message.  */\n void\n inform (location_t location, const char *gmsgid, ...)\n+{\n+  diagnostic_info diagnostic;\n+  va_list ap;\n+  rich_location richloc (location);\n+\n+  va_start (ap, gmsgid);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_NOTE);\n+  report_diagnostic (&diagnostic);\n+  va_end (ap);\n+}\n+\n+/* Same as \"inform\", but at RICHLOC.  */\n+void\n+inform_at_rich_loc (rich_location *richloc, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, location, DK_NOTE);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, richloc, DK_NOTE);\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }\n@@ -921,11 +981,12 @@ inform_n (location_t location, int n, const char *singular_gmsgid,\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n+  rich_location richloc (location);\n \n   va_start (ap, plural_gmsgid);\n   diagnostic_set_info_translated (&diagnostic,\n                                   ngettext (singular_gmsgid, plural_gmsgid, n),\n-                                  &ap, location, DK_NOTE);\n+                                  &ap, &richloc, DK_NOTE);\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }\n@@ -939,9 +1000,10 @@ warning (int opt, const char *gmsgid, ...)\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n+  rich_location richloc (input_location);\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location, DK_WARNING);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_WARNING);\n   diagnostic.option_index = opt;\n \n   ret = report_diagnostic (&diagnostic);\n@@ -955,13 +1017,31 @@ warning (int opt, const char *gmsgid, ...)\n \n bool\n warning_at (location_t location, int opt, const char *gmsgid, ...)\n+{\n+  diagnostic_info diagnostic;\n+  va_list ap;\n+  bool ret;\n+  rich_location richloc (location);\n+\n+  va_start (ap, gmsgid);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_WARNING);\n+  diagnostic.option_index = opt;\n+  ret = report_diagnostic (&diagnostic);\n+  va_end (ap);\n+  return ret;\n+}\n+\n+/* Same as warning at, but using RICHLOC.  */\n+\n+bool\n+warning_at_rich_loc (rich_location *richloc, int opt, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, location, DK_WARNING);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, richloc, DK_WARNING);\n   diagnostic.option_index = opt;\n   ret = report_diagnostic (&diagnostic);\n   va_end (ap);\n@@ -979,11 +1059,13 @@ warning_n (location_t location, int opt, int n, const char *singular_gmsgid,\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n+  rich_location richloc (location);\n \n   va_start (ap, plural_gmsgid);\n   diagnostic_set_info_translated (&diagnostic,\n                                   ngettext (singular_gmsgid, plural_gmsgid, n),\n-                                  &ap, location, DK_WARNING);\n+                                  &ap, &richloc, DK_WARNING\n+);\n   diagnostic.option_index = opt;\n   ret = report_diagnostic (&diagnostic);\n   va_end (ap);\n@@ -1009,9 +1091,10 @@ pedwarn (location_t location, int opt, const char *gmsgid, ...)\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n+  rich_location richloc (location);\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, location,  DK_PEDWARN);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc,  DK_PEDWARN);\n   diagnostic.option_index = opt;\n   ret = report_diagnostic (&diagnostic);\n   va_end (ap);\n@@ -1031,9 +1114,28 @@ permerror (location_t location, const char *gmsgid, ...)\n   diagnostic_info diagnostic;\n   va_list ap;\n   bool ret;\n+  rich_location richloc (location);\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, location,\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc,\n+                       permissive_error_kind (global_dc));\n+  diagnostic.option_index = permissive_error_option (global_dc);\n+  ret = report_diagnostic (&diagnostic);\n+  va_end (ap);\n+  return ret;\n+}\n+\n+/* Same as \"permerror\", but at RICHLOC.  */\n+\n+bool\n+permerror_at_rich_loc (rich_location *richloc, const char *gmsgid, ...)\n+{\n+  diagnostic_info diagnostic;\n+  va_list ap;\n+  bool ret;\n+\n+  va_start (ap, gmsgid);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, richloc,\n                        permissive_error_kind (global_dc));\n   diagnostic.option_index = permissive_error_option (global_dc);\n   ret = report_diagnostic (&diagnostic);\n@@ -1048,9 +1150,10 @@ error (const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n+  rich_location richloc (input_location);\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location, DK_ERROR);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_ERROR);\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }\n@@ -1063,11 +1166,12 @@ error_n (location_t location, int n, const char *singular_gmsgid,\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n+  rich_location richloc (location);\n \n   va_start (ap, plural_gmsgid);\n   diagnostic_set_info_translated (&diagnostic,\n                                   ngettext (singular_gmsgid, plural_gmsgid, n),\n-                                  &ap, location, DK_ERROR);\n+                                  &ap, &richloc, DK_ERROR);\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }\n@@ -1078,9 +1182,25 @@ error_at (location_t loc, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n+  rich_location richloc (loc);\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, loc, DK_ERROR);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_ERROR);\n+  report_diagnostic (&diagnostic);\n+  va_end (ap);\n+}\n+\n+/* Same as above, but use RICH_LOC.  */\n+\n+void\n+error_at_rich_loc (rich_location *rich_loc, const char *gmsgid, ...)\n+{\n+  diagnostic_info diagnostic;\n+  va_list ap;\n+\n+  va_start (ap, gmsgid);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, rich_loc,\n+\t\t       DK_ERROR);\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }\n@@ -1093,9 +1213,10 @@ sorry (const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n+  rich_location richloc (input_location);\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location, DK_SORRY);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_SORRY);\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }\n@@ -1116,9 +1237,10 @@ fatal_error (location_t loc, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n+  rich_location richloc (loc);\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, loc, DK_FATAL);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_FATAL);\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n \n@@ -1134,9 +1256,10 @@ internal_error (const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n+  rich_location richloc (input_location);\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location, DK_ICE);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_ICE);\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n \n@@ -1151,9 +1274,10 @@ internal_error_no_backtrace (const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n+  rich_location richloc (input_location);\n \n   va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location, DK_ICE_NOBT);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_ICE_NOBT);\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n \n@@ -1217,3 +1341,17 @@ real_abort (void)\n {\n   abort ();\n }\n+\n+/* Display the given source_range instance, with MSG as a descriptive\n+   comment.  This issues a \"note\" diagnostic at the range.\n+\n+   This is declared within libcpp, but implemented here, since it\n+   makes use of the diagnostic-printing machinery.  */\n+\n+DEBUG_FUNCTION void\n+source_range::debug (const char *msg) const\n+{\n+  rich_location richloc (m_start);\n+  richloc.add_range (m_start, m_finish, false);\n+  inform_at_rich_loc (&richloc, \"%s\", msg);\n+}"}, {"sha": "9096e16eb07c953842ea3bc2ceabc1b65693deee", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -29,10 +29,12 @@ along with GCC; see the file COPYING3.  If not see\n    list in diagnostic.def.  */\n struct diagnostic_info\n {\n-  /* Text to be formatted. It also contains the location(s) for this\n-     diagnostic.  */\n+  /* Text to be formatted.  */\n   text_info message;\n-  unsigned int override_column;\n+\n+  /* The location at which the diagnostic is to be reported.  */\n+  rich_location *richloc;\n+\n   /* Auxiliary data for client.  */\n   void *x_data;\n   /* The kind of diagnostic it is about.  */\n@@ -102,8 +104,8 @@ struct diagnostic_context\n   /* Maximum width of the source line printed.  */\n   int caret_max_width;\n \n-  /* Characters used for caret diagnostics.  */\n-  char caret_chars[MAX_LOCATIONS_PER_MESSAGE];\n+  /* Character used for caret diagnostics.  */\n+  char caret_chars[rich_location::MAX_RANGES];\n \n   /* True if we should print the command line option which controls\n      each diagnostic, if known.  */\n@@ -181,6 +183,15 @@ struct diagnostic_context\n   int lock;\n \n   bool inhibit_notes_p;\n+\n+  /* When printing source code, should the characters at carets and ranges\n+     be colorized? (assuming colorization is on at all).\n+     This should be true for frontends that generate range information\n+     (so that the ranges of code are colorized),\n+     and false for frontends that merely specify points within the\n+     source code (to avoid e.g. colorizing just the first character in\n+     a token, which would look strange).  */\n+  bool colorize_source_p;\n };\n \n static inline void\n@@ -252,10 +263,6 @@ extern diagnostic_context *global_dc;\n \n #define report_diagnostic(D) diagnostic_report_diagnostic (global_dc, D)\n \n-/* Override the column number to be used for reporting a\n-   diagnostic.  */\n-#define diagnostic_override_column(DI, COL) (DI)->override_column = (COL)\n-\n /* Override the option index to be used for reporting a\n    diagnostic.  */\n #define diagnostic_override_option_index(DI, OPTIDX) \\\n@@ -279,13 +286,17 @@ extern bool diagnostic_report_diagnostic (diagnostic_context *,\n \t\t\t\t\t  diagnostic_info *);\n #ifdef ATTRIBUTE_GCC_DIAG\n extern void diagnostic_set_info (diagnostic_info *, const char *, va_list *,\n-\t\t\t\t location_t, diagnostic_t) ATTRIBUTE_GCC_DIAG(2,0);\n+\t\t\t\t rich_location *, diagnostic_t) ATTRIBUTE_GCC_DIAG(2,0);\n extern void diagnostic_set_info_translated (diagnostic_info *, const char *,\n-\t\t\t\t\t    va_list *, location_t,\n+\t\t\t\t\t    va_list *, rich_location *,\n \t\t\t\t\t    diagnostic_t)\n      ATTRIBUTE_GCC_DIAG(2,0);\n extern void diagnostic_append_note (diagnostic_context *, location_t,\n                                     const char *, ...) ATTRIBUTE_GCC_DIAG(3,4);\n+extern void diagnostic_append_note_at_rich_loc (diagnostic_context *,\n+\t\t\t\t\t\trich_location *,\n+\t\t\t\t\t\tconst char *, ...)\n+  ATTRIBUTE_GCC_DIAG(3,4);\n #endif\n extern char *diagnostic_build_prefix (diagnostic_context *, const diagnostic_info *);\n void default_diagnostic_starter (diagnostic_context *, diagnostic_info *);\n@@ -306,19 +317,22 @@ diagnostic_location (const diagnostic_info * diagnostic, int which = 0)\n   return diagnostic->message.get_location (which);\n }\n \n+/* Return the number of locations to be printed in DIAGNOSTIC.  */\n+\n+static inline unsigned int\n+diagnostic_num_locations (const diagnostic_info * diagnostic)\n+{\n+  return diagnostic->message.m_richloc->get_num_locations ();\n+}\n+\n /* Expand the location of this diagnostic. Use this function for\n    consistency.  Parameter WHICH specifies which location. By default,\n    expand the first one.  */\n \n static inline expanded_location\n diagnostic_expand_location (const diagnostic_info * diagnostic, int which = 0)\n {\n-  expanded_location s\n-    = expand_location_to_spelling_point (diagnostic_location (diagnostic,\n-\t\t\t\t\t\t\t      which));\n-  if (which == 0 && diagnostic->override_column)\n-    s.column = diagnostic->override_column;\n-  return s;\n+  return diagnostic->richloc->get_range (which)->m_caret;\n }\n \n /* This is somehow the right-side margin of a caret line, that is, we\n@@ -338,11 +352,7 @@ diagnostic_same_line (const diagnostic_context *context,\n     && context->caret_max_width - CARET_LINE_MARGIN > abs (s1.column - s2.column);\n }\n \n-void\n-diagnostic_print_caret_line (diagnostic_context * context,\n-\t\t\t     expanded_location xloc1,\n-\t\t\t     expanded_location xloc2,\n-\t\t\t     char caret1, char caret2);\n+extern const char *diagnostic_get_color_for_kind (diagnostic_t kind);\n \n /* Pure text formatting support functions.  */\n extern char *file_name_as_prefix (diagnostic_context *, const char *);"}, {"sha": "acbb1b75f060a488b801ecc3ef58795c31a7beed", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -1,3 +1,24 @@\n+2015-11-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cpp.c (cb_cpp_error): Convert parameter from location_t to\n+\trich_location *.  Eliminate the \"column_override\" parameter.\n+\t* error.c (gfc_warning): Update for change in signature of\n+\tdiagnostic_set_info.\n+\t(gfc_format_decoder): Update handling of %C/%L for changes\n+\tto struct text_info.\n+\t(gfc_diagnostic_starter): Use richloc when determining whether to\n+\tprint one locus or two.  When handling a location that will\n+\tinvolve a call to diagnostic_show_locus, only attempt to print the\n+\tlocus for the primary location, and don't call into\n+\tdiagnostic_print_caret_line.\n+\t(gfc_warning_now_at): Update for change in signature of\n+\tdiagnostic_set_info.\n+\t(gfc_warning_now): Likewise.\n+\t(gfc_error_now): Likewise.\n+\t(gfc_fatal_error): Likewise.\n+\t(gfc_error): Likewise.\n+\t(gfc_internal_error): Likewise.\n+\n 2015-11-05  Cesar Philippidis  <cesar@codesourcery.com>\n \n \t* openmp.c (gfc_match_omp_clauses): Update support for the tile"}, {"sha": "85a2c79cd70965ea04cbb9f5374129347d2d1f81", "filename": "gcc/fortran/cpp.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ffortran%2Fcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ffortran%2Fcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcpp.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -147,9 +147,9 @@ static void cb_include (cpp_reader *, source_location, const unsigned char *,\n static void cb_ident (cpp_reader *, source_location, const cpp_string *);\n static void cb_used_define (cpp_reader *, source_location, cpp_hashnode *);\n static void cb_used_undef (cpp_reader *, source_location, cpp_hashnode *);\n-static bool cb_cpp_error (cpp_reader *, int, int, location_t, unsigned int,\n+static bool cb_cpp_error (cpp_reader *, int, int, rich_location *,\n \t\t\t  const char *, va_list *)\n-     ATTRIBUTE_GCC_DIAG(6,0);\n+     ATTRIBUTE_GCC_DIAG(5,0);\n void pp_dir_change (cpp_reader *, const char *);\n \n static int dump_macro (cpp_reader *, cpp_hashnode *, void *);\n@@ -1024,13 +1024,12 @@ cb_used_define (cpp_reader *pfile, source_location line ATTRIBUTE_UNUSED,\n /* Callback from cpp_error for PFILE to print diagnostics from the\n    preprocessor.  The diagnostic is of type LEVEL, with REASON set\n    to the reason code if LEVEL is represents a warning, at location\n-   LOCATION, with column number possibly overridden by COLUMN_OVERRIDE\n-   if not zero; MSG is the translated message and AP the arguments.\n+   RICHLOC; MSG is the translated message and AP the arguments.\n    Returns true if a diagnostic was emitted, false otherwise.  */\n \n static bool\n cb_cpp_error (cpp_reader *pfile ATTRIBUTE_UNUSED, int level, int reason,\n-\t      location_t location, unsigned int column_override,\n+\t      rich_location *richloc,\n \t      const char *msg, va_list *ap)\n {\n   diagnostic_info diagnostic;\n@@ -1065,9 +1064,7 @@ cb_cpp_error (cpp_reader *pfile ATTRIBUTE_UNUSED, int level, int reason,\n       gcc_unreachable ();\n     }\n   diagnostic_set_info_translated (&diagnostic, msg, ap,\n-\t\t\t\t  location, dlevel);\n-  if (column_override)\n-    diagnostic_override_column (&diagnostic, column_override);\n+\t\t\t\t  richloc, dlevel);\n   if (reason == CPP_W_WARNING_DIRECTIVE)\n     diagnostic_override_option_index (&diagnostic, OPT_Wcpp);\n   ret = report_diagnostic (&diagnostic);"}, {"sha": "4b3d31ce4ba3c47950d992d66270271a628a8f72", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 28, "deletions": 75, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -773,6 +773,7 @@ gfc_warning (int opt, const char *gmsgid, va_list ap)\n   va_copy (argp, ap);\n \n   diagnostic_info diagnostic;\n+  rich_location rich_loc (UNKNOWN_LOCATION);\n   bool fatal_errors = global_dc->fatal_errors;\n   pretty_printer *pp = global_dc->printer;\n   output_buffer *tmp_buffer = pp->buffer;\n@@ -787,7 +788,7 @@ gfc_warning (int opt, const char *gmsgid, va_list ap)\n       --werrorcount;\n     }\n \n-  diagnostic_set_info (&diagnostic, gmsgid, &argp, UNKNOWN_LOCATION,\n+  diagnostic_set_info (&diagnostic, gmsgid, &argp, &rich_loc,\n \t\t       DK_WARNING);\n   diagnostic.option_index = opt;\n   bool ret = report_diagnostic (&diagnostic);\n@@ -938,10 +939,12 @@ gfc_format_decoder (pretty_printer *pp,\n \t/* If location[0] != UNKNOWN_LOCATION means that we already\n \t   processed one of %C/%L.  */\n \tint loc_num = text->get_location (0) == UNKNOWN_LOCATION ? 0 : 1;\n-\ttext->set_location (loc_num,\n-\t\t\t    linemap_position_for_loc_and_offset (line_table,\n-\t\t\t\t\t\t\t\t loc->lb->location,\n-\t\t\t\t\t\t\t\t offset));\n+\tsource_range range\n+\t  = source_range::from_location (\n+\t      linemap_position_for_loc_and_offset (line_table,\n+\t\t\t\t\t\t   loc->lb->location,\n+\t\t\t\t\t\t   offset));\n+\ttext->set_range (loc_num, range, true);\n \tpp_string (pp, result[loc_num]);\n \treturn true;\n       }\n@@ -1024,48 +1027,21 @@ gfc_diagnostic_build_locus_prefix (diagnostic_context *context,\n }\n \n /* This function prints the locus (file:line:column), the diagnostic kind\n-   (Error, Warning) and (optionally) the caret line (a source line\n-   with '1' and/or '2' below it).\n+   (Error, Warning) and (optionally) the relevant lines of code with\n+   annotation lines with '1' and/or '2' below them.\n \n-   With -fdiagnostic-show-caret (the default) and for valid locations,\n-   it prints for one location:\n+   With -fdiagnostic-show-caret (the default) it prints:\n \n-       [locus]:\n+       [locus of primary range]:\n        \n           some code\n                  1\n        Error: Some error at (1)\n         \n-   for two locations that fit in the same locus line:\n+  With -fno-diagnostic-show-caret or if the primary range is not\n+  valid, it prints:\n \n-       [locus]:\n-       \n-         some code and some more code\n-                1       2\n-       Error: Some error at (1) and (2)\n-\n-   and for two locations that do not fit in the same locus line:\n-\n-       [locus]:\n-       \n-         some code\n-                1\n-       [locus2]:\n-       \n-         some other code\n-           2\n-       Error: Some error at (1) and (2)\n-       \n-  With -fno-diagnostic-show-caret or if one of the locations is not\n-  valid, it prints for one location (or for two locations that fit in\n-  the same locus line):\n-\n-       [locus]: Error: Some error at (1) and (2)\n-\n-   and for two locations that do not fit in the same locus line:\n-\n-       [name]:[locus]: Error: (1)\n-       [name]:[locus2]: Error: Some error at (1) and (2)\n+       [locus of primary range]: Error: Some error at (1) and (2)\n */\n static void \n gfc_diagnostic_starter (diagnostic_context *context,\n@@ -1075,7 +1051,7 @@ gfc_diagnostic_starter (diagnostic_context *context,\n \n   expanded_location s1 = diagnostic_expand_location (diagnostic);\n   expanded_location s2;\n-  bool one_locus = diagnostic_location (diagnostic, 1) == UNKNOWN_LOCATION;\n+  bool one_locus = diagnostic->richloc->get_num_locations () < 2;\n   bool same_locus = false;\n \n   if (!one_locus) \n@@ -1125,35 +1101,6 @@ gfc_diagnostic_starter (diagnostic_context *context,\n       /* If the caret line was shown, the prefix does not contain the\n \t locus.  */\n       pp_set_prefix (context->printer, kind_prefix);\n-\n-      if (one_locus || same_locus)\n-\t  return;\n-\n-      locus_prefix = gfc_diagnostic_build_locus_prefix (context, s2);\n-      if (diagnostic_location (diagnostic, 1) <= BUILTINS_LOCATION)\n-\t{\n-\t  /* No caret line for the second location. Override the previous\n-\t     prefix with [locus2]:[prefix].  */\n-\t  pp_set_prefix (context->printer,\n-\t\t\t concat (locus_prefix, \" \", kind_prefix, NULL));\n-\t  free (kind_prefix);\n-\t  free (locus_prefix);\n-\t}\n-      else\n-\t{\n-\t  /* We print the caret for the second location.  */\n-\t  pp_verbatim (context->printer, locus_prefix);\n-\t  free (locus_prefix);\n-\t  /* Fortran uses an empty line between locus and caret line.  */\n-\t  pp_newline (context->printer);\n-\t  s1.column = 0; /* Print only a caret line for s2.  */\n-\t  diagnostic_print_caret_line (context, s2, s1,\n-\t\t\t\t       context->caret_chars[1], '\\0');\n-\t  pp_newline (context->printer);\n-\t  /* If the caret line was shown, the prefix does not contain the\n-\t     locus.  */\n-\t  pp_set_prefix (context->printer, kind_prefix);\n-\t}\n     }\n }\n \n@@ -1173,10 +1120,11 @@ gfc_warning_now_at (location_t loc, int opt, const char *gmsgid, ...)\n {\n   va_list argp;\n   diagnostic_info diagnostic;\n+  rich_location rich_loc (loc);\n   bool ret;\n \n   va_start (argp, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &argp, loc, DK_WARNING);\n+  diagnostic_set_info (&diagnostic, gmsgid, &argp, &rich_loc, DK_WARNING);\n   diagnostic.option_index = opt;\n   ret = report_diagnostic (&diagnostic);\n   va_end (argp);\n@@ -1190,10 +1138,11 @@ gfc_warning_now (int opt, const char *gmsgid, ...)\n {\n   va_list argp;\n   diagnostic_info diagnostic;\n+  rich_location rich_loc (UNKNOWN_LOCATION);\n   bool ret;\n \n   va_start (argp, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &argp, UNKNOWN_LOCATION,\n+  diagnostic_set_info (&diagnostic, gmsgid, &argp, &rich_loc,\n \t\t       DK_WARNING);\n   diagnostic.option_index = opt;\n   ret = report_diagnostic (&diagnostic);\n@@ -1209,11 +1158,12 @@ gfc_error_now (const char *gmsgid, ...)\n {\n   va_list argp;\n   diagnostic_info diagnostic;\n+  rich_location rich_loc (UNKNOWN_LOCATION);\n \n   error_buffer.flag = true;\n \n   va_start (argp, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &argp, UNKNOWN_LOCATION, DK_ERROR);\n+  diagnostic_set_info (&diagnostic, gmsgid, &argp, &rich_loc, DK_ERROR);\n   report_diagnostic (&diagnostic);\n   va_end (argp);\n }\n@@ -1226,9 +1176,10 @@ gfc_fatal_error (const char *gmsgid, ...)\n {\n   va_list argp;\n   diagnostic_info diagnostic;\n+  rich_location rich_loc (UNKNOWN_LOCATION);\n \n   va_start (argp, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &argp, UNKNOWN_LOCATION, DK_FATAL);\n+  diagnostic_set_info (&diagnostic, gmsgid, &argp, &rich_loc, DK_FATAL);\n   report_diagnostic (&diagnostic);\n   va_end (argp);\n \n@@ -1291,6 +1242,7 @@ gfc_error (const char *gmsgid, va_list ap)\n     }\n \n   diagnostic_info diagnostic;\n+  rich_location richloc (UNKNOWN_LOCATION);\n   bool fatal_errors = global_dc->fatal_errors;\n   pretty_printer *pp = global_dc->printer;\n   output_buffer *tmp_buffer = pp->buffer;\n@@ -1306,7 +1258,7 @@ gfc_error (const char *gmsgid, va_list ap)\n       --errorcount;\n     }\n \n-  diagnostic_set_info (&diagnostic, gmsgid, &argp, UNKNOWN_LOCATION, DK_ERROR);\n+  diagnostic_set_info (&diagnostic, gmsgid, &argp, &richloc, DK_ERROR);\n   report_diagnostic (&diagnostic);\n \n   if (buffered_p)\n@@ -1336,9 +1288,10 @@ gfc_internal_error (const char *gmsgid, ...)\n {\n   va_list argp;\n   diagnostic_info diagnostic;\n+  rich_location rich_loc (UNKNOWN_LOCATION);\n \n   va_start (argp, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &argp, UNKNOWN_LOCATION, DK_ICE);\n+  diagnostic_set_info (&diagnostic, gmsgid, &argp, &rich_loc, DK_ICE);\n   report_diagnostic (&diagnostic);\n   va_end (argp);\n "}, {"sha": "ad502f972620e373d7d8e25cfd2d1cf8390723e5", "filename": "gcc/genmatch.c", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -53,14 +53,31 @@ unsigned verbose;\n \n static struct line_maps *line_table;\n \n+/* The rich_location class within libcpp requires a way to expand\n+   source_location instances, and relies on the client code\n+   providing a symbol named\n+     linemap_client_expand_location_to_spelling_point\n+   to do this.\n+\n+   This is the implementation for genmatch.  */\n+\n+expanded_location\n+linemap_client_expand_location_to_spelling_point (source_location loc)\n+{\n+  const struct line_map_ordinary *map;\n+  loc = linemap_resolve_location (line_table, loc, LRK_SPELLING_LOCATION, &map);\n+  return linemap_expand_location (line_table, map, loc);\n+}\n+\n static bool\n #if GCC_VERSION >= 4001\n-__attribute__((format (printf, 6, 0)))\n+__attribute__((format (printf, 5, 0)))\n #endif\n-error_cb (cpp_reader *, int errtype, int, source_location location,\n-\t  unsigned int, const char *msg, va_list *ap)\n+error_cb (cpp_reader *, int errtype, int, rich_location *richloc,\n+\t  const char *msg, va_list *ap)\n {\n   const line_map_ordinary *map;\n+  source_location location = richloc->get_loc ();\n   linemap_resolve_location (line_table, location, LRK_SPELLING_LOCATION, &map);\n   expanded_location loc = linemap_expand_location (line_table, map, location);\n   fprintf (stderr, \"%s:%d:%d %s: \", loc.file, loc.line, loc.column,\n@@ -102,9 +119,10 @@ __attribute__((format (printf, 2, 3)))\n #endif\n fatal_at (const cpp_token *tk, const char *msg, ...)\n {\n+  rich_location richloc (tk->src_loc);\n   va_list ap;\n   va_start (ap, msg);\n-  error_cb (NULL, CPP_DL_FATAL, 0, tk->src_loc, 0, msg, &ap);\n+  error_cb (NULL, CPP_DL_FATAL, 0, &richloc, msg, &ap);\n   va_end (ap);\n }\n \n@@ -114,9 +132,10 @@ __attribute__((format (printf, 2, 3)))\n #endif\n fatal_at (source_location loc, const char *msg, ...)\n {\n+  rich_location richloc (loc);\n   va_list ap;\n   va_start (ap, msg);\n-  error_cb (NULL, CPP_DL_FATAL, 0, loc, 0, msg, &ap);\n+  error_cb (NULL, CPP_DL_FATAL, 0, &richloc, msg, &ap);\n   va_end (ap);\n }\n \n@@ -126,9 +145,10 @@ __attribute__((format (printf, 2, 3)))\n #endif\n warning_at (const cpp_token *tk, const char *msg, ...)\n {\n+  rich_location richloc (tk->src_loc);\n   va_list ap;\n   va_start (ap, msg);\n-  error_cb (NULL, CPP_DL_WARNING, 0, tk->src_loc, 0, msg, &ap);\n+  error_cb (NULL, CPP_DL_WARNING, 0, &richloc, msg, &ap);\n   va_end (ap);\n }\n \n@@ -138,9 +158,10 @@ __attribute__((format (printf, 2, 3)))\n #endif\n warning_at (source_location loc, const char *msg, ...)\n {\n+  rich_location richloc (loc);\n   va_list ap;\n   va_start (ap, msg);\n-  error_cb (NULL, CPP_DL_WARNING, 0, loc, 0, msg, &ap);\n+  error_cb (NULL, CPP_DL_WARNING, 0, &richloc, msg, &ap);\n   va_end (ap);\n }\n "}, {"sha": "0f6d448b54638b6a81b2639acf1f5ca62e5c49f1", "filename": "gcc/input.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -751,6 +751,22 @@ expand_location_to_spelling_point (source_location loc)\n   return expand_location_1 (loc, /*expansion_point_p=*/false);\n }\n \n+/* The rich_location class within libcpp requires a way to expand\n+   source_location instances, and relies on the client code\n+   providing a symbol named\n+     linemap_client_expand_location_to_spelling_point\n+   to do this.\n+\n+   This is the implementation for libcommon.a (all host binaries),\n+   which simply calls into expand_location_to_spelling_point.  */\n+\n+expanded_location\n+linemap_client_expand_location_to_spelling_point (source_location loc)\n+{\n+  return expand_location_to_spelling_point (loc);\n+}\n+\n+\n /* If LOCATION is in a system header and if it is a virtual location for\n    a token coming from the expansion of a macro, unwind it to the\n    location of the expansion point of the macro.  Otherwise, just return"}, {"sha": "4a28d3c5fd9e683aa4faa60b098b2e09db48e27f", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -31,6 +31,27 @@ along with GCC; see the file COPYING3.  If not see\n #include <iconv.h>\n #endif\n \n+/* Overwrite the range within this text_info's rich_location.\n+   For use e.g. when implementing \"+\" in client format decoders.  */\n+\n+void\n+text_info::set_range (unsigned int idx, source_range range, bool caret_p)\n+{\n+  gcc_checking_assert (m_richloc);\n+  m_richloc->set_range (idx, range, caret_p, true);\n+}\n+\n+location_t\n+text_info::get_location (unsigned int index_of_location) const\n+{\n+  gcc_checking_assert (m_richloc);\n+\n+  if (index_of_location == 0)\n+    return m_richloc->get_loc ();\n+  else\n+    return UNKNOWN_LOCATION;\n+}\n+\n // Default construct an output buffer.\n \n output_buffer::output_buffer ()"}, {"sha": "cdee2535fe0f024ae4fd87607bf578907def5570", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -27,11 +27,6 @@ along with GCC; see the file COPYING3.  If not see\n /* Maximum number of format string arguments.  */\n #define PP_NL_ARGMAX   30\n \n-/* Maximum number of locations associated to each message.  If\n-   location 'i' is UNKNOWN_LOCATION, then location 'i+1' is not\n-   valid.  */\n-#define MAX_LOCATIONS_PER_MESSAGE 2\n-\n /* The type of a text to be formatted according a format specification\n    along with a list of things.  */\n struct text_info\n@@ -40,21 +35,17 @@ struct text_info\n   va_list *args_ptr;\n   int err_no;  /* for %m */\n   void **x_data;\n+  rich_location *m_richloc;\n \n-  inline void set_location (unsigned int index_of_location, location_t loc)\n+  inline void set_location (unsigned int idx, location_t loc, bool caret_p)\n   {\n-    gcc_checking_assert (index_of_location < MAX_LOCATIONS_PER_MESSAGE);\n-    this->locations[index_of_location] = loc;\n+    source_range src_range;\n+    src_range.m_start = loc;\n+    src_range.m_finish = loc;\n+    set_range (idx, src_range, caret_p);\n   }\n-\n-  inline location_t get_location (unsigned int index_of_location) const\n-  {\n-    gcc_checking_assert (index_of_location < MAX_LOCATIONS_PER_MESSAGE);\n-    return this->locations[index_of_location];\n-  }\n-\n-private:\n-  location_t locations[MAX_LOCATIONS_PER_MESSAGE];\n+  void set_range (unsigned int idx, source_range range, bool caret_p);\n+  location_t get_location (unsigned int index_of_location) const;\n };\n \n /* How often diagnostics are prefixed by their locations:"}, {"sha": "96da2bd275d3d3bb490000eb73367e7526fe94c6", "filename": "gcc/rtl-error.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Frtl-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Frtl-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-error.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -67,9 +67,10 @@ diagnostic_for_asm (const rtx_insn *insn, const char *msg, va_list *args_ptr,\n \t\t    diagnostic_t kind)\n {\n   diagnostic_info diagnostic;\n+  rich_location richloc (location_for_asm (insn));\n \n   diagnostic_set_info (&diagnostic, msg, args_ptr,\n-\t\t       location_for_asm (insn), kind);\n+\t\t       &richloc, kind);\n   report_diagnostic (&diagnostic);\n }\n "}, {"sha": "9a0d1aa22f8e5b9bda20e5a2d6ffee9fe06fc02c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -1,3 +1,11 @@\n+2015-11-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/plugin/diagnostic-test-show-locus-bw.c: New file.\n+\t* gcc.dg/plugin/diagnostic-test-show-locus-color.c: New file.\n+\t* gcc.dg/plugin/diagnostic_plugin_test_show_locus.c: New file.\n+\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add the above.\n+\t* lib/gcc-dg.exp: Load multiline.exp.\n+\n 2015-11-06  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \t* gcc.target/arm/combine-movs.c: Adjust for unified asm."}, {"sha": "a4b16da318c5490eede8e58ddd2d0d87ebfdc25a", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-show-locus-bw.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-bw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-bw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-bw.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -0,0 +1,149 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdiagnostics-show-caret\" } */\n+\n+/* This is a collection of unittests for diagnostic_show_locus;\n+   see the overview in diagnostic_plugin_test_show_locus.c.\n+\n+   In particular, note the discussion of why we need a very long line here:\n+01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+   and that we can't use macros in this file.  */\n+\n+void test_simple (void)\n+{\n+#if 0\n+  myvar = myvar.x; /* { dg-warning \"test\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+   myvar = myvar.x;\n+           ~~~~~^~\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_simple_2 (void)\n+{\n+#if 0\n+  x = first_function () + second_function ();  /* { dg-warning \"test\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+   x = first_function () + second_function ();\n+       ~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+\n+void test_multiline (void)\n+{\n+#if 0\n+  x = (first_function ()\n+       + second_function ()); /* { dg-warning \"test\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+   x = (first_function ()\n+        ~~~~~~~~~~~~~~~~~\n+        + second_function ());\n+        ^ ~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_many_lines (void)\n+{\n+#if 0\n+  x = (first_function_with_a_very_long_name (lorem, ipsum, dolor, sit, amet,\n+                                            consectetur, adipiscing, elit,\n+                                            sed, eiusmod, tempor,\n+                                            incididunt, ut, labore, et,\n+                                            dolore, magna, aliqua)\n+       + second_function_with_a_very_long_name (lorem, ipsum, dolor, sit, /* { dg-warning \"test\" } */\n+                                                amet, consectetur,\n+                                                adipiscing, elit, sed,\n+                                                eiusmod, tempor, incididunt,\n+                                                ut, labore, et, dolore,\n+                                                magna, aliqua));\n+\n+/* { dg-begin-multiline-output \"\" }\n+   x = (first_function_with_a_very_long_name (lorem, ipsum, dolor, sit, amet,\n+        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+                                             consectetur, adipiscing, elit,\n+                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+                                             sed, eiusmod, tempor,\n+                                             ~~~~~~~~~~~~~~~~~~~~~\n+                                             incididunt, ut, labore, et,\n+                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+                                             dolore, magna, aliqua)\n+                                             ~~~~~~~~~~~~~~~~~~~~~~\n+        + second_function_with_a_very_long_name (lorem, ipsum, dolor, sit,\n+        ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+                                                 amet, consectetur,\n+                                                 ~~~~~~~~~~~~~~~~~~\n+                                                 adipiscing, elit, sed,\n+                                                 ~~~~~~~~~~~~~~~~~~~~~~\n+                                                 eiusmod, tempor, incididunt,\n+                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+                                                 ut, labore, et, dolore,\n+                                                 ~~~~~~~~~~~~~~~~~~~~~~~\n+                                                 magna, aliqua));\n+                                                 ~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_richloc_from_proper_range (void)\n+{\n+#if 0\n+  float f = 98.6f; /* { dg-warning \"test\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   float f = 98.6f;\n+             ^~~~~\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_caret_within_proper_range (void)\n+{\n+#if 0\n+  float f = foo * bar; /* { dg-warning \"17: test\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   float f = foo * bar;\n+             ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_very_wide_line (void)\n+{\n+#if 0\n+                                                                                float f = foo * bar; /* { dg-warning \"95: test\" } */\n+/* { dg-begin-multiline-output \"\" }\n+                                              float f = foo * bar;\n+                                                        ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_multiple_carets (void)\n+{\n+#if 0\n+   x = x + y /* { dg-warning \"8: test\" } */\n+/* { dg-begin-multiline-output \"\" }\n+    x = x + y\n+        A   B\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_caret_on_leading_whitespace (void)\n+{\n+#if 0\n+    ASSOCIATE (y => x)\n+      y = 5 /* { dg-warning \"6: test\" } */\n+/* { dg-begin-multiline-output \"\" }\n+     ASSOCIATE (y => x)\n+                    2\n+       y = 5\n+      1\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}"}, {"sha": "47639b22fc976db66032f8a2a6d5228178b14167", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-show-locus-color.c", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-show-locus-color.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -0,0 +1,158 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdiagnostics-show-caret -fplugin-arg-diagnostic_plugin_test_show_locus-color\" } */\n+\n+/* This is a collection of unittests for diagnostic_show_locus;\n+   see the overview in diagnostic_plugin_test_show_locus.c.\n+\n+   In particular, note the discussion of why we need a very long line here:\n+01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+   and that we can't use macros in this file.  */\n+\n+void test_simple (void)\n+{\n+#if 0\n+  myvar = myvar.x; /* { dg-warning \"test\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+   myvar = \u001b[32m\u001b[Kmyvar\u001b[m\u001b[K\u001b[01;35m\u001b[K.\u001b[m\u001b[K\u001b[34m\u001b[Kx\u001b[m\u001b[K;\n+           \u001b[32m\u001b[K~~~~~\u001b[m\u001b[K\u001b[01;35m\u001b[K^\u001b[m\u001b[K\u001b[34m\u001b[K~\n+\u001b[m\u001b[K\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_simple_2 (void)\n+{\n+#if 0\n+  x = first_function () + second_function ();  /* { dg-warning \"test\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+   x = \u001b[32m\u001b[Kfirst_function ()\u001b[m\u001b[K \u001b[01;35m\u001b[K+\u001b[m\u001b[K \u001b[34m\u001b[Ksecond_function ()\u001b[m\u001b[K;\n+       \u001b[32m\u001b[K~~~~~~~~~~~~~~~~~\u001b[m\u001b[K \u001b[01;35m\u001b[K^\u001b[m\u001b[K \u001b[34m\u001b[K~~~~~~~~~~~~~~~~~~\n+\u001b[m\u001b[K\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+\n+void test_multiline (void)\n+{\n+#if 0\n+  x = (first_function ()\n+       + second_function ()); /* { dg-warning \"test\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+   x = (\u001b[32m\u001b[Kfirst_function ()\n+ \u001b[m\u001b[K       \u001b[32m\u001b[K~~~~~~~~~~~~~~~~~\n+\u001b[m\u001b[K        \u001b[01;35m\u001b[K+\u001b[m\u001b[K \u001b[34m\u001b[Ksecond_function ()\u001b[m\u001b[K);\n+        \u001b[01;35m\u001b[K^\u001b[m\u001b[K \u001b[34m\u001b[K~~~~~~~~~~~~~~~~~~\n+\u001b[m\u001b[K\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_many_lines (void)\n+{\n+#if 0\n+  x = (first_function_with_a_very_long_name (lorem, ipsum, dolor, sit, amet,\n+                                            consectetur, adipiscing, elit,\n+                                            sed, eiusmod, tempor,\n+                                            incididunt, ut, labore, et,\n+                                            dolore, magna, aliqua)\n+       + second_function_with_a_very_long_name (lorem, ipsum, dolor, sit, /* { dg-warning \"test\" } */\n+                                                amet, consectetur,\n+                                                adipiscing, elit, sed,\n+                                                eiusmod, tempor, incididunt,\n+                                                ut, labore, et, dolore,\n+                                                magna, aliqua));\n+\n+/* { dg-begin-multiline-output \"\" }\n+   x = (\u001b[32m\u001b[Kfirst_function_with_a_very_long_name (lorem, ipsum, dolor, sit, amet,\n+ \u001b[m\u001b[K       \u001b[32m\u001b[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\u001b[m\u001b[K \u001b[32m\u001b[K                                            consectetur, adipiscing, elit,\n+ \u001b[m\u001b[K                                            \u001b[32m\u001b[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\u001b[m\u001b[K \u001b[32m\u001b[K                                            sed, eiusmod, tempor,\n+ \u001b[m\u001b[K                                            \u001b[32m\u001b[K~~~~~~~~~~~~~~~~~~~~~\n+\u001b[m\u001b[K \u001b[32m\u001b[K                                            incididunt, ut, labore, et,\n+ \u001b[m\u001b[K                                            \u001b[32m\u001b[K~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\u001b[m\u001b[K \u001b[32m\u001b[K                                            dolore, magna, aliqua)\n+ \u001b[m\u001b[K                                            \u001b[32m\u001b[K~~~~~~~~~~~~~~~~~~~~~~\n+\u001b[m\u001b[K        \u001b[01;35m\u001b[K+\u001b[m\u001b[K \u001b[34m\u001b[Ksecond_function_with_a_very_long_name (lorem, ipsum, dolor, sit,\n+ \u001b[m\u001b[K       \u001b[01;35m\u001b[K^\u001b[m\u001b[K \u001b[34m\u001b[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\u001b[m\u001b[K \u001b[34m\u001b[K                                                amet, consectetur,\n+ \u001b[m\u001b[K                                                \u001b[34m\u001b[K~~~~~~~~~~~~~~~~~~\n+\u001b[m\u001b[K \u001b[34m\u001b[K                                                adipiscing, elit, sed,\n+ \u001b[m\u001b[K                                                \u001b[34m\u001b[K~~~~~~~~~~~~~~~~~~~~~~\n+\u001b[m\u001b[K \u001b[34m\u001b[K                                                eiusmod, tempor, incididunt,\n+ \u001b[m\u001b[K                                                \u001b[34m\u001b[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\u001b[m\u001b[K \u001b[34m\u001b[K                                                ut, labore, et, dolore,\n+ \u001b[m\u001b[K                                                \u001b[34m\u001b[K~~~~~~~~~~~~~~~~~~~~~~~\n+\u001b[m\u001b[K \u001b[34m\u001b[K                                                magna, aliqua)\u001b[m\u001b[K);\n+                                                 \u001b[34m\u001b[K~~~~~~~~~~~~~~\n+\u001b[m\u001b[K\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_richloc_from_proper_range (void)\n+{\n+#if 0\n+  float f = 98.6f; /* { dg-warning \"test\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   float f = \u001b[01;35m\u001b[K98.6f\u001b[m\u001b[K;\n+             \u001b[01;35m\u001b[K^~~~~\n+\u001b[m\u001b[K\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_caret_within_proper_range (void)\n+{\n+#if 0\n+  float f = foo * bar; /* { dg-warning \"17: test\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   float f = \u001b[01;35m\u001b[Kfoo * bar\u001b[m\u001b[K;\n+             \u001b[01;35m\u001b[K~~~~^~~~~\n+\u001b[m\u001b[K\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_very_wide_line (void)\n+{\n+#if 0\n+                                                                                float f = foo * bar; /* { dg-warning \"95: test\" } */\n+/* { dg-begin-multiline-output \"\" }\n+                                              float f = \u001b[01;35m\u001b[Kfoo * bar\u001b[m\u001b[K;\n+                                                        \u001b[01;35m\u001b[K~~~~^~~~~\n+\u001b[m\u001b[K\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_multiple_carets (void)\n+{\n+#if 0\n+   x = x + y /* { dg-warning \"8: test\" } */\n+/* { dg-begin-multiline-output \"\" }\n+    x = \u001b[01;35m\u001b[Kx\u001b[m\u001b[K + \u001b[32m\u001b[Ky\u001b[m\u001b[K\n+        \u001b[01;35m\u001b[KA\u001b[m\u001b[K   \u001b[32m\u001b[KB\n+\u001b[m\u001b[K\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}\n+\n+void test_caret_on_leading_whitespace (void)\n+{\n+#if 0\n+    ASSOCIATE (y => x)\n+      y = 5 /* { dg-warning \"6: test\" } */\n+/* { dg-begin-multiline-output \"\" }\n+     ASSOCIATE (y =>\u001b[32m\u001b[K \u001b[m\u001b[Kx)\n+                    \u001b[32m\u001b[K2\n+\u001b[m\u001b[K      \u001b[01;35m\u001b[K \u001b[m\u001b[Ky = 5\n+      \u001b[01;35m\u001b[K1\n+\u001b[m\u001b[K\n+   { dg-end-multiline-output \"\" } */\n+#endif\n+}"}, {"sha": "8f5724ec27d9d4455a8b42b58a0b58964e44ac67", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic_plugin_test_show_locus.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_show_locus.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -0,0 +1,326 @@\n+/* { dg-options \"-O\" } */\n+\n+/* This plugin exercises the diagnostics-printing code.\n+\n+   The goal is to unit-test the range-printing code without needing any\n+   correct range data within the compiler's IR.  We can't use any real\n+   diagnostics for this, so we have to fake it, hence this plugin.\n+\n+   There are two test files used with this code:\n+\n+     diagnostic-test-show-locus-ascii-bw.c\n+     ..........................-ascii-color.c\n+\n+   to exercise uncolored vs colored output by supplying plugin arguments\n+   to hack in the desired behavior:\n+\n+     -fplugin-arg-diagnostic_plugin_test_show_locus-color\n+\n+   The test files contain functions, but the body of each\n+   function is disabled using the preprocessor.  The plugin detects\n+   the functions by name, and inject diagnostics within them, using\n+   hard-coded locations relative to the top of each function.\n+\n+   The plugin uses a function \"get_loc\" below to map from line/column\n+   numbers to source_location, and this relies on input_location being in\n+   the same ordinary line_map as the locations in question.  The plugin\n+   runs after parsing, so input_location will be at the end of the file.\n+\n+   This need for all of the test code to be in a single ordinary line map\n+   means that each test file needs to have a very long line near the top\n+   (potentially to cover the extra byte-count of colorized data),\n+   to ensure that further very long lines don't start a new linemap.\n+   This also means that we can't use macros in the test files.  */\n+\n+#include \"gcc-plugin.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"toplev.h\"\n+#include \"basic-block.h\"\n+#include \"hash-table.h\"\n+#include \"vec.h\"\n+#include \"ggc.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"intl.h\"\n+#include \"plugin-version.h\"\n+#include \"diagnostic.h\"\n+#include \"context.h\"\n+#include \"print-tree.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+const pass_data pass_data_test_show_locus =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"test_show_locus\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_test_show_locus : public gimple_opt_pass\n+{\n+public:\n+  pass_test_show_locus(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_test_show_locus, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate (function *) { return true; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_test_show_locus\n+\n+/* Given LINE_NUM and COL_NUM, generate a source_location in the\n+   current file, relative to input_location.  This relies on the\n+   location being expressible in the same ordinary line_map as\n+   input_location (which is typically at the end of the source file\n+   when this is called).  Hence the test files we compile with this\n+   plugin must have an initial very long line (to avoid long lines\n+   starting a new line map), and must not use macros.\n+\n+   COL_NUM uses the Emacs convention of 0-based column numbers.  */\n+\n+static source_location\n+get_loc (unsigned int line_num, unsigned int col_num)\n+{\n+  /* Use input_location to get the relevant line_map */\n+  const struct line_map_ordinary *line_map\n+    = (const line_map_ordinary *)(linemap_lookup (line_table,\n+\t\t\t\t\t\t  input_location));\n+\n+  /* Convert from 0-based column numbers to 1-based column numbers.  */\n+  source_location loc\n+    = linemap_position_for_line_and_column (line_map,\n+\t\t\t\t\t    line_num, col_num + 1);\n+\n+  return loc;\n+}\n+\n+/* Was \"color\" passed in as a plugin argument?  */\n+static bool force_show_locus_color = false;\n+\n+/* We want to verify the colorized output of diagnostic_show_locus,\n+   but turning on colorization for everything confuses \"dg-warning\" etc.\n+   Hence we special-case it within this plugin by using this modified\n+   version of default_diagnostic_finalizer, which, if \"color\" is\n+   passed in as a plugin argument turns on colorization, but just\n+   for diagnostic_show_locus.  */\n+\n+static void\n+custom_diagnostic_finalizer (diagnostic_context *context,\n+\t\t\t     diagnostic_info *diagnostic)\n+{\n+  bool old_show_color = pp_show_color (context->printer);\n+  if (force_show_locus_color)\n+    pp_show_color (context->printer) = true;\n+  diagnostic_show_locus (context, diagnostic);\n+  pp_show_color (context->printer) = old_show_color;\n+\n+  pp_destroy_prefix (context->printer);\n+  pp_newline_and_flush (context->printer);\n+}\n+\n+/* Exercise the diagnostic machinery to emit various warnings,\n+   for use by diagnostic-test-show-locus-*.c.\n+\n+   We inject each warning relative to the start of a function,\n+   which avoids lots of hardcoded absolute locations.  */\n+\n+static void\n+test_show_locus (function *fun)\n+{\n+  tree fndecl = fun->decl;\n+  tree identifier = DECL_NAME (fndecl);\n+  const char *fnname = IDENTIFIER_POINTER (identifier);\n+  location_t fnstart = fun->function_start_locus;\n+  int fnstart_line = LOCATION_LINE (fnstart);\n+\n+  diagnostic_finalizer (global_dc) = custom_diagnostic_finalizer;\n+\n+  /* Hardcode the \"terminal width\", to verify the behavior of\n+     very wide lines.  */\n+  global_dc->caret_max_width = 70;\n+\n+  if (0 == strcmp (fnname, \"test_simple\"))\n+    {\n+      const int line = fnstart_line + 2;\n+      rich_location richloc (get_loc (line, 15));\n+      richloc.add_range (get_loc (line, 10), get_loc (line, 14), false);\n+      richloc.add_range (get_loc (line, 16), get_loc (line, 16), false);\n+      warning_at_rich_loc (&richloc, 0, \"test\");\n+    }\n+\n+  if (0 == strcmp (fnname, \"test_simple_2\"))\n+    {\n+      const int line = fnstart_line + 2;\n+      rich_location richloc (get_loc (line, 24));\n+      richloc.add_range (get_loc (line, 6),\n+\t\t\t get_loc (line, 22), false);\n+      richloc.add_range (get_loc (line, 26),\n+\t\t\t get_loc (line, 43), false);\n+      warning_at_rich_loc (&richloc, 0, \"test\");\n+    }\n+\n+  if (0 == strcmp (fnname, \"test_multiline\"))\n+    {\n+      const int line = fnstart_line + 2;\n+      rich_location richloc (get_loc (line + 1, 7));\n+      richloc.add_range (get_loc (line, 7),\n+\t\t\t get_loc (line, 23), false);\n+      richloc.add_range (get_loc (line + 1, 9),\n+\t\t\t get_loc (line + 1, 26), false);\n+      warning_at_rich_loc (&richloc, 0, \"test\");\n+    }\n+\n+  if (0 == strcmp (fnname, \"test_many_lines\"))\n+    {\n+      const int line = fnstart_line + 2;\n+      rich_location richloc (get_loc (line + 5, 7));\n+      richloc.add_range (get_loc (line, 7),\n+\t\t\t get_loc (line + 4, 65), false);\n+      richloc.add_range (get_loc (line + 5, 9),\n+\t\t\t get_loc (line + 10, 61), false);\n+      warning_at_rich_loc (&richloc, 0, \"test\");\n+    }\n+\n+  /* Example of a rich_location constructed directly from a\n+     source_range where the range is larger than one character.  */\n+  if (0 == strcmp (fnname, \"test_richloc_from_proper_range\"))\n+    {\n+      const int line = fnstart_line + 2;\n+      source_range src_range;\n+      src_range.m_start = get_loc (line, 12);\n+      src_range.m_finish = get_loc (line, 16);\n+      rich_location richloc (src_range);\n+      warning_at_rich_loc (&richloc, 0, \"test\");\n+    }\n+\n+  /* Example of a single-range location where the range starts\n+     before the caret.  */\n+  if (0 == strcmp (fnname, \"test_caret_within_proper_range\"))\n+    {\n+      const int line = fnstart_line + 2;\n+      location_t caret = get_loc (line, 16);\n+      source_range src_range;\n+      src_range.m_start = get_loc (line, 12);\n+      src_range.m_finish = get_loc (line, 20);\n+      rich_location richloc (caret);\n+      richloc.set_range (0, src_range, true, false);\n+      warning_at_rich_loc (&richloc, 0, \"test\");\n+    }\n+\n+  /* Example of a very wide line, where the information of interest\n+     is beyond the width of the terminal (hardcoded above).  */\n+  if (0 == strcmp (fnname, \"test_very_wide_line\"))\n+    {\n+      const int line = fnstart_line + 2;\n+      location_t caret = get_loc (line, 94);\n+      source_range src_range;\n+      src_range.m_start = get_loc (line, 90);\n+      src_range.m_finish = get_loc (line, 98);\n+      rich_location richloc (caret);\n+      richloc.set_range (0, src_range, true, false);\n+      warning_at_rich_loc (&richloc, 0, \"test\");\n+    }\n+\n+  /* Example of multiple carets.  */\n+  if (0 == strcmp (fnname, \"test_multiple_carets\"))\n+    {\n+      const int line = fnstart_line + 2;\n+      location_t caret_a = get_loc (line, 7);\n+      location_t caret_b = get_loc (line, 11);\n+      rich_location richloc (caret_a);\n+      richloc.add_range (caret_b, caret_b, true);\n+      global_dc->caret_chars[0] = 'A';\n+      global_dc->caret_chars[1] = 'B';\n+      warning_at_rich_loc (&richloc, 0, \"test\");\n+      global_dc->caret_chars[0] = '^';\n+      global_dc->caret_chars[1] = '^';\n+    }\n+\n+  /* Example of two carets where both carets appear to have an off-by-one\n+     error appearing one column early.\n+     Seen with gfortran.dg/associate_5.f03.\n+     In an earlier version of the printer, the printing of caret 0 aka\n+     \"1\" was suppressed due to it appearing within the leading whitespace\n+     before the text in its line.  Ensure that we at least faithfully\n+     print both carets, at the given (erroneous) locations.  */\n+  if (0 == strcmp (fnname, \"test_caret_on_leading_whitespace\"))\n+    {\n+      const int line = fnstart_line + 3;\n+      location_t caret_a = get_loc (line, 5);\n+      location_t caret_b = get_loc (line - 1, 19);\n+      rich_location richloc (caret_a);\n+      richloc.add_range (caret_b, caret_b, true);\n+      global_dc->caret_chars[0] = '1';\n+      global_dc->caret_chars[1] = '2';\n+      warning_at_rich_loc (&richloc, 0, \"test\");\n+      global_dc->caret_chars[0] = '^';\n+      global_dc->caret_chars[1] = '^';\n+    }\n+}\n+\n+unsigned int\n+pass_test_show_locus::execute (function *fun)\n+{\n+  test_show_locus (fun);\n+  return 0;\n+}\n+\n+static gimple_opt_pass *\n+make_pass_test_show_locus (gcc::context *ctxt)\n+{\n+  return new pass_test_show_locus (ctxt);\n+}\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  struct register_pass_info pass_info;\n+  const char *plugin_name = plugin_info->base_name;\n+  int argc = plugin_info->argc;\n+  struct plugin_argument *argv = plugin_info->argv;\n+\n+  if (!plugin_default_version_check (version, &gcc_version))\n+    return 1;\n+\n+  /* For now, tell the dc to expect ranges and thus to colorize the source\n+     lines, not just the carets/underlines.  This will be redundant\n+     once the C frontend generates ranges.  */\n+  global_dc->colorize_source_p = true;\n+\n+  for (int i = 0; i < argc; i++)\n+    {\n+      if (0 == strcmp (argv[i].key, \"color\"))\n+\tforce_show_locus_color = true;\n+    }\n+\n+  pass_info.pass = make_pass_test_show_locus (g);\n+  pass_info.reference_pass_name = \"ssa\";\n+  pass_info.ref_pass_instance_number = 1;\n+  pass_info.pos_op = PASS_POS_INSERT_AFTER;\n+  register_callback (plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,\n+\t\t     &pass_info);\n+\n+  return 0;\n+}"}, {"sha": "941bccc438718daf625e85254ae88c963e623a83", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -63,6 +63,9 @@ set plugin_test_list [list \\\n     { start_unit_plugin.c start_unit-test-1.c } \\\n     { finish_unit_plugin.c finish_unit-test-1.c } \\\n     { wide-int_plugin.c wide-int-test-1.c } \\\n+    { diagnostic_plugin_test_show_locus.c \\\n+\t  diagnostic-test-show-locus-bw.c \\\n+\t  diagnostic-test-show-locus-color.c } \\\n ]\n \n foreach plugin_test $plugin_test_list {"}, {"sha": "8cc1d87d6495a35162dbce5e7e9e7a26f03e5c4a", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -29,6 +29,7 @@ load_lib libgloss.exp\n load_lib target-libpath.exp\n load_lib torture-options.exp\n load_lib fortran-modules.exp\n+load_lib multiline.exp\n \n # We set LC_ALL and LANG to C so that we get the same error messages as expected.\n setenv LC_ALL C"}, {"sha": "bbb830b3e06c4c7546807c8981990b2d22bd7447", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -286,7 +286,7 @@ default_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n     }\n \n   if (set_locus)\n-    text->set_location (0, DECL_SOURCE_LOCATION (t));\n+    text->set_location (0, DECL_SOURCE_LOCATION (t), true);\n \n   if (DECL_P (t))\n     {"}, {"sha": "3f0a4e6cfe08de2c5fd131315c39de9f337c4e97", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -3770,7 +3770,7 @@ void\n percent_K_format (text_info *text)\n {\n   tree t = va_arg (*text->args_ptr, tree), block;\n-  text->set_location (0, EXPR_LOCATION (t));\n+  text->set_location (0, EXPR_LOCATION (t), true);\n   gcc_assert (pp_ti_abstract_origin (text) != NULL);\n   block = TREE_BLOCK (t);\n   *pp_ti_abstract_origin (text) = NULL;"}, {"sha": "57ac5bfbde1f1ffeb0090a710b5b84b76ef8252c", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -1,3 +1,22 @@\n+2015-11-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* errors.c (cpp_diagnostic): Update for change in signature\n+\tof \"error\" callback.\n+\t(cpp_diagnostic_with_line): Likewise, calling override_column\n+\ton the rich_location.\n+\t* include/cpplib.h (struct cpp_callbacks): Within \"error\"\n+\tcallback, convert param from source_location to rich_location *,\n+\tand drop column_override param.\n+\t* include/line-map.h (struct source_range): New struct.\n+\t(struct location_range): New struct.\n+\t(class rich_location): New class.\n+\t(linemap_client_expand_location_to_spelling_point): New declaration.\n+\t* line-map.c (rich_location::rich_location): New ctors.\n+\t(rich_location::lazily_expand_location): New method.\n+\t(rich_location::override_column): New method.\n+\t(rich_location::add_range): New methods.\n+\t(rich_location::set_range): New method.\n+\n 2015-11-06  David Malcolm  <dmalcolm@redhat.com>\n \n \t* include/line-map.h (struct linemap_stats): Add fields"}, {"sha": "c351c112ad135f4496f4adca8a4bb483f4313004", "filename": "libcpp/errors.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/libcpp%2Ferrors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/libcpp%2Ferrors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ferrors.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -57,7 +57,8 @@ cpp_diagnostic (cpp_reader * pfile, int level, int reason,\n \n   if (!pfile->cb.error)\n     abort ();\n-  ret = pfile->cb.error (pfile, level, reason, src_loc, 0, _(msgid), ap);\n+  rich_location richloc (src_loc);\n+  ret = pfile->cb.error (pfile, level, reason, &richloc, _(msgid), ap);\n \n   return ret;\n }\n@@ -139,7 +140,9 @@ cpp_diagnostic_with_line (cpp_reader * pfile, int level, int reason,\n   \n   if (!pfile->cb.error)\n     abort ();\n-  ret = pfile->cb.error (pfile, level, reason, src_loc, column, _(msgid), ap);\n+  rich_location richloc (src_loc);\n+  richloc.override_column (column);\n+  ret = pfile->cb.error (pfile, level, reason, &richloc, _(msgid), ap);\n \n   return ret;\n }"}, {"sha": "a2bdfa0c808df62b9dfc756243aa398beb6f1f15", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -573,9 +573,9 @@ struct cpp_callbacks\n \n   /* Called to emit a diagnostic.  This callback receives the\n      translated message.  */\n-  bool (*error) (cpp_reader *, int, int, source_location, unsigned int,\n+  bool (*error) (cpp_reader *, int, int, rich_location *,\n \t\t const char *, va_list *)\n-       ATTRIBUTE_FPTR_PRINTF(6,0);\n+       ATTRIBUTE_FPTR_PRINTF(5,0);\n \n   /* Callbacks for when a macro is expanded, or tested (whether\n      defined or not at the time) in #ifdef, #ifndef or \"defined\".  */"}, {"sha": "c9340a6eaefb062f3bcd843b37933aa9a3bfa4bc", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -131,6 +131,47 @@ typedef unsigned int linenum_type;\n   libcpp/location-example.txt.  */\n typedef unsigned int source_location;\n \n+/* A range of source locations.\n+\n+   Ranges are closed:\n+   m_start is the first location within the range,\n+   m_finish is the last location within the range.\n+\n+   We may need a more compact way to store these, but for now,\n+   let's do it the simple way, as a pair.  */\n+struct GTY(()) source_range\n+{\n+  source_location m_start;\n+  source_location m_finish;\n+\n+  /* Display this source_range instance, with MSG as a descriptive\n+     comment.  This issues a \"note\" diagnostic at the range, using\n+     gcc's diagnostic machinery.\n+\n+     This is declared here, but is implemented within gcc/diagnostic.c,\n+     since it makes use of gcc's diagnostic-printing machinery.  This\n+     is a slight layering violation, but this is sufficiently useful\n+     for debugging that it's worth it.\n+\n+     This declaration would have a DEBUG_FUNCTION annotation, but that\n+     is implemented in gcc/system.h and thus is not available here in\n+     libcpp.  */\n+  void debug (const char *msg) const;\n+\n+  /* We avoid using constructors, since various structs that\n+     don't yet have constructors will embed instances of\n+     source_range.  */\n+\n+  /* Make a source_range from a source_location.  */\n+  static source_range from_location (source_location loc)\n+  {\n+    source_range result;\n+    result.m_start = loc;\n+    result.m_finish = loc;\n+    return result;\n+  }\n+};\n+\n /* Memory allocation function typedef.  Works like xrealloc.  */\n typedef void *(*line_map_realloc) (void *, size_t);\n \n@@ -1028,6 +1069,174 @@ typedef struct\n   bool sysp;\n } expanded_location;\n \n+/* Both gcc and emacs number source *lines* starting at 1, but\n+   they have differing conventions for *columns*.\n+\n+   GCC uses a 1-based convention for source columns,\n+   whereas Emacs's M-x column-number-mode uses a 0-based convention.\n+\n+   For example, an error in the initial, left-hand\n+   column of source line 3 is reported by GCC as:\n+\n+      some-file.c:3:1: error: ...etc...\n+\n+   On navigating to the location of that error in Emacs\n+   (e.g. via \"next-error\"),\n+   the locus is reported in the Mode Line\n+   (assuming M-x column-number-mode) as:\n+\n+     some-file.c   10%   (3, 0)\n+\n+   i.e. \"3:1:\" in GCC corresponds to \"(3, 0)\" in Emacs.  */\n+\n+/* Ranges are closed\n+   m_start is the first location within the range, and\n+   m_finish is the last location within the range.  */\n+struct location_range\n+{\n+  expanded_location m_start;\n+  expanded_location m_finish;\n+\n+  /* Should a caret be drawn for this range?  Typically this is\n+     true for the 0th range, and false for subsequent ranges,\n+     but the Fortran frontend overrides this for rendering things like:\n+\n+       x = x + y\n+           1   2\n+       Error: Shapes for operands at (1) and (2) are not conformable\n+\n+     where \"1\" and \"2\" are notionally carets.  */\n+  bool m_show_caret_p;\n+  expanded_location m_caret;\n+};\n+\n+/* A \"rich\" source code location, for use when printing diagnostics.\n+   A rich_location has one or more ranges, each optionally with\n+   a caret.   Typically the zeroth range has a caret; other ranges\n+   sometimes have carets.\n+\n+   The \"primary\" location of a rich_location is the caret of range 0,\n+   used for determining the line/column when printing diagnostic\n+   text, such as:\n+\n+      some-file.c:3:1: error: ...etc...\n+\n+   Additional ranges may be added to help the user identify other\n+   pertinent clauses in a diagnostic.\n+\n+   rich_location instances are intended to be allocated on the stack\n+   when generating diagnostics, and to be short-lived.\n+\n+   Examples of rich locations\n+   --------------------------\n+\n+   Example A\n+   *********\n+      int i = \"foo\";\n+              ^\n+   This \"rich\" location is simply a single range (range 0), with\n+   caret = start = finish at the given point.\n+\n+   Example B\n+   *********\n+      a = (foo && bar)\n+          ~~~~~^~~~~~~\n+   This rich location has a single range (range 0), with the caret\n+   at the first \"&\", and the start/finish at the parentheses.\n+   Compare with example C below.\n+\n+   Example C\n+   *********\n+      a = (foo && bar)\n+           ~~~ ^~ ~~~\n+   This rich location has three ranges:\n+   - Range 0 has its caret and start location at the first \"&\" and\n+     end at the second \"&.\n+   - Range 1 has its start and finish at the \"f\" and \"o\" of \"foo\";\n+     the caret is not flagged for display, but is perhaps at the \"f\"\n+     of \"foo\".\n+   - Similarly, range 2 has its start and finish at the \"b\" and \"r\" of\n+     \"bar\"; the caret is not flagged for display, but is perhaps at the\n+     \"b\" of \"bar\".\n+   Compare with example B above.\n+\n+   Example D (Fortran frontend)\n+   ****************************\n+       x = x + y\n+           1   2\n+   This rich location has range 0 at \"1\", and range 1 at \"2\".\n+   Both are flagged for caret display.  Both ranges have start/finish\n+   equal to their caret point.  The frontend overrides the diagnostic\n+   context's default caret character for these ranges.\n+\n+   Example E\n+   *********\n+      printf (\"arg0: %i  arg1: %s arg2: %i\",\n+                               ^~\n+              100, 101, 102);\n+                   ~~~\n+   This rich location has two ranges:\n+   - range 0 is at the \"%s\" with start = caret = \"%\" and finish at\n+     the \"s\".\n+   - range 1 has start/finish covering the \"101\" and is not flagged for\n+     caret printing; it is perhaps at the start of \"101\".  */\n+\n+class rich_location\n+{\n+ public:\n+  /* Constructors.  */\n+\n+  /* Constructing from a location.  */\n+  rich_location (source_location loc);\n+\n+  /* Constructing from a source_range.  */\n+  rich_location (source_range src_range);\n+\n+  /* Accessors.  */\n+  source_location get_loc () const { return m_loc; }\n+\n+  source_location *get_loc_addr () { return &m_loc; }\n+\n+  void\n+  add_range (source_location start, source_location finish,\n+\t     bool show_caret_p);\n+\n+  void\n+  add_range (source_range src_range, bool show_caret_p);\n+\n+  void\n+  add_range (location_range *src_range);\n+\n+  void\n+  set_range (unsigned int idx, source_range src_range,\n+\t     bool show_caret_p, bool overwrite_loc_p);\n+\n+  unsigned int get_num_locations () const { return m_num_ranges; }\n+\n+  location_range *get_range (unsigned int idx)\n+  {\n+    linemap_assert (idx < m_num_ranges);\n+    return &m_ranges[idx];\n+  }\n+\n+  expanded_location lazily_expand_location ();\n+\n+  void\n+  override_column (int column);\n+\n+public:\n+  static const int MAX_RANGES = 3;\n+\n+protected:\n+  source_location m_loc;\n+\n+  unsigned int m_num_ranges;\n+  location_range m_ranges[MAX_RANGES];\n+\n+  bool m_have_expanded_location;\n+  expanded_location m_expanded_location;\n+};\n+\n /* This is enum is used by the function linemap_resolve_location\n    below.  The meaning of the values is explained in the comment of\n    that function.  */\n@@ -1173,4 +1382,13 @@ void linemap_dump (FILE *, struct line_maps *, unsigned, bool);\n    specifies how many macro maps to dump.  */\n void line_table_dump (FILE *, struct line_maps *, unsigned int, unsigned int);\n \n+/* The rich_location class requires a way to expand source_location instances.\n+   We would directly use expand_location_to_spelling_point, which is\n+   implemented in gcc/input.c, but we also need to use it for rich_location\n+   within genmatch.c.\n+   Hence we require client code of libcpp to implement the following\n+   symbol.  */\n+extern expanded_location\n+linemap_client_expand_location_to_spelling_point (source_location );\n+\n #endif /* !LIBCPP_LINE_MAP_H  */"}, {"sha": "3c19f93b7a5a671781775cd4493ae687361877d9", "filename": "libcpp/line-map.c", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a64515099e64564542cbd09be7c9a21c2f580f3/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a64515099e64564542cbd09be7c9a21c2f580f3/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=8a64515099e64564542cbd09be7c9a21c2f580f3", "patch": "@@ -1755,3 +1755,133 @@ line_table_dump (FILE *stream, struct line_maps *set, unsigned int num_ordinary,\n       fprintf (stream, \"\\n\");\n     }\n }\n+\n+/* class rich_location.  */\n+\n+/* Construct a rich_location with location LOC as its initial range.  */\n+\n+rich_location::rich_location (source_location loc) :\n+  m_loc (loc),\n+  m_num_ranges (0),\n+  m_have_expanded_location (false)\n+{\n+  /* Set up the 0th range: */\n+  add_range (loc, loc, true);\n+  m_ranges[0].m_caret = lazily_expand_location ();\n+}\n+\n+/* Construct a rich_location with source_range SRC_RANGE as its\n+   initial range.  */\n+\n+rich_location::rich_location (source_range src_range)\n+: m_loc (src_range.m_start),\n+  m_num_ranges (0),\n+  m_have_expanded_location (false)\n+{\n+  /* Set up the 0th range: */\n+  add_range (src_range, true);\n+}\n+\n+/* Get an expanded_location for this rich_location's primary\n+   location.  */\n+\n+expanded_location\n+rich_location::lazily_expand_location ()\n+{\n+  if (!m_have_expanded_location)\n+    {\n+      m_expanded_location\n+\t= linemap_client_expand_location_to_spelling_point (m_loc);\n+      m_have_expanded_location = true;\n+    }\n+\n+  return m_expanded_location;\n+}\n+\n+/* Set the column of the primary location.  */\n+\n+void\n+rich_location::override_column (int column)\n+{\n+  lazily_expand_location ();\n+  m_expanded_location.column = column;\n+}\n+\n+/* Add the given range.  */\n+\n+void\n+rich_location::add_range (source_location start, source_location finish,\n+\t\t\t  bool show_caret_p)\n+{\n+  linemap_assert (m_num_ranges < MAX_RANGES);\n+\n+  location_range *range = &m_ranges[m_num_ranges++];\n+  range->m_start = linemap_client_expand_location_to_spelling_point (start);\n+  range->m_finish = linemap_client_expand_location_to_spelling_point (finish);\n+  range->m_caret = range->m_start;\n+  range->m_show_caret_p = show_caret_p;\n+}\n+\n+/* Add the given range.  */\n+\n+void\n+rich_location::add_range (source_range src_range, bool show_caret_p)\n+{\n+  linemap_assert (m_num_ranges < MAX_RANGES);\n+\n+  add_range (src_range.m_start, src_range.m_finish, show_caret_p);\n+}\n+\n+void\n+rich_location::add_range (location_range *src_range)\n+{\n+  linemap_assert (m_num_ranges < MAX_RANGES);\n+\n+  m_ranges[m_num_ranges++] = *src_range;\n+}\n+\n+/* Add or overwrite the range given by IDX.  It must either\n+   overwrite an existing range, or add one *exactly* on the end of\n+   the array.\n+\n+   This is primarily for use by gcc when implementing diagnostic\n+   format decoders e.g. the \"+\" in the C/C++ frontends, for handling\n+   format codes like \"%q+D\" (which writes the source location of a\n+   tree back into range 0 of the rich_location).\n+\n+   If SHOW_CARET_P is true, then the range should be rendered with\n+   a caret at its starting location.  This\n+   is for use by the Fortran frontend, for implementing the\n+   \"%C\" and \"%L\" format codes.  */\n+\n+void\n+rich_location::set_range (unsigned int idx, source_range src_range,\n+\t\t\t  bool show_caret_p, bool overwrite_loc_p)\n+{\n+  linemap_assert (idx < MAX_RANGES);\n+\n+  /* We can either overwrite an existing range, or add one exactly\n+     on the end of the array.  */\n+  linemap_assert (idx <= m_num_ranges);\n+\n+  location_range *locrange = &m_ranges[idx];\n+  locrange->m_start\n+    = linemap_client_expand_location_to_spelling_point (src_range.m_start);\n+  locrange->m_finish\n+    = linemap_client_expand_location_to_spelling_point (src_range.m_finish);\n+\n+  locrange->m_show_caret_p = show_caret_p;\n+  if (overwrite_loc_p)\n+    locrange->m_caret = locrange->m_start;\n+\n+  /* Are we adding a range onto the end?  */\n+  if (idx == m_num_ranges)\n+    m_num_ranges = idx + 1;\n+\n+  if (idx == 0 && overwrite_loc_p)\n+    {\n+      m_loc = src_range.m_start;\n+      /* Mark any cached value here as dirty.  */\n+      m_have_expanded_location = false;\n+    }\n+}"}]}