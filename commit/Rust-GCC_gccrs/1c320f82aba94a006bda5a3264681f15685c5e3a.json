{"sha": "1c320f82aba94a006bda5a3264681f15685c5e3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWMzMjBmODJhYmE5NGEwMDZiZGE1YTMyNjQ2ODFmMTU2ODVjNWUzYQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-05-27T22:57:39Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-05-27T22:57:39Z"}, "message": "reg-stack.c (compensate_edge): Remove original prototype.\n\n\n\t* reg-stack.c (compensate_edge): Remove original prototype.\n\t(propagate_stack): New function to copy the stack layout\n\tat the start of a basic block from the layout at the end of\n\tone of its predecessors.\n\t(compensate_edge): Assume that both source and destination\n\tblocks have already had their stack layouts defined.\n\t(compensate_edges): Traverse all non-entry edges in the CFG\n\tand call compensate_edge on each in turn.\n\t(convert_regs_1): Change return type to void.  Call\n\tpropagate_stack instead of compensate_edge.\n\t(convert_regs_2): Change return type to void.  Update call\n\tto convert_regs_1 to ignore the (now void) return value.\n\t(convert_regs): Update calls to convert_regs_2 to ignore\n\tthe (now void) return value.  After all the basic blocks have\n\tbeen processed, call compensate_edges to actually emit new\n\tinsns.\n\t(reg_to_stack): Initialize the aux info for each basic block\n\twith FOR_EACH_BB instead of which FOR_EACH_BB_REVERSE.\n\nFrom-SVN: r100283", "tree": {"sha": "c748dc271d28039f2d586b93c3aa2c1f6f3a2ed3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c748dc271d28039f2d586b93c3aa2c1f6f3a2ed3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c320f82aba94a006bda5a3264681f15685c5e3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c320f82aba94a006bda5a3264681f15685c5e3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c320f82aba94a006bda5a3264681f15685c5e3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c320f82aba94a006bda5a3264681f15685c5e3a/comments", "author": null, "committer": null, "parents": [{"sha": "b59fa6cf91b357b25e00dd3f1c3e88dd5d0220e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b59fa6cf91b357b25e00dd3f1c3e88dd5d0220e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b59fa6cf91b357b25e00dd3f1c3e88dd5d0220e2"}], "stats": {"total": 152, "additions": 97, "deletions": 55}, "files": [{"sha": "2b4e78bb3b02e16752de73b01e9c67e76d702018", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c320f82aba94a006bda5a3264681f15685c5e3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c320f82aba94a006bda5a3264681f15685c5e3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c320f82aba94a006bda5a3264681f15685c5e3a", "patch": "@@ -1,3 +1,24 @@\n+2005-05-27  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* reg-stack.c (compensate_edge): Remove original prototype.\n+\t(propagate_stack): New function to copy the stack layout\n+\tat the start of a basic block from the layout at the end of\n+\tone of its predecessors.\n+\t(compensate_edge): Assume that both source and destination\n+\tblocks have already had their stack layouts defined.\n+\t(compensate_edges): Traverse all non-entry edges in the CFG\n+\tand call compensate_edge on each in turn.\n+\t(convert_regs_1): Change return type to void.  Call\n+\tpropagate_stack instead of compensate_edge.\n+\t(convert_regs_2): Change return type to void.  Update call\n+\tto convert_regs_1 to ignore the (now void) return value.\n+\t(convert_regs): Update calls to convert_regs_2 to ignore\n+\tthe (now void) return value.  After all the basic blocks have\n+\tbeen processed, call compensate_edges to actually emit new\n+\tinsns.\n+\t(reg_to_stack): Initialize the aux info for each basic block\n+\twith FOR_EACH_BB instead of which FOR_EACH_BB_REVERSE.\n+\n 2005-05-28  Jan Hubicka  <jh@suse.cz>\n \n \t* except.c (can_throw_internal_1, can_throw_external_1): Add "}, {"sha": "6aaa8bed0d4e4a57003d53353a74a9076a2fc0b5", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 76, "deletions": 55, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c320f82aba94a006bda5a3264681f15685c5e3a/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c320f82aba94a006bda5a3264681f15685c5e3a/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=1c320f82aba94a006bda5a3264681f15685c5e3a", "patch": "@@ -261,7 +261,6 @@ static bool subst_stack_regs (rtx, stack);\n static void change_stack (rtx, stack, stack, enum emit_where);\n static void print_stack (FILE *, stack);\n static rtx next_flags_user (rtx);\n-static bool compensate_edge (edge, FILE *);\n \f\n /* Return nonzero if any stack register is mentioned somewhere within PAT.  */\n \n@@ -2579,9 +2578,35 @@ convert_regs_exit (void)\n     }\n }\n \n-/* Adjust the stack of this block on exit to match the stack of the\n-   target block, or copy stack info into the stack of the successor\n-   of the successor hasn't been processed yet.  */\n+/* If the stack of the target block hasn't been processed yet,\n+   copy the stack info from the source block.  */\n+\n+static void\n+propagate_stack (edge e)\n+{\n+  basic_block dest = e->dest;\n+  stack dest_stack = &BLOCK_INFO (dest)->stack_in;\n+\n+  if (dest_stack->top == -2)\n+    {\n+      basic_block src = e->src;\n+      stack src_stack = &BLOCK_INFO (src)->stack_out;\n+      int reg;\n+\n+      /* Preserve the order of the original stack, but check whether\n+\t any pops are needed.  */\n+      dest_stack->top = -1;\n+      for (reg = 0; reg <= src_stack->top; ++reg)\n+\tif (TEST_HARD_REG_BIT (dest_stack->reg_set, src_stack->reg[reg]))\n+\t  dest_stack->reg[++dest_stack->top] = src_stack->reg[reg];\n+    }\n+}\n+\n+\n+/* Adjust the stack of edge E's source block on exit to match the stack\n+   of it's target block upon input.  The stack layouts of both blocks\n+   should have been defined by now.  */\n+\n static bool\n compensate_edge (edge e, FILE *file)\n {\n@@ -2596,50 +2621,27 @@ compensate_edge (edge e, FILE *file)\n   if (file)\n     fprintf (file, \"Edge %d->%d: \", block->index, target->index);\n \n-  if (target_stack->top == -2)\n+  gcc_assert (target_stack->top != -2);\n+\n+  /* Check whether stacks are identical.  */\n+  if (target_stack->top == regstack.top)\n     {\n-      /* The target block hasn't had a stack order selected.\n-         We need merely ensure that no pops are needed.  */\n-      for (reg = regstack.top; reg >= 0; --reg)\n-\tif (!TEST_HARD_REG_BIT (target_stack->reg_set, regstack.reg[reg]))\n+      for (reg = target_stack->top; reg >= 0; --reg)\n+\tif (target_stack->reg[reg] != regstack.reg[reg])\n \t  break;\n \n       if (reg == -1)\n \t{\n \t  if (file)\n-\t    fprintf (file, \"new block; copying stack position\\n\");\n-\n-\t  /* change_stack kills values in regstack.  */\n-\t  tmpstack = regstack;\n-\n-\t  change_stack (BB_END (block), &tmpstack, target_stack, EMIT_AFTER);\n+\t    fprintf (file, \"no changes needed\\n\");\n \t  return false;\n \t}\n-\n-      if (file)\n-\tfprintf (file, \"new block; pops needed\\n\");\n     }\n-  else\n-    {\n-      if (target_stack->top == regstack.top)\n-\t{\n-\t  for (reg = target_stack->top; reg >= 0; --reg)\n-\t    if (target_stack->reg[reg] != regstack.reg[reg])\n-\t      break;\n-\n-\t  if (reg == -1)\n-\t    {\n-\t      if (file)\n-\t\tfprintf (file, \"no changes needed\\n\");\n-\t      return false;\n-\t    }\n-\t}\n \n-      if (file)\n-\t{\n-\t  fprintf (file, \"correcting stack to \");\n-\t  print_stack (file, target_stack);\n-\t}\n+  if (file)\n+    {\n+      fprintf (file, \"correcting stack to \");\n+      print_stack (file, target_stack);\n     }\n \n   /* Care for non-call EH edges specially.  The normal return path have\n@@ -2714,20 +2716,41 @@ compensate_edge (edge e, FILE *file)\n   return false;\n }\n \n+/* Traverse all non-entry edges in the CFG, and emit the necessary\n+   edge compensation code to change the stack from stack_out of the\n+   source block to the stack_in of the destination block.  */\n+\n+static bool\n+compensate_edges (FILE *file)\n+{\n+  bool inserted = false;\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    if (bb != ENTRY_BLOCK_PTR)\n+      {\n+        edge e;\n+        edge_iterator ei;\n+\n+        FOR_EACH_EDGE (e, ei, bb->succs)\n+\t  inserted |= compensate_edge (e, file);\n+      }\n+  return inserted;\n+}\n+\n /* Convert stack register references in one block.  */\n \n-static int\n+static void\n convert_regs_1 (FILE *file, basic_block block)\n {\n   struct stack_def regstack;\n   block_info bi = BLOCK_INFO (block);\n-  int inserted, reg;\n+  int reg;\n   rtx insn, next;\n   edge e, beste = NULL;\n   bool control_flow_insn_deleted = false;\n   edge_iterator ei;\n \n-  inserted = 0;\n   any_malformed_asm = false;\n \n   /* Find the edge we will copy stack from.  It should be the most frequent\n@@ -2763,7 +2786,7 @@ convert_regs_1 (FILE *file, basic_block block)\n   if (bi->stack_in.top == -2)\n     {\n       if (beste)\n-\tinserted |= compensate_edge (beste, file);\n+\tpropagate_stack (beste);\n       else\n \t{\n \t  /* No predecessors.  Create an arbitrary input stack.  */\n@@ -2887,29 +2910,27 @@ convert_regs_1 (FILE *file, basic_block block)\n \t{\n \t  gcc_assert (BLOCK_INFO (e->dest)->done\n \t\t      || e->dest == block);\n-\t  inserted |= compensate_edge (e, file);\n+\t  propagate_stack (e);\n \t}\n     }\n+\n   FOR_EACH_EDGE (e, ei, block->preds)\n     {\n       if (e != beste && !(e->flags & EDGE_DFS_BACK)\n \t  && e->src != ENTRY_BLOCK_PTR)\n \t{\n \t  gcc_assert (BLOCK_INFO (e->src)->done);\n-\t  inserted |= compensate_edge (e, file);\n+\t  propagate_stack (e);\n \t}\n     }\n-\n-  return inserted;\n }\n \n /* Convert registers in all blocks reachable from BLOCK.  */\n \n-static int\n+static void\n convert_regs_2 (FILE *file, basic_block block)\n {\n   basic_block *stack, *sp;\n-  int inserted;\n \n   /* We process the blocks in a top-down manner, in a way such that one block\n      is only processed after all its predecessors.  The number of predecessors\n@@ -2920,7 +2941,6 @@ convert_regs_2 (FILE *file, basic_block block)\n \n   *sp++ = block;\n \n-  inserted = 0;\n   do\n     {\n       edge e;\n@@ -2949,14 +2969,12 @@ convert_regs_2 (FILE *file, basic_block block)\n \t      *sp++ = e->dest;\n \t  }\n \n-      inserted |= convert_regs_1 (file, block);\n+      convert_regs_1 (file, block);\n       BLOCK_INFO (block)->done = 1;\n     }\n   while (sp != stack);\n \n   free (stack);\n-\n-  return inserted;\n }\n \n /* Traverse all basic blocks in a function, converting the register\n@@ -2984,7 +3002,7 @@ convert_regs (FILE *file)\n \n   /* Process all blocks reachable from all entry points.  */\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-    inserted |= convert_regs_2 (file, e->dest);\n+    convert_regs_2 (file, e->dest);\n \n   /* ??? Process all unreachable blocks.  Though there's no excuse\n      for keeping these even when not optimizing.  */\n@@ -2993,8 +3011,11 @@ convert_regs (FILE *file)\n       block_info bi = BLOCK_INFO (b);\n \n       if (! bi->done)\n-\tinserted |= convert_regs_2 (file, b);\n+\tconvert_regs_2 (file, b);\n     }\n+\n+  inserted |= compensate_edges (file);\n+\n   clear_aux_for_blocks ();\n \n   fixup_abnormal_edges ();\n@@ -3046,7 +3067,7 @@ reg_to_stack (FILE *file)\n \n   /* Set up block info for each basic block.  */\n   alloc_aux_for_blocks (sizeof (struct block_info_def));\n-  FOR_EACH_BB_REVERSE (bb)\n+  FOR_EACH_BB (bb)\n     {\n       block_info bi = BLOCK_INFO (bb);\n       edge_iterator ei;"}]}