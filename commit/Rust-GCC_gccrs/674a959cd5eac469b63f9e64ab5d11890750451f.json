{"sha": "674a959cd5eac469b63f9e64ab5d11890750451f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc0YTk1OWNkNWVhYzQ2OWI2M2Y5ZTY0YWI1ZDExODkwNzUwNDUxZg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2016-03-01T09:25:23Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-03-01T09:25:23Z"}, "message": "S/390: Get rid of Y constraint in vector.md.\n\nThis finally removes the Y constraint from the vector patterns while\nfolding some of them using a code iterator.\n\ngcc/ChangeLog:\n\n2016-03-01  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/subst.md (DSI_VI): New mode iterator.\n\t(\"addr_style_op_subst\"): Use DSI_VI instead of DSI.\n\t* config/s390/vector.md (\"vec_set<mode>\"): Move expander before\n\tthe insn definition.\n\t(\"*vec_set<mode>\"): Change predicate and add alternative to\n\tsupport only either register or const_int operands as element\n\tselector.\n\t(\"*vec_set<mode>_plus\"): New pattern to support reg + const_int\n\toperands.\n\t(\"vec_extract<mode>\"): New expander.\n\t(\"*vec_extract<mode>\"): New insn definition supporting reg and\n\tconst_int element selectors.\n\t(\"*vec_extract<mode>_plus\"): New insn definition supporting\n\treg+const_int element selectors.\n\t(\"rotl<mode>3\", \"ashl<mode>3\", \"ashr<mode>3\"): Merge into the\n\tfollowing expander+insn definition.\n\t(\"<vec_shifts_name><mode>3\"): New expander.\n\t(\"*<vec_shifts_name><mode>3<addr_style_op>\"): New insn definition.\n\nFrom-SVN: r233847", "tree": {"sha": "613e9ea3bc2d6b2af78ce58229a8e86f7ba11890", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/613e9ea3bc2d6b2af78ce58229a8e86f7ba11890"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/674a959cd5eac469b63f9e64ab5d11890750451f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/674a959cd5eac469b63f9e64ab5d11890750451f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/674a959cd5eac469b63f9e64ab5d11890750451f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/674a959cd5eac469b63f9e64ab5d11890750451f/comments", "author": null, "committer": null, "parents": [{"sha": "eae48192e4c70b47a2066650a56b12c9198b9b47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eae48192e4c70b47a2066650a56b12c9198b9b47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eae48192e4c70b47a2066650a56b12c9198b9b47"}], "stats": {"total": 159, "additions": 100, "deletions": 59}, "files": [{"sha": "79756c8a185d5e02cebbbd335722d007938455dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674a959cd5eac469b63f9e64ab5d11890750451f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674a959cd5eac469b63f9e64ab5d11890750451f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=674a959cd5eac469b63f9e64ab5d11890750451f", "patch": "@@ -1,3 +1,24 @@\n+2016-03-01  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/subst.md (DSI_VI): New mode iterator.\n+\t(\"addr_style_op_subst\"): Use DSI_VI instead of DSI.\n+\t* config/s390/vector.md (\"vec_set<mode>\"): Move expander before\n+\tthe insn definition.\n+\t(\"*vec_set<mode>\"): Change predicate and add alternative to\n+\tsupport only either register or const_int operands as element\n+\tselector.\n+\t(\"*vec_set<mode>_plus\"): New pattern to support reg + const_int\n+\toperands.\n+\t(\"vec_extract<mode>\"): New expander.\n+\t(\"*vec_extract<mode>\"): New insn definition supporting reg and\n+\tconst_int element selectors.\n+\t(\"*vec_extract<mode>_plus\"): New insn definition supporting\n+\treg+const_int element selectors.\n+\t(\"rotl<mode>3\", \"ashl<mode>3\", \"ashr<mode>3\"): Merge into the\n+\tfollowing expander+insn definition.\n+\t(\"<vec_shifts_name><mode>3\"): New expander.\n+\t(\"*<vec_shifts_name><mode>3<addr_style_op>\"): New insn definition.\n+\n 2016-03-01  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/s390.md (\"*tabort_1\"): Change predicate to"}, {"sha": "8a1b8145fd00717dca0f71b829d72d7f95aec1a6", "filename": "gcc/config/s390/subst.md", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674a959cd5eac469b63f9e64ab5d11890750451f/gcc%2Fconfig%2Fs390%2Fsubst.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674a959cd5eac469b63f9e64ab5d11890750451f/gcc%2Fconfig%2Fs390%2Fsubst.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fsubst.md?ref=674a959cd5eac469b63f9e64ab5d11890750451f", "patch": "@@ -20,19 +20,20 @@\n ;; <http://www.gnu.org/licenses/>.\n \n (define_code_iterator SUBST [rotate ashift lshiftrt ashiftrt])\n+(define_mode_iterator DSI_VI [SI DI V2QI V4QI V8QI V16QI V2HI V4HI V8HI V2SI V4SI V2DI])\n \n ; This expands an register/immediate operand to a register+immediate\n ; operand to draw advantage of the address style operand format\n ; providing a addition for free.\n (define_subst \"addr_style_op_subst\"\n-  [(set (match_operand:DSI 0 \"\" \"\")\n-        (SUBST:DSI (match_operand:DSI 1 \"\" \"\")\n-\t\t   (match_operand:SI 2 \"\" \"\")))]\n+  [(set (match_operand:DSI_VI 0 \"\" \"\")\n+        (SUBST:DSI_VI (match_operand:DSI_VI 1 \"\" \"\")\n+\t\t      (match_operand:SI 2 \"\" \"\")))]\n   \"\"\n   [(set (match_dup 0)\n-        (SUBST:DSI (match_dup 1)\n-\t\t   (plus:SI (match_operand:SI 2 \"register_operand\" \"a\")\n-\t\t\t    (match_operand 3 \"const_int_operand\"   \"n\"))))])\n+        (SUBST:DSI_VI (match_dup 1)\n+\t\t      (plus:SI (match_operand:SI 2 \"register_operand\" \"a\")\n+\t\t\t       (match_operand 3 \"const_int_operand\"   \"n\"))))])\n \n ; Use this in the insn name.\n (define_subst_attr \"addr_style_op\"     \"addr_style_op_subst\" \"\" \"_plus\")"}, {"sha": "5b3cdafe3d69ceec9bfc491e399f08c95ec8121e", "filename": "gcc/config/s390/vector.md", "status": "modified", "additions": 72, "deletions": 53, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674a959cd5eac469b63f9e64ab5d11890750451f/gcc%2Fconfig%2Fs390%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674a959cd5eac469b63f9e64ab5d11890750451f/gcc%2Fconfig%2Fs390%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvector.md?ref=674a959cd5eac469b63f9e64ab5d11890750451f", "patch": "@@ -307,47 +307,80 @@\n \n ; vec_store_lanes?\n \n+; vec_set is supposed to *modify* an existing vector so operand 0 is\n+; duplicated as input operand.\n+(define_expand \"vec_set<mode>\"\n+  [(set (match_operand:V                    0 \"register_operand\"  \"\")\n+\t(unspec:V [(match_operand:<non_vec> 1 \"general_operand\"   \"\")\n+\t\t   (match_operand:SI        2 \"nonmemory_operand\" \"\")\n+\t\t   (match_dup 0)]\n+\t\t   UNSPEC_VEC_SET))]\n+  \"TARGET_VX\")\n+\n ; FIXME: Support also vector mode operands for 1\n ; FIXME: A target memory operand seems to be useful otherwise we end\n ; up with vl vlvgg vst.  Shouldn't the middle-end be able to handle\n ; that itself?\n (define_insn \"*vec_set<mode>\"\n-  [(set (match_operand:V                    0 \"register_operand\"             \"=v, v,v\")\n-\t(unspec:V [(match_operand:<non_vec> 1 \"general_operand\"               \"d,QR,K\")\n-\t\t   (match_operand:SI        2 \"shift_count_or_setmem_operand\" \"Y, I,I\")\n-\t\t   (match_operand:V         3 \"register_operand\"              \"0, 0,0\")]\n+  [(set (match_operand:V                    0 \"register_operand\"  \"=v, v,v\")\n+\t(unspec:V [(match_operand:<non_vec> 1 \"general_operand\"    \"d,QR,K\")\n+\t\t   (match_operand:SI        2 \"nonmemory_operand\" \"an, I,I\")\n+\t\t   (match_operand:V         3 \"register_operand\"   \"0, 0,0\")]\n \t\t  UNSPEC_VEC_SET))]\n-  \"TARGET_VX\"\n+  \"TARGET_VX\n+   && (!CONST_INT_P (operands[2])\n+       || UINTVAL (operands[2]) < GET_MODE_NUNITS (<V:MODE>mode))\"\n   \"@\n    vlvg<bhfgq>\\t%v0,%1,%Y2\n    vle<bhfgq>\\t%v0,%1,%2\n    vlei<bhfgq>\\t%v0,%1,%2\"\n   [(set_attr \"op_type\" \"VRS,VRX,VRI\")])\n \n-; vec_set is supposed to *modify* an existing vector so operand 0 is\n-; duplicated as input operand.\n-(define_expand \"vec_set<mode>\"\n-  [(set (match_operand:V                    0 \"register_operand\"              \"\")\n-\t(unspec:V [(match_operand:<non_vec> 1 \"general_operand\"               \"\")\n-\t\t   (match_operand:SI        2 \"shift_count_or_setmem_operand\" \"\")\n-\t\t   (match_dup 0)]\n-\t\t   UNSPEC_VEC_SET))]\n-  \"TARGET_VX\")\n+(define_insn \"*vec_set<mode>_plus\"\n+  [(set (match_operand:V                      0 \"register_operand\" \"=v\")\n+\t(unspec:V [(match_operand:<non_vec>   1 \"general_operand\"   \"d\")\n+\t\t   (plus:SI (match_operand:SI 2 \"register_operand\"  \"a\")\n+\t\t\t    (match_operand:SI 4 \"const_int_operand\" \"n\"))\n+\t\t   (match_operand:V           3 \"register_operand\"  \"0\")]\n+\t\t  UNSPEC_VEC_SET))]\n+  \"TARGET_VX\"\n+  \"vlvg<bhfgq>\\t%v0,%1,%Y4(%2)\"\n+  [(set_attr \"op_type\" \"VRS\")])\n+\n \n ; FIXME: Support also vector mode operands for 0\n ; FIXME: This should be (vec_select ..) or something but it does only allow constant selectors :(\n ; This is used via RTL standard name as well as for expanding the builtin\n-(define_insn \"vec_extract<mode>\"\n-  [(set (match_operand:<non_vec> 0 \"nonimmediate_operand\"                        \"=d,QR\")\n-\t(unspec:<non_vec> [(match_operand:V  1 \"register_operand\"                \" v, v\")\n-\t\t\t   (match_operand:SI 2 \"shift_count_or_setmem_operand\"   \" Y, I\")]\n+(define_expand \"vec_extract<mode>\"\n+  [(set (match_operand:<non_vec> 0 \"nonimmediate_operand\" \"\")\n+\t(unspec:<non_vec> [(match_operand:V  1 \"register_operand\" \"\")\n+\t\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"\")]\n \t\t\t  UNSPEC_VEC_EXTRACT))]\n-  \"TARGET_VX\"\n+  \"TARGET_VX\")\n+\n+(define_insn \"*vec_extract<mode>\"\n+  [(set (match_operand:<non_vec> 0 \"nonimmediate_operand\"          \"=d,QR\")\n+\t(unspec:<non_vec> [(match_operand:V  1 \"register_operand\"   \"v, v\")\n+\t\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"an, I\")]\n+\t\t\t  UNSPEC_VEC_EXTRACT))]\n+  \"TARGET_VX\n+   && (!CONST_INT_P (operands[2])\n+       || UINTVAL (operands[2]) < GET_MODE_NUNITS (<V:MODE>mode))\"\n   \"@\n    vlgv<bhfgq>\\t%0,%v1,%Y2\n    vste<bhfgq>\\t%v1,%0,%2\"\n   [(set_attr \"op_type\" \"VRS,VRX\")])\n \n+(define_insn \"*vec_extract<mode>_plus\"\n+  [(set (match_operand:<non_vec>                      0 \"nonimmediate_operand\" \"=d\")\n+\t(unspec:<non_vec> [(match_operand:V           1 \"register_operand\"      \"v\")\n+\t\t\t   (plus:SI (match_operand:SI 2 \"nonmemory_operand\"     \"a\")\n+\t\t\t\t    (match_operand:SI 3 \"const_int_operand\"     \"n\"))]\n+\t\t\t   UNSPEC_VEC_EXTRACT))]\n+  \"TARGET_VX\"\n+  \"vlgv<bhfgq>\\t%0,%v1,%Y3(%2)\"\n+  [(set_attr \"op_type\" \"VRS\")])\n+\n (define_expand \"vec_init<V_HW:mode>\"\n   [(match_operand:V_HW 0 \"register_operand\" \"\")\n    (match_operand:V_HW 1 \"nonmemory_operand\" \"\")]\n@@ -667,17 +700,6 @@\n   [(set_attr \"op_type\" \"VRR\")])\n \n \n-; Vector rotate instructions\n-\n-; Each vector element rotated by a scalar\n-; verllb, verllh, verllf, verllg\n-(define_insn \"rotl<mode>3\"\n-  [(set (match_operand:VI            0 \"register_operand\"             \"=v\")\n-\t(rotate:VI (match_operand:VI 1 \"register_operand\"              \"v\")\n-\t\t   (match_operand:SI 2 \"shift_count_or_setmem_operand\" \"Y\")))]\n-  \"TARGET_VX\"\n-  \"verll<bhfgq>\\t%v0,%v1,%Y2\"\n-  [(set_attr \"op_type\" \"VRS\")])\n \n ; Each vector element rotated by the corresponding vector element\n ; verllvb, verllvh, verllvf, verllvg\n@@ -690,36 +712,33 @@\n   [(set_attr \"op_type\" \"VRR\")])\n \n \n-; Shift each element by scalar value\n+; Vector rotate and shift by scalar instructions\n \n-; veslb, veslh, veslf, veslg\n-(define_insn \"ashl<mode>3\"\n-  [(set (match_operand:VI            0 \"register_operand\"             \"=v\")\n-\t(ashift:VI (match_operand:VI 1 \"register_operand\"              \"v\")\n-\t\t   (match_operand:SI 2 \"shift_count_or_setmem_operand\" \"Y\")))]\n-  \"TARGET_VX\"\n-  \"vesl<bhfgq>\\t%v0,%v1,%Y2\"\n-  [(set_attr \"op_type\" \"VRS\")])\n+(define_code_iterator VEC_SHIFTS [ashift ashiftrt lshiftrt rotate])\n+(define_code_attr vec_shifts_name [(ashift \"ashl\")    (ashiftrt \"ashr\")\n+\t\t\t\t   (lshiftrt \"lshr\")  (rotate \"rotl\")])\n+(define_code_attr vec_shifts_mnem [(ashift \"vesl\")    (ashiftrt \"vesra\")\n+\t\t\t\t   (lshiftrt \"vesrl\") (rotate \"verll\")])\n \n-; vesrab, vesrah, vesraf, vesrag\n-(define_insn \"ashr<mode>3\"\n-  [(set (match_operand:VI              0 \"register_operand\"             \"=v\")\n-\t(ashiftrt:VI (match_operand:VI 1 \"register_operand\"              \"v\")\n-\t\t     (match_operand:SI 2 \"shift_count_or_setmem_operand\" \"Y\")))]\n-  \"TARGET_VX\"\n-  \"vesra<bhfgq>\\t%v0,%v1,%Y2\"\n-  [(set_attr \"op_type\" \"VRS\")])\n+; Each vector element rotated by a scalar\n+(define_expand \"<vec_shifts_name><mode>3\"\n+  [(set (match_operand:VI 0 \"register_operand\" \"\")\n+\t(VEC_SHIFTS:VI (match_operand:VI 1 \"register_operand\" \"\")\n+\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"TARGET_VX\")\n \n+; verllb, verllh, verllf, verllg\n+; veslb,  veslh,  veslf,  veslg\n+; vesrab, vesrah, vesraf, vesrag\n ; vesrlb, vesrlh, vesrlf, vesrlg\n-(define_insn \"lshr<mode>3\"\n-  [(set (match_operand:VI              0 \"register_operand\"             \"=v\")\n-\t(lshiftrt:VI (match_operand:VI 1 \"register_operand\"              \"v\")\n-\t\t     (match_operand:SI 2 \"shift_count_or_setmem_operand\" \"Y\")))]\n+(define_insn \"*<vec_shifts_name><mode>3<addr_style_op>\"\n+  [(set (match_operand:VI                0 \"register_operand\"  \"=v\")\n+\t(VEC_SHIFTS:VI (match_operand:VI 1 \"register_operand\"   \"v\")\n+\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"an\")))]\n   \"TARGET_VX\"\n-  \"vesrl<bhfgq>\\t%v0,%v1,%Y2\"\n+  \"<vec_shifts_mnem><bhfgq>\\t%v0,%v1,%Y2\"\n   [(set_attr \"op_type\" \"VRS\")])\n \n-\n ; Shift each element by corresponding vector element\n \n ; veslvb, veslvh, veslvf, veslvg"}]}