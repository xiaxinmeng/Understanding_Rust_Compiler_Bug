{"sha": "6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNkZDU2NzI0YWZmM2FkYzRiZWYxYjU0NDE1MjZkODRkZGI2ZDJjYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-09-08T18:45:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-09-08T18:45:21Z"}, "message": "function.c (reference_callee_copied): New.\n\n        * function.c (reference_callee_copied): New.\n        (assign_parm_setup_reg): Use it.\n        * calls.c (initialize_argument_information): Likewise.\n        (emit_library_call_value_1): Likewise.\n        * function.h (reference_callee_copied): Declare.\n\n        * target.h (struct gcc_target): Add callee_copies.\n        * target-def.h (TARGET_CALLEE_COPIES): New.\n        (TARGET_PASS_BY_REFERENCE): Update default.\n        * expr.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n        * targhooks.c (hook_callee_copies_named): New.\n        (hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false): Rename from\n        hook_pass_by_reference_false.\n        (hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true): New.\n        * targhooks.h: Update decls.\n        * config/arc/arc.c (TARGET_CALLEE_COPIES): New.\n        * config/arc/arc.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n        * config/frv/frv-protos.h (frv_function_arg_callee_copies): Remove.\n        * config/frv/frv.c (frv_function_arg_callee_copies): Remove.\n        * config/frv/frv.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n        * config/iq2000/iq2000.c (TARGET_CALLEE_COPIES): New.\n        * config/iq2000/iq2000.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n        * config/m68hc11/m68hc11.c (TARGET_CALLEE_COPIES): New.\n        * config/m68hc11/m68hc11.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n        * config/mips/mips.c (TARGET_CALLEE_COPIES): New.\n        (mips_callee_copies): New.\n        * config/mips/mips.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n        * config/mmix/mmix.c (TARGET_CALLEE_COPIES): New.\n        * config/mmix/mmix.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n        * config/mn10300/mn10300.c (TARGET_CALLEE_COPIES): New.\n        * config/mn10300/mn10300.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n        * config/pa/pa.c (TARGET_CALLEE_COPIES): New.\n        * config/pa/pa.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n        * config/sh/sh.c (sh_callee_copies): New.\n        (TARGET_CALLEE_COPIES): New.\n        * config/sh/sh.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n        * config/v850/v850.c (TARGET_CALLEE_COPIES): New.\n        * config/v850/v850.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n        * doc/tm.texi (TARGET_CALLEE_COPIES): Replace documentation\n        for FUNCTION_ARG_CALLEE_COPIES.\n        * doc/rtl.texi (CALL_INSN_FUNCTION_USAGE): Update.\n\nFrom-SVN: r87195", "tree": {"sha": "e2b5ae247504eef2927039baf6729090ed6d7ff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2b5ae247504eef2927039baf6729090ed6d7ff8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/comments", "author": null, "committer": null, "parents": [{"sha": "7f7e0703105e0ba185eb29beba29e55964b48f55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f7e0703105e0ba185eb29beba29e55964b48f55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f7e0703105e0ba185eb29beba29e55964b48f55"}], "stats": {"total": 296, "additions": 176, "deletions": 120}, "files": [{"sha": "c58585af6e9028d766d0a86b19155e92751249d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -1,8 +1,53 @@\n+2004-09-08  Richard Henderson  <rth@redhat.com>\n+\n+\t* function.c (reference_callee_copied): New.\n+\t(assign_parm_setup_reg): Use it.\n+\t* calls.c (initialize_argument_information): Likewise.\n+\t(emit_library_call_value_1): Likewise.\n+\t* function.h (reference_callee_copied): Declare.\n+\n+\t* target.h (struct gcc_target): Add callee_copies.\n+\t* target-def.h (TARGET_CALLEE_COPIES): New.\n+\t(TARGET_PASS_BY_REFERENCE): Update default.\n+\t* expr.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n+\t* targhooks.c (hook_callee_copies_named): New.\n+\t(hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false): Rename from\n+\thook_pass_by_reference_false.\n+\t(hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true): New.\n+\t* targhooks.h: Update decls.\n+\t* config/arc/arc.c (TARGET_CALLEE_COPIES): New.\n+\t* config/arc/arc.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n+\t* config/frv/frv-protos.h (frv_function_arg_callee_copies): Remove.\n+\t* config/frv/frv.c (frv_function_arg_callee_copies): Remove.\n+\t* config/frv/frv.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n+\t* config/iq2000/iq2000.c (TARGET_CALLEE_COPIES): New.\n+\t* config/iq2000/iq2000.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n+\t* config/m68hc11/m68hc11.c (TARGET_CALLEE_COPIES): New.\n+\t* config/m68hc11/m68hc11.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n+\t* config/mips/mips.c (TARGET_CALLEE_COPIES): New.\n+\t(mips_callee_copies): New.\n+\t* config/mips/mips.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n+\t* config/mmix/mmix.c (TARGET_CALLEE_COPIES): New.\n+\t* config/mmix/mmix.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n+\t* config/mn10300/mn10300.c (TARGET_CALLEE_COPIES): New.\n+\t* config/mn10300/mn10300.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n+\t* config/pa/pa.c (TARGET_CALLEE_COPIES): New.\n+\t* config/pa/pa.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n+\t* config/sh/sh.c (sh_callee_copies): New.\n+\t(TARGET_CALLEE_COPIES): New.\n+\t* config/sh/sh.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n+\t* config/v850/v850.c (TARGET_CALLEE_COPIES): New.\n+\t* config/v850/v850.h (FUNCTION_ARG_CALLEE_COPIES): Remove.\n+\t* doc/tm.texi (TARGET_CALLEE_COPIES): Replace documentation\n+\tfor FUNCTION_ARG_CALLEE_COPIES.\n+\t* doc/rtl.texi (CALL_INSN_FUNCTION_USAGE): Update.\n+\n 2004-09-08  Devang Patel  <dpatel@apple.com>\n \n-\t* tree-if-conv.c (find_phi_replacement_condition): Return true edge block.\n-\t(replace_phi_with_cond_modify_expr): Select conditional expr args based on\n-\ttrue edge basic block.\n+\t* tree-if-conv.c (find_phi_replacement_condition): Return true\n+\tedge block.\n+\t(replace_phi_with_cond_modify_expr): Select conditional expr args\n+\tbased on true edge basic block.\n \t\n 2004-09-08  Jan Hubicka  <jh@suse.cz>\n "}, {"sha": "09c24d7c27b2cb2930f1f4392cccc9aa1439136f", "filename": "gcc/calls.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -974,8 +974,8 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t  tree base;\n \n \t  callee_copies\n-\t    = FUNCTION_ARG_CALLEE_COPIES (*args_so_far, TYPE_MODE (type),\n-\t\t\t\t\t  type, argpos < n_named_args);\n+\t    = reference_callee_copied (args_so_far, TYPE_MODE (type),\n+\t\t\t\t       type, argpos < n_named_args);\n \n \t  /* If we're compiling a thunk, pass through invisible references\n \t     instead of making a copy.  */\n@@ -3333,8 +3333,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       if (pass_by_reference (&args_so_far, mode, NULL_TREE, 1))\n \t{\n \t  rtx slot;\n-\t  int must_copy = ! FUNCTION_ARG_CALLEE_COPIES (args_so_far, mode,\n-\t\t\t\t\t\t\tNULL_TREE, 1);\n+\t  int must_copy\n+\t    = !reference_callee_copied (&args_so_far, mode, NULL_TREE, 1);\n \n \t  /* loop.c won't look at CALL_INSN_FUNCTION_USAGE of const/pure\n \t     functions, so we have to pretend this isn't such a function.  */"}, {"sha": "90419f9fefd465f7488c202c4551cf8539c4d6b1", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -142,6 +142,8 @@ static bool arc_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n #define TARGET_RETURN_IN_MEMORY arc_return_in_memory\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE arc_pass_by_reference\n+#undef TARGET_CALLEE_COPIES\n+#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n \n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS arc_setup_incoming_varargs\n@@ -2356,4 +2358,3 @@ arc_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n \n   return size > 8;\n }\n-"}, {"sha": "6b94cd1e3a335b65e87620d2f5137160e79d9aab", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -696,15 +696,6 @@ extern enum reg_class arc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    registers.  */\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n-/* A C expression that indicates when it is the called function's\n-   responsibility to make copies of arguments passed by reference.\n-   If the callee can determine that the argument won't be modified, it can\n-   avoid the copy.  */\n-/* ??? We'd love to be able to use NAMED here.  Unfortunately, it doesn't\n-   include the last named argument so we keep track of the args ourselves.  */\n-\n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 1\n-\n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */"}, {"sha": "611e8d6262f2e5444254038e33f7714336836702", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -84,10 +84,6 @@ extern int frv_function_arg_partial_nregs\t(CUMULATIVE_ARGS *,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t tree, int);\n \n-extern int frv_function_arg_callee_copies\t(CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t tree, int);\n-\n extern void frv_expand_builtin_va_start\t\t(tree, rtx);\n #endif /* TREE_CODE */\n "}, {"sha": "58d86a9b2536990d972ccdf8f973a78ff0896182", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -3143,25 +3143,6 @@ frv_function_arg_partial_nregs (CUMULATIVE_ARGS *cum,\n \n }\n \n-\f\n-/* If defined, a C expression that indicates when it is the called function's\n-   responsibility to make a copy of arguments passed by invisible reference.\n-   Normally, the caller makes a copy and passes the address of the copy to the\n-   routine being called.  When FUNCTION_ARG_CALLEE_COPIES is defined and is\n-   nonzero, the caller does not make a copy.  Instead, it passes a pointer to\n-   the \"live\" value.  The called function must not modify this value.  If it\n-   can be determined that the value won't be modified, it need not make a copy;\n-   otherwise a copy must be made.  */\n-\n-int\n-frv_function_arg_callee_copies (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n-                                enum machine_mode mode ATTRIBUTE_UNUSED,\n-                                tree type ATTRIBUTE_UNUSED,\n-                                int named ATTRIBUTE_UNUSED)\n-{\n-  return 0;\n-}\n-\n \f\n /* Return true if a register is ok to use as a base or index register.  */\n "}, {"sha": "84e59cfa3a5d256f3dd4a563b2d8bb5d19cdf2ce", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -1903,17 +1903,6 @@ struct machine_function GTY(())\n \n /* extern int frv_function_arg_partial_nregs (CUMULATIVE_ARGS, int, Tree, int);  */\n \n-/* If defined, a C expression that indicates when it is the called function's\n-   responsibility to make a copy of arguments passed by invisible reference.\n-   Normally, the caller makes a copy and passes the address of the copy to the\n-   routine being called.  When FUNCTION_ARG_CALLEE_COPIES is defined and is\n-   nonzero, the caller does not make a copy.  Instead, it passes a pointer to\n-   the \"live\" value.  The called function must not modify this value.  If it\n-   can be determined that the value won't be modified, it need not make a copy;\n-   otherwise a copy must be made.  */\n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)\t\t\\\n-  frv_function_arg_callee_copies (&CUM, MODE, TYPE, NAMED)\n-\n /* A C type for declaring a variable that is used as the first argument of\n    `FUNCTION_ARG' and other related values.  For some target machines, the type\n    `int' suffices and can hold the number of bytes of argument so far."}, {"sha": "3f39ec557b7663de836c326e17c5dedce048a935", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -199,6 +199,8 @@ static bool iq2000_pass_by_reference  (CUMULATIVE_ARGS *, enum machine_mode,\n #define TARGET_RETURN_IN_MEMORY\t\tiq2000_return_in_memory\n #undef  TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE\tiq2000_pass_by_reference\n+#undef  TARGET_CALLEE_COPIES\n+#define TARGET_CALLEE_COPIES\t\thook_callee_copies_named\n \n #undef  TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS\tiq2000_setup_incoming_varargs"}, {"sha": "09cca0f1658b6975493d7e8ca147845f866a4e31", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -441,8 +441,6 @@ enum reg_class\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n   function_arg_partial_nregs (& CUM, MODE, TYPE, NAMED)\n \n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) (NAMED)\n-\n #define MAX_ARGS_IN_REGISTERS 8\n \n typedef struct iq2000_args"}, {"sha": "4d47a6275cf6c2edeb1ccdb78d1dadd55d7269eb", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -272,6 +272,8 @@ static int nb_soft_regs;\n #define TARGET_STRUCT_VALUE_RTX m68hc11_struct_value_rtx\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY m68hc11_return_in_memory\n+#undef TARGET_CALLEE_COPIES\n+#define TARGET_CALLEE_COPIES hook_callee_copies_named\n \n #undef TARGET_STRIP_NAME_ENCODING\n #define TARGET_STRIP_NAME_ENCODING m68hc11_strip_name_encoding"}, {"sha": "497c53574d25ddbd224071666fe3f839470f76d8", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -1049,17 +1049,6 @@ typedef struct m68hc11_args\n #define PAD_VARARGS_DOWN \\\n   (m68hc11_function_arg_padding (TYPE_MODE (type), type) == downward)\n \n-/* A C expression that indicates when it is the called function's\n-   responsibility to make a copy of arguments passed by invisible\n-   reference.  Normally, the caller makes a copy and passes the\n-   address of the copy to the routine being called.  When\n-   FUNCTION_ARG_CALLEE_COPIES is defined and is nonzero, the caller\n-   does not make a copy.  Instead, it passes a pointer to the \"live\"\n-   value.  The called function must not modify this value.  If it can\n-   be determined that the value won't be modified, it need not make a\n-   copy; otherwise a copy must be made.  */\n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) (NAMED)\n-\n /* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to a\n    function whose data type is FNTYPE. For a library call, FNTYPE is 0.  */\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\"}, {"sha": "b3be4bb418b6ed758ee5bfd1b08e00ba0fe84987", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -349,6 +349,8 @@ static tree mips_build_builtin_va_list (void);\n static tree mips_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n static bool mips_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode mode,\n \t\t\t\t    tree, bool);\n+static bool mips_callee_copies (CUMULATIVE_ARGS *, enum machine_mode mode,\n+\t\t\t\ttree, bool);\n static bool mips_vector_mode_supported_p (enum machine_mode);\n static rtx mips_prepare_builtin_arg (enum insn_code, unsigned int, tree *);\n static rtx mips_prepare_builtin_target (enum insn_code, unsigned int, rtx);\n@@ -785,6 +787,8 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE mips_pass_by_reference\n+#undef TARGET_CALLEE_COPIES\n+#define TARGET_CALLEE_COPIES mips_callee_copies\n \n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P mips_vector_mode_supported_p\n@@ -6808,6 +6812,14 @@ mips_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n     }\n }\n \n+static bool\n+mips_callee_copies (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t    tree type ATTRIBUTE_UNUSED, bool named)\n+{\n+  return mips_abi == ABI_EABI && named;\n+}\n+\n /* Return the class of registers for which a mode change from FROM to TO\n    is invalid.\n "}, {"sha": "3428ac9a4fee457e355038042d9f929709632f34", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -2302,9 +2302,6 @@ typedef struct mips_args {\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST)\t\t\\\n   (mips_pad_reg_upward (MODE, TYPE) ? upward : downward)\n \n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)\t\t\\\n-  (mips_abi == ABI_EABI && (NAMED))\n-\n /* True if using EABI and varargs can be passed in floating-point\n    registers.  Under these conditions, we need a more complex form\n    of va_list, which tracks GPR, FPR and stack arguments separately.  */"}, {"sha": "c08fa92e1d71b0b94f1362c8e057e7ffc2dfbce3", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -206,6 +206,8 @@ static bool mmix_pass_by_reference (const CUMULATIVE_ARGS *,\n #define TARGET_SETUP_INCOMING_VARARGS mmix_setup_incoming_varargs\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE mmix_pass_by_reference\n+#undef TARGET_CALLEE_COPIES\n+#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "143c8de462e64b30604a50f60c5c8b716de98464", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -720,8 +720,6 @@ enum reg_class\n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\\\n  mmix_function_arg (&(CUM), MODE, TYPE, NAMED, 1)\n \n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 1\n-\n typedef struct { int regs; int lib; } CUMULATIVE_ARGS;\n \n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\"}, {"sha": "b0af9d91d27e60477646947be7ca76f8dd704d40", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -97,6 +97,8 @@ static bool mn10300_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n #define TARGET_RETURN_IN_MEMORY mn10300_return_in_memory\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE mn10300_pass_by_reference\n+#undef TARGET_CALLEE_COPIES\n+#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS mn10300_builtin_saveregs"}, {"sha": "df1a4b114448f5db6850fe3af2dc087e72692f4b", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -610,8 +610,6 @@ struct cum_arg {int nbytes; };\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n   function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n-\f\n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 1\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree)."}, {"sha": "7c875817b40a17f223df3aec69c1e85bffecb7f6", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -280,6 +280,8 @@ static size_t n_deferred_plabels = 0;\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE pa_pass_by_reference\n+#undef TARGET_CALLEE_COPIES\n+#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS hppa_builtin_saveregs"}, {"sha": "7e4e1fd9fcf68f73a95219ffaf592830e3165d7a", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -949,8 +949,6 @@ struct hppa_args {int words, nargs_prototype, incoming, indirect; };\n     : GET_MODE_SIZE(MODE) <= UNITS_PER_WORD)\t\t\t\t\\\n    ? PARM_BOUNDARY : MAX_PARM_BOUNDARY)\n \n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 1\n-\n \f\n extern GTY(()) rtx hppa_compare_op0;\n extern GTY(()) rtx hppa_compare_op1;"}, {"sha": "b58293d8a35bf89c41225a144af73b5ffc130741", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -283,6 +283,8 @@ static tree sh_build_builtin_va_list (void);\n static tree sh_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n static bool sh_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, bool);\n+static bool sh_callee_copies (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t      tree, bool);\n \n \f\n /* Initialize the GCC target structure.  */\n@@ -438,6 +440,8 @@ static bool sh_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE sh_pass_by_reference\n+#undef TARGET_CALLEE_COPIES\n+#define TARGET_CALLEE_COPIES sh_callee_copies\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST sh_build_builtin_va_list\n@@ -6609,6 +6613,18 @@ sh_pass_by_reference (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   return false;\n }\n \n+static bool\n+sh_callee_copies (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t  tree type, bool named ATTRIBUTE_UNUSED)\n+{\n+  /* ??? How can it possibly be correct to return true only on the\n+     caller side of the equation?  Is there someplace else in the\n+     sh backend that's magically producing the copies?  */\n+  return (cum->outgoing\n+\t  && ((mode == BLKmode ? TYPE_ALIGN (type) : GET_MODE_ALIGNMENT (mode))\n+\t      % SH_MIN_ALIGN_FOR_CALLEE_COPY == 0));\n+}\n+\n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument."}, {"sha": "61fd9ca6f37f4b3efe816102bfe090b5437aed42", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -2197,12 +2197,6 @@ struct sh_args {\n    boundaries, because they'll be loaded using quad loads.  */\n #define SH_MIN_ALIGN_FOR_CALLEE_COPY (8 * BITS_PER_UNIT)\n \n-#define FUNCTION_ARG_CALLEE_COPIES(CUM,MODE,TYPE,NAMED) \\\n-  ((CUM).outgoing\t\t\t\t\t\t\t\\\n-   && (((MODE) == BLKmode ? TYPE_ALIGN (TYPE)\t\t\t\t\\\n-\t: GET_MODE_ALIGNMENT (MODE))\t\t\t\t\t\\\n-       % SH_MIN_ALIGN_FOR_CALLEE_COPY == 0))\n-\n /* The SH5 ABI requires floating-point arguments to be passed to\n    functions without a prototype in both an FP register and a regular\n    register or the stack.  When passing the argument in both FP and"}, {"sha": "98c24c94ffed23516b7bca97ab2984d71a22e9f3", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -131,6 +131,9 @@ static int v850_interrupt_p = FALSE;\n #undef TARGET_PASS_BY_REFERENCE\n #define TARGET_PASS_BY_REFERENCE v850_pass_by_reference\n \n+#undef TARGET_CALLEE_COPIES\n+#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n+\n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS v850_setup_incoming_varargs\n "}, {"sha": "fe3a659c963a6f89aa9d8ba027e447a9c0058bc7", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -773,8 +773,6 @@ struct cum_arg { int nbytes; int anonymous_args; };\n    space allocated by the caller.  */\n #define OUTGOING_REG_PARM_STACK_SPACE\n \n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 1\n-\n /* 1 if N is a possible register number for function argument passing.  */\n \n #define FUNCTION_ARG_REGNO_P(N) (N >= 6 && N <= 9)"}, {"sha": "113dc147e79d03748fc988cfeaa7573243f46947", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -2959,8 +2959,8 @@ clobbered by the called function.\n \n A @code{MEM} generally points to a stack slots in which arguments passed\n to the libcall by reference (@pxref{Register Arguments,\n-FUNCTION_ARG_PASS_BY_REFERENCE}) are stored.  If the argument is\n-caller-copied (@pxref{Register Arguments, FUNCTION_ARG_CALLEE_COPIES}),\n+TARGET_PASS_BY_REFERENCE}) are stored.  If the argument is\n+caller-copied (@pxref{Register Arguments, TARGET_CALLEE_COPIES}),\n the stack slot will be mentioned in @code{CLOBBER} and @code{USE}\n entries; if it's callee-copied, only a @code{USE} will appear, and the\n @code{MEM} may point to addresses that are not stack slots.  These"}, {"sha": "0734b2cebc57fd8772305766fd63fbd7450f0b4c", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -3733,16 +3733,18 @@ The pointer is passed in whatever way is appropriate for passing a pointer\n to that type.\n @end deftypefn\n \n-@defmac FUNCTION_ARG_CALLEE_COPIES (@var{cum}, @var{mode}, @var{type}, @var{named})\n-If defined, a C expression that indicates when it is the called function's\n-responsibility to make a copy of arguments passed by invisible reference.\n-Normally, the caller makes a copy and passes the address of the copy to the\n-routine being called.  When @code{FUNCTION_ARG_CALLEE_COPIES} is defined and is\n-nonzero, the caller does not make a copy.  Instead, it passes a pointer to the\n-``live'' value.  The called function must not modify this value.  If it can be\n-determined that the value won't be modified, it need not make a copy;\n-otherwise a copy must be made.\n-@end defmac\n+@deftypefn {Target Hook} bool TARGET_CALLEE_COPIES (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})\n+The function argument described by the parameters to this hook is\n+known to be passed by reference.  The hook should return true if the\n+function argument should be copied by the callee instead of copied\n+by the caller.\n+\n+For any argument for which the hook returns true, if it can be \n+determined that the argument is not modified, then a copy need\n+not be generated.\n+\n+The default version of this hook always returns false.\n+@end deftypefn\n \n @defmac CUMULATIVE_ARGS\n A C type for declaring a variable that is used as the first argument of"}, {"sha": "2f693bb3daf726bfef0f10459f240ae5684c83b9", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -188,10 +188,6 @@ do {\t\t\t\t\t\t\t\\\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n #endif\n \n-#ifndef FUNCTION_ARG_CALLEE_COPIES\n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 0\n-#endif\n-\n tree split_complex_types (tree);\n tree split_complex_values (tree);\n "}, {"sha": "34c5d65dbe8c2f1851e3c39dca00e17dda348b55", "filename": "gcc/function.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -1951,6 +1951,18 @@ pass_by_reference (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n   return targetm.calls.pass_by_reference (ca, mode, type, named_arg);\n }\n \n+/* Return true if TYPE, which is passed by reference, should be callee\n+   copied instead of caller copied.  */\n+\n+bool\n+reference_callee_copied (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+\t\t\t tree type, bool named_arg)\n+{\n+  if (type && TREE_ADDRESSABLE (type))\n+    return false;\n+  return targetm.calls.callee_copies (ca, mode, type, named_arg);\n+}\n+\n /* Structures to communicate between the subroutines of assign_parms.\n    The first holds data persistent across all parameters, the second\n    is cleared out for each parameter.  */\n@@ -2766,9 +2778,8 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n     {\n       tree type = TREE_TYPE (data->passed_type);\n     \n-      if (FUNCTION_ARG_CALLEE_COPIES (all->args_so_far, TYPE_MODE (type),\n-\t\t\t\t      type, data->named_arg)\n-\t   && !TREE_ADDRESSABLE (type))\n+      if (reference_callee_copied (&all->args_so_far, TYPE_MODE (type),\n+\t\t\t\t   type, data->named_arg))\n \t{\n \t  rtx copy;\n "}, {"sha": "e38b5294dbb3216ef91f756830e019578f1575ad", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -543,5 +543,7 @@ extern void do_warn_unused_parameter (tree);\n \n extern bool pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t       tree, bool);\n+extern bool reference_callee_copied (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t     tree, bool);\n \n #endif  /* GCC_FUNCTION_H */"}, {"sha": "38042069122072d7fe78fb16f351e89d69fc0e6e", "filename": "gcc/target-def.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -383,12 +383,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_SPLIT_COMPLEX_ARG NULL\n \n #define TARGET_GIMPLIFY_VA_ARG_EXPR std_gimplify_va_arg_expr\n-\n-#define TARGET_PASS_BY_REFERENCE hook_pass_by_reference_false\n-\n+#define TARGET_PASS_BY_REFERENCE hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false\n #define TARGET_LATE_RTL_PROLOGUE_EPILOGUE false\n-\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size_or_pad\n+#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false\n \n #define TARGET_CALLS {\t\t\t\t\t\t\\\n    TARGET_PROMOTE_FUNCTION_ARGS,\t\t\t\t\\\n@@ -403,7 +401,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_STRICT_ARGUMENT_NAMING,\t\t\t\t\\\n    TARGET_PRETEND_OUTGOING_VARARGS_NAMED,\t\t\t\\\n    TARGET_SPLIT_COMPLEX_ARG,\t\t\t\t\t\\\n-   TARGET_MUST_PASS_IN_STACK\t\t\t\t\t\\\n+   TARGET_MUST_PASS_IN_STACK,\t\t\t\t\t\\\n+   TARGET_CALLEE_COPIES\t\t\t\t\t\t\\\n    }\n \n "}, {"sha": "acb1814bcc3efc991c5ff0e455861a22e60ef821", "filename": "gcc/target.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -502,6 +502,12 @@ struct gcc_target\n     /* ??? This predicate should be applied strictly after pass-by-reference.\n        Need audit to verify that this is the case.  */\n     bool (* must_pass_in_stack) (enum machine_mode mode, tree t);\n+\n+    /* Return true if type TYPE, mode MODE, which is passed by reference,\n+       should have the object copy generated by the callee rather than\n+       the caller.  It is never called for TYPE requiring constructors.  */\n+    bool (* callee_copies) (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+\t\t\t    tree type, bool named);\n   } calls;\n \n   /* Functions specific to the C++ frontend.  */"}, {"sha": "042c83efb4c253c6105a06893c29a701b3870d4c", "filename": "gcc/targhooks.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -184,17 +184,6 @@ default_cxx_get_cookie_size (tree type)\n   return cookie_size;\n }\n \n-/* This version of the TARGET_PASS_BY_REFERENCE hook adds no conditions\n-   beyond those mandated by generic code.  */\n-\n-bool\n-hook_pass_by_reference_false (CUMULATIVE_ARGS *c ATTRIBUTE_UNUSED,\n-\tenum machine_mode mode ATTRIBUTE_UNUSED, tree type ATTRIBUTE_UNUSED,\n-\tbool named_arg ATTRIBUTE_UNUSED)\n-{\n-  return false;\n-}\n-\n /* Return true if a parameter must be passed by reference.  This version\n    of the TARGET_PASS_BY_REFERENCE hook uses just MUST_PASS_IN_STACK.  */\n \n@@ -206,6 +195,16 @@ hook_pass_by_reference_must_pass_in_stack (CUMULATIVE_ARGS *c ATTRIBUTE_UNUSED,\n   return targetm.calls.must_pass_in_stack (mode, type);\n }\n \n+/* Return true if a parameter follows callee copies conventions.  This\n+   version of the hook is true for all named arguments.  */\n+\n+bool\n+hook_callee_copies_named (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t  tree type ATTRIBUTE_UNUSED, bool named)\n+{\n+  return named;\n+}\n \n /* Emit any directives required to unwind this instruction.  */\n \n@@ -262,3 +261,21 @@ default_scalar_mode_supported_p (enum machine_mode mode)\n       abort ();\n     }\n }\n+\n+bool\n+hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false (\n+\tCUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\ttree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n+bool\n+hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true (\n+\tCUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\ttree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}"}, {"sha": "bbdfacdc0a5cb25e36d88f9cd8bbcdc267d8db48", "filename": "gcc/targhooks.h", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cdd56724aff3adc4bef1b5441526d84ddb6d2cb/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=6cdd56724aff3adc4bef1b5441526d84ddb6d2cb", "patch": "@@ -28,22 +28,31 @@ extern bool default_return_in_memory (tree, tree);\n extern rtx default_expand_builtin_saveregs (void);\n extern void default_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\n extern rtx default_builtin_setjmp_frame_value (void);\n-extern bool hook_bool_CUMULATIVE_ARGS_false (CUMULATIVE_ARGS *);\n extern bool default_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *);\n \n extern enum machine_mode default_eh_return_filter_mode (void);\n extern unsigned HOST_WIDE_INT default_shift_truncation_mask\n   (enum machine_mode);\n \n-extern bool hook_bool_CUMULATIVE_ARGS_true (CUMULATIVE_ARGS *);\n extern tree default_cxx_guard_type (void);\n extern tree default_cxx_get_cookie_size (tree);\n \n-extern bool hook_pass_by_reference_false\n-  (CUMULATIVE_ARGS *, enum machine_mode mode, tree, bool);\n extern bool hook_pass_by_reference_must_pass_in_stack\n   (CUMULATIVE_ARGS *, enum machine_mode mode, tree, bool);\n+extern bool hook_callee_copies_named\n+  (CUMULATIVE_ARGS *ca, enum machine_mode, tree, bool);\n \n extern void default_unwind_emit (FILE *, rtx);\n \n extern bool default_scalar_mode_supported_p (enum machine_mode);\n+\n+/* These are here, and not in hooks.[ch], because not all users of\n+   hooks.h include tm.h, and thus we don't have CUMULATIVE_ARGS.  */\n+\n+extern bool hook_bool_CUMULATIVE_ARGS_false (CUMULATIVE_ARGS *);\n+extern bool hook_bool_CUMULATIVE_ARGS_true (CUMULATIVE_ARGS *);\n+\n+extern bool hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false\n+  (CUMULATIVE_ARGS *, enum machine_mode, tree, bool);\n+extern bool hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n+  (CUMULATIVE_ARGS *, enum machine_mode, tree, bool);"}]}