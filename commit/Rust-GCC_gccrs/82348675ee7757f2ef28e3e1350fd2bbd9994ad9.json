{"sha": "82348675ee7757f2ef28e3e1350fd2bbd9994ad9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIzNDg2NzVlZTc3NTdmMmVmMjhlM2UxMzUwZmQyYmJkOTk5NGFkOQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2017-10-24T02:35:50Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2017-10-24T02:35:50Z"}, "message": "nios2-protos.h (nios2_large_constant_p): Declare.\n\n2017-10-23  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/\n\t* config/nios2/nios2-protos.h (nios2_large_constant_p): Declare.\n\t(nios2_symbolic_memory_operand_p): Declare.\n\t(nios2_split_large_constant): Declare.\n\t(nios2_split_symbolic_memory_operand): Declare.\n\t* config/nios2/nios2.c: Adjust includes.\n\t(nios2_symbolic_constant_allowed): New.\n\t(nios2_symbolic_constant_p): New.\n\t(nios2_plus_symbolic_constant_p): New.\n\t(nios2_valid_addr_expr_p): Recognize addresses involving \n\tsymbolic constants.\n\t(nios2_legitimate_address_p): Likewise, also LO_SUM.\n\t(nios2_symbolic_memory_operand_p): New.\n\t(nios2_large_constant_p): New.\n\t(nios2_split_large_constant): New.\n\t(nios2_split_plus_large_constant): New.\n\t(nios2_split_symbolic_memory_operand): New.\n\t(nios2_legitimize_address): Code refactoring.  Handle addresses\n\tinvolving symbolic constants.\n\t(nios2_emit_move_sequence): Likewise.\n\t(nios2_print_operand): Improve error output.\n\t(nios2_print_operand_address): Handle LO_SUM.\n\t(nios2_cdx_narrow_form_p): Likewise.\n\t* config/nios2/nios2.md (movqi_internal): Add splitter for memory\n\toperands involving symbolic constants.\n\t(movhi_internal, movsi_internal): Likewise.\n\t(zero_extendhisi2, zero_extendqi<mode>2): Likewise.\n\t(extendhisi2, extendqi<mode>2): Likewise.\n\nFrom-SVN: r254033", "tree": {"sha": "2e0e51a19f52572af692c3439e4a1a36603345ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e0e51a19f52572af692c3439e4a1a36603345ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82348675ee7757f2ef28e3e1350fd2bbd9994ad9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82348675ee7757f2ef28e3e1350fd2bbd9994ad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82348675ee7757f2ef28e3e1350fd2bbd9994ad9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82348675ee7757f2ef28e3e1350fd2bbd9994ad9/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6642bfb2b855d916e2eb62d24742f7db7e74a16c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6642bfb2b855d916e2eb62d24742f7db7e74a16c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6642bfb2b855d916e2eb62d24742f7db7e74a16c"}], "stats": {"total": 339, "additions": 317, "deletions": 22}, "files": [{"sha": "f214c8ae47fed8a3ac9b105156ba3505a59cebd1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82348675ee7757f2ef28e3e1350fd2bbd9994ad9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82348675ee7757f2ef28e3e1350fd2bbd9994ad9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82348675ee7757f2ef28e3e1350fd2bbd9994ad9", "patch": "@@ -1,3 +1,33 @@\n+2017-10-23  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* config/nios2/nios2-protos.h (nios2_large_constant_p): Declare.\n+\t(nios2_symbolic_memory_operand_p): Declare.\n+\t(nios2_split_large_constant): Declare.\n+\t(nios2_split_symbolic_memory_operand): Declare.\n+\t* config/nios2/nios2.c: Adjust includes.\n+\t(nios2_symbolic_constant_allowed): New.\n+\t(nios2_symbolic_constant_p): New.\n+\t(nios2_plus_symbolic_constant_p): New.\n+\t(nios2_valid_addr_expr_p): Recognize addresses involving \n+\tsymbolic constants.\n+\t(nios2_legitimate_address_p): Likewise, also LO_SUM.\n+\t(nios2_symbolic_memory_operand_p): New.\n+\t(nios2_large_constant_p): New.\n+\t(nios2_split_large_constant): New.\n+\t(nios2_split_plus_large_constant): New.\n+\t(nios2_split_symbolic_memory_operand): New.\n+\t(nios2_legitimize_address): Code refactoring.  Handle addresses\n+\tinvolving symbolic constants.\n+\t(nios2_emit_move_sequence): Likewise.\n+\t(nios2_print_operand): Improve error output.\n+\t(nios2_print_operand_address): Handle LO_SUM.\n+\t(nios2_cdx_narrow_form_p): Likewise.\n+\t* config/nios2/nios2.md (movqi_internal): Add splitter for memory\n+\toperands involving symbolic constants.\n+\t(movhi_internal, movsi_internal): Likewise.\n+\t(zero_extendhisi2, zero_extendqi<mode>2): Likewise.\n+\t(extendhisi2, extendqi<mode>2): Likewise.\n+\n 2017-10-23  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* tree-pass.h (PROP_rtl_split_insns): Define."}, {"sha": "6df65bb800e3511245be26176611c545522d753a", "filename": "gcc/config/nios2/nios2-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82348675ee7757f2ef28e3e1350fd2bbd9994ad9/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82348675ee7757f2ef28e3e1350fd2bbd9994ad9/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2-protos.h?ref=82348675ee7757f2ef28e3e1350fd2bbd9994ad9", "patch": "@@ -30,6 +30,11 @@ extern bool nios2_expand_return (void);\n extern void nios2_function_profiler (FILE *, int);\n \n #ifdef RTX_CODE\n+extern bool nios2_large_constant_p (rtx);\n+extern bool nios2_symbolic_memory_operand_p (rtx);\n+\n+extern rtx nios2_split_large_constant (rtx, rtx);\n+extern rtx nios2_split_symbolic_memory_operand (rtx);\n extern bool nios2_emit_move_sequence (rtx *, machine_mode);\n extern void nios2_emit_expensive_div (rtx *, machine_mode);\n extern void nios2_adjust_call_address (rtx *, rtx);"}, {"sha": "af1ccebd1bcc935d1f8721daf04429e0ac2c8901", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 212, "deletions": 11, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82348675ee7757f2ef28e3e1350fd2bbd9994ad9/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82348675ee7757f2ef28e3e1350fd2bbd9994ad9/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=82348675ee7757f2ef28e3e1350fd2bbd9994ad9", "patch": "@@ -48,11 +48,13 @@\n #include \"langhooks.h\"\n #include \"stor-layout.h\"\n #include \"builtins.h\"\n+#include \"tree-pass.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n \n /* Forward function declarations.  */\n+static bool nios2_symbolic_constant_p (rtx);\n static bool prologue_saved_reg_p (unsigned);\n static void nios2_load_pic_register (void);\n static void nios2_register_custom_code (unsigned int, enum nios2_ccs_code, int);\n@@ -1902,7 +1904,52 @@ nios2_validate_compare (machine_mode mode, rtx *cmp, rtx *op1, rtx *op2)\n }\n \n \n-/* Addressing Modes.  */\n+/* Addressing modes and constants.  */\n+\n+/* Symbolic constants are split into high/lo_sum pairs during the \n+   split1 pass.  After that, they are not considered legitimate addresses.\n+   This function returns true if in a pre-split context where these\n+   constants are allowed.  */\n+static bool\n+nios2_symbolic_constant_allowed (void)\n+{\n+  /* The reload_completed check is for the benefit of\n+     nios2_asm_output_mi_thunk and perhaps other places that try to\n+     emulate a post-reload pass.  */\n+  return !(cfun->curr_properties & PROP_rtl_split_insns) && !reload_completed;\n+}\n+\n+/* Return true if X is constant expression with a reference to an\n+   \"ordinary\" symbol; not GOT-relative, not GP-relative, not TLS.  */\n+static bool\n+nios2_symbolic_constant_p (rtx x)\n+{\n+  rtx base, offset;\n+\n+  if (flag_pic)\n+    return false;\n+  if (GET_CODE (x) == LABEL_REF)\n+    return true;\n+  else if (CONSTANT_P (x))\n+    {\n+      split_const (x, &base, &offset);\n+      return (SYMBOL_REF_P (base)\n+\t\t&& !SYMBOL_REF_TLS_MODEL (base)\n+\t\t&& !gprel_constant_p (base)\n+\t\t&& SMALL_INT (INTVAL (offset)));\n+    }\n+  return false;\n+}\n+\n+/* Return true if X is an expression of the form \n+   (PLUS reg symbolic_constant).  */\n+static bool\n+nios2_plus_symbolic_constant_p (rtx x)\n+{\n+  return (GET_CODE (x) == PLUS\n+\t  && REG_P (XEXP (x, 0))\n+\t  && nios2_symbolic_constant_p (XEXP (x, 1)));\n+}\n \n /* Implement TARGET_LEGITIMATE_CONSTANT_P.  */\n static bool\n@@ -1971,6 +2018,8 @@ nios2_valid_addr_expr_p (rtx base, rtx offset, bool strict_p)\n \t  && nios2_regno_ok_for_base_p (REGNO (base), strict_p)\n \t  && (offset == NULL_RTX\n \t      || nios2_valid_addr_offset_p (offset)\n+\t      || (nios2_symbolic_constant_allowed () \n+\t\t  && nios2_symbolic_constant_p (offset))\n \t      || nios2_unspec_reloc_p (offset)));\n }\n \n@@ -1993,6 +2042,11 @@ nios2_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,\n \n       /* Else, fall through.  */\n     case LABEL_REF:\n+      if (nios2_symbolic_constant_allowed () \n+\t  && nios2_symbolic_constant_p (operand))\n+\treturn true;\n+\n+      /* Else, fall through.  */\n     case CONST_INT:\n     case CONST_DOUBLE:\n       return false;\n@@ -2007,16 +2061,104 @@ nios2_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,\n         rtx op0 = XEXP (operand, 0);\n         rtx op1 = XEXP (operand, 1);\n \n-\treturn (nios2_valid_addr_expr_p (op0, op1, strict_p)\n-\t\t|| nios2_valid_addr_expr_p (op1, op0, strict_p));\n+\tif (nios2_valid_addr_expr_p (op0, op1, strict_p) \n+\t    || nios2_valid_addr_expr_p (op1, op0, strict_p))\n+\t  return true;\n       }\n+      break;\n+\n+      /* %lo(constant)(reg)\n+\t This requires a 16-bit relocation and isn't valid with R2\n+\t io-variant load/stores.  */\n+    case LO_SUM:\n+      if (TARGET_ARCH_R2 \n+\t  && (TARGET_BYPASS_CACHE || TARGET_BYPASS_CACHE_VOLATILE))\n+\treturn false;\n+      else\n+\t{\n+\t  rtx op0 = XEXP (operand, 0);\n+\t  rtx op1 = XEXP (operand, 1);\n+\n+\t  return (REG_P (op0)\n+\t\t  && nios2_regno_ok_for_base_p (REGNO (op0), strict_p)\n+\t\t  && nios2_large_constant_p (op1));\n+\t}\n \n     default:\n       break;\n     }\n   return false;\n }\n \n+/* Return true if X is a MEM whose address expression involves a symbolic\n+   constant.  */\n+bool\n+nios2_symbolic_memory_operand_p (rtx x)\n+{\n+  rtx addr;\n+\n+  if (GET_CODE (x) != MEM)\n+    return false;\n+  addr = XEXP (x, 0);\n+\n+  return (nios2_symbolic_constant_p (addr)\n+\t  || nios2_plus_symbolic_constant_p (addr));\n+}\n+\n+\n+/* Return true if X is something that needs to be split into a \n+   high/lo_sum pair.  */\n+bool\n+nios2_large_constant_p (rtx x)\n+{\n+  return (nios2_symbolic_constant_p (x)\n+\t  || nios2_large_unspec_reloc_p (x));\n+}\n+\n+/* Given an RTX X that satisfies nios2_large_constant_p, split it into\n+   high and lo_sum parts using TEMP as a scratch register.  Emit the high \n+   instruction and return the lo_sum expression.  */\n+rtx\n+nios2_split_large_constant (rtx x, rtx temp)\n+{\n+  emit_insn (gen_rtx_SET (temp, gen_rtx_HIGH (Pmode, copy_rtx (x))));\n+  return gen_rtx_LO_SUM (Pmode, temp, copy_rtx (x));\n+}\n+\n+/* Split an RTX of the form\n+     (plus op0 op1)\n+   where op1 is a large constant into\n+     (set temp (high op1))\n+     (set temp (plus op0 temp))\n+     (lo_sum temp op1)\n+   returning the lo_sum expression as the value.  */\n+static rtx\n+nios2_split_plus_large_constant (rtx op0, rtx op1)\n+{\n+  rtx temp = gen_reg_rtx (Pmode);\n+  op0 = force_reg (Pmode, op0);\n+\n+  emit_insn (gen_rtx_SET (temp, gen_rtx_HIGH (Pmode, copy_rtx (op1))));\n+  emit_insn (gen_rtx_SET (temp, gen_rtx_PLUS (Pmode, op0, temp)));\n+  return gen_rtx_LO_SUM (Pmode, temp, copy_rtx (op1));\n+}\n+\n+/* Given a MEM OP with an address that includes a splittable symbol,\n+   emit some instructions to do the split and return a new MEM.  */\n+rtx\n+nios2_split_symbolic_memory_operand (rtx op)\n+{\n+  rtx addr = XEXP (op, 0);\n+\n+  if (nios2_symbolic_constant_p (addr))\n+    addr = nios2_split_large_constant (addr, gen_reg_rtx (Pmode));\n+  else if (nios2_plus_symbolic_constant_p (addr))\n+    addr = nios2_split_plus_large_constant (XEXP (addr, 0), XEXP (addr, 1));\n+  else\n+    gcc_unreachable ();\n+  return replace_equiv_address (op, addr, false);\n+}\n+\n /* Return true if SECTION is a small section name.  */\n static bool\n nios2_small_section_name_p (const char *section)\n@@ -2219,6 +2361,9 @@ nios2_legitimize_constant_address (rtx addr)\n     base = nios2_legitimize_tls_address (base);\n   else if (flag_pic)\n     base = nios2_load_pic_address (base, UNSPEC_PIC_SYM, NULL_RTX);\n+  else if (!nios2_symbolic_constant_allowed () \n+\t   && nios2_symbolic_constant_p (addr))\n+    return nios2_split_large_constant (addr, gen_reg_rtx (Pmode));\n   else\n     return addr;\n \n@@ -2239,9 +2384,27 @@ static rtx\n nios2_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t\t  machine_mode mode ATTRIBUTE_UNUSED)\n {\n+  rtx op0, op1;\n+  \n   if (CONSTANT_P (x))\n     return nios2_legitimize_constant_address (x);\n \n+  /* Remaining cases all involve something + a constant.  */\n+  if (GET_CODE (x) != PLUS)\n+    return x;\n+\n+  op0 = XEXP (x, 0);\n+  op1 = XEXP (x, 1);\n+\n+  /* We may need to split symbolic constants now.  */\n+  if (nios2_symbolic_constant_p (op1))\n+    {\n+      if (nios2_symbolic_constant_allowed ())\n+\treturn gen_rtx_PLUS (Pmode, force_reg (Pmode, op0), copy_rtx (op1));\n+      else\n+\treturn nios2_split_plus_large_constant (op0, op1);\n+    }\n+\n   /* For the TLS LE (Local Exec) model, the compiler may try to\n      combine constant offsets with unspec relocs, creating address RTXs\n      looking like this:\n@@ -2264,20 +2427,19 @@ nios2_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n                               (const_int 48 [0x30])))] UNSPEC_ADD_TLS_LE)))\n \n      Which will be output as '%tls_le(var+48)(r23)' in assembly.  */\n-  if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 1)) == CONST)\n+  else if (GET_CODE (op1) == CONST)\n     {\n       rtx unspec, offset;\n-      split_const (XEXP (x, 1), &unspec, &offset);\n+      split_const (op1, &unspec, &offset);\n       if (GET_CODE (unspec) == UNSPEC\n \t  && !nios2_large_offset_p (XINT (unspec, 1))\n \t  && offset != const0_rtx)\n \t{\n-\t  rtx reg = force_reg (Pmode, XEXP (x, 0));\n+\t  rtx reg = force_reg (Pmode, op0);\n \t  unspec = copy_rtx (unspec);\n \t  XVECEXP (unspec, 0, 0)\n \t    = plus_constant (Pmode, XVECEXP (unspec, 0, 0), INTVAL (offset));\n-\t  x = gen_rtx_PLUS (Pmode, reg, gen_rtx_CONST (Pmode, unspec));\n+\t  return gen_rtx_PLUS (Pmode, reg, gen_rtx_CONST (Pmode, unspec));\n \t}\n     }\n \n@@ -2338,10 +2500,28 @@ nios2_emit_move_sequence (rtx *operands, machine_mode mode)\n \t      return true;\n \t    }\n \t}\n-      else if (!gprel_constant_p (from))\n+      else if (gprel_constant_p (from))\n+\t/* Handled directly by movsi_internal as gp + offset.  */\n+\t;\n+      else if (nios2_large_constant_p (from))\n+\t/* This case covers either a regular symbol reference or an UNSPEC\n+\t   representing a 32-bit offset.  We split the former \n+\t   only conditionally and the latter always.  */\n \t{\n-\t  if (!nios2_large_unspec_reloc_p (from))\n-\t    from = nios2_legitimize_constant_address (from);\n+\t  if (!nios2_symbolic_constant_allowed () \n+\t      || nios2_large_unspec_reloc_p (from))\n+\t    {\n+\t      rtx lo = nios2_split_large_constant (from, to);\n+\t      emit_insn (gen_rtx_SET (to, lo));\n+\t      set_unique_reg_note (get_last_insn (), REG_EQUAL,\n+\t\t\t\t   copy_rtx (operands[1]));\n+\t      return true;\n+\t    }\n+\t}\n+      else \n+\t/* This is a TLS or PIC symbol.  */\n+\t{\n+\t  from = nios2_legitimize_constant_address (from);\n \t  if (CONSTANT_P (from))\n \t    {\n \t      emit_insn (gen_rtx_SET (to,\n@@ -2652,6 +2832,7 @@ nios2_print_operand (FILE *file, rtx op, int letter)\n       break;\n     }\n \n+  debug_rtx (op);\n   output_operand_lossage (\"Unsupported operand for code '%c'\", letter);\n   gcc_unreachable ();\n }\n@@ -2757,6 +2938,20 @@ nios2_print_operand_address (FILE *file, machine_mode mode, rtx op)\n       }\n       break;\n \n+    case LO_SUM:\n+      {\n+        rtx op0 = XEXP (op, 0);\n+        rtx op1 = XEXP (op, 1);\n+\n+\tif (REG_P (op0) && CONSTANT_P (op1))\n+\t  {\n+\t    nios2_print_operand (file, op1, 'L');\n+\t    fprintf (file, \"(%s)\", reg_names[REGNO (op0)]);\n+\t    return;\n+\t  }\n+      }\n+      break;\n+\n     case REG:\n       fprintf (file, \"0(%s)\", reg_names[REGNO (op)]);\n       return;\n@@ -4329,6 +4524,9 @@ nios2_cdx_narrow_form_p (rtx_insn *insn)\n \t    /* GP-based references are never narrow.  */\n \t    if (gprel_constant_p (addr))\n \t\treturn false;\n+\t    /* %lo requires a 16-bit relocation and is never narrow.  */\n+\t    if (GET_CODE (addr) == LO_SUM)\n+\t      return false;\n \t    ret = split_mem_address (addr, &rhs1, &rhs2);\n \t    gcc_assert (ret);\n \t  }\n@@ -4373,6 +4571,9 @@ nios2_cdx_narrow_form_p (rtx_insn *insn)\n \t  /* GP-based references are never narrow.  */\n \t  if (gprel_constant_p (addr))\n \t    return false;\n+\t  /* %lo requires a 16-bit relocation and is never narrow.  */\n+\t  if (GET_CODE (addr) == LO_SUM)\n+\t    return false;\n \t  ret = split_mem_address (addr, &rhs1, &rhs2);\n \t  gcc_assert (ret);\n \t  offset = INTVAL (rhs2);"}, {"sha": "ef2883f25169c27b376942a14cde5afa52c5df32", "filename": "gcc/config/nios2/nios2.md", "status": "modified", "additions": 70, "deletions": 11, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82348675ee7757f2ef28e3e1350fd2bbd9994ad9/gcc%2Fconfig%2Fnios2%2Fnios2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82348675ee7757f2ef28e3e1350fd2bbd9994ad9/gcc%2Fconfig%2Fnios2%2Fnios2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.md?ref=82348675ee7757f2ef28e3e1350fd2bbd9994ad9", "patch": "@@ -201,7 +201,7 @@\n   \"addi\\\\t%0, %1, %L2\"\n   [(set_attr \"type\" \"alu\")])\n \n-(define_insn \"movqi_internal\"\n+(define_insn_and_split \"movqi_internal\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=m, r,r\")\n         (match_operand:QI 1 \"general_operand\"       \"rM,m,rI\"))]\n   \"(register_operand (operands[0], QImode)\n@@ -224,20 +224,47 @@\n \tgcc_unreachable ();\n       }\n   }\n+  \"(nios2_symbolic_memory_operand_p (operands[0]) \n+   || nios2_symbolic_memory_operand_p (operands[1]))\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  {\n+    if (nios2_symbolic_memory_operand_p (operands[0]))\n+      operands[0] = nios2_split_symbolic_memory_operand (operands[0]);\n+    else\n+      operands[1] = nios2_split_symbolic_memory_operand (operands[1]);\n+  }\n   [(set_attr \"type\" \"st,ld,mov\")])\n \n-(define_insn \"movhi_internal\"\n+(define_insn_and_split \"movhi_internal\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=m, r,r\")\n         (match_operand:HI 1 \"general_operand\"       \"rM,m,rI\"))]\n   \"(register_operand (operands[0], HImode)\n     || reg_or_0_operand (operands[1], HImode))\"\n-  \"@\n-    sth%o0%.\\\\t%z1, %0\n-    ldhu%o1%.\\\\t%0, %1\n-    mov%i1%.\\\\t%0, %z1\"\n+  {\n+    switch (which_alternative)\n+      {\n+      case 0:\n+        return \"sth%o0%.\\\\t%z1, %0\";\n+      case 1:\n+        return \"ldhu%o1%.\\\\t%0, %1\";\n+      case 2:\n+        return \"mov%i1%.\\\\t%0, %z1\";\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+  \"(nios2_symbolic_memory_operand_p (operands[0]) \n+   || nios2_symbolic_memory_operand_p (operands[1]))\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  {\n+    if (nios2_symbolic_memory_operand_p (operands[0]))\n+      operands[0] = nios2_split_symbolic_memory_operand (operands[0]);\n+    else\n+      operands[1] = nios2_split_symbolic_memory_operand (operands[1]);\n+  }\n   [(set_attr \"type\" \"st,ld,mov\")])\n \n-(define_insn \"movsi_internal\"\n+(define_insn_and_split \"movsi_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m, r,r,   r\")\n         (match_operand:SI 1 \"general_operand\"       \"rM,m,rIJK,S\"))]\n   \"(register_operand (operands[0], SImode)\n@@ -269,6 +296,18 @@\n \tgcc_unreachable ();\n       }\n   }\n+  \"(nios2_symbolic_memory_operand_p (operands[0]) \n+    || nios2_symbolic_memory_operand_p (operands[1])\n+    || nios2_large_constant_p (operands[1]))\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  {\n+    if (nios2_symbolic_memory_operand_p (operands[0]))\n+      operands[0] = nios2_split_symbolic_memory_operand (operands[0]);\n+    else if (nios2_symbolic_memory_operand_p (operands[1]))\n+      operands[1] = nios2_split_symbolic_memory_operand (operands[1]);\n+    else\n+      operands[1] = nios2_split_large_constant (operands[1], operands[0]);\n+  }\n   [(set_attr \"type\" \"st,ld,mov,alu\")])\n \n (define_mode_iterator BH [QI HI])\n@@ -318,42 +357,62 @@\n (define_mode_iterator QX [HI SI])\n \n ;; Zero extension patterns\n-(define_insn \"zero_extendhisi2\"\n+(define_insn_and_split \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n         (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n   \"\"\n   \"@\n     andi%.\\\\t%0, %1, 0xffff\n     ldhu%o1%.\\\\t%0, %1\"\n+  \"nios2_symbolic_memory_operand_p (operands[1])\"\n+  [(set (match_dup 0) (zero_extend:SI (match_dup 1)))]\n+  {\n+    operands[1] = nios2_split_symbolic_memory_operand (operands[1]);\n+  }\n   [(set_attr \"type\"     \"and,ld\")])\n \n-(define_insn \"zero_extendqi<mode>2\"\n+(define_insn_and_split \"zero_extendqi<mode>2\"\n   [(set (match_operand:QX 0 \"register_operand\" \"=r,r\")\n         (zero_extend:QX (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n   \"\"\n   \"@\n     andi%.\\\\t%0, %1, 0xff\n     ldbu%o1%.\\\\t%0, %1\"\n+  \"nios2_symbolic_memory_operand_p (operands[1])\"\n+  [(set (match_dup 0) (zero_extend:QX (match_dup 1)))]\n+  {\n+    operands[1] = nios2_split_symbolic_memory_operand (operands[1]);\n+  }\n   [(set_attr \"type\"     \"and,ld\")])\n \n ;; Sign extension patterns\n \n-(define_insn \"extendhisi2\"\n+(define_insn_and_split \"extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\"                     \"=r,r\")\n         (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\"  \"r,m\")))]\n   \"\"\n   \"@\n    #\n    ldh%o1%.\\\\t%0, %1\"\n+  \"nios2_symbolic_memory_operand_p (operands[1])\"\n+  [(set (match_dup 0) (sign_extend:SI (match_dup 1)))]\n+  {\n+    operands[1] = nios2_split_symbolic_memory_operand (operands[1]);\n+  }\n   [(set_attr \"type\" \"alu,ld\")])\n \n-(define_insn \"extendqi<mode>2\"\n+(define_insn_and_split \"extendqi<mode>2\"\n   [(set (match_operand:QX 0 \"register_operand\"                     \"=r,r\")\n         (sign_extend:QX (match_operand:QI 1 \"nonimmediate_operand\"  \"r,m\")))]\n   \"\"\n   \"@\n    #\n    ldb%o1%.\\\\t%0, %1\"\n+  \"nios2_symbolic_memory_operand_p (operands[1])\"\n+  [(set (match_dup 0) (sign_extend:QX (match_dup 1)))]\n+  {\n+    operands[1] = nios2_split_symbolic_memory_operand (operands[1]);\n+  }\n   [(set_attr \"type\" \"alu,ld\")])\n \n ;; Split patterns for register alternative cases."}]}