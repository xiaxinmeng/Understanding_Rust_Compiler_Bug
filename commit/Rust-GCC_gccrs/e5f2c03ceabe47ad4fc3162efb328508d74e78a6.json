{"sha": "e5f2c03ceabe47ad4fc3162efb328508d74e78a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVmMmMwM2NlYWJlNDdhZDRmYzMxNjJlZmIzMjg1MDhkNzRlNzhhNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T12:18:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-20T12:18:09Z"}, "message": "[multiple changes]\n\n2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb: Code clean up.\n\n2015-10-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb (Expand_N_Extended_Return_Statement): Code cleanup.\n\t(Make_Build_In_Place_Call_In_Object_Declaration): Update the\n\tparameter profile.  Code cleanup. Request debug info for the\n\tobject renaming declaration.\n\t(Move_Activation_Chain): Add new formal parameter and update the\n\tcomment on usage.\n\t* exp_ch6.ads (Make_Build_In_Place_Call_In_Object_Declaration):\n\tUpdate the parameter profile and comment on usage.\n\t* sem_util.ads, sem_util.adb (Remove_Overloaded_Entity): New routine,\n\tcurrently unused.\n\nFrom-SVN: r229067", "tree": {"sha": "71bceedb186341d23abe6ec26381f6a4827c7043", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71bceedb186341d23abe6ec26381f6a4827c7043"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5f2c03ceabe47ad4fc3162efb328508d74e78a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f2c03ceabe47ad4fc3162efb328508d74e78a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5f2c03ceabe47ad4fc3162efb328508d74e78a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f2c03ceabe47ad4fc3162efb328508d74e78a6/comments", "author": null, "committer": null, "parents": [{"sha": "58ef3d309c306a09b552c035c0aa31c788eb1a3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58ef3d309c306a09b552c035c0aa31c788eb1a3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58ef3d309c306a09b552c035c0aa31c788eb1a3e"}], "stats": {"total": 429, "additions": 272, "deletions": 157}, "files": [{"sha": "e32bac43c41ac6721eb94b8d4f27eb538b69209d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f2c03ceabe47ad4fc3162efb328508d74e78a6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f2c03ceabe47ad4fc3162efb328508d74e78a6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e5f2c03ceabe47ad4fc3162efb328508d74e78a6", "patch": "@@ -1,3 +1,20 @@\n+2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb: Code clean up.\n+\n+2015-10-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_N_Extended_Return_Statement): Code cleanup.\n+\t(Make_Build_In_Place_Call_In_Object_Declaration): Update the\n+\tparameter profile.  Code cleanup. Request debug info for the\n+\tobject renaming declaration.\n+\t(Move_Activation_Chain): Add new formal parameter and update the\n+\tcomment on usage.\n+\t* exp_ch6.ads (Make_Build_In_Place_Call_In_Object_Declaration):\n+\tUpdate the parameter profile and comment on usage.\n+\t* sem_util.ads, sem_util.adb (Remove_Overloaded_Entity): New routine,\n+\tcurrently unused.\n+\n 2015-10-20  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch13.adb (Analyze_One_Aspect, case"}, {"sha": "792208a3806ab8cbf60d7248aed2d8c3a2a826af", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 141, "deletions": 150, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f2c03ceabe47ad4fc3162efb328508d74e78a6/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f2c03ceabe47ad4fc3162efb328508d74e78a6/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=e5f2c03ceabe47ad4fc3162efb328508d74e78a6", "patch": "@@ -3942,22 +3942,6 @@ package body Exp_Ch6 is\n    procedure Expand_N_Extended_Return_Statement (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n \n-      Par_Func     : constant Entity_Id :=\n-                       Return_Applies_To (Return_Statement_Entity (N));\n-      Result_Subt  : constant Entity_Id := Etype (Par_Func);\n-      Ret_Obj_Id   : constant Entity_Id :=\n-                       First_Entity (Return_Statement_Entity (N));\n-      Ret_Obj_Decl : constant Node_Id := Parent (Ret_Obj_Id);\n-\n-      Is_Build_In_Place : constant Boolean :=\n-                            Is_Build_In_Place_Function (Par_Func);\n-\n-      Exp         : Node_Id;\n-      HSS         : Node_Id;\n-      Result      : Node_Id;\n-      Return_Stmt : Node_Id;\n-      Stmts       : List_Id;\n-\n       function Build_Heap_Allocator\n         (Temp_Id    : Entity_Id;\n          Temp_Typ   : Entity_Id;\n@@ -3991,12 +3975,15 @@ package body Exp_Ch6 is\n       --  temporary. Func_Id is the enclosing function. Ret_Typ is the return\n       --  type of Func_Id. Alloc_Expr is the actual allocator.\n \n-      function Move_Activation_Chain return Node_Id;\n+      function Move_Activation_Chain (Func_Id : Entity_Id) return Node_Id;\n       --  Construct a call to System.Tasking.Stages.Move_Activation_Chain\n       --  with parameters:\n       --    From         current activation chain\n       --    To           activation chain passed in by the caller\n       --    New_Master   master passed in by the caller\n+      --\n+      --  Func_Id is the entity of the function where the extended return\n+      --  statement appears.\n \n       --------------------------\n       -- Build_Heap_Allocator --\n@@ -4158,7 +4145,7 @@ package body Exp_Ch6 is\n       -- Move_Activation_Chain --\n       ---------------------------\n \n-      function Move_Activation_Chain return Node_Id is\n+      function Move_Activation_Chain (Func_Id : Entity_Id) return Node_Id is\n       begin\n          return\n            Make_Procedure_Call_Statement (Loc,\n@@ -4176,14 +4163,31 @@ package body Exp_Ch6 is\n                --  Destination chain\n \n                New_Occurrence_Of\n-                 (Build_In_Place_Formal (Par_Func, BIP_Activation_Chain), Loc),\n+                 (Build_In_Place_Formal (Func_Id, BIP_Activation_Chain), Loc),\n \n                --  New master\n \n                New_Occurrence_Of\n-                 (Build_In_Place_Formal (Par_Func, BIP_Task_Master), Loc)));\n+                 (Build_In_Place_Formal (Func_Id, BIP_Task_Master), Loc)));\n       end Move_Activation_Chain;\n \n+      --  Local variables\n+\n+      Func_Id      : constant Entity_Id :=\n+                       Return_Applies_To (Return_Statement_Entity (N));\n+      Is_BIP_Func  : constant Boolean   :=\n+                       Is_Build_In_Place_Function (Func_Id);\n+      Ret_Obj_Id   : constant Entity_Id :=\n+                       First_Entity (Return_Statement_Entity (N));\n+      Ret_Obj_Decl : constant Node_Id   := Parent (Ret_Obj_Id);\n+      Ret_Typ      : constant Entity_Id := Etype (Func_Id);\n+\n+      Exp         : Node_Id;\n+      HSS         : Node_Id;\n+      Result      : Node_Id;\n+      Return_Stmt : Node_Id;\n+      Stmts       : List_Id;\n+\n    --  Start of processing for Expand_N_Extended_Return_Statement\n \n    begin\n@@ -4207,9 +4211,7 @@ package body Exp_Ch6 is\n       --  with the scope finalizer. There is one flag per each return object\n       --  in case of multiple returns.\n \n-      if Is_Build_In_Place\n-        and then Needs_Finalization (Etype (Ret_Obj_Id))\n-      then\n+      if Is_BIP_Func and then Needs_Finalization (Etype (Ret_Obj_Id)) then\n          declare\n             Flag_Decl : Node_Id;\n             Flag_Id   : Entity_Id;\n@@ -4218,7 +4220,7 @@ package body Exp_Ch6 is\n          begin\n             --  Recover the function body\n \n-            Func_Bod := Unit_Declaration_Node (Par_Func);\n+            Func_Bod := Unit_Declaration_Node (Func_Id);\n \n             if Nkind (Func_Bod) = N_Subprogram_Declaration then\n                Func_Bod := Parent (Parent (Corresponding_Body (Func_Bod)));\n@@ -4253,7 +4255,7 @@ package body Exp_Ch6 is\n       --  built in place (though we plan to do so eventually).\n \n       if Present (HSS)\n-        or else Is_Composite_Type (Result_Subt)\n+        or else Is_Composite_Type (Ret_Typ)\n         or else No (Exp)\n       then\n          if No (HSS) then\n@@ -4279,9 +4281,8 @@ package body Exp_Ch6 is\n          --  result to be built in place, though that's necessarily true for\n          --  the case of result types with task parts.\n \n-         if Is_Build_In_Place\n-           and then Has_Task (Result_Subt)\n-         then\n+         if Is_BIP_Func and then Has_Task (Ret_Typ) then\n+\n             --  The return expression is an aggregate for a complex type which\n             --  contains tasks. This particular case is left unexpanded since\n             --  the regular expansion would insert all temporaries and\n@@ -4295,16 +4296,14 @@ package body Exp_Ch6 is\n             --  contain tasks.\n \n             if Has_Task (Etype (Ret_Obj_Id)) then\n-               Append_To (Stmts, Move_Activation_Chain);\n+               Append_To (Stmts, Move_Activation_Chain (Func_Id));\n             end if;\n          end if;\n \n          --  Update the state of the function right before the object is\n          --  returned.\n \n-         if Is_Build_In_Place\n-           and then Needs_Finalization (Etype (Ret_Obj_Id))\n-         then\n+         if Is_BIP_Func and then Needs_Finalization (Etype (Ret_Obj_Id)) then\n             declare\n                Flag_Id : constant Entity_Id :=\n                            Status_Flag_Or_Transient_Decl (Ret_Obj_Id);\n@@ -4354,7 +4353,7 @@ package body Exp_Ch6 is\n          --  build-in-place function, and that function is responsible for\n          --  the allocation of the return object.\n \n-         if Is_Build_In_Place\n+         if Is_BIP_Func\n            and then Nkind (Ret_Obj_Decl) = N_Object_Renaming_Declaration\n          then\n             pragma Assert\n@@ -4366,7 +4365,7 @@ package body Exp_Ch6 is\n \n             Set_By_Ref (Return_Stmt);\n \n-         elsif Is_Build_In_Place then\n+         elsif Is_BIP_Func then\n \n             --  Locate the implicit access parameter associated with the\n             --  caller-supplied return object and convert the return\n@@ -4390,17 +4389,13 @@ package body Exp_Ch6 is\n             --       ...\n \n             declare\n-               Return_Obj_Id    : constant Entity_Id :=\n-                                    Defining_Identifier (Ret_Obj_Decl);\n-               Return_Obj_Typ   : constant Entity_Id := Etype (Return_Obj_Id);\n-               Return_Obj_Expr  : constant Node_Id :=\n-                                    Expression (Ret_Obj_Decl);\n-               Constr_Result    : constant Boolean :=\n-                                    Is_Constrained (Result_Subt);\n-               Obj_Alloc_Formal : Entity_Id;\n-               Object_Access    : Entity_Id;\n-               Obj_Acc_Deref    : Node_Id;\n+               Ret_Obj_Expr : constant Node_Id   := Expression (Ret_Obj_Decl);\n+               Ret_Obj_Typ  : constant Entity_Id := Etype (Ret_Obj_Id);\n+\n                Init_Assignment  : Node_Id := Empty;\n+               Obj_Acc_Formal   : Entity_Id;\n+               Obj_Acc_Deref    : Node_Id;\n+               Obj_Alloc_Formal : Entity_Id;\n \n             begin\n                --  Build-in-place results must be returned by reference\n@@ -4409,8 +4404,8 @@ package body Exp_Ch6 is\n \n                --  Retrieve the implicit access parameter passed by the caller\n \n-               Object_Access :=\n-                 Build_In_Place_Formal (Par_Func, BIP_Object_Access);\n+               Obj_Acc_Formal :=\n+                 Build_In_Place_Formal (Func_Id, BIP_Object_Access);\n \n                --  If the return object's declaration includes an expression\n                --  and the declaration isn't marked as No_Initialization, then\n@@ -4428,16 +4423,16 @@ package body Exp_Ch6 is\n                --  is a nonlimited descendant of a limited interface (the\n                --  interface has no assignment operation).\n \n-               if Present (Return_Obj_Expr)\n+               if Present (Ret_Obj_Expr)\n                  and then not No_Initialization (Ret_Obj_Decl)\n-                 and then not Is_Interface (Return_Obj_Typ)\n+                 and then not Is_Interface (Ret_Obj_Typ)\n                then\n                   Init_Assignment :=\n                     Make_Assignment_Statement (Loc,\n-                      Name       => New_Occurrence_Of (Return_Obj_Id, Loc),\n-                      Expression => Relocate_Node (Return_Obj_Expr));\n+                      Name       => New_Occurrence_Of (Ret_Obj_Id, Loc),\n+                      Expression => Relocate_Node (Ret_Obj_Expr));\n \n-                  Set_Etype (Name (Init_Assignment), Etype (Return_Obj_Id));\n+                  Set_Etype (Name (Init_Assignment), Etype (Ret_Obj_Id));\n                   Set_Assignment_OK (Name (Init_Assignment));\n                   Set_No_Ctrl_Actions (Init_Assignment);\n \n@@ -4446,14 +4441,14 @@ package body Exp_Ch6 is\n \n                   Set_Expression (Ret_Obj_Decl, Empty);\n \n-                  if Is_Class_Wide_Type (Etype (Return_Obj_Id))\n+                  if Is_Class_Wide_Type (Etype (Ret_Obj_Id))\n                     and then not Is_Class_Wide_Type\n                                    (Etype (Expression (Init_Assignment)))\n                   then\n                      Rewrite (Expression (Init_Assignment),\n                        Make_Type_Conversion (Loc,\n                          Subtype_Mark =>\n-                           New_Occurrence_Of (Etype (Return_Obj_Id), Loc),\n+                           New_Occurrence_Of (Etype (Ret_Obj_Id), Loc),\n                          Expression   =>\n                            Relocate_Node (Expression (Init_Assignment))));\n                   end if;\n@@ -4464,8 +4459,8 @@ package body Exp_Ch6 is\n                   --  the different forms of allocation (this is true for\n                   --  unconstrained and tagged result subtypes).\n \n-                  if Constr_Result\n-                    and then not Is_Tagged_Type (Underlying_Type (Result_Subt))\n+                  if Is_Constrained (Ret_Typ)\n+                    and then not Is_Tagged_Type (Underlying_Type (Ret_Typ))\n                   then\n                      Insert_After (Ret_Obj_Decl, Init_Assignment);\n                   end if;\n@@ -4490,11 +4485,11 @@ package body Exp_Ch6 is\n                --  called in dispatching contexts and must be handled similarly\n                --  to functions with a class-wide result.\n \n-               if not Constr_Result\n-                 or else Is_Tagged_Type (Underlying_Type (Result_Subt))\n+               if not Is_Constrained (Ret_Typ)\n+                 or else Is_Tagged_Type (Underlying_Type (Ret_Typ))\n                then\n                   Obj_Alloc_Formal :=\n-                    Build_In_Place_Formal (Par_Func, BIP_Alloc_Form);\n+                    Build_In_Place_Formal (Func_Id, BIP_Alloc_Form);\n \n                   declare\n                      Pool_Id        : constant Entity_Id :=\n@@ -4529,7 +4524,7 @@ package body Exp_Ch6 is\n                            Make_Access_To_Object_Definition (Loc,\n                              All_Present        => True,\n                              Subtype_Indication =>\n-                               New_Occurrence_Of (Return_Obj_Typ, Loc)));\n+                               New_Occurrence_Of (Ret_Obj_Typ, Loc)));\n \n                      Insert_Before (Ret_Obj_Decl, Ptr_Type_Decl);\n \n@@ -4553,7 +4548,7 @@ package body Exp_Ch6 is\n                      --  global heap. If there's an initialization expression,\n                      --  then create these as initialized allocators.\n \n-                     if Present (Return_Obj_Expr)\n+                     if Present (Ret_Obj_Expr)\n                        and then not No_Initialization (Ret_Obj_Decl)\n                      then\n                         --  Always use the type of the expression for the\n@@ -4570,27 +4565,26 @@ package body Exp_Ch6 is\n                               Make_Qualified_Expression (Loc,\n                                 Subtype_Mark =>\n                                   New_Occurrence_Of\n-                                    (Etype (Return_Obj_Expr), Loc),\n-                                Expression   =>\n-                                  New_Copy_Tree (Return_Obj_Expr)));\n+                                    (Etype (Ret_Obj_Expr), Loc),\n+                                Expression   => New_Copy_Tree (Ret_Obj_Expr)));\n \n                      else\n                         --  If the function returns a class-wide type we cannot\n                         --  use the return type for the allocator. Instead we\n                         --  use the type of the expression, which must be an\n                         --  aggregate of a definite type.\n \n-                        if Is_Class_Wide_Type (Return_Obj_Typ) then\n+                        if Is_Class_Wide_Type (Ret_Obj_Typ) then\n                            Heap_Allocator :=\n                              Make_Allocator (Loc,\n                                Expression =>\n                                  New_Occurrence_Of\n-                                   (Etype (Return_Obj_Expr), Loc));\n+                                   (Etype (Ret_Obj_Expr), Loc));\n                         else\n                            Heap_Allocator :=\n                              Make_Allocator (Loc,\n                                Expression =>\n-                                 New_Occurrence_Of (Return_Obj_Typ, Loc));\n+                                 New_Occurrence_Of (Ret_Obj_Typ, Loc));\n                         end if;\n \n                         --  If the object requires default initialization then\n@@ -4622,7 +4616,7 @@ package body Exp_Ch6 is\n                               Make_Explicit_Dereference (Loc,\n                                 New_Occurrence_Of\n                                   (Build_In_Place_Formal\n-                                     (Par_Func, BIP_Storage_Pool), Loc)));\n+                                     (Func_Id, BIP_Storage_Pool), Loc)));\n                         Set_Storage_Pool (Pool_Allocator, Pool_Id);\n                         Set_Procedure_To_Call\n                           (Pool_Allocator, RTE (RE_Allocate_Any));\n@@ -4675,10 +4669,10 @@ package body Exp_Ch6 is\n                      --  statement, past the point where these flags are\n                      --  normally set.\n \n-                     Set_Sec_Stack_Needed_For_Return (Par_Func);\n+                     Set_Sec_Stack_Needed_For_Return (Func_Id);\n                      Set_Sec_Stack_Needed_For_Return\n                        (Return_Statement_Entity (N));\n-                     Set_Uses_Sec_Stack (Par_Func);\n+                     Set_Uses_Sec_Stack (Func_Id);\n                      Set_Uses_Sec_Stack (Return_Statement_Entity (N));\n \n                      --  Create an if statement to test the BIP_Alloc_Form\n@@ -4719,7 +4713,7 @@ package body Exp_Ch6 is\n                                  Subtype_Mark =>\n                                    New_Occurrence_Of (Ref_Type, Loc),\n                                  Expression   =>\n-                                   New_Occurrence_Of (Object_Access, Loc)))),\n+                                   New_Occurrence_Of (Obj_Acc_Formal, Loc)))),\n \n                          Elsif_Parts => New_List (\n                            Make_Elsif_Part (Loc,\n@@ -4752,17 +4746,17 @@ package body Exp_Ch6 is\n                                Build_Heap_Allocator\n                                  (Temp_Id    => Alloc_Obj_Id,\n                                   Temp_Typ   => Ref_Type,\n-                                  Func_Id    => Par_Func,\n-                                  Ret_Typ    => Return_Obj_Typ,\n+                                  Func_Id    => Func_Id,\n+                                  Ret_Typ    => Ret_Obj_Typ,\n                                   Alloc_Expr => Heap_Allocator)))),\n \n                          Else_Statements => New_List (\n                            Pool_Decl,\n                            Build_Heap_Allocator\n                              (Temp_Id    => Alloc_Obj_Id,\n                               Temp_Typ   => Ref_Type,\n-                              Func_Id    => Par_Func,\n-                              Ret_Typ    => Return_Obj_Typ,\n+                              Func_Id    => Func_Id,\n+                              Ret_Typ    => Ret_Obj_Typ,\n                               Alloc_Expr => Pool_Allocator)));\n \n                      --  If a separate initialization assignment was created\n@@ -4778,8 +4772,7 @@ package body Exp_Ch6 is\n                           Make_Explicit_Dereference (Loc,\n                             Prefix => New_Occurrence_Of (Alloc_Obj_Id, Loc)));\n \n-                        Set_Etype\n-                          (Name (Init_Assignment), Etype (Return_Obj_Id));\n+                        Set_Etype (Name (Init_Assignment), Etype (Ret_Obj_Id));\n \n                         Append_To\n                           (Then_Statements (Alloc_If_Stmt), Init_Assignment);\n@@ -4790,7 +4783,7 @@ package body Exp_Ch6 is\n                      --  Remember the local access object for use in the\n                      --  dereference of the renaming created below.\n \n-                     Object_Access := Alloc_Obj_Id;\n+                     Obj_Acc_Formal := Alloc_Obj_Id;\n                   end;\n                end if;\n \n@@ -4800,17 +4793,16 @@ package body Exp_Ch6 is\n \n                Obj_Acc_Deref :=\n                  Make_Explicit_Dereference (Loc,\n-                   Prefix => New_Occurrence_Of (Object_Access, Loc));\n+                   Prefix => New_Occurrence_Of (Obj_Acc_Formal, Loc));\n \n                Rewrite (Ret_Obj_Decl,\n                  Make_Object_Renaming_Declaration (Loc,\n-                   Defining_Identifier => Return_Obj_Id,\n+                   Defining_Identifier => Ret_Obj_Id,\n                    Access_Definition   => Empty,\n-                   Subtype_Mark        =>\n-                     New_Occurrence_Of (Return_Obj_Typ, Loc),\n+                   Subtype_Mark        => New_Occurrence_Of (Ret_Obj_Typ, Loc),\n                    Name                => Obj_Acc_Deref));\n \n-               Set_Renamed_Object (Return_Obj_Id, Obj_Acc_Deref);\n+               Set_Renamed_Object (Ret_Obj_Id, Obj_Acc_Deref);\n             end;\n          end if;\n \n@@ -8789,14 +8781,14 @@ package body Exp_Ch6 is\n    ----------------------------------------------------\n \n    procedure Make_Build_In_Place_Call_In_Object_Declaration\n-     (Object_Decl   : Node_Id;\n+     (Obj_Decl      : Node_Id;\n       Function_Call : Node_Id)\n    is\n-      Loc             : Source_Ptr;\n-      Obj_Def_Id      : constant Entity_Id :=\n-                          Defining_Identifier (Object_Decl);\n-      Enclosing_Func  : constant Entity_Id :=\n-                          Enclosing_Subprogram (Obj_Def_Id);\n+      Obj_Def_Id : constant Entity_Id  := Defining_Identifier (Obj_Decl);\n+      Encl_Func  : constant Entity_Id  := Enclosing_Subprogram (Obj_Def_Id);\n+      Loc        : constant Source_Ptr := Sloc (Function_Call);\n+      Obj_Loc    : constant Source_Ptr := Sloc (Obj_Decl);\n+\n       Call_Deref      : Node_Id;\n       Caller_Object   : Node_Id;\n       Def_Id          : Entity_Id;\n@@ -8835,8 +8827,6 @@ package body Exp_Ch6 is\n \n       Set_Is_Expanded_Build_In_Place_Call (Func_Call);\n \n-      Loc := Sloc (Function_Call);\n-\n       if Is_Entity_Name (Name (Func_Call)) then\n          Function_Id := Entity (Name (Func_Call));\n \n@@ -8878,11 +8868,11 @@ package body Exp_Ch6 is\n       --  cause freezing.\n \n       if Definite\n-        and then not Is_Return_Object (Defining_Identifier (Object_Decl))\n+        and then not Is_Return_Object (Defining_Identifier (Obj_Decl))\n       then\n-         Insert_After_And_Analyze (Object_Decl, Ptr_Typ_Decl);\n+         Insert_After_And_Analyze (Obj_Decl, Ptr_Typ_Decl);\n       else\n-         Insert_Action (Object_Decl, Ptr_Typ_Decl);\n+         Insert_Action (Obj_Decl, Ptr_Typ_Decl);\n       end if;\n \n       --  Force immediate freezing of Ptr_Typ because Res_Decl will be\n@@ -8907,18 +8897,18 @@ package body Exp_Ch6 is\n       --  aggregate return object, when the call result should really be\n       --  directly built in place in the aggregate and not in a temporary. ???)\n \n-      if Is_Return_Object (Defining_Identifier (Object_Decl)) then\n+      if Is_Return_Object (Defining_Identifier (Obj_Decl)) then\n          Pass_Caller_Acc := True;\n \n          --  When the enclosing function has a BIP_Alloc_Form formal then we\n          --  pass it along to the callee (such as when the enclosing function\n          --  has an unconstrained or tagged result type).\n \n-         if Needs_BIP_Alloc_Form (Enclosing_Func) then\n+         if Needs_BIP_Alloc_Form (Encl_Func) then\n             if RTE_Available (RE_Root_Storage_Pool_Ptr) then\n                Pool_Actual :=\n-                 New_Occurrence_Of (Build_In_Place_Formal\n-                   (Enclosing_Func, BIP_Storage_Pool), Loc);\n+                 New_Occurrence_Of\n+                   (Build_In_Place_Formal (Encl_Func, BIP_Storage_Pool), Loc);\n \n             --  The build-in-place pool formal is not built on e.g. ZFP\n \n@@ -8931,8 +8921,7 @@ package body Exp_Ch6 is\n                Function_Id    => Function_Id,\n                Alloc_Form_Exp =>\n                  New_Occurrence_Of\n-                   (Build_In_Place_Formal\n-                     (Enclosing_Func, BIP_Alloc_Form), Loc),\n+                   (Build_In_Place_Formal (Encl_Func, BIP_Alloc_Form), Loc),\n                Pool_Actual    => Pool_Actual);\n \n          --  Otherwise, if enclosing function has a definite result subtype,\n@@ -8943,27 +8932,27 @@ package body Exp_Ch6 is\n               (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n          end if;\n \n-         if Needs_BIP_Finalization_Master (Enclosing_Func) then\n+         if Needs_BIP_Finalization_Master (Encl_Func) then\n             Fmaster_Actual :=\n               New_Occurrence_Of\n                 (Build_In_Place_Formal\n-                   (Enclosing_Func, BIP_Finalization_Master), Loc);\n+                   (Encl_Func, BIP_Finalization_Master), Loc);\n          end if;\n \n          --  Retrieve the BIPacc formal from the enclosing function and convert\n          --  it to the access type of the callee's BIP_Object_Access formal.\n \n          Caller_Object :=\n-            Make_Unchecked_Type_Conversion (Loc,\n-              Subtype_Mark =>\n-                New_Occurrence_Of\n-                  (Etype\n-                     (Build_In_Place_Formal (Function_Id, BIP_Object_Access)),\n-                   Loc),\n-              Expression   =>\n-                New_Occurrence_Of\n-                  (Build_In_Place_Formal (Enclosing_Func, BIP_Object_Access),\n-                   Loc));\n+           Make_Unchecked_Type_Conversion (Loc,\n+             Subtype_Mark =>\n+               New_Occurrence_Of\n+                 (Etype\n+                    (Build_In_Place_Formal (Function_Id, BIP_Object_Access)),\n+                  Loc),\n+             Expression   =>\n+               New_Occurrence_Of\n+                 (Build_In_Place_Formal (Encl_Func, BIP_Object_Access),\n+                  Loc));\n \n       --  In the definite case, add an implicit actual to the function call\n       --  that provides access to the declared object. An unchecked conversion\n@@ -8990,7 +8979,7 @@ package body Exp_Ch6 is\n       --  the secondary stack is destroyed after each library unload. This is\n       --  a hybrid mechanism where a stack-allocated object lives on the heap.\n \n-      elsif Is_Library_Level_Entity (Defining_Identifier (Object_Decl))\n+      elsif Is_Library_Level_Entity (Defining_Identifier (Obj_Decl))\n         and then not Restriction_Active (No_Implicit_Heap_Allocations)\n       then\n          Add_Unconstrained_Actuals_To_Build_In_Place_Call\n@@ -9024,7 +9013,7 @@ package body Exp_Ch6 is\n            (Func_Call, Function_Id, Alloc_Form => Secondary_Stack);\n          Caller_Object := Empty;\n \n-         Establish_Transient_Scope (Object_Decl, Sec_Stack => True);\n+         Establish_Transient_Scope (Obj_Decl, Sec_Stack => True);\n       end if;\n \n       --  Pass along any finalization master actual, which is needed in the\n@@ -9036,7 +9025,7 @@ package body Exp_Ch6 is\n          Func_Id    => Function_Id,\n          Master_Exp => Fmaster_Actual);\n \n-      if Nkind (Parent (Object_Decl)) = N_Extended_Return_Statement\n+      if Nkind (Parent (Obj_Decl)) = N_Extended_Return_Statement\n         and then Has_Task (Result_Subt)\n       then\n          --  Here we're passing along the master that was passed in to this\n@@ -9045,8 +9034,8 @@ package body Exp_Ch6 is\n          Add_Task_Actuals_To_Build_In_Place_Call\n            (Func_Call, Function_Id,\n             Master_Actual =>\n-              New_Occurrence_Of (Build_In_Place_Formal\n-                (Enclosing_Func, BIP_Task_Master), Loc));\n+              New_Occurrence_Of\n+                (Build_In_Place_Formal (Encl_Func, BIP_Task_Master), Loc));\n \n       else\n          Add_Task_Actuals_To_Build_In_Place_Call\n@@ -9079,7 +9068,7 @@ package body Exp_Ch6 is\n       --  the object as having no initialization.\n \n       if Definite\n-        and then not Is_Return_Object (Defining_Identifier (Object_Decl))\n+        and then not Is_Return_Object (Defining_Identifier (Obj_Decl))\n       then\n          --  The related object declaration is encased in a transient block\n          --  because the build-in-place function call contains at least one\n@@ -9093,14 +9082,12 @@ package body Exp_Ch6 is\n          --  which prompted the generation of the transient block. To resolve\n          --  this scenario, store the build-in-place call.\n \n-         if Scope_Is_Transient\n-           and then Node_To_Be_Wrapped = Object_Decl\n-         then\n+         if Scope_Is_Transient and then Node_To_Be_Wrapped = Obj_Decl then\n             Set_BIP_Initialization_Call (Obj_Def_Id, Res_Decl);\n          end if;\n \n-         Set_Expression (Object_Decl, Empty);\n-         Set_No_Initialization (Object_Decl);\n+         Set_Expression (Obj_Decl, Empty);\n+         Set_No_Initialization (Obj_Decl);\n \n       --  In case of an indefinite result subtype, or if the call is the\n       --  return expression of an enclosing BIP function, rewrite the object\n@@ -9111,20 +9098,28 @@ package body Exp_Ch6 is\n \n       else\n          Call_Deref :=\n-           Make_Explicit_Dereference (Loc,\n-             Prefix => New_Occurrence_Of (Def_Id, Loc));\n-\n-         Loc := Sloc (Object_Decl);\n-         Rewrite (Object_Decl,\n-           Make_Object_Renaming_Declaration (Loc,\n-             Defining_Identifier => Make_Temporary (Loc, 'D'),\n-             Access_Definition   => Empty,\n-             Subtype_Mark        => New_Occurrence_Of (Result_Subt, Loc),\n+           Make_Explicit_Dereference (Obj_Loc,\n+             Prefix => New_Occurrence_Of (Def_Id, Obj_Loc));\n+\n+         Rewrite (Obj_Decl,\n+           Make_Object_Renaming_Declaration (Obj_Loc,\n+             Defining_Identifier => Make_Temporary (Obj_Loc, 'D'),\n+             Subtype_Mark        => New_Occurrence_Of (Result_Subt, Obj_Loc),\n              Name                => Call_Deref));\n \n-         Set_Renamed_Object (Defining_Identifier (Object_Decl), Call_Deref);\n+         Set_Renamed_Object (Defining_Identifier (Obj_Decl), Call_Deref);\n+\n+         --  If the original entity comes from source, then mark the new\n+         --  entity as needing debug information, even though it's defined\n+         --  by a generated renaming that does not come from source, so that\n+         --  the Materialize_Entity flag will be set on the entity when\n+         --  Debug_Renaming_Declaration is called during analysis.\n+\n+         if Comes_From_Source (Obj_Def_Id) then\n+            Set_Debug_Info_Needed (Defining_Identifier (Obj_Decl));\n+         end if;\n \n-         Analyze (Object_Decl);\n+         Analyze (Obj_Decl);\n \n          --  Replace the internal identifier of the renaming declaration's\n          --  entity with identifier of the original object entity. We also have\n@@ -9138,31 +9133,27 @@ package body Exp_Ch6 is\n          --  corrupted. Finally, the homonym chain must be preserved as well.\n \n          declare\n-            Renaming_Def_Id  : constant Entity_Id :=\n-                                 Defining_Identifier (Object_Decl);\n-            Next_Entity_Temp : constant Entity_Id :=\n-                                 Next_Entity (Renaming_Def_Id);\n+            Ren_Id  : constant Entity_Id := Defining_Entity (Obj_Decl);\n+            Next_Id : constant Entity_Id := Next_Entity (Ren_Id);\n+\n          begin\n-            Set_Chars (Renaming_Def_Id, Chars (Obj_Def_Id));\n+            Set_Chars (Ren_Id, Chars (Obj_Def_Id));\n \n             --  Swap next entity links in preparation for exchanging entities\n \n-            Set_Next_Entity (Renaming_Def_Id, Next_Entity (Obj_Def_Id));\n-            Set_Next_Entity (Obj_Def_Id, Next_Entity_Temp);\n-            Set_Homonym     (Renaming_Def_Id, Homonym (Obj_Def_Id));\n+            Set_Next_Entity (Ren_Id, Next_Entity (Obj_Def_Id));\n+            Set_Next_Entity (Obj_Def_Id, Next_Id);\n+            Set_Homonym     (Ren_Id, Homonym (Obj_Def_Id));\n \n-            Exchange_Entities (Renaming_Def_Id, Obj_Def_Id);\n+            Exchange_Entities (Ren_Id, Obj_Def_Id);\n \n             --  Preserve source indication of original declaration, so that\n             --  xref information is properly generated for the right entity.\n \n-            Preserve_Comes_From_Source\n-              (Object_Decl, Original_Node (Object_Decl));\n-\n-            Preserve_Comes_From_Source\n-              (Obj_Def_Id, Original_Node (Object_Decl));\n+            Preserve_Comes_From_Source (Obj_Decl, Original_Node (Obj_Decl));\n+            Preserve_Comes_From_Source (Obj_Def_Id, Original_Node (Obj_Decl));\n \n-            Set_Comes_From_Source (Renaming_Def_Id, False);\n+            Set_Comes_From_Source (Ren_Id, False);\n          end;\n       end if;\n \n@@ -9174,8 +9165,8 @@ package body Exp_Ch6 is\n       --  improve this treatment when build-in-place functions with class-wide\n       --  results are implemented. ???\n \n-      if Is_Class_Wide_Type (Etype (Defining_Identifier (Object_Decl))) then\n-         Set_Etype (Defining_Identifier (Object_Decl), Result_Subt);\n+      if Is_Class_Wide_Type (Etype (Defining_Identifier (Obj_Decl))) then\n+         Set_Etype (Defining_Identifier (Obj_Decl), Result_Subt);\n       end if;\n    end Make_Build_In_Place_Call_In_Object_Declaration;\n "}, {"sha": "1cc993f509ec4f9ac62d92e271bfa4206ba9844e", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f2c03ceabe47ad4fc3162efb328508d74e78a6/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f2c03ceabe47ad4fc3162efb328508d74e78a6/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=e5f2c03ceabe47ad4fc3162efb328508d74e78a6", "patch": "@@ -178,7 +178,7 @@ package Exp_Ch6 is\n    --  call.\n \n    procedure Make_Build_In_Place_Call_In_Object_Declaration\n-     (Object_Decl   : Node_Id;\n+     (Obj_Decl      : Node_Id;\n       Function_Call : Node_Id);\n    --  Ada 2005 (AI-318-02): Handle a call to a build-in-place function that\n    --  occurs as the expression initializing an object declaration by"}, {"sha": "fa00f620506f245f87dec31c8ded4353e4d68c66", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f2c03ceabe47ad4fc3162efb328508d74e78a6/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f2c03ceabe47ad4fc3162efb328508d74e78a6/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=e5f2c03ceabe47ad4fc3162efb328508d74e78a6", "patch": "@@ -25211,6 +25211,7 @@ package body Sem_Prag is\n             Root_Typ := Etype (F);\n \n             if Is_Access_Type (Etype (F)) then\n+               Root_Typ := Designated_Type (Root_Typ);\n                New_Typ :=\n                  Make_Defining_Identifier (Loc,\n                    Chars =>"}, {"sha": "a6eb50c52b79b2ac65d716bb37b45144e5424d31", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f2c03ceabe47ad4fc3162efb328508d74e78a6/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f2c03ceabe47ad4fc3162efb328508d74e78a6/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=e5f2c03ceabe47ad4fc3162efb328508d74e78a6", "patch": "@@ -16961,6 +16961,106 @@ package body Sem_Util is\n       end if;\n    end Remove_Homonym;\n \n+   ------------------------------\n+   -- Remove_Overloaded_Entity --\n+   ------------------------------\n+\n+   procedure Remove_Overloaded_Entity (Id : Entity_Id) is\n+      procedure Remove_Primitive_Of (Typ : Entity_Id);\n+      --  Remove primitive subprogram Id from the list of primitives that\n+      --  belong to type Typ.\n+\n+      -------------------------\n+      -- Remove_Primitive_Of --\n+      -------------------------\n+\n+      procedure Remove_Primitive_Of (Typ : Entity_Id) is\n+         Prims : Elist_Id;\n+\n+      begin\n+         if Is_Tagged_Type (Typ) then\n+            Prims := Direct_Primitive_Operations (Typ);\n+\n+            if Present (Prims) then\n+               Remove (Prims, Id);\n+            end if;\n+         end if;\n+      end Remove_Primitive_Of;\n+\n+      --  Local variables\n+\n+      Scop    : constant Entity_Id := Scope (Id);\n+      Formal  : Entity_Id;\n+      Prev_Id : Entity_Id;\n+\n+   --  Start of processing for Remove_Overloaded_Entity\n+\n+   begin\n+      --  Remove the entity from the homonym chain. When the entity is the\n+      --  head of the chain, associate the entry in the name table with its\n+      --  homonym effectively making it the new head of the chain.\n+\n+      if Current_Entity (Id) = Id then\n+         Set_Name_Entity_Id (Chars (Id), Homonym (Id));\n+\n+      --  Otherwise link the previous and next homonyms\n+\n+      else\n+         Prev_Id := Current_Entity (Id);\n+         while Present (Prev_Id) and then Homonym (Prev_Id) /= Id loop\n+            Prev_Id := Homonym (Prev_Id);\n+         end loop;\n+\n+         Set_Homonym (Prev_Id, Homonym (Id));\n+      end if;\n+\n+      --  Remove the entity from the scope entity chain. When the entity is\n+      --  the head of the chain, set the next entity as the new head of the\n+      --  chain.\n+\n+      if First_Entity (Scop) = Id then\n+         Prev_Id := Empty;\n+         Set_First_Entity (Scop, Next_Entity (Id));\n+\n+      --  Otherwise the entity is either in the middle of the chain or it acts\n+      --  as its tail. Traverse and link the previous and next entities.\n+\n+      else\n+         Prev_Id := First_Entity (Scop);\n+         while Present (Prev_Id) and then Next_Entity (Prev_Id) /= Id loop\n+            Next_Entity (Prev_Id);\n+         end loop;\n+\n+         Set_Next_Entity (Prev_Id, Next_Entity (Id));\n+      end if;\n+\n+      --  Handle the case where the entity acts as the tail of the scope entity\n+      --  chain.\n+\n+      if Last_Entity (Scop) = Id then\n+         Set_Last_Entity (Scop, Prev_Id);\n+      end if;\n+\n+      --  The entity denotes a primitive subprogram. Remove it from the list of\n+      --  primitives of the associated controlling type.\n+\n+      if Ekind_In (Id, E_Function, E_Procedure) and then Is_Primitive (Id) then\n+         Formal := First_Formal (Id);\n+         while Present (Formal) loop\n+            if Is_Controlling_Formal (Formal) then\n+               Remove_Primitive_Of (Etype (Formal));\n+               exit;\n+            end if;\n+\n+            Next_Formal (Formal);\n+         end loop;\n+\n+         if Ekind (Id) = E_Function and then Has_Controlling_Result (Id) then\n+            Remove_Primitive_Of (Etype (Id));\n+         end if;\n+      end if;\n+   end Remove_Overloaded_Entity;\n+\n    ---------------------\n    -- Rep_To_Pos_Flag --\n    ---------------------"}, {"sha": "c0bf234ce70fe7e7373ec42e7444b6fddd46b84d", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f2c03ceabe47ad4fc3162efb328508d74e78a6/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f2c03ceabe47ad4fc3162efb328508d74e78a6/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=e5f2c03ceabe47ad4fc3162efb328508d74e78a6", "patch": "@@ -1781,12 +1781,6 @@ package Sem_Util is\n    --  convenience, qualified expressions applied to object names are also\n    --  allowed as actuals for this function.\n \n-   function Original_Corresponding_Operation (S : Entity_Id) return Entity_Id;\n-   --  [Ada 2012: AI05-0125-1]: If S is an inherited dispatching primitive S2,\n-   --  or overrides an inherited dispatching primitive S2, the original\n-   --  corresponding operation of S is the original corresponding operation of\n-   --  S2. Otherwise, it is S itself.\n-\n    function Original_Aspect_Pragma_Name (N : Node_Id) return Name_Id;\n    --  Retrieve the name of aspect or pragma N taking into account a possible\n    --  rewrite and whether the pragma is generated from an aspect as the names\n@@ -1799,6 +1793,12 @@ package Sem_Util is\n    --    Type_Invariant       -> Name_uType_Invariant\n    --    Type_Invariant'Class -> Name_uType_Invariant\n \n+   function Original_Corresponding_Operation (S : Entity_Id) return Entity_Id;\n+   --  [Ada 2012: AI05-0125-1]: If S is an inherited dispatching primitive S2,\n+   --  or overrides an inherited dispatching primitive S2, the original\n+   --  corresponding operation of S is the original corresponding operation of\n+   --  S2. Otherwise, it is S itself.\n+\n    function Policy_In_Effect (Policy : Name_Id) return Name_Id;\n    --  Given a policy, return the policy identifier associated with it. If no\n    --  such policy is in effect, the value returned is No_Name.\n@@ -1845,6 +1845,12 @@ package Sem_Util is\n    procedure Remove_Homonym (E : Entity_Id);\n    --  Removes E from the homonym chain\n \n+   procedure Remove_Overloaded_Entity (Id : Entity_Id);\n+   --  Remove arbitrary entity Id from the homonym chain, the scope chain and\n+   --  the primitive operations list of the associated controlling type. NOTE:\n+   --  the removal performed by this routine does not affect the visibility of\n+   --  existing homonyms.\n+\n    function Rep_To_Pos_Flag (E : Entity_Id; Loc : Source_Ptr) return Node_Id;\n    --  This is used to construct the second argument in a call to Rep_To_Pos\n    --  which is Standard_True if range checks are enabled (E is an entity to"}]}