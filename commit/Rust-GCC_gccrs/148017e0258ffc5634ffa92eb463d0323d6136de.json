{"sha": "148017e0258ffc5634ffa92eb463d0323d6136de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ4MDE3ZTAyNThmZmM1NjM0ZmZhOTJlYjQ2M2QwMzIzZDYxMzZkZQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-05-05T23:15:04Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-05-05T23:15:04Z"}, "message": "* doc/cni.sgml:  Document RawData.\n\nFrom-SVN: r26791", "tree": {"sha": "c95a65e2ee141918dd3fbe0f1a33b06465bee2ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c95a65e2ee141918dd3fbe0f1a33b06465bee2ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/148017e0258ffc5634ffa92eb463d0323d6136de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/148017e0258ffc5634ffa92eb463d0323d6136de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/148017e0258ffc5634ffa92eb463d0323d6136de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/148017e0258ffc5634ffa92eb463d0323d6136de/comments", "author": null, "committer": null, "parents": [{"sha": "cd9643f75b2f7bc41642bd988532a03ba923c3f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd9643f75b2f7bc41642bd988532a03ba923c3f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd9643f75b2f7bc41642bd988532a03ba923c3f4"}], "stats": {"total": 92, "additions": 92, "deletions": 0}, "files": [{"sha": "fac01db7512f32cb74528431c804f33770432e7f", "filename": "libjava/doc/cni.sgml", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/148017e0258ffc5634ffa92eb463d0323d6136de/libjava%2Fdoc%2Fcni.sgml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/148017e0258ffc5634ffa92eb463d0323d6136de/libjava%2Fdoc%2Fcni.sgml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdoc%2Fcni.sgml?ref=148017e0258ffc5634ffa92eb463d0323d6136de", "patch": "@@ -369,6 +369,98 @@ to private C++ fields and methods, but other fields and methods\n are mapped to public fields and methods.\n </para>\n </sect2>\n+<sect2><title>Non-Java fields</title>\n+<para>\n+When you write a Java wrapper around an existing library, that library\n+will often allocate and manage its own data structures.  These are\n+<quote>objects</quote> that are not Java <literal>Object</literal>s;\n+instead they are usually C <literal>struct</literal> instances.\n+Typically, you will write a Java class, and use native CNI methods\n+which call functions in the C library.  The problem is how to get\n+from the Java wrapper object to the C <literal>struct</literal> instances.\n+The obvious solution is to add a field to the Java object that\n+points to the C structure.  The problem is that there is no Java\n+type that we can give to this field.</para>\n+<para>The GCJ solution is to define a special dummy class\n+<literal>gnu.gcj.RawData</literal>.  This can be used as the type for fields,\n+parameters, array elements, or local variables in Java code.\n+It means that the field or variable is a pointer to a non-Java object.\n+Nothing else is known about it, so it corresponds to a\n+<literal>(void*)</literal> declaration is C or C++ code.</para>\n+<para>\n+The garbage collector will ignore a field that has type\n+<literal>gnu.gcj.RawData</literal>.  You are responsible for\n+freeing the C data structure when you are done with it, and\n+performing any necessary cleanups.  In most cases, you should\n+use a <literal>finalize</literal> method, and have it call\n+the library's cleanup routine.  Also, the C data structure\n+should not contain a pointer back to the Java object, since\n+the garbage collector will not know about the pointer.\n+If you need to save a pointer to a Java object inside some\n+non-Java data structure, you first need to <quote>pin</quote>\n+or <quote>globalize</quote> the pointer;  there is no CNI function\n+to do this yet.\n+(From the point of view of the\n+implementation, a <literal>gnu.gcj.RawData</literal> value is\n+the same as an integer that has the same size as a pointer.)</para>\n+<para>\n+Here is an example where we create a Java wrapper around C stdio:\n+<programlisting>\n+import gnu.gcj.RawData;\n+\n+public class StdioFile\n+{\n+  private RawData file;\n+  public StdioFile (RawData file) { this.file = file; }\n+  public StdioFile (String name, String mode)\n+    throws FileNotFoundException\n+  { init(name, mode); }\n+  private native void init (String name, String mode)\n+    throws FileNotFoundException;\n+  public native int getc();\n+  public native int close();\n+  protected native void finalize();\n+}\n+</programlisting>\n+This is the CNI implementation:\n+<programlisting>\n+jint\n+StdioFile::getc()\n+{\n+  return getc((FILE*) file);\n+}\n+\n+jint\n+StdioFile::close()\n+{\n+  return fclose((FILE*) file);\n+}\n+\n+void\n+StdioFile::init(jstring name, jstring mode)\n+{\n+  int cname_len = JvGetStringUTFLength (name);\n+  int cmode_len = JvGetStringUTFLength (mode);\n+  char cname[cname_len + 1];\n+  char cmode[cmode_len + 1];\n+  JvGetStringUTFRegion (name, 0, name->length(), cname);\n+  JvGetStringUTFRegion (mode, 0, mode->length(), cmode);\n+  cname[cname_len] = '\\0';\n+  cmode[cmode_len] = '\\0';\n+  file = (gnu::gcj::RawData*) fopen(cname, cmode);\n+  if (file == NULL)\n+    JvThrow(new java::lang::FileNotFoundException(name));\n+}\n+\n+void\n+StdioFile::finalize()\n+{\n+  fclose((FILE*) file);\n+}\n+</programlisting>\n+\n+</sect2>\n+\n </sect1>\n \n <sect1><title>Arrays</title>"}]}