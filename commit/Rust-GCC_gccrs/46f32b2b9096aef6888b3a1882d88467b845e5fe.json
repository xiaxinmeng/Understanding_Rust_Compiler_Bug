{"sha": "46f32b2b9096aef6888b3a1882d88467b845e5fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZmMzJiMmI5MDk2YWVmNjg4OGIzYTE4ODJkODg0NjdiODQ1ZTVmZQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-11-16T19:43:53Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-11-16T19:43:53Z"}, "message": "[multiple changes]\n\n2005-11-15  Tom Tromey  <tromey@redhat.com>\n\n       classpath/23890:\n       * java/util/Calendar.java (equals): Include other calendar\n       attributes.\n       (hashCode): Updated.\n       * java/util/GregorianCalendar.java (hashCode): New method.\n       (equals): Use super.equals().\n\n2005-11-15  Sven de Marothy  <sven@physto.se>\n\n       * java/util/Calendar (setTimeInMillis): Recompute time fields.\n\n2005-11-15  Mark Wielaard  <mark@klomp.org>\n\n       * java/util/SimpleTimeZone.java: Removed, fully merged now.\n       * java/util/Date.java: Likewise.\n       * sources.am: Regenerated.\n       * Makefile.in: Regenerated.\n\n2005-11-15  David Gilbert  <david.gilbert@object-refinery.com>\n\n       * java/util/Calendar.java: fixed minor problems in API docs,\n       * java/util/Date.java: likewise,\n       * java/util/ResourceBundle.java: likewise,\n       * java/util/SimpleTimeZone.java: likewise,\n\nFrom-SVN: r107094", "tree": {"sha": "67bb5a1de4af3deef7413170ad72219a4af856aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67bb5a1de4af3deef7413170ad72219a4af856aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46f32b2b9096aef6888b3a1882d88467b845e5fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46f32b2b9096aef6888b3a1882d88467b845e5fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46f32b2b9096aef6888b3a1882d88467b845e5fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46f32b2b9096aef6888b3a1882d88467b845e5fe/comments", "author": null, "committer": null, "parents": [{"sha": "ab156144da05dcb8df7fb55a10e937a17372f6a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab156144da05dcb8df7fb55a10e937a17372f6a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab156144da05dcb8df7fb55a10e937a17372f6a7"}], "stats": {"total": 2415, "additions": 66, "deletions": 2349}, "files": [{"sha": "a9716a97fc043a53dc5baad94aa4a1ad65d6a4d5", "filename": "libjava/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46f32b2b9096aef6888b3a1882d88467b845e5fe/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46f32b2b9096aef6888b3a1882d88467b845e5fe/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=46f32b2b9096aef6888b3a1882d88467b845e5fe", "patch": "@@ -1,3 +1,30 @@\n+2005-11-15  Tom Tromey  <tromey@redhat.com>\n+\n+\tclasspath/23890:\n+\t* java/util/Calendar.java (equals): Include other calendar\n+\tattributes.\n+\t(hashCode): Updated.\n+\t* java/util/GregorianCalendar.java (hashCode): New method.\n+\t(equals): Use super.equals().\n+\n+2005-11-15  Sven de Marothy  <sven@physto.se>\n+\n+\t* java/util/Calendar (setTimeInMillis): Recompute time fields.\n+\n+2005-11-15  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/util/SimpleTimeZone.java: Removed, fully merged now.\n+\t* java/util/Date.java: Likewise.\n+\t* sources.am: Regenerated.\n+\t* Makefile.in: Regenerated.\n+\n+2005-11-15  David Gilbert  <david.gilbert@object-refinery.com>\n+\n+\t* java/util/Calendar.java: fixed minor problems in API docs,\n+\t* java/util/Date.java: likewise,\n+\t* java/util/ResourceBundle.java: likewise,\n+\t* java/util/SimpleTimeZone.java: likewise,\n+\n 2005-11-15  Jeroen Frijters  <jeroen@frijters.net>\n \n \t* java/io/ObjectInputStream.java"}, {"sha": "8ebe1bbbb7f4c096a27aebbf7a2bd8545b2326c3", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46f32b2b9096aef6888b3a1882d88467b845e5fe/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46f32b2b9096aef6888b3a1882d88467b845e5fe/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=46f32b2b9096aef6888b3a1882d88467b845e5fe", "patch": "@@ -3236,7 +3236,7 @@ classpath/java/util/Collections.java \\\n classpath/java/util/Comparator.java \\\n classpath/java/util/ConcurrentModificationException.java \\\n java/util/Currency.java \\\n-java/util/Date.java \\\n+classpath/java/util/Date.java \\\n classpath/java/util/Dictionary.java \\\n classpath/java/util/EmptyStackException.java \\\n classpath/java/util/Enumeration.java \\\n@@ -3271,7 +3271,7 @@ classpath/java/util/Random.java \\\n classpath/java/util/RandomAccess.java \\\n java/util/ResourceBundle.java \\\n classpath/java/util/Set.java \\\n-java/util/SimpleTimeZone.java \\\n+classpath/java/util/SimpleTimeZone.java \\\n classpath/java/util/SortedMap.java \\\n classpath/java/util/SortedSet.java \\\n classpath/java/util/Stack.java \\"}, {"sha": "5559d8c53f41936501819cdee85710b389e71aee", "filename": "libjava/java/util/Calendar.java", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46f32b2b9096aef6888b3a1882d88467b845e5fe/libjava%2Fjava%2Futil%2FCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46f32b2b9096aef6888b3a1882d88467b845e5fe/libjava%2Fjava%2Futil%2FCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FCalendar.java?ref=46f32b2b9096aef6888b3a1882d88467b845e5fe", "patch": "@@ -629,6 +629,7 @@ public void setTimeInMillis(long time)\n     clear();\n     this.time = time;\n     isTimeSet = true;\n+    computeFields();\n   }\n \n   /**\n@@ -879,7 +880,6 @@ public final boolean isSet(int field)\n \n   /**\n    * Fills any unset fields in the time field list\n-   * @return true if the specified field has a value.\n    */\n   protected void complete()\n   {\n@@ -897,8 +897,19 @@ protected void complete()\n    */\n   public boolean equals(Object o)\n   {\n-    return (o instanceof Calendar)\n-           && getTimeInMillis() == ((Calendar) o).getTimeInMillis();\n+    if (! (o instanceof Calendar))\n+      return false;\n+    Calendar cal = (Calendar) o;\n+    if (getTimeInMillis() == ((Calendar) o).getTimeInMillis()\n+        && cal.getFirstDayOfWeek() == getFirstDayOfWeek()\n+        && cal.isLenient() == isLenient()\n+        && cal.getMinimalDaysInFirstWeek() == getMinimalDaysInFirstWeek())\n+      {\n+        TimeZone self = getTimeZone();\n+        TimeZone oth = cal.getTimeZone();\n+        return self == null ? oth == null : self.equals(oth);\n+      }\n+    return false;\n   }\n \n   /**\n@@ -909,7 +920,13 @@ public boolean equals(Object o)\n   public int hashCode()\n   {\n     long time = getTimeInMillis();\n-    return (int) ((time & 0xffffffffL) ^ (time >> 32));\n+    int val = (int) ((time & 0xffffffffL) ^ (time >> 32));\n+    val += (getFirstDayOfWeek() + (isLenient() ? 1230 : 1237)\n+            + getMinimalDaysInFirstWeek());\n+    TimeZone self = getTimeZone();\n+    if (self != null)\n+      val ^= self.hashCode();\n+    return val;\n   }\n \n   /**"}, {"sha": "8154ad1d158ba9f330ddf6117a24b3540401c19e", "filename": "libjava/java/util/Date.java", "status": "removed", "additions": 0, "deletions": 1261, "changes": 1261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab156144da05dcb8df7fb55a10e937a17372f6a7/libjava%2Fjava%2Futil%2FDate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab156144da05dcb8df7fb55a10e937a17372f6a7/libjava%2Fjava%2Futil%2FDate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FDate.java?ref=ab156144da05dcb8df7fb55a10e937a17372f6a7", "patch": "@@ -1,1261 +0,0 @@\n-/* java.util.Date\n-   Copyright (C) 1998, 1999, 2000, 2001, 2005  Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package java.util;\n-\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.Serializable;\n-\n-/**\n- * <p>\n- * This class represents a specific time in milliseconds since the epoch.\n- * The epoch is 1970, January 1 00:00:00.0000 UTC.  \n- * </p>\n- * <p>\n- * <code>Date</code> is intended to reflect universal time coordinate (UTC),\n- * but this depends on the underlying host environment.  Most operating systems \n- * don't handle the leap second, which occurs about once every year or\n- * so.  The leap second is added to the last minute of the day on either\n- * the 30th of June or the 31st of December, creating a minute 61 seconds\n- * in length.\n- * </p>\n- * <p>\n- * The representations of the date fields are as follows:\n- * <ul>\n- * <li>\n- * Years are specified as the difference between the year\n- * and 1900.  Thus, the final year used is equal to\n- * 1900 + y, where y is the input value.\n- * </li>\n- * <li>\n- * Months are represented using zero-based indexing,\n- * making 0 January and 11 December.\n- * </li>\n- * <li>\n- * Dates are represented with the usual values of\n- * 1 through to 31.\n- * </li>\n- * <li>\n- * Hours are represented in the twenty-four hour clock,\n- * with integer values from 0 to 23.  12am is 0, and\n- * 12pm is 12.\n- * </li>\n- * <li>\n- * Minutes are again as usual, with values from 0 to 59.\n- * </li>\n- * <li>\n- * Seconds are represented with the values 0 through to 61,\n- * with 60 and 61 being leap seconds (as per the ISO C standard).\n- * </li>\n- * </ul>\n- * </p>\n- * <p>\n- * Prior to JDK 1.1, this class was the sole class handling date and time\n- * related functionality.  However, this particular solution was not\n- * amenable to internationalization.  The new <code>Calendar</code>\n- * class should now be used to handle dates and times, with <code>Date</code>\n- * being used only for values in milliseconds since the epoch.  The\n- * <code>Calendar</code> class, and its concrete implementations, handle\n- * the interpretation of these values into minutes, hours, days, months\n- * and years.  The formatting and parsing of dates is left to the\n- * <code>DateFormat</code> class, which is able to handle the different\n- * types of date format which occur in different locales.\n- * </p>\n- *\n- * @see Calendar\n- * @see GregorianCalendar\n- * @see java.text.DateFormat\n- * @author Jochen Hoenicke\n- * @author Per Bothner (bothner@cygnus.com)\n- * @author Andrew John Hughes (gnu_andrew@member.fsf.org)\n- */\n-public class Date\n-    implements Cloneable, Comparable, Serializable\n-{\n-  /**\n-   * This is the serialization UID for this class\n-   * for compatability with Sun's JDK.\n-   */\n-  private static final long serialVersionUID = 7523967970034938905L;\n-\n-  /**\n-   * The time in milliseconds since the epoch.\n-   */\n-  private transient long time;\n-\n-  /**\n-   * An array of week names used to map names to integer values.\n-   */\n-  private static final String[] weekNames = { \"Sun\", \"Mon\", \"Tue\", \"Wed\",\n-\t\t\t\t\t      \"Thu\", \"Fri\", \"Sat\" };\n-  /**\n-   * An array of month names used to map names to integer values.\n-   */\n-  private static final String[] monthNames = { \"Jan\", \"Feb\", \"Mar\", \"Apr\",\n-\t\t\t\t\t       \"May\", \"Jun\", \"Jul\", \"Aug\",\n-\t\t\t\t\t       \"Sep\", \"Oct\", \"Nov\", \"Dec\" };\n-  /**\n-   * Creates a new Date Object representing the current time.\n-   */\n-  public Date()\n-  {\n-    time = System.currentTimeMillis();\n-  }\n-\n-  /**\n-   * Creates a new Date Object representing the given time.\n-   *\n-   * @param time the time in milliseconds since the epoch.\n-   */\n-  public Date(long time)\n-  {\n-    this.time = time;\n-  }\n-\n-  /**\n-   * Creates a new Date Object representing the given time.\n-   *\n-   * @deprecated use <code>new GregorianCalendar(year+1900, month,\n-   * day)</code> instead.\n-   * @param year the difference between the required year and 1900.\n-   * @param month the month as a value between 0 and 11.\n-   * @param day the day as a value between 0 and 31.\n-   */\n-  public Date(int year, int month, int day)\n-  {\n-    this(year, month, day, 0, 0, 0);\n-  }\n-\n-  /**\n-   * Creates a new Date Object representing the given time.\n-   *\n-   * @deprecated use <code>new GregorianCalendar(year+1900, month,\n-   * day, hour, min)</code> instead.\n-   * @param year the difference between the required year and 1900.\n-   * @param month the month as a value between 0 and 11.\n-   * @param day the day as a value between 0 and 31.\n-   * @param hour the hour as a value between 0 and 23, in 24-hour\n-   *        clock notation.\n-   * @param min the minute as a value between 0 and 59.\n-   */\n-  public Date(int year, int month, int day, int hour, int min)\n-  {\n-    this(year, month, day, hour, min, 0);\n-  }\n-\n-  /**\n-   * Creates a new Date Object representing the given time.\n-   *\n-   * @deprecated use <code>new GregorianCalendar(year+1900, month,\n-   * day, hour, min, sec)</code> instead. \n-   * @param year the difference between the required year and 1900.\n-   * @param month the month as a value between 0 and 11.\n-   * @param day the day as a value between 0 and 31.\n-   * @param hour the hour as a value between 0 and 23, in 24-hour\n-   *        clock notation.\n-   * @param min the minute as a value between 0 and 59.\n-   * @param sec the second as a value between 0 and 61 (with 60\n-   *        and 61 being leap seconds).\n-   */\n-  public Date(int year, int month, int day, int hour, int min, int sec)\n-  {\n-    GregorianCalendar cal =\n-\tnew GregorianCalendar(year + 1900, month, day, hour, min, sec);\n-    time = cal.getTimeInMillis();\n-  }\n-\n-  /**\n-   * Creates a new Date from the given string representation.  This\n-   * does the same as <code>new Date(Date.parse(s))</code>\n-   * @see #parse\n-   * @deprecated use <code>java.text.DateFormat.parse(s)</code> instead.  \n-   */\n-  public Date(String s)\n-  {\n-    time = parse(s);\n-  }\n-\n-  /**\n-   * Returns a copy of this <code>Date</code> object.\n-   *\n-   * @return a copy, or null if the object couldn't be\n-   *         cloned.\n-   * @see Object#clone()\n-   */\n-  public Object clone()\n-  {\n-    try\n-      {\n-\treturn super.clone();\n-      }\n-    catch (CloneNotSupportedException ex)\n-      {\n-\treturn null;\n-      }\n-  }\n-\n-  /**\n-   * Returns the number of milliseconds since the epoch\n-   * specified by the given arguments.  The arguments are\n-   * interpreted relative to UTC rather than the local\n-   * time zone.\n-   *\n-   * @deprecated Use <code>Calendar</code> with a UTC\n-   *             <code>TimeZone</code> instead.\n-   * @param year the difference between the required year and 1900.\n-   * @param month the month as a value between 0 and 11.\n-   * @param day the day as a value between 0 and 31.\n-   * @param hour the hour as a value between 0 and 23, in 24-hour\n-   *        clock notation.\n-   * @param min the minute as a value between 0 and 59.\n-   * @param sec the second as a value between 0 and 61 (with 60\n-   *        and 61 being leap seconds).\n-   * @return the time in milliseconds since the epoch.\n-   */\n-  public static long UTC(int year, int month, int date,\n-\t\t\t int hrs, int min, int sec)\n-  {\n-    GregorianCalendar cal =\n-      new GregorianCalendar(year + 1900, month, date, hrs, min, sec);\n-    cal.set(Calendar.ZONE_OFFSET, 0);\n-    cal.set(Calendar.DST_OFFSET, 0);\n-    return cal.getTimeInMillis();\n-  }\n-\n-  /**\n-   * Gets the time represented by this object.\n-   *\n-   * @return the time in milliseconds since the epoch.\n-   */\n-  public long getTime()\n-  {\n-    return time;\n-  }\n-\n-  /**\n-   * Returns the number of minutes offset used with UTC to give the time\n-   * represented by this object in the current time zone.  The date information\n-   * from this object is also used to determine whether or not daylight savings\n-   * time is in effect.  For example, the offset for the UK would be 0 if the\n-   * month of the date object was January, and 1 if the month was August.\n-   * \n-   * @deprecated use\n-   * <code>Calendar.get(Calendar.ZONE_OFFSET)+Calendar.get(Calendar.DST_OFFSET)</code>\n-   * instead.\n-   * @return The time zone offset in minutes of the local time zone\n-   * relative to UTC.  The time represented by this object is used to\n-   * determine if we should use daylight savings.\n-   */\n-  public int getTimezoneOffset()\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    return - (cal.get(Calendar.ZONE_OFFSET)\n-\t    + cal.get(Calendar.DST_OFFSET)) / (60 * 1000);\n-  }\n-\n-  /**\n-   * Sets the time which this object should represent.\n-   *\n-   * @param time the time in milliseconds since the epoch.  \n-   */\n-  public void setTime(long time)\n-  {\n-    this.time = time;\n-  }\n-\n-  /**\n-   * Tests if this date is after the specified date.\n-   *\n-   * @param when the other date\n-   * @return true, if the date represented by this object is\n-   * strictly later than the time represented by when.  \n-   */\n-  public boolean after(Date when)\n-  {\n-    return time > when.time;\n-  }\n-\n-  /**\n-   * Tests if this date is before the specified date.\n-   *\n-   * @param when the other date\n-   * @return true, if the date represented by when is strictly later\n-   * than the time represented by this object.\n-   */\n-  public boolean before(Date when)\n-  {\n-    return time < when.time;\n-  }\n-\n-  /**\n-   * Compares two dates for equality.\n-   *\n-   * @param obj the object to compare.\n-   * @return true, if obj is a Date object and the time represented\n-   * by obj is exactly the same as the time represented by this\n-   * object.  \n-   */\n-  public boolean equals(Object obj)\n-  {\n-    return (obj instanceof Date && time == ((Date) obj).time);\n-  }\n-\n-  /**\n-   * Compares two dates.\n-   *\n-   * @param when the other date.\n-   * @return 0, if the date represented\n-   * by obj is exactly the same as the time represented by this\n-   * object, a negative if this Date is before the other Date, and\n-   * a positive value otherwise.  \n-   */\n-  public int compareTo(Date when)\n-  {\n-    return (time < when.time) ? -1 : (time == when.time) ? 0 : 1;\n-  }\n-\n-  /**\n-   * Compares this Date to another object.  This behaves like\n-   * <code>compareTo(Date)</code>, but it takes a generic object\n-   * and throws a <code>ClassCastException</code> if obj is\n-   * not a <code>Date</code>.\n-   * \n-   * @param obj the other date.\n-   * @return 0, if the date represented\n-   * by obj is exactly the same as the time represented by this\n-   * object, a negative if this Date is before the other Date, and\n-   * a positive value otherwise.  \n-   * @exception ClassCastException if obj is not of type Date.\n-   */\n-  public int compareTo(Object obj)\n-  {\n-    return compareTo((Date) obj);\n-  }\n-\n-  /**\n-   * Computes the hash code of this <code>Date</code> as the\n-   * XOR of the most significant and the least significant\n-   * 32 bits of the 64 bit milliseconds value.\n-   *\n-   * @return the hash code.\n-   */\n-  public int hashCode()\n-  {\n-    return (int) time ^ (int) (time >>> 32);\n-  }\n-\n-  /**\n-   * <p>\n-   * Returns a string representation of this date using\n-   * the following date format:\n-   * </p>\n-   * <p>\n-   * <code>day mon dd hh:mm:ss zz yyyy</code>\n-   * </p>\n-   * <p>where the fields used here are:\n-   * <ul>\n-   * <li>\n-   * <code>day</code> -- the day of the week\n-   * (Sunday through to Saturday).\n-   * </li>\n-   * <li>\n-   * <code>mon</code> -- the month (Jan to Dec).\n-   * </li>\n-   * <li>\n-   * <code>dd</code> -- the day of the month\n-   * as two decimal digits (01 to 31).\n-   * </li>\n-   * <li>\n-   * <code>hh</code> -- the hour of the day\n-   * as two decimal digits in 24-hour clock notation\n-   * (01 to 23).\n-   * </li>\n-   * <li>\n-   * <code>mm</code> -- the minute of the day\n-   * as two decimal digits (01 to 59).\n-   * </li>\n-   * <li>\n-   * <code>ss</code> -- the second of the day\n-   * as two decimal digits (01 to 61).\n-   * </li>\n-   * <li>\n-   * <code>zz</code> -- the time zone information if available.\n-   * The possible time zones used include the abbreviations\n-   * recognised by <code>parse()</code> (e.g. GMT, CET, etc.)\n-   * and may reflect the fact that daylight savings time is in\n-   * effect.  The empty string is used if there is no time zone\n-   * information.\n-   * </li>\n-   * <li>\n-   * <code>yyyy</code> -- the year as four decimal digits.\n-   * </li>\n-   * </ul>\n-   * <p>\n-   * The <code>DateFormat</code> class should now be \n-   * preferred over using this method.\n-   * </p>\n-   *\n-   * @return A string of the form 'day mon dd hh:mm:ss zz yyyy'\n-   * @see #parse(String)\n-   * @see DateFormat\n-   */\n-  public String toString()\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    String day = \"0\" + cal.get(Calendar.DATE);\n-    String hour = \"0\" + cal.get(Calendar.HOUR_OF_DAY);\n-    String min = \"0\" + cal.get(Calendar.MINUTE);\n-    String sec = \"0\" + cal.get(Calendar.SECOND);\n-    String year = \"000\" + cal.get(Calendar.YEAR);\n-    return weekNames[cal.get(Calendar.DAY_OF_WEEK) - 1] + \" \"\n-      + monthNames[cal.get(Calendar.MONTH)] + \" \"\n-      + day.substring(day.length() - 2) + \" \"\n-      + hour.substring(hour.length() - 2) + \":\"\n-      + min.substring(min.length() - 2) + \":\"\n-      + sec.substring(sec.length() - 2) + \" \"\n-      +\n-      cal.getTimeZone().getDisplayName(cal.getTimeZone().inDaylightTime(this),\n-\t\t\t\t       TimeZone.SHORT) + \" \" +\n-      year.substring(year.length() - 4);\n-  }\n-\n-  /** \n-   * Returns a locale-dependent string representation of this\n-   * <code>Date</code> object.\n-   *\n-   * @deprecated Use DateFormat.format(Date)\n-   * @return A locale-dependent string representation.\n-   * @see #parse(String)\n-   * @see DateFormat\n-   */\n-  public String toLocaleString()\n-  {\n-    return java.text.DateFormat.getInstance().format(this);\n-  }\n-\n-  /** \n-   * <p>\n-   * Returns a string representation of this <code>Date</code>\n-   * object using GMT rather than the local timezone.\n-   * The following date format is used:\n-   * </p>\n-   * <p>\n-   * <code>d mon yyyy hh:mm:ss GMT</code>\n-   * </p>\n-   * <p>where the fields used here are:\n-   * <ul>\n-   * <li>\n-   * <code>d</code> -- the day of the month\n-   * as one or two decimal digits (1 to 31).\n-   * </li>\n-   * <li>\n-   * <code>mon</code> -- the month (Jan to Dec).\n-   * </li>\n-   * <li>\n-   * <code>yyyy</code> -- the year as four decimal digits.\n-   * </li>\n-   * <li>\n-   * <code>hh</code> -- the hour of the day\n-   * as two decimal digits in 24-hour clock notation\n-   * (01 to 23).\n-   * </li>\n-   * <li>\n-   * <code>mm</code> -- the minute of the day\n-   * as two decimal digits (01 to 59).\n-   * </li>\n-   * <li>\n-   * <code>ss</code> -- the second of the day\n-   * as two decimal digits (01 to 61).\n-   * </li>\n-   * <li>\n-   * <code>GMT</code> -- the literal string \"GMT\"\n-   * indicating Greenwich Mean Time as opposed to\n-   * the local timezone.\n-   * </li>\n-   * </ul>\n-   * \n-   * @deprecated Use DateFormat.format(Date) with a GMT TimeZone.\n-   * @return A string of the form 'd mon yyyy hh:mm:ss GMT' using\n-   *         GMT as opposed to the local timezone.\n-   * @see #parse(String)\n-   * @see DateFormat\n-   */\n-  public String toGMTString()\n-  {\n-    java.text.DateFormat format = java.text.DateFormat.getInstance();\n-    format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-    return format.format(this);\n-  }\n-\n-  /**\n-   * Parses the time zone string.\n-   *\n-   * @param tok The token containing the time zone.\n-   * @param sign The sign (+ or -) used by the time zone.\n-   * @return An integer representing the number of minutes offset\n-   *         from GMT for the time zone.\n-   */\n-  private static int parseTz(String tok, char sign)\n-    throws IllegalArgumentException\n-  {\n-    int num;\n-\n-    try\n-      {\n-\t// parseInt doesn't handle '+' so strip off sign.\n-\tnum = Integer.parseInt(tok.substring(1));\n-      }\n-    catch (NumberFormatException ex)\n-      {\n-\tthrow new IllegalArgumentException(tok);\n-      }\n-\n-    // Convert hours to minutes.\n-    if (num < 24)\n-      num *= 60;\n-    else\n-      num = (num / 100) * 60 + num % 100;\n-\n-    return sign == '-' ? -num : num;\n-  }\n-\n-  /**\n-   * Parses the month string.\n-   *\n-   * @param tok the token containing the month.\n-   * @return An integer between 0 and 11, representing\n-   *         a month from January (0) to December (11),\n-   *         or -1 if parsing failed.\n-   */\n-  private static int parseMonth(String tok)\n-  {\n-    // Initialize strings for month names.\n-    // We could possibly use the fields of DateFormatSymbols but that is\n-    // localized and thus might not match the English words specified.\n-    String months[] = { \"JANUARY\", \"FEBRUARY\", \"MARCH\", \"APRIL\", \"MAY\",\n-\t\t\t\"JUNE\", \"JULY\", \"AUGUST\", \"SEPTEMBER\", \"OCTOBER\",\n-\t\t\t\"NOVEMBER\", \"DECEMBER\" };\n-\n-    int i;\n-    for (i = 0; i < 12; i++)\n-      if (months[i].startsWith(tok))\n-        return i;\n-\n-    // Return -1 if not found.\n-    return -1;\n-  }\n-\n-  /**\n-   * Parses the day of the week string.\n-   *\n-   * @param tok the token containing the day of the week.\n-   * @return true if the token was parsed successfully.\n-   */\n-  private static boolean parseDayOfWeek(String tok)\n-  {\n-    // Initialize strings for days of the week names.\n-    // We could possibly use the fields of DateFormatSymbols but that is\n-    // localized and thus might not match the English words specified.\n-    String daysOfWeek[] = { \"SUNDAY\", \"MONDAY\", \"TUESDAY\", \"WEDNESDAY\",\n-\t\t\t    \"THURSDAY\", \"FRIDAY\", \"SATURDAY\" };\n-\n-    int i;\n-    for (i = 0; i < 7; i++)\n-      if (daysOfWeek[i].startsWith(tok))\n-        return true;\n-\n-    return false;\n-  }\n-\n-  /** \n-   * <p>\n-   * Parses a String and returns the time, in milliseconds since the\n-   * epoch, it represents.  Most syntaxes are handled, including\n-   * the IETF date standard \"day, dd mon yyyy hh:mm:ss zz\" (see\n-   * <code>toString()</code> for definitions of these fields).\n-   * Standard U.S. time zone abbreviations are recognised, in\n-   * addition to time zone offsets in positive or negative minutes.\n-   * If a time zone is specified, the specified time is assumed to\n-   * be in UTC and the appropriate conversion is applied, following\n-   * parsing, to convert this to the local time zone.  If no zone\n-   * is specified, the time is assumed to already be in the local\n-   * time zone.\n-   * </p>\n-   * <p>\n-   * The method parses the string progressively from left to right.\n-   * At the end of the parsing process, either a time is returned\n-   * or an <code>IllegalArgumentException</code> is thrown to signify\n-   * failure.  The ASCII characters A-Z, a-z, 0-9, and ',', '+', '-',\n-   * ':' and '/' are the only characters permitted within the string,\n-   * besides whitespace and characters enclosed within parantheses\n-   * '(' and ')'.  \n-   * </p>\n-   * <p>\n-   * A sequence of consecutive digits are recognised as a number,\n-   * and interpreted as follows:\n-   * <ul>\n-   * <li>\n-   * A number preceded by a sign (+ or -) is taken to be a time zone\n-   * offset.  The time zone offset can be specified in either hours\n-   * or minutes.  The former is assumed if the number is less than 24.\n-   * Otherwise, the offset is assumed to be in minutes.  A - indicates\n-   * a time zone west of GMT, while a + represents a time zone to the\n-   * east of GMT.  The time zones are always assumed to be relative\n-   * to GMT, and a (redundant) specification of this can be included\n-   * with the time zone.  For example, '-9', 'utc-9' and 'GMT-9' all\n-   * represent a time zone nine hours west of GMT.  Similarly,\n-   * '+4', 'ut+4' and 'UTC+4' all give 4 hours east of GMT.\n-   * </li>\n-   * <li>\n-   * A number equal to or greater than 70 is regarded as a year specification.\n-   * Values lower than 70 are only assumed to indicate a year if both the\n-   * day of the month and the month itself have already been recognised.\n-   * Year values less than 100 are interpreted as being relative to the current\n-   * century when the <code>Date</code> class is initialised..  Given a century,\n-   * x, the year is assumed to be within the range x - 80 to x + 19.  The value\n-   * itself is then used as a match against the two last digits of one of these\n-   * years.  For example, take x to be 2004.  A two-digit year is assumed to fall\n-   * within the range x - 80 (1924) and x + 19 (2023).  Thus, any intepreted value\n-   * between 0 and 23 is assumed to be 2000 to 2023 and values between 24 and 99\n-   * are taken as being 1924 to 1999.  This only applies for the case of 2004.\n-   * With a different year, the values will be interpreted differently. 2005\n-   * will used 0 to 24 as 2000 to 2024 and 25 to 99 as 1925 to 1999, for example.\n-   * This behaviour differs from that of <code>SimpleDateFormat</code> and is\n-   * time-dependent (a two-digit year will be interpreted differently depending\n-   * on the time the code is run).\n-   * </li>\n-   * <li>\n-   * Numbers followed by a colon are interpreted by first an hour, and then\n-   * as a minute, once an hour has been found.\n-   * </li>\n-   * <li>\n-   * <li>\n-   * Numbers followed by a slash are regarded first as a month, and then as\n-   * a day of the month once the month has been found.  This follows the\n-   * U.S. date format of mm/dd, rather than the European dd/mm.  Months\n-   * are converted to the recognised value - 1 before storage, in order\n-   * to put the number within the range 0 to 11.\n-   * </li>\n-   * <li>\n-   * Numbers followed by commas, whitespace, hyphens or the end of the string\n-   * are interpreted in the following order: hour, minute, second, day of month.\n-   * The first type not already recognised in the current string being parsed is\n-   * assumed.\n-   * </li>\n-   * </ul>\n-   * </p>\n-   * <p>\n-   * A sequence of consecutive alphabetic characters is recognised as a word,\n-   * and interpreted as follows, in a case-insentive fashion:\n-   * <ul>\n-   * <li>\n-   * The characters 'AM' or 'PM' restrict the hour value to a value between 0\n-   * and 12.  In the latter case, 12 is added to the hour value before storage.\n-   * </li>\n-   * <li>\n-   * Any words which match any prefix of one of the days of the week ('Monday',\n-   * 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' and 'Sunday'),\n-   * are simply ignored.\n-   * </li>\n-   * <li>\n-   * Any words which match any prefix of one of the months of the year ('January',\n-   * 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',\n-   * 'October', 'November', 'December') are recognised and interpreted as the\n-   * appropriate value between 0 and 11.  The first match made against a\n-   * month is the one used, in the order specified here.  For example, 'Ma' is\n-   * intepreted as 'March' (2) and not as 'May' (4).  Similarly, 'Ju' is 'June',\n-   * and not 'July'.\n-   * </li>\n-   * <li>\n-   * The words 'GMT', 'UT' and 'UTC' are interpreted as specifying UTC as the\n-   * time zone in use for this date.\n-   * </li>\n-   * <li>\n-   * The word pairs 'EST'/'EDT', 'CST'/'CDT', 'MST'/'MDT' and 'PST'/'PDT' are\n-   * interpreted as the appropriate U.S. time zone abbreviation.  Each pair\n-   * is the standard and daylight savings time zone specification, respectively,\n-   * for each zone within the U.S, these being Eastern Standard/Daylight Time\n-   * (-5), Central Standard/Daylight Time (-6), Mountain Standard/Daylight Time\n-   * (-7) and Pacific Standard/Daylight Time (-8).\n-   * </li>\n-   * </ul>\n-   *\n-   * @param s The String to parse.\n-   * @return The time in milliseconds since the epoch.\n-   * @throws IllegalArgumentException if the string fails to parse.\n-   * @deprecated Use DateFormat.parse(String)\n-   * @see #toString()\n-   * @see SimpleDateFormat\n-   */\n-  public static long parse(String string)\n-  {\n-    // Initialize date/time fields before parsing begins.\n-    int year = -1;\n-    int month = -1;\n-    int day = -1;\n-    int hour = -1;\n-    int minute = -1;\n-    int second = -1;\n-    int timezone = 0;\n-    boolean localTimezone = true;\n-\n-    // Trim out any nested stuff in parentheses now to make parsing easier.\n-    StringBuffer buf = new StringBuffer();\n-    int parenNesting = 0;\n-    int len = string.length();\n-    for (int i = 0;  i < len;  i++)\n-      {\n-\tchar ch = string.charAt(i);\n-\tif (ch >= 'a' && ch <= 'z')\n-\t  ch -= 'a' - 'A';\n-\tif (ch == '(')\n-\t  parenNesting++;\n-\telse if (parenNesting == 0)\n-\t  buf.append(ch);\n-\telse if (ch == ')')\n-\t  parenNesting--;\n-      }\n-    int tmpMonth;\n-\n-    // Make all chars upper case to simplify comparisons later.\n-    // Also ignore commas; treat them as delimiters.\n-    StringTokenizer strtok = new StringTokenizer(buf.toString(), \" \\t\\n\\r,\");\n-\n-    while (strtok.hasMoreTokens())\n-      {\n-\tString tok = strtok.nextToken();\n-\tchar firstch = tok.charAt(0);\n-\tif ((firstch == '+' || firstch == '-') && year >= 0)\n-\t  {\n-\t    timezone = parseTz(tok, firstch);\n-\t    localTimezone = false;\n-\t  }\n-\telse if (firstch >= '0' && firstch <= '9')\n-\t  {\n-\t    while (tok != null && tok.length() > 0)\n-\t      {\n-\t\tint punctOffset = tok.length();\n-\t\tint num = 0;\n-\t\tint punct;\n-\t\tfor (int i = 0;  ;  i++)\n-\t\t  {\n-\t\t    if (i >= punctOffset)\n-\t\t      {\n-\t\t\tpunct = -1;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\tpunct = tok.charAt(i);\n-\t\t\tif (punct >= '0' && punct <= '9')\n-\t\t\t  {\n-\t\t\t    if (num > 999999999) // in case of overflow\n-\t\t\t      throw new IllegalArgumentException(tok);\n-\t\t\t    num = 10 * num + (punct - '0');\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  {\n-\t\t\t    punctOffset = i;\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t      }\n-\t\t      \n-\t\t  }\n-\n-\t\tif (punct == ':')\n-\t\t  {\n-\t\t    if (hour < 0)\n-\t\t      hour = num;\n-\t\t    else\n-\t\t      minute = num;\n-\t\t  }\n-\t        else if ((num >= 70\n-\t\t\t  && (punct == ' ' || punct == ','\n-\t\t\t      || punct == '/' || punct < 0))\n-\t\t\t || (num < 70 && day >= 0 && month >= 0 && year < 0))\n-\t\t  {\n-\t\t    if (num >= 100)\n-\t\t      year = num;\n-\t\t    else\n-\t\t      {\n-\t\t\tint curYear = 1900 + new Date().getYear();\n-\t\t\tint firstYear = curYear - 80;\n-\t\t\tyear = firstYear / 100 * 100 + num;\n-\t\t\tif (year < firstYear)\n-\t\t\t  year += 100;\n-\t\t      }\n-\t\t  }\n-\t\telse if (punct == '/')\n-\t\t  {\n-\t\t    if (month < 0)\n-\t\t      month = num - 1;\n-\t\t    else\n-\t\t      day = num;\n-\t\t  }\n-\t\telse if (hour >= 0 && minute < 0)\n-\t\t  minute = num;\n-\t\telse if (minute >= 0 && second < 0)\n-\t\t  second = num;\n-\t\telse if (day < 0)\n-\t\t  day = num;\n-\t\telse\n-\t\t  throw new IllegalArgumentException(tok);\n-\n-\t\t// Advance string if there's more to process in this token.\n-\t\tif (punct < 0 || punctOffset + 1 >= tok.length())\n-\t\t  tok = null;\n-\t\telse\n-\t\t  tok = tok.substring(punctOffset + 1);\n-\t      }\n-\t  }\n-\telse if (firstch >= 'A' && firstch <= 'Z')\n-\t  {\n-\t    if (tok.equals(\"AM\"))\n-\t      {\n-\t\tif (hour < 1 || hour > 12)\n-\t\t  throw new IllegalArgumentException(tok);\n-\t\tif (hour == 12)\n-\t\t  hour = 0;\n-\t      }\n-\t    else if (tok.equals(\"PM\"))\n-\t      {\n-\t\tif (hour < 1 || hour > 12)\n-\t\t  throw new IllegalArgumentException(tok);\n-\t\tif (hour < 12)\n-\t\t  hour += 12;\n-\t      }\n-\t    else if (parseDayOfWeek(tok))\n-\t      ; // Ignore it; throw the token away.\n-\t    else if (tok.equals(\"UT\") || tok.equals(\"UTC\") || tok.equals(\"GMT\"))\n-\t      localTimezone = false;\n-\t    else if (tok.startsWith(\"UT\") || tok.startsWith(\"GMT\"))\n-\t      {\n-\t\tint signOffset = 3;\n-\t\tif (tok.charAt(1) == 'T' && tok.charAt(2) != 'C')\n-\t\t  signOffset = 2;\n-\n-\t        char sign = tok.charAt(signOffset);\n-\t\tif (sign != '+' && sign != '-')\n-\t\t  throw new IllegalArgumentException(tok);\n-\n-\t        timezone = parseTz(tok.substring(signOffset), sign);\n-\t        localTimezone = false;\n-\t      }\n-\t    else if ((tmpMonth = parseMonth(tok)) >= 0)\n-\t      month = tmpMonth;\n-\t    else if (tok.length() == 3 && tok.charAt(2) == 'T')\n-\t      {\n-\t\t// Convert timezone offset from hours to minutes.\n-\t\tchar ch = tok.charAt(0);\n-\t\tif (ch == 'E')\n-\t\t  timezone = -5 * 60;\n-\t\telse if (ch == 'C')\n-\t\t  timezone = -6 * 60;\n-\t\telse if (ch == 'M')\n-\t\t  timezone = -7 * 60;\n-\t\telse if (ch == 'P')\n-\t\t  timezone = -8 * 60;\n-\t\telse\n-\t\t  throw new IllegalArgumentException(tok);\n-\n-\t\t// Shift 60 minutes for Daylight Savings Time.\n-\t\tif (tok.charAt(1) == 'D')\n-\t\t  timezone += 60;\n-\t\telse if (tok.charAt(1) != 'S')\n-\t\t  throw new IllegalArgumentException(tok);\n-\n-\t        localTimezone = false;\n-\t      }\n-\t    else\n-\t      throw new IllegalArgumentException(tok);\n-\t  }\n-\telse\n-\t  throw new IllegalArgumentException(tok);\n-      }\n-\n-    // Unspecified hours, minutes, or seconds should default to 0.\n-    if (hour < 0)\n-      hour = 0;\n-    if (minute < 0)\n-      minute = 0;\n-    if (second < 0)\n-      second = 0;\n-\n-    // Throw exception if any other fields have not been recognized and set.\n-    if (year < 0 || month < 0 || day < 0)\n-      throw new IllegalArgumentException(\"Missing field\");\n-\n-    // Return the time in either local time or relative to GMT as parsed.\n-    // If no time-zone was specified, get the local one (in minutes) and\n-    // convert to milliseconds before adding to the UTC.\n-    GregorianCalendar cal\n-      = new GregorianCalendar(year, month, day, hour, minute, second);\n-    if (!localTimezone)\n-      {\n-\tcal.set(Calendar.ZONE_OFFSET, timezone * 60 * 1000);\n-\tcal.set(Calendar.DST_OFFSET, 0);\n-      }\n-    return cal.getTimeInMillis();\n-  }\n-\n-  /**\n-   * Returns the difference between the year represented by this\n-   * <code>Date</code> object and 1900.\n-   *\n-   * @return the year minus 1900 represented by this date object.\n-   * @deprecated Use Calendar instead of Date, and use get(Calendar.YEAR)\n-   * instead.  Note the 1900 difference in the year.\n-   * @see Calendar\n-   * @see #setYear(int)\n-   */\n-  public int getYear()\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    return cal.get(Calendar.YEAR) - 1900;\n-  }\n-\n-  /**\n-   * Sets the year to the specified year, plus 1900.  The other\n-   * fields are only altered as required to match the same date\n-   * and time in the new year.  Usually, this will mean that\n-   * the fields are not changed at all, but in the case of\n-   * a leap day or leap second, the fields will change in\n-   * relation to the existence of such an event in the new year.\n-   * For example, if the date specifies February the 29th, 2000,\n-   * then this will become March the 1st if the year is changed\n-   * to 2001, as 2001 is not a leap year.  Similarly, a seconds\n-   * value of 60 or 61 may result in the seconds becoming 0 and\n-   * the minute increasing by 1, if the new time does not include\n-   * a leap second.\n-   *\n-   * @param year the year minus 1900.\n-   * @deprecated Use Calendar instead of Date, and use\n-   * set(Calendar.YEAR, year) instead.  Note about the 1900\n-   * difference in year.  \n-   * @see #getYear()\n-   * @see Calendar\n-   */\n-  public void setYear(int year)\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    cal.set(Calendar.YEAR, 1900 + year);\n-    time = cal.getTimeInMillis();\n-  }\n-\n-  /**\n-   * Returns the month represented by this <code>Date</code> object,\n-   * as a value between 0 (January) and 11 (December).\n-   *\n-   * @return the month represented by this date object (zero based).\n-   * @deprecated Use Calendar instead of Date, and use get(Calendar.MONTH)\n-   * instead.\n-   * @see #setMonth(int)\n-   * @see Calendar\n-   */\n-  public int getMonth()\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    return cal.get(Calendar.MONTH);\n-  }\n-\n-  /**\n-   * Sets the month to the given value.  The other\n-   * fields are only altered as necessary to match\n-   * the same date and time in the new month.  In most\n-   * cases, the other fields won't change at all.  However,\n-   * in the case of a shorter month or a leap second, values\n-   * may be adjusted.  For example, if the day of the month\n-   * is currently 31, and the month value is changed from\n-   * January (0) to September (8), the date will become\n-   * October the 1st, as September only has 30 days.  Similarly,\n-   * a seconds value of 60 or 61 (a leap second) may result\n-   * in the seconds value being reset to 0 and the minutes\n-   * value being incremented by 1, if the new time does\n-   * not include a leap second.\n-   * \n-   * @param month the month, with a zero-based index\n-   *        from January.\n-   * @deprecated Use Calendar instead of Date, and use\n-   * set(Calendar.MONTH, month) instead.\n-   * @see #getMonth()\n-   * @see Calendar \n-   */\n-  public void setMonth(int month)\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    cal.set(Calendar.MONTH, month);\n-    time = cal.getTimeInMillis();\n-  }\n-\n-  /**\n-   * Returns the day of the month of this <code>Date</code>\n-   * object, as a value between 0 and 31.\n-   *\n-   * @return the day of month represented by this date object.\n-   * @deprecated Use Calendar instead of Date, and use get(Calendar.DATE)\n-   * instead.\n-   * @see Calendar\n-   * @see #setDate(int)\n-   */\n-  public int getDate()\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    return cal.get(Calendar.DATE);\n-  }\n-\n-  /**\n-   * Sets the date to the given value. The other\n-   * fields are only altered as necessary to match\n-   * the same date and time on the new day of the month.  In most\n-   * cases, the other fields won't change at all.  However,\n-   * in the case of a leap second or the day being out of\n-   * the range of the current month, values\n-   * may be adjusted.  For example, if the day of the month\n-   * is currently 30 and the month is June, a new day of the\n-   * month value of 31 will cause the month to change to July,\n-   * as June only has 30 days .  Similarly,\n-   * a seconds value of 60 or 61 (a leap second) may result\n-   * in the seconds value being reset to 0 and the minutes\n-   * value being incremented by 1, if the new time does\n-   * not include a leap second.\n-   *\n-   * @param date the date.\n-   * @deprecated Use Calendar instead of Date, and use\n-   * set(Calendar.DATE, date) instead. \n-   * @see Calendar\n-   * @see #getDate()\n-   */\n-  public void setDate(int date)\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    cal.set(Calendar.DATE, date);\n-    time = cal.getTimeInMillis();\n-  }\n-\n-  /**\n-   * Returns the day represented by this <code>Date</code>\n-   * object as an integer between 0 (Sunday) and 6 (Saturday).\n-   *\n-   * @return the day represented by this date object.\n-   * @deprecated Use Calendar instead of Date, and use get(Calendar.DAY_OF_WEEK)\n-   * instead.\n-   * @see Calendar\n-   */\n-  public int getDay()\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    // For Calendar, Sunday is 1.  For Date, Sunday is 0.\n-    return cal.get(Calendar.DAY_OF_WEEK) - 1;\n-  }\n-\n-  /**\n-   * Returns the hours represented by this <code>Date</code>\n-   * object as an integer between 0 and 23.\n-   *\n-   * @return the hours represented by this date object.\n-   * @deprecated Use Calendar instead of Date, and use get(Calendar.HOUR_OF_DAY)\n-   * instead.\n-   * @see Calendar\n-   * @see #setHours(int)\n-   */\n-  public int getHours()\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    return cal.get(Calendar.HOUR_OF_DAY);\n-  }\n-\n-  /**\n-   * Sets the hours to the given value.  The other\n-   * fields are only altered as necessary to match\n-   * the same date and time in the new hour.  In most\n-   * cases, the other fields won't change at all.  However,\n-   * in the case of a leap second, values\n-   * may be adjusted.  For example,\n-   * a seconds value of 60 or 61 (a leap second) may result\n-   * in the seconds value being reset to 0 and the minutes\n-   * value being incremented by 1 if the new hour does\n-   * not contain a leap second.\n-   *\n-   * @param hours the hours.\n-   * @deprecated Use Calendar instead of Date, and use\n-   * set(Calendar.HOUR_OF_DAY, hours) instead.\n-   * @see Calendar\n-   * @see #getHours() \n-   */\n-  public void setHours(int hours)\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    cal.set(Calendar.HOUR_OF_DAY, hours);\n-    time = cal.getTimeInMillis();\n-  }\n-\n-  /**\n-   * Returns the number of minutes represented by the <code>Date</code>\n-   * object, as an integer between 0 and 59.\n-   *\n-   * @return the minutes represented by this date object.\n-   * @deprecated Use Calendar instead of Date, and use get(Calendar.MINUTE)\n-   * instead.\n-   * @see Calendar\n-   * @see #setMinutes(int)\n-   */\n-  public int getMinutes()\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    return cal.get(Calendar.MINUTE);\n-  }\n-\n-  /**\n-   * Sets the minutes to the given value.  The other\n-   * fields are only altered as necessary to match\n-   * the same date and time in the new minute.  In most\n-   * cases, the other fields won't change at all.  However,\n-   * in the case of a leap second, values\n-   * may be adjusted.  For example,\n-   * a seconds value of 60 or 61 (a leap second) may result\n-   * in the seconds value being reset to 0 and the minutes\n-   * value being incremented by 1 if the new minute does\n-   * not contain a leap second.\n-   *\n-   * @param minutes the minutes.\n-   * @deprecated Use Calendar instead of Date, and use\n-   * set(Calendar.MINUTE, minutes) instead. \n-   * @see Calendar\n-   * @see #getMinutes()\n-   */\n-  public void setMinutes(int minutes)\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    cal.set(Calendar.MINUTE, minutes);\n-    time = cal.getTimeInMillis();\n-  }\n-\n-  /**\n-   * Returns the number of seconds represented by the <code>Date</code>\n-   * object, as an integer between 0 and 61 (60 and 61 being leap seconds).\n-   *\n-   * @return the seconds represented by this date object.\n-   * @deprecated Use Calendar instead of Date, and use get(Calendar.SECOND)\n-   * instead.\n-   * @see Calendar\n-   * @see #setSeconds(int)\n-   */\n-  public int getSeconds()\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    return cal.get(Calendar.SECOND);\n-  }\n-\n-  /**\n-   * Sets the seconds to the given value.  The other\n-   * fields are only altered as necessary to match\n-   * the same date and time in the new minute.  In most\n-   * cases, the other fields won't change at all.  However,\n-   * in the case of a leap second, values\n-   * may be adjusted.  For example, setting the\n-   * seconds value to 60 or 61 (a leap second) may result\n-   * in the seconds value being reset to 0 and the minutes\n-   * value being incremented by 1, if the current time does\n-   * not contain a leap second.\n-   *\n-   * @param seconds the seconds.\n-   * @deprecated Use Calendar instead of Date, and use\n-   * set(Calendar.SECOND, seconds) instead.\n-   * @see Calendar\n-   * @see #getSeconds() \n-   */\n-  public void setSeconds(int seconds)\n-  {\n-    Calendar cal = Calendar.getInstance();\n-    cal.setTimeInMillis(time);\n-    cal.set(Calendar.SECOND, seconds);\n-    time = cal.getTimeInMillis();\n-  }\n-\n-  /**\n-   * Deserializes a <code>Date</code> object from an\n-   * input stream, setting the time (in milliseconds\n-   * since the epoch) to the long value read from the\n-   * stream.\n-   *\n-   * @param input the input stream.\n-   * @throws IOException if an I/O error occurs in the stream.\n-   * @throws ClassNotFoundException if the class of the\n-   *         serialized object could not be found.\n-   */\n-  private void readObject(ObjectInputStream input)\n-    throws IOException, ClassNotFoundException\n-  {\n-    input.defaultReadObject();\n-    time = input.readLong();\n-  }\n-\n-  /**\n-   * Serializes a <code>Date</code> object to an output stream,\n-   * storing the time (in milliseconds since the epoch) as a long\n-   * value in the stream.\n-   *\n-   * @serialdata A long value representing the offset from the epoch\n-   * in milliseconds.  This is the same value that is returned by the\n-   * method getTime().\n-   * @param output the output stream.\n-   * @throws IOException if an I/O error occurs in the stream.\n-   */\n-  private void writeObject(ObjectOutputStream output)\n-    throws IOException\n-  {\n-    output.defaultWriteObject();\n-    output.writeLong(time);\n-  }\n-\n-}"}, {"sha": "dc77c2f502452a526052ee8f2ca4ead2149d0314", "filename": "libjava/java/util/GregorianCalendar.java", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46f32b2b9096aef6888b3a1882d88467b845e5fe/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46f32b2b9096aef6888b3a1882d88467b845e5fe/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FGregorianCalendar.java?ref=46f32b2b9096aef6888b3a1882d88467b845e5fe", "patch": "@@ -871,6 +871,17 @@ protected synchronized void computeFields()\n \n     areFieldsSet = isSet[ERA] = isSet[YEAR] = isSet[MONTH] = isSet[WEEK_OF_YEAR] = isSet[WEEK_OF_MONTH] = isSet[DAY_OF_MONTH] = isSet[DAY_OF_YEAR] = isSet[DAY_OF_WEEK] = isSet[DAY_OF_WEEK_IN_MONTH] = isSet[AM_PM] = isSet[HOUR] = isSet[HOUR_OF_DAY] = isSet[MINUTE] = isSet[SECOND] = isSet[MILLISECOND] = isSet[ZONE_OFFSET] = isSet[DST_OFFSET] = true;\n   }\n+  \n+  /**\n+   * Return a hash code for this object, following the general contract\n+   * specified by {@link Object#hashCode()}.\n+   * @return the hash code\n+   */\n+  public int hashCode()\n+  {\n+    int val = (int) ((gregorianCutover >>> 32) ^ (gregorianCutover & 0xffffffff));\n+    return super.hashCode() ^ val;\n+  }\n \n   /**\n    * Compares the given calendar with this.  An object, o, is\n@@ -893,7 +904,8 @@ public boolean equals(Object o)\n       return false;\n \n     GregorianCalendar cal = (GregorianCalendar) o;\n-    return (cal.getTimeInMillis() == getTimeInMillis());\n+    return (cal.gregorianCutover == gregorianCutover\n+            && super.equals(o));\n   }\n \n   /**"}, {"sha": "19dd3cdf19f0c203ae214f67c461aa2e050737d3", "filename": "libjava/java/util/ResourceBundle.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46f32b2b9096aef6888b3a1882d88467b845e5fe/libjava%2Fjava%2Futil%2FResourceBundle.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46f32b2b9096aef6888b3a1882d88467b845e5fe/libjava%2Fjava%2Futil%2FResourceBundle.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FResourceBundle.java?ref=46f32b2b9096aef6888b3a1882d88467b845e5fe", "patch": "@@ -359,7 +359,7 @@ public boolean equals(Object o)\n    *\n    * @param baseName the name of the ResourceBundle\n    * @param locale A locale\n-   * @param classloader a ClassLoader\n+   * @param classLoader a ClassLoader\n    * @return the desired resource bundle\n    * @throws MissingResourceException if the resource bundle can't be found\n    * @throws NullPointerException if any argument is null"}, {"sha": "f754d22b3b4723c4fd0558a24ab507335f0fce54", "filename": "libjava/java/util/SimpleTimeZone.java", "status": "removed", "additions": 0, "deletions": 1078, "changes": 1078, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab156144da05dcb8df7fb55a10e937a17372f6a7/libjava%2Fjava%2Futil%2FSimpleTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab156144da05dcb8df7fb55a10e937a17372f6a7/libjava%2Fjava%2Futil%2FSimpleTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FSimpleTimeZone.java?ref=ab156144da05dcb8df7fb55a10e937a17372f6a7", "patch": "@@ -1,1078 +0,0 @@\n-/* java.util.SimpleTimeZone\n-   Copyright (C) 1998, 1999, 2000, 2003, 2004, 2005  Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.util;\n-\n-\n-/**\n- * This class represents a simple time zone offset and handles\n- * daylight savings.  It can only handle one daylight savings rule, so\n- * it can't represent historical changes.\n- *\n- * This object is tightly bound to the Gregorian calendar.  It assumes\n- * a regular seven days week, and the month lengths are that of the\n- * Gregorian Calendar.  It can only handle daylight savings for years\n- * lying in the AD era.\n- *\n- * @see Calendar\n- * @see GregorianCalender\n- * @author Jochen Hoenicke\n- */\n-public class SimpleTimeZone extends TimeZone\n-{\n-  /**\n-   * The raw time zone offset in milliseconds to GMT, ignoring\n-   * daylight savings.\n-   * @serial\n-   */\n-  private int rawOffset;\n-\n-  /**\n-   * True, if this timezone uses daylight savings, false otherwise.\n-   * @serial\n-   */\n-  private boolean useDaylight;\n-\n-  /**\n-   * The daylight savings offset.  This is a positive offset in\n-   * milliseconds with respect to standard time.  Typically this\n-   * is one hour, but for some time zones this may be half an hour.\n-   * @serial\n-   * @since JDK1.1.4\n-   */\n-  private int dstSavings = 60 * 60 * 1000;\n-\n-  /**\n-   * The first year, in which daylight savings rules applies.\n-   * @serial\n-   */\n-  private int startYear;\n-  private static final int DOM_MODE = 1;\n-  private static final int DOW_IN_MONTH_MODE = 2;\n-  private static final int DOW_GE_DOM_MODE = 3;\n-  private static final int DOW_LE_DOM_MODE = 4;\n-\n-  /**\n-   * The mode of the start rule. This takes one of the following values:\n-   * <dl>\n-   * <dt>DOM_MODE (1)</dt>\n-   * <dd> startDay contains the day in month of the start date,\n-   * startDayOfWeek is unused. </dd>\n-   * <dt>DOW_IN_MONTH_MODE (2)</dt>\n-   * <dd> The startDay gives the day of week in month, and\n-   * startDayOfWeek the day of week.  For example startDay=2 and\n-   * startDayOfWeek=Calender.SUNDAY specifies that the change is on\n-   * the second sunday in that month.  You must make sure, that this\n-   * day always exists (ie. don't specify the 5th sunday).\n-   * </dd>\n-   * <dt>DOW_GE_DOM_MODE (3)</dt>\n-   * <dd> The start is on the first startDayOfWeek on or after\n-   * startDay.  For example startDay=13 and\n-   * startDayOfWeek=Calendar.FRIDAY specifies that the daylight\n-   * savings start on the first FRIDAY on or after the 13th of that\n-   * Month. Make sure that the change is always in the given month, or\n-   * the result is undefined.\n-   * </dd>\n-   * <dt>DOW_LE_DOM_MONTH (4)</dt>\n-   * <dd> The start is on the first startDayOfWeek on or before the\n-   * startDay.  Make sure that the change is always in the given\n-   * month, or the result is undefined.\n-   </dd>\n-   * </dl>\n-   * @serial */\n-  private int startMode;\n-\n-  /**\n-   * The month in which daylight savings start.  This is one of the\n-   * constants Calendar.JANUARY, ..., Calendar.DECEMBER.\n-   * @serial\n-   */\n-  private int startMonth;\n-\n-  /**\n-   * This variable can have different meanings.  See startMode for details\n-   * @see #startMode;\n-   * @serial\n-   */\n-  private int startDay;\n-\n-  /**\n-   * This variable specifies the day of week the change takes place.  If\n-   * startMode == DOM_MODE, this is undefined.\n-   * @serial\n-   * @see #startMode;\n-   */\n-  private int startDayOfWeek;\n-\n-  /**\n-   * This variable specifies the time of change to daylight savings.\n-   * This time is given in milliseconds after midnight local\n-   * standard time.\n-   * @serial\n-   */\n-  private int startTime;\n-\n-  /**\n-   * This variable specifies the mode that startTime is specified in.  By\n-   * default it is WALL_TIME, but can also be STANDARD_TIME or UTC_TIME.  For\n-   * startTime, STANDARD_TIME and WALL_TIME are equivalent.\n-   * @serial\n-   */\n-  private int startTimeMode = WALL_TIME;\n-\n-  /**\n-   * The month in which daylight savings ends.  This is one of the\n-   * constants Calendar.JANUARY, ..., Calendar.DECEMBER.\n-   * @serial\n-   */\n-  private int endMonth;\n-\n-  /**\n-   * This variable gives the mode for the end of daylight savings rule.\n-   * It can take the same values as startMode.\n-   * @serial\n-   * @see #startMode\n-   */\n-  private int endMode;\n-\n-  /**\n-   * This variable can have different meanings.  See startMode for details\n-   * @serial\n-   * @see #startMode;\n-   */\n-  private int endDay;\n-\n-  /**\n-   * This variable specifies the day of week the change takes place.  If\n-   * endMode == DOM_MODE, this is undefined.\n-   * @serial\n-   * @see #startMode;\n-   */\n-  private int endDayOfWeek;\n-\n-  /**\n-   * This variable specifies the time of change back to standard time.\n-   * This time is given in milliseconds after midnight local\n-   * standard time.\n-   * @serial\n-   */\n-  private int endTime;\n-\n-  /**\n-   * This variable specifies the mode that endTime is specified in.  By\n-   * default it is WALL_TIME, but can also be STANDARD_TIME or UTC_TIME.\n-   * @serial\n-   */\n-  private int endTimeMode = WALL_TIME;\n-\n-  /**\n-   * This variable points to a deprecated array from JDK 1.1.  It is\n-   * ignored in JDK 1.2 but streamed out for compatibility with JDK 1.1.\n-   * The array contains the lengths of the months in the year and is\n-   * assigned from a private static final field to avoid allocating\n-   * the array for every instance of the object.\n-   * Note that static final fields are not serialized.\n-   * @serial\n-   */\n-  private byte[] monthLength = monthArr;\n-  private static final byte[] monthArr = \n-                                         {\n-                                           31, 28, 31, 30, 31, 30, 31, 31, 30,\n-                                           31, 30, 31\n-                                         };\n-\n-  /**\n-   * The version of the serialized data on the stream.\n-   * <dl>\n-   * <dt>0 or not present on stream</dt>\n-   * <dd> JDK 1.1.3 or earlier, only provides this fields:\n-   * rawOffset, startDay, startDayOfWeek, startMonth, startTime,\n-   * startYear, endDay, endDayOfWeek, endMonth, endTime\n-   * </dd>\n-   * <dd> JDK 1.1.4 or later. This includes three new fields, namely\n-   * startMode, endMode and dstSavings.  And there is a optional section\n-   * as described in writeObject.\n-   * </dd>\n-   * </dl>\n-   *\n-   * XXX - JDK 1.2 Beta 4 docu states 1.1.4, but my 1.1.5 has the old\n-   * version.\n-   *\n-   * When streaming out this class it is always written in the latest\n-   * version.\n-   * @serial\n-   * @since JDK1.1.4\n-   */\n-  private int serialVersionOnStream = 2;\n-  private static final long serialVersionUID = -403250971215465050L;\n-\n-  /**\n-   * Constant to indicate that start and end times are specified in standard\n-   * time, without adjusting for daylight savings.\n-   */\n-  public static final int STANDARD_TIME = 1;\n-\n-  /**\n-   * Constant to indicate that start and end times are specified in wall\n-   * time, adjusting for daylight savings.  This is the default.\n-   */\n-  public static final int WALL_TIME = 0;\n-\n-  /**\n-   * Constant to indicate that start and end times are specified in UTC.\n-   */\n-  public static final int UTC_TIME = 2;\n-\n-  /**\n-   * Create a <code>SimpleTimeZone</code> with the given time offset\n-   * from GMT and without daylight savings.\n-   * @param rawOffset the time offset from GMT in milliseconds.\n-   * @param id The identifier of this time zone.\n-   */\n-  public SimpleTimeZone(int rawOffset, String id)\n-  {\n-    this.rawOffset = rawOffset;\n-    setID(id);\n-    useDaylight = false;\n-    startYear = 0;\n-  }\n-\n-  /**\n-   * Create a <code>SimpleTimeZone</code> with the given time offset\n-   * from GMT and with daylight savings.  The start/end parameters\n-   * can have different meaning (replace WEEKDAY with a real day of\n-   * week). Only the first two meanings were supported by earlier\n-   * versions of jdk.\n-   *\n-   * <dl>\n-   * <dt><code>day &gt; 0, dayOfWeek = Calendar.WEEKDAY</code></dt>\n-   * <dd>The start/end of daylight savings is on the <code>day</code>-th\n-   * <code>WEEKDAY</code> in the given month. </dd>\n-   * <dt><code>day &lt; 0, dayOfWeek = Calendar.WEEKDAY</code></dt>\n-   * <dd>The start/end of daylight savings is on the <code>-day</code>-th\n-   * <code>WEEKDAY</code> counted from the <i>end</i> of the month. </dd>\n-   * <dt><code>day &gt; 0, dayOfWeek = 0</code></dt>\n-   * <dd>The start/end of daylight is on the <code>day</code>-th day of\n-   * the month. </dd>\n-   * <dt><code>day &gt; 0, dayOfWeek = -Calendar.WEEKDAY</code></dt>\n-   * <dd>The start/end of daylight is on the first WEEKDAY on or after\n-   * the <code>day</code>-th day of the month.  You must make sure that\n-   * this day lies in the same month. </dd>\n-   * <dt><code>day &lt; 0, dayOfWeek = -Calendar.WEEKDAY</code></dt>\n-   * <dd>The start/end of daylight is on the first WEEKDAY on or\n-   * <i>before</i> the <code>-day</code>-th day of the month.  You\n-   * must make sure that this day lies in the same month. </dd>\n-   * </dl>\n-   *\n-   * If you give a non existing month, a day that is zero, or too big,\n-   * or a dayOfWeek that is too big,  the result is undefined.\n-   *\n-   * The start rule must have a different month than the end rule.\n-   * This restriction shouldn't hurt for all possible time zones.\n-   *\n-   * @param rawOffset The time offset from GMT in milliseconds.\n-   * @param id  The identifier of this time zone.\n-   * @param startMonth The start month of daylight savings; use the\n-   * constants in Calendar.\n-   * @param startday A day in month or a day of week number, as\n-   * described above.\n-   * @param startDayOfWeek The start rule day of week; see above.\n-   * @param startTime A time in millis in standard time.\n-   * @param endMonth The end month of daylight savings; use the\n-   * constants in Calendar.\n-   * @param endday A day in month or a day of week number, as\n-   * described above.\n-   * @param endDayOfWeek The end rule day of week; see above.\n-   * @param endTime A time in millis in standard time.\n-   * @throws IllegalArgumentException if parameters are invalid or out of\n-   * range.\n-   */\n-  public SimpleTimeZone(int rawOffset, String id, int startMonth,\n-                        int startDayOfWeekInMonth, int startDayOfWeek,\n-                        int startTime, int endMonth, int endDayOfWeekInMonth,\n-                        int endDayOfWeek, int endTime)\n-  {\n-    this.rawOffset = rawOffset;\n-    setID(id);\n-    useDaylight = true;\n-\n-    setStartRule(startMonth, startDayOfWeekInMonth, startDayOfWeek, startTime);\n-    setEndRule(endMonth, endDayOfWeekInMonth, endDayOfWeek, endTime);\n-    if (startMonth == endMonth)\n-      throw new IllegalArgumentException(\"startMonth and endMonth must be different\");\n-    this.startYear = 0;\n-  }\n-\n-  /**\n-   * This constructs a new SimpleTimeZone that supports a daylight savings\n-   * rule.  The parameter are the same as for the constructor above, except\n-   * there is the additional dstSavaings parameter.\n-   *\n-   * @param dstSavings the amount of savings for daylight savings\n-   * time in milliseconds.  This must be positive.\n-   * @since 1.2\n-   */\n-  public SimpleTimeZone(int rawOffset, String id, int startMonth,\n-                        int startDayOfWeekInMonth, int startDayOfWeek,\n-                        int startTime, int endMonth, int endDayOfWeekInMonth,\n-                        int endDayOfWeek, int endTime, int dstSavings)\n-  {\n-    this(rawOffset, id, startMonth, startDayOfWeekInMonth, startDayOfWeek,\n-         startTime, endMonth, endDayOfWeekInMonth, endDayOfWeek, endTime);\n-\n-    this.dstSavings = dstSavings;\n-  }\n-\n-  /**\n-   * This constructs a new SimpleTimeZone that supports a daylight savings\n-   * rule.  The parameter are the same as for the constructor above, except\n-   * there are the additional startTimeMode, endTimeMode, and dstSavings\n-   * parameters.\n-   *\n-   * @param startTimeMode the mode that start times are specified in.  One of\n-   * WALL_TIME, STANDARD_TIME, or UTC_TIME.\n-   * @param endTimeMode the mode that end times are specified in.  One of\n-   * WALL_TIME, STANDARD_TIME, or UTC_TIME.\n-   * @param dstSavings the amount of savings for daylight savings\n-   * time in milliseconds.  This must be positive.\n-   * @throws IllegalArgumentException if parameters are invalid or out of\n-   * range.\n-   * @since 1.4\n-   */\n-  public SimpleTimeZone(int rawOffset, String id, int startMonth,\n-                        int startDayOfWeekInMonth, int startDayOfWeek,\n-                        int startTime, int startTimeMode, int endMonth,\n-                        int endDayOfWeekInMonth, int endDayOfWeek,\n-                        int endTime, int endTimeMode, int dstSavings)\n-  {\n-    this.rawOffset = rawOffset;\n-    setID(id);\n-    useDaylight = true;\n-\n-    if (startTimeMode < WALL_TIME || startTimeMode > UTC_TIME)\n-      throw new IllegalArgumentException(\"startTimeMode must be one of WALL_TIME, STANDARD_TIME, or UTC_TIME\");\n-    if (endTimeMode < WALL_TIME || endTimeMode > UTC_TIME)\n-      throw new IllegalArgumentException(\"endTimeMode must be one of WALL_TIME, STANDARD_TIME, or UTC_TIME\");\n-    this.startTimeMode = startTimeMode;\n-    this.endTimeMode = endTimeMode;\n-\n-    setStartRule(startMonth, startDayOfWeekInMonth, startDayOfWeek, startTime);\n-    setEndRule(endMonth, endDayOfWeekInMonth, endDayOfWeek, endTime);\n-    if (startMonth == endMonth)\n-      throw new IllegalArgumentException(\"startMonth and endMonth must be different\");\n-    this.startYear = 0;\n-\n-    this.dstSavings = dstSavings;\n-  }\n-\n-  /**\n-   * Sets the first year, where daylight savings applies.  The daylight\n-   * savings rule never apply for years in the BC era.  Note that this\n-   * is gregorian calendar specific.\n-   * @param year the start year.\n-   */\n-  public void setStartYear(int year)\n-  {\n-    startYear = year;\n-    useDaylight = true;\n-  }\n-\n-  /**\n-   * Checks if the month, day, dayOfWeek arguments are in range and\n-   * returns the mode of the rule.\n-   * @param month the month parameter as in the constructor\n-   * @param day the day parameter as in the constructor\n-   * @param dayOfWeek the day of week parameter as in the constructor\n-   * @return the mode of this rule see startMode.\n-   * @exception IllegalArgumentException if parameters are out of range.\n-   * @see #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)\n-   * @see #startMode\n-   */\n-  private int checkRule(int month, int day, int dayOfWeek)\n-  {\n-    if (month < 0 || month > 11)\n-      throw new IllegalArgumentException(\"month out of range\");\n-\n-    int daysInMonth = getDaysInMonth(month, 1);\n-    if (dayOfWeek == 0)\n-      {\n-\tif (day <= 0 || day > daysInMonth)\n-\t  throw new IllegalArgumentException(\"day out of range\");\n-\treturn DOM_MODE;\n-      }\n-    else if (dayOfWeek > 0)\n-      {\n-\tif (Math.abs(day) > (daysInMonth + 6) / 7)\n-\t  throw new IllegalArgumentException(\"dayOfWeekInMonth out of range\");\n-\tif (dayOfWeek > Calendar.SATURDAY)\n-\t  throw new IllegalArgumentException(\"dayOfWeek out of range\");\n-\treturn DOW_IN_MONTH_MODE;\n-      }\n-    else\n-      {\n-\tif (day == 0 || Math.abs(day) > daysInMonth)\n-\t  throw new IllegalArgumentException(\"day out of range\");\n-\tif (dayOfWeek < -Calendar.SATURDAY)\n-\t  throw new IllegalArgumentException(\"dayOfWeek out of range\");\n-\tif (day < 0)\n-\t  return DOW_LE_DOM_MODE;\n-\telse\n-\t  return DOW_GE_DOM_MODE;\n-      }\n-  }\n-\n-  /**\n-   * Sets the daylight savings start rule.  You must also set the\n-   * end rule with <code>setEndRule</code> or the result of\n-   * getOffset is undefined.  For the parameters see the ten-argument\n-   * constructor above.\n-   *\n-   * @param month The month where daylight savings start, zero\n-   * based.  You should use the constants in Calendar.\n-   * @param day A day of month or day of week in month.\n-   * @param dayOfWeek The day of week where daylight savings start.\n-   * @param time The time in milliseconds standard time where daylight\n-   * savings start.\n-   * @see SimpleTimeZone\n-   */\n-  public void setStartRule(int month, int day, int dayOfWeek, int time)\n-  {\n-    this.startMode = checkRule(month, day, dayOfWeek);\n-    this.startMonth = month;\n-    this.startDay = day;\n-    this.startDayOfWeek = Math.abs(dayOfWeek);\n-    if (this.startTimeMode == WALL_TIME || this.startTimeMode == STANDARD_TIME)\n-      this.startTime = time;\n-    else\n-      // Convert from UTC to STANDARD\n-      this.startTime = time + this.rawOffset;\n-    useDaylight = true;\n-  }\n-\n-  /**\n-   * Sets the daylight savings start rule.  You must also set the\n-   * end rule with <code>setEndRule</code> or the result of\n-   * getOffset is undefined.  For the parameters see the ten-argument\n-   * constructor above.\n-   *\n-   * Note that this API isn't incredibly well specified.  It appears that the\n-   * after flag must override the parameters, since normally, the day and\n-   * dayofweek can select this.  I.e., if day < 0 and dayOfWeek < 0, on or\n-   * before mode is chosen.  But if after == true, this implementation\n-   * overrides the signs of the other arguments.  And if dayOfWeek == 0, it\n-   * falls back to the behavior in the other APIs.  I guess this should be\n-   * checked against Sun's implementation.\n-   *\n-   * @param month The month where daylight savings start, zero\n-   * based.  You should use the constants in Calendar.\n-   * @param day A day of month or day of week in month.\n-   * @param dayOfWeek The day of week where daylight savings start.\n-   * @param time The time in milliseconds standard time where daylight\n-   * savings start.\n-   * @param after If true, day and dayOfWeek specify first day of week on or\n-   * after day, else first day of week on or before.\n-   * @since 1.2\n-   * @see SimpleTimeZone\n-   */\n-  public void setStartRule(int month, int day, int dayOfWeek, int time,\n-                           boolean after)\n-  {\n-    // FIXME: XXX: Validate that checkRule and offset processing work with on\n-    // or before mode.\n-    this.startDay = after ? Math.abs(day) : -Math.abs(day);\n-    this.startDayOfWeek = after ? Math.abs(dayOfWeek) : -Math.abs(dayOfWeek);\n-    this.startMode = (dayOfWeek != 0)\n-                     ? (after ? DOW_GE_DOM_MODE : DOW_LE_DOM_MODE)\n-                     : checkRule(month, day, dayOfWeek);\n-    this.startDay = Math.abs(this.startDay);\n-    this.startDayOfWeek = Math.abs(this.startDayOfWeek);\n-\n-    this.startMonth = month;\n-\n-    if (this.startTimeMode == WALL_TIME || this.startTimeMode == STANDARD_TIME)\n-      this.startTime = time;\n-    else\n-      // Convert from UTC to STANDARD\n-      this.startTime = time + this.rawOffset;\n-    useDaylight = true;\n-  }\n-\n-  /**\n-   * Sets the daylight savings start rule.  You must also set the\n-   * end rule with <code>setEndRule</code> or the result of\n-   * getOffset is undefined.  For the parameters see the ten-argument\n-   * constructor above.\n-   *\n-   * @param month The month where daylight savings start, zero\n-   * based.  You should use the constants in Calendar.\n-   * @param day A day of month or day of week in month.\n-   * @param time The time in milliseconds standard time where daylight\n-   * savings start.\n-   * @see SimpleTimeZone\n-   * @since 1.2\n-   */\n-  public void setStartRule(int month, int day, int time)\n-  {\n-    setStartRule(month, day, 0, time);\n-  }\n-\n-  /**\n-   * Sets the daylight savings end rule.  You must also set the\n-   * start rule with <code>setStartRule</code> or the result of\n-   * getOffset is undefined. For the parameters see the ten-argument\n-   * constructor above.\n-   *\n-   * @param month The end month of daylight savings.\n-   * @param day A day in month, or a day of week in month.\n-   * @param dayOfWeek A day of week, when daylight savings ends.\n-   * @param time A time in millis in standard time.\n-   * @see #setStartRule\n-   */\n-  public void setEndRule(int month, int day, int dayOfWeek, int time)\n-  {\n-    this.endMode = checkRule(month, day, dayOfWeek);\n-    this.endMonth = month;\n-    this.endDay = day;\n-    this.endDayOfWeek = Math.abs(dayOfWeek);\n-    if (this.endTimeMode == WALL_TIME)\n-      this.endTime = time;\n-    else if (this.endTimeMode == STANDARD_TIME)\n-      // Convert from STANDARD to DST\n-      this.endTime = time + this.dstSavings;\n-    else\n-      // Convert from UTC to DST\n-      this.endTime = time + this.rawOffset + this.dstSavings;\n-    useDaylight = true;\n-  }\n-\n-  /**\n-   * Sets the daylight savings end rule.  You must also set the\n-   * start rule with <code>setStartRule</code> or the result of\n-   * getOffset is undefined. For the parameters see the ten-argument\n-   * constructor above.\n-   *\n-   * Note that this API isn't incredibly well specified.  It appears that the\n-   * after flag must override the parameters, since normally, the day and\n-   * dayofweek can select this.  I.e., if day < 0 and dayOfWeek < 0, on or\n-   * before mode is chosen.  But if after == true, this implementation\n-   * overrides the signs of the other arguments.  And if dayOfWeek == 0, it\n-   * falls back to the behavior in the other APIs.  I guess this should be\n-   * checked against Sun's implementation.\n-   *\n-   * @param month The end month of daylight savings.\n-   * @param day A day in month, or a day of week in month.\n-   * @param dayOfWeek A day of week, when daylight savings ends.\n-   * @param time A time in millis in standard time.\n-   * @param after If true, day and dayOfWeek specify first day of week on or\n-   * after day, else first day of week on or before.\n-   * @since 1.2\n-   * @see #setStartRule\n-   */\n-  public void setEndRule(int month, int day, int dayOfWeek, int time,\n-                         boolean after)\n-  {\n-    // FIXME: XXX: Validate that checkRule and offset processing work with on\n-    // or before mode.\n-    this.endDay = after ? Math.abs(day) : -Math.abs(day);\n-    this.endDayOfWeek = after ? Math.abs(dayOfWeek) : -Math.abs(dayOfWeek);\n-    this.endMode = (dayOfWeek != 0)\n-                   ? (after ? DOW_GE_DOM_MODE : DOW_LE_DOM_MODE)\n-                   : checkRule(month, day, dayOfWeek);\n-    this.endDay = Math.abs(this.endDay);\n-    this.endDayOfWeek = Math.abs(endDayOfWeek);\n-\n-    this.endMonth = month;\n-\n-    if (this.endTimeMode == WALL_TIME)\n-      this.endTime = time;\n-    else if (this.endTimeMode == STANDARD_TIME)\n-      // Convert from STANDARD to DST\n-      this.endTime = time + this.dstSavings;\n-    else\n-      // Convert from UTC to DST\n-      this.endTime = time + this.rawOffset + this.dstSavings;\n-    useDaylight = true;\n-  }\n-\n-  /**\n-   * Sets the daylight savings end rule.  You must also set the\n-   * start rule with <code>setStartRule</code> or the result of\n-   * getOffset is undefined. For the parameters see the ten-argument\n-   * constructor above.\n-   *\n-   * @param month The end month of daylight savings.\n-   * @param day A day in month, or a day of week in month.\n-   * @param dayOfWeek A day of week, when daylight savings ends.\n-   * @param time A time in millis in standard time.\n-   * @see #setStartRule\n-   */\n-  public void setEndRule(int month, int day, int time)\n-  {\n-    setEndRule(month, day, 0, time);\n-  }\n-\n-  /**\n-   * Gets the time zone offset, for current date, modified in case of\n-   * daylight savings.  This is the offset to add to UTC to get the local\n-   * time.\n-   *\n-   * In the standard JDK the results given by this method may result in\n-   * inaccurate results at the end of February or the beginning of March.\n-   * To avoid this, you should use Calendar instead:\n-   * <code>offset = cal.get(Calendar.ZONE_OFFSET)\n-   * + cal.get(Calendar.DST_OFFSET);</code>\n-   *\n-   * This version doesn't suffer this inaccuracy.\n-   *\n-   * The arguments don't follow the approach for setting start and end rules.\n-   * The day must be a positive number and dayOfWeek must be a positive value\n-   * from Calendar.  dayOfWeek is redundant, but must match the other values\n-   * or an inaccurate result may be returned.\n-   *\n-   * @param era the era of the given date\n-   * @param year the year of the given date\n-   * @param month the month of the given date, 0 for January.\n-   * @param day the day of month\n-   * @param dayOfWeek the day of week; this must match the other fields.\n-   * @param millis the millis in the day (in local standard time)\n-   * @return the time zone offset in milliseconds.\n-   * @throws IllegalArgumentException if arguments are incorrect.\n-   */\n-  public int getOffset(int era, int year, int month, int day, int dayOfWeek,\n-                       int millis)\n-  {\n-    int daysInMonth = getDaysInMonth(month, year);\n-    if (day < 1 || day > daysInMonth)\n-      throw new IllegalArgumentException(\"day out of range\");\n-    if (dayOfWeek < Calendar.SUNDAY || dayOfWeek > Calendar.SATURDAY)\n-      throw new IllegalArgumentException(\"dayOfWeek out of range\");\n-    if (month < Calendar.JANUARY || month > Calendar.DECEMBER)\n-      throw new IllegalArgumentException(\"month out of range:\" + month);\n-\n-    // This method is called by Calendar, so we mustn't use that class.\n-    int daylightSavings = 0;\n-    if (useDaylight && era == GregorianCalendar.AD && year >= startYear)\n-      {\n-\t// This does only work for Gregorian calendars :-(\n-\t// This is mainly because setStartYear doesn't take an era.\n-\tboolean afterStart = ! isBefore(year, month, day, dayOfWeek, millis,\n-\t                                startMode, startMonth, startDay,\n-\t                                startDayOfWeek, startTime);\n-\tboolean beforeEnd = isBefore(year, month, day, dayOfWeek,\n-\t\t\t\t     millis + dstSavings,\n-\t                             endMode, endMonth, endDay, endDayOfWeek,\n-\t                             endTime);\n-\n-\tif (startMonth < endMonth)\n-\t  // use daylight savings, if the date is after the start of\n-\t  // savings, and before the end of savings.\n-\t  daylightSavings = afterStart && beforeEnd ? dstSavings : 0;\n-\telse\n-\t  // use daylight savings, if the date is before the end of\n-\t  // savings, or after the start of savings.\n-\t  daylightSavings = beforeEnd || afterStart ? dstSavings : 0;\n-      }\n-    return rawOffset + daylightSavings;\n-  }\n-\n-  /**\n-   * Returns the time zone offset to GMT in milliseconds, ignoring\n-   * day light savings.\n-   * @return the time zone offset.\n-   */\n-  public int getRawOffset()\n-  {\n-    return rawOffset;\n-  }\n-\n-  /**\n-   * Sets the standard time zone offset to GMT.\n-   * @param rawOffset The time offset from GMT in milliseconds.\n-   */\n-  public void setRawOffset(int rawOffset)\n-  {\n-    this.rawOffset = rawOffset;\n-  }\n-\n-  /**\n-   * Gets the daylight savings offset.  This is a positive offset in\n-   * milliseconds with respect to standard time.  Typically this\n-   * is one hour, but for some time zones this may be half an our.\n-   * @return the daylight savings offset in milliseconds.\n-   *\n-   * @since 1.2\n-   */\n-  public int getDSTSavings()\n-  {\n-    return dstSavings;\n-  }\n-\n-  /**\n-   * Sets the daylight savings offset.  This is a positive offset in\n-   * milliseconds with respect to standard time.\n-   *\n-   * @param dstSavings the daylight savings offset in milliseconds.\n-   *\n-   * @since 1.2\n-   */\n-  public void setDSTSavings(int dstSavings)\n-  {\n-    if (dstSavings <= 0)\n-      throw new IllegalArgumentException(\"illegal value for dstSavings\");\n-\n-    this.dstSavings = dstSavings;\n-  }\n-\n-  /**\n-   * Returns if this time zone uses daylight savings time.\n-   * @return true, if we use daylight savings time, false otherwise.\n-   */\n-  public boolean useDaylightTime()\n-  {\n-    return useDaylight;\n-  }\n-\n-  /**\n-   * Returns the number of days in the given month.\n-   * Uses gregorian rules prior to 1582 (The default and earliest cutover)\n-   * @param month The month, zero based; use one of the Calendar constants.\n-   * @param year  The year.\n-   */\n-  private int getDaysInMonth(int month, int year)\n-  {\n-    if (month == Calendar.FEBRUARY)\n-      {\n-\tif ((year & 3) != 0)\n-\t  return 28;\n-\n-\t// Assume default Gregorian cutover, \n-\t// all years prior to this must be Julian\n-\tif (year < 1582)\n-\t  return 29;\n-\n-\t// Gregorian rules \n-\treturn ((year % 100) != 0 || (year % 400) == 0) ? 29 : 28;\n-      }\n-    else\n-      return monthArr[month];\n-  }\n-\n-  /**\n-   * Checks if the date given in calXXXX, is before the change between\n-   * dst and standard time.\n-   * @param calYear the year of the date to check (for leap day checking).\n-   * @param calMonth the month of the date to check.\n-   * @param calDay the day of month of the date to check.\n-   * @param calDayOfWeek the day of week of the date to check.\n-   * @param calMillis the millis of day of the date to check (standard time).\n-   * @param mode  the change mode; same semantic as startMode.\n-   * @param month the change month; same semantic as startMonth.\n-   * @param day   the change day; same semantic as startDay.\n-   * @param dayOfWeek the change day of week;\n-   * @param millis the change time in millis since midnight standard time.\n-   * same semantic as startDayOfWeek.\n-   * @return true, if cal is before the change, false if cal is on\n-   * or after the change.\n-   */\n-  private boolean isBefore(int calYear, int calMonth, int calDayOfMonth,\n-                           int calDayOfWeek, int calMillis, int mode,\n-                           int month, int day, int dayOfWeek, int millis)\n-  {\n-    // This method is called by Calendar, so we mustn't use that class.\n-    // We have to do all calculations by hand.\n-    // check the months:\n-    // XXX - this is not correct:\n-    // for the DOW_GE_DOM and DOW_LE_DOM modes the change date may\n-    // be in a different month.\n-    if (calMonth != month)\n-      return calMonth < month;\n-\n-    // check the day:\n-    switch (mode)\n-      {\n-      case DOM_MODE:\n-\tif (calDayOfMonth != day)\n-\t  return calDayOfMonth < day;\n-\tbreak;\n-      case DOW_IN_MONTH_MODE:\n-        {\n-\t  // This computes the day of month of the day of type\n-\t  // \"dayOfWeek\" that lies in the same (sunday based) week as cal.\n-\t  calDayOfMonth += (dayOfWeek - calDayOfWeek);\n-\n-\t  // Now we convert it to 7 based number (to get a one based offset\n-\t  // after dividing by 7).  If we count from the end of the\n-\t  // month, we get want a -7 based number counting the days from \n-\t  // the end:\n-\t  if (day < 0)\n-\t    calDayOfMonth -= getDaysInMonth(calMonth, calYear) + 7;\n-\t  else\n-\t    calDayOfMonth += 6;\n-\n-\t  //  day > 0                    day < 0\n-\t  //  S  M  T  W  T  F  S        S  M  T  W  T  F  S\n-\t  //     7  8  9 10 11 12         -36-35-34-33-32-31\n-\t  // 13 14 15 16 17 18 19      -30-29-28-27-26-25-24\n-\t  // 20 21 22 23 24 25 26      -23-22-21-20-19-18-17\n-\t  // 27 28 29 30 31 32 33      -16-15-14-13-12-11-10\n-\t  // 34 35 36                   -9 -8 -7\n-\t  // Now we calculate the day of week in month:\n-\t  int week = calDayOfMonth / 7;\n-\n-\t  //  day > 0                    day < 0\n-\t  //  S  M  T  W  T  F  S        S  M  T  W  T  F  S\n-\t  //     1  1  1  1  1  1          -5 -5 -4 -4 -4 -4\n-\t  //  1  2  2  2  2  2  2       -4 -4 -4 -3 -3 -3 -3\n-\t  //  2  3  3  3  3  3  3       -3 -3 -3 -2 -2 -2 -2\n-\t  //  3  4  4  4  4  4  4       -2 -2 -2 -1 -1 -1 -1\n-\t  //  4  5  5                   -1 -1 -1\n-\t  if (week != day)\n-\t    return week < day;\n-\n-\t  if (calDayOfWeek != dayOfWeek)\n-\t    return calDayOfWeek < dayOfWeek;\n-\n-\t  // daylight savings starts/ends  on the given day.\n-\t  break;\n-        }\n-      case DOW_LE_DOM_MODE:\n-\t// The greatest sunday before or equal December, 12\n-\t// is the same as smallest sunday after or equal December, 6.\n-\tday = Math.abs(day) - 6;\n-      case DOW_GE_DOM_MODE:\n-\t// Calculate the day of month of the day of type\n-\t// \"dayOfWeek\" that lies before (or on) the given date.\n-\tcalDayOfMonth -= (calDayOfWeek < dayOfWeek ? 7 : 0) + calDayOfWeek\n-\t- dayOfWeek;\n-\tif (calDayOfMonth < day)\n-\t  return true;\n-\tif (calDayOfWeek != dayOfWeek || calDayOfMonth >= day + 7)\n-\t  return false;\n-\n-\t// now we have the same day\n-\tbreak;\n-      }\n-\n-    // the millis decides:\n-    return (calMillis < millis);\n-  }\n-\n-  /**\n-   * Determines if the given date is in daylight savings time.\n-   * @return true, if it is in daylight savings time, false otherwise.\n-   */\n-  public boolean inDaylightTime(Date date)\n-  {\n-    Calendar cal = Calendar.getInstance(this);\n-    cal.setTime(date);\n-    return (cal.get(Calendar.DST_OFFSET) != 0);\n-  }\n-\n-  /**\n-   * Generates the hashCode for the SimpleDateFormat object.  It is\n-   * the rawOffset, possibly, if useDaylightSavings is true, xored\n-   * with startYear, startMonth, startDayOfWeekInMonth, ..., endTime.\n-   */\n-  public synchronized int hashCode()\n-  {\n-    return rawOffset\n-           ^ (useDaylight\n-              ? startMonth ^ startDay ^ startDayOfWeek ^ startTime ^ endMonth\n-              ^ endDay ^ endDayOfWeek ^ endTime : 0);\n-  }\n-\n-  public synchronized boolean equals(Object o)\n-  {\n-    if (this == o)\n-      return true;\n-    if (! (o instanceof SimpleTimeZone))\n-      return false;\n-    SimpleTimeZone zone = (SimpleTimeZone) o;\n-    if (zone.hashCode() != hashCode() || ! getID().equals(zone.getID())\n-        || rawOffset != zone.rawOffset || useDaylight != zone.useDaylight)\n-      return false;\n-    if (! useDaylight)\n-      return true;\n-    return (startYear == zone.startYear && startMonth == zone.startMonth\n-           && startDay == zone.startDay\n-           && startDayOfWeek == zone.startDayOfWeek\n-           && startTime == zone.startTime\n-           && startTimeMode == zone.startTimeMode && endMonth == zone.endMonth\n-           && endDay == zone.endDay && endDayOfWeek == zone.endDayOfWeek\n-           && endTime == zone.endTime && endTimeMode == zone.endTimeMode);\n-  }\n-\n-  /**\n-   * Test if the other time zone uses the same rule and only\n-   * possibly differs in ID.  This implementation for this particular\n-   * class will return true if the other object is a SimpleTimeZone,\n-   * the raw offsets and useDaylight are identical and if useDaylight\n-   * is true, also the start and end datas are identical.\n-   * @return true if this zone uses the same rule.\n-   */\n-  public boolean hasSameRules(TimeZone other)\n-  {\n-    if (this == other)\n-      return true;\n-    if (! (other instanceof SimpleTimeZone))\n-      return false;\n-    SimpleTimeZone zone = (SimpleTimeZone) other;\n-    if (zone.hashCode() != hashCode() || rawOffset != zone.rawOffset\n-        || useDaylight != zone.useDaylight)\n-      return false;\n-    if (! useDaylight)\n-      return true;\n-    return (startYear == zone.startYear && startMonth == zone.startMonth\n-           && startDay == zone.startDay\n-           && startDayOfWeek == zone.startDayOfWeek\n-           && startTime == zone.startTime\n-           && startTimeMode == zone.startTimeMode && endMonth == zone.endMonth\n-           && endDay == zone.endDay && endDayOfWeek == zone.endDayOfWeek\n-           && endTime == zone.endTime && endTimeMode == zone.endTimeMode);\n-  }\n-\n-  /**\n-   * Returns a string representation of this SimpleTimeZone object.\n-   * @return a string representation of this SimpleTimeZone object.\n-   */\n-  public String toString()\n-  {\n-    // the test for useDaylight is an incompatibility to jdk1.2, but\n-    // I think this shouldn't hurt.\n-    return getClass().getName() + \"[\" + \"id=\" + getID() + \",offset=\"\n-           + rawOffset + \",dstSavings=\" + dstSavings + \",useDaylight=\"\n-           + useDaylight\n-           + (useDaylight\n-              ? \",startYear=\" + startYear + \",startMode=\" + startMode\n-              + \",startMonth=\" + startMonth + \",startDay=\" + startDay\n-              + \",startDayOfWeek=\" + startDayOfWeek + \",startTime=\"\n-              + startTime + \",startTimeMode=\" + startTimeMode + \",endMode=\"\n-              + endMode + \",endMonth=\" + endMonth + \",endDay=\" + endDay\n-              + \",endDayOfWeek=\" + endDayOfWeek + \",endTime=\" + endTime\n-              + \",endTimeMode=\" + endTimeMode : \"\") + \"]\";\n-  }\n-\n-  /**\n-   * Reads a serialized simple time zone from stream.\n-   * @see #writeObject\n-   */\n-  private void readObject(java.io.ObjectInputStream input)\n-    throws java.io.IOException, ClassNotFoundException\n-  {\n-    input.defaultReadObject();\n-    if (serialVersionOnStream == 0)\n-      {\n-\t// initialize the new fields to default values.\n-\tdstSavings = 60 * 60 * 1000;\n-\tendMode = DOW_IN_MONTH_MODE;\n-\tstartMode = DOW_IN_MONTH_MODE;\n-\tstartTimeMode = WALL_TIME;\n-\tendTimeMode = WALL_TIME;\n-\tserialVersionOnStream = 2;\n-      }\n-    else\n-      {\n-\tint length = input.readInt();\n-\tbyte[] byteArray = new byte[length];\n-\tinput.read(byteArray, 0, length);\n-\tif (length >= 4)\n-\t  {\n-\t    // Lets hope that Sun does extensions to the serialized\n-\t    // form in a sane manner.\n-\t    startDay = byteArray[0];\n-\t    startDayOfWeek = byteArray[1];\n-\t    endDay = byteArray[2];\n-\t    endDayOfWeek = byteArray[3];\n-\t  }\n-      }\n-  }\n-\n-  /**\n-   * Serializes this object to a stream.  @serialdata The object is\n-   * first written in the old JDK 1.1 format, so that it can be read\n-   * by by the old classes.  This means, that the\n-   * <code>start/endDay(OfWeek)</code>-Fields are written in the\n-   * DOW_IN_MONTH_MODE rule, since this was the only supported rule\n-   * in 1.1.\n-   *\n-   * In the optional section, we write first the length of an byte\n-   * array as int and afterwards the byte array itself.  The byte\n-   * array contains in this release four elements, namely the real\n-   * startDay, startDayOfWeek endDay, endDayOfWeek in that Order.\n-   * These fields are needed, because for compatibility reasons only\n-   * approximative values are written to the required section, as\n-   * described above.\n-   */\n-  private void writeObject(java.io.ObjectOutputStream output)\n-    throws java.io.IOException\n-  {\n-    byte[] byteArray = new byte[]\n-                       {\n-                         (byte) startDay, (byte) startDayOfWeek, (byte) endDay,\n-                         (byte) endDayOfWeek\n-                       };\n-\n-    /* calculate the approximation for JDK 1.1 */\n-    switch (startMode)\n-      {\n-      case DOM_MODE:\n-\tstartDayOfWeek = Calendar.SUNDAY; // random day of week\n-\n-      // fall through\n-      case DOW_GE_DOM_MODE:\n-      case DOW_LE_DOM_MODE:\n-\tstartDay = (startDay + 6) / 7;\n-      }\n-    switch (endMode)\n-      {\n-      case DOM_MODE:\n-\tendDayOfWeek = Calendar.SUNDAY;\n-\n-      // fall through\n-      case DOW_GE_DOM_MODE:\n-      case DOW_LE_DOM_MODE:\n-\tendDay = (endDay + 6) / 7;\n-      }\n-\n-    // the required part:\n-    output.defaultWriteObject();\n-    // the optional part:\n-    output.writeInt(byteArray.length);\n-    output.write(byteArray, 0, byteArray.length);\n-  }\n-}"}, {"sha": "f9b83ae6f5dd751a93aaa0f1f4ef505fa70dca7c", "filename": "libjava/sources.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46f32b2b9096aef6888b3a1882d88467b845e5fe/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46f32b2b9096aef6888b3a1882d88467b845e5fe/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=46f32b2b9096aef6888b3a1882d88467b845e5fe", "patch": "@@ -3660,7 +3660,7 @@ classpath/java/util/Collections.java \\\n classpath/java/util/Comparator.java \\\n classpath/java/util/ConcurrentModificationException.java \\\n java/util/Currency.java \\\n-java/util/Date.java \\\n+classpath/java/util/Date.java \\\n classpath/java/util/Dictionary.java \\\n classpath/java/util/EmptyStackException.java \\\n classpath/java/util/Enumeration.java \\\n@@ -3695,7 +3695,7 @@ classpath/java/util/Random.java \\\n classpath/java/util/RandomAccess.java \\\n java/util/ResourceBundle.java \\\n classpath/java/util/Set.java \\\n-java/util/SimpleTimeZone.java \\\n+classpath/java/util/SimpleTimeZone.java \\\n classpath/java/util/SortedMap.java \\\n classpath/java/util/SortedSet.java \\\n classpath/java/util/Stack.java \\"}]}