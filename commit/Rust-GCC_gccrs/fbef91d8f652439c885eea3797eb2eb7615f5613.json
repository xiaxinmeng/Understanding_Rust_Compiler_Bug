{"sha": "fbef91d8f652439c885eea3797eb2eb7615f5613", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJlZjkxZDhmNjUyNDM5Yzg4NWVlYTM3OTdlYjJlYjc2MTVmNTYxMw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-02-07T19:17:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-02-07T19:17:20Z"}, "message": "gcse.c (implicit_sets): New.\n\n        * gcse.c (implicit_sets): New.\n        (compute_hash_table_work): Include them in hash table.\n        (find_implicit_sets, fis_get_condition): New.\n        (one_cprop_pass): Allocate and free implicit_sets; call\n        find_implicit_sets before building hash table.\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r62533", "tree": {"sha": "5bf0c033f52426a60490362de2b8afed7e53f3e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bf0c033f52426a60490362de2b8afed7e53f3e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbef91d8f652439c885eea3797eb2eb7615f5613", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbef91d8f652439c885eea3797eb2eb7615f5613", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbef91d8f652439c885eea3797eb2eb7615f5613", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbef91d8f652439c885eea3797eb2eb7615f5613/comments", "author": null, "committer": null, "parents": [{"sha": "d5525e93c0bb72bf997e5161ff758117d897a96a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5525e93c0bb72bf997e5161ff758117d897a96a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5525e93c0bb72bf997e5161ff758117d897a96a"}], "stats": {"total": 141, "additions": 140, "deletions": 1}, "files": [{"sha": "3bda14a013a1109e571737eaed932302e8c176cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbef91d8f652439c885eea3797eb2eb7615f5613/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbef91d8f652439c885eea3797eb2eb7615f5613/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbef91d8f652439c885eea3797eb2eb7615f5613", "patch": "@@ -1,3 +1,12 @@\n+2003-02-07  Roger Sayle  <roger@eyesopen.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* gcse.c (implicit_sets): New.\n+\t(compute_hash_table_work): Include them in hash table.\n+\t(find_implicit_sets, fis_get_condition): New.\n+\t(one_cprop_pass): Allocate and free implicit_sets; call\n+\tfind_implicit_sets before building hash table.\n+\n 2003-02-07  Jason Thorpe  <thorpej@wasabisystems.com>\n \n \t* config/t-netbsd (USER_H): Revert previous change."}, {"sha": "3adaf5ca0ac864ef84f088e16ed35a4c142c58b9", "filename": "gcc/gcse.c", "status": "modified", "additions": 131, "deletions": 1, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbef91d8f652439c885eea3797eb2eb7615f5613/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbef91d8f652439c885eea3797eb2eb7615f5613/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=fbef91d8f652439c885eea3797eb2eb7615f5613", "patch": "@@ -479,6 +479,9 @@ struct ls_expr\n   rtx reaching_reg;\t\t/* Register to use when re-writing.  */\n };\n \n+/* Array of implicit set patterns indexed by basic block index.  */\n+static rtx *implicit_sets;\n+\n /* Head of the list of load/store memory refs.  */\n static struct ls_expr * pre_ldst_mems = NULL;\n \n@@ -614,6 +617,8 @@ static int load_killed_in_block_p    PARAMS ((basic_block, int, rtx, int));\n static void canon_list_insert        PARAMS ((rtx, rtx, void *));\n static int cprop_insn\t\tPARAMS ((rtx, int));\n static int cprop\t\tPARAMS ((int));\n+static rtx fis_get_condition\tPARAMS ((rtx));\n+static void find_implicit_sets\tPARAMS ((void));\n static int one_cprop_pass\tPARAMS ((int, int, int));\n static bool constprop_register\tPARAMS ((rtx, rtx, rtx, int));\n static struct expr *find_bypass_set PARAMS ((int, int));\n@@ -2470,7 +2475,6 @@ record_last_set_info (dest, setter, data)\n \n    Currently src must be a pseudo-reg or a const_int.\n \n-   F is the first insn.\n    TABLE is the table computed.  */\n \n static void\n@@ -2532,6 +2536,12 @@ compute_hash_table_work (table)\n \t  note_stores (PATTERN (insn), record_last_set_info, insn);\n \t}\n \n+      /* Insert implicit sets in the hash table.  */\n+      if (table->set_p\n+\t  && implicit_sets[current_bb->index] != NULL_RTX)\n+\thash_scan_set (implicit_sets[current_bb->index],\n+\t\t       current_bb->head, table);\n+\n       /* The next pass builds the hash table.  */\n \n       for (insn = current_bb->head, in_libcall_block = 0;\n@@ -4478,6 +4488,117 @@ cprop (alter_jumps)\n   return changed;\n }\n \n+/* Similar to get_condition, only the resulting condition must be\n+   valid at JUMP, instead of at EARLIEST.\n+\n+   This differs from noce_get_condition in ifcvt.c in that we prefer not to\n+   settle for the condition variable in the jump instruction being integral.\n+   We prefer to be able to record the value of a user variable, rather than\n+   the value of a temporary used in a condition.  This could be solved by\n+   recording the value of *every* register scaned by canonicalize_condition,\n+   but this would require some code reorganization.  */\n+\n+static rtx\n+fis_get_condition (jump)\n+     rtx jump;\n+{\n+  rtx cond, set, tmp, insn, earliest;\n+  bool reverse;\n+\n+  if (! any_condjump_p (jump))\n+    return NULL_RTX;\n+\n+  set = pc_set (jump);\n+  cond = XEXP (SET_SRC (set), 0);\n+\n+  /* If this branches to JUMP_LABEL when the condition is false,\n+     reverse the condition.  */\n+  reverse = (GET_CODE (XEXP (SET_SRC (set), 2)) == LABEL_REF\n+\t     && XEXP (XEXP (SET_SRC (set), 2), 0) == JUMP_LABEL (jump));\n+\n+  /* Use canonicalize_condition to do the dirty work of manipulating\n+     MODE_CC values and COMPARE rtx codes.  */\n+  tmp = canonicalize_condition (jump, cond, reverse, &earliest, NULL_RTX);\n+  if (!tmp)\n+    return NULL_RTX;\n+\n+  /* Verify that the given condition is valid at JUMP by virtue of not\n+     having been modified since EARLIEST.  */\n+  for (insn = earliest; insn != jump; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn) && modified_in_p (tmp, insn))\n+      break;\n+  if (insn == jump)\n+    return tmp;\n+\n+  /* The condition was modified.  See if we can get a partial result\n+     that doesn't follow all the reversals.  Perhaps combine can fold\n+     them together later.  */\n+  tmp = XEXP (tmp, 0);\n+  if (!REG_P (tmp) || GET_MODE_CLASS (GET_MODE (tmp)) != MODE_INT)\n+    return NULL_RTX;\n+  tmp = canonicalize_condition (jump, cond, reverse, &earliest, tmp);\n+  if (!tmp)\n+    return NULL_RTX;\n+\n+  /* For sanity's sake, re-validate the new result.  */\n+  for (insn = earliest; insn != jump; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn) && modified_in_p (tmp, insn))\n+      return NULL_RTX;\n+\n+  return tmp;\n+}\n+\n+/* Find the implicit sets of a function.  An \"implicit set\" is a constraint\n+   on the value of a variable, implied by a conditional jump.  For example,\n+   following \"if (x == 2)\", the then branch may be optimized as though the\n+   conditional performed an \"explicit set\", in this example, \"x = 2\".  This\n+   function records the set patterns that are implicit at the start of each\n+   basic block.  */\n+\n+static void\n+find_implicit_sets ()\n+{\n+  basic_block bb, dest;\n+  unsigned int count;\n+  rtx cond, new;\n+\n+  count = 0;\n+  FOR_EACH_BB (bb)\n+    /* Check for more than one sucessor.  */\n+    if (bb->succ && bb->succ->succ_next)\n+      {\n+\tcond = fis_get_condition (bb->end);\n+\n+\tif (cond\n+\t    && (GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n+\t    && GET_CODE (XEXP (cond, 0)) == REG\n+\t    && REGNO (XEXP (cond, 0)) >= FIRST_PSEUDO_REGISTER\n+\t    && CONSTANT_P (XEXP (cond, 1)))\n+\t  {\n+\t    dest = GET_CODE (cond) == EQ ? BRANCH_EDGE (bb)->dest\n+\t\t\t\t\t : FALLTHRU_EDGE (bb)->dest;\n+\n+\t    if (dest && ! dest->pred->pred_next\n+\t\t&& dest != EXIT_BLOCK_PTR)\n+\t      {\n+\t\tnew = gen_rtx_SET (VOIDmode, XEXP (cond, 0),\n+\t\t\t\t\t     XEXP (cond, 1));\n+\t\timplicit_sets[dest->index] = new;\n+\t\tif (gcse_file)\n+\t\t  {\n+\t\t    fprintf(gcse_file, \"Implicit set of reg %d in \",\n+\t\t\t    REGNO (XEXP (cond, 0)));\n+\t\t    fprintf(gcse_file, \"basic block %d\\n\", dest->index);\n+\t\t  }\n+\t\tcount++;\n+\t      }\n+\t  }\n+      }\n+\n+  if (gcse_file)\n+    fprintf (gcse_file, \"Found %d implicit sets\\n\", count);\n+}\n+\n /* Perform one copy/constant propagation pass.\n    PASS is the pass count.  If CPROP_JUMPS is true, perform constant\n    propagation into conditional jumps.  If BYPASS_JUMPS is true,\n@@ -4496,8 +4617,17 @@ one_cprop_pass (pass, cprop_jumps, bypass_jumps)\n \n   local_cprop_pass (cprop_jumps);\n \n+  /* Determine implicit sets.  */\n+  implicit_sets = (rtx *) xcalloc (last_basic_block, sizeof (rtx));\n+  find_implicit_sets ();\n+\n   alloc_hash_table (max_cuid, &set_hash_table, 1);\n   compute_hash_table (&set_hash_table);\n+\n+  /* Free implicit_sets before peak usage.  */\n+  free (implicit_sets);\n+  implicit_sets = NULL;\n+\n   if (gcse_file)\n     dump_hash_table (gcse_file, \"SET\", &set_hash_table);\n   if (set_hash_table.n_elems > 0)"}]}