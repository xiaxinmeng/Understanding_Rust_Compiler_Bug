{"sha": "eaf6e63a647b8604de960d2fa992c7dd57a5d553", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFmNmU2M2E2NDdiODYwNGRlOTYwZDJmYTk5MmM3ZGQ1N2E1ZDU1Mw==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2020-06-09T23:04:56Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-16T09:18:10Z"}, "message": "[Ada] Adjust heuristics about size of static aggregates\n\ngcc/ada/\n\n\t* exp_aggr.adb (Max_Aggregate_Size): Use the small size of 64\n\twhen copying is needed (for example, for the initialization of a\n\tlocal variable, and for assignment statements). Use the larger\n\tsize when static allocation can be done without copying.", "tree": {"sha": "e8787ac833c1f8a88074e1aab8f9a449bd6e333a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8787ac833c1f8a88074e1aab8f9a449bd6e333a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaf6e63a647b8604de960d2fa992c7dd57a5d553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaf6e63a647b8604de960d2fa992c7dd57a5d553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaf6e63a647b8604de960d2fa992c7dd57a5d553", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaf6e63a647b8604de960d2fa992c7dd57a5d553/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7a8be8a1919661122a8ac87c595e1267a1ee3d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7a8be8a1919661122a8ac87c595e1267a1ee3d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7a8be8a1919661122a8ac87c595e1267a1ee3d5"}], "stats": {"total": 96, "additions": 77, "deletions": 19}, "files": [{"sha": "0ca1af4abfa862a144a508394e1e67ca31a81e59", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 77, "deletions": 19, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf6e63a647b8604de960d2fa992c7dd57a5d553/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf6e63a647b8604de960d2fa992c7dd57a5d553/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=eaf6e63a647b8604de960d2fa992c7dd57a5d553", "patch": "@@ -252,7 +252,7 @@ package body Exp_Aggr is\n    function Aggr_Assignment_OK_For_Backend (N : Node_Id) return Boolean;\n    --  Returns true if an aggregate assignment can be done by the back end\n \n-   function Aggr_Size_OK (N : Node_Id; Typ : Entity_Id) return Boolean;\n+   function Aggr_Size_OK (N : Node_Id) return Boolean;\n    --  Very large static aggregates present problems to the back-end, and are\n    --  transformed into assignments and loops. This function verifies that the\n    --  total number of components of an aggregate is acceptable for rewriting\n@@ -328,10 +328,10 @@ package body Exp_Aggr is\n    --  is a two dimensional bit packed array with component size 1, 2, or 4.\n \n    function Max_Aggregate_Size\n-     (Typ          : Entity_Id;\n+     (N            : Node_Id;\n       Default_Size : Nat := 5000) return Nat;\n-   --  Return the max size for a static aggregate of the given Typ.\n-   --  Return Default_Size if no other special criteria trigger.\n+   --  Return the max size for a static aggregate N. Return Default_Size if no\n+   --  other special criteria trigger.\n \n    function Packed_Array_Aggregate_Handled (N : Node_Id) return Boolean;\n    --  Given an array aggregate, this function handles the case of a packed\n@@ -593,7 +593,8 @@ package body Exp_Aggr is\n    -- Aggr_Size_OK --\n    ------------------\n \n-   function Aggr_Size_OK (N : Node_Id; Typ : Entity_Id) return Boolean is\n+   function Aggr_Size_OK (N : Node_Id) return Boolean is\n+      Typ  : constant Entity_Id := Etype (N);\n       Lo   : Node_Id;\n       Hi   : Node_Id;\n       Indx : Node_Id;\n@@ -688,9 +689,9 @@ package body Exp_Aggr is\n       if No (Expressions (N))\n         and then No (Next (First (Component_Associations (N))))\n       then\n-         Max_Aggr_Size := Max_Aggregate_Size (Typ);\n+         Max_Aggr_Size := Max_Aggregate_Size (N);\n       else\n-         Max_Aggr_Size := Max_Aggregate_Size (Typ, 500_000);\n+         Max_Aggr_Size := Max_Aggregate_Size (N, 500_000);\n       end if;\n \n       Size := UI_From_Int (Component_Count (Component_Type (Typ)));\n@@ -4955,7 +4956,7 @@ package body Exp_Aggr is\n    is\n       Typ                  : constant Entity_Id := Etype (N);\n       Dims                 : constant Nat := Number_Dimensions (Typ);\n-      Max_Others_Replicate : constant Nat := Max_Aggregate_Size (Typ);\n+      Max_Others_Replicate : constant Nat := Max_Aggregate_Size (N);\n \n       Static_Components : Boolean := True;\n \n@@ -5475,7 +5476,7 @@ package body Exp_Aggr is\n       --  compatible with the upper bound of the type, and therefore it is\n       --  worth flattening such aggregates as well.\n \n-      if Aggr_Size_OK (N, Typ)\n+      if Aggr_Size_OK (N)\n         and then\n           Flatten (N, Dims, First_Index (Typ), First_Index (Base_Type (Typ)))\n       then\n@@ -8315,8 +8316,69 @@ package body Exp_Aggr is\n    ------------------------\n \n    function Max_Aggregate_Size\n-     (Typ          : Entity_Id;\n-      Default_Size : Nat := 5000) return Nat is\n+     (N            : Node_Id;\n+      Default_Size : Nat := 5000) return Nat\n+   is\n+      Typ : constant Entity_Id := Etype (N);\n+\n+      function Use_Small_Size (N : Node_Id) return Boolean;\n+      --  True if we should return a very small size, which means large\n+      --  aggregates will be implemented as a loop when possible (potentially\n+      --  transformed to memset calls).\n+\n+      function Aggr_Context (N : Node_Id) return Node_Id;\n+      --  Return the context in which the aggregate appears, not counting\n+      --  qualified expressions and similar.\n+\n+      function Aggr_Context (N : Node_Id) return Node_Id is\n+         Result : Node_Id := Parent (N);\n+      begin\n+         if Nkind_In (Result, N_Qualified_Expression,\n+                              N_Type_Conversion,\n+                              N_Unchecked_Type_Conversion,\n+                              N_If_Expression,\n+                              N_Case_Expression,\n+                              N_Component_Association,\n+                              N_Aggregate)\n+         then\n+            Result := Aggr_Context (Result);\n+         end if;\n+\n+         return Result;\n+      end Aggr_Context;\n+\n+      function Use_Small_Size (N : Node_Id) return Boolean is\n+         C : constant Node_Id := Aggr_Context (N);\n+         --  The decision depends on the context in which the aggregate occurs,\n+         --  and for variable declarations, whether we are nested inside a\n+         --  subprogram.\n+      begin\n+         case Nkind (C) is\n+            --  True for assignment statements and similar\n+\n+            when N_Assignment_Statement\n+               | N_Simple_Return_Statement\n+               | N_Allocator\n+               | N_Attribute_Reference\n+            =>\n+               return True;\n+\n+            --  True for nested variable declarations. False for library level\n+            --  variables, and for constants (whether or not nested).\n+\n+            when N_Object_Declaration =>\n+               return not Constant_Present (C)\n+                 and then Ekind (Current_Scope) in Subprogram_Kind;\n+\n+            --  False for all other contexts\n+\n+            when others =>\n+               return False;\n+         end case;\n+      end Use_Small_Size;\n+\n+   --  Start of processing for Max_Aggregate_Size\n+\n    begin\n       --  We use a small limit in CodePeer mode where we favor loops\n       --  instead of thousands of single assignments (from large aggregates).\n@@ -8332,10 +8394,6 @@ package body Exp_Aggr is\n       --  if components are static it is much more efficient to construct a\n       --  one-dimensional equivalent array with static components.\n \n-      --  Finally we also use a small limit when we're within a subprogram\n-      --  since we want to favor loops (potentially transformed to memset\n-      --  calls) in this context.\n-\n       if CodePeer_Mode then\n          return 100;\n       elsif Restriction_Active (No_Elaboration_Code)\n@@ -8345,11 +8403,11 @@ package body Exp_Aggr is\n                    and then Static_Elaboration_Desired (Current_Scope))\n       then\n          return 2 ** 24;\n-      elsif Ekind (Current_Scope) in Subprogram_Kind then\n+      elsif Use_Small_Size (N) then\n          return 64;\n-      else\n-         return Default_Size;\n       end if;\n+\n+      return Default_Size;\n    end Max_Aggregate_Size;\n \n    -----------------------\n@@ -9153,7 +9211,7 @@ package body Exp_Aggr is\n                   return False;\n                end if;\n \n-               if not Aggr_Size_OK (N, Typ) then\n+               if not Aggr_Size_OK (N) then\n                   return False;\n                end if;\n "}]}