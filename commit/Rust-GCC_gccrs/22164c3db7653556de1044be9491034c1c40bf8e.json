{"sha": "22164c3db7653556de1044be9491034c1c40bf8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIxNjRjM2RiNzY1MzU1NmRlMTA0NGJlOTQ5MTAzNGMxYzQwYmY4ZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2007-12-03T22:38:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2007-12-03T22:38:28Z"}, "message": "re PR middle-end/29749 (Missing byte swap optimizations)\n\n\tPR middle-end/29749\n\t* fold-const.c (fold_binary) <case BIT_AND_EXPR>: Optimize\n\t(X << C1) & C2 into (X << C1) & (C2 | ((1 << C1) - 1))\n\tand (X >> C1) & C2 into (X >> C1) & (C2 | ~((type) -1 >> C1)).\n\t(fold_binary) <case LSHIFT_EXPR, case RSHIFT_EXPR>: Optimize\n\t(X & C2) << C1 into (X << C1) & (C2 << C1) and\n\t(X & C2) >> C1 into (X >> C1) & (C2 >> C1) if that allows further\n\toptimizations.\n\n\t* gcc.dg/fold-rotate-1.c: New test.\n\nFrom-SVN: r130589", "tree": {"sha": "be824c8293ea6a41f93ef21d3fef35ab8fdd8e00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be824c8293ea6a41f93ef21d3fef35ab8fdd8e00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22164c3db7653556de1044be9491034c1c40bf8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22164c3db7653556de1044be9491034c1c40bf8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22164c3db7653556de1044be9491034c1c40bf8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22164c3db7653556de1044be9491034c1c40bf8e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "36ad7922cbf93f3601ab81b6b4d332fddf575a9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36ad7922cbf93f3601ab81b6b4d332fddf575a9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36ad7922cbf93f3601ab81b6b4d332fddf575a9f"}], "stats": {"total": 199, "additions": 199, "deletions": 0}, "files": [{"sha": "4e16b73f7b0161899e817807f86831705f4de232", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22164c3db7653556de1044be9491034c1c40bf8e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22164c3db7653556de1044be9491034c1c40bf8e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22164c3db7653556de1044be9491034c1c40bf8e", "patch": "@@ -1,5 +1,14 @@\n 2007-12-03  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/29749\n+\t* fold-const.c (fold_binary) <case BIT_AND_EXPR>: Optimize\n+\t(X << C1) & C2 into (X << C1) & (C2 | ((1 << C1) - 1))\n+\tand (X >> C1) & C2 into (X >> C1) & (C2 | ~((type) -1 >> C1)).\n+\t(fold_binary) <case LSHIFT_EXPR, case RSHIFT_EXPR>: Optimize\n+\t(X & C2) << C1 into (X << C1) & (C2 << C1) and\n+\t(X & C2) >> C1 into (X >> C1) & (C2 >> C1) if that allows further\n+\toptimizations.\n+\n \tPR tree-optimization/33453\n \t* tree-data-ref.c (split_constant_offset): Use POINTER_PLUS_EXPR\n \tfor pointer addition."}, {"sha": "1502994e26cdeb1b4966c0105d58668048b98626", "filename": "gcc/fold-const.c", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22164c3db7653556de1044be9491034c1c40bf8e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22164c3db7653556de1044be9491034c1c40bf8e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=22164c3db7653556de1044be9491034c1c40bf8e", "patch": "@@ -10973,6 +10973,100 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    return build_int_cst (type, residue & low);\n \t}\n \n+      /* Fold (X << C1) & C2 into (X << C1) & (C2 | ((1 << C1) - 1))\n+\t      (X >> C1) & C2 into (X >> C1) & (C2 | ~((type) -1 >> C1))\n+\t if the new mask might be further optimized.  */\n+      if ((TREE_CODE (arg0) == LSHIFT_EXPR\n+\t   || TREE_CODE (arg0) == RSHIFT_EXPR)\n+\t  && host_integerp (TREE_OPERAND (arg0, 1), 1)\n+\t  && host_integerp (arg1, TYPE_UNSIGNED (TREE_TYPE (arg1)))\n+\t  && tree_low_cst (TREE_OPERAND (arg0, 1), 1)\n+\t     < TYPE_PRECISION (TREE_TYPE (arg0))\n+\t  && TYPE_PRECISION (TREE_TYPE (arg0)) <= HOST_BITS_PER_WIDE_INT\n+\t  && tree_low_cst (TREE_OPERAND (arg0, 1), 1) > 0)\n+\t{\n+\t  unsigned int shiftc = tree_low_cst (TREE_OPERAND (arg0, 1), 1);\n+\t  unsigned HOST_WIDE_INT mask\n+\t    = tree_low_cst (arg1, TYPE_UNSIGNED (TREE_TYPE (arg1)));\n+\t  unsigned HOST_WIDE_INT newmask, zerobits = 0;\n+\t  tree shift_type = TREE_TYPE (arg0);\n+\n+\t  if (TREE_CODE (arg0) == LSHIFT_EXPR)\n+\t    zerobits = ((((unsigned HOST_WIDE_INT) 1) << shiftc) - 1);\n+\t  else if (TREE_CODE (arg0) == RSHIFT_EXPR\n+\t\t   && TYPE_PRECISION (TREE_TYPE (arg0))\n+\t\t      == GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (arg0))))\n+\t    {\n+\t      unsigned int prec = TYPE_PRECISION (TREE_TYPE (arg0));\n+\t      tree arg00 = TREE_OPERAND (arg0, 0);\n+\t      /* See if more bits can be proven as zero because of\n+\t\t zero extension.  */\n+\t      if (TREE_CODE (arg00) == NOP_EXPR\n+\t\t  && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg00, 0))))\n+\t\t{\n+\t\t  tree inner_type = TREE_TYPE (TREE_OPERAND (arg00, 0));\n+\t\t  if (TYPE_PRECISION (inner_type)\n+\t\t      == GET_MODE_BITSIZE (TYPE_MODE (inner_type))\n+\t\t      && TYPE_PRECISION (inner_type) < prec)\n+\t\t    {\n+\t\t      prec = TYPE_PRECISION (inner_type);\n+\t\t      /* See if we can shorten the right shift.  */\n+\t\t      if (shiftc < prec)\n+\t\t\tshift_type = inner_type;\n+\t\t    }\n+\t\t}\n+\t      zerobits = ~(unsigned HOST_WIDE_INT) 0;\n+\t      zerobits >>= HOST_BITS_PER_WIDE_INT - shiftc;\n+\t      zerobits <<= prec - shiftc;\n+\t      /* For arithmetic shift if sign bit could be set, zerobits\n+\t\t can contain actually sign bits, so no transformation is\n+\t\t possible, unless MASK masks them all away.  In that\n+\t\t case the shift needs to be converted into logical shift.  */\n+\t      if (!TYPE_UNSIGNED (TREE_TYPE (arg0))\n+\t\t  && prec == TYPE_PRECISION (TREE_TYPE (arg0)))\n+\t\t{\n+\t\t  if ((mask & zerobits) == 0)\n+\t\t    shift_type = unsigned_type_for (TREE_TYPE (arg0));\n+\t\t  else\n+\t\t    zerobits = 0;\n+\t\t}\n+\t    }\n+\n+\t  /* ((X << 16) & 0xff00) is (X, 0).  */\n+\t  if ((mask & zerobits) == mask)\n+\t    return omit_one_operand (type, build_int_cst (type, 0), arg0);\n+\n+\t  newmask = mask | zerobits;\n+\t  if (newmask != mask && (newmask & (newmask + 1)) == 0)\n+\t    {\n+\t      unsigned int prec;\n+\n+\t      /* Only do the transformation if NEWMASK is some integer\n+\t\t mode's mask.  */\n+\t      for (prec = BITS_PER_UNIT;\n+\t\t   prec < HOST_BITS_PER_WIDE_INT; prec <<= 1)\n+\t\tif (newmask == (((unsigned HOST_WIDE_INT) 1) << prec) - 1)\n+\t\t  break;\n+\t      if (prec < HOST_BITS_PER_WIDE_INT\n+\t\t  || newmask == ~(unsigned HOST_WIDE_INT) 0)\n+\t\t{\n+\t\t  if (shift_type != TREE_TYPE (arg0))\n+\t\t    {\n+\t\t      tem = fold_build2 (TREE_CODE (arg0), shift_type,\n+\t\t\t\t\t fold_convert (shift_type,\n+\t\t\t\t\t\t       TREE_OPERAND (arg0, 0)),\n+\t\t\t\t\t TREE_OPERAND (arg0, 1));\n+\t\t      tem = fold_convert (type, tem);\n+\t\t    }\n+\t\t  else\n+\t\t    tem = op0;\n+\t\t  return fold_build2 (BIT_AND_EXPR, type, tem,\n+\t\t\t\t      build_int_cst_type (TREE_TYPE (op1),\n+\t\t\t\t\t\t\t  newmask));\n+\t\t}\n+\t    }\n+\t}\n+\n       goto associate;\n \n     case RDIV_EXPR:\n@@ -11526,6 +11620,25 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      == (unsigned int) GET_MODE_BITSIZE (TYPE_MODE (type))))\n \treturn TREE_OPERAND (arg0, 0);\n \n+      /* Fold (X & C2) << C1 into (X << C1) & (C2 << C1)\n+\t      (X & C2) >> C1 into (X >> C1) & (C2 >> C1)\n+\t if the latter can be further optimized.  */\n+      if ((code == LSHIFT_EXPR || code == RSHIFT_EXPR)\n+\t  && TREE_CODE (arg0) == BIT_AND_EXPR\n+\t  && TREE_CODE (arg1) == INTEGER_CST\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n+\t{\n+\t  tree mask = fold_build2 (code, type,\n+\t\t\t\t   fold_convert (type, TREE_OPERAND (arg0, 1)),\n+\t\t\t\t   arg1);\n+\t  tree shift = fold_build2 (code, type,\n+\t\t\t\t    fold_convert (type, TREE_OPERAND (arg0, 0)),\n+\t\t\t\t    arg1);\n+\t  tem = fold_binary (BIT_AND_EXPR, type, shift, mask);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n+\n       return NULL_TREE;\n \n     case MIN_EXPR:"}, {"sha": "11a07deecfc3f32bc840ed198e50abdbb0f19453", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22164c3db7653556de1044be9491034c1c40bf8e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22164c3db7653556de1044be9491034c1c40bf8e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=22164c3db7653556de1044be9491034c1c40bf8e", "patch": "@@ -1,5 +1,8 @@\n 2007-12-03  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/29749\n+\t* gcc.dg/fold-rotate-1.c: New test.\n+\n \tPR tree-optimization/33453\n \t* gcc.c-torture/compile/20071203-1.c: New test.\n "}, {"sha": "c04447fb3cf537b764bd01e4dcd49a5645e5b9f6", "filename": "gcc/testsuite/gcc.dg/fold-rotate-1.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22164c3db7653556de1044be9491034c1c40bf8e/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-rotate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22164c3db7653556de1044be9491034c1c40bf8e/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-rotate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-rotate-1.c?ref=22164c3db7653556de1044be9491034c1c40bf8e", "patch": "@@ -0,0 +1,74 @@\n+/* PR middle-end/29749 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-original\" } */\n+\n+#if __SCHAR_MAX__ == 127\n+\n+unsigned char\n+e1 (unsigned char a)\n+{\n+  return a >> 5 | a << 3;\n+}\n+\n+unsigned char\n+e2 (unsigned char a)\n+{\n+  return (a & 0xe0) >> 5 | (a & 0x1f) << 3;\n+}\n+\n+unsigned char\n+e3 (unsigned char a)\n+{\n+  return ((a >> 5) & 0x07) | ((a << 3) & 0xf8);\n+}\n+\n+#endif\n+\n+#if __SHRT_MAX__ == 32767\n+\n+unsigned short\n+f1 (unsigned short a)\n+{\n+  return a >> 8 | a << 8;\n+}\n+\n+unsigned short\n+f2 (unsigned short a)\n+{\n+  return (a & 0xff00) >> 8 | (a & 0x00ff) << 8;\n+}\n+\n+unsigned short\n+f3 (unsigned short a)\n+{\n+  return ((a >> 8) & 0x00ff) | ((a << 8) & 0xff00);\n+}\n+\n+#endif\n+\n+#if __INT_MAX__ == 2147483647\n+\n+unsigned int\n+g1 (unsigned int a)\n+{\n+  return a >> 24 | a << 8;\n+}\n+\n+unsigned int\n+g2 (unsigned int a)\n+{\n+  return (a & 0xff000000) >> 24 | (a & 0x00ffffff) << 8;\n+}\n+\n+unsigned int\n+g3 (unsigned int a)\n+{\n+  return ((a >> 24) & 0x000000ff) | ((a << 8) & 0xffffff00U);\n+}\n+\n+#endif\n+\n+int i;\n+\n+/* { dg-final { scan-tree-dump-times \"&\" 0 \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}]}