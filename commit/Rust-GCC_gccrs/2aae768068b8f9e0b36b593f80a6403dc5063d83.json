{"sha": "2aae768068b8f9e0b36b593f80a6403dc5063d83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFhZTc2ODA2OGI4ZjllMGIzNmI1OTNmODBhNjQwM2RjNTA2M2Q4Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-04-16T14:34:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-04-16T14:34:22Z"}, "message": "cgraph.h (symtab_node_base): Add next and previous pointers.\n\n\n\t* cgraph.h (symtab_node_base): Add next and previous pointers.\n\t(cgraph_node): Remove next and preivous pointers.\n\t(varpool_node): Likewise; remove next/previous GTY marker;\n\tit is not type safe.\n\t(symtab_node_def): Update GTY marker\n\t(x_cgraph_nodes, cgraph_nodes): Remove.\n\t(symtab_nodes): New function.\n\t(cgraph_order): Rename to ...\n\t(symtab_order): ... this one.\n\t(symtab_register_node, symtab_unregister_node, symtab_remove_node):\n\tDeclare.\n\t(x_varpool_nodes, varpool_nodes): Remove.\n\t(FOR_EACH_STATIC_VARIABLE): Update.\n\t(symtab_function_p, symtab_variable_p): New function.\n\t(FOR_EACH_VARIABLE): Update.\n\t(varpool_first_variable, varpool_next_variable): New functions.\n\t(FOR_EACH_VARIABLE): Update.\n\t(cgraph_first_defined_function): Update.\n\t(cgraph_next_defined_function, cgraph_next_defined_function): Update.\n\t(FOR_EACH_DEFINED_FUNCTION, FOR_EACH_FUNCTION): Update.\n\t(cgraph_first_function, cgraph_next_function): New.\n\t(FOR_EACH_FUNCTION): Update.\n\t(cgraph_first_function_with_gimple_body,\n\tcgraph_next_function_with_gimple_body): Update.\n\t* symtab.c: New file.\n\t* cgraph.c: Update copyright dates.\n\t(x_cgraph_nodes, cgraph_order): Remove.\n\t(NEXT_FREE_NODE): Update.\n\t(SET_NEXT_FREE_NODE): New.\n\t(cgraph_create_node_1): Remove common code.\n\t(cgraph_create_node); Remove common code; call symtab_register_node.\n\t(cgraph_remove_node): Remove common code; call symtab_unregister-node.\n\t(cgraph_add_asm_node); update.\n\t(cgraph_clone_node): Register new node.\n\t* cgraphunit.c (process_function_and_variable_attributes): Update.\n\t(cgraph_analyze_functions): Update.\n\t(cgraph_analyze_functions): Update.\n\t(cgraph_output_in_order): Update.\n\t* lto-cgraph.c (input_node, input_varpool_node, input_cgraph_1): Update.\n\t* ipa-inline.c (recursive_inlining); update.\n\t* lto-streamer-in.c (lto_input_toplevel_asms); Update.\n\t* ipa.c (cgraph_remove_unreachable_nodes): Update.\n\t* Makefile.in: Add symtab.o\n\t* varpool.c (x_varpool_nodes): Remove\n\t(varpool_node): Remove common code; call symtab_register_node.\n\t(varpool_remove_node); Remove common code; call symtab_unregister_node.\n\nFrom-SVN: r186496", "tree": {"sha": "5faa94b4b722d5a4697b6faeb99c4c72e121c4ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5faa94b4b722d5a4697b6faeb99c4c72e121c4ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2aae768068b8f9e0b36b593f80a6403dc5063d83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aae768068b8f9e0b36b593f80a6403dc5063d83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aae768068b8f9e0b36b593f80a6403dc5063d83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aae768068b8f9e0b36b593f80a6403dc5063d83/comments", "author": null, "committer": null, "parents": [{"sha": "1c4010c6d61d3fa7f5fceeb09ea06a260bc5128c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c4010c6d61d3fa7f5fceeb09ea06a260bc5128c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c4010c6d61d3fa7f5fceeb09ea06a260bc5128c"}], "stats": {"total": 440, "additions": 297, "deletions": 143}, "files": [{"sha": "a2f6461eabb2e507ce902df4b81e51db1bbb34a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2aae768068b8f9e0b36b593f80a6403dc5063d83", "patch": "@@ -1,3 +1,52 @@\n+2012-04-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (symtab_node_base): Add next and previous pointers.\n+\t(cgraph_node): Remove next and preivous pointers.\n+\t(varpool_node): Likewise; remove next/previous GTY marker;\n+\tit is not type safe.\n+\t(symtab_node_def): Update GTY marker\n+\t(x_cgraph_nodes, cgraph_nodes): Remove.\n+\t(symtab_nodes): New function.\n+\t(cgraph_order): Rename to ...\n+\t(symtab_order): ... this one.\n+\t(symtab_register_node, symtab_unregister_node, symtab_remove_node):\n+\tDeclare.\n+\t(x_varpool_nodes, varpool_nodes): Remove.\n+\t(FOR_EACH_STATIC_VARIABLE): Update.\n+\t(symtab_function_p, symtab_variable_p): New function.\n+\t(FOR_EACH_VARIABLE): Update.\n+\t(varpool_first_variable, varpool_next_variable): New functions.\n+\t(FOR_EACH_VARIABLE): Update.\n+\t(cgraph_first_defined_function): Update.\n+\t(cgraph_next_defined_function, cgraph_next_defined_function): Update.\n+\t(FOR_EACH_DEFINED_FUNCTION, FOR_EACH_FUNCTION): Update.\n+\t(cgraph_first_function, cgraph_next_function): New.\n+\t(FOR_EACH_FUNCTION): Update.\n+\t(cgraph_first_function_with_gimple_body,\n+\tcgraph_next_function_with_gimple_body): Update.\n+\t* symtab.c: New file.\n+\t* cgraph.c: Update copyright dates.\n+\t(x_cgraph_nodes, cgraph_order): Remove.\n+\t(NEXT_FREE_NODE): Update.\n+\t(SET_NEXT_FREE_NODE): New.\n+\t(cgraph_create_node_1): Remove common code.\n+\t(cgraph_create_node); Remove common code; call symtab_register_node.\n+\t(cgraph_remove_node): Remove common code; call symtab_unregister-node.\n+\t(cgraph_add_asm_node); update.\n+\t(cgraph_clone_node): Register new node.\n+\t* cgraphunit.c (process_function_and_variable_attributes): Update.\n+\t(cgraph_analyze_functions): Update.\n+\t(cgraph_analyze_functions): Update.\n+\t(cgraph_output_in_order): Update.\n+\t* lto-cgraph.c (input_node, input_varpool_node, input_cgraph_1): Update.\n+\t* ipa-inline.c (recursive_inlining); update.\n+\t* lto-streamer-in.c (lto_input_toplevel_asms); Update.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): Update.\n+\t* Makefile.in: Add symtab.o\n+\t* varpool.c (x_varpool_nodes): Remove\n+\t(varpool_node): Remove common code; call symtab_register_node.\n+\t(varpool_remove_node); Remove common code; call symtab_unregister_node.\n+\n 2012-04-16  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/52977"}, {"sha": "de8276401a2b2fd939c42314dc4bf459bd5f58d0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2aae768068b8f9e0b36b593f80a6403dc5063d83", "patch": "@@ -1173,6 +1173,7 @@ OBJS = \\\n \tcfgloopanal.o \\\n \tcfgloopmanip.o \\\n \tcfgrtl.o \\\n+\tsymtab.o \\\n \tcgraph.o \\\n \tcgraphbuild.o \\\n \tcgraphunit.o \\\n@@ -2909,6 +2910,9 @@ simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(RECOG_H) $(EXPR_H) $(DIAGNOSTIC_CORE_H) output.h $(FUNCTION_H) $(GGC_H) $(TM_P_H) \\\n    $(TREE_H) $(TARGET_H)\n+symtab.o : symtab.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n+   langhooks.h toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) $(TARGET_H) $(CGRAPH_H) \\\n+   $(HASHTAB_H) \n cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) $(TARGET_H) $(CGRAPH_H) \\\n    gt-cgraph.h output.h intl.h $(BASIC_BLOCK_H) debug.h $(HASHTAB_H) \\"}, {"sha": "6a54db9630177e61c156d5e1b218c34780a8412a", "filename": "gcc/cgraph.c", "status": "modified", "additions": 9, "deletions": 44, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=2aae768068b8f9e0b36b593f80a6403dc5063d83", "patch": "@@ -1,6 +1,6 @@\n /* Callgraph handling code.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011, 2012 Free Software Foundation, Inc.\n    Contributed by Jan Hubicka\n \n This file is part of GCC.\n@@ -124,9 +124,6 @@ static GTY((param_is (union symtab_node_def))) htab_t cgraph_hash;\n /* Hash table used to convert assembler names into nodes.  */\n static GTY((param_is (union symtab_node_def))) htab_t assembler_name_hash;\n \n-/* The linked list of cgraph nodes.  */\n-symtab_node x_cgraph_nodes;\n-\n /* Queue of cgraph nodes scheduled to be lowered.  */\n symtab_node x_cgraph_nodes_queue;\n #define cgraph_nodes_queue ((struct cgraph_node *)x_cgraph_nodes_queue)\n@@ -160,11 +157,6 @@ struct cgraph_asm_node *cgraph_asm_nodes;\n /* Last node in cgraph_asm_nodes.  */\n static GTY(()) struct cgraph_asm_node *cgraph_asm_last_node;\n \n-/* The order index of the next cgraph node to be created.  This is\n-   used so that we can sort the cgraph nodes in order by when we saw\n-   them, to support -fno-toplevel-reorder.  */\n-int cgraph_order;\n-\n /* List of hooks triggered on cgraph_edge events.  */\n struct cgraph_edge_hook_list {\n   cgraph_edge_hook hook;\n@@ -216,7 +208,8 @@ bool same_body_aliases_done;\n \n /* Macros to access the next item in the list of free cgraph nodes and\n    edges. */\n-#define NEXT_FREE_NODE(NODE) (NODE)->next\n+#define NEXT_FREE_NODE(NODE) cgraph ((NODE)->symbol.next)\n+#define SET_NEXT_FREE_NODE(NODE,NODE2) ((NODE))->symbol.next = (symtab_node)NODE2\n #define NEXT_FREE_EDGE(EDGE) (EDGE)->prev_caller\n \n /* Register HOOK to be called with DATA on each removed edge.  */\n@@ -475,15 +468,8 @@ cgraph_create_node_1 (void)\n   struct cgraph_node *node = cgraph_allocate_node ();\n \n   node->symbol.type = SYMTAB_FUNCTION;\n-  node->next = cgraph_nodes;\n-  node->symbol.order = cgraph_order++;\n-  if (cgraph_nodes)\n-    cgraph_nodes->previous = node;\n-  node->previous = NULL;\n   node->frequency = NODE_FREQUENCY_NORMAL;\n   node->count_materialization_scale = REG_BR_PROB_BASE;\n-  ipa_empty_ref_list (&node->symbol.ref_list);\n-  x_cgraph_nodes = (symtab_node)node;\n   cgraph_n_nodes++;\n   return node;\n }\n@@ -506,6 +492,7 @@ cgraph_create_node (tree decl)\n \n   node = cgraph_create_node_1 ();\n   node->symbol.decl = decl;\n+  symtab_register_node ((symtab_node)node);\n   *slot = node;\n   if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n     {\n@@ -1418,8 +1405,6 @@ cgraph_remove_node (struct cgraph_node *node)\n   cgraph_call_node_removal_hooks (node);\n   cgraph_node_remove_callers (node);\n   cgraph_node_remove_callees (node);\n-  ipa_remove_all_references (&node->symbol.ref_list);\n-  ipa_remove_all_refering (&node->symbol.ref_list);\n   VEC_free (ipa_opt_pass, heap,\n             node->ipa_transforms_to_apply);\n \n@@ -1437,14 +1422,7 @@ cgraph_remove_node (struct cgraph_node *node)\n \tnode2 = &(*node2)->next_nested;\n       *node2 = node->next_nested;\n     }\n-  if (node->previous)\n-    node->previous->next = node->next;\n-  else\n-    x_cgraph_nodes = (symtab_node)node->next;\n-  if (node->next)\n-    node->next->previous = node->previous;\n-  node->next = NULL;\n-  node->previous = NULL;\n+  symtab_unregister_node ((symtab_node)node);\n   slot = htab_find_slot (cgraph_hash, node, NO_INSERT);\n   if (*slot == node)\n     {\n@@ -1567,20 +1545,6 @@ cgraph_remove_node (struct cgraph_node *node)\n \t}\n     }\n \n-  if (node->symbol.same_comdat_group)\n-    {\n-      symtab_node prev;\n-      for (prev = node->symbol.same_comdat_group;\n-\t   prev->symbol.same_comdat_group != (symtab_node)node;\n-\t   prev = prev->symbol.same_comdat_group)\n-\t;\n-      if (node->symbol.same_comdat_group == prev)\n-\tprev->symbol.same_comdat_group = NULL;\n-      else\n-\tprev->symbol.same_comdat_group = node->symbol.same_comdat_group;\n-      node->symbol.same_comdat_group = NULL;\n-    }\n-\n   /* While all the clones are removed after being proceeded, the function\n      itself is kept in the cgraph even after it is compiled.  Check whether\n      we are done with this body and reclaim it proactively if this is the case.\n@@ -1621,7 +1585,7 @@ cgraph_remove_node (struct cgraph_node *node)\n   memset (node, 0, sizeof(*node));\n   node->symbol.type = SYMTAB_FUNCTION;\n   node->uid = uid;\n-  NEXT_FREE_NODE (node) = free_nodes;\n+  SET_NEXT_FREE_NODE (node, free_nodes);\n   free_nodes = node;\n }\n \n@@ -2029,7 +1993,7 @@ cgraph_add_asm_node (tree asm_str)\n \n   node = ggc_alloc_cleared_cgraph_asm_node ();\n   node->asm_str = asm_str;\n-  node->order = cgraph_order++;\n+  node->order = symtab_order++;\n   node->next = NULL;\n   if (cgraph_asm_nodes == NULL)\n     cgraph_asm_nodes = node;\n@@ -2134,6 +2098,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   unsigned i;\n \n   new_node->symbol.decl = decl;\n+  symtab_register_node ((symtab_node)new_node);\n   new_node->origin = n->origin;\n   if (new_node->origin)\n     {"}, {"sha": "e2f3b0b7f2bd5584f198719ca7dca8cf767cb9a8", "filename": "gcc/cgraph.h", "status": "modified", "additions": 106, "deletions": 40, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=2aae768068b8f9e0b36b593f80a6403dc5063d83", "patch": "@@ -57,6 +57,10 @@ struct GTY(()) symtab_node_base\n   /* File stream where this node is being written to.  */\n   struct lto_file_decl_data * lto_file_data;\n \n+  /* Linked list of symbol table entries starting with symtab_nodes.  */\n+  symtab_node next;\n+  symtab_node previous;\n+\n   PTR GTY ((skip)) aux;\n \n   /* Set when function has address taken.\n@@ -190,12 +194,6 @@ struct GTY(()) cgraph_node {\n   struct symtab_node_base symbol;\n   struct cgraph_edge *callees;\n   struct cgraph_edge *callers;\n-  struct cgraph_node *\n-    GTY ((nested_ptr (union symtab_node_def, \"(struct cgraph_node *)(%h)\", \"(symtab_node)%h\")))\n-    next;\n-  struct cgraph_node *\n-    GTY ((nested_ptr (union symtab_node_def, \"(struct cgraph_node *)(%h)\", \"(symtab_node)%h\")))\n-    previous;\n   /* List of edges representing indirect calls with a yet undetermined\n      callee.  */\n   struct cgraph_edge *indirect_calls;\n@@ -417,17 +415,10 @@ DEF_VEC_ALLOC_P(cgraph_edge_p,heap);\n /* The varpool data structure.\n    Each static variable decl has assigned varpool_node.  */\n \n-struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) varpool_node {\n+struct GTY(()) varpool_node {\n   struct symtab_node_base symbol;\n   /* For aliases points to declaration DECL is alias of.  */\n   tree alias_of;\n-  /* Pointer to the next function in varpool_nodes.  */\n-  struct varpool_node *\n-    GTY ((nested_ptr (union symtab_node_def, \"(struct varpool_node *)(%h)\", \"(symtab_node)%h\")))\n-    next;\n-  struct varpool_node *\n-    GTY ((nested_ptr (union symtab_node_def, \"(struct varpool_node *)(%h)\", \"(symtab_node)%h\")))\n-    prev;\n   /* Pointer to the next function in varpool_nodes_queue.  */\n   struct varpool_node *\n     GTY ((nested_ptr (union symtab_node_def, \"(struct varpool_node *)(%h)\", \"(symtab_node)%h\")))\n@@ -467,16 +458,16 @@ struct GTY(()) cgraph_asm_node {\n };\n \n /* Symbol table entry.  */\n-union GTY((desc (\"%h.symbol.type\"))) symtab_node_def {\n+union GTY((desc (\"%h.symbol.type\"), chain_next (\"%h.symbol.next\"),\n+\t   chain_prev (\"%h.symbol.previous\"))) symtab_node_def {\n   struct symtab_node_base GTY ((tag (\"SYMTAB_SYMBOL\"))) symbol;\n   /* Use cgraph (symbol) accessor to get cgraph_node.  */\n   struct cgraph_node GTY ((tag (\"SYMTAB_FUNCTION\"))) x_function;\n   /* Use varpool (symbol) accessor to get varpool_node.  */\n   struct varpool_node GTY ((tag (\"SYMTAB_VARIABLE\"))) x_variable;\n };\n \n-extern GTY(()) symtab_node x_cgraph_nodes;\n-#define cgraph_nodes ((struct cgraph_node *)x_cgraph_nodes)\n+extern GTY(()) symtab_node symtab_nodes;\n extern GTY(()) int cgraph_n_nodes;\n extern GTY(()) int cgraph_max_uid;\n extern GTY(()) int cgraph_edge_max_uid;\n@@ -501,9 +492,14 @@ extern GTY(()) symtab_node x_cgraph_nodes_queue;\n extern GTY(()) struct cgraph_node *cgraph_new_nodes;\n \n extern GTY(()) struct cgraph_asm_node *cgraph_asm_nodes;\n-extern GTY(()) int cgraph_order;\n+extern GTY(()) int symtab_order;\n extern bool same_body_aliases_done;\n \n+/* In symtab.c  */\n+void symtab_register_node (symtab_node);\n+void symtab_unregister_node (symtab_node);\n+void symtab_remove_node (symtab_node);\n+\n /* In cgraph.c  */\n void dump_cgraph (FILE *);\n void debug_cgraph (void);\n@@ -684,9 +680,7 @@ bool cgraph_optimize_for_size_p (struct cgraph_node *);\n \n /* In varpool.c  */\n extern GTY(()) symtab_node x_varpool_nodes_queue;\n-extern GTY(()) symtab_node x_varpool_nodes;\n #define varpool_nodes_queue ((struct varpool_node *)x_varpool_nodes_queue)\n-#define varpool_nodes ((struct varpool_node *)x_varpool_nodes)\n \n struct varpool_node *varpool_node (tree);\n struct varpool_node *varpool_node_for_asm (tree asmname);\n@@ -721,9 +715,19 @@ bool varpool_for_node_and_aliases (struct varpool_node *,\n \t\t\t           void *, bool);\n void varpool_add_new_variable (tree);\n \n-/* Walk all reachable static variables.  */\n-#define FOR_EACH_STATIC_VARIABLE(node) \\\n-   for ((node) = varpool_nodes_queue; (node); (node) = (node)->next_needed)\n+/* Return true when NODE is function.  */\n+static inline bool\n+symtab_function_p (symtab_node node)\n+{\n+  return node->symbol.type == SYMTAB_FUNCTION;\n+}\n+\n+/* Return true when NODE is variable.  */\n+static inline bool\n+symtab_variable_p (symtab_node node)\n+{\n+  return node->symbol.type == SYMTAB_VARIABLE;\n+}\n \n /* Return callgraph node for given symbol and check it is a function. */\n static inline struct cgraph_node *\n@@ -769,13 +773,44 @@ varpool_next_static_initializer (struct varpool_node *node)\n   return NULL;\n }\n \n+/* Walk all reachable static variables.  */\n+#define FOR_EACH_STATIC_VARIABLE(node) \\\n+   for ((node) = varpool_nodes_queue; (node); (node) = (node)->next_needed)\n /* Walk all static variables with initializer set.  */\n #define FOR_EACH_STATIC_INITIALIZER(node) \\\n    for ((node) = varpool_first_static_initializer (); (node); \\\n         (node) = varpool_next_static_initializer (node))\n+\n+/* Return first variable.  */\n+static inline struct varpool_node *\n+varpool_first_variable (void)\n+{\n+  symtab_node node;\n+  for (node = symtab_nodes; node; node = node->symbol.next)\n+    {\n+      if (symtab_variable_p (node))\n+\treturn varpool (node);\n+    }\n+  return NULL;\n+}\n+\n+/* Return next variable after NODE.  */\n+static inline struct varpool_node *\n+varpool_next_variable (struct varpool_node *node)\n+{\n+  symtab_node node1 = (symtab_node) node->symbol.next;\n+  for (; node1; node1 = node1->symbol.next)\n+    {\n+      if (symtab_variable_p (node1))\n+\treturn varpool (node1);\n+    }\n+  return NULL;\n+}\n /* Walk all variables.  */\n #define FOR_EACH_VARIABLE(node) \\\n-   for ((node) = varpool_nodes; (node); (node) = (node)->next)\n+   for ((node) = varpool_first_variable (); \\\n+        (node); \\\n+\t(node) = varpool_next_variable ((node)))\n /* Walk all variables with definitions in current unit.  */\n #define FOR_EACH_DEFINED_VARIABLE(node) \\\n    for ((node) = varpool_nodes_queue; (node); (node) = (node)->next_needed)\n@@ -784,11 +819,11 @@ varpool_next_static_initializer (struct varpool_node *node)\n static inline struct cgraph_node *\n cgraph_first_defined_function (void)\n {\n-  struct cgraph_node *node;\n-  for (node = cgraph_nodes; node; node = node->next)\n+  symtab_node node;\n+  for (node = symtab_nodes; node; node = node->symbol.next)\n     {\n-      if (node->analyzed)\n-\treturn node;\n+      if (symtab_function_p (node) && cgraph (node)->analyzed)\n+\treturn cgraph (node);\n     }\n   return NULL;\n }\n@@ -797,21 +832,49 @@ cgraph_first_defined_function (void)\n static inline struct cgraph_node *\n cgraph_next_defined_function (struct cgraph_node *node)\n {\n-  for (node = node->next; node; node = node->next)\n+  symtab_node node1 = (symtab_node) node->symbol.next;\n+  for (; node1; node1 = node1->symbol.next)\n     {\n-      if (node->analyzed)\n-\treturn node;\n+      if (symtab_function_p (node1) && cgraph (node1)->analyzed)\n+\treturn cgraph (node1);\n     }\n   return NULL;\n }\n \n /* Walk all functions with body defined.  */\n #define FOR_EACH_DEFINED_FUNCTION(node) \\\n    for ((node) = cgraph_first_defined_function (); (node); \\\n-        (node) = cgraph_next_defined_function (node))\n+        (node) = cgraph_next_defined_function ((node)))\n+\n+/* Return first function.  */\n+static inline struct cgraph_node *\n+cgraph_first_function (void)\n+{\n+  symtab_node node;\n+  for (node = symtab_nodes; node; node = node->symbol.next)\n+    {\n+      if (symtab_function_p (node))\n+\treturn cgraph (node);\n+    }\n+  return NULL;\n+}\n+\n+/* Return next function.  */\n+static inline struct cgraph_node *\n+cgraph_next_function (struct cgraph_node *node)\n+{\n+  symtab_node node1 = (symtab_node) node->symbol.next;\n+  for (; node1; node1 = node1->symbol.next)\n+    {\n+      if (symtab_function_p (node1))\n+\treturn cgraph (node1);\n+    }\n+  return NULL;\n+}\n /* Walk all functions.  */\n #define FOR_EACH_FUNCTION(node) \\\n-   for ((node) = cgraph_nodes; (node); (node) = (node)->next)\n+   for ((node) = cgraph_first_function (); (node); \\\n+        (node) = cgraph_next_function ((node)))\n \n /* Return true when NODE is a function with Gimple body defined\n    in current unit.  Functions can also be define externally or they\n@@ -829,11 +892,12 @@ cgraph_function_with_gimple_body_p (struct cgraph_node *node)\n static inline struct cgraph_node *\n cgraph_first_function_with_gimple_body (void)\n {\n-  struct cgraph_node *node;\n-  for (node = cgraph_nodes; node; node = node->next)\n+  symtab_node node;\n+  for (node = symtab_nodes; node; node = node->symbol.next)\n     {\n-      if (cgraph_function_with_gimple_body_p (node))\n-\treturn node;\n+      if (symtab_function_p (node)\n+\t  && cgraph_function_with_gimple_body_p (cgraph (node)))\n+\treturn cgraph (node);\n     }\n   return NULL;\n }\n@@ -842,10 +906,12 @@ cgraph_first_function_with_gimple_body (void)\n static inline struct cgraph_node *\n cgraph_next_function_with_gimple_body (struct cgraph_node *node)\n {\n-  for (node = node->next; node; node = node->next)\n+  symtab_node node1 = node->symbol.next;\n+  for (; node1; node1 = node1->symbol.next)\n     {\n-      if (cgraph_function_with_gimple_body_p (node))\n-\treturn node;\n+      if (symtab_function_p (node1)\n+\t  && cgraph_function_with_gimple_body_p (cgraph (node1)))\n+\treturn cgraph (node1);\n     }\n   return NULL;\n }"}, {"sha": "726d8839d3db362c734e13ca5161a255dd03fcab", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=2aae768068b8f9e0b36b593f80a6403dc5063d83", "patch": "@@ -1085,7 +1085,8 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n   struct cgraph_node *node;\n   struct varpool_node *vnode;\n \n-  for (node = cgraph_nodes; node != first; node = node->next)\n+  for (node = cgraph_first_function (); node != first;\n+       node = cgraph_next_function (node))\n     {\n       tree decl = node->symbol.decl;\n       if (DECL_PRESERVE_P (decl))\n@@ -1126,7 +1127,8 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n      \n       process_common_attributes (decl);\n     }\n-  for (vnode = varpool_nodes; vnode != first_var; vnode = vnode->next)\n+  for (vnode = varpool_first_variable (); vnode != first_var;\n+       vnode = varpool_next_variable (vnode))\n     {\n       tree decl = vnode->symbol.decl;\n       if (DECL_PRESERVE_P (decl))\n@@ -1184,13 +1186,14 @@ cgraph_analyze_functions (void)\n   bitmap_obstack_initialize (NULL);\n   process_function_and_variable_attributes (first_processed,\n \t\t\t\t\t    first_analyzed_var);\n-  first_processed = cgraph_nodes;\n-  first_analyzed_var = varpool_nodes;\n+  first_processed = cgraph_first_function ();\n+  first_analyzed_var = varpool_first_variable ();\n   varpool_analyze_pending_decls ();\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Initial entry points:\");\n-      for (node = cgraph_nodes; node != first_analyzed; node = node->next)\n+      for (node = cgraph_first_function (); node != first_analyzed;\n+\t   node = cgraph_next_function (node))\n \tif (node->needed)\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\");\n@@ -1255,8 +1258,8 @@ cgraph_analyze_functions (void)\n          edges.  Process their attributes too.  */\n       process_function_and_variable_attributes (first_processed,\n \t\t\t\t\t\tfirst_analyzed_var);\n-      first_processed = cgraph_nodes;\n-      first_analyzed_var = varpool_nodes;\n+      first_processed = cgraph_first_function ();\n+      first_analyzed_var = varpool_first_variable ();\n       varpool_analyze_pending_decls ();\n       cgraph_process_new_functions ();\n     }\n@@ -1265,7 +1268,8 @@ cgraph_analyze_functions (void)\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Unit entry points:\");\n-      for (node = cgraph_nodes; node != first_analyzed; node = node->next)\n+      for (node = cgraph_first_function (); node != first_analyzed;\n+\t   node = cgraph_next_function (node))\n \tif (node->needed)\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\\nInitial \");\n@@ -1276,10 +1280,11 @@ cgraph_analyze_functions (void)\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"\\nReclaiming functions:\");\n \n-  for (node = cgraph_nodes; node != first_analyzed; node = next)\n+  for (node = cgraph_first_function (); node != first_analyzed;\n+       node = next)\n     {\n       tree decl = node->symbol.decl;\n-      next = node->next;\n+      next = cgraph_next_function (node);\n \n       if (node->local.finalized && !gimple_has_body_p (decl)\n \t  && (!node->alias || !node->thunk.alias)\n@@ -1309,7 +1314,7 @@ cgraph_analyze_functions (void)\n       dump_varpool (cgraph_dump_file);\n     }\n   bitmap_obstack_release (NULL);\n-  first_analyzed = cgraph_nodes;\n+  first_analyzed = cgraph_first_function ();\n   ggc_collect ();\n }\n \n@@ -2076,7 +2081,7 @@ cgraph_output_in_order (void)\n   struct varpool_node *pv;\n   struct cgraph_asm_node *pa;\n \n-  max = cgraph_order;\n+  max = symtab_order;\n   nodes = XCNEWVEC (struct cgraph_order_sort, max);\n \n   varpool_analyze_pending_decls ();"}, {"sha": "8c41db8eb38470c31dfe16e1f2e5ee88fa12be3f", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=2aae768068b8f9e0b36b593f80a6403dc5063d83", "patch": "@@ -1267,10 +1267,10 @@ recursive_inlining (struct cgraph_edge *edge,\n   /* Remove master clone we used for inlining.  We rely that clones inlined\n      into master clone gets queued just before master clone so we don't\n      need recursion.  */\n-  for (node = cgraph_nodes; node != master_clone;\n+  for (node = cgraph_first_function (); node != master_clone;\n        node = next)\n     {\n-      next = node->next;\n+      next = cgraph_next_function (node);\n       if (node->global.inlined_to == master_clone)\n \tcgraph_remove_node (node);\n     }"}, {"sha": "b46618809dfa1e0078c63ecad338539bf6346600", "filename": "gcc/ipa.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=2aae768068b8f9e0b36b593f80a6403dc5063d83", "patch": "@@ -329,9 +329,9 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n      Also we need to care functions that are unreachable but we need to keep them around\n      for later clonning.  In this case we also turn them to unanalyzed nodes, but\n      keep the body around.  */\n-  for (node = cgraph_nodes; node; node = next)\n+  for (node = cgraph_first_function (); node; node = next)\n     {\n-      next = node->next;\n+      next = cgraph_next_function (node);\n       if (node->symbol.aux && !node->reachable)\n         {\n \t  cgraph_node_remove_callees (node);\n@@ -425,9 +425,9 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \n   if (file)\n     fprintf (file, \"Reclaiming variables:\");\n-  for (vnode = varpool_nodes; vnode; vnode = vnext)\n+  for (vnode = varpool_first_variable (); vnode; vnode = vnext)\n     {\n-      vnext = vnode->next;\n+      vnext = varpool_next_variable (vnode);\n       if (!vnode->needed)\n         {\n \t  if (file)"}, {"sha": "e6365b46ce822f2e2bcab294e3f7208d3e594d54", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=2aae768068b8f9e0b36b593f80a6403dc5063d83", "patch": "@@ -998,8 +998,8 @@ input_node (struct lto_file_decl_data *file_data,\n     node = cgraph_get_create_node (fn_decl);\n \n   node->symbol.order = order;\n-  if (order >= cgraph_order)\n-    cgraph_order = order + 1;\n+  if (order >= symtab_order)\n+    symtab_order = order + 1;\n \n   node->count = streamer_read_hwi (ib);\n   node->count_materialization_scale = streamer_read_hwi (ib);\n@@ -1069,8 +1069,8 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   var_decl = lto_file_decl_data_get_var_decl (file_data, decl_index);\n   node = varpool_node (var_decl);\n   node->symbol.order = order;\n-  if (order >= cgraph_order)\n-    cgraph_order = order + 1;\n+  if (order >= symtab_order)\n+    symtab_order = order + 1;\n   node->symbol.lto_file_data = file_data;\n \n   bp = streamer_read_bitpack (ib);\n@@ -1210,7 +1210,7 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n   unsigned i;\n \n   tag = streamer_read_enum (ib, LTO_cgraph_tags, LTO_cgraph_last_tag);\n-  order_base = cgraph_order;\n+  order_base = symtab_order;\n   while (tag)\n     {\n       if (tag == LTO_cgraph_edge)"}, {"sha": "1f2bfb6adc860bdd46b07a3398641d420cdd4265", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=2aae768068b8f9e0b36b593f80a6403dc5063d83", "patch": "@@ -1225,8 +1225,8 @@ lto_input_toplevel_asms (struct lto_file_decl_data *file_data, int order_base)\n     {\n       struct cgraph_asm_node *node = cgraph_add_asm_node (str);\n       node->order = streamer_read_hwi (&ib) + order_base;\n-      if (node->order >= cgraph_order)\n-\tcgraph_order = node->order + 1;\n+      if (node->order >= symtab_order)\n+\tsymtab_order = node->order + 1;\n     }\n \n   clear_line_info (data_in);"}, {"sha": "c30f33d703fa8d062b4564e90d0c291ac05aecbb", "filename": "gcc/symtab.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=2aae768068b8f9e0b36b593f80a6403dc5063d83", "patch": "@@ -0,0 +1,97 @@\n+/* Symbol table.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"tree-inline.h\"\n+#include \"hashtab.h\"\n+#include \"cgraph.h\"\n+\n+/* Linked list of symbol table nodes.  */\n+symtab_node symtab_nodes;\n+\n+/* The order index of the next symtab node to be created.  This is\n+   used so that we can sort the cgraph nodes in order by when we saw\n+   them, to support -fno-toplevel-reorder.  */\n+int symtab_order;\n+\n+/* Add node into symbol table.  This function is not used directly, but via\n+   cgraph/varpool node creation routines.  */\n+\n+void\n+symtab_register_node (symtab_node node)\n+{\n+  node->symbol.next = symtab_nodes;\n+  node->symbol.previous = NULL;\n+  if (symtab_nodes)\n+    symtab_nodes->symbol.previous = node;\n+  symtab_nodes = node;\n+\n+  node->symbol.order = symtab_order++;\n+\n+  ipa_empty_ref_list (&node->symbol.ref_list);\n+}\n+\n+/* Remove node from symbol table.  This function is not used directly, but via\n+   cgraph/varpool node removal routines.  */\n+\n+void\n+symtab_unregister_node (symtab_node node)\n+{\n+  ipa_remove_all_references (&node->symbol.ref_list);\n+  ipa_remove_all_refering (&node->symbol.ref_list);\n+\n+  if (node->symbol.same_comdat_group)\n+    {\n+      symtab_node prev;\n+      for (prev = node->symbol.same_comdat_group;\n+\t   prev->symbol.same_comdat_group != node;\n+\t   prev = prev->symbol.same_comdat_group)\n+\t;\n+      if (node->symbol.same_comdat_group == prev)\n+\tprev->symbol.same_comdat_group = NULL;\n+      else\n+\tprev->symbol.same_comdat_group = node->symbol.same_comdat_group;\n+      node->symbol.same_comdat_group = NULL;\n+    }\n+\n+  if (node->symbol.previous)\n+    node->symbol.previous->symbol.next = node->symbol.next;\n+  else\n+    symtab_nodes = node->symbol.next;\n+  if (node->symbol.next)\n+    node->symbol.next->symbol.previous = node->symbol.previous;\n+  node->symbol.next = NULL;\n+  node->symbol.previous = NULL;\n+}\n+\n+/* Remove symtab NODE from the symbol table.  */\n+\n+void\n+symtab_remove_node (symtab_node node)\n+{\n+  if (symtab_function_p (node))\n+    cgraph_remove_node (cgraph (node));\n+  else if (symtab_variable_p (node))\n+    varpool_remove_node (varpool (node));\n+}"}, {"sha": "8fd9e8ad16dee115607a04303010f6f79a048de5", "filename": "gcc/varpool.c", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aae768068b8f9e0b36b593f80a6403dc5063d83/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=2aae768068b8f9e0b36b593f80a6403dc5063d83", "patch": "@@ -51,10 +51,6 @@ along with GCC; see the file COPYING3.  If not see\n /* Hash table used to convert declarations into nodes.  */\n static GTY((param_is (union symtab_node_def))) htab_t varpool_hash;\n \n-/* The linked list of cgraph varpool nodes.\n-   Linked via node->next pointer.  */\n-symtab_node x_varpool_nodes;\n-\n /* Queue of cgraph nodes scheduled to be lowered and output.\n    The queue is maintained via mark_needed_node, linked via node->next_needed\n    pointer.\n@@ -146,12 +142,7 @@ varpool_node (tree decl)\n   node = ggc_alloc_cleared_varpool_node ();\n   node->symbol.type = SYMTAB_VARIABLE;\n   node->symbol.decl = decl;\n-  node->symbol.order = cgraph_order++;\n-  node->next = varpool_nodes;\n-  ipa_empty_ref_list (&node->symbol.ref_list);\n-  if (varpool_nodes)\n-    varpool (x_varpool_nodes)->prev = node;\n-  x_varpool_nodes = (symtab_node)node;\n+  symtab_register_node ((symtab_node)node);\n   *slot = node;\n   return node;\n }\n@@ -165,15 +156,7 @@ varpool_remove_node (struct varpool_node *node)\n   gcc_assert (*slot == node);\n   htab_clear_slot (varpool_hash, slot);\n   gcc_assert (!varpool_assembled_nodes_queue);\n-  if (node->next)\n-    node->next->prev = node->prev;\n-  if (node->prev)\n-    node->prev->next = node->next;\n-  else\n-    {\n-      gcc_assert (varpool_nodes == node);\n-      x_varpool_nodes = (symtab_node)node->next;\n-    }\n+  symtab_unregister_node ((symtab_node)node);\n   if (varpool_first_unanalyzed_node == node)\n     x_varpool_first_unanalyzed_node = (symtab_node)node->next_needed;\n   if (node->next_needed)\n@@ -190,21 +173,6 @@ varpool_remove_node (struct varpool_node *node)\n       gcc_assert (varpool_nodes_queue == node);\n       x_varpool_nodes_queue = (symtab_node)node->next_needed;\n     }\n-  if (node->symbol.same_comdat_group)\n-    {\n-      symtab_node prev;\n-      for (prev = node->symbol.same_comdat_group;\n-\t   prev->symbol.same_comdat_group != (symtab_node)node;\n-\t   prev = prev->symbol.same_comdat_group)\n-\t;\n-      if (node->symbol.same_comdat_group == prev)\n-\tprev->symbol.same_comdat_group = NULL;\n-      else\n-\tprev->symbol.same_comdat_group = (symtab_node)node->symbol.same_comdat_group;\n-      node->symbol.same_comdat_group = NULL;\n-    }\n-  ipa_remove_all_references (&node->symbol.ref_list);\n-  ipa_remove_all_refering (&node->symbol.ref_list);\n   ggc_free (node);\n }\n "}]}