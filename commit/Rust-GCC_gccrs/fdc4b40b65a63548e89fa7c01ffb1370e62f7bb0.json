{"sha": "fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRjNGI0MGI2NWE2MzU0OGU4OWZhN2MwMWZmYjEzNzBlNjJmN2JiMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-02-09T23:30:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-02-09T23:30:51Z"}, "message": "i386.c (vector_move_operand): New predicate.\n\n\t* i386.c (vector_move_operand): New predicate.\n\t(ix86_expand_vector_move): Be happy about 0.\n\t* i386.h (PREDICATE_CODES): Add sse-move_operand.\n\t* i386.md (mov*_internal): Add 'C' alternative.\n\nFrom-SVN: r62612", "tree": {"sha": "d397cd0705675a3ac76ae9e389f40732c9d7f698", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d397cd0705675a3ac76ae9e389f40732c9d7f698"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0/comments", "author": null, "committer": null, "parents": [{"sha": "35c28a133076b6ccf420e795bb1ac1dec90f67e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35c28a133076b6ccf420e795bb1ac1dec90f67e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35c28a133076b6ccf420e795bb1ac1dec90f67e1"}], "stats": {"total": 210, "additions": 153, "deletions": 57}, "files": [{"sha": "34340032206411a9b3c6bd7ec1240de7730c0471", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0", "patch": "@@ -1,3 +1,10 @@\n+Mon Feb 10 00:29:17 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (vector_move_operand): New predicate.\n+\t(ix86_expand_vector_move): Be happy about 0.\n+\t* i386.h (PREDICATE_CODES): Add sse-move_operand.\n+\t* i386.md (mov*_internal): Add 'C' alternative.\n+\n Sun Feb  9 23:58:33 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (floathi*): Deal with SSE."}, {"sha": "04da441a7109d99ab22727f9980a08b682e90be6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0", "patch": "@@ -3736,6 +3736,19 @@ zero_extended_scalar_load_operand (op, mode)\n   return 1;\n }\n \n+/*  Return 1 when OP is operand acceptable for standard SSE move.  */\n+int\n+vector_move_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (nonimmediate_operand (op, mode))\n+    return 1;\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+  return (op == CONST0_RTX (GET_MODE (op)));\n+}\n+\n /* Return 1 if OP is a comparison that can be used in the CMPSS/CMPPS\n    insns.  */\n int\n@@ -8161,7 +8174,7 @@ ix86_expand_vector_move (mode, operands)\n      to handle some of them more efficiently.  */\n   if ((reload_in_progress | reload_completed) == 0\n       && register_operand (operands[0], mode)\n-      && CONSTANT_P (operands[1]))\n+      && CONSTANT_P (operands[1]) && operands[1] != CONST0_RTX (mode))\n     operands[1] = validize_mem (force_const_mem (mode, operands[1]));\n \n   /* Make operand1 a register if it isn't already.  */"}, {"sha": "11349f99d815bf067f624a2fab6f57ca64fa71a6", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0", "patch": "@@ -3039,6 +3039,7 @@ do {\t\t\t\t\t\t\\\n   {\"fp_register_operand\", {REG}},\t\t\t\t\t\\\n   {\"register_and_not_fp_reg_operand\", {REG}},\t\t\t\t\\\n   {\"zero_extended_scalar_load_operand\", {MEM}},\t\t\t\t\\\n+  {\"vector_move_operand\", {CONST_VECTOR, SUBREG, REG, MEM}},\t\t\\\n \n /* A list of predicates that do special things with modes, and so\n    should not elicit warnings for VOIDmode match_operand.  */"}, {"sha": "591d7ff13103d288ac6b394748dd3806a9bfe6a5", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 131, "deletions": 56, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=fdc4b40b65a63548e89fa7c01ffb1370e62f7bb0", "patch": "@@ -18706,10 +18706,13 @@\n ;; Moves for SSE/MMX regs.\n \n (define_insn \"movv4sf_internal\"\n-  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(match_operand:V4SF 1 \"nonimmediate_operand\" \"xm,x\"))]\n+  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=x,x,m\")\n+\t(match_operand:V4SF 1 \"vector_move_operand\" \"C,xm,x\"))]\n   \"TARGET_SSE\"\n-  \"movaps\\t{%1, %0|%0, %1}\"\n+  \"@\n+    xorps\\t%0, %0\n+    movaps\\t{%1, %0|%0, %1}\n+    movaps\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"ssemov\")\n    (set_attr \"mode\" \"V4SF\")])\n \n@@ -18728,24 +18731,36 @@\n })\n \n (define_insn \"movv4si_internal\"\n-  [(set (match_operand:V4SI 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(match_operand:V4SI 1 \"nonimmediate_operand\" \"xm,x\"))]\n+  [(set (match_operand:V4SI 0 \"nonimmediate_operand\" \"=x,x,m\")\n+\t(match_operand:V4SI 1 \"vector_move_operand\" \"C,xm,x\"))]\n   \"TARGET_SSE\"\n {\n-  if (get_attr_mode (insn) == MODE_V4SF)\n-    return \"movaps\\t{%1, %0|%0, %1}\";\n-  else\n-    return \"movdqa\\t{%1, %0|%0, %1}\";\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (get_attr_mode (insn) == MODE_V4SF)\n+\treturn \"xorps\\t%0, %0\";\n+      else\n+\treturn \"pxor\\t%0, %0\";\n+    case 1:\n+    case 2:\n+      if (get_attr_mode (insn) == MODE_V4SF)\n+\treturn \"movaps\\t{%1, %0|%0, %1}\";\n+      else\n+\treturn \"movdqa\\t{%1, %0|%0, %1}\";\n+    default:\n+      abort ();\n+    }\n }\n   [(set_attr \"type\" \"ssemov\")\n    (set (attr \"mode\")\n-        (cond [(eq_attr \"alternative\" \"0\")\n+        (cond [(eq_attr \"alternative\" \"0,1\")\n \t\t (if_then_else\n \t\t   (ne (symbol_ref \"optimize_size\")\n \t\t       (const_int 0))\n \t\t   (const_string \"V4SF\")\n \t\t   (const_string \"TI\"))\n-\t       (eq_attr \"alternative\" \"1\")\n+\t       (eq_attr \"alternative\" \"2\")\n \t\t (if_then_else\n \t\t   (ior (ne (symbol_ref \"TARGET_SSE_TYPELESS_STORES\")\n \t\t\t    (const_int 0))\n@@ -18756,24 +18771,36 @@\n \t       (const_string \"TI\")))])\n \n (define_insn \"movv2di_internal\"\n-  [(set (match_operand:V2DI 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(match_operand:V2DI 1 \"nonimmediate_operand\" \"xm,x\"))]\n+  [(set (match_operand:V2DI 0 \"nonimmediate_operand\" \"=x,x,m\")\n+\t(match_operand:V2DI 1 \"vector_move_operand\" \"C,xm,x\"))]\n   \"TARGET_SSE2\"\n {\n-  if (get_attr_mode (insn) == MODE_V4SF)\n-    return \"movaps\\t{%1, %0|%0, %1}\";\n-  else\n-    return \"movdqa\\t{%1, %0|%0, %1}\";\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (get_attr_mode (insn) == MODE_V4SF)\n+\treturn \"xorps\\t%0, %0\";\n+      else\n+\treturn \"pxor\\t%0, %0\";\n+    case 1:\n+    case 2:\n+      if (get_attr_mode (insn) == MODE_V4SF)\n+\treturn \"movaps\\t{%1, %0|%0, %1}\";\n+      else\n+\treturn \"movdqa\\t{%1, %0|%0, %1}\";\n+    default:\n+      abort ();\n+    }\n }\n   [(set_attr \"type\" \"ssemov\")\n    (set (attr \"mode\")\n-        (cond [(eq_attr \"alternative\" \"0\")\n+        (cond [(eq_attr \"alternative\" \"0,1\")\n \t\t (if_then_else\n \t\t   (ne (symbol_ref \"optimize_size\")\n \t\t       (const_int 0))\n \t\t   (const_string \"V4SF\")\n \t\t   (const_string \"TI\"))\n-\t       (eq_attr \"alternative\" \"1\")\n+\t       (eq_attr \"alternative\" \"2\")\n \t\t (if_then_else\n \t\t   (ior (ne (symbol_ref \"TARGET_SSE_TYPELESS_STORES\")\n \t\t\t    (const_int 0))\n@@ -18798,38 +18825,50 @@\n })\n \n (define_insn \"movv8qi_internal\"\n-  [(set (match_operand:V8QI 0 \"nonimmediate_operand\" \"=y,m\")\n-\t(match_operand:V8QI 1 \"nonimmediate_operand\" \"ym,y\"))]\n+  [(set (match_operand:V8QI 0 \"nonimmediate_operand\" \"=y,y,m\")\n+\t(match_operand:V8QI 1 \"vector_move_operand\" \"C,ym,y\"))]\n   \"TARGET_MMX\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n-  \"movq\\t{%1, %0|%0, %1}\"\n+  \"@\n+    pxor\\t%0, %0\n+    movq\\t{%1, %0|%0, %1}\n+    movq\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"mmxmov\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_insn \"movv4hi_internal\"\n-  [(set (match_operand:V4HI 0 \"nonimmediate_operand\" \"=y,m\")\n-\t(match_operand:V4HI 1 \"nonimmediate_operand\" \"ym,y\"))]\n+  [(set (match_operand:V4HI 0 \"nonimmediate_operand\" \"=y,y,m\")\n+\t(match_operand:V4HI 1 \"vector_move_operand\" \"C,ym,y\"))]\n   \"TARGET_MMX\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n-  \"movq\\t{%1, %0|%0, %1}\"\n+  \"@\n+    pxor\\t%0, %0\n+    movq\\t{%1, %0|%0, %1}\n+    movq\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"mmxmov\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_insn \"movv2si_internal\"\n-  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"=y,m\")\n-\t(match_operand:V2SI 1 \"nonimmediate_operand\" \"ym,y\"))]\n+  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"=y,y,m\")\n+\t(match_operand:V2SI 1 \"vector_move_operand\" \"C,ym,y\"))]\n   \"TARGET_MMX\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n-  \"movq\\t{%1, %0|%0, %1}\"\n+  \"@\n+    pxor\\t%0, %0\n+    movq\\t{%1, %0|%0, %1}\n+    movq\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"mmxcvt\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_insn \"movv2sf_internal\"\n-  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=y,m\")\n-        (match_operand:V2SF 1 \"nonimmediate_operand\" \"ym,y\"))]\n+  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=y,y,m\")\n+        (match_operand:V2SF 1 \"vector_move_operand\" \"C,ym,y\"))]\n   \"TARGET_3DNOW\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n-  \"movq\\\\t{%1, %0|%0, %1}\"\n+  \"@\n+    pxor\\t%0, %0\n+    movq\\t{%1, %0|%0, %1}\n+    movq\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"mmxcvt\")\n    (set_attr \"mode\" \"DI\")])\n \n@@ -18846,25 +18885,37 @@\n })\n \n (define_insn \"movv2df_internal\"\n-  [(set (match_operand:V2DF 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(match_operand:V2DF 1 \"nonimmediate_operand\" \"xm,x\"))]\n+  [(set (match_operand:V2DF 0 \"nonimmediate_operand\" \"=x,x,m\")\n+\t(match_operand:V2DF 1 \"vector_move_operand\" \"C,xm,x\"))]\n   \"TARGET_SSE2\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n {\n-  if (get_attr_mode (insn) == MODE_V4SF)\n-    return \"movaps\\t{%1, %0|%0, %1}\";\n-  else\n-    return \"movapd\\t{%1, %0|%0, %1}\";\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (get_attr_mode (insn) == MODE_V4SF)\n+\treturn \"xorps\\t%0, %0\";\n+      else\n+\treturn \"xorpd\\t%0, %0\";\n+    case 1:\n+    case 2:\n+      if (get_attr_mode (insn) == MODE_V4SF)\n+\treturn \"movaps\\t{%1, %0|%0, %1}\";\n+      else\n+\treturn \"movapd\\t{%1, %0|%0, %1}\";\n+    default:\n+      abort ();\n+    }\n }\n   [(set_attr \"type\" \"ssemov\")\n    (set (attr \"mode\")\n-        (cond [(eq_attr \"alternative\" \"0\")\n+        (cond [(eq_attr \"alternative\" \"0,1\")\n \t\t (if_then_else\n \t\t   (ne (symbol_ref \"optimize_size\")\n \t\t       (const_int 0))\n \t\t   (const_string \"V4SF\")\n \t\t   (const_string \"V2DF\"))\n-\t       (eq_attr \"alternative\" \"1\")\n+\t       (eq_attr \"alternative\" \"2\")\n \t\t (if_then_else\n \t\t   (ior (ne (symbol_ref \"TARGET_SSE_TYPELESS_STORES\")\n \t\t\t    (const_int 0))\n@@ -18875,25 +18926,37 @@\n \t       (const_string \"V2DF\")))])\n \n (define_insn \"movv8hi_internal\"\n-  [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(match_operand:V8HI 1 \"nonimmediate_operand\" \"xm,x\"))]\n+  [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"=x,x,m\")\n+\t(match_operand:V8HI 1 \"vector_move_operand\" \"C,xm,x\"))]\n   \"TARGET_SSE2\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n {\n-  if (get_attr_mode (insn) == MODE_V4SF)\n-    return \"movaps\\t{%1, %0|%0, %1}\";\n-  else\n-    return \"movdqa\\t{%1, %0|%0, %1}\";\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (get_attr_mode (insn) == MODE_V4SF)\n+\treturn \"xorps\\t%0, %0\";\n+      else\n+\treturn \"pxor\\t%0, %0\";\n+    case 1:\n+    case 2:\n+      if (get_attr_mode (insn) == MODE_V4SF)\n+\treturn \"movaps\\t{%1, %0|%0, %1}\";\n+      else\n+\treturn \"movdqa\\t{%1, %0|%0, %1}\";\n+    default:\n+      abort ();\n+    }\n }\n   [(set_attr \"type\" \"ssemov\")\n    (set (attr \"mode\")\n-        (cond [(eq_attr \"alternative\" \"0\")\n+        (cond [(eq_attr \"alternative\" \"0,1\")\n \t\t (if_then_else\n \t\t   (ne (symbol_ref \"optimize_size\")\n \t\t       (const_int 0))\n \t\t   (const_string \"V4SF\")\n \t\t   (const_string \"TI\"))\n-\t       (eq_attr \"alternative\" \"1\")\n+\t       (eq_attr \"alternative\" \"2\")\n \t\t (if_then_else\n \t\t   (ior (ne (symbol_ref \"TARGET_SSE_TYPELESS_STORES\")\n \t\t\t    (const_int 0))\n@@ -18904,25 +18967,37 @@\n \t       (const_string \"TI\")))])\n \n (define_insn \"movv16qi_internal\"\n-  [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(match_operand:V16QI 1 \"nonimmediate_operand\" \"xm,x\"))]\n+  [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"=x,x,m\")\n+\t(match_operand:V16QI 1 \"nonimmediate_operand\" \"C,xm,x\"))]\n   \"TARGET_SSE2\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n {\n-  if (get_attr_mode (insn) == MODE_V4SF)\n-    return \"movaps\\t{%1, %0|%0, %1}\";\n-  else\n-    return \"movdqa\\t{%1, %0|%0, %1}\";\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (get_attr_mode (insn) == MODE_V4SF)\n+\treturn \"xorps\\t%0, %0\";\n+      else\n+\treturn \"pxor\\t%0, %0\";\n+    case 1:\n+    case 2:\n+      if (get_attr_mode (insn) == MODE_V4SF)\n+\treturn \"movaps\\t{%1, %0|%0, %1}\";\n+      else\n+\treturn \"movdqa\\t{%1, %0|%0, %1}\";\n+    default:\n+      abort ();\n+    }\n }\n   [(set_attr \"type\" \"ssemov\")\n    (set (attr \"mode\")\n-        (cond [(eq_attr \"alternative\" \"0\")\n+        (cond [(eq_attr \"alternative\" \"0,1\")\n \t\t (if_then_else\n \t\t   (ne (symbol_ref \"optimize_size\")\n \t\t       (const_int 0))\n \t\t   (const_string \"V4SF\")\n \t\t   (const_string \"TI\"))\n-\t       (eq_attr \"alternative\" \"1\")\n+\t       (eq_attr \"alternative\" \"2\")\n \t\t (if_then_else\n \t\t   (ior (ne (symbol_ref \"TARGET_SSE_TYPELESS_STORES\")\n \t\t\t    (const_int 0))\n@@ -19113,7 +19188,7 @@\n \n (define_insn \"movti_internal\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=x,x,m\")\n-\t(match_operand:TI 1 \"general_operand\" \"C,xm,x\"))]\n+\t(match_operand:TI 1 \"vector_move_operand\" \"C,xm,x\"))]\n   \"TARGET_SSE && !TARGET_64BIT\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n {"}]}