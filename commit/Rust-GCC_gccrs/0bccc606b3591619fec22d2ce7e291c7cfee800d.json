{"sha": "0bccc606b3591619fec22d2ce7e291c7cfee800d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJjY2M2MDZiMzU5MTYxOWZlYzIyZDJjZTdlMjkxYzdjZmVlODAwZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-09-08T15:44:46Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-08T15:44:46Z"}, "message": "final.c (shorten_branches, [...]): Use gcc_assert and gcc_unreachable.\n\n\t* final.c (shorten_branches, final, get_insn_template,\n\toutput_alternate_entry_point, final_scan_insn, alter_subreg,\n\talter_cond, output_operand, asm_fprintf, final_forward_branch_p,\n\tleaf_renumber_regs_insn): Use gcc_assert and gcc_unreachable.\n\t* fix-header.c (lookup_std_proto): Likewise.\n\t* flow.c (first_insn_after_basic_block_note, verify_wide_reg,\n\tverify_local_live_at_start, update_life_info, mark_reg,\n\tcalculate_global_regs_live, allocate_reg_life_data,\n\tinit_propagate_block_info, mark_set_regs, flush_reg_cond_reg_1,\n\tior_reg_cond, not_reg_cond, and_reg_cond, elim_reg_cond,\n\tattempt_auto_inc, mark_used_reg, mark_used_regs): Likewise.\n\t* fold-const.c (force_fit_type, div_and_round_double,\n\tmay_negate_without_overflow_p, int_const_binop, const_binop,\n\tsize_binop, size_diffop, fold_convert_const, fold_convert,\n\tinvert_tree_comparison, swap_tree_comparison,\n\tcomparison_to_compcode, compcode_to_comparison, invert_truthvalue,\n\trange_binop, make_range, fold_cond_expr_with_comparison,\n\tfold_div_compare, fold, fold_checksum_tree, fold_negate_const,\n\tfold_abs_const, fold_not_const, fold_relational_const, round_up,\n\tround_down): Likewise.\n\t* function.c (find_function_data, assign_stack_temp_for_type,\n\tinstantiate_virtual_regs_lossage, aggregate_value_p,\n\tassign_parm_find_entry_rtl, assign_parm_setup_block,\n\texpand_function_start, expand_function_end, keep_stack_depressed,\n\thandle_epilogue_set, thread_prologue_and_epilogue_insns): Likewise.\n\nFrom-SVN: r87192", "tree": {"sha": "d4ae6549382aa7dcd6e2e812d293953633ea36c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4ae6549382aa7dcd6e2e812d293953633ea36c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bccc606b3591619fec22d2ce7e291c7cfee800d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bccc606b3591619fec22d2ce7e291c7cfee800d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bccc606b3591619fec22d2ce7e291c7cfee800d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bccc606b3591619fec22d2ce7e291c7cfee800d/comments", "author": null, "committer": null, "parents": [{"sha": "5f4a098e0594c3d49af7ce0c06dc60d6e3d395a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f4a098e0594c3d49af7ce0c06dc60d6e3d395a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f4a098e0594c3d49af7ce0c06dc60d6e3d395a8"}], "stats": {"total": 566, "additions": 286, "deletions": 280}, "files": [{"sha": "9418f0859e280b607f958db2556c728b23fd0659", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bccc606b3591619fec22d2ce7e291c7cfee800d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bccc606b3591619fec22d2ce7e291c7cfee800d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bccc606b3591619fec22d2ce7e291c7cfee800d", "patch": "@@ -1,3 +1,31 @@\n+2004-09-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* final.c (shorten_branches, final, get_insn_template,\n+\toutput_alternate_entry_point, final_scan_insn, alter_subreg,\n+\talter_cond, output_operand, asm_fprintf, final_forward_branch_p,\n+\tleaf_renumber_regs_insn): Use gcc_assert and gcc_unreachable.\n+\t* fix-header.c (lookup_std_proto): Likewise.\n+\t* flow.c (first_insn_after_basic_block_note, verify_wide_reg,\n+\tverify_local_live_at_start, update_life_info, mark_reg,\n+\tcalculate_global_regs_live, allocate_reg_life_data,\n+\tinit_propagate_block_info, mark_set_regs, flush_reg_cond_reg_1,\n+\tior_reg_cond, not_reg_cond, and_reg_cond, elim_reg_cond,\n+\tattempt_auto_inc, mark_used_reg, mark_used_regs): Likewise.\n+\t* fold-const.c (force_fit_type, div_and_round_double,\n+\tmay_negate_without_overflow_p, int_const_binop, const_binop,\n+\tsize_binop, size_diffop, fold_convert_const, fold_convert,\n+\tinvert_tree_comparison, swap_tree_comparison,\n+\tcomparison_to_compcode, compcode_to_comparison, invert_truthvalue,\n+\trange_binop, make_range, fold_cond_expr_with_comparison,\n+\tfold_div_compare, fold, fold_checksum_tree, fold_negate_const,\n+\tfold_abs_const, fold_not_const, fold_relational_const, round_up,\n+\tround_down): Likewise.\n+\t* function.c (find_function_data, assign_stack_temp_for_type,\n+\tinstantiate_virtual_regs_lossage, aggregate_value_p,\n+\tassign_parm_find_entry_rtl, assign_parm_setup_block,\n+\texpand_function_start, expand_function_end, keep_stack_depressed,\n+\thandle_epilogue_set, thread_prologue_and_epilogue_insns): Likewise.\n+\n 2004-09-08  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* Makefile.in (tree-loop-linear.o): Added."}, {"sha": "a0fd5b7f2fa3d3f53cf015f112faee311766863d", "filename": "gcc/final.c", "status": "modified", "additions": 27, "deletions": 39, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bccc606b3591619fec22d2ce7e291c7cfee800d/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bccc606b3591619fec22d2ce7e291c7cfee800d/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=0bccc606b3591619fec22d2ce7e291c7cfee800d", "patch": "@@ -788,8 +788,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n \n       /* Range of labels grows monotonically in the function.  Abort here\n          means that the initialization of array got lost.  */\n-      if (n_old_labels > n_labels)\n-\tabort ();\n+      gcc_assert (n_old_labels <= n_labels);\n \n       memset (label_align + n_old_labels, 0,\n \t      (n_labels - n_old_labels) * sizeof (struct label_alignment));\n@@ -933,8 +932,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n \t    continue;\n \t  pat = PATTERN (insn);\n \t  len = XVECLEN (pat, 1);\n-\t  if (len <= 0)\n-\t    abort ();\n+\t  gcc_assert (len > 0);\n \t  min_align = MAX_CODE_ALIGN;\n \t  for (min = max_shuid, max = min_shuid, i = len - 1; i >= 0; i--)\n \t    {\n@@ -1566,10 +1564,8 @@ final (rtx first, FILE *file, int optimize, int prescan)\n \t{\n \t  /* This can be triggered by bugs elsewhere in the compiler if\n \t     new insns are created after init_insn_lengths is called.  */\n-\t  if (NOTE_P (insn))\n-\t    insn_current_address = -1;\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (NOTE_P (insn));\n+\t  insn_current_address = -1;\n \t}\n       else\n \tinsn_current_address = INSN_ADDRESSES (INSN_UID (insn));\n@@ -1589,12 +1585,11 @@ get_insn_template (int code, rtx insn)\n     case INSN_OUTPUT_FORMAT_MULTI:\n       return insn_data[code].output.multi[which_alternative];\n     case INSN_OUTPUT_FORMAT_FUNCTION:\n-      if (insn == NULL)\n-\tabort ();\n+      gcc_assert (insn);\n       return (*insn_data[code].output.function) (recog_data.operand, insn);\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1625,7 +1620,7 @@ output_alternate_entry_point (FILE *file, rtx insn)\n \n     case LABEL_NORMAL:\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1822,8 +1817,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \n \t      /* End of a symbol-block.  */\n \t      --block_depth;\n-\t      if (block_depth < 0)\n-\t\tabort ();\n+\t      gcc_assert (block_depth >= 0);\n \n \t      (*debug_hooks->end_block) (high_block_linenum, n);\n \t    }\n@@ -1844,8 +1838,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t  break;\n \n \tdefault:\n-\t  if (NOTE_LINE_NUMBER (insn) <= 0)\n-\t    abort ();\n+\t  gcc_assert (NOTE_LINE_NUMBER (insn) > 0);\n \t  break;\n \t}\n       break;\n@@ -2039,15 +2032,15 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n #ifdef ASM_OUTPUT_ADDR_VEC\n \t\tASM_OUTPUT_ADDR_VEC (PREV_INSN (insn), body);\n #else\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n #endif\n \t      }\n \t    else\n \t      {\n #ifdef ASM_OUTPUT_ADDR_DIFF_VEC\n \t\tASM_OUTPUT_ADDR_DIFF_VEC (PREV_INSN (insn), body);\n #else\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n #endif\n \t      }\n #else\n@@ -2060,7 +2053,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t\t    ASM_OUTPUT_ADDR_VEC_ELT\n \t\t      (file, CODE_LABEL_NUMBER (XEXP (XVECEXP (body, 0, idx), 0)));\n #else\n-\t\t    abort ();\n+\t\t    gcc_unreachable ();\n #endif\n \t\t  }\n \t\telse\n@@ -2072,7 +2065,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t\t       CODE_LABEL_NUMBER (XEXP (XVECEXP (body, 1, idx), 0)),\n \t\t       CODE_LABEL_NUMBER (XEXP (XEXP (body, 0), 0)));\n #else\n-\t\t    abort ();\n+\t\t    gcc_unreachable ();\n #endif\n \t\t  }\n \t      }\n@@ -2478,8 +2471,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t  {\n \t    rtx prev;\n \n-\t    if (prev_nonnote_insn (insn) != last_ignored_compare)\n-\t      abort ();\n+\t    gcc_assert (prev_nonnote_insn (insn) == last_ignored_compare);\n \n \t    /* We have already processed the notes between the setter and\n \t       the user.  Make sure we don't process them again, this is\n@@ -2510,7 +2502,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t    /* This instruction should have been split in shorten_branches,\n \t       to ensure that we would have valid length info for the\n \t       splitees.  */\n-\t    abort ();\n+\t    gcc_unreachable ();\n #endif\n \n \t    return new;\n@@ -2622,14 +2614,14 @@ alter_subreg (rtx *xp)\n \n       if (new != 0)\n \t*xp = new;\n-      /* Simplify_subreg can't handle some REG cases, but we have to.  */\n-      else if (REG_P (y))\n+      else\n \t{\n+\t  /* Simplify_subreg can't handle some REG cases, but we have to.  */\n \t  unsigned int regno = subreg_hard_regno (x, 1);\n+\t  \n+\t  gcc_assert (REG_P (y));\n \t  *xp = gen_rtx_REG_offset (y, GET_MODE (x), regno, SUBREG_BYTE (x));\n \t}\n-      else\n-\tabort ();\n     }\n \n   return *xp;\n@@ -2780,7 +2772,7 @@ alter_cond (rtx cond)\n     switch (GET_CODE (cond))\n       {\n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n \n       case NE:\n \tPUT_CODE (cond, cc_status.flags & CC_Z_IN_N ? GE : LT);\n@@ -3209,9 +3201,7 @@ output_operand (rtx x, int code ATTRIBUTE_UNUSED)\n \n   /* If X is a pseudo-register, abort now rather than writing trash to the\n      assembler file.  */\n-\n-  if (x && REG_P (x) && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n-    abort ();\n+  gcc_assert (!x || !REG_P (x) || REGNO (x) < FIRST_PSEUDO_REGISTER);\n \n   PRINT_OPERAND (asm_out_file, x, code);\n }\n@@ -3510,7 +3500,7 @@ asm_fprintf (FILE *file, const char *p, ...)\n \t  ASM_FPRINTF_EXTENSIONS (file, argptr, p)\n #endif\n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n \tbreak;\n \n@@ -3711,13 +3701,12 @@ int\n final_forward_branch_p (rtx insn)\n {\n   int insn_id, label_id;\n-  if (!uid_shuid)\n-    abort ();\n+  \n+  gcc_assert (uid_shuid);\n   insn_id = INSN_SHUID (insn);\n   label_id = INSN_SHUID (JUMP_LABEL (insn));\n   /* We've hit some insns that does not have id information available.  */\n-  if (!insn_id || !label_id)\n-    abort ();\n+  gcc_assert (insn_id && label_id);\n   return insn_id < label_id;\n }\n \n@@ -3809,8 +3798,7 @@ leaf_renumber_regs_insn (rtx in_rtx)\n \t  return;\n \t}\n       newreg = LEAF_REG_REMAP (newreg);\n-      if (newreg < 0)\n-\tabort ();\n+      gcc_assert (newreg >= 0);\n       regs_ever_live[REGNO (in_rtx)] = 0;\n       regs_ever_live[newreg] = 1;\n       REGNO (in_rtx) = newreg;\n@@ -3853,7 +3841,7 @@ leaf_renumber_regs_insn (rtx in_rtx)\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n }\n #endif"}, {"sha": "9bd79d404ce77764098c195dfef186c4d529ccb9", "filename": "gcc/fix-header.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bccc606b3591619fec22d2ce7e291c7cfee800d/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bccc606b3591619fec22d2ce7e291c7cfee800d/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=0bccc606b3591619fec22d2ce7e291c7cfee800d", "patch": "@@ -397,8 +397,7 @@ lookup_std_proto (const char *name, int name_length)\n \t  && strncmp (fn->fname, name, name_length) == 0)\n \treturn fn;\n       i = (i+1) % HASH_SIZE;\n-      if (i == i0)\n-\tabort ();\n+      gcc_assert (i != i0);\n     }\n }\n "}, {"sha": "d1e7e2d61c4948683fb8a09e31f5ff834a5391d6", "filename": "gcc/flow.c", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bccc606b3591619fec22d2ce7e291c7cfee800d/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bccc606b3591619fec22d2ce7e291c7cfee800d/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=0bccc606b3591619fec22d2ce7e291c7cfee800d", "patch": "@@ -346,8 +346,7 @@ first_insn_after_basic_block_note (basic_block block)\n     return NULL_RTX;\n   if (LABEL_P (insn))\n     insn = NEXT_INSN (insn);\n-  if (!NOTE_INSN_BASIC_BLOCK_P (insn))\n-    abort ();\n+  gcc_assert (NOTE_INSN_BASIC_BLOCK_P (insn));\n \n   return NEXT_INSN (insn);\n }\n@@ -487,13 +486,12 @@ verify_wide_reg (int regno, basic_block bb)\n \tbreak;\n       head = NEXT_INSN (head);\n     }\n-\n   if (dump_file)\n     {\n       fprintf (dump_file, \"Register %d died unexpectedly.\\n\", regno);\n       dump_bb (bb, dump_file, 0);\n     }\n-  abort ();\n+  fatal_error (\"internal consistency failure\");\n }\n \n /* A subroutine of update_life_info.  Verify that there are no untoward\n@@ -517,7 +515,7 @@ verify_local_live_at_start (regset new_live_at_start, basic_block bb)\n \t      fputs (\"Old:\\n\", dump_file);\n \t      dump_bb (bb, dump_file, 0);\n \t    }\n-\t  abort ();\n+\t  fatal_error (\"internal consistency failure\");\n \t}\n     }\n   else\n@@ -538,9 +536,8 @@ verify_local_live_at_start (regset new_live_at_start, basic_block bb)\n \t\t\t   \"Register %d died unexpectedly.\\n\", i);\n \t\t  dump_bb (bb, dump_file, 0);\n \t\t}\n-\t      abort ();\n+\t      fatal_error (\"internal consistency failure\");\n \t    }\n-\n \t  /* Verify that the now-live register is wider than word_mode.  */\n \t  verify_wide_reg (i, bb);\n \t});\n@@ -587,9 +584,8 @@ update_life_info (sbitmap blocks, enum update_life_extent extent, int prop_flags\n \n   /* Changes to the CFG are only allowed when\n      doing a global update for the entire CFG.  */\n-  if ((prop_flags & PROP_ALLOW_CFG_CHANGES)\n-      && (extent == UPDATE_LIFE_LOCAL || blocks))\n-    abort ();\n+  gcc_assert (!(prop_flags & PROP_ALLOW_CFG_CHANGES)\n+\t      || (extent != UPDATE_LIFE_LOCAL && !blocks));\n \n   /* For a global update, we go through the relaxation process again.  */\n   if (extent != UPDATE_LIFE_LOCAL)\n@@ -901,8 +897,7 @@ mark_reg (rtx reg, void *xset)\n   regset set = (regset) xset;\n   int regno = REGNO (reg);\n \n-  if (GET_MODE (reg) == BLKmode)\n-    abort ();\n+  gcc_assert (GET_MODE (reg) != BLKmode);\n \n   SET_REGNO_REG_SET (set, regno);\n   if (regno < FIRST_PSEUDO_REGISTER)\n@@ -1025,8 +1020,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n      sick behavior here.  */\n #ifdef ENABLE_CHECKING\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-    if (bb->aux)\n-      abort ();\n+    gcc_assert (!bb->aux);\n #endif\n \n   tmp = INITIALIZE_REG_SET (tmp_head);\n@@ -1436,8 +1430,7 @@ allocate_reg_life_data (void)\n   int i;\n \n   max_regno = max_reg_num ();\n-  if (reg_deaths)\n-    abort ();\n+  gcc_assert (!reg_deaths);\n   reg_deaths = xcalloc (sizeof (*reg_deaths), max_regno);\n \n   /* Recalculate the register space, in case it has grown.  Old style\n@@ -1845,14 +1838,13 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t      bb_false = bb_true;\n \t      bb_true = t;\n \t    }\n-\t  else if (! (bb->succ->succ_next->flags & EDGE_FALLTHRU))\n-\t    abort ();\n+\t  else\n+\t    gcc_assert (bb->succ->succ_next->flags & EDGE_FALLTHRU);\n \t}\n       else\n \t{\n \t  /* This can happen with a conditional jump to the next insn.  */\n-\t  if (JUMP_LABEL (BB_END (bb)) != BB_HEAD (bb_true))\n-\t    abort ();\n+\t  gcc_assert (JUMP_LABEL (BB_END (bb)) == BB_HEAD (bb_true));\n \n \t  /* Simplest way to do nothing.  */\n \t  bb_false = bb_true;\n@@ -2468,8 +2460,7 @@ mark_set_regs (struct propagate_block_info *pbi, rtx x, rtx insn)\n \t    switch (code = GET_CODE (sub))\n \t      {\n \t      case COND_EXEC:\n-\t\tif (cond != NULL_RTX)\n-\t\t  abort ();\n+\t\tgcc_assert (!cond);\n \n \t\tcond = COND_EXEC_TEST (sub);\n \t\tsub = COND_EXEC_CODE (sub);\n@@ -2958,8 +2949,8 @@ flush_reg_cond_reg_1 (splay_tree_node node, void *data)\n       xdata[1] = node->key;\n       return -1;\n     }\n-  else if (rcli->condition == const1_rtx)\n-    abort ();\n+  else\n+    gcc_assert (rcli->condition != const1_rtx);\n \n   return 0;\n }\n@@ -3073,7 +3064,7 @@ ior_reg_cond (rtx old, rtx x, int add)\n       return gen_rtx_IOR (0, old, x);\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -3089,8 +3080,7 @@ not_reg_cond (rtx x)\n   if (COMPARISON_P (x)\n       && REG_P (XEXP (x, 0)))\n     {\n-      if (XEXP (x, 1) != const0_rtx)\n-\tabort ();\n+      gcc_assert (XEXP (x, 1) == const0_rtx);\n \n       return gen_rtx_fmt_ee (reversed_comparison_code (x, NULL),\n \t\t\t     VOIDmode, XEXP (x, 0), const0_rtx);\n@@ -3182,7 +3172,7 @@ and_reg_cond (rtx old, rtx x, int add)\n       return gen_rtx_AND (0, old, x);\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -3242,7 +3232,7 @@ elim_reg_cond (rtx x, unsigned int regno)\n       return x;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n #endif /* HAVE_conditional_execution */\n@@ -3264,6 +3254,7 @@ attempt_auto_inc (struct propagate_block_info *pbi, rtx inc, rtx insn,\n   rtx q = SET_DEST (set);\n   rtx y = SET_SRC (set);\n   int opnum = XEXP (y, 0) == incr_reg ? 0 : 1;\n+  int changed;\n \n   /* Make sure this reg appears only once in this insn.  */\n   if (count_occurrences (PATTERN (insn), incr_reg, 1) != 1)\n@@ -3363,8 +3354,8 @@ attempt_auto_inc (struct propagate_block_info *pbi, rtx inc, rtx insn,\n \n   /* Modify the old increment-insn to simply copy\n      the already-incremented value of our register.  */\n-  if (! validate_change (incr, &SET_SRC (set), incr_reg, 0))\n-    abort ();\n+  changed = validate_change (incr, &SET_SRC (set), incr_reg, 0);\n+  gcc_assert (changed);\n \n   /* If that makes it a no-op (copying the register into itself) delete\n      it so it won't appear to be a \"use\" and a \"set\" of this\n@@ -3570,10 +3561,7 @@ mark_used_reg (struct propagate_block_info *pbi, rtx reg,\n       for (i = regno_first; i <= regno_last; ++i)\n \tif (! REGNO_REG_SET_P (pbi->reg_live, i))\n \t  {\n-#ifdef ENABLE_CHECKING\n-\t    if (reg_deaths[i])\n-\t      abort ();\n-#endif\n+\t    gcc_assert (!reg_deaths[i]);\n \t    reg_deaths[i] = pbi->insn_num;\n \t  }\n     }\n@@ -3925,8 +3913,7 @@ mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n       }\n \n     case COND_EXEC:\n-      if (cond != NULL_RTX)\n-\tabort ();\n+      gcc_assert (!cond);\n \n       mark_used_regs (pbi, COND_EXEC_TEST (x), NULL_RTX, insn);\n "}, {"sha": "f6c5396204996e8804ab7b48f6b4b78b08e03b74", "filename": "gcc/fold-const.c", "status": "modified", "additions": 140, "deletions": 133, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bccc606b3591619fec22d2ce7e291c7cfee800d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bccc606b3591619fec22d2ce7e291c7cfee800d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0bccc606b3591619fec22d2ce7e291c7cfee800d", "patch": "@@ -207,8 +207,7 @@ force_fit_type (tree t, int overflowable,\n   unsigned int prec;\n   int sign_extended_type;\n \n-  if (TREE_CODE (t) != INTEGER_CST)\n-    abort ();\n+  gcc_assert (TREE_CODE (t) == INTEGER_CST);\n   \n   low = TREE_INT_CST_LOW (t);\n   high = TREE_INT_CST_HIGH (t);\n@@ -825,7 +824,7 @@ div_and_round_double (enum tree_code code, int uns,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Compute true remainder:  rem = num - (quo * den)  */\n@@ -873,8 +872,7 @@ may_negate_without_overflow_p (tree t)\n   unsigned int prec;\n   tree type;\n \n-  if (TREE_CODE (t) != INTEGER_CST)\n-    abort ();\n+  gcc_assert (TREE_CODE (t) == INTEGER_CST);\n \n   type = TREE_TYPE (t);\n   if (TYPE_UNSIGNED (type))\n@@ -1425,7 +1423,7 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   t = build_int_cst_wide (TREE_TYPE (arg1), low, hi);\n@@ -1588,7 +1586,7 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       return t;\n     }\n@@ -1614,9 +1612,8 @@ size_binop (enum tree_code code, tree arg0, tree arg1)\n {\n   tree type = TREE_TYPE (arg0);\n \n-  if (TREE_CODE (type) != INTEGER_TYPE || ! TYPE_IS_SIZETYPE (type)\n-      || type != TREE_TYPE (arg1))\n-    abort ();\n+  gcc_assert (TREE_CODE (type) == INTEGER_TYPE && TYPE_IS_SIZETYPE (type)\n+\t      && type == TREE_TYPE (arg1));\n \n   /* Handle the special case of two integer constants faster.  */\n   if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n@@ -1650,9 +1647,8 @@ size_diffop (tree arg0, tree arg1)\n   tree type = TREE_TYPE (arg0);\n   tree ctype;\n \n-  if (TREE_CODE (type) != INTEGER_TYPE || ! TYPE_IS_SIZETYPE (type)\n-      || type != TREE_TYPE (arg1))\n-    abort ();\n+  gcc_assert (TREE_CODE (type) == INTEGER_TYPE && TYPE_IS_SIZETYPE (type)\n+\t      && type == TREE_TYPE (arg1));\n \n   /* If the type is already signed, just do the simple thing.  */\n   if (!TYPE_UNSIGNED (type))\n@@ -1753,7 +1749,7 @@ fold_convert_const (enum tree_code code, tree type, tree arg1)\n \t      break;\n \n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \n \t  /* If R is NaN, return zero and show we have an overflow.  */\n@@ -1854,9 +1850,11 @@ fold_convert (tree type, tree arg)\n \t\t\t\t\tTYPE_MAIN_VARIANT (orig)))\n     return fold (build1 (NOP_EXPR, type, arg));\n \n-  if (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type)\n-      || TREE_CODE (type) == OFFSET_TYPE)\n+  switch (TREE_CODE (type))\n     {\n+    case INTEGER_TYPE: case CHAR_TYPE: case ENUMERAL_TYPE: case BOOLEAN_TYPE:\n+    case POINTER_TYPE: case REFERENCE_TYPE:\n+    case OFFSET_TYPE:\n       if (TREE_CODE (arg) == INTEGER_CST)\n \t{\n \t  tem = fold_convert_const (NOP_EXPR, type, arg);\n@@ -1871,12 +1869,11 @@ fold_convert (tree type, tree arg)\n \t  tem = fold (build1 (REALPART_EXPR, TREE_TYPE (orig), arg));\n \t  return fold_convert (type, tem);\n \t}\n-      if (TREE_CODE (orig) == VECTOR_TYPE\n-\t  && tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)))\n-\treturn fold (build1 (NOP_EXPR, type, arg));\n-    }\n-  else if (TREE_CODE (type) == REAL_TYPE)\n-    {\n+      gcc_assert (TREE_CODE (orig) == VECTOR_TYPE\n+\t\t  && tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)));\n+      return fold (build1 (NOP_EXPR, type, arg));\n+      \n+    case REAL_TYPE:\n       if (TREE_CODE (arg) == INTEGER_CST)\n \t{\n \t  tem = fold_convert_const (FLOAT_EXPR, type, arg);\n@@ -1890,56 +1887,70 @@ fold_convert (tree type, tree arg)\n \t    return tem;\n \t}\n \n-      if (INTEGRAL_TYPE_P (orig) || POINTER_TYPE_P (orig))\n-        return fold (build1 (FLOAT_EXPR, type, arg));\n-      if (TREE_CODE (orig) == REAL_TYPE)\n-\treturn fold (build1 (flag_float_store ? CONVERT_EXPR : NOP_EXPR,\n-\t\t\t     type, arg));\n-      if (TREE_CODE (orig) == COMPLEX_TYPE)\n+      switch (TREE_CODE (orig))\n \t{\n+\tcase INTEGER_TYPE: case CHAR_TYPE:\n+\tcase BOOLEAN_TYPE: case ENUMERAL_TYPE:\n+\tcase POINTER_TYPE: case REFERENCE_TYPE:\n+\t  return fold (build1 (FLOAT_EXPR, type, arg));\n+\t  \n+\tcase REAL_TYPE:\n+\t  return fold (build1 (flag_float_store ? CONVERT_EXPR : NOP_EXPR,\n+\t\t\t       type, arg));\n+\t  \n+\tcase COMPLEX_TYPE:\n \t  tem = fold (build1 (REALPART_EXPR, TREE_TYPE (orig), arg));\n \t  return fold_convert (type, tem);\n+\t  \n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-    }\n-  else if (TREE_CODE (type) == COMPLEX_TYPE)\n-    {\n-      if (INTEGRAL_TYPE_P (orig)\n-\t  || POINTER_TYPE_P (orig)\n-\t  || TREE_CODE (orig) == REAL_TYPE)\n-\treturn build2 (COMPLEX_EXPR, type,\n-\t\t       fold_convert (TREE_TYPE (type), arg),\n-\t\t       fold_convert (TREE_TYPE (type), integer_zero_node));\n-      if (TREE_CODE (orig) == COMPLEX_TYPE)\n-\t{\n-\t  tree rpart, ipart;\n+      \n+    case COMPLEX_TYPE:\n+      switch (TREE_CODE (orig))\n+\t{\n+\tcase INTEGER_TYPE: case CHAR_TYPE:\n+\tcase BOOLEAN_TYPE: case ENUMERAL_TYPE:\n+\tcase POINTER_TYPE: case REFERENCE_TYPE:\n+\tcase REAL_TYPE:\n+\t  return build2 (COMPLEX_EXPR, type,\n+\t\t\t fold_convert (TREE_TYPE (type), arg),\n+\t\t\t fold_convert (TREE_TYPE (type), integer_zero_node));\n+\tcase COMPLEX_TYPE:\n+\t  {\n+\t    tree rpart, ipart;\n+\t    \n+\t    if (TREE_CODE (arg) == COMPLEX_EXPR)\n+\t      {\n+\t\trpart = fold_convert (TREE_TYPE (type), TREE_OPERAND (arg, 0));\n+\t\tipart = fold_convert (TREE_TYPE (type), TREE_OPERAND (arg, 1));\n+\t\treturn fold (build2 (COMPLEX_EXPR, type, rpart, ipart));\n+\t      }\n+\t    \n+\t    arg = save_expr (arg);\n+\t    rpart = fold (build1 (REALPART_EXPR, TREE_TYPE (orig), arg));\n+\t    ipart = fold (build1 (IMAGPART_EXPR, TREE_TYPE (orig), arg));\n+\t    rpart = fold_convert (TREE_TYPE (type), rpart);\n+\t    ipart = fold_convert (TREE_TYPE (type), ipart);\n+\t    return fold (build2 (COMPLEX_EXPR, type, rpart, ipart));\n+\t  }\n+\t  \n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      \n+    case VECTOR_TYPE:\n+      gcc_assert (tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)));\n+      gcc_assert (INTEGRAL_TYPE_P (orig) || POINTER_TYPE_P (orig)\n+\t\t  || TREE_CODE (orig) == VECTOR_TYPE);\n+      return fold (build1 (NOP_EXPR, type, arg));\n \n-\t  if (TREE_CODE (arg) == COMPLEX_EXPR)\n-\t    {\n-\t      rpart = fold_convert (TREE_TYPE (type), TREE_OPERAND (arg, 0));\n-\t      ipart = fold_convert (TREE_TYPE (type), TREE_OPERAND (arg, 1));\n-\t      return fold (build2 (COMPLEX_EXPR, type, rpart, ipart));\n-\t    }\n+    case VOID_TYPE:\n+      return fold (build1 (CONVERT_EXPR, type, fold_ignored_result (arg)));\n \n-\t  arg = save_expr (arg);\n-\t  rpart = fold (build1 (REALPART_EXPR, TREE_TYPE (orig), arg));\n-\t  ipart = fold (build1 (IMAGPART_EXPR, TREE_TYPE (orig), arg));\n-\t  rpart = fold_convert (TREE_TYPE (type), rpart);\n-\t  ipart = fold_convert (TREE_TYPE (type), ipart);\n-\t  return fold (build2 (COMPLEX_EXPR, type, rpart, ipart));\n-\t}\n-    }\n-  else if (TREE_CODE (type) == VECTOR_TYPE)\n-    {\n-      if ((INTEGRAL_TYPE_P (orig) || POINTER_TYPE_P (orig))\n-\t  && tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)))\n-\treturn fold (build1 (NOP_EXPR, type, arg));\n-      if (TREE_CODE (orig) == VECTOR_TYPE\n-\t  && tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)))\n-\treturn fold (build1 (NOP_EXPR, type, arg));\n+    default:\n+      gcc_unreachable ();\n     }\n-  else if (VOID_TYPE_P (type))\n-    return fold (build1 (CONVERT_EXPR, type, fold_ignored_result (arg)));\n-  abort ();\n }\n \f\n /* Return an expr equal to X but certainly not valid as an lvalue.  */\n@@ -2048,7 +2059,7 @@ invert_tree_comparison (enum tree_code code, bool honor_nans)\n     case UNORDERED_EXPR:\n       return ORDERED_EXPR;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2072,7 +2083,7 @@ swap_tree_comparison (enum tree_code code)\n     case LE_EXPR:\n       return GE_EXPR;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2115,7 +2126,7 @@ comparison_to_compcode (enum tree_code code)\n     case UNGE_EXPR:\n       return COMPCODE_UNGE;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2157,7 +2168,7 @@ compcode_to_comparison (enum comparison_code code)\n     case COMPCODE_UNGE:\n       return UNGE_EXPR;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2959,8 +2970,7 @@ invert_truthvalue (tree arg)\n     default:\n       break;\n     }\n-  if (TREE_CODE (TREE_TYPE (arg)) != BOOLEAN_TYPE)\n-    abort ();\n+  gcc_assert (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE);\n   return build1 (TRUTH_NOT_EXPR, type, arg);\n }\n \n@@ -3486,7 +3496,7 @@ range_binop (enum tree_code code, tree type, tree arg0, int upper0_p,\n       result = sgn0 >= sgn1;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return constant_boolean_node (result, type);\n@@ -3575,7 +3585,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t      in_p = ! in_p, low = 0, high = arg1;\n \t      break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \n \t  /* If this is an unsigned comparison, we also know that EXP is\n@@ -4151,7 +4161,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \ttem = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n \treturn negate_expr (fold_convert (type, tem));\n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n \n   /* A != 0 ? A : 0 is simply A, unless A is -0.  Likewise\n@@ -4247,7 +4257,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \t    }\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -4317,7 +4327,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n       case NE_EXPR:\n \tbreak;\n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n \n   return NULL_TREE;\n@@ -5660,7 +5670,7 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   else\n@@ -5684,7 +5694,7 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -8424,7 +8434,7 @@ fold (tree expr)\n \t    case LT_EXPR:\n \t      return constant_boolean_node (0, type);\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n \n@@ -9024,10 +9034,9 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n   char buf[sizeof (struct tree_decl)];\n   int i, len;\n \n-  if (sizeof (struct tree_exp) + 5 * sizeof (tree)\n-      > sizeof (struct tree_decl)\n-      || sizeof (struct tree_type) > sizeof (struct tree_decl))\n-    abort ();\n+  gcc_assert ((sizeof (struct tree_exp) + 5 * sizeof (tree)\n+\t       <= sizeof (struct tree_decl))\n+\t      && sizeof (struct tree_type) <= sizeof (struct tree_decl));\n   if (expr == NULL)\n     return;\n   slot = htab_find_slot (ht, expr, INSERT);\n@@ -10240,26 +10249,31 @@ fold_negate_const (tree arg0, tree type)\n {\n   tree t = NULL_TREE;\n \n-  if (TREE_CODE (arg0) == INTEGER_CST)\n+  switch (TREE_CODE (arg0))\n     {\n-      unsigned HOST_WIDE_INT low;\n-      HOST_WIDE_INT high;\n-      int overflow = neg_double (TREE_INT_CST_LOW (arg0),\n-\t\t\t\t TREE_INT_CST_HIGH (arg0),\n-\t\t\t\t &low, &high);\n-      t = build_int_cst_wide (type, low, high);\n-      t = force_fit_type (t, 1,\n-\t\t\t  (overflow | TREE_OVERFLOW (arg0))\n-\t\t\t  && !TYPE_UNSIGNED (type),\n-\t\t\t  TREE_CONSTANT_OVERFLOW (arg0));\n-    }\n-  else if (TREE_CODE (arg0) == REAL_CST)\n-    t = build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n-#ifdef ENABLE_CHECKING\n-  else\n-    abort ();\n-#endif\n+    case INTEGER_CST:\n+      {\n+\tunsigned HOST_WIDE_INT low;\n+\tHOST_WIDE_INT high;\n+\tint overflow = neg_double (TREE_INT_CST_LOW (arg0),\n+\t\t\t\t   TREE_INT_CST_HIGH (arg0),\n+\t\t\t\t   &low, &high);\n+\tt = build_int_cst_wide (type, low, high);\n+\tt = force_fit_type (t, 1,\n+\t\t\t    (overflow | TREE_OVERFLOW (arg0))\n+\t\t\t    && !TYPE_UNSIGNED (type),\n+\t\t\t    TREE_CONSTANT_OVERFLOW (arg0));\n+\tbreak;\n+      }\n+      \n+    case REAL_CST:\n+      t = build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n+      break;\n \n+    default:\n+      gcc_unreachable ();\n+    }\n+  \n   return t;\n }\n \n@@ -10273,15 +10287,16 @@ fold_abs_const (tree arg0, tree type)\n {\n   tree t = NULL_TREE;\n \n-  if (TREE_CODE (arg0) == INTEGER_CST)\n+  switch (TREE_CODE (arg0))\n     {\n+    case INTEGER_CST:\n       /* If the value is unsigned, then the absolute value is\n \t the same as the ordinary value.  */\n       if (TYPE_UNSIGNED (type))\n-\treturn arg0;\n+\tt = arg0;\n       /* Similarly, if the value is non-negative.  */\n       else if (INT_CST_LT (integer_minus_one_node, arg0))\n-\treturn arg0;\n+\tt = arg0;\n       /* If the value is negative, then the absolute value is\n \t its negation.  */\n       else\n@@ -10294,21 +10309,20 @@ fold_abs_const (tree arg0, tree type)\n \t  t = build_int_cst_wide (type, low, high);\n \t  t = force_fit_type (t, -1, overflow | TREE_OVERFLOW (arg0),\n \t\t\t      TREE_CONSTANT_OVERFLOW (arg0));\n-\t  return t;\n \t}\n-    }\n-  else if (TREE_CODE (arg0) == REAL_CST)\n-    {\n+      break;\n+      \n+    case REAL_CST:\n       if (REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg0)))\n-\treturn build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n+\tt = build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n       else\n-\treturn arg0;\n+\tt =  arg0;\n+      break;\n+      \n+    default:\n+      gcc_unreachable ();\n     }\n-#ifdef ENABLE_CHECKING\n-  else\n-    abort ();\n-#endif\n-\n+  \n   return t;\n }\n \n@@ -10320,19 +10334,14 @@ fold_not_const (tree arg0, tree type)\n {\n   tree t = NULL_TREE;\n \n-  if (TREE_CODE (arg0) == INTEGER_CST)\n-    {\n-      t = build_int_cst_wide (type,\n-\t\t\t      ~ TREE_INT_CST_LOW (arg0),\n-\t\t\t      ~ TREE_INT_CST_HIGH (arg0));\n-      t = force_fit_type (t, 0, TREE_OVERFLOW (arg0),\n-\t\t\t  TREE_CONSTANT_OVERFLOW (arg0));\n-    }\n-#ifdef ENABLE_CHECKING\n-  else\n-    abort ();\n-#endif\n-\n+  gcc_assert (TREE_CODE (arg0) == INTEGER_CST);\n+  \n+  t = build_int_cst_wide (type,\n+\t\t\t  ~ TREE_INT_CST_LOW (arg0),\n+\t\t\t  ~ TREE_INT_CST_HIGH (arg0));\n+  t = force_fit_type (t, 0, TREE_OVERFLOW (arg0),\n+\t\t      TREE_CONSTANT_OVERFLOW (arg0));\n+  \n   return t;\n }\n \n@@ -10385,7 +10394,7 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n \t      break;\n \n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \n \t  return constant_boolean_node (result, type);\n@@ -10576,8 +10585,7 @@ round_up (tree value, int divisor)\n {\n   tree div = NULL_TREE;\n \n-  if (divisor <= 0)\n-    abort ();\n+  gcc_assert (divisor > 0);\n   if (divisor == 1)\n     return value;\n \n@@ -10621,8 +10629,7 @@ round_down (tree value, int divisor)\n {\n   tree div = NULL_TREE;\n \n-  if (divisor <= 0)\n-    abort ();\n+  gcc_assert (divisor > 0);\n   if (divisor == 1)\n     return value;\n "}, {"sha": "589294ff7a8f213ca9f011df9ef56d33b06328c9", "filename": "gcc/function.c", "status": "modified", "additions": 66, "deletions": 69, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bccc606b3591619fec22d2ce7e291c7cfee800d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bccc606b3591619fec22d2ce7e291c7cfee800d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0bccc606b3591619fec22d2ce7e291c7cfee800d", "patch": "@@ -230,7 +230,7 @@ find_function_data (tree decl)\n     if (p->decl == decl)\n       return p;\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Save the current context for compilation of a nested function.\n@@ -604,12 +604,10 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n \n   /* If SIZE is -1 it means that somebody tried to allocate a temporary\n      of a variable size.  */\n-  if (size == -1)\n-    abort ();\n+  gcc_assert (size != -1);\n \n   /* These are now unused.  */\n-  if (keep > 1)\n-    abort ();\n+  gcc_assert (keep <= 1);\n \n   if (mode == BLKmode)\n     align = BIGGEST_ALIGNMENT;\n@@ -695,8 +693,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n \t So for requests which depended on the rounding of SIZE, we go ahead\n \t and round it now.  We also make sure ALIGNMENT is at least\n \t BIGGEST_ALIGNMENT.  */\n-      if (mode == BLKmode && align < BIGGEST_ALIGNMENT)\n-\tabort ();\n+      gcc_assert (mode != BLKmode || align == BIGGEST_ALIGNMENT);\n       p->slot = assign_stack_local (mode,\n \t\t\t\t    (mode == BLKmode\n \t\t\t\t     ? CEIL_ROUND (size, (int) align / BITS_PER_UNIT)\n@@ -1434,13 +1431,9 @@ instantiate_new_reg (rtx x, HOST_WIDE_INT *poffset)\n static void\n instantiate_virtual_regs_lossage (rtx insn)\n {\n-  if (asm_noperands (PATTERN (insn)) >= 0)\n-    {\n-      error_for_asm (insn, \"impossible constraint in `asm'\");\n-      delete_insn (insn);\n-    }\n-  else\n-    abort ();\n+  gcc_assert (asm_noperands (PATTERN (insn)) >= 0);\n+  error_for_asm (insn, \"impossible constraint in `asm'\");\n+  delete_insn (insn);\n }\n /* Given a pointer to a piece of rtx and an optional pointer to the\n    containing object, instantiate any virtual registers present in it.\n@@ -1862,7 +1855,7 @@ aggregate_value_p (tree exp, tree fntype)\n \tbreak;\n       default:\n \t/* We don't expect other rtl types here.  */\n-\tabort();\n+\tgcc_unreachable ();\n       }\n \n   if (TREE_CODE (type) == VOID_TYPE)\n@@ -2309,8 +2302,7 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n \n \t  /* We assume at most one partial arg, and it must be the first\n \t     argument on the stack.  */\n-\t  if (all->extra_pretend_bytes || all->pretend_args_size)\n-\t    abort ();\n+\t  gcc_assert (!all->extra_pretend_bytes && !all->pretend_args_size);\n \n \t  pretend_bytes = partial * UNITS_PER_WORD;\n \t  all->pretend_args_size = CEIL_ROUND (pretend_bytes, STACK_BYTES);\n@@ -2567,8 +2559,8 @@ assign_parm_setup_block (tree parm, struct assign_parm_data_one *data)\n \t}\n       else if (GET_CODE (entry_parm) == PARALLEL)\n \t;\n-      else if (size != 0 && PARM_BOUNDARY % BITS_PER_WORD != 0)\n-\tabort ();\n+      else\n+\tgcc_assert (!size || !(PARM_BOUNDARY % BITS_PER_WORD));\n \n       mem = validize_mem (stack_parm);\n \n@@ -4029,10 +4021,11 @@ expand_function_start (tree subr)\n \t so we may see a PARALLEL or a REG.  */\n       if (REG_P (hard_reg))\n \tSET_DECL_RTL (DECL_RESULT (subr), gen_reg_rtx (GET_MODE (hard_reg)));\n-      else if (GET_CODE (hard_reg) == PARALLEL)\n-\tSET_DECL_RTL (DECL_RESULT (subr), gen_group_rtx (hard_reg));\n       else\n-\tabort ();\n+\t{\n+\t  gcc_assert (GET_CODE (hard_reg) == PARALLEL);\n+\t  SET_DECL_RTL (DECL_RESULT (subr), gen_group_rtx (hard_reg));\n+\t}\n \n       /* Set DECL_REGISTER flag so that expand_function_end will copy the\n \t result to the real return register(s).  */\n@@ -4321,8 +4314,7 @@ expand_function_end (void)\n \t  rtx real_decl_rtl = current_function_return_rtx;\n \n \t  /* This should be set in assign_parms.  */\n-\t  if (! REG_FUNCTION_VALUE_P (real_decl_rtl))\n-\t    abort ();\n+\t  gcc_assert (REG_FUNCTION_VALUE_P (real_decl_rtl));\n \n \t  /* If this is a BLKmode structure being returned in registers,\n \t     then use the mode computed in expand_return.  Note that if\n@@ -4680,19 +4672,27 @@ keep_stack_depressed (rtx insns)\n \t      insn = next;\n \t      continue;\n \t    }\n-\t  else if (MEM_P (retaddr)\n-\t\t   && REG_P (XEXP (retaddr, 0)))\n-\t    base = gen_rtx_REG (Pmode, REGNO (XEXP (retaddr, 0))), offset = 0;\n-\t  else if (MEM_P (retaddr)\n-\t\t   && GET_CODE (XEXP (retaddr, 0)) == PLUS\n-\t\t   && REG_P (XEXP (XEXP (retaddr, 0), 0))\n-\t\t   && GET_CODE (XEXP (XEXP (retaddr, 0), 1)) == CONST_INT)\n+\t  else\n \t    {\n-\t      base = gen_rtx_REG (Pmode, REGNO (XEXP (XEXP (retaddr, 0), 0)));\n-\t      offset = INTVAL (XEXP (XEXP (retaddr, 0), 1));\n+\t      rtx ret_ptr;\n+\t      gcc_assert (MEM_P (retaddr));\n+\n+\t      ret_ptr = XEXP (retaddr, 0);\n+\t      \n+\t      if (REG_P (ret_ptr))\n+\t\t{\n+\t\t  base = gen_rtx_REG (Pmode, REGNO (ret_ptr));\n+\t\t  offset = 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (GET_CODE (ret_ptr) == PLUS\n+\t\t\t      && REG_P (XEXP (ret_ptr, 0))\n+\t\t\t      && GET_CODE (XEXP (ret_ptr, 1)) == CONST_INT);\n+\t\t  base = gen_rtx_REG (Pmode, REGNO (XEXP (ret_ptr, 0)));\n+\t\t  offset = INTVAL (XEXP (ret_ptr, 1));\n+\t\t}\n \t    }\n-\t  else\n-\t    abort ();\n \n \t  /* If the base of the location containing the return pointer\n \t     is SP, we must update it with the replacement address.  Otherwise,\n@@ -4727,8 +4727,7 @@ keep_stack_depressed (rtx insns)\n \t\t    && info.const_equiv[regno] == 0)\n \t\t  break;\n \n-\t      if (regno == FIRST_PSEUDO_REGISTER)\n-\t\tabort ();\n+\t      gcc_assert (regno < FIRST_PSEUDO_REGISTER);\n \n \t      reg = gen_rtx_REG (Pmode, regno);\n \t      emit_move_insn (reg, retaddr);\n@@ -4740,10 +4739,8 @@ keep_stack_depressed (rtx insns)\n \n \t  /* Show the SET in the above insn is a RETURN.  */\n \t  jump_set = single_set (jump_insn);\n-\t  if (jump_set == 0)\n-\t    abort ();\n-\t  else\n-\t    SET_IS_RETURN_P (jump_set) = 1;\n+\t  gcc_assert (jump_set);\n+\t  SET_IS_RETURN_P (jump_set) = 1;\n \t}\n \n       /* If SP is not mentioned in the pattern and its equivalent register, if\n@@ -4758,11 +4755,13 @@ keep_stack_depressed (rtx insns)\n \t       && (info.sp_equiv_reg == stack_pointer_rtx\n \t\t   || !reg_set_p (info.sp_equiv_reg, insn)))\n \t{\n-\t  if (! validate_replace_rtx (stack_pointer_rtx,\n-\t\t\t\t      plus_constant (info.sp_equiv_reg,\n-\t\t\t\t\t\t     info.sp_offset),\n-\t\t\t\t      insn))\n-\t    abort ();\n+\t  int changed;\n+\n+\t  changed = validate_replace_rtx (stack_pointer_rtx,\n+\t\t\t\t\t  plus_constant (info.sp_equiv_reg,\n+\t\t\t\t\t\t\t info.sp_offset),\n+\t\t\t\t\t  insn);\n+\t  gcc_assert (changed);\n \n \t  add_insn (insn);\n \t}\n@@ -4802,21 +4801,22 @@ handle_epilogue_set (rtx set, struct epi_info *p)\n      set from.  If unknown, abort.  */\n   if (reg_set_p (stack_pointer_rtx, set))\n     {\n-      if (SET_DEST (set) != stack_pointer_rtx)\n-\tabort ();\n+      gcc_assert (SET_DEST (set) == stack_pointer_rtx);\n \n       if (GET_CODE (SET_SRC (set)) == PLUS)\n \t{\n \t  p->new_sp_equiv_reg = XEXP (SET_SRC (set), 0);\n \t  if (GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n \t    p->new_sp_offset = INTVAL (XEXP (SET_SRC (set), 1));\n-\t  else if (REG_P (XEXP (SET_SRC (set), 1))\n-\t\t   && REGNO (XEXP (SET_SRC (set), 1)) < FIRST_PSEUDO_REGISTER\n-\t\t   && p->const_equiv[REGNO (XEXP (SET_SRC (set), 1))] != 0)\n-\t    p->new_sp_offset\n-\t      = INTVAL (p->const_equiv[REGNO (XEXP (SET_SRC (set), 1))]);\n \t  else\n-\t    abort ();\n+\t    {\n+\t      gcc_assert (REG_P (XEXP (SET_SRC (set), 1))\n+\t\t\t  && (REGNO (XEXP (SET_SRC (set), 1))\n+\t\t\t      < FIRST_PSEUDO_REGISTER)\n+\t\t\t  && p->const_equiv[REGNO (XEXP (SET_SRC (set), 1))]);\n+\t      p->new_sp_offset\n+\t\t= INTVAL (p->const_equiv[REGNO (XEXP (SET_SRC (set), 1))]);\n+\t    }\n \t}\n       else\n \tp->new_sp_equiv_reg = SET_SRC (set), p->new_sp_offset = 0;\n@@ -4828,8 +4828,7 @@ handle_epilogue_set (rtx set, struct epi_info *p)\n \t  p->new_sp_offset += p->sp_offset;\n \t}\n \n-      if (p->new_sp_equiv_reg == 0 || !REG_P (p->new_sp_equiv_reg))\n-\tabort ();\n+      gcc_assert (p->new_sp_equiv_reg && REG_P (p->new_sp_equiv_reg));\n \n       return;\n     }\n@@ -4844,17 +4843,16 @@ handle_epilogue_set (rtx set, struct epi_info *p)\n      Pmode).  */\n   else if (p->new_sp_equiv_reg != 0 && reg_set_p (p->new_sp_equiv_reg, set))\n     {\n-      if (p->equiv_reg_src != 0\n-\t  || !REG_P (p->new_sp_equiv_reg)\n-\t  || !REG_P (SET_DEST (set))\n-\t  || GET_MODE_BITSIZE (GET_MODE (SET_DEST (set))) > BITS_PER_WORD\n-\t  || REGNO (p->new_sp_equiv_reg) != REGNO (SET_DEST (set)))\n-\tabort ();\n-      else\n-\tp->equiv_reg_src\n-\t  = simplify_replace_rtx (SET_SRC (set), stack_pointer_rtx,\n-\t\t\t\t  plus_constant (p->sp_equiv_reg,\n-\t\t\t\t\t\t p->sp_offset));\n+      gcc_assert (!p->equiv_reg_src\n+\t\t  && REG_P (p->new_sp_equiv_reg)\n+\t\t  && REG_P (SET_DEST (set))\n+\t\t  && (GET_MODE_BITSIZE (GET_MODE (SET_DEST (set)))\n+\t\t      <= BITS_PER_WORD)\n+\t\t  && REGNO (p->new_sp_equiv_reg) == REGNO (SET_DEST (set)));\n+      p->equiv_reg_src\n+\t= simplify_replace_rtx (SET_SRC (set), stack_pointer_rtx,\n+\t\t\t\tplus_constant (p->sp_equiv_reg,\n+\t\t\t\t\t       p->sp_offset));\n     }\n \n   /* Otherwise, replace any references to SP in the insn to its new value\n@@ -4966,8 +4964,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n       /* Can't deal with multiple successors of the entry block\n          at the moment.  Function should always have at least one\n          entry point.  */\n-      if (!ENTRY_BLOCK_PTR->succ || ENTRY_BLOCK_PTR->succ->succ_next)\n-\tabort ();\n+      gcc_assert (ENTRY_BLOCK_PTR->succ && !ENTRY_BLOCK_PTR->succ->succ_next);\n \n       insert_insn_on_edge (seq, ENTRY_BLOCK_PTR->succ);\n       inserted = 1;"}]}