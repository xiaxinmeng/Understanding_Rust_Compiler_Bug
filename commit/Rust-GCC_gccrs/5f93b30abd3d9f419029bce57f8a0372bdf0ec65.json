{"sha": "5f93b30abd3d9f419029bce57f8a0372bdf0ec65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY5M2IzMGFiZDNkOWY0MTkwMjliY2U1N2Y4YTAzNzJiZGYwZWM2NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-22T23:19:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-22T23:19:25Z"}, "message": "Fix mark_all_labels vs cfglayout mode.\n\n        * jump.c (maybe_propagate_label_ref): Split out of...\n        (mark_all_labels): ... here.  Do not attempt label_ref\n        propagation while in cfglayout mode.\n\nFrom-SVN: r176663", "tree": {"sha": "5ae6b4e94160bc7e3cba433e4dd5bbb954faab3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ae6b4e94160bc7e3cba433e4dd5bbb954faab3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f93b30abd3d9f419029bce57f8a0372bdf0ec65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f93b30abd3d9f419029bce57f8a0372bdf0ec65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f93b30abd3d9f419029bce57f8a0372bdf0ec65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f93b30abd3d9f419029bce57f8a0372bdf0ec65/comments", "author": null, "committer": null, "parents": [{"sha": "a0a22423b01fa898acc938d7d89e531121c62e02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a22423b01fa898acc938d7d89e531121c62e02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a22423b01fa898acc938d7d89e531121c62e02"}], "stats": {"total": 156, "additions": 89, "deletions": 67}, "files": [{"sha": "905dc1c54edc6abd7a86193fe8001ae7d8380b72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f93b30abd3d9f419029bce57f8a0372bdf0ec65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f93b30abd3d9f419029bce57f8a0372bdf0ec65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f93b30abd3d9f419029bce57f8a0372bdf0ec65", "patch": "@@ -1,3 +1,9 @@\n+2011-07-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* jump.c (maybe_propagate_label_ref): Split out of...\n+\t(mark_all_labels): ... here.  Do not attempt label_ref\n+\tpropagation while in cfglayout mode.\n+\n 2011-07-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (struct macinfo_struct): Change code to unsigned char."}, {"sha": "0d29f0fcb18c47219eba6f07087eabc63bca84bd", "filename": "gcc/jump.c", "status": "modified", "additions": 83, "deletions": 67, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f93b30abd3d9f419029bce57f8a0372bdf0ec65/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f93b30abd3d9f419029bce57f8a0372bdf0ec65/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=5f93b30abd3d9f419029bce57f8a0372bdf0ec65", "patch": "@@ -200,92 +200,86 @@ init_label_info (rtx f)\n     }\n }\n \n+/* A subroutine of mark_all_labels.  Trivially propagate a simple label\n+   load into a jump_insn that uses it.  */\n+\n+static void\n+maybe_propagate_label_ref (rtx jump_insn, rtx prev_nonjump_insn)\n+{\n+  rtx label_note, pc, pc_src;\n+\n+  pc = pc_set (jump_insn);\n+  pc_src = pc != NULL ? SET_SRC (pc) : NULL;\n+  label_note = find_reg_note (prev_nonjump_insn, REG_LABEL_OPERAND, NULL);\n+\n+  /* If the previous non-jump insn sets something to a label,\n+     something that this jump insn uses, make that label the primary\n+     target of this insn if we don't yet have any.  That previous\n+     insn must be a single_set and not refer to more than one label.\n+     The jump insn must not refer to other labels as jump targets\n+     and must be a plain (set (pc) ...), maybe in a parallel, and\n+     may refer to the item being set only directly or as one of the\n+     arms in an IF_THEN_ELSE.  */\n+\n+  if (label_note != NULL && pc_src != NULL)\n+    {\n+      rtx label_set = single_set (prev_nonjump_insn);\n+      rtx label_dest = label_set != NULL ? SET_DEST (label_set) : NULL;\n+\n+      if (label_set != NULL\n+\t  /* The source must be the direct LABEL_REF, not a\n+\t     PLUS, UNSPEC, IF_THEN_ELSE etc.  */\n+\t  && GET_CODE (SET_SRC (label_set)) == LABEL_REF\n+\t  && (rtx_equal_p (label_dest, pc_src)\n+\t      || (GET_CODE (pc_src) == IF_THEN_ELSE\n+\t\t  && (rtx_equal_p (label_dest, XEXP (pc_src, 1))\n+\t\t      || rtx_equal_p (label_dest, XEXP (pc_src, 2))))))\n+\t{\n+\t  /* The CODE_LABEL referred to in the note must be the\n+\t     CODE_LABEL in the LABEL_REF of the \"set\".  We can\n+\t     conveniently use it for the marker function, which\n+\t     requires a LABEL_REF wrapping.  */\n+\t  gcc_assert (XEXP (label_note, 0) == XEXP (SET_SRC (label_set), 0));\n+\n+\t  mark_jump_label_1 (label_set, jump_insn, false, true);\n+\n+\t  gcc_assert (JUMP_LABEL (jump_insn) == XEXP (label_note, 0));\n+\t}\n+    }\n+}\n+\n /* Mark the label each jump jumps to.\n    Combine consecutive labels, and count uses of labels.  */\n \n static void\n mark_all_labels (rtx f)\n {\n   rtx insn;\n-  rtx prev_nonjump_insn = NULL;\n-\n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n-    if (NONDEBUG_INSN_P (insn))\n-      {\n-\tmark_jump_label (PATTERN (insn), insn, 0);\n-\n-\t/* If the previous non-jump insn sets something to a label,\n-\t   something that this jump insn uses, make that label the primary\n-\t   target of this insn if we don't yet have any.  That previous\n-\t   insn must be a single_set and not refer to more than one label.\n-\t   The jump insn must not refer to other labels as jump targets\n-\t   and must be a plain (set (pc) ...), maybe in a parallel, and\n-\t   may refer to the item being set only directly or as one of the\n-\t   arms in an IF_THEN_ELSE.  */\n-\tif (! INSN_DELETED_P (insn)\n-\t    && JUMP_P (insn)\n-\t    && JUMP_LABEL (insn) == NULL)\n-\t  {\n-\t    rtx label_note = NULL;\n-\t    rtx pc = pc_set (insn);\n-\t    rtx pc_src = pc != NULL ? SET_SRC (pc) : NULL;\n-\n-\t    if (prev_nonjump_insn != NULL)\n-\t      label_note\n-\t\t= find_reg_note (prev_nonjump_insn, REG_LABEL_OPERAND, NULL);\n-\n-\t    if (label_note != NULL && pc_src != NULL)\n-\t      {\n-\t\trtx label_set = single_set (prev_nonjump_insn);\n-\t\trtx label_dest\n-\t\t  = label_set != NULL ? SET_DEST (label_set) : NULL;\n-\n-\t\tif (label_set != NULL\n-\t\t    /* The source must be the direct LABEL_REF, not a\n-\t\t       PLUS, UNSPEC, IF_THEN_ELSE etc.  */\n-\t\t    && GET_CODE (SET_SRC (label_set)) == LABEL_REF\n-\t\t    && (rtx_equal_p (label_dest, pc_src)\n-\t\t\t|| (GET_CODE (pc_src) == IF_THEN_ELSE\n-\t\t\t    && (rtx_equal_p (label_dest, XEXP (pc_src, 1))\n-\t\t\t\t|| rtx_equal_p (label_dest,\n-\t\t\t\t\t\tXEXP (pc_src, 2))))))\n-\n-\t\t  {\n-\t\t    /* The CODE_LABEL referred to in the note must be the\n-\t\t       CODE_LABEL in the LABEL_REF of the \"set\".  We can\n-\t\t       conveniently use it for the marker function, which\n-\t\t       requires a LABEL_REF wrapping.  */\n-\t\t    gcc_assert (XEXP (label_note, 0)\n-\t\t\t\t== XEXP (SET_SRC (label_set), 0));\n-\n-\t\t    mark_jump_label_1 (label_set, insn, false, true);\n-\t\t    gcc_assert (JUMP_LABEL (insn)\n-\t\t\t\t== XEXP (SET_SRC (label_set), 0));\n-\t\t  }\n-\t      }\n-\t  }\n-\telse if (! INSN_DELETED_P (insn))\n-\t  prev_nonjump_insn = insn;\n-      }\n-    else if (LABEL_P (insn))\n-      prev_nonjump_insn = NULL;\n \n-  /* If we are in cfglayout mode, there may be non-insns between the\n-     basic blocks.  If those non-insns represent tablejump data, they\n-     contain label references that we must record.  */\n   if (current_ir_type () == IR_RTL_CFGLAYOUT)\n     {\n       basic_block bb;\n-      rtx insn;\n       FOR_EACH_BB (bb)\n \t{\n+\t  /* In cfglayout mode, we don't bother with trivial next-insn\n+\t     propagation of LABEL_REFs into JUMP_LABEL.  This will be\n+\t     handled by other optimizers using better algorithms.  */\n+\t  FOR_BB_INSNS (bb, insn)\n+\t    {\n+\t      gcc_assert (! INSN_DELETED_P (insn));\n+\t      if (NONDEBUG_INSN_P (insn))\n+\t        mark_jump_label (PATTERN (insn), insn, 0);\n+\t    }\n+\n+\t  /* In cfglayout mode, there may be non-insns between the\n+\t     basic blocks.  If those non-insns represent tablejump data,\n+\t     they contain label references that we must record.  */\n \t  for (insn = bb->il.rtl->header; insn; insn = NEXT_INSN (insn))\n \t    if (INSN_P (insn))\n \t      {\n \t\tgcc_assert (JUMP_TABLE_DATA_P (insn));\n \t\tmark_jump_label (PATTERN (insn), insn, 0);\n \t      }\n-\n \t  for (insn = bb->il.rtl->footer; insn; insn = NEXT_INSN (insn))\n \t    if (INSN_P (insn))\n \t      {\n@@ -294,6 +288,28 @@ mark_all_labels (rtx f)\n \t      }\n \t}\n     }\n+  else\n+    {\n+      rtx prev_nonjump_insn = NULL;\n+      for (insn = f; insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (INSN_DELETED_P (insn))\n+\t    ;\n+\t  else if (LABEL_P (insn))\n+\t    prev_nonjump_insn = NULL;\n+\t  else if (NONDEBUG_INSN_P (insn))\n+\t    {\n+\t      mark_jump_label (PATTERN (insn), insn, 0);\n+\t      if (JUMP_P (insn))\n+\t\t{\n+\t\t  if (JUMP_LABEL (insn) == NULL && prev_nonjump_insn != NULL)\n+\t\t    maybe_propagate_label_ref (insn, prev_nonjump_insn);\n+\t\t}\n+\t      else\n+\t\tprev_nonjump_insn = insn;\n+\t    }\n+\t}\n+    }\n }\n \f\n /* Given a comparison (CODE ARG0 ARG1), inside an insn, INSN, return a code"}]}