{"sha": "0f8e84c609c67456965b20e1274e7dca3db9ab05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY4ZTg0YzYwOWM2NzQ1Njk2NWIyMGUxMjc0ZTdkY2EzZGI5YWIwNQ==", "commit": {"author": {"name": "Vladislav Ivanishin", "email": "vlad@ispras.ru", "date": "2019-05-21T10:39:05Z"}, "committer": {"name": "Vladislav Ivanishin", "email": "vlad@gcc.gnu.org", "date": "2019-05-21T10:39:05Z"}, "message": "tree-ssa-uninit: suppress more spurious warnings\n\n\t* tree-ssa-uninit.c (value_sat_pred_p): This new function is a wrapper\n        around is_value_included_in that knows how to handle BIT_AND_EXPR.\n        (is_pred_expr_subset_of): Use the new function.  Handle more cases where\n        code1 == EQ_EXPR and where code1 == BIT_AND_EXPR and thus fix some false\n        positives.\n\ntestsuite/\n        * gcc.dg/uninit-28-gimple.c: New test.\n        * gcc.dg/uninit-29-gimple.c: New test.\n        * gcc.dg/uninit-30-gimple.c: New test.\n        * gcc.dg/uninit-31-gimple.c: New test.\n\nFrom-SVN: r271460", "tree": {"sha": "e8164610a69f92b3f89415f8d116e7cf42e4dd2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8164610a69f92b3f89415f8d116e7cf42e4dd2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f8e84c609c67456965b20e1274e7dca3db9ab05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f8e84c609c67456965b20e1274e7dca3db9ab05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f8e84c609c67456965b20e1274e7dca3db9ab05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f8e84c609c67456965b20e1274e7dca3db9ab05/comments", "author": {"login": "ivladak", "id": 3601329, "node_id": "MDQ6VXNlcjM2MDEzMjk=", "avatar_url": "https://avatars.githubusercontent.com/u/3601329?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ivladak", "html_url": "https://github.com/ivladak", "followers_url": "https://api.github.com/users/ivladak/followers", "following_url": "https://api.github.com/users/ivladak/following{/other_user}", "gists_url": "https://api.github.com/users/ivladak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ivladak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ivladak/subscriptions", "organizations_url": "https://api.github.com/users/ivladak/orgs", "repos_url": "https://api.github.com/users/ivladak/repos", "events_url": "https://api.github.com/users/ivladak/events{/privacy}", "received_events_url": "https://api.github.com/users/ivladak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "36902ed6bdeafc86e1f9b1778a1138b21580cc93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36902ed6bdeafc86e1f9b1778a1138b21580cc93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36902ed6bdeafc86e1f9b1778a1138b21580cc93"}], "stats": {"total": 235, "additions": 225, "deletions": 10}, "files": [{"sha": "d341a64440c624ba0d4027c61d39d568cd48ab31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f8e84c609c67456965b20e1274e7dca3db9ab05", "patch": "@@ -1,3 +1,11 @@\n+2019-05-21  Vladislav Ivanishin  <vlad@ispras.ru>\n+\n+\t* tree-ssa-uninit.c (value_sat_pred_p): This new function is a wrapper\n+\taround is_value_included_in that knows how to handle BIT_AND_EXPR.\n+\t(is_pred_expr_subset_of): Use the new function.  Handle more cases where\n+\tcode1 == EQ_EXPR and where code1 == BIT_AND_EXPR and thus fix some false\n+\tpositives.\n+\n 2019-05-21  Martin Liska  <mliska@suse.cz>\n \n \t* config/rs6000/driver-rs6000.c (elf_platform): Do not use"}, {"sha": "f2bff8a0b429dc3c2f0caf074381a6bc9b5bff79", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0f8e84c609c67456965b20e1274e7dca3db9ab05", "patch": "@@ -1,3 +1,10 @@\n+2019-05-21  Vladislav Ivanishin  <vlad@ispras.ru>\n+\n+\t* gcc.dg/uninit-28-gimple.c: New test.\n+\t* gcc.dg/uninit-29-gimple.c: New test.\n+\t* gcc.dg/uninit-30-gimple.c: New test.\n+\t* gcc.dg/uninit-31-gimple.c: New test.\n+\n 2019-05-21  Martin Liska  <mliska@suse.cz>\n \n \t* gcc.dg/pr90263.c: Add -O2."}, {"sha": "0648b8a4aa785ba97435a2dbece03f825a4a9393", "filename": "gcc/testsuite/gcc.dg/uninit-28-gimple.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-28-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-28-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-28-gimple.c?ref=0f8e84c609c67456965b20e1274e7dca3db9ab05", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple -O -Wmaybe-uninitialized\" } */\n+\n+unsigned int __GIMPLE (ssa,startwith(\"uninit1\"))\n+foo (unsigned int v)\n+{\n+  /* Uninit warning here would be bogus, because (16 & 3) == 0 and therefore\n+     if v == 16, the uninit value is not used (the use is properly guarded).  */\n+  unsigned int undef;        /* { dg-bogus \"may be used uninitialized\" } */\n+  unsigned int _2;\n+  unsigned int _9;\n+  unsigned int _10;\n+  unsigned pred;\n+\n+  __BB(2):\n+  if (v_4(D) != 16u)\n+    goto __BB3;\n+  else\n+    goto __BB4;\n+\n+  /* 'undef' is defined conditionally (under 'v != 16' predicate)  */\n+  __BB(3):\n+  undef_8 = 8u;\n+  goto __BB4;\n+\n+  /* An undef value flows into a phi.  */\n+  __BB(4):\n+  undef_1 = __PHI (__BB2: undef_5(D), __BB3: undef_8);\n+  pred = v_4(D) & 3u;\n+  if (pred != 0u)\n+    goto __BB5;\n+  else\n+    goto __BB6;\n+\n+  /* The phi value is used here (under 'v & 3' predicate).  */\n+  __BB(5):\n+  _9 = undef_1;\n+  goto __BB7;\n+\n+  __BB(6):\n+  _10 = v_4(D);\n+  goto __BB7;\n+\n+  __BB(7):\n+  _2 = __PHI (__BB5: _9, __BB6: _10);\n+  return _2;\n+}"}, {"sha": "cb5bc97164eb4c53c0092e7e369774d28c96327f", "filename": "gcc/testsuite/gcc.dg/uninit-29-gimple.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-29-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-29-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-29-gimple.c?ref=0f8e84c609c67456965b20e1274e7dca3db9ab05", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple -O -Wmaybe-uninitialized\" } */\n+\n+unsigned int __GIMPLE (ssa,startwith(\"uninit1\"))\n+foo (unsigned int v)\n+{\n+  unsigned int undef;        /* { dg-warning \"may be used uninitialized\" } */\n+  unsigned int _2;\n+  unsigned int _9;\n+  unsigned int _10;\n+  unsigned pred;\n+\n+  __BB(2):\n+  pred = v_4(D) & 3u;\n+  if (pred != 0u)\n+    goto __BB3;\n+  else\n+    goto __BB4;\n+\n+  /* 'undef' is defined conditionally (under 'v & 3' predicate)  */\n+  __BB(3):\n+  undef_8 = 8u;\n+  goto __BB4;\n+\n+  /* An undef value flows into a phi.  */\n+  __BB(4):\n+  undef_1 = __PHI (__BB2: undef_5(D), __BB3: undef_8);\n+  if (v_4(D) != 16u)\n+    goto __BB5;\n+  else\n+    goto __BB6;\n+\n+  /* The phi value is used here (under 'v != 16' predicate).  */\n+  __BB(5):\n+  _9 = undef_1;\n+  goto __BB7;\n+\n+  __BB(6):\n+  _10 = v_4(D);\n+  goto __BB7;\n+\n+  __BB(7):\n+  _2 = __PHI (__BB5: _9, __BB6: _10);\n+  return _2;\n+}"}, {"sha": "8c91f79d509586eb81b008192a67e6a546252285", "filename": "gcc/testsuite/gcc.dg/uninit-30-gimple.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-30-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-30-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-30-gimple.c?ref=0f8e84c609c67456965b20e1274e7dca3db9ab05", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple -O -Wmaybe-uninitialized\" } */\n+\n+unsigned int __GIMPLE (ssa,startwith(\"uninit1\"))\n+foo (unsigned int v)\n+{\n+  unsigned int undef;        /* { dg-bogus \"may be used uninitialized\" } */\n+  unsigned int _2;\n+  unsigned int _9;\n+  unsigned int _10;\n+\n+  __BB(2):\n+  if (v_4(D) < 100u)\n+    goto __BB3;\n+  else\n+    goto __BB4;\n+\n+  /* 'undef' is defined conditionally (under 'v < 100' predicate).  */\n+  __BB(3):\n+  undef_8 = 8u;\n+  goto __BB4;\n+\n+  /* An undef value flows into a phi.  */\n+  __BB(4):\n+  undef_1 = __PHI (__BB2: undef_5(D), __BB3: undef_8);\n+  if (v_4(D) == 42u)\n+    goto __BB5;\n+  else\n+    goto __BB6;\n+\n+  /* The phi value is used here (under 'v == 42' predicate).  */\n+  __BB(5):\n+  _9 = undef_1;\n+  goto __BB7;\n+\n+  __BB(6):\n+  _10 = v_4(D);\n+  goto __BB7;\n+\n+  __BB(7):\n+  _2 = __PHI (__BB5: _9, __BB6: _10);\n+  return _2;\n+}"}, {"sha": "01118ef98239a1f31708896da24d1ea8c4a81a4d", "filename": "gcc/testsuite/gcc.dg/uninit-31-gimple.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-31-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-31-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-31-gimple.c?ref=0f8e84c609c67456965b20e1274e7dca3db9ab05", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple -O -Wmaybe-uninitialized\" } */\n+\n+unsigned int __GIMPLE (ssa,startwith(\"uninit1\"))\n+foo (unsigned int v)\n+{\n+  /* If v == 2, then undef is used w/o being initialized.  */\n+  unsigned int undef;        /* { dg-warning \"may be used uninitialized\" } */\n+  unsigned int _2;\n+  unsigned int _9;\n+  unsigned int _10;\n+  unsigned int pred2;\n+  unsigned int pred1;\n+\n+  __BB(2):\n+  pred2 = v_4(D) & 5u;\n+  if (pred2 != 0u)\n+    goto __BB3;\n+  else\n+    goto __BB4;\n+\n+  /* 'undef' is defined conditionally (under 'v & 5' predicate).  */\n+  __BB(3):\n+  undef_8 = 8u;\n+  goto __BB4;\n+\n+  /* An undef value flows into a phi.  */\n+  __BB(4):\n+  undef_1 = __PHI (__BB2: undef_5(D), __BB3: undef_8);\n+  pred1 = v_4(D) & 3u;\n+  if (pred1 != 0u)\n+    goto __BB5;\n+  else\n+    goto __BB6;\n+\n+  /* The phi value is used here (under 'v & 3' predicate).  */\n+  __BB(5):\n+  _9 = undef_1;\n+  goto __BB7;\n+\n+  __BB(6):\n+  _10 = v_4(D);\n+  goto __BB7;\n+\n+  __BB(7):\n+  _2 = __PHI (__BB5: _9, __BB6: _10);\n+  return _2;\n+}"}, {"sha": "bc07afe32c85e7c5a33625ce1f89a71231e1ba16", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f8e84c609c67456965b20e1274e7dca3db9ab05/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=0f8e84c609c67456965b20e1274e7dca3db9ab05", "patch": "@@ -1045,6 +1045,26 @@ is_value_included_in (tree val, tree boundary, enum tree_code cmpc)\n   return result;\n }\n \n+/* Returns whether VAL satisfies (x CMPC BOUNDARY) predicate.  CMPC can be\n+   either one of the range comparison codes ({GE,LT,EQ,NE}_EXPR and the like),\n+   or BIT_AND_EXPR.  EXACT_P is only meaningful for the latter.  It modifies the\n+   question from whether VAL & BOUNDARY != 0 to whether VAL & BOUNDARY == VAL.\n+   For other values of CMPC, EXACT_P is ignored.  */\n+\n+static bool\n+value_sat_pred_p (tree val, tree boundary, enum tree_code cmpc,\n+\t\t  bool exact_p = false)\n+{\n+  if (cmpc != BIT_AND_EXPR)\n+    return is_value_included_in (val, boundary, cmpc);\n+\n+  wi::tree_to_wide_ref andw = wi::to_wide (val) & wi::to_wide (boundary);\n+  if (exact_p)\n+    return andw == wi::to_wide (val);\n+  else\n+    return andw.to_uhwi ();\n+}\n+\n /* Returns true if PRED is common among all the predicate\n    chains (PREDS) (and therefore can be factored out).\n    NUM_PRED_CHAIN is the size of array PREDS.  */\n@@ -1471,18 +1491,15 @@ is_pred_expr_subset_of (pred_info expr1, pred_info expr2)\n   if (code2 == NE_EXPR && code1 == NE_EXPR)\n     return false;\n \n-  if (code2 == NE_EXPR && code1 != BIT_AND_EXPR)\n-    return !is_value_included_in (expr2.pred_rhs, expr1.pred_rhs, code1);\n+  if (code2 == NE_EXPR)\n+    return !value_sat_pred_p (expr2.pred_rhs, expr1.pred_rhs, code1);\n \n-  if ((code1 == EQ_EXPR || code1 == BIT_AND_EXPR) && code2 == BIT_AND_EXPR)\n-    return (wi::to_wide (expr1.pred_rhs)\n-\t    == (wi::to_wide (expr1.pred_rhs) & wi::to_wide (expr2.pred_rhs)));\n+  if (code1 == EQ_EXPR)\n+    return value_sat_pred_p (expr1.pred_rhs, expr2.pred_rhs, code2);\n \n-  if (code1 != code2)\n-    return false;\n-\n-  if (is_value_included_in (expr1.pred_rhs, expr2.pred_rhs, code2))\n-    return true;\n+  if (code1 == code2)\n+    return value_sat_pred_p (expr1.pred_rhs, expr2.pred_rhs, code2,\n+\t\t\t     code1 == BIT_AND_EXPR);\n \n   return false;\n }"}]}