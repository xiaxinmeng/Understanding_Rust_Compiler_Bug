{"sha": "b3b9865d065da548c5a3746638515229784f059b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNiOTg2NWQwNjVkYTU0OGM1YTM3NDY2Mzg1MTUyMjk3ODRmMDU5Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-10T11:07:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-10T11:07:42Z"}, "message": "[multiple changes]\n\n2009-04-10  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.adb: Minor reformatting\n\n\t* exp_util.adb (Make_Non_Empty_Check): New function\n\t(Silly_Boolean_Array_Not_Test): Add call to Make_Non_Empty_Check\n\t(Silly_Boolean_Array_Xor_Test): Use Make_Non_Empty_Check\n\n2009-04-10  Arnaud Charlet  <charlet@adacore.com>\n\n\t* make.adb, gnatlink.adb: Rename JGNAT toolchain.\n\n2009-04-10  Jose Ruiz  <ruiz@adacore.com>\n\n\t* mlib-tgt-specific-xi.adb (Get_Target_Prefix): Insert the appropriate\n\ttool prefix for AVR and PowerPC 55xx targets.\n\n2009-04-10  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_warn.adb (Within_Postcondition): New function\n\t(Check_Unset_Reference): Use Within_Postcondition to stop bad warning\n\nFrom-SVN: r145889", "tree": {"sha": "d956a22e239b264b70a3858e4f6475cea0fdbfc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d956a22e239b264b70a3858e4f6475cea0fdbfc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3b9865d065da548c5a3746638515229784f059b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b9865d065da548c5a3746638515229784f059b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3b9865d065da548c5a3746638515229784f059b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b9865d065da548c5a3746638515229784f059b/comments", "author": null, "committer": null, "parents": [{"sha": "2436ca9ee8f3bab11e16594f590f4aefc82ea95e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2436ca9ee8f3bab11e16594f590f4aefc82ea95e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2436ca9ee8f3bab11e16594f590f4aefc82ea95e"}], "stats": {"total": 879, "additions": 487, "deletions": 392}, "files": [{"sha": "526267c95f26f7cb5401a2b2119100f050a3f7cc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b3b9865d065da548c5a3746638515229784f059b", "patch": "@@ -1,3 +1,29 @@\n+2009-04-10  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* init.c: Install signal handler on Darwin.\n+\n+2009-04-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.adb: Minor reformatting\n+\n+\t* exp_util.adb (Make_Non_Empty_Check): New function\n+\t(Silly_Boolean_Array_Not_Test): Add call to Make_Non_Empty_Check\n+\t(Silly_Boolean_Array_Xor_Test): Use Make_Non_Empty_Check\n+\n+2009-04-10  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* make.adb, gnatlink.adb: Rename JGNAT toolchain.\n+\n+2009-04-10  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* mlib-tgt-specific-xi.adb (Get_Target_Prefix): Insert the appropriate\n+\ttool prefix for AVR and PowerPC 55xx targets.\n+\n+2009-04-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_warn.adb (Within_Postcondition): New function\n+\t(Check_Unset_Reference): Use Within_Postcondition to stop bad warning\n+\n 2009-04-10  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_warn.adb: Minor reformatting"}, {"sha": "8205735d5a53e9483a415939313dcdae650778bf", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=b3b9865d065da548c5a3746638515229784f059b", "patch": "@@ -135,6 +135,12 @@ package body Exp_Util is\n    --          (Literal_Type'Pos (Low_Bound (Literal_Type))\n    --             + (Length (Literal_Typ) -1))\n \n+   function Make_Non_Empty_Check\n+     (Loc : Source_Ptr;\n+      N   : Node_Id) return Node_Id;\n+   --  Produce a boolean expression checking that the unidimensional array\n+   --  node N is not empty.\n+\n    function New_Class_Wide_Subtype\n      (CW_Typ : Entity_Id;\n       N      : Node_Id) return Entity_Id;\n@@ -3742,6 +3748,25 @@ package body Exp_Util is\n              High_Bound => Hi);\n    end Make_Literal_Range;\n \n+   --------------------------\n+   -- Make_Non_Empty_Check --\n+   --------------------------\n+\n+   function Make_Non_Empty_Check\n+     (Loc : Source_Ptr;\n+      N   : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+        Make_Op_Ne (Loc,\n+          Left_Opnd =>\n+            Make_Attribute_Reference (Loc,\n+              Attribute_Name => Name_Length,\n+              Prefix => Duplicate_Subexpr_No_Checks (N, Name_Req => True)),\n+          Right_Opnd =>\n+            Make_Integer_Literal (Loc, 0));\n+   end Make_Non_Empty_Check;\n+\n    ----------------------------\n    -- Make_Subtype_From_Expr --\n    ----------------------------\n@@ -5116,6 +5141,10 @@ package body Exp_Util is\n    --  that constraint error is raised. The reason is that the NOT is bound\n    --  to cause CE in this case, and we will not otherwise catch it.\n \n+   --  No such check is required for AND and OR, since for both these cases\n+   --  False op False = False, and True op True = True. For the XOR case,\n+   --  see Silly_Boolean_Array_Xor_Test.\n+\n    --  Believe it or not, this was reported as a bug. Note that nearly\n    --  always, the test will evaluate statically to False, so the code will\n    --  be statically removed, and no extra overhead caused.\n@@ -5125,19 +5154,34 @@ package body Exp_Util is\n       CT  : constant Entity_Id  := Component_Type (T);\n \n    begin\n+      --  The check we install is\n+\n+      --    constraint_error when\n+      --      component_type'first = component_type'last\n+      --        and then array_type'Length /= 0)\n+\n+      --  We need the last guard because we don't want to raise CE for empty\n+      --  arrays since no out of range values result. (Empty arrays with a\n+      --  component type of True .. True -- very useful -- even the ACATS\n+      --  does not test that marginal case!)\n+\n       Insert_Action (N,\n         Make_Raise_Constraint_Error (Loc,\n           Condition =>\n-            Make_Op_Eq (Loc,\n+            Make_And_Then (Loc,\n               Left_Opnd =>\n-                Make_Attribute_Reference (Loc,\n-                  Prefix         => New_Occurrence_Of (CT, Loc),\n-                  Attribute_Name => Name_First),\n-\n-              Right_Opnd =>\n-                Make_Attribute_Reference (Loc,\n-                  Prefix         => New_Occurrence_Of (CT, Loc),\n-                  Attribute_Name => Name_Last)),\n+                Make_Op_Eq (Loc,\n+                  Left_Opnd =>\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => New_Occurrence_Of (CT, Loc),\n+                      Attribute_Name => Name_First),\n+\n+                  Right_Opnd =>\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => New_Occurrence_Of (CT, Loc),\n+                      Attribute_Name => Name_Last)),\n+\n+              Right_Opnd => Make_Non_Empty_Check (Loc, Right_Opnd (N))),\n           Reason => CE_Range_Check_Failed));\n    end Silly_Boolean_Array_Not_Test;\n \n@@ -5151,7 +5195,9 @@ package body Exp_Util is\n    --  will not be generated otherwise (cf Expand_Packed_Not).\n \n    --  No such check is required for AND and OR, since for both these cases\n-   --  False op False = False, and True op True = True.\n+   --  False op False = False, and True op True = True, and no check is\n+   --  required for the case of False .. False, since False xor False = False.\n+   --  See also Silly_Boolean_Array_Not_Test\n \n    procedure Silly_Boolean_Array_Xor_Test (N : Node_Id; T : Entity_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n@@ -5188,14 +5234,7 @@ package body Exp_Util is\n                         Prefix         => New_Occurrence_Of (CT, Loc),\n                         Attribute_Name => Name_Last))),\n \n-              Right_Opnd =>\n-                Make_Op_Ne (Loc,\n-                  Left_Opnd =>\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix => New_Reference_To (T, Loc),\n-                      Attribute_Name => Name_Length),\n-                  Right_Opnd => Make_Integer_Literal (Loc, 0))),\n-\n+              Right_Opnd => Make_Non_Empty_Check (Loc, Right_Opnd (N))),\n           Reason => CE_Range_Check_Failed));\n    end Silly_Boolean_Array_Xor_Test;\n "}, {"sha": "72d9068d15b02d72cc171df6acde8d853c61a37d", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=b3b9865d065da548c5a3746638515229784f059b", "patch": "@@ -1619,7 +1619,7 @@ begin\n \n    if VM_Target /= No_VM then\n       case VM_Target is\n-         when JVM_Target => Gcc := new String'(\"jgnat\");\n+         when JVM_Target => Gcc := new String'(\"jvm-gnatcompile\");\n          when CLI_Target => Gcc := new String'(\"dotnet-gnatcompile\");\n          when No_VM      => raise Program_Error;\n       end case;"}, {"sha": "a8995d9c71611a815b388c51921cc65efefdc8fe", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=b3b9865d065da548c5a3746638515229784f059b", "patch": "@@ -5396,10 +5396,7 @@ package body Make is\n                --  JVM machine since \".class\" files are generated instead.\n \n                Check_Object_Consistency := False;\n-\n-               Gcc := new String'(\"jgnat\");\n-               Gnatbind := new String'(\"jgnatbind\");\n-               Gnatlink := new String'(\"jgnatlink\");\n+               Gcc := new String'(\"jvm-gnatcompile\");\n \n             when Targparm.CLI_Target =>\n                Gcc := new String'(\"dotnet-gnatcompile\");"}, {"sha": "3a56d83712524899b36ed685be4dd230b42ddfe1", "filename": "gcc/ada/mlib-tgt-specific-xi.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2Fmlib-tgt-specific-xi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2Fmlib-tgt-specific-xi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-xi.adb?ref=b3b9865d065da548c5a3746638515229784f059b", "patch": "@@ -148,12 +148,20 @@ package body MLib.Tgt.Specific is\n          Index := Index + 1;\n       end loop;\n \n-      if Target_Name (Target_Name'First .. Index) = \"erc32\" then\n+      if Target_Name (Target_Name'First .. Index) = \"avr\" then\n+         return \"avr-\";\n+      elsif Target_Name (Target_Name'First .. Index) = \"erc32\" then\n          return \"erc32-elf-\";\n       elsif Target_Name (Target_Name'First .. Index) = \"leon\" then\n          return \"leon-elf-\";\n       elsif Target_Name (Target_Name'First .. Index) = \"powerpc\" then\n-         return \"powerpc-elf-\";\n+         if Target_Name'Last - 6 >= Target_Name'First and then\n+           Target_Name (Target_Name'Last - 6 .. Target_Name'Last) = \"eabispe\"\n+         then\n+            return \"powerpc-eabispe-\";\n+         else\n+            return \"powerpc-elf-\";\n+         end if;\n       else\n          return \"\";\n       end if;"}, {"sha": "6f4e07fe87a725498dbb3a368433c310d1562331", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 342, "deletions": 351, "changes": 693, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b3b9865d065da548c5a3746638515229784f059b", "patch": "@@ -110,13 +110,13 @@ package body Sem_Prag is\n    --  exported, and must refer to an entity in the current declarative\n    --  part (as required by the rules for LOCAL_NAME).\n \n-   --  The external linker name is designated by the External parameter\n-   --  if given, or the Internal parameter if not (if there is no External\n+   --  The external linker name is designated by the External parameter if\n+   --  given, or the Internal parameter if not (if there is no External\n    --  parameter, the External parameter is a copy of the Internal name).\n \n-   --  If the External parameter is given as a string, then this string\n-   --  is treated as an external name (exactly as though it had been given\n-   --  as an External_Name parameter for a normal Import pragma).\n+   --  If the External parameter is given as a string, then this string is\n+   --  treated as an external name (exactly as though it had been given as an\n+   --  External_Name parameter for a normal Import pragma).\n \n    --  If the External parameter is given as an identifier (or there is no\n    --  External parameter, so that the Internal identifier is used), then\n@@ -128,15 +128,15 @@ package body Sem_Prag is\n    --  Import_xxx or Export_xxx pragmas override an external or link name\n    --  specified in a previous Import or Export pragma.\n \n-   --  Note: these and all other DEC-compatible GNAT pragmas allow full\n-   --  use of named notation, following the standard rules for subprogram\n-   --  calls, i.e. parameters can be given in any order if named notation\n-   --  is used, and positional and named notation can be mixed, subject to\n-   --  the rule that all positional parameters must appear first.\n+   --  Note: these and all other DEC-compatible GNAT pragmas allow full use of\n+   --  named notation, following the standard rules for subprogram calls, i.e.\n+   --  parameters can be given in any order if named notation is used, and\n+   --  positional and named notation can be mixed, subject to the rule that all\n+   --  positional parameters must appear first.\n \n-   --  Note: All these pragmas are implemented exactly following the DEC\n-   --  design and implementation and are intended to be fully compatible\n-   --  with the use of these pragmas in the DEC Ada compiler.\n+   --  Note: All these pragmas are implemented exactly following the DEC design\n+   --  and implementation and are intended to be fully compatible with the use\n+   --  of these pragmas in the DEC Ada compiler.\n \n    --------------------------------------------\n    -- Checking for Duplicated External Names --\n@@ -146,9 +146,9 @@ package body Sem_Prag is\n    --  name. The following table is used to diagnose this situation so that\n    --  an appropriate warning can be issued.\n \n-   --  The Node_Id stored is for the N_String_Literal node created to\n-   --  hold the value of the external name. The Sloc of this node is\n-   --  used to cross-reference the location of the duplication.\n+   --  The Node_Id stored is for the N_String_Literal node created to hold\n+   --  the value of the external name. The Sloc of this node is used to\n+   --  cross-reference the location of the duplication.\n \n    package Externals is new Table.Table (\n      Table_Component_Type => Node_Id,\n@@ -164,16 +164,16 @@ package body Sem_Prag is\n \n    function Adjust_External_Name_Case (N : Node_Id) return Node_Id;\n    --  This routine is used for possible casing adjustment of an explicit\n-   --  external name supplied as a string literal (the node N), according\n-   --  to the casing requirement of Opt.External_Name_Casing. If this is\n-   --  set to As_Is, then the string literal is returned unchanged, but if\n-   --  it is set to Uppercase or Lowercase, then a new string literal with\n-   --  appropriate casing is constructed.\n+   --  external name supplied as a string literal (the node N), according to\n+   --  the casing requirement of Opt.External_Name_Casing. If this is set to\n+   --  As_Is, then the string literal is returned unchanged, but if it is set\n+   --  to Uppercase or Lowercase, then a new string literal with appropriate\n+   --  casing is constructed.\n \n    function Get_Base_Subprogram (Def_Id : Entity_Id) return Entity_Id;\n-   --  If Def_Id refers to a renamed subprogram, then the base subprogram\n-   --  (the original one, following the renaming chain) is returned.\n-   --  Otherwise the entity is returned unchanged. Should be in Einfo???\n+   --  If Def_Id refers to a renamed subprogram, then the base subprogram (the\n+   --  original one, following the renaming chain) is returned. Otherwise the\n+   --  entity is returned unchanged. Should be in Einfo???\n \n    function Get_Pragma_Arg (Arg : Node_Id) return Node_Id;\n    --  All the routines that check pragma arguments take either a pragma\n@@ -190,9 +190,9 @@ package body Sem_Prag is\n    --  the source, allowing convenient stepping to the point of interest.\n \n    procedure Set_Unit_Name (N : Node_Id; With_Item : Node_Id);\n-   --  Place semantic information on the argument of an Elaborate or\n-   --  Elaborate_All pragma. Entity name for unit and its parents is\n-   --  taken from item in previous with_clause that mentions the unit.\n+   --  Place semantic information on the argument of an Elaborate/Elaborate_All\n+   --  pragma. Entity name for unit and its parents is taken from item in\n+   --  previous with_clause that mentions the unit.\n \n    -------------------------------\n    -- Adjust_External_Name_Case --\n@@ -250,14 +250,14 @@ package body Sem_Prag is\n       Arg2 : constant Node_Id := Next (Arg1);\n \n    begin\n-      --  Install formals and push subprogram spec onto scope stack\n-      --  so that we can see the formals from the pragma.\n+      --  Install formals and push subprogram spec onto scope stack so that we\n+      --  can see the formals from the pragma.\n \n       Install_Formals (S);\n       Push_Scope (S);\n \n-      --  Preanalyze the boolean expression, we treat this as a\n-      --  spec expression (i.e. similar to a default expression).\n+      --  Preanalyze the boolean expression, we treat this as a spec expression\n+      --  (i.e. similar to a default expression).\n \n       Preanalyze_Spec_Expression\n         (Get_Pragma_Arg (Arg1), Standard_Boolean);\n@@ -269,8 +269,8 @@ package body Sem_Prag is\n            (Get_Pragma_Arg (Arg2), Standard_String);\n       end if;\n \n-      --  Remove the subprogram from the scope stack now that the\n-      --  pre-analysis of the precondition/postcondition is done.\n+      --  Remove the subprogram from the scope stack now that the pre-analysis\n+      --  of the precondition/postcondition is done.\n \n       End_Scope;\n    end Analyze_PPC_In_Decl_Part;\n@@ -285,10 +285,10 @@ package body Sem_Prag is\n       Prag_Id : Pragma_Id;\n \n       Pragma_Exit : exception;\n-      --  This exception is used to exit pragma processing completely. It\n-      --  is used when an error is detected, and no further processing is\n-      --  required. It is also used if an earlier error has left the tree\n-      --  in a state where the pragma should not be processed.\n+      --  This exception is used to exit pragma processing completely. It is\n+      --  used when an error is detected, and no further processing is\n+      --  required. It is also used if an earlier error has left the tree in\n+      --  a state where the pragma should not be processed.\n \n       Arg_Count : Nat;\n       --  Number of pragma argument associations\n@@ -297,8 +297,8 @@ package body Sem_Prag is\n       Arg2 : Node_Id;\n       Arg3 : Node_Id;\n       Arg4 : Node_Id;\n-      --  First four pragma arguments (pragma argument association nodes,\n-      --  or Empty if the corresponding argument does not exist).\n+      --  First four pragma arguments (pragma argument association nodes, or\n+      --  Empty if the corresponding argument does not exist).\n \n       type Name_List is array (Natural range <>) of Name_Id;\n       type Args_List is array (Natural range <>) of Node_Id;\n@@ -316,40 +316,40 @@ package body Sem_Prag is\n       --  of 95 pragma.\n \n       procedure Check_Arg_Count (Required : Nat);\n-      --  Check argument count for pragma is equal to given parameter.\n-      --  If not, then issue an error message and raise Pragma_Exit.\n+      --  Check argument count for pragma is equal to given parameter. If not,\n+      --  then issue an error message and raise Pragma_Exit.\n \n-      --  Note: all routines whose name is Check_Arg_Is_xxx take an\n-      --  argument Arg which can either be a pragma argument association,\n-      --  in which case the check is applied to the expression of the\n-      --  association or an expression directly.\n+      --  Note: all routines whose name is Check_Arg_Is_xxx take an argument\n+      --  Arg which can either be a pragma argument association, in which case\n+      --  the check is applied to the expression of the association or an\n+      --  expression directly.\n \n       procedure Check_Arg_Is_External_Name (Arg : Node_Id);\n       --  Check that an argument has the right form for an EXTERNAL_NAME\n-      --  parameter of an extended import/export pragma. The rule is that\n-      --  the name must be an identifier or string literal (in Ada 83 mode)\n-      --  or a static string expression (in Ada 95 mode).\n+      --  parameter of an extended import/export pragma. The rule is that the\n+      --  name must be an identifier or string literal (in Ada 83 mode) or a\n+      --  static string expression (in Ada 95 mode).\n \n       procedure Check_Arg_Is_Identifier (Arg : Node_Id);\n       --  Check the specified argument Arg to make sure that it is an\n       --  identifier. If not give error and raise Pragma_Exit.\n \n       procedure Check_Arg_Is_Integer_Literal (Arg : Node_Id);\n-      --  Check the specified argument Arg to make sure that it is an\n-      --  integer literal. If not give error and raise Pragma_Exit.\n+      --  Check the specified argument Arg to make sure that it is an integer\n+      --  literal. If not give error and raise Pragma_Exit.\n \n       procedure Check_Arg_Is_Library_Level_Local_Name (Arg : Node_Id);\n-      --  Check the specified argument Arg to make sure that it has the\n-      --  proper syntactic form for a local name and meets the semantic\n-      --  requirements for a local name. The local name is analyzed as\n-      --  part of the processing for this call. In addition, the local\n-      --  name is required to represent an entity at the library level.\n+      --  Check the specified argument Arg to make sure that it has the proper\n+      --  syntactic form for a local name and meets the semantic requirements\n+      --  for a local name. The local name is analyzed as part of the\n+      --  processing for this call. In addition, the local name is required\n+      --  to represent an entity at the library level.\n \n       procedure Check_Arg_Is_Local_Name (Arg : Node_Id);\n-      --  Check the specified argument Arg to make sure that it has the\n-      --  proper syntactic form for a local name and meets the semantic\n-      --  requirements for a local name. The local name is analyzed as\n-      --  part of the processing for this call.\n+      --  Check the specified argument Arg to make sure that it has the proper\n+      --  syntactic form for a local name and meets the semantic requirements\n+      --  for a local name. The local name is analyzed as part of the\n+      --  processing for this call.\n \n       procedure Check_Arg_Is_Locking_Policy (Arg : Node_Id);\n       --  Check the specified argument Arg to make sure that it is a valid\n@@ -375,13 +375,12 @@ package body Sem_Prag is\n       --  Any_Integer is OK). If not, given error and raise Pragma_Exit.\n \n       procedure Check_Arg_Is_String_Literal (Arg : Node_Id);\n-      --  Check the specified argument Arg to make sure that it is a\n-      --  string literal. If not give error and raise Pragma_Exit\n+      --  Check the specified argument Arg to make sure that it is a string\n+      --  literal. If not give error and raise Pragma_Exit\n \n       procedure Check_Arg_Is_Task_Dispatching_Policy (Arg : Node_Id);\n-      --  Check the specified argument Arg to make sure that it is a valid\n-      --  valid task dispatching policy name. If not give error and raise\n-      --  Pragma_Exit.\n+      --  Check the specified argument Arg to make sure that it is a valid task\n+      --  dispatching policy name. If not give error and raise Pragma_Exit.\n \n       procedure Check_Arg_Order (Names : Name_List);\n       --  Checks for an instance of two arguments with identifiers for the\n@@ -399,22 +398,22 @@ package body Sem_Prag is\n       --  constrained subtypes, and for restrictions on finalizable components.\n \n       procedure Check_Duplicated_Export_Name (Nam : Node_Id);\n-      --  Nam is an N_String_Literal node containing the external name set\n-      --  by an Import or Export pragma (or extended Import or Export pragma).\n-      --  This procedure checks for possible duplications if this is the\n-      --  export case, and if found, issues an appropriate error message.\n+      --  Nam is an N_String_Literal node containing the external name set by\n+      --  an Import or Export pragma (or extended Import or Export pragma).\n+      --  This procedure checks for possible duplications if this is the export\n+      --  case, and if found, issues an appropriate error message.\n \n       procedure Check_First_Subtype (Arg : Node_Id);\n-      --  Checks that Arg, whose expression is an entity name referencing\n-      --  a subtype, does not reference a type that is not a first subtype.\n+      --  Checks that Arg, whose expression is an entity name referencing a\n+      --  subtype, does not reference a type that is not a first subtype.\n \n       procedure Check_In_Main_Program;\n       --  Common checks for pragmas that appear within a main program\n       --  (Priority, Main_Storage, Time_Slice, Relative_Deadline).\n \n       procedure Check_Interrupt_Or_Attach_Handler;\n-      --  Common processing for first argument of pragma Interrupt_Handler\n-      --  or pragma Attach_Handler.\n+      --  Common processing for first argument of pragma Interrupt_Handler or\n+      --  pragma Attach_Handler.\n \n       procedure Check_Is_In_Decl_Part_Or_Package_Spec;\n       --  Check that pragma appears in a declarative part, or in a package\n@@ -606,19 +605,19 @@ package body Sem_Prag is\n          Arg_External : Node_Id;\n          Arg_Form     : Node_Id;\n          Arg_Code     : Node_Id);\n-      --  Common processing for the pragmas Import/Export_Exception.\n-      --  The three arguments correspond to the three named parameters of\n-      --  the pragma. An argument is empty if the corresponding parameter\n-      --  is not present in the pragma.\n+      --  Common processing for the pragmas Import/Export_Exception. The three\n+      --  arguments correspond to the three named parameters of the pragma. An\n+      --  argument is empty if the corresponding parameter is not present in\n+      --  the pragma.\n \n       procedure Process_Extended_Import_Export_Object_Pragma\n         (Arg_Internal : Node_Id;\n          Arg_External : Node_Id;\n          Arg_Size     : Node_Id);\n-      --  Common processing for the pragmas Import/Export_Object.\n-      --  The three arguments correspond to the three named parameters\n-      --  of the pragmas. An argument is empty if the corresponding\n-      --  parameter is not present in the pragma.\n+      --  Common processing for the pragmas Import/Export_Object. The three\n+      --  arguments correspond to the three named parameters of the pragmas. An\n+      --  argument is empty if the corresponding parameter is not present in\n+      --  the pragma.\n \n       procedure Process_Extended_Import_Export_Internal_Arg\n         (Arg_Internal : Node_Id := Empty);\n@@ -636,12 +635,11 @@ package body Sem_Prag is\n          Arg_Mechanism                : Node_Id;\n          Arg_Result_Mechanism         : Node_Id := Empty;\n          Arg_First_Optional_Parameter : Node_Id := Empty);\n-      --  Common processing for all extended Import and Export pragmas\n-      --  applying to subprograms. The caller omits any arguments that do\n-      --  not apply to the pragma in question (for example, Arg_Result_Type\n-      --  can be non-Empty only in the Import_Function and Export_Function\n-      --  cases). The argument names correspond to the allowed pragma\n-      --  association identifiers.\n+      --  Common processing for all extended Import and Export pragmas applying\n+      --  to subprograms. The caller omits any arguments that do not apply to\n+      --  the pragma in question (for example, Arg_Result_Type can be non-Empty\n+      --  only in the Import_Function and Export_Function cases). The argument\n+      --  names correspond to the allowed pragma association identifiers.\n \n       procedure Process_Generic_List;\n       --  Common processing for Share_Generic and Inline_Generic\n@@ -651,8 +649,8 @@ package body Sem_Prag is\n \n       procedure Process_Inline (Active : Boolean);\n       --  Common processing for Inline and Inline_Always. The parameter\n-      --  indicates if the inline pragma is active, i.e. if it should\n-      --  actually cause inlining to occur.\n+      --  indicates if the inline pragma is active, i.e. if it should actually\n+      --  cause inlining to occur.\n \n       procedure Process_Interface_Name\n         (Subprogram_Def : Entity_Id;\n@@ -661,12 +659,12 @@ package body Sem_Prag is\n       --  Given the last two arguments of pragma Import, pragma Export, or\n       --  pragma Interface_Name, performs validity checks and sets the\n       --  Interface_Name field of the given subprogram entity to the\n-      --  appropriate external or link name, depending on the arguments\n-      --  given. Ext_Arg is always present, but Link_Arg may be missing.\n-      --  Note that Ext_Arg may represent the Link_Name if Link_Arg is\n-      --  missing, and appropriate named notation is used for Ext_Arg.\n-      --  If neither Ext_Arg nor Link_Arg is present, the interface name\n-      --  is set to the default from the subprogram name.\n+      --  appropriate external or link name, depending on the arguments given.\n+      --  Ext_Arg is always present, but Link_Arg may be missing. Note that\n+      --  Ext_Arg may represent the Link_Name if Link_Arg is missing, and\n+      --  appropriate named notation is used for Ext_Arg. If neither Ext_Arg\n+      --  nor Link_Arg is present, the interface name is set to the default\n+      --  from the subprogram name.\n \n       procedure Process_Interrupt_Or_Attach_Handler;\n       --  Common processing for Interrupt and Attach_Handler pragmas\n@@ -711,10 +709,10 @@ package body Sem_Prag is\n       --  set appropriately.\n \n       procedure Set_Ravenscar_Profile (N : Node_Id);\n-      --  Activate the set of configuration pragmas and restrictions that\n-      --  make up the Ravenscar Profile. N is the corresponding pragma\n-      --  node, which is used for error messages on any constructs\n-      --  that violate the profile.\n+      --  Activate the set of configuration pragmas and restrictions that make\n+      --  up the Ravenscar Profile. N is the corresponding pragma node, which\n+      --  is used for error messages on any constructs that violate the\n+      --  profile.\n \n       ---------------------\n       -- Ada_2005_Pragma --\n@@ -981,19 +979,19 @@ package body Sem_Prag is\n          elsif Etype (Argx) = Any_Type then\n             raise Pragma_Exit;\n \n-         --  An interesting special case, if we have a string literal and\n-         --  we are in Ada 83 mode, then we allow it even though it will\n-         --  not be flagged as static. This allows the use of Ada 95\n-         --  pragmas like Import in Ada 83 mode. They will of course be\n-         --  flagged with warnings as usual, but will not cause errors.\n+         --  An interesting special case, if we have a string literal and we\n+         --  are in Ada 83 mode, then we allow it even though it will not be\n+         --  flagged as static. This allows the use of Ada 95 pragmas like\n+         --  Import in Ada 83 mode. They will of course be flagged with\n+         --  warnings as usual, but will not cause errors.\n \n          elsif Ada_Version = Ada_83\n            and then Nkind (Argx) = N_String_Literal\n          then\n             return;\n \n-         --  Static expression that raises Constraint_Error. This has\n-         --  already been flagged, so just exit from pragma processing.\n+         --  Static expression that raises Constraint_Error. This has already\n+         --  been flagged, so just exit from pragma processing.\n \n          elsif Is_Static_Expression (Argx) then\n             raise Pragma_Exit;\n@@ -1422,11 +1420,11 @@ package body Sem_Prag is\n          while Present (Prev (P)) loop\n             P := Prev (P);\n \n-            --  If the previous node is a generic subprogram, do not go to\n-            --  to the original node, which is the unanalyzed tree: we need\n-            --  to attach the pre/postconditions to the analyzed version\n-            --  at this point. They get propagated to the original tree when\n-            --  analyzing the corresponding body.\n+            --  If the previous node is a generic subprogram, do not go to to\n+            --  the original node, which is the unanalyzed tree: we need to\n+            --  attach the pre/postconditions to the analyzed version at this\n+            --  point. They get propagated to the original tree when analyzing\n+            --  the corresponding body.\n \n             if Nkind (P) not in N_Generic_Declaration then\n                PO := Original_Node (P);\n@@ -1452,8 +1450,8 @@ package body Sem_Prag is\n             end if;\n          end loop;\n \n-         --  If we fall through loop, pragma is at start of list, so see if\n-         --  it is at the start of declarations of a subprogram body.\n+         --  If we fall through loop, pragma is at start of list, so see if it\n+         --  is at the start of declarations of a subprogram body.\n \n          if Nkind (Parent (N)) = N_Subprogram_Body\n            and then List_Containing (N) = Declarations (Parent (N))\n@@ -1487,8 +1485,8 @@ package body Sem_Prag is\n       -----------------------------\n \n       --  Note: for convenience in writing this procedure, in addition to\n-      --  the officially (i.e. by spec) allowed argument which is always\n-      --  a constraint, it also allows ranges and discriminant associations.\n+      --  the officially (i.e. by spec) allowed argument which is always a\n+      --  constraint, it also allows ranges and discriminant associations.\n       --  Above is not clear ???\n \n       procedure Check_Static_Constraint (Constr : Node_Id) is\n@@ -1581,9 +1579,9 @@ package body Sem_Prag is\n             if Parent_Node = Empty then\n                Pragma_Misplaced;\n \n-            --  Case of pragma appearing after a compilation unit. In this\n-            --  case it must have an argument with the corresponding name\n-            --  and must be part of the following pragmas of its parent.\n+            --  Case of pragma appearing after a compilation unit. In this case\n+            --  it must have an argument with the corresponding name and must\n+            --  be part of the following pragmas of its parent.\n \n             elsif Nkind (Parent_Node) = N_Compilation_Unit_Aux then\n                if Plist /= Pragmas_After (Parent_Node) then\n@@ -2201,12 +2199,12 @@ package body Sem_Prag is\n                   Set_Has_Delayed_Freeze (E);\n                end if;\n \n-               --  An interesting improvement here. If an object of type X\n-               --  is declared atomic, and the type X is not atomic, that's\n-               --  a pity, since it may not have appropriate alignment etc.\n-               --  We can rescue this in the special case where the object\n-               --  and type are in the same unit by just setting the type\n-               --  as atomic, so that the back end will process it as atomic.\n+               --  An interesting improvement here. If an object of type X is\n+               --  declared atomic, and the type X is not atomic, that's a\n+               --  pity, since it may not have appropriate alignment etc. We\n+               --  can rescue this in the special case where the object and\n+               --  type are in the same unit by just setting the type as\n+               --  atomic, so that the back end will process it as atomic.\n \n                Utyp := Underlying_Type (Etype (E));\n \n@@ -2268,17 +2266,17 @@ package body Sem_Prag is\n                   --  warning, even though it is not in the main unit.\n \n                begin\n-                  --  Loop through segments of message separated by line\n-                  --  feeds. We output these segments as separate messages\n-                  --  with continuation marks for all but the first.\n+                  --  Loop through segments of message separated by line feeds.\n+                  --  We output these segments as separate messages with\n+                  --  continuation marks for all but the first.\n \n                   Cont := False;\n                   Ptr := 1;\n                   loop\n                      Error_Msg_Strlen := 0;\n \n-                     --  Loop to copy characters from argument to error\n-                     --  message string buffer.\n+                     --  Loop to copy characters from argument to error message\n+                     --  string buffer.\n \n                      loop\n                         exit when Ptr > Len;\n@@ -2386,9 +2384,8 @@ package body Sem_Prag is\n                Set_Has_Convention_Pragma (Underlying_Type (E), True);\n             end if;\n \n-            --  A class-wide type should inherit the convention of\n-            --  the specific root type (although this isn't specified\n-            --  clearly by the RM).\n+            --  A class-wide type should inherit the convention of the specific\n+            --  root type (although this isn't specified clearly by the RM).\n \n             if Is_Type (E) and then Present (Class_Wide_Type (E)) then\n                Set_Convention (Class_Wide_Type (E), C);\n@@ -2413,9 +2410,9 @@ package body Sem_Prag is\n                end if;\n             end if;\n \n-            --  If the entity is a derived boolean type, check for the\n-            --  special case of convention C, C++, or Fortran, where we\n-            --  consider any nonzero value to represent true.\n+            --  If the entity is a derived boolean type, check for the special\n+            --  case of convention C, C++, or Fortran, where we consider any\n+            --  nonzero value to represent true.\n \n             if Is_Discrete_Type (E)\n               and then Root_Type (Etype (E)) = Standard_Boolean\n@@ -2438,9 +2435,8 @@ package body Sem_Prag is\n          Check_Arg_Is_Identifier (Arg1);\n          Cname := Chars (Expression (Arg1));\n \n-         --  C_Pass_By_Copy is treated as a synonym for convention C\n-         --  (this is tested again below to set the critical flag)\n-\n+         --  C_Pass_By_Copy is treated as a synonym for convention C (this is\n+         --  tested again below to set the critical flag).\n          if Cname = Name_C_Pass_By_Copy then\n             C := Convention_C;\n \n@@ -2617,8 +2613,8 @@ package body Sem_Prag is\n                E1 := Homonym (E1);\n                exit when No (E1) or else Scope (E1) /= Current_Scope;\n \n-               --  Do not set the pragma on inherited operations or on\n-               --  formal subprograms.\n+               --  Do not set the pragma on inherited operations or on formal\n+               --  subprograms.\n \n                if Comes_From_Source (E1)\n                  and then Comp_Unit = Get_Source_Unit (E1)\n@@ -2882,10 +2878,10 @@ package body Sem_Prag is\n          function Same_Base_Type\n           (Ptype  : Node_Id;\n            Formal : Entity_Id) return Boolean;\n-         --  Determines if Ptype references the type of Formal. Note that\n-         --  only the base types need to match according to the spec. Ptype\n-         --  here is the argument from the pragma, which is either a type\n-         --  name, or an access attribute.\n+         --  Determines if Ptype references the type of Formal. Note that only\n+         --  the base types need to match according to the spec. Ptype here is\n+         --  the argument from the pragma, which is either a type name, or an\n+         --  access attribute.\n \n          --------------------\n          -- Same_Base_Type --\n@@ -2914,8 +2910,8 @@ package body Sem_Prag is\n                end if;\n \n                --  We have a match if the corresponding argument is of an\n-               --  anonymous access type, and its designated type matches\n-               --  the type of the prefix of the access attribute\n+               --  anonymous access type, and its designated type matches the\n+               --  type of the prefix of the access attribute\n \n                return Ekind (Ftyp) = E_Anonymous_Access_Type\n                  and then Base_Type (Entity (Pref)) =\n@@ -2932,8 +2928,8 @@ package body Sem_Prag is\n                   raise Pragma_Exit;\n                end if;\n \n-               --  We have a match if the corresponding argument is of\n-               --  the type given in the pragma (comparing base types)\n+               --  We have a match if the corresponding argument is of the type\n+               --  given in the pragma (comparing base types)\n \n                return Base_Type (Entity (Ptype)) = Ftyp;\n             end if;\n@@ -3438,16 +3434,16 @@ package body Sem_Prag is\n                then\n                   null;\n \n-               --  If it is not a subprogram, it must be in an outer\n-               --  scope and pragma does not apply.\n+               --  If it is not a subprogram, it must be in an outer scope and\n+               --  pragma does not apply.\n \n                elsif not Is_Subprogram (Def_Id)\n                  and then not Is_Generic_Subprogram (Def_Id)\n                then\n                   null;\n \n-               --  Verify that the homonym is in the same declarative\n-               --  part (not just the same scope).\n+               --  Verify that the homonym is in the same declarative part (not\n+               --  just the same scope).\n \n                elsif Parent (Unit_Declaration_Node (Def_Id)) /= Parent (N)\n                  and then Nkind (Parent (N)) /= N_Compilation_Unit_Aux\n@@ -3478,24 +3474,24 @@ package body Sem_Prag is\n \n                      Set_Is_Intrinsic_Subprogram (Def_Id);\n \n-                     --  If no external name is present, then check that\n-                     --  this is a valid intrinsic subprogram. If an external\n-                     --  name is present, then this is handled by the back end.\n+                     --  If no external name is present, then check that this\n+                     --  is a valid intrinsic subprogram. If an external name\n+                     --  is present, then this is handled by the back end.\n \n                      if No (Arg3) then\n                         Check_Intrinsic_Subprogram (Def_Id, Expression (Arg2));\n                      end if;\n                   end if;\n \n-                  --  All interfaced procedures need an external symbol\n-                  --  created for them since they are always referenced\n-                  --  from another object file.\n+                  --  All interfaced procedures need an external symbol created\n+                  --  for them since they are always referenced from another\n+                  --  object file.\n \n                   Set_Is_Public (Def_Id);\n \n                   --  Verify that the subprogram does not have a completion\n-                  --  through a renaming declaration. For other completions\n-                  --  the pragma appears as a too late representation.\n+                  --  through a renaming declaration. For other completions the\n+                  --  pragma appears as a too late representation.\n \n                   declare\n                      Decl : constant Node_Id := Unit_Declaration_Node (Def_Id);\n@@ -3582,9 +3578,9 @@ package body Sem_Prag is\n                Arg2);\n          end if;\n \n-         --  If this pragma applies to a compilation unit, then the unit,\n-         --  which is a subprogram, does not require (or allow) a body.\n-         --  We also do not need to elaborate imported procedures.\n+         --  If this pragma applies to a compilation unit, then the unit, which\n+         --  is a subprogram, does not require (or allow) a body. We also do\n+         --  not need to elaborate imported procedures.\n \n          if Nkind (Parent (N)) = N_Compilation_Unit_Aux then\n             declare\n@@ -3608,9 +3604,9 @@ package body Sem_Prag is\n          Effective : Boolean := False;\n \n          procedure Make_Inline (Subp : Entity_Id);\n-         --  Subp is the defining unit name of the subprogram\n-         --  declaration. Set the flag, as well as the flag in the\n-         --  corresponding body, if there is one present.\n+         --  Subp is the defining unit name of the subprogram declaration. Set\n+         --  the flag, as well as the flag in the corresponding body, if there\n+         --  is one present.\n \n          procedure Set_Inline_Flags (Subp : Entity_Id);\n          --  Sets Is_Inlined and Has_Pragma_Inline flags for Subp and also\n@@ -3650,9 +3646,9 @@ package body Sem_Prag is\n                   Error_Msg_N (\"pragma appears too late, ignored?\", N);\n                   return True;\n \n-               --  If the subprogram is a renaming as body, the body is\n-               --  just a call to the renamed subprogram, and inlining is\n-               --  trivially possible.\n+               --  If the subprogram is a renaming as body, the body is just a\n+               --  call to the renamed subprogram, and inlining is trivially\n+               --  possible.\n \n                elsif\n                  Nkind (Unit_Declaration_Node (Corresponding_Body (Decl))) =\n@@ -3715,10 +3711,10 @@ package body Sem_Prag is\n \n             --  However, a simple Comes_From_Source test is insufficient, since\n             --  we do want to allow inlining of generic instances which also do\n-            --  not come from source. We also need to recognize specs\n-            --  generated by the front-end for bodies that carry the pragma.\n-            --  Finally, predefined operators do not come from source but are\n-            --  not inlineable either.\n+            --  not come from source. We also need to recognize specs generated\n+            --  by the front-end for bodies that carry the pragma. Finally,\n+            --  predefined operators do not come from source but are not\n+            --  inlineable either.\n \n             elsif Is_Generic_Instance (Subp)\n               or else Nkind (Parent (Parent (Subp))) = N_Subprogram_Declaration\n@@ -3732,8 +3728,8 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            --  The referenced entity must either be the enclosing entity,\n-            --  or an entity declared within the current open scope.\n+            --  The referenced entity must either be the enclosing entity, or\n+            --  an entity declared within the current open scope.\n \n             if Present (Scope (Subp))\n               and then Scope (Subp) /= Current_Scope\n@@ -3744,10 +3740,9 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            --  Processing for procedure, operator or function.\n-            --  If subprogram is aliased (as for an instance) indicate\n-            --  that the renamed entity (if declared in the same unit)\n-            --  is inlined.\n+            --  Processing for procedure, operator or function. If subprogram\n+            --  is aliased (as for an instance) indicate that the renamed\n+            --  entity (if declared in the same unit) is inlined.\n \n             if Is_Subprogram (Subp) then\n                while Present (Alias (Inner_Subp)) loop\n@@ -3767,9 +3762,9 @@ package body Sem_Prag is\n                   elsif Is_Generic_Instance (Subp) then\n \n                      --  Indicate that the body needs to be created for\n-                     --  inlining subsequent calls. The instantiation\n-                     --  node follows the declaration of the wrapper\n-                     --  package created for it.\n+                     --  inlining subsequent calls. The instantiation node\n+                     --  follows the declaration of the wrapper package\n+                     --  created for it.\n \n                      if Scope (Subp) /= Standard_Standard\n                        and then\n@@ -3784,9 +3779,9 @@ package body Sem_Prag is\n \n                Applies := True;\n \n-            --  For a generic subprogram set flag as well, for use at\n-            --  the point of instantiation, to determine whether the\n-            --  body should be generated.\n+            --  For a generic subprogram set flag as well, for use at the point\n+            --  of instantiation, to determine whether the body should be\n+            --  generated.\n \n             elsif Is_Generic_Subprogram (Subp) then\n                Set_Inline_Flags (Subp);\n@@ -4046,8 +4041,8 @@ package body Sem_Prag is\n             Link_Nam := Adjust_External_Name_Case (Expr_Value_S (Ext_Nam));\n \n          --  For the Link_Name case, the given literal is preceded by an\n-         --  asterisk, which indicates to GCC that the given name should\n-         --  be taken literally, and in particular that no prepending of\n+         --  asterisk, which indicates to GCC that the given name should be\n+         --  taken literally, and in particular that no prepending of\n          --  underlines should occur, even in systems where this is the\n          --  normal default.\n \n@@ -4082,10 +4077,10 @@ package body Sem_Prag is\n       begin\n          Set_Is_Interrupt_Handler (Handler_Proc);\n \n-         --  If the pragma is not associated with a handler procedure\n-         --  within a protected type, then it must be for a nonprotected\n-         --  procedure for the AAMP target, in which case we don't\n-         --  associate a representation item with the procedure's scope.\n+         --  If the pragma is not associated with a handler procedure within a\n+         --  protected type, then it must be for a nonprotected procedure for\n+         --  the AAMP target, in which case we don't associate a representation\n+         --  item with the procedure's scope.\n \n          if Ekind (Proc_Scope) = E_Protected_Type then\n             if Prag_Id = Pragma_Interrupt_Handler\n@@ -4345,8 +4340,8 @@ package body Sem_Prag is\n       --  Start of processing for Process_Suppress_Unsuppress\n \n       begin\n-         --  Suppress/Unsuppress can appear as a configuration pragma,\n-         --  or in a declarative part or a package spec (RM 11.5(5))\n+         --  Suppress/Unsuppress can appear as a configuration pragma, or in a\n+         --  declarative part or a package spec (RM 11.5(5)).\n \n          if not Is_Configuration_Pragma then\n             Check_Is_In_Decl_Part_Or_Package_Spec;\n@@ -4456,8 +4451,8 @@ package body Sem_Prag is\n                E := Homonym (E);\n                exit when No (E);\n \n-               --  If we are within a package specification, the\n-               --  pragma only applies to homonyms in the same scope.\n+               --  If we are within a package specification, the pragma only\n+               --  applies to homonyms in the same scope.\n \n                exit when In_Package_Spec\n                  and then Scope (E) /= Current_Scope;\n@@ -4503,12 +4498,11 @@ package body Sem_Prag is\n                Set_Is_Public (E);\n                Set_Is_Statically_Allocated (E);\n \n-               --  Warn if the corresponding W flag is set and the pragma\n-               --  comes from source. The latter may not be true e.g. on\n-               --  VMS where we expand export pragmas for exception codes\n-               --  associated with imported or exported exceptions. We do\n-               --  not want to generate a warning for something that the\n-               --  user did not write.\n+               --  Warn if the corresponding W flag is set and the pragma comes\n+               --  from source. The latter may not be true e.g. on VMS where we\n+               --  expand export pragmas for exception codes associated with\n+               --  imported or exported exceptions. We do not want to generate\n+               --  a warning for something that the user did not write.\n \n                if Warn_On_Export_Import\n                  and then Comes_From_Source (Arg)\n@@ -4560,16 +4554,16 @@ package body Sem_Prag is\n          elsif Nkind (Arg_External) = N_Identifier then\n             New_Name := Get_Default_External_Name (Arg_External);\n \n-         --  Check_Arg_Is_External_Name should let through only\n-         --  identifiers and string literals or static string\n-         --  expressions (which are folded to string literals).\n+         --  Check_Arg_Is_External_Name should let through only identifiers and\n+         --  string literals or static string expressions (which are folded to\n+         --  string literals).\n \n          else\n             raise Program_Error;\n          end if;\n \n-         --  If we already have an external name set (by a prior normal\n-         --  Import or Export pragma), then the external names must match\n+         --  If we already have an external name set (by a prior normal Import\n+         --  or Export pragma), then the external names must match\n \n          if Present (Interface_Name (Internal_Ent)) then\n             Check_Matching_Internal_Names : declare\n@@ -4641,10 +4635,10 @@ package body Sem_Prag is\n          else\n             Set_Is_Imported (E);\n \n-            --  If the entity is an object that is not at the library\n-            --  level, then it is statically allocated. We do not worry\n-            --  about objects with address clauses in this context since\n-            --  they are not really imported in the linker sense.\n+            --  If the entity is an object that is not at the library level,\n+            --  then it is statically allocated. We do not worry about objects\n+            --  with address clauses in this context since they are not really\n+            --  imported in the linker sense.\n \n             if Is_Object (E)\n               and then not Is_Library_Level_Entity (E)\n@@ -4659,9 +4653,9 @@ package body Sem_Prag is\n       -- Set_Mechanism_Value --\n       -------------------------\n \n-      --  Note: the mechanism name has not been analyzed (and cannot indeed\n-      --  be analyzed, since it is semantic nonsense), so we get it in the\n-      --  exact form created by the parser.\n+      --  Note: the mechanism name has not been analyzed (and cannot indeed be\n+      --  analyzed, since it is semantic nonsense), so we get it in the exact\n+      --  form created by the parser.\n \n       procedure Set_Mechanism_Value (Ent : Entity_Id; Mech_Name : Node_Id) is\n          Class : Node_Id;\n@@ -5435,7 +5429,7 @@ package body Sem_Prag is\n               and then not Is_Remote_Types (C_Ent)\n             then\n                --  This pragma should only appear in an RCI or Remote Types\n-               --  unit (RM E.4.1(4))\n+               --  unit (RM E.4.1(4)).\n \n                Error_Pragma\n                  (\"pragma% not in Remote_Call_Interface or \" &\n@@ -5461,18 +5455,18 @@ package body Sem_Prag is\n \n             elsif Is_Remote_Access_To_Subprogram_Type (Nm) then\n \n-               if Is_Record_Type (Nm) then\n-                  --  A record type that is the Equivalent_Type for\n-                  --  a remote access-to-subprogram type.\n+                  if Is_Record_Type (Nm) then\n \n-                  N := Declaration_Node (Corresponding_Remote_Type (Nm));\n+                  --  A record type that is the Equivalent_Type for a remote\n+                  --  access-to-subprogram type.\n \n-               else\n-                  --  A non-expanded RAS type (case where distribution is\n-                  --  not enabled).\n+                     N := Declaration_Node (Corresponding_Remote_Type (Nm));\n \n-                  N := Declaration_Node (Nm);\n-               end if;\n+                  else\n+                     --  A non-expanded RAS type (distribution is not enabled)\n+\n+                     N := Declaration_Node (Nm);\n+                  end if;\n \n                if Nkind (N) = N_Full_Type_Declaration\n                  and then Nkind (Type_Definition (N)) =\n@@ -5794,8 +5788,8 @@ package body Sem_Prag is\n \n          --  POLICY_IDENTIFIER ::= ON | OFF | CHECK | IGNORE\n \n-         --  Note: this is a configuration pragma, but it is allowed to\n-         --  appear anywhere else.\n+         --  Note: this is a configuration pragma, but it is allowed to appear\n+         --  anywhere else.\n \n          when Pragma_Check_Policy =>\n             GNAT_Pragma;\n@@ -5983,11 +5977,11 @@ package body Sem_Prag is\n \n             Check_Arg_Is_Identifier (Form);\n \n-            --  Get proper alignment, note that Default = Component_Size\n-            --  on all machines we have so far, and we want to set this\n-            --  value rather than the default value to indicate that it\n-            --  has been explicitly set (and thus will not get overridden\n-            --  by the default component alignment for the current scope)\n+            --  Get proper alignment, note that Default = Component_Size on all\n+            --  machines we have so far, and we want to set this value rather\n+            --  than the default value to indicate that it has been explicitly\n+            --  set (and thus will not get overridden by the default component\n+            --  alignment for the current scope)\n \n             if Chars (Form) = Name_Component_Size then\n                Atype := Calign_Component_Size;\n@@ -6599,8 +6593,8 @@ package body Sem_Prag is\n                --  safe from an elaboration point of view, so a client must\n                --  still do an Elaborate_All on such units.\n \n-               --  Debug flag -gnatdD restores the old behavior of 3.13,\n-               --  where Elaborate_Body always suppressed elab warnings.\n+               --  Debug flag -gnatdD restores the old behavior of 3.13, where\n+               --  Elaborate_Body always suppressed elab warnings.\n \n                if Dynamic_Elaboration_Checks or Debug_Flag_DD then\n                   Set_Suppress_Elaboration_Warnings (Cunit_Ent);\n@@ -6737,9 +6731,8 @@ package body Sem_Prag is\n             Process_Interface_Name (Def_Id, Arg3, Arg4);\n             Set_Exported (Def_Id, Arg2);\n \n-            --  If the entity is a deferred constant, propagate the\n-            --  information to the full view, because gigi elaborates\n-            --  the full view only.\n+            --  If the entity is a deferred constant, propagate the information\n+            --  to the full view, because gigi elaborates the full view only.\n \n             if Ekind (Def_Id) = E_Constant\n               and then Present (Full_View (Def_Id))\n@@ -7385,10 +7378,10 @@ package body Sem_Prag is\n \n          --  pragma Ident (static_string_EXPRESSION)\n \n-         --  Note: pragma Comment shares this processing. Pragma Comment\n-         --  is identical to Ident, except that the restriction of the\n-         --  argument to 31 characters and the placement restrictions\n-         --  are not enforced for pragma Comment.\n+         --  Note: pragma Comment shares this processing. Pragma Comment is\n+         --  identical to Ident, except that the restriction of the argument to\n+         --  31 characters and the placement restrictions are not enforced for\n+         --  pragma Comment.\n \n          when Pragma_Ident | Pragma_Comment => Ident : declare\n             Str : Node_Id;\n@@ -7399,8 +7392,8 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n \n-            --  For pragma Ident, preserve DEC compatibility by requiring\n-            --  the pragma to appear in a declarative part or package spec.\n+            --  For pragma Ident, preserve DEC compatibility by requiring the\n+            --  pragma to appear in a declarative part or package spec.\n \n             if Prag_Id = Pragma_Ident then\n                Check_Is_In_Decl_Part_Or_Package_Spec;\n@@ -7421,8 +7414,8 @@ package body Sem_Prag is\n                   GP := Parent (GP);\n                end if;\n \n-               --  If we have a compilation unit, then record the ident\n-               --  value, checking for improper duplication.\n+               --  If we have a compilation unit, then record the ident value,\n+               --  checking for improper duplication.\n \n                if Nkind (GP) = N_Compilation_Unit then\n                   CS := Ident_String (Current_Sem_Unit);\n@@ -7434,8 +7427,8 @@ package body Sem_Prag is\n                      if Prag_Id = Pragma_Ident then\n                         Error_Pragma (\"duplicate% pragma not permitted\");\n \n-                     --  For Comment, we concatenate the string, unless we\n-                     --  want to preserve the tree structure for ASIS.\n+                     --  For Comment, we concatenate the string, unless we want\n+                     --  to preserve the tree structure for ASIS.\n \n                      elsif not ASIS_Mode then\n                         Start_String (Strval (CS));\n@@ -7467,9 +7460,9 @@ package body Sem_Prag is\n                      Set_Ident_String (Current_Sem_Unit, Str);\n                   end if;\n \n-               --  For subunits, we just ignore the Ident, since in GNAT\n-               --  these are not separate object files, and hence not\n-               --  separate units in the unit table.\n+               --  For subunits, we just ignore the Ident, since in GNAT these\n+               --  are not separate object files, and hence not separate units\n+               --  in the unit table.\n \n                elsif Nkind (GP) = N_Subunit then\n                   null;\n@@ -8103,10 +8096,10 @@ package body Sem_Prag is\n          --  INTERRUPT_ID => IDENTIFIER | static_integer_EXPRESSION\n          --  INTERRUPT_STATE => System | Runtime | User\n \n-         --  Note: if the interrupt id is given as an identifier, then\n-         --  it must be one of the identifiers in Ada.Interrupts.Names.\n-         --  Otherwise it is given as a static integer expression which\n-         --  must be in the range of Ada.Interrupts.Interrupt_ID.\n+         --  Note: if the interrupt id is given as an identifier, then it must\n+         --  be one of the identifiers in Ada.Interrupts.Names. Otherwise it is\n+         --  given as a static integer expression which must be in the range of\n+         --  Ada.Interrupts.Interrupt_ID.\n \n          when Pragma_Interrupt_State => Interrupt_State : declare\n \n@@ -8156,8 +8149,8 @@ package body Sem_Prag is\n                   Next_Entity (Int_Ent);\n                end loop;\n \n-            --  First argument is not an identifier, so it must be a\n-            --  static expression of type Ada.Interrupts.Interrupt_ID.\n+            --  First argument is not an identifier, so it must be a static\n+            --  expression of type Ada.Interrupts.Interrupt_ID.\n \n             else\n                Check_Arg_Is_Static_Expression (Arg1, Any_Integer);\n@@ -8334,11 +8327,11 @@ package body Sem_Prag is\n \n             Typ := Underlying_Type (Entity (Arg));\n \n-            --  For now we simply check some of the semantic constraints\n-            --  on the type. This currently leaves out some restrictions\n-            --  on interface types, namely that the parent type must be\n-            --  java.lang.Object.Typ and that all primitives of the type\n-            --  should be declared abstract. ???\n+            --  For now simply check some of the semantic constraints on the\n+            --  type. This currently leaves out some restrictions on interface\n+            --  types, namely that the parent type must be java.lang.Object.Typ\n+            --  and that all primitives of the type should be declared\n+            --  abstract. ???\n \n             if not Is_Tagged_Type (Typ) or else not Is_Abstract_Type (Typ) then\n                Error_Pragma_Arg (\"pragma% requires an abstract \"\n@@ -8449,10 +8442,9 @@ package body Sem_Prag is\n                while Present (Arg) loop\n                   Check_Arg_Is_Static_Expression (Arg, Standard_String);\n \n-                  --  Store argument, converting sequences of spaces\n-                  --  to a single null character (this is one of the\n-                  --  differences in processing between Link_With\n-                  --  and Linker_Options).\n+                  --  Store argument, converting sequences of spaces to a\n+                  --  single null character (this is one of the differences\n+                  --  in processing between Link_With and Linker_Options).\n \n                   Arg_Store : declare\n                      C : constant Char_Code := Get_Char_Code (' ');\n@@ -8481,8 +8473,8 @@ package body Sem_Prag is\n                      Skip_Spaces; -- skip leading spaces\n \n                      --  Loop through characters, changing any embedded\n-                     --  sequence of spaces to a single null character\n-                     --  (this is how Link_With/Linker_Options differ)\n+                     --  sequence of spaces to a single null character (this\n+                     --  is how Link_With/Linker_Options differ)\n \n                      while F <= L loop\n                         if Get_String_Char (S, F) = C then\n@@ -8654,9 +8646,9 @@ package body Sem_Prag is\n \n          --  pragma List (On | Off)\n \n-         --  There is nothing to do here, since we did all the processing\n-         --  for this pragma in Par.Prag (so that it works properly even in\n-         --  syntax only mode)\n+         --  There is nothing to do here, since we did all the processing for\n+         --  this pragma in Par.Prag (so that it works properly even in syntax\n+         --  only mode).\n \n          when Pragma_List =>\n             null;\n@@ -8685,8 +8677,8 @@ package body Sem_Prag is\n                Error_Msg_Sloc := Locking_Policy_Sloc;\n                Error_Pragma (\"locking policy incompatible with policy#\");\n \n-            --  Set new policy, but always preserve System_Location since\n-            --  we like the error message with the run time name.\n+            --  Set new policy, but always preserve System_Location since we\n+            --  like the error message with the run time name.\n \n             else\n                Locking_Policy := LP;\n@@ -8980,8 +8972,8 @@ package body Sem_Prag is\n \n          --  pragma No_Run_Time;\n \n-         --  Note: this pragma is retained for backwards compatibility.\n-         --  See body of Rtsfind for full details on its handling.\n+         --  Note: this pragma is retained for backwards compatibility. See\n+         --  body of Rtsfind for full details on its handling.\n \n          when Pragma_No_Run_Time =>\n             GNAT_Pragma;\n@@ -9088,8 +9080,8 @@ package body Sem_Prag is\n \n                if Present (Ename) then\n \n-                  --  If entity name matches, we are fine\n-                  --  Save entity in pragma argument, for ASIS use.\n+                  --  If entity name matches, we are fine. Save entity in\n+                  --  pragma argument, for ASIS use.\n \n                   if Chars (Ename) = Chars (Ent) then\n                      Set_Entity (Ename, Ent);\n@@ -9422,9 +9414,9 @@ package body Sem_Prag is\n \n          --  pragma Page;\n \n-         --  There is nothing to do here, since we did all the processing\n-         --  for this pragma in Par.Prag (so that it works properly even in\n-         --  syntax only mode)\n+         --  There is nothing to do here, since we did all the processing for\n+         --  this pragma in Par.Prag (so that it works properly even in syntax\n+         --  only mode).\n \n          when Pragma_Page =>\n             null;\n@@ -10310,8 +10302,8 @@ package body Sem_Prag is\n                Error_Msg_Sloc := Queuing_Policy_Sloc;\n                Error_Pragma (\"queuing policy incompatible with policy#\");\n \n-            --  Set new policy, but always preserve System_Location since\n-            --  we like the error message with the run time name.\n+            --  Set new policy, but always preserve System_Location since we\n+            --  like the error message with the run time name.\n \n             else\n                Queuing_Policy := QP;\n@@ -10606,16 +10598,16 @@ package body Sem_Prag is\n          --  CASING_SPEC ::= Uppercase | Lowercase | Mixedcase\n \n          --  Pragma Source_File_Name_Project (SFNP) is equivalent to pragma\n-         --  Source_File_Name (SFN), however their usage is exclusive:\n-         --  SFN can only be used when no project file is used, while\n-         --  SFNP can only be used when a project file is used.\n+         --  Source_File_Name (SFN), however their usage is exclusive: SFN can\n+         --  only be used when no project file is used, while SFNP can only be\n+         --  used when a project file is used.\n \n-         --  No processing here. Processing was completed during parsing,\n-         --  since we need to have file names set as early as possible.\n-         --  Units are loaded well before semantic processing starts.\n+         --  No processing here. Processing was completed during parsing, since\n+         --  we need to have file names set as early as possible. Units are\n+         --  loaded well before semantic processing starts.\n \n-         --  The only processing we defer to this point is the check\n-         --  for correct placement.\n+         --  The only processing we defer to this point is the check for\n+         --  correct placement.\n \n          when Pragma_Source_File_Name =>\n             GNAT_Pragma;\n@@ -10627,27 +10619,27 @@ package body Sem_Prag is\n \n          --  See Source_File_Name for syntax\n \n-         --  No processing here. Processing was completed during parsing,\n-         --  since we need to have file names set as early as possible.\n-         --  Units are loaded well before semantic processing starts.\n+         --  No processing here. Processing was completed during parsing, since\n+         --  we need to have file names set as early as possible. Units are\n+         --  loaded well before semantic processing starts.\n \n-         --  The only processing we defer to this point is the check\n-         --  for correct placement.\n+         --  The only processing we defer to this point is the check for\n+         --  correct placement.\n \n          when Pragma_Source_File_Name_Project =>\n             GNAT_Pragma;\n             Check_Valid_Configuration_Pragma;\n \n-            --  Check that a pragma Source_File_Name_Project is used only\n-            --  in a configuration pragmas file.\n+            --  Check that a pragma Source_File_Name_Project is used only in a\n+            --  configuration pragmas file.\n \n-            --  Pragmas Source_File_Name_Project should only be generated\n-            --  by the Project Manager in configuration pragmas files.\n+            --  Pragmas Source_File_Name_Project should only be generated by\n+            --  the Project Manager in configuration pragmas files.\n \n             --  This is really an ugly test. It seems to depend on some\n-            --  accidental and undocumented property. At the very least\n-            --  it needs to be documented, but it would be better to have\n-            --  a clean way of testing if we are in a configuration file???\n+            --  accidental and undocumented property. At the very least it\n+            --  needs to be documented, but it would be better to have a\n+            --  clean way of testing if we are in a configuration file???\n \n             if Present (Parent (N)) then\n                Error_Pragma\n@@ -10660,8 +10652,8 @@ package body Sem_Prag is\n \n          --  pragma Source_Reference (INTEGER_LITERAL [, STRING_LITERAL]);\n \n-         --  Nothing to do, all processing completed in Par.Prag, since we\n-         --  need the information for possible parser messages that are output\n+         --  Nothing to do, all processing completed in Par.Prag, since we need\n+         --  the information for possible parser messages that are output.\n \n          when Pragma_Source_Reference =>\n             GNAT_Pragma;\n@@ -10757,10 +10749,10 @@ package body Sem_Prag is\n          when Pragma_Stream_Convert => Stream_Convert : declare\n \n             procedure Check_OK_Stream_Convert_Function (Arg : Node_Id);\n-            --  Check that the given argument is the name of a local\n-            --  function of one argument that is not overloaded earlier\n-            --  in the current local scope. A check is also made that the\n-            --  argument is a function with one parameter.\n+            --  Check that the given argument is the name of a local function\n+            --  of one argument that is not overloaded earlier in the current\n+            --  local scope. A check is also made that the argument is a\n+            --  function with one parameter.\n \n             --------------------------------------\n             -- Check_OK_Stream_Convert_Function --\n@@ -10863,9 +10855,9 @@ package body Sem_Prag is\n \n          --  pragma Style_Checks (On | Off | ALL_CHECKS | STRING_LITERAL);\n \n-         --  This is processed by the parser since some of the style\n-         --  checks take place during source scanning and parsing. This\n-         --  means that we don't need to issue error messages here.\n+         --  This is processed by the parser since some of the style checks\n+         --  take place during source scanning and parsing. This means that\n+         --  we don't need to issue error messages here.\n \n          when Pragma_Style_Checks => Style_Checks : declare\n             A  : constant Node_Id   := Expression (Arg1);\n@@ -10983,11 +10975,10 @@ package body Sem_Prag is\n \n          --  pragma Suppress_All;\n \n-         --  The only check made here is that the pragma appears in the\n-         --  proper place, i.e. following a compilation unit. If indeed\n-         --  it appears in this context, then the parser has already\n-         --  inserted an equivalent pragma Suppress (All_Checks) to get\n-         --  the required effect.\n+         --  The only check made here is that the pragma appears in the proper\n+         --  place, i.e. following a compilation unit. If indeed it appears in\n+         --  this context, then the parser has already inserted an equivalent\n+         --  pragma Suppress (All_Checks) to get the required effect.\n \n          when Pragma_Suppress_All =>\n             GNAT_Pragma;\n@@ -11075,8 +11066,8 @@ package body Sem_Prag is\n \n          --  pragma System_Name (DIRECT_NAME);\n \n-         --  Syntax check: one argument, which must be the identifier GNAT\n-         --  or the identifier GCC, no other identifiers are acceptable.\n+         --  Syntax check: one argument, which must be the identifier GNAT or\n+         --  the identifier GCC, no other identifiers are acceptable.\n \n          when Pragma_System_Name =>\n             GNAT_Pragma;\n@@ -11109,8 +11100,8 @@ package body Sem_Prag is\n                Error_Pragma\n                  (\"task dispatching policy incompatible with policy#\");\n \n-            --  Set new policy, but always preserve System_Location since\n-            --  we like the error message with the run time name.\n+            --  Set new policy, but always preserve System_Location since we\n+            --  like the error message with the run time name.\n \n             else\n                Task_Dispatching_Policy := DP;\n@@ -11169,8 +11160,8 @@ package body Sem_Prag is\n \n             Arg := Expression (Arg1);\n \n-            --  The expression is used in the call to Create_Task, and must\n-            --  be expanded there, not in the context of the current spec.\n+            --  The expression is used in the call to Create_Task, and must be\n+            --  expanded there, not in the context of the current spec.\n \n             Preanalyze_And_Resolve (New_Copy_Tree (Arg), Standard_String);\n \n@@ -11464,9 +11455,9 @@ package body Sem_Prag is\n \n          --  pragma Unimplemented_Unit;\n \n-         --  Note: this only gives an error if we are generating code,\n-         --  or if we are in a generic library unit (where the pragma\n-         --  appears in the body, not in the spec).\n+         --  Note: this only gives an error if we are generating code, or if\n+         --  we are in a generic library unit (where the pragma appears in the\n+         --  body, not in the spec).\n \n          when Pragma_Unimplemented_Unit => Unimplemented_Unit : declare\n             Cunitent : constant Entity_Id :=\n@@ -11527,10 +11518,10 @@ package body Sem_Prag is\n             GNAT_Pragma;\n \n             --  If this is a configuration pragma, then set the universal\n-            --  addressing option, otherwise confirm that the pragma\n-            --  satisfies the requirements of library unit pragma placement\n-            --  and leave it to the GNAAMP back end to detect the pragma\n-            --  (avoids transitive setting of the option due to withed units).\n+            --  addressing option, otherwise confirm that the pragma satisfies\n+            --  the requirements of library unit pragma placement and leave it\n+            --  to the GNAAMP back end to detect the pragma (avoids transitive\n+            --  setting of the option due to withed units).\n \n             if Is_Configuration_Pragma then\n                Universal_Addressing_On_AAMP := True;\n@@ -11563,13 +11554,13 @@ package body Sem_Prag is\n             while Present (Arg_Node) loop\n                Check_No_Identifier (Arg_Node);\n \n-               --  Note: the analyze call done by Check_Arg_Is_Local_Name\n-               --  will in fact generate reference, so that the entity will\n-               --  have a reference, which will inhibit any warnings about\n-               --  it not being referenced, and also properly show up in the\n-               --  ali file as a reference. But this reference is recorded\n-               --  before the Has_Pragma_Unreferenced flag is set, so that\n-               --  no warning is generated for this reference.\n+               --  Note: the analyze call done by Check_Arg_Is_Local_Name will\n+               --  in fact generate reference, so that the entity will have a\n+               --  reference, which will inhibit any warnings about it not\n+               --  being referenced, and also properly show up in the ali file\n+               --  as a reference. But this reference is recorded before the\n+               --  Has_Pragma_Unreferenced flag is set, so that no warning is\n+               --  generated for this reference.\n \n                Check_Arg_Is_Local_Name (Arg_Node);\n                Arg_Expr := Get_Pragma_Arg (Arg_Node);\n@@ -12181,9 +12172,9 @@ package body Sem_Prag is\n    function Is_Config_Static_String (Arg : Node_Id) return Boolean is\n \n       function Add_Config_Static_String (Arg : Node_Id) return Boolean;\n-      --  This is an internal recursive function that is just like the\n-      --  outer function except that it adds the string to the name buffer\n-      --  rather than placing the string in the name buffer.\n+      --  This is an internal recursive function that is just like the outer\n+      --  function except that it adds the string to the name buffer rather\n+      --  than placing the string in the name buffer.\n \n       ------------------------------\n       -- Add_Config_Static_String --\n@@ -12480,11 +12471,11 @@ package body Sem_Prag is\n    -- Is_Pragma_String_Literal --\n    ------------------------------\n \n-   --  This function returns true if the corresponding pragma argument is\n-   --  a static string expression. These are the only cases in which string\n-   --  literals can appear as pragma arguments. We also allow a string\n-   --  literal as the first argument to pragma Assert (although it will\n-   --  of course always generate a type error).\n+   --  This function returns true if the corresponding pragma argument is a\n+   --  static string expression. These are the only cases in which string\n+   --  literals can appear as pragma arguments. We also allow a string literal\n+   --  as the first argument to pragma Assert (although it will of course\n+   --  always generate a type error).\n \n    function Is_Pragma_String_Literal (Par : Node_Id) return Boolean is\n       Pragn : constant Node_Id := Parent (Par);\n@@ -12549,11 +12540,11 @@ package body Sem_Prag is\n \n    procedure Process_Compilation_Unit_Pragmas (N : Node_Id) is\n    begin\n-      --  A special check for pragma Suppress_All. This is a strange DEC\n-      --  pragma, strange because it comes at the end of the unit. If we\n-      --  have a pragma Suppress_All in the Pragmas_After of the current\n-      --  unit, then we insert a pragma Suppress (All_Checks) at the start\n-      --  of the context clause to ensure the correct processing.\n+      --  A special check for pragma Suppress_All, a very strange DEC pragma,\n+      --  strange because it comes at the end of the unit. If we have a pragma\n+      --  Suppress_All in the Pragmas_After of the current unit, then we insert\n+      --  a pragma Suppress (All_Checks) at the start of the context clause to\n+      --  ensure the correct processing.\n \n       declare\n          PA : constant List_Id := Pragmas_After (Aux_Decls_Node (N));\n@@ -12604,8 +12595,8 @@ package body Sem_Prag is\n       Hex : constant array (0 .. 15) of Character := \"0123456789abcdef\";\n \n       procedure Encode;\n-      --  Stores encoded value of character code CC. The encoding we\n-      --  use an underscore followed by four lower case hex digits.\n+      --  Stores encoded value of character code CC. The encoding we use an\n+      --  underscore followed by four lower case hex digits.\n \n       ------------\n       -- Encode --\n@@ -12627,10 +12618,10 @@ package body Sem_Prag is\n    --  Start of processing for Set_Encoded_Interface_Name\n \n    begin\n-      --  If first character is asterisk, this is a link name, and we\n-      --  leave it completely unmodified. We also ignore null strings\n-      --  (the latter case happens only in error cases) and no encoding\n-      --  should occur for Java or AAMP interface names.\n+      --  If first character is asterisk, this is a link name, and we leave it\n+      --  completely unmodified. We also ignore null strings (the latter case\n+      --  happens only in error cases) and no encoding should occur for Java or\n+      --  AAMP interface names.\n \n       if Len = 0\n         or else Get_String_Char (Str, 1) = Get_Char_Code ('*')"}, {"sha": "d96f697fcbca640a8e4c3bfa722fd55cdd0e8250", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b9865d065da548c5a3746638515229784f059b/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=b3b9865d065da548c5a3746638515229784f059b", "patch": "@@ -1610,10 +1610,37 @@ package body Sem_Warn is\n                   --  As always, it is possible to construct cases where the\n                   --  warning is wrong, that is why it is a warning!\n \n-                  declare\n+                  Potential_Unset_Reference : declare\n                      SR : Entity_Id;\n                      SE : constant Entity_Id := Scope (E);\n \n+                     function Within_Postcondition return Boolean;\n+                     --  Returns True iff N is within a Precondition\n+\n+                     --------------------------\n+                     -- Within_Postcondition --\n+                     --------------------------\n+\n+                     function Within_Postcondition return Boolean is\n+                        Nod : Node_Id;\n+\n+                     begin\n+                        Nod := Parent (N);\n+                        while Present (Nod) loop\n+                           if Nkind (Nod) = N_Pragma\n+                             and then Pragma_Name (Nod) = Name_Postcondition\n+                           then\n+                              return True;\n+                           end if;\n+\n+                           Nod := Parent (Nod);\n+                        end loop;\n+\n+                        return False;\n+                     end Within_Postcondition;\n+\n+                  --  Start of processing for Potential_Unset_Reference\n+\n                   begin\n                      SR := Current_Scope;\n                      while SR /= SE loop\n@@ -1732,26 +1759,33 @@ package body Sem_Warn is\n                         end Access_Type_Case;\n                      end if;\n \n-                     --  Here we definitely have a case for giving a warning\n-                     --  for a reference to an unset value. But we don't give\n-                     --  the warning now. Instead we set the Unset_Reference\n-                     --  field of the identifier involved. The reason for this\n-                     --  is that if we find the variable is never ever assigned\n-                     --  a value then that warning is more important and there\n-                     --  is no point in giving the reference warning.\n+                     --  One more check, don't bother if we are within a\n+                     --  postcondition pragma, since the expression occurs\n+                     --  in a place unrelated to the actual test.\n \n-                     --  If this is an identifier, set the field directly\n+                     if not Within_Postcondition then\n \n-                     if Nkind (N) = N_Identifier then\n-                        Set_Unset_Reference (E, N);\n+                        --  Here we definitely have a case for giving a warning\n+                        --  for a reference to an unset value. But we don't\n+                        --  give the warning now. Instead set Unset_Reference\n+                        --  in the identifier involved. The reason for this is\n+                        --  that if we find the variable is never ever assigned\n+                        --  a value then that warning is more important and\n+                        --  there is no point in giving the reference warning.\n \n-                     --  Otherwise it is an expanded name, so set the field of\n-                     --  the actual identifier for the reference.\n+                        --  If this is an identifier, set the field directly\n \n-                     else\n-                        Set_Unset_Reference (E, Selector_Name (N));\n+                        if Nkind (N) = N_Identifier then\n+                           Set_Unset_Reference (E, N);\n+\n+                        --  Otherwise it is an expanded name, so set the field\n+                        --  of the actual identifier for the reference.\n+\n+                        else\n+                           Set_Unset_Reference (E, Selector_Name (N));\n+                        end if;\n                      end if;\n-                  end;\n+                  end Potential_Unset_Reference;\n                end if;\n             end;\n "}]}