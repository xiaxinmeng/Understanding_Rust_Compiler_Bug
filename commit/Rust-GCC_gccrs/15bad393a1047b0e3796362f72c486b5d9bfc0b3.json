{"sha": "15bad393a1047b0e3796362f72c486b5d9bfc0b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTViYWQzOTNhMTA0N2IwZTM3OTYzNjJmNzJjNDg2YjVkOWJmYzBiMw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-07-01T04:27:09Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-07-01T04:27:09Z"}, "message": "expmed.c (expand_shift): Consider expanding LSHIFT_EXPR by a constant as a sequence of additions...\n\n\n\t* expmed.c (expand_shift): Consider expanding LSHIFT_EXPR by a\n\tconstant as a sequence of additions depending upon the rtx_costs.\n\t(synth_mult): Update the \"observed\" cost of a shift, based upon\n\tthe above optimization.\n\nFrom-SVN: r83956", "tree": {"sha": "a9c7e9bbd5c7b7753ecf1aed3dfa709751ef1a6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9c7e9bbd5c7b7753ecf1aed3dfa709751ef1a6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15bad393a1047b0e3796362f72c486b5d9bfc0b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15bad393a1047b0e3796362f72c486b5d9bfc0b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15bad393a1047b0e3796362f72c486b5d9bfc0b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15bad393a1047b0e3796362f72c486b5d9bfc0b3/comments", "author": null, "committer": null, "parents": [{"sha": "f8a57be8182804460dde7e7f28a681e26577fdae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8a57be8182804460dde7e7f28a681e26577fdae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8a57be8182804460dde7e7f28a681e26577fdae"}], "stats": {"total": 32, "additions": 31, "deletions": 1}, "files": [{"sha": "92a4d69b804a50bc3b82e9ecf14b6fbb39961c3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bad393a1047b0e3796362f72c486b5d9bfc0b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bad393a1047b0e3796362f72c486b5d9bfc0b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15bad393a1047b0e3796362f72c486b5d9bfc0b3", "patch": "@@ -1,3 +1,10 @@\n+2004-06-30  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* expmed.c (expand_shift): Consider expanding LSHIFT_EXPR by a\n+\tconstant as a sequence of additions depending upon the rtx_costs.\n+\t(synth_mult): Update the \"observed\" cost of a shift, based upon\n+\tthe above optimization.\n+\n 2004-06-28  Geoffrey Keating  <geoffk@apple.com>\n \t    Andreas Tobler  <a.tobler@schweiz.ch>\n "}, {"sha": "e95a62643fc3977fb2b091694d2b5f7c3ec3d824", "filename": "gcc/expmed.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15bad393a1047b0e3796362f72c486b5d9bfc0b3/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15bad393a1047b0e3796362f72c486b5d9bfc0b3/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=15bad393a1047b0e3796362f72c486b5d9bfc0b3", "patch": "@@ -2017,6 +2017,24 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n   if (op1 == const0_rtx)\n     return shifted;\n \n+  /* Check whether its cheaper to implement a left shift by a constant\n+     bit count by a sequence of additions.  */\n+  if (code == LSHIFT_EXPR\n+      && GET_CODE (op1) == CONST_INT\n+      && INTVAL (op1) > 0\n+      && INTVAL (op1) < GET_MODE_BITSIZE (mode)\n+      && shift_cost[mode][INTVAL (op1)] > INTVAL (op1) * add_cost[mode])\n+    {\n+      int i;\n+      for (i = 0; i < INTVAL (op1); i++)\n+\t{\n+\t  temp = force_reg (mode, shifted);\n+\t  shifted = expand_binop (mode, add_optab, temp, temp, NULL_RTX,\n+\t\t\t\t  unsignedp, OPTAB_LIB_WIDEN);\n+\t}\n+      return shifted;\n+    }\n+\n   for (try = 0; temp == 0 && try < 3; try++)\n     {\n       enum optab_methods methods;\n@@ -2242,7 +2260,12 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       if (m < maxm)\n \t{\n \t  q = t >> m;\n-\t  cost = shift_cost[mode][m];\n+\t  /* The function expand_shift will choose between a shift and\n+\t     a sequence of additions, so the observed cost is given as\n+\t     MIN (m * add_cost[mode], shift_cost[mode][m]).  */\n+\t  cost = m * add_cost[mode];\n+\t  if (shift_cost[mode][m] < cost)\n+\t    cost = shift_cost[mode][m];\n \t  synth_mult (alg_in, q, cost_limit - cost, mode);\n \n \t  cost += alg_in->cost;"}]}