{"sha": "d9e91ebb8183faa4073a76d731e7c022ef73566d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDllOTFlYmI4MTgzZmFhNDA3M2E3NmQ3MzFlN2MwMjJlZjczNTY2ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-01-10T15:44:16Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-01-10T15:44:16Z"}, "message": "re PR middle-end/84877 (Local stack copy of BLKmode parameter on the stack is not aligned when the requested alignment exceeds MAX_SUPPORTED_STACK_ALIGNMENT)\n\n\tPR middle-end/84877\n\tPR bootstrap/88450\n\t* function.c (assign_stack_local_1): Revert the 2018-11-21 changes.\n\t(assign_parm_setup_block): Do the argument slot realignment here\n\tinstead.\n\nFrom-SVN: r267812", "tree": {"sha": "448eeeea63f8ee118c13c37b49f4fad9e810dfdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/448eeeea63f8ee118c13c37b49f4fad9e810dfdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9e91ebb8183faa4073a76d731e7c022ef73566d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e91ebb8183faa4073a76d731e7c022ef73566d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9e91ebb8183faa4073a76d731e7c022ef73566d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e91ebb8183faa4073a76d731e7c022ef73566d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "174f1d264274d3f77133713a3853fc016ba527b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174f1d264274d3f77133713a3853fc016ba527b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174f1d264274d3f77133713a3853fc016ba527b4"}], "stats": {"total": 88, "additions": 31, "deletions": 57}, "files": [{"sha": "bf6d6824ef0db2f4b93396243e211c5df9385ee5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e91ebb8183faa4073a76d731e7c022ef73566d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e91ebb8183faa4073a76d731e7c022ef73566d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9e91ebb8183faa4073a76d731e7c022ef73566d", "patch": "@@ -1,3 +1,11 @@\n+2019-01-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/84877\n+\tPR bootstrap/88450\n+\t* function.c (assign_stack_local_1): Revert the 2018-11-21 changes.\n+\t(assign_parm_setup_block): Do the argument slot realignment here\n+\tinstead.\n+\n 2019-01-10  Stefan Agner  <stefan@agner.ch>\n \n \tPR target/88648"}, {"sha": "5260d733fca6aac45d27f02a73ca7cbe4b046d4c", "filename": "gcc/function.c", "status": "modified", "additions": 23, "deletions": 57, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e91ebb8183faa4073a76d731e7c022ef73566d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e91ebb8183faa4073a76d731e7c022ef73566d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d9e91ebb8183faa4073a76d731e7c022ef73566d", "patch": "@@ -377,7 +377,6 @@ assign_stack_local_1 (machine_mode mode, poly_int64 size,\n   poly_int64 bigend_correction = 0;\n   poly_int64 slot_offset = 0, old_frame_offset;\n   unsigned int alignment, alignment_in_bits;\n-  bool dynamic_align_addr = false;\n \n   if (align == 0)\n     {\n@@ -396,22 +395,14 @@ assign_stack_local_1 (machine_mode mode, poly_int64 size,\n \n   alignment_in_bits = alignment * BITS_PER_UNIT;\n \n+  /* Ignore alignment if it exceeds MAX_SUPPORTED_STACK_ALIGNMENT.  */\n   if (alignment_in_bits > MAX_SUPPORTED_STACK_ALIGNMENT)\n     {\n-      /* If the required alignment exceeds MAX_SUPPORTED_STACK_ALIGNMENT and\n-\t it is not OK to reduce it.  Align the slot dynamically.  */\n-      if (mode == BLKmode\n-\t  && (kind & ASLK_REDUCE_ALIGN) == 0\n-\t  && currently_expanding_to_rtl)\n-\tdynamic_align_addr = true;\n-      else\n-\t{\n-\t  alignment_in_bits = MAX_SUPPORTED_STACK_ALIGNMENT;\n-\t  alignment = MAX_SUPPORTED_STACK_ALIGNMENT / BITS_PER_UNIT;\n-\t}\n+      alignment_in_bits = MAX_SUPPORTED_STACK_ALIGNMENT;\n+      alignment = MAX_SUPPORTED_STACK_ALIGNMENT / BITS_PER_UNIT;\n     }\n \n-  if (SUPPORTS_STACK_ALIGNMENT && !dynamic_align_addr)\n+  if (SUPPORTS_STACK_ALIGNMENT)\n     {\n       if (crtl->stack_alignment_estimated < alignment_in_bits)\n \t{\n@@ -441,42 +432,10 @@ assign_stack_local_1 (machine_mode mode, poly_int64 size,\n \t}\n     }\n \n-  /* Handle overalignment here for parameter copy on the stack.\n-     Reserved enough space for it and dynamically align the address.\n-     No free frame_space is added here.  */\n-  if (dynamic_align_addr)\n-    {\n-      rtx allocsize = gen_int_mode (size, Pmode);\n-      get_dynamic_stack_size (&allocsize, 0, alignment_in_bits, NULL);\n-\n-      /* This is the size of space needed to accommodate required size of data\n-\t with given alignment.  */\n-      poly_int64 len = rtx_to_poly_int64 (allocsize);\n-      old_frame_offset = frame_offset;\n-\n-      if (FRAME_GROWS_DOWNWARD)\n-\t{\n-\t  frame_offset -= len;\n-\t  try_fit_stack_local (frame_offset, len, len,\n-\t\t\t       PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT,\n-\t\t\t       &slot_offset);\n-\t}\n-      else\n-\t{\n-\t  frame_offset += len;\n-\t  try_fit_stack_local (old_frame_offset, len, len,\n-\t\t\t       PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT,\n-\t\t\t       &slot_offset);\n-\t}\n-      goto found_space;\n-    }\n-  else\n-    {\n-      if (crtl->stack_alignment_needed < alignment_in_bits)\n-\tcrtl->stack_alignment_needed = alignment_in_bits;\n-      if (crtl->max_used_stack_slot_alignment < alignment_in_bits)\n-\tcrtl->max_used_stack_slot_alignment = alignment_in_bits;\n-    }\n+  if (crtl->stack_alignment_needed < alignment_in_bits)\n+    crtl->stack_alignment_needed = alignment_in_bits;\n+  if (crtl->max_used_stack_slot_alignment < alignment_in_bits)\n+    crtl->max_used_stack_slot_alignment = alignment_in_bits;\n \n   if (mode != BLKmode || maybe_ne (size, 0))\n     {\n@@ -563,12 +522,6 @@ assign_stack_local_1 (machine_mode mode, poly_int64 size,\n \t\t\t  (slot_offset + bigend_correction,\n \t\t\t   Pmode));\n \n-  if (dynamic_align_addr)\n-    {\n-      addr = align_dynamic_address (addr, alignment_in_bits);\n-      mark_reg_pointer (addr, alignment_in_bits);\n-    }\n-\n   x = gen_rtx_MEM (mode, addr);\n   set_mem_align (x, alignment_in_bits);\n   MEM_NOTRAP_P (x) = 1;\n@@ -2960,8 +2913,21 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n   if (stack_parm == 0)\n     {\n       SET_DECL_ALIGN (parm, MAX (DECL_ALIGN (parm), BITS_PER_WORD));\n-      stack_parm = assign_stack_local (BLKmode, size_stored,\n-\t\t\t\t       DECL_ALIGN (parm));\n+      if (DECL_ALIGN (parm) > MAX_SUPPORTED_STACK_ALIGNMENT)\n+\t{\n+\t  rtx allocsize = gen_int_mode (size, Pmode);\n+\t  get_dynamic_stack_size (&allocsize, 0, DECL_ALIGN (parm), NULL);\n+\t  stack_parm = assign_stack_local (BLKmode, UINTVAL (allocsize),\n+\t\t\t\t\t   MAX_SUPPORTED_STACK_ALIGNMENT);\n+\t  rtx addr = align_dynamic_address (XEXP (stack_parm, 0),\n+\t\t\t\t\t    DECL_ALIGN (parm));\n+\t  mark_reg_pointer (addr, DECL_ALIGN (parm));\n+\t  stack_parm = gen_rtx_MEM (GET_MODE (stack_parm), addr);\n+\t  MEM_NOTRAP_P (stack_parm) = 1;\n+\t}\n+      else\n+\tstack_parm = assign_stack_local (BLKmode, size_stored,\n+\t\t\t\t\t DECL_ALIGN (parm));\n       if (known_eq (GET_MODE_SIZE (GET_MODE (entry_parm)), size))\n \tPUT_MODE (stack_parm, GET_MODE (entry_parm));\n       set_mem_attributes (stack_parm, parm, 1);"}]}