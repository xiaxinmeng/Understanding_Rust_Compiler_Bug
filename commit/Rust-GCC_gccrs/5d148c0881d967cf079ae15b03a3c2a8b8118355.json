{"sha": "5d148c0881d967cf079ae15b03a3c2a8b8118355", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQxNDhjMDg4MWQ5NjdjZjA3OWFlMTViMDNhM2MyYThiODExODM1NQ==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-05-07T05:53:07Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-05-07T05:53:07Z"}, "message": "re PR fortran/31399 (Wrong code for do loop with large interation count)\n\n\tPR fortran/31399\n\n\t* trans-stmt.c (gfc_trans_do): Handle large loop counts.\n\n\t* gfortran.dg/do_3.F90: New test.\n\nFrom-SVN: r124496", "tree": {"sha": "a052b218e3380fbb0358f79542de2fc87ef76803", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a052b218e3380fbb0358f79542de2fc87ef76803"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d148c0881d967cf079ae15b03a3c2a8b8118355", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d148c0881d967cf079ae15b03a3c2a8b8118355", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d148c0881d967cf079ae15b03a3c2a8b8118355", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d148c0881d967cf079ae15b03a3c2a8b8118355/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f8e3bd7bd87055806b1180fc5a5b4668b0c28cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f8e3bd7bd87055806b1180fc5a5b4668b0c28cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f8e3bd7bd87055806b1180fc5a5b4668b0c28cd"}], "stats": {"total": 209, "additions": 175, "deletions": 34}, "files": [{"sha": "3831e7443e4dfa80b610338509c6db934848b508", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d148c0881d967cf079ae15b03a3c2a8b8118355/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d148c0881d967cf079ae15b03a3c2a8b8118355/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5d148c0881d967cf079ae15b03a3c2a8b8118355", "patch": "@@ -1,3 +1,8 @@\n+2007-05-07  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/31399\n+\t* trans-stmt.c (gfc_trans_do): Handle large loop counts.\n+\n 2007-05-07  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/31764"}, {"sha": "92462cbad7594ab36d075b80770593fcca546921", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 55, "deletions": 34, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d148c0881d967cf079ae15b03a3c2a8b8118355/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d148c0881d967cf079ae15b03a3c2a8b8118355/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=5d148c0881d967cf079ae15b03a3c2a8b8118355", "patch": "@@ -809,22 +809,22 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n    to:\n \n    [evaluate loop bounds and step]\n-   count = (to + step - from) / step;\n+   empty = (step > 0 ? to < from : to > from);\n+   countm1 = (to - from) / step;\n    dovar = from;\n+   if (empty) goto exit_label;\n    for (;;)\n      {\n        body;\n cycle_label:\n        dovar += step\n-       count--;\n-       if (count <=0) goto exit_label;\n+       countm1--;\n+       if (countm1 ==0) goto exit_label;\n      }\n exit_label:\n \n-   TODO: Large loop counts\n-   The code above assumes the loop count fits into a signed integer kind,\n-   i.e. Does not work for loop counts > 2^31 for integer(kind=4) variables\n-   We must support the full range.  */\n+   countm1 is an unsigned integer.  It is equal to the loop count minus one,\n+   because the loop count itself can overflow.  */\n \n tree\n gfc_trans_do (gfc_code * code)\n@@ -834,13 +834,15 @@ gfc_trans_do (gfc_code * code)\n   tree from;\n   tree to;\n   tree step;\n-  tree count;\n-  tree count_one;\n+  tree empty;\n+  tree countm1;\n   tree type;\n+  tree utype;\n   tree cond;\n   tree cycle_label;\n   tree exit_label;\n   tree tmp;\n+  tree pos_step;\n   stmtblock_t block;\n   stmtblock_t body;\n \n@@ -874,48 +876,59 @@ gfc_trans_do (gfc_code * code)\n \t|| tree_int_cst_equal (step, integer_minus_one_node)))\n     return gfc_trans_simple_do (code, &block, dovar, from, to, step);\n       \n-  /* Initialize loop count. This code is executed before we enter the\n-     loop body. We generate: count = (to + step - from) / step.  */\n+  /* We need a special check for empty loops:\n+     empty = (step > 0 ? to < from : to > from);  */\n+  pos_step = fold_build2 (GT_EXPR, boolean_type_node, step,\n+\t\t\t  fold_convert (type, integer_zero_node));\n+  empty = fold_build3 (COND_EXPR, boolean_type_node, pos_step,\n+\t\t       fold_build2 (LT_EXPR, boolean_type_node, to, from),\n+\t\t       fold_build2 (GT_EXPR, boolean_type_node, to, from));\n \n-  tmp = fold_build2 (MINUS_EXPR, type, step, from);\n-  tmp = fold_build2 (PLUS_EXPR, type, to, tmp);\n+  /* Initialize loop count. This code is executed before we enter the\n+     loop body. We generate: countm1 = abs(to - from) / abs(step).  */\n   if (TREE_CODE (type) == INTEGER_TYPE)\n     {\n-      tmp = fold_build2 (TRUNC_DIV_EXPR, type, tmp, step);\n-      count = gfc_create_var (type, \"count\");\n+      tree ustep;\n+\n+      utype = gfc_unsigned_type (type);\n+\n+      /* tmp = abs(to - from) / abs(step) */\n+      ustep = fold_convert (utype, fold_build1 (ABS_EXPR, type, step));\n+      tmp = fold_build3 (COND_EXPR, type, pos_step,\n+\t\t\t fold_build2 (MINUS_EXPR, type, to, from),\n+\t\t\t fold_build2 (MINUS_EXPR, type, from, to));\n+      tmp = fold_build2 (TRUNC_DIV_EXPR, utype, fold_convert (utype, tmp),\n+\t\t\t ustep);\n     }\n   else\n     {\n       /* TODO: We could use the same width as the real type.\n \t This would probably cause more problems that it solves\n \t when we implement \"long double\" types.  */\n+      utype = gfc_unsigned_type (gfc_array_index_type);\n+      tmp = fold_build2 (MINUS_EXPR, type, to, from);\n       tmp = fold_build2 (RDIV_EXPR, type, tmp, step);\n-      tmp = fold_build1 (FIX_TRUNC_EXPR, gfc_array_index_type, tmp);\n-      count = gfc_create_var (gfc_array_index_type, \"count\");\n+      tmp = fold_build1 (FIX_TRUNC_EXPR, utype, tmp);\n     }\n-  gfc_add_modify_expr (&block, count, tmp);\n+  countm1 = gfc_create_var (utype, \"countm1\");\n+  gfc_add_modify_expr (&block, countm1, tmp);\n \n-  count_one = build_int_cst (TREE_TYPE (count), 1);\n+  /* Cycle and exit statements are implemented with gotos.  */\n+  cycle_label = gfc_build_label_decl (NULL_TREE);\n+  exit_label = gfc_build_label_decl (NULL_TREE);\n+  TREE_USED (exit_label) = 1;\n \n   /* Initialize the DO variable: dovar = from.  */\n   gfc_add_modify_expr (&block, dovar, from);\n \n+  /* If the loop is empty, go directly to the exit label.  */\n+  tmp = fold_build3 (COND_EXPR, void_type_node, empty,\n+\t\t     build1_v (GOTO_EXPR, exit_label), build_empty_stmt ());\n+  gfc_add_expr_to_block (&block, tmp);\n+\n   /* Loop body.  */\n   gfc_start_block (&body);\n \n-  /* Cycle and exit statements are implemented with gotos.  */\n-  cycle_label = gfc_build_label_decl (NULL_TREE);\n-  exit_label = gfc_build_label_decl (NULL_TREE);\n-\n-  /* Start with the loop condition.  Loop until count <= 0.  */\n-  cond = fold_build2 (LE_EXPR, boolean_type_node, count,\n-\t\t      build_int_cst (TREE_TYPE (count), 0));\n-  tmp = build1_v (GOTO_EXPR, exit_label);\n-  TREE_USED (exit_label) = 1;\n-  tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t     cond, tmp, build_empty_stmt ());\n-  gfc_add_expr_to_block (&body, tmp);\n-\n   /* Put these labels where they can be found later. We put the\n      labels in a TREE_LIST node (because TREE_CHAIN is already\n      used). cycle_label goes in TREE_PURPOSE (backend_decl), exit\n@@ -934,13 +947,21 @@ gfc_trans_do (gfc_code * code)\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n+  /* End with the loop condition.  Loop until countm1 == 0.  */\n+  cond = fold_build2 (EQ_EXPR, boolean_type_node, countm1,\n+\t\t      build_int_cst (utype, 0));\n+  tmp = build1_v (GOTO_EXPR, exit_label);\n+  tmp = fold_build3 (COND_EXPR, void_type_node,\n+\t\t     cond, tmp, build_empty_stmt ());\n+  gfc_add_expr_to_block (&body, tmp);\n+\n   /* Increment the loop variable.  */\n   tmp = build2 (PLUS_EXPR, type, dovar, step);\n   gfc_add_modify_expr (&body, dovar, tmp);\n \n   /* Decrement the loop count.  */\n-  tmp = build2 (MINUS_EXPR, TREE_TYPE (count), count, count_one);\n-  gfc_add_modify_expr (&body, count, tmp);\n+  tmp = build2 (MINUS_EXPR, utype, countm1, build_int_cst (utype, 1));\n+  gfc_add_modify_expr (&body, countm1, tmp);\n \n   /* End of loop body.  */\n   tmp = gfc_finish_block (&body);"}, {"sha": "099cbe5680a8b927fa5c6f1702be04d08dcf88e6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d148c0881d967cf079ae15b03a3c2a8b8118355/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d148c0881d967cf079ae15b03a3c2a8b8118355/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d148c0881d967cf079ae15b03a3c2a8b8118355", "patch": "@@ -1,3 +1,8 @@\n+2007-05-07  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/31399\n+\t* gfortran.dg/do_3.F90: New test.\n+\n 2007-05-07  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/31764"}, {"sha": "1e2e238bf7ed523fc7da1e57ae8786bc56e6e3c8", "filename": "gcc/testsuite/gfortran.dg/do_3.F90", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d148c0881d967cf079ae15b03a3c2a8b8118355/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_3.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d148c0881d967cf079ae15b03a3c2a8b8118355/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_3.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_3.F90?ref=5d148c0881d967cf079ae15b03a3c2a8b8118355", "patch": "@@ -0,0 +1,110 @@\n+! { dg-do run }\n+! { dg-options \"-std=legacy -ffree-line-length-none\" }\n+program test\n+  integer :: count\n+  integer :: i\n+  integer(kind=1) :: i1\n+  real :: r\n+\n+#define TEST_LOOP(var,from,to,step,total,test) \\\n+  count = 0 ; do var = from, to, step ; count = count + 1 ; end do ; \\\n+  if (count /= total) call abort ; \\\n+  if (test (from, to, step) /= total) call abort\n+\n+  ! Integer loops\n+  TEST_LOOP(i, 0, 0, 1, 1, test_i)\n+  TEST_LOOP(i, 0, 0, 2, 1, test_i)\n+  TEST_LOOP(i, 0, 0, -1, 1, test_i)\n+  TEST_LOOP(i, 0, 0, -2, 1, test_i)\n+\n+  TEST_LOOP(i, 0, 1, 1, 2, test_i)\n+  TEST_LOOP(i, 0, 1, 2, 1, test_i)\n+  TEST_LOOP(i, 0, 1, 3, 1, test_i)\n+  TEST_LOOP(i, 0, 1, huge(0), 1, test_i)\n+  TEST_LOOP(i, 0, 1, -1, 0, test_i)\n+  TEST_LOOP(i, 0, 1, -2, 0, test_i)\n+  TEST_LOOP(i, 0, 1, -3, 0, test_i)\n+  TEST_LOOP(i, 0, 1, -huge(0), 0, test_i)\n+  TEST_LOOP(i, 0, 1, -huge(0)-1, 0, test_i)\n+\n+  TEST_LOOP(i, 1, 0, 1, 0, test_i)\n+  TEST_LOOP(i, 1, 0, 2, 0, test_i)\n+  TEST_LOOP(i, 1, 0, 3, 0, test_i)\n+  TEST_LOOP(i, 1, 0, huge(0), 0, test_i)\n+  TEST_LOOP(i, 1, 0, -1, 2, test_i)\n+  TEST_LOOP(i, 1, 0, -2, 1, test_i)\n+  TEST_LOOP(i, 1, 0, -3, 1, test_i)\n+  TEST_LOOP(i, 1, 0, -huge(0), 1, test_i)\n+  TEST_LOOP(i, 1, 0, -huge(0)-1, 1, test_i)\n+\n+  TEST_LOOP(i, 0, 17, 1, 18, test_i)\n+  TEST_LOOP(i, 0, 17, 2, 9, test_i)\n+  TEST_LOOP(i, 0, 17, 3, 6, test_i)\n+  TEST_LOOP(i, 0, 17, 4, 5, test_i)\n+  TEST_LOOP(i, 0, 17, 5, 4, test_i)\n+  TEST_LOOP(i, 17, 0, -1, 18, test_i)\n+  TEST_LOOP(i, 17, 0, -2, 9, test_i)\n+  TEST_LOOP(i, 17, 0, -3, 6, test_i)\n+  TEST_LOOP(i, 17, 0, -4, 5, test_i)\n+  TEST_LOOP(i, 17, 0, -5, 4, test_i)\n+\n+  TEST_LOOP(i1, -huge(i1)-1_1, huge(i1), 1_1, int(huge(i1))*2+2, test_i1)\n+  TEST_LOOP(i1, -huge(i1)-1_1, huge(i1), 2_1, int(huge(i1))+1, test_i1)\n+  TEST_LOOP(i1, -huge(i1)-1_1, huge(i1), huge(i1), 3, test_i1)\n+\n+  TEST_LOOP(i1, huge(i1), -huge(i1)-1_1, -1_1, int(huge(i1))*2+2, test_i1)\n+  TEST_LOOP(i1, huge(i1), -huge(i1)-1_1, -2_1, int(huge(i1))+1, test_i1)\n+  TEST_LOOP(i1, huge(i1), -huge(i1)-1_1, -huge(i1), 3, test_i1)\n+  TEST_LOOP(i1, huge(i1), -huge(i1)-1_1, -huge(i1)-1_1, 2, test_i1)\n+\n+  TEST_LOOP(i1, -2_1, 3_1, huge(i1), 1, test_i1)\n+  TEST_LOOP(i1, -2_1, 3_1, -huge(i1), 0, test_i1)\n+  TEST_LOOP(i1, 2_1, -3_1, -huge(i1), 1, test_i1)\n+  TEST_LOOP(i1, 2_1, -3_1, huge(i1), 0, test_i1)\n+\n+  ! Real loops\n+  TEST_LOOP(r, 0.0, 1.0, 0.11, 1 + int(1.0/0.11), test_r)\n+  TEST_LOOP(r, 0.0, 1.0, -0.11, 0, test_r)\n+  TEST_LOOP(r, 0.0, -1.0, 0.11, 0, test_r)\n+  TEST_LOOP(r, 0.0, -1.0, -0.11, 1 + int(1.0/0.11), test_r)\n+  TEST_LOOP(r, 0.0, 0.0, 0.11, 1, test_r)\n+  TEST_LOOP(r, 0.0, 0.0, -0.11, 1, test_r)\n+\n+#undef TEST_LOOP\n+\n+contains\n+\n+  function test_i1 (from, to, step) result(res)\n+    integer(kind=1), intent(in) :: from, to, step\n+    integer(kind=1) :: i\n+    integer :: res\n+\n+    res = 0\n+    do i = from, to, step\n+      res = res + 1\n+    end do\n+  end function test_i1\n+\n+  function test_i (from, to, step) result(res)\n+    integer, intent(in) :: from, to, step\n+    integer :: i\n+    integer :: res\n+\n+    res = 0\n+    do i = from, to, step\n+      res = res + 1\n+    end do\n+  end function test_i\n+\n+  function test_r (from, to, step) result(res)\n+    real, intent(in) :: from, to, step\n+    real :: i\n+    integer :: res\n+\n+    res = 0\n+    do i = from, to, step\n+      res = res + 1\n+    end do\n+  end function test_r\n+\n+end program test"}]}