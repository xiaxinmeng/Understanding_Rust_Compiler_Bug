{"sha": "4187be442f5baa4fc3d6a3f0077fca0d46877b6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE4N2JlNDQyZjViYWE0ZmMzZDZhM2YwMDc3ZmNhMGQ0Njg3N2I2ZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:14:59Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:14:59Z"}, "message": "Add more iterator utilities\n\nThis patch adds some more iterator helper classes.  They really fall\ninto two groups, but there didn't seem much value in separating them:\n\n- A later patch has a class hierarchy of the form:\n\n     Base\n      +- Derived1\n      +- Derived2\n\n  A class wants to store an array A1 of Derived1 pointers and an\n  array A2 of Derived2 pointers.  However, for compactness reasons,\n  it was convenient to have a single array of Base pointers,\n  with A1 and A2 being slices of this array.  This reduces the\n  overhead from two pointers and two ints (3 LP64 words) to one\n  pointer and two ints (2 LP64 words).\n\n  But consumers of the class shouldn't be aware of this: they should\n  see A1 as containing Derived1 pointers rather than Base pointers\n  and A2 as containing Derived2 pointers rather than Base pointers.\n  This patch adds derived_iterator and const_derived_container\n  classes to support this use case.\n\n- A later patch also adds various linked lists.  This patch adds\n  wrapper_iterator and list_iterator classes to make it easier\n  to create iterators for these linked lists.  For example:\n\n    // Iterators for lists of definitions.\n    using def_iterator = list_iterator<def_info, &def_info::next_def>;\n    using reverse_def_iterator\n      = list_iterator<def_info, &def_info::prev_def>;\n\n  This in turn makes it possible to use range-based for loops\n  on the lists.\n\nThe patch just adds the things that the later patches need; it doesn't\ntry to make the classes as functionally complete as possible.  I think\nwe should add extra functionality when needed rather than ahead of time.\n\ngcc/\n\t* iterator-utils.h (derived_iterator): New class.\n\t(const_derived_container, wrapper_iterator): Likewise.\n\t(list_iterator): Likewise.", "tree": {"sha": "0ebb57c97944b99a13c9d9b2b9984b98beaeb057", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ebb57c97944b99a13c9d9b2b9984b98beaeb057"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4187be442f5baa4fc3d6a3f0077fca0d46877b6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4187be442f5baa4fc3d6a3f0077fca0d46877b6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4187be442f5baa4fc3d6a3f0077fca0d46877b6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4187be442f5baa4fc3d6a3f0077fca0d46877b6e/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "900846cda693e199f4ebafd99af72445c3016629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/900846cda693e199f4ebafd99af72445c3016629", "html_url": "https://github.com/Rust-GCC/gccrs/commit/900846cda693e199f4ebafd99af72445c3016629"}], "stats": {"total": 159, "additions": 159, "deletions": 0}, "files": [{"sha": "22cc1a545ef6063c2afbaba75c53fb35675d557b", "filename": "gcc/iterator-utils.h", "status": "modified", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4187be442f5baa4fc3d6a3f0077fca0d46877b6e/gcc%2Fiterator-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4187be442f5baa4fc3d6a3f0077fca0d46877b6e/gcc%2Fiterator-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fiterator-utils.h?ref=4187be442f5baa4fc3d6a3f0077fca0d46877b6e", "patch": "@@ -41,4 +41,163 @@ struct iterator_range\n   T m_end;\n };\n \n+// Provide an iterator like BaseIT, except that it yields values of type T,\n+// which is derived from the type that BaseIT normally yields.\n+//\n+// The class doesn't inherit from BaseIT for two reasons:\n+// - using inheritance would stop the class working with plain pointers\n+// - not using inheritance increases type-safety for writable iterators\n+//\n+// Constructing this class from a BaseIT involves an assertion that all\n+// contents really do have type T.  The constructor is therefore explicit.\n+template<typename T, typename BaseIT>\n+class derived_iterator\n+{\n+public:\n+  using value_type = T;\n+\n+  derived_iterator () = default;\n+\n+  template<typename... Ts>\n+  explicit derived_iterator (Ts... args)\n+    : m_base (std::forward<Ts> (args)...) {}\n+\n+  derived_iterator &operator++ () { ++m_base; return *this; }\n+  derived_iterator operator++ (int);\n+\n+  T operator* () const { return static_cast<T> (*m_base); }\n+  T *operator-> () const { return static_cast<T *> (m_base.operator-> ()); }\n+\n+  bool operator== (const derived_iterator &other) const;\n+  bool operator!= (const derived_iterator &other) const;\n+\n+protected:\n+  BaseIT m_base;\n+};\n+\n+template<typename T, typename BaseIT>\n+inline derived_iterator<T, BaseIT>\n+derived_iterator<T, BaseIT>::operator++ (int)\n+{\n+  derived_iterator ret = *this;\n+  ++m_base;\n+  return ret;\n+}\n+\n+template<typename T, typename BaseIT>\n+inline bool\n+derived_iterator<T, BaseIT>::operator== (const derived_iterator &other) const\n+{\n+  return m_base == other.m_base;\n+}\n+\n+template<typename T, typename BaseIT>\n+inline bool\n+derived_iterator<T, BaseIT>::operator!= (const derived_iterator &other) const\n+{\n+  return m_base != other.m_base;\n+}\n+\n+// Provide a constant view of a BaseCT in which every value is known to\n+// have type T, which is derived from the type that BaseCT normally presents.\n+//\n+// Constructing this class from a BaseCT involves an assertion that all\n+// contents really do have type T.  The constructor is therefore explicit.\n+template<typename T, typename BaseCT>\n+class const_derived_container : public BaseCT\n+{\n+  using base_const_iterator = typename BaseCT::const_iterator;\n+\n+public:\n+  using value_type = T;\n+  using const_iterator = derived_iterator<T, base_const_iterator>;\n+\n+  const_derived_container () = default;\n+\n+  template<typename... Ts>\n+  explicit const_derived_container (Ts... args)\n+    : BaseCT (std::forward<Ts> (args)...) {}\n+\n+  const_iterator begin () const { return const_iterator (BaseCT::begin ()); }\n+  const_iterator end () const { return const_iterator (BaseCT::end ()); }\n+\n+  T front () const { return static_cast<T> (BaseCT::front ()); }\n+  T back () const { return static_cast<T> (BaseCT::back ()); }\n+  T operator[] (unsigned int i) const;\n+};\n+\n+template<typename T, typename BaseCT>\n+inline T\n+const_derived_container<T, BaseCT>::operator[] (unsigned int i) const\n+{\n+  return static_cast<T> (BaseCT::operator[] (i));\n+}\n+\n+// A base class for iterators whose contents consist of a StoredT and that\n+// when dereferenced yield those StoredT contents as a T.  Derived classes\n+// should implement at least operator++ or operator--.\n+template<typename T, typename StoredT = T>\n+class wrapper_iterator\n+{\n+public:\n+  using value_type = T;\n+\n+  wrapper_iterator () = default;\n+\n+  template<typename... Ts>\n+  wrapper_iterator (Ts... args) : m_contents (std::forward<Ts> (args)...) {}\n+\n+  T operator* () const { return static_cast<T> (m_contents); }\n+  bool operator== (const wrapper_iterator &) const;\n+  bool operator!= (const wrapper_iterator &) const;\n+\n+protected:\n+  StoredT m_contents;\n+};\n+\n+template<typename T, typename StoredT>\n+inline bool\n+wrapper_iterator<T, StoredT>::operator== (const wrapper_iterator &other) const\n+{\n+  return m_contents == other.m_contents;\n+}\n+\n+template<typename T, typename StoredT>\n+inline bool\n+wrapper_iterator<T, StoredT>::operator!= (const wrapper_iterator &other) const\n+{\n+  return m_contents != other.m_contents;\n+}\n+\n+// A forward iterator for a linked list whose nodes are referenced using\n+// type T.  Given a node \"T N\", the next element is given by (N->*Next) ().\n+template<typename T, T *(T::*Next) () const>\n+class list_iterator : public wrapper_iterator<T *>\n+{\n+private:\n+  using parent = wrapper_iterator<T *>;\n+\n+public:\n+  using parent::parent;\n+  list_iterator &operator++ ();\n+  list_iterator operator++ (int);\n+};\n+\n+template<typename T, T *(T::*Next) () const>\n+inline list_iterator<T, Next> &\n+list_iterator<T, Next>::operator++ ()\n+{\n+  this->m_contents = (this->m_contents->*Next) ();\n+  return *this;\n+}\n+\n+template<typename T, T *(T::*Next) () const>\n+inline list_iterator<T, Next>\n+list_iterator<T, Next>::operator++ (int)\n+{\n+  list_iterator ret = *this;\n+  this->m_contents = (this->m_contents->*Next) ();\n+  return ret;\n+}\n+\n #endif"}]}