{"sha": "f4a5629fb7f6274433005c255bc9baf113856a5d", "node_id": "C_kwDOANBUbNoAKGY0YTU2MjlmYjdmNjI3NDQzMzAwNWMyNTViYzliYWYxMTM4NTZhNWQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-06-29T15:14:33Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-06-29T15:35:52Z"}, "message": "Fix name resolution using self paths and nested functions\n\nWhen we resolve paths the code was looking at the crate hierarchy first\nin the algorithm this leads to a bug where in rust you can have a function\nnamed foo at the item level then declare a nested function with the same\nname. So when we wanted to call the nested function the code was defaulting\nto the toplevel first resulting in bad name resolution.\n\nThis patch updates the code to look at the scope first, then look at the\nmodule scope hierarchy. It finally adds the error handling in a nice single\npath at the end. We can only error out if its not the first segment since\npaths such as associated types like Self::foo we cannot resolve foo as this\nrequires the type-resolution system to determine the projection.\n\nFixes #1231", "tree": {"sha": "b7c7d86aa682e9dc107e5743ccdc845d97d6ede6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7c7d86aa682e9dc107e5743ccdc845d97d6ede6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4a5629fb7f6274433005c255bc9baf113856a5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a5629fb7f6274433005c255bc9baf113856a5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4a5629fb7f6274433005c255bc9baf113856a5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a5629fb7f6274433005c255bc9baf113856a5d/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18648e7b9f54c0cec4d4d865ff42b453b8de7101", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18648e7b9f54c0cec4d4d865ff42b453b8de7101", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18648e7b9f54c0cec4d4d865ff42b453b8de7101"}], "stats": {"total": 206, "additions": 124, "deletions": 82}, "files": [{"sha": "9bd836a5872cc540259aac8f0a78a3bf7832078d", "filename": "gcc/rust/resolve/rust-ast-resolve-path.cc", "status": "modified", "additions": 46, "deletions": 40, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4a5629fb7f6274433005c255bc9baf113856a5d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4a5629fb7f6274433005c255bc9baf113856a5d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc?ref=f4a5629fb7f6274433005c255bc9baf113856a5d", "patch": "@@ -130,7 +130,43 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n       //\n       // can only use old resolution when previous segment is unkown\n \n-      if (previous_resolved_node_id == module_scope_id)\n+      if (is_first_segment)\n+\t{\n+\t  // name scope first\n+\t  NodeId resolved_node = UNKNOWN_NODEID;\n+\t  const CanonicalPath path\n+\t    = CanonicalPath::new_seg (segment.get_node_id (),\n+\t\t\t\t      ident_seg.as_string ());\n+\t  if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t      resolved_node_id = resolved_node;\n+\t    }\n+\t  // check the type scope\n+\t  else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_type (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t      resolved_node_id = resolved_node;\n+\t    }\n+\t  else if (segment.is_lower_self_seg ())\n+\t    {\n+\t      module_scope_id = crate_scope_id;\n+\t      previous_resolved_node_id = module_scope_id;\n+\t      resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t      module_scope_id);\n+\t      continue;\n+\t    }\n+\t  else\n+\t    {\n+\t      // no error handling here since we might be able to resolve via\n+\t      // the module hierarchy and handle errors at the end\n+\t    }\n+\t}\n+\n+      if (resolved_node_id == UNKNOWN_NODEID\n+\t  && previous_resolved_node_id == module_scope_id)\n \t{\n \t  Optional<CanonicalPath &> resolved_child\n \t    = mappings->lookup_module_child (module_scope_id,\n@@ -162,52 +198,22 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n \t    }\n \t}\n \n-      if (resolved_node_id == UNKNOWN_NODEID && is_first_segment)\n-\t{\n-\t  // name scope first\n-\t  NodeId resolved_node = UNKNOWN_NODEID;\n-\t  const CanonicalPath path\n-\t    = CanonicalPath::new_seg (segment.get_node_id (),\n-\t\t\t\t      ident_seg.as_string ());\n-\t  if (resolver->get_name_scope ().lookup (path, &resolved_node))\n-\t    {\n-\t      resolver->insert_resolved_name (segment.get_node_id (),\n-\t\t\t\t\t      resolved_node);\n-\t    }\n-\t  // check the type scope\n-\t  else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n-\t    {\n-\t      resolver->insert_resolved_type (segment.get_node_id (),\n-\t\t\t\t\t      resolved_node);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (segment.is_lower_self_seg ())\n-\t\t{\n-\t\t  module_scope_id = crate_scope_id;\n-\t\t  previous_resolved_node_id = module_scope_id;\n-\t\t  resolver->insert_resolved_name (segment.get_node_id (),\n-\t\t\t\t\t\t  module_scope_id);\n-\t\t  continue;\n-\t\t}\n-\n-\t      rust_error_at (segment.get_locus (),\n-\t\t\t     \"Cannot find path %<%s%> in this scope\",\n-\t\t\t     segment.as_string ().c_str ());\n-\t      return;\n-\t    }\n-\n-\t  resolved_node_id = resolved_node;\n-\t}\n-\n-      if (resolved_node_id != UNKNOWN_NODEID)\n+      bool did_resolve_segment = resolved_node_id != UNKNOWN_NODEID;\n+      if (did_resolve_segment)\n \t{\n \t  if (mappings->node_is_module (resolved_node_id))\n \t    {\n \t      module_scope_id = resolved_node_id;\n \t    }\n \t  previous_resolved_node_id = resolved_node_id;\n \t}\n+      else if (is_first_segment)\n+\t{\n+\t  rust_error_at (segment.get_locus (),\n+\t\t\t \"Cannot find path %<%s%> in this scope\",\n+\t\t\t segment.as_string ().c_str ());\n+\t  return;\n+\t}\n     }\n \n   resolved_node = resolved_node_id;"}, {"sha": "d444e3758cd8d97ab8c87235426edfcfd99e53ca", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4a5629fb7f6274433005c255bc9baf113856a5d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4a5629fb7f6274433005c255bc9baf113856a5d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=f4a5629fb7f6274433005c255bc9baf113856a5d", "patch": "@@ -155,8 +155,39 @@ ResolveRelativeTypePath::go (AST::TypePath &path, NodeId &resolved_node_id)\n \t  break;\n \t}\n \n-      if (previous_resolved_node_id == module_scope_id\n-\t  && path.get_segments ().size () > 1)\n+      if (is_first_segment)\n+\t{\n+\t  // name scope first\n+\t  NodeId resolved_node = UNKNOWN_NODEID;\n+\t  const CanonicalPath path\n+\t    = CanonicalPath::new_seg (segment->get_node_id (),\n+\t\t\t\t      ident_seg.as_string ());\n+\t  if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_type (segment->get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t      resolved_node_id = resolved_node;\n+\t    }\n+\t  else if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_name (segment->get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t      resolved_node_id = resolved_node;\n+\t    }\n+\t  else if (segment->is_lower_self_seg ())\n+\t    {\n+\t      // what is the current crate scope node id?\n+\t      module_scope_id = crate_scope_id;\n+\t      previous_resolved_node_id = module_scope_id;\n+\t      resolver->insert_resolved_name (segment->get_node_id (),\n+\t\t\t\t\t      module_scope_id);\n+\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (resolved_node_id == UNKNOWN_NODEID\n+\t  && previous_resolved_node_id == module_scope_id)\n \t{\n \t  Optional<CanonicalPath &> resolved_child\n \t    = mappings->lookup_module_child (module_scope_id,\n@@ -188,53 +219,22 @@ ResolveRelativeTypePath::go (AST::TypePath &path, NodeId &resolved_node_id)\n \t    }\n \t}\n \n-      if (resolved_node_id == UNKNOWN_NODEID && is_first_segment)\n-\t{\n-\t  // name scope first\n-\t  NodeId resolved_node = UNKNOWN_NODEID;\n-\t  const CanonicalPath path\n-\t    = CanonicalPath::new_seg (segment->get_node_id (),\n-\t\t\t\t      ident_seg.as_string ());\n-\t  if (resolver->get_type_scope ().lookup (path, &resolved_node))\n-\t    {\n-\t      resolver->insert_resolved_type (segment->get_node_id (),\n-\t\t\t\t\t      resolved_node);\n-\t    }\n-\t  else if (resolver->get_name_scope ().lookup (path, &resolved_node))\n-\t    {\n-\t      resolver->insert_resolved_name (segment->get_node_id (),\n-\t\t\t\t\t      resolved_node);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (segment->is_lower_self_seg ())\n-\t\t{\n-\t\t  // what is the current crate scope node id?\n-\t\t  module_scope_id = crate_scope_id;\n-\t\t  previous_resolved_node_id = module_scope_id;\n-\t\t  resolver->insert_resolved_name (segment->get_node_id (),\n-\t\t\t\t\t\t  module_scope_id);\n-\n-\t\t  continue;\n-\t\t}\n-\n-\t      rust_error_at (segment->get_locus (),\n-\t\t\t     \"failed to resolve TypePath: %s in this scope\",\n-\t\t\t     segment->as_string ().c_str ());\n-\t      return false;\n-\t    }\n-\n-\t  resolved_node_id = resolved_node;\n-\t}\n-\n-      if (resolved_node_id != UNKNOWN_NODEID)\n+      bool did_resolve_segment = resolved_node_id != UNKNOWN_NODEID;\n+      if (did_resolve_segment)\n \t{\n \t  if (mappings->node_is_module (resolved_node_id))\n \t    {\n \t      module_scope_id = resolved_node_id;\n \t    }\n \t  previous_resolved_node_id = resolved_node_id;\n \t}\n+      else if (is_first_segment)\n+\t{\n+\t  rust_error_at (segment->get_locus (),\n+\t\t\t \"failed to resolve TypePath: %s in this scope\",\n+\t\t\t segment->as_string ().c_str ());\n+\t  return false;\n+\t}\n     }\n \n   if (resolved_node_id != UNKNOWN_NODEID)"}, {"sha": "970e86f917a28d35e4ccb3521be7e327d86f73b0", "filename": "gcc/testsuite/rust/execute/torture/issue-1231.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4a5629fb7f6274433005c255bc9baf113856a5d/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1231.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4a5629fb7f6274433005c255bc9baf113856a5d/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1231.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1231.rs?ref=f4a5629fb7f6274433005c255bc9baf113856a5d", "patch": "@@ -0,0 +1,36 @@\n+// { dg-additional-options \"-w\" }\n+// { dg-output \"outer\\ninner\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn machin() {\n+    unsafe {\n+        let a = \"outer\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, 123);\n+    }\n+}\n+\n+fn bidule() {\n+    fn machin() {\n+        unsafe {\n+            let a = \"inner\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, 123);\n+        }\n+    }\n+\n+    self::machin();\n+    machin();\n+}\n+\n+fn main() -> i32 {\n+    bidule();\n+\n+    0\n+}"}]}