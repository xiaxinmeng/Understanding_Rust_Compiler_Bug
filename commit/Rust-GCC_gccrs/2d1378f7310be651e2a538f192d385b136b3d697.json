{"sha": "2d1378f7310be651e2a538f192d385b136b3d697", "node_id": "C_kwDOANBUbNoAKDJkMTM3OGY3MzEwYmU2NTFlMmE1MzhmMTkyZDM4NWIxMzZiM2Q2OTc", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-07-15T10:56:19Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-07-15T16:02:20Z"}, "message": "Add new metadata interface to write directly to file\n\nThis interface will allow us to write the metadata directly to a file.\nMacOs does not support metadata embeded directly into a .section of\nobject files and archives. This allows us to seperate this mechanism so\nthat we can follow rustc and write this directly to a seperate file.\n\nThis patch adds two new options to control metadata outputs\n\n -frust-embed-metadata this toggles to embed the metadata into .rust_export\n section of the target asm output\n\n -frust-metadata-output= specifies the path to directly write the metadata\n to file\n\nWe need these options as embeding the metadata does not seem to be\nsupported for all platforms like MacOs so writing directly to file is a\nplatform agnostic solution.\n\nThere is an implicit naming convetion to metadata export files. They need\nto be of crate_name.rox. This patch adds some simple validation by checking\nthe basename of the specified path.", "tree": {"sha": "a080716bf04ed6180acd115fcfbbb856ab6990b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a080716bf04ed6180acd115fcfbbb856ab6990b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d1378f7310be651e2a538f192d385b136b3d697", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d1378f7310be651e2a538f192d385b136b3d697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d1378f7310be651e2a538f192d385b136b3d697", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d1378f7310be651e2a538f192d385b136b3d697/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "418aef1b006182e84266dcf4f31ee721ed04301a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/418aef1b006182e84266dcf4f31ee721ed04301a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/418aef1b006182e84266dcf4f31ee721ed04301a"}], "stats": {"total": 444, "additions": 324, "deletions": 120}, "files": [{"sha": "1f6855ede1dd3c340d69a4fbde12a94ef9bf4c29", "filename": "gcc/rust/lang.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d1378f7310be651e2a538f192d385b136b3d697/gcc%2Frust%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d1378f7310be651e2a538f192d385b136b3d697/gcc%2Frust%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flang.opt?ref=2d1378f7310be651e2a538f192d385b136b3d697", "patch": "@@ -103,6 +103,14 @@ Enum(frust_edition) String(2018) Value(1)\n EnumValue\n Enum(frust_edition) String(2021) Value(2)\n \n+frust-embed-metadata\n+Rust Var(flag_rust_embed_metadata)\n+Flag to enable embeding metadata directly into object files\n+\n+frust-metadata-output=\n+Rust Joined RejectNegative\n+-frust-metadata-output=<path.rox>  Path to output crate metadata\n+\n o\n Rust Joined Separate\n ; Documented in common.opt"}, {"sha": "4856bc26149a12584dfdf57203344ff77782a6e9", "filename": "gcc/rust/metadata/rust-export-metadata.cc", "status": "modified", "additions": 241, "deletions": 111, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d1378f7310be651e2a538f192d385b136b3d697/gcc%2Frust%2Fmetadata%2Frust-export-metadata.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d1378f7310be651e2a538f192d385b136b3d697/gcc%2Frust%2Fmetadata%2Frust-export-metadata.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-export-metadata.cc?ref=2d1378f7310be651e2a538f192d385b136b3d697", "patch": "@@ -29,127 +29,126 @@\n namespace Rust {\n namespace Metadata {\n \n-class ExportContext\n-{\n-public:\n-  ExportContext () : mappings (Analysis::Mappings::get ()) {}\n+static const std::string extension_path = \".rox\";\n \n-  ~ExportContext () {}\n+ExportContext::ExportContext () : mappings (Analysis::Mappings::get ()) {}\n \n-  void push_module_scope (const HIR::Module &module)\n-  {\n-    module_stack.push_back (module);\n-  }\n+ExportContext::~ExportContext () {}\n \n-  const HIR::Module &pop_module_scope ()\n-  {\n-    rust_assert (!module_stack.empty ());\n-\n-    const HIR::Module &poped = module_stack.back ();\n-    module_stack.pop_back ();\n-    return poped;\n-  }\n+void\n+ExportContext::push_module_scope (const HIR::Module &module)\n+{\n+  module_stack.push_back (module);\n+}\n \n-  void emit_trait (const HIR::Trait &trait)\n-  {\n-    // lookup the AST node for this\n-    AST::Item *item = nullptr;\n-    bool ok\n-      = mappings->lookup_ast_item (trait.get_mappings ().get_nodeid (), &item);\n-    rust_assert (ok);\n+const HIR::Module &\n+ExportContext::pop_module_scope ()\n+{\n+  rust_assert (!module_stack.empty ());\n+  const HIR::Module &poped = module_stack.back ();\n+  module_stack.pop_back ();\n+  return poped;\n+}\n \n-    std::stringstream oss;\n-    AST::Dump dumper (oss);\n-    dumper.go (*item);\n+void\n+ExportContext::emit_trait (const HIR::Trait &trait)\n+{\n+  // lookup the AST node for this\n+  AST::Item *item = nullptr;\n+  bool ok\n+    = mappings->lookup_ast_item (trait.get_mappings ().get_nodeid (), &item);\n+  rust_assert (ok);\n \n-    public_interface_buffer += oss.str ();\n-  }\n+  std::stringstream oss;\n+  AST::Dump dumper (oss);\n+  dumper.go (*item);\n \n-  void emit_function (const HIR::Function &fn)\n-  {\n-    // lookup the AST node for this\n-    AST::Item *item = nullptr;\n-    bool ok\n-      = mappings->lookup_ast_item (fn.get_mappings ().get_nodeid (), &item);\n-    rust_assert (ok);\n+  public_interface_buffer += oss.str ();\n+}\n \n-    // FIXME add assertion that item must be a vis_item;\n-    AST::VisItem &vis_item = static_cast<AST::VisItem &> (*item);\n+void\n+ExportContext::emit_function (const HIR::Function &fn)\n+{\n+  // lookup the AST node for this\n+  AST::Item *item = nullptr;\n+  bool ok = mappings->lookup_ast_item (fn.get_mappings ().get_nodeid (), &item);\n+  rust_assert (ok);\n \n-    // if its a generic function we need to output the full declaration\n-    // otherwise we can let people link against this\n+  // is this a CFG macro or not\n+  if (item->is_marked_for_strip ())\n+    return;\n \n-    std::stringstream oss;\n-    AST::Dump dumper (oss);\n-    if (!fn.has_generics ())\n-      {\n-\t// FIXME assert that this is actually an AST::Function\n-\tAST::Function &function = static_cast<AST::Function &> (vis_item);\n-\n-\t// we can emit an extern block with abi of \"rust\"\n-\tIdentifier item_name = function.get_function_name ();\n-\n-\t// always empty for extern linkage\n-\tAST::WhereClause where_clause = AST::WhereClause::create_empty ();\n-\tstd::vector<std::unique_ptr<AST::GenericParam>> generic_params;\n-\n-\tAST::Visibility vis = function.get_visibility ();\n-\tstd::unique_ptr<AST::Type> return_type\n-\t  = std::unique_ptr<AST::Type> (nullptr);\n-\tif (function.has_return_type ())\n-\t  {\n-\t    return_type = function.get_return_type ()->clone_type ();\n-\t  }\n-\n-\tstd::vector<AST::NamedFunctionParam> function_params;\n-\tfor (AST::FunctionParam &param : function.get_function_params ())\n-\t  {\n-\t    std::string name = param.get_pattern ()->as_string ();\n-\t    std::unique_ptr<AST::Type> param_type\n-\t      = param.get_type ()->clone_type ();\n-\n-\t    AST::NamedFunctionParam p (name, std::move (param_type), {},\n-\t\t\t\t       param.get_locus ());\n-\t    function_params.push_back (std::move (p));\n-\t  }\n-\n-\tAST::ExternalItem *external_item = new AST::ExternalFunctionItem (\n-\t  item_name, {} /* generic_params */, std::move (return_type),\n-\t  where_clause, std::move (function_params), false /* has_variadics */,\n-\t  {} /* variadic_outer_attrs */, vis, function.get_outer_attrs (),\n-\t  function.get_locus ());\n-\n-\tstd::vector<std::unique_ptr<AST::ExternalItem>> external_items;\n-\texternal_items.push_back (\n-\t  std::unique_ptr<AST::ExternalItem> (external_item));\n-\n-\tAST::ExternBlock extern_block (get_string_from_abi (Rust::ABI::RUST),\n-\t\t\t\t       std::move (external_items),\n-\t\t\t\t       vis_item.get_visibility (), {}, {},\n-\t\t\t\t       fn.get_locus ());\n-\n-\tdumper.go (extern_block);\n-      }\n-    else\n-      {\n-\tdumper.go (*item);\n-      }\n+  // FIXME add assertion that item must be a vis_item;\n+  AST::VisItem &vis_item = static_cast<AST::VisItem &> (*item);\n \n-    // store the dump\n-    public_interface_buffer += oss.str ();\n-  }\n+  // if its a generic function we need to output the full declaration\n+  // otherwise we can let people link against this\n \n-  const std::string &get_interface_buffer () const\n-  {\n-    return public_interface_buffer;\n-  }\n+  std::stringstream oss;\n+  AST::Dump dumper (oss);\n+  if (!fn.has_generics ())\n+    {\n+      // FIXME assert that this is actually an AST::Function\n+      AST::Function &function = static_cast<AST::Function &> (vis_item);\n+\n+      // we can emit an extern block with abi of \"rust\"\n+      Identifier item_name = function.get_function_name ();\n+\n+      // always empty for extern linkage\n+      AST::WhereClause where_clause = AST::WhereClause::create_empty ();\n+      std::vector<std::unique_ptr<AST::GenericParam>> generic_params;\n+\n+      AST::Visibility vis = function.get_visibility ();\n+      std::unique_ptr<AST::Type> return_type\n+\t= std::unique_ptr<AST::Type> (nullptr);\n+      if (function.has_return_type ())\n+\t{\n+\t  return_type = function.get_return_type ()->clone_type ();\n+\t}\n+\n+      std::vector<AST::NamedFunctionParam> function_params;\n+      for (AST::FunctionParam &param : function.get_function_params ())\n+\t{\n+\t  std::string name = param.get_pattern ()->as_string ();\n+\t  std::unique_ptr<AST::Type> param_type\n+\t    = param.get_type ()->clone_type ();\n+\n+\t  AST::NamedFunctionParam p (name, std::move (param_type), {},\n+\t\t\t\t     param.get_locus ());\n+\t  function_params.push_back (std::move (p));\n+\t}\n+\n+      AST::ExternalItem *external_item = new AST::ExternalFunctionItem (\n+\titem_name, {} /* generic_params */, std::move (return_type),\n+\twhere_clause, std::move (function_params), false /* has_variadics */,\n+\t{} /* variadic_outer_attrs */, vis, function.get_outer_attrs (),\n+\tfunction.get_locus ());\n+\n+      std::vector<std::unique_ptr<AST::ExternalItem>> external_items;\n+      external_items.push_back (\n+\tstd::unique_ptr<AST::ExternalItem> (external_item));\n+\n+      AST::ExternBlock extern_block (get_string_from_abi (Rust::ABI::RUST),\n+\t\t\t\t     std::move (external_items),\n+\t\t\t\t     vis_item.get_visibility (), {}, {},\n+\t\t\t\t     fn.get_locus ());\n+\n+      dumper.go (extern_block);\n+    }\n+  else\n+    {\n+      dumper.go (*item);\n+    }\n \n-private:\n-  Analysis::Mappings *mappings;\n+  // store the dump\n+  public_interface_buffer += oss.str ();\n+}\n \n-  std::vector<std::reference_wrapper<const HIR::Module>> module_stack;\n-  std::string public_interface_buffer;\n-};\n+const std::string &\n+ExportContext::get_interface_buffer () const\n+{\n+  return public_interface_buffer;\n+}\n \n // implicitly by using HIR nodes we know that these have passed CFG expansion\n // and they exist in the compilation unit\n@@ -183,20 +182,28 @@ class ExportVisItems : public HIR::HIRVisItemVisitor\n };\n \n PublicInterface::PublicInterface (HIR::Crate &crate)\n-  : crate (crate), mappings (*Analysis::Mappings::get ())\n+  : crate (crate), mappings (*Analysis::Mappings::get ()), context ()\n {}\n \n void\n PublicInterface::Export (HIR::Crate &crate)\n {\n   PublicInterface interface (crate);\n-  interface.go ();\n+  interface.gather_export_data ();\n+  interface.write_to_object_file ();\n+}\n+\n+void\n+PublicInterface::ExportTo (HIR::Crate &crate, const std::string &output_path)\n+{\n+  PublicInterface interface (crate);\n+  interface.gather_export_data ();\n+  interface.write_to_path (output_path);\n }\n \n void\n-PublicInterface::go ()\n+PublicInterface::gather_export_data ()\n {\n-  ExportContext context;\n   ExportVisItems visitor (context);\n   for (auto &item : crate.items)\n     {\n@@ -208,7 +215,11 @@ PublicInterface::go ()\n       if (is_crate_public (vis_item))\n \tvis_item.accept_vis (visitor);\n     }\n+}\n \n+void\n+PublicInterface::write_to_object_file () const\n+{\n   // done\n   const auto &buf = context.get_interface_buffer ();\n   std::string size_buffer = std::to_string (buf.size ());\n@@ -236,6 +247,116 @@ PublicInterface::go ()\n   rust_write_export_data (buf.c_str (), buf.size ());\n }\n \n+void\n+PublicInterface::write_to_path (const std::string &path) const\n+{\n+  // validate path contains correct extension\n+  const std::string expected_file_name = expected_metadata_filename ();\n+  const char *path_base_name = basename (path.c_str ());\n+  if (strcmp (path_base_name, expected_file_name.c_str ()) != 0)\n+    {\n+      rust_error_at (Location (),\n+\t\t     \"expected metadata-output path to have base file name of: \"\n+\t\t     \"%<%s%> got %<%s%>\",\n+\t\t     expected_file_name.c_str (), path_base_name);\n+      return;\n+    }\n+\n+  // done\n+  const auto &buf = context.get_interface_buffer ();\n+  std::string size_buffer = std::to_string (buf.size ());\n+\n+  // md5 this\n+  struct md5_ctx chksm;\n+  unsigned char checksum[16];\n+\n+  md5_init_ctx (&chksm);\n+  md5_process_bytes (buf.c_str (), buf.size (), &chksm);\n+  md5_finish_ctx (&chksm, checksum);\n+\n+  // MAGIC MD5 DLIM  DLIM buffer-size DELIM contents\n+  const std::string current_crate_name = mappings.get_current_crate_name ();\n+\n+  // write to path\n+  FILE *nfd = fopen (path.c_str (), \"wb\");\n+  if (nfd == NULL)\n+    {\n+      rust_error_at (Location (), \"failed to open file %<%s%> for writing: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      return;\n+    }\n+\n+  // write data\n+  if (fwrite (kMagicHeader, sizeof (kMagicHeader), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (checksum, sizeof (checksum), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (kSzDelim, sizeof (kSzDelim), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (current_crate_name.c_str (), current_crate_name.size (), 1, nfd)\n+      < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (kSzDelim, sizeof (kSzDelim), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (size_buffer.c_str (), size_buffer.size (), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (kSzDelim, sizeof (kSzDelim), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (!buf.empty ())\n+    if (fwrite (buf.c_str (), buf.size (), 1, nfd) < 1)\n+      {\n+\trust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t       path.c_str (), xstrerror (errno));\n+\tfclose (nfd);\n+\treturn;\n+      }\n+\n+  // done\n+  fclose (nfd);\n+}\n+\n bool\n PublicInterface::is_crate_public (const HIR::VisItem &item)\n {\n@@ -251,5 +372,14 @@ PublicInterface::is_crate_public (const HIR::VisItem &item)\n   return is_public && !has_path;\n }\n \n+std::string\n+PublicInterface::expected_metadata_filename ()\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+\n+  const std::string current_crate_name = mappings->get_current_crate_name ();\n+  return current_crate_name + extension_path;\n+}\n+\n } // namespace Metadata\n } // namespace Rust"}, {"sha": "cbb6ecd65a6826d8542caed892ba6cb6dc3c4f0a", "filename": "gcc/rust/metadata/rust-export-metadata.h", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d1378f7310be651e2a538f192d385b136b3d697/gcc%2Frust%2Fmetadata%2Frust-export-metadata.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d1378f7310be651e2a538f192d385b136b3d697/gcc%2Frust%2Fmetadata%2Frust-export-metadata.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-export-metadata.h?ref=2d1378f7310be651e2a538f192d385b136b3d697", "patch": "@@ -29,19 +29,54 @@ namespace Metadata {\n static const char kMagicHeader[4] = {'G', 'R', 'S', 'T'};\n static const char kSzDelim[1] = {'$'};\n \n+class ExportContext\n+{\n+public:\n+  ExportContext ();\n+\n+  ~ExportContext ();\n+\n+  void push_module_scope (const HIR::Module &module);\n+\n+  const HIR::Module &pop_module_scope ();\n+\n+  void emit_trait (const HIR::Trait &trait);\n+\n+  void emit_function (const HIR::Function &fn);\n+\n+  const std::string &get_interface_buffer () const;\n+\n+private:\n+  Analysis::Mappings *mappings;\n+\n+  std::vector<std::reference_wrapper<const HIR::Module>> module_stack;\n+  std::string public_interface_buffer;\n+};\n+\n class PublicInterface\n {\n public:\n   static void Export (HIR::Crate &crate);\n \n+  static void ExportTo (HIR::Crate &crate, const std::string &output_path);\n+\n   static bool is_crate_public (const HIR::VisItem &item);\n \n+  static std::string expected_metadata_filename ();\n+\n+protected:\n+  void gather_export_data ();\n+\n+  void write_to_object_file () const;\n+\n+  void write_to_path (const std::string &path) const;\n+\n private:\n   PublicInterface (HIR::Crate &crate);\n-  void go ();\n \n   HIR::Crate &crate;\n   Analysis::Mappings &mappings;\n+  ExportContext context;\n };\n \n } // namespace Metadata"}, {"sha": "f3007289eadf7374c4fe5de4ca7192ec1cfc975e", "filename": "gcc/rust/rust-object-export.cc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d1378f7310be651e2a538f192d385b136b3d697/gcc%2Frust%2Frust-object-export.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d1378f7310be651e2a538f192d385b136b3d697/gcc%2Frust%2Frust-object-export.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-object-export.cc?ref=2d1378f7310be651e2a538f192d385b136b3d697", "patch": "@@ -17,9 +17,6 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n-// FIXME: doesn't this duplicate lots of code from rust-backend.c? Is one meant\n-// to be a replacement?\n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -54,9 +51,6 @@\n #define TARGET_AIX 0\n #endif\n \n-/* This file holds all the cases where the Rust frontend needs\n-   information from gcc's backend.  */\n-\n /* Return whether or not GCC has reported any errors.  */\n \n bool"}, {"sha": "eb4240a447fe35fddd91ce9f5fd7ccba05b21850", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d1378f7310be651e2a538f192d385b136b3d697/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d1378f7310be651e2a538f192d385b136b3d697/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=2d1378f7310be651e2a538f192d385b136b3d697", "patch": "@@ -461,6 +461,10 @@ Session::handle_option (\n       options.set_edition (flag_rust_edition);\n       break;\n \n+    case OPT_frust_metadata_output_:\n+      options.set_metadata_output (arg);\n+      break;\n+\n     default:\n       break;\n     }\n@@ -796,8 +800,22 @@ Session::parse_file (const char *filename)\n       Analysis::ScanDeadcode::Scan (hir);\n       Analysis::UnusedVariables::Lint (ctx);\n \n-      // emit metadata\n-      Metadata::PublicInterface::Export (hir);\n+      // metadata\n+      bool specified_emit_metadata\n+\t= flag_rust_embed_metadata || options.metadata_output_path_set ();\n+      if (!specified_emit_metadata)\n+\t{\n+\t  Metadata::PublicInterface::ExportTo (\n+\t    hir, Metadata::PublicInterface::expected_metadata_filename ());\n+\t}\n+      else\n+\t{\n+\t  if (flag_rust_embed_metadata)\n+\t    Metadata::PublicInterface::Export (hir);\n+\t  if (options.metadata_output_path_set ())\n+\t    Metadata::PublicInterface::ExportTo (\n+\t      hir, options.get_metadata_output ());\n+\t}\n     }\n \n   // pass to GCC middle-end\n@@ -952,6 +970,8 @@ Session::injection (AST::Crate &crate)\n    * an invalid crate type is not specified, so maybe just do that. Valid\n    * crate types: bin lib dylib staticlib cdylib rlib proc-macro */\n \n+  // this crate type will have options affecting the metadata ouput\n+\n   rust_debug (\"finished injection\");\n }\n "}, {"sha": "c68e796461fec697cfe58f82ab3bcaf9fc064911", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d1378f7310be651e2a538f192d385b136b3d697/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d1378f7310be651e2a538f192d385b136b3d697/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=2d1378f7310be651e2a538f192d385b136b3d697", "patch": "@@ -189,6 +189,8 @@ struct CompileOptions\n   bool enable_test = false;\n   bool debug_assertions = false;\n   bool proc_macro = false;\n+  std::string metadata_output_path;\n+\n   enum Edition\n   {\n     E2015 = 0,\n@@ -236,6 +238,21 @@ struct CompileOptions\n   {\n     edition = static_cast<Edition> (raw_edition);\n   }\n+\n+  void set_metadata_output (const std::string &path)\n+  {\n+    metadata_output_path = path;\n+  }\n+\n+  const std::string &get_metadata_output () const\n+  {\n+    return metadata_output_path;\n+  }\n+\n+  bool metadata_output_path_set () const\n+  {\n+    return !metadata_output_path.empty ();\n+  }\n };\n \n /* Defines a compiler session. This is for a single compiler invocation, so"}]}