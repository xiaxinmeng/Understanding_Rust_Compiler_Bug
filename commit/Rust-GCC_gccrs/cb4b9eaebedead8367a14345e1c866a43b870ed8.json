{"sha": "cb4b9eaebedead8367a14345e1c866a43b870ed8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I0YjllYWViZWRlYWQ4MzY3YTE0MzQ1ZTFjODY2YTQzYjg3MGVkOA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T21:44:56Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T21:44:56Z"}, "message": "trans.h (struct gfc_array_info): Move dim and dimen fields...\n\n\t* trans.h (struct gfc_array_info): Move dim and dimen fields...\n\t(struct gfc_ss): ... here.  Remove gfc_ss::data::temp::dimen field.\n\t* trans-array.c (gfc_conv_loop_setup): Remove temp_ss dim array\n\tinitialization.\n\t(gfc_get_temp_ss): Initialize dim and dimen.\n\t(gfc_free_ss, gfc_get_array_ss, gfc_get_temp_ss,\n\tgfc_set_loop_bounds_from_array_spec, get_array_ref_dim,\n\tgfc_trans_create_temp_array, gfc_trans_constant_array_constructor,\n\tgfc_set_vector_loop_bounds, gfc_conv_scalarized_array_ref,\n\tgfc_trans_preloop_setup, gfc_conv_ss_startstride,\n\tgfc_conv_resolve_dependencies, gfc_conv_loop_setup, transposed_dims,\n\tgfc_conv_expr_descriptor, gfc_alloc_allocatable_for_assignment,\n\tgfc_walk_array_ref): Update field references.\n\t* trans-expr.c (gfc_conv_subref_array_arg, gfc_conv_procedure_call):\n\tDitto.\n\t* trans-intrinsic.c (walk_inline_intrinsic_transpose): Ditto.\n\t* trans-stmt.c (gfc_conv_elemental_dependencies): Ditto.\n\nFrom-SVN: r180865", "tree": {"sha": "22ec19ee4fddeba6b4f14d88ddeeabc3574e9345", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22ec19ee4fddeba6b4f14d88ddeeabc3574e9345"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb4b9eaebedead8367a14345e1c866a43b870ed8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4b9eaebedead8367a14345e1c866a43b870ed8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb4b9eaebedead8367a14345e1c866a43b870ed8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4b9eaebedead8367a14345e1c866a43b870ed8/comments", "author": null, "committer": null, "parents": [{"sha": "6d63e468a3939e3b34336075aaa6ae1c3b857e09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d63e468a3939e3b34336075aaa6ae1c3b857e09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d63e468a3939e3b34336075aaa6ae1c3b857e09"}], "stats": {"total": 188, "additions": 99, "deletions": 89}, "files": [{"sha": "712882a4c82fd18e90e82d9b01f6f560157b134a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4b9eaebedead8367a14345e1c866a43b870ed8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4b9eaebedead8367a14345e1c866a43b870ed8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=cb4b9eaebedead8367a14345e1c866a43b870ed8", "patch": "@@ -1,3 +1,23 @@\n+2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans.h (struct gfc_array_info): Move dim and dimen fields...\n+\t(struct gfc_ss): ... here.  Remove gfc_ss::data::temp::dimen field.\n+\t* trans-array.c (gfc_conv_loop_setup): Remove temp_ss dim array\n+\tinitialization.\n+\t(gfc_get_temp_ss): Initialize dim and dimen.\n+\t(gfc_free_ss, gfc_get_array_ss, gfc_get_temp_ss,\n+\tgfc_set_loop_bounds_from_array_spec, get_array_ref_dim,\n+\tgfc_trans_create_temp_array, gfc_trans_constant_array_constructor,\n+\tgfc_set_vector_loop_bounds, gfc_conv_scalarized_array_ref,\n+\tgfc_trans_preloop_setup, gfc_conv_ss_startstride,\n+\tgfc_conv_resolve_dependencies, gfc_conv_loop_setup, transposed_dims,\n+\tgfc_conv_expr_descriptor, gfc_alloc_allocatable_for_assignment,\n+\tgfc_walk_array_ref): Update field references.\n+\t* trans-expr.c (gfc_conv_subref_array_arg, gfc_conv_procedure_call):\n+\tDitto.\n+\t* trans-intrinsic.c (walk_inline_intrinsic_transpose): Ditto.\n+\t* trans-stmt.c (gfc_conv_elemental_dependencies): Ditto.\n+\n 2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans.h (struct gfc_ss_info, struct gfc_array_info):"}, {"sha": "6ff60dcfa9919ff7290c2b6558ffce9d8c25f695", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 64, "deletions": 69, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4b9eaebedead8367a14345e1c866a43b870ed8/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4b9eaebedead8367a14345e1c866a43b870ed8/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=cb4b9eaebedead8367a14345e1c866a43b870ed8", "patch": "@@ -496,10 +496,10 @@ gfc_free_ss (gfc_ss * ss)\n   switch (ss->type)\n     {\n     case GFC_SS_SECTION:\n-      for (n = 0; n < ss->data.info.dimen; n++)\n+      for (n = 0; n < ss->dimen; n++)\n \t{\n-\t  if (ss->data.info.subscript[ss->data.info.dim[n]])\n-\t    gfc_free_ss_chain (ss->data.info.subscript[ss->data.info.dim[n]]);\n+\t  if (ss->data.info.subscript[ss->dim[n]])\n+\t    gfc_free_ss_chain (ss->data.info.subscript[ss->dim[n]]);\n \t}\n       break;\n \n@@ -517,17 +517,15 @@ gfc_ss *\n gfc_get_array_ss (gfc_ss *next, gfc_expr *expr, int dimen, gfc_ss_type type)\n {\n   gfc_ss *ss;\n-  gfc_array_info *info;\n   int i;\n \n   ss = gfc_get_ss ();\n   ss->next = next;\n   ss->type = type;\n   ss->expr = expr;\n-  info = &ss->data.info;\n-  info->dimen = dimen;\n-  for (i = 0; i < info->dimen; i++)\n-    info->dim[i] = i;\n+  ss->dimen = dimen;\n+  for (i = 0; i < ss->dimen; i++)\n+    ss->dim[i] = i;\n \n   return ss;\n }\n@@ -539,13 +537,16 @@ gfc_ss *\n gfc_get_temp_ss (tree type, tree string_length, int dimen)\n {\n   gfc_ss *ss;\n+  int i;\n \n   ss = gfc_get_ss ();\n   ss->next = gfc_ss_terminator;\n   ss->type = GFC_SS_TEMP;\n   ss->string_length = string_length;\n-  ss->data.temp.dimen = dimen;\n   ss->data.temp.type = type;\n+  ss->dimen = dimen;\n+  for (i = 0; i < ss->dimen; i++)\n+    ss->dim[i] = i;\n \n   return ss;\n }\n@@ -642,7 +643,7 @@ gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping * mapping,\n   if (as && as->type == AS_EXPLICIT)\n     for (n = 0; n < se->loop->dimen; n++)\n       {\n-\tdim = se->ss->data.info.dim[n];\n+\tdim = se->ss->dim[n];\n \tgcc_assert (dim < as->rank);\n \tgcc_assert (se->loop->dimen == as->rank);\n \tif (se->loop->to[n] == NULL_TREE)\n@@ -810,15 +811,12 @@ static int\n get_array_ref_dim (gfc_ss *ss, int loop_dim)\n {\n   int n, array_dim, array_ref_dim;\n-  gfc_array_info *info;\n-\n-  info = &ss->data.info;\n \n   array_ref_dim = 0;\n-  array_dim = info->dim[loop_dim];\n+  array_dim = ss->dim[loop_dim];\n \n-  for (n = 0; n < info->dimen; n++)\n-    if (info->dim[n] < array_dim)\n+  for (n = 0; n < ss->dimen; n++)\n+    if (ss->dim[n] < array_dim)\n       array_ref_dim++;\n \n   return array_ref_dim;\n@@ -861,16 +859,16 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \n   info = &ss->data.info;\n \n-  gcc_assert (info->dimen > 0);\n-  gcc_assert (loop->dimen == info->dimen);\n+  gcc_assert (ss->dimen > 0);\n+  gcc_assert (loop->dimen == ss->dimen);\n \n   if (gfc_option.warn_array_temp && where)\n     gfc_warning (\"Creating array temporary at %L\", where);\n \n   /* Set the lower bound to zero.  */\n   for (n = 0; n < loop->dimen; n++)\n     {\n-      dim = info->dim[n];\n+      dim = ss->dim[n];\n \n       /* Callee allocated arrays may not have a known bound yet.  */\n       if (loop->to[n])\n@@ -899,7 +897,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \n   /* Initialize the descriptor.  */\n   type =\n-    gfc_get_array_type_bounds (eltype, info->dimen, 0, from, to, 1,\n+    gfc_get_array_type_bounds (eltype, ss->dimen, 0, from, to, 1,\n \t\t\t       GFC_ARRAY_UNKNOWN, true);\n   desc = gfc_create_var (type, \"atmp\");\n   GFC_DECL_PACKED_ARRAY (desc) = 1;\n@@ -937,7 +935,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \n   for (n = 0; n < loop->dimen; n++)\n     {\n-      dim = info->dim[n];\n+      dim = ss->dim[n];\n \n       if (size == NULL_TREE)\n \t{\n@@ -1003,8 +1001,8 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n   gfc_trans_allocate_array_storage (pre, post, info, size, nelem, initial,\n \t\t\t\t    dynamic, dealloc);\n \n-  if (info->dimen > loop->temp_dim)\n-    loop->temp_dim = info->dimen;\n+  if (ss->dimen > loop->temp_dim)\n+    loop->temp_dim = ss->dimen;\n \n   return size;\n }\n@@ -1869,7 +1867,7 @@ trans_constant_array_constructor (gfc_ss * ss, tree type)\n   info->data = gfc_build_addr_expr (NULL_TREE, tmp);\n   info->offset = gfc_index_zero_node;\n \n-  for (i = 0; i < info->dimen; i++)\n+  for (i = 0; i < ss->dimen; i++)\n     {\n       info->delta[i] = gfc_index_zero_node;\n       info->start[i] = gfc_index_zero_node;\n@@ -1950,7 +1948,7 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n       first_len = true;\n     }\n \n-  gcc_assert (ss->data.info.dimen == loop->dimen);\n+  gcc_assert (ss->dimen == loop->dimen);\n \n   c = ss->expr->value.constructor;\n   if (ss->expr->ts.type == BT_CHARACTER)\n@@ -2111,7 +2109,7 @@ set_vector_loop_bounds (gfc_loopinfo * loop, gfc_ss * ss)\n \n   for (n = 0; n < loop->dimen; n++)\n     {\n-      dim = info->dim[n];\n+      dim = ss->dim[n];\n       if (info->ref->u.ar.dimen_type[dim] == DIMEN_VECTOR\n \t  && loop->to[n] == NULL)\n \t{\n@@ -2633,16 +2631,17 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n   tree decl = NULL_TREE;\n   tree index;\n   tree tmp;\n+  gfc_ss *ss;\n   int n;\n \n-  info = &se->ss->data.info;\n+  ss = se->ss;\n+  info = &ss->data.info;\n   if (ar)\n     n = se->loop->order[0];\n   else\n     n = 0;\n \n-  index = conv_array_index_offset (se, se->ss, info->dim[n], n, ar,\n-\t\t\t\t       info->stride0);\n+  index = conv_array_index_offset (se, ss, ss->dim[n], n, ar, info->stride0);\n   /* Add the offset for this dimension to the stored offset for all other\n      dimensions.  */\n   if (!integer_zerop (info->offset))\n@@ -2873,8 +2872,8 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n \n       info = &ss->data.info;\n \n-      gcc_assert (dim < info->dimen);\n-      gcc_assert (info->dimen == loop->dimen);\n+      gcc_assert (dim < ss->dimen);\n+      gcc_assert (ss->dimen == loop->dimen);\n \n       if (info->ref)\n \tar = &info->ref->u.ar;\n@@ -2892,7 +2891,7 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n \n       if (dim == loop->dimen - 1)\n \t{\n-\t  stride = gfc_conv_array_stride (info->descriptor, info->dim[i]);\n+\t  stride = gfc_conv_array_stride (info->descriptor, ss->dim[i]);\n \n \t  /* Calculate the stride of the innermost loop.  Hopefully this will\n \t     allow the backend optimizers to do their stuff more effectively.\n@@ -2915,7 +2914,7 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n \t}\n       else\n \t/* Add the offset for the previous loop dimension.  */\n-\tadd_array_offset (pblock, loop, ss, ar, info->dim[i], i);\n+\tadd_array_offset (pblock, loop, ss, ar, ss->dim[i], i);\n \n       /* Remember this offset for the second loop.  */\n       if (dim == loop->temp_dim - 1)\n@@ -3271,7 +3270,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \tcase GFC_SS_CONSTRUCTOR:\n \tcase GFC_SS_FUNCTION:\n \tcase GFC_SS_COMPONENT:\n-\t  loop->dimen = ss->data.info.dimen;\n+\t  loop->dimen = ss->dimen;\n \t  goto done;\n \n \t/* As usual, lbound and ubound are exceptions!.  */\n@@ -3283,7 +3282,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t    case GFC_ISYM_LCOBOUND:\n \t    case GFC_ISYM_UCOBOUND:\n \t    case GFC_ISYM_THIS_IMAGE:\n-\t      loop->dimen = ss->data.info.dimen;\n+\t      loop->dimen = ss->dimen;\n \t      goto done;\n \n \t    default:\n@@ -3312,8 +3311,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t  /* Get the descriptor for the array.  */\n \t  gfc_conv_ss_descriptor (&loop->pre, ss, !loop->array_parameter);\n \n-\t  for (n = 0; n < ss->data.info.dimen; n++)\n-\t    gfc_conv_section_startstride (loop, ss, ss->data.info.dim[n]);\n+\t  for (n = 0; n < ss->dimen; n++)\n+\t    gfc_conv_section_startstride (loop, ss, ss->dim[n]);\n \t  break;\n \n \tcase GFC_SS_INTRINSIC:\n@@ -3333,9 +3332,9 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \n \tcase GFC_SS_CONSTRUCTOR:\n \tcase GFC_SS_FUNCTION:\n-\t  for (n = 0; n < ss->data.info.dimen; n++)\n+\t  for (n = 0; n < ss->dimen; n++)\n \t    {\n-\t      int dim = ss->data.info.dim[n];\n+\t      int dim = ss->dim[n];\n \n \t      ss->data.info.start[dim]  = gfc_index_zero_node;\n \t      ss->data.info.end[dim]    = gfc_index_zero_node;\n@@ -3387,7 +3386,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t    {\n \t      bool check_upper;\n \n-\t      dim = info->dim[n];\n+\t      dim = ss->dim[n];\n \t      if (info->ref->u.ar.dimen_type[dim] != DIMEN_RANGE)\n \t\tcontinue;\n \n@@ -3776,10 +3775,10 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n \t  if (nDepend == 1)\n \t    break;\n \n-\t  for (i = 0; i < dest->data.info.dimen; i++)\n-\t    for (j = 0; j < ss->data.info.dimen; j++)\n+\t  for (i = 0; i < dest->dimen; i++)\n+\t    for (j = 0; j < ss->dimen; j++)\n \t      if (i != j\n-\t\t  && dest->data.info.dim[i] == ss->data.info.dim[j])\n+\t\t  && dest->dim[i] == ss->dim[j])\n \t\t{\n \t\t  /* If we don't access array elements in the same order,\n \t\t     there is a dependency.  */\n@@ -3853,7 +3852,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n   int n, dim, spec_dim;\n   gfc_array_info *info;\n   gfc_array_info *specinfo;\n-  gfc_ss *ss;\n+  gfc_ss *ss, *tmp_ss;\n   tree tmp;\n   gfc_ss *loopspec[GFC_MAX_DIMENSIONS];\n   bool dynamic[GFC_MAX_DIMENSIONS];\n@@ -3878,12 +3877,12 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t    continue;\n \n \t  info = &ss->data.info;\n-\t  dim = info->dim[n];\n+\t  dim = ss->dim[n];\n \n \t  if (loopspec[n] != NULL)\n \t    {\n \t      specinfo = &loopspec[n]->data.info;\n-\t      spec_dim = specinfo->dim[n];\n+\t      spec_dim = loopspec[n]->dim[n];\n \t    }\n \t  else\n \t    {\n@@ -3971,7 +3970,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n       gcc_assert (loopspec[n]);\n \n       info = &loopspec[n]->data.info;\n-      dim = info->dim[n];\n+      dim = loopspec[n]->dim[n];\n \n       /* Set the extents of this range.  */\n       cshape = loopspec[n]->shape;\n@@ -4047,8 +4046,9 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n      allocating the temporary.  */\n   gfc_add_loop_ss_code (loop, loop->ss, false, where);\n \n+  tmp_ss = loop->temp_ss;\n   /* If we want a temporary then create it.  */\n-  if (loop->temp_ss != NULL)\n+  if (tmp_ss != NULL)\n     {\n       gcc_assert (loop->temp_ss->type == GFC_SS_TEMP);\n \n@@ -4060,17 +4060,13 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t\t\t loop->temp_ss->string_length);\n \n       tmp = loop->temp_ss->data.temp.type;\n-      n = loop->temp_ss->data.temp.dimen;\n       memset (&loop->temp_ss->data.info, 0, sizeof (gfc_array_info));\n       loop->temp_ss->type = GFC_SS_SECTION;\n-      loop->temp_ss->data.info.dimen = n;\n \n-      gcc_assert (loop->temp_ss->data.info.dimen != 0);\n-      for (n = 0; n < loop->temp_ss->data.info.dimen; n++)\n-\tloop->temp_ss->data.info.dim[n] = n;\n+      gcc_assert (tmp_ss->dimen != 0);\n \n       gfc_trans_create_temp_array (&loop->pre, &loop->post, loop,\n-\t\t\t\t   loop->temp_ss, tmp, NULL_TREE,\n+\t\t\t\t   tmp_ss, tmp, NULL_TREE,\n \t\t\t\t   false, true, false, where);\n     }\n \n@@ -4094,12 +4090,12 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \n       info = &ss->data.info;\n \n-      for (n = 0; n < info->dimen; n++)\n+      for (n = 0; n < ss->dimen; n++)\n \t{\n \t  /* If we are specifying the range the delta is already set.  */\n \t  if (loopspec[n] != ss)\n \t    {\n-\t      dim = ss->data.info.dim[n];\n+\t      dim = ss->dim[n];\n \n \t      /* Calculate the offset relative to the loop variable.\n \t\t First multiply by the stride.  */\n@@ -5657,16 +5653,15 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)\n     }\n }\n \n+\n /* Helper function to check dimensions.  */\n static bool\n transposed_dims (gfc_ss *ss)\n {\n-  gfc_array_info *info;\n   int n;\n \n-  info = &ss->data.info;\n-  for (n = 0; n < info->dimen; n++)\n-    if (info->dim[n] != n)\n+  for (n = 0; n < ss->dimen; n++)\n+    if (ss->dim[n] != n)\n       return true;\n   return false;\n }\n@@ -5899,7 +5894,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t\t\t\t      loop.dimen);\n \n       se->string_length = loop.temp_ss->string_length;\n-      gcc_assert (loop.temp_ss->data.temp.dimen == loop.dimen);\n+      gcc_assert (loop.temp_ss->dimen == loop.dimen);\n       gfc_add_ss_to_loop (&loop, loop.temp_ss);\n     }\n \n@@ -5972,7 +5967,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       tree to;\n       tree base;\n \n-      ndim = info->ref ? info->ref->u.ar.dimen : info->dimen;\n+      ndim = info->ref ? info->ref->u.ar.dimen : ss->dimen;\n \n       if (se->want_coarray)\n \t{\n@@ -6087,7 +6082,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n  \n \t  /* look for the corresponding scalarizer dimension: dim.  */\n \t  for (dim = 0; dim < ndim; dim++)\n-\t    if (info->dim[dim] == n)\n+\t    if (ss->dim[dim] == n)\n \t      break;\n \n \t  /* loop exited early: the DIM being looked for has been found.  */\n@@ -7376,7 +7371,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   for (n = 0; n < expr1->rank; n++)\n     {\n       tmp = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[n]);\n-      dim = lss->data.info.dim[n];\n+      dim = lss->dim[n];\n       tmp = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t     gfc_array_index_type, tmp,\n \t\t\t     loop->from[dim]);\n@@ -7678,8 +7673,8 @@ gfc_walk_array_ref (gfc_ss * ss, gfc_expr * expr, gfc_ref * ref)\n \t\tcase DIMEN_RANGE:\n                   /* We don't add anything for sections, just remember this\n                      dimension for later.  */\n-\t\t  newss->data.info.dim[newss->data.info.dimen] = n;\n-\t\t  newss->data.info.dimen++;\n+\t\t  newss->dim[newss->dimen] = n;\n+\t\t  newss->dimen++;\n \t\t  break;\n \n \t\tcase DIMEN_VECTOR:\n@@ -7689,8 +7684,8 @@ gfc_walk_array_ref (gfc_ss * ss, gfc_expr * expr, gfc_ref * ref)\n \t\t\t\t\t      1, GFC_SS_VECTOR);\n \t\t  indexss->loop_chain = gfc_ss_terminator;\n \t\t  newss->data.info.subscript[n] = indexss;\n-\t\t  newss->data.info.dim[newss->data.info.dimen] = n;\n-\t\t  newss->data.info.dimen++;\n+\t\t  newss->dim[newss->dimen] = n;\n+\t\t  newss->dimen++;\n \t\t  break;\n \n \t\tdefault:\n@@ -7700,7 +7695,7 @@ gfc_walk_array_ref (gfc_ss * ss, gfc_expr * expr, gfc_ref * ref)\n \t    }\n \t  /* We should have at least one non-elemental dimension,\n \t     unless we are creating a descriptor for a (scalar) coarray.  */\n-\t  gcc_assert (newss->data.info.dimen > 0\n+\t  gcc_assert (newss->dimen > 0\n \t\t      || newss->data.info.ref->u.ar.as->corank > 0);\n \t  ss = newss;\n \t  break;"}, {"sha": "84222f5296925fc742717823e90414c1052916c5", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4b9eaebedead8367a14345e1c866a43b870ed8/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4b9eaebedead8367a14345e1c866a43b870ed8/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=cb4b9eaebedead8367a14345e1c866a43b870ed8", "patch": "@@ -2489,7 +2489,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n      outside the innermost loop, so the overall transfer could be\n      optimized further.  */\n   info = &rse.ss->data.info;\n-  dimen = info->dimen;\n+  dimen = rse.ss->dimen;\n \n   tmp_index = gfc_index_zero_node;\n   for (n = dimen - 1; n > 0; n--)\n@@ -3582,7 +3582,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t  /* Set the type of the array.  */\n \t  tmp = gfc_typenode_for_spec (&comp->ts);\n-\t  gcc_assert (info->dimen == se->loop->dimen);\n+\t  gcc_assert (se->ss->dimen == se->loop->dimen);\n \n \t  /* Evaluate the bounds of the result, if known.  */\n \t  gfc_set_loop_bounds_from_array_spec (&mapping, se, comp->as);\n@@ -3618,7 +3618,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t  /* Set the type of the array.  */\n \t  tmp = gfc_typenode_for_spec (&ts);\n-\t  gcc_assert (info->dimen == se->loop->dimen);\n+\t  gcc_assert (se->ss->dimen == se->loop->dimen);\n \n \t  /* Evaluate the bounds of the result, if known.  */\n \t  gfc_set_loop_bounds_from_array_spec (&mapping, se, sym->result->as);"}, {"sha": "3f8d51451fb46cd4d882baed6d00bd64eb11713d", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4b9eaebedead8367a14345e1c866a43b870ed8/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4b9eaebedead8367a14345e1c866a43b870ed8/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=cb4b9eaebedead8367a14345e1c866a43b870ed8", "patch": "@@ -6757,15 +6757,13 @@ walk_inline_intrinsic_transpose (gfc_ss *ss, gfc_expr *expr)\n \t  && tmp_ss->type != GFC_SS_REFERENCE)\n \t{\n \t  int tmp_dim;\n-\t  gfc_array_info *info;\n \n-\t  info = &tmp_ss->data.info;\n-\t  gcc_assert (info->dimen == 2);\n+\t  gcc_assert (tmp_ss->dimen == 2);\n \n \t  /* We just invert dimensions.  */\n-\t  tmp_dim = info->dim[0];\n-\t  info->dim[0] = info->dim[1];\n-\t  info->dim[1] = tmp_dim;\n+\t  tmp_dim = tmp_ss->dim[0];\n+\t  tmp_ss->dim[0] = tmp_ss->dim[1];\n+\t  tmp_ss->dim[1] = tmp_dim;\n \t}\n \n       /* Stop when tmp_ss points to the last valid element of the chain...  */"}, {"sha": "c66d6b54499d49c5a59bc6eb9b74bf9442e22bd9", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4b9eaebedead8367a14345e1c866a43b870ed8/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4b9eaebedead8367a14345e1c866a43b870ed8/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=cb4b9eaebedead8367a14345e1c866a43b870ed8", "patch": "@@ -241,8 +241,8 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t  /* Make a local loopinfo for the temporary creation, so that\n \t     none of the other ss->info's have to be renormalized.  */\n \t  gfc_init_loopinfo (&tmp_loop);\n-\t  tmp_loop.dimen = info->dimen;\n-\t  for (n = 0; n < info->dimen; n++)\n+\t  tmp_loop.dimen = ss->dimen;\n+\t  for (n = 0; n < ss->dimen; n++)\n \t    {\n \t      tmp_loop.to[n] = loopse->loop->to[n];\n \t      tmp_loop.from[n] = loopse->loop->from[n];\n@@ -320,7 +320,7 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \n \t  /* Calculate the offset for the temporary.  */\n \t  offset = gfc_index_zero_node;\n-\t  for (n = 0; n < info->dimen; n++)\n+\t  for (n = 0; n < ss->dimen; n++)\n \t    {\n \t      tmp = gfc_conv_descriptor_stride_get (info->descriptor,\n \t\t\t\t\t\t    gfc_rank_cst[n]);"}, {"sha": "5acab12ad5a32a9d0f9d134c27b146c713cf8a88", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4b9eaebedead8367a14345e1c866a43b870ed8/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4b9eaebedead8367a14345e1c866a43b870ed8/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=cb4b9eaebedead8367a14345e1c866a43b870ed8", "patch": "@@ -113,7 +113,6 @@ gfc_coarray_type;\n \n typedef struct gfc_array_info\n {\n-  int dimen;\n   /* The ref that holds information on this section.  */\n   gfc_ref *ref;\n   /* The descriptor of this array.  */\n@@ -134,10 +133,6 @@ typedef struct gfc_array_info\n   tree end[GFC_MAX_DIMENSIONS];\n   tree stride[GFC_MAX_DIMENSIONS];\n   tree delta[GFC_MAX_DIMENSIONS];\n-\n-  /* Translation from loop dimensions to actual dimensions.\n-     actual_dim = dim[loop_dim]  */\n-  int dim[GFC_MAX_DIMENSIONS];\n }\n gfc_array_info;\n \n@@ -212,9 +207,6 @@ typedef struct gfc_ss\n     /* GFC_SS_TEMP.  */\n     struct\n     {\n-      /* The rank of the temporary.  May be less than the rank of the\n-         assigned expression.  */\n-      int dimen;\n       tree type;\n     }\n     temp;\n@@ -223,6 +215,11 @@ typedef struct gfc_ss\n   }\n   data;\n \n+  int dimen;\n+  /* Translation from loop dimensions to actual array dimensions.\n+     actual_dim = dim[loop_dim]  */\n+  int dim[GFC_MAX_DIMENSIONS];\n+\n   /* All the SS in a loop and linked through loop_chain.  The SS for an\n      expression are linked by the next pointer.  */\n   struct gfc_ss *loop_chain;"}]}