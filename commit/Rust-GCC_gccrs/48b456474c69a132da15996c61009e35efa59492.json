{"sha": "48b456474c69a132da15996c61009e35efa59492", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhiNDU2NDc0YzY5YTEzMmRhMTU5OTZjNjEwMDllMzVlZmE1OTQ5Mg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-07-15T16:15:52Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-07-15T16:15:52Z"}, "message": "decl.c (xref_basetypes): Refactor.\n\n\t* decl.c (xref_basetypes): Refactor.\n\t* tree.c (copy_base_binfos): Replace with ...\n\t(copy_binfo): ... this. Deep copy the given binfo, (not the just\n\tbases of the given base).\n\t* cp-tree.h (copy_base_binfo): Remove.\n\t(copy_binfo): Declare.\n\nFrom-SVN: r84758", "tree": {"sha": "1f7738dc53d2e50f08b65daa6d392613fb4ff028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f7738dc53d2e50f08b65daa6d392613fb4ff028"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48b456474c69a132da15996c61009e35efa59492", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48b456474c69a132da15996c61009e35efa59492", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48b456474c69a132da15996c61009e35efa59492", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48b456474c69a132da15996c61009e35efa59492/comments", "author": null, "committer": null, "parents": [{"sha": "df05a794c1a6b9c0311513c4b1a8f44eeafdf866", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df05a794c1a6b9c0311513c4b1a8f44eeafdf866", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df05a794c1a6b9c0311513c4b1a8f44eeafdf866"}], "stats": {"total": 412, "additions": 200, "deletions": 212}, "files": [{"sha": "c93ce695675e1089935759957aa96c30831835c0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b456474c69a132da15996c61009e35efa59492/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b456474c69a132da15996c61009e35efa59492/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=48b456474c69a132da15996c61009e35efa59492", "patch": "@@ -1,3 +1,12 @@\n+2004-07-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* decl.c (xref_basetypes): Refactor.\n+\t* tree.c (copy_base_binfos): Replace with ...\n+\t(copy_binfo): ... this. Deep copy the given binfo, (not the just\n+\tbases of the given base).\n+\t* cp-tree.h (copy_base_binfo): Remove.\n+\t(copy_binfo): Declare.\n+\n 2004-07-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* name-lookup.c (set_inherited_value_binding_p): Add class_type "}, {"sha": "1e921d823d29b7b55d6a3ec348d2213f4f87e99e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b456474c69a132da15996c61009e35efa59492/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b456474c69a132da15996c61009e35efa59492/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=48b456474c69a132da15996c61009e35efa59492", "patch": "@@ -4145,7 +4145,8 @@ extern void init_tree\t\t\t        (void);\n extern int pod_type_p\t\t\t\t(tree);\n extern int zero_init_p\t\t\t\t(tree);\n extern tree canonical_type_variant              (tree);\n-extern tree copy_base_binfos\t\t\t(tree, tree, tree);\n+extern tree copy_binfo\t\t\t\t(tree, tree, tree,\n+\t\t\t\t\t\t tree *, int);\n extern int member_p\t\t\t\t(tree);\n extern cp_lvalue_kind real_lvalue_p             (tree);\n extern int lvalue_or_else\t\t\t(tree, const char *);"}, {"sha": "6aac5bae5474cfa7bf5085f05b664668946c0268", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 121, "deletions": 150, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b456474c69a132da15996c61009e35efa59492/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b456474c69a132da15996c61009e35efa59492/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=48b456474c69a132da15996c61009e35efa59492", "patch": "@@ -9024,28 +9024,30 @@ xref_tag_from_type (tree old, tree id, int globalize)\n   return xref_tag (tag_kind, id, globalize, false);\n }\n \n-/* REF is a type (named NAME), for which we have just seen some\n-   baseclasses.  BASE_LIST is a list of those baseclasses; the\n-   TREE_PURPOSE is an access_* node, and the TREE_VALUE is the type of\n-   the base-class.  Non-NULL TREE_TYPE indicates virtual inheritance.\n-   CODE_TYPE_NODE indicates whether REF is a class, struct, or\n-   union.  */\n+/* Create the binfo hierarchy for REF with (possibly NULL) base list\n+   BASE_LIST.  For each element on BASE_LIST the TREE_PURPOSE is an\n+   access_* node, and the TREE_VALUE is the type of the base-class.\n+   Non-NULL TREE_TYPE indicates virtual inheritance.  */\n \n void\n xref_basetypes (tree ref, tree base_list)\n {\n-  /* In the declaration `A : X, Y, ... Z' we mark all the types\n-     (A, X, Y, ..., Z) so we can check for duplicates.  */\n   tree *basep;\n-  unsigned max_vbases = 0;\n+  tree binfo;\n+  unsigned max_vbases = 0; /* Maxium direct & indirect virtual bases. */\n+  unsigned max_bases = 0;  /* Maxium direct bases.  */\n   int i;\n-  enum tag_types tag_code;\n+  tree default_access;\n+  tree igo_prev; /* Track Inheritance Graph Order.  */\n \n   if (ref == error_mark_node)\n     return;\n \n-  tag_code = TREE_CODE (ref) == UNION_TYPE ? union_type\n-    : (CLASSTYPE_DECLARED_CLASS (ref) ? class_type : record_type);\n+  /* The base of a derived class is private by default, all others are\n+     public.  */\n+  default_access = (TREE_CODE (ref) == RECORD_TYPE\n+\t\t    && CLASSTYPE_DECLARED_CLASS (ref)\n+\t\t    ? access_private_node : access_public_node);\n \n   /* First, make sure that any templates in base-classes are\n      instantiated.  This ensures that if we call ourselves recursively\n@@ -9061,169 +9063,138 @@ xref_basetypes (tree ref, tree base_list)\n \t/* An incomplete type.  Remove it from the list.  */\n \t*basep = TREE_CHAIN (*basep);\n       else\n-\tbasep = &TREE_CHAIN (*basep);\n+\t{\n+\t  max_bases++;\n+\t  if (TREE_TYPE (*basep))\n+\t    max_vbases++;\n+\t  if (CLASS_TYPE_P (basetype))\n+\t    max_vbases += VEC_length (tree, CLASSTYPE_VBASECLASSES (basetype));\n+\t  basep = &TREE_CHAIN (*basep);\n+\t}\n     }\n \n   SET_CLASSTYPE_MARKED (ref);\n-  i = list_length (base_list);\n+\n   /* The binfo slot should be empty, unless this is an (ill-formed)\n      redefinition.  */\n   my_friendly_assert (!TYPE_BINFO (ref) || TYPE_SIZE (ref), 20040706);\n   my_friendly_assert (TYPE_MAIN_VARIANT (ref) == ref, 20040712);\n-  TYPE_BINFO (ref) = make_tree_binfo (BINFO_LANG_SLOTS);\n-  BINFO_OFFSET (TYPE_BINFO (ref)) = size_zero_node;\n-  BINFO_TYPE (TYPE_BINFO (ref)) = ref;\n   \n-  if (i)\n+  binfo = make_tree_binfo (BINFO_LANG_SLOTS);\n+  TYPE_BINFO (ref) = binfo;\n+  BINFO_OFFSET (binfo) = size_zero_node;\n+  BINFO_TYPE (binfo) = ref;\n+  \n+  if (max_bases)\n+    {\n+      BINFO_BASE_BINFOS (binfo) = make_tree_vec (max_bases);\n+      BINFO_BASE_ACCESSES (binfo) = make_tree_vec (max_bases);\n+      /* An aggregate cannot have baseclasses.  */\n+      CLASSTYPE_NON_AGGREGATE (ref) = 1;\n+      \n+      if (TREE_CODE (ref) == UNION_TYPE)\n+\terror (\"derived union `%T' invalid\", ref);\n+    }\n+      \n+  if (max_bases > 1)\n     {\n-      tree binfo = TYPE_BINFO (ref);\n-      tree binfos = make_tree_vec (i);\n-      tree accesses = make_tree_vec (i);\n+      TYPE_USES_MULTIPLE_INHERITANCE (ref) = 1;\n+      /* If there is more than one non-empty they cannot be at the\n+\t same address.  */\n+      TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref) = 1;\n       \n-      BINFO_BASE_BINFOS (binfo) = binfos;\n-      BINFO_BASE_ACCESSES (binfo) = accesses;\n+      if (TYPE_FOR_JAVA (ref))\n+\terror (\"Java class '%T' cannot have multiple bases\", ref);\n+    }\n   \n-      for (i = 0; base_list; base_list = TREE_CHAIN (base_list))\n-\t{\n-\t  tree access = TREE_PURPOSE (base_list);\n-\t  int via_virtual = TREE_TYPE (base_list) != NULL_TREE;\n-\t  tree basetype = TREE_VALUE (base_list);\n-\t  tree base_binfo;\n-\t  \n-\t  if (via_virtual)\n-\t    max_vbases++;\n-\t  if (access == access_default_node)\n-\t    /* The base of a derived struct is public by default.  */\n-\t    access = (tag_code == class_type\n-\t\t      ? access_private_node : access_public_node);\n-\t  \n-\t  if (basetype && TREE_CODE (basetype) == TYPE_DECL)\n-\t    basetype = TREE_TYPE (basetype);\n-\t  if (!basetype\n-\t      || (TREE_CODE (basetype) != RECORD_TYPE\n-\t\t  && TREE_CODE (basetype) != TYPENAME_TYPE\n-\t\t  && TREE_CODE (basetype) != TEMPLATE_TYPE_PARM\n-\t\t  && TREE_CODE (basetype) != BOUND_TEMPLATE_TEMPLATE_PARM))\n-\t    {\n-\t      error (\"base type `%T' fails to be a struct or class type\",\n-\t\t     basetype);\n-\t      continue;\n-\t    }\n-\t  \n-\t  if (CLASSTYPE_MARKED (basetype))\n-\t    {\n-\t      if (basetype == ref)\n-\t\terror (\"recursive type `%T' undefined\", basetype);\n-\t      else\n-\t\terror (\"duplicate base type `%T' invalid\", basetype);\n-\t      continue;\n-\t    }\n-\t  \n-\t  if (TYPE_FOR_JAVA (basetype)\n-\t      && (current_lang_depth () == 0))\n-\t    TYPE_FOR_JAVA (ref) = 1;\n-\t  \n-\t  if (CLASS_TYPE_P (basetype) && !dependent_type_p (basetype))\n-\t    {\n-\t      base_binfo = TYPE_BINFO (basetype);\n+  if (max_vbases)\n+    {\n+      CLASSTYPE_VBASECLASSES (ref) = VEC_alloc (tree, max_vbases);\n+      TYPE_USES_VIRTUAL_BASECLASSES (ref) = 1;\n+      /* Converting to a virtual base class requires looking up the\n+\t offset of the virtual base.  */\n+      TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref) = 1;\n+      \n+      if (TYPE_FOR_JAVA (ref))\n+\terror (\"Java class '%T' cannot have virtual bases\", ref);\n+    }\n \n-\t      my_friendly_assert (base_binfo, 20040706);\n-\t    }\n-\t  else\n-\t    {\n-\t      base_binfo = make_tree_binfo (BINFO_LANG_SLOTS);\n-\t      \n-\t      BINFO_TYPE (base_binfo) = basetype;\n-\t      BINFO_DEPENDENT_BASE_P (base_binfo) = 1;\n-\t    }\n-\t  \n-\t  TREE_VEC_ELT (binfos, i) = base_binfo;\n-\t  TREE_VEC_ELT (accesses, i) = access;\n-\t  /* This flag will be in the binfo of the base type, we must\n-\t     clear it after copying the base binfos.  */\n-\t  BINFO_VIRTUAL_P (base_binfo) = via_virtual;\n-\t  \n-\t  SET_CLASSTYPE_MARKED (basetype);\n-\t  \n-\t  /* We are free to modify these bits because they are meaningless\n-\t     at top level, and BASETYPE is a top-level type.  */\n-\t  if (via_virtual || TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n-\t    {\n-\t      TYPE_USES_VIRTUAL_BASECLASSES (ref) = 1;\n-\t      /* Converting to a virtual base class requires looking\n-\t     \t up the offset of the virtual base.  */\n-\t      TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref) = 1;\n-\t    }\n+  i = 0;\n+  for (igo_prev = binfo; base_list; base_list = TREE_CHAIN (base_list))\n+    {\n+      tree access = TREE_PURPOSE (base_list);\n+      int via_virtual = TREE_TYPE (base_list) != NULL_TREE;\n+      tree basetype = TREE_VALUE (base_list);\n+      tree base_binfo = NULL_TREE;\n+      \n+      if (access == access_default_node)\n+\taccess = default_access;\n \t  \n-\t  if (CLASS_TYPE_P (basetype))\n-\t    {\n-\t      TYPE_HAS_NEW_OPERATOR (ref)\n-\t\t|= TYPE_HAS_NEW_OPERATOR (basetype);\n-\t      TYPE_HAS_ARRAY_NEW_OPERATOR (ref)\n-\t\t|= TYPE_HAS_ARRAY_NEW_OPERATOR (basetype);\n-\t      TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n-\t      /* If the base-class uses multiple inheritance, so do we.  */\n-\t      TYPE_USES_MULTIPLE_INHERITANCE (ref)\n-\t\t|= TYPE_USES_MULTIPLE_INHERITANCE (basetype);\n-\t      /* Likewise, if converting to a base of the base may require\n-\t     \t code, then we may need to generate code to convert to a\n-\t     \t base as well.  */\n-\t      TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref)\n-\t\t|= TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (basetype);\n-\t      TYPE_HAS_CONVERSION (ref) |= TYPE_HAS_CONVERSION (basetype);\n-\t      max_vbases += VEC_length\n-\t\t(tree, CLASSTYPE_VBASECLASSES (basetype));\n-\t    }\n-\t  i++;\n+      if (TREE_CODE (basetype) == TYPE_DECL)\n+\tbasetype = TREE_TYPE (basetype);\n+      if (TREE_CODE (basetype) != RECORD_TYPE\n+\t  && TREE_CODE (basetype) != TYPENAME_TYPE\n+\t  && TREE_CODE (basetype) != TEMPLATE_TYPE_PARM\n+\t  && TREE_CODE (basetype) != BOUND_TEMPLATE_TEMPLATE_PARM)\n+\t{\n+\t  error (\"base type `%T' fails to be a struct or class type\",\n+\t\t basetype);\n+\t  continue;\n \t}\n-      if (i)\n+      \n+      if (CLASSTYPE_MARKED (basetype))\n \t{\n-\t  TREE_VEC_LENGTH (accesses) = TREE_VEC_LENGTH (binfos) = i;\n-\t  /* An aggregate cannot have baseclasses.  */\n-\t  CLASSTYPE_NON_AGGREGATE (ref) = 1;\n+\t  if (basetype == ref)\n+\t    error (\"recursive type `%T' undefined\", basetype);\n+\t  else\n+\t    error (\"duplicate base type `%T' invalid\", basetype);\n+\t  continue;\n \t}\n-      else\n-\tBINFO_BASE_ACCESSES (binfo) = BINFO_BASE_BINFOS (binfo) = NULL_TREE;\n-      if (max_vbases)\n-\tCLASSTYPE_VBASECLASSES (ref) = VEC_alloc (tree, max_vbases);\n+      SET_CLASSTYPE_MARKED (basetype);\n       \n-      if (i > 1)\n+      if (TYPE_FOR_JAVA (basetype) && (current_lang_depth () == 0))\n+\tTYPE_FOR_JAVA (ref) = 1;\n+\n+      if (CLASS_TYPE_P (basetype) && !dependent_type_p (basetype))\n \t{\n-\t  TYPE_USES_MULTIPLE_INHERITANCE (ref) = 1;\n-\t  /* If there is more than one non-empty they cannot be at the same\n-\t     address.  */\n-\t  TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref) = 1;\n+\t  base_binfo = TYPE_BINFO (basetype);\n+\t  /* The orignal basetype could have been a typedef'd type.  */\n+\t  basetype = BINFO_TYPE (base_binfo);\n+\t  \n+\t  /* Inherit flags from the base.  */\n+\t  TYPE_HAS_NEW_OPERATOR (ref)\n+\t    |= TYPE_HAS_NEW_OPERATOR (basetype);\n+\t  TYPE_HAS_ARRAY_NEW_OPERATOR (ref)\n+\t    |= TYPE_HAS_ARRAY_NEW_OPERATOR (basetype);\n+\t  TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n+\t  TYPE_USES_MULTIPLE_INHERITANCE (ref)\n+\t    |= TYPE_USES_MULTIPLE_INHERITANCE (basetype);\n+\t  TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref)\n+\t    |= TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (basetype);\n+\t  TYPE_HAS_CONVERSION (ref) |= TYPE_HAS_CONVERSION (basetype);\n \t}\n-    }\n-  \n-  /* Copy the base binfos, collect the virtual bases and set the\n-     inheritance order chain.  */\n-  copy_base_binfos (TYPE_BINFO (ref), ref, NULL_TREE);\n+      \n+      base_binfo = copy_binfo (base_binfo, basetype, ref,\n+\t\t\t       &igo_prev, via_virtual);\n+      if (!BINFO_INHERITANCE_CHAIN (base_binfo))\n+\tBINFO_INHERITANCE_CHAIN (base_binfo) = binfo;\n \n-  if (TREE_CODE (ref) == UNION_TYPE)\n-    {\n-      if (i)\n-\terror (\"derived union `%T' invalid\", ref);\n+      TREE_VEC_ELT (BINFO_BASE_ACCESSES (binfo), i) = access;\n+      BINFO_BASE_BINFO (binfo, i) = base_binfo;\n+      i++;\n     }\n \n-  if (TYPE_FOR_JAVA (ref))\n+  if (max_bases)\n     {\n-      if (TYPE_USES_MULTIPLE_INHERITANCE (ref))\n-\terror (\"Java class '%T' cannot have multiple bases\", ref);\n-      if (CLASSTYPE_VBASECLASSES (ref))\n-\terror (\"Java class '%T' cannot have virtual bases\", ref);\n+      /* If any bases were invalid, we will have allocated too many\n+\t slots.  */\n+      TREE_VEC_LENGTH (BINFO_BASE_ACCESSES (binfo)) = i;\n+      TREE_VEC_LENGTH (BINFO_BASE_BINFOS (binfo)) = i;\n     }\n-\n+  \n   /* Unmark all the types.  */\n-  while (i--)\n-    {\n-      tree binfo = BINFO_BASE_BINFO (TYPE_BINFO (ref), i);\n-      tree basetype = BINFO_TYPE (binfo);\n-      \n-      CLEAR_CLASSTYPE_MARKED (basetype);\n-      if (!BINFO_DEPENDENT_BASE_P (binfo))\n-\tBINFO_VIRTUAL_P (TYPE_BINFO (basetype)) = 0;\n-    }\n+  for (i = 0; i != BINFO_N_BASE_BINFOS (binfo); i++)\n+    CLEAR_CLASSTYPE_MARKED (BINFO_TYPE (BINFO_BASE_BINFO (binfo, i)));\n   CLEAR_CLASSTYPE_MARKED (ref);\n }\n "}, {"sha": "4321b8a1a725494370bcaeb1e4b05585f507bc97", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 68, "deletions": 61, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b456474c69a132da15996c61009e35efa59492/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b456474c69a132da15996c61009e35efa59492/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=48b456474c69a132da15996c61009e35efa59492", "patch": "@@ -567,85 +567,92 @@ canonical_type_variant (tree t)\n   return cp_build_qualified_type (TYPE_MAIN_VARIANT (t), cp_type_quals (t));\n }\n \f\n-/* Makes new binfos for the indirect bases under BINFO. T is the most\n-   derived TYPE. PREV is the previous binfo, whose TREE_CHAIN we make\n-   point to this binfo. We return the last BINFO created.\n-\n-   The CLASSTYPE_VBASECLASSES vector of T is constructed in the correct\n-   order.\n+/* Makes a copy of BINFO and TYPE, which is to be inherited into a\n+   graph dominated by T.  If BINFO is NULL, TYPE is a dependent base,\n+   and we do a shallow copy.  If BINFO is non-NULL, we do a deep copy.\n+   VIRT indicates whether TYPE is inherited virtually or not.\n+   IGO_PREV points at the previous binfo of the inheritance graph\n+   order chain.  The newly copied binfo's TREE_CHAIN forms this\n+   ordering.\n+\n+   The CLASSTYPE_VBASECLASSES vector of T is constructed in the\n+   correct order. That is in the order the bases themselves should be\n+   constructed in.\n \n    The BINFO_INHERITANCE of a virtual base class points to the binfo\n-   og the most derived type.\n-\n-   The binfo's TREE_CHAIN is set to inheritance graph order, but bases\n-   for non-class types are not included (i.e. those which are\n-   dependent bases in non-instantiated templates).  */\n+   of the most derived type. ??? We could probably change this so that\n+   BINFO_INHERITANCE becomes synonymous with BINFO_PRIMARY, and hence\n+   remove a field.  They currently can only differ for primary virtual\n+   virtual bases.  */\n \n tree\n-copy_base_binfos (tree binfo, tree t, tree prev)\n+copy_binfo (tree binfo, tree type, tree t, tree *igo_prev, int virt)\n {\n-  tree binfos = BINFO_BASE_BINFOS (binfo);\n-  int n, ix;\n+  tree new_binfo;\n \n-  if (prev)\n-    TREE_CHAIN (prev) = binfo;\n-  prev = binfo;\n+  if (virt)\n+    {\n+      /* See if we've already made this virtual base.  */\n+      new_binfo = binfo_for_vbase (type, t);\n+      if (new_binfo)\n+\treturn new_binfo;\n+    }\n   \n-  if (binfos == NULL_TREE)\n-    return prev;\n+  new_binfo = make_tree_binfo (BINFO_LANG_SLOTS);\n+  BINFO_TYPE (new_binfo) = type;\n \n-  n = TREE_VEC_LENGTH (binfos);\n+  /* Chain it into the inheritance graph.  */\n+  TREE_CHAIN (*igo_prev) = new_binfo;\n+  *igo_prev = new_binfo;\n   \n-  /* Now copy the structure beneath BINFO.  */\n-  for (ix = 0; ix != n; ix++)\n+  if (binfo)\n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, ix);\n-      tree new_binfo = NULL_TREE;\n-\n-      if (BINFO_DEPENDENT_BASE_P (base_binfo))\n+      int ix, n = BINFO_N_BASE_BINFOS (binfo);\n+      \n+      my_friendly_assert (!BINFO_DEPENDENT_BASE_P (binfo), 20040712);\n+      my_friendly_assert (type == BINFO_TYPE (binfo), 20040714);\n+  \n+      BINFO_OFFSET (new_binfo) = BINFO_OFFSET (binfo);\n+      BINFO_VIRTUALS (new_binfo) = BINFO_VIRTUALS (binfo);\n+      \n+      /* Create a new base binfo vector.  */\n+      if (n)\n \t{\n-\t  my_friendly_assert (binfo == TYPE_BINFO (t), 20030204);\n-\t  \n-\t  new_binfo = base_binfo;\n-\t  TREE_CHAIN (prev) = new_binfo;\n-\t  prev = new_binfo;\n-\t  BINFO_INHERITANCE_CHAIN (new_binfo) = binfo;\n-\t  BINFO_DEPENDENT_BASE_P (new_binfo) = 1;\n+\t  BINFO_BASE_BINFOS (new_binfo) = make_tree_vec (n);\n+          /* We do not need to copy the accesses, as they are read only.  */\n+\t  BINFO_BASE_ACCESSES (new_binfo) = BINFO_BASE_ACCESSES (binfo);\n \t}\n-      else if (BINFO_VIRTUAL_P (base_binfo))\n-\tnew_binfo = binfo_for_vbase (BINFO_TYPE (base_binfo), t);\n       \n-      if (!new_binfo)\n+      /* Recursively copy base binfos of BINFO.  */\n+      for (ix = 0; ix != n; ix++)\n \t{\n-\t  new_binfo = make_tree_binfo (BINFO_LANG_SLOTS);\n-\n-\t  BINFO_TYPE (new_binfo) = BINFO_TYPE (base_binfo);\n-\t  BINFO_OFFSET (new_binfo) = BINFO_OFFSET (base_binfo);\n-\t  BINFO_VIRTUALS (new_binfo) = BINFO_VIRTUALS (base_binfo);\n-\n-\t  if (BINFO_BASE_BINFOS (base_binfo))\n-\t    /* Duplicate the binfo's base vector, so we can recurse.  */\n-\t    BINFO_BASE_BINFOS (new_binfo)\n-\t      = copy_node (BINFO_BASE_BINFOS (base_binfo));\n-\t  /* We do not need to copy the accesses, as they are read only.  */\n-\t  BINFO_BASE_ACCESSES (new_binfo) = BINFO_BASE_ACCESSES (base_binfo);\n+\t  tree base_binfo = BINFO_BASE_BINFO (binfo, ix);\n+\t  tree new_base_binfo;\n+\t  \n+\t  my_friendly_assert (!BINFO_DEPENDENT_BASE_P (base_binfo), 20040713);\n+\t  new_base_binfo = copy_binfo (base_binfo, BINFO_TYPE (base_binfo),\n+\t\t\t\t       t, igo_prev,\n+\t\t\t\t       BINFO_VIRTUAL_P (base_binfo));\n \t  \n-\t  prev = copy_base_binfos (new_binfo, t, prev);\n-\t  if (BINFO_VIRTUAL_P (base_binfo))\n-\t    {\n-\t      VEC_quick_push (tree, CLASSTYPE_VBASECLASSES (t), new_binfo);\n-\t      BINFO_VIRTUAL_P (new_binfo) = 1;\n-\t      BINFO_INHERITANCE_CHAIN (new_binfo) = TYPE_BINFO (t);\n-\t    }\n-\t  else\n-\t    BINFO_INHERITANCE_CHAIN (new_binfo) = binfo;\n+\t  if (!BINFO_INHERITANCE_CHAIN (new_base_binfo))\n+\t    BINFO_INHERITANCE_CHAIN (new_base_binfo) = new_binfo;\n+\t  BINFO_BASE_BINFO (new_binfo, ix) = new_base_binfo;\n \t}\n-      TREE_VEC_ELT (binfos, ix) = new_binfo;\n     }\n-\n-  return prev;\n+  else\n+    BINFO_DEPENDENT_BASE_P (new_binfo) = 1;\n+  \n+  if (virt)\n+    {\n+      /* Push it onto the list after any virtual bases it contains\n+\t will have been pushed.  */\n+      VEC_quick_push (tree, CLASSTYPE_VBASECLASSES (t), new_binfo);\n+      BINFO_VIRTUAL_P (new_binfo) = 1;\n+      BINFO_INHERITANCE_CHAIN (new_binfo) = TYPE_BINFO (t);\n+    }\n+  \n+  return new_binfo;\n }\n-\n \f\n /* Hashing of lists so that we don't make duplicates.\n    The entry point is `list_hash_canon'.  */"}]}