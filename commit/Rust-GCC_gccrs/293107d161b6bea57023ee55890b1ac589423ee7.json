{"sha": "293107d161b6bea57023ee55890b1ac589423ee7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkzMTA3ZDE2MWI2YmVhNTcwMjNlZTU1ODkwYjFhYzU4OTQyM2VlNw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-04-27T03:50:27Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-04-27T03:50:27Z"}, "message": "varasm.c (output_constant_def): Split out two new static functions...\n\n\t* varasm.c (output_constant_def): Split out two new static\n\tfunctions, build_constant_desc and maybe_output_constant_def_contents.\n\tRestructure for comprehensibility.  Don't call\n\toutput_addressed_constants.  Treat defstr being non-NULL for\n\tSTRING_POOL_ADDRESS_P constants as an invariant.\n\t(struct deferred_string): Remove labelno field.\n\t(output_constant_def_contents): Kill labelno argument.  Call\n\toutput_addressed_constants here.  Use ASM_OUTPUT_LABEL, not\n\tasm_out.internal_label.\n\t(mark_constant): Update call to output_constant_def_contents.\n\tTreat defstr being non-NULL for STRING_POOL_ADDRESS_P\n\tconstants as an invariant.\n\nFrom-SVN: r66129", "tree": {"sha": "f60a97654206225b2632896d83ee4a02b479e9d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f60a97654206225b2632896d83ee4a02b479e9d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/293107d161b6bea57023ee55890b1ac589423ee7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/293107d161b6bea57023ee55890b1ac589423ee7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/293107d161b6bea57023ee55890b1ac589423ee7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/293107d161b6bea57023ee55890b1ac589423ee7/comments", "author": null, "committer": null, "parents": [{"sha": "12969f45d3d34a5555fbce2c7ac9445950d68350", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12969f45d3d34a5555fbce2c7ac9445950d68350", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12969f45d3d34a5555fbce2c7ac9445950d68350"}], "stats": {"total": 344, "additions": 185, "deletions": 159}, "files": [{"sha": "66aec014742d94c1b93bae8e67385d9c8440abb2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 71, "deletions": 56, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/293107d161b6bea57023ee55890b1ac589423ee7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/293107d161b6bea57023ee55890b1ac589423ee7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=293107d161b6bea57023ee55890b1ac589423ee7", "patch": "@@ -1,3 +1,18 @@\n+2003-04-26  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* varasm.c (output_constant_def): Split out two new static\n+\tfunctions, build_constant_desc and maybe_output_constant_def_contents.\n+\tRestructure for comprehensibility.  Don't call\n+\toutput_addressed_constants.  Treat defstr being non-NULL for\n+\tSTRING_POOL_ADDRESS_P constants as an invariant.\n+\t(struct deferred_string): Remove labelno field.\n+\t(output_constant_def_contents): Kill labelno argument. Call\n+\toutput_addressed_constants here.  Use ASM_OUTPUT_LABEL,\tnot\n+\tasm_out.internal_label.\n+\t(mark_constant): Update call to\toutput_constant_def_contents.\n+\tTreat defstr being non-NULL for STRING_POOL_ADDRESS_P\n+\tconstants as an invariant.\n+\n 2003-04-26  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (output_pic_addr_const): Use SYMBOL_REF_LOCAL_P.\n@@ -88,9 +103,9 @@\n \n 2003-04-25  Richard Henderson  <rth@redhat.com>\n \n-        PR opt/10315 \n-        * config/rs6000/rs6000.c (rs6000_emit_move): Only elide proper\n-        checks during reload; use validize_mem instead of adjust_address.\n+\tPR opt/10315\n+\t* config/rs6000/rs6000.c (rs6000_emit_move): Only elide proper\n+\tchecks during reload; use validize_mem instead of adjust_address.\n \n 2003-04-26  Ben Elliston  <bje@wasabisystems.com>\n \n@@ -115,14 +130,14 @@\n 2003-04-24  Alexander Kabaev <kan@FreeBSD.ORG>\n \n \t* config/sparc/sparc.md (umulsidi3, mulsidi3): Avoid using\n-\tconst_umulsidi3_sp32 and const_mulsidi3_sp32 on 64bit targets \n+\tconst_umulsidi3_sp32 and const_mulsidi3_sp32 on 64bit targets\n \twhere they might be not present. Use their _sp64 equivalent\n \tinstead.\n \n Thu Apr 24 20:42:12 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (cvtsi2sdq): Fix typo in previous patch.\n-\t\n+\n 2003-04-24  Krister Walfridsson  <cato@df.lth.se>\n \n \t* configure.in: Check whether mbstowcs works.\n@@ -156,7 +171,7 @@ Thu Apr 24 16:55:26 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \tPR c/10308\n \t* reload.c (find_reloads_address_1): Reload plus at the place of\n \tindex register.\n-\t\n+\n 2003-04-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tNew GCOV_TAG_FUNCTION layout\n@@ -334,14 +349,14 @@ Thu Apr 24 16:55:26 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-04-22  Richard Henderson  <rth@redhat.com>\n \n-        PR 8866\n-        * rtl.h (MEM_NOTRAP_P): New.\n-        (MEM_COPY_ATTRIBUTES): Copy it.\n-        * rtlanal.c (may_trap_p): Check it.\n-        * expr.c (do_tablejump): Set it.\n+\tPR 8866\n+\t* rtl.h (MEM_NOTRAP_P): New.\n+\t(MEM_COPY_ATTRIBUTES): Copy it.\n+\t* rtlanal.c (may_trap_p): Check it.\n+\t* expr.c (do_tablejump): Set it.\n \t* doc/rtl.texi (Flags): Document it.\n \n-        * cfgrtl.c (try_redirect_by_replacing_jump): Revert last three changes.\n+\t* cfgrtl.c (try_redirect_by_replacing_jump): Revert last three changes.\n \n 2003-04-22  Olivier Hainque  <hainque@act-europe.fr>\n \n@@ -350,12 +365,12 @@ Thu Apr 24 16:55:26 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-04-22  Vincent Celier <celier@gnat.com>\n \n-        * gthr-gnat.h, gthr-gnat.c: new sources for implementation of\n-        --enable-threads=gnat.\n-        * Makefile.in: Add gthr-gnat.c to LIB2ADDEH.\n-        * configure.in: Add gnat to the list of thread packages\n-        * configure: Rebuild.\n-        * config/t-linux: Add gthr-gnat.c to LIB2ADDEH and LIB2ADDEHDEP\n+\t* gthr-gnat.h, gthr-gnat.c: new sources for implementation of\n+\t--enable-threads=gnat.\n+\t* Makefile.in: Add gthr-gnat.c to LIB2ADDEH.\n+\t* configure.in: Add gnat to the list of thread packages\n+\t* configure: Rebuild.\n+\t* config/t-linux: Add gthr-gnat.c to LIB2ADDEH and LIB2ADDEHDEP\n \n 2003-04-22  Neil Booth  <neil@daikokuya.co.uk>\n \n@@ -366,7 +381,7 @@ Thu Apr 24 16:55:26 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \t* cpptrad.c (_cpp_replacement_text_len): Add check for macro\n \tparameter count.\n \t(_cpp_copy_replacement_text): Same.\n-\t\n+\n 2003-04-22  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* c-lex.c (c_lex): Handle CPP_OTHER differently.\n@@ -397,9 +412,9 @@ Thu Apr 24 16:55:26 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-04-22  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/t-spe: Merge in t-fprules into file.\n+\t* config/rs6000/t-spe: Merge in t-fprules into file.\n \n-        * config.gcc: Add t-spe to powerpc-eabispe.\n+\t* config.gcc: Add t-spe to powerpc-eabispe.\n \n 2003-04-22  Kean Johnston  <jkj@sco.com>\n \n@@ -433,8 +448,8 @@ Thu Apr 24 16:55:26 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-04-21  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/rs6000.c (rs6000_override_options): No SPE means\n-        64-bit long doubles.\n+\t* config/rs6000/rs6000.c (rs6000_override_options): No SPE means\n+\t64-bit long doubles.\n \n 2003-04-21  Olivier Hainque  <hainque@act-europe.fr>\n \n@@ -446,7 +461,7 @@ Thu Apr 24 16:55:26 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \tnested subprograms.\n \n \t* expmed.c (extract_bit_field): Reverse operands of && condition to\n-        prevent a potential division by zero in the previously first branch.\n+\tprevent a potential division by zero in the previously first branch.\n \t* config/pa/pa.md (extv, extzv): FAIL if the bitfield length is zero.\n \n 2003-04-21  Joel Brobecker  <brobecker@gnat.com>\n@@ -458,34 +473,34 @@ Thu Apr 24 16:55:26 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n \n-        Break out coverage routines to new file.\n-        * Makefile.in (COVERAGE_H): New variable\n-        (C_OBJS): Add coverage.o\n-        (coverage.o): New target.\n-        (profile.o, loop-init.o, sched-ebb.o, predict.o, tracer.o): Adjust\n-        dependencies.\n-        (GTFILES): Adjust.\n-        (gt-coverage.h): New target.\n-        (gt-profile.h): Remove.\n-        * profile.h: Remove. Move to ...\n-        * coverage.h: ... here. New. #include gcov-io.h.\n-        * gcov-io.h: Move function definitions to ...\n-        * gcov-io.c: ... here. New.\n-        * profile.c: Move coverage routines to coverage.c.\n-        (instrument_edges, get_exec_counts, branch_prob, init_branch_prob,\n-        end_branch_prob): Adjust.\n-        * coverage.c: New. Coverage routines from profile.c\n-        (coverage_counter_ref, coverage_init, coverage_finish,\n-        coverage_end_function, coverage_begin_output,\n-        coverage_counter_ref, get_coverage_counts): Define.\n-        * gcov-dump.c, gcov.c: #include gcov-io.c.\n-        * libgcov.c: Likewise. Adjust.\n-        * loop-init.c: Don't #include profile.h\n-        * tracer.c, predict.c, sched-ebb.c: Adjust #includes.\n-        * rtl.h: Add coverage prototypes.\n-        * toplev.c (compile_file): Init coverage, not branch_prob.\n-        Always call coverage_finish.\n-        (rest_of_compilation): Call coverage_end_function.\n+\tBreak out coverage routines to new file.\n+\t* Makefile.in (COVERAGE_H): New variable\n+\t(C_OBJS): Add coverage.o\n+\t(coverage.o): New target.\n+\t(profile.o, loop-init.o, sched-ebb.o, predict.o, tracer.o): Adjust\n+\tdependencies.\n+\t(GTFILES): Adjust.\n+\t(gt-coverage.h): New target.\n+\t(gt-profile.h): Remove.\n+\t* profile.h: Remove. Move to ...\n+\t* coverage.h: ... here. New. #include gcov-io.h.\n+\t* gcov-io.h: Move function definitions to ...\n+\t* gcov-io.c: ... here. New.\n+\t* profile.c: Move coverage routines to coverage.c.\n+\t(instrument_edges, get_exec_counts, branch_prob, init_branch_prob,\n+\tend_branch_prob): Adjust.\n+\t* coverage.c: New. Coverage routines from profile.c\n+\t(coverage_counter_ref, coverage_init, coverage_finish,\n+\tcoverage_end_function, coverage_begin_output,\n+\tcoverage_counter_ref, get_coverage_counts): Define.\n+\t* gcov-dump.c, gcov.c: #include gcov-io.c.\n+\t* libgcov.c: Likewise. Adjust.\n+\t* loop-init.c: Don't #include profile.h\n+\t* tracer.c, predict.c, sched-ebb.c: Adjust #includes.\n+\t* rtl.h: Add coverage prototypes.\n+\t* toplev.c (compile_file): Init coverage, not branch_prob.\n+\tAlways call coverage_finish.\n+\t(rest_of_compilation): Call coverage_end_function.\n \n 2003-04-21  Matt Kraai  <kraai@alumni.cmu.edu>\n \n@@ -506,10 +521,10 @@ Thu Apr 24 16:55:26 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \t* cpplib.h (struct cpp_callbacks): Change prototype of include.\n \n 2003-04-21  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n-\t\n+\n \t* doc/rtl.texi (RTX_UNCHANGING_P): Point to true_dependence for\n \tdetails of conflict handling.\n-\t\n+\n \t* fold-const.c (extract_muldiv, case CONVERT_EXPR): Detect case\n \twhen conversion overflows.\n \n@@ -525,7 +540,7 @@ Thu Apr 24 16:55:26 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-04-21  Andreas Jaeger  <aj@suse.de>\n \n-        * cppcharset.c (_cpp_valid_ucn): Cast field precision to int.\n+\t* cppcharset.c (_cpp_valid_ucn): Cast field precision to int.\n \n 2003-04-20  Chris Lattner  <sabre@nondot.org>\n \t    Zack Weinberg  <zack@codesourcery.com>\n@@ -921,7 +936,7 @@ Fri Apr 18 01:28:51 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* emit-rtl.c (subreg_hard_regno):  Check that register is\n \trepresentable.\n-\t\n+\n \t* reload.c (reload_inner_reg_of_subreg):  When register is not\n \trepresentable, reload the whole thing.\n \t(find_reloads): Likewsie."}, {"sha": "82a3e15486c7c1ce6387c211c99a653214a48bf7", "filename": "gcc/varasm.c", "status": "modified", "additions": 114, "deletions": 103, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/293107d161b6bea57023ee55890b1ac589423ee7/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/293107d161b6bea57023ee55890b1ac589423ee7/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=293107d161b6bea57023ee55890b1ac589423ee7", "patch": "@@ -142,7 +142,8 @@ static unsigned int const_hash\t\tPARAMS ((tree));\n static unsigned int const_hash_1\tPARAMS ((tree));\n static int compare_constant\t\tPARAMS ((tree, tree));\n static tree copy_constant\t\tPARAMS ((tree));\n-static void output_constant_def_contents  PARAMS ((tree, int, int));\n+static void maybe_output_constant_def_contents PARAMS ((tree, rtx, int));\n+static void output_constant_def_contents  PARAMS ((tree, const char *));\n static void decode_rtx_const\t\tPARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t       struct rtx_const *));\n static unsigned int const_hash_rtx\tPARAMS ((enum machine_mode, rtx));\n@@ -2164,6 +2165,8 @@ struct constant_descriptor_tree GTY(())\n static GTY(()) struct constant_descriptor_tree *\n   const_hash_table[MAX_HASH_TABLE];\n \n+static struct constant_descriptor_tree * build_constant_desc PARAMS ((tree));\n+\n /* We maintain a hash table of STRING_CST values.  Unless we are asked to force\n    out a string constant, we defer output of the constants until we know\n    they are actually used.  This will be if something takes its address or if\n@@ -2175,7 +2178,6 @@ struct deferred_string GTY(())\n {\n   const char *label;\n   tree exp;\n-  int labelno;\n };\n \n static GTY ((param_is (struct deferred_string))) htab_t const_str_htab;\n@@ -2533,6 +2535,51 @@ copy_constant (exp)\n     }\n }\n \f\n+/* Subroutine of output_constant_def:\n+   No constant equal to EXP is known to have been output.\n+   Make a constant descriptor to enter EXP in the hash table.\n+   Assign the label number and construct RTL to refer to the\n+   constant's location in memory.\n+   Caller is responsible for updating the hash table.  */\n+\n+static struct constant_descriptor_tree *\n+build_constant_desc (exp)\n+     tree exp;\n+{\n+  rtx symbol;\n+  rtx rtl;\n+  char label[256];\n+  int labelno;\n+  struct constant_descriptor_tree *desc;\n+\n+  desc = ggc_alloc (sizeof (*desc));\n+  desc->value = copy_constant (exp);\n+\n+  /* Create a string containing the label name, in LABEL.  */\n+  labelno = const_labelno++;\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", labelno);\n+\n+  /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n+  symbol = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label));\n+  SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_LOCAL;\n+\n+  rtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)), symbol);\n+  set_mem_attributes (rtl, exp, 1);\n+  set_mem_alias_set (rtl, 0);\n+  set_mem_alias_set (rtl, const_alias_set);\n+\n+  /* Set flags or add text to the name to record information, such as\n+     that it is a local symbol.  If the name is changed, the macro\n+     ASM_OUTPUT_LABELREF will have to know how to strip this\n+     information.  */\n+  (*targetm.encode_section_info) (exp, rtl, true);\n+\n+  desc->rtl = rtl;\n+  desc->label = XSTR (XEXP (desc->rtl, 0), 0);\n+\n+  return desc;\n+}\n+\n /* Return an rtx representing a reference to constant data in memory\n    for the constant expression EXP.\n \n@@ -2554,146 +2601,109 @@ output_constant_def (exp, defer)\n {\n   int hash;\n   struct constant_descriptor_tree *desc;\n-  struct deferred_string **defstr;\n-  char label[256];\n-  int reloc;\n-  int found = 1;\n-  int labelno = -1;\n-  rtx rtl;\n \n   /* We can't just use the saved RTL if this is a deferred string constant\n      and we are not to defer anymore.  */\n   if (TREE_CODE (exp) != INTEGER_CST && TREE_CST_RTL (exp)\n       && (defer || !STRING_POOL_ADDRESS_P (XEXP (TREE_CST_RTL (exp), 0))))\n     return TREE_CST_RTL (exp);\n \n-  /* Make sure any other constants whose addresses appear in EXP\n-     are assigned label numbers.  */\n-\n-  reloc = output_addressed_constants (exp);\n-\n   /* Compute hash code of EXP.  Search the descriptors for that hash code\n      to see if any of them describes EXP.  If yes, the descriptor records\n      the label number already assigned.  */\n \n   hash = const_hash (exp);\n-\n   for (desc = const_hash_table[hash]; desc; desc = desc->next)\n     if (compare_constant (exp, desc->value))\n       break;\n \n   if (desc == 0)\n     {\n-      rtx symbol;\n-\n-      /* No constant equal to EXP is known to have been output.\n-\t Make a constant descriptor to enter EXP in the hash table.\n-\t Assign the label number and record it in the descriptor for\n-\t future calls to this function to find.  */\n-\n-      /* Create a string containing the label name, in LABEL.  */\n-      labelno = const_labelno++;\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", labelno);\n-\n-      desc = ggc_alloc (sizeof (*desc));\n+      desc = build_constant_desc (exp);\n       desc->next = const_hash_table[hash];\n-      desc->label = ggc_strdup (label);\n-      desc->value = copy_constant (exp);\n       const_hash_table[hash] = desc;\n \n-      /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n-      symbol = gen_rtx_SYMBOL_REF (Pmode, desc->label);\n-      SYMBOL_REF_FLAGS (symbol) = SYMBOL_FLAG_LOCAL;\n-\n-      rtl = desc->rtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)), symbol);\n+      maybe_output_constant_def_contents (exp, desc->rtl, defer);\n+    }\n+  else if (!defer && STRING_POOL_ADDRESS_P (XEXP (desc->rtl, 0)))\n+    {\n+      /* If the string is currently deferred but we need to output it\n+\t now, remove it from the deferred string hash table.  */\n+      struct deferred_string **defstr;\n \n-      set_mem_attributes (rtl, exp, 1);\n-      set_mem_alias_set (rtl, 0);\n-      set_mem_alias_set (rtl, const_alias_set);\n+      defstr = (struct deferred_string **)\n+\thtab_find_slot_with_hash (const_str_htab, desc->label,\n+\t\t\t\t  STRHASH (desc->label), NO_INSERT);\n+#ifdef ENABLE_CHECKING\n+      if (!defstr)\n+\tabort ();\n+#endif\n \n-      found = 0;\n+      STRING_POOL_ADDRESS_P (XEXP (desc->rtl, 0)) = 0;\n+      htab_clear_slot (const_str_htab, (void **) defstr);\n+      maybe_output_constant_def_contents (exp, desc->rtl, 0);\n     }\n-  else\n-    rtl = desc->rtl;\n \n-  if (TREE_CODE (exp) != INTEGER_CST)\n-    TREE_CST_RTL (exp) = rtl;\n+  TREE_CST_RTL (exp) = desc->rtl;\n+  return desc->rtl;\n+}\n \n-  /* Optionally set flags or add text to the name to record information\n-     such as that it is a function name.  If the name is changed, the macro\n-     ASM_OUTPUT_LABELREF will have to know how to strip this information.  */\n-  /* A previously-processed constant would already have section info\n-     encoded in it.  */\n-  if (! found)\n-    {\n-      (*targetm.encode_section_info) (exp, rtl, true);\n+/* Subroutine of output_constant_def:\n+   Decide whether or not to defer the output of EXP, which can be\n+   accesed through rtl RTL, and either do the output or record EXP in\n+   the table of deferred strings.  */\n+static void\n+maybe_output_constant_def_contents (exp, rtl, defer)\n+     tree exp;\n+     rtx rtl;\n+     int defer;\n+{\n+  const char *label;\n \n-      desc->rtl = rtl;\n-      desc->label = XSTR (XEXP (desc->rtl, 0), 0);\n-    }\n+  if (flag_syntax_only)\n+    return;\n \n-  if (found && !defer && STRING_POOL_ADDRESS_P (XEXP (rtl, 0)))\n+  label = XSTR (XEXP (rtl, 0), 0);\n+\n+  if (defer && TREE_CODE (exp) == STRING_CST && !flag_writable_strings)\n     {\n+      struct deferred_string **defstr;\n       defstr = (struct deferred_string **)\n-\thtab_find_slot_with_hash (const_str_htab, desc->label,\n-\t\t\t\t  STRHASH (desc->label), NO_INSERT);\n+\thtab_find_slot_with_hash (const_str_htab, label,\n+\t\t\t\t  STRHASH (label), INSERT);\n       if (defstr)\n \t{\n-\t  /* If the string is currently deferred but we need to output it now,\n-\t     remove it from deferred string hash table.  */\n-\t  found = 0;\n-\t  labelno = (*defstr)->labelno;\n-\t  STRING_POOL_ADDRESS_P (XEXP (rtl, 0)) = 0;\n-\t  htab_clear_slot (const_str_htab, (void **) defstr);\n-\t}\n-    }\n+\t  struct deferred_string *p;\n \n-  /* If this is the first time we've seen this particular constant,\n-     output it.  Do no output if -fsyntax-only.  */\n-  if (! found && ! flag_syntax_only)\n-    {\n-      if (!defer || TREE_CODE (exp) != STRING_CST\n-\t  || flag_writable_strings)\n-\toutput_constant_def_contents (exp, reloc, labelno);\n-      else\n-\t{\n-\t  defstr = (struct deferred_string **)\n-\t    htab_find_slot_with_hash (const_str_htab, desc->label,\n-\t\t\t\t      STRHASH (desc->label), INSERT);\n-\t  if (!defstr)\n-\t    output_constant_def_contents (exp, reloc, labelno);\n-\t  else\n-\t    {\n-\t      struct deferred_string *p;\n+\t  p = (struct deferred_string *)\n+\t    ggc_alloc (sizeof (struct deferred_string));\n \n-\t      p = (struct deferred_string *)\n-\t\tggc_alloc (sizeof (struct deferred_string));\n+\t  p->exp = exp;\n+\t  p->label = label;\n \n-\t      p->exp = desc->value;\n-\t      p->label = desc->label;\n-\t      p->labelno = labelno;\n-\t      *defstr = p;\n-\t      STRING_POOL_ADDRESS_P (XEXP (rtl, 0)) = 1;\n-\t    }\n+\t  *defstr = p;\n+\t  STRING_POOL_ADDRESS_P (XEXP (rtl, 0)) = 1;\n+\t  return;\n \t}\n     }\n \n-  return rtl;\n+  output_constant_def_contents (exp, label);\n }\n \n /* Now output assembler code to define the label for EXP,\n    and follow it with the data of EXP.  */\n \n static void\n-output_constant_def_contents (exp, reloc, labelno)\n+output_constant_def_contents (exp, label)\n      tree exp;\n-     int reloc;\n-     int labelno;\n+     const char *label;\n {\n-  int align;\n+  /* Make sure any other constants whose addresses appear in EXP\n+     are assigned label numbers.  */\n+  int reloc = output_addressed_constants (exp);\n \n   /* Align the location counter as required by EXP's data type.  */\n-  align = TYPE_ALIGN (TREE_TYPE (exp));\n+  int align = TYPE_ALIGN (TREE_TYPE (exp));\n #ifdef CONSTANT_ALIGNMENT\n   align = CONSTANT_ALIGNMENT (exp, align);\n #endif\n@@ -2709,7 +2719,7 @@ output_constant_def_contents (exp, reloc, labelno)\n     }\n \n   /* Output the label itself.  */\n-  (*targetm.asm_out.internal_label) (asm_out_file, \"LC\", labelno);\n+  ASM_OUTPUT_LABEL (asm_out_file, label);\n \n   /* Output the value of EXP.  */\n   output_constant (exp,\n@@ -3521,19 +3531,20 @@ mark_constant (current_rtx, data)\n \t}\n       else if (STRING_POOL_ADDRESS_P (x))\n \t{\n-\t  struct deferred_string **defstr;\n+\t  struct deferred_string *p, **defstr;\n \n \t  defstr = (struct deferred_string **)\n \t    htab_find_slot_with_hash (const_str_htab, XSTR (x, 0),\n \t\t\t\t      STRHASH (XSTR (x, 0)), NO_INSERT);\n-\t  if (defstr)\n-\t    {\n-\t      struct deferred_string *p = *defstr;\n+#ifdef ENABLE_CHECKING\n+\t  if (!defstr)\n+\t    abort ();\n+#endif\n \n-\t      STRING_POOL_ADDRESS_P (x) = 0;\n-\t      output_constant_def_contents (p->exp, 0, p->labelno);\n-\t      htab_clear_slot (const_str_htab, (void **) defstr);\n-\t    }\n+\t  p = *defstr;\n+\t  STRING_POOL_ADDRESS_P (x) = 0;\n+\t  output_constant_def_contents (p->exp, p->label);\n+\t  htab_clear_slot (const_str_htab, (void **) defstr);\n \t}\n     }\n   return 0;"}]}