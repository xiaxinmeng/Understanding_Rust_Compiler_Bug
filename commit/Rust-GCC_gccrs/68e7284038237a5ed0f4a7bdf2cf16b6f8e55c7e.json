{"sha": "68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhlNzI4NDAzODIzN2E1ZWQwZjRhN2JkZjJjZjE2YjZmOGU1NWM3ZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-05-02T12:57:10Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-05-02T12:57:10Z"}, "message": "re PR middle-end/53153 (ice in tree_low_cst, at tree.c:6569)\n\ngcc/\n\tPR middle-end/53153\n\t* gimplify.c (preprocess_case_label_vec_for_gimple): New function,\n\tsplit out from ...\n\t(gimplify_switch_expr): ... here.\n\t* gimple.h (preprocess_case_label_vec_for_gimple): Add prototype.\n\t* tree-ssa-forwprop.c (simplify_gimple_switch_label_vec): New function\n\tto clean up case labels with values outside the index type range.\n\t(simplify_gimple_switch): Call it if something changed.\n\tRemove strange and unnecessary assert.\n\ntestsuite/\n\tPR middle-end/53153\n\t* gcc.dg/pr53153.c: New test.\n\nFrom-SVN: r187048", "tree": {"sha": "b7785a15881f825f1471e07b5eba334ae18d62ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7785a15881f825f1471e07b5eba334ae18d62ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e/comments", "author": null, "committer": null, "parents": [{"sha": "69416e98ff5d226210fefc00e91451269036f928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69416e98ff5d226210fefc00e91451269036f928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69416e98ff5d226210fefc00e91451269036f928"}], "stats": {"total": 485, "additions": 335, "deletions": 150}, "files": [{"sha": "a37a5b4a88b1fe3cbf135542f397982006bed1f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e", "patch": "@@ -1,3 +1,15 @@\n+2012-05-02  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR middle-end/53153\n+\t* gimplify.c (preprocess_case_label_vec_for_gimple): New function,\n+\tsplit out from ...\n+\t(gimplify_switch_expr): ... here.\n+\t* gimple.h (preprocess_case_label_vec_for_gimple): Add prototype.\n+\t* tree-ssa-forwprop.c (simplify_gimple_switch_label_vec): New function\n+\tto clean up case labels with values outside the index type range.\n+\t(simplify_gimple_switch): Call it if something changed.\n+\tRemove strange and unnecessary assert.\n+\n 2012-05-02  Richard Guenther  <rguenther@suse.de>\n \n \t* fold-const.c (div_if_zero_remainder): sizetypes no longer"}, {"sha": "e0f8660fba3c6d267ac759f5161b2bb562326aa3", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e", "patch": "@@ -922,6 +922,7 @@ gimple gimple_build_transaction (gimple_seq, tree);\n gimple gimple_build_predict (enum br_predictor, enum prediction);\n enum gimple_statement_structure_enum gss_for_assign (enum tree_code);\n void sort_case_labels (VEC(tree,heap) *);\n+void preprocess_case_label_vec_for_gimple (VEC(tree,heap) *, tree, tree *);\n void gimple_set_body (tree, gimple_seq);\n gimple_seq gimple_body (tree);\n bool gimple_has_body_p (tree);"}, {"sha": "c021fa1a38672c5b87ffece51a67d40bc4aa2516", "filename": "gcc/gimplify.c", "status": "modified", "additions": 182, "deletions": 146, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e", "patch": "@@ -1538,7 +1538,7 @@ gimplify_statement_list (tree *expr_p, gimple_seq *pre_p)\n \n   return GS_ALL_DONE;\n }\n-\n+\f\n /* Compare two case labels.  Because the front end should already have\n    made sure that case ranges do not overlap, it is enough to only compare\n    the CASE_LOW values of each case label.  */\n@@ -1565,8 +1565,179 @@ sort_case_labels (VEC(tree,heap)* label_vec)\n {\n   VEC_qsort (tree, label_vec, compare_case_labels);\n }\n+\f\n+/* Prepare a vector of case labels to be used in a GIMPLE_SWITCH statement.\n+\n+   LABELS is a vector that contains all case labels to look at.\n+\n+   INDEX_TYPE is the type of the switch index expression.  Case labels\n+   in LABELS are discarded if their values are not in the value range\n+   covered by INDEX_TYPE.  The remaining case label values are folded\n+   to INDEX_TYPE.\n+\n+   If a default case exists in LABELS, it is removed from LABELS and\n+   returned in DEFAULT_CASEP.  If no default case exists, but the\n+   case labels already cover the whole range of INDEX_TYPE, a default\n+   case is returned pointing to one of the existing case labels.\n+   Otherwise DEFAULT_CASEP is set to NULL_TREE.\n+\n+   DEFAULT_CASEP may be NULL, in which case the above comment doesn't\n+   apply and no action is taken regardless of whether a default case is\n+   found or not.  */\n+\n+void\n+preprocess_case_label_vec_for_gimple (VEC(tree,heap) *labels,\n+\t\t\t\t      tree index_type,\n+\t\t\t\t      tree *default_casep)\n+{\n+  tree min_value, max_value;\n+  tree default_case = NULL_TREE;\n+  size_t i, len;\n+\n+  i = 0;\n+  min_value = TYPE_MIN_VALUE (index_type);\n+  max_value = TYPE_MAX_VALUE (index_type);\n+  while (i < VEC_length (tree, labels))\n+    {\n+      tree elt = VEC_index (tree, labels, i);\n+      tree low = CASE_LOW (elt);\n+      tree high = CASE_HIGH (elt);\n+      bool remove_element = FALSE;\n \n-/* Gimplify a SWITCH_EXPR, and collect a TREE_VEC of the labels it can\n+      if (low)\n+\t{\n+\t  gcc_checking_assert (TREE_CODE (low) == INTEGER_CST);\n+\t  gcc_checking_assert (!high || TREE_CODE (high) == INTEGER_CST);\n+\n+\t  /* This is a non-default case label, i.e. it has a value.\n+\n+\t     See if the case label is reachable within the range of\n+\t     the index type.  Remove out-of-range case values.  Turn\n+\t     case ranges into a canonical form (high > low strictly)\n+\t     and convert the case label values to the index type.\n+\n+\t     NB: The type of gimple_switch_index() may be the promoted\n+\t     type, but the case labels retain the original type.  */\n+\n+\t  if (high)\n+\t    {\n+\t      /* This is a case range.  Discard empty ranges.\n+\t\t If the bounds or the range are equal, turn this\n+\t\t into a simple (one-value) case.  */\n+\t      int cmp = tree_int_cst_compare (high, low);\n+\t      if (cmp < 0)\n+\t\tremove_element = TRUE;\n+\t      else if (cmp == 0)\n+\t\thigh = NULL_TREE;\n+\t    }\n+\n+\t  if (! high)\n+\t    {\n+\t      /* If the simple case value is unreachable, ignore it.  */\n+\t      if ((TREE_CODE (min_value) == INTEGER_CST\n+\t\t   && tree_int_cst_compare (low, min_value) < 0)\n+\t\t  || (TREE_CODE (max_value) == INTEGER_CST\n+\t\t      && tree_int_cst_compare (low, max_value) > 0))\n+\t\tremove_element = TRUE;\n+\t      else\n+\t\tlow = fold_convert (index_type, low);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If the entire case range is unreachable, ignore it.  */\n+\t      if ((TREE_CODE (min_value) == INTEGER_CST\n+\t\t   && tree_int_cst_compare (high, min_value) < 0)\n+\t\t  || (TREE_CODE (max_value) == INTEGER_CST\n+\t\t      && tree_int_cst_compare (low, max_value) > 0))\n+\t\tremove_element = TRUE;\n+\t      else\n+\t\t{\n+\t\t  /* If the lower bound is less than the index type's\n+\t\t     minimum value, truncate the range bounds.  */\n+\t\t  if (TREE_CODE (min_value) == INTEGER_CST\n+\t\t      && tree_int_cst_compare (low, min_value) < 0)\n+\t\t    low = min_value;\n+\t\t  low = fold_convert (index_type, low);\n+\n+\t\t  /* If the upper bound is greater than the index type's\n+\t\t     maximum value, truncate the range bounds.  */\n+\t\t  if (TREE_CODE (max_value) == INTEGER_CST\n+\t\t      && tree_int_cst_compare (high, max_value) > 0)\n+\t\t    high = max_value;\n+\t\t  high = fold_convert (index_type, high);\n+\t\t}\n+\t    }\n+\n+\t  CASE_LOW (elt) = low;\n+\t  CASE_HIGH (elt) = high;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (!default_case);\n+\t  default_case = elt;\n+\t  /* The default case must be passed separately to the\n+\t     gimple_build_switch routines.  But if DEFAULT_CASEP\n+\t     is NULL, we do not remove the default case (it would\n+\t     be completely lost).  */\n+\t  if (default_casep)\n+\t    remove_element = TRUE;\n+\t}\n+\n+      if (remove_element)\n+\tVEC_ordered_remove (tree, labels, i);\n+      else\n+\ti++;\n+    }\n+  len = i;\n+\n+  if (!VEC_empty (tree, labels))\n+    sort_case_labels (labels);\n+\n+  if (default_casep && !default_case)\n+    {\n+      /* If the switch has no default label, add one, so that we jump\n+\t around the switch body.  If the labels already cover the whole\n+\t range of the switch index_type, add the default label pointing\n+\t to one of the existing labels.  */\n+      if (len\n+\t  && TYPE_MIN_VALUE (index_type)\n+\t  && TYPE_MAX_VALUE (index_type)\n+\t  && tree_int_cst_equal (CASE_LOW (VEC_index (tree, labels, 0)),\n+\t\t\t\t TYPE_MIN_VALUE (index_type)))\n+\t{\n+\t  tree low, high = CASE_HIGH (VEC_index (tree, labels, len - 1));\n+\t  if (!high)\n+\t    high = CASE_LOW (VEC_index (tree, labels, len - 1));\n+\t  if (tree_int_cst_equal (high, TYPE_MAX_VALUE (index_type)))\n+\t    {\n+\t      for (i = 1; i < len; i++)\n+\t\t{\n+\t\t  high = CASE_LOW (VEC_index (tree, labels, i));\n+\t\t  low = CASE_HIGH (VEC_index (tree, labels, i - 1));\n+\t\t  if (!low)\n+\t\t    low = CASE_LOW (VEC_index (tree, labels, i - 1));\n+\t\t  if ((TREE_INT_CST_LOW (low) + 1\n+\t\t       != TREE_INT_CST_LOW (high))\n+\t\t      || (TREE_INT_CST_HIGH (low)\n+\t\t\t  + (TREE_INT_CST_LOW (high) == 0)\n+\t\t\t  != TREE_INT_CST_HIGH (high)))\n+\t\t    break;\n+\t\t}\n+\t      if (i == len)\n+\t\t{\n+\t\t  tree label = CASE_LABEL (VEC_index (tree, labels, 0));\n+\t\t  default_case = build_case_label (NULL_TREE, NULL_TREE,\n+\t\t\t\t\t\t   label);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (default_casep)\n+    *default_casep = default_case;\n+}\n+\f\n+/* Gimplify a SWITCH_EXPR, and collect the vector of labels it can\n    branch to.  */\n \n static enum gimplify_status\n@@ -1588,9 +1759,7 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n     {\n       VEC (tree,heap) *labels;\n       VEC (tree,heap) *saved_labels;\n-      tree min_value, max_value;\n       tree default_case = NULL_TREE;\n-      size_t i, len;\n       gimple gimple_switch;\n \n       /* If someone can be bothered to fill in the labels, they can\n@@ -1606,155 +1775,22 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n       labels = gimplify_ctxp->case_labels;\n       gimplify_ctxp->case_labels = saved_labels;\n \n-      i = 0;\n-      min_value = TYPE_MIN_VALUE (index_type);\n-      max_value = TYPE_MAX_VALUE (index_type);\n-      while (i < VEC_length (tree, labels))\n-\t{\n-\t  tree elt = VEC_index (tree, labels, i);\n-\t  tree low = CASE_LOW (elt);\n-\t  tree high = CASE_HIGH (elt);\n-\t  bool remove_element = FALSE;\n-\n-\n-\t  if (low)\n-\t    {\n-\t      gcc_checking_assert (TREE_CODE (low) == INTEGER_CST);\n-\t      gcc_checking_assert (!high || TREE_CODE (high) == INTEGER_CST);\n-\n-\t      /* This is a non-default case label, i.e. it has a value.\n-\n-\t\t See if the case label is reachable within the range of\n-\t\t the index type.  Remove out-of-range case values.  Turn\n-\t\t case ranges into a canonical form (high > low strictly)\n-\t\t and convert the case label values to the index type.\n-\n-\t\t NB: The type of gimple_switch_index() may be the promoted\n-\t\t type, but the case labels retain the original type.  */\n-\n-\t      if (high)\n-\t\t{\n-\t\t  /* This is a case range.  Discard empty ranges.\n-\t\t     If the bounds or the range are equal, turn this\n-\t\t     into a simple (one-value) case.  */\n-\t\t  int cmp = tree_int_cst_compare (high, low);\n-\t\t  if (cmp < 0)\n-\t\t    remove_element = TRUE;\n-\t\t  else if (cmp == 0)\n-\t\t    high = NULL_TREE;\n-\t\t}\n-\n-\t      if (! high)\n-\t\t{\n-\t\t  /* If the simple case value is unreachable, ignore it.  */\n-\t\t  if ((TREE_CODE (min_value) == INTEGER_CST\n-\t\t       && tree_int_cst_compare (low, min_value) < 0)\n-\t\t      || (TREE_CODE (max_value) == INTEGER_CST\n-\t\t\t  && tree_int_cst_compare (low, max_value) > 0))\n-\t\t    remove_element = TRUE;\n-\t\t  else\n-\t\t    low = fold_convert (index_type, low);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* If the entire case range is unreachable, ignore it.  */\n-\t\t  if ((TREE_CODE (min_value) == INTEGER_CST\n-\t\t       && tree_int_cst_compare (high, min_value) < 0)\n-\t\t      || (TREE_CODE (max_value) == INTEGER_CST\n-\t\t\t  && tree_int_cst_compare (low, max_value) > 0))\n-\t\t    remove_element = TRUE;\n-\t\t  else\n-\t\t    {\n-\t\t      /* If the lower bound is less than the index type's\n-\t\t\t minimum value, truncate the range bounds.  */\n-\t\t      if (TREE_CODE (min_value) == INTEGER_CST\n-\t\t\t  && tree_int_cst_compare (low, min_value) < 0)\n-\t\t\tlow = min_value;\n-\t\t      low = fold_convert (index_type, low);\n-\n-\t\t      /* If the upper bound is greater than the index type's\n-\t\t\t maximum value, truncate the range bounds.  */\n-\t\t      if (TREE_CODE (max_value) == INTEGER_CST\n-\t\t\t  && tree_int_cst_compare (high, max_value) > 0)\n-\t\t\thigh = max_value;\n-\t\t      high = fold_convert (index_type, high);\n-\t\t    }\n-\t\t}\n-\n-\t      CASE_LOW (elt) = low;\n-\t      CASE_HIGH (elt) = high;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* The default case must be the last label in the list.  */\n-\t      gcc_assert (!default_case);\n-\t      default_case = elt;\n-\t      remove_element = TRUE;\n-\t    }\n-\n-\t  if (remove_element)\n-\t    VEC_ordered_remove (tree, labels, i);\n-\t  else\n-\t    i++;\n-\t}\n-      len = i;\n-\n-      if (!VEC_empty (tree, labels))\n-\tsort_case_labels (labels);\n+      preprocess_case_label_vec_for_gimple (labels, index_type,\n+\t\t\t\t\t    &default_case);\n \n       if (!default_case)\n \t{\n-\t  /* If the switch has no default label, add one, so that we jump\n-\t     around the switch body.  If the labels already cover the whole\n-\t     range of the switch index_type, add the default label pointing\n-\t     to one of the existing labels.  */\n-\t  if (len\n-\t      && TYPE_MIN_VALUE (index_type)\n-\t      && TYPE_MAX_VALUE (index_type)\n-\t      && tree_int_cst_equal (CASE_LOW (VEC_index (tree, labels, 0)),\n-\t\t\t\t     TYPE_MIN_VALUE (index_type)))\n-\t    {\n-\t      tree low, high = CASE_HIGH (VEC_index (tree, labels, len - 1));\n-\t      if (!high)\n-\t\thigh = CASE_LOW (VEC_index (tree, labels, len - 1));\n-\t      if (tree_int_cst_equal (high, TYPE_MAX_VALUE (index_type)))\n-\t\t{\n-\t\t  for (i = 1; i < len; i++)\n-\t\t    {\n-\t\t      high = CASE_LOW (VEC_index (tree, labels, i));\n-\t\t      low = CASE_HIGH (VEC_index (tree, labels, i - 1));\n-\t\t      if (!low)\n-\t\t\tlow = CASE_LOW (VEC_index (tree, labels, i - 1));\n-\t\t      if ((TREE_INT_CST_LOW (low) + 1\n-\t\t\t   != TREE_INT_CST_LOW (high))\n-\t\t\t  || (TREE_INT_CST_HIGH (low)\n-\t\t\t      + (TREE_INT_CST_LOW (high) == 0)\n-\t\t\t      != TREE_INT_CST_HIGH (high)))\n-\t\t\tbreak;\n-\t\t    }\n-\t\t  if (i == len)\n-\t\t    {\n-\t\t      tree label = CASE_LABEL (VEC_index (tree, labels, 0));\n-\t\t      default_case = build_case_label (NULL_TREE, NULL_TREE,\n-\t\t\t\t\t\t       label);\n-\t\t    }\n-\t\t}\n-\t    }\n+\t  gimple new_default;\n \n-\t  if (!default_case)\n-\t    {\n-\t      gimple new_default;\n-\n-\t      default_case\n-\t\t= build_case_label (NULL_TREE, NULL_TREE,\n-\t\t\t\t    create_artificial_label (UNKNOWN_LOCATION));\n-\t      new_default = gimple_build_label (CASE_LABEL (default_case));\n-\t      gimplify_seq_add_stmt (&switch_body_seq, new_default);\n-\t    }\n+\t  default_case\n+\t    = build_case_label (NULL_TREE, NULL_TREE,\n+\t\t\t\tcreate_artificial_label (UNKNOWN_LOCATION));\n+\t  new_default = gimple_build_label (CASE_LABEL (default_case));\n+\t  gimplify_seq_add_stmt (&switch_body_seq, new_default);\n \t}\n \n       gimple_switch = gimple_build_switch_vec (SWITCH_COND (switch_expr),\n-                                               default_case, labels);\n+\t\t\t\t\t       default_case, labels);\n       gimplify_seq_add_stmt (pre_p, gimple_switch);\n       gimplify_seq_add_seq (pre_p, switch_body_seq);\n       VEC_free(tree, heap, labels);"}, {"sha": "a7322f057ec04536edbeb38d7bad40be0e118b88", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e", "patch": "@@ -1,3 +1,8 @@\n+2012-05-02  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR middle-end/53153\n+\t* gcc.dg/pr53153.c: New test.\n+\n 2012-05-02  Richard Guenther  <rguenther@suse.de>\n \n \t* g++.dg/tree-ssa/pr19807.C: Adjust."}, {"sha": "8899e04e90f642479d14a546bed53805125a587e", "filename": "gcc/testsuite/gcc.dg/pr53153.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr53153.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr53153.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr53153.c?ref=68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void bar (void);\n+\n+/* Case 181 is not in the range for 'char'.  */\n+void\n+foo1 (char *buf)\n+{\n+  int x = *buf;\n+  switch (x)\n+    {\n+    case -76:\n+    case 65:\n+    case 181:\n+      bar();\n+    }\n+}\n+\n+/* All cases are below the range of char.  */\n+void\n+foo2 (char *buf)\n+{\n+  int x = *buf;\n+  switch (x)\n+    {\n+    case -150:\n+    case -140:\n+    case -130:\n+      bar();\n+    }\n+}\n+\n+/* All cases are above the range of char.  */\n+void\n+foo3 (char *buf)\n+{\n+  int x = *buf;\n+  switch (x)\n+    {\n+    case 130:\n+    case 140:\n+    case 150: /* This case is not in the range for 'char'.  */\n+      bar();\n+    }\n+}\n+\n+/* The bounding cases are partially out of range for char.  */\n+void\n+foo4 (char *buf)\n+{\n+  int x = *buf;\n+  switch (x)\n+    {\n+    case -130 ... -120:\n+    case 100:\n+    case 120 ... 130:\n+      bar();\n+    }\n+}\n+"}, {"sha": "d3e9f98a06980ea212b9866f3c28afac6ca94b44", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 74, "deletions": 4, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=68e7284038237a5ed0f4a7bdf2cf16b6f8e55c7e", "patch": "@@ -163,7 +163,7 @@ along with GCC; see the file COPYING3.  If not see\n \n static bool forward_propagate_addr_expr (tree name, tree rhs);\n \n-/* Set to true if we delete EH edges during the optimization.  */\n+/* Set to true if we delete dead edges during the optimization.  */\n static bool cfg_changed;\n \n static tree rhs_to_tree (tree type, gimple stmt);\n@@ -1319,6 +1319,78 @@ simplify_not_neg_expr (gimple_stmt_iterator *gsi_p)\n   return false;\n }\n \n+/* Helper function for simplify_gimple_switch.  Remove case labels that\n+   have values outside the range of the new type.  */\n+\n+static void\n+simplify_gimple_switch_label_vec (gimple stmt, tree index_type)\n+{\n+  unsigned int branch_num = gimple_switch_num_labels (stmt);\n+  VEC(tree, heap) *labels = VEC_alloc (tree, heap, branch_num);\n+  unsigned int i, len;\n+\n+  /* Collect the existing case labels in a VEC, and preprocess it as if\n+     we are gimplifying a GENERIC SWITCH_EXPR.  */\n+  for (i = 1; i < branch_num; i++)\n+    VEC_quick_push (tree, labels, gimple_switch_label (stmt, i));\n+  preprocess_case_label_vec_for_gimple (labels, index_type, NULL);\n+\n+  /* If any labels were removed, replace the existing case labels\n+     in the GIMPLE_SWITCH statement with the correct ones.\n+     Note that the type updates were done in-place on the case labels,\n+     so we only have to replace the case labels in the GIMPLE_SWITCH\n+     if the number of labels changed.  */\n+  len = VEC_length (tree, labels);\n+  if (len < branch_num - 1)\n+    {\n+      bitmap target_blocks;\n+      edge_iterator ei;\n+      edge e;\n+\n+      /* Corner case: *all* case labels have been removed as being\n+\t out-of-range for INDEX_TYPE.  Push one label and let the\n+\t CFG cleanups deal with this further.  */\n+      if (len == 0)\n+\t{\n+\t  tree label, elt;\n+\n+\t  label = CASE_LABEL (gimple_switch_default_label (stmt));\n+\t  elt = build_case_label (build_int_cst (index_type, 0), NULL, label);\n+\t  VEC_quick_push (tree, labels, elt);\n+\t  len = 1;\n+\t}\n+\n+      for (i = 0; i < VEC_length (tree, labels); i++)\n+\tgimple_switch_set_label (stmt, i + 1, VEC_index (tree, labels, i));\n+      for (i++ ; i < branch_num; i++)\n+\tgimple_switch_set_label (stmt, i, NULL_TREE);\n+      gimple_switch_set_num_labels (stmt, len + 1);\n+\n+      /* Cleanup any edges that are now dead.  */\n+      target_blocks = BITMAP_ALLOC (NULL);\n+      for (i = 0; i < gimple_switch_num_labels (stmt); i++)\n+\t{\n+\t  tree elt = gimple_switch_label (stmt, i);\n+\t  basic_block target = label_to_block (CASE_LABEL (elt));\n+\t  bitmap_set_bit (target_blocks, target->index);\n+\t}\n+      for (ei = ei_start (gimple_bb (stmt)->succs); (e = ei_safe_edge (ei)); )\n+\t{\n+\t  if (! bitmap_bit_p (target_blocks, e->dest->index))\n+\t    {\n+\t      remove_edge (e);\n+\t      cfg_changed = true;\n+\t      free_dominance_info (CDI_DOMINATORS);\n+\t    }\n+\t  else\n+\t    ei_next (&ei);\n+\t} \n+      BITMAP_FREE (target_blocks);\n+    }\n+\n+  VEC_free (tree, heap, labels);\n+}\n+\n /* STMT is a SWITCH_EXPR for which we attempt to find equivalent forms of\n    the condition which we may be able to optimize better.  */\n \n@@ -1344,9 +1416,6 @@ simplify_gimple_switch (gimple stmt)\n \n \t      def = gimple_assign_rhs1 (def_stmt);\n \n-\t      /* ??? Why was Jeff testing this?  We are gimple...  */\n-\t      gcc_checking_assert (is_gimple_val (def));\n-\n \t      to = TREE_TYPE (cond);\n \t      ti = TREE_TYPE (def);\n \n@@ -1367,6 +1436,7 @@ simplify_gimple_switch (gimple stmt)\n \t      if (!fail)\n \t\t{\n \t\t  gimple_switch_set_index (stmt, def);\n+\t\t  simplify_gimple_switch_label_vec (stmt, ti);\n \t\t  update_stmt (stmt);\n \t\t  return true;\n \t\t}"}]}