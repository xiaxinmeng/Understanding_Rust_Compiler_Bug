{"sha": "46ef912923897a967e5c0d8641176300011be8b7", "node_id": "C_kwDOANBUbNoAKDQ2ZWY5MTI5MjM4OTdhOTY3ZTVjMGQ4NjQxMTc2MzAwMDExYmU4Yjc", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-11T12:17:45Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-11T12:17:45Z"}, "message": "Remove unused include in HIR", "tree": {"sha": "527a4bbd36c196a17ed7151c1dcec8905c09a6e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/527a4bbd36c196a17ed7151c1dcec8905c09a6e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46ef912923897a967e5c0d8641176300011be8b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46ef912923897a967e5c0d8641176300011be8b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46ef912923897a967e5c0d8641176300011be8b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46ef912923897a967e5c0d8641176300011be8b7/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eca2ac2c23e0c8b438fd696d4f85e35c9210d8dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eca2ac2c23e0c8b438fd696d4f85e35c9210d8dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eca2ac2c23e0c8b438fd696d4f85e35c9210d8dd"}], "stats": {"total": 249, "additions": 0, "deletions": 249}, "files": [{"sha": "a8a13d28189d79600c3ae9f2bf09e2cf6bf0bae4", "filename": "gcc/rust/hir/tree/rust-hir-cond-compilation.h", "status": "removed", "additions": 0, "deletions": 249, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca2ac2c23e0c8b438fd696d4f85e35c9210d8dd/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-cond-compilation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca2ac2c23e0c8b438fd696d4f85e35c9210d8dd/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-cond-compilation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-cond-compilation.h?ref=eca2ac2c23e0c8b438fd696d4f85e35c9210d8dd", "patch": "@@ -1,249 +0,0 @@\n-// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_AST_CONDCOMPILATION\n-#define RUST_AST_CONDCOMPILATION\n-\n-#include \"rust-ast-full-decls.h\"\n-#include \"rust-hir.h\"\n-\n-namespace Rust {\n-namespace HIR {\n-// Base conditional compilation configuration predicate thing - abstract\n-class ConfigurationPredicate\n-{\n-public:\n-  virtual ~ConfigurationPredicate () {}\n-\n-  // Unique pointer custom clone function\n-  std::unique_ptr<ConfigurationPredicate> clone_configuration_predicate () const\n-  {\n-    return std::unique_ptr<ConfigurationPredicate> (\n-      clone_configuration_predicate_impl ());\n-  }\n-\n-  // not sure if I'll use this but here anyway\n-  virtual void accept_vis (HIRFullVisitor &vis) = 0;\n-\n-protected:\n-  // Clone function impl to be overriden in base classes\n-  virtual ConfigurationPredicate *\n-  clone_configuration_predicate_impl () const = 0;\n-};\n-\n-// A configuration option - true if option is set, false if option is not set.\n-class ConfigurationOption : public ConfigurationPredicate\n-{\n-  Identifier option_name;\n-\n-  // bool has_string_literal_option_body;\n-  std::string option_value; // technically a string or raw string literal\n-\n-public:\n-  /* Returns whether the configuration option has a \"value\" part of the\n-   * key-value pair. */\n-  bool has_option_value () const { return !option_value.empty (); }\n-\n-  // Key-value pair constructor\n-  ConfigurationOption (Identifier option_name, std::string option_value)\n-    : option_name (option_name), option_value (option_value)\n-  {}\n-\n-  // Name-only constructor\n-  ConfigurationOption (Identifier option_name) : option_name (option_name) {}\n-\n-  void accept_vis (HIRFullVisitor &vis) override;\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ConfigurationOption *clone_configuration_predicate_impl () const override\n-  {\n-    return new ConfigurationOption (*this);\n-  }\n-};\n-\n-// TODO: inline\n-struct ConfigurationPredicateList\n-{\n-  std::vector<std::unique_ptr<ConfigurationPredicate> > predicate_list;\n-};\n-\n-// Predicate that returns true if all of the supplied predicates return true.\n-class ConfigurationAll : public ConfigurationPredicate\n-{\n-  std::vector<std::unique_ptr<ConfigurationPredicate> >\n-    predicate_list; // inlined form\n-\n-public:\n-  ConfigurationAll (\n-    std::vector<std::unique_ptr<ConfigurationPredicate> > predicate_list)\n-    : predicate_list (predicate_list)\n-  {}\n-\n-  void accept_vis (HIRFullVisitor &vis) override;\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ConfigurationAll *clone_configuration_predicate_impl () const override\n-  {\n-    return new ConfigurationAll (*this);\n-  }\n-};\n-\n-// Predicate that returns true if any of the supplied predicates are true.\n-class ConfigurationAny : public ConfigurationPredicate\n-{\n-  std::vector<std::unique_ptr<ConfigurationPredicate> >\n-    predicate_list; // inlined form\n-\n-public:\n-  ConfigurationAny (\n-    std::vector<std::unique_ptr<ConfigurationPredicate> > predicate_list)\n-    : predicate_list (predicate_list)\n-  {}\n-\n-  void accept_vis (HIRFullVisitor &vis) override;\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ConfigurationAny *clone_configuration_predicate_impl () const override\n-  {\n-    return new ConfigurationAny (*this);\n-  }\n-};\n-\n-/* Predicate that produces the negation of a supplied other configuration\n- * predicate. */\n-class ConfigurationNot : public ConfigurationPredicate\n-{\n-  std::unique_ptr<ConfigurationPredicate> config_to_negate;\n-\n-public:\n-  ConfigurationNot (ConfigurationPredicate *config_to_negate)\n-    : config_to_negate (config_to_negate)\n-  {}\n-\n-  // Copy constructor with clone\n-  ConfigurationNot (ConfigurationNot const &other)\n-    : config_to_negate (\n-      other.config_to_negate->clone_configuration_predicate ())\n-  {}\n-\n-  // Overloaded assignment operator to clone\n-  ConfigurationNot &operator= (ConfigurationNot const &other)\n-  {\n-    config_to_negate = other.config_to_negate->clone_configuration_predicate ();\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  ConfigurationNot (ConfigurationNot &&other) = default;\n-  ConfigurationNot &operator= (ConfigurationNot &&other) = default;\n-\n-  void accept_vis (HIRFullVisitor &vis) override;\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ConfigurationNot *clone_configuration_predicate_impl () const override\n-  {\n-    return new ConfigurationNot (*this);\n-  }\n-};\n-\n-// TODO: relationship to other attributes?\n-class CfgAttribute\n-{\n-  std::unique_ptr<ConfigurationPredicate> config_to_include;\n-\n-public:\n-  CfgAttribute (ConfigurationPredicate *config_to_include)\n-    : config_to_include (config_to_include)\n-  {}\n-\n-  // Copy constructor with clone\n-  CfgAttribute (CfgAttribute const &other)\n-    : config_to_include (\n-      other.config_to_include->clone_configuration_predicate ())\n-  {}\n-\n-  // Overloaded assignment operator to clone\n-  CfgAttribute &operator= (CfgAttribute const &other)\n-  {\n-    config_to_include\n-      = other.config_to_include->clone_configuration_predicate ();\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  CfgAttribute (CfgAttribute &&other) = default;\n-  CfgAttribute &operator= (CfgAttribute &&other) = default;\n-};\n-/* TODO: ok, best thing to do would be eliminating this class, making Attribute\n- * has a \"is_cfg()\" method, and having attribute path as \"cfg\" and AttrInput as\n- * ConfigurationPredicate (so make ConfigurationPredicate a subclass of\n- * AttrInput?). Would need special handling in parser, however. */\n-\n-// TODO: inline\n-struct CfgAttrs\n-{\n-  AST::AttrVec cfg_attrs;\n-};\n-\n-// TODO: relationship to other attributes?\n-class CfgAttrAttribute\n-{\n-  std::unique_ptr<ConfigurationPredicate> config_to_include;\n-  AST::AttrVec cfg_attrs;\n-\n-public:\n-  CfgAttrAttribute (ConfigurationPredicate *config_to_include,\n-\t\t    AST::AttrVec cfg_attrs)\n-    : config_to_include (config_to_include), cfg_attrs (cfg_attrs)\n-  {}\n-\n-  // Copy constructor with clone\n-  CfgAttrAttribute (CfgAttrAttribute const &other)\n-    : config_to_include (\n-      other.config_to_include->clone_configuration_predicate ()),\n-      cfg_attrs (cfg_attrs)\n-  {}\n-\n-  // Overloaded assignment operator to clone\n-  CfgAttrAttribute &operator= (CfgAttrAttribute const &other)\n-  {\n-    config_to_include\n-      = other.config_to_include->clone_configuration_predicate ();\n-    cfg_attrs = other.cfg_attrs;\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  CfgAttrAttribute (CfgAttrAttribute &&other) = default;\n-  CfgAttrAttribute &operator= (CfgAttrAttribute &&other) = default;\n-};\n-} // namespace HIR\n-} // namespace Rust\n-\n-#endif"}]}