{"sha": "fa1608c29d80bfc90a408ff0ac02c0aeda046dcb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmExNjA4YzI5ZDgwYmZjOTBhNDA4ZmYwYWMwMmMwYWVkYTA0NmRjYg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2013-07-05T10:50:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-05T10:50:49Z"}, "message": "exp_ch3.adb (Build_Variant_Record_Equality): Add pairs of formals for each discriminant of an unchecked union.\n\n2013-07-05  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch3.adb (Build_Variant_Record_Equality): Add pairs of\n\tformals for each discriminant of an unchecked union.\n\t(Make_Eq_Case): Suprogram accepts a list of discriminants. Nested\n\tvariants are supported. New helper function Corresponding_Formal.\n\t* exp_ch4.adb (Build_Equality_Call): For unchecked unions,\n\tloop through discriminants to create list of inferred values,\n\tand modify call to equality routine accordingly.\n\nFrom-SVN: r200709", "tree": {"sha": "bff4e24d7128121a25860fba12080bdf9c68b5af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bff4e24d7128121a25860fba12080bdf9c68b5af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa1608c29d80bfc90a408ff0ac02c0aeda046dcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa1608c29d80bfc90a408ff0ac02c0aeda046dcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa1608c29d80bfc90a408ff0ac02c0aeda046dcb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa1608c29d80bfc90a408ff0ac02c0aeda046dcb/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a33f291d93be2788324ee4a5d4e5236906ebf950", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a33f291d93be2788324ee4a5d4e5236906ebf950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a33f291d93be2788324ee4a5d4e5236906ebf950"}], "stats": {"total": 346, "additions": 241, "deletions": 105}, "files": [{"sha": "24b3fd28fed7de7b5aae92bd4a983b675a2aab7f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1608c29d80bfc90a408ff0ac02c0aeda046dcb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1608c29d80bfc90a408ff0ac02c0aeda046dcb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fa1608c29d80bfc90a408ff0ac02c0aeda046dcb", "patch": "@@ -1,3 +1,13 @@\n+2013-07-05  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Variant_Record_Equality): Add pairs of\n+\tformals for each discriminant of an unchecked union.\n+\t(Make_Eq_Case): Suprogram accepts a list of discriminants. Nested\n+\tvariants are supported. New helper function Corresponding_Formal.\n+\t* exp_ch4.adb (Build_Equality_Call): For unchecked unions,\n+\tloop through discriminants to create list of inferred values,\n+\tand modify call to equality routine accordingly.\n+\n 2013-07-05  Claire Dross  <dross@adacore.com>\n \n \t* a-cfdlli.ads, a-cfhama.ads, a-cfhase.ads, a-cforma.ads,"}, {"sha": "4491d30aa9a3896a7d3a5ef8380c3547de722eda", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 110, "deletions": 48, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1608c29d80bfc90a408ff0ac02c0aeda046dcb/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1608c29d80bfc90a408ff0ac02c0aeda046dcb/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=fa1608c29d80bfc90a408ff0ac02c0aeda046dcb", "patch": "@@ -237,16 +237,19 @@ package body Exp_Ch3 is\n    --  user-defined equality. Factored out of Predefined_Primitive_Bodies.\n \n    function Make_Eq_Case\n-     (E     : Entity_Id;\n-      CL    : Node_Id;\n-      Discr : Entity_Id := Empty) return List_Id;\n+     (E      : Entity_Id;\n+      CL     : Node_Id;\n+      Discrs : Elist_Id := New_Elmt_List) return List_Id;\n    --  Building block for variant record equality. Defined to share the code\n    --  between the tagged and non-tagged case. Given a Component_List node CL,\n    --  it generates an 'if' followed by a 'case' statement that compares all\n    --  components of local temporaries named X and Y (that are declared as\n    --  formals at some upper level). E provides the Sloc to be used for the\n-   --  generated code. Discr is used as the case statement switch in the case\n-   --  of Unchecked_Union equality.\n+   --  generated code.\n+   --\n+   --  IF E is an unchecked_union,  Discrs is the list of formals created for\n+   --  the inferred discriminants of one operand. These formals are used in\n+   --  the generated case statements for each variant of the unchecked union.\n \n    function Make_Eq_If\n      (E : Entity_Id;\n@@ -4335,8 +4338,7 @@ package body Exp_Ch3 is\n               Result_Definition => New_Reference_To (Standard_Boolean, Loc)),\n           Declarations               => New_List,\n           Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => Stmts)));\n+            Make_Handled_Sequence_Of_Statements (Loc, Statements => Stmts)));\n \n       Append_To (Pspecs,\n         Make_Parameter_Specification (Loc,\n@@ -4350,57 +4352,71 @@ package body Exp_Ch3 is\n \n       --  Unchecked_Unions require additional machinery to support equality.\n       --  Two extra parameters (A and B) are added to the equality function\n-      --  parameter list in order to capture the inferred values of the\n-      --  discriminants in later calls.\n+      --  parameter list for each discriminant of the type, in order to\n+      --  capture the inferred values of the discriminants in equality calls.\n+      --  The names of the parameters match the names of the corresponding\n+      --  discriminant, with an added suffix.\n \n       if Is_Unchecked_Union (Typ) then\n          declare\n-            Discr_Type : constant Node_Id := Etype (First_Discriminant (Typ));\n+            Discr      : Entity_Id;\n+            Discr_Type : Entity_Id;\n+            A, B       : Entity_Id;\n+            New_Discrs : Elist_Id;\n \n-            A : constant Node_Id :=\n-                  Make_Defining_Identifier (Loc,\n-                    Chars => Name_A);\n+         begin\n+            New_Discrs := New_Elmt_List;\n \n-            B : constant Node_Id :=\n-                  Make_Defining_Identifier (Loc,\n-                    Chars => Name_B);\n+            Discr := First_Discriminant (Typ);\n+            while Present (Discr) loop\n+               Discr_Type := Etype (Discr);\n+               A := Make_Defining_Identifier (Loc,\n+                      Chars => New_External_Name (Chars (Discr), 'A'));\n \n-         begin\n-            --  Add A and B to the parameter list\n+               B := Make_Defining_Identifier (Loc,\n+                      Chars => New_External_Name (Chars (Discr), 'B'));\n \n-            Append_To (Pspecs,\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => A,\n-                Parameter_Type => New_Reference_To (Discr_Type, Loc)));\n+               --  Add new parameters to the parameter list\n \n-            Append_To (Pspecs,\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => B,\n-                Parameter_Type => New_Reference_To (Discr_Type, Loc)));\n+               Append_To (Pspecs,\n+                 Make_Parameter_Specification (Loc,\n+                   Defining_Identifier => A,\n+                   Parameter_Type      => New_Reference_To (Discr_Type, Loc)));\n \n-            --  Generate the following header code to compare the inferred\n-            --  discriminants:\n+               Append_To (Pspecs,\n+                 Make_Parameter_Specification (Loc,\n+                   Defining_Identifier => B,\n+                   Parameter_Type      => New_Reference_To (Discr_Type, Loc)));\n \n-            --  if a /= b then\n-            --     return False;\n-            --  end if;\n+               Append_Elmt (A, New_Discrs);\n \n-            Append_To (Stmts,\n-              Make_If_Statement (Loc,\n-                Condition =>\n-                  Make_Op_Ne (Loc,\n-                    Left_Opnd => New_Reference_To (A, Loc),\n-                    Right_Opnd => New_Reference_To (B, Loc)),\n-                Then_Statements => New_List (\n-                  Make_Simple_Return_Statement (Loc,\n-                    Expression => New_Occurrence_Of (Standard_False, Loc)))));\n+               --  Generate the following code to compare each of the inferred\n+               --  discriminants:\n+\n+               --  if a /= b then\n+               --     return False;\n+               --  end if;\n+\n+               Append_To (Stmts,\n+                 Make_If_Statement (Loc,\n+                   Condition       =>\n+                     Make_Op_Ne (Loc,\n+                       Left_Opnd  => New_Reference_To (A, Loc),\n+                       Right_Opnd => New_Reference_To (B, Loc)),\n+                   Then_Statements => New_List (\n+                     Make_Simple_Return_Statement (Loc,\n+                       Expression =>\n+                         New_Occurrence_Of (Standard_False, Loc)))));\n+               Next_Discriminant (Discr);\n+            end loop;\n \n             --  Generate component-by-component comparison. Note that we must\n-            --  propagate one of the inferred discriminant formals to act as\n-            --  the case statement switch.\n+            --  propagate the inferred discriminants formals to act as\n+            --  the case statement switch. Their value is added when an\n+            --  equality call on unchecked unions is expanded.\n \n             Append_List_To (Stmts,\n-              Make_Eq_Case (Typ, Comps, A));\n+              Make_Eq_Case (Typ, Comps, New_Discrs));\n          end;\n \n       --  Normal case (not unchecked union)\n@@ -8578,13 +8594,56 @@ package body Exp_Ch3 is\n    function Make_Eq_Case\n      (E     : Entity_Id;\n       CL    : Node_Id;\n-      Discr : Entity_Id := Empty) return List_Id\n+      Discrs : Elist_Id := New_Elmt_List) return List_Id\n    is\n       Loc      : constant Source_Ptr := Sloc (E);\n       Result   : constant List_Id    := New_List;\n       Variant  : Node_Id;\n       Alt_List : List_Id;\n \n+      function Corresponding_Formal (C : Node_Id) return Entity_Id;\n+      --  Given the discriminant that controls a given variant of an unchecked\n+      --  union, find the formal of the equality function that carries the\n+      --  inferred value of the discriminant.\n+\n+      function External_Name (E : Entity_Id) return Name_Id;\n+      --  The value of a given discriminant is conveyed in the corresponding\n+      --  formal parameter of the equality routine. The name of this formal\n+      --  parameter carries a one-character suffix which is removed here.\n+\n+      --------------------------\n+      -- Corresponding_Formal --\n+      --------------------------\n+\n+      function Corresponding_Formal (C : Node_Id) return Entity_Id is\n+         Discr : constant Entity_Id := Entity (Name (Variant_Part (C)));\n+         Elm   : Elmt_Id;\n+\n+      begin\n+         Elm := First_Elmt (Discrs);\n+         while Present (Elm) loop\n+            if Chars (Discr) = External_Name (Node (Elm)) then\n+               return Node (Elm);\n+            end if;\n+            Next_Elmt (Elm);\n+         end loop;\n+\n+         --  A formal of the proper name must be found\n+\n+         raise Program_Error;\n+      end Corresponding_Formal;\n+\n+      -------------------\n+      -- External_Name --\n+      -------------------\n+\n+      function External_Name (E : Entity_Id) return Name_Id is\n+      begin\n+         Get_Name_String (Chars (E));\n+         Name_Len := Name_Len - 1;\n+         return Name_Find;\n+      end External_Name;\n+\n    begin\n       Append_To (Result, Make_Eq_If (E, Component_Items (CL)));\n \n@@ -8604,18 +8663,21 @@ package body Exp_Ch3 is\n          Append_To (Alt_List,\n            Make_Case_Statement_Alternative (Loc,\n              Discrete_Choices => New_Copy_List (Discrete_Choices (Variant)),\n-             Statements => Make_Eq_Case (E, Component_List (Variant))));\n+             Statements =>\n+               Make_Eq_Case (E, Component_List (Variant), Discrs)));\n \n          Next_Non_Pragma (Variant);\n       end loop;\n \n-      --  If we have an Unchecked_Union, use one of the parameters that\n-      --  captures the discriminants.\n+      --  If we have an Unchecked_Union, use one of the parameters of the\n+      --  enclosing equality routine that captures the discriminant, to use\n+      --  as the expression in the generated case statement.\n \n       if Is_Unchecked_Union (E) then\n          Append_To (Result,\n            Make_Case_Statement (Loc,\n-             Expression => New_Reference_To (Discr, Loc),\n+             Expression =>\n+               New_Reference_To (Corresponding_Formal (CL), Loc),\n              Alternatives => Alt_List));\n \n       else"}, {"sha": "9b0fc02748aaff187b6aa92f3f40523ea406434a", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 121, "deletions": 57, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa1608c29d80bfc90a408ff0ac02c0aeda046dcb/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa1608c29d80bfc90a408ff0ac02c0aeda046dcb/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=fa1608c29d80bfc90a408ff0ac02c0aeda046dcb", "patch": "@@ -6939,17 +6939,26 @@ package body Exp_Ch4 is\n \n          if Is_Unchecked_Union (Op_Type) then\n             declare\n-               Lhs_Type      : constant Node_Id := Etype (L_Exp);\n-               Rhs_Type      : constant Node_Id := Etype (R_Exp);\n-               Lhs_Discr_Val : Node_Id;\n-               Rhs_Discr_Val : Node_Id;\n+               Lhs_Type : constant Node_Id := Etype (L_Exp);\n+               Rhs_Type : constant Node_Id := Etype (R_Exp);\n+\n+               Lhs_Discr_Vals : Elist_Id;\n+               --  List of inferred discriminant values for left operand.\n+\n+               Rhs_Discr_Vals : Elist_Id;\n+               --  List of inferred discriminant values for right operand.\n+\n+               Discr : Entity_Id;\n \n             begin\n+               Lhs_Discr_Vals := New_Elmt_List;\n+               Rhs_Discr_Vals := New_Elmt_List;\n+\n                --  Per-object constrained selected components require special\n                --  attention. If the enclosing scope of the component is an\n                --  Unchecked_Union, we cannot reference its discriminants\n-               --  directly. This is why we use the two extra parameters of\n-               --  the equality function of the enclosing Unchecked_Union.\n+               --  directly. This is why we use the extra parameters of the\n+               --  equality function of the enclosing Unchecked_Union.\n \n                --  type UU_Type (Discr : Integer := 0) is\n                --     . . .\n@@ -6976,7 +6985,8 @@ package body Exp_Ch4 is\n \n                --  A and B are the formal parameters of the equality function\n                --  of Enclosing_UU_Type. The function always has two extra\n-               --  formals to capture the inferred discriminant values.\n+               --  formals to capture the inferred discriminant values for\n+               --  each discriminant of the type.\n \n                --  2. Non-Unchecked_Union enclosing record:\n \n@@ -7001,94 +7011,148 @@ package body Exp_Ch4 is\n                --  In this case we can directly reference the discriminants of\n                --  the enclosing record.\n \n-               --  Lhs of equality\n+               --  Process left operand of equality\n \n                if Nkind (Lhs) = N_Selected_Component\n                  and then\n                    Has_Per_Object_Constraint (Entity (Selector_Name (Lhs)))\n                then\n-                  --  Enclosing record is an Unchecked_Union, use formal A\n+                  --  If enclosing record is an Unchecked_Union, use formals\n+                  --  corresponding to each discriminant. The name of the\n+                  --  formal is that of the discriminant, with added suffix,\n+                  --  see Exp_Ch3.Build_Record_Equality for details.\n \n                   if Is_Unchecked_Union\n                        (Scope (Entity (Selector_Name (Lhs))))\n                   then\n-                     Lhs_Discr_Val := Make_Identifier (Loc, Name_A);\n+                     Discr :=\n+                       First_Discriminant\n+                         (Scope (Entity (Selector_Name (Lhs))));\n+                     while Present (Discr) loop\n+                        Append_Elmt (\n+                          Make_Identifier (Loc,\n+                            Chars => New_External_Name (Chars (Discr), 'A')),\n+                          To => Lhs_Discr_Vals);\n+                        Next_Discriminant (Discr);\n+                     end loop;\n \n-                  --  Enclosing record is of a non-Unchecked_Union type, it is\n-                  --  possible to reference the discriminant.\n+                  --  If enclosing record is of a non-Unchecked_Union type, it\n+                  --  is possible to reference its discriminants directly.\n \n                   else\n-                     Lhs_Discr_Val :=\n-                       Make_Selected_Component (Loc,\n-                         Prefix => Prefix (Lhs),\n-                         Selector_Name =>\n-                           New_Copy\n-                             (Get_Discriminant_Value\n-                                (First_Discriminant (Lhs_Type),\n-                                 Lhs_Type,\n-                                 Stored_Constraint (Lhs_Type))));\n+                     Discr := First_Discriminant (Lhs_Type);\n+                     while Present (Discr) loop\n+                        Append_Elmt (\n+                          Make_Selected_Component (Loc,\n+                            Prefix => Prefix (Lhs),\n+                            Selector_Name =>\n+                              New_Copy\n+                                (Get_Discriminant_Value (Discr,\n+                                    Lhs_Type,\n+                                    Stored_Constraint (Lhs_Type)))),\n+                          To => Lhs_Discr_Vals);\n+                        Next_Discriminant (Discr);\n+                     end loop;\n                   end if;\n \n-               --  Comment needed here ???\n+               --  Otherwise operand is on object with a constrained type.\n+               --  Infer the discriminant values from the constraint.\n \n                else\n-                  --  Infer the discriminant value\n-\n-                  Lhs_Discr_Val :=\n-                    New_Copy\n-                      (Get_Discriminant_Value\n-                         (First_Discriminant (Lhs_Type),\n-                          Lhs_Type,\n-                          Stored_Constraint (Lhs_Type)));\n+\n+                  Discr := First_Discriminant (Lhs_Type);\n+                  while Present (Discr) loop\n+                     Append_Elmt (\n+                       New_Copy\n+                         (Get_Discriminant_Value (Discr,\n+                             Lhs_Type,\n+                             Stored_Constraint (Lhs_Type))),\n+                       To => Lhs_Discr_Vals);\n+                     Next_Discriminant (Discr);\n+                  end loop;\n                end if;\n \n-               --  Rhs of equality\n+               --  Similar processing for right operand of equality\n \n                if Nkind (Rhs) = N_Selected_Component\n                  and then\n                    Has_Per_Object_Constraint (Entity (Selector_Name (Rhs)))\n                then\n                   if Is_Unchecked_Union\n-                       (Scope (Entity (Selector_Name (Rhs))))\n+                    (Scope (Entity (Selector_Name (Rhs))))\n                   then\n-                     Rhs_Discr_Val := Make_Identifier (Loc, Name_B);\n+                     Discr :=\n+                       First_Discriminant\n+                         (Scope (Entity (Selector_Name (Rhs))));\n+                     while Present (Discr) loop\n+                        Append_Elmt (\n+                          Make_Identifier (Loc,\n+                            Chars => New_External_Name (Chars (Discr), 'B')),\n+                          To => Rhs_Discr_Vals);\n+                        Next_Discriminant (Discr);\n+                     end loop;\n \n                   else\n-                     Rhs_Discr_Val :=\n-                       Make_Selected_Component (Loc,\n-                         Prefix => Prefix (Rhs),\n-                         Selector_Name =>\n-                           New_Copy (Get_Discriminant_Value (\n-                             First_Discriminant (Rhs_Type),\n-                             Rhs_Type,\n-                             Stored_Constraint (Rhs_Type))));\n-\n+                     Discr := First_Discriminant (Rhs_Type);\n+                     while Present (Discr) loop\n+                        Append_Elmt (\n+                          Make_Selected_Component (Loc,\n+                            Prefix        => Prefix (Rhs),\n+                            Selector_Name =>\n+                              New_Copy (Get_Discriminant_Value\n+                                          (Discr,\n+                                           Rhs_Type,\n+                                           Stored_Constraint (Rhs_Type)))),\n+                          To => Rhs_Discr_Vals);\n+                        Next_Discriminant (Discr);\n+                     end loop;\n                   end if;\n-               else\n-                  Rhs_Discr_Val :=\n-                    New_Copy (Get_Discriminant_Value (\n-                      First_Discriminant (Rhs_Type),\n-                      Rhs_Type,\n-                      Stored_Constraint (Rhs_Type)));\n \n+               else\n+                  Discr := First_Discriminant (Rhs_Type);\n+                  while Present (Discr) loop\n+                     Append_Elmt (\n+                       New_Copy (Get_Discriminant_Value\n+                                   (Discr,\n+                                    Rhs_Type,\n+                                    Stored_Constraint (Rhs_Type))),\n+                       To => Rhs_Discr_Vals);\n+                     Next_Discriminant (Discr);\n+                  end loop;\n                end if;\n \n-               Rewrite (N,\n-                 Make_Function_Call (Loc,\n-                   Name => New_Reference_To (Eq, Loc),\n-                   Parameter_Associations => New_List (\n-                     L_Exp,\n-                     R_Exp,\n-                     Lhs_Discr_Val,\n-                     Rhs_Discr_Val)));\n+               --  Now merge the list of discriminant values so that values\n+               --  of corresponding discriminants are adjacent.\n+\n+               declare\n+                  Params : List_Id;\n+                  L_Elmt : Elmt_Id;\n+                  R_Elmt : Elmt_Id;\n+\n+               begin\n+                  Params := New_List (L_Exp, R_Exp);\n+                  L_Elmt := First_Elmt (Lhs_Discr_Vals);\n+                  R_Elmt := First_Elmt (Rhs_Discr_Vals);\n+                  while Present (L_Elmt) loop\n+                     Append_To (Params, Node (L_Elmt));\n+                     Append_To (Params, Node (R_Elmt));\n+                     Next_Elmt (L_Elmt);\n+                     Next_Elmt (R_Elmt);\n+                  end loop;\n+\n+                  Rewrite (N,\n+                    Make_Function_Call (Loc,\n+                      Name                   => New_Reference_To (Eq, Loc),\n+                      Parameter_Associations => Params));\n+               end;\n             end;\n \n          --  Normal case, not an unchecked union\n \n          else\n             Rewrite (N,\n               Make_Function_Call (Loc,\n-                Name => New_Reference_To (Eq, Loc),\n+                Name                   => New_Reference_To (Eq, Loc),\n                 Parameter_Associations => New_List (L_Exp, R_Exp)));\n          end if;\n "}]}