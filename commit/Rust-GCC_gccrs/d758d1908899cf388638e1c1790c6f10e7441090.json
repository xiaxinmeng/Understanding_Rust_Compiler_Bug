{"sha": "d758d1908899cf388638e1c1790c6f10e7441090", "node_id": "C_kwDOANBUbNoAKGQ3NThkMTkwODg5OWNmMzg4NjM4ZTFjMTc5MGM2ZjEwZTc0NDEwOTA", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2022-11-14T18:05:26Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2022-11-14T18:05:26Z"}, "message": "aarch64: Add support for +cssc\n\nThis patch adds codegen for FEAT_CSSC from the 2022 Architecture extensions.\nIt fits various existing optabs in GCC quite well.\nThere are instructions for scalar signed/unsigned min/max, abs, ctz, popcount.\nWe have expanders for these already, so they are wired up to emit single-insn\npatterns for the new TARGET_CSSC.\n\nThese instructions are enabled by the +cssc command-line extension.\nBootstrapped and tested on aarch64-none-linux-gnu.\n\ngcc/ChangeLog:\n\n\t* config/aarch64/aarch64-option-extensions.def (cssc): Define.\n\t* config/aarch64/aarch64.h (AARCH64_ISA_CSSC): Define.\n\t(TARGET_CSSC): Likewise.\n\t* config/aarch64/aarch64.md (*aarch64_abs<mode>2_cssc_ins): New define_insn.\n\t(abs<mode>2): Adjust for the above.\n\t(aarch64_umax<mode>3_insn): New define_insn.\n\t(umax<mode>3): Adjust for the above.\n\t(*aarch64_popcount<mode>2_cssc_insn): New define_insn.\n\t(popcount<mode>2): Adjust for the above.\n\t(<optab><mode>3): New define_insn.\n\t* config/aarch64/constraints.md (Usm): Define.\n\t(Uum): Likewise.\n\t* doc/invoke.texi (AArch64 options): Document +cssc.\n\t* config/aarch64/iterators.md (MAXMIN_NOUMAX): New code iterator.\n\t* config/aarch64/predicates.md (aarch64_sminmax_immediate): Define.\n\t(aarch64_sminmax_operand): Likewise.\n\t(aarch64_uminmax_immediate): Likewise.\n\t(aarch64_uminmax_operand): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/cssc_1.c: New test.\n\t* gcc.target/aarch64/cssc_2.c: New test.\n\t* gcc.target/aarch64/cssc_3.c: New test.\n\t* gcc.target/aarch64/cssc_4.c: New test.\n\t* gcc.target/aarch64/cssc_5.c: New test.", "tree": {"sha": "613739b867e9eb0b55694037a32c308d95dcd426", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/613739b867e9eb0b55694037a32c308d95dcd426"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d758d1908899cf388638e1c1790c6f10e7441090", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d758d1908899cf388638e1c1790c6f10e7441090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d758d1908899cf388638e1c1790c6f10e7441090", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d758d1908899cf388638e1c1790c6f10e7441090/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a89ac9011e04cf8ebdf856b679bd91000ef70175", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a89ac9011e04cf8ebdf856b679bd91000ef70175", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a89ac9011e04cf8ebdf856b679bd91000ef70175"}], "stats": {"total": 513, "additions": 482, "deletions": 31}, "files": [{"sha": "8d1a703fb8c9379c5eca82d69b8058d436932fac", "filename": "gcc/config/aarch64/aarch64-option-extensions.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-option-extensions.def?ref=d758d1908899cf388638e1c1790c6f10e7441090", "patch": "@@ -149,4 +149,6 @@ AARCH64_OPT_EXTENSION(\"ls64\", LS64, (), (), (), \"\")\n \n AARCH64_OPT_EXTENSION(\"mops\", MOPS, (), (), (), \"\")\n \n+AARCH64_OPT_EXTENSION(\"cssc\", CSSC, (), (), (), \"\")\n+\n #undef AARCH64_OPT_EXTENSION"}, {"sha": "bbbb7e4213de40a17e1e371b2fefdc2083a38f17", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=d758d1908899cf388638e1c1790c6f10e7441090", "patch": "@@ -221,6 +221,7 @@ enum class aarch64_feature : unsigned char {\n #define AARCH64_ISA_V9_3A          (aarch64_isa_flags & AARCH64_FL_V9_3A)\n #define AARCH64_ISA_MOPS\t   (aarch64_isa_flags & AARCH64_FL_MOPS)\n #define AARCH64_ISA_LS64\t   (aarch64_isa_flags & AARCH64_FL_LS64)\n+#define AARCH64_ISA_CSSC\t   (aarch64_isa_flags & AARCH64_FL_CSSC)\n \n /* Crypto is an optional extension to AdvSIMD.  */\n #define TARGET_CRYPTO (AARCH64_ISA_CRYPTO)\n@@ -316,6 +317,9 @@ enum class aarch64_feature : unsigned char {\n /* LS64 instructions are enabled through +ls64.  */\n #define TARGET_LS64 (AARCH64_ISA_LS64)\n \n+/* CSSC instructions are enabled through +cssc.  */\n+#define TARGET_CSSC (AARCH64_ISA_CSSC)\n+\n /* Make sure this is always defined so we don't have to check for ifdefs\n    but rather use normal ifs.  */\n #ifndef TARGET_FIX_ERR_A53_835769_DEFAULT"}, {"sha": "76b6898ca048c559ff7f7fba78119161b3d382f6", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 88, "deletions": 31, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=d758d1908899cf388638e1c1790c6f10e7441090", "patch": "@@ -3577,15 +3577,26 @@\n   [(set_attr \"type\" \"alu_ext\")]\n )\n \n+(define_insn \"*aarch64_abs<mode>2_cssc_insn\"\n+  [(set (match_operand:GPI 0 \"register_operand\" \"=r\")\n+\t(abs:GPI (match_operand:GPI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_CSSC\"\n+  \"abs\\\\t%<w>0, %<w>1\"\n+  [(set_attr \"type\" \"alu_sreg\")]\n+)\n+\n (define_expand \"abs<mode>2\"\n-  [(match_operand:GPI 0 \"register_operand\")\n-   (match_operand:GPI 1 \"register_operand\")]\n+  [(set (match_operand:GPI 0 \"register_operand\")\n+\t(abs:GPI (match_operand:GPI 1 \"register_operand\")))]\n   \"\"\n   {\n-    rtx ccreg = aarch64_gen_compare_reg (LT, operands[1], const0_rtx);\n-    rtx x = gen_rtx_LT (VOIDmode, ccreg, const0_rtx);\n-    emit_insn (gen_csneg3<mode>_insn (operands[0], x, operands[1], operands[1]));\n-    DONE;\n+    if (!TARGET_CSSC)\n+      {\n+\trtx ccreg = aarch64_gen_compare_reg (LT, operands[1], const0_rtx);\n+\trtx x = gen_rtx_LT (VOIDmode, ccreg, const0_rtx);\n+\temit_insn (gen_csneg3<mode>_insn (operands[0], x, operands[1], operands[1]));\n+\tDONE;\n+      }\n   }\n )\n \n@@ -4379,6 +4390,17 @@\n   [(set_attr \"type\" \"csel\")]\n )\n \n+(define_insn \"aarch64_umax<mode>3_insn\"\n+  [(set (match_operand:GPI 0 \"register_operand\" \"=r,r\")\n+        (umax:GPI (match_operand:GPI 1 \"register_operand\" \"r,r\")\n+\t\t(match_operand:GPI 2 \"aarch64_uminmax_operand\" \"r,Uum\")))]\n+  \"TARGET_CSSC\"\n+  \"@\n+   umax\\\\t%<w>0, %<w>1, %<w>2\n+   umax\\\\t%<w>0, %<w>1, %2\"\n+  [(set_attr \"type\" \"alu_sreg,alu_imm\")]\n+)\n+\n ;; If X can be loaded by a single CNT[BHWD] instruction,\n ;;\n ;;    A = UMAX (B, X)\n@@ -4409,11 +4431,23 @@\n   [(set (match_operand:GPI 0 \"register_operand\")\n \t(umax:GPI (match_operand:GPI 1 \"\")\n \t\t  (match_operand:GPI 2 \"\")))]\n-  \"TARGET_SVE\"\n+  \"TARGET_SVE || TARGET_CSSC\"\n   {\n     if (aarch64_sve_cnt_immediate (operands[1], <MODE>mode))\n       std::swap (operands[1], operands[2]);\n-    else if (!aarch64_sve_cnt_immediate (operands[2], <MODE>mode))\n+    else if (!aarch64_sve_cnt_immediate (operands[2], <MODE>mode)\n+\t     && TARGET_CSSC)\n+      {\n+\tif (aarch64_uminmax_immediate (operands[1], <MODE>mode))\n+\t  std::swap (operands[1], operands[2]);\n+\toperands[1] = force_reg (<MODE>mode, operands[1]);\n+\tif (!aarch64_uminmax_operand (operands[2], <MODE>mode))\n+\t  operands[2] = force_reg (<MODE>mode, operands[2]);\n+\temit_insn (gen_aarch64_umax<mode>3_insn (operands[0], operands[1],\n+\t\t\t\t\t\t operands[2]));\n+\tDONE;\n+      }\n+    else\n       FAIL;\n     rtx temp = gen_reg_rtx (<MODE>mode);\n     operands[1] = force_reg (<MODE>mode, operands[1]);\n@@ -4963,35 +4997,47 @@\n   }\n )\n \n-;; Pop count be done via the \"CNT\" instruction in AdvSIMD.\n-;;\n+(define_insn \"*aarch64_popcount<mode>2_cssc_insn\"\n+  [(set (match_operand:GPI 0 \"register_operand\" \"=r\")\n+        (popcount:GPI (match_operand:GPI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_CSSC\"\n+  \"cnt\\\\t%<w>0, %<w>1\"\n+  [(set_attr \"type\" \"clz\")]\n+)\n+\n+;; The CSSC instructions can do popcount in the GP registers directly through\n+;; CNT.  If it is not available then we can use CNT on the Advanced SIMD side\n+;; through:\n ;; MOV\tv.1d, x0\n ;; CNT\tv1.8b, v.8b\n ;; ADDV b2, v1.8b\n ;; MOV\tw0, v2.b[0]\n \n (define_expand \"popcount<mode>2\"\n-  [(match_operand:GPI 0 \"register_operand\")\n-   (match_operand:GPI 1 \"register_operand\")]\n-  \"TARGET_SIMD\"\n+  [(set (match_operand:GPI 0 \"register_operand\")\n+\t(popcount:GPI (match_operand:GPI 1 \"register_operand\")))]\n+  \"TARGET_CSSC || TARGET_SIMD\"\n {\n-  rtx v = gen_reg_rtx (V8QImode);\n-  rtx v1 = gen_reg_rtx (V8QImode);\n-  rtx in = operands[1];\n-  rtx out = operands[0];\n-  if(<MODE>mode == SImode)\n+  if (!TARGET_CSSC)\n     {\n-      rtx tmp;\n-      tmp = gen_reg_rtx (DImode);\n-      /* If we have SImode, zero extend to DImode, pop count does\n-         not change if we have extra zeros. */\n-      emit_insn (gen_zero_extendsidi2 (tmp, in));\n-      in = tmp;\n+      rtx v = gen_reg_rtx (V8QImode);\n+      rtx v1 = gen_reg_rtx (V8QImode);\n+      rtx in = operands[1];\n+      rtx out = operands[0];\n+      if(<MODE>mode == SImode)\n+\t{\n+\t  rtx tmp;\n+\t  tmp = gen_reg_rtx (DImode);\n+\t  /* If we have SImode, zero extend to DImode, pop count does\n+\t     not change if we have extra zeros. */\n+\t  emit_insn (gen_zero_extendsidi2 (tmp, in));\n+\t  in = tmp;\n+\t}\n+      emit_move_insn (v, gen_lowpart (V8QImode, in));\n+      emit_insn (gen_popcountv8qi2 (v1, v));\n+      emit_insn (gen_aarch64_zero_extend<mode>_reduc_plus_v8qi (out, v1));\n+      DONE;\n     }\n-  emit_move_insn (v, gen_lowpart (V8QImode, in));\n-  emit_insn (gen_popcountv8qi2 (v1, v));\n-  emit_insn (gen_aarch64_zero_extend<mode>_reduc_plus_v8qi (out, v1));\n-  DONE;\n })\n \n (define_insn \"clrsb<mode>2\"\n@@ -5013,14 +5059,14 @@\n ;; Split after reload into RBIT + CLZ.  Since RBIT is represented as an UNSPEC\n ;; it is unlikely to fold with any other operation, so keep this as a CTZ\n ;; expression and split after reload to enable scheduling them apart if\n-;; needed.\n+;; needed.  For TARGET_CSSC we have a single CTZ instruction that can do this.\n \n (define_insn_and_split \"ctz<mode>2\"\n  [(set (match_operand:GPI           0 \"register_operand\" \"=r\")\n        (ctz:GPI (match_operand:GPI  1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"#\"\n-  \"reload_completed\"\n+  { return TARGET_CSSC ? \"ctz\\\\t%<w>0, %<w>1\" : \"#\"; }\n+  \"reload_completed && !TARGET_CSSC\"\n   [(const_int 0)]\n   \"\n   emit_insn (gen_aarch64_rbit (<MODE>mode, operands[0], operands[1]));\n@@ -6659,6 +6705,17 @@\n   [(set_attr \"type\" \"ffarith<stype>\")]\n )\n \n+(define_insn \"<optab><mode>3\"\n+  [(set (match_operand:GPI 0 \"register_operand\" \"=r,r\")\n+        (MAXMIN_NOUMAX:GPI (match_operand:GPI 1 \"register_operand\" \"r,r\")\n+\t\t(match_operand:GPI 2 \"aarch64_<su>minmax_operand\" \"r,U<su>m\")))]\n+  \"TARGET_CSSC\"\n+  \"@\n+   <optab>\\\\t%<w>0, %<w>1, %<w>2\n+   <optab>\\\\t%<w>0, %<w>1, %2\"\n+  [(set_attr \"type\" \"alu_sreg,alu_imm\")]\n+)\n+\n ;; Given that smax/smin do not specify the result when either input is NaN,\n ;; we could use either FMAXNM or FMAX for smax, and either FMINNM or FMIN\n ;; for smin."}, {"sha": "29efb6c0cff7574c9b239ef358acaca96dd75d03", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=d758d1908899cf388638e1c1790c6f10e7441090", "patch": "@@ -152,6 +152,11 @@\n        (match_test \"aarch64_symbolic_address_p (op)\")\n        (match_test \"aarch64_mov_operand_p (op, GET_MODE (op))\")))\n \n+(define_constraint \"Usm\"\n+ \"A constant that can be used with the S[MIN/MAX] CSSC instructions.\"\n+ (and (match_code \"const_int\")\n+      (match_test \"aarch64_sminmax_immediate (op, VOIDmode)\")))\n+\n ;; const is needed here to support UNSPEC_SALT_ADDR.\n (define_constraint \"Usw\"\n   \"@internal\n@@ -389,6 +394,11 @@\n   (and (match_code \"const_double,const_vector\")\n        (match_test \"aarch64_float_const_representable_p (op)\")))\n \n+(define_constraint \"Uum\"\n+ \"A constant that can be used with the U[MIN/MAX] CSSC instructions.\"\n+ (and (match_code \"const_int\")\n+      (match_test \"aarch64_uminmax_immediate (op, VOIDmode)\")))\n+\n (define_constraint \"Uvi\"\n   \"A floating point constant which can be used with a\\\n    MOVI immediate operation.\""}, {"sha": "718b4c08a0249d9be0b134e222538f80da23bc7f", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=d758d1908899cf388638e1c1790c6f10e7441090", "patch": "@@ -2186,6 +2186,9 @@\n ;; Code iterator for variants of vector max and min.\n (define_code_iterator MAXMIN [smax smin umax umin])\n \n+;; Code iterator for min/max ops but without UMAX.\n+(define_code_iterator MAXMIN_NOUMAX [smax smin umin])\n+\n (define_code_iterator FMAXMIN [smax smin])\n \n ;; Signed and unsigned max operations."}, {"sha": "6175875fbc6be6b0bff77873f55e5e6d44378d0c", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=d758d1908899cf388638e1c1790c6f10e7441090", "patch": "@@ -148,6 +148,22 @@\n   (and (match_code \"const_int\")\n        (match_test \"(INTVAL (op) < 0xffffff && INTVAL (op) > -0xffffff)\")))\n \n+(define_predicate \"aarch64_sminmax_immediate\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), -128, 127)\")))\n+\n+(define_predicate \"aarch64_sminmax_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"aarch64_sminmax_immediate\")))\n+\n+(define_predicate \"aarch64_uminmax_immediate\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 255)\")))\n+\n+(define_predicate \"aarch64_uminmax_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"aarch64_uminmax_immediate\")))\n+\n (define_predicate \"aarch64_pluslong_strict_immedate\"\n   (and (match_operand 0 \"aarch64_pluslong_immediate\")\n        (not (match_operand 0 \"aarch64_plus_immediate\"))))"}, {"sha": "40f667a630ad6af31acbbc3a873a04dbecacac16", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d758d1908899cf388638e1c1790c6f10e7441090", "patch": "@@ -20249,6 +20249,8 @@ Enable the instructions to accelerate memory operations like @code{memcpy},\n Enable the Flag Manipulation instructions Extension.\n @item pauth\n Enable the Pointer Authentication Extension.\n+@item cssc\n+Enable the Common Short Sequence Compression instructions.\n \n @end table\n "}, {"sha": "eecd00b25366dfbc760d6af8ffaf0a831fa07b54", "filename": "gcc/testsuite/gcc.target/aarch64/cssc_1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_1.c?ref=d758d1908899cf388638e1c1790c6f10e7441090", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"--save-temps -O1\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#include <stdint.h>\n+\n+#pragma GCC target \"+cssc\"\n+\n+/*\n+** absw:\n+**      abs\tw0, w0\n+**      ret\n+*/\n+\n+int32_t\n+absw (int32_t a)\n+{\n+  return __builtin_abs (a);\n+}\n+\n+/*\n+** absx:\n+**      abs\tx0, x0\n+**      ret\n+*/\n+\n+int64_t\n+absx (int64_t a)\n+{\n+  return __builtin_labs (a);\n+}\n+"}, {"sha": "1637d29c6dc20c0eb55c5f3d05157b5b6c581fdc", "filename": "gcc/testsuite/gcc.target/aarch64/cssc_2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_2.c?ref=d758d1908899cf388638e1c1790c6f10e7441090", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"--save-temps -O1\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#include <stdint.h>\n+\n+#pragma GCC target \"+cssc\"\n+\n+/*\n+** cntw:\n+**      cnt\tw0, w0\n+**      ret\n+*/\n+\n+int32_t\n+cntw (int32_t a)\n+{\n+  return __builtin_popcount (a);\n+}\n+\n+/*\n+** cntx:\n+**      cnt\tx0, x0\n+**      ret\n+*/\n+\n+int64_t\n+cntx (int64_t a)\n+{\n+  return __builtin_popcountll (a);\n+}\n+"}, {"sha": "8965256c08e1e9a83c06a094e7ec533baae61619", "filename": "gcc/testsuite/gcc.target/aarch64/cssc_3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_3.c?ref=d758d1908899cf388638e1c1790c6f10e7441090", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"--save-temps -O1\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#include <stdint.h>\n+\n+#pragma GCC target \"+cssc\"\n+\n+/*\n+** ctzw:\n+**      ctz\tw0, w0\n+**      ret\n+*/\n+\n+int32_t\n+ctzw (int32_t a)\n+{\n+  return __builtin_ctz (a);\n+}\n+\n+/*\n+** ctzx:\n+**      ctz\tx0, x0\n+**      ret\n+*/\n+\n+int64_t\n+ctzx (int64_t a)\n+{\n+  return __builtin_ctzll (a);\n+}\n+"}, {"sha": "34ccd0e7c3b03a214fa36a3d07955d787afb3ccd", "filename": "gcc/testsuite/gcc.target/aarch64/cssc_4.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_4.c?ref=d758d1908899cf388638e1c1790c6f10e7441090", "patch": "@@ -0,0 +1,107 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"--save-temps -O1\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#include <stdint.h>\n+\n+#pragma GCC target \"+cssc\"\n+\n+#define MIN(X, Y) ((X) > (Y) ? (Y) : (X))\n+#define MAX(X, Y) ((X) > (Y) ? (X) : (Y))\n+\n+/*\n+** uminw:\n+**      umin\tw0, w[01], w[01]\n+**      ret\n+*/\n+\n+uint32_t\n+uminw (uint32_t a, uint32_t b)\n+{\n+  return MIN (a, b);\n+}\n+\n+/*\n+** uminx:\n+**      umin\tx0, x[01], x[01]\n+**      ret\n+*/\n+\n+uint64_t\n+uminx (uint64_t a, uint64_t b)\n+{\n+  return MIN (a, b);\n+}\n+\n+/*\n+** sminw:\n+**      smin\tw0, w[01], w[01]\n+**      ret\n+*/\n+\n+int32_t\n+sminw (int32_t a, int32_t b)\n+{\n+  return MIN (a, b);\n+}\n+\n+/*\n+** sminx:\n+**      smin\tx0, x[01], x[01]\n+**      ret\n+*/\n+\n+int64_t\n+sminx (int64_t a, int64_t b)\n+{\n+  return MIN (a, b);\n+}\n+\n+/*\n+** umaxw:\n+**      umax\tw0, w[01], w[01]\n+**      ret\n+*/\n+\n+uint32_t\n+umaxw (uint32_t a, uint32_t b)\n+{\n+  return MAX (a, b);\n+}\n+\n+/*\n+** umaxx:\n+**      umax\tx0, x[01], x[01]\n+**      ret\n+*/\n+\n+uint64_t\n+umaxx (uint64_t a, uint64_t b)\n+{\n+  return MAX (a, b);\n+}\n+\n+/*\n+** smaxw:\n+**      smax\tw0, w[01], w[01]\n+**      ret\n+*/\n+\n+int32_t\n+smaxw (int32_t a, int32_t b)\n+{\n+  return MAX (a, b);\n+}\n+\n+/*\n+** smaxx:\n+**      smax\tx0, x[01], x[01]\n+**      ret\n+*/\n+\n+int64_t\n+smaxx (int64_t a, int64_t b)\n+{\n+  return MAX (a, b);\n+}\n+"}, {"sha": "51495195eaea745b62df00e47f590faaaba348ae", "filename": "gcc/testsuite/gcc.target/aarch64/cssc_5.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d758d1908899cf388638e1c1790c6f10e7441090/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcssc_5.c?ref=d758d1908899cf388638e1c1790c6f10e7441090", "patch": "@@ -0,0 +1,154 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"--save-temps -O1\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */\n+\n+#include <stdint.h>\n+\n+#pragma GCC target \"+cssc\"\n+\n+#define MIN(X, Y) ((X) > (Y) ? (Y) : (X))\n+#define MAX(X, Y) ((X) > (Y) ? (X) : (Y))\n+\n+#define FUNC(T, OP, IMM)                \\\n+T                                       \\\n+T##_##OP##_##IMM (T a)                  \\\n+{                                       \\\n+  return OP (a, IMM);                   \\\n+}                                       \\\n+\n+#define FUNCNEG(T, OP, IMM)             \\\n+T                                       \\\n+T##_##OP##_m##IMM (T a)                 \\\n+{                                       \\\n+  return OP (a, - (IMM));               \\\n+}                                       \\\n+\n+/*\n+** uint32_t_MIN_255:\n+**      umin\tw0, w0, 255\n+**      ret\n+*/\n+\n+FUNC (uint32_t, MIN, 255)\n+\n+/*\n+** uint64_t_MIN_255:\n+**      umin\tx0, x0, 255\n+**      ret\n+*/\n+\n+FUNC (uint64_t, MIN, 255)\n+\n+/*\n+** uint32_t_MAX_255:\n+**      umax\tw0, w0, 255\n+**      ret\n+*/\n+\n+FUNC (uint32_t, MAX, 255)\n+\n+\n+/*\n+** uint64_t_MAX_255:\n+**      umax\tx0, x0, 255\n+**      ret\n+*/\n+\n+FUNC (uint64_t, MAX, 255)\n+\n+/*\n+** int32_t_MIN_m128:\n+**      smin\tw0, w0, -128\n+**      ret\n+*/\n+\n+FUNCNEG (int32_t, MIN, 128)\n+\n+/*\n+** int32_t_MIN_127:\n+**      smin\tw0, w0, 127\n+**      ret\n+*/\n+\n+FUNC (int32_t, MIN, 127)\n+\n+/*\n+** int64_t_MIN_m128:\n+**      smin\tx0, x0, -128\n+**      ret\n+*/\n+\n+FUNCNEG (int64_t, MIN, 128)\n+\n+/*\n+** int64_t_MIN_127:\n+**      smin\tx0, x0, 127\n+**      ret\n+*/\n+\n+FUNC (int64_t, MIN, 127)\n+\n+/*\n+** int32_t_MAX_m128:\n+**      smax\tw0, w0, -128\n+**      ret\n+*/\n+\n+FUNCNEG (int32_t, MAX, 128)\n+\n+/*\n+** int32_t_MAX_127:\n+**      smax\tw0, w0, 127\n+**      ret\n+*/\n+\n+FUNC (int32_t, MAX, 127)\n+\n+/*\n+** int64_t_MAX_m128:\n+**      smax\tx0, x0, -128\n+**      ret\n+*/\n+\n+FUNCNEG (int64_t, MAX, 128)\n+\n+/*\n+** int64_t_MAX_127:\n+**      smax\tx0, x0, 127\n+**      ret\n+*/\n+\n+FUNC (int64_t, MAX, 127)\n+\n+/*\n+** int32_t_MIN_0:\n+**      smin\tw0, w0, 0\n+**      ret\n+*/\n+\n+FUNC (int32_t, MIN, 0)\n+\n+/*\n+** int64_t_MIN_0:\n+**      smin\tx0, x0, 0\n+**      ret\n+*/\n+\n+FUNC (int64_t, MIN, 0)\n+\n+/*\n+** int32_t_MAX_0:\n+**      smax\tw0, w0, 0\n+**      ret\n+*/\n+\n+FUNC (int32_t, MAX, 0)\n+\n+/*\n+** int64_t_MAX_0:\n+**      smax\tx0, x0, 0\n+**      ret\n+*/\n+\n+FUNC (int64_t, MAX, 0)\n+"}]}