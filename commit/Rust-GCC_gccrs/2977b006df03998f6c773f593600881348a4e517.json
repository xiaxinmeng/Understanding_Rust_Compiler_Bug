{"sha": "2977b006df03998f6c773f593600881348a4e517", "node_id": "C_kwDOANBUbNoAKDI5NzdiMDA2ZGYwMzk5OGY2Yzc3M2Y1OTM2MDA4ODEzNDhhNGU1MTc", "commit": {"author": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-04-22T15:52:49Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-06-01T08:43:19Z"}, "message": "[Ada] Fix predicate check on object declaration\n\nWhen subtype predicate checks are added for object declarations, it\ncould lead to a compiler crash or to an incorrect check.\n\nWhen the subtype for the object being declared is built later by\nAnalyze_Object_Declaration, the predicate check can't be applied on the\nobject instead of a copy as the call will be incorrect after the subtype\nhas been built.\n\nWhen subtypes for LHS and RHS do not statically match, only checking the\npredicate on the object after it has been initialized may miss a failing\npredicate on the RHS.\n\nIn both cases, skip the optimization and check the predicate on a copy.\n\nRename Should_Build_Subtype into Build_Default_Subtype_OK and move it\nout of sem_ch3 to make it available to other part of the compiler (in\nparticular to checks.adb).\n\ngcc/ada/\n\n\t* checks.adb (Apply_Predicate_Check): Refine condition for\n\tapplying optimization.\n\t* sem_ch3.adb (Analyze_Component_Declaration): Adjust calls to\n\tShould_Build_Subtype.\n\t(Analyze_Object_Declaration): Likewise.\n\t(Should_Build_Subtype): Rename/move to ...\n\t* sem_util.ads (Build_Default_Subtype_OK): ... this.\n\t* sem_util.adb (Build_Default_Subtype_OK): Moved from\n\tsem_ch3.adb.", "tree": {"sha": "5734554d786a10be1436ca2f0aede782b50ccad2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5734554d786a10be1436ca2f0aede782b50ccad2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2977b006df03998f6c773f593600881348a4e517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2977b006df03998f6c773f593600881348a4e517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2977b006df03998f6c773f593600881348a4e517", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2977b006df03998f6c773f593600881348a4e517/comments", "author": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ba4b38f6ac6d80130808943f20011ab8855695d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ba4b38f6ac6d80130808943f20011ab8855695d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ba4b38f6ac6d80130808943f20011ab8855695d"}], "stats": {"total": 198, "additions": 106, "deletions": 92}, "files": [{"sha": "204d13efc72144d16f2529f9f62d1cbce1ff9c3e", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2977b006df03998f6c773f593600881348a4e517/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2977b006df03998f6c773f593600881348a4e517/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=2977b006df03998f6c773f593600881348a4e517", "patch": "@@ -2944,14 +2944,28 @@ package body Checks is\n \n          --  Similarly, if the expression is an aggregate in an object\n          --  declaration, apply it to the object after the declaration.\n-         --  This is only necessary in rare cases of tagged extensions\n-         --  initialized with an aggregate with an \"others => <>\" clause.\n+\n+         --  This is only necessary in cases of tagged extensions\n+         --  initialized with an aggregate with an \"others => <>\" clause,\n+         --  when the subtypes of LHS and RHS do not statically match or\n+         --  when we know the object's type will be rewritten later.\n+         --  The condition for the later is copied from the\n+         --  Analyze_Object_Declaration procedure when it actually builds the\n+         --  subtype.\n \n          elsif Nkind (Par) = N_Object_Declaration then\n-            Insert_Action_After (Par,\n-              Make_Predicate_Check (Typ,\n-                New_Occurrence_Of (Defining_Identifier (Par), Sloc (N))));\n-            return;\n+            if Subtypes_Statically_Match\n+                 (Etype (Defining_Identifier (Par)), Typ)\n+              and then (Nkind (N) = N_Extension_Aggregate\n+                         or else (Is_Definite_Subtype (Typ)\n+                                   and then Build_Default_Subtype_OK (Typ)))\n+            then\n+               Insert_Action_After (Par,\n+                  Make_Predicate_Check (Typ,\n+                    New_Occurrence_Of (Defining_Identifier (Par), Sloc (N))));\n+               return;\n+            end if;\n+\n          end if;\n       end if;\n "}, {"sha": "2dbba159980bfcd21602c40277154628e9da6db9", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 86, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2977b006df03998f6c773f593600881348a4e517/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2977b006df03998f6c773f593600881348a4e517/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=2977b006df03998f6c773f593600881348a4e517", "patch": "@@ -725,16 +725,6 @@ package body Sem_Ch3 is\n    --  sets the flags SSO_Set_Low_By_Default/SSO_Set_High_By_Default according\n    --  to the setting of Opt.Default_SSO.\n \n-   function Should_Build_Subtype (T : Entity_Id) return Boolean;\n-   --  When analyzing components or object declarations, it is possible, in\n-   --  some cases, to build subtypes for discriminated types. This is\n-   --  worthwhile to avoid the backend allocating the maximum possible size for\n-   --  objects of the type.\n-   --  In particular, when T is limited, the discriminants and therefore the\n-   --  size of an object of type T cannot change. Furthermore, if T is definite\n-   --  with statically initialized defaulted discriminants, we are able and\n-   --  want to build a constrained subtype of the right size.\n-\n    procedure Signed_Integer_Type_Declaration (T : Entity_Id; Def : Node_Id);\n    --  Create a new signed integer entity, and apply the constraint to obtain\n    --  the required first named subtype of this type.\n@@ -2214,7 +2204,7 @@ package body Sem_Ch3 is\n \n       --  When possible, build the default subtype\n \n-      if Should_Build_Subtype (T) then\n+      if Build_Default_Subtype_OK (T) then\n          declare\n             Act_T : constant Entity_Id := Build_Default_Subtype (T, N);\n \n@@ -4815,7 +4805,7 @@ package body Sem_Ch3 is\n \n       --  When possible, build the default subtype\n \n-      elsif Should_Build_Subtype (T) then\n+      elsif Build_Default_Subtype_OK (T) then\n          if No (E) then\n             Act_T := Build_Default_Subtype (T, N);\n          else\n@@ -22963,80 +22953,6 @@ package body Sem_Ch3 is\n       end if;\n    end Set_Stored_Constraint_From_Discriminant_Constraint;\n \n-   --------------------------\n-   -- Should_Build_Subtype --\n-   --------------------------\n-\n-   function Should_Build_Subtype (T : Entity_Id) return Boolean is\n-\n-      function Default_Discriminant_Values_Known_At_Compile_Time\n-         (T : Entity_Id) return Boolean;\n-         --  For an unconstrained type T, return False if the given type has a\n-         --  discriminant with default value not known at compile time. Return\n-         --  True otherwise.\n-\n-      ---------------------------------------------------------\n-      -- Default_Discriminant_Values_Known_At_Compile_Time --\n-      ---------------------------------------------------------\n-\n-      function Default_Discriminant_Values_Known_At_Compile_Time\n-         (T : Entity_Id) return Boolean\n-      is\n-         Discr : Entity_Id;\n-         DDV : Node_Id;\n-\n-      begin\n-\n-         --  If the type has no discriminant, we know them all at compile time\n-\n-         if not Has_Discriminants (T) then\n-            return True;\n-         end if;\n-\n-         --  The type has discriminants, check that none of them has a default\n-         --  value not known at compile time.\n-\n-         Discr := First_Discriminant (T);\n-\n-         while Present (Discr) loop\n-            DDV := Discriminant_Default_Value (Discr);\n-\n-            if Present (DDV) and then not Compile_Time_Known_Value (DDV) then\n-               return False;\n-            end if;\n-\n-            Next_Discriminant (Discr);\n-         end loop;\n-\n-         return True;\n-      end Default_Discriminant_Values_Known_At_Compile_Time;\n-\n-   --  Start of processing for Should_Build_Subtype\n-\n-   begin\n-\n-      if Is_Constrained (T) then\n-\n-         --  We won't build a new subtype if T is constrained\n-\n-         return False;\n-      end if;\n-\n-      if not Default_Discriminant_Values_Known_At_Compile_Time (T) then\n-\n-         --  This is a special case of definite subtypes. To allocate a\n-         --  specific size to the subtype, we need to know the value at compile\n-         --  time. This might not be the case if the default value is the\n-         --  result of a function. In that case, the object might be definite\n-         --  and limited but the needed size might not be statically known or\n-         --  too tricky to obtain. In that case, we will not build the subtype.\n-\n-         return False;\n-      end if;\n-\n-      return Is_Definite_Subtype (T) and then Is_Limited_View (T);\n-   end Should_Build_Subtype;\n-\n    -------------------------------------\n    -- Signed_Integer_Type_Declaration --\n    -------------------------------------"}, {"sha": "eb0a1f1173351400a3c482655caf0de23ee3d442", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2977b006df03998f6c773f593600881348a4e517/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2977b006df03998f6c773f593600881348a4e517/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=2977b006df03998f6c773f593600881348a4e517", "patch": "@@ -2533,6 +2533,80 @@ package body Sem_Util is\n       end;\n    end Build_Default_Subtype;\n \n+   ------------------------------\n+   -- Build_Default_Subtype_OK --\n+   ------------------------------\n+\n+   function Build_Default_Subtype_OK (T : Entity_Id) return Boolean is\n+\n+      function Default_Discriminant_Values_Known_At_Compile_Time\n+         (T : Entity_Id) return Boolean;\n+         --  For an unconstrained type T, return False if the given type has a\n+         --  discriminant with default value not known at compile time. Return\n+         --  True otherwise.\n+\n+      ---------------------------------------------------------\n+      -- Default_Discriminant_Values_Known_At_Compile_Time --\n+      ---------------------------------------------------------\n+\n+      function Default_Discriminant_Values_Known_At_Compile_Time\n+         (T : Entity_Id) return Boolean\n+      is\n+         Discr : Entity_Id;\n+         DDV : Node_Id;\n+\n+      begin\n+\n+         --  If the type has no discriminant, we know them all at compile time\n+\n+         if not Has_Discriminants (T) then\n+            return True;\n+         end if;\n+\n+         --  The type has discriminants, check that none of them has a default\n+         --  value not known at compile time.\n+\n+         Discr := First_Discriminant (T);\n+\n+         while Present (Discr) loop\n+            DDV := Discriminant_Default_Value (Discr);\n+\n+            if Present (DDV) and then not Compile_Time_Known_Value (DDV) then\n+               return False;\n+            end if;\n+\n+            Next_Discriminant (Discr);\n+         end loop;\n+\n+         return True;\n+      end Default_Discriminant_Values_Known_At_Compile_Time;\n+\n+   --  Start of processing for Build_Default_Subtype_OK\n+\n+   begin\n+\n+      if Is_Constrained (T) then\n+\n+         --  We won't build a new subtype if T is constrained\n+\n+         return False;\n+      end if;\n+\n+      if not Default_Discriminant_Values_Known_At_Compile_Time (T) then\n+\n+         --  This is a special case of definite subtypes. To allocate a\n+         --  specific size to the subtype, we need to know the value at compile\n+         --  time. This might not be the case if the default value is the\n+         --  result of a function. In that case, the object might be definite\n+         --  and limited but the needed size might not be statically known or\n+         --  too tricky to obtain. In that case, we will not build the subtype.\n+\n+         return False;\n+      end if;\n+\n+      return Is_Definite_Subtype (T) and then Is_Limited_View (T);\n+   end Build_Default_Subtype_OK;\n+\n    --------------------------------------------\n    -- Build_Discriminal_Subtype_Of_Component --\n    --------------------------------------------"}, {"sha": "37118ccb809c7ffbe5743c78fcea2a21f984617c", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2977b006df03998f6c773f593600881348a4e517/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2977b006df03998f6c773f593600881348a4e517/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=2977b006df03998f6c773f593600881348a4e517", "patch": "@@ -320,6 +320,16 @@ package Sem_Util is\n    --  declaration in the tree before N, and return the entity of that\n    --  subtype. Otherwise, simply return T.\n \n+   function Build_Default_Subtype_OK (T : Entity_Id) return Boolean;\n+   --  When analyzing components or object declarations, it is possible, in\n+   --  some cases, to build subtypes for discriminated types. This is\n+   --  worthwhile to avoid the backend allocating the maximum possible size for\n+   --  objects of the type.\n+   --  In particular, when T is limited, the discriminants and therefore the\n+   --  size of an object of type T cannot change. Furthermore, if T is definite\n+   --  with statically initialized defaulted discriminants, we are able and\n+   --  want to build a constrained subtype of the right size.\n+\n    function Build_Discriminal_Subtype_Of_Component\n      (T : Entity_Id) return Node_Id;\n    --  Determine whether a record component has a type that depends on"}]}