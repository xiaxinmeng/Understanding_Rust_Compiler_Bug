{"sha": "833fc3ad2371e77287a7c2456b11d7da43f11d7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMzZmMzYWQyMzcxZTc3Mjg3YTdjMjQ1NmIxMWQ3ZGE0M2YxMWQ3Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-12-17T11:10:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-12-17T11:10:58Z"}, "message": "gcse.c (try_replace_reg): Do replacements in REG_EQUAL/REG_EQUIV notes too...\n\n\t* gcse.c (try_replace_reg): Do replacements in REG_EQUAL/REG_EQUIV\n\tnotes too, create one when replacement failed, attempt to simplify\n\tresulting notes.\n\t(cprop_insn): Propagate even to registers mentioned only in REG_EQUAL\n\tor REG_EQUIV notes.\n\nFrom-SVN: r30992", "tree": {"sha": "b830cb088c1b2c2b3b055d29eab46f83ec51aec9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b830cb088c1b2c2b3b055d29eab46f83ec51aec9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/833fc3ad2371e77287a7c2456b11d7da43f11d7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/833fc3ad2371e77287a7c2456b11d7da43f11d7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/833fc3ad2371e77287a7c2456b11d7da43f11d7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/833fc3ad2371e77287a7c2456b11d7da43f11d7c/comments", "author": null, "committer": null, "parents": [{"sha": "5928cc35dbc3f6fe25a288fccf389581f94c159e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5928cc35dbc3f6fe25a288fccf389581f94c159e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5928cc35dbc3f6fe25a288fccf389581f94c159e"}], "stats": {"total": 69, "additions": 67, "deletions": 2}, "files": [{"sha": "1728e84f13e86e6c0d7068f96a25120c3970c727", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/833fc3ad2371e77287a7c2456b11d7da43f11d7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/833fc3ad2371e77287a7c2456b11d7da43f11d7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=833fc3ad2371e77287a7c2456b11d7da43f11d7c", "patch": "@@ -1,3 +1,11 @@\n+Fri Dec 17 12:08:11 MET 1999  Jan Hubicka  <hubicka@freesoftr.cz>\n+\n+\t* gcse.c (try_replace_reg): Do replacements in REG_EQUAL/REG_EQUIV\n+\tnotes too, create one when replacement failed, attempt to simplify\n+\tresulting notes.\n+\t(cprop_insn): Propagate even to registers mentioned only in REG_EQUAL\n+\tor REG_EQUIV notes.\n+\n 1999-12-16  Mark Mitchell  <mark@codesourcery.com>\n \n \t* crtstuff.c (__dso_handle): Declare."}, {"sha": "dc45ac1fcd0a93dd0df0572a327adc938557a5f7", "filename": "gcc/gcse.c", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/833fc3ad2371e77287a7c2456b11d7da43f11d7c/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/833fc3ad2371e77287a7c2456b11d7da43f11d7c/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=833fc3ad2371e77287a7c2456b11d7da43f11d7c", "patch": "@@ -3702,14 +3702,62 @@ static int\n try_replace_reg (from, to, insn)\n      rtx from, to, insn;\n {\n+  rtx note;\n+  rtx src;\n+  int success;\n+  rtx set;\n+\n+  note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n+\n+  if (!note)\n+    note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n+\n   /* If this fails we could try to simplify the result of the\n      replacement and attempt to recognize the simplified insn.\n \n      But we need a general simplify_rtx that doesn't have pass\n      specific state variables.  I'm not aware of one at the moment.  */\n-  return validate_replace_src (from, to, insn);\n-}\n \n+\n+  success = validate_replace_src (from, to, insn);\n+  set = single_set (insn);\n+\n+  /* We've failed to do replacement. Try to add REG_EQUAL note to not loose\n+     information.  */\n+  if (!success && !note)\n+    {\n+      if (!set)\n+\treturn 0;\n+      note = REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t\t\t   copy_rtx (SET_SRC (set)),\n+\t\t\t\t\t\t   REG_NOTES (insn));\n+    }\n+\n+  /* Always do the replacement in REQ_EQUAL and REG_EQUIV notes.  Also\n+     try to simplify them.  */\n+  if (note)\n+    {\n+      rtx simplified;\n+      src = XEXP (note, 0);\n+      replace_rtx (src, from, to);\n+\n+      /* Try to simplify resulting note. */\n+      simplified = simplify_rtx (src);\n+      if (simplified)\n+\t{\n+\t  src = simplified;\n+\t  XEXP (note, 0) = src;\n+\t}\n+\n+      /* REG_EQUAL may get simplified into register.\n+         We don't allow that. Remove that note. This code ought\n+         not to hapen, because previous code ought to syntetize\n+         reg-reg move, but be on the safe side.  */\n+      else if (REG_P (src))\n+\tremove_note (insn, note);\n+    }\n+  return success;\n+}\n /* Find a set of REGNO that is available on entry to INSN's block.\n    Returns NULL if not found.  */\n \n@@ -3897,6 +3945,7 @@ cprop_insn (insn, alter_jumps)\n {\n   struct reg_use *reg_used;\n   int changed = 0;\n+  rtx note;\n \n   /* Only propagate into SETs.  Note that a conditional jump is a\n      SET with pc_rtx as the destination.  */\n@@ -3907,6 +3956,14 @@ cprop_insn (insn, alter_jumps)\n \n   reg_use_count = 0;\n   find_used_regs (PATTERN (insn));\n+  \n+  note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n+  if (!note)\n+    note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n+\n+  /* We may win even when propagating constants into notes. */\n+  if (note)\n+    find_used_regs (XEXP (note, 0));\n \n   reg_used = &reg_use_table[0];\n   for ( ; reg_use_count > 0; reg_used++, reg_use_count--)"}]}