{"sha": "6e7f952e96c08b97602e80d0961265090c707242", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU3Zjk1MmU5NmMwOGI5NzYwMmU4MGQwOTYxMjY1MDkwYzcwNzI0Mg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-12-24T20:49:47Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-12-24T20:49:47Z"}, "message": "(read_name_map, read_filename_string, open_include_file):\n\nNew functions.\n(struct file_name_list): New members: name_map, got_name_map.\n(main, path_include, do_include, do_once): Set got_name_map.\n(do_include): Use open_include_file instead of open.  Add new\nparameter to lookup_import calls.\n(lookup_import): New parameter searchptr.  Call open_include_file\ninstead of open.\n\nFrom-SVN: r6307", "tree": {"sha": "7b997e0b369b8ad3700d86f0ded90e93d7bf5343", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b997e0b369b8ad3700d86f0ded90e93d7bf5343"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e7f952e96c08b97602e80d0961265090c707242", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e7f952e96c08b97602e80d0961265090c707242", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e7f952e96c08b97602e80d0961265090c707242", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e7f952e96c08b97602e80d0961265090c707242/comments", "author": null, "committer": null, "parents": [{"sha": "2bf29316da96818c2db73220318bce5679431c98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf29316da96818c2db73220318bce5679431c98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf29316da96818c2db73220318bce5679431c98"}], "stats": {"total": 237, "additions": 231, "deletions": 6}, "files": [{"sha": "80e7b9f8edc2d9b20509049d67cd27f82f8e2691", "filename": "gcc/cccp.c", "status": "modified", "additions": 231, "deletions": 6, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e7f952e96c08b97602e80d0961265090c707242/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e7f952e96c08b97602e80d0961265090c707242/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=6e7f952e96c08b97602e80d0961265090c707242", "patch": "@@ -266,6 +266,9 @@ static void print_containing_files ();\n static int lookup_import ();\n static int redundant_include_p ();\n static is_system_include ();\n+static struct file_name_map *read_name_map ();\n+static char *read_filename_string ();\n+static int open_include_file ();\n static int check_preconditions ();\n static void pcfinclude ();\n static void pcstring_used ();\n@@ -547,6 +550,10 @@ struct file_name_list\n     /* If the following is nonzero, it is a C-language system include\n        directory.  */\n     int c_system_include_path;\n+    /* Mapping of file names for this directory.  */\n+    struct file_name_map *name_map;\n+    /* Non-zero if name_map is valid.  */\n+    int got_name_map;\n   };\n \n /* #include \"file\" looks in source file dir, then stack. */\n@@ -1190,6 +1197,7 @@ main (argc, argv)\n \t\t\t\t\t    + strlen (prefix) + 1);\n \t  strcpy (dirtmp->fname, prefix);\n \t  strcat (dirtmp->fname, argv[++i]);\n+\t  dirtmp->got_name_map = 0;\n \n \t  if (after_include == 0)\n \t    after_include = dirtmp;\n@@ -1224,6 +1232,7 @@ main (argc, argv)\n \t\t\t\t\t    + strlen (prefix) + 1);\n \t  strcpy (dirtmp->fname, prefix);\n \t  strcat (dirtmp->fname, argv[++i]);\n+\t  dirtmp->got_name_map = 0;\n \n \t  append_include_chain (dirtmp, dirtmp);\n \t}\n@@ -1240,6 +1249,7 @@ main (argc, argv)\n \t    fatal (\"Directory name missing after `-idirafter' option\");\n \t  else\n \t    dirtmp->fname = argv[++i];\n+\t  dirtmp->got_name_map = 0;\n \n \t  if (after_include == 0)\n \t    after_include = dirtmp;\n@@ -1494,6 +1504,7 @@ main (argc, argv)\n \t      fatal (\"Directory name missing after -I option\");\n \t    else\n \t      dirtmp->fname = argv[++i];\n+\t    dirtmp->got_name_map = 0;\n \t    append_include_chain (dirtmp, dirtmp);\n \t  }\n \t}\n@@ -1752,6 +1763,7 @@ main (argc, argv)\n \t    new->fname = str;\n \t    new->control_macro = 0;\n \t    new->c_system_include_path = !p->cplusplus;\n+\t    new->got_name_map = 0;\n \t    append_include_chain (new, new);\n \t    if (first_system_include == 0)\n \t      first_system_include = new;\n@@ -1767,6 +1779,7 @@ main (argc, argv)\n \tnew->control_macro = 0;\n \tnew->c_system_include_path = !p->cplusplus;\n \tnew->fname = p->fname;\n+\tnew->got_name_map = 0;\n \tappend_include_chain (new, new);\n \tif (first_system_include == 0)\n \t  first_system_include = new;\n@@ -2091,6 +2104,7 @@ path_include (path)\n       dirtmp->control_macro = 0;\n       dirtmp->c_system_include_path = 0;\n       dirtmp->fname = name;\n+      dirtmp->got_name_map = 0;\n       append_include_chain (dirtmp, dirtmp);\n \n       /* Advance past this name.  */\n@@ -4003,6 +4017,7 @@ do_include (buf, limit, op, keyword)\n \t    } else {\n \t      dsp[0].fname = 0; /* Current directory */\n \t    }\n+\t    dsp[0].got_name_map = 0;\n \t    break;\n \t  }\n \t}\n@@ -4072,9 +4087,9 @@ do_include (buf, limit, op, keyword)\n     if (redundant_include_p (fname))\n       return 0;\n     if (importing)\n-      f = lookup_import (fname);\n+      f = lookup_import (fname, NULL_PTR);\n     else\n-      f = open (fname, O_RDONLY, 0666);\n+      f = open_include_file (fname, NULL_PTR);\n     if (f == -2)\n       return 0;\t\t/* Already included this file */\n   } else {\n@@ -4108,9 +4123,9 @@ do_include (buf, limit, op, keyword)\n       }\n #endif /* VMS */\n       if (importing)\n-\tf = lookup_import (fname);\n+\tf = lookup_import (fname, searchptr);\n       else\n-\tf = open (fname, O_RDONLY, 0666);\n+\tf = open_include_file (fname, searchptr);\n       if (f == -2)\n \treturn 0;\t\t\t/* Already included this file */\n #ifdef EACCES\n@@ -4173,6 +4188,7 @@ do_include (buf, limit, op, keyword)\n       ptr->next = all_include_files;\n       all_include_files = ptr;\n       ptr->fname = savestring (fname);\n+      ptr->got_name_map = 0;\n \n       /* For -M, add this file to the dependencies.  */\n       if (print_deps > (angle_brackets || (system_include_depth > 0)))\n@@ -4289,6 +4305,213 @@ is_system_include (filename)\n   return 0;\n }\n \f\n+/* The file_name_map structure holds a mapping of file names for a\n+   particular directory.  This mapping is read from the file named\n+   FILE_NAME_MAP_FILE in that directory.  Such a file can be used to\n+   map filenames on a file system with severe filename restrictions,\n+   such as DOS.  The format of the file name map file is just a series\n+   of lines with two tokens on each line.  The first token is the name\n+   to map, and the second token is the actual name to use.  */\n+\n+struct file_name_map\n+{\n+  struct file_name_map *map_next;\n+  char *map_from;\n+  char *map_to;\n+};\n+\n+#define FILE_NAME_MAP_FILE \"header.gcc\"\n+\n+/* Read a space delimited string of unlimited length from a stdio\n+   file.  */\n+\n+static char *\n+read_filename_string (ch, f)\n+     int ch;\n+     FILE *f;\n+{\n+  char *alloc, *set;\n+  int len;\n+\n+  len = 20;\n+  set = alloc = xmalloc (len + 1);\n+  if (! is_space[ch])\n+    {\n+      *set++ = ch;\n+      while ((ch = getc (f)) != EOF && ! is_space[ch])\n+\t{\n+\t  if (set - alloc == len)\n+\t    {\n+\t      len *= 2;\n+\t      alloc = xrealloc (alloc, len + 1);\n+\t      set = alloc + len / 2;\n+\t    }\n+\t  *set++ = ch;\n+\t}\n+    }\n+  *set = '\\0';\n+  ungetc (ch, f);\n+  return alloc;\n+}\n+\n+/* Read the file name map file for DIRNAME.  */\n+\n+static struct file_name_map *\n+read_name_map (dirname)\n+     char *dirname;\n+{\n+  /* This structure holds a linked list of file name maps, one per\n+     directory.  */\n+  struct file_name_map_list\n+    {\n+      struct file_name_map_list *map_list_next;\n+      char *map_list_name;\n+      struct file_name_map *map_list_map;\n+    };\n+  static struct file_name_map_list *map_list;\n+  register struct file_name_map_list *map_list_ptr;\n+  char *name;\n+  FILE *f;\n+\n+  for (map_list_ptr = map_list; map_list_ptr;\n+       map_list_ptr = map_list_ptr->map_list_next)\n+    if (! strcmp (map_list_ptr->map_list_name, dirname))\n+      return map_list_ptr->map_list_map;\n+\n+  map_list_ptr = ((struct file_name_map_list *)\n+\t\t  xmalloc (sizeof (struct file_name_map_list)));\n+  map_list_ptr->map_list_name = savestring (dirname);\n+  map_list_ptr->map_list_map = NULL;\n+\n+  name = (char *) alloca (strlen (dirname) + strlen (FILE_NAME_MAP_FILE) + 2);\n+  strcpy (name, dirname);\n+  if (*dirname)\n+    strcat (name, \"/\");\n+  strcat (name, FILE_NAME_MAP_FILE);\n+  f = fopen (name, \"r\");\n+  if (!f)\n+    map_list_ptr->map_list_map = NULL;\n+  else\n+    {\n+      int ch;\n+      int dirlen = strlen (dirname);\n+\n+      while ((ch = getc (f)) != EOF)\n+\t{\n+\t  char *from, *to;\n+\t  struct file_name_map *ptr;\n+\n+\t  if (is_space[ch])\n+\t    continue;\n+\t  from = read_filename_string (ch, f);\n+\t  while ((ch = getc (f)) != EOF && is_hor_space[ch])\n+\t    ;\n+\t  to = read_filename_string (ch, f);\n+\n+\t  ptr = ((struct file_name_map *)\n+\t\t xmalloc (sizeof (struct file_name_map)));\n+\t  ptr->map_from = from;\n+\n+\t  /* Make the real filename absolute.  */\n+\t  if (*to == '/')\n+\t    ptr->map_to = to;\n+\t  else\n+\t    {\n+\t      ptr->map_to = xmalloc (dirlen + strlen (to) + 2);\n+\t      strcpy (ptr->map_to, dirname);\n+\t      ptr->map_to[dirlen] = '/';\n+\t      strcpy (ptr->map_to + dirlen + 1, to);\n+\t      free (to);\n+\t    }\t      \n+\n+\t  ptr->map_next = map_list_ptr->map_list_map;\n+\t  map_list_ptr->map_list_map = ptr;\n+\n+\t  while ((ch = getc (f)) != '\\n')\n+\t    if (ch == EOF)\n+\t      break;\n+\t}\n+      fclose (f);\n+    }\n+  \n+  map_list_ptr->map_list_next = map_list;\n+  map_list = map_list_ptr;\n+\n+  return map_list_ptr->map_list_map;\n+}  \n+\n+/* Try to open include file FILENAME.  SEARCHPTR is the directory\n+   being tried from the include file search path.  This function maps\n+   filenames on file systems based on information read by\n+   read_name_map.  */\n+\n+static int\n+open_include_file (filename, searchptr)\n+     char *filename;\n+     struct file_name_list *searchptr;\n+{\n+  register struct file_name_map *map;\n+  register char *from;\n+  char *p, *dir;\n+\n+  if (searchptr && ! searchptr->got_name_map)\n+    {\n+      searchptr->name_map = read_name_map (searchptr->fname\n+\t\t\t\t\t   ? searchptr->fname : \".\");\n+      searchptr->got_name_map = 1;\n+    }\n+\n+  /* First check the mapping for the directory we are using.  */\n+  if (searchptr && searchptr->name_map)\n+    {\n+      from = filename;\n+      if (searchptr->fname)\n+\tfrom += strlen (searchptr->fname) + 1;\n+      for (map = searchptr->name_map; map; map = map->map_next)\n+\t{\n+\t  if (! strcmp (map->map_from, from))\n+\t    {\n+\t      /* Found a match.  */\n+\t      return open (map->map_to, O_RDONLY, 0666);\n+\t    }\n+\t}\n+    }\n+\n+  /* Try to find a mapping file for the particular directory we are\n+     looking in.  Thus #include <sys/types.h> will look up sys/types.h\n+     in /usr/include/header.gcc and look up types.h in\n+     /usr/include/sys/header.gcc.  */\n+  p = rindex (filename, '/');\n+  if (! p)\n+    p = filename;\n+  if (searchptr\n+      && searchptr->fname\n+      && strlen (searchptr->fname) == p - filename\n+      && ! strncmp (searchptr->fname, filename, p - filename))\n+    {\n+      /* FILENAME is in SEARCHPTR, which we've already checked.  */\n+      return open (filename, O_RDONLY, 0666);\n+    }\n+\n+  if (p == filename)\n+    {\n+      dir = \".\";\n+      from = filename;\n+    }\n+  else\n+    {\n+      dir = (char *) alloca (p - filename + 1);\n+      bcopy (filename, dir, p - filename);\n+      dir[p - filename] = '\\0';\n+      from = p + 1;\n+    }\n+  for (map = read_name_map (dir); map; map = map->map_next)\n+    if (! strcmp (map->map_from, from))\n+      return open (map->map_to, O_RDONLY, 0666);\n+\n+  return open (filename, O_RDONLY, 0666);\n+}\n+\f\n /* Process the contents of include file FNAME, already open on descriptor F,\n    with output to OP.\n    SYSTEM_HEADER_P is 1 if this file resides in any one of the known\n@@ -4480,8 +4703,9 @@ import_hash (f)\n    or -1 if unsuccessful.  */\n \n static int\n-lookup_import (filename)\n+lookup_import (filename, searchptr)\n      char *filename;\n+     struct file_name_list *searchptr;\n {\n   struct import_file *i;\n   int h;\n@@ -4500,7 +4724,7 @@ lookup_import (filename)\n     i = i->next;\n   }\n   /* Open it and try a match on inode/dev */\n-  fd = open (filename, O_RDONLY, 0666);\n+  fd = open_include_file (filename, searchptr);\n   if (fd < 0)\n     return fd;\n   fstat (fd, &sb);\n@@ -6185,6 +6409,7 @@ do_once ()\n     dont_repeat_files = new;\n     new->fname = savestring (ip->fname);\n     new->control_macro = 0;\n+    new->got_name_map = 0;\n     new->c_system_include_path = 0;\n   }\n   return 0;"}]}