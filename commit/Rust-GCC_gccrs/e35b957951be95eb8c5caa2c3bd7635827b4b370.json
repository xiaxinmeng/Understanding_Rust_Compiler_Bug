{"sha": "e35b957951be95eb8c5caa2c3bd7635827b4b370", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM1Yjk1Nzk1MWJlOTVlYjhjNWNhYTJjM2JkNzYzNTgyN2I0YjM3MA==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "2000-10-01T05:29:14Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-10-01T05:29:14Z"}, "message": "rs6000.md (movsi_to_cr): Remove the USE.\n\n\t* config/rs6000/rs6000.md (movsi_to_cr): Remove the USE.  Calculate\n\tthe mask value from the individual SET operations.\n\t(return_internal_si): Move the USE after the RETURN.\n\t(return_internal_di): Likewise.\n\t(return_and_restore_fpregs_si): Likewise.\n\t(return_and_restore_fpregs_di): Likewise.\n\t(return_eh_si): Likewise.\n\t(return_eh_di): Likewise.\n\t* config/rs6000/rs6000.c (mtcrf_operation): Don't look for,\n\tor check, the USE.\n\t(rs6000_emit_prologue): Don't emit the USE for movsi_to_cr.\n\tDon't generate a PARALLEL around a single operation movsi_to_cr.\n\tGenerate the RETURN first in any PARALLELs.\n\n\t* rtlanal.c (single_set_1): Use fatal_insn to display the\n\tinvalid insn.  Check for more cases when a USE or CLOBBER occurs\n\tbefore a SET.\n\t* Makefile.in: Update dependencies for rtlanal.o.\n\nFrom-SVN: r36683", "tree": {"sha": "9b33000ba9e8cb51c596c7c89e8c48ae70621225", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b33000ba9e8cb51c596c7c89e8c48ae70621225"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e35b957951be95eb8c5caa2c3bd7635827b4b370", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e35b957951be95eb8c5caa2c3bd7635827b4b370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e35b957951be95eb8c5caa2c3bd7635827b4b370", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e35b957951be95eb8c5caa2c3bd7635827b4b370/comments", "author": null, "committer": null, "parents": [{"sha": "9256db1dea11f28654770cdfd450c95c3cc53a0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9256db1dea11f28654770cdfd450c95c3cc53a0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9256db1dea11f28654770cdfd450c95c3cc53a0f"}], "stats": {"total": 173, "additions": 103, "deletions": 70}, "files": [{"sha": "15e6d46ae9989463788a7dbc6370da25f83ea638", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e35b957951be95eb8c5caa2c3bd7635827b4b370/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e35b957951be95eb8c5caa2c3bd7635827b4b370/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e35b957951be95eb8c5caa2c3bd7635827b4b370", "patch": "@@ -1,3 +1,24 @@\n+2000-09-30  Geoff Keating  <geoffk@cygnus.com>\n+\n+\t* config/rs6000/rs6000.md (movsi_to_cr): Remove the USE.  Calculate\n+\tthe mask value from the individual SET operations.\n+\t(return_internal_si): Move the USE after the RETURN.\n+\t(return_internal_di): Likewise.\n+\t(return_and_restore_fpregs_si): Likewise.\n+\t(return_and_restore_fpregs_di): Likewise.\n+\t(return_eh_si): Likewise.\n+\t(return_eh_di): Likewise.\n+\t* config/rs6000/rs6000.c (mtcrf_operation): Don't look for,\n+\tor check, the USE.\n+\t(rs6000_emit_prologue): Don't emit the USE for movsi_to_cr.\n+\tDon't generate a PARALLEL around a single operation movsi_to_cr.\n+\tGenerate the RETURN first in any PARALLELs.\n+\n+\t* rtlanal.c (single_set_1): Use fatal_insn to display the\n+\tinvalid insn.  Check for more cases when a USE or CLOBBER occurs\n+\tbefore a SET.\n+\t* Makefile.in: Update dependencies for rtlanal.o.\n+\n 2000-09-30  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* i386.c: Move include of \"config.h\" to before that of <setjmp.h>."}, {"sha": "c1ecef078be1aa34449aea75f59289a6b531882c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e35b957951be95eb8c5caa2c3bd7635827b4b370/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e35b957951be95eb8c5caa2c3bd7635827b4b370/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e35b957951be95eb8c5caa2c3bd7635827b4b370", "patch": "@@ -1253,7 +1253,7 @@ rtl.o : rtl.c $(CONFIG_H) system.h $(RTL_H) bitmap.h $(GGC_H) toplev.h\n \n print-rtl.o : print-rtl.c $(CONFIG_H) system.h $(RTL_H) hard-reg-set.h \\\n     $(BASIC_BLOCK_H)\n-rtlanal.o : rtlanal.c $(CONFIG_H) system.h $(RTL_H)\n+rtlanal.o : rtlanal.c $(CONFIG_H) system.h toplev.h $(RTL_H)\n errors.o : errors.c $(CONFIG_H) system.h errors.h\n \n varasm.o : varasm.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) flags.h \\"}, {"sha": "e0bacdd775787bc861a47c63ebdf3afa557cafae", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e35b957951be95eb8c5caa2c3bd7635827b4b370/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e35b957951be95eb8c5caa2c3bd7635827b4b370/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e35b957951be95eb8c5caa2c3bd7635827b4b370", "patch": "@@ -3006,25 +3006,22 @@ mtcrf_operation (op, mode)\n {\n   int count = XVECLEN (op, 0);\n   int i;\n-  int bitmap = 0;\n   rtx src_reg;\n \n   /* Perform a quick check so we don't blow up below.  */\n-  if (count < 2\n-      || GET_CODE (XVECEXP (op, 0, 0)) != USE\n-      || GET_CODE (XEXP (XVECEXP (op, 0, 0), 0)) != CONST_INT\n-      || GET_CODE (XVECEXP (op, 0, 1)) != SET\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, 1))) != UNSPEC\n-      || XVECLEN (SET_SRC (XVECEXP (op, 0, 1)), 0) != 2)\n+  if (count < 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC\n+      || XVECLEN (SET_SRC (XVECEXP (op, 0, 0)), 0) != 2)\n     return 0;\n-  src_reg = XVECEXP (SET_SRC (XVECEXP (op, 0, 1)), 0, 0);\n+  src_reg = XVECEXP (SET_SRC (XVECEXP (op, 0, 0)), 0, 0);\n   \n   if (GET_CODE (src_reg) != REG\n       || GET_MODE (src_reg) != SImode\n       || ! INT_REGNO_P (REGNO (src_reg)))\n     return 0;\n \n-  for (i = 1; i < count; i++)\n+  for (i = 0; i < count; i++)\n     {\n       rtx exp = XVECEXP (op, 0, i);\n       rtx unspec;\n@@ -3037,7 +3034,6 @@ mtcrf_operation (op, mode)\n \treturn 0;\n       unspec = SET_SRC (exp);\n       maskval = 1 << (MAX_CR_REGNO - REGNO (SET_DEST (exp)));\n-      bitmap |= maskval;\n       \n       if (GET_CODE (unspec) != UNSPEC\n \t  || XINT (unspec, 1) != 20\n@@ -3047,7 +3043,7 @@ mtcrf_operation (op, mode)\n \t  || INTVAL (XVECEXP (unspec, 0, 1)) != maskval)\n \treturn 0;\n     }\n-  return INTVAL (XEXP (XVECEXP (op, 0, 0), 0)) == bitmap;\n+  return 1;\n }\n \n /* Return 1 for an PARALLEL suitable for lmw. */\n@@ -5974,38 +5970,39 @@ rs6000_emit_epilogue(sibcall)\n   if (info->cr_save_p)\n     {\n       rtx r12_rtx = gen_rtx_REG (SImode, 12);\n+      int count = 0;\n       \n       if (using_mfcr_multiple)\n \t{\n-\t  rtvec p;\n-\t  int mask = 0;\n-\t  int count = 0;\n-\n \t  for (i = 0; i < 8; i++)\n \t    if (regs_ever_live[CR0_REGNO+i] && ! call_used_regs[CR0_REGNO+i])\n-\t      {\n-\t\tmask |= 1 << (7-i);\n-\t\tcount++;\n-\t      }\n+\t      count++;\n \t  if (count == 0)\n-\t    abort();\n+\t    abort ();\n+\t}\n+\n+      if (using_mfcr_multiple && count > 1)\n+\t{\n+\t  rtvec p;\n+\t  int ndx;\n \t  \n-\t  p = rtvec_alloc (count + 1);\n+\t  p = rtvec_alloc (count);\n \n-\t  RTVEC_ELT (p, 0) = gen_rtx_USE (VOIDmode, GEN_INT (mask));\n-\t  count = 1;\n+\t  ndx = 0;\n \t  for (i = 0; i < 8; i++)\n \t    if (regs_ever_live[CR0_REGNO+i] && ! call_used_regs[CR0_REGNO+i])\n \t      {\n \t\trtvec r = rtvec_alloc (2);\n \t\tRTVEC_ELT (r, 0) = r12_rtx;\n \t\tRTVEC_ELT (r, 1) = GEN_INT (1 << (7-i));\n-\t\tRTVEC_ELT (p, count) =\n+\t\tRTVEC_ELT (p, ndx) =\n \t\t  gen_rtx_SET (VOIDmode, gen_rtx_REG (CCmode, CR0_REGNO+i), \n \t\t\t       gen_rtx_UNSPEC (CCmode, r, 20));\n-\t\tcount++;\n+\t\tndx++;\n \t      }\n \t  emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+\t  if (ndx != count)\n+\t    abort ();\n \t}\n       else\n \tfor (i = 0; i < 8; i++)\n@@ -6050,10 +6047,10 @@ rs6000_emit_epilogue(sibcall)\n       else\n \tp = rtvec_alloc (2);\n \n-      RTVEC_ELT (p, 0) = gen_rtx_USE (VOIDmode, \n+      RTVEC_ELT (p, 0) = gen_rtx_RETURN (VOIDmode);\n+      RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode, \n \t\t\t\t      gen_rtx_REG (Pmode, \n \t\t\t\t\t\t   LINK_REGISTER_REGNUM));\n-      RTVEC_ELT (p, 1) = gen_rtx_RETURN (VOIDmode);\n \n       /* If we have to restore more than two FP registers, branch to the\n \t restore function.  It will return to our caller.  */"}, {"sha": "43e74683bcf8429d69a2970af35463c3fc857a61", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e35b957951be95eb8c5caa2c3bd7635827b4b370/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e35b957951be95eb8c5caa2c3bd7635827b4b370/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=e35b957951be95eb8c5caa2c3bd7635827b4b370", "patch": "@@ -13295,13 +13295,20 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \n (define_insn \"*movsi_to_cr\"\n  [(match_parallel 0 \"mtcrf_operation\"\n-                  [(use (match_operand 1 \"immediate_operand\" \"n\"))\n-\t\t   (set (match_operand:CC 2 \"cc_reg_operand\" \"=y\")\n-       \t\t\t(unspec:CC [(match_operand:SI 3 \"gpc_reg_operand\" \"r\")\n-\t\t   \t\t    (match_operand 4 \"immediate_operand\" \"n\")]\n+                  [(set (match_operand:CC 1 \"cc_reg_operand\" \"=y\")\n+       \t\t\t(unspec:CC [(match_operand:SI 2 \"gpc_reg_operand\" \"r\")\n+\t\t   \t\t    (match_operand 3 \"immediate_operand\" \"n\")]\n \t\t\t 20))])]\n  \"\"\n- \"mtcrf %1,%3\")\n+ \"*\n+{\n+  int mask = 0;\n+  int i;\n+  for (i = 0; i < XVECLEN (operands[0], 0); i++)\n+    mask |= INTVAL (XVECEXP (SET_SRC (XVECEXP (operands[0], 0, i)), 0, 1));\n+  operands[4] = GEN_INT (mask);\n+  return \\\"mtcrf %4,%2\\\";\n+}\")\n \n (define_insn \"\"\n  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n@@ -13325,15 +13332,15 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n  \"{lm|lmw} %1,%2\")\n  \n (define_insn \"*return_internal_si\"\n-  [(use (match_operand:SI 0 \"register_operand\" \"lc\"))\n-   (return)]\n+  [(return)\n+   (use (match_operand:SI 0 \"register_operand\" \"lc\"))]\n   \"TARGET_32BIT\"\n   \"b%T0\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n (define_insn \"*return_internal_di\"\n-  [(use (match_operand:DI 0 \"register_operand\" \"lc\"))\n-   (return)]\n+  [(return)\n+   (use (match_operand:DI 0 \"register_operand\" \"lc\"))]\n   \"TARGET_64BIT\"\n   \"b%T0\"\n   [(set_attr \"type\" \"jmpreg\")])\n@@ -13343,8 +13350,8 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \n (define_insn \"*return_and_restore_fpregs_si\"\n  [(match_parallel 0 \"any_operand\"\n-                  [(use (match_operand:SI 1 \"register_operand\" \"l\"))\n-\t\t   (return)\n+                  [(return)\n+\t\t   (use (match_operand:SI 1 \"register_operand\" \"l\"))\n \t\t   (use (match_operand:SI 2 \"call_operand\" \"s\"))\n \t\t   (set (match_operand:DF 3 \"gpc_reg_operand\" \"=f\")\n \t\t\t(match_operand:DF 4 \"memory_operand\" \"m\"))])]\n@@ -13353,8 +13360,8 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \n (define_insn \"*return_and_restore_fpregs_di\"\n  [(match_parallel 0 \"any_operand\"\n-                  [(use (match_operand:DI 1 \"register_operand\" \"l\"))\n-\t\t   (return)\n+                  [(return)\n+\t\t   (use (match_operand:DI 1 \"register_operand\" \"l\"))\n \t\t   (use (match_operand:DI 2 \"call_operand\" \"s\"))\n \t\t   (set (match_operand:DF 3 \"gpc_reg_operand\" \"=f\")\n \t\t\t(match_operand:DF 4 \"memory_operand\" \"m\"))])]\n@@ -13460,17 +13467,17 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \n \n (define_insn \"return_eh_si\"\n-  [(use (match_operand:SI 0 \"register_operand\" \"lc\"))\n-   (return)\n+  [(return)\n+   (use (match_operand:SI 0 \"register_operand\" \"lc\"))\n    (use (reg:SI 2))\n    (use (reg:SI 3))]\n   \"TARGET_32BIT\"\n   \"b%T0\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n (define_insn \"return_eh_di\"\n-  [(use (match_operand:DI 0 \"register_operand\" \"lc\"))\n-   (return)\n+  [(return)\n+   (use (match_operand:DI 0 \"register_operand\" \"lc\"))\n    (use (reg:DI 2))\n    (use (reg:DI 3))]\n   \"TARGET_64BIT\""}, {"sha": "2e1ae1450e955bd153939365055ce214f72cb380", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e35b957951be95eb8c5caa2c3bd7635827b4b370/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e35b957951be95eb8c5caa2c3bd7635827b4b370/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=e35b957951be95eb8c5caa2c3bd7635827b4b370", "patch": "@@ -22,6 +22,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"toplev.h\"\n #include \"rtl.h\"\n \n static int rtx_addr_can_trap_p\tPARAMS ((rtx));\n@@ -878,7 +879,7 @@ single_set_1 (insn)\n \t    /* Instruction should not consist only from USEs and CLOBBERS,\n \t       since then gcc is allowed to remove it entirely.  In case\n \t       something else is present, it should be first in the pattern.  */\n-\t    abort();\n+\t    fatal_insn (\"USE or CLOBBER before SET:\", insn);\n #endif\n \t  case SET:\n \t    break;\n@@ -895,34 +896,41 @@ single_set_1 (insn)\n \t  for (i = XVECLEN (pat, 0) - 1; i > 1; i--)\n \t    if (GET_CODE (XVECEXP (pat, 0, i)) != USE\n \t\t&& GET_CODE (XVECEXP (pat, 0, i)) != CLOBBER)\n-\t      abort();\n+\t      fatal_insn (\"USE or CLOBBER before SET:\", insn);\n #endif\n \t    return set;\n \tcase SET:\n-\t  /* Multiple set insns - we are off the critical path now.  */\n-\t  for (i = XVECLEN (pat, 0) - 1; i > 0; i--)\n-\t    {\n-\t      sub = XVECEXP (pat, 0, i);\n-\t      switch GET_CODE (sub)\n-\t\t{\n-\t\tcase USE:\n-\t\tcase CLOBBER:\n-\t\t  break;\n-\n-\t\tcase SET:\n-\t\t  if (!set\n-\t\t      || (find_reg_note (insn, REG_UNUSED, SET_DEST (set))\n-\t\t\t  && side_effects_p (set)))\n-\t\t    set = sub;\n-\t\t  else if (! find_reg_note (insn, REG_UNUSED, SET_DEST (sub))\n-\t\t\t   || side_effects_p (sub))\n-\t\t    return NULL_RTX;\n-\t\t  break;\n+\t  {\n+\t    int seen_clobber = 0;\n \n-\t\tdefault:\n-\t\t  return NULL_RTX;\n-\t\t}\n-\t    }\n+\t    /* Multiple set insns - we are off the critical path now.  */\n+\t    for (i = 1; i < XVECLEN (pat, 0); i++)\n+\t      {\n+\t\tsub = XVECEXP (pat, 0, i);\n+\t\tswitch GET_CODE (sub)\n+\t\t  {\n+\t\t  case USE:\n+\t\t  case CLOBBER:\n+\t\t    seen_clobber = 1;\n+\t\t    break;\n+\t\t    \n+\t\t  case SET:\n+\t\t    if (seen_clobber)\n+\t\t      fatal_insn (\"USE or CLOBBER before SET:\", insn);\n+\t\t    if (!set\n+\t\t\t|| (find_reg_note (insn, REG_UNUSED, SET_DEST (set))\n+\t\t\t    && side_effects_p (set)))\n+\t\t      set = sub;\n+\t\t    else if (! find_reg_note (insn, REG_UNUSED, SET_DEST (sub))\n+\t\t\t     || side_effects_p (sub))\n+\t\t      return NULL_RTX;\n+\t\t    break;\n+\t\t    \n+\t\t  default:\n+\t\t    return NULL_RTX;\n+\t\t  }\n+\t      }\n+\t  }\n \t  return set;\n \tdefault:\n \t  return NULL_RTX;"}]}