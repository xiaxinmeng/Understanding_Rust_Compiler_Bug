{"sha": "14f0f659acfb490fc37e1a9de8f19c4759845337", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRmMGY2NTlhY2ZiNDkwZmMzN2UxYTlkZThmMTljNDc1OTg0NTMzNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T14:29:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T14:29:25Z"}, "message": "[multiple changes]\n\n2011-08-29  Johannes Kanig  <kanig@adacore.com>\n\n\t* debug.adb: Add comments.\n\n2011-08-29  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* impunit.adb, s-stposu.adb, s-stposu.ads, exp_ch4.adb,\n\ts-finmas.adb, s-finmas.ads: Redo previous change.\n\nFrom-SVN: r178247", "tree": {"sha": "f3cbda05d7c40e4bba9dea79735033beefd4785f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3cbda05d7c40e4bba9dea79735033beefd4785f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14f0f659acfb490fc37e1a9de8f19c4759845337", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14f0f659acfb490fc37e1a9de8f19c4759845337", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14f0f659acfb490fc37e1a9de8f19c4759845337", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14f0f659acfb490fc37e1a9de8f19c4759845337/comments", "author": null, "committer": null, "parents": [{"sha": "8027b4559bbfa23f098c171d3200973dd11a9da9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8027b4559bbfa23f098c171d3200973dd11a9da9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8027b4559bbfa23f098c171d3200973dd11a9da9"}], "stats": {"total": 593, "additions": 492, "deletions": 101}, "files": [{"sha": "00c9e10909dfc55a7dc0cbbc0f4bedcbb5aa740a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=14f0f659acfb490fc37e1a9de8f19c4759845337", "patch": "@@ -1,3 +1,7 @@\n+2011-08-29  Johannes Kanig  <kanig@adacore.com>\n+\n+\t* debug.adb: Add comments.\n+\n 2011-08-29  Thomas Quinot  <quinot@adacore.com>\n \n \t* a-except.adb, a-except-2005.adb: Minor comment rewording and\n@@ -118,11 +122,6 @@\n \t* exp_ch5.adb (Expand_Iterator_Loop): Handle properly a loop over a\n \tcontainer of a derived type.\n \n-2011-08-29  Hristian Kirtchev  <kirtchev@adacore.com>\n-\n-\t* impunit.adb, s-stposu.adb, s-stposu.ads, exp_ch4.adb, s-finmas.adb,\n-\ts-finmas.ads: Revert previous change.\n-\n 2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n \n \t* a-cidlli.adb, a-cidlli.ads, a-cihama.adb, a-cihama.ads,"}, {"sha": "6f9a7d68d49fa31378a9270f4348c0d1cc640bda", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=14f0f659acfb490fc37e1a9de8f19c4759845337", "patch": "@@ -128,7 +128,7 @@ package body Debug is\n    --  d.H  Standard package only mode for gnat2why\n    --  d.I  SCIL generation mode\n    --  d.J  Disable parallel SCIL generation mode\n-   --  d.K\n+   --  d.K  Alfa detection only mode for gnat2why\n    --  d.L  Depend on back end for limited types in conditional expressions\n    --  d.M\n    --  d.N\n@@ -600,6 +600,9 @@ package body Debug is\n    --       done in parallel to speed processing. This switch disables this\n    --       behavior.\n \n+   --  d.K  Alfa detection only mode for gnat2why. In this mode, gnat2why\n+   --       will only generate the .alfa file, but no Why code.\n+\n    --  d.L  Normally the front end generates special expansion for conditional\n    --       expressions of a limited type. This debug flag removes this special\n    --       case expansion, leaving it up to the back end to handle conditional"}, {"sha": "4824df02583b86cb3660407684be6b0b2a5c5375", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=14f0f659acfb490fc37e1a9de8f19c4759845337", "patch": "@@ -1137,6 +1137,8 @@ package body Exp_Ch4 is\n             Rewrite (Exp, New_Copy (Expression (Exp)));\n          end if;\n       else\n+         Build_Allocate_Deallocate_Proc (N, True);\n+\n          --  If we have:\n          --    type A is access T1;\n          --    X : A := new T2'(...);"}, {"sha": "9aa86d523f6914297e8c9ea05e1f6504a9a8d650", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=14f0f659acfb490fc37e1a9de8f19c4759845337", "patch": "@@ -346,7 +346,6 @@ package body Impunit is\n \n      \"s-addima\",    -- System.Address_Image\n      \"s-assert\",    -- System.Assertions\n-     \"s-finmas\",    -- System.Finalization_Masters\n      \"s-memory\",    -- System.Memory\n      \"s-parint\",    -- System.Partition_Interface\n      \"s-pooglo\",    -- System.Pool_Global\n@@ -529,7 +528,6 @@ package body Impunit is\n    -- GNAT Defined Additions to Ada 20012 --\n    -----------------------------------------\n \n-     \"s-spsufi\",    -- System.Storage_Pools.Subpools.Finalization\n      \"a-cofove\",    -- Ada.Containers.Formal_Vectors\n      \"a-cfdlli\",    -- Ada.Containers.Formal_Doubly_Linked_Lists\n      \"a-cforse\",    -- Ada.Containers.Formal_Ordered_Sets"}, {"sha": "72b87dfe462728394678ce499bba3904c20c6fd9", "filename": "gcc/ada/s-finmas.adb", "status": "modified", "additions": 171, "deletions": 28, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fs-finmas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fs-finmas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.adb?ref=14f0f659acfb490fc37e1a9de8f19c4759845337", "patch": "@@ -31,12 +31,32 @@\n \n with Ada.Exceptions;          use Ada.Exceptions;\n with System.Address_Image;\n+with System.HTable;           use System.HTable;\n with System.IO;               use System.IO;\n with System.Soft_Links;       use System.Soft_Links;\n with System.Storage_Elements; use System.Storage_Elements;\n \n package body System.Finalization_Masters is\n \n+   --  Finalize_Address hash table types. In general, masters are homogeneous\n+   --  collections of controlled objects. Rare cases such as allocations on a\n+   --  subpool require heterogeneous masters. The following table provides a\n+   --  relation between object address and its Finalize_Address routine.\n+\n+   type Header_Num is range 0 .. 127;\n+\n+   function Hash (Key : System.Address) return Header_Num;\n+\n+   --  Address --> Finalize_Address_Ptr\n+\n+   package Finalize_Address_Table is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Finalize_Address_Ptr,\n+      No_Element => null,\n+      Key        => System.Address,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+\n    ---------------------------\n    -- Add_Offset_To_Address --\n    ---------------------------\n@@ -79,6 +99,17 @@ package body System.Finalization_Masters is\n       return Master.Base_Pool;\n    end Base_Pool;\n \n+   -----------------------------\n+   -- Delete_Finalize_Address --\n+   -----------------------------\n+\n+   procedure Delete_Finalize_Address (Obj : System.Address) is\n+   begin\n+      Lock_Task.all;\n+      Finalize_Address_Table.Remove (Obj);\n+      Unlock_Task.all;\n+   end Delete_Finalize_Address;\n+\n    ------------\n    -- Detach --\n    ------------\n@@ -94,17 +125,18 @@ package body System.Finalization_Masters is\n          N.Next := null;\n \n          Unlock_Task.all;\n-      end if;\n \n-      --  Note: No need to unlock in case of an exception because the above\n-      --  code can never raise one.\n+         --  Note: No need to unlock in case of an exception because the above\n+         --  code can never raise one.\n+      end if;\n    end Detach;\n \n    --------------\n    -- Finalize --\n    --------------\n \n    overriding procedure Finalize (Master : in out Finalization_Master) is\n+      Cleanup  : Finalize_Address_Ptr;\n       Curr_Ptr : FM_Node_Ptr;\n       Ex_Occur : Exception_Occurrence;\n       Obj_Addr : Address;\n@@ -144,23 +176,41 @@ package body System.Finalization_Masters is\n \n          Detach (Curr_Ptr);\n \n-         if Master.Finalize_Address /= null then\n+         --  Skip the list header in order to offer proper object layout for\n+         --  finalization.\n \n-            --  Skip the list header in order to offer proper object layout for\n-            --  finalization and call Finalize_Address.\n+         Obj_Addr := Curr_Ptr.all'Address + Header_Offset;\n+\n+         --  Retrieve TSS primitive Finalize_Address depending on the master's\n+         --  mode of operation.\n+\n+         if Master.Is_Homogeneous then\n+            Cleanup := Master.Finalize_Address;\n+         else\n+            Cleanup := Finalize_Address (Obj_Addr);\n+         end if;\n \n-            Obj_Addr := Curr_Ptr.all'Address + Header_Offset;\n+         --  If Finalize_Address is not available, then this is most likely an\n+         --  error in the expansion of the designated type or the allocator.\n \n-            begin\n-               Master.Finalize_Address (Obj_Addr);\n+         pragma Assert (Cleanup /= null);\n \n-            exception\n-               when Fin_Occur : others =>\n-                  if not Raised then\n-                     Raised := True;\n-                     Save_Occurrence (Ex_Occur, Fin_Occur);\n-                  end if;\n-            end;\n+         begin\n+            Cleanup (Obj_Addr);\n+\n+         exception\n+            when Fin_Occur : others =>\n+               if not Raised then\n+                  Raised := True;\n+                  Save_Occurrence (Ex_Occur, Fin_Occur);\n+               end if;\n+         end;\n+\n+         --  When the master is a heterogeneous collection, destroy the object\n+         --  - Finalize_Address pair since it is no longer needed.\n+\n+         if not Master.Is_Homogeneous then\n+            Delete_Finalize_Address (Obj_Addr);\n          end if;\n       end loop;\n \n@@ -172,6 +222,56 @@ package body System.Finalization_Masters is\n       end if;\n    end Finalize;\n \n+   ----------------------\n+   -- Finalize_Address --\n+   ----------------------\n+\n+   function Finalize_Address\n+     (Master : Finalization_Master) return Finalize_Address_Ptr\n+   is\n+   begin\n+      return Master.Finalize_Address;\n+   end Finalize_Address;\n+\n+   ----------------------\n+   -- Finalize_Address --\n+   ----------------------\n+\n+   function Finalize_Address\n+     (Obj : System.Address) return Finalize_Address_Ptr\n+   is\n+      Result : Finalize_Address_Ptr;\n+\n+   begin\n+      Lock_Task.all;\n+      Result := Finalize_Address_Table.Get (Obj);\n+      Unlock_Task.all;\n+\n+      return Result;\n+   end Finalize_Address;\n+\n+   --------------------------\n+   -- Finalization_Started --\n+   --------------------------\n+\n+   function Finalization_Started\n+     (Master : Finalization_Master) return Boolean\n+   is\n+   begin\n+      return Master.Finalization_Started;\n+   end Finalization_Started;\n+\n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash (Key : System.Address) return Header_Num is\n+   begin\n+      return\n+        Header_Num\n+          (To_Integer (Key) mod Integer_Address (Header_Num'Range_Length));\n+   end Hash;\n+\n    -----------------\n    -- Header_Size --\n    -----------------\n@@ -202,11 +302,29 @@ package body System.Finalization_Masters is\n       Master.Objects.Prev := Master.Objects'Unchecked_Access;\n    end Initialize;\n \n-   --------\n-   -- pm --\n-   --------\n+   --------------------\n+   -- Is_Homogeneous --\n+   --------------------\n+\n+   function Is_Homogeneous (Master : Finalization_Master) return Boolean is\n+   begin\n+      return Master.Is_Homogeneous;\n+   end Is_Homogeneous;\n \n-   procedure pm (Master : Finalization_Master) is\n+   -------------\n+   -- Objects --\n+   -------------\n+\n+   function Objects (Master : Finalization_Master) return FM_Node_Ptr is\n+   begin\n+      return Master.Objects'Unrestricted_Access;\n+   end Objects;\n+\n+   ------------------\n+   -- Print_Master --\n+   ------------------\n+\n+   procedure Print_Master (Master : Finalization_Master) is\n       Head      : constant FM_Node_Ptr := Master.Objects'Unrestricted_Access;\n       Head_Seen : Boolean := False;\n       N_Ptr     : FM_Node_Ptr;\n@@ -215,23 +333,25 @@ package body System.Finalization_Masters is\n       --  Output the basic contents of a master\n \n       --    Master   : 0x123456789\n+      --    Is_Hmgen : TURE <or> FALSE\n       --    Base_Pool: null <or> 0x123456789\n       --    Fin_Addr : null <or> 0x123456789\n       --    Fin_Start: TRUE <or> FALSE\n \n       Put (\"Master   : \");\n       Put_Line (Address_Image (Master'Address));\n \n-      Put (\"Base_Pool: \");\n+      Put (\"Is_Hmgen : \");\n+      Put_Line (Master.Is_Homogeneous'Img);\n \n+      Put (\"Base_Pool: \");\n       if Master.Base_Pool = null then\n-         Put_Line (\" null\");\n+         Put_Line (\"null\");\n       else\n          Put_Line (Address_Image (Master.Base_Pool'Address));\n       end if;\n \n       Put (\"Fin_Addr : \");\n-\n       if Master.Finalize_Address = null then\n          Put_Line (\"null\");\n       else\n@@ -255,17 +375,17 @@ package body System.Finalization_Masters is\n \n       --  Header - the address of the list header\n       --  Prev   - the address of the list header which the current element\n-      --         - points back to\n+      --           points back to\n       --  Next   - the address of the list header which the current element\n-      --         - points to\n+      --           points to\n       --  (dummy head) - present if dummy head\n \n       N_Ptr := Head;\n-      while N_Ptr /= null loop -- Should never be null; we being defensive\n+      while N_Ptr /= null loop  --  Should never be null\n          Put_Line (\"V\");\n \n          --  We see the head initially; we want to exit when we see the head a\n-         --  SECOND time.\n+         --  second time.\n \n          if N_Ptr = Head then\n             exit when Head_Seen;\n@@ -321,7 +441,7 @@ package body System.Finalization_Masters is\n \n          N_Ptr := N_Ptr.Next;\n       end loop;\n-   end pm;\n+   end Print_Master;\n \n    -------------------\n    -- Set_Base_Pool --\n@@ -347,4 +467,27 @@ package body System.Finalization_Masters is\n       Master.Finalize_Address := Fin_Addr_Ptr;\n    end Set_Finalize_Address;\n \n+   --------------------------\n+   -- Set_Finalize_Address --\n+   --------------------------\n+\n+   procedure Set_Finalize_Address\n+     (Obj          : System.Address;\n+      Fin_Addr_Ptr : Finalize_Address_Ptr)\n+   is\n+   begin\n+      Lock_Task.all;\n+      Finalize_Address_Table.Set (Obj, Fin_Addr_Ptr);\n+      Unlock_Task.all;\n+   end Set_Finalize_Address;\n+\n+   --------------------------\n+   -- Set_Is_Heterogeneous --\n+   --------------------------\n+\n+   procedure Set_Is_Heterogeneous (Master : in out Finalization_Master) is\n+   begin\n+      Master.Is_Homogeneous := False;\n+   end Set_Is_Heterogeneous;\n+\n end System.Finalization_Masters;"}, {"sha": "0ffc78af2d0998314b48d00128245c5ee14a4807", "filename": "gcc/ada/s-finmas.ads", "status": "modified", "additions": 91, "deletions": 45, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fs-finmas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fs-finmas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.ads?ref=14f0f659acfb490fc37e1a9de8f19c4759845337", "patch": "@@ -30,15 +30,13 @@\n ------------------------------------------------------------------------------\n \n with Ada.Finalization;\n-with Ada.Unchecked_Conversion;\n-\n with System.Storage_Elements;\n with System.Storage_Pools;\n \n pragma Compiler_Unit;\n \n package System.Finalization_Masters is\n-   pragma Preelaborate (System.Finalization_Masters);\n+   pragma Preelaborate;\n \n    --  A reference to primitive Finalize_Address. The expander generates an\n    --  implementation of this procedure for each controlled and class-wide\n@@ -48,17 +46,11 @@ package System.Finalization_Masters is\n \n    type Finalize_Address_Ptr is access procedure (Obj : System.Address);\n \n-   --  Heterogeneous collection type structure. The implementation allows for\n-   --  finalizable objects of different base types to be serviced by the same\n-   --  master.\n+   --  Heterogeneous collection type structure\n \n-   type FM_Node;\n+   type FM_Node is private;\n    type FM_Node_Ptr is access all FM_Node;\n-\n-   type FM_Node is record\n-      Prev : FM_Node_Ptr := null;\n-      Next : FM_Node_Ptr := null;\n-   end record;\n+   pragma No_Strict_Aliasing (FM_Node_Ptr);\n \n    --  A reference to any derivation from Root_Storage_Pool. Since this type\n    --  may not be used to allocate objects, its storage size is zero.\n@@ -69,11 +61,95 @@ package System.Finalization_Masters is\n \n    --  Finalization master type structure. A unique master is associated with\n    --  each access-to-controlled or access-to-class-wide type. Masters also act\n-   --  as components of subpools.\n+   --  as components of subpools. By default, a master contains objects of the\n+   --  same designated type but it may also accomodate heterogeneous objects.\n+\n+   type Finalization_Master is\n+     new Ada.Finalization.Limited_Controlled with private;\n+\n+   --  A reference to a finalization master. Since this type may not be used\n+   --  to allocate objects, its storage size is zero.\n+\n+   type Finalization_Master_Ptr is access all Finalization_Master;\n+   for Finalization_Master_Ptr'Storage_Size use 0;\n+\n+   procedure Attach (N : not null FM_Node_Ptr; L : not null FM_Node_Ptr);\n+   --  Prepend a node to a specific finalization master\n+\n+   procedure Delete_Finalize_Address (Obj : System.Address);\n+   --  Destroy the relation pair object - Finalize_Address from the internal\n+   --  hash table.\n+\n+   procedure Detach (N : not null FM_Node_Ptr);\n+   --  Remove a node from an arbitrary finalization master\n+\n+   overriding procedure Finalize (Master : in out Finalization_Master);\n+   --  Lock the master to prevent allocations during finalization. Iterate over\n+   --  the list of allocated controlled objects, finalizing each one by calling\n+   --  its specific Finalize_Address. In the end, deallocate the dummy head.\n+\n+   function Finalize_Address\n+     (Master : Finalization_Master) return Finalize_Address_Ptr;\n+   --  Return a reference to the TSS primitive Finalize_Address associated with\n+   --  a master.\n+\n+   function Finalize_Address\n+     (Obj : System.Address) return Finalize_Address_Ptr;\n+   --  Retrieve the Finalize_Address primitive associated with a particular\n+   --  object.\n+\n+   function Finalization_Started (Master : Finalization_Master) return Boolean;\n+   --  Return the finalization status of a master\n+\n+   function Header_Offset return System.Storage_Elements.Storage_Offset;\n+   --  Return the size of type FM_Node as Storage_Offset\n+\n+   function Header_Size return System.Storage_Elements.Storage_Count;\n+   --  Return the size of type FM_Node as Storage_Count\n+\n+   function Is_Homogeneous (Master : Finalization_Master) return Boolean;\n+   --  Return the behavior flag of a master\n+\n+   function Objects (Master : Finalization_Master) return FM_Node_Ptr;\n+   --  Return the header of the doubly-linked list of controlled objects\n+\n+   procedure Print_Master (Master : Finalization_Master);\n+   --  Debug routine, outputs the contents of a master\n+\n+   procedure Set_Finalize_Address\n+     (Master       : in out Finalization_Master;\n+      Fin_Addr_Ptr : Finalize_Address_Ptr);\n+   --  Set the clean up routine of a finalization master. Note: this routine\n+   --  must precede the one below since RTSfind needs to match this one.\n+\n+   procedure Set_Finalize_Address\n+     (Obj          : System.Address;\n+      Fin_Addr_Ptr : Finalize_Address_Ptr);\n+   --  Add a relation pair object - Finalize_Address to the internal hash table\n+\n+   procedure Set_Is_Heterogeneous (Master : in out Finalization_Master);\n+   --  Mark the master as being a heterogeneous collection of objects\n+\n+private\n+   --  Heterogeneous collection type structure\n+\n+   type FM_Node is record\n+      Prev : FM_Node_Ptr := null;\n+      Next : FM_Node_Ptr := null;\n+   end record;\n+\n+   --  Finalization master type structure. A unique master is associated with\n+   --  each access-to-controlled or access-to-class-wide type. Masters also act\n+   --  as components of subpools. By default, a master contains objects of the\n+   --  same designated type but it may also accomodate heterogeneous objects.\n \n    type Finalization_Master is\n      new Ada.Finalization.Limited_Controlled with\n    record\n+      Is_Homogeneous : Boolean := True;\n+      --  A flag which controls the behavior of the master. A value of False\n+      --  denotes a heterogeneous collection.\n+\n       Base_Pool : Any_Storage_Pool_Ptr := null;\n       --  A reference to the pool which this finalization master services. This\n       --  field is used in conjunction with the build-in-place machinery.\n@@ -83,7 +159,8 @@ package System.Finalization_Masters is\n       --  objects allocated in a [sub]pool.\n \n       Finalize_Address : Finalize_Address_Ptr := null;\n-      --  A reference to the routine reponsible for object finalization\n+      --  A reference to the routine reponsible for object finalization. This\n+      --  is used only when the master is in homogeneous mode.\n \n       Finalization_Started : Boolean := False;\n       pragma Atomic (Finalization_Started);\n@@ -93,55 +170,24 @@ package System.Finalization_Masters is\n       --  is accessed without Lock_Task / Unlock_Task.\n    end record;\n \n-   type Finalization_Master_Ptr is access all Finalization_Master;\n-   for Finalization_Master_Ptr'Storage_Size use 0;\n-\n    --  Since RTSfind cannot contain names of the form RE_\"+\", the following\n    --  routine serves as a wrapper around System.Storage_Elements.\"+\".\n \n    function Add_Offset_To_Address\n      (Addr   : System.Address;\n       Offset : System.Storage_Elements.Storage_Offset) return System.Address;\n \n-   function Address_To_FM_Node_Ptr is\n-     new Ada.Unchecked_Conversion (Address, FM_Node_Ptr);\n-\n-   procedure Attach (N : not null FM_Node_Ptr; L : not null FM_Node_Ptr);\n-   --  Prepend a node to a specific finalization master\n-\n    function Base_Pool\n      (Master : Finalization_Master) return Any_Storage_Pool_Ptr;\n    --  Return a reference to the underlying storage pool on which the master\n    --  operates.\n \n-   procedure Detach (N : not null FM_Node_Ptr);\n-   --  Remove a node from an arbitrary finalization master\n-\n-   overriding procedure Finalize (Master : in out Finalization_Master);\n-   --  Lock the master to prevent allocations during finalization. Iterate over\n-   --  the list of allocated controlled objects, finalizing each one by calling\n-   --  its specific Finalize_Address. In the end, deallocate the dummy head.\n-\n-   function Header_Offset return System.Storage_Elements.Storage_Offset;\n-   --  Return the size of type FM_Node as Storage_Offset\n-\n-   function Header_Size return System.Storage_Elements.Storage_Count;\n-   --  Return the size of type FM_Node as Storage_Count\n-\n    overriding procedure Initialize (Master : in out Finalization_Master);\n    --  Initialize the dummy head of a finalization master\n \n-   procedure pm (Master : Finalization_Master);\n-   --  Debug routine, outputs the contents of a master\n-\n    procedure Set_Base_Pool\n      (Master   : in out Finalization_Master;\n       Pool_Ptr : Any_Storage_Pool_Ptr);\n    --  Set the underlying pool of a finalization master\n \n-   procedure Set_Finalize_Address\n-     (Master       : in out Finalization_Master;\n-      Fin_Addr_Ptr : Finalize_Address_Ptr);\n-   --  Set the clean up routine of a finalization master\n-\n end System.Finalization_Masters;"}, {"sha": "2b4e7fc40443baa6ab31f1aa32f2b36ddf2b2322", "filename": "gcc/ada/s-stposu.adb", "status": "modified", "additions": 212, "deletions": 17, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fs-stposu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fs-stposu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.adb?ref=14f0f659acfb490fc37e1a9de8f19c4759845337", "patch": "@@ -30,14 +30,24 @@\n ------------------------------------------------------------------------------\n \n with Ada.Exceptions;              use Ada.Exceptions;\n+with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n-\n+with System.Address_Image;\n with System.Finalization_Masters; use System.Finalization_Masters;\n+with System.IO;                   use System.IO;\n with System.Soft_Links;           use System.Soft_Links;\n with System.Storage_Elements;     use System.Storage_Elements;\n \n package body System.Storage_Pools.Subpools is\n \n+   Finalize_Address_Table_In_Use : Boolean := False;\n+   --  This flag should be set only when a successfull allocation on a subpool\n+   --  has been performed and the associated Finalize_Address has been added to\n+   --  the hash table in System.Finalization_Masters.\n+\n+   function Address_To_FM_Node_Ptr is\n+     new Ada.Unchecked_Conversion (Address, FM_Node_Ptr);\n+\n    procedure Attach (N : not null SP_Node_Ptr; L : not null SP_Node_Ptr);\n    --  Attach a subpool node to a pool\n \n@@ -169,7 +179,7 @@ package body System.Storage_Pools.Subpools is\n          Master := Context_Master;\n       end if;\n \n-      --  Step 2: Master and Finalize_Address-related runtime checks and size\n+      --  Step 2: Master, Finalize_Address-related runtime checks and size\n       --  calculations.\n \n       --  Allocation of a descendant from [Limited_]Controlled, a class-wide\n@@ -180,7 +190,7 @@ package body System.Storage_Pools.Subpools is\n          --  Do not allow the allocation of controlled objects while the\n          --  associated master is being finalized.\n \n-         if Master.Finalization_Started then\n+         if Finalization_Started (Master.all) then\n             raise Program_Error with \"allocation after finalization started\";\n          end if;\n \n@@ -248,21 +258,40 @@ package body System.Storage_Pools.Subpools is\n          --     +- Header_And_Padding --+\n \n          N_Ptr := Address_To_FM_Node_Ptr\n-                   (N_Addr + Header_And_Padding - Header_Offset);\n+                    (N_Addr + Header_And_Padding - Header_Offset);\n \n          --  Prepend the allocated object to the finalization master\n \n-         Attach (N_Ptr, Master.Objects'Unchecked_Access);\n-\n-         if Master.Finalize_Address = null then\n-            Master.Finalize_Address := Fin_Address;\n-         end if;\n+         Attach (N_Ptr, Objects (Master.all));\n \n          --  Move the address from the hidden list header to the start of the\n          --  object. This operation effectively hides the list header.\n \n          Addr := N_Addr + Header_And_Padding;\n \n+         --  Subpool allocations use heterogeneous masters to manage various\n+         --  controlled objects. Associate a Finalize_Address with the object.\n+         --  This relation pair is deleted when the object is deallocated or\n+         --  when the associated master is finalized.\n+\n+         if Is_Subpool_Allocation then\n+            pragma Assert (not Master.Is_Homogeneous);\n+\n+            Set_Finalize_Address (Addr, Fin_Address);\n+            Finalize_Address_Table_In_Use := True;\n+\n+         --  Normal allocations chain objects on homogeneous collections\n+\n+         else\n+            pragma Assert (Master.Is_Homogeneous);\n+\n+            if Finalize_Address (Master.all) = null then\n+               Set_Finalize_Address (Master.all, Fin_Address);\n+            end if;\n+         end if;\n+\n+      --  Non-controlled allocation\n+\n       else\n          Addr := N_Addr;\n       end if;\n@@ -315,6 +344,13 @@ package body System.Storage_Pools.Subpools is\n \n       if Is_Controlled then\n \n+         --  Destroy the relation pair object - Finalize_Address since it is no\n+         --  longer needed.\n+\n+         if Finalize_Address_Table_In_Use then\n+            Delete_Finalize_Address (Addr);\n+         end if;\n+\n          --  Account for possible padding space before the header due to a\n          --  larger alignment.\n \n@@ -382,6 +418,8 @@ package body System.Storage_Pools.Subpools is\n \n       N.Prev.Next := N.Next;\n       N.Next.Prev := N.Prev;\n+      N.Prev := null;\n+      N.Next := null;\n \n       Unlock_Task.all;\n \n@@ -405,9 +443,22 @@ package body System.Storage_Pools.Subpools is\n    procedure Finalize_Pool (Pool : in out Root_Storage_Pool_With_Subpools) is\n       Curr_Ptr : SP_Node_Ptr;\n       Ex_Occur : Exception_Occurrence;\n-      Next_Ptr : SP_Node_Ptr;\n       Raised   : Boolean := False;\n \n+      function Is_Empty_List (L : not null SP_Node_Ptr) return Boolean;\n+      --  Determine whether a list contains only one element, the dummy head\n+\n+      -------------------\n+      -- Is_Empty_List --\n+      -------------------\n+\n+      function Is_Empty_List (L : not null SP_Node_Ptr) return Boolean is\n+      begin\n+         return L.Next = L and then L.Prev = L;\n+      end Is_Empty_List;\n+\n+   --  Start of processing for Finalize_Pool\n+\n    begin\n       --  It is possible for multiple tasks to cause the finalization of a\n       --  common pool. Allow only one task to finalize the contents.\n@@ -423,11 +474,8 @@ package body System.Storage_Pools.Subpools is\n \n       Pool.Finalization_Started := True;\n \n-      --  Skip the dummy head\n-\n-      Curr_Ptr := Pool.Subpools.Next;\n-      while Curr_Ptr /= Pool.Subpools'Unchecked_Access loop\n-         Next_Ptr := Curr_Ptr.Next;\n+      while not Is_Empty_List (Pool.Subpools'Unchecked_Access) loop\n+         Curr_Ptr := Pool.Subpools.Next;\n \n          --  Perform the following actions:\n \n@@ -446,8 +494,6 @@ package body System.Storage_Pools.Subpools is\n                   Save_Occurrence (Ex_Occur, Fin_Occur);\n                end if;\n          end;\n-\n-         Curr_Ptr := Next_Ptr;\n       end loop;\n \n       --  If the finalization of a particular master failed, reraise the\n@@ -537,6 +583,150 @@ package body System.Storage_Pools.Subpools is\n       return Subpool.Owner;\n    end Pool_Of_Subpool;\n \n+   ----------------\n+   -- Print_Pool --\n+   ----------------\n+\n+   procedure Print_Pool (Pool : Root_Storage_Pool_With_Subpools) is\n+      Head      : constant SP_Node_Ptr := Pool.Subpools'Unrestricted_Access;\n+      Head_Seen : Boolean := False;\n+      SP_Ptr    : SP_Node_Ptr;\n+\n+   begin\n+      --  Output the contents of the pool\n+\n+      --    Pool      : 0x123456789\n+      --    Subpools  : 0x123456789\n+      --    Fin_Start : TRUE <or> FALSE\n+      --    Controller: OK <or> NOK\n+\n+      Put (\"Pool      : \");\n+      Put_Line (Address_Image (Pool'Address));\n+\n+      Put (\"Subpools  : \");\n+      Put_Line (Address_Image (Pool.Subpools'Address));\n+\n+      Put (\"Fin_Start : \");\n+      Put_Line (Pool.Finalization_Started'Img);\n+\n+      Put (\"Controlled: \");\n+      if Pool.Controller.Enclosing_Pool = Pool'Unrestricted_Access then\n+         Put_Line (\"OK\");\n+      else\n+         Put_Line (\"NOK (ERROR)\");\n+      end if;\n+\n+      SP_Ptr := Head;\n+      while SP_Ptr /= null loop  --  Should never be null\n+         Put_Line (\"V\");\n+\n+         --  We see the head initially; we want to exit when we see the head a\n+         --  second time.\n+\n+         if SP_Ptr = Head then\n+            exit when Head_Seen;\n+\n+            Head_Seen := True;\n+         end if;\n+\n+         --  The current element is null. This should never happend since the\n+         --  list is circular.\n+\n+         if SP_Ptr.Prev = null then\n+            Put_Line (\"null (ERROR)\");\n+\n+         --  The current element points back to the correct element\n+\n+         elsif SP_Ptr.Prev.Next = SP_Ptr then\n+            Put_Line (\"^\");\n+\n+         --  The current element points to an erroneous element\n+\n+         else\n+            Put_Line (\"? (ERROR)\");\n+         end if;\n+\n+         --  Output the contents of the node\n+\n+         Put (\"|Header: \");\n+         Put (Address_Image (SP_Ptr.all'Address));\n+         if SP_Ptr = Head then\n+            Put_Line (\" (dummy head)\");\n+         else\n+            Put_Line (\"\");\n+         end if;\n+\n+         Put (\"|  Prev: \");\n+\n+         if SP_Ptr.Prev = null then\n+            Put_Line (\"null\");\n+         else\n+            Put_Line (Address_Image (SP_Ptr.Prev.all'Address));\n+         end if;\n+\n+         Put (\"|  Next: \");\n+\n+         if SP_Ptr.Next = null then\n+            Put_Line (\"null\");\n+         else\n+            Put_Line (Address_Image (SP_Ptr.Next.all'Address));\n+         end if;\n+\n+         Put (\"|  Subp: \");\n+\n+         if SP_Ptr.Subpool = null then\n+            Put_Line (\"null\");\n+         else\n+            Put_Line (Address_Image (SP_Ptr.Subpool.all'Address));\n+         end if;\n+\n+         SP_Ptr := SP_Ptr.Next;\n+      end loop;\n+   end Print_Pool;\n+\n+   -------------------\n+   -- Print_Subpool --\n+   -------------------\n+\n+   procedure Print_Subpool (Subpool : Subpool_Handle) is\n+   begin\n+      if Subpool = null then\n+         Put_Line (\"null\");\n+         return;\n+      end if;\n+\n+      --  Output the contents of a subpool\n+\n+      --    Owner : 0x123456789\n+      --    Master: 0x123456789\n+      --    Node  : 0x123456789\n+\n+      Put (\"Owner : \");\n+      if Subpool.Owner = null then\n+         Put_Line (\"null\");\n+      else\n+         Put_Line (Address_Image (Subpool.Owner'Address));\n+      end if;\n+\n+      Put (\"Master: \");\n+      Put_Line (Address_Image (Subpool.Master'Address));\n+\n+      Put (\"Node  : \");\n+      if Subpool.Node = null then\n+         Put (\"null\");\n+\n+         if Subpool.Owner = null then\n+            Put_Line (\" OK\");\n+         else\n+            Put_Line (\" (ERROR)\");\n+         end if;\n+      else\n+         Put_Line (Address_Image (Subpool.Node'Address));\n+      end if;\n+\n+      Print_Master (Subpool.Master);\n+   end Print_Subpool;\n+\n    -------------------------\n    -- Set_Pool_Of_Subpool --\n    -------------------------\n@@ -574,6 +764,11 @@ package body System.Storage_Pools.Subpools is\n       Subpool.Node := N_Ptr;\n \n       Attach (N_Ptr, Pool.Subpools'Unchecked_Access);\n+\n+      --  Mark the subpool's master as being a heterogeneous collection of\n+      --  controlled objects.\n+\n+      Set_Is_Heterogeneous (Subpool.Master);\n    end Set_Pool_Of_Subpool;\n \n end System.Storage_Pools.Subpools;"}, {"sha": "0c5bd218515b7a77cc1f4516a516512cd5fac5cc", "filename": "gcc/ada/s-stposu.ads", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fs-stposu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14f0f659acfb490fc37e1a9de8f19c4759845337/gcc%2Fada%2Fs-stposu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.ads?ref=14f0f659acfb490fc37e1a9de8f19c4759845337", "patch": "@@ -34,12 +34,11 @@\n ------------------------------------------------------------------------------\n \n with Ada.Finalization;\n-\n with System.Finalization_Masters;\n with System.Storage_Elements;\n \n package System.Storage_Pools.Subpools is\n-   pragma Preelaborate (System.Storage_Pools.Subpools);\n+   pragma Preelaborate;\n \n    type Root_Storage_Pool_With_Subpools is abstract\n      new Root_Storage_Pool with private;\n@@ -242,7 +241,7 @@ private\n       --  A reference to the master pool_with_subpools\n \n       Master : aliased System.Finalization_Masters.Finalization_Master;\n-      --  A collection of controlled objects\n+      --  A heterogeneous collection of controlled objects\n \n       Node : SP_Node_Ptr := null;\n       --  A link to the doubly linked list node which contains the subpool.\n@@ -336,4 +335,10 @@ private\n    procedure Initialize_Pool (Pool : in out Root_Storage_Pool_With_Subpools);\n    --  Setup the doubly linked list of subpools\n \n+   procedure Print_Pool (Pool : Root_Storage_Pool_With_Subpools);\n+   --  Debug routine, output the contents of a pool_with_subpools\n+\n+   procedure Print_Subpool (Subpool : Subpool_Handle);\n+   --  Debug routine, output the contents of a subpool\n+\n end System.Storage_Pools.Subpools;"}]}