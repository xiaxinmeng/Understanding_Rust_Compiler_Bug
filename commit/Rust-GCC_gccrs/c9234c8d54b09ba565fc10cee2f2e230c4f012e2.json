{"sha": "c9234c8d54b09ba565fc10cee2f2e230c4f012e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkyMzRjOGQ1NGIwOWJhNTY1ZmMxMGNlZTJmMmUyMzBjNGYwMTJlMg==", "commit": {"author": {"name": "Doug Kwan", "email": "dougkwan@google.com", "date": "2008-08-02T01:25:48Z"}, "committer": {"name": "Doug Kwan", "email": "dougkwan@gcc.gnu.org", "date": "2008-08-02T01:25:48Z"}, "message": "matrix-reorg.c: Re-enable all code.\n\n2008-08-01  Doug Kwan  <dougkwan@google.com>\n\n\t* matrix-reorg.c: Re-enable all code.\n\t(struct malloc_call_data): Change CALL_STMT to gimple type.\n\t(collect_data_for_malloc_call): Tuplify.\n \t(struct access_site_info): Change STMT to gimple type.\n\t(struct matrix_info): Change MIN_INDIRECT_LEVEL_ESCAPE_STMT,\n\tand MALLOC_FOR_LEVEL to gimple and gimple pointer type.\n\t(struct free_info): Change STMT to gimple type.\n \t(struct matrix_access_phi_node):  Change PHI to gimple type.\n\t(get_inner_of_cast_expr): Remove.\n\t(may_flatten_matrices_1): Tuplify.\n\t(may_flatten_matrices): Ditto.\n\t(mark_min_matrix_escape_level): Ditto.\n \t(ssa_accessed_in_tree): Refactor statement RHS related code into ...\n\t(ssa_accessed_in_call_rhs): New\n\t(ssa_accessed_in_assign_rhs): New\n\t(record_access_alloc_site_info): Tuplify.\n\t(add_allocation_site): Ditto.\n\t(analyze_matrix_allocation_site): Ditto.\n\t(analyze_transpose): Ditto.\n\t(get_index_from_offset): Ditto.\n\t(update_type_size): Ditto.\n\t(analyze_accesses_for_call_expr): Tuplify and renamed into ...\n\t(analyze_accesses_for_call_stmt): New. Also handle LHS of a call.\n\t(analyze_accesses_for_phi_node): Tuplify.\n\t(analyze_accesses_for_modify_stmt): Tuplify and renamed into ...\n\t(analyze_accesses_for_assign_stmt): Remove code for handling call LHS.\n\t(analyze_matrix_accesses): Tuplify.\n\t(check_var_data): New call-back type for check_var_notmodified_p.\n\t(check_var_notmodified_p): Tuplify and use call-back struct to\n\treturn statement found.\n\t(can_calculate_expr_before_stmt): Factor out statement related code\n\tinto ...\n\t(can_calculate_stmt_before_stmt): New.\n \t(check_allocation_function): Tuplify.\n\t(find_sites_in_func): Ditto.\n\t(record_all_accesses_in_func): Ditto.\n\t(transform_access_sites): Ditto.\n\t(transform_allocation_sites): Ditto.\n\t(matrix_reorg): Re-enable.\n\t(gate_matrix_reorg): Re-enable.\n\nFrom-SVN: r138544", "tree": {"sha": "31d6f216355e99f1861fc40a5023ac620072cefa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31d6f216355e99f1861fc40a5023ac620072cefa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9234c8d54b09ba565fc10cee2f2e230c4f012e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9234c8d54b09ba565fc10cee2f2e230c4f012e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9234c8d54b09ba565fc10cee2f2e230c4f012e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9234c8d54b09ba565fc10cee2f2e230c4f012e2/comments", "author": {"login": "dougkwan", "id": 1399231, "node_id": "MDQ6VXNlcjEzOTkyMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1399231?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dougkwan", "html_url": "https://github.com/dougkwan", "followers_url": "https://api.github.com/users/dougkwan/followers", "following_url": "https://api.github.com/users/dougkwan/following{/other_user}", "gists_url": "https://api.github.com/users/dougkwan/gists{/gist_id}", "starred_url": "https://api.github.com/users/dougkwan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dougkwan/subscriptions", "organizations_url": "https://api.github.com/users/dougkwan/orgs", "repos_url": "https://api.github.com/users/dougkwan/repos", "events_url": "https://api.github.com/users/dougkwan/events{/privacy}", "received_events_url": "https://api.github.com/users/dougkwan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "16fa5fe436b5fe5a540bf6ec29f3a4f7d61743a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16fa5fe436b5fe5a540bf6ec29f3a4f7d61743a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16fa5fe436b5fe5a540bf6ec29f3a4f7d61743a4"}], "stats": {"total": 798, "additions": 456, "deletions": 342}, "files": [{"sha": "b95f6b98dffcaa661e87d017933ce7e880efb05c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9234c8d54b09ba565fc10cee2f2e230c4f012e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9234c8d54b09ba565fc10cee2f2e230c4f012e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9234c8d54b09ba565fc10cee2f2e230c4f012e2", "patch": "@@ -1,3 +1,46 @@\n+2008-08-01  Doug Kwan  <dougkwan@google.com>\n+\n+\t* matrix-reorg.c: Re-enable all code.\n+\t(struct malloc_call_data): Change CALL_STMT to gimple type.\n+\t(collect_data_for_malloc_call): Tuplify.\n+ \t(struct access_site_info): Change STMT to gimple type.\n+\t(struct matrix_info): Change MIN_INDIRECT_LEVEL_ESCAPE_STMT,\n+\tand MALLOC_FOR_LEVEL to gimple and gimple pointer type.\n+\t(struct free_info): Change STMT to gimple type.\n+ \t(struct matrix_access_phi_node):  Change PHI to gimple type.\n+\t(get_inner_of_cast_expr): Remove.\n+\t(may_flatten_matrices_1): Tuplify.\n+\t(may_flatten_matrices): Ditto.\n+\t(mark_min_matrix_escape_level): Ditto.\n+ \t(ssa_accessed_in_tree): Refactor statement RHS related code into ...\n+\t(ssa_accessed_in_call_rhs): New\n+\t(ssa_accessed_in_assign_rhs): New\n+\t(record_access_alloc_site_info): Tuplify.\n+\t(add_allocation_site): Ditto.\n+\t(analyze_matrix_allocation_site): Ditto.\n+\t(analyze_transpose): Ditto.\n+\t(get_index_from_offset): Ditto.\n+\t(update_type_size): Ditto.\n+\t(analyze_accesses_for_call_expr): Tuplify and renamed into ...\n+\t(analyze_accesses_for_call_stmt): New. Also handle LHS of a call.\n+\t(analyze_accesses_for_phi_node): Tuplify.\n+\t(analyze_accesses_for_modify_stmt): Tuplify and renamed into ...\n+\t(analyze_accesses_for_assign_stmt): Remove code for handling call LHS.\n+\t(analyze_matrix_accesses): Tuplify.\n+\t(check_var_data): New call-back type for check_var_notmodified_p.\n+\t(check_var_notmodified_p): Tuplify and use call-back struct to\n+\treturn statement found.\n+\t(can_calculate_expr_before_stmt): Factor out statement related code\n+\tinto ...\n+\t(can_calculate_stmt_before_stmt): New.\n+ \t(check_allocation_function): Tuplify.\n+\t(find_sites_in_func): Ditto.\n+\t(record_all_accesses_in_func): Ditto.\n+\t(transform_access_sites): Ditto.\n+\t(transform_allocation_sites): Ditto.\n+\t(matrix_reorg): Re-enable.\n+\t(gate_matrix_reorg): Re-enable.\n+\n 2008-08-01  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (compute_barrier_args_size): Set barrier_args_size"}, {"sha": "846a813898f9a13d0b87a2b173c62be07ae0da21", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 413, "deletions": 342, "changes": 755, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9234c8d54b09ba565fc10cee2f2e230c4f012e2/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9234c8d54b09ba565fc10cee2f2e230c4f012e2/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=c9234c8d54b09ba565fc10cee2f2e230c4f012e2", "patch": "@@ -143,8 +143,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-chrec.h\"\n #include \"tree-scalar-evolution.h\"\n \n-  /* FIXME tuples.  */\n-#if 0\n /* We need to collect a lot of data from the original malloc,\n    particularly as the gimplifier has converted:\n \n@@ -163,11 +161,14 @@ along with GCC; see the file COPYING3.  If not see\n \n struct malloc_call_data\n {\n-  tree call_stmt;\t\t/* Tree for \"T4 = malloc (T3);\"                     */\n+  gimple call_stmt;\t\t/* Tree for \"T4 = malloc (T3);\"                     */\n   tree size_var;\t\t/* Var decl for T3.                                 */\n   tree malloc_size;\t\t/* Tree for \"<constant>\", the rhs assigned to T3.   */\n };\n \n+static tree can_calculate_expr_before_stmt (tree, sbitmap);\n+static tree can_calculate_stmt_before_stmt (gimple, sbitmap);\n+\n /* The front end of the compiler, when parsing statements of the form:\n \n    var = (type_cast) malloc (sizeof (type));\n@@ -187,24 +188,20 @@ struct malloc_call_data\n    need to find the rest of the variables/statements on our own.  That\n    is what the following function does.  */\n static void\n-collect_data_for_malloc_call (tree stmt, struct malloc_call_data *m_data)\n+collect_data_for_malloc_call (gimple stmt, struct malloc_call_data *m_data)\n {\n   tree size_var = NULL;\n   tree malloc_fn_decl;\n-  tree tmp;\n   tree arg1;\n \n-  gcc_assert (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT);\n+  gcc_assert (is_gimple_call (stmt));\n \n-  tmp = get_call_expr_in (stmt);\n-  malloc_fn_decl = CALL_EXPR_FN (tmp);\n-  if (TREE_CODE (malloc_fn_decl) != ADDR_EXPR\n-      || TREE_CODE (TREE_OPERAND (malloc_fn_decl, 0)) != FUNCTION_DECL\n-      || DECL_FUNCTION_CODE (TREE_OPERAND (malloc_fn_decl, 0)) !=\n-      BUILT_IN_MALLOC)\n+  malloc_fn_decl = gimple_call_fndecl (stmt);\n+  if (malloc_fn_decl == NULL\n+      || DECL_FUNCTION_CODE (malloc_fn_decl) != BUILT_IN_MALLOC)\n     return;\n \n-  arg1 = CALL_EXPR_ARG (tmp, 0);\n+  arg1 = gimple_call_arg (stmt, 0);\n   size_var = arg1;\n \n   m_data->call_stmt = stmt;\n@@ -223,7 +220,7 @@ collect_data_for_malloc_call (tree stmt, struct malloc_call_data *m_data)\n struct access_site_info\n {\n   /* The statement (INDIRECT_REF or POINTER_PLUS_EXPR).  */\n-  tree stmt;\n+  gimple stmt;\n \n   /* In case of POINTER_PLUS_EXPR, what is the offset.  */\n   tree offset;\n@@ -262,7 +259,7 @@ struct matrix_info\n      0 to ACTUAL_DIM - k escapes.  */\n   int min_indirect_level_escape;\n \n-  tree min_indirect_level_escape_stmt;\n+  gimple min_indirect_level_escape_stmt;\n \n   /* Is the matrix transposed.  */\n   bool is_transposed_p;\n@@ -271,7 +268,7 @@ struct matrix_info\n      We can use NUM_DIMS as the upper bound and allocate the array\n      once with this number of elements and no need to use realloc and\n      MAX_MALLOCED_LEVEL.  */\n-  tree *malloc_for_level;\n+  gimple *malloc_for_level;\n \n   int max_malloced_level;\n \n@@ -282,7 +279,7 @@ struct matrix_info\n   /* The calls to free for each level of indirection.  */\n   struct free_info\n   {\n-    tree stmt;\n+    gimple stmt;\n     tree func;\n   } *free_stmts;\n \n@@ -322,7 +319,7 @@ struct matrix_info\n \n struct matrix_access_phi_node\n {\n-  tree phi;\n+  gimple phi;\n   int indirection_level;\n };\n \n@@ -408,28 +405,20 @@ mtt_info_eq (const void *mtt1, const void *mtt2)\n   return false;\n }\n \n-/* Return the inner most tree that is not a cast.  */\n-static tree\n-get_inner_of_cast_expr (tree t)\n-{\n-  while (CONVERT_EXPR_P (t)\n-\t || TREE_CODE (t) == VIEW_CONVERT_EXPR)\n-    t = TREE_OPERAND (t, 0);\n-\n-  return t;\n-}\n-\n /* Return false if STMT may contain a vector expression.  \n    In this situation, all matrices should not be flattened.  */\n static bool\n-may_flatten_matrices_1 (tree stmt)\n+may_flatten_matrices_1 (gimple stmt)\n {\n   tree t;\n \n-  switch (TREE_CODE (stmt))\n+  switch (gimple_code (stmt))\n     {\n-    case GIMPLE_MODIFY_STMT:\n-      t = TREE_OPERAND (stmt, 1);\n+    case GIMPLE_ASSIGN:\n+      if (!gimple_assign_cast_p (stmt))\n+\treturn true;\n+\n+      t = gimple_assign_rhs1 (stmt);\n       while (CONVERT_EXPR_P (t))\n \t{\n \t  if (TREE_TYPE (t) && POINTER_TYPE_P (TREE_TYPE (t)))\n@@ -450,7 +439,7 @@ may_flatten_matrices_1 (tree stmt)\n \t  t = TREE_OPERAND (t, 0);\n \t}\n       break;\n-    case ASM_EXPR:\n+    case GIMPLE_ASM:\n       /* Asm code could contain vector operations.  */\n       return false;\n       break;\n@@ -468,15 +457,15 @@ may_flatten_matrices (struct cgraph_node *node)\n   tree decl;\n   struct function *func;\n   basic_block bb;\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator gsi;\n \n   decl = node->decl;\n   if (node->analyzed)\n     {\n       func = DECL_STRUCT_FUNCTION (decl);\n       FOR_EACH_BB_FN (bb, func)\n-\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\tif (!may_flatten_matrices_1 (bsi_stmt (bsi)))\n+\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\tif (!may_flatten_matrices_1 (gsi_stmt (gsi)))\n \t  return false;\n     }\n   return true;\n@@ -597,7 +586,7 @@ find_matrices_decl (void)\n \n /* Mark that the matrix MI escapes at level L.  */\n static void\n-mark_min_matrix_escape_level (struct matrix_info *mi, int l, tree s)\n+mark_min_matrix_escape_level (struct matrix_info *mi, int l, gimple s)\n {\n   if (mi->min_indirect_level_escape == -1\n       || (mi->min_indirect_level_escape > l))\n@@ -610,19 +599,13 @@ mark_min_matrix_escape_level (struct matrix_info *mi, int l, tree s)\n /* Find if the SSA variable is accessed inside the\n    tree and record the tree containing it.\n    The only relevant uses are the case of SSA_NAME, or SSA inside\n-   INDIRECT_REF, CALL_EXPR, PLUS_EXPR, POINTER_PLUS_EXPR, MULT_EXPR.  */\n+   INDIRECT_REF, PLUS_EXPR, POINTER_PLUS_EXPR, MULT_EXPR.  */\n static void\n ssa_accessed_in_tree (tree t, struct ssa_acc_in_tree *a)\n {\n-  tree call, decl;\n-  tree arg;\n-  call_expr_arg_iterator iter;\n-\n   a->t_code = TREE_CODE (t);\n   switch (a->t_code)\n     {\n-      tree op1, op2;\n-\n     case SSA_NAME:\n       if (t == a->ssa_var)\n \ta->var_found = true;\n@@ -632,24 +615,59 @@ ssa_accessed_in_tree (tree t, struct ssa_acc_in_tree *a)\n \t  && TREE_OPERAND (t, 0) == a->ssa_var)\n \ta->var_found = true;\n       break;\n-    case CALL_EXPR:\n-      FOR_EACH_CALL_EXPR_ARG (arg, iter, t)\n-      {\n-\tif (arg == a->ssa_var)\n-\t  {\n-\t    a->var_found = true;\n-\t    call = get_call_expr_in (t);\n-\t    if (call && (decl = get_callee_fndecl (call)))\n-\t      a->t_tree = decl;\n-\t    break;\n-\t  }\n-      }\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Find if the SSA variable is accessed on the right hand side of\n+   gimple call STMT. */\n+\n+static void\n+ssa_accessed_in_call_rhs (gimple stmt, struct ssa_acc_in_tree *a)\n+{\n+  tree decl;\n+  tree arg;\n+  size_t i;\n+\n+  a->t_code = CALL_EXPR;\n+  for (i = 0; i < gimple_call_num_args (stmt); i++)\n+    {\n+      arg = gimple_call_arg (stmt, i);\n+      if (arg == a->ssa_var)\n+\t{\n+\t  a->var_found = true;\n+\t  decl = gimple_call_fndecl (stmt);\n+\t  a->t_tree = decl;\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* Find if the SSA variable is accessed on the right hand side of\n+   gimple assign STMT. */\n+\n+static void\n+ssa_accessed_in_assign_rhs (gimple stmt, struct ssa_acc_in_tree *a)\n+{\n+\n+  a->t_code = gimple_assign_rhs_code (stmt);\n+  switch (a->t_code)\n+    {\n+      tree op1, op2;\n+\n+    case SSA_NAME:\n+    case INDIRECT_REF:\n+    case CONVERT_EXPR:\n+    case NOP_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      ssa_accessed_in_tree (gimple_assign_rhs1 (stmt), a);\n       break;\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n     case MULT_EXPR:\n-      op1 = TREE_OPERAND (t, 0);\n-      op2 = TREE_OPERAND (t, 1);\n+      op1 = gimple_assign_rhs1 (stmt);\n+      op2 = gimple_assign_rhs2 (stmt);\n \n       if (op1 == a->ssa_var)\n \t{\n@@ -670,7 +688,7 @@ ssa_accessed_in_tree (tree t, struct ssa_acc_in_tree *a)\n /* Record the access/allocation site information for matrix MI so we can \n    handle it later in transformation.  */\n static void\n-record_access_alloc_site_info (struct matrix_info *mi, tree stmt, tree offset,\n+record_access_alloc_site_info (struct matrix_info *mi, gimple stmt, tree offset,\n \t\t\t       tree index, int level, bool is_alloc)\n {\n   struct access_site_info *acc_info;\n@@ -697,7 +715,7 @@ record_access_alloc_site_info (struct matrix_info *mi, tree stmt, tree offset,\n    all the allocation sites could be pre-calculated before the call to\n    the malloc of level 0 (the main malloc call).  */\n static void\n-add_allocation_site (struct matrix_info *mi, tree stmt, int level)\n+add_allocation_site (struct matrix_info *mi, gimple stmt, int level)\n {\n   struct malloc_call_data mcd;\n \n@@ -740,13 +758,13 @@ add_allocation_site (struct matrix_info *mi, tree stmt, int level)\n      calls like calloc and realloc.  */\n   if (!mi->malloc_for_level)\n     {\n-      mi->malloc_for_level = XCNEWVEC (tree, level + 1);\n+      mi->malloc_for_level = XCNEWVEC (gimple, level + 1);\n       mi->max_malloced_level = level + 1;\n     }\n   else if (mi->max_malloced_level <= level)\n     {\n       mi->malloc_for_level\n-\t= XRESIZEVEC (tree, mi->malloc_for_level, level + 1);\n+\t= XRESIZEVEC (gimple, mi->malloc_for_level, level + 1);\n \n       /* Zero the newly allocated items.  */\n       memset (&(mi->malloc_for_level[mi->max_malloced_level + 1]),\n@@ -769,79 +787,74 @@ add_allocation_site (struct matrix_info *mi, tree stmt, int level)\n    Return if STMT is related to an allocation site.  */\n \n static void\n-analyze_matrix_allocation_site (struct matrix_info *mi, tree stmt,\n+analyze_matrix_allocation_site (struct matrix_info *mi, gimple stmt,\n \t\t\t\tint level, sbitmap visited)\n {\n-  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n+  if (gimple_assign_copy_p (stmt) || gimple_assign_cast_p (stmt))\n     {\n-      tree rhs = TREE_OPERAND (stmt, 1);\n+      tree rhs = gimple_assign_rhs1 (stmt);\n \n-      rhs = get_inner_of_cast_expr (rhs);\n       if (TREE_CODE (rhs) == SSA_NAME)\n \t{\n-\t  tree def = SSA_NAME_DEF_STMT (rhs);\n+\t  gimple def = SSA_NAME_DEF_STMT (rhs);\n \n \t  analyze_matrix_allocation_site (mi, def, level, visited);\n \t  return;\n \t}\n+      /* If we are back to the original matrix variable then we\n+         are sure that this is analyzed as an access site.  */\n+      else if (rhs == mi->decl)\n+\treturn;\n+    }\n+  /* A result of call to malloc.  */\n+  else if (is_gimple_call (stmt))\n+    {\n+      int call_flags = gimple_call_flags (stmt);\n \n-      /* A result of call to malloc.  */\n-      else if (TREE_CODE (rhs) == CALL_EXPR)\n+      if (!(call_flags & ECF_MALLOC))\n \t{\n-\t  int call_flags = call_expr_flags (rhs);\n+\t  mark_min_matrix_escape_level (mi, level, stmt);\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  tree malloc_fn_decl;\n+\t  const char *malloc_fname;\n \n-\t  if (!(call_flags & ECF_MALLOC))\n+\t  malloc_fn_decl = gimple_call_fndecl (stmt);\n+\t  if (malloc_fn_decl == NULL_TREE)\n \t    {\n \t      mark_min_matrix_escape_level (mi, level, stmt);\n \t      return;\n \t    }\n-\t  else\n-\t    {\n-\t      tree malloc_fn_decl;\n-\t      const char *malloc_fname;\n-\n-\t      malloc_fn_decl = CALL_EXPR_FN (rhs);\n-\t      if (TREE_CODE (malloc_fn_decl) != ADDR_EXPR\n-\t\t  || TREE_CODE (TREE_OPERAND (malloc_fn_decl, 0)) !=\n-\t\t  FUNCTION_DECL)\n-\t\t{\n-\t\t  mark_min_matrix_escape_level (mi, level, stmt);\n-\t\t  return;\n-\t\t}\n-\t      malloc_fn_decl = TREE_OPERAND (malloc_fn_decl, 0);\n-\t      malloc_fname = IDENTIFIER_POINTER (DECL_NAME (malloc_fn_decl));\n-\t      if (DECL_FUNCTION_CODE (malloc_fn_decl) != BUILT_IN_MALLOC)\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file,\n-\t\t\t     \"Matrix %s is an argument to function %s\\n\",\n-\t\t\t     get_name (mi->decl), get_name (malloc_fn_decl));\n-\t\t  mark_min_matrix_escape_level (mi, level, stmt);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t  /* This is a call to malloc of level 'level'.  \n-\t     mi->max_malloced_level-1 == level  means that we've \n-\t     seen a malloc statement of level 'level' before.  \n-\t     If the statement is not the same one that we've \n-\t     seen before, then there's another malloc statement \n-\t     for the same level, which means that we need to mark \n-\t     it escaping.  */\n-\t  if (mi->malloc_for_level\n-\t      && mi->max_malloced_level-1 == level\n-\t      && mi->malloc_for_level[level] != stmt)\n+\t  malloc_fname = IDENTIFIER_POINTER (DECL_NAME (malloc_fn_decl));\n+\t  if (DECL_FUNCTION_CODE (malloc_fn_decl) != BUILT_IN_MALLOC)\n \t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Matrix %s is an argument to function %s\\n\",\n+\t\t\t get_name (mi->decl), get_name (malloc_fn_decl));\n \t      mark_min_matrix_escape_level (mi, level, stmt);\n \t      return;\n \t    }\n-\t  else\n-\t    add_allocation_site (mi, stmt, level);\n+\t}\n+      /* This is a call to malloc of level 'level'.  \n+\t mi->max_malloced_level-1 == level  means that we've \n+\t seen a malloc statement of level 'level' before.  \n+\t If the statement is not the same one that we've \n+\t seen before, then there's another malloc statement \n+\t for the same level, which means that we need to mark \n+\t it escaping.  */\n+      if (mi->malloc_for_level\n+\t  && mi->max_malloced_level-1 == level\n+\t  && mi->malloc_for_level[level] != stmt)\n+\t{\n+\t  mark_min_matrix_escape_level (mi, level, stmt);\n \t  return;\n \t}\n-      /* If we are back to the original matrix variable then we\n-         are sure that this is analyzed as an access site.  */\n-      else if (rhs == mi->decl)\n-\treturn;\n+      else\n+\tadd_allocation_site (mi, stmt, level);\n+      return;\n     }\n   /* Looks like we don't know what is happening in this\n      statement so be in the safe side and mark it as escaping.  */\n@@ -909,7 +922,7 @@ analyze_transpose (void **slot, void *data ATTRIBUTE_UNUSED)\n   for (i = 0; VEC_iterate (access_site_info_p, mi->access_l, i, acc_info);\n        i++)\n     {\n-      if (TREE_CODE (TREE_OPERAND (acc_info->stmt, 1)) == POINTER_PLUS_EXPR\n+      if (gimple_assign_rhs_code (acc_info->stmt) == POINTER_PLUS_EXPR\n \t  && acc_info->level < min_escape_l)\n \t{\n \t  loop = loop_containing_stmt (acc_info->stmt);\n@@ -945,19 +958,21 @@ analyze_transpose (void **slot, void *data ATTRIBUTE_UNUSED)\n /* Find the index which defines the OFFSET from base.  \n    We walk from use to def until we find how the offset was defined.  */\n static tree\n-get_index_from_offset (tree offset, tree def_stmt)\n+get_index_from_offset (tree offset, gimple def_stmt)\n {\n-  tree op1, op2, expr, index;\n+  tree op1, op2, index;\n \n-  if (TREE_CODE (def_stmt) == PHI_NODE)\n+  if (gimple_code (def_stmt) == GIMPLE_PHI)\n     return NULL;\n-  expr = get_inner_of_cast_expr (TREE_OPERAND (def_stmt, 1));\n-  if (TREE_CODE (expr) == SSA_NAME)\n-    return get_index_from_offset (offset, SSA_NAME_DEF_STMT (expr));\n-  else if (TREE_CODE (expr) == MULT_EXPR)\n+  if ((gimple_assign_copy_p (def_stmt) || gimple_assign_cast_p (def_stmt))\n+      && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME)\n+    return get_index_from_offset (offset,\n+\t\t\t\t  SSA_NAME_DEF_STMT (gimple_assign_rhs1 (def_stmt)));\n+  else if (is_gimple_assign (def_stmt)\n+\t   && gimple_assign_rhs_code (def_stmt) == MULT_EXPR)\n     {\n-      op1 = TREE_OPERAND (expr, 0);\n-      op2 = TREE_OPERAND (expr, 1);\n+      op1 = gimple_assign_rhs1 (def_stmt);\n+      op2 = gimple_assign_rhs2 (def_stmt);\n       if (TREE_CODE (op1) != INTEGER_CST && TREE_CODE (op2) != INTEGER_CST)\n \treturn NULL;\n       index = (TREE_CODE (op1) == INTEGER_CST) ? op2 : op1;\n@@ -971,17 +986,17 @@ get_index_from_offset (tree offset, tree def_stmt)\n    of the type related to the SSA_VAR, or the type related to the\n    lhs of STMT, in the case that it is an INDIRECT_REF.  */\n static void\n-update_type_size (struct matrix_info *mi, tree stmt, tree ssa_var,\n+update_type_size (struct matrix_info *mi, gimple stmt, tree ssa_var,\n \t\t  int current_indirect_level)\n {\n   tree lhs;\n   HOST_WIDE_INT type_size;\n \n   /* Update type according to the type of the INDIRECT_REF expr.   */\n-  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n-      && TREE_CODE (TREE_OPERAND (stmt, 0)) == INDIRECT_REF)\n+  if (is_gimple_assign (stmt)\n+      && TREE_CODE (gimple_assign_lhs (stmt)) == INDIRECT_REF)\n     {\n-      lhs = TREE_OPERAND (stmt, 0);\n+      lhs = gimple_assign_lhs (stmt);\n       gcc_assert (POINTER_TYPE_P\n \t\t  (TREE_TYPE (SSA_NAME_VAR (TREE_OPERAND (lhs, 0)))));\n       type_size =\n@@ -1026,24 +1041,66 @@ update_type_size (struct matrix_info *mi, tree stmt, tree ssa_var,\n     }\n }\n \n-/* USE_STMT represents a call_expr ,where one of the arguments is the \n+/* USE_STMT represents a GIMPLE_CALL, where one of the arguments is the \n    ssa var that we want to check because it came from some use of matrix \n    MI.  CURRENT_INDIRECT_LEVEL is the indirection level we reached so \n    far.  */\n \n-static void\n-analyze_accesses_for_call_expr (struct matrix_info *mi, tree use_stmt,\n-\t\t\t\tint current_indirect_level)\n+static int\n+analyze_accesses_for_call_stmt (struct matrix_info *mi, tree ssa_var,\n+\t\t\t\tgimple use_stmt, int current_indirect_level)\n {\n-  tree call = get_call_expr_in (use_stmt);\n-  if (call && get_callee_fndecl (call))\n+  tree fndecl = gimple_call_fndecl (use_stmt);\n+\n+  if (gimple_call_lhs (use_stmt))\n     {\n-      if (DECL_FUNCTION_CODE (get_callee_fndecl (call)) != BUILT_IN_FREE)\n+      tree lhs = gimple_call_lhs (use_stmt);\n+      struct ssa_acc_in_tree lhs_acc, rhs_acc;\n+\n+      memset (&lhs_acc, 0, sizeof (lhs_acc));\n+      memset (&rhs_acc, 0, sizeof (rhs_acc));\n+\n+      lhs_acc.ssa_var = ssa_var;\n+      lhs_acc.t_code = ERROR_MARK;\n+      ssa_accessed_in_tree (lhs, &lhs_acc);\n+      rhs_acc.ssa_var = ssa_var;\n+      rhs_acc.t_code = ERROR_MARK;\n+      ssa_accessed_in_call_rhs (use_stmt, &rhs_acc);\n+\n+      /* The SSA must be either in the left side or in the right side,\n+\t to understand what is happening.\n+\t In case the SSA_NAME is found in both sides we should be escaping\n+\t at this level because in this case we cannot calculate the\n+\t address correctly.  */\n+      if ((lhs_acc.var_found && rhs_acc.var_found\n+\t   && lhs_acc.t_code == INDIRECT_REF)\n+\t  || (!rhs_acc.var_found && !lhs_acc.var_found))\n+\t{\n+\t  mark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n+\t  return current_indirect_level;\n+\t}\n+      gcc_assert (!rhs_acc.var_found || !lhs_acc.var_found);\n+\n+      /* If we are storing to the matrix at some level, then mark it as\n+\t escaping at that level.  */\n+      if (lhs_acc.var_found)\n+\t{\n+\t  int l = current_indirect_level + 1;\n+\n+\t  gcc_assert (lhs_acc.t_code == INDIRECT_REF);\n+\t  mark_min_matrix_escape_level (mi, l, use_stmt);\n+\t  return current_indirect_level;\n+\t}\n+    }\n+\n+  if (fndecl)\n+    {\n+      if (DECL_FUNCTION_CODE (fndecl) != BUILT_IN_FREE)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Matrix %s: Function call %s, level %d escapes.\\n\",\n-\t\t     get_name (mi->decl), get_name (get_callee_fndecl (call)),\n+\t\t     get_name (mi->decl), get_name (fndecl),\n \t\t     current_indirect_level);\n \t  mark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n \t}\n@@ -1060,6 +1117,7 @@ analyze_accesses_for_call_expr (struct matrix_info *mi, tree use_stmt,\n \t  mi->free_stmts[l].func = current_function_decl;\n \t}\n     }\n+  return current_indirect_level;\n }\n \n /* USE_STMT represents a phi node of the ssa var that we want to \n@@ -1073,7 +1131,7 @@ analyze_accesses_for_call_expr (struct matrix_info *mi, tree use_stmt,\n    CURRENT_INDIRECT_LEVEL is the indirection level we reached so far.  */\n \n static void\n-analyze_accesses_for_phi_node (struct matrix_info *mi, tree use_stmt,\n+analyze_accesses_for_phi_node (struct matrix_info *mi, gimple use_stmt,\n \t\t\t       int current_indirect_level, sbitmap visited,\n \t\t\t       bool record_accesses)\n {\n@@ -1090,18 +1148,18 @@ analyze_accesses_for_phi_node (struct matrix_info *mi, tree use_stmt,\n \t{\n \t  int level = MIN (maphi->indirection_level,\n \t\t\t   current_indirect_level);\n-\t  int j;\n-\t  tree t = NULL_TREE;\n+\t  size_t j;\n+\t  gimple stmt = NULL;\n \n \t  maphi->indirection_level = level;\n-\t  for (j = 0; j < PHI_NUM_ARGS (use_stmt); j++)\n+\t  for (j = 0; j < gimple_phi_num_args (use_stmt); j++)\n \t    {\n \t      tree def = PHI_ARG_DEF (use_stmt, j);\n \n-\t      if (TREE_CODE (SSA_NAME_DEF_STMT (def)) != PHI_NODE)\n-\t\tt = SSA_NAME_DEF_STMT (def);\n+\t      if (gimple_code (SSA_NAME_DEF_STMT (def)) != GIMPLE_PHI)\n+\t\tstmt = SSA_NAME_DEF_STMT (def);\n \t    }\n-\t  mark_min_matrix_escape_level (mi, level, t);\n+\t  mark_min_matrix_escape_level (mi, level, stmt);\n \t}\n       return;\n     }\n@@ -1126,20 +1184,17 @@ analyze_accesses_for_phi_node (struct matrix_info *mi, tree use_stmt,\n     }\n }\n \n-/* USE_STMT represents a modify statement (the rhs or lhs include \n+/* USE_STMT represents an assign statement (the rhs or lhs include \n    the ssa var that we want to check  because it came from some use of matrix \n-   MI.\n-   CURRENT_INDIRECT_LEVEL is the indirection level we reached so far.  */\n+   MI.  CURRENT_INDIRECT_LEVEL is the indirection level we reached so far.  */\n \n static int\n-analyze_accesses_for_modify_stmt (struct matrix_info *mi, tree ssa_var,\n-\t\t\t\t  tree use_stmt, int current_indirect_level,\n+analyze_accesses_for_assign_stmt (struct matrix_info *mi, tree ssa_var,\n+\t\t\t\t  gimple use_stmt, int current_indirect_level,\n \t\t\t\t  bool last_op, sbitmap visited,\n \t\t\t\t  bool record_accesses)\n {\n-\n-  tree lhs = TREE_OPERAND (use_stmt, 0);\n-  tree rhs = TREE_OPERAND (use_stmt, 1);\n+  tree lhs = gimple_get_lhs (use_stmt);\n   struct ssa_acc_in_tree lhs_acc, rhs_acc;\n \n   memset (&lhs_acc, 0, sizeof (lhs_acc));\n@@ -1150,7 +1205,7 @@ analyze_accesses_for_modify_stmt (struct matrix_info *mi, tree ssa_var,\n   ssa_accessed_in_tree (lhs, &lhs_acc);\n   rhs_acc.ssa_var = ssa_var;\n   rhs_acc.t_code = ERROR_MARK;\n-  ssa_accessed_in_tree (get_inner_of_cast_expr (rhs), &rhs_acc);\n+  ssa_accessed_in_assign_rhs (use_stmt, &rhs_acc);\n \n   /* The SSA must be either in the left side or in the right side,\n      to understand what is happening.\n@@ -1170,17 +1225,18 @@ analyze_accesses_for_modify_stmt (struct matrix_info *mi, tree ssa_var,\n      escaping at that level.  */\n   if (lhs_acc.var_found)\n     {\n-      tree def;\n       int l = current_indirect_level + 1;\n \n       gcc_assert (lhs_acc.t_code == INDIRECT_REF);\n-      def = get_inner_of_cast_expr (rhs);\n-      if (TREE_CODE (def) != SSA_NAME)\n+\n+      if (!(gimple_assign_copy_p (use_stmt)\n+\t    || gimple_assign_cast_p (use_stmt))\n+\t  || (TREE_CODE (gimple_assign_rhs1 (use_stmt)) != SSA_NAME))\n \tmark_min_matrix_escape_level (mi, l, use_stmt);\n       else\n \t{\n-\t  def = SSA_NAME_DEF_STMT (def);\n-\t  analyze_matrix_allocation_site (mi, def, l, visited);\n+\t  gimple def_stmt = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (use_stmt));\n+\t  analyze_matrix_allocation_site (mi, def_stmt, l, visited);\n \t  if (record_accesses)\n \t    record_access_alloc_site_info (mi, use_stmt, NULL_TREE,\n \t\t\t\t\t   NULL_TREE, l, true);\n@@ -1192,17 +1248,6 @@ analyze_accesses_for_modify_stmt (struct matrix_info *mi, tree ssa_var,\n      is used.  */\n   if (rhs_acc.var_found)\n     {\n-      /* If we are passing the ssa name to a function call and\n-         the pointer escapes when passed to the function \n-         (not the case of free), then we mark the matrix as \n-         escaping at this level.  */\n-      if (rhs_acc.t_code == CALL_EXPR)\n-\t{\n-\t  analyze_accesses_for_call_expr (mi, use_stmt,\n-\t\t\t\t\t  current_indirect_level);\n-\n-\t  return current_indirect_level;\n-\t}\n       if (rhs_acc.t_code != INDIRECT_REF\n \t  && rhs_acc.t_code != POINTER_PLUS_EXPR && rhs_acc.t_code != SSA_NAME)\n \t{\n@@ -1235,8 +1280,8 @@ analyze_accesses_for_modify_stmt (struct matrix_info *mi, tree ssa_var,\n \t      tree index;\n \t      tree op1, op2;\n \n-\t      op1 = TREE_OPERAND (rhs, 0);\n-\t      op2 = TREE_OPERAND (rhs, 1);\n+\t      op1 = gimple_assign_rhs1 (use_stmt);\n+\t      op2 = gimple_assign_rhs2 (use_stmt);\n \n \t      op2 = (op1 == ssa_var) ? op2 : op1;\n \t      if (TREE_CODE (op2) == INTEGER_CST)\n@@ -1331,8 +1376,8 @@ analyze_matrix_accesses (struct matrix_info *mi, tree ssa_var,\n \n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, ssa_var)\n   {\n-    tree use_stmt = USE_STMT (use_p);\n-    if (TREE_CODE (use_stmt) == PHI_NODE)\n+    gimple use_stmt = USE_STMT (use_p);\n+    if (gimple_code (use_stmt) == GIMPLE_PHI)\n       /* We check all the escaping levels that get to the PHI node\n          and make sure they are all the same escaping;\n          if not (which is rare) we let the escaping level be the\n@@ -1342,16 +1387,22 @@ analyze_matrix_accesses (struct matrix_info *mi, tree ssa_var,\n       analyze_accesses_for_phi_node (mi, use_stmt, current_indirect_level,\n \t\t\t\t     visited, record_accesses);\n \n-    else if (TREE_CODE (use_stmt) == CALL_EXPR)\n-      analyze_accesses_for_call_expr (mi, use_stmt, current_indirect_level);\n-    else if (TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT)\n+    else if (is_gimple_call (use_stmt))\n+      analyze_accesses_for_call_stmt (mi, ssa_var, use_stmt,\n+\t\t\t\t      current_indirect_level);\n+    else if (is_gimple_assign (use_stmt))\n       current_indirect_level =\n-\tanalyze_accesses_for_modify_stmt (mi, ssa_var, use_stmt,\n+\tanalyze_accesses_for_assign_stmt (mi, ssa_var, use_stmt,\n \t\t\t\t\t  current_indirect_level, last_op,\n \t\t\t\t\t  visited, record_accesses);\n   }\n }\n \n+typedef struct \n+{\n+  tree fn;\n+  gimple stmt;\n+} check_var_data;\n \n /* A walk_tree function to go over the VAR_DECL, PARM_DECL nodes of\n    the malloc size expression and check that those aren't changed\n@@ -1361,81 +1412,90 @@ check_var_notmodified_p (tree * tp, int *walk_subtrees, void *data)\n {\n   basic_block bb;\n   tree t = *tp;\n-  tree fn = (tree) data;\n-  block_stmt_iterator bsi;\n-  tree stmt;\n+  check_var_data *callback_data = (check_var_data*) data;\n+  tree fn = callback_data->fn;\n+  gimple_stmt_iterator gsi;\n+  gimple stmt;\n \n   if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n     return NULL_TREE;\n \n   FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (fn))\n   {\n-    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n-\tstmt = bsi_stmt (bsi);\n-\tif (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+\tstmt = gsi_stmt (gsi);\n+\tif (!is_gimple_assign (stmt) && !is_gimple_call (stmt))\n \t  continue;\n-\tif (TREE_OPERAND (stmt, 0) == t)\n-\t  return stmt;\n+\tif (gimple_get_lhs (stmt) == t)\n+\t  {\n+\t    callback_data->stmt = stmt;\n+\t    return t;\n+\t  }\n       }\n   }\n   *walk_subtrees = 1;\n   return NULL_TREE;\n }\n \n /* Go backwards in the use-def chains and find out the expression\n-   represented by the possible SSA name in EXPR, until it is composed\n+   represented by the possible SSA name in STMT, until it is composed\n    of only VAR_DECL, PARM_DECL and INT_CST.  In case of phi nodes\n    we make sure that all the arguments represent the same subexpression,\n    otherwise we fail.  */\n+\n static tree\n-can_calculate_expr_before_stmt (tree expr, sbitmap visited)\n+can_calculate_stmt_before_stmt (gimple stmt, sbitmap visited)\n {\n-  tree def_stmt, op1, op2, res;\n+  tree op1, op2, res;\n+  enum tree_code code;\n \n-  switch (TREE_CODE (expr))\n+  switch (gimple_code (stmt))\n     {\n-    case SSA_NAME:\n-      /* Case of loop, we don't know to represent this expression.  */\n-      if (TEST_BIT (visited, SSA_NAME_VERSION (expr)))\n-\treturn NULL_TREE;\n+    case GIMPLE_ASSIGN:\n+      code = gimple_assign_rhs_code (stmt);\n+      op1 = gimple_assign_rhs1 (stmt);\n+\t\n+      switch (code)\n+\t{\n+\tcase POINTER_PLUS_EXPR:\n+\tcase PLUS_EXPR:\n+\tcase MINUS_EXPR:\n+\tcase MULT_EXPR:\n+\n+\t  op2 = gimple_assign_rhs2 (stmt);\n+\t  op1 = can_calculate_expr_before_stmt (op1, visited);\n+\t  if (!op1)\n+\t    return NULL_TREE;\n+\t  op2 = can_calculate_expr_before_stmt (op2, visited);\n+\t  if (op2)\n+\t    return fold_build2 (code, gimple_expr_type (stmt), op1, op2);\n+\t  return NULL_TREE;\n+\n+\tCASE_CONVERT:\n+\t  res = can_calculate_expr_before_stmt (op1, visited);\n+\t  if (res != NULL_TREE)\n+\t    return build1 (code, gimple_expr_type (stmt), res);\n+\t  else\n+\t    return NULL_TREE;\n \n-      SET_BIT (visited, SSA_NAME_VERSION (expr));\n-      def_stmt = SSA_NAME_DEF_STMT (expr);\n-      res = can_calculate_expr_before_stmt (def_stmt, visited);\n-      RESET_BIT (visited, SSA_NAME_VERSION (expr));\n-      return res;\n-    case VAR_DECL:\n-    case PARM_DECL:\n-    case INTEGER_CST:\n-      return expr;\n-    case POINTER_PLUS_EXPR:\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-    case MULT_EXPR:\n-      op1 = TREE_OPERAND (expr, 0);\n-      op2 = TREE_OPERAND (expr, 1);\n+\tdefault:\n+\t  if (gimple_assign_single_p (stmt))\n+\t    return can_calculate_expr_before_stmt (op1, visited);\n+\t  else\n+\t    return NULL_TREE;\n+\t}\n \n-      op1 = can_calculate_expr_before_stmt (op1, visited);\n-      if (!op1)\n-\treturn NULL_TREE;\n-      op2 = can_calculate_expr_before_stmt (op2, visited);\n-      if (op2)\n-\treturn fold_build2 (TREE_CODE (expr), TREE_TYPE (expr), op1, op2);\n-      return NULL_TREE;\n-    case GIMPLE_MODIFY_STMT:\n-      return can_calculate_expr_before_stmt (TREE_OPERAND (expr, 1),\n-\t\t\t\t\t     visited);\n-    case PHI_NODE:\n+    case GIMPLE_PHI:\n       {\n-\tint j;\n+\tsize_t j;\n \n \tres = NULL_TREE;\n \t/* Make sure all the arguments represent the same value.  */\n-\tfor (j = 0; j < PHI_NUM_ARGS (expr); j++)\n+\tfor (j = 0; j < gimple_phi_num_args (stmt); j++)\n \t  {\n \t    tree new_res;\n-\t    tree def = PHI_ARG_DEF (expr, j);\n+\t    tree def = PHI_ARG_DEF (stmt, j);\n \n \t    new_res = can_calculate_expr_before_stmt (def, visited);\n \t    if (res == NULL_TREE)\n@@ -1445,13 +1505,40 @@ can_calculate_expr_before_stmt (tree expr, sbitmap visited)\n \t  }\n \treturn res;\n       }\n-    CASE_CONVERT:\n-      res = can_calculate_expr_before_stmt (TREE_OPERAND (expr, 0), visited);\n-      if (res != NULL_TREE)\n-\treturn build1 (TREE_CODE (expr), TREE_TYPE (expr), res);\n-      else\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+/* Go backwards in the use-def chains and find out the expression\n+   represented by the possible SSA name in EXPR, until it is composed\n+   of only VAR_DECL, PARM_DECL and INT_CST.  In case of phi nodes\n+   we make sure that all the arguments represent the same subexpression,\n+   otherwise we fail.  */\n+static tree\n+can_calculate_expr_before_stmt (tree expr, sbitmap visited)\n+{\n+  gimple def_stmt;\n+  tree res;\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case SSA_NAME:\n+      /* Case of loop, we don't know to represent this expression.  */\n+      if (TEST_BIT (visited, SSA_NAME_VERSION (expr)))\n \treturn NULL_TREE;\n \n+      SET_BIT (visited, SSA_NAME_VERSION (expr));\n+      def_stmt = SSA_NAME_DEF_STMT (expr);\n+      res = can_calculate_stmt_before_stmt (def_stmt, visited);\n+      RESET_BIT (visited, SSA_NAME_VERSION (expr));\n+      return res;\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case INTEGER_CST:\n+      return expr;\n+\n     default:\n       return NULL_TREE;\n     }\n@@ -1483,7 +1570,7 @@ static int\n check_allocation_function (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n   int level;\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator gsi;\n   basic_block bb_level_0;\n   struct matrix_info *mi = (struct matrix_info *) *slot;\n   sbitmap visited;\n@@ -1504,16 +1591,17 @@ check_allocation_function (void **slot, void *data ATTRIBUTE_UNUSED)\n     if (!mi->malloc_for_level[level])\n       break;\n \n-  mark_min_matrix_escape_level (mi, level, NULL_TREE);\n+  mark_min_matrix_escape_level (mi, level, NULL);\n \n-  bsi = bsi_for_stmt (mi->malloc_for_level[0]);\n-  bb_level_0 = bsi.bb;\n+  gsi = gsi_for_stmt (mi->malloc_for_level[0]);\n+  bb_level_0 = gsi.bb;\n \n   /* Check if the expression of the size passed to malloc could be\n      pre-calculated before the malloc of level 0.  */\n   for (level = 1; level < mi->min_indirect_level_escape; level++)\n     {\n-      tree call_stmt, size;\n+      gimple call_stmt;\n+      tree size;\n       struct malloc_call_data mcd;\n \n       call_stmt = mi->malloc_for_level[level];\n@@ -1574,40 +1662,43 @@ find_sites_in_func (bool record)\n {\n   sbitmap visited_stmts_1;\n \n-  block_stmt_iterator bsi;\n-  tree stmt;\n+  gimple_stmt_iterator gsi;\n+  gimple stmt;\n   basic_block bb;\n   struct matrix_info tmpmi, *mi;\n \n   visited_stmts_1 = sbitmap_alloc (num_ssa_names);\n \n   FOR_EACH_BB (bb)\n   {\n-    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n-\tstmt = bsi_stmt (bsi);\n-\tif (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n-\t    && TREE_CODE (TREE_OPERAND (stmt, 0)) == VAR_DECL)\n+\ttree lhs;\n+\n+\tstmt = gsi_stmt (gsi);\n+\tlhs = gimple_get_lhs (stmt);\n+\tif (lhs != NULL_TREE\n+\t    && TREE_CODE (lhs) == VAR_DECL)\n \t  {\n-\t    tmpmi.decl = TREE_OPERAND (stmt, 0);\n+\t    tmpmi.decl = lhs;\n \t    if ((mi = (struct matrix_info *) htab_find (matrices_to_reorg,\n \t\t\t\t\t\t\t&tmpmi)))\n \t      {\n \t\tsbitmap_zero (visited_stmts_1);\n \t\tanalyze_matrix_allocation_site (mi, stmt, 0, visited_stmts_1);\n \t      }\n \t  }\n-\tif (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n-\t    && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME\n-\t    && TREE_CODE (TREE_OPERAND (stmt, 1)) == VAR_DECL)\n+\tif (is_gimple_assign (stmt)\n+\t    && gimple_assign_single_p (stmt)\n+\t    && TREE_CODE (lhs) == SSA_NAME\n+\t    && TREE_CODE (gimple_assign_rhs1 (stmt)) == VAR_DECL)\n \t  {\n-\t    tmpmi.decl = TREE_OPERAND (stmt, 1);\n+\t    tmpmi.decl = gimple_assign_rhs1 (stmt);\n \t    if ((mi = (struct matrix_info *) htab_find (matrices_to_reorg,\n \t\t\t\t\t\t\t&tmpmi)))\n \t      {\n \t\tsbitmap_zero (visited_stmts_1);\n-\t\tanalyze_matrix_accesses (mi,\n-\t\t\t\t\t TREE_OPERAND (stmt, 0), 0,\n+\t\tanalyze_matrix_accesses (mi, lhs, 0,\n \t\t\t\t\t false, visited_stmts_1, record);\n \t      }\n \t  }\n@@ -1639,10 +1730,11 @@ record_all_accesses_in_func (void)\n       tree rhs, lhs;\n \n       if (!ssa_var\n-\t  || TREE_CODE (SSA_NAME_DEF_STMT (ssa_var)) != GIMPLE_MODIFY_STMT)\n+\t  || !is_gimple_assign (SSA_NAME_DEF_STMT (ssa_var))\n+\t  || !gimple_assign_single_p (SSA_NAME_DEF_STMT (ssa_var)))\n \tcontinue;\n-      rhs = TREE_OPERAND (SSA_NAME_DEF_STMT (ssa_var), 1);\n-      lhs = TREE_OPERAND (SSA_NAME_DEF_STMT (ssa_var), 0);\n+      rhs = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (ssa_var));\n+      lhs = gimple_assign_lhs (SSA_NAME_DEF_STMT (ssa_var));\n       if (TREE_CODE (rhs) != VAR_DECL && TREE_CODE (lhs) != VAR_DECL)\n \tcontinue;\n \n@@ -1718,19 +1810,18 @@ compute_offset (HOST_WIDE_INT orig, HOST_WIDE_INT new, tree result)\n static int\n transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator gsi;\n   struct matrix_info *mi = (struct matrix_info *) *slot;\n   int min_escape_l = mi->min_indirect_level_escape;\n   struct access_site_info *acc_info;\n+  enum tree_code code;\n   int i;\n \n   if (min_escape_l < 2 || !mi->access_l)\n     return 1;\n   for (i = 0; VEC_iterate (access_site_info_p, mi->access_l, i, acc_info);\n        i++)\n     {\n-      tree orig, type;\n-\n       /* This is possible because we collect the access sites before\n          we determine the final minimum indirection level.  */\n       if (acc_info->level >= min_escape_l)\n@@ -1744,69 +1835,61 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t    {\n \t      ssa_op_iter iter;\n \t      tree def;\n-\t      tree stmt = acc_info->stmt;\n+\t      gimple stmt = acc_info->stmt;\n+\t      tree lhs;\n \n \t      FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n \t\tmark_sym_for_renaming (SSA_NAME_VAR (def));\n-\t      bsi = bsi_for_stmt (stmt);\n-\t      gcc_assert (TREE_CODE (acc_info->stmt) == GIMPLE_MODIFY_STMT);\n-\t      if (TREE_CODE (TREE_OPERAND (acc_info->stmt, 0)) ==\n-\t\t  SSA_NAME && acc_info->level < min_escape_l - 1)\n+\t      gsi = gsi_for_stmt (stmt);\n+\t      gcc_assert (is_gimple_assign (acc_info->stmt));\n+\t      lhs = gimple_assign_lhs (acc_info->stmt);\n+\t      if (TREE_CODE (lhs) == SSA_NAME\n+\t\t  && acc_info->level < min_escape_l - 1)\n \t\t{\n \t\t  imm_use_iterator imm_iter;\n \t\t  use_operand_p use_p;\n-\t\t  tree use_stmt;\n+\t\t  gimple use_stmt;\n \n-\t\t  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter,\n-\t\t\t\t\t TREE_OPERAND (acc_info->stmt,\n-\t\t\t\t\t\t\t      0))\n+\t\t  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, lhs)\n \t\t    FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n \t\t  {\n-\t\t    tree conv, tmp, stmts;\n+\t\t    tree rhs, tmp;\n+\t\t    gimple new_stmt;\n \n+\t\t    gcc_assert (gimple_assign_rhs_code (acc_info->stmt)\n+\t\t\t\t== INDIRECT_REF);\n \t\t    /* Emit convert statement to convert to type of use.  */\n-\t\t    conv =\n-\t\t      fold_build1 (CONVERT_EXPR,\n-\t\t\t\t   TREE_TYPE (TREE_OPERAND\n-\t\t\t\t\t      (acc_info->stmt, 0)),\n-\t\t\t\t   TREE_OPERAND (TREE_OPERAND\n-\t\t\t\t\t\t (acc_info->stmt, 1), 0));\n-\t\t    tmp =\n-\t\t      create_tmp_var (TREE_TYPE\n-\t\t\t\t      (TREE_OPERAND\n-\t\t\t\t       (acc_info->stmt, 0)), \"new\");\n+\t\t    tmp = create_tmp_var (TREE_TYPE (lhs), \"new\");\n \t\t    add_referenced_var (tmp);\n-\t\t    stmts =\n-\t\t      fold_build2 (GIMPLE_MODIFY_STMT,\n-\t\t\t\t   TREE_TYPE (TREE_OPERAND\n-\t\t\t\t\t      (acc_info->stmt, 0)), tmp,\n-\t\t\t\t   conv);\n-\t\t    tmp = make_ssa_name (tmp, stmts);\n-\t\t    TREE_OPERAND (stmts, 0) = tmp;\n-\t\t    bsi = bsi_for_stmt (acc_info->stmt);\n-\t\t    bsi_insert_after (&bsi, stmts, BSI_SAME_STMT);\n+\t\t    rhs = gimple_assign_rhs1 (acc_info->stmt);\n+\t\t    new_stmt = gimple_build_assign (tmp,\n+\t\t\t\t\t\t    TREE_OPERAND (rhs, 0));\n+\t\t    tmp = make_ssa_name (tmp, new_stmt);\n+\t\t    gimple_assign_set_lhs (new_stmt, tmp);\n+\t\t    gsi = gsi_for_stmt (acc_info->stmt);\n+\t\t    gsi_insert_after (&gsi, new_stmt, GSI_SAME_STMT);\n \t\t    SET_USE (use_p, tmp);\n \t\t  }\n \t\t}\n \t      if (acc_info->level < min_escape_l - 1)\n-\t\tbsi_remove (&bsi, true);\n+\t\tgsi_remove (&gsi, true);\n \t    }\n \t  free (acc_info);\n \t  continue;\n \t}\n-      orig = TREE_OPERAND (acc_info->stmt, 1);\n-      type = TREE_TYPE (orig);\n-      if (TREE_CODE (orig) == INDIRECT_REF\n+      code = gimple_assign_rhs_code (acc_info->stmt);\n+      if (code == INDIRECT_REF\n \t  && acc_info->level < min_escape_l - 1)\n \t{\n \t  /* Replace the INDIRECT_REF with NOP (cast) usually we are casting\n \t     from \"pointer to type\" to \"type\".  */\n-\t  orig =\n-\t    build1 (NOP_EXPR, TREE_TYPE (orig),\n-\t\t    TREE_OPERAND (orig, 0));\n-\t  TREE_OPERAND (acc_info->stmt, 1) = orig;\n+\t  tree t =\n+\t    build1 (NOP_EXPR, TREE_TYPE (gimple_assign_rhs1 (acc_info->stmt)),\n+\t\t    TREE_OPERAND (gimple_assign_rhs1 (acc_info->stmt), 0));\n+\t  gimple_assign_set_rhs_code (acc_info->stmt, NOP_EXPR);\n+\t  gimple_assign_set_rhs1 (acc_info->stmt, t);\n \t}\n-      else if (TREE_CODE (orig) == POINTER_PLUS_EXPR\n+      else if (code == POINTER_PLUS_EXPR\n \t       && acc_info->level < (min_escape_l))\n \t{\n \t  imm_use_iterator imm_iter;\n@@ -1840,10 +1923,10 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t\t  total_elements = new_offset;\n \t\t  if (new_offset != offset)\n \t\t    {\n-\t\t      bsi = bsi_for_stmt (acc_info->stmt);\n-\t\t      tmp1 = force_gimple_operand_bsi (&bsi, total_elements,\n+\t\t      gsi = gsi_for_stmt (acc_info->stmt);\n+\t\t      tmp1 = force_gimple_operand_gsi (&gsi, total_elements,\n \t\t\t\t\t\t       true, NULL,\n-\t\t\t\t\t\t       true, BSI_SAME_STMT);\n+\t\t\t\t\t\t       true, GSI_SAME_STMT);\n \t\t    }\n \t\t  else\n \t\t    tmp1 = offset;\n@@ -1856,16 +1939,16 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t\tfold_build2 (MULT_EXPR, sizetype, fold_convert (sizetype, acc_info->index),\n \t\t\t    fold_convert (sizetype, d_size));\n \t      add_referenced_var (d_size);\n-\t      bsi = bsi_for_stmt (acc_info->stmt);\n-\t      tmp1 = force_gimple_operand_bsi (&bsi, num_elements, true,\n-\t\t\t\t\t       NULL, true, BSI_SAME_STMT);\n+\t      gsi = gsi_for_stmt (acc_info->stmt);\n+\t      tmp1 = force_gimple_operand_gsi (&gsi, num_elements, true,\n+\t\t\t\t\t       NULL, true, GSI_SAME_STMT);\n \t    }\n \t  /* Replace the offset if needed.  */\n \t  if (tmp1 != offset)\n \t    {\n \t      if (TREE_CODE (offset) == SSA_NAME)\n \t\t{\n-\t\t  tree use_stmt;\n+\t\t  gimple use_stmt;\n \n \t\t  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, offset)\n \t\t    FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n@@ -1875,7 +1958,7 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t      else\n \t\t{\n \t\t  gcc_assert (TREE_CODE (offset) == INTEGER_CST);\n-\t\t  TREE_OPERAND (orig, 1) = tmp1;\n+\t\t  gimple_assign_set_rhs2 (acc_info->stmt, tmp1);\n \t\t}\n \t    }\n \t}\n@@ -1934,10 +2017,11 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n   int i;\n   struct matrix_info *mi;\n-  tree type, call_stmt_0, malloc_stmt, oldfn, prev_dim_size, use_stmt;\n+  tree type, oldfn, prev_dim_size;\n+  gimple call_stmt_0, use_stmt;\n   struct cgraph_node *c_node;\n   struct cgraph_edge *e;\n-  block_stmt_iterator bsi;\n+  gimple_stmt_iterator gsi;\n   struct malloc_call_data mcd;\n   HOST_WIDE_INT element_size;\n \n@@ -2020,17 +2104,20 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n   for (i = 1; i < mi->min_indirect_level_escape; i++)\n     {\n       tree t;\n+      check_var_data data;\n \n       /* mi->dimension_size must contain the expression of the size calculated\n          in check_allocation_function.  */\n       gcc_assert (mi->dimension_size[i]);\n \n+      data.fn = mi->allocation_function_decl;\n+      data.stmt = NULL;\n       t = walk_tree_without_duplicates (&(mi->dimension_size[i]),\n \t\t\t\t\tcheck_var_notmodified_p,\n-\t\t\t\t\tmi->allocation_function_decl);\n+\t\t\t\t\t&data);\n       if (t != NULL_TREE)\n \t{\n-\t  mark_min_matrix_escape_level (mi, i, t);\n+\t  mark_min_matrix_escape_level (mi, i, data.stmt);\n \t  break;\n \t}\n     }\n@@ -2040,7 +2127,7 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \n   /* Since we should make sure that the size expression is available\n      before the call to malloc of level 0.  */\n-  bsi = bsi_for_stmt (call_stmt_0);\n+  gsi = gsi_for_stmt (call_stmt_0);\n \n   /* Find out the size of each dimension by looking at the malloc\n      sites and create a global variable to hold it.\n@@ -2059,7 +2146,8 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \n   for (i = mi->min_indirect_level_escape - 1; i >= 0; i--)\n     {\n-      tree dim_size, dim_var, tmp;\n+      tree dim_size, dim_var;\n+      gimple stmt;\n       tree d_type_size;\n \n       /* Now put the size expression in a global variable and initialize it to\n@@ -2090,24 +2178,22 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \n \t  dim_size = fold_build2 (MULT_EXPR, type, dim_size, prev_dim_size);\n \t}\n-      dim_size = force_gimple_operand_bsi (&bsi, dim_size, true, NULL,\n-\t\t\t\t\t   true, BSI_SAME_STMT);\n+      dim_size = force_gimple_operand_gsi (&gsi, dim_size, true, NULL,\n+\t\t\t\t\t   true, GSI_SAME_STMT);\n       /* GLOBAL_HOLDING_THE_SIZE = DIM_SIZE.  */\n-      tmp = fold_build2 (GIMPLE_MODIFY_STMT, type, dim_var, dim_size);\n-      TREE_OPERAND (tmp, 0) = dim_var;\n-      mark_symbols_for_renaming (tmp);\n-      bsi_insert_before (&bsi, tmp, BSI_SAME_STMT);\n+      stmt = gimple_build_assign (dim_var, dim_size);\n+      mark_symbols_for_renaming (stmt);\n+      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n \n       prev_dim_size = mi->dimension_size[i] = dim_var;\n     }\n   update_ssa (TODO_update_ssa);\n   /* Replace the malloc size argument in the malloc of level 0 to be\n      the size of all the dimensions.  */\n-  malloc_stmt = TREE_OPERAND (call_stmt_0, 1);\n   c_node = cgraph_node (mi->allocation_function_decl);\n-  old_size_0 = CALL_EXPR_ARG (malloc_stmt, 0);\n-  tmp = force_gimple_operand_bsi (&bsi, mi->dimension_size[0], true,\n-\t\t\t\t  NULL, true, BSI_SAME_STMT);\n+  old_size_0 = gimple_call_arg (call_stmt_0, 0);\n+  tmp = force_gimple_operand_gsi (&gsi, mi->dimension_size[0], true,\n+\t\t\t\t  NULL, true, GSI_SAME_STMT);\n   if (TREE_CODE (old_size_0) == SSA_NAME)\n     {\n       FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, old_size_0)\n@@ -2122,33 +2208,31 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n      check this outside of \"cgraph.c\".  */\n   for (i = 1; i < mi->min_indirect_level_escape; i++)\n     {\n-      block_stmt_iterator bsi;\n-      tree use_stmt1 = NULL;\n-      tree call;\n+      gimple_stmt_iterator gsi;\n+      gimple use_stmt1 = NULL;\n \n-      tree call_stmt = mi->malloc_for_level[i];\n-      call = TREE_OPERAND (call_stmt, 1);\n-      gcc_assert (TREE_CODE (call) == CALL_EXPR);\n+      gimple call_stmt = mi->malloc_for_level[i];\n+      gcc_assert (is_gimple_call (call_stmt));\n       e = cgraph_edge (c_node, call_stmt);\n       gcc_assert (e);\n       cgraph_remove_edge (e);\n-      bsi = bsi_for_stmt (call_stmt);\n+      gsi = gsi_for_stmt (call_stmt);\n       /* Remove the call stmt.  */\n-      bsi_remove (&bsi, true);\n+      gsi_remove (&gsi, true);\n       /* remove the type cast stmt.  */\n       FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter,\n-\t\t\t     TREE_OPERAND (call_stmt, 0))\n+\t\t\t     gimple_call_lhs (call_stmt))\n       {\n \tuse_stmt1 = use_stmt;\n-\tbsi = bsi_for_stmt (use_stmt);\n-\tbsi_remove (&bsi, true);\n+\tgsi = gsi_for_stmt (use_stmt);\n+\tgsi_remove (&gsi, true);\n       }\n       /* Remove the assignment of the allocated area.  */\n       FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter,\n-\t\t\t     TREE_OPERAND (use_stmt1, 0))\n+\t\t\t     gimple_get_lhs (use_stmt1))\n       {\n-\tbsi = bsi_for_stmt (use_stmt);\n-\tbsi_remove (&bsi, true);\n+\tgsi = gsi_for_stmt (use_stmt);\n+\tgsi_remove (&gsi, true);\n       }\n     }\n   update_ssa (TODO_update_ssa);\n@@ -2158,24 +2242,21 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n   /* Delete the calls to free.  */\n   for (i = 1; i < mi->min_indirect_level_escape; i++)\n     {\n-      block_stmt_iterator bsi;\n-      tree call;\n+      gimple_stmt_iterator gsi;\n \n       /* ??? wonder why this case is possible but we failed on it once.  */\n       if (!mi->free_stmts[i].stmt)\n \tcontinue;\n \n-      call = TREE_OPERAND (mi->free_stmts[i].stmt, 1);\n       c_node = cgraph_node (mi->free_stmts[i].func);\n-\n-      gcc_assert (TREE_CODE (mi->free_stmts[i].stmt) == CALL_EXPR);\n+      gcc_assert (is_gimple_call (mi->free_stmts[i].stmt));\n       e = cgraph_edge (c_node, mi->free_stmts[i].stmt);\n       gcc_assert (e);\n       cgraph_remove_edge (e);\n       current_function_decl = mi->free_stmts[i].func;\n       set_cfun (DECL_STRUCT_FUNCTION (mi->free_stmts[i].func));\n-      bsi = bsi_for_stmt (mi->free_stmts[i].stmt);\n-      bsi_remove (&bsi, true);\n+      gsi = gsi_for_stmt (mi->free_stmts[i].stmt);\n+      gsi_remove (&gsi, true);\n     }\n   /* Return to the previous situation.  */\n   current_function_decl = oldfn;\n@@ -2203,13 +2284,11 @@ dump_matrix_reorg_analysis (void **slot, void *data ATTRIBUTE_UNUSED)\n   return 1;\n }\n \n-#endif\n /* Perform matrix flattening.  */\n \n static unsigned int\n matrix_reorg (void)\n {\n-#if 0 /* FIXME tuples */\n   struct cgraph_node *node;\n \n   if (profile_info)\n@@ -2316,22 +2395,14 @@ matrix_reorg (void)\n   set_cfun (NULL);\n   matrices_to_reorg = NULL;\n   return 0;\n-#else\n-  gcc_unreachable ();\n-#endif\n }\n \n \n /* The condition for matrix flattening to be performed.  */\n static bool\n gate_matrix_reorg (void)\n {\n-  /* FIXME tuples */\n-#if 0\n   return flag_ipa_matrix_reorg && flag_whole_program;\n-#else\n-  return false;\n-#endif\n }\n \n struct simple_ipa_opt_pass pass_ipa_matrix_reorg = "}]}