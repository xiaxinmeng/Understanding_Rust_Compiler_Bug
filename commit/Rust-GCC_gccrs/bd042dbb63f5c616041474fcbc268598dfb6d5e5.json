{"sha": "bd042dbb63f5c616041474fcbc268598dfb6d5e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQwNDJkYmI2M2Y1YzYxNjA0MTQ3NGZjYmMyNjg1OThkZmI2ZDVlNQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2004-10-01T02:54:39Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2004-10-01T02:54:39Z"}, "message": "builtins.c (expand_builtin_strstr, [...]): Eliminate duplicate code.\n\n\t* builtins.c (expand_builtin_strstr, expand_builtin_strchr,\n\texpand_builtin_strrchr, expand_builtin_strpbrk,\n\texpand_builtin_strncat, expand_builtin_strspn,\n\texpand_builtin_strcspn, expand_builtin_fputs): Eliminate duplicate\n\tcode.\n\nFrom-SVN: r88378", "tree": {"sha": "e28e751b95539961e02361c6b6d0b9264646e2d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e28e751b95539961e02361c6b6d0b9264646e2d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd042dbb63f5c616041474fcbc268598dfb6d5e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd042dbb63f5c616041474fcbc268598dfb6d5e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd042dbb63f5c616041474fcbc268598dfb6d5e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd042dbb63f5c616041474fcbc268598dfb6d5e5/comments", "author": null, "committer": null, "parents": [{"sha": "97804fa37c725cfc7decf621290188fc2b2e056b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97804fa37c725cfc7decf621290188fc2b2e056b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97804fa37c725cfc7decf621290188fc2b2e056b"}], "stats": {"total": 387, "additions": 51, "deletions": 336}, "files": [{"sha": "1cc8a2bd5897e06bbd410b8cde8310d2c4c367eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd042dbb63f5c616041474fcbc268598dfb6d5e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd042dbb63f5c616041474fcbc268598dfb6d5e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd042dbb63f5c616041474fcbc268598dfb6d5e5", "patch": "@@ -1,3 +1,11 @@\n+2004-09-30  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (expand_builtin_strstr, expand_builtin_strchr,\n+\texpand_builtin_strrchr, expand_builtin_strpbrk,\n+\texpand_builtin_strncat, expand_builtin_strspn,\n+\texpand_builtin_strcspn, expand_builtin_fputs): Eliminate duplicate\n+\tcode.\n+\n 2004-09-30  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390-protos.h (s390_expand_logical_operator): Add"}, {"sha": "1362c2a83c2facad99a6e2b145246e9f74c82e8d", "filename": "gcc/builtins.c", "status": "modified", "additions": 43, "deletions": 336, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd042dbb63f5c616041474fcbc268598dfb6d5e5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd042dbb63f5c616041474fcbc268598dfb6d5e5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=bd042dbb63f5c616041474fcbc268598dfb6d5e5", "patch": "@@ -2463,51 +2463,13 @@ expand_builtin_strlen (tree arglist, rtx target,\n static rtx\n expand_builtin_strstr (tree arglist, rtx target, enum machine_mode mode)\n {\n-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-    return 0;\n-  else\n+  if (validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     {\n-      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      tree fn, tmp;\n-      const char *p1, *p2;\n-\n-      p2 = c_getstr (s2);\n-      if (p2 == NULL)\n-\treturn 0;\n-\n-      p1 = c_getstr (s1);\n-      if (p1 != NULL)\n-\t{\n-\t  const char *r = strstr (p1, p2);\n-\n-\t  if (r == NULL)\n-\t    return const0_rtx;\n-\n-\t  /* Return an offset into the constant string argument.  */\n-\t  tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (s1), s1,\n-\t\t\t      fold_convert (TREE_TYPE (s1),\n-\t\t\t\t\t    ssize_int (r - p1))));\n-\t  return expand_expr (tmp, target, mode, EXPAND_NORMAL);\n-\t}\n-\n-      if (p2[0] == '\\0')\n-\treturn expand_expr (s1, target, mode, EXPAND_NORMAL);\n-\n-      if (p2[1] != '\\0')\n-\treturn 0;\n-\n-      fn = implicit_built_in_decls[BUILT_IN_STRCHR];\n-      if (!fn)\n-\treturn 0;\n-\n-      /* New argument list transforming strstr(s1, s2) to\n-\t strchr(s1, s2[0]).  */\n-      arglist = build_tree_list (NULL_TREE,\n-\t\t\t\t build_int_cst (NULL_TREE, p2[0]));\n-      arglist = tree_cons (NULL_TREE, s1, arglist);\n-      return expand_expr (build_function_call_expr (fn, arglist),\n-\t\t\t  target, mode, EXPAND_NORMAL);\n+      tree result = fold_builtin_strstr (arglist);\n+      if (result)\n+\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n+  return 0;\n }\n \n /* Expand a call to the strchr builtin.  Return 0 if we failed the\n@@ -2517,42 +2479,15 @@ expand_builtin_strstr (tree arglist, rtx target, enum machine_mode mode)\n static rtx\n expand_builtin_strchr (tree arglist, rtx target, enum machine_mode mode)\n {\n-  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    return 0;\n-  else\n+  if (validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     {\n-      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      const char *p1;\n-\n-      if (TREE_CODE (s2) != INTEGER_CST)\n-\treturn 0;\n-\n-      p1 = c_getstr (s1);\n-      if (p1 != NULL)\n-\t{\n-\t  char c;\n-\t  const char *r;\n-\t  tree tmp;\n-\n-\t  if (target_char_cast (s2, &c))\n-\t    return 0;\n-\n-\t  r = strchr (p1, c);\n-\n-\t  if (r == NULL)\n-\t    return const0_rtx;\n+      tree result = fold_builtin_strchr (arglist);\n+      if (result)\n+\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n \n-\t  /* Return an offset into the constant string argument.  */\n-\t  tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (s1), s1,\n-\t\t\t      fold_convert (TREE_TYPE (s1),\n-\t\t\t\t\t    ssize_int (r - p1))));\n-\t  return expand_expr (tmp, target, mode, EXPAND_NORMAL);\n-\t}\n-\n-      /* FIXME: Should use here strchrM optab so that ports can optimize\n-\t this.  */\n-      return 0;\n+      /* FIXME: Should use strchrM optab so that ports can optimize this.  */\n     }\n+  return 0;\n }\n \n /* Expand a call to the strrchr builtin.  Return 0 if we failed the\n@@ -2562,49 +2497,13 @@ expand_builtin_strchr (tree arglist, rtx target, enum machine_mode mode)\n static rtx\n expand_builtin_strrchr (tree arglist, rtx target, enum machine_mode mode)\n {\n-  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    return 0;\n-  else\n+  if (validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     {\n-      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      tree fn, tmp;\n-      const char *p1;\n-\n-      if (TREE_CODE (s2) != INTEGER_CST)\n-\treturn 0;\n-\n-      p1 = c_getstr (s1);\n-      if (p1 != NULL)\n-\t{\n-\t  char c;\n-\t  const char *r;\n-\n-\t  if (target_char_cast (s2, &c))\n-\t    return 0;\n-\n-\t  r = strrchr (p1, c);\n-\n-\t  if (r == NULL)\n-\t    return const0_rtx;\n-\n-\t  /* Return an offset into the constant string argument.  */\n-\t  tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (s1), s1,\n-\t\t\t      fold_convert (TREE_TYPE (s1),\n-\t\t\t\t\t    ssize_int (r - p1))));\n-\t  return expand_expr (tmp, target, mode, EXPAND_NORMAL);\n-\t}\n-\n-      if (! integer_zerop (s2))\n-\treturn 0;\n-\n-      fn = implicit_built_in_decls[BUILT_IN_STRCHR];\n-      if (!fn)\n-\treturn 0;\n-\n-      /* Transform strrchr(s1, '\\0') to strchr(s1, '\\0').  */\n-      return expand_expr (build_function_call_expr (fn, arglist),\n-\t\t\t  target, mode, EXPAND_NORMAL);\n+      tree result = fold_builtin_strrchr (arglist);\n+      if (result)\n+\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n+  return 0;\n }\n \n /* Expand a call to the strpbrk builtin.  Return 0 if we failed the\n@@ -2614,57 +2513,13 @@ expand_builtin_strrchr (tree arglist, rtx target, enum machine_mode mode)\n static rtx\n expand_builtin_strpbrk (tree arglist, rtx target, enum machine_mode mode)\n {\n-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-    return 0;\n-  else\n+  if (validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     {\n-      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      tree fn, tmp;\n-      const char *p1, *p2;\n-\n-      p2 = c_getstr (s2);\n-      if (p2 == NULL)\n-\treturn 0;\n-\n-      p1 = c_getstr (s1);\n-      if (p1 != NULL)\n-\t{\n-\t  const char *r = strpbrk (p1, p2);\n-\n-\t  if (r == NULL)\n-\t    return const0_rtx;\n-\n-\t  /* Return an offset into the constant string argument.  */\n-\t  tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (s1), s1,\n-\t\t\t      fold_convert (TREE_TYPE (s1),\n-\t\t\t\t\t    ssize_int (r - p1))));\n-\t  return expand_expr (tmp, target, mode, EXPAND_NORMAL);\n-\t}\n-\n-      if (p2[0] == '\\0')\n-\t{\n-\t  /* strpbrk(x, \"\") == NULL.\n-\t     Evaluate and ignore the arguments in case they had\n-\t     side-effects.  */\n-\t  expand_expr (s1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t  return const0_rtx;\n-\t}\n-\n-      if (p2[1] != '\\0')\n-\treturn 0;  /* Really call strpbrk.  */\n-\n-      fn = implicit_built_in_decls[BUILT_IN_STRCHR];\n-      if (!fn)\n-\treturn 0;\n-\n-      /* New argument list transforming strpbrk(s1, s2) to\n-\t strchr(s1, s2[0]).  */\n-      arglist = build_tree_list (NULL_TREE,\n-\t\t\t\t build_int_cst (NULL_TREE, p2[0]));\n-      arglist = tree_cons (NULL_TREE, s1, arglist);\n-      return expand_expr (build_function_call_expr (fn, arglist),\n-\t\t\t  target, mode, EXPAND_NORMAL);\n+      tree result = fold_builtin_strpbrk (arglist);\n+      if (result)\n+\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n+  return 0;\n }\n \n /* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)\n@@ -3982,46 +3837,14 @@ expand_builtin_strcat (tree arglist, rtx target, enum machine_mode mode)\n static rtx\n expand_builtin_strncat (tree arglist, rtx target, enum machine_mode mode)\n {\n-  if (!validate_arglist (arglist,\n-\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    return 0;\n-  else\n+  if (validate_arglist (arglist,\n+\t\t\tPOINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     {\n-      tree dst = TREE_VALUE (arglist),\n-\tsrc = TREE_VALUE (TREE_CHAIN (arglist)),\n-\tlen = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-      const char *p = c_getstr (src);\n-\n-      /* If the requested length is zero, or the src parameter string\n-          length is zero, return the dst parameter.  */\n-      if (integer_zerop (len) || (p && *p == '\\0'))\n-\t{\n-\t  /* Evaluate and ignore the src and len parameters in case\n-\t     they have side-effects.  */\n-\t  expand_expr (src, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t  expand_expr (len, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t  return expand_expr (dst, target, mode, EXPAND_NORMAL);\n-\t}\n-\n-      /* If the requested len is greater than or equal to the string\n-         length, call strcat.  */\n-      if (TREE_CODE (len) == INTEGER_CST && p\n-\t  && compare_tree_int (len, strlen (p)) >= 0)\n-\t{\n-\t  tree newarglist\n-\t    = tree_cons (NULL_TREE, dst, build_tree_list (NULL_TREE, src));\n-\t  tree fn = implicit_built_in_decls[BUILT_IN_STRCAT];\n-\n-\t  /* If the replacement _DECL isn't initialized, don't do the\n-\t     transformation.  */\n-\t  if (!fn)\n-\t    return 0;\n-\n-\t  return expand_expr (build_function_call_expr (fn, newarglist),\n-\t\t\t      target, mode, EXPAND_NORMAL);\n-\t}\n-      return 0;\n+      tree result = fold_builtin_strncat (arglist);\n+      if (result)\n+\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n+  return 0;\n }\n \n /* Expand expression EXP, which is a call to the strspn builtin.\n@@ -4031,31 +3854,13 @@ expand_builtin_strncat (tree arglist, rtx target, enum machine_mode mode)\n static rtx\n expand_builtin_strspn (tree arglist, rtx target, enum machine_mode mode)\n {\n-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-    return 0;\n-  else\n+  if (validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     {\n-      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      const char *p1 = c_getstr (s1), *p2 = c_getstr (s2);\n-\n-      /* If both arguments are constants, evaluate at compile-time.  */\n-      if (p1 && p2)\n-\t{\n-\t  const size_t r = strspn (p1, p2);\n-\t  return expand_expr (size_int (r), target, mode, EXPAND_NORMAL);\n-\t}\n-\n-      /* If either argument is \"\", return 0.  */\n-      if ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0'))\n-\t{\n-\t  /* Evaluate and ignore both arguments in case either one has\n-\t     side-effects.  */\n-\t  expand_expr (s1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t  expand_expr (s2, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t  return const0_rtx;\n-\t}\n-      return 0;\n+      tree result = fold_builtin_strspn (arglist);\n+      if (result)\n+\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n+  return 0;\n }\n \n /* Expand expression EXP, which is a call to the strcspn builtin.\n@@ -4065,45 +3870,13 @@ expand_builtin_strspn (tree arglist, rtx target, enum machine_mode mode)\n static rtx\n expand_builtin_strcspn (tree arglist, rtx target, enum machine_mode mode)\n {\n-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-    return 0;\n-  else\n+  if (validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     {\n-      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n-      const char *p1 = c_getstr (s1), *p2 = c_getstr (s2);\n-\n-      /* If both arguments are constants, evaluate at compile-time.  */\n-      if (p1 && p2)\n-\t{\n-\t  const size_t r = strcspn (p1, p2);\n-\t  return expand_expr (size_int (r), target, mode, EXPAND_NORMAL);\n-\t}\n-\n-      /* If the first argument is \"\", return 0.  */\n-      if (p1 && *p1 == '\\0')\n-\t{\n-\t  /* Evaluate and ignore argument s2 in case it has\n-\t     side-effects.  */\n-\t  expand_expr (s2, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t  return const0_rtx;\n-\t}\n-\n-      /* If the second argument is \"\", return __builtin_strlen(s1).  */\n-      if (p2 && *p2 == '\\0')\n-\t{\n-\t  tree newarglist = build_tree_list (NULL_TREE, s1),\n-\t    fn = implicit_built_in_decls[BUILT_IN_STRLEN];\n-\n-\t  /* If the replacement _DECL isn't initialized, don't do the\n-\t     transformation.  */\n-\t  if (!fn)\n-\t    return 0;\n-\n-\t  return expand_expr (build_function_call_expr (fn, newarglist),\n-\t\t\t      target, mode, EXPAND_NORMAL);\n-\t}\n-      return 0;\n+      tree result = fold_builtin_strcspn (arglist);\n+      if (result)\n+\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n+  return 0;\n }\n \n /* Expand a call to __builtin_saveregs, generating the result in TARGET,\n@@ -4678,78 +4451,15 @@ expand_builtin_unop (enum machine_mode target_mode, tree arglist, rtx target,\n static rtx\n expand_builtin_fputs (tree arglist, rtx target, bool unlocked)\n {\n-  tree len, fn;\n-  tree fn_fputc = unlocked ? implicit_built_in_decls[BUILT_IN_FPUTC_UNLOCKED]\n-    : implicit_built_in_decls[BUILT_IN_FPUTC];\n-  tree fn_fwrite = unlocked ? implicit_built_in_decls[BUILT_IN_FWRITE_UNLOCKED]\n-    : implicit_built_in_decls[BUILT_IN_FWRITE];\n-\n-  /* If the return value is used, or the replacement _DECL isn't\n-     initialized, don't do the transformation.  */\n-  if (target != const0_rtx || !fn_fputc || !fn_fwrite)\n-    return 0;\n-\n   /* Verify the arguments in the original call.  */\n-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-    return 0;\n-\n-  /* Get the length of the string passed to fputs.  If the length\n-     can't be determined, punt.  */\n-  if (!(len = c_strlen (TREE_VALUE (arglist), 1))\n-      || TREE_CODE (len) != INTEGER_CST)\n-    return 0;\n-\n-  switch (compare_tree_int (len, 1))\n+  if (validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     {\n-    case -1: /* length is 0, delete the call entirely .  */\n-      {\n-\t/* Evaluate and ignore the argument in case it has\n-           side-effects.  */\n-\texpand_expr (TREE_VALUE (TREE_CHAIN (arglist)), const0_rtx,\n-\t\t     VOIDmode, EXPAND_NORMAL);\n-\treturn const0_rtx;\n-      }\n-    case 0: /* length is 1, call fputc.  */\n-      {\n-\tconst char *p = c_getstr (TREE_VALUE (arglist));\n-\n-\tif (p != NULL)\n-\t  {\n-\t    /* New argument list transforming fputs(string, stream) to\n-\t       fputc(string[0], stream).  */\n-\t    arglist = build_tree_list (NULL_TREE,\n-\t\t\t\t       TREE_VALUE (TREE_CHAIN (arglist)));\n-\t    arglist = tree_cons (NULL_TREE,\n-\t\t\t\t build_int_cst (NULL_TREE, p[0]),\n-\t\t\t\t arglist);\n-\t    fn = fn_fputc;\n-\t    break;\n-\t  }\n-      }\n-      /* Fall through.  */\n-    case 1: /* length is greater than 1, call fwrite.  */\n-      {\n-\ttree string_arg;\n-\n-\t/* If optimizing for size keep fputs.  */\n-\tif (optimize_size)\n-\t  return 0;\n-\tstring_arg = TREE_VALUE (arglist);\n-\t/* New argument list transforming fputs(string, stream) to\n-\t   fwrite(string, 1, len, stream).  */\n-\targlist = build_tree_list (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)));\n-\targlist = tree_cons (NULL_TREE, len, arglist);\n-\targlist = tree_cons (NULL_TREE, size_one_node, arglist);\n-\targlist = tree_cons (NULL_TREE, string_arg, arglist);\n-\tfn = fn_fwrite;\n-\tbreak;\n-      }\n-    default:\n-      gcc_unreachable ();\n+      tree result = fold_builtin_fputs (arglist, (target == const0_rtx),\n+\t\t\t\t\tunlocked, NULL_TREE);\n+      if (result)\n+\treturn expand_expr (result, target, VOIDmode, EXPAND_NORMAL);\n     }\n-\n-  return expand_expr (build_function_call_expr (fn, arglist),\n-\t\t      const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  return 0;\n }\n \n /* Expand a call to __builtin_expect.  We return our argument and emit a\n@@ -8728,9 +8438,6 @@ fold_builtin_strchr (tree arglist)\n \t  return fold (build2 (PLUS_EXPR, TREE_TYPE (s1),\n \t\t\t       s1, build_int_cst (TREE_TYPE (s1), r - p1)));\n \t}\n-\n-      /* FIXME: Should use here strchrM optab so that ports can optimize\n-\t this.  */\n       return 0;\n     }\n }"}]}