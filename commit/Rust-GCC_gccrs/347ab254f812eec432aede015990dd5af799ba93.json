{"sha": "347ab254f812eec432aede015990dd5af799ba93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ3YWIyNTRmODEyZWVjNDMyYWVkZTAxNTk5MGRkNWFmNzk5YmE5Mw==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2009-04-22T10:57:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-22T10:57:10Z"}, "message": "prj.ads, [...] (Recursive_Process): Remove duplicated code.\n\n2009-04-22  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj.ads, prj.adb, prj-nmsc.adb, prj-proc.adb (Recursive_Process):\n\tRemove duplicated code.\n\t(Canonical_Case_File_Name): new subprogram\n\t(Check_And_Normalize_Unit_Names): new subprogram\n\t(Write_Attr): new subprogram\n\tBetter sharing of code\n\t(Check_Naming_Ada_Only, Check_Naming_Multi_Lang): new subprogram, to\n\tsplit Check_Naming and help find duplicated code\n\t(Check_Common): new subprogram, sharing code between ada_only and\n\tmulti_language mode.\n\t(Naming_Data.Dot_Repl_Loc): field removed\n\nFrom-SVN: r146567", "tree": {"sha": "ac9b9b389332bd8a93258c5b6e99a3bc5dff89eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac9b9b389332bd8a93258c5b6e99a3bc5dff89eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/347ab254f812eec432aede015990dd5af799ba93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/347ab254f812eec432aede015990dd5af799ba93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/347ab254f812eec432aede015990dd5af799ba93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/347ab254f812eec432aede015990dd5af799ba93/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "24a40b356f07a2a4d50d4c36e5bbb86ef06d3925", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24a40b356f07a2a4d50d4c36e5bbb86ef06d3925", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24a40b356f07a2a4d50d4c36e5bbb86ef06d3925"}], "stats": {"total": 1339, "additions": 549, "deletions": 790}, "files": [{"sha": "18cfd872bd9cb386721a6284430264412447dfb7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/347ab254f812eec432aede015990dd5af799ba93/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/347ab254f812eec432aede015990dd5af799ba93/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=347ab254f812eec432aede015990dd5af799ba93", "patch": "@@ -1,3 +1,17 @@\n+2009-04-22  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj.ads, prj.adb, prj-nmsc.adb, prj-proc.adb (Recursive_Process):\n+\tRemove duplicated code.\n+\t(Canonical_Case_File_Name): new subprogram\n+\t(Check_And_Normalize_Unit_Names): new subprogram\n+\t(Write_Attr): new subprogram\n+\tBetter sharing of code\n+\t(Check_Naming_Ada_Only, Check_Naming_Multi_Lang): new subprogram, to\n+\tsplit Check_Naming and help find duplicated code\n+\t(Check_Common): new subprogram, sharing code between ada_only and\n+\tmulti_language mode.\n+\t(Naming_Data.Dot_Repl_Loc): field removed\n+\n 2009-04-22  Emmanuel Briot  <briot@adacore.com>\n \n \t* prj-proc.adb, prj-nmsc.adb (Load_Naming_Exceptions): New subprogram."}, {"sha": "952098584e3b87a8833c354bb00412db2d43d027", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 469, "deletions": 658, "changes": 1127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/347ab254f812eec432aede015990dd5af799ba93/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/347ab254f812eec432aede015990dd5af799ba93/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=347ab254f812eec432aede015990dd5af799ba93", "patch": "@@ -250,6 +250,10 @@ package body Prj.Nmsc is\n    --  If Source_To_Replace is specified, it points to the source in the\n    --  extended project that the new file is overriding.\n \n+   function Canonical_Case_File_Name (Name : Name_Id) return File_Name_Type;\n+   --  Same as Osint.Canonical_Case_File_Name but applies to Name_Id.\n+   --  This alters Name_Buffer\n+\n    function ALI_File_Name (Source : String) return String;\n    --  Return the ALI file name corresponding to a source\n \n@@ -332,6 +336,16 @@ package body Prj.Nmsc is\n    --  Current_Dir should represent the current directory, and is passed for\n    --  efficiency to avoid system calls to recompute it.\n \n+   procedure Check_And_Normalize_Unit_Names\n+     (Project    : Project_Id;\n+      In_Tree    : Project_Tree_Ref;\n+      List       : Array_Element_Id;\n+      Debug_Name : String);\n+   --  Check that a list of unit names contains only valid names. Casing\n+   --  is normalized where appropriate.\n+   --  Debug_Name is the name representing the list, and is used for debug\n+   --  output only.\n+\n    procedure Get_Path_Names_And_Record_Ada_Sources\n      (Project     : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n@@ -510,7 +524,8 @@ package body Prj.Nmsc is\n       Current_Dir : String);\n    --  Find all the sources of project Project in project tree In_Tree and\n    --  update its Data accordingly. This assumes that Data.First_Source has\n-   --  been initialized with the list of excluded sources.\n+   --  been initialized with the list of excluded sources and special naming\n+   --  exceptions.\n    --\n    --  Current_Dir should represent the current directory, and is passed for\n    --  efficiency to avoid system calls to recompute it.\n@@ -574,6 +589,24 @@ package body Prj.Nmsc is\n    --  Check that individual naming conventions apply to immediate sources of\n    --  the project. If not, issue a warning.\n \n+   procedure Write_Attr (Name, Value : String);\n+   --  Debug print a value for a specific property. Does nothing when not in\n+   --  debug mode\n+\n+   ----------------\n+   -- Write_Attr --\n+   ----------------\n+\n+   procedure Write_Attr (Name, Value : String) is\n+   begin\n+      if Current_Verbosity = High then\n+         Write_Str  (\"  \" & Name & \" = \"\"\");\n+         Write_Str  (Value);\n+         Write_Char ('\"');\n+         Write_Eol;\n+      end if;\n+   end Write_Attr;\n+\n    ----------------\n    -- Add_Source --\n    ----------------\n@@ -718,6 +751,21 @@ package body Prj.Nmsc is\n       return Source & ALI_Suffix;\n    end ALI_File_Name;\n \n+   ------------------------------\n+   -- Canonical_Case_File_Name --\n+   ------------------------------\n+\n+   function Canonical_Case_File_Name (Name : Name_Id) return File_Name_Type is\n+   begin\n+      if Osint.File_Names_Case_Sensitive then\n+         return File_Name_Type (Name);\n+      else\n+         Get_Name_String (Name);\n+         Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n+         return Name_Find;\n+      end if;\n+   end Canonical_Case_File_Name;\n+\n    -----------\n    -- Check --\n    -----------\n@@ -1097,37 +1145,6 @@ package body Prj.Nmsc is\n                                   (Naming.Separate_Suffix);\n \n          begin\n-            --  Dot_Replacement cannot\n-\n-            --   - be empty\n-            --   - start or end with an alphanumeric\n-            --   - be a single '_'\n-            --   - start with an '_' followed by an alphanumeric\n-            --   - contain a '.' except if it is \".\"\n-\n-            if Dot_Replacement'Length = 0\n-              or else Is_Alphanumeric\n-                        (Dot_Replacement (Dot_Replacement'First))\n-              or else Is_Alphanumeric\n-                        (Dot_Replacement (Dot_Replacement'Last))\n-              or else (Dot_Replacement (Dot_Replacement'First) = '_'\n-                        and then\n-                        (Dot_Replacement'Length = 1\n-                          or else\n-                           Is_Alphanumeric\n-                             (Dot_Replacement (Dot_Replacement'First + 1))))\n-              or else (Dot_Replacement'Length > 1\n-                         and then\n-                           Index (Source => Dot_Replacement,\n-                                  Pattern => \".\") /= 0)\n-            then\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  '\"' & Dot_Replacement &\n-                  \"\"\" is illegal for Dot_Replacement.\",\n-                  Naming.Dot_Repl_Loc);\n-            end if;\n-\n             --  Suffixes cannot\n             --   - be empty\n \n@@ -2655,9 +2672,7 @@ package body Prj.Nmsc is\n          List := Interfaces.Values;\n          while List /= Nil_String loop\n             Element := In_Tree.String_Elements.Table (List);\n-            Get_Name_String (Element.Value);\n-            Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-            Name := Name_Find;\n+            Name := Canonical_Case_File_Name (Element.Value);\n \n             Project_2 := Project;\n             Data_2 := Data;\n@@ -2744,6 +2759,55 @@ package body Prj.Nmsc is\n       end if;\n    end Check_Interfaces;\n \n+   ------------------------------------\n+   -- Check_And_Normalize_Unit_Names --\n+   ------------------------------------\n+\n+   procedure Check_And_Normalize_Unit_Names\n+     (Project    : Project_Id;\n+      In_Tree    : Project_Tree_Ref;\n+      List       : Array_Element_Id;\n+      Debug_Name : String)\n+   is\n+      Current   : Array_Element_Id := List;\n+      Element   : Array_Element;\n+      Unit_Name : Name_Id;\n+   begin\n+      if Current_Verbosity = High then\n+         Write_Line (\"  Checking unit names in \" & Debug_Name);\n+      end if;\n+\n+      while Current /= No_Array_Element loop\n+         Element := In_Tree.Array_Elements.Table (Current);\n+         Element.Value.Value :=\n+           Name_Id (Canonical_Case_File_Name (Element.Value.Value));\n+\n+         --  Check that it contains a valid unit name\n+\n+         Get_Name_String (Element.Index);\n+         Check_Ada_Name (Name_Buffer (1 .. Name_Len), Unit_Name);\n+\n+         if Unit_Name = No_Name then\n+            Err_Vars.Error_Msg_Name_1 := Element.Index;\n+            Error_Msg\n+              (Project, In_Tree,\n+               \"%% is not a valid unit name.\",\n+               Element.Value.Location);\n+\n+         else\n+            if Current_Verbosity = High then\n+               Write_Str (\"    for unit: \");\n+               Write_Line (Get_Name_String (Unit_Name));\n+            end if;\n+\n+            Element.Index := Unit_Name;\n+            In_Tree.Array_Elements.Table (Current) := Element;\n+         end if;\n+\n+         Current := Element.Next;\n+      end loop;\n+   end Check_And_Normalize_Unit_Names;\n+\n    --------------------------\n    -- Check_Naming_Schemes --\n    --------------------------\n@@ -2757,65 +2821,148 @@ package body Prj.Nmsc is\n                     Util.Value_Of (Name_Naming, Data.Decl.Packages, In_Tree);\n       Naming    : Package_Element;\n \n-      procedure Check_Unit_Names (List : Array_Element_Id);\n-      --  Check that a list of unit names contains only valid names\n-\n       procedure Get_Exceptions (Kind : Source_Kind);\n       --  Comment required ???\n \n       procedure Get_Unit_Exceptions (Kind : Source_Kind);\n       --  Comment required ???\n \n-      ----------------------\n-      -- Check_Unit_Names --\n-      ----------------------\n+      procedure Check_Naming_Ada_Only;\n+      --  Does Check_Naming_Schemes processing in Ada_Only mode.\n+      --  If there is a package Naming, puts in Data.Naming the contents of\n+      --  this package.\n+\n+      procedure Check_Naming_Multi_Lang;\n+      --  Does Check_Naming_Schemes processing for Multi_Language mode.\n+\n+      procedure Check_Common\n+        (Dot_Replacement : in out File_Name_Type;\n+         Casing          : in out Casing_Type;\n+         Casing_Defined  : out Boolean;\n+         Separate_Suffix : in out File_Name_Type;\n+         Sep_Suffix_Loc  : in out Source_Ptr);\n+      --  Check attributes common to Ada_Only and Multi_Lang modes\n+\n+      ------------------\n+      -- Check_Common --\n+      ------------------\n+\n+      procedure Check_Common\n+        (Dot_Replacement : in out File_Name_Type;\n+         Casing          : in out Casing_Type;\n+         Casing_Defined  : out Boolean;\n+         Separate_Suffix : in out File_Name_Type;\n+         Sep_Suffix_Loc  : in out Source_Ptr)\n+      is\n+         Dot_Repl        : constant Variable_Value :=\n+           Util.Value_Of\n+             (Name_Dot_Replacement, Naming.Decl.Attributes, In_Tree);\n+         Casing_String : constant Variable_Value :=\n+           Util.Value_Of (Name_Casing, Naming.Decl.Attributes, In_Tree);\n+         Sep_Suffix : constant Variable_Value :=\n+           Util.Value_Of\n+             (Name_Separate_Suffix, Naming.Decl.Attributes, In_Tree);\n \n-      procedure Check_Unit_Names (List : Array_Element_Id) is\n-         Current   : Array_Element_Id;\n-         Element   : Array_Element;\n-         Unit_Name : Name_Id;\n+         Dot_Repl_Loc    : Source_Ptr;\n \n       begin\n-         --  Loop through elements of the string list\n+         if not Dot_Repl.Default then\n+            pragma Assert\n+              (Dot_Repl.Kind = Single, \"Dot_Replacement is not a string\");\n+            if Length_Of_Name (Dot_Repl.Value) = 0 then\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"Dot_Replacement cannot be empty\",\n+                  Dot_Repl.Location);\n+            end if;\n \n-         Current := List;\n-         while Current /= No_Array_Element loop\n-            Element := In_Tree.Array_Elements.Table (Current);\n+            Dot_Replacement := Canonical_Case_File_Name (Dot_Repl.Value);\n+            Dot_Repl_Loc    := Dot_Repl.Location;\n \n-            --  Put file name in canonical case\n+            declare\n+               Repl : constant String := Get_Name_String (Dot_Replacement);\n+            begin\n+               --  Dot_Replacement cannot\n+               --   - be empty\n+               --   - start or end with an alphanumeric\n+               --   - be a single '_'\n+               --   - start with an '_' followed by an alphanumeric\n+               --   - contain a '.' except if it is \".\"\n+\n+               if Repl'Length = 0\n+                 or else Is_Alphanumeric (Repl (Repl'First))\n+                 or else Is_Alphanumeric (Repl (Repl'Last))\n+                 or else (Repl (Repl'First) = '_'\n+                          and then\n+                            (Repl'Length = 1\n+                             or else Is_Alphanumeric (Repl (Repl'First + 1))))\n+                 or else (Repl'Length > 1\n+                          and then Index (Source => Repl, Pattern => \".\") /= 0)\n+               then\n+                  Error_Msg\n+                    (Project, In_Tree,\n+                     '\"' & Repl &\n+                     \"\"\" is illegal for Dot_Replacement.\",\n+                     Dot_Repl_Loc);\n+               end if;\n+            end;\n+         end if;\n \n-            if not Osint.File_Names_Case_Sensitive then\n-               Get_Name_String (Element.Value.Value);\n-               Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-               Element.Value.Value := Name_Find;\n-            end if;\n+         Write_Attr\n+           (\"Dot_Replacement\", Get_Name_String (Dot_Replacement));\n \n-            --  Check that it contains a valid unit name\n+         Casing_Defined := False;\n \n-            Get_Name_String (Element.Index);\n-            Check_Ada_Name (Name_Buffer (1 .. Name_Len), Unit_Name);\n+         if not Casing_String.Default then\n+            pragma Assert\n+              (Casing_String.Kind = Single, \"Casing is not a string\");\n \n-            if Unit_Name = No_Name then\n-               Err_Vars.Error_Msg_Name_1 := Element.Index;\n+            declare\n+               Casing_Image : constant String :=\n+                 Get_Name_String (Casing_String.Value);\n+            begin\n+               if Casing_Image'Length = 0 then\n+                  Error_Msg\n+                    (Project, In_Tree,\n+                     \"Casing cannot be an empty string\",\n+                     Casing_String.Location);\n+               end if;\n+\n+               Casing := Value (Casing_Image);\n+               Casing_Defined := True;\n+\n+            exception\n+               when Constraint_Error =>\n+                  Name_Len := Casing_Image'Length;\n+                  Name_Buffer (1 .. Name_Len) := Casing_Image;\n+                  Err_Vars.Error_Msg_Name_1 := Name_Find;\n+                  Error_Msg\n+                    (Project, In_Tree,\n+                     \"%% is not a correct Casing\",\n+                     Casing_String.Location);\n+            end;\n+         end if;\n+\n+         Write_Attr (\"Casing\", Image (Casing));\n+\n+         if not Sep_Suffix.Default then\n+            if Length_Of_Name (Sep_Suffix.Value) = 0 then\n                Error_Msg\n                  (Project, In_Tree,\n-                  \"%% is not a valid unit name.\",\n-                  Element.Value.Location);\n+                  \"Separate_Suffix cannot be empty\",\n+                  Sep_Suffix.Location);\n \n             else\n-               if Current_Verbosity = High then\n-                  Write_Str (\"    Unit (\"\"\");\n-                  Write_Str (Get_Name_String (Unit_Name));\n-                  Write_Line (\"\"\")\");\n-               end if;\n-\n-               Element.Index := Unit_Name;\n-               In_Tree.Array_Elements.Table (Current) := Element;\n+               Separate_Suffix := Canonical_Case_File_Name (Sep_Suffix.Value);\n+               Sep_Suffix_Loc  := Sep_Suffix.Location;\n             end if;\n+         end if;\n \n-            Current := Element.Next;\n-         end loop;\n-      end Check_Unit_Names;\n+         if Separate_Suffix /= No_File then\n+            Write_Attr\n+              (\"Separate_Suffix\", Get_Name_String (Separate_Suffix));\n+         end if;\n+      end Check_Common;\n \n       --------------------\n       -- Get_Exceptions --\n@@ -2866,14 +3013,7 @@ package body Prj.Nmsc is\n                   Element_Id := Exception_List.Values;\n                   while Element_Id /= Nil_String loop\n                      Element := In_Tree.String_Elements.Table (Element_Id);\n-\n-                     if Osint.File_Names_Case_Sensitive then\n-                        File_Name := File_Name_Type (Element.Value);\n-                     else\n-                        Get_Name_String (Element.Value);\n-                        Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                        File_Name := Name_Find;\n-                     end if;\n+                     File_Name := Canonical_Case_File_Name (Element.Value);\n \n                      Source := Data.First_Source;\n                      while Source /= No_Source\n@@ -2995,14 +3135,7 @@ package body Prj.Nmsc is\n \n          while Exceptions /= No_Array_Element loop\n             Element := In_Tree.Array_Elements.Table (Exceptions);\n-\n-            if Osint.File_Names_Case_Sensitive then\n-               File_Name := File_Name_Type (Element.Value.Value);\n-            else\n-               Get_Name_String (Element.Value.Value);\n-               Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-               File_Name := Name_Find;\n-            end if;\n+            File_Name := Canonical_Case_File_Name (Element.Value.Value);\n \n             Get_Name_String (Element.Index);\n             To_Lower (Name_Buffer (1 .. Name_Len));\n@@ -3101,524 +3234,255 @@ package body Prj.Nmsc is\n \n             Exceptions := Element.Next;\n          end loop;\n-\n       end Get_Unit_Exceptions;\n \n-   --  Start of processing for Check_Naming_Schemes\n-\n-   begin\n-      if Get_Mode = Ada_Only then\n-\n-         --  If there is a package Naming, we will put in Data.Naming what is\n-         --  in this package Naming.\n-\n-         if Naming_Id /= No_Package then\n-            Naming := In_Tree.Packages.Table (Naming_Id);\n-\n-            if Current_Verbosity = High then\n-               Write_Line (\"Checking \"\"Naming\"\" for Ada.\");\n-            end if;\n-\n-            declare\n-               Bodies : constant Array_Element_Id :=\n-                          Util.Value_Of\n-                            (Name_Body, Naming.Decl.Arrays, In_Tree);\n-\n-               Specs  : constant Array_Element_Id :=\n-                          Util.Value_Of\n-                            (Name_Spec, Naming.Decl.Arrays, In_Tree);\n-\n-            begin\n-               if Bodies /= No_Array_Element then\n-\n-                  --  We have elements in the array Body_Part\n-\n-                  if Current_Verbosity = High then\n-                     Write_Line (\"Found Bodies.\");\n-                  end if;\n-\n-                  Data.Naming.Bodies := Bodies;\n-                  Check_Unit_Names (Bodies);\n-\n-               else\n-                  if Current_Verbosity = High then\n-                     Write_Line (\"No Bodies.\");\n-                  end if;\n-               end if;\n-\n-               if Specs /= No_Array_Element then\n-\n-                  --  We have elements in the array Specs\n-\n-                  if Current_Verbosity = High then\n-                     Write_Line (\"Found Specs.\");\n-                  end if;\n-\n-                  Data.Naming.Specs := Specs;\n-                  Check_Unit_Names (Specs);\n-\n-               else\n-                  if Current_Verbosity = High then\n-                     Write_Line (\"No Specs.\");\n-                  end if;\n-               end if;\n-            end;\n-\n-            --  We are now checking if variables Dot_Replacement, Casing,\n-            --  Spec_Suffix, Body_Suffix and/or Separate_Suffix exist.\n-\n-            --  For each variable, if it does not exist, we do nothing,\n-            --  because we already have the default.\n-\n-            --  Check Dot_Replacement\n-\n-            declare\n-               Dot_Replacement : constant Variable_Value :=\n-                                   Util.Value_Of\n-                                     (Name_Dot_Replacement,\n-                                      Naming.Decl.Attributes, In_Tree);\n-\n-            begin\n-               pragma Assert (Dot_Replacement.Kind = Single,\n-                              \"Dot_Replacement is not a single string\");\n-\n-               if not Dot_Replacement.Default then\n-                  Get_Name_String (Dot_Replacement.Value);\n-\n-                  if Name_Len = 0 then\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"Dot_Replacement cannot be empty\",\n-                        Dot_Replacement.Location);\n-\n-                  else\n-                     if Osint.File_Names_Case_Sensitive then\n-                        Data.Naming.Dot_Replacement :=\n-                          File_Name_Type (Dot_Replacement.Value);\n-                     else\n-                        Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                        Data.Naming.Dot_Replacement := Name_Find;\n-                     end if;\n-                     Data.Naming.Dot_Repl_Loc := Dot_Replacement.Location;\n-                  end if;\n-               end if;\n-            end;\n-\n-            if Current_Verbosity = High then\n-               Write_Str  (\"  Dot_Replacement = \"\"\");\n-               Write_Str  (Get_Name_String (Data.Naming.Dot_Replacement));\n-               Write_Char ('\"');\n-               Write_Eol;\n-            end if;\n-\n-            --  Check Casing\n-\n-            declare\n-               Casing_String : constant Variable_Value :=\n-                                 Util.Value_Of\n-                                   (Name_Casing,\n-                                    Naming.Decl.Attributes,\n-                                    In_Tree);\n-\n-            begin\n-               pragma Assert (Casing_String.Kind = Single,\n-                              \"Casing is not a single string\");\n-\n-               if not Casing_String.Default then\n-                  declare\n-                     Casing_Image : constant String :=\n-                                      Get_Name_String (Casing_String.Value);\n-                  begin\n-                     declare\n-                        Casing_Value : constant Casing_Type :=\n-                                         Value (Casing_Image);\n-                     begin\n-                        Data.Naming.Casing := Casing_Value;\n-                     end;\n-\n-                  exception\n-                     when Constraint_Error =>\n-                        if Casing_Image'Length = 0 then\n-                           Error_Msg\n-                             (Project, In_Tree,\n-                              \"Casing cannot be an empty string\",\n-                              Casing_String.Location);\n-\n-                        else\n-                           Name_Len := Casing_Image'Length;\n-                           Name_Buffer (1 .. Name_Len) := Casing_Image;\n-                           Err_Vars.Error_Msg_Name_1 := Name_Find;\n-                           Error_Msg\n-                             (Project, In_Tree,\n-                              \"%% is not a correct Casing\",\n-                              Casing_String.Location);\n-                        end if;\n-                  end;\n-               end if;\n-            end;\n-\n-            if Current_Verbosity = High then\n-               Write_Str  (\"  Casing = \");\n-               Write_Str  (Image (Data.Naming.Casing));\n-               Write_Char ('.');\n-               Write_Eol;\n-            end if;\n-\n-            --  Check Spec_Suffix\n-\n-            declare\n-               Ada_Spec_Suffix : constant Variable_Value :=\n-                                   Prj.Util.Value_Of\n-                                     (Index     => Name_Ada,\n-                                      Src_Index => 0,\n-                                      In_Array  => Data.Naming.Spec_Suffix,\n-                                      In_Tree   => In_Tree);\n-\n-            begin\n-               if Ada_Spec_Suffix.Kind = Single\n-                 and then Get_Name_String (Ada_Spec_Suffix.Value) /= \"\"\n-               then\n-                  Get_Name_String (Ada_Spec_Suffix.Value);\n-                  Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                  Set_Spec_Suffix (In_Tree, \"ada\", Data.Naming, Name_Find);\n-                  Data.Naming.Ada_Spec_Suffix_Loc := Ada_Spec_Suffix.Location;\n-\n-               else\n-                  Set_Spec_Suffix\n-                    (In_Tree,\n-                     \"ada\",\n-                     Data.Naming,\n-                     Default_Ada_Spec_Suffix);\n-               end if;\n-            end;\n-\n-            if Current_Verbosity = High then\n-               Write_Str  (\"  Spec_Suffix = \"\"\");\n-               Write_Str  (Spec_Suffix_Of (In_Tree, \"ada\", Data.Naming));\n-               Write_Char ('\"');\n-               Write_Eol;\n-            end if;\n-\n-            --  Check Body_Suffix\n-\n-            declare\n-               Ada_Body_Suffix : constant Variable_Value :=\n-                                   Prj.Util.Value_Of\n-                                     (Index     => Name_Ada,\n-                                      Src_Index => 0,\n-                                      In_Array  => Data.Naming.Body_Suffix,\n-                                      In_Tree   => In_Tree);\n-\n-            begin\n-               if Ada_Body_Suffix.Kind = Single\n-                 and then Get_Name_String (Ada_Body_Suffix.Value) /= \"\"\n-               then\n-                  Get_Name_String (Ada_Body_Suffix.Value);\n-                  Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                  Set_Body_Suffix (In_Tree, \"ada\", Data.Naming, Name_Find);\n-                  Data.Naming.Ada_Body_Suffix_Loc := Ada_Body_Suffix.Location;\n-\n-               else\n-                  Set_Body_Suffix\n-                    (In_Tree,\n-                     \"ada\",\n-                     Data.Naming,\n-                     Default_Ada_Body_Suffix);\n-               end if;\n-            end;\n-\n-            if Current_Verbosity = High then\n-               Write_Str  (\"  Body_Suffix = \"\"\");\n-               Write_Str  (Body_Suffix_Of (In_Tree, \"ada\", Data.Naming));\n-               Write_Char ('\"');\n-               Write_Eol;\n-            end if;\n-\n-            --  Check Separate_Suffix\n-\n-            declare\n-               Ada_Sep_Suffix : constant Variable_Value :=\n-                                  Prj.Util.Value_Of\n-                                    (Variable_Name => Name_Separate_Suffix,\n-                                     In_Variables  => Naming.Decl.Attributes,\n-                                     In_Tree       => In_Tree);\n-\n-            begin\n-               if Ada_Sep_Suffix.Default then\n-                  Data.Naming.Separate_Suffix :=\n-                    Body_Suffix_Id_Of (In_Tree, Name_Ada, Data.Naming);\n-\n-               else\n-                  Get_Name_String (Ada_Sep_Suffix.Value);\n-\n-                  if Name_Len = 0 then\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"Separate_Suffix cannot be empty\",\n-                        Ada_Sep_Suffix.Location);\n+      ---------------------------\n+      -- Check_Naming_Ada_Only --\n+      ---------------------------\n \n-                  else\n-                     Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                     Data.Naming.Separate_Suffix := Name_Find;\n-                     Data.Naming.Sep_Suffix_Loc  := Ada_Sep_Suffix.Location;\n-                  end if;\n-               end if;\n-            end;\n+      procedure Check_Naming_Ada_Only is\n+         Casing_Defined : Boolean;\n+      begin\n+         Data.Naming.Bodies :=\n+           Util.Value_Of (Name_Body, Naming.Decl.Arrays, In_Tree);\n \n-            if Current_Verbosity = High then\n-               Write_Str  (\"  Separate_Suffix = \"\"\");\n-               Write_Str  (Get_Name_String (Data.Naming.Separate_Suffix));\n-               Write_Char ('\"');\n-               Write_Eol;\n-            end if;\n+         if Data.Naming.Bodies /= No_Array_Element then\n+            Check_And_Normalize_Unit_Names\n+              (Project, In_Tree, Data.Naming.Bodies, \"Naming.Bodies\");\n+         end if;\n \n-            --  Check if Data.Naming is valid\n+         Data.Naming.Specs :=\n+           Util.Value_Of (Name_Spec, Naming.Decl.Arrays, In_Tree);\n \n-            Check_Ada_Naming_Scheme_Validity (Project, In_Tree, Data.Naming);\n+         if Data.Naming.Specs /= No_Array_Element then\n+            Check_And_Normalize_Unit_Names\n+              (Project, In_Tree, Data.Naming.Specs, \"Naming.Specs\");\n          end if;\n \n-      elsif not In_Configuration then\n+         --  Check Spec_Suffix\n \n-         --  Look into package Naming, if there is one\n+         declare\n+            Ada_Spec_Suffix : constant Variable_Value :=\n+              Prj.Util.Value_Of\n+                (Index     => Name_Ada,\n+                 Src_Index => 0,\n+                 In_Array  => Data.Naming.Spec_Suffix,\n+                 In_Tree   => In_Tree);\n \n-         if Naming_Id /= No_Package then\n-            Naming := In_Tree.Packages.Table (Naming_Id);\n+         begin\n+            if Ada_Spec_Suffix.Kind = Single\n+              and then Get_Name_String (Ada_Spec_Suffix.Value) /= \"\"\n+            then\n+               Set_Spec_Suffix\n+                 (In_Tree, \"ada\", Data.Naming,\n+                  Canonical_Case_File_Name (Ada_Spec_Suffix.Value));\n+               Data.Naming.Ada_Spec_Suffix_Loc := Ada_Spec_Suffix.Location;\n \n-            if Current_Verbosity = High then\n-               Write_Line (\"Checking package Naming.\");\n+            else\n+               Set_Spec_Suffix\n+                 (In_Tree, \"ada\", Data.Naming, Default_Ada_Spec_Suffix);\n             end if;\n \n-            --  We are now checking if attribute Dot_Replacement, Casing,\n-            --  and/or Separate_Suffix exist.\n+            Write_Attr\n+              (\"Spec_Suffix\", Spec_Suffix_Of (In_Tree, \"ada\", Data.Naming));\n+         end;\n \n-            --  For each attribute, if it does not exist, we do nothing,\n-            --  because we already have the default.\n-            --  Otherwise, for all unit-based languages, we put the declared\n-            --  value in the language config.\n+         --  Check Body_Suffix\n \n-            declare\n-               Dot_Repl        : constant Variable_Value :=\n-                                   Util.Value_Of\n-                                     (Name_Dot_Replacement,\n-                                      Naming.Decl.Attributes, In_Tree);\n-               Dot_Replacement : File_Name_Type := No_File;\n+         declare\n+            Ada_Body_Suffix : constant Variable_Value :=\n+              Prj.Util.Value_Of\n+                (Index     => Name_Ada,\n+                 Src_Index => 0,\n+                 In_Array  => Data.Naming.Body_Suffix,\n+                 In_Tree   => In_Tree);\n \n-               Casing_String : constant Variable_Value :=\n-                                 Util.Value_Of\n-                                   (Name_Casing,\n-                                    Naming.Decl.Attributes,\n-                                    In_Tree);\n+         begin\n+            if Ada_Body_Suffix.Kind = Single\n+              and then Get_Name_String (Ada_Body_Suffix.Value) /= \"\"\n+            then\n+               Data.Naming.Separate_Suffix :=\n+                 Canonical_Case_File_Name (Ada_Body_Suffix.Value);\n+               Set_Body_Suffix\n+                 (In_Tree, \"ada\", Data.Naming, Data.Naming.Separate_Suffix);\n+               Data.Naming.Ada_Body_Suffix_Loc := Ada_Body_Suffix.Location;\n \n-               Casing : Casing_Type := All_Lower_Case;\n-               --  Casing type (junk initialization to stop bad gcc warning)\n+            else\n+               Data.Naming.Separate_Suffix := Default_Ada_Body_Suffix;\n+               Set_Body_Suffix\n+                 (In_Tree, \"ada\", Data.Naming, Default_Ada_Body_Suffix);\n+            end if;\n \n-               Casing_Defined : Boolean := False;\n+            Write_Attr\n+              (\"Body_Suffix\", Body_Suffix_Of (In_Tree, \"ada\", Data.Naming));\n+         end;\n \n-               Sep_Suffix : constant Variable_Value :=\n-                              Prj.Util.Value_Of\n-                                (Variable_Name => Name_Separate_Suffix,\n-                                 In_Variables  => Naming.Decl.Attributes,\n-                                 In_Tree       => In_Tree);\n+         Check_Common\n+           (Dot_Replacement => Data.Naming.Dot_Replacement,\n+            Casing          => Data.Naming.Casing,\n+            Casing_Defined  => Casing_Defined,\n+            Separate_Suffix => Data.Naming.Separate_Suffix,\n+            Sep_Suffix_Loc  => Data.Naming.Sep_Suffix_Loc);\n \n-               Separate_Suffix : File_Name_Type := No_File;\n-               Lang_Id         : Language_Index;\n+         Check_Ada_Naming_Scheme_Validity (Project, In_Tree, Data.Naming);\n+      end Check_Naming_Ada_Only;\n \n-            begin\n-               --  Check attribute Dot_Replacement\n+      -----------------------------\n+      -- Check_Naming_Multi_Lang --\n+      -----------------------------\n \n-               if not Dot_Repl.Default then\n-                  Get_Name_String (Dot_Repl.Value);\n+      procedure Check_Naming_Multi_Lang is\n+      begin\n+         --  We are now checking if attribute Dot_Replacement, Casing,\n+         --  and/or Separate_Suffix exist.\n \n-                  if Name_Len = 0 then\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"Dot_Replacement cannot be empty\",\n-                        Dot_Repl.Location);\n+         --  For each attribute, if it does not exist, we do nothing,\n+         --  because we already have the default.\n+         --  Otherwise, for all unit-based languages, we put the declared\n+         --  value in the language config.\n \n-                  else\n-                     Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                     Dot_Replacement := Name_Find;\n+         declare\n+            Dot_Replacement : File_Name_Type := No_File;\n+            Separate_Suffix : File_Name_Type := No_File;\n+            Sep_Suffix_Loc  : Source_Ptr     := No_Location;\n+            Casing          : Casing_Type    := All_Lower_Case;\n+            Casing_Defined  : Boolean;\n+            Lang_Id         : Language_Index;\n \n-                     if Current_Verbosity = High then\n-                        Write_Str  (\"  Dot_Replacement = \"\"\");\n-                        Write_Str  (Get_Name_String (Dot_Replacement));\n-                        Write_Char ('\"');\n-                        Write_Eol;\n+         begin\n+            Check_Common\n+              (Dot_Replacement => Dot_Replacement,\n+               Casing          => Casing,\n+               Casing_Defined  => Casing_Defined,\n+               Separate_Suffix => Separate_Suffix,\n+               Sep_Suffix_Loc  => Sep_Suffix_Loc);\n+\n+            --  For all unit based languages, if any, set the specified\n+            --  value of Dot_Replacement, Casing and/or Separate_Suffix. Do not\n+            --  systematically overwrite, since the defaults come from the\n+            --  configuration file\n+\n+            if Dot_Replacement /= No_File\n+              or else Casing_Defined\n+              or else Separate_Suffix /= No_File\n+            then\n+               Lang_Id := Data.First_Language_Processing;\n+               while Lang_Id /= No_Language_Index loop\n+                  if In_Tree.Languages_Data.Table\n+                    (Lang_Id).Config.Kind = Unit_Based\n+                  then\n+                     if Dot_Replacement /= No_File then\n+                        In_Tree.Languages_Data.Table\n+                          (Lang_Id).Config.Naming_Data.Dot_Replacement :=\n+                          Dot_Replacement;\n                      end if;\n-                  end if;\n-               end if;\n-\n-               --  Check attribute Casing\n-\n-               if not Casing_String.Default then\n-                  declare\n-                     Casing_Image : constant String :=\n-                                      Get_Name_String (Casing_String.Value);\n-                  begin\n-                     declare\n-                        Casing_Value : constant Casing_Type :=\n-                                         Value (Casing_Image);\n-                     begin\n-                        Casing := Casing_Value;\n-                        Casing_Defined := True;\n-\n-                        if Current_Verbosity = High then\n-                           Write_Str  (\"  Casing = \");\n-                           Write_Str  (Image (Casing));\n-                           Write_Char ('.');\n-                           Write_Eol;\n-                        end if;\n-                     end;\n \n-                  exception\n-                     when Constraint_Error =>\n-                        if Casing_Image'Length = 0 then\n-                           Error_Msg\n-                             (Project, In_Tree,\n-                              \"Casing cannot be an empty string\",\n-                              Casing_String.Location);\n-\n-                        else\n-                           Name_Len := Casing_Image'Length;\n-                           Name_Buffer (1 .. Name_Len) := Casing_Image;\n-                           Err_Vars.Error_Msg_Name_1 := Name_Find;\n-                           Error_Msg\n-                             (Project, In_Tree,\n-                              \"%% is not a correct Casing\",\n-                              Casing_String.Location);\n-                        end if;\n-                  end;\n-               end if;\n-\n-               if not Sep_Suffix.Default then\n-                  Get_Name_String (Sep_Suffix.Value);\n-\n-                  if Name_Len = 0 then\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"Separate_Suffix cannot be empty\",\n-                        Sep_Suffix.Location);\n-\n-                  else\n-                     Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                     Separate_Suffix := Name_Find;\n+                     if Casing_Defined then\n+                        In_Tree.Languages_Data.Table\n+                          (Lang_Id).Config.Naming_Data.Casing := Casing;\n+                     end if;\n \n-                     if Current_Verbosity = High then\n-                        Write_Str (\"  Separate_Suffix = \"\"\");\n-                        Write_Str (Get_Name_String (Separate_Suffix));\n-                        Write_Char ('\"');\n-                        Write_Eol;\n+                     if Separate_Suffix /= No_File then\n+                        In_Tree.Languages_Data.Table\n+                          (Lang_Id).Config.Naming_Data.Separate_Suffix :=\n+                          Separate_Suffix;\n                      end if;\n                   end if;\n-               end if;\n-\n-               --  For all unit based languages, if any, set the specified\n-               --  value of Dot_Replacement, Casing and/or Separate_Suffix.\n \n-               if Dot_Replacement /= No_File\n-                 or else Casing_Defined\n-                 or else Separate_Suffix /= No_File\n-               then\n-                  Lang_Id := Data.First_Language_Processing;\n-                  while Lang_Id /= No_Language_Index loop\n-                     if In_Tree.Languages_Data.Table\n-                       (Lang_Id).Config.Kind = Unit_Based\n-                     then\n-                        if Dot_Replacement /= No_File then\n-                           In_Tree.Languages_Data.Table\n-                             (Lang_Id).Config.Naming_Data.Dot_Replacement :=\n-                             Dot_Replacement;\n-                        end if;\n-\n-                        if Casing_Defined then\n-                           In_Tree.Languages_Data.Table\n-                             (Lang_Id).Config.Naming_Data.Casing := Casing;\n-                        end if;\n-\n-                        if Separate_Suffix /= No_File then\n-                           In_Tree.Languages_Data.Table\n-                             (Lang_Id).Config.Naming_Data.Separate_Suffix :=\n-                               Separate_Suffix;\n-                        end if;\n-                     end if;\n+                  Lang_Id :=\n+                    In_Tree.Languages_Data.Table (Lang_Id).Next;\n+               end loop;\n+            end if;\n+         end;\n \n-                     Lang_Id :=\n-                       In_Tree.Languages_Data.Table (Lang_Id).Next;\n-                  end loop;\n-               end if;\n-            end;\n+         --  Next, get the spec and body suffixes\n \n-            --  Next, get the spec and body suffixes\n+         declare\n+            Suffix  : Variable_Value;\n+            Lang_Id : Language_Index;\n+            Lang    : Name_Id;\n \n-            declare\n-               Suffix  : Variable_Value;\n-               Lang_Id : Language_Index;\n-               Lang    : Name_Id;\n+         begin\n+            Lang_Id := Data.First_Language_Processing;\n+            while Lang_Id /= No_Language_Index loop\n+               Lang := In_Tree.Languages_Data.Table (Lang_Id).Name;\n \n-            begin\n-               Lang_Id := Data.First_Language_Processing;\n-               while Lang_Id /= No_Language_Index loop\n-                  Lang := In_Tree.Languages_Data.Table (Lang_Id).Name;\n+               --  Spec_Suffix\n \n-                  --  Spec_Suffix\n+               Suffix := Value_Of\n+                 (Name                    => Lang,\n+                  Attribute_Or_Array_Name => Name_Spec_Suffix,\n+                  In_Package              => Naming_Id,\n+                  In_Tree                 => In_Tree);\n \n+               if Suffix = Nil_Variable_Value then\n                   Suffix := Value_Of\n                     (Name                    => Lang,\n-                     Attribute_Or_Array_Name => Name_Spec_Suffix,\n+                     Attribute_Or_Array_Name => Name_Specification_Suffix,\n                      In_Package              => Naming_Id,\n                      In_Tree                 => In_Tree);\n+               end if;\n \n-                  if Suffix = Nil_Variable_Value then\n-                     Suffix := Value_Of\n-                       (Name                    => Lang,\n-                        Attribute_Or_Array_Name => Name_Specification_Suffix,\n-                        In_Package              => Naming_Id,\n-                        In_Tree                 => In_Tree);\n-                  end if;\n+               if Suffix /= Nil_Variable_Value then\n+                  In_Tree.Languages_Data.Table (Lang_Id).\n+                    Config.Naming_Data.Spec_Suffix :=\n+                      File_Name_Type (Suffix.Value);\n+               end if;\n \n-                  if Suffix /= Nil_Variable_Value then\n-                     In_Tree.Languages_Data.Table (Lang_Id).\n-                       Config.Naming_Data.Spec_Suffix :=\n-                         File_Name_Type (Suffix.Value);\n-                  end if;\n+               --  Body_Suffix\n \n-                  --  Body_Suffix\n+               Suffix := Value_Of\n+                 (Name                    => Lang,\n+                  Attribute_Or_Array_Name => Name_Body_Suffix,\n+                  In_Package              => Naming_Id,\n+                  In_Tree                 => In_Tree);\n \n+               if Suffix = Nil_Variable_Value then\n                   Suffix := Value_Of\n                     (Name                    => Lang,\n-                     Attribute_Or_Array_Name => Name_Body_Suffix,\n+                     Attribute_Or_Array_Name => Name_Implementation_Suffix,\n                      In_Package              => Naming_Id,\n                      In_Tree                 => In_Tree);\n+               end if;\n \n-                  if Suffix = Nil_Variable_Value then\n-                     Suffix := Value_Of\n-                       (Name                    => Lang,\n-                        Attribute_Or_Array_Name => Name_Implementation_Suffix,\n-                        In_Package              => Naming_Id,\n-                        In_Tree                 => In_Tree);\n-                  end if;\n+               if Suffix /= Nil_Variable_Value then\n+                  In_Tree.Languages_Data.Table (Lang_Id).\n+                    Config.Naming_Data.Body_Suffix :=\n+                      File_Name_Type (Suffix.Value);\n+               end if;\n \n-                  if Suffix /= Nil_Variable_Value then\n-                     In_Tree.Languages_Data.Table (Lang_Id).\n-                       Config.Naming_Data.Body_Suffix :=\n-                         File_Name_Type (Suffix.Value);\n-                  end if;\n+               Lang_Id := In_Tree.Languages_Data.Table (Lang_Id).Next;\n+            end loop;\n+         end;\n \n-                  Lang_Id := In_Tree.Languages_Data.Table (Lang_Id).Next;\n-               end loop;\n-            end;\n+         --  Get the exceptions for file based languages\n+\n+         Get_Exceptions (Spec);\n+         Get_Exceptions (Impl);\n \n-            --  Get the exceptions for file based languages\n+         --  Get the exceptions for unit based languages\n \n-            Get_Exceptions (Spec);\n-            Get_Exceptions (Impl);\n+         Get_Unit_Exceptions (Spec);\n+         Get_Unit_Exceptions (Impl);\n+      end Check_Naming_Multi_Lang;\n \n-            --  Get the exceptions for unit based languages\n+   --  Start of processing for Check_Naming_Schemes\n \n-            Get_Unit_Exceptions (Spec);\n-            Get_Unit_Exceptions (Impl);\n+   begin\n+      --  No Naming package or parsing a configuration file ? nothing to do\n+      if Naming_Id /= No_Package and not In_Configuration then\n+         Naming := In_Tree.Packages.Table (Naming_Id);\n \n+         if Current_Verbosity = High then\n+            Write_Line (\"Checking package Naming.\");\n          end if;\n+\n+         case Get_Mode is\n+            when Ada_Only =>\n+               Check_Naming_Ada_Only;\n+            when Multi_Language =>\n+               Check_Naming_Multi_Lang;\n+         end case;\n       end if;\n    end Check_Naming_Schemes;\n \n@@ -3819,9 +3683,7 @@ package body Prj.Nmsc is\n \n       if Data.Library_Name /= No_Name then\n          if Current_Verbosity = High then\n-            Write_Str (\"Library name = \"\"\");\n-            Write_Str (Get_Name_String (Data.Library_Name));\n-            Write_Line (\"\"\"\");\n+            Write_Attr (\"Library name\", Get_Name_String (Data.Library_Name));\n          end if;\n \n          pragma Assert (Lib_Dir.Kind = Single);\n@@ -3969,10 +3831,9 @@ package body Prj.Nmsc is\n \n                      --  Display the Library directory in high verbosity\n \n-                     Write_Str (\"Library directory =\"\"\");\n-                     Write_Str\n-                       (Get_Name_String (Data.Library_Dir.Display_Name));\n-                     Write_Line (\"\"\"\");\n+                     Write_Attr\n+                       (\"Library directory\",\n+                        Get_Name_String (Data.Library_Dir.Display_Name));\n                   end if;\n                end;\n             end if;\n@@ -4185,11 +4046,10 @@ package body Prj.Nmsc is\n                            --  Display the Library ALI directory in high\n                            --  verbosity.\n \n-                           Write_Str (\"Library ALI directory =\"\"\");\n-                           Write_Str\n-                             (Get_Name_String\n+                           Write_Attr\n+                             (\"Library ALI dir\",\n+                              Get_Name_String\n                                 (Data.Library_ALI_Dir.Display_Name));\n-                           Write_Line (\"\"\"\");\n                         end if;\n                      end;\n                   end if;\n@@ -4242,8 +4102,7 @@ package body Prj.Nmsc is\n                   end if;\n \n                   if Current_Verbosity = High and then OK then\n-                     Write_Str (\"Library kind = \");\n-                     Write_Line (Kind_Name);\n+                     Write_Attr (\"Library kind\", Kind_Name);\n                   end if;\n \n                   if Data.Library_Kind /= Static then\n@@ -5351,9 +5210,9 @@ package body Prj.Nmsc is\n                   if Data.Library_Src_Dir /= No_Path_Information\n                     and then Current_Verbosity = High\n                   then\n-                     Write_Str (\"Directory to copy interfaces =\"\"\");\n-                     Write_Str (Get_Name_String (Data.Library_Src_Dir.Name));\n-                     Write_Line (\"\"\"\");\n+                     Write_Attr\n+                       (\"Directory to copy interfaces\",\n+                        Get_Name_String (Data.Library_Src_Dir.Name));\n                   end if;\n                end if;\n             end;\n@@ -5766,8 +5625,7 @@ package body Prj.Nmsc is\n \n                begin\n                   if Current_Verbosity = High then\n-                     Write_Str (\"Source_Dir = \");\n-                     Write_Line (Source_Directory);\n+                     Write_Attr (\"Source_Dir\", Source_Directory);\n                   end if;\n \n                   --  We look at every entry in the source directory\n@@ -5957,14 +5815,8 @@ package body Prj.Nmsc is\n             Name_Buffer (1 .. Name_Len) :=\n               The_Path (The_Path'First .. The_Path_Last);\n             Non_Canonical_Path := Name_Find;\n-\n-            if Osint.File_Names_Case_Sensitive then\n-               Canonical_Path := Non_Canonical_Path;\n-            else\n-               Get_Name_String (Non_Canonical_Path);\n-               Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-               Canonical_Path := Name_Find;\n-            end if;\n+            Canonical_Path :=\n+              Name_Id (Canonical_Case_File_Name (Non_Canonical_Path));\n \n             --  To avoid processing the same directory several times, check\n             --  if the directory is already in Recursive_Dirs. If it is, then\n@@ -6386,15 +6238,8 @@ package body Prj.Nmsc is\n \n                Data.Object_Directory.Display_Name :=\n                  Path_Name_Type (Object_Dir.Value);\n-\n-               if Osint.File_Names_Case_Sensitive then\n-                  Data.Object_Directory.Name :=\n-                    Path_Name_Type (Object_Dir.Value);\n-               else\n-                  Get_Name_String (Object_Dir.Value);\n-                  Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                  Data.Object_Directory.Name := Name_Find;\n-               end if;\n+               Data.Object_Directory.Name :=\n+                 Path_Name_Type (Canonical_Case_File_Name (Object_Dir.Value));\n             end if;\n          end if;\n \n@@ -6420,9 +6265,9 @@ package body Prj.Nmsc is\n          if Data.Object_Directory = No_Path_Information then\n             Write_Line (\"No object directory\");\n          else\n-            Write_Str (\"Object directory: \"\"\");\n-            Write_Str (Get_Name_String (Data.Object_Directory.Display_Name));\n-            Write_Line (\"\"\"\");\n+            Write_Attr\n+              (\"Object directory\",\n+               Get_Name_String (Data.Object_Directory.Display_Name));\n          end if;\n       end if;\n \n@@ -6515,10 +6360,9 @@ package body Prj.Nmsc is\n             Index         => 0);\n \n          if Current_Verbosity = High then\n-            Write_Line (\"Single source directory:\");\n-            Write_Str (\"    \"\"\");\n-            Write_Str (Get_Name_String (Data.Directory.Display_Name));\n-            Write_Line (\"\"\"\");\n+            Write_Attr\n+              (\"Single source directory\",\n+               Get_Name_String (Data.Directory.Display_Name));\n          end if;\n \n       elsif Source_Dirs.Values = Nil_String then\n@@ -6584,12 +6428,8 @@ package body Prj.Nmsc is\n          while Current /= Nil_String loop\n             Element := In_Tree.String_Elements.Table (Current);\n             if Element.Value /= No_Name then\n-               if not Osint.File_Names_Case_Sensitive then\n-                  Get_Name_String (Element.Value);\n-                  Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                  Element.Value := Name_Find;\n-               end if;\n-\n+               Element.Value :=\n+                 Name_Id (Canonical_Case_File_Name (Name_Id (Element.Value)));\n                In_Tree.String_Elements.Table (Current) := Element;\n             end if;\n \n@@ -7256,32 +7096,20 @@ package body Prj.Nmsc is\n       In_Tree : Project_Tree_Ref;\n       Data    : Project_Data)\n    is\n-      Excluded_Sources : Variable_Value;\n-\n-      Excluded_Source_List_File : Variable_Value;\n-\n-      Current          : String_List_Id;\n-\n-      Element : String_Element;\n-\n-      Location : Source_Ptr;\n-\n-      Name : File_Name_Type;\n-\n-      File : Prj.Util.Text_File;\n-      Line : String (1 .. 300);\n-      Last : Natural;\n-\n-      Locally_Removed : Boolean := False;\n+      Excluded_Source_List_File : constant Variable_Value := Util.Value_Of\n+        (Name_Excluded_Source_List_File, Data.Decl.Attributes, In_Tree);\n+      Excluded_Sources          : Variable_Value := Util.Value_Of\n+        (Name_Excluded_Source_Files, Data.Decl.Attributes, In_Tree);\n+\n+      Current                   : String_List_Id;\n+      Element                   : String_Element;\n+      Location                  : Source_Ptr;\n+      Name                      : File_Name_Type;\n+      File                      : Prj.Util.Text_File;\n+      Line                      : String (1 .. 300);\n+      Last                      : Natural;\n+      Locally_Removed           : Boolean := False;\n    begin\n-      Excluded_Source_List_File :=\n-        Util.Value_Of\n-          (Name_Excluded_Source_List_File, Data.Decl.Attributes, In_Tree);\n-\n-      Excluded_Sources :=\n-        Util.Value_Of\n-          (Name_Excluded_Source_Files, Data.Decl.Attributes, In_Tree);\n-\n       --  If Excluded_Source_Files is not declared, check\n       --  Locally_Removed_Files.\n \n@@ -7316,14 +7144,7 @@ package body Prj.Nmsc is\n          Current := Excluded_Sources.Values;\n          while Current /= Nil_String loop\n             Element := In_Tree.String_Elements.Table (Current);\n-\n-            if Osint.File_Names_Case_Sensitive then\n-               Name := File_Name_Type (Element.Value);\n-            else\n-               Get_Name_String (Element.Value);\n-               Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-               Name := Name_Find;\n-            end if;\n+            Name := Canonical_Case_File_Name (Element.Value);\n \n             --  If the element has no location, then use the location\n             --  of Excluded_Sources to report possible errors.\n@@ -7483,15 +7304,9 @@ package body Prj.Nmsc is\n \n             while Current /= Nil_String loop\n                Element := In_Tree.String_Elements.Table (Current);\n+               Name := Canonical_Case_File_Name (Element.Value);\n                Get_Name_String (Element.Value);\n \n-               if Osint.File_Names_Case_Sensitive then\n-                  Name := File_Name_Type (Element.Value);\n-               else\n-                  Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                  Name := Name_Find;\n-               end if;\n-\n                --  If the element has no location, then use the\n                --  location of Sources to report possible errors.\n \n@@ -8518,8 +8333,7 @@ package body Prj.Nmsc is\n \n                begin\n                   if Current_Verbosity = High then\n-                     Write_Str (\"Source_Dir = \");\n-                     Write_Line (Source_Directory);\n+                     Write_Attr (\"Source_Dir\", Source_Directory);\n                   end if;\n \n                   --  We look to every entry in the source directory\n@@ -8900,21 +8714,21 @@ package body Prj.Nmsc is\n       Source_Names.Reset;\n       Find_Excluded_Sources (Project, In_Tree, Data);\n \n-      case Get_Mode is\n-         when Ada_Only =>\n-            if Is_A_Language (In_Tree, Data, Name_Ada) then\n-               Find_Explicit_Sources (Current_Dir, Project, In_Tree, Data);\n-               Mark_Excluded_Sources;\n-            end if;\n+      if (Get_Mode = Ada_Only and then Is_A_Language (In_Tree, Data, Name_Ada))\n+        or else (Get_Mode = Multi_Language\n+                 and then Data.First_Language_Processing /= No_Language_Index)\n+      then\n+         if Get_Mode = Multi_Language then\n+            Load_Naming_Exceptions (Project, In_Tree, Data);\n+         end if;\n \n-         when Multi_Language =>\n-            if Data.First_Language_Processing /= No_Language_Index then\n-               Load_Naming_Exceptions (Project, In_Tree, Data);\n-               Find_Explicit_Sources (Current_Dir, Project, In_Tree, Data);\n-               Mark_Excluded_Sources;\n-               Process_Sources_In_Multi_Language_Mode;\n-            end if;\n-      end case;\n+         Find_Explicit_Sources (Current_Dir, Project, In_Tree, Data);\n+         Mark_Excluded_Sources;\n+\n+         if Get_Mode = Multi_Language then\n+            Process_Sources_In_Multi_Language_Mode;\n+         end if;\n+      end if;\n    end Look_For_Sources;\n \n    ------------------\n@@ -9024,14 +8838,11 @@ package body Prj.Nmsc is\n       File_Name_Recorded : Boolean := False;\n \n    begin\n+      Canonical_File_Name := Canonical_Case_File_Name (Name_Id (File_Name));\n+\n       if Osint.File_Names_Case_Sensitive then\n-         Canonical_File_Name := File_Name;\n          Canonical_Path_Name := Path_Name;\n       else\n-         Get_Name_String (File_Name);\n-         Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-         Canonical_File_Name := Name_Find;\n-\n          declare\n             Canonical_Path : constant String :=\n                                Normalize_Pathname"}, {"sha": "a5cb0c85e1121d1c66b9f15bb589dd3fd2bca6fe", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 65, "deletions": 127, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/347ab254f812eec432aede015990dd5af799ba93/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/347ab254f812eec432aede015990dd5af799ba93/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=347ab254f812eec432aede015990dd5af799ba93", "patch": "@@ -2519,7 +2519,67 @@ package body Prj.Proc is\n       From_Project_Node_Tree : Project_Node_Tree_Ref;\n       Extended_By            : Project_Id)\n    is\n-      With_Clause : Project_Node_Id;\n+      procedure Process_Imported_Projects\n+        (Imported     : in out Project_List;\n+         Limited_With : Boolean);\n+      --  Process imported projects. If Limited_With is True, then only\n+      --  projects processed through a \"limited with\" are processed, otherwise\n+      --  only projects imported through a standard \"with\" are processed.\n+      --  Imported is the id of the last imported project.\n+\n+      procedure Process_Imported_Projects\n+        (Imported     : in out Project_List;\n+         Limited_With : Boolean)\n+      is\n+         With_Clause : Project_Node_Id := First_With_Clause_Of\n+           (From_Project_Node, From_Project_Node_Tree);\n+         New_Project : Project_Id;\n+         Proj_Node   : Project_Node_Id;\n+      begin\n+         while Present (With_Clause) loop\n+            Proj_Node :=\n+              Non_Limited_Project_Node_Of\n+                (With_Clause, From_Project_Node_Tree);\n+            New_Project := No_Project;\n+\n+            if (Limited_With and No (Proj_Node))\n+              or (not Limited_With and Present (Proj_Node))\n+            then\n+               Recursive_Process\n+                 (In_Tree                => In_Tree,\n+                  Project                => New_Project,\n+                  From_Project_Node      =>\n+                    Project_Node_Of\n+                      (With_Clause, From_Project_Node_Tree),\n+                  From_Project_Node_Tree => From_Project_Node_Tree,\n+                  Extended_By            => No_Project);\n+\n+               --  Add this project to our list of imported projects\n+\n+               Project_List_Table.Increment_Last (In_Tree.Project_Lists);\n+\n+               In_Tree.Project_Lists.Table\n+                 (Project_List_Table.Last (In_Tree.Project_Lists)) :=\n+                 (Project => New_Project, Next => Empty_Project_List);\n+\n+               --  Imported is the id of the last imported project. If\n+               --  it is nil, then this imported project is our first.\n+\n+               if Imported = Empty_Project_List then\n+                  In_Tree.Projects.Table (Project).Imported_Projects :=\n+                    Project_List_Table.Last (In_Tree.Project_Lists);\n+               else\n+                  In_Tree.Project_Lists.Table (Imported).Next :=\n+                    Project_List_Table.Last (In_Tree.Project_Lists);\n+               end if;\n+\n+               Imported := Project_List_Table.Last (In_Tree.Project_Lists);\n+            end if;\n+\n+            With_Clause :=\n+              Next_With_Clause_Of (With_Clause, From_Project_Node_Tree);\n+         end loop;\n+      end Process_Imported_Projects;\n \n    begin\n       if No (From_Project_Node) then\n@@ -2624,84 +2684,23 @@ package body Prj.Proc is\n                Prj.Attr.Attribute_First,\n                Project_Level => True);\n \n-            --  Process non limited withed projects\n-\n-            With_Clause :=\n-              First_With_Clause_Of (From_Project_Node, From_Project_Node_Tree);\n-            while Present (With_Clause) loop\n-               declare\n-                  New_Project : Project_Id;\n-                  New_Data    : Project_Data;\n-                  pragma Unreferenced (New_Data);\n-                  Proj_Node   : Project_Node_Id;\n-\n-               begin\n-                  Proj_Node :=\n-                    Non_Limited_Project_Node_Of\n-                      (With_Clause, From_Project_Node_Tree);\n-\n-                  if Present (Proj_Node) then\n-                     Recursive_Process\n-                       (In_Tree                => In_Tree,\n-                        Project                => New_Project,\n-                        From_Project_Node      =>\n-                          Project_Node_Of\n-                            (With_Clause, From_Project_Node_Tree),\n-                        From_Project_Node_Tree => From_Project_Node_Tree,\n-                        Extended_By            => No_Project);\n-\n-                     New_Data :=\n-                       In_Tree.Projects.Table (New_Project);\n-\n-                     --  Add this project to our list of imported projects\n-\n-                     Project_List_Table.Increment_Last\n-                       (In_Tree.Project_Lists);\n-\n-                     In_Tree.Project_Lists.Table\n-                       (Project_List_Table.Last\n-                          (In_Tree.Project_Lists)) :=\n-                       (Project => New_Project, Next => Empty_Project_List);\n-\n-                     --  Imported is the id of the last imported project. If it\n-                     --  is nil, then this imported project is our first.\n-\n-                     if Imported = Empty_Project_List then\n-                        Processed_Data.Imported_Projects :=\n-                          Project_List_Table.Last\n-                            (In_Tree.Project_Lists);\n-\n-                     else\n-                        In_Tree.Project_Lists.Table\n-                          (Imported).Next := Project_List_Table.Last\n-                          (In_Tree.Project_Lists);\n-                     end if;\n-\n-                     Imported := Project_List_Table.Last\n-                       (In_Tree.Project_Lists);\n-                  end if;\n+            In_Tree.Projects.Table (Project) := Processed_Data;\n \n-                  With_Clause :=\n-                    Next_With_Clause_Of\n-                      (With_Clause, From_Project_Node_Tree);\n-               end;\n-            end loop;\n+            Process_Imported_Projects (Imported, Limited_With => False);\n \n             Declaration_Node :=\n               Project_Declaration_Of\n                 (From_Project_Node, From_Project_Node_Tree);\n \n             Recursive_Process\n               (In_Tree                => In_Tree,\n-               Project                => Processed_Data.Extends,\n+               Project            => In_Tree.Projects.Table (Project).Extends,\n                From_Project_Node      => Extended_Project_Of\n                                           (Declaration_Node,\n                                            From_Project_Node_Tree),\n                From_Project_Node_Tree => From_Project_Node_Tree,\n                Extended_By            => Project);\n \n-            In_Tree.Projects.Table (Project) := Processed_Data;\n-\n             Process_Declarative_Items\n               (Project                => Project,\n                In_Tree                => In_Tree,\n@@ -2826,68 +2825,7 @@ package body Prj.Proc is\n                In_Tree.Projects.Table (Project) := Processed_Data;\n             end if;\n \n-            --  Process limited withed projects\n-\n-            With_Clause :=\n-              First_With_Clause_Of\n-                (From_Project_Node, From_Project_Node_Tree);\n-            while Present (With_Clause) loop\n-               declare\n-                  New_Project : Project_Id;\n-                  New_Data    : Project_Data;\n-                  pragma Unreferenced (New_Data);\n-                  Proj_Node   : Project_Node_Id;\n-\n-               begin\n-                  Proj_Node :=\n-                    Non_Limited_Project_Node_Of\n-                      (With_Clause, From_Project_Node_Tree);\n-\n-                  if No (Proj_Node) then\n-                     Recursive_Process\n-                       (In_Tree                => In_Tree,\n-                        Project                => New_Project,\n-                        From_Project_Node      =>\n-                          Project_Node_Of\n-                            (With_Clause, From_Project_Node_Tree),\n-                        From_Project_Node_Tree => From_Project_Node_Tree,\n-                        Extended_By            => No_Project);\n-\n-                     New_Data :=\n-                       In_Tree.Projects.Table (New_Project);\n-\n-                     --  Add this project to our list of imported projects\n-\n-                     Project_List_Table.Increment_Last\n-                       (In_Tree.Project_Lists);\n-\n-                     In_Tree.Project_Lists.Table\n-                       (Project_List_Table.Last\n-                          (In_Tree.Project_Lists)) :=\n-                       (Project => New_Project, Next => Empty_Project_List);\n-\n-                     --  Imported is the id of the last imported project. If\n-                     --  it is nil, then this imported project is our first.\n-\n-                     if Imported = Empty_Project_List then\n-                        In_Tree.Projects.Table (Project).Imported_Projects :=\n-                          Project_List_Table.Last\n-                            (In_Tree.Project_Lists);\n-                     else\n-                        In_Tree.Project_Lists.Table\n-                          (Imported).Next := Project_List_Table.Last\n-                          (In_Tree.Project_Lists);\n-                     end if;\n-\n-                     Imported := Project_List_Table.Last\n-                       (In_Tree.Project_Lists);\n-                  end if;\n-\n-                  With_Clause :=\n-                    Next_With_Clause_Of\n-                      (With_Clause, From_Project_Node_Tree);\n-               end;\n-            end loop;\n+            Process_Imported_Projects (Imported, Limited_With => True);\n          end;\n       end if;\n    end Recursive_Process;"}, {"sha": "a1caea990fea036ffe1188780c8be7705e166fed", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/347ab254f812eec432aede015990dd5af799ba93/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/347ab254f812eec432aede015990dd5af799ba93/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=347ab254f812eec432aede015990dd5af799ba93", "patch": "@@ -73,7 +73,6 @@ package body Prj is\n \n    Std_Naming_Data : constant Naming_Data :=\n                        (Dot_Replacement           => Standard_Dot_Replacement,\n-                        Dot_Repl_Loc              => No_Location,\n                         Casing                    => All_Lower_Case,\n                         Spec_Suffix               => No_Array_Element,\n                         Ada_Spec_Suffix_Loc       => No_Location,\n@@ -655,10 +654,9 @@ package body Prj is\n       Extended  : Project_Id;\n       In_Tree   : Project_Tree_Ref) return Boolean\n    is\n-      Proj : Project_Id;\n+      Proj : Project_Id := Extending;\n \n    begin\n-      Proj := Extending;\n       while Proj /= No_Project loop\n          if Proj = Extended then\n             return True;"}, {"sha": "5282c38c088fec6b8e206efc960329bcc5338758", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/347ab254f812eec432aede015990dd5af799ba93/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/347ab254f812eec432aede015990dd5af799ba93/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=347ab254f812eec432aede015990dd5af799ba93", "patch": "@@ -870,8 +870,6 @@ package Prj is\n       Dot_Replacement : File_Name_Type := No_File;\n       --  The string to replace '.' in the source file name (for Ada)\n \n-      Dot_Repl_Loc : Source_Ptr := No_Location;\n-\n       Casing : Casing_Type := All_Lower_Case;\n       --  The casing of the source file name (for Ada)\n "}]}