{"sha": "28c5e6b58f86f8f5446b959cb1decc1b6d6f7577", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhjNWU2YjU4Zjg2ZjhmNTQ0NmI5NTljYjFkZWNjMWI2ZDZmNzU3Nw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-12-06T15:04:09Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-12-06T15:04:09Z"}, "message": "Forward-port from gcc-4_6-branch r181936 2011-12-02.\n\nlibgcc/\n\tForward-port from gcc-4_6-branch r181936 2011-12-02.\n\n\tPR target/51345\n\tPR target/51002\n\t* config/avr/lib1funcs.S (__prologue_saves__,\n\t__epilogue_restores__, __divdi3_moddi3): Enclose parts using\n\t__SP_H__ in !defined (__AVR_HAVE_8BIT_SP__).  Add FIXME comments.\n\ngcc/\n\tForward-port from gcc-4_6-branch r181936 2011-12-02.\n\n\tPR target/51002\n\t* config/avr/avr.md (movhi_sp_r): Set insn condition to\n\t!AVR_HAVE_8BIT_SP.\n\t* config/avr/avr.c (output_movhi): Use \"clr%B0\" instead of \"in\n\t%B0,__SP_H__\" if AVR_HAVE_8BIT_SP.\n\t(avr_file_start): Only print \"__SP_H__ = 0x3e\" if !AVR_HAVE_8BIT_SP.\n\nFrom-SVN: r182052", "tree": {"sha": "55fe407836f382ac16da8b2665c7119175760165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55fe407836f382ac16da8b2665c7119175760165"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "562f552bd866b17d9425b443d341e1fb5f7d1184", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/562f552bd866b17d9425b443d341e1fb5f7d1184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/562f552bd866b17d9425b443d341e1fb5f7d1184"}], "stats": {"total": 163, "additions": 107, "deletions": 56}, "files": [{"sha": "2ddce7a55c3a9e9af692923bffa1ab9cdf068692", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28c5e6b58f86f8f5446b959cb1decc1b6d6f7577", "patch": "@@ -1,3 +1,14 @@\n+2011-12-06  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tForward-port from gcc-4_6-branch r181936 2011-12-02.\n+\n+\tPR target/51002\n+\t* config/avr/avr.md (movhi_sp_r): Set insn condition to\n+\t!AVR_HAVE_8BIT_SP.\n+\t* config/avr/avr.c (output_movhi): Use \"clr%B0\" instead of \"in\n+\t%B0,__SP_H__\" if AVR_HAVE_8BIT_SP.\n+\t(avr_file_start): Only print \"__SP_H__ = 0x3e\" if !AVR_HAVE_8BIT_SP.\n+\n 2011-12-06  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/51409"}, {"sha": "8b85b5c165dcd724773e009e584af0c6f428dd67", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 57, "deletions": 55, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=28c5e6b58f86f8f5446b959cb1decc1b6d6f7577", "patch": "@@ -2875,78 +2875,77 @@ output_movqi (rtx insn, rtx operands[], int *l)\n \n \n const char *\n-output_movhi (rtx insn, rtx operands[], int *l)\n+output_movhi (rtx insn, rtx xop[], int *plen)\n {\n-  int dummy;\n-  rtx dest = operands[0];\n-  rtx src = operands[1];\n-  int *real_l = l;\n+  rtx dest = xop[0];\n+  rtx src = xop[1];\n+\n+  gcc_assert (GET_MODE_SIZE (GET_MODE (dest)) == 2);\n   \n   if (avr_mem_pgm_p (src)\n       || avr_mem_pgm_p (dest))\n     {\n-      return avr_out_lpm (insn, operands, real_l);\n+      return avr_out_lpm (insn, xop, plen);\n     }\n \n-  if (!l)\n-    l = &dummy;\n-  \n-  if (register_operand (dest, HImode))\n+  if (REG_P (dest))\n     {\n-      if (register_operand (src, HImode)) /* mov r,r */\n-\t{\n-\t  if (test_hard_reg_class (STACK_REG, dest))\n-\t    {\n-\t      if (AVR_HAVE_8BIT_SP)\n-\t\treturn *l = 1, AS2 (out,__SP_L__,%A1);\n-              /* Use simple load of stack pointer if no interrupts are \n-\t\t used.  */\n-\t      else if (TARGET_NO_INTERRUPTS)\n-\t\treturn *l = 2, (AS2 (out,__SP_H__,%B1) CR_TAB\n-\t\t\t\tAS2 (out,__SP_L__,%A1));\n-\t      *l = 5;\n-\t      return (AS2 (in,__tmp_reg__,__SREG__)  CR_TAB\n-\t\t      \"cli\"                          CR_TAB\n-\t\t      AS2 (out,__SP_H__,%B1)         CR_TAB\n-\t\t      AS2 (out,__SREG__,__tmp_reg__) CR_TAB\n-\t\t      AS2 (out,__SP_L__,%A1));\n-\t    }\n-\t  else if (test_hard_reg_class (STACK_REG, src))\n-\t    {\n-\t      *l = 2;\t\n-\t      return (AS2 (in,%A0,__SP_L__) CR_TAB\n-\t\t      AS2 (in,%B0,__SP_H__));\n-\t    }\n+      if (REG_P (src)) /* mov r,r */\n+        {\n+          if (test_hard_reg_class (STACK_REG, dest))\n+            {\n+              if (AVR_HAVE_8BIT_SP)\n+                return avr_asm_len (\"out __SP_L__,%A1\", xop, plen, -1);\n+              \n+              /* Use simple load of SP if no interrupts are  used.  */\n+              \n+              return TARGET_NO_INTERRUPTS\n+                ? avr_asm_len (\"out __SP_H__,%B1\" CR_TAB\n+                               \"out __SP_L__,%A1\", xop, plen, -2)\n+\n+                : avr_asm_len (\"in __tmp_reg__,__SREG__\"  CR_TAB\n+                               \"cli\"                      CR_TAB\n+                               \"out __SP_H__,%B1\"         CR_TAB\n+                               \"out __SREG__,__tmp_reg__\" CR_TAB\n+                               \"out __SP_L__,%A1\", xop, plen, -5);\n+            }\n+          else if (test_hard_reg_class (STACK_REG, src))\n+            {\n+              return AVR_HAVE_8BIT_SP\n+                ? avr_asm_len (\"in %A0,__SP_L__\" CR_TAB\n+                               \"clr %B0\", xop, plen, -2)\n+                \n+                : avr_asm_len (\"in %A0,__SP_L__\" CR_TAB\n+                               \"in %B0,__SP_H__\", xop, plen, -2);\n+            }\n \n-\t  if (AVR_HAVE_MOVW)\n-\t    {\n-\t      *l = 1;\n-\t      return (AS2 (movw,%0,%1));\n-\t    }\n-\t  else\n-\t    {\n-\t      *l = 2;\n-\t      return (AS2 (mov,%A0,%A1) CR_TAB\n-\t\t      AS2 (mov,%B0,%B1));\n-\t    }\n-\t}\n+          return AVR_HAVE_MOVW\n+            ? avr_asm_len (\"movw %0,%1\", xop, plen, -1)\n+\n+            : avr_asm_len (\"mov %A0,%A1\" CR_TAB\n+                           \"mov %B0,%B1\", xop, plen, -2);\n+        } /* REG_P (src) */\n       else if (CONSTANT_P (src))\n         {\n-          return output_reload_inhi (operands, NULL, real_l);\n+          return output_reload_inhi (xop, NULL, plen);\n+        }\n+      else if (MEM_P (src))\n+        {\n+          return out_movhi_r_mr (insn, xop, plen); /* mov r,m */\n         }\n-      else if (GET_CODE (src) == MEM)\n-\treturn out_movhi_r_mr (insn, operands, real_l); /* mov r,m */\n     }\n-  else if (GET_CODE (dest) == MEM)\n+  else if (MEM_P (dest))\n     {\n       rtx xop[2];\n \n       xop[0] = dest;\n       xop[1] = src == const0_rtx ? zero_reg_rtx : src;\n \n-      return out_movhi_mr_r (insn, xop, real_l);\n+      return out_movhi_mr_r (insn, xop, plen);\n     }\n+  \n   fatal_insn (\"invalid insn:\", insn);\n+  \n   return \"\";\n }\n \n@@ -7272,16 +7271,19 @@ avr_file_start (void)\n \n   default_file_start ();\n \n+  if (!AVR_HAVE_8BIT_SP)\n+    fprintf (asm_out_file,\n+             \"__SP_H__ = 0x%02x\\n\"\n+             -sfr_offset + SP_ADDR + 1);\n+\n   fprintf (asm_out_file,\n-           \"__SREG__ = 0x%02x\\n\"\n-           \"__SP_H__ = 0x%02x\\n\"\n            \"__SP_L__ = 0x%02x\\n\"\n+           \"__SREG__ = 0x%02x\\n\"\n            \"__RAMPZ__ = 0x%02x\\n\"\n            \"__tmp_reg__ = %d\\n\" \n            \"__zero_reg__ = %d\\n\",\n-           -sfr_offset + SREG_ADDR,\n-           -sfr_offset + SP_ADDR + 1,\n            -sfr_offset + SP_ADDR,\n+           -sfr_offset + SREG_ADDR,\n            -sfr_offset + RAMPZ_ADDR,\n            TMP_REGNO,\n            ZERO_REGNO);"}, {"sha": "1c79894f1841df83e71ac8e8bf665d9d3dd2b5b8", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=28c5e6b58f86f8f5446b959cb1decc1b6d6f7577", "patch": "@@ -620,7 +620,7 @@\n         (unspec_volatile:HI [(match_operand:HI 1 \"register_operand\"  \"r,r\")\n                              (match_operand:HI 2 \"const_int_operand\" \"L,P\")]\n                             UNSPECV_WRITE_SP))]\n-  \"\"\n+  \"!AVR_HAVE_8BIT_SP\"\n   \"@\n \tout __SP_H__,%B1\\;out __SP_L__,%A1\n \tcli\\;out __SP_H__,%B1\\;sei\\;out __SP_L__,%A1\""}, {"sha": "cde3853b72fb763d9a031cbf85fad4b5292ef72a", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=28c5e6b58f86f8f5446b959cb1decc1b6d6f7577", "patch": "@@ -1,3 +1,13 @@\n+2011-12-06  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tForward-port from gcc-4_6-branch r181936 2011-12-02.\n+\n+\tPR target/51345\n+\tPR target/51002\n+\t* config/avr/lib1funcs.S (__prologue_saves__,\n+\t__epilogue_restores__, __divdi3_moddi3): Enclose parts using\n+\t__SP_H__ in !defined (__AVR_HAVE_8BIT_SP__).  Add FIXME comments.\n+\n 2011-12-04  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* config/rs6000/t-darwin64 (LIB2ADD): Add fp and gp save routines."}, {"sha": "3545d095b60f7a9adb5cb02bdef3e83e809f3872", "filename": "libgcc/config/avr/lib1funcs.S", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28c5e6b58f86f8f5446b959cb1decc1b6d6f7577/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs.S?ref=28c5e6b58f86f8f5446b959cb1decc1b6d6f7577", "patch": "@@ -1149,7 +1149,14 @@ DEFUN  __divdi3_moddi3\n \n 4:  ;; Epilogue: Restore the Z = 12 Registers and return\n     in r28, __SP_L__\n+#if defined (__AVR_HAVE_8BIT_SP__)\n+;; FIXME: __AVR_HAVE_8BIT_SP__ is set on device level, not on core level\n+;;        so this lines are dead code.  To make it work, devices without\n+;;        SP_H must get their own multilib(s).\n+    clr r29\n+#else\n     in r29, __SP_H__\n+#endif /* #SP = 8/16 */\n     ldi r30, 12\n     XJMP __epilogue_restores__ + ((18 - 12) * 2)\n \n@@ -1229,6 +1236,15 @@ DEFUN __prologue_saves__\n \tpush r17\n \tpush r28\n \tpush r29\n+#if defined (__AVR_HAVE_8BIT_SP__)\n+;; FIXME: __AVR_HAVE_8BIT_SP__ is set on device level, not on core level\n+;;        so this lines are dead code.  To make it work, devices without\n+;;        SP_H must get their own multilib(s).\n+\tin\tr28,__SP_L__\n+\tsub\tr28,r26\n+\tout\t__SP_L__,r28\n+\tclr\tr29\n+#else\n \tin\tr28,__SP_L__\n \tin\tr29,__SP_H__\n \tsub\tr28,r26\n@@ -1238,6 +1254,8 @@ DEFUN __prologue_saves__\n \tout\t__SP_H__,r29\n \tout\t__SREG__,__tmp_reg__\n \tout\t__SP_L__,r28\n+#endif /* #SP = 8/16 */\n+\n #if defined (__AVR_HAVE_EIJMP_EICALL__)\n \teijmp\n #else\n@@ -1270,6 +1288,15 @@ DEFUN __epilogue_restores__\n \tldd\tr16,Y+4\n \tldd\tr17,Y+3\n \tldd\tr26,Y+2\n+#if defined (__AVR_HAVE_8BIT_SP__)\n+;; FIXME: __AVR_HAVE_8BIT_SP__ is set on device level, not on core level\n+;;        so this lines are dead code.  To make it work, devices without\n+;;        SP_H must get their own multilib(s).\n+\tldd\tr29,Y+1\n+\tadd\tr28,r30\n+\tout\t__SP_L__,r28\n+\tmov\tr28, r26\n+#else\n \tldd\tr27,Y+1\n \tadd\tr28,r30\n \tadc\tr29,__zero_reg__\n@@ -1280,6 +1307,7 @@ DEFUN __epilogue_restores__\n \tout\t__SP_L__,r28\n \tmov_l\tr28, r26\n \tmov_h\tr29, r27\n+#endif /* #SP = 8/16 */\n \tret\n ENDF __epilogue_restores__\n #endif /* defined (L_epilogue) */"}]}