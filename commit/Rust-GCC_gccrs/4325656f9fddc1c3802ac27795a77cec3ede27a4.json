{"sha": "4325656f9fddc1c3802ac27795a77cec3ede27a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMyNTY1NmY5ZmRkYzFjMzgwMmFjMjc3OTVhNzdjZWMzZWRlMjdhNA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-08T12:36:26Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-08T12:36:26Z"}, "message": "Come up with cgraph_node::get_uid and make cgraph_node::uid private.\n\n2018-06-08  Martin Liska  <mliska@suse.cz>\n\n\t* cgraph.c (function_version_hasher::hash): Use\n\tcgraph_node::get_uid ().\n\t(function_version_hasher::equal):\n\t* cgraph.h (cgraph_node::get_uid): New method.\n\t* ipa-inline.c (update_caller_keys): Use\n\tcgraph_node::get_uid ().\n\t(update_callee_keys): Likewise.\n\t* ipa-utils.c (searchc): Likewise.\n\t(ipa_reduced_postorder): Likewise.\n\t* lto-cgraph.c (input_node): Likewise.\n\t* passes.c (is_pass_explicitly_enabled_or_disabled): Likewise.\n\t* symbol-summary.h (symtab_insertion): Likewise.\n\t(symtab_removal): Likewise.\n\t(symtab_duplication): Likewise.\n\t* tree-pretty-print.c (dump_function_header): Likewise.\n\t* tree-sra.c (convert_callers_for_node): Likewise.\n\nFrom-SVN: r261320", "tree": {"sha": "3007ee87e0be9ad71f6af55941a7f2d815dedcfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3007ee87e0be9ad71f6af55941a7f2d815dedcfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4325656f9fddc1c3802ac27795a77cec3ede27a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4325656f9fddc1c3802ac27795a77cec3ede27a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4325656f9fddc1c3802ac27795a77cec3ede27a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4325656f9fddc1c3802ac27795a77cec3ede27a4/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8b25212d3e960dd130d71330ad6d55b40c5be254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b25212d3e960dd130d71330ad6d55b40c5be254", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b25212d3e960dd130d71330ad6d55b40c5be254"}], "stats": {"total": 76, "additions": 53, "deletions": 23}, "files": [{"sha": "27d1b7c12227e104e2d12e9323d93e88f2d324a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4325656f9fddc1c3802ac27795a77cec3ede27a4", "patch": "@@ -1,3 +1,22 @@\n+2018-06-08  Martin Liska  <mliska@suse.cz>\n+\n+\t* cgraph.c (function_version_hasher::hash): Use\n+\tcgraph_node::get_uid ().\n+\t(function_version_hasher::equal):\n+\t* cgraph.h (cgraph_node::get_uid): New method.\n+\t* ipa-inline.c (update_caller_keys): Use\n+\tcgraph_node::get_uid ().\n+\t(update_callee_keys): Likewise.\n+\t* ipa-utils.c (searchc): Likewise.\n+\t(ipa_reduced_postorder): Likewise.\n+\t* lto-cgraph.c (input_node): Likewise.\n+\t* passes.c (is_pass_explicitly_enabled_or_disabled): Likewise.\n+\t* symbol-summary.h (symtab_insertion): Likewise.\n+\t(symtab_removal): Likewise.\n+\t(symtab_duplication): Likewise.\n+\t* tree-pretty-print.c (dump_function_header): Likewise.\n+\t* tree-sra.c (convert_callers_for_node): Likewise.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* cgraph.c (symbol_table::create_edge): Always assign a new"}, {"sha": "bafbed7f13d9fbb1ad5991d1226f0520271a7fe8", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=4325656f9fddc1c3802ac27795a77cec3ede27a4", "patch": "@@ -120,7 +120,7 @@ static GTY(()) hash_table<function_version_hasher> *cgraph_fnver_htab = NULL;\n hashval_t\n function_version_hasher::hash (cgraph_function_version_info *ptr)\n {\n-  int uid = ptr->this_node->uid;\n+  int uid = ptr->this_node->get_uid ();\n   return (hashval_t)(uid);\n }\n \n@@ -129,7 +129,7 @@ bool\n function_version_hasher::equal (cgraph_function_version_info *n1,\n \t\t\t       \tcgraph_function_version_info *n2)\n {\n-  return n1->this_node->uid == n2->this_node->uid;\n+  return n1->this_node->get_uid () == n2->this_node->get_uid ();\n }\n \n /* Mark as GC root all allocated nodes.  */"}, {"sha": "a8b1b4cb3c38f5d8fe1160366fff26388c376dc9", "filename": "gcc/cgraph.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=4325656f9fddc1c3802ac27795a77cec3ede27a4", "patch": "@@ -97,6 +97,8 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   symtab_node\n {\n public:\n+  friend class symbol_table;\n+\n   /* Return name.  */\n   const char *name () const;\n \n@@ -893,6 +895,8 @@ struct cgraph_edge_hasher : ggc_ptr_hash<cgraph_edge>\n \n struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n public:\n+  friend class symbol_table;\n+\n   /* Remove the node from cgraph and all inline clones inlined into it.\n      Skip however removal of FORBIDDEN_NODE and return true if it needs to be\n      removed.  This allows to call the function from outer loop walking clone\n@@ -1271,6 +1275,12 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n     dump_cgraph (stderr);\n   }\n \n+  /* Get unique identifier of the node.  */\n+  inline int get_uid ()\n+  {\n+    return m_uid;\n+  }\n+\n   /* Record that DECL1 and DECL2 are semantically identical function\n      versions.  */\n   static void record_function_versions (tree decl1, tree decl2);\n@@ -1390,8 +1400,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   /* How to scale counts at materialization time; used to merge\n      LTO units with different number of profile runs.  */\n   int count_materialization_scale;\n-  /* Unique id of the node.  */\n-  int uid;\n   /* ID assigned by the profiling.  */\n   unsigned int profile_id;\n   /* Time profiler: first run of function.  */\n@@ -1438,6 +1446,9 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   unsigned indirect_call_target : 1;\n \n private:\n+  /* Unique id of the node.  */\n+  int m_uid;\n+\n   /* Worker for call_for_symbol_and_aliases.  */\n   bool call_for_symbol_and_aliases_1 (bool (*callback) (cgraph_node *,\n \t\t\t\t\t\t        void *),\n@@ -2617,7 +2628,7 @@ symbol_table::allocate_cgraph_symbol (void)\n   else\n     node = ggc_cleared_alloc<cgraph_node> ();\n \n-  node->uid = cgraph_max_uid++;\n+  node->m_uid = cgraph_max_uid++;\n   return node;\n }\n "}, {"sha": "7e4468a7331db3c0cc11fcd62a82c92812e5387e", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=4325656f9fddc1c3802ac27795a77cec3ede27a4", "patch": "@@ -1337,7 +1337,7 @@ update_caller_keys (edge_heap_t *heap, struct cgraph_node *node,\n   if ((!node->alias && !ipa_fn_summaries->get_create (node)->inlinable)\n       || node->global.inlined_to)\n     return;\n-  if (!bitmap_set_bit (updated_nodes, node->uid))\n+  if (!bitmap_set_bit (updated_nodes, node->get_uid ()))\n     return;\n \n   FOR_EACH_ALIAS (node, ref)\n@@ -1395,7 +1395,7 @@ update_callee_keys (edge_heap_t *heap, struct cgraph_node *node,\n \t    && (callee = e->callee->ultimate_alias_target (&avail, e->caller))\n \t    && ipa_fn_summaries->get_create (callee)->inlinable\n \t    && avail >= AVAIL_AVAILABLE\n-\t    && !bitmap_bit_p (updated_nodes, callee->uid))\n+\t    && !bitmap_bit_p (updated_nodes, callee->get_uid ()))\n \t  {\n \t    if (can_inline_edge_p (e, false)\n \t\t&& want_inline_small_function_p (e, false)"}, {"sha": "9985721f7da795e052f283b3c5ed6430cf9d4a88", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=4325656f9fddc1c3802ac27795a77cec3ede27a4", "patch": "@@ -86,7 +86,7 @@ searchc (struct searchc_env* env, struct cgraph_node *v,\n \n   /* mark node as old */\n   v_info->new_node = false;\n-  splay_tree_remove (env->nodes_marked_new, v->uid);\n+  splay_tree_remove (env->nodes_marked_new, v->get_uid ());\n \n   v_info->dfn_number = env->count;\n   v_info->low_link = env->count;\n@@ -195,7 +195,7 @@ ipa_reduced_postorder (struct cgraph_node **order,\n \t  node->aux = info;\n \n \t  splay_tree_insert (env.nodes_marked_new,\n-\t\t\t     (splay_tree_key)node->uid,\n+\t\t\t     (splay_tree_key)node->get_uid (),\n \t\t\t     (splay_tree_value)node);\n \t}\n       else"}, {"sha": "d5e390cb5f4cc4dc5061cd6dd7c54bb19dbaa430", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=4325656f9fddc1c3802ac27795a77cec3ede27a4", "patch": "@@ -1268,7 +1268,7 @@ input_node (struct lto_file_decl_data *file_data,\n      functions, they are expected to be read more than once.  */\n   if (node->aux && !DECL_BUILT_IN (node->decl))\n     internal_error (\"bytecode stream: found multiple instances of cgraph \"\n-\t\t    \"node with uid %d\", node->uid);\n+\t\t    \"node with uid %d\", node->get_uid ());\n \n   node->tp_first_run = streamer_read_uhwi (ib);\n "}, {"sha": "6e614029864b1c464085b9940396ea052528c0d0", "filename": "gcc/passes.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=4325656f9fddc1c3802ac27795a77cec3ede27a4", "patch": "@@ -1170,7 +1170,7 @@ is_pass_explicitly_enabled_or_disabled (opt_pass *pass,\n   if (!slot)\n     return false;\n \n-  cgraph_uid = func ? cgraph_node::get (func)->uid : 0;\n+  cgraph_uid = func ? cgraph_node::get (func)->get_uid () : 0;\n   if (func && DECL_ASSEMBLER_NAME_SET_P (func))\n     aname = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (func));\n \n@@ -1635,7 +1635,7 @@ do_per_function (void (*callback) (function *, void *data), void *data)\n static int nnodes;\n static GTY ((length (\"nnodes\"))) cgraph_node **order;\n \n-#define uid_hash_t hash_set<int_hash <int, 0, -1>>\n+#define uid_hash_t hash_set<int_hash <int, 0, -1> >\n \n /* Hook called when NODE is removed and therefore should be\n    excluded from order vector.  DATA is a hash set with removed nodes.  */\n@@ -1644,7 +1644,7 @@ static void\n remove_cgraph_node_from_order (cgraph_node *node, void *data)\n {\n   uid_hash_t *removed_nodes = (uid_hash_t *)data;\n-  removed_nodes->add (node->uid);\n+  removed_nodes->add (node->get_uid ());\n }\n \n /* If we are in IPA mode (i.e., current_function_decl is NULL), call\n@@ -1675,7 +1675,7 @@ do_per_function_toporder (void (*callback) (function *, void *data), void *data)\n \t  cgraph_node *node = order[i];\n \n \t  /* Function could be inlined and removed as unreachable.  */\n-\t  if (node == NULL || removed_nodes.contains (node->uid))\n+\t  if (node == NULL || removed_nodes.contains (node->get_uid ()))\n \t    continue;\n \n \t  /* Allow possibly removed nodes to be garbage collected.  */"}, {"sha": "ebf4b175e71cb68f8a4ef9ada2eedc62f32fe56e", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=4325656f9fddc1c3802ac27795a77cec3ede27a4", "patch": "@@ -90,13 +90,13 @@ class GTY((user)) function_summary <T *>\n      does not exist it will be created.  */\n   T* get_create (cgraph_node *node)\n   {\n-    return get (node->uid, true);\n+    return get (node->get_uid (), true);\n   }\n \n   /* Getter for summary callgraph node pointer.  */\n   T* get (cgraph_node *node)\n   {\n-    return get (node->uid, false);\n+    return get (node->get_uid (), false);\n   }\n \n   /* Return number of elements handled by data structure.  */\n@@ -108,7 +108,7 @@ class GTY((user)) function_summary <T *>\n   /* Return true if a summary for the given NODE already exists.  */\n   bool exists (cgraph_node *node)\n   {\n-    return m_map.get (node->uid) != NULL;\n+    return m_map.get (node->get_uid ()) != NULL;\n   }\n \n   /* Enable insertion hook invocation.  */\n@@ -216,7 +216,7 @@ template <typename T>\n void\n function_summary<T *>::symtab_insertion (cgraph_node *node, void *data)\n {\n-  gcc_checking_assert (node->uid);\n+  gcc_checking_assert (node->get_uid ());\n   function_summary *summary = (function_summary <T *> *) (data);\n \n   if (summary->m_insertion_enabled)\n@@ -227,10 +227,10 @@ template <typename T>\n void\n function_summary<T *>::symtab_removal (cgraph_node *node, void *data)\n {\n-  gcc_checking_assert (node->uid);\n+  gcc_checking_assert (node->get_uid ());\n   function_summary *summary = (function_summary <T *> *) (data);\n \n-  int uid = node->uid;\n+  int uid = node->get_uid ();\n   T **v = summary->m_map.get (uid);\n \n   if (v)\n@@ -256,7 +256,7 @@ function_summary<T *>::symtab_duplication (cgraph_node *node,\n     {\n       /* This load is necessary, because we insert a new value!  */\n       T *duplicate = summary->allocate_new ();\n-      summary->m_map.put (node2->uid, duplicate);\n+      summary->m_map.put (node2->get_uid (), duplicate);\n       summary->duplicate (node, node2, v, duplicate);\n     }\n }"}, {"sha": "94410541e0500032c2a480e02442b81c1d613784", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=4325656f9fddc1c3802ac27795a77cec3ede27a4", "patch": "@@ -4056,7 +4056,7 @@ dump_function_header (FILE *dump_file, tree fdecl, dump_flags_t flags)\n     fprintf (dump_file, \", decl_uid=%d\", DECL_UID (fdecl));\n   if (node)\n     {\n-      fprintf (dump_file, \", cgraph_uid=%d\", node->uid);\n+      fprintf (dump_file, \", cgraph_uid=%d\", node->get_uid ());\n       fprintf (dump_file, \", symbol_order=%d)%s\\n\\n\", node->order,\n                node->frequency == NODE_FREQUENCY_HOT\n                ? \" (hot)\""}, {"sha": "494afd830460669ec99631fbd1e8de25840918c0", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4325656f9fddc1c3802ac27795a77cec3ede27a4/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=4325656f9fddc1c3802ac27795a77cec3ede27a4", "patch": "@@ -5279,7 +5279,7 @@ convert_callers_for_node (struct cgraph_node *node,\n     }\n \n   for (cs = node->callers; cs; cs = cs->next_caller)\n-    if (bitmap_set_bit (recomputed_callers, cs->caller->uid)\n+    if (bitmap_set_bit (recomputed_callers, cs->caller->get_uid ())\n \t&& gimple_in_ssa_p (DECL_STRUCT_FUNCTION (cs->caller->decl)))\n       compute_fn_summary (cs->caller, true);\n   BITMAP_FREE (recomputed_callers);"}]}