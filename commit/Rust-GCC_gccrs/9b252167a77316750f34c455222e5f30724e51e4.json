{"sha": "9b252167a77316750f34c455222e5f30724e51e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIyNTIxNjdhNzczMTY3NTBmMzRjNDU1MjIyZTVmMzA3MjRlNTFlNA==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-11-17T14:00:30Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-08T13:10:32Z"}, "message": "Added more expression cfg stripping\n\nFixed compile errors", "tree": {"sha": "e5a69430cc9104031ef958852605f15c6aa76494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5a69430cc9104031ef958852605f15c6aa76494"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b252167a77316750f34c455222e5f30724e51e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b252167a77316750f34c455222e5f30724e51e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b252167a77316750f34c455222e5f30724e51e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b252167a77316750f34c455222e5f30724e51e4/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ec3b8d62b1b6ae79d55b71b423dcb04129884c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ec3b8d62b1b6ae79d55b71b423dcb04129884c6"}], "stats": {"total": 730, "additions": 660, "deletions": 70}, "files": [{"sha": "5601a1a0e281a814805246e5fee750114a352e4d", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b252167a77316750f34c455222e5f30724e51e4/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b252167a77316750f34c455222e5f30724e51e4/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=9b252167a77316750f34c455222e5f30724e51e4", "patch": "@@ -1700,10 +1700,8 @@ ReturnExpr::as_string () const\n {\n   std::string str (\"return \");\n \n-  if (has_return_expr ())\n-    {\n+  if (has_returned_expr ())\n       str += return_expr->as_string ();\n-    }\n \n   return str;\n }\n@@ -2255,13 +2253,9 @@ WhileLetLoopExpr::as_string () const\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n-    {\n       str += \"none\";\n-    }\n   else\n-    {\n       str += loop_label.as_string ();\n-    }\n \n   str += \"\\n Match arm patterns: \";\n   if (match_arm_patterns.empty ())\n@@ -2271,12 +2265,10 @@ WhileLetLoopExpr::as_string () const\n   else\n     {\n       for (const auto &pattern : match_arm_patterns)\n-\t{\n \t  str += \"\\n  \" + pattern->as_string ();\n-\t}\n     }\n \n-  str += \"\\n Scrutinee expr: \" + condition->as_string ();\n+  str += \"\\n Scrutinee expr: \" + scrutinee->as_string ();\n \n   str += \"\\n Loop block: \" + loop_block->as_string ();\n "}, {"sha": "df77611d75fc3bee24109fe1c519b24bdd19ad03", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 150, "deletions": 14, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b252167a77316750f34c455222e5f30724e51e4/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b252167a77316750f34c455222e5f30724e51e4/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=9b252167a77316750f34c455222e5f30724e51e4", "patch": "@@ -3281,19 +3281,19 @@ class RangeToInclExpr : public RangeExpr\n // Return expression AST node representation\n class ReturnExpr : public ExprWithoutBlock\n {\n-public:\n   std::unique_ptr<Expr> return_expr;\n \n   Location locus;\n \n   // TODO: find another way to store this to save memory?\n   bool marked_for_strip = false;\n \n+public:\n   std::string as_string () const override;\n \n   /* Returns whether the object has an expression returned (i.e. not void return\n    * type). */\n-  bool has_return_expr () const { return return_expr != nullptr; }\n+  bool has_returned_expr () const { return return_expr != nullptr; }\n \n   // Constructor for ReturnExpr.\n   ReturnExpr (Location locus, std::unique_ptr<Expr> returned_expr = nullptr,\n@@ -3341,6 +3341,12 @@ class ReturnExpr : public ExprWithoutBlock\n   void mark_for_strip () override { marked_for_strip = true; }\n   bool is_marked_for_strip () const override { return marked_for_strip; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_returned_expr () {\n+    rust_assert (return_expr != nullptr);\n+    return return_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3358,7 +3364,6 @@ class UnsafeBlockExpr : public ExprWithBlock\n {\n   // Or just have it extend BlockExpr\n   std::unique_ptr<BlockExpr> expr;\n-\n   Location locus;\n \n public:\n@@ -3408,6 +3413,12 @@ class UnsafeBlockExpr : public ExprWithBlock\n   void mark_for_strip () override { expr = nullptr; }\n   bool is_marked_for_strip () const override { return expr == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_block_expr () {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3422,7 +3433,6 @@ class UnsafeBlockExpr : public ExprWithBlock\n class LoopLabel /*: public Node*/\n {\n   Lifetime label; // or type LIFETIME_OR_LABEL\n-\n   Location locus;\n \n public:\n@@ -3504,6 +3514,12 @@ class BaseLoopExpr : public ExprWithBlock\n   // Invalid if loop block is null, so base stripping on that. \n   void mark_for_strip () override { loop_block = nullptr; }\n   bool is_marked_for_strip () const override { return loop_block == nullptr; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_loop_block () {\n+    rust_assert (loop_block != nullptr);\n+    return loop_block;\n+  }\n };\n \n // 'Loop' expression (i.e. the infinite loop) AST node\n@@ -3573,6 +3589,12 @@ class WhileLoopExpr : public BaseLoopExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_predicate_expr () {\n+    rust_assert (condition != nullptr);\n+    return condition;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3587,29 +3609,29 @@ class WhileLetLoopExpr : public BaseLoopExpr\n {\n   // MatchArmPatterns patterns;\n   std::vector<std::unique_ptr<Pattern> > match_arm_patterns; // inlined\n-  std::unique_ptr<Expr> condition;\n+  std::unique_ptr<Expr> scrutinee;\n \n public:\n   std::string as_string () const override;\n \n   // Constructor with a loop label\n   WhileLetLoopExpr (std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n-\t\t    std::unique_ptr<Expr> condition,\n+\t\t    std::unique_ptr<Expr> scrutinee,\n \t\t    std::unique_ptr<BlockExpr> loop_block, Location locus,\n \t\t    LoopLabel loop_label = LoopLabel::error (),\n \t\t    std::vector<Attribute> outer_attribs\n \t\t    = std::vector<Attribute> ())\n     : BaseLoopExpr (std::move (loop_block), locus, std::move (loop_label),\n \t\t    std::move (outer_attribs)),\n       match_arm_patterns (std::move (match_arm_patterns)),\n-      condition (std::move (condition))\n+      scrutinee (std::move (scrutinee))\n   {}\n \n   // Copy constructor with clone\n   WhileLetLoopExpr (WhileLetLoopExpr const &other)\n     : BaseLoopExpr (other),\n-      /*match_arm_patterns(other.match_arm_patterns),*/ condition (\n-\tother.condition->clone_expr ())\n+      /*match_arm_patterns(other.match_arm_patterns),*/ scrutinee (\n+\tother.scrutinee->clone_expr ())\n   {\n     match_arm_patterns.reserve (other.match_arm_patterns.size ());\n     for (const auto &e : other.match_arm_patterns)\n@@ -3621,7 +3643,7 @@ class WhileLetLoopExpr : public BaseLoopExpr\n   {\n     BaseLoopExpr::operator= (other);\n     // match_arm_patterns = other.match_arm_patterns;\n-    condition = other.condition->clone_expr ();\n+    scrutinee = other.scrutinee->clone_expr ();\n     // loop_block = other.loop_block->clone_block_expr();\n     // loop_label = other.loop_label;\n     // outer_attrs = other.outer_attrs;\n@@ -3639,6 +3661,12 @@ class WhileLetLoopExpr : public BaseLoopExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_scrutinee_expr () {\n+    rust_assert (scrutinee != nullptr);\n+    return scrutinee;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3694,6 +3722,12 @@ class ForLoopExpr : public BaseLoopExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_iterator_expr () {\n+    rust_assert (iterator_expr != nullptr);\n+    return iterator_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3777,8 +3811,17 @@ class IfExpr : public ExprWithBlock\n   void vis_if_condition (ASTVisitor &vis) { condition->accept_vis (vis); }\n   void vis_if_block (ASTVisitor &vis) { if_block->accept_vis (vis); }\n \n-  Expr *get_if_condition () { return condition.get (); }\n-  BlockExpr *get_if_block () { return if_block.get (); }\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_condition_expr () {\n+    rust_assert (condition != nullptr);\n+    return condition;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_if_block () {\n+    rust_assert (if_block != nullptr);\n+    return if_block;\n+  }\n \n   // Invalid if if block or condition is null, so base stripping on that. \n   void mark_for_strip () override { if_block = nullptr; condition = nullptr; }\n@@ -3836,6 +3879,12 @@ class IfExprConseqElse : public IfExpr\n \n   void vis_else_block (ASTVisitor &vis) { else_block->accept_vis (vis); }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_else_block () {\n+    rust_assert (else_block != nullptr);\n+    return else_block;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3888,6 +3937,12 @@ class IfExprConseqIf : public IfExpr\n     conseq_if_expr->accept_vis (vis);\n   }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<IfExpr> &get_conseq_if_expr () {\n+    rust_assert (conseq_if_expr != nullptr);\n+    return conseq_if_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3976,6 +4031,18 @@ class IfLetExpr : public ExprWithBlock\n   void mark_for_strip () override { if_block = nullptr; value = nullptr; }\n   bool is_marked_for_strip () const override { return if_block == nullptr && value == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_value_expr () {\n+    rust_assert (value != nullptr);\n+    return value;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_if_block () {\n+    rust_assert (if_block != nullptr);\n+    return if_block;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base (or rather this or any derived object) */\n@@ -4030,6 +4097,12 @@ class IfExprConseqIfLet : public IfExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<IfLetExpr> &get_conseq_if_let_expr () {\n+    rust_assert (if_let_expr != nullptr);\n+    return if_let_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -4082,6 +4155,12 @@ class IfLetExprConseqElse : public IfLetExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_else_block () {\n+    rust_assert (else_block != nullptr);\n+    return else_block;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -4133,6 +4212,12 @@ class IfLetExprConseqIf : public IfLetExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<IfExpr> &get_conseq_if_expr () {\n+    rust_assert (if_expr != nullptr);\n+    return if_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -4184,6 +4269,12 @@ class IfLetExprConseqIfLet : public IfLetExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<IfLetExpr> &get_conseq_if_let_expr () {\n+    rust_assert (if_let_expr != nullptr);\n+    return if_let_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -4265,6 +4356,16 @@ struct MatchArm\n   }\n \n   std::string as_string () const;\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_guard_expr () {\n+    rust_assert (has_match_arm_guard ());\n+    return guard_expr;\n+  }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n };\n \n /*\n@@ -4330,6 +4431,18 @@ struct MatchCase\n   ~MatchCase () = default;\n \n   std::string as_string () const;\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_expr () {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  MatchArm &get_arm () {\n+    rust_assert (!arm.is_error ());\n+    return arm;\n+  }\n };\n \n #if 0\n@@ -4502,6 +4615,19 @@ class MatchExpr : public ExprWithBlock\n   void mark_for_strip () override { branch_value = nullptr; }\n   bool is_marked_for_strip () const override { return branch_value == nullptr; }\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_scrutinee_expr () {\n+    rust_assert (branch_value != nullptr);\n+    return branch_value;\n+  }\n+\n+  const std::vector<MatchCase> &get_match_cases () const { return match_arms; }\n+  std::vector<MatchCase> &get_match_cases () { return match_arms; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -4515,7 +4641,6 @@ class MatchExpr : public ExprWithBlock\n class AwaitExpr : public ExprWithoutBlock\n {\n   std::unique_ptr<Expr> awaited_expr;\n-\n   Location locus;\n \n public:\n@@ -4565,6 +4690,12 @@ class AwaitExpr : public ExprWithoutBlock\n   void mark_for_strip () override { awaited_expr = nullptr; }\n   bool is_marked_for_strip () const override { return awaited_expr == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_awaited_expr () {\n+    rust_assert (awaited_expr != nullptr);\n+    return awaited_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -4580,7 +4711,6 @@ class AsyncBlockExpr : public ExprWithBlock\n   // TODO: should this extend BlockExpr rather than be a composite of it?\n   bool has_move;\n   std::unique_ptr<BlockExpr> block_expr;\n-\n   Location locus;\n \n public:\n@@ -4630,6 +4760,12 @@ class AsyncBlockExpr : public ExprWithBlock\n   void mark_for_strip () override { block_expr = nullptr; }\n   bool is_marked_for_strip () const override { return block_expr == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_block_expr () {\n+    rust_assert (block_expr != nullptr);\n+    return block_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "eb01b12b7f60143afe49cf3e305d6c4603cdf492", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b252167a77316750f34c455222e5f30724e51e4/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b252167a77316750f34c455222e5f30724e51e4/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=9b252167a77316750f34c455222e5f30724e51e4", "patch": "@@ -740,10 +740,10 @@ void\n Compilation::visit (AST::ReturnExpr &expr)\n {\n   Bexpression *ret = NULL;\n-  VISIT_POP (expr.return_expr->get_locus_slow (), expr.return_expr, ret, exprs);\n+  VISIT_POP (expr.get_returned_expr ()->get_locus_slow (), expr.get_returned_expr ().get (), ret, exprs);\n   if (ret == NULL)\n     {\n-      rust_fatal_error (expr.return_expr->get_locus_slow (),\n+      rust_fatal_error (expr.get_returned_expr ()->get_locus_slow (),\n \t\t\t\"failed to compile\");\n       return;\n     }\n@@ -778,11 +778,11 @@ void\n Compilation::visit (AST::IfExpr &expr)\n {\n   Bexpression *cond = NULL;\n-  VISIT_POP (expr.get_if_condition ()->get_locus_slow (),\n-\t     expr.get_if_condition (), cond, exprs);\n+  VISIT_POP (expr.get_condition_expr ()->get_locus_slow (),\n+\t     expr.get_condition_expr ().get (), cond, exprs);\n   if (cond == NULL)\n     {\n-      rust_error_at (expr.get_if_condition ()->get_locus_slow (),\n+      rust_error_at (expr.get_condition_expr ()->get_locus_slow (),\n \t\t     \"failed to compile\");\n       return;\n     }\n@@ -799,11 +799,11 @@ void\n Compilation::visit (AST::IfExprConseqElse &expr)\n {\n   Bexpression *cond = NULL;\n-  VISIT_POP (expr.get_if_condition ()->get_locus_slow (),\n-\t     expr.get_if_condition (), cond, exprs);\n+  VISIT_POP (expr.get_condition_expr ()->get_locus_slow (),\n+\t     expr.get_condition_expr ().get (), cond, exprs);\n   if (cond == NULL)\n     {\n-      rust_error_at (expr.get_if_condition ()->get_locus_slow (),\n+      rust_error_at (expr.get_condition_expr ()->get_locus_slow (),\n \t\t     \"failed to compile\");\n       return;\n     }\n@@ -824,11 +824,11 @@ void\n Compilation::visit (AST::IfExprConseqIf &expr)\n {\n   Bexpression *cond = NULL;\n-  VISIT_POP (expr.get_if_condition ()->get_locus_slow (),\n-\t     expr.get_if_condition (), cond, exprs);\n+  VISIT_POP (expr.get_condition_expr ()->get_locus_slow (),\n+\t     expr.get_condition_expr ().get (), cond, exprs);\n   if (cond == NULL)\n     {\n-      rust_error_at (expr.get_if_condition ()->get_locus_slow (),\n+      rust_error_at (expr.get_condition_expr ()->get_locus_slow (),\n \t\t     \"failed to compile\");\n       return;\n     }"}, {"sha": "7dd97506c78612606c693a89f9990bf0adab108b", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 497, "deletions": 35, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b252167a77316750f34c455222e5f30724e51e4/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b252167a77316750f34c455222e5f30724e51e4/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=9b252167a77316750f34c455222e5f30724e51e4", "patch": "@@ -956,23 +956,436 @@ namespace Rust {\n                 rust_error_at(to_expr->get_locus_slow(), \n                   \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n-        void visit(AST::ReturnExpr& expr) override {}\n-        void visit(AST::UnsafeBlockExpr& expr) override {}\n-        void visit(AST::LoopExpr& expr) override {}\n-        void visit(AST::WhileLoopExpr& expr) override {}\n-        void visit(AST::WhileLetLoopExpr& expr) override {}\n-        void visit(AST::ForLoopExpr& expr) override {}\n-        void visit(AST::IfExpr& expr) override {}\n-        void visit(AST::IfExprConseqElse& expr) override {}\n-        void visit(AST::IfExprConseqIf& expr) override {}\n-        void visit(AST::IfExprConseqIfLet& expr) override {}\n-        void visit(AST::IfLetExpr& expr) override {}\n-        void visit(AST::IfLetExprConseqElse& expr) override {}\n-        void visit(AST::IfLetExprConseqIf& expr) override {}\n-        void visit(AST::IfLetExprConseqIfLet& expr) override {}\n-        void visit(AST::MatchExpr& expr) override {}\n-        void visit(AST::AwaitExpr& expr) override {}\n-        void visit(AST::AsyncBlockExpr& expr) override {}\n+        void visit(AST::ReturnExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* spec does not say that you can have outer attributes on \n+             * expression, so assuming you can't. stripping for sub-expressions\n+             * is the only thing that can be done */\n+            if (expr.has_returned_expr()) {\n+                auto& returned_expr = expr.get_returned_expr();\n+\n+                returned_expr->accept_vis(*this);\n+\n+                if (returned_expr->is_marked_for_strip()) \n+                    rust_error_at(returned_expr->get_locus_slow(), \n+                      \"cannot strip expression in this position - outer attributes not allowed\");\n+            }\n+            /* TODO: conceptually, you would maybe be able to remove a returned\n+             * expr - e.g. if you had conditional compilation returning void or\n+             * returning a type. On the other hand, I think that function \n+             * return type cannot be conditionally compiled, so I assumed you\n+             * can't do this either. */\n+        }\n+        void visit(AST::UnsafeBlockExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip block itself, but can strip sub-expressions\n+            auto& block_expr = expr.get_block_expr();\n+            block_expr->accept_vis(*this);\n+            if (block_expr->is_marked_for_strip()) \n+                rust_error_at(block_expr->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::LoopExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip block itself, but can strip sub-expressions\n+            auto& loop_block = expr.get_loop_block();\n+            loop_block->accept_vis(*this);\n+            if (loop_block->is_marked_for_strip()) \n+                rust_error_at(loop_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::WhileLoopExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip predicate expr itself, but can strip sub-expressions\n+            auto& predicate_expr = expr.get_predicate_expr();\n+            predicate_expr->accept_vis(*this);\n+            if (predicate_expr->is_marked_for_strip()) \n+                rust_error_at(predicate_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+\n+            // can't strip block itself, but can strip sub-expressions\n+            auto& loop_block = expr.get_loop_block();\n+            loop_block->accept_vis(*this);\n+            if (loop_block->is_marked_for_strip()) \n+                rust_error_at(loop_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::WhileLetLoopExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip scrutinee expr itself, but can strip sub-expressions\n+            auto& scrutinee_expr = expr.get_scrutinee_expr();\n+            scrutinee_expr->accept_vis(*this);\n+            if (scrutinee_expr->is_marked_for_strip()) \n+                rust_error_at(scrutinee_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+\n+            // can't strip block itself, but can strip sub-expressions\n+            auto& loop_block = expr.get_loop_block();\n+            loop_block->accept_vis(*this);\n+            if (loop_block->is_marked_for_strip()) \n+                rust_error_at(loop_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::ForLoopExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip scrutinee expr itself, but can strip sub-expressions\n+            auto& iterator_expr = expr.get_iterator_expr();\n+            iterator_expr->accept_vis(*this);\n+            if (iterator_expr->is_marked_for_strip()) \n+                rust_error_at(iterator_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+\n+            // can't strip block itself, but can strip sub-expressions\n+            auto& loop_block = expr.get_loop_block();\n+            loop_block->accept_vis(*this);\n+            if (loop_block->is_marked_for_strip()) \n+                rust_error_at(loop_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::IfExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip condition expr itself, but can strip sub-expressions\n+            auto& condition_expr = expr.get_condition_expr();\n+            condition_expr->accept_vis(*this);\n+            if (condition_expr->is_marked_for_strip()) \n+                rust_error_at(condition_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+\n+            // can't strip if block itself, but can strip sub-expressions\n+            auto& if_block = expr.get_if_block();\n+            if_block->accept_vis(*this);\n+            if (if_block->is_marked_for_strip()) \n+                rust_error_at(if_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::IfExprConseqElse& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip condition expr itself, but can strip sub-expressions\n+            auto& condition_expr = expr.get_condition_expr();\n+            condition_expr->accept_vis(*this);\n+            if (condition_expr->is_marked_for_strip()) \n+                rust_error_at(condition_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+\n+            // can't strip if block itself, but can strip sub-expressions\n+            auto& if_block = expr.get_if_block();\n+            if_block->accept_vis(*this);\n+            if (if_block->is_marked_for_strip()) \n+                rust_error_at(if_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+            \n+            // can't strip else block itself, but can strip sub-expressions\n+            auto& else_block = expr.get_else_block();\n+            else_block->accept_vis(*this);\n+            if (else_block->is_marked_for_strip()) \n+                rust_error_at(else_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::IfExprConseqIf& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip condition expr itself, but can strip sub-expressions\n+            auto& condition_expr = expr.get_condition_expr();\n+            condition_expr->accept_vis(*this);\n+            if (condition_expr->is_marked_for_strip()) \n+                rust_error_at(condition_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+\n+            // can't strip if block itself, but can strip sub-expressions\n+            auto& if_block = expr.get_if_block();\n+            if_block->accept_vis(*this);\n+            if (if_block->is_marked_for_strip()) \n+                rust_error_at(if_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+            \n+            // can't strip if expr itself, but can strip sub-expressions\n+            auto& conseq_if_expr = expr.get_conseq_if_expr();\n+            conseq_if_expr->accept_vis(*this);\n+            if (conseq_if_expr->is_marked_for_strip()) \n+                rust_error_at(conseq_if_expr->get_locus_slow(), \n+                  \"cannot strip consequent if expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::IfExprConseqIfLet& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip condition expr itself, but can strip sub-expressions\n+            auto& condition_expr = expr.get_condition_expr();\n+            condition_expr->accept_vis(*this);\n+            if (condition_expr->is_marked_for_strip()) \n+                rust_error_at(condition_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+\n+            // can't strip if block itself, but can strip sub-expressions\n+            auto& if_block = expr.get_if_block();\n+            if_block->accept_vis(*this);\n+            if (if_block->is_marked_for_strip()) \n+                rust_error_at(if_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+            \n+            // can't strip if let expr itself, but can strip sub-expressions\n+            auto& conseq_if_let_expr = expr.get_conseq_if_let_expr();\n+            conseq_if_let_expr->accept_vis(*this);\n+            if (conseq_if_let_expr->is_marked_for_strip()) \n+                rust_error_at(conseq_if_let_expr->get_locus_slow(), \n+                  \"cannot strip consequent if let expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::IfLetExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip value expr itself, but can strip sub-expressions\n+            auto& value_expr = expr.get_value_expr();\n+            value_expr->accept_vis(*this);\n+            if (value_expr->is_marked_for_strip()) \n+                rust_error_at(value_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+\n+            // can't strip if block itself, but can strip sub-expressions\n+            auto& if_block = expr.get_if_block();\n+            if_block->accept_vis(*this);\n+            if (if_block->is_marked_for_strip()) \n+                rust_error_at(if_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::IfLetExprConseqElse& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip value expr itself, but can strip sub-expressions\n+            auto& value_expr = expr.get_value_expr();\n+            value_expr->accept_vis(*this);\n+            if (value_expr->is_marked_for_strip()) \n+                rust_error_at(value_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+\n+            // can't strip if block itself, but can strip sub-expressions\n+            auto& if_block = expr.get_if_block();\n+            if_block->accept_vis(*this);\n+            if (if_block->is_marked_for_strip()) \n+                rust_error_at(if_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+\n+            // can't strip else block itself, but can strip sub-expressions\n+            auto& else_block = expr.get_else_block();\n+            else_block->accept_vis(*this);\n+            if (else_block->is_marked_for_strip()) \n+                rust_error_at(else_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::IfLetExprConseqIf& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip value expr itself, but can strip sub-expressions\n+            auto& value_expr = expr.get_value_expr();\n+            value_expr->accept_vis(*this);\n+            if (value_expr->is_marked_for_strip()) \n+                rust_error_at(value_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+\n+            // can't strip if block itself, but can strip sub-expressions\n+            auto& if_block = expr.get_if_block();\n+            if_block->accept_vis(*this);\n+            if (if_block->is_marked_for_strip()) \n+                rust_error_at(if_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+            \n+            // can't strip if expr itself, but can strip sub-expressions\n+            auto& conseq_if_expr = expr.get_conseq_if_expr();\n+            conseq_if_expr->accept_vis(*this);\n+            if (conseq_if_expr->is_marked_for_strip()) \n+                rust_error_at(conseq_if_expr->get_locus_slow(), \n+                  \"cannot strip consequent if expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::IfLetExprConseqIfLet& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip value expr itself, but can strip sub-expressions\n+            auto& value_expr = expr.get_value_expr();\n+            value_expr->accept_vis(*this);\n+            if (value_expr->is_marked_for_strip()) \n+                rust_error_at(value_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+\n+            // can't strip if block itself, but can strip sub-expressions\n+            auto& if_block = expr.get_if_block();\n+            if_block->accept_vis(*this);\n+            if (if_block->is_marked_for_strip()) \n+                rust_error_at(if_block->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+\n+            // can't strip if let expr itself, but can strip sub-expressions\n+            auto& conseq_if_let_expr = expr.get_conseq_if_let_expr();\n+            conseq_if_let_expr->accept_vis(*this);\n+            if (conseq_if_let_expr->is_marked_for_strip()) \n+                rust_error_at(conseq_if_let_expr->get_locus_slow(), \n+                  \"cannot strip consequent if let expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::MatchExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // inner attr strip test\n+            expander.expand_cfg_attrs(expr.get_inner_attrs());\n+            if (expander.fails_cfg(expr.get_inner_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip scrutinee expr itself, but can strip sub-expressions\n+            auto& scrutinee_expr = expr.get_scrutinee_expr();\n+            scrutinee_expr->accept_vis(*this);\n+            if (scrutinee_expr->is_marked_for_strip()) \n+                rust_error_at(scrutinee_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+            \n+            // strip match cases \n+            auto& match_cases = expr.get_match_cases();\n+            for (int i = 0; i < match_cases.size(); ) {\n+                auto& match_case = match_cases[i];\n+\n+                // strip match case based on outer attributes in match arm\n+                auto& match_arm = match_case.get_arm();\n+                expander.expand_cfg_attrs(match_arm.get_outer_attrs());\n+                if (expander.fails_cfg(match_arm.get_outer_attrs())) {\n+                    // strip match case\n+                    match_cases.erase(match_cases.begin() + i);\n+                    continue;\n+                } \n+\n+                /* assuming that guard expression cannot be stripped as \n+                 * strictly speaking you would have to strip the whole guard to \n+                 * make syntactical sense, which you can't do. as such, only\n+                 * strip sub-expressions */\n+                if (match_arm.has_match_arm_guard()) {\n+                    auto& guard_expr = match_arm.get_guard_expr();\n+                    guard_expr->accept_vis(*this);\n+                    if (guard_expr->is_marked_for_strip()) \n+                        rust_error_at(guard_expr->get_locus_slow(), \n+                          \"cannot strip expression in this position - outer attributes not allowed\");\n+                }\n+\n+                // strip sub-expressions from match cases\n+                auto& case_expr = match_case.get_expr();\n+                case_expr->accept_vis(*this);\n+                if (case_expr->is_marked_for_strip()) \n+                    rust_error_at(case_expr->get_locus_slow(), \n+                      \"cannot strip expression in this position - outer attributes not allowed\");\n+                \n+                // increment to next case if haven't continued\n+                i++;\n+            }\n+        }\n+        void visit(AST::AwaitExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* can't strip awaited expr itself, but can strip sub-expressions \n+             * - this is because you can't have no expr to await */\n+            auto& awaited_expr = expr.get_awaited_expr();\n+            awaited_expr->accept_vis(*this);\n+            if (awaited_expr->is_marked_for_strip()) \n+                rust_error_at(awaited_expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n+        }\n+        void visit(AST::AsyncBlockExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // can't strip block itself, but can strip sub-expressions\n+            auto& block_expr = expr.get_block_expr();\n+            block_expr->accept_vis(*this);\n+            if (block_expr->is_marked_for_strip()) \n+                rust_error_at(block_expr->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n+        }\n \n         void visit(AST::TypeParam& param) override {\n             // shouldn't require?\n@@ -1001,8 +1414,12 @@ namespace Rust {\n \n             /* body should always exist - if error state, should have returned\n              * before now */\n-            method.get_definition()->accept_vis(*this);\n-            // TODO: can block as a whole be invalidated here? Assuming no\n+            // can't strip block itself, but can strip sub-expressions\n+            auto& block_expr = method.get_definition();\n+            block_expr->accept_vis(*this);\n+            if (block_expr->is_marked_for_strip()) \n+                rust_error_at(block_expr->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::ModuleBodied& module) override {\n             // strip test based on outer attrs\n@@ -1080,8 +1497,12 @@ namespace Rust {\n \n             /* body should always exist - if error state, should have returned\n              * before now */\n-            function.get_definition()->accept_vis(*this);\n-            // TODO: can block as a whole be invalidated here? Assuming no\n+            // can't strip block itself, but can strip sub-expressions\n+            auto& block_expr = function.get_definition();\n+            block_expr->accept_vis(*this);\n+            if (block_expr->is_marked_for_strip()) \n+                rust_error_at(block_expr->get_locus_slow(), \n+                  \"cannot strip block expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::TypeAlias& type_alias) override {\n             // initial test based on outer attrs\n@@ -1158,7 +1579,11 @@ namespace Rust {\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped. */\n-            item.get_expr()->accept_vis(*this);\n+            auto& expr = item.get_expr();\n+            expr->accept_vis(*this);\n+            if (expr->is_marked_for_strip()) \n+                rust_error_at(expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::Enum& enum_item) override {\n             // initial test based on outer attrs\n@@ -1206,7 +1631,11 @@ namespace Rust {\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped. */\n-            const_item.get_expr()->accept_vis(*this);\n+            auto& expr = const_item.get_expr();\n+            expr->accept_vis(*this);\n+            if (expr->is_marked_for_strip()) \n+                rust_error_at(expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::StaticItem& static_item) override {\n             // initial test based on outer attrs\n@@ -1219,7 +1648,11 @@ namespace Rust {\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped. */\n-            static_item.get_expr()->accept_vis(*this);\n+            auto& expr = static_item.get_expr();\n+            expr->accept_vis(*this);\n+            if (expr->is_marked_for_strip()) \n+                rust_error_at(expr->get_locus_slow(), \n+                  \"cannot strip expression in this position - outer attributes not allowed\");\n         }\n         void visit(AST::TraitItemFunc& item) override {\n             // initial test based on outer attrs\n@@ -1234,8 +1667,14 @@ namespace Rust {\n             expand_function_params(item.get_function_params());\n \n             if (item.has_definition()) {\n-                item.get_definition()->accept_vis(*this);\n-                // TODO: can block as a whole be invalidated here? Assuming no\n+                /* strip any internal sub-expressions - expression itself isn't\n+                 * allowed to have external attributes in this position so can't be\n+                 * stripped. */\n+                auto& block = item.get_definition();\n+                block->accept_vis(*this);\n+                if (block->is_marked_for_strip()) \n+                    rust_error_at(block->get_locus_slow(), \n+                      \"cannot strip block expression in this position - outer attributes not allowed\");\n             }\n         }\n         void visit(AST::TraitItemMethod& item) override {\n@@ -1255,8 +1694,14 @@ namespace Rust {\n             expand_function_params(item.get_function_params());\n \n             if (item.has_definition()) {\n-                item.get_definition()->accept_vis(*this);\n-                // TODO: can block as a whole be invalidated here? Assuming no\n+                /* strip any internal sub-expressions - expression itself isn't\n+                 * allowed to have external attributes in this position so can't be\n+                 * stripped. */\n+                auto& block = item.get_definition();\n+                block->accept_vis(*this);\n+                if (block->is_marked_for_strip()) \n+                    rust_error_at(block->get_locus_slow(), \n+                      \"cannot strip block expression in this position - outer attributes not allowed\");\n             }\n         }\n         void visit(AST::TraitItemConst& item) override {\n@@ -1270,8 +1715,13 @@ namespace Rust {\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped */\n-            if (item.has_expression())\n-                item.get_expr()->accept_vis(*this);\n+            if (item.has_expression()) {\n+                auto& expr = item.get_expr();\n+                expr->accept_vis(*this);\n+                if (expr->is_marked_for_strip()) \n+                    rust_error_at(expr->get_locus_slow(), \n+                      \"cannot strip expression in this position - outer attributes not allowed\");\n+            }\n         }\n         void visit(AST::TraitItemType& item) override {\n             // initial test based on outer attrs\n@@ -1474,7 +1924,9 @@ namespace Rust {\n         void visit(AST::StructPatternFieldTuplePat& field) override {}\n         void visit(AST::StructPatternFieldIdentPat& field) override {}\n         void visit(AST::StructPatternFieldIdent& field) override {}\n-        void visit(AST::StructPattern& pattern) override {}\n+        void visit(AST::StructPattern& pattern) override {\n+            // TODO: apparently struct pattern fields can have outer attrs. so can they be stripped?\n+        }\n         void visit(AST::TupleStructItemsNoRange& tuple_items) override {}\n         void visit(AST::TupleStructItemsRange& tuple_items) override {}\n         void visit(AST::TupleStructPattern& pattern) override {}\n@@ -1498,8 +1950,13 @@ namespace Rust {\n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n              * stripped */\n-            if (stmt.has_init_expr())\n-                stmt.get_init_expr()->accept_vis(*this);\n+            if (stmt.has_init_expr()) {\n+                auto& init_expr = stmt.get_init_expr();\n+                init_expr->accept_vis(*this);\n+                if (init_expr->is_marked_for_strip()) \n+                    rust_error_at(init_expr->get_locus_slow(), \n+                      \"cannot strip expression in this position - outer attributes not allowed\");\n+            }\n         }\n         void visit(AST::ExprStmtWithoutBlock& stmt) override {\n             // outer attributes associated with expr, so rely on expr\n@@ -1543,10 +2000,15 @@ namespace Rust {\n         void visit(AST::NeverType& type) override {}\n         void visit(AST::RawPointerType& type) override {}\n         void visit(AST::ReferenceType& type) override {}\n-        void visit(AST::ArrayType& type) override {}\n+        void visit(AST::ArrayType& type) override {\n+            // TODO: array type contains a \"constant expression\" - could this have strippable sub-exprs?\n+        }\n         void visit(AST::SliceType& type) override {}\n         void visit(AST::InferredType& type) override {}\n-        void visit(AST::BareFunctionType& type) override {}\n+        void visit(AST::BareFunctionType& type) override {\n+            // TODO: bare function type contains \"maybe-named params\" that have outer attributes - could this be strippable?\n+            // apparently \"attribute rules are same as on regular function params\", so looks like a yes\n+        }\n     };\n \n     void MacroExpander::expand_invoc(std::unique_ptr<AST::MacroInvocation>& invoc) {"}]}