{"sha": "14e19b82c1e67ead60c3095ac23347317298904b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRlMTliODJjMWU2N2VhZDYwYzMwOTVhYzIzMzQ3MzE3Mjk4OTA0Yg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-10-19T15:40:00Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-10-27T10:49:54Z"}, "message": "gcov-profile: use static pool for TOPN first\n\ngcc/ChangeLog:\n\n\tPR gcov-profile/97461\n\t* gcov-io.h (GCOV_PREALLOCATED_KVP): Pre-allocate 64\n\tstatic counters.\n\nlibgcc/ChangeLog:\n\n\tPR gcov-profile/97461\n\t* libgcov.h (gcov_counter_add): Use first static counters\n\tas it should help to have malloc wrappers set up.\n\ngcc/testsuite/ChangeLog:\n\n\tPR gcov-profile/97461\n\t* gcc.dg/tree-prof/pr97461.c: New test.", "tree": {"sha": "fde313742d6dd32a455e4246f7d5535178d5e30c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fde313742d6dd32a455e4246f7d5535178d5e30c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14e19b82c1e67ead60c3095ac23347317298904b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14e19b82c1e67ead60c3095ac23347317298904b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14e19b82c1e67ead60c3095ac23347317298904b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14e19b82c1e67ead60c3095ac23347317298904b/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21508c47f9a51f5b7dce35baee08fe95053ea85b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21508c47f9a51f5b7dce35baee08fe95053ea85b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21508c47f9a51f5b7dce35baee08fe95053ea85b"}], "stats": {"total": 84, "additions": 65, "deletions": 19}, "files": [{"sha": "4e95c7c82eec5d796c46e09b09a889be63a79fc7", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14e19b82c1e67ead60c3095ac23347317298904b/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14e19b82c1e67ead60c3095ac23347317298904b/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=14e19b82c1e67ead60c3095ac23347317298904b", "patch": "@@ -293,7 +293,7 @@ GCOV_COUNTERS\n #define GCOV_TOPN_MAXIMUM_TRACKED_VALUES 32\n \n /* Number of pre-allocated gcov_kvp structures.  */\n-#define GCOV_PREALLOCATED_KVP 16\n+#define GCOV_PREALLOCATED_KVP 64\n \n /* Convert a counter index to a tag.  */\n #define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\"}, {"sha": "8d21a3ef421e87f4691c1c271d5af182de153af4", "filename": "gcc/testsuite/gcc.dg/tree-prof/pr97461.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14e19b82c1e67ead60c3095ac23347317298904b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr97461.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14e19b82c1e67ead60c3095ac23347317298904b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr97461.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr97461.c?ref=14e19b82c1e67ead60c3095ac23347317298904b", "patch": "@@ -0,0 +1,58 @@\n+/* PR gcov-profile/97461 */\n+/* { dg-options \"-O2 -ldl\" } */\n+\n+#define _GNU_SOURCE\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+static int malloc_depth = 0;\n+\n+static char memory[128* 1024];\n+static size_t memory_p = 0;\n+\n+void f1(void) {}\n+void f2(void) {}\n+\n+typedef void (*fun_t)(void);\n+static const fun_t funs[2] = { f1, f2, };\n+\n+static void * malloc_impl(size_t size) {\n+    void * r = &memory[memory_p];\n+    memory_p += size;\n+\n+    // force TOPN profile\n+    funs[size % 2]();\n+    return r;\n+}\n+\n+// Override default malloc, check it it get s called recursively\n+void * malloc(size_t size) {\n+    // Must not be called recursively. Malloc implementation does not support it.\n+    if (malloc_depth != 0) __builtin_trap();\n+\n+    ++malloc_depth;\n+      void * r = malloc_impl(size);\n+    --malloc_depth;\n+    return r;\n+}\n+\n+// Called from gcov\n+void *calloc(size_t nmemb, size_t size) {\n+    // Must not be called recursively.  Malloc implementation does not support it.\n+    if (malloc_depth != 0) __builtin_trap();\n+\n+    ++malloc_depth;\n+      void * r = malloc_impl(size * nmemb);\n+      memset(r, 0, size * nmemb);\n+    --malloc_depth;\n+    return r;\n+}\n+\n+void free(void *ptr){}\n+\n+int main() {\n+    void * p = malloc(8);\n+    return p != 0 ? 0 : 1;\n+}"}, {"sha": "e70cf63b414e8d2339399bb5dad6e6e1dd71fae2", "filename": "libgcc/libgcov.h", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14e19b82c1e67ead60c3095ac23347317298904b/libgcc%2Flibgcov.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14e19b82c1e67ead60c3095ac23347317298904b/libgcc%2Flibgcov.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.h?ref=14e19b82c1e67ead60c3095ac23347317298904b", "patch": "@@ -404,22 +404,16 @@ gcov_counter_add (gcov_type *counter, gcov_type value,\n     *counter += value;\n }\n \n-/* Allocate gcov_kvp from heap.  If we are recursively called, then allocate\n-   it from a list of pre-allocated pool.  */\n+/* Allocate gcov_kvp from statically pre-allocated pool,\n+   or use heap otherwise.  */\n \n static inline struct gcov_kvp *\n allocate_gcov_kvp (void)\n {\n   struct gcov_kvp *new_node = NULL;\n \n-  static\n-#if defined(HAVE_CC_TLS)\n-__thread\n-#endif\n-  volatile unsigned in_recursion ATTRIBUTE_UNUSED = 0;\n-\n #if !defined(IN_GCOV_TOOL) && !defined(L_gcov_merge_topn)\n-  if (__builtin_expect (in_recursion, 0))\n+  if (__gcov_kvp_pool_index < GCOV_PREALLOCATED_KVP)\n     {\n       unsigned index;\n #if GCOV_SUPPORTS_ATOMIC\n@@ -430,17 +424,11 @@ __thread\n #endif\n       if (index < GCOV_PREALLOCATED_KVP)\n \tnew_node = &__gcov_kvp_pool[index];\n-      else\n-\t/* Do not crash in the situation.  */\n-\treturn NULL;\n     }\n-  else\n #endif\n-    {\n-      in_recursion = 1;\n-      new_node = (struct gcov_kvp *)xcalloc (1, sizeof (struct gcov_kvp));\n-      in_recursion = 0;\n-    }\n+\n+  if (new_node == NULL)\n+    new_node = (struct gcov_kvp *)xcalloc (1, sizeof (struct gcov_kvp));\n \n   return new_node;\n }"}]}