{"sha": "916b809fbfdd2740006270baf549bf22fe9ec3c4", "node_id": "C_kwDOANBUbNoAKDkxNmI4MDlmYmZkZDI3NDAwMDYyNzBiYWY1NDliZjIyZmU5ZWMzYzQ", "commit": {"author": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2022-02-23T22:08:29Z"}, "committer": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2022-02-24T19:38:13Z"}, "message": "Fortran: frontend code for F2018 QUIET specifier to STOP and ERROR STOP\n\nFortran 2018 allows for a QUIET specifier to the STOP and ERROR STOP\nstatements.  Whilst the gfortran library code provides support for this\nspecifier for quite some time, the frontend implementation was missing.\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/84519\n\t* dump-parse-tree.cc (show_code_node): Dump QUIET specifier when\n\tpresent.\n\t* match.cc (gfc_match_stopcode): Implement parsing of F2018 QUIET\n\tspecifier.  F2018 stopcodes may have non-default integer kind.\n\t* resolve.cc (gfc_resolve_code): Add checks for QUIET argument.\n\t* trans-stmt.cc (gfc_trans_stop): Pass QUIET specifier to call of\n\tlibrary function.\n\ngcc/testsuite/ChangeLog:\n\n\tPR fortran/84519\n\t* gfortran.dg/stop_1.f90: New test.\n\t* gfortran.dg/stop_2.f: New test.\n\t* gfortran.dg/stop_3.f90: New test.\n\t* gfortran.dg/stop_4.f90: New test.", "tree": {"sha": "9d2d6e000b37e084950454f1b0f108a9a9b21625", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d2d6e000b37e084950454f1b0f108a9a9b21625"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/916b809fbfdd2740006270baf549bf22fe9ec3c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916b809fbfdd2740006270baf549bf22fe9ec3c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/916b809fbfdd2740006270baf549bf22fe9ec3c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916b809fbfdd2740006270baf549bf22fe9ec3c4/comments", "author": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "committer": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8645370af18979123d9e94e3ed215d23dd740721", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8645370af18979123d9e94e3ed215d23dd740721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8645370af18979123d9e94e3ed215d23dd740721"}], "stats": {"total": 202, "additions": 189, "deletions": 13}, "files": [{"sha": "322416e65567597cb93cfe79cfcf4a92920b7e0c", "filename": "gcc/fortran/dump-parse-tree.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ffortran%2Fdump-parse-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ffortran%2Fdump-parse-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.cc?ref=916b809fbfdd2740006270baf549bf22fe9ec3c4", "patch": "@@ -2370,6 +2370,11 @@ show_code_node (int level, gfc_code *c)\n \tshow_expr (c->expr1);\n       else\n \tfprintf (dumpfile, \"%d\", c->ext.stop_code);\n+      if (c->expr2 != NULL)\n+\t{\n+\t  fputs (\" QUIET=\", dumpfile);\n+\t  show_expr (c->expr2);\n+\t}\n \n       break;\n "}, {"sha": "715a74eba51f3bd8dd255cc4b71f0edb6a9dbff0", "filename": "gcc/fortran/match.cc", "status": "modified", "additions": 52, "deletions": 10, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ffortran%2Fmatch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ffortran%2Fmatch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.cc?ref=916b809fbfdd2740006270baf549bf22fe9ec3c4", "patch": "@@ -2978,6 +2978,13 @@ Fortran 2008 has\n    R856 allstop-stmt  is ALL STOP [ stop-code ]\n    R857 stop-code     is scalar-default-char-constant-expr\n                       or scalar-int-constant-expr\n+Fortran 2018 has\n+\n+   R1160 stop-stmt       is STOP [ stop-code ] [ , QUIET = scalar-logical-expr]\n+   R1161 error-stop-stmt is\n+                      ERROR STOP [ stop-code ] [ , QUIET = scalar-logical-expr]\n+   R1162 stop-code       is scalar-default-char-expr\n+                         or scalar-int-expr\n \n For free-form source code, all standards contain a statement of the form:\n \n@@ -2994,8 +3001,10 @@ static match\n gfc_match_stopcode (gfc_statement st)\n {\n   gfc_expr *e = NULL;\n+  gfc_expr *quiet = NULL;\n   match m;\n   bool f95, f03, f08;\n+  char c;\n \n   /* Set f95 for -std=f95.  */\n   f95 = (gfc_option.allow_std == GFC_STD_OPT_F95);\n@@ -3006,11 +3015,16 @@ gfc_match_stopcode (gfc_statement st)\n   /* Set f08 for -std=f2008.  */\n   f08 = (gfc_option.allow_std == GFC_STD_OPT_F08);\n \n-  /* Look for a blank between STOP and the stop-code for F2008 or later.  */\n-  if (gfc_current_form != FORM_FIXED && !(f95 || f03))\n-    {\n-      char c = gfc_peek_ascii_char ();\n+  /* Plain STOP statement?  */\n+  if (gfc_match_eos () == MATCH_YES)\n+    goto checks;\n+\n+  /* Look for a blank between STOP and the stop-code for F2008 or later.\n+     But allow for F2018's ,QUIET= specifier.  */\n+  c = gfc_peek_ascii_char ();\n \n+  if (gfc_current_form != FORM_FIXED && !(f95 || f03) && c != ',')\n+    {\n       /* Look for end-of-statement.  There is no stop-code.  */\n       if (c == '\\n' || c == '!' || c == ';')\n         goto done;\n@@ -3023,7 +3037,12 @@ gfc_match_stopcode (gfc_statement st)\n \t}\n     }\n \n-  if (gfc_match_eos () != MATCH_YES)\n+  if (c == ' ')\n+    {\n+      gfc_gobble_whitespace ();\n+      c = gfc_peek_ascii_char ();\n+    }\n+  if (c != ',')\n     {\n       int stopcode;\n       locus old_locus;\n@@ -3053,11 +3072,20 @@ gfc_match_stopcode (gfc_statement st)\n \tgoto cleanup;\n       if (m == MATCH_NO)\n \tgoto syntax;\n+    }\n \n-      if (gfc_match_eos () != MATCH_YES)\n-\tgoto syntax;\n+  if (gfc_match (\" , quiet = %e\", &quiet) == MATCH_YES)\n+    {\n+      if (!gfc_notify_std (GFC_STD_F2018, \"QUIET= specifier for %s at %L\",\n+\t\t\t   gfc_ascii_statement (st), &quiet->where))\n+\tgoto cleanup;\n     }\n \n+  if (gfc_match_eos () != MATCH_YES)\n+    goto syntax;\n+\n+checks:\n+\n   if (gfc_pure (NULL))\n     {\n       if (st == ST_ERROR_STOP)\n@@ -3133,10 +3161,22 @@ gfc_match_stopcode (gfc_statement st)\n \t  goto cleanup;\n \t}\n \n-      if (e->ts.type == BT_INTEGER && e->ts.kind != gfc_default_integer_kind)\n+      if (e->ts.type == BT_INTEGER && e->ts.kind != gfc_default_integer_kind\n+\t  && !gfc_notify_std (GFC_STD_F2018,\n+\t\t\t      \"STOP code at %L must be default integer KIND=%d\",\n+\t\t\t      &e->where, (int) gfc_default_integer_kind))\n+\tgoto cleanup;\n+    }\n+\n+  if (quiet != NULL)\n+    {\n+      if (!gfc_simplify_expr (quiet, 0))\n+\tgoto cleanup;\n+\n+      if (quiet->rank != 0)\n \t{\n-\t  gfc_error (\"STOP code at %L must be default integer KIND=%d\",\n-\t\t     &e->where, (int) gfc_default_integer_kind);\n+\t  gfc_error (\"QUIET specifier at %L must be a scalar LOGICAL\",\n+\t\t     &quiet->where);\n \t  goto cleanup;\n \t}\n     }\n@@ -3159,6 +3199,7 @@ gfc_match_stopcode (gfc_statement st)\n     }\n \n   new_st.expr1 = e;\n+  new_st.expr2 = quiet;\n   new_st.ext.stop_code = -1;\n \n   return MATCH_YES;\n@@ -3169,6 +3210,7 @@ gfc_match_stopcode (gfc_statement st)\n cleanup:\n \n   gfc_free_expr (e);\n+  gfc_free_expr (quiet);\n   return MATCH_ERROR;\n }\n "}, {"sha": "753aa27e23f6bb0087a791dcc2c344737f3979f0", "filename": "gcc/fortran/resolve.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ffortran%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ffortran%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.cc?ref=916b809fbfdd2740006270baf549bf22fe9ec3c4", "patch": "@@ -11944,8 +11944,17 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_END_NESTED_BLOCK:\n \tcase EXEC_CYCLE:\n \tcase EXEC_PAUSE:\n+\t  break;\n+\n \tcase EXEC_STOP:\n \tcase EXEC_ERROR_STOP:\n+\t  if (code->expr2 != NULL\n+\t      && (code->expr2->ts.type != BT_LOGICAL\n+\t\t  || code->expr2->rank != 0))\n+\t    gfc_error (\"QUIET specifier at %L must be a scalar LOGICAL\",\n+\t\t       &code->expr2->where);\n+\t  break;\n+\n \tcase EXEC_EXIT:\n \tcase EXEC_CONTINUE:\n \tcase EXEC_DT_END:"}, {"sha": "79096816c6e9fcf6dac3ec68b960d596c1598583", "filename": "gcc/fortran/trans-stmt.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ffortran%2Ftrans-stmt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ffortran%2Ftrans-stmt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.cc?ref=916b809fbfdd2740006270baf549bf22fe9ec3c4", "patch": "@@ -652,11 +652,20 @@ gfc_trans_stop (gfc_code *code, bool error_stop)\n {\n   gfc_se se;\n   tree tmp;\n+  tree quiet;\n \n   /* Start a new block for this statement.  */\n   gfc_init_se (&se, NULL);\n   gfc_start_block (&se.pre);\n \n+  if (code->expr2)\n+    {\n+      gfc_conv_expr_val (&se, code->expr2);\n+      quiet = fold_convert (boolean_type_node, se.expr);\n+    }\n+  else\n+    quiet = boolean_false_node;\n+\n   if (code->expr1 == NULL)\n     {\n       tmp = build_int_cst (size_type_node, 0);\n@@ -669,7 +678,7 @@ gfc_trans_stop (gfc_code *code, bool error_stop)\n \t\t\t\t    ? gfor_fndecl_caf_stop_str\n \t\t\t\t    : gfor_fndecl_stop_string),\n \t\t\t\t 3, build_int_cst (pchar_type_node, 0), tmp,\n-\t\t\t\t boolean_false_node);\n+\t\t\t\t quiet);\n     }\n   else if (code->expr1->ts.type == BT_INTEGER)\n     {\n@@ -683,7 +692,7 @@ gfc_trans_stop (gfc_code *code, bool error_stop)\n \t\t\t\t    ? gfor_fndecl_caf_stop_numeric\n \t\t\t\t    : gfor_fndecl_stop_numeric), 2,\n \t\t\t\t fold_convert (integer_type_node, se.expr),\n-\t\t\t\t boolean_false_node);\n+\t\t\t\t quiet);\n     }\n   else\n     {\n@@ -698,7 +707,7 @@ gfc_trans_stop (gfc_code *code, bool error_stop)\n \t\t\t\t    : gfor_fndecl_stop_string),\n \t\t\t\t 3, se.expr, fold_convert (size_type_node,\n \t\t\t\t\t\t\t   se.string_length),\n-\t\t\t\t boolean_false_node);\n+\t\t\t\t quiet);\n     }\n \n   gfc_add_expr_to_block (&se.pre, tmp);"}, {"sha": "3e00455ba4e5dd5fdf2a01d949c960bbebe85cf7", "filename": "gcc/testsuite/gfortran.dg/stop_1.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstop_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstop_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstop_1.f90?ref=916b809fbfdd2740006270baf549bf22fe9ec3c4", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2018\" }\n+\n+  implicit none\n+  logical      :: q = .false.\n+  integer(2)   :: p = 99\n+  real         :: x = 0.\n+  character(5) :: s = \"stopp\"\n+  print *, \"Hello\"\n+  stop 1, quiet=.false.\n+  stop 2, quiet=q\n+  stop 3, quiet=f(x)\n+  stop; stop!\n+  stop ;stop 4!\n+  stop 5; stop 6\n+  stop 7 ;stop 8\n+  stop 1_1; stop 2_2; stop 4_4; stop 8_8\n+  stop&!\n+       &;stop;&!\n+       stop&!\n+       s&\n+       ; stop \"x\";&!\n+       ; st&!\n+       &op&!\n+       p\n+  stop s\n+  if(f(x))then;stop 9,quiet=.false.;else;stop 10;endif\n+  error stop 4, quiet=.true.\n+  error stop 5 , quiet=.true.\n+  error stop s, quiet=.true.\n+  stop \"last \" // s, quiet=.false._2\n+  stop, quiet=any([.false.])\n+  stop , quiet=any([f(x)])\n+  stop \"stopp\" , quiet=any([f(x)])\n+  stop s, quiet=all([f(x)])\n+  stop42, quiet=.false.            ! { dg-error \"Blank required\" }\n+  stop\"stopp\" , quiet=any([f(x)])  ! { dg-error \"Blank required\" }\n+  stop 8, quiet=([f(x)])           ! { dg-error \"must be a scalar LOGICAL\" }\n+contains\n+  logical function f(x)\n+    real, intent(in) :: x\n+    f = .false.\n+  end function f\n+end"}, {"sha": "24fb91350cd7fa23f6be156b3b2f6c8c38eb61e2", "filename": "gcc/testsuite/gfortran.dg/stop_2.f", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstop_2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstop_2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstop_2.f?ref=916b809fbfdd2740006270baf549bf22fe9ec3c4", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2018\" }\n+\n+      implicit none\n+      logical      :: q = .false.\n+      integer(2)   :: p = 99\n+      real         :: x = 0.\n+      character(5) :: s = \"stopp\"\n+      stop 1, quiet=.false.\n+      stop 2, quiet=q\n+      stop 3, quiet=f(x)\n+      stop42,quiet=.false.\n+      error stop 4, quiet=.true.\n+      error stop 5 , quiet=.true.\n+      stop1_1;stop2_2;stop4_4;stop8_8\n+      stopp;stops\n+      st\n+     &op42\n+      stop, quiet=any([.false.])\n+      stop , quiet=any([f(x)])\n+      stop\"stopp\",quiet=any([f(x)])\n+      stop \"stopp\" , quiet=any([f(x)])\n+      s to ps,quiet=all([f(x)])\n+      e r r o r s t o p 4 3 , q u i e t = . t r u e .\n+      errorstop\"stopp\",quiet=.not.f(x)\n+      contains\n+      logical function f(x)\n+      real, intent(in) :: x\n+      f = .false.\n+      end function f\n+      end"}, {"sha": "bc153dd3455485046fc88a10565c64a4bdaed6d4", "filename": "gcc/testsuite/gfortran.dg/stop_3.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstop_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstop_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstop_3.f90?ref=916b809fbfdd2740006270baf549bf22fe9ec3c4", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+! F95 and F2003 do not require a blank after STOP\n+\n+  implicit none\n+  integer,      parameter :: p = 99\n+  character(*), parameter :: s = \"stopp\"\n+  stop1\n+  stop2!\n+  stop3;stop4!\n+  stopp\n+  stop&!\n+       &;stop;&!\n+       stop&!\n+       s&\n+       ;stop\"x\";&!\n+       ;st&!\n+       &op&!\n+       p\n+  stops\n+  stop\"last \" // s\n+end"}, {"sha": "f01b3ae16c11ce3054fa9a7b7e53ba5e3a3f3b31", "filename": "gcc/testsuite/gfortran.dg/stop_4.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstop_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b809fbfdd2740006270baf549bf22fe9ec3c4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstop_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstop_4.f90?ref=916b809fbfdd2740006270baf549bf22fe9ec3c4", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original -std=f2018\" }\n+! Check that the QUIET specifier to shut up a STOP statement is passed properly\n+\n+program p\n+  logical(1) :: q = .true.  ! using kind=1 to simplify scanning of tree dump\n+  stop 0, quiet=q\n+  stop 1, quiet=.true.\n+  stop 2                    ! the \"noisy\" default\n+end program p\n+\n+! { dg-final { scan-tree-dump \"_gfortran_stop_numeric \\\\(0, q\\\\)\" \"original\" } }\n+! { dg-final { scan-tree-dump \"_gfortran_stop_numeric \\\\(1, 1\\\\)\" \"original\" } }\n+! { dg-final { scan-tree-dump \"_gfortran_stop_numeric \\\\(2, 0\\\\)\" \"original\" } }"}]}