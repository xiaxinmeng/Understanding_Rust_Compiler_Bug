{"sha": "76f9c7f44fffb0b03266730b137313fe79f1c99e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZmOWM3ZjQ0ZmZmYjBiMDMyNjY3MzBiMTM3MzEzZmU3OWYxYzk5ZQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-02-03T10:31:16Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-05-07T09:29:09Z"}, "message": "[Ada] Variable-sized node types\n\ngcc/ada/\n\n\t* atree.ads, atree.adb: Major rewrite to support variable-sized\n\tnode types. Add pragmas Suppress and Assertion_Policy.  We now\n\thave an extra level of indirection: Node_Offsets is a table\n\tmapping Node_Ids to the offset of the start of each node in\n\tSlots. Slots is a table containing one or more contiguous slots\n\tfor each node. Each slot is a 32-bit unchecked union that can\n\tcontain any mixture of 1, 2, 4, 8, and 32-bit fields that fits.\n\tThe old low-level getters and setters (e.g.  Flag123) are\n\tremoved.\n\t* gen_il-fields.ads, gen_il-gen-gen_entities.adb,\n\tgen_il-gen-gen_nodes.adb, gen_il-gen.adb, gen_il-gen.ads,\n\tgen_il-main.adb, gen_il-types.ads, gen_il-utils.adb,\n\tgen_il-utils.ads, gen_il.adb, gen_il.ads: New gen_il program\n\tthat generates various Ada and C++ files. In particular, the\n\tfollowing files are generated by gen_il: einfo-entities.adb\n\teinfo-entities.ads, gnatvsn.ads, nmake.adb, nmake.ads,\n\tseinfo.ads, seinfo_tables.adb, seinfo_tables.ads,\n\tsinfo-nodes.adb, sinfo-nodes.ads, einfo.h, and sinfo.h.\n\t* sinfo-utils.adb, sinfo-utils.ads, einfo-utils.adb,\n\teinfo-utils.ads: New files containing code that needs to refer\n\tto Sinfo.Nodes and Einfo.Entities. This code is mostly moved\n\there from Sinfo and Einfo to break cycles.\n\t* back_end.adb: Pass node_offsets_ptr and slots_ptr to gigi,\n\tinstead of nodes_ptr and flags_ptr. The Nodes and Flags tables\n\tno longer exist. (Note that gigi never used the Flags table.)\n\t* sinfo-cn.ads (Change_Identifier_To_Defining_Identifier,\n\tChange_Character_Literal_To_Defining_Character_Literal,\n\tChange_Operator_Symbol_To_Defining_Operator_Symbol): Turn N into\n\tan IN formal.\n\t* sinfo-cn.adb: Update.  Add assertions, which can be removed at\n\tsome point.  Rewrite to use higher-level facilities.  Make sure\n\tvanishing fields are zeroed out.  Add with/use for new packages.\n\t* sem_util.adb: Remove \"Assert(False)\" immediately followed by\n\t\"raise Program_Error\".  Use higher-level facilities such as\n\tWalk_Sinfo_Fields instead of depending on low-level Set_FieldN\n\troutines that no longer exist. Use Get_Comes_From_Source_Default\n\tinstead of Default_Node.Comes_From_Source (Default_Node no\n\tlonger exists).  Use Set_Basic_Convention instead of\n\tBasic_Set_Convention.  Add with/use for new packages.\n\t* sem_util.ads: The Convention field had getter Convention and\n\tsetter Basic_Set_Convention. Make that more uniform: there is\n\tnow a field called Basic_Convention, with Basic_Convention and\n\tSet_Basic_Convention as getter/setter, and write Convention and\n\tSet_Convention here.\n\t* nlists.adb: Rewrite to use abstractions, rather then depending\n\ton low-level implementation details of Atree. Necessary because\n\tthose details have changed. Add with/use for new packages.\n\t* sem_ch12.adb: Use higher-level facilities such as\n\tWalk_Sinfo_Fields instead of depending on low-level Set_FieldN\n\troutines that no longer exist. Add with/use for new packages.\n\t* exp_cg.adb, sem_ch10.adb, sem_ch4.adb, sem_eval.adb,\n\tsem_prag.adb, sem_warn.adb: Change expanded names to refer to\n\tthe new packages for things that moved. Add with/use for new\n\tpackages.\n\t* sem_ch3.adb: Likewise. Reinitialize vanishing fields.\n\t* exp_disp.adb: Likewise. Remove failing assertion.\n\t* sinfo.ads, einfo.ads: Remove code that is now generated into\n\tSinfo.Nodes and Einfo.Entities.\n\t* sinfo.adb, einfo.adb: Replace bodies with \"pragma No_Body;\".\n\tWe should delete these at some point, but No_Body makes make\n\tfiles easier. Some code is moved to Sinfo.Nodes, Einfo.Entities,\n\tSinfo.Utils, and Einfo.Utils. Some is no longer necessary.\n\t* treepr.adb: Rewrite to use new tables. We no longer need\n\ttreeprs.ads.\n\t* treepr.ads: Add comment.\n\t* types.ads: Move types Component_Alignment_Kind and\n\tFloat_Rep_Kind here.\n\t* atree.h: Major update to match atree.ads changes.  Add slot\n\ttypes, for use by getters/setters.\n\t* types.h: Move types Component_Alignment_Kind and\n\tFloat_Rep_Kind here.\n\t* fe.h: Rewrite to deal with code that has changed or moved from\n\tAtree, Sinfo, Einfo.\n\t* nlists.h: Move some code to fe.h.\n\t* alloc.ads: Split Nodes_* constants into Node_Offsets and\n\tSlots, because Atree has two separate tables.  Increase values.\n\tRemove Nodes_Release_Threshold. Improve comment.\n\t* debug.adb, gnat1drv.adb: Remove obsolete gnatd.A and gnatd.N\n\tswitches.  Add with/use for new packages.\n\t* opt.ads: Minor comment fix.\n\t* aspects.adb, checks.adb, comperr.adb, contracts.adb,\n\tcstand.adb, debug_a.adb, errout.adb, eval_fat.adb, exp_aggr.adb,\n\texp_atag.adb, exp_attr.adb, exp_ch11.adb, exp_ch12.adb,\n\texp_ch13.adb, exp_ch2.adb, exp_ch3.adb, exp_ch4.adb,\n\texp_ch5.adb, exp_ch6.adb, exp_ch7.adb, exp_ch8.adb, exp_ch9.adb,\n\texp_code.adb, exp_dbug.adb, exp_dist.adb, exp_fixd.adb,\n\texp_imgv.adb, exp_intr.adb, exp_pakd.adb, exp_prag.adb,\n\texp_put_image.adb, exp_sel.adb, exp_smem.adb, exp_spark.adb,\n\texp_strm.adb, exp_tss.adb, exp_unst.adb, exp_util.adb,\n\texp_util.ads, expander.adb, freeze.adb, frontend.adb,\n\tget_targ.ads, ghost.adb, gnat_cuda.adb, impunit.adb, inline.adb,\n\titypes.adb, itypes.ads, layout.adb, lib.adb, lib-load.adb,\n\tlib-writ.adb, lib-xref.adb, lib-xref.ads,\n\tlib-xref-spark_specific.adb, live.adb, par.adb, par_sco.adb,\n\tpprint.adb, repinfo.adb, restrict.adb, rtsfind.adb, scil_ll.adb,\n\tscn.adb, sem.adb, sem.ads, sem_aggr.adb, sem_attr.adb,\n\tsem_aux.adb, sem_case.adb, sem_cat.adb, sem_ch11.adb,\n\tsem_ch13.adb, sem_ch2.adb, sem_ch5.adb, sem_ch6.adb,\n\tsem_ch7.adb, sem_ch8.adb, sem_ch9.adb, sem_dim.adb,\n\tsem_disp.adb, sem_dist.adb, sem_elab.adb, sem_elim.adb,\n\tsem_intr.adb, sem_mech.adb, sem_res.adb, sem_scil.adb,\n\tsem_smem.adb, sem_type.adb, set_targ.ads, sinput.adb,\n\tsinput-l.adb, sprint.adb, style.adb, styleg.adb, tbuild.adb,\n\ttbuild.ads, uname.adb: Add with/use for new packages.\n\t* libgnat/a-stoubu.adb, libgnat/a-stouut.adb: Simplify to ease\n\tbootstrap.\n\t* libgnat/a-stobfi.adb, libgnat/a-stoufi.adb (Create_File,\n\tCreate_New_File): Create file in binary format, to avoid\n\tintroducing unwanted text conversions on Windows. Simplify to\n\tease bootstrap.\n\t* libgnat/a-stteou__bootstrap.ads: New.\n\t* ceinfo.adb, csinfo.adb, nmake.adt, treeprs.adt, xeinfo.adb,\n\txnmake.adb, xsinfo.adb, xtreeprs.adb: Delete.\n\t* Make-generated.in: Build and run the gen_il program to\n\tgenerate files. The files are generated in the ada/gen_il\n\tsubdirectory, and then moved up to ada.  We rely on gnatmake (as\n\topposed to make) to build the gen_il program efficiently (i.e.\n\tdon't do anything if the sources didn't change).\n\t* gcc-interface/Makefile.in (ADAFLAGS): Add -gnatU.\n\t(GNATMAKE_OBJS): Add new object files.\n\t(GENERATED_FILES_FOR_TOOLS): New variable.\n\t(../stamp-tools): Create a link for all\n\tGENERATED_FILES_FOR_TOOLS.\n\t* gcc-interface/Make-lang.in (GNAT_ADA_OBJS): Add new object\n\tfiles.  Remove ada/treeprs.o.\n\t(GNATBIND_OBJS): Add new object files.\n\t(ada.mostlyclean): Remove ada/sdefault.adb and add\n\tada/stamp-gen_il.\n\t(ada.maintainer-clean): Remove ada/treeprs.ads.\n\t(update-sources): Remove obsolete target.\n\t(ada_generated_files): Rename to...\n\t(ADA_GENERATED_FILES): ... this.  Add new source files.  Add\n\tcomment.\n\n\t* gcc-interface/trans.c: Remove obsolete Nodes_Ptr and\n\tFlags_ptr.  Add Node_Offsets_Ptr and Slots_Ptr, which point to\n\tthe corresponding tables in Atree.\n\t* gcc-interface/gigi.h (gigi): New parameters for initializing\n\tNode_Offsets_Ptr and Slots_Ptr.\n\t* gcc-interface/decl.c: Numeric_Kind,\n\tDiscrete_Or_Fixed_Point_Kind, and Record_Kind were\n\tnonhierarchical, and were therefore removed for simplicity.\n\tReplace uses with calls to Is_In_... functions.\n\ngnattools/\n\n\t* Makefile.in (GENERATED_FILES_FOR_TOOLS): New variable.\n\t($(GCC_DIR)/stamp-tools): Walk it for the first copy operation.", "tree": {"sha": "8c77fa6bd5661f0ffb427f7003a21b9a46dc30d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c77fa6bd5661f0ffb427f7003a21b9a46dc30d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76f9c7f44fffb0b03266730b137313fe79f1c99e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76f9c7f44fffb0b03266730b137313fe79f1c99e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76f9c7f44fffb0b03266730b137313fe79f1c99e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76f9c7f44fffb0b03266730b137313fe79f1c99e/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "476ed6bf66ab20e22ae4b3da0fd7fd94753f2334", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334", "html_url": "https://github.com/Rust-GCC/gccrs/commit/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334"}], "stats": {"total": 62117, "additions": 18305, "deletions": 43812}, "files": [{"sha": "237444c7a26b4374b2e8350dd7f0dc2791b10bcd", "filename": "gcc/ada/Make-generated.in", "status": "modified", "additions": 79, "deletions": 59, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2FMake-generated.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2FMake-generated.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-generated.in?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -2,10 +2,6 @@\n \n # Note: can't use ?= here, not supported by older versions of GNU Make\n \n-ifeq ($(origin ADA_GEN_SUBDIR), undefined)\n-ADA_GEN_SUBDIR=ada\n-endif\n-\n ifeq ($(origin CP), undefined)\n CP=cp\n endif\n@@ -14,60 +10,84 @@ ifeq ($(origin MKDIR), undefined)\n MKDIR=mkdir -p\n endif\n \n-ifeq ($(origin MOVE_IF_CHANGE), undefined)\n-MOVE_IF_CHANGE=mv -f\n-endif\n+fsrcdir := $(shell cd $(srcdir);${PWD_COMMAND})\n+\n+GEN_IL_INCLUDES = -I$(fsrcdir)/ada\n+GEN_IL_FLAGS = -a -q -g -gnata -j0 -gnat2012 -gnatw.g -gnatyg -gnatU $(GEN_IL_INCLUDES)\n+\n+.PHONY: do_gen_il\n+do_gen_il:\n+\t$(MKDIR) ada/gen_il\n+\t$(MKDIR) ada/generated\n+\t# Copy recent runtime files needed by gen_il that may not be available\n+\t# in the base compiler.\n+\t$(CP) -f $(fsrcdir)/ada/libgnat/a-sto*.ad? ada/gen_il\n+\t$(CP) -f $(fsrcdir)/ada/libgnat/a-stteou__bootstrap.ads ada/gen_il/a-stteou.ads\n+\tcd ada/gen_il ; gnatmake $(GEN_IL_FLAGS) gen_il-main.adb\n+\t# ignore errors when running gen_il-main due to bootstrap\n+\t# considerations\n+\t-cd ada/gen_il ; ./gen_il-main\n+\n+ada/seinfo_tables.ads: do_gen_il\n+\t$(fsrcdir)/../move-if-change ada/gen_il/seinfo_tables.ads ada/seinfo_tables.ads\n+\n+ada/seinfo_tables.adb: do_gen_il\n+\t$(fsrcdir)/../move-if-change ada/gen_il/seinfo_tables.adb ada/seinfo_tables.adb\n+\n+# We need -gnatX to compile seinfo_tables, because it uses extensions. This\n+# target is not currently used when building gnat, because these extensions\n+# would cause bootstrapping with older compilers to fail. You can call it by\n+# hand, as a sanity check that these files are legal.\n+ada/seinfo_tables.o: ada/seinfo_tables.ads ada/seinfo_tables.adb\n+\tcd ada ; time gnatmake $(GEN_IL_INCLUDES) seinfo_tables.adb -gnatU -gnatX\n+\n+ada/sinfo.h: do_gen_il\n+\t$(fsrcdir)/../move-if-change ada/gen_il/sinfo.h ada/sinfo.h\n+\n+ada/einfo.h: do_gen_il\n+\t$(fsrcdir)/../move-if-change ada/gen_il/einfo.h ada/einfo.h\n+\n+ada/nmake.ads: do_gen_il\n+\t$(fsrcdir)/../move-if-change ada/gen_il/nmake.ads ada/nmake.ads\n+\t$(CP) ada/nmake.ads ada/generated\n+\n+ada/nmake.adb: do_gen_il\n+\t$(fsrcdir)/../move-if-change ada/gen_il/nmake.adb ada/nmake.adb\n+\t$(CP) ada/nmake.adb ada/generated\n+\n+ada/seinfo.ads: do_gen_il\n+\t$(fsrcdir)/../move-if-change ada/gen_il/seinfo.ads ada/seinfo.ads\n+\t$(CP) ada/seinfo.ads ada/generated\n+\n+ada/sinfo-nodes.ads: do_gen_il\n+\t$(fsrcdir)/../move-if-change ada/gen_il/sinfo-nodes.ads ada/sinfo-nodes.ads\n+\t$(CP) ada/sinfo-nodes.ads ada/generated\n+\n+ada/sinfo-nodes.adb: do_gen_il\n+\t$(fsrcdir)/../move-if-change ada/gen_il/sinfo-nodes.adb ada/sinfo-nodes.adb\n+\t$(CP) ada/sinfo-nodes.adb ada/generated\n+\n+ada/einfo-entities.ads: do_gen_il\n+\t$(fsrcdir)/../move-if-change ada/gen_il/einfo-entities.ads ada/einfo-entities.ads\n+\t$(CP) ada/einfo-entities.ads ada/generated\n+\n+ada/einfo-entities.adb: do_gen_il\n+\t$(fsrcdir)/../move-if-change ada/gen_il/einfo-entities.adb ada/einfo-entities.adb\n+\t$(CP) ada/einfo-entities.adb ada/generated\n+\n+ada/snames.h ada/snames.ads ada/snames.adb : ada/stamp-snames ; @true\n+ada/stamp-snames : ada/snames.ads-tmpl ada/snames.adb-tmpl ada/snames.h-tmpl ada/xsnamest.adb ada/xutil.ads ada/xutil.adb\n+\t-$(MKDIR) ada/bldtools/snamest\n+\t$(RM) $(addprefix ada/bldtools/snamest/,$(notdir $^))\n+\t$(CP) $^ ada/bldtools/snamest\n+\tcd ada/bldtools/snamest; gnatmake -q xsnamest ; ./xsnamest\n+\t$(fsrcdir)/../move-if-change ada/bldtools/snamest/snames.ns ada/snames.ads\n+\t$(fsrcdir)/../move-if-change ada/bldtools/snamest/snames.nb ada/snames.adb\n+\t$(fsrcdir)/../move-if-change ada/bldtools/snamest/snames.nh ada/snames.h\n+\ttouch ada/stamp-snames\n \n-.PHONY: ada_extra_files\n-ada_extra_files : $(ADA_GEN_SUBDIR)/treeprs.ads $(ADA_GEN_SUBDIR)/einfo.h $(ADA_GEN_SUBDIR)/sinfo.h $(ADA_GEN_SUBDIR)/nmake.adb \\\n-\t$(ADA_GEN_SUBDIR)/nmake.ads $(ADA_GEN_SUBDIR)/snames.ads $(ADA_GEN_SUBDIR)/snames.adb $(ADA_GEN_SUBDIR)/snames.h\n-\n-# We delete the files before copying, below, in case they are read-only.\n-\n-$(ADA_GEN_SUBDIR)/treeprs.ads : $(ADA_GEN_SUBDIR)/treeprs.adt $(ADA_GEN_SUBDIR)/sinfo.ads $(ADA_GEN_SUBDIR)/xtreeprs.adb\n-\t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/treeprs\n-\t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/treeprs/,$(notdir $^))\n-\t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/treeprs\n-\t(cd $(ADA_GEN_SUBDIR)/bldtools/treeprs; gnatmake -q xtreeprs ; ./xtreeprs treeprs.ads )\n-\t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/treeprs/treeprs.ads $(ADA_GEN_SUBDIR)/treeprs.ads\n-\n-$(ADA_GEN_SUBDIR)/einfo.h : $(ADA_GEN_SUBDIR)/einfo.ads $(ADA_GEN_SUBDIR)/einfo.adb $(ADA_GEN_SUBDIR)/xeinfo.adb $(ADA_GEN_SUBDIR)/ceinfo.adb\n-\t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/einfo\n-\t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/einfo/,$(notdir $^))\n-\t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/einfo\n-\t(cd $(ADA_GEN_SUBDIR)/bldtools/einfo; gnatmake -q xeinfo ; ./xeinfo einfo.h )\n-\t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/einfo/einfo.h $(ADA_GEN_SUBDIR)/einfo.h\n-\n-$(ADA_GEN_SUBDIR)/sinfo.h : $(ADA_GEN_SUBDIR)/sinfo.ads $(ADA_GEN_SUBDIR)/sinfo.adb $(ADA_GEN_SUBDIR)/xsinfo.adb $(ADA_GEN_SUBDIR)/csinfo.adb\n-\t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/sinfo\n-\t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/sinfo/,$(notdir $^))\n-\t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/sinfo\n-\t(cd $(ADA_GEN_SUBDIR)/bldtools/sinfo; gnatmake -q xsinfo ; ./xsinfo sinfo.h )\n-\t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/sinfo/sinfo.h $(ADA_GEN_SUBDIR)/sinfo.h\n-\n-$(ADA_GEN_SUBDIR)/snames.h $(ADA_GEN_SUBDIR)/snames.ads $(ADA_GEN_SUBDIR)/snames.adb : $(ADA_GEN_SUBDIR)/stamp-snames ; @true\n-$(ADA_GEN_SUBDIR)/stamp-snames : $(ADA_GEN_SUBDIR)/snames.ads-tmpl $(ADA_GEN_SUBDIR)/snames.adb-tmpl $(ADA_GEN_SUBDIR)/snames.h-tmpl $(ADA_GEN_SUBDIR)/xsnamest.adb $(ADA_GEN_SUBDIR)/xutil.ads $(ADA_GEN_SUBDIR)/xutil.adb\n-\t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/snamest\n-\t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/snamest/,$(notdir $^))\n-\t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/snamest\n-\t(cd $(ADA_GEN_SUBDIR)/bldtools/snamest; gnatmake -q xsnamest ; ./xsnamest )\n-\t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/snamest/snames.ns $(ADA_GEN_SUBDIR)/snames.ads\n-\t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/snamest/snames.nb $(ADA_GEN_SUBDIR)/snames.adb\n-\t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/snamest/snames.nh $(ADA_GEN_SUBDIR)/snames.h\n-\ttouch $(ADA_GEN_SUBDIR)/stamp-snames\n-\n-$(ADA_GEN_SUBDIR)/nmake.adb $(ADA_GEN_SUBDIR)/nmake.ads: $(ADA_GEN_SUBDIR)/stamp-nmake ; @true\n-$(ADA_GEN_SUBDIR)/stamp-nmake: $(ADA_GEN_SUBDIR)/sinfo.ads $(ADA_GEN_SUBDIR)/nmake.adt $(ADA_GEN_SUBDIR)/xnmake.adb $(ADA_GEN_SUBDIR)/xutil.ads $(ADA_GEN_SUBDIR)/xutil.adb\n-\t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/nmake\n-\t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/nmake/,$(notdir $^))\n-\t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/nmake\n-\t(cd $(ADA_GEN_SUBDIR)/bldtools/nmake; gnatmake -q xnmake ; ./xnmake -b nmake.adb ; ./xnmake -s nmake.ads)\n-\t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/nmake/nmake.ads $(ADA_GEN_SUBDIR)/nmake.ads\n-\t$(MOVE_IF_CHANGE) $(ADA_GEN_SUBDIR)/bldtools/nmake/nmake.adb $(ADA_GEN_SUBDIR)/nmake.adb\n-\ttouch $(ADA_GEN_SUBDIR)/stamp-nmake\n-\n-$(ADA_GEN_SUBDIR)/sdefault.adb: $(ADA_GEN_SUBDIR)/stamp-sdefault ; @true\n-$(ADA_GEN_SUBDIR)/stamp-sdefault : $(srcdir)/version.c Makefile\n+ada/sdefault.adb: ada/stamp-sdefault ; @true\n+ada/stamp-sdefault : $(srcdir)/version.c Makefile\n \t$(ECHO) \"pragma Style_Checks (Off);\" >tmp-sdefault.adb\n \t$(ECHO) \"with Osint; use Osint;\" >>tmp-sdefault.adb\n \t$(ECHO) \"package body Sdefault is\" >>tmp-sdefault.adb\n@@ -93,5 +113,5 @@ $(ADA_GEN_SUBDIR)/stamp-sdefault : $(srcdir)/version.c Makefile\n \t$(ECHO) \"      return Relocate_Path (S0, S4);\" >>tmp-sdefault.adb\n \t$(ECHO) \"   end Search_Dir_Prefix;\" >>tmp-sdefault.adb\n \t$(ECHO) \"end Sdefault;\" >> tmp-sdefault.adb\n-\t$(MOVE_IF_CHANGE) tmp-sdefault.adb $(ADA_GEN_SUBDIR)/sdefault.adb\n-\ttouch $(ADA_GEN_SUBDIR)/stamp-sdefault\n+\t$(fsrcdir)/../move-if-change tmp-sdefault.adb ada/sdefault.adb\n+\ttouch ada/stamp-sdefault"}, {"sha": "85944c987cf80a807e0895f095600049e801ef40", "filename": "gcc/ada/alloc.ads", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Falloc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Falloc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falloc.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -35,7 +35,7 @@\n \n package Alloc is\n \n-   --  The comment shows the unit in which the table is defined\n+   --  The comment shows the unit in which the tables are defined\n \n    All_Interp_Initial               : constant := 1_000;      -- Sem_Type\n    All_Interp_Increment             : constant := 100;\n@@ -94,9 +94,11 @@ package Alloc is\n    Names_Initial                    : constant := 6_000;      -- Namet\n    Names_Increment                  : constant := 100;\n \n-   Nodes_Initial                    : constant := 50_000;     -- Atree\n-   Nodes_Increment                  : constant := 100;\n-   Nodes_Release_Threshold          : constant := 100_000;\n+   Node_Offsets_Initial             : constant := 500_000;    -- Atree, Nlists\n+   Node_Offsets_Increment           : constant := 100;\n+\n+   Slots_Initial                    : constant := 2_000_000;  -- Atree\n+   Slots_Increment                  : constant := 100;\n \n    Notes_Initial                    : constant := 100;        -- Lib\n    Notes_Increment                  : constant := 200;"}, {"sha": "2cdd219f1de51e4061113016ba7fa737938e859f", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,9 +24,13 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Nlists;   use Nlists;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n \n with GNAT.HTable;\n \n@@ -224,7 +228,7 @@ package body Aspects is\n       while Present (Item) loop\n          if Nkind (Item) = N_Aspect_Specification\n            and then Get_Aspect_Id (Item) = A\n-           and then Class_Present = Sinfo.Class_Present (Item)\n+           and then Class_Present = Sinfo.Nodes.Class_Present (Item)\n          then\n             return Item;\n          end if;\n@@ -248,7 +252,7 @@ package body Aspects is\n          Spec := First (Aspect_Specifications (Decl));\n          while Present (Spec) loop\n             if Get_Aspect_Id (Spec) = A\n-              and then Class_Present = Sinfo.Class_Present (Spec)\n+              and then Class_Present = Sinfo.Nodes.Class_Present (Spec)\n             then\n                return Spec;\n             end if;"}, {"sha": "08b7d05c50b6c16d1072447da3d1b3002a1dc8b3", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 1833, "deletions": 8105, "changes": 9938, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e"}, {"sha": "473ae9767aa55962266fe8f98c4ad9f247063e99", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 352, "deletions": 3424, "changes": 3776, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e"}, {"sha": "6b8f7b9c50d60592d8b52ea68dddbde111ee90dd", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 131, "deletions": 810, "changes": 941, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -35,353 +35,12 @@\n extern \"C\" {\n #endif\n \n-/* Structure used for the first part of the node in the case where we have\n-   an Nkind.  */\n-\n-struct NFK\n-{\n-  Boolean      is_extension  :  1;\n-  Boolean      pflag1        :  1;\n-  Boolean      pflag2        :  1;\n-  Boolean      in_list       :  1;\n-  Boolean      has_aspects   :  1;\n-  Boolean      rewrite_ins   :  1;\n-  Boolean      analyzed      :  1;\n-  Boolean      c_f_s\t     :  1;\n-  Boolean      error_posted  :  1;\n-\n-  Boolean      flag4  :  1;\n-  Boolean      flag5  :  1;\n-  Boolean      flag6  :  1;\n-  Boolean      flag7  :  1;\n-  Boolean      flag8  :  1;\n-  Boolean      flag9  :  1;\n-  Boolean      flag10 :  1;\n-\n-  Boolean      flag11 :  1;\n-  Boolean      flag12 :  1;\n-  Boolean      flag13 :  1;\n-  Boolean      flag14 :  1;\n-  Boolean      flag15 :  1;\n-  Boolean      flag16 :  1;\n-  Boolean      flag17 :  1;\n-  Boolean      flag18 :  1;\n-\n-  unsigned char kind;\n-};\n-\n-/* Structure for the first part of a node when Nkind is not present by\n-   extra flag bits are.  */\n-\n-struct NFNK\n-{\n-  Boolean      is_extension  :  1;\n-  Boolean      pflag1        :  1;\n-  Boolean      pflag2        :  1;\n-  Boolean      in_list       :  1;\n-  Boolean      has_aspects   :  1;\n-  Boolean      rewrite_ins   :  1;\n-  Boolean      analyzed      :  1;\n-  Boolean      c_f_s\t     :  1;\n-  Boolean      error_posted  :  1;\n-\n-  Boolean      flag4  :  1;\n-  Boolean      flag5  :  1;\n-  Boolean      flag6  :  1;\n-  Boolean      flag7  :  1;\n-  Boolean      flag8  :  1;\n-  Boolean      flag9  :  1;\n-  Boolean      flag10 :  1;\n-\n-  Boolean      flag11 :  1;\n-  Boolean      flag12 :  1;\n-  Boolean      flag13 :  1;\n-  Boolean      flag14 :  1;\n-  Boolean      flag15 :  1;\n-  Boolean      flag16 :  1;\n-  Boolean      flag17 :  1;\n-  Boolean      flag18 :  1;\n-\n-  Boolean      flag65 :  1;\n-  Boolean      flag66 :  1;\n-  Boolean      flag67 :  1;\n-  Boolean      flag68 :  1;\n-  Boolean      flag69 :  1;\n-  Boolean      flag70 :  1;\n-  Boolean      flag71 :  1;\n-  Boolean      flag72 :  1;\n-};\n-\n-/* Structure used for extra flags in third component overlaying Field12 */\n-struct Flag_Word\n-{\n-  Boolean      flag73\t    :  1;\n-  Boolean      flag74\t    :  1;\n-  Boolean      flag75\t    :  1;\n-  Boolean      flag76\t    :  1;\n-  Boolean      flag77\t    :  1;\n-  Boolean      flag78\t    :  1;\n-  Boolean      flag79\t    :  1;\n-  Boolean      flag80\t    :  1;\n-  Boolean      flag81\t    :  1;\n-  Boolean      flag82\t    :  1;\n-  Boolean      flag83\t    :  1;\n-  Boolean      flag84\t    :  1;\n-  Boolean      flag85\t    :  1;\n-  Boolean      flag86\t    :  1;\n-  Boolean      flag87\t    :  1;\n-  Boolean      flag88\t    :  1;\n-  Boolean      flag89\t    :  1;\n-  Boolean      flag90\t    :  1;\n-  Boolean      flag91\t    :  1;\n-  Boolean      flag92\t    :  1;\n-  Boolean      flag93\t    :  1;\n-  Boolean      flag94\t    :  1;\n-  Boolean      flag95\t    :  1;\n-  Boolean      flag96\t    :  1;\n-  Byte         convention   :  8;\n-};\n-\n-/* Structure used for extra flags in fourth component overlaying Field12 */\n-struct Flag_Word2\n-{\n-  Boolean      flag97\t    :  1;\n-  Boolean      flag98\t    :  1;\n-  Boolean      flag99\t    :  1;\n-  Boolean      flag100\t    :  1;\n-  Boolean      flag101\t    :  1;\n-  Boolean      flag102\t    :  1;\n-  Boolean      flag103\t    :  1;\n-  Boolean      flag104\t    :  1;\n-  Boolean      flag105\t    :  1;\n-  Boolean      flag106\t    :  1;\n-  Boolean      flag107\t    :  1;\n-  Boolean      flag108\t    :  1;\n-  Boolean      flag109\t    :  1;\n-  Boolean      flag110\t    :  1;\n-  Boolean      flag111\t    :  1;\n-  Boolean      flag112\t    :  1;\n-  Boolean      flag113\t    :  1;\n-  Boolean      flag114\t    :  1;\n-  Boolean      flag115\t    :  1;\n-  Boolean      flag116\t    :  1;\n-  Boolean      flag117\t    :  1;\n-  Boolean      flag118\t    :  1;\n-  Boolean      flag119\t    :  1;\n-  Boolean      flag120\t    :  1;\n-  Boolean      flag121\t    :  1;\n-  Boolean      flag122\t    :  1;\n-  Boolean      flag123\t    :  1;\n-  Boolean      flag124\t    :  1;\n-  Boolean      flag125\t    :  1;\n-  Boolean      flag126\t    :  1;\n-  Boolean      flag127\t    :  1;\n-  Boolean      flag128\t    :  1;\n-};\n-\n-/* Structure used for extra flags in fourth component overlaying Field11 */\n-struct Flag_Word3\n-{\n-  Boolean      flag152\t    :  1;\n-  Boolean      flag153\t    :  1;\n-  Boolean      flag154\t    :  1;\n-  Boolean      flag155\t    :  1;\n-  Boolean      flag156\t    :  1;\n-  Boolean      flag157\t    :  1;\n-  Boolean      flag158\t    :  1;\n-  Boolean      flag159\t    :  1;\n-\n-  Boolean      flag160\t    :  1;\n-  Boolean      flag161\t    :  1;\n-  Boolean      flag162\t    :  1;\n-  Boolean      flag163\t    :  1;\n-  Boolean      flag164\t    :  1;\n-  Boolean      flag165\t    :  1;\n-  Boolean      flag166\t    :  1;\n-  Boolean      flag167\t    :  1;\n-\n-  Boolean      flag168\t    :  1;\n-  Boolean      flag169\t    :  1;\n-  Boolean      flag170\t    :  1;\n-  Boolean      flag171\t    :  1;\n-  Boolean      flag172\t    :  1;\n-  Boolean      flag173\t    :  1;\n-  Boolean      flag174\t    :  1;\n-  Boolean      flag175\t    :  1;\n-\n-  Boolean      flag176\t    :  1;\n-  Boolean      flag177\t    :  1;\n-  Boolean      flag178\t    :  1;\n-  Boolean      flag179\t    :  1;\n-  Boolean      flag180\t    :  1;\n-  Boolean      flag181\t    :  1;\n-  Boolean      flag182\t    :  1;\n-  Boolean      flag183\t    :  1;\n-};\n-\n-/* Structure used for extra flags in fifth component overlaying Field12 */\n-struct Flag_Word4\n-{\n-  Boolean      flag184\t    :  1;\n-  Boolean      flag185\t    :  1;\n-  Boolean      flag186\t    :  1;\n-  Boolean      flag187\t    :  1;\n-  Boolean      flag188\t    :  1;\n-  Boolean      flag189\t    :  1;\n-  Boolean      flag190\t    :  1;\n-  Boolean      flag191\t    :  1;\n-\n-  Boolean      flag192\t    :  1;\n-  Boolean      flag193\t    :  1;\n-  Boolean      flag194\t    :  1;\n-  Boolean      flag195\t    :  1;\n-  Boolean      flag196\t    :  1;\n-  Boolean      flag197\t    :  1;\n-  Boolean      flag198\t    :  1;\n-  Boolean      flag199\t    :  1;\n-\n-  Boolean      flag200\t    :  1;\n-  Boolean      flag201\t    :  1;\n-  Boolean      flag202\t    :  1;\n-  Boolean      flag203\t    :  1;\n-  Boolean      flag204\t    :  1;\n-  Boolean      flag205\t    :  1;\n-  Boolean      flag206\t    :  1;\n-  Boolean      flag207\t    :  1;\n-\n-  Boolean      flag208      :  1;\n-  Boolean      flag209\t    :  1;\n-  Boolean      flag210\t    :  1;\n-  Boolean      flag211\t    :  1;\n-  Boolean      flag212\t    :  1;\n-  Boolean      flag213\t    :  1;\n-  Boolean      flag214\t    :  1;\n-  Boolean      flag215\t    :  1;\n-};\n-\n-/* Structure used for extra flags in sixth component overlaying Field12 */\n-struct Flag_Word5\n-{\n-  Boolean      flag255\t    :  1;\n-  Boolean      flag256\t    :  1;\n-  Boolean      flag257\t    :  1;\n-  Boolean      flag258\t    :  1;\n-  Boolean      flag259\t    :  1;\n-  Boolean      flag260\t    :  1;\n-  Boolean      flag261\t    :  1;\n-  Boolean      flag262\t    :  1;\n-\n-  Boolean      flag263\t    :  1;\n-  Boolean      flag264\t    :  1;\n-  Boolean      flag265\t    :  1;\n-  Boolean      flag266\t    :  1;\n-  Boolean      flag267\t    :  1;\n-  Boolean      flag268\t    :  1;\n-  Boolean      flag269\t    :  1;\n-  Boolean      flag270\t    :  1;\n-\n-  Boolean      flag271\t    :  1;\n-  Boolean      flag272\t    :  1;\n-  Boolean      flag273\t    :  1;\n-  Boolean      flag274\t    :  1;\n-  Boolean      flag275\t    :  1;\n-  Boolean      flag276\t    :  1;\n-  Boolean      flag277\t    :  1;\n-  Boolean      flag278\t    :  1;\n-\n-  Boolean      flag279      :  1;\n-  Boolean      flag280\t    :  1;\n-  Boolean      flag281\t    :  1;\n-  Boolean      flag282\t    :  1;\n-  Boolean      flag283\t    :  1;\n-  Boolean      flag284\t    :  1;\n-  Boolean      flag285\t    :  1;\n-  Boolean      flag286\t    :  1;\n-};\n-struct Non_Extended\n-{\n-  Source_Ptr   sloc;\n-  Int\t       link;\n-  Int\t       field1;\n-  Int\t       field2;\n-  Int\t       field3;\n-  Int\t       field4;\n-  Int\t       field5;\n-};\n-\n-/* The Following structure corresponds to variant with is_extension = True.  */\n-struct Extended\n-{\n-  Int\t       field6;\n-  Int\t       field7;\n-  Int\t       field8;\n-  Int\t       field9;\n-  Int\t       field10;\n-  union\n-    {\n-      Int      field11;\n-      struct   Flag_Word3 fw3;\n-    } X;\n-\n-  union\n-    {\n-      Int      field12;\n-      struct   Flag_Word fw;\n-      struct   Flag_Word2 fw2;\n-      struct   Flag_Word4 fw4;\n-      struct   Flag_Word5 fw5;\n-    } U;\n-};\n-\n-/* A tree node itself.  */\n-\n-struct Node\n-{\n-  union kind\n-    {\n-      struct NFK K;\n-      struct NFNK NK;\n-    } U;\n-\n-  union variant\n-    {\n-      struct Non_Extended NX;\n-      struct Extended EX;\n-    } V;\n-};\n-\n-/* The actual tree is an array of nodes. The pointer to this array is passed\n-   as a parameter to the tree transformer procedure and stored in the global\n-   variable Nodes_Ptr after adjusting it by subtracting Node_First_Entry, so\n-   that Node_Id values can be used as subscripts.  */\n-extern struct Node *Nodes_Ptr;\n-\n #define Parent atree__parent\n extern Node_Id Parent (Node_Id);\n \n #define Original_Node atree__original_node\n extern Node_Id Original_Node (Node_Id);\n \n-/* The auxiliary flags array which is allocated in parallel to Nodes */\n-\n-struct Flags\n-{\n-    Boolean      Flag0  : 1;\n-    Boolean      Flag1  : 1;\n-    Boolean      Flag2  : 1;\n-    Boolean      Flag3  : 1;\n-    Boolean      Spare0 : 1;\n-    Boolean      Spare1 : 1;\n-    Boolean      Spare2 : 1;\n-    Boolean      Spare3 : 1;\n-};\n-extern struct Flags *Flags_Ptr;\n-\n-/* Overloaded Functions:\n-\n-   These functions are overloaded in the original Ada source, but there is\n-   only one corresponding C function, which works as described below.\t*/\n-\n /* Type used for union of Node_Id, List_Id, Elist_Id. */\n typedef Int Tree_Id;\n \n@@ -400,496 +59,158 @@ No (Tree_Id N)\n INLINE Boolean\n Present (Tree_Id N)\n {\n-  return N != Empty;\n+  return !No (N);\n }\n \n extern Node_Id Parent\t\t(Tree_Id);\n \n #define Current_Error_Node atree__current_error_node\n extern Node_Id Current_Error_Node;\n \n-/* Node Access Functions:  */\n-\n-#define Nkind(N)        ((Node_Kind) (Nodes_Ptr[(N) - First_Node_Id].U.K.kind))\n-#define Ekind(N)        ((Entity_Kind) (Nodes_Ptr[N + 1].U.K.kind))\n-#define Sloc(N)         (Nodes_Ptr[(N) - First_Node_Id].V.NX.sloc)\n-#define Paren_Count(N)\t(Nodes_Ptr[(N) - First_Node_Id].U.K.pflag1\t\\\n-\t\t\t + 2 * Nodes_Ptr[(N) - First_Node_Id].U.K.pflag2)\n-\n-#define Field1(N)     (Nodes_Ptr[(N) - First_Node_Id].V.NX.field1)\n-#define Field2(N)     (Nodes_Ptr[(N) - First_Node_Id].V.NX.field2)\n-#define Field3(N)     (Nodes_Ptr[(N) - First_Node_Id].V.NX.field3)\n-#define Field4(N)     (Nodes_Ptr[(N) - First_Node_Id].V.NX.field4)\n-#define Field5(N)     (Nodes_Ptr[(N) - First_Node_Id].V.NX.field5)\n-#define Field6(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].V.EX.field6)\n-#define Field7(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].V.EX.field7)\n-#define Field8(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].V.EX.field8)\n-#define Field9(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].V.EX.field9)\n-#define Field10(N)    (Nodes_Ptr[(N) - First_Node_Id + 1].V.EX.field10)\n-#define Field11(N)    (Nodes_Ptr[(N) - First_Node_Id + 1].V.EX.X.field11)\n-#define Field12(N)    (Nodes_Ptr[(N) - First_Node_Id + 1].V.EX.U.field12)\n-#define Field13(N)    (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.field6)\n-#define Field14(N)    (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.field7)\n-#define Field15(N)    (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.field8)\n-#define Field16(N)    (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.field9)\n-#define Field17(N)    (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.field10)\n-#define Field18(N)    (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.X.field11)\n-#define Field19(N)    (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.field6)\n-#define Field20(N)    (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.field7)\n-#define Field21(N)    (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.field8)\n-#define Field22(N)    (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.field9)\n-#define Field23(N)    (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.field10)\n-#define Field24(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field6)\n-#define Field25(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field7)\n-#define Field26(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field8)\n-#define Field27(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field9)\n-#define Field28(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field10)\n-#define Field29(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.X.field11)\n-#define Field30(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.field6)\n-#define Field31(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.field7)\n-#define Field32(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.field8)\n-#define Field33(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.field9)\n-#define Field34(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.field10)\n-#define Field35(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.X.field11)\n-#define Field36(N)    (Nodes_Ptr[(N) - First_Node_Id + 6].V.EX.field6)\n-#define Field37(N)    (Nodes_Ptr[(N) - First_Node_Id + 6].V.EX.field7)\n-#define Field38(N)    (Nodes_Ptr[(N) - First_Node_Id + 6].V.EX.field8)\n-#define Field39(N)    (Nodes_Ptr[(N) - First_Node_Id + 6].V.EX.field9)\n-#define Field40(N)    (Nodes_Ptr[(N) - First_Node_Id + 6].V.EX.field10)\n-#define Field41(N)    (Nodes_Ptr[(N) - First_Node_Id + 6].V.EX.X.field11)\n-\n-#define Node1(N)      Field1  (N)\n-#define Node2(N)      Field2  (N)\n-#define Node3(N)      Field3  (N)\n-#define Node4(N)      Field4  (N)\n-#define Node5(N)      Field5  (N)\n-#define Node6(N)      Field6  (N)\n-#define Node7(N)      Field7  (N)\n-#define Node8(N)      Field8  (N)\n-#define Node9(N)      Field9  (N)\n-#define Node10(N)     Field10 (N)\n-#define Node11(N)     Field11 (N)\n-#define Node12(N)     Field12 (N)\n-#define Node13(N)     Field13 (N)\n-#define Node14(N)     Field14 (N)\n-#define Node15(N)     Field15 (N)\n-#define Node16(N)     Field16 (N)\n-#define Node17(N)     Field17 (N)\n-#define Node18(N)     Field18 (N)\n-#define Node19(N)     Field19 (N)\n-#define Node20(N)     Field20 (N)\n-#define Node21(N)     Field21 (N)\n-#define Node22(N)     Field22 (N)\n-#define Node23(N)     Field23 (N)\n-#define Node24(N)     Field24 (N)\n-#define Node25(N)     Field25 (N)\n-#define Node26(N)     Field26 (N)\n-#define Node27(N)     Field27 (N)\n-#define Node28(N)     Field28 (N)\n-#define Node29(N)     Field29 (N)\n-#define Node30(N)     Field30 (N)\n-#define Node31(N)     Field31 (N)\n-#define Node32(N)     Field32 (N)\n-#define Node33(N)     Field33 (N)\n-#define Node34(N)     Field34 (N)\n-#define Node35(N)     Field35 (N)\n-#define Node36(N)     Field36 (N)\n-#define Node37(N)     Field37 (N)\n-#define Node38(N)     Field38 (N)\n-#define Node39(N)     Field39 (N)\n-#define Node40(N)     Field40 (N)\n-#define Node41(N)     Field41 (N)\n-\n-#define List1(N)      Field1  (N)\n-#define List2(N)      Field2  (N)\n-#define List3(N)      Field3  (N)\n-#define List4(N)      Field4  (N)\n-#define List5(N)      Field5  (N)\n-#define List10(N)     Field10 (N)\n-#define List14(N)     Field14 (N)\n-#define List25(N)     Field25 (N)\n-#define List38(N)     Field38 (N)\n-#define List39(N)     Field39 (N)\n-\n-#define Elist1(N)     Field1  (N)\n-#define Elist2(N)     Field2  (N)\n-#define Elist3(N)     Field3  (N)\n-#define Elist4(N)     Field4  (N)\n-#define Elist5(N)     Field5  (N)\n-#define Elist8(N)     Field8  (N)\n-#define Elist9(N)     Field9  (N)\n-#define Elist10(N)    Field10 (N)\n-#define Elist11(N)    Field11 (N)\n-#define Elist13(N)    Field13 (N)\n-#define Elist15(N)    Field15 (N)\n-#define Elist16(N)    Field16 (N)\n-#define Elist18(N)    Field18 (N)\n-#define Elist21(N)    Field21 (N)\n-#define Elist23(N)    Field23 (N)\n-#define Elist24(N)    Field24 (N)\n-#define Elist25(N)    Field25 (N)\n-#define Elist26(N)    Field26 (N)\n-#define Elist29(N)    Field29 (N)\n-#define Elist30(N)    Field30 (N)\n-#define Elist36(N)    Field36 (N)\n-\n-#define Name1(N)      Field1  (N)\n-#define Name2(N)      Field2  (N)\n-\n-#define Char_Code2(N) (Field2 (N) - Char_Code_Bias)\n-\n-#define Str3(N)       Field3  (N)\n+// The following code corresponds to the Get_n_Bit_Field functions (for\n+// various n) in package Atree. The low-level getters in sinfo.h call\n+// these even-lower-level getters.\n \n-#define Uint2(N)      ((Field2  (N) == 0) ? Uint_0 : Field2  (N))\n-#define Uint3(N)      ((Field3  (N) == 0) ? Uint_0 : Field3  (N))\n-#define Uint4(N)      ((Field4  (N) == 0) ? Uint_0 : Field4  (N))\n-#define Uint5(N)      ((Field5  (N) == 0) ? Uint_0 : Field5  (N))\n-#define Uint8(N)      ((Field8  (N) == 0) ? Uint_0 : Field8  (N))\n-#define Uint9(N)      ((Field9  (N) == 0) ? Uint_0 : Field9  (N))\n-#define Uint10(N)     ((Field10 (N) == 0) ? Uint_0 : Field10 (N))\n-#define Uint11(N)     ((Field11 (N) == 0) ? Uint_0 : Field11 (N))\n-#define Uint12(N)     ((Field12 (N) == 0) ? Uint_0 : Field12 (N))\n-#define Uint13(N)     ((Field13 (N) == 0) ? Uint_0 : Field13 (N))\n-#define Uint14(N)     ((Field14 (N) == 0) ? Uint_0 : Field14 (N))\n-#define Uint15(N)     ((Field15 (N) == 0) ? Uint_0 : Field15 (N))\n-#define Uint16(N)     ((Field16 (N) == 0) ? Uint_0 : Field16 (N))\n-#define Uint17(N)     ((Field17 (N) == 0) ? Uint_0 : Field17 (N))\n-#define Uint22(N)     ((Field22 (N) == 0) ? Uint_0 : Field22 (N))\n-#define Uint24(N)     ((Field24 (N) == 0) ? Uint_0 : Field24 (N))\n+extern Field_Offset *Node_Offsets_Ptr;\n+extern slot* Slots_Ptr;\n \n-#define Ureal3(N)     Field3  (N)\n-#define Ureal18(N)    Field18 (N)\n-#define Ureal21(N)    Field21 (N)\n+static Union_Id Get_1_Bit_Field(Node_Id N, Field_Offset Offset);\n+static Union_Id Get_2_Bit_Field(Node_Id N, Field_Offset Offset);\n+static Union_Id Get_4_Bit_Field(Node_Id N, Field_Offset Offset);\n+static Union_Id Get_8_Bit_Field(Node_Id N, Field_Offset Offset);\n+static Union_Id Get_32_Bit_Field(Node_Id N, Field_Offset Offset);\n+static Union_Id Get_32_Bit_Field_With_Default\n+    (Node_Id N, Field_Offset Offset, Union_Id Default_Value);\n \n-#define Analyzed(N)          (Nodes_Ptr[(N) - First_Node_Id].U.K.analyzed)\n-#define Comes_From_Source(N) (Nodes_Ptr[(N) - First_Node_Id].U.K.c_f_s)\n-#define Error_Posted(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.error_posted)\n-#define Has_Aspects(N)       (Nodes_Ptr[(N) - First_Node_Id].U.K.has_aspects)\n-#define Convention(N) \\\n-    (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.convention)\n-\n-#define Flag0(N)      (Flags_Ptr[(N) - First_Node_Id].Flag0)\n-#define Flag1(N)      (Flags_Ptr[(N) - First_Node_Id].Flag1)\n-#define Flag2(N)      (Flags_Ptr[(N) - First_Node_Id].Flag2)\n-#define Flag3(N)      (Flags_Ptr[(N) - First_Node_Id].Flag3)\n-\n-#define Flag4(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.flag4)\n-#define Flag5(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.flag5)\n-#define Flag6(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.flag6)\n-#define Flag7(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.flag7)\n-#define Flag8(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.flag8)\n-#define Flag9(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.flag9)\n-#define Flag10(N)     (Nodes_Ptr[(N) - First_Node_Id].U.K.flag10)\n-#define Flag11(N)     (Nodes_Ptr[(N) - First_Node_Id].U.K.flag11)\n-#define Flag12(N)     (Nodes_Ptr[(N) - First_Node_Id].U.K.flag12)\n-#define Flag13(N)     (Nodes_Ptr[(N) - First_Node_Id].U.K.flag13)\n-#define Flag14(N)     (Nodes_Ptr[(N) - First_Node_Id].U.K.flag14)\n-#define Flag15(N)     (Nodes_Ptr[(N) - First_Node_Id].U.K.flag15)\n-#define Flag16(N)     (Nodes_Ptr[(N) - First_Node_Id].U.K.flag16)\n-#define Flag17(N)     (Nodes_Ptr[(N) - First_Node_Id].U.K.flag17)\n-#define Flag18(N)     (Nodes_Ptr[(N) - First_Node_Id].U.K.flag18)\n+INLINE Union_Id\n+Get_1_Bit_Field(Node_Id N, Field_Offset Offset)\n+{\n+    const Field_Offset L = 32;\n+    slot_1_bit slot = (Slots_Ptr + (Node_Offsets_Ptr[N] + Offset/L))->slot_1;\n \n-#define Flag19(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.in_list)\n-#define Flag20(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.has_aspects)\n-#define Flag21(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.rewrite_ins)\n-#define Flag22(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.analyzed)\n-#define Flag23(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.c_f_s)\n-#define Flag24(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.error_posted)\n-#define Flag25(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag4)\n-#define Flag26(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag5)\n-#define Flag27(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag6)\n-#define Flag28(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag7)\n-#define Flag29(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag8)\n-#define Flag30(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag9)\n-#define Flag31(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag10)\n-#define Flag32(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag11)\n-#define Flag33(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag12)\n-#define Flag34(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag13)\n-#define Flag35(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag14)\n-#define Flag36(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag15)\n-#define Flag37(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag16)\n-#define Flag38(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag17)\n-#define Flag39(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.flag18)\n+    switch (Offset%L)\n+    {\n+    case 0: return slot.f0;\n+    case 1: return slot.f1;\n+    case 2: return slot.f2;\n+    case 3: return slot.f3;\n+    case 4: return slot.f4;\n+    case 5: return slot.f5;\n+    case 6: return slot.f6;\n+    case 7: return slot.f7;\n+    case 8: return slot.f8;\n+    case 9: return slot.f9;\n+    case 10: return slot.f10;\n+    case 11: return slot.f11;\n+    case 12: return slot.f12;\n+    case 13: return slot.f13;\n+    case 14: return slot.f14;\n+    case 15: return slot.f15;\n+    case 16: return slot.f16;\n+    case 17: return slot.f17;\n+    case 18: return slot.f18;\n+    case 19: return slot.f19;\n+    case 20: return slot.f20;\n+    case 21: return slot.f21;\n+    case 22: return slot.f22;\n+    case 23: return slot.f23;\n+    case 24: return slot.f24;\n+    case 25: return slot.f25;\n+    case 26: return slot.f26;\n+    case 27: return slot.f27;\n+    case 28: return slot.f28;\n+    case 29: return slot.f29;\n+    case 30: return slot.f30;\n+    case 31: return slot.f31;\n+    default: gcc_assert(false);\n+    }\n+}\n \n-#define Flag40(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.in_list)\n-#define Flag41(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.has_aspects)\n-#define Flag42(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.rewrite_ins)\n-#define Flag43(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.analyzed)\n-#define Flag44(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.c_f_s)\n-#define Flag45(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.error_posted)\n-#define Flag46(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag4)\n-#define Flag47(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag5)\n-#define Flag48(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag6)\n-#define Flag49(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag7)\n-#define Flag50(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag8)\n-#define Flag51(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag9)\n-#define Flag52(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag10)\n-#define Flag53(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag11)\n-#define Flag54(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag12)\n-#define Flag55(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag13)\n-#define Flag56(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag14)\n-#define Flag57(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag15)\n-#define Flag58(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag16)\n-#define Flag59(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag17)\n-#define Flag60(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.flag18)\n-#define Flag61(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.pflag1)\n-#define Flag62(N)     (Nodes_Ptr[(N) - First_Node_Id + 1].U.K.pflag2)\n-#define Flag63(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.pflag1)\n-#define Flag64(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.K.pflag2)\n+INLINE Union_Id\n+Get_2_Bit_Field(Node_Id N, Field_Offset Offset)\n+{\n+    const Field_Offset L = 16;\n+    slot_2_bit slot = (Slots_Ptr + (Node_Offsets_Ptr[N] + Offset/L))->slot_2;\n \n-#define Flag65(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.NK.flag65)\n-#define Flag66(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.NK.flag66)\n-#define Flag67(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.NK.flag67)\n-#define Flag68(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.NK.flag68)\n-#define Flag69(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.NK.flag69)\n-#define Flag70(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.NK.flag70)\n-#define Flag71(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.NK.flag71)\n-#define Flag72(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].U.NK.flag72)\n+    switch (Offset%L)\n+    {\n+    case 0: return slot.f0;\n+    case 1: return slot.f1;\n+    case 2: return slot.f2;\n+    case 3: return slot.f3;\n+    case 4: return slot.f4;\n+    case 5: return slot.f5;\n+    case 6: return slot.f6;\n+    case 7: return slot.f7;\n+    case 8: return slot.f8;\n+    case 9: return slot.f9;\n+    case 10: return slot.f10;\n+    case 11: return slot.f11;\n+    case 12: return slot.f12;\n+    case 13: return slot.f13;\n+    case 14: return slot.f14;\n+    case 15: return slot.f15;\n+    default: gcc_assert(false);\n+    }\n+}\n \n-#define Flag73(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag73)\n-#define Flag74(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag74)\n-#define Flag75(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag75)\n-#define Flag76(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag76)\n-#define Flag77(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag77)\n-#define Flag78(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag78)\n-#define Flag79(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag79)\n-#define Flag80(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag80)\n-#define Flag81(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag81)\n-#define Flag82(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag82)\n-#define Flag83(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag83)\n-#define Flag84(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag84)\n-#define Flag85(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag85)\n-#define Flag86(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag86)\n-#define Flag87(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag87)\n-#define Flag88(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag88)\n-#define Flag89(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag89)\n-#define Flag90(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag90)\n-#define Flag91(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag91)\n-#define Flag92(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag92)\n-#define Flag93(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag93)\n-#define Flag94(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag94)\n-#define Flag95(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag95)\n-#define Flag96(N)     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.flag96)\n-#define Flag97(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag97)\n-#define Flag98(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag98)\n-#define Flag99(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag99)\n-#define Flag100(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag100)\n-#define Flag101(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag101)\n-#define Flag102(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag102)\n-#define Flag103(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag103)\n-#define Flag104(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag104)\n-#define Flag105(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag105)\n-#define Flag106(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag106)\n-#define Flag107(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag107)\n-#define Flag108(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag108)\n-#define Flag109(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag109)\n-#define Flag110(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag110)\n-#define Flag111(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag111)\n-#define Flag112(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag112)\n-#define Flag113(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag113)\n-#define Flag114(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag114)\n-#define Flag115(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag115)\n-#define Flag116(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag116)\n-#define Flag117(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag117)\n-#define Flag118(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag118)\n-#define Flag119(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag119)\n-#define Flag120(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag120)\n-#define Flag121(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag121)\n-#define Flag122(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag122)\n-#define Flag123(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag123)\n-#define Flag124(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag124)\n-#define Flag125(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag125)\n-#define Flag126(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag126)\n-#define Flag127(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag127)\n-#define Flag128(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.U.fw2.flag128)\n+INLINE Union_Id\n+Get_4_Bit_Field(Node_Id N, Field_Offset Offset)\n+{\n+    const Field_Offset L = 8;\n+    slot_4_bit slot = (Slots_Ptr + (Node_Offsets_Ptr[N] + Offset/L))->slot_4;\n \n-#define Flag129(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.in_list)\n-#define Flag130(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.has_aspects)\n-#define Flag131(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.rewrite_ins)\n-#define Flag132(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.analyzed)\n-#define Flag133(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.c_f_s)\n-#define Flag134(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.error_posted)\n-#define Flag135(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag4)\n-#define Flag136(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag5)\n-#define Flag137(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag6)\n-#define Flag138(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag7)\n-#define Flag139(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag8)\n-#define Flag140(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag9)\n-#define Flag141(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag10)\n-#define Flag142(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag11)\n-#define Flag143(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag12)\n-#define Flag144(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag13)\n-#define Flag145(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag14)\n-#define Flag146(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag15)\n-#define Flag147(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag16)\n-#define Flag148(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag17)\n-#define Flag149(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.flag18)\n-#define Flag150(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.pflag1)\n-#define Flag151(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.K.pflag2)\n+    switch (Offset%L)\n+    {\n+    case 0: return slot.f0;\n+    case 1: return slot.f1;\n+    case 2: return slot.f2;\n+    case 3: return slot.f3;\n+    case 4: return slot.f4;\n+    case 5: return slot.f5;\n+    case 6: return slot.f6;\n+    case 7: return slot.f7;\n+    default: gcc_assert(false);\n+    }\n+}\n \n-#define Flag152(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag152)\n-#define Flag153(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag153)\n-#define Flag154(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag154)\n-#define Flag155(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag155)\n-#define Flag156(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag156)\n-#define Flag157(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag157)\n-#define Flag158(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag158)\n-#define Flag159(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag159)\n-#define Flag160(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag160)\n-#define Flag161(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag161)\n-#define Flag162(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag162)\n-#define Flag163(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag163)\n-#define Flag164(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag164)\n-#define Flag165(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag165)\n-#define Flag166(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag166)\n-#define Flag167(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag167)\n-#define Flag168(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag168)\n-#define Flag169(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag169)\n-#define Flag170(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag170)\n-#define Flag171(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag171)\n-#define Flag172(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag172)\n-#define Flag173(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag173)\n-#define Flag174(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag174)\n-#define Flag175(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag175)\n-#define Flag176(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag176)\n-#define Flag177(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag177)\n-#define Flag178(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag178)\n-#define Flag179(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag179)\n-#define Flag180(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag180)\n-#define Flag181(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag181)\n-#define Flag182(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag182)\n-#define Flag183(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.X.fw3.flag183)\n+INLINE Union_Id\n+Get_8_Bit_Field(Node_Id N, Field_Offset Offset)\n+{\n+    const Field_Offset L = 4;\n+    slot_8_bit slot = (Slots_Ptr + (Node_Offsets_Ptr[N] + Offset/L))->slot_8;\n \n-#define Flag184(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag184)\n-#define Flag185(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag185)\n-#define Flag186(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag186)\n-#define Flag187(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag187)\n-#define Flag188(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag188)\n-#define Flag189(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag189)\n-#define Flag190(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag190)\n-#define Flag191(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag191)\n-#define Flag192(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag192)\n-#define Flag193(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag193)\n-#define Flag194(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag194)\n-#define Flag195(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag195)\n-#define Flag196(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag196)\n-#define Flag197(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag197)\n-#define Flag198(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag198)\n-#define Flag199(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag199)\n-#define Flag200(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag200)\n-#define Flag201(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag201)\n-#define Flag202(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag202)\n-#define Flag203(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag203)\n-#define Flag204(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag204)\n-#define Flag205(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag205)\n-#define Flag206(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag206)\n-#define Flag207(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag207)\n-#define Flag208(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag208)\n-#define Flag209(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag209)\n-#define Flag210(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag210)\n-#define Flag211(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag211)\n-#define Flag212(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag212)\n-#define Flag213(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag213)\n-#define Flag214(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag214)\n-#define Flag215(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.U.fw4.flag215)\n+    switch (Offset%L)\n+    {\n+    case 0: return slot.f0;\n+    case 1: return slot.f1;\n+    case 2: return slot.f2;\n+    case 3: return slot.f3;\n+    default: gcc_assert(false);\n+    }\n+}\n \n-#define Flag216(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.in_list)\n-#define Flag217(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.has_aspects)\n-#define Flag218(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.rewrite_ins)\n-#define Flag219(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.analyzed)\n-#define Flag220(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.c_f_s)\n-#define Flag221(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.error_posted)\n-#define Flag222(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag4)\n-#define Flag223(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag5)\n-#define Flag224(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag6)\n-#define Flag225(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag7)\n-#define Flag226(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag8)\n-#define Flag227(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag9)\n-#define Flag228(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag10)\n-#define Flag229(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag11)\n-#define Flag230(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag12)\n-#define Flag231(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag13)\n-#define Flag232(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag14)\n-#define Flag233(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag15)\n-#define Flag234(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag16)\n-#define Flag235(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag17)\n-#define Flag236(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.flag18)\n-#define Flag237(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.pflag1)\n-#define Flag238(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.K.pflag2)\n+INLINE Union_Id\n+Get_32_Bit_Field(Node_Id N, Field_Offset Offset)\n+{\n+    const Field_Offset L = 1;\n+    slot_32_bit slot = (Slots_Ptr + (Node_Offsets_Ptr[N] + Offset/L))->slot_32;\n+    return slot;\n+}\n \n-#define Flag239(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.NK.flag65)\n-#define Flag240(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.NK.flag66)\n-#define Flag241(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.NK.flag67)\n-#define Flag242(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.NK.flag68)\n-#define Flag243(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.NK.flag69)\n-#define Flag244(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.NK.flag70)\n-#define Flag245(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.NK.flag71)\n-#define Flag246(N)     (Nodes_Ptr[(N) - First_Node_Id + 3].U.NK.flag72)\n+INLINE Union_Id\n+Get_32_Bit_Field_With_Default(Node_Id N, Field_Offset Offset, Union_Id Default_Value)\n+{\n+    const Field_Offset L = 1;\n+    slot_32_bit slot = (Slots_Ptr + (Node_Offsets_Ptr[N] + Offset/L))->slot_32;\n \n-#define Flag247(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.NK.flag65)\n-#define Flag248(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.NK.flag66)\n-#define Flag249(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.NK.flag67)\n-#define Flag250(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.NK.flag68)\n-#define Flag251(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.NK.flag69)\n-#define Flag252(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.NK.flag70)\n-#define Flag253(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.NK.flag71)\n-#define Flag254(N)     (Nodes_Ptr[(N) - First_Node_Id + 4].U.NK.flag72)\n+    if (slot == Empty)\n+    {\n+        return Default_Value;\n+    }\n \n-#define Flag255(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag255)\n-#define Flag256(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag256)\n-#define Flag257(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag257)\n-#define Flag258(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag258)\n-#define Flag259(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag259)\n-#define Flag260(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag260)\n-#define Flag261(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag261)\n-#define Flag262(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag262)\n-#define Flag263(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag263)\n-#define Flag264(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag264)\n-#define Flag265(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag265)\n-#define Flag266(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag266)\n-#define Flag267(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag267)\n-#define Flag268(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag268)\n-#define Flag269(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag269)\n-#define Flag270(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag270)\n-#define Flag271(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag271)\n-#define Flag272(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag272)\n-#define Flag273(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag273)\n-#define Flag274(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag274)\n-#define Flag275(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag275)\n-#define Flag276(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag276)\n-#define Flag277(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag277)\n-#define Flag278(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag278)\n-#define Flag279(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag279)\n-#define Flag280(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag280)\n-#define Flag281(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag281)\n-#define Flag282(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag282)\n-#define Flag283(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag283)\n-#define Flag284(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag284)\n-#define Flag285(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag285)\n-#define Flag286(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.U.fw5.flag286)\n-#define Flag287(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.in_list)\n-#define Flag288(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.has_aspects)\n-#define Flag289(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.rewrite_ins)\n-#define Flag290(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.analyzed)\n-#define Flag291(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.c_f_s)\n-#define Flag292(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.error_posted)\n-#define Flag293(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag4)\n-#define Flag294(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag5)\n-#define Flag295(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag6)\n-#define Flag296(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag7)\n-#define Flag297(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag8)\n-#define Flag298(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag9)\n-#define Flag299(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag10)\n-#define Flag300(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag11)\n-#define Flag301(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag12)\n-#define Flag302(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag13)\n-#define Flag303(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag14)\n-#define Flag304(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag15)\n-#define Flag305(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag16)\n-#define Flag306(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag17)\n-#define Flag307(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.flag18)\n-#define Flag308(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.pflag1)\n-#define Flag309(N)     (Nodes_Ptr[(N) - First_Node_Id + 5].U.K.pflag2)\n+    return slot;\n+}\n \n #ifdef __cplusplus\n }"}, {"sha": "a170ed5fbafba143835715f1420e70bfe91a6b90", "filename": "gcc/ada/back_end.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -88,8 +88,8 @@ package body Back_End is\n         (gnat_root                     : Int;\n          max_gnat_node                 : Int;\n          number_name                   : Nat;\n-         nodes_ptr                     : Address;\n-         flags_ptr                     : Address;\n+         node_offsets_ptr              : Address;\n+         slots_ptr                     : Address;\n \n          next_node_ptr                 : Address;\n          prev_node_ptr                 : Address;\n@@ -156,8 +156,8 @@ package body Back_End is\n         (gnat_root          => Int (Cunit (Main_Unit)),\n          max_gnat_node      => Int (Last_Node_Id - First_Node_Id + 1),\n          number_name        => Name_Entries_Count,\n-         nodes_ptr          => Nodes_Address,\n-         flags_ptr          => Flags_Address,\n+         node_offsets_ptr   => Node_Offsets_Address,\n+         slots_ptr          => Slots_Address,\n \n          next_node_ptr      => Next_Node_Address,\n          prev_node_ptr      => Prev_Node_Address,"}, {"sha": "ccb53cefe4513296bb8f6418d04926ce50085090", "filename": "gcc/ada/ceinfo.adb", "status": "removed", "additions": 0, "deletions": 226, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fceinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fceinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fceinfo.adb?ref=476ed6bf66ab20e22ae4b3da0fd7fd94753f2334", "patch": "@@ -1,226 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                          GNAT SYSTEM UTILITIES                           --\n---                                                                          --\n---                               C E I N F O                                --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1998-2021, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Check consistency of einfo.ads and einfo.adb. Checks that field name usage\n---  is consistent, including comments mentioning fields.\n-\n---  Note that this is used both as a standalone program, and as a procedure\n---  called by XEinfo. This raises an unhandled exception if it finds any\n---  errors; we don't attempt any sophisticated error recovery.\n-\n-with Ada.Strings.Unbounded;         use Ada.Strings.Unbounded;\n-with Ada.Strings.Unbounded.Text_IO; use Ada.Strings.Unbounded.Text_IO;\n-with Ada.Text_IO;                   use Ada.Text_IO;\n-\n-with GNAT.Spitbol;                  use GNAT.Spitbol;\n-with GNAT.Spitbol.Patterns;         use GNAT.Spitbol.Patterns;\n-with GNAT.Spitbol.Table_VString;\n-\n-procedure CEinfo is\n-\n-   package TV renames GNAT.Spitbol.Table_VString;\n-   use TV;\n-\n-   Infil  : File_Type;\n-   Lineno : Natural := 0;\n-\n-   Err : exception;\n-   --  Raised on error\n-\n-   Fieldnm    : VString;\n-   Accessfunc : VString;\n-   Line       : VString;\n-\n-   Fields : GNAT.Spitbol.Table_VString.Table (500);\n-   --  Maps field names to underlying field access name\n-\n-   UC : constant Pattern := Any (\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n-\n-   Fnam : constant Pattern := (UC & Break (' ')) * Fieldnm;\n-\n-   Field_Def : constant Pattern :=\n-     \"--    \" & Fnam & \" (\" & Break (')') * Accessfunc;\n-\n-   Field_Ref : constant Pattern :=\n-     \"   --    \" & Fnam & Break ('(') & Len (1) &\n-     Break (')') * Accessfunc;\n-\n-   Field_Com : constant Pattern := \"   --    \" & Fnam & Span (' ') &\n-                                     (Break (' ') or Rest) * Accessfunc;\n-\n-   Func_Hedr : constant Pattern := \"   function \" & Fnam;\n-\n-   Func_Retn : constant Pattern := \"      return \" & Break (' ') * Accessfunc;\n-\n-   Proc_Hedr : constant Pattern := \"   procedure \" & Fnam;\n-\n-   Proc_Setf : constant Pattern := \"      Set_\" & Break (' ') * Accessfunc;\n-\n-   procedure Next_Line;\n-   --  Read next line trimmed from Infil into Line and bump Lineno\n-\n-   procedure Next_Line is\n-   begin\n-      Line := Get_Line (Infil);\n-      Trim (Line);\n-      Lineno := Lineno + 1;\n-   end Next_Line;\n-\n---  Start of processing for CEinfo\n-\n-begin\n-   Anchored_Mode := True;\n-   New_Line;\n-   Open (Infil, In_File, \"einfo.ads\");\n-\n-   Put_Line (\"Acquiring field names from spec\");\n-\n-   loop\n-      Next_Line;\n-\n-      --  Old format of einfo.ads\n-\n-      exit when Match (Line, \"   -- Access Kinds --\");\n-\n-      --  New format of einfo.ads\n-\n-      exit when Match (Line, \"-- Access Kinds --\");\n-\n-      if Match (Line, Field_Def) then\n-         Set (Fields, Fieldnm, Accessfunc);\n-      end if;\n-   end loop;\n-\n-   Put_Line (\"Checking consistent references in spec\");\n-\n-   loop\n-      Next_Line;\n-      exit when Match (Line, \"   -- Description of Defined\");\n-   end loop;\n-\n-   loop\n-      Next_Line;\n-      exit when Match (Line, \"   -- Component_Alignment Control\");\n-\n-      if Match (Line, Field_Ref) then\n-         if Accessfunc /= \"synth\"\n-              and then\n-            Accessfunc /= \"special\"\n-              and then\n-            Accessfunc /= Get (Fields, Fieldnm)\n-         then\n-            if Present (Fields, Fieldnm) then\n-               Put_Line (\"*** field name incorrect at line \" & Lineno);\n-               Put_Line (\"      found field \" & Accessfunc);\n-               Put_Line (\"      expecting field \" & Get (Fields, Fieldnm));\n-\n-            else\n-               Put_Line\n-                 (\"*** unknown field name \" & Fieldnm & \" at line \" & Lineno);\n-            end if;\n-\n-            raise Err;\n-         end if;\n-      end if;\n-   end loop;\n-\n-   Close (Infil);\n-   Open (Infil, In_File, \"einfo.adb\");\n-   Lineno := 0;\n-\n-   Put_Line (\"Check listing of fields in body\");\n-\n-   loop\n-      Next_Line;\n-      exit when Match (Line, \"   -- Attribute Access Functions --\");\n-\n-      if Match (Line, Field_Com)\n-        and then Fieldnm /= \"(unused)\"\n-        and then Accessfunc /= Get (Fields, Fieldnm)\n-      then\n-         if Present (Fields, Fieldnm) then\n-            Put_Line (\"*** field name incorrect at line \" & Lineno);\n-            Put_Line (\"      found field \" & Accessfunc);\n-            Put_Line (\"      expecting field \" & Get (Fields, Fieldnm));\n-\n-         else\n-            Put_Line\n-              (\"*** unknown field name \" & Fieldnm & \" at line \" & Lineno);\n-         end if;\n-\n-         raise Err;\n-      end if;\n-   end loop;\n-\n-   Put_Line (\"Check references in access routines in body\");\n-\n-   loop\n-      Next_Line;\n-      exit when Match (Line, \"   -- Classification Functions --\");\n-\n-      if Match (Line, Func_Hedr) then\n-         null;\n-\n-      elsif Match (Line, Func_Retn)\n-        and then Accessfunc /= Get (Fields, Fieldnm)\n-        and then Fieldnm /= \"Mechanism\"\n-      then\n-         Put_Line (\"*** incorrect field at line \" & Lineno);\n-         Put_Line (\"      found field \" & Accessfunc);\n-         Put_Line (\"      expecting field \" & Get (Fields, Fieldnm));\n-         raise Err;\n-      end if;\n-   end loop;\n-\n-   Put_Line (\"Check references in set routines in body\");\n-\n-   loop\n-      Next_Line;\n-      exit when Match (Line, \"   -- Attribute Set Procedures\");\n-   end loop;\n-\n-   loop\n-      Next_Line;\n-      exit when Match (Line, \"   ------------\");\n-\n-      if Match (Line, Proc_Hedr) then\n-         null;\n-\n-      elsif Match (Line, Proc_Setf)\n-        and then Accessfunc /= Get (Fields, Fieldnm)\n-        and then Fieldnm /= \"Mechanism\"\n-      then\n-         Put_Line (\"*** incorrect field at line \" & Lineno);\n-         Put_Line (\"      found field \" & Accessfunc);\n-         Put_Line (\"      expecting field \" & Get (Fields, Fieldnm));\n-         raise Err;\n-      end if;\n-   end loop;\n-\n-   Close (Infil);\n-\n-   Put_Line (\"All tests completed successfully, no errors detected\");\n-\n-end CEinfo;"}, {"sha": "22b2b6909bc692f549066ba31b9aa759f4e7336b", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Atree;    use Atree;\n with Casing;   use Casing;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Eval_Fat; use Eval_Fat;\n with Exp_Ch11; use Exp_Ch11;\n@@ -53,7 +55,9 @@ with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Sprint;   use Sprint;\n@@ -9295,7 +9299,6 @@ package body Checks is\n \n                      Append_To (New_Alts,\n                        Make_Case_Expression_Alternative (Sloc (Alt),\n-                         Actions          => No_List,\n                          Discrete_Choices => Discrete_Choices (Alt),\n                          Expression       => New_Exp));\n "}, {"sha": "252a0c4d7001b36ad54dc44efe32c8d1888b367e", "filename": "gcc/ada/comperr.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fcomperr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fcomperr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcomperr.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -36,7 +36,8 @@ with Namet;    use Namet;\n with Opt;      use Opt;\n with Osint;    use Osint;\n with Output;   use Output;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Sinput;   use Sinput;\n with Sprint;   use Sprint;\n with Sdefault; use Sdefault;"}, {"sha": "61345ea31b7df1122a6f7cc33a5c0d9ce81eef64", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Aspects;  use Aspects;\n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Prag; use Exp_Prag;\n@@ -46,7 +48,9 @@ with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;"}, {"sha": "a8084ca7b1d5e8f899d99c9d624dee321878282b", "filename": "gcc/ada/csinfo.adb", "status": "removed", "additions": 0, "deletions": 639, "changes": 639, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fcsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fcsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcsinfo.adb?ref=476ed6bf66ab20e22ae4b3da0fd7fd94753f2334", "patch": "@@ -1,639 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                          GNAT SYSTEM UTILITIES                           --\n---                                                                          --\n---                               C S I N F O                                --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2021, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Check consistency of sinfo.ads and sinfo.adb. Checks that field name usage\n---  is consistent and that assertion cross-reference lists are correct, as well\n---  as making sure that all the comments on field name usage are consistent.\n-\n---  Note that this is used both as a standalone program, and as a procedure\n---  called by XSinfo. This raises an unhandled exception if it finds any\n---  errors; we don't attempt any sophisticated error recovery.\n-\n-with Ada.Strings.Unbounded;         use Ada.Strings.Unbounded;\n-with Ada.Strings.Unbounded.Text_IO; use Ada.Strings.Unbounded.Text_IO;\n-with Ada.Strings.Maps;              use Ada.Strings.Maps;\n-with Ada.Strings.Maps.Constants;    use Ada.Strings.Maps.Constants;\n-with Ada.Text_IO;                   use Ada.Text_IO;\n-\n-with GNAT.Spitbol;                  use GNAT.Spitbol;\n-with GNAT.Spitbol.Patterns;         use GNAT.Spitbol.Patterns;\n-with GNAT.Spitbol.Table_Boolean;\n-with GNAT.Spitbol.Table_VString;\n-\n-procedure CSinfo is\n-\n-   package TB renames GNAT.Spitbol.Table_Boolean;\n-   package TV renames GNAT.Spitbol.Table_VString;\n-   use TB, TV;\n-\n-   Infil  : File_Type;\n-   Lineno : Natural := 0;\n-\n-   Err : exception;\n-   --  Raised on fatal error\n-\n-   Done : exception;\n-   --  Raised after error is found to terminate run\n-\n-   WSP : constant Pattern := Span (' ' & ASCII.HT);\n-\n-   Fields   : TV.Table (300);\n-   Fields1  : TV.Table (300);\n-   Refs     : TV.Table (300);\n-   Refscopy : TV.Table (300);\n-   Special  : TB.Table (50);\n-   Inlines  : TV.Table (100);\n-\n-   --  The following define the standard fields used for binary operator,\n-   --  unary operator, and other expression nodes. Numbers in the range 1-5\n-   --  refer to the Fieldn fields. Letters D-R refer to flags:\n-\n-   --      D = Flag4\n-   --      E = Flag5\n-   --      F = Flag6\n-   --      G = Flag7\n-   --      H = Flag8\n-   --      I = Flag9\n-   --      J = Flag10\n-   --      K = Flag11\n-   --      L = Flag12\n-   --      M = Flag13\n-   --      N = Flag14\n-   --      O = Flag15\n-   --      P = Flag16\n-   --      Q = Flag17\n-   --      R = Flag18\n-\n-   Flags : TV.Table (20);\n-   --  Maps flag numbers to letters\n-\n-   N_Fields : constant Pattern := BreakX (\"J\");\n-   E_Fields : constant Pattern := BreakX (\"5EFGHIJOP\");\n-   U_Fields : constant Pattern := BreakX (\"1345EFGHIJKOPQ\");\n-   B_Fields : constant Pattern := BreakX (\"12345EFGHIJKOPQ\");\n-\n-   Line : VString;\n-   Bad  : Boolean;\n-\n-   Field       : constant VString := Nul;\n-   Fields_Used : VString := Nul;\n-   Name        : constant VString := Nul;\n-   Next        : constant VString := Nul;\n-   Node        : VString := Nul;\n-   Ref         : VString := Nul;\n-   Synonym     : constant VString := Nul;\n-   Nxtref      : constant VString := Nul;\n-\n-   Which_Field : aliased VString := Nul;\n-\n-   Node_Search : constant Pattern := WSP & \"--  N_\" & Rest * Node;\n-   Break_Punc  : constant Pattern := Break (\" .,\");\n-   Plus_Binary : constant Pattern := WSP\n-                                     & \"--  plus fields for binary operator\";\n-   Plus_Unary  : constant Pattern := WSP\n-                                     & \"--  plus fields for unary operator\";\n-   Plus_Expr   : constant Pattern := WSP\n-                                     & \"--  plus fields for expression\";\n-   Break_Syn   : constant Pattern := WSP &  \"--  \"\n-                                     & Break (' ') * Synonym\n-                                     & \" (\" & Break (')') * Field;\n-   Break_Field : constant Pattern := BreakX ('-') * Field;\n-   Get_Field   : constant Pattern := BreakX (Decimal_Digit_Set)\n-                                     & Span (Decimal_Digit_Set) * Which_Field;\n-   Break_WFld  : constant Pattern := Break (Which_Field'Access);\n-   Get_Funcsyn : constant Pattern := WSP & \"function \" & Rest * Synonym;\n-   Extr_Field  : constant Pattern := BreakX ('-') & \"-- \" & Rest * Field;\n-   Get_Procsyn : constant Pattern := WSP & \"procedure Set_\" & Rest * Synonym;\n-   Get_Inline  : constant Pattern := WSP & \"pragma Inline (\"\n-                                     & Break (')') * Name;\n-   Set_Name    : constant Pattern := \"Set_\" & Rest * Name;\n-   Func_Rest   : constant Pattern := \"   function \" & Rest * Synonym;\n-   Get_Nxtref  : constant Pattern := Break (',') * Nxtref & ',';\n-   Test_Syn    : constant Pattern := Break ('=') & \"= N_\"\n-                                     & (Break (\" ,)\") or Rest) * Next;\n-   Chop_Comma  : constant Pattern := BreakX (',') * Next;\n-   Return_Fld  : constant Pattern := WSP & \"return \" & Break (' ') * Field;\n-   Set_Syn     : constant Pattern := \"   procedure Set_\" & Rest * Synonym;\n-   Set_Fld     : constant Pattern := WSP & \"Set_\" & Break (' ') * Field\n-                                     & \" (N, Val)\";\n-   Break_With  : constant Pattern := Break ('_') ** Field & \"_With_Parent\";\n-\n-   type VStringA is array (Natural range <>) of VString;\n-\n-   procedure Next_Line;\n-   --  Read next line trimmed from Infil into Line and bump Lineno\n-\n-   procedure Sort (A : in out VStringA);\n-   --  Sort a (small) array of VString's\n-\n-   procedure Next_Line is\n-   begin\n-      Line := Get_Line (Infil);\n-      Trim (Line);\n-      Lineno := Lineno + 1;\n-   end Next_Line;\n-\n-   procedure Sort (A : in out VStringA) is\n-      Temp : VString;\n-   begin\n-      <<Sort>>\n-         for J in 1 .. A'Length - 1 loop\n-            if A (J) > A (J + 1) then\n-               Temp := A (J);\n-               A (J) := A (J + 1);\n-               A (J + 1) := Temp;\n-               goto Sort;\n-            end if;\n-         end loop;\n-   end Sort;\n-\n---  Start of processing for CSinfo\n-\n-begin\n-   Anchored_Mode := True;\n-   New_Line;\n-   Open (Infil, In_File, \"sinfo.ads\");\n-   Put_Line (\"Check for field name consistency\");\n-\n-   --  Setup table for mapping flag numbers to letters\n-\n-   Set (Flags, \"4\",  V (\"D\"));\n-   Set (Flags, \"5\",  V (\"E\"));\n-   Set (Flags, \"6\",  V (\"F\"));\n-   Set (Flags, \"7\",  V (\"G\"));\n-   Set (Flags, \"8\",  V (\"H\"));\n-   Set (Flags, \"9\",  V (\"I\"));\n-   Set (Flags, \"10\", V (\"J\"));\n-   Set (Flags, \"11\", V (\"K\"));\n-   Set (Flags, \"12\", V (\"L\"));\n-   Set (Flags, \"13\", V (\"M\"));\n-   Set (Flags, \"14\", V (\"N\"));\n-   Set (Flags, \"15\", V (\"O\"));\n-   Set (Flags, \"16\", V (\"P\"));\n-   Set (Flags, \"17\", V (\"Q\"));\n-   Set (Flags, \"18\", V (\"R\"));\n-\n-   --  Special fields table. The following names are not recorded or checked\n-   --  by Csinfo, since they are specially handled. This means that any field\n-   --  definition or subprogram with a matching name is ignored.\n-\n-   Set (Special, \"Analyzed\",                         True);\n-   Set (Special, \"Assignment_OK\",                    True);\n-   Set (Special, \"Associated_Node\",                  True);\n-   Set (Special, \"Cannot_Be_Constant\",               True);\n-   Set (Special, \"Chars\",                            True);\n-   Set (Special, \"Comes_From_Source\",                True);\n-   Set (Special, \"Do_Overflow_Check\",                True);\n-   Set (Special, \"Do_Range_Check\",                   True);\n-   Set (Special, \"Entity\",                           True);\n-   Set (Special, \"Entity_Or_Associated_Node\",        True);\n-   Set (Special, \"Error_Posted\",                     True);\n-   Set (Special, \"Etype\",                            True);\n-   Set (Special, \"Evaluate_Once\",                    True);\n-   Set (Special, \"First_Itype\",                      True);\n-   Set (Special, \"Has_Aspect_Specifications\",        True);\n-   Set (Special, \"Has_Dynamic_Itype\",                True);\n-   Set (Special, \"Has_Dynamic_Length_Check\",         True);\n-   Set (Special, \"Has_Private_View\",                 True);\n-   Set (Special, \"Is_Controlling_Actual\",            True);\n-   Set (Special, \"Is_Overloaded\",                    True);\n-   Set (Special, \"Is_Static_Expression\",             True);\n-   Set (Special, \"Left_Opnd\",                        True);\n-   Set (Special, \"Must_Not_Freeze\",                  True);\n-   Set (Special, \"Nkind_In\",                         True);\n-   Set (Special, \"Parens\",                           True);\n-   Set (Special, \"Pragma_Name\",                      True);\n-   Set (Special, \"Raises_Constraint_Error\",          True);\n-   Set (Special, \"Right_Opnd\",                       True);\n-\n-   --  Loop to acquire information from node definitions in sinfo.ads,\n-   --  checking for consistency in Op/Flag assignments to each synonym\n-\n-   loop\n-      Bad := False;\n-      Next_Line;\n-      exit when Match (Line, \"   -- Node Access Functions\");\n-\n-      if Match (Line, Node_Search)\n-        and then not Match (Node, Break_Punc)\n-      then\n-         Fields_Used := Nul;\n-\n-      elsif Node = \"\" then\n-         null;\n-\n-      elsif Line = \"\" then\n-         Node := Nul;\n-\n-      elsif Match (Line, Plus_Binary) then\n-         Bad := Match (Fields_Used, B_Fields);\n-\n-      elsif Match (Line, Plus_Unary) then\n-         Bad := Match (Fields_Used, U_Fields);\n-\n-      elsif Match (Line, Plus_Expr) then\n-         Bad := Match (Fields_Used, E_Fields);\n-\n-      elsif not Match (Line, Break_Syn) then\n-         null;\n-\n-      elsif Match (Synonym, \"plus\") then\n-         null;\n-\n-      else\n-         Match (Field, Break_Field);\n-\n-         if not Present (Special, Synonym) then\n-            if Present (Fields, Synonym) then\n-               if Field /= Get (Fields, Synonym) then\n-                  Put_Line\n-                    (\"Inconsistent field reference at line\" &\n-                     Lineno'Img & \" for \" & Synonym);\n-                  raise Done;\n-               end if;\n-\n-            else\n-               Set (Fields, Synonym, Field);\n-            end if;\n-\n-            Set (Refs, Synonym, Node & ',' & Get (Refs, Synonym));\n-            Match (Field, Get_Field);\n-\n-            if Match (Field, \"Flag\") then\n-               Which_Field := Get (Flags, Which_Field);\n-            end if;\n-\n-            if Match (Fields_Used, Break_WFld) then\n-               Put_Line\n-                 (\"Overlapping field at line \" & Lineno'Img &\n-                  \" for \" & Synonym);\n-               raise Done;\n-            end if;\n-\n-            Append (Fields_Used, Which_Field);\n-            Bad := Bad or Match (Fields_Used, N_Fields);\n-         end if;\n-      end if;\n-\n-      if Bad then\n-         Put_Line (\"fields conflict with standard fields for node \" & Node);\n-         raise Done;\n-      end if;\n-   end loop;\n-\n-   Put_Line (\"     OK\");\n-   New_Line;\n-   Put_Line (\"Check for function consistency\");\n-\n-   --  Loop through field function definitions to make sure they are OK\n-\n-   Fields1 := Fields;\n-   loop\n-      Next_Line;\n-      exit when Match (Line, \"   -- Node Update\");\n-\n-      if Match (Line, Get_Funcsyn)\n-        and then not Present (Special, Synonym)\n-      then\n-         if not Present (Fields1, Synonym) then\n-            Put_Line\n-              (\"function on line \" &  Lineno &\n-               \" is for unused synonym\");\n-            raise Done;\n-         end if;\n-\n-         Next_Line;\n-\n-         if not Match (Line, Extr_Field) then\n-            raise Err;\n-         end if;\n-\n-         if Field /= Get (Fields1, Synonym) then\n-            Put_Line (\"Wrong field in function \" & Synonym);\n-            raise Done;\n-\n-         else\n-            Delete (Fields1, Synonym);\n-         end if;\n-      end if;\n-   end loop;\n-\n-   Put_Line (\"     OK\");\n-   New_Line;\n-   Put_Line (\"Check for missing functions\");\n-\n-   declare\n-      List : constant TV.Table_Array := Convert_To_Array (Fields1);\n-\n-   begin\n-      if List'Length > 0 then\n-         Put_Line (\"No function for field synonym \" & List (1).Name);\n-         raise Done;\n-      end if;\n-   end;\n-\n-   --  Check field set procedures\n-\n-   Put_Line (\"     OK\");\n-   New_Line;\n-   Put_Line (\"Check for set procedure consistency\");\n-\n-   Fields1 := Fields;\n-   loop\n-      Next_Line;\n-      exit when Match (Line, \"   -- Inline Pragmas\");\n-      exit when Match (Line, \"   -- Iterator Procedures\");\n-\n-      if Match (Line, Get_Procsyn)\n-        and then not Present (Special, Synonym)\n-      then\n-         if not Present (Fields1, Synonym) then\n-            Put_Line\n-              (\"procedure on line \" & Lineno & \" is for unused synonym\");\n-            raise Done;\n-         end if;\n-\n-         Next_Line;\n-\n-         if not Match (Line, Extr_Field) then\n-            raise Err;\n-         end if;\n-\n-         if Field /= Get (Fields1, Synonym) then\n-            Put_Line (\"Wrong field in procedure Set_\" & Synonym);\n-            raise Done;\n-\n-         else\n-            Delete (Fields1, Synonym);\n-         end if;\n-      end if;\n-   end loop;\n-\n-   Put_Line (\"     OK\");\n-   New_Line;\n-   Put_Line (\"Check for missing set procedures\");\n-\n-   declare\n-      List : constant TV.Table_Array := Convert_To_Array (Fields1);\n-\n-   begin\n-      if List'Length > 0 then\n-         Put_Line (\"No procedure for field synonym Set_\" & List (1).Name);\n-         raise Done;\n-      end if;\n-   end;\n-\n-   Put_Line (\"     OK\");\n-   New_Line;\n-   Put_Line (\"Check pragma Inlines are all for existing subprograms\");\n-\n-   Clear (Fields1);\n-   while not End_Of_File (Infil) loop\n-      Next_Line;\n-\n-      if Match (Line, Get_Inline)\n-        and then not Present (Special, Name)\n-      then\n-         exit when Match (Name, Set_Name);\n-\n-         if not Present (Fields, Name) then\n-            Put_Line\n-              (\"Pragma Inline on line \" & Lineno &\n-               \" does not correspond to synonym\");\n-            raise Done;\n-\n-         else\n-            Set (Inlines, Name, Get (Inlines, Name) & 'r');\n-         end if;\n-      end if;\n-   end loop;\n-\n-   Put_Line (\"     OK\");\n-   New_Line;\n-   Put_Line (\"Check no pragma Inlines were omitted\");\n-\n-   declare\n-      List : constant TV.Table_Array := Convert_To_Array (Fields);\n-      Nxt  : VString := Nul;\n-\n-   begin\n-      for M in List'Range loop\n-         Nxt := List (M).Name;\n-\n-         if Get (Inlines, Nxt) /= \"r\" then\n-            Put_Line (\"Incorrect pragma Inlines for \" & Nxt);\n-            raise Done;\n-         end if;\n-      end loop;\n-   end;\n-\n-   Put_Line (\"     OK\");\n-   New_Line;\n-   Clear (Inlines);\n-\n-   Close (Infil);\n-   Open (Infil, In_File, \"sinfo.adb\");\n-   Lineno := 0;\n-   Put_Line (\"Check references in functions in body\");\n-\n-   Refscopy := Refs;\n-   loop\n-      Next_Line;\n-      exit when Match (Line, \"   -- Field Access Functions --\");\n-   end loop;\n-\n-   loop\n-      Next_Line;\n-      exit when Match (Line, \"   -- Field Set Procedures --\");\n-\n-      if Match (Line, Func_Rest)\n-        and then not Present (Special, Synonym)\n-      then\n-         Ref := Get (Refs, Synonym);\n-         Delete (Refs, Synonym);\n-\n-         if Ref = \"\" then\n-            Put_Line\n-              (\"Function on line \" & Lineno & \" is for unknown synonym\");\n-            raise Err;\n-         end if;\n-\n-         --  Alpha sort of references for this entry\n-\n-         declare\n-            Refa   : VStringA (1 .. 100);\n-            N      : Natural := 0;\n-\n-         begin\n-            loop\n-               exit when not Match (Ref, Get_Nxtref, Nul);\n-               N := N + 1;\n-               Refa (N) := Nxtref;\n-            end loop;\n-\n-            Sort (Refa (1 .. N));\n-            Next_Line;\n-            Next_Line;\n-            Next_Line;\n-\n-            --  Checking references for one entry\n-\n-            for M in 1 .. N loop\n-               Next_Line;\n-\n-               if not Match (Line, Test_Syn) then\n-                  Put_Line (\"Expecting N_\" & Refa (M) & \" at line \" & Lineno);\n-                  raise Done;\n-               end if;\n-\n-               Match (Next, Chop_Comma);\n-\n-               if Next /= Refa (M) then\n-                  Put_Line (\"Expecting N_\" & Refa (M) & \" at line \" & Lineno);\n-                  raise Done;\n-               end if;\n-            end loop;\n-\n-            Next_Line;\n-            Match (Line, Return_Fld);\n-\n-            if Field /= Get (Fields, Synonym) then\n-               Put_Line\n-                (\"Wrong field for function \" & Synonym & \" at line \" &\n-                 Lineno & \" should be \" & Get (Fields, Synonym));\n-               raise Done;\n-            end if;\n-         end;\n-      end if;\n-   end loop;\n-\n-   Put_Line (\"     OK\");\n-   New_Line;\n-   Put_Line (\"Check for missing functions in body\");\n-\n-   declare\n-      List : constant TV.Table_Array := Convert_To_Array (Refs);\n-\n-   begin\n-      if List'Length /= 0 then\n-         Put_Line (\"Missing function \" & List (1).Name & \" in body\");\n-         raise Done;\n-      end if;\n-   end;\n-\n-   Put_Line (\"     OK\");\n-   New_Line;\n-   Put_Line (\"Check Set procedures in body\");\n-   Refs := Refscopy;\n-\n-   loop\n-      Next_Line;\n-      exit when Match (Line, \"end\");\n-      exit when Match (Line, \"   -- Iterator Procedures\");\n-\n-      if Match (Line, Set_Syn)\n-        and then not Present (Special, Synonym)\n-      then\n-         Ref := Get (Refs, Synonym);\n-         Delete (Refs, Synonym);\n-\n-         if Ref = \"\" then\n-            Put_Line\n-              (\"Function on line \" & Lineno & \" is for unknown synonym\");\n-            raise Err;\n-         end if;\n-\n-         --  Alpha sort of references for this entry\n-\n-         declare\n-            Refa   : VStringA (1 .. 100);\n-            N      : Natural;\n-\n-         begin\n-            N := 0;\n-\n-            loop\n-               exit when not Match (Ref, Get_Nxtref, Nul);\n-               N := N + 1;\n-               Refa (N) := Nxtref;\n-            end loop;\n-\n-            Sort (Refa (1 .. N));\n-\n-            Next_Line;\n-            Next_Line;\n-            Next_Line;\n-\n-            --  Checking references for one entry\n-\n-            for M in 1 .. N loop\n-               Next_Line;\n-\n-               if not Match (Line, Test_Syn)\n-                 or else Next /= Refa (M)\n-               then\n-                  Put_Line (\"Expecting N_\" & Refa (M) & \" at line \" & Lineno);\n-                  raise Err;\n-               end if;\n-            end loop;\n-\n-            loop\n-               Next_Line;\n-               exit when Match (Line, Set_Fld);\n-            end loop;\n-\n-            Match (Field, Break_With);\n-\n-            if Field /= Get (Fields, Synonym) then\n-               Put_Line\n-                 (\"Wrong field for procedure Set_\" & Synonym &\n-                  \" at line \" & Lineno & \" should be \" &\n-                  Get (Fields, Synonym));\n-               raise Done;\n-            end if;\n-\n-            Delete (Fields1, Synonym);\n-         end;\n-      end if;\n-   end loop;\n-\n-   Put_Line (\"     OK\");\n-   New_Line;\n-   Put_Line (\"Check for missing set procedures in body\");\n-\n-   declare\n-      List : constant TV.Table_Array := Convert_To_Array (Fields1);\n-   begin\n-      if List'Length /= 0 then\n-         Put_Line (\"Missing procedure Set_\" & List (1).Name & \" in body\");\n-         raise Done;\n-      end if;\n-   end;\n-\n-   Put_Line (\"     OK\");\n-   New_Line;\n-   Put_Line (\"All tests completed successfully, no errors detected\");\n-\n-end CSinfo;"}, {"sha": "7f9849465eb30fcbb0f216209dfa90e168efa2cf", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Atree;    use Atree;\n with Csets;    use Csets;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Layout;   use Layout;\n with Namet;    use Namet;\n@@ -40,7 +42,9 @@ with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n with Sem_Mech; use Sem_Mech;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Uintp;    use Uintp;\n@@ -1105,7 +1109,7 @@ package body CStand is\n       --  Create semantic phase entities\n \n       Standard_Void_Type := New_Standard_Entity (\"_void_type\");\n-      Set_Ekind       (Standard_Void_Type, E_Void);\n+      pragma Assert (Ekind (Standard_Void_Type) = E_Void); -- it's the default\n       Set_Etype       (Standard_Void_Type, Standard_Void_Type);\n       Set_Scope       (Standard_Void_Type, Standard_Standard);\n "}, {"sha": "e2c72289f6dae28f296925a1165f5e16ff407f14", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -112,7 +112,7 @@ package body Debug is\n    --  d.y  Disable implicit pragma Elaborate_All on task bodies\n    --  d.z  Restore previous support for frontend handling of Inline_Always\n \n-   --  d.A  Print Atree statistics\n+   --  d.A\n    --  d.B  Generate a bug box on abort_statement\n    --  d.C  Generate concatenation call, do not generate inline code\n    --  d.D  Disable errors on use of overriding keyword in Ada 95 mode\n@@ -125,7 +125,7 @@ package body Debug is\n    --  d.K  Do not reject components in extensions overlapping with parent\n    --  d.L  Depend on back end for limited types in if and case expressions\n    --  d.M  Relaxed RM semantics\n-   --  d.N  Add node to all entities\n+   --  d.N\n    --  d.O  Dump internal SCO tables\n    --  d.P  Previous (non-optimized) handling of length comparisons\n    --  d.Q  Previous (incomplete) style check for binary operators\n@@ -160,7 +160,7 @@ package body Debug is\n    --  d_s  Stop elaboration checks on synchronous suspension\n    --  d_t\n    --  d_u\n-   --  d_v\n+   --  d_v  Enable additional checks and debug printouts in Atree\n    --  d_w\n    --  d_x  Disable inline expansion of Image attribute for enumeration types\n    --  d_y\n@@ -830,8 +830,6 @@ package body Debug is\n    --       handling of Inline_Always by the front end on such targets. For the\n    --       targets that do not use the GCC back end, this switch is ignored.\n \n-   --  d.A  Print Atree statistics\n-\n    --  d.B  Generate a bug box when we see an abort_statement, even though\n    --       there is no bug. Useful for testing Comperr.Compiler_Abort: write\n    --       some code containing an abort_statement, and compile it with\n@@ -900,10 +898,6 @@ package body Debug is\n    --  d.M  Relaxed RM semantics. This flag sets Opt.Relaxed_RM_Semantics\n    --       See Opt.Relaxed_RM_Semantics for more details.\n \n-   --  d.N  Enlarge entities by one node (but don't attempt to use this extra\n-   --       node for storage of any flags or fields). This can be used to do\n-   --       experiments on the impact of increasing entity sizes.\n-\n    --  d.O  Dump internal SCO tables. Before outputting the SCO information to\n    --       the ALI file, the internal SCO tables (SCO_Table/SCO_Unit_Table)\n    --       are dumped for debugging purposes.\n@@ -990,6 +984,8 @@ package body Debug is\n    --       a call to routine Ada.Synchronous_Task_Control.Suspend_Until_True\n    --       or Ada.Synchronous_Barriers.Wait_For_Release.\n \n+   --  d_v  Enable additional checks and debug printouts in Atree\n+\n    --  d_x  The compiler does not expand in line the Image attribute for user-\n    --       defined enumeration types and the standard boolean type.\n "}, {"sha": "571603038b71f68f05b6b734cc4e0392800fc411", "filename": "gcc/ada/debug_a.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fdebug_a.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fdebug_a.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug_a.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,8 @@\n \n with Atree;   use Atree;\n with Debug;   use Debug;\n-with Sinfo;   use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Sinput;  use Sinput;\n with Output;  use Output;\n "}, {"sha": "53ea5ca5997ee7090e2fc06bab4bc296626641e4", "filename": "gcc/ada/einfo-utils.adb", "status": "added", "additions": 3339, "deletions": 0, "changes": 3339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Feinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Feinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo-utils.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e"}, {"sha": "321caefca5e428074aeca8c1ef77b78ec3540566", "filename": "gcc/ada/einfo-utils.ads", "status": "added", "additions": 682, "deletions": 0, "changes": 682, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Feinfo-utils.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Feinfo-utils.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo-utils.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,682 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                           E I N F O . U T I L S                          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--           Copyright (C) 2020-2021, Free Software Foundation, Inc.        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Einfo.Entities; use Einfo.Entities;\n+\n+package Einfo.Utils is\n+\n+   -----------------------------------\n+   -- Renamings of Renamed_Or_Alias --\n+   -----------------------------------\n+\n+   --  See the comment in einfo.ads, \"Renaming and Aliasing\", which is somewhat\n+   --  incorrect. In fact, the compiler uses Alias, Renamed_Entity, and\n+   --  Renamed_Object more-or-less interchangeably, so we rename them here.\n+   --  ????Should add preconditions.\n+\n+   function Alias\n+     (N : Entity_Id) return Node_Id renames Renamed_Or_Alias;\n+   procedure Set_Alias\n+     (N : Entity_Id; Val : Node_Id) renames Set_Renamed_Or_Alias;\n+   function Renamed_Entity\n+     (N : Entity_Id) return Node_Id renames Renamed_Or_Alias;\n+   procedure Set_Renamed_Entity\n+     (N : Entity_Id; Val : Node_Id) renames Set_Renamed_Or_Alias;\n+   function Renamed_Object\n+     (N : Entity_Id) return Node_Id renames Renamed_Or_Alias;\n+   procedure Set_Renamed_Object\n+     (N : Entity_Id; Val : Node_Id) renames Set_Renamed_Or_Alias;\n+\n+   --------------------------\n+   -- Subtype Declarations --\n+   --------------------------\n+\n+   --  ????\n+   --  The above entities are arranged so that they can be conveniently grouped\n+   --  into subtype ranges. Note that for each of the xxx_Kind ranges defined\n+   --  below, there is a corresponding Is_xxx (or for types, Is_xxx_Type)\n+   --  predicate which is to be used in preference to direct range tests using\n+   --  the subtype name. However, the subtype names are available for direct\n+   --  use, e.g. as choices in case statements.\n+\n+   -------------------\n+   -- Type Synonyms --\n+   -------------------\n+\n+   --  The following type synonyms are used to tidy up the function and\n+   --  procedure declarations that follow, and also to make it possible to meet\n+   --  the requirement for the XEINFO utility that all function specs must fit\n+   --  on a single source line.????\n+\n+   subtype B is Boolean;\n+   subtype C is Component_Alignment_Kind;\n+   subtype E is Entity_Id;\n+   subtype F is Float_Rep_Kind;\n+   subtype M is Mechanism_Type;\n+   subtype N is Node_Id;\n+   subtype U is Uint;\n+   subtype R is Ureal;\n+   subtype L is Elist_Id;\n+   subtype S is List_Id;\n+\n+   -------------------------------\n+   -- Classification Attributes --\n+   -------------------------------\n+\n+   --  These functions provide a convenient functional notation for testing\n+   --  whether an Ekind value belongs to a specified kind, for example the\n+   --  function Is_Elementary_Type tests if its argument is in Elementary_Kind.\n+   --  In some cases, the test is of an entity attribute (e.g. in the case of\n+   --  Is_Generic_Type where the Ekind does not provide the needed\n+   --  information).\n+   --  ????Could automatically generate some of these?\n+\n+   function Is_Access_Object_Type               (Id : E) return B;\n+   function Is_Access_Type                      (Id : E) return B;\n+   function Is_Access_Protected_Subprogram_Type (Id : E) return B;\n+   function Is_Access_Subprogram_Type           (Id : E) return B;\n+   function Is_Aggregate_Type                   (Id : E) return B;\n+   function Is_Anonymous_Access_Type            (Id : E) return B;\n+   function Is_Array_Type                       (Id : E) return B;\n+   function Is_Assignable                       (Id : E) return B;\n+   function Is_Class_Wide_Type                  (Id : E) return B;\n+   function Is_Composite_Type                   (Id : E) return B;\n+   function Is_Concurrent_Body                  (Id : E) return B;\n+   function Is_Concurrent_Type                  (Id : E) return B;\n+   function Is_Decimal_Fixed_Point_Type         (Id : E) return B;\n+   function Is_Digits_Type                      (Id : E) return B;\n+   function Is_Discrete_Or_Fixed_Point_Type     (Id : E) return B;\n+   function Is_Discrete_Type                    (Id : E) return B;\n+   function Is_Elementary_Type                  (Id : E) return B;\n+   function Is_Entry                            (Id : E) return B;\n+   function Is_Enumeration_Type                 (Id : E) return B;\n+   function Is_Fixed_Point_Type                 (Id : E) return B;\n+   function Is_Floating_Point_Type              (Id : E) return B;\n+   function Is_Formal                           (Id : E) return B;\n+   function Is_Formal_Object                    (Id : E) return B;\n+   function Is_Generic_Subprogram               (Id : E) return B;\n+   function Is_Generic_Unit                     (Id : E) return B;\n+   function Is_Ghost_Entity                     (Id : E) return B;\n+   function Is_Incomplete_Or_Private_Type       (Id : E) return B;\n+   function Is_Incomplete_Type                  (Id : E) return B;\n+   function Is_Integer_Type                     (Id : E) return B;\n+   function Is_Modular_Integer_Type             (Id : E) return B;\n+   function Is_Named_Access_Type                (Id : E) return B;\n+   function Is_Named_Number                     (Id : E) return B;\n+   function Is_Numeric_Type                     (Id : E) return B;\n+   function Is_Object                           (Id : E) return B;\n+   function Is_Ordinary_Fixed_Point_Type        (Id : E) return B;\n+   function Is_Overloadable                     (Id : E) return B;\n+   function Is_Private_Type                     (Id : E) return B;\n+   function Is_Protected_Type                   (Id : E) return B;\n+   function Is_Real_Type                        (Id : E) return B;\n+   function Is_Record_Type                      (Id : E) return B;\n+   function Is_Scalar_Type                      (Id : E) return B;\n+   function Is_Signed_Integer_Type              (Id : E) return B;\n+   function Is_Subprogram                       (Id : E) return B;\n+   function Is_Subprogram_Or_Entry              (Id : E) return B;\n+   function Is_Subprogram_Or_Generic_Subprogram (Id : E) return B;\n+   function Is_Task_Type                        (Id : E) return B;\n+   function Is_Type                             (Id : E) return B;\n+\n+   -------------------------------------\n+   -- Synthesized Attribute Functions --\n+   -------------------------------------\n+\n+   --  The functions in this section synthesize attributes from the tree,\n+   --  so they do not correspond to defined fields in the entity itself.\n+\n+   function Address_Clause                      (Id : E) return N;\n+   function Aft_Value                           (Id : E) return U;\n+   function Alignment_Clause                    (Id : E) return N;\n+   function Base_Type                           (Id : E) return E;\n+   function Declaration_Node                    (Id : E) return N;\n+   function Designated_Type                     (Id : E) return E;\n+   function Entry_Index_Type                    (Id : E) return E;\n+   function First_Component                     (Id : E) return E;\n+   function First_Component_Or_Discriminant     (Id : E) return E;\n+   function First_Formal                        (Id : E) return E;\n+   function First_Formal_With_Extras            (Id : E) return E;\n+   function Has_Attach_Handler                  (Id : E) return B;\n+   function Has_DIC                             (Id : E) return B;\n+   function Has_Entries                         (Id : E) return B;\n+   function Has_Foreign_Convention              (Id : E) return B;\n+   function Has_Interrupt_Handler               (Id : E) return B;\n+   function Has_Invariants                      (Id : E) return B;\n+   function Has_Limited_View                    (Id : E) return B;\n+   function Has_Non_Limited_View                (Id : E) return B;\n+   function Has_Non_Null_Abstract_State         (Id : E) return B;\n+   function Has_Non_Null_Visible_Refinement     (Id : E) return B;\n+   function Has_Null_Abstract_State             (Id : E) return B;\n+   function Has_Null_Visible_Refinement         (Id : E) return B;\n+   function Implementation_Base_Type            (Id : E) return E;\n+   function Is_Base_Type                        (Id : E) return B;\n+   function Is_Boolean_Type                     (Id : E) return B;\n+   function Is_Constant_Object                  (Id : E) return B;\n+   function Is_Controlled                       (Id : E) return B;\n+   function Is_Discriminal                      (Id : E) return B;\n+   function Is_Dynamic_Scope                    (Id : E) return B;\n+   function Is_Elaboration_Target               (Id : E) return B;\n+   function Is_External_State                   (Id : E) return B;\n+   function Is_Finalizer                        (Id : E) return B;\n+   function Is_Full_Access                      (Id : E) return B;\n+   function Is_Null_State                       (Id : E) return B;\n+   function Is_Package_Or_Generic_Package       (Id : E) return B;\n+   function Is_Packed_Array                     (Id : E) return B;\n+   function Is_Prival                           (Id : E) return B;\n+   function Is_Protected_Component              (Id : E) return B;\n+   function Is_Protected_Interface              (Id : E) return B;\n+   function Is_Protected_Record_Type            (Id : E) return B;\n+   function Is_Relaxed_Initialization_State     (Id : E) return B;\n+   function Is_Standard_Character_Type          (Id : E) return B;\n+   function Is_Standard_String_Type             (Id : E) return B;\n+   function Is_String_Type                      (Id : E) return B;\n+   function Is_Synchronized_Interface           (Id : E) return B;\n+   function Is_Synchronized_State               (Id : E) return B;\n+   function Is_Task_Interface                   (Id : E) return B;\n+   function Is_Task_Record_Type                 (Id : E) return B;\n+   function Is_Wrapper_Package                  (Id : E) return B;\n+   function Last_Formal                         (Id : E) return E;\n+   function Machine_Emax_Value                  (Id : E) return U;\n+   function Machine_Emin_Value                  (Id : E) return U;\n+   function Machine_Mantissa_Value              (Id : E) return U;\n+   function Machine_Radix_Value                 (Id : E) return U;\n+   function Model_Emin_Value                    (Id : E) return U;\n+   function Model_Epsilon_Value                 (Id : E) return R;\n+   function Model_Mantissa_Value                (Id : E) return U;\n+   function Model_Small_Value                   (Id : E) return R;\n+   function Next_Component                      (Id : E) return E;\n+   function Next_Component_Or_Discriminant      (Id : E) return E;\n+   function Next_Discriminant                   (Id : E) return E;\n+   function Next_Formal                         (Id : E) return E;\n+   function Next_Formal_With_Extras             (Id : E) return E;\n+   function Next_Index                          (Id : N) return N;\n+   function Next_Literal                        (Id : E) return E;\n+   function Next_Stored_Discriminant            (Id : E) return E;\n+   function Number_Dimensions                   (Id : E) return Pos;\n+   function Number_Entries                      (Id : E) return Nat;\n+   function Number_Formals                      (Id : E) return Pos;\n+   function Object_Size_Clause                  (Id : E) return N;\n+   function Parameter_Mode                      (Id : E) return Formal_Kind;\n+   function Partial_Refinement_Constituents     (Id : E) return L;\n+   function Primitive_Operations                (Id : E) return L;\n+   function Root_Type                           (Id : E) return E;\n+   function Safe_Emax_Value                     (Id : E) return U;\n+   function Safe_First_Value                    (Id : E) return R;\n+   function Safe_Last_Value                     (Id : E) return R;\n+   function Scope_Depth                         (Id : E) return U;\n+   function Scope_Depth_Set                     (Id : E) return B;\n+   function Size_Clause                         (Id : E) return N;\n+   function Stream_Size_Clause                  (Id : E) return N;\n+   function Type_High_Bound                     (Id : E) return N;\n+   function Type_Low_Bound                      (Id : E) return N;\n+   function Underlying_Type                     (Id : E) return E;\n+\n+   ----------------------------------------------\n+   -- Type Representation Attribute Predicates --\n+   ----------------------------------------------\n+\n+   --  These predicates test the setting of the indicated attribute. If the\n+   --  value has been set, then Known is True, and Unknown is False. If no\n+   --  value is set, then Known is False and Unknown is True. The Known_Static\n+   --  predicate is true only if the value is set (Known) and is set to a\n+   --  compile time known value. Note that in the case of Alignment and\n+   --  Normalized_First_Bit, dynamic values are not possible, so we do not\n+   --  need a separate Known_Static calls in these cases. The not set (unknown)\n+   --  values are as follows:\n+\n+   --    Alignment               Uint_0 or No_Uint\n+   --    Component_Size          Uint_0 or No_Uint\n+   --    Component_Bit_Offset    No_Uint\n+   --    Digits_Value            Uint_0 or No_Uint\n+   --    Esize                   Uint_0 or No_Uint\n+   --    Normalized_First_Bit    No_Uint\n+   --    Normalized_Position     No_Uint\n+   --    Normalized_Position_Max No_Uint\n+   --    RM_Size                 Uint_0 or No_Uint\n+\n+   --  It would be cleaner to use No_Uint in all these cases, but historically\n+   --  we chose to use Uint_0 at first, and the change over will take time ???\n+   --  This is particularly true for the RM_Size field, where a value of zero\n+   --  is legitimate. We deal with this by a considering that the value is\n+   --  always known static for discrete types (and no other types can have\n+   --  an RM_Size value of zero).\n+\n+   --  In two cases, Known_Static_Esize and Known_Static_RM_Size, there is one\n+   --  more consideration, which is that we always return False for generic\n+   --  types. Within a template, the size can look known, because of the fake\n+   --  size values we put in template types, but they are not really known and\n+   --  anyone testing if they are known within the template should get False as\n+   --  a result to prevent incorrect assumptions.\n+\n+   function Known_Alignment                       (E : Entity_Id) return B;\n+   function Known_Component_Bit_Offset            (E : Entity_Id) return B;\n+   function Known_Component_Size                  (E : Entity_Id) return B;\n+   function Known_Esize                           (E : Entity_Id) return B;\n+   function Known_Normalized_First_Bit            (E : Entity_Id) return B;\n+   function Known_Normalized_Position             (E : Entity_Id) return B;\n+   function Known_Normalized_Position_Max         (E : Entity_Id) return B;\n+   function Known_RM_Size                         (E : Entity_Id) return B;\n+\n+   function Known_Static_Component_Bit_Offset     (E : Entity_Id) return B;\n+   function Known_Static_Component_Size           (E : Entity_Id) return B;\n+   function Known_Static_Esize                    (E : Entity_Id) return B;\n+   function Known_Static_Normalized_First_Bit     (E : Entity_Id) return B;\n+   function Known_Static_Normalized_Position      (E : Entity_Id) return B;\n+   function Known_Static_Normalized_Position_Max  (E : Entity_Id) return B;\n+   function Known_Static_RM_Size                  (E : Entity_Id) return B;\n+\n+   function Unknown_Alignment                     (E : Entity_Id) return B;\n+   function Unknown_Component_Bit_Offset          (E : Entity_Id) return B;\n+   function Unknown_Component_Size                (E : Entity_Id) return B;\n+   function Unknown_Esize                         (E : Entity_Id) return B;\n+   function Unknown_Normalized_First_Bit          (E : Entity_Id) return B;\n+   function Unknown_Normalized_Position           (E : Entity_Id) return B;\n+   function Unknown_Normalized_Position_Max       (E : Entity_Id) return B;\n+   function Unknown_RM_Size                       (E : Entity_Id) return B;\n+\n+   ---------------------------------------------------\n+   -- Access to Subprograms in Subprograms_For_Type --\n+   ---------------------------------------------------\n+\n+   function Is_Partial_DIC_Procedure            (Id : E) return B;\n+\n+   function DIC_Procedure                        (Id : E) return E;\n+   function Partial_DIC_Procedure                (Id : E) return E;\n+   function Invariant_Procedure                  (Id : E) return E;\n+   function Partial_Invariant_Procedure          (Id : E) return E;\n+   function Predicate_Function                   (Id : E) return E;\n+   function Predicate_Function_M                 (Id : E) return E;\n+\n+   procedure Set_DIC_Procedure                   (Id : E; V : E);\n+   procedure Set_Partial_DIC_Procedure           (Id : E; V : E);\n+   procedure Set_Invariant_Procedure             (Id : E; V : E);\n+   procedure Set_Partial_Invariant_Procedure     (Id : E; V : E);\n+   procedure Set_Predicate_Function              (Id : E; V : E);\n+   procedure Set_Predicate_Function_M            (Id : E; V : E);\n+\n+   -----------------------------------\n+   -- Field Initialization Routines --\n+   -----------------------------------\n+\n+   --  These routines are overloadings of some of the above Set procedures\n+   --  where the argument is normally a Uint. The overloadings take an Int\n+   --  parameter instead, and appropriately convert it. There are also\n+   --  versions that implicitly initialize to the appropriate \"not set\"\n+   --  value. The not set (unknown) values are as follows:\n+\n+   --    Alignment                 Uint_0\n+   --    Component_Size            Uint_0\n+   --    Component_Bit_Offset      No_Uint\n+   --    Digits_Value              Uint_0\n+   --    Esize                     Uint_0\n+   --    Normalized_First_Bit      No_Uint\n+   --    Normalized_Position       No_Uint\n+   --    Normalized_Position_Max   No_Uint\n+   --    RM_Size                   Uint_0\n+\n+   --  It would be cleaner to use No_Uint in all these cases, but historically\n+   --  we chose to use Uint_0 at first, and the change over will take time ???\n+   --  This is particularly true for the RM_Size field, where a value of zero\n+   --  is legitimate and causes some special tests around the code.\n+\n+   --  Contrary to the corresponding Set procedures above, these routines\n+   --  do NOT check the entity kind of their argument, instead they set the\n+   --  underlying Uint fields directly (this allows them to be used for\n+   --  entities whose Ekind has not been set yet).\n+\n+   procedure Init_Alignment                (Id : E; V : Int);\n+   procedure Init_Component_Bit_Offset     (Id : E; V : Int);\n+   procedure Init_Component_Size           (Id : E; V : Int);\n+   procedure Init_Digits_Value             (Id : E; V : Int);\n+   procedure Init_Esize                    (Id : E; V : Int);\n+   procedure Init_Normalized_First_Bit     (Id : E; V : Int);\n+   procedure Init_Normalized_Position      (Id : E; V : Int);\n+   procedure Init_Normalized_Position_Max  (Id : E; V : Int);\n+   procedure Init_RM_Size                  (Id : E; V : Int);\n+\n+   procedure Init_Alignment                (Id : E);\n+   procedure Init_Component_Bit_Offset     (Id : E);\n+   procedure Init_Component_Size           (Id : E);\n+   procedure Init_Digits_Value             (Id : E);\n+   procedure Init_Esize                    (Id : E);\n+   procedure Init_Normalized_First_Bit     (Id : E);\n+   procedure Init_Normalized_Position      (Id : E);\n+   procedure Init_Normalized_Position_Max  (Id : E);\n+   procedure Init_RM_Size                  (Id : E);\n+\n+   procedure Init_Component_Location (Id : E);\n+   --  Initializes all fields describing the location of a component\n+   --  (Normalized_Position, Component_Bit_Offset, Normalized_First_Bit,\n+   --  Normalized_Position_Max, Esize) to all be Unknown.\n+\n+   procedure Init_Size (Id : E; V : Int);\n+   --  Initialize both the Esize and RM_Size fields of E to V\n+\n+   procedure Init_Size_Align (Id : E);\n+   --  This procedure initializes both size fields and the alignment\n+   --  field to all be Unknown.\n+\n+   procedure Init_Object_Size_Align (Id : E);\n+   --  Same as Init_Size_Align except RM_Size field (which is only for types)\n+   --  is unaffected.\n+\n+   ---------------\n+   -- Iterators --\n+   ---------------\n+\n+   --  The call to Next_xxx (obj) is equivalent to obj := Next_xxx (obj)\n+   --  We define the set of Proc_Next_xxx routines simply for the purposes\n+   --  of inlining them without necessarily inlining the function.\n+\n+   procedure Proc_Next_Component                 (N : in out Node_Id);\n+   procedure Proc_Next_Component_Or_Discriminant (N : in out Node_Id);\n+   procedure Proc_Next_Discriminant              (N : in out Node_Id);\n+   procedure Proc_Next_Formal                    (N : in out Node_Id);\n+   procedure Proc_Next_Formal_With_Extras        (N : in out Node_Id);\n+   procedure Proc_Next_Index                     (N : in out Node_Id);\n+   procedure Proc_Next_Inlined_Subprogram        (N : in out Node_Id);\n+   procedure Proc_Next_Literal                   (N : in out Node_Id);\n+   procedure Proc_Next_Stored_Discriminant       (N : in out Node_Id);\n+\n+   pragma Inline (Proc_Next_Component);\n+   pragma Inline (Proc_Next_Component_Or_Discriminant);\n+   pragma Inline (Proc_Next_Discriminant);\n+   pragma Inline (Proc_Next_Formal);\n+   pragma Inline (Proc_Next_Formal_With_Extras);\n+   pragma Inline (Proc_Next_Index);\n+   pragma Inline (Proc_Next_Inlined_Subprogram);\n+   pragma Inline (Proc_Next_Literal);\n+   pragma Inline (Proc_Next_Stored_Discriminant);\n+\n+   procedure Next_Component                 (N : in out Node_Id)\n+     renames Proc_Next_Component;\n+\n+   procedure Next_Component_Or_Discriminant (N : in out Node_Id)\n+     renames Proc_Next_Component_Or_Discriminant;\n+\n+   procedure Next_Discriminant              (N : in out Node_Id)\n+     renames Proc_Next_Discriminant;\n+\n+   procedure Next_Formal                    (N : in out Node_Id)\n+     renames Proc_Next_Formal;\n+\n+   procedure Next_Formal_With_Extras        (N : in out Node_Id)\n+     renames Proc_Next_Formal_With_Extras;\n+\n+   procedure Next_Index                     (N : in out Node_Id)\n+     renames Proc_Next_Index;\n+\n+   procedure Next_Inlined_Subprogram        (N : in out Node_Id)\n+     renames Proc_Next_Inlined_Subprogram;\n+\n+   procedure Next_Literal                   (N : in out Node_Id)\n+     renames Proc_Next_Literal;\n+\n+   procedure Next_Stored_Discriminant       (N : in out Node_Id)\n+     renames Proc_Next_Stored_Discriminant;\n+\n+   ---------------------------\n+   -- Testing Warning Flags --\n+   ---------------------------\n+\n+   --  These routines are to be used rather than testing flags Warnings_Off,\n+   --  Has_Pragma_Unmodified, Has_Pragma_Unreferenced. They deal with setting\n+   --  the flags Warnings_Off_Used[_Unmodified|Unreferenced] for later access.\n+\n+   function Has_Warnings_Off (E : Entity_Id) return Boolean;\n+   --  If Warnings_Off is set on E, then returns True and also sets the flag\n+   --  Warnings_Off_Used on E. If Warnings_Off is not set on E, returns False\n+   --  and has no side effect.\n+\n+   function Has_Unmodified (E : Entity_Id) return Boolean;\n+   --  If flag Has_Pragma_Unmodified is set on E, returns True with no side\n+   --  effects. Otherwise if Warnings_Off is set on E, returns True and also\n+   --  sets the flag Warnings_Off_Used_Unmodified on E. If neither of the flags\n+   --  Warnings_Off nor Has_Pragma_Unmodified is set, returns False with no\n+   --  side effects.\n+\n+   function Has_Unreferenced (E : Entity_Id) return Boolean;\n+   --  If flag Has_Pragma_Unreferenced is set on E, returns True with no side\n+   --  effects. Otherwise if Warnings_Off is set on E, returns True and also\n+   --  sets the flag Warnings_Off_Used_Unreferenced on E. If neither of the\n+   --  flags Warnings_Off nor Has_Pragma_Unreferenced is set, returns False\n+   --  with no side effects.\n+\n+   ----------------------------------------------\n+   -- Subprograms for Accessing Rep Item Chain --\n+   ----------------------------------------------\n+\n+   --  The First_Rep_Item field of every entity points to a linked list (linked\n+   --  through Next_Rep_Item) of representation pragmas, attribute definition\n+   --  clauses, representation clauses, and aspect specifications that apply to\n+   --  the item. Note that in the case of types, it is assumed that any such\n+   --  rep items for a base type also apply to all subtypes. This is achieved\n+   --  by having the chain for subtypes link onto the chain for the base type,\n+   --  so that new entries for the subtype are added at the start of the chain.\n+   --\n+   --  Note: aspect specification nodes are linked only when evaluation of the\n+   --  expression is deferred to the freeze point. For further details see\n+   --  Sem_Ch13.Analyze_Aspect_Specifications.\n+\n+   function Get_Attribute_Definition_Clause\n+     (E  : Entity_Id;\n+      Id : Attribute_Id) return Node_Id;\n+   --  Searches the Rep_Item chain for a given entity E, for an instance of an\n+   --  attribute definition clause with the given attribute Id. If found, the\n+   --  value returned is the N_Attribute_Definition_Clause node, otherwise\n+   --  Empty is returned.\n+\n+   --  WARNING: There is a matching C declaration of this subprogram in fe.h\n+\n+   function Get_Pragma (E : Entity_Id; Id : Pragma_Id) return Node_Id;\n+   --  Searches the Rep_Item chain of entity E, for an instance of a pragma\n+   --  with the given pragma Id. If found, the value returned is the N_Pragma\n+   --  node, otherwise Empty is returned. The following contract pragmas that\n+   --  appear in N_Contract nodes are also handled by this routine:\n+   --    Abstract_State\n+   --    Async_Readers\n+   --    Async_Writers\n+   --    Attach_Handler\n+   --    Constant_After_Elaboration\n+   --    Contract_Cases\n+   --    Depends\n+   --    Effective_Reads\n+   --    Effective_Writes\n+   --    Global\n+   --    Initial_Condition\n+   --    Initializes\n+   --    Interrupt_Handler\n+   --    No_Caching\n+   --    Part_Of\n+   --    Precondition\n+   --    Postcondition\n+   --    Refined_Depends\n+   --    Refined_Global\n+   --    Refined_Post\n+   --    Refined_State\n+   --    Subprogram_Variant\n+   --    Test_Case\n+   --    Volatile_Function\n+\n+   function Get_Class_Wide_Pragma\n+     (E  : Entity_Id;\n+      Id : Pragma_Id) return Node_Id;\n+   --  Examine Rep_Item chain to locate a classwide pre- or postcondition of a\n+   --  primitive operation. Returns Empty if not present.\n+\n+   function Get_Record_Representation_Clause (E : Entity_Id) return Node_Id;\n+   --  Searches the Rep_Item chain for a given entity E, for a record\n+   --  representation clause, and if found, returns it. Returns Empty\n+   --  if no such clause is found.\n+\n+   function Present_In_Rep_Item (E : Entity_Id; N : Node_Id) return Boolean;\n+   --  Return True if N is present in the Rep_Item chain for a given entity E\n+\n+   procedure Record_Rep_Item (E : Entity_Id; N : Node_Id);\n+   --  N is the node for a representation pragma, representation clause, an\n+   --  attribute definition clause, or an aspect specification that applies to\n+   --  entity E. This procedure links the node N onto the Rep_Item chain for\n+   --  entity E. Note that it is an error to call this procedure with E being\n+   --  overloadable, and N being a pragma that applies to multiple overloadable\n+   --  entities (Convention, Interface, Inline, Inline_Always, Import, Export,\n+   --  External). This is not allowed even in the case where the entity is not\n+   --  overloaded, since we can't rely on it being present in the overloaded\n+   --  case, it is not useful to have it present in the non-overloaded case.\n+\n+   -------------------------------\n+   -- Miscellaneous Subprograms --\n+   -------------------------------\n+\n+   procedure Append_Entity (Id : Entity_Id; Scop : Entity_Id);\n+   --  Add an entity to the list of entities declared in the scope Scop\n+\n+   function Get_Full_View (T : Entity_Id) return Entity_Id;\n+   --  If T is an incomplete type and the full declaration has been seen, or\n+   --  is the name of a class_wide type whose root is incomplete, return the\n+   --  corresponding full declaration, else return T itself.\n+\n+   function Is_Entity_Name (N : Node_Id) return Boolean;\n+   --  Test if the node N is the name of an entity (i.e. is an identifier,\n+   --  expanded name, or an attribute reference that returns an entity).\n+\n+   --  WARNING: There is a matching C declaration of this subprogram in fe.h\n+\n+   procedure Link_Entities (First : Entity_Id; Second : Entity_Id);\n+   --  Link entities First and Second in one entity chain.\n+   --\n+   --  NOTE: No updates are done to the First_Entity and Last_Entity fields\n+   --  of the scope.\n+\n+   procedure Remove_Entity (Id : Entity_Id);\n+   --  Remove entity Id from the entity chain of its scope\n+\n+   function Subtype_Kind (K : Entity_Kind) return Entity_Kind;\n+   --  Given an entity_kind K this function returns the entity_kind\n+   --  corresponding to subtype kind of the type represented by K. For\n+   --  example if K is E_Signed_Integer_Type then E_Signed_Integer_Subtype\n+   --  is returned. If K is already a subtype kind it itself is returned. An\n+   --  internal error is generated if no such correspondence exists for K.\n+\n+   procedure Unlink_Next_Entity (Id : Entity_Id);\n+   --  Unchain entity Id's forward link within the entity chain of its scope\n+\n+   function Is_Volatile (Id : E) return B;\n+   procedure Set_Is_Volatile (Id : E; V : B := True);\n+   --  Call [Set_]Is_Volatile_Type/Is_Volatile_Object as appropriate for the\n+   --  Ekind of Id.\n+\n+   function Convention\n+     (N : Entity_Id) return Convention_Id renames Basic_Convention;\n+   procedure Set_Convention (E : Entity_Id; Val : Convention_Id);\n+   --  Same as Set_Basic_Convention, but with an extra check for access types.\n+   --  In particular, if E is an access-to-subprogram type, and Val is a\n+   --  foreign convention, then we set Can_Use_Internal_Rep to False on E.\n+   --  Also, if the Etype of E is set and is an anonymous access type with\n+   --  no convention set, this anonymous type inherits the convention of E.\n+\n+   ----------------------------------\n+   -- Debugging Output Subprograms --\n+   ----------------------------------\n+\n+   procedure Write_Entity_Info (Id : Entity_Id; Prefix : String);\n+   --  A debugging procedure to write out information about an entity\n+\n+   --  ????Make sure the Inlines from Einfo were fully copied here.\n+   --  ????\n+   --  The following Inline pragmas are *not* read by XEINFO when building the\n+   --  C version of this interface automatically (so the C version will end up\n+   --  making out of line calls). The pragma scan in XEINFO will be terminated\n+   --  on encountering the END XEINFO INLINES line. We inline things here which\n+   --  are small, but not of the canonical attribute access/set format that can\n+   --  be handled by XEINFO.\n+\n+   pragma Inline (Address_Clause);\n+   pragma Inline (Alignment_Clause);\n+   pragma Inline (Base_Type);\n+\n+   pragma Inline (Has_Foreign_Convention);\n+   pragma Inline (Has_Non_Limited_View);\n+   pragma Inline (Is_Base_Type);\n+   pragma Inline (Is_Boolean_Type);\n+   pragma Inline (Is_Constant_Object);\n+   pragma Inline (Is_Controlled);\n+   pragma Inline (Is_Discriminal);\n+   pragma Inline (Is_Entity_Name);\n+   pragma Inline (Is_Finalizer);\n+   pragma Inline (Is_Full_Access);\n+   pragma Inline (Is_Null_State);\n+   pragma Inline (Is_Package_Or_Generic_Package);\n+   pragma Inline (Is_Packed_Array);\n+   pragma Inline (Is_Prival);\n+   pragma Inline (Is_Protected_Component);\n+   pragma Inline (Is_Protected_Record_Type);\n+   pragma Inline (Is_String_Type);\n+   pragma Inline (Is_Task_Record_Type);\n+   pragma Inline (Is_Wrapper_Package);\n+   pragma Inline (Scope_Depth);\n+   pragma Inline (Scope_Depth_Set);\n+   pragma Inline (Size_Clause);\n+   pragma Inline (Stream_Size_Clause);\n+   pragma Inline (Type_High_Bound);\n+   pragma Inline (Type_Low_Bound);\n+\n+   pragma Inline (Known_Alignment);\n+   pragma Inline (Known_Component_Bit_Offset);\n+   pragma Inline (Known_Component_Size);\n+   pragma Inline (Known_Esize);\n+   pragma Inline (Known_Normalized_First_Bit);\n+   pragma Inline (Known_Normalized_Position);\n+   pragma Inline (Known_Normalized_Position_Max);\n+   pragma Inline (Known_RM_Size);\n+\n+   pragma Inline (Known_Static_Component_Bit_Offset);\n+   pragma Inline (Known_Static_Component_Size);\n+   pragma Inline (Known_Static_Esize);\n+   pragma Inline (Known_Static_Normalized_First_Bit);\n+   pragma Inline (Known_Static_Normalized_Position);\n+   pragma Inline (Known_Static_Normalized_Position_Max);\n+   pragma Inline (Known_Static_RM_Size);\n+\n+   pragma Inline (Unknown_Alignment);\n+   pragma Inline (Unknown_Component_Bit_Offset);\n+   pragma Inline (Unknown_Component_Size);\n+   pragma Inline (Unknown_Esize);\n+   pragma Inline (Unknown_Normalized_First_Bit);\n+   pragma Inline (Unknown_Normalized_Position);\n+   pragma Inline (Unknown_Normalized_Position_Max);\n+   pragma Inline (Unknown_RM_Size);\n+\n+   pragma Inline (Init_Alignment);\n+   pragma Inline (Init_Component_Bit_Offset);\n+   pragma Inline (Init_Component_Size);\n+   pragma Inline (Init_Digits_Value);\n+   pragma Inline (Init_Esize);\n+   pragma Inline (Init_Normalized_First_Bit);\n+   pragma Inline (Init_Normalized_Position);\n+   pragma Inline (Init_Normalized_Position_Max);\n+   pragma Inline (Init_RM_Size);\n+\n+end Einfo.Utils;"}, {"sha": "3202f99b3c25e9ded75d72f66bfc8f738a7f444c", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 1, "deletions": 11570, "changes": 11571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e"}, {"sha": "3995f8ed43fbdaf19aeae987eb29f22542413dcc", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 119, "deletions": 3480, "changes": 3599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e"}, {"sha": "0ed58d494329f7ed077c8fb673decd973a7a5cb1", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -33,7 +33,9 @@ with Atree;    use Atree;\n with Casing;   use Casing;\n with Csets;    use Csets;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Erroutc;  use Erroutc;\n with Gnatvsn;  use Gnatvsn;\n with Lib;      use Lib;\n@@ -43,7 +45,9 @@ with Output;   use Output;\n with Scans;    use Scans;\n with Sem_Aux;  use Sem_Aux;\n with Sinput;   use Sinput;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stylesw;  use Stylesw;\n@@ -4010,7 +4014,8 @@ package body Errout is\n          --  other errors. The reason we eliminate unfrozen types is that\n          --  messages issued before the freeze type are for sure OK.\n \n-         elsif Is_Frozen (E)\n+         elsif Nkind (N) in N_Entity\n+           and then Is_Frozen (E)\n            and then Serious_Errors_Detected > 0\n            and then Nkind (N) /= N_Component_Clause\n            and then Nkind (Parent (N)) /= N_Component_Clause"}, {"sha": "94f7ad6742acade3b95150eb8d631a76de92fd3b", "filename": "gcc/ada/eval_fat.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Feval_fat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Feval_fat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -23,7 +23,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Opt;      use Opt;\n with Sem_Util; use Sem_Util;"}, {"sha": "531483762dbd2eed91b66910833dee4aa63d29bc", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,9 @@ with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Expander; use Expander;\n@@ -59,7 +61,9 @@ with Sem_Eval; use Sem_Eval;\n with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;"}, {"sha": "313da779490b1db2abbd3b6cba7de4ea51a85022", "filename": "gcc/ada/exp_atag.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_atag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_atag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,15 +24,18 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Exp_Disp; use Exp_Disp;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Disp; use Sem_Disp;\n with Sem_Util; use Sem_Util;"}, {"sha": "9aecf6d036264547e36fcb0d85dcb251fd317c75", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Exp_Atag; use Exp_Atag;\n with Exp_Ch3;  use Exp_Ch3;\n@@ -59,7 +61,9 @@ with Sem_Ch8;  use Sem_Ch8;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n@@ -7330,7 +7334,7 @@ package body Exp_Attr is\n                P    : Node_Id := Pref;\n \n             begin\n-               --  If the prefix has an entity, use the Esize from this entity\n+               --  If the prefix is an object, use the Esize from this object\n                --  to handle in a more user friendly way the case of objects\n                --  or components with a large Size aspect: if a Size aspect is\n                --  specified, we want to read a scalar value as large as the\n@@ -7343,6 +7347,7 @@ package body Exp_Attr is\n \n                if Nkind (P) in N_Has_Entity\n                  and then Present (Entity (P))\n+                 and then Is_Object (Entity (P))\n                  and then Esize (Entity (P)) /= Uint_0\n                then\n                   if Esize (Entity (P)) <= System_Max_Integer_Size then"}, {"sha": "7d7dd5bcd1de7e32500b1273a2bd65139068913e", "filename": "gcc/ada/exp_cg.adb", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_cg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_cg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_cg.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,7 +24,9 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Tss;  use Exp_Tss;\n@@ -36,7 +38,9 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Disp; use Sem_Disp;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with System;   use System;\n@@ -376,7 +380,14 @@ package body Exp_CG is\n                  and then Nkind (Parent (Par)) /= N_Compilation_Unit\n                loop\n                   Par := Parent (Par);\n-                  pragma Assert (Present (Par));\n+\n+                  --  Par can legitimately be empty inside a class-wide\n+                  --  precondition; the \"real\" call will be found inside the\n+                  --  generated pragma.\n+\n+                  if No (Par) then\n+                     return;\n+                  end if;\n                end loop;\n \n                Set_Parent (Copy, Par);\n@@ -429,7 +440,7 @@ package body Exp_CG is\n    procedure Write_Call_Info (Call : Node_Id) is\n       Ctrl_Arg : constant Node_Id   := Controlling_Argument (Call);\n       Ctrl_Typ : constant Entity_Id := Base_Type (Etype (Ctrl_Arg));\n-      Prim     : constant Entity_Id := Entity (Sinfo.Name (Call));\n+      Prim     : constant Entity_Id := Entity (Sinfo.Nodes.Name (Call));\n       P        : constant Node_Id   := Parent (Call);\n \n    begin\n@@ -559,13 +570,13 @@ package body Exp_CG is\n          Write_Char ('\"');\n          Write_Name (Chars (Parent_Typ));\n \n-         --  Note: Einfo prefix not needed if this routine is moved to\n+         --  Note: Einfo.Entities prefix not needed if this routine is moved to\n          --  exp_disp???\n \n-         if Present (Einfo.Interfaces (Typ))\n-           and then not Is_Empty_Elmt_List (Einfo.Interfaces (Typ))\n+         if Present (Einfo.Entities.Interfaces (Typ))\n+           and then not Is_Empty_Elmt_List (Einfo.Entities.Interfaces (Typ))\n          then\n-            Elmt := First_Elmt (Einfo.Interfaces (Typ));\n+            Elmt := First_Elmt (Einfo.Entities.Interfaces (Typ));\n             while Present (Elmt) loop\n                Write_Str  (\", \");\n                Write_Name (Chars (Node (Elmt)));"}, {"sha": "5b9812242d526076c8087eafd874401c784f3d15", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Atree;    use Atree;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch7;  use Exp_Ch7;\n@@ -42,7 +44,9 @@ with Sem;      use Sem;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;"}, {"sha": "ce52b64aacdd9adc2b468c361bcc6bb1587fd0c7", "filename": "gcc/ada/exp_ch12.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch12.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,10 +25,13 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n with Exp_Util; use Exp_Util;\n with Nmake;    use Nmake;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Tbuild;   use Tbuild;"}, {"sha": "efb43f0eb11d2ecdc9016162a137c3c453a262ba", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch6;\n with Exp_Imgv; use Exp_Imgv;\n@@ -45,7 +47,9 @@ with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;"}, {"sha": "30a9c73e2d2fb07c4e9d84d8cb32c04013598ab3", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Exp_Smem; use Exp_Smem;\n with Exp_Tss;  use Exp_Tss;\n@@ -40,7 +42,9 @@ with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Tbuild;   use Tbuild;"}, {"sha": "6843069a321c32a645dde73aeedec173b9563a3e", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Atag; use Exp_Atag;\n@@ -66,7 +68,9 @@ with Sem_Res;  use Sem_Res;\n with Sem_SCIL; use Sem_SCIL;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Stand;    use Stand;\n with Snames;   use Snames;\n with Tbuild;   use Tbuild;"}, {"sha": "1a12cf0200aa58e35297fda776cd84e5e9e12275", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n@@ -61,7 +63,9 @@ with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with SCIL_LL;  use SCIL_LL;"}, {"sha": "9b403aff3744e2a3f318626f45f1cdbd8c6fe3eb", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,9 @@ with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch6;  use Exp_Ch6;\n@@ -45,7 +47,9 @@ with Opt;      use Opt;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch3;  use Sem_Ch3;"}, {"sha": "4471f35067dc09d99b28b389d5d10d5e1365b24c", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -28,7 +28,9 @@ with Aspects;   use Aspects;\n with Checks;    use Checks;\n with Contracts; use Contracts;\n with Debug;     use Debug;\n-with Einfo;     use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;    use Errout;\n with Elists;    use Elists;\n with Expander;  use Expander;\n@@ -68,7 +70,9 @@ with Sem_Mech;  use Sem_Mech;\n with Sem_Res;   use Sem_Res;\n with Sem_SCIL;  use Sem_SCIL;\n with Sem_Util;  use Sem_Util;\n-with Sinfo;     use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;    use Snames;\n with Stand;     use Stand;\n with Tbuild;    use Tbuild;\n@@ -2209,7 +2213,7 @@ package body Exp_Ch6 is\n \n          --  Check for volatility mismatch\n \n-         if Is_Volatile_Object (Actual) and then not Is_Volatile (E_Formal)\n+         if Is_Volatile_Object_Ref (Actual) and then not Is_Volatile (E_Formal)\n          then\n             if Comes_From_Source (N) then\n                Error_Msg_N"}, {"sha": "2e0616977c47c497a12d73b910751ddd0a9c2cad", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -30,7 +30,9 @@\n with Atree;     use Atree;\n with Contracts; use Contracts;\n with Debug;     use Debug;\n-with Einfo;     use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;    use Elists;\n with Errout;    use Errout;\n with Exp_Ch6;   use Exp_Ch6;\n@@ -52,7 +54,9 @@ with Output;    use Output;\n with Restrict;  use Restrict;\n with Rident;    use Rident;\n with Rtsfind;   use Rtsfind;\n-with Sinfo;     use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sem;       use Sem;\n with Sem_Aux;   use Sem_Aux;\n with Sem_Ch3;   use Sem_Ch3;"}, {"sha": "554b5c84162092247d873bf97b18942d4588b2f5", "filename": "gcc/ada/exp_ch8.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,7 +24,9 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch4;  use Exp_Ch4;\n with Exp_Ch6;  use Exp_Ch6;\n@@ -39,7 +41,9 @@ with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Tbuild;   use Tbuild;"}, {"sha": "356f11898e5469a0178f6b4e6560bb585c25c161", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Atree;    use Atree;\n with Aspects;  use Aspects;\n with Checks;   use Checks;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch3;  use Exp_Ch3;\n@@ -59,7 +61,9 @@ with Sem_Elab; use Sem_Elab;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Targparm; use Targparm;"}, {"sha": "9bfcd447d2f4dc594324c3614fd96b580a39496a", "filename": "gcc/ada/exp_code.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_code.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_code.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_code.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,7 +24,9 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Lib;      use Lib;\n with Namet;    use Namet;\n@@ -36,7 +38,9 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Stringt;  use Stringt;\n with Tbuild;   use Tbuild;\n "}, {"sha": "3cec36a0c46502a11564b16de3c000f284abe5fd", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Alloc;\n with Atree;    use Atree;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Exp_Util; use Exp_Util;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -35,7 +37,9 @@ with Output;   use Output;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n with Table;"}, {"sha": "d7102f6b27a2559cdadfe432896aa2bb6b73eb19", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Expander; use Expander;\n@@ -58,7 +60,9 @@ with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n@@ -4093,7 +4097,10 @@ package body Exp_Disp is\n             Count := Count + 1;\n          end loop;\n \n-         pragma Assert (Related_Type (Node (Elmt)) = Typ);\n+         --  Related_Type (Node (Elmt)) should be equal to Typ here, but we\n+         --  can't assert that, because it is sometimes false in illegal\n+         --  programs. We can't check Serious_Errors_Detected, because the\n+         --  errors have not yet been detected.\n \n          Get_External_Name (Node (Elmt));\n          Set_Interface_Name (DT,\n@@ -4694,8 +4701,8 @@ package body Exp_Disp is\n \n       Discard_Names : constant Boolean :=\n                         Present (No_Tagged_Streams_Pragma (Typ))\n-                          and then (Global_Discard_Names\n-                                     or else Einfo.Discard_Names (Typ));\n+                          and then\n+        (Global_Discard_Names or else Einfo.Entities.Discard_Names (Typ));\n \n       --  The following name entries are used by Make_DT to generate a number\n       --  of entities related to a tagged type. These entities may be generated"}, {"sha": "1d1cd4c803a62822f70ed2ac4de6d96661eba0e9", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,7 +24,9 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Exp_Atag; use Exp_Atag;\n with Exp_Strm; use Exp_Strm;\n@@ -44,7 +46,9 @@ with Sem_Ch12; use Sem_Ch12;\n with Sem_Dist; use Sem_Dist;\n with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n with Tbuild;   use Tbuild;"}, {"sha": "8d6da50c566121e974f14f9e7c56b4c1eca200ba", "filename": "gcc/ada/exp_fixd.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_fixd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_fixd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Exp_Util; use Exp_Util;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -36,7 +38,8 @@ with Sem;      use Sem;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Stand;    use Stand;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;"}, {"sha": "b7ae3cd6a2a1495919f0456a86309f4a7347a0b4", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,8 +26,10 @@\n with Atree;    use Atree;\n with Casing;   use Casing;\n with Checks;   use Checks;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n with Exp_Put_Image;\n with Exp_Util; use Exp_Util;\n with Lib;      use Lib;\n@@ -39,7 +41,9 @@ with Rtsfind;  use Rtsfind;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;"}, {"sha": "66f3f2c49a513eef767e5007924881f5544077a0", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Expander; use Expander;\n with Exp_Atag; use Exp_Atag;\n@@ -48,7 +50,9 @@ with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;"}, {"sha": "e3872d5187d902e5a8bf3a551bc58dcde98846e3", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Util; use Exp_Util;\n@@ -43,7 +45,9 @@ with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Targparm; use Targparm;"}, {"sha": "11b80cd93ddf9db8bb9273858f4003b11ed45719", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,9 @@ with Atree;    use Atree;\n with Casing;   use Casing;\n with Checks;   use Checks;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch11; use Exp_Ch11;\n@@ -47,7 +49,9 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stringt;  use Stringt;"}, {"sha": "7793f1b89fd952cedf8343f70682ab8950759d75", "filename": "gcc/ada/exp_put_image.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_put_image.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_put_image.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_put_image.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,7 +24,9 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util;\n with Debug;    use Debug;\n@@ -36,7 +38,9 @@ with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;\n with Tbuild;   use Tbuild;"}, {"sha": "3abcc4decd2279fa2b3c865ac1c1495a240a6c6a", "filename": "gcc/ada/exp_sel.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_sel.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_sel.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_sel.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -23,12 +23,14 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Einfo;   use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n with Nlists;  use Nlists;\n with Nmake;   use Nmake;\n with Opt;     use Opt;\n with Rtsfind; use Rtsfind;\n-with Sinfo;   use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Snames;  use Snames;\n with Stand;   use Stand;\n with Tbuild;  use Tbuild;"}, {"sha": "8ebc571b26ea7c51debc175a2a4e7beadf3242d7", "filename": "gcc/ada/exp_smem.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_smem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_smem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_smem.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,7 +24,9 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch9;  use Exp_Ch9;\n@@ -37,7 +39,9 @@ with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;"}, {"sha": "aa5e6a01fb10e771f55944105111d13f259dcd8f", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Exp_Attr;\n with Exp_Ch4;\n with Exp_Ch5;  use Exp_Ch5;\n@@ -40,7 +42,9 @@ with Sem_Ch8;  use Sem_Ch8;\n with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Tbuild;   use Tbuild;"}, {"sha": "4502d51c87a6a62caa711d9fb1321e1142b27244", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,7 +24,9 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Exp_Util; use Exp_Util;\n with Namet;    use Namet;\n@@ -33,7 +35,9 @@ with Nmake;    use Nmake;\n with Rtsfind;  use Rtsfind;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Tbuild;   use Tbuild;"}, {"sha": "10a68029f84858fc9b70effe5eb75fff3fcb9a43", "filename": "gcc/ada/exp_tss.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_tss.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_tss.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_tss.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,7 +24,9 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Exp_Util; use Exp_Util;\n with Nlists;   use Nlists;\n@@ -34,7 +36,8 @@ with Rident;   use Rident;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n \n package body Exp_Tss is\n "}, {"sha": "f19a591efcad2e5dd7d4abdc3101ded58f7b23ab", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Atree;    use Atree;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Exp_Util; use Exp_Util;\n with Lib;      use Lib;\n@@ -41,7 +43,9 @@ with Sem_Ch8;  use Sem_Ch8;\n with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;"}, {"sha": "8137afb3ca82a165b4f59d782c17cf0bcbf7bbeb", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -28,7 +28,9 @@ with Atree;    use Atree;\n with Casing;   use Casing;\n with Checks;   use Checks;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n@@ -57,6 +59,7 @@ with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n@@ -9183,7 +9186,7 @@ package body Exp_Util is\n \n       --  True if object reference with volatile type\n \n-      elsif Is_Volatile_Object (N) then\n+      elsif Is_Volatile_Object_Ref (N) then\n          return True;\n \n       --  True if reference to volatile entity\n@@ -12203,15 +12206,28 @@ package body Exp_Util is\n                if Nkind (Context) in N_Subprogram_Call\n                  and then No (Type_Map.Get (Entity (Name (Context))))\n                then\n-                  New_Ref :=\n-                    Convert_To (Type_Of_Formal (Context, Old_Ref), New_Ref);\n-\n-                  --  Do not process the generated type conversion because\n-                  --  both the parent type and the derived type are in the\n-                  --  Type_Map table. This will clobber the type conversion\n-                  --  by resetting its subtype mark.\n-\n-                  Result := Skip;\n+                  declare\n+                     --  We need to use the Original_Node of the callee, in\n+                     --  case it was already modified. Note that we are using\n+                     --  Traverse_Proc to walk the tree, and it is defined to\n+                     --  walk subtrees in an arbitrary order.\n+\n+                     Callee : constant Entity_Id :=\n+                       Entity (Original_Node (Name (Context)));\n+                  begin\n+                     if No (Type_Map.Get (Callee)) then\n+                        New_Ref :=\n+                          Convert_To\n+                            (Type_Of_Formal (Context, Old_Ref), New_Ref);\n+\n+                        --  Do not process the generated type conversion\n+                        --  because both the parent type and the derived type\n+                        --  are in the Type_Map table. This will clobber the\n+                        --  type conversion by resetting its subtype mark.\n+\n+                        Result := Skip;\n+                     end if;\n+                  end;\n                end if;\n \n             --  Otherwise there is nothing to replace"}, {"sha": "e114e07bb7d47f566415b7e533d07e6f65a4c328", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -28,7 +28,8 @@\n with Exp_Tss; use Exp_Tss;\n with Namet;   use Namet;\n with Rtsfind; use Rtsfind;\n-with Sinfo;   use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Types;   use Types;\n with Uintp;   use Uintp;\n "}, {"sha": "5ae85ea420ab31c2889417c3985f0df1b4250e50", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -47,7 +47,8 @@ with Rtsfind;   use Rtsfind;\n with Sem;       use Sem;\n with Sem_Ch8;   use Sem_Ch8;\n with Sem_Util;  use Sem_Util;\n-with Sinfo;     use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Table;\n \n package body Expander is"}, {"sha": "9c4a5723f52b3405d58e0ee8562666b5d76ec885", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 391, "deletions": 13, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -69,14 +69,14 @@ extern Boolean Debug_Flag_NN;\n \n /* einfo: */\n \n-#define Set_Alignment\t\t\teinfo__set_alignment\n-#define Set_Component_Bit_Offset\teinfo__set_component_bit_offset\n-#define Set_Component_Size\t\teinfo__set_component_size\n-#define Set_Esize\t\t\teinfo__set_esize\n-#define Set_Mechanism\t\t\teinfo__set_mechanism\n-#define Set_Normalized_First_Bit\teinfo__set_normalized_first_bit\n-#define Set_Normalized_Position\t\teinfo__set_normalized_position\n-#define Set_RM_Size\t\t\teinfo__set_rm_size\n+#define Set_Alignment\t\t\teinfo__entities__set_alignment\n+#define Set_Component_Bit_Offset\teinfo__entities__set_component_bit_offset\n+#define Set_Component_Size\t\teinfo__entities__set_component_size\n+#define Set_Esize\t\t\teinfo__entities__set_esize\n+#define Set_Mechanism\t\t\teinfo__entities__set_mechanism\n+#define Set_Normalized_First_Bit\teinfo__entities__set_normalized_first_bit\n+#define Set_Normalized_Position\t\teinfo__entities__set_normalized_position\n+#define Set_RM_Size\t\t\teinfo__entities__set_rm_size\n \n extern void Set_Alignment\t\t(Entity_Id, Uint);\n extern void Set_Component_Bit_Offset\t(Entity_Id, Uint);\n@@ -87,11 +87,11 @@ extern void Set_Normalized_First_Bit\t(Entity_Id, Uint);\n extern void Set_Normalized_Position\t(Entity_Id, Uint);\n extern void Set_RM_Size\t\t\t(Entity_Id, Uint);\n \n-#define Is_Entity_Name\t\teinfo__is_entity_name\n+#define Is_Entity_Name\t\teinfo__utils__is_entity_name\n \n extern Boolean Is_Entity_Name\t\t(Node_Id);\n \n-#define Get_Attribute_Definition_Clause\teinfo__get_attribute_definition_clause\n+#define Get_Attribute_Definition_Clause\teinfo__utils__get_attribute_definition_clause\n \n extern Node_Id Get_Attribute_Definition_Clause (Entity_Id, unsigned char);\n \n@@ -301,9 +301,9 @@ extern Boolean Requires_Transient_Scope\t(Entity_Id);\n \n /* sinfo: */\n \n-#define End_Location\t\t\tsinfo__end_location\n-#define Set_Has_No_Elaboration_Code\tsinfo__set_has_no_elaboration_code\n-#define Set_Present_Expr\t\tsinfo__set_present_expr\n+#define End_Location\t\t\tsinfo__utils__end_location\n+#define Set_Has_No_Elaboration_Code\tsinfo__nodes__set_has_no_elaboration_code\n+#define Set_Present_Expr\t\tsinfo__nodes__set_present_expr\n \n extern Source_Ptr End_Location \t\t(Node_Id);\n extern void Set_Has_No_Elaboration_Code\t(Node_Id, Boolean);\n@@ -343,6 +343,384 @@ extern Boolean Stack_Check_Probes_On_Target;\n \n extern Boolean Warn_On_Questionable_Layout;\n \n+// The following corresponds to Ada code in Einfo.Utils.\n+\n+typedef Boolean B;\n+typedef Component_Alignment_Kind C;\n+typedef Entity_Id E;\n+typedef Mechanism_Type M;\n+typedef Node_Id N;\n+typedef Uint U;\n+typedef Ureal R;\n+typedef Elist_Id L;\n+typedef List_Id S;\n+\n+#define Is_Access_Object_Type einfo__utils__is_access_object_type\n+B Is_Access_Object_Type               (E Id);\n+\n+#define Is_Named_Access_Type einfo__utils__is_named_access_type\n+B Is_Named_Access_Type                (E Id);\n+\n+#define Address_Clause einfo__utils__address_clause\n+N Address_Clause                      (E Id);\n+\n+#define Aft_Value einfo__utils__aft_value\n+U Aft_Value                           (E Id);\n+\n+#define Alignment_Clause einfo__utils__alignment_clause\n+N Alignment_Clause                    (E Id);\n+\n+#define Base_Type einfo__utils__base_type\n+E Base_Type                           (E Id);\n+\n+#define Declaration_Node einfo__utils__declaration_node\n+N Declaration_Node                    (E Id);\n+\n+#define Designated_Type einfo__utils__designated_type\n+E Designated_Type                     (E Id);\n+\n+#define First_Component einfo__utils__first_component\n+E First_Component                     (E Id);\n+\n+#define First_Component_Or_Discriminant einfo__utils__first_component_or_discriminant\n+E First_Component_Or_Discriminant     (E Id);\n+\n+#define First_Formal einfo__utils__first_formal\n+E First_Formal                        (E Id);\n+\n+#define First_Formal_With_Extras einfo__utils__first_formal_with_extras\n+E First_Formal_With_Extras            (E Id);\n+\n+#define Has_Attach_Handler einfo__utils__has_attach_handler\n+B Has_Attach_Handler                  (E Id);\n+\n+#define Has_Entries einfo__utils__has_entries\n+B Has_Entries                         (E Id);\n+\n+#define Has_Foreign_Convention einfo__utils__has_foreign_convention\n+B Has_Foreign_Convention              (E Id);\n+\n+#define Has_Interrupt_Handler einfo__utils__has_interrupt_handler\n+B Has_Interrupt_Handler               (E Id);\n+\n+#define Has_Non_Limited_View einfo__utils__has_non_limited_view\n+B Has_Non_Limited_View                (E Id);\n+\n+#define Has_Non_Null_Abstract_State einfo__utils__has_non_null_abstract_state\n+B Has_Non_Null_Abstract_State         (E Id);\n+\n+#define Has_Non_Null_Visible_Refinement einfo__utils__has_non_null_visible_refinement\n+B Has_Non_Null_Visible_Refinement     (E Id);\n+\n+#define Has_Null_Abstract_State einfo__utils__has_null_abstract_state\n+B Has_Null_Abstract_State             (E Id);\n+\n+#define Has_Null_Visible_Refinement einfo__utils__has_null_visible_refinement\n+B Has_Null_Visible_Refinement         (E Id);\n+\n+#define Implementation_Base_Type einfo__utils__implementation_base_type\n+E Implementation_Base_Type            (E Id);\n+\n+#define Is_Base_Type einfo__utils__is_base_type\n+B Is_Base_Type                        (E Id);\n+\n+#define Is_Boolean_Type einfo__utils__is_boolean_type\n+B Is_Boolean_Type                     (E Id);\n+\n+#define Is_Constant_Object einfo__utils__is_constant_object\n+B Is_Constant_Object                  (E Id);\n+\n+#define Is_Controlled einfo__utils__is_controlled\n+B Is_Controlled                       (E Id);\n+\n+#define Is_Discriminal einfo__utils__is_discriminal\n+B Is_Discriminal                      (E Id);\n+\n+#define Is_Dynamic_Scope einfo__utils__is_dynamic_scope\n+B Is_Dynamic_Scope                    (E Id);\n+\n+#define Is_Elaboration_Target einfo__utils__is_elaboration_target\n+B Is_Elaboration_Target               (E Id);\n+\n+#define Is_External_State einfo__utils__is_external_state\n+B Is_External_State                   (E Id);\n+\n+#define Is_Finalizer einfo__utils__is_finalizer\n+B Is_Finalizer                        (E Id);\n+\n+#define Is_Null_State einfo__utils__is_null_state\n+B Is_Null_State                       (E Id);\n+\n+#define Is_Package_Or_Generic_Package einfo__utils__is_package_or_generic_package\n+B Is_Package_Or_Generic_Package       (E Id);\n+\n+#define Is_Packed_Array einfo__utils__is_packed_array\n+B Is_Packed_Array                     (E Id);\n+\n+#define Is_Prival einfo__utils__is_prival\n+B Is_Prival                           (E Id);\n+\n+#define Is_Protected_Component einfo__utils__is_protected_component\n+B Is_Protected_Component              (E Id);\n+\n+#define Is_Protected_Interface einfo__utils__is_protected_interface\n+B Is_Protected_Interface              (E Id);\n+\n+#define Is_Protected_Record_Type einfo__utils__is_protected_record_type\n+B Is_Protected_Record_Type            (E Id);\n+\n+#define Is_Relaxed_Initialization_State einfo__utils__is_relaxed_initialization_state\n+B Is_Relaxed_Initialization_State     (E Id);\n+\n+#define Is_Standard_Character_Type einfo__utils__is_standard_character_type\n+B Is_Standard_Character_Type          (E Id);\n+\n+#define Is_Standard_String_Type einfo__utils__is_standard_string_type\n+B Is_Standard_String_Type             (E Id);\n+\n+#define Is_String_Type einfo__utils__is_string_type\n+B Is_String_Type                      (E Id);\n+\n+#define Is_Synchronized_Interface einfo__utils__is_synchronized_interface\n+B Is_Synchronized_Interface           (E Id);\n+\n+#define Is_Synchronized_State einfo__utils__is_synchronized_state\n+B Is_Synchronized_State               (E Id);\n+\n+#define Is_Task_Interface einfo__utils__is_task_interface\n+B Is_Task_Interface                   (E Id);\n+\n+#define Is_Task_Record_Type einfo__utils__is_task_record_type\n+B Is_Task_Record_Type                 (E Id);\n+\n+#define Is_Wrapper_Package einfo__utils__is_wrapper_package\n+B Is_Wrapper_Package                  (E Id);\n+\n+#define Last_Formal einfo__utils__last_formal\n+E Last_Formal                         (E Id);\n+\n+#define Machine_Emax_Value einfo__utils__machine_emax_value\n+U Machine_Emax_Value                  (E Id);\n+\n+#define Machine_Emin_Value einfo__utils__machine_emin_value\n+U Machine_Emin_Value                  (E Id);\n+\n+#define Machine_Mantissa_Value einfo__utils__machine_mantissa_value\n+U Machine_Mantissa_Value              (E Id);\n+\n+#define Machine_Radix_Value einfo__utils__machine_radix_value\n+U Machine_Radix_Value                 (E Id);\n+\n+#define Model_Emin_Value einfo__utils__model_emin_value\n+U Model_Emin_Value                    (E Id);\n+\n+#define Model_Epsilon_Value einfo__utils__model_epsilon_value\n+R Model_Epsilon_Value                 (E Id);\n+\n+#define Model_Mantissa_Value einfo__utils__model_mantissa_value\n+U Model_Mantissa_Value                (E Id);\n+\n+#define Model_Small_Value einfo__utils__model_small_value\n+R Model_Small_Value                   (E Id);\n+\n+#define Next_Component einfo__utils__next_component\n+E Next_Component                      (E Id);\n+\n+#define Next_Component_Or_Discriminant einfo__utils__next_component_or_discriminant\n+E Next_Component_Or_Discriminant      (E Id);\n+\n+#define Next_Discriminant einfo__utils__next_discriminant\n+E Next_Discriminant                   (E Id);\n+\n+#define Next_Formal einfo__utils__next_formal\n+E Next_Formal                         (E Id);\n+\n+#define Next_Formal_With_Extras einfo__utils__next_formal_with_extras\n+E Next_Formal_With_Extras             (E Id);\n+\n+#define Number_Dimensions einfo__utils__number_dimensions\n+Pos Number_Dimensions                   (E Id);\n+\n+#define Number_Entries einfo__utils__number_entries\n+Nat Number_Entries                      (E Id);\n+\n+#define Number_Formals einfo__utils__number_formals\n+Pos Number_Formals                      (E Id);\n+\n+#define Object_Size_Clause einfo__utils__object_size_clause\n+N Object_Size_Clause                  (E Id);\n+\n+#define Partial_Refinement_Constituents einfo__utils__partial_refinement_constituents\n+L Partial_Refinement_Constituents     (E Id);\n+\n+#define Primitive_Operations einfo__utils__primitive_operations\n+L Primitive_Operations                (E Id);\n+\n+#define Root_Type einfo__utils__root_type\n+E Root_Type                           (E Id);\n+\n+#define Safe_Emax_Value einfo__utils__safe_emax_value\n+U Safe_Emax_Value                     (E Id);\n+\n+#define Safe_First_Value einfo__utils__safe_first_value\n+R Safe_First_Value                    (E Id);\n+\n+#define Safe_Last_Value einfo__utils__safe_last_value\n+R Safe_Last_Value                     (E Id);\n+\n+#define Scope_Depth einfo__utils__scope_depth\n+U Scope_Depth                         (E Id);\n+\n+#define Scope_Depth_Set einfo__utils__scope_depth_set\n+B Scope_Depth_Set                     (E Id);\n+\n+#define Size_Clause einfo__utils__size_clause\n+N Size_Clause                         (E Id);\n+\n+#define Stream_Size_Clause einfo__utils__stream_size_clause\n+N Stream_Size_Clause                  (E Id);\n+\n+#define Type_High_Bound einfo__utils__type_high_bound\n+N Type_High_Bound                     (E Id);\n+\n+#define Type_Low_Bound einfo__utils__type_low_bound\n+N Type_Low_Bound                      (E Id);\n+\n+#define Underlying_Type einfo__utils__underlying_type\n+E Underlying_Type                     (E Id);\n+\n+#define Known_Alignment einfo__utils__known_alignment\n+B Known_Alignment                       (Entity_Id E);\n+\n+#define Known_Component_Bit_Offset einfo__utils__known_component_bit_offset\n+B Known_Component_Bit_Offset            (Entity_Id E);\n+\n+#define Known_Component_Size einfo__utils__known_component_size\n+B Known_Component_Size                  (Entity_Id E);\n+\n+#define Known_Esize einfo__utils__known_esize\n+B Known_Esize                           (Entity_Id E);\n+\n+#define Known_Normalized_First_Bit einfo__utils__known_normalized_first_bit\n+B Known_Normalized_First_Bit            (Entity_Id E);\n+\n+#define Known_Normalized_Position einfo__utils__known_normalized_position\n+B Known_Normalized_Position             (Entity_Id E);\n+\n+#define Known_Normalized_Position_Max einfo__utils__known_normalized_position_max\n+B Known_Normalized_Position_Max         (Entity_Id E);\n+\n+#define Known_RM_Size einfo__utils__known_rm_size\n+B Known_RM_Size                         (Entity_Id E);\n+\n+#define Known_Static_Component_Bit_Offset einfo__utils__known_static_component_bit_offset\n+B Known_Static_Component_Bit_Offset     (Entity_Id E);\n+\n+#define Known_Static_Component_Size einfo__utils__known_static_component_size\n+B Known_Static_Component_Size           (Entity_Id E);\n+\n+#define Known_Static_Esize einfo__utils__known_static_esize\n+B Known_Static_Esize                    (Entity_Id E);\n+\n+#define Known_Static_Normalized_First_Bit einfo__utils__known_static_normalized_first_bit\n+B Known_Static_Normalized_First_Bit     (Entity_Id E);\n+\n+#define Known_Static_Normalized_Position einfo__utils__known_static_normalized_position\n+B Known_Static_Normalized_Position      (Entity_Id E);\n+\n+#define Known_Static_Normalized_Position_Max einfo__utils__known_static_normalized_position_max\n+B Known_Static_Normalized_Position_Max  (Entity_Id E);\n+\n+#define Known_Static_RM_Size einfo__utils__known_static_rm_size\n+B Known_Static_RM_Size                  (Entity_Id E);\n+\n+#define Unknown_Alignment einfo__utils__unknown_alignment\n+B Unknown_Alignment                     (Entity_Id E);\n+\n+#define Unknown_Component_Bit_Offset einfo__utils__unknown_component_bit_offset\n+B Unknown_Component_Bit_Offset          (Entity_Id E);\n+\n+#define Unknown_Component_Size einfo__utils__unknown_component_size\n+B Unknown_Component_Size                (Entity_Id E);\n+\n+#define Unknown_Esize einfo__utils__unknown_esize\n+B Unknown_Esize                         (Entity_Id E);\n+\n+#define Unknown_Normalized_First_Bit einfo__utils__unknown_normalized_first_bit\n+B Unknown_Normalized_First_Bit          (Entity_Id E);\n+\n+#define Unknown_Normalized_Position einfo__utils__unknown_normalized_position\n+B Unknown_Normalized_Position           (Entity_Id E);\n+\n+#define Unknown_Normalized_Position_Max einfo__utils__unknown_normalized_position_max\n+B Unknown_Normalized_Position_Max       (Entity_Id E);\n+\n+#define Unknown_RM_Size einfo__utils__unknown_rm_size\n+B Unknown_RM_Size                       (Entity_Id E);\n+\n+// The following were automatically generated as INLINE functions in the old\n+// einfo.h by the spitbol program.\n+// Is it important that they be inlined????\n+\n+#define Is_Discrete_Or_Fixed_Point_Type einfo__utils__is_discrete_or_fixed_point_type\n+B Is_Discrete_Or_Fixed_Point_Type     (E Id);\n+\n+#define Is_Floating_Point_Type einfo__utils__is_floating_point_type\n+B Is_Floating_Point_Type                      (E Id);\n+\n+#define Is_Record_Type einfo__utils__is_record_type\n+B Is_Record_Type                      (E Id);\n+\n+#define Has_DIC einfo__utils__has_dic\n+B Has_DIC (E Id);\n+\n+#define Has_Invariants einfo__utils__has_invariants\n+B Has_Invariants (E Id);\n+\n+#define Is_Full_Access einfo__utils__is_full_access\n+B Is_Full_Access (E Id);\n+\n+#define Next_Index einfo__utils__next_index\n+Node_Id Next_Index (Node_Id Id);\n+\n+#define Next_Literal einfo__utils__next_literal\n+E Next_Literal (E Id);\n+\n+#define Next_Stored_Discriminant einfo__utils__next_stored_discriminant\n+E Next_Stored_Discriminant (E Id);\n+\n+#define Parameter_Mode einfo__utils__parameter_mode\n+// Parameter_Mode really returns Formal_Kind, but that is not visible, because\n+// fe.h is included before einfo.h.\n+Entity_Kind Parameter_Mode (E Id);\n+\n+#define Is_List_Member einfo__utils__is_list_member\n+B Is_List_Member (N Node);\n+\n+#define List_Containing einfo__utils__list_containing\n+S List_Containing (N Node);\n+\n+// The following is needed because Convention in Sem_Util is a renaming\n+// of Basic_Convention.\n+\n+#define Convention einfo__entities__basic_convention\n+Convention_Id Convention (N Node);\n+\n+// See comments regarding Entity_Or_Associated_Node in Sinfo.Utils.\n+\n+#define Entity sinfo__nodes__entity_or_associated_node\n+Entity_Id Entity (N Node);\n+\n+// See comments regarding Renamed_Or_Alias in Einfo.Utils\n+\n+#define Alias einfo__entities__renamed_or_alias\n+\n+#define Renamed_Entity einfo__entities__renamed_or_alias\n+Node_Id Renamed_Entity (N Node);\n+\n+#define Renamed_Object einfo__entities__renamed_or_alias\n+Node_Id Renamed_Object (N Node);\n+\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "0b807758cc92f93f0ae21b720b1c31c01362e2be", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -28,7 +28,9 @@ with Atree;     use Atree;\n with Checks;    use Checks;\n with Contracts; use Contracts;\n with Debug;     use Debug;\n-with Einfo;     use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;    use Elists;\n with Errout;    use Errout;\n with Exp_Ch3;   use Exp_Ch3;\n@@ -59,7 +61,9 @@ with Sem_Mech;  use Sem_Mech;\n with Sem_Prag;  use Sem_Prag;\n with Sem_Res;   use Sem_Res;\n with Sem_Util;  use Sem_Util;\n-with Sinfo;     use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;    use Snames;\n with Stand;     use Stand;\n with Stringt;   use Stringt;\n@@ -7545,7 +7549,7 @@ package body Freeze is\n \n       Typ := Empty;\n \n-      if Nkind (N) in N_Has_Etype then\n+      if Nkind (N) in N_Has_Etype and then Present (Etype (N)) then\n          if not Is_Frozen (Etype (N)) then\n             Typ := Etype (N);\n \n@@ -7566,6 +7570,7 @@ package body Freeze is\n       --  an initialization procedure from freezing the variable.\n \n       if Is_Entity_Name (N)\n+        and then Present (Entity (N))\n         and then not Is_Frozen (Entity (N))\n         and then (Nkind (N) /= N_Identifier\n                    or else Comes_From_Source (N)"}, {"sha": "8d4636d3086823f8315fccf45a6314e7c7575efb", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -60,7 +60,9 @@ with Sem_SCIL;\n with Sem_Elab; use Sem_Elab;\n with Sem_Prag; use Sem_Prag;\n with Sem_Warn;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Sinput.L; use Sinput.L;\n with SCIL_LL;"}, {"sha": "969022e21a7457bf338c0a5f17ee9b54b49b1f22", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -272,6 +272,8 @@ GNAT_ADA_OBJS =\t\\\n  ada/cstand.o\t\\\n  ada/debug.o\t\\\n  ada/debug_a.o\t\\\n+ ada/einfo-entities.o \\\n+ ada/einfo-utils.o \\\n  ada/einfo.o\t\\\n  ada/elists.o\t\\\n  ada/err_vars.o\t\\\n@@ -424,6 +426,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/scng.o\t\\\n  ada/scos.o\t\\\n  ada/sdefault.o\t\\\n+ ada/seinfo.o \\\n  ada/sem.o\t\\\n  ada/sem_aggr.o\t\\\n  ada/sem_attr.o\t\\\n@@ -459,6 +462,8 @@ GNAT_ADA_OBJS =\t\\\n  ada/sem_warn.o\t\\\n  ada/set_targ.o \\\n  ada/sinfo-cn.o\t\\\n+ ada/sinfo-nodes.o \\\n+ ada/sinfo-utils.o \\\n  ada/sinfo.o\t\\\n  ada/sinput-d.o\t\\\n  ada/sinput-l.o\t\\\n@@ -478,7 +483,6 @@ GNAT_ADA_OBJS =\t\\\n  ada/targparm.o\t\\\n  ada/tbuild.o\t\\\n  ada/treepr.o\t\\\n- ada/treeprs.o\t\\\n  ada/ttypes.o\t\\\n  ada/types.o\t\\\n  ada/uintp.o\t\\\n@@ -526,6 +530,8 @@ GNATBIND_OBJS = \\\n  ada/csets.o      \\\n  ada/cstreams.o   \\\n  ada/debug.o      \\\n+ ada/einfo-entities.o \\\n+ ada/einfo-utils.o \\\n  ada/einfo.o      \\\n  ada/elists.o     \\\n  ada/env.o        \\\n@@ -618,7 +624,10 @@ GNATBIND_OBJS = \\\n  ada/scng.o       \\\n  ada/sdefault.o   \\\n  ada/seh_init.o   \\\n+ ada/seinfo.o \\\n  ada/sem_aux.o    \\\n+ ada/sinfo-nodes.o \\\n+ ada/sinfo-utils.o \\\n  ada/sinfo.o      \\\n  ada/sinput-c.o   \\\n  ada/sinput.o     \\\n@@ -879,7 +888,7 @@ ada.mostlyclean:\n \t-$(RM) ada/*$(objext) ada/*.ali ada/b_gnat*.ads ada/b_gnat*.adb\n \t-$(RM) ada/*$(objext).gnatd.n\n \t-$(RM) ada/*$(coverageexts)\n-\t-$(RM) ada/sdefault.adb ada/stamp-sdefault ada/stamp-snames\n+\t-$(RM) ada/stamp-sdefault ada/stamp-snames ada/stamp-gen_il\n \t-$(RMDIR) ada/tools\n \t-$(RMDIR) ada/libgnat\n \t-$(RM) gnatbind$(exeext) gnat1$(exeext)\n@@ -907,7 +916,6 @@ ada.maintainer-clean:\n \t-$(RM) ada/einfo.h\n \t-$(RM) ada/nmake.adb\n \t-$(RM) ada/nmake.ads\n-\t-$(RM) ada/treeprs.ads\n \t-$(RM) ada/snames.ads ada/snames.adb ada/snames.h\n \n # Stage hooks:\n@@ -1033,11 +1041,6 @@ ada/b_gnatb.o : ada/b_gnatb.adb\n \n include $(srcdir)/ada/Make-generated.in\n \n-update-sources : ada/treeprs.ads ada/einfo.h ada/sinfo.h ada/nmake.adb \\\n-\tada/nmake.ads\n-\t$(RM) $(addprefix $(srcdir)/ada/,$(notdir $^))\n-\t$(CP) $^ $(srcdir)/ada\n-\n ada/sdefault.o : ada/libgnat/ada.ads ada/libgnat/a-except.ads ada/libgnat/a-unccon.ads \\\n    ada/libgnat/a-uncdea.ads ada/alloc.ads ada/debug.ads ada/hostparm.ads ada/namet.ads \\\n    ada/opt.ads ada/osint.ads ada/output.ads ada/sdefault.ads ada/sdefault.adb \\\n@@ -1099,13 +1102,23 @@ ada/mdll-fil.o : ada/mdll-fil.adb ada/mdll.ads ada/mdll-fil.ads\n ada/mdll-utl.o : ada/mdll-utl.adb ada/mdll.ads ada/mdll-utl.ads ada/sdefault.ads ada/types.ads\n \t$(CC) -c $(ALL_ADAFLAGS) $(ADA_INCLUDES) $< $(ADA_OUTPUT_OPTION)\n \n-ada_generated_files = ada/sinfo.h ada/einfo.h ada/nmake.adb ada/nmake.ads \\\n-\t\t      ada/treeprs.ads ada/snames.ads ada/snames.adb ada/snames.h \\\n-\t\t      ada/generated/gnatvsn.ads\n+# All generated files.  Perhaps we should build all of these in the same\n+# subdirectory, and get rid of ada/bldtools.\n+ADA_GENERATED_FILES = ada/sinfo.h ada/einfo.h ada/nmake.adb ada/nmake.ads \\\n+\t\t      ada/snames.ads ada/snames.adb ada/snames.h \\\n+\t\t      ada/generated/gnatvsn.ads \\\n+\t\t      ada/seinfo.ads \\\n+\t\t      ada/seinfo_tables.ads ada/seinfo_tables.adb \\\n+\t\t      ada/sinfo-nodes.ads ada/sinfo-nodes.adb \\\n+\t\t      ada/einfo-entities.ads ada/einfo-entities.adb\n+\n+# Only used to manually trigger the creation of the generated files.\n+.PHONY:\n+ada_generated_files: $(ADA_GENERATED_FILES)\n \n # When building from scratch we don't have dependency files, the only thing\n # we need to ensure is that the generated files are created first.\n-$(GNAT1_OBJS) $(GNATBIND_OBJS): | $(ada_generated_files)\n+$(GNAT1_OBJS) $(GNATBIND_OBJS): | $(ADA_GENERATED_FILES)\n \n # Manually include the auto-generated dependencies for the Ada host objects.\n ADA_DEPFILES = $(foreach obj,$(GNAT1_ADA_OBJS) $(GNATBIND_OBJS),\\"}, {"sha": "333e2035455d1d2e7b7a84aa7e068c181e43d99c", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -104,7 +104,7 @@ TEXI2DVI = texi2dvi\n TEXI2PDF = texi2pdf\n GNATBIND_FLAGS = -static -x\n ADA_CFLAGS =\n-ADAFLAGS = -W -Wall -gnatpg -gnata\n+ADAFLAGS = -W -Wall -gnatpg -gnata -gnatU\n FORCE_DEBUG_ADAFLAGS = -g\n NO_INLINE_ADAFLAGS = -fno-inline\n NO_OMIT_ADAFLAGS = -fno-omit-frame-pointer\n@@ -332,6 +332,7 @@ GNATMAKE_OBJS = a-except.o ali.o ali-util.o aspects.o s-casuti.o alloc.o \\\n  snames.o stand.o stringt.o styleg.o stylesw.o system.o validsw.o \\\n  switch.o switch-m.o table.o targparm.o tempdir.o types.o uintp.o \\\n  uname.o urealp.o usage.o widechar.o \\\n+ seinfo.o einfo-entities.o einfo-utils.o sinfo-nodes.o sinfo-utils.o \\\n  $(EXTRA_GNATMAKE_OBJS)\n \n # Make arch match the current multilib so that the RTS selection code\n@@ -383,15 +384,20 @@ TOOLS_FLAGS_TO_PASS=\t\t\\\n \n GCC_LINK=$(CXX) $(GCC_LINK_FLAGS) $(LDFLAGS)\n \n-# Build directory for the tools. Let's copy the target-dependent\n-# sources using the same mechanism as for gnatlib. The other sources are\n-# accessed using the vpath directive below\n+# Build directory for the tools. We first need to copy the generated files,\n+# then the target-dependent sources using the same mechanism as for gnatlib.\n+# The other sources are accessed using the vpath directive below\n+\n+GENERATED_FILES_FOR_TOOLS = \\\n+  einfo-entities.ads einfo-entities.adb sdefault.adb seinfo.ads \\\n+  sinfo-nodes.ads sinfo-nodes.adb snames.ads snames.adb\n \n ../stamp-tools:\n \t-$(RM) tools/*\n \t-$(RMDIR) tools\n \t-$(MKDIR) tools\n-\t-(cd tools; $(LN_S) ../sdefault.adb ../snames.ads ../snames.adb .)\n+\t-(cd tools; $(foreach FILE,$(GENERATED_FILES_FOR_TOOLS), \\\n+\t\t\t     $(LN_S) ../$(FILE) $(FILE);))\n \t-$(foreach PAIR,$(TOOLS_TARGET_PAIRS), \\\n \t          $(RM) tools/$(word 1,$(subst <, ,$(PAIR)));\\\n \t          $(LN_S) $(fsrcpfx)ada/$(word 2,$(subst <, ,$(PAIR))) \\"}, {"sha": "b4c4653052ca9df2bb92d000d7089ad1768e6967", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -434,7 +434,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n   gcc_assert (!is_type\n \t      || Known_Esize (gnat_entity)\n \t      || Has_Size_Clause (gnat_entity)\n-\t      || (!IN (kind, Numeric_Kind)\n+\t      || (!Is_In_Numeric_Kind (kind)\n \t\t  && !IN (kind, Enumeration_Kind)\n \t\t  && (!IN (kind, Access_Kind)\n \t\t      || kind == E_Access_Protected_Subprogram_Type\n@@ -443,7 +443,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t      || type_annotate_only)));\n \n   /* The RM size must be specified for all discrete and fixed-point types.  */\n-  gcc_assert (!(IN (kind, Discrete_Or_Fixed_Point_Kind)\n+  gcc_assert (!(Is_In_Discrete_Or_Fixed_Point_Kind (kind)\n \t\t&& Unknown_RM_Size (gnat_entity)));\n \n   /* If we get here, it means we have not yet done anything with this entity.\n@@ -4568,7 +4568,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       /* Similarly, if this is a record type or subtype at global level, call\n \t elaborate_expression_2 on any field position.  Skip any fields that\n \t we haven't made trees for to avoid problems with class-wide types.  */\n-      if (IN (kind, Record_Kind) && global_bindings_p ())\n+      if (Is_In_Record_Kind (kind) && global_bindings_p ())\n \tfor (gnat_temp = First_Entity (gnat_entity); Present (gnat_temp);\n \t     gnat_temp = Next_Entity (gnat_temp))\n \t  if (Ekind (gnat_temp) == E_Component && present_gnu_tree (gnat_temp))\n@@ -7675,7 +7675,7 @@ typedef struct vinfo\n    will be the single field of GNU_RECORD_TYPE and the GCC nodes for the\n    discriminants will be on GNU_FIELD_LIST.  The other call to this function\n    is a recursive call for the component list of a variant and, in this case,\n-   GNU_FIELD_LIST is empty.\n+   GNU_FIELD_LIST is empty.  Note that GNAT_COMPONENT_LIST may be Empty.\n \n    PACKED is 1 if this is for a packed record or -1 if this is for a record\n    with Component_Alignment of Storage_Unit.\n@@ -7731,7 +7731,8 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n   /* For each component referenced in a component declaration create a GCC\n      field and add it to the list, skipping pragmas in the GNAT list.  */\n   gnu_last = tree_last (gnu_field_list);\n-  if (Present (Component_Items (gnat_component_list)))\n+  if (Present (gnat_component_list)\n+      && (Present (Component_Items (gnat_component_list))))\n     for (gnat_component_decl\n \t   = First_Non_Pragma (Component_Items (gnat_component_list));\n \t Present (gnat_component_decl);\n@@ -7788,7 +7789,10 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n       }\n \n   /* At the end of the component list there may be a variant part.  */\n-  gnat_variant_part = Variant_Part (gnat_component_list);\n+  if (Present (gnat_component_list))\n+    gnat_variant_part = Variant_Part (gnat_component_list);\n+  else\n+    gnat_variant_part = Empty;\n \n   /* We create a QUAL_UNION_TYPE for the variant part since the variants are\n      mutually exclusive and should go in the same memory.  To do this we need"}, {"sha": "7b754dad174e644c451f0e8ade24e54093486619", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -233,24 +233,24 @@ extern \"C\" {\n    structures and then generates code.  */\n extern void gigi (Node_Id gnat_root,\n \t          int max_gnat_node,\n-                  int number_name,\n-\t\t  struct Node *nodes_ptr,\n-\t\t  struct Flags *Flags_Ptr,\n+\t\t  int number_name,\n+\t\t  Field_Offset *node_offsets_ptr,\n+\t\t  slot *Slots,\n \t\t  Node_Id *next_node_ptr,\n \t\t  Node_Id *prev_node_ptr,\n \t\t  struct Elist_Header *elists_ptr,\n-                  struct Elmt_Item *elmts_ptr,\n-                  struct String_Entry *strings_ptr,\n-                  Char_Code *strings_chars_ptr,\n-                  struct List_Header *list_headers_ptr,\n-                  Nat number_file,\n-                  struct File_Info_Type *file_info_ptr,\n-                  Entity_Id standard_boolean,\n-                  Entity_Id standard_integer,\n-                  Entity_Id standard_character,\n-                  Entity_Id standard_long_long_float,\n-                  Entity_Id standard_exception_type,\n-                  Int gigi_operating_mode);\n+\t\t  struct Elmt_Item *elmts_ptr,\n+\t\t  struct String_Entry *strings_ptr,\n+\t\t  Char_Code *strings_chars_ptr,\n+\t\t  struct List_Header *list_headers_ptr,\n+\t\t  Nat number_file,\n+\t\t  struct File_Info_Type *file_info_ptr,\n+\t\t  Entity_Id standard_boolean,\n+\t\t  Entity_Id standard_integer,\n+\t\t  Entity_Id standard_character,\n+\t\t  Entity_Id standard_long_long_float,\n+\t\t  Entity_Id standard_exception_type,\n+\t\t  Int gigi_operating_mode);\n \n #ifdef __cplusplus\n }"}, {"sha": "61a9d6185a6291b877f4e59ff78e32409e6eeea5", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -75,8 +75,8 @@\n #define ALLOCA_THRESHOLD 1000\n \n /* Pointers to front-end tables accessed through macros.  */\n-struct Node *Nodes_Ptr;\n-struct Flags *Flags_Ptr;\n+Field_Offset *Node_Offsets_Ptr;\n+slot *Slots_Ptr;\n Node_Id *Next_Node_Ptr;\n Node_Id *Prev_Node_Ptr;\n struct Elist_Header *Elists_Ptr;\n@@ -279,8 +279,8 @@ void\n gigi (Node_Id gnat_root,\n       int max_gnat_node,\n       int number_name ATTRIBUTE_UNUSED,\n-      struct Node *nodes_ptr,\n-      struct Flags *flags_ptr,\n+      Field_Offset *node_offsets_ptr,\n+      slot *slots_ptr,\n       Node_Id *next_node_ptr,\n       Node_Id *prev_node_ptr,\n       struct Elist_Header *elists_ptr,\n@@ -305,8 +305,8 @@ gigi (Node_Id gnat_root,\n \n   max_gnat_nodes = max_gnat_node;\n \n-  Nodes_Ptr = nodes_ptr;\n-  Flags_Ptr = flags_ptr;\n+  Node_Offsets_Ptr = node_offsets_ptr;\n+  Slots_Ptr = slots_ptr;\n   Next_Node_Ptr = next_node_ptr;\n   Prev_Node_Ptr = prev_node_ptr;\n   Elists_Ptr = elists_ptr;"}, {"sha": "7948d2688a27f374ed2772f6cc08cfb854d5befd", "filename": "gcc/ada/gen_il-fields.ads", "status": "added", "additions": 923, "deletions": 0, "changes": 923, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,923 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         G E N _ I L . F I E L D S                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2020-2021, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Gen_IL.Fields is\n+\n+   --  The following is \"optional field enumeration\" -- i.e. it is Field_Enum\n+   --  (declared in Gen_IL.Utils) plus the special null value No_Field.\n+   --  See the spec of Gen_IL.Gen for how to modify this.\n+\n+   type Opt_Field_Enum is\n+     (No_Field,\n+\n+      --  Start of node fields:\n+\n+      Nkind,\n+      Sloc,\n+      In_List,\n+      Rewrite_Ins,\n+      Comes_From_Source,\n+      Analyzed,\n+      Error_Posted,\n+      Small_Paren_Count,\n+      Check_Actuals,\n+      Has_Aspects,\n+      Is_Ignored_Ghost_Node,\n+      Link,\n+\n+      Abort_Present,\n+      Abortable_Part,\n+      Abstract_Present,\n+      Accept_Handler_Records,\n+      Accept_Statement,\n+      Access_Definition,\n+      Access_To_Subprogram_Definition,\n+      Access_Types_To_Process,\n+      Actions,\n+      Activation_Chain_Entity,\n+      Acts_As_Spec,\n+      Actual_Designated_Subtype,\n+      Address_Warning_Posted,\n+      Aggregate_Bounds,\n+      Aliased_Present,\n+      Alloc_For_BIP_Return,\n+      All_Others,\n+      All_Present,\n+      Alternatives,\n+      Ancestor_Part,\n+      Atomic_Sync_Required,\n+      Array_Aggregate,\n+      Aspect_On_Partial_View,\n+      Aspect_Rep_Item,\n+      Assignment_OK,\n+      Attribute_Name,\n+      At_End_Proc,\n+      Aux_Decls_Node,\n+      Backwards_OK,\n+      Bad_Is_Detected,\n+      Body_Required,\n+      Body_To_Inline,\n+      Box_Present,\n+      By_Ref,\n+      Char_Literal_Value,\n+      Chars,\n+      Check_Address_Alignment,\n+      Choice_Parameter,\n+      Choices,\n+      Class_Present,\n+      Classifications,\n+      Cleanup_Actions,\n+      Comes_From_Extended_Return_Statement,\n+      Compile_Time_Known_Aggregate,\n+      Component_Associations,\n+      Component_Clauses,\n+      Component_Definition,\n+      Component_Items,\n+      Component_List,\n+      Component_Name,\n+      Componentwise_Assignment,\n+      Condition,\n+      Condition_Actions,\n+      Config_Pragmas,\n+      Constant_Present,\n+      Constraint,\n+      Constraints,\n+      Context_Installed,\n+      Context_Items,\n+      Context_Pending,\n+      Contract_Test_Cases,\n+      Controlling_Argument,\n+      Conversion_OK,\n+      Convert_To_Return_False,\n+      Corresponding_Aspect,\n+      Corresponding_Body,\n+      Corresponding_Formal_Spec,\n+      Corresponding_Generic_Association,\n+      Corresponding_Integer_Value,\n+      Corresponding_Spec,\n+      Corresponding_Spec_Of_Stub,\n+      Corresponding_Stub,\n+      Dcheck_Function,\n+      Declarations,\n+      Default_Expression,\n+      Default_Storage_Pool,\n+      Default_Name,\n+      Defining_Identifier,\n+      Defining_Unit_Name,\n+      Delay_Alternative,\n+      Delay_Statement,\n+      Delta_Expression,\n+      Digits_Expression,\n+      Discr_Check_Funcs_Built,\n+      Discrete_Choices,\n+      Discrete_Range,\n+      Discrete_Subtype_Definition,\n+      Discrete_Subtype_Definitions,\n+      Discriminant_Specifications,\n+      Discriminant_Type,\n+      Do_Accessibility_Check,\n+      Do_Discriminant_Check,\n+      Do_Division_Check,\n+      Do_Length_Check,\n+      Do_Overflow_Check,\n+      Do_Range_Check,\n+      Do_Storage_Check,\n+      Do_Tag_Check,\n+      Elaborate_All_Desirable,\n+      Elaborate_All_Present,\n+      Elaborate_Desirable,\n+      Elaborate_Present,\n+      Else_Actions,\n+      Else_Statements,\n+      Elsif_Parts,\n+      Enclosing_Variant,\n+      End_Label,\n+      End_Span,\n+      Entity_Or_Associated_Node,\n+      Entry_Body_Formal_Part,\n+      Entry_Call_Alternative,\n+      Entry_Call_Statement,\n+      Entry_Direct_Name,\n+      Entry_Index,\n+      Entry_Index_Specification,\n+      Etype,\n+      Exception_Choices,\n+      Exception_Handlers,\n+      Exception_Junk,\n+      Exception_Label,\n+      Expansion_Delayed,\n+      Explicit_Actual_Parameter,\n+      Explicit_Generic_Actual_Parameter,\n+      Expression,\n+      Expression_Copy,\n+      Expressions,\n+      First_Bit,\n+      First_Inlined_Subprogram,\n+      First_Name,\n+      First_Named_Actual,\n+      First_Real_Statement,\n+      First_Subtype_Link,\n+      Float_Truncate,\n+      Formal_Type_Definition,\n+      Forwards_OK,\n+      From_Aspect_Specification,\n+      From_At_End,\n+      From_At_Mod,\n+      From_Conditional_Expression,\n+      From_Default,\n+      Generalized_Indexing,\n+      Generic_Associations,\n+      Generic_Formal_Declarations,\n+      Generic_Parent,\n+      Generic_Parent_Type,\n+      Handled_Statement_Sequence,\n+      Handler_List_Entry,\n+      Has_Created_Identifier,\n+      Has_Dereference_Action,\n+      Has_Dynamic_Length_Check,\n+      Has_Init_Expression,\n+      Has_Local_Raise,\n+      Has_No_Elaboration_Code,\n+      Has_Pragma_Suppress_All,\n+      Has_Private_View,\n+      Has_Relative_Deadline_Pragma,\n+      Has_Self_Reference,\n+      Has_SP_Choice,\n+      Has_Storage_Size_Pragma,\n+      Has_Target_Names,\n+      Has_Wide_Character,\n+      Has_Wide_Wide_Character,\n+      Header_Size_Added,\n+      Hidden_By_Use_Clause,\n+      High_Bound,\n+      Identifier,\n+      Interface_List,\n+      Interface_Present,\n+      Implicit_With,\n+      Import_Interface_Present,\n+      In_Present,\n+      Includes_Infinities,\n+      Incomplete_View,\n+      Inherited_Discriminant,\n+      Instance_Spec,\n+      Intval,\n+      Is_Abort_Block,\n+      Is_Accessibility_Actual,\n+      Is_Analyzed_Pragma,\n+      Is_Asynchronous_Call_Block,\n+      Is_Boolean_Aspect,\n+      Is_Checked,\n+      Is_Checked_Ghost_Pragma,\n+      Is_Component_Left_Opnd,\n+      Is_Component_Right_Opnd,\n+      Is_Controlling_Actual,\n+      Is_Declaration_Level_Node,\n+      Is_Delayed_Aspect,\n+      Is_Disabled,\n+      Is_Dispatching_Call,\n+      Is_Dynamic_Coextension,\n+      Is_Effective_Use_Clause,\n+      Is_Elaboration_Checks_OK_Node,\n+      Is_Elaboration_Code,\n+      Is_Elaboration_Warnings_OK_Node,\n+      Is_Elsif,\n+      Is_Entry_Barrier_Function,\n+      Is_Expanded_Build_In_Place_Call,\n+      Is_Expanded_Contract,\n+      Is_Finalization_Wrapper,\n+      Is_Folded_In_Parser,\n+      Is_Generic_Contract_Pragma,\n+      Is_Homogeneous_Aggregate,\n+      Is_Ignored,\n+      Is_Ignored_Ghost_Pragma,\n+      Is_In_Discriminant_Check,\n+      Is_Inherited_Pragma,\n+      Is_Initialization_Block,\n+      Is_Known_Guaranteed_ABE,\n+      Is_Machine_Number,\n+      Is_Null_Loop,\n+      Is_Overloaded,\n+      Is_Power_Of_2_For_Shift,\n+      Is_Preelaborable_Call,\n+      Is_Prefixed_Call,\n+      Is_Protected_Subprogram_Body,\n+      Is_Qualified_Universal_Literal,\n+      Is_Read,\n+      Is_Source_Call,\n+      Is_SPARK_Mode_On_Node,\n+      Is_Static_Coextension,\n+      Is_Static_Expression,\n+      Is_Subprogram_Descriptor,\n+      Is_Task_Allocation_Block,\n+      Is_Task_Body_Procedure,\n+      Is_Task_Master,\n+      Is_Write,\n+      Iterator_Filter,\n+      Iteration_Scheme,\n+      Iterator_Specification,\n+      Itype,\n+      Key_Expression,\n+      Kill_Range_Check,\n+      Last_Bit,\n+      Last_Name,\n+      Library_Unit,\n+      Label_Construct,\n+      Left_Opnd,\n+      Limited_View_Installed,\n+      Limited_Present,\n+      Literals,\n+      Local_Raise_Not_OK,\n+      Local_Raise_Statements,\n+      Loop_Actions,\n+      Loop_Parameter_Specification,\n+      Low_Bound,\n+      Mod_Clause,\n+      More_Ids,\n+      Must_Be_Byte_Aligned,\n+      Must_Not_Freeze,\n+      Must_Not_Override,\n+      Must_Override,\n+      Name,\n+      Names,\n+      Next_Entity,\n+      Next_Exit_Statement,\n+      Next_Implicit_With,\n+      Next_Named_Actual,\n+      Next_Pragma,\n+      Next_Rep_Item,\n+      Next_Use_Clause,\n+      No_Ctrl_Actions,\n+      No_Elaboration_Check,\n+      No_Entities_Ref_In_Spec,\n+      No_Initialization,\n+      No_Minimize_Eliminate,\n+      No_Side_Effect_Removal,\n+      No_Truncation,\n+      Null_Excluding_Subtype,\n+      Null_Exclusion_Present,\n+      Null_Exclusion_In_Return_Present,\n+      Null_Present,\n+      Null_Record_Present,\n+      Null_Statement,\n+      Object_Definition,\n+      Of_Present,\n+      Original_Discriminant,\n+      Original_Entity,\n+      Others_Discrete_Choices,\n+      Out_Present,\n+      Parameter_Associations,\n+      Parameter_Specifications,\n+      Parameter_Type,\n+      Parent_Spec,\n+      Parent_With,\n+      Position,\n+      Pragma_Argument_Associations,\n+      Pragma_Identifier,\n+      Pragmas_After,\n+      Pragmas_Before,\n+      Pre_Post_Conditions,\n+      Prefix,\n+      Premature_Use,\n+      Present_Expr,\n+      Prev_Ids,\n+      Prev_Use_Clause,\n+      Print_In_Hex,\n+      Private_Declarations,\n+      Private_Present,\n+      Procedure_To_Call,\n+      Proper_Body,\n+      Protected_Definition,\n+      Protected_Present,\n+      Raises_Constraint_Error,\n+      Range_Constraint,\n+      Range_Expression,\n+      Real_Range_Specification,\n+      Realval,\n+      Reason,\n+      Record_Extension_Part,\n+      Redundant_Use,\n+      Renaming_Exception,\n+      Result_Definition,\n+      Return_Object_Declarations,\n+      Return_Statement_Entity,\n+      Reverse_Present,\n+      Right_Opnd,\n+      Rounded_Result,\n+      Save_Invocation_Graph_Of_Body,\n+      SCIL_Controlling_Tag,\n+      SCIL_Entity,\n+      SCIL_Tag_Value,\n+      SCIL_Target_Prim,\n+      Scope,\n+      Select_Alternatives,\n+      Selector_Name,\n+      Selector_Names,\n+      Shift_Count_OK,\n+      Source_Type,\n+      Specification,\n+      Split_PPC,\n+      Statements,\n+      Storage_Pool,\n+      Subpool_Handle_Name,\n+      Strval,\n+      Subtype_Indication,\n+      Subtype_Mark,\n+      Subtype_Marks,\n+      Suppress_Assignment_Checks,\n+      Suppress_Loop_Warnings,\n+      Synchronized_Present,\n+      Tagged_Present,\n+      Target,\n+      Target_Type,\n+      Task_Definition,\n+      Task_Present,\n+      Then_Actions,\n+      Then_Statements,\n+      Triggering_Alternative,\n+      Triggering_Statement,\n+      TSS_Elist,\n+      Type_Definition,\n+      Uneval_Old_Accept,\n+      Uneval_Old_Warn,\n+      Unit,\n+      Unknown_Discriminants_Present,\n+      Unreferenced_In_Spec,\n+      Variant_Part,\n+      Variants,\n+      Visible_Declarations,\n+      Uninitialized_Variable,\n+      Used_Operations,\n+      Was_Attribute_Reference,\n+      Was_Expression_Function,\n+      Was_Originally_Stub,\n+\n+      --  End of node fields.\n+\n+      Between_Node_And_Entity_Fields,\n+\n+      --  Start of entity fields:\n+\n+      Ekind,\n+      Basic_Convention,\n+      Abstract_States,\n+      Accept_Address,\n+      Access_Disp_Table,\n+      Access_Disp_Table_Elab_Flag,\n+      Access_Subprogram_Wrapper,\n+      Activation_Record_Component,\n+      Actual_Subtype,\n+      Address_Taken,\n+--  ??      Alias,\n+      Alignment,\n+      Anonymous_Designated_Type,\n+      Anonymous_Masters,\n+      Anonymous_Object,\n+      Associated_Entity,\n+      Associated_Formal_Package,\n+      Associated_Node_For_Itype,\n+      Associated_Storage_Pool,\n+      Barrier_Function,\n+      BIP_Initialization_Call,\n+      Block_Node,\n+      Body_Entity,\n+      Body_Needed_For_Inlining,\n+      Body_Needed_For_SAL,\n+      Body_References,\n+      C_Pass_By_Copy,\n+      Can_Never_Be_Null,\n+      Can_Use_Internal_Rep,\n+      Checks_May_Be_Suppressed,\n+      Class_Wide_Clone,\n+      Class_Wide_Type,\n+      Cloned_Subtype,\n+      Component_Alignment,\n+      Component_Bit_Offset,\n+      Component_Clause,\n+      Component_Size,\n+      Component_Type,\n+      Contract,\n+      Contract_Wrapper,\n+      Corresponding_Concurrent_Type,\n+      Corresponding_Discriminant,\n+      Corresponding_Equality,\n+      Corresponding_Function,\n+      Corresponding_Procedure,\n+      Corresponding_Protected_Entry,\n+      Corresponding_Record_Component,\n+      Corresponding_Record_Type,\n+      Corresponding_Remote_Type,\n+      CR_Discriminant,\n+      Current_Use_Clause,\n+      Current_Value,\n+      Debug_Info_Off,\n+      Debug_Renaming_Link,\n+      Default_Aspect_Component_Value,\n+      Default_Aspect_Value,\n+      Default_Expr_Function,\n+      Default_Expressions_Processed,\n+      Default_Value,\n+      Delay_Cleanups,\n+      Delay_Subprogram_Descriptors,\n+      Delta_Value,\n+      Dependent_Instances,\n+      Depends_On_Private,\n+      Derived_Type_Link,\n+      Digits_Value,\n+      Predicated_Parent,\n+      Predicates_Ignored,\n+      Direct_Primitive_Operations,\n+      Directly_Designated_Type,\n+      Disable_Controlled,\n+      Discard_Names,\n+      Discriminal,\n+      Discriminal_Link,\n+      Discriminant_Checking_Func,\n+      Discriminant_Constraint,\n+      Discriminant_Default_Value,\n+      Discriminant_Number,\n+      Dispatch_Table_Wrappers,\n+      DT_Entry_Count,\n+      DT_Offset_To_Top_Func,\n+      DT_Position,\n+      DTC_Entity,\n+      Elaborate_Body_Desirable,\n+      Elaboration_Entity,\n+      Elaboration_Entity_Required,\n+      Encapsulating_State,\n+      Enclosing_Scope,\n+      Entry_Accepted,\n+      Entry_Bodies_Array,\n+      Entry_Cancel_Parameter,\n+      Entry_Component,\n+      Entry_Formal,\n+      Entry_Index_Constant,\n+      Entry_Max_Queue_Lengths_Array,\n+      Entry_Parameters_Type,\n+      Enum_Pos_To_Rep,\n+      Enumeration_Pos,\n+      Enumeration_Rep,\n+      Enumeration_Rep_Expr,\n+      Equivalent_Type,\n+      Esize,\n+      Extra_Accessibility,\n+      Extra_Accessibility_Of_Result,\n+      Extra_Constrained,\n+      Extra_Formal,\n+      Extra_Formals,\n+      Finalization_Master,\n+      Finalize_Storage_Only,\n+      Finalizer,\n+      First_Entity,\n+      First_Exit_Statement,\n+      First_Index,\n+      First_Literal,\n+      First_Private_Entity,\n+      First_Rep_Item,\n+      Float_Rep,\n+      Freeze_Node,\n+      From_Limited_With,\n+      Full_View,\n+      Generic_Homonym,\n+      Generic_Renamings,\n+      Handler_Records,\n+      Has_Aliased_Components,\n+      Has_Alignment_Clause,\n+      Has_All_Calls_Remote,\n+      Has_Atomic_Components,\n+      Has_Biased_Representation,\n+      Has_Completion,\n+      Has_Completion_In_Body,\n+      Has_Complex_Representation,\n+      Has_Component_Size_Clause,\n+      Has_Constrained_Partial_View,\n+      Has_Contiguous_Rep,\n+      Has_Controlled_Component,\n+      Has_Controlling_Result,\n+      Has_Convention_Pragma,\n+      Has_Default_Aspect,\n+      Has_Delayed_Aspects,\n+      Has_Delayed_Freeze,\n+      Has_Delayed_Rep_Aspects,\n+      Has_Discriminants,\n+      Has_Dispatch_Table,\n+      Has_Dynamic_Predicate_Aspect,\n+      Has_Enumeration_Rep_Clause,\n+      Has_Exit,\n+      Has_Expanded_Contract,\n+      Has_Forward_Instantiation,\n+      Has_Fully_Qualified_Name,\n+      Has_Gigi_Rep_Item,\n+      Has_Homonym,\n+      Has_Implicit_Dereference,\n+      Has_Independent_Components,\n+      Has_Inheritable_Invariants,\n+      Has_Inherited_DIC,\n+      Has_Inherited_Invariants,\n+      Has_Initial_Value,\n+      Has_Loop_Entry_Attributes,\n+      Has_Machine_Radix_Clause,\n+      Has_Master_Entity,\n+      Has_Missing_Return,\n+      Has_Nested_Block_With_Handler,\n+      Has_Nested_Subprogram,\n+      Has_Non_Standard_Rep,\n+      Has_Object_Size_Clause,\n+      Has_Out_Or_In_Out_Parameter,\n+      Has_Own_DIC,\n+      Has_Own_Invariants,\n+      Has_Partial_Visible_Refinement,\n+      Has_Per_Object_Constraint,\n+      Has_Pragma_Controlled,\n+      Has_Pragma_Elaborate_Body,\n+      Has_Pragma_Inline,\n+      Has_Pragma_Inline_Always,\n+      Has_Pragma_No_Inline,\n+      Has_Pragma_Ordered,\n+      Has_Pragma_Pack,\n+      Has_Pragma_Preelab_Init,\n+      Has_Pragma_Pure,\n+      Has_Pragma_Pure_Function,\n+      Has_Pragma_Thread_Local_Storage,\n+      Has_Pragma_Unmodified,\n+      Has_Pragma_Unreferenced,\n+      Has_Pragma_Unreferenced_Objects,\n+      Has_Pragma_Unused,\n+      Has_Predicates,\n+      Has_Primitive_Operations,\n+      Has_Private_Ancestor,\n+      Has_Private_Declaration,\n+      Has_Private_Extension,\n+      Has_Protected,\n+      Has_Qualified_Name,\n+      Has_RACW,\n+      Has_Record_Rep_Clause,\n+      Has_Recursive_Call,\n+      Has_Shift_Operator,\n+      Has_Size_Clause,\n+      Has_Small_Clause,\n+      Has_Specified_Layout,\n+      Has_Specified_Stream_Input,\n+      Has_Specified_Stream_Output,\n+      Has_Specified_Stream_Read,\n+      Has_Specified_Stream_Write,\n+      Has_Static_Discriminants,\n+      Has_Static_Predicate,\n+      Has_Static_Predicate_Aspect,\n+      Has_Storage_Size_Clause,\n+      Has_Stream_Size_Clause,\n+      Has_Task,\n+      Has_Timing_Event,\n+      Has_Thunks,\n+      Has_Unchecked_Union,\n+      Has_Unknown_Discriminants,\n+      Has_Visible_Refinement,\n+      Has_Volatile_Components,\n+      Has_Xref_Entry,\n+      Has_Yield_Aspect,\n+      Hiding_Loop_Variable,\n+      Hidden_In_Formal_Instance,\n+      Homonym,\n+      Ignore_SPARK_Mode_Pragmas,\n+      Import_Pragma,\n+      Incomplete_Actuals,\n+      In_Package_Body,\n+      In_Private_Part,\n+      In_Use,\n+      Initialization_Statements,\n+      Inner_Instances,\n+      Interface_Alias,\n+      Interface_Name,\n+      Interfaces,\n+      Is_Abstract_Subprogram,\n+      Is_Abstract_Type,\n+      Is_Access_Constant,\n+      Is_Activation_Record,\n+      Is_Actual_Subtype,\n+      Is_Ada_2005_Only,\n+      Is_Ada_2012_Only,\n+      Is_Aliased,\n+      Is_Asynchronous,\n+      Is_Atomic,\n+      Is_Bit_Packed_Array,\n+      Is_Called,\n+      Is_Character_Type,\n+      Is_Checked_Ghost_Entity,\n+      Is_Child_Unit,\n+      Is_Class_Wide_Clone,\n+      Is_Class_Wide_Equivalent_Type,\n+      Is_Compilation_Unit,\n+      Is_Completely_Hidden,\n+      Is_Concurrent_Record_Type,\n+      Is_Constr_Subt_For_U_Nominal,\n+      Is_Constr_Subt_For_UN_Aliased,\n+      Is_Constrained,\n+      Is_Constructor,\n+      Is_Controlled_Active,\n+      Is_Controlling_Formal,\n+      Is_CPP_Class,\n+      Is_CUDA_Kernel,\n+      Is_Descendant_Of_Address,\n+      Is_DIC_Procedure,\n+      Is_Discrim_SO_Function,\n+      Is_Discriminant_Check_Function,\n+      Is_Dispatch_Table_Entity,\n+      Is_Dispatching_Operation,\n+      Is_Elaboration_Checks_OK_Id,\n+      Is_Elaboration_Warnings_OK_Id,\n+      Is_Eliminated,\n+      Is_Entry_Formal,\n+      Is_Entry_Wrapper,\n+      Is_Exception_Handler,\n+      Is_Exported,\n+      Is_Finalized_Transient,\n+      Is_First_Subtype,\n+      Is_Formal_Subprogram,\n+      Is_Frozen,\n+      Is_Generic_Actual_Subprogram,\n+      Is_Generic_Actual_Type,\n+      Is_Generic_Instance,\n+      Is_Generic_Type,\n+      Is_Hidden,\n+      Is_Hidden_Non_Overridden_Subpgm,\n+      Is_Hidden_Open_Scope,\n+      Is_Ignored_Ghost_Entity,\n+      Is_Ignored_Transient,\n+      Is_Immediately_Visible,\n+      Is_Implementation_Defined,\n+      Is_Imported,\n+      Is_Independent,\n+      Is_Initial_Condition_Procedure,\n+      Is_Inlined,\n+      Is_Inlined_Always,\n+      Is_Instantiated,\n+      Is_Interface,\n+      Is_Internal,\n+      Is_Interrupt_Handler,\n+      Is_Intrinsic_Subprogram,\n+      Is_Invariant_Procedure,\n+      Is_Itype,\n+      Is_Known_Non_Null,\n+      Is_Known_Null,\n+      Is_Known_Valid,\n+      Is_Limited_Composite,\n+      Is_Limited_Interface,\n+      Is_Limited_Record,\n+      Is_Local_Anonymous_Access,\n+      Is_Loop_Parameter,\n+      Is_Machine_Code_Subprogram,\n+      Is_Non_Static_Subtype,\n+      Is_Null_Init_Proc,\n+      Is_Obsolescent,\n+      Is_Only_Out_Parameter,\n+      Is_Package_Body_Entity,\n+      Is_Packed,\n+      Is_Packed_Array_Impl_Type,\n+      Is_Param_Block_Component_Type,\n+      Is_Partial_Invariant_Procedure,\n+      Is_Potentially_Use_Visible,\n+      Is_Predicate_Function,\n+      Is_Predicate_Function_M,\n+      Is_Preelaborated,\n+      Is_Primitive,\n+      Is_Primitive_Wrapper,\n+      Is_Private_Composite,\n+      Is_Private_Descendant,\n+      Is_Private_Primitive,\n+      Is_Public,\n+      Is_Pure,\n+      Is_Pure_Unit_Access_Type,\n+      Is_RACW_Stub_Type,\n+      Is_Raised,\n+      Is_Remote_Call_Interface,\n+      Is_Remote_Types,\n+      Is_Renaming_Of_Object,\n+      Is_Return_Object,\n+      Is_Safe_To_Reevaluate,\n+      Is_Shared_Passive,\n+      Is_Static_Type,\n+      Is_Statically_Allocated,\n+      Is_Tag,\n+      Is_Tagged_Type,\n+      Is_Thunk,\n+      Is_Trivial_Subprogram,\n+      Is_True_Constant,\n+      Is_Unchecked_Union,\n+      Is_Underlying_Full_View,\n+      Is_Underlying_Record_View,\n+      Is_Unimplemented,\n+      Is_Unsigned_Type,\n+      Is_Uplevel_Referenced_Entity,\n+      Is_Valued_Procedure,\n+      Is_Visible_Formal,\n+      Is_Visible_Lib_Unit,\n+      Is_Volatile_Type,\n+      Is_Volatile_Object,\n+      Is_Volatile_Full_Access,\n+      Itype_Printed,\n+      Kill_Elaboration_Checks,\n+      Kill_Range_Checks,\n+      Known_To_Have_Preelab_Init,\n+      Last_Aggregate_Assignment,\n+      Last_Assignment,\n+      Last_Entity,\n+      Limited_View,\n+      Linker_Section_Pragma,\n+      Lit_Hash,\n+      Lit_Indexes,\n+      Lit_Strings,\n+      Low_Bound_Tested,\n+      Machine_Radix_10,\n+      Master_Id,\n+      Materialize_Entity,\n+      May_Inherit_Delayed_Rep_Aspects,\n+      Mechanism,\n+      Minimum_Accessibility,\n+      Modulus,\n+      Must_Be_On_Byte_Boundary,\n+      Must_Have_Preelab_Init,\n+      Needs_Activation_Record,\n+      Needs_Debug_Info,\n+      Needs_No_Actuals,\n+      Never_Set_In_Source,\n+      Next_Inlined_Subprogram,\n+      No_Dynamic_Predicate_On_Actual,\n+      No_Pool_Assigned,\n+      No_Predicate_On_Actual,\n+      No_Reordering,\n+      No_Return,\n+      No_Strict_Aliasing,\n+      No_Tagged_Streams_Pragma,\n+      Non_Binary_Modulus,\n+      Non_Limited_View,\n+      Nonzero_Is_True,\n+      Normalized_First_Bit,\n+      Normalized_Position,\n+      Normalized_Position_Max,\n+      OK_To_Rename,\n+      Optimize_Alignment_Space,\n+      Optimize_Alignment_Time,\n+      Original_Access_Type,\n+      Original_Array_Type,\n+      Original_Protected_Subprogram,\n+      Original_Record_Component,\n+      Overlays_Constant,\n+      Overridden_Operation,\n+      Package_Instantiation,\n+      Packed_Array_Impl_Type,\n+      Parent_Subtype,\n+      Part_Of_Constituents,\n+      Part_Of_References,\n+      Partial_View_Has_Unknown_Discr,\n+      Pending_Access_Types,\n+      Postconditions_Proc,\n+      Prev_Entity,\n+      Prival,\n+      Prival_Link,\n+      Private_Dependents,\n+      Protected_Body_Subprogram,\n+      Protected_Formal,\n+      Protected_Subprogram,\n+      Protection_Object,\n+      Reachable,\n+      Receiving_Entry,\n+      Referenced,\n+      Referenced_As_LHS,\n+      Referenced_As_Out_Parameter,\n+      Refinement_Constituents,\n+      Register_Exception_Call,\n+      Related_Array_Object,\n+      Related_Expression,\n+      Related_Instance,\n+      Related_Type,\n+      Relative_Deadline_Variable,\n+--  ???      Renamed_Entity,\n+      Renamed_In_Spec,\n+--  ???      Renamed_Object,\n+      Renamed_Or_Alias, -- ???Replaces Alias, Renamed_Entity, Renamed_Object\n+      Renaming_Map,\n+      Requires_Overriding,\n+      Return_Applies_To,\n+      Return_Present,\n+      Returns_By_Ref,\n+      Reverse_Bit_Order,\n+      Reverse_Storage_Order,\n+      Rewritten_For_C,\n+      RM_Size,\n+      Scalar_Range,\n+      Scale_Value,\n+      Scope_Depth_Value,\n+      Sec_Stack_Needed_For_Return,\n+      Shared_Var_Procs_Instance,\n+      Size_Check_Code,\n+      Size_Depends_On_Discriminant,\n+      Size_Known_At_Compile_Time,\n+      Small_Value,\n+      SPARK_Aux_Pragma,\n+      SPARK_Aux_Pragma_Inherited,\n+      SPARK_Pragma,\n+      SPARK_Pragma_Inherited,\n+      Spec_Entity,\n+      SSO_Set_High_By_Default,\n+      SSO_Set_Low_By_Default,\n+      Static_Discrete_Predicate,\n+      Static_Elaboration_Desired,\n+      Static_Initialization,\n+      Static_Real_Or_String_Predicate,\n+      Status_Flag_Or_Transient_Decl,\n+      Storage_Size_Variable,\n+      Stored_Constraint,\n+      Stores_Attribute_Old_Prefix,\n+      Strict_Alignment,\n+      String_Literal_Length,\n+      String_Literal_Low_Bound,\n+      Subprograms_For_Type,\n+      Subps_Index,\n+      Suppress_Elaboration_Warnings,\n+      Suppress_Initialization,\n+      Suppress_Style_Checks,\n+      Suppress_Value_Tracking_On_Call,\n+      Task_Body_Procedure,\n+      Thunk_Entity,\n+      Treat_As_Volatile,\n+      Underlying_Full_View,\n+      Underlying_Record_View,\n+      Universal_Aliasing,\n+      Unset_Reference,\n+      Used_As_Generic_Actual,\n+      Uses_Lock_Free,\n+      Uses_Sec_Stack,\n+      Validated_Object,\n+      Warnings_Off,\n+      Warnings_Off_Used,\n+      Warnings_Off_Used_Unmodified,\n+      Warnings_Off_Used_Unreferenced,\n+      Was_Default_Init_Box_Association,\n+      Was_Hidden,\n+      Wrapped_Entity\n+\n+      --  End of entity fields.\n+     ); -- Opt_Field_Enum\n+\n+end Gen_IL.Fields;"}, {"sha": "588d22e302ced3f7bc6ff2ef9ddc88f5cfb66a99", "filename": "gcc/ada/gen_il-gen-gen_entities.adb", "status": "added", "additions": 1304, "deletions": 0, "changes": 1304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_entities.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,1304 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--               G E N _ I L . G E N . G E N _ E N T I T I E S              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2020-2021, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+procedure Gen_IL.Gen.Gen_Entities is\n+\n+   procedure Ab\n+     (T : Abstract_Entity; Parent : Abstract_Type;\n+      Fields : Field_Sequence := No_Fields)\n+      renames Create_Abstract_Entity_Type;\n+   procedure Cc\n+     (T : Concrete_Entity; Parent : Abstract_Type;\n+      Fields : Field_Sequence := No_Fields)\n+      renames Create_Concrete_Entity_Type;\n+\n+   function Sm\n+     (Field : Field_Enum; Field_Type : Type_Enum;\n+      Type_Only  : Type_Only_Enum := No_Type_Only;\n+      Pre : String := \"\") return Field_Desc\n+      renames Create_Semantic_Field;\n+\n+   procedure Union (T : Abstract_Entity; Children : Type_Array)\n+     renames Create_Entity_Union;\n+\n+begin -- Gen_IL.Gen.Gen_Entities\n+   pragma Style_Checks (\"M200\");\n+\n+   Create_Root_Entity_Type (Entity_Kind,\n+       (Sm (Ekind, Ekind_Type),\n+        Sm (Basic_Convention, Convention_Id),\n+        Sm (Address_Taken, Flag),\n+        Sm (Associated_Entity, Node_Id),\n+        Sm (Can_Never_Be_Null, Flag),\n+        Sm (Checks_May_Be_Suppressed, Flag),\n+        Sm (Debug_Info_Off, Flag),\n+        Sm (Default_Expressions_Processed, Flag),\n+        Sm (Delay_Cleanups, Flag),\n+        Sm (Delay_Subprogram_Descriptors, Flag),\n+        Sm (Depends_On_Private, Flag),\n+        Sm (Disable_Controlled, Flag, Base_Type_Only),\n+        Sm (Discard_Names, Flag),\n+        Sm (First_Rep_Item, Node_Id),\n+        Sm (Freeze_Node, Node_Id),\n+        Sm (From_Limited_With, Flag),\n+        Sm (Has_Aliased_Components, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Alignment_Clause, Flag),\n+        Sm (Has_All_Calls_Remote, Flag),\n+        Sm (Has_Atomic_Components, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Biased_Representation, Flag),\n+        Sm (Has_Completion, Flag),\n+        Sm (Has_Contiguous_Rep, Flag),\n+        Sm (Has_Controlled_Component, Flag, Base_Type_Only),\n+        Sm (Has_Controlling_Result, Flag),\n+        Sm (Has_Convention_Pragma, Flag),\n+        Sm (Has_Default_Aspect, Flag, Base_Type_Only),\n+        Sm (Has_Delayed_Aspects, Flag),\n+        Sm (Has_Delayed_Freeze, Flag),\n+        Sm (Has_Delayed_Rep_Aspects, Flag),\n+        Sm (Has_Exit, Flag),\n+        Sm (Has_Forward_Instantiation, Flag),\n+        Sm (Has_Fully_Qualified_Name, Flag),\n+        Sm (Has_Gigi_Rep_Item, Flag),\n+        Sm (Has_Homonym, Flag),\n+        Sm (Has_Implicit_Dereference, Flag),\n+        Sm (Has_Independent_Components, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Master_Entity, Flag),\n+        Sm (Has_Nested_Block_With_Handler, Flag),\n+        Sm (Has_Non_Standard_Rep, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Per_Object_Constraint, Flag),\n+        Sm (Has_Pragma_Elaborate_Body, Flag),\n+        Sm (Has_Pragma_Inline, Flag),\n+        Sm (Has_Pragma_Inline_Always, Flag),\n+        Sm (Has_Pragma_No_Inline, Flag),\n+        Sm (Has_Pragma_Preelab_Init, Flag),\n+        Sm (Has_Pragma_Pure, Flag),\n+        Sm (Has_Pragma_Pure_Function, Flag),\n+        Sm (Has_Pragma_Thread_Local_Storage, Flag),\n+        Sm (Has_Pragma_Unmodified, Flag),\n+        Sm (Has_Pragma_Unreferenced, Flag),\n+        Sm (Has_Pragma_Unused, Flag),\n+        Sm (Has_Private_Ancestor, Flag),\n+        Sm (Has_Private_Declaration, Flag),\n+        Sm (Has_Protected, Flag, Base_Type_Only),\n+        Sm (Has_Qualified_Name, Flag),\n+        Sm (Has_Size_Clause, Flag),\n+        Sm (Has_Stream_Size_Clause, Flag),\n+        Sm (Has_Task, Flag, Base_Type_Only),\n+        Sm (Has_Timing_Event, Flag, Base_Type_Only),\n+        Sm (Has_Thunks, Flag),\n+        Sm (Has_Unchecked_Union, Flag, Base_Type_Only),\n+        Sm (Has_Volatile_Components, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Xref_Entry, Flag),\n+        Sm (Has_Yield_Aspect, Flag),\n+        Sm (Homonym, Node_Id),\n+        Sm (In_Package_Body, Flag),\n+        Sm (In_Private_Part, Flag),\n+        Sm (In_Use, Flag),\n+        Sm (Is_Ada_2005_Only, Flag),\n+        Sm (Is_Ada_2012_Only, Flag),\n+        Sm (Is_Aliased, Flag),\n+        Sm (Is_Atomic, Flag),\n+        Sm (Is_Bit_Packed_Array, Flag, Impl_Base_Type_Only),\n+        Sm (Is_Character_Type, Flag),\n+        Sm (Is_Checked_Ghost_Entity, Flag),\n+        Sm (Is_Child_Unit, Flag),\n+        Sm (Is_Class_Wide_Clone, Flag),\n+        Sm (Is_Class_Wide_Equivalent_Type, Flag),\n+        Sm (Is_Compilation_Unit, Flag),\n+        Sm (Is_Concurrent_Record_Type, Flag),\n+        Sm (Is_Constr_Subt_For_U_Nominal, Flag),\n+        Sm (Is_Constr_Subt_For_UN_Aliased, Flag),\n+        Sm (Is_Constrained, Flag),\n+        Sm (Is_Constructor, Flag),\n+        Sm (Is_Controlled_Active, Flag, Base_Type_Only),\n+        Sm (Is_CPP_Class, Flag),\n+        Sm (Is_Descendant_Of_Address, Flag),\n+        Sm (Is_Discrim_SO_Function, Flag),\n+        Sm (Is_Discriminant_Check_Function, Flag),\n+        Sm (Is_Dispatch_Table_Entity, Flag),\n+        Sm (Is_Dispatching_Operation, Flag),\n+        Sm (Is_Eliminated, Flag),\n+        Sm (Is_Entry_Formal, Flag),\n+        Sm (Is_Entry_Wrapper, Flag),\n+        Sm (Is_Exported, Flag),\n+        Sm (Is_First_Subtype, Flag),\n+        Sm (Is_Formal_Subprogram, Flag),\n+        Sm (Is_Frozen, Flag),\n+        Sm (Is_Generic_Instance, Flag),\n+        Sm (Is_Generic_Type, Flag),\n+        Sm (Is_Hidden, Flag),\n+        Sm (Is_Hidden_Non_Overridden_Subpgm, Flag),\n+        Sm (Is_Hidden_Open_Scope, Flag),\n+        Sm (Is_Ignored_Ghost_Entity, Flag),\n+        Sm (Is_Immediately_Visible, Flag),\n+        Sm (Is_Implementation_Defined, Flag),\n+        Sm (Is_Imported, Flag),\n+        Sm (Is_Independent, Flag),\n+        Sm (Is_Inlined, Flag),\n+        Sm (Is_Instantiated, Flag),\n+        Sm (Is_Interface, Flag),\n+        Sm (Is_Internal, Flag),\n+        Sm (Is_Interrupt_Handler, Flag),\n+        Sm (Is_Intrinsic_Subprogram, Flag),\n+        Sm (Is_Itype, Flag),\n+        Sm (Is_Known_Non_Null, Flag),\n+        Sm (Is_Known_Null, Flag),\n+        Sm (Is_Known_Valid, Flag),\n+        Sm (Is_Limited_Composite, Flag),\n+        Sm (Is_Limited_Interface, Flag),\n+        Sm (Is_Limited_Record, Flag),\n+        Sm (Is_Loop_Parameter, Flag),\n+        Sm (Is_Obsolescent, Flag),\n+        Sm (Is_Package_Body_Entity, Flag),\n+        Sm (Is_Packed, Flag, Impl_Base_Type_Only),\n+        Sm (Is_Packed_Array_Impl_Type, Flag),\n+        Sm (Is_Potentially_Use_Visible, Flag),\n+        Sm (Is_Preelaborated, Flag),\n+        Sm (Is_Private_Descendant, Flag),\n+        Sm (Is_Public, Flag),\n+        Sm (Is_Pure, Flag),\n+        Sm (Is_Remote_Call_Interface, Flag),\n+        Sm (Is_Remote_Types, Flag),\n+        Sm (Is_Renaming_Of_Object, Flag),\n+        Sm (Is_Return_Object, Flag),\n+        Sm (Is_Safe_To_Reevaluate, Flag),\n+        Sm (Is_Shared_Passive, Flag),\n+        Sm (Is_Static_Type, Flag),\n+        Sm (Is_Statically_Allocated, Flag),\n+        Sm (Is_Tag, Flag),\n+        Sm (Is_Tagged_Type, Flag),\n+        Sm (Is_Thunk, Flag),\n+        Sm (Is_Trivial_Subprogram, Flag),\n+        Sm (Is_True_Constant, Flag),\n+        Sm (Is_Unchecked_Union, Flag, Impl_Base_Type_Only),\n+        Sm (Is_Underlying_Full_View, Flag),\n+        Sm (Is_Underlying_Record_View, Flag, Base_Type_Only),\n+        Sm (Is_Unimplemented, Flag),\n+        Sm (Is_Uplevel_Referenced_Entity, Flag),\n+        Sm (Is_Visible_Formal, Flag),\n+        Sm (Is_Visible_Lib_Unit, Flag),\n+        Sm (Is_Volatile_Type, Flag), -- Should be Base_Type_Only?????\n+        Sm (Is_Volatile_Object, Flag),\n+        Sm (Is_Volatile_Full_Access, Flag),\n+        Sm (Kill_Elaboration_Checks, Flag),\n+        Sm (Kill_Range_Checks, Flag),\n+        Sm (Low_Bound_Tested, Flag),\n+        Sm (Materialize_Entity, Flag),\n+        Sm (May_Inherit_Delayed_Rep_Aspects, Flag),\n+        Sm (Needs_Activation_Record, Flag),\n+        Sm (Needs_Debug_Info, Flag),\n+        Sm (Never_Set_In_Source, Flag),\n+        Sm (No_Return, Flag),\n+        Sm (Overlays_Constant, Flag),\n+        Sm (Prev_Entity, Node_Id),\n+        Sm (Reachable, Flag),\n+        Sm (Referenced, Flag),\n+        Sm (Referenced_As_LHS, Flag),\n+        Sm (Referenced_As_Out_Parameter, Flag),\n+        Sm (Return_Present, Flag),\n+        Sm (Returns_By_Ref, Flag),\n+        Sm (Sec_Stack_Needed_For_Return, Flag),\n+        Sm (Size_Depends_On_Discriminant, Flag),\n+        Sm (Size_Known_At_Compile_Time, Flag),\n+        Sm (Stores_Attribute_Old_Prefix, Flag),\n+        Sm (Strict_Alignment, Flag, Impl_Base_Type_Only),\n+        Sm (Suppress_Elaboration_Warnings, Flag),\n+        Sm (Suppress_Style_Checks, Flag),\n+        Sm (Suppress_Value_Tracking_On_Call, Flag),\n+        Sm (Treat_As_Volatile, Flag),\n+        Sm (Used_As_Generic_Actual, Flag),\n+        Sm (Uses_Sec_Stack, Flag),\n+        Sm (Warnings_Off, Flag),\n+        Sm (Warnings_Off_Used, Flag),\n+        Sm (Warnings_Off_Used_Unmodified, Flag),\n+        Sm (Warnings_Off_Used_Unreferenced, Flag),\n+        Sm (Was_Hidden, Flag)));\n+\n+   Cc (E_Void, Entity_Kind,\n+       (Sm (Alignment, Uint),\n+        Sm (Contract, Node_Id),\n+        Sm (Is_Elaboration_Warnings_OK_Id, Flag),\n+        Sm (Original_Record_Component, Node_Id),\n+        Sm (Scope_Depth_Value, Uint),\n+        Sm (SPARK_Pragma, Node_Id),\n+        Sm (SPARK_Pragma_Inherited, Flag),\n+        Sm (Corresponding_Protected_Entry, Node_Id), -- setter only\n+        Sm (Current_Value, Node_Id), -- setter only\n+        Sm (Has_Predicates, Flag), -- setter only\n+        Sm (Initialization_Statements, Node_Id), -- setter only\n+        Sm (Is_Param_Block_Component_Type, Flag, Base_Type_Only), -- setter only\n+        Sm (Package_Instantiation, Node_Id), -- setter only\n+        Sm (Related_Expression, Node_Id), -- setter only\n+\n+        --  ????The following are not documented in the old einfo.ads as being\n+        --  fields of E_Void.\n+        Sm (Accept_Address, Elist_Id),\n+        Sm (Associated_Formal_Package, Node_Id),\n+        Sm (Associated_Node_For_Itype, Node_Id),\n+        Sm (Corresponding_Remote_Type, Node_Id),\n+        Sm (CR_Discriminant, Node_Id),\n+        Sm (Debug_Renaming_Link, Node_Id),\n+        Sm (Directly_Designated_Type, Node_Id),\n+        Sm (Discriminal_Link, Node_Id),\n+        Sm (Discriminant_Default_Value, Node_Id),\n+        Sm (Discriminant_Number, Uint),\n+        Sm (Enclosing_Scope, Node_Id),\n+        Sm (Entry_Bodies_Array, Node_Id,\n+            Pre => \"Has_Entries (N)\"), -- This can't be right????\n+        Sm (Entry_Cancel_Parameter, Node_Id),\n+        Sm (Entry_Component, Node_Id),\n+        Sm (Entry_Formal, Node_Id),\n+        Sm (Entry_Parameters_Type, Node_Id),\n+        Sm (Esize, Uint),\n+        Sm (RM_Size, Uint),\n+        Sm (Extra_Formal, Node_Id),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Float_Rep, Float_Rep_Kind, Base_Type_Only),\n+        Sm (Generic_Homonym, Node_Id),\n+        Sm (Generic_Renamings, Elist_Id),\n+        Sm (Handler_Records, List_Id),\n+--  ????         Sm (Has_Protected, Flag),\n+        Sm (Has_Static_Discriminants, Flag),\n+        Sm (Inner_Instances, Elist_Id),\n+        Sm (Interface_Name, Node_Id),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Next_Inlined_Subprogram, Node_Id),\n+        Sm (Renamed_Or_Alias, Node_Id), -- See Einfo.Utils\n+        Sm (Renaming_Map, Uint),\n+        Sm (Return_Applies_To, Node_Id),\n+        Sm (Scalar_Range, Node_Id),\n+        Sm (Scale_Value, Uint),\n+        Sm (Unset_Reference, Node_Id)));\n+   --  In the previous version, the above \"setter only\" fields were allowed for\n+   --  E_Void only on the setters, not getters.\n+\n+   --  ????This comment in the old version of einfo.adb:\n+\n+   --  Note: in many of these set procedures an \"obvious\" assertion is missing.\n+   --  The reason for this is that in many cases, a field is set before the\n+   --  Ekind field is set, so that the field is set when Ekind = E_Void. It\n+   --  it is possible to add assertions that specifically include the E_Void\n+   --  possibility, but in some cases, we just omit the assertions.\n+\n+   --  causes a lot of headaches. Plus some places used the low-level setters\n+   --  (e.g. Set_Node1), which bypasses any assertions.\n+\n+   Ab (Object_Kind, Entity_Kind,\n+       (Sm (Current_Value, Node_Id),\n+        Sm (Renamed_Or_Alias, Node_Id)));\n+\n+   Cc (E_Component, Object_Kind,\n+       (Sm (Component_Bit_Offset, Uint),\n+        Sm (Component_Clause, Node_Id),\n+        Sm (Corresponding_Record_Component, Node_Id),\n+        Sm (Discriminant_Checking_Func, Node_Id),\n+        Sm (DT_Entry_Count, Uint,\n+            Pre => \"Is_Tag (N)\"),\n+        Sm (DT_Offset_To_Top_Func, Node_Id,\n+            Pre => \"Is_Tag (N)\"),\n+        Sm (Entry_Formal, Node_Id),\n+        Sm (Esize, Uint),\n+        Sm (Interface_Name, Node_Id),\n+        Sm (Linker_Section_Pragma, Node_Id),\n+        Sm (Normalized_First_Bit, Uint),\n+        Sm (Normalized_Position, Uint),\n+        Sm (Normalized_Position_Max, Uint),\n+        Sm (Original_Record_Component, Node_Id),\n+        Sm (Prival, Node_Id,\n+            Pre => \"Is_Protected_Component (N)\"),\n+        Sm (Related_Type, Node_Id)));\n+\n+   Cc (E_Constant, Object_Kind,\n+       (Sm (Activation_Record_Component, Node_Id),\n+        Sm (Actual_Subtype, Node_Id),\n+        Sm (Alignment, Uint),\n+        Sm (BIP_Initialization_Call, Node_Id),\n+        Sm (Contract, Node_Id),\n+        Sm (Discriminal_Link, Node_Id),\n+        Sm (Encapsulating_State, Node_Id),\n+        Sm (Esize, Uint),\n+        Sm (Extra_Accessibility, Node_Id),\n+        Sm (Full_View, Node_Id),\n+        Sm (Initialization_Statements, Node_Id),\n+        Sm (Interface_Name, Node_Id),\n+        Sm (Is_Elaboration_Checks_OK_Id, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Id, Flag),\n+        Sm (Is_Finalized_Transient, Flag),\n+        Sm (Is_Ignored_Transient, Flag),\n+        Sm (Last_Aggregate_Assignment, Node_Id),\n+        Sm (Linker_Section_Pragma, Node_Id),\n+        Sm (Optimize_Alignment_Space, Flag),\n+        Sm (Optimize_Alignment_Time, Flag),\n+        Sm (Prival_Link, Node_Id),\n+        Sm (Related_Expression, Node_Id),\n+        Sm (Related_Type, Node_Id),\n+        Sm (Size_Check_Code, Node_Id),\n+        Sm (SPARK_Pragma, Node_Id),\n+        Sm (SPARK_Pragma_Inherited, Flag),\n+        Sm (Status_Flag_Or_Transient_Decl, Node_Id)));\n+\n+   Cc (E_Discriminant, Object_Kind,\n+       (Sm (Component_Bit_Offset, Uint),\n+        Sm (Component_Clause, Node_Id),\n+        Sm (Corresponding_Discriminant, Node_Id),\n+        Sm (Corresponding_Record_Component, Node_Id),\n+        Sm (CR_Discriminant, Node_Id),\n+        Sm (Discriminal, Node_Id),\n+        Sm (Discriminant_Default_Value, Node_Id),\n+        Sm (Discriminant_Number, Uint),\n+        Sm (Entry_Formal, Node_Id),\n+        Sm (Esize, Uint),\n+        Sm (Interface_Name, Node_Id),\n+        Sm (Is_Completely_Hidden, Flag),\n+        Sm (Linker_Section_Pragma, Node_Id),\n+        Sm (Normalized_First_Bit, Uint),\n+        Sm (Normalized_Position, Uint),\n+        Sm (Normalized_Position_Max, Uint),\n+        Sm (Original_Record_Component, Node_Id)));\n+\n+   Cc (E_Loop_Parameter, Object_Kind,\n+       (Sm (Activation_Record_Component, Node_Id),\n+        Sm (Alignment, Uint),\n+        Sm (Esize, Uint),\n+        Sm (Is_Finalized_Transient, Flag),\n+        Sm (Is_Ignored_Transient, Flag),\n+        Sm (Linker_Section_Pragma, Node_Id),\n+        Sm (Related_Expression, Node_Id),\n+        Sm (Status_Flag_Or_Transient_Decl, Node_Id)));\n+\n+   Cc (E_Variable, Object_Kind,\n+       (Sm (Activation_Record_Component, Node_Id),\n+        Sm (Actual_Subtype, Node_Id),\n+        Sm (Alignment, Uint),\n+        Sm (Anonymous_Designated_Type, Node_Id),\n+        Sm (BIP_Initialization_Call, Node_Id),\n+        Sm (Contract, Node_Id),\n+        Sm (Debug_Renaming_Link, Node_Id),\n+        Sm (Discriminal_Link, Node_Id),\n+        Sm (Encapsulating_State, Node_Id),\n+        Sm (Esize, Uint),\n+        Sm (Extra_Accessibility, Node_Id),\n+        Sm (Extra_Constrained, Node_Id),\n+        Sm (Has_Initial_Value, Flag),\n+        Sm (Hiding_Loop_Variable, Node_Id),\n+        Sm (Initialization_Statements, Node_Id),\n+        Sm (Interface_Name, Node_Id),\n+        Sm (Is_Elaboration_Checks_OK_Id, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Id, Flag),\n+        Sm (Is_Finalized_Transient, Flag),\n+        Sm (Is_Ignored_Transient, Flag),\n+        Sm (Last_Aggregate_Assignment, Node_Id),\n+        Sm (Last_Assignment, Node_Id),\n+        Sm (Linker_Section_Pragma, Node_Id),\n+        Sm (OK_To_Rename, Flag),\n+        Sm (Optimize_Alignment_Space, Flag),\n+        Sm (Optimize_Alignment_Time, Flag),\n+        Sm (Part_Of_Constituents, Elist_Id),\n+        Sm (Part_Of_References, Elist_Id),\n+        Sm (Prival_Link, Node_Id),\n+        Sm (Related_Expression, Node_Id),\n+        Sm (Related_Type, Node_Id),\n+        Sm (Shared_Var_Procs_Instance, Node_Id),\n+        Sm (Size_Check_Code, Node_Id),\n+        Sm (SPARK_Pragma, Node_Id),\n+        Sm (SPARK_Pragma_Inherited, Flag),\n+        Sm (Status_Flag_Or_Transient_Decl, Node_Id),\n+        Sm (Suppress_Initialization, Flag),\n+        Sm (Unset_Reference, Node_Id),\n+        Sm (Validated_Object, Node_Id)));\n+\n+   Ab (Formal_Kind, Object_Kind,\n+       (Sm (Activation_Record_Component, Node_Id),\n+        Sm (Actual_Subtype, Node_Id),\n+        Sm (Alignment, Uint),\n+        Sm (Default_Expr_Function, Node_Id),\n+        Sm (Default_Value, Node_Id),\n+        Sm (Entry_Component, Node_Id),\n+        Sm (Esize, Uint),\n+        Sm (Extra_Accessibility, Node_Id),\n+        Sm (Extra_Constrained, Node_Id),\n+        Sm (Extra_Formal, Node_Id),\n+        Sm (Has_Initial_Value, Flag),\n+        Sm (Is_Controlling_Formal, Flag),\n+        Sm (Is_Only_Out_Parameter, Flag),\n+        Sm (Linker_Section_Pragma, Node_Id),\n+        Sm (Mechanism, Mechanism_Type),\n+        Sm (Minimum_Accessibility, Node_Id),\n+        Sm (Protected_Formal, Node_Id),\n+        Sm (Spec_Entity, Node_Id),\n+        Sm (Unset_Reference, Node_Id)));\n+\n+   Cc (E_Out_Parameter, Formal_Kind,\n+       (Sm (Last_Assignment, Node_Id)));\n+\n+   Cc (E_In_Out_Parameter, Formal_Kind,\n+       (Sm (Last_Assignment, Node_Id)));\n+\n+   Cc (E_In_Parameter, Formal_Kind,\n+       (Sm (Discriminal_Link, Node_Id),\n+        Sm (Discriminant_Default_Value, Node_Id),\n+        Sm (Is_Activation_Record, Flag)));\n+\n+   Ab (Formal_Object_Kind, Object_Kind,\n+       (Sm (Entry_Component, Node_Id),\n+        Sm (Esize, Uint)));\n+\n+   Cc (E_Generic_In_Out_Parameter, Formal_Object_Kind,\n+       (Sm (Actual_Subtype, Node_Id)));\n+\n+   Cc (E_Generic_In_Parameter, Formal_Object_Kind);\n+\n+   Ab (Named_Kind, Entity_Kind,\n+       (Sm (Renamed_Or_Alias, Node_Id)));\n+\n+   Cc (E_Named_Integer, Named_Kind);\n+\n+   Cc (E_Named_Real, Named_Kind);\n+\n+   Ab (Type_Kind, Entity_Kind,\n+       (Sm (Alignment, Uint),\n+        Sm (Associated_Node_For_Itype, Node_Id),\n+        Sm (Can_Use_Internal_Rep, Flag, Base_Type_Only,\n+            Pre => \"Is_Access_Subprogram_Type (Base_Type (N))\"),\n+        Sm (Class_Wide_Type, Node_Id),\n+        Sm (Contract, Node_Id),\n+        Sm (Current_Use_Clause, Node_Id),\n+        Sm (Derived_Type_Link, Node_Id),\n+        Sm (Predicates_Ignored, Flag),\n+        Sm (Esize, Uint),\n+        Sm (Finalize_Storage_Only, Flag, Base_Type_Only),\n+        Sm (Full_View, Node_Id),\n+        Sm (Has_Completion_In_Body, Flag),\n+        Sm (Has_Constrained_Partial_View, Flag, Base_Type_Only),\n+        Sm (Has_Discriminants, Flag),\n+        Sm (Has_Dispatch_Table, Flag,\n+            Pre => \"Is_Tagged_Type (N)\"),\n+        Sm (Has_Dynamic_Predicate_Aspect, Flag),\n+        Sm (Has_Inheritable_Invariants, Flag, Base_Type_Only),\n+        Sm (Has_Inherited_DIC, Flag, Base_Type_Only),\n+        Sm (Has_Inherited_Invariants, Flag, Base_Type_Only),\n+        Sm (Has_Object_Size_Clause, Flag),\n+        Sm (Has_Own_DIC, Flag, Base_Type_Only),\n+        Sm (Has_Own_Invariants, Flag, Base_Type_Only),\n+        Sm (Has_Pragma_Unreferenced_Objects, Flag),\n+        Sm (Has_Predicates, Flag),\n+        Sm (Has_Primitive_Operations, Flag, Base_Type_Only),\n+        Sm (Has_Private_Extension, Flag,\n+            Pre => \"Is_Tagged_Type (N)\"),\n+        Sm (Has_Specified_Layout, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Specified_Stream_Input, Flag),\n+        Sm (Has_Specified_Stream_Output, Flag),\n+        Sm (Has_Specified_Stream_Read, Flag),\n+        Sm (Has_Specified_Stream_Write, Flag),\n+        Sm (Has_Static_Discriminants, Flag),\n+        Sm (Has_Static_Predicate, Flag),\n+        Sm (Has_Static_Predicate_Aspect, Flag),\n+        Sm (Has_Unknown_Discriminants, Flag),\n+        Sm (Interface_Name, Node_Id),\n+        Sm (Is_Abstract_Type, Flag),\n+        Sm (Is_Actual_Subtype, Flag),\n+        Sm (Is_Asynchronous, Flag),\n+        Sm (Is_Generic_Actual_Type, Flag),\n+        Sm (Is_Non_Static_Subtype, Flag),\n+        Sm (Is_Private_Composite, Flag),\n+        Sm (Is_RACW_Stub_Type, Flag),\n+        Sm (Is_Unsigned_Type, Flag),\n+        Sm (Itype_Printed, Flag,\n+            Pre => \"Is_Itype (N)\"),\n+        Sm (Known_To_Have_Preelab_Init, Flag),\n+        Sm (Linker_Section_Pragma, Node_Id),\n+        Sm (Must_Be_On_Byte_Boundary, Flag),\n+        Sm (Must_Have_Preelab_Init, Flag),\n+        Sm (No_Tagged_Streams_Pragma, Node_Id,\n+            Pre => \"Is_Tagged_Type (N)\"),\n+        Sm (Non_Binary_Modulus, Flag, Base_Type_Only),\n+        Sm (Optimize_Alignment_Space, Flag),\n+        Sm (Optimize_Alignment_Time, Flag),\n+        Sm (Partial_View_Has_Unknown_Discr, Flag),\n+        Sm (Pending_Access_Types, Elist_Id),\n+        Sm (Related_Expression, Node_Id),\n+        Sm (RM_Size, Uint),\n+        Sm (SPARK_Pragma, Node_Id),\n+        Sm (SPARK_Pragma_Inherited, Flag),\n+        Sm (Subprograms_For_Type, Elist_Id),\n+        Sm (Suppress_Initialization, Flag),\n+        Sm (Universal_Aliasing, Flag, Impl_Base_Type_Only),\n+        Sm (Renamed_Or_Alias, Node_Id)));\n+\n+   Ab (Elementary_Kind, Type_Kind);\n+\n+   Ab (Scalar_Kind, Elementary_Kind,\n+       (Sm (Default_Aspect_Value, Node_Id, Base_Type_Only),\n+        Sm (Scalar_Range, Node_Id)));\n+\n+   Ab (Discrete_Kind, Scalar_Kind,\n+       (Sm (No_Dynamic_Predicate_On_Actual, Flag),\n+        Sm (No_Predicate_On_Actual, Flag),\n+        Sm (Static_Discrete_Predicate, List_Id)));\n+\n+   Ab (Enumeration_Kind, Discrete_Kind,\n+       (Sm (First_Literal, Node_Id),\n+        Sm (Has_Enumeration_Rep_Clause, Flag),\n+        Sm (Has_Pragma_Ordered, Flag, Impl_Base_Type_Only),\n+        Sm (Lit_Indexes, Node_Id),\n+        Sm (Lit_Strings, Node_Id),\n+        Sm (Nonzero_Is_True, Flag, Base_Type_Only,\n+            Pre => \"Root_Type (N) = Standard_Boolean\"),\n+        Sm (Lit_Hash, Node_Id, Root_Type_Only)));\n+\n+   Cc (E_Enumeration_Type, Enumeration_Kind,\n+       (Sm (Enum_Pos_To_Rep, Node_Id),\n+        Sm (First_Entity, Node_Id)));\n+\n+   Cc (E_Enumeration_Subtype, Enumeration_Kind);\n+\n+   Ab (Integer_Kind, Discrete_Kind,\n+       (Sm (Has_Shift_Operator, Flag, Base_Type_Only)));\n+\n+   Ab (Signed_Integer_Kind, Integer_Kind,\n+       (Sm (First_Entity, Node_Id)));\n+\n+   Cc (E_Signed_Integer_Type, Signed_Integer_Kind,\n+       (Sm (Direct_Primitive_Operations, Elist_Id,\n+            Pre => \"Is_Tagged_Type (N)\")));\n+\n+   Cc (E_Signed_Integer_Subtype, Signed_Integer_Kind);\n+\n+   Ab (Modular_Integer_Kind, Integer_Kind,\n+       (Sm (Modulus, Uint, Base_Type_Only),\n+        Sm (Original_Array_Type, Node_Id)));\n+\n+   Cc (E_Modular_Integer_Type, Modular_Integer_Kind);\n+\n+   Cc (E_Modular_Integer_Subtype, Modular_Integer_Kind);\n+\n+   Ab (Real_Kind, Scalar_Kind,\n+       (Sm (Static_Real_Or_String_Predicate, Node_Id)));\n+\n+   Ab (Fixed_Point_Kind, Real_Kind,\n+       (Sm (Delta_Value, Ureal),\n+        Sm (Small_Value, Ureal)));\n+\n+   Ab (Ordinary_Fixed_Point_Kind, Fixed_Point_Kind,\n+       (Sm (Has_Small_Clause, Flag)));\n+\n+   Cc (E_Ordinary_Fixed_Point_Type, Ordinary_Fixed_Point_Kind);\n+\n+   Cc (E_Ordinary_Fixed_Point_Subtype, Ordinary_Fixed_Point_Kind);\n+\n+   Ab (Decimal_Fixed_Point_Kind, Fixed_Point_Kind,\n+       (Sm (Digits_Value, Uint),\n+        Sm (Has_Machine_Radix_Clause, Flag),\n+        Sm (Machine_Radix_10, Flag),\n+        Sm (Scale_Value, Uint)));\n+\n+   Cc (E_Decimal_Fixed_Point_Type, Decimal_Fixed_Point_Kind);\n+\n+   Cc (E_Decimal_Fixed_Point_Subtype, Decimal_Fixed_Point_Kind);\n+\n+   Ab (Float_Kind, Real_Kind,\n+       (Sm (Digits_Value, Uint),\n+        Sm (Float_Rep, Float_Rep_Kind, Base_Type_Only)));\n+\n+   Cc (E_Floating_Point_Type, Float_Kind);\n+\n+   Cc (E_Floating_Point_Subtype, Float_Kind);\n+\n+   Ab (Access_Kind, Elementary_Kind,\n+       (Sm (Associated_Storage_Pool, Node_Id, Root_Type_Only),\n+        Sm (Directly_Designated_Type, Node_Id),\n+        Sm (Finalization_Master, Node_Id, Root_Type_Only),\n+        Sm (Has_Pragma_Controlled, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Storage_Size_Clause, Flag, Impl_Base_Type_Only),\n+        Sm (Is_Access_Constant, Flag),\n+        Sm (Is_Local_Anonymous_Access, Flag),\n+        Sm (Is_Param_Block_Component_Type, Flag, Base_Type_Only),\n+        Sm (Is_Pure_Unit_Access_Type, Flag),\n+        Sm (Master_Id, Node_Id),\n+        Sm (No_Pool_Assigned, Flag, Root_Type_Only),\n+        Sm (No_Strict_Aliasing, Flag, Base_Type_Only),\n+        Sm (Storage_Size_Variable, Node_Id, Impl_Base_Type_Only)));\n+\n+   Cc (E_Access_Type, Access_Kind,\n+       (Sm (Direct_Primitive_Operations, Elist_Id,\n+            Pre => \"Is_Tagged_Type (N)\")));\n+\n+   Cc (E_Access_Subtype, Access_Kind);\n+\n+   Cc (E_Access_Attribute_Type, Access_Kind);\n+\n+   Cc (E_Allocator_Type, Access_Kind);\n+\n+   Cc (E_General_Access_Type, Access_Kind,\n+       (Sm (First_Entity, Node_Id)));\n+\n+   Ab (Access_Subprogram_Kind, Access_Kind);\n+\n+   Cc (E_Access_Subprogram_Type, Access_Subprogram_Kind,\n+       (Sm (Equivalent_Type, Node_Id),\n+        Sm (Original_Access_Type, Node_Id)));\n+\n+   Ab (Access_Protected_Kind, Access_Subprogram_Kind,\n+       (Sm (Equivalent_Type, Node_Id)));\n+\n+   Cc (E_Access_Protected_Subprogram_Type, Access_Protected_Kind);\n+\n+   Cc (E_Anonymous_Access_Protected_Subprogram_Type, Access_Protected_Kind);\n+\n+   Cc (E_Anonymous_Access_Subprogram_Type, Access_Subprogram_Kind);\n+\n+   Cc (E_Anonymous_Access_Type, Access_Kind);\n+\n+   Ab (Composite_Kind, Type_Kind,\n+--  ????This fails for the same reason as DT_Position of E_Function;\n+--  see comment there.\n+--       (Sm (Discriminant_Constraint, Elist_Id,\n+--            Pre => \"Has_Discriminants (N) or else Is_Constrained (N)\")));\n+       (Sm (Discriminant_Constraint, Elist_Id)));\n+\n+   Ab (Aggregate_Kind, Composite_Kind,\n+       (Sm (Component_Alignment, Component_Alignment_Kind, Base_Type_Only),\n+        Sm (Has_Pragma_Pack, Flag, Impl_Base_Type_Only),\n+        Sm (Reverse_Storage_Order, Flag, Base_Type_Only),\n+        Sm (SSO_Set_High_By_Default, Flag, Base_Type_Only),\n+        Sm (SSO_Set_Low_By_Default, Flag, Base_Type_Only)));\n+\n+   Ab (Array_Kind, Aggregate_Kind,\n+       (Sm (Component_Size, Uint, Impl_Base_Type_Only),\n+        Sm (Component_Type, Node_Id, Impl_Base_Type_Only),\n+        Sm (Default_Aspect_Component_Value, Node_Id, Base_Type_Only),\n+        Sm (First_Index, Node_Id),\n+        Sm (Has_Component_Size_Clause, Flag, Impl_Base_Type_Only),\n+        Sm (Original_Array_Type, Node_Id),\n+        Sm (Packed_Array_Impl_Type, Node_Id),\n+        Sm (Related_Array_Object, Node_Id)));\n+\n+   Cc (E_Array_Type, Array_Kind,\n+       (Sm (First_Entity, Node_Id),\n+        Sm (Static_Real_Or_String_Predicate, Node_Id)));\n+\n+   Cc (E_Array_Subtype, Array_Kind,\n+       (Sm (Predicated_Parent, Node_Id),\n+        Sm (Direct_Primitive_Operations, Elist_Id,\n+            Pre => \"Is_Tagged_Type (N)\"),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Static_Real_Or_String_Predicate, Node_Id)));\n+\n+   Cc (E_String_Literal_Subtype, Array_Kind,\n+       (Sm (String_Literal_Length, Uint),\n+        Sm (String_Literal_Low_Bound, Node_Id)));\n+\n+   Ab (Class_Wide_Kind, Aggregate_Kind,\n+       (Sm (C_Pass_By_Copy, Flag, Impl_Base_Type_Only),\n+        Sm (Direct_Primitive_Operations, Elist_Id,\n+            Pre => \"Is_Tagged_Type (N)\"),\n+        Sm (Equivalent_Type, Node_Id),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Has_Complex_Representation, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Record_Rep_Clause, Flag, Impl_Base_Type_Only),\n+        Sm (Interfaces, Elist_Id),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (No_Reordering, Flag, Impl_Base_Type_Only),\n+        Sm (Non_Limited_View, Node_Id),\n+        Sm (Parent_Subtype, Node_Id, Base_Type_Only),\n+        Sm (Reverse_Bit_Order, Flag, Base_Type_Only),\n+        Sm (Stored_Constraint, Elist_Id)));\n+\n+   Cc (E_Class_Wide_Type, Class_Wide_Kind,\n+       (Sm (Corresponding_Remote_Type, Node_Id),\n+        Sm (Scalar_Range, Node_Id)));\n+\n+   Cc (E_Class_Wide_Subtype, Class_Wide_Kind,\n+       (Sm (Cloned_Subtype, Node_Id)));\n+\n+   Cc (E_Record_Type, Aggregate_Kind,\n+       (Sm (Access_Disp_Table, Elist_Id, Impl_Base_Type_Only),\n+        Sm (Access_Disp_Table_Elab_Flag, Node_Id, Impl_Base_Type_Only),\n+        Sm (C_Pass_By_Copy, Flag, Impl_Base_Type_Only),\n+        Sm (Corresponding_Concurrent_Type, Node_Id),\n+        Sm (Corresponding_Remote_Type, Node_Id),\n+        Sm (Direct_Primitive_Operations, Elist_Id,\n+            Pre => \"Is_Tagged_Type (N)\"),\n+        Sm (Dispatch_Table_Wrappers, Elist_Id, Impl_Base_Type_Only),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Has_Complex_Representation, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Record_Rep_Clause, Flag, Impl_Base_Type_Only),\n+        Sm (Interfaces, Elist_Id),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (No_Reordering, Flag, Impl_Base_Type_Only),\n+        Sm (Parent_Subtype, Node_Id, Base_Type_Only),\n+        Sm (Reverse_Bit_Order, Flag, Base_Type_Only),\n+        Sm (Stored_Constraint, Elist_Id),\n+        Sm (Underlying_Record_View, Node_Id)));\n+\n+   Cc (E_Record_Subtype, Aggregate_Kind,\n+       (Sm (Access_Disp_Table, Elist_Id, Impl_Base_Type_Only),\n+        Sm (Access_Disp_Table_Elab_Flag, Node_Id, Impl_Base_Type_Only),\n+        Sm (C_Pass_By_Copy, Flag, Impl_Base_Type_Only),\n+        Sm (Cloned_Subtype, Node_Id),\n+        Sm (Corresponding_Remote_Type, Node_Id),\n+        Sm (Predicated_Parent, Node_Id),\n+        Sm (Direct_Primitive_Operations, Elist_Id,\n+            Pre => \"Is_Tagged_Type (N)\"),\n+        Sm (Dispatch_Table_Wrappers, Elist_Id, Impl_Base_Type_Only),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Has_Complex_Representation, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Record_Rep_Clause, Flag, Impl_Base_Type_Only),\n+        Sm (Interfaces, Elist_Id),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (No_Reordering, Flag, Impl_Base_Type_Only),\n+        Sm (Parent_Subtype, Node_Id, Base_Type_Only),\n+        Sm (Reverse_Bit_Order, Flag, Base_Type_Only),\n+        Sm (Stored_Constraint, Elist_Id),\n+        Sm (Underlying_Record_View, Node_Id)));\n+\n+   Ab (Incomplete_Or_Private_Kind, Composite_Kind,\n+       (Sm (First_Entity, Node_Id),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Private_Dependents, Elist_Id),\n+        Sm (Stored_Constraint, Elist_Id)));\n+\n+   Ab (Private_Kind, Incomplete_Or_Private_Kind,\n+       (Sm (Underlying_Full_View, Node_Id)));\n+\n+   Cc (E_Record_Type_With_Private, Private_Kind,\n+       (Sm (Access_Disp_Table, Elist_Id, Impl_Base_Type_Only),\n+        Sm (Access_Disp_Table_Elab_Flag, Node_Id, Impl_Base_Type_Only),\n+        Sm (C_Pass_By_Copy, Flag, Impl_Base_Type_Only),\n+        Sm (Component_Alignment, Component_Alignment_Kind, Base_Type_Only),\n+        Sm (Corresponding_Remote_Type, Node_Id),\n+        Sm (Direct_Primitive_Operations, Elist_Id,\n+            Pre => \"Is_Tagged_Type (N)\"),\n+        Sm (Has_Complex_Representation, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Pragma_Pack, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Record_Rep_Clause, Flag, Impl_Base_Type_Only),\n+        Sm (Interfaces, Elist_Id),\n+        Sm (No_Reordering, Flag, Impl_Base_Type_Only),\n+        Sm (Parent_Subtype, Node_Id, Base_Type_Only),\n+        Sm (Reverse_Bit_Order, Flag, Base_Type_Only),\n+        Sm (Reverse_Storage_Order, Flag, Base_Type_Only),\n+        Sm (SSO_Set_High_By_Default, Flag, Base_Type_Only),\n+        Sm (SSO_Set_Low_By_Default, Flag, Base_Type_Only),\n+        Sm (Underlying_Record_View, Node_Id)));\n+\n+   Cc (E_Record_Subtype_With_Private, Private_Kind,\n+       (Sm (C_Pass_By_Copy, Flag, Impl_Base_Type_Only),\n+        Sm (Component_Alignment, Component_Alignment_Kind, Base_Type_Only),\n+        Sm (Corresponding_Remote_Type, Node_Id),\n+        Sm (Predicated_Parent, Node_Id),\n+        Sm (Direct_Primitive_Operations, Elist_Id,\n+            Pre => \"Is_Tagged_Type (N)\"),\n+        Sm (Has_Complex_Representation, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Pragma_Pack, Flag, Impl_Base_Type_Only),\n+        Sm (Has_Record_Rep_Clause, Flag, Impl_Base_Type_Only),\n+        Sm (Interfaces, Elist_Id),\n+        Sm (No_Reordering, Flag, Impl_Base_Type_Only),\n+        Sm (Parent_Subtype, Node_Id, Base_Type_Only),\n+        Sm (Reverse_Bit_Order, Flag, Base_Type_Only),\n+        Sm (Reverse_Storage_Order, Flag, Base_Type_Only),\n+        Sm (SSO_Set_High_By_Default, Flag, Base_Type_Only),\n+        Sm (SSO_Set_Low_By_Default, Flag, Base_Type_Only)));\n+\n+   Cc (E_Private_Type, Private_Kind,\n+       (Sm (Direct_Primitive_Operations, Elist_Id,\n+            Pre => \"Is_Tagged_Type (N)\"),\n+        Sm (Scalar_Range, Node_Id),\n+        Sm (Scope_Depth_Value, Uint),\n+        Sm (Directly_Designated_Type, Node_Id)));\n+   --  ????Directly_Designated_Type was allowed to be Set_, but not get.\n+   --  Same for E_Limited_Private_Type. And incomplete.\n+\n+   Cc (E_Private_Subtype, Private_Kind,\n+       (Sm (Direct_Primitive_Operations, Elist_Id,\n+            Pre => \"Is_Tagged_Type (N)\"),\n+        Sm (Scope_Depth_Value, Uint)));\n+\n+   Cc (E_Limited_Private_Type, Private_Kind,\n+       (Sm (Scalar_Range, Node_Id),\n+        Sm (Scope_Depth_Value, Uint),\n+        Sm (Directly_Designated_Type, Node_Id)));\n+\n+   Cc (E_Limited_Private_Subtype, Private_Kind,\n+       (Sm (Scope_Depth_Value, Uint)));\n+\n+   Ab (Incomplete_Kind, Incomplete_Or_Private_Kind,\n+       (Sm (Direct_Primitive_Operations, Elist_Id,\n+            Pre => \"Is_Tagged_Type (N)\"),\n+        Sm (Non_Limited_View, Node_Id),\n+        Sm (Directly_Designated_Type, Node_Id)));\n+\n+   Cc (E_Incomplete_Type, Incomplete_Kind,\n+       (Sm (Scalar_Range, Node_Id)));\n+\n+   Cc (E_Incomplete_Subtype, Incomplete_Kind);\n+\n+   Ab (Concurrent_Kind, Composite_Kind,\n+       (Sm (Corresponding_Record_Type, Node_Id),\n+        Sm (Direct_Primitive_Operations, Elist_Id,\n+            Pre => \"Is_Tagged_Type (N)\"),\n+        Sm (First_Entity, Node_Id),\n+        Sm (First_Private_Entity, Node_Id),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Scope_Depth_Value, Uint),\n+        Sm (Stored_Constraint, Elist_Id)));\n+\n+   Ab (Task_Kind, Concurrent_Kind,\n+       (Sm (Has_Storage_Size_Clause, Flag, Impl_Base_Type_Only),\n+        Sm (Is_Elaboration_Checks_OK_Id, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Id, Flag),\n+        Sm (Relative_Deadline_Variable, Node_Id, Impl_Base_Type_Only),\n+        Sm (Storage_Size_Variable, Node_Id, Impl_Base_Type_Only),\n+        Sm (Task_Body_Procedure, Node_Id)));\n+\n+   Cc (E_Task_Type, Task_Kind,\n+       (Sm (Anonymous_Object, Node_Id),\n+        Sm (Ignore_SPARK_Mode_Pragmas, Flag),\n+        Sm (SPARK_Aux_Pragma, Node_Id),\n+        Sm (SPARK_Aux_Pragma_Inherited, Flag)));\n+\n+   Cc (E_Task_Subtype, Task_Kind);\n+\n+   Ab (Protected_Kind, Concurrent_Kind,\n+       (Sm (Entry_Bodies_Array, Node_Id,\n+            Pre => \"Has_Entries (N)\"),\n+        Sm (Uses_Lock_Free, Flag)));\n+\n+   Cc (E_Protected_Type, Protected_Kind,\n+       (Sm (Anonymous_Object, Node_Id),\n+        Sm (Entry_Max_Queue_Lengths_Array, Node_Id),\n+        Sm (Ignore_SPARK_Mode_Pragmas, Flag),\n+        Sm (SPARK_Aux_Pragma, Node_Id),\n+        Sm (SPARK_Aux_Pragma_Inherited, Flag)));\n+\n+   Cc (E_Protected_Subtype, Protected_Kind);\n+\n+   Cc (E_Exception_Type, Type_Kind,\n+       (Sm (Equivalent_Type, Node_Id)));\n+\n+   Cc (E_Subprogram_Type, Type_Kind,\n+       (Sm (Access_Subprogram_Wrapper, Node_Id),\n+        Sm (Extra_Accessibility_Of_Result, Node_Id),\n+        Sm (Extra_Formals, Node_Id),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Needs_No_Actuals, Flag)));\n+\n+   Ab (Overloadable_Kind, Entity_Kind,\n+       (Sm (Renamed_Or_Alias, Node_Id),\n+        Sm (Extra_Formals, Node_Id),\n+        Sm (Is_Abstract_Subprogram, Flag),\n+        Sm (Is_Primitive, Flag),\n+        Sm (Needs_No_Actuals, Flag),\n+        Sm (Requires_Overriding, Flag)));\n+\n+   Cc (E_Enumeration_Literal, Overloadable_Kind,\n+       (Sm (Enumeration_Pos, Uint),\n+        Sm (Enumeration_Rep, Uint),\n+        Sm (Enumeration_Rep_Expr, Node_Id),\n+        Sm (Esize, Uint),\n+        Sm (Alignment, Uint),\n+        Sm (Interface_Name, Node_Id)));\n+\n+   Ab (Subprogram_Kind, Overloadable_Kind,\n+       (Sm (Body_Needed_For_SAL, Flag),\n+        Sm (Class_Wide_Clone, Node_Id),\n+        Sm (Contract, Node_Id),\n+        Sm (Elaboration_Entity, Node_Id),\n+        Sm (Elaboration_Entity_Required, Flag),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Has_Expanded_Contract, Flag),\n+        Sm (Has_Nested_Subprogram, Flag),\n+        Sm (Has_Out_Or_In_Out_Parameter, Flag),\n+        Sm (Has_Recursive_Call, Flag),\n+        Sm (Ignore_SPARK_Mode_Pragmas, Flag),\n+        Sm (Import_Pragma, Node_Id),\n+        Sm (Interface_Alias, Node_Id),\n+        Sm (Interface_Name, Node_Id),\n+        Sm (Is_Elaboration_Checks_OK_Id, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Id, Flag),\n+        Sm (Is_Machine_Code_Subprogram, Flag),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Linker_Section_Pragma, Node_Id),\n+        Sm (Overridden_Operation, Node_Id),\n+        Sm (Protected_Body_Subprogram, Node_Id),\n+        Sm (Scope_Depth_Value, Uint),\n+        Sm (SPARK_Pragma, Node_Id),\n+        Sm (SPARK_Pragma_Inherited, Flag),\n+        Sm (Subps_Index, Uint)));\n+\n+   Cc (E_Function, Subprogram_Kind,\n+       (Sm (Anonymous_Masters, Elist_Id),\n+        Sm (Corresponding_Equality, Node_Id,\n+            Pre => \"not Comes_From_Source (N) and then Chars (N) = Name_Op_Ne\"),\n+        Sm (Corresponding_Procedure, Node_Id),\n+--  ????In the old version, we had the following assertion in the getter, but\n+--  not the setter, and in fact we sometimes violate it in the setter, for\n+--  example, sem_disp.adb:1635 says \"Set_DT_Position_Value (Subp, No_Uint);\".\n+--        Sm (DT_Position, Uint,\n+--            Pre => \"Present (DTC_Entity (N))\"),\n+--  Perhaps we should have \"getter-only preconditions\".\n+        Sm (DT_Position, Uint),\n+        Sm (DTC_Entity, Node_Id),\n+        Sm (Extra_Accessibility_Of_Result, Node_Id),\n+        Sm (Generic_Renamings, Elist_Id),\n+        Sm (Handler_Records, List_Id),\n+        Sm (Has_Missing_Return, Flag),\n+        Sm (Inner_Instances, Elist_Id),\n+        Sm (Is_Called, Flag),\n+        Sm (Is_CUDA_Kernel, Flag),\n+        Sm (Is_DIC_Procedure, Flag),\n+        Sm (Is_Generic_Actual_Subprogram, Flag),\n+        Sm (Is_Initial_Condition_Procedure, Flag),\n+        Sm (Is_Inlined_Always, Flag),\n+        Sm (Is_Invariant_Procedure, Flag),\n+        Sm (Is_Partial_Invariant_Procedure, Flag),\n+        Sm (Is_Predicate_Function, Flag),\n+        Sm (Is_Predicate_Function_M, Flag),\n+        Sm (Is_Primitive_Wrapper, Flag),\n+        Sm (Is_Private_Primitive, Flag),\n+        Sm (Mechanism, Mechanism_Type),\n+        Sm (Next_Inlined_Subprogram, Node_Id),\n+        Sm (Original_Protected_Subprogram, Node_Id),\n+        Sm (Postconditions_Proc, Node_Id),\n+        Sm (Protected_Subprogram, Node_Id),\n+        Sm (Protection_Object, Node_Id),\n+        Sm (Related_Expression, Node_Id),\n+        Sm (Renaming_Map, Uint),\n+        Sm (Rewritten_For_C, Flag),\n+        Sm (Thunk_Entity, Node_Id,\n+            Pre => \"Is_Thunk (N)\"),\n+        Sm (Wrapped_Entity, Node_Id,\n+            Pre => \"Is_Primitive_Wrapper (N)\")));\n+\n+   Cc (E_Operator, Subprogram_Kind,\n+       (Sm (Extra_Accessibility_Of_Result, Node_Id)));\n+\n+   Cc (E_Procedure, Subprogram_Kind,\n+       (Sm (Anonymous_Masters, Elist_Id),\n+        Sm (Associated_Node_For_Itype, Node_Id),\n+        Sm (Corresponding_Function, Node_Id),\n+--  ????See comment in E_Function.\n+--        Sm (DT_Position, Uint,\n+--            Pre => \"Present (DTC_Entity (N))\"),\n+        Sm (DT_Position, Uint),\n+        Sm (DTC_Entity, Node_Id),\n+        Sm (Entry_Parameters_Type, Node_Id),\n+        Sm (Generic_Renamings, Elist_Id),\n+        Sm (Handler_Records, List_Id),\n+        Sm (Inner_Instances, Elist_Id),\n+        Sm (Is_Asynchronous, Flag),\n+        Sm (Is_Called, Flag),\n+        Sm (Is_CUDA_Kernel, Flag),\n+        Sm (Is_DIC_Procedure, Flag),\n+        Sm (Is_Generic_Actual_Subprogram, Flag),\n+        Sm (Is_Initial_Condition_Procedure, Flag),\n+        Sm (Is_Inlined_Always, Flag),\n+        Sm (Is_Invariant_Procedure, Flag),\n+        Sm (Is_Null_Init_Proc, Flag),\n+        Sm (Is_Partial_Invariant_Procedure, Flag),\n+        Sm (Is_Predicate_Function, Flag),\n+        Sm (Is_Predicate_Function_M, Flag),\n+        Sm (Is_Primitive_Wrapper, Flag),\n+        Sm (Is_Private_Primitive, Flag),\n+        Sm (Is_Valued_Procedure, Flag),\n+        Sm (Next_Inlined_Subprogram, Node_Id),\n+        Sm (Original_Protected_Subprogram, Node_Id),\n+        Sm (Postconditions_Proc, Node_Id),\n+        Sm (Protected_Subprogram, Node_Id),\n+        Sm (Protection_Object, Node_Id),\n+        Sm (Receiving_Entry, Node_Id),\n+        Sm (Renaming_Map, Uint),\n+        Sm (Static_Initialization, Node_Id,\n+            Pre => \"not Is_Dispatching_Operation (N)\"),\n+        Sm (Thunk_Entity, Node_Id,\n+            Pre => \"Is_Thunk (N)\"),\n+        Sm (Wrapped_Entity, Node_Id,\n+            Pre => \"Is_Primitive_Wrapper (N)\")));\n+\n+   Cc (E_Abstract_State, Overloadable_Kind,\n+       (Sm (Body_References, Elist_Id),\n+        Sm (Encapsulating_State, Node_Id),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Has_Partial_Visible_Refinement, Flag),\n+        Sm (Has_Visible_Refinement, Flag),\n+        Sm (Non_Limited_View, Node_Id),\n+        Sm (Part_Of_Constituents, Elist_Id),\n+        Sm (Refinement_Constituents, Elist_Id),\n+        Sm (SPARK_Pragma, Node_Id),\n+        Sm (SPARK_Pragma_Inherited, Flag)));\n+\n+   Cc (E_Entry, Overloadable_Kind,\n+       (Sm (Accept_Address, Elist_Id),\n+        Sm (Barrier_Function, Node_Id),\n+        Sm (Contract, Node_Id),\n+        Sm (Contract_Wrapper, Node_Id),\n+        Sm (Elaboration_Entity, Node_Id),\n+        Sm (Elaboration_Entity_Required, Flag),\n+        Sm (Entry_Accepted, Flag),\n+        Sm (Entry_Parameters_Type, Node_Id),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Has_Out_Or_In_Out_Parameter, Flag),\n+        Sm (Ignore_SPARK_Mode_Pragmas, Flag),\n+        Sm (Is_Elaboration_Checks_OK_Id, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Id, Flag),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Postconditions_Proc, Node_Id),\n+        Sm (Protected_Body_Subprogram, Node_Id),\n+        Sm (Protection_Object, Node_Id),\n+        Sm (Scope_Depth_Value, Uint),\n+        Sm (SPARK_Pragma, Node_Id),\n+        Sm (SPARK_Pragma_Inherited, Flag)));\n+\n+   Cc (E_Entry_Family, Entity_Kind,\n+       (Sm (Accept_Address, Elist_Id),\n+        Sm (Barrier_Function, Node_Id),\n+        Sm (Contract, Node_Id),\n+        Sm (Contract_Wrapper, Node_Id),\n+        Sm (Elaboration_Entity, Node_Id),\n+        Sm (Elaboration_Entity_Required, Flag),\n+        Sm (Entry_Accepted, Flag),\n+        Sm (Entry_Parameters_Type, Node_Id),\n+        Sm (Extra_Formals, Node_Id),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Has_Out_Or_In_Out_Parameter, Flag),\n+        Sm (Ignore_SPARK_Mode_Pragmas, Flag),\n+        Sm (Is_Elaboration_Checks_OK_Id, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Id, Flag),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Needs_No_Actuals, Flag),\n+        Sm (Postconditions_Proc, Node_Id),\n+        Sm (Protected_Body_Subprogram, Node_Id),\n+        Sm (Protection_Object, Node_Id),\n+        Sm (Renamed_Or_Alias, Node_Id),\n+        Sm (Scope_Depth_Value, Uint),\n+        Sm (SPARK_Pragma, Node_Id),\n+        Sm (SPARK_Pragma_Inherited, Flag)));\n+\n+   Cc (E_Block, Entity_Kind,\n+       (Sm (Block_Node, Node_Id),\n+        Sm (Entry_Cancel_Parameter, Node_Id),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Is_Exception_Handler, Flag),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Renamed_Or_Alias, Node_Id),\n+        Sm (Return_Applies_To, Node_Id),\n+        Sm (Scope_Depth_Value, Uint)));\n+\n+   Cc (E_Entry_Index_Parameter, Entity_Kind,\n+       (Sm (Entry_Index_Constant, Node_Id)));\n+\n+   Cc (E_Exception, Entity_Kind,\n+       (Sm (Alignment, Uint),\n+        Sm (Esize, Uint),\n+        Sm (Interface_Name, Node_Id),\n+        Sm (Is_Raised, Flag),\n+        Sm (Register_Exception_Call, Node_Id),\n+        Sm (Renamed_Or_Alias, Node_Id)));\n+\n+   Ab (Generic_Unit_Kind, Entity_Kind,\n+       (Sm (Body_Needed_For_SAL, Flag),\n+        Sm (Contract, Node_Id),\n+        Sm (Elaboration_Entity, Node_Id),\n+        Sm (Elaboration_Entity_Required, Flag),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Ignore_SPARK_Mode_Pragmas, Flag),\n+        Sm (Inner_Instances, Elist_Id),\n+        Sm (Interface_Name, Node_Id),\n+        Sm (Is_Elaboration_Checks_OK_Id, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Id, Flag),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Renamed_Or_Alias, Node_Id),\n+        Sm (Renaming_Map, Uint),\n+        Sm (Scope_Depth_Value, Uint),\n+        Sm (SPARK_Pragma, Node_Id),\n+        Sm (SPARK_Pragma_Inherited, Flag)));\n+\n+   Ab (Generic_Subprogram_Kind, Generic_Unit_Kind,\n+       (Sm (Has_Out_Or_In_Out_Parameter, Flag),\n+        Sm (Is_Primitive, Flag),\n+        Sm (Next_Inlined_Subprogram, Node_Id),\n+        Sm (Overridden_Operation, Node_Id)));\n+\n+   Cc (E_Generic_Function, Generic_Subprogram_Kind,\n+       (Sm (Has_Missing_Return, Flag)));\n+\n+   Cc (E_Generic_Procedure, Generic_Subprogram_Kind);\n+\n+   Cc (E_Generic_Package, Generic_Unit_Kind,\n+       (Sm (Abstract_States, Elist_Id),\n+        Sm (Body_Entity, Node_Id),\n+        Sm (First_Private_Entity, Node_Id),\n+        Sm (Generic_Homonym, Node_Id),\n+        Sm (Package_Instantiation, Node_Id),\n+        Sm (SPARK_Aux_Pragma, Node_Id),\n+        Sm (SPARK_Aux_Pragma_Inherited, Flag)));\n+\n+   Cc (E_Label, Entity_Kind,\n+       (Sm (Enclosing_Scope, Node_Id),\n+        Sm (Renamed_Or_Alias, Node_Id)));\n+\n+   Cc (E_Loop, Entity_Kind,\n+       (Sm (First_Entity, Node_Id),\n+        Sm (First_Exit_Statement, Node_Id),\n+        Sm (Has_Loop_Entry_Attributes, Flag),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Renamed_Or_Alias, Node_Id),\n+        Sm (Scope_Depth_Value, Uint)));\n+\n+   Cc (E_Return_Statement, Entity_Kind,\n+       (Sm (First_Entity, Node_Id),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Return_Applies_To, Node_Id),\n+        Sm (Scope_Depth_Value, Uint)));\n+\n+   Cc (E_Package, Entity_Kind,\n+       (Sm (Abstract_States, Elist_Id),\n+        Sm (Anonymous_Masters, Elist_Id),\n+        Sm (Associated_Formal_Package, Node_Id),\n+        Sm (Body_Entity, Node_Id),\n+        Sm (Body_Needed_For_Inlining, Flag),\n+        Sm (Body_Needed_For_SAL, Flag),\n+        Sm (Contract, Node_Id),\n+        Sm (Current_Use_Clause, Node_Id),\n+        Sm (Dependent_Instances, Elist_Id,\n+            Pre => \"Is_Generic_Instance (N)\"),\n+        Sm (Elaborate_Body_Desirable, Flag),\n+        Sm (Elaboration_Entity, Node_Id),\n+        Sm (Elaboration_Entity_Required, Flag),\n+        Sm (Finalizer, Node_Id),\n+        Sm (First_Entity, Node_Id),\n+        Sm (First_Private_Entity, Node_Id),\n+        Sm (Generic_Renamings, Elist_Id),\n+        Sm (Handler_Records, List_Id),\n+        Sm (Has_RACW, Flag),\n+        Sm (Hidden_In_Formal_Instance, Elist_Id),\n+        Sm (Ignore_SPARK_Mode_Pragmas, Flag),\n+        Sm (Incomplete_Actuals, Elist_Id),\n+        Sm (Inner_Instances, Elist_Id),\n+        Sm (Interface_Name, Node_Id),\n+        Sm (Is_Called, Flag),\n+        Sm (Is_Elaboration_Checks_OK_Id, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Id, Flag),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Limited_View, Node_Id),\n+        Sm (Package_Instantiation, Node_Id),\n+        Sm (Related_Instance, Node_Id),\n+        Sm (Renamed_In_Spec, Flag),\n+        Sm (Renamed_Or_Alias, Node_Id),\n+        Sm (Renaming_Map, Uint),\n+        Sm (Scope_Depth_Value, Uint),\n+        Sm (SPARK_Aux_Pragma, Node_Id),\n+        Sm (SPARK_Aux_Pragma_Inherited, Flag),\n+        Sm (SPARK_Pragma, Node_Id),\n+        Sm (SPARK_Pragma_Inherited, Flag),\n+        Sm (Static_Elaboration_Desired, Flag)));\n+\n+   Cc (E_Package_Body, Entity_Kind,\n+       (Sm (Contract, Node_Id),\n+        Sm (Finalizer, Node_Id),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Handler_Records, List_Id),\n+        Sm (Ignore_SPARK_Mode_Pragmas, Flag),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Related_Instance, Node_Id),\n+        Sm (Renamed_Or_Alias, Node_Id),\n+        Sm (Scope_Depth_Value, Uint),\n+        Sm (SPARK_Aux_Pragma, Node_Id),\n+        Sm (SPARK_Aux_Pragma_Inherited, Flag),\n+        Sm (SPARK_Pragma, Node_Id),\n+        Sm (SPARK_Pragma_Inherited, Flag),\n+        Sm (Spec_Entity, Node_Id)));\n+\n+   Ab (Concurrent_Body_Kind, Entity_Kind,\n+       (Sm (Ignore_SPARK_Mode_Pragmas, Flag),\n+        Sm (SPARK_Pragma, Node_Id),\n+        Sm (SPARK_Pragma_Inherited, Flag)));\n+\n+   Cc (E_Protected_Body, Concurrent_Body_Kind);\n+\n+   Cc (E_Task_Body, Concurrent_Body_Kind,\n+       (Sm (Contract, Node_Id),\n+        Sm (First_Entity, Node_Id)));\n+\n+   Cc (E_Subprogram_Body, Entity_Kind,\n+       (Sm (Anonymous_Masters, Elist_Id),\n+        Sm (Contract, Node_Id),\n+        Sm (Corresponding_Protected_Entry, Node_Id),\n+        Sm (Extra_Formals, Node_Id),\n+        Sm (First_Entity, Node_Id),\n+        Sm (Ignore_SPARK_Mode_Pragmas, Flag),\n+        Sm (Interface_Name, Node_Id),\n+        Sm (Last_Entity, Node_Id),\n+        Sm (Renamed_Or_Alias, Node_Id),\n+        Sm (Scope_Depth_Value, Uint),\n+        Sm (SPARK_Pragma, Node_Id),\n+        Sm (SPARK_Pragma_Inherited, Flag)));\n+\n+   --  Union types. These don't fit into the normal parent/child hierarchy\n+   --  above.\n+\n+   Union (Anonymous_Access_Kind,\n+          Children =>\n+            (E_Anonymous_Access_Protected_Subprogram_Type,\n+             E_Anonymous_Access_Subprogram_Type,\n+             E_Anonymous_Access_Type));\n+\n+   Union (Assignable_Kind,\n+          Children =>\n+            (E_Variable,\n+             E_Out_Parameter,\n+             E_In_Out_Parameter));\n+\n+   Union (Digits_Kind,\n+          Children =>\n+            (Decimal_Fixed_Point_Kind,\n+             Float_Kind));\n+\n+   Union (Discrete_Or_Fixed_Point_Kind,\n+          Children =>\n+            (Discrete_Kind,\n+             Fixed_Point_Kind));\n+\n+   Union (Entry_Kind,\n+          Children =>\n+            (E_Entry,\n+             E_Entry_Family));\n+\n+   Union (Numeric_Kind,\n+          Children =>\n+            (Integer_Kind,\n+             Fixed_Point_Kind,\n+             Float_Kind));\n+\n+   Union (Record_Kind,\n+          Children =>\n+            (E_Class_Wide_Type,\n+             E_Class_Wide_Subtype,\n+             E_Record_Type,\n+             E_Record_Subtype,\n+             E_Record_Type_With_Private,\n+             E_Record_Subtype_With_Private));\n+\n+end Gen_IL.Gen.Gen_Entities;"}, {"sha": "24c63dd4f22ff2572bd33e6d94045a6210ed3c0b", "filename": "gcc/ada/gen_il-gen-gen_nodes.adb", "status": "added", "additions": 1616, "deletions": 0, "changes": 1616, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,1616 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                  G E N _ I L . G E N . G E N _ N O D E S                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--           Copyright (C) 2020-2021, Free Software Foundation, Inc.        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+procedure Gen_IL.Gen.Gen_Nodes is\n+\n+   procedure Ab -- Short for \"Abstract\"\n+     (T : Abstract_Node; Parent : Abstract_Type;\n+      Fields : Field_Sequence := No_Fields)\n+      renames Create_Abstract_Node_Type;\n+   procedure Cc -- Short for \"ConCrete\"\n+     (T : Concrete_Node; Parent : Abstract_Type;\n+      Fields : Field_Sequence := No_Fields)\n+      renames Create_Concrete_Node_Type;\n+\n+   function Sy -- Short for \"Syntactic\"\n+     (Field : Node_Field; Field_Type : Type_Enum;\n+      Default_Value : Field_Default_Value := No_Default;\n+      Pre : String := \"\") return Field_Desc\n+      renames Create_Syntactic_Field;\n+   function Sm -- Short for \"Semantic\"\n+     (Field : Field_Enum; Field_Type : Type_Enum;\n+      Type_Only  : Type_Only_Enum := No_Type_Only;\n+      Pre : String := \"\") return Field_Desc\n+      renames Create_Semantic_Field;\n+\n+   procedure Union (T : Abstract_Node; Children : Type_Array)\n+     renames Create_Node_Union;\n+\n+begin -- Gen_IL.Gen.Gen_Nodes\n+   pragma Style_Checks (\"M200\");\n+\n+   --  N_Empty should not inherit all of these fields????\n+   --  But the following getters and setters are called on Empty:\n+   --\n+   --  Set_Comes_From_Source\n+   --  Set_Sloc\n+   --\n+   --  Comes_From_Source\n+   --  Error_Posted\n+   --  In_List\n+   --  Link\n+   --  Rewrite_Ins\n+   --  Sloc\n+   --  Small_Paren_Count\n+   Create_Root_Node_Type (Node_Kind,\n+       (Sm (Nkind, Nkind_Type),\n+        Sm (Sloc, Source_Ptr),\n+        Sm (In_List, Flag),\n+        Sm (Rewrite_Ins, Flag),\n+        Sm (Comes_From_Source, Flag),\n+        Sm (Analyzed, Flag),\n+        Sm (Error_Posted, Flag),\n+        Sm (Small_Paren_Count, Small_Paren_Count_Type),\n+        Sm (Check_Actuals, Flag),\n+        Sm (Has_Aspects, Flag),\n+        Sm (Is_Ignored_Ghost_Node, Flag),\n+        Sm (Link, Union_Id)));\n+\n+   Cc (N_Unused_At_Start, Node_Kind);\n+\n+   Ab (N_Representation_Clause, Node_Kind);\n+\n+   Cc (N_At_Clause, N_Representation_Clause,\n+       (Sy (Identifier, Node_Id, Default_Empty),\n+        Sy (Expression, Node_Id, Default_Empty)));\n+\n+   Cc (N_Component_Clause, N_Representation_Clause,\n+       (Sy (Component_Name, Node_Id),\n+        Sy (Position, Node_Id),\n+        Sy (First_Bit, Node_Id),\n+        Sy (Last_Bit, Node_Id)));\n+\n+   Cc (N_Enumeration_Representation_Clause, N_Representation_Clause,\n+       (Sy (Identifier, Node_Id, Default_Empty),\n+        Sy (Array_Aggregate, Node_Id),\n+        Sm (Next_Rep_Item, Node_Id)));\n+\n+   Cc (N_Mod_Clause, N_Representation_Clause,\n+       (Sy (Expression, Node_Id, Default_Empty),\n+        Sy (Pragmas_Before, List_Id, Default_No_List)));\n+\n+   Cc (N_Record_Representation_Clause, N_Representation_Clause,\n+       (Sy (Identifier, Node_Id, Default_Empty),\n+        Sy (Mod_Clause, Node_Id, Default_Empty),\n+        Sy (Component_Clauses, List_Id),\n+        Sm (Next_Rep_Item, Node_Id)));\n+\n+   Cc (N_Attribute_Definition_Clause, N_Representation_Clause,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Chars, Name_Id, Default_No_Name),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (Address_Warning_Posted, Flag),\n+        Sm (Check_Address_Alignment, Flag),\n+        Sm (Entity_Or_Associated_Node, Node_Id), -- just Entity\n+        Sm (From_Aspect_Specification, Flag),\n+        Sm (From_At_Mod, Flag),\n+        Sm (Is_Delayed_Aspect, Flag),\n+        Sm (Next_Rep_Item, Node_Id)));\n+\n+   Cc (N_Empty, Node_Kind,\n+       (Sy (Chars, Name_Id, Default_No_Name)));\n+\n+   Cc (N_Pragma_Argument_Association, Node_Kind,\n+       (Sy (Chars, Name_Id, Default_No_Name),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (Expression_Copy, Node_Id)));\n+\n+   Ab (N_Has_Etype, Node_Kind,\n+       (Sm (Etype, Node_Id)));\n+\n+   Cc (N_Error, N_Has_Etype,\n+       (Sy (Chars, Name_Id, Default_No_Name)));\n+\n+   Ab (N_Entity, N_Has_Etype,\n+       (Sm (Next_Entity, Node_Id),\n+        Sm (Scope, Node_Id)));\n+\n+   Cc (N_Defining_Character_Literal, N_Entity,\n+       (Sy (Chars, Name_Id, Default_No_Name)));\n+\n+   Cc (N_Defining_Identifier, N_Entity,\n+       (Sy (Chars, Name_Id, Default_No_Name)));\n+\n+   Cc (N_Defining_Operator_Symbol, N_Entity,\n+       (Sy (Chars, Name_Id, Default_No_Name)));\n+\n+   Ab (N_Subexpr, N_Has_Etype,\n+       (Sm (Assignment_OK, Flag),\n+        Sm (Do_Range_Check, Flag),\n+        Sm (Has_Dynamic_Length_Check, Flag),\n+        Sm (Is_Controlling_Actual, Flag),\n+        Sm (Is_Overloaded, Flag),\n+        Sm (Is_Static_Expression, Flag),\n+        Sm (Must_Not_Freeze, Flag),\n+        Sm (Raises_Constraint_Error, Flag)));\n+\n+   Ab (N_Has_Entity, N_Subexpr,\n+       (Sm (Entity_Or_Associated_Node, Node_Id))); -- both\n+\n+   Cc (N_Expanded_Name, N_Has_Entity,\n+       (Sy (Chars, Name_Id, Default_No_Name),\n+        Sy (Prefix, Node_Id),\n+        Sy (Selector_Name, Node_Id, Default_Empty),\n+        Sm (Atomic_Sync_Required, Flag),\n+        Sm (Has_Private_View, Flag),\n+        Sm (Is_Elaboration_Checks_OK_Node, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Node, Flag),\n+        Sm (Is_SPARK_Mode_On_Node, Flag),\n+        Sm (Redundant_Use, Flag)));\n+\n+   Ab (N_Direct_Name, N_Has_Entity,\n+       (Sm (Has_Private_View, Flag)));\n+\n+   Cc (N_Identifier, N_Direct_Name,\n+       (Sy (Chars, Name_Id, Default_No_Name),\n+        Sm (Atomic_Sync_Required, Flag),\n+        Sm (Is_Elaboration_Checks_OK_Node, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Node, Flag),\n+        Sm (Is_SPARK_Mode_On_Node, Flag),\n+        Sm (Original_Discriminant, Node_Id),\n+        Sm (Redundant_Use, Flag)));\n+\n+   Cc (N_Operator_Symbol, N_Direct_Name,\n+       (Sy (Chars, Name_Id, Default_No_Name),\n+        Sy (Strval, String_Id)));\n+\n+   Cc (N_Character_Literal, N_Direct_Name,\n+       (Sy (Chars, Name_Id, Default_No_Name),\n+        Sy (Char_Literal_Value, Uint)));\n+\n+   Ab (N_Op, N_Has_Entity,\n+       (Sm (Do_Overflow_Check, Flag),\n+        Sm (Has_Private_View, Flag)));\n+\n+   Ab (N_Binary_Op, N_Op);\n+\n+   Cc (N_Op_Add, N_Binary_Op,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Concat, N_Binary_Op,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id),\n+        Sm (Is_Component_Left_Opnd, Flag),\n+        Sm (Is_Component_Right_Opnd, Flag)));\n+\n+   Cc (N_Op_Expon, N_Binary_Op,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id),\n+        Sm (Is_Power_Of_2_For_Shift, Flag)));\n+\n+   Cc (N_Op_Subtract, N_Binary_Op,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Ab (N_Multiplying_Operator, N_Binary_Op);\n+\n+   Cc (N_Op_Divide, N_Multiplying_Operator,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id),\n+        Sm (Do_Division_Check, Flag),\n+        Sm (Rounded_Result, Flag)));\n+\n+   Cc (N_Op_Mod, N_Multiplying_Operator,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id),\n+        Sm (Do_Division_Check, Flag)));\n+\n+   Cc (N_Op_Multiply, N_Multiplying_Operator,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id),\n+        Sm (Rounded_Result, Flag)));\n+\n+   Cc (N_Op_Rem, N_Multiplying_Operator,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id),\n+        Sm (Do_Division_Check, Flag)));\n+\n+   Ab (N_Op_Boolean, N_Binary_Op);\n+\n+   Cc (N_Op_And, N_Op_Boolean,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id),\n+        Sm (Do_Length_Check, Flag)));\n+\n+   Ab (N_Op_Compare, N_Op_Boolean);\n+\n+   Cc (N_Op_Eq, N_Op_Compare,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Ge, N_Op_Compare,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Gt, N_Op_Compare,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Le, N_Op_Compare,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Lt, N_Op_Compare,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Ne, N_Op_Compare,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Or, N_Op_Boolean,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id),\n+        Sm (Do_Length_Check, Flag)));\n+\n+   Cc (N_Op_Xor, N_Op_Boolean,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id),\n+        Sm (Do_Length_Check, Flag)));\n+\n+   Ab (N_Op_Shift, N_Binary_Op,\n+       (Sm (Shift_Count_OK, Flag)));\n+\n+   Cc (N_Op_Rotate_Left, N_Op_Shift,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Rotate_Right, N_Op_Shift,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Shift_Left, N_Op_Shift,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Shift_Right, N_Op_Shift,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Shift_Right_Arithmetic, N_Op_Shift,\n+       (Sm (Chars, Name_Id),\n+        Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Ab (N_Unary_Op, N_Op);\n+\n+   Cc (N_Op_Abs, N_Unary_Op,\n+       (Sm (Chars, Name_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Minus, N_Unary_Op,\n+       (Sm (Chars, Name_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Not, N_Unary_Op,\n+       (Sm (Chars, Name_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Op_Plus, N_Unary_Op,\n+       (Sm (Chars, Name_Id),\n+        Sy (Right_Opnd, Node_Id)));\n+\n+   Cc (N_Attribute_Reference, N_Has_Entity,\n+       (Sy (Prefix, Node_Id),\n+        Sy (Attribute_Name, Name_Id),\n+        Sy (Expressions, List_Id, Default_No_List),\n+        Sm (Do_Overflow_Check, Flag),\n+        Sm (Header_Size_Added, Flag),\n+        Sm (Is_Elaboration_Checks_OK_Node, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Node, Flag),\n+        Sm (Is_SPARK_Mode_On_Node, Flag),\n+        Sm (Must_Be_Byte_Aligned, Flag),\n+        Sm (Redundant_Use, Flag)));\n+\n+   Ab (N_Membership_Test, N_Subexpr);\n+\n+   Cc (N_In, N_Membership_Test,\n+       (Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id),\n+        Sy (Alternatives, List_Id, Default_No_List),\n+        Sy (No_Minimize_Eliminate, Flag)));\n+\n+   Cc (N_Not_In, N_Membership_Test,\n+       (Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id),\n+        Sy (Alternatives, List_Id, Default_No_List),\n+        Sy (No_Minimize_Eliminate, Flag)));\n+\n+   Ab (N_Short_Circuit, N_Subexpr);\n+\n+   Cc (N_And_Then, N_Short_Circuit,\n+       (Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id),\n+        Sm (Actions, List_Id)));\n+\n+   Cc (N_Or_Else, N_Short_Circuit,\n+       (Sy (Left_Opnd, Node_Id),\n+        Sy (Right_Opnd, Node_Id),\n+        Sm (Actions, List_Id)));\n+\n+   Ab (N_Subprogram_Call, N_Subexpr,\n+       (Sm (Controlling_Argument, Node_Id),\n+        Sm (Do_Tag_Check, Flag),\n+        Sm (First_Named_Actual, Node_Id),\n+        Sm (Is_Elaboration_Checks_OK_Node, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Node, Flag),\n+        Sm (Is_Known_Guaranteed_ABE, Flag),\n+        Sm (Is_SPARK_Mode_On_Node, Flag),\n+        Sm (No_Elaboration_Check, Flag)));\n+\n+   Cc (N_Function_Call, N_Subprogram_Call,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Parameter_Associations, List_Id, Default_No_List),\n+        Sm (Is_Expanded_Build_In_Place_Call, Flag),\n+        Sm (No_Side_Effect_Removal, Flag)));\n+\n+   Cc (N_Procedure_Call_Statement, N_Subprogram_Call,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Parameter_Associations, List_Id, Default_No_List)));\n+\n+   Ab (N_Raise_xxx_Error, N_Subexpr);\n+\n+   Cc (N_Raise_Constraint_Error, N_Raise_xxx_Error,\n+       (Sy (Condition, Node_Id, Default_Empty),\n+        Sy (Reason, Uint)));\n+\n+   Cc (N_Raise_Program_Error, N_Raise_xxx_Error,\n+       (Sy (Condition, Node_Id, Default_Empty),\n+        Sy (Reason, Uint)));\n+\n+   Cc (N_Raise_Storage_Error, N_Raise_xxx_Error,\n+       (Sy (Condition, Node_Id, Default_Empty),\n+        Sy (Reason, Uint)));\n+\n+   Ab (N_Numeric_Or_String_Literal, N_Subexpr);\n+\n+   Cc (N_Integer_Literal, N_Numeric_Or_String_Literal,\n+       (Sy (Intval, Uint),\n+        Sm (Original_Entity, Node_Id),\n+        Sm (Print_In_Hex, Flag)));\n+\n+   Cc (N_Real_Literal, N_Numeric_Or_String_Literal,\n+       (Sy (Realval, Ureal),\n+        Sm (Corresponding_Integer_Value, Uint),\n+        Sm (Is_Machine_Number, Flag),\n+        Sm (Original_Entity, Node_Id)));\n+\n+   Cc (N_String_Literal, N_Numeric_Or_String_Literal,\n+       (Sy (Strval, String_Id),\n+        Sy (Is_Folded_In_Parser, Flag),\n+        Sm (Has_Wide_Character, Flag),\n+        Sm (Has_Wide_Wide_Character, Flag)));\n+\n+   Cc (N_Explicit_Dereference, N_Subexpr,\n+       (Sy (Prefix, Node_Id),\n+        Sm (Actual_Designated_Subtype, Node_Id),\n+        Sm (Atomic_Sync_Required, Flag),\n+        Sm (Has_Dereference_Action, Flag)));\n+\n+   Cc (N_Expression_With_Actions, N_Subexpr,\n+       (Sy (Actions, List_Id, Default_No_List),\n+        Sy (Expression, Node_Id, Default_Empty)));\n+\n+   Cc (N_If_Expression, N_Subexpr,\n+       (Sy (Expressions, List_Id, Default_No_List),\n+        Sy (Is_Elsif, Flag),\n+        Sm (Do_Overflow_Check, Flag),\n+        Sm (Else_Actions, List_Id),\n+        Sm (Then_Actions, List_Id)));\n+\n+   Cc (N_Indexed_Component, N_Subexpr,\n+       (Sy (Prefix, Node_Id),\n+        Sy (Expressions, List_Id, Default_No_List),\n+        Sm (Atomic_Sync_Required, Flag),\n+        Sm (Generalized_Indexing, Node_Id)));\n+\n+   Cc (N_Null, N_Subexpr);\n+\n+   Cc (N_Qualified_Expression, N_Subexpr,\n+       (Sy (Subtype_Mark, Node_Id, Default_Empty),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (Is_Qualified_Universal_Literal, Flag)));\n+\n+   Cc (N_Quantified_Expression, N_Subexpr,\n+       (Sy (Iterator_Specification, Node_Id, Default_Empty),\n+        Sy (Loop_Parameter_Specification, Node_Id, Default_Empty),\n+        Sy (Condition, Node_Id, Default_Empty),\n+        Sy (All_Present, Flag)));\n+\n+   Cc (N_Aggregate, N_Subexpr,\n+       (Sy (Expressions, List_Id, Default_No_List),\n+        Sy (Component_Associations, List_Id, Default_No_List),\n+        Sy (Null_Record_Present, Flag),\n+        Sy (Is_Homogeneous_Aggregate, Flag),\n+        Sm (Aggregate_Bounds, Node_Id),\n+        Sm (Entity_Or_Associated_Node, Node_Id), -- just Associated_Node\n+        Sm (Compile_Time_Known_Aggregate, Flag),\n+        Sm (Expansion_Delayed, Flag),\n+        Sm (Has_Self_Reference, Flag)));\n+\n+   Cc (N_Allocator, N_Subexpr,\n+       (Sy (Expression, Node_Id, Default_Empty),\n+        Sy (Subpool_Handle_Name, Node_Id, Default_Empty),\n+        Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sm (Alloc_For_BIP_Return, Flag),\n+        Sm (Do_Storage_Check, Flag),\n+        Sm (Is_Dynamic_Coextension, Flag),\n+        Sm (Is_Static_Coextension, Flag),\n+        Sm (No_Initialization, Flag),\n+        Sm (Procedure_To_Call, Node_Id),\n+        Sm (Storage_Pool, Node_Id)));\n+\n+   Cc (N_Case_Expression, N_Subexpr,\n+       (Sy (Expression, Node_Id, Default_Empty),\n+        Sy (Alternatives, List_Id, Default_No_List),\n+        Sm (Do_Overflow_Check, Flag)));\n+\n+   Cc (N_Delta_Aggregate, N_Subexpr,\n+       (Sy (Expression, Node_Id, Default_Empty),\n+        Sy (Component_Associations, List_Id, Default_No_List)));\n+\n+   Cc (N_Extension_Aggregate, N_Subexpr,\n+       (Sy (Ancestor_Part, Node_Id),\n+        Sy (Expressions, List_Id, Default_No_List),\n+        Sy (Component_Associations, List_Id, Default_No_List),\n+        Sy (Null_Record_Present, Flag),\n+        Sm (Entity_Or_Associated_Node, Node_Id), -- just Associated_Node\n+        Sm (Expansion_Delayed, Flag),\n+        Sm (Has_Self_Reference, Flag)));\n+\n+   Cc (N_Raise_Expression, N_Subexpr,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (Convert_To_Return_False, Flag)));\n+\n+   Cc (N_Range, N_Subexpr,\n+       (Sy (Low_Bound, Node_Id),\n+        Sy (High_Bound, Node_Id),\n+        Sy (Includes_Infinities, Flag)));\n+\n+   Cc (N_Reference, N_Subexpr,\n+       (Sy (Prefix, Node_Id)));\n+\n+   Cc (N_Selected_Component, N_Subexpr,\n+       (Sy (Prefix, Node_Id),\n+        Sy (Selector_Name, Node_Id, Default_Empty),\n+        Sm (Atomic_Sync_Required, Flag),\n+        Sm (Entity_Or_Associated_Node, Node_Id), -- just Associated_Node\n+        Sm (Do_Discriminant_Check, Flag),\n+        Sm (Is_In_Discriminant_Check, Flag),\n+        Sm (Is_Prefixed_Call, Flag)));\n+\n+   Cc (N_Slice, N_Subexpr,\n+       (Sy (Prefix, Node_Id),\n+        Sy (Discrete_Range, Node_Id)));\n+\n+   Cc (N_Target_Name, N_Subexpr);\n+\n+   Cc (N_Type_Conversion, N_Subexpr,\n+       (Sy (Subtype_Mark, Node_Id, Default_Empty),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (Conversion_OK, Flag),\n+        Sm (Do_Discriminant_Check, Flag),\n+        Sm (Do_Length_Check, Flag),\n+        Sm (Do_Overflow_Check, Flag),\n+        Sm (Do_Tag_Check, Flag),\n+        Sm (Float_Truncate, Flag),\n+        Sm (Rounded_Result, Flag)));\n+\n+   Cc (N_Unchecked_Expression, N_Subexpr,\n+       (Sy (Expression, Node_Id, Default_Empty)));\n+\n+   Cc (N_Unchecked_Type_Conversion, N_Subexpr,\n+       (Sy (Subtype_Mark, Node_Id, Default_Empty),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (Kill_Range_Check, Flag),\n+        Sm (No_Truncation, Flag)));\n+\n+   Cc (N_Subtype_Indication, N_Has_Etype,\n+       (Sy (Subtype_Mark, Node_Id, Default_Empty),\n+        Sy (Constraint, Node_Id),\n+        Sm (Must_Not_Freeze, Flag)));\n+\n+   Ab (N_Declaration, Node_Kind);\n+\n+   Cc (N_Component_Declaration, N_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Component_Definition, Node_Id),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (More_Ids, Flag),\n+        Sm (Prev_Ids, Flag)));\n+\n+   Cc (N_Entry_Declaration, N_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Discrete_Subtype_Definition, Node_Id, Default_Empty),\n+        Sy (Parameter_Specifications, List_Id, Default_No_List),\n+        Sy (Must_Override, Flag),\n+        Sy (Must_Not_Override, Flag),\n+        Sm (Corresponding_Body, Node_Id)));\n+\n+   Cc (N_Expression_Function, N_Declaration,\n+       (Sy (Specification, Node_Id),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (Corresponding_Spec, Node_Id)));\n+\n+   Cc (N_Formal_Object_Declaration, N_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (In_Present, Flag),\n+        Sy (Out_Present, Flag),\n+        Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sy (Subtype_Mark, Node_Id, Default_Empty),\n+        Sy (Access_Definition, Node_Id, Default_Empty),\n+        Sy (Default_Expression, Node_Id, Default_Empty),\n+        Sm (More_Ids, Flag),\n+        Sm (Prev_Ids, Flag)));\n+\n+   Cc (N_Formal_Type_Declaration, N_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Formal_Type_Definition, Node_Id),\n+        Sy (Discriminant_Specifications, List_Id, Default_No_List),\n+        Sy (Unknown_Discriminants_Present, Flag)));\n+\n+   Cc (N_Full_Type_Declaration, N_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Discriminant_Specifications, List_Id, Default_No_List),\n+        Sy (Type_Definition, Node_Id),\n+        Sm (Discr_Check_Funcs_Built, Flag),\n+        Sm (Incomplete_View, Node_Id)));\n+\n+   Cc (N_Incomplete_Type_Declaration, N_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Discriminant_Specifications, List_Id, Default_No_List),\n+        Sy (Unknown_Discriminants_Present, Flag),\n+        Sy (Tagged_Present, Flag),\n+        Sm (Premature_Use, Node_Id)));\n+\n+   Cc (N_Iterator_Specification, N_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Name, Node_Id, Default_Empty),\n+        Sy (Reverse_Present, Flag),\n+        Sy (Of_Present, Flag),\n+        Sy (Iterator_Filter, Node_Id, Default_Empty),\n+        Sy (Subtype_Indication, Node_Id, Default_Empty)));\n+\n+   Cc (N_Loop_Parameter_Specification, N_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Reverse_Present, Flag),\n+        Sy (Iterator_Filter, Node_Id, Default_Empty),\n+        Sy (Discrete_Subtype_Definition, Node_Id, Default_Empty)));\n+\n+   Cc (N_Object_Declaration, N_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Aliased_Present, Flag),\n+        Sy (Constant_Present, Flag),\n+        Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sy (Object_Definition, Node_Id),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sy (Has_Init_Expression, Flag),\n+        Sm (Assignment_OK, Flag),\n+        Sm (Corresponding_Generic_Association, Node_Id),\n+        Sm (Exception_Junk, Flag),\n+        Sm (Handler_List_Entry, Node_Id),\n+        Sm (Is_Subprogram_Descriptor, Flag),\n+        Sm (More_Ids, Flag),\n+        Sm (No_Initialization, Flag),\n+        Sm (Prev_Ids, Flag),\n+        Sm (Suppress_Assignment_Checks, Flag)));\n+\n+   Cc (N_Protected_Type_Declaration, N_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Discriminant_Specifications, List_Id, Default_No_List),\n+        Sy (Interface_List, List_Id, Default_No_List),\n+        Sy (Protected_Definition, Node_Id),\n+        Sm (Corresponding_Body, Node_Id)));\n+\n+   Cc (N_Private_Extension_Declaration, N_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Discriminant_Specifications, List_Id, Default_No_List),\n+        Sy (Unknown_Discriminants_Present, Flag),\n+        Sy (Abstract_Present, Flag),\n+        Sy (Limited_Present, Flag),\n+        Sy (Synchronized_Present, Flag),\n+        Sy (Subtype_Indication, Node_Id, Default_Empty),\n+        Sy (Interface_List, List_Id, Default_No_List),\n+        Sm (Uninitialized_Variable, Node_Id)));\n+\n+   Cc (N_Private_Type_Declaration, N_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Discriminant_Specifications, List_Id, Default_No_List),\n+        Sy (Unknown_Discriminants_Present, Flag),\n+        Sy (Abstract_Present, Flag),\n+        Sy (Tagged_Present, Flag),\n+        Sy (Limited_Present, Flag)));\n+\n+   Cc (N_Subtype_Declaration, N_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sy (Subtype_Indication, Node_Id, Default_Empty),\n+        Sm (Exception_Junk, Flag),\n+        Sm (Generic_Parent_Type, Node_Id)));\n+\n+   Ab (N_Subprogram_Specification, N_Declaration,\n+       (Sm (Generic_Parent, Node_Id)));\n+\n+   Cc (N_Function_Specification, N_Subprogram_Specification,\n+       (Sy (Defining_Unit_Name, Node_Id),\n+        Sy (Parameter_Specifications, List_Id, Default_No_List),\n+        Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sy (Result_Definition, Node_Id),\n+        Sy (Must_Override, Flag),\n+        Sy (Must_Not_Override, Flag)));\n+\n+   Cc (N_Procedure_Specification, N_Subprogram_Specification,\n+       (Sy (Defining_Unit_Name, Node_Id),\n+        Sy (Parameter_Specifications, List_Id, Default_No_List),\n+        Sy (Null_Present, Flag),\n+        Sy (Must_Override, Flag),\n+        Sy (Must_Not_Override, Flag),\n+        Sm (Null_Statement, Node_Id)));\n+\n+   Ab (N_Access_To_Subprogram_Definition, Node_Kind);\n+\n+   Cc (N_Access_Function_Definition, N_Access_To_Subprogram_Definition,\n+       (Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sy (Null_Exclusion_In_Return_Present, Flag),\n+        Sy (Protected_Present, Flag),\n+        Sy (Parameter_Specifications, List_Id, Default_No_List),\n+        Sy (Result_Definition, Node_Id)));\n+\n+   Cc (N_Access_Procedure_Definition, N_Access_To_Subprogram_Definition,\n+       (Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sy (Protected_Present, Flag),\n+        Sy (Parameter_Specifications, List_Id, Default_No_List)));\n+\n+   Ab (N_Later_Decl_Item, Node_Kind);\n+\n+   Cc (N_Task_Type_Declaration, N_Later_Decl_Item,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Discriminant_Specifications, List_Id, Default_No_List),\n+        Sy (Interface_List, List_Id, Default_No_List),\n+        Sy (Task_Definition, Node_Id, Default_Empty),\n+        Sm (Corresponding_Body, Node_Id)));\n+\n+   Ab (N_Body_Stub, N_Later_Decl_Item,\n+       (Sm (Corresponding_Body, Node_Id),\n+        Sm (Corresponding_Spec_Of_Stub, Node_Id),\n+        Sm (Library_Unit, Node_Id)));\n+\n+   Cc (N_Package_Body_Stub, N_Body_Stub,\n+       (Sy (Defining_Identifier, Node_Id)));\n+\n+   Cc (N_Protected_Body_Stub, N_Body_Stub,\n+       (Sy (Defining_Identifier, Node_Id)));\n+\n+   Cc (N_Subprogram_Body_Stub, N_Body_Stub,\n+       (Sy (Specification, Node_Id)));\n+\n+   Cc (N_Task_Body_Stub, N_Body_Stub,\n+       (Sy (Defining_Identifier, Node_Id)));\n+\n+   Ab (N_Generic_Instantiation, N_Later_Decl_Item,\n+       (Sm (Instance_Spec, Node_Id),\n+        Sm (Is_Declaration_Level_Node, Flag),\n+        Sm (Is_Elaboration_Checks_OK_Node, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Node, Flag),\n+        Sm (Is_Known_Guaranteed_ABE, Flag),\n+        Sm (Is_SPARK_Mode_On_Node, Flag),\n+        Sm (Parent_Spec, Node_Id)));\n+\n+   Ab (N_Subprogram_Instantiation, N_Generic_Instantiation);\n+\n+   Cc (N_Function_Instantiation, N_Subprogram_Instantiation,\n+       (Sy (Defining_Unit_Name, Node_Id),\n+        Sy (Name, Node_Id, Default_Empty),\n+        Sy (Generic_Associations, List_Id, Default_No_List),\n+        Sy (Must_Override, Flag),\n+        Sy (Must_Not_Override, Flag)));\n+\n+   Cc (N_Procedure_Instantiation, N_Subprogram_Instantiation,\n+       (Sy (Defining_Unit_Name, Node_Id),\n+        Sy (Name, Node_Id, Default_Empty),\n+        Sy (Generic_Associations, List_Id, Default_No_List),\n+        Sy (Must_Override, Flag),\n+        Sy (Must_Not_Override, Flag)));\n+\n+   Cc (N_Package_Instantiation, N_Generic_Instantiation,\n+       (Sy (Defining_Unit_Name, Node_Id),\n+        Sy (Name, Node_Id, Default_Empty),\n+        Sy (Generic_Associations, List_Id, Default_No_List)));\n+\n+   Ab (N_Proper_Body, N_Later_Decl_Item,\n+       (Sm (Corresponding_Spec, Node_Id),\n+        Sm (Was_Originally_Stub, Flag)));\n+\n+   Ab (N_Unit_Body, N_Proper_Body);\n+\n+   Cc (N_Package_Body, N_Unit_Body,\n+       (Sy (Defining_Unit_Name, Node_Id),\n+        Sy (Declarations, List_Id, Default_No_List),\n+        Sy (Handled_Statement_Sequence, Node_Id, Default_Empty)));\n+\n+   Cc (N_Subprogram_Body, N_Unit_Body,\n+       (Sy (Specification, Node_Id),\n+        Sy (Declarations, List_Id, Default_No_List),\n+        Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n+        Sy (Bad_Is_Detected, Flag),\n+        Sm (Activation_Chain_Entity, Node_Id),\n+        Sm (Acts_As_Spec, Flag),\n+        Sm (Do_Storage_Check, Flag),\n+        Sm (Has_Relative_Deadline_Pragma, Flag),\n+        Sm (Is_Entry_Barrier_Function, Flag),\n+        Sm (Is_Protected_Subprogram_Body, Flag),\n+        Sm (Is_Task_Body_Procedure, Flag),\n+        Sm (Is_Task_Master, Flag),\n+        Sm (Was_Attribute_Reference, Flag),\n+        Sm (Was_Expression_Function, Flag)));\n+\n+   Cc (N_Protected_Body, N_Proper_Body,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Declarations, List_Id, Default_No_List),\n+        Sy (End_Label, Node_Id, Default_Empty)));\n+\n+   Cc (N_Task_Body, N_Proper_Body,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Declarations, List_Id, Default_No_List),\n+        Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n+        Sm (Activation_Chain_Entity, Node_Id),\n+        Sm (Is_Task_Master, Flag)));\n+\n+   Cc (N_Implicit_Label_Declaration, N_Later_Decl_Item,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sm (Label_Construct, Node_Id)));\n+\n+   Cc (N_Package_Declaration, N_Later_Decl_Item,\n+       (Sy (Specification, Node_Id),\n+        Sm (Activation_Chain_Entity, Node_Id),\n+        Sm (Corresponding_Body, Node_Id),\n+        Sm (Parent_Spec, Node_Id)));\n+\n+   Cc (N_Single_Task_Declaration, N_Later_Decl_Item,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Interface_List, List_Id, Default_No_List),\n+        Sy (Task_Definition, Node_Id, Default_Empty)));\n+\n+   Cc (N_Subprogram_Declaration, N_Later_Decl_Item,\n+       (Sy (Specification, Node_Id),\n+        Sm (Body_To_Inline, Node_Id),\n+        Sm (Corresponding_Body, Node_Id),\n+        Sm (Is_Entry_Barrier_Function, Flag),\n+        Sm (Is_Task_Body_Procedure, Flag),\n+        Sm (Parent_Spec, Node_Id)));\n+\n+   Cc (N_Use_Package_Clause, N_Later_Decl_Item,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Is_Effective_Use_Clause, Flag),\n+        Sm (Entity_Or_Associated_Node, Node_Id), -- just Associated_Node\n+        Sm (Hidden_By_Use_Clause, Elist_Id),\n+        Sm (More_Ids, Flag),\n+        Sm (Next_Use_Clause, Node_Id),\n+        Sm (Prev_Ids, Flag),\n+        Sm (Prev_Use_Clause, Node_Id)));\n+\n+   Ab (N_Generic_Declaration, N_Later_Decl_Item,\n+       (Sm (Corresponding_Body, Node_Id),\n+        Sm (Parent_Spec, Node_Id)));\n+\n+   Cc (N_Generic_Package_Declaration, N_Generic_Declaration,\n+       (Sy (Specification, Node_Id),\n+        Sy (Generic_Formal_Declarations, List_Id),\n+        Sm (Activation_Chain_Entity, Node_Id)));\n+\n+   Cc (N_Generic_Subprogram_Declaration, N_Generic_Declaration,\n+       (Sy (Specification, Node_Id),\n+        Sy (Generic_Formal_Declarations, List_Id)));\n+\n+   Ab (N_Array_Type_Definition, Node_Kind);\n+\n+   Cc (N_Constrained_Array_Definition, N_Array_Type_Definition,\n+       (Sy (Discrete_Subtype_Definitions, List_Id),\n+        Sy (Component_Definition, Node_Id)));\n+\n+   Cc (N_Unconstrained_Array_Definition, N_Array_Type_Definition,\n+       (Sy (Subtype_Marks, List_Id),\n+        Sy (Component_Definition, Node_Id)));\n+\n+   Ab (N_Renaming_Declaration, Node_Kind);\n+\n+   Cc (N_Exception_Renaming_Declaration, N_Renaming_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Name, Node_Id, Default_Empty)));\n+\n+   Cc (N_Object_Renaming_Declaration, N_Renaming_Declaration,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sy (Subtype_Mark, Node_Id, Default_Empty),\n+        Sy (Access_Definition, Node_Id, Default_Empty),\n+        Sy (Name, Node_Id, Default_Empty),\n+        Sm (Corresponding_Generic_Association, Node_Id)));\n+\n+   Cc (N_Package_Renaming_Declaration, N_Renaming_Declaration,\n+       (Sy (Defining_Unit_Name, Node_Id),\n+        Sy (Name, Node_Id, Default_Empty),\n+        Sm (Parent_Spec, Node_Id)));\n+\n+   Cc (N_Subprogram_Renaming_Declaration, N_Renaming_Declaration,\n+       (Sy (Specification, Node_Id),\n+        Sy (Name, Node_Id, Default_Empty),\n+        Sm (Corresponding_Formal_Spec, Node_Id),\n+        Sm (Corresponding_Spec, Node_Id),\n+        Sm (From_Default, Flag),\n+        Sm (Parent_Spec, Node_Id)));\n+\n+   Ab (N_Generic_Renaming_Declaration, N_Renaming_Declaration,\n+       (Sm (Parent_Spec, Node_Id)));\n+\n+   Cc (N_Generic_Function_Renaming_Declaration, N_Generic_Renaming_Declaration,\n+       (Sy (Defining_Unit_Name, Node_Id),\n+        Sy (Name, Node_Id, Default_Empty)));\n+\n+   Cc (N_Generic_Package_Renaming_Declaration, N_Generic_Renaming_Declaration,\n+       (Sy (Defining_Unit_Name, Node_Id),\n+        Sy (Name, Node_Id, Default_Empty)));\n+\n+   Cc (N_Generic_Procedure_Renaming_Declaration, N_Generic_Renaming_Declaration,\n+       (Sy (Defining_Unit_Name, Node_Id),\n+        Sy (Name, Node_Id, Default_Empty)));\n+\n+   Ab (N_Statement_Other_Than_Procedure_Call, Node_Kind);\n+\n+   Cc (N_Abort_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Names, List_Id)));\n+\n+   Cc (N_Accept_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Entry_Direct_Name, Node_Id),\n+        Sy (Entry_Index, Node_Id, Default_Empty),\n+        Sy (Parameter_Specifications, List_Id, Default_No_List),\n+        Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n+        Sy (Declarations, List_Id, Default_No_List)));\n+\n+   Cc (N_Assignment_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (Backwards_OK, Flag),\n+        Sm (Componentwise_Assignment, Flag),\n+        Sm (Do_Discriminant_Check, Flag),\n+        Sm (Do_Length_Check, Flag),\n+        Sm (Do_Tag_Check, Flag),\n+        Sm (Forwards_OK, Flag),\n+        Sm (Has_Target_Names, Flag),\n+        Sm (Is_Elaboration_Checks_OK_Node, Flag),\n+        Sm (Is_Elaboration_Code, Flag),\n+        Sm (Is_SPARK_Mode_On_Node, Flag),\n+        Sm (No_Ctrl_Actions, Flag),\n+        Sm (Suppress_Assignment_Checks, Flag)));\n+\n+   Cc (N_Asynchronous_Select, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Triggering_Alternative, Node_Id),\n+        Sy (Abortable_Part, Node_Id)));\n+\n+   Cc (N_Block_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Identifier, Node_Id, Default_Empty),\n+        Sy (Declarations, List_Id, Default_No_List),\n+        Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n+        Sy (Has_Created_Identifier, Flag),\n+        Sy (Is_Asynchronous_Call_Block, Flag),\n+        Sy (Is_Task_Allocation_Block, Flag),\n+        Sm (Activation_Chain_Entity, Node_Id),\n+        Sm (Cleanup_Actions, List_Id),\n+        Sm (Exception_Junk, Flag),\n+        Sm (Is_Abort_Block, Flag),\n+        Sm (Is_Finalization_Wrapper, Flag),\n+        Sm (Is_Initialization_Block, Flag),\n+        Sm (Is_Task_Master, Flag)));\n+\n+   Cc (N_Case_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Expression, Node_Id, Default_Empty),\n+        Sy (Alternatives, List_Id, Default_No_List),\n+        Sy (End_Span, Uint, Default_Uint_0),\n+        Sm (From_Conditional_Expression, Flag)));\n+\n+   Cc (N_Code_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Expression, Node_Id, Default_Empty)));\n+\n+   Cc (N_Compound_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Actions, List_Id, Default_No_List)));\n+\n+   Cc (N_Conditional_Entry_Call, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Entry_Call_Alternative, Node_Id),\n+        Sy (Else_Statements, List_Id, Default_No_List)));\n+\n+   Ab (N_Delay_Statement, N_Statement_Other_Than_Procedure_Call);\n+\n+   Cc (N_Delay_Relative_Statement, N_Delay_Statement,\n+       (Sy (Expression, Node_Id, Default_Empty)));\n+\n+   Cc (N_Delay_Until_Statement, N_Delay_Statement,\n+       (Sy (Expression, Node_Id, Default_Empty)));\n+\n+   Cc (N_Entry_Call_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Parameter_Associations, List_Id, Default_No_List),\n+        Sm (First_Named_Actual, Node_Id),\n+        Sm (Is_Elaboration_Checks_OK_Node, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Node, Flag),\n+        Sm (Is_SPARK_Mode_On_Node, Flag)));\n+\n+   Cc (N_Free_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Expression, Node_Id, Default_Empty),\n+        Sm (Actual_Designated_Subtype, Node_Id),\n+        Sm (Procedure_To_Call, Node_Id),\n+        Sm (Storage_Pool, Node_Id)));\n+\n+   Cc (N_Goto_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sm (Exception_Junk, Flag)));\n+\n+   Cc (N_Loop_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Identifier, Node_Id, Default_Empty),\n+        Sy (Iteration_Scheme, Node_Id, Default_Empty),\n+        Sy (Statements, List_Id, Default_Empty_List),\n+        Sy (End_Label, Node_Id, Default_Empty),\n+        Sy (Has_Created_Identifier, Flag),\n+        Sy (Is_Null_Loop, Flag),\n+        Sy (Suppress_Loop_Warnings, Flag)));\n+\n+   Cc (N_Null_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sm (Next_Rep_Item, Node_Id)));\n+\n+   Cc (N_Raise_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (From_At_End, Flag)));\n+\n+   Cc (N_Requeue_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Abort_Present, Flag),\n+        Sm (Is_Elaboration_Checks_OK_Node, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Node, Flag),\n+        Sm (Is_SPARK_Mode_On_Node, Flag)));\n+\n+   Cc (N_Simple_Return_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Expression, Node_Id, Default_Empty),\n+        Sm (By_Ref, Flag),\n+        Sm (Comes_From_Extended_Return_Statement, Flag),\n+        Sm (Do_Tag_Check, Flag),\n+        Sm (Procedure_To_Call, Node_Id),\n+        Sm (Return_Statement_Entity, Node_Id),\n+        Sm (Storage_Pool, Node_Id)));\n+\n+   Cc (N_Extended_Return_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Return_Object_Declarations, List_Id),\n+        Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n+        Sm (By_Ref, Flag),\n+        Sm (Do_Tag_Check, Flag),\n+        Sm (Procedure_To_Call, Node_Id),\n+        Sm (Return_Statement_Entity, Node_Id),\n+        Sm (Storage_Pool, Node_Id)));\n+\n+   Cc (N_Selective_Accept, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Select_Alternatives, List_Id),\n+        Sy (Else_Statements, List_Id, Default_No_List)));\n+\n+   Cc (N_Timed_Entry_Call, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Entry_Call_Alternative, Node_Id),\n+        Sy (Delay_Alternative, Node_Id)));\n+\n+   Cc (N_Exit_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Condition, Node_Id, Default_Empty),\n+        Sm (Next_Exit_Statement, Node_Id)));\n+\n+   Cc (N_If_Statement, N_Statement_Other_Than_Procedure_Call,\n+       (Sy (Condition, Node_Id, Default_Empty),\n+        Sy (Then_Statements, List_Id),\n+        Sy (Elsif_Parts, List_Id, Default_No_List),\n+        Sy (Else_Statements, List_Id, Default_No_List),\n+        Sy (End_Span, Uint, Default_Uint_0),\n+        Sm (From_Conditional_Expression, Flag)));\n+\n+   Cc (N_Accept_Alternative, Node_Kind,\n+       (Sy (Accept_Statement, Node_Id),\n+        Sy (Condition, Node_Id, Default_Empty),\n+        Sy (Statements, List_Id, Default_Empty_List),\n+        Sy (Pragmas_Before, List_Id, Default_No_List),\n+        Sm (Accept_Handler_Records, List_Id)));\n+\n+   Cc (N_Delay_Alternative, Node_Kind,\n+       (Sy (Delay_Statement, Node_Id),\n+        Sy (Condition, Node_Id, Default_Empty),\n+        Sy (Statements, List_Id, Default_Empty_List),\n+        Sy (Pragmas_Before, List_Id, Default_No_List)));\n+\n+   Cc (N_Elsif_Part, Node_Kind,\n+       (Sy (Condition, Node_Id, Default_Empty),\n+        Sy (Then_Statements, List_Id),\n+        Sm (Condition_Actions, List_Id)));\n+\n+   Cc (N_Entry_Body_Formal_Part, Node_Kind,\n+       (Sy (Entry_Index_Specification, Node_Id, Default_Empty),\n+        Sy (Parameter_Specifications, List_Id, Default_No_List),\n+        Sy (Condition, Node_Id, Default_Empty)));\n+\n+   Cc (N_Iteration_Scheme, Node_Kind,\n+       (Sy (Condition, Node_Id, Default_Empty),\n+        Sy (Iterator_Specification, Node_Id, Default_Empty),\n+        Sy (Loop_Parameter_Specification, Node_Id, Default_Empty),\n+        Sm (Condition_Actions, List_Id)));\n+\n+   Cc (N_Terminate_Alternative, Node_Kind,\n+       (Sy (Condition, Node_Id, Default_Empty),\n+        Sy (Pragmas_Before, List_Id, Default_No_List),\n+        Sy (Pragmas_After, List_Id, Default_No_List)));\n+\n+   Ab (N_Formal_Subprogram_Declaration, Node_Kind);\n+\n+   Cc (N_Formal_Abstract_Subprogram_Declaration, N_Formal_Subprogram_Declaration,\n+       (Sy (Specification, Node_Id),\n+        Sy (Default_Name, Node_Id, Default_Empty),\n+        Sy (Box_Present, Flag)));\n+\n+   Cc (N_Formal_Concrete_Subprogram_Declaration, N_Formal_Subprogram_Declaration,\n+       (Sy (Specification, Node_Id),\n+        Sy (Default_Name, Node_Id, Default_Empty),\n+        Sy (Box_Present, Flag)));\n+\n+   Ab (N_Push_Pop_xxx_Label, Node_Kind);\n+\n+   Ab (N_Push_xxx_Label, N_Push_Pop_xxx_Label,\n+       (Sm (Exception_Label, Node_Id)));\n+\n+   Cc (N_Push_Constraint_Error_Label, N_Push_xxx_Label);\n+\n+   Cc (N_Push_Program_Error_Label, N_Push_xxx_Label);\n+\n+   Cc (N_Push_Storage_Error_Label, N_Push_xxx_Label);\n+\n+   Ab (N_Pop_xxx_Label, N_Push_Pop_xxx_Label);\n+\n+   Cc (N_Pop_Constraint_Error_Label, N_Pop_xxx_Label);\n+\n+   Cc (N_Pop_Program_Error_Label, N_Pop_xxx_Label);\n+\n+   Cc (N_Pop_Storage_Error_Label, N_Pop_xxx_Label);\n+\n+   Ab (N_SCIL_Node, Node_Kind,\n+       (Sm (SCIL_Entity, Node_Id)));\n+\n+   Cc (N_SCIL_Dispatch_Table_Tag_Init, N_SCIL_Node);\n+\n+   Cc (N_SCIL_Dispatching_Call, N_SCIL_Node,\n+       (Sm (SCIL_Controlling_Tag, Node_Id),\n+        Sm (SCIL_Target_Prim, Node_Id)));\n+\n+   Cc (N_SCIL_Membership_Test, N_SCIL_Node,\n+       (Sm (SCIL_Tag_Value, Node_Id)));\n+\n+   Cc (N_Abortable_Part, Node_Kind,\n+       (Sy (Statements, List_Id, Default_Empty_List)));\n+\n+   Cc (N_Abstract_Subprogram_Declaration, Node_Kind,\n+       (Sy (Specification, Node_Id)));\n+\n+   Cc (N_Access_Definition, Node_Kind,\n+       (Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sy (All_Present, Flag),\n+        Sy (Constant_Present, Flag),\n+        Sy (Subtype_Mark, Node_Id, Default_Empty),\n+        Sy (Access_To_Subprogram_Definition, Node_Id, Default_Empty)));\n+\n+   Cc (N_Access_To_Object_Definition, Node_Kind,\n+       (Sy (All_Present, Flag),\n+        Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sy (Null_Excluding_Subtype, Flag),\n+        Sy (Subtype_Indication, Node_Id, Default_Empty),\n+        Sy (Constant_Present, Flag)));\n+\n+   Cc (N_Aspect_Specification, Node_Kind,\n+       (Sy (Identifier, Node_Id, Default_Empty),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sy (Class_Present, Flag),\n+        Sy (Split_PPC, Flag),\n+        Sm (Aspect_On_Partial_View, Flag),\n+        Sm (Aspect_Rep_Item, Node_Id),\n+        Sm (Entity_Or_Associated_Node, Node_Id), -- just Entity\n+        Sm (Is_Boolean_Aspect, Flag),\n+        Sm (Is_Checked, Flag),\n+        Sm (Is_Delayed_Aspect, Flag),\n+        Sm (Is_Disabled, Flag),\n+        Sm (Is_Ignored, Flag),\n+        Sm (Next_Rep_Item, Node_Id)));\n+\n+   Cc (N_Call_Marker, Node_Kind,\n+       (Sm (Is_Declaration_Level_Node, Flag),\n+        Sm (Is_Dispatching_Call, Flag),\n+        Sm (Is_Elaboration_Checks_OK_Node, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Node, Flag),\n+        Sm (Is_Known_Guaranteed_ABE, Flag),\n+        Sm (Is_Preelaborable_Call, Flag),\n+        Sm (Is_Source_Call, Flag),\n+        Sm (Is_SPARK_Mode_On_Node, Flag),\n+        Sm (Target, Node_Id)));\n+\n+   Cc (N_Case_Expression_Alternative, Node_Kind,\n+       (Sm (Actions, List_Id),\n+        Sy (Discrete_Choices, List_Id),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (Has_SP_Choice, Flag)));\n+\n+   Cc (N_Case_Statement_Alternative, Node_Kind,\n+       (Sy (Discrete_Choices, List_Id),\n+        Sy (Statements, List_Id, Default_Empty_List),\n+        Sm (Has_SP_Choice, Flag)));\n+\n+   Cc (N_Compilation_Unit, Node_Kind,\n+       (Sy (Context_Items, List_Id),\n+        Sy (Private_Present, Flag),\n+        Sy (Unit, Node_Id),\n+        Sy (Aux_Decls_Node, Node_Id),\n+        Sm (Acts_As_Spec, Flag),\n+        Sm (Body_Required, Flag),\n+        Sm (Context_Pending, Flag),\n+        Sm (First_Inlined_Subprogram, Node_Id),\n+        Sm (Has_No_Elaboration_Code, Flag),\n+        Sm (Has_Pragma_Suppress_All, Flag),\n+        Sm (Library_Unit, Node_Id),\n+        Sm (Save_Invocation_Graph_Of_Body, Flag)));\n+\n+   Cc (N_Compilation_Unit_Aux, Node_Kind,\n+       (Sy (Declarations, List_Id, Default_No_List),\n+        Sy (Actions, List_Id, Default_No_List),\n+        Sy (Pragmas_After, List_Id, Default_No_List),\n+        Sy (Config_Pragmas, List_Id, Default_Empty_List),\n+        Sm (Default_Storage_Pool, Node_Id)));\n+\n+   Cc (N_Component_Association, Node_Kind,\n+       (Sy (Choices, List_Id),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sy (Box_Present, Flag),\n+        Sy (Inherited_Discriminant, Flag),\n+        Sm (Loop_Actions, List_Id),\n+        Sm (Was_Default_Init_Box_Association, Flag)));\n+\n+   Cc (N_Component_Definition, Node_Kind,\n+       (Sy (Aliased_Present, Flag),\n+        Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sy (Subtype_Indication, Node_Id, Default_Empty),\n+        Sy (Access_Definition, Node_Id, Default_Empty)));\n+\n+   Cc (N_Component_List, Node_Kind,\n+       (Sy (Component_Items, List_Id),\n+        Sy (Variant_Part, Node_Id, Default_Empty),\n+        Sy (Null_Present, Flag)));\n+\n+   Cc (N_Contract, Node_Kind,\n+       (Sm (Classifications, Node_Id),\n+        Sm (Contract_Test_Cases, Node_Id),\n+        Sm (Is_Expanded_Contract, Flag),\n+        Sm (Pre_Post_Conditions, Node_Id)));\n+\n+   Cc (N_Derived_Type_Definition, Node_Kind,\n+       (Sy (Abstract_Present, Flag),\n+        Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sy (Subtype_Indication, Node_Id, Default_Empty),\n+        Sy (Record_Extension_Part, Node_Id, Default_Empty),\n+        Sy (Limited_Present, Flag),\n+        Sy (Task_Present, Flag),\n+        Sy (Protected_Present, Flag),\n+        Sy (Synchronized_Present, Flag),\n+        Sy (Interface_List, List_Id, Default_No_List),\n+        Sy (Interface_Present, Flag)));\n+\n+   Cc (N_Decimal_Fixed_Point_Definition, Node_Kind,\n+       (Sy (Delta_Expression, Node_Id),\n+        Sy (Digits_Expression, Node_Id),\n+        Sy (Real_Range_Specification, Node_Id, Default_Empty)));\n+\n+   Cc (N_Defining_Program_Unit_Name, Node_Kind,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Defining_Identifier, Node_Id)));\n+\n+   Cc (N_Delta_Constraint, Node_Kind,\n+       (Sy (Delta_Expression, Node_Id),\n+        Sy (Range_Constraint, Node_Id, Default_Empty)));\n+\n+   Cc (N_Designator, Node_Kind,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Identifier, Node_Id, Default_Empty)));\n+\n+   Cc (N_Digits_Constraint, Node_Kind,\n+       (Sy (Digits_Expression, Node_Id),\n+        Sy (Range_Constraint, Node_Id, Default_Empty)));\n+\n+   Cc (N_Discriminant_Association, Node_Kind,\n+       (Sy (Selector_Names, List_Id),\n+        Sy (Expression, Node_Id, Default_Empty)));\n+\n+   Cc (N_Discriminant_Specification, Node_Kind,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sy (Discriminant_Type, Node_Id),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (More_Ids, Flag),\n+        Sm (Prev_Ids, Flag)));\n+\n+   Cc (N_Enumeration_Type_Definition, Node_Kind,\n+       (Sy (Literals, List_Id),\n+        Sy (End_Label, Node_Id, Default_Empty)));\n+\n+   Cc (N_Entry_Body, Node_Kind,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Entry_Body_Formal_Part, Node_Id),\n+        Sy (Declarations, List_Id, Default_No_List),\n+        Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n+        Sm (Activation_Chain_Entity, Node_Id)));\n+\n+   Cc (N_Entry_Call_Alternative, Node_Kind,\n+       (Sy (Entry_Call_Statement, Node_Id),\n+        Sy (Statements, List_Id, Default_Empty_List),\n+        Sy (Pragmas_Before, List_Id, Default_No_List)));\n+\n+   Cc (N_Entry_Index_Specification, Node_Kind,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Discrete_Subtype_Definition, Node_Id, Default_Empty)));\n+\n+   Cc (N_Exception_Declaration, Node_Kind,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sm (Expression, Node_Id),\n+        Sm (More_Ids, Flag),\n+        Sm (Prev_Ids, Flag),\n+        Sm (Renaming_Exception, Node_Id)));\n+\n+   Cc (N_Exception_Handler, Node_Kind,\n+       (Sy (Choice_Parameter, Node_Id, Default_Empty),\n+        Sy (Exception_Choices, List_Id),\n+        Sy (Statements, List_Id, Default_Empty_List),\n+        Sm (Exception_Label, Node_Id),\n+        Sm (Has_Local_Raise, Flag),\n+        Sm (Local_Raise_Not_OK, Flag),\n+        Sm (Local_Raise_Statements, Elist_Id)));\n+\n+   Cc (N_Floating_Point_Definition, Node_Kind,\n+       (Sy (Digits_Expression, Node_Id),\n+        Sy (Real_Range_Specification, Node_Id, Default_Empty)));\n+\n+   Cc (N_Formal_Decimal_Fixed_Point_Definition, Node_Kind);\n+\n+   Cc (N_Formal_Derived_Type_Definition, Node_Kind,\n+       (Sy (Subtype_Mark, Node_Id, Default_Empty),\n+        Sy (Private_Present, Flag),\n+        Sy (Abstract_Present, Flag),\n+        Sy (Limited_Present, Flag),\n+        Sy (Synchronized_Present, Flag),\n+        Sy (Interface_List, List_Id, Default_No_List)));\n+\n+   Cc (N_Formal_Discrete_Type_Definition, Node_Kind);\n+\n+   Cc (N_Formal_Floating_Point_Definition, Node_Kind);\n+\n+   Cc (N_Formal_Modular_Type_Definition, Node_Kind);\n+\n+   Cc (N_Formal_Ordinary_Fixed_Point_Definition, Node_Kind);\n+\n+   Cc (N_Formal_Package_Declaration, Node_Kind,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Name, Node_Id, Default_Empty),\n+        Sy (Generic_Associations, List_Id, Default_No_List),\n+        Sy (Box_Present, Flag),\n+        Sm (Instance_Spec, Node_Id),\n+        Sm (Is_Known_Guaranteed_ABE, Flag)));\n+\n+   Cc (N_Formal_Private_Type_Definition, Node_Kind,\n+       (Sy (Abstract_Present, Flag),\n+        Sy (Tagged_Present, Flag),\n+        Sy (Limited_Present, Flag),\n+        Sm (Uninitialized_Variable, Node_Id)));\n+\n+   Cc (N_Formal_Incomplete_Type_Definition, Node_Kind,\n+       (Sy (Tagged_Present, Flag)));\n+\n+   Cc (N_Formal_Signed_Integer_Type_Definition, Node_Kind);\n+\n+   Cc (N_Freeze_Entity, Node_Kind,\n+       (Sy (Actions, List_Id, Default_No_List),\n+        Sm (Access_Types_To_Process, Elist_Id),\n+        Sm (Entity_Or_Associated_Node, Node_Id), -- just Entity\n+        Sm (First_Subtype_Link, Node_Id),\n+        Sm (TSS_Elist, Elist_Id)));\n+\n+   Cc (N_Freeze_Generic_Entity, Node_Kind,\n+        Sm (Entity_Or_Associated_Node, Node_Id)); -- just Entity\n+\n+   Cc (N_Generic_Association, Node_Kind,\n+       (Sy (Selector_Name, Node_Id, Default_Empty),\n+        Sy (Explicit_Generic_Actual_Parameter, Node_Id),\n+        Sy (Box_Present, Flag)));\n+\n+   Cc (N_Handled_Sequence_Of_Statements, Node_Kind,\n+       (Sy (Statements, List_Id, Default_Empty_List),\n+        Sy (End_Label, Node_Id, Default_Empty),\n+        Sy (Exception_Handlers, List_Id, Default_No_List),\n+        Sy (At_End_Proc, Node_Id, Default_Empty),\n+        Sm (First_Real_Statement, Node_Id)));\n+\n+   Cc (N_Index_Or_Discriminant_Constraint, Node_Kind,\n+       (Sy (Constraints, List_Id)));\n+\n+   Cc (N_Iterated_Component_Association, Node_Kind,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Iterator_Specification, Node_Id, Default_Empty),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sy (Discrete_Choices, List_Id),\n+        Sy (Box_Present, Flag),\n+        Sm (Loop_Actions, List_Id)));\n+\n+   Cc (N_Iterated_Element_Association, Node_Kind,\n+       (Sy (Key_Expression, Node_Id),\n+        Sy (Iterator_Specification, Node_Id, Default_Empty),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sy (Loop_Parameter_Specification, Node_Id, Default_Empty),\n+        Sy (Box_Present, Flag),\n+        Sm (Loop_Actions, List_Id)));\n+\n+   Cc (N_Itype_Reference, Node_Kind,\n+       (Sm (Itype, Node_Id)));\n+\n+   Cc (N_Label, Node_Kind,\n+       (Sy (Identifier, Node_Id, Default_Empty),\n+        Sm (Exception_Junk, Flag)));\n+\n+   Cc (N_Modular_Type_Definition, Node_Kind,\n+       (Sy (Expression, Node_Id, Default_Empty)));\n+\n+   Cc (N_Number_Declaration, Node_Kind,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (More_Ids, Flag),\n+        Sm (Prev_Ids, Flag)));\n+\n+   Cc (N_Ordinary_Fixed_Point_Definition, Node_Kind,\n+       (Sy (Delta_Expression, Node_Id),\n+        Sy (Real_Range_Specification, Node_Id, Default_Empty)));\n+\n+   Cc (N_Others_Choice, Node_Kind,\n+       (Sm (All_Others, Flag),\n+        Sm (Others_Discrete_Choices, List_Id)));\n+\n+   Cc (N_Package_Specification, Node_Kind,\n+       (Sy (Defining_Unit_Name, Node_Id),\n+        Sy (Visible_Declarations, List_Id),\n+        Sy (Private_Declarations, List_Id, Default_No_List),\n+        Sy (End_Label, Node_Id, Default_Empty),\n+        Sm (Generic_Parent, Node_Id),\n+        Sm (Limited_View_Installed, Flag)));\n+\n+   Cc (N_Parameter_Association, Node_Kind,\n+       (Sy (Selector_Name, Node_Id, Default_Empty),\n+        Sy (Explicit_Actual_Parameter, Node_Id),\n+        Sm (Is_Accessibility_Actual, Flag),\n+        Sm (Next_Named_Actual, Node_Id)));\n+\n+   Cc (N_Parameter_Specification, Node_Kind,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Aliased_Present, Flag),\n+        Sy (In_Present, Flag),\n+        Sy (Out_Present, Flag),\n+        Sy (Null_Exclusion_Present, Flag, Default_False),\n+        Sy (Parameter_Type, Node_Id),\n+        Sy (Expression, Node_Id, Default_Empty),\n+        Sm (Default_Expression, Node_Id),\n+        Sm (Do_Accessibility_Check, Flag),\n+        Sm (More_Ids, Flag),\n+        Sm (Prev_Ids, Flag)));\n+\n+   Cc (N_Pragma, Node_Kind,\n+       (Sy (Pragma_Argument_Associations, List_Id, Default_No_List),\n+        Sy (Pragma_Identifier, Node_Id),\n+        Sy (Class_Present, Flag),\n+        Sy (Split_PPC, Flag),\n+        Sm (Corresponding_Aspect, Node_Id),\n+        Sm (From_Aspect_Specification, Flag),\n+        Sm (Import_Interface_Present, Flag),\n+        Sm (Is_Analyzed_Pragma, Flag),\n+        Sm (Is_Checked, Flag),\n+        Sm (Is_Checked_Ghost_Pragma, Flag),\n+        Sm (Is_Delayed_Aspect, Flag),\n+        Sm (Is_Disabled, Flag),\n+        Sm (Is_Generic_Contract_Pragma, Flag),\n+        Sm (Is_Ignored, Flag),\n+        Sm (Is_Ignored_Ghost_Pragma, Flag),\n+        Sm (Is_Inherited_Pragma, Flag),\n+        Sm (Next_Pragma, Node_Id),\n+        Sm (Next_Rep_Item, Node_Id),\n+        Sm (Uneval_Old_Accept, Flag),\n+        Sm (Uneval_Old_Warn, Flag)));\n+\n+   Cc (N_Protected_Definition, Node_Kind,\n+       (Sy (Visible_Declarations, List_Id),\n+        Sy (Private_Declarations, List_Id, Default_No_List),\n+        Sy (End_Label, Node_Id, Default_Empty)));\n+\n+   Cc (N_Range_Constraint, Node_Kind,\n+       (Sy (Range_Expression, Node_Id)));\n+\n+   Cc (N_Real_Range_Specification, Node_Kind,\n+       (Sy (Low_Bound, Node_Id),\n+        Sy (High_Bound, Node_Id)));\n+\n+   Cc (N_Record_Definition, Node_Kind,\n+       (Sy (End_Label, Node_Id, Default_Empty),\n+        Sy (Abstract_Present, Flag),\n+        Sy (Tagged_Present, Flag),\n+        Sy (Limited_Present, Flag),\n+        Sy (Component_List, Node_Id),\n+        Sy (Null_Present, Flag),\n+        Sy (Task_Present, Flag),\n+        Sy (Protected_Present, Flag),\n+        Sy (Synchronized_Present, Flag),\n+        Sy (Interface_Present, Flag),\n+        Sy (Interface_List, List_Id, Default_No_List)));\n+\n+   Cc (N_Signed_Integer_Type_Definition, Node_Kind,\n+       (Sy (Low_Bound, Node_Id),\n+        Sy (High_Bound, Node_Id)));\n+\n+   Cc (N_Single_Protected_Declaration, Node_Kind,\n+       (Sy (Defining_Identifier, Node_Id),\n+        Sy (Interface_List, List_Id, Default_No_List),\n+        Sy (Protected_Definition, Node_Id)));\n+\n+   Cc (N_Subunit, Node_Kind,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Proper_Body, Node_Id),\n+        Sm (Corresponding_Stub, Node_Id)));\n+\n+   Cc (N_Task_Definition, Node_Kind,\n+       (Sy (Visible_Declarations, List_Id),\n+        Sy (Private_Declarations, List_Id, Default_No_List),\n+        Sy (End_Label, Node_Id, Default_Empty),\n+        Sm (Has_Relative_Deadline_Pragma, Flag),\n+        Sm (Has_Storage_Size_Pragma, Flag)));\n+\n+   Cc (N_Triggering_Alternative, Node_Kind,\n+       (Sy (Triggering_Statement, Node_Id),\n+        Sy (Statements, List_Id, Default_Empty_List),\n+        Sy (Pragmas_Before, List_Id, Default_No_List)));\n+\n+   Cc (N_Use_Type_Clause, Node_Kind,\n+       (Sy (Subtype_Mark, Node_Id, Default_Empty),\n+        Sy (Is_Effective_Use_Clause, Flag),\n+        Sy (All_Present, Flag),\n+        Sm (Hidden_By_Use_Clause, Elist_Id),\n+        Sm (More_Ids, Flag),\n+        Sm (Next_Use_Clause, Node_Id),\n+        Sm (Prev_Ids, Flag),\n+        Sm (Prev_Use_Clause, Node_Id),\n+        Sm (Used_Operations, Elist_Id)));\n+\n+   Cc (N_Validate_Unchecked_Conversion, Node_Kind,\n+       (Sm (Source_Type, Node_Id),\n+        Sm (Target_Type, Node_Id)));\n+\n+   Cc (N_Variable_Reference_Marker, Node_Kind,\n+       (Sm (Is_Elaboration_Checks_OK_Node, Flag),\n+        Sm (Is_Elaboration_Warnings_OK_Node, Flag),\n+        Sm (Is_Read, Flag),\n+        Sm (Is_SPARK_Mode_On_Node, Flag),\n+        Sm (Is_Write, Flag),\n+        Sm (Target, Node_Id)));\n+\n+   Cc (N_Variant, Node_Kind,\n+       (Sy (Discrete_Choices, List_Id),\n+        Sy (Component_List, Node_Id),\n+        Sm (Dcheck_Function, Node_Id),\n+        Sm (Enclosing_Variant, Node_Id),\n+        Sm (Has_SP_Choice, Flag),\n+        Sm (Present_Expr, Uint)));\n+\n+   Cc (N_Variant_Part, Node_Kind,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Variants, List_Id)));\n+\n+   Cc (N_With_Clause, Node_Kind,\n+       (Sy (Name, Node_Id, Default_Empty),\n+        Sy (Private_Present, Flag),\n+        Sy (Limited_Present, Flag),\n+        Sy (First_Name, Flag, Default_True),\n+        Sy (Last_Name, Flag, Default_True),\n+        Sm (Context_Installed, Flag),\n+        Sm (Corresponding_Spec, Node_Id),\n+        Sm (Elaborate_All_Desirable, Flag),\n+        Sm (Elaborate_All_Present, Flag),\n+        Sm (Elaborate_Desirable, Flag),\n+        Sm (Elaborate_Present, Flag),\n+        Sm (Implicit_With, Flag),\n+        Sm (Library_Unit, Node_Id),\n+        Sm (Limited_View_Installed, Flag),\n+        Sm (Next_Implicit_With, Node_Id),\n+        Sm (No_Entities_Ref_In_Spec, Flag),\n+        Sm (Parent_With, Flag),\n+        Sm (Unreferenced_In_Spec, Flag)));\n+\n+   Cc (N_Unused_At_End, Node_Kind);\n+\n+   --  Union types. These don't fit into the normal parent/child hierarchy\n+   --  above.\n+\n+   Union (N_Has_Chars,\n+          Children =>\n+            (N_Attribute_Definition_Clause,\n+             N_Empty,\n+             N_Pragma_Argument_Association,\n+             N_Error,\n+             N_Entity,\n+             N_Expanded_Name,\n+             N_Identifier,\n+             N_Operator_Symbol,\n+             N_Character_Literal,\n+             N_Op));\n+\n+   Union (N_Has_Condition,\n+          Children =>\n+            (N_Exit_Statement,\n+             N_If_Statement,\n+             N_Accept_Alternative,\n+             N_Delay_Alternative,\n+             N_Elsif_Part,\n+             N_Entry_Body_Formal_Part,\n+             N_Iteration_Scheme,\n+             N_Terminate_Alternative));\n+   --  Nodes with condition fields (does not include N_Raise_xxx_Error)\n+\n+end Gen_IL.Gen.Gen_Nodes;"}, {"sha": "137338c569c6075b0867d79979c06d3a354491bf", "filename": "gcc/ada/gen_il-gen.adb", "status": "added", "additions": 2974, "deletions": 0, "changes": 2974, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-gen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-gen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e"}, {"sha": "13f8c5984134d7e273f985e67f09b6e6bd47f6b1", "filename": "gcc/ada/gen_il-gen.ads", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-gen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-gen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,220 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                            G E N _ I L . G E N                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2020-2021, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Gen_IL.Types;  use Gen_IL.Types;\n+pragma Warnings (Off);\n+with Gen_IL.Fields; use Gen_IL.Fields; -- for children\n+pragma Warnings (On);\n+with Gen_IL.Utils;  use Gen_IL.Utils;\n+use Gen_IL.Utils.Type_Vectors;\n+use Gen_IL.Utils.Field_Vectors;\n+\n+package Gen_IL.Gen is\n+\n+   --  \"Language design is library design and library design is language\n+   --  design\".\n+   --    -- Bjarne Stroustrup\n+\n+   --  This package provides a \"little language\" for defining type hierarchies,\n+   --  which we call \"Gen_IL.Gen\". In particular, it is used to describe the\n+   --  type hierarchies rooted at Node_Id and Entity_Id in the intermediate\n+   --  language used by GNAT.\n+\n+   --  The type hierarchy is a strict hierarchy (treeish, no multiple\n+   --  inheritance). We have \"abstract\" and \"concrete\" types. Each type has a\n+   --  \"parent\", except for the root type (Node_Id or Entity_Id). All leaf\n+   --  types in the hierarchy are concrete; all nonleaf types (including the\n+   --  two root types) are abstract. One can create instances of concrete, but\n+   --  not abstract, types.\n+   --\n+   --  Descendants of Node_Id/Node_Kind are node types, and descendants of\n+   --  Entity_Id/Entity_Kind are entity types.\n+   --\n+   --  Types have \"fields\". Each type inherits all the fields from its parent,\n+   --  and may add new ones. A node field can be marked \"syntactic\"; entity\n+   --  fields are never syntactic. A nonsyntactic field is \"semantic\".\n+   --\n+   --  If a field is syntactic, then the constructors in Nmake take a parameter\n+   --  to initialize that field. In addition, the tree-traversal routines in\n+   --  Atree (Traverse_Func and Traverse_Proc) traverse syntactic fields that\n+   --  are of type Node_Id (or subtypes of Node_Id) or List_Id. Finally, (with\n+   --  some exceptions documented in the body) the setter for a syntactic node\n+   --  or list field \"Set_F (N, Val)\" will set the Parent of Val to N, unless\n+   --  Val is Empty or Error[_List].\n+   --\n+   --  Note that the same field can be syntactic in some node types but\n+   --  semantic in other node types. This is an added complexity that we might\n+   --  want to eliminate someday. We shouldn't add any new such cases.\n+   --\n+   --  A \"program\" written in the Gen_IL.Gen language consists of calls to the\n+   --  \"Create_...\" routines below, followed by a call to Compile, also below.\n+   --  In order to understand what's going on, you need to look not only at the\n+   --  Gen_IL.Gen \"code\", but at the output of the compiler -- at least, look\n+   --  at the specs of Sinfo.Nodes and Einfo.Entities, because GNAT invokes\n+   --  those directly. It's not like a normal language where you don't usually\n+   --  have to look at the generated machine code.\n+   --\n+   --  Thus, the Gen_IL.Gen code is really Ada code, and when you run it as an\n+   --  Ada program, it generates the above-mentioned files. The program is\n+   --  somewhat unusual in that it has no input. Everything it needs to\n+   --  generate code is embodied in it.\n+\n+   --  Why don't we just use a variant record, instead of inventing a wheel?\n+   --  Or a hierarchy of tagged types?\n+   --\n+   --  The key feature that Ada's variant records and tagged types lack, and\n+   --  that this little language has, is that if two types have a field with\n+   --  the same name, then those are the same field, even though they weren't\n+   --  inherited from a common ancestor. Such fields are required to have the\n+   --  same type, the same default value, and the same extra precondition.\n+\n+   procedure Create_Root_Node_Type\n+     (T : Abstract_Node;\n+      Fields : Field_Sequence := No_Fields)\n+      with Pre => T = Node_Kind;\n+   procedure Create_Abstract_Node_Type\n+     (T : Abstract_Node; Parent : Abstract_Type;\n+      Fields : Field_Sequence := No_Fields);\n+   procedure Create_Concrete_Node_Type\n+     (T : Concrete_Node; Parent : Abstract_Type;\n+      Fields : Field_Sequence := No_Fields);\n+   procedure Create_Root_Entity_Type\n+     (T : Abstract_Entity;\n+      Fields : Field_Sequence := No_Fields)\n+      with Pre => T = Entity_Kind;\n+   procedure Create_Abstract_Entity_Type\n+     (T : Abstract_Entity; Parent : Abstract_Type;\n+      Fields : Field_Sequence := No_Fields);\n+   procedure Create_Concrete_Entity_Type\n+     (T : Concrete_Entity; Parent : Abstract_Type;\n+      Fields : Field_Sequence := No_Fields);\n+\n+   function Create_Syntactic_Field\n+     (Field      : Node_Field;\n+      Field_Type : Type_Enum;\n+      Default_Value : Field_Default_Value := No_Default;\n+      Pre        : String := \"\") return Field_Desc;\n+   function Create_Semantic_Field\n+     (Field      : Field_Enum;\n+      Field_Type : Type_Enum;\n+      Type_Only  : Type_Only_Enum := No_Type_Only;\n+      Pre        : String := \"\") return Field_Desc;\n+   --  Create_Syntactic_Field is used for syntactic fields of nodes. The order\n+   --  of calls to Create_Syntactic_Field determines the order of the formal\n+   --  parameters of the Make_... functions in Nmake.\n+   --\n+   --  Create_Semantic_Field is used for semantic fields of nodes, and all\n+   --  fields of entities are considered semantic. The order of calls doesn't\n+   --  make any difference.\n+   --\n+   --  Field_Type is the type of the field. Default_Value is the default value\n+   --  for the parameter of the Make_... function in Nmake; this is effective\n+   --  only for syntactic fields. Flag fields of syntactic nodes always have a\n+   --  default value, which is False unless specified as Default_True. Pre is\n+   --  an additional precondition for the field getter and setter, in addition\n+   --  to the precondition that asserts that the type has that field.\n+   --\n+   --  If multiple calls to these occur for the same Field but different types,\n+   --  the Field_Type and Pre must match. Default_Value should match for\n+   --  syntactic fields. See the declaration of Type_Only_Enum for Type_Only.\n+   --\n+   --  (The matching Default_Value requirement is a simplification from the\n+   --  earlier hand-written version.)\n+\n+   --  To add a new node or entity type, add it to the enumeration type in\n+   --  Gen_IL.Types, taking care that it is in the approprate range\n+   --  (Abstract_Node, Abstract_Entity, Concrete_Node, or Concrete_Entity).\n+   --  Then add a call to one of the above type-creation procedures to\n+   --  Sinfo.Nodes or Einfo.Entities.\n+   --\n+   --  To add a new field to a type, add a call to one of the above field\n+   --  creation procedures to Sinfo.Nodes or Einfo.Entities.\n+\n+   --  Forward references are not allowed. So if you say:\n+   --\n+   --     Create..._Type (..., Parent => P);\n+   --\n+   --  then Create..._Type must have already been called to create P.\n+   --\n+   --  Likewise, if you say:\n+   --\n+   --     Create..._Field (T, F, Field_Type, ...);\n+   --\n+   --  then Create..._Type must have already been called to create T and\n+   --  (if it's a node or entity type) to create Field_Type.\n+   --\n+   --  To delete a node or entity type, delete it from Gen_IL.Types, update the\n+   --  subranges in Gen_IL.Utils if necessary, and delete all occurrences from\n+   --  Gen_IL.Gen.Gen_Entities. To delete a field, delete it from\n+   --  Gen_IL.Fields, and delete all occurrences from Gen_IL.Gen.Gen_Entities.\n+\n+   --  If a field is not set, it is initialized by default to whatever value is\n+   --  represented by all-zero bits, with two exceptions: Elist fields default\n+   --  to No_Elist, and Uint fields default to Uint_0. In retrospect, it would\n+   --  have been better to use No_Uint instead of Uint_0.\n+\n+   procedure Create_Node_Union (T : Abstract_Node; Children : Type_Array);\n+   procedure Create_Entity_Union (T : Abstract_Entity; Children : Type_Array);\n+   --  Create a \"union\" type that is the union of the Children. This is used\n+   --  for nonhierachical types. This is the opposite of the normal \"object\n+   --  oriented\" routines above, which create child types based on existing\n+   --  parents. Here we are creating parent types based on existing child\n+   --  types. A union type is considered to be an abstract type because it has\n+   --  multiple children. We do not allow union types to have their own fields,\n+   --  because that would introduce the well-known complexity of multiple\n+   --  inheritance. That restriction could be relaxed, but for now, union types\n+   --  are mainly for allowing things like \"Pre => X in Some_Union_Type\".\n+\n+   Illegal : exception;\n+   --  Exception raised when Gen_IL code (in particular in Gen_Nodes and\n+   --  Gen_Entities) is illegal. We don't try elaborate error recovery, but\n+   --  hopefully the exception message will indicate what's wrong. You might\n+   --  have to go in the debugger to see which line it's complaining about.\n+\n+   procedure Compile;\n+\n+private\n+\n+   function Sy\n+     (Field      : Node_Field;\n+      Field_Type : Type_Enum;\n+      Default_Value : Field_Default_Value := No_Default;\n+      Pre        : String := \"\") return Field_Sequence;\n+   function Sm\n+     (Field      : Field_Enum;\n+      Field_Type : Type_Enum;\n+      Type_Only  : Type_Only_Enum := No_Type_Only;\n+      Pre        : String := \"\") return Field_Sequence;\n+   --  The above functions return Field_Sequence. This is a trick to get around\n+   --  the fact that Ada doesn't allow singleton positional aggregates. It\n+   --  allows us to write things like:\n+   --\n+   --     Cc (N_Empty, Node_Kind,\n+   --         (Sy (Chars, Name_Id, Default_No_Name)));\n+   --\n+   --  where that thing pretending to be an aggregate is really a parenthesized\n+   --  expression.\n+\n+end Gen_IL.Gen;"}, {"sha": "d62440616528f2ffb15e4596a2ee68d44ac74856", "filename": "gcc/ada/gen_il-main.adb", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-main.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-main.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-main.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,34 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                           G E N _ I L . M A I N                          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--           Copyright (C) 2020-2021, Free Software Foundation, Inc.        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Gen_IL.Gen.Gen_Nodes;\n+with Gen_IL.Gen.Gen_Entities;\n+\n+procedure Gen_IL.Main is\n+begin\n+   Gen_IL.Gen.Gen_Nodes;\n+   Gen_IL.Gen.Gen_Entities;\n+   Gen_IL.Gen.Compile;\n+end Gen_IL.Main;"}, {"sha": "684d2bfb2c866d6ad32a54346f422c77bfa32c98", "filename": "gcc/ada/gen_il-types.ads", "status": "added", "additions": 496, "deletions": 0, "changes": 496, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-types.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-types.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-types.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,496 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                          G E N _ I L . T Y P E S                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2020-2021, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package Gen_IL.Types is\n+\n+   --  Enumeration of all the types that are \"of interest\". We have an\n+   --  enumeration literal here for every node kind, every entity kind,\n+   --  andevery type that can be the type of a field.\n+\n+   --  The \"Between_...\" literals below are simply for making subranges.\n+   --  When adding literals to this enumeration type, be sure to put them\n+   --  in the right place so they end up in the appropriate subranges in\n+   --  Gen_IL.Utils (Abstract_Node, Abstract_Entity, Concrete_Node,\n+   --  Concrete_Entity).\n+\n+   --  The following is \"optional type enumeration\" -- i.e. it is Type_Enum\n+   --  (declared in Gen_IL.Utils) plus the special null value No_Type.\n+   --  See the spec of Gen_IL.Gen for how to modify this.\n+\n+   type Opt_Type_Enum is\n+     (No_Type,\n+\n+      Flag,\n+      --  We use Flag for Boolean, so we don't conflict with\n+      --  Standard.Boolean.\n+\n+      Node_Id,\n+      List_Id,\n+      Elist_Id,\n+      Name_Id,\n+      String_Id,\n+      Uint,\n+      Ureal,\n+\n+      Nkind_Type, -- Type of result of Nkind function, i.e. Node_Kind\n+      Ekind_Type, -- Type of result of Ekind function, i.e. Entity_Kind\n+      Source_Ptr,\n+      Small_Paren_Count_Type,\n+      Union_Id,\n+      Convention_Id,\n+\n+      Component_Alignment_Kind,\n+      Float_Rep_Kind,\n+      Mechanism_Type,\n+\n+      Between_Special_And_Abstract_Node_Types,\n+\n+      --  Abstract node types:\n+\n+      Node_Kind, -- root of node type hierarchy\n+      N_Access_To_Subprogram_Definition,\n+      N_Array_Type_Definition,\n+      N_Binary_Op,\n+      N_Body_Stub,\n+      N_Declaration,\n+      N_Delay_Statement,\n+      N_Direct_Name,\n+      N_Entity,\n+      N_Formal_Subprogram_Declaration,\n+      N_Generic_Declaration,\n+      N_Generic_Instantiation,\n+      N_Generic_Renaming_Declaration,\n+      N_Has_Chars,\n+      N_Has_Entity,\n+      N_Has_Etype,\n+      N_Multiplying_Operator,\n+      N_Later_Decl_Item,\n+      N_Membership_Test,\n+      N_Numeric_Or_String_Literal,\n+      N_Op,\n+      N_Op_Boolean,\n+      N_Op_Compare,\n+      N_Op_Shift,\n+      N_Proper_Body,\n+      N_Push_xxx_Label,\n+      N_Pop_xxx_Label,\n+      N_Push_Pop_xxx_Label,\n+      N_Raise_xxx_Error,\n+      N_Renaming_Declaration,\n+      N_Representation_Clause,\n+      N_Short_Circuit,\n+      N_SCIL_Node,\n+      N_Statement_Other_Than_Procedure_Call,\n+      N_Subprogram_Call,\n+      N_Subprogram_Instantiation,\n+      N_Has_Condition,\n+      N_Subexpr,\n+      N_Subprogram_Specification,\n+      N_Unary_Op,\n+      N_Unit_Body,\n+\n+      --  End of abstract node types.\n+\n+      Between_Abstract_Node_And_Abstract_Entity_Types,\n+\n+      --  Abstract entity types:\n+\n+      Entity_Kind, -- root of entity type hierarchy\n+      Access_Kind,\n+      Access_Subprogram_Kind,\n+      Access_Protected_Kind,\n+      Aggregate_Kind,\n+      Anonymous_Access_Kind,\n+      Array_Kind,\n+      Assignable_Kind,\n+      Class_Wide_Kind,\n+      Composite_Kind,\n+      Concurrent_Kind,\n+      Concurrent_Body_Kind,\n+      Decimal_Fixed_Point_Kind,\n+      Digits_Kind,\n+      Discrete_Kind,\n+      Discrete_Or_Fixed_Point_Kind,\n+      Elementary_Kind,\n+      Enumeration_Kind,\n+      Entry_Kind,\n+      Fixed_Point_Kind,\n+      Float_Kind,\n+      Formal_Kind,\n+      Formal_Object_Kind,\n+      Generic_Subprogram_Kind,\n+      Generic_Unit_Kind,\n+      Incomplete_Kind,\n+      Incomplete_Or_Private_Kind,\n+      Integer_Kind,\n+      Modular_Integer_Kind,\n+      Named_Kind,\n+      Numeric_Kind,\n+      Object_Kind,\n+      Ordinary_Fixed_Point_Kind,\n+      Overloadable_Kind,\n+      Private_Kind,\n+      Protected_Kind,\n+      Real_Kind,\n+      Record_Kind,\n+      Scalar_Kind,\n+      Subprogram_Kind,\n+      Signed_Integer_Kind,\n+      Task_Kind,\n+      Type_Kind,\n+\n+      --  End of abstract entity types.\n+\n+      Between_Abstract_Entity_And_Concrete_Node_Types,\n+\n+      --  Concrete node types:\n+\n+      N_Unused_At_Start,\n+      N_At_Clause,\n+      N_Component_Clause,\n+      N_Enumeration_Representation_Clause,\n+      N_Mod_Clause,\n+      N_Record_Representation_Clause,\n+      N_Attribute_Definition_Clause,\n+      N_Empty,\n+      N_Pragma_Argument_Association,\n+      N_Error,\n+      N_Defining_Character_Literal,\n+      N_Defining_Identifier,\n+      N_Defining_Operator_Symbol,\n+      N_Expanded_Name,\n+      N_Identifier,\n+      N_Operator_Symbol,\n+      N_Character_Literal,\n+      N_Op_Add,\n+      N_Op_Concat,\n+      N_Op_Expon,\n+      N_Op_Subtract,\n+      N_Op_Divide,\n+      N_Op_Mod,\n+      N_Op_Multiply,\n+      N_Op_Rem,\n+      N_Op_And,\n+      N_Op_Eq,\n+      N_Op_Ge,\n+      N_Op_Gt,\n+      N_Op_Le,\n+      N_Op_Lt,\n+      N_Op_Ne,\n+      N_Op_Or,\n+      N_Op_Xor,\n+      N_Op_Rotate_Left,\n+      N_Op_Rotate_Right,\n+      N_Op_Shift_Left,\n+      N_Op_Shift_Right,\n+      N_Op_Shift_Right_Arithmetic,\n+      N_Op_Abs,\n+      N_Op_Minus,\n+      N_Op_Not,\n+      N_Op_Plus,\n+      N_Attribute_Reference,\n+      N_In,\n+      N_Not_In,\n+      N_And_Then,\n+      N_Or_Else,\n+      N_Function_Call,\n+      N_Procedure_Call_Statement,\n+      N_Raise_Constraint_Error,\n+      N_Raise_Program_Error,\n+      N_Raise_Storage_Error,\n+      N_Integer_Literal,\n+      N_Real_Literal,\n+      N_String_Literal,\n+      N_Explicit_Dereference,\n+      N_Expression_With_Actions,\n+      N_If_Expression,\n+      N_Indexed_Component,\n+      N_Null,\n+      N_Qualified_Expression,\n+      N_Quantified_Expression,\n+      N_Aggregate,\n+      N_Allocator,\n+      N_Case_Expression,\n+      N_Delta_Aggregate,\n+      N_Extension_Aggregate,\n+      N_Raise_Expression,\n+      N_Range,\n+      N_Reference,\n+      N_Selected_Component,\n+      N_Slice,\n+      N_Target_Name,\n+      N_Type_Conversion,\n+      N_Unchecked_Expression,\n+      N_Unchecked_Type_Conversion,\n+      N_Subtype_Indication,\n+      N_Component_Declaration,\n+      N_Entry_Declaration,\n+      N_Expression_Function,\n+      N_Formal_Object_Declaration,\n+      N_Formal_Type_Declaration,\n+      N_Full_Type_Declaration,\n+      N_Incomplete_Type_Declaration,\n+      N_Iterator_Specification,\n+      N_Loop_Parameter_Specification,\n+      N_Object_Declaration,\n+      N_Protected_Type_Declaration,\n+      N_Private_Extension_Declaration,\n+      N_Private_Type_Declaration,\n+      N_Subtype_Declaration,\n+      N_Function_Specification,\n+      N_Procedure_Specification,\n+      N_Access_Function_Definition,\n+      N_Access_Procedure_Definition,\n+      N_Task_Type_Declaration,\n+      N_Package_Body_Stub,\n+      N_Protected_Body_Stub,\n+      N_Subprogram_Body_Stub,\n+      N_Task_Body_Stub,\n+      N_Function_Instantiation,\n+      N_Procedure_Instantiation,\n+      N_Package_Instantiation,\n+      N_Package_Body,\n+      N_Subprogram_Body,\n+      N_Protected_Body,\n+      N_Task_Body,\n+      N_Implicit_Label_Declaration,\n+      N_Package_Declaration,\n+      N_Single_Task_Declaration,\n+      N_Subprogram_Declaration,\n+      N_Use_Package_Clause,\n+      N_Generic_Package_Declaration,\n+      N_Generic_Subprogram_Declaration,\n+      N_Constrained_Array_Definition,\n+      N_Unconstrained_Array_Definition,\n+      N_Exception_Renaming_Declaration,\n+      N_Object_Renaming_Declaration,\n+      N_Package_Renaming_Declaration,\n+      N_Subprogram_Renaming_Declaration,\n+      N_Generic_Function_Renaming_Declaration,\n+      N_Generic_Package_Renaming_Declaration,\n+      N_Generic_Procedure_Renaming_Declaration,\n+      N_Abort_Statement,\n+      N_Accept_Statement,\n+      N_Assignment_Statement,\n+      N_Asynchronous_Select,\n+      N_Block_Statement,\n+      N_Case_Statement,\n+      N_Code_Statement,\n+      N_Compound_Statement,\n+      N_Conditional_Entry_Call,\n+      N_Delay_Relative_Statement,\n+      N_Delay_Until_Statement,\n+      N_Entry_Call_Statement,\n+      N_Free_Statement,\n+      N_Goto_Statement,\n+      N_Loop_Statement,\n+      N_Null_Statement,\n+      N_Raise_Statement,\n+      N_Requeue_Statement,\n+      N_Simple_Return_Statement,\n+      N_Extended_Return_Statement,\n+      N_Selective_Accept,\n+      N_Timed_Entry_Call,\n+      N_Exit_Statement,\n+      N_If_Statement,\n+      N_Accept_Alternative,\n+      N_Delay_Alternative,\n+      N_Elsif_Part,\n+      N_Entry_Body_Formal_Part,\n+      N_Iteration_Scheme,\n+      N_Terminate_Alternative,\n+      N_Formal_Abstract_Subprogram_Declaration,\n+      N_Formal_Concrete_Subprogram_Declaration,\n+      N_Push_Constraint_Error_Label,\n+      N_Push_Program_Error_Label,\n+      N_Push_Storage_Error_Label,\n+      N_Pop_Constraint_Error_Label,\n+      N_Pop_Program_Error_Label,\n+      N_Pop_Storage_Error_Label,\n+      N_SCIL_Dispatch_Table_Tag_Init,\n+      N_SCIL_Dispatching_Call,\n+      N_SCIL_Membership_Test,\n+      N_Abortable_Part,\n+      N_Abstract_Subprogram_Declaration,\n+      N_Access_Definition,\n+      N_Access_To_Object_Definition,\n+      N_Aspect_Specification,\n+      N_Call_Marker,\n+      N_Case_Expression_Alternative,\n+      N_Case_Statement_Alternative,\n+      N_Compilation_Unit,\n+      N_Compilation_Unit_Aux,\n+      N_Component_Association,\n+      N_Component_Definition,\n+      N_Component_List,\n+      N_Contract,\n+      N_Derived_Type_Definition,\n+      N_Decimal_Fixed_Point_Definition,\n+      N_Defining_Program_Unit_Name,\n+      N_Delta_Constraint,\n+      N_Designator,\n+      N_Digits_Constraint,\n+      N_Discriminant_Association,\n+      N_Discriminant_Specification,\n+      N_Enumeration_Type_Definition,\n+      N_Entry_Body,\n+      N_Entry_Call_Alternative,\n+      N_Entry_Index_Specification,\n+      N_Exception_Declaration,\n+      N_Exception_Handler,\n+      N_Floating_Point_Definition,\n+      N_Formal_Decimal_Fixed_Point_Definition,\n+      N_Formal_Derived_Type_Definition,\n+      N_Formal_Discrete_Type_Definition,\n+      N_Formal_Floating_Point_Definition,\n+      N_Formal_Modular_Type_Definition,\n+      N_Formal_Ordinary_Fixed_Point_Definition,\n+      N_Formal_Package_Declaration,\n+      N_Formal_Private_Type_Definition,\n+      N_Formal_Incomplete_Type_Definition,\n+      N_Formal_Signed_Integer_Type_Definition,\n+      N_Freeze_Entity,\n+      N_Freeze_Generic_Entity,\n+      N_Generic_Association,\n+      N_Handled_Sequence_Of_Statements,\n+      N_Index_Or_Discriminant_Constraint,\n+      N_Iterated_Component_Association,\n+      N_Iterated_Element_Association,\n+      N_Itype_Reference,\n+      N_Label,\n+      N_Modular_Type_Definition,\n+      N_Number_Declaration,\n+      N_Ordinary_Fixed_Point_Definition,\n+      N_Others_Choice,\n+      N_Package_Specification,\n+      N_Parameter_Association,\n+      N_Parameter_Specification,\n+      N_Pragma,\n+      N_Protected_Definition,\n+      N_Range_Constraint,\n+      N_Real_Range_Specification,\n+      N_Record_Definition,\n+      N_Signed_Integer_Type_Definition,\n+      N_Single_Protected_Declaration,\n+      N_Subunit,\n+      N_Task_Definition,\n+      N_Triggering_Alternative,\n+      N_Use_Type_Clause,\n+      N_Validate_Unchecked_Conversion,\n+      N_Variable_Reference_Marker,\n+      N_Variant,\n+      N_Variant_Part,\n+      N_With_Clause,\n+      N_Unused_At_End,\n+\n+      --  End of concrete node types.\n+\n+      Between_Concrete_Node_And_Concrete_Entity_Types,\n+\n+      --  Concrete entity types:\n+\n+      E_Void,\n+      E_Component,\n+      E_Constant,\n+      E_Discriminant,\n+      E_Loop_Parameter,\n+      E_Variable,\n+      E_Out_Parameter,\n+      E_In_Out_Parameter,\n+      E_In_Parameter,\n+      E_Generic_In_Out_Parameter,\n+      E_Generic_In_Parameter,\n+      E_Named_Integer,\n+      E_Named_Real,\n+      E_Enumeration_Type,\n+      E_Enumeration_Subtype,\n+      E_Signed_Integer_Type,\n+      E_Signed_Integer_Subtype,\n+      E_Modular_Integer_Type,\n+      E_Modular_Integer_Subtype,\n+      E_Ordinary_Fixed_Point_Type,\n+      E_Ordinary_Fixed_Point_Subtype,\n+      E_Decimal_Fixed_Point_Type,\n+      E_Decimal_Fixed_Point_Subtype,\n+      E_Floating_Point_Type,\n+      E_Floating_Point_Subtype,\n+      E_Access_Type,\n+      E_Access_Subtype,\n+      E_Access_Attribute_Type,\n+      E_Allocator_Type,\n+      E_General_Access_Type,\n+      E_Access_Subprogram_Type,\n+      E_Access_Protected_Subprogram_Type,\n+      E_Anonymous_Access_Protected_Subprogram_Type,\n+      E_Anonymous_Access_Subprogram_Type,\n+      E_Anonymous_Access_Type,\n+      E_Array_Type,\n+      E_Array_Subtype,\n+      E_String_Literal_Subtype,\n+      E_Class_Wide_Type,\n+      E_Class_Wide_Subtype,\n+      E_Record_Type,\n+      E_Record_Subtype,\n+      E_Record_Type_With_Private,\n+      E_Record_Subtype_With_Private,\n+      E_Private_Type,\n+      E_Private_Subtype,\n+      E_Limited_Private_Type,\n+      E_Limited_Private_Subtype,\n+      E_Incomplete_Type,\n+      E_Incomplete_Subtype,\n+      E_Task_Type,\n+      E_Task_Subtype,\n+      E_Protected_Type,\n+      E_Protected_Subtype,\n+      E_Exception_Type,\n+      E_Subprogram_Type,\n+      E_Enumeration_Literal,\n+      E_Function,\n+      E_Operator,\n+      E_Procedure,\n+      E_Abstract_State,\n+      E_Entry,\n+      E_Entry_Family,\n+      E_Block,\n+      E_Entry_Index_Parameter,\n+      E_Exception,\n+      E_Generic_Function,\n+      E_Generic_Procedure,\n+      E_Generic_Package,\n+      E_Label,\n+      E_Loop,\n+      E_Return_Statement,\n+      E_Package,\n+      E_Package_Body,\n+      E_Protected_Body,\n+      E_Task_Body,\n+      E_Subprogram_Body\n+\n+      --  End of concrete entity types.\n+\n+     ); -- Type_Enum\n+\n+end Gen_IL.Types;"}, {"sha": "21acd9bfe25324b301994f94dfa4e96d1cbec3bb", "filename": "gcc/ada/gen_il-utils.adb", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-utils.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,453 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                          G E N _ I L . U T I L S                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2020-2021, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Gen_IL.Utils is\n+\n+   procedure Nil (T : Node_Or_Entity_Type) is\n+   begin\n+      null;\n+   end Nil;\n+\n+   function Node_Or_Entity (Root : Root_Type) return String is\n+   begin\n+      if Root = Node_Kind then\n+         return \"Node\";\n+      else\n+         return \"Entity\";\n+      end if;\n+   end Node_Or_Entity;\n+\n+   function Num_Concrete_Descendants\n+     (T : Node_Or_Entity_Type) return Natural is\n+   begin\n+      return Concrete_Type'Pos (Type_Table (T).Last) -\n+        Concrete_Type'Pos (Type_Table (T).First) + 1;\n+   end Num_Concrete_Descendants;\n+\n+   function First_Abstract (Root : Root_Type) return Abstract_Type is\n+     (case Root is\n+        when Node_Kind => Abstract_Node'First,\n+        when others => Abstract_Entity'First);  -- Entity_Kind\n+   function Last_Abstract (Root : Root_Type) return Abstract_Type is\n+     (case Root is\n+        when Node_Kind => Abstract_Node'Last,\n+        when others => Abstract_Entity'Last);  -- Entity_Kind\n+\n+   function First_Concrete (Root : Root_Type) return Concrete_Type is\n+     (case Root is\n+        when Node_Kind => Concrete_Node'First,\n+        when others => Concrete_Entity'First);  -- Entity_Kind\n+   function Last_Concrete (Root : Root_Type) return Concrete_Type is\n+     (case Root is\n+        when Node_Kind => Concrete_Node'Last,\n+        when others => Concrete_Entity'Last);  -- Entity_Kind\n+\n+   function First_Field (Root : Root_Type) return Field_Enum is\n+     (case Root is\n+        when Node_Kind => Node_Field'First,\n+        when others => Entity_Field'First);  -- Entity_Kind\n+   function Last_Field (Root : Root_Type) return Field_Enum is\n+     (case Root is\n+        when Node_Kind => Node_Field'Last,\n+        when others => Entity_Field'Last);  -- Entity_Kind\n+   --  First and Last node or entity fields\n+\n+   procedure Verify_Type_Table is\n+   begin\n+      for T in Node_Or_Entity_Type loop\n+         if Type_Table (T) /= null then\n+            if not Type_Table (T).Is_Union then\n+               case T is\n+                  when Concrete_Node | Concrete_Entity =>\n+                     pragma Assert (Type_Table (T).First = T);\n+                     pragma Assert (Type_Table (T).Last = T);\n+\n+                  when Abstract_Node | Abstract_Entity =>\n+                     pragma Assert\n+                       (Type_Table (T).First < Type_Table (T).Last);\n+\n+                  when Boundaries =>\n+                     null;\n+               end case;\n+            end if;\n+         end if;\n+      end loop;\n+   end Verify_Type_Table;\n+\n+   function Id_Image (T : Type_Enum) return String is\n+   begin\n+      case T is\n+         when Flag =>\n+            return \"Boolean\";\n+         when Node_Kind =>\n+            return \"Node_Id\";\n+         when Entity_Kind =>\n+            return \"Entity_Id\";\n+         when Nkind_Type =>\n+            return \"Node_Kind\";\n+         when Ekind_Type =>\n+            return \"Entity_Kind\";\n+         when others =>\n+            return Image (T) & \"_Id\";\n+      end case;\n+   end Id_Image;\n+\n+   function Get_Set_Id_Image (T : Type_Enum) return String is\n+   begin\n+      case T is\n+         when Node_Kind =>\n+            return \"Node_Id\";\n+         when Entity_Kind =>\n+            return \"Entity_Id\";\n+         when Nkind_Type =>\n+            return \"Node_Kind\";\n+         when Ekind_Type =>\n+            return \"Entity_Kind\";\n+         when others =>\n+            return Image (T);\n+      end case;\n+   end Get_Set_Id_Image;\n+\n+   function Image (T : Opt_Type_Enum) return String is\n+   begin\n+      case T is\n+         --  We special case the following; otherwise the compiler will give\n+         --  \"wrong case\" warnings in compiler code.\n+\n+         when N_Pop_xxx_Label =>\n+            return \"N_Pop_xxx_Label\";\n+\n+         when N_Push_Pop_xxx_Label =>\n+            return \"N_Push_Pop_xxx_Label\";\n+\n+         when N_Push_xxx_Label =>\n+            return \"N_Push_xxx_Label\";\n+\n+         when N_Raise_xxx_Error =>\n+            return \"N_Raise_xxx_Error\";\n+\n+         when N_SCIL_Node =>\n+            return \"N_SCIL_Node\";\n+\n+         when N_SCIL_Dispatch_Table_Tag_Init =>\n+            return \"N_SCIL_Dispatch_Table_Tag_Init\";\n+\n+         when N_SCIL_Dispatching_Call =>\n+            return \"N_SCIL_Dispatching_Call\";\n+\n+         when N_SCIL_Membership_Test =>\n+            return \"N_SCIL_Membership_Test\";\n+\n+         when others =>\n+            return Capitalize (T'Img);\n+      end case;\n+   end Image;\n+\n+   function Image_Sans_N (T : Opt_Type_Enum) return String is\n+      Im : constant String := Image (T);\n+      pragma Assert (Im (1 .. 2) = \"N_\");\n+   begin\n+      return Im (3 .. Im'Last);\n+   end Image_Sans_N;\n+\n+   procedure Put_Images (S : in out Sink'Class; U : Type_Vector) is\n+      First_Time : Boolean := True;\n+   begin\n+      Indent (S, 3);\n+\n+      for T of U loop\n+         if First_Time then\n+            First_Time := False;\n+         else\n+            Put (S, \"\\n| \");\n+         end if;\n+\n+         Put (S, \"\\1\", Image (T));\n+      end loop;\n+\n+      Outdent (S, 3);\n+   end Put_Images;\n+\n+   procedure Put_Id_Images (S : in out Sink'Class; U : Type_Vector) is\n+      First_Time : Boolean := True;\n+   begin\n+      Indent (S, 3);\n+\n+      for T of U loop\n+         if First_Time then\n+            First_Time := False;\n+         else\n+            Put (S, \"\\n| \");\n+         end if;\n+\n+         Put (S, \"\\1\", Id_Image (T));\n+      end loop;\n+\n+      Outdent (S, 3);\n+   end Put_Id_Images;\n+\n+   function Image (F : Opt_Field_Enum) return String is\n+   begin\n+      case F is\n+         --  Special cases for the same reason as in the above Image\n+         --  function.\n+\n+         when Alloc_For_BIP_Return =>\n+            return \"Alloc_For_BIP_Return\";\n+         when Assignment_OK =>\n+            return \"Assignment_OK\";\n+         when Backwards_OK =>\n+            return \"Backwards_OK\";\n+         when BIP_Initialization_Call =>\n+            return \"BIP_Initialization_Call\";\n+         when Body_Needed_For_SAL =>\n+            return \"Body_Needed_For_SAL\";\n+         when Conversion_OK =>\n+            return \"Conversion_OK\";\n+         when CR_Discriminant =>\n+            return \"CR_Discriminant\";\n+         when DTC_Entity =>\n+            return \"DTC_Entity\";\n+         when DT_Entry_Count =>\n+            return \"DT_Entry_Count\";\n+         when DT_Offset_To_Top_Func =>\n+            return \"DT_Offset_To_Top_Func\";\n+         when DT_Position =>\n+            return \"DT_Position\";\n+         when Forwards_OK =>\n+            return \"Forwards_OK\";\n+         when Has_Inherited_DIC =>\n+            return \"Has_Inherited_DIC\";\n+         when Has_Own_DIC =>\n+            return \"Has_Own_DIC\";\n+         when Has_RACW =>\n+            return \"Has_RACW\";\n+         when Has_SP_Choice =>\n+            return \"Has_SP_Choice\";\n+         when Ignore_SPARK_Mode_Pragmas =>\n+            return \"Ignore_SPARK_Mode_Pragmas\";\n+         when Is_Constr_Subt_For_UN_Aliased =>\n+            return \"Is_Constr_Subt_For_UN_Aliased\";\n+         when Is_CPP_Class =>\n+            return \"Is_CPP_Class\";\n+         when Is_CUDA_Kernel =>\n+            return \"Is_CUDA_Kernel\";\n+         when Is_DIC_Procedure =>\n+            return \"Is_DIC_Procedure\";\n+         when Is_Discrim_SO_Function =>\n+            return \"Is_Discrim_SO_Function\";\n+         when Is_Elaboration_Checks_OK_Id =>\n+            return \"Is_Elaboration_Checks_OK_Id\";\n+         when Is_Elaboration_Checks_OK_Node =>\n+            return \"Is_Elaboration_Checks_OK_Node\";\n+         when Is_Elaboration_Warnings_OK_Id =>\n+            return \"Is_Elaboration_Warnings_OK_Id\";\n+         when Is_Elaboration_Warnings_OK_Node =>\n+            return \"Is_Elaboration_Warnings_OK_Node\";\n+         when Is_Known_Guaranteed_ABE =>\n+            return \"Is_Known_Guaranteed_ABE\";\n+         when Is_RACW_Stub_Type =>\n+            return \"Is_RACW_Stub_Type\";\n+         when Is_SPARK_Mode_On_Node =>\n+            return \"Is_SPARK_Mode_On_Node\";\n+         when Local_Raise_Not_OK =>\n+            return \"Local_Raise_Not_OK\";\n+         when OK_To_Rename =>\n+            return \"OK_To_Rename\";\n+         when Referenced_As_LHS =>\n+            return \"Referenced_As_LHS\";\n+         when RM_Size =>\n+            return \"RM_Size\";\n+         when SCIL_Controlling_Tag =>\n+            return \"SCIL_Controlling_Tag\";\n+         when SCIL_Entity =>\n+            return \"SCIL_Entity\";\n+         when SCIL_Tag_Value =>\n+            return \"SCIL_Tag_Value\";\n+         when SCIL_Target_Prim =>\n+            return \"SCIL_Target_Prim\";\n+         when Shift_Count_OK =>\n+            return \"Shift_Count_OK\";\n+         when SPARK_Aux_Pragma =>\n+            return \"SPARK_Aux_Pragma\";\n+         when SPARK_Aux_Pragma_Inherited =>\n+            return \"SPARK_Aux_Pragma_Inherited\";\n+         when SPARK_Pragma =>\n+            return \"SPARK_Pragma\";\n+         when SPARK_Pragma_Inherited =>\n+            return \"SPARK_Pragma_Inherited\";\n+         when Split_PPC =>\n+            return \"Split_PPC\";\n+         when SSO_Set_High_By_Default =>\n+            return \"SSO_Set_High_By_Default\";\n+         when SSO_Set_Low_By_Default =>\n+            return \"SSO_Set_Low_By_Default\";\n+         when TSS_Elist =>\n+            return \"TSS_Elist\";\n+\n+         when others =>\n+            return Capitalize (F'Img);\n+      end case;\n+   end Image;\n+\n+   function Image (Default : Field_Default_Value) return String is\n+     (Capitalize (Default'Img));\n+\n+   function Value_Image (Default : Field_Default_Value) return String is\n+   begin\n+      if Default = No_Default then\n+         return Image (Default);\n+\n+      else\n+         --  Strip off the prefix and capitalize it\n+\n+         declare\n+            Im : constant String := Image (Default);\n+            Prefix : constant String := \"Default_\";\n+         begin\n+            pragma Assert (Im (1 .. Prefix'Length) = Prefix);\n+            return Im (Prefix'Length + 1 .. Im'Last);\n+         end;\n+      end if;\n+   end Value_Image;\n+\n+   procedure Iterate_Types\n+     (Root  : Node_Or_Entity_Type;\n+      Pre, Post : not null access procedure (T : Node_Or_Entity_Type) :=\n+        Nil'Access)\n+   is\n+      procedure Recursive (T : Node_Or_Entity_Type);\n+      --  Recursive walk\n+\n+      procedure Recursive (T : Node_Or_Entity_Type) is\n+      begin\n+         Pre (T);\n+\n+         for Child of Type_Table (T).Children loop\n+            Recursive (Child);\n+         end loop;\n+\n+         Post (T);\n+      end Recursive;\n+\n+   begin\n+      Recursive (Root);\n+   end Iterate_Types;\n+\n+   function Is_Descendant (Ancestor, Descendant : Node_Or_Entity_Type)\n+     return Boolean is\n+   begin\n+      if Ancestor = Descendant then\n+         return True;\n+\n+      elsif Descendant in Root_Type then\n+         return False;\n+\n+      else\n+         return Is_Descendant (Ancestor, Type_Table (Descendant).Parent);\n+      end if;\n+   end Is_Descendant;\n+\n+   procedure Put_Type_Hierarchy (S : in out Sink'Class; Root : Root_Type) is\n+      Level : Natural := 0;\n+\n+      function Indentation return String is ((1 .. 3 * Level => ' '));\n+      --  Indentation string of space characters. We can't use the Indent\n+      --  primitive, because we want this indentation after the \"--\".\n+\n+      procedure Pre (T : Node_Or_Entity_Type);\n+      procedure Post (T : Node_Or_Entity_Type);\n+      --  Pre and Post actions passed to Iterate_Types\n+\n+      procedure Pre (T : Node_Or_Entity_Type) is\n+      begin\n+         if not Type_Table (T).Allow_Overlap then\n+            Put (S, \"--  \\1\\2\\n\", Indentation, Image (T));\n+         end if;\n+\n+         Level := Level + 1;\n+      end Pre;\n+\n+      procedure Post (T : Node_Or_Entity_Type) is\n+      begin\n+         Level := Level - 1;\n+\n+         if not Type_Table (T).Allow_Overlap then\n+            --  Put out an \"end\" line only if there are many descendants, for\n+            --  an arbitrary definition of \"many\".\n+\n+            if Num_Concrete_Descendants (T) > 10 then\n+               Put (S, \"--  \\1end \\2\\n\", Indentation, Image (T));\n+            end if;\n+         end if;\n+      end Post;\n+\n+      N_Or_E : constant String :=\n+        (case Root is\n+           when Node_Kind => \"nodes\",\n+           when others => \"entities\");  -- Entity_Kind\n+\n+   begin\n+      Put (S, \"--  Type hierarchy for \\1\\n\", N_Or_E);\n+      Put (S, \"--\\n\");\n+\n+      Iterate_Types (Root, Pre'Access, Post'Access);\n+\n+      Put (S, \"--\\n\");\n+      Put (S, \"--  End type hierarchy for \\1\\n\\n\", N_Or_E);\n+   end Put_Type_Hierarchy;\n+\n+   function Pos (T : Concrete_Type) return Root_Nat is\n+      First : constant Concrete_Type :=\n+        (if T in Concrete_Node then Concrete_Node'First\n+         else Concrete_Entity'First);\n+   begin\n+      return Type_Enum'Pos (T) - Type_Enum'Pos (First);\n+   end Pos;\n+\n+   Stdout : Sink'Class renames Files.Standard_Output.all;\n+\n+   --  The following procedures are for use in gdb. They use the 'Put_Image\n+   --  attribute. That is commented out, because we don't want this new feature\n+   --  used in the compiler. If you need this for debugging, just uncomment\n+   --  those lines back in, and rebuild.\n+\n+   pragma Warnings (Off);\n+   procedure Ptypes (V : Type_Vector) is\n+   begin\n+--      Type_Vector'Put_Image (Stdout, V);\n+      New_Line (Stdout);\n+      Flush (Stdout);\n+   end Ptypes;\n+\n+   procedure Pfields (V : Field_Vector) is\n+   begin\n+--      Field_Vector'Put_Image (Stdout, V);\n+      New_Line (Stdout);\n+      Flush (Stdout);\n+   end Pfields;\n+   pragma Warnings (On);\n+\n+end Gen_IL.Utils;"}, {"sha": "f264a5f5650a8ee776b1156197efab11ea6c6813", "filename": "gcc/ada/gen_il-utils.ads", "status": "added", "additions": 558, "deletions": 0, "changes": 558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-utils.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il-utils.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-utils.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,558 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                          G E N _ I L . U T I L S                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2020-2021, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Vectors; use Ada.Containers;\n+\n+with Gen_IL.Types;  use Gen_IL.Types;\n+with Gen_IL.Fields; use Gen_IL.Fields;\n+\n+package Gen_IL.Utils is\n+\n+   subtype Type_Enum is Opt_Type_Enum\n+     range Opt_Type_Enum'Succ (No_Type) .. Opt_Type_Enum'Last;\n+   --  Enumeration of types -- Opt_Type_Enum without the special null value\n+   --  No_Type.\n+\n+   subtype Node_Or_Entity_Type is\n+     Type_Enum range\n+       Type_Enum'Succ (Between_Special_And_Abstract_Node_Types) ..\n+         Type_Enum'Last;\n+\n+   subtype Abstract_Type is\n+     Type_Enum range\n+       Type_Enum'Succ (Between_Special_And_Abstract_Node_Types) ..\n+         Type_Enum'Pred (Between_Abstract_Entity_And_Concrete_Node_Types);\n+   subtype Abstract_Node is\n+     Abstract_Type range\n+       Type_Enum'Succ (Between_Special_And_Abstract_Node_Types) ..\n+         Type_Enum'Pred (Between_Abstract_Node_And_Abstract_Entity_Types);\n+   subtype Abstract_Entity is\n+     Abstract_Type range\n+       Type_Enum'Succ (Between_Abstract_Node_And_Abstract_Entity_Types) ..\n+         Type_Enum'Pred (Between_Abstract_Entity_And_Concrete_Node_Types);\n+\n+   subtype Concrete_Type is\n+     Type_Enum range\n+       Type_Enum'Succ (Between_Abstract_Entity_And_Concrete_Node_Types) ..\n+         Type_Enum'Last;\n+   subtype Concrete_Node is\n+     Concrete_Type range\n+       Type_Enum'Succ (Between_Abstract_Entity_And_Concrete_Node_Types) ..\n+         Type_Enum'Pred (Between_Concrete_Node_And_Concrete_Entity_Types);\n+   subtype Concrete_Entity is\n+     Concrete_Type range\n+       Type_Enum'Succ (Between_Concrete_Node_And_Concrete_Entity_Types) ..\n+         Type_Enum'Last;\n+\n+   subtype Root_Type is Abstract_Type with\n+        Predicate => Root_Type in Node_Kind | Entity_Kind;\n+\n+   subtype Node_Type is Node_Or_Entity_Type with\n+        Predicate => Node_Type in Abstract_Node | Concrete_Node;\n+   subtype Entity_Type is Node_Or_Entity_Type with\n+        Predicate => Entity_Type in Abstract_Entity | Concrete_Entity;\n+\n+   subtype Special_Type is Type_Enum range\n+     Flag .. Type_Enum'Pred (Between_Special_And_Abstract_Node_Types);\n+\n+   subtype Traversal_Type is Type_Enum with Predicate =>\n+     Traversal_Type in Node_Id | List_Id | Node_Type;\n+   --  These are the types of fields traversed by Traverse_Func\n+\n+   subtype Entity_Node is Node_Type with\n+     Predicate => Entity_Node in\n+        N_Defining_Character_Literal\n+      | N_Defining_Identifier\n+      | N_Defining_Operator_Symbol;\n+\n+   function Image (T : Opt_Type_Enum) return String;\n+\n+   function Image_Sans_N (T : Opt_Type_Enum) return String;\n+   --  Returns the image without the leading \"N_\"\n+\n+   subtype Boundaries is Type_Enum with\n+        Predicate => Boundaries in\n+          Between_Abstract_Node_And_Abstract_Entity_Types |\n+          Between_Abstract_Entity_And_Concrete_Node_Types |\n+          Between_Concrete_Node_And_Concrete_Entity_Types;\n+\n+   ----------------\n+\n+   type Type_Set is array (Type_Enum) of Boolean;\n+\n+   type Type_Index is new Positive;\n+   subtype Type_Count is Type_Index'Base range 0 .. Type_Index'Last;\n+   package Type_Vectors is new Vectors (Type_Index, Type_Enum);\n+   use Type_Vectors;\n+   subtype Type_Vector is Type_Vectors.Vector;\n+\n+   procedure Ptypes (V : Type_Vector); -- for debugging\n+\n+   type Type_Array is array (Type_Index range <>) of Type_Enum;\n+\n+   subtype Field_Enum is Opt_Field_Enum\n+     range Opt_Field_Enum'Succ (No_Field) .. Opt_Field_Enum'Last;\n+   --  Enumeration of fields -- Opt_Field_Enum without the special null value\n+   --  No_Field.\n+\n+   subtype Node_Header_Type is Type_Enum range\n+     Nkind_Type .. Union_Id;\n+   subtype Node_Header_Field is Field_Enum with Predicate =>\n+     Node_Header_Field in Nkind .. Link | Ekind;\n+\n+   type Fields_Present_Array is array (Field_Enum) of Type_Set;\n+\n+   type Field_Set is array (Field_Enum) of Boolean;\n+   type Fields_Per_Node_Type is array (Node_Or_Entity_Type) of Field_Set;\n+\n+   type Field_Index is new Positive;\n+   subtype Field_Count is Field_Index'Base range 0 .. Field_Index'Last;\n+   package Field_Vectors is new Vectors (Field_Index, Field_Enum);\n+   subtype Field_Vector is Field_Vectors.Vector;\n+   procedure Pfields (V : Field_Vector); -- for debugging\n+\n+   subtype Opt_Abstract_Type is Opt_Type_Enum with\n+        Predicate => Opt_Abstract_Type = No_Type or\n+        Opt_Abstract_Type in Abstract_Type;\n+\n+   procedure Put_Images (S : in out Sink'Class; U : Type_Vector);\n+   procedure Put_Id_Images (S : in out Sink'Class; U : Type_Vector);\n+   --  Put the types with vertical bars in between, as in\n+   --     N_This | N_That | N_Other\n+   --  or\n+   --     N_This_Id | N_That_Id | N_Other_Id\n+\n+   function Id_Image (T : Type_Enum) return String;\n+   function Get_Set_Id_Image (T : Type_Enum) return String;\n+\n+   type Bit_Offset is new Root_Nat range 0 .. 32_000 - 1;\n+   --  There are fewer than 1000 fields. But offsets are in size units (1 bit\n+   --  for flags, 32 bits for most others, also 2, 4, and 8).\n+\n+   type Field_Offset is new Bit_Offset;\n+\n+   type Type_Info (Is_Union : Boolean) is record\n+      Parent : Opt_Abstract_Type;\n+      --  Parent of this type (single inheritance). No_Type for a root\n+      --  type (Node_Kind or Entity_Kind). For union types, this is\n+      --  a root type.\n+\n+      Children : Type_Vector;\n+      --  Inverse of Parent\n+\n+      Concrete_Descendants : Type_Vector;\n+\n+      case Is_Union is\n+         when True =>\n+            null;\n+\n+         when False =>\n+            First, Last : Concrete_Type;\n+            --  This type includes concrete types in the range First..Last. For\n+            --  a concrete type, First=Last. For an abstract type, First..Last\n+            --  includes two or more types.\n+\n+            Fields : Field_Vector;\n+\n+            Allow_Overlap : Boolean;\n+            --  True to allow overlapping subranges\n+      end case;\n+   end record;\n+\n+   type Type_Info_Ptr is access all Type_Info;\n+\n+   Type_Table : array (Node_Or_Entity_Type) of Type_Info_Ptr;\n+   --  Table mapping from enumeration literals representing types to\n+   --  information about the type.\n+\n+   function Num_Concrete_Descendants\n+     (T : Node_Or_Entity_Type) return Natural;\n+   --  Number of concrete descendants of T, including (if T is concrete)\n+   --  itself.\n+\n+   type Field_Default_Value is\n+     (No_Default,\n+      Default_Empty, -- Node_Id\n+      Default_No_List, Default_Empty_List, -- List_Id\n+      Default_False, Default_True, -- Flag\n+      Default_No_Elist, -- Elist_Id\n+      Default_No_Name, -- Name_Id\n+      Default_Uint_0); -- Uint\n+   --  Default value for a field in the Nmake functions. No_Default if the\n+   --  field parameter has no default value. Otherwise this indicates the\n+   --  default value used, which must matcht the type of the field.\n+\n+   type Type_Only_Enum is\n+     (No_Type_Only, Base_Type_Only, Impl_Base_Type_Only, Root_Type_Only);\n+   --  ????These correspond to the \"[base type only]\", \"[implementation base\n+   --  type only]\", and \"[root type only]\" annotations in the old einfo.ads.\n+   --  Move the relevant comments here. There is no comment explaining\n+   --  [root type only] in the old einfo.ads.\n+\n+   function Image (Default : Field_Default_Value) return String;\n+   function Value_Image (Default : Field_Default_Value) return String;\n+\n+   type Field_Info is record\n+      Have_This_Field : Type_Vector;\n+\n+      Field_Type      : Type_Enum;\n+      --  Type of the field. Currently, we use Node_Id for all node-valued\n+      --  fields, but we could narrow down to children of that. Similar for\n+      --  Entity_Id.\n+\n+      Default_Value   : Field_Default_Value;\n+      Type_Only       : Type_Only_Enum;\n+      Pre             : String_Ptr;\n+\n+      Offset          : Field_Offset;\n+      --  Offset of the field, in units of the field size. So if a field is 4\n+      --  bits, it starts at bit number Offset*4 from the start of the node.\n+   end record;\n+\n+   type Field_Info_Ptr is access all Field_Info;\n+\n+   Field_Table : array (Field_Enum) of Field_Info_Ptr;\n+   --  Table mapping from enumeration literals representing fields to\n+   --  information about the field.\n+\n+   procedure Verify_Type_Table;\n+\n+   ----------------\n+\n+   subtype Node_Field is\n+     Field_Enum range\n+       Field_Enum'First ..\n+         Field_Enum'Pred (Between_Node_And_Entity_Fields);\n+\n+   subtype Entity_Field is\n+     Field_Enum range\n+       Field_Enum'Succ (Between_Node_And_Entity_Fields) ..\n+         Field_Enum'Last;\n+\n+   function Image (F : Opt_Field_Enum) return String;\n+\n+   procedure Nil (T : Node_Or_Entity_Type);\n+   --  Null procedure\n+\n+   procedure Iterate_Types\n+     (Root  : Node_Or_Entity_Type;\n+      Pre, Post : not null access procedure (T : Node_Or_Entity_Type) :=\n+        Nil'Access);\n+   --  Iterate top-down on the type hierarchy. Call Pre and Post before and\n+   --  after walking child types. Note that this ignores union types, because\n+   --  they are nonhierarchical.\n+\n+   function Is_Descendant (Ancestor, Descendant : Node_Or_Entity_Type)\n+     return Boolean;\n+   --  True if Descendant is a descendant of Ancestor; that is,\n+   --  True if Ancestor is an ancestor of Descendant. True for\n+   --  a type itself.\n+\n+   procedure Put_Type_Hierarchy (S : in out Sink'Class; Root : Root_Type);\n+\n+   function Pos (T : Concrete_Type) return Root_Nat;\n+   --  Return Node_Kind'Pos (T) or Entity_Kind'Pos (T)\n+\n+   ----------------\n+\n+   --  The same field can be syntactic in some nodes but semantic in others:\n+\n+   type Field_Desc is record\n+      F : Field_Enum;\n+      Is_Syntactic : Boolean;\n+   end record;\n+\n+   type Field_Sequence_Index is new Positive;\n+   type Field_Sequence is array (Field_Sequence_Index range <>) of Field_Desc;\n+   No_Fields : constant Field_Sequence := (1 .. 0 => <>);\n+\n+   type Field_Array is array (Bit_Offset range <>) of Opt_Field_Enum;\n+   type Field_Array_Ptr is access all Field_Array;\n+\n+   type Type_Layout_Array is array (Concrete_Type) of Field_Array_Ptr;\n+   --  Mapping from types to mappings from offsets to fields\n+\n+   type Offset_To_Fields_Mapping is\n+     array (Bit_Offset range <>) of Field_Array_Ptr;\n+   --  Mapping from bit offsets to fields using that offset\n+\n+   function First_Abstract (Root : Root_Type) return Abstract_Type;\n+   function Last_Abstract (Root : Root_Type) return Abstract_Type;\n+   --  First and Last abstract types descended from the Root\n+\n+   function First_Concrete (Root : Root_Type) return Concrete_Type;\n+   function Last_Concrete (Root : Root_Type) return Concrete_Type;\n+   --  First and Last concrete types descended from the Root\n+\n+   function First_Field (Root : Root_Type) return Field_Enum;\n+   function Last_Field (Root : Root_Type) return Field_Enum;\n+   --  First and Last node or entity fields\n+\n+   function Node_Or_Entity (Root : Root_Type) return String;\n+   --  Return \"Node\" or \"Entity\" depending on whether Root = Node_Kind\n+\n+   type Sinfo_Node_Order_Index is new Positive;\n+   Sinfo_Node_Order :\n+     constant array (Sinfo_Node_Order_Index range <>) of Node_Type :=\n+     --  The order in which the documentation of node kinds appears in the old\n+     --  sinfo.ads. This is the same order of the functions in Nmake.\n+     --  Sinfo_Node_Order was constructed  by massaging nmake.ads.\n+     (N_Unused_At_Start,\n+      N_Unused_At_End,\n+      N_Identifier,\n+      N_Integer_Literal,\n+      N_Real_Literal,\n+      N_Character_Literal,\n+      N_String_Literal,\n+      N_Pragma,\n+      N_Pragma_Argument_Association,\n+      N_Defining_Identifier,\n+      N_Full_Type_Declaration,\n+      N_Subtype_Declaration,\n+      N_Subtype_Indication,\n+      N_Object_Declaration,\n+      N_Number_Declaration,\n+      N_Derived_Type_Definition,\n+      N_Range_Constraint,\n+      N_Range,\n+      N_Enumeration_Type_Definition,\n+      N_Defining_Character_Literal,\n+      N_Signed_Integer_Type_Definition,\n+      N_Modular_Type_Definition,\n+      N_Floating_Point_Definition,\n+      N_Real_Range_Specification,\n+      N_Ordinary_Fixed_Point_Definition,\n+      N_Decimal_Fixed_Point_Definition,\n+      N_Digits_Constraint,\n+      N_Unconstrained_Array_Definition,\n+      N_Constrained_Array_Definition,\n+      N_Component_Definition,\n+      N_Discriminant_Specification,\n+      N_Index_Or_Discriminant_Constraint,\n+      N_Discriminant_Association,\n+      N_Record_Definition,\n+      N_Component_List,\n+      N_Component_Declaration,\n+      N_Variant_Part,\n+      N_Variant,\n+      N_Others_Choice,\n+      N_Access_To_Object_Definition,\n+      N_Access_Function_Definition,\n+      N_Access_Procedure_Definition,\n+      N_Access_Definition,\n+      N_Incomplete_Type_Declaration,\n+      N_Explicit_Dereference,\n+      N_Indexed_Component,\n+      N_Slice,\n+      N_Selected_Component,\n+      N_Attribute_Reference,\n+      N_Aggregate,\n+      N_Component_Association,\n+      N_Extension_Aggregate,\n+      N_Iterated_Component_Association,\n+      N_Delta_Aggregate,\n+      N_Iterated_Element_Association,\n+      N_Null,\n+      N_And_Then,\n+      N_Or_Else,\n+      N_In,\n+      N_Not_In,\n+      N_Op_And,\n+      N_Op_Or,\n+      N_Op_Xor,\n+      N_Op_Eq,\n+      N_Op_Ne,\n+      N_Op_Lt,\n+      N_Op_Le,\n+      N_Op_Gt,\n+      N_Op_Ge,\n+      N_Op_Add,\n+      N_Op_Subtract,\n+      N_Op_Concat,\n+      N_Op_Multiply,\n+      N_Op_Divide,\n+      N_Op_Mod,\n+      N_Op_Rem,\n+      N_Op_Expon,\n+      N_Op_Plus,\n+      N_Op_Minus,\n+      N_Op_Abs,\n+      N_Op_Not,\n+      N_If_Expression,\n+      N_Case_Expression,\n+      N_Case_Expression_Alternative,\n+      N_Quantified_Expression,\n+      N_Type_Conversion,\n+      N_Qualified_Expression,\n+      N_Allocator,\n+      N_Null_Statement,\n+      N_Label,\n+      N_Assignment_Statement,\n+      N_Target_Name,\n+      N_If_Statement,\n+      N_Elsif_Part,\n+      N_Case_Statement,\n+      N_Case_Statement_Alternative,\n+      N_Loop_Statement,\n+      N_Iteration_Scheme,\n+      N_Loop_Parameter_Specification,\n+      N_Iterator_Specification,\n+      N_Block_Statement,\n+      N_Exit_Statement,\n+      N_Goto_Statement,\n+      N_Subprogram_Declaration,\n+      N_Abstract_Subprogram_Declaration,\n+      N_Function_Specification,\n+      N_Procedure_Specification,\n+      N_Designator,\n+      N_Defining_Program_Unit_Name,\n+      N_Operator_Symbol,\n+      N_Defining_Operator_Symbol,\n+      N_Parameter_Specification,\n+      N_Subprogram_Body,\n+      N_Procedure_Call_Statement,\n+      N_Function_Call,\n+      N_Parameter_Association,\n+      N_Simple_Return_Statement,\n+      N_Extended_Return_Statement,\n+      N_Expression_Function,\n+      N_Package_Declaration,\n+      N_Package_Specification,\n+      N_Package_Body,\n+      N_Private_Type_Declaration,\n+      N_Private_Extension_Declaration,\n+      N_Use_Package_Clause,\n+      N_Use_Type_Clause,\n+      N_Object_Renaming_Declaration,\n+      N_Exception_Renaming_Declaration,\n+      N_Package_Renaming_Declaration,\n+      N_Subprogram_Renaming_Declaration,\n+      N_Generic_Package_Renaming_Declaration,\n+      N_Generic_Procedure_Renaming_Declaration,\n+      N_Generic_Function_Renaming_Declaration,\n+      N_Task_Type_Declaration,\n+      N_Single_Task_Declaration,\n+      N_Task_Definition,\n+      N_Task_Body,\n+      N_Protected_Type_Declaration,\n+      N_Single_Protected_Declaration,\n+      N_Protected_Definition,\n+      N_Protected_Body,\n+      N_Entry_Declaration,\n+      N_Accept_Statement,\n+      N_Entry_Body,\n+      N_Entry_Body_Formal_Part,\n+      N_Entry_Index_Specification,\n+      N_Entry_Call_Statement,\n+      N_Requeue_Statement,\n+      N_Delay_Until_Statement,\n+      N_Delay_Relative_Statement,\n+      N_Selective_Accept,\n+      N_Accept_Alternative,\n+      N_Delay_Alternative,\n+      N_Terminate_Alternative,\n+      N_Timed_Entry_Call,\n+      N_Entry_Call_Alternative,\n+      N_Conditional_Entry_Call,\n+      N_Asynchronous_Select,\n+      N_Triggering_Alternative,\n+      N_Abortable_Part,\n+      N_Abort_Statement,\n+      N_Compilation_Unit,\n+      N_Compilation_Unit_Aux,\n+      N_With_Clause,\n+      N_Subprogram_Body_Stub,\n+      N_Package_Body_Stub,\n+      N_Task_Body_Stub,\n+      N_Protected_Body_Stub,\n+      N_Subunit,\n+      N_Exception_Declaration,\n+      N_Handled_Sequence_Of_Statements,\n+      N_Exception_Handler,\n+      N_Raise_Statement,\n+      N_Raise_Expression,\n+      N_Generic_Subprogram_Declaration,\n+      N_Generic_Package_Declaration,\n+      N_Package_Instantiation,\n+      N_Procedure_Instantiation,\n+      N_Function_Instantiation,\n+      N_Generic_Association,\n+      N_Formal_Object_Declaration,\n+      N_Formal_Type_Declaration,\n+      N_Formal_Private_Type_Definition,\n+      N_Formal_Derived_Type_Definition,\n+      N_Formal_Incomplete_Type_Definition,\n+      N_Formal_Discrete_Type_Definition,\n+      N_Formal_Signed_Integer_Type_Definition,\n+      N_Formal_Modular_Type_Definition,\n+      N_Formal_Floating_Point_Definition,\n+      N_Formal_Ordinary_Fixed_Point_Definition,\n+      N_Formal_Decimal_Fixed_Point_Definition,\n+      N_Formal_Concrete_Subprogram_Declaration,\n+      N_Formal_Abstract_Subprogram_Declaration,\n+      N_Formal_Package_Declaration,\n+      N_Attribute_Definition_Clause,\n+      N_Aspect_Specification,\n+      N_Enumeration_Representation_Clause,\n+      N_Record_Representation_Clause,\n+      N_Component_Clause,\n+      N_Code_Statement,\n+      N_Op_Rotate_Left,\n+      N_Op_Rotate_Right,\n+      N_Op_Shift_Left,\n+      N_Op_Shift_Right_Arithmetic,\n+      N_Op_Shift_Right,\n+      N_Delta_Constraint,\n+      N_At_Clause,\n+      N_Mod_Clause,\n+      N_Call_Marker,\n+      N_Compound_Statement,\n+      N_Contract,\n+      N_Expanded_Name,\n+      N_Expression_With_Actions,\n+      N_Free_Statement,\n+      N_Freeze_Entity,\n+      N_Freeze_Generic_Entity,\n+      N_Implicit_Label_Declaration,\n+      N_Itype_Reference,\n+      N_Raise_Constraint_Error,\n+      N_Raise_Program_Error,\n+      N_Raise_Storage_Error,\n+      N_Push_Constraint_Error_Label,\n+      N_Push_Program_Error_Label,\n+      N_Push_Storage_Error_Label,\n+      N_Pop_Constraint_Error_Label,\n+      N_Pop_Program_Error_Label,\n+      N_Pop_Storage_Error_Label,\n+      N_Reference,\n+      N_SCIL_Dispatch_Table_Tag_Init,\n+      N_SCIL_Dispatching_Call,\n+      N_SCIL_Membership_Test,\n+      N_Unchecked_Expression,\n+      N_Unchecked_Type_Conversion,\n+      N_Validate_Unchecked_Conversion,\n+      N_Variable_Reference_Marker);\n+\n+end Gen_IL.Utils;"}, {"sha": "1a6326daa6cdefb4660dcc8825ee3a4e59f81129", "filename": "gcc/ada/gen_il.adb", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,63 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                G E N _ I L                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--           Copyright (C) 2020-2021, Free Software Foundation, Inc.        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Gen_IL is\n+\n+   function Image (X : Root_Int) return String is\n+      Result : constant String := X'Img;\n+   begin\n+      if Result (1) = ' ' then\n+         return Result (2 .. Result'Last);\n+      else\n+         return Result;\n+      end if;\n+   end Image;\n+\n+   procedure Capitalize (S : in out String) is\n+      Cap : Boolean := True;\n+   begin\n+      for X of S loop\n+         declare\n+            Old : constant Character := X;\n+         begin\n+            if Cap then\n+               X := To_Upper (X);\n+            else\n+               X := To_Lower (X);\n+            end if;\n+\n+            Cap := not (Is_Letter (Old) or else Is_Digit (Old));\n+         end;\n+      end loop;\n+   end Capitalize;\n+\n+   function Capitalize (S : String) return String is\n+   begin\n+      return Result : String (S'Range) := S do\n+         Capitalize (Result);\n+      end return;\n+   end Capitalize;\n+\n+end Gen_IL;"}, {"sha": "3b0e4ba9af1c97f217817a5603b263760331939f", "filename": "gcc/ada/gen_il.ads", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgen_il.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,309 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                G E N _ I L                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2020-2021, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Warnings (Off); -- with clauses for children\n+with Ada.Strings.Text_Output.Formatting;\n+use Ada.Strings.Text_Output, Ada.Strings.Text_Output.Formatting;\n+with Ada.Strings.Text_Output.Files; use Ada.Strings.Text_Output.Files;\n+with Ada.Strings.Text_Output.Utils; use Ada.Strings.Text_Output.Utils;\n+with Ada.Characters.Handling;       use Ada.Characters.Handling;\n+pragma Warnings (On);\n+\n+package Gen_IL is -- generate intermediate language\n+\n+   --  This package and children generates the main intermediate language used\n+   --  by the compiler, which is a decorated syntax tree.\n+\n+   --  Here's what the hand-written and generated code looks like. The make\n+   --  files run the gen_il-main.adb program to generate the generated files\n+   --  listed below, before building the compiler proper.\n+   --\n+   --  atree.ads, atree.adb: Rewrite according to low-level\n+   --  design notes. Remove package Unchecked_Access.\n+   --  Low-level getters and setters go in Atree_Private_Part.\n+   --  These are called by the high-level automatically-generated\n+   --  getters and setters in Sinfo.Nodes and Einfo.Entities.\n+   --  Also used by Atree.Traverse_Func, and by Treepr.\n+   --\n+   --  sinfo.ads, einfo.ads: Remove getters and setters.\n+   --  Remove Write_... routines used by old Treepr.\n+   --  Keep commments describing the semantics of all the nodes,\n+   --  entities, and fields. These comments are wrong, but only\n+   --  a little, and I'm not going to try to fix them. At some\n+   --  point, we could remove the comments giving field offsets\n+   --  (e.g. \"(Flag5-Sem)\"), but for now, just note that that's\n+   --  obsolete info.\n+   --\n+   --  einfo.adb, sinfo.adb: Delete.\n+   --\n+   --  gen_il.ads, gen_il.adb: Mostly empty root package for the\n+   --  \"generate intermediate language\" program, which generates\n+   --  all the files mentioned here.\n+   --  The main program is gen_il-main.adb.\n+   --\n+   --  sinfo-utils.ads, sinfo-utils.adb, einfo-utils.ads, einfo-utils.adb:\n+   --  Move all handwritten code currently in sinfo&einfo to here,\n+   --  if it refers to stuff in sinfo-nodes.ads, einfo-entities.ads\n+   --  This includes the \"synthesized attributes\".\n+   --\n+   --  gen_il-types.ads: Enumeration type containing one literal for\n+   --  each type of interest. That includes all the Node_Kinds and\n+   --  Entity_Kinds, plus the subtypes that include multiple\n+   --  Node_Kinds and Entity_Kinds (all from the old sinfo/einfo),\n+   --  plus all field types (Uint, Ureal, Name_Id, etc).\n+   --\n+   --  gen_il-fields.ads: Enumeration of all the fields of all node\n+   --  and entity types.\n+   --\n+   --  gen_il-gen.ads, gen_il-gen.adb: Implementation of the \"compiler\"\n+   --  for the \"little language\".\n+   --\n+   --  gen_il-gen-gen_nodes.adb: Procedure to generate Sinfo.Nodes\n+   --  (by calling procedures in Gen_IL).\n+   --  This defines what abstract and concrete node types exist,\n+   --  and what fields they have. This and the next one are the\n+   --  hard part. I'm planning to generate this semi-automatically.\n+   --  But once it's working, we will maintain it by hand.\n+   --\n+   --  gen_il-gen-gen_entities.adb: Procedure to generate einfo-entities.*.\n+   --  This defines what abstract and concrete entity types exist,\n+   --  and what fields they have.\n+   --\n+   --  seinfo.ads: Generated by gen_il-main.adb. Contains declarations shared\n+   --  by Sinfo.Nodes and Einfo.Entities.\n+   --\n+   --  sinfo-nodes.ads, sinfo-nodes.adb: Generated by gen_il-main.adb\n+   --  (really by Gen_Nodes). Contains:\n+   --\n+   --      - Information in comments, such as what fields exist in what\n+   --        node kinds, which might be hard to compute by hand for\n+   --        inherited fields.\n+   --\n+   --      - Type Node_Kind. Same as the old Sinfo, but now generated.\n+   --        One enumeral for each concrete node type in Gen_Nodes.\n+   --\n+   --      - One subtype of Node_Kind for each abstract type in Gen_Nodes.\n+   --        Same as the old Sinfo, but now generated. E.g.:\n+   --\n+   --        subtype N_Representation_Clause is Node_Kind range\n+   --          N_At_Clause .. N_Attribute_Definition_Clause;\n+   --\n+   --      - One subtype of Node_Id for each abstract and concrete type,\n+   --        with a predicate requiring the right Nkind. E.g.:\n+   --\n+   --        subtype N_Representation_Clause_Id is\n+   --          Node_Id with Predicate =>\n+   --            Nkind (N_Representation_Clause_Id) in N_Representation_Clause;\n+   --\n+   --      - Getters and setters for every node field. If the field is defined\n+   --        for all node kinds in one of the above Node_Id subtypes and no\n+   --        others, then we use that as the parameter subtype:\n+   --\n+   --        function Abortable_Part\n+   --          (N : N_Asynchronous_Select_Id) return Node_Id with Inline;\n+   --\n+   --        Otherwise, we use a precondition:\n+   --\n+   --        function Abstract_Present\n+   --          (N : Node_Id) return Flag with Inline, Pre =>\n+   --          N in N_Private_Extension_Declaration_Id\n+   --             | N_Private_Type_Declaration_Id\n+   --             | N_Derived_Type_Definition_Id\n+   --             ...\n+   --\n+   --      - Type Node_Field: Enumeration of all node fields. Used by Treepr,\n+   --        and in tables below.\n+   --\n+   --      - Table of syntactic fields. For each node kind, we have a sequence\n+   --        of fields. A field is included if it exists in that node kind,\n+   --        and it is syntactic, and it is of type Node_Id or List_Id.\n+   --        Used by Traverse_Func.\n+   --\n+   --      - Table of node sizes, indexed by Node_Kind. Used by Atree when\n+   --        allocating and copying nodes.\n+   --\n+   --      - Table mapping Node_Kinds to the sequence of fields that exist in\n+   --        that Node_Kind. Used by Treepr.\n+   --\n+   --      - Node_Field_Descriptors: Table mapping fields to type and offset.\n+   --        Used by Treepr to know where to find each field, and what its\n+   --        type is, for printing.\n+   --\n+   --      - The body contains instantiations of the low-level getters and\n+   --        setters declared in Atree, e.g.:\n+   --\n+   --        function Get_List_Id is new Get_32_Bit_Field (List_Id)\n+   --           with Inline;\n+   --        procedure Set_List_Id is new Set_32_Bit_Field (List_Id)\n+   --           with Inline;\n+   --\n+   --        and bodies of the high-level getters and setters, e.g.:\n+   --\n+   --        function Actions\n+   --          (N : Node_Id) return List_Id is\n+   --        begin\n+   --           return Get_List_Id (N, 4);\n+   --        end Actions;\n+   --\n+   --  einfo-entities.ads, einfo-entities.adb: Generated by gen_il-main.adb\n+   --  (really by Gen_Entities). Contains the same sort of stuff as\n+   --  Sinfo.Nodes, except no table of syntactic fields.\n+   --\n+   --  nmake.ads, nmake.adb: Same contents as the old version, but generated by\n+   --  Gen_IL instead of xnmake.\n+   --\n+   --  treepr.adb: Rewrite to use the tables in Nodes and Entities.\n+   --\n+   --  treeprs.ads: Delete. (Was automatically generated.)\n+   --  Treepr no longer needs this; it can use 'Image on the\n+   --  enumeration types in Nodes and Entities.\n+   --\n+   --  csinfo.adb, ceinfo.adb, xsinfo.adb, xeinfo.adb, xnmake.adb,\n+   --  xtreeprs.adb, nmake.adt, treeprs.adt: Delete.\n+\n+   --  C++ code:\n+   --\n+   --  atree.h (hand-written code):\n+   --\n+   --  This code should be entirely deleted, and replaced with low-level\n+   --  getters analogous to the generic getters in Atree.  One getter for each\n+   --  field size (currently 1, 2, 4, 8, and 32 bits. No need for setters.\n+   --\n+   --  ----------------\n+   --\n+   --  fe.h (hand-written code):\n+   --\n+   --  There are comments in various places that say that gigi\n+   --  does not modify the tree. However, I discovered some stuff\n+   --  in fe.h that modifies the tree:\n+   --\n+   --  #define End_Location                     sinfo__end_location\n+   --  #define Set_Has_No_Elaboration_Code sinfo__set_has_no_elaboration_code\n+   --  #define Set_Present_Expr         sinfo__set_present_expr\n+   --\n+   --  #define Set_Alignment                    einfo__set_alignment\n+   --  #define Set_Component_Bit_Offset einfo__set_component_bit_offset\n+   --  #define Set_Component_Size               einfo__set_component_size\n+   --  #define Set_Esize                        einfo__set_esize\n+   --  #define Set_Mechanism                    einfo__set_mechanism\n+   --  #define Set_Normalized_First_Bit einfo__set_normalized_first_bit\n+   --  #define Set_Normalized_Position          einfo__set_normalized_position\n+   --  #define Set_RM_Size                      einfo__set_rm_size\n+   --\n+   --  #define Is_Entity_Name           einfo__utils__is_entity_name\n+   --  #define Get_Attribute_Definition_Clause  \\\n+   --    einfo__utils__get_attribute_definition_clause\n+   --\n+   --  These setters and some getters need to be changed because the\n+   --  setters and getters are moving from Sinfo to Sinfo.Nodes,\n+   --  and from Einfo to Einfo.Entities. The last two will be in Einfo.Utils.\n+   --\n+   --  ----------------\n+   --\n+   --  sinfo.h (tool-generated code):\n+   --\n+   --  A bunch of #defines for the node kinds. These can remain the same.\n+   --\n+   --  A bunch of calls to SUBTYPE (macro defined in gcc-interface/ada.h).\n+   --  These can remain the same.\n+   --\n+   --  A bunch of getters (no setters), like:\n+   --\n+   --     INLINE Boolean   Abort_Present                  (Node_Id N)\n+   --        { return Flag15 (N); }\n+   --\n+   --  Change this to call the new low-level getters.\n+   --  Something like:\n+   --\n+   --     INLINE Boolean   Abort_Present                  (Node_Id N)\n+   --        { return Get_Flag (N, 15); }\n+   --\n+   --  Generate the low-level getters in the same file, before the above\n+   --  high-level getters, one for each field type:\n+   --\n+   --        Flag\n+   --        Node_Id\n+   --        List_Id\n+   --        Elist_Id\n+   --        Name_Id\n+   --        String_Id\n+   --        Uint\n+   --        Ureal\n+   --        Node_Kind\n+   --        Entity_Kind\n+   --        Source_Ptr\n+   --        Small_Paren_Count_Type\n+   --        Union_Id\n+   --        Convention_Id\n+   --        Component_Alignment_Kind\n+   --        Float_Rep_Kind\n+   --        Mechanism_Type\n+   --\n+   --  These are in types.h.\n+   --\n+   --  ----------------\n+   --\n+   --  einfo.h (tool-generated code):\n+   --\n+   --  Can mostly remain the same, except:\n+   --\n+   --      Call low-level getters, as for sinfo.h.\n+   --\n+   --      The getters that are NOT inlined will be moved from\n+   --      Einfo to Einfo.Entities.\n+   --      I don't understand why some are not inlined (e.g Float_Rep?).\n+   --      Most are not inlined because they are synthesized.\n+   --      Maybe that should be hand written, and moved to a different file.\n+   --      Or maybe Gen_IL should know about these fields.\n+   --\n+   --      We have code like:\n+   --         INLINE B Is_Subprogram_Or_Generic_Subprogram (E Id)\n+   --            { return IN (Ekind (Id), Subprogram_Kind) || IN (Ekind (Id),\n+   --              Generic_Subprogram_Kind); }\n+   --      That should be hand written, and moved to atree.h or fe.h.\n+   --      Is_Record_Type requires special treatment, because Record_Kind is\n+   --      a nonhierarchical type.\n+   --\n+   --  Looks like the getters are in alphabetical order.\n+   --  Except for the Is_..._Type ones.\n+\n+   --  Misc declarations used throughout:\n+\n+   type Root_Int is new Integer;\n+   function Image (X : Root_Int) return String;\n+   --  Without the extra blank. You can derive from Root_Int or the subtypes\n+   --  below, and inherit a convenient Image function that leaves out that\n+   --  blank.\n+\n+   subtype Root_Nat is Root_Int range 0 .. Root_Int'Last;\n+   subtype Root_Pos is Root_Int range 1 .. Root_Int'Last;\n+\n+   function Capitalize (S : String) return String;\n+   procedure Capitalize (S : in out String);\n+   --  Turns an identifier into Mixed_Case\n+\n+   type String_Ptr is access all String;\n+\n+end Gen_IL;"}, {"sha": "1928273a707c602a6aae3364cb7bf6a1c96801fd", "filename": "gcc/ada/get_targ.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fget_targ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fget_targ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_targ.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -37,7 +37,6 @@\n --  the Wide_Character_Type uses twice the size of a C char, instead of the\n --  size of wchar_t.\n \n-with Einfo; use Einfo;\n with Types; use Types;\n \n package Get_Targ is"}, {"sha": "0a78fad2c078b497c660df3d81f9f5d88b51452b", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Alloc;\n with Aspects;  use Aspects;\n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Namet;    use Namet;\n@@ -39,7 +41,9 @@ with Sem_Eval; use Sem_Eval;\n with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Table;\n "}, {"sha": "31d0018e1f05242b738f382e0adb27a8cdb760e1", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -65,7 +65,9 @@ with Sem_Eval;\n with Sem_Prag;\n with Sem_Type;\n with Set_Targ;\n-with Sinfo;     use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;    use Sinput;\n with Sinput.L;  use Sinput.L;\n with Snames;    use Snames;\n@@ -610,12 +612,6 @@ procedure Gnat1drv is\n          Ttypes.Target_Strict_Alignment := True;\n       end if;\n \n-      --  Increase size of allocated entities if debug flag -gnatd.N is set\n-\n-      if Debug_Flag_Dot_NN then\n-         Atree.Num_Extension_Nodes := Atree.Num_Extension_Nodes + 1;\n-      end if;\n-\n       --  Disable static allocation of dispatch tables if -gnatd.t is enabled.\n       --  The front end's layout phase currently treats types that have\n       --  discriminant-dependent arrays as not being static even when a\n@@ -1093,10 +1089,6 @@ begin\n       --  Lib.Initialize needs to be called before Scan_Compiler_Arguments,\n       --  because it initializes a table filled by Scan_Compiler_Arguments.\n \n-      --  Atree.Initialize needs to be called after Scan_Compiler_Arguments,\n-      --  because the value specified by the -gnaten switch is used by\n-      --  Atree.Initialize.\n-\n       Osint.Initialize;\n       Fmap.Reset_Tables;\n       Lib.Initialize;\n@@ -1720,10 +1712,6 @@ begin\n \n    <<End_Of_Program>>\n \n-   if Debug_Flag_Dot_AA then\n-      Atree.Print_Statistics;\n-   end if;\n-\n --  The outer exception handler handles an unrecoverable error\n \n exception"}, {"sha": "eb023dbe3ab439dfac8d27e8c2c4bcbb1c7f8eb8", "filename": "gcc/ada/gnat_cuda.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgnat_cuda.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fgnat_cuda.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_cuda.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,14 +25,14 @@\n \n --  This package defines CUDA-specific datastructures and functions.\n \n-with Atree;    use Atree;\n with Debug;    use Debug;\n with Elists;   use Elists;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Rtsfind;  use Rtsfind;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Stringt;  use Stringt;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;"}, {"sha": "a5ba1b1b5c874bdad6e9bb446ed369084b191391", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -23,9 +23,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Atree;    use Atree;\n with Errout;   use Errout;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Fname.UF; use Fname.UF;\n with Lib;      use Lib;\n with Namet;    use Namet;"}, {"sha": "4bd7ea10c7b5ae4a24580ab493777e3313501d92", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,9 @@ with Alloc;\n with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Expander; use Expander;\n@@ -49,7 +51,9 @@ with Sem_Ch12; use Sem_Ch12;\n with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;"}, {"sha": "e9e851aeb28151af354a3bcd15121c7b05299392", "filename": "gcc/ada/itypes.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fitypes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fitypes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fitypes.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -23,9 +23,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Atree;    use Atree;\n+with Einfo.Utils; use Einfo.Utils;\n with Sem;      use Sem;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Stand;    use Stand;\n with Targparm; use Targparm;\n with Uintp;    use Uintp;"}, {"sha": "8188ca88611bf02f751031127988ce4c1a7dc8a7", "filename": "gcc/ada/itypes.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fitypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fitypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fitypes.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,8 @@\n \n --  This package contains declarations for handling of implicit types\n \n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n with Sem_Util; use Sem_Util;\n with Types;    use Types;\n "}, {"sha": "1b9d9eea30aa6e95bf197f08995554a2023394f1", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,14 +25,18 @@\n \n with Atree;    use Atree;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Opt;      use Opt;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;"}, {"sha": "991496e939c92fd3b345421a606a8aba9e68335a", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,8 @@\n \n with Atree;    use Atree;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n with Errout;   use Errout;\n with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n@@ -38,7 +39,9 @@ with Output;   use Output;\n with Par;\n with Restrict; use Restrict;\n with Scn;      use Scn;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Sinput.L; use Sinput.L;\n with Stand;    use Stand;"}, {"sha": "38c9fd6d603488ba8c7b6db29dc769d50e03e93a", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,9 @@ with ALI;      use ALI;\n with Atree;    use Atree;\n with Casing;   use Casing;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n@@ -46,7 +48,9 @@ with Rident;   use Rident;\n with Stand;    use Stand;\n with Scn;      use Scn;\n with Sem_Eval; use Sem_Eval;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stringt;  use Stringt;"}, {"sha": "a56e005440f26de11dc3c76df52b9bfb2d83635a", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -23,7 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Einfo;       use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n with Nmake;       use Nmake;\n with SPARK_Xrefs; use SPARK_Xrefs;\n "}, {"sha": "2bd311c21c387d937297ace49a16a13075f06502", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,6 +25,8 @@\n \n with Atree;    use Atree;\n with Csets;    use Csets;\n+with Einfo; use Einfo;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Lib.Util; use Lib.Util;\n@@ -37,7 +39,9 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stringt;  use Stringt;"}, {"sha": "55a92515740a0a70693dd074fe2839341055074c", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,7 @@\n --  This package contains for collecting and outputting cross-reference\n --  information.\n \n-with Einfo;       use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n with SPARK_Xrefs;\n \n package Lib.Xref is"}, {"sha": "9998ba0459e587cb64ae3ae35581159cbddf0e66", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -29,11 +29,13 @@ pragma Style_Checks (All_Checks);\n \n with Atree;    use Atree;\n with Csets;    use Csets;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Output;   use Output;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Sinput;   use Sinput;\n with Stand;    use Stand;\n with Stringt;  use Stringt;"}, {"sha": "942f1518229380aadebd0c08a3f26648aa51e9cf", "filename": "gcc/ada/libgnat/a-stobfi.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flibgnat%2Fa-stobfi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flibgnat%2Fa-stobfi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stobfi.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -62,7 +62,7 @@ package body Ada.Strings.Text_Output.Basic_Files is\n    is\n    begin\n       return Create_From_FD\n-        (OS.Create_File (Name, Fmode => OS.Text),\n+        (OS.Create_File (Name, Fmode => OS.Binary),\n          Indent_Amount, Chunk_Length);\n    end Create_File;\n \n@@ -73,7 +73,7 @@ package body Ada.Strings.Text_Output.Basic_Files is\n    is\n    begin\n       return Create_From_FD\n-        (OS.Create_New_File (Name, Fmode => OS.Text),\n+        (OS.Create_New_File (Name, Fmode => OS.Binary),\n          Indent_Amount, Chunk_Length);\n    end Create_New_File;\n "}, {"sha": "3c5433866a102cea2a59678511b9fabac17ae3e0", "filename": "gcc/ada/libgnat/a-stoubu.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flibgnat%2Fa-stoubu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flibgnat%2Fa-stoubu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stoubu.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -78,7 +78,7 @@ package body Ada.Strings.Text_Output.Buffers is\n       S.Cur_Chunk.Next :=\n         Text_Output.Chunk_Access (Chunk_Access'(new Chunk (S.Chunk_Length)));\n       S.Cur_Chunk := S.Cur_Chunk.Next;\n-      S.Num_Extra_Chunks := @ + 1;\n+      S.Num_Extra_Chunks := S.Num_Extra_Chunks + 1;\n       S.Last := 0;\n    end Full_Method;\n "}, {"sha": "3444e3b47d98ce2ea97dde3cb032dd9ac13a4d70", "filename": "gcc/ada/libgnat/a-stoufi.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flibgnat%2Fa-stoufi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flibgnat%2Fa-stoufi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stoufi.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -46,7 +46,7 @@ package body Ada.Strings.Text_Output.Files is\n    is\n    begin\n       if FD = OS.Invalid_FD then\n-         raise Program_Error with OS.Errno_Message;\n+         raise Program_Error;\n       end if;\n       return Result : File (Chunk_Length) do\n          Result.Indent_Amount := Indent_Amount;\n@@ -62,7 +62,7 @@ package body Ada.Strings.Text_Output.Files is\n    is\n    begin\n       return Create_From_FD\n-        (OS.Create_File (Name, Fmode => OS.Text),\n+        (OS.Create_File (Name, Fmode => OS.Binary),\n          Indent_Amount, Chunk_Length);\n    end Create_File;\n \n@@ -73,7 +73,7 @@ package body Ada.Strings.Text_Output.Files is\n    is\n    begin\n       return Create_From_FD\n-        (OS.Create_New_File (Name, Fmode => OS.Text),\n+        (OS.Create_New_File (Name, Fmode => OS.Binary),\n          Indent_Amount, Chunk_Length);\n    end Create_New_File;\n \n@@ -90,7 +90,7 @@ package body Ada.Strings.Text_Output.Files is\n       if S.FD not in OS.Standout | OS.Standerr then -- Don't close these\n          OS.Close (S.FD, Status);\n          if not Status then\n-            raise Program_Error with OS.Errno_Message;\n+            raise Program_Error;\n          end if;\n       end if;\n    end Close;\n@@ -103,7 +103,7 @@ package body Ada.Strings.Text_Output.Files is\n         OS.Write (S.FD, S.Cur_Chunk.Chars'Address, S.Last);\n    begin\n       if Res /= S.Last then\n-         raise Program_Error with OS.Errno_Message;\n+         raise Program_Error;\n       end if;\n       S.Last := 0;\n    end Flush_Method;"}, {"sha": "6b8f72ba84d84d08013b89b2b04a30b848cef630", "filename": "gcc/ada/libgnat/a-stouut.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flibgnat%2Fa-stouut.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flibgnat%2Fa-stouut.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stouut.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -57,7 +57,7 @@ package body Ada.Strings.Text_Output.Utils is\n \n    procedure Put_Octet (S : in out Sink'Class; Item : Character) is\n    begin\n-      S.Last := @ + 1;\n+      S.Last := S.Last + 1;\n       S.Cur_Chunk.Chars (S.Last) := Item;\n       pragma Assert (S.Chunk_Length = S.Cur_Chunk.Chars'Length);\n       if S.Last = S.Chunk_Length then\n@@ -75,7 +75,7 @@ package body Ada.Strings.Text_Output.Utils is\n       if S.Column = 1 then\n          Tab_To_Column (S, S.Indentation + 1);\n       end if;\n-      S.Column := @ + 1;\n+      S.Column := S.Column + 1;\n    end Adjust_Column;\n \n    procedure Put_7bit (S : in out Sink'Class; Item : Character_7) is\n@@ -196,7 +196,7 @@ package body Ada.Strings.Text_Output.Utils is\n             Line_Start := Index + 1;\n          end if;\n \n-         Index := @ + 1;\n+         Index := Index + 1;\n       end loop;\n \n       if Index > Line_Start then"}, {"sha": "0112491d0fac1fdd0878c8844307b9bbbfccf74b", "filename": "gcc/ada/libgnat/a-stteou__bootstrap.ads", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flibgnat%2Fa-stteou__bootstrap.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flibgnat%2Fa-stteou__bootstrap.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stteou__bootstrap.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,190 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                          ADA.STRINGS.TEXT_OUTPUT                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020-2021, Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Simplified version used during bootstrap only\n+\n+with Ada.Strings.UTF_Encoding;\n+\n+package Ada.Strings.Text_Output with Pure is\n+\n+   --  This package provides a \"Sink\" abstraction, to which characters of type\n+   --  Character, Wide_Character, and Wide_Wide_Character can be sent. This\n+   --  type is used by the Put_Image attribute. In particular, T'Put_Image has\n+   --  the following parameter types:\n+   --\n+   --     procedure T'Put_Image (S : in out Sink'Class; V : T);\n+   --\n+   --  The default generated code for Put_Image of a composite type will\n+   --  typically call Put_Image on the components.\n+   --\n+   --  This is not a fully general abstraction that can be arbitrarily\n+   --  extended. It is designed with particular extensions in mind, and these\n+   --  extensions are declared in child packages of this package, because they\n+   --  depend on implementation details in the private part of this\n+   --  package.\n+   --\n+   --  Users are not expected to extend type Sink.\n+   --\n+   --  The primary extensions of Sink are:\n+   --\n+   --     Buffer. The characters sent to a Buffer are stored in memory, and can\n+   --     be retrieved via Get functions. This is intended for the\n+   --     implementation of the 'Image attribute. The compiler will generate a\n+   --     T'Image function that declares a local Buffer, sends characters to\n+   --     it, and then returns a call to Get, Destroying the Buffer on return.\n+   --\n+   --       function T'Image (V : T) return String is\n+   --          Buf : Buffer := New_Buffer (...);\n+   --       begin\n+   --          T'Put_Image (Buf, V);\n+   --          return Result : constant String := Get (Buf) do\n+   --             Destroy (Buf);\n+   --          end return;\n+   --       end T'Image;\n+   --       ????Perhaps Buffer should be controlled; if you don't like\n+   --       controlled types, call Put_Image directly.\n+   --\n+   --     File. The characters are sent to a file, possibly opened by file\n+   --     name, or possibly standard output or standard error. 'Put_Image\n+   --     can be called directly on a File, thus avoiding any heap allocation.\n+\n+   type Sink (<>) is abstract tagged limited private;\n+   type Sink_Access is access all Sink'Class with Storage_Size => 0;\n+   --  Sink is a character sink; you can send characters to a Sink.\n+   --  UTF-8 encoding is used.\n+\n+   procedure Full_Method (S : in out Sink) is abstract;\n+   procedure Flush_Method (S : in out Sink) is abstract;\n+   --  There is an internal buffer to store the characters. Full_Method is\n+   --  called when the buffer is full, and Flush_Method may be called to flush\n+   --  the buffer. For Buffer, Full_Method allocates more space for more\n+   --  characters, and Flush_Method does nothing. For File, Full_Method and\n+   --  Flush_Method do the same thing: write the characters to the file, and\n+   --  empty the internal buffer.\n+   --\n+   --  These are the only dispatching subprograms on Sink. This is for\n+   --  efficiency; we don't dispatch on every write to the Sink, but only when\n+   --  the internal buffer is full (or upon client request).\n+   --\n+   --  Full_Method and Flush_Method must make the current chunk empty.\n+   --\n+   --  Additional operations operating on Sink'Class are declared in the Utils\n+   --  child, including Full and Flush, which call the above.\n+\n+   function To_Wide (C : Character) return Wide_Character is\n+     (Wide_Character'Val (Character'Pos (C)));\n+   function To_Wide_Wide (C : Character) return Wide_Wide_Character is\n+     (Wide_Wide_Character'Val (Character'Pos (C)));\n+   function To_Wide_Wide (C : Wide_Character) return Wide_Wide_Character is\n+     (Wide_Wide_Character'Val (Wide_Character'Pos (C)));\n+   --  Conversions [Wide_]Character --> [Wide_]Wide_Character.\n+   --  These cannot fail.\n+\n+   function From_Wide (C : Wide_Character) return Character is\n+     (Character'Val (Wide_Character'Pos (C)));\n+   function From_Wide_Wide (C : Wide_Wide_Character) return Character is\n+     (Character'Val (Wide_Wide_Character'Pos (C)));\n+   function From_Wide_Wide (C : Wide_Wide_Character) return Wide_Character is\n+     (Wide_Character'Val (Wide_Wide_Character'Pos (C)));\n+   --  Conversions [Wide_]Wide_Character --> [Wide_]Character.\n+   --  These fail if the character is out of range.\n+\n+   function NL return Character is (ASCII.LF) with Inline;\n+   function Wide_NL return Wide_Character is (To_Wide (Character'(NL)))\n+     with Inline;\n+   function Wide_Wide_NL return Wide_Wide_Character is\n+     (To_Wide_Wide (Character'(NL))) with Inline;\n+   --  Character representing new line. There is no support for CR/LF line\n+   --  endings.\n+\n+   --  We have two subtypes of String that are encoded in UTF-8. UTF_8 cannot\n+   --  contain newline characters; UTF_8_Lines can. Sending UTF_8 data to a\n+   --  Sink is more efficient, because end-of-line processing is not needed.\n+   --  Both of these are more efficient than [[Wide_]Wide_]String, because no\n+   --  encoding is needed.\n+\n+   subtype UTF_8_Lines is UTF_Encoding.UTF_8_String;\n+\n+   subtype UTF_8 is UTF_8_Lines;\n+\n+   Default_Indent_Amount : constant Natural := 4;\n+\n+   Default_Chunk_Length : constant Positive := 500;\n+   --  Experiment shows this value to be reasonably efficient; decreasing it\n+   --  slows things down, but increasing it doesn't gain much.\n+\n+private\n+   --  For Buffer, the \"internal buffer\" mentioned above is implemented as a\n+   --  linked list of chunks. When the current chunk is full, we allocate a new\n+   --  one. For File, there is only one chunk. When it is full, we send the\n+   --  data to the file, and empty it.\n+\n+   type Chunk;\n+   type Chunk_Access is access all Chunk with Storage_Size => 0;\n+   type Chunk (Length : Positive) is limited record\n+      Next : Chunk_Access := null;\n+      Chars : UTF_8_Lines (1 .. Length);\n+   end record;\n+\n+   type Sink (Chunk_Length : Positive) is abstract tagged limited record\n+      Indent_Amount : Natural;\n+      Column : Positive := 1;\n+      Indentation : Natural := 0;\n+\n+      All_7_Bits : Boolean := True;\n+      --  For optimization of Text_Output.Buffers.Get (cf).\n+      --  True if all characters seen so far fit in 7 bits.\n+      --  7-bit characters are represented the same in Character\n+      --  and in UTF-8, so they don't need translation.\n+\n+      All_8_Bits : Boolean := True;\n+      --  True if all characters seen so far fit in 8 bits.\n+      --  This is needed in Text_Output.Buffers.Get to distinguish\n+      --  the case where all characters are Latin-1 (so it should\n+      --  decode) from the case where some characters are bigger than\n+      --  8 bits (so the result is implementation defined).\n+\n+      Cur_Chunk : Chunk_Access;\n+      --  Points to the chunk we are currently sending characters to.\n+      --  We want to say:\n+      --     Cur_Chunk : Chunk_Access := Initial_Chunk'Access;\n+      --  but that's illegal, so we have some horsing around to do.\n+\n+      Last : Natural := 0;\n+      --  Last-used character in Cur_Chunk.all.\n+\n+      Initial_Chunk : aliased Chunk (Length => Chunk_Length);\n+      --  For Buffer, this is the first chunk. Subsequent chunks are allocated\n+      --  on the heap. For File, this is the only chunk, and there is no heap\n+      --  allocation.\n+   end record;\n+\n+end Ada.Strings.Text_Output;"}, {"sha": "a97b3ac8736886af5a702576c7f86c88cb788416", "filename": "gcc/ada/live.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flive.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Flive.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flive.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,12 +24,16 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Lib;      use Lib;\n with Nlists;   use Nlists;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Types;    use Types;\n \n package body Live is"}, {"sha": "b20b6a487f4cd1ac3ec559bb64d3f6cd3b62f85d", "filename": "gcc/ada/nlists.adb", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fnlists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fnlists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -30,7 +30,8 @@ with Alloc;\n with Atree;  use Atree;\n with Debug;  use Debug;\n with Output; use Output;\n-with Sinfo;  use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Table;\n \n package body Nlists is\n@@ -39,9 +40,6 @@ package body Nlists is\n    --  permitted only when this switch is set to False; compiling without\n    --  assertions this lock has no effect.\n \n-   use Atree_Private_Part;\n-   --  Get access to Nodes table\n-\n    ----------------------------------\n    -- Implementation of Node Lists --\n    ----------------------------------\n@@ -86,17 +84,16 @@ package body Nlists is\n       Table_Component_Type => Node_Or_Entity_Id,\n       Table_Index_Type     => Node_Or_Entity_Id'Base,\n       Table_Low_Bound      => First_Node_Id,\n-      Table_Initial        => Alloc.Nodes_Initial,\n-      Table_Increment      => Alloc.Nodes_Increment,\n-      Release_Threshold    => Alloc.Nodes_Release_Threshold,\n+      Table_Initial        => Alloc.Node_Offsets_Initial,\n+      Table_Increment      => Alloc.Node_Offsets_Increment,\n       Table_Name           => \"Next_Node\");\n \n    package Prev_Node is new Table.Table (\n       Table_Component_Type => Node_Or_Entity_Id,\n       Table_Index_Type     => Node_Or_Entity_Id'Base,\n       Table_Low_Bound      => First_Node_Id,\n-      Table_Initial        => Alloc.Nodes_Initial,\n-      Table_Increment      => Alloc.Nodes_Increment,\n+      Table_Initial        => Alloc.Node_Offsets_Initial,\n+      Table_Increment      => Alloc.Node_Offsets_Increment,\n       Table_Name           => \"Prev_Node\");\n \n    -----------------------\n@@ -188,7 +185,7 @@ package body Nlists is\n \n       Set_Last (To, Node);\n \n-      Nodes.Table (Node).In_List := True;\n+      Set_In_List (Node, True);\n \n       Set_Next      (Node, Empty);\n       Set_Prev      (Node, L);\n@@ -406,7 +403,7 @@ package body Nlists is\n \n          Set_Next (After, Node);\n \n-         Nodes.Table (Node).In_List := True;\n+         Set_In_List (Node, True);\n \n          Set_Prev      (Node, After);\n          Set_Next      (Node, Before);\n@@ -466,7 +463,7 @@ package body Nlists is\n \n          Set_Prev (Before, Node);\n \n-         Nodes.Table (Node).In_List := True;\n+         Set_In_List (Node, True);\n \n          Set_Prev      (Node, After);\n          Set_Next      (Node, Before);\n@@ -623,7 +620,7 @@ package body Nlists is\n \n    function Is_List_Member (Node : Node_Or_Entity_Id) return Boolean is\n    begin\n-      return Nodes.Table (Node).In_List;\n+      return In_List (Node);\n    end Is_List_Member;\n \n    -----------------------\n@@ -675,7 +672,7 @@ package body Nlists is\n    function List_Containing (Node : Node_Or_Entity_Id) return List_Id is\n    begin\n       pragma Assert (Is_List_Member (Node));\n-      return List_Id (Nodes.Table (Node).Link);\n+      return List_Id (Link (Node));\n    end List_Containing;\n \n    -----------------\n@@ -866,7 +863,7 @@ package body Nlists is\n             Set_First  (List, Node);\n             Set_Last   (List, Node);\n \n-            Nodes.Table (Node).In_List := True;\n+            Set_In_List (Node, True);\n             Set_List_Link (Node, List);\n             Set_Prev (Node, Empty);\n             Set_Next (Node, Empty);\n@@ -1083,7 +1080,7 @@ package body Nlists is\n \n       Set_First (To, Node);\n \n-      Nodes.Table (Node).In_List := True;\n+      Set_In_List (Node, True);\n \n       Set_Next      (Node, F);\n       Set_Prev      (Node, Empty);\n@@ -1292,7 +1289,7 @@ package body Nlists is\n          Set_Prev (Nxt, Prv);\n       end if;\n \n-      Nodes.Table (Node).In_List := False;\n+      Set_In_List (Node, False);\n       Set_Parent (Node, Empty);\n    end Remove;\n \n@@ -1341,7 +1338,7 @@ package body Nlists is\n                Set_Prev (Nxt, Empty);\n             end if;\n \n-            Nodes.Table (Frst).In_List := False;\n+            Set_In_List (Frst, False);\n             Set_Parent (Frst, Empty);\n             return Frst;\n          end;\n@@ -1392,7 +1389,7 @@ package body Nlists is\n                Set_Prev (Nxt2, Node);\n             end if;\n \n-            Nodes.Table (Nxt).In_List := False;\n+            Set_In_List (Nxt, False);\n             Set_Parent (Nxt, Empty);\n          end;\n       end if;\n@@ -1427,7 +1424,7 @@ package body Nlists is\n    procedure Set_List_Link (Node : Node_Or_Entity_Id; To : List_Id) is\n    begin\n       pragma Assert (not Locked);\n-      Nodes.Table (Node).Link := Union_Id (To);\n+      Set_Link (Node, Union_Id (To));\n    end Set_List_Link;\n \n    --------------"}, {"sha": "2cd5cf3d59621a195d50238a4068de4b7ef109c8", "filename": "gcc/ada/nlists.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fnlists.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fnlists.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.h?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -105,34 +105,13 @@ Prev (Node_Id Node)\n extern Node_Id Prev_Non_Pragma\t\t(Node_Id);\n \n static Boolean Is_Empty_List\t\t(List_Id);\n-static Boolean Is_Non_Empty_List\t(List_Id);\n-static Boolean Is_List_Member\t\t(Node_Id);\n-static List_Id List_Containing\t\t(Node_Id);\n \n INLINE Boolean\n Is_Empty_List (List_Id Id)\n {\n   return (First (Id) == Empty);\n }\n \n-INLINE Boolean\n-Is_Non_Empty_List (List_Id Id)\n-{\n-  return (Present (Id) && First (Id) != Empty);\n-}\n-\n-INLINE Boolean\n-Is_List_Member (Node_Id Node)\n-{\n-  return Nodes_Ptr[Node - First_Node_Id].U.K.in_list;\n-}\n-\n-INLINE List_Id\n-List_Containing (Node_Id Node)\n-{\n-  return Nodes_Ptr[Node - First_Node_Id].V.NX.link;\n-}\n-\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "8fd5684145744f48f30554a3fd2683b9ca0ca698", "filename": "gcc/ada/nmake.adt", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fnmake.adt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fnmake.adt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnmake.adt?ref=476ed6bf66ab20e22ae4b3da0fd7fd94753f2334", "patch": "@@ -1,80 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                                N M A K E                                 --\n---                                                                          --\n---                             T e m p l a t e                              --\n---                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n---  This file is a template used as input to the utility program XNmake,\n---  which reads this template, and the spec of Sinfo (sinfo.ads) and\n---  generates the body and/or the spec for the Nmake package (files\n---  nmake.ads and nmake.adb)\n-\n-pragma Style_Checks (All_Checks);\n---  Turn off subprogram order checking, since the routines here are\n---  generated automatically in order.\n-\n-with Atree;  use Atree;       --  body only\n-with Namet;  use Namet;       --  spec only\n-with Nlists; use Nlists;      --  spec only\n-with Sinfo;  use Sinfo;       --  body only\n-with Snames; use Snames;      --  body only\n-with Stand;  use Stand;       --  body only\n-with Types;  use Types;       --  spec only\n-with Uintp;  use Uintp;       --  spec only\n-with Urealp; use Urealp;      --  spec only\n-\n-package Nmake is\n-\n---  This package contains a set of routines used to construct tree nodes\n---  using a functional style. There is one routine for each node type defined\n---  in Sinfo with the general interface:\n-\n---    function Make_xxx (Sloc : Source_Ptr,\n---                       Field_Name_1 : Field_Name_1_Type [:= default]\n---                       Field_Name_2 : Field_Name_2_Type [:= default]\n---                       ...)\n---    return Node_Id\n-\n---  Only syntactic fields are included (i.e. fields marked as \"-Sem\" or \"-Lib\"\n---  in the Sinfo spec are excluded). In addition, the following four syntactic\n---  fields are excluded:\n-\n---    Prev_Ids\n---    More_Ids\n---    Comes_From_Source\n---    Paren_Count\n-\n---  since they are very rarely set in expanded code. If they need to be set,\n---  to other than the default values (False, False, False, zero), then the\n---  appropriate Set_xxx procedures must be used on the returned value.\n-\n---  Default values are provided only for flag fields (where the default is\n---  False), and for optional fields. An optional field is one where the\n---  comment line describing the field contains the string \"(set to xxx if\".\n---  For such fields, a default value of xxx is provided.\"\n-\n---  Warning: since calls to Make_xxx routines are normal function calls, the\n---  arguments can be evaluated in any order. This means that at most one such\n---  argument can have side effects (e.g. be a call to a parse routine).\n-\n-!!TEMPLATE INSERTION POINT\n-\n-end Nmake;"}, {"sha": "e4be0961d2ef498211bd0cbcc6a2dece1cbfc3f5", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -1528,7 +1528,7 @@ package Opt is\n    Table_Factor : Int := 1;\n    --  GNAT\n    --  Factor by which all initial table sizes set in Alloc are multiplied.\n-   --  Used in Table to calculate initial table sizes (the initial table size\n+   --  Used in Table to calculate initial table sizes. The initial table size\n    --  is the value in Alloc, used as the Table_Initial parameter value,\n    --  multiplied by the factor given here. The default value is used if no\n    --  -gnatT switch appears."}, {"sha": "b026979868cbf2304fae80ce12799cd923860151", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -44,7 +44,9 @@ with Scn;      use Scn;\n with Sem_Util; use Sem_Util;\n with Sinput;   use Sinput;\n with Sinput.L; use Sinput.L;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Style;\n with Stylesw;  use Stylesw;"}, {"sha": "16942144168f6a0bceff2d5ac20087b6be2e95ba", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -37,7 +37,9 @@ with Put_SCOs;\n with SCOs;     use SCOs;\n with Sem;      use Sem;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Table;"}, {"sha": "e6a7cc38f30afb5c3c3544711727137ca24e3043", "filename": "gcc/ada/pprint.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fpprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fpprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpprint.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,11 +24,15 @@\n ------------------------------------------------------------------------------\n \n with Atree;   use Atree;\n-with Einfo;   use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Namet;   use Namet;\n with Nlists;  use Nlists;\n with Opt;     use Opt;\n-with Sinfo;   use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;  use Sinput;\n with Snames;  use Snames;\n with Uintp;   use Uintp;"}, {"sha": "54dbb32034362d6387cd0c3a2c018f69484b6d38", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,15 +27,19 @@ with Alloc;\n with Atree;    use Atree;\n with Casing;   use Casing;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Output;   use Output;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Eval; use Sem_Eval;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stringt;  use Stringt;"}, {"sha": "31ba422fed9c7814e2673bd0d62403e620444c43", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,14 +25,18 @@\n \n with Atree;    use Atree;\n with Casing;   use Casing;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Debug;    use Debug;\n with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n with Lib;      use Lib;\n with Opt;      use Opt;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Stand;    use Stand;\n with Targparm; use Targparm;"}, {"sha": "11aad690a8abff2008fc4cd08b4c015b74ef837d", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,9 @@ with Atree;    use Atree;\n with Casing;   use Casing;\n with Csets;    use Csets;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Dist;\n@@ -47,7 +49,9 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Dist; use Sem_Dist;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Stand;    use Stand;\n with Snames;   use Snames;\n with Tbuild;   use Tbuild;"}, {"sha": "4e8c9dfb6b2c2c09341b7b491900acfd712cf6bd", "filename": "gcc/ada/scil_ll.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fscil_ll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fscil_ll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscil_ll.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,8 @@\n \n with Atree;         use Atree;\n with Opt;           use Opt;\n-with Sinfo;         use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with System.HTable; use System.HTable;\n \n package body SCIL_LL is"}, {"sha": "d0d49899c70b99d110d4fc81af05467cb08c7af8", "filename": "gcc/ada/scn.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fscn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fscn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscn.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -30,7 +30,8 @@ with Opt;      use Opt;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Scans;    use Scans;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Sinput;   use Sinput;\n with Uintp;    use Uintp;\n "}, {"sha": "1c001b085212d2b05078e07fb11ea8d5a1b16c5a", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,6 +26,9 @@\n with Atree;     use Atree;\n with Debug;     use Debug;\n with Debug_A;   use Debug_A;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;    use Elists;\n with Exp_SPARK; use Exp_SPARK;\n with Expander;  use Expander;\n@@ -50,7 +53,9 @@ with Sem_Ch12;  use Sem_Ch12;\n with Sem_Ch13;  use Sem_Ch13;\n with Sem_Prag;  use Sem_Prag;\n with Sem_Util;  use Sem_Util;\n-with Sinfo;     use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Stand;     use Stand;\n with Stylesw;   use Stylesw;\n with Uintp;     use Uintp;"}, {"sha": "a56ce937b916abbd9296df9f64c3ea0a62653018", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -202,7 +202,6 @@\n --  called Preanalyze_And_Resolve and is in Sem_Res.\n \n with Alloc;\n-with Einfo;  use Einfo;\n with Opt;    use Opt;\n with Table;\n with Types;  use Types;"}, {"sha": "123f9dbc48c4f310ced3d4308b551fad8f55cec4", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Expander; use Expander;\n@@ -57,7 +59,9 @@ with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sem_Type; use Sem_Type;\n with Sem_Warn; use Sem_Warn;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stringt;  use Stringt;\n with Stand;    use Stand;"}, {"sha": "19c5d4605cd686893d83e499e39b2e5fa9c673da", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -30,7 +30,9 @@ with Atree;    use Atree;\n with Casing;   use Casing;\n with Checks;   use Checks;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Eval_Fat;\n@@ -66,7 +68,9 @@ with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sem_Warn;\n with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with System;\n with Stringt;  use Stringt;\n@@ -11477,14 +11481,14 @@ package body Sem_Attr is\n                     (\"access to atomic object cannot yield access-to-\" &\n                      \"non-atomic type\", P);\n \n-               elsif Is_Volatile_Object (P)\n+               elsif Is_Volatile_Object_Ref (P)\n                  and then not Is_Volatile (Designated_Type (Typ))\n                then\n                   Error_Msg_F\n                     (\"access to volatile object cannot yield access-to-\" &\n                      \"non-volatile type\", P);\n \n-               elsif Is_Volatile_Full_Access_Object (P)\n+               elsif Is_Volatile_Full_Access_Object_Ref (P)\n                  and then not Is_Volatile_Full_Access (Designated_Type (Typ))\n                then\n                   Error_Msg_F"}, {"sha": "8f645a7e9bcb2ad74c321e9b9df8d409c48e3b10", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,9 +24,13 @@\n ------------------------------------------------------------------------------\n \n with Atree;  use Atree;\n-with Einfo;  use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Nlists; use Nlists;\n-with Sinfo;  use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames; use Snames;\n with Stand;  use Stand;\n with Uintp;  use Uintp;"}, {"sha": "136c7195f1cbdb79bb70b75009959fcb7bd1b13a", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,7 +24,9 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -38,7 +40,9 @@ with Sem_Util; use Sem_Util;\n with Sem_Type; use Sem_Type;\n with Snames;   use Snames;\n with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n "}, {"sha": "5a2b1ccade61d0930562e57638789a23762a93fc", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Atree;    use Atree;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Lib;      use Lib;\n@@ -38,7 +40,9 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Dist; use Sem_Dist;\n with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n "}, {"sha": "c1b92537b5691e29dee02a47fcb658aff59641c7", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,9 @@ with Aspects;   use Aspects;\n with Atree;     use Atree;\n with Contracts; use Contracts;\n with Debug;     use Debug;\n-with Einfo;     use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;    use Errout;\n with Exp_Put_Image;\n with Exp_Util;  use Exp_Util;\n@@ -61,7 +63,9 @@ with Sem_Prag;  use Sem_Prag;\n with Sem_Util;  use Sem_Util;\n with Sem_Warn;  use Sem_Warn;\n with Stand;     use Stand;\n-with Sinfo;     use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinfo.CN;  use Sinfo.CN;\n with Sinput;    use Sinput;\n with Snames;    use Snames;\n@@ -2433,8 +2437,10 @@ package body Sem_Ch10 is\n \n       --  The syntax rules require a proper body for a subprogram subunit\n \n-      if Nkind (Proper_Body (Sinfo.Unit (N))) = N_Subprogram_Declaration then\n-         if Null_Present (Specification (Proper_Body (Sinfo.Unit (N)))) then\n+      if Nkind (Proper_Body (Sinfo.Nodes.Unit (N))) = N_Subprogram_Declaration\n+      then\n+         if Null_Present (Specification (Proper_Body (Sinfo.Nodes.Unit (N))))\n+         then\n             Error_Msg_N\n               (\"null procedure not allowed as subunit\",\n                Proper_Body (Unit (N)));"}, {"sha": "c250ed2ed4fde4b8b8eed7ec3dcc7f3cf06b1335", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n@@ -44,7 +46,9 @@ with Sem_Ch13; use Sem_Ch13;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n "}, {"sha": "5303fb0d027dcb0f8e04ea92c2fdd682e92c73d6", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 61, "deletions": 50, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Aspects;   use Aspects;\n with Atree;     use Atree;\n with Contracts; use Contracts;\n-with Einfo;     use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;    use Elists;\n with Errout;    use Errout;\n with Expander;  use Expander;\n@@ -65,7 +67,9 @@ with Sem_Type;  use Sem_Type;\n with Sem_Util;  use Sem_Util;\n with Sem_Warn;  use Sem_Warn;\n with Stand;     use Stand;\n-with Sinfo;     use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinfo.CN;  use Sinfo.CN;\n with Sinput;    use Sinput;\n with Sinput.L;  use Sinput.L;\n@@ -7872,16 +7876,10 @@ package body Sem_Ch12 is\n       ----------------------\n \n       procedure Copy_Descendants is\n-         use Atree.Unchecked_Access;\n-         --  This code section is part of the implementation of an untyped\n-         --  tree traversal, so it needs direct access to node fields.\n-\n+         procedure Walk is new\n+           Walk_Sinfo_Fields_Pairwise (Copy_Generic_Descendant);\n       begin\n-         Set_Field1 (New_N, Copy_Generic_Descendant (Field1 (N)));\n-         Set_Field2 (New_N, Copy_Generic_Descendant (Field2 (N)));\n-         Set_Field3 (New_N, Copy_Generic_Descendant (Field3 (N)));\n-         Set_Field4 (New_N, Copy_Generic_Descendant (Field4 (N)));\n-         Set_Field5 (New_N, Copy_Generic_Descendant (Field5 (N)));\n+         Walk (New_N, N);\n       end Copy_Descendants;\n \n       -----------------------------\n@@ -8481,18 +8479,33 @@ package body Sem_Ch12 is\n \n          --  Do not copy the associated node, which points to the generic copy\n          --  of the aggregate.\n+         --  ????We ought to be able to get rid of all the Union_Id conversions\n \n-         declare\n-            use Atree.Unchecked_Access;\n-            --  This code section is part of the implementation of an untyped\n-            --  tree traversal, so it needs direct access to node fields.\n+         if Nkind (N) = N_Aggregate then\n+            Set_Aggregate_Bounds\n+              (New_N,\n+               Node_Id (Copy_Generic_Descendant\n+                          (Union_Id (Aggregate_Bounds (N)))));\n \n-         begin\n-            Set_Field1 (New_N, Copy_Generic_Descendant (Field1 (N)));\n-            Set_Field2 (New_N, Copy_Generic_Descendant (Field2 (N)));\n-            Set_Field3 (New_N, Copy_Generic_Descendant (Field3 (N)));\n-            Set_Field5 (New_N, Copy_Generic_Descendant (Field5 (N)));\n-         end;\n+         elsif Nkind (N) = N_Extension_Aggregate then\n+            Set_Ancestor_Part\n+              (New_N,\n+               Node_Id (Copy_Generic_Descendant\n+                          (Union_Id (Ancestor_Part (N)))));\n+\n+         else\n+            pragma Assert (False);\n+         end if;\n+\n+         Set_Expressions\n+           (New_N,\n+            List_Id (Copy_Generic_Descendant (Union_Id (Expressions (N)))));\n+         Set_Component_Associations\n+           (New_N,\n+            List_Id (Copy_Generic_Descendant\n+                       (Union_Id (Component_Associations (N)))));\n+         Set_Etype\n+           (New_N, Node_Id (Copy_Generic_Descendant (Union_Id (Etype (N)))));\n \n       --  Allocators do not have an identifier denoting the access type, so we\n       --  must locate it through the expression to check whether the views are\n@@ -11403,14 +11416,15 @@ package body Sem_Ch12 is\n                Actual, Gen_Obj);\n             Error_Msg_N (\"\\with atomic object actual (RM C.6(12))\", Actual);\n \n-         elsif Is_Volatile_Object (Actual) and then not Is_Volatile (Orig_Ftyp)\n+         elsif Is_Volatile_Object_Ref (Actual)\n+           and then not Is_Volatile (Orig_Ftyp)\n          then\n             Error_Msg_NE\n               (\"cannot instantiate nonvolatile formal & of mode in out\",\n                Actual, Gen_Obj);\n             Error_Msg_N (\"\\with volatile object actual (RM C.6(12))\", Actual);\n \n-         elsif Is_Volatile_Full_Access_Object (Actual)\n+         elsif Is_Volatile_Full_Access_Object_Ref (Actual)\n            and then not Is_Volatile_Full_Access (Orig_Ftyp)\n          then\n             Error_Msg_NE\n@@ -15608,6 +15622,11 @@ package body Sem_Ch12 is\n          elsif E = Standard_Standard then\n             return True;\n \n+         --  E should be an entity, but it is not always\n+\n+         elsif Nkind (E) not in N_Entity then -- ????\n+            return False;\n+\n          elsif Is_Child_Unit (E)\n            and then (Is_Instance_Node (Parent (N2))\n                       or else (Nkind (Parent (N2)) = N_Expanded_Name\n@@ -16275,10 +16294,6 @@ package body Sem_Ch12 is\n             Qual  : Node_Id   := Empty;\n             Typ   : Entity_Id := Empty;\n \n-            use Atree.Unchecked_Access;\n-            --  This code section is part of implementing an untyped tree\n-            --  traversal, so it needs direct access to node fields.\n-\n          begin\n             N2 := Get_Associated_Node (N);\n \n@@ -16341,10 +16356,19 @@ package body Sem_Ch12 is\n                end if;\n             end if;\n \n-            Save_Global_Descendant (Field1 (N));\n-            Save_Global_Descendant (Field2 (N));\n-            Save_Global_Descendant (Field3 (N));\n-            Save_Global_Descendant (Field5 (N));\n+            if Nkind (N) = N_Aggregate then\n+               Save_Global_Descendant (Union_Id (Aggregate_Bounds (N)));\n+\n+            elsif Nkind (N) = N_Extension_Aggregate then\n+               Save_Global_Descendant (Union_Id (Ancestor_Part (N)));\n+\n+            else\n+               pragma Assert (False);\n+            end if;\n+\n+            Save_Global_Descendant (Union_Id (Expressions (N)));\n+            Save_Global_Descendant (Union_Id (Component_Associations (N)));\n+            Save_Global_Descendant (Union_Id (Etype (N)));\n \n             if Present (Qual) then\n                Rewrite (N, Qual);\n@@ -16372,16 +16396,9 @@ package body Sem_Ch12 is\n          ------------------------------------\n \n          procedure Save_References_In_Descendants (N : Node_Id) is\n-            use Atree.Unchecked_Access;\n-            --  This code section is part of implementing an untyped tree\n-            --  traversal, so it needs direct access to node fields.\n-\n+            procedure Walk is new Walk_Sinfo_Fields (Save_Global_Descendant);\n          begin\n-            Save_Global_Descendant (Field1 (N));\n-            Save_Global_Descendant (Field2 (N));\n-            Save_Global_Descendant (Field3 (N));\n-            Save_Global_Descendant (Field4 (N));\n-            Save_Global_Descendant (Field5 (N));\n+            Walk (N);\n          end Save_References_In_Descendants;\n \n          -----------------------------------\n@@ -16586,10 +16603,6 @@ package body Sem_Ch12 is\n             Context : Node_Id;\n             Do_Save : Boolean := True;\n \n-            use Atree.Unchecked_Access;\n-            --  This code section is part of implementing an untyped tree\n-            --  traversal, so it needs direct access to node fields.\n-\n          begin\n             --  Do not save global references in pragmas generated from aspects\n             --  because the pragmas will be regenerated at instantiation time.\n@@ -16621,14 +16634,12 @@ package body Sem_Ch12 is\n \n             --  For all other cases, save all global references within the\n             --  descendants, but skip the following semantic fields:\n-\n-            --    Field1 - Next_Pragma\n-            --    Field3 - Corresponding_Aspect\n-            --    Field5 - Next_Rep_Item\n+            --  Next_Pragma, Corresponding_Aspect, Next_Rep_Item.\n \n             if Do_Save then\n-               Save_Global_Descendant (Field2 (Prag));\n-               Save_Global_Descendant (Field4 (Prag));\n+               Save_Global_Descendant\n+                 (Union_Id (Pragma_Argument_Associations (N)));\n+               Save_Global_Descendant (Union_Id (Pragma_Identifier (N)));\n             end if;\n          end Save_References_In_Pragma;\n "}, {"sha": "4002d82d42a239f74b3a7d5948ffbc02be82f863", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,9 @@ with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Disp; use Exp_Disp;\n@@ -60,7 +62,9 @@ with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;"}, {"sha": "ff5466dcd2f5ec827671a5e2892f51784475f6c9", "filename": "gcc/ada/sem_ch2.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch2.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,14 +24,16 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Utils; use Einfo.Utils;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Dim;  use Sem_Dim;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Stand;    use Stand;\n with Uintp;    use Uintp;\n "}, {"sha": "6b9715324ab5f4d1b5aae551fb6ab860a0ec14b5", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 88, "deletions": 37, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -29,7 +29,9 @@ with Checks;    use Checks;\n with Contracts; use Contracts;\n with Debug;     use Debug;\n with Elists;    use Elists;\n-with Einfo;     use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;    use Errout;\n with Eval_Fat;  use Eval_Fat;\n with Exp_Ch3;   use Exp_Ch3;\n@@ -72,7 +74,9 @@ with Sem_Type;  use Sem_Type;\n with Sem_Util;  use Sem_Util;\n with Sem_Warn;  use Sem_Warn;\n with Stand;     use Stand;\n-with Sinfo;     use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;    use Sinput;\n with Snames;    use Snames;\n with Targparm;  use Targparm;\n@@ -1337,7 +1341,20 @@ package body Sem_Ch3 is\n            and then Present (Entity (S))\n            and then Ekind (Root_Type (Entity (S))) = E_Incomplete_Type\n          then\n-            Set_Directly_Designated_Type (T, Entity (S));\n+            --  The following \"if\" prevents us from blowing up if the access\n+            --  type is illegally completing something else.\n+\n+            if T in E_Void_Id\n+                    | Access_Kind_Id\n+                    | E_Private_Type_Id\n+                    | E_Limited_Private_Type_Id\n+                    | Incomplete_Kind_Id\n+            then\n+               Set_Directly_Designated_Type (T, Entity (S));\n+\n+            else\n+               pragma Assert (Error_Posted (T));\n+            end if;\n \n             --  If the designated type is a limited view, we cannot tell if\n             --  the full view contains tasks, and there is no way to handle\n@@ -1396,45 +1413,47 @@ package body Sem_Ch3 is\n          Set_Ekind (T, E_Access_Type);\n       end if;\n \n-      Full_Desig := Designated_Type (T);\n+      if not Error_Posted (T) then\n+         Full_Desig := Designated_Type (T);\n \n-      if Base_Type (Full_Desig) = T then\n-         Error_Msg_N (\"access type cannot designate itself\", S);\n+         if Base_Type (Full_Desig) = T then\n+            Error_Msg_N (\"access type cannot designate itself\", S);\n \n-      --  In Ada 2005, the type may have a limited view through some unit in\n-      --  its own context, allowing the following circularity that cannot be\n-      --  detected earlier.\n+         --  In Ada 2005, the type may have a limited view through some unit in\n+         --  its own context, allowing the following circularity that cannot be\n+         --  detected earlier.\n \n-      elsif Is_Class_Wide_Type (Full_Desig) and then Etype (Full_Desig) = T\n-      then\n-         Error_Msg_N\n-           (\"access type cannot designate its own class-wide type\", S);\n+         elsif Is_Class_Wide_Type (Full_Desig) and then Etype (Full_Desig) = T\n+         then\n+            Error_Msg_N\n+              (\"access type cannot designate its own class-wide type\", S);\n \n-         --  Clean up indication of tagged status to prevent cascaded errors\n+            --  Clean up indication of tagged status to prevent cascaded errors\n \n-         Set_Is_Tagged_Type (T, False);\n-      end if;\n+            Set_Is_Tagged_Type (T, False);\n+         end if;\n \n-      Set_Etype (T, T);\n+         Set_Etype (T, T);\n \n-      --  For SPARK, check that the designated type is compatible with\n-      --  respect to volatility with the access type.\n+         --  For SPARK, check that the designated type is compatible with\n+         --  respect to volatility with the access type.\n \n-      if SPARK_Mode /= Off\n-         and then Comes_From_Source (T)\n-      then\n-         --  ??? UNIMPLEMENTED\n-         --  In the case where the designated type is incomplete at this point,\n-         --  performing this check here is harmless but the check will need to\n-         --  be repeated when the designated type is complete.\n+         if SPARK_Mode /= Off\n+            and then Comes_From_Source (T)\n+         then\n+            --  ??? UNIMPLEMENTED\n+            --  In the case where the designated type is incomplete at this\n+            --  point, performing this check here is harmless but the check\n+            --  will need to be repeated when the designated type is complete.\n \n-         --  The preceding call to Comes_From_Source is needed because the\n-         --  FE sometimes introduces implicitly declared access types. See,\n-         --  for example, the expansion of nested_po.ads in OA28-015.\n+            --  The preceding call to Comes_From_Source is needed because the\n+            --  FE sometimes introduces implicitly declared access types. See,\n+            --  for example, the expansion of nested_po.ads in OA28-015.\n \n-         Check_Volatility_Compatibility\n-           (Full_Desig, T, \"designated type\", \"access type\",\n-            Srcpos_Bearer => T);\n+            Check_Volatility_Compatibility\n+              (Full_Desig, T, \"designated type\", \"access type\",\n+               Srcpos_Bearer => T);\n+         end if;\n       end if;\n \n       --  If the type has appeared already in a with_type clause, it is frozen\n@@ -4746,6 +4765,10 @@ package body Sem_Ch3 is\n \n       --  Now establish the proper kind and type of the object\n \n+      if Ekind (Id) = E_Void then\n+         Reinit_Field_To_Zero (Id, Next_Inlined_Subprogram);\n+      end if;\n+\n       if Constant_Present (N) then\n          Set_Ekind            (Id, E_Constant);\n          Set_Is_True_Constant (Id);\n@@ -6204,6 +6227,12 @@ package body Sem_Ch3 is\n \n       else pragma Assert (Nkind (Def) = N_Unconstrained_Array_Definition);\n \n+         if Ekind (T) in Incomplete_Or_Private_Kind then\n+            Reinit_Field_To_Zero (T, Stored_Constraint);\n+         else\n+            pragma Assert (Ekind (T) = E_Void);\n+         end if;\n+\n          Set_Ekind                    (T, E_Array_Type);\n          Init_Size_Align              (T);\n          Set_Etype                    (T, T);\n@@ -12494,6 +12523,10 @@ package body Sem_Ch3 is\n       Set_Homonym                   (Full, Save_Homonym);\n       Set_Associated_Node_For_Itype (Full, Related_Nod);\n \n+      if Ekind (Full) in Incomplete_Or_Private_Kind then\n+         Reinit_Field_To_Zero (Full, Private_Dependents);\n+      end if;\n+\n       --  Set common attributes for all subtypes: kind, convention, etc.\n \n       Set_Ekind            (Full, Subtype_Kind (Ekind (Full_Base)));\n@@ -17892,9 +17925,8 @@ package body Sem_Ch3 is\n          T := Access_Definition (Related_Nod, Obj_Def);\n \n          Set_Is_Local_Anonymous_Access\n-           (T,\n-            V => (Ada_Version < Ada_2012)\n-                   or else (Nkind (P) /= N_Object_Declaration)\n+           (T, Ada_Version < Ada_2012\n+                   or else Nkind (P) /= N_Object_Declaration\n                    or else Is_Library_Level_Entity (Defining_Identifier (P)));\n \n       --  Otherwise, the object definition is just a subtype_mark\n@@ -19184,6 +19216,20 @@ package body Sem_Ch3 is\n       --  abstract, its Etype points back to the specific root type, and it\n       --  cannot have any invariants.\n \n+      if Ekind (CW_Type) in Incomplete_Or_Private_Kind then\n+         Reinit_Field_To_Zero (CW_Type, Private_Dependents);\n+\n+      elsif Ekind (CW_Type) in Concurrent_Kind then\n+         if Ekind (CW_Type) = E_Task_Type then\n+            Reinit_Field_To_Zero (CW_Type, Is_Elaboration_Checks_OK_Id);\n+            Reinit_Field_To_Zero (CW_Type, Is_Elaboration_Warnings_OK_Id);\n+         end if;\n+\n+         Reinit_Field_To_Zero (CW_Type, First_Private_Entity);\n+         Reinit_Field_To_Zero (CW_Type, Scope_Depth_Value);\n+         Reinit_Field_To_Zero (CW_Type, SPARK_Aux_Pragma_Inherited);\n+      end if;\n+\n       Set_Ekind                       (CW_Type, E_Class_Wide_Type);\n       Set_Is_Tagged_Type              (CW_Type, True);\n       Set_Direct_Primitive_Operations (CW_Type, New_Elmt_List);\n@@ -20364,6 +20410,11 @@ package body Sem_Ch3 is\n       Discr_Number := Uint_1;\n       while Present (Discr) loop\n          Id := Defining_Identifier (Discr);\n+\n+         if Ekind (Id) = E_In_Parameter then -- ????Above says E_Void\n+            Reinit_Field_To_Zero (Id, Discriminal_Link);\n+         end if;\n+\n          Set_Ekind (Id, E_Discriminant);\n          Init_Component_Location (Id);\n          Init_Esize (Id);\n@@ -20724,7 +20775,7 @@ package body Sem_Ch3 is\n                   & \"has no discriminants\", Full_T);\n             end if;\n \n-            --  ??????? Do we implement the following properly ?????\n+            --  Do we implement the following properly???\n             --  If the ancestor subtype of a private extension has constrained\n             --  discriminants, then the parent subtype of the full view shall\n             --  impose a statically matching constraint on those discriminants\n@@ -20803,7 +20854,7 @@ package body Sem_Ch3 is\n         and then not Has_Discriminants (Priv_T)\n         and then Has_Defaulted_Discriminants (Full_T)\n       then\n-         Set_Has_Constrained_Partial_View (Full_T);\n+         Set_Has_Constrained_Partial_View (Base_Type (Full_T));\n          Set_Has_Constrained_Partial_View (Priv_T);\n       end if;\n "}, {"sha": "5e10e36f2c20ba8c6fa605ee68da56f4c6890c9d", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Util; use Exp_Util;\n@@ -57,7 +59,9 @@ with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n@@ -5291,7 +5295,7 @@ package body Sem_Ch4 is\n                   Set_Parent (Par, Parent (Parent (N)));\n \n                   if Try_Object_Operation\n-                       (Sinfo.Name (Par), CW_Test_Only => True)\n+                       (Sinfo.Nodes.Name (Par), CW_Test_Only => True)\n                   then\n                      return;\n                   end if;"}, {"sha": "9b346941d3073bafa71e07923bb8ee1e0bcf8615", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,9 @@ with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Expander; use Expander;\n with Exp_Ch6;  use Exp_Ch6;\n@@ -56,7 +58,9 @@ with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n with Snames;   use Snames;\n with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n@@ -1315,6 +1319,10 @@ package body Sem_Ch5 is\n                Set_Identifier (N, Empty);\n \n             else\n+               if Ekind (Ent) = E_Label then\n+                  Reinit_Field_To_Zero (Ent, Enclosing_Scope);\n+               end if;\n+\n                Set_Ekind (Ent, E_Block);\n                Generate_Reference (Ent, N, ' ');\n                Generate_Definition (Ent);\n@@ -3752,6 +3760,7 @@ package body Sem_Ch5 is\n             --  parser for generic units.\n \n             if Ekind (Ent) = E_Label then\n+               Reinit_Field_To_Zero (Ent, Enclosing_Scope);\n                Set_Ekind (Ent, E_Loop);\n \n                if Nkind (Parent (Ent)) = N_Implicit_Label_Declaration then"}, {"sha": "284c41298c6f227ccbcef513e31f4fcfece1a5d4", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -28,7 +28,9 @@ with Atree;     use Atree;\n with Checks;    use Checks;\n with Contracts; use Contracts;\n with Debug;     use Debug;\n-with Einfo;     use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;    use Elists;\n with Errout;    use Errout;\n with Expander;  use Expander;\n@@ -77,7 +79,9 @@ with Sem_Type;  use Sem_Type;\n with Sem_Warn;  use Sem_Warn;\n with Sinput;    use Sinput;\n with Stand;     use Stand;\n-with Sinfo;     use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinfo.CN;  use Sinfo.CN;\n with Snames;    use Snames;\n with Stringt;   use Stringt;\n@@ -1844,6 +1848,11 @@ package body Sem_Ch6 is\n          --  Visible generic entity is callable within its own body\n \n          Set_Ekind          (Gen_Id,  Ekind (Body_Id));\n+         Reinit_Field_To_Zero (Body_Id, Has_Out_Or_In_Out_Parameter,\n+           Old_Ekind =>\n+             (E_Function | E_Procedure |\n+                E_Generic_Function | E_Generic_Procedure => True,\n+              others => False));\n          Set_Ekind          (Body_Id, E_Subprogram_Body);\n          Set_Convention     (Body_Id, Convention (Gen_Id));\n          Set_Is_Obsolescent (Body_Id, Is_Obsolescent (Gen_Id));\n@@ -1920,6 +1929,8 @@ package body Sem_Ch6 is\n \n       --  Outside of its body, unit is generic again\n \n+      Reinit_Field_To_Zero (Gen_Id, Has_Nested_Subprogram,\n+        Old_Ekind => (E_Function | E_Procedure => True, others => False));\n       Set_Ekind (Gen_Id, Kind);\n       Generate_Reference (Gen_Id, Body_Id, 'b', Set_Ref => False);\n \n@@ -4599,6 +4610,18 @@ package body Sem_Ch6 is\n             Reference_Body_Formals (Spec_Id, Body_Id);\n          end if;\n \n+         Reinit_Field_To_Zero (Body_Id, Has_Out_Or_In_Out_Parameter);\n+         Reinit_Field_To_Zero (Body_Id, Needs_No_Actuals,\n+           Old_Ekind => (E_Function | E_Procedure => True, others => False));\n+         Reinit_Field_To_Zero (Body_Id, Is_Predicate_Function,\n+           Old_Ekind => (E_Function | E_Procedure => True, others => False));\n+         Reinit_Field_To_Zero (Body_Id, Protected_Subprogram,\n+           Old_Ekind => (E_Function | E_Procedure => True, others => False));\n+\n+         if Ekind (Body_Id) = E_Procedure then\n+            Reinit_Field_To_Zero (Body_Id, Receiving_Entry);\n+         end if;\n+\n          Set_Ekind (Body_Id, E_Subprogram_Body);\n \n          if Nkind (N) = N_Subprogram_Body_Stub then\n@@ -5766,8 +5789,21 @@ package body Sem_Ch6 is\n       if Nkind (N) = N_Function_Specification then\n          Set_Ekind (Designator, E_Function);\n          Set_Mechanism (Designator, Default_Mechanism);\n+\n       else\n-         Set_Ekind (Designator, E_Procedure);\n+         case Ekind (Designator) is\n+            when E_Subprogram_Body | E_Void =>\n+               Reinit_Field_To_Zero\n+                 (Designator, Corresponding_Protected_Entry);\n+               Set_Ekind (Designator, E_Procedure);\n+\n+            when E_Procedure | E_Generic_Procedure =>\n+               null;\n+\n+            when others =>\n+               pragma Assert (False);\n+         end case;\n+\n          Set_Etype (Designator, Standard_Void_Type);\n       end if;\n "}, {"sha": "2f65ff20a821d2697d4eaeb8145c13aad0695f89", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -32,7 +32,9 @@ with Aspects;   use Aspects;\n with Atree;     use Atree;\n with Contracts; use Contracts;\n with Debug;     use Debug;\n-with Einfo;     use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;    use Elists;\n with Errout;    use Errout;\n with Exp_Disp;  use Exp_Disp;\n@@ -64,7 +66,9 @@ with Sem_Util;  use Sem_Util;\n with Sem_Warn;  use Sem_Warn;\n with Snames;    use Snames;\n with Stand;     use Stand;\n-with Sinfo;     use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;    use Sinput;\n with Style;\n with Uintp;     use Uintp;\n@@ -2924,6 +2928,11 @@ package body Sem_Ch7 is\n                   Set_Is_Potentially_Use_Visible (Id);\n                end if;\n \n+            --  Avoid crash caused by previous errors\n+\n+            elsif No (Etype (Id)) and then Serious_Errors_Detected /= 0 then\n+               null;\n+\n             --  We need to avoid incorrectly marking enumeration literals as\n             --  non-visible when a visible use-all-type clause is in effect.\n "}, {"sha": "b88a36ac80cae72b0d808c4a7244d2c39b411bb6", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Atree;    use Atree;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Disp; use Exp_Disp;\n@@ -65,7 +67,9 @@ with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sem_Type; use Sem_Type;\n with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinfo.CN; use Sinfo.CN;\n with Snames;   use Snames;\n with Style;\n@@ -1457,10 +1461,6 @@ package body Sem_Ch8 is\n          Set_Ekind (Id, E_Variable);\n       end if;\n \n-      --  Initialize the object size and alignment. Note that we used to call\n-      --  Init_Size_Align here, but that's wrong for objects which have only\n-      --  an Esize, not an RM_Size field.\n-\n       Init_Object_Size_Align (Id);\n \n       --  If N comes from source then check that the original node is an\n@@ -1545,10 +1545,11 @@ package body Sem_Ch8 is\n       --  renamed object is atomic, independent, volatile or VFA. These flags\n       --  are set on the renamed object in the RM legality sense.\n \n-      Set_Is_Atomic               (Id, Is_Atomic_Object (Nam));\n-      Set_Is_Independent          (Id, Is_Independent_Object (Nam));\n-      Set_Is_Volatile             (Id, Is_Volatile_Object (Nam));\n-      Set_Is_Volatile_Full_Access (Id, Is_Volatile_Full_Access_Object (Nam));\n+      Set_Is_Atomic (Id, Is_Atomic_Object (Nam));\n+      Set_Is_Independent (Id, Is_Independent_Object (Nam));\n+      Set_Is_Volatile (Id, Is_Volatile_Object_Ref (Nam));\n+      Set_Is_Volatile_Full_Access\n+        (Id, Is_Volatile_Full_Access_Object_Ref (Nam));\n \n       --  Treat as volatile if we just set the Volatile flag\n \n@@ -3277,6 +3278,9 @@ package body Sem_Ch8 is\n          --  constructed later at the freeze point, so indicate that the\n          --  completion has not been seen yet.\n \n+         Reinit_Field_To_Zero (New_S, Has_Out_Or_In_Out_Parameter);\n+         Reinit_Field_To_Zero (New_S, Needs_No_Actuals,\n+           Old_Ekind => (E_Function | E_Procedure => True, others => False));\n          Set_Ekind (New_S, E_Subprogram_Body);\n          New_S := Rename_Spec;\n          Set_Has_Completion (Rename_Spec, False);\n@@ -6829,7 +6833,17 @@ package body Sem_Ch8 is\n          end if;\n       end if;\n \n-      Change_Selected_Component_To_Expanded_Name (N);\n+      case Nkind (N) is\n+         when N_Selected_Component =>\n+            Reinit_Field_To_Zero (N, Is_Prefixed_Call);\n+            Change_Selected_Component_To_Expanded_Name (N);\n+\n+         when N_Expanded_Name =>\n+            null;\n+\n+         when others =>\n+            pragma Assert (False);\n+      end case;\n \n       --  Preserve relevant elaboration-related attributes of the context which\n       --  are no longer available or very expensive to recompute once analysis,"}, {"sha": "c8962a91a620714ebe3f9e410c8d5aa9e8e0359e", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -28,7 +28,9 @@ with Atree;     use Atree;\n with Checks;    use Checks;\n with Contracts; use Contracts;\n with Debug;     use Debug;\n-with Einfo;     use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;    use Errout;\n with Exp_Ch9;   use Exp_Ch9;\n with Elists;    use Elists;\n@@ -59,7 +61,9 @@ with Sem_Util;  use Sem_Util;\n with Sem_Warn;  use Sem_Warn;\n with Snames;    use Snames;\n with Stand;     use Stand;\n-with Sinfo;     use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Style;\n with Tbuild;    use Tbuild;\n with Uintp;     use Uintp;"}, {"sha": "82cfcfc13117d44c9126c2e4efae6b645c4318cd", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Aspects;  use Aspects;\n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Exp_Util; use Exp_Util;\n with Lib;      use Lib;\n@@ -39,7 +41,9 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;"}, {"sha": "e1b0bca519ddd966f94d433f2e71e4cfd7265d5d", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,9 @@ with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Debug;    use Debug;\n with Elists;   use Elists;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Exp_Disp; use Exp_Disp;\n with Exp_Util; use Exp_Util;\n with Exp_Ch7;  use Exp_Ch7;\n@@ -50,7 +52,9 @@ with Sem_Eval; use Sem_Eval;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Snames;   use Snames;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Warnsw;   use Warnsw;"}, {"sha": "15767cff266bd3442c1b7c73ab1480182eb6f3e7", "filename": "gcc/ada/sem_dist.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dist.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Atree;    use Atree;\n with Casing;   use Casing;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Exp_Dist; use Exp_Dist;\n with Exp_Tss;  use Exp_Tss;\n@@ -40,7 +42,9 @@ with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n with Tbuild;   use Tbuild;"}, {"sha": "ac99e1d21e25f8613880b7111217c61c23b4b5a8", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,9 @@ with ALI;      use ALI;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch11; use Exp_Ch11;\n@@ -52,7 +54,9 @@ with Sem_Ch8;  use Sem_Ch8;\n with Sem_Disp; use Sem_Disp;\n with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;"}, {"sha": "e6d19f81c6b312e9cb026aae36ddb0dd8f6df798", "filename": "gcc/ada/sem_elim.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_elim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_elim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elim.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,7 +24,9 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Lib;      use Lib;\n with Namet;    use Namet;\n@@ -35,7 +37,8 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n with Sinput;   use Sinput;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;"}, {"sha": "fe5c397331f127b64335b148ff68cd57443864d9", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,9 @@ with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Eval_Fat; use Eval_Fat;\n@@ -51,7 +53,9 @@ with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sem_Type; use Sem_Type;\n with Sem_Warn; use Sem_Warn;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n@@ -4995,7 +4999,7 @@ package body Sem_Eval is\n             Check_Elab_Call;\n \n             if Is_Modular_Integer_Type (Typ) then\n-               Modulus := Einfo.Modulus (Typ);\n+               Modulus := Einfo.Entities.Modulus (Typ);\n             else\n                Modulus := Uint_2 ** RM_Size (Typ);\n             end if;\n@@ -5023,7 +5027,7 @@ package body Sem_Eval is\n                Fold_Uint (N, Expr_Value (Left), Static => Static);\n             else\n                if Is_Modular_Integer_Type (Typ) then\n-                  Modulus := Einfo.Modulus (Typ);\n+                  Modulus := Einfo.Entities.Modulus (Typ);\n                else\n                   Modulus := Uint_2 ** RM_Size (Typ);\n                end if;\n@@ -5047,7 +5051,7 @@ package body Sem_Eval is\n                Two_Y : constant Uint := Uint_2 ** Expr_Value (Right);\n             begin\n                if Is_Modular_Integer_Type (Typ) then\n-                  Modulus := Einfo.Modulus (Typ);\n+                  Modulus := Einfo.Entities.Modulus (Typ);\n                else\n                   Modulus := Uint_2 ** RM_Size (Typ);\n                end if;"}, {"sha": "dcd7ea5e59e0a22eada2694355fd07675bf39830", "filename": "gcc/ada/sem_intr.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_intr.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,15 +26,19 @@\n --  Processing for intrinsic subprogram declarations\n \n with Atree;    use Atree;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;"}, {"sha": "497f8133ba3311efc008e3623ad00fadac95d58a", "filename": "gcc/ada/sem_mech.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_mech.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_mech.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_mech.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,12 +24,15 @@\n ------------------------------------------------------------------------------\n \n with Atree;   use Atree;\n-with Einfo;   use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;  use Errout;\n with Namet;   use Namet;\n with Sem;     use Sem;\n with Sem_Aux; use Sem_Aux;\n-with Sinfo;   use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Snames;  use Snames;\n \n package body Sem_Mech is"}, {"sha": "4eb27327419a735b8bdaee0db86aac82b3caa601", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -36,7 +36,9 @@ with Checks;    use Checks;\n with Contracts; use Contracts;\n with Csets;     use Csets;\n with Debug;     use Debug;\n-with Einfo;     use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;    use Elists;\n with Errout;    use Errout;\n with Exp_Dist;  use Exp_Dist;\n@@ -76,7 +78,9 @@ with Sem_Type;  use Sem_Type;\n with Sem_Util;  use Sem_Util;\n with Sem_Warn;  use Sem_Warn;\n with Stand;     use Stand;\n-with Sinfo;     use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinfo.CN;  use Sinfo.CN;\n with Sinput;    use Sinput;\n with Stringt;   use Stringt;\n@@ -16098,7 +16102,8 @@ package body Sem_Prag is\n                begin\n                   Set_Is_Exported    (Id2, Is_Exported          (Def_Id));\n                   Set_First_Rep_Item (Id2, First_Rep_Item       (Def_Id));\n-                  Set_Interface_Name (Id2, Einfo.Interface_Name (Def_Id));\n+                  Set_Interface_Name\n+                    (Id2, Einfo.Entities.Interface_Name (Def_Id));\n                end;\n             end if;\n          end Export;"}, {"sha": "f3caca741311998204081d4c1e98f3c2724d59f7", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -28,7 +28,9 @@ with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n with Debug_A;  use Debug_A;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Expander; use Expander;\n with Exp_Ch6;  use Exp_Ch6;\n@@ -72,7 +74,9 @@ with Sem_Mech; use Sem_Mech;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinfo.CN; use Sinfo.CN;\n with Snames;   use Snames;\n with Stand;    use Stand;\n@@ -1285,8 +1289,10 @@ package body Sem_Res is\n          Check_Parameterless_Call (Explicit_Actual_Parameter (N));\n \n       elsif Nkind (N) = N_Operator_Symbol then\n-         Change_Operator_Symbol_To_String_Literal (N);\n+         Set_Etype (N, Empty);\n+         Set_Entity (N, Empty);\n          Set_Is_Overloaded (N, False);\n+         Change_Operator_Symbol_To_String_Literal (N);\n          Set_Etype (N, Any_String);\n       end if;\n    end Check_Parameterless_Call;\n@@ -4804,7 +4810,7 @@ package body Sem_Res is\n                   Error_Msg_N\n                     (\"\\which is passed by reference (RM C.6(12))\", A);\n \n-               elsif Is_Volatile_Object (A)\n+               elsif Is_Volatile_Object_Ref (A)\n                  and then not Is_Volatile (Etype (F))\n                then\n                   Error_Msg_NE\n@@ -4813,7 +4819,7 @@ package body Sem_Res is\n                   Error_Msg_N\n                     (\"\\which is passed by reference (RM C.6(12))\", A);\n \n-               elsif Is_Volatile_Full_Access_Object (A)\n+               elsif Is_Volatile_Full_Access_Object_Ref (A)\n                  and then not Is_Volatile_Full_Access (Etype (F))\n                then\n                   Error_Msg_NE"}, {"sha": "bba92473b5f36ddee24c1a9208ad423084a1b5b6", "filename": "gcc/ada/sem_scil.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_scil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_scil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_scil.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -23,11 +23,14 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Einfo;   use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Nlists;  use Nlists;\n with Rtsfind; use Rtsfind;\n with Sem_Aux; use Sem_Aux;\n-with Sinfo;   use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Stand;   use Stand;\n with SCIL_LL; use SCIL_LL;\n "}, {"sha": "95dc94280da834ccdbd782d6de78ac96dc6488f5", "filename": "gcc/ada/sem_smem.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_smem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_smem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_smem.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -24,11 +24,14 @@\n ------------------------------------------------------------------------------\n \n with Atree;   use Atree;\n-with Einfo;   use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;  use Errout;\n with Namet;   use Namet;\n with Sem_Aux; use Sem_Aux;\n-with Sinfo;   use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Snames;  use Snames;\n \n package body Sem_Smem is"}, {"sha": "bf70491783b3c9e1144d8b2d553dd47bc7f736bf", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,9 @@ with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Alloc;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Nlists;   use Nlists;\n with Errout;   use Errout;\n@@ -44,7 +46,9 @@ with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Util; use Sem_Util;\n with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Table;\n with Treepr;   use Treepr;"}, {"sha": "5c1368edadb0aae4377c63fe588d9a09cd040bc2", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 57, "deletions": 131, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,6 +26,7 @@\n with Casing;   use Casing;\n with Checks;   use Checks;\n with Debug;    use Debug;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Erroutc;  use Erroutc;\n@@ -58,7 +59,9 @@ with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Warn; use Sem_Warn;\n with Sem_Type; use Sem_Type;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Stand;    use Stand;\n with Style;\n@@ -6471,7 +6474,6 @@ package body Sem_Util is\n                      Remove (Op_List, Node (Second));\n \n                   else\n-                     pragma Assert (False);\n                      raise Program_Error;\n                   end if;\n                end if;\n@@ -13872,7 +13874,7 @@ package body Sem_Util is\n       elsif Is_Record_Type (Typ) then\n          Comp := First_Component (Typ);\n          while Present (Comp) loop\n-            if Is_Volatile_Object (Comp) then\n+            if Is_Volatile_Object_Ref (Comp) then\n                return True;\n             end if;\n \n@@ -17225,7 +17227,8 @@ package body Sem_Util is\n \n    function Is_Full_Access_Object (N : Node_Id) return Boolean is\n    begin\n-      return Is_Atomic_Object (N) or else Is_Volatile_Full_Access_Object (N);\n+      return Is_Atomic_Object (N)\n+        or else Is_Volatile_Full_Access_Object_Ref (N);\n    end Is_Full_Access_Object;\n \n    -------------------------------\n@@ -20955,11 +20958,11 @@ package body Sem_Util is\n         and then Scope (Scope (Scope (Root))) = Standard_Standard;\n    end Is_Visibly_Controlled;\n \n-   --------------------------------------\n-   --  Is_Volatile_Full_Access_Object  --\n-   --------------------------------------\n+   ----------------------------------------\n+   -- Is_Volatile_Full_Access_Object_Ref --\n+   ----------------------------------------\n \n-   function Is_Volatile_Full_Access_Object (N : Node_Id) return Boolean is\n+   function Is_Volatile_Full_Access_Object_Ref (N : Node_Id) return Boolean is\n       function Is_VFA_Object_Entity (Id : Entity_Id) return Boolean;\n       --  Determine whether arbitrary entity Id denotes an object that is\n       --  Volatile_Full_Access.\n@@ -20977,7 +20980,7 @@ package body Sem_Util is\n                        Is_Volatile_Full_Access (Etype (Id)));\n       end Is_VFA_Object_Entity;\n \n-   --  Start of processing for Is_Volatile_Full_Access_Object\n+   --  Start of processing for Is_Volatile_Full_Access_Object_Ref\n \n    begin\n       if Is_Entity_Name (N) then\n@@ -20992,7 +20995,7 @@ package body Sem_Util is\n       else\n          return False;\n       end if;\n-   end Is_Volatile_Full_Access_Object;\n+   end Is_Volatile_Full_Access_Object_Ref;\n \n    --------------------------\n    -- Is_Volatile_Function --\n@@ -21024,11 +21027,11 @@ package body Sem_Util is\n       end if;\n    end Is_Volatile_Function;\n \n-   ------------------------\n-   -- Is_Volatile_Object --\n-   ------------------------\n+   ----------------------------\n+   -- Is_Volatile_Object_Ref --\n+   ----------------------------\n \n-   function Is_Volatile_Object (N : Node_Id) return Boolean is\n+   function Is_Volatile_Object_Ref (N : Node_Id) return Boolean is\n       function Is_Volatile_Object_Entity (Id : Entity_Id) return Boolean;\n       --  Determine whether arbitrary entity Id denotes an object that is\n       --  Volatile.\n@@ -21074,15 +21077,15 @@ package body Sem_Util is\n          then\n             return True;\n \n-         elsif Is_Volatile_Object (P) then\n+         elsif Is_Volatile_Object_Ref (P) then\n             return True;\n \n          else\n             return False;\n          end if;\n       end Prefix_Has_Volatile_Components;\n \n-   --  Start of processing for Is_Volatile_Object\n+   --  Start of processing for Is_Volatile_Object_Ref\n \n    begin\n       if Is_Entity_Name (N) then\n@@ -21101,7 +21104,7 @@ package body Sem_Util is\n       else\n          return False;\n       end if;\n-   end Is_Volatile_Object;\n+   end Is_Volatile_Object_Ref;\n \n    -----------------------------\n    -- Iterate_Call_Parameters --\n@@ -22900,9 +22903,6 @@ package body Sem_Util is\n       --  This routine performs low-level tree manipulations and needs access\n       --  to the internals of the tree.\n \n-      use Atree.Unchecked_Access;\n-      use Atree_Private_Part;\n-\n       EWA_Level : Nat := 0;\n       --  This counter keeps track of how many N_Expression_With_Actions nodes\n       --  are encountered during a depth-first traversal of the subtree. These\n@@ -23054,6 +23054,7 @@ package body Sem_Util is\n       --  valid syntactic fields. Par_Nod is the expected parent of the\n       --  syntactic field. Flag Semantic should be set when the input is a\n       --  semantic field.\n+      --  ????So it's visiting sem fields twice?\n \n       procedure Visit_Itype (Itype : Entity_Id);\n       --  Visit itype Itype. This action may create a new entity for Itype and\n@@ -23444,6 +23445,25 @@ package body Sem_Util is\n       function Copy_Node_With_Replacement (N : Node_Id) return Node_Id is\n          Result : Node_Id;\n \n+         function Transform (U : Union_Id) return Union_Id;\n+         --  Copies one field, replacing N with Result\n+\n+         ---------------\n+         -- Transform --\n+         ---------------\n+\n+         function Transform (U : Union_Id) return Union_Id is\n+         begin\n+            return Copy_Field_With_Replacement\n+                     (Field   => U,\n+                      Old_Par => N,\n+                      New_Par => Result);\n+         end Transform;\n+\n+         procedure Walk is new Walk_Sinfo_Fields_Pairwise (Transform);\n+\n+      --  Start of processing for Copy_Node_With_Replacement\n+\n       begin\n          --  Assume that the node must be returned unchanged\n \n@@ -23454,35 +23474,7 @@ package body Sem_Util is\n \n             Result := New_Copy (N);\n \n-            Set_Field1 (Result,\n-              Copy_Field_With_Replacement\n-                (Field   => Field1 (Result),\n-                 Old_Par => N,\n-                 New_Par => Result));\n-\n-            Set_Field2 (Result,\n-              Copy_Field_With_Replacement\n-                (Field   => Field2 (Result),\n-                 Old_Par => N,\n-                 New_Par => Result));\n-\n-            Set_Field3 (Result,\n-              Copy_Field_With_Replacement\n-                (Field   => Field3 (Result),\n-                 Old_Par => N,\n-                 New_Par => Result));\n-\n-            Set_Field4 (Result,\n-              Copy_Field_With_Replacement\n-                (Field   => Field4 (Result),\n-                 Old_Par => N,\n-                 New_Par => Result));\n-\n-            Set_Field5 (Result,\n-              Copy_Field_With_Replacement\n-                (Field   => Field5 (Result),\n-                 Old_Par => N,\n-                 New_Par => Result));\n+            Walk (Result, Result);\n \n             --  Update the Comes_From_Source and Sloc attributes of the node\n             --  in case the caller has supplied new values.\n@@ -23622,7 +23614,7 @@ package body Sem_Util is\n          --  A new source location defaults the Comes_From_Source attribute\n \n          if New_Sloc /= No_Location then\n-            Set_Comes_From_Source (N, Default_Node.Comes_From_Source);\n+            Set_Comes_From_Source (N, Get_Comes_From_Source_Default);\n             Set_Sloc              (N, New_Sloc);\n          end if;\n       end Update_CFS_Sloc;\n@@ -24229,25 +24221,17 @@ package body Sem_Util is\n             EWA_Inner_Scope_Level := EWA_Inner_Scope_Level + 1;\n          end if;\n \n-         Visit_Field\n-          (Field   => Field1 (N),\n-           Par_Nod => N);\n-\n-         Visit_Field\n-          (Field   => Field2 (N),\n-           Par_Nod => N);\n-\n-         Visit_Field\n-          (Field   => Field3 (N),\n-           Par_Nod => N);\n-\n-         Visit_Field\n-          (Field   => Field4 (N),\n-           Par_Nod => N);\n+         declare\n+            procedure Action (U : Union_Id);\n+            procedure Action (U : Union_Id) is\n+            begin\n+               Visit_Field (Field => U, Par_Nod => N);\n+            end Action;\n \n-         Visit_Field\n-          (Field   => Field5 (N),\n-           Par_Nod => N);\n+            procedure Walk is new Walk_Sinfo_Fields (Action);\n+         begin\n+            Walk (N);\n+         end;\n \n          if EWA_Level > 0\n            and then Nkind (N) in N_Block_Statement\n@@ -26181,14 +26165,16 @@ package body Sem_Util is\n          Partial_DIC_Proc := Partial_DIC_Procedure (From_Typ);\n \n          --  The setting of the attributes is intentionally conservative. This\n-         --  prevents accidental clobbering of enabled attributes.\n+         --  prevents accidental clobbering of enabled attributes. We need to\n+         --  call Base_Type twice, because it is sometimes not set to an actual\n+         --  base type.\n \n          if Has_Inherited_DIC (From_Typ) then\n-            Set_Has_Inherited_DIC (Typ);\n+            Set_Has_Inherited_DIC (Base_Type (Base_Type (Typ)));\n          end if;\n \n          if Has_Own_DIC (From_Typ) then\n-            Set_Has_Own_DIC (Typ);\n+            Set_Has_Own_DIC (Base_Type (Base_Type (Typ)));\n          end if;\n \n          if Present (DIC_Proc) and then No (DIC_Procedure (Typ)) then\n@@ -27336,66 +27322,6 @@ package body Sem_Util is\n       return False;\n    end Scope_Within_Or_Same;\n \n-   --------------------\n-   -- Set_Convention --\n-   --------------------\n-\n-   procedure Set_Convention (E : Entity_Id; Val : Snames.Convention_Id) is\n-   begin\n-      Basic_Set_Convention (E, Val);\n-\n-      if Is_Type (E)\n-        and then Is_Access_Subprogram_Type (Base_Type (E))\n-        and then Has_Foreign_Convention (E)\n-      then\n-         Set_Can_Use_Internal_Rep (E, False);\n-      end if;\n-\n-      --  If E is an object, including a component, and the type of E is an\n-      --  anonymous access type with no convention set, then also set the\n-      --  convention of the anonymous access type. We do not do this for\n-      --  anonymous protected types, since protected types always have the\n-      --  default convention.\n-\n-      if Present (Etype (E))\n-        and then (Is_Object (E)\n-\n-                   --  Allow E_Void (happens for pragma Convention appearing\n-                   --  in the middle of a record applying to a component)\n-\n-                   or else Ekind (E) = E_Void)\n-      then\n-         declare\n-            Typ : constant Entity_Id := Etype (E);\n-\n-         begin\n-            if Ekind (Typ) in E_Anonymous_Access_Type\n-                            | E_Anonymous_Access_Subprogram_Type\n-              and then not Has_Convention_Pragma (Typ)\n-            then\n-               Basic_Set_Convention (Typ, Val);\n-               Set_Has_Convention_Pragma (Typ);\n-\n-               --  And for the access subprogram type, deal similarly with the\n-               --  designated E_Subprogram_Type, which is always internal.\n-\n-               if Ekind (Typ) = E_Anonymous_Access_Subprogram_Type then\n-                  declare\n-                     Dtype : constant Entity_Id := Designated_Type (Typ);\n-                  begin\n-                     if Ekind (Dtype) = E_Subprogram_Type\n-                       and then not Has_Convention_Pragma (Dtype)\n-                     then\n-                        Basic_Set_Convention (Dtype, Val);\n-                        Set_Has_Convention_Pragma (Dtype);\n-                     end if;\n-                  end;\n-               end if;\n-            end if;\n-         end;\n-      end if;\n-   end Set_Convention;\n-\n    ------------------------\n    -- Set_Current_Entity --\n    ------------------------"}, {"sha": "b4b5d10bc3fc7798eef218d6c51d4ce049ad5767", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,7 +27,8 @@\n \n with Aspects; use Aspects;\n with Atree;   use Atree;\n-with Einfo;   use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n with Exp_Tss; use Exp_Tss;\n with Namet;   use Namet;\n with Opt;     use Opt;\n@@ -2388,7 +2389,7 @@ package Sem_Util is\n    --  Initialize/Adjust/Finalize subprogram does not override the inherited\n    --  one.\n \n-   function Is_Volatile_Full_Access_Object (N : Node_Id) return Boolean;\n+   function Is_Volatile_Full_Access_Object_Ref (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N denotes a reference to an object\n    --  which is Volatile_Full_Access.\n \n@@ -2397,7 +2398,7 @@ package Sem_Util is\n    --  pragma Volatile_Function. Protected functions are treated as volatile\n    --  (SPARK RM 7.1.2).\n \n-   function Is_Volatile_Object (N : Node_Id) return Boolean;\n+   function Is_Volatile_Object_Ref (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N denotes a reference to a volatile\n    --  object as per RM C.6(8). Note that the test here is for something that\n    --  is actually declared as volatile, not for an object that gets treated\n@@ -3018,13 +3019,6 @@ package Sem_Util is\n    --  the same scope. Note that scopes are partially ordered, so Scope_Within\n    --  (A, B) and Scope_Within (B, A) may both return False.\n \n-   procedure Set_Convention (E : Entity_Id; Val : Convention_Id);\n-   --  Same as Basic_Set_Convention, but with an extra check for access types.\n-   --  In particular, if E is an access-to-subprogram type, and Val is a\n-   --  foreign convention, then we set Can_Use_Internal_Rep to False on E.\n-   --  Also, if the Etype of E is set and is an anonymous access type with\n-   --  no convention set, this anonymous type inherits the convention of E.\n-\n    procedure Set_Current_Entity (E : Entity_Id);\n    pragma Inline (Set_Current_Entity);\n    --  Establish the entity E as the currently visible definition of its"}, {"sha": "43ce5effb4f8bd7432cfdcb2be0d30582408f334", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,7 +25,9 @@\n \n with Atree;    use Atree;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Exp_Code; use Exp_Code;\n with Lib;      use Lib;\n@@ -41,7 +43,9 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Eval; use Sem_Eval;\n with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n@@ -2308,7 +2312,7 @@ package body Sem_Warn is\n \n          procedure Check_Inner_Package (Pack : Entity_Id) is\n             E  : Entity_Id;\n-            Un : constant Node_Id := Sinfo.Unit (Cnode);\n+            Un : constant Node_Id := Sinfo.Nodes.Unit (Cnode);\n \n             function Check_Use_Clause (N : Node_Id) return Traverse_Result;\n             --  If N is a use_clause for Pack, emit warning"}, {"sha": "cfd9b702f244a1934806cf64f73c3791decf5d2f", "filename": "gcc/ada/set_targ.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fset_targ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fset_targ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fset_targ.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -36,7 +36,6 @@\n --  of Wide_Character_Type uses twice the size of a C char, instead of the\n --  size of wchar_t, since this corresponds to expected Ada usage.\n \n-with Einfo; use Einfo;\n with Stand; use Stand;\n with Types; use Types;\n "}, {"sha": "9fc4e00fcffdeefafd20aa0e3452f98594d1fa45", "filename": "gcc/ada/sinfo-cn.adb", "status": "modified", "additions": 69, "deletions": 19, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinfo-cn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinfo-cn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-cn.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -32,25 +32,52 @@\n \n with Atree;    use Atree;\n with Snames;   use Snames;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n \n package body Sinfo.CN is\n \n-   use Atree.Unchecked_Access;\n-   --  This package is one of the few packages which is allowed to make direct\n-   --  references to tree nodes (since it is in the business of providing a\n-   --  higher level of tree access which other clients are expected to use and\n-   --  which implements checks).\n+   procedure Assert_Expression_Fields_Zero (N : Node_Id);\n+   --  Asserts that all fields documented in Sinfo as \"plus fields for\n+   --  expression\" have their initial zero value. Note that N_Operator_Symbol\n+   --  is not documented as having \"plus fields for expression\", but it is in\n+   --  N_Subexpr, so it does.\n+   --  ????This is redundant with Check_Vanishing_Fields in Atree.\n+\n+   -----------------------------------\n+   -- Assert_Expression_Fields_Zero --\n+   -----------------------------------\n+\n+   procedure Assert_Expression_Fields_Zero (N : Node_Id) is\n+   begin\n+      pragma Assert (Paren_Count (N) = 0);\n+      pragma Assert (No (Etype (N)));\n+      pragma Assert (not Is_Overloaded (N));\n+      pragma Assert (not Is_Static_Expression (N));\n+      pragma Assert (not Raises_Constraint_Error (N));\n+      pragma Assert (not Must_Not_Freeze (N));\n+      pragma Assert (not Do_Range_Check (N));\n+      pragma Assert (not Has_Dynamic_Length_Check (N));\n+      pragma Assert (not Assignment_OK (N));\n+      pragma Assert (not Is_Controlling_Actual (N));\n+   end Assert_Expression_Fields_Zero;\n \n    ------------------------------------------------------------\n    -- Change_Character_Literal_To_Defining_Character_Literal --\n    ------------------------------------------------------------\n \n    procedure Change_Character_Literal_To_Defining_Character_Literal\n-     (N : in out Node_Id)\n+     (N : Node_Id)\n    is\n    begin\n-      Set_Nkind (N, N_Defining_Character_Literal);\n-      N := Extend_Node (N);\n+      Reinit_Field_To_Zero (N, Char_Literal_Value);\n+--  ????pragma Assert (No (Node2 (N))); -- Char_Literal_Value is Uint2 out of r\n+      pragma Assert (No (Entity (N)));\n+      pragma Assert (No (Associated_Node (N)));\n+      pragma Assert (not Has_Private_View (N));\n+      Assert_Expression_Fields_Zero (N);\n+\n+      Extend_Node (N);\n    end Change_Character_Literal_To_Defining_Character_Literal;\n \n    ------------------------------------\n@@ -62,17 +89,27 @@ package body Sinfo.CN is\n       Set_Do_Overflow_Check (N, False);\n       Set_Do_Tag_Check (N, False);\n       Set_Do_Length_Check (N, False);\n-      Set_Nkind (N, N_Unchecked_Type_Conversion);\n+      Mutate_Nkind (N, N_Unchecked_Type_Conversion);\n    end Change_Conversion_To_Unchecked;\n \n    ----------------------------------------------\n    -- Change_Identifier_To_Defining_Identifier --\n    ----------------------------------------------\n \n-   procedure Change_Identifier_To_Defining_Identifier (N : in out Node_Id) is\n+   procedure Change_Identifier_To_Defining_Identifier (N : Node_Id) is\n    begin\n-      Set_Nkind (N, N_Defining_Identifier);\n-      N := Extend_Node (N);\n+      pragma Assert (No (Entity (N)));\n+      pragma Assert (No (Associated_Node (N)));\n+      pragma Assert (No (Original_Discriminant (N)));\n+      pragma Assert (not Is_Elaboration_Checks_OK_Node (N));\n+      pragma Assert (not Is_SPARK_Mode_On_Node (N));\n+      pragma Assert (not Is_Elaboration_Warnings_OK_Node (N));\n+      pragma Assert (not Has_Private_View (N));\n+      pragma Assert (not Redundant_Use (N));\n+      pragma Assert (not Atomic_Sync_Required (N));\n+      Assert_Expression_Fields_Zero (N);\n+\n+      Extend_Node (N);\n    end Change_Identifier_To_Defining_Identifier;\n \n    ---------------------------------------------\n@@ -132,12 +169,18 @@ package body Sinfo.CN is\n    --------------------------------------------------------\n \n    procedure Change_Operator_Symbol_To_Defining_Operator_Symbol\n-     (N : in out Node_Id)\n+     (N : Node_Id)\n    is\n    begin\n-      Set_Nkind (N, N_Defining_Operator_Symbol);\n-      Set_Node2 (N, Empty); -- Clear unused Str2 field\n-      N := Extend_Node (N);\n+      Reinit_Field_To_Zero (N, Strval);\n+--  ????pragma Assert (No (Node3 (N))); -- Strval is Str3, 0 is out of range\n+      pragma Assert (No (Entity (N)));\n+      pragma Assert (No (Associated_Node (N)));\n+      pragma Assert (No (Etype (N)));\n+      pragma Assert (not Has_Private_View (N));\n+      Assert_Expression_Fields_Zero (N);\n+\n+      Extend_Node (N);\n    end Change_Operator_Symbol_To_Defining_Operator_Symbol;\n \n    ----------------------------------------------\n@@ -146,8 +189,15 @@ package body Sinfo.CN is\n \n    procedure Change_Operator_Symbol_To_String_Literal (N : Node_Id) is\n    begin\n-      Set_Nkind (N, N_String_Literal);\n-      Set_Node1 (N, Empty); -- clear Name1 field\n+      Reinit_Field_To_Zero (N, Chars);\n+      Set_Entity (N, Empty);\n+--  ????pragma Assert (No (Node1 (N))); -- Chars is Name1 out of range\n+      pragma Assert (No (Entity (N)));\n+      pragma Assert (No (Associated_Node (N)));\n+      pragma Assert (No (Etype (N)));\n+      pragma Assert (not Has_Private_View (N));\n+\n+      Mutate_Nkind (N, N_String_Literal);\n    end Change_Operator_Symbol_To_String_Literal;\n \n    ------------------------------------------------\n@@ -156,7 +206,7 @@ package body Sinfo.CN is\n \n    procedure Change_Selected_Component_To_Expanded_Name (N : Node_Id) is\n    begin\n-      Set_Nkind (N, N_Expanded_Name);\n+      Mutate_Nkind (N, N_Expanded_Name);\n       Set_Chars (N, Chars (Selector_Name (N)));\n    end Change_Selected_Component_To_Expanded_Name;\n "}, {"sha": "bf3231b982f7b31febd739fbd1f7c07ffa27c756", "filename": "gcc/ada/sinfo-cn.ads", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinfo-cn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinfo-cn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-cn.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -32,20 +32,19 @@\n \n package Sinfo.CN is\n \n-   procedure Change_Identifier_To_Defining_Identifier (N : in out Node_Id);\n+   procedure Change_Identifier_To_Defining_Identifier (N : Node_Id);\n    --  N must refer to a node of type N_Identifier. This node is modified to\n    --  be of type N_Defining_Identifier. The scanner always returns identifiers\n    --  as N_Identifier. The parser then uses this routine to change the node\n    --  to be a defining identifier where the context demands it. This routine\n-   --  also allocates the necessary extension node. Note that this procedure\n-   --  may (but is not required to) change the Id of the node in question.\n+   --  also allocates the necessary extension node.\n \n    procedure Change_Character_Literal_To_Defining_Character_Literal\n-     (N : in out Node_Id);\n+     (N : Node_Id);\n    --  Similar processing for a character literal\n \n    procedure Change_Operator_Symbol_To_Defining_Operator_Symbol\n-     (N : in out Node_Id);\n+     (N : Node_Id);\n    --  Similar processing for an operator symbol\n \n    procedure Change_Conversion_To_Unchecked (N : Node_Id);"}, {"sha": "abcda46bdfad462a3f0912dffc69fcb51c2cddba", "filename": "gcc/ada/sinfo-utils.adb", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-utils.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,217 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                           S I N F O . U T I L S                          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--           Copyright (C) 2020-2021, Free Software Foundation, Inc.        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;\n+with Seinfo;\n+\n+package body Sinfo.Utils is\n+\n+   -------------------------\n+   -- Iterator Procedures --\n+   -------------------------\n+\n+   procedure Next_Entity       (N : in out Node_Id) is\n+   begin\n+      N := Next_Entity (N);\n+   end Next_Entity;\n+\n+   procedure Next_Named_Actual (N : in out Node_Id) is\n+   begin\n+      N := Next_Named_Actual (N);\n+   end Next_Named_Actual;\n+\n+   procedure Next_Rep_Item     (N : in out Node_Id) is\n+   begin\n+      N := Next_Rep_Item (N);\n+   end Next_Rep_Item;\n+\n+   procedure Next_Use_Clause   (N : in out Node_Id) is\n+   begin\n+      N := Next_Use_Clause (N);\n+   end Next_Use_Clause;\n+\n+   ------------------\n+   -- End_Location --\n+   ------------------\n+\n+   function End_Location (N : Node_Id) return Source_Ptr is\n+      L : constant Uint := End_Span (N);\n+   begin\n+      if L = No_Uint then\n+         return No_Location;\n+      else\n+         return Source_Ptr (Int (Sloc (N)) + UI_To_Int (L));\n+      end if;\n+   end End_Location;\n+\n+   --------------------\n+   -- Get_Pragma_Arg --\n+   --------------------\n+\n+   function Get_Pragma_Arg (Arg : Node_Id) return Node_Id is\n+   begin\n+      if Nkind (Arg) = N_Pragma_Argument_Association then\n+         return Expression (Arg);\n+      else\n+         return Arg;\n+      end if;\n+   end Get_Pragma_Arg;\n+\n+   ----------------------\n+   -- Set_End_Location --\n+   ----------------------\n+\n+   procedure Set_End_Location (N : Node_Id; S : Source_Ptr) is\n+   begin\n+      Set_End_Span (N,\n+        UI_From_Int (Int (S) - Int (Sloc (N))));\n+   end Set_End_Location;\n+\n+   --------------------------\n+   -- Pragma_Name_Unmapped --\n+   --------------------------\n+\n+   function Pragma_Name_Unmapped (N : Node_Id) return Name_Id is\n+   begin\n+      return Chars (Pragma_Identifier (N));\n+   end Pragma_Name_Unmapped;\n+\n+   ------------------------------------\n+   -- Helpers for Walk_Sinfo_Fields* --\n+   ------------------------------------\n+\n+   function Get_Node_Field_Union is new\n+     Atree.Atree_Private_Part.Get_32_Bit_Field (Union_Id) with Inline;\n+   procedure Set_Node_Field_Union is new\n+     Atree.Atree_Private_Part.Set_32_Bit_Field (Union_Id) with Inline;\n+\n+   use Seinfo;\n+\n+   function Is_In_Union_Id (F_Kind : Field_Kind) return Boolean is\n+     (F_Kind in Node_Id_Field\n+              | List_Id_Field\n+              | Elist_Id_Field\n+              | Name_Id_Field\n+              | String_Id_Field\n+              | Uint_Field\n+              | Ureal_Field\n+              | Union_Id_Field);\n+   --  True if the field type is one that can be converted to Types.Union_Id\n+\n+   -----------------------\n+   -- Walk_Sinfo_Fields --\n+   -----------------------\n+\n+   procedure Walk_Sinfo_Fields (N : Node_Id) is\n+      Fields : Node_Field_Array renames\n+        Node_Field_Table (Nkind (N)).all;\n+\n+   begin\n+      for J in Fields'Range loop\n+         if Fields (J) /= Link then -- Don't walk Parent!\n+            declare\n+               Desc : Field_Descriptor renames\n+                 Node_Field_Descriptors (Fields (J));\n+            begin\n+               if Is_In_Union_Id (Desc.Kind) then\n+                  Action (Get_Node_Field_Union (N, Desc.Offset));\n+               end if;\n+            end;\n+         end if;\n+      end loop;\n+   end Walk_Sinfo_Fields;\n+\n+   --------------------------------\n+   -- Walk_Sinfo_Fields_Pairwise --\n+   --------------------------------\n+\n+   procedure Walk_Sinfo_Fields_Pairwise (N1, N2 : Node_Id) is\n+      pragma Assert (Nkind (N1) = Nkind (N2));\n+\n+      Fields : Node_Field_Array renames\n+        Node_Field_Table (Nkind (N1)).all;\n+\n+   begin\n+      for J in Fields'Range loop\n+         if Fields (J) /= Link then -- Don't walk Parent!\n+            declare\n+               Desc : Field_Descriptor renames\n+                 Node_Field_Descriptors (Fields (J));\n+            begin\n+               if Is_In_Union_Id (Desc.Kind) then\n+                  Set_Node_Field_Union\n+                    (N1, Desc.Offset,\n+                     Transform (Get_Node_Field_Union (N2, Desc.Offset)));\n+               end if;\n+            end;\n+         end if;\n+      end loop;\n+   end Walk_Sinfo_Fields_Pairwise;\n+\n+   ---------------------\n+   -- Map_Pragma_Name --\n+   ---------------------\n+\n+   --  We don't want to introduce a dependence on some hash table package or\n+   --  similar, so we use a simple array of Key => Value pairs, and do a linear\n+   --  search. Linear search is plenty efficient, given that we don't expect\n+   --  more than a couple of entries in the mapping.\n+\n+   type Name_Pair is record\n+      Key   : Name_Id;\n+      Value : Name_Id;\n+   end record;\n+\n+   type Pragma_Map_Index is range 1 .. 100;\n+   Pragma_Map : array (Pragma_Map_Index) of Name_Pair;\n+   Last_Pair : Pragma_Map_Index'Base range 0 .. Pragma_Map_Index'Last := 0;\n+\n+   procedure Map_Pragma_Name (From, To : Name_Id) is\n+   begin\n+      if Last_Pair = Pragma_Map'Last then\n+         raise Too_Many_Pragma_Mappings;\n+      end if;\n+\n+      Last_Pair := Last_Pair + 1;\n+      Pragma_Map (Last_Pair) := (Key => From, Value => To);\n+   end Map_Pragma_Name;\n+\n+   -----------------\n+   -- Pragma_Name --\n+   -----------------\n+\n+   function Pragma_Name (N : Node_Id) return Name_Id is\n+      Result : constant Name_Id := Pragma_Name_Unmapped (N);\n+   begin\n+      for J in Pragma_Map'First .. Last_Pair loop\n+         if Result = Pragma_Map (J).Key then\n+            return Pragma_Map (J).Value;\n+         end if;\n+      end loop;\n+\n+      return Result;\n+   end Pragma_Name;\n+\n+end Sinfo.Utils;"}, {"sha": "7d11e2a3b2807adf74747e929922b1eafbe6d516", "filename": "gcc/ada/sinfo-utils.ads", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinfo-utils.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinfo-utils.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-utils.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -0,0 +1,148 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                           S I N F O . U T I L S                          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--           Copyright (C) 2020-2021, Free Software Foundation, Inc.        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+\n+package Sinfo.Utils is\n+\n+   -------------------------\n+   -- Iterator Procedures --\n+   -------------------------\n+\n+   --  The call to Next_xxx (N) is equivalent to N := Next_xxx (N)\n+\n+   procedure Next_Entity       (N : in out Node_Id);\n+   procedure Next_Named_Actual (N : in out Node_Id);\n+   procedure Next_Rep_Item     (N : in out Node_Id);\n+   procedure Next_Use_Clause   (N : in out Node_Id);\n+\n+   -------------------------------------------\n+   -- Miscellaneous Tree Access Subprograms --\n+   -------------------------------------------\n+\n+   function End_Location (N : Node_Id) return Source_Ptr;\n+   --  N is an N_If_Statement or N_Case_Statement node, and this function\n+   --  returns the location of the IF token in the END IF sequence by\n+   --  translating the value of the End_Span field.\n+\n+   --  WARNING: There is a matching C declaration of this subprogram in fe.h\n+\n+   procedure Set_End_Location (N : Node_Id; S : Source_Ptr);\n+   --  N is an N_If_Statement or N_Case_Statement node. This procedure sets\n+   --  the End_Span field to correspond to the given value S. In other words,\n+   --  End_Span is set to the difference between S and Sloc (N), the starting\n+   --  location.\n+\n+   function Get_Pragma_Arg (Arg : Node_Id) return Node_Id;\n+   --  Given an argument to a pragma Arg, this function returns the expression\n+   --  for the argument. This is Arg itself, or, in the case where Arg is a\n+   --  pragma argument association node, the expression from this node.\n+\n+   -----------------------\n+   -- Utility Functions --\n+   -----------------------\n+\n+   procedure Map_Pragma_Name (From, To : Name_Id);\n+   --  Used in the implementation of pragma Rename_Pragma. Maps pragma name\n+   --  From to pragma name To, so From can be used as a synonym for To.\n+\n+   Too_Many_Pragma_Mappings : exception;\n+   --  Raised if Map_Pragma_Name is called too many times. We expect that few\n+   --  programs will use it at all, and those that do will use it approximately\n+   --  once or twice.\n+\n+   function Pragma_Name (N : Node_Id) return Name_Id;\n+   --  Obtain the name of pragma N from the Chars field of its identifier. If\n+   --  the pragma has been renamed using Rename_Pragma, this routine returns\n+   --  the name of the renaming.\n+\n+   function Pragma_Name_Unmapped (N : Node_Id) return Name_Id;\n+   --  Obtain the name of pragma N from the Chars field of its identifier. This\n+   --  form of name extraction does not take into account renamings performed\n+   --  by Rename_Pragma.\n+\n+   generic\n+      with procedure Action (U : Union_Id);\n+   procedure Walk_Sinfo_Fields (N : Node_Id);\n+   --  Walk the Sinfo fields of N, for all field types that Union_Id includes,\n+   --  and call Action on each one. However, skip the Link field, which is the\n+   --  Parent, and would cause us to wander off into the weeds. ????It's not\n+   --  clear why this should walk semantic fields.\n+\n+   generic\n+      with function Transform (U : Union_Id) return Union_Id;\n+   procedure Walk_Sinfo_Fields_Pairwise (N1, N2 : Node_Id);\n+   --  Walks the Sinfo fields of N1 and N2 pairwise, calls Tranform on each N2\n+   --  field, copying the resut into the corresponding field of N1. The Nkinds\n+   --  must match. Link is skipped.\n+\n+   -------------------------------------------\n+   -- Aliases for Entity_Or_Associated_Node --\n+   -------------------------------------------\n+\n+   --  Historically, the Entity, Associated_Node, and Entity_Or_Associated_Node\n+   --  fields shared the same slot. A further complication is that there is an\n+   --  N_Has_Entity that does not include all node types that have the Entity\n+   --  field.\n+\n+   subtype N_Really_Has_Entity is Node_Id with Predicate =>\n+     N_Really_Has_Entity in\n+       N_Has_Entity_Id\n+       | N_Attribute_Definition_Clause_Id\n+       | N_Aspect_Specification_Id\n+       | N_Freeze_Entity_Id\n+       | N_Freeze_Generic_Entity_Id;\n+\n+   subtype N_Has_Associated_Node is Node_Id with Predicate =>\n+     N_Has_Associated_Node in\n+       N_Has_Entity_Id\n+       | N_Aggregate_Id\n+       | N_Extension_Aggregate_Id\n+       | N_Selected_Component_Id\n+       | N_Use_Package_Clause_Id;\n+\n+   function Associated_Node\n+     (N : N_Has_Associated_Node) return Node_Id\n+      renames Entity_Or_Associated_Node;\n+\n+   function Entity\n+     (N : N_Really_Has_Entity) return Node_Id\n+      renames Entity_Or_Associated_Node;\n+\n+   procedure Set_Associated_Node\n+     (N : N_Has_Associated_Node; Val : Node_Id)\n+      renames Set_Entity_Or_Associated_Node;\n+\n+   procedure Set_Entity\n+     (N : N_Really_Has_Entity; Val : Node_Id)\n+      renames Set_Entity_Or_Associated_Node;\n+\n+   function Associated_Node return Node_Field renames\n+     Entity_Or_Associated_Node;\n+   function Entity return Node_Field renames\n+     Entity_Or_Associated_Node;\n+   --  Note that we are renaming the enumeration literals here\n+\n+end Sinfo.Utils;"}, {"sha": "8c5c32a4f0af6e8ce48540fed2b855706a149c8e", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 1, "deletions": 7163, "changes": 7164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e"}, {"sha": "9d8dc09dc374adae3bb6dedb8a72df70f14529ac", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 19, "deletions": 5315, "changes": 5334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e"}, {"sha": "6529e175faaea7098ccd539fbb9403885655681a", "filename": "gcc/ada/sinput-l.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinput-l.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinput-l.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-l.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Alloc;\n with Atree;    use Atree;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Fname;    use Fname;\n with Lib;      use Lib;\n@@ -39,7 +41,8 @@ with Scans;    use Scans;\n with Scn;      use Scn;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Snames;   use Snames;\n with System;   use System;\n "}, {"sha": "0041f0438af18bb016b9bfd28ade8d0426328372", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -31,6 +31,8 @@ with Debug;    use Debug;\n with Opt;      use Opt;\n with Output;   use Output;\n with Scans;    use Scans;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Widechar; use Widechar;\n \n with GNAT.Byte_Order_Mark; use GNAT.Byte_Order_Mark;"}, {"sha": "3e8348d0c1718c05a13485302d97f503682caf4d", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -28,7 +28,9 @@ with Atree;    use Atree;\n with Casing;   use Casing;\n with Csets;    use Csets;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -37,7 +39,9 @@ with Output;   use Output;\n with Rtsfind;  use Rtsfind;\n with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Sinput.D; use Sinput.D;\n with Snames;   use Snames;"}, {"sha": "8b926deb77a52b52545fedac9a620190be0e490b", "filename": "gcc/ada/style.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fstyle.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fstyle.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyle.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,12 +26,16 @@\n with Atree;    use Atree;\n with Casing;   use Casing;\n with Csets;    use Csets;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Errout;   use Errout;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n with Stand;    use Stand;\n with Stylesw;  use Stylesw;"}, {"sha": "4d0fd541b89744d024831ca1d8b2b7b9a1572433", "filename": "gcc/ada/styleg.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fstyleg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Fstyleg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyleg.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -30,11 +30,13 @@\n with Atree;    use Atree;\n with Casing;   use Casing;\n with Csets;    use Csets;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Utils; use Einfo.Utils;\n with Err_Vars; use Err_Vars;\n with Opt;      use Opt;\n with Scans;    use Scans;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Sinput;   use Sinput;\n with Stylesw;  use Stylesw;\n "}, {"sha": "31e6dee435e947529dcd0fab1e697ed5fa3e2387", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -26,7 +26,9 @@\n with Atree;    use Atree;\n with Aspects;  use Aspects;\n with Csets;    use Csets;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Lib;      use Lib;\n with Nlists;   use Nlists;\n@@ -35,6 +37,7 @@ with Opt;      use Opt;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Sem_Aux;  use Sem_Aux;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sem_Util; use Sem_Util;\n with Snames;   use Snames;\n with Stand;    use Stand;"}, {"sha": "e19e2fb4311fde521c29b9b4c2ef17449a1279d5", "filename": "gcc/ada/tbuild.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ftbuild.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ftbuild.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -28,6 +28,7 @@\n \n with Namet; use Namet;\n with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n with Types; use Types;\n with Uintp; use Uintp;\n "}, {"sha": "44ac8d0283caa6361bf9cba4e89c3dd1e5dee2e3", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 617, "deletions": 552, "changes": 1169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -27,32 +27,31 @@ with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Csets;    use Csets;\n with Debug;    use Debug;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Einfo.Utils; use Einfo.Utils;\n with Elists;   use Elists;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Output;   use Output;\n-with Sem_Mech; use Sem_Mech;\n-with Sinfo;    use Sinfo;\n+with Seinfo; use Seinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Snames;   use Snames;\n with Sinput;   use Sinput;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n with SCIL_LL;  use SCIL_LL;\n-with Treeprs;  use Treeprs;\n with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n with Uname;    use Uname;\n+with Unchecked_Conversion;\n with Unchecked_Deallocation;\n \n package body Treepr is\n \n-   use Atree.Unchecked_Access;\n-   --  This module uses the unchecked access functions in package Atree\n-   --  since it does an untyped traversal of the tree (we do not want to\n-   --  count on the structure of the tree being correct in this routine).\n-\n    ----------------------------------\n    -- Approach Used for Tree Print --\n    ----------------------------------\n@@ -77,6 +76,10 @@ package body Treepr is\n    -- Global Variables --\n    ----------------------\n \n+   Include_Low_Level : Boolean := False with Warnings => Off;\n+   --  Set True to print low-level information useful for debugging Atree and\n+   --  the like.\n+\n    type Hash_Record is record\n       Serial : Nat;\n       --  Serial number for hash table entry. A value of zero means that\n@@ -120,10 +123,18 @@ package body Treepr is\n    -- Local Procedures --\n    ----------------------\n \n-   procedure Print_End_Span (N : Node_Id);\n-   --  Special routine to print contents of End_Span field of node N.\n-   --  The format includes the implicit source location as well as the\n-   --  value of the field.\n+   function From_Union is new Unchecked_Conversion (Union_Id, Uint);\n+   function From_Union is new Unchecked_Conversion (Union_Id, Ureal);\n+\n+   --  Print_End_Span is gone. Should be restored????\n+\n+   function Capitalize (S : String) return String;\n+   procedure Capitalize (S : in out String);\n+   --  Turns an identifier into Mixed_Case\n+\n+   function Image (F : Node_Field) return String;\n+\n+   function Image (F : Entity_Field) return String;\n \n    procedure Print_Init;\n    --  Initialize for printing of tree with descendants\n@@ -172,9 +183,30 @@ package body Treepr is\n    --  extension, using routines in Einfo to get the field names and flags.\n \n    procedure Print_Field (Val : Union_Id; Format : UI_Format := Auto);\n+   procedure Print_Field\n+     (Prefix : String;\n+      Field : String;\n+      N : Node_Or_Entity_Id;\n+      FD : Field_Descriptor;\n+      Format : UI_Format);\n    --  Print representation of Field value (name, tree, string, uint, charcode)\n    --  The format parameter controls the format of printing in the case of an\n-   --  integer value (see UI_Write for details).\n+   --  integer value (see UI_Write for details).????\n+   --  Do we really need two of these???\n+\n+   procedure Print_Node_Field\n+     (Prefix : String;\n+      Field : Node_Field;\n+      N : Node_Id;\n+      FD : Field_Descriptor;\n+      Format : UI_Format := Auto);\n+\n+   procedure Print_Entity_Field\n+     (Prefix : String;\n+      Field : Entity_Field;\n+      N : Entity_Id;\n+      FD : Field_Descriptor;\n+      Format : UI_Format := Auto);\n \n    procedure Print_Flag (F : Boolean);\n    --  Print True or False\n@@ -215,6 +247,149 @@ package body Treepr is\n    --  descendants are to be printed. Prefix_Str is to be added to all\n    --  printed lines.\n \n+   ----------------\n+   -- Capitalize --\n+   ----------------\n+\n+   procedure Capitalize (S : in out String) is\n+      Cap : Boolean := True;\n+   begin\n+      for J in S'Range loop\n+         declare\n+            Old : constant Character := S (J);\n+         begin\n+            if Cap then\n+               S (J) := Fold_Upper (S (J));\n+            else\n+               S (J) := Fold_Lower (S (J));\n+            end if;\n+\n+            Cap := Old = '_';\n+         end;\n+      end loop;\n+   end Capitalize;\n+\n+   function Capitalize (S : String) return String is\n+   begin\n+      return Result : String (S'Range) := S do\n+         Capitalize (Result);\n+      end return;\n+   end Capitalize;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (F : Node_Field) return String is\n+   begin\n+      case F is\n+         when Alloc_For_BIP_Return =>\n+            return \"Alloc_For_BIP_Return\";\n+         when Assignment_OK =>\n+            return \"Assignment_OK\";\n+         when Backwards_OK =>\n+            return \"Backwards_OK\";\n+         when Conversion_OK =>\n+            return \"Conversion_OK\";\n+         when Forwards_OK =>\n+            return \"Forwards_OK\";\n+         when Has_SP_Choice =>\n+            return \"Has_SP_Choice\";\n+         when Is_Elaboration_Checks_OK_Node =>\n+            return \"Is_Elaboration_Checks_OK_Node\";\n+         when Is_Elaboration_Warnings_OK_Node =>\n+            return \"Is_Elaboration_Warnings_OK_Node\";\n+         when Is_Known_Guaranteed_ABE =>\n+            return \"Is_Known_Guaranteed_ABE\";\n+         when Is_SPARK_Mode_On_Node =>\n+            return \"Is_SPARK_Mode_On_Node\";\n+         when Local_Raise_Not_OK =>\n+            return \"Local_Raise_Not_OK\";\n+         when SCIL_Controlling_Tag =>\n+            return \"SCIL_Controlling_Tag\";\n+         when SCIL_Entity =>\n+            return \"SCIL_Entity\";\n+         when SCIL_Tag_Value =>\n+            return \"SCIL_Tag_Value\";\n+         when SCIL_Target_Prim =>\n+            return \"SCIL_Target_Prim\";\n+         when Shift_Count_OK =>\n+            return \"Shift_Count_OK\";\n+         when Split_PPC =>\n+            return \"Split_PPC\";\n+         when TSS_Elist =>\n+            return \"TSS_Elist\";\n+\n+         when others =>\n+            return Capitalize (F'Img);\n+      end case;\n+   end Image;\n+\n+   function Image (F : Entity_Field) return String is\n+   begin\n+      case F is\n+         when BIP_Initialization_Call =>\n+            return \"BIP_Initialization_Call\";\n+         when Body_Needed_For_SAL =>\n+            return \"Body_Needed_For_SAL\";\n+         when CR_Discriminant =>\n+            return \"CR_Discriminant\";\n+         when DT_Entry_Count =>\n+            return \"DT_Entry_Count\";\n+         when DT_Offset_To_Top_Func =>\n+            return \"DT_Offset_To_Top_Func\";\n+         when DT_Position =>\n+            return \"DT_Position\";\n+         when DTC_Entity =>\n+            return \"DTC_Entity\";\n+         when Has_Inherited_DIC =>\n+            return \"Has_Inherited_DIC\";\n+         when Has_Own_DIC =>\n+            return \"Has_Own_DIC\";\n+         when Has_RACW =>\n+            return \"Has_RACW\";\n+         when Ignore_SPARK_Mode_Pragmas =>\n+            return \"Ignore_SPARK_Mode_Pragmas\";\n+         when Is_Constr_Subt_For_UN_Aliased =>\n+            return \"Is_Constr_Subt_For_UN_Aliased\";\n+         when Is_CPP_Class =>\n+            return \"Is_CPP_Class\";\n+         when Is_CUDA_Kernel =>\n+            return \"Is_CUDA_Kernel\";\n+         when Is_DIC_Procedure =>\n+            return \"Is_DIC_Procedure\";\n+         when Is_Discrim_SO_Function =>\n+            return \"Is_Discrim_SO_Function\";\n+         when Is_Elaboration_Checks_OK_Id =>\n+            return \"Is_Elaboration_Checks_OK_Id\";\n+         when Is_Elaboration_Warnings_OK_Id =>\n+            return \"Is_Elaboration_Warnings_OK_Id\";\n+         when Is_RACW_Stub_Type =>\n+            return \"Is_RACW_Stub_Type\";\n+         when OK_To_Rename =>\n+            return \"OK_To_Rename\";\n+         when Referenced_As_LHS =>\n+            return \"Referenced_As_LHS\";\n+         when RM_Size =>\n+            return \"RM_Size\";\n+         when SPARK_Aux_Pragma =>\n+            return \"SPARK_Aux_Pragma\";\n+         when SPARK_Aux_Pragma_Inherited =>\n+            return \"SPARK_Aux_Pragma_Inherited\";\n+         when SPARK_Pragma =>\n+            return \"SPARK_Pragma\";\n+         when SPARK_Pragma_Inherited =>\n+            return \"SPARK_Pragma_Inherited\";\n+         when SSO_Set_High_By_Default =>\n+            return \"SSO_Set_High_By_Default\";\n+         when SSO_Set_Low_By_Default =>\n+            return \"SSO_Set_Low_By_Default\";\n+\n+         when others =>\n+            return Capitalize (F'Img);\n+      end case;\n+   end Image;\n+\n    -------\n    -- p --\n    -------\n@@ -415,45 +590,11 @@ package body Treepr is\n       Print_Term;\n    end Print_Elist_Subtree;\n \n-   --------------------\n-   -- Print_End_Span --\n-   --------------------\n-\n-   procedure Print_End_Span (N : Node_Id) is\n-      Val : constant Uint := End_Span (N);\n-\n-   begin\n-      UI_Write (Val);\n-      Write_Str (\" (Uint = \");\n-      Write_Int (Int (Field5 (N)));\n-      Write_Str (\")  \");\n-\n-      if Val /= No_Uint then\n-         Write_Location (End_Location (N));\n-      end if;\n-   end Print_End_Span;\n-\n    -----------------------\n    -- Print_Entity_Info --\n    -----------------------\n \n    procedure Print_Entity_Info (Ent : Entity_Id; Prefix : String) is\n-      function Field_Present (U : Union_Id) return Boolean;\n-      --  Returns False unless the value U represents a missing value\n-      --  (Empty, No_Elist, No_Uint, No_Ureal or No_String)\n-\n-      function Field_Present (U : Union_Id) return Boolean is\n-      begin\n-         return\n-            U /= Union_Id (Empty)    and then\n-            U /= Union_Id (No_Elist) and then\n-            U /= To_Union (No_Uint)  and then\n-            U /= To_Union (No_Ureal) and then\n-            U /= Union_Id (No_String);\n-      end Field_Present;\n-\n-   --  Start of processing for Print_Entity_Info\n-\n    begin\n       Print_Str (Prefix);\n       Print_Str (\"Ekind = \");\n@@ -480,340 +621,98 @@ package body Treepr is\n          end;\n       end if;\n \n-      if Field_Present (Field6 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field6_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field6 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field7 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field7_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field7 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field8 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field8_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field8 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field9 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field9_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field9 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field10 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field10_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field10 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field11 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field11_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field11 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field12 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field12_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field12 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field13 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field13_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field13 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field14 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field14_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field14 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field15 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field15_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field15 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field16 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field16_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field16 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field17 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field17_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field17 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field18 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field18_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field18 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field19 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field19_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field19 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field20 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field20_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field20 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field21 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field21_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field21 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field22 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field22_Name (Ent);\n-         Write_Str (\" = \");\n-\n-         --  Mechanism case has to be handled specially\n-\n-         if Ekind (Ent) = E_Function or else Is_Formal (Ent) then\n-            declare\n-               M : constant Mechanism_Type := Mechanism (Ent);\n-\n-            begin\n-               case M is\n-                  when Default_Mechanism =>\n-                     Write_Str (\"Default\");\n-\n-                  when By_Copy =>\n-                     Write_Str (\"By_Copy\");\n-\n-                  when By_Reference =>\n-                     Write_Str (\"By_Reference\");\n-\n-                  when 1 .. Mechanism_Type'Last =>\n-                     Write_Str (\"By_Copy if size <= \");\n-                     Write_Int (Int (M));\n-               end case;\n-            end;\n-\n-         --  Normal case (not Mechanism)\n-\n-         else\n-            Print_Field (Field22 (Ent));\n-         end if;\n-\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field23 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field23_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field23 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field24 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field24_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field24 (Ent));\n-         Print_Eol;\n-      end if;\n-\n-      if Field_Present (Field25 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field25_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field25 (Ent));\n-         Print_Eol;\n-      end if;\n+      declare\n+         A : Entity_Field_Array renames Entity_Field_Table (Ekind (Ent)).all;\n+         Already_Printed_Above : constant Entity_Field_Set :=\n+           (Ekind\n+              | Basic_Convention => True, -- Convention was printed\n+            others => False);\n+      begin\n+         --  Outer loop makes flags come out last\n+\n+         for Print_Flags in Boolean loop\n+            for Field_Index in A'Range loop\n+               declare\n+                  FD : Field_Descriptor renames\n+                    Entity_Field_Descriptors (A (Field_Index));\n+               begin\n+                  if Already_Printed_Above (A (Field_Index))  then\n+                     null; -- Skip the ones already printed\n+\n+                  elsif (FD.Kind = Flag_Field) = Print_Flags then\n+                     Print_Entity_Field\n+                       (Prefix, A (Field_Index), Ent, FD);\n+                  end if;\n+               end;\n+            end loop;\n+         end loop;\n+      end;\n+   end Print_Entity_Info;\n \n-      if Field_Present (Field26 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field26_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field26 (Ent));\n-         Print_Eol;\n-      end if;\n+   ---------------\n+   -- Print_Eol --\n+   ---------------\n \n-      if Field_Present (Field27 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field27_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field27 (Ent));\n-         Print_Eol;\n+   procedure Print_Eol is\n+   begin\n+      if Phase = Printing then\n+         Write_Eol;\n       end if;\n+   end Print_Eol;\n \n-      if Field_Present (Field28 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field28_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field28 (Ent));\n-         Print_Eol;\n-      end if;\n+   -----------------\n+   -- Print_Field --\n+   -----------------\n \n-      if Field_Present (Field29 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field29_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field29 (Ent));\n-         Print_Eol;\n-      end if;\n+   --  Instantiations of low-level getters and setters that take offsets\n+   --  in units of the size of the field.\n \n-      if Field_Present (Field30 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field30_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field30 (Ent));\n-         Print_Eol;\n-      end if;\n+   use Atree.Atree_Private_Part;\n \n-      if Field_Present (Field31 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field31_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field31 (Ent));\n-         Print_Eol;\n-      end if;\n+   function Get_Flag is new Get_1_Bit_Field\n+     (Boolean) with Inline;\n \n-      if Field_Present (Field32 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field32_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field32 (Ent));\n-         Print_Eol;\n-      end if;\n+   function Get_Node_Id is new Get_32_Bit_Field\n+     (Node_Id) with Inline;\n \n-      if Field_Present (Field33 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field33_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field33 (Ent));\n-         Print_Eol;\n-      end if;\n+   function Get_List_Id is new Get_32_Bit_Field\n+     (List_Id) with Inline;\n \n-      if Field_Present (Field34 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field34_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field34 (Ent));\n-         Print_Eol;\n-      end if;\n+   function Get_Elist_Id is new Get_32_Bit_Field_With_Default\n+     (Elist_Id, No_Elist) with Inline;\n \n-      if Field_Present (Field35 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field35_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field35 (Ent));\n-         Print_Eol;\n-      end if;\n+   function Get_Name_Id is new Get_32_Bit_Field\n+     (Name_Id) with Inline;\n \n-      if Field_Present (Field36 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field36_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field36 (Ent));\n-         Print_Eol;\n-      end if;\n+   function Get_String_Id is new Get_32_Bit_Field\n+     (String_Id) with Inline;\n \n-      if Field_Present (Field37 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field37_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field37 (Ent));\n-         Print_Eol;\n-      end if;\n+   function Get_Uint is new Get_32_Bit_Field_With_Default\n+     (Uint, Uint_0) with Inline;\n \n-      if Field_Present (Field38 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field38_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field38 (Ent));\n-         Print_Eol;\n-      end if;\n+   function Get_Ureal is new Get_32_Bit_Field\n+     (Ureal) with Inline;\n \n-      if Field_Present (Field39 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field39_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field39 (Ent));\n-         Print_Eol;\n-      end if;\n+   function Get_Nkind_Type is new Get_8_Bit_Field\n+     (Node_Kind) with Inline;\n \n-      if Field_Present (Field40 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field40_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field40 (Ent));\n-         Print_Eol;\n-      end if;\n+   function Get_Ekind_Type is new Get_8_Bit_Field\n+     (Entity_Kind) with Inline;\n \n-      if Field_Present (Field41 (Ent)) then\n-         Print_Str (Prefix);\n-         Write_Field41_Name (Ent);\n-         Write_Str (\" = \");\n-         Print_Field (Field41 (Ent));\n-         Print_Eol;\n-      end if;\n+   function Get_Source_Ptr is new Get_32_Bit_Field\n+     (Source_Ptr) with Inline, Unreferenced;\n \n-      Write_Entity_Flags (Ent, Prefix);\n-   end Print_Entity_Info;\n+   function Get_Small_Paren_Count_Type is new Get_2_Bit_Field\n+     (Small_Paren_Count_Type) with Inline, Unreferenced;\n \n-   ---------------\n-   -- Print_Eol --\n-   ---------------\n+   function Get_Union_Id is new Get_32_Bit_Field\n+     (Union_Id) with Inline;\n \n-   procedure Print_Eol is\n-   begin\n-      if Phase = Printing then\n-         Write_Eol;\n-      end if;\n-   end Print_Eol;\n+   function Get_Convention_Id is new Get_8_Bit_Field\n+     (Convention_Id) with Inline, Unreferenced;\n \n-   -----------------\n-   -- Print_Field --\n-   -----------------\n+   function Get_Mechanism_Type is new Get_32_Bit_Field\n+     (Mechanism_Type) with Inline, Unreferenced;\n \n    procedure Print_Field (Val : Union_Id; Format : UI_Format := Auto) is\n    begin\n@@ -860,6 +759,236 @@ package body Treepr is\n       end if;\n    end Print_Field;\n \n+   procedure Print_Field\n+     (Prefix : String;\n+      Field : String;\n+      N : Node_Or_Entity_Id;\n+      FD : Field_Descriptor;\n+      Format : UI_Format) is\n+\n+      Printed : Boolean := False;\n+\n+      procedure Print_Initial;\n+      --  Print the initial stuff that goes before the value\n+\n+      procedure Print_Initial is\n+      begin\n+         Printed := True;\n+         Print_Str (Prefix);\n+         Print_Str (Field);\n+\n+         if Include_Low_Level then\n+            Write_Str (\" at \");\n+            Write_Int (Int (FD.Offset));\n+         end if;\n+\n+         Write_Str (\" = \");\n+      end Print_Initial;\n+\n+   begin\n+      if Phase /= Printing then\n+         return;\n+      end if;\n+\n+      case FD.Kind is\n+         when Flag_Field =>\n+            declare\n+               Val : constant Boolean := Get_Flag (N, FD.Offset);\n+            begin\n+               if Val then\n+                  Print_Initial;\n+                  Print_Flag (Val);\n+               end if;\n+            end;\n+\n+         when Node_Id_Field =>\n+            declare\n+               Val : constant Node_Id := Get_Node_Id (N, FD.Offset);\n+            begin\n+               if Present (Val) then\n+                  Print_Initial;\n+                  Print_Node_Ref (Val);\n+               end if;\n+            end;\n+\n+         when List_Id_Field =>\n+            declare\n+               Val : constant List_Id := Get_List_Id (N, FD.Offset);\n+            begin\n+               if Present (Val) then\n+                  Print_Initial;\n+                  Print_List_Ref (Val);\n+               end if;\n+            end;\n+\n+         when Elist_Id_Field =>\n+            declare\n+               Val : constant Elist_Id := Get_Elist_Id (N, FD.Offset);\n+            begin\n+               if Present (Val) then\n+                  Print_Initial;\n+                  Print_Elist_Ref (Val);\n+               end if;\n+            end;\n+\n+         when Name_Id_Field =>\n+            declare\n+               Val : constant Name_Id := Get_Name_Id (N, FD.Offset);\n+            begin\n+               if Present (Val) then\n+                  Print_Initial;\n+                  Print_Name (Val);\n+                  Write_Str (\" (Name_Id=\");\n+                  Write_Int (Int (Val));\n+                  Write_Char (')');\n+               end if;\n+            end;\n+\n+         when String_Id_Field =>\n+            declare\n+               Val : constant String_Id := Get_String_Id (N, FD.Offset);\n+            begin\n+               if Val /= No_String then\n+                  Print_Initial;\n+                  Write_String_Table_Entry (Val);\n+                  Write_Str (\" (String_Id=\");\n+                  Write_Int (Int (Val));\n+                  Write_Char (')');\n+               end if;\n+            end;\n+\n+         when Uint_Field =>\n+            declare\n+               Val : constant Uint := Get_Uint (N, FD.Offset);\n+               function Cast is new Unchecked_Conversion (Uint, Int);\n+            begin\n+               if Val /= No_Uint then\n+                  Print_Initial;\n+                  UI_Write (Val, Format);\n+                  Write_Str (\" (Uint = \");\n+                  Write_Int (Cast (Val));\n+                  Write_Char (')');\n+               end if;\n+            end;\n+\n+         when Ureal_Field =>\n+            declare\n+               Val : constant Ureal := Get_Ureal (N, FD.Offset);\n+               function Cast is new Unchecked_Conversion (Ureal, Int);\n+            begin\n+               if Val /= No_Ureal then\n+                  Print_Initial;\n+                  UR_Write (Val);\n+                  Write_Str (\" (Ureal = \");\n+                  Write_Int (Cast (Val));\n+                  Write_Char (')');\n+               end if;\n+            end;\n+\n+         when Nkind_Type_Field =>\n+            declare\n+               Val : constant Node_Kind := Get_Nkind_Type (N, FD.Offset);\n+            begin\n+               Print_Initial;\n+               Print_Str_Mixed_Case (Node_Kind'Image (Val));\n+            end;\n+\n+         when Ekind_Type_Field =>\n+            declare\n+               Val : constant Entity_Kind := Get_Ekind_Type (N, FD.Offset);\n+            begin\n+               Print_Initial;\n+               Print_Str_Mixed_Case (Entity_Kind'Image (Val));\n+            end;\n+\n+            pragma Style_Checks (\"M200\");\n+\n+         when Union_Id_Field =>\n+            declare\n+               Val : constant Union_Id := Get_Union_Id (N, FD.Offset);\n+            begin\n+               if Val /= Empty_List_Or_Node then\n+                  Print_Initial;\n+\n+                  if Val in Node_Range then\n+                     Print_Node_Ref (Node_Id (Val));\n+\n+                  elsif Val in List_Range then\n+                     Print_List_Ref (List_Id (Val));\n+\n+                  else\n+                     Print_Str (\"????union id out of range\");\n+                  end if;\n+               end if;\n+            end;\n+            pragma Style_Checks (\"M79\");\n+\n+         when others =>\n+            Print_Initial;\n+            Print_Str (\"????\");\n+      end case;\n+\n+      if Printed then\n+         Print_Eol;\n+      end if;\n+\n+   exception\n+      when others =>\n+         declare\n+            function Cast is new Unchecked_Conversion (Field_32_Bit, Int);\n+         begin\n+            Write_Eol;\n+            Print_Initial;\n+            Write_Str (\"exception raised in Print_Field -- int val = \");\n+            Write_Eol;\n+\n+            case Field_Size (FD.Kind) is\n+               when 1 => Write_Int (Int (Get_1_Bit_Val (N, FD.Offset)));\n+               when 2 => Write_Int (Int (Get_2_Bit_Val (N, FD.Offset)));\n+               when 4 => Write_Int (Int (Get_4_Bit_Val (N, FD.Offset)));\n+               when 8 => Write_Int (Int (Get_8_Bit_Val (N, FD.Offset)));\n+               when others =>  -- 32\n+                  Write_Int (Cast (Get_32_Bit_Val (N, FD.Offset)));\n+            end case;\n+\n+            Write_Str (\", \");\n+            Write_Str (FD.Kind'Img);\n+            Write_Str (\" \");\n+            Write_Int (Int (Field_Size (FD.Kind)));\n+            Write_Str (\" bits\");\n+            Write_Eol;\n+         exception\n+            when others =>\n+               Write_Eol;\n+               Write_Str (\"double exception raised in Print_Field\");\n+               Write_Eol;\n+         end;\n+   end Print_Field;\n+\n+   procedure Print_Node_Field\n+     (Prefix : String;\n+      Field : Node_Field;\n+      N : Node_Id;\n+      FD : Field_Descriptor;\n+      Format : UI_Format := Auto) is\n+   begin\n+      if not Field_Is_Initial_Zero (N, Field) then\n+         Print_Field (Prefix, Image (Field), N, FD, Format);\n+      end if;\n+   end Print_Node_Field;\n+\n+   procedure Print_Entity_Field\n+     (Prefix : String;\n+      Field : Entity_Field;\n+      N : Entity_Id;\n+      FD : Field_Descriptor;\n+      Format : UI_Format := Auto) is\n+   begin\n+      if not Field_Is_Initial_Zero (N, Field) then\n+         Print_Field (Prefix, Image (Field), N, FD, Format);\n+      end if;\n+   end Print_Entity_Field;\n+\n    ----------------\n    -- Print_Flag --\n    ----------------\n@@ -993,11 +1122,7 @@ package body Treepr is\n       Prefix_Str  : String;\n       Prefix_Char : Character)\n    is\n-      F : Fchar;\n-      P : Natural;\n-\n-      Field_To_Be_Printed : Boolean;\n-      Prefix_Str_Char     : String (Prefix_Str'First .. Prefix_Str'Last + 1);\n+      Prefix : constant String := Prefix_Str & Prefix_Char;\n \n       Sfile : Source_File_Index;\n       Fmt   : UI_Format;\n@@ -1010,25 +1135,13 @@ package body Treepr is\n       --  If there is no such node, indicate that. Skip the rest, so we don't\n       --  crash getting fields of the nonexistent node.\n \n-      if N > Atree_Private_Part.Nodes.Last then\n+      if not Is_Valid_Node (Union_Id (N)) then\n          Print_Str (\"No such node: \");\n          Print_Int (Int (N));\n          Print_Eol;\n          return;\n       end if;\n \n-      --  Similarly, if N points to an extension, avoid crashing\n-\n-      if Atree_Private_Part.Nodes.Table (N).Is_Extension then\n-         Print_Int (Int (N));\n-         Print_Str (\" is an extension, not a node\");\n-         Print_Eol;\n-         return;\n-      end if;\n-\n-      Prefix_Str_Char (Prefix_Str'Range)    := Prefix_Str;\n-      Prefix_Str_Char (Prefix_Str'Last + 1) := Prefix_Char;\n-\n       --  Print header line\n \n       Print_Str (Prefix_Str);\n@@ -1041,6 +1154,10 @@ package body Treepr is\n          Print_Eol;\n       end if;\n \n+      if Include_Low_Level then\n+         Print_Atree_Info (N);\n+      end if;\n+\n       if N = Empty then\n          return;\n       end if;\n@@ -1055,7 +1172,7 @@ package body Treepr is\n       --  Print Sloc field if it is set\n \n       if Sloc (N) /= No_Location then\n-         Print_Str (Prefix_Str_Char);\n+         Print_Str (Prefix);\n          Print_Str (\"Sloc = \");\n \n          if Sloc (N) = Standard_Location then\n@@ -1077,7 +1194,7 @@ package body Treepr is\n       --  Print Chars field if present\n \n       if Nkind (N) in N_Has_Chars and then Chars (N) /= No_Name then\n-         Print_Str (Prefix_Str_Char);\n+         Print_Str (Prefix);\n          Print_Str (\"Chars = \");\n          Print_Name (Chars (N));\n          Write_Str (\" (Name_Id=\");\n@@ -1099,15 +1216,15 @@ package body Treepr is\n             --  Print Left_Opnd if present\n \n             if Nkind (N) not in N_Unary_Op then\n-               Print_Str (Prefix_Str_Char);\n+               Print_Str (Prefix);\n                Print_Str (\"Left_Opnd = \");\n                Print_Node_Ref (Left_Opnd (N));\n                Print_Eol;\n             end if;\n \n             --  Print Right_Opnd\n \n-            Print_Str (Prefix_Str_Char);\n+            Print_Str (Prefix);\n             Print_Str (\"Right_Opnd = \");\n             Print_Node_Ref (Right_Opnd (N));\n             Print_Eol;\n@@ -1117,7 +1234,7 @@ package body Treepr is\n          --  are in the table, so are handled in the normal circuit)\n \n          if Nkind (N) in N_Op and then Present (Entity (N)) then\n-            Print_Str (Prefix_Str_Char);\n+            Print_Str (Prefix);\n             Print_Str (\"Entity = \");\n             Print_Node_Ref (Entity (N));\n             Print_Eol;\n@@ -1128,62 +1245,62 @@ package body Treepr is\n          if Nkind (N) in N_Subexpr then\n \n             if Assignment_OK (N) then\n-               Print_Str (Prefix_Str_Char);\n+               Print_Str (Prefix);\n                Print_Str (\"Assignment_OK = True\");\n                Print_Eol;\n             end if;\n \n             if Do_Range_Check (N) then\n-               Print_Str (Prefix_Str_Char);\n+               Print_Str (Prefix);\n                Print_Str (\"Do_Range_Check = True\");\n                Print_Eol;\n             end if;\n \n             if Has_Dynamic_Length_Check (N) then\n-               Print_Str (Prefix_Str_Char);\n+               Print_Str (Prefix);\n                Print_Str (\"Has_Dynamic_Length_Check = True\");\n                Print_Eol;\n             end if;\n \n             if Has_Aspects (N) then\n-               Print_Str (Prefix_Str_Char);\n+               Print_Str (Prefix);\n                Print_Str (\"Has_Aspects = True\");\n                Print_Eol;\n             end if;\n \n             if Is_Controlling_Actual (N) then\n-               Print_Str (Prefix_Str_Char);\n+               Print_Str (Prefix);\n                Print_Str (\"Is_Controlling_Actual = True\");\n                Print_Eol;\n             end if;\n \n             if Is_Overloaded (N) then\n-               Print_Str (Prefix_Str_Char);\n+               Print_Str (Prefix);\n                Print_Str (\"Is_Overloaded = True\");\n                Print_Eol;\n             end if;\n \n             if Is_Static_Expression (N) then\n-               Print_Str (Prefix_Str_Char);\n+               Print_Str (Prefix);\n                Print_Str (\"Is_Static_Expression = True\");\n                Print_Eol;\n             end if;\n \n             if Must_Not_Freeze (N) then\n-               Print_Str (Prefix_Str_Char);\n+               Print_Str (Prefix);\n                Print_Str (\"Must_Not_Freeze = True\");\n                Print_Eol;\n             end if;\n \n             if Paren_Count (N) /= 0 then\n-               Print_Str (Prefix_Str_Char);\n+               Print_Str (Prefix);\n                Print_Str (\"Paren_Count = \");\n                Print_Int (Int (Paren_Count (N)));\n                Print_Eol;\n             end if;\n \n             if Raises_Constraint_Error (N) then\n-               Print_Str (Prefix_Str_Char);\n+               Print_Str (Prefix);\n                Print_Str (\"Raises_Constraint_Error = True\");\n                Print_Eol;\n             end if;\n@@ -1193,7 +1310,7 @@ package body Treepr is\n          --  Print Do_Overflow_Check field if present\n \n          if Nkind (N) in N_Op and then Do_Overflow_Check (N) then\n-            Print_Str (Prefix_Str_Char);\n+            Print_Str (Prefix);\n             Print_Str (\"Do_Overflow_Check = True\");\n             Print_Eol;\n          end if;\n@@ -1202,132 +1319,77 @@ package body Treepr is\n          --  is handled by the Print_Entity_Info procedure).\n \n          if Nkind (N) in N_Has_Etype and then Present (Etype (N)) then\n-            Print_Str (Prefix_Str_Char);\n+            Print_Str (Prefix);\n             Print_Str (\"Etype = \");\n             Print_Node_Ref (Etype (N));\n             Print_Eol;\n          end if;\n       end if;\n-\n-      --  Loop to print fields included in Pchars array\n-\n-      P := Pchar_Pos (Nkind (N));\n+      --  ????Can some of the above be handled by the\n+      --  loop below, or by calling Print_Field directly?\n \n       if Nkind (N) = N_Integer_Literal and then Print_In_Hex (N) then\n          Fmt := Hex;\n       else\n          Fmt := Auto;\n       end if;\n \n-      while P < Pchar_Pos (Node_Kind'Succ (Nkind (N))) loop\n-         F := Pchars (P);\n-         P := P + 1;\n-\n-         --  Check for case of False flag, which we never print, or an Empty\n-         --  field, which is also never printed.\n-\n-         case F is\n-            when F_Field1 =>\n-               Field_To_Be_Printed := Field1 (N) /= Union_Id (Empty);\n-\n-            when F_Field2 =>\n-               Field_To_Be_Printed := Field2 (N) /= Union_Id (Empty);\n-\n-            when F_Field3 =>\n-               Field_To_Be_Printed := Field3 (N) /= Union_Id (Empty);\n-\n-            when F_Field4 =>\n-               Field_To_Be_Printed := Field4 (N) /= Union_Id (Empty);\n-\n-            when F_Field5 =>\n-               Field_To_Be_Printed := Field5 (N) /= Union_Id (Empty);\n-\n-            when F_Flag1  => Field_To_Be_Printed := Flag1  (N);\n-            when F_Flag2  => Field_To_Be_Printed := Flag2  (N);\n-            when F_Flag3  => Field_To_Be_Printed := Flag3  (N);\n-            when F_Flag4  => Field_To_Be_Printed := Flag4  (N);\n-            when F_Flag5  => Field_To_Be_Printed := Flag5  (N);\n-            when F_Flag6  => Field_To_Be_Printed := Flag6  (N);\n-            when F_Flag7  => Field_To_Be_Printed := Flag7  (N);\n-            when F_Flag8  => Field_To_Be_Printed := Flag8  (N);\n-            when F_Flag9  => Field_To_Be_Printed := Flag9  (N);\n-            when F_Flag10 => Field_To_Be_Printed := Flag10 (N);\n-            when F_Flag11 => Field_To_Be_Printed := Flag11 (N);\n-            when F_Flag12 => Field_To_Be_Printed := Flag12 (N);\n-            when F_Flag13 => Field_To_Be_Printed := Flag13 (N);\n-            when F_Flag14 => Field_To_Be_Printed := Flag14 (N);\n-            when F_Flag15 => Field_To_Be_Printed := Flag15 (N);\n-            when F_Flag16 => Field_To_Be_Printed := Flag16 (N);\n-            when F_Flag17 => Field_To_Be_Printed := Flag17 (N);\n-            when F_Flag18 => Field_To_Be_Printed := Flag18 (N);\n-         end case;\n-\n-         --  Print field if it is to be printed\n-\n-         if Field_To_Be_Printed then\n-            Print_Str (Prefix_Str_Char);\n-\n-            while P < Pchar_Pos (Node_Kind'Succ (Nkind (N)))\n-              and then Pchars (P) not in Fchar\n-            loop\n-               Print_Char (Pchars (P));\n-               P := P + 1;\n-            end loop;\n-\n-            Print_Str (\" = \");\n-\n-            case F is\n-               when F_Field1 => Print_Field (Field1 (N), Fmt);\n-               when F_Field2 => Print_Field (Field2 (N), Fmt);\n-               when F_Field3 => Print_Field (Field3 (N), Fmt);\n-               when F_Field4 => Print_Field (Field4 (N), Fmt);\n-\n-               --  Special case End_Span = Uint5\n-\n-               when F_Field5 =>\n-                  if Nkind (N) in N_Case_Statement | N_If_Statement then\n-                     Print_End_Span (N);\n-                  else\n-                     Print_Field (Field5 (N), Fmt);\n+      declare\n+         A : Node_Field_Array renames Node_Field_Table (Nkind (N)).all;\n+         Already_Printed_Above : constant Node_Field_Set :=\n+           (Nkind\n+            | Chars\n+            | Comes_From_Source\n+            | Analyzed\n+            | Error_Posted\n+            | Is_Ignored_Ghost_Node\n+            | Check_Actuals\n+            | Link -- Parent was printed\n+            | Sloc\n+            | Left_Opnd\n+            | Right_Opnd\n+            | Entity\n+            | Assignment_OK\n+            | Do_Range_Check\n+            | Has_Dynamic_Length_Check\n+            | Has_Aspects\n+            | Is_Controlling_Actual\n+            | Is_Overloaded\n+            | Is_Static_Expression\n+            | Must_Not_Freeze\n+            | Small_Paren_Count -- Paren_Count was printed\n+            | Raises_Constraint_Error\n+            | Do_Overflow_Check\n+            | Etype\n+            | In_List -- ????wasn't printed by old version\n+              => True,\n+\n+            others => False);\n+      begin\n+         --  Outer loop makes flags come out last\n+\n+         for Print_Flags in Boolean loop\n+            for Field_Index in A'Range loop --  Use Walk_Sinfo_Fields????\n+               declare\n+                  FD : Field_Descriptor renames\n+                    Node_Field_Descriptors (A (Field_Index));\n+               begin\n+                  if Already_Printed_Above (A (Field_Index))  then\n+                     null; -- Skip the ones already printed\n+\n+                  elsif (FD.Kind = Flag_Field) = Print_Flags then\n+                     Print_Node_Field\n+                       (Prefix, A (Field_Index), N, FD, Fmt);\n                   end if;\n-\n-               when F_Flag1  => Print_Flag (Flag1 (N));\n-               when F_Flag2  => Print_Flag (Flag2 (N));\n-               when F_Flag3  => Print_Flag (Flag3 (N));\n-               when F_Flag4  => Print_Flag (Flag4 (N));\n-               when F_Flag5  => Print_Flag (Flag5 (N));\n-               when F_Flag6  => Print_Flag (Flag6 (N));\n-               when F_Flag7  => Print_Flag (Flag7 (N));\n-               when F_Flag8  => Print_Flag (Flag8 (N));\n-               when F_Flag9  => Print_Flag (Flag9 (N));\n-               when F_Flag10 => Print_Flag (Flag10 (N));\n-               when F_Flag11 => Print_Flag (Flag11 (N));\n-               when F_Flag12 => Print_Flag (Flag12 (N));\n-               when F_Flag13 => Print_Flag (Flag13 (N));\n-               when F_Flag14 => Print_Flag (Flag14 (N));\n-               when F_Flag15 => Print_Flag (Flag15 (N));\n-               when F_Flag16 => Print_Flag (Flag16 (N));\n-               when F_Flag17 => Print_Flag (Flag17 (N));\n-               when F_Flag18 => Print_Flag (Flag18 (N));\n-            end case;\n-\n-            Print_Eol;\n-\n-         --  Field is not to be printed (False flag field)\n-\n-         else\n-            while P < Pchar_Pos (Node_Kind'Succ (Nkind (N)))\n-              and then Pchars (P) not in Fchar\n-            loop\n-               P := P + 1;\n+               end;\n             end loop;\n-         end if;\n-      end loop;\n+         end loop;\n+      end;\n \n       --  Print aspects if present\n \n       if Has_Aspects (N) then\n-         Print_Str (Prefix_Str_Char);\n+         Print_Str (Prefix);\n          Print_Str (\"Aspect_Specifications = \");\n          Print_Field (Union_Id (Aspect_Specifications (N)));\n          Print_Eol;\n@@ -1336,13 +1398,13 @@ package body Treepr is\n       --  Print entity information for entities\n \n       if Nkind (N) in N_Entity then\n-         Print_Entity_Info (N, Prefix_Str_Char);\n+         Print_Entity_Info (N, Prefix);\n       end if;\n \n       --  Print the SCIL node (if available)\n \n       if Present (Get_SCIL_Node (N)) then\n-         Print_Str (Prefix_Str_Char);\n+         Print_Str (Prefix);\n          Print_Str (\"SCIL_Node = \");\n          Print_Node_Ref (Get_SCIL_Node (N));\n          Print_Eol;\n@@ -1393,7 +1455,7 @@ package body Treepr is\n    begin\n       Print_Node_Ref (N);\n \n-      if N > Atree_Private_Part.Nodes.Last then\n+      if not Is_Valid_Node (Union_Id (N)) then\n          Print_Str (\" (no such node)\");\n          Print_Eol;\n          return;\n@@ -1442,6 +1504,8 @@ package body Treepr is\n \n          --  Note: the call to Fold_Upper in this loop is to get past the GNAT\n          --  bug of 'Image returning lower case instead of upper case.\n+         --  ????I'm sure that bug has long been fixed. This code was written\n+         --  in 2001. It should call Print_Str_Mixed_Case?\n \n          for J in S'Range loop\n             if Ucase then\n@@ -2060,13 +2124,8 @@ package body Treepr is\n                Visit_Elist (Elist_Id (D), New_Prefix);\n             end if;\n \n-         --  For all other kinds of descendants (strings, names, uints etc),\n-         --  there is nothing to visit (the contents of the field will be\n-         --  printed when we print the containing node, but what concerns\n-         --  us now is looking for descendants in the tree.\n-\n          else\n-            null;\n+            raise Program_Error;\n          end if;\n       end Visit_Descendant;\n \n@@ -2129,42 +2188,49 @@ package body Treepr is\n \n       --  Visit all descendants of this node\n \n-      if Nkind (N) not in N_Entity then\n-         Visit_Descendant (Field1 (N));\n-         Visit_Descendant (Field2 (N));\n-         Visit_Descendant (Field3 (N));\n-         Visit_Descendant (Field4 (N));\n-         Visit_Descendant (Field5 (N));\n-\n-         if Has_Aspects (N) then\n-            Visit_Descendant (Union_Id (Aspect_Specifications (N)));\n-         end if;\n+      declare\n+         A : Node_Field_Array renames Node_Field_Table (Nkind (N)).all;\n+      begin\n+         for Field_Index in A'Range loop\n+            declare\n+               F : constant Node_Field := A (Field_Index);\n+               FD : Field_Descriptor renames Node_Field_Descriptors (F);\n+            begin\n+               if FD.Kind in Node_Id_Field | List_Id_Field | Elist_Id_Field\n+                  --  For all other kinds of descendants (strings, names, uints\n+                  --  etc), there is nothing to visit (the contents of the\n+                  --  field will be printed when we print the containing node,\n+                  --  but what concerns us now is looking for descendants in\n+                  --  the tree.\n+\n+                 and then F /= Next_Entity -- See below for why we skip this\n+               then\n+                  Visit_Descendant (Get_Union_Id (N, FD.Offset));\n+               end if;\n+            end;\n+         end loop;\n+      end;\n \n-      --  Entity case\n+      if Has_Aspects (N) then\n+         Visit_Descendant (Union_Id (Aspect_Specifications (N)));\n+      end if;\n \n-      else\n-         Visit_Descendant (Field1 (N));\n-         Visit_Descendant (Field3 (N));\n-         Visit_Descendant (Field4 (N));\n-         Visit_Descendant (Field5 (N));\n-         Visit_Descendant (Field6 (N));\n-         Visit_Descendant (Field7 (N));\n-         Visit_Descendant (Field8 (N));\n-         Visit_Descendant (Field9 (N));\n-         Visit_Descendant (Field10 (N));\n-         Visit_Descendant (Field11 (N));\n-         Visit_Descendant (Field12 (N));\n-         Visit_Descendant (Field13 (N));\n-         Visit_Descendant (Field14 (N));\n-         Visit_Descendant (Field15 (N));\n-         Visit_Descendant (Field16 (N));\n-         Visit_Descendant (Field17 (N));\n-         Visit_Descendant (Field18 (N));\n-         Visit_Descendant (Field19 (N));\n-         Visit_Descendant (Field20 (N));\n-         Visit_Descendant (Field21 (N));\n-         Visit_Descendant (Field22 (N));\n-         Visit_Descendant (Field23 (N));\n+      if Nkind (N) in N_Entity then\n+         declare\n+            A : Entity_Field_Array renames Entity_Field_Table (Ekind (N)).all;\n+         begin\n+            for Field_Index in A'Range loop\n+               declare\n+                  F : constant Entity_Field := A (Field_Index);\n+                  FD : Field_Descriptor renames Entity_Field_Descriptors (F);\n+               begin\n+                  if FD.Kind in Node_Id_Field | List_Id_Field | Elist_Id_Field\n+                  then\n+                     Visit_Descendant (Get_Union_Id (N, FD.Offset));\n+                  end if;\n+               end;\n+            end loop;\n+         end;\n \n          --  Now an interesting special case. Normally parents are always\n          --  printed since we traverse the tree in a downwards direction.\n@@ -2176,12 +2242,11 @@ package body Treepr is\n             Visit_Descendant (Union_Id (Parent (N)));\n          end if;\n \n-         --  You may be wondering why we omitted Field2 above. The answer\n-         --  is that this is the Next_Entity field, and we want to treat\n-         --  it rather specially. Why? Because a Next_Entity link does not\n-         --  correspond to a level deeper in the tree, and we do not want\n-         --  the tree to march off to the right of the page due to bogus\n-         --  indentations coming from this effect.\n+         --  You may be wondering why we omitted Next_Entity above. The answer\n+         --  is that we want to treat it rather specially. Why? Because a\n+         --  Next_Entity link does not correspond to a level deeper in the\n+         --  tree, and we do not want the tree to march off to the right of the\n+         --  page due to bogus indentations coming from this effect.\n \n          --  To prevent this, what we do is to control references via\n          --  Next_Entity only from the first entity on a given scope chain,"}, {"sha": "8c496cbca8b533ac7427d840dc6c4feadedc0f8b", "filename": "gcc/ada/treepr.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ftreepr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ftreepr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -80,7 +80,8 @@ package Treepr is\n    pragma Export (Ada, pe);\n    --  Print a node, node list, uint, or anything else that falls under\n    --  the definition of Union_Id. Historically this was only for printing\n-   --  nodes, hence the name.\n+   --  nodes, hence the name pn. These are all the same, but the renamings\n+   --  need to be in the body, or else the debugger can't find them.\n \n    procedure ppar (N : Union_Id);\n    pragma Export (Ada, ppar);"}, {"sha": "b65d6c26b58d728cd2acaa075b062ccf9a6fcdf6", "filename": "gcc/ada/treeprs.adt", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Ftreeprs.adt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Ftreeprs.adt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreeprs.adt?ref=476ed6bf66ab20e22ae4b3da0fd7fd94753f2334", "patch": "@@ -1,107 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              T R E E P R S                               --\n---                                                                          --\n---                             T e m p l a t e                              --\n---                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n---  This file is a template used as input to the utility program XTreeprs,\n---  which reads this template, and the spec of Sinfo (sinfo.ads) and generates\n---  the spec for the Treeprs package (file treeprs.ads)\n-\n---  This package contains the declaration of the string used by the Tree_Print\n---  package. It must be updated whenever the arrangements of the field names\n---  in package Sinfo is changed. The utility program XTREEPRS is used to\n---  do this update correctly using the template treeprs.adt as input.\n-\n-with Sinfo; use Sinfo;\n-\n-package Treeprs is\n-\n-   --------------------------------\n-   -- String Data for Node Print --\n-   --------------------------------\n-\n-   --  String data for print out. The Pchars array is a long string with the\n-   --  the entry for each node type consisting of a single blank, followed by\n-   --  a series of entries, one for each Op or Flag field used for the node.\n-   --  Each entry has a single character which identifies the field, followed\n-   --  by the synonym name. The starting location for a given node type is\n-   --  found from the corresponding entry in the Pchars_Pos_Array.\n-\n-   --  The following characters identify the field. These are characters which\n-   --  could never occur in a field name, so they also mark the end of the\n-   --  previous name.\n-\n-   --  Note the following definitions do not include Flag0. This will have to\n-   --  be addressed if we ever need to use Flag0 (it's not currently used).\n-\n-   subtype Fchar is Character range '#' .. '9';\n-\n-   F_Field1     : constant Fchar := '#'; -- Character'Val (16#23#)\n-   F_Field2     : constant Fchar := '$'; -- Character'Val (16#24#)\n-   F_Field3     : constant Fchar := '%'; -- Character'Val (16#25#)\n-   F_Field4     : constant Fchar := '&'; -- Character'Val (16#26#)\n-   F_Field5     : constant Fchar := '''; -- Character'Val (16#27#)\n-   F_Flag1      : constant Fchar := '('; -- Character'Val (16#28#)\n-   F_Flag2      : constant Fchar := ')'; -- Character'Val (16#29#)\n-   F_Flag3      : constant Fchar := '*'; -- Character'Val (16#2A#)\n-   F_Flag4      : constant Fchar := '+'; -- Character'Val (16#2B#)\n-   F_Flag5      : constant Fchar := ','; -- Character'Val (16#2C#)\n-   F_Flag6      : constant Fchar := '-'; -- Character'Val (16#2D#)\n-   F_Flag7      : constant Fchar := '.'; -- Character'Val (16#2E#)\n-   F_Flag8      : constant Fchar := '/'; -- Character'Val (16#2F#)\n-   F_Flag9      : constant Fchar := '0'; -- Character'Val (16#30#)\n-   F_Flag10     : constant Fchar := '1'; -- Character'Val (16#31#)\n-   F_Flag11     : constant Fchar := '2'; -- Character'Val (16#32#)\n-   F_Flag12     : constant Fchar := '3'; -- Character'Val (16#33#)\n-   F_Flag13     : constant Fchar := '4'; -- Character'Val (16#34#)\n-   F_Flag14     : constant Fchar := '5'; -- Character'Val (16#35#)\n-   F_Flag15     : constant Fchar := '6'; -- Character'Val (16#36#)\n-   F_Flag16     : constant Fchar := '7'; -- Character'Val (16#37#)\n-   F_Flag17     : constant Fchar := '8'; -- Character'Val (16#38#)\n-   F_Flag18     : constant Fchar := '9'; -- Character'Val (16#39#)\n-\n-   --  Note this table does not include entity field and flags whose access\n-   --  functions are in Einfo (these are handled by the Print_Entity_Info\n-   --  procedure in Treepr, which uses the routines in Einfo to get the proper\n-   --  symbolic information). In addition, the following fields are handled by\n-   --  Treepr, and do not appear in the Pchars array:\n-\n-   --    Analyzed\n-   --    Cannot_Be_Constant\n-   --    Chars\n-   --    Comes_From_Source\n-   --    Error_Posted\n-   --    Etype\n-   --    Is_Controlling_Actual\n-   --    Is_Overloaded\n-   --    Is_Static_Expression\n-   --    Left_Opnd\n-   --    Must_Check_Expr\n-   --    Must_Not_Freeze\n-   --    No_Overflow_Expr\n-   --    Paren_Count\n-   --    Raises_Constraint_Error\n-   --    Right_Opnd\n-\n-!!TEMPLATE INSERTION POINT\n-\n-end Treeprs;"}, {"sha": "f6c420acb832d7f70ed79a0a7d8915962374a487", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -312,8 +312,7 @@ package Types is\n    --  The tree Id values start at zero, because we use zero for Empty (to\n    --  allow a zero test for Empty).\n \n-   Node_High_Bound : constant :=\n-     (if Standard'Address_Size = 32 then 299_999_999 else 1_999_999_999);\n+   Node_High_Bound : constant := 1_999_999_999;\n \n    Elist_Low_Bound : constant := -199_999_999;\n    --  The Elist_Id values are subscripts into an array of elist headers which\n@@ -387,7 +386,7 @@ package Types is\n    --  the special values Empty and Error are subscripts into this table.\n    --  See package Atree for further details.\n \n-   type Node_Id is range Node_Low_Bound .. Node_High_Bound;\n+   type Node_Id is range Node_Low_Bound .. Node_High_Bound with Size => 32;\n    --  Type used to identify nodes in the tree\n \n    subtype Entity_Id is Node_Id;\n@@ -436,7 +435,7 @@ package Types is\n    --  attempt to apply list operations to No_List will cause a (detected)\n    --  error.\n \n-   type List_Id is range List_Low_Bound .. List_High_Bound;\n+   type List_Id is range List_Low_Bound .. List_High_Bound with Size => 32;\n    --  Type used to identify a node list\n \n    No_List : constant List_Id := List_High_Bound;\n@@ -461,7 +460,7 @@ package Types is\n    --  of the tree, allowing nodes to be members of more than one such list\n    --  (see package Elists for further details).\n \n-   type Elist_Id is range Elist_Low_Bound .. Elist_High_Bound;\n+   type Elist_Id is range Elist_Low_Bound .. Elist_High_Bound with Size => 32;\n    --  Type used to identify an element list (Elist header table subscript)\n \n    No_Elist : constant Elist_Id := Elist_Low_Bound;\n@@ -491,7 +490,8 @@ package Types is\n    --  String_Id values are used to identify entries in the strings table. They\n    --  are subscripts into the Strings table defined in package Stringt.\n \n-   type String_Id is range Strings_Low_Bound .. Strings_High_Bound;\n+   type String_Id is range Strings_Low_Bound .. Strings_High_Bound\n+     with Size => 32;\n    --  Type used to identify entries in the strings table\n \n    No_String : constant String_Id := Strings_Low_Bound;\n@@ -817,6 +817,38 @@ package Types is\n    --  then Default_C_Record_Mechanism is set to 32, and the meaning is to use\n    --  By_Reference if the size is greater than 32, and By_Copy otherwise.\n \n+   ---------------------------------\n+   -- Component_Alignment Control --\n+   ---------------------------------\n+\n+   --  There are four types of alignment possible for array and record\n+   --  types, and a field in the type entities contains a value of the\n+   --  following type indicating which alignment choice applies. For full\n+   --  details of the meaning of these alignment types, see description\n+   --  of the Component_Alignment pragma.\n+\n+   type Component_Alignment_Kind is (\n+      Calign_Default,          -- default alignment\n+      Calign_Component_Size,   -- natural alignment for component size\n+      Calign_Component_Size_4, -- natural for size <= 4, 4 for size >= 4\n+      Calign_Storage_Unit);    -- all components byte aligned\n+\n+   -----------------------------------\n+   -- Floating Point Representation --\n+   -----------------------------------\n+\n+   type Float_Rep_Kind is (\n+      IEEE_Binary,  -- IEEE 754p conforming binary format\n+      AAMP);        -- AAMP format\n+\n+   ----------------------------\n+   -- Small_Paren_Count_Type --\n+   ----------------------------\n+\n+   --  See Paren_Count in Atree for documentation\n+\n+   subtype Small_Paren_Count_Type is Nat range 0 .. 3;\n+\n    ------------------------------\n    -- Run-Time Exception Codes --\n    ------------------------------\n@@ -948,4 +980,21 @@ package Types is\n               SE_Infinite_Recursion             => SE_Reason,\n               SE_Object_Too_Large               => SE_Reason);\n \n+   --  Types for field offsets/sizes used in Seinfo, Sinfo.Nodes and\n+   --  Einfo.Entities:\n+\n+   type Field_Offset is new Nat;\n+   --  Offset of a node field, in units of the size of the field, which is\n+   --  always a power of 2.\n+\n+   subtype Field_Size_In_Bits is Field_Offset with Predicate =>\n+     Field_Size_In_Bits in 1 | 2 | 4 | 8 | 32;\n+\n+   subtype Opt_Field_Offset is Field_Offset'Base range -1 .. Field_Offset'Last;\n+   No_Field_Offset : constant Opt_Field_Offset := Opt_Field_Offset'First;\n+\n+   type Offset_Array_Index is new Nat;\n+   type Offset_Array is\n+     array (Offset_Array_Index range <>) of Opt_Field_Offset;\n+\n end Types;"}, {"sha": "15ebf2b67364ea24cbb57a57c817cdff95af66b1", "filename": "gcc/ada/types.h", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.h?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -360,6 +360,18 @@ typedef Int Mechanism_Type;\n #define By_Short_Descriptor_NCA  (-18)\n #define By_Short_Descriptor_Last (-18)\n \n+typedef char Component_Alignment_Kind;\n+#define Calign_Default           0\n+#define Calign_Component_Size    1\n+#define Calign_Component_Size_4  2\n+#define Calign_Storage_Unit      3\n+\n+typedef char Float_Rep_Kind;\n+#define IEEE_Binary              0\n+#define AAMP                     1\n+\n+typedef Nat Small_Paren_Count_Type;\n+\n /* Definitions of Reason codes for Raise_xxx_Error nodes */\n #define CE_Access_Check_Failed              0\n #define CE_Access_Parameter_Is_Null         1\n@@ -403,3 +415,104 @@ typedef Int Mechanism_Type;\n #define SE_Object_Too_Large                35\n \n #define LAST_REASON_CODE                   37\n+\n+typedef Nat Field_Offset;\n+\n+typedef struct\n+{\n+    unsigned f0 : 1;\n+    unsigned f1 : 1;\n+    unsigned f2 : 1;\n+    unsigned f3 : 1;\n+    unsigned f4 : 1;\n+    unsigned f5 : 1;\n+    unsigned f6 : 1;\n+    unsigned f7 : 1;\n+    unsigned f8 : 1;\n+    unsigned f9 : 1;\n+    unsigned f10 : 1;\n+    unsigned f11 : 1;\n+    unsigned f12 : 1;\n+    unsigned f13 : 1;\n+    unsigned f14 : 1;\n+    unsigned f15 : 1;\n+    unsigned f16 : 1;\n+    unsigned f17 : 1;\n+    unsigned f18 : 1;\n+    unsigned f19 : 1;\n+    unsigned f20 : 1;\n+    unsigned f21 : 1;\n+    unsigned f22 : 1;\n+    unsigned f23 : 1;\n+    unsigned f24 : 1;\n+    unsigned f25 : 1;\n+    unsigned f26 : 1;\n+    unsigned f27 : 1;\n+    unsigned f28 : 1;\n+    unsigned f29 : 1;\n+    unsigned f30 : 1;\n+    unsigned f31 : 1;\n+} slot_1_bit;\n+\n+typedef struct\n+{\n+    unsigned f0 : 2;\n+    unsigned f1 : 2;\n+    unsigned f2 : 2;\n+    unsigned f3 : 2;\n+    unsigned f4 : 2;\n+    unsigned f5 : 2;\n+    unsigned f6 : 2;\n+    unsigned f7 : 2;\n+    unsigned f8 : 2;\n+    unsigned f9 : 2;\n+    unsigned f10 : 2;\n+    unsigned f11 : 2;\n+    unsigned f12 : 2;\n+    unsigned f13 : 2;\n+    unsigned f14 : 2;\n+    unsigned f15 : 2;\n+} slot_2_bit;\n+\n+typedef struct\n+{\n+    unsigned f0 : 4;\n+    unsigned f1 : 4;\n+    unsigned f2 : 4;\n+    unsigned f3 : 4;\n+    unsigned f4 : 4;\n+    unsigned f5 : 4;\n+    unsigned f6 : 4;\n+    unsigned f7 : 4;\n+} slot_4_bit;\n+\n+typedef struct\n+{\n+    unsigned f0 : 8;\n+    unsigned f1 : 8;\n+    unsigned f2 : 8;\n+    unsigned f3 : 8;\n+} slot_8_bit;\n+\n+typedef Union_Id slot_32_bit;\n+\n+typedef union\n+{\n+    slot_1_bit slot_1;\n+    slot_2_bit slot_2;\n+    slot_4_bit slot_4;\n+    slot_8_bit slot_8;\n+    slot_32_bit slot_32;\n+} slot;\n+\n+// Slots are 32 bits (???for now, but we might want to make that 64).\n+// The first bootstrap stage uses -std=gnu++98, so we can't use\n+// static_assert in that case.\n+#if __cplusplus >= 201402L\n+static_assert(sizeof(slot_1_bit) == 4);\n+static_assert(sizeof(slot_2_bit) == 4);\n+static_assert(sizeof(slot_4_bit) == 4);\n+static_assert(sizeof(slot_8_bit) == 4);\n+static_assert(sizeof(slot_32_bit) == 4);\n+static_assert(sizeof(slot) == 4);\n+#endif"}, {"sha": "02f8c59dc606c4f8421046bba518d1a331811af5", "filename": "gcc/ada/uname.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Funame.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gcc%2Fada%2Funame.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Funame.adb?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -25,12 +25,15 @@\n \n with Atree;    use Atree;\n with Casing;   use Casing;\n-with Einfo;    use Einfo;\n+with Einfo; use Einfo;\n+with Einfo.Utils; use Einfo.Utils;\n with Hostparm;\n with Lib;      use Lib;\n with Nlists;   use Nlists;\n with Output;   use Output;\n-with Sinfo;    use Sinfo;\n+with Sinfo; use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Sinfo.Utils; use Sinfo.Utils;\n with Sinput;   use Sinput;\n \n package body Uname is"}, {"sha": "81bd9b86c381af7aeb8e181d37fed1a128883fb9", "filename": "gcc/ada/xeinfo.adb", "status": "removed", "additions": 0, "deletions": 551, "changes": 551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fxeinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fxeinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxeinfo.adb?ref=476ed6bf66ab20e22ae4b3da0fd7fd94753f2334", "patch": "@@ -1,551 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                          GNAT SYSTEM UTILITIES                           --\n---                                                                          --\n---                               X E I N F O                                --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2021, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Program to construct C header file einfo.h (C version of einfo.ads spec)\n---  for use by Gigi. This header file contains all definitions and access\n---  functions, but does not contain set procedures, since Gigi is not allowed\n---  to modify the GNAT tree.\n-\n---    Input files:\n-\n---       einfo.ads     spec of Einfo package\n---       einfo.adb     body of Einfo package\n-\n---    Output files:\n-\n---       einfo.h       corresponding C header file\n-\n---  Note: It is assumed that the input files have been compiled without errors\n-\n---  An optional argument allows the specification of an output file name to\n---  override the default einfo.h file name for the generated output file.\n-\n---  Most, but not all of the functions in Einfo can be inlined in the C header.\n---  They are the functions identified by pragma Inline in the spec. Functions\n---  that cannot be inlined are simply defined in the header.\n-\n-with Ada.Command_Line;              use Ada.Command_Line;\n-with Ada.Strings.Unbounded;         use Ada.Strings.Unbounded;\n-with Ada.Strings.Unbounded.Text_IO; use Ada.Strings.Unbounded.Text_IO;\n-with Ada.Strings.Maps;              use Ada.Strings.Maps;\n-with Ada.Strings.Maps.Constants;    use Ada.Strings.Maps.Constants;\n-with Ada.Text_IO;                   use Ada.Text_IO;\n-\n-with GNAT.Spitbol;                  use GNAT.Spitbol;\n-with GNAT.Spitbol.Patterns;         use GNAT.Spitbol.Patterns;\n-with GNAT.Spitbol.Table_Boolean;    use GNAT.Spitbol.Table_Boolean;\n-\n-with CEinfo;\n-\n-procedure XEinfo is\n-\n-   package TB renames GNAT.Spitbol.Table_Boolean;\n-\n-   Err : exception;\n-\n-   A         : VString := Nul;\n-   B         : VString := Nul;\n-   C         : VString := Nul;\n-   Expr      : VString := Nul;\n-   Filler    : VString := Nul;\n-   Fline     : VString := Nul;\n-   Formal    : VString := Nul;\n-   Formaltyp : VString := Nul;\n-   FN        : VString := Nul;\n-   Line      : VString := Nul;\n-   N         : VString := Nul;\n-   N1        : VString := Nul;\n-   N2        : VString := Nul;\n-   N3        : VString := Nul;\n-   Nam       : VString := Nul;\n-   Name      : VString := Nul;\n-   NewS      : VString := Nul;\n-   Nextlin   : VString := Nul;\n-   OldS      : VString := Nul;\n-   Rtn       : VString := Nul;\n-   Term      : VString := Nul;\n-\n-   InB : File_Type;\n-   --  Used to read initial header from body\n-\n-   InF   : File_Type;\n-   --  Used to read full text of both spec and body\n-\n-   Ofile : File_Type;\n-   --  Used to write output file\n-\n-   wsp      : constant Pattern := NSpan (' ' & ASCII.HT);\n-   Comment  : constant Pattern := wsp & \"--\";\n-   For_Rep  : constant Pattern := wsp & \"for\";\n-   Get_Func : constant Pattern := wsp * A & \"function\" & wsp\n-                                  & Break (' ') * Name;\n-   Inline   : constant Pattern := wsp & \"pragma Inline (\" & Break (')') * Name;\n-   Get_Pack : constant Pattern := wsp & \"package \";\n-   Get_Enam : constant Pattern := wsp & Break (',') * N & ',';\n-   Find_Fun : constant Pattern := wsp & \"function\";\n-   F_Subtyp : constant Pattern := wsp * A & \"subtype \" & Break (' ') * N;\n-   G_Subtyp : constant Pattern := wsp & \"subtype\" & wsp & Break (' ') * NewS\n-                                  & wsp & \"is\" & wsp & Break (\" ;\") * OldS\n-                                  & wsp & ';' & wsp & Rtab (0);\n-   F_Typ    : constant Pattern := wsp * A & \"type \" & Break (' ') * N &\n-                                  \" is (\";\n-   Get_Nam  : constant Pattern := wsp * A & Break (\",)\") * Nam\n-                                  & Len (1) * Term;\n-   Get_Styp : constant Pattern := wsp * A & \"subtype \" & Break (' ') * N;\n-   Get_N1   : constant Pattern := wsp & Break (' ') * N1;\n-   Get_N2   : constant Pattern := wsp & \"-- \" & Rest * N2;\n-   Get_N3   : constant Pattern := wsp & Break (';') * N3;\n-   Get_FN   : constant Pattern := wsp * C & \"function\" & wsp\n-                                  & Break (\" (\") * FN;\n-   Is_Rturn : constant Pattern := BreakX ('r') & \"return\";\n-   Is_Begin : constant Pattern := wsp & \"begin\";\n-   Get_Asrt : constant Pattern := wsp & \"pragma Assert\";\n-   Semicoln : constant Pattern := BreakX (';');\n-   Get_Cmnt : constant Pattern := BreakX ('-') * A & \"--\";\n-   Get_Expr : constant Pattern := wsp & \"return \" & Break (';') * Expr;\n-   Chek_End : constant Pattern := wsp & \"end\" & BreakX (';') & ';';\n-   Get_B0   : constant Pattern := BreakX (' ') * A & \" or else \" & Rest * B;\n-   Get_B1   : constant Pattern := BreakX (' ') * A & \" in \" & Rest * B;\n-   Get_B2   : constant Pattern := BreakX (' ') * A & \" = \" & Rest * B;\n-   Get_B3   : constant Pattern := BreakX (' ') * A & \" /= \" & Rest * B;\n-   To_Paren : constant Pattern := wsp * Filler & '(';\n-   Get_Fml  : constant Pattern := Break (\" :\") * Formal & wsp & ':' & wsp\n-                                  & BreakX (\" );\") * Formaltyp;\n-   Nxt_Fml  : constant Pattern := wsp & \"; \";\n-   Get_Rtn  : constant Pattern := wsp & \"return\" & wsp & BreakX (\" ;\") * Rtn;\n-   Rem_Prn  : constant Pattern := wsp & ')';\n-\n-   M : Match_Result;\n-\n-   Lineno : Natural := 0;\n-   --  Line number in spec\n-\n-   V   : Natural;\n-   Ctr : Natural;\n-\n-   Inlined : TB.Table (200);\n-   --  Inlined<N> = True for inlined function, False otherwise\n-\n-   Lastinlined : Boolean;\n-\n-   procedure Badfunc;\n-   pragma No_Return (Badfunc);\n-   --  Signal bad function in body\n-\n-   function Getlin return VString;\n-   --  Get non-comment line (comment lines skipped, also skips FOR rep clauses)\n-   --  Fatal error (raises End_Error exception) if end of file encountered\n-\n-   procedure Must (B : Boolean);\n-   --  Raises Err if the argument (a Match) call, returns False\n-\n-   procedure Sethead (Line : in out VString; Term : String);\n-   --  Process function header into C\n-\n-   procedure Translate_Expr (Expr : in out VString);\n-   --  Translate expression from Ada to C\n-\n-   -------------\n-   -- Badfunc --\n-   -------------\n-\n-   procedure Badfunc is\n-   begin\n-      Put_Line\n-        (Standard_Error,\n-         \"Body for function \" & FN & \" does not meet requirements\");\n-      raise Err;\n-   end Badfunc;\n-\n-   -------------\n-   -- Getlin --\n-   -------------\n-\n-   function Getlin return VString is\n-      Lin : VString;\n-\n-   begin\n-      loop\n-         Lin := Get_Line (InF);\n-         Lineno := Lineno + 1;\n-\n-         if Lin /= \"\"\n-           and then not Match (Lin, Comment)\n-           and then not Match (Lin, For_Rep)\n-         then\n-            return Lin;\n-         end if;\n-      end loop;\n-   end Getlin;\n-\n-   ----------\n-   -- Must --\n-   ----------\n-\n-   procedure Must (B : Boolean) is\n-   begin\n-      if not B then\n-         raise Err;\n-      end if;\n-   end Must;\n-\n-   -------------\n-   -- Sethead --\n-   -------------\n-\n-   procedure Sethead (Line : in out VString; Term : String) is\n-      Args : VString;\n-\n-   begin\n-      Must (Match (Line, Get_Func, \"\"));\n-      Args := Nul;\n-\n-      if Match (Line, To_Paren, \"\") then\n-         Args := Filler & '(';\n-\n-         loop\n-            Must (Match (Line, Get_Fml, \"\"));\n-            Append (Args, Formaltyp & ' ' & Formal);\n-            exit when not Match (Line, Nxt_Fml);\n-            Append (Args, \",\");\n-         end loop;\n-\n-         Match (Line, Rem_Prn, \"\");\n-         Append (Args, ')');\n-      end if;\n-\n-      Must (Match (Line, Get_Rtn));\n-\n-      if Present (Inlined, Name) then\n-         Put_Line (Ofile, A & \"INLINE \" & Rtn & ' ' & Name & Args & Term);\n-      else\n-         Put_Line (Ofile, A &  Rtn & ' ' & Name & Args & Term);\n-      end if;\n-   end Sethead;\n-\n-   --------------------\n-   -- Translate_Expr --\n-   --------------------\n-\n-   procedure Translate_Expr (Expr : in out VString) is\n-      M : Match_Result;\n-\n-   begin\n-      Match (Expr, Get_B1, M);\n-      Replace (M, \"IN (\" & A & \", \" & B & ')');\n-      Match (Expr, Get_B2, M);\n-      Replace (M, A & \" == \" & B);\n-      Match (Expr, Get_B3, M);\n-      Replace (M, A & \" != \" & B);\n-   end Translate_Expr;\n-\n---  Start of processing for XEinfo\n-\n-begin\n-   --  First run CEinfo to check for errors. Note that CEinfo is also a\n-   --  stand-alone program that can be run separately.\n-\n-   CEinfo;\n-\n-   Anchored_Mode := True;\n-\n-   if Argument_Count > 0 then\n-      Create (Ofile, Out_File, Argument (1));\n-   else\n-      Create (Ofile, Out_File, \"einfo.h\");\n-   end if;\n-\n-   Open (InB, In_File, \"einfo.adb\");\n-   Open (InF, In_File, \"einfo.ads\");\n-\n-   Lineno := 0;\n-   loop\n-      Line := Get_Line (InF);\n-      Lineno := Lineno + 1;\n-      exit when Line = \"\";\n-\n-      Match (Line,\n-             \"--                                 S p e c       \",\n-             \"--                              C Header File    \");\n-      Match (Line, \"--\", \"/*\");\n-      Match (Line, Rtab (2) * A & \"--\", M);\n-      Replace (M, A & \"*/\");\n-      Put_Line (Ofile, Line);\n-   end loop;\n-\n-   Put_Line (Ofile, \"\");\n-\n-   Put_Line (Ofile, \"#ifdef __cplusplus\");\n-   Put_Line (Ofile, \"extern \"\"C\"\" {\");\n-   Put_Line (Ofile, \"#endif\");\n-\n-   --  Find and record pragma Inlines\n-\n-   loop\n-      Line := Get_Line (InF);\n-      exit when Match (Line, \"   --  END XEINFO INLINES\");\n-\n-      if Match (Line, Inline) then\n-         Set (Inlined, Name, True);\n-      end if;\n-   end loop;\n-\n-   --  Skip to package line\n-\n-   Reset (InF, In_File);\n-   Lineno := 0;\n-\n-   loop\n-      Line := Getlin;\n-      exit when Match (Line, Get_Pack);\n-   end loop;\n-\n-   V := 0;\n-   Line := Getlin;\n-   Must (Match (Line, wsp & \"type Entity_Kind\"));\n-\n-   --  Process entity kind code definitions\n-\n-   loop\n-      Line := Getlin;\n-      exit when not Match (Line, Get_Enam);\n-      Put_Line (Ofile, \"   #define \" & Rpad (N, 32) & \" \" & V);\n-      V := V + 1;\n-   end loop;\n-\n-   Must (Match (Line, wsp & Rest * N));\n-   Put_Line (Ofile, \"   #define \" & Rpad (N, 32) & ' ' & V);\n-   Line := Getlin;\n-\n-   Must (Match (Line, wsp & \");\"));\n-   Put_Line (Ofile, \"\");\n-\n-   --  Loop through subtype and type declarations\n-\n-   loop\n-      Line := Getlin;\n-      exit when Match (Line, Find_Fun);\n-\n-      --  Case of a subtype declaration\n-\n-      if Match (Line, F_Subtyp) then\n-\n-         --  Case of a subtype declaration that is an abbreviation of the\n-         --  form subtype x is y, and if so generate the appropriate typedef\n-\n-         if Match (Line, G_Subtyp) then\n-            Put_Line (Ofile, A & \"typedef \" & OldS & ' ' & NewS & ';');\n-\n-         --  Otherwise the subtype must be declaring a subrange of Entity_Id\n-\n-         else\n-            Must (Match (Line, Get_Styp));\n-            Line := Getlin;\n-            Must (Match (Line, Get_N1));\n-\n-            loop\n-               Line := Get_Line (InF);\n-               Lineno := Lineno + 1;\n-               exit when not Match (Line, Get_N2);\n-            end loop;\n-\n-            Must (Match (Line, Get_N3));\n-            Put_Line (Ofile, A & \"SUBTYPE (\" & N & \", Entity_Kind, \");\n-            Put_Line (Ofile, A & \"   \" & N1 & \", \" & N3 & ')');\n-            Put_Line (Ofile, \"\");\n-         end if;\n-\n-      --  Case of type declaration\n-\n-      elsif Match (Line, F_Typ) then\n-\n-         --  Process type declaration (must be enumeration type)\n-\n-         Ctr := 0;\n-         Put_Line (Ofile, A & \"typedef char \" & N & ';');\n-\n-         loop\n-            Line := Getlin;\n-            Must (Match (Line, Get_Nam));\n-            Put_Line (Ofile, A & \"#define \" & Rpad (Nam, 25) & Ctr);\n-            Ctr := Ctr + 1;\n-            exit when Term /= \",\";\n-         end loop;\n-\n-         Put_Line (Ofile, \"\");\n-\n-      --  Neither subtype nor type declaration\n-\n-      else\n-         raise Err;\n-      end if;\n-   end loop;\n-\n-   --  Process function declarations\n-\n-   --  Note: Lastinlined used to control blank lines\n-\n-   Put_Line (Ofile, \"\");\n-   Lastinlined := True;\n-\n-   --  Loop through function declarations\n-\n-   while Match (Line, Get_FN) loop\n-\n-      --  Non-inlined function\n-\n-      if not Present (Inlined, FN) then\n-         Put_Line (Ofile, \"\");\n-         Put_Line\n-           (Ofile,\n-            \"   #define \" & FN & \" einfo__\" & Translate (FN, Lower_Case_Map));\n-\n-      --  Inlined function\n-\n-      else\n-         if not Lastinlined then\n-            Put_Line (Ofile, \"\");\n-         end if;\n-      end if;\n-\n-      --  Merge here to output spec\n-\n-      Sethead (Line, \";\");\n-      Lastinlined := Get (Inlined, FN);\n-      Line := Getlin;\n-   end loop;\n-\n-   Put_Line (Ofile, \"\");\n-\n-   --  Read body to find inlined functions\n-\n-   Close (InB);\n-   Close (InF);\n-   Open (InF, In_File, \"einfo.adb\");\n-   Lineno := 0;\n-\n-   --  Loop through input lines to find bodies of inlined functions\n-\n-   while not End_Of_File (InF) loop\n-      Fline := Get_Line (InF);\n-\n-      if Match (Fline, Get_FN)\n-        and then Get (Inlined, FN)\n-      then\n-         --  Here we have an inlined function\n-\n-         if not Match (Fline, Is_Rturn) then\n-            Line := Fline;\n-            Badfunc;\n-         end if;\n-\n-         Line := Getlin;\n-\n-         if not Match (Line, Is_Begin) then\n-            Badfunc;\n-         end if;\n-\n-         --  Skip past pragma Asserts\n-\n-         loop\n-            Line := Getlin;\n-            exit when not Match (Line, Get_Asrt);\n-\n-            --  Pragma assert found, get its continuation lines\n-\n-            loop\n-               exit when Match (Line, Semicoln);\n-               Line := Getlin;\n-            end loop;\n-         end loop;\n-\n-         --  Process return statement\n-\n-         Match (Line, Get_Cmnt, M);\n-         Replace (M, A);\n-\n-         --  Get continuations of return statement\n-\n-         while not Match (Line, Semicoln) loop\n-            Nextlin := Getlin;\n-            Match (Nextlin, wsp, \" \");\n-            Append (Line, Nextlin);\n-         end loop;\n-\n-         if not Match (Line, Get_Expr) then\n-            Badfunc;\n-         end if;\n-\n-         Line := Getlin;\n-\n-         if not Match (Line, Chek_End) then\n-            Badfunc;\n-         end if;\n-\n-         --  Process expression\n-\n-         if Match (Expr, Get_B0, M) then\n-            declare\n-               Saved_A : VString := A;\n-               Saved_B : VString := B;\n-            begin\n-               Translate_Expr (Saved_A);\n-               Translate_Expr (Saved_B);\n-               Replace (M, Saved_A & \" || \" & Saved_B);\n-            end;\n-         else\n-            Translate_Expr (Expr);\n-         end if;\n-\n-         Put_Line (Ofile, \"\");\n-         Sethead (Fline, \"\");\n-         Put_Line (Ofile, C & \"   { return \" & Expr & \"; }\");\n-      end if;\n-   end loop;\n-\n-   Put_Line (Ofile, \"\");\n-\n-   Put_Line (Ofile, \"#ifdef __cplusplus\");\n-   Put_Line (Ofile, \"}\");\n-   Put_Line (Ofile, \"#endif\");\n-\n-   Put_Line\n-     (Ofile,\n-      \"/* End of einfo.h (C version of Einfo package specification) */\");\n-\n-   Close (InF);\n-   Close (Ofile);\n-\n-exception\n-   when Err =>\n-      Put_Line (Standard_Error, Lineno & \".  \" & Line);\n-      Put_Line (Standard_Error, \"**** fatal error ****\");\n-      Set_Exit_Status (1);\n-\n-   when End_Error =>\n-      Put_Line (Standard_Error, \"unexpected end of file\");\n-      Put_Line (Standard_Error, \"**** fatal error ****\");\n-\n-end XEinfo;"}, {"sha": "952e3f77345caf5ab2b976c53b6f581777a1856f", "filename": "gcc/ada/xnmake.adb", "status": "removed", "additions": 0, "deletions": 467, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fxnmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fxnmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxnmake.adb?ref=476ed6bf66ab20e22ae4b3da0fd7fd94753f2334", "patch": "@@ -1,467 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                          GNAT SYSTEM UTILITIES                           --\n---                                                                          --\n---                               X N M A K E                                --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2021, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Program to construct the spec and body of the Nmake package\n-\n---    Input files:\n-\n---       sinfo.ads     Spec of Sinfo package\n---       nmake.adt     Template for Nmake package\n-\n---    Output files:\n-\n---       nmake.ads     Spec of Nmake package\n---       nmake.adb     Body of Nmake package\n-\n---  Note: this program assumes that sinfo.ads has passed the error checks that\n---  are carried out by the csinfo utility, so it does not duplicate these\n---  checks and assumes that sinfo.ads has the correct form.\n-\n---   In the absence of any switches, both the ads and adb files are output.\n---   The switch -s or /s indicates that only the ads file is to be output.\n---   The switch -b or /b indicates that only the adb file is to be output.\n-\n---   If a file name argument is given, then the output is written to this file\n---   rather than to nmake.ads or nmake.adb. A file name can only be given if\n---   exactly one of the -s or -b options is present.\n-\n-with Ada.Command_Line;              use Ada.Command_Line;\n-with Ada.Strings.Unbounded;         use Ada.Strings.Unbounded;\n-with Ada.Strings.Unbounded.Text_IO; use Ada.Strings.Unbounded.Text_IO;\n-with Ada.Strings.Maps;              use Ada.Strings.Maps;\n-with Ada.Strings.Maps.Constants;    use Ada.Strings.Maps.Constants;\n-with Ada.Streams.Stream_IO;         use Ada.Streams.Stream_IO;\n-with Ada.Text_IO;                   use Ada.Text_IO;\n-\n-with GNAT.Spitbol;                  use GNAT.Spitbol;\n-with GNAT.Spitbol.Patterns;         use GNAT.Spitbol.Patterns;\n-\n-with XUtil;\n-\n-procedure XNmake is\n-\n-   Err : exception;\n-   --  Raised to terminate execution\n-\n-   A        : VString := Nul;\n-   Arg      : VString := Nul;\n-   Arg_List : VString := Nul;\n-   Comment  : VString := Nul;\n-   Default  : VString := Nul;\n-   Field    : VString := Nul;\n-   Line     : VString := Nul;\n-   Node     : VString := Nul;\n-   Op_Name  : VString := Nul;\n-   Prevl    : VString := Nul;\n-   Synonym  : VString := Nul;\n-   X        : VString := Nul;\n-\n-   NWidth : Natural;\n-\n-   FileS : VString := V (\"nmake.ads\");\n-   FileB : VString := V (\"nmake.adb\");\n-   --  Set to null if corresponding file not to be generated\n-\n-   Given_File : VString := Nul;\n-   --  File name given by command line argument\n-\n-   subtype Sfile is Ada.Streams.Stream_IO.File_Type;\n-\n-   InS,  InT  : Ada.Text_IO.File_Type;\n-   OutS, OutB : Sfile;\n-\n-   wsp : constant Pattern := Span (' ' & ASCII.HT);\n-\n-   Body_Only : constant Pattern := BreakX (' ') * X\n-                                   & Span (' ') & \"--  body only\";\n-   Spec_Only : constant Pattern := BreakX (' ') * X\n-                                   & Span (' ') & \"--  spec only\";\n-\n-   Node_Hdr  : constant Pattern := wsp & \"--  N_\" & Rest * Node;\n-   Punc      : constant Pattern := BreakX (\" .,\");\n-\n-   Binop     : constant Pattern := wsp\n-                                   & \"--  plus fields for binary operator\";\n-   Unop      : constant Pattern := wsp\n-                                   & \"--  plus fields for unary operator\";\n-   Syn       : constant Pattern := wsp & \"--  \" & Break (' ') * Synonym\n-                                   & \" (\" & Break (')') * Field\n-                                   & Rest * Comment;\n-\n-   Templ     : constant Pattern := BreakX ('T') * A & \"T e m p l a t e\";\n-   Spec      : constant Pattern := BreakX ('S') * A & \"S p e c\";\n-\n-   Sem_Field : constant Pattern := BreakX ('-') & \"-Sem\";\n-   Lib_Field : constant Pattern := BreakX ('-') & \"-Lib\";\n-\n-   Get_Field : constant Pattern := BreakX (Decimal_Digit_Set) * Field;\n-\n-   Get_Dflt  : constant Pattern := BreakX ('(') & \"(set to \"\n-                                   & Break (\" \") * Default & \" if\";\n-\n-   Next_Arg  : constant Pattern := Break (',') * Arg & ',';\n-\n-   Op_Node   : constant Pattern := \"Op_\" & Rest * Op_Name;\n-\n-   Shft_Rot  : constant Pattern := \"Shift_\" or \"Rotate_\";\n-\n-   No_Ent    : constant Pattern := \"Or_Else\" or \"And_Then\"\n-                                     or \"In\" or \"Not_In\";\n-\n-   M : Match_Result;\n-\n-   V_String_Id : constant VString := V (\"String_Id\");\n-   V_Node_Id   : constant VString := V (\"Node_Id\");\n-   V_Name_Id   : constant VString := V (\"Name_Id\");\n-   V_List_Id   : constant VString := V (\"List_Id\");\n-   V_Elist_Id  : constant VString := V (\"Elist_Id\");\n-   V_Boolean   : constant VString := V (\"Boolean\");\n-\n-   procedure Put_Line (F : Sfile; S : String)  renames XUtil.Put_Line;\n-   procedure Put_Line (F : Sfile; S : VString) renames XUtil.Put_Line;\n-   --  Local version of Put_Line ensures Unix style line endings\n-\n-   procedure WriteS  (S : String);\n-   procedure WriteB  (S : String);\n-   procedure WriteBS (S : String);\n-   procedure WriteS  (S : VString);\n-   procedure WriteB  (S : VString);\n-   procedure WriteBS (S : VString);\n-   --  Write given line to spec or body file or both if active\n-\n-   procedure WriteB (S : String) is\n-   begin\n-      if FileB /= Nul then\n-         Put_Line (OutB, S);\n-      end if;\n-   end WriteB;\n-\n-   procedure WriteB (S : VString) is\n-   begin\n-      if FileB /= Nul then\n-         Put_Line (OutB, S);\n-      end if;\n-   end WriteB;\n-\n-   procedure WriteBS (S : String) is\n-   begin\n-      if FileB /= Nul then\n-         Put_Line (OutB, S);\n-      end if;\n-\n-      if FileS /= Nul then\n-         Put_Line (OutS, S);\n-      end if;\n-   end WriteBS;\n-\n-   procedure WriteBS (S : VString) is\n-   begin\n-      if FileB /= Nul then\n-         Put_Line (OutB, S);\n-      end if;\n-\n-      if FileS /= Nul then\n-         Put_Line (OutS, S);\n-      end if;\n-   end WriteBS;\n-\n-   procedure WriteS (S : String) is\n-   begin\n-      if FileS /= Nul then\n-         Put_Line (OutS, S);\n-      end if;\n-   end WriteS;\n-\n-   procedure WriteS (S : VString) is\n-   begin\n-      if FileS /= Nul then\n-         Put_Line (OutS, S);\n-      end if;\n-   end WriteS;\n-\n---  Start of processing for XNmake\n-\n-begin\n-   NWidth := 28;\n-   Anchored_Mode := True;\n-\n-   for ArgN in 1 .. Argument_Count loop\n-      declare\n-         Arg : constant String := Argument (ArgN);\n-\n-      begin\n-         if Arg (1) = '-' then\n-            if Arg'Length = 2\n-              and then (Arg (2) = 'b' or else Arg (2) = 'B')\n-            then\n-               FileS := Nul;\n-\n-            elsif Arg'Length = 2\n-              and then (Arg (2) = 's' or else Arg (2) = 'S')\n-            then\n-               FileB := Nul;\n-\n-            else\n-               raise Err;\n-            end if;\n-\n-         else\n-            if Given_File /= Nul then\n-               raise Err;\n-            else\n-               Given_File := V (Arg);\n-            end if;\n-         end if;\n-      end;\n-   end loop;\n-\n-   if FileS = Nul and then FileB = Nul then\n-      raise Err;\n-\n-   elsif Given_File /= Nul then\n-      if FileB = Nul then\n-         FileS := Given_File;\n-\n-      elsif FileS = Nul then\n-         FileB := Given_File;\n-\n-      else\n-         raise Err;\n-      end if;\n-   end if;\n-\n-   Open (InS, In_File, \"sinfo.ads\");\n-   Open (InT, In_File, \"nmake.adt\");\n-\n-   if FileS /= Nul then\n-      Create (OutS, Out_File, S (FileS));\n-   end if;\n-\n-   if FileB /= Nul then\n-      Create (OutB, Out_File, S (FileB));\n-   end if;\n-\n-   Anchored_Mode := True;\n-\n-   --  Copy initial part of template to spec and body\n-\n-   loop\n-      Line := Get_Line (InT);\n-\n-      --  Skip lines describing the template\n-\n-      if Match (Line, \"--  This file is a template\") then\n-         loop\n-            Line := Get_Line (InT);\n-            exit when Line = \"\";\n-         end loop;\n-      end if;\n-\n-      --  Loop keeps going until \"package\" keyword written\n-\n-      exit when Match (Line, \"package\");\n-\n-      --  Deal with WITH lines, writing to body or spec as appropriate\n-\n-      if Match (Line, Body_Only, M) then\n-         Replace (M, X);\n-         WriteB (Line);\n-\n-      elsif Match (Line, Spec_Only, M) then\n-         Replace (M, X);\n-         WriteS (Line);\n-\n-      --  Change header from Template to Spec and write to spec file\n-\n-      else\n-         if Match (Line, Templ, M) then\n-            Replace (M, A &  \"    S p e c    \");\n-         end if;\n-\n-         WriteS (Line);\n-\n-         --  Write header line to body file\n-\n-         if Match (Line, Spec, M) then\n-            Replace (M, A &  \"B o d y\");\n-         end if;\n-\n-         WriteB (Line);\n-      end if;\n-   end loop;\n-\n-   --  Package line reached\n-\n-   WriteS (\"package Nmake is\");\n-   WriteB (\"package body Nmake is\");\n-   WriteB (\"\");\n-\n-   --  Copy rest of lines up to template insert point to spec only\n-\n-   loop\n-      Line := Get_Line (InT);\n-      exit when Match (Line, \"!!TEMPLATE INSERTION POINT\");\n-      WriteS (Line);\n-   end loop;\n-\n-   --  Here we are doing the actual insertions, loop through node types\n-\n-   loop\n-      Line := Get_Line (InS);\n-\n-      if Match (Line, Node_Hdr)\n-        and then not Match (Node, Punc)\n-        and then Node /= \"Unused\"\n-      then\n-         exit when Node = \"Empty\";\n-         Prevl := \"   function Make_\" & Node & \" (Sloc : Source_Ptr\";\n-         Arg_List := Nul;\n-\n-         --  Loop through fields of one node\n-\n-         loop\n-            Line := Get_Line (InS);\n-            exit when Line = \"\";\n-\n-            if Match (Line, Binop) then\n-               WriteBS (Prevl & ';');\n-               Append (Arg_List, \"Left_Opnd,Right_Opnd,\");\n-               WriteBS (\n-                 \"      \" & Rpad (\"Left_Opnd\",  NWidth) & \" : Node_Id;\");\n-               Prevl :=\n-                 \"      \" & Rpad (\"Right_Opnd\", NWidth) & \" : Node_Id\";\n-\n-            elsif Match (Line, Unop) then\n-               WriteBS (Prevl & ';');\n-               Append (Arg_List, \"Right_Opnd,\");\n-               Prevl := \"      \" & Rpad (\"Right_Opnd\", NWidth) & \" : Node_Id\";\n-\n-            elsif Match (Line, Syn) then\n-               if         Synonym /= \"Prev_Ids\"\n-                 and then Synonym /= \"More_Ids\"\n-                 and then Synonym /= \"Comes_From_Source\"\n-                 and then Synonym /= \"Paren_Count\"\n-                 and then not Match (Field, Sem_Field)\n-                 and then not Match (Field, Lib_Field)\n-               then\n-                  Match (Field, Get_Field);\n-\n-                  if    Field = \"Str\"   then\n-                     Field := V_String_Id;\n-                  elsif Field = \"Node\"  then\n-                     Field := V_Node_Id;\n-                  elsif Field = \"Name\"  then\n-                     Field := V_Name_Id;\n-                  elsif Field = \"List\"  then\n-                     Field := V_List_Id;\n-                  elsif Field = \"Elist\" then\n-                     Field := V_Elist_Id;\n-                  elsif Field = \"Flag\"  then\n-                     Field := V_Boolean;\n-                  end if;\n-\n-                  if Field = \"Boolean\" then\n-                     Default := V (\"False\");\n-                  else\n-                     Default := Nul;\n-                  end if;\n-\n-                  Match (Comment, Get_Dflt);\n-\n-                  WriteBS (Prevl & ';');\n-                  Append (Arg_List, Synonym & ',');\n-                  Rpad (Synonym, NWidth);\n-\n-                  if Default = \"\" then\n-                     Prevl := \"      \" & Synonym & \" : \" & Field;\n-                  else\n-                     Prevl :=\n-                       \"      \" & Synonym & \" : \" & Field & \" := \" & Default;\n-                  end if;\n-               end if;\n-            end if;\n-         end loop;\n-\n-         WriteBS (Prevl & ')');\n-         WriteS (\"      return Node_Id;\");\n-         WriteS (\"   pragma Inline (Make_\" & Node & \");\");\n-         WriteB (\"      return Node_Id\");\n-         WriteB (\"   is\");\n-         WriteB (\"      N : constant Node_Id :=\");\n-\n-         if Match (Node, \"Defining_Identifier\") or else\n-            Match (Node, \"Defining_Character\")  or else\n-            Match (Node, \"Defining_Operator\")\n-         then\n-            WriteB (\"            New_Entity (N_\" & Node & \", Sloc);\");\n-         else\n-            WriteB (\"            New_Node (N_\" & Node & \", Sloc);\");\n-         end if;\n-\n-         WriteB (\"   begin\");\n-\n-         while Match (Arg_List, Next_Arg, \"\") loop\n-            if Length (Arg) < NWidth then\n-               WriteB (\"      Set_\" & Arg & \" (N, \" & Arg & \");\");\n-            else\n-               WriteB (\"      Set_\" & Arg);\n-               WriteB (\"        (N, \" & Arg & \");\");\n-            end if;\n-         end loop;\n-\n-         if Match (Node, Op_Node) then\n-            if Node = \"Op_Plus\" then\n-               WriteB (\"      Set_Chars (N, Name_Op_Add);\");\n-\n-            elsif Node = \"Op_Minus\" then\n-               WriteB (\"      Set_Chars (N, Name_Op_Subtract);\");\n-\n-            elsif Match (Op_Name, Shft_Rot) then\n-               WriteB (\"      Set_Chars (N, Name_\" & Op_Name & \");\");\n-\n-            else\n-               WriteB (\"      Set_Chars (N, Name_\" & Node & \");\");\n-            end if;\n-\n-            if not Match (Op_Name, No_Ent) then\n-               WriteB (\"      Set_Entity (N, Standard_\" & Node & \");\");\n-            end if;\n-         end if;\n-\n-         WriteB (\"      return N;\");\n-         WriteB (\"   end Make_\" & Node & ';');\n-         WriteBS (\"\");\n-      end if;\n-   end loop;\n-\n-   WriteBS (\"end Nmake;\");\n-\n-exception\n-\n-   when Err =>\n-      Put_Line (Standard_Error, \"usage: xnmake [-b] [-s] [filename]\");\n-      Set_Exit_Status (1);\n-\n-end XNmake;"}, {"sha": "c4488d9fd94593c5bcfa68a54d677628165d1519", "filename": "gcc/ada/xsinfo.adb", "status": "removed", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fxsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fxsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxsinfo.adb?ref=476ed6bf66ab20e22ae4b3da0fd7fd94753f2334", "patch": "@@ -1,262 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                          GNAT SYSTEM UTILITIES                           --\n---                                                                          --\n---                               X S I N F O                                --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2021, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Program to construct C header file sinfo.h (C version of sinfo.ads spec,\n---  for use by Gigi, contains all definitions and access functions, but does\n---  not contain set procedures, since Gigi never modifies the GNAT tree)\n-\n---    Input files:\n-\n---       sinfo.ads     Spec of Sinfo package\n-\n---    Output files:\n-\n---       sinfo.h       Corresponding c header file\n-\n---  An optional argument allows the specification of an output file name to\n---  override the default sinfo.h file name for the generated output file.\n-\n-with Ada.Command_Line;              use Ada.Command_Line;\n-with Ada.Strings.Unbounded;         use Ada.Strings.Unbounded;\n-with Ada.Strings.Unbounded.Text_IO; use Ada.Strings.Unbounded.Text_IO;\n-with Ada.Text_IO;                   use Ada.Text_IO;\n-\n-with GNAT.Spitbol;                  use GNAT.Spitbol;\n-with GNAT.Spitbol.Patterns;         use GNAT.Spitbol.Patterns;\n-\n-with CSinfo;\n-\n-procedure XSinfo is\n-\n-   Done : exception;\n-   Err  : exception;\n-\n-   A         : VString := Nul;\n-   Arg       : VString := Nul;\n-   Comment   : VString := Nul;\n-   Line      : VString := Nul;\n-   N         : VString := Nul;\n-   N1, N2    : VString := Nul;\n-   Nam       : VString := Nul;\n-   Rtn       : VString := Nul;\n-   Term      : VString := Nul;\n-\n-   InS   : File_Type;\n-   Ofile : File_Type;\n-\n-   wsp     : constant Pattern := Span (' ' & ASCII.HT);\n-   Wsp_For : constant Pattern := wsp & \"for\";\n-   Is_Cmnt : constant Pattern := wsp & \"--\";\n-   Typ_Nod : constant Pattern := wsp * A & \"type Node_Kind is\";\n-   Get_Nam : constant Pattern := wsp * A & \"N_\" &  Break (\",)\") * Nam\n-                                 & Len (1) * Term;\n-   Sub_Typ : constant Pattern := wsp * A & \"subtype \" &  Break (' ') * N;\n-   No_Cont : constant Pattern := wsp & Break (' ') * N1\n-                                 & \" .. \" & Break (';') * N2;\n-   Cont_N1 : constant Pattern := wsp & Break (' ') * N1 & \" ..\" & Rpos (0);\n-   Cont_N2 : constant Pattern := Span (' ') & Break (';') * N2;\n-   Is_Func : constant Pattern := wsp * A & \"function \" & Rest * Nam;\n-   Get_Arg : constant Pattern := wsp & \"(N : \" & Break (')') * Arg\n-                                 & \") return \" & Break (';') * Rtn\n-                                 & ';' & wsp & \"--\" & wsp & Rest * Comment;\n-\n-   NKV : Natural;\n-\n-   M : Match_Result;\n-\n-   procedure Getline;\n-   --  Get non-comment, non-blank line. Also skips \"for \" rep clauses\n-\n-   -------------\n-   -- Getline --\n-   -------------\n-\n-   procedure Getline is\n-   begin\n-      loop\n-         Line := Get_Line (InS);\n-\n-         if Line /= \"\"\n-           and then not Match (Line, Wsp_For)\n-           and then not Match (Line, Is_Cmnt)\n-         then\n-            return;\n-\n-         elsif Match (Line, \"   --  End functions (note\") then\n-            raise Done;\n-         end if;\n-      end loop;\n-   end Getline;\n-\n---  Start of processing for XSinfo\n-\n-begin\n-   --  First run CSinfo to check for errors. Note that CSinfo is also a\n-   --  stand-alone program that can be run separately.\n-\n-   CSinfo;\n-\n-   Set_Exit_Status (1);\n-   Anchored_Mode := True;\n-\n-   if Argument_Count > 0 then\n-      Create (Ofile, Out_File, Argument (1));\n-   else\n-      Create (Ofile, Out_File, \"sinfo.h\");\n-   end if;\n-\n-   Open (InS, In_File, \"sinfo.ads\");\n-\n-   --  Write header to output file\n-\n-   loop\n-      Line := Get_Line (InS);\n-      exit when Line = \"\";\n-\n-      Match\n-        (Line,\n-         \"--                                 S p e c       \",\n-         \"--                              C Header File    \");\n-\n-      Match (Line, \"--\", \"/*\");\n-      Match (Line, Rtab (2) * A & \"--\", M);\n-      Replace (M, A & \"*/\");\n-      Put_Line (Ofile, Line);\n-   end loop;\n-\n-   --  Skip to package line\n-\n-   loop\n-      Getline;\n-      exit when Match (Line, \"package\");\n-   end loop;\n-\n-   --  Skip to first node kind line\n-\n-   loop\n-      Getline;\n-      exit when Match (Line, Typ_Nod);\n-      Put_Line (Ofile, Line);\n-   end loop;\n-\n-   Put_Line (Ofile, \"\");\n-\n-   Put_Line (Ofile, \"#ifdef __cplusplus\");\n-   Put_Line (Ofile, \"extern \"\"C\"\" {\");\n-   Put_Line (Ofile, \"#endif\");\n-\n-   NKV := 0;\n-\n-   --  Loop through node kind codes\n-\n-   loop\n-      Getline;\n-\n-      if Match (Line, Get_Nam) then\n-         Put_Line (Ofile, A & \"#define N_\" & Nam & ' ' & NKV);\n-         NKV := NKV + 1;\n-         exit when not Match (Term, \",\");\n-\n-      else\n-         Put_Line (Ofile, Line);\n-      end if;\n-   end loop;\n-\n-   Put_Line (Ofile, \"\");\n-   Put_Line (Ofile, A & \"#define Number_Node_Kinds \" & NKV);\n-\n-   --  Loop through subtype declarations\n-\n-   loop\n-      Getline;\n-\n-      if not Match (Line, Sub_Typ) then\n-         exit when Match (Line, \"   function\");\n-         Put_Line (Ofile, Line);\n-\n-      else\n-         Put_Line (Ofile, A & \"SUBTYPE (\" & N & \", Node_Kind, \");\n-         Getline;\n-\n-         --  Normal case\n-\n-         if Match (Line, No_Cont) then\n-            Put_Line (Ofile, A & \"   \" & N1 & \", \" & N2 & ')');\n-\n-         --  Continuation case\n-\n-         else\n-            if not Match (Line, Cont_N1) then\n-               raise Err;\n-            end if;\n-\n-            Getline;\n-\n-            if not Match (Line, Cont_N2) then\n-               raise Err;\n-            end if;\n-\n-            Put_Line (Ofile,  A & \"   \" & N1 & ',');\n-            Put_Line (Ofile,  A & \"   \" & N2 & ')');\n-         end if;\n-      end if;\n-   end loop;\n-\n-   --  Loop through functions. Note that this loop is terminated by\n-   --  the call to Getfile encountering the end of functions sentinel\n-\n-   loop\n-      if Match (Line, Is_Func) then\n-         Getline;\n-            if not Match (Line, Get_Arg) then\n-               raise Err;\n-            end if;\n-         Put_Line\n-           (Ofile,\n-            A &  \"INLINE \" & Rpad (Rtn, 9)\n-            & ' ' & Rpad (Nam, 30) & \" (\" & Arg & \" N)\");\n-\n-         Put_Line (Ofile,  A & \"   { return \" & Comment & \" (N); }\");\n-\n-      else\n-         Put_Line (Ofile, Line);\n-      end if;\n-\n-      Getline;\n-   end loop;\n-\n-   --  Can't get here since above loop only left via raise\n-\n-exception\n-   when Done =>\n-      Close (InS);\n-      Put_Line (Ofile, \"\");\n-      Put_Line (Ofile, \"#ifdef __cplusplus\");\n-      Put_Line (Ofile, \"}\");\n-      Put_Line (Ofile, \"#endif\");\n-      Close (Ofile);\n-      Set_Exit_Status (0);\n-\n-end XSinfo;"}, {"sha": "f6410a8072c9082f1fdc2117de320114e95f71ae", "filename": "gcc/ada/xtreeprs.adb", "status": "removed", "additions": 0, "deletions": 357, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fxtreeprs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476ed6bf66ab20e22ae4b3da0fd7fd94753f2334/gcc%2Fada%2Fxtreeprs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxtreeprs.adb?ref=476ed6bf66ab20e22ae4b3da0fd7fd94753f2334", "patch": "@@ -1,357 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                          GNAT SYSTEM UTILITIES                           --\n---                                                                          --\n---                             X T R E E P R S                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2021, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Program to construct the spec of the Treeprs package\n-\n---    Input files:\n-\n---       sinfo.ads     Spec of Sinfo package\n---       treeprs.adt   Template for Treeprs package\n-\n---    Output files:\n-\n---       treeprs.ads   Spec of Treeprs package\n-\n---  Note: this program assumes that sinfo.ads has passed the error checks which\n---  are carried out by the CSinfo utility so it does not duplicate these checks\n-\n---  An optional argument allows the specification of an output file name to\n---  override the default treeprs.ads file name for the generated output file.\n-\n-with Ada.Command_Line;              use Ada.Command_Line;\n-with Ada.Strings.Unbounded;         use Ada.Strings.Unbounded;\n-with Ada.Strings.Unbounded.Text_IO; use Ada.Strings.Unbounded.Text_IO;\n-with Ada.Text_IO;                   use Ada.Text_IO;\n-with Ada.Streams.Stream_IO;         use Ada.Streams.Stream_IO;\n-\n-with GNAT.Spitbol;                  use GNAT.Spitbol;\n-with GNAT.Spitbol.Patterns;         use GNAT.Spitbol.Patterns;\n-with GNAT.Spitbol.Table_Boolean;    use GNAT.Spitbol.Table_Boolean;\n-with GNAT.Spitbol.Table_VString;    use GNAT.Spitbol.Table_VString;\n-\n-procedure XTreeprs is\n-\n-   package TB renames GNAT.Spitbol.Table_Boolean;\n-   package TV renames GNAT.Spitbol.Table_VString;\n-\n-   Err : exception;\n-   --  Raised on fatal error\n-\n-   A         : VString := Nul;\n-   Ffield    : VString := Nul;\n-   Field     : VString := Nul;\n-   Fieldno   : VString := Nul;\n-   Flagno    : VString := Nul;\n-   Line      : VString := Nul;\n-   Name      : VString := Nul;\n-   Node      : VString := Nul;\n-   Outstring : VString := Nul;\n-   Prefix    : VString := Nul;\n-   S         : VString := Nul;\n-   S1        : VString := Nul;\n-   Syn       : VString := Nul;\n-   Synonym   : VString := Nul;\n-   Term      : VString := Nul;\n-\n-   subtype Sfile is Ada.Streams.Stream_IO.File_Type;\n-\n-   OutS : Sfile;\n-   --  Output file\n-\n-   InS : Ada.Text_IO.File_Type;\n-   --  Read sinfo.ads\n-\n-   InT : Ada.Text_IO.File_Type;\n-   --  Read treeprs.adt\n-\n-   Special : TB.Table (20);\n-   --  Table of special fields. These fields are not included in the table\n-   --  constructed by Xtreeprs, since they are specially handled in treeprs.\n-   --  This means these field definitions are completely ignored.\n-\n-   Names : array (1 .. 500) of VString;\n-   --  Table of names of synonyms\n-\n-   Positions : array (1 .. 500) of Natural;\n-   --  Table of starting positions in Pchars string for synonyms\n-\n-   Strings : TV.Table (300);\n-   --  Contribution of each synonym to Pchars string, indexed by name\n-\n-   Count  : Natural := 0;\n-   --  Number of synonyms processed so far\n-\n-   Curpos : Natural := 1;\n-   --  Number of characters generated in Pchars string so far\n-\n-   Lineno : Natural := 0;\n-   --  Line number in sinfo.ads\n-\n-   Field_Base : constant := Character'Pos ('#');\n-   --  Fields 1-5 are represented by the characters #$%&' (i.e. by five\n-   --  contiguous characters starting at # (16#23#)).\n-\n-   Flag_Base : constant := Character'Pos ('(');\n-   --  Flags 1-18 are represented by the characters ()*+,-./0123456789\n-   --  (i.e. by 18 contiguous characters starting at (16#28#)).\n-\n-   Fieldch : Character;\n-   --  Field character, as per above tables\n-\n-   Sp : aliased Natural;\n-   --  Space left on line for Pchars output\n-\n-   wsp      : constant Pattern := Span (' ' & ASCII.HT);\n-   Is_Temp  : constant Pattern := BreakX ('T') * A & \"T e m p l a t e\";\n-   Get_Node : constant Pattern := wsp & \"--  N_\" & Rest * Node;\n-   Tst_Punc : constant Pattern := Break (\" ,.\");\n-   Get_Syn  : constant Pattern := Span (' ') & \"--  \" & Break (' ') * Synonym\n-                                  & \" (\" & Break (')') * Field;\n-   Brk_Min  : constant Pattern := Break ('-') * Ffield;\n-   Is_Flag  : constant Pattern := \"Flag\" & Rest * Flagno;\n-   Is_Field : constant Pattern := Rtab (1) & Len (1) * Fieldno;\n-   Is_Syn   : constant Pattern := wsp & \"N_\" & Break (\",)\") * Syn\n-                                  & Len (1) * Term;\n-   Brk_Node : constant Pattern := Break (' ') * Node & ' ';\n-   Chop_SP  : constant Pattern := Len (Sp'Unrestricted_Access) * S1;\n-\n-   M : Match_Result;\n-\n-   procedure Put_Line (F : Sfile; S : String);\n-   procedure Put_Line (F : Sfile; S : VString);\n-   --  Local version of Put_Line ensures Unix style line endings\n-\n-   procedure Put_Line (F : Sfile; S : String) is\n-   begin\n-      String'Write (Stream (F), S);\n-      Character'Write (Stream (F), ASCII.LF);\n-   end Put_Line;\n-\n-   procedure Put_Line (F : Sfile; S : VString) is\n-   begin\n-      Put_Line (F, To_String (S));\n-   end Put_Line;\n-\n---  Start of processing for XTreeprs\n-\n-begin\n-   Anchored_Mode := True;\n-\n-   if Argument_Count > 0 then\n-      Create (OutS, Out_File, Argument (1));\n-   else\n-      Create (OutS, Out_File, \"treeprs.ads\");\n-   end if;\n-\n-   Open (InS, In_File, \"sinfo.ads\");\n-   Open (InT, In_File, \"treeprs.adt\");\n-\n-   --  Initialize special fields table\n-\n-   Set (Special, \"Analyzed\",                True);\n-   Set (Special, \"Cannot_Be_Constant\",      True);\n-   Set (Special, \"Chars\",                   True);\n-   Set (Special, \"Comes_From_Source\",       True);\n-   Set (Special, \"Error_Posted\",            True);\n-   Set (Special, \"Etype\",                   True);\n-   Set (Special, \"Has_No_Side_Effects\",     True);\n-   Set (Special, \"Is_Controlling_Actual\",   True);\n-   Set (Special, \"Is_Overloaded\",           True);\n-   Set (Special, \"Is_Static_Expression\",    True);\n-   Set (Special, \"Left_Opnd\",               True);\n-   Set (Special, \"Must_Check_Expr\",         True);\n-   Set (Special, \"No_Overflow_Expr\",        True);\n-   Set (Special, \"Paren_Count\",             True);\n-   Set (Special, \"Raises_Constraint_Error\", True);\n-   Set (Special, \"Right_Opnd\",              True);\n-\n-   --  Read template header and generate new header\n-\n-   loop\n-      Line := Get_Line (InT);\n-\n-      --  Skip lines describing the template\n-\n-      if Match (Line, \"--  This file is a template\") then\n-         loop\n-            Line := Get_Line (InT);\n-            exit when Line = \"\";\n-         end loop;\n-      end if;\n-\n-      exit when Match (Line, \"package\");\n-\n-      if Match (Line, Is_Temp, M) then\n-         Replace (M, A & \"    S p e c    \");\n-      end if;\n-\n-      Put_Line (OutS, Line);\n-   end loop;\n-\n-   Put_Line (OutS, Line);\n-\n-   --  Copy rest of comments up to template insert point to spec\n-\n-   loop\n-      Line := Get_Line (InT);\n-      exit when Match (Line, \"!!TEMPLATE INSERTION POINT\");\n-      Put_Line (OutS, Line);\n-   end loop;\n-\n-   --  Here we are doing the actual insertions\n-\n-   Put_Line (OutS, \"   Pchars : constant String :=\");\n-\n-   --  Loop through comments describing nodes, picking up fields\n-\n-   loop\n-      Line := Get_Line (InS);\n-      Lineno := Lineno + 1;\n-      exit when Match (Line, \"   type Node_Kind\");\n-\n-      if Match (Line, Get_Node)\n-        and then not Match (Node, Tst_Punc)\n-      then\n-         Outstring := Node & ' ';\n-\n-         loop\n-            Line := Get_Line (InS);\n-            exit when Line = \"\";\n-\n-            if Match (Line, Get_Syn)\n-              and then not Match (Synonym, \"plus\")\n-              and then not Present (Special, Synonym)\n-            then\n-               --  Convert this field into the character used to\n-               --  represent the field according to the table:\n-\n-               --    Field1       '#'\n-               --    Field2       '$'\n-               --    Field3       '%'\n-               --    Field4       '&'\n-               --    Field5       \"'\"\n-               --    Flag4        '+'\n-               --    Flag5        ','\n-               --    Flag6        '-'\n-               --    Flag7        '.'\n-               --    Flag8        '/'\n-               --    Flag9        '0'\n-               --    Flag10       '1'\n-               --    Flag11       '2'\n-               --    Flag12       '3'\n-               --    Flag13       '4'\n-               --    Flag14       '5'\n-               --    Flag15       '6'\n-               --    Flag16       '7'\n-               --    Flag17       '8'\n-               --    Flag18       '9'\n-\n-               if Match (Field, Brk_Min) then\n-                  Field := Ffield;\n-               end if;\n-\n-               if Match (Field, Is_Flag) then\n-                  Fieldch := Char (Flag_Base - 1 + N (Flagno));\n-\n-               elsif Match (Field, Is_Field) then\n-                  Fieldch := Char (Field_Base - 1 + N (Fieldno));\n-\n-               else\n-                  Put_Line\n-                    (Standard_Error,\n-                     \"*** Line \" &\n-                      Lineno &\n-                      \" has unrecognized field name \" &\n-                      Field);\n-                  raise Err;\n-               end if;\n-\n-               Append (Outstring, Fieldch & Synonym);\n-            end if;\n-         end loop;\n-\n-         Set (Strings, Node, Outstring);\n-      end if;\n-   end loop;\n-\n-   --  Loop through actual definitions of node kind enumeration literals\n-\n-   loop\n-      loop\n-         Line := Get_Line (InS);\n-         Lineno := Lineno + 1;\n-         exit when Match (Line, Is_Syn);\n-      end loop;\n-\n-      S := Get (Strings, Syn);\n-      Match (S, Brk_Node, \"\");\n-      Count := Count + 1;\n-      Names (Count) := Syn;\n-      Positions (Count) := Curpos;\n-      Curpos := Curpos + Length (S);\n-      Put_Line (OutS, \"      --  \" & Node);\n-      Prefix := V (\"      \");\n-      exit when Term = \")\";\n-\n-      --  Loop to output the string literal for Pchars\n-\n-      loop\n-         Sp := 79 - 4 - Length (Prefix);\n-         exit when Size (S) <= Sp;\n-         Match (S, Chop_SP, \"\");\n-         Put_Line (OutS, Prefix & '\"' & S1 & \"\"\" &\");\n-         Prefix := V (\"         \");\n-      end loop;\n-\n-      Put_Line (OutS, Prefix & '\"' & S & \"\"\" &\");\n-   end loop;\n-\n-   Put_Line (OutS, \"      \"\"\"\";\");\n-   Put_Line (OutS, \"\");\n-   Put_Line\n-     (OutS, \"   type Pchar_Pos_Array is array (Node_Kind) of Positive;\");\n-   Put_Line\n-     (OutS,\n-      \"   Pchar_Pos : constant Pchar_Pos_Array := Pchar_Pos_Array'(\");\n-\n-   --  Output lines for Pchar_Pos_Array values\n-\n-   for M in 1 .. Count - 1 loop\n-      Name := Rpad (\"N_\" & Names (M), 40);\n-      Put_Line (OutS, \"      \" & Name & \" => \" & Positions (M) & ',');\n-   end loop;\n-\n-   Name := Rpad (\"N_\" & Names (Count), 40);\n-   Put_Line (OutS, \"      \" & Name & \" => \" & Positions (Count) & \");\");\n-\n-   Put_Line (OutS, \"\");\n-   Put_Line (OutS, \"end Treeprs;\");\n-\n-exception\n-   when Err =>\n-      Put_Line (Standard_Error, \"*** fatal error\");\n-      Set_Exit_Status (1);\n-\n-end XTreeprs;"}, {"sha": "055a2693f49eb1cfd4af6e40f77fa71651616469", "filename": "gnattools/Makefile.in", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f9c7f44fffb0b03266730b137313fe79f1c99e/gnattools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f9c7f44fffb0b03266730b137313fe79f1c99e/gnattools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gnattools%2FMakefile.in?ref=76f9c7f44fffb0b03266730b137313fe79f1c99e", "patch": "@@ -170,14 +170,18 @@ $(GCC_DIR)/stamp-gnatlib-rts:\n         fi\n \n \n-# Build directory for the tools. Let's copy the target-dependent\n-# sources using the same mechanism as for gnatlib. The other sources are\n-# accessed using the vpath directive in ada/Makefile.in\n+# Build directory for the tools. We first need to copy the generated files,\n+# then the target-dependent sources using the same mechanism as for gnatlib.\n+\n+GENERATED_FILES_FOR_TOOLS = \\\n+  einfo-entities.ads einfo-entities.adb sdefault.adb seinfo.ads \\\n+  sinfo-nodes.ads sinfo-nodes.adb snames.ads snames.adb\n \n $(GCC_DIR)/stamp-tools:\n \t-rm -rf $(GCC_DIR)/ada/tools\n \t-mkdir -p $(GCC_DIR)/ada/tools\n-\t-(cd $(GCC_DIR)/ada/tools; $(LN_S) ../sdefault.adb ../snames.ads ../snames.adb .)\n+\t-(cd $(GCC_DIR)/ada/tools; $(foreach FILE,$(GENERATED_FILES_FOR_TOOLS), \\\n+\t\t\t     $(LN_S) ../$(FILE) $(FILE);))\n \t-$(foreach PAIR,$(TOOLS_TARGET_PAIRS), \\\n \t          rm -f $(GCC_DIR)/ada/tools/$(word 1,$(subst <, ,$(PAIR)));\\\n \t          $(LN_S) $(fsrcdir)/ada/$(word 2,$(subst <, ,$(PAIR))) \\"}]}